commit 0ad903b226a1ea6bde5c18272dab73d924436b84
Author: code <wbpcode@users.noreply.github.com>
Date:   Thu Apr 8 02:58:03 2021 +0800

    dubbo proxy: support parsing parameters and attachment of dubbo request (#15308)
    
    This PR is an enhancement and supplement to dubbo proxy. Although the original dubbo proxy provided a complete API, many functions did not provide complete implementation, such as headers matching, parameters matching, group matching, etc.
    For more information, please refer to issues: #15131 #14391 #14529
    
    This PR uses  [hessian2-codes](https://github.com/alibaba/hessian2-codec) for dubbo request decoding and encoding. Thanks very much to the main contributor of [hessian2-codes](https://github.com/alibaba/hessian2-codec) @zyfjeff
    
    Additional Description:
    
    hessian2-codec dependency policy check list:
    
    MUST
    - [x] Cloud Native Computing Foundation (CNCF) approved license
    - [x] Dependencies must not substantially increase the binary size unless they are optional (i.e. confined to specific extensions)
    - [x] No duplication of existing dependencies
    - [x] Hosted on a git repository and the archive fetch must directly reference this repository. We will NOT support intermediate artifacts built by-hand located on GCS, S3, etc.
    - [x] CVE history appears reasonable, no pathological CVE arcs
    - [x] Code review (ideally PRs) before merge
    - [x] Security vulnerability process exists, with contact details and reporting/disclosure process
    - [x] Tests run in CI
    
    SHOULD
    
    - [x] > 1 contributor responsible for a non-trivial number of commits
    - [ ] High test coverage (also static/dynamic analysis, fuzzing)
    - [ ] Envoy can obtain advanced notification of vulnerabilities or of security releases
    - [ ] Do other significant projects have shared fate by using this dependency?
    - [ ] Releases (with release notes)
    - [x] Commits/releases in last 90 days
    
    coverage:
    * Overall: 87%
    * Core: 91%
    
    Risk Level: Normal.
    Testing: Added.
    Docs Changes: N/A
    Release Notes: N/A
    
    Signed-off-by: wbpcode <comems@msn.com>

diff --git a/bazel/repositories.bzl b/bazel/repositories.bzl
index cf0e7ba947..c143dc01c3 100644
--- a/bazel/repositories.bzl
+++ b/bazel/repositories.bzl
@@ -101,104 +101,105 @@ def _rust_deps():
 def envoy_dependencies(skip_targets = []):
     # Setup Envoy developer tools.
     envoy_dev_binding()
 
     # Treat Envoy's overall build config as an external repo, so projects that
     # build Envoy as a subcomponent can easily override the config.
     if "envoy_build_config" not in native.existing_rules().keys():
         _default_envoy_build_config(name = "envoy_build_config")
 
     # Setup external Bazel rules
     _foreign_cc_dependencies()
 
     # Binding to an alias pointing to the selected version of BoringSSL:
     # - BoringSSL FIPS from @boringssl_fips//:ssl,
     # - non-FIPS BoringSSL from @boringssl//:ssl.
     _boringssl()
     _boringssl_fips()
     native.bind(
         name = "ssl",
         actual = "@envoy//bazel:boringssl",
     )
 
     # The long repo names (`com_github_fmtlib_fmt` instead of `fmtlib`) are
     # semi-standard in the Bazel community, intended to avoid both duplicate
     # dependencies and name conflicts.
     _com_github_c_ares_c_ares()
     _com_github_circonus_labs_libcircllhist()
     _com_github_cyan4973_xxhash()
     _com_github_datadog_dd_opentracing_cpp()
     _com_github_mirror_tclap()
     _com_github_envoyproxy_sqlparser()
     _com_github_fmtlib_fmt()
     _com_github_gabime_spdlog()
     _com_github_google_benchmark()
     _com_github_google_jwt_verify()
     _com_github_google_libprotobuf_mutator()
     _com_github_google_tcmalloc()
     _com_github_gperftools_gperftools()
     _com_github_grpc_grpc()
     _com_github_jbeder_yaml_cpp()
     _com_github_libevent_libevent()
     _com_github_luajit_luajit()
     _com_github_moonjit_moonjit()
     _com_github_nghttp2_nghttp2()
     _com_github_skyapm_cpp2sky()
     _com_github_nodejs_http_parser()
+    _com_github_alibaba_hessian2_codec()
     _com_github_tencent_rapidjson()
     _com_github_nlohmann_json()
     _com_github_ncopa_suexec()
     _com_google_absl()
     _com_google_googletest()
     _com_google_protobuf()
     _io_opencensus_cpp()
     _com_github_curl()
     _com_github_envoyproxy_sqlparser()
     _com_googlesource_chromium_v8()
     _com_googlesource_quiche()
     _com_googlesource_googleurl()
     _com_lightstep_tracer_cpp()
     _io_opentracing_cpp()
     _net_zlib()
     _com_github_zlib_ng_zlib_ng()
     _org_brotli()
     _upb()
     _proxy_wasm_cpp_sdk()
     _proxy_wasm_cpp_host()
     _emscripten_toolchain()
     _rules_fuzzing()
     external_http_archive("proxy_wasm_rust_sdk")
     external_http_archive("com_googlesource_code_re2")
     _com_google_cel_cpp()
     external_http_archive("com_github_google_flatbuffers")
     external_http_archive("bazel_toolchains")
     external_http_archive("bazel_compdb")
     external_http_archive("envoy_build_tools")
     external_http_archive("rules_cc")
 
     # Unconditional, since we use this only for compiler-agnostic fuzzing utils.
     _org_llvm_releases_compiler_rt()
 
     _python_deps()
     _cc_deps()
     _go_deps(skip_targets)
     _rust_deps()
     _kafka_deps()
 
     _org_llvm_llvm()
     _com_github_wavm_wavm()
     _com_github_wasmtime()
     _com_github_wasm_c_api()
 
     switched_rules_by_language(
         name = "com_google_googleapis_imports",
         cc = True,
         go = True,
         grpc = True,
         rules_override = {
             "py_proto_library": "@envoy_api//bazel:api_build_system.bzl",
         },
     )
     native.bind(
         name = "bazel_runfiles",
         actual = "@bazel_tools//tools/cpp/runfiles",
     )
@@ -478,6 +479,17 @@ def _com_github_nodejs_http_parser():
         actual = "@com_github_nodejs_http_parser//:http_parser",
     )
 
+def _com_github_alibaba_hessian2_codec():
+    external_http_archive("com_github_alibaba_hessian2_codec")
+    native.bind(
+        name = "hessian2_codec_object_codec_lib",
+        actual = "@com_github_alibaba_hessian2_codec//hessian2/basic_codec:object_codec_lib",
+    )
+    native.bind(
+        name = "hessian2_codec_codec_impl",
+        actual = "@com_github_alibaba_hessian2_codec//hessian2:codec_impl_lib",
+    )
+
 def _com_github_ncopa_suexec():
     external_http_archive(
         name = "com_github_ncopa_suexec",
diff --git a/bazel/repository_locations.bzl b/bazel/repository_locations.bzl
index 2a6a28f50e..653318d76c 100644
--- a/bazel/repository_locations.bzl
+++ b/bazel/repository_locations.bzl
@@ -1,1034 +1,1047 @@
 # This should match the schema defined in external_deps.bzl.
 REPOSITORY_LOCATIONS_SPEC = dict(
     bazel_compdb = dict(
         project_name = "bazel-compilation-database",
         project_desc = "Clang JSON compilation database support for Bazel",
         project_url = "https://github.com/grailbio/bazel-compilation-database",
         version = "0.4.5",
         sha256 = "bcecfd622c4ef272fd4ba42726a52e140b961c4eac23025f18b346c968a8cfb4",
         strip_prefix = "bazel-compilation-database-{version}",
         urls = ["https://github.com/grailbio/bazel-compilation-database/archive/{version}.tar.gz"],
         release_date = "2020-08-01",
         use_category = ["build"],
     ),
     bazel_gazelle = dict(
         project_name = "Gazelle",
         project_desc = "Bazel BUILD file generator for Go projects",
         project_url = "https://github.com/bazelbuild/bazel-gazelle",
         version = "0.22.2",
         sha256 = "b85f48fa105c4403326e9525ad2b2cc437babaa6e15a3fc0b1dbab0ab064bc7c",
         urls = ["https://github.com/bazelbuild/bazel-gazelle/releases/download/v{version}/bazel-gazelle-v{version}.tar.gz"],
         release_date = "2020-10-02",
         use_category = ["build"],
     ),
     bazel_toolchains = dict(
         project_name = "bazel-toolchains",
         project_desc = "Bazel toolchain configs for RBE",
         project_url = "https://github.com/bazelbuild/bazel-toolchains",
         version = "3.7.2",
         sha256 = "1caf8584434d3e31be674067996be787cfa511fda2a0f05811131b588886477f",
         strip_prefix = "bazel-toolchains-{version}",
         urls = [
             "https://github.com/bazelbuild/bazel-toolchains/releases/download/{version}/bazel-toolchains-{version}.tar.gz",
             "https://mirror.bazel.build/github.com/bazelbuild/bazel-toolchains/archive/{version}.tar.gz",
         ],
         release_date = "2021-01-07",
         use_category = ["build"],
     ),
     build_bazel_rules_apple = dict(
         project_name = "Apple Rules for Bazel",
         project_desc = "Bazel rules for Apple platforms",
         project_url = "https://github.com/bazelbuild/rules_apple",
         version = "0.19.0",
         sha256 = "7a7afdd4869bb201c9352eed2daf37294d42b093579b70423490c1b4d4f6ce42",
         urls = ["https://github.com/bazelbuild/rules_apple/releases/download/{version}/rules_apple.{version}.tar.gz"],
         release_date = "2019-10-10",
         use_category = ["build"],
     ),
     rules_fuzzing = dict(
         project_name = "Fuzzing Rules for Bazel",
         project_desc = "Bazel rules for fuzz tests",
         project_url = "https://github.com/bazelbuild/rules_fuzzing",
         version = "0.1.3",
         sha256 = "ce99c277c4e9e21f77222757936bf7ffb8823911497db84bdd57a796588fcf01",
         strip_prefix = "rules_fuzzing-{version}",
         urls = ["https://github.com/bazelbuild/rules_fuzzing/archive/v{version}.tar.gz"],
         release_date = "2021-04-01",
         use_category = ["test_only"],
         implied_untracked_deps = [
             # This is a repository rule generated to define an OSS-Fuzz fuzzing
             # engine target from the CFLAGS/CXXFLAGS environment.
             "rules_fuzzing_oss_fuzz",
         ],
     ),
     envoy_build_tools = dict(
         project_name = "envoy-build-tools",
         project_desc = "Common build tools shared by the Envoy/UDPA ecosystem",
         project_url = "https://github.com/envoyproxy/envoy-build-tools",
         version = "d36336060aa1ade024654dec009adc4a19e3efd6",
         sha256 = "7b379e69eafb883cebb52a5ed11b1a12710dd77a33de79c0bc207f6458a5f712",
         strip_prefix = "envoy-build-tools-{version}",
         urls = ["https://github.com/envoyproxy/envoy-build-tools/archive/{version}.tar.gz"],
         release_date = "2021-01-28",
         use_category = ["build"],
     ),
     boringssl = dict(
         project_name = "BoringSSL",
         project_desc = "Minimal OpenSSL fork",
         project_url = "https://github.com/google/boringssl",
         # To update BoringSSL, which tracks Chromium releases:
         # 1. Open https://omahaproxy.appspot.com/ and note <current_version> of linux/stable release.
         # 2. Open https://chromium.googlesource.com/chromium/src/+/refs/tags/<current_version>/DEPS and note <boringssl_revision>.
         # 3. Find a commit in BoringSSL's "master-with-bazel" branch that merges <boringssl_revision>.
         #
         # chromium-90.0.4395.0(linux/dev)
         version = "b049eae83d25977661556dcd913b35fbafb3a93a",
         sha256 = "d78f7b11b8665feea1b6def8e6f235ad8671db8de950f5429f1bf2b3503b3894",
         strip_prefix = "boringssl-{version}",
         urls = ["https://github.com/google/boringssl/archive/{version}.tar.gz"],
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2021-01-25",
         cpe = "cpe:2.3:a:google:boringssl:*",
     ),
     boringssl_fips = dict(
         project_name = "BoringSSL (FIPS)",
         project_desc = "FIPS compliant BoringSSL",
         project_url = "https://boringssl.googlesource.com/boringssl/+/master/crypto/fipsmodule/FIPS.md",
         version = "fips-20190808",
         sha256 = "3b5fdf23274d4179c2077b5e8fa625d9debd7a390aac1d165b7e47234f648bb8",
         urls = ["https://commondatastorage.googleapis.com/chromium-boringssl-fips/boringssl-ae223d6138807a13006342edfeef32e813246b39.tar.xz"],
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2019-08-08",
         cpe = "cpe:2.3:a:google:boringssl:*",
     ),
     com_google_absl = dict(
         project_name = "Abseil",
         project_desc = "Open source collection of C++ libraries drawn from the most fundamental pieces of Google’s internal codebase",
         project_url = "https://abseil.io/",
         version = "5d8fc9192245f0ea67094af57399d7931d6bd53f",
         sha256 = "e3812f256dd7347a33bf9d93a950cf356c61c0596842ff07d8154cd415145d83",
         strip_prefix = "abseil-cpp-{version}",
         urls = ["https://github.com/abseil/abseil-cpp/archive/{version}.tar.gz"],
         use_category = ["dataplane_core", "controlplane"],
         release_date = "2020-11-24",
         cpe = "N/A",
     ),
     com_github_c_ares_c_ares = dict(
         project_name = "c-ares",
         project_desc = "C library for asynchronous DNS requests",
         project_url = "https://c-ares.haxx.se/",
         version = "1.17.1",
         sha256 = "d73dd0f6de824afd407ce10750ea081af47eba52b8a6cb307d220131ad93fc40",
         strip_prefix = "c-ares-{version}",
         urls = ["https://github.com/c-ares/c-ares/releases/download/cares-{underscore_version}/c-ares-{version}.tar.gz"],
         use_category = ["dataplane_core", "controlplane"],
         release_date = "2020-11-19",
         cpe = "cpe:2.3:a:c-ares_project:c-ares:*",
     ),
     com_github_circonus_labs_libcircllhist = dict(
         project_name = "libcircllhist",
         project_desc = "An implementation of Circonus log-linear histograms",
         project_url = "https://github.com/circonus-labs/libcircllhist",
         version = "63a16dd6f2fc7bc841bb17ff92be8318df60e2e1",
         sha256 = "8165aa25e529d7d4b9ae849d3bf30371255a99d6db0421516abcff23214cdc2c",
         strip_prefix = "libcircllhist-{version}",
         urls = ["https://github.com/circonus-labs/libcircllhist/archive/{version}.tar.gz"],
         use_category = ["controlplane", "observability_core", "dataplane_core"],
         release_date = "2019-02-11",
         cpe = "N/A",
     ),
     com_github_cyan4973_xxhash = dict(
         project_name = "xxHash",
         project_desc = "Extremely fast hash algorithm",
         project_url = "https://github.com/Cyan4973/xxHash",
         version = "0.7.3",
         sha256 = "952ebbf5b11fbf59ae5d760a562d1e9112278f244340ad7714e8556cbe54f7f7",
         strip_prefix = "xxHash-{version}",
         urls = ["https://github.com/Cyan4973/xxHash/archive/v{version}.tar.gz"],
         use_category = ["dataplane_core", "controlplane"],
         release_date = "2020-03-05",
         cpe = "N/A",
     ),
     com_github_envoyproxy_sqlparser = dict(
         project_name = "C++ SQL Parser Library",
         project_desc = "Forked from Hyrise SQL Parser",
         project_url = "https://github.com/envoyproxy/sql-parser",
         version = "3b40ba2d106587bdf053a292f7e3bb17e818a57f",
         sha256 = "96c10c8e950a141a32034f19b19cdeb1da48fe859cf96ae5e19f894f36c62c71",
         strip_prefix = "sql-parser-{version}",
         urls = ["https://github.com/envoyproxy/sql-parser/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = [
             "envoy.filters.network.mysql_proxy",
             "envoy.filters.network.postgres_proxy",
         ],
         release_date = "2020-06-10",
         cpe = "N/A",
     ),
     com_github_mirror_tclap = dict(
         project_name = "tclap",
         project_desc = "Small, flexible library that provides a simple interface for defining and accessing command line arguments",
         project_url = "http://tclap.sourceforge.net",
         version = "1-2-1",
         sha256 = "f0ede0721dddbb5eba3a47385a6e8681b14f155e1129dd39d1a959411935098f",
         strip_prefix = "tclap-tclap-{version}-release-final",
         urls = ["https://github.com/mirror/tclap/archive/tclap-{version}-release-final.tar.gz"],
         release_date = "2011-04-16",
         use_category = ["other"],
     ),
     com_github_fmtlib_fmt = dict(
         project_name = "fmt",
         project_desc = "{fmt} is an open-source formatting library providing a fast and safe alternative to C stdio and C++ iostreams",
         project_url = "https://fmt.dev",
         version = "7.0.3",
         sha256 = "decfdf9ad274070fa85f26407b816f5a4d82205ae86bac1990be658d0795ea4d",
         strip_prefix = "fmt-{version}",
         urls = ["https://github.com/fmtlib/fmt/releases/download/{version}/fmt-{version}.zip"],
         use_category = ["dataplane_core", "controlplane"],
         release_date = "2020-08-06",
         cpe = "cpe:2.3:a:fmt:fmt:*",
     ),
     com_github_gabime_spdlog = dict(
         project_name = "spdlog",
         project_desc = "Very fast, header-only/compiled, C++ logging library",
         project_url = "https://github.com/gabime/spdlog",
         version = "1.7.0",
         sha256 = "f0114a4d3c88be9e696762f37a7c379619443ce9d668546c61b21d41affe5b62",
         strip_prefix = "spdlog-{version}",
         urls = ["https://github.com/gabime/spdlog/archive/v{version}.tar.gz"],
         use_category = ["dataplane_core", "controlplane"],
         release_date = "2020-07-09",
         cpe = "N/A",
     ),
     com_github_google_libprotobuf_mutator = dict(
         project_name = "libprotobuf-mutator",
         project_desc = "Library to randomly mutate protobuffers",
         project_url = "https://github.com/google/libprotobuf-mutator",
         version = "1.0",
         sha256 = "792f250fb546bde8590e72d64311ea00a70c175fd77df6bb5e02328fa15fe28e",
         strip_prefix = "libprotobuf-mutator-{version}",
         urls = ["https://github.com/google/libprotobuf-mutator/archive/v{version}.tar.gz"],
         release_date = "2020-11-06",
         use_category = ["test_only"],
     ),
     com_github_google_tcmalloc = dict(
         project_name = "tcmalloc",
         project_desc = "Fast, multi-threaded malloc implementation",
         project_url = "https://github.com/google/tcmalloc",
         version = "9f385356c34d4fc11f76a000b609e2b446c20667",
         sha256 = "652e48e0b9ef645db04bff8a3d4841c60ce07275f5d98e18e698dc92bd111291",
         strip_prefix = "tcmalloc-{version}",
         urls = ["https://github.com/google/tcmalloc/archive/{version}.tar.gz"],
         use_category = ["dataplane_core", "controlplane"],
         release_date = "2020-11-04",
         cpe = "N/A",
     ),
     com_github_gperftools_gperftools = dict(
         project_name = "gperftools",
         project_desc = "tcmalloc and profiling libraries",
         project_url = "https://github.com/gperftools/gperftools",
         version = "2.8",
         sha256 = "240deacdd628b6459671b83eb0c4db8e97baadf659f25b92e9a078d536bd513e",
         strip_prefix = "gperftools-{version}",
         urls = ["https://github.com/gperftools/gperftools/releases/download/gperftools-{version}/gperftools-{version}.tar.gz"],
         release_date = "2020-07-06",
         use_category = ["dataplane_core", "controlplane"],
         cpe = "cpe:2.3:a:gperftools_project:gperftools:*",
     ),
     com_github_grpc_grpc = dict(
         project_name = "gRPC",
         project_desc = "gRPC C core library",
         project_url = "https://grpc.io",
         version = "1.34.0",
         sha256 = "7372a881122cd85a7224435a1d58bc5e11c88d4fb98a64b83f36f3d1c2f16d39",
         strip_prefix = "grpc-{version}",
         urls = ["https://github.com/grpc/grpc/archive/v{version}.tar.gz"],
         use_category = ["dataplane_core", "controlplane"],
         release_date = "2020-12-01",
         cpe = "cpe:2.3:a:grpc:grpc:*",
     ),
     com_github_luajit_luajit = dict(
         project_name = "LuaJIT",
         project_desc = "Just-In-Time compiler for Lua",
         project_url = "https://luajit.org",
         # The last release version, 2.1.0-beta3 has a number of CVEs filed
         # against it. These may not impact correct non-malicious Lua code, but for prudence we bump.
         version = "1d8b747c161db457e032a023ebbff511f5de5ec2",
         sha256 = "20a159c38a98ecdb6368e8d655343b6036622a29a1621da9dc303f7ed9bf37f3",
         strip_prefix = "LuaJIT-{version}",
         urls = ["https://github.com/LuaJIT/LuaJIT/archive/{version}.tar.gz"],
         release_date = "2020-10-12",
         use_category = ["dataplane_ext"],
         extensions = ["envoy.filters.http.lua"],
         cpe = "cpe:2.3:a:luajit:luajit:*",
     ),
     com_github_moonjit_moonjit = dict(
         project_name = "Moonjit",
         project_desc = "LuaJIT fork with wider platform support",
         project_url = "https://github.com/moonjit/moonjit",
         version = "2.2.0",
         sha256 = "83deb2c880488dfe7dd8ebf09e3b1e7613ef4b8420de53de6f712f01aabca2b6",
         strip_prefix = "moonjit-{version}",
         urls = ["https://github.com/moonjit/moonjit/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = ["envoy.filters.http.lua"],
         release_date = "2020-01-14",
         cpe = "cpe:2.3:a:moonjit_project:moonjit:*",
     ),
     com_github_nghttp2_nghttp2 = dict(
         project_name = "Nghttp2",
         project_desc = "Implementation of HTTP/2 and its header compression algorithm HPACK in Cimplementation of HTTP/2 and its header compression algorithm HPACK in C",
         project_url = "https://nghttp2.org",
         version = "1.42.0",
         sha256 = "884d18a0158908125d58b1b61d475c0325e5a004e3d61a56b5fcc55d5f4b7af5",
         strip_prefix = "nghttp2-{version}",
         urls = ["https://github.com/nghttp2/nghttp2/releases/download/v{version}/nghttp2-{version}.tar.gz"],
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2020-11-23",
         cpe = "cpe:2.3:a:nghttp2:nghttp2:*",
     ),
     io_opentracing_cpp = dict(
         project_name = "OpenTracing",
         project_desc = "Vendor-neutral APIs and instrumentation for distributed tracing",
         project_url = "https://opentracing.io",
         version = "1.5.1",
         sha256 = "015c4187f7a6426a2b5196f0ccd982aa87f010cf61f507ae3ce5c90523f92301",
         strip_prefix = "opentracing-cpp-{version}",
         urls = ["https://github.com/opentracing/opentracing-cpp/archive/v{version}.tar.gz"],
         use_category = ["observability_ext"],
         extensions = [
             "envoy.tracers.datadog",
             "envoy.tracers.dynamic_ot",
             "envoy.tracers.lightstep",
         ],
         release_date = "2019-01-16",
         cpe = "N/A",
     ),
     com_lightstep_tracer_cpp = dict(
         project_name = "lightstep-tracer-cpp",
         project_desc = "LightStep distributed tracing library for C++",
         project_url = "https://github.com/lightstep/lightstep-tracer-cpp",
         version = "1942b3f142e218ebc143a043f32e3278dafec9aa",
         sha256 = "3238921a8f578beb26c2215cd277e8f6752f3d29b020b881d60d96a240a38aed",
         strip_prefix = "lightstep-tracer-cpp-{version}",
         urls = ["https://github.com/lightstep/lightstep-tracer-cpp/archive/{version}.tar.gz"],
         use_category = ["observability_ext"],
         extensions = ["envoy.tracers.lightstep"],
         release_date = "2020-08-25",
         cpe = "N/A",
     ),
     skywalking_data_collect_protocol = dict(
         project_name = "skywalking-data-collect-protocol",
         project_desc = "Data Collect Protocols of Apache SkyWalking",
         project_url = "https://github.com/apache/skywalking-data-collect-protocol",
         name = "skywalking_data_collect_protocol",
         sha256 = "fa9ac679624217f30b6e8d5c450365386c610e2d08188a20f0340c3b14401833",
         urls = ["https://github.com/apache/skywalking-data-collect-protocol/archive/v8.3.0.zip"],
         strip_prefix = "skywalking-data-collect-protocol-8.3.0",
         version = "8.3.0",
         use_category = ["observability_ext"],
         extensions = ["envoy.tracers.skywalking"],
         release_date = "2020-11-20",
         cpe = "N/A",
     ),
     com_github_skyapm_cpp2sky = dict(
         project_name = "cpp2sky",
         project_desc = "C++ SDK for Apache SkyWalking",
         project_url = "https://github.com/SkyAPM/cpp2sky",
         sha256 = "a8d870bb4b1c4a05eae319f689d1948927f3f0a5b5fe524db73a4c04121a339a",
         version = "0.1.1",
         strip_prefix = "cpp2sky-{version}",
         urls = ["https://github.com/SkyAPM/cpp2sky/archive/v{version}.tar.gz"],
         use_category = ["observability_ext"],
         extensions = ["envoy.tracers.skywalking"],
         release_date = "2021-01-15",
         cpe = "N/A",
     ),
     com_github_datadog_dd_opentracing_cpp = dict(
         project_name = "Datadog OpenTracing C++ Client",
         project_desc = "Datadog OpenTracing C++ Client",
         project_url = "https://github.com/DataDog/dd-opentracing-cpp",
         version = "1.2.1",
         sha256 = "ae44699e4aa2d21b70ed897a6c0cf3ed7dfb411e1aae4e686e39af75cec7c9bf",
         strip_prefix = "dd-opentracing-cpp-{version}",
         urls = ["https://github.com/DataDog/dd-opentracing-cpp/archive/v{version}.tar.gz"],
         use_category = ["observability_ext"],
         extensions = ["envoy.tracers.datadog"],
         release_date = "2021-01-26",
         cpe = "N/A",
     ),
     com_github_google_benchmark = dict(
         project_name = "Benchmark",
         project_desc = "Library to benchmark code snippets",
         project_url = "https://github.com/google/benchmark",
         version = "1.5.1",
         sha256 = "23082937d1663a53b90cb5b61df4bcc312f6dee7018da78ba00dd6bd669dfef2",
         strip_prefix = "benchmark-{version}",
         urls = ["https://github.com/google/benchmark/archive/v{version}.tar.gz"],
         use_category = ["test_only"],
         release_date = "2020-06-09",
     ),
     com_github_libevent_libevent = dict(
         project_name = "libevent",
         project_desc = "Event notification library",
         project_url = "https://libevent.org",
         # This SHA includes the new "prepare" and "check" watchers, used for event loop performance
         # stats (see https://github.com/libevent/libevent/pull/793) and the fix for a race condition
         # in the watchers (see https://github.com/libevent/libevent/pull/802).
         # This also includes the fixes for https://github.com/libevent/libevent/issues/806
         # and https://github.com/lyft/envoy-mobile/issues/215.
         # This also includes the fixes for Phantom events with EV_ET (see
         # https://github.com/libevent/libevent/issues/984).
         # This also includes the wepoll backend for Windows (see
         # https://github.com/libevent/libevent/pull/1006)
         # TODO(adip): Update to v2.2 when it is released.
         version = "62c152d9a7cd264b993dad730c4163c6ede2e0a3",
         sha256 = "4c80e5fe044ce5f8055b20a2f141ee32ec2614000f3e95d2aa81611a4c8f5213",
         strip_prefix = "libevent-{version}",
         urls = ["https://github.com/libevent/libevent/archive/{version}.tar.gz"],
         use_category = ["dataplane_core", "controlplane"],
         release_date = "2020-07-28",
         cpe = "cpe:2.3:a:libevent_project:libevent:*",
     ),
     # This should be removed, see https://github.com/envoyproxy/envoy/issues/13261.
     net_zlib = dict(
         project_name = "zlib",
         project_desc = "zlib compression library",
         project_url = "https://zlib.net",
         version = "79baebe50e4d6b73ae1f8b603f0ef41300110aa3",
         # Use the dev branch of zlib to resolve fuzz bugs and out of bound
         # errors resulting in crashes in zlib 1.2.11.
         # TODO(asraa): Remove when zlib > 1.2.11 is released.
         sha256 = "155a8f8c1a753fb05b16a1b0cc0a0a9f61a78e245f9e0da483d13043b3bcbf2e",
         strip_prefix = "zlib-{version}",
         urls = ["https://github.com/madler/zlib/archive/{version}.tar.gz"],
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2019-04-14",
         cpe = "cpe:2.3:a:gnu:zlib:*",
     ),
     org_brotli = dict(
         project_name = "brotli",
         project_desc = "brotli compression library",
         project_url = "https://brotli.org",
         # Use the dev branch of brotli to resolve compilation issues.
         # TODO(rojkov): Remove when brotli > 1.0.9 is released.
         version = "0cd2e3926e95e7e2930f57ae3f4885508d462a25",
         sha256 = "93810780e60304b51f2c9645fe313a6e4640711063ed0b860cfa60999dd256c5",
         strip_prefix = "brotli-{version}",
         urls = ["https://github.com/google/brotli/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = [
             "envoy.compression.brotli.compressor",
             "envoy.compression.brotli.decompressor",
         ],
         release_date = "2020-09-08",
         cpe = "cpe:2.3:a:google:brotli:*",
     ),
     com_github_zlib_ng_zlib_ng = dict(
         project_name = "zlib-ng",
         project_desc = "zlib fork (higher performance)",
         project_url = "https://github.com/zlib-ng/zlib-ng",
         version = "b802a303ce8b6c86fbe3f93d59e0a82333768c0c",
         sha256 = "e051eade607ecbbfa2c7ed3087fe53e5d3a58325375e1e28209594138e4aa93d",
         strip_prefix = "zlib-ng-{version}",
         urls = ["https://github.com/zlib-ng/zlib-ng/archive/{version}.tar.gz"],
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2020-10-18",
         cpe = "N/A",
     ),
     com_github_jbeder_yaml_cpp = dict(
         project_name = "yaml-cpp",
         project_desc = "YAML parser and emitter in C++ matching the YAML 1.2 spec",
         project_url = "https://github.com/jbeder/yaml-cpp",
         version = "98acc5a8874faab28b82c28936f4b400b389f5d6",
         sha256 = "79ab7069ef1c7c3632e7ffe095f7185d4c77b64d8035db3c085c239d4fe96d5f",
         strip_prefix = "yaml-cpp-{version}",
         urls = ["https://github.com/jbeder/yaml-cpp/archive/{version}.tar.gz"],
         # YAML is also used for runtime as well as controlplane. It shouldn't appear on the
         # dataplane but we can't verify this automatically due to code structure today.
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2020-07-27",
         cpe = "cpe:2.3:a:yaml-cpp_project:yaml-cpp:*",
     ),
     com_github_msgpack_msgpack_c = dict(
         project_name = "msgpack for C/C++",
         project_desc = "MessagePack is an efficient binary serialization format",
         project_url = "https://github.com/msgpack/msgpack-c",
         version = "3.3.0",
         sha256 = "6e114d12a5ddb8cb11f669f83f32246e484a8addd0ce93f274996f1941c1f07b",
         strip_prefix = "msgpack-{version}",
         urls = ["https://github.com/msgpack/msgpack-c/releases/download/cpp-{version}/msgpack-{version}.tar.gz"],
         use_category = ["observability_ext"],
         extensions = ["envoy.tracers.datadog"],
         release_date = "2020-06-05",
         cpe = "N/A",
     ),
     com_github_google_jwt_verify = dict(
         project_name = "jwt_verify_lib",
         project_desc = "JWT verification library for C++",
         project_url = "https://github.com/google/jwt_verify_lib",
         version = "28efec2e4df1072db0ed03597591360ec9f80aac",
         sha256 = "7a5c35b7cbf633398503ae12cad8c2833e92b3a796eed68b6256d22d51ace5e1",
         strip_prefix = "jwt_verify_lib-{version}",
         urls = ["https://github.com/google/jwt_verify_lib/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = ["envoy.filters.http.jwt_authn"],
         release_date = "2020-11-05",
         cpe = "N/A",
     ),
     com_github_nodejs_http_parser = dict(
         project_name = "HTTP Parser",
         project_desc = "Parser for HTTP messages written in C",
         project_url = "https://github.com/nodejs/http-parser",
         # This SHA includes fix for https://github.com/nodejs/http-parser/issues/517 which allows (opt-in) to serve
         # requests with both Content-Legth and Transfer-Encoding: chunked headers set.
         version = "4f15b7d510dc7c6361a26a7c6d2f7c3a17f8d878",
         sha256 = "6a12896313ce1ca630cf516a0ee43a79b5f13f5a5d8143f56560ac0b21c98fac",
         strip_prefix = "http-parser-{version}",
         urls = ["https://github.com/nodejs/http-parser/archive/{version}.tar.gz"],
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2020-07-10",
         cpe = "cpe:2.3:a:nodejs:node.js:*",
     ),
+    com_github_alibaba_hessian2_codec = dict(
+        project_name = "hessian2-codec",
+        project_desc = "hessian2-codec is a C++ library for hessian2 codec",
+        project_url = "https://github.com/alibaba/hessian2-codec.git",
+        version = "dd8e05487a27b367b90ce81f4e6e6f62d693a212",
+        sha256 = "93260c54406e11b7be078a7ea120f7ab0df475c733e68d010fde400c5c8c8162",
+        strip_prefix = "hessian2-codec-{version}",
+        urls = ["https://github.com/alibaba/hessian2-codec/archive/{version}.tar.gz"],
+        use_category = ["dataplane_ext"],
+        extensions = ["envoy.filters.network.dubbo_proxy"],
+        release_date = "2021-04-05",
+        cpe = "N/A",
+    ),
     com_github_tencent_rapidjson = dict(
         project_name = "RapidJSON",
         project_desc = "Fast JSON parser/generator for C++",
         project_url = "https://rapidjson.org",
         version = "dfbe1db9da455552f7a9ad5d2aea17dd9d832ac1",
         sha256 = "a2faafbc402394df0fa94602df4b5e4befd734aad6bb55dfef46f62fcaf1090b",
         strip_prefix = "rapidjson-{version}",
         urls = ["https://github.com/Tencent/rapidjson/archive/{version}.tar.gz"],
         # We're mostly using com_google_protobuf for JSON, but there are some extensions and hard to
         # disentangle uses on the dataplane, e.g. header_formatter, Squash filter.
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2019-12-03",
         cpe = "cpe:2.3:a:tencent:rapidjson:*",
     ),
     com_github_nlohmann_json = dict(
         project_name = "nlohmann JSON",
         project_desc = "Fast JSON parser/generator for C++",
         project_url = "https://nlohmann.github.io/json",
         version = "3.9.1",
         sha256 = "4cf0df69731494668bdd6460ed8cb269b68de9c19ad8c27abc24cd72605b2d5b",
         strip_prefix = "json-{version}",
         urls = ["https://github.com/nlohmann/json/archive/v{version}.tar.gz"],
         # This will be a replacement for rapidJSON used in extensions and may also be a fast
         # replacement for protobuf JSON.
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2020-08-06",
         cpe = "cpe:2.3:a:json_project:json:*",
     ),
     # This is an external dependency needed while running the
     # envoy docker image. A bazel target has been created since
     # there is no binary package available for the utility on Ubuntu
     # which is the base image used to build an envoy container.
     # This is not needed to build an envoy binary or run tests.
     com_github_ncopa_suexec = dict(
         project_name = "su-exec",
         project_desc = "Utility to switch user and group id, setgroups and exec",
         project_url = "https://github.com/ncopa/su-exec",
         version = "212b75144bbc06722fbd7661f651390dc47a43d1",
         sha256 = "939782774079ec156788ea3e04dd5e340e993544f4296be76a9c595334ca1779",
         strip_prefix = "su-exec-{version}",
         urls = ["https://github.com/ncopa/su-exec/archive/{version}.tar.gz"],
         use_category = ["other"],
         release_date = "2019-09-18",
         cpe = "N/A",
     ),
     com_github_twitter_common_lang = dict(
         project_name = "twitter.common.lang (Thrift)",
         project_desc = "twitter.common Python language and compatibility facilities",
         project_url = "https://pypi.org/project/twitter.common.lang",
         version = "0.3.9",
         sha256 = "56d1d266fd4767941d11c27061a57bc1266a3342e551bde3780f9e9eb5ad0ed1",
         strip_prefix = "twitter.common.lang-{version}/src",
         urls = ["https://files.pythonhosted.org/packages/08/bc/d6409a813a9dccd4920a6262eb6e5889e90381453a5f58938ba4cf1d9420/twitter.common.lang-{version}.tar.gz"],
         release_date = "2016-10-17",
         use_category = ["test_only"],
     ),
     com_github_twitter_common_rpc = dict(
         project_name = "twitter.common.rpc (Thrift)",
         project_desc = "twitter.common Thrift helpers including Finagle and SSL transports",
         project_url = "https://pypi.org/project/twitter.common.rpc",
         version = "0.3.9",
         sha256 = "0792b63fb2fb32d970c2e9a409d3d00633190a22eb185145fe3d9067fdaa4514",
         strip_prefix = "twitter.common.rpc-{version}/src",
         urls = ["https://files.pythonhosted.org/packages/be/97/f5f701b703d0f25fbf148992cd58d55b4d08d3db785aad209255ee67e2d0/twitter.common.rpc-{version}.tar.gz"],
         release_date = "2016-10-17",
         use_category = ["test_only"],
     ),
     com_github_twitter_common_finagle_thrift = dict(
         project_name = "twitter.common.finagle-thrift",
         project_desc = "twitter.common Thrift stubs for Zipkin RPC tracing support in Finagle",
         project_url = "https://pypi.org/project/twitter.common.finagle-thrift",
         version = "0.3.9",
         sha256 = "1e3a57d11f94f58745e6b83348ecd4fa74194618704f45444a15bc391fde497a",
         strip_prefix = "twitter.common.finagle-thrift-{version}/src",
         urls = ["https://files.pythonhosted.org/packages/f9/e7/4f80d582578f8489226370762d2cf6bc9381175d1929eba1754e03f70708/twitter.common.finagle-thrift-{version}.tar.gz"],
         release_date = "2016-10-17",
         use_category = ["test_only"],
     ),
     com_google_googletest = dict(
         project_name = "Google Test",
         project_desc = "Google's C++ test framework",
         project_url = "https://github.com/google/googletest",
         # Pick up fix for MOCK_METHOD compilation with clang-cl for Windows (resolved after 1.10.0)
         # see https://github.com/google/googletest/issues/2490
         version = "a4ab0abb93620ce26efad9de9296b73b16e88588",
         sha256 = "7897bfaa5ad39a479177cfb5c3ce010184dbaee22a7c3727b212282871918751",
         strip_prefix = "googletest-{version}",
         urls = ["https://github.com/google/googletest/archive/{version}.tar.gz"],
         release_date = "2020-09-10",
         use_category = ["test_only"],
     ),
     com_google_protobuf = dict(
         project_name = "Protocol Buffers",
         project_desc = "Language-neutral, platform-neutral extensible mechanism for serializing structured data",
         project_url = "https://developers.google.com/protocol-buffers",
         version = "3.14.0",
         sha256 = "6dd0f6b20094910fbb7f1f7908688df01af2d4f6c5c21331b9f636048674aebf",
         strip_prefix = "protobuf-{version}",
         urls = ["https://github.com/protocolbuffers/protobuf/releases/download/v{version}/protobuf-all-{version}.tar.gz"],
         use_category = ["dataplane_core", "controlplane"],
         release_date = "2020-11-13",
         cpe = "cpe:2.3:a:google:protobuf:*",
     ),
     grpc_httpjson_transcoding = dict(
         project_name = "grpc-httpjson-transcoding",
         project_desc = "Library that supports transcoding so that HTTP/JSON can be converted to gRPC",
         project_url = "https://github.com/grpc-ecosystem/grpc-httpjson-transcoding",
         version = "909368951e9a447098f87e41bc49e37810af99f5",
         sha256 = "4be3d92add3e3fad56d09a68b6f3f18367b086a3442275e046e84b3c2bb94d43",
         strip_prefix = "grpc-httpjson-transcoding-{version}",
         urls = ["https://github.com/grpc-ecosystem/grpc-httpjson-transcoding/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = ["envoy.filters.http.grpc_json_transcoder"],
         release_date = "2021-02-24",
         cpe = "N/A",
     ),
     io_bazel_rules_go = dict(
         project_name = "Go rules for Bazel",
         project_desc = "Bazel rules for the Go language",
         project_url = "https://github.com/bazelbuild/rules_go",
         version = "0.25.0",
         sha256 = "6f111c57fd50baf5b8ee9d63024874dd2a014b069426156c55adbf6d3d22cb7b",
         urls = ["https://github.com/bazelbuild/rules_go/releases/download/v{version}/rules_go-v{version}.tar.gz"],
         use_category = ["build", "api"],
         release_date = "2020-12-02",
         implied_untracked_deps = [
             "com_github_golang_protobuf",
             "io_bazel_rules_nogo",
             "org_golang_google_protobuf",
             "org_golang_x_tools",
         ],
     ),
     rules_cc = dict(
         project_name = "C++ rules for Bazel",
         project_desc = "Bazel rules for the C++ language",
         project_url = "https://github.com/bazelbuild/rules_cc",
         # TODO(lizan): pin to a point releases when there's a released version.
         version = "b1c40e1de81913a3c40e5948f78719c28152486d",
         sha256 = "71d037168733f26d2a9648ad066ee8da4a34a13f51d24843a42efa6b65c2420f",
         strip_prefix = "rules_cc-{version}",
         urls = ["https://github.com/bazelbuild/rules_cc/archive/{version}.tar.gz"],
         release_date = "2020-11-11",
         use_category = ["build"],
     ),
     rules_foreign_cc = dict(
         project_name = "Rules for using foreign build systems in Bazel",
         project_desc = "Rules for using foreign build systems in Bazel",
         project_url = "https://github.com/bazelbuild/rules_foreign_cc",
         version = "d54c78ab86b40770ee19f0949db9d74a831ab9f0",
         sha256 = "e7446144277c9578141821fc91c55a61df7ae01bda890902f7286f5fd2f6ae46",
         strip_prefix = "rules_foreign_cc-{version}",
         urls = ["https://github.com/bazelbuild/rules_foreign_cc/archive/{version}.tar.gz"],
         release_date = "2020-10-26",
         use_category = ["build"],
     ),
     rules_python = dict(
         project_name = "Python rules for Bazel",
         project_desc = "Bazel rules for the Python language",
         project_url = "https://github.com/bazelbuild/rules_python",
         version = "0.1.0",
         sha256 = "b6d46438523a3ec0f3cead544190ee13223a52f6a6765a29eae7b7cc24cc83a0",
         release_date = "2020-10-15",
         urls = ["https://github.com/bazelbuild/rules_python/releases/download/{version}/rules_python-{version}.tar.gz"],
         use_category = ["build"],
     ),
     six = dict(
         project_name = "Six",
         project_desc = "Python 2 and 3 compatibility library",
         project_url = "https://pypi.org/project/six",
         version = "1.12.0",
         sha256 = "d16a0141ec1a18405cd4ce8b4613101da75da0e9a7aec5bdd4fa804d0e0eba73",
         urls = ["https://files.pythonhosted.org/packages/dd/bf/4138e7bfb757de47d1f4b6994648ec67a51efe58fa907c1e11e350cddfca/six-{version}.tar.gz"],
         release_date = "2018-12-09",
         use_category = ["other"],
     ),
     org_llvm_llvm = dict(
         project_name = "LLVM",
         project_desc = "LLVM Compiler Infrastructure",
         project_url = "https://llvm.org",
         version = "10.0.0",
         sha256 = "df83a44b3a9a71029049ec101fb0077ecbbdf5fe41e395215025779099a98fdf",
         strip_prefix = "llvm-{version}.src",
         urls = ["https://github.com/llvm/llvm-project/releases/download/llvmorg-{version}/llvm-{version}.src.tar.xz"],
         release_date = "2020-03-23",
         use_category = ["dataplane_ext"],
         extensions = ["envoy.wasm.runtime.wavm"],
         cpe = "cpe:2.3:a:llvm:*:*",
     ),
     com_github_wavm_wavm = dict(
         project_name = "WAVM",
         project_desc = "WebAssembly Virtual Machine",
         project_url = "https://wavm.github.io",
         version = "79c3aa29366615d9b1593cd527e5b4b94cc6072a",
         sha256 = "ce899269516313b400005a8cc9bc3bcd8329663f43f7b4baae211ea0cd456a39",
         strip_prefix = "WAVM-{version}",
         urls = ["https://github.com/WAVM/WAVM/archive/{version}.tar.gz"],
         release_date = "2021-03-31",
         use_category = ["dataplane_ext"],
         extensions = ["envoy.wasm.runtime.wavm"],
         cpe = "cpe:2.3:a:webassembly_virtual_machine_project:webassembly_virtual_machine:*",
     ),
     com_github_wasmtime = dict(
         project_name = "wasmtime",
         project_desc = "A standalone runtime for WebAssembly",
         project_url = "https://github.com/bytecodealliance/wasmtime",
         version = "0.25.0",
         sha256 = "219b79db4084a0f9d720d430d625a676d68dd0228b11cab46fd6c2a649f77034",
         strip_prefix = "wasmtime-{version}",
         urls = ["https://github.com/bytecodealliance/wasmtime/archive/v{version}.tar.gz"],
         release_date = "2021-03-16",
         use_category = ["dataplane_ext"],
         extensions = ["envoy.wasm.runtime.wasmtime"],
         cpe = "N/A",
     ),
     com_github_wasm_c_api = dict(
         project_name = "wasm-c-api",
         project_desc = "WebAssembly C and C++ API",
         project_url = "https://github.com/WebAssembly/wasm-c-api",
         # this is the submodule's specific commit used by wasmtime
         # https://github.com/bytecodealliance/wasmtime/tree/v0.25.0/crates/c-api
         version = "c9d31284651b975f05ac27cee0bab1377560b87e",
         sha256 = "c774044f51431429e878bd1b9e2a4e38932f861f9211df72f75e9427eb6b8d32",
         strip_prefix = "wasm-c-api-{version}",
         urls = ["https://github.com/WebAssembly/wasm-c-api/archive/{version}.tar.gz"],
         release_date = "2021-01-11",
         use_category = ["dataplane_ext"],
         extensions = ["envoy.wasm.runtime.wasmtime"],
         cpe = "N/A",
     ),
     io_opencensus_cpp = dict(
         project_name = "OpenCensus C++",
         project_desc = "OpenCensus tracing library",
         project_url = "https://github.com/census-instrumentation/opencensus-cpp",
         version = "ba631066779a534267fdb1321b19850eb2b0c000",
         sha256 = "f239a40803f6e2e42b57c9e68771b0990c4ca8b2d76b440073cdf14f4211ad26",
         strip_prefix = "opencensus-cpp-{version}",
         urls = ["https://github.com/census-instrumentation/opencensus-cpp/archive/{version}.tar.gz"],
         use_category = ["observability_ext"],
         extensions = ["envoy.tracers.opencensus"],
         release_date = "2020-10-08",
         cpe = "N/A",
     ),
     # This should be removed, see https://github.com/envoyproxy/envoy/issues/11816.
     com_github_curl = dict(
         project_name = "curl",
         project_desc = "Library for transferring data with URLs",
         project_url = "https://curl.haxx.se",
         version = "7.74.0",
         sha256 = "e56b3921eeb7a2951959c02db0912b5fcd5fdba5aca071da819e1accf338bbd7",
         strip_prefix = "curl-{version}",
         urls = ["https://github.com/curl/curl/releases/download/curl-{underscore_version}/curl-{version}.tar.gz"],
         use_category = ["dataplane_ext", "observability_ext"],
         extensions = [
             "envoy.filters.http.aws_lambda",
             "envoy.filters.http.aws_request_signing",
             "envoy.grpc_credentials.aws_iam",
             "envoy.tracers.opencensus",
         ],
         release_date = "2020-12-09",
         cpe = "cpe:2.3:a:haxx:curl:*",
     ),
     com_googlesource_chromium_v8 = dict(
         project_name = "V8",
         project_desc = "Google’s open source high-performance JavaScript and WebAssembly engine, written in C++",
         project_url = "https://v8.dev",
         version = "9.0.257.13",
         # This archive was created using https://storage.googleapis.com/envoyproxy-wee8/wee8-archive.sh
         # and contains complete checkout of V8 with all dependencies necessary to build wee8.
         sha256 = "163e592a9e75da8e561b498861c2d13e653f4d39aed51e0eff9f4d5ff60c8a37",
         urls = ["https://storage.googleapis.com/envoyproxy-wee8/wee8-{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = ["envoy.wasm.runtime.v8"],
         release_date = "2021-03-16",
         cpe = "cpe:2.3:a:google:v8:*",
     ),
     com_googlesource_quiche = dict(
         project_name = "QUICHE",
         project_desc = "QUICHE (QUIC, HTTP/2, Etc) is Google‘s implementation of QUIC and related protocols",
         project_url = "https://quiche.googlesource.com/quiche",
         # Static snapshot of https://quiche.googlesource.com/quiche/+archive/2475cc8246d3e77e391347ae319f0ab9db132fb4.tar.gz
         version = "6fec8e97a1ab1a945b86bd6b7252666294448ddb",
         sha256 = "3045254cbf03c29ee7166fb01b1072a463c58df405669b8573677d4638869290",
         urls = ["https://storage.googleapis.com/quiche-envoy-integration/{version}.tar.gz"],
         use_category = ["dataplane_core"],
         release_date = "2021-02-24",
         cpe = "N/A",
     ),
     com_googlesource_googleurl = dict(
         project_name = "Chrome URL parsing library",
         project_desc = "Chrome URL parsing library",
         project_url = "https://quiche.googlesource.com/googleurl",
         # Static snapshot of https://quiche.googlesource.com/quiche/+archive/ef0d23689e240e6c8de4c3a5296b209128c87373.tar.gz.
         version = "ef0d23689e240e6c8de4c3a5296b209128c87373",
         sha256 = "d769283fed1319bca68bae8bdd47fbc3a7933999329eee850eff1f1ea61ce176",
         urls = ["https://storage.googleapis.com/quiche-envoy-integration/googleurl_{version}.tar.gz"],
         use_category = ["controlplane", "dataplane_core"],
         extensions = [],
         release_date = "2020-07-30",
         cpe = "N/A",
     ),
     com_google_cel_cpp = dict(
         project_name = "Common Expression Language (CEL) C++ library",
         project_desc = "Common Expression Language (CEL) C++ library",
         project_url = "https://opensource.google/projects/cel",
         version = "9841e3ee251f3cc4cd5b6dd9deee6818bc9f2854",
         sha256 = "7e42cbad7d1068d6e7891ad101e2863e727692136d6b3a817c487b3cc7bcfdcc",
         strip_prefix = "cel-cpp-{version}",
         urls = ["https://github.com/google/cel-cpp/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = [
             "envoy.access_loggers.wasm",
             "envoy.bootstrap.wasm",
             "envoy.rate_limit_descriptors.expr",
             "envoy.filters.http.rbac",
             "envoy.filters.http.wasm",
             "envoy.filters.network.rbac",
             "envoy.filters.network.wasm",
             "envoy.stat_sinks.wasm",
         ],
         release_date = "2020-12-17",
         cpe = "N/A",
     ),
     com_github_google_flatbuffers = dict(
         project_name = "FlatBuffers",
         project_desc = "Cross platform serialization library architected for maximum memory efficiency",
         project_url = "https://github.com/google/flatbuffers",
         version = "a83caf5910644ba1c421c002ef68e42f21c15f9f",
         sha256 = "b8efbc25721e76780752bad775a97c3f77a0250271e2db37fc747b20e8b0f24a",
         strip_prefix = "flatbuffers-{version}",
         urls = ["https://github.com/google/flatbuffers/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = [
             "envoy.access_loggers.wasm",
             "envoy.bootstrap.wasm",
             "envoy.rate_limit_descriptors.expr",
             "envoy.filters.http.rbac",
             "envoy.filters.http.wasm",
             "envoy.filters.network.rbac",
             "envoy.filters.network.wasm",
             "envoy.stat_sinks.wasm",
         ],
         release_date = "2020-04-02",
         cpe = "N/A",
     ),
     com_googlesource_code_re2 = dict(
         project_name = "RE2",
         project_desc = "RE2, a regular expression library",
         project_url = "https://github.com/google/re2",
         version = "2020-07-06",
         sha256 = "2e9489a31ae007c81e90e8ec8a15d62d58a9c18d4fd1603f6441ef248556b41f",
         strip_prefix = "re2-{version}",
         urls = ["https://github.com/google/re2/archive/{version}.tar.gz"],
         use_category = ["controlplane", "dataplane_core"],
         release_date = "2020-07-06",
         cpe = "N/A",
     ),
     # Included to access FuzzedDataProvider.h. This is compiler agnostic but
     # provided as part of the compiler-rt source distribution. We can't use the
     # Clang variant as we are not a Clang-LLVM only shop today.
     org_llvm_releases_compiler_rt = dict(
         project_name = "compiler-rt",
         project_desc = "LLVM compiler runtime library",
         project_url = "https://compiler-rt.llvm.org",
         version = "11.0.1",
         sha256 = "087be3f1116e861cd969c9b0b0903c27028b52eaf45157276f50a9c2500687fc",
         # Only allow peeking at fuzzer related files for now.
         strip_prefix = "compiler-rt-{version}.src",
         urls = ["https://github.com/llvm/llvm-project/releases/download/llvmorg-{version}/compiler-rt-{version}.src.tar.xz"],
         release_date = "2020-12-18",
         use_category = ["test_only"],
     ),
     upb = dict(
         project_name = "upb",
         project_desc = "A small protobuf implementation in C (gRPC dependency)",
         project_url = "https://github.com/protocolbuffers/upb",
         version = "de76b31f9c56b28120580d53a6f8d7941fdb79eb",
         sha256 = "487d84ce85065ff89ccde1c1ac2ea1515d2be411306e4adf1be6861dc4a4a86b",
         release_date = "2020-12-29",
         strip_prefix = "upb-{version}",
         urls = ["https://github.com/protocolbuffers/upb/archive/{version}.tar.gz"],
         use_category = ["controlplane"],
         cpe = "N/A",
     ),
     kafka_source = dict(
         project_name = "Kafka (source)",
         project_desc = "Open-source distributed event streaming platform",
         project_url = "https://kafka.apache.org",
         version = "2.4.1",
         sha256 = "740236f44d66e33ea83382383b4fb7eabdab7093a644b525dd5ec90207f933bd",
         strip_prefix = "kafka-{version}/clients/src/main/resources/common/message",
         urls = ["https://github.com/apache/kafka/archive/{version}.zip"],
         use_category = ["dataplane_ext"],
         extensions = ["envoy.filters.network.kafka_broker"],
         release_date = "2020-03-03",
         cpe = "cpe:2.3:a:apache:kafka:*",
     ),
     kafka_server_binary = dict(
         project_name = "Kafka (server binary)",
         project_desc = "Open-source distributed event streaming platform",
         project_url = "https://kafka.apache.org",
         version = "2.4.1",
         sha256 = "2177cbd14118999e1d76fec628ca78ace7e6f841219dbc6035027c796bbe1a2a",
         strip_prefix = "kafka_2.12-{version}",
         urls = ["https://archive.apache.org/dist/kafka/{version}/kafka_2.12-{version}.tgz"],
         release_date = "2020-03-12",
         use_category = ["test_only"],
     ),
     kafka_python_client = dict(
         project_name = "Kafka (Python client)",
         project_desc = "Open-source distributed event streaming platform",
         project_url = "https://kafka.apache.org",
         version = "2.0.1",
         sha256 = "05f7c6eecb402f11fcb7e524c903f1ba1c38d3bdc9bf42bc8ec3cf7567b9f979",
         strip_prefix = "kafka-python-{version}",
         urls = ["https://github.com/dpkp/kafka-python/archive/{version}.tar.gz"],
         release_date = "2020-02-20",
         use_category = ["test_only"],
     ),
     proxy_wasm_cpp_sdk = dict(
         project_name = "WebAssembly for Proxies (C++ SDK)",
         project_desc = "WebAssembly for Proxies (C++ SDK)",
         project_url = "https://github.com/proxy-wasm/proxy-wasm-cpp-sdk",
         version = "258b4c6974dba5255a9c433450971a56b29228ff",
         sha256 = "8ff6231a5f0cc07bc865293e56eb37f60f5fd8d5a3889455c4e4ad9dbe54a5f7",
         strip_prefix = "proxy-wasm-cpp-sdk-{version}",
         urls = ["https://github.com/proxy-wasm/proxy-wasm-cpp-sdk/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = [
             "envoy.access_loggers.wasm",
             "envoy.bootstrap.wasm",
             "envoy.filters.http.wasm",
             "envoy.filters.network.wasm",
             "envoy.stat_sinks.wasm",
             "envoy.wasm.runtime.null",
             "envoy.wasm.runtime.v8",
             "envoy.wasm.runtime.wavm",
             "envoy.wasm.runtime.wasmtime",
         ],
         release_date = "2021-03-10",
         cpe = "N/A",
     ),
     proxy_wasm_cpp_host = dict(
         project_name = "WebAssembly for Proxies (C++ host implementation)",
         project_desc = "WebAssembly for Proxies (C++ host implementation)",
         project_url = "https://github.com/proxy-wasm/proxy-wasm-cpp-host",
         version = "1d4bdb9a4cf9c74387473c25f3db58e23f9118f3",
         sha256 = "6c45a667e5dc56bdb83b30f8a956e5318e4df3dfcf73b68f43c89e459ca05c47",
         strip_prefix = "proxy-wasm-cpp-host-{version}",
         urls = ["https://github.com/proxy-wasm/proxy-wasm-cpp-host/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = [
             "envoy.access_loggers.wasm",
             "envoy.bootstrap.wasm",
             "envoy.filters.http.wasm",
             "envoy.filters.network.wasm",
             "envoy.stat_sinks.wasm",
             "envoy.wasm.runtime.null",
             "envoy.wasm.runtime.v8",
             "envoy.wasm.runtime.wavm",
             "envoy.wasm.runtime.wasmtime",
         ],
         release_date = "2021-04-05",
         cpe = "N/A",
     ),
     proxy_wasm_rust_sdk = dict(
         project_name = "WebAssembly for Proxies (Rust SDK)",
         project_desc = "WebAssembly for Proxies (Rust SDK)",
         project_url = "https://github.com/proxy-wasm/proxy-wasm-rust-sdk",
         version = "28a94df25659b2107b67a11df0112f8f6833558b",
         sha256 = "d3da0042fc119282223b7955962e8b3eed261242c8493f9dc8d07a08ca7e2e3e",
         strip_prefix = "proxy-wasm-rust-sdk-{version}",
         urls = ["https://github.com/proxy-wasm/proxy-wasm-rust-sdk/archive/{version}.tar.gz"],
         use_category = ["test_only"],
         release_date = "2021-02-09",
         cpe = "N/A",
     ),
     emscripten_toolchain = dict(
         project_name = "Emscripten SDK",
         project_desc = "Emscripten SDK (use by Wasm)",
         project_url = "https://github.com/emscripten-core/emsdk",
         version = "2.0.7",
         sha256 = "ce7a5c76e8b425aca874cea329fd9ac44b203b777053453b6a37b4496c5ce34f",
         strip_prefix = "emsdk-{version}",
         urls = ["https://github.com/emscripten-core/emsdk/archive/{version}.tar.gz"],
         use_category = ["build"],
         release_date = "2020-10-13",
     ),
     rules_rust = dict(
         project_name = "Bazel rust rules",
         project_desc = "Bazel rust rules (used by Wasm)",
         project_url = "https://github.com/bazelbuild/rules_rust",
         version = "1b648302edb64d3ddcc159655bf065bff40e6571",
         sha256 = "242deacf4c9e4274d90964689dfae6c245bfb1bfa5e3336b2ad3b44f2541b70c",
         strip_prefix = "rules_rust-{version}",
         urls = ["https://github.com/bazelbuild/rules_rust/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = ["envoy.wasm.runtime.wasmtime"],
         release_date = "2021-04-02",
         cpe = "N/A",
     ),
     rules_antlr = dict(
         project_name = "ANTLR Rules for Bazel",
         project_desc = "Bazel rules for ANTLR",
         project_url = "https://github.com/marcohu/rules_antlr",
         version = "3cc2f9502a54ceb7b79b37383316b23c4da66f9a",
         sha256 = "7249d1569293d9b239e23c65f6b4c81a07da921738bde0dfeb231ed98be40429",
         strip_prefix = "rules_antlr-{version}",
         urls = ["https://github.com/marcohu/rules_antlr/archive/{version}.tar.gz"],
         # ANTLR has a runtime component, so is not purely build.
         use_category = ["dataplane_ext"],
         extensions = [
             "envoy.access_loggers.wasm",
             "envoy.bootstrap.wasm",
             "envoy.rate_limit_descriptors.expr",
             "envoy.filters.http.wasm",
             "envoy.filters.network.wasm",
             "envoy.stat_sinks.wasm",
         ],
         release_date = "2019-06-21",
         cpe = "N/A",
     ),
     antlr4_runtimes = dict(
         project_name = "ANTLR v4",
         project_desc = "ANTLR (ANother Tool for Language Recognition) is a powerful parser generator for reading, processing, executing, or translating structured text or binary files",
         project_url = "https://github.com/antlr/antlr4",
         version = "4.7.2",
         sha256 = "46f5e1af5f4bd28ade55cb632f9a069656b31fc8c2408f9aa045f9b5f5caad64",
         strip_prefix = "antlr4-{version}",
         urls = ["https://github.com/antlr/antlr4/archive/{version}.tar.gz"],
         use_category = ["dataplane_ext"],
         extensions = [
             "envoy.access_loggers.wasm",
             "envoy.bootstrap.wasm",
             "envoy.rate_limit_descriptors.expr",
             "envoy.filters.http.wasm",
             "envoy.filters.network.wasm",
             "envoy.stat_sinks.wasm",
         ],
         release_date = "2018-12-18",
         cpe = "N/A",
     ),
 )
diff --git a/source/extensions/filters/network/dubbo_proxy/BUILD b/source/extensions/filters/network/dubbo_proxy/BUILD
index db011190e6..e051679a29 100644
--- a/source/extensions/filters/network/dubbo_proxy/BUILD
+++ b/source/extensions/filters/network/dubbo_proxy/BUILD
@@ -9,24 +9,16 @@ licenses(["notice"])  # Apache 2
 
 envoy_extension_package()
 
-envoy_cc_library(
-    name = "buffer_helper_lib",
-    srcs = ["buffer_helper.cc"],
-    hdrs = ["buffer_helper.h"],
-    deps = [
-        "//source/common/buffer:buffer_lib",
-        "//source/common/common:assert_lib",
-        "//source/common/common:byte_order_lib",
-        "//source/common/common:safe_memcpy_lib",
-    ],
-)
-
 envoy_cc_library(
     name = "hessian_utils_lib",
     srcs = ["hessian_utils.cc"],
     hdrs = ["hessian_utils.h"],
+    external_deps = [
+        "hessian2_codec_codec_impl",
+        "hessian2_codec_object_codec_lib",
+    ],
     deps = [
-        ":buffer_helper_lib",
+        "//include/envoy/buffer:buffer_interface",
         "//source/common/singleton:const_singleton",
     ],
 )
@@ -34,14 +26,13 @@ envoy_cc_library(
 envoy_cc_library(
     name = "protocol_interface",
     hdrs = ["protocol.h"],
     deps = [
-        ":buffer_helper_lib",
         ":message_lib",
         ":metadata_lib",
         ":serializer_interface",
         "//include/envoy/config:typed_config_interface",
         "//source/common/common:assert_lib",
         "//source/common/config:utility_lib",
         "//source/common/singleton:const_singleton",
     ],
 )
@@ -59,19 +50,18 @@ envoy_cc_library(
 
 envoy_cc_library(
     name = "serializer_interface",
-    srcs = ["serializer_impl.cc"],
     hdrs = [
         "protocol_constants.h",
         "serializer.h",
-        "serializer_impl.h",
     ],
     deps = [
+        ":hessian_utils_lib",
         ":message_lib",
         ":metadata_lib",
         "//include/envoy/buffer:buffer_interface",
         "//include/envoy/config:typed_config_interface",
         "//source/common/common:assert_lib",
         "//source/common/config:utility_lib",
         "//source/common/singleton:const_singleton",
     ],
 )
@@ -79,13 +69,12 @@ envoy_cc_library(
 envoy_cc_library(
     name = "dubbo_hessian2_serializer_impl_lib",
     srcs = ["dubbo_hessian2_serializer_impl.cc"],
     hdrs = [
         "dubbo_hessian2_serializer_impl.h",
     ],
     deps = [
-        ":buffer_helper_lib",
         ":hessian_utils_lib",
         ":serializer_interface",
         "//source/common/singleton:const_singleton",
     ],
 )
@@ -141,12 +130,17 @@ envoy_cc_library(
 
 envoy_cc_library(
     name = "message_lib",
+    srcs = [
+        "message_impl.cc",
+    ],
     hdrs = [
         "message.h",
         "message_impl.h",
     ],
     deps = [
+        ":hessian_utils_lib",
         "//source/common/buffer:buffer_lib",
+        "//source/common/http:header_map_lib",
     ],
 )
 
diff --git a/source/extensions/filters/network/dubbo_proxy/active_message.cc b/source/extensions/filters/network/dubbo_proxy/active_message.cc
index fc98e76a28..e0818cf76b 100644
--- a/source/extensions/filters/network/dubbo_proxy/active_message.cc
+++ b/source/extensions/filters/network/dubbo_proxy/active_message.cc
@@ -32,42 +32,42 @@ DubboFilters::UpstreamResponseStatus ActiveResponseDecoder::onData(Buffer::Insta
 void ActiveResponseDecoder::onStreamDecoded(MessageMetadataSharedPtr metadata,
                                             ContextSharedPtr ctx) {
   ASSERT(metadata->messageType() == MessageType::Response ||
          metadata->messageType() == MessageType::Exception);
   ASSERT(metadata->hasResponseStatus());
 
   metadata_ = metadata;
   if (applyMessageEncodedFilters(metadata, ctx) != FilterStatus::Continue) {
     response_status_ = DubboFilters::UpstreamResponseStatus::Complete;
     return;
   }
 
   if (response_connection_.state() != Network::Connection::State::Open) {
     throw DownstreamConnectionCloseException("Downstream has closed or closing");
   }
 
-  response_connection_.write(ctx->messageOriginData(), false);
+  response_connection_.write(ctx->originMessage(), false);
   ENVOY_LOG(debug,
             "dubbo response: the upstream response message has been forwarded to the downstream");
 
   stats_.response_.inc();
   stats_.response_decoding_success_.inc();
   if (metadata->messageType() == MessageType::Exception) {
     stats_.response_business_exception_.inc();
   }
 
   switch (metadata->responseStatus()) {
   case ResponseStatus::Ok:
     stats_.response_success_.inc();
     break;
   default:
     stats_.response_error_.inc();
     ENVOY_LOG(error, "dubbo response status: {}", static_cast<uint8_t>(metadata->responseStatus()));
     break;
   }
 
   complete_ = true;
   response_status_ = DubboFilters::UpstreamResponseStatus::Complete;
 
   ENVOY_LOG(debug, "dubbo response: complete processing of upstream response messages, id is {}",
             metadata->requestId());
 }
@@ -128,19 +128,19 @@ ActiveMessageDecoderFilter::ActiveMessageDecoderFilter(ActiveMessage& parent,
 void ActiveMessageDecoderFilter::continueDecoding() {
   ASSERT(parent_.context());
   auto state = ActiveMessage::FilterIterationStartState::AlwaysStartFromNext;
-  if (0 != parent_.context()->messageOriginData().length()) {
+  if (0 != parent_.context()->originMessage().length()) {
     state = ActiveMessage::FilterIterationStartState::CanStartFromCurrent;
     ENVOY_LOG(warn, "The original message data is not consumed, triggering the decoder filter from "
                     "the current location");
   }
   const FilterStatus status = parent_.applyDecoderFilters(this, state);
   if (status == FilterStatus::Continue) {
     ENVOY_LOG(debug, "dubbo response: start upstream");
     // All filters have been executed for the current decoder state.
     if (parent_.pendingStreamDecoded()) {
       // If the filter stack was paused during messageEnd, handle end-of-request details.
       parent_.finalizeRequest();
     }
     parent_.continueDecoding();
   }
 }
@@ -170,15 +170,15 @@ ActiveMessageEncoderFilter::ActiveMessageEncoderFilter(ActiveMessage& parent,
 void ActiveMessageEncoderFilter::continueEncoding() {
   ASSERT(parent_.context());
   auto state = ActiveMessage::FilterIterationStartState::AlwaysStartFromNext;
-  if (0 != parent_.context()->messageOriginData().length()) {
+  if (0 != parent_.context()->originMessage().length()) {
     state = ActiveMessage::FilterIterationStartState::CanStartFromCurrent;
     ENVOY_LOG(warn, "The original message data is not consumed, triggering the encoder filter from "
                     "the current location");
   }
   const FilterStatus status = parent_.applyEncoderFilters(this, state);
   if (FilterStatus::Continue == status) {
     ENVOY_LOG(debug, "All encoding filters have been executed");
   }
 }
 
 // class ActiveMessage
diff --git a/source/extensions/filters/network/dubbo_proxy/buffer_helper.cc b/source/extensions/filters/network/dubbo_proxy/buffer_helper.cc
deleted file mode 100644
index 934a8ffb78..0000000000
--- a/source/extensions/filters/network/dubbo_proxy/buffer_helper.cc
+++ /dev/null
@@ -1,30 +0,0 @@
-#include "extensions/filters/network/dubbo_proxy/buffer_helper.h"
-
-namespace Envoy {
-namespace Extensions {
-namespace NetworkFilters {
-namespace DubboProxy {
-
-double BufferHelper::peekDouble(Buffer::Instance& buffer, uint64_t offset) {
-  if (buffer.length() < offset + 8) {
-    throw EnvoyException("buffer underflow");
-  }
-  double i;
-  uint64_t j = buffer.peekBEInt<uint64_t>(offset);
-  safeMemcpy(&i, &j);
-  return i;
-}
-
-float BufferHelper::peekFloat(Buffer::Instance& buffer, uint64_t offset) {
-  if (buffer.length() < offset + 4) {
-    throw EnvoyException("buffer underflow");
-  }
-  float i;
-  uint32_t j = buffer.peekBEInt<uint32_t>(offset);
-  safeMemcpy(&i, &j);
-  return i;
-}
-} // namespace DubboProxy
-} // namespace NetworkFilters
-} // namespace Extensions
-} // namespace Envoy
diff --git a/source/extensions/filters/network/dubbo_proxy/buffer_helper.h b/source/extensions/filters/network/dubbo_proxy/buffer_helper.h
deleted file mode 100644
index cdd25c939f..0000000000
--- a/source/extensions/filters/network/dubbo_proxy/buffer_helper.h
+++ /dev/null
@@ -1,40 +0,0 @@
-#pragma once
-
-#include "envoy/buffer/buffer.h"
-#include "envoy/common/exception.h"
-
-#include "common/common/assert.h"
-#include "common/common/safe_memcpy.h"
-
-namespace Envoy {
-namespace Extensions {
-namespace NetworkFilters {
-namespace DubboProxy {
-
-/**
- * BufferHelper provides buffer operations for reading bytes and numbers in the various encodings
- * used by protocols.
- */
-class BufferHelper {
-public:
-  /**
-   * Reads an double from the buffer at the given offset.
-   * @param buffer Buffer::Instance containing data to decode
-   * @param offset offset into buffer to peek at
-   * @return the double at offset in buffer
-   */
-  static double peekDouble(Buffer::Instance& buffer, uint64_t offset = 0);
-
-  /**
-   * Reads an float from the buffer at the given offset.
-   * @param buffer Buffer::Instance containing data to decode
-   * @param offset offset into buffer to peek at
-   * @return the float at offset in buffer
-   */
-  static float peekFloat(Buffer::Instance& buffer, uint64_t offset = 0);
-};
-
-} // namespace DubboProxy
-} // namespace NetworkFilters
-} // namespace Extensions
-} // namespace Envoy
diff --git a/source/extensions/filters/network/dubbo_proxy/decoder.cc b/source/extensions/filters/network/dubbo_proxy/decoder.cc
index 0f838a9a06..3bd1e79097 100644
--- a/source/extensions/filters/network/dubbo_proxy/decoder.cc
+++ b/source/extensions/filters/network/dubbo_proxy/decoder.cc
@@ -11,30 +11,30 @@ DecoderStateMachine::DecoderStatus
 DecoderStateMachine::onDecodeStreamHeader(Buffer::Instance& buffer) {
   ASSERT(!active_stream_);
 
   auto metadata = std::make_shared<MessageMetadata>();
   auto ret = protocol_.decodeHeader(buffer, metadata);
   if (!ret.second) {
     ENVOY_LOG(debug, "dubbo decoder: need more data for {} protocol", protocol_.name());
     return {ProtocolState::WaitForData};
   }
 
   auto context = ret.first;
   if (metadata->messageType() == MessageType::HeartbeatRequest ||
       metadata->messageType() == MessageType::HeartbeatResponse) {
     if (buffer.length() < (context->headerSize() + context->bodySize())) {
       ENVOY_LOG(debug, "dubbo decoder: need more data for {} protocol heartbeat", protocol_.name());
       return {ProtocolState::WaitForData};
     }
 
     ENVOY_LOG(debug, "dubbo decoder: this is the {} heartbeat message", protocol_.name());
     buffer.drain(context->headerSize() + context->bodySize());
     delegate_.onHeartbeat(metadata);
     return {ProtocolState::Done};
   }
 
   active_stream_ = delegate_.newStream(metadata, context);
   ASSERT(active_stream_);
-  context->messageOriginData().move(buffer, context->headerSize());
+  context->originMessage().move(buffer, context->headerSize());
 
   return {ProtocolState::OnDecodeStreamData};
 }
@@ -43,16 +43,16 @@ DecoderStateMachine::DecoderStatus
 DecoderStateMachine::onDecodeStreamData(Buffer::Instance& buffer) {
   ASSERT(active_stream_);
 
   if (!protocol_.decodeData(buffer, active_stream_->context_, active_stream_->metadata_)) {
     ENVOY_LOG(debug, "dubbo decoder: need more data for {} serialization, current size {}",
               protocol_.serializer()->name(), buffer.length());
     return {ProtocolState::WaitForData};
   }
 
-  active_stream_->context_->messageOriginData().move(buffer, active_stream_->context_->bodySize());
+  active_stream_->context_->originMessage().move(buffer, active_stream_->context_->bodySize());
   active_stream_->onStreamDecoded();
   active_stream_ = nullptr;
 
   ENVOY_LOG(debug, "dubbo decoder: ends the deserialization of the message");
   return {ProtocolState::Done};
 }
diff --git a/source/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.cc b/source/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.cc
index 7a63a1a15d..3257265262 100644
--- a/source/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.cc
+++ b/source/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.cc
@@ -1,14 +1,14 @@
 #include "extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.h"
 
 #include "envoy/common/exception.h"
 
 #include "common/common/assert.h"
 #include "common/common/macros.h"
 
 #include "extensions/filters/network/dubbo_proxy/hessian_utils.h"
 #include "extensions/filters/network/dubbo_proxy/message_impl.h"
-#include "extensions/filters/network/dubbo_proxy/serializer.h"
-#include "extensions/filters/network/dubbo_proxy/serializer_impl.h"
+
+#include "hessian2/object.hpp"
 
 namespace Envoy {
 namespace Extensions {
@@ -18,26 +18,64 @@ namespace DubboProxy {
 std::pair<RpcInvocationSharedPtr, bool>
 DubboHessian2SerializerImpl::deserializeRpcInvocation(Buffer::Instance& buffer,
                                                       ContextSharedPtr context) {
-  size_t total_size = 0, size;
+  Hessian2::Decoder decoder(std::make_unique<BufferReader>(buffer));
+
   // TODO(zyfjeff): Add format checker
-  std::string dubbo_version = HessianUtils::peekString(buffer, &size);
-  total_size += size;
-  std::string service_name = HessianUtils::peekString(buffer, &size, total_size);
-  total_size += size;
-  std::string service_version = HessianUtils::peekString(buffer, &size, total_size);
-  total_size += size;
-  std::string method_name = HessianUtils::peekString(buffer, &size, total_size);
-  total_size += size;
-
-  if (static_cast<uint64_t>(context->bodySize()) < total_size) {
-    throw EnvoyException(fmt::format("RpcInvocation size({}) large than body size({})", total_size,
-                                     context->bodySize()));
+  auto dubbo_version = decoder.decode<std::string>();
+  auto service_name = decoder.decode<std::string>();
+  auto service_version = decoder.decode<std::string>();
+  auto method_name = decoder.decode<std::string>();
+
+  if (context->bodySize() < decoder.offset()) {
+    throw EnvoyException(fmt::format("RpcInvocation size({}) larger than body size({})",
+                                     decoder.offset(), context->bodySize()));
+  }
+
+  if (dubbo_version == nullptr || service_name == nullptr || service_version == nullptr ||
+      method_name == nullptr) {
+    throw EnvoyException(fmt::format("RpcInvocation has no request metadata"));
   }
 
   auto invo = std::make_shared<RpcInvocationImpl>();
-  invo->setServiceName(service_name);
-  invo->setServiceVersion(service_version);
-  invo->setMethodName(method_name);
+  invo->setServiceName(*service_name);
+  invo->setServiceVersion(*service_version);
+  invo->setMethodName(*method_name);
+
+  size_t parsed_size = context->headerSize() + decoder.offset();
+
+  auto delayed_decoder = std::make_shared<Hessian2::Decoder>(
+      std::make_unique<BufferReader>(context->originMessage(), parsed_size));
+
+  invo->setParametersLazyCallback([delayed_decoder]() -> RpcInvocationImpl::ParametersPtr {
+    auto params = std::make_unique<RpcInvocationImpl::Parameters>();
+
+    if (auto types = delayed_decoder->decode<std::string>(); types != nullptr && !types->empty()) {
+      uint32_t number = HessianUtils::getParametersNumber(*types);
+      for (uint32_t i = 0; i < number; i++) {
+        if (auto result = delayed_decoder->decode<Hessian2::Object>(); result != nullptr) {
+          params->push_back(std::move(result));
+        } else {
+          throw EnvoyException("Cannot parse RpcInvocation parameter from buffer");
+        }
+      }
+    }
+    return params;
+  });
+
+  invo->setAttachmentLazyCallback([delayed_decoder]() -> RpcInvocationImpl::AttachmentPtr {
+    size_t offset = delayed_decoder->offset();
+
+    auto result = delayed_decoder->decode<Hessian2::Object>();
+    if (result != nullptr && result->type() == Hessian2::Object::Type::UntypedMap) {
+      return std::make_unique<RpcInvocationImpl::Attachment>(
+          RpcInvocationImpl::Attachment::MapPtr{
+              dynamic_cast<RpcInvocationImpl::Attachment::Map*>(result.release())},
+          offset);
+    } else {
+      return std::make_unique<RpcInvocationImpl::Attachment>(
+          std::make_unique<RpcInvocationImpl::Attachment::Map>(), offset);
+    }
+  });
 
   return std::pair<RpcInvocationSharedPtr, bool>(invo, true);
 }
@@ -46,39 +84,47 @@ std::pair<RpcResultSharedPtr, bool>
 DubboHessian2SerializerImpl::deserializeRpcResult(Buffer::Instance& buffer,
                                                   ContextSharedPtr context) {
   ASSERT(buffer.length() >= context->bodySize());
-  size_t total_size = 0;
   bool has_value = true;
 
   auto result = std::make_shared<RpcResultImpl>();
-  RpcResponseType type = static_cast<RpcResponseType>(HessianUtils::peekInt(buffer, &total_size));
+
+  Hessian2::Decoder decoder(std::make_unique<BufferReader>(buffer));
+  auto type_value = decoder.decode<int32_t>();
+  if (type_value == nullptr) {
+    throw EnvoyException(fmt::format("Cannot parse RpcResult type from buffer"));
+  }
+
+  RpcResponseType type = static_cast<RpcResponseType>(*type_value);
 
   switch (type) {
   case RpcResponseType::ResponseWithException:
   case RpcResponseType::ResponseWithExceptionWithAttachments:
     result->setException(true);
     break;
   case RpcResponseType::ResponseWithNullValue:
   case RpcResponseType::ResponseNullValueWithAttachments:
     has_value = false;
     FALLTHRU;
   case RpcResponseType::ResponseWithValue:
   case RpcResponseType::ResponseValueWithAttachments:
     result->setException(false);
     break;
   default:
     throw EnvoyException(fmt::format("not supported return type {}", static_cast<uint8_t>(type)));
   }
 
+  size_t total_size = decoder.offset();
+
   if (context->bodySize() < total_size) {
     throw EnvoyException(fmt::format("RpcResult size({}) large than body size({})", total_size,
                                      context->bodySize()));
   }
 
   if (!has_value && context->bodySize() != total_size) {
     throw EnvoyException(
         fmt::format("RpcResult is no value, but the rest of the body size({}) not equal 0",
                     (context->bodySize() - total_size)));
   }
 
   return std::pair<RpcResultSharedPtr, bool>(result, true);
 }
@@ -86,18 +132,16 @@ DubboHessian2SerializerImpl::deserializeRpcResult(Buffer::Instance& buffer,
 size_t DubboHessian2SerializerImpl::serializeRpcResult(Buffer::Instance& output_buffer,
                                                        const std::string& content,
                                                        RpcResponseType type) {
   size_t origin_length = output_buffer.length();
+  Hessian2::Encoder encoder(std::make_unique<BufferWriter>(output_buffer));
 
   // The serialized response type is compact int.
-  size_t serialized_size = HessianUtils::writeInt(
-      output_buffer, static_cast<std::underlying_type<RpcResponseType>::type>(type));
-
-  // Serialized response content.
-  serialized_size += HessianUtils::writeString(output_buffer, content);
+  bool result = encoder.encode(static_cast<std::underlying_type<RpcResponseType>::type>(type));
+  result |= encoder.encode(content);
 
-  ASSERT((output_buffer.length() - origin_length) == serialized_size);
+  ASSERT(result);
 
-  return serialized_size;
+  return output_buffer.length() - origin_length;
 }
 
 class DubboHessian2SerializerConfigFactory
diff --git a/source/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.h b/source/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.h
index 7655d891a5..0bdb7697d1 100644
--- a/source/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.h
+++ b/source/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.h
@@ -1,30 +1,31 @@
 #pragma once
 
+#include "extensions/filters/network/dubbo_proxy/message_impl.h"
 #include "extensions/filters/network/dubbo_proxy/serializer.h"
 
 namespace Envoy {
 namespace Extensions {
 namespace NetworkFilters {
 namespace DubboProxy {
+
 class DubboHessian2SerializerImpl : public Serializer {
 public:
-  ~DubboHessian2SerializerImpl() override = default;
   const std::string& name() const override {
     return ProtocolSerializerNames::get().fromType(ProtocolType::Dubbo, type());
   }
   SerializationType type() const override { return SerializationType::Hessian2; }
 
   std::pair<RpcInvocationSharedPtr, bool>
   deserializeRpcInvocation(Buffer::Instance& buffer, ContextSharedPtr context) override;
 
   std::pair<RpcResultSharedPtr, bool> deserializeRpcResult(Buffer::Instance& buffer,
                                                            ContextSharedPtr context) override;
 
   size_t serializeRpcResult(Buffer::Instance& output_buffer, const std::string& content,
                             RpcResponseType type) override;
 };
 
 } // namespace DubboProxy
 } // namespace NetworkFilters
 } // namespace Extensions
 } // namespace Envoy
diff --git a/source/extensions/filters/network/dubbo_proxy/dubbo_protocol_impl.cc b/source/extensions/filters/network/dubbo_proxy/dubbo_protocol_impl.cc
index 3a05491134..daaacfe2be 100644
--- a/source/extensions/filters/network/dubbo_proxy/dubbo_protocol_impl.cc
+++ b/source/extensions/filters/network/dubbo_proxy/dubbo_protocol_impl.cc
@@ -1,11 +1,10 @@
 #include "extensions/filters/network/dubbo_proxy/dubbo_protocol_impl.h"
 
 #include "envoy/registry/registry.h"
 
 #include "common/common/assert.h"
 
 #include "extensions/filters/network/dubbo_proxy/message_impl.h"
-#include "extensions/filters/network/dubbo_proxy/serializer_impl.h"
 
 namespace Envoy {
 namespace Extensions {
@@ -139,34 +138,34 @@ DubboProtocolImpl::decodeHeader(Buffer::Instance& buffer, MessageMetadataSharedP
 bool DubboProtocolImpl::decodeData(Buffer::Instance& buffer, ContextSharedPtr context,
                                    MessageMetadataSharedPtr metadata) {
   ASSERT(serializer_);
 
-  if ((buffer.length()) < static_cast<uint64_t>(context->bodySize())) {
+  if ((buffer.length()) < context->bodySize()) {
     return false;
   }
 
   switch (metadata->messageType()) {
   case MessageType::Oneway:
   case MessageType::Request: {
     auto ret = serializer_->deserializeRpcInvocation(buffer, context);
     if (!ret.second) {
       return false;
     }
     metadata->setInvocationInfo(ret.first);
     break;
   }
   case MessageType::Response: {
     auto ret = serializer_->deserializeRpcResult(buffer, context);
     if (!ret.second) {
       return false;
     }
     if (ret.first->hasException()) {
       metadata->setMessageType(MessageType::Exception);
     }
     break;
   }
   default:
     NOT_REACHED_GCOVR_EXCL_LINE;
   }
 
   return true;
 }
diff --git a/source/extensions/filters/network/dubbo_proxy/hessian_utils.cc b/source/extensions/filters/network/dubbo_proxy/hessian_utils.cc
index 777bf38549..c75a7427c0 100644
--- a/source/extensions/filters/network/dubbo_proxy/hessian_utils.cc
+++ b/source/extensions/filters/network/dubbo_proxy/hessian_utils.cc
@@ -1,587 +1,70 @@
 #include "extensions/filters/network/dubbo_proxy/hessian_utils.h"
 
-#include <type_traits>
-
-#include "common/common/assert.h"
-#include "common/common/fmt.h"
-
-#include "extensions/filters/network/dubbo_proxy/buffer_helper.h"
-
-#include "absl/strings/str_cat.h"
-
 namespace Envoy {
 namespace Extensions {
 namespace NetworkFilters {
 namespace DubboProxy {
 
-namespace {
-
-template <typename T>
-typename std::enable_if<std::is_signed<T>::value, T>::type leftShift(T left, uint16_t bit_number) {
-  if (left < 0) {
-    left = -left;
-    return -1 * (left << bit_number);
-  }
-
-  return left << bit_number;
-}
-
-inline void addByte(Buffer::Instance& buffer, const uint8_t value) { buffer.add(&value, 1); }
-
-void addSeq(Buffer::Instance& buffer, const std::initializer_list<uint8_t>& values) {
-  for (const uint8_t& value : values) {
-    buffer.add(&value, 1);
-  }
-}
-
-size_t doWriteString(Buffer::Instance& instance, absl::string_view str_view) {
-  const size_t length = str_view.length();
-  constexpr size_t str_max_length = 0xffff;
-  constexpr size_t two_octet_max_lenth = 1024;
-
-  if (length < 32) {
-    addByte(instance, static_cast<uint8_t>(length));
-    instance.add(str_view.data(), str_view.length());
-    return length + sizeof(uint8_t);
-  }
-
-  if (length < two_octet_max_lenth) {
-    const uint8_t code = length >> 8; // 0x30 + length / 0x100 must less than 0x34
-    const uint8_t remain = length & 0xff;
-    std::initializer_list<uint8_t> values{static_cast<uint8_t>(0x30 + code), remain};
-    addSeq(instance, values);
-    instance.add(str_view.data(), str_view.length());
-    return length + values.size();
-  }
-
-  if (length <= str_max_length) {
-    const uint8_t code = length >> 8;
-    const uint8_t remain = length & 0xff;
-    std::initializer_list<uint8_t> values{'S', code, remain};
-    addSeq(instance, values);
-    instance.add(str_view.data(), str_view.length());
-    return length + values.size();
+// Check
+// https://github.com/apache/dubbo/blob/master/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java
+// for details of parameters type.
+uint32_t HessianUtils::getParametersNumber(const std::string& parameters_type) {
+  if (parameters_type.empty()) {
+    return 0;
   }
 
-  std::initializer_list<uint8_t> values{0x52, 0xff, 0xff};
-  addSeq(instance, values);
-  instance.add(str_view.data(), str_max_length);
-  const size_t size = str_max_length + values.size();
-  ASSERT(size == (str_max_length + values.size()));
-
-  const size_t child_size =
-      doWriteString(instance, str_view.substr(str_max_length, length - str_max_length));
-  return child_size + size;
-}
-
-} // namespace
-
-/*
- * Reference:
- * https://cs.chromium.org/chromium/src/base/strings/string_util.h?q=WriteInto&sq=package:chromium&dr=CSs&l=426
- */
-char* allocStringBuffer(std::string* str, size_t length) {
-  str->reserve(length);
-  str->resize(length - 1);
-  return &((*str)[0]);
-}
-
-std::string HessianUtils::peekString(Buffer::Instance& buffer, size_t* size, uint64_t offset) {
-  ASSERT(buffer.length() > offset);
-  const uint8_t code = buffer.peekInt<uint8_t>(offset);
-  size_t delta_length = 0;
-  std::string result;
-  switch (code) {
-  case 0x00:
-  case 0x01:
-  case 0x02:
-  case 0x03:
-  case 0x04:
-  case 0x05:
-  case 0x06:
-  case 0x07:
-  case 0x08:
-  case 0x09:
-  case 0x0a:
-  case 0x0b:
-  case 0x0c:
-  case 0x0d:
-  case 0x0e:
-  case 0x0f:
-  case 0x10:
-  case 0x11:
-  case 0x12:
-  case 0x13:
-  case 0x14:
-  case 0x15:
-  case 0x16:
-  case 0x17:
-  case 0x18:
-  case 0x19:
-  case 0x1a:
-  case 0x1b:
-  case 0x1c:
-  case 0x1d:
-  case 0x1e:
-  case 0x1f:
-    delta_length = code - 0x00;
-    if (delta_length + 1 + offset > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-    buffer.copyOut(offset + 1, delta_length, allocStringBuffer(&result, delta_length + 1));
-    *size = delta_length + 1;
-    return result;
-
-  case 0x30:
-  case 0x31:
-  case 0x32:
-  case 0x33:
-    if (offset + 2 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    delta_length = (code - 0x30) * 256 + buffer.peekInt<uint8_t>(offset + 1);
-    if (delta_length + 2 + offset > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    buffer.copyOut(offset + 2, delta_length, allocStringBuffer(&result, delta_length + 1));
-    *size = delta_length + 2;
-    return result;
-
-  case 0x53:
-    if (offset + 3 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    delta_length = buffer.peekBEInt<uint16_t>(offset + 1);
-
-    if (delta_length + 3 + offset > buffer.length()) {
-      throw EnvoyException("buffer underflow");
+  uint32_t count = 0;
+  bool next = false;
+
+  for (auto ch : parameters_type) {
+    if (ch == '[') {
+      // Is array.
+      continue;
+    }
+
+    if (next && ch != ';') {
+      // Is Object.
+      continue;
+    }
+
+    switch (ch) {
+    case 'V':
+    case 'Z':
+    case 'B':
+    case 'C':
+    case 'D':
+    case 'F':
+    case 'I':
+    case 'J':
+    case 'S':
+      count++;
+      break;
+    case 'L':
+      // Start of Object.
+      count++;
+      next = true;
+      break;
+    case ';':
+      // End of Object.
+      next = false;
+      break;
+    default:
+      break;
     }
-
-    buffer.copyOut(offset + 3, delta_length, allocStringBuffer(&result, delta_length + 1));
-    *size = delta_length + 3;
-    return result;
-
-  case 0x52:
-    if (offset + 3 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    delta_length = buffer.peekBEInt<uint16_t>(offset + 1);
-    buffer.copyOut(offset + 3, delta_length, allocStringBuffer(&result, delta_length + 1));
-    size_t next_size = 0;
-    result.append(peekString(buffer, &next_size, delta_length + 3 + offset));
-    *size = next_size + delta_length + 3;
-    return result;
   }
-  throw EnvoyException(absl::StrCat("hessian type is not string ", code));
+  return count;
 }
 
-std::string HessianUtils::readString(Buffer::Instance& buffer) {
-  size_t size;
-  std::string result(peekString(buffer, &size));
-  buffer.drain(size);
-  return result;
-}
+void BufferWriter::rawWrite(const void* data, uint64_t size) { buffer_.add(data, size); }
 
-long HessianUtils::peekLong(Buffer::Instance& buffer, size_t* size, uint64_t offset) {
-  ASSERT(buffer.length() > offset);
-  long result;
-  uint8_t code = buffer.peekInt<uint8_t>(offset);
-  switch (code) {
-  case 0xd8:
-  case 0xd9:
-  case 0xda:
-  case 0xdb:
-  case 0xdc:
-  case 0xdd:
-  case 0xde:
-  case 0xdf:
-  case 0xe0:
-  case 0xe1:
-  case 0xe2:
-  case 0xe3:
-  case 0xe4:
-  case 0xe5:
-  case 0xe6:
-  case 0xe7:
-  case 0xe8:
-  case 0xe9:
-  case 0xea:
-  case 0xeb:
-  case 0xec:
-  case 0xed:
-  case 0xee:
-  case 0xef:
-
-    result = code - 0xe0;
-    *size = 1;
-    return result;
-
-  case 0xf0:
-  case 0xf1:
-  case 0xf2:
-  case 0xf3:
-  case 0xf4:
-  case 0xf5:
-  case 0xf6:
-  case 0xf7:
-  case 0xf8:
-  case 0xf9:
-  case 0xfa:
-  case 0xfb:
-  case 0xfc:
-  case 0xfd:
-  case 0xfe:
-  case 0xff:
-
-    if (offset + 2 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    result = leftShift<int16_t>(code - 0xf8, 8) + buffer.peekInt<uint8_t>(offset + 1);
-    *size = 2;
-    return result;
-
-  case 0x38:
-  case 0x39:
-  case 0x3a:
-  case 0x3b:
-  case 0x3c:
-  case 0x3d:
-  case 0x3e:
-  case 0x3f:
-
-    if (offset + 3 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    result = leftShift<int32_t>(code - 0x3c, 16) + (buffer.peekInt<uint8_t>(offset + 1) << 8) +
-             buffer.peekInt<uint8_t>(offset + 2);
-    *size = 3;
-    return result;
-
-  case 0x59:
-
-    if (offset + 5 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    result = buffer.peekBEInt<uint32_t>(offset + 1);
-    *size = 5;
-    return result;
-
-  case 0x4c:
-
-    if (offset + 9 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    result = buffer.peekBEInt<int64_t>(offset + 1);
-    *size = 9;
-    return result;
-  }
-
-  throw EnvoyException(absl::StrCat("hessian type is not long ", code));
-}
-
-long HessianUtils::readLong(Buffer::Instance& buffer) {
-  size_t size;
-  const long result = peekLong(buffer, &size);
-  buffer.drain(size);
-  return result;
-}
-
-bool HessianUtils::peekBool(Buffer::Instance& buffer, size_t* size, uint64_t offset) {
-  ASSERT(buffer.length() > offset);
-  bool result;
-  const uint8_t code = buffer.peekInt<uint8_t>(offset);
-  if (code == 0x46) {
-    result = false;
-    *size = 1;
-    return result;
-  }
-
-  if (code == 0x54) {
-    result = true;
-    *size = 1;
-    return result;
-  }
-
-  throw EnvoyException(absl::StrCat("hessian type is not bool ", code));
-}
-
-bool HessianUtils::readBool(Buffer::Instance& buffer) {
-  size_t size;
-  bool result(peekBool(buffer, &size));
-  buffer.drain(size);
-  return result;
-}
-
-int HessianUtils::peekInt(Buffer::Instance& buffer, size_t* size, uint64_t offset) {
-  ASSERT(buffer.length() > offset);
-  const uint8_t code = buffer.peekInt<uint8_t>(offset);
-  int result;
-
-  // Compact int
-  if (code >= 0x80 && code <= 0xbf) {
-    result = (code - 0x90);
-    *size = 1;
-    return result;
-  }
-
-  switch (code) {
-  case 0xc0:
-  case 0xc1:
-  case 0xc2:
-  case 0xc3:
-  case 0xc4:
-  case 0xc5:
-  case 0xc6:
-  case 0xc7:
-  case 0xc8:
-  case 0xc9:
-  case 0xca:
-  case 0xcb:
-  case 0xcc:
-  case 0xcd:
-  case 0xce:
-  case 0xcf:
-    if (offset + 2 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    result = leftShift<int16_t>(code - 0xc8, 8) + buffer.peekInt<uint8_t>(offset + 1);
-    *size = 2;
-    return result;
-
-  case 0xd0:
-  case 0xd1:
-  case 0xd2:
-  case 0xd3:
-  case 0xd4:
-  case 0xd5:
-  case 0xd6:
-  case 0xd7:
-    if (offset + 3 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-    result = leftShift<int32_t>(code - 0xd4, 16) + (buffer.peekInt<uint8_t>(offset + 1) << 8) +
-             buffer.peekInt<uint8_t>(offset + 2);
-    *size = 3;
-    return result;
-
-  case 0x49:
-    if (offset + 5 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-    result = buffer.peekBEInt<int32_t>(offset + 1);
-    *size = 5;
-    return result;
-  }
-
-  throw EnvoyException(absl::StrCat("hessian type is not int ", code));
-}
-
-int HessianUtils::readInt(Buffer::Instance& buffer) {
-  size_t size;
-  int result(peekInt(buffer, &size));
-  buffer.drain(size);
-  return result;
-}
-
-double HessianUtils::peekDouble(Buffer::Instance& buffer, size_t* size, uint64_t offset) {
-  ASSERT(buffer.length() > offset);
-  double result;
-  uint8_t code = buffer.peekInt<uint8_t>(offset);
-  switch (code) {
-  case 0x5b:
-    result = 0.0;
-    *size = 1;
-    return result;
-
-  case 0x5c:
-    result = 1.0;
-    *size = 1;
-    return result;
-
-  case 0x5d:
-    if (offset + 2 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-    result = static_cast<double>(buffer.peekInt<int8_t>(offset + 1));
-    *size = 2;
-    return result;
-
-  case 0x5e:
-    if (offset + 3 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-    result = static_cast<double>(256 * buffer.peekInt<int8_t>(offset + 1) +
-                                 buffer.peekInt<uint8_t>(offset + 2));
-    *size = 3;
-    return result;
-
-  case 0x5f:
-    if (offset + 5 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-    result = BufferHelper::peekFloat(buffer, offset + 1);
-    *size = 5;
-    return result;
-
-  case 0x44:
-    if (offset + 9 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-    result = BufferHelper::peekDouble(buffer, offset + 1);
-    *size = 9;
-    return result;
-  }
-
-  throw EnvoyException(absl::StrCat("hessian type is not double ", code));
-}
-
-double HessianUtils::readDouble(Buffer::Instance& buffer) {
-  size_t size;
-  double result(peekDouble(buffer, &size));
-  buffer.drain(size);
-  return result;
-}
-
-void HessianUtils::peekNull(Buffer::Instance& buffer, size_t* size, uint64_t offset) {
-  ASSERT(buffer.length() > offset);
-  uint8_t code = buffer.peekInt<uint8_t>(offset);
-  if (code == 0x4e) {
-    *size = 1;
-    return;
-  }
-
-  throw EnvoyException(absl::StrCat("hessian type is not null ", code));
-}
-
-void HessianUtils::readNull(Buffer::Instance& buffer) {
-  size_t size;
-  peekNull(buffer, &size);
-  buffer.drain(size);
-}
-
-std::chrono::milliseconds HessianUtils::peekDate(Buffer::Instance& buffer, size_t* size,
-                                                 uint64_t offset) {
-  ASSERT(buffer.length() > offset);
-  std::chrono::milliseconds result;
-  uint8_t code = buffer.peekInt<uint8_t>(offset);
-  switch (code) {
-  case 0x4b:
-    if (offset + 5 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    result = std::chrono::minutes(buffer.peekBEInt<uint32_t>(offset + 1));
-    *size = 5;
-    return result;
-
-  case 0x4a:
-    if (offset + 9 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-    result = std::chrono::milliseconds(buffer.peekBEInt<uint64_t>(offset + 1));
-    *size = 9;
-    return result;
-  }
-
-  throw EnvoyException(absl::StrCat("hessian type is not date ", code));
-}
-
-std::chrono::milliseconds HessianUtils::readDate(Buffer::Instance& buffer) {
-  size_t size;
-  std::chrono::milliseconds result;
-  result = peekDate(buffer, &size);
-  buffer.drain(size);
-  return result;
-}
-
-std::string HessianUtils::peekByte(Buffer::Instance& buffer, size_t* size, uint64_t offset) {
-  ASSERT(buffer.length() > offset);
-  std::string result;
-  uint8_t code = buffer.peekInt<uint8_t>(offset);
-  size_t delta_length = 0;
-  switch (code) {
-  case 0x20:
-  case 0x21:
-  case 0x22:
-  case 0x23:
-  case 0x24:
-  case 0x25:
-  case 0x26:
-  case 0x27:
-  case 0x28:
-  case 0x29:
-  case 0x2a:
-  case 0x2b:
-  case 0x2c:
-  case 0x2d:
-  case 0x2e:
-  case 0x2f:
-    delta_length = code - 0x20;
-    if (delta_length + 1 + offset > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    buffer.copyOut(offset + 1, delta_length, allocStringBuffer(&result, delta_length + 1));
-    *size = delta_length + 1;
-    return result;
-
-  case 0x42:
-    if (offset + 3 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    delta_length = buffer.peekBEInt<uint16_t>(offset + 1);
-    if (delta_length + 3 + offset > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    buffer.copyOut(offset + 3, delta_length, allocStringBuffer(&result, delta_length + 1));
-    *size = delta_length + 3;
-    return result;
-
-  case 0x41:
-    if (offset + 3 > buffer.length()) {
-      throw EnvoyException("buffer underflow");
-    }
-
-    delta_length = buffer.peekBEInt<uint16_t>(offset + 1);
-    buffer.copyOut(offset + 3, delta_length, allocStringBuffer(&result, delta_length + 1));
-    size_t next_size;
-    result.append(peekByte(buffer, &next_size, delta_length + 3 + offset));
-    *size = delta_length + 3 + next_size;
-    return result;
-  }
-
-  throw EnvoyException(absl::StrCat("hessian type is not byte ", code));
-}
-
-std::string HessianUtils::readByte(Buffer::Instance& buffer) {
-  size_t size;
-  std::string result(peekByte(buffer, &size));
-  buffer.drain(size);
-  return result;
-}
-
-size_t HessianUtils::writeString(Buffer::Instance& buffer, absl::string_view str) {
-  return doWriteString(buffer, str);
-}
+void BufferWriter::rawWrite(absl::string_view data) { buffer_.add(data); }
 
-size_t HessianUtils::writeInt(Buffer::Instance& buffer, uint8_t value) {
-  // Compact int
-  buffer.writeByte(0x90 + value);
-  return sizeof(uint8_t);
+void BufferReader::rawReadNBytes(void* data, size_t len, size_t peek_offset) {
+  ASSERT(byteAvailable() - peek_offset >= len);
+  buffer_.copyOut(offset() + peek_offset, len, data);
 }
 
 } // namespace DubboProxy
 } // namespace NetworkFilters
 } // namespace Extensions
 } // namespace Envoy
diff --git a/source/extensions/filters/network/dubbo_proxy/hessian_utils.h b/source/extensions/filters/network/dubbo_proxy/hessian_utils.h
index 88f250442c..8385eb37c0 100644
--- a/source/extensions/filters/network/dubbo_proxy/hessian_utils.h
+++ b/source/extensions/filters/network/dubbo_proxy/hessian_utils.h
@@ -1,46 +1,53 @@
 #pragma once
 
-#include <chrono>
-#include <map>
 #include <string>
 
 #include "envoy/buffer/buffer.h"
 
+#include "absl/strings/string_view.h"
+#include "hessian2/basic_codec/object_codec.hpp"
+#include "hessian2/codec.hpp"
+#include "hessian2/object.hpp"
+#include "hessian2/reader.hpp"
+#include "hessian2/writer.hpp"
+
 namespace Envoy {
 namespace Extensions {
 namespace NetworkFilters {
 namespace DubboProxy {
 
-/*
- * Hessian deserialization
- * See http://hessian.caucho.com/doc/hessian-serialization.html
- */
 class HessianUtils {
 public:
-  static std::string peekString(Buffer::Instance& buffer, size_t* size, uint64_t offset = 0);
-  static long peekLong(Buffer::Instance& buffer, size_t* size, uint64_t offset = 0);
-  static bool peekBool(Buffer::Instance& buffer, size_t* size, uint64_t offset = 0);
-  static int peekInt(Buffer::Instance& buffer, size_t* size, uint64_t offset = 0);
-  static double peekDouble(Buffer::Instance& buffer, size_t* size, uint64_t offset = 0);
-  static void peekNull(Buffer::Instance& buffer, size_t* size, uint64_t offset = 0);
-  static std::chrono::milliseconds peekDate(Buffer::Instance& buffer, size_t* size,
-                                            uint64_t offset = 0);
-  static std::string peekByte(Buffer::Instance& buffer, size_t* size, uint64_t offset = 0);
-
-  static std::string readString(Buffer::Instance& buffer);
-  static long readLong(Buffer::Instance& buffer);
-  static bool readBool(Buffer::Instance& buffer);
-  static int readInt(Buffer::Instance& buffer);
-  static double readDouble(Buffer::Instance& buffer);
-  static void readNull(Buffer::Instance& buffer);
-  static std::chrono::milliseconds readDate(Buffer::Instance& buffer);
-  static std::string readByte(Buffer::Instance& buffer);
-
-  static size_t writeString(Buffer::Instance& buffer, absl::string_view str);
-  static size_t writeInt(Buffer::Instance& buffer, uint8_t value);
+  static uint32_t getParametersNumber(const std::string& parameters_type);
+};
+
+class BufferWriter : public Hessian2::Writer {
+public:
+  BufferWriter(Envoy::Buffer::Instance& buffer) : buffer_(buffer) {}
+
+  // Hessian2::Writer
+  void rawWrite(const void* data, uint64_t size) override;
+  void rawWrite(absl::string_view data) override;
+
+private:
+  Envoy::Buffer::Instance& buffer_;
+};
+
+class BufferReader : public Hessian2::Reader {
+public:
+  BufferReader(Envoy::Buffer::Instance& buffer, uint64_t initial_offset = 0) : buffer_(buffer) {
+    initial_offset_ = initial_offset;
+  }
+
+  // Hessian2::Reader
+  uint64_t length() const override { return buffer_.length(); }
+  void rawReadNBytes(void* data, size_t len, size_t peek_offset) override;
+
+private:
+  Envoy::Buffer::Instance& buffer_;
 };
 
 } // namespace DubboProxy
 } // namespace NetworkFilters
 } // namespace Extensions
 } // namespace Envoy
diff --git a/source/extensions/filters/network/dubbo_proxy/message.h b/source/extensions/filters/network/dubbo_proxy/message.h
index 08a399fae8..3aa194a8c9 100644
--- a/source/extensions/filters/network/dubbo_proxy/message.h
+++ b/source/extensions/filters/network/dubbo_proxy/message.h
@@ -89,23 +89,18 @@ enum class RpcResponseType : uint8_t {
 
 class Context {
 public:
-  using AttachmentMap = absl::node_hash_map<std::string, std::string>;
+  virtual ~Context() = default;
 
-  bool hasAttachments() const { return !attachments_.empty(); }
-  const AttachmentMap& attachments() const { return attachments_; }
-
-  Buffer::Instance& messageOriginData() { return message_origin_buffer_; }
+  Buffer::Instance& originMessage() { return origin_message_; }
   size_t messageSize() const { return headerSize() + bodySize(); }
 
-  virtual size_t bodySize() const PURE;
   virtual size_t headerSize() const PURE;
+  virtual size_t bodySize() const PURE;
 
-protected:
-  Context() = default;
-  virtual ~Context() { attachments_.clear(); }
+  virtual bool isHeartbeat() const PURE;
 
-  AttachmentMap attachments_;
-  Buffer::OwnedImpl message_origin_buffer_;
+protected:
+  Buffer::OwnedImpl origin_message_;
 };
 
 using ContextSharedPtr = std::shared_ptr<Context>;
@@ -135,6 +130,7 @@ using RpcInvocationSharedPtr = std::shared_ptr<RpcInvocation>;
 class RpcResult {
 public:
   virtual ~RpcResult() = default;
+
   virtual bool hasException() const PURE;
 };
 
diff --git a/source/extensions/filters/network/dubbo_proxy/message_impl.cc b/source/extensions/filters/network/dubbo_proxy/message_impl.cc
new file mode 100644
index 0000000000..5e76711ee8
--- /dev/null
+++ b/source/extensions/filters/network/dubbo_proxy/message_impl.cc
@@ -0,0 +1,109 @@
+#include "extensions/filters/network/dubbo_proxy/message_impl.h"
+
+#include "common/http/header_map_impl.h"
+
+namespace Envoy {
+namespace Extensions {
+namespace NetworkFilters {
+namespace DubboProxy {
+
+RpcInvocationImpl::Attachment::Attachment(MapPtr&& value, size_t offset)
+    : attachment_(std::move(value)), attachment_offset_(offset) {
+  headers_ = Http::RequestHeaderMapImpl::create();
+
+  ASSERT(attachment_);
+  ASSERT(attachment_->toMutableUntypedMap());
+
+  for (const auto& pair : *attachment_->toMutableUntypedMap()) {
+    const auto key = pair.first->toString();
+    const auto value = pair.second->toString();
+    if (!key.has_value() || !value.has_value()) {
+      continue;
+    }
+    headers_->addCopy(Http::LowerCaseString(*(key.value())), *(value.value()));
+  }
+}
+
+void RpcInvocationImpl::Attachment::insert(const std::string& key, const std::string& value) {
+  attachment_updated_ = true;
+
+  ASSERT(attachment_->toMutableUntypedMap());
+
+  attachment_->toMutableUntypedMap()->emplace(std::make_unique<String>(key),
+                                              std::make_unique<String>(value));
+
+  auto lowcase_key = Http::LowerCaseString(key);
+  headers_->remove(lowcase_key);
+  headers_->addCopy(lowcase_key, value);
+}
+
+void RpcInvocationImpl::Attachment::remove(const std::string& key) {
+  attachment_updated_ = true;
+
+  ASSERT(attachment_->toMutableUntypedMap());
+
+  attachment_->toMutableUntypedMap()->erase(std::make_unique<String>(key));
+  headers_->remove(Http::LowerCaseString(key));
+}
+
+const std::string* RpcInvocationImpl::Attachment::lookup(const std::string& key) const {
+  ASSERT(attachment_->toMutableUntypedMap());
+
+  auto map = attachment_->toMutableUntypedMap();
+  auto result = map->find(std::make_unique<String>(key));
+  if (result != map->end() && result->second->toString().has_value()) {
+    return result->second->toString().value();
+  }
+  return nullptr;
+}
+
+void RpcInvocationImpl::assignParametersIfNeed() const {
+  ASSERT(parameters_lazy_callback_ != nullptr);
+  if (parameters_ == nullptr) {
+    parameters_ = parameters_lazy_callback_();
+  }
+}
+
+void RpcInvocationImpl::assignAttachmentIfNeed() const {
+  ASSERT(attachment_lazy_callback_ != nullptr);
+  if (attachment_ != nullptr) {
+    return;
+  }
+
+  assignParametersIfNeed();
+  attachment_ = attachment_lazy_callback_();
+
+  if (auto g = attachment_->lookup("group"); g != nullptr) {
+    const_cast<RpcInvocationImpl*>(this)->group_ = *g;
+  }
+}
+
+const absl::optional<std::string>& RpcInvocationImpl::serviceGroup() const {
+  assignAttachmentIfNeed();
+  return group_;
+}
+
+const RpcInvocationImpl::Attachment& RpcInvocationImpl::attachment() const {
+  assignAttachmentIfNeed();
+  return *attachment_;
+}
+
+RpcInvocationImpl::AttachmentPtr& RpcInvocationImpl::mutableAttachment() const {
+  assignAttachmentIfNeed();
+  return attachment_;
+}
+
+const RpcInvocationImpl::Parameters& RpcInvocationImpl::parameters() const {
+  assignParametersIfNeed();
+  return *parameters_;
+}
+
+RpcInvocationImpl::ParametersPtr& RpcInvocationImpl::mutableParameters() const {
+  assignParametersIfNeed();
+  return parameters_;
+}
+
+} // namespace DubboProxy
+} // namespace NetworkFilters
+} // namespace Extensions
+} // namespace Envoy
diff --git a/source/extensions/filters/network/dubbo_proxy/message_impl.h b/source/extensions/filters/network/dubbo_proxy/message_impl.h
index c535b522e9..952cbb3dc5 100644
--- a/source/extensions/filters/network/dubbo_proxy/message_impl.h
+++ b/source/extensions/filters/network/dubbo_proxy/message_impl.h
@@ -1,5 +1,8 @@
 #pragma once
 
+#include "envoy/http/header_map.h"
+
+#include "extensions/filters/network/dubbo_proxy/hessian_utils.h"
 #include "extensions/filters/network/dubbo_proxy/message.h"
 
 namespace Envoy {
@@ -7,32 +10,21 @@ namespace Extensions {
 namespace NetworkFilters {
 namespace DubboProxy {
 
-class ContextBase : public Context {
+class ContextImpl : public Context {
 public:
-  ContextBase() = default;
-  ~ContextBase() override = default;
-
-  // Override from Context
-  size_t bodySize() const override { return body_size_; }
+  // DubboProxy::Context
   size_t headerSize() const override { return header_size_; }
+  size_t bodySize() const override { return body_size_; }
+  bool isHeartbeat() const override { return is_heartbeat_; }
 
-  void setBodySize(size_t size) { body_size_ = size; }
   void setHeaderSize(size_t size) { header_size_ = size; }
+  void setBodySize(size_t size) { body_size_ = size; }
+  void setHeartbeat(bool heartbeat) { is_heartbeat_ = heartbeat; }
 
-protected:
-  size_t body_size_{0};
+private:
   size_t header_size_{0};
-};
-
-class ContextImpl : public ContextBase {
-public:
-  ContextImpl() = default;
-  ~ContextImpl() override = default;
-
-  bool isHeartbeat() const { return is_heartbeat_; }
-  void setHeartbeat(bool is_heartbeat) { is_heartbeat_ = is_heartbeat; }
+  size_t body_size_{0};
 
-private:
   bool is_heartbeat_{false};
 };
 
@@ -55,11 +47,96 @@ public:
 protected:
   std::string service_name_;
   std::string method_name_;
   absl::optional<std::string> service_version_;
   absl::optional<std::string> group_;
 };
 
+class RpcInvocationImpl : public RpcInvocationBase {
+public:
+  // Each parameter consists of a parameter binary size and Hessian2::Object.
+  using Parameters = std::vector<Hessian2::ObjectPtr>;
+  using ParametersPtr = std::unique_ptr<Parameters>;
+
+  class Attachment {
+  public:
+    using Map = Hessian2::UntypedMapObject;
+    using MapPtr = std::unique_ptr<Hessian2::UntypedMapObject>;
+    using String = Hessian2::StringObject;
+
+    Attachment(MapPtr&& value, size_t offset);
+
+    const Map& attachment() const { return *attachment_; }
+
+    void insert(const std::string& key, const std::string& value);
+    void remove(const std::string& key);
+    const std::string* lookup(const std::string& key) const;
+
+    // Http::HeaderMap wrapper to attachment.
+    const Http::HeaderMap& headers() const { return *headers_; }
+
+    // Whether the attachment should be re-serialized.
+    bool attachmentUpdated() const { return attachment_updated_; }
+
+    size_t attachmentOffset() const { return attachment_offset_; }
+
+  private:
+    bool attachment_updated_{false};
+
+    MapPtr attachment_;
+
+    // The binary offset of attachment in the original message. Retaining this value can help
+    // subsequent re-serialization of the attachment without re-serializing the parameters.
+    size_t attachment_offset_{};
+
+    // To reuse the HeaderMatcher API and related tools provided by Envoy, we store the key/value
+    // pair of the string type in the attachment in the Http::HeaderMap. This introduces additional
+    // overhead and ignores the case of the key in the attachment. But for now, it's acceptable.
+    Http::HeaderMapPtr headers_;
+  };
+  using AttachmentPtr = std::unique_ptr<Attachment>;
+
+  using AttachmentLazyCallback = std::function<AttachmentPtr()>;
+  using ParametersLazyCallback = std::function<ParametersPtr()>;
+
+  bool hasParameters() const { return parameters_ != nullptr; }
+  const Parameters& parameters() const;
+  ParametersPtr& mutableParameters() const;
+
+  bool hasAttachment() const { return attachment_ != nullptr; }
+  const Attachment& attachment() const;
+  AttachmentPtr& mutableAttachment() const;
+
+  void setParametersLazyCallback(ParametersLazyCallback&& callback) {
+    parameters_lazy_callback_ = std::move(callback);
+  }
+
+  void setAttachmentLazyCallback(AttachmentLazyCallback&& callback) {
+    attachment_lazy_callback_ = std::move(callback);
+  }
+
+  const absl::optional<std::string>& serviceGroup() const override;
+
+private:
+  void assignParametersIfNeed() const;
+  void assignAttachmentIfNeed() const;
+
+  AttachmentLazyCallback attachment_lazy_callback_;
+  ParametersLazyCallback parameters_lazy_callback_;
+
+  mutable ParametersPtr parameters_{};
+  mutable AttachmentPtr attachment_{};
+};
+
+class RpcResultImpl : public RpcResult {
+public:
+  bool hasException() const override { return has_exception_; }
+  void setException(bool has_exception) { has_exception_ = has_exception; }
+
+private:
+  bool has_exception_{false};
+};
+
 } // namespace DubboProxy
 } // namespace NetworkFilters
 } // namespace Extensions
 } // namespace Envoy
diff --git a/source/extensions/filters/network/dubbo_proxy/router/route_matcher.cc b/source/extensions/filters/network/dubbo_proxy/router/route_matcher.cc
index 934035d5a3..7a5f5d26f9 100644
--- a/source/extensions/filters/network/dubbo_proxy/router/route_matcher.cc
+++ b/source/extensions/filters/network/dubbo_proxy/router/route_matcher.cc
@@ -1,12 +1,10 @@
 #include "extensions/filters/network/dubbo_proxy/router/route_matcher.h"
 
 #include "envoy/config/route/v3/route_components.pb.h"
 #include "envoy/extensions/filters/network/dubbo_proxy/v3/route.pb.h"
 
 #include "common/protobuf/utility.h"
 
-#include "extensions/filters/network/dubbo_proxy/serializer_impl.h"
-
 namespace Envoy {
 namespace Extensions {
 namespace NetworkFilters {
@@ -43,8 +41,14 @@ RouteConstSharedPtr RouteEntryImplBase::clusterEntry(uint64_t random_value) cons
                                           false);
 }
 
-bool RouteEntryImplBase::headersMatch(const Http::HeaderMap& headers) const {
+bool RouteEntryImplBase::headersMatch(const RpcInvocationImpl& invocation) const {
+  if (config_headers_.empty()) {
+    ENVOY_LOG(debug, "dubbo route matcher: no headers match");
+    return true;
+  }
+
+  const auto& headers = invocation.attachment().headers();
   ENVOY_LOG(debug, "dubbo route matcher: headers size {}, metadata headers size {}",
             config_headers_.size(), headers.size());
   return Http::HeaderUtility::matchHeaders(headers, config_headers_);
 }
@@ -82,29 +86,39 @@ bool ParameterRouteEntryImpl::matchParameter(absl::string_view request_data,
 RouteConstSharedPtr ParameterRouteEntryImpl::matches(const MessageMetadata& metadata,
                                                      uint64_t random_value) const {
   ASSERT(metadata.hasInvocationInfo());
   const auto invocation = dynamic_cast<const RpcInvocationImpl*>(&metadata.invocationInfo());
   ASSERT(invocation);
-  if (!invocation->hasParameters()) {
+
+  const auto& parameters = invocation->parameters();
+  if (parameters.empty()) {
     return nullptr;
   }
 
   ENVOY_LOG(debug, "dubbo route matcher: parameter name match");
   for (auto& config_data : parameter_data_list_) {
-    const std::string& data = invocation->getParameterValue(config_data.index_);
-    if (data.empty()) {
+    if (config_data.index_ >= parameters.size()) {
       ENVOY_LOG(debug,
-                "dubbo route matcher: parameter matching failed, there are no parameters in the "
+                "dubbo route matcher: parameter matching failed, there is no parameter in the "
                 "user request, index '{}'",
                 config_data.index_);
       return nullptr;
     }
 
-    if (!matchParameter(data, config_data)) {
+    const auto data = parameters.at(config_data.index_)->toString();
+    if (!data.has_value()) {
+      ENVOY_LOG(debug,
+                "dubbo route matcher: parameter matching failed, the parameter cannot be converted "
+                "to string, index '{}'",
+                config_data.index_);
+      return nullptr;
+    }
+
+    if (!matchParameter(absl::string_view(*data.value()), config_data)) {
       ENVOY_LOG(debug, "dubbo route matcher: parameter matching failed, index '{}', value '{}'",
-                config_data.index_, data);
+                config_data.index_, *data.value());
       return nullptr;
     }
   }
 
   return clusterEntry(random_value);
 }
@@ -141,29 +155,29 @@ MethodRouteEntryImpl::~MethodRouteEntryImpl() = default;
 RouteConstSharedPtr MethodRouteEntryImpl::matches(const MessageMetadata& metadata,
                                                   uint64_t random_value) const {
   ASSERT(metadata.hasInvocationInfo());
   const auto invocation = dynamic_cast<const RpcInvocationImpl*>(&metadata.invocationInfo());
   ASSERT(invocation);
 
-  if (invocation->hasHeaders() && !RouteEntryImplBase::headersMatch(invocation->headers())) {
+  if (!RouteEntryImplBase::headersMatch(*invocation)) {
     ENVOY_LOG(error, "dubbo route matcher: headers not match");
     return nullptr;
   }
 
   if (invocation->methodName().empty()) {
     ENVOY_LOG(error, "dubbo route matcher: there is no method name in the metadata");
     return nullptr;
   }
 
   if (!method_name_.match(invocation->methodName())) {
     ENVOY_LOG(debug, "dubbo route matcher: method matching failed, input method '{}'",
               invocation->methodName());
     return nullptr;
   }
 
   if (parameter_route_) {
     ENVOY_LOG(debug, "dubbo route matcher: parameter matching is required");
     return parameter_route_->matches(metadata, random_value);
   }
 
   return clusterEntry(random_value);
 }
@@ -179,25 +193,66 @@ SingleRouteMatcherImpl::SingleRouteMatcherImpl(const RouteConfig& config,
   ENVOY_LOG(debug, "dubbo route matcher: routes list size {}", routes_.size());
 }
 
+bool SingleRouteMatcherImpl::matchServiceGroup(const RpcInvocationImpl& invocation) const {
+  if (!group_.has_value() || group_.value().empty()) {
+    return true;
+  }
+
+  return invocation.serviceGroup().has_value() && invocation.serviceGroup().value() == group_;
+}
+
+bool SingleRouteMatcherImpl::matchServiceVersion(const RpcInvocationImpl& invocation) const {
+  if (!version_.has_value() || version_.value().empty()) {
+    return true;
+  }
+  return invocation.serviceVersion().has_value() && invocation.serviceVersion().value() == version_;
+}
+
+bool SingleRouteMatcherImpl::matchServiceName(const RpcInvocationImpl& invocation) const {
+  return interface_matcher_.match(invocation.serviceName());
+}
+
+SingleRouteMatcherImpl::InterfaceMatcher::InterfaceMatcher(const std::string& interface_name) {
+  if (interface_name == "*") {
+    impl_ = [](const absl::string_view interface) { return !interface.empty(); };
+    return;
+  }
+  if (absl::StartsWith(interface_name, "*")) {
+    const std::string suffix = interface_name.substr(1);
+    impl_ = [suffix](const absl::string_view interface) {
+      return interface.size() > suffix.size() && absl::EndsWith(interface, suffix);
+    };
+    return;
+  }
+  if (absl::EndsWith(interface_name, "*")) {
+    const std::string prefix = interface_name.substr(0, interface_name.size() - 1);
+    impl_ = [prefix](const absl::string_view interface) {
+      return interface.size() > prefix.size() && absl::StartsWith(interface, prefix);
+    };
+    return;
+  }
+  impl_ = [interface_name](const absl::string_view interface) {
+    return interface == interface_name;
+  };
+}
+
 RouteConstSharedPtr SingleRouteMatcherImpl::route(const MessageMetadata& metadata,
                                                   uint64_t random_value) const {
   ASSERT(metadata.hasInvocationInfo());
-  const auto& invocation = metadata.invocationInfo();
+  const auto invocation = dynamic_cast<const RpcInvocationImpl*>(&metadata.invocationInfo());
+  ASSERT(invocation);
 
-  if (interface_matcher_.match(invocation.serviceName()) &&
-      (group_.value().empty() ||
-       (invocation.serviceGroup().has_value() && invocation.serviceGroup().value() == group_)) &&
-      (version_.value().empty() || (invocation.serviceVersion().has_value() &&
-                                    invocation.serviceVersion().value() == version_))) {
+  if (matchServiceName(*invocation) && matchServiceVersion(*invocation) &&
+      matchServiceGroup(*invocation)) {
     for (const auto& route : routes_) {
       RouteConstSharedPtr route_entry = route->matches(metadata, random_value);
       if (nullptr != route_entry) {
         return route_entry;
       }
     }
   } else {
     ENVOY_LOG(debug, "dubbo route matcher: interface matching failed");
   }
 
   return nullptr;
 }
diff --git a/source/extensions/filters/network/dubbo_proxy/router/route_matcher.h b/source/extensions/filters/network/dubbo_proxy/router/route_matcher.h
index b75c6d5be8..79ab71db3b 100644
--- a/source/extensions/filters/network/dubbo_proxy/router/route_matcher.h
+++ b/source/extensions/filters/network/dubbo_proxy/router/route_matcher.h
@@ -1,20 +1,21 @@
 #pragma once
 
 #include <memory>
 #include <string>
 #include <vector>
 
 #include "envoy/config/route/v3/route_components.pb.h"
 #include "envoy/extensions/filters/network/dubbo_proxy/v3/route.pb.h"
 #include "envoy/type/v3/range.pb.h"
 
 #include "common/common/logger.h"
 #include "common/common/matchers.h"
 #include "common/http/header_utility.h"
 #include "common/protobuf/protobuf.h"
 
+#include "extensions/filters/network/dubbo_proxy/message_impl.h"
 #include "extensions/filters/network/dubbo_proxy/metadata.h"
 #include "extensions/filters/network/dubbo_proxy/router/route.h"
 #include "extensions/filters/network/dubbo_proxy/router/router.h"
 
 #include "absl/types/optional.h"
@@ -47,7 +48,7 @@ public:
 
 protected:
   RouteConstSharedPtr clusterEntry(uint64_t random_value) const;
-  bool headersMatch(const Http::HeaderMap& headers) const;
+  bool headersMatch(const RpcInvocationImpl& invocation) const;
 
 private:
   class WeightedClusterEntry : public RouteEntry, public Route {
@@ -131,45 +132,25 @@ class SingleRouteMatcherImpl : public RouteMatcher, public Logger::Loggable<Logg
 public:
   class InterfaceMatcher {
   public:
-    using MatcherImpl = std::function<bool(const absl::string_view)>;
-    InterfaceMatcher(const std::string& interface_name) {
-      if (interface_name == "*") {
-        impl_ = [](const absl::string_view interface) { return !interface.empty(); };
-        return;
-      }
-      if (absl::StartsWith(interface_name, "*")) {
-        const std::string suffix = interface_name.substr(1);
-        impl_ = [suffix](const absl::string_view interface) {
-          return interface.size() > suffix.size() && absl::EndsWith(interface, suffix);
-        };
-        return;
-      }
-      if (absl::EndsWith(interface_name, "*")) {
-        const std::string prefix = interface_name.substr(0, interface_name.size() - 1);
-        impl_ = [prefix](const absl::string_view interface) {
-          return interface.size() > prefix.size() && absl::StartsWith(interface, prefix);
-        };
-        return;
-      }
-      impl_ = [interface_name](const absl::string_view interface) {
-        return interface == interface_name;
-      };
-    }
-
+    InterfaceMatcher(const std::string& interface_name);
     bool match(const absl::string_view interface) const { return impl_(interface); }
 
   private:
-    MatcherImpl impl_;
+    std::function<bool(const absl::string_view)> impl_;
   };
 
   using RouteConfig = envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration;
   SingleRouteMatcherImpl(const RouteConfig& config, Server::Configuration::FactoryContext& context);
 
   RouteConstSharedPtr route(const MessageMetadata& metadata, uint64_t random_value) const override;
 
 private:
+  bool matchServiceName(const RpcInvocationImpl& invocation) const;
+  bool matchServiceVersion(const RpcInvocationImpl& invocation) const;
+  bool matchServiceGroup(const RpcInvocationImpl& invocation) const;
+
   std::vector<RouteEntryImplBaseConstSharedPtr> routes_;
   const InterfaceMatcher interface_matcher_;
   const absl::optional<std::string> group_;
   const absl::optional<std::string> version_;
 };
diff --git a/source/extensions/filters/network/dubbo_proxy/router/router_impl.cc b/source/extensions/filters/network/dubbo_proxy/router/router_impl.cc
index 2d9e96a9d8..17e57fd499 100644
--- a/source/extensions/filters/network/dubbo_proxy/router/router_impl.cc
+++ b/source/extensions/filters/network/dubbo_proxy/router/router_impl.cc
@@ -1,9 +1,10 @@
 #include "extensions/filters/network/dubbo_proxy/router/router_impl.h"
 
 #include "envoy/upstream/cluster_manager.h"
 #include "envoy/upstream/thread_local_cluster.h"
 
 #include "extensions/filters/network/dubbo_proxy/app_exception.h"
+#include "extensions/filters/network/dubbo_proxy/message_impl.h"
 
 namespace Envoy {
 namespace Extensions {
@@ -25,60 +26,93 @@ void Router::setDecoderFilterCallbacks(DubboFilters::DecoderFilterCallbacks& cal
 FilterStatus Router::onMessageDecoded(MessageMetadataSharedPtr metadata, ContextSharedPtr ctx) {
   ASSERT(metadata->hasInvocationInfo());
   const auto& invocation = metadata->invocationInfo();
 
   route_ = callbacks_->route();
   if (!route_) {
     ENVOY_STREAM_LOG(debug, "dubbo router: no cluster match for interface '{}'", *callbacks_,
                      invocation.serviceName());
     callbacks_->sendLocalReply(AppException(ResponseStatus::ServiceNotFound,
                                             fmt::format("dubbo router: no route for interface '{}'",
                                                         invocation.serviceName())),
                                false);
     return FilterStatus::StopIteration;
   }
 
   route_entry_ = route_->routeEntry();
 
   Upstream::ThreadLocalCluster* cluster =
       cluster_manager_.getThreadLocalCluster(route_entry_->clusterName());
   if (!cluster) {
     ENVOY_STREAM_LOG(debug, "dubbo router: unknown cluster '{}'", *callbacks_,
                      route_entry_->clusterName());
     callbacks_->sendLocalReply(
         AppException(ResponseStatus::ServerError, fmt::format("dubbo router: unknown cluster '{}'",
                                                               route_entry_->clusterName())),
         false);
     return FilterStatus::StopIteration;
   }
 
   cluster_ = cluster->info();
   ENVOY_STREAM_LOG(debug, "dubbo router: cluster '{}' match for interface '{}'", *callbacks_,
                    route_entry_->clusterName(), invocation.serviceName());
 
   if (cluster_->maintenanceMode()) {
     callbacks_->sendLocalReply(
         AppException(ResponseStatus::ServerError,
                      fmt::format("dubbo router: maintenance mode for cluster '{}'",
                                  route_entry_->clusterName())),
         false);
     return FilterStatus::StopIteration;
   }
 
   Tcp::ConnectionPool::Instance* conn_pool =
       cluster->tcpConnPool(Upstream::ResourcePriority::Default, this);
   if (!conn_pool) {
     callbacks_->sendLocalReply(
         AppException(
             ResponseStatus::ServerError,
             fmt::format("dubbo router: no healthy upstream for '{}'", route_entry_->clusterName())),
         false);
     return FilterStatus::StopIteration;
   }
 
   ENVOY_STREAM_LOG(debug, "dubbo router: decoding request", *callbacks_);
-  upstream_request_buffer_.move(ctx->messageOriginData(), ctx->messageSize());
+
+  const auto* invocation_impl = dynamic_cast<const RpcInvocationImpl*>(&invocation);
+  ASSERT(invocation_impl);
+
+  if (invocation_impl->hasAttachment() && invocation_impl->attachment().attachmentUpdated()) {
+    constexpr size_t body_length_size = sizeof(uint32_t);
+
+    const size_t attachment_offset = invocation_impl->attachment().attachmentOffset();
+    const size_t request_header_size = ctx->headerSize();
+
+    ASSERT(attachment_offset <= ctx->originMessage().length());
+
+    // Move the other parts of the request headers except the body size to the upstream request
+    // buffer.
+    upstream_request_buffer_.move(ctx->originMessage(), request_header_size - body_length_size);
+    // Discard the old body size.
+    ctx->originMessage().drain(body_length_size);
+
+    // Re-serialize the updated attachment.
+    Buffer::OwnedImpl attachment_buffer;
+    Hessian2::Encoder encoder(std::make_unique<BufferWriter>(attachment_buffer));
+    encoder.encode(invocation_impl->attachment().attachment());
+
+    size_t new_body_size = attachment_offset - request_header_size + attachment_buffer.length();
+
+    upstream_request_buffer_.writeBEInt<uint32_t>(new_body_size);
+    upstream_request_buffer_.move(ctx->originMessage(), attachment_offset - request_header_size);
+    upstream_request_buffer_.move(attachment_buffer);
+
+    // Discard the old attachment.
+    ctx->originMessage().drain(ctx->messageSize() - attachment_offset);
+  } else {
+    upstream_request_buffer_.move(ctx->originMessage(), ctx->messageSize());
+  }
 
   upstream_request_ = std::make_unique<UpstreamRequest>(
       *this, *conn_pool, metadata, callbacks_->serializationType(), callbacks_->protocolType());
   return upstream_request_->start();
 }
diff --git a/source/extensions/filters/network/dubbo_proxy/router/router_impl.h b/source/extensions/filters/network/dubbo_proxy/router/router_impl.h
index 8eb73cc122..84a746d1f8 100644
--- a/source/extensions/filters/network/dubbo_proxy/router/router_impl.h
+++ b/source/extensions/filters/network/dubbo_proxy/router/router_impl.h
@@ -42,6 +42,9 @@ public:
   void onAboveWriteBufferHighWatermark() override {}
   void onBelowWriteBufferLowWatermark() override {}
 
+  // This function is for testing only.
+  Envoy::Buffer::Instance& upstreamRequestBufferForTest() { return upstream_request_buffer_; }
+
 private:
   struct UpstreamRequest : public Tcp::ConnectionPool::Callbacks {
     UpstreamRequest(Router& parent, Tcp::ConnectionPool::Instance& pool,
diff --git a/source/extensions/filters/network/dubbo_proxy/serializer_impl.cc b/source/extensions/filters/network/dubbo_proxy/serializer_impl.cc
deleted file mode 100644
index 550e847cc4..0000000000
--- a/source/extensions/filters/network/dubbo_proxy/serializer_impl.cc
+++ /dev/null
@@ -1,48 +0,0 @@
-#include "extensions/filters/network/dubbo_proxy/serializer_impl.h"
-
-namespace Envoy {
-namespace Extensions {
-namespace NetworkFilters {
-namespace DubboProxy {
-
-void RpcInvocationImpl::addParameterValue(uint32_t index, const std::string& value) {
-  assignParameterIfNeed();
-  parameter_map_->emplace(index, value);
-}
-
-const std::string& RpcInvocationImpl::getParameterValue(uint32_t index) const {
-  if (parameter_map_) {
-    auto itor = parameter_map_->find(index);
-    if (itor != parameter_map_->end()) {
-      return itor->second;
-    }
-  }
-
-  return EMPTY_STRING;
-}
-
-const RpcInvocationImpl::ParameterValueMap& RpcInvocationImpl::parameters() {
-  ASSERT(hasParameters());
-  return *parameter_map_;
-}
-
-const Http::HeaderMap& RpcInvocationImpl::headers() const {
-  ASSERT(hasHeaders());
-  return *headers_;
-}
-
-void RpcInvocationImpl::addHeader(const std::string& key, const std::string& value) {
-  assignHeaderIfNeed();
-  headers_->addCopy(Http::LowerCaseString(key), value);
-}
-
-void RpcInvocationImpl::addHeaderReference(const Http::LowerCaseString& key,
-                                           const std::string& value) {
-  assignHeaderIfNeed();
-  headers_->addReference(key, value);
-}
-
-} // namespace DubboProxy
-} // namespace NetworkFilters
-} // namespace Extensions
-} // namespace Envoy
diff --git a/source/extensions/filters/network/dubbo_proxy/serializer_impl.h b/source/extensions/filters/network/dubbo_proxy/serializer_impl.h
deleted file mode 100644
index 1c9bcd7ccf..0000000000
--- a/source/extensions/filters/network/dubbo_proxy/serializer_impl.h
+++ /dev/null
@@ -1,62 +0,0 @@
-#pragma once
-
-#include "extensions/filters/network/dubbo_proxy/message_impl.h"
-#include "extensions/filters/network/dubbo_proxy/serializer.h"
-
-namespace Envoy {
-namespace Extensions {
-namespace NetworkFilters {
-namespace DubboProxy {
-
-class RpcInvocationImpl : public RpcInvocationBase {
-public:
-  // TODO(gengleilei) Add parameter data types and implement Dubbo data type mapping.
-  using ParameterValueMap = absl::node_hash_map<uint32_t, std::string>;
-  using ParameterValueMapPtr = std::unique_ptr<ParameterValueMap>;
-
-  RpcInvocationImpl() = default;
-  ~RpcInvocationImpl() override = default;
-
-  void addParameterValue(uint32_t index, const std::string& value);
-  const ParameterValueMap& parameters();
-  const std::string& getParameterValue(uint32_t index) const;
-  bool hasParameters() const { return parameter_map_ != nullptr; }
-
-  void addHeader(const std::string& key, const std::string& value);
-  void addHeaderReference(const Http::LowerCaseString& key, const std::string& value);
-  const Http::HeaderMap& headers() const;
-  bool hasHeaders() const { return headers_ != nullptr; }
-
-private:
-  inline void assignHeaderIfNeed() {
-    if (!headers_) {
-      headers_ = Http::RequestHeaderMapImpl::create();
-    }
-  }
-
-  inline void assignParameterIfNeed() {
-    if (!parameter_map_) {
-      parameter_map_ = std::make_unique<ParameterValueMap>();
-    }
-  }
-
-  ParameterValueMapPtr parameter_map_;
-  Http::HeaderMapPtr headers_; // attachment
-};
-
-class RpcResultImpl : public RpcResult {
-public:
-  RpcResultImpl() = default;
-  ~RpcResultImpl() override = default;
-
-  bool hasException() const override { return has_exception_; }
-  void setException(bool has_exception) { has_exception_ = has_exception; }
-
-private:
-  bool has_exception_ = false;
-};
-
-} // namespace DubboProxy
-} // namespace NetworkFilters
-} // namespace Extensions
-} // namespace Envoy
diff --git a/test/extensions/filters/network/dubbo_proxy/BUILD b/test/extensions/filters/network/dubbo_proxy/BUILD
index 1a2b5e0aa8..6eb15466f4 100644
--- a/test/extensions/filters/network/dubbo_proxy/BUILD
+++ b/test/extensions/filters/network/dubbo_proxy/BUILD
@@ -55,6 +55,17 @@ envoy_extension_cc_test(
     ],
 )
 
+envoy_extension_cc_test(
+    name = "message_impl_test",
+    srcs = ["message_impl_test.cc"],
+    extension_name = "envoy.filters.network.dubbo_proxy",
+    deps = [
+        "//source/extensions/filters/network/dubbo_proxy:message_lib",
+        "//test/test_common:printers_lib",
+        "//test/test_common:utility_lib",
+    ],
+)
+
 envoy_extension_cc_test(
     name = "dubbo_protocol_impl_test",
     srcs = ["dubbo_protocol_impl_test.cc"],
@@ -120,15 +131,16 @@ envoy_extension_cc_test(
 envoy_extension_cc_test(
     name = "router_test",
     srcs = ["router_test.cc"],
     extension_name = "envoy.filters.network.dubbo_proxy",
     deps = [
         ":mocks_lib",
+        ":utility_lib",
         "//source/extensions/filters/network/dubbo_proxy:app_exception_lib",
         "//source/extensions/filters/network/dubbo_proxy:dubbo_hessian2_serializer_impl_lib",
         "//source/extensions/filters/network/dubbo_proxy:dubbo_protocol_impl_lib",
         "//source/extensions/filters/network/dubbo_proxy:metadata_lib",
         "//source/extensions/filters/network/dubbo_proxy/router:config",
         "//test/mocks/server:factory_context_mocks",
         "//test/test_common:registry_lib",
     ],
 )
@@ -148,6 +160,20 @@ envoy_extension_cc_test(
     ],
 )
 
+envoy_extension_cc_test(
+    name = "heartbeat_response_test",
+    srcs = ["heartbeat_response_test.cc"],
+    extension_name = "envoy.filters.network.dubbo_proxy",
+    deps = [
+        ":mocks_lib",
+        ":utility_lib",
+        "//source/extensions/filters/network/dubbo_proxy:dubbo_protocol_impl_lib",
+        "//source/extensions/filters/network/dubbo_proxy:heartbeat_response_lib",
+        "//source/extensions/filters/network/dubbo_proxy:hessian_utils_lib",
+        "//source/extensions/filters/network/dubbo_proxy:metadata_lib",
+    ],
+)
+
 envoy_extension_cc_test(
     name = "router_filter_config_test",
     srcs = ["router_filter_config_test.cc"],
diff --git a/test/extensions/filters/network/dubbo_proxy/app_exception_test.cc b/test/extensions/filters/network/dubbo_proxy/app_exception_test.cc
index d58bea0e47..49403617d9 100644
--- a/test/extensions/filters/network/dubbo_proxy/app_exception_test.cc
+++ b/test/extensions/filters/network/dubbo_proxy/app_exception_test.cc
@@ -1,17 +1,18 @@
 #include "extensions/filters/network/dubbo_proxy/app_exception.h"
 #include "extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.h"
 #include "extensions/filters/network/dubbo_proxy/dubbo_protocol_impl.h"
 #include "extensions/filters/network/dubbo_proxy/filters/filter.h"
 #include "extensions/filters/network/dubbo_proxy/hessian_utils.h"
+#include "extensions/filters/network/dubbo_proxy/message_impl.h"
 #include "extensions/filters/network/dubbo_proxy/metadata.h"
-#include "extensions/filters/network/dubbo_proxy/serializer_impl.h"
 
 #include "test/extensions/filters/network/dubbo_proxy/mocks.h"
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 
 using testing::_;
+using testing::NiceMock;
 using testing::Return;
 
 namespace Envoy {
@@ -19,6 +20,8 @@ namespace Extensions {
 namespace NetworkFilters {
 namespace DubboProxy {
 
+namespace {
+
 class AppExceptionTest : public testing::Test {
 public:
   AppExceptionTest() : metadata_(std::make_shared<MessageMetadata>()) {
@@ -32,52 +35,79 @@ public:
 TEST_F(AppExceptionTest, Encode) {
   std::string mock_message("invalid method name 'Sub'");
   AppException app_exception(ResponseStatus::ServiceNotFound, mock_message);
 
   Buffer::OwnedImpl buffer;
-  size_t expect_body_size =
-      HessianUtils::writeString(buffer, mock_message) +
-      HessianUtils::writeInt(buffer, static_cast<uint8_t>(app_exception.response_type_));
+
+  Hessian2::Encoder encoder(std::make_unique<BufferWriter>(buffer));
+
+  encoder.encode(mock_message);
+  encoder.encode(static_cast<uint8_t>(app_exception.response_type_));
+
+  size_t expect_body_size = buffer.length();
+
   buffer.drain(buffer.length());
 
   metadata_->setSerializationType(SerializationType::Hessian2);
   metadata_->setRequestId(0);
 
   EXPECT_EQ(app_exception.encode(*(metadata_.get()), protocol_, buffer),
             DubboFilters::DirectResponse::ResponseType::Exception);
   MessageMetadataSharedPtr metadata = std::make_shared<MessageMetadata>();
   auto result = protocol_.decodeHeader(buffer, metadata);
   EXPECT_TRUE(result.second);
 
   const ContextImpl* context = static_cast<const ContextImpl*>(result.first.get());
   EXPECT_EQ(expect_body_size, context->bodySize());
   EXPECT_EQ(metadata->messageType(), MessageType::Response);
   buffer.drain(context->headerSize());
 
   // Verify the response type and content.
-  size_t hessian_int_size;
-  int type_value = HessianUtils::peekInt(buffer, &hessian_int_size);
+  Hessian2::Decoder decoder(std::make_unique<BufferReader>(buffer));
+
+  int type_value = *decoder.decode<int32_t>();
   EXPECT_EQ(static_cast<uint8_t>(app_exception.response_type_), static_cast<uint8_t>(type_value));
 
-  size_t hessian_string_size;
-  std::string message = HessianUtils::peekString(buffer, &hessian_string_size, sizeof(uint8_t));
+  std::string message = *decoder.decode<std::string>();
   EXPECT_EQ(mock_message, message);
 
-  EXPECT_EQ(buffer.length(), hessian_int_size + hessian_string_size);
+  EXPECT_EQ(buffer.length(), decoder.offset());
 
   auto rpc_result = protocol_.serializer()->deserializeRpcResult(buffer, result.first);
   EXPECT_TRUE(rpc_result.second);
   EXPECT_TRUE(rpc_result.first->hasException());
   buffer.drain(buffer.length());
 
   AppException new_app_exception(app_exception);
   EXPECT_EQ(new_app_exception.status_, ResponseStatus::ServiceNotFound);
 
   MockProtocol mock_protocol;
   EXPECT_CALL(mock_protocol, encode(_, _, _, _)).WillOnce(Return(false));
   EXPECT_THROW(app_exception.encode(*(metadata_.get()), mock_protocol, buffer), EnvoyException);
 }
 
+class AppExceptionTestWithMock : public testing::Test {
+public:
+  AppExceptionTestWithMock() : metadata_(std::make_shared<MessageMetadata>()) {}
+
+  NiceMock<MockProtocol> mock_protocol_;
+  MessageMetadataSharedPtr metadata_;
+};
+
+TEST_F(AppExceptionTestWithMock, AppExceptionTestWithMock) {
+  std::string mock_message("MOCK_MESSAGE");
+  AppException app_exception(ResponseStatus::ServiceNotFound, mock_message);
+
+  Buffer::OwnedImpl buffer;
+
+  ON_CALL(mock_protocol_, encode(_, _, _, _)).WillByDefault(Return(false));
+
+  EXPECT_THROW_WITH_MESSAGE(app_exception.encode(*metadata_, mock_protocol_, buffer),
+                            EnvoyException, "Failed to encode local reply message");
+}
+
+} // namespace
+
 } // namespace DubboProxy
 } // namespace NetworkFilters
 } // namespace Extensions
 } // namespace Envoy
diff --git a/test/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl_test.cc b/test/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl_test.cc
index 4bc08cb93c..19113bba6b 100644
--- a/test/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl_test.cc
+++ b/test/extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl_test.cc
@@ -23,131 +23,431 @@ TEST(HessianProtocolTest, Name) {
 TEST(HessianProtocolTest, deserializeRpcInvocation) {
   DubboHessian2SerializerImpl serializer;
 
   {
     Buffer::OwnedImpl buffer;
     buffer.add(std::string({
         0x05, '2', '.', '0', '.', '2', // Dubbo version
         0x04, 't', 'e', 's', 't',      // Service name
         0x05, '0', '.', '0', '.', '0', // Service version
         0x04, 't', 'e', 's', 't',      // method name
     }));
     std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
     context->setBodySize(buffer.length());
     auto result = serializer.deserializeRpcInvocation(buffer, context);
     EXPECT_TRUE(result.second);
 
     auto invo = result.first;
     EXPECT_STREQ("test", invo->methodName().c_str());
     EXPECT_STREQ("test", invo->serviceName().c_str());
     EXPECT_STREQ("0.0.0", invo->serviceVersion().value().c_str());
   }
 
   // incorrect body size
   {
     Buffer::OwnedImpl buffer;
     buffer.add(std::string({
         0x05, '2', '.', '0', '.', '2', // Dubbo version
         0x04, 't', 'e', 's', 't',      // Service name
         0x05, '0', '.', '0', '.', '0', // Service version
         0x04, 't', 'e', 's', 't',      // method name
     }));
-    std::string exception_string = fmt::format("RpcInvocation size({}) large than body size({})",
+    std::string exception_string = fmt::format("RpcInvocation size({}) larger than body size({})",
                                                buffer.length(), buffer.length() - 1);
     std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
     context->setBodySize(buffer.length() - 1);
     EXPECT_THROW_WITH_MESSAGE(serializer.deserializeRpcInvocation(buffer, context), EnvoyException,
                               exception_string);
   }
+
+  // Missing key metadata.
+  {
+    Buffer::OwnedImpl buffer;
+    buffer.add(std::string({
+        0x05, '2', '.', '0', '.', '2', // Dubbo version
+        0x04, 't', 'e', 's', 't',      // Service name
+        0x05, '0', '.', '0', '.', '0', // Service version
+    }));
+    std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
+    context->setBodySize(buffer.length());
+    EXPECT_THROW_WITH_MESSAGE(serializer.deserializeRpcInvocation(buffer, context), EnvoyException,
+                              "RpcInvocation has no request metadata");
+  }
+}
+
+TEST(HessianProtocolTest, deserializeRpcInvocationWithParametersOrAttachment) {
+  RpcInvocationImpl::Attachment attach(std::make_unique<RpcInvocationImpl::Attachment::Map>(), 0);
+  attach.insert("test1", "test_value1");
+  attach.insert("test2", "test_value2");
+  attach.insert("test3", "test_value3");
+
+  RpcInvocationImpl::Parameters params;
+
+  params.push_back(std::make_unique<Hessian2::StringObject>("test_string"));
+
+  std::vector<uint8_t> test_binary{0, 1, 2, 3, 4};
+  params.push_back(std::make_unique<Hessian2::BinaryObject>(test_binary));
+
+  params.push_back(std::make_unique<Hessian2::LongObject>(233333));
+
+  // 4 parameters. We will encode attachment as a map type parameter.
+  std::string parameters_type = "Ljava.lang.String;[BJLjava.util.Map;";
+
+  {
+    DubboHessian2SerializerImpl serializer;
+    Buffer::OwnedImpl buffer;
+    buffer.add(std::string({
+        0x05, '2', '.', '0', '.', '2', // Dubbo version
+        0x04, 't', 'e', 's', 't',      // Service name
+        0x05, '0', '.', '0', '.', '0', // Service version
+        0x04, 't', 'e', 's', 't',      // method name
+    }));
+
+    Hessian2::Encoder encoder(std::make_unique<BufferWriter>(buffer));
+
+    encoder.encode<std::string>(parameters_type);
+
+    for (const auto& param : params) {
+      encoder.encode<Hessian2::Object>(*param);
+    }
+    // Encode an untyped map object as fourth parameter.
+    encoder.encode<Hessian2::Object>(attach.attachment());
+
+    size_t expected_attachment_offset = buffer.length();
+
+    // Encode attachment
+    encoder.encode<Hessian2::Object>(attach.attachment());
+
+    std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
+
+    context->setBodySize(buffer.length());
+
+    auto result = serializer.deserializeRpcInvocation(buffer, context);
+    EXPECT_EQ(true, result.second);
+
+    auto invo = dynamic_cast<RpcInvocationImpl*>(result.first.get());
+
+    context->originMessage().move(buffer, buffer.length());
+
+    EXPECT_EQ(false, invo->hasAttachment());
+    EXPECT_EQ(false, invo->hasParameters());
+
+    auto& result_params = invo->mutableParameters();
+
+    // When parsing parameters, attachment will not be parsed.
+    EXPECT_EQ(false, invo->hasAttachment());
+    EXPECT_EQ(true, invo->hasParameters());
+
+    EXPECT_EQ(4, result_params->size());
+
+    EXPECT_EQ("test_string", *result_params->at(0)->toString().value());
+    EXPECT_EQ(4, result_params->at(1)->toBinary().value()->at(4));
+    EXPECT_EQ(233333, *result_params->at(2)->toLong());
+    EXPECT_EQ(3, result_params->at(3)->toUntypedMap().value()->size());
+    EXPECT_EQ("test_value2", *(result_params->at(3)
+                                   ->toUntypedMap()
+                                   .value()
+                                   ->find(std::make_unique<Hessian2::StringObject>("test2"))
+                                   ->second->toString()
+                                   .value()));
+
+    auto& result_attach = invo->mutableAttachment();
+    EXPECT_EQ("test_value2", *(result_attach->attachment()
+                                   .toUntypedMap()
+                                   .value()
+                                   ->find(std::make_unique<Hessian2::StringObject>("test2"))
+                                   ->second->toString()
+                                   .value()));
+
+    EXPECT_EQ(expected_attachment_offset, result_attach->attachmentOffset());
+  }
+  {
+    DubboHessian2SerializerImpl serializer;
+    Buffer::OwnedImpl buffer;
+    buffer.add(std::string({
+        0x05, '2', '.', '0', '.', '2', // Dubbo version
+        0x04, 't', 'e', 's', 't',      // Service name
+        0x05, '0', '.', '0', '.', '0', // Service version
+        0x04, 't', 'e', 's', 't',      // method name
+    }));
+
+    Hessian2::Encoder encoder(std::make_unique<BufferWriter>(buffer));
+
+    encoder.encode<std::string>(parameters_type);
+
+    for (const auto& param : params) {
+      encoder.encode<Hessian2::Object>(*param);
+    }
+    // Encode an untyped map object as fourth parameter.
+    encoder.encode<Hessian2::Object>(attach.attachment());
+
+    // Encode attachment
+    encoder.encode<Hessian2::Object>(attach.attachment());
+
+    std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
+
+    context->setBodySize(buffer.length());
+
+    auto result = serializer.deserializeRpcInvocation(buffer, context);
+    EXPECT_EQ(true, result.second);
+
+    auto invo = dynamic_cast<RpcInvocationImpl*>(result.first.get());
+
+    context->originMessage().move(buffer, buffer.length());
+
+    EXPECT_EQ(false, invo->hasAttachment());
+    EXPECT_EQ(false, invo->hasParameters());
+
+    auto& result_attach = invo->mutableAttachment();
+
+    // When parsing attachment, parameters will also be parsed.
+    EXPECT_EQ(true, invo->hasAttachment());
+    EXPECT_EQ(true, invo->hasParameters());
+
+    EXPECT_EQ("test_value2", *(result_attach->attachment()
+                                   .toUntypedMap()
+                                   .value()
+                                   ->find(std::make_unique<Hessian2::StringObject>("test2"))
+                                   ->second->toString()
+                                   .value()));
+
+    auto& result_params = invo->parameters();
+    EXPECT_EQ("test_value2", *(result_params.at(3)
+                                   ->toUntypedMap()
+                                   .value()
+                                   ->find(std::make_unique<Hessian2::StringObject>("test2"))
+                                   ->second->toString()
+                                   .value()));
+  }
+  // Test case that request only have parameters.
+  {
+    DubboHessian2SerializerImpl serializer;
+    Buffer::OwnedImpl buffer;
+    buffer.add(std::string({
+        0x05, '2', '.', '0', '.', '2', // Dubbo version
+        0x04, 't', 'e', 's', 't',      // Service name
+        0x05, '0', '.', '0', '.', '0', // Service version
+        0x04, 't', 'e', 's', 't',      // method name
+    }));
+
+    Hessian2::Encoder encoder(std::make_unique<BufferWriter>(buffer));
+
+    encoder.encode<std::string>(parameters_type);
+
+    for (const auto& param : params) {
+      encoder.encode<Hessian2::Object>(*param);
+    }
+    // Encode an untyped map object as fourth parameter.
+    encoder.encode<Hessian2::Object>(attach.attachment());
+
+    std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
+
+    context->setBodySize(buffer.length());
+
+    auto result = serializer.deserializeRpcInvocation(buffer, context);
+    EXPECT_EQ(true, result.second);
+
+    auto invo = dynamic_cast<RpcInvocationImpl*>(result.first.get());
+
+    context->originMessage().move(buffer, buffer.length());
+
+    EXPECT_EQ(false, invo->hasAttachment());
+    EXPECT_EQ(false, invo->hasParameters());
+
+    auto& result_attach = invo->mutableAttachment();
+
+    // When parsing attachment, parameters will also be parsed.
+    EXPECT_EQ(true, invo->hasAttachment());
+    EXPECT_EQ(true, invo->hasParameters());
+
+    auto& result_params = invo->parameters();
+    EXPECT_EQ("test_value2", *(result_params.at(3)
+                                   ->toUntypedMap()
+                                   .value()
+                                   ->find(std::make_unique<Hessian2::StringObject>("test2"))
+                                   ->second->toString()
+                                   .value()));
+
+    EXPECT_EQ(true, result_attach->attachment().toUntypedMap().value()->empty());
+  }
+  // Test the case where there are not enough parameters in the request buffer.
+  {
+    DubboHessian2SerializerImpl serializer;
+    Buffer::OwnedImpl buffer;
+    buffer.add(std::string({
+        0x05, '2', '.', '0', '.', '2', // Dubbo version
+        0x04, 't', 'e', 's', 't',      // Service name
+        0x05, '0', '.', '0', '.', '0', // Service version
+        0x04, 't', 'e', 's', 't',      // method name
+    }));
+
+    Hessian2::Encoder encoder(std::make_unique<BufferWriter>(buffer));
+
+    encoder.encode<std::string>(parameters_type);
+
+    // There are actually only three parameters in the request.
+    for (const auto& param : params) {
+      encoder.encode<Hessian2::Object>(*param);
+    }
+
+    std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
+
+    context->setBodySize(buffer.length());
+
+    auto result = serializer.deserializeRpcInvocation(buffer, context);
+    EXPECT_EQ(true, result.second);
+
+    auto invo = dynamic_cast<RpcInvocationImpl*>(result.first.get());
+
+    context->originMessage().move(buffer, buffer.length());
+
+    // There are not enough parameters and throws an exception.
+    EXPECT_THROW_WITH_MESSAGE(invo->mutableParameters(), EnvoyException,
+                              "Cannot parse RpcInvocation parameter from buffer");
+  }
+  // Test for incorrect attachment types.
+  {
+    DubboHessian2SerializerImpl serializer;
+    Buffer::OwnedImpl buffer;
+    buffer.add(std::string({
+        0x05, '2', '.', '0', '.', '2', // Dubbo version
+        0x04, 't', 'e', 's', 't',      // Service name
+        0x05, '0', '.', '0', '.', '0', // Service version
+        0x04, 't', 'e', 's', 't',      // method name
+    }));
+
+    Hessian2::Encoder encoder(std::make_unique<BufferWriter>(buffer));
+
+    encoder.encode<std::string>(parameters_type);
+
+    for (const auto& param : params) {
+      encoder.encode<Hessian2::Object>(*param);
+    }
+    // Encode an untyped map object as fourth parameter.
+    encoder.encode<Hessian2::Object>(attach.attachment());
+
+    // Encode a string object as attachment.
+    encoder.encode<Hessian2::Object>(*params[0]);
+
+    std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
+
+    context->setBodySize(buffer.length());
+
+    auto result = serializer.deserializeRpcInvocation(buffer, context);
+    EXPECT_EQ(true, result.second);
+
+    auto invo = dynamic_cast<RpcInvocationImpl*>(result.first.get());
+
+    context->originMessage().move(buffer, buffer.length());
+
+    auto& result_attach = invo->mutableAttachment();
+    EXPECT_EQ(true, result_attach->attachment().toUntypedMap().value()->empty());
+  }
 }
 
 TEST(HessianProtocolTest, deserializeRpcResult) {
   DubboHessian2SerializerImpl serializer;
   std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
 
+  {
+    Buffer::OwnedImpl buffer;
+    buffer.add(std::string({
+        0x04,
+        't',
+        'e',
+        's',
+        't',
+    }));
+
+    context->setBodySize(4);
+
+    EXPECT_THROW_WITH_MESSAGE(serializer.deserializeRpcResult(buffer, context), EnvoyException,
+                              "Cannot parse RpcResult type from buffer");
+  }
+
   {
     Buffer::OwnedImpl buffer;
     buffer.add(std::string({
         '\x94',                   // return type
         0x04, 't', 'e', 's', 't', // return body
     }));
     context->setBodySize(4);
     auto result = serializer.deserializeRpcResult(buffer, context);
     EXPECT_TRUE(result.second);
     EXPECT_FALSE(result.first->hasException());
   }
 
   {
     Buffer::OwnedImpl buffer;
     buffer.add(std::string({
         '\x93',                   // return type
         0x04, 't', 'e', 's', 't', // return body
     }));
     context->setBodySize(4);
     auto result = serializer.deserializeRpcResult(buffer, context);
     EXPECT_TRUE(result.second);
     EXPECT_TRUE(result.first->hasException());
   }
 
   {
     Buffer::OwnedImpl buffer;
     buffer.add(std::string({
         '\x90',                   // return type
         0x04, 't', 'e', 's', 't', // return body
     }));
     context->setBodySize(4);
     auto result = serializer.deserializeRpcResult(buffer, context);
     EXPECT_TRUE(result.second);
     EXPECT_TRUE(result.first->hasException());
   }
 
   {
     Buffer::OwnedImpl buffer;
     buffer.add(std::string({
         '\x91',                   // return type
         0x04, 't', 'e', 's', 't', // return body
     }));
     context->setBodySize(4);
     auto result = serializer.deserializeRpcResult(buffer, context);
     EXPECT_TRUE(result.second);
     EXPECT_FALSE(result.first->hasException());
   }
 
   // incorrect body size
   {
     Buffer::OwnedImpl buffer;
     buffer.add(std::string({
         '\x94',                   // return type
         0x05, 't', 'e', 's', 't', // return body
     }));
     context->setBodySize(0);
     EXPECT_THROW_WITH_MESSAGE(serializer.deserializeRpcResult(buffer, context), EnvoyException,
                               "RpcResult size(1) large than body size(0)");
   }
 
   // incorrect return type
   {
     Buffer::OwnedImpl buffer;
     buffer.add(std::string({
         '\x96',                   // incorrect return type
         0x05, 't', 'e', 's', 't', // return body
     }));
     context->setBodySize(buffer.length());
     EXPECT_THROW_WITH_MESSAGE(serializer.deserializeRpcResult(buffer, context), EnvoyException,
                               "not supported return type 6");
   }
 
   // incorrect value size
   {
     Buffer::OwnedImpl buffer;
     buffer.add(std::string({
         '\x92',                   // without the value of the return type
         0x05, 't', 'e', 's', 't', // return body
     }));
     std::string exception_string =
         fmt::format("RpcResult is no value, but the rest of the body size({}) not equal 0",
                     buffer.length() - 1);
     context->setBodySize(buffer.length());
     EXPECT_THROW_WITH_MESSAGE(serializer.deserializeRpcResult(buffer, context), EnvoyException,
                               exception_string);
   }
 }
@@ -163,29 +463,29 @@ TEST(HessianProtocolTest, HessianDeserializerConfigFactory) {
 TEST(HessianProtocolTest, serializeRpcResult) {
   Buffer::OwnedImpl buffer;
   std::string mock_response("invalid method name 'Add'");
   RpcResponseType mock_response_type = RpcResponseType::ResponseWithException;
   DubboHessian2SerializerImpl serializer;
 
   EXPECT_NE(serializer.serializeRpcResult(buffer, mock_response, mock_response_type), 0);
 
-  size_t hessian_int_size;
-  int type_value = HessianUtils::peekInt(buffer, &hessian_int_size);
+  Hessian2::Decoder decoder(std::make_unique<BufferReader>(buffer));
+
+  int type_value = *decoder.decode<int32_t>();
   EXPECT_EQ(static_cast<uint8_t>(mock_response_type), static_cast<uint8_t>(type_value));
 
-  size_t hessian_string_size;
-  std::string content = HessianUtils::peekString(buffer, &hessian_string_size, sizeof(uint8_t));
+  std::string content = *decoder.decode<std::string>();
   EXPECT_EQ(mock_response, content);
 
-  EXPECT_EQ(buffer.length(), hessian_int_size + hessian_string_size);
+  EXPECT_EQ(buffer.length(), decoder.offset());
 
   size_t body_size = mock_response.size() + sizeof(mock_response_type);
   std::shared_ptr<ContextImpl> context = std::make_shared<ContextImpl>();
   context->setBodySize(body_size);
   auto result = serializer.deserializeRpcResult(buffer, context);
   EXPECT_TRUE(result.first->hasException());
 }
 
 } // namespace DubboProxy
 } // namespace NetworkFilters
 } // namespace Extensions
 } // namespace Envoy
diff --git a/test/extensions/filters/network/dubbo_proxy/dubbo_protocol_impl_test.cc b/test/extensions/filters/network/dubbo_proxy/dubbo_protocol_impl_test.cc
index 0dafbc8fef..2501f0adfa 100644
--- a/test/extensions/filters/network/dubbo_proxy/dubbo_protocol_impl_test.cc
+++ b/test/extensions/filters/network/dubbo_proxy/dubbo_protocol_impl_test.cc
@@ -122,33 +122,31 @@ TEST(DubboProtocolImplTest, DubboProtocolConfigFactory) {
 TEST(DubboProtocolImplTest, encode) {
   MessageMetadata metadata;
   metadata.setMessageType(MessageType::Response);
   metadata.setResponseStatus(ResponseStatus::ServiceNotFound);
   metadata.setSerializationType(SerializationType::Hessian2);
   metadata.setRequestId(100);
 
   Buffer::OwnedImpl buffer;
   DubboProtocolImpl dubbo_protocol;
   dubbo_protocol.initSerializer(SerializationType::Hessian2);
   std::string content("this is test data");
   EXPECT_TRUE(dubbo_protocol.encode(buffer, metadata, content, RpcResponseType::ResponseWithValue));
 
   MessageMetadataSharedPtr output_metadata = std::make_shared<MessageMetadata>();
   auto result = dubbo_protocol.decodeHeader(buffer, output_metadata);
   EXPECT_TRUE(result.second);
 
   EXPECT_EQ(metadata.messageType(), output_metadata->messageType());
   EXPECT_EQ(metadata.responseStatus(), output_metadata->responseStatus());
   EXPECT_EQ(metadata.serializationType(), output_metadata->serializationType());
   EXPECT_EQ(metadata.requestId(), output_metadata->requestId());
 
   Buffer::OwnedImpl body_buffer;
   size_t serialized_body_size = dubbo_protocol.serializer()->serializeRpcResult(
       body_buffer, content, RpcResponseType::ResponseWithValue);
   auto context = result.first;
   EXPECT_EQ(context->bodySize(), serialized_body_size);
-  EXPECT_EQ(false, context->hasAttachments());
-  EXPECT_EQ(0, context->attachments().size());
 
   buffer.drain(context->headerSize());
   EXPECT_TRUE(dubbo_protocol.decodeData(buffer, context, output_metadata));
 }
diff --git a/test/extensions/filters/network/dubbo_proxy/heartbeat_response_test.cc b/test/extensions/filters/network/dubbo_proxy/heartbeat_response_test.cc
new file mode 100644
index 0000000000..1313da2da0
--- /dev/null
+++ b/test/extensions/filters/network/dubbo_proxy/heartbeat_response_test.cc
@@ -0,0 +1,63 @@
+#include "extensions/filters/network/dubbo_proxy/heartbeat_response.h"
+#include "extensions/filters/network/dubbo_proxy/hessian_utils.h"
+#include "extensions/filters/network/dubbo_proxy/message_impl.h"
+#include "extensions/filters/network/dubbo_proxy/metadata.h"
+
+#include "test/extensions/filters/network/dubbo_proxy/mocks.h"
+
+#include "gmock/gmock.h"
+#include "gtest/gtest.h"
+
+using testing::_;
+using testing::NiceMock;
+using testing::Return;
+
+namespace Envoy {
+namespace Extensions {
+namespace NetworkFilters {
+namespace DubboProxy {
+
+namespace {
+
+class HeartbeatResponseTestWithMock : public testing::Test {
+public:
+  HeartbeatResponseTestWithMock() : metadata_(std::make_shared<MessageMetadata>()) {
+    metadata_->setResponseStatus(ResponseStatus::Ok);
+    metadata_->setMessageType(MessageType::HeartbeatResponse);
+  }
+
+  NiceMock<MockProtocol> mock_protocol_;
+  MessageMetadataSharedPtr metadata_;
+};
+
+TEST_F(HeartbeatResponseTestWithMock, HeartbeatResponseTestWithMock) {
+  {
+    std::string mock_message("MOCK_MESSAGE");
+    HeartbeatResponse heartbeat_response;
+
+    Buffer::OwnedImpl buffer;
+
+    ON_CALL(mock_protocol_, encode(_, _, _, _)).WillByDefault(Return(false));
+
+    EXPECT_THROW_WITH_MESSAGE(heartbeat_response.encode(*metadata_, mock_protocol_, buffer),
+                              EnvoyException, "failed to encode heartbeat message");
+  }
+  {
+    std::string mock_message("MOCK_MESSAGE");
+    HeartbeatResponse heartbeat_response;
+
+    Buffer::OwnedImpl buffer;
+
+    ON_CALL(mock_protocol_, encode(_, _, _, _)).WillByDefault(Return(true));
+
+    EXPECT_EQ(heartbeat_response.encode(*metadata_, mock_protocol_, buffer),
+              DubboFilters::DirectResponse::ResponseType::SuccessReply);
+  }
+}
+
+} // namespace
+
+} // namespace DubboProxy
+} // namespace NetworkFilters
+} // namespace Extensions
+} // namespace Envoy
diff --git a/test/extensions/filters/network/dubbo_proxy/hessian_utils_test.cc b/test/extensions/filters/network/dubbo_proxy/hessian_utils_test.cc
index 6f5d6387af..daf167ef1d 100644
--- a/test/extensions/filters/network/dubbo_proxy/hessian_utils_test.cc
+++ b/test/extensions/filters/network/dubbo_proxy/hessian_utils_test.cc
@@ -12,900 +12,75 @@ namespace Extensions {
 namespace NetworkFilters {
 namespace DubboProxy {
 
-TEST(HessianUtilsTest, peekString) {
-  // Insufficient data
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x02, 't'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekString(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x30}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekString(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x30, 't'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekString(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x53, 't'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekString(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x53, 't', 'e'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekString(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x52, 't'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekString(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  // Incorrect type
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x20, 't'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekString(buffer, &size), EnvoyException,
-                              "hessian type is not string 32");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x01, 't'}));
-    size_t size;
-    EXPECT_STREQ("t", HessianUtils::peekString(buffer, &size).c_str());
-    EXPECT_EQ(2, size);
-  }
-
-  // empty string
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x00}));
-    size_t size;
-    EXPECT_STREQ("", HessianUtils::peekString(buffer, &size).c_str());
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x01, 0x00}));
-    size_t size;
-    EXPECT_STREQ("", HessianUtils::peekString(buffer, &size, 1).c_str());
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x53, 0x00, 0x05, 'h', 'e', 'l', 'l', 'o'}));
-    size_t size;
-    EXPECT_STREQ("hello", HessianUtils::peekString(buffer, &size).c_str());
-    EXPECT_EQ(8, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string(
-        {0x52, 0x00, 0x07, 'h', 'e', 'l', 'l', 'o', ',', ' ', 0x05, 'w', 'o', 'r', 'l', 'd'}));
-    size_t size;
-    EXPECT_STREQ("hello, world", HessianUtils::peekString(buffer, &size).c_str());
-    EXPECT_EQ(16, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x31, 0x01}) + std::string(256 + 0x01, 't'));
-    size_t size;
-    EXPECT_STREQ(std::string(256 + 0x01, 't').c_str(),
-                 HessianUtils::peekString(buffer, &size).c_str());
-    EXPECT_EQ(256 + 0x01 + 2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x31, 0x01}) + std::string(256 + 0x01, 't'));
-    EXPECT_STREQ(std::string(256 + 0x01, 't').c_str(), HessianUtils::readString(buffer).c_str());
-    EXPECT_EQ(0, buffer.length());
-  }
-}
+namespace {
 
-TEST(HessianUtilsTest, peekLong) {
-  // Insufficient data
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xf0'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekLong(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x38, '1'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekLong(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x59, '1'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekLong(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4c, '1'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekLong(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  // Incorrect type
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x40}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekLong(buffer, &size), EnvoyException,
-                              "hessian type is not long 64");
-  }
-
-  // Single octet longs
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xeb'}));
-    size_t size;
-    EXPECT_EQ(11, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xec'}));
-    size_t size;
-    EXPECT_EQ(12, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xed'}));
-    size_t size;
-    EXPECT_EQ(13, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xef'}));
-    size_t size;
-    EXPECT_EQ(15, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xe0'}));
-    size_t size;
-    EXPECT_EQ(0, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xd8'}));
-    size_t size;
-    EXPECT_EQ(-8, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  // Two octet longs
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xf8', 0x00}));
-    size_t size;
-    EXPECT_EQ(0, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xf0', 0x00}));
-    size_t size;
-    EXPECT_EQ(-2048, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xf7', 0x00}));
-    size_t size;
-    EXPECT_EQ(-256, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xfc', 0x00}));
-    size_t size;
-    EXPECT_EQ(1024, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xfc', '\xff'}));
-    size_t size;
-    EXPECT_EQ(1279, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xfd', 0x00}));
-    size_t size;
-    EXPECT_EQ(1280, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xfd', '\xff'}));
-    size_t size;
-    EXPECT_EQ(1535, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xff', '\xff'}));
-    size_t size;
-    EXPECT_EQ(2047, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  // Three octet longs
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x3c, 0x00, 0x00}));
-    size_t size;
-    EXPECT_EQ(0, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(3, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x38, 0x00, 0x00}));
-    size_t size;
-    EXPECT_EQ(-262144, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(3, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\x3f', '\xff', '\xff'}));
-    size_t size;
-    EXPECT_EQ(262143, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(3, size);
-  }
-
-  // four octet longs
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x59, 0x00, 0x00, 0x00, 0x00}));
-    size_t size;
-    EXPECT_EQ(0, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(5, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x01, 0x59, 0x00, 0x00, 0x01, 0x2c}));
-    size_t size;
-    EXPECT_EQ(300, HessianUtils::peekLong(buffer, &size, 1));
-    EXPECT_EQ(5, size);
-  }
-
-  // eight octet longs
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2c}));
-    size_t size;
-    EXPECT_EQ(300, HessianUtils::peekLong(buffer, &size));
-    EXPECT_EQ(9, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2c}));
-    EXPECT_EQ(300, HessianUtils::readLong(buffer));
-    EXPECT_EQ(0, buffer.length());
-  }
-}
+TEST(BufferReaderTest, BufferReaderTest) {
+  Envoy::Buffer::OwnedImpl buffer;
+  buffer.add("test");
 
-TEST(HessianUtilsTest, peekBool) {
-  // Incorrect type
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x01}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekBool(buffer, &size), EnvoyException,
-                              "hessian type is not bool 1");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'T'}));
-    size_t size;
-    EXPECT_TRUE(HessianUtils::peekBool(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'F'}));
-    size_t size;
-    EXPECT_FALSE(HessianUtils::peekBool(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'F'}));
-    EXPECT_FALSE(HessianUtils::readBool(buffer));
-    EXPECT_EQ(0, buffer.length());
-  }
-}
+  BufferReader reader_1(buffer);
 
-TEST(HessianUtilsTest, peekInt) {
-  // Insufficient data
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xc1'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekInt(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xd0'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekInt(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x49}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekInt(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  // Incorrect type
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x01}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekInt(buffer, &size), EnvoyException,
-                              "hessian type is not int 1");
-  }
-
-  // Single octet integers
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\x90'}));
-    size_t size;
-    EXPECT_EQ(0, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\x80'}));
-    size_t size;
-    EXPECT_EQ(-16, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xbf'}));
-    size_t size;
-    EXPECT_EQ(47, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  // Two octet integers
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xc8', 0x00}));
-    size_t size;
-    EXPECT_EQ(0, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xc0', 0x00}));
-    size_t size;
-    EXPECT_EQ(-2048, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xc7', 0x00}));
-    size_t size;
-    EXPECT_EQ(-256, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xcc', 0x00}));
-    size_t size;
-    EXPECT_EQ(1024, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xcc', '\xff'}));
-    size_t size;
-    EXPECT_EQ(1279, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xcf', '\xff'}));
-    size_t size;
-    EXPECT_EQ(2047, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  // Three octet integers
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xd4', 0x00, 0x00}));
-    size_t size;
-    EXPECT_EQ(0, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(3, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xd0', 0x00, 0x00}));
-    size_t size;
-    EXPECT_EQ(-262144, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(3, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({'\xd7', '\xff', '\xff'}));
-    size_t size;
-    EXPECT_EQ(262143, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(3, size);
-  }
-
-  // Four octet integers
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x49, 0x00, 0x00, 0x00, 0x00}));
-    size_t size;
-    EXPECT_EQ(0, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(5, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x49, 0x00, 0x00, 0x01, 0x2c}));
-    size_t size;
-    EXPECT_EQ(300, HessianUtils::peekInt(buffer, &size));
-    EXPECT_EQ(5, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x49, 0x00, 0x00, 0x01, 0x2c}));
-    EXPECT_EQ(300, HessianUtils::readInt(buffer));
-    EXPECT_EQ(0, buffer.length());
-  }
-}
+  EXPECT_EQ(0, reader_1.offset());
+  EXPECT_EQ(4, reader_1.length());
 
-TEST(HessianUtilsTest, peekDouble) {
-  // Insufficient data
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5d}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekDouble(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5e}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekDouble(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5f}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekDouble(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x44}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekDouble(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  // Incorrect type
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x01}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekDouble(buffer, &size), EnvoyException,
-                              "hessian type is not double 1");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5b}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(0.0, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5c}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(1.0, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5d, 0x00}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(0.0, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5d, '\x80'}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(-128.0, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5d, '\x7f'}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(127.0, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(2, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5e, 0x00, 0x00}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(0.0, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(3, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5e, '\x80', 0x00}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(-32768.0, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(3, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5e, '\x7f', '\xff'}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(32767.0, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(3, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5f, 0x00, 0x00, 0x00, 0x00}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(0.0, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(5, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x44, 0x40, 0x28, '\x80', 0x00, 0x00, 0x00, 0x00, 0x00}));
-    size_t size;
-    EXPECT_DOUBLE_EQ(12.25, HessianUtils::peekDouble(buffer, &size));
-    EXPECT_EQ(9, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x5f, 0x00, 0x00, 0x00, 0x00}));
-    EXPECT_DOUBLE_EQ(0.0, HessianUtils::readDouble(buffer));
-    EXPECT_EQ(0, buffer.length());
-  }
-}
+  std::string test_string(4, 0);
 
-TEST(HessianUtilsTest, peekNull) {
-  // Incorrect type
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x01}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekNull(buffer, &size), EnvoyException,
-                              "hessian type is not null 1");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4e}));
-    size_t size = 0;
-    HessianUtils::peekNull(buffer, &size);
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4e}));
-    HessianUtils::readNull(buffer);
-    EXPECT_EQ(0, buffer.length());
-  }
-}
+  reader_1.readNBytes(test_string.data(), 4);
+
+  EXPECT_EQ("test", test_string);
+  EXPECT_EQ(4, reader_1.offset());
 
-TEST(HessianUtilsTest, peekDate) {
-  // Insufficient data
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4a}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekDate(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4b}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekDate(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  // Incorrect type
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x01}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekDate(buffer, &size), EnvoyException,
-                              "hessian type is not date 1");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4b, 0x00, 0x00, 0x00, 0x00}));
-    size_t size;
-    auto t = HessianUtils::peekDate(buffer, &size);
-    EXPECT_EQ(5, size);
-    EXPECT_EQ(0, t.count());
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4b, 0x00, '\xe3', '\x83', '\x8f'}));
-    size_t size;
-    auto t = HessianUtils::peekDate(buffer, &size);
-    EXPECT_EQ(5, size);
-    EXPECT_EQ(894621060000, t.count());
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4a, 0x00, 0x00, 0x00, '\xd0', 0x4b, '\x92', '\x84', '\xb8'}));
-    size_t size = 0;
-    auto t = HessianUtils::peekDate(buffer, &size);
-    EXPECT_EQ(9, size);
-    // Time zone was UTC
-    EXPECT_EQ(894621091000, t.count());
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x4a, 0x00, 0x00, 0x00, '\xd0', 0x4b, '\x92', '\x84', '\xb8'}));
-    auto t = HessianUtils::readDate(buffer);
-    // Time zone was UTC
-    EXPECT_EQ(894621091000, t.count());
-    EXPECT_EQ(0, buffer.length());
-  }
+  BufferReader reader_2(buffer, 2);
+
+  EXPECT_EQ(2, reader_2.offset());
 }
 
-TEST(HessianUtilsTest, peekByte) {
-  // Insufficient data
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x23}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekByte(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x42}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekByte(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x42, 't', 'e'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekByte(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x41, 't'}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekByte(buffer, &size), EnvoyException,
-                              "buffer underflow");
-  }
-
-  // Incorrect type
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x01}));
-    size_t size;
-    EXPECT_THROW_WITH_MESSAGE(HessianUtils::peekByte(buffer, &size), EnvoyException,
-                              "hessian type is not byte 1");
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x20}));
-    size_t size = 0;
-    EXPECT_STREQ("", HessianUtils::peekByte(buffer, &size).c_str());
-    EXPECT_EQ(1, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x23, 0x01, 0x02, 0x03}));
-    size_t size = 0;
-    EXPECT_STREQ("\x1\x2\x3", HessianUtils::peekByte(buffer, &size).c_str());
-    EXPECT_EQ(4, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x42, 0x10, 0x00}) + std::string(0x10 * 256, 't'));
-    size_t size = 0;
-    EXPECT_STREQ(std::string(0x10 * 256, 't').c_str(),
-                 HessianUtils::peekByte(buffer, &size).c_str());
-    EXPECT_EQ(3 + 0x10 * 256, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x41, 0x04, 0x00}) + std::string(0x04 * 256, 't') +
-               std::string({0x23, 0x01, 0x02, 0x03}));
-    size_t size = 0;
-    std::string expect_string = std::string(0x04 * 256, 't') + "\x1\x2\x3";
-    EXPECT_STREQ(expect_string.c_str(), HessianUtils::peekByte(buffer, &size).c_str());
-    EXPECT_EQ(3 + 0x04 * 256 + 4, size);
-  }
-
-  {
-    Buffer::OwnedImpl buffer;
-    buffer.add(std::string({0x23, 0x01, 0x02, 0x03}));
-    EXPECT_STREQ("\x1\x2\x3", HessianUtils::readByte(buffer).c_str());
-    EXPECT_EQ(0, buffer.length());
-  }
+TEST(BufferWriterTest, BufferWriterTest) {
+  Envoy::Buffer::OwnedImpl buffer;
+  buffer.add("test");
+
+  BufferWriter writer_1(buffer);
+
+  std::string test_string("123456789");
+
+  writer_1.rawWrite(test_string);
+
+  writer_1.rawWrite(test_string.data(), 5);
+
+  EXPECT_EQ("test12345678912345", buffer.toString());
 }
 
-TEST(HessianUtilsTest, writeString) {
-  const size_t max = 65535;
-  const size_t segment_mark_length = 3;
-
-  {
-    const std::string append_content("b");
-    const size_t append_content_hessian_length = 1;
-    std::string message(max, 'a');
-    message.append(append_content);
-    size_t expect_serialized_size =
-        max + segment_mark_length + append_content_hessian_length + append_content.size();
-
-    Buffer::OwnedImpl buffer;
-    size_t size = HessianUtils::writeString(buffer, message);
-    EXPECT_EQ(size, expect_serialized_size);
-  }
-
-  {
-    const std::string append_content(33, 'b');
-    const size_t append_content_hessian_length = 2;
-    std::string message(max, 'a');
-    message.append(append_content);
-    size_t expect_serialized_size =
-        max + segment_mark_length + append_content_hessian_length + append_content.size();
-
-    Buffer::OwnedImpl buffer;
-    size_t size = HessianUtils::writeString(buffer, message);
-    EXPECT_EQ(size, expect_serialized_size);
-  }
-
-  {
-    const std::string append_content(1025, 'b');
-    const size_t append_content_hessian_length = 3;
-    std::string message(max, 'a');
-    message.append(append_content);
-    size_t expect_serialized_size =
-        max + segment_mark_length + append_content_hessian_length + append_content.size();
-
-    Buffer::OwnedImpl buffer;
-    size_t size = HessianUtils::writeString(buffer, message);
-    EXPECT_EQ(size, expect_serialized_size);
-  }
-
-  {
-    const std::string append_content(1025, 'b');
-    const size_t append_content_hessian_length = 3;
-    const size_t max_size = 2 * max;
-    std::string message(max_size, 'a');
-    message.append(append_content);
-    size_t expect_serialized_size =
-        max * 2 + segment_mark_length * 2 + append_content_hessian_length + append_content.size();
-
-    Buffer::OwnedImpl buffer;
-    size_t size = HessianUtils::writeString(buffer, message);
-    EXPECT_EQ(size, expect_serialized_size);
-  }
+TEST(HessianUtilsTest, GetParametersNumberTest) {
+  const std::string test_empty_types = "";
+
+  EXPECT_EQ(0, HessianUtils::getParametersNumber(test_empty_types));
+
+  // "[B" stands for binary type.
+  const std::string test_normal_types = "VZ[BBCDFIJS";
+
+  EXPECT_EQ(10, HessianUtils::getParametersNumber(test_normal_types));
+
+  const std::string test_with_arrays = "[V[Z[B[C[D[F[I[J[S";
+
+  EXPECT_EQ(9, HessianUtils::getParametersNumber(test_with_arrays));
+
+  const std::string test_with_object = "Ljava.lang.String;[BCDLjava.lang.Date;CDFIJ";
+
+  EXPECT_EQ(10, HessianUtils::getParametersNumber(test_with_object));
+
+  const std::string test_hybrid_types =
+      "CD[B[Ljava.lang.String;[Ljava.lang.Date;DLjava.lang.String;FIJ";
+
+  EXPECT_EQ(10, HessianUtils::getParametersNumber(test_hybrid_types));
+
+  const std::string test_error_types = "abcdefg";
+
+  EXPECT_EQ(0, HessianUtils::getParametersNumber(test_error_types));
 }
 
+} // namespace
+
 } // namespace DubboProxy
 } // namespace NetworkFilters
 } // namespace Extensions
 } // namespace Envoy
diff --git a/test/extensions/filters/network/dubbo_proxy/message_impl_test.cc b/test/extensions/filters/network/dubbo_proxy/message_impl_test.cc
new file mode 100644
index 0000000000..82767f6cb8
--- /dev/null
+++ b/test/extensions/filters/network/dubbo_proxy/message_impl_test.cc
@@ -0,0 +1,164 @@
+#include "extensions/filters/network/dubbo_proxy/message_impl.h"
+
+#include "test/test_common/printers.h"
+#include "test/test_common/utility.h"
+
+#include "gtest/gtest.h"
+#include "hessian2/object.hpp"
+
+namespace Envoy {
+namespace Extensions {
+namespace NetworkFilters {
+namespace DubboProxy {
+
+namespace {
+
+TEST(ContextImplTest, ContextImplTest) {
+  ContextImpl test;
+
+  test.setHeaderSize(13);
+  EXPECT_EQ(13, test.headerSize());
+
+  test.setBodySize(13);
+  EXPECT_EQ(13, test.bodySize());
+
+  test.setHeartbeat(true);
+  EXPECT_EQ(true, test.isHeartbeat());
+
+  EXPECT_EQ(26, test.messageSize());
+}
+
+TEST(RpcInvocationImplAttachmentTest, RpcInvocationImplAttachmentTest) {
+  auto map = std::make_unique<RpcInvocationImpl::Attachment::Map>();
+
+  map->toMutableUntypedMap()->emplace(std::make_unique<Hessian2::StringObject>("group"),
+                                      std::make_unique<Hessian2::StringObject>("fake_group"));
+  map->toMutableUntypedMap()->emplace(std::make_unique<Hessian2::StringObject>("fake_key"),
+                                      std::make_unique<Hessian2::StringObject>("fake_value"));
+
+  map->toMutableUntypedMap()->emplace(std::make_unique<Hessian2::NullObject>(),
+                                      std::make_unique<Hessian2::LongObject>(0));
+
+  map->toMutableUntypedMap()->emplace(std::make_unique<Hessian2::StringObject>("map_key"),
+                                      std::make_unique<Hessian2::UntypedMapObject>());
+
+  RpcInvocationImpl::Attachment attachment(std::move(map), 23333);
+
+  EXPECT_EQ(4, attachment.attachment().toUntypedMap().value()->size());
+  // Only string type key/value pairs will be inserted to header map.
+  EXPECT_EQ(2, attachment.headers().size());
+
+  // Test lookup.
+  EXPECT_EQ(nullptr, attachment.lookup("map_key"));
+  EXPECT_EQ("fake_group", *attachment.lookup("group"));
+
+  EXPECT_FALSE(attachment.attachmentUpdated());
+
+  // Test remove. Remove a normal string type key/value pair.
+  EXPECT_EQ("fake_value", *attachment.lookup("fake_key"));
+  attachment.remove("fake_key");
+  EXPECT_EQ(nullptr, attachment.lookup("fake_key"));
+
+  EXPECT_EQ(3, attachment.attachment().toUntypedMap().value()->size());
+  EXPECT_EQ(1, attachment.headers().size());
+
+  // Test remove. Delete a key/value pair whose value type is map.
+  attachment.remove("map_key");
+  EXPECT_EQ(2, attachment.attachment().toUntypedMap().value()->size());
+  EXPECT_EQ(1, attachment.headers().size());
+
+  // Test insert.
+  attachment.insert("test", "test_value");
+  EXPECT_EQ(3, attachment.attachment().toUntypedMap().value()->size());
+  EXPECT_EQ(2, attachment.headers().size());
+
+  EXPECT_EQ("test_value", *attachment.lookup("test"));
+
+  EXPECT_TRUE(attachment.attachmentUpdated());
+  EXPECT_EQ(23333, attachment.attachmentOffset());
+}
+
+TEST(RpcInvocationImplTest, RpcInvocationImplTest) {
+  RpcInvocationImpl invo;
+
+  invo.setServiceName("fake_service");
+  EXPECT_EQ("fake_service", invo.serviceName());
+
+  invo.setMethodName("fake_method");
+  EXPECT_EQ("fake_method", invo.methodName());
+
+  EXPECT_EQ(false, invo.serviceVersion().has_value());
+  invo.setServiceVersion("fake_version");
+  EXPECT_EQ("fake_version", invo.serviceVersion().value());
+
+  bool set_parameters{false};
+  bool set_attachment{false};
+
+  invo.setParametersLazyCallback([&set_parameters]() -> RpcInvocationImpl::ParametersPtr {
+    set_parameters = true;
+    return std::make_unique<RpcInvocationImpl::Parameters>();
+  });
+
+  invo.setAttachmentLazyCallback([&set_attachment]() -> RpcInvocationImpl::AttachmentPtr {
+    auto map = std::make_unique<RpcInvocationImpl::Attachment::Map>();
+
+    map->toMutableUntypedMap()->emplace(std::make_unique<Hessian2::StringObject>("group"),
+                                        std::make_unique<Hessian2::StringObject>("fake_group"));
+
+    auto attach = std::make_unique<RpcInvocationImpl::Attachment>(std::move(map), 0);
+
+    set_attachment = true;
+
+    return attach;
+  });
+
+  EXPECT_EQ(false, invo.hasParameters());
+  EXPECT_EQ(false, invo.hasAttachment());
+
+  // When parsing attachment, parameters will also be parsed.
+  EXPECT_NE(nullptr, invo.mutableAttachment());
+  invo.attachment();
+  EXPECT_EQ(true, set_parameters);
+  EXPECT_EQ(true, set_attachment);
+  EXPECT_EQ(true, invo.hasParameters());
+  EXPECT_EQ(true, invo.hasAttachment());
+  EXPECT_EQ("fake_group", invo.serviceGroup().value());
+
+  invo.setServiceGroup("new_fake_group");
+  EXPECT_EQ("new_fake_group", invo.serviceGroup().value());
+
+  // If parameters and attachment have values, the callback function will not be executed.
+  set_parameters = false;
+  set_attachment = false;
+  EXPECT_NE(nullptr, invo.mutableParameters());
+  EXPECT_NE(nullptr, invo.mutableAttachment());
+  EXPECT_EQ(false, set_parameters);
+  EXPECT_EQ(false, set_attachment);
+
+  // Reset attachment and parameters.
+  invo.mutableParameters() = nullptr;
+  invo.mutableAttachment() = nullptr;
+
+  // When parsing parameters, attachment will not be parsed.
+  invo.mutableParameters();
+  EXPECT_EQ(true, set_parameters);
+  EXPECT_EQ(false, set_attachment);
+  EXPECT_EQ(true, invo.hasParameters());
+  EXPECT_EQ(false, invo.hasAttachment());
+}
+
+TEST(RpcResultImplTest, RpcResultImplTest) {
+  RpcResultImpl result;
+
+  EXPECT_EQ(false, result.hasException());
+
+  result.setException(true);
+
+  EXPECT_EQ(true, result.hasException());
+}
+
+} // namespace
+} // namespace DubboProxy
+} // namespace NetworkFilters
+} // namespace Extensions
+} // namespace Envoy
diff --git a/test/extensions/filters/network/dubbo_proxy/metadata_test.cc b/test/extensions/filters/network/dubbo_proxy/metadata_test.cc
index 4ac1e14e63..c014b7ff56 100644
--- a/test/extensions/filters/network/dubbo_proxy/metadata_test.cc
+++ b/test/extensions/filters/network/dubbo_proxy/metadata_test.cc
@@ -1,6 +1,5 @@
 #include "extensions/filters/network/dubbo_proxy/message_impl.h"
 #include "extensions/filters/network/dubbo_proxy/metadata.h"
-#include "extensions/filters/network/dubbo_proxy/serializer_impl.h"
 
 #include "gtest/gtest.h"
 
@@ -9,56 +8,48 @@ namespace Extensions {
 namespace NetworkFilters {
 namespace DubboProxy {
 
-TEST(MessageMetadataTest, Fields) {
-  MessageMetadata metadata;
-  auto invo = std::make_shared<RpcInvocationImpl>();
+TEST(MessageMetadataTest, MessageMetadataTest) {
+  auto invocation_info = std::make_shared<RpcInvocationImpl>();
+  MessageMetadata meta;
 
-  EXPECT_FALSE(metadata.hasInvocationInfo());
-  metadata.setInvocationInfo(invo);
-  EXPECT_TRUE(metadata.hasInvocationInfo());
+  EXPECT_EQ(false, meta.hasInvocationInfo());
 
-  EXPECT_THROW(metadata.timeout().value(), absl::bad_optional_access);
-  metadata.setTimeout(3);
-  EXPECT_TRUE(metadata.timeout().has_value());
+  meta.setInvocationInfo(invocation_info);
 
-  invo->setMethodName("method");
-  EXPECT_EQ("method", invo->methodName());
+  EXPECT_EQ(true, meta.hasInvocationInfo());
+  EXPECT_EQ(invocation_info.get(), &meta.invocationInfo());
 
-  EXPECT_FALSE(invo->serviceVersion().has_value());
-  EXPECT_THROW(invo->serviceVersion().value(), absl::bad_optional_access);
-  invo->setServiceVersion("1.0.0");
-  EXPECT_TRUE(invo->serviceVersion().has_value());
-  EXPECT_EQ("1.0.0", invo->serviceVersion().value());
+  meta.setProtocolType(ProtocolType::Dubbo);
+  EXPECT_EQ(ProtocolType::Dubbo, meta.protocolType());
 
-  EXPECT_FALSE(invo->serviceGroup().has_value());
-  EXPECT_THROW(invo->serviceGroup().value(), absl::bad_optional_access);
-  invo->setServiceGroup("group");
-  EXPECT_TRUE(invo->serviceGroup().has_value());
-  EXPECT_EQ("group", invo->serviceGroup().value());
-}
+  meta.setProtocolVersion(27);
+  EXPECT_EQ(27, meta.protocolVersion());
 
-TEST(MessageMetadataTest, Headers) {
-  MessageMetadata metadata;
-  auto invo = std::make_shared<RpcInvocationImpl>();
+  meta.setMessageType(MessageType::Request);
+  EXPECT_EQ(MessageType::Request, meta.messageType());
 
-  EXPECT_FALSE(invo->hasHeaders());
-  invo->addHeader("k", "v");
-  EXPECT_EQ(invo->headers().size(), 1);
-}
+  meta.setRequestId(1234567);
+  EXPECT_EQ(1234567, meta.requestId());
+
+  EXPECT_EQ(false, meta.timeout().has_value());
+  meta.setTimeout(6000);
+  EXPECT_EQ(6000, meta.timeout().value());
+
+  meta.setTwoWayFlag(true);
+  EXPECT_EQ(true, meta.isTwoWay());
+
+  meta.setSerializationType(SerializationType::Hessian2);
+  EXPECT_EQ(SerializationType::Hessian2, meta.serializationType());
+
+  EXPECT_EQ(false, meta.hasResponseStatus());
 
-TEST(MessageMetadataTest, Parameters) {
-  MessageMetadata metadata;
-  auto invo = std::make_shared<RpcInvocationImpl>();
+  meta.setResponseStatus(ResponseStatus::ServerTimeout);
+  EXPECT_EQ(ResponseStatus::ServerTimeout, meta.responseStatus());
 
-  EXPECT_FALSE(invo->hasParameters());
-  invo->addParameterValue(0, "test");
-  EXPECT_TRUE(invo->hasParameters());
-  EXPECT_EQ(invo->parameters().size(), 1);
-  EXPECT_EQ(invo->getParameterValue(0), "test");
-  EXPECT_EQ(invo->getParameterValue(1), "");
+  EXPECT_EQ(true, meta.hasResponseStatus());
 }
 
 } // namespace DubboProxy
 } // namespace NetworkFilters
 } // namespace Extensions
 } // namespace Envoy
diff --git a/test/extensions/filters/network/dubbo_proxy/route_matcher_test.cc b/test/extensions/filters/network/dubbo_proxy/route_matcher_test.cc
index 93adeb624d..31a4ef785c 100644
--- a/test/extensions/filters/network/dubbo_proxy/route_matcher_test.cc
+++ b/test/extensions/filters/network/dubbo_proxy/route_matcher_test.cc
@@ -1,14 +1,14 @@
 #include "envoy/extensions/filters/network/dubbo_proxy/v3/dubbo_proxy.pb.h"
 #include "envoy/extensions/filters/network/dubbo_proxy/v3/dubbo_proxy.pb.validate.h"
 #include "envoy/extensions/filters/network/dubbo_proxy/v3/route.pb.h"
 #include "envoy/extensions/filters/network/dubbo_proxy/v3/route.pb.validate.h"
 
 #include "common/protobuf/protobuf.h"
 
+#include "extensions/filters/network/dubbo_proxy/message_impl.h"
 #include "extensions/filters/network/dubbo_proxy/router/route_matcher.h"
-#include "extensions/filters/network/dubbo_proxy/serializer_impl.h"
 
 #include "test/mocks/server/factory_context.h"
 
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
@@ -32,10 +32,21 @@ envoy::extensions::filters::network::dubbo_proxy::v3::DubboProxy
 parseDubboProxyFromV2Yaml(const std::string& yaml) {
   envoy::extensions::filters::network::dubbo_proxy::v3::DubboProxy config;
   TestUtility::loadFromYaml(yaml, config);
   TestUtility::validate(config);
   return config;
 }
 
+void setDefaultInvocationCallback(RpcInvocationImpl& invo) {
+  invo.setParametersLazyCallback([]() -> RpcInvocationImpl::ParametersPtr {
+    return std::make_unique<RpcInvocationImpl::Parameters>();
+  });
+
+  invo.setAttachmentLazyCallback([]() -> RpcInvocationImpl::AttachmentPtr {
+    auto map = std::make_unique<RpcInvocationImpl::Attachment::Map>();
+    return std::make_unique<RpcInvocationImpl::Attachment>(std::move(map), 0);
+  });
+}
+
 } // namespace
 
 TEST(DubboRouteMatcherTest, RouteByServiceNameWithWildcard) {
@@ -209,33 +220,37 @@ group: test
 routes:
   - match:
       method:
         name:
           safe_regex:
             google_re2: {}
             regex: "(.*?)"
     route:
         cluster: user_service_dubbo_server
 )EOF";
 
     envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
         parseRouteConfigurationFromV2Yaml(yaml);
 
     NiceMock<Server::Configuration::MockFactoryContext> context;
     SingleRouteMatcherImpl matcher(config, context);
     auto invo = std::make_shared<RpcInvocationImpl>();
     MessageMetadata metadata;
     metadata.setInvocationInfo(invo);
     invo->setMethodName("test");
     invo->setServiceName("org.apache.dubbo.demo.DemoService");
+
+    setDefaultInvocationCallback(*invo);
+
     EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 
     invo->setServiceGroup("test");
     EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 
     invo->setServiceVersion("1.0.0");
+
     EXPECT_EQ("user_service_dubbo_server", matcher.route(metadata, 0)->routeEntry()->clusterName());
   }
 
   // Service name with version matches.
   {
     const std::string yaml = R"EOF(
@@ -286,33 +301,36 @@ group: HSF
 routes:
   - match:
       method:
         name:
           safe_regex:
             google_re2: {}
             regex: "(.*?)"
     route:
         cluster: user_service_dubbo_server
 )EOF";
 
     envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
         parseRouteConfigurationFromV2Yaml(yaml);
 
     NiceMock<Server::Configuration::MockFactoryContext> context;
     SingleRouteMatcherImpl matcher(config, context);
     auto invo = std::make_shared<RpcInvocationImpl>();
     MessageMetadata metadata;
     metadata.setInvocationInfo(invo);
     invo->setMethodName("test");
     invo->setServiceName("org.apache.dubbo.demo.DemoService");
+
+    setDefaultInvocationCallback(*invo);
+
     EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 
     invo->setServiceGroup("test");
     EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 
     invo->setServiceVersion("1.0.0");
     EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 
     invo->setServiceGroup("HSF");
     EXPECT_EQ("user_service_dubbo_server", matcher.route(metadata, 0)->routeEntry()->clusterName());
   }
 }
@@ -449,6 +467,107 @@ routes:
   EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 }
 
+TEST(DubboRouteMatcherTest, RouteByParamterWithNoParameter) {
+  const std::string yaml = R"EOF(
+name: local_route
+interface: org.apache.dubbo.demo.DemoService
+routes:
+  - match:
+      method:
+        name:
+          exact: "add"
+        params_match:
+          0:
+            range_match:
+              start: 100
+              end: 200
+    route:
+        cluster: user_service_dubbo_server
+)EOF";
+
+  envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
+      parseRouteConfigurationFromV2Yaml(yaml);
+  auto invo = std::make_shared<RpcInvocationImpl>();
+  MessageMetadata metadata;
+  metadata.setInvocationInfo(invo);
+  invo->setServiceName("org.apache.dubbo.demo.DemoService");
+  invo->setMethodName("add");
+
+  setDefaultInvocationCallback(*invo);
+
+  NiceMock<Server::Configuration::MockFactoryContext> context;
+  SingleRouteMatcherImpl matcher(config, context);
+  EXPECT_EQ(nullptr, matcher.route(metadata, 0));
+}
+
+TEST(DubboRouteMatcherTest, RouteByParamterWithErrorIndex) {
+  const std::string yaml = R"EOF(
+name: local_route
+interface: org.apache.dubbo.demo.DemoService
+routes:
+  - match:
+      method:
+        name:
+          exact: "add"
+        params_match:
+          3:
+            range_match:
+              start: 100
+              end: 200
+    route:
+        cluster: user_service_dubbo_server
+)EOF";
+
+  envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
+      parseRouteConfigurationFromV2Yaml(yaml);
+  auto invo = std::make_shared<RpcInvocationImpl>();
+  MessageMetadata metadata;
+  metadata.setInvocationInfo(invo);
+  invo->setServiceName("org.apache.dubbo.demo.DemoService");
+  invo->setMethodName("add");
+
+  setDefaultInvocationCallback(*invo);
+  invo->mutableParameters()->push_back(std::make_unique<Hessian2::StringObject>("150"));
+
+  NiceMock<Server::Configuration::MockFactoryContext> context;
+  SingleRouteMatcherImpl matcher(config, context);
+  EXPECT_EQ(nullptr, matcher.route(metadata, 0));
+}
+
+TEST(DubboRouteMatcherTest, RouteByParameterWithErrorType) {
+  const std::string yaml = R"EOF(
+name: local_route
+interface: org.apache.dubbo.demo.DemoService
+routes:
+  - match:
+      method:
+        name:
+          exact: "add"
+        params_match:
+          0:
+            range_match:
+              start: 100
+              end: 200
+    route:
+        cluster: user_service_dubbo_server
+)EOF";
+
+  envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
+      parseRouteConfigurationFromV2Yaml(yaml);
+  auto invo = std::make_shared<RpcInvocationImpl>();
+  MessageMetadata metadata;
+  metadata.setInvocationInfo(invo);
+  invo->setServiceName("org.apache.dubbo.demo.DemoService");
+  invo->setMethodName("add");
+
+  setDefaultInvocationCallback(*invo);
+  invo->mutableParameters()->push_back(std::make_unique<Hessian2::NullObject>());
+
+  NiceMock<Server::Configuration::MockFactoryContext> context;
+  SingleRouteMatcherImpl matcher(config, context);
+  EXPECT_EQ(nullptr, matcher.route(metadata, 0));
+}
+
 TEST(DubboRouteMatcherTest, RouteByParameterWithRangeMatch) {
   const std::string yaml = R"EOF(
 name: local_route
@@ -456,31 +575,67 @@ interface: org.apache.dubbo.demo.DemoService
 routes:
   - match:
       method:
         name:
           exact: "add"
         params_match:
           0:
             range_match:
               start: 100
               end: 200
     route:
         cluster: user_service_dubbo_server
 )EOF";
 
   envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
       parseRouteConfigurationFromV2Yaml(yaml);
   auto invo = std::make_shared<RpcInvocationImpl>();
   MessageMetadata metadata;
   metadata.setInvocationInfo(invo);
   invo->setServiceName("org.apache.dubbo.demo.DemoService");
   invo->setMethodName("add");
-  invo->addParameterValue(0, "150");
+
+  setDefaultInvocationCallback(*invo);
+  invo->mutableParameters()->push_back(std::make_unique<Hessian2::StringObject>("150"));
 
   NiceMock<Server::Configuration::MockFactoryContext> context;
   SingleRouteMatcherImpl matcher(config, context);
   EXPECT_EQ("user_service_dubbo_server", matcher.route(metadata, 0)->routeEntry()->clusterName());
 }
 
+TEST(DubboRouteMatcherTest, RouteByParameterWithRangeMatchButNotMatch) {
+  const std::string yaml = R"EOF(
+name: local_route
+interface: org.apache.dubbo.demo.DemoService
+routes:
+  - match:
+      method:
+        name:
+          exact: "add"
+        params_match:
+          0:
+            range_match:
+              start: 100
+              end: 200
+    route:
+        cluster: user_service_dubbo_server
+)EOF";
+
+  envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
+      parseRouteConfigurationFromV2Yaml(yaml);
+  auto invo = std::make_shared<RpcInvocationImpl>();
+  MessageMetadata metadata;
+  metadata.setInvocationInfo(invo);
+  invo->setServiceName("org.apache.dubbo.demo.DemoService");
+  invo->setMethodName("add");
+
+  setDefaultInvocationCallback(*invo);
+  invo->mutableParameters()->push_back(std::make_unique<Hessian2::StringObject>("300"));
+
+  NiceMock<Server::Configuration::MockFactoryContext> context;
+  SingleRouteMatcherImpl matcher(config, context);
+  EXPECT_EQ(nullptr, matcher.route(metadata, 0));
+}
+
 TEST(DubboRouteMatcherTest, RouteByParameterWithExactMatch) {
   const std::string yaml = R"EOF(
 name: local_route
@@ -488,25 +643,28 @@ interface: org.apache.dubbo.demo.DemoService
 routes:
   - match:
       method:
         name:
           exact: "add"
         params_match:
           1:
             exact_match: "user_id:94562"
     route:
         cluster: user_service_dubbo_server
 )EOF";
 
   envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
       parseRouteConfigurationFromV2Yaml(yaml);
   auto invo = std::make_shared<RpcInvocationImpl>();
   MessageMetadata metadata;
   metadata.setInvocationInfo(invo);
   invo->setServiceName("org.apache.dubbo.demo.DemoService");
   invo->setMethodName("add");
-  invo->addParameterValue(1, "user_id:94562");
+
+  setDefaultInvocationCallback(*invo);
+  invo->mutableParameters()->resize(2);
+  invo->mutableParameters()->back() = std::make_unique<Hessian2::StringObject>("user_id:94562");
 
   NiceMock<Server::Configuration::MockFactoryContext> context;
   SingleRouteMatcherImpl matcher(config, context);
   EXPECT_EQ("user_service_dubbo_server", matcher.route(metadata, 0)->routeEntry()->clusterName());
 }
@@ -518,40 +676,40 @@ interface: org.apache.dubbo.demo.DemoService
 routes:
   - match:
       method:
         name:
           exact: "add"
       headers:
       - name: custom
         exact_match: "123"
       - name: custom1
         exact_match: "123"
         invert_match: true
     route:
         cluster: user_service_dubbo_server
 )EOF";
 
   envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
       parseRouteConfigurationFromV2Yaml(yaml);
   auto invo = std::make_shared<RpcInvocationImpl>();
   MessageMetadata metadata;
   metadata.setInvocationInfo(invo);
   invo->setServiceName("org.apache.dubbo.demo.DemoService");
   invo->setMethodName("add");
-  invo->addHeader("custom", "123");
-  std::string test_value("123");
 
-  Envoy::Http::LowerCaseString test_key("custom1");
-  invo->addHeaderReference(test_key, test_value);
+  setDefaultInvocationCallback(*invo);
+
+  invo->mutableAttachment()->insert("custom", "123");
+  invo->mutableAttachment()->insert("custom1", "123");
 
   NiceMock<Server::Configuration::MockFactoryContext> context;
   SingleRouteMatcherImpl matcher(config, context);
   EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 
-  test_value = "456";
+  invo->mutableAttachment()->insert("custom1", "456");
   EXPECT_EQ("user_service_dubbo_server", matcher.route(metadata, 0)->routeEntry()->clusterName());
   EXPECT_EQ(nullptr, matcher.route(metadata, 0)->routeEntry()->metadataMatchCriteria());
 
-  test_value = "123";
+  invo->mutableAttachment()->insert("custom1", "123");
   EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 }
 
@@ -563,43 +721,46 @@ serialization_type: Hessian2
 route_config:
   - name: test1
     interface: org.apache.dubbo.demo.DemoService
     routes:
       - match:
           method:
             name:
               exact: "add"
             params_match:
               1:
                 exact_match: "user_id"
         route:
             cluster: user_service_dubbo_server
   - name: test2
     interface: org.apache.dubbo.demo.FormatService
     routes:
       - match:
           method:
             name:
               exact: "format"
         route:
             cluster: format_service
 )EOF";
 
   envoy::extensions::filters::network::dubbo_proxy::v3::DubboProxy config =
       parseDubboProxyFromV2Yaml(yaml);
   auto invo = std::make_shared<RpcInvocationImpl>();
   MessageMetadata metadata;
   metadata.setInvocationInfo(invo);
   invo->setServiceName("org.apache.dubbo.demo.DemoService");
   invo->setMethodName("add");
-  invo->addParameterValue(1, "user_id");
+
+  setDefaultInvocationCallback(*invo);
+  invo->mutableParameters()->resize(2);
+  invo->mutableParameters()->back() = std::make_unique<Hessian2::StringObject>("user_id");
 
   NiceMock<Server::Configuration::MockFactoryContext> context;
   MultiRouteMatcher matcher(config.route_config(), context);
   EXPECT_EQ("user_service_dubbo_server", matcher.route(metadata, 0)->routeEntry()->clusterName());
 
   {
     envoy::extensions::filters::network::dubbo_proxy::v3::DubboProxy invalid_config;
     MultiRouteMatcher matcher(invalid_config.route_config(), context);
     EXPECT_EQ(nullptr, matcher.route(metadata, 0));
   }
 }
@@ -611,39 +772,49 @@ interface: org.apache.dubbo.demo.DemoService
 routes:
   - match:
       method:
         name:
           exact: "add"
         params_match:
           1:
             exact_match: "user_id:94562"
     route:
         cluster: user_service_dubbo_server
 )EOF";
 
   envoy::extensions::filters::network::dubbo_proxy::v3::RouteConfiguration config =
       parseRouteConfigurationFromV2Yaml(yaml);
   auto invo = std::make_shared<RpcInvocationImpl>();
   MessageMetadata metadata;
   metadata.setInvocationInfo(invo);
   invo->setServiceName("org.apache.dubbo.demo.DemoService");
   invo->setMethodName("add");
 
+  setDefaultInvocationCallback(*invo);
+
   // There is no parameter information in metadata.
   NiceMock<Server::Configuration::MockFactoryContext> context;
   SingleRouteMatcherImpl matcher(config, context);
   EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 
   // The parameter is empty.
-  invo->addParameterValue(1, "");
+  invo->mutableParameters()->resize(2);
+  invo->mutableParameters()->back() = std::make_unique<Hessian2::StringObject>("");
+
   EXPECT_EQ(nullptr, matcher.route(metadata, 0));
 
   {
     auto invo = std::make_shared<RpcInvocationImpl>();
+
+    setDefaultInvocationCallback(*invo);
+
+    // Error parameter.
+    invo->mutableParameters()->resize(2);
+    invo->mutableParameters()->back() = std::make_unique<Hessian2::StringObject>("user_id:562");
+
     MessageMetadata metadata;
     metadata.setInvocationInfo(invo);
     invo->setServiceName("org.apache.dubbo.demo.DemoService");
     invo->setMethodName("add");
-    invo->addParameterValue(1, "user_id:562");
     EXPECT_EQ(nullptr, matcher.route(metadata, 0));
   }
 }
diff --git a/test/extensions/filters/network/dubbo_proxy/router_test.cc b/test/extensions/filters/network/dubbo_proxy/router_test.cc
index 7b580f9f60..e8945775b3 100644
--- a/test/extensions/filters/network/dubbo_proxy/router_test.cc
+++ b/test/extensions/filters/network/dubbo_proxy/router_test.cc
@@ -1,16 +1,16 @@
 #include <memory>
 
 #include "extensions/filters/network/dubbo_proxy/app_exception.h"
 #include "extensions/filters/network/dubbo_proxy/dubbo_hessian2_serializer_impl.h"
 #include "extensions/filters/network/dubbo_proxy/message_impl.h"
 #include "extensions/filters/network/dubbo_proxy/protocol.h"
 #include "extensions/filters/network/dubbo_proxy/router/router_impl.h"
-#include "extensions/filters/network/dubbo_proxy/serializer_impl.h"
 
 #include "test/extensions/filters/network/dubbo_proxy/mocks.h"
+#include "test/extensions/filters/network/dubbo_proxy/utility.h"
 #include "test/mocks/network/mocks.h"
 #include "test/mocks/server/factory_context.h"
 #include "test/test_common/printers.h"
 #include "test/test_common/registry.h"
 
 #include "gtest/gtest.h"
@@ -48,193 +48,211 @@ class TestNamedProtocolConfigFactory : public NamedProtocolConfigFactory {
 public:
   TestNamedProtocolConfigFactory(std::function<MockProtocol*()> f) : f_(f) {}
 
   ProtocolPtr createProtocol(SerializationType serialization_type) override {
     auto protocol = ProtocolPtr{f_()};
     protocol->initSerializer(serialization_type);
     return protocol;
   }
   std::string name() const override { return ProtocolNames::get().fromType(ProtocolType::Dubbo); }
 
   std::function<MockProtocol*()> f_;
 };
 
+void writeRequest(Buffer::Instance& buffer) {
+  buffer.add(std::string({'\xda', '\xbb', 0x42, 20})); // Header
+  addInt64(buffer, 1);
+  addInt32(buffer, 5);
+
+  buffer.add(std::string({
+      0x04,
+      't',
+      'e',
+      's',
+      't',
+  })); // Body
+}
+
 } // namespace
 
 class DubboRouterTestBase {
 public:
   DubboRouterTestBase()
       : serializer_factory_([&]() -> MockSerializer* {
           ASSERT(serializer_ == nullptr);
           serializer_ = new NiceMock<MockSerializer>();
           if (mock_serializer_cb_) {
             mock_serializer_cb_(serializer_);
           }
           return serializer_;
         }),
         protocol_factory_([&]() -> MockProtocol* {
           ASSERT(protocol_ == nullptr);
           protocol_ = new NiceMock<MockProtocol>();
           if (mock_protocol_cb_) {
             mock_protocol_cb_(protocol_);
           }
           return protocol_;
         }),
         serializer_register_(serializer_factory_), protocol_register_(protocol_factory_) {
     context_.cluster_manager_.initializeThreadLocalClusters({"cluster"});
   }
 
   void initializeRouter() {
     route_ = new NiceMock<MockRoute>();
     route_ptr_.reset(route_);
 
     router_ = std::make_unique<Router>(context_.clusterManager());
 
     EXPECT_EQ(nullptr, router_->downstreamConnection());
 
     router_->setDecoderFilterCallbacks(callbacks_);
   }
 
   void initializeMetadata(MessageType msg_type) {
+    if (metadata_ != nullptr) {
+      return;
+    }
+
     msg_type_ = msg_type;
 
     metadata_ = std::make_shared<MessageMetadata>();
     metadata_->setMessageType(msg_type_);
     metadata_->setRequestId(1);
 
     auto invo = std::make_shared<RpcInvocationImpl>();
     metadata_->setInvocationInfo(invo);
     invo->setMethodName("test");
 
     message_context_ = std::make_shared<ContextImpl>();
   }
 
   void startRequest(MessageType msg_type) {
     initializeMetadata(msg_type);
 
     EXPECT_CALL(callbacks_, route()).WillOnce(Return(route_ptr_));
     EXPECT_CALL(*route_, routeEntry()).WillOnce(Return(&route_entry_));
     EXPECT_CALL(route_entry_, clusterName()).WillRepeatedly(ReturnRef(cluster_name_));
 
     EXPECT_CALL(callbacks_, serializationType()).WillOnce(Return(SerializationType::Hessian2));
     EXPECT_CALL(callbacks_, protocolType()).WillOnce(Return(ProtocolType::Dubbo));
 
     EXPECT_EQ(FilterStatus::StopIteration, router_->onMessageDecoded(metadata_, message_context_));
 
     EXPECT_CALL(callbacks_, connection()).WillRepeatedly(Return(&connection_));
     EXPECT_EQ(&connection_, router_->downstreamConnection());
 
     // Not yet implemented:
     EXPECT_EQ(absl::optional<uint64_t>(), router_->computeHashKey());
     EXPECT_EQ(nullptr, router_->metadataMatchCriteria());
     EXPECT_EQ(nullptr, router_->downstreamHeaders());
   }
 
   void connectUpstream() {
     EXPECT_CALL(*context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_.connection_data_,
                 addUpstreamCallbacks(_))
         .WillOnce(Invoke([&](Tcp::ConnectionPool::UpstreamCallbacks& cb) -> void {
           upstream_callbacks_ = &cb;
         }));
 
     conn_state_.reset();
     EXPECT_CALL(*context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_.connection_data_,
                 connectionState())
         .WillRepeatedly(
             Invoke([&]() -> Tcp::ConnectionPool::ConnectionState* { return conn_state_.get(); }));
 
     EXPECT_CALL(callbacks_, continueDecoding());
     context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_.poolReady(upstream_connection_);
 
     EXPECT_NE(nullptr, upstream_callbacks_);
   }
 
   void startRequestWithExistingConnection(MessageType msg_type) {
     EXPECT_CALL(callbacks_, route()).WillOnce(Return(route_ptr_));
     EXPECT_CALL(*route_, routeEntry()).WillOnce(Return(&route_entry_));
     EXPECT_CALL(route_entry_, clusterName()).WillRepeatedly(ReturnRef(cluster_name_));
 
     initializeMetadata(msg_type);
 
     EXPECT_CALL(*context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_.connection_data_,
                 addUpstreamCallbacks(_))
         .WillOnce(Invoke([&](Tcp::ConnectionPool::UpstreamCallbacks& cb) -> void {
           upstream_callbacks_ = &cb;
         }));
 
     EXPECT_CALL(callbacks_, connection()).WillRepeatedly(Return(&connection_));
     EXPECT_EQ(&connection_, router_->downstreamConnection());
 
     // Not yet implemented:
     EXPECT_EQ(absl::optional<uint64_t>(), router_->computeHashKey());
     EXPECT_EQ(nullptr, router_->metadataMatchCriteria());
     EXPECT_EQ(nullptr, router_->downstreamHeaders());
 
     EXPECT_CALL(callbacks_, serializationType()).WillOnce(Return(SerializationType::Hessian2));
     EXPECT_CALL(callbacks_, protocolType()).WillOnce(Return(ProtocolType::Dubbo));
 
     EXPECT_CALL(callbacks_, continueDecoding()).Times(0);
     EXPECT_CALL(context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_, newConnection(_))
         .WillOnce(
             Invoke([&](Tcp::ConnectionPool::Callbacks& cb) -> Tcp::ConnectionPool::Cancellable* {
               context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_.newConnectionImpl(cb);
               context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_.poolReady(
                   upstream_connection_);
               return nullptr;
             }));
   }
 
   void returnResponse() {
     Buffer::OwnedImpl buffer;
 
     EXPECT_CALL(callbacks_, startUpstreamResponse());
 
     EXPECT_CALL(callbacks_, upstreamData(Ref(buffer)))
         .WillOnce(Return(DubboFilters::UpstreamResponseStatus::MoreData));
     upstream_callbacks_->onUpstreamData(buffer, false);
 
     // Nothing to do.
     upstream_callbacks_->onAboveWriteBufferHighWatermark();
     upstream_callbacks_->onBelowWriteBufferLowWatermark();
 
     EXPECT_CALL(callbacks_, upstreamData(Ref(buffer)))
         .WillOnce(Return(DubboFilters::UpstreamResponseStatus::Complete));
     EXPECT_CALL(context_.cluster_manager_.thread_local_cluster_.tcp_conn_pool_,
                 released(Ref(upstream_connection_)));
     upstream_callbacks_->onUpstreamData(buffer, false);
   }
 
   void destroyRouter() {
     router_->onDestroy();
     router_.reset();
   }
 
   TestNamedSerializerConfigFactory serializer_factory_;
   TestNamedProtocolConfigFactory protocol_factory_;
   Registry::InjectFactory<NamedSerializerConfigFactory> serializer_register_;
   Registry::InjectFactory<NamedProtocolConfigFactory> protocol_register_;
 
   std::function<void(MockSerializer*)> mock_serializer_cb_{};
   std::function<void(MockProtocol*)> mock_protocol_cb_{};
 
   NiceMock<Server::Configuration::MockFactoryContext> context_;
   NiceMock<Network::MockClientConnection> connection_;
   NiceMock<DubboFilters::MockDecoderFilterCallbacks> callbacks_;
   NiceMock<MockSerializer>* serializer_{};
   NiceMock<MockProtocol>* protocol_{};
   NiceMock<MockRoute>* route_{};
   NiceMock<MockRouteEntry> route_entry_;
   NiceMock<Upstream::MockHostDescription>* host_{};
   Tcp::ConnectionPool::ConnectionStatePtr conn_state_;
 
   RouteConstSharedPtr route_ptr_;
   std::unique_ptr<Router> router_;
 
   std::string cluster_name_{"cluster"};
 
   MessageType msg_type_{MessageType::Request};
   MessageMetadataSharedPtr metadata_;
   ContextSharedPtr message_context_;
 
   Tcp::ConnectionPool::UpstreamCallbacks* upstream_callbacks_{};
   NiceMock<Network::MockClientConnection> upstream_connection_;
 };
@@ -384,19 +402,49 @@ TEST_F(DubboRouterTest, NoCluster) {
 TEST_F(DubboRouterTest, UnexpectedRouterDestroy) {
   initializeRouter();
   initializeMetadata(MessageType::Request);
   EXPECT_CALL(upstream_connection_, close(Network::ConnectionCloseType::NoFlush));
 
   Buffer::OwnedImpl buffer;
   buffer.add(std::string({'\xda', '\xbb', 0x42, 20})); // Header
   buffer.add("test");                                  // Body
 
   auto ctx = static_cast<ContextImpl*>(message_context_.get());
-  ctx->messageOriginData().move(buffer, buffer.length());
+  ctx->originMessage().move(buffer, buffer.length());
   startRequest(MessageType::Request);
   connectUpstream();
   destroyRouter();
 }
 
+TEST_F(DubboRouterTest, UpstreamRemoteCloseNoRequest) {
+  initializeRouter();
+
+  startRequest(MessageType::Request);
+  connectUpstream();
+  returnResponse();
+
+  upstream_callbacks_->onEvent(Network::ConnectionEvent::RemoteClose);
+  destroyRouter();
+}
+
+TEST_F(DubboRouterTest, UpstreamLocalCloseAndRequestReset) {
+  initializeRouter();
+
+  startRequest(MessageType::Request);
+  connectUpstream();
+
+  Buffer::OwnedImpl buffer;
+
+  EXPECT_CALL(callbacks_, startUpstreamResponse());
+
+  EXPECT_CALL(callbacks_, upstreamData(Ref(buffer)))
+      .WillOnce(Return(DubboFilters::UpstreamResponseStatus::Reset));
+
+  upstream_callbacks_->onUpstreamData(buffer, false);
+
+  upstream_callbacks_->onEvent(Network::ConnectionEvent::LocalClose);
+  destroyRouter();
+}
+
 TEST_F(DubboRouterTest, UpstreamRemoteCloseMidResponse) {
   initializeRouter();
 
@@ -446,6 +494,55 @@ TEST_F(DubboRouterTest, Call) {
   destroyRouter();
 }
 
+// Test the attachment being updated.
+TEST_F(DubboRouterTest, AttachmentUpdated) {
+  initializeRouter();
+  initializeMetadata(MessageType::Request);
+
+  auto* invo = const_cast<RpcInvocationImpl*>(
+      dynamic_cast<const RpcInvocationImpl*>(&metadata_->invocationInfo()));
+
+  EXPECT_CALL(upstream_connection_, write(_, false));
+
+  writeRequest(message_context_->originMessage());
+  dynamic_cast<ContextImpl*>(message_context_.get())->setHeaderSize(16);
+
+  const size_t origin_message_size = message_context_->originMessage().length();
+
+  invo->setParametersLazyCallback([]() -> RpcInvocationImpl::ParametersPtr {
+    return std::make_unique<RpcInvocationImpl::Parameters>();
+  });
+
+  invo->setAttachmentLazyCallback([origin_message_size]() -> RpcInvocationImpl::AttachmentPtr {
+    auto map = std::make_unique<RpcInvocationImpl::Attachment::Map>();
+    return std::make_unique<RpcInvocationImpl::Attachment>(std::move(map), origin_message_size);
+  });
+
+  invo->mutableAttachment()->insert("fake_attach_key", "fake_attach_value");
+
+  startRequest(MessageType::Request);
+
+  auto& upstream_request_buffer = router_->upstreamRequestBufferForTest();
+
+  // Verify that the attachment is properly serialized.
+  Hessian2::Decoder decoder(
+      std::make_unique<BufferReader>(upstream_request_buffer, origin_message_size));
+  EXPECT_EQ("fake_attach_value",
+            *(decoder.decode<Hessian2::Object>()
+                  ->toUntypedMap()
+                  .value()
+                  ->at(std::make_unique<Hessian2::StringObject>("fake_attach_key"))
+                  ->toString()
+                  .value()));
+
+  // Check new body size value.
+  EXPECT_EQ(upstream_request_buffer.peekBEInt<int32_t>(12), upstream_request_buffer.length() - 16);
+
+  connectUpstream();
+  returnResponse();
+  destroyRouter();
+}
+
 TEST_F(DubboRouterTest, DecoderFilterCallbacks) {
   initializeRouter();
   initializeMetadata(MessageType::Request);
