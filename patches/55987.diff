commit 7c312980b08e436e4183e297a33dd515fe818a03
Author: Ali Mohammad Pur <mpfard@serenityos.org>
Date:   Tue Mar 21 03:53:24 2023 +0330

    Shell: Implement arithmetic expansions for POSIX mode
    
    This also adds a 'math' immediate function that can be used in Shell
    proper to do arithmetic stuff.

diff --git a/Userland/Shell/ImmediateFunctions.cpp b/Userland/Shell/ImmediateFunctions.cpp
index 6baf1c6247..f819f91483 100644
--- a/Userland/Shell/ImmediateFunctions.cpp
+++ b/Userland/Shell/ImmediateFunctions.cpp
@@ -1,12 +1,13 @@
 /*
  * Copyright (c) 2021, the SerenityOS developers.
  *
  * SPDX-License-Identifier: BSD-2-Clause
  */
 
 #include "Formatter.h"
 #include "Shell.h"
 #include <LibRegex/Regex.h>
+#include <math.h>
 
 namespace Shell {
 
@@ -612,6 +613,761 @@ ErrorOr<RefPtr<AST::Node>> Shell::immediate_length_of_variable(AST::ImmediateExp
         false);
 }
 
+namespace Arithmetic {
+struct BinaryOperationNode;
+struct UnaryOperationNode;
+struct TernaryOperationNode;
+struct ErrorNode;
+
+struct Node {
+    Variant<String, i64, NonnullOwnPtr<BinaryOperationNode>, NonnullOwnPtr<UnaryOperationNode>, NonnullOwnPtr<TernaryOperationNode>, NonnullOwnPtr<ErrorNode>> value;
+};
+
+struct ErrorNode {
+    String error;
+};
+
+enum class Operator {
+    Add,                  // +
+    Subtract,             // -
+    Multiply,             // *
+    Quotient,             // /
+    Remainder,            // %
+    Power,                // **
+    Equal,                // ==
+    GreaterThan,          // >
+    LessThan,             // <
+    NotEqual,             // !=
+    GreaterThanOrEqual,   // >=
+    LessThanOrEqual,      // <=
+    BitwiseAnd,           // &
+    BitwiseOr,            // |
+    BitwiseXor,           // ^
+    ShiftLeft,            // <<
+    ShiftRight,           // >>
+    ArithmeticAnd,        // &&
+    ArithmeticOr,         // ||
+    Comma,                // ,
+    Negate,               // !
+    BitwiseNegate,        // ~
+    TernaryQuestion,      // ?
+    TernaryColon,         // :
+    Assignment,           // =
+    PlusAssignment,       // +=
+    MinusAssignment,      // -=
+    MultiplyAssignment,   // *=
+    DivideAssignment,     // /=
+    ModuloAssignment,     // %=
+    AndAssignment,        // &=
+    OrAssignment,         // |=
+    XorAssignment,        // ^=
+    LeftShiftAssignment,  // <<=
+    RightShiftAssignment, // >>=
+
+    OpenParen,  // (
+    CloseParen, // )
+};
+
+static Operator assignment_operation_of(Operator op)
+{
+    switch (op) {
+    case Operator::PlusAssignment:
+        return Operator::Add;
+    case Operator::MinusAssignment:
+        return Operator::Subtract;
+    case Operator::MultiplyAssignment:
+        return Operator::Multiply;
+    case Operator::DivideAssignment:
+        return Operator::Quotient;
+    case Operator::ModuloAssignment:
+        return Operator::Remainder;
+    case Operator::AndAssignment:
+        return Operator::BitwiseAnd;
+    case Operator::OrAssignment:
+        return Operator::BitwiseOr;
+    case Operator::XorAssignment:
+        return Operator::BitwiseXor;
+    case Operator::LeftShiftAssignment:
+        return Operator::ShiftLeft;
+    case Operator::RightShiftAssignment:
+        return Operator::ShiftRight;
+    default:
+        VERIFY_NOT_REACHED();
+    }
+}
+
+static bool is_assignment_operator(Operator op)
+{
+    switch (op) {
+    case Operator::Assignment:
+    case Operator::PlusAssignment:
+    case Operator::MinusAssignment:
+    case Operator::MultiplyAssignment:
+    case Operator::DivideAssignment:
+    case Operator::ModuloAssignment:
+    case Operator::AndAssignment:
+    case Operator::OrAssignment:
+    case Operator::XorAssignment:
+    case Operator::LeftShiftAssignment:
+    case Operator::RightShiftAssignment:
+        return true;
+    default:
+        return false;
+    }
+}
+
+using Token = Variant<String, i64, Operator>;
+
+struct BinaryOperationNode {
+    BinaryOperationNode(Operator op, Node lhs, Node rhs)
+        : op(op)
+        , lhs(move(lhs))
+        , rhs(move(rhs))
+    {
+    }
+
+    Operator op;
+    Node lhs;
+    Node rhs;
+};
+
+struct UnaryOperationNode {
+    UnaryOperationNode(Operator op, Node rhs)
+        : op(op)
+        , rhs(move(rhs))
+    {
+    }
+
+    Operator op;
+    Node rhs;
+};
+
+struct TernaryOperationNode {
+    TernaryOperationNode(Node condition, Node true_value, Node false_value)
+        : condition(move(condition))
+        , true_value(move(true_value))
+        , false_value(move(false_value))
+    {
+    }
+
+    Node condition;
+    Node true_value;
+    Node false_value;
+};
+
+static ErrorOr<Node> parse_expression(Span<Token>);
+static ErrorOr<Node> parse_assignment_expression(Span<Token>&);
+static ErrorOr<Node> parse_comma_expression(Span<Token>&);
+static ErrorOr<Node> parse_ternary_expression(Span<Token>&);
+static ErrorOr<Node> parse_logical_or_expression(Span<Token>&);
+static ErrorOr<Node> parse_logical_and_expression(Span<Token>&);
+static ErrorOr<Node> parse_bitwise_or_expression(Span<Token>&);
+static ErrorOr<Node> parse_bitwise_xor_expression(Span<Token>&);
+static ErrorOr<Node> parse_bitwise_and_expression(Span<Token>&);
+static ErrorOr<Node> parse_equality_expression(Span<Token>&);
+static ErrorOr<Node> parse_comparison_expression(Span<Token>&);
+static ErrorOr<Node> parse_shift_expression(Span<Token>&);
+static ErrorOr<Node> parse_additive_expression(Span<Token>&);
+static ErrorOr<Node> parse_multiplicative_expression(Span<Token>&);
+static ErrorOr<Node> parse_exponential_expression(Span<Token>&);
+static ErrorOr<Node> parse_unary_expression(Span<Token>&);
+static ErrorOr<Node> parse_primary_expression(Span<Token>&);
+template<size_t N>
+static ErrorOr<Node> parse_binary_expression_using_operators(Span<Token>&, Array<Operator, N>, Function<ErrorOr<Node>(Span<Token>&)> const& parse_rhs);
+static ErrorOr<Node> parse_binary_expression_using_operator(Span<Token>& tokens, Operator op, Function<ErrorOr<Node>(Span<Token>&)> const& parse_rhs)
+{
+    return parse_binary_expression_using_operators(tokens, Array { op }, parse_rhs);
+}
+
+static bool next_token_is_operator(Span<Token>& tokens, Operator op)
+{
+    if (tokens.is_empty())
+        return false;
+    return tokens.first().has<Operator>() && tokens.first().get<Operator>() == op;
+}
+
+ErrorOr<Node> parse_expression(Span<Token> tokens)
+{
+    return parse_comma_expression(tokens);
+}
+
+ErrorOr<Node> parse_comma_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operator(tokens, Operator::Comma, &parse_assignment_expression);
+}
+
+ErrorOr<Node> parse_assignment_expression(Span<Token>& tokens)
+{
+    auto lhs = TRY(parse_ternary_expression(tokens));
+    if (tokens.is_empty())
+        return lhs;
+
+    auto is_assignment_operator = [](Operator op) {
+        return op == Operator::Assignment
+            || op == Operator::PlusAssignment
+            || op == Operator::MinusAssignment
+            || op == Operator::MultiplyAssignment
+            || op == Operator::DivideAssignment
+            || op == Operator::ModuloAssignment
+            || op == Operator::AndAssignment
+            || op == Operator::OrAssignment
+            || op == Operator::XorAssignment
+            || op == Operator::LeftShiftAssignment
+            || op == Operator::RightShiftAssignment;
+    };
+
+    auto& token = tokens.first();
+    if (auto op = token.get_pointer<Operator>(); op && is_assignment_operator(*op)) {
+        if (!lhs.value.has<String>()) {
+            return Node {
+                make<ErrorNode>(TRY("Left-hand side of assignment must be a variable"_string))
+            };
+        }
+
+        tokens = tokens.slice(1);
+        auto rhs = TRY(parse_assignment_expression(tokens));
+        return Node {
+            make<BinaryOperationNode>(*op, move(lhs), move(rhs))
+        };
+    }
+
+    return lhs;
+}
+
+ErrorOr<Node> parse_ternary_expression(Span<Token>& tokens)
+{
+    auto condition = TRY(parse_logical_or_expression(tokens));
+    if (!next_token_is_operator(tokens, Operator::TernaryQuestion))
+        return condition;
+
+    tokens = tokens.slice(1);
+
+    auto true_value = TRY(parse_comma_expression(tokens));
+
+    if (!next_token_is_operator(tokens, Operator::TernaryColon)) {
+        return Node {
+            make<ErrorNode>(TRY("Expected ':' after true value in ternary expression"_string))
+        };
+    }
+
+    tokens = tokens.slice(1);
+
+    auto false_value = TRY(parse_ternary_expression(tokens));
+
+    return Node {
+        make<TernaryOperationNode>(move(condition), move(true_value), move(false_value))
+    };
+}
+
+ErrorOr<Node> parse_logical_or_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operator(tokens, Operator::ArithmeticOr, &parse_logical_and_expression);
+}
+
+ErrorOr<Node> parse_logical_and_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operator(tokens, Operator::ArithmeticAnd, &parse_bitwise_or_expression);
+}
+
+ErrorOr<Node> parse_bitwise_or_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operator(tokens, Operator::BitwiseOr, &parse_bitwise_xor_expression);
+}
+
+ErrorOr<Node> parse_bitwise_xor_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operator(tokens, Operator::BitwiseXor, &parse_bitwise_and_expression);
+}
+
+ErrorOr<Node> parse_bitwise_and_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operator(tokens, Operator::BitwiseAnd, &parse_equality_expression);
+}
+
+ErrorOr<Node> parse_equality_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operators(tokens, Array { Operator::Equal, Operator::NotEqual }, &parse_comparison_expression);
+}
+
+ErrorOr<Node> parse_comparison_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operators(tokens, Array { Operator::LessThan, Operator::GreaterThan, Operator::LessThanOrEqual, Operator::GreaterThanOrEqual }, &parse_shift_expression);
+}
+
+ErrorOr<Node> parse_shift_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operators(tokens, Array { Operator::ShiftLeft, Operator::ShiftRight }, &parse_additive_expression);
+}
+
+ErrorOr<Node> parse_additive_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operators(tokens, Array { Operator::Add, Operator::Subtract }, &parse_multiplicative_expression);
+}
+
+ErrorOr<Node> parse_multiplicative_expression(Span<Token>& tokens)
+{
+    return parse_binary_expression_using_operators(tokens, Array { Operator::Multiply, Operator::Quotient, Operator::Remainder }, &parse_exponential_expression);
+}
+
+ErrorOr<Node> parse_exponential_expression(Span<Token>& tokens)
+{
+    auto lhs = TRY(parse_unary_expression(tokens));
+    if (!next_token_is_operator(tokens, Operator::Power))
+        return lhs;
+
+    tokens = tokens.slice(1);
+    auto rhs = TRY(parse_exponential_expression(tokens));
+
+    return Node {
+        make<BinaryOperationNode>(Operator::Power, move(lhs), move(rhs))
+    };
+}
+
+ErrorOr<Node> parse_unary_expression(Span<Token>& tokens)
+{
+    if (tokens.is_empty()) {
+        return Node {
+            make<ErrorNode>(TRY("Expected expression, got end of input"_string))
+        };
+    }
+
+    auto& token = tokens.first();
+    if (auto op = token.get_pointer<Operator>()) {
+        if (*op == Operator::Add || *op == Operator::Subtract || *op == Operator::Negate || *op == Operator::BitwiseNegate) {
+            tokens = tokens.slice(1);
+            auto rhs = TRY(parse_unary_expression(tokens));
+            return Node {
+                make<UnaryOperationNode>(*op, move(rhs))
+            };
+        }
+    }
+
+    return parse_primary_expression(tokens);
+}
+
+ErrorOr<Node> parse_primary_expression(Span<Token>& tokens)
+{
+    if (tokens.is_empty())
+        return Node { make<ErrorNode>(TRY("Expected expression, got end of input"_string)) };
+
+    auto& token = tokens.first();
+    return token.visit(
+        [&](String const& var) -> ErrorOr<Node> {
+            tokens = tokens.slice(1);
+            return Node { var };
+        },
+        [&](i64 value) -> ErrorOr<Node> {
+            tokens = tokens.slice(1);
+            return Node { value };
+        },
+        [&](Operator op) -> ErrorOr<Node> {
+            switch (op) {
+            case Operator::OpenParen: {
+                tokens = tokens.slice(1);
+                auto value = TRY(parse_expression(tokens));
+                if (!next_token_is_operator(tokens, Operator::CloseParen)) {
+                    return Node {
+                        make<ErrorNode>(TRY("Expected ')' after expression in parentheses"_string))
+                    };
+                }
+                tokens = tokens.slice(1);
+                return value;
+            }
+            default:
+                return Node {
+                    make<ErrorNode>(TRY("Expected expression, got operator"_string))
+                };
+            }
+        });
+}
+
+template<size_t N>
+ErrorOr<Node> parse_binary_expression_using_operators(Span<Token>& tokens, Array<Operator, N> operators, Function<ErrorOr<Node>(Span<Token>&)> const& parse_rhs)
+{
+    auto lhs = TRY(parse_rhs(tokens));
+    for (;;) {
+        Optional<Operator> op;
+        for (auto candidate : operators) {
+            if (next_token_is_operator(tokens, candidate)) {
+                op = candidate;
+                break;
+            }
+        }
+
+        if (!op.has_value())
+            return lhs;
+
+        tokens = tokens.slice(1);
+        auto rhs = TRY(parse_rhs(tokens));
+        lhs = Node {
+            make<BinaryOperationNode>(*op, move(lhs), move(rhs))
+        };
+    }
+}
+
+}
+
+ErrorOr<RefPtr<AST::Node>> Shell::immediate_math(AST::ImmediateExpression& invoking_node, Vector<NonnullRefPtr<AST::Node>> const& arguments)
+{
+    if (arguments.size() != 1) {
+        raise_error(ShellError::EvaluatedSyntaxError, "Expected exactly 1 argument to math", invoking_node.position());
+        return nullptr;
+    }
+
+    auto expression_parts = TRY(TRY(const_cast<AST::Node&>(*arguments.first()).run(*this))->resolve_as_list(*this));
+    auto expression = TRY(String::join(' ', expression_parts));
+
+    using Arithmetic::Operator;
+    using Arithmetic::Token;
+
+    Vector<Token> tokens;
+
+    auto view = expression.code_points();
+    Optional<size_t> integer_or_word_start_offset;
+    for (auto it = view.begin(); it != view.end(); ++it) {
+        auto code_point = *it;
+        if (is_ascii_alphanumeric(code_point) || code_point == U'_') {
+            if (!integer_or_word_start_offset.has_value())
+                integer_or_word_start_offset = view.byte_offset_of(it);
+            continue;
+        }
+
+        if (integer_or_word_start_offset.has_value()) {
+            auto integer_or_word = view.substring_view(
+                *integer_or_word_start_offset,
+                view.byte_offset_of(it) - *integer_or_word_start_offset);
+
+            if (all_of(integer_or_word, is_ascii_digit))
+                tokens.append(*integer_or_word.as_string().to_int());
+            else
+                tokens.append(TRY(expression.substring_from_byte_offset_with_shared_superstring(*integer_or_word_start_offset, integer_or_word.length())));
+
+            integer_or_word_start_offset.clear();
+        }
+
+        switch (code_point) {
+        case U'!':
+            if (it.peek(1) == U'=') {
+                ++it;
+                tokens.append(Operator::NotEqual);
+            } else {
+                tokens.append(Operator::Negate);
+            }
+            break;
+        case U'=':
+            if (it.peek(1) == U'=') {
+                ++it;
+                tokens.append(Operator::Equal);
+            } else {
+                tokens.append(Operator::Assignment);
+            }
+            break;
+        case U'~':
+            tokens.append(Operator::BitwiseNegate);
+            break;
+        case U'(':
+            tokens.append(Operator::OpenParen);
+            break;
+        case U')':
+            tokens.append(Operator::CloseParen);
+            break;
+        case U'&':
+            switch (it.peek(1).value_or(0)) {
+            case U'&':
+                ++it;
+                tokens.append(Operator::ArithmeticAnd);
+                break;
+            case U'=':
+                ++it;
+                tokens.append(Operator::AndAssignment);
+                break;
+            default:
+                tokens.append(Operator::BitwiseAnd);
+                break;
+            }
+            break;
+        case U'|':
+            switch (it.peek(1).value_or(0)) {
+            case U'|':
+                ++it;
+                tokens.append(Operator::ArithmeticOr);
+                break;
+            case U'=':
+                ++it;
+                tokens.append(Operator::OrAssignment);
+                break;
+            default:
+                tokens.append(Operator::BitwiseOr);
+                break;
+            }
+            break;
+        case U'^':
+            if (it.peek(1) == U'=') {
+                ++it;
+                tokens.append(Operator::XorAssignment);
+            } else {
+                tokens.append(Operator::BitwiseXor);
+            }
+            break;
+        case U',':
+            tokens.append(Operator::Comma);
+            break;
+        case U'?':
+            tokens.append(Operator::TernaryQuestion);
+            break;
+        case U':':
+            tokens.append(Operator::TernaryColon);
+            break;
+        case U'+':
+            switch (it.peek(1).value_or(0)) {
+            case U'=':
+                ++it;
+                tokens.append(Operator::PlusAssignment);
+                break;
+            default:
+                tokens.append(Operator::Add);
+                break;
+            }
+            break;
+        case U'-':
+            switch (it.peek(1).value_or(0)) {
+            case U'=':
+                ++it;
+                tokens.append(Operator::MinusAssignment);
+                break;
+            default:
+                tokens.append(Operator::Subtract);
+                break;
+            }
+            break;
+        case U'*':
+            switch (it.peek(1).value_or(0)) {
+            case U'=':
+                ++it;
+                tokens.append(Operator::MultiplyAssignment);
+                break;
+            case U'*':
+                ++it;
+                tokens.append(Operator::Power);
+                break;
+            default:
+                tokens.append(Operator::Multiply);
+                break;
+            }
+            break;
+        case U'/':
+            if (it.peek(1) == U'=') {
+                ++it;
+                tokens.append(Operator::DivideAssignment);
+            } else {
+                tokens.append(Operator::Quotient);
+            }
+            break;
+        case U'%':
+            if (it.peek(1) == U'=') {
+                ++it;
+                tokens.append(Operator::ModuloAssignment);
+            } else {
+                tokens.append(Operator::Remainder);
+            }
+            break;
+        case U'<':
+            switch (it.peek(1).value_or(0)) {
+            case U'<':
+                ++it;
+                if (it.peek(1) == U'=') {
+                    ++it;
+                    tokens.append(Operator::LeftShiftAssignment);
+                } else {
+                    tokens.append(Operator::ShiftLeft);
+                }
+                break;
+            case U'=':
+                ++it;
+                tokens.append(Operator::LessThanOrEqual);
+                break;
+            default:
+                tokens.append(Operator::LessThan);
+                break;
+            }
+            break;
+        case U'>':
+            switch (it.peek(1).value_or(0)) {
+            case U'>':
+                ++it;
+                if (it.peek(1) == U'=') {
+                    ++it;
+                    tokens.append(Operator::RightShiftAssignment);
+                } else {
+                    tokens.append(Operator::ShiftRight);
+                }
+                break;
+            case U'=':
+                ++it;
+                tokens.append(Operator::GreaterThanOrEqual);
+                break;
+            default:
+                tokens.append(Operator::GreaterThan);
+                break;
+            }
+            break;
+        case U' ':
+        case U'\t':
+        case U'\n':
+        case U'\r':
+            break;
+        default:
+            raise_error(ShellError::EvaluatedSyntaxError, DeprecatedString::formatted("Unexpected character '{:c}' in math expression", code_point), arguments.first()->position());
+            return nullptr;
+        }
+    }
+    if (integer_or_word_start_offset.has_value()) {
+        auto integer_or_word = view.substring_view(*integer_or_word_start_offset);
+
+        if (all_of(integer_or_word, is_ascii_digit))
+            tokens.append(*integer_or_word.as_string().to_int());
+        else
+            tokens.append(TRY(expression.substring_from_byte_offset_with_shared_superstring(*integer_or_word_start_offset, integer_or_word.length())));
+
+        integer_or_word_start_offset.clear();
+    }
+
+    auto ast = TRY(Arithmetic::parse_expression(tokens));
+
+    // Now interpret that.
+    Function<ErrorOr<i64>(Arithmetic::Node const&)> interpret = [&](Arithmetic::Node const& node) -> ErrorOr<i64> {
+        return node.value.visit(
+            [&](String const& name) -> ErrorOr<i64> {
+                size_t resolution_attempts_remaining = 100;
+                for (auto resolved_name = name; resolution_attempts_remaining > 0; --resolution_attempts_remaining) {
+                    auto value = TRY(lookup_local_variable(resolved_name.bytes_as_string_view()));
+                    if (!value)
+                        break;
+
+                    StringBuilder builder;
+                    builder.join(' ', TRY(const_cast<AST::Value&>(*value).resolve_as_list(const_cast<Shell&>(*this))));
+                    resolved_name = TRY(builder.to_string());
+
+                    auto integer = resolved_name.bytes_as_string_view().to_int<i64>();
+                    if (integer.has_value())
+                        return *integer;
+                }
+
+                if (resolution_attempts_remaining == 0)
+                    raise_error(ShellError::EvaluatedSyntaxError, DeprecatedString::formatted("Too many indirections when resolving variable '{}'", name), arguments.first()->position());
+
+                return 0;
+            },
+            [&](i64 value) -> ErrorOr<i64> {
+                return value;
+            },
+            [&](NonnullOwnPtr<Arithmetic::BinaryOperationNode> const& node) -> ErrorOr<i64> {
+                if (Arithmetic::is_assignment_operator(node->op)) {
+                    // lhs must be a variable name.
+                    auto name = node->lhs.value.get_pointer<String>();
+                    if (!name) {
+                        raise_error(ShellError::EvaluatedSyntaxError, "Invalid left-hand side of assignment", arguments.first()->position());
+                        return 0;
+                    }
+
+                    auto rhs = TRY(interpret(node->rhs));
+
+                    if (node->op != Arithmetic::Operator::Assignment) {
+                        // Evaluate the new value
+                        rhs = TRY(interpret(Arithmetic::Node {
+                            .value = make<Arithmetic::BinaryOperationNode>(
+                                Arithmetic::assignment_operation_of(node->op),
+                                Arithmetic::Node { *name },
+                                Arithmetic::Node { rhs }),
+                        }));
+                    }
+
+                    set_local_variable(name->to_deprecated_string(), make_ref_counted<AST::StringValue>(TRY(String::number(rhs))));
+                    return rhs;
+                }
+
+                auto lhs = TRY(interpret(node->lhs));
+                auto rhs = TRY(interpret(node->rhs));
+
+                using Arithmetic::Operator;
+                switch (node->op) {
+                case Operator::Add:
+                    return lhs + rhs;
+                case Operator::Subtract:
+                    return lhs - rhs;
+                case Operator::Multiply:
+                    return lhs * rhs;
+                case Operator::Quotient:
+                    return lhs / rhs;
+                case Operator::Remainder:
+                    return lhs % rhs;
+                case Operator::ShiftLeft:
+                    return lhs << rhs;
+                case Operator::ShiftRight:
+                    return lhs >> rhs;
+                case Operator::BitwiseAnd:
+                    return lhs & rhs;
+                case Operator::BitwiseOr:
+                    return lhs | rhs;
+                case Operator::BitwiseXor:
+                    return lhs ^ rhs;
+                case Operator::ArithmeticAnd:
+                    return lhs != 0 && rhs != 0;
+                case Operator::ArithmeticOr:
+                    return lhs != 0 || rhs != 0;
+                case Operator::LessThan:
+                    return lhs < rhs;
+                case Operator::LessThanOrEqual:
+                    return lhs <= rhs;
+                case Operator::GreaterThan:
+                    return lhs > rhs;
+                case Operator::GreaterThanOrEqual:
+                    return lhs >= rhs;
+                case Operator::Equal:
+                    return lhs == rhs;
+                case Operator::NotEqual:
+                    return lhs != rhs;
+                case Operator::Power:
+                    return trunc(pow(static_cast<double>(lhs), static_cast<double>(rhs)));
+                case Operator::Comma:
+                    return rhs;
+                default:
+                    VERIFY_NOT_REACHED();
+                }
+            },
+            [&](NonnullOwnPtr<Arithmetic::UnaryOperationNode> const& node) -> ErrorOr<i64> {
+                auto value = TRY(interpret(node->rhs));
+
+                switch (node->op) {
+                case Arithmetic::Operator::Negate:
+                    return value == 0;
+                case Arithmetic::Operator::BitwiseNegate:
+                    return ~value;
+                case Arithmetic::Operator::Add:
+                    return value;
+                case Arithmetic::Operator::Subtract:
+                    return -value;
+                default:
+                    VERIFY_NOT_REACHED();
+                }
+            },
+            [&](NonnullOwnPtr<Arithmetic::TernaryOperationNode> const& node) -> ErrorOr<i64> {
+                auto condition = TRY(interpret(node->condition));
+                if (condition != 0)
+                    return TRY(interpret(node->true_value));
+                return TRY(interpret(node->false_value));
+            },
+            [&](NonnullOwnPtr<Arithmetic::ErrorNode> const& node) -> ErrorOr<i64> {
+                raise_error(ShellError::EvaluatedSyntaxError, node->error.to_deprecated_string(), arguments.first()->position());
+                return 0;
+            });
+    };
+
+    auto result = TRY(interpret(ast));
+
+    return make_ref_counted<AST::StringLiteral>(arguments.first()->position(), TRY(String::number(result)), AST::StringLiteral::EnclosureType::None);
+}
+
 ErrorOr<RefPtr<AST::Node>> Shell::run_immediate_function(StringView str, AST::ImmediateExpression& invoking_node, Vector<NonnullRefPtr<AST::Node>> const& arguments)
 {
 #define __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(name) \
diff --git a/Userland/Shell/PosixLexer.h b/Userland/Shell/PosixLexer.h
index b21bc1fe09..8aa9364b45 100644
--- a/Userland/Shell/PosixLexer.h
+++ b/Userland/Shell/PosixLexer.h
@@ -179,7 +179,12 @@ struct ResolvedCommandExpansion {
     ExpansionRange range;
 };
 
-using ResolvedExpansion = Variant<ResolvedParameterExpansion, ResolvedCommandExpansion>;
+struct ResolvedArithmeticExpansion {
+    String source_expression;
+    ExpansionRange range;
+};
+
+using ResolvedExpansion = Variant<ResolvedParameterExpansion, ResolvedCommandExpansion, ResolvedArithmeticExpansion>;
 
 struct HeredocEntry {
     String key;
diff --git a/Userland/Shell/PosixParser.cpp b/Userland/Shell/PosixParser.cpp
index 4703174408..582b9c0516 100644
--- a/Userland/Shell/PosixParser.cpp
+++ b/Userland/Shell/PosixParser.cpp
@@ -104,27 +104,28 @@ namespace Shell::Posix {
 ErrorOr<void> Parser::fill_token_buffer(Optional<Reduction> starting_reduction)
 {
     for (;;) {
         auto token = TRY(next_expanded_token(starting_reduction));
         if (!token.has_value())
             break;
 #if SHELL_POSIX_PARSER_DEBUG
         DeprecatedString position = "(~)";
         if (token->position.has_value())
             position = DeprecatedString::formatted("{}:{}", token->position->start_offset, token->position->end_offset);
         DeprecatedString expansions = "";
         for (auto& exp : token->resolved_expansions)
             exp.visit(
                 [&](ResolvedParameterExpansion& x) { expansions = DeprecatedString::formatted("{}param({}),", expansions, x.to_deprecated_string()); },
-                [&](ResolvedCommandExpansion& x) { expansions = DeprecatedString::formatted("{}command({:p})", expansions, x.command.ptr()); });
+                [&](ResolvedCommandExpansion& x) { expansions = DeprecatedString::formatted("{}command({:p})", expansions, x.command.ptr()); },
+                [&](ResolvedArithmeticExpansion& x) { expansions = DeprecatedString::formatted("{}arith({})", expansions, x.source_expression); });
         DeprecatedString rexpansions = "";
         for (auto& exp : token->expansions)
             exp.visit(
                 [&](ParameterExpansion& x) { rexpansions = DeprecatedString::formatted("{}param({}) from {} to {},", rexpansions, x.parameter.string_view(), x.range.start, x.range.length); },
                 [&](auto&) { rexpansions = DeprecatedString::formatted("{}...,", rexpansions); });
         dbgln("Token @ {}: '{}' (type {}) - parsed expansions: {} - raw expansions: {}", position, token->value.replace("\n"sv, "\\n"sv, ReplaceMode::All), token->type_name(), expansions, rexpansions);
 #endif
     }
     m_token_index = 0;
 
     return {};
 }
@@ -177,448 +178,441 @@ ErrorOr<Optional<Token>> Parser::next_expanded_token(Optional<Reduction> startin
 Vector<Token> Parser::perform_expansions(Vector<Token> tokens)
 {
     if (tokens.is_empty())
         return {};
 
     Vector<Token> expanded_tokens;
     auto previous_token = Optional<Token>();
     auto previous_previous_token = Optional<Token>();
     auto tokens_taken_from_buffer = 0;
 
     expanded_tokens.ensure_capacity(tokens.size());
 
     auto swap_expansions = [&] {
         if (previous_previous_token.has_value())
             expanded_tokens.append(previous_previous_token.release_value());
 
         if (previous_token.has_value())
             expanded_tokens.append(previous_token.release_value());
 
         for (; tokens_taken_from_buffer > 0; tokens_taken_from_buffer--)
             m_token_buffer.append(expanded_tokens.take_first());
 
         swap(tokens, expanded_tokens);
         expanded_tokens.clear_with_capacity();
     };
 
     // (1) join all consecutive newlines (this works around a grammar ambiguity)
     auto previous_was_newline = !m_token_buffer.is_empty() && m_token_buffer.last().type == Token::Type::Newline;
     for (auto& token : tokens) {
         if (token.type == Token::Type::Newline) {
             if (previous_was_newline)
                 continue;
             previous_was_newline = true;
         } else {
             previous_was_newline = false;
         }
         expanded_tokens.append(move(token));
     }
 
     swap_expansions();
 
     // (2) Detect reserved words
     if (m_token_buffer.size() >= 1) {
         previous_token = m_token_buffer.take_last();
         tokens_taken_from_buffer++;
     }
     if (m_token_buffer.size() >= 1) {
         previous_previous_token = m_token_buffer.take_last();
         tokens_taken_from_buffer++;
     }
 
     auto check_reserved_word = [&](auto& token) {
         if (is_a_reserved_word_position(token, previous_token, previous_previous_token)) {
             if (token.value == "if"sv)
                 token.type = Token::Type::If;
             else if (token.value == "then"sv)
                 token.type = Token::Type::Then;
             else if (token.value == "else"sv)
                 token.type = Token::Type::Else;
             else if (token.value == "elif"sv)
                 token.type = Token::Type::Elif;
             else if (token.value == "fi"sv)
                 token.type = Token::Type::Fi;
             else if (token.value == "while"sv)
                 token.type = Token::Type::While;
             else if (token.value == "until"sv)
                 token.type = Token::Type::Until;
             else if (token.value == "do"sv)
                 token.type = Token::Type::Do;
             else if (token.value == "done"sv)
                 token.type = Token::Type::Done;
             else if (token.value == "case"sv)
                 token.type = Token::Type::Case;
             else if (token.value == "esac"sv)
                 token.type = Token::Type::Esac;
             else if (token.value == "for"sv)
                 token.type = Token::Type::For;
             else if (token.value == "in"sv)
                 token.type = Token::Type::In;
             else if (token.value == "!"sv)
                 token.type = Token::Type::Bang;
             else if (token.value == "{"sv)
                 token.type = Token::Type::OpenBrace;
             else if (token.value == "}"sv)
                 token.type = Token::Type::CloseBrace;
             else if (token.type == Token::Type::Token)
                 token.type = Token::Type::Word;
         } else if (token.type == Token::Type::Token) {
             token.type = Token::Type::Word;
         }
     };
 
     for (auto& token : tokens) {
         if (!previous_token.has_value()) {
             check_reserved_word(token);
             previous_token = token;
             continue;
         }
         if (!previous_previous_token.has_value()) {
             check_reserved_word(token);
             previous_previous_token = move(previous_token);
             previous_token = token;
             continue;
         }
 
         check_reserved_word(token);
         expanded_tokens.append(exchange(*previous_previous_token, exchange(*previous_token, move(token))));
     }
 
     swap_expansions();
 
     // (3) Detect io_number tokens
     previous_token = Optional<Token>();
     tokens_taken_from_buffer = 0;
     if (m_token_buffer.size() >= 1) {
         previous_token = m_token_buffer.take_last();
         tokens_taken_from_buffer++;
     }
 
     for (auto& token : tokens) {
         if (!previous_token.has_value()) {
             previous_token = token;
             continue;
         }
 
         if (is_io_operator(token) && previous_token->type == Token::Type::Word && all_of(previous_token->value.bytes_as_string_view(), is_ascii_digit)) {
             previous_token->type = Token::Type::IoNumber;
         }
 
         expanded_tokens.append(exchange(*previous_token, move(token)));
     }
 
     swap_expansions();
 
     // (4) Try to identify simple commands
     previous_token = Optional<Token>();
     tokens_taken_from_buffer = 0;
 
     if (m_token_buffer.size() >= 1) {
         previous_token = m_token_buffer.take_last();
         tokens_taken_from_buffer++;
     }
 
     for (auto& token : tokens) {
         if (!previous_token.has_value()) {
             token.could_be_start_of_a_simple_command = true;
             previous_token = token;
             continue;
         }
 
         token.could_be_start_of_a_simple_command = is_one_of(previous_token->type, Token::Type::OpenParen, Token::Type::CloseParen, Token::Type::Newline)
             || is_separator(*previous_token)
             || (!is_reserved(*previous_token) && is_reserved(token));
 
         expanded_tokens.append(exchange(*previous_token, move(token)));
     }
 
     swap_expansions();
 
     // (5) Detect assignment words
     for (auto& token : tokens) {
         if (token.could_be_start_of_a_simple_command)
             m_disallow_command_prefix = false;
 
         // Check if we're in a command prefix (could be an assignment)
         if (!m_disallow_command_prefix && token.type == Token::Type::Word && token.value.contains('=')) {
             // If the word before '=' is a valid name, this is an assignment
             auto equal_offset = *token.value.find_byte_offset('=');
             if (is_valid_name(token.value.bytes_as_string_view().substring_view(0, equal_offset)))
                 token.type = Token::Type::AssignmentWord;
             else
                 m_disallow_command_prefix = true;
         } else {
             m_disallow_command_prefix = true;
         }
 
         expanded_tokens.append(move(token));
     }
 
     swap_expansions();
 
     // (6) Parse expansions
     for (auto& token : tokens) {
         if (!is_one_of(token.type, Token::Type::Word, Token::Type::AssignmentWord)) {
             expanded_tokens.append(move(token));
             continue;
         }
 
         Vector<ResolvedExpansion> resolved_expansions;
         for (auto& expansion : token.expansions) {
             auto resolved = expansion.visit(
                 [&](ParameterExpansion const& expansion) -> ResolvedExpansion {
                     auto text = expansion.parameter.string_view();
                     // ${NUMBER}
                     if (all_of(text, is_ascii_digit)) {
                         return ResolvedParameterExpansion {
                             .parameter = expansion.parameter.to_string().release_value_but_fixme_should_propagate_errors(),
                             .argument = {},
                             .range = expansion.range,
                             .op = ResolvedParameterExpansion::Op::GetPositionalParameter,
                         };
                     }
 
                     if (text.length() == 1) {
                         ResolvedParameterExpansion::Op op;
                         switch (text[0]) {
                         case '!':
                             op = ResolvedParameterExpansion::Op::GetLastBackgroundPid;
                             break;
                         case '@':
                             op = ResolvedParameterExpansion::Op::GetPositionalParameterList;
                             break;
                         case '-':
                             op = ResolvedParameterExpansion::Op::GetCurrentOptionFlags;
                             break;
                         case '#':
                             op = ResolvedParameterExpansion::Op::GetPositionalParameterCount;
                             break;
                         case '?':
                             op = ResolvedParameterExpansion::Op::GetLastExitStatus;
                             break;
                         case '*':
                             op = ResolvedParameterExpansion::Op::GetPositionalParameterListAsString;
                             break;
                         case '$':
                             op = ResolvedParameterExpansion::Op::GetShellProcessId;
                             break;
                         default:
                             if (is_valid_name(text)) {
                                 op = ResolvedParameterExpansion::Op::GetVariable;
                             } else {
                                 error(token, "Unknown parameter expansion: {}", text);
                                 return ResolvedParameterExpansion {
                                     .parameter = expansion.parameter.to_string().release_value_but_fixme_should_propagate_errors(),
                                     .argument = {},
                                     .range = expansion.range,
                                     .op = ResolvedParameterExpansion::Op::StringLength,
                                 };
                             }
                         }
 
                         return ResolvedParameterExpansion {
                             .parameter = {},
                             .argument = {},
                             .range = expansion.range,
                             .op = op,
                         };
                     }
 
                     if (text.starts_with('#')) {
                         return ResolvedParameterExpansion {
                             .parameter = String::from_utf8(text.substring_view(1)).release_value_but_fixme_should_propagate_errors(),
                             .argument = {},
                             .range = expansion.range,
                             .op = ResolvedParameterExpansion::Op::StringLength,
                         };
                     }
 
                     GenericLexer lexer { text };
                     auto parameter = lexer.consume_while([first = true](char c) mutable {
                         if (first) {
                             first = false;
                             return is_ascii_alpha(c) || c == '_';
                         }
                         return is_ascii_alphanumeric(c) || c == '_';
                     });
 
                     StringView argument;
                     ResolvedParameterExpansion::Op op;
                     switch (lexer.peek()) {
                     case ':':
                         lexer.ignore();
                         switch (lexer.is_eof() ? 0 : lexer.consume()) {
                         case '-':
                             argument = lexer.consume_all();
                             op = ResolvedParameterExpansion::Op::UseDefaultValue;
                             break;
                         case '=':
                             argument = lexer.consume_all();
                             op = ResolvedParameterExpansion::Op::AssignDefaultValue;
                             break;
                         case '?':
                             argument = lexer.consume_all();
                             op = ResolvedParameterExpansion::Op::IndicateErrorIfEmpty;
                             break;
                         case '+':
                             argument = lexer.consume_all();
                             op = ResolvedParameterExpansion::Op::UseAlternativeValue;
                             break;
                         default:
                             error(token, "Unknown parameter expansion: {}", text);
                             return ResolvedParameterExpansion {
                                 .parameter = String::from_utf8(parameter).release_value_but_fixme_should_propagate_errors(),
                                 .argument = {},
                                 .range = expansion.range,
                                 .op = ResolvedParameterExpansion::Op::StringLength,
                             };
                         }
                         break;
                     case '-':
                         lexer.ignore();
                         argument = lexer.consume_all();
                         op = ResolvedParameterExpansion::Op::UseDefaultValueIfUnset;
                         break;
                     case '=':
                         lexer.ignore();
                         argument = lexer.consume_all();
                         op = ResolvedParameterExpansion::Op::AssignDefaultValueIfUnset;
                         break;
                     case '?':
                         lexer.ignore();
                         argument = lexer.consume_all();
                         op = ResolvedParameterExpansion::Op::IndicateErrorIfUnset;
                         break;
                     case '+':
                         lexer.ignore();
                         argument = lexer.consume_all();
                         op = ResolvedParameterExpansion::Op::UseAlternativeValueIfUnset;
                         break;
                     case '%':
                         if (lexer.consume_specific('%'))
                             op = ResolvedParameterExpansion::Op::RemoveLargestSuffixByPattern;
                         else
                             op = ResolvedParameterExpansion::Op::RemoveSmallestSuffixByPattern;
                         argument = lexer.consume_all();
                         break;
                     case '#':
                         if (lexer.consume_specific('#'))
                             op = ResolvedParameterExpansion::Op::RemoveLargestPrefixByPattern;
                         else
                             op = ResolvedParameterExpansion::Op::RemoveSmallestPrefixByPattern;
                         argument = lexer.consume_all();
                         break;
                     default:
                         if (is_valid_name(text)) {
                             op = ResolvedParameterExpansion::Op::GetVariable;
                         } else {
                             error(token, "Unknown parameter expansion: {}", text);
                             return ResolvedParameterExpansion {
                                 .parameter = String::from_utf8(parameter).release_value_but_fixme_should_propagate_errors(),
                                 .argument = {},
                                 .range = expansion.range,
                                 .op = ResolvedParameterExpansion::Op::StringLength,
                             };
                         }
                     }
                     VERIFY(lexer.is_eof());
 
                     return ResolvedParameterExpansion {
                         .parameter = String::from_utf8(parameter).release_value_but_fixme_should_propagate_errors(),
                         .argument = String::from_utf8(argument).release_value_but_fixme_should_propagate_errors(),
                         .range = expansion.range,
                         .op = op,
                         .expand = ResolvedParameterExpansion::Expand::Word,
                     };
                 },
                 [&](ArithmeticExpansion const& expansion) -> ResolvedExpansion {
-                    error(token, "Arithmetic expansion is not supported");
-                    return ResolvedParameterExpansion {
-                        .parameter = {},
-                        .argument = {},
-                        .range = expansion.range,
-                        .op = ResolvedParameterExpansion::Op::StringLength,
-                        .expand = ResolvedParameterExpansion::Expand::Nothing,
-                    };
+                    return ResolvedArithmeticExpansion { expansion.expression, expansion.range };
                 },
                 [&](CommandExpansion const& expansion) -> ResolvedExpansion {
                     Parser parser { expansion.command.string_view() };
                     auto node = parser.parse();
                     m_errors.extend(move(parser.m_errors));
                     return ResolvedCommandExpansion {
                         move(node),
                         expansion.range,
                     };
                 });
 
             resolved_expansions.append(move(resolved));
         }
 
         token.resolved_expansions = move(resolved_expansions);
         expanded_tokens.append(move(token));
     }
 
     swap_expansions();
 
     // (7) Loop variables
     previous_token = {};
     tokens_taken_from_buffer = 0;
     if (m_token_buffer.size() >= 1) {
         previous_token = m_token_buffer.take_last();
         tokens_taken_from_buffer++;
     }
 
     for (auto& token : tokens) {
         if (!previous_token.has_value()) {
             previous_token = token;
             continue;
         }
 
         if (previous_token->type == Token::Type::For && token.type == Token::Type::Word && is_valid_name(token.value)) {
             token.type = Token::Type::VariableName;
         }
 
         expanded_tokens.append(exchange(*previous_token, token));
     }
 
     swap_expansions();
 
     // (8) Function names
     previous_token = {};
     previous_previous_token = {};
     tokens_taken_from_buffer = 0;
     if (m_token_buffer.size() >= 1) {
         previous_token = m_token_buffer.take_last();
         tokens_taken_from_buffer++;
     }
     if (m_token_buffer.size() >= 1) {
         previous_previous_token = m_token_buffer.take_last();
         tokens_taken_from_buffer++;
     }
 
     for (auto& token : tokens) {
         if (!previous_token.has_value()) {
             previous_token = token;
             continue;
         }
         if (!previous_previous_token.has_value()) {
             previous_previous_token = move(previous_token);
             previous_token = token;
             continue;
         }
 
         // NAME ( )
         if (previous_previous_token->could_be_start_of_a_simple_command
             && previous_previous_token->type == Token::Type::Word
             && previous_token->type == Token::Type::OpenParen
             && token.type == Token::Type::CloseParen) {
 
             previous_previous_token->type = Token::Type::VariableName;
         }
 
         expanded_tokens.append(exchange(*previous_previous_token, exchange(*previous_token, token)));
     }
 
     swap_expansions();
 
     return tokens;
 }
@@ -1398,355 +1392,404 @@ RefPtr<AST::Node> Parser::parse_word_list()
 ErrorOr<RefPtr<AST::Node>> Parser::parse_word()
 {
     if (peek().type != Token::Type::Word)
         return nullptr;
 
     auto token = consume();
     RefPtr<AST::Node> word;
 
     enum class Quote {
         None,
         Single,
         Double,
     } in_quote { Quote::None };
 
     auto append_bareword = [&](StringView string) -> ErrorOr<void> {
         if (!word && string.starts_with('~')) {
             GenericLexer lexer { string };
             lexer.ignore();
             auto user = lexer.consume_while(is_ascii_alphanumeric);
             string = lexer.remaining();
 
             word = make_ref_counted<AST::Tilde>(token.position.value_or(empty_position()), TRY(String::from_utf8(user)));
         }
 
         if (string.is_empty())
             return {};
 
         auto node = make_ref_counted<AST::BarewordLiteral>(
             token.position.value_or(empty_position()),
             TRY(String::from_utf8(string)));
 
         if (word) {
             word = make_ref_counted<AST::Juxtaposition>(
                 word->position().with_end(token.position.value_or(empty_position())),
                 *word,
                 move(node),
                 AST::Juxtaposition::Mode::StringExpand);
         } else {
             word = move(node);
         }
 
         return {};
     };
 
     auto append_string_literal = [&](StringView string) -> ErrorOr<void> {
         if (string.is_empty())
             return {};
 
         auto node = make_ref_counted<AST::StringLiteral>(
             token.position.value_or(empty_position()),
             TRY(String::from_utf8(string)),
             AST::StringLiteral::EnclosureType::SingleQuotes);
 
         if (word) {
             word = make_ref_counted<AST::Juxtaposition>(
                 word->position().with_end(token.position.value_or(empty_position())),
                 *word,
                 move(node),
                 AST::Juxtaposition::Mode::StringExpand);
         } else {
             word = move(node);
         }
 
         return {};
     };
 
     auto append_string_part = [&](StringView string) -> ErrorOr<void> {
         if (string.is_empty())
             return {};
 
         auto node = make_ref_counted<AST::StringLiteral>(
             token.position.value_or(empty_position()),
             TRY(String::from_utf8(string)),
             AST::StringLiteral::EnclosureType::DoubleQuotes);
 
         if (word) {
             word = make_ref_counted<AST::Juxtaposition>(
                 word->position().with_end(token.position.value_or(empty_position())),
                 *word,
                 move(node),
                 AST::Juxtaposition::Mode::StringExpand);
         } else {
             word = move(node);
         }
 
         return {};
     };
 
+    auto append_arithmetic_expansion = [&](ResolvedArithmeticExpansion const& x) -> ErrorOr<void> {
+        auto node = make_ref_counted<AST::ImmediateExpression>(
+            token.position.value_or(empty_position()),
+            AST::NameWithPosition {
+                TRY("math"_string),
+                token.position.value_or(empty_position()),
+            },
+            Vector<NonnullRefPtr<AST::Node>> {
+                make_ref_counted<AST::ImmediateExpression>(
+                    token.position.value_or(empty_position()),
+                    AST::NameWithPosition {
+                        TRY("reexpand"_string),
+                        token.position.value_or(empty_position()),
+                    },
+                    Vector<NonnullRefPtr<AST::Node>> {
+                        make_ref_counted<AST::StringLiteral>(
+                            token.position.value_or(empty_position()),
+                            TRY(String::from_utf8(x.source_expression)),
+                            AST::StringLiteral::EnclosureType::DoubleQuotes),
+                    },
+                    Optional<AST::Position> {}) },
+            Optional<AST::Position> {});
+
+        if (word) {
+            word = make_ref_counted<AST::Juxtaposition>(
+                word->position().with_end(token.position.value_or(empty_position())),
+                *word,
+                move(node),
+                AST::Juxtaposition::Mode::StringExpand);
+        } else {
+            word = move(node);
+        }
+
+        return {};
+    };
+
     auto append_parameter_expansion = [&](ResolvedParameterExpansion const& x) -> ErrorOr<void> {
         StringView immediate_function_name;
         RefPtr<AST::Node> node;
         switch (x.op) {
         case ResolvedParameterExpansion::Op::UseDefaultValue:
             immediate_function_name = "value_or_default"sv;
             break;
         case ResolvedParameterExpansion::Op::AssignDefaultValue:
             immediate_function_name = "assign_default"sv;
             break;
         case ResolvedParameterExpansion::Op::IndicateErrorIfEmpty:
             immediate_function_name = "error_if_empty"sv;
             break;
         case ResolvedParameterExpansion::Op::UseAlternativeValue:
             immediate_function_name = "null_or_alternative"sv;
             break;
         case ResolvedParameterExpansion::Op::UseDefaultValueIfUnset:
             immediate_function_name = "defined_value_or_default"sv;
             break;
         case ResolvedParameterExpansion::Op::AssignDefaultValueIfUnset:
             immediate_function_name = "assign_defined_default"sv;
             break;
         case ResolvedParameterExpansion::Op::IndicateErrorIfUnset:
             immediate_function_name = "error_if_unset"sv;
             break;
         case ResolvedParameterExpansion::Op::UseAlternativeValueIfUnset:
             immediate_function_name = "null_if_unset_or_alternative"sv;
             break;
         case ResolvedParameterExpansion::Op::RemoveLargestSuffixByPattern:
             // FIXME: Implement this
         case ResolvedParameterExpansion::Op::RemoveSmallestSuffixByPattern:
             immediate_function_name = "remove_suffix"sv;
             break;
         case ResolvedParameterExpansion::Op::RemoveLargestPrefixByPattern:
             // FIXME: Implement this
         case ResolvedParameterExpansion::Op::RemoveSmallestPrefixByPattern:
             immediate_function_name = "remove_prefix"sv;
             break;
         case ResolvedParameterExpansion::Op::StringLength:
             immediate_function_name = "length_of_variable"sv;
             break;
         case ResolvedParameterExpansion::Op::GetPositionalParameter:
         case ResolvedParameterExpansion::Op::GetVariable:
             node = make_ref_counted<AST::SimpleVariable>(
                 token.position.value_or(empty_position()),
                 x.parameter);
             break;
         case ResolvedParameterExpansion::Op::GetLastBackgroundPid:
             node = make_ref_counted<AST::SyntaxError>(
                 token.position.value_or(empty_position()),
                 TRY("$! not implemented"_string));
             break;
         case ResolvedParameterExpansion::Op::GetPositionalParameterList:
             node = make_ref_counted<AST::SpecialVariable>(
                 token.position.value_or(empty_position()),
                 '*');
             break;
         case ResolvedParameterExpansion::Op::GetCurrentOptionFlags:
             node = make_ref_counted<AST::SyntaxError>(
                 token.position.value_or(empty_position()),
                 TRY("The current option flags are not available in parameter expansions"_string));
             break;
         case ResolvedParameterExpansion::Op::GetPositionalParameterCount:
             node = make_ref_counted<AST::SpecialVariable>(
                 token.position.value_or(empty_position()),
                 '#');
             break;
         case ResolvedParameterExpansion::Op::GetLastExitStatus:
             node = make_ref_counted<AST::SpecialVariable>(
                 token.position.value_or(empty_position()),
                 '?');
             break;
         case ResolvedParameterExpansion::Op::GetPositionalParameterListAsString:
             node = make_ref_counted<AST::SyntaxError>(
                 token.position.value_or(empty_position()),
                 TRY("$* not implemented"_string));
             break;
         case ResolvedParameterExpansion::Op::GetShellProcessId:
             node = make_ref_counted<AST::SpecialVariable>(
                 token.position.value_or(empty_position()),
                 '$');
             break;
         }
 
         if (!node) {
             Vector<NonnullRefPtr<AST::Node>> arguments;
             arguments.append(make_ref_counted<AST::BarewordLiteral>(
                 token.position.value_or(empty_position()),
                 x.parameter));
 
             if (!x.argument.is_empty()) {
                 // dbgln("Will parse {}", x.argument);
                 arguments.append(*TRY(Parser { x.argument }.parse_word()));
             }
 
             node = make_ref_counted<AST::ImmediateExpression>(
                 token.position.value_or(empty_position()),
                 AST::NameWithPosition {
                     TRY(String::from_utf8(immediate_function_name)),
                     token.position.value_or(empty_position()),
                 },
                 move(arguments),
                 Optional<AST::Position> {});
         }
 
         if (x.expand == ResolvedParameterExpansion::Expand::Word) {
             node = make_ref_counted<AST::ImmediateExpression>(
                 token.position.value_or(empty_position()),
                 AST::NameWithPosition {
                     TRY("reexpand"_string),
                     token.position.value_or(empty_position()),
                 },
                 Vector { node.release_nonnull() },
                 Optional<AST::Position> {});
         }
 
         if (word) {
             word = make_ref_counted<AST::Juxtaposition>(
                 word->position().with_end(token.position.value_or(empty_position())),
                 *word,
                 node.release_nonnull(),
                 AST::Juxtaposition::Mode::StringExpand);
         } else {
             word = move(node);
         }
 
         return {};
     };
 
     auto append_command_expansion = [&](ResolvedCommandExpansion const& x) -> ErrorOr<void> {
         if (!x.command)
             return {};
 
         RefPtr<AST::Execute> execute_node;
 
         if (x.command->is_execute()) {
             execute_node = const_cast<AST::Execute&>(static_cast<AST::Execute const&>(*x.command));
             execute_node->capture_stdout();
         } else {
             execute_node = make_ref_counted<AST::Execute>(
                 word ? word->position() : empty_position(),
                 *x.command,
                 true);
         }
 
         if (word) {
             word = make_ref_counted<AST::Juxtaposition>(
                 word->position(),
                 *word,
                 execute_node.release_nonnull(),
                 AST::Juxtaposition::Mode::StringExpand);
         } else {
             word = move(execute_node);
         }
 
         return {};
     };
 
     auto append_string = [&](StringView string) -> ErrorOr<void> {
         if (string.is_empty())
             return {};
 
         Optional<size_t> run_start;
         auto escape = false;
         for (size_t i = 0; i < string.length(); ++i) {
             auto ch = string[i];
             switch (ch) {
             case '\\':
                 if (!escape && i + 1 < string.length()) {
                     if (is_one_of(string[i + 1], '"', '\'', '$', '`', '\\')) {
                         escape = in_quote != Quote::Single;
                         continue;
                     }
                 }
                 break;
             case '\'':
                 if (in_quote == Quote::Single) {
                     in_quote = Quote::None;
                     TRY(append_string_literal(string.substring_view(*run_start, i - *run_start)));
                     run_start = i + 1;
                     continue;
                 }
                 if (in_quote == Quote::Double) {
                     escape = false;
                     continue;
                 }
                 [[fallthrough]];
             case '"':
                 if (ch == '\'' && in_quote == Quote::Single) {
                     escape = false;
                     continue;
                 }
                 if (!escape) {
                     if (ch == '"' && in_quote == Quote::Double) {
                         in_quote = Quote::None;
                         if (run_start.has_value())
                             TRY(append_string_part(string.substring_view(*run_start, i - *run_start)));
                         run_start = i + 1;
                         continue;
                     }
                     if (run_start.has_value())
                         TRY(append_bareword(string.substring_view(*run_start, i - *run_start)));
                     in_quote = ch == '\'' ? Quote::Single : Quote::Double;
                     run_start = i + 1;
                 }
                 escape = false;
                 [[fallthrough]];
             default:
                 if (!run_start.has_value())
                     run_start = i;
                 escape = false;
                 continue;
             }
         }
 
         if (run_start.has_value())
             TRY(append_bareword(string.substring_view(*run_start, string.length() - *run_start)));
 
         return {};
     };
 
     if (!token.resolved_expansions.is_empty())
         dbgln_if(SHELL_POSIX_PARSER_DEBUG, "Expanding '{}' with {} expansion entries", token.value, token.resolved_expansions.size());
 
     size_t current_offset = 0;
     auto value_bytes = token.value.bytes_as_string_view();
     for (auto& expansion : token.resolved_expansions) {
         TRY(expansion.visit(
             [&](ResolvedParameterExpansion const& x) -> ErrorOr<void> {
                 dbgln_if(SHELL_POSIX_PARSER_DEBUG, "    Expanding '{}' ({}+{})", x.to_deprecated_string(), x.range.start, x.range.length);
                 if (x.range.start >= value_bytes.length()) {
                     dbgln("Parameter expansion range {}-{} is out of bounds for '{}'", x.range.start, x.range.length, value_bytes);
                     return {};
                 }
 
                 if (x.range.start != current_offset) {
                     TRY(append_string(value_bytes.substring_view(current_offset, x.range.start - current_offset)));
                     current_offset = x.range.start;
                 }
                 current_offset += x.range.length;
                 return append_parameter_expansion(x);
             },
+            [&](ResolvedArithmeticExpansion const& x) -> ErrorOr<void> {
+                if (x.range.start >= value_bytes.length()) {
+                    dbgln("Parameter expansion range {}-{} is out of bounds for '{}'", x.range.start, x.range.length, value_bytes);
+                    return {};
+                }
+
+                if (x.range.start != current_offset) {
+                    TRY(append_string(value_bytes.substring_view(current_offset, x.range.start - current_offset)));
+                    current_offset = x.range.start;
+                }
+                current_offset += x.range.length;
+                return append_arithmetic_expansion(x);
+            },
             [&](ResolvedCommandExpansion const& x) -> ErrorOr<void> {
                 if (x.range.start >= value_bytes.length()) {
                     dbgln("Parameter expansion range {}-{} is out of bounds for '{}'", x.range.start, x.range.length, value_bytes);
                     return {};
                 }
 
                 if (x.range.start != current_offset) {
                     TRY(append_string(value_bytes.substring_view(current_offset, x.range.start - current_offset)));
                     current_offset = x.range.start;
                 }
                 current_offset += x.range.length;
                 return append_command_expansion(x);
             }));
     }
 
     if (current_offset > value_bytes.length()) {
         dbgln("Parameter expansion range {}- is out of bounds for '{}'", current_offset, value_bytes);
         return word;
     }
 
     if (current_offset != value_bytes.length())
         TRY(append_string(value_bytes.substring_view(current_offset)));
 
     return word;
 }
diff --git a/Userland/Shell/Shell.h b/Userland/Shell/Shell.h
index 6ecf7cb989..f8ca97cbbd 100644
--- a/Userland/Shell/Shell.h
+++ b/Userland/Shell/Shell.h
@@ -1,86 +1,87 @@
 /*
  * Copyright (c) 2020-2022, the SerenityOS developers.
  *
  * SPDX-License-Identifier: BSD-2-Clause
  */
 
 #pragma once
 
 #include "Job.h"
 #include "Parser.h"
 #include <AK/Array.h>
 #include <AK/CircularQueue.h>
 #include <AK/DeprecatedString.h>
 #include <AK/HashMap.h>
 #include <AK/StackInfo.h>
 #include <AK/StringBuilder.h>
 #include <AK/StringView.h>
 #include <AK/Types.h>
 #include <AK/Vector.h>
 #include <LibCore/Notifier.h>
 #include <LibCore/Object.h>
 #include <LibLine/Editor.h>
 #include <LibMain/Main.h>
 #include <termios.h>
 
 #define ENUMERATE_SHELL_BUILTINS()     \
     __ENUMERATE_SHELL_BUILTIN(alias)   \
     __ENUMERATE_SHELL_BUILTIN(where)   \
     __ENUMERATE_SHELL_BUILTIN(cd)      \
     __ENUMERATE_SHELL_BUILTIN(cdh)     \
     __ENUMERATE_SHELL_BUILTIN(pwd)     \
     __ENUMERATE_SHELL_BUILTIN(type)    \
     __ENUMERATE_SHELL_BUILTIN(exec)    \
     __ENUMERATE_SHELL_BUILTIN(exit)    \
     __ENUMERATE_SHELL_BUILTIN(export)  \
     __ENUMERATE_SHELL_BUILTIN(glob)    \
     __ENUMERATE_SHELL_BUILTIN(unalias) \
     __ENUMERATE_SHELL_BUILTIN(unset)   \
     __ENUMERATE_SHELL_BUILTIN(history) \
     __ENUMERATE_SHELL_BUILTIN(umask)   \
     __ENUMERATE_SHELL_BUILTIN(not )    \
     __ENUMERATE_SHELL_BUILTIN(dirs)    \
     __ENUMERATE_SHELL_BUILTIN(pushd)   \
     __ENUMERATE_SHELL_BUILTIN(popd)    \
     __ENUMERATE_SHELL_BUILTIN(setopt)  \
     __ENUMERATE_SHELL_BUILTIN(shift)   \
     __ENUMERATE_SHELL_BUILTIN(source)  \
     __ENUMERATE_SHELL_BUILTIN(time)    \
     __ENUMERATE_SHELL_BUILTIN(jobs)    \
     __ENUMERATE_SHELL_BUILTIN(disown)  \
     __ENUMERATE_SHELL_BUILTIN(fg)      \
     __ENUMERATE_SHELL_BUILTIN(bg)      \
     __ENUMERATE_SHELL_BUILTIN(wait)    \
     __ENUMERATE_SHELL_BUILTIN(dump)    \
     __ENUMERATE_SHELL_BUILTIN(kill)    \
     __ENUMERATE_SHELL_BUILTIN(noop)    \
     __ENUMERATE_SHELL_BUILTIN(argsparser_parse)
 
 #define ENUMERATE_SHELL_OPTIONS()                                                                                    \
     __ENUMERATE_SHELL_OPTION(inline_exec_keep_empty_segments, false, "Keep empty segments in inline execute $(...)") \
     __ENUMERATE_SHELL_OPTION(verbose, false, "Announce every command that is about to be executed")                  \
     __ENUMERATE_SHELL_OPTION(invoke_program_for_autocomplete, false, "Attempt to use the program being completed itself for autocompletion via --complete")
 
 #define ENUMERATE_SHELL_IMMEDIATE_FUNCTIONS()                          \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(concat_lists)                 \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(length)                       \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(length_across)                \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(remove_suffix)                \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(remove_prefix)                \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(regex_replace)                \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(filter_glob)                  \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(split)                        \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(join)                         \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(value_or_default)             \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(assign_default)               \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(error_if_empty)               \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(null_or_alternative)          \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(defined_value_or_default)     \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(assign_defined_default)       \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(error_if_unset)               \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(null_if_unset_or_alternative) \
     __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(length_of_variable)           \
-    __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(reexpand)
+    __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(reexpand)                     \
+    __ENUMERATE_SHELL_IMMEDIATE_FUNCTION(math)
 
 namespace Shell {
 
