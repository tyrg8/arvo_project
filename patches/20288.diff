commit 4bb0afabfcbf9123f95a787db9b10af791dd1dc7
Author: Cristy <mikayla-grace@urban-warrior.org>
Date:   Wed Jan 22 20:35:36 2020 -0500

    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=20288

diff --git a/MagickCore/fx.c b/MagickCore/fx.c
index ed2875159..1af2ef40d 100644
--- a/MagickCore/fx.c
+++ b/MagickCore/fx.c
@@ -1431,1218 +1431,1221 @@ static const char *FxOperatorPrecedence(const char *expression,
 static double FxEvaluateSubexpression(FxInfo *fx_info,
   const PixelChannel channel,const ssize_t x,const ssize_t y,
   const char *expression,const size_t depth,double *beta,
   ExceptionInfo *exception)
 {
 #define FxMaxParenthesisDepth  58
 #define FxMaxSubexpressionDepth  200
 #define FxReturn(value) \
 { \
   subexpression=DestroyString(subexpression); \
   return(value); \
 }
 #define FxParseSubscription(subexpression,sentinal,p,q) \
 { \
   p=subexpression; \
   for (q=(char *) p; (*q != (sentinal)) && (*q != '\0'); q++) \
     if (*q == '(') \
       { \
         for (q++; (*q != ')') && (*q != '\0'); q++); \
         if (*q == '\0') \
           break; \
       } \
   if (*q == '\0') \
     { \
       (void) ThrowMagickException(exception,GetMagickModule(), \
         OptionError,"UnableToParseExpression","`%s'",subexpression); \
       FxReturn(0.0); \
     } \
   *q='\0'; \
 }
 
   char
     *q,
     *subexpression;
 
   double
     alpha,
     gamma,
     sans,
     value;
 
   register const char
     *p;
 
   *beta=0.0;
   sans=0.0;
   subexpression=AcquireString(expression);
   *subexpression='\0';
   if (depth > FxMaxSubexpressionDepth)
     {
       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
         "UnableToParseExpression","`%s'",expression);
       FxReturn(0.0);
     }
   if (exception->severity >= ErrorException)
     FxReturn(0.0);
   while (isspace((int) ((unsigned char) *expression)) != 0)
     expression++;
   if (*expression == '\0')
     FxReturn(0.0);
   p=FxOperatorPrecedence(expression,exception);
   if (p != (const char *) NULL)
     {
       (void) CopyMagickString(subexpression,expression,(size_t)
         (p-expression+1));
       alpha=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,
         beta,exception);
       switch ((unsigned char) *p)
       {
         case '~':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           *beta=(double) (~(size_t) *beta);
           FxReturn(*beta);
         }
         case '!':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(*beta == 0.0 ? 1.0 : 0.0);
         }
         case '^':
         {
           *beta=pow(alpha,FxEvaluateSubexpression(fx_info,channel,x,y,++p,
             depth+1,beta,exception));
           FxReturn(*beta);
         }
         case '*':
         case ExponentialNotation:
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(alpha*(*beta));
         }
         case '/':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(PerceptibleReciprocal(*beta)*alpha);
         }
         case '%':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(fmod(alpha,*beta));
         }
         case '+':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(alpha+(*beta));
         }
         case '-':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(alpha-(*beta));
         }
         case BitwiseAndAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           value=(double) ((size_t) (alpha+0.5) & (size_t) (*beta+0.5));
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case BitwiseOrAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           value=(double) ((size_t) (alpha+0.5) | (size_t) (*beta+0.5));
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case LeftShiftAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           if ((size_t) (*beta+0.5) >= (8*sizeof(size_t)))
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"ShiftCountOverflow","`%s'",subexpression);
               FxReturn(0.0);
             }
           value=(double) ((size_t) (alpha+0.5) << (size_t) (*beta+0.5));
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case RightShiftAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           if ((size_t) (*beta+0.5) >= (8*sizeof(size_t)))
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"ShiftCountOverflow","`%s'",subexpression);
               FxReturn(0.0);
             }
           value=(double) ((size_t) (alpha+0.5) >> (size_t) (*beta+0.5));
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case PowerAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           value=pow(alpha,*beta);
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case ModuloAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           value=fmod(alpha,*beta);
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case PlusAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           value=alpha+(*beta);
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case SubtractAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           value=alpha-(*beta);
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case MultiplyAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           value=alpha*(*beta);
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case DivideAssignmentOperator:
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           value=alpha*PerceptibleReciprocal(*beta);
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case IncrementAssignmentOperator:
         {
           if (*subexpression == '\0')
             alpha=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
               exception);
           value=alpha+1.0;
           if (*subexpression == '\0')
             {
               if (SetFxSymbolValue(fx_info,p,value) == MagickFalse)
                 return(0.0);
             }
           else
             if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
               return(0.0);
           FxReturn(*beta);
         }
         case DecrementAssignmentOperator:
         {
           if (*subexpression == '\0')
             alpha=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
               exception);
           value=alpha-1.0;
           if (*subexpression == '\0')
             {
               if (SetFxSymbolValue(fx_info,p,value) == MagickFalse)
                 return(0.0);
             }
           else
             if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
               return(0.0);
           FxReturn(*beta);
         }
         case LeftShiftOperator:
         {
           gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           if ((size_t) (gamma+0.5) >= (8*sizeof(size_t)))
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"ShiftCountOverflow","`%s'",subexpression);
               FxReturn(0.0);
             }
           *beta=(double) ((size_t) (alpha+0.5) << (size_t) (gamma+0.5));
           FxReturn(*beta);
         }
         case RightShiftOperator:
         {
           gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           if ((size_t) (gamma+0.5) >= (8*sizeof(size_t)))
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"ShiftCountOverflow","`%s'",subexpression);
               FxReturn(0.0);
             }
           *beta=(double) ((size_t) (alpha+0.5) >> (size_t) (gamma+0.5));
           FxReturn(*beta);
         }
         case '<':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(alpha < *beta ? 1.0 : 0.0);
         }
         case LessThanEqualOperator:
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(alpha <= *beta ? 1.0 : 0.0);
         }
         case '>':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(alpha > *beta ? 1.0 : 0.0);
         }
         case GreaterThanEqualOperator:
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(alpha >= *beta ? 1.0 : 0.0);
         }
         case EqualOperator:
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(fabs(alpha-(*beta)) < MagickEpsilon ? 1.0 : 0.0);
         }
         case NotEqualOperator:
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(fabs(alpha-(*beta)) >= MagickEpsilon ? 1.0 : 0.0);
         }
         case '&':
         {
           gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           *beta=(double) ((size_t) (alpha+0.5) & (size_t) (gamma+0.5));
           FxReturn(*beta);
         }
         case '|':
         {
           gamma=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           *beta=(double) ((size_t) (alpha+0.5) | (size_t) (gamma+0.5));
           FxReturn(*beta);
         }
         case LogicalAndOperator:
         {
           p++;
           if (alpha <= 0.0)
             {
               *beta=0.0;
               FxReturn(*beta);
             }
           gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
             exception);
           *beta=(gamma > 0.0) ? 1.0 : 0.0;
           FxReturn(*beta);
         }
         case LogicalOrOperator:
         {
           p++;
           if (alpha > 0.0)
             {
              *beta=1.0;
              FxReturn(*beta);
             }
           gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
             exception);
           *beta=(gamma > 0.0) ? 1.0 : 0.0;
           FxReturn(*beta);
         }
         case '?':
         {
           (void) CopyMagickString(subexpression,++p,MagickPathExtent);
           FxParseSubscription(subexpression,':',p,q);
           if (fabs(alpha) >= MagickEpsilon)
             gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
               exception);
           else
             gamma=FxEvaluateSubexpression(fx_info,channel,x,y,q+1,depth+1,beta,
               exception);
           FxReturn(gamma);
         }
         case '=':
         {
           q=subexpression;
           while (isalpha((int) ((unsigned char) *q)) != 0)
             q++;
           if (*q != '\0')
             {
               (void) ThrowMagickException(exception,GetMagickModule(),
                 OptionError,"UnableToParseExpression","`%s'",subexpression);
               FxReturn(0.0);
             }
           ClearMagickException(exception);
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           value=(*beta);
           if (SetFxSymbolValue(fx_info,subexpression,value) == MagickFalse)
             return(0.0);
           FxReturn(*beta);
         }
         case ',':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(alpha);
         }
         case ';':
         {
           *beta=FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,beta,
             exception);
           FxReturn(*beta);
         }
         default:
         {
           gamma=alpha*FxEvaluateSubexpression(fx_info,channel,x,y,++p,depth+1,
             beta,exception);
           FxReturn(gamma);
         }
       }
     }
   if (strchr("(",(int) *expression) != (char *) NULL)
     {
       size_t
         length;
 
       if (depth >= FxMaxParenthesisDepth)
         (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
           "ParenthesisNestedTooDeeply","`%s'",expression);
       length=CopyMagickString(subexpression,expression+1,MagickPathExtent);
       if (length != 0)
         subexpression[length-1]='\0';
       gamma=FxEvaluateSubexpression(fx_info,channel,x,y,subexpression,depth+1,
         beta,exception);
       FxReturn(gamma);
     }
   switch (*expression)
   {
     case '+':
     {
       gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth+1,
         beta,exception);
       FxReturn(1.0*gamma);
     }
     case '-':
     {
       gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth+1,
         beta,exception);
       FxReturn(-1.0*gamma);
     }
     case '~':
     {
       gamma=FxEvaluateSubexpression(fx_info,channel,x,y,expression+1,depth+1,
         beta,exception);
       FxReturn((double) (~(size_t) (gamma+0.5)));
     }
     case 'A':
     case 'a':
     {
       if (IsFxFunction(expression,"abs",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(fabs(alpha));
         }
 #if defined(MAGICKCORE_HAVE_ACOSH)
       if (IsFxFunction(expression,"acosh",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           FxReturn(acosh(alpha));
         }
 #endif
       if (IsFxFunction(expression,"acos",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           FxReturn(acos(alpha));
         }
 #if defined(MAGICKCORE_HAVE_J1)
       if (IsFxFunction(expression,"airy",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           if (alpha == 0.0)
             FxReturn(1.0);
           gamma=2.0*j1((MagickPI*alpha))/(MagickPI*alpha);
           FxReturn(gamma*gamma);
         }
 #endif
 #if defined(MAGICKCORE_HAVE_ASINH)
       if (IsFxFunction(expression,"asinh",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           FxReturn(asinh(alpha));
         }
 #endif
       if (IsFxFunction(expression,"asin",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           FxReturn(asin(alpha));
         }
       if (IsFxFunction(expression,"alt",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(((ssize_t) alpha) & 0x01 ? -1.0 : 1.0);
         }
       if (IsFxFunction(expression,"atan2",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           FxReturn(atan2(alpha,*beta));
         }
 #if defined(MAGICKCORE_HAVE_ATANH)
       if (IsFxFunction(expression,"atanh",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           FxReturn(atanh(alpha));
         }
 #endif
       if (IsFxFunction(expression,"atan",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           FxReturn(atan(alpha));
         }
       if (LocaleCompare(expression,"a") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'B':
     case 'b':
     {
       if (LocaleCompare(expression,"b") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'C':
     case 'c':
     {
       if (IsFxFunction(expression,"ceil",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           FxReturn(ceil(alpha));
         }
       if (IsFxFunction(expression,"clamp",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           if (alpha < 0.0)
             FxReturn(0.0);
           if (alpha > 1.0)
             FxReturn(1.0);
           FxReturn(alpha);
         }
       if (IsFxFunction(expression,"cosh",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           FxReturn(cosh(alpha));
         }
       if (IsFxFunction(expression,"cos",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(cos(alpha));
         }
       if (LocaleCompare(expression,"c") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'D':
     case 'd':
     {
       if (IsFxFunction(expression,"debug",5) != MagickFalse)
         {
           const char
             *type;
 
           size_t
             length;
 
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           switch (fx_info->images->colorspace)
           {
             case CMYKColorspace:
             {
               switch (channel)
               {
                 case CyanPixelChannel: type="cyan"; break;
                 case MagentaPixelChannel: type="magenta"; break;
                 case YellowPixelChannel: type="yellow"; break;
                 case AlphaPixelChannel: type="alpha"; break;
                 case BlackPixelChannel: type="black"; break;
                 default: type="unknown"; break;
               }
               break;
             }
             case GRAYColorspace:
             {
               switch (channel)
               {
                 case RedPixelChannel: type="gray"; break;
                 case AlphaPixelChannel: type="alpha"; break;
                 default: type="unknown"; break;
               }
               break;
             }
             default:
             {
               switch (channel)
               {
                 case RedPixelChannel: type="red"; break;
                 case GreenPixelChannel: type="green"; break;
                 case BluePixelChannel: type="blue"; break;
                 case AlphaPixelChannel: type="alpha"; break;
                 default: type="unknown"; break;
               }
               break;
             }
           }
           *subexpression='\0';
           length=1;
           if (strlen(expression) > 6)
             length=CopyMagickString(subexpression,expression+6,
               MagickPathExtent);
           if (length != 0)
             subexpression[length-1]='\0';
           if (fx_info->file != (FILE *) NULL)
             (void) FormatLocaleFile(fx_info->file,"%s[%.20g,%.20g].%s: "
               "%s=%.*g\n",fx_info->images->filename,(double) x,(double) y,type,
               subexpression,GetMagickPrecision(),alpha);
           FxReturn(alpha);
         }
       if (IsFxFunction(expression,"do",2) != MagickFalse)
         {
           size_t
             length;
 
           /*
             Parse do(expression,condition test).
           */
           length=CopyMagickString(subexpression,expression+3,MagickPathExtent);
           if (length != 0)
             subexpression[length-1]='\0';
           FxParseSubscription(subexpression,',',p,q);
-          for ( ; ; )
+          for (alpha=0.0; ; )
           {
-            alpha=FxEvaluateSubexpression(fx_info,channel,x,y,q+1,depth+1,beta,
-              exception);
+            if (*q != '\0')
+              alpha=FxEvaluateSubexpression(fx_info,channel,x,y,q+1,depth+1,
+                beta,exception);
             gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,&sans,
               exception);
             if (fabs(gamma) < MagickEpsilon)
               break;
           }
           FxReturn(alpha);
         }
       if (IsFxFunction(expression,"drc",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn((alpha/(*beta*(alpha-1.0)+1.0)));
         }
       break;
     }
     case 'E':
     case 'e':
     {
       if (LocaleCompare(expression,"epsilon") == 0)
         FxReturn(MagickEpsilon);
 #if defined(MAGICKCORE_HAVE_ERF)
       if (IsFxFunction(expression,"erf",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(erf(alpha));
         }
 #endif
       if (IsFxFunction(expression,"exp",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(exp(alpha));
         }
       if (LocaleCompare(expression,"e") == 0)
         FxReturn(2.7182818284590452354);
       break;
     }
     case 'F':
     case 'f':
     {
       if (IsFxFunction(expression,"floor",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           FxReturn(floor(alpha));
         }
       if (IsFxFunction(expression,"for",3) != MagickFalse)
         {
           double
             sans = 0.0;
 
           size_t
             length;
 
           /*
             Parse for(initialization, condition test, expression).
           */
           length=CopyMagickString(subexpression,expression+4,MagickPathExtent);
           if (length != 0)
             subexpression[length-1]='\0';
           FxParseSubscription(subexpression,',',p,q);
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,&sans,
             exception);
           (void) CopyMagickString(subexpression,q+1,MagickPathExtent);
           FxParseSubscription(subexpression,',',p,q);
-          for ( ; ; )
+          for (alpha=0.0; ; )
           {
             gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,&sans,
               exception);
             if (fabs(gamma) < MagickEpsilon)
               break;
-            alpha=FxEvaluateSubexpression(fx_info,channel,x,y,q+1,depth+1,beta,
-              exception);
+            if (*q != '\0')
+              alpha=FxEvaluateSubexpression(fx_info,channel,x,y,q+1,depth+1,
+                beta,exception);
           }
           FxReturn(alpha);
         }
       break;
     }
     case 'G':
     case 'g':
     {
       if (IsFxFunction(expression,"gauss",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           FxReturn(exp((-alpha*alpha/2.0))/sqrt(2.0*MagickPI));
         }
       if (IsFxFunction(expression,"gcd",3) != MagickFalse)
         {
           MagickOffsetType
             gcd;
 
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           gcd=FxGCD((MagickOffsetType) (alpha+0.5),(MagickOffsetType) (*beta+
             0.5));
           FxReturn((double) gcd);
         }
       if (LocaleCompare(expression,"g") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'H':
     case 'h':
     {
       if (LocaleCompare(expression,"h") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       if (LocaleCompare(expression,"hue") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       if (IsFxFunction(expression,"hypot",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           FxReturn(hypot(alpha,*beta));
         }
       break;
     }
     case 'K':
     case 'k':
     {
       if (LocaleCompare(expression,"k") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'I':
     case 'i':
     {
       if (IsFxFunction(expression,"if",2) != MagickFalse)
         {
           double
             sans = 0.0;
 
           size_t
             length;
 
           length=CopyMagickString(subexpression,expression+3,MagickPathExtent);
           if (length != 0)
             subexpression[length-1]='\0';
           FxParseSubscription(subexpression,',',p,q);
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,&sans,
             exception);
           (void) CopyMagickString(subexpression,q+1,MagickPathExtent);
           FxParseSubscription(subexpression,',',p,q);
           if (fabs(alpha) >= MagickEpsilon)
             alpha=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,beta,
               exception);
           else
             alpha=FxEvaluateSubexpression(fx_info,channel,x,y,q+1,depth+1,beta,
               exception);
           FxReturn(alpha);
         }
       if (LocaleCompare(expression,"intensity") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       if (IsFxFunction(expression,"int",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(floor(alpha));
         }
       if (IsFxFunction(expression,"isnan",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           FxReturn((double) !!IsNaN(alpha));
         }
       if (LocaleCompare(expression,"i") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'J':
     case 'j':
     {
       if (LocaleCompare(expression,"j") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
 #if defined(MAGICKCORE_HAVE_J0)
       if (IsFxFunction(expression,"j0",2) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,
             depth+1,beta,exception);
           FxReturn(j0(alpha));
         }
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
       if (IsFxFunction(expression,"j1",2) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,
             depth+1,beta,exception);
           FxReturn(j1(alpha));
         }
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
       if (IsFxFunction(expression,"jinc",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           if (alpha == 0.0)
             FxReturn(1.0);
           FxReturn((2.0*j1((MagickPI*alpha))/(MagickPI*alpha)));
         }
 #endif
       break;
     }
     case 'L':
     case 'l':
     {
       if (IsFxFunction(expression,"ln",2) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+2,
             depth+1,beta,exception);
           FxReturn(log(alpha));
         }
       if (IsFxFunction(expression,"logtwo",6) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+6,
             depth+1,beta,exception);
           FxReturn(log10(alpha)/log10(2.0));
         }
       if (IsFxFunction(expression,"log",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(log10(alpha));
         }
       if (LocaleCompare(expression,"lightness") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'M':
     case 'm':
     {
       if (LocaleCompare(expression,"MaxRGB") == 0)
         FxReturn(QuantumRange);
       if (LocaleNCompare(expression,"maxima",6) == 0)
         break;
       if (IsFxFunction(expression,"max",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(alpha > *beta ? alpha : *beta);
         }
       if (LocaleNCompare(expression,"minima",6) == 0)
         break;
       if (IsFxFunction(expression,"min",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(alpha < *beta ? alpha : *beta);
         }
       if (IsFxFunction(expression,"mod",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(alpha-floor((alpha*PerceptibleReciprocal(*beta)))*(*beta));
         }
       if (LocaleCompare(expression,"m") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'N':
     case 'n':
     {
       if (IsFxFunction(expression,"not",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn((double) (alpha < MagickEpsilon));
         }
       if (LocaleCompare(expression,"n") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'O':
     case 'o':
     {
       if (LocaleCompare(expression,"Opaque") == 0)
         FxReturn(1.0);
       if (LocaleCompare(expression,"o") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'P':
     case 'p':
     {
       if (LocaleCompare(expression,"phi") == 0)
         FxReturn(MagickPHI);
       if (LocaleCompare(expression,"pi") == 0)
         FxReturn(MagickPI);
       if (IsFxFunction(expression,"pow",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(pow(alpha,*beta));
         }
       if (LocaleCompare(expression,"p") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'Q':
     case 'q':
     {
       if (LocaleCompare(expression,"QuantumRange") == 0)
         FxReturn(QuantumRange);
       if (LocaleCompare(expression,"QuantumScale") == 0)
         FxReturn(QuantumScale);
       break;
     }
     case 'R':
     case 'r':
     {
       if (IsFxFunction(expression,"rand",4) != MagickFalse)
         {
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
         #pragma omp critical (MagickCore_FxEvaluateSubexpression)
 #endif
           alpha=GetPseudoRandomValue(fx_info->random_info);
           FxReturn(alpha);
         }
       if (IsFxFunction(expression,"round",5) != MagickFalse)
         {
           /*
             Round the fraction to nearest integer.
           */
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           if ((alpha-floor(alpha)) < (ceil(alpha)-alpha))
             FxReturn(floor(alpha));
           FxReturn(ceil(alpha));
         }
       if (LocaleCompare(expression,"r") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'S':
     case 's':
     {
       if (LocaleCompare(expression,"saturation") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       if (IsFxFunction(expression,"sign",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           FxReturn(alpha < 0.0 ? -1.0 : 1.0);
         }
       if (IsFxFunction(expression,"sinc",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           if (alpha == 0)
             FxReturn(1.0);
           FxReturn(sin((MagickPI*alpha))/(MagickPI*alpha));
         }
       if (IsFxFunction(expression,"sinh",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           FxReturn(sinh(alpha));
         }
       if (IsFxFunction(expression,"sin",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(sin(alpha));
         }
       if (IsFxFunction(expression,"sqrt",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           FxReturn(sqrt(alpha));
         }
       if (IsFxFunction(expression,"squish",6) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+6,
             depth+1,beta,exception);
           FxReturn((1.0/(1.0+exp(-alpha))));
         }
       if (LocaleCompare(expression,"s") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'T':
     case 't':
     {
       if (IsFxFunction(expression,"tanh",4) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+4,
             depth+1,beta,exception);
           FxReturn(tanh(alpha));
         }
       if (IsFxFunction(expression,"tan",3) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+3,
             depth+1,beta,exception);
           FxReturn(tan(alpha));
         }
       if (LocaleCompare(expression,"Transparent") == 0)
         FxReturn(0.0);
       if (IsFxFunction(expression,"trunc",5) != MagickFalse)
         {
           alpha=FxEvaluateSubexpression(fx_info,channel,x,y,expression+5,
             depth+1,beta,exception);
           if (alpha >= 0.0)
             FxReturn(floor(alpha));
           FxReturn(ceil(alpha));
         }
       if (LocaleCompare(expression,"t") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'U':
     case 'u':
     {
       if (LocaleCompare(expression,"u") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'V':
     case 'v':
     {
       if (LocaleCompare(expression,"v") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'W':
     case 'w':
     {
       if (IsFxFunction(expression,"while",5) != MagickFalse)
         {
           size_t
             length;
 
           /*
             Parse while(condition test, expression).
           */
           length=CopyMagickString(subexpression,expression+6,MagickPathExtent);
           if (length != 0)
             subexpression[length-1]='\0';
           FxParseSubscription(subexpression,',',p,q);
-          for ( ; ; )
+          for (alpha=0.0; ; )
           {
             gamma=FxEvaluateSubexpression(fx_info,channel,x,y,p,depth+1,&sans,
               exception);
             if (fabs(gamma) < MagickEpsilon)
               break;
-            alpha=FxEvaluateSubexpression(fx_info,channel,x,y,q+1,depth+1,beta,
-              exception);
+            if (*q != '\0')
+              alpha=FxEvaluateSubexpression(fx_info,channel,x,y,q+1,depth+1,
+                beta,exception);
           }
           FxReturn(alpha);
         }
       if (LocaleCompare(expression,"w") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'Y':
     case 'y':
     {
       if (LocaleCompare(expression,"y") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     case 'Z':
     case 'z':
     {
       if (LocaleCompare(expression,"z") == 0)
         FxReturn(FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception));
       break;
     }
     default:
       break;
   }
   subexpression=DestroyString(subexpression);
   q=(char *) expression;
   alpha=InterpretSiPrefixValue(expression,&q);
   if (q == expression)
     alpha=FxGetSymbol(fx_info,channel,x,y,expression,depth+1,exception);
   FxReturn(alpha);
 }
diff --git a/coders/tiff.c b/coders/tiff.c
index 0b19b92cc..74bffe397 100644
--- a/coders/tiff.c
+++ b/coders/tiff.c
@@ -113,19 +113,14 @@
 /*
   Typedef declarations.
 */
 typedef enum
 {
   ReadSingleSampleMethod,
   ReadRGBAMethod,
   ReadCMYKAMethod,
   ReadYCCKMethod,
-  ReadContigStripMethod,
-  ReadPlanarStripMethod,
-  ReadRGBAStripMethod,
+  ReadStripMethod,
   ReadTileMethod,
-  ReadContigTileMethod,
-  ReadPlanarTileMethod,
-  ReadRGBATileMethod,
   ReadGenericMethod
 } TIFFMethodType;
 
@@ -1415,1429 +1410,951 @@ DisableMSCWarning(4127)
     if (0 && (image_info->verbose != MagickFalse))
       TIFFPrintDirectory(tiff,stdout,MagickFalse);
 RestoreMSCWarning
     photometric=PHOTOMETRIC_RGB;
     if ((TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width) != 1) ||
         (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric,sans) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_COMPRESSION,&compress_tag,sans) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian,sans) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_PLANARCONFIG,&interlace,sans) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel,sans) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample,sans) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLEFORMAT,&sample_format,sans) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value,sans) != 1) ||
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value,sans) != 1))
       {
         TIFFClose(tiff);
         ThrowReaderException(CorruptImageError,"ImproperImageHeader");
       }
     if (((sample_format != SAMPLEFORMAT_IEEEFP) || (bits_per_sample != 64)) &&
         ((bits_per_sample <= 0) || (bits_per_sample > 32)))
       {
         TIFFClose(tiff);
         ThrowReaderException(CorruptImageError,"UnsupportedBitsPerPixel");
       }
     if (sample_format == SAMPLEFORMAT_IEEEFP)
       (void) SetImageProperty(image,"quantum:format","floating-point",
         exception);
     switch (photometric)
     {
       case PHOTOMETRIC_MINISBLACK:
       {
         (void) SetImageProperty(image,"tiff:photometric","min-is-black",
           exception);
         break;
       }
       case PHOTOMETRIC_MINISWHITE:
       {
         (void) SetImageProperty(image,"tiff:photometric","min-is-white",
           exception);
         break;
       }
       case PHOTOMETRIC_PALETTE:
       {
         (void) SetImageProperty(image,"tiff:photometric","palette",exception);
         break;
       }
       case PHOTOMETRIC_RGB:
       {
         (void) SetImageProperty(image,"tiff:photometric","RGB",exception);
         break;
       }
       case PHOTOMETRIC_CIELAB:
       {
         (void) SetImageProperty(image,"tiff:photometric","CIELAB",exception);
         break;
       }
       case PHOTOMETRIC_LOGL:
       {
         (void) SetImageProperty(image,"tiff:photometric","CIE Log2(L)",
           exception);
         break;
       }
       case PHOTOMETRIC_LOGLUV:
       {
         (void) SetImageProperty(image,"tiff:photometric","LOGLUV",exception);
         break;
       }
 #if defined(PHOTOMETRIC_MASK)
       case PHOTOMETRIC_MASK:
       {
         (void) SetImageProperty(image,"tiff:photometric","MASK",exception);
         break;
       }
 #endif
       case PHOTOMETRIC_SEPARATED:
       {
         (void) SetImageProperty(image,"tiff:photometric","separated",exception);
         break;
       }
       case PHOTOMETRIC_YCBCR:
       {
         (void) SetImageProperty(image,"tiff:photometric","YCBCR",exception);
         break;
       }
       default:
       {
         (void) SetImageProperty(image,"tiff:photometric","unknown",exception);
         break;
       }
     }
     if (image->debug != MagickFalse)
       {
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),"Geometry: %ux%u",
           (unsigned int) width,(unsigned int) height);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),"Interlace: %u",
           interlace);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           "Bits per sample: %u",bits_per_sample);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           "Min sample value: %u",min_sample_value);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),
           "Max sample value: %u",max_sample_value);
         (void) LogMagickEvent(CoderEvent,GetMagickModule(),"Photometric "
           "interpretation: %s",GetImageProperty(image,"tiff:photometric",
           exception));
       }
     image->columns=(size_t) width;
     image->rows=(size_t) height;
     image->depth=(size_t) bits_per_sample;
     if (image->debug != MagickFalse)
       (void) LogMagickEvent(CoderEvent,GetMagickModule(),"Image depth: %.20g",
         (double) image->depth);
     image->endian=MSBEndian;
     if (endian == FILLORDER_LSB2MSB)
       image->endian=LSBEndian;
 #if defined(MAGICKCORE_HAVE_TIFFISBIGENDIAN)
     if (TIFFIsBigEndian(tiff) == 0)
       {
         (void) SetImageProperty(image,"tiff:endian","lsb",exception);
         image->endian=LSBEndian;
       }
     else
       {
         (void) SetImageProperty(image,"tiff:endian","msb",exception);
         image->endian=MSBEndian;
       }
 #endif
     if ((photometric == PHOTOMETRIC_MINISBLACK) ||
         (photometric == PHOTOMETRIC_MINISWHITE))
       SetImageColorspace(image,GRAYColorspace,exception);
     if (photometric == PHOTOMETRIC_SEPARATED)
       SetImageColorspace(image,CMYKColorspace,exception);
     if (photometric == PHOTOMETRIC_CIELAB)
       SetImageColorspace(image,LabColorspace,exception);
     TIFFGetProfiles(tiff,image,exception);
     TIFFGetProperties(tiff,image,exception);
     option=GetImageOption(image_info,"tiff:exif-properties");
     if (IsStringFalse(option) == MagickFalse) /* enabled by default */
       TIFFGetEXIFProperties(tiff,image,exception);
     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XRESOLUTION,&x_resolution,sans) == 1) &&
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YRESOLUTION,&y_resolution,sans) == 1))
       {
         image->resolution.x=x_resolution;
         image->resolution.y=y_resolution;
       }
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_RESOLUTIONUNIT,&units,sans) == 1)
       {
         if (units == RESUNIT_INCH)
           image->units=PixelsPerInchResolution;
         if (units == RESUNIT_CENTIMETER)
           image->units=PixelsPerCentimeterResolution;
       }
     if ((TIFFGetFieldDefaulted(tiff,TIFFTAG_XPOSITION,&x_position,sans) == 1) &&
         (TIFFGetFieldDefaulted(tiff,TIFFTAG_YPOSITION,&y_position,sans) == 1))
       {
         image->page.x=(ssize_t) ceil(x_position*image->resolution.x-0.5);
         image->page.y=(ssize_t) ceil(y_position*image->resolution.y-0.5);
       }
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_ORIENTATION,&orientation,sans) == 1)
       image->orientation=(OrientationType) orientation;
     if (TIFFGetField(tiff,TIFFTAG_WHITEPOINT,&chromaticity) == 1)
       {
         if (chromaticity != (float *) NULL)
           {
             image->chromaticity.white_point.x=chromaticity[0];
             image->chromaticity.white_point.y=chromaticity[1];
           }
       }
     if (TIFFGetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,&chromaticity) == 1)
       {
         if (chromaticity != (float *) NULL)
           {
             image->chromaticity.red_primary.x=chromaticity[0];
             image->chromaticity.red_primary.y=chromaticity[1];
             image->chromaticity.green_primary.x=chromaticity[2];
             image->chromaticity.green_primary.y=chromaticity[3];
             image->chromaticity.blue_primary.x=chromaticity[4];
             image->chromaticity.blue_primary.y=chromaticity[5];
           }
       }
 #if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)
     if ((compress_tag != COMPRESSION_NONE) &&
         (TIFFIsCODECConfigured(compress_tag) == 0))
       {
         TIFFClose(tiff);
         ThrowReaderException(CoderError,"CompressNotSupported");
       }
 #endif
     switch (compress_tag)
     {
       case COMPRESSION_NONE: image->compression=NoCompression; break;
       case COMPRESSION_CCITTFAX3: image->compression=FaxCompression; break;
       case COMPRESSION_CCITTFAX4: image->compression=Group4Compression; break;
       case COMPRESSION_JPEG:
       {
          image->compression=JPEGCompression;
 #if defined(JPEG_SUPPORT)
          {
            char
              sampling_factor[MagickPathExtent];
 
            uint16
              horizontal,
              vertical;
 
            tiff_status=TIFFGetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,&horizontal,
              &vertical);
            if (tiff_status == 1)
              {
                (void) FormatLocaleString(sampling_factor,MagickPathExtent,
                  "%dx%d",horizontal,vertical);
                (void) SetImageProperty(image,"jpeg:sampling-factor",
                  sampling_factor,exception);
                (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                  "Sampling Factors: %s",sampling_factor);
              }
          }
 #endif
         break;
       }
       case COMPRESSION_OJPEG: image->compression=JPEGCompression; break;
 #if defined(COMPRESSION_LZMA)
       case COMPRESSION_LZMA: image->compression=LZMACompression; break;
 #endif
       case COMPRESSION_LZW: image->compression=LZWCompression; break;
       case COMPRESSION_DEFLATE: image->compression=ZipCompression; break;
       case COMPRESSION_ADOBE_DEFLATE: image->compression=ZipCompression; break;
 #if defined(COMPRESSION_WEBP)
       case COMPRESSION_WEBP: image->compression=WebPCompression; break;
 #endif
 #if defined(COMPRESSION_ZSTD)
       case COMPRESSION_ZSTD: image->compression=ZstdCompression; break;
 #endif
       default: image->compression=RLECompression; break;
     }
     quantum_info=(QuantumInfo *) NULL;
     if ((photometric == PHOTOMETRIC_PALETTE) &&
         (pow(2.0,1.0*bits_per_sample) <= MaxColormapSize))
       {
         size_t
           colors;
 
         colors=(size_t) GetQuantumRange(bits_per_sample)+1;
         if (AcquireImageColormap(image,colors,exception) == MagickFalse)
           {
             TIFFClose(tiff);
             ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
           }
       }
     value=(unsigned short) image->scene;
     if (TIFFGetFieldDefaulted(tiff,TIFFTAG_PAGENUMBER,&value,&pages,sans) == 1)
       image->scene=value;
     if (image->storage_class == PseudoClass)
       {
         size_t
           range;
 
         uint16
           *blue_colormap,
           *green_colormap,
           *red_colormap;
 
         /*
           Initialize colormap.
         */
         tiff_status=TIFFGetField(tiff,TIFFTAG_COLORMAP,&red_colormap,
           &green_colormap,&blue_colormap);
         if (tiff_status == 1)
           {
             if ((red_colormap != (uint16 *) NULL) &&
                 (green_colormap != (uint16 *) NULL) &&
                 (blue_colormap != (uint16 *) NULL))
               {
                 range=255;  /* might be old style 8-bit colormap */
                 for (i=0; i < (ssize_t) image->colors; i++)
                   if ((red_colormap[i] >= 256) || (green_colormap[i] >= 256) ||
                       (blue_colormap[i] >= 256))
                     {
                       range=65535;
                       break;
                     }
                 for (i=0; i < (ssize_t) image->colors; i++)
                 {
                   image->colormap[i].red=ClampToQuantum(((double)
                     QuantumRange*red_colormap[i])/range);
                   image->colormap[i].green=ClampToQuantum(((double)
                     QuantumRange*green_colormap[i])/range);
                   image->colormap[i].blue=ClampToQuantum(((double)
                     QuantumRange*blue_colormap[i])/range);
                 }
               }
           }
       }
     if (image_info->ping != MagickFalse)
       {
         if (image_info->number_scenes != 0)
           if (image->scene >= (image_info->scene+image_info->number_scenes-1))
             break;
         goto next_tiff_frame;
       }
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       {
         TIFFClose(tiff);
         return(DestroyImageList(image));
       }
     status=ResetImagePixels(image,exception);
     if (status == MagickFalse)
       {
         TIFFClose(tiff);
         return(DestroyImageList(image));
       }
     /*
       Allocate memory for the image and pixel buffer.
     */
     quantum_info=AcquireQuantumInfo(image_info,image);
     if (quantum_info == (QuantumInfo *) NULL)
       ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
     if (sample_format == SAMPLEFORMAT_UINT)
       status=SetQuantumFormat(image,quantum_info,UnsignedQuantumFormat);
     if (sample_format == SAMPLEFORMAT_INT)
       status=SetQuantumFormat(image,quantum_info,SignedQuantumFormat);
     if (sample_format == SAMPLEFORMAT_IEEEFP)
       status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
     if (status == MagickFalse)
       ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
     status=MagickTrue;
     switch (photometric)
     {
       case PHOTOMETRIC_MINISBLACK:
       {
         quantum_info->min_is_white=MagickFalse;
         break;
       }
       case PHOTOMETRIC_MINISWHITE:
       {
         quantum_info->min_is_white=MagickTrue;
         break;
       }
       default:
         break;
     }
     tiff_status=TIFFGetFieldDefaulted(tiff,TIFFTAG_EXTRASAMPLES,&extra_samples,
       &sample_info,sans);
     if (tiff_status == 1)
       {
         (void) SetImageProperty(image,"tiff:alpha","unspecified",exception);
         if (extra_samples == 0)
           {
             if ((samples_per_pixel == 4) && (photometric == PHOTOMETRIC_RGB))
               image->alpha_trait=BlendPixelTrait;
           }
         else
           for (i=0; i < extra_samples; i++)
           {
             image->alpha_trait=BlendPixelTrait;
             if (sample_info[i] == EXTRASAMPLE_ASSOCALPHA)
               {
                 SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);
                 (void) SetImageProperty(image,"tiff:alpha","associated",
                   exception);
               }
             else
               if (sample_info[i] == EXTRASAMPLE_UNASSALPHA)
                 {
                   SetQuantumAlphaType(quantum_info,DisassociatedQuantumAlpha);
                   (void) SetImageProperty(image,"tiff:alpha","unassociated",
                     exception);
                 }
           }
       }
     if (image->alpha_trait != UndefinedPixelTrait)
       (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
     method=ReadGenericMethod;
     rows_per_strip=(uint32) image->rows;
     if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
       {
         char
           buffer[MagickPathExtent];
 
         (void) FormatLocaleString(buffer,MagickPathExtent,"%u",
           (unsigned int) rows_per_strip);
         (void) SetImageProperty(image,"tiff:rows-per-strip",buffer,exception);
       }
     if (rows_per_strip > (uint32) image->rows)
       rows_per_strip=(uint32) image->rows;
     if ((samples_per_pixel >= 3) && (interlace == PLANARCONFIG_CONTIG))
       if ((image->alpha_trait == UndefinedPixelTrait) ||
           (samples_per_pixel >= 4))
         method=ReadRGBAMethod;
     if ((samples_per_pixel >= 4) && (interlace == PLANARCONFIG_SEPARATE))
       if ((image->alpha_trait == UndefinedPixelTrait) ||
           (samples_per_pixel >= 5))
         method=ReadCMYKAMethod;
     if ((photometric != PHOTOMETRIC_RGB) &&
         (photometric != PHOTOMETRIC_CIELAB) &&
         (photometric != PHOTOMETRIC_SEPARATED))
       method=ReadGenericMethod;
     if (image->storage_class == PseudoClass)
       method=ReadSingleSampleMethod;
     if ((photometric == PHOTOMETRIC_MINISBLACK) ||
         (photometric == PHOTOMETRIC_MINISWHITE))
       method=ReadSingleSampleMethod;
     if ((photometric != PHOTOMETRIC_SEPARATED) &&
         (interlace == PLANARCONFIG_SEPARATE) && (bits_per_sample < 64))
       method=ReadGenericMethod;
     if (image->compression == JPEGCompression)
       method=GetJPEGMethod(image,tiff,photometric,bits_per_sample,
         samples_per_pixel);
     if (TIFFIsTiled(tiff) != MagickFalse)
-      {
-        method=ReadTileMethod;
-        if (samples_per_pixel > 1)
-          {
-            method=ReadContigTileMethod;
-            if (interlace == PLANARCONFIG_SEPARATE)
-              method=ReadPlanarTileMethod;
-          }
-        if (image->compression == JPEGCompression)
-          method=ReadRGBATileMethod;
-      }
+      method=ReadTileMethod;
     else
       if (TIFFGetField(tiff,TIFFTAG_ROWSPERSTRIP,&rows_per_strip) == 1)
-        {
-          method=ReadRGBAStripMethod;
-          if (samples_per_pixel > 1)
-            {
-              method=ReadContigStripMethod;
-              if (interlace == PLANARCONFIG_SEPARATE)
-                method=ReadPlanarStripMethod;
-            }
-          if (compress_tag == COMPRESSION_JBIG)
-            method=ReadRGBAStripMethod;
-        }
+        method=ReadStripMethod;
     quantum_info->endian=LSBEndian;
     quantum_type=RGBQuantum;
     if (TIFFScanlineSize(tiff) <= 0)
       ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
     if ((1.0*TIFFScanlineSize(tiff)) > (2.1*GetBlobSize(image)))
       ThrowTIFFException(CorruptImageError,"InsufficientImageDataInFile");
     number_pixels=MagickMax(TIFFScanlineSize(tiff),MagickMax((ssize_t)
       image->columns*samples_per_pixel*pow(2.0,ceil(log(bits_per_sample)/
       log(2.0))),image->columns*rows_per_strip));
     pixel_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
     if (pixel_info == (MemoryInfo *) NULL)
       ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
     (void) memset(pixels,0,number_pixels*sizeof(uint32));
-    switch (method)
-    {
-      case ReadSingleSampleMethod:
+    quantum_type=IndexQuantum;
+    pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
+    if (image->alpha_trait != UndefinedPixelTrait)
       {
-        /*
-          Convert TIFF image to PseudoClass MIFF image.
-        */
-        quantum_type=IndexQuantum;
-        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
+        if (image->storage_class == PseudoClass)
+          quantum_type=IndexAlphaQuantum;
+        else
+          quantum_type=samples_per_pixel == 1 ? AlphaQuantum : GrayAlphaQuantum;
+      }
+    else
+      if (image->storage_class != PseudoClass)
+        quantum_type=GrayQuantum;
+    if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))
+      {
+        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);
+        quantum_type=RGBQuantum;
         if (image->alpha_trait != UndefinedPixelTrait)
           {
-            if (image->storage_class != PseudoClass)
-              {
-                quantum_type=samples_per_pixel == 1 ? AlphaQuantum :
-                  GrayAlphaQuantum;
-                pad=(size_t) MagickMax((ssize_t) samples_per_pixel-2,0);
-              }
-            else
+            quantum_type=RGBAQuantum;
+            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
+          }
+        if (image->colorspace == CMYKColorspace)
+          {
+            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
+            quantum_type=CMYKQuantum;
+            if (image->alpha_trait != UndefinedPixelTrait)
               {
-                quantum_type=IndexAlphaQuantum;
-                pad=(size_t) MagickMax((ssize_t) samples_per_pixel-2,0);
+                quantum_type=CMYKAQuantum;
+                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);
               }
           }
-        else
-          if (image->storage_class != PseudoClass)
-            {
-              quantum_type=GrayQuantum;
-              pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
-            }
-        status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(
-          bits_per_sample)/log(2))));
+        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
         if (status == MagickFalse)
           ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
+      }
+    switch (method)
+    {
+      case ReadSingleSampleMethod:
+      {
+        /*
+          Convert single sample TIFF image.
+        */
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register Quantum
             *magick_restrict q;
 
           tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);
           if (tiff_status == -1)
             break;
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (Quantum *) NULL)
             break;
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadRGBAMethod:
       {
         /*
-          Convert TIFF image to DirectClass MIFF image.
+          Convert RGBA TIFF image.
         */
-        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);
-        quantum_type=RGBQuantum;
-        if (image->alpha_trait != UndefinedPixelTrait)
-          {
-            quantum_type=RGBAQuantum;
-            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
-          }
-        if (image->colorspace == CMYKColorspace)
-          {
-            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
-            quantum_type=CMYKQuantum;
-            if (image->alpha_trait != UndefinedPixelTrait)
-              {
-                quantum_type=CMYKAQuantum;
-                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);
-              }
-          }
-        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
-        if (status == MagickFalse)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register Quantum
             *magick_restrict q;
 
           tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);
           if (tiff_status == -1)
             break;
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (Quantum *) NULL)
             break;
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadCMYKAMethod:
       {
         /*
-          Convert TIFF image to DirectClass MIFF image.
+          Convert CMYK TIFF image.
         */
         for (i=0; i < (ssize_t) samples_per_pixel; i++)
         {
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             tiff_status=TIFFReadPixels(tiff,(tsample_t) i,y,(char *)
               pixels);
             if (tiff_status == -1)
               break;
             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (Quantum *) NULL)
               break;
             if (image->colorspace != CMYKColorspace)
               switch (i)
               {
                 case 0: quantum_type=RedQuantum; break;
                 case 1: quantum_type=GreenQuantum; break;
                 case 2: quantum_type=BlueQuantum; break;
                 case 3: quantum_type=AlphaQuantum; break;
                 default: quantum_type=UndefinedQuantum; break;
               }
             else
               switch (i)
               {
                 case 0: quantum_type=CyanQuantum; break;
                 case 1: quantum_type=MagentaQuantum; break;
                 case 2: quantum_type=YellowQuantum; break;
                 case 3: quantum_type=BlackQuantum; break;
                 case 4: quantum_type=AlphaQuantum; break;
                 default: quantum_type=UndefinedQuantum; break;
               }
             (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
               quantum_type,pixels,exception);
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
           }
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
       case ReadYCCKMethod:
       {
+        /*
+          Convert YCC TIFF image.
+        */
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register Quantum
             *magick_restrict q;
 
           register ssize_t
             x;
 
           unsigned char
             *p;
 
           tiff_status=TIFFReadPixels(tiff,0,y,(char *) pixels);
           if (tiff_status == -1)
             break;
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (Quantum *) NULL)
             break;
           p=pixels;
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelCyan(image,ScaleCharToQuantum(ClampYCC((double) *p+
               (1.402*(double) *(p+2))-179.456)),q);
             SetPixelMagenta(image,ScaleCharToQuantum(ClampYCC((double) *p-
               (0.34414*(double) *(p+1))-(0.71414*(double ) *(p+2))+
               135.45984)),q);
             SetPixelYellow(image,ScaleCharToQuantum(ClampYCC((double) *p+
               (1.772*(double) *(p+1))-226.816)),q);
             SetPixelBlack(image,ScaleCharToQuantum((unsigned char) *(p+3)),q);
             q+=GetPixelChannels(image);
             p+=4;
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         break;
       }
-      case ReadContigStripMethod:
+      case ReadStripMethod:
       {
         register unsigned char
           *p;
 
         ssize_t
           stride,
           strip_id;
 
         tsize_t
-          rows_remaining,
           strip_size;
 
         unsigned char
           *strip_pixels;
 
         /*
-          Convert tiled TIFF image to DirectClass MIFF image.
-        */
-        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);
-        quantum_type=RGBQuantum;
-        if (image->alpha_trait != UndefinedPixelTrait)
-          {
-            quantum_type=RGBAQuantum;
-            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
-          }
-        if (image->colorspace == CMYKColorspace)
-          {
-            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
-            quantum_type=CMYKQuantum;
-            if (image->alpha_trait != UndefinedPixelTrait)
-              {
-                quantum_type=CMYKAQuantum;
-                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);
-              }
-          }
-        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
-        if (status == MagickFalse)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        strip_pixels=(unsigned char *) AcquireQuantumMemory(TIFFStripSize(tiff)+
-          sizeof(uint32),sizeof(*strip_pixels));
-        if (strip_pixels == (unsigned char *) NULL)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        (void) memset(strip_pixels,0,TIFFStripSize(tiff)*sizeof(*strip_pixels));
-        stride=TIFFVStripSize(tiff,1);
-        strip_id=0;
-        rows_remaining=0;
-        for (y=0; y < (ssize_t) image->rows; y++)
-        {
-          register Quantum
-            *magick_restrict q;
-
-          q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
-          if (q == (Quantum *) NULL)
-            break;
-          if (rows_remaining == 0)
-            {
-              strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,
-                TIFFStripSize(tiff));
-              if (strip_size == -1)
-                break;
-              rows_remaining=rows_per_strip;
-              if ((y+rows_per_strip) > image->rows)
-                rows_remaining=(rows_per_strip-(y+rows_per_strip-image->rows));
-              p=strip_pixels;
-              strip_id++;
-            }
-          (void) ImportQuantumPixels(image,(CacheView *) NULL,
-            quantum_info,quantum_type,p,exception);
-          p+=stride;
-          rows_remaining--;
-          if (SyncAuthenticPixels(image,exception) == MagickFalse)
-            break;
-          if (image->previous == (Image *) NULL)
-            {
-              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
-                image->rows);
-              if (status == MagickFalse)
-                break;
-            }
-        }
-        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);
-        break;
-      }
-      case ReadPlanarStripMethod:
-      {
-        register unsigned char
-          *p;
-
-        ssize_t
-          stride,
-          strip_id;
-
-        tsize_t
-          strip_size;
-
-        unsigned char
-          *strip_pixels;
-
-        /*
-          Convert tiled TIFF image to DirectClass MIFF image.
+          Convert stripped TIFF image.
         */
         strip_pixels=(unsigned char *) AcquireQuantumMemory(TIFFStripSize(tiff)+
           sizeof(uint32),sizeof(*strip_pixels));
         if (strip_pixels == (unsigned char *) NULL)
           ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
         (void) memset(strip_pixels,0,TIFFStripSize(tiff)*sizeof(*strip_pixels));
         stride=TIFFVStripSize(tiff,1);
         strip_id=0;
         for (i=0; i < (ssize_t) samples_per_pixel; i++)
         {
           size_t
             rows_remaining;
 
           switch (i)
           {
-            case 0: quantum_type=RedQuantum; break;
+            case 0: break;
             case 1: quantum_type=GreenQuantum; break;
             case 2: quantum_type=BlueQuantum; break;
             case 3:
             {
               if (image->colorspace == CMYKColorspace)
                 quantum_type=BlackQuantum;
               break;
             }
             case 4: quantum_type=AlphaQuantum; break;
           }
           rows_remaining=0;
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             register Quantum
               *magick_restrict q;
 
             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (Quantum *) NULL)
               break;
             if (rows_remaining == 0)
               {
                 strip_size=TIFFReadEncodedStrip(tiff,strip_id,strip_pixels,
                   TIFFStripSize(tiff));
                 if (strip_size == -1)
                   break;
                 rows_remaining=rows_per_strip;
                 if ((y+rows_per_strip) > image->rows)
                   rows_remaining=(rows_per_strip-(y+rows_per_strip-
                     image->rows));
                 p=strip_pixels;
                 strip_id++;
               }
             (void) ImportQuantumPixels(image,(CacheView *) NULL,
               quantum_info,quantum_type,p,exception);
             p+=stride;
             rows_remaining--;
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                   image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
-        }
-        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);
-        break;
-      }
-      case ReadRGBAStripMethod:
-      {
-        register uint32
-          *p;
-
-        /*
-          Convert stripped TIFF image to DirectClass MIFF image.
-        */
-        (void) SetImageStorageClass(image,DirectClass,exception);
-        i=0;
-        p=(uint32 *) NULL;
-        for (y=0; y < (ssize_t) image->rows; y++)
-        {
-          register ssize_t
-            x;
-
-          register Quantum
-            *magick_restrict q;
-
-          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
-          if (q == (Quantum *) NULL)
-            break;
-          if (i == 0)
-            {
-              if (TIFFReadRGBAStrip(tiff,(tstrip_t) y,(uint32 *) pixels) == 0)
-                break;
-              i=(ssize_t) MagickMin((ssize_t) rows_per_strip,(ssize_t)
-                image->rows-y);
-            }
-          i--;
-          p=((uint32 *) pixels)+image->columns*i;
-          for (x=0; x < (ssize_t) image->columns; x++)
-          {
-            SetPixelRed(image,ScaleCharToQuantum((unsigned char)
-              (TIFFGetR(*p))),q);
-            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
-              (TIFFGetG(*p))),q);
-            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
-              (TIFFGetB(*p))),q);
-            if (image->alpha_trait != UndefinedPixelTrait)
-              SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
-                (TIFFGetA(*p))),q);
-            p++;
-            q+=GetPixelChannels(image);
-          }
-          if (SyncAuthenticPixels(image,exception) == MagickFalse)
+          if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))
             break;
-          if (image->previous == (Image *) NULL)
-            {
-              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
-                image->rows);
-              if (status == MagickFalse)
-                break;
-            }
         }
+        strip_pixels=(unsigned char *) RelinquishMagickMemory(strip_pixels);
         break;
       }
       case ReadTileMethod:
       {
         register unsigned char
           *p;
 
         uint32
           columns,
           rows;
 
         unsigned char
           *tile_pixels;
 
         /*
-          Convert tiled TIFF image to DirectClass MIFF image.
-        */
-        quantum_type=IndexQuantum;
-        pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
-        if (image->alpha_trait != UndefinedPixelTrait)
-          {
-            if (image->storage_class != PseudoClass)
-              {
-                quantum_type=samples_per_pixel == 1 ? AlphaQuantum :
-                  GrayAlphaQuantum;
-                pad=(size_t) MagickMax((ssize_t) samples_per_pixel-2,0);
-              }
-            else
-              {
-                quantum_type=IndexAlphaQuantum;
-                pad=(size_t) MagickMax((ssize_t) samples_per_pixel-2,0);
-              }
-          }
-        else
-          if (image->storage_class != PseudoClass)
-            {
-              quantum_type=GrayQuantum;
-              pad=(size_t) MagickMax((ssize_t) samples_per_pixel-1,0);
-            }
-        status=SetQuantumPad(image,quantum_info,pad*pow(2,ceil(log(
-          bits_per_sample)/log(2))));
-        if (status == MagickFalse)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
-            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
-          ThrowTIFFException(CoderError,"ImageIsNotTiled");
-        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||
-            (AcquireMagickResource(HeightResource,rows) == MagickFalse))
-          ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
-        number_pixels=(MagickSizeType) columns*rows;
-        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        tile_pixels=(unsigned char *) AcquireQuantumMemory(TIFFTileSize(tiff)+
-          sizeof(uint32),sizeof(*tile_pixels));
-        if (tile_pixels == (unsigned char *) NULL)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        (void) memset(tile_pixels,0,TIFFTileSize(tiff)*sizeof(*tile_pixels));
-        for (y=0; y < (ssize_t) image->rows; y+=rows)
-        {
-          register ssize_t
-            x;
-
-          size_t
-            rows_remaining;
-
-          rows_remaining=image->rows-y;
-          if ((ssize_t) (y+rows) < (ssize_t) image->rows)
-            rows_remaining=rows;
-          for (x=0; x < (ssize_t) image->columns; x+=columns)
-          {
-            size_t
-              columns_remaining,
-              row;
-
-            columns_remaining=image->columns-x;
-            if ((ssize_t) (x+columns) < (ssize_t) image->columns)
-              columns_remaining=columns;
-            if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,0) == 0)
-              break;
-            p=tile_pixels;
-            for (row=0; row < rows_remaining; row++)
-            {
-              register Quantum
-                *magick_restrict q;
-
-              q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,exception);
-              if (q == (Quantum *) NULL)
-                break;
-              (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
-                quantum_type,p,exception);
-              p+=TIFFTileRowSize(tiff);
-              if (SyncAuthenticPixels(image,exception) == MagickFalse)
-                break;
-            }
-          }
-          if (image->previous == (Image *) NULL)
-            {
-              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
-                image->rows);
-              if (status == MagickFalse)
-                break;
-            }
-        }
-        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);
-        break;
-      }
-      case ReadContigTileMethod:
-      {
-        register unsigned char
-          *p;
-
-        uint32
-          columns,
-          rows;
-
-        unsigned char
-          *tile_pixels;
-
-        /*
-          Convert tiled TIFF image to DirectClass MIFF image.
-        */
-        pad=(size_t) MagickMax((size_t) samples_per_pixel-3,0);
-        quantum_type=RGBQuantum;
-        if (image->alpha_trait != UndefinedPixelTrait)
-          {
-            quantum_type=RGBAQuantum;
-            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
-          }
-        if (image->colorspace == CMYKColorspace)
-          {
-            pad=(size_t) MagickMax((size_t) samples_per_pixel-4,0);
-            quantum_type=CMYKQuantum;
-            if (image->alpha_trait != UndefinedPixelTrait)
-              {
-                quantum_type=CMYKAQuantum;
-                pad=(size_t) MagickMax((size_t) samples_per_pixel-5,0);
-              }
-          }
-        status=SetQuantumPad(image,quantum_info,pad*((bits_per_sample+7) >> 3));
-        if (status == MagickFalse)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
-            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
-          ThrowTIFFException(CoderError,"ImageIsNotTiled");
-        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||
-            (AcquireMagickResource(HeightResource,rows) == MagickFalse))
-          ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
-        number_pixels=(MagickSizeType) columns*rows;
-        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        tile_pixels=(unsigned char *) AcquireQuantumMemory(TIFFTileSize(tiff)+
-          sizeof(uint32),sizeof(*tile_pixels));
-        if (tile_pixels == (unsigned char *) NULL)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        (void) memset(tile_pixels,0,TIFFTileSize(tiff)*sizeof(*tile_pixels));
-        for (y=0; y < (ssize_t) image->rows; y+=rows)
-        {
-          register ssize_t
-            x;
-
-          size_t
-            rows_remaining;
-
-          rows_remaining=image->rows-y;
-          if ((ssize_t) (y+rows) < (ssize_t) image->rows)
-            rows_remaining=rows;
-          for (x=0; x < (ssize_t) image->columns; x+=columns)
-          {
-            size_t
-              columns_remaining,
-              row;
-
-            columns_remaining=image->columns-x;
-            if ((ssize_t) (x+columns) < (ssize_t) image->columns)
-              columns_remaining=columns;
-            if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,0) == 0)
-              break;
-            p=tile_pixels;
-            for (row=0; row < rows_remaining; row++)
-            {
-              register Quantum
-                *magick_restrict q;
-
-              q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,
-                exception);
-              if (q == (Quantum *) NULL)
-                break;
-              (void) ImportQuantumPixels(image,(CacheView *) NULL,
-                quantum_info,quantum_type,p,exception);
-              p+=TIFFTileRowSize(tiff);
-              if (SyncAuthenticPixels(image,exception) == MagickFalse)
-                break;
-            }
-          }
-          if (image->previous == (Image *) NULL)
-            {
-              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
-                image->rows);
-              if (status == MagickFalse)
-                break;
-            }
-        }
-        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);
-        break;
-      }
-      case ReadPlanarTileMethod:
-      {
-        register unsigned char
-          *p;
-
-        uint32
-          columns,
-          rows;
-
-        unsigned char
-          *tile_pixels;
-
-        /*
-          Convert tiled TIFF image to DirectClass MIFF image.
+          Convert tiled TIFF image.
         */
         if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
             (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
           ThrowTIFFException(CoderError,"ImageIsNotTiled");
         if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||
             (AcquireMagickResource(HeightResource,rows) == MagickFalse))
           ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
         number_pixels=(MagickSizeType) columns*rows;
         if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
           ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
         tile_pixels=(unsigned char *) AcquireQuantumMemory(TIFFTileSize(tiff)+
           sizeof(uint32),sizeof(*tile_pixels));
         if (tile_pixels == (unsigned char *) NULL)
           ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
         (void) memset(tile_pixels,0,TIFFTileSize(tiff)*sizeof(*tile_pixels));
         for (i=0; i < (ssize_t) samples_per_pixel; i++)
         {
           switch (i)
           {
-            case 0: quantum_type=RedQuantum; break;
+            case 0: break;
             case 1: quantum_type=GreenQuantum; break;
             case 2: quantum_type=BlueQuantum; break;
             case 3:
             {
               if (image->colorspace == CMYKColorspace)
                 quantum_type=BlackQuantum;
               break;
             }
             case 4: quantum_type=AlphaQuantum; break;
           }
           for (y=0; y < (ssize_t) image->rows; y+=rows)
           {
             register ssize_t
               x;
 
             size_t
               rows_remaining;
 
             rows_remaining=image->rows-y;
             if ((ssize_t) (y+rows) < (ssize_t) image->rows)
               rows_remaining=rows;
             for (x=0; x < (ssize_t) image->columns; x+=columns)
             {
               size_t
                 columns_remaining,
                 row;
 
               columns_remaining=image->columns-x;
               if ((ssize_t) (x+columns) < (ssize_t) image->columns)
                 columns_remaining=columns;
               if (TIFFReadTile(tiff,tile_pixels,(uint32) x,(uint32) y,0,i) == 0)
                 break;
               p=tile_pixels;
               for (row=0; row < rows_remaining; row++)
               {
                 register Quantum
                   *magick_restrict q;
 
                 q=GetAuthenticPixels(image,x,y+row,columns_remaining,1,
                   exception);
                 if (q == (Quantum *) NULL)
                   break;
                 (void) ImportQuantumPixels(image,(CacheView *) NULL,
                   quantum_info,quantum_type,p,exception);
                 p+=TIFFTileRowSize(tiff);
                 if (SyncAuthenticPixels(image,exception) == MagickFalse)
                   break;
               }
             }
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                   image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
-        }
-        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);
-        break;
-      }
-      case ReadRGBATileMethod:
-      {
-        register uint32
-          *p;
-
-        uint32
-          *tile_pixels,
-          columns,
-          rows;
-
-        /*
-          Convert tiled TIFF image to DirectClass MIFF image.
-        */
-        if ((TIFFGetField(tiff,TIFFTAG_TILEWIDTH,&columns) != 1) ||
-            (TIFFGetField(tiff,TIFFTAG_TILELENGTH,&rows) != 1))
-          ThrowTIFFException(CoderError,"ImageIsNotTiled");
-        if ((AcquireMagickResource(WidthResource,columns) == MagickFalse) ||
-            (AcquireMagickResource(HeightResource,rows) == MagickFalse))
-          ThrowTIFFException(ImageError,"WidthOrHeightExceedsLimit");
-        (void) SetImageStorageClass(image,DirectClass,exception);
-        number_pixels=(MagickSizeType) columns*rows;
-        if (HeapOverflowSanityCheck(rows,sizeof(*tile_pixels)) != MagickFalse)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        tile_pixels=(uint32 *) AcquireQuantumMemory(columns,rows*
-          sizeof(*tile_pixels));
-        if (tile_pixels == (uint32 *) NULL)
-          ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
-        for (y=0; y < (ssize_t) image->rows; y+=rows)
-        {
-          register ssize_t
-            x;
-
-          register Quantum
-            *magick_restrict q,
-            *magick_restrict tile;
-
-          size_t
-            columns_remaining,
-            rows_remaining;
-
-          rows_remaining=image->rows-y;
-          if ((ssize_t) (y+rows) < (ssize_t) image->rows)
-            rows_remaining=rows;
-          tile=QueueAuthenticPixels(image,0,y,image->columns,rows_remaining,
-            exception);
-          if (tile == (Quantum *) NULL)
-            break;
-          for (x=0; x < (ssize_t) image->columns; x+=columns)
-          {
-            size_t
-              column,
-              row;
-
-            if (TIFFReadRGBATile(tiff,(uint32) x,(uint32) y,tile_pixels) == 0)
-              break;
-            columns_remaining=image->columns-x;
-            if ((ssize_t) (x+columns) < (ssize_t) image->columns)
-              columns_remaining=columns;
-            p=tile_pixels+(rows-rows_remaining)*columns;
-            q=tile+GetPixelChannels(image)*(image->columns*(rows_remaining-1)+
-              x);
-            for (row=rows_remaining; row > 0; row--)
-            {
-              if (image->alpha_trait != UndefinedPixelTrait)
-                for (column=columns_remaining; column > 0; column--)
-                {
-                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)
-                    TIFFGetR(*p)),q);
-                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
-                    TIFFGetG(*p)),q);
-                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
-                    TIFFGetB(*p)),q);
-                  SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
-                    TIFFGetA(*p)),q);
-                  p++;
-                  q+=GetPixelChannels(image);
-                }
-              else
-                for (column=columns_remaining; column > 0; column--)
-                {
-                  SetPixelRed(image,ScaleCharToQuantum((unsigned char)
-                    TIFFGetR(*p)),q);
-                  SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
-                    TIFFGetG(*p)),q);
-                  SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
-                    TIFFGetB(*p)),q);
-                  p++;
-                  q+=GetPixelChannels(image);
-                }
-              p+=columns-columns_remaining;
-              q-=GetPixelChannels(image)*(image->columns+columns_remaining);
-            }
-          }
-          if (SyncAuthenticPixels(image,exception) == MagickFalse)
+          if ((samples_per_pixel > 2) && (interlace != PLANARCONFIG_SEPARATE))
             break;
-          if (image->previous == (Image *) NULL)
-            {
-              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
-                image->rows);
-              if (status == MagickFalse)
-                break;
-            }
         }
-        tile_pixels=(uint32 *) RelinquishMagickMemory(tile_pixels);
+        tile_pixels=(unsigned char *) RelinquishMagickMemory(tile_pixels);
         break;
       }
       case ReadGenericMethod:
       default:
       {
         MemoryInfo
           *generic_info = (MemoryInfo * ) NULL;
 
         register uint32
           *p;
 
         uint32
           *pixels;
 
         /*
-          Convert TIFF image to DirectClass MIFF image.
+          Convert generic TIFF image.
         */
-        (void) SetImageStorageClass(image,DirectClass,exception);
         if (HeapOverflowSanityCheck(image->rows,sizeof(*pixels)) != MagickFalse)
           ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
         number_pixels=(MagickSizeType) image->columns*image->rows;
         generic_info=AcquireVirtualMemory(number_pixels,sizeof(uint32));
         if (generic_info == (MemoryInfo *) NULL)
           ThrowTIFFException(ResourceLimitError,"MemoryAllocationFailed");
         pixels=(uint32 *) GetVirtualMemoryBlob(generic_info);
         (void) TIFFReadRGBAImage(tiff,(uint32) image->columns,(uint32)
           image->rows,(uint32 *) pixels,0);
-        /*
-          Convert image to DirectClass pixel packets.
-        */
         p=pixels+number_pixels-1;
         for (y=0; y < (ssize_t) image->rows; y++)
         {
           register ssize_t
             x;
 
           register Quantum
             *magick_restrict q;
 
           q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
           if (q == (Quantum *) NULL)
             break;
           q+=GetPixelChannels(image)*(image->columns-1);
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             SetPixelRed(image,ScaleCharToQuantum((unsigned char)
               TIFFGetR(*p)),q);
             SetPixelGreen(image,ScaleCharToQuantum((unsigned char)
               TIFFGetG(*p)),q);
             SetPixelBlue(image,ScaleCharToQuantum((unsigned char)
               TIFFGetB(*p)),q);
             if (image->alpha_trait != UndefinedPixelTrait)
               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)
                 TIFFGetA(*p)),q);
             p--;
             q-=GetPixelChannels(image);
           }
           if (SyncAuthenticPixels(image,exception) == MagickFalse)
             break;
           if (image->previous == (Image *) NULL)
             {
               status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
               if (status == MagickFalse)
                 break;
             }
         }
         generic_info=RelinquishVirtualMemory(generic_info);
         break;
       }
     }
     pixel_info=RelinquishVirtualMemory(pixel_info);
     SetQuantumImageType(image,quantum_type);
   next_tiff_frame:
     if (quantum_info != (QuantumInfo *) NULL)
       quantum_info=DestroyQuantumInfo(quantum_info);
     if (photometric == PHOTOMETRIC_CIELAB)
       DecodeLabImage(image,exception);
     if ((photometric == PHOTOMETRIC_LOGL) ||
         (photometric == PHOTOMETRIC_MINISBLACK) ||
         (photometric == PHOTOMETRIC_MINISWHITE))
       {
         image->type=GrayscaleType;
         if (bits_per_sample == 1)
           image->type=BilevelType;
       }
     /*
       Proceed to next image.
     */
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     more_frames=TIFFReadDirectory(tiff) != 0 ? MagickTrue : MagickFalse;
     if (more_frames != MagickFalse)
       {
         /*
           Allocate next image structure.
         */
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             status=MagickFalse;
             break;
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,image->scene-1,
           image->scene);
         if (status == MagickFalse)
           break;
       }
   } while ((status != MagickFalse) && (more_frames != MagickFalse));
   TIFFClose(tiff);
   TIFFReadPhotoshopLayers(image_info,image,exception);
   if ((image_info->number_scenes != 0) &&
       (image_info->scene >= GetImageListLength(image)))
     status=MagickFalse;
   if (status == MagickFalse)
     return(DestroyImageList(image));
   return(GetFirstImageInList(image));
 }
 #endif
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   R e g i s t e r T I F F I m a g e                                         %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  RegisterTIFFImage() adds properties for the TIFF image format to
 %  the list of supported formats.  The properties include the image format
 %  tag, a method to read and/or write the format, whether the format
 %  supports the saving of more than one frame to the same file or blob,
 %  whether the format supports native in-memory I/O, and a brief
 %  description of the format.
 %
 %  The format of the RegisterTIFFImage method is:
 %
 %      size_t RegisterTIFFImage(void)
 %
 */
 
 #if defined(MAGICKCORE_TIFF_DELEGATE)
 #if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)
