commit 8a3ec3ca2f4fc125ea8760a275bb7628e3324e51
Author: Andrea Reale <realeandrea@yahoo.it>
Date:   Tue Jun 20 11:40:38 2023 +0200

    updateunzip

diff --git a/code/CMakeLists.txt b/code/CMakeLists.txt
index 7cc46db90..f7aa847bc 100644
--- a/code/CMakeLists.txt
+++ b/code/CMakeLists.txt
@@ -964,12 +964,11 @@ IF(ASSIMP_HUNTER_ENABLED)
   hunter_add_package(minizip)
   find_package(minizip CONFIG REQUIRED)
 ELSE()
   SET( unzip_SRCS
-    ../contrib/unzip/crypt.c
     ../contrib/unzip/crypt.h
     ../contrib/unzip/ioapi.c
     ../contrib/unzip/ioapi.h
     ../contrib/unzip/unzip.c
     ../contrib/unzip/unzip.h
   )
   SOURCE_GROUP(Contrib\\unzip FILES ${unzip_SRCS})
diff --git a/contrib/unzip/crypt.c b/contrib/unzip/crypt.c
deleted file mode 100644
index cc6650630..000000000
--- a/contrib/unzip/crypt.c
+++ /dev/null
@@ -1,172 +0,0 @@
-/* crypt.c -- base code for traditional PKWARE encryption
-   Version 1.01e, February 12th, 2005
-
-   Copyright (C) 1998-2005 Gilles Vollant
-   Modifications for Info-ZIP crypting
-     Copyright (C) 2003 Terry Thorsen
-
-   This code is a modified version of crypting code in Info-ZIP distribution
-
-   Copyright (C) 1990-2000 Info-ZIP.  All rights reserved.
-
-   This program is distributed under the terms of the same license as zlib.
-   See the accompanying LICENSE file for the full text of the license.
-
-   This encryption code is a direct transcription of the algorithm from
-   Roger Schlafly, described by Phil Katz in the file appnote.txt. This
-   file (appnote.txt) is distributed with the PKZIP program (even in the
-   version without encryption capabilities).
-
-   If you don't need crypting in your application, just define symbols
-   NOCRYPT and NOUNCRYPT.
-*/
-
-#if defined(WIN32) || defined(_WIN32) || defined(__WIN32) && !defined(__CYGWIN__)
-    #define MICROSOFT_WINDOWS_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS 0
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <time.h>
-
-#ifdef _WIN32
-#  include <windows.h>
-#  include <wincrypt.h>
-#else
-#  include <sys/stat.h>
-#  include <fcntl.h>
-#  include <unistd.h>
-#endif
-
-#include "zlib.h"
-
-#include "crypt.h"
-
-#ifdef _MSC_VER
-#   pragma warning(push)
-#   pragma warning(disable : 4244)
-#endif // _MSC_VER
-
-/***************************************************************************/
-
-#define CRC32(c, b) ((*(pcrc_32_tab+(((uint32_t)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))
-
-#ifndef ZCR_SEED2
-#  define ZCR_SEED2 3141592654UL     /* use PI as default pattern */
-#endif
-
-/***************************************************************************/
-
-uint8_t decrypt_byte(uint32_t *pkeys)
-{
-    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
-                     * unpredictable manner on 16-bit systems; not a problem
-                     * with any known compiler so far, though */
-
-    temp = ((uint32_t)(*(pkeys+2)) & 0xffff) | 2;
-    return (uint8_t)(((temp * (temp ^ 1)) >> 8) & 0xff);
-}
-
-uint8_t update_keys(uint32_t *pkeys, const z_crc_t *pcrc_32_tab, int32_t c)
-{
-    (*(pkeys+0)) = (uint32_t)CRC32((*(pkeys+0)), c);
-    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
-    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;
-    {
-        register int32_t keyshift = (int32_t)((*(pkeys + 1)) >> 24);
-        (*(pkeys+2)) = (uint32_t)CRC32((*(pkeys+2)), keyshift);
-    }
-    return c;
-}
-
-void init_keys(const char *passwd, uint32_t *pkeys, const z_crc_t *pcrc_32_tab)
-{
-    *(pkeys+0) = 305419896L;
-    *(pkeys+1) = 591751049L;
-    *(pkeys+2) = 878082192L;
-    while (*passwd != 0)
-    {
-        update_keys(pkeys, pcrc_32_tab, *passwd);
-        passwd += 1;
-    }
-}
-
-/***************************************************************************/
-
-int cryptrand(unsigned char *buf, unsigned int len)
-{
-    static unsigned calls = 0;
-    int rlen = 0;
-#ifdef _WIN32
-    HCRYPTPROV provider;
-    unsigned __int64 pentium_tsc[1];
-    int result = 0;
-
-    #if defined(WINAPI_FAMILY) && WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP
-    if (CryptAcquireContext(&provider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
-    {
-        result = CryptGenRandom(provider, len, buf);
-        CryptReleaseContext(provider, 0);
-        if (result)
-            return len;
-    }
-    #endif
-
-    for (rlen = 0; rlen < (int)len; ++rlen)
-    {
-        if (rlen % 8 == 0)
-            QueryPerformanceCounter((LARGE_INTEGER *)pentium_tsc);
-        buf[rlen] = ((unsigned char*)pentium_tsc)[rlen % 8];
-    }
-#else
-    int frand = open("/dev/urandom", O_RDONLY);
-    if (frand != -1)
-    {
-        rlen = (int)read(frand, buf, len);
-        close(frand);
-    }
-#endif
-    if (rlen < (int)len)
-    {
-        /* Ensure different random header each time */
-        if (++calls == 1)
-            srand((unsigned)(time(NULL) ^ ZCR_SEED2));
-
-        while (rlen < (int)len)
-            buf[rlen++] = (rand() >> 7) & 0xff;
-    }
-    return rlen;
-}
-
-int crypthead(const char *passwd, uint8_t *buf, int buf_size, uint32_t *pkeys, 
-              const z_crc_t *pcrc_32_tab, uint8_t verify1, uint8_t verify2)
-{
-    uint8_t n = 0;                      /* index in random header */
-    uint8_t header[RAND_HEAD_LEN-2];    /* random header */
-    uint16_t t = 0;                     /* temporary */
-
-    if (buf_size < RAND_HEAD_LEN)
-        return 0;
-
-    init_keys(passwd, pkeys, pcrc_32_tab);
-
-    /* First generate RAND_HEAD_LEN-2 random bytes. */
-    cryptrand(header, RAND_HEAD_LEN-2);
-
-    /* Encrypt random header (last two bytes is high word of crc) */
-    init_keys(passwd, pkeys, pcrc_32_tab);
-
-    for (n = 0; n < RAND_HEAD_LEN-2; n++)
-        buf[n] = (uint8_t)zencode(pkeys, pcrc_32_tab, header[n], t);
-
-    buf[n++] = (uint8_t)zencode(pkeys, pcrc_32_tab, verify1, t);
-    buf[n++] = (uint8_t)zencode(pkeys, pcrc_32_tab, verify2, t);
-    return n;
-}
-
-#ifdef _MSC_VER
-#   pragma warning(pop)
-#endif // _MSC_VER
-
-/***************************************************************************/
diff --git a/contrib/unzip/crypt.h b/contrib/unzip/crypt.h
index 78146eb83..1cc41f19d 100644
--- a/contrib/unzip/crypt.h
+++ b/contrib/unzip/crypt.h
@@ -1,63 +1,132 @@
-/* crypt.h -- base code for traditional PKWARE encryption
+/* crypt.h -- base code for crypt/uncrypt ZIPfile
+
+
    Version 1.01e, February 12th, 2005
 
    Copyright (C) 1998-2005 Gilles Vollant
-   Modifications for Info-ZIP crypting
-     Copyright (C) 2003 Terry Thorsen
 
-   This code is a modified version of crypting code in Info-ZIP distribution
+   This code is a modified version of crypting code in Infozip distribution
 
-   Copyright (C) 1990-2000 Info-ZIP.  All rights reserved.
+   The encryption/decryption parts of this source code (as opposed to the
+   non-echoing password parts) were originally written in Europe.  The
+   whole source package can be freely distributed, including from the USA.
+   (Prior to January 2000, re-export from the US was a violation of US law.)
 
-   This program is distributed under the terms of the same license as zlib.
-   See the accompanying LICENSE file for the full text of the license.
-*/
+   This encryption code is a direct transcription of the algorithm from
+   Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
+   file (appnote.txt) is distributed with the PKZIP program (even in the
+   version without encryption capabilities).
 
-#ifndef _MINICRYPT_H
-#define _MINICRYPT_H
-
-#if ZLIB_VERNUM < 0x1270
-#if !defined(Z_U4)
-typedef unsigned long z_crc_t;
-#endif
-#endif
+   If you don't need crypting in your application, just define symbols
+   NOCRYPT and NOUNCRYPT.
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+   This code support the "Traditional PKWARE Encryption".
 
-#define RAND_HEAD_LEN  12
+   The new AES encryption added on Zip format by Winzip (see the page
+   http://www.winzip.com/aes_info.htm ) and PKWare PKZip 5.x Strong
+   Encryption is not supported.
+*/
 
-/***************************************************************************/
+#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))
 
-#define zdecode(pkeys,pcrc_32_tab,c) \
-    (update_keys(pkeys,pcrc_32_tab, c ^= decrypt_byte(pkeys)))
+/***********************************************************************
+ * Return the next byte in the pseudo-random sequence
+ */
+static int decrypt_byte(unsigned long* pkeys, const z_crc_t* pcrc_32_tab)
+{
+    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
+                     * unpredictable manner on 16-bit systems; not a problem
+                     * with any known compiler so far, though */
 
-#define zencode(pkeys,pcrc_32_tab,c,t) \
-    (t = decrypt_byte(pkeys), update_keys(pkeys,pcrc_32_tab,c), t^(c))
-
-/***************************************************************************/
+    (void)pcrc_32_tab;
+    temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;
+    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
+}
 
-/* Return the next byte in the pseudo-random sequence */
-uint8_t decrypt_byte(uint32_t *pkeys);
+/***********************************************************************
+ * Update the encryption keys with the next byte of plain text
+ */
+static int update_keys(unsigned long* pkeys,const z_crc_t* pcrc_32_tab,int c)
+{
+    (*(pkeys+0)) = CRC32((*(pkeys+0)), c);
+    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
+    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;
+    {
+      register int keyshift = (int)((*(pkeys+1)) >> 24);
+      (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);
+    }
+    return c;
+}
 
-/* Update the encryption keys with the next byte of plain text */
-uint8_t update_keys(uint32_t *pkeys, const z_crc_t *pcrc_32_tab, int32_t c);
 
-/* Initialize the encryption keys and the random header according to the given password. */
-void init_keys(const char *passwd, uint32_t *pkeys, const z_crc_t *pcrc_32_tab);
+/***********************************************************************
+ * Initialize the encryption keys and the random header according to
+ * the given password.
+ */
+static void init_keys(const char* passwd,unsigned long* pkeys,const z_crc_t* pcrc_32_tab)
+{
+    *(pkeys+0) = 305419896L;
+    *(pkeys+1) = 591751049L;
+    *(pkeys+2) = 878082192L;
+    while (*passwd != '\0') {
+        update_keys(pkeys,pcrc_32_tab,(int)*passwd);
+        passwd++;
+    }
+}
 
-/* Generate cryptographically secure random numbers */
-int cryptrand(unsigned char *buf, unsigned int len);
+#define zdecode(pkeys,pcrc_32_tab,c) \
+    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys,pcrc_32_tab)))
 
-/* Create encryption header */
-int crypthead(const char *passwd, uint8_t *buf, int buf_size, uint32_t *pkeys, 
-    const z_crc_t *pcrc_32_tab, uint8_t verify1, uint8_t verify2);
+#define zencode(pkeys,pcrc_32_tab,c,t) \
+    (t=decrypt_byte(pkeys,pcrc_32_tab), update_keys(pkeys,pcrc_32_tab,c), (Byte)t^(c))
 
-/***************************************************************************/
+#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED
 
-#ifdef __cplusplus
+#define RAND_HEAD_LEN  12
+   /* "last resort" source for second part of crypt seed pattern */
+#  ifndef ZCR_SEED2
+#    define ZCR_SEED2 3141592654UL      /* use PI as default pattern */
+#  endif
+
+static unsigned crypthead(const char* passwd,       /* password string */
+                          unsigned char* buf,       /* where to write header */
+                          int bufSize,
+                          unsigned long* pkeys,
+                          const z_crc_t* pcrc_32_tab,
+                          unsigned long crcForCrypting)
+{
+    unsigned n;                  /* index in random header */
+    int t;                       /* temporary */
+    int c;                       /* random byte */
+    unsigned char header[RAND_HEAD_LEN-2]; /* random header */
+    static unsigned calls = 0;   /* ensure different random header each time */
+
+    if (bufSize<RAND_HEAD_LEN)
+      return 0;
+
+    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
+     * output of rand() to get less predictability, since rand() is
+     * often poorly implemented.
+     */
+    if (++calls == 1)
+    {
+        srand((unsigned)(time(NULL) ^ ZCR_SEED2));
+    }
+    init_keys(passwd, pkeys, pcrc_32_tab);
+    for (n = 0; n < RAND_HEAD_LEN-2; n++)
+    {
+        c = (rand() >> 7) & 0xff;
+        header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);
+    }
+    /* Encrypt random header (last two bytes is high word of crc) */
+    init_keys(passwd, pkeys, pcrc_32_tab);
+    for (n = 0; n < RAND_HEAD_LEN-2; n++)
+    {
+        buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);
+    }
+    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);
+    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);
+    return n;
 }
-#endif
 
 #endif
diff --git a/contrib/unzip/ioapi.c b/contrib/unzip/ioapi.c
index d9ae01e7d..814a6fd38 100644
--- a/contrib/unzip/ioapi.c
+++ b/contrib/unzip/ioapi.c
@@ -1,367 +1,257 @@
-/* ioapi.c -- IO base function header for compress/uncompress .zip
-   part of the MiniZip project
+/* ioapi.h -- IO base function header for compress/uncompress .zip
+   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
 
-   Copyright (C) 1998-2010 Gilles Vollant
-     http://www.winimage.com/zLibDll/minizip.html
-   Modifications for Zip64 support
-     Copyright (C) 2009-2010 Mathias Svensson
-     http://result42.com
+         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
 
-   This program is distributed under the terms of the same license as zlib.
-   See the accompanying LICENSE file for the full text of the license.
-*/
+         Modifications for Zip64 support
+         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
 
-#include <stdlib.h>
-#include <string.h>
+         For more info read MiniZip_info.txt
 
-#if defined unix || defined __APPLE__
-#include <sys/types.h>
-#include <unistd.h>
-#endif
+*/
 
-#include "ioapi.h"
+#if defined(_WIN32) && (!(defined(_CRT_SECURE_NO_WARNINGS)))
+        #define _CRT_SECURE_NO_WARNINGS
+#endif
 
-#ifdef _WIN32
-#   define snprintf _snprintf
-#ifdef _MSC_VER
-#   pragma warning(push)
-#   pragma warning(disable : 4131 4100)
+#if defined(__APPLE__) || defined(IOAPI_NO_64)
+// In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions
+#define FOPEN_FUNC(filename, mode) fopen(filename, mode)
+#define FTELLO_FUNC(stream) ftello(stream)
+#define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
+#else
+#define FOPEN_FUNC(filename, mode) fopen64(filename, mode)
+#define FTELLO_FUNC(stream) ftello64(stream)
+#define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)
 #endif
-#   ifdef __clang__
-#       pragma clang diagnostic push
-#       pragma clang diagnostic ignored "-Wunused-parameter"
-#   endif
-#endif // _WIN32
 
 
-voidpf call_zopen64(const zlib_filefunc64_32_def *pfilefunc, const void *filename, int mode)
-{
-    if (pfilefunc->zfile_func64.zopen64_file != NULL)
-        return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque, filename, mode);
-    return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque, (const char*)filename, mode);
-}
+#include "ioapi.h"
 
-voidpf call_zopendisk64(const zlib_filefunc64_32_def *pfilefunc, voidpf filestream, uint32_t number_disk, int mode)
+voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode)
 {
-    if (pfilefunc->zfile_func64.zopendisk64_file != NULL)
-        return (*(pfilefunc->zfile_func64.zopendisk64_file)) (pfilefunc->zfile_func64.opaque, filestream, number_disk, mode);
-    return (*(pfilefunc->zopendisk32_file))(pfilefunc->zfile_func64.opaque, filestream, number_disk, mode);
+    if (pfilefunc->zfile_func64.zopen64_file != NULL)
+        return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque,filename,mode);
+    else
+    {
+        return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque,(const char*)filename,mode);
+    }
 }
 
-long call_zseek64(const zlib_filefunc64_32_def *pfilefunc, voidpf filestream, uint64_t offset, int origin)
+long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin)
 {
-    uint32_t offset_truncated = 0;
     if (pfilefunc->zfile_func64.zseek64_file != NULL)
         return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque,filestream,offset,origin);
-    offset_truncated = (uint32_t)offset;
-    if (offset_truncated != offset)
-        return -1;
-    return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque,filestream, offset_truncated, origin);
+    else
+    {
+        uLong offsetTruncated = (uLong)offset;
+        if (offsetTruncated != offset)
+            return -1;
+        else
+            return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque,filestream,offsetTruncated,origin);
+    }
 }
 
-uint64_t call_ztell64(const zlib_filefunc64_32_def *pfilefunc, voidpf filestream)
+ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream)
 {
-    uint64_t position;
     if (pfilefunc->zfile_func64.zseek64_file != NULL)
-        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque, filestream);
-    position = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque, filestream);
-    if ((position) == UINT32_MAX)
-        return (uint64_t)-1;
-    return position;
+        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);
+    else
+    {
+        uLong tell_uLong = (uLong)(*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);
+        if ((tell_uLong) == MAXU32)
+            return (ZPOS64_T)-1;
+        else
+            return tell_uLong;
+    }
 }
 
-void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def *p_filefunc64_32, const zlib_filefunc_def *p_filefunc32)
+void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32)
 {
     p_filefunc64_32->zfile_func64.zopen64_file = NULL;
-    p_filefunc64_32->zfile_func64.zopendisk64_file = NULL;
     p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;
-    p_filefunc64_32->zopendisk32_file = p_filefunc32->zopendisk_file;
     p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
     p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;
     p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;
     p_filefunc64_32->zfile_func64.ztell64_file = NULL;
     p_filefunc64_32->zfile_func64.zseek64_file = NULL;
     p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;
     p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
     p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;
     p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;
     p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;
 }
 
-static voidpf   ZCALLBACK fopen_file_func(voidpf opaque, const char *filename, int mode);
-static uint32_t ZCALLBACK fread_file_func(voidpf opaque, voidpf stream, void* buf, uint32_t size);
-static uint32_t ZCALLBACK fwrite_file_func(voidpf opaque, voidpf stream, const void *buf, uint32_t size);
-static uint64_t ZCALLBACK ftell64_file_func(voidpf opaque, voidpf stream);
-static long     ZCALLBACK fseek64_file_func(voidpf opaque, voidpf stream, uint64_t offset, int origin);
-static int      ZCALLBACK fclose_file_func(voidpf opaque, voidpf stream);
-static int      ZCALLBACK ferror_file_func(voidpf opaque, voidpf stream);
 
-typedef struct
-{
-    FILE *file;
-    int filenameLength;
-    void *filename;
-} FILE_IOPOSIX;
 
-static voidpf file_build_ioposix(FILE *file, const char *filename)
-{
-    FILE_IOPOSIX *ioposix = NULL;
-    if (file == NULL)
-        return NULL;
-    ioposix = (FILE_IOPOSIX*)malloc(sizeof(FILE_IOPOSIX));
-    ioposix->file = file;
-    ioposix->filenameLength = (int)strlen(filename) + 1;
-    ioposix->filename = (char*)malloc(ioposix->filenameLength * sizeof(char));
-    memcpy((char*)ioposix->filename, filename, ioposix->filenameLength);
-    return (voidpf)ioposix;
-}
+static voidpf  ZCALLBACK fopen_file_func OF((voidpf opaque, const char* filename, int mode));
+static uLong   ZCALLBACK fread_file_func OF((voidpf opaque, voidpf stream, void* buf, uLong size));
+static uLong   ZCALLBACK fwrite_file_func OF((voidpf opaque, voidpf stream, const void* buf,uLong size));
+static ZPOS64_T ZCALLBACK ftell64_file_func OF((voidpf opaque, voidpf stream));
+static long    ZCALLBACK fseek64_file_func OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
+static int     ZCALLBACK fclose_file_func OF((voidpf opaque, voidpf stream));
+static int     ZCALLBACK ferror_file_func OF((voidpf opaque, voidpf stream));
 
-static voidpf ZCALLBACK fopen_file_func(voidpf opaque, const char *filename, int mode)
+static voidpf ZCALLBACK fopen_file_func (voidpf opaque, const char* filename, int mode)
 {
     FILE* file = NULL;
-    const char *mode_fopen = NULL;
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER) == ZLIB_FILEFUNC_MODE_READ)
+    const char* mode_fopen = NULL;
+    (void)opaque;
+    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
         mode_fopen = "rb";
-    else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
+    else
+    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
         mode_fopen = "r+b";
-    else if (mode & ZLIB_FILEFUNC_MODE_CREATE)
+    else
+    if (mode & ZLIB_FILEFUNC_MODE_CREATE)
         mode_fopen = "wb";
 
-    if ((filename != NULL) && (mode_fopen != NULL))
-    {
+    if ((filename!=NULL) && (mode_fopen != NULL))
         file = fopen(filename, mode_fopen);
-        return file_build_ioposix(file, filename);
-    }
     return file;
 }
 
-static voidpf ZCALLBACK fopen64_file_func(voidpf opaque, const void *filename, int mode)
+static voidpf ZCALLBACK fopen64_file_func (voidpf opaque, const void* filename, int mode)
 {
     FILE* file = NULL;
-    const char *mode_fopen = NULL;
-    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER) == ZLIB_FILEFUNC_MODE_READ)
+    const char* mode_fopen = NULL;
+    (void)opaque;
+    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER)==ZLIB_FILEFUNC_MODE_READ)
         mode_fopen = "rb";
-    else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
+    else
+    if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
         mode_fopen = "r+b";
-    else if (mode & ZLIB_FILEFUNC_MODE_CREATE)
+    else
+    if (mode & ZLIB_FILEFUNC_MODE_CREATE)
         mode_fopen = "wb";
 
-    if ((filename != NULL) && (mode_fopen != NULL))
-    {
-        file = fopen64((const char*)filename, mode_fopen);
-        return file_build_ioposix(file, (const char*)filename);
-    }
+    if ((filename!=NULL) && (mode_fopen != NULL))
+        file = FOPEN_FUNC((const char*)filename, mode_fopen);
     return file;
 }
 
-static voidpf ZCALLBACK fopendisk64_file_func(voidpf opaque, voidpf stream, uint32_t number_disk, int mode)
-{
-    FILE_IOPOSIX *ioposix = NULL;
-    char *diskFilename = NULL;
-    voidpf ret = NULL;
-    int i = 0;
-
-    if (stream == NULL)
-        return NULL;
-    ioposix = (FILE_IOPOSIX*)stream;
-    diskFilename = (char*)malloc(ioposix->filenameLength * sizeof(char));
-    strncpy(diskFilename, (const char*)ioposix->filename, ioposix->filenameLength);
-    for (i = ioposix->filenameLength - 1; i >= 0; i -= 1)
-    {
-        if (diskFilename[i] != '.')
-            continue;
-        snprintf(&diskFilename[i], ioposix->filenameLength - i, ".z%02u", number_disk + 1);
-        break;
-    }
-    if (i >= 0)
-        ret = fopen64_file_func(opaque, diskFilename, mode);
-    free(diskFilename);
-    return ret;
-}
 
-static voidpf ZCALLBACK fopendisk_file_func(voidpf opaque, voidpf stream, uint32_t number_disk, int mode)
+static uLong ZCALLBACK fread_file_func (voidpf opaque, voidpf stream, void* buf, uLong size)
 {
-    FILE_IOPOSIX *ioposix = NULL;
-    char *diskFilename = NULL;
-    voidpf ret = NULL;
-    int i = 0;
-
-    if (stream == NULL)
-        return NULL;
-    ioposix = (FILE_IOPOSIX*)stream;
-    diskFilename = (char*)malloc(ioposix->filenameLength * sizeof(char));
-    strncpy(diskFilename, (const char*)ioposix->filename, ioposix->filenameLength);
-    for (i = ioposix->filenameLength - 1; i >= 0; i -= 1)
-    {
-        if (diskFilename[i] != '.')
-            continue;
-        snprintf(&diskFilename[i], ioposix->filenameLength - i, ".z%02u", number_disk + 1);
-        break;
-    }
-    if (i >= 0)
-        ret = fopen_file_func(opaque, diskFilename, mode);
-    free(diskFilename);
+    uLong ret;
+    (void)opaque;
+    ret = (uLong)fread(buf, 1, (size_t)size, (FILE *)stream);
     return ret;
 }
 
-static uint32_t ZCALLBACK fread_file_func(voidpf opaque, voidpf stream, void* buf, uint32_t size)
+static uLong ZCALLBACK fwrite_file_func (voidpf opaque, voidpf stream, const void* buf, uLong size)
 {
-    FILE_IOPOSIX *ioposix = NULL;
-    uint32_t read = (uint32_t)-1;
-    if (stream == NULL)
-        return read;
-    ioposix = (FILE_IOPOSIX*)stream;
-    read = (uint32_t)fread(buf, 1, (size_t)size, ioposix->file);
-    return read;
-}
-
-static uint32_t ZCALLBACK fwrite_file_func(voidpf opaque, voidpf stream, const void *buf, uint32_t size)
-{
-    FILE_IOPOSIX *ioposix = NULL;
-    uint32_t written = (uint32_t)-1;
-    if (stream == NULL)
-        return written;
-    ioposix = (FILE_IOPOSIX*)stream;
-    written = (uint32_t)fwrite(buf, 1, (size_t)size, ioposix->file);
-    return written;
+    uLong ret;
+    (void)opaque;
+    ret = (uLong)fwrite(buf, 1, (size_t)size, (FILE *)stream);
+    return ret;
 }
 
-static long ZCALLBACK ftell_file_func(voidpf opaque, voidpf stream)
+static long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)
 {
-    FILE_IOPOSIX *ioposix = NULL;
-    long ret = -1;
-    if (stream == NULL)
-        return ret;
-    ioposix = (FILE_IOPOSIX*)stream;
-    ret = ftell(ioposix->file);
+    long ret;
+    (void)opaque;
+    ret = ftell((FILE *)stream);
     return ret;
 }
 
-static uint64_t ZCALLBACK ftell64_file_func(voidpf opaque, voidpf stream)
+
+static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)
 {
-    FILE_IOPOSIX *ioposix = NULL;
-    uint64_t ret = (uint64_t)-1;
-    if (stream == NULL)
-        return ret;
-    ioposix = (FILE_IOPOSIX*)stream;
-    ret = ftello64(ioposix->file);
+    ZPOS64_T ret;
+    (void)opaque;
+    ret = (ZPOS64_T)FTELLO_FUNC((FILE *)stream);
     return ret;
 }
 
-static long ZCALLBACK fseek_file_func(voidpf opaque, voidpf stream, uint32_t offset, int origin)
+static long ZCALLBACK fseek_file_func (voidpf  opaque, voidpf stream, uLong offset, int origin)
 {
-    FILE_IOPOSIX *ioposix = NULL;
-    int fseek_origin = 0;
-    long ret = 0;
-
-    if (stream == NULL)
-        return -1;
-    ioposix = (FILE_IOPOSIX*)stream;
-
+    int fseek_origin=0;
+    long ret;
+    (void)opaque;
     switch (origin)
     {
-        case ZLIB_FILEFUNC_SEEK_CUR:
-            fseek_origin = SEEK_CUR;
-            break;
-        case ZLIB_FILEFUNC_SEEK_END:
-            fseek_origin = SEEK_END;
-            break;
-        case ZLIB_FILEFUNC_SEEK_SET:
-            fseek_origin = SEEK_SET;
-            break;
-        default:
-            return -1;
+    case ZLIB_FILEFUNC_SEEK_CUR :
+        fseek_origin = SEEK_CUR;
+        break;
+    case ZLIB_FILEFUNC_SEEK_END :
+        fseek_origin = SEEK_END;
+        break;
+    case ZLIB_FILEFUNC_SEEK_SET :
+        fseek_origin = SEEK_SET;
+        break;
+    default: return -1;
     }
-    if (fseek(ioposix->file, offset, fseek_origin) != 0)
+    ret = 0;
+    if (fseek((FILE *)stream, (long)offset, fseek_origin) != 0)
         ret = -1;
     return ret;
 }
 
-static long ZCALLBACK fseek64_file_func(voidpf opaque, voidpf stream, uint64_t offset, int origin)
+static long ZCALLBACK fseek64_file_func (voidpf  opaque, voidpf stream, ZPOS64_T offset, int origin)
 {
-    FILE_IOPOSIX *ioposix = NULL;
-    int fseek_origin = 0;
-    long ret = 0;
-
-    if (stream == NULL)
-        return -1;
-    ioposix = (FILE_IOPOSIX*)stream;
-
+    int fseek_origin=0;
+    long ret;
+    (void)opaque;
     switch (origin)
     {
-        case ZLIB_FILEFUNC_SEEK_CUR:
-            fseek_origin = SEEK_CUR;
-            break;
-        case ZLIB_FILEFUNC_SEEK_END:
-            fseek_origin = SEEK_END;
-            break;
-        case ZLIB_FILEFUNC_SEEK_SET:
-            fseek_origin = SEEK_SET;
-            break;
-        default:
-            return -1;
+    case ZLIB_FILEFUNC_SEEK_CUR :
+        fseek_origin = SEEK_CUR;
+        break;
+    case ZLIB_FILEFUNC_SEEK_END :
+        fseek_origin = SEEK_END;
+        break;
+    case ZLIB_FILEFUNC_SEEK_SET :
+        fseek_origin = SEEK_SET;
+        break;
+    default: return -1;
     }
+    ret = 0;
 
-    if (fseeko64(ioposix->file, offset, fseek_origin) != 0)
-        ret = -1;
+    if(FSEEKO_FUNC((FILE *)stream, (z_off_t)offset, fseek_origin) != 0)
+                        ret = -1;
 
     return ret;
 }
 
-static int ZCALLBACK fclose_file_func(voidpf opaque, voidpf stream)
+
+static int ZCALLBACK fclose_file_func (voidpf opaque, voidpf stream)
 {
-    FILE_IOPOSIX *ioposix = NULL;
-    int ret = -1;
-    if (stream == NULL)
-        return ret;
-    ioposix = (FILE_IOPOSIX*)stream;
-    if (ioposix->filename != NULL)
-        free(ioposix->filename);
-    ret = fclose(ioposix->file);
-    free(ioposix);
+    int ret;
+    (void)opaque;
+    ret = fclose((FILE *)stream);
     return ret;
 }
 
-static int ZCALLBACK ferror_file_func(voidpf opaque, voidpf stream)
+static int ZCALLBACK ferror_file_func (voidpf opaque, voidpf stream)
 {
-    FILE_IOPOSIX *ioposix = NULL;
-    int ret = -1;
-    if (stream == NULL)
-        return ret;
-    ioposix = (FILE_IOPOSIX*)stream;
-    ret = ferror(ioposix->file);
+    int ret;
+    (void)opaque;
+    ret = ferror((FILE *)stream);
     return ret;
 }
 
-void fill_fopen_filefunc(zlib_filefunc_def *pzlib_filefunc_def)
+void fill_fopen_filefunc (pzlib_filefunc_def)
+  zlib_filefunc_def* pzlib_filefunc_def;
 {
     pzlib_filefunc_def->zopen_file = fopen_file_func;
-    pzlib_filefunc_def->zopendisk_file = fopendisk_file_func;
     pzlib_filefunc_def->zread_file = fread_file_func;
     pzlib_filefunc_def->zwrite_file = fwrite_file_func;
     pzlib_filefunc_def->ztell_file = ftell_file_func;
     pzlib_filefunc_def->zseek_file = fseek_file_func;
     pzlib_filefunc_def->zclose_file = fclose_file_func;
     pzlib_filefunc_def->zerror_file = ferror_file_func;
     pzlib_filefunc_def->opaque = NULL;
 }
 
-void fill_fopen64_filefunc(zlib_filefunc64_def *pzlib_filefunc_def)
+void fill_fopen64_filefunc (zlib_filefunc64_def*  pzlib_filefunc_def)
 {
     pzlib_filefunc_def->zopen64_file = fopen64_file_func;
-    pzlib_filefunc_def->zopendisk64_file = fopendisk64_file_func;
     pzlib_filefunc_def->zread_file = fread_file_func;
     pzlib_filefunc_def->zwrite_file = fwrite_file_func;
     pzlib_filefunc_def->ztell64_file = ftell64_file_func;
     pzlib_filefunc_def->zseek64_file = fseek64_file_func;
     pzlib_filefunc_def->zclose_file = fclose_file_func;
     pzlib_filefunc_def->zerror_file = ferror_file_func;
     pzlib_filefunc_def->opaque = NULL;
 }
-
-#ifdef _MSC_VER
-#   pragma warning(pop)
-#   ifdef __clang__
-#       pragma clang diagnostic pop
-#   endif
-#endif // _MSC_VER
diff --git a/contrib/unzip/ioapi.h b/contrib/unzip/ioapi.h
index 0e49543e5..ae9ca7e83 100644
--- a/contrib/unzip/ioapi.h
+++ b/contrib/unzip/ioapi.h
@@ -1,145 +1,210 @@
 /* ioapi.h -- IO base function header for compress/uncompress .zip
-   part of the MiniZip project
+   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
 
-   Copyright (C) 1998-2010 Gilles Vollant
-     http://www.winimage.com/zLibDll/minizip.html
-   Modifications for Zip64 support
-     Copyright (C) 2009-2010 Mathias Svensson
-     http://result42.com
+         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Modifications for Zip64 support
+         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+
+         For more info read MiniZip_info.txt
+
+         Changes
+
+    Oct-2009 - Defined ZPOS64_T to fpos_t on windows and u_int64_t on linux. (might need to find a better why for this)
+    Oct-2009 - Change to fseeko64, ftello64 and fopen64 so large files would work on linux.
+               More if/def section may be needed to support other platforms
+    Oct-2009 - Defined fxxxx64 calls to normal fopen/ftell/fseek so they would compile on windows.
+                          (but you should use iowin32.c for windows instead)
 
-   This program is distributed under the terms of the same license as zlib.
-   See the accompanying LICENSE file for the full text of the license.
 */
 
 #ifndef _ZLIBIOAPI64_H
 #define _ZLIBIOAPI64_H
 
+#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
+
+  // Linux needs this to support file operation on files larger then 4+GB
+  // But might need better if/def to select just the platforms that needs them.
+
+        #ifndef __USE_FILE_OFFSET64
+                #define __USE_FILE_OFFSET64
+        #endif
+        #ifndef __USE_LARGEFILE64
+                #define __USE_LARGEFILE64
+        #endif
+        #ifndef _LARGEFILE64_SOURCE
+                #define _LARGEFILE64_SOURCE
+        #endif
+        #ifndef _FILE_OFFSET_BIT
+                #define _FILE_OFFSET_BIT 64
+        #endif
+
+#endif
+
 #include <stdio.h>
 #include <stdlib.h>
-#include <stdint.h>
-
 #include "zlib.h"
 
 #if defined(USE_FILE32API)
-#   define fopen64 fopen
-#   define ftello64 ftell
-#   define fseeko64 fseek
+#define fopen64 fopen
+#define ftello64 ftell
+#define fseeko64 fseek
+#else
+#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__)
+#define fopen64 fopen
+#define ftello64 ftello
+#define fseeko64 fseeko
+#endif
+#ifdef _MSC_VER
+ #define fopen64 fopen
+ #if (_MSC_VER >= 1400) && (!(defined(NO_MSCVER_FILE64_FUNC)))
+  #define ftello64 _ftelli64
+  #define fseeko64 _fseeki64
+ #else // old MSC
+  #define ftello64 ftell
+  #define fseeko64 fseek
+ #endif
+#endif
+#endif
+
+/*
+#ifndef ZPOS64_T
+  #ifdef _WIN32
+                #define ZPOS64_T fpos_t
+  #else
+    #include <stdint.h>
+    #define ZPOS64_T uint64_t
+  #endif
+#endif
+*/
+
+#ifdef HAVE_MINIZIP64_CONF_H
+#include "mz64conf.h"
+#endif
+
+/* a type choosen by DEFINE */
+#ifdef HAVE_64BIT_INT_CUSTOM
+typedef  64BIT_INT_CUSTOM_TYPE ZPOS64_T;
 #else
-#if defined(_MSC_VER)
-#   define fopen64 fopen
-#   if (_MSC_VER >= 1400) && (!(defined(NO_MSCVER_FILE64_FUNC)))
-#       define ftello64 _ftelli64
-#       define fseeko64 _fseeki64
-#   else /* old MSC */
-#       define ftello64 ftell
-#       define fseeko64 fseek
-#   endif
+#ifdef HAS_STDINT_H
+#include "stdint.h"
+typedef uint64_t ZPOS64_T;
 #else
-#   define fopen64 fopen
-#   define ftello64 ftello
-#   define fseeko64 fseeko
+
+
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+typedef unsigned __int64 ZPOS64_T;
+#else
+typedef unsigned long long int ZPOS64_T;
+#endif
 #endif
 #endif
 
+/* Maximum unsigned 32-bit value used as placeholder for zip64 */
+#ifndef MAXU32
+#define MAXU32 (0xffffffff)
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+
 #define ZLIB_FILEFUNC_SEEK_CUR (1)
 #define ZLIB_FILEFUNC_SEEK_END (2)
 #define ZLIB_FILEFUNC_SEEK_SET (0)
 
-#define ZLIB_FILEFUNC_MODE_READ             (1)
-#define ZLIB_FILEFUNC_MODE_WRITE            (2)
-#define ZLIB_FILEFUNC_MODE_READWRITEFILTER  (3)
-#define ZLIB_FILEFUNC_MODE_EXISTING         (4)
-#define ZLIB_FILEFUNC_MODE_CREATE           (8)
+#define ZLIB_FILEFUNC_MODE_READ      (1)
+#define ZLIB_FILEFUNC_MODE_WRITE     (2)
+#define ZLIB_FILEFUNC_MODE_READWRITEFILTER (3)
+
+#define ZLIB_FILEFUNC_MODE_EXISTING (4)
+#define ZLIB_FILEFUNC_MODE_CREATE   (8)
+
 
 #ifndef ZCALLBACK
-#  if (defined(WIN32) || defined(_WIN32) || defined (WINDOWS) || \
-       defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)
-#    define ZCALLBACK CALLBACK
-#  else
-#    define ZCALLBACK
-#  endif
+ #if (defined(WIN32) || defined(_WIN32) || defined (WINDOWS) || defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)
+   #define ZCALLBACK CALLBACK
+ #else
+   #define ZCALLBACK
+ #endif
 #endif
 
-typedef voidpf   (ZCALLBACK *open_file_func)     (voidpf opaque, const char *filename, int mode);
-typedef voidpf   (ZCALLBACK *opendisk_file_func) (voidpf opaque, voidpf stream, uint32_t number_disk, int mode);
-typedef uint32_t (ZCALLBACK *read_file_func)     (voidpf opaque, voidpf stream, void* buf, uint32_t size);
-typedef uint32_t (ZCALLBACK *write_file_func)    (voidpf opaque, voidpf stream, const void *buf, uint32_t size);
-typedef int      (ZCALLBACK *close_file_func)    (voidpf opaque, voidpf stream);
-typedef int      (ZCALLBACK *error_file_func)    (voidpf opaque, voidpf stream);
 
-typedef long     (ZCALLBACK *tell_file_func)     (voidpf opaque, voidpf stream);
-typedef long     (ZCALLBACK *seek_file_func)     (voidpf opaque, voidpf stream, uint32_t offset, int origin);
+
+
+typedef voidpf   (ZCALLBACK *open_file_func)      OF((voidpf opaque, const char* filename, int mode));
+typedef uLong    (ZCALLBACK *read_file_func)      OF((voidpf opaque, voidpf stream, void* buf, uLong size));
+typedef uLong    (ZCALLBACK *write_file_func)     OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
+typedef int      (ZCALLBACK *close_file_func)     OF((voidpf opaque, voidpf stream));
+typedef int      (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
+
+typedef long     (ZCALLBACK *tell_file_func)      OF((voidpf opaque, voidpf stream));
+typedef long     (ZCALLBACK *seek_file_func)      OF((voidpf opaque, voidpf stream, uLong offset, int origin));
+
 
 /* here is the "old" 32 bits structure structure */
 typedef struct zlib_filefunc_def_s
 {
     open_file_func      zopen_file;
-    opendisk_file_func  zopendisk_file;
     read_file_func      zread_file;
     write_file_func     zwrite_file;
     tell_file_func      ztell_file;
     seek_file_func      zseek_file;
     close_file_func     zclose_file;
-    error_file_func     zerror_file;
+    testerror_file_func zerror_file;
     voidpf              opaque;
 } zlib_filefunc_def;
 
-typedef uint64_t (ZCALLBACK *tell64_file_func)    (voidpf opaque, voidpf stream);
-typedef long     (ZCALLBACK *seek64_file_func)    (voidpf opaque, voidpf stream, uint64_t offset, int origin);
-typedef voidpf   (ZCALLBACK *open64_file_func)    (voidpf opaque, const void *filename, int mode);
-typedef voidpf   (ZCALLBACK *opendisk64_file_func)(voidpf opaque, voidpf stream, uint32_t number_disk, int mode);
+typedef ZPOS64_T (ZCALLBACK *tell64_file_func)    OF((voidpf opaque, voidpf stream));
+typedef long     (ZCALLBACK *seek64_file_func)    OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
+typedef voidpf   (ZCALLBACK *open64_file_func)    OF((voidpf opaque, const void* filename, int mode));
 
 typedef struct zlib_filefunc64_def_s
 {
-    open64_file_func     zopen64_file;
-    opendisk64_file_func zopendisk64_file;
-    read_file_func       zread_file;
-    write_file_func      zwrite_file;
-    tell64_file_func     ztell64_file;
-    seek64_file_func     zseek64_file;
-    close_file_func      zclose_file;
-    error_file_func      zerror_file;
-    voidpf               opaque;
+    open64_file_func    zopen64_file;
+    read_file_func      zread_file;
+    write_file_func     zwrite_file;
+    tell64_file_func    ztell64_file;
+    seek64_file_func    zseek64_file;
+    close_file_func     zclose_file;
+    testerror_file_func zerror_file;
+    voidpf              opaque;
 } zlib_filefunc64_def;
 
-void fill_fopen_filefunc(zlib_filefunc_def *pzlib_filefunc_def);
-void fill_fopen64_filefunc(zlib_filefunc64_def *pzlib_filefunc_def);
+void fill_fopen64_filefunc OF((zlib_filefunc64_def* pzlib_filefunc_def));
+void fill_fopen_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
 
 /* now internal definition, only for zip.c and unzip.h */
 typedef struct zlib_filefunc64_32_def_s
 {
     zlib_filefunc64_def zfile_func64;
     open_file_func      zopen32_file;
-    opendisk_file_func  zopendisk32_file;
     tell_file_func      ztell32_file;
     seek_file_func      zseek32_file;
 } zlib_filefunc64_32_def;
 
-#define ZREAD64(filefunc,filestream,buf,size)       ((*((filefunc).zfile_func64.zread_file))        ((filefunc).zfile_func64.opaque,filestream,buf,size))
-#define ZWRITE64(filefunc,filestream,buf,size)      ((*((filefunc).zfile_func64.zwrite_file))       ((filefunc).zfile_func64.opaque,filestream,buf,size))
-/*#define ZTELL64(filefunc,filestream)                ((*((filefunc).ztell64_file))                   ((filefunc).opaque,filestream))*/
-/*#define ZSEEK64(filefunc,filestream,pos,mode)       ((*((filefunc).zseek64_file))                   ((filefunc).opaque,filestream,pos,mode))*/
-#define ZCLOSE64(filefunc,filestream)               ((*((filefunc).zfile_func64.zclose_file))       ((filefunc).zfile_func64.opaque,filestream))
-#define ZERROR64(filefunc,filestream)               ((*((filefunc).zfile_func64.zerror_file))       ((filefunc).zfile_func64.opaque,filestream))
 
-voidpf   call_zopen64(const zlib_filefunc64_32_def *pfilefunc,const void*filename, int mode);
-voidpf   call_zopendisk64(const zlib_filefunc64_32_def *pfilefunc, voidpf filestream, uint32_t number_disk, int mode);
-long     call_zseek64(const zlib_filefunc64_32_def *pfilefunc, voidpf filestream, uint64_t offset, int origin);
-uint64_t call_ztell64(const zlib_filefunc64_32_def *pfilefunc, voidpf filestream);
+#define ZREAD64(filefunc,filestream,buf,size)     ((*((filefunc).zfile_func64.zread_file))   ((filefunc).zfile_func64.opaque,filestream,buf,size))
+#define ZWRITE64(filefunc,filestream,buf,size)    ((*((filefunc).zfile_func64.zwrite_file))  ((filefunc).zfile_func64.opaque,filestream,buf,size))
+//#define ZTELL64(filefunc,filestream)            ((*((filefunc).ztell64_file)) ((filefunc).opaque,filestream))
+//#define ZSEEK64(filefunc,filestream,pos,mode)   ((*((filefunc).zseek64_file)) ((filefunc).opaque,filestream,pos,mode))
+#define ZCLOSE64(filefunc,filestream)             ((*((filefunc).zfile_func64.zclose_file))  ((filefunc).zfile_func64.opaque,filestream))
+#define ZERROR64(filefunc,filestream)             ((*((filefunc).zfile_func64.zerror_file))  ((filefunc).zfile_func64.opaque,filestream))
+
+voidpf call_zopen64 OF((const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode));
+long    call_zseek64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin));
+ZPOS64_T call_ztell64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream));
 
-void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def *p_filefunc64_32, const zlib_filefunc_def *p_filefunc32);
+void    fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32);
 
-#define ZOPEN64(filefunc,filename,mode)             (call_zopen64((&(filefunc)),(filename),(mode)))
-#define ZOPENDISK64(filefunc,filestream,diskn,mode) (call_zopendisk64((&(filefunc)),(filestream),(diskn),(mode)))
-#define ZTELL64(filefunc,filestream)                (call_ztell64((&(filefunc)),(filestream)))
-#define ZSEEK64(filefunc,filestream,pos,mode)       (call_zseek64((&(filefunc)),(filestream),(pos),(mode)))
+#define ZOPEN64(filefunc,filename,mode)         (call_zopen64((&(filefunc)),(filename),(mode)))
+#define ZTELL64(filefunc,filestream)            (call_ztell64((&(filefunc)),(filestream)))
+#define ZSEEK64(filefunc,filestream,pos,mode)   (call_zseek64((&(filefunc)),(filestream),(pos),(mode)))
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif
diff --git a/contrib/unzip/unzip.c b/contrib/unzip/unzip.c
index 4bc6773ef..3036b470b 100644
--- a/contrib/unzip/unzip.c
+++ b/contrib/unzip/unzip.c
@@ -1,2000 +1,2130 @@
 /* unzip.c -- IO for uncompress .zip files using zlib
    Version 1.1, February 14h, 2010
-   part of the MiniZip project
-
-   Copyright (C) 1998-2010 Gilles Vollant
-     http://www.winimage.com/zLibDll/minizip.html
-   Modifications of Unzip for Zip64
-     Copyright (C) 2007-2008 Even Rouault
-   Modifications for Zip64 support on both zip and unzip
-     Copyright (C) 2009-2010 Mathias Svensson
-     http://result42.com
-   Modifications for AES, PKWARE disk spanning
-     Copyright (C) 2010-2014 Nathan Moinvaziri
-
-   This program is distributed under the terms of the same license as zlib.
-   See the accompanying LICENSE file for the full text of the license.
+   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Modifications of Unzip for Zip64
+         Copyright (C) 2007-2008 Even Rouault
+
+         Modifications for Zip64 support on both zip and unzip
+         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+
+         For more info read MiniZip_info.txt
+
+
+  ------------------------------------------------------------------------------------
+  Decryption code comes from crypt.c by Info-ZIP but has been greatly reduced in terms of
+  compatibility with older software. The following is from the original crypt.c.
+  Code woven in by Terry Thorsen 1/2003.
+
+  Copyright (c) 1990-2000 Info-ZIP.  All rights reserved.
+
+  See the accompanying file LICENSE, version 2000-Apr-09 or later
+  (the contents of which are also included in zip.h) for terms of use.
+  If, for some reason, all these files are missing, the Info-ZIP license
+  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html
+
+        crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]
+
+  The encryption/decryption parts of this source code (as opposed to the
+  non-echoing password parts) were originally written in Europe.  The
+  whole source package can be freely distributed, including from the USA.
+  (Prior to January 2000, re-export from the US was a violation of US law.)
+
+        This encryption code is a direct transcription of the algorithm from
+  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
+  file (appnote.txt) is distributed with the PKZIP program (even in the
+  version without encryption capabilities).
+
+        ------------------------------------------------------------------------------------
+
+        Changes in unzip.c
+
+        2007-2008 - Even Rouault - Addition of cpl_unzGetCurrentFileZStreamPos
+  2007-2008 - Even Rouault - Decoration of symbol names unz* -> cpl_unz*
+  2007-2008 - Even Rouault - Remove old C style function prototypes
+  2007-2008 - Even Rouault - Add unzip support for ZIP64
+
+        Copyright (C) 2007-2008 Even Rouault
+
+
+        Oct-2009 - Mathias Svensson - Removed cpl_* from symbol names (Even Rouault added them but since this is now moved to a new project (minizip64) I renamed them again).
+  Oct-2009 - Mathias Svensson - Fixed problem if uncompressed size was > 4G and compressed size was <4G
+                                should only read the compressed/uncompressed size from the Zip64 format if
+                                the size from normal header was 0xFFFFFFFF
+  Oct-2009 - Mathias Svensson - Applied some bug fixes from paches recived from Gilles Vollant
+        Oct-2009 - Mathias Svensson - Applied support to unzip files with compression mathod BZIP2 (bzip2 lib is required)
+                                Patch created by Daniel Borca
+
+  Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer
+
+  Copyright (C) 1998 - 2010 Gilles Vollant, Even Rouault, Mathias Svensson
+
 */
 
+
 #include <stdio.h>
 #include <stdlib.h>
-#include <stdint.h>
 #include <string.h>
-#include <errno.h>
+
+#ifndef NOUNCRYPT
+        #define NOUNCRYPT
+#endif
 
 #include "zlib.h"
 #include "unzip.h"
 
-#ifdef HAVE_AES
-#  define AES_METHOD          (99)
-#  define AES_PWVERIFYSIZE    (2)
-#  define AES_MAXSALTLENGTH   (16)
-#  define AES_AUTHCODESIZE    (10)
-#  define AES_HEADERSIZE      (11)
-#  define AES_KEYSIZE(mode)   (64 + (mode * 64))
-
-#  include "aes/aes.h"
-#  include "aes/fileenc.h"
+#ifdef STDC
+#  include <stddef.h>
+#  include <string.h>
+#  include <stdlib.h>
 #endif
-#ifdef HAVE_APPLE_COMPRESSION
-#  include <compression.h>
+#ifdef NO_ERRNO_H
+    extern int errno;
+#else
+#   include <errno.h>
 #endif
 
-#ifndef NOUNCRYPT
-#  include "crypt.h"
-#endif
 
-#define DISKHEADERMAGIC             (0x08074b50)
-#define LOCALHEADERMAGIC            (0x04034b50)
-#define CENTRALHEADERMAGIC          (0x02014b50)
-#define ENDHEADERMAGIC              (0x06054b50)
-#define ZIP64ENDHEADERMAGIC         (0x06064b50)
-#define ZIP64ENDLOCHEADERMAGIC      (0x07064b50)
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
 
-#define SIZECENTRALDIRITEM          (0x2e)
-#define SIZECENTRALHEADERLOCATOR    (0x14)
-#define SIZEZIPLOCALHEADER          (0x1e)
 
-#ifndef BUFREADCOMMENT
-#  define BUFREADCOMMENT            (0x400)
+#ifndef CASESENSITIVITYDEFAULT_NO
+#  if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES)
+#    define CASESENSITIVITYDEFAULT_NO
+#  endif
 #endif
 
+
 #ifndef UNZ_BUFSIZE
-#  define UNZ_BUFSIZE               (UINT16_MAX)
+#define UNZ_BUFSIZE (16384)
 #endif
+
 #ifndef UNZ_MAXFILENAMEINZIP
-#  define UNZ_MAXFILENAMEINZIP      (256)
+#define UNZ_MAXFILENAMEINZIP (256)
 #endif
 
 #ifndef ALLOC
-#  define ALLOC(size) (malloc(size))
+# define ALLOC(size) (malloc(size))
 #endif
 #ifndef TRYFREE
-#  define TRYFREE(p) {if (p) free(p);}
+# define TRYFREE(p) { free(p);}
 #endif
 
-#ifdef _MSC_VER
-#   pragma warning(push)
-#   pragma warning(disable : 4131 4244 4189 4245)
-#endif // _MSC_VER
+#define SIZECENTRALDIRITEM (0x2e)
+#define SIZEZIPLOCALHEADER (0x1e)
 
-static const char unz_copyright[] =
+
+const char unz_copyright[] =
    " unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
 
-/* unz_file_info_internal contain internal info about a file in zipfile*/
+/* unz_file_info_interntal contain internal info about a file in zipfile*/
 typedef struct unz_file_info64_internal_s
 {
-    uint64_t offset_curfile;            /* relative offset of local header 8 bytes */
-    uint64_t byte_before_the_zipfile;   /* byte before the zipfile, (>0 for sfx) */
-#ifdef HAVE_AES
-    uint8_t  aes_encryption_mode;
-    uint16_t aes_compression_method;
-    uint16_t aes_version;
-#endif
+    ZPOS64_T offset_curfile;/* relative offset of local header 8 bytes */
 } unz_file_info64_internal;
 
-/* file_in_zip_read_info_s contain internal information about a file in zipfile */
+
+/* file_in_zip_read_info_s contain internal information about a file in zipfile,
+    when reading and decompress it */
 typedef struct
 {
-    uint8_t *read_buffer;               /* internal buffer for compressed data */
-    z_stream stream;                    /* zLib stream structure for inflate */
+    char  *read_buffer;         /* internal buffer for compressed data */
+    z_stream stream;            /* zLib stream structure for inflate */
+
 #ifdef HAVE_BZIP2
-    bz_stream bstream;                  /* bzLib stream structure for bziped */
+    bz_stream bstream;          /* bzLib stream structure for bziped */
 #endif
-#ifdef HAVE_APPLE_COMPRESSION
-    compression_stream astream;         /* libcompression stream structure */
-#endif
-#ifdef HAVE_AES
-    fcrypt_ctx aes_ctx;
-#endif
-    uint64_t pos_in_zipfile;            /* position in byte on the zipfile, for fseek */
-    uint8_t  stream_initialised;        /* flag set if stream structure is initialised */
 
-    uint64_t offset_local_extrafield;   /* offset of the local extra field */
-    uint16_t size_local_extrafield;     /* size of the local extra field */
-    uint64_t pos_local_extrafield;      /* position in the local extra field in read */
-    uint64_t total_out_64;
+    ZPOS64_T pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/
+    uLong stream_initialised;   /* flag set if stream structure is initialised*/
 
-    uint32_t crc32;                     /* crc32 of all data uncompressed */
-    uint32_t crc32_wait;                /* crc32 we must obtain after decompress all */
-    uint64_t rest_read_compressed;      /* number of byte to be decompressed */
-    uint64_t rest_read_uncompressed;    /* number of byte to be obtained after decomp */
+    ZPOS64_T offset_local_extrafield;/* offset of the local extra field */
+    uInt  size_local_extrafield;/* size of the local extra field */
+    ZPOS64_T pos_local_extrafield;   /* position in the local extra field in read*/
+    ZPOS64_T total_out_64;
 
+    uLong crc32;                /* crc32 of all data uncompressed */
+    uLong crc32_wait;           /* crc32 we must obtain after decompress all */
+    ZPOS64_T rest_read_compressed; /* number of byte to be decompressed */
+    ZPOS64_T rest_read_uncompressed;/*number of byte to be obtained after decomp*/
     zlib_filefunc64_32_def z_filefunc;
-
-    voidpf   filestream;                /* io structore of the zipfile */
-    uint16_t compression_method;        /* compression method (0==store) */
-    uint64_t byte_before_the_zipfile;   /* byte before the zipfile, (>0 for sfx) */
-    int      raw;
+    voidpf filestream;        /* io structore of the zipfile */
+    uLong compression_method;   /* compression method (0==store) */
+    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
+    int   raw;
 } file_in_zip64_read_info_s;
 
-/* unz64_s contain internal information about the zipfile */
+
+/* unz64_s contain internal information about the zipfile
+*/
 typedef struct
 {
     zlib_filefunc64_32_def z_filefunc;
+    int is64bitOpenFunction;
+    voidpf filestream;        /* io structore of the zipfile */
+    unz_global_info64 gi;       /* public global information */
+    ZPOS64_T byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
+    ZPOS64_T num_file;             /* number of the current file in the zipfile*/
+    ZPOS64_T pos_in_central_dir;   /* pos of the current file in the central dir*/
+    ZPOS64_T current_file_ok;      /* flag about the usability of the current file*/
+    ZPOS64_T central_pos;          /* position of the beginning of the central dir*/
+
+    ZPOS64_T size_central_dir;     /* size of the central directory  */
+    ZPOS64_T offset_central_dir;   /* offset of start of central directory with
+                                   respect to the starting disk number */
+
+    unz_file_info64 cur_file_info; /* public info about the current file in zip*/
+    unz_file_info64_internal cur_file_info_internal; /* private info about it*/
+    file_in_zip64_read_info_s* pfile_in_zip_read; /* structure about the current
+                                        file if we are decompressing it */
+    int encrypted;
+
+    int isZip64;
+
+#    ifndef NOUNCRYPT
+    unsigned long keys[3];     /* keys defining the pseudo-random sequence */
+    const z_crc_t* pcrc_32_tab;
+#    endif
+} unz64_s;
+
 
-    voidpf filestream;                  /* io structure of the current zipfile */
-    voidpf filestream_with_CD;          /* io structure of the disk with the central directory */
-
-    unz_global_info64 gi;               /* public global information */
-
-    uint64_t byte_before_the_zipfile;   /* byte before the zipfile, (>0 for sfx) */
-    uint64_t num_file;                  /* number of the current file in the zipfile */
-    uint64_t pos_in_central_dir;        /* pos of the current file in the central dir */
-    uint64_t current_file_ok;           /* flag about the usability of the current file */
-    uint64_t central_pos;               /* position of the beginning of the central dir */
-    uint32_t number_disk;               /* number of the current disk, used for spanning ZIP */
-    uint64_t size_central_dir;          /* size of the central directory */
-    uint64_t offset_central_dir;        /* offset of start of central directory with
-                                           respect to the starting disk number */
-
-    unz_file_info64 cur_file_info;      /* public info about the current file in zip*/
-    unz_file_info64_internal cur_file_info_internal;
-                                        /* private info about it*/
-    file_in_zip64_read_info_s *pfile_in_zip_read;
-                                        /* structure about the current file if we are decompressing it */
-    int is_zip64;                       /* is the current file zip64 */
 #ifndef NOUNCRYPT
-    uint32_t keys[3];                   /* keys defining the pseudo-random sequence */
-    const z_crc_t *pcrc_32_tab;
+#include "crypt.h"
 #endif
-} unz64_s;
 
-/* Read a byte from a gz_stream; Return EOF for end of file. */
-static int unzReadUInt8(const zlib_filefunc64_32_def *pzlib_filefunc_def, voidpf filestream, uint8_t *value)
+/* ===========================================================================
+     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
+   for end of file.
+   IN assertion: the stream s has been successfully opened for reading.
+*/
+
+
+local int unz64local_getByte OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream,
+    int *pi));
+
+local int unz64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi)
 {
-    uint8_t c = 0;
-    if (ZREAD64(*pzlib_filefunc_def, filestream, &c, 1) == 1)
+    unsigned char c;
+    int err = (int)ZREAD64(*pzlib_filefunc_def,filestream,&c,1);
+    if (err==1)
     {
-        *value = (uint8_t)c;
+        *pi = (int)c;
         return UNZ_OK;
     }
-    *value = 0;
-    if (ZERROR64(*pzlib_filefunc_def, filestream))
-        return UNZ_ERRNO;
-    return UNZ_EOF;
+    else
+    {
+        if (ZERROR64(*pzlib_filefunc_def,filestream))
+            return UNZ_ERRNO;
+        else
+            return UNZ_EOF;
+    }
 }
 
-static int unzReadUInt16(const zlib_filefunc64_32_def *pzlib_filefunc_def, voidpf filestream, uint16_t *value)
+
+/* ===========================================================================
+   Reads a long in LSB order from the given gz_stream. Sets
+*/
+local int unz64local_getShort OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream,
+    uLong *pX));
+
+local int unz64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def,
+                             voidpf filestream,
+                             uLong *pX)
 {
-    uint16_t x;
-    uint8_t c = 0;
-    int err = UNZ_OK;
-
-    err = unzReadUInt8(pzlib_filefunc_def, filestream, &c);
-    x = (uint16_t)c;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &c);
-    x |= ((uint16_t)c) << 8;
-
-    if (err == UNZ_OK)
-        *value = x;
+    uLong x ;
+    int i = 0;
+    int err;
+
+    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x = (uLong)i;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((uLong)i)<<8;
+
+    if (err==UNZ_OK)
+        *pX = x;
     else
-        *value = 0;
+        *pX = 0;
     return err;
 }
 
-static int unzReadUInt32(const zlib_filefunc64_32_def *pzlib_filefunc_def, voidpf filestream, uint32_t *value)
+local int unz64local_getLong OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream,
+    uLong *pX));
+
+local int unz64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def,
+                            voidpf filestream,
+                            uLong *pX)
 {
-    uint32_t x = 0;
-    uint8_t c = 0;
-    int err = UNZ_OK;
-
-    err = unzReadUInt8(pzlib_filefunc_def, filestream, &c);
-    x = (uint32_t)c;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &c);
-    x |= ((uint32_t)c) << 8;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &c);
-    x |= ((uint32_t)c) << 16;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &c);
-    x += ((uint32_t)c) << 24;
-
-    if (err == UNZ_OK)
-        *value = x;
+    uLong x ;
+    int i = 0;
+    int err;
+
+    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x = (uLong)i;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((uLong)i)<<8;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((uLong)i)<<16;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x += ((uLong)i)<<24;
+
+    if (err==UNZ_OK)
+        *pX = x;
     else
-        *value = 0;
+        *pX = 0;
     return err;
 }
 
-static int unzReadUInt64(const zlib_filefunc64_32_def *pzlib_filefunc_def, voidpf filestream, uint64_t *value)
+local int unz64local_getLong64 OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream,
+    ZPOS64_T *pX));
+
+
+local int unz64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def,
+                            voidpf filestream,
+                            ZPOS64_T *pX)
 {
-    uint64_t x = 0;
-    uint8_t i = 0;
-    int err = UNZ_OK;
-
-    err = unzReadUInt8(pzlib_filefunc_def, filestream, &i);
-    x = (uint64_t)i;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &i);
-    x |= ((uint64_t)i) << 8;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &i);
-    x |= ((uint64_t)i) << 16;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &i);
-    x |= ((uint64_t)i) << 24;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &i);
-    x |= ((uint64_t)i) << 32;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &i);
-    x |= ((uint64_t)i) << 40;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &i);
-    x |= ((uint64_t)i) << 48;
-    if (err == UNZ_OK)
-        err = unzReadUInt8(pzlib_filefunc_def, filestream, &i);
-    x |= ((uint64_t)i) << 56;
-
-    if (err == UNZ_OK)
-        *value = x;
+    ZPOS64_T x ;
+    int i = 0;
+    int err;
+
+    err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x = (ZPOS64_T)i;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<8;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<16;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<24;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<32;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<40;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<48;
+
+    if (err==UNZ_OK)
+        err = unz64local_getByte(pzlib_filefunc_def,filestream,&i);
+    x |= ((ZPOS64_T)i)<<56;
+
+    if (err==UNZ_OK)
+        *pX = x;
     else
-        *value = 0;
+        *pX = 0;
     return err;
 }
 
-/* Locate the Central directory of a zip file (at the end, just before the global comment) */
-static uint64_t unzSearchCentralDir(const zlib_filefunc64_32_def *pzlib_filefunc_def, voidpf filestream)
+/* My own strcmpi / strcasecmp */
+local int strcmpcasenosensitive_internal (const char* fileName1, const char* fileName2)
+{
+    for (;;)
+    {
+        char c1=*(fileName1++);
+        char c2=*(fileName2++);
+        if ((c1>='a') && (c1<='z'))
+            c1 -= 0x20;
+        if ((c2>='a') && (c2<='z'))
+            c2 -= 0x20;
+        if (c1=='\0')
+            return ((c2=='\0') ? 0 : -1);
+        if (c2=='\0')
+            return 1;
+        if (c1<c2)
+            return -1;
+        if (c1>c2)
+            return 1;
+    }
+}
+
+
+#ifdef  CASESENSITIVITYDEFAULT_NO
+#define CASESENSITIVITYDEFAULTVALUE 2
+#else
+#define CASESENSITIVITYDEFAULTVALUE 1
+#endif
+
+#ifndef STRCMPCASENOSENTIVEFUNCTION
+#define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal
+#endif
+
+/*
+   Compare two filename (fileName1,fileName2).
+   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
+   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
+                                                                or strcasecmp)
+   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
+        (like 1 on Unix, 2 on Windows)
+
+*/
+extern int ZEXPORT unzStringFileNameCompare (const char*  fileName1,
+                                                 const char*  fileName2,
+                                                 int iCaseSensitivity)
+
+{
+    if (iCaseSensitivity==0)
+        iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;
+
+    if (iCaseSensitivity==1)
+        return strcmp(fileName1,fileName2);
+
+    return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);
+}
+
+#ifndef BUFREADCOMMENT
+#define BUFREADCOMMENT (0x400)
+#endif
+
+/*
+  Locate the Central directory of a zipfile (at the end, just before
+    the global comment)
+*/
+local ZPOS64_T unz64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
+local ZPOS64_T unz64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
 {
-    uint8_t buf[BUFREADCOMMENT + 4];
-    uint64_t file_size = 0;
-    uint64_t back_read = 4;
-    uint64_t max_back = UINT16_MAX; /* maximum size of global comment */
-    uint64_t pos_found = 0;
-    uint32_t read_size = 0;
-    uint64_t read_pos = 0;
-    uint32_t i = 0;
-
-    if (ZSEEK64(*pzlib_filefunc_def, filestream, 0, ZLIB_FILEFUNC_SEEK_END) != 0)
+    unsigned char* buf;
+    ZPOS64_T uSizeFile;
+    ZPOS64_T uBackRead;
+    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
+    ZPOS64_T uPosFound=0;
+
+    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
         return 0;
 
-    file_size = ZTELL64(*pzlib_filefunc_def, filestream);
 
-    if (max_back > file_size)
-        max_back = file_size;
+    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
+
+    if (uMaxBack>uSizeFile)
+        uMaxBack = uSizeFile;
+
+    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
+    if (buf==NULL)
+        return 0;
 
-    while (back_read < max_back)
+    uBackRead = 4;
+    while (uBackRead<uMaxBack)
     {
-        if (back_read + BUFREADCOMMENT > max_back)
-            back_read = max_back;
+        uLong uReadSize;
+        ZPOS64_T uReadPos ;
+        int i;
+        if (uBackRead+BUFREADCOMMENT>uMaxBack)
+            uBackRead = uMaxBack;
         else
-            back_read += BUFREADCOMMENT;
-
-        read_pos = file_size - back_read;
-        read_size = ((BUFREADCOMMENT + 4) < (file_size - read_pos)) ?
-                     (BUFREADCOMMENT + 4) : (uint32_t)(file_size - read_pos);
+            uBackRead+=BUFREADCOMMENT;
+        uReadPos = uSizeFile-uBackRead ;
 
-        if (ZSEEK64(*pzlib_filefunc_def, filestream, read_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
+        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
+                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
+        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
             break;
-        if (ZREAD64(*pzlib_filefunc_def, filestream, buf, read_size) != read_size)
+
+        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
             break;
 
-        for (i = read_size - 3; (i--) > 0;)
-            if (((*(buf+i)) == (ENDHEADERMAGIC & 0xff)) &&
-                ((*(buf+i+1)) == (ENDHEADERMAGIC >> 8 & 0xff)) &&
-                ((*(buf+i+2)) == (ENDHEADERMAGIC >> 16 & 0xff)) &&
-                ((*(buf+i+3)) == (ENDHEADERMAGIC >> 24 & 0xff)))
+        for (i=(int)uReadSize-3; (i--)>0;)
+            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
+                ((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
             {
-                pos_found = read_pos+i;
+                uPosFound = uReadPos+(unsigned)i;
                 break;
             }
 
-        if (pos_found != 0)
+        if (uPosFound!=0)
             break;
     }
-
-    return pos_found;
+    TRYFREE(buf);
+    return uPosFound;
 }
 
-/* Locate the Central directory 64 of a zipfile (at the end, just before the global comment) */
-static uint64_t unzSearchCentralDir64(const zlib_filefunc64_32_def *pzlib_filefunc_def, voidpf filestream,
-    const uint64_t endcentraloffset)
+
+/*
+  Locate the Central directory 64 of a zipfile (at the end, just before
+    the global comment)
+*/
+local ZPOS64_T unz64local_SearchCentralDir64 OF((
+    const zlib_filefunc64_32_def* pzlib_filefunc_def,
+    voidpf filestream));
+
+local ZPOS64_T unz64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def,
+                                      voidpf filestream)
 {
-    uint64_t offset = 0;
-    uint32_t value32 = 0;
+    unsigned char* buf;
+    ZPOS64_T uSizeFile;
+    ZPOS64_T uBackRead;
+    ZPOS64_T uMaxBack=0xffff; /* maximum size of global comment */
+    ZPOS64_T uPosFound=0;
+    uLong uL;
+                ZPOS64_T relativeOffset;
+
+    if (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
+        return 0;
+
+
+    uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);
+
+    if (uMaxBack>uSizeFile)
+        uMaxBack = uSizeFile;
+
+    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
+    if (buf==NULL)
+        return 0;
+
+    uBackRead = 4;
+    while (uBackRead<uMaxBack)
+    {
+        uLong uReadSize;
+        ZPOS64_T uReadPos;
+        int i;
+        if (uBackRead+BUFREADCOMMENT>uMaxBack)
+            uBackRead = uMaxBack;
+        else
+            uBackRead+=BUFREADCOMMENT;
+        uReadPos = uSizeFile-uBackRead ;
+
+        uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ?
+                     (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
+        if (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+            break;
+
+        if (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
+            break;
+
+        for (i=(int)uReadSize-3; (i--)>0;)
+            if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) &&
+                ((*(buf+i+2))==0x06) && ((*(buf+i+3))==0x07))
+            {
+                uPosFound = uReadPos+(unsigned)i;
+                break;
+            }
+
+        if (uPosFound!=0)
+            break;
+    }
+    TRYFREE(buf);
+    if (uPosFound == 0)
+        return 0;
 
     /* Zip64 end of central directory locator */
-    if (ZSEEK64(*pzlib_filefunc_def, filestream, endcentraloffset - SIZECENTRALHEADERLOCATOR, ZLIB_FILEFUNC_SEEK_SET) != 0)
+    if (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)
+        return 0;
+
+    /* the signature, already checked */
+    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
         return 0;
 
-    /* Read locator signature */
-    if (unzReadUInt32(pzlib_filefunc_def, filestream, &value32) != UNZ_OK)
+    /* number of the disk with the start of the zip64 end of  central directory */
+    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
         return 0;
-    if (value32 != ZIP64ENDLOCHEADERMAGIC)
+    if (uL != 0)
         return 0;
-    /* Number of the disk with the start of the zip64 end of  central directory */
-    if (unzReadUInt32(pzlib_filefunc_def, filestream, &value32) != UNZ_OK)
+
+    /* relative offset of the zip64 end of central directory record */
+    if (unz64local_getLong64(pzlib_filefunc_def,filestream,&relativeOffset)!=UNZ_OK)
         return 0;
-    /* Relative offset of the zip64 end of central directory record */
-    if (unzReadUInt64(pzlib_filefunc_def, filestream, &offset) != UNZ_OK)
+
+    /* total number of disks */
+    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
         return 0;
-    /* Total number of disks */
-    if (unzReadUInt32(pzlib_filefunc_def, filestream, &value32) != UNZ_OK)
+    if (uL != 1)
         return 0;
+
     /* Goto end of central directory record */
-    if (ZSEEK64(*pzlib_filefunc_def, filestream, offset, ZLIB_FILEFUNC_SEEK_SET) != 0)
+    if (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)
         return 0;
-     /* The signature */
-    if (unzReadUInt32(pzlib_filefunc_def, filestream, &value32) != UNZ_OK)
+
+     /* the signature */
+    if (unz64local_getLong(pzlib_filefunc_def,filestream,&uL)!=UNZ_OK)
         return 0;
-    if (value32 != ZIP64ENDHEADERMAGIC)
+
+    if (uL != 0x06064b50)
         return 0;
 
-    return offset;
+    return relativeOffset;
 }
 
-static unzFile unzOpenInternal(const void *path, zlib_filefunc64_32_def *pzlib_filefunc64_32_def)
+/*
+  Open a Zip file. path contain the full pathname (by example,
+     on a Windows NT computer "c:\\test\\zlib114.zip" or on an Unix computer
+     "zlib/zlib114.zip".
+     If the zipfile cannot be opened (file doesn't exist or in not valid), the
+       return value is NULL.
+     Else, the return value is a unzFile Handle, usable with other function
+       of this unzip package.
+*/
+local unzFile unzOpenInternal (const void *path,
+                               zlib_filefunc64_32_def* pzlib_filefunc64_32_def,
+                               int is64bitOpenFunction)
 {
     unz64_s us;
-    unz64_s *s = NULL;
-    uint64_t central_pos = 0;
-    uint64_t central_pos64 = 0;
-    uint64_t number_entry_CD = 0;
-    uint16_t value16 = 0;
-    uint32_t value32 = 0;
-    uint64_t value64 = 0;
-    voidpf filestream = NULL;
-    int err = UNZ_OK;
-
-    if (unz_copyright[0] != ' ')
+    unz64_s *s;
+    ZPOS64_T central_pos;
+    uLong   uL;
+
+    uLong number_disk;          /* number of the current dist, used for
+                                   spaning ZIP, unsupported, always 0*/
+    uLong number_disk_with_CD;  /* number the the disk with central dir, used
+                                   for spaning ZIP, unsupported, always 0*/
+    ZPOS64_T number_entry_CD;      /* total number of entries in
+                                   the central dir
+                                   (same than number_entry on nospan) */
+
+    int err=UNZ_OK;
+
+    if (unz_copyright[0]!=' ')
         return NULL;
 
-    us.filestream = NULL;
-    us.filestream_with_CD = NULL;
     us.z_filefunc.zseek32_file = NULL;
     us.z_filefunc.ztell32_file = NULL;
-
-    if (pzlib_filefunc64_32_def == NULL)
+    if (pzlib_filefunc64_32_def==NULL)
         fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);
     else
         us.z_filefunc = *pzlib_filefunc64_32_def;
+    us.is64bitOpenFunction = is64bitOpenFunction;
 
-    us.filestream = ZOPEN64(us.z_filefunc, path, ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_EXISTING);
 
-    if (us.filestream == NULL)
-        return NULL;
 
-    us.filestream_with_CD = us.filestream;
-    us.is_zip64 = 0;
+    us.filestream = ZOPEN64(us.z_filefunc,
+                                                 path,
+                                                 ZLIB_FILEFUNC_MODE_READ |
+                                                 ZLIB_FILEFUNC_MODE_EXISTING);
+    if (us.filestream==NULL)
+        return NULL;
 
-    /* Search for end of central directory header */
-    central_pos = unzSearchCentralDir(&us.z_filefunc, us.filestream);
+    central_pos = unz64local_SearchCentralDir64(&us.z_filefunc,us.filestream);
     if (central_pos)
     {
-        if (ZSEEK64(us.z_filefunc, us.filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
-            err = UNZ_ERRNO;
-
-        /* The signature, already checked */
-        if (unzReadUInt32(&us.z_filefunc, us.filestream, &value32) != UNZ_OK)
-            err = UNZ_ERRNO;
-        /* Number of this disk */
-        if (unzReadUInt16(&us.z_filefunc, us.filestream, &value16) != UNZ_OK)
-            err = UNZ_ERRNO;
-        us.number_disk = value16;
-        /* Number of the disk with the start of the central directory */
-        if (unzReadUInt16(&us.z_filefunc, us.filestream, &value16) != UNZ_OK)
-            err = UNZ_ERRNO;
-        us.gi.number_disk_with_CD = value16;
-        /* Total number of entries in the central directory on this disk */
-        if (unzReadUInt16(&us.z_filefunc, us.filestream, &value16) != UNZ_OK)
-            err = UNZ_ERRNO;
-        us.gi.number_entry = value16;
-        /* Total number of entries in the central directory */
-        if (unzReadUInt16(&us.z_filefunc, us.filestream, &value16) != UNZ_OK)
-            err = UNZ_ERRNO;
-        number_entry_CD = value16;
-        if (number_entry_CD != us.gi.number_entry)
-            err = UNZ_BADZIPFILE;
-        /* Size of the central directory */
-        if (unzReadUInt32(&us.z_filefunc, us.filestream, &value32) != UNZ_OK)
-            err = UNZ_ERRNO;
-        us.size_central_dir = value32;
-        /* Offset of start of central directory with respect to the starting disk number */
-        if (unzReadUInt32(&us.z_filefunc, us.filestream, &value32) != UNZ_OK)
-            err = UNZ_ERRNO;
-        us.offset_central_dir = value32;
-        /* Zipfile comment length */
-        if (unzReadUInt16(&us.z_filefunc, us.filestream, &us.gi.size_comment) != UNZ_OK)
-            err = UNZ_ERRNO;
+        uLong uS;
+        ZPOS64_T uL64;
 
-        if (err == UNZ_OK)
-        {
-            /* Search for Zip64 end of central directory header */
-            central_pos64 = unzSearchCentralDir64(&us.z_filefunc, us.filestream, central_pos);
-            if (central_pos64)
-            {
-                central_pos = central_pos64;
-                us.is_zip64 = 1;
-
-                if (ZSEEK64(us.z_filefunc, us.filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
-                    err = UNZ_ERRNO;
-
-                /* the signature, already checked */
-                if (unzReadUInt32(&us.z_filefunc, us.filestream, &value32) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                /* size of zip64 end of central directory record */
-                if (unzReadUInt64(&us.z_filefunc, us.filestream, &value64) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                /* version made by */
-                if (unzReadUInt16(&us.z_filefunc, us.filestream, &value16) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                /* version needed to extract */
-                if (unzReadUInt16(&us.z_filefunc, us.filestream, &value16) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                /* number of this disk */
-                if (unzReadUInt32(&us.z_filefunc, us.filestream, &us.number_disk) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                /* number of the disk with the start of the central directory */
-                if (unzReadUInt32(&us.z_filefunc, us.filestream, &us.gi.number_disk_with_CD) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                /* total number of entries in the central directory on this disk */
-                if (unzReadUInt64(&us.z_filefunc, us.filestream, &us.gi.number_entry) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                /* total number of entries in the central directory */
-                if (unzReadUInt64(&us.z_filefunc, us.filestream, &number_entry_CD) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                if (number_entry_CD != us.gi.number_entry)
-                    err = UNZ_BADZIPFILE;
-                /* size of the central directory */
-                if (unzReadUInt64(&us.z_filefunc, us.filestream, &us.size_central_dir) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                /* offset of start of central directory with respect to the starting disk number */
-                if (unzReadUInt64(&us.z_filefunc, us.filestream, &us.offset_central_dir) != UNZ_OK)
-                    err = UNZ_ERRNO;
-            }
-            else if ((us.gi.number_entry == UINT16_MAX) || (us.size_central_dir == UINT16_MAX) || (us.offset_central_dir == UINT32_MAX))
-                err = UNZ_BADZIPFILE;
-        }
+        us.isZip64 = 1;
+
+        if (ZSEEK64(us.z_filefunc, us.filestream,
+                                      central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+        err=UNZ_ERRNO;
+
+        /* the signature, already checked */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* size of zip64 end of central directory record */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&uL64)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* version made by */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* version needed to extract */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uS)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* number of this disk */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* number of the disk with the start of the central directory */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* total number of entries in the central directory on this disk */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.gi.number_entry)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* total number of entries in the central directory */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&number_entry_CD)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        if ((number_entry_CD!=us.gi.number_entry) ||
+            (number_disk_with_CD!=0) ||
+            (number_disk!=0))
+            err=UNZ_BADZIPFILE;
+
+        /* size of the central directory */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.size_central_dir)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* offset of start of central directory with respect to the
+          starting disk number */
+        if (unz64local_getLong64(&us.z_filefunc, us.filestream,&us.offset_central_dir)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        us.gi.size_comment = 0;
     }
     else
-        err = UNZ_ERRNO;
+    {
+        central_pos = unz64local_SearchCentralDir(&us.z_filefunc,us.filestream);
+        if (central_pos==0)
+            err=UNZ_ERRNO;
+
+        us.isZip64 = 0;
+
+        if (ZSEEK64(us.z_filefunc, us.filestream,
+                                        central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
+            err=UNZ_ERRNO;
+
+        /* the signature, already checked */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* number of this disk */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* number of the disk with the start of the central directory */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&number_disk_with_CD)!=UNZ_OK)
+            err=UNZ_ERRNO;
+
+        /* total number of entries in the central dir on this disk */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+        us.gi.number_entry = uL;
+
+        /* total number of entries in the central dir */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+        number_entry_CD = uL;
+
+        if ((number_entry_CD!=us.gi.number_entry) ||
+            (number_disk_with_CD!=0) ||
+            (number_disk!=0))
+            err=UNZ_BADZIPFILE;
+
+        /* size of the central directory */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+        us.size_central_dir = uL;
+
+        /* offset of start of central directory with respect to the
+            starting disk number */
+        if (unz64local_getLong(&us.z_filefunc, us.filestream,&uL)!=UNZ_OK)
+            err=UNZ_ERRNO;
+        us.offset_central_dir = uL;
+
+        /* zipfile comment length */
+        if (unz64local_getShort(&us.z_filefunc, us.filestream,&us.gi.size_comment)!=UNZ_OK)
+            err=UNZ_ERRNO;
+    }
 
-    if ((err == UNZ_OK) && (central_pos < us.offset_central_dir + us.size_central_dir))
-        err = UNZ_BADZIPFILE;
+    if ((central_pos<us.offset_central_dir+us.size_central_dir) &&
+        (err==UNZ_OK))
+        err=UNZ_BADZIPFILE;
 
-    if (err != UNZ_OK)
+    if (err!=UNZ_OK)
     {
         ZCLOSE64(us.z_filefunc, us.filestream);
         return NULL;
     }
 
-    if (us.gi.number_disk_with_CD == 0)
-    {
-        /* If there is only one disk open another stream so we don't have to seek between the CD
-           and the file headers constantly */
-        filestream = ZOPEN64(us.z_filefunc, path, ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_EXISTING);
-        if (filestream != NULL)
-            us.filestream = filestream;
-    }
-
-    /* Hack for zip files that have no respect for zip64
-    if ((central_pos > 0xffffffff) && (us.offset_central_dir < 0xffffffff))
-        us.offset_central_dir = central_pos - us.size_central_dir;*/
-
-    us.byte_before_the_zipfile = central_pos - (us.offset_central_dir + us.size_central_dir);
+    us.byte_before_the_zipfile = central_pos -
+                            (us.offset_central_dir+us.size_central_dir);
     us.central_pos = central_pos;
     us.pfile_in_zip_read = NULL;
+    us.encrypted = 0;
+
 
-    s = (unz64_s*)ALLOC(sizeof(unz64_s));
-    if (s != NULL)
+    s=(unz64_s*)ALLOC(sizeof(unz64_s));
+    if( s != NULL)
     {
-        *s = us;
+        *s=us;
         unzGoToFirstFile((unzFile)s);
     }
     return (unzFile)s;
 }
 
-extern unzFile ZEXPORT unzOpen2(const char *path, zlib_filefunc_def *pzlib_filefunc32_def)
+
+extern unzFile ZEXPORT unzOpen2 (const char *path,
+                                        zlib_filefunc_def* pzlib_filefunc32_def)
 {
     if (pzlib_filefunc32_def != NULL)
     {
         zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
-        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill, pzlib_filefunc32_def);
-        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill);
+        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
+        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 0);
     }
-    return unzOpenInternal(path, NULL);
+    else
+        return unzOpenInternal(path, NULL, 0);
 }
 
-extern unzFile ZEXPORT unzOpen2_64(const void *path, zlib_filefunc64_def *pzlib_filefunc_def)
+extern unzFile ZEXPORT unzOpen2_64 (const void *path,
+                                     zlib_filefunc64_def* pzlib_filefunc_def)
 {
     if (pzlib_filefunc_def != NULL)
     {
         zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
         zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
         zlib_filefunc64_32_def_fill.ztell32_file = NULL;
         zlib_filefunc64_32_def_fill.zseek32_file = NULL;
-        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill);
+        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill, 1);
     }
-    return unzOpenInternal(path, NULL);
+    else
+        return unzOpenInternal(path, NULL, 1);
 }
 
-extern unzFile ZEXPORT unzOpen(const char *path)
+extern unzFile ZEXPORT unzOpen (const char *path)
 {
-    return unzOpenInternal(path, NULL);
+    return unzOpenInternal(path, NULL, 0);
 }
 
-extern unzFile ZEXPORT unzOpen64(const void *path)
+extern unzFile ZEXPORT unzOpen64 (const void *path)
 {
-    return unzOpenInternal(path, NULL);
+    return unzOpenInternal(path, NULL, 1);
 }
 
-extern int ZEXPORT unzClose(unzFile file)
+/*
+  Close a ZipFile opened with unzOpen.
+  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
+    these files MUST be closed with unzCloseCurrentFile before call unzClose.
+  return UNZ_OK if there is no problem. */
+extern int ZEXPORT unzClose (unzFile file)
 {
-    unz64_s *s;
-    if (file == NULL)
+    unz64_s* s;
+    if (file==NULL)
         return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
+    s=(unz64_s*)file;
 
-    if (s->pfile_in_zip_read != NULL)
+    if (s->pfile_in_zip_read!=NULL)
         unzCloseCurrentFile(file);
 
-    if ((s->filestream != NULL) && (s->filestream != s->filestream_with_CD))
-        ZCLOSE64(s->z_filefunc, s->filestream);
-    if (s->filestream_with_CD != NULL)
-        ZCLOSE64(s->z_filefunc, s->filestream_with_CD);
-
-    s->filestream = NULL;
-    s->filestream_with_CD = NULL;
+    ZCLOSE64(s->z_filefunc, s->filestream);
     TRYFREE(s);
     return UNZ_OK;
 }
 
-/* Goto to the next available disk for spanned archives */
-static int unzGoToNextDisk(unzFile file)
-{
-    unz64_s *s;
-    uint32_t number_disk_next = 0;
 
-    s = (unz64_s*)file;
-    if (s == NULL)
+/*
+  Write info about the ZipFile in the *pglobal_info structure.
+  No preparation of the structure is needed
+  return UNZ_OK if there is no problem. */
+extern int ZEXPORT unzGetGlobalInfo64 (unzFile file, unz_global_info64* pglobal_info)
+{
+    unz64_s* s;
+    if (file==NULL)
         return UNZ_PARAMERROR;
-    number_disk_next = s->number_disk;
-
-    if ((s->pfile_in_zip_read != NULL) && (s->pfile_in_zip_read->rest_read_uncompressed > 0))
-        /* We are currently reading a file and we need the next sequential disk */
-        number_disk_next += 1;
-    else
-        /* Goto the disk for the current file */
-        number_disk_next = s->cur_file_info.disk_num_start;
-
-    if (number_disk_next != s->number_disk)
-    {
-        /* Switch disks */
-        if ((s->filestream != NULL) && (s->filestream != s->filestream_with_CD))
-            ZCLOSE64(s->z_filefunc, s->filestream);
-
-        if (number_disk_next == s->gi.number_disk_with_CD)
-        {
-            s->filestream = s->filestream_with_CD;
-        }
-        else
-        {
-            s->filestream = ZOPENDISK64(s->z_filefunc, s->filestream_with_CD, number_disk_next,
-                ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_EXISTING);
-        }
-
-        if (s->filestream == NULL)
-            return UNZ_ERRNO;
-
-        s->number_disk = number_disk_next;
-    }
-
+    s=(unz64_s*)file;
+    *pglobal_info=s->gi;
     return UNZ_OK;
 }
 
-extern int ZEXPORT unzGetGlobalInfo(unzFile file, unz_global_info* pglobal_info32)
+extern int ZEXPORT unzGetGlobalInfo (unzFile file, unz_global_info* pglobal_info32)
 {
-    unz64_s *s = NULL;
-    if (file == NULL)
+    unz64_s* s;
+    if (file==NULL)
         return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-
-    pglobal_info32->number_entry = (uint32_t)s->gi.number_entry;
+    s=(unz64_s*)file;
+    /* to do : check if number_entry is not truncated */
+    pglobal_info32->number_entry = (uLong)s->gi.number_entry;
     pglobal_info32->size_comment = s->gi.size_comment;
-    pglobal_info32->number_disk_with_CD = s->gi.number_disk_with_CD;
     return UNZ_OK;
 }
-
-extern int ZEXPORT unzGetGlobalInfo64(unzFile file, unz_global_info64 *pglobal_info)
+/*
+   Translate date/time from Dos format to tm_unz (readable more easilty)
+*/
+local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)
 {
-    unz64_s *s = NULL;
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-    *pglobal_info = s->gi;
-    return UNZ_OK;
+    ZPOS64_T uDate;
+    uDate = (ZPOS64_T)(ulDosDate>>16);
+    ptm->tm_mday = (int)(uDate&0x1f) ;
+    ptm->tm_mon =  (int)((((uDate)&0x1E0)/0x20)-1) ;
+    ptm->tm_year = (int)(((uDate&0x0FE00)/0x0200)+1980) ;
+
+    ptm->tm_hour = (int) ((ulDosDate &0xF800)/0x800);
+    ptm->tm_min =  (int) ((ulDosDate&0x7E0)/0x20) ;
+    ptm->tm_sec =  (int) (2*(ulDosDate&0x1f)) ;
 }
 
-extern int ZEXPORT unzGetGlobalComment(unzFile file, char *comment, uint16_t comment_size)
+/*
+  Get Info about the current file in the zipfile, with internal only info
+*/
+local int unz64local_GetCurrentFileInfoInternal OF((unzFile file,
+                                                  unz_file_info64 *pfile_info,
+                                                  unz_file_info64_internal
+                                                  *pfile_info_internal,
+                                                  char *szFileName,
+                                                  uLong fileNameBufferSize,
+                                                  void *extraField,
+                                                  uLong extraFieldBufferSize,
+                                                  char *szComment,
+                                                  uLong commentBufferSize));
+
+local int unz64local_GetCurrentFileInfoInternal (unzFile file,
+                                                  unz_file_info64 *pfile_info,
+                                                  unz_file_info64_internal
+                                                  *pfile_info_internal,
+                                                  char *szFileName,
+                                                  uLong fileNameBufferSize,
+                                                  void *extraField,
+                                                  uLong extraFieldBufferSize,
+                                                  char *szComment,
+                                                  uLong commentBufferSize)
 {
-    unz64_s *s = NULL;
-    uint16_t bytes_to_read = comment_size;
-    if (file == NULL)
-        return (int)UNZ_PARAMERROR;
-    s = (unz64_s*)file;
+    unz64_s* s;
+    unz_file_info64 file_info;
+    unz_file_info64_internal file_info_internal;
+    int err=UNZ_OK;
+    uLong uMagic;
+    long lSeek=0;
+    uLong uL;
 
-    if (bytes_to_read > s->gi.size_comment)
-        bytes_to_read = s->gi.size_comment;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    if (ZSEEK64(s->z_filefunc, s->filestream,
+              s->pos_in_central_dir+s->byte_before_the_zipfile,
+              ZLIB_FILEFUNC_SEEK_SET)!=0)
+        err=UNZ_ERRNO;
 
-    if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, s->central_pos + 22, ZLIB_FILEFUNC_SEEK_SET) != 0)
-        return UNZ_ERRNO;
 
-    if (bytes_to_read > 0)
+    /* we check the magic */
+    if (err==UNZ_OK)
     {
-        *comment = 0;
-        if (ZREAD64(s->z_filefunc, s->filestream_with_CD, comment, bytes_to_read) != bytes_to_read)
-            return UNZ_ERRNO;
+        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
+            err=UNZ_ERRNO;
+        else if (uMagic!=0x02014b50)
+            err=UNZ_BADZIPFILE;
     }
 
-    if ((comment != NULL) && (comment_size > s->gi.size_comment))
-        *(comment + s->gi.size_comment) = 0;
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version) != UNZ_OK)
+        err=UNZ_ERRNO;
 
-    return (int)bytes_to_read;
-}
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.version_needed) != UNZ_OK)
+        err=UNZ_ERRNO;
 
-static int unzGetCurrentFileInfoField(unzFile file, uint32_t *seek, void *field, uint16_t field_size, uint16_t size_file_field, int null_terminated_field)
-{
-    unz64_s *s = NULL;
-    uint32_t bytes_to_read = 0;
-    int err = UNZ_OK;
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.flag) != UNZ_OK)
+        err=UNZ_ERRNO;
 
-    if (file == NULL)
-        return (int)UNZ_PARAMERROR;
-    s = (unz64_s*)file;
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.compression_method) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.dosDate) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    unz64local_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.crc) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
+        err=UNZ_ERRNO;
+    file_info.compressed_size = uL;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
+        err=UNZ_ERRNO;
+    file_info.uncompressed_size = uL;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_filename) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_extra) != UNZ_OK)
+        err=UNZ_ERRNO;
 
-    /* Read field */
-    if (field != NULL)
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.size_file_comment) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.disk_num_start) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&file_info.internal_fa) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&file_info.external_fa) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+                // relative offset of local header
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
+        err=UNZ_ERRNO;
+    file_info_internal.offset_curfile = uL;
+
+    lSeek+=file_info.size_filename;
+    if ((err==UNZ_OK) && (szFileName!=NULL))
     {
-        if (size_file_field < field_size)
+        uLong uSizeRead ;
+        if (file_info.size_filename<fileNameBufferSize)
         {
-            if (null_terminated_field)
-                *((char *)field+size_file_field) = 0;
-
-            bytes_to_read = size_file_field;
+            *(szFileName+file_info.size_filename)='\0';
+            uSizeRead = file_info.size_filename;
         }
         else
-            bytes_to_read = field_size;
-        
-        if (*seek != 0)
-        {
-            if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, *seek, ZLIB_FILEFUNC_SEEK_CUR) == 0)
-                *seek = 0;
-            else
-                err = UNZ_ERRNO;
-        }
-        
-        if ((size_file_field > 0) && (field_size > 0))
-        {
-            if (ZREAD64(s->z_filefunc, s->filestream_with_CD, field, bytes_to_read) != bytes_to_read)
-                err = UNZ_ERRNO;
-        }
-        *seek += size_file_field - bytes_to_read;
-    }
-    else
-    {
-        *seek += size_file_field;
+            uSizeRead = fileNameBufferSize;
+
+        if ((file_info.size_filename>0) && (fileNameBufferSize>0))
+            if (ZREAD64(s->z_filefunc, s->filestream,szFileName,uSizeRead)!=uSizeRead)
+                err=UNZ_ERRNO;
+        lSeek -= uSizeRead;
     }
 
-    return err;
-}
+    // Read extrafield
+    if ((err==UNZ_OK) && (extraField!=NULL))
+    {
+        ZPOS64_T uSizeRead ;
+        if (file_info.size_file_extra<extraFieldBufferSize)
+            uSizeRead = file_info.size_file_extra;
+        else
+            uSizeRead = extraFieldBufferSize;
 
-/* Get info about the current file in the zipfile, with internal only info */
-static int unzGetCurrentFileInfoInternal(unzFile file, unz_file_info64 *pfile_info,
-    unz_file_info64_internal *pfile_info_internal, char *filename, uint16_t filename_size, void *extrafield,
-    uint16_t extrafield_size, char *comment, uint16_t comment_size)
-{
-    unz64_s *s = NULL;
-    unz_file_info64 file_info;
-    unz_file_info64_internal file_info_internal;
-    uint32_t magic = 0;
-    uint64_t current_pos = 0;
-    uint32_t seek = 0;
-    uint32_t extra_pos = 0;
-    uint16_t extra_header_id = 0;
-    uint16_t extra_data_size = 0;
-    uint16_t value16 = 0;
-    uint32_t value32 = 0;
-    uint64_t value64 = 0;
-    int err = UNZ_OK;
-
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
+        if (lSeek!=0)
+        {
+            if (ZSEEK64(s->z_filefunc, s->filestream,(ZPOS64_T)lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
+                lSeek=0;
+            else
+                err=UNZ_ERRNO;
+        }
 
-    if (ZSEEK64(s->z_filefunc, s->filestream_with_CD,
-            s->pos_in_central_dir + s->byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
-        err = UNZ_ERRNO;
+        if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))
+            if (ZREAD64(s->z_filefunc, s->filestream,extraField,(uLong)uSizeRead)!=uSizeRead)
+                err=UNZ_ERRNO;
 
-    /* Check the magic */
-    if (err == UNZ_OK)
-    {
-        if (unzReadUInt32(&s->z_filefunc, s->filestream_with_CD, &magic) != UNZ_OK)
-            err = UNZ_ERRNO;
-        else if (magic != CENTRALHEADERMAGIC)
-            err = UNZ_BADZIPFILE;
+        lSeek += file_info.size_file_extra - (uLong)uSizeRead;
     }
+    else
+        lSeek += file_info.size_file_extra;
 
-    /* Read central directory header */
-    if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &file_info.version) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &file_info.version_needed) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &file_info.flag) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &file_info.compression_method) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt32(&s->z_filefunc, s->filestream_with_CD, &file_info.dos_date) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt32(&s->z_filefunc, s->filestream_with_CD, &file_info.crc) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt32(&s->z_filefunc, s->filestream_with_CD, &value32) != UNZ_OK)
-        err = UNZ_ERRNO;
-    file_info.compressed_size = value32;
-    if (unzReadUInt32(&s->z_filefunc, s->filestream_with_CD, &value32) != UNZ_OK)
-        err = UNZ_ERRNO;
-    file_info.uncompressed_size = value32;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &file_info.size_filename) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &file_info.size_file_extra) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &file_info.size_file_comment) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &value16) != UNZ_OK)
-        err = UNZ_ERRNO;
-    file_info.disk_num_start = value16;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &file_info.internal_fa) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt32(&s->z_filefunc, s->filestream_with_CD, &file_info.external_fa) != UNZ_OK)
-        err = UNZ_ERRNO;
-    /* Relative offset of local header */
-    if (unzReadUInt32(&s->z_filefunc, s->filestream_with_CD, &value32) != UNZ_OK)
-        err = UNZ_ERRNO;
-
-    file_info.size_file_extra_internal = 0;
-    file_info.disk_offset = value32;
-    file_info_internal.offset_curfile = value32;
-#ifdef HAVE_AES
-    file_info_internal.aes_compression_method = 0;
-    file_info_internal.aes_encryption_mode = 0;
-    file_info_internal.aes_version = 0;
-#endif
 
-    if (err == UNZ_OK)
-        err = unzGetCurrentFileInfoField(file, &seek, filename, filename_size, file_info.size_filename, 1);
+    if ((err==UNZ_OK) && (file_info.size_file_extra != 0))
+    {
+                                uLong acc = 0;
 
-    /* Read extrafield */
-    if (err == UNZ_OK)
-        err = unzGetCurrentFileInfoField(file, &seek, extrafield, extrafield_size, file_info.size_file_extra, 0);
+        // since lSeek now points to after the extra field we need to move back
+        lSeek -= file_info.size_file_extra;
 
-    if ((err == UNZ_OK) && (file_info.size_file_extra != 0))
-    {
-        if (seek != 0)
+        if (lSeek!=0)
         {
-            if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, seek, ZLIB_FILEFUNC_SEEK_CUR) == 0)
-                seek = 0;
+            if (ZSEEK64(s->z_filefunc, s->filestream,(ZPOS64_T)lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
+                lSeek=0;
             else
-                err = UNZ_ERRNO;
+                err=UNZ_ERRNO;
         }
 
-        /* We are going to parse the extra field so we need to move back */
-        current_pos = ZTELL64(s->z_filefunc, s->filestream_with_CD);
-        if (current_pos < file_info.size_file_extra)
-            err = UNZ_ERRNO;
-        current_pos -= file_info.size_file_extra;
-        if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, current_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
-            err = UNZ_ERRNO;
-
-        while ((err != UNZ_ERRNO) && (extra_pos < file_info.size_file_extra))
+        while(acc < file_info.size_file_extra)
         {
-            if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &extra_header_id) != UNZ_OK)
-                err = UNZ_ERRNO;
-            if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &extra_data_size) != UNZ_OK)
-                err = UNZ_ERRNO;
+            uLong headerId;
+                                                uLong dataSize;
+
+            if (unz64local_getShort(&s->z_filefunc, s->filestream,&headerId) != UNZ_OK)
+                err=UNZ_ERRNO;
+
+            if (unz64local_getShort(&s->z_filefunc, s->filestream,&dataSize) != UNZ_OK)
+                err=UNZ_ERRNO;
 
             /* ZIP64 extra fields */
-            if (extra_header_id == 0x0001)
-            {
-                /* Subtract size of ZIP64 field, since ZIP64 is handled internally */
-                file_info.size_file_extra_internal += 2 + 2 + extra_data_size;
-
-                if (file_info.uncompressed_size == UINT32_MAX)
-                {
-                    if (unzReadUInt64(&s->z_filefunc, s->filestream_with_CD, &file_info.uncompressed_size) != UNZ_OK)
-                        err = UNZ_ERRNO;
-                }
-                if (file_info.compressed_size == UINT32_MAX)
-                {
-                    if (unzReadUInt64(&s->z_filefunc, s->filestream_with_CD, &file_info.compressed_size) != UNZ_OK)
-                        err = UNZ_ERRNO;
-                }
-                if (file_info_internal.offset_curfile == UINT32_MAX)
-                {
-                    /* Relative Header offset */
-                    if (unzReadUInt64(&s->z_filefunc, s->filestream_with_CD, &value64) != UNZ_OK)
-                        err = UNZ_ERRNO;
-                    file_info_internal.offset_curfile = value64;
-                    file_info.disk_offset = value64;
-                }
-                if (file_info.disk_num_start == UINT32_MAX)
-                {
-                    /* Disk Start Number */
-                    if (unzReadUInt32(&s->z_filefunc, s->filestream_with_CD, &file_info.disk_num_start) != UNZ_OK)
-                        err = UNZ_ERRNO;
-                }
-            }
-#ifdef HAVE_AES
-            /* AES header */
-            else if (extra_header_id == 0x9901)
+            if (headerId == 0x0001)
             {
-                uint8_t value8 = 0;
-
-                /* Subtract size of AES field, since AES is handled internally */
-                file_info.size_file_extra_internal += 2 + 2 + extra_data_size;
-
-                /* Verify version info */
-                if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &value16) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                /* Support AE-1 and AE-2 */
-                if (value16 != 1 && value16 != 2)
-                    err = UNZ_ERRNO;
-                file_info_internal.aes_version = value16;
-                if (unzReadUInt8(&s->z_filefunc, s->filestream_with_CD, &value8) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                if ((char)value8 != 'A')
-                    err = UNZ_ERRNO;
-                if (unzReadUInt8(&s->z_filefunc, s->filestream_with_CD, &value8) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                if ((char)value8 != 'E')
-                    err = UNZ_ERRNO;
-                /* Get AES encryption strength and actual compression method */
-                if (unzReadUInt8(&s->z_filefunc, s->filestream_with_CD, &value8) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                file_info_internal.aes_encryption_mode = value8;
-                if (unzReadUInt16(&s->z_filefunc, s->filestream_with_CD, &value16) != UNZ_OK)
-                    err = UNZ_ERRNO;
-                file_info_internal.aes_compression_method = value16;
+                                                        uLong uL;
+
+                                                                if(file_info.uncompressed_size == MAXU32)
+                                                                {
+                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.uncompressed_size) != UNZ_OK)
+                                                                                        err=UNZ_ERRNO;
+                                                                }
+
+                                                                if(file_info.compressed_size == MAXU32)
+                                                                {
+                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info.compressed_size) != UNZ_OK)
+                                                                                  err=UNZ_ERRNO;
+                                                                }
+
+                                                                if(file_info_internal.offset_curfile == MAXU32)
+                                                                {
+                                                                        /* Relative Header offset */
+                                                                        if (unz64local_getLong64(&s->z_filefunc, s->filestream,&file_info_internal.offset_curfile) != UNZ_OK)
+                                                                                err=UNZ_ERRNO;
+                                                                }
+
+                                                                if(file_info.disk_num_start == MAXU32)
+                                                                {
+                                                                        /* Disk Start Number */
+                                                                        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uL) != UNZ_OK)
+                                                                                err=UNZ_ERRNO;
+                                                                }
+
             }
-#endif
             else
             {
-                if (ZSEEK64(s->z_filefunc, s->filestream_with_CD,extra_data_size, ZLIB_FILEFUNC_SEEK_CUR) != 0)
-                    err = UNZ_ERRNO;
+                if (ZSEEK64(s->z_filefunc, s->filestream,dataSize,ZLIB_FILEFUNC_SEEK_CUR)!=0)
+                    err=UNZ_ERRNO;
             }
 
-            extra_pos += 2 + 2 + extra_data_size;
+            acc += 2 + 2 + dataSize;
         }
     }
 
-    if (file_info.disk_num_start == s->gi.number_disk_with_CD)
-        file_info_internal.byte_before_the_zipfile = s->byte_before_the_zipfile;
+    if ((err==UNZ_OK) && (szComment!=NULL))
+    {
+        uLong uSizeRead ;
+        if (file_info.size_file_comment<commentBufferSize)
+        {
+            *(szComment+file_info.size_file_comment)='\0';
+            uSizeRead = file_info.size_file_comment;
+        }
+        else
+            uSizeRead = commentBufferSize;
+
+        if (lSeek!=0)
+        {
+            if (ZSEEK64(s->z_filefunc, s->filestream,(ZPOS64_T)lSeek,ZLIB_FILEFUNC_SEEK_CUR)==0)
+                lSeek=0;
+            else
+                err=UNZ_ERRNO;
+        }
+
+        if ((file_info.size_file_comment>0) && (commentBufferSize>0))
+            if (ZREAD64(s->z_filefunc, s->filestream,szComment,uSizeRead)!=uSizeRead)
+                err=UNZ_ERRNO;
+        lSeek+=file_info.size_file_comment - uSizeRead;
+    }
     else
-        file_info_internal.byte_before_the_zipfile = 0;
+        lSeek+=file_info.size_file_comment;
 
-    if (err == UNZ_OK)
-        err = unzGetCurrentFileInfoField(file, &seek, comment, comment_size, file_info.size_file_comment, 1);
 
-    if ((err == UNZ_OK) && (pfile_info != NULL))
-        *pfile_info = file_info;
-    if ((err == UNZ_OK) && (pfile_info_internal != NULL))
-        *pfile_info_internal = file_info_internal;
+    if ((err==UNZ_OK) && (pfile_info!=NULL))
+        *pfile_info=file_info;
+
+    if ((err==UNZ_OK) && (pfile_info_internal!=NULL))
+        *pfile_info_internal=file_info_internal;
 
     return err;
 }
 
-extern int ZEXPORT unzGetCurrentFileInfo(unzFile file, unz_file_info *pfile_info, char *filename,
-    uint16_t filename_size, void *extrafield, uint16_t extrafield_size, char *comment, uint16_t comment_size)
-{
-    unz_file_info64 file_info64;
-    int err = UNZ_OK;
 
-    err = unzGetCurrentFileInfoInternal(file, &file_info64, NULL, filename, filename_size,
-                extrafield, extrafield_size, comment, comment_size);
 
-    if ((err == UNZ_OK) && (pfile_info != NULL))
+/*
+  Write info about the ZipFile in the *pglobal_info structure.
+  No preparation of the structure is needed
+  return UNZ_OK if there is no problem.
+*/
+extern int ZEXPORT unzGetCurrentFileInfo64 (unzFile file,
+                                          unz_file_info64 * pfile_info,
+                                          char * szFileName, uLong fileNameBufferSize,
+                                          void *extraField, uLong extraFieldBufferSize,
+                                          char* szComment,  uLong commentBufferSize)
+{
+    return unz64local_GetCurrentFileInfoInternal(file,pfile_info,NULL,
+                                                szFileName,fileNameBufferSize,
+                                                extraField,extraFieldBufferSize,
+                                                szComment,commentBufferSize);
+}
+
+extern int ZEXPORT unzGetCurrentFileInfo (unzFile file,
+                                          unz_file_info * pfile_info,
+                                          char * szFileName, uLong fileNameBufferSize,
+                                          void *extraField, uLong extraFieldBufferSize,
+                                          char* szComment,  uLong commentBufferSize)
+{
+    int err;
+    unz_file_info64 file_info64;
+    err = unz64local_GetCurrentFileInfoInternal(file,&file_info64,NULL,
+                                                szFileName,fileNameBufferSize,
+                                                extraField,extraFieldBufferSize,
+                                                szComment,commentBufferSize);
+    if ((err==UNZ_OK) && (pfile_info != NULL))
     {
         pfile_info->version = file_info64.version;
         pfile_info->version_needed = file_info64.version_needed;
         pfile_info->flag = file_info64.flag;
         pfile_info->compression_method = file_info64.compression_method;
-        pfile_info->dos_date = file_info64.dos_date;
+        pfile_info->dosDate = file_info64.dosDate;
         pfile_info->crc = file_info64.crc;
 
         pfile_info->size_filename = file_info64.size_filename;
-        pfile_info->size_file_extra = file_info64.size_file_extra - file_info64.size_file_extra_internal;
+        pfile_info->size_file_extra = file_info64.size_file_extra;
         pfile_info->size_file_comment = file_info64.size_file_comment;
 
-        pfile_info->disk_num_start = (uint16_t)file_info64.disk_num_start;
+        pfile_info->disk_num_start = file_info64.disk_num_start;
         pfile_info->internal_fa = file_info64.internal_fa;
         pfile_info->external_fa = file_info64.external_fa;
 
-        pfile_info->compressed_size = (uint32_t)file_info64.compressed_size;
-        pfile_info->uncompressed_size = (uint32_t)file_info64.uncompressed_size;
+        pfile_info->tmu_date = file_info64.tmu_date,
+
+
+        pfile_info->compressed_size = (uLong)file_info64.compressed_size;
+        pfile_info->uncompressed_size = (uLong)file_info64.uncompressed_size;
+
     }
     return err;
 }
+/*
+  Set the current file of the zipfile to the first file.
+  return UNZ_OK if there is no problem
+*/
+extern int ZEXPORT unzGoToFirstFile (unzFile file)
+{
+    int err=UNZ_OK;
+    unz64_s* s;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    s->pos_in_central_dir=s->offset_central_dir;
+    s->num_file=0;
+    err=unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+                                             &s->cur_file_info_internal,
+                                             NULL,0,NULL,0,NULL,0);
+    s->current_file_ok = (err == UNZ_OK);
+    return err;
+}
 
-extern int ZEXPORT unzGetCurrentFileInfo64(unzFile file, unz_file_info64 * pfile_info, char *filename,
-    uint16_t filename_size, void *extrafield, uint16_t extrafield_size, char *comment, uint16_t comment_size)
+/*
+  Set the current file of the zipfile to the next file.
+  return UNZ_OK if there is no problem
+  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
+*/
+extern int ZEXPORT unzGoToNextFile (unzFile  file)
 {
-    return unzGetCurrentFileInfoInternal(file, pfile_info, NULL, filename, filename_size,
-        extrafield, extrafield_size, comment,comment_size);
+    unz64_s* s;
+    int err;
+
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    if (!s->current_file_ok)
+        return UNZ_END_OF_LIST_OF_FILE;
+    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */
+      if (s->num_file+1==s->gi.number_entry)
+        return UNZ_END_OF_LIST_OF_FILE;
+
+    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
+            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;
+    s->num_file++;
+    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+                                               &s->cur_file_info_internal,
+                                               NULL,0,NULL,0,NULL,0);
+    s->current_file_ok = (err == UNZ_OK);
+    return err;
 }
 
-/* Read the local header of the current zipfile. Check the coherency of the local header and info in the
-   end of central directory about this file store in *piSizeVar the size of extra info in local header
-   (filename and size of extra field data) */
-static int unzCheckCurrentFileCoherencyHeader(unz64_s *s, uint32_t *psize_variable, uint64_t *poffset_local_extrafield,
-    uint16_t *psize_local_extrafield)
+
+/*
+  Try locate the file szFileName in the zipfile.
+  For the iCaseSensitivity signification, see unzStringFileNameCompare
+
+  return value :
+  UNZ_OK if the file is found. It becomes the current file.
+  UNZ_END_OF_LIST_OF_FILE if the file is not found
+*/
+extern int ZEXPORT unzLocateFile (unzFile file, const char *szFileName, int iCaseSensitivity)
 {
-    uint32_t magic = 0;
-    uint16_t value16 = 0;
-    uint32_t value32 = 0;
-    uint32_t flags = 0;
-    uint16_t size_filename = 0;
-    uint16_t size_extra_field = 0;
-    uint16_t compression_method = 0;
-    int err = UNZ_OK;
-
-    if (psize_variable == NULL)
+    unz64_s* s;
+    int err;
+
+    /* We remember the 'current' position in the file so that we can jump
+     * back there if we fail.
+     */
+    unz_file_info64 cur_file_infoSaved;
+    unz_file_info64_internal cur_file_info_internalSaved;
+    ZPOS64_T num_fileSaved;
+    ZPOS64_T pos_in_central_dirSaved;
+
+
+    if (file==NULL)
         return UNZ_PARAMERROR;
-    *psize_variable = 0;
-    if (poffset_local_extrafield == NULL)
+
+    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)
         return UNZ_PARAMERROR;
-    *poffset_local_extrafield = 0;
-    if (psize_local_extrafield == NULL)
+
+    s=(unz64_s*)file;
+    if (!s->current_file_ok)
+        return UNZ_END_OF_LIST_OF_FILE;
+
+    /* Save the current state */
+    num_fileSaved = s->num_file;
+    pos_in_central_dirSaved = s->pos_in_central_dir;
+    cur_file_infoSaved = s->cur_file_info;
+    cur_file_info_internalSaved = s->cur_file_info_internal;
+
+    err = unzGoToFirstFile(file);
+
+    while (err == UNZ_OK)
+    {
+        char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];
+        err = unzGetCurrentFileInfo64(file,NULL,
+                                    szCurrentFileName,sizeof(szCurrentFileName)-1,
+                                    NULL,0,NULL,0);
+        if (err == UNZ_OK)
+        {
+            if (unzStringFileNameCompare(szCurrentFileName,
+                                            szFileName,iCaseSensitivity)==0)
+                return UNZ_OK;
+            err = unzGoToNextFile(file);
+        }
+    }
+
+    /* We failed, so restore the state of the 'current file' to where we
+     * were.
+     */
+    s->num_file = num_fileSaved ;
+    s->pos_in_central_dir = pos_in_central_dirSaved ;
+    s->cur_file_info = cur_file_infoSaved;
+    s->cur_file_info_internal = cur_file_info_internalSaved;
+    return err;
+}
+
+
+/*
+///////////////////////////////////////////
+// Contributed by Ryan Haksi (mailto://cryogen@infoserve.net)
+// I need random access
+//
+// Further optimization could be realized by adding an ability
+// to cache the directory in memory. The goal being a single
+// comprehensive file read to put the file I need in a memory.
+*/
+
+/*
+typedef struct unz_file_pos_s
+{
+    ZPOS64_T pos_in_zip_directory;   // offset in file
+    ZPOS64_T num_of_file;            // # of file
+} unz_file_pos;
+*/
+
+extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)
+{
+    unz64_s* s;
+
+    if (file==NULL || file_pos==NULL)
         return UNZ_PARAMERROR;
-    *psize_local_extrafield = 0;
+    s=(unz64_s*)file;
+    if (!s->current_file_ok)
+        return UNZ_END_OF_LIST_OF_FILE;
 
-    err = unzGoToNextDisk((unzFile)s);
-    if (err != UNZ_OK)
-        return err;
+    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;
+    file_pos->num_of_file           = s->num_file;
 
-    if (ZSEEK64(s->z_filefunc, s->filestream, s->cur_file_info_internal.offset_curfile +
-        s->cur_file_info_internal.byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
-        return UNZ_ERRNO;
+    return UNZ_OK;
+}
 
-    if (err == UNZ_OK)
+extern int ZEXPORT unzGetFilePos(
+    unzFile file,
+    unz_file_pos* file_pos)
+{
+    unz64_file_pos file_pos64;
+    int err = unzGetFilePos64(file,&file_pos64);
+    if (err==UNZ_OK)
     {
-        if (unzReadUInt32(&s->z_filefunc, s->filestream, &magic) != UNZ_OK)
-            err = UNZ_ERRNO;
-        else if (magic != LOCALHEADERMAGIC)
-            err = UNZ_BADZIPFILE;
+        file_pos->pos_in_zip_directory = (uLong)file_pos64.pos_in_zip_directory;
+        file_pos->num_of_file = (uLong)file_pos64.num_of_file;
     }
+    return err;
+}
 
-    if (unzReadUInt16(&s->z_filefunc, s->filestream, &value16) != UNZ_OK)
-        err = UNZ_ERRNO;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream, &value16) != UNZ_OK)
-        err = UNZ_ERRNO;
-    flags = value16;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream, &value16) != UNZ_OK)
-        err = UNZ_ERRNO;
-    else if ((err == UNZ_OK) && (value16 != s->cur_file_info.compression_method))
-        err = UNZ_BADZIPFILE;
-
-    compression_method = s->cur_file_info.compression_method;
-#ifdef HAVE_AES
-    if (compression_method == AES_METHOD)
-        compression_method = s->cur_file_info_internal.aes_compression_method;
-#endif
+extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos* file_pos)
+{
+    unz64_s* s;
+    int err;
+
+    if (file==NULL || file_pos==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
 
-    if ((err == UNZ_OK) && (compression_method != 0) && (compression_method != Z_DEFLATED))
+    /* jump to the right spot */
+    s->pos_in_central_dir = file_pos->pos_in_zip_directory;
+    s->num_file           = file_pos->num_of_file;
+
+    /* set the current file */
+    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+                                               &s->cur_file_info_internal,
+                                               NULL,0,NULL,0,NULL,0);
+    /* return results */
+    s->current_file_ok = (err == UNZ_OK);
+    return err;
+}
+
+extern int ZEXPORT unzGoToFilePos(
+    unzFile file,
+    unz_file_pos* file_pos)
+{
+    unz64_file_pos file_pos64;
+    if (file_pos == NULL)
+        return UNZ_PARAMERROR;
+
+    file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;
+    file_pos64.num_of_file = file_pos->num_of_file;
+    return unzGoToFilePos64(file,&file_pos64);
+}
+
+/*
+// Unzip Helper Functions - should be here?
+///////////////////////////////////////////
+*/
+
+/*
+  Read the local header of the current zipfile
+  Check the coherency of the local header and info in the end of central
+        directory about this file
+  store in *piSizeVar the size of extra info in local header
+        (filename and size of extra field data)
+*/
+local int unz64local_CheckCurrentFileCoherencyHeader (unz64_s* s, uInt* piSizeVar,
+                                                    ZPOS64_T * poffset_local_extrafield,
+                                                    uInt  * psize_local_extrafield)
+{
+    uLong uMagic,uData,uFlags;
+    uLong size_filename;
+    uLong size_extra_field;
+    int err=UNZ_OK;
+
+    *piSizeVar = 0;
+    *poffset_local_extrafield = 0;
+    *psize_local_extrafield = 0;
+
+    if (ZSEEK64(s->z_filefunc, s->filestream,s->cur_file_info_internal.offset_curfile +
+                                s->byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET)!=0)
+        return UNZ_ERRNO;
+
+
+    if (err==UNZ_OK)
     {
-#ifdef HAVE_BZIP2
-        if (compression_method != Z_BZIP2ED)
-#endif
-            err = UNZ_BADZIPFILE;
+        if (unz64local_getLong(&s->z_filefunc, s->filestream,&uMagic) != UNZ_OK)
+            err=UNZ_ERRNO;
+        else if (uMagic!=0x04034b50)
+            err=UNZ_BADZIPFILE;
     }
 
-    if (unzReadUInt32(&s->z_filefunc, s->filestream, &value32) != UNZ_OK) /* date/time */
-        err = UNZ_ERRNO;
-    if (unzReadUInt32(&s->z_filefunc, s->filestream, &value32) != UNZ_OK) /* crc */
-        err = UNZ_ERRNO;
-    else if ((err == UNZ_OK) && (value32 != s->cur_file_info.crc) && ((flags & 8) == 0))
-        err = UNZ_BADZIPFILE;
-    if (unzReadUInt32(&s->z_filefunc, s->filestream, &value32) != UNZ_OK) /* size compr */
-        err = UNZ_ERRNO;
-    else if ((value32 != UINT32_MAX) && (err == UNZ_OK) && (value32 != s->cur_file_info.compressed_size) && ((flags & 8) == 0))
-        err = UNZ_BADZIPFILE;
-    if (unzReadUInt32(&s->z_filefunc, s->filestream, &value32) != UNZ_OK) /* size uncompr */
-        err = UNZ_ERRNO;
-    else if ((value32 != UINT32_MAX) && (err == UNZ_OK) && (value32 != s->cur_file_info.uncompressed_size) && ((flags & 8) == 0))
-        err = UNZ_BADZIPFILE;
-    if (unzReadUInt16(&s->z_filefunc, s->filestream, &size_filename) != UNZ_OK)
-        err = UNZ_ERRNO;
-    else if ((err == UNZ_OK) && (size_filename != s->cur_file_info.size_filename))
-        err = UNZ_BADZIPFILE;
-
-    *psize_variable += size_filename;
-
-    if (unzReadUInt16(&s->z_filefunc, s->filestream, &size_extra_field) != UNZ_OK)
-        err = UNZ_ERRNO;
-
-    *poffset_local_extrafield = s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER + size_filename;
-    *psize_local_extrafield = size_extra_field;
-    *psize_variable += size_extra_field;
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
+        err=UNZ_ERRNO;
+/*
+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
+        err=UNZ_BADZIPFILE;
+*/
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uFlags) != UNZ_OK)
+        err=UNZ_ERRNO;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&uData) != UNZ_OK)
+        err=UNZ_ERRNO;
+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))
+        err=UNZ_BADZIPFILE;
+
+    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&
+/* #ifdef HAVE_BZIP2 */
+                         (s->cur_file_info.compression_method!=Z_BZIP2ED) &&
+/* #endif */
+                         (s->cur_file_info.compression_method!=Z_DEFLATED))
+        err=UNZ_BADZIPFILE;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* date/time */
+        err=UNZ_ERRNO;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* crc */
+        err=UNZ_ERRNO;
+    else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) && ((uFlags & 8)==0))
+        err=UNZ_BADZIPFILE;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size compr */
+        err=UNZ_ERRNO;
+    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) && ((uFlags & 8)==0))
+        err=UNZ_BADZIPFILE;
+
+    if (unz64local_getLong(&s->z_filefunc, s->filestream,&uData) != UNZ_OK) /* size uncompr */
+        err=UNZ_ERRNO;
+    else if (uData != 0xFFFFFFFF && (err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && ((uFlags & 8)==0))
+        err=UNZ_BADZIPFILE;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_filename) != UNZ_OK)
+        err=UNZ_ERRNO;
+    else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))
+        err=UNZ_BADZIPFILE;
+
+    *piSizeVar += (uInt)size_filename;
+
+    if (unz64local_getShort(&s->z_filefunc, s->filestream,&size_extra_field) != UNZ_OK)
+        err=UNZ_ERRNO;
+    *poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +
+                                    SIZEZIPLOCALHEADER + size_filename;
+    *psize_local_extrafield = (uInt)size_extra_field;
+
+    *piSizeVar += (uInt)size_extra_field;
 
     return err;
 }
 
 /*
   Open for reading data the current file in the zipfile.
   If there is no error and the file is opened, the return value is UNZ_OK.
 */
-extern int ZEXPORT unzOpenCurrentFile3(unzFile file, int *method, int *level, int raw, const char *password)
+extern int ZEXPORT unzOpenCurrentFile3 (unzFile file, int* method,
+                                            int* level, int raw, const char* password)
 {
-    unz64_s *s = NULL;
-    file_in_zip64_read_info_s *pfile_in_zip_read_info = NULL;
-    uint16_t compression_method = 0;
-    uint64_t offset_local_extrafield = 0;
-    uint16_t size_local_extrafield = 0;
-    uint32_t size_variable = 0;
-    int err = UNZ_OK;
-#ifndef NOUNCRYPT
+    int err=UNZ_OK;
+    uInt iSizeVar;
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    ZPOS64_T offset_local_extrafield;  /* offset of the local extra field */
+    uInt  size_local_extrafield;    /* size of the local extra field */
+#    ifndef NOUNCRYPT
     char source[12];
-#else
+#    else
     if (password != NULL)
         return UNZ_PARAMERROR;
-#endif
-    if (file == NULL)
+#    endif
+
+    if (file==NULL)
         return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
+    s=(unz64_s*)file;
     if (!s->current_file_ok)
         return UNZ_PARAMERROR;
 
     if (s->pfile_in_zip_read != NULL)
         unzCloseCurrentFile(file);
 
-    if (unzCheckCurrentFileCoherencyHeader(s, &size_variable, &offset_local_extrafield, &size_local_extrafield) != UNZ_OK)
+    if (unz64local_CheckCurrentFileCoherencyHeader(s,&iSizeVar, &offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)
         return UNZ_BADZIPFILE;
 
     pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));
-    if (pfile_in_zip_read_info == NULL)
+    if (pfile_in_zip_read_info==NULL)
         return UNZ_INTERNALERROR;
 
-    pfile_in_zip_read_info->read_buffer = (uint8_t*)ALLOC(UNZ_BUFSIZE);
+    pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);
     pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
     pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
-    pfile_in_zip_read_info->pos_local_extrafield = 0;
-    pfile_in_zip_read_info->raw = raw;
+    pfile_in_zip_read_info->pos_local_extrafield=0;
+    pfile_in_zip_read_info->raw=raw;
 
-    if (pfile_in_zip_read_info->read_buffer == NULL)
+    if (pfile_in_zip_read_info->read_buffer==NULL)
     {
         TRYFREE(pfile_in_zip_read_info);
         return UNZ_INTERNALERROR;
     }
 
-    pfile_in_zip_read_info->stream_initialised = 0;
-
-    compression_method = s->cur_file_info.compression_method;
-#ifdef HAVE_AES
-    if (compression_method == AES_METHOD)
-    {
-        compression_method = s->cur_file_info_internal.aes_compression_method;
-        if (password == NULL)
-        {
-            TRYFREE(pfile_in_zip_read_info);
-            return UNZ_PARAMERROR;
-        }
-    }
-#endif
+    pfile_in_zip_read_info->stream_initialised=0;
 
-    if (method != NULL)
-        *method = compression_method;
+    if (method!=NULL)
+        *method = (int)s->cur_file_info.compression_method;
 
-    if (level != NULL)
+    if (level!=NULL)
     {
         *level = 6;
         switch (s->cur_file_info.flag & 0x06)
         {
           case 6 : *level = 1; break;
           case 4 : *level = 2; break;
           case 2 : *level = 9; break;
         }
     }
 
-    if ((compression_method != 0) && (compression_method != Z_DEFLATED))
-    {
-#ifdef HAVE_BZIP2
-        if (compression_method != Z_BZIP2ED)
-#endif
-        {
-            TRYFREE(pfile_in_zip_read_info);
-            return UNZ_BADZIPFILE;
-        }
-    }
+    if ((s->cur_file_info.compression_method!=0) &&
+/* #ifdef HAVE_BZIP2 */
+        (s->cur_file_info.compression_method!=Z_BZIP2ED) &&
+/* #endif */
+        (s->cur_file_info.compression_method!=Z_DEFLATED))
+
+        err=UNZ_BADZIPFILE;
+
+    pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;
+    pfile_in_zip_read_info->crc32=0;
+    pfile_in_zip_read_info->total_out_64=0;
+    pfile_in_zip_read_info->compression_method = s->cur_file_info.compression_method;
+    pfile_in_zip_read_info->filestream=s->filestream;
+    pfile_in_zip_read_info->z_filefunc=s->z_filefunc;
+    pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;
 
-    pfile_in_zip_read_info->crc32_wait = s->cur_file_info.crc;
-    pfile_in_zip_read_info->crc32 = 0;
-    pfile_in_zip_read_info->total_out_64 = 0;
-    pfile_in_zip_read_info->compression_method = compression_method;
-    pfile_in_zip_read_info->filestream = s->filestream;
-    pfile_in_zip_read_info->z_filefunc = s->z_filefunc;
-    if (s->number_disk == s->gi.number_disk_with_CD)
-        pfile_in_zip_read_info->byte_before_the_zipfile = s->byte_before_the_zipfile;
-    else
-        pfile_in_zip_read_info->byte_before_the_zipfile = 0;
     pfile_in_zip_read_info->stream.total_out = 0;
-    pfile_in_zip_read_info->stream.total_in = 0;
-    pfile_in_zip_read_info->stream.next_in = NULL;
 
-    if (!raw)
+    if ((s->cur_file_info.compression_method==Z_BZIP2ED) && (!raw))
     {
-        if (compression_method == Z_BZIP2ED)
-        {
 #ifdef HAVE_BZIP2
-            pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;
-            pfile_in_zip_read_info->bstream.bzfree = (free_func)0;
-            pfile_in_zip_read_info->bstream.opaque = (voidpf)0;
-            pfile_in_zip_read_info->bstream.state = (voidpf)0;
-
-            pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
-            pfile_in_zip_read_info->stream.zfree = (free_func)0;
-            pfile_in_zip_read_info->stream.opaque = (voidpf)0;
-            pfile_in_zip_read_info->stream.next_in = (voidpf)0;
-            pfile_in_zip_read_info->stream.avail_in = 0;
-
-            err = BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);
-            if (err == Z_OK)
-            {
-                pfile_in_zip_read_info->stream_initialised = Z_BZIP2ED;
-            }
-            else
-            {
-                TRYFREE(pfile_in_zip_read_info);
-                return err;
-            }
-#else
-            pfile_in_zip_read_info->raw = 1;
-#endif
-        }
-        else if (compression_method == Z_DEFLATED)
-        {
-            pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
-            pfile_in_zip_read_info->stream.zfree = (free_func)0;
-            pfile_in_zip_read_info->stream.opaque = (voidpf)s;
-            pfile_in_zip_read_info->stream.next_in = (voidpf)0;
-            pfile_in_zip_read_info->stream.avail_in = 0;
-
-#ifdef HAVE_APPLE_COMPRESSION
-            err = compression_stream_init(&pfile_in_zip_read_info->astream, COMPRESSION_STREAM_DECODE, COMPRESSION_ZLIB);
-            if (err == COMPRESSION_STATUS_ERROR)
-                err = UNZ_INTERNALERROR;
-            else
-                err = Z_OK;
+      pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;
+      pfile_in_zip_read_info->bstream.bzfree = (free_func)0;
+      pfile_in_zip_read_info->bstream.opaque = (voidpf)0;
+      pfile_in_zip_read_info->bstream.state = (voidpf)0;
+
+      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
+      pfile_in_zip_read_info->stream.zfree = (free_func)0;
+      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
+      pfile_in_zip_read_info->stream.next_in = (voidpf)0;
+      pfile_in_zip_read_info->stream.avail_in = 0;
+
+      err=BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);
+      if (err == Z_OK)
+        pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;
+      else
+      {
+        TRYFREE(pfile_in_zip_read_info->read_buffer);
+        TRYFREE(pfile_in_zip_read_info);
+        return err;
+      }
 #else
-            err = inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
+      pfile_in_zip_read_info->raw=1;
 #endif
-            if (err == Z_OK)
-            {
-                pfile_in_zip_read_info->stream_initialised = Z_DEFLATED;
-            }
-            else
-            {
-                TRYFREE(pfile_in_zip_read_info);
-                return err;
-            }
-            /* windowBits is passed < 0 to tell that there is no zlib header.
-             * Note that in this case inflate *requires* an extra "dummy" byte
-             * after the compressed stream in order to complete decompression and
-             * return Z_STREAM_END.
-             * In unzip, i don't wait absolutely Z_STREAM_END because I known the
-             * size of both compressed and uncompressed data
-             */
-        }
     }
+    else if ((s->cur_file_info.compression_method==Z_DEFLATED) && (!raw))
+    {
+      pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
+      pfile_in_zip_read_info->stream.zfree = (free_func)0;
+      pfile_in_zip_read_info->stream.opaque = (voidpf)0;
+      pfile_in_zip_read_info->stream.next_in = 0;
+      pfile_in_zip_read_info->stream.avail_in = 0;
+
+      err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
+      if (err == Z_OK)
+        pfile_in_zip_read_info->stream_initialised=Z_DEFLATED;
+      else
+      {
+        TRYFREE(pfile_in_zip_read_info->read_buffer);
+        TRYFREE(pfile_in_zip_read_info);
+        return err;
+      }
+        /* windowBits is passed < 0 to tell that there is no zlib header.
+         * Note that in this case inflate *requires* an extra "dummy" byte
+         * after the compressed stream in order to complete decompression and
+         * return Z_STREAM_END.
+         * In unzip, i don't wait absolutely Z_STREAM_END because I known the
+         * size of both compressed and uncompressed data
+         */
+    }
+    pfile_in_zip_read_info->rest_read_compressed =
+            s->cur_file_info.compressed_size ;
+    pfile_in_zip_read_info->rest_read_uncompressed =
+            s->cur_file_info.uncompressed_size ;
 
-    pfile_in_zip_read_info->rest_read_compressed = s->cur_file_info.compressed_size;
-    pfile_in_zip_read_info->rest_read_uncompressed = s->cur_file_info.uncompressed_size;
-    pfile_in_zip_read_info->pos_in_zipfile = s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER + size_variable;
-    pfile_in_zip_read_info->stream.avail_in = 0;
 
-    s->pfile_in_zip_read = pfile_in_zip_read_info;
+    pfile_in_zip_read_info->pos_in_zipfile =
+            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER +
+              iSizeVar;
 
-#ifndef NOUNCRYPT
-    s->pcrc_32_tab = NULL;
+    pfile_in_zip_read_info->stream.avail_in = (uInt)0;
 
-    if ((password != NULL) && ((s->cur_file_info.flag & 1) != 0))
+    s->pfile_in_zip_read = pfile_in_zip_read_info;
+                s->encrypted = 0;
+
+#    ifndef NOUNCRYPT
+    if (password != NULL)
     {
+        int i;
+        s->pcrc_32_tab = get_crc_table();
+        init_keys(password,s->keys,s->pcrc_32_tab);
         if (ZSEEK64(s->z_filefunc, s->filestream,
-                  s->pfile_in_zip_read->pos_in_zipfile + s->pfile_in_zip_read->byte_before_the_zipfile,
-                  ZLIB_FILEFUNC_SEEK_SET) != 0)
+                  s->pfile_in_zip_read->pos_in_zipfile +
+                     s->pfile_in_zip_read->byte_before_the_zipfile,
+                  SEEK_SET)!=0)
+            return UNZ_INTERNALERROR;
+        if(ZREAD64(s->z_filefunc, s->filestream,source, 12)<12)
             return UNZ_INTERNALERROR;
-#ifdef HAVE_AES
-        if (s->cur_file_info.compression_method == AES_METHOD)
-        {
-            unsigned char passverify_archive[AES_PWVERIFYSIZE];
-            unsigned char passverify_password[AES_PWVERIFYSIZE];
-            unsigned char salt_value[AES_MAXSALTLENGTH];
-            uint32_t salt_length = 0;
-
-            if ((s->cur_file_info_internal.aes_encryption_mode < 1) ||
-                (s->cur_file_info_internal.aes_encryption_mode > 3))
-                return UNZ_INTERNALERROR;
-
-            salt_length = SALT_LENGTH(s->cur_file_info_internal.aes_encryption_mode);
-
-            if (ZREAD64(s->z_filefunc, s->filestream, salt_value, salt_length) != salt_length)
-                return UNZ_INTERNALERROR;
-            if (ZREAD64(s->z_filefunc, s->filestream, passverify_archive, AES_PWVERIFYSIZE) != AES_PWVERIFYSIZE)
-                return UNZ_INTERNALERROR;
-
-            fcrypt_init(s->cur_file_info_internal.aes_encryption_mode, (uint8_t *)password,
-                (uint32_t)strlen(password), salt_value, passverify_password, &s->pfile_in_zip_read->aes_ctx);
-
-            if (memcmp(passverify_archive, passverify_password, AES_PWVERIFYSIZE) != 0)
-                return UNZ_BADPASSWORD;
-
-            s->pfile_in_zip_read->rest_read_compressed -= salt_length + AES_PWVERIFYSIZE;
-            s->pfile_in_zip_read->rest_read_compressed -= AES_AUTHCODESIZE;
-
-            s->pfile_in_zip_read->pos_in_zipfile += salt_length + AES_PWVERIFYSIZE;
-        }
-        else
-#endif
-        {
-            int i;
-            s->pcrc_32_tab = (const z_crc_t*)get_crc_table();
-            init_keys(password, s->keys, s->pcrc_32_tab);
-
-            if (ZREAD64(s->z_filefunc, s->filestream, source, 12) < 12)
-                return UNZ_INTERNALERROR;
 
-            for (i = 0; i < 12; i++)
-                zdecode(s->keys, s->pcrc_32_tab, source[i]);
+        for (i = 0; i<12; i++)
+            zdecode(s->keys,s->pcrc_32_tab,source[i]);
 
-            s->pfile_in_zip_read->rest_read_compressed -= 12;
-            s->pfile_in_zip_read->pos_in_zipfile += 12;
-        }
+        s->pfile_in_zip_read->pos_in_zipfile+=12;
+        s->encrypted=1;
     }
-#endif
+#    endif
+
 
     return UNZ_OK;
 }
 
-extern int ZEXPORT unzOpenCurrentFile(unzFile file)
+extern int ZEXPORT unzOpenCurrentFile (unzFile file)
 {
     return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);
 }
 
-extern int ZEXPORT unzOpenCurrentFilePassword(unzFile file, const char *password)
+extern int ZEXPORT unzOpenCurrentFilePassword (unzFile file, const char*  password)
 {
     return unzOpenCurrentFile3(file, NULL, NULL, 0, password);
 }
 
-extern int ZEXPORT unzOpenCurrentFile2(unzFile file, int *method, int *level, int raw)
+extern int ZEXPORT unzOpenCurrentFile2 (unzFile file, int* method, int* level, int raw)
 {
     return unzOpenCurrentFile3(file, method, level, raw, NULL);
 }
 
-/* Read bytes from the current file.
-   buf contain buffer where data must be copied
-   len the size of buf.
+/** Addition for GDAL : START */
 
-   return the number of byte copied if some bytes are copied
-   return 0 if the end of file was reached
-   return <0 with error code if there is an error (UNZ_ERRNO for IO error, or zLib error for uncompress error) */
-extern int ZEXPORT unzReadCurrentFile(unzFile file, voidp buf, uint32_t len)
+extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64( unzFile file)
 {
-    unz64_s *s = NULL;
-    uint32_t read = 0;
-    int err = UNZ_OK;
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    s=(unz64_s*)file;
+    if (file==NULL)
+        return 0; //UNZ_PARAMERROR;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+    if (pfile_in_zip_read_info==NULL)
+        return 0; //UNZ_PARAMERROR;
+    return pfile_in_zip_read_info->pos_in_zipfile +
+                         pfile_in_zip_read_info->byte_before_the_zipfile;
+}
+
+/** Addition for GDAL : END */
 
-    if (file == NULL)
+/*
+  Read bytes from the current file.
+  buf contain buffer where data must be copied
+  len the size of buf.
+
+  return the number of byte copied if somes bytes are copied
+  return 0 if the end of file was reached
+  return <0 with error code if there is an error
+    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
+*/
+extern int ZEXPORT unzReadCurrentFile  (unzFile file, voidp buf, unsigned len)
+{
+    int err=UNZ_OK;
+    uInt iRead = 0;
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
         return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
 
-    if (s->pfile_in_zip_read == NULL)
+    if (pfile_in_zip_read_info==NULL)
         return UNZ_PARAMERROR;
-    if (s->pfile_in_zip_read->read_buffer == NULL)
+
+
+    if (pfile_in_zip_read_info->read_buffer == NULL)
         return UNZ_END_OF_LIST_OF_FILE;
-    if (len == 0)
+    if (len==0)
         return 0;
-    if (len > UINT16_MAX)
-        return UNZ_PARAMERROR;
 
-    s->pfile_in_zip_read->stream.next_out = (uint8_t*)buf;
-    s->pfile_in_zip_read->stream.avail_out = (uint16_t)len;
+    pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;
 
-    if (s->pfile_in_zip_read->raw)
-    {
-        if (len > s->pfile_in_zip_read->rest_read_compressed + s->pfile_in_zip_read->stream.avail_in)
-            s->pfile_in_zip_read->stream.avail_out = (uint16_t)s->pfile_in_zip_read->rest_read_compressed +
-                s->pfile_in_zip_read->stream.avail_in;
-    }
-    else
-    {
-        if (len > s->pfile_in_zip_read->rest_read_uncompressed)
-            s->pfile_in_zip_read->stream.avail_out = (uint16_t)s->pfile_in_zip_read->rest_read_uncompressed;
-    }
+    pfile_in_zip_read_info->stream.avail_out = (uInt)len;
 
-    do
+    if ((len>pfile_in_zip_read_info->rest_read_uncompressed) &&
+        (!(pfile_in_zip_read_info->raw)))
+        pfile_in_zip_read_info->stream.avail_out =
+            (uInt)pfile_in_zip_read_info->rest_read_uncompressed;
+
+    if ((len>pfile_in_zip_read_info->rest_read_compressed+
+           pfile_in_zip_read_info->stream.avail_in) &&
+         (pfile_in_zip_read_info->raw))
+        pfile_in_zip_read_info->stream.avail_out =
+            (uInt)pfile_in_zip_read_info->rest_read_compressed+
+            pfile_in_zip_read_info->stream.avail_in;
+
+    while (pfile_in_zip_read_info->stream.avail_out>0)
     {
-        if (s->pfile_in_zip_read->stream.avail_in == 0)
+        if ((pfile_in_zip_read_info->stream.avail_in==0) &&
+            (pfile_in_zip_read_info->rest_read_compressed>0))
         {
-            uint32_t bytes_to_read = UNZ_BUFSIZE;
-            uint32_t bytes_not_read = 0;
-            uint32_t bytes_read = 0;
-            uint32_t total_bytes_read = 0;
-
-            if (s->pfile_in_zip_read->stream.next_in != NULL)
-                bytes_not_read = (uint32_t)(s->pfile_in_zip_read->read_buffer + UNZ_BUFSIZE -
-                    s->pfile_in_zip_read->stream.next_in);
-            bytes_to_read -= bytes_not_read;
-            if (bytes_not_read > 0)
-                memcpy(s->pfile_in_zip_read->read_buffer, s->pfile_in_zip_read->stream.next_in, bytes_not_read);
-            if (s->pfile_in_zip_read->rest_read_compressed < bytes_to_read)
-                bytes_to_read = (uint16_t)s->pfile_in_zip_read->rest_read_compressed;
-
-            while (total_bytes_read != bytes_to_read)
+            uInt uReadThis = UNZ_BUFSIZE;
+            if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)
+                uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;
+            if (uReadThis == 0)
+                return UNZ_EOF;
+            if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
+                      pfile_in_zip_read_info->filestream,
+                      pfile_in_zip_read_info->pos_in_zipfile +
+                         pfile_in_zip_read_info->byte_before_the_zipfile,
+                         ZLIB_FILEFUNC_SEEK_SET)!=0)
+                return UNZ_ERRNO;
+            if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
+                      pfile_in_zip_read_info->filestream,
+                      pfile_in_zip_read_info->read_buffer,
+                      uReadThis)!=uReadThis)
+                return UNZ_ERRNO;
+
+
+#            ifndef NOUNCRYPT
+            if(s->encrypted)
             {
-                if (ZSEEK64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream,
-                        s->pfile_in_zip_read->pos_in_zipfile + s->pfile_in_zip_read->byte_before_the_zipfile,
-                        ZLIB_FILEFUNC_SEEK_SET) != 0)
-                    return UNZ_ERRNO;
-
-                bytes_read = ZREAD64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream,
-                          s->pfile_in_zip_read->read_buffer + bytes_not_read + total_bytes_read,
-                          bytes_to_read - total_bytes_read);
-
-                total_bytes_read += bytes_read;
-                s->pfile_in_zip_read->pos_in_zipfile += bytes_read;
-
-                if (bytes_read == 0)
-                {
-                    if (ZERROR64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream))
-                        return UNZ_ERRNO;
-
-                    err = unzGoToNextDisk(file);
-                    if (err != UNZ_OK)
-                        return err;
-
-                    s->pfile_in_zip_read->pos_in_zipfile = 0;
-                    s->pfile_in_zip_read->filestream = s->filestream;
-                }
+                uInt i;
+                for(i=0;i<uReadThis;i++)
+                  pfile_in_zip_read_info->read_buffer[i] =
+                      zdecode(s->keys,s->pcrc_32_tab,
+                              pfile_in_zip_read_info->read_buffer[i]);
             }
+#            endif
 
-#ifndef NOUNCRYPT
-            if ((s->cur_file_info.flag & 1) != 0)
-            {
-#ifdef HAVE_AES
-                if (s->cur_file_info.compression_method == AES_METHOD)
-                {
-                    fcrypt_decrypt(s->pfile_in_zip_read->read_buffer, bytes_to_read, &s->pfile_in_zip_read->aes_ctx);
-                }
-                else
-#endif
-                if (s->pcrc_32_tab != NULL)
-                {
-                    uint32_t i = 0;
-
-                    for (i = 0; i < total_bytes_read; i++)
-                      s->pfile_in_zip_read->read_buffer[i] =
-                          zdecode(s->keys, s->pcrc_32_tab, s->pfile_in_zip_read->read_buffer[i]);
-                }
-            }
-#endif
 
-            s->pfile_in_zip_read->rest_read_compressed -= total_bytes_read;
-            s->pfile_in_zip_read->stream.next_in = (uint8_t*)s->pfile_in_zip_read->read_buffer;
-            s->pfile_in_zip_read->stream.avail_in = (uint16_t)(bytes_not_read + total_bytes_read);
+            pfile_in_zip_read_info->pos_in_zipfile += uReadThis;
+
+            pfile_in_zip_read_info->rest_read_compressed-=uReadThis;
+
+            pfile_in_zip_read_info->stream.next_in =
+                (Bytef*)pfile_in_zip_read_info->read_buffer;
+            pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;
         }
 
-        if ((s->pfile_in_zip_read->compression_method == 0) || (s->pfile_in_zip_read->raw))
+        if ((pfile_in_zip_read_info->compression_method==0) || (pfile_in_zip_read_info->raw))
         {
-            uint32_t i = 0;
-            uint32_t copy = 0;
+            uInt uDoCopy,i ;
 
-            if ((s->pfile_in_zip_read->stream.avail_in == 0) &&
-                (s->pfile_in_zip_read->rest_read_compressed == 0))
-                return (read == 0) ? UNZ_EOF : read;
+            if ((pfile_in_zip_read_info->stream.avail_in == 0) &&
+                (pfile_in_zip_read_info->rest_read_compressed == 0))
+                return (iRead==0) ? UNZ_EOF : (int)iRead;
 
-            if (s->pfile_in_zip_read->stream.avail_out < s->pfile_in_zip_read->stream.avail_in)
-                copy = s->pfile_in_zip_read->stream.avail_out;
+            if (pfile_in_zip_read_info->stream.avail_out <
+                            pfile_in_zip_read_info->stream.avail_in)
+                uDoCopy = pfile_in_zip_read_info->stream.avail_out ;
             else
-                copy = s->pfile_in_zip_read->stream.avail_in;
-
-            for (i = 0; i < copy; i++)
-                *(s->pfile_in_zip_read->stream.next_out + i) =
-                        *(s->pfile_in_zip_read->stream.next_in + i);
-
-            s->pfile_in_zip_read->total_out_64 = s->pfile_in_zip_read->total_out_64 + copy;
-            s->pfile_in_zip_read->rest_read_uncompressed -= copy;
-            s->pfile_in_zip_read->crc32 = (uint32_t)crc32(s->pfile_in_zip_read->crc32,
-                                s->pfile_in_zip_read->stream.next_out, copy);
-
-            s->pfile_in_zip_read->stream.avail_in -= copy;
-            s->pfile_in_zip_read->stream.avail_out -= copy;
-            s->pfile_in_zip_read->stream.next_out += copy;
-            s->pfile_in_zip_read->stream.next_in += copy;
-            s->pfile_in_zip_read->stream.total_out += copy;
-
-            read += copy;
+                uDoCopy = pfile_in_zip_read_info->stream.avail_in ;
+
+            for (i=0;i<uDoCopy;i++)
+                *(pfile_in_zip_read_info->stream.next_out+i) =
+                        *(pfile_in_zip_read_info->stream.next_in+i);
+
+            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uDoCopy;
+
+            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,
+                                pfile_in_zip_read_info->stream.next_out,
+                                uDoCopy);
+            pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;
+            pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
+            pfile_in_zip_read_info->stream.avail_out -= uDoCopy;
+            pfile_in_zip_read_info->stream.next_out += uDoCopy;
+            pfile_in_zip_read_info->stream.next_in += uDoCopy;
+            pfile_in_zip_read_info->stream.total_out += uDoCopy;
+            iRead += uDoCopy;
         }
-        else if (s->pfile_in_zip_read->compression_method == Z_BZIP2ED)
+        else if (pfile_in_zip_read_info->compression_method==Z_BZIP2ED)
         {
 #ifdef HAVE_BZIP2
-            uint64_t total_out_before = 0;
-            uint64_t total_out_after = 0;
-            uint64_t out_bytes = 0;
-            const uint8_t *buf_before = NULL;
-
-            s->pfile_in_zip_read->bstream.next_in        = (char*)s->pfile_in_zip_read->stream.next_in;
-            s->pfile_in_zip_read->bstream.avail_in       = s->pfile_in_zip_read->stream.avail_in;
-            s->pfile_in_zip_read->bstream.total_in_lo32  = (uint32_t)s->pfile_in_zip_read->stream.total_in;
-            s->pfile_in_zip_read->bstream.total_in_hi32  = s->pfile_in_zip_read->stream.total_in >> 32;
-            
-            s->pfile_in_zip_read->bstream.next_out       = (char*)s->pfile_in_zip_read->stream.next_out;
-            s->pfile_in_zip_read->bstream.avail_out      = s->pfile_in_zip_read->stream.avail_out;
-            s->pfile_in_zip_read->bstream.total_out_lo32 = (uint32_t)s->pfile_in_zip_read->stream.total_out;
-            s->pfile_in_zip_read->bstream.total_out_hi32 = s->pfile_in_zip_read->stream.total_out >> 32;
-
-            total_out_before = s->pfile_in_zip_read->bstream.total_out_lo32 + 
-                (((uint32_t)s->pfile_in_zip_read->bstream.total_out_hi32) << 32);
-            buf_before = (const uint8_t*)s->pfile_in_zip_read->bstream.next_out;
-
-            err = BZ2_bzDecompress(&s->pfile_in_zip_read->bstream);
-
-            total_out_after = s->pfile_in_zip_read->bstream.total_out_lo32 + 
-                (((uint32_t)s->pfile_in_zip_read->bstream.total_out_hi32) << 32);
-
-            out_bytes = total_out_after - total_out_before;
-
-            s->pfile_in_zip_read->total_out_64 = s->pfile_in_zip_read->total_out_64 + out_bytes;
-            s->pfile_in_zip_read->rest_read_uncompressed -= out_bytes;
-            s->pfile_in_zip_read->crc32 = crc32(s->pfile_in_zip_read->crc32, buf_before, (uint32_t)out_bytes);
-
-            read += (uint32_t)out_bytes;
-
-            s->pfile_in_zip_read->stream.next_in   = (uint8_t*)s->pfile_in_zip_read->bstream.next_in;
-            s->pfile_in_zip_read->stream.avail_in  = s->pfile_in_zip_read->bstream.avail_in;
-            s->pfile_in_zip_read->stream.total_in  = s->pfile_in_zip_read->bstream.total_in_lo32;
-            s->pfile_in_zip_read->stream.next_out  = (uint8_t*)s->pfile_in_zip_read->bstream.next_out;
-            s->pfile_in_zip_read->stream.avail_out = s->pfile_in_zip_read->bstream.avail_out;
-            s->pfile_in_zip_read->stream.total_out = s->pfile_in_zip_read->bstream.total_out_lo32;
-
-            if (err == BZ_STREAM_END)
-                return (read == 0) ? UNZ_EOF : read;
-            if (err != BZ_OK)
-                break;
+            uLong uTotalOutBefore,uTotalOutAfter;
+            const Bytef *bufBefore;
+            uLong uOutThis;
+
+            pfile_in_zip_read_info->bstream.next_in        = (char*)pfile_in_zip_read_info->stream.next_in;
+            pfile_in_zip_read_info->bstream.avail_in       = pfile_in_zip_read_info->stream.avail_in;
+            pfile_in_zip_read_info->bstream.total_in_lo32  = pfile_in_zip_read_info->stream.total_in;
+            pfile_in_zip_read_info->bstream.total_in_hi32  = 0;
+            pfile_in_zip_read_info->bstream.next_out       = (char*)pfile_in_zip_read_info->stream.next_out;
+            pfile_in_zip_read_info->bstream.avail_out      = pfile_in_zip_read_info->stream.avail_out;
+            pfile_in_zip_read_info->bstream.total_out_lo32 = pfile_in_zip_read_info->stream.total_out;
+            pfile_in_zip_read_info->bstream.total_out_hi32 = 0;
+
+            uTotalOutBefore = pfile_in_zip_read_info->bstream.total_out_lo32;
+            bufBefore = (const Bytef *)pfile_in_zip_read_info->bstream.next_out;
+
+            err=BZ2_bzDecompress(&pfile_in_zip_read_info->bstream);
+
+            uTotalOutAfter = pfile_in_zip_read_info->bstream.total_out_lo32;
+            uOutThis = uTotalOutAfter-uTotalOutBefore;
+
+            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;
+
+            pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,bufBefore, (uInt)(uOutThis));
+            pfile_in_zip_read_info->rest_read_uncompressed -= uOutThis;
+            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
+
+            pfile_in_zip_read_info->stream.next_in   = (Bytef*)pfile_in_zip_read_info->bstream.next_in;
+            pfile_in_zip_read_info->stream.avail_in  = pfile_in_zip_read_info->bstream.avail_in;
+            pfile_in_zip_read_info->stream.total_in  = pfile_in_zip_read_info->bstream.total_in_lo32;
+            pfile_in_zip_read_info->stream.next_out  = (Bytef*)pfile_in_zip_read_info->bstream.next_out;
+            pfile_in_zip_read_info->stream.avail_out = pfile_in_zip_read_info->bstream.avail_out;
+            pfile_in_zip_read_info->stream.total_out = pfile_in_zip_read_info->bstream.total_out_lo32;
+
+            if (err==BZ_STREAM_END)
+              return (iRead==0) ? UNZ_EOF : iRead;
+            if (err!=BZ_OK)
+              break;
 #endif
-        }
-#ifdef HAVE_APPLE_COMPRESSION
-        else
-        {
-            uint64_t total_out_before = 0;
-            uint64_t total_out_after = 0;
-            uint64_t out_bytes = 0;
-            const uint8_t *buf_before = NULL;
-
-            s->pfile_in_zip_read->astream.src_ptr = s->pfile_in_zip_read->stream.next_in;
-            s->pfile_in_zip_read->astream.src_size = s->pfile_in_zip_read->stream.avail_in;
-            s->pfile_in_zip_read->astream.dst_ptr = s->pfile_in_zip_read->stream.next_out;
-            s->pfile_in_zip_read->astream.dst_size = len;
-
-            total_out_before = s->pfile_in_zip_read->stream.total_out;
-            buf_before = s->pfile_in_zip_read->stream.next_out;
-
-            compression_status status;
-            compression_stream_flags flags;
-
-            if (s->pfile_in_zip_read->stream.avail_in == 0)
-            {
-                flags = COMPRESSION_STREAM_FINALIZE;
-            }
-
-            status = compression_stream_process(&s->pfile_in_zip_read->astream, flags);
-
-            total_out_after = len - s->pfile_in_zip_read->astream.dst_size;
-            out_bytes = total_out_after - total_out_before;
-
-            s->pfile_in_zip_read->total_out_64 += out_bytes;
-            s->pfile_in_zip_read->rest_read_uncompressed -= out_bytes;
-            s->pfile_in_zip_read->crc32 =
-                crc32(s->pfile_in_zip_read->crc32, buf_before, (uint32_t)out_bytes);
-
-            read += (uint32_t)out_bytes;
-
-            s->pfile_in_zip_read->stream.next_in = s->pfile_in_zip_read->astream.src_ptr;
-            s->pfile_in_zip_read->stream.avail_in = s->pfile_in_zip_read->astream.src_size;
-            s->pfile_in_zip_read->stream.next_out = s->pfile_in_zip_read->astream.dst_ptr;
-            s->pfile_in_zip_read->stream.avail_out = s->pfile_in_zip_read->astream.dst_size;
-
-            if (status == COMPRESSION_STATUS_END)
-                return (read == 0) ? UNZ_EOF : read;
-            if (status == COMPRESSION_STATUS_ERROR)
-                return Z_DATA_ERROR;
-            return read;
-        }
-#else
+        } // end Z_BZIP2ED
         else
         {
-            uint64_t total_out_before = 0;
-            uint64_t total_out_after = 0;
-            uint64_t out_bytes = 0;
-            const uint8_t *buf_before = NULL;
-            int flush = Z_SYNC_FLUSH;
+            ZPOS64_T uTotalOutBefore,uTotalOutAfter;
+            const Bytef *bufBefore;
+            ZPOS64_T uOutThis;
+            int flush=Z_SYNC_FLUSH;
 
-            total_out_before = s->pfile_in_zip_read->stream.total_out;
-            buf_before = s->pfile_in_zip_read->stream.next_out;
+            uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;
+            bufBefore = pfile_in_zip_read_info->stream.next_out;
 
             /*
             if ((pfile_in_zip_read_info->rest_read_uncompressed ==
                      pfile_in_zip_read_info->stream.avail_out) &&
                 (pfile_in_zip_read_info->rest_read_compressed == 0))
                 flush = Z_FINISH;
             */
-            err = inflate(&s->pfile_in_zip_read->stream, flush);
+            err=inflate(&pfile_in_zip_read_info->stream,flush);
+
+            if ((err>=0) && (pfile_in_zip_read_info->stream.msg!=NULL))
+              err = Z_DATA_ERROR;
+
+            uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;
+            /* Detect overflow, because z_stream.total_out is uLong (32 bits) */
+            if (uTotalOutAfter<uTotalOutBefore)
+                uTotalOutAfter += 1LL << 32; /* Add maximum value of uLong + 1 */
+            uOutThis = uTotalOutAfter-uTotalOutBefore;
 
-            if ((err >= 0) && (s->pfile_in_zip_read->stream.msg != NULL))
-                err = Z_DATA_ERROR;
+            pfile_in_zip_read_info->total_out_64 = pfile_in_zip_read_info->total_out_64 + uOutThis;
 
-            total_out_after = s->pfile_in_zip_read->stream.total_out;
-            out_bytes = total_out_after - total_out_before;
+            pfile_in_zip_read_info->crc32 =
+                crc32(pfile_in_zip_read_info->crc32,bufBefore,
+                        (uInt)(uOutThis));
 
-            s->pfile_in_zip_read->total_out_64 += out_bytes;
-            s->pfile_in_zip_read->rest_read_uncompressed -= out_bytes;
-            s->pfile_in_zip_read->crc32 =
-                (uint32_t)crc32(s->pfile_in_zip_read->crc32,buf_before, (uint32_t)out_bytes);
+            pfile_in_zip_read_info->rest_read_uncompressed -=
+                uOutThis;
 
-            read += (uint32_t)out_bytes;
+            iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
 
-            if (err == Z_STREAM_END)
-                return (read == 0) ? UNZ_EOF : read;
-            if (err != Z_OK)
+            if (err==Z_STREAM_END)
+                return (iRead==0) ? UNZ_EOF : (int)iRead;
+            if (err!=Z_OK)
                 break;
         }
-#endif
     }
-    while (s->pfile_in_zip_read->stream.avail_out > 0);
 
-    if (err == Z_OK)
-        return read;
+    if (err==Z_OK)
+        return (int)iRead;
     return err;
 }
 
-extern int ZEXPORT unzGetLocalExtrafield(unzFile file, voidp buf, uint32_t len)
+
+/*
+  Give the current position in uncompressed data
+*/
+extern z_off_t ZEXPORT unztell (unzFile file)
 {
-    unz64_s *s = NULL;
-    uint64_t size_to_read = 0;
-    uint32_t read_now = 0;
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
 
-    if (file == NULL)
+    if (pfile_in_zip_read_info==NULL)
         return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-    if (s->pfile_in_zip_read == NULL)
+
+    return (z_off_t)pfile_in_zip_read_info->stream.total_out;
+}
+
+extern ZPOS64_T ZEXPORT unztell64 (unzFile file)
+{
+
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
+        return (ZPOS64_T)-1;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+    if (pfile_in_zip_read_info==NULL)
+        return (ZPOS64_T)-1;
+
+    return pfile_in_zip_read_info->total_out_64;
+}
+
+
+/*
+  return 1 if the end of file was reached, 0 elsewhere
+*/
+extern int ZEXPORT unzeof (unzFile file)
+{
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
         return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
 
-    size_to_read = s->pfile_in_zip_read->size_local_extrafield - s->pfile_in_zip_read->pos_local_extrafield;
+    if (pfile_in_zip_read_info==NULL)
+        return UNZ_PARAMERROR;
 
-    if (buf == NULL)
+    if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
+        return 1;
+    else
+        return 0;
+}
+
+
+
+/*
+Read extra field from the current file (opened by unzOpenCurrentFile)
+This is the local-header version of the extra field (sometimes, there is
+more info in the local-header version than in the central-header)
+
+  if buf==NULL, it return the size of the local extra field that can be read
+
+  if buf!=NULL, len is the size of the buffer, the extra header is copied in
+    buf.
+  the return value is the number of bytes copied in buf, or (if <0)
+    the error code
+*/
+extern int ZEXPORT unzGetLocalExtrafield (unzFile file, voidp buf, unsigned len)
+{
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    uInt read_now;
+    ZPOS64_T size_to_read;
+
+    if (file==NULL)
+        return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
+
+    if (pfile_in_zip_read_info==NULL)
+        return UNZ_PARAMERROR;
+
+    size_to_read = (pfile_in_zip_read_info->size_local_extrafield -
+                pfile_in_zip_read_info->pos_local_extrafield);
+
+    if (buf==NULL)
         return (int)size_to_read;
 
-    if (len > size_to_read)
-        read_now = (uint32_t)size_to_read;
+    if (len>size_to_read)
+        read_now = (uInt)size_to_read;
     else
-        read_now = len;
+        read_now = (uInt)len ;
 
-    if (read_now == 0)
+    if (read_now==0)
         return 0;
 
-    if (ZSEEK64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream,
-        s->pfile_in_zip_read->offset_local_extrafield + s->pfile_in_zip_read->pos_local_extrafield,
-        ZLIB_FILEFUNC_SEEK_SET) != 0)
+    if (ZSEEK64(pfile_in_zip_read_info->z_filefunc,
+              pfile_in_zip_read_info->filestream,
+              pfile_in_zip_read_info->offset_local_extrafield +
+              pfile_in_zip_read_info->pos_local_extrafield,
+              ZLIB_FILEFUNC_SEEK_SET)!=0)
         return UNZ_ERRNO;
 
-    if (ZREAD64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream, buf, read_now) != read_now)
+    if (ZREAD64(pfile_in_zip_read_info->z_filefunc,
+              pfile_in_zip_read_info->filestream,
+              buf,read_now)!=read_now)
         return UNZ_ERRNO;
 
     return (int)read_now;
 }
 
-extern int ZEXPORT unzCloseCurrentFile(unzFile file)
+/*
+  Close the file in zip opened with unzOpenCurrentFile
+  Return UNZ_CRCERROR if all the file was read but the CRC is not good
+*/
+extern int ZEXPORT unzCloseCurrentFile (unzFile file)
 {
-    unz64_s *s = NULL;
-    file_in_zip64_read_info_s *pfile_in_zip_read_info = NULL;
-    int err = UNZ_OK;
+    int err=UNZ_OK;
 
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-    pfile_in_zip_read_info = s->pfile_in_zip_read;
-    if (pfile_in_zip_read_info == NULL)
+    unz64_s* s;
+    file_in_zip64_read_info_s* pfile_in_zip_read_info;
+    if (file==NULL)
         return UNZ_PARAMERROR;
+    s=(unz64_s*)file;
+    pfile_in_zip_read_info=s->pfile_in_zip_read;
 
-#ifdef HAVE_AES
-    if (s->cur_file_info.compression_method == AES_METHOD)
-    {
-        unsigned char authcode[AES_AUTHCODESIZE];
-        unsigned char rauthcode[AES_AUTHCODESIZE];
+    if (pfile_in_zip_read_info==NULL)
+        return UNZ_PARAMERROR;
 
-        if (ZREAD64(s->z_filefunc, s->filestream, authcode, AES_AUTHCODESIZE) != AES_AUTHCODESIZE)
-            return UNZ_ERRNO;
 
-        if (fcrypt_end(rauthcode, &s->pfile_in_zip_read->aes_ctx) != AES_AUTHCODESIZE)
-            err = UNZ_CRCERROR;
-        if (memcmp(authcode, rauthcode, AES_AUTHCODESIZE) != 0)
-            err = UNZ_CRCERROR;
-    }
-    /* AES zip version AE-1 will expect a valid crc as well */
-    if ((s->cur_file_info.compression_method != AES_METHOD) ||
-        (s->cur_file_info_internal.aes_version == 0x0001))
-#endif
+    if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&
+        (!pfile_in_zip_read_info->raw))
     {
-        if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&
-            (!pfile_in_zip_read_info->raw))
-        {
-            if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
-                err = UNZ_CRCERROR;
-        }
+        if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
+            err=UNZ_CRCERROR;
     }
 
+
     TRYFREE(pfile_in_zip_read_info->read_buffer);
     pfile_in_zip_read_info->read_buffer = NULL;
     if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)
-    {
-#ifdef HAVE_APPLE_COMPRESSION
-        if (compression_stream_destroy)
-            compression_stream_destroy(&pfile_in_zip_read_info->astream);
-#else
         inflateEnd(&pfile_in_zip_read_info->stream);
-#endif
-        
-    }
 #ifdef HAVE_BZIP2
     else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)
         BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);
 #endif
 
+
     pfile_in_zip_read_info->stream_initialised = 0;
     TRYFREE(pfile_in_zip_read_info);
 
-    s->pfile_in_zip_read = NULL;
-
-    return err;
-}
-
-extern int ZEXPORT unzGoToFirstFile2(unzFile file, unz_file_info64 *pfile_info, char *filename,
-    uint16_t filename_size, void *extrafield, uint16_t extrafield_size, char *comment, uint16_t comment_size)
-{
-    unz64_s *s = NULL;
-    int err = UNZ_OK;
-
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-
-    s->pos_in_central_dir = s->offset_central_dir;
-    s->num_file = 0;
-
-    err = unzGetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal,
-            filename, filename_size, extrafield, extrafield_size, comment,comment_size);
-
-    s->current_file_ok = (err == UNZ_OK);
-    if ((err == UNZ_OK) && (pfile_info != NULL))
-        memcpy(pfile_info, &s->cur_file_info, sizeof(unz_file_info64));
+    s->pfile_in_zip_read=NULL;
 
     return err;
 }
 
-extern int ZEXPORT unzGoToFirstFile(unzFile file)
-{
-    return unzGoToFirstFile2(file, NULL, NULL, 0, NULL, 0, NULL, 0);
-}
-
-extern int ZEXPORT unzGoToNextFile2(unzFile file, unz_file_info64 *pfile_info, char *filename,
-    uint16_t filename_size, void *extrafield, uint16_t extrafield_size, char *comment, uint16_t comment_size)
-{
-    unz64_s *s = NULL;
-    int err = UNZ_OK;
 
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-    if (s->gi.number_entry != UINT16_MAX)    /* 2^16 files overflow hack */
-    {
-        if (s->num_file+1 == s->gi.number_entry)
-            return UNZ_END_OF_LIST_OF_FILE;
-    }
-
-    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
-            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment;
-    s->num_file += 1;
-
-    err = unzGetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal,
-            filename, filename_size, extrafield,extrafield_size, comment, comment_size);
-
-    s->current_file_ok = (err == UNZ_OK);
-    if ((err == UNZ_OK) && (pfile_info != NULL))
-        memcpy(pfile_info, &s->cur_file_info, sizeof(unz_file_info64));
-
-    return err;
-}
-
-extern int ZEXPORT unzGoToNextFile(unzFile file)
-{
-    return unzGoToNextFile2(file, NULL, NULL, 0, NULL, 0, NULL, 0);
-}
-
-extern int ZEXPORT unzLocateFile(unzFile file, const char *filename, unzFileNameComparer filename_compare_func)
+/*
+  Get the global comment string of the ZipFile, in the szComment buffer.
+  uSizeBuf is the size of the szComment buffer.
+  return the number of byte copied or an error code <0
+*/
+extern int ZEXPORT unzGetGlobalComment (unzFile file, char * szComment, uLong uSizeBuf)
 {
-    unz64_s *s = NULL;
-    unz_file_info64 cur_file_info_saved;
-    unz_file_info64_internal cur_file_info_internal_saved;
-    uint64_t num_file_saved = 0;
-    uint64_t pos_in_central_dir_saved = 0;
-    char current_filename[UNZ_MAXFILENAMEINZIP+1];
-    int err = UNZ_OK;
-
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    if (strlen(filename) >= UNZ_MAXFILENAMEINZIP)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-    if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    /* Save the current state */
-    num_file_saved = s->num_file;
-    pos_in_central_dir_saved = s->pos_in_central_dir;
-    cur_file_info_saved = s->cur_file_info;
-    cur_file_info_internal_saved = s->cur_file_info_internal;
-
-    err = unzGoToFirstFile2(file, NULL, current_filename, sizeof(current_filename)-1, NULL, 0, NULL, 0);
+    unz64_s* s;
+    uLong uReadThis ;
+    if (file==NULL)
+        return (int)UNZ_PARAMERROR;
+    s=(unz64_s*)file;
 
-    while (err == UNZ_OK)
-    {
-        if (filename_compare_func != NULL)
-            err = filename_compare_func(file, current_filename, filename);
-        else
-            err = strcmp(current_filename, filename);
-        if (err == 0)
-            return UNZ_OK;
-        err = unzGoToNextFile2(file, NULL, current_filename, sizeof(current_filename)-1, NULL, 0, NULL, 0);
-    }
+    uReadThis = uSizeBuf;
+    if (uReadThis>s->gi.size_comment)
+        uReadThis = s->gi.size_comment;
 
-    /* We failed, so restore the state of the 'current file' to where we were. */
-    s->num_file = num_file_saved;
-    s->pos_in_central_dir = pos_in_central_dir_saved;
-    s->cur_file_info = cur_file_info_saved;
-    s->cur_file_info_internal = cur_file_info_internal_saved;
-    return err;
-}
+    if (ZSEEK64(s->z_filefunc,s->filestream,s->central_pos+22,ZLIB_FILEFUNC_SEEK_SET)!=0)
+        return UNZ_ERRNO;
 
-extern int ZEXPORT unzGetFilePos(unzFile file, unz_file_pos *file_pos)
-{
-    unz64_file_pos file_pos64;
-    int err = unzGetFilePos64(file, &file_pos64);
-    if (err == UNZ_OK)
+    if (uReadThis>0)
     {
-        file_pos->pos_in_zip_directory = (uint32_t)file_pos64.pos_in_zip_directory;
-        file_pos->num_of_file = (uint32_t)file_pos64.num_of_file;
+      *szComment='\0';
+      if (ZREAD64(s->z_filefunc,s->filestream,szComment,uReadThis)!=uReadThis)
+        return UNZ_ERRNO;
     }
-    return err;
-}
 
-extern int ZEXPORT unzGoToFilePos(unzFile file, unz_file_pos *file_pos)
-{
-    unz64_file_pos file_pos64;
-    if (file_pos == NULL)
-        return UNZ_PARAMERROR;
-    file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;
-    file_pos64.num_of_file = file_pos->num_of_file;
-    return unzGoToFilePos64(file, &file_pos64);
+    if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))
+        *(szComment+s->gi.size_comment)='\0';
+    return (int)uReadThis;
 }
 
-extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos *file_pos)
+/* Additions by RX '2004 */
+extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)
 {
-    unz64_s *s = NULL;
+    unz64_s* s;
 
-    if (file == NULL || file_pos == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
+    if (file==NULL)
+          return 0; //UNZ_PARAMERROR;
+    s=(unz64_s*)file;
     if (!s->current_file_ok)
-        return UNZ_END_OF_LIST_OF_FILE;
-
-    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;
-    file_pos->num_of_file = s->num_file;
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos *file_pos)
-{
-    unz64_s *s = NULL;
-    int err = UNZ_OK;
-
-    if (file == NULL || file_pos == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-
-    /* Jump to the right spot */
-    s->pos_in_central_dir = file_pos->pos_in_zip_directory;
-    s->num_file = file_pos->num_of_file;
-
-    /* Set the current file */
-    err = unzGetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal, NULL, 0, NULL, 0, NULL, 0);
-    /* Return results */
-    s->current_file_ok = (err == UNZ_OK);
-    return err;
+      return 0;
+    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)
+      if (s->num_file==s->gi.number_entry)
+         return 0;
+    return s->pos_in_central_dir;
 }
 
-extern int32_t ZEXPORT unzGetOffset(unzFile file)
+extern uLong ZEXPORT unzGetOffset (unzFile file)
 {
-    uint64_t offset64 = 0;
+    ZPOS64_T offset64;
 
-    if (file == NULL)
-        return UNZ_PARAMERROR;
+    if (file==NULL)
+          return 0; //UNZ_PARAMERROR;
     offset64 = unzGetOffset64(file);
-    return (int32_t)offset64;
+    return (uLong)offset64;
 }
 
-extern int64_t ZEXPORT unzGetOffset64(unzFile file)
+extern int ZEXPORT unzSetOffset64(unzFile file, ZPOS64_T pos)
 {
-    unz64_s *s = NULL;
+    unz64_s* s;
+    int err;
 
-    if (file == NULL)
+    if (file==NULL)
         return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-    if (!s->current_file_ok)
-        return 0;
-    if (s->gi.number_entry != 0 && s->gi.number_entry != UINT16_MAX)
-    {
-        if (s->num_file == s->gi.number_entry)
-            return 0;
-    }
-    return s->pos_in_central_dir;
-}
-
-extern int ZEXPORT unzSetOffset(unzFile file, uint32_t pos)
-{
-    return unzSetOffset64(file, pos);
-}
-
-extern int ZEXPORT unzSetOffset64(unzFile file, uint64_t pos)
-{
-    unz64_s *s = NULL;
-    int err = UNZ_OK;
+    s=(unz64_s*)file;
 
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
     s->pos_in_central_dir = pos;
-    s->num_file = s->gi.number_entry; /* hack */
-
-    err = unzGetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal, NULL, 0, NULL, 0, NULL, 0);
-
+    s->num_file = s->gi.number_entry;      /* hack */
+    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info,
+                                              &s->cur_file_info_internal,
+                                              NULL,0,NULL,0,NULL,0);
     s->current_file_ok = (err == UNZ_OK);
     return err;
 }
 
-extern int32_t ZEXPORT unzTell(unzFile file)
-{
-    unz64_s *s = NULL;
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-    if (s->pfile_in_zip_read == NULL)
-        return UNZ_PARAMERROR;
-    return (int32_t)s->pfile_in_zip_read->stream.total_out;
-}
-
-extern int64_t ZEXPORT unzTell64(unzFile file)
-{
-    unz64_s *s = NULL;
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-    if (s->pfile_in_zip_read == NULL)
-        return UNZ_PARAMERROR;
-    return s->pfile_in_zip_read->total_out_64;
-}
-
-extern int ZEXPORT unzSeek(unzFile file, uint32_t offset, int origin)
-{
-    return unzSeek64(file, offset, origin);
-}
-
-extern int ZEXPORT unzSeek64(unzFile file, uint64_t offset, int origin)
-{
-    unz64_s *s = NULL;
-    uint64_t stream_pos_begin = 0;
-    uint64_t stream_pos_end = 0;
-    uint64_t position = 0;
-    int is_within_buffer = 0;
-
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-
-    if (s->pfile_in_zip_read == NULL)
-        return UNZ_ERRNO;
-    if (s->pfile_in_zip_read->compression_method != 0)
-        return UNZ_ERRNO;
-
-    if (origin == SEEK_SET)
-        position = offset;
-    else if (origin == SEEK_CUR)
-        position = s->pfile_in_zip_read->total_out_64 + offset;
-    else if (origin == SEEK_END)
-        position = s->cur_file_info.compressed_size + offset;
-    else
-        return UNZ_PARAMERROR;
-
-    if (position > s->cur_file_info.compressed_size)
-        return UNZ_PARAMERROR;
-
-    stream_pos_end = s->pfile_in_zip_read->pos_in_zipfile;
-    stream_pos_begin = stream_pos_end;
-
-    if (stream_pos_begin > UNZ_BUFSIZE)
-        stream_pos_begin -= UNZ_BUFSIZE;
-    else
-        stream_pos_begin = 0;
-
-    is_within_buffer = 
-        (s->pfile_in_zip_read->stream.avail_in != 0) &&
-        (s->pfile_in_zip_read->rest_read_compressed != 0 || s->cur_file_info.compressed_size < UNZ_BUFSIZE) &&
-        (position >= stream_pos_begin && position < stream_pos_end);
-
-    if (is_within_buffer)
-    {
-        s->pfile_in_zip_read->stream.next_in += position - s->pfile_in_zip_read->total_out_64;
-        s->pfile_in_zip_read->stream.avail_in = (uInt)(stream_pos_end - position);
-    }
-    else
-    {
-        s->pfile_in_zip_read->stream.avail_in = 0;
-        s->pfile_in_zip_read->stream.next_in = 0;
-
-        s->pfile_in_zip_read->pos_in_zipfile = s->pfile_in_zip_read->offset_local_extrafield + position;
-        s->pfile_in_zip_read->rest_read_compressed = s->cur_file_info.compressed_size - position;
-    }
-
-    s->pfile_in_zip_read->rest_read_uncompressed -= (position - s->pfile_in_zip_read->total_out_64);
-    s->pfile_in_zip_read->stream.total_out = (uint32_t)position;
-    s->pfile_in_zip_read->total_out_64 = position;
-
-    return UNZ_OK;
-}
-
-extern int ZEXPORT unzEndOfFile(unzFile file)
+extern int ZEXPORT unzSetOffset (unzFile file, uLong pos)
 {
-    unz64_s *s = NULL;
-    if (file == NULL)
-        return UNZ_PARAMERROR;
-    s = (unz64_s*)file;
-    if (s->pfile_in_zip_read == NULL)
-        return UNZ_PARAMERROR;
-    if (s->pfile_in_zip_read->rest_read_uncompressed == 0)
-        return 1;
-    return 0;
+    return unzSetOffset64(file,pos);
 }
-
-#ifdef _MSC_VER
-#   pragma warning(pop)
-#endif // _MSC_VER
diff --git a/contrib/unzip/unzip.h b/contrib/unzip/unzip.h
index ea4c90a4d..6f95e94d7 100644
--- a/contrib/unzip/unzip.h
+++ b/contrib/unzip/unzip.h
@@ -1,306 +1,437 @@
 /* unzip.h -- IO for uncompress .zip files using zlib
    Version 1.1, February 14h, 2010
-   part of the MiniZip project
-
-   Copyright (C) 1998-2010 Gilles Vollant
-     http://www.winimage.com/zLibDll/minizip.html
-   Modifications of Unzip for Zip64
-     Copyright (C) 2007-2008 Even Rouault
-   Modifications for Zip64 support on both zip and unzip
-     Copyright (C) 2009-2010 Mathias Svensson
-     http://result42.com
-
-   This program is distributed under the terms of the same license as zlib.
-   See the accompanying LICENSE file for the full text of the license.
+   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )
+
+         Modifications of Unzip for Zip64
+         Copyright (C) 2007-2008 Even Rouault
+
+         Modifications for Zip64 support on both zip and unzip
+         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )
+
+         For more info read MiniZip_info.txt
+
+         ---------------------------------------------------------------------------------
+
+        Condition of use and distribution are the same than zlib :
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  ---------------------------------------------------------------------------------
+
+        Changes
+
+        See header of unzip64.c
+
 */
 
-#ifndef _UNZ_H
-#define _UNZ_H
+#ifndef _unz64_H
+#define _unz64_H
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #ifndef _ZLIB_H
 #include "zlib.h"
 #endif
 
-#ifndef _ZLIBIOAPI_H
+#ifndef  _ZLIBIOAPI_H
 #include "ioapi.h"
 #endif
 
 #ifdef HAVE_BZIP2
 #include "bzlib.h"
 #endif
 
 #define Z_BZIP2ED 12
 
 #if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
 /* like the STRICT of WIN32, we define a pointer that cannot be converted
     from (void*) without cast */
-typedef struct TagunzFile__ { int unused; } unz_file__;
-typedef unz_file__ *unzFile;
+typedef struct TagunzFile__ { int unused; } unzFile__;
+typedef unzFile__ *unzFile;
 #else
 typedef voidp unzFile;
 #endif
 
+
 #define UNZ_OK                          (0)
 #define UNZ_END_OF_LIST_OF_FILE         (-100)
 #define UNZ_ERRNO                       (Z_ERRNO)
 #define UNZ_EOF                         (0)
 #define UNZ_PARAMERROR                  (-102)
 #define UNZ_BADZIPFILE                  (-103)
 #define UNZ_INTERNALERROR               (-104)
 #define UNZ_CRCERROR                    (-105)
-#define UNZ_BADPASSWORD                 (-106)
+
+/* tm_unz contain date/time info */
+typedef struct tm_unz_s
+{
+    int tm_sec;             /* seconds after the minute - [0,59] */
+    int tm_min;             /* minutes after the hour - [0,59] */
+    int tm_hour;            /* hours since midnight - [0,23] */
+    int tm_mday;            /* day of the month - [1,31] */
+    int tm_mon;             /* months since January - [0,11] */
+    int tm_year;            /* years - [1980..2044] */
+} tm_unz;
 
 /* unz_global_info structure contain global data about the ZIPfile
    These data comes from the end of central dir */
 typedef struct unz_global_info64_s
 {
-    uint64_t number_entry;          /* total number of entries in the central dir on this disk */
-    uint32_t number_disk_with_CD;   /* number the the disk with central dir, used for spanning ZIP*/
-    uint16_t size_comment;          /* size of the global comment of the zipfile */
+    ZPOS64_T number_entry;         /* total number of entries in
+                                     the central dir on this disk */
+    uLong size_comment;         /* size of the global comment of the zipfile */
 } unz_global_info64;
 
 typedef struct unz_global_info_s
 {
-    uint32_t number_entry;          /* total number of entries in the central dir on this disk */
-    uint32_t number_disk_with_CD;   /* number the the disk with central dir, used for spanning ZIP*/
-    uint16_t size_comment;          /* size of the global comment of the zipfile */
+    uLong number_entry;         /* total number of entries in
+                                     the central dir on this disk */
+    uLong size_comment;         /* size of the global comment of the zipfile */
 } unz_global_info;
 
 /* unz_file_info contain information about a file in the zipfile */
 typedef struct unz_file_info64_s
 {
-    uint16_t version;               /* version made by                 2 bytes */
-    uint16_t version_needed;        /* version needed to extract       2 bytes */
-    uint16_t flag;                  /* general purpose bit flag        2 bytes */
-    uint16_t compression_method;    /* compression method              2 bytes */
-    uint32_t dos_date;              /* last mod file date in Dos fmt   4 bytes */
-    uint32_t crc;                   /* crc-32                          4 bytes */
-    uint64_t compressed_size;       /* compressed size                 8 bytes */
-    uint64_t uncompressed_size;     /* uncompressed size               8 bytes */
-    uint16_t size_filename;         /* filename length                 2 bytes */
-    uint16_t size_file_extra;       /* extra field length              2 bytes */
-    uint16_t size_file_comment;     /* file comment length             2 bytes */
-
-    uint32_t disk_num_start;        /* disk number start               4 bytes */
-    uint16_t internal_fa;           /* internal file attributes        2 bytes */
-    uint32_t external_fa;           /* external file attributes        4 bytes */
-
-    uint64_t disk_offset;
-
-    uint16_t size_file_extra_internal;
+    uLong version;              /* version made by                 2 bytes */
+    uLong version_needed;       /* version needed to extract       2 bytes */
+    uLong flag;                 /* general purpose bit flag        2 bytes */
+    uLong compression_method;   /* compression method              2 bytes */
+    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
+    uLong crc;                  /* crc-32                          4 bytes */
+    ZPOS64_T compressed_size;   /* compressed size                 8 bytes */
+    ZPOS64_T uncompressed_size; /* uncompressed size               8 bytes */
+    uLong size_filename;        /* filename length                 2 bytes */
+    uLong size_file_extra;      /* extra field length              2 bytes */
+    uLong size_file_comment;    /* file comment length             2 bytes */
+
+    uLong disk_num_start;       /* disk number start               2 bytes */
+    uLong internal_fa;          /* internal file attributes        2 bytes */
+    uLong external_fa;          /* external file attributes        4 bytes */
+
+    tm_unz tmu_date;
 } unz_file_info64;
 
 typedef struct unz_file_info_s
 {
-    uint16_t version;               /* version made by                 2 bytes */
-    uint16_t version_needed;        /* version needed to extract       2 bytes */
-    uint16_t flag;                  /* general purpose bit flag        2 bytes */
-    uint16_t compression_method;    /* compression method              2 bytes */
-    uint32_t dos_date;              /* last mod file date in Dos fmt   4 bytes */
-    uint32_t crc;                   /* crc-32                          4 bytes */
-    uint32_t compressed_size;       /* compressed size                 4 bytes */
-    uint32_t uncompressed_size;     /* uncompressed size               4 bytes */
-    uint16_t size_filename;         /* filename length                 2 bytes */
-    uint16_t size_file_extra;       /* extra field length              2 bytes */
-    uint16_t size_file_comment;     /* file comment length             2 bytes */
-
-    uint16_t disk_num_start;        /* disk number start               2 bytes */
-    uint16_t internal_fa;           /* internal file attributes        2 bytes */
-    uint32_t external_fa;           /* external file attributes        4 bytes */
-
-    uint64_t disk_offset;
+    uLong version;              /* version made by                 2 bytes */
+    uLong version_needed;       /* version needed to extract       2 bytes */
+    uLong flag;                 /* general purpose bit flag        2 bytes */
+    uLong compression_method;   /* compression method              2 bytes */
+    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
+    uLong crc;                  /* crc-32                          4 bytes */
+    uLong compressed_size;      /* compressed size                 4 bytes */
+    uLong uncompressed_size;    /* uncompressed size               4 bytes */
+    uLong size_filename;        /* filename length                 2 bytes */
+    uLong size_file_extra;      /* extra field length              2 bytes */
+    uLong size_file_comment;    /* file comment length             2 bytes */
+
+    uLong disk_num_start;       /* disk number start               2 bytes */
+    uLong internal_fa;          /* internal file attributes        2 bytes */
+    uLong external_fa;          /* external file attributes        4 bytes */
+
+    tm_unz tmu_date;
 } unz_file_info;
 
-/***************************************************************************/
-/* Opening and close a zip file */
-
-extern unzFile ZEXPORT unzOpen(const char *path);
-extern unzFile ZEXPORT unzOpen64(const void *path);
-/* Open a Zip file.
-
-   path should contain the full path (by example, on a Windows XP computer 
-      "c:\\zlib\\zlib113.zip" or on an Unix computer "zlib/zlib113.zip". 
-   return NULL if zipfile cannot be opened or doesn't exist
-   return unzFile handle if no error
-
-   NOTE: The "64" function take a const void *pointer, because  the path is just the value passed to the
-   open64_file_func callback. Under Windows, if UNICODE is defined, using fill_fopen64_filefunc, the path 
-   is a pointer to a wide unicode string  (LPCTSTR is LPCWSTR), so const char *does not describe the reality */
+extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
+                                                 const char* fileName2,
+                                                 int iCaseSensitivity));
+/*
+   Compare two filename (fileName1,fileName2).
+   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
+   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
+                                or strcasecmp)
+   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
+    (like 1 on Unix, 2 on Windows)
+*/
 
-extern unzFile ZEXPORT unzOpen2(const char *path, zlib_filefunc_def *pzlib_filefunc_def);
-/* Open a Zip file, like unzOpen, but provide a set of file low level API for read/write operations */
-extern unzFile ZEXPORT unzOpen2_64(const void *path, zlib_filefunc64_def *pzlib_filefunc_def);
-/* Open a Zip file, like unz64Open, but provide a set of file low level API for read/write 64-bit operations */
 
-extern int ZEXPORT unzClose(unzFile file);
-/* Close a ZipFile opened with unzOpen. If there is files inside the .Zip opened with unzOpenCurrentFile,
-   these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
+extern unzFile ZEXPORT unzOpen OF((const char *path));
+extern unzFile ZEXPORT unzOpen64 OF((const void *path));
+/*
+  Open a Zip file. path contain the full pathname (by example,
+     on a Windows XP computer "c:\\zlib\\zlib113.zip" or on an Unix computer
+     "zlib/zlib113.zip".
+     If the zipfile cannot be opened (file don't exist or in not valid), the
+       return value is NULL.
+     Else, the return value is a unzFile Handle, usable with other function
+       of this unzip package.
+     the "64" function take a const void* pointer, because the path is just the
+       value passed to the open64_file_func callback.
+     Under Windows, if UNICODE is defined, using fill_fopen64_filefunc, the path
+       is a pointer to a wide unicode string (LPCTSTR is LPCWSTR), so const char*
+       does not describe the reality
+*/
 
-   return UNZ_OK if there is no error */
 
-extern int ZEXPORT unzGetGlobalInfo(unzFile file, unz_global_info *pglobal_info);
-extern int ZEXPORT unzGetGlobalInfo64(unzFile file, unz_global_info64 *pglobal_info);
-/* Write info about the ZipFile in the *pglobal_info structure.
+extern unzFile ZEXPORT unzOpen2 OF((const char *path,
+                                    zlib_filefunc_def* pzlib_filefunc_def));
+/*
+   Open a Zip file, like unzOpen, but provide a set of file low level API
+      for read/write the zip file (see ioapi.h)
+*/
 
-   return UNZ_OK if no error */
+extern unzFile ZEXPORT unzOpen2_64 OF((const void *path,
+                                    zlib_filefunc64_def* pzlib_filefunc_def));
+/*
+   Open a Zip file, like unz64Open, but provide a set of file low level API
+      for read/write the zip file (see ioapi.h)
+*/
 
-extern int ZEXPORT unzGetGlobalComment(unzFile file, char *comment, uint16_t comment_size);
-/* Get the global comment string of the ZipFile, in the comment buffer.
+extern int ZEXPORT unzClose OF((unzFile file));
+/*
+  Close a ZipFile opened with unzOpen.
+  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
+    these files MUST be closed with unzCloseCurrentFile before call unzClose.
+  return UNZ_OK if there is no problem. */
+
+extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
+                                        unz_global_info *pglobal_info));
+
+extern int ZEXPORT unzGetGlobalInfo64 OF((unzFile file,
+                                        unz_global_info64 *pglobal_info));
+/*
+  Write info about the ZipFile in the *pglobal_info structure.
+  No preparation of the structure is needed
+  return UNZ_OK if there is no problem. */
+
+
+extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
+                                           char *szComment,
+                                           uLong uSizeBuf));
+/*
+  Get the global comment string of the ZipFile, in the szComment buffer.
+  uSizeBuf is the size of the szComment buffer.
+  return the number of byte copied or an error code <0
+*/
 
-   uSizeBuf is the size of the szComment buffer.
-   return the number of byte copied or an error code <0 */
 
 /***************************************************************************/
-/* Reading the content of the current zipfile, you can open it, read data from it, and close it
-   (you can close it before reading all the file) */
+/* Unzip package allow you browse the directory of the zipfile */
 
-extern int ZEXPORT unzOpenCurrentFile(unzFile file);
-/* Open for reading data the current file in the zipfile.
-
-   return UNZ_OK if no error */
+extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
+/*
+  Set the current file of the zipfile to the first file.
+  return UNZ_OK if there is no problem
+*/
 
-extern int ZEXPORT unzOpenCurrentFilePassword(unzFile file, const char *password);
-/* Open for reading data the current file in the zipfile.
-   password is a crypting password
+extern int ZEXPORT unzGoToNextFile OF((unzFile file));
+/*
+  Set the current file of the zipfile to the next file.
+  return UNZ_OK if there is no problem
+  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
+*/
 
-   return UNZ_OK if no error */
+extern int ZEXPORT unzLocateFile OF((unzFile file,
+                     const char *szFileName,
+                     int iCaseSensitivity));
+/*
+  Try locate the file szFileName in the zipfile.
+  For the iCaseSensitivity signification, see unzStringFileNameCompare
 
-extern int ZEXPORT unzOpenCurrentFile2(unzFile file, int *method, int *level, int raw);
-/* Same as unzOpenCurrentFile, but open for read raw the file (not uncompress)
-   if raw==1 *method will receive method of compression, *level will receive level of compression
+  return value :
+  UNZ_OK if the file is found. It becomes the current file.
+  UNZ_END_OF_LIST_OF_FILE if the file is not found
+*/
 
-   NOTE: you can set level parameter as NULL (if you did not want known level,
-         but you CANNOT set method parameter as NULL */
 
-extern int ZEXPORT unzOpenCurrentFile3(unzFile file, int *method, int *level, int raw, const char *password);
-/* Same as unzOpenCurrentFile, but takes extra parameter password for encrypted files */
+/* ****************************************** */
+/* Ryan supplied functions */
+/* unz_file_info contain information about a file in the zipfile */
+typedef struct unz_file_pos_s
+{
+    uLong pos_in_zip_directory;   /* offset in zip file directory */
+    uLong num_of_file;            /* # of file */
+} unz_file_pos;
 
-extern int ZEXPORT unzReadCurrentFile(unzFile file, voidp buf, uint32_t len);
-/* Read bytes from the current file (opened by unzOpenCurrentFile)
-   buf contain buffer where data must be copied
-   len the size of buf.
+extern int ZEXPORT unzGetFilePos(
+    unzFile file,
+    unz_file_pos* file_pos);
 
-   return the number of byte copied if somes bytes are copied
-   return 0 if the end of file was reached
-   return <0 with error code if there is an error (UNZ_ERRNO for IO error, or zLib error for uncompress error) */
+extern int ZEXPORT unzGoToFilePos(
+    unzFile file,
+    unz_file_pos* file_pos);
 
-extern int ZEXPORT unzGetCurrentFileInfo(unzFile file, unz_file_info *pfile_info, char *filename, 
-    uint16_t filename_size, void *extrafield, uint16_t extrafield_size, char *comment, uint16_t comment_size);
-extern int ZEXPORT unzGetCurrentFileInfo64(unzFile file, unz_file_info64 *pfile_info, char *filename,
-    uint16_t filename_size, void *extrafield, uint16_t extrafield_size, char *comment, uint16_t comment_size);
-/* Get Info about the current file
+typedef struct unz64_file_pos_s
+{
+    ZPOS64_T pos_in_zip_directory;   /* offset in zip file directory */
+    ZPOS64_T num_of_file;            /* # of file */
+} unz64_file_pos;
 
-   pfile_info if != NULL, the *pfile_info structure will contain somes info about the current file
-   filename if != NULL, the file name string will be copied in filename 
-   filename_size is the size of the filename buffer
-   extrafield if != NULL, the extra field information from the central header will be copied in to
-   extrafield_size is the size of the extraField buffer 
-   comment if != NULL, the comment string of the file will be copied in to
-   comment_size is the size of the comment buffer */
+extern int ZEXPORT unzGetFilePos64(
+    unzFile file,
+    unz64_file_pos* file_pos);
+
+extern int ZEXPORT unzGoToFilePos64(
+    unzFile file,
+    const unz64_file_pos* file_pos);
+
+/* ****************************************** */
+
+extern int ZEXPORT unzGetCurrentFileInfo64 OF((unzFile file,
+                         unz_file_info64 *pfile_info,
+                         char *szFileName,
+                         uLong fileNameBufferSize,
+                         void *extraField,
+                         uLong extraFieldBufferSize,
+                         char *szComment,
+                         uLong commentBufferSize));
+
+extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
+                         unz_file_info *pfile_info,
+                         char *szFileName,
+                         uLong fileNameBufferSize,
+                         void *extraField,
+                         uLong extraFieldBufferSize,
+                         char *szComment,
+                         uLong commentBufferSize));
+/*
+  Get Info about the current file
+  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
+        the current file
+  if szFileName!=NULL, the filemane string will be copied in szFileName
+            (fileNameBufferSize is the size of the buffer)
+  if extraField!=NULL, the extra field information will be copied in extraField
+            (extraFieldBufferSize is the size of the buffer).
+            This is the Central-header version of the extra field
+  if szComment!=NULL, the comment string of the file will be copied in szComment
+            (commentBufferSize is the size of the buffer)
+*/
 
-extern int ZEXPORT unzGetLocalExtrafield(unzFile file, voidp buf, uint32_t len);
-/* Read extra field from the current file (opened by unzOpenCurrentFile)
-   This is the local-header version of the extra field (sometimes, there is
-   more info in the local-header version than in the central-header)
 
-   if buf == NULL, it return the size of the local extra field
-   if buf != NULL, len is the size of the buffer, the extra header is copied in buf.
+/** Addition for GDAL : START */
 
-   return number of bytes copied in buf, or (if <0) the error code */
+extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64 OF((unzFile file));
 
-extern int ZEXPORT unzCloseCurrentFile(unzFile file);
-/* Close the file in zip opened with unzOpenCurrentFile
+/** Addition for GDAL : END */
 
-   return UNZ_CRCERROR if all the file was read but the CRC is not good */
 
 /***************************************************************************/
-/* Browse the directory of the zipfile */
-
-typedef int (*unzFileNameComparer)(unzFile file, const char *filename1, const char *filename2);
-typedef int (*unzIteratorFunction)(unzFile file);
-typedef int (*unzIteratorFunction2)(unzFile file, unz_file_info64 *pfile_info, char *filename,
-    uint16_t filename_size, void *extrafield, uint16_t extrafield_size, char *comment, uint16_t comment_size);
-
-extern int ZEXPORT unzGoToFirstFile(unzFile file);
-/* Set the current file of the zipfile to the first file.
-
-   return UNZ_OK if no error */
+/* for reading the content of the current zipfile, you can open it, read data
+   from it, and close it (you can close it before reading all the file)
+   */
+
+extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
+/*
+  Open for reading data the current file in the zipfile.
+  If there is no error, the return value is UNZ_OK.
+*/
 
-extern int ZEXPORT unzGoToFirstFile2(unzFile file, unz_file_info64 *pfile_info, char *filename,
-    uint16_t filename_size, void *extrafield, uint16_t extrafield_size, char *comment, uint16_t comment_size);
-/* Set the current file of the zipfile to the first file and retrieves the current info on success. 
-   Not as seek intensive as unzGoToFirstFile + unzGetCurrentFileInfo.
+extern int ZEXPORT unzOpenCurrentFilePassword OF((unzFile file,
+                                                  const char* password));
+/*
+  Open for reading data the current file in the zipfile.
+  password is a crypting password
+  If there is no error, the return value is UNZ_OK.
+*/
 
-   return UNZ_OK if no error */
+extern int ZEXPORT unzOpenCurrentFile2 OF((unzFile file,
+                                           int* method,
+                                           int* level,
+                                           int raw));
+/*
+  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
+    if raw==1
+  *method will receive method of compression, *level will receive level of
+     compression
+  note : you can set level parameter as NULL (if you did not want known level,
+         but you CANNOT set method parameter as NULL
+*/
 
-extern int ZEXPORT unzGoToNextFile(unzFile file);
-/* Set the current file of the zipfile to the next file.
+extern int ZEXPORT unzOpenCurrentFile3 OF((unzFile file,
+                                           int* method,
+                                           int* level,
+                                           int raw,
+                                           const char* password));
+/*
+  Same than unzOpenCurrentFile, but open for read raw the file (not uncompress)
+    if raw==1
+  *method will receive method of compression, *level will receive level of
+     compression
+  note : you can set level parameter as NULL (if you did not want known level,
+         but you CANNOT set method parameter as NULL
+*/
 
-   return UNZ_OK if no error
-   return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest */
 
-extern int ZEXPORT unzGoToNextFile2(unzFile file, unz_file_info64 *pfile_info, char *filename,
-    uint16_t filename_size, void *extrafield, uint16_t extrafield_size, char *comment, uint16_t comment_size);
-/* Set the current file of the zipfile to the next file and retrieves the current 
-   info on success. Does less seeking around than unzGotoNextFile + unzGetCurrentFileInfo.
+extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));
+/*
+  Close the file in zip opened with unzOpenCurrentFile
+  Return UNZ_CRCERROR if all the file was read but the CRC is not good
+*/
 
-   return UNZ_OK if no error
-   return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest */
+extern int ZEXPORT unzReadCurrentFile OF((unzFile file,
+                      voidp buf,
+                      unsigned len));
+/*
+  Read bytes from the current file (opened by unzOpenCurrentFile)
+  buf contain buffer where data must be copied
+  len the size of buf.
+
+  return the number of byte copied if somes bytes are copied
+  return 0 if the end of file was reached
+  return <0 with error code if there is an error
+    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
+*/
 
-extern int ZEXPORT unzLocateFile(unzFile file, const char *filename, unzFileNameComparer filename_compare_func);
-/* Try locate the file szFileName in the zipfile. For custom filename comparison pass in comparison function.
+extern z_off_t ZEXPORT unztell OF((unzFile file));
 
-   return UNZ_OK if the file is found (it becomes the current file)
-   return UNZ_END_OF_LIST_OF_FILE if the file is not found */
+extern ZPOS64_T ZEXPORT unztell64 OF((unzFile file));
+/*
+  Give the current position in uncompressed data
+*/
 
-/***************************************************************************/
-/* Raw access to zip file */
+extern int ZEXPORT unzeof OF((unzFile file));
+/*
+  return 1 if the end of file was reached, 0 elsewhere
+*/
 
-typedef struct unz_file_pos_s
-{
-    uint32_t pos_in_zip_directory;  /* offset in zip file directory */
-    uint32_t num_of_file;           /* # of file */
-} unz_file_pos;
+extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,
+                                             voidp buf,
+                                             unsigned len));
+/*
+  Read extra field from the current file (opened by unzOpenCurrentFile)
+  This is the local-header version of the extra field (sometimes, there is
+    more info in the local-header version than in the central-header)
 
-extern int ZEXPORT unzGetFilePos(unzFile file, unz_file_pos *file_pos);
-extern int ZEXPORT unzGoToFilePos(unzFile file, unz_file_pos *file_pos);
+  if buf==NULL, it return the size of the local extra field
 
-typedef struct unz64_file_pos_s
-{
-    uint64_t pos_in_zip_directory;   /* offset in zip file directory */
-    uint64_t num_of_file;            /* # of file */
-} unz64_file_pos;
+  if buf!=NULL, len is the size of the buffer, the extra header is copied in
+    buf.
+  the return value is the number of bytes copied in buf, or (if <0)
+    the error code
+*/
 
-extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos *file_pos);
-extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos *file_pos);
+/***************************************************************************/
 
-extern int32_t ZEXPORT unzGetOffset(unzFile file);
-extern int64_t ZEXPORT unzGetOffset64(unzFile file);
 /* Get the current file offset */
+extern ZPOS64_T ZEXPORT unzGetOffset64 (unzFile file);
+extern uLong ZEXPORT unzGetOffset (unzFile file);
 
-extern int ZEXPORT unzSetOffset(unzFile file, uint32_t pos);
-extern int ZEXPORT unzSetOffset64(unzFile file, uint64_t pos);
 /* Set the current file offset */
+extern int ZEXPORT unzSetOffset64 (unzFile file, ZPOS64_T pos);
+extern int ZEXPORT unzSetOffset (unzFile file, uLong pos);
 
-extern int32_t ZEXPORT unzTell(unzFile file);
-extern int64_t ZEXPORT unzTell64(unzFile file);
-/* return current position in uncompressed data */
 
-extern int ZEXPORT unzSeek(unzFile file, uint32_t offset, int origin);
-extern int ZEXPORT unzSeek64(unzFile file, uint64_t offset, int origin);
-/* Seek within the uncompressed data if compression method is storage */
-
-extern int ZEXPORT unzEndOfFile(unzFile file);
-/* return 1 if the end of file was reached, 0 elsewhere */
-
-/***************************************************************************/
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif /* _UNZ_H */
+#endif /* _unz64_H */
