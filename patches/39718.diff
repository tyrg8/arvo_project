commit ad9c10b47b0e157fc7299639a89f00b015f10599
Author: Bob Weinand <bobwei9@hotmail.com>
Date:   Mon Oct 4 00:42:39 2021 +0200

    Prefer userfaultfd over mprotect+SIGSEGV signal handling on linux for phpdbg watchpoints
    
    Closes GH-7551.

diff --git a/sapi/phpdbg/config.m4 b/sapi/phpdbg/config.m4
index 2f9a5e4a0f..a494e9daae 100644
--- a/sapi/phpdbg/config.m4
+++ b/sapi/phpdbg/config.m4
@@ -22,64 +22,86 @@ PHP_ARG_ENABLE([phpdbg-readline],
 if test "$BUILD_PHPDBG" = "" && test "$PHP_PHPDBG" != "no"; then
   AC_HEADER_TIOCGWINSZ
   AC_DEFINE(HAVE_PHPDBG, 1, [ ])
 
   if test "$PHP_PHPDBG_DEBUG" != "no"; then
     AC_DEFINE(PHPDBG_DEBUG, 1, [ ])
   else
     AC_DEFINE(PHPDBG_DEBUG, 0, [ ])
   fi
 
   PHP_PHPDBG_CFLAGS="-D_GNU_SOURCE -DZEND_ENABLE_STATIC_TSRMLS_CACHE=1"
   PHP_PHPDBG_FILES="phpdbg.c phpdbg_parser.c phpdbg_lexer.c phpdbg_prompt.c phpdbg_help.c phpdbg_break.c phpdbg_print.c phpdbg_bp.c phpdbg_list.c phpdbg_utils.c phpdbg_info.c phpdbg_cmd.c phpdbg_set.c phpdbg_frame.c phpdbg_watch.c phpdbg_btree.c phpdbg_sigsafe.c phpdbg_io.c phpdbg_out.c"
 
   AC_MSG_CHECKING([for phpdbg and readline integration])
   if test "$PHP_PHPDBG_READLINE" = "yes"; then
     if test "$PHP_READLINE" != "no" -o  "$PHP_LIBEDIT" != "no"; then
   	  AC_DEFINE(HAVE_PHPDBG_READLINE, 1, [ ])
   	  PHPDBG_EXTRA_LIBS="$PHP_READLINE_LIBS"
   	  AC_MSG_RESULT([ok])
   	else
   	  AC_MSG_RESULT([readline is not available])
     fi
   else
     AC_MSG_RESULT([disabled])
   fi
 
+  AC_CACHE_CHECK([for userfaultfd faulting on write-protected memory support], ac_phpdbg_userfaultfd_writefault, AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
+    #include <linux/userfaultfd.h>
+    #ifndef UFFDIO_WRITEPROTECT_MODE_WP
+    # error userfaults on write-protected memory not supported
+    #endif
+  ]])], [ac_phpdbg_userfaultfd_writefault=yes], [ac_phpdbg_userfaultfd_writefault=no]))
+  if test "$ac_phpdbg_userfaultfd_writefault" = "yes"; then
+    if test "$enable_zts" != "yes"; then
+      dnl Add pthreads linker and compiler flags for userfaultfd background thread
+      if test -n "$ac_cv_pthreads_lib"; then
+        LIBS="$LIBS -l$ac_cv_pthreads_lib"
+      fi
+      if test -n "$ac_cv_pthreads_cflags"; then
+        CFLAGS="$CFLAGS $ac_cv_pthreads_cflags"
+      fi
+
+      PTHREADS_FLAGS
+    fi
+
+    AC_DEFINE(HAVE_USERFAULTFD_WRITEFAULT, 1, [Whether faulting on write-protected memory support can be compiled for userfaultfd])
+  fi
+
   PHP_SUBST(PHP_PHPDBG_CFLAGS)
   PHP_SUBST(PHP_PHPDBG_FILES)
   PHP_SUBST(PHPDBG_EXTRA_LIBS)
 
   PHP_ADD_MAKEFILE_FRAGMENT([$abs_srcdir/sapi/phpdbg/Makefile.frag], [$abs_srcdir/sapi/phpdbg], [$abs_builddir/sapi/phpdbg])
   PHP_SELECT_SAPI(phpdbg, program, $PHP_PHPDBG_FILES, $PHP_PHPDBG_CFLAGS, [$(SAPI_PHPDBG_PATH)])
 
   BUILD_BINARY="sapi/phpdbg/phpdbg"
   BUILD_SHARED="sapi/phpdbg/libphpdbg.la"
 
   BUILD_PHPDBG="\$(LIBTOOL) --mode=link \
         \$(CC) -export-dynamic \$(CFLAGS_CLEAN) \$(EXTRA_CFLAGS) \$(EXTRA_LDFLAGS_PROGRAM) \$(LDFLAGS) \$(PHP_RPATHS) \
                 \$(PHP_GLOBAL_OBJS:.lo=.o) \
                 \$(PHP_BINARY_OBJS:.lo=.o) \
                 \$(PHP_PHPDBG_OBJS:.lo=.o) \
                 \$(EXTRA_LIBS) \
                 \$(PHPDBG_EXTRA_LIBS) \
                 \$(ZEND_EXTRA_LIBS) \
                 \$(PHP_FRAMEWORKS) \
          -o \$(BUILD_BINARY)"
 
   BUILD_PHPDBG_SHARED="\$(LIBTOOL) --mode=link \
         \$(CC) -shared -Wl,-soname,libphpdbg.so -export-dynamic \$(CFLAGS_CLEAN) \$(EXTRA_CFLAGS) \$(EXTRA_LDFLAGS_PROGRAM) \$(LDFLAGS) \$(PHP_RPATHS) \
                 \$(PHP_GLOBAL_OBJS) \
                 \$(PHP_BINARY_OBJS) \
                 \$(PHP_PHPDBG_OBJS) \
                 \$(EXTRA_LIBS) \
                 \$(PHPDBG_EXTRA_LIBS) \
                 \$(ZEND_EXTRA_LIBS) \
                 \-DPHPDBG_SHARED \
          -o \$(BUILD_SHARED)"
 
   PHP_SUBST(BUILD_BINARY)
   PHP_SUBST(BUILD_SHARED)
   PHP_SUBST(BUILD_PHPDBG)
   PHP_SUBST(BUILD_PHPDBG_SHARED)
 
   PHP_OUTPUT(sapi/phpdbg/phpdbg.1)
diff --git a/sapi/phpdbg/phpdbg.c b/sapi/phpdbg/phpdbg.c
index ed56aa68f2..e9a5884b72 100644
--- a/sapi/phpdbg/phpdbg.c
+++ b/sapi/phpdbg/phpdbg.c
@@ -106,40 +106,45 @@ static void php_phpdbg_destroy_file_source(zval *data) /* {{{ */
 static inline void php_phpdbg_globals_ctor(zend_phpdbg_globals *pg) /* {{{ */
 {
 	pg->prompt[0] = NULL;
 	pg->prompt[1] = NULL;
 
 	pg->colors[0] = NULL;
 	pg->colors[1] = NULL;
 	pg->colors[2] = NULL;
 
 	pg->lines = phpdbg_get_terminal_height();
 	pg->exec = NULL;
 	pg->exec_len = 0;
 	pg->buffer = NULL;
 	pg->last_was_newline = 1;
 	pg->ops = NULL;
 	pg->vmret = 0;
 	pg->in_execution = 0;
 	pg->bp_count = 0;
 	pg->flags = PHPDBG_DEFAULT_FLAGS;
 	memset(pg->io, 0, sizeof(pg->io));
 	pg->frame.num = 0;
 	pg->sapi_name_ptr = NULL;
 	pg->unclean_eval = 0;
 
 	pg->req_id = 0;
 	pg->err_buf.active = 0;
 	pg->err_buf.type = 0;
 
 	pg->input_buflen = 0;
 	pg->sigsafe_mem.mem = NULL;
 	pg->sigsegv_bailout = NULL;
 
 	pg->oplog_list = NULL;
 	pg->stdin_file = NULL;
 
 	pg->cur_command = NULL;
 	pg->last_line = 0;
+
+#ifdef HAVE_USERFAULTFD_WRITEFAULT
+	pg->watch_userfaultfd = 0;
+	pg->watch_userfault_thread = 0;
+#endif
 } /* }}} */
 
 static PHP_MINIT_FUNCTION(phpdbg) /* {{{ */
@@ -1116,704 +1121,709 @@ php_stream *phpdbg_stream_url_wrap_php(php_stream_wrapper *wrapper, const char *
 int main(int argc, char **argv) /* {{{ */
 {
 	sapi_module_struct *phpdbg = &phpdbg_sapi_module;
 	char *sapi_name;
 	char *ini_entries;
 	int   ini_entries_len;
 	char **zend_extensions = NULL;
 	zend_ulong zend_extensions_len = 0L;
 	bool ini_ignore;
 	char *ini_override;
 	char *exec = NULL;
 	char *first_command = NULL;
 	char *init_file;
 	size_t init_file_len;
 	bool init_file_default;
 	uint64_t flags;
 	char *php_optarg;
 	int php_optind, opt, show_banner = 1;
 	long cleaning = -1;
 	volatile bool quit_immediately = 0; /* somehow some gcc release builds will play a bit around with order in combination with setjmp..., hence volatile */
 	zend_phpdbg_globals *settings = NULL;
 	char *bp_tmp = NULL;
 	char *print_opline_func;
 	bool ext_stmt = 0;
 	bool is_exit;
 	int exit_status;
 	char *read_from_stdin = NULL;
 	zend_string *backup_phpdbg_compile = NULL;
 	bool show_help = 0, show_version = 0;
 	void* (*_malloc)(size_t);
 	void (*_free)(void*);
 	void* (*_realloc)(void*, size_t);
 	php_stream_wrapper wrapper;
 	php_stream_wrapper_ops wops;
 
 #ifdef PHP_WIN32
 	_fmode = _O_BINARY;                 /* sets default for file streams to binary */
 	setmode(_fileno(stdin), O_BINARY);  /* make the stdio mode be binary */
 	setmode(_fileno(stdout), O_BINARY); /* make the stdio mode be binary */
 	setmode(_fileno(stderr), O_BINARY); /* make the stdio mode be binary */
 #else
 	struct sigaction signal_struct;
 	signal_struct.sa_sigaction = phpdbg_signal_handler;
 	signal_struct.sa_flags = SA_SIGINFO | SA_NODEFER;
 #endif
 
 phpdbg_main:
 #ifdef ZTS
 	php_tsrm_startup();
 # ifdef PHP_WIN32
 	ZEND_TSRMLS_CACHE_UPDATE();
 # endif
 #endif
 
 	zend_signal_startup();
 
 	ini_entries = NULL;
 	ini_entries_len = 0;
 	ini_ignore = 0;
 	ini_override = NULL;
 	zend_extensions = NULL;
 	zend_extensions_len = 0L;
 	init_file = NULL;
 	init_file_len = 0;
 	init_file_default = 1;
 	flags = PHPDBG_DEFAULT_FLAGS;
 	is_exit = 0;
 	php_optarg = NULL;
 	php_optind = 1;
 	opt = 0;
 	sapi_name = NULL;
 	exit_status = 0;
 	if (settings) {
 		exec = settings->exec;
 	}
 
 	while ((opt = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 0, 2)) != -1) {
 		switch (opt) {
 			case 'r':
 				if (settings == NULL) {
 					phpdbg_startup_run++;
 				}
 				break;
 			case 'n':
 				ini_ignore = 1;
 				break;
 			case 'c':
 				if (ini_override) {
 					free(ini_override);
 				}
 				ini_override = strdup(php_optarg);
 				break;
 			case 'd': {
 				int len = strlen(php_optarg);
 				char *val;
 
 				if ((val = strchr(php_optarg, '='))) {
 				  val++;
 				  if (!isalnum(*val) && *val != '"' && *val != '\'' && *val != '\0') {
 					  ini_entries = realloc(ini_entries, ini_entries_len + len + sizeof("\"\"\n\0"));
 					  memcpy(ini_entries + ini_entries_len, php_optarg, (val - php_optarg));
 					  ini_entries_len += (val - php_optarg);
 					  memcpy(ini_entries + ini_entries_len, "\"", 1);
 					  ini_entries_len++;
 					  memcpy(ini_entries + ini_entries_len, val, len - (val - php_optarg));
 					  ini_entries_len += len - (val - php_optarg);
 					  memcpy(ini_entries + ini_entries_len, "\"\n\0", sizeof("\"\n\0"));
 					  ini_entries_len += sizeof("\n\0\"") - 2;
 				  } else {
 					  ini_entries = realloc(ini_entries, ini_entries_len + len + sizeof("\n\0"));
 					  memcpy(ini_entries + ini_entries_len, php_optarg, len);
 					  memcpy(ini_entries + ini_entries_len + len, "\n\0", sizeof("\n\0"));
 					  ini_entries_len += len + sizeof("\n\0") - 2;
 				  }
 				} else {
 				  ini_entries = realloc(ini_entries, ini_entries_len + len + sizeof("=1\n\0"));
 				  memcpy(ini_entries + ini_entries_len, php_optarg, len);
 				  memcpy(ini_entries + ini_entries_len + len, "=1\n\0", sizeof("=1\n\0"));
 				  ini_entries_len += len + sizeof("=1\n\0") - 2;
 				}
 			} break;
 
 			case 'z':
 				zend_extensions_len++;
 				if (zend_extensions) {
 					zend_extensions = realloc(zend_extensions, sizeof(char*) * zend_extensions_len);
 				} else zend_extensions = malloc(sizeof(char*) * zend_extensions_len);
 				zend_extensions[zend_extensions_len-1] = strdup(php_optarg);
 			break;
 
 			/* begin phpdbg options */
 
 			case 's': { /* read script from stdin */
 				if (settings == NULL) {
 					read_from_stdin = strdup(php_optarg);
 				}
 			} break;
 
 			case 'S': { /* set SAPI name */
 				sapi_name = strdup(php_optarg);
 			} break;
 
 			case 'I': { /* ignore .phpdbginit */
 				init_file_default = 0;
 			} break;
 
 			case 'i': { /* set init file */
 				if (init_file) {
 					free(init_file);
 					init_file = NULL;
 				}
 
 				init_file_len = strlen(php_optarg);
 				if (init_file_len) {
 					init_file = strdup(php_optarg);
 				}
 			} break;
 
 			case 'v': /* set quietness off */
 				flags &= ~PHPDBG_IS_QUIET;
 			break;
 
 			case 'e':
 				ext_stmt = 1;
 			break;
 
 			case 'E': /* stepping through eval on */
 				flags |= PHPDBG_IS_STEPONEVAL;
 			break;
 
 			case 'b': /* set colours off */
 				flags &= ~PHPDBG_IS_COLOURED;
 			break;
 
 			case 'q': /* hide banner */
 				show_banner = 0;
 			break;
 
 			case 'p': {
 				print_opline_func = php_optarg;
 				show_banner = 0;
 				settings = (void *) 0x1;
 			} break;
 
 			case 'h': {
 				show_help = 1;
 			} break;
 
 			case 'V': {
 				show_version = 1;
 			} break;
 		}
 
 		php_optarg = NULL;
 	}
 
 	quit_immediately = phpdbg_startup_run > 1;
 
 	/* set exec if present on command line */
 	if (!read_from_stdin && argc > php_optind) {
 		if (!exec && strlen(argv[php_optind])) {
 			exec = strdup(argv[php_optind]);
 		}
 		php_optind++;
 	}
 
 	if (sapi_name) {
 		phpdbg->name = sapi_name;
 	}
 
 	phpdbg->ini_defaults = NULL;
 	phpdbg->phpinfo_as_text = 1;
 	phpdbg->php_ini_ignore_cwd = 1;
 
 	sapi_startup(phpdbg);
 
 	phpdbg->executable_location = argv[0];
 	phpdbg->phpinfo_as_text = 1;
 	phpdbg->php_ini_ignore = ini_ignore;
 	phpdbg->php_ini_path_override = ini_override;
 
 	if (ini_entries) {
 		ini_entries = realloc(ini_entries, ini_entries_len + sizeof(phpdbg_ini_hardcoded));
 		memmove(ini_entries + sizeof(phpdbg_ini_hardcoded) - 2, ini_entries, ini_entries_len + 1);
 		memcpy(ini_entries, phpdbg_ini_hardcoded, sizeof(phpdbg_ini_hardcoded) - 2);
 	} else {
 		ini_entries = malloc(sizeof(phpdbg_ini_hardcoded));
 		memcpy(ini_entries, phpdbg_ini_hardcoded, sizeof(phpdbg_ini_hardcoded));
 	}
 	ini_entries_len += sizeof(phpdbg_ini_hardcoded) - 2;
 
 	if (zend_extensions_len) {
 		zend_ulong zend_extension = 0L;
 
 		while (zend_extension < zend_extensions_len) {
 			const char *ze = zend_extensions[zend_extension];
 			size_t ze_len = strlen(ze);
 
 			ini_entries = realloc(
 				ini_entries, ini_entries_len + (ze_len + (sizeof("zend_extension=\n"))));
 			memcpy(&ini_entries[ini_entries_len], "zend_extension=", (sizeof("zend_extension=\n")-1));
 			ini_entries_len += (sizeof("zend_extension=")-1);
 			memcpy(&ini_entries[ini_entries_len], ze, ze_len);
 			ini_entries_len += ze_len;
 			memcpy(&ini_entries[ini_entries_len], "\n", (sizeof("\n") - 1));
 
 			free(zend_extensions[zend_extension]);
 			zend_extension++;
 		}
 
 		free(zend_extensions);
 	}
 
 	phpdbg->ini_entries = ini_entries;
 
 	ZEND_INIT_MODULE_GLOBALS(phpdbg, php_phpdbg_globals_ctor, NULL);
 
 	/* set default colors */
 	phpdbg_set_color_ex(PHPDBG_COLOR_PROMPT,  PHPDBG_STRL("white-bold"));
 	phpdbg_set_color_ex(PHPDBG_COLOR_ERROR,   PHPDBG_STRL("red-bold"));
 	phpdbg_set_color_ex(PHPDBG_COLOR_NOTICE,  PHPDBG_STRL("green"));
 
 	if (settings > (zend_phpdbg_globals *) 0x2) {
 #ifdef ZTS
 		zend_phpdbg_globals *ptr = TSRMG_BULK_STATIC(phpdbg_globals_id, zend_phpdbg_globals *);
 		*ptr = *settings;
 #else
 		phpdbg_globals = *settings;
 #endif
 		free(settings);
 	} else {
 		/* set default prompt */
 		phpdbg_set_prompt(PHPDBG_DEFAULT_PROMPT);
 	}
 
 	/* set flags from command line */
 	PHPDBG_G(flags) = flags;
 
 	if (phpdbg->startup(phpdbg) == SUCCESS) {
 		zend_mm_heap *mm_heap;
 #ifdef _WIN32
 	EXCEPTION_POINTERS *xp;
 	__try {
 #endif
 
 		if (show_version || show_help) {
 			/* It ain't gonna proceed to real execution anyway,
 				but the correct descriptor is needed already. */
 			PHPDBG_G(io)[PHPDBG_STDOUT].fd = fileno(stdout);
 			if (show_help) {
 				phpdbg_do_help_cmd(exec);
 			} else if (show_version) {
 				phpdbg_out(
 					"phpdbg %s (built: %s %s)\nPHP %s, Copyright (c) The PHP Group\n%s",
 					PHPDBG_VERSION,
 					__DATE__,
 					__TIME__,
 					PHP_VERSION,
 					get_zend_version()
 				);
 			}
 			sapi_deactivate();
 			sapi_shutdown();
 			if (ini_entries) {
 				free(ini_entries);
 			}
 			if (ini_override) {
 				free(ini_override);
 			}
 			if (exec) {
 				free(exec);
 			}
 			if (init_file) {
 				free(init_file);
 			}
 			goto free_and_return;
 		}
 
 		zend_try {
 			zend_signal_activate();
 		} zend_end_try();
 
 #ifndef _WIN32
 		zend_signal(SIGHUP, phpdbg_sighup_handler);
 #endif
 
 		mm_heap = zend_mm_get_heap();
 		zend_mm_get_custom_handlers(mm_heap, &_malloc, &_free, &_realloc);
 
 		use_mm_wrappers = !_malloc && !_realloc && !_free;
 
 		PHPDBG_G(original_free_function) = _free;
 		_free = phpdbg_watch_efree;
 
 		if (use_mm_wrappers) {
 #if ZEND_DEBUG
 			zend_mm_set_custom_debug_handlers(mm_heap, phpdbg_malloc_wrapper, phpdbg_free_wrapper, phpdbg_realloc_wrapper);
 #else
 			zend_mm_set_custom_handlers(mm_heap, phpdbg_malloc_wrapper, phpdbg_free_wrapper, phpdbg_realloc_wrapper);
 #endif
 		} else {
 			zend_mm_set_custom_handlers(mm_heap, _malloc, _free, _realloc);
 		}
 
 		_free = PHPDBG_G(original_free_function);
 
 
 		phpdbg_init_list();
 
 		PHPDBG_G(sapi_name_ptr) = sapi_name;
 
 		if (exec) { /* set execution context */
 			PHPDBG_G(exec) = phpdbg_resolve_path(exec);
 			PHPDBG_G(exec_len) = PHPDBG_G(exec) ? strlen(PHPDBG_G(exec)) : 0;
 
 			free(exec);
 			exec = NULL;
 		}
 
 		php_output_activate();
 		php_output_deactivate();
 
 		if (SG(sapi_headers).mimetype) {
 			efree(SG(sapi_headers).mimetype);
 			SG(sapi_headers).mimetype = NULL;
 		}
 
 		php_output_activate();
 
 		{
 			int i;
 
 			SG(request_info).argc = argc - php_optind + 1;
 			SG(request_info).argv = emalloc(SG(request_info).argc * sizeof(char *));
 			for (i = SG(request_info).argc; --i;) {
 				SG(request_info).argv[i] = estrdup(argv[php_optind - 1 + i]);
 			}
 			SG(request_info).argv[0] = PHPDBG_G(exec) ? estrdup(PHPDBG_G(exec)) : estrdup("");
 		}
 
 		if (php_request_startup() == FAILURE) {
 			PUTS("Could not startup");
 			return 1;
 		}
 
 #ifndef _WIN32
-		zend_try { zend_sigaction(SIGSEGV, &signal_struct, &PHPDBG_G(old_sigsegv_signal)); } zend_end_try();
-		zend_try { zend_sigaction(SIGBUS, &signal_struct, &PHPDBG_G(old_sigsegv_signal)); } zend_end_try();
+#ifdef HAVE_USERFAULTFD_WRITEFAULT
+		if (!PHPDBG_G(watch_userfaultfd))
+#endif
+		{
+			zend_try { zend_sigaction(SIGSEGV, &signal_struct, &PHPDBG_G(old_sigsegv_signal)); } zend_end_try();
+			zend_try { zend_sigaction(SIGBUS, &signal_struct, &PHPDBG_G(old_sigsegv_signal)); } zend_end_try();
+		}
 #endif
 		zend_try { zend_signal(SIGINT, phpdbg_sigint_handler); } zend_end_try();
 
 
 		PHPDBG_G(io)[PHPDBG_STDIN].fd = fileno(stdin);
 		PHPDBG_G(io)[PHPDBG_STDOUT].fd = fileno(stdout);
 		PHPDBG_G(io)[PHPDBG_STDERR].fd = fileno(stderr);
 
 #ifndef _WIN32
 		PHPDBG_G(php_stdiop_write) = php_stream_stdio_ops.write;
 		php_stream_stdio_ops.write = phpdbg_stdiop_write;
 #endif
 
 		{
 			zval *zv = zend_hash_str_find(php_stream_get_url_stream_wrappers_hash(), ZEND_STRL("php"));
 			php_stream_wrapper *tmp_wrapper = Z_PTR_P(zv);
 			PHPDBG_G(orig_url_wrap_php) = tmp_wrapper;
 			memcpy(&wrapper, tmp_wrapper, sizeof(wrapper));
 			memcpy(&wops, tmp_wrapper->wops, sizeof(wops));
 			wops.stream_opener = phpdbg_stream_url_wrap_php;
 			wrapper.wops = (const php_stream_wrapper_ops*)&wops;
 			Z_PTR_P(zv) = &wrapper;
 		}
 
 		/* Make stdin, stdout and stderr accessible from PHP scripts */
 		phpdbg_register_file_handles();
 
 		phpdbg_list_update();
 
 		if (show_banner && cleaning < 2) {
 			/* print blurb */
 			phpdbg_welcome(cleaning == 1);
 		}
 
 		cleaning = -1;
 
 		if (ext_stmt) {
 			CG(compiler_options) |= ZEND_COMPILE_EXTENDED_INFO;
 		}
 
 		/* initialize from file */
 		PHPDBG_G(flags) |= PHPDBG_IS_INITIALIZING;
 		zend_try {
 			phpdbg_init(init_file, init_file_len, init_file_default);
 		} zend_end_try();
 		PHPDBG_G(flags) &= ~PHPDBG_IS_INITIALIZING;
 
 		/* quit if init says so */
 		if (PHPDBG_G(flags) & PHPDBG_IS_QUITTING) {
 			goto phpdbg_out;
 		}
 
 		/* auto compile */
 		if (read_from_stdin) {
 			if (!read_from_stdin[0]) {
 				if (!quit_immediately) {
 					phpdbg_error("Impossible to not specify a stdin delimiter without -rr");
 					PHPDBG_G(flags) |= PHPDBG_IS_QUITTING;
 					goto phpdbg_out;
 				}
 			}
 			if (show_banner || read_from_stdin[0]) {
 				phpdbg_notice("Reading input from stdin; put '%s' followed by a newline on an own line after code to end input", read_from_stdin);
 			}
 
 			if (phpdbg_startup_run > 0) {
 				PHPDBG_G(flags) |= PHPDBG_DISCARD_OUTPUT;
 			}
 
 			zend_try {
 				phpdbg_param_t cmd;
 				cmd.str = read_from_stdin;
 				cmd.len = strlen(read_from_stdin);
 				PHPDBG_COMMAND_HANDLER(stdin)(&cmd);
 			} zend_end_try();
 
 			PHPDBG_G(flags) &= ~PHPDBG_DISCARD_OUTPUT;
 		} else if (PHPDBG_G(exec)) {
 			if (settings || phpdbg_startup_run > 0) {
 				PHPDBG_G(flags) |= PHPDBG_DISCARD_OUTPUT;
 			}
 
 			zend_try {
 				if (backup_phpdbg_compile) {
 					phpdbg_compile_stdin(backup_phpdbg_compile);
 				} else {
 					phpdbg_compile();
 				}
 			} zend_end_try();
 			backup_phpdbg_compile = NULL;
 
 			PHPDBG_G(flags) &= ~PHPDBG_DISCARD_OUTPUT;
 		}
 
 		if (bp_tmp) {
 			PHPDBG_G(flags) |= PHPDBG_DISCARD_OUTPUT | PHPDBG_IS_INITIALIZING;
 			phpdbg_string_init(bp_tmp);
 			free(bp_tmp);
 			bp_tmp = NULL;
 			PHPDBG_G(flags) &= ~PHPDBG_DISCARD_OUTPUT & ~PHPDBG_IS_INITIALIZING;
 		}
 
 		if (settings == (void *) 0x1) {
 			if (PHPDBG_G(ops)) {
 				phpdbg_print_opcodes(print_opline_func);
 			} else {
 				zend_quiet_write(PHPDBG_G(io)[PHPDBG_STDERR].fd, ZEND_STRL("No opcodes could be compiled | No file specified or compilation failed?\n"));
 			}
 			goto phpdbg_out;
 		}
 
 		PG(during_request_startup) = 0;
 
 		phpdbg_fully_started = 1;
 
 		/* phpdbg main() */
 		do {
 			zend_try {
 				if (phpdbg_startup_run) {
 					phpdbg_startup_run = 0;
 					if (quit_immediately) {
 						PHPDBG_G(flags) = (PHPDBG_G(flags) & ~PHPDBG_HAS_PAGINATION) | PHPDBG_IS_INTERACTIVE | PHPDBG_PREVENT_INTERACTIVE;
 					} else {
 						PHPDBG_G(flags) |= PHPDBG_IS_INTERACTIVE;
 					}
 					zend_try {
 						if (first_command) {
 							phpdbg_interactive(1, estrdup(first_command));
 						} else {
 							PHPDBG_COMMAND_HANDLER(run)(NULL);
 						}
 					} zend_end_try();
 					if (quit_immediately) {
 						/* if -r is on the command line more than once just quit */
 						EG(bailout) = __orig_bailout; /* reset zend_try */
 						exit_status = EG(exit_status);
 						break;
 					}
 				}
 
 				CG(unclean_shutdown) = 0;
 				phpdbg_interactive(1, NULL);
 			} zend_catch {
 				if ((PHPDBG_G(flags) & PHPDBG_IS_CLEANING)) {
 					char *bp_tmp_str;
 					PHPDBG_G(flags) |= PHPDBG_DISCARD_OUTPUT;
 					phpdbg_export_breakpoints_to_string(&bp_tmp_str);
 					PHPDBG_G(flags) &= ~PHPDBG_DISCARD_OUTPUT;
 					if (bp_tmp_str) {
 						bp_tmp = strdup(bp_tmp_str);
 						free(bp_tmp_str);
 					}
 					cleaning = 1;
 				} else {
 					cleaning = 0;
 				}
 			} zend_end_try();
 		} while (!(PHPDBG_G(flags) & PHPDBG_IS_STOPPING));
 
 #ifdef _WIN32
 	} __except(phpdbg_exception_handler_win32(xp = GetExceptionInformation())) {
 		phpdbg_error("Access violation (Segmentation fault) encountered\ntrying to abort cleanly...");
 	}
 #endif
 phpdbg_out:
 
 		phpdbg_purge_watchpoint_tree();
 
 		if (first_command) {
 			free(first_command);
 			first_command = NULL;
 		}
 
 		if (cleaning <= 0) {
 			PHPDBG_G(flags) &= ~PHPDBG_IS_CLEANING;
 			cleaning = -1;
 		}
 
 		{
 			int i;
 			/* free argv */
 			for (i = SG(request_info).argc; i--;) {
 				efree(SG(request_info).argv[i]);
 			}
 			efree(SG(request_info).argv);
 		}
 
 		if (ini_entries) {
 			free(ini_entries);
 		}
 
 		if (ini_override) {
 			free(ini_override);
 		}
 
 		/* In case we aborted during script execution, we may not reset CG(unclean_shutdown) */
 		if (!(PHPDBG_G(flags) & PHPDBG_IS_RUNNING)) {
 			is_exit = !PHPDBG_G(in_execution);
 			CG(unclean_shutdown) = is_exit || PHPDBG_G(unclean_eval);
 		}
 
 		if ((PHPDBG_G(flags) & (PHPDBG_IS_CLEANING | PHPDBG_IS_RUNNING)) == PHPDBG_IS_CLEANING) {
 			php_free_shutdown_functions();
 			zend_objects_store_mark_destructed(&EG(objects_store));
 		}
 
 		if (PHPDBG_G(exec) && strcmp("Standard input code", PHPDBG_G(exec)) == SUCCESS) { /* i.e. execution context has been read from stdin - back it up */
 			phpdbg_file_source *data = zend_hash_str_find_ptr(&PHPDBG_G(file_sources), PHPDBG_G(exec), PHPDBG_G(exec_len));
 			backup_phpdbg_compile = zend_string_alloc(data->len + 2, 1);
 			GC_MAKE_PERSISTENT_LOCAL(backup_phpdbg_compile);
 			sprintf(ZSTR_VAL(backup_phpdbg_compile), "?>%.*s", (int) data->len, data->buf);
 		}
 
 		zend_try {
 			php_request_shutdown(NULL);
 		} zend_end_try();
 
 		/* backup globals when cleaning */
 		if ((cleaning > 0) && !quit_immediately) {
 			settings = calloc(1, sizeof(zend_phpdbg_globals));
 
 			php_phpdbg_globals_ctor(settings);
 
 			if (PHPDBG_G(exec)) {
 				settings->exec = zend_strndup(PHPDBG_G(exec), PHPDBG_G(exec_len));
 				settings->exec_len = PHPDBG_G(exec_len);
 			}
 			settings->prompt[0] = PHPDBG_G(prompt)[0];
 			settings->prompt[1] = PHPDBG_G(prompt)[1];
 			memcpy(ZEND_VOIDP(settings->colors), PHPDBG_G(colors), sizeof(settings->colors));
 			settings->input_buflen = PHPDBG_G(input_buflen);
 			memcpy(settings->input_buffer, PHPDBG_G(input_buffer), settings->input_buflen);
 			settings->flags = PHPDBG_G(flags) & PHPDBG_PRESERVE_FLAGS_MASK;
 			first_command = PHPDBG_G(cur_command);
 		} else {
 			if (PHPDBG_G(prompt)[0]) {
 				free(PHPDBG_G(prompt)[0]);
 			}
 			if (PHPDBG_G(prompt)[1]) {
 				free(PHPDBG_G(prompt)[1]);
 			}
 			if (PHPDBG_G(cur_command)) {
 				free(PHPDBG_G(cur_command));
 			}
 		}
 
 		if (exit_status == 0) {
 			exit_status = EG(exit_status);
 		}
 
 		php_output_deactivate();
 
 		if (!(PHPDBG_G(flags) & PHPDBG_IS_QUITTING)) {
 			PHPDBG_G(flags) |= PHPDBG_IS_QUITTING;
 			if (PHPDBG_G(in_execution) || is_exit) {
 				if (!quit_immediately && !phpdbg_startup_run) {
 					PHPDBG_G(flags) -= PHPDBG_IS_QUITTING;
 					cleaning++;
 				}
 			}
 		}
 
 		{
 			zval *zv = zend_hash_str_find(php_stream_get_url_stream_wrappers_hash(), ZEND_STRL("php"));
 			Z_PTR_P(zv) = (void*)PHPDBG_G(orig_url_wrap_php);
 		}
 
 #ifndef _WIN32
 		/* force override (no zend_signals) to prevent crashes due to signal recursion in SIGSEGV/SIGBUS handlers */
 		signal(SIGSEGV, SIG_DFL);
 		signal(SIGBUS, SIG_DFL);
 
 		/* reset it... else we risk a stack overflow upon next run (when clean'ing) */
 		php_stream_stdio_ops.write = PHPDBG_G(php_stdiop_write);
 #endif
 	}
 
 	php_module_shutdown();
 
 	sapi_shutdown();
 
 	if (sapi_name) {
 		free(sapi_name);
 	}
 
 free_and_return:
 	if (read_from_stdin) {
 		free(read_from_stdin);
 		read_from_stdin = NULL;
 	}
 
 #ifdef ZTS
 	/* reset to original handlers - otherwise PHPDBG_G() in phpdbg_watch_efree will be segfaulty (with e.g. USE_ZEND_ALLOC=0) */
 	if (!use_mm_wrappers) {
 		zend_mm_set_custom_handlers(zend_mm_get_heap(), _malloc, _free, _realloc);
 	}
 
 	ts_free_id(phpdbg_globals_id);
 
 	tsrm_shutdown();
 #endif
 
 	if ((cleaning > 0) && !quit_immediately) {
 		/* reset internal php_getopt state */
 		php_getopt(-1, argv, OPTIONS, NULL, &php_optind, 0, 0);
 
 		goto phpdbg_main;
 	}
 
 	if (backup_phpdbg_compile) {
 		zend_string_free(backup_phpdbg_compile);
 	}
 
 	/* usually 0; just for -rr */
 	return exit_status;
 } /* }}} */
diff --git a/sapi/phpdbg/phpdbg.h b/sapi/phpdbg/phpdbg.h
index 45c5eb0593..1da3b055dd 100644
--- a/sapi/phpdbg/phpdbg.h
+++ b/sapi/phpdbg/phpdbg.h
@@ -233,78 +233,82 @@ struct _phpdbg_oplog_list {
 /* {{{ structs */
 ZEND_BEGIN_MODULE_GLOBALS(phpdbg)
 	HashTable bp[PHPDBG_BREAK_TABLES];           /* break points */
 	HashTable registered;                        /* registered */
 	HashTable seek;                              /* seek oplines */
 	zend_execute_data *seek_ex;                  /* call frame of oplines to seek to */
 	zend_object *handled_exception;              /* last handled exception (prevent multiple handling of same exception) */
 	phpdbg_frame_t frame;                        /* frame */
 	uint32_t last_line;                          /* last executed line */
 
 	char *cur_command;                           /* current command */
 	phpdbg_lexer_data lexer;                     /* lexer data */
 	phpdbg_param_t *parser_stack;                /* param stack during lexer / parser phase */
 
 #ifndef _WIN32
 	struct sigaction old_sigsegv_signal;         /* segv signal handler */
+#endif
+#ifdef HAVE_USERFAULTFD_WRITEFAULT
+    int watch_userfaultfd;                       /* userfaultfd(2) handler, 0 if unused */
+    pthread_t watch_userfault_thread;            /* thread for watch fault handling */
 #endif
 	phpdbg_btree watchpoint_tree;                /* tree with watchpoints */
 	phpdbg_btree watch_HashTables;               /* tree with original dtors of watchpoints */
 	HashTable watch_elements;                    /* user defined watch elements */
 	HashTable watch_collisions;                  /* collision table to check if multiple watches share the same recursive watchpoint */
 	HashTable watch_recreation;                  /* watch elements pending recreation of their respective watchpoints */
 	HashTable watch_free;                        /* pointers to watch for being freed */
 	HashTable *watchlist_mem;                    /* triggered watchpoints */
 	HashTable *watchlist_mem_backup;             /* triggered watchpoints backup table while iterating over it */
 	bool watchpoint_hit;                    /* a watchpoint was hit */
 	void (*original_free_function)(void *);      /* the original AG(mm_heap)->_free function */
 	phpdbg_watch_element *watch_tmp;             /* temporary pointer for a watch element */
 
 	char *exec;                                  /* file to execute */
 	size_t exec_len;                             /* size of exec */
 	zend_op_array *ops;                 	     /* op_array */
 	zval retval;                                 /* return value */
 	int bp_count;                                /* breakpoint count */
 	int vmret;                                   /* return from last opcode handler execution */
 	bool in_execution;                      /* in execution? */
 	bool unclean_eval;                      /* do not check for memory leaks when we needed to bail out during eval */
 
 	zend_op_array *(*compile_file)(zend_file_handle *file_handle, int type);
 	zend_op_array *(*init_compile_file)(zend_file_handle *file_handle, int type);
 	zend_op_array *(*compile_string)(zend_string *source_string, const char *filename, zend_compile_position position);
 	HashTable file_sources;
 
 	zend_arena *oplog_arena;                     /* arena for storing oplog */
 	phpdbg_oplog_list *oplog_list;               /* list of oplog starts */
 	phpdbg_oplog_entry *oplog_cur;               /* current oplog entry */
 
 	struct {
 		int fd;
 	} io[PHPDBG_IO_FDS];                         /* io */
 	ssize_t (*php_stdiop_write)(php_stream *, const char *, size_t);
 	struct {
 		bool active;
 		int type;
 		int fd;
 		char *msg;
 		int msglen;
 	} err_buf;                                   /* error buffer */
 	zend_ulong req_id;                           /* "request id" to keep track of commands */
 
 	char *prompt[2];                             /* prompt */
 	const phpdbg_color_t *colors[PHPDBG_COLORS]; /* colors */
 	char *buffer;                                /* buffer */
 	bool last_was_newline;                  /* check if we don't need to output a newline upon next phpdbg_error or phpdbg_notice */
 
 	FILE *stdin_file;                            /* FILE pointer to stdin source file */
 	const php_stream_wrapper *orig_url_wrap_php;
 
 	char input_buffer[PHPDBG_MAX_CMD];           /* stdin input buffer */
 	int input_buflen;                            /* length of stdin input buffer */
 	phpdbg_signal_safe_mem sigsafe_mem;          /* memory to use in async safe environment (only once!) */
 
 	JMP_BUF *sigsegv_bailout;                    /* bailout address for accessibility probing */
 
 	uint64_t flags;                              /* phpdbg flags */
 
 	char *sapi_name_ptr;                         /* store sapi name to free it if necessary to not leak memory */
 	zend_ulong lines;                                  /* max number of lines to display */
diff --git a/sapi/phpdbg/phpdbg_watch.c b/sapi/phpdbg/phpdbg_watch.c
index 4da831019d..05155bdd06 100644
--- a/sapi/phpdbg/phpdbg_watch.c
+++ b/sapi/phpdbg/phpdbg_watch.c
@@ -111,6 +111,13 @@
 # include <sys/mman.h>
 #endif
 
+#ifdef HAVE_USERFAULTFD_WRITEFAULT
+# include <pthread.h>
+# include <linux/userfaultfd.h>
+# include <sys/ioctl.h>
+# include <sys/syscall.h>
+#endif
+
 ZEND_EXTERN_MODULE_GLOBALS(phpdbg)
 
 const phpdbg_command_t phpdbg_watch_commands[] = {
@@ -208,28 +215,58 @@ void phpdbg_print_watch_diff(phpdbg_watchtype type, zend_string *name, void *old
 }
 
 /* ### LOW LEVEL WATCHPOINT HANDLING ### */
-static phpdbg_watchpoint_t *phpdbg_check_for_watchpoint(void *addr) {
+static phpdbg_watchpoint_t *phpdbg_check_for_watchpoint(phpdbg_btree *tree, void *addr) {
 	phpdbg_watchpoint_t *watch;
-	phpdbg_btree_result *result = phpdbg_btree_find_closest(&PHPDBG_G(watchpoint_tree), (zend_ulong) phpdbg_get_page_boundary(addr) + phpdbg_pagesize - 1);
+	phpdbg_btree_result *result = phpdbg_btree_find_closest(tree, (zend_ulong) phpdbg_get_page_boundary(addr) + phpdbg_pagesize - 1);
 
 	if (result == NULL) {
 		return NULL;
 	}
 
 	watch = result->ptr;
 
 	/* check if that addr is in a mprotect()'ed memory area */
 	if ((char *) phpdbg_get_page_boundary(watch->addr.ptr) > (char *) addr || (char *) phpdbg_get_page_boundary(watch->addr.ptr) + phpdbg_get_total_page_size(watch->addr.ptr, watch->size) < (char *) addr) {
 		/* failure */
 		return NULL;
 	}
 
 	return watch;
 }
 
 static void phpdbg_change_watchpoint_access(phpdbg_watchpoint_t *watch, int access) {
+	void *page_addr = phpdbg_get_page_boundary(watch->addr.ptr);
+	size_t size = phpdbg_get_total_page_size(watch->addr.ptr, watch->size);
+#ifdef HAVE_USERFAULTFD_WRITEFAULT
+	if (PHPDBG_G(watch_userfaultfd)) {
+		struct uffdio_range range = {
+			.start = (__u64) page_addr,
+			.len = size
+		};
+		if (access == PROT_READ) {
+			struct uffdio_register reg = {
+				.mode = UFFDIO_REGISTER_MODE_WP,
+				.range = range
+			};
+			struct uffdio_writeprotect protect = {
+				.mode = UFFDIO_WRITEPROTECT_MODE_WP,
+				.range = range
+			};
+			ioctl(PHPDBG_G(watch_userfaultfd), UFFDIO_REGISTER,  &reg);
+			ioctl(PHPDBG_G(watch_userfaultfd), UFFDIO_WRITEPROTECT,  &protect);
+		} else {
+			struct uffdio_register reg = {
+				.mode = UFFDIO_REGISTER_MODE_WP,
+				.range = range
+			};
+			ioctl(PHPDBG_G(watch_userfaultfd), UFFDIO_UNREGISTER,  &reg);
+		}
+	} else
+#endif
 	/* pagesize is assumed to be in the range of 2^x */
-	mprotect(phpdbg_get_page_boundary(watch->addr.ptr), phpdbg_get_total_page_size(watch->addr.ptr, watch->size), access);
+	{
+		mprotect(page_addr, size, access);
+	}
 }
 
 static inline void phpdbg_activate_watchpoint(phpdbg_watchpoint_t *watch) {
@@ -246,28 +283,51 @@ int phpdbg_watchpoint_segfault_handler(void *addr) {
 #else
 int phpdbg_watchpoint_segfault_handler(siginfo_t *info, void *context) {
 #endif
 
 	void *page = phpdbg_get_page_boundary(
 #ifdef _WIN32
 		addr
 #else
 		info->si_addr
 #endif
 	);
 
 	/* perhaps unnecessary, but check to be sure to not conflict with other segfault handlers */
-	if (phpdbg_check_for_watchpoint(page) == NULL) {
+	if (phpdbg_check_for_watchpoint(&PHPDBG_G(watchpoint_tree), page) == NULL) {
 		return FAILURE;
 	}
 
 	/* re-enable writing */
 	mprotect(page, phpdbg_pagesize, PROT_READ | PROT_WRITE);
 
 	zend_hash_index_add_empty_element(PHPDBG_G(watchlist_mem), (zend_ulong) page);
 
 	return SUCCESS;
 }
 
+#ifdef HAVE_USERFAULTFD_WRITEFAULT
+void *phpdbg_watchpoint_userfaultfd_thread(void *phpdbg_globals) {
+	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+	zend_phpdbg_globals *globals = (zend_phpdbg_globals *) phpdbg_globals;
+
+	struct uffd_msg fault_msg = {0};
+	while (read(globals->watch_userfaultfd, &fault_msg, sizeof(fault_msg)) == sizeof(fault_msg)) {
+    	void *page = phpdbg_get_page_boundary((char *) fault_msg.arg.pagefault.address);
+		zend_hash_index_add_empty_element(globals->watchlist_mem, (zend_ulong) page);
+		struct uffdio_writeprotect unprotect = {
+			.mode = 0,
+			.range = {
+				.start = (__u64) page,
+				.len = phpdbg_pagesize
+			}
+		};
+		ioctl(globals->watch_userfaultfd, UFFDIO_WRITEPROTECT, &unprotect);
+	}
+
+	return NULL;
+}
+#endif
+
 /* ### REGISTER WATCHPOINT ### To be used only by watch element and collision managers ### */
 static inline void phpdbg_store_watchpoint_btree(phpdbg_watchpoint_t *watch) {
 	phpdbg_btree_result *res;
@@ -327,27 +387,27 @@ void phpdbg_watch_backup_data(phpdbg_watchpoint_t *watch) {
 /* ### MANAGE WATCH COLLISIONS ### To be used only by watch element manager and memory differ ### */
 /* watch collisions are responsible for having only one watcher on a given refcounted/refval and having a mapping back to the parent zvals */
 void phpdbg_delete_watch_collision(phpdbg_watchpoint_t *watch) {
 	phpdbg_watch_collision *coll;
 	if ((coll = zend_hash_index_find_ptr(&PHPDBG_G(watch_collisions), (zend_ulong) watch->ref))) {
 		zend_hash_index_del(&coll->parents, (zend_ulong) watch);
 		if (zend_hash_num_elements(&coll->parents) == 0) {
-			phpdbg_deactivate_watchpoint(&coll->ref);
 			phpdbg_remove_watchpoint_btree(&coll->ref);
+			phpdbg_deactivate_watchpoint(&coll->ref);
 
 			if (coll->ref.type == WATCH_ON_ZVAL) {
 				phpdbg_delete_watch_collision(&coll->ref);
 			} else if (coll->reference.addr.ptr) {
-				phpdbg_deactivate_watchpoint(&coll->reference);
 				phpdbg_remove_watchpoint_btree(&coll->reference);
+				phpdbg_deactivate_watchpoint(&coll->reference);
 				phpdbg_delete_watch_collision(&coll->reference);
 				if (coll->reference.type == WATCH_ON_STR) {
 					zend_string_release(coll->reference.backup.str);
 				}
 			}
 
 			zend_hash_index_del(&PHPDBG_G(watch_collisions), (zend_ulong) watch->ref);
 			zend_hash_destroy(&coll->parents);
 			efree(coll);
 		}
 	}
 }
@@ -607,22 +667,22 @@ void phpdbg_watch_parent_ht(phpdbg_watch_element *element) {
 void phpdbg_unwatch_parent_ht(phpdbg_watch_element *element) {
 	if (element->watch->type == WATCH_ON_BUCKET) {
 		phpdbg_btree_result *res = phpdbg_btree_find(&PHPDBG_G(watch_HashTables), (zend_ulong) element->parent_container);
 		ZEND_ASSERT(element->parent_container);
 		if (res) {
 			phpdbg_watch_ht_info *hti = res->ptr;
 
 			if (zend_hash_num_elements(&hti->watches) == 1) {
 				zend_hash_destroy(&hti->watches);
 				phpdbg_btree_delete(&PHPDBG_G(watch_HashTables), (zend_ulong) hti->ht);
-				phpdbg_deactivate_watchpoint(&hti->hash_watch);
 				phpdbg_remove_watchpoint_btree(&hti->hash_watch);
+				phpdbg_deactivate_watchpoint(&hti->hash_watch);
 				efree(hti);
 			} else {
 				zend_hash_del(&hti->watches, element->name_in_parent);
 			}
 		}
 	}
 }
 
 /* ### DE/QUEUE WATCH ELEMENTS ### to be used by watch element manager only */
 /* implicit watchpoints may change (especially because of separation); elements updated by remove & re-add etc.; thus we need to wait a little bit (until next opcode) and then compare whether the watchpoint still exists and if not, remove it */
@@ -887,20 +947,20 @@ void phpdbg_update_watch_collision_elements(phpdbg_watchpoint_t *watch) {
 void phpdbg_remove_watchpoint(phpdbg_watchpoint_t *watch) {
 	phpdbg_watch_element *element;
 
-	phpdbg_deactivate_watchpoint(watch);
 	phpdbg_remove_watchpoint_btree(watch);
+	phpdbg_deactivate_watchpoint(watch);
 	phpdbg_delete_watch_collision(watch);
 
 	if (watch->coll) {
 		phpdbg_update_watch_collision_elements(watch);
 		return;
 	}
 
 	watch->elements.nNumOfElements++; /* dirty hack to avoid double free */
 	ZEND_HASH_FOREACH_PTR(&watch->elements, element) {
 		phpdbg_update_watch_element_watch(element);
 	} ZEND_HASH_FOREACH_END();
 	zend_hash_destroy(&watch->elements);
 
 	efree(watch);
 }
@@ -944,115 +1004,115 @@ zend_string *phpdbg_watchpoint_change_collision_name(phpdbg_watchpoint_t *watch)
 /* ### WATCHING FOR CHANGES ### */
 /* TODO: enforce order: first parents, then children, in order to avoid false positives */
 void phpdbg_check_watchpoint(phpdbg_watchpoint_t *watch) {
 	zend_string *name = NULL;
 	void *comparePtr;
 
 	if (watch->type == WATCH_ON_HASHTABLE) {
 		phpdbg_watch_element *element;
 		zend_string *str;
 		zend_long idx;
 		zval *zv;
 		ZEND_HASH_FOREACH_PTR(&watch->elements, element) {
 			if (element->flags & PHPDBG_WATCH_RECURSIVE) {
 				phpdbg_btree_result *res = phpdbg_btree_find(&PHPDBG_G(watch_HashTables), (zend_ulong) HT_WATCH_HT(watch));
 				phpdbg_watch_ht_info *hti = res ? res->ptr : NULL;
 
 				ZEND_HASH_REVERSE_FOREACH_KEY_VAL(HT_WATCH_HT(watch), idx, str, zv) {
 					if (!str) {
 						str = zend_long_to_str(idx); // TODO: hack, use proper int handling for name in parent
 					} else {
 						str = zend_string_copy(str);
 					}
 					if (hti && zend_hash_find(&hti->watches, str)) {
 						zend_string_release(str);
 						break;
 					}
 					ZEND_HASH_FOREACH_PTR(&watch->elements, element) {
 						if (element->flags & PHPDBG_WATCH_RECURSIVE) {
 							phpdbg_add_recursive_watch_from_ht(element, idx, str, zv);
 						}
 					} ZEND_HASH_FOREACH_END();
 					phpdbg_notice("Element %.*s has been added to watchpoint", (int) ZSTR_LEN(str), ZSTR_VAL(str));
 					zend_string_release(str);
 					PHPDBG_G(watchpoint_hit) = 1;
 				} ZEND_HASH_FOREACH_END();
 
 				break;
 			}
 		} ZEND_HASH_FOREACH_END();
 	}
 	if (watch->type == WATCH_ON_HASHDATA) {
 		return;
 	}
 
 	switch (watch->type) {
 		case WATCH_ON_STR:
 			comparePtr = &ZSTR_LEN(watch->backup.str);
 			break;
 		case WATCH_ON_HASHTABLE:
 			comparePtr = (char *) &watch->backup.ht + HT_WATCH_OFFSET;
 			break;
 		default:
 			comparePtr = &watch->backup;
 	}
 	if (!phpdbg_check_watch_diff(watch->type, comparePtr, watch->addr.ptr)) {
 		return;
 	}
 	if (watch->type == WATCH_ON_REFCOUNTED && !(PHPDBG_G(flags) & PHPDBG_SHOW_REFCOUNTS)) {
 		phpdbg_watch_backup_data(watch);
 		return;
 	}
 	if (watch->type == WATCH_ON_BUCKET) {
 		if (watch->backup.bucket.key != watch->addr.bucket->key || (watch->backup.bucket.key != NULL && watch->backup.bucket.h != watch->addr.bucket->h)) {
 			phpdbg_watch_element *element = NULL;
 			zval *new;
 
 			ZEND_HASH_FOREACH_PTR(&watch->elements, element) {
 				break;
 			} ZEND_HASH_FOREACH_END();
 
 			ZEND_ASSERT(element); /* elements must be non-empty */
 			new = zend_symtable_find(element->parent_container, element->name_in_parent);
 
 			if (!new) {
 				/* dequeuing will take care of appropriate notification about removal */
 				phpdbg_remove_watchpoint(watch);
 				return;
 			}
 
-			phpdbg_deactivate_watchpoint(watch);
 			phpdbg_remove_watchpoint_btree(watch);
+			phpdbg_deactivate_watchpoint(watch);
 			watch->addr.zv = new;
 			phpdbg_store_watchpoint_btree(watch);
 			phpdbg_activate_watchpoint(watch);
 
 			if (!phpdbg_check_watch_diff(WATCH_ON_ZVAL, &watch->backup.bucket.val, watch->addr.ptr)) {
 				phpdbg_watch_backup_data(watch);
 				return;
 			}
 		} else if (Z_TYPE_P(watch->addr.zv) == IS_UNDEF) {
 			/* dequeuing will take care of appropriate notification about removal */
 			phpdbg_remove_watchpoint(watch);
 			return;
 		}
 	}
 
 	name = phpdbg_watchpoint_change_collision_name(watch);
 
 	if (name) {
 		phpdbg_print_watch_diff(watch->type, name, comparePtr, watch->addr.ptr);
 		zend_string_release(name);
 	}
 
 	if (watch->type == WATCH_ON_ZVAL || watch->type == WATCH_ON_BUCKET) {
 		phpdbg_watch_element *element;
 		phpdbg_update_watch_ref(watch);
 		ZEND_HASH_FOREACH_PTR(&watch->elements, element) {
 			if (element->flags & PHPDBG_WATCH_RECURSIVE) {
 				phpdbg_recurse_watch_element(element);
 			}
 		} ZEND_HASH_FOREACH_END();
 	}
 
 	phpdbg_watch_backup_data(watch);
 }
@@ -1060,17 +1120,31 @@ void phpdbg_check_watchpoint(phpdbg_watchpoint_t *watch) {
 void phpdbg_reenable_memory_watches(void) {
 	zend_ulong page;
 	phpdbg_btree_result *res;
 	phpdbg_watchpoint_t *watch;
 
 	ZEND_HASH_FOREACH_NUM_KEY(PHPDBG_G(watchlist_mem), page) {
 		/* Disable writing again if there are any watchers on that page */
 		res = phpdbg_btree_find_closest(&PHPDBG_G(watchpoint_tree), page + phpdbg_pagesize - 1);
 		if (res) {
 			watch = res->ptr;
 			if ((char *) page < (char *) watch->addr.ptr + watch->size) {
-				mprotect((void *) page, phpdbg_pagesize, PROT_READ);
+#ifdef HAVE_USERFAULTFD_WRITEFAULT
+				if (PHPDBG_G(watch_userfaultfd)) {
+					struct uffdio_writeprotect protect = {
+						.mode = UFFDIO_WRITEPROTECT_MODE_WP,
+						.range = {
+							.start = (__u64) page,
+							.len = phpdbg_pagesize
+						}
+					};
+					ioctl(PHPDBG_G(watch_userfaultfd), UFFDIO_WRITEPROTECT,  &protect);
+				} else
+#endif
+				{
+					mprotect((void *) page, phpdbg_pagesize, PROT_READ);
+				}
 			}
 		}
 	} ZEND_HASH_FOREACH_END();
 	zend_hash_clean(PHPDBG_G(watchlist_mem));
 }
@@ -1374,52 +1448,71 @@ PHPDBG_WATCH(array) /* {{{ */
 void phpdbg_setup_watchpoints(void) {
 #if defined(_SC_PAGE_SIZE)
 	phpdbg_pagesize = sysconf(_SC_PAGE_SIZE);
 #elif defined(_SC_PAGESIZE)
 	phpdbg_pagesize = sysconf(_SC_PAGESIZE);
 #elif defined(_SC_NUTC_OS_PAGESIZE)
 	phpdbg_pagesize = sysconf(_SC_NUTC_OS_PAGESIZE);
 #else
 	phpdbg_pagesize = 4096; /* common pagesize */
 #endif
 
 	phpdbg_btree_init(&PHPDBG_G(watchpoint_tree), sizeof(void *) * 8);
 	phpdbg_btree_init(&PHPDBG_G(watch_HashTables), sizeof(void *) * 8);
 	zend_hash_init(&PHPDBG_G(watch_elements), 8, NULL, NULL, 0);
 	zend_hash_init(&PHPDBG_G(watch_collisions), 8, NULL, NULL, 0);
 	zend_hash_init(&PHPDBG_G(watch_recreation), 8, NULL, NULL, 0);
 	zend_hash_init(&PHPDBG_G(watch_free), 8, NULL, NULL, 0);
 
 	/* put these on a separate page, to avoid conflicts with other memory */
 	PHPDBG_G(watchlist_mem) = malloc(phpdbg_pagesize > sizeof(HashTable) ? phpdbg_pagesize : sizeof(HashTable));
 	zend_hash_init(PHPDBG_G(watchlist_mem), phpdbg_pagesize / (sizeof(Bucket) + sizeof(uint32_t)), NULL, NULL, 1);
 	PHPDBG_G(watchlist_mem_backup) = malloc(phpdbg_pagesize > sizeof(HashTable) ? phpdbg_pagesize : sizeof(HashTable));
 	zend_hash_init(PHPDBG_G(watchlist_mem_backup), phpdbg_pagesize / (sizeof(Bucket) + sizeof(uint32_t)), NULL, NULL, 1);
 
 	PHPDBG_G(watch_tmp) = NULL;
+
+#ifdef HAVE_USERFAULTFD_WRITEFAULT
+	PHPDBG_G(watch_userfaultfd) = syscall(SYS_userfaultfd, O_CLOEXEC);
+	if (PHPDBG_G(watch_userfaultfd) < 0) {
+		PHPDBG_G(watch_userfaultfd) = 0;
+	} else {
+		struct uffdio_api userfaultfd_features = {0};
+		userfaultfd_features.api = UFFD_API;
+		userfaultfd_features.features = UFFD_FEATURE_PAGEFAULT_FLAG_WP;
+		ioctl(PHPDBG_G(watch_userfaultfd), UFFDIO_API, &userfaultfd_features);
+		if (userfaultfd_features.features & UFFD_FEATURE_PAGEFAULT_FLAG_WP) {
+			pthread_create(&PHPDBG_G(watch_userfault_thread), NULL, phpdbg_watchpoint_userfaultfd_thread, ZEND_MODULE_GLOBALS_BULK(phpdbg));
+		} else {
+			PHPDBG_G(watch_userfaultfd) = 0;
+		}
+	}
+#endif
 }
 
 void phpdbg_destroy_watchpoints(void) {
 	phpdbg_watch_element *element;
-	phpdbg_btree_position pos;
-	phpdbg_btree_result *res;
 
 	/* unconditionally free all remaining elements to avoid memory leaks */
 	ZEND_HASH_FOREACH_PTR(&PHPDBG_G(watch_recreation), element) {
 		phpdbg_automatic_dequeue_free(element);
 	} ZEND_HASH_FOREACH_END();
 
 	/* upon fatal errors etc. (i.e. CG(unclean_shutdown) == 1), some watchpoints may still be active. Ensure memory is not watched anymore for next run. Do not care about memory freeing here, shutdown is unclean and near anyway. */
-	pos = phpdbg_btree_find_between(&PHPDBG_G(watchpoint_tree), 0, -1);
-	while ((res = phpdbg_btree_next(&pos))) {
-		phpdbg_deactivate_watchpoint(res->ptr);
+    phpdbg_purge_watchpoint_tree();
+
+#ifdef HAVE_USERFAULTFD_WRITEFAULT
+	if (PHPDBG_G(watch_userfaultfd)) {
+		pthread_cancel(PHPDBG_G(watch_userfault_thread));
+		close(PHPDBG_G(watch_userfaultfd));
 	}
+#endif
 
 	zend_hash_destroy(&PHPDBG_G(watch_elements)); PHPDBG_G(watch_elements).nNumOfElements = 0; /* phpdbg_watch_efree() is checking against this arrays size */
 	zend_hash_destroy(&PHPDBG_G(watch_recreation));
 	zend_hash_destroy(&PHPDBG_G(watch_free));
 	zend_hash_destroy(&PHPDBG_G(watch_collisions));
 	zend_hash_destroy(PHPDBG_G(watchlist_mem));
 	free(PHPDBG_G(watchlist_mem));
 	zend_hash_destroy(PHPDBG_G(watchlist_mem_backup));
 	free(PHPDBG_G(watchlist_mem_backup));
 }
