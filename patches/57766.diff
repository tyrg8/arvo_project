commit 761da806fc950c6b26c1763e8989a814e9b16a59
Author: David Anderson <davea42@linuxmail.org>
Date:   Sun Apr 9 11:17:05 2023 -0700

    Fixing DW202304-002 oss fuzz  57766
    A  read off the end of the relevant (.debug_str_offsets)
    section.
    
    Using renamed fields related to str_offsets
            modified:   src/lib/libdwarf/dwarf_die_deliv.c
            modified:   src/lib/libdwarf/dwarf_fission_to_cu.c
    
    Add a new check for sanity in reading indexes
    to be used on str_offsets.
    Simplify and correct
    _dwarf_extract_string_offset_via_str_offsets()
            modified:   src/lib/libdwarf/dwarf_form.c
    
    Revise the list of values used in str_offsets
    data for cu contexts. Document the fields better.
    Put the boolean markers next to what they relate
    to.  Delete a useless boolean.
            modified:   src/lib/libdwarf/dwarf_opaque.h
    
    Using renamed fields related to str_offsets
            modified:   src/lib/libdwarf/dwarf_query.c
            modified:   src/lib/libdwarf/dwarf_str_offsets.c

diff --git a/src/lib/libdwarf/dwarf_die_deliv.c b/src/lib/libdwarf/dwarf_die_deliv.c
index eca97217..cba0ae66 100644
--- a/src/lib/libdwarf/dwarf_die_deliv.c
+++ b/src/lib/libdwarf/dwarf_die_deliv.c
@@ -1081,329 +1081,329 @@ static int
 find_cu_die_base_fields(Dwarf_Debug dbg,
     Dwarf_CU_Context cucon,
     Dwarf_Die cudie,
     Dwarf_Error*    error)
 {
     Dwarf_CU_Context  cu_context = 0;
     Dwarf_Attribute * alist = 0;
     Dwarf_Signed      atcount = 0;
     unsigned          version_stamp = 2;
     int               alres = 0;
     Dwarf_Signed      i = 0;
     Dwarf_Signed low_pc_attrnum = -1;
     Dwarf_Signed entry_pc_attrnum = -1;
     Dwarf_Signed at_addr_base_attrnum = -1;
 
     cu_context = cudie->di_cu_context;
     version_stamp = cu_context->cc_version_stamp;
 
     alres = dwarf_attrlist(cudie, &alist,
         &atcount,error);
     if (alres != DW_DLV_OK) {
         /* Something is badly wrong. No attrlist! */
         return alres;
     }
     /*  DW_AT_dwo_id and/or DW_AT_GNU_dwo_id
         are only found  in some
         experimental DWARF4.
         Even DWARF3,4 use DW_AT_low_pc as base address
         DWARF5 changed CU header contents
         to make this attribute unnecessary.
         DW_AT_GNU_odr_signature is the same format,
         but is in a different namespace so not
         appropriate here..
     */
     for (i = 0;  i < atcount; ++i) {
         Dwarf_Half attrnum = 0;
         Dwarf_Half form = 0;
         int ares = 0;
         int ares2 = 0;
         Dwarf_Attribute attr = alist[i];
 
         ares = dwarf_whatattr(attr,&attrnum,error);
         if (ares == DW_DLV_ERROR && error) {
             dwarf_dealloc_error(dbg,*error);
             *error = 0;
         }
         ares2 = dwarf_whatform(attr,&form,error);
         if (ares2 == DW_DLV_ERROR && error) {
             dwarf_dealloc_error(dbg,*error);
             *error = 0;
         }
         /*  We are not returning on DW_DLV_NO_ENTRY
             or DW_DLV_ERROR here. Such will be
             caught later. Lets finish a CU die
             scan and finish the cu_context  */
         if (ares == DW_DLV_OK && ares2 == DW_DLV_OK) {
             switch(form) {
             case DW_FORM_strx:
             case DW_FORM_strx1:
             case DW_FORM_strx2:
             case DW_FORM_strx3:
             case DW_FORM_strx4:
                 cucon->cc_at_strx_present = TRUE;
             default:
                 break;
             }
             switch(attrnum) {
             case DW_AT_dwo_id:
             case DW_AT_GNU_dwo_id: {
                 Dwarf_Sig8 signature;
                 /*  This is for DWARF4 with an early
                     non-standard version
                     of split dwarf. Not DWARF5. */
                 int sres = 0;
                 if (version_stamp != DW_CU_VERSION4 ) {
                     /* Not supposed to happen. */
                     local_attrlist_dealloc(dbg,atcount,alist);
                     _dwarf_error(dbg,error,
                         DW_DLE_IMPROPER_DWO_ID);
                     return DW_DLV_ERROR;
                 }
                 signature = dwarfsig8zero;
                 sres = dwarf_formsig8_const(attr,
                     &signature,error);
                 if (sres == DW_DLV_OK) {
                     if (!cucon->cc_signature_present) {
                         cucon->cc_signature = signature;
                         cucon->cc_signature_present = TRUE;
                     } else {
                         /*  Something wrong. Two styles of sig?
                             Can happen with DWARF4
                             debug-fission extension DWO_id.
                         */
                         if (memcmp(&signature,&cucon->cc_signature,
                             sizeof(signature))) {
                             /*  The two sigs do not match! */
                             const char *m="DW_DLE_SIGNATURE_MISMATCH"
                                 "DWARF4 extension fission signature"
                                 " and DW_AT_GNU_dwo_id do not match"
                                 " ignoring DW_AT[_GNU]_dwo_id";
                             dwarf_insert_harmless_error(dbg,
                                 (char*)m);
                         }
                     }
                 } else {
                     /* Something is badly wrong. */
                     local_attrlist_dealloc(dbg,atcount,alist);
                     return sres;
                 }
                     /* Something is badly wrong. */
                 break;
             }
             /*  If, in .debug_rnglists for a CU the
                 applicable range has no base address
                 this attribute provides a base address.
                 If this is indexed doing this now would
                 lead to an infinite recursion.
                 So wait till all the other fields seen.
             */
             case DW_AT_low_pc: {
                 low_pc_attrnum = i;
                 break;
             }
             /*  DW_AT_producer 4.2.1 (Based on Apple Inc. build 5658)
                 (LLVM build 2336.1.00) uses DW_AT_entry_pc as the
                 base address (DW_AT_entry_pc
                 first appears in DWARF3).
                 So we allow that as an extension,
                 as a 'low_pc' if there is DW_AT_entry_pc with
                 no DW_AT_low_pc. 19 May 2022.
             */
             case DW_AT_entry_pc: {
                 entry_pc_attrnum = i;
                 break;
             }
 
             /*  The offset is of the first offset in
                 .debug_str_offsets that is the string table
-                for this CU. */
+                offset array for this CU. */
             case DW_AT_str_offsets_base:{
                 int udres = 0;
                 Dwarf_Bool is_info = cucon->cc_is_info;
 
                 udres = _dwarf_internal_global_formref_b(attr,
                     /* avoid recurse creating context */ 1,
-                    &cucon->cc_str_offsets_header_offset,
+                    &cucon->cc_str_offsets_array_offset,
                     &is_info,
                     error);
                 if (udres == DW_DLV_OK) {
-                    cucon->cc_str_offsets_tab_present = TRUE;
+                    cucon->cc_str_offsets_array_offset_present = TRUE;
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
             }
             /*  offset in .debug_loclists  of the offsets table
                 applicable to this CU. */
             case DW_AT_loclists_base: {
                 int udres = 0;
                 Dwarf_Bool is_info = cucon->cc_is_info;
 
                 udres = _dwarf_internal_global_formref_b(attr,
                     /* avoid recurse creating context */ 1,
                     &cucon->cc_loclists_base,
                     &is_info,
                     error);
                 if (udres == DW_DLV_OK) {
                     cucon->cc_loclists_base_present = TRUE;
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
                 }
             /*  Base offset  in .debug_addr of the addr table
                 for this CU. DWARF5 (and possibly GNU DWARF4)
                 So we really want to look in only
                 this section, not an offset referring
                 to another (DWARF5 debug_info vs debug_types) */
             case DW_AT_addr_base:
             case DW_AT_GNU_addr_base: {
                 int udres = 0;
                 Dwarf_Bool is_info = cucon->cc_is_info;
 
                 at_addr_base_attrnum = i;
 
                 udres = _dwarf_internal_global_formref_b(attr,
                     /* avoid recurse creating context */ 1,
                     &cucon->cc_addr_base,
                     &is_info,
                     error);
                 if (udres == DW_DLV_OK) {
                     if (is_info == cucon->cc_is_info) {
                         /*  Only accept if same .debug section,
                             which is relevant for DWARF4 */
                         cucon->cc_addr_base_present = TRUE;
                     }
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
             }
             case DW_AT_GNU_ranges_base: {
             /*  The DW4 ranges base was never used in GNU
                 but did get emitted in skeletons.
                 http://llvm.1065342.n5.nabble.com/
                 DebugInfo-DW-AT-GNU-ranges-base-in-
                 non-fission-td64194.html
                 But we accept it anyway. */
             /*  offset in .debug_rnglists  of the offsets table
                 applicable to this CU.
                 Note that this base applies when
                 referencing from the dwp, but NOT
                 when referencing from the a.out */
                 int udres = 0;
                 Dwarf_Bool is_info = cucon->cc_is_info;
 
                 udres = _dwarf_internal_global_formref_b(attr,
                     /* avoid recurse creating context */ 1,
                     &cucon->cc_ranges_base,
                     &is_info,
                     error);
                 if (udres == DW_DLV_OK) {
                     cucon->cc_ranges_base_present = TRUE;
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
                 }
             case  DW_AT_rnglists_base: {
                 int udres = 0;
                 Dwarf_Bool is_info = cucon->cc_is_info;
 
                 udres = _dwarf_internal_global_formref_b(attr,
                     /* avoid recurse creating context */ 1,
                     &cucon->cc_rnglists_base,
                     &is_info,
                     error);
                 if (udres == DW_DLV_OK) {
                     cucon->cc_rnglists_base_present = TRUE;
                 } else {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     /* Something is badly wrong. */
                     return udres;
                 }
                 break;
                 }
             /*  A signature, found in a DWARF5 skeleton
                 compilation unit. */
             case DW_AT_GNU_dwo_name:
             case DW_AT_dwo_name: {
                 int dnres = 0;
 
                 dnres = dwarf_formstring(attr,
                     &cucon->cc_dwo_name,error);
                 if (dnres != DW_DLV_OK) {
                     local_attrlist_dealloc(dbg,atcount,alist);
                     return dnres;
                 }
                 cucon->cc_dwo_name_present = TRUE;
                 break;
                 }
             default: /* do nothing, not an attribute
                 we need to deal with here. */
                 break;
             }
         }
     }
     if (low_pc_attrnum >= 0 ){
         int battr = 0;
 
         /* Prefer DW_AT_low_pc */
         Dwarf_Attribute attr = alist[low_pc_attrnum];
         battr = _dwarf_setup_base_address(dbg,"DW_AT_low_pc",
             attr,at_addr_base_attrnum, cucon,error);
         if (battr != DW_DLV_OK) {
             local_attrlist_dealloc(dbg,atcount,alist);
             /* Something is badly wrong */
             return battr;
         }
     } else if (entry_pc_attrnum >= 0) {
         int battr = 0;
 
         /*  Pretending that DW_AT_entry_pc with no
             DW_AT_low_pc is a valid base address for
             loccation lists.
             DW_AT_producer 4.2.1 (Based on Apple Inc. build 5658)
             (LLVM build 2336.1.00) uses DW_AT_entry_pc as the
             base address (DW_AT_entry_pc first appears in DWARF3).
             So we allow that as an extension,
             as a 'low_pc' if there is DW_AT_entry_pc with
             no DW_AT_low_pc. 19 May 2022. */
         Dwarf_Attribute attr = alist[entry_pc_attrnum];
         battr = _dwarf_setup_base_address(dbg,"DW_AT_entry_pc",
             attr,at_addr_base_attrnum, cucon,error);
         if (battr != DW_DLV_OK) {
             local_attrlist_dealloc(dbg,atcount,alist);
             /* Something is badly wrong */
             return battr;
         }
     }
     local_attrlist_dealloc(dbg,atcount,alist);
     alist = 0;
     atcount = 0;
     {
         int chres = 0;
         Dwarf_Half flag = 0;
 
         /*  always winds up with cc_cu_die_has_children
             set intentionally...to something. */
         cucon->cc_cu_die_has_children = TRUE;
         chres = dwarf_die_abbrev_children_flag(cudie,&flag);
         /*  If chres is not DW_DLV_OK the assumption
             of children remains true. */
         if (chres == DW_DLV_OK) {
             cucon->cc_cu_die_has_children = flag;
         }
     }
     return DW_DLV_OK;
 }
 
 /*  Called only for DWARF4 */
diff --git a/src/lib/libdwarf/dwarf_fission_to_cu.c b/src/lib/libdwarf/dwarf_fission_to_cu.c
index f6d96817..782e2720 100644
--- a/src/lib/libdwarf/dwarf_fission_to_cu.c
+++ b/src/lib/libdwarf/dwarf_fission_to_cu.c
@@ -53,57 +53,57 @@ static int
 load_xu_loclists_into_cucontext(Dwarf_Debug dbg,
     Dwarf_CU_Context cu_context,
     struct Dwarf_Debug_Fission_Per_CU_s*fsd,
     int fsd_index,
     Dwarf_Error *error)
 {
     Dwarf_Unsigned size = 0;
     Dwarf_Unsigned soff_hdroffset = 0;
     Dwarf_Unsigned soff_size = 0;
     struct Dwarf_Loclists_Context_s localcontxt;
     Dwarf_Loclists_Context buildhere = &localcontxt;
     Dwarf_Unsigned nextset = 0;
     int res = 0;
 
     if (!fsd) {
         _dwarf_error_string(dbg, error, DW_DLE_XU_TYPE_ARG_ERROR,
             "DW_DLE_XU_TYPE_ARG_ERROR: a required argument to"
             "load_xu_loclists_into_cucontext() is NULL");
         return DW_DLV_ERROR;
     }
     localcontxt = localcontxt_zero;
     size = fsd->pcu_size[fsd_index];
     soff_hdroffset = fsd->pcu_offset[fsd_index];
     soff_size = dbg->de_debug_loclists.dss_size;
     if (!soff_size) {
         return DW_DLV_NO_ENTRY;
     }
     if (soff_hdroffset >= soff_size) {
         /*  Something is badly wrong. Ignore it here. */
         return DW_DLV_NO_ENTRY;
     }
     memset(buildhere,0,sizeof(localcontxt));
     res = _dwarf_internal_read_loclists_header(dbg,
         0,soff_size,
         dbg->de_debug_loclists.dss_data,
         dbg->de_debug_loclists.dss_data +soff_size,
         soff_hdroffset,
         buildhere,
         &nextset,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     cu_context->cc_loclists_base_present = TRUE;
     cu_context->cc_loclists_base_contr_size = size;
     cu_context->cc_loclists_base            =
         buildhere->lc_offsets_off_in_sect;
     return DW_DLV_OK;
 }
 
-/*  ASSERT: cc_str_offsets_base_present FALSE
-    ASSERT: cc_str_offsets_header_length_present  FALSE
+/*  
+   
     ASSERT: dbg,cu_context, and fsd are non-NULL
     as the caller ensured that.
     If .debug_cu_index or
     .debug_tu_index is present it might help us find
     the offset for this CU's .debug_str_offsets.
 */
@@ -111,69 +111,69 @@ static int
 load_xu_str_offsets_into_cucontext(Dwarf_Debug dbg,
     Dwarf_CU_Context cu_context,
     struct Dwarf_Debug_Fission_Per_CU_s*fsd,
     int fsd_index,
     Dwarf_Error *error )
 {
     Dwarf_Small *soff_secptr = 0;
     Dwarf_Unsigned soff_hdroffset = 0;
     Dwarf_Unsigned soff_size = 0;
     Dwarf_Small *soff_eptr = 0;
     int res = 0;
 
     res = _dwarf_load_section(dbg, &dbg->de_debug_str_offsets,
         error);
     if (res != DW_DLV_OK) {
         return res;
     }
     soff_hdroffset = fsd->pcu_offset[fsd_index];
     soff_secptr = dbg->de_debug_str_offsets.dss_data;
     soff_size = dbg->de_debug_str_offsets.dss_size;
     if (soff_hdroffset >= soff_size) {
         /*  Something is badly wrong. Ignore it here. */
         return DW_DLV_NO_ENTRY;
     }
 
     {
         Dwarf_Unsigned length = 0;
         Dwarf_Half     offset_size = 0;
         Dwarf_Half     extension_size = 0;
         Dwarf_Half     version = 0;
         Dwarf_Half     padding = 0;
         Dwarf_Unsigned local_offset_to_array=0;
         Dwarf_Unsigned total_table_length   =0;
         struct Dwarf_Str_Offsets_Table_s  sotstr;
 
         memset(&sotstr,0,sizeof(sotstr));
         sotstr.so_dbg = dbg;
         sotstr.so_section_start_ptr = soff_secptr;
         sotstr.so_section_end_ptr = soff_eptr;
         sotstr.so_section_size = soff_size;
         sotstr.so_next_table_offset = soff_hdroffset;
         res =  _dwarf_read_str_offsets_header(&sotstr,
             cu_context,
             &length,&offset_size,
             &extension_size,&version,&padding,
             &local_offset_to_array,
             &total_table_length,
             error);
         if (res != DW_DLV_OK) {
             if (res == DW_DLV_ERROR && error) {
                 dwarf_dealloc_error(dbg,*error);
                 *error = 0;
             }
             return DW_DLV_NO_ENTRY;
         }
         /*  See dwarf_opaque.h for comments. */
         cu_context->cc_str_offsets_tab_present = TRUE;
         cu_context->cc_str_offsets_header_offset = soff_hdroffset;
-        cu_context->cc_str_offsets_tab_to_array_present = TRUE;
         cu_context->cc_str_offsets_tab_to_array =
             local_offset_to_array;
-        cu_context->cc_str_offsets_offset_size = offset_size;
+        cu_context->cc_str_offsets_table_size = total_table_length;
         cu_context->cc_str_offsets_version = version;
+        cu_context->cc_str_offsets_offset_size = offset_size;
     }
     return DW_DLV_OK;
 }
 
 /*  ASSERT: dbg,cu_context, and fsd are non-NULL
     as the caller ensured that. */
diff --git a/src/lib/libdwarf/dwarf_form.c b/src/lib/libdwarf/dwarf_form.c
index de8c98f6..e99a6fb2 100644
--- a/src/lib/libdwarf/dwarf_form.c
+++ b/src/lib/libdwarf/dwarf_form.c
@@ -1055,6 +1055,9 @@ dwarf_get_debug_addr_index(Dwarf_Attribute attr,
     return DW_DLV_ERROR;
 }
 
+/*  The index value here is the value of the
+    attribute with this form.
+    FORMs passed in are always strx forms. */
 static int
 dw_read_str_index_val_itself(Dwarf_Debug dbg,
     unsigned theform,
@@ -1107,30 +1110,45 @@ int
 dwarf_get_debug_str_index(Dwarf_Attribute attr,
     Dwarf_Unsigned *return_index,
     Dwarf_Error *error)
 {
     int theform = attr->ar_attribute_form;
     Dwarf_CU_Context cu_context = 0;
     Dwarf_Debug dbg = 0;
     int res  = 0;
     Dwarf_Byte_Ptr section_end =  0;
     Dwarf_Unsigned index = 0;
     Dwarf_Small *info_ptr = 0;
     int indxres = 0;
+    Dwarf_Unsigned length_size = 0;
+    Dwarf_Unsigned sectionlen = 0;
 
+    
     res = get_attr_dbg(&dbg,&cu_context,attr,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     section_end =
         _dwarf_calculate_info_section_end_ptr(cu_context);
     info_ptr = attr->ar_debug_ptr;
 
     indxres = dw_read_str_index_val_itself(dbg, theform, info_ptr,
         section_end, &index,error);
     if (indxres == DW_DLV_OK) {
         *return_index = index;
         return indxres;
     }
+    length_size = cu_context->cc_length_size;
+    sectionlen = dbg->de_debug_str_offsets.dss_size;
+    if (index > sectionlen ||
+        (index *length_size) > sectionlen) {
+        _dwarf_error_string(dbg, error,
+            DW_DLE_ATTR_FORM_SIZE_BAD,
+            "DW_DLE_ATTR_FORM_SIZE_BAD: "
+            "An Attribute Value (index  into "
+            ".debug_str_offsets) is Impossibly "            
+            "large. Corrupt Dwarf.");
+        return DW_DLV_ERROR;
+    }
     return indxres;
 }
 
@@ -1693,127 +1711,143 @@ dwarf_formblock(Dwarf_Attribute attr,
     return DW_DLV_OK;
 }
 
+/*  This is called for attribute with strx form
+    or macro5 with strx form. 
+    No relation to the Name Table or
+    to  FIXME */
 int
 _dwarf_extract_string_offset_via_str_offsets(Dwarf_Debug dbg,
     Dwarf_Small *data_ptr,
     Dwarf_Small *end_data_ptr,
     Dwarf_Half   attrform,
     Dwarf_CU_Context cu_context,
     Dwarf_Unsigned *str_sect_offset_out,
     Dwarf_Error *error)
 {
     Dwarf_Unsigned index_to_offset_entry = 0;
-    Dwarf_Unsigned offsetintable = 0;
-    Dwarf_Unsigned end_offsetintable = 0;
+    Dwarf_Unsigned offsettotable = 0;
+    Dwarf_Unsigned end_offsettotable = 0;
     Dwarf_Unsigned indexoffset = 0;
     Dwarf_Unsigned baseoffset = 0;
     Dwarf_Unsigned table_offset_to_array = 0;
     int res = 0;
     int idxres = 0;
     Dwarf_Small *sectionptr = 0;
     Dwarf_Unsigned sectionlen = 0;
     Dwarf_Small   *sof_start = 0;
     Dwarf_Small   *sof_end = 0;
     Dwarf_Unsigned str_sect_offset = 0;
     Dwarf_Unsigned length_size  = 0;
+    Dwarf_Bool have_array_offset = FALSE;
 
     res = _dwarf_load_section(dbg, &dbg->de_debug_str_offsets,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     sectionptr = dbg->de_debug_str_offsets.dss_data;
     sectionlen = dbg->de_debug_str_offsets.dss_size;
     length_size = cu_context->cc_length_size;
     /*  If this is a dwp we look there, but I suppose
         we could also look for the section in the tied
         executable object file it is not here. FIXME */
     idxres = dw_read_str_index_val_itself(dbg,
         attrform,data_ptr,end_data_ptr,&index_to_offset_entry,error);
     if ( idxres != DW_DLV_OK) {
         return idxres;
     }
-
-    if (cu_context->cc_str_offsets_tab_present) {
+    if (cu_context->cc_str_offsets_array_offset_present) {
+        baseoffset = cu_context->cc_str_offsets_array_offset;
+        have_array_offset = TRUE;
+    } else if (cu_context->cc_str_offsets_tab_present) {
         baseoffset = cu_context->cc_str_offsets_header_offset;
+        baseoffset += cu_context->cc_str_offsets_tab_to_array;
+        have_array_offset = TRUE;
+    } else { /* do nothing */}
+    if (baseoffset > sectionlen ||
+        (baseoffset+length_size) > sectionlen ||
+        (baseoffset+(index_to_offset_entry *length_size)) >
+            sectionlen) {
+        _dwarf_error_string(dbg, error,
+            DW_DLE_ATTR_FORM_SIZE_BAD,
+            "DW_DLE_ATTR_FORM_SIZE_BAD: "
+            "An Attribute value (offset  into "
+            ".debug_str_offsets) is impossibly "            
+            "large. Corrupt Dwarf.");
+        return DW_DLV_ERROR;
     }
-    if (cu_context->cc_str_offsets_tab_to_array_present) {
-        table_offset_to_array =
-            cu_context->cc_str_offsets_tab_to_array;
-    }
-
-    if (!cu_context->cc_str_offsets_tab_present ||
-        !cu_context->cc_str_offsets_tab_to_array_present) {
+    indexoffset = index_to_offset_entry* length_size;
+    if (!have_array_offset) {
         /*  missing any connection to a specific
             str_offsets table this guesses at table zero.
             When the compiler/linker have
             combined str offsets into a
             single table this works. */
+        Dwarf_Unsigned headeroffset = 0;
         if (cu_context->cc_version_stamp ==  DW_CU_VERSION5 ) {
             /*  A base offset of 0 is ok for either
                 DWARF5. but some early GNU compilers emitted
                 DWARF4 .debug_str_offsets, so lets check
                 the first table.  */
             Dwarf_Unsigned stsize =
                 dbg->de_debug_str_offsets.dss_size;
             Dwarf_Unsigned length           = 0;
             Dwarf_Unsigned table_length     = 0;
             Dwarf_Half local_offset_size    = 0;
             Dwarf_Half local_extension_size = 0;
             Dwarf_Half version              = 0;
             Dwarf_Half padding              = 0;
 
             res = _dwarf_trial_read_dwarf_five_hdr(dbg,
-                baseoffset,stsize,
+                headeroffset,stsize,
                 &table_offset_to_array,
                 &table_length,
                 &length, &local_offset_size,
                 &local_extension_size,
                 &version,
                 &padding,
                 error);
             if (res == DW_DLV_OK) {
-                /* baseoffset unchanged */
+                baseoffset = table_offset_to_array+
+                    headeroffset;
             } else {
                 if (res == DW_DLV_ERROR && error) {
                     dwarf_dealloc_error(dbg,*error);
                     *error = 0;
                 } else {}
             }
         }
     }
-    indexoffset = index_to_offset_entry* length_size;
-    offsetintable = indexoffset+ baseoffset
-        + table_offset_to_array;
-    end_offsetintable = offsetintable + length_size;
+    offsettotable = indexoffset+ baseoffset;
+    end_offsettotable = offsettotable + length_size;
     /*  The offsets table is a series of offset-size entries.
         The == case in the test applies when we are at the last table
         entry, so == is not an error, hence only test >
     */
-    if (end_offsetintable  > sectionlen) {
+    if (offsettotable  > sectionlen ||
+        end_offsettotable  > sectionlen) {
         dwarfstring m;
 
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_ATTR_FORM_SIZE_BAD: The end offset of "
             "a .debug_str_offsets table is 0x%x ",
-            end_offsetintable);
+            end_offsettotable);
         dwarfstring_append_printf_u(&m,
             "but the object section is just 0x%x "
             "bytes long",
             sectionlen);
         _dwarf_error_string(dbg, error,
             DW_DLE_ATTR_FORM_SIZE_BAD,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
-
-    sof_start = sectionptr+ offsetintable;
-    sof_end = sectionptr + end_offsetintable;
+    sof_start = sectionptr+ offsettotable;
+    sof_end = sectionptr + end_offsettotable;
     /* Now read the string offset from the offset table. */
     READ_UNALIGNED_CK(dbg,str_sect_offset,Dwarf_Unsigned,
         sof_start,
         length_size,error,sof_end);
     *str_sect_offset_out = str_sect_offset;
     return DW_DLV_OK;
 }
diff --git a/src/lib/libdwarf/dwarf_opaque.h b/src/lib/libdwarf/dwarf_opaque.h
index 481a5283..c80325c1 100644
--- a/src/lib/libdwarf/dwarf_opaque.h
+++ b/src/lib/libdwarf/dwarf_opaque.h
@@ -137,198 +137,210 @@ struct Dwarf_Attribute_s {
     **Updated by dwarf_next_cu_header in dwarf_die_deliv.c
 */
 struct Dwarf_CU_Context_s {
     Dwarf_Debug cc_dbg;
     /*  The sum of cc_length, cc_length_size, and cc_extension_size
         is the total length of the CU including its header.
         cc_length is the length of the compilation unit excluding
         cc_length_size and cc_extension_size.  */
     Dwarf_Unsigned cc_length;
 
     /*  cc_length_size is the size in bytes of an offset.
         Should probably be renamed cc_offset_size.
         4 for 32bit dwarf, 8 for 64bit dwarf (whether MIPS/IRIX
         64bit dwarf or standard 64bit dwarf using the extension
         mechanism). */
     Dwarf_Small cc_length_size;
 
     /*  cc_extension_size is zero unless this is standard
         DWARF3 and later 64bit dwarf using the extension mechanism.
         64bit DWARF3 and later: cc_extension_size is 4.
         64bit DWARF2 MIPS/IRIX: cc_extension_size is zero.
         32bit DWARF:            cc_extension_size is zero.  */
     Dwarf_Small cc_extension_size;
 
     /*  cc_version_stamp is the DWARF version number applicable
         to the  DWARF in this compilation unit. 2,3,4,... */
     Dwarf_Half cc_version_stamp;
     /*  cc_abbrev_offset is the section-global offset
         of the .debug_abbrev section this CU uses.
         Data from CU header. Includes DWP adjustment made
         as soon as we create a cu_context. */
     Dwarf_Unsigned cc_abbrev_offset;
 
     /*  cc_address_size is the size of an address in this
         compilation unit. */
     Dwarf_Small cc_address_size;
     Dwarf_Small cc_segment_selector_size;
 
     /*  cc_debug_offset is the global offset in the section
         of the area length field of the CU.
         The CU header of the CU is at offset
         cc_debug_offset+cc_length_size+cc_extension_size;
         This is a section global offset.
         May be debug_info or debug_types.
         Even in DWP this is set to true global offset
         right away when cu_context created.
         See cc_is_info flag. */
     Dwarf_Unsigned cc_debug_offset;
 
     /* === START DEBUG FISSION (Split Dwarf) data
         cc_signature is in the TU header
         of a type unit of a TU DIE (or for DW5 in the
         skeleton or split_compile header is a dwo_id).
         Ignore this field if cc_signature_present is zero.
         (TU CUs signature is not the same namespace
         as DW_AT_dwo_id signatures. The two must be
         kept separate (for DWARF5))
 
         If cc_unit_type == DW_UT_compile or DW_UT_partial
             the signature is a CU signature (dwo_id).
         Some early DW5 drafts encouraged DWARF4 output
             of some compilers to include dwo_id, but
             in a messier way(lacking DW_UT_*).
         If cc_unit_type ==  DW_UT_split_type
             the signature is a type signature. */
     Dwarf_Half  cc_cu_die_tag;
 
     Dwarf_Sig8  cc_signature;
 
     /*  cc_type_signature_offset contains the
         section-local DIE offset of the type
         the signature applies to if the cc_unit_type
         is DW_UT_type or DW_UT_split_type. */
     Dwarf_Unsigned cc_signature_offset;
 
     /*  For each CU and each TU
         in a dwp package file there is
         is a hash and
         a set of offsets indexed by DW_SECT_* id.
         Only one such set per CU or TU.
         The data on all that is in cc_dwp_offsets
 
         If it is a TU the signature in cc_dwp_offsets
         must match the signature in cc_signature.
         */
     struct Dwarf_Debug_Fission_Per_CU_s  cc_dwp_offsets;
 
     Dwarf_Bool cc_signature_present; /* Meaning type signature
         in TU header or, for CU header, signature in CU DIE. */
     Dwarf_Bool cc_low_pc_present;
     Dwarf_Bool cc_addr_base_present;   /* Not TRUE in .dwo */
 
     Dwarf_Bool cc_cu_die_has_children;
     Dwarf_Bool cc_dwo_name_present;
     Dwarf_Bool cc_at_strx_present;
 
     /*  Non zero if this context is a dwo section. Either
         dwo or dwp file. */
     Dwarf_Bool cc_is_dwo;
 
     /*  cc_cu_die_offset_present is non-zero if
         cc_cu_die_global_sec_offset is meaningful.  */
     Dwarf_Bool     cc_cu_die_offset_present;
 
     /*  If present, is base address of CU.  In DWARF2
         nothing says what attribute is the base address.
         DW_AT_producer 4.2.1 (Based on Apple Inc. build 5658)
         (LLVM build 2336.1.00) uses DW_AT_entry_pc as the
         base address.  DW_AT_entry_pc first appears
         in DWARF3.
         We allow  DW_AT_entry_pc as an extension,
         as a 'low_pc' if there is DW_AT_entry_pc with
         no DW_AT_low_pc. 19 May 2022.
         In DWARF3, DWARF4 DW_AT_low_pc is specifically
         mentioned as the base address.  */
     Dwarf_Unsigned cc_low_pc;
     /*  from DW_AT_addr_base in CU DIE, offset to .debug_addr table */
     Dwarf_Unsigned cc_addr_base;  /* Zero in .dwo */
 
     /*  DW_SECT_LINE */
     Dwarf_Bool     cc_line_base_present;     /*DW5 */
     Dwarf_Unsigned cc_line_base;             /*DW5 */
     Dwarf_Unsigned cc_line_base_contr_size;  /*DW5 */
 
     /*  From DW_AT_loclists_base or DW_SECT_LOCLISTS */
     Dwarf_Unsigned cc_loclists_base;
     Dwarf_Unsigned cc_loclists_base_contr_size;
     Dwarf_Bool     cc_loclists_base_present;
     Dwarf_Bool     cc_loclists_header_length_present;
 
-    /*  .debug_str_offsets DW_SECT_STR_OFFSETS DW4 DW5 vs
-        DW_AT_str_offsets_base (table array offset) .
-        Here cc_str_offsets_tab_present
-        paired with cc_str_offsets_header_offset
-        which is what the offset means */
+    /* ======= str_offsets table data  =======*/
+    /*  header_offset is global offset in str_offsets section
+        of an array of string offsets. Not a header offset
+        at all.
+        from DW_AT_str_offsets_base DW5 page 66 item 13.
+        Not related to the Name Table */
+    /*  Set from DW_AT_str_offsets_base. Global offset. */
+    Dwarf_Bool     cc_str_offsets_array_offset_present;
+    Dwarf_Unsigned cc_str_offsets_array_offset;
+
+    /*  Set from str_offsets header, means all the relevant
+        data from the header is present. Does not mean
+        the data from DW_AT_str_offsets_base is present */
     Dwarf_Bool     cc_str_offsets_tab_present;
-    /*  Without tab_to_array present we cannot do much. */
-    Dwarf_Bool     cc_str_offsets_tab_to_array_present;
+    /*  Set from str_offsets header. */
+    Dwarf_Unsigned cc_str_offsets_header_offset;
 
-    /*  header_offset is global offset in str_offsets section. */
-    Dwarf_Unsigned cc_str_offsets_header_offset; /* cu/tu etc*/
-    Dwarf_Unsigned cc_str_offsets_table_size;
-
-    /*  to get from the start of a str_offsets table to the
-        offsets array entries. */
+    /*  Set by reading str_offsets header. Local offset
+        from header to its array. */
     Dwarf_Unsigned cc_str_offsets_tab_to_array;
+
+    /*  The following three set but not used. Might
+        be useful for error checking. */
     Dwarf_Unsigned cc_str_offsets_offset_size;
+    /*  The size of the table from table header
+        to end of this table. Not the size of array
+        in the table */
+    Dwarf_Unsigned cc_str_offsets_table_size;
     Dwarf_Half     cc_str_offsets_version;
+    /* ======= end str_offsets table data  =======*/
 
     /*  DW_SECT_MACRO */
     Dwarf_Unsigned cc_macro_base;    /*DW5 */
     Dwarf_Unsigned cc_macro_base_contr_size;    /*DW5 */
     Dwarf_Bool     cc_macro_base_present;
     Dwarf_Bool     cc_macro_header_length_present;
 
     /*  DW_SECT_RNGLISTS  */
     Dwarf_Unsigned cc_rnglists_base;    /*DW5 */
     Dwarf_Unsigned cc_rnglists_base_contr_size;    /*DW5 */
     /*  DW_AT_GNU_ranges_base was a GNU extension that appeared
         but was unused. See dwarf_die_deliv.c for details. */
     Dwarf_Unsigned cc_ranges_base;
     /*  DW_AT_GNU_ranges_base is a GNU extension, DW4  */
     Dwarf_Bool     cc_ranges_base_present;
     /* .debug_rnglists */
     Dwarf_Bool     cc_rnglists_base_present; /* DW5 */
     Dwarf_Bool     cc_rnglists_header_length_present;
 
     char *         cc_dwo_name;
     /* === END DEBUG FISSION (Split Dwarf) data */
 
     /*  Global section offset to the bytes of the CU die for this CU.
         Set when the CU die is accessed by dwarf_siblingof_b(). */
     Dwarf_Unsigned cc_cu_die_global_sec_offset;
 
     Dwarf_Byte_Ptr   cc_last_abbrev_ptr;
     Dwarf_Byte_Ptr   cc_last_abbrev_endptr;
     Dwarf_Hash_Table cc_abbrev_hash_table;
     Dwarf_Unsigned   cc_highest_known_code;
     Dwarf_CU_Context cc_next;
 
     Dwarf_Bool cc_is_info;    /* TRUE means context is
         in debug_info, FALSE means is in debug_types.
         FALSE only possible for DWARF4 .debug_types
         section CUs.
         For DWARF5 all DIEs are in .debug_info[.dwo] */
 
     Dwarf_Half cc_unit_type; /* DWARF5
         Set from header as a DW_UT_ value.
         For DWARF 2,3,4 this is filled in initially
         from the CU header and refined by inspecting
         the CU DIE to detect the correct setting. */
 
 };
 
 /*  Consolidates section-specific data in one place.
     Section is an Elf specific term, intended as a general
     term (for non-Elf objects some code must synthesize the
     values somehow).  */
diff --git a/src/lib/libdwarf/dwarf_query.c b/src/lib/libdwarf/dwarf_query.c
index 1078d2a7..557bbeca 100644
--- a/src/lib/libdwarf/dwarf_query.c
+++ b/src/lib/libdwarf/dwarf_query.c
@@ -1194,83 +1194,79 @@ int
 _dwarf_merge_all_base_attrs_of_cu_die(Dwarf_Debug dbg,
     Dwarf_CU_Context context,
     Dwarf_Debug tieddbg,
     Dwarf_CU_Context *tiedcontext_out,
     Dwarf_Error *error)
 {
     Dwarf_CU_Context tiedcontext = 0;
     int res = 0;
 
     if (!tieddbg) {
         return DW_DLV_NO_ENTRY;
     }
     if (!context->cc_signature_present) {
         return DW_DLV_NO_ENTRY;
     }
     res = _dwarf_search_for_signature(tieddbg,
         context->cc_signature,
         &tiedcontext,
         error);
     if ( res == DW_DLV_ERROR) {
         /* Associate the error with dbg, not tieddbg */
         _dwarf_error_mv_s_to_t(tieddbg,error,dbg,error);
         return res;
     }
     if ( res == DW_DLV_NO_ENTRY) {
         return res;
     }
     if (!context->cc_low_pc_present) {
         context->cc_low_pc_present =
             tiedcontext->cc_low_pc_present;
         context->        cc_low_pc=
             tiedcontext->cc_low_pc;
     }
     if (!context->cc_addr_base_present) {
         context->        cc_addr_base_present =
             tiedcontext->cc_addr_base_present;
         context->        cc_addr_base=
             tiedcontext->cc_addr_base;
     }
     if (!context->cc_rnglists_base_present) {
         context->        cc_rnglists_base_present =
             tiedcontext->cc_rnglists_base_present;
         context->        cc_rnglists_base=
             tiedcontext->cc_rnglists_base;
     }
     if (!context->cc_loclists_base_present) {
         context->        cc_loclists_base_present =
             tiedcontext->cc_loclists_base_present;
         context->        cc_loclists_base=
             tiedcontext->cc_loclists_base;
     }
     if (!context->cc_str_offsets_tab_present) {
         context->        cc_str_offsets_tab_present =
             tiedcontext->cc_str_offsets_tab_present;
         context->        cc_str_offsets_header_offset=
             tiedcontext->cc_str_offsets_header_offset;
-    }
-    if (!context->cc_str_offsets_tab_to_array_present) {
-        context->        cc_str_offsets_tab_to_array_present =
-            tiedcontext->cc_str_offsets_tab_to_array_present;
         context->        cc_str_offsets_tab_to_array=
             tiedcontext->cc_str_offsets_tab_to_array;
         context->        cc_str_offsets_table_size=
             tiedcontext->cc_str_offsets_table_size;
         context->        cc_str_offsets_version=
             tiedcontext->cc_str_offsets_version;
         context->        cc_str_offsets_offset_size=
             tiedcontext->cc_str_offsets_offset_size;
     }
 
     /* GNU DW4 extension. */
     if (!context->        cc_ranges_base_present) {
         context->        cc_ranges_base_present =
             tiedcontext->cc_ranges_base_present;
         context->        cc_ranges_base =
             tiedcontext->cc_ranges_base;
     }
 
     if (tiedcontext_out) {
         *tiedcontext_out = tiedcontext;
     }
     return DW_DLV_OK;
 }
diff --git a/src/lib/libdwarf/dwarf_str_offsets.c b/src/lib/libdwarf/dwarf_str_offsets.c
index e0b97ef4..fafb14ff 100644
--- a/src/lib/libdwarf/dwarf_str_offsets.c
+++ b/src/lib/libdwarf/dwarf_str_offsets.c
@@ -389,108 +389,107 @@ int
 _dwarf_read_str_offsets_header(Dwarf_Str_Offsets_Table sot,
     Dwarf_CU_Context cucontext,
     /* Followed by return values/error */
     Dwarf_Unsigned *length_out,
     Dwarf_Half     *offset_size_out,
     Dwarf_Half     *extension_size_out,
     Dwarf_Half     *version_out,
     Dwarf_Half     *padding_out,
     Dwarf_Unsigned *local_offset_to_array_out,
     Dwarf_Unsigned *total_table_length_out,
     Dwarf_Error *error)
 {
     Dwarf_Unsigned length            = 0;
     Dwarf_Half local_offset_size = 0;
     Dwarf_Half local_extension_size = 0;
     Dwarf_Half version               = 0;
     Dwarf_Half padding               = 0;
     int            res = 0;
     Dwarf_Bool     is_dwarf_five = TRUE;
     Dwarf_Debug    dbg = sot->so_dbg;
     Dwarf_Unsigned secsize  = sot->so_section_size;
     Dwarf_Unsigned table_local_offset_of_array = 0;
     Dwarf_Unsigned total_table_length = 0;
     Dwarf_Unsigned globaltaboff = 0;
 
     globaltaboff = sot->so_next_table_offset;
     if (cucontext) {
-        if (cucontext->cc_str_offsets_tab_to_array_present) {
+        if (cucontext->cc_str_offsets_tab_present) {
             /*  cu_context has what it needs already and we do
                 not need the rest of what the interface
                 provides */
             return DW_DLV_OK;
         }
     }
     res = _dwarf_trial_read_dwarf_five_hdr(dbg,
         globaltaboff,
         secsize,
         &table_local_offset_of_array,
         &total_table_length,
         /* Length is the length field from the table involved */
         &length,
         &local_offset_size,
         &local_extension_size,
         &version,
         &padding,
         error);
     if (res != DW_DLV_OK) {
         if (res == DW_DLV_ERROR && error) {
             dwarf_dealloc_error(dbg,*error);
             *error = 0;
         }
         /*  If it's really DWARF5 but with a serious
             problem  this will think...NOT 5! */
         is_dwarf_five = FALSE;
     }
     if ( !is_dwarf_five) {
         length = secsize;
         /*  This is possibly
             GNU Dwarf4 extension .debug_str_offsets.
             It could also just be corrupted data.
             offset size is not going to be 8.
             de_length_size is a guess and not set at this point .
             We assume the data starts with the array
             of string offsets,
             and all in one simple array from start to end
             of section. */
         table_local_offset_of_array = 0;
         total_table_length = secsize;
         length = secsize;
         local_offset_size = 4;
         local_extension_size = 0;
         version = DW_STR_OFFSETS_VERSION4;
         padding = 0;
     }
 
     if (length_out) {
         *length_out = length;
     }
     if (offset_size_out) {
         *offset_size_out = local_offset_size;
     }
     if (extension_size_out) {
         *extension_size_out = local_extension_size;
     }
     if (version_out) {
         *version_out = version;
     }
     if (padding_out) {
         *padding_out = padding;
     }
     if (cucontext) {
         cucontext->cc_str_offsets_header_offset = globaltaboff;
         cucontext->cc_str_offsets_tab_present = TRUE;
         cucontext->cc_str_offsets_tab_to_array =
             table_local_offset_of_array;
-        cucontext->cc_str_offsets_tab_to_array_present = TRUE;
+        cucontext->cc_str_offsets_version   = version;
         cucontext->cc_str_offsets_offset_size  = local_offset_size;
         cucontext->cc_str_offsets_table_size   = total_table_length;
-        cucontext->cc_str_offsets_version   = version;
     }
     if (local_offset_to_array_out) {
         *local_offset_to_array_out = table_local_offset_of_array;
     }
     if (total_table_length_out) {
         *total_table_length_out = total_table_length;
     }
     return DW_DLV_OK;
 }
