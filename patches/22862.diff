commit 52ed601504b6fc462bd85576a4dab0f32fce7d96
Author: seladb <pcapplusplus@gmail.com>
Date:   Fri Sep 4 12:41:36 2020 +0530

    Bugfixes 22830, 22862 in oss-fuzz: GTP and PPPoE layers

diff --git a/Packet++/header/IPv4Layer.h b/Packet++/header/IPv4Layer.h
index c3178aa6..b3aa5e28 100644
--- a/Packet++/header/IPv4Layer.h
+++ b/Packet++/header/IPv4Layer.h
@@ -12,619 +12,619 @@
 /**
  * \namespace pcpp
  * \brief The main namespace for the PcapPlusPlus lib
  */
 namespace pcpp
 {
 
 	/**
 	 * @struct iphdr
 	 * Represents an IPv4 protocol header
 	 */
 #pragma pack(push, 1)
 	struct iphdr {
 #if (BYTE_ORDER == LITTLE_ENDIAN)
 		/** IP header length, has the value of 5 for IPv4 */
 		uint8_t internetHeaderLength:4,
 		/** IP version number, has the value of 4 for IPv4 */
 		ipVersion:4;
 #else
 		/** IP version number, has the value of 4 for IPv4 */
 		uint8_t ipVersion:4,
 		/** IP header length, has the value of 5 for IPv4 */
 		internetHeaderLength:4;
 #endif
 		/** type of service, same as Differentiated Services Code Point (DSCP)*/
 		uint8_t typeOfService;
 		/** Entire packet (fragment) size, including header and data, in bytes */
 		uint16_t totalLength;
 		/** Identification field. Primarily used for uniquely identifying the group of fragments of a single IP datagram*/
 		uint16_t ipId;
 		 /** Fragment offset field, measured in units of eight-byte blocks (64 bits) */
 		uint16_t fragmentOffset;
 		/** An eight-bit time to live field helps prevent datagrams from persisting (e.g. going in circles) on an internet.  In practice, the field has become a hop count */
 		uint8_t timeToLive;
 		/** Defines the protocol used in the data portion of the IP datagram. Must be one of ::IPProtocolTypes */
 		uint8_t protocol;
 		/** Error-checking of the header */
 		uint16_t headerChecksum;
 		/** IPv4 address of the sender of the packet */
 		uint32_t ipSrc;
 		/** IPv4 address of the receiver of the packet */
 		uint32_t ipDst;
 		/*The options start here. */
 	};
 #pragma pack(pop)
 
 	/**
 	 * An enum for all possible IPv4 and IPv6 protocol types
 	 */
 	enum IPProtocolTypes
 	{
 		/** Dummy protocol for TCP		*/
 		PACKETPP_IPPROTO_IP = 0,
 		/** IPv6 Hop-by-Hop options		*/
 		PACKETPP_IPPROTO_HOPOPTS = 0,
 		/** Internet Control Message Protocol	*/
 		PACKETPP_IPPROTO_ICMP = 1,
 		/** Internet Gateway Management Protocol */
 		PACKETPP_IPPROTO_IGMP = 2,
 		/** IPIP tunnels (older KA9Q tunnels use 94) */
 		PACKETPP_IPPROTO_IPIP = 4,
 		/** Transmission Control Protocol	*/
 		PACKETPP_IPPROTO_TCP = 6,
 		/** Exterior Gateway Protocol		*/
 		PACKETPP_IPPROTO_EGP = 8,
 		/** PUP protocol				*/
 		PACKETPP_IPPROTO_PUP = 12,
 		/** User Datagram Protocol		*/
 		PACKETPP_IPPROTO_UDP = 17,
 		/** XNS IDP protocol			*/
 		PACKETPP_IPPROTO_IDP = 22,
 		/** IPv6 header				*/
 		PACKETPP_IPPROTO_IPV6 = 41,
 		/** IPv6 Routing header			*/
 		PACKETPP_IPPROTO_ROUTING = 43,
 		/** IPv6 fragmentation header		*/
 		PACKETPP_IPPROTO_FRAGMENT = 44,
 		/** GRE protocol */
 		PACKETPP_IPPROTO_GRE = 47,
 		/** encapsulating security payload	*/
 		PACKETPP_IPPROTO_ESP = 50,
 		/** authentication header		*/
 		PACKETPP_IPPROTO_AH = 51,
 		/** ICMPv6				*/
 		PACKETPP_IPPROTO_ICMPV6 = 58,
 		/** IPv6 no next header			*/
 		PACKETPP_IPPROTO_NONE = 59,
 		/** IPv6 Destination options		*/
 		PACKETPP_IPPROTO_DSTOPTS = 60,
 		/** Raw IP packets			*/
 		PACKETPP_IPPROTO_RAW = 255,
 		/** Maximum value */
 		PACKETPP_IPPROTO_MAX
 	};
 
 
 	/**
 	 * An enum for supported IPv4 option types
 	 */
 	enum IPv4OptionTypes
 	{
 		/** End of Options List */
 		IPV4OPT_EndOfOptionsList = 0,
 		/** No Operation */
 		IPV4OPT_NOP = 1,
 		/** Record Route */
 		IPV4OPT_RecordRoute = 7,
 		/** MTU Probe */
 		IPV4OPT_MTUProbe = 11,
 		/** MTU Reply */
 		IPV4OPT_MTUReply = 12,
 		/** Quick-Start */
 		IPV4OPT_QuickStart = 25,
 		/** Timestamp */
 		IPV4OPT_Timestamp = 68,
 		/** Traceroute */
 		IPV4OPT_Traceroute = 82,
 		/** Security */
 		IPV4OPT_Security = 130,
 		/** Loose Source Route */
 		IPV4OPT_LooseSourceRoute = 131,
 		/** Extended Security */
 		IPV4OPT_ExtendedSecurity = 133,
 		/** Commercial Security */
 		IPV4OPT_CommercialSecurity = 134,
 		/** Stream ID */
 		IPV4OPT_StreamID = 136,
 		/** Strict Source Route */
 		IPV4OPT_StrictSourceRoute = 137,
 		/** Extended Internet Protocol */
 		IPV4OPT_ExtendedInternetProtocol = 145,
 		/** Address Extension */
 		IPV4OPT_AddressExtension = 147,
 		/** Router Alert */
 		IPV4OPT_RouterAlert = 148,
 		/** Selective Directed Broadcast */
 		IPV4OPT_SelectiveDirectedBroadcast = 149,
 		/** Dynamic Packet State */
 		IPV4OPT_DynamicPacketState = 151,
 		/** Upstream Multicast Pkt. */
 		IPV4OPT_UpstreamMulticastPkt = 152,
 		/** Unknown IPv4 option */
 		IPV4OPT_Unknown
 	};
 
 #define PCPP_IP_DONT_FRAGMENT  0x40
 #define PCPP_IP_MORE_FRAGMENTS 0x20
 
 	/**
 	 * @struct IPv4TimestampOptionValue
 	 * A struct representing a parsed value of the IPv4 timestamp option. This struct is used returned in IPv4OptionData#getTimestampOptionValue() method
 	 */
 	struct IPv4TimestampOptionValue
 	{
 		/**
 		 * An enum for IPv4 timestamp option types
 		 */
 		enum TimestampType
 		{
 			/** Value containing only timestamps */
 			TimestampOnly = 0,
 			/** Value containing both timestamps and IPv4 addresses */
 			TimestampAndIP = 1,
 			/** The IPv4 addresses are prespecified */
 			TimestampsForPrespecifiedIPs = 2,
 			/** Invalid or unknown value type */
 			Unknown = 3
 		};
 
 		/** The timestamp value type */
 		TimestampType type;
 
 		/** A list of timestamps parsed from the IPv4 timestamp option value */
 		std::vector<uint32_t> timestamps;
 
 		/** A list of IPv4 addresses parsed from the IPv4 timestamp option value */
 		std::vector<IPv4Address> ipAddresses;
 
 		/** The default constructor */
 		IPv4TimestampOptionValue() : type(IPv4TimestampOptionValue::Unknown) {}
 
 		/**
 		 * Clear the structure. Clean the timestamps and IP addresses vectors and set the type as IPv4TimestampOptionValue#Unknown
 		 */
 		void clear()
 		{
 			type = IPv4TimestampOptionValue::Unknown;
 			timestamps.clear();
 			ipAddresses.clear();
 		}
 	};
 
 
 	/**
 	 * @class IPv4Option
 	 * A wrapper class for IPv4 options. This class does not create or modify IPv4 option records, but rather
 	 * serves as a wrapper and provides useful methods for retrieving data from them
 	 */
 	class IPv4Option : public TLVRecord
 	{
 	public:
 
 		/**
 		 * A c'tor for this class that gets a pointer to the option raw data (byte array)
 		 * @param[in] optionRawData A pointer to the IPv4 option raw data
 		 */
 		IPv4Option(uint8_t* optionRawData) : TLVRecord(optionRawData) { }
 
 		/**
 		 * A d'tor for this class, currently does nothing
 		 */
 		~IPv4Option() { }
 
 		/**
 		 * A method for parsing the IPv4 option value as a list of IPv4 addresses. This method is relevant only for certain types of IPv4 options which their value is a list of IPv4 addresses
 		 * such as ::IPV4OPT_RecordRoute, ::IPV4OPT_StrictSourceRoute, ::IPV4OPT_LooseSourceRoute, etc. This method returns a vector of the IPv4 addresses. Blank IP addresses
 		 * (meaning zeroed addresses - 0.0.0.0) will not be added to the returned list. If some error occurs during the parsing or the value is invalid an empty vector is returned
 		 * @return A vector of IPv4 addresses parsed from the IPv4 option value
 		 */
 		std::vector<IPv4Address> getValueAsIpList() const
 		{
 			std::vector<IPv4Address> res;
 
 			if (m_Data == NULL)
 				return res;
 
 			size_t dataSize = getDataSize();
 			if (dataSize < 2)
 				return res;
 
 			uint8_t valueOffset = (uint8_t)(1);
 
 			while ((size_t)valueOffset < dataSize)
 			{
 				uint32_t curValue;
 				memcpy(&curValue, m_Data->recordValue + valueOffset, sizeof(uint32_t));
 				if (curValue == 0)
 					break;
 
 				res.push_back(IPv4Address(curValue));
 
 				valueOffset += (uint8_t)(4);
 			}
 
 			return res;
 		}
 
 		/**
 		 * A method for parsing the IPv4 timestamp option value. This method is relevant only for IPv4 timestamp option. For other option types an empty result will be returned.
 		 * The returned structure contains the timestamp value type (timestamp only, timestamp + IP addresses, etc.) as well as 2 vectors containing the list of timestamps and the list
 		 * of IP addresses (if applicable for the timestamp value type). Blank timestamps or IP addresses (meaning zeroed values - timestamp=0 or IP address=0.0.0.0) will not be added to
 		 * the lists. If some error occurs during the parsing or the value is invalid an empty result is returned
 		 * @return A structured containing the IPv4 timestamp value
 		 */
 		IPv4TimestampOptionValue getTimestampOptionValue() const
 		{
 			IPv4TimestampOptionValue res;
 			res.clear();
 
 			if (m_Data == NULL)
 				return res;
 
 			if (getIPv4OptionType() != IPV4OPT_Timestamp)
 				return res;
 
 			size_t dataSize =  getDataSize();
 			if (dataSize < 2)
 				return res;
 
 			res.type = (IPv4TimestampOptionValue::TimestampType)m_Data->recordValue[1];
 
 			uint8_t valueOffset = (uint8_t)(2);
 			bool readIPAddr = (res.type == IPv4TimestampOptionValue::TimestampAndIP);
 
 			while ((size_t)valueOffset < dataSize)
 			{
 				uint32_t curValue;
 				memcpy(&curValue, m_Data->recordValue + valueOffset, sizeof(uint32_t));
 				if (curValue == 0)
 					break;
 
 				if (readIPAddr)
 					res.ipAddresses.push_back(IPv4Address(curValue));
 				else
 					res.timestamps.push_back(curValue);
 
 				if (res.type == IPv4TimestampOptionValue::TimestampAndIP)
 					readIPAddr = !readIPAddr;
 
 				valueOffset += (uint8_t)(4);
 			}
 
 			return res;
 		}
 
 		/**
 		 * @return IPv4 option type casted as pcpp::IPv4OptionTypes enum
 		 */
 		IPv4OptionTypes getIPv4OptionType() const
 		{
 			if (m_Data == NULL)
 				return IPV4OPT_Unknown;
 
 			return (IPv4OptionTypes)m_Data->recordType;
 		}
 
 
 		// implement abstract methods
 
 		size_t getTotalSize() const
 		{
 			if (m_Data == NULL)
 				return 0;
 
 			if (getIPv4OptionType() == (uint8_t)IPV4OPT_EndOfOptionsList || m_Data->recordType == (uint8_t)IPV4OPT_NOP)
 				return sizeof(uint8_t);
 
 			return (size_t)m_Data->recordLen;
 		}
 
 		size_t getDataSize() const
 		{
 			if (m_Data == NULL)
 				return 0;
 
 			if (getIPv4OptionType() == (uint8_t)IPV4OPT_EndOfOptionsList || m_Data->recordType == (uint8_t)IPV4OPT_NOP)
 				return (size_t)0;
 
 			return (size_t)m_Data->recordLen - (2*sizeof(uint8_t));
 		}
 	};
 
 
 	/**
 	 * @class IPv4OptionBuilder
 	 * A class for building IPv4 option records. This builder receives the IPv4 option parameters in its c'tor,
 	 * builds the IPv4 option raw buffer and provides a build() method to get a IPv4Option object out of it
 	 */
 	class IPv4OptionBuilder : public TLVRecordBuilder
 	{
 	private:
 		bool m_BuilderParamsValid;
 
 	public:
 		
 		/**
 		 * A c'tor for building IPv4 options which their value is a byte array. The IPv4Option object can be later
 		 * retrieved by calling build()
 		 * @param[in] optionType IPv4 option type
 		 * @param[in] optionValue A buffer containing the option value. This buffer is read-only and isn't modified in any way.
 		 * For option types ::IPV4OPT_NOP and ::IPV4OPT_EndOfOptionsList this parameter is ignored (expected to be NULL) as these
 		 * option types don't contain any data
 		 * @param[in] optionValueLen Option value length in bytes
 		 */
 		IPv4OptionBuilder(IPv4OptionTypes optionType, const uint8_t* optionValue, uint8_t optionValueLen) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue, optionValueLen) { m_BuilderParamsValid = true; }
 
 		/**
 		 * A c'tor for building IPv4 options which have a 2-byte value. The IPv4Option object can be later retrieved
 		 * by calling build()
 		 * @param[in] optionType IPv4 option type
 		 * @param[in] optionValue A 2-byte option value
 		 */
 		IPv4OptionBuilder(IPv4OptionTypes optionType, uint16_t optionValue) :
 			TLVRecordBuilder((uint8_t)optionType, optionValue) { m_BuilderParamsValid = true; }
 
 		/**
 		 * A c'tor for building IPv4 options which their value is a list of IPv4 addresses, for example: 
 		 * ::IPV4OPT_RecordRoute, ::IPV4OPT_StrictSourceRoute, ::IPV4OPT_LooseSourceRoute. The IPv4Option object can be later retrieved
 		 * by calling build()
 		 * @param[in] optionType IPv4 option type
 		 * @param[in] ipList A vector of IPv4 addresses that will be used as the option value
 		 */
 		IPv4OptionBuilder(IPv4OptionTypes optionType, const std::vector<IPv4Address>& ipList);
 
 		/**
 		 * A c'tor for building IPv4 timestamp option (::IPV4OPT_Timestamp). The IPv4Option object can be later retrieved by calling build()
 		 * @param[in] timestampValue The timestamp value to build the IPv4 option with
 		 */
 		IPv4OptionBuilder(const IPv4TimestampOptionValue& timestampValue);
 
 		/**
 		 * Build the IPv4Option object out of the parameters defined in the c'tor
 		 * @return The IPv4Option object
 		 */
 		IPv4Option build() const;
 	};
 
 
 	/**
 	 * @class IPv4Layer
 	 * Represents an IPv4 protocol layer
 	 */
 	class IPv4Layer : public Layer
 	{
 	public:
 		/**
 		 * A constructor that creates the layer from an existing packet raw data
 		 * @param[in] data A pointer to the raw data (will be casted to @ref iphdr)
 		 * @param[in] dataLen Size of the data in bytes
 		 * @param[in] prevLayer A pointer to the previous layer
 		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
 		 */
 		IPv4Layer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet);
 
 		/**
 		 * A constructor that creates the layer from an existing packet raw data
 		 * @param[in] data A pointer to the raw data (will be casted to @ref iphdr)
 		 * @param[in] dataLen Size of the data in bytes
 		 * @param[in] prevLayer A pointer to the previous layer
 		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
 		 * @param[in] setTotalLenAsDataLen When setting this value to "true" or when using the other c'tor, the layer data length is calculated
 		 * from iphdr#totalLength field. When setting to "false" the data length is set as the value of dataLen parameter. Please notice that
 		 * if iphdr#totalLength is equal to zero (which can happen in TCP Segmentation Offloading), this flag is ignored and the layer data
 		 * length is calculated by the actual data captured on the wire
 		 */
 		IPv4Layer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet, bool setTotalLenAsDataLen);
 
 
 		/**
 		 * A constructor that allocates a new IPv4 header with empty fields
 		 */
 		IPv4Layer();
 
 		/**
 		 * A constructor that allocates a new IPv4 header with source and destination IPv4 addresses
 		 * @param[in] srcIP Source IPv4 address
 		 * @param[in] dstIP Destination IPv4 address
 		 */
 		IPv4Layer(const IPv4Address& srcIP, const IPv4Address& dstIP);
 
 		/**
 		 * A copy constructor that copy the entire header from the other IPv4Layer (including IPv4 options)
 		 */
 		IPv4Layer(const IPv4Layer& other);
 
 		/**
 		 * An assignment operator that first delete all data from current layer and then copy the entire header from the other IPv4Layer (including IPv4 options)
 		 */
 		IPv4Layer& operator=(const IPv4Layer& other);
 
 		/**
 		 * Get a pointer to the IPv4 header. Notice this points directly to the data, so every change will change the actual packet data
 		 * @return A pointer to the @ref iphdr
 		 */
 		iphdr* getIPv4Header() const { return (iphdr*)m_Data; }
 
 		/**
 		 * Get the source IP address in the form of IPv4Address
 		 * @return An IPv4Address containing the source address
 		 */
 		IPv4Address getSrcIpAddress() const { return getIPv4Header()->ipSrc; }
 
 		/**
 		 * Set the source IP address
 		 * @param[in] ipAddr The IP address to set
 		 */
 		void setSrcIpAddress(const IPv4Address& ipAddr) { getIPv4Header()->ipSrc = ipAddr.toInt(); }
 
 		/**
 		 * Get the destination IP address in the form of IPv4Address
 		 * @return An IPv4Address containing the destination address
 		 */
 		IPv4Address getDstIpAddress() const { return getIPv4Header()->ipDst; }
 
 		/**
 		 * Set the dest IP address
 		 * @param[in] ipAddr The IP address to set
 		 */
 		void setDstIpAddress(const IPv4Address& ipAddr) { getIPv4Header()->ipDst = ipAddr.toInt(); }
 
 		/**
 		 * @return True if this packet is a fragment (in sense of IP fragmentation), false otherwise
 		 */
 		bool isFragment() const;
 
 		/**
 		 * @return True if this packet is a fragment (in sense of IP fragmentation) and is the first fragment
 		 * (which usually contains the L4 header). Return false otherwise (not a fragment or not the first fragment)
 		 */
 		bool isFirstFragment() const;
 
 		/**
 		 * @return True if this packet is a fragment (in sense of IP fragmentation) and is the last fragment.
 		 * Return false otherwise (not a fragment or not the last fragment)
 		 */
 		bool isLastFragment() const;
 
 		/**
 		 * @return A bitmask containing the fragmentation flags (e.g IP_DONT_FRAGMENT or IP_MORE_FRAGMENTS)
 		 */
 		uint8_t getFragmentFlags() const;
 
 		/**
 		 * @return The fragment offset in case this packet is a fragment, 0 otherwise
 		 */
 		uint16_t getFragmentOffset() const;
 
 		/**
 		 * Get an IPv4 option by type.
 		 * @param[in] option IPv4 option type
 		 * @return An IPv4Option object that contains the first option that matches this type, or logical NULL
 		 * (IPv4Option#isNull() == true) if no such option found
 		 */
 		IPv4Option getOption(IPv4OptionTypes option) const;
 
 		/**
 		 * @return The first IPv4 option in the packet. If the current layer contains no options the returned value will contain
 		 * a logical NULL (IPv4Option#isNull() == true)
 		 */
 		IPv4Option getFirstOption() const;
 
 		/**
 		 * Get the IPv4 option that comes after a given option. If the given option was the last one, the
 		 * returned value will contain a logical NULL (IPv4Option#isNull() == true)
 		 * @param[in] option An IPv4 option object that exists in the current layer
 		 * @return A IPv4Option object that contains the IPv4 option data that comes next, or logical NULL if the given
 		 * IPv4 option: (1) was the last one; or (2) contains a logical NULL; or (3) doesn't belong to this packet
 		 */
 		IPv4Option getNextOption(IPv4Option& option) const;
 
 		/**
 		 * @return The number of IPv4 options in this layer
 		 */
 		size_t getOptionCount() const;
 
 		/**
 		 * Add a new IPv4 option at the end of the layer (after the last IPv4 option)
 		 * @param[in] optionBuilder An IPv4OptionBuilder object that contains the IPv4 option data to be added
 		 * @return A IPv4Option object that contains the newly added IPv4 option data or logical NULL
 		 * (IPv4Option#isNull() == true) if addition failed. In case of a failure a corresponding error message will be
 		 * printed to log
 		 */
 		IPv4Option addOption(const IPv4OptionBuilder& optionBuilder);
 
 		/**
 		 * Add a new IPv4 option after an existing one
 		 * @param[in] optionBuilder An IPv4OptionBuilder object that contains the requested IPv4 option data to be added
 		 * @param[in] prevOptionType The IPv4 option which the newly added option should come after. This is an optional parameter which
 		 * gets a default value of ::IPV4OPT_Unknown if omitted, which means the new option will be added as the first option in the layer
 		 * @return A IPv4Option object containing the newly added IPv4 option data or logical NULL
 		 * (IPv4Option#isNull() == true) if addition failed. In case of a failure a corresponding error message will be
 		 * printed to log
 		 */
 		IPv4Option addOptionAfter(const IPv4OptionBuilder& optionBuilder, IPv4OptionTypes prevOptionType = IPV4OPT_Unknown);
 
 		/**
 		 * Remove an IPv4 option
 		 * @param[in] option The option type to remove
 		 * @return True if option was removed successfully or false if option type wasn't found or failed to shorten the layer. If an option appears twice in the layer, its first instance
 		 * will be removed
 		 */
 		bool removeOption(IPv4OptionTypes option);
 
 		/**
 		 * Remove all IPv4 options from the layer
 		 * @return True if options removed successfully or false if some error occurred (an appropriate error message will be printed to log)
 		 */
 		bool removeAllOptions();
 
 
 		// implement abstract methods
 
 		/**
 		 * Currently identifies the following next layers: UdpLayer, TcpLayer. Otherwise sets PayloadLayer
 		 */
 		void parseNextLayer();
 
 		/**
 		 * @return Size of IPv4 header (including IPv4 options if exist)
 		 */
 		size_t getHeaderLen() const { return (size_t)((uint16_t)(getIPv4Header()->internetHeaderLength) * 4) + m_TempHeaderExtension; }
 
 		/**
 		 * Calculate the following fields:
 		 * - iphdr#ipVersion = 4;
 		 * - iphdr#totalLength = total packet length
 		 * - iphdr#headerChecksum = calculated
 		 * - iphdr#protocol = calculated if next layer is known: ::PACKETPP_IPPROTO_TCP for TCP, ::PACKETPP_IPPROTO_UDP for UDP, ::PACKETPP_IPPROTO_ICMP for ICMP
 		 */
 		void computeCalculateFields();
 
 		std::string toString() const;
 
 		OsiModelLayer getOsiModelLayer() const { return OsiModelNetworkLayer; }
 
 		/**
-		 * The static method makes validation of input data
-		 * @param[in] data The pointer to the beginning of byte stream of IP packet
-		 * @param[in] dataLen The length of byte stream
-		 * @return True if the data is valid and can represent the IPv4 packet
+		 * A static method that validates the input data
+		 * @param[in] data The pointer to the beginning of a byte stream of IP packet
+		 * @param[in] dataLen The length of the byte stream
+		 * @return True if the data is valid and can represent an IPv4 packet
 		 */
 		static inline bool isDataValid(const uint8_t* data, size_t dataLen);
 
 	private:
 		int m_NumOfTrailingBytes;
 		int m_TempHeaderExtension;
 		TLVRecordReader<IPv4Option> m_OptionReader;
 
 		void copyLayerData(const IPv4Layer& other);
 		uint8_t* getOptionsBasePtr() const { return m_Data + sizeof(iphdr); }
 		IPv4Option addOptionAt(const IPv4OptionBuilder& optionBuilder, int offset);
 		void adjustOptionsTrailer(size_t totalOptSize);
 		void initLayer();
 		void initLayerInPacket(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet, bool setTotalLenAsDataLen);
 	};
 
 
 	// implementation of inline methods
 
 	bool IPv4Layer::isDataValid(const uint8_t* data, size_t dataLen)
 	{
 		const iphdr* hdr = reinterpret_cast<const iphdr*>(data);
 		return dataLen >= sizeof(iphdr) && hdr->ipVersion == 4 && hdr->internetHeaderLength >= 5;
 	}
 
 } // namespace pcpp
 
 #endif /* PACKETPP_IPV4_LAYER */
diff --git a/Packet++/header/PPPoELayer.h b/Packet++/header/PPPoELayer.h
index 59e4132e..ebc79493 100644
--- a/Packet++/header/PPPoELayer.h
+++ b/Packet++/header/PPPoELayer.h
@@ -10,647 +10,675 @@
 /**
  * \namespace pcpp
  * \brief The main namespace for the PcapPlusPlus lib
  */
 namespace pcpp
 {
 
 	/**
 	 * @struct pppoe_header
 	 * Represents an PPPoE protocol header
 	 */
 #pragma pack(push, 1)
 	struct pppoe_header {
 #if (BYTE_ORDER == LITTLE_ENDIAN)
 		/** PPPoE version */
 		uint8_t version:4,
 		/** PPPoE type */
 		type:4;
 		/** PPPoE code */
 		uint8_t code;
 #else
 		/** PPPoE version */
 		uint16_t version:4,
 		/** PPPoE type */
 		type:4,
 		/** PPPoE code */
 		code:8;
 #endif
 		/** PPPoE session ID (relevant for PPPoE session packets only) */
 		uint16_t sessionId;
 		/** Length (in bytes) of payload, not including the PPPoE header */
 		uint16_t payloadLength;
 	};
 #pragma pack(pop)
 
 
 	/**
 	 * @class PPPoELayer
 	 * An abstract class that describes the PPPoE protocol. Contains common data and logic of the two types of PPPoE packets: PPPoE session
 	 * and PPPoE discovery
 	 */
 	class PPPoELayer : public Layer
 	{
 	public:
 		/**
 		 * PPPoE possible codes
 		 */
 		enum PPPoECode
 		{
 			/** PPPoE session code */
 			PPPOE_CODE_SESSION	= 0x00,
 			/** PPPoE discovery PADO */
 			PPPOE_CODE_PADO		= 0x07,
 			/** PPPoE discovery PADI */
 			PPPOE_CODE_PADI		= 0x09,
 			/** PPPoE discovery PADG */
 			PPPOE_CODE_PADG		= 0x0a,
 			/** PPPoE discovery PADC */
 			PPPOE_CODE_PADC		= 0x0b,
 			/** PPPoE discovery PADQ */
 			PPPOE_CODE_PADQ		= 0x0c,
 			/** PPPoE discovery PADR */
 			PPPOE_CODE_PADR		= 0x19,
 			/** PPPoE discovery PADS */
 			PPPOE_CODE_PADS		= 0x65,
 			/** PPPoE discovery PADT */
 			PPPOE_CODE_PADT		= 0xa7,
 			/** PPPoE discovery PADM */
 			PPPOE_CODE_PADM		= 0xd3,
 			/** PPPoE discovery PADN */
 			PPPOE_CODE_PADN		= 0xd4
 		};
 
 		~PPPoELayer() {}
 
 		/**
 		 * Get a pointer to the PPPoE header. Notice this points directly to the data, so every change will change the actual packet data
 		 * @return A pointer to the pppoe_header
 		 */
 		pppoe_header* getPPPoEHeader() const { return (pppoe_header*)m_Data; }
 
 		// abstract methods implementation
 
 		/**
 		 * Calculate @ref pppoe_header#payloadLength field
 		 */
 		virtual void computeCalculateFields();
 
 		OsiModelLayer getOsiModelLayer() const { return OsiModelDataLinkLayer; }
 
 	protected:
 
 		// protected c'tor as this class shouldn't be instantiated
 		PPPoELayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet) : Layer(data, dataLen, prevLayer, packet) { }
 
 		// protected c'tor as this class shouldn't be instantiated
 		PPPoELayer(uint8_t version, uint8_t type, PPPoELayer::PPPoECode code, uint16_t sessionId, size_t additionalBytesToAllocate = 0);
 
 	};
 
 
 	/**
 	 * @class PPPoESessionLayer
 	 * Describes the PPPoE session protocol
 	 */
 	class PPPoESessionLayer : public PPPoELayer
 	{
 	public:
 
 		/**
 		 * A constructor that creates the layer from an existing packet raw data
 		 * @param[in] data A pointer to the raw data (will be casted to @ref pppoe_header)
 		 * @param[in] dataLen Size of the data in bytes
 		 * @param[in] prevLayer A pointer to the previous layer
 		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
 		 */
 		PPPoESessionLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet) : PPPoELayer(data, dataLen, prevLayer, packet) { m_Protocol = PPPoESession; }
 
 		/**
 		 * A constructor that allocates a new PPPoE Session header with version, type and session ID
 		 * @param[in] version PPPoE version
 		 * @param[in] type PPPoE type
 		 * @param[in] sessionId PPPoE session ID
 		 * @param[in] pppNextProtocol The next protocol to come after the PPPoE session header. Should be one of the PPP_* macros listed below
 		 */
 		PPPoESessionLayer(uint8_t version, uint8_t type, uint16_t sessionId, uint16_t pppNextProtocol) : PPPoELayer(version, type, PPPoELayer::PPPOE_CODE_SESSION, sessionId, sizeof(uint16_t)) { setPPPNextProtocol(pppNextProtocol); }
 
 		virtual ~PPPoESessionLayer() {}
 
 		/**
 		 * @return The protocol after the PPPoE session header. The return value is one of the PPP_* macros listed below. This method is also
 		 * used when parsing a packet (this way we know which layer comes after the PPPoE session)
 		 */
 		uint16_t getPPPNextProtocol() const;
 
 		/**
 		 * Set the field that describes which header comes after the PPPoE session header
 		 * @param[in] nextProtocol The protocol value. Should be one of the PPP_* macros listed below
 		 */
 		void setPPPNextProtocol(uint16_t nextProtocol);
 
+		/**
+		 * A static method that validates the input data
+		 * @param[in] data The pointer to the beginning of byte stream of a packet
+		 * @param[in] dataLen The length of the byte stream
+		 * @return True if the data is valid and can represent a PPPoES packet
+		 */
+		static inline bool isDataValid(const uint8_t* data, size_t dataLen);
+
 		// abstract methods implementation
 
 		/**
 		 * Currently identifies the following next layers: IPv4Layer, IPv6Layer. Otherwise sets PayloadLayer
 		 */
 		virtual void parseNextLayer();
 
 		/**
 		 * @return Size of @ref pppoe_header
 		 */
 		virtual size_t getHeaderLen() const { return sizeof(pppoe_header) + sizeof(uint16_t); }
 
 		virtual std::string toString() const;
 	};
 
 
 
 	/**
 	 * @class PPPoEDiscoveryLayer
 	 * Describes the PPPoE discovery protocol
 	 */
 	class PPPoEDiscoveryLayer : public PPPoELayer
 	{
 	public:
 		/**
 		 * PPPoE tag types
 		 */
 		enum PPPoETagTypes
 		{
 			/** End-Of-List tag type*/
 			PPPOE_TAG_EOL		 = 0x0000,
 			/** Service-Name tag type*/
 			PPPOE_TAG_SVC_NAME	 = 0x0101,
 			/** AC-Name tag type*/
 			PPPOE_TAG_AC_NAME	 = 0x0102,
 			/** Host-Uniq tag type*/
 			PPPOE_TAG_HOST_UNIQ	 = 0x0103,
 			/** AC-Cookie tag type*/
 			PPPOE_TAG_AC_COOKIE	 = 0x0104,
 			/** Vendor-Specific tag type*/
 			PPPOE_TAG_VENDOR	 = 0x0105,
 			/** Credits tag type*/
 			PPPOE_TAG_CREDITS	 = 0x0106,
 			/** Metrics tag type*/
 			PPPOE_TAG_METRICS	 = 0x0107,
 			/** Sequence Number tag type */
 			PPPOE_TAG_SEQ_NUM	 = 0x0108,
 			/** Credit Scale Factor tag type */
 			PPPOE_TAG_CRED_SCALE = 0x0109,
 			/** Relay-Session-Id tag type */
 			PPPOE_TAG_RELAY_ID	 = 0x0110,
 			/** HURL tag type */
 			PPPOE_TAG_HURL		 = 0x0111,
 			/** MOTM tag type */
 			PPPOE_TAG_MOTM		 = 0x0112,
 			/** PPP-Max-Payload tag type */
 			PPPOE_TAG_MAX_PAYLD	 = 0x0120,
 			/** IP_Route_Add tag type */
 			PPPOE_TAG_IP_RT_ADD	 = 0x0121,
 			/** Service-Name-Error tag type */
 			PPPOE_TAG_SVC_ERR	 = 0x0201,
 			/** AC-System-Error tag type */
 			PPPOE_TAG_AC_ERR	 = 0x0202,
 			/** Generic-Error tag type */
 			PPPOE_TAG_GENERIC_ERR= 0x0203
 		};
 
 		/**
 		 * @struct PPPoETag
 		 * Represents a PPPoE tag and its data
 		 */
 		struct PPPoETag
 		{
 		public:
 
 			/** The type of the data, can be converted to PPPoEDiscoveryLayer#PPPoETagTypes enum (or use getType()) */
 			uint16_t tagType;
 			/** The length of the tag data */
 			uint16_t tagDataLength;
 			/** A pointer to the tag data. It's recommended to use getTagDataAs() to retrieve the tag data or setTagData() to set tag data */
 			uint8_t	 tagData[];
 
 			/**
 			 * A templated method to retrieve the tag data as a certain type T. For example, if tag data is 4B (integer) then this method
 			 * should be used as getTagDataAs<int>() and it will return the tag data as integer.<BR>
 			 * Notice this return value is a copy of the data, not a pointer to the actual data
 			 * @param[in] tagDataOffset An optional parameter that specifies where to start copy the tag data. For example: if tag data is 20 bytes
 			 * and you need only the 4 last bytes as integer then use this method like this: getTagDataAs<int>(16). The default is 0 - start copy
 			 * from the beginning of tag data
 			 * @return The tag data as type T
 			 */
 			template<typename T>
 			T getTagDataAs(int tagDataOffset = 0) const
 			{
 				T result;
 				memcpy(&result, tagData + tagDataOffset, sizeof(T));
 				return result;
 			}
 
 			/**
 			 * A templated method to copy data of type T into the tag data. For example: if tag data is 4[Bytes] long use this method like
 			 * this to set an integer "num" into tag data: setTagData<int>(num)
 			 * @param[in] value The value of type T to copy to tag data
 			 * @param[in] tagDataOffset An optional parameter that specifies where to start set the tag data. For example: if tag data is 20 bytes
 			 * and you only need to set the 4 last bytes as integer then use this method like this: setTagDataAs<int>(num, 16).
 			 * The default is 0 - start copy to the beginning of tag data
 			 */
 			template<typename T>
 			void setTagData(T value, int tagDataOffset = 0)
 			{
 				memcpy(tagData+tagDataOffset, &value, sizeof(T));
 			}
 
 			/**
 			 * @return The total size in bytes of this tag which includes: 2[Bytes] (tag name) + 2[Bytes] (tag length) + X[Bytes] (tag data length)
 			 */
 			size_t getTagTotalSize() const;
 
 			/**
 			 * @return The tag type converted to PPPoEDiscoveryLayer#PPPoETagTypes enum
 			 */
 			PPPoEDiscoveryLayer::PPPoETagTypes getType() const;
 		private:
 			// private c'tor which isn't implemented to make this struct impossible to construct
 			PPPoETag();
 		};
 
 		/**
 		 * A constructor that creates the layer from an existing packet raw data
 		 * @param[in] data A pointer to the raw data (will be casted to @ref pppoe_header)
 		 * @param[in] dataLen Size of the data in bytes
 		 * @param[in] prevLayer A pointer to the previous layer
 		 * @param[in] packet A pointer to the Packet instance where layer will be stored in
 		 */
 		PPPoEDiscoveryLayer(uint8_t* data, size_t dataLen, Layer* prevLayer, Packet* packet) : PPPoELayer(data, dataLen, prevLayer, packet) { m_Protocol = PPPoEDiscovery; m_TagCount = -1; m_DataLen = getHeaderLen(); }
 
 		/**
 		 * A constructor that allocates a new PPPoE Discovery header with version, type, PPPoE code and session ID
 		 * @param[in] version PPPoE version
 		 * @param[in] type PPPoE type
 		 * @param[in] code PPPoE code enum
 		 * @param[in] sessionId PPPoE session ID
 		 */
 		PPPoEDiscoveryLayer(uint8_t version, uint8_t type, PPPoELayer::PPPoECode code, uint16_t sessionId) : PPPoELayer(version, type, code, sessionId) { m_Protocol = PPPoEDiscovery; m_TagCount = -1; }
 
 		/**
 		 * Retrieve a PPPoE tag by tag type. If packet consists of multiple tags of the same type, the first tag will be returned. If packet contains
 		 * no tags of the tag type NULL will be returned. Notice the return value is a pointer to the real data casted to PPPoETag type (as opposed
 		 * to a copy of the tag data). So changes in the return value will affect the packet data
 		 * @param[in] tagType The type of the tag to search
 		 * @return A pointer to the tag data casted to PPPoETag*
 		 */
 		PPPoETag* getTag(PPPoEDiscoveryLayer::PPPoETagTypes tagType) const;
 
 		/**
 		 * @return The first tag in the PPPoE discovery layer, or NULL if no tags exist. Notice the return value is a pointer to the real data casted to PPPoETag type (as opposed
 		 * to a copy of the tag data). So changes in the return value will affect the packet data
 		 */
 		PPPoETag* getFirstTag() const;
 
 		/**
 		 * Get the tag which come next to "tag" parameter. If "tag" is NULL or then NULL will be returned. If "tag" is the last tag NULL will be
 		 * returned. Notice the return value is a pointer to the real data casted to PPPoETag type (as opposed to a copy of the tag data).
 		 * So changes in the return value will affect the packet data
 		 * @param[in] tag The tag to start search
 		 * @return The next tag or NULL if "tag" is NULL or "tag" is the last tag
 		 */
 		PPPoETag* getNextTag(PPPoETag* tag) const;
 
 		/**
 		 * @return The number of tags in this layer
 		 */
 		int getTagCount() const;
 
 		/**
 		 * Add a new tag at the end of the layer (after the last tag)
 		 * @param[in] tagType The type of the added tag
 		 * @param[in] tagLength The length of the tag data
 		 * @param[in] tagData A pointer to the tag data. This data will be copied to added tag data. Notice the length of tagData must be tagLength
 		 * @return A pointer to the new added tag. Notice this is a pointer to the real data casted to PPPoETag type (as opposed to a copy of
 		 * the tag data). So changes in this return value will affect the packet data
 		 */
 		PPPoETag* addTag(PPPoETagTypes tagType, uint16_t tagLength, const uint8_t* tagData);
 
 		/**
 		 * Add a new tag after an existing tag
 		 * @param[in] tagType The type of the added tag
 		 * @param[in] tagLength The length of the tag data
 		 * @param[in] tagData A pointer to the tag data. This data will be copied to added tag data. Notice the length of tagData must be tagLength
 		 * @param[in] prevTag The tag which the new added tag will come after
 		 * @return A pointer to the new added tag. Notice this is a pointer to the real data casted to PPPoETag type (as opposed to a copy of
 		 * the tag data). So changes in this return value will affect the packet data
 		 */
 		PPPoETag* addTagAfter(PPPoETagTypes tagType, uint16_t tagLength, const uint8_t* tagData, PPPoETag* prevTag);
 
 		/**
 		 * Remove an existing tag. Tag will be found by the tag type
 		 * @param[in] tagType The tag type to remove
 		 * @return True if tag was removed or false if tag wasn't found or if tag removal failed (in each case a proper error will be written
 		 * to log)
 		 */
 		bool removeTag(PPPoEDiscoveryLayer::PPPoETagTypes tagType);
 
 		/**
 		 * Remove all tags in this layer
 		 * @return True if all tags were successfully or false if removal failed for some reason (a proper error will be written to log)
 		 */
 		bool removeAllTags();
 
+		/**
+		 * A static method that validates the input data
+		 * @param[in] data The pointer to the beginning of byte stream of a packet
+		 * @param[in] dataLen The length of the byte stream
+		 * @return True if the data is valid and can represent a PPPoED packet
+		 */
+		static inline bool isDataValid(const uint8_t* data, size_t dataLen);
+
 		// abstract methods implementation
 
 		/**
 		 * Does nothing for this layer (PPPoE discovery is always the last layer)
 		 */
 		virtual void parseNextLayer() {}
 
 		/**
 		 * @return The header length which is size of strcut pppoe_header plus the total size of tags
 		 */
 		virtual size_t getHeaderLen() const;
 
 		virtual std::string toString() const { return "PPP-over-Ethernet Discovery (" + codeToString((PPPoELayer::PPPoECode)getPPPoEHeader()->code) + ")"; }
 
 	private:
 		mutable int m_TagCount;
 
 		PPPoETag* addTagAt(PPPoETagTypes tagType, uint16_t tagLength, const uint8_t* tagData, int offset);
 
 		PPPoETag* castPtrToPPPoETag(uint8_t* ptr) const;
 
 		std::string codeToString(PPPoECode code) const;
 	};
 
 
+	// implementation of inline methods
+
+	bool PPPoESessionLayer::isDataValid(const uint8_t* data, size_t dataLen)
+	{
+		return dataLen >= sizeof(pppoe_header) + sizeof(uint16_t);
+	}
+
+	bool PPPoEDiscoveryLayer::isDataValid(const uint8_t* data, size_t dataLen)
+	{
+		return dataLen >= sizeof(pppoe_header);
+	}
+
 	// Copied from Wireshark: ppptypes.h
 
 	/** Padding Protocol */
 #define PCPP_PPP_PADDING		0x1
 	/** ROHC small-CID */
 #define PCPP_PPP_ROHC_SCID		0x3
 	/** ROHC large-CID */
 #define PCPP_PPP_ROHC_LCID		0x5
 	/** Internet Protocol version 4 */
 #define PCPP_PPP_IP				0x21
 	/** OSI Network Layer */
 #define PCPP_PPP_OSI			0x23
 	/** Xerox NS IDP */
 #define PCPP_PPP_XNSIDP			0x25
 	/** DECnet Phase IV */
 #define PCPP_PPP_DEC4			0x27
 	/** AppleTalk */
 #define PCPP_PPP_AT				0x29
 	/** Novell IPX */
 #define PCPP_PPP_IPX			0x2b
 	/** Van Jacobson Compressed TCP/IP */
 #define PCPP_PPP_VJC_COMP		0x2d
 	/** Van Jacobson Uncompressed TCP/IP */
 #define PCPP_PPP_VJC_UNCOMP		0x2f
 	/** Bridging PDU */
 #define PCPP_PPP_BCP			0x31
 	/** Stream Protocol (ST-II) */
 #define PCPP_PPP_ST				0x33
 	/** Banyan Vines */
 #define PCPP_PPP_VINES			0x35
 	/** AppleTalk EDDP */
 #define PCPP_PPP_AT_EDDP		0x39
 	/** AppleTalk SmartBuffered */
 #define PCPP_PPP_AT_SB			0x3b
 	/** Multi-Link */
 #define PCPP_PPP_MP				0x3d
 	/** NETBIOS Framing */
 #define PCPP_PPP_NB				0x3f
 	/** Cisco Systems */
 #define PCPP_PPP_CISCO			0x41
 	/** Ascom Timeplex */
 #define PCPP_PPP_ASCOM			0x43
 	/** Fujitsu Link Backup and Load Balancing */
 #define PCPP_PPP_LBLB			0x45
 	/** DCA Remote Lan */
 #define PCPP_PPP_RL				0x47
 	/** Serial Data Transport Protocol */
 #define PCPP_PPP_SDTP			0x49
 	/** SNA over 802.2 */
 #define PCPP_PPP_LLC			0x4b
 	/** SNA */
 #define PCPP_PPP_SNA			0x4d
 	/** IPv6 Header Compression  */
 #define PCPP_PPP_IPV6HC			0x4f
 	/** KNX Bridging Data */
 #define PCPP_PPP_KNX			0x51
 	/** Encryption */
 #define PCPP_PPP_ENCRYPT		0x53
 	/** Individual Link Encryption */
 #define PCPP_PPP_ILE			0x55
 	/** Internet Protocol version 6 */
 #define PCPP_PPP_IPV6			0x57
 	/** PPP Muxing */
 #define PCPP_PPP_MUX			0x59
 	/** Vendor-Specific Network Protocol (VSNP) */
 #define PCPP_PPP_VSNP			0x5b
 	/** TRILL Network Protocol (TNP) */
 #define PCPP_PPP_TNP			0x5d
 	/** RTP IPHC Full Header */
 #define PCPP_PPP_RTP_FH			0x61
 	/** RTP IPHC Compressed TCP */
 #define PCPP_PPP_RTP_CTCP		0x63
 	/** RTP IPHC Compressed Non TCP */
 #define PCPP_PPP_RTP_CNTCP		0x65
 	/** RTP IPHC Compressed UDP 8 */
 #define PCPP_PPP_RTP_CUDP8		0x67
 	/** RTP IPHC Compressed RTP 8 */
 #define PCPP_PPP_RTP_CRTP8		0x69
 	/** Stampede Bridging */
 #define PCPP_PPP_STAMPEDE		0x6f
 	/** MP+ Protocol */
 #define PCPP_PPP_MPPLUS			0x73
 	/** NTCITS IPI */
 #define PCPP_PPP_NTCITS_IPI		0xc1
 	/** Single link compression in multilink */
 #define PCPP_PPP_ML_SLCOMP		0xfb
 	/** Compressed datagram */
 #define PCPP_PPP_COMP			0xfd
 	/** 802.1d Hello Packets */
 #define PCPP_PPP_STP_HELLO		0x0201
 	/** IBM Source Routing BPDU */
 #define PCPP_PPP_IBM_SR			0x0203
 	/** DEC LANBridge100 Spanning Tree */
 #define PCPP_PPP_DEC_LB			0x0205
 	/** Cisco Discovery Protocol */
 #define PCPP_PPP_CDP			0x0207
 	/** Netcs Twin Routing */
 #define PCPP_PPP_NETCS			0x0209
 	/** STP - Scheduled Transfer Protocol */
 #define PCPP_PPP_STP			0x020b
 	/** EDP - Extreme Discovery Protocol */
 #define PCPP_PPP_EDP			0x020d
 	/** Optical Supervisory Channel Protocol */
 #define PCPP_PPP_OSCP			0x0211
 	/** Optical Supervisory Channel Protocol */
 #define PCPP_PPP_OSCP2			0x0213
 	/** Luxcom */
 #define PCPP_PPP_LUXCOM			0x0231
 	/** Sigma Network Systems */
 #define PCPP_PPP_SIGMA			0x0233
 	/** Apple Client Server Protocol */
 #define PCPP_PPP_ACSP			0x0235
 	/** MPLS Unicast */
 #define PCPP_PPP_MPLS_UNI		0x0281
 	/** MPLS Multicast */
 #define PCPP_PPP_MPLS_MULTI		0x0283
 	/** IEEE p1284.4 standard - data packets */
 #define PCPP_PPP_P12844			0x0285
 	/** ETSI TETRA Network Procotol Type 1 */
 #define PCPP_PPP_TETRA			0x0287
 	/** Multichannel Flow Treatment Protocol */
 #define PCPP_PPP_MFTP			0x0289
 	/** RTP IPHC Compressed TCP No Delta */
 #define PCPP_PPP_RTP_CTCPND		0x2063
 	/** RTP IPHC Context State */
 #define PCPP_PPP_RTP_CS			0x2065
 	/** RTP IPHC Compressed UDP 16 */
 #define PCPP_PPP_RTP_CUDP16		0x2067
 	/** RTP IPHC Compressed RTP 16 */
 #define PCPP_PPP_RTP_CRDP16		0x2069
 	/** Cray Communications Control Protocol */
 #define PCPP_PPP_CCCP			0x4001
 	/** CDPD Mobile Network Registration Protocol */
 #define PCPP_PPP_CDPD_MNRP		0x4003
 	/** Expand accelerator protocol */
 #define PCPP_PPP_EXPANDAP		0x4005
 	/** ODSICP NCP */
 #define PCPP_PPP_ODSICP			0x4007
 	/** DOCSIS DLL */
 #define PCPP_PPP_DOCSIS			0x4009
 	/** Cetacean Network Detection Protocol */
 #define PCPP_PPP_CETACEANNDP	0x400b
 	/** Stacker LZS */
 #define PCPP_PPP_LZS			0x4021
 	/** RefTek Protocol */
 #define PCPP_PPP_REFTEK			0x4023
 	/** Fibre Channel */
 #define PCPP_PPP_FC				0x4025
 	/** EMIT Protocols */
 #define PCPP_PPP_EMIT			0x4027
 	/** Vendor-Specific Protocol (VSP) */
 #define PCPP_PPP_VSP			0x405b
 	/** TRILL Link State Protocol (TLSP) */
 #define PCPP_PPP_TLSP			0x405d
 	/** Internet Protocol Control Protocol */
 #define PCPP_PPP_IPCP			0x8021
 	/** OSI Network Layer Control Protocol */
 #define PCPP_PPP_OSINLCP		0x8023
 	/** Xerox NS IDP Control Protocol */
 #define PCPP_PPP_XNSIDPCP		0x8025
 	/** DECnet Phase IV Control Protocol */
 #define PCPP_PPP_DECNETCP		0x8027
 	/** AppleTalk Control Protocol */
 #define PCPP_PPP_ATCP			0x8029
 	/** Novell IPX Control Protocol */
 #define PCPP_PPP_IPXCP			0x802b
 	/** Bridging NCP */
 #define PCPP_PPP_BRIDGENCP		0x8031
 	/** Stream Protocol Control Protocol */
 #define PCPP_PPP_SPCP			0x8033
 	/** Banyan Vines Control Protocol */
 #define PCPP_PPP_BVCP			0x8035
 	/** Multi-Link Control Protocol */
 #define PCPP_PPP_MLCP			0x803d
 	/** NETBIOS Framing Control Protocol */
 #define PCPP_PPP_NBCP			0x803f
 	/** Cisco Systems Control Protocol */
 #define PCPP_PPP_CISCOCP		0x8041
 	/** Ascom Timeplex Control Protocol (?) */
 #define PCPP_PPP_ASCOMCP		0x8043
 	/** Fujitsu LBLB Control Protocol */
 #define PCPP_PPP_LBLBCP			0x8045
 	/** DCA Remote Lan Network Control Protocol */
 #define PCPP_PPP_RLNCP			0x8047
 	/** Serial Data Control Protocol */
 #define PCPP_PPP_SDCP			0x8049
 	/** SNA over 802.2 Control Protocol */
 #define PCPP_PPP_LLCCP			0x804b
 	/** SNA Control Protocol */
 #define PCPP_PPP_SNACP			0x804d
 	/** IP6 Header Compression Control Protocol */
 #define PCPP_PPP_IP6HCCP		0x804f
 	/** KNX Bridging Control Protocol */
 #define PCPP_PPP_KNXCP			0x8051
 	/** Encryption Control Protocol */
 #define PCPP_PPP_ECP			0x8053
 	/** Individual Link Encryption Control Protocol */
 #define PCPP_PPP_ILECP			0x8055
 	/** IPv6 Control Protocol */
 #define PCPP_PPP_IPV6CP			0x8057
 	/** PPP Muxing Control Protocol */
 #define PCPP_PPP_MUXCP			0x8059
 	/** Vendor-Specific Network Control Protocol (VSNCP)   [RFC3772] */
 #define PCPP_PPP_VSNCP			0x805b
 	/** TRILL Network Control Protocol (TNCP) */
 #define PCPP_PPP_TNCP			0x805d
 	/** Stampede Bridging Control Protocol */
 #define PCPP_PPP_STAMPEDECP		0x806f
 	/** MP+ Contorol Protocol */
 #define PCPP_PPP_MPPCP			0x8073
 	/** NTCITS IPI Control Protocol */
 #define PCPP_PPP_IPICP			0x80c1
 	/** Single link compression in multilink control */
 #define PCPP_PPP_SLCC			0x80fb
 	/** Compression Control Protocol */
 #define PCPP_PPP_CCP			0x80fd
 	/** Cisco Discovery Protocol Control Protocol */
 #define PCPP_PPP_CDPCP			0x8207
 	/** Netcs Twin Routing */
 #define PCPP_PPP_NETCSCP		0x8209
 	/** STP - Control Protocol */
 #define PCPP_PPP_STPCP			0x820b
 	/** EDPCP - Extreme Discovery Protocol Control Protocol */
 #define PCPP_PPP_EDPCP			0x820d
 	/** Apple Client Server Protocol Control */
 #define PCPP_PPP_ACSPC			0x8235
 	/** MPLS Control Protocol */
 #define PCPP_PPP_MPLSCP			0x8281
 	/** IEEE p1284.4 standard - Protocol Control */
 #define PCPP_PPP_P12844CP		0x8285
 	/** ETSI TETRA TNP1 Control Protocol */
 #define PCPP_PPP_TETRACP		0x8287
 	/** Multichannel Flow Treatment Protocol */
 #define PCPP_PPP_MFTPCP			0x8289
 	/** Link Control Protocol */
 #define PCPP_PPP_LCP			0xc021
 	/** Password Authentication Protocol */
 #define PCPP_PPP_PAP			0xc023
 	/** Link Quality Report */
 #define PCPP_PPP_LQR			0xc025
 	/** Shiva Password Authentication Protocol */
 #define PCPP_PPP_SPAP			0xc027
 	/** CallBack Control Protocol (CBCP) */
 #define PCPP_PPP_CBCP			0xc029
 	/** BACP Bandwidth Allocation Control Protocol */
 #define PCPP_PPP_BACP			0xc02b
 	/** BAP Bandwidth Allocation Protocol */
 #define PCPP_PPP_BAP			0xc02d
 	/** Vendor-Specific Authentication Protocol (VSAP) */
 #define PCPP_PPP_VSAP			0xc05b
 	/** Container Control Protocol */
 #define PCPP_PPP_CONTCP			0xc081
 	/** Challenge Handshake Authentication Protocol */
 #define PCPP_PPP_CHAP			0xc223
 	/** RSA Authentication Protocol */
 #define PCPP_PPP_RSAAP			0xc225
 	/** Extensible Authentication Protocol */
 #define PCPP_PPP_EAP			0xc227
 	/** Mitsubishi Security Information Exchange Protocol (SIEP) */
 #define PCPP_PPP_SIEP			0xc229
 	/** Stampede Bridging Authorization Protocol */
 #define PCPP_PPP_SBAP			0xc26f
 	/** Proprietary Authentication Protocol */
 #define PCPP_PPP_PRPAP			0xc281
 	/** Proprietary Authentication Protocol */
 #define PCPP_PPP_PRPAP2			0xc283
 	/** Proprietary Node ID Authentication Protocol */
 #define PCPP_PPP_PRPNIAP		0xc481
 
 } // namespace pcpp
 
 #endif /* PACKETPP_PPPOE_LAYER */
diff --git a/Packet++/src/EthLayer.cpp b/Packet++/src/EthLayer.cpp
index 0e077fd7..e18995c2 100644
--- a/Packet++/src/EthLayer.cpp
+++ b/Packet++/src/EthLayer.cpp
@@ -32,40 +32,44 @@ EthLayer::EthLayer(const MacAddress& sourceMac, const MacAddress& destMac, uint1
 void EthLayer::parseNextLayer()
 {
 	if (m_DataLen <= sizeof(ether_header))
 		return;
 
 	ether_header* hdr = getEthHeader();
 	uint8_t* payload = m_Data + sizeof(ether_header);
 	size_t payloadLen = m_DataLen - sizeof(ether_header);
 
 	switch (be16toh(hdr->etherType))
 	{
 	case PCPP_ETHERTYPE_IP:
 		m_NextLayer = IPv4Layer::isDataValid(payload, payloadLen)
 			? static_cast<Layer*>(new IPv4Layer(payload, payloadLen, this, m_Packet))
 			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_IPV6:
 		m_NextLayer = IPv6Layer::isDataValid(payload, payloadLen)
 			? static_cast<Layer*>(new IPv6Layer(payload, payloadLen, this, m_Packet))
 			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_ARP:
 		m_NextLayer = new ArpLayer(payload, payloadLen, this, m_Packet);
 		break;
 	case PCPP_ETHERTYPE_VLAN:
 		m_NextLayer = new VlanLayer(payload, payloadLen, this, m_Packet);
 		break;
 	case PCPP_ETHERTYPE_PPPOES:
-		m_NextLayer = new PPPoESessionLayer(payload, payloadLen, this, m_Packet);
+		m_NextLayer = PPPoESessionLayer::isDataValid(payload, payloadLen)
+			? static_cast<Layer*>(new PPPoESessionLayer(payload, payloadLen, this, m_Packet))
+			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_PPPOED:
-		m_NextLayer = new PPPoEDiscoveryLayer(payload, payloadLen, this, m_Packet);
+		m_NextLayer = PPPoEDiscoveryLayer::isDataValid(payload, payloadLen)
+			? static_cast<Layer*>(new PPPoEDiscoveryLayer(payload, payloadLen, this, m_Packet))
+			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_MPLS:
 		m_NextLayer = new MplsLayer(payload, payloadLen, this, m_Packet);
 		break;
 	default:
 		m_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);
 	}
 }
diff --git a/Packet++/src/GtpLayer.cpp b/Packet++/src/GtpLayer.cpp
index 28b64bcb..f86a0145 100644
--- a/Packet++/src/GtpLayer.cpp
+++ b/Packet++/src/GtpLayer.cpp
@@ -203,10 +203,10 @@ void GtpV1Layer::init(GtpV1MessageType messageType, uint32_t teid, bool setSeqNu
 
 bool GtpV1Layer::isGTPv1(const uint8_t* data, size_t dataSize)
 {
-	if(data != NULL && dataSize > 1 && (data[0] & 0xE0) == 0x20)
+	if(data != NULL && dataSize >= sizeof(gtpv1_header) && (data[0] & 0xE0) == 0x20)
 	{
 		return true;
 	}
 
 	return false;
 }
diff --git a/Packet++/src/PPPoELayer.cpp b/Packet++/src/PPPoELayer.cpp
index 1e8d98ca..a11430b9 100644
--- a/Packet++/src/PPPoELayer.cpp
+++ b/Packet++/src/PPPoELayer.cpp
@@ -368,7 +368,11 @@ PPPoEDiscoveryLayer::PPPoETag* PPPoEDiscoveryLayer::addTag(PPPoETagTypes tagType
 
 size_t PPPoEDiscoveryLayer::getHeaderLen() const
 {
-	return sizeof(pppoe_header) + be16toh(getPPPoEHeader()->payloadLength);
+	size_t payloadLen = sizeof(pppoe_header) + be16toh(getPPPoEHeader()->payloadLength);
+	if (payloadLen > m_DataLen)
+		return m_DataLen;
+
+	return payloadLen;
 }
 
 PPPoEDiscoveryLayer::PPPoETag* PPPoEDiscoveryLayer::castPtrToPPPoETag(uint8_t* ptr) const
diff --git a/Packet++/src/SllLayer.cpp b/Packet++/src/SllLayer.cpp
index 012de021..a7462005 100644
--- a/Packet++/src/SllLayer.cpp
+++ b/Packet++/src/SllLayer.cpp
@@ -58,41 +58,45 @@ bool SllLayer::setMacAddressAsLinkLayer(MacAddress macAddr)
 void SllLayer::parseNextLayer()
 {
 	if (m_DataLen <= sizeof(sll_header))
 		return;
 
 	uint8_t* payload = m_Data + sizeof(sll_header);
 	size_t payloadLen = m_DataLen - sizeof(sll_header);
 
 	sll_header* hdr = getSllHeader();
 	switch (be16toh(hdr->protocol_type))
 	{
 	case PCPP_ETHERTYPE_IP:
 		m_NextLayer = IPv4Layer::isDataValid(payload, payloadLen)
 			? static_cast<Layer*>(new IPv4Layer(payload, payloadLen, this, m_Packet))
 			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_IPV6:
 		m_NextLayer = IPv6Layer::isDataValid(payload, payloadLen)
 			? static_cast<Layer*>(new IPv6Layer(payload, payloadLen, this, m_Packet))
 			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_ARP:
 		m_NextLayer = new ArpLayer(payload, payloadLen, this, m_Packet);
 		break;
 	case PCPP_ETHERTYPE_VLAN:
 		m_NextLayer = new VlanLayer(payload, payloadLen, this, m_Packet);
 		break;
 	case PCPP_ETHERTYPE_PPPOES:
-		m_NextLayer = new PPPoESessionLayer(payload, payloadLen, this, m_Packet);
+		m_NextLayer = PPPoESessionLayer::isDataValid(payload, payloadLen)
+			? static_cast<Layer*>(new PPPoESessionLayer(payload, payloadLen, this, m_Packet))
+			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_PPPOED:
-		m_NextLayer = new PPPoEDiscoveryLayer(payload, payloadLen, this, m_Packet);
+		m_NextLayer = PPPoEDiscoveryLayer::isDataValid(payload, payloadLen)
+			? static_cast<Layer*>(new PPPoEDiscoveryLayer(payload, payloadLen, this, m_Packet))
+			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_MPLS:
 		m_NextLayer = new MplsLayer(payload, payloadLen, this, m_Packet);
 		break;
 	default:
 		m_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);
 	}
 
 }
diff --git a/Packet++/src/VlanLayer.cpp b/Packet++/src/VlanLayer.cpp
index f1db1068..9ede3b5f 100644
--- a/Packet++/src/VlanLayer.cpp
+++ b/Packet++/src/VlanLayer.cpp
@@ -56,40 +56,44 @@ void VlanLayer::setPriority(uint8_t priority) {
 void VlanLayer::parseNextLayer()
 {
 	if (m_DataLen <= sizeof(vlan_header))
 		return;
 	
 	uint8_t* payload = m_Data + sizeof(vlan_header);
 	size_t payloadLen = m_DataLen - sizeof(vlan_header);
 
 	vlan_header* hdr = getVlanHeader();
 	switch (be16toh(hdr->etherType))
 	{
 	case PCPP_ETHERTYPE_IP:
 		m_NextLayer = IPv4Layer::isDataValid(payload, payloadLen)
 			? static_cast<Layer*>(new IPv4Layer(payload, payloadLen, this, m_Packet))
 			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_IPV6:
 		m_NextLayer = IPv6Layer::isDataValid(payload, payloadLen)
 			? static_cast<Layer*>(new IPv6Layer(payload, payloadLen, this, m_Packet))
 			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_ARP:
 		m_NextLayer = new ArpLayer(payload, payloadLen, this, m_Packet);
 		break;
 	case PCPP_ETHERTYPE_VLAN:
 		m_NextLayer = new VlanLayer(payload, payloadLen, this, m_Packet);
 		break;
 	case PCPP_ETHERTYPE_PPPOES:
-		m_NextLayer = new PPPoESessionLayer(payload, payloadLen, this, m_Packet);
+		m_NextLayer = PPPoESessionLayer::isDataValid(payload, payloadLen)
+			? static_cast<Layer*>(new PPPoESessionLayer(payload, payloadLen, this, m_Packet))
+			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_PPPOED:
-		m_NextLayer = new PPPoEDiscoveryLayer(payload, payloadLen, this, m_Packet);
+		m_NextLayer = PPPoEDiscoveryLayer::isDataValid(payload, payloadLen)
+			? static_cast<Layer*>(new PPPoEDiscoveryLayer(payload, payloadLen, this, m_Packet))
+			: static_cast<Layer*>(new PayloadLayer(payload, payloadLen, this, m_Packet));
 		break;
 	case PCPP_ETHERTYPE_MPLS:
 		m_NextLayer = new MplsLayer(payload, payloadLen, this, m_Packet);
 		break;
 	default:
 		m_NextLayer = new PayloadLayer(payload, payloadLen, this, m_Packet);
 	}
 }
diff --git a/Tests/Fuzzers/RegressionTests/regression_samples/clusterfuzz-testcase-FuzzTarget-6207688043397120 b/Tests/Fuzzers/RegressionTests/regression_samples/clusterfuzz-testcase-FuzzTarget-6207688043397120
new file mode 100644
index 00000000..7104cde0
Binary files /dev/null and b/Tests/Fuzzers/RegressionTests/regression_samples/clusterfuzz-testcase-FuzzTarget-6207688043397120 differ
diff --git a/Tests/Fuzzers/RegressionTests/regression_samples/clusterfuzz-testcase-minimized-FuzzTarget-5204104585674752 b/Tests/Fuzzers/RegressionTests/regression_samples/clusterfuzz-testcase-minimized-FuzzTarget-5204104585674752
new file mode 100644
index 00000000..9ce24098
Binary files /dev/null and b/Tests/Fuzzers/RegressionTests/regression_samples/clusterfuzz-testcase-minimized-FuzzTarget-5204104585674752 differ
