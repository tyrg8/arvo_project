commit 9392fc7117dd5240c76d8ab81d84b482bc968339
Author: Riccardo Schirone <ret2libc@users.noreply.github.com>
Date:   Thu May 30 15:45:52 2019 +0200

    Fix some RBin file format crashes ##bin
    
    * Use st64 and ut64 instead of size_t
    * Fix mach0 parsing issue
    * Fix OOB write in PE parsing
    * Fix crash in bin_xbe parser
    * Fix crash in bin_java
    Fixes clusterfuzz-testcase-minimized-ia_fuzz-5740477602594816.dms

diff --git a/libr/bin/format/mach0/mach0.c b/libr/bin/format/mach0/mach0.c
index 34a1794e35..9b11f96eda 100644
--- a/libr/bin/format/mach0/mach0.c
+++ b/libr/bin/format/mach0/mach0.c
@@ -2060,222 +2060,225 @@ static int reloc_comparator(struct reloc_t *a, struct reloc_t *b) {
 RSkipList *MACH0_(get_relocs)(struct MACH0_(obj_t) *bin) {
 	RSkipList *relocs;
 	ulebr ur = {NULL};
 	int wordsize = MACH0_(get_bits)(bin) / 8;
 	if (bin->dyld_info) {
 		ut8 *opcodes,*end, type = 0, rel_type = 0;
 		int lib_ord, seg_idx = -1, sym_ord = -1;
 		char *sym_name = NULL;
 		size_t j, count, skip, bind_size, lazy_size, weak_size;
 		st64 addend = 0;
 		ut64 segmentAddress = 0LL;
 		ut64 addr = 0LL;
 
 #define CASE(T) case ((T) / 8): rel_type = R_BIN_RELOC_ ## T; break
 		switch (wordsize) {
 		CASE(8);
 		CASE(16);
 		CASE(32);
 		CASE(64);
 		default: return NULL;
 		}
 #undef CASE
 		bind_size = bin->dyld_info->bind_size;
 		lazy_size = bin->dyld_info->lazy_bind_size;
 		weak_size = bin->dyld_info->weak_bind_size;
 
 		if (!bind_size || !lazy_size) {
 			return NULL;
 		}
 
 		if ((bind_size + lazy_size)<1) {
 			return NULL;
 		}
 		if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {
 			return NULL;
 		}
 		if (bin->dyld_info->lazy_bind_off > bin->size || \
 			bin->dyld_info->lazy_bind_off + lazy_size > bin->size) {
 			return NULL;
 		}
-		if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {
+		if (bin->dyld_info->bind_off + bind_size + lazy_size > bin->size) {
+			return NULL;
+		}
+		if (bin->dyld_info->weak_bind_off + weak_size > bin->size) {
 			return NULL;
 		}
 		ut64 amount = bind_size + lazy_size + weak_size;
 		if (amount < 0) {
 			return NULL;
 		}
 		relocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);
 		if (!relocs) {
 			return NULL;
 		}
 		opcodes = calloc (1, amount + 1);
 		if (!opcodes) {
 			r_skiplist_free (relocs);
 			return NULL;
 		}
 
 		int len = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);
 		len += r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);
 		len += r_buf_read_at (bin->b, bin->dyld_info->weak_bind_off, opcodes + bind_size + lazy_size, weak_size);
 		if (len < amount) {
 			bprintf ("Error: read (dyld_info bind) at 0x%08"PFMT64x"\n", (ut64)(size_t)bin->dyld_info->bind_off);
 			R_FREE (opcodes);
 			r_skiplist_free (relocs);
 			return NULL;
 		}
 
 		for (ur.p = opcodes, end = opcodes + amount ; ur.p < end; ) {
 			ut8 imm = *ur.p & BIND_IMMEDIATE_MASK, op = *ur.p & BIND_OPCODE_MASK;
 			++ur.p;
 			if (ur.p >= end) {
 				break;
 			}
 			switch (op) {
 #define ULEB() read_uleb128 (&ur,end)
 #define SLEB() read_sleb128 (&ur,end)
 			case BIND_OPCODE_DONE:
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
 				lib_ord = imm;
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
 				lib_ord = ULEB();
 				break;
 			case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
 				lib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;
 				break;
 			case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {
 				sym_name = (char*)ur.p;
 				while (*ur.p++ && ur.p<end) {
 					/* empty loop */
 				}
 				sym_ord = -1;
 				if (bin->symtab && bin->dysymtab.nundefsym < 0xffff) {
 					for (j = 0; j < bin->dysymtab.nundefsym; j++) {
 						int stridx = 0;
 						int iundefsym = bin->dysymtab.iundefsym;
 						if (iundefsym >= 0 && iundefsym < bin->nsymtab) {
 							int sidx = iundefsym + j;
 							if (sidx < 0 || sidx >= bin->nsymtab) {
 								continue;
 							}
 							stridx = bin->symtab[sidx].n_strx;
 							if (stridx < 0 || stridx >= bin->symstrlen) {
 								continue;
 							}
 						}
 						if (!strcmp ((char *)bin->symstr + stridx, sym_name)) {
 							sym_ord = j;
 							break;
 						}
 					}
 				}
 				break;
 			}
 			case BIND_OPCODE_SET_TYPE_IMM:
 				type = imm;
 				break;
 			case BIND_OPCODE_SET_ADDEND_SLEB:
 				addend = SLEB();
 				break;
 			case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
 				seg_idx = imm;
 				if (seg_idx < 0 || seg_idx >= bin->nsegs) {
 					bprintf ("Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB"
 						" has unexistent segment %d\n", seg_idx);
 					R_FREE (opcodes);
 					r_skiplist_free (relocs);
 					return NULL; // early exit to avoid future mayhem
 				} else {
 					addr = bin->segs[seg_idx].vmaddr + ULEB();
 					segmentAddress = bin->segs[seg_idx].vmaddr \
 							+ bin->segs[seg_idx].vmsize;
 				}
 				break;
 			case BIND_OPCODE_ADD_ADDR_ULEB:
 				addr += ULEB();
 				break;
 #define DO_BIND() do {\
 	if ((sym_ord < 0 && !sym_name) || seg_idx < 0 ) break;\
 	if (!addr) break;\
 	struct reloc_t *reloc = R_NEW0 (struct reloc_t);\
 	reloc->addr = addr;\
 	reloc->offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\
 	if (type == BIND_TYPE_TEXT_PCREL32)\
 		reloc->addend = addend - (bin->baddr + addr);\
 	else\
 		reloc->addend = addend;\
 	/* library ordinal ??? */ \
 	reloc->ord = lib_ord;\
 	reloc->ord = sym_ord;\
 	reloc->type = rel_type;\
 	if (sym_name)\
 		r_str_ncpy (reloc->name, sym_name, 256);\
 	r_skiplist_insert (relocs, reloc);\
 } while (0)
 			case BIND_OPCODE_DO_BIND:
 				if (addr >= segmentAddress) {
 					bprintf ("Error: Malformed DO bind opcode\n");
 					goto beach;
 				}
 				DO_BIND ();
 				addr += wordsize;
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
 				if (addr >= segmentAddress) {
 					bprintf ("Error: Malformed ADDR ULEB bind opcode\n");
 					goto beach;
 				}
 				DO_BIND ();
 				addr += ULEB () + wordsize;
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
 				if (addr >= segmentAddress) {
 					bprintf ("Error: Malformed IMM SCALED bind opcode\n");
 					goto beach;
 				}
 				DO_BIND();
 				addr += (ut64)imm * (ut64)wordsize + wordsize;
 				break;
 			case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
 				count = ULEB();
 				skip = ULEB();
 				for (j = 0; j < count; j++) {
 					if (addr >= segmentAddress) {
 						bprintf ("Error: Malformed ULEB TIMES bind opcode\n");
 						goto beach;
 					}
 					DO_BIND ();
 					addr += skip + wordsize;
 				}
 				break;
 #undef DO_BIND
 #undef ULEB
 #undef SLEB
 			default:
 				bprintf ("Error: unknown bind opcode 0x%02x in dyld_info\n", *ur.p);
 				R_FREE (opcodes);
 				return relocs;
 			}
 		}
 		R_FREE (opcodes);
 	} else {
 		int j;
 		if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {
 			return NULL;
 		}
 		int amount = bin->dysymtab.nundefsym;
 		if (amount < 0) {
 			amount = 0;
 		}
 		relocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);
 		if (!relocs) {
 			return NULL;
 		}
 		for (j = 0; j < amount; j++) {
 			struct reloc_t *reloc = R_NEW0 (struct reloc_t);
 			if (parse_import_ptr (bin, reloc, bin->dysymtab.iundefsym + j)) {
 				reloc->ord = j;
 			}
 		}
 	}
diff --git a/libr/bin/format/pe/pe.c b/libr/bin/format/pe/pe.c
index 6d695d7c10..0a525f413e 100644
--- a/libr/bin/format/pe/pe.c
+++ b/libr/bin/format/pe/pe.c
@@ -2461,32 +2461,32 @@ R_API void PE_(bin_pe_parse_resource)(struct PE_(r_bin_pe_obj_t) *bin) {
 static void bin_pe_get_certificate(struct PE_ (r_bin_pe_obj_t) * bin) {
 	ut64 size, vaddr;
 	ut8 *data = NULL;
 	int len;
 	if (!bin || !bin->nt_headers) {
 		return;
 	}
 	bin->cms = NULL;
 	size = bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY].Size;
 	vaddr = bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY].VirtualAddress;
-	if (size == 0) {
+	if (size < 8) {
 		return;
 	}
 	data = calloc (1, size);
 	if (!data) {
 		return;
 	}
 	if (vaddr > bin->size || vaddr + size > bin->size) {
 		bprintf ("vaddr greater than the file\n");
 		free (data);
 		return;
 	}
 	//skipping useless header..
 	len = r_buf_read_at (bin->b, vaddr + 8, data, size - 8);
 	if (len < 1) {
 		R_FREE (data);
 		return;
 	}
 	bin->cms = r_pkcs7_parse_cms (data, size);
 	bin->is_signed = bin->cms != NULL;
 	R_FREE (data);
 }
diff --git a/libr/bin/format/xbe/xbe.h b/libr/bin/format/xbe/xbe.h
index 71142c0b89..7bb35ae942 100644
--- a/libr/bin/format/xbe/xbe.h
+++ b/libr/bin/format/xbe/xbe.h
@@ -65,9 +65,9 @@ typedef struct  {
 }) xbe_lib;
 
 typedef struct {
-	xbe_header *header;
+	xbe_header header;
 	int kt_key;
 	int ep_key;
 } r_bin_xbe_obj_t; 
 
 
diff --git a/libr/bin/p/bin_java.c b/libr/bin/p/bin_java.c
index 9b3d9a4bdc..25f1b7a3e8 100644
--- a/libr/bin/p/bin_java.c
+++ b/libr/bin/p/bin_java.c
@@ -74,67 +74,22 @@ static Sdb *get_sdb(RBinFile *bf) {
 	return NULL;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
+static bool load_buffer(RBinFile * bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	struct r_bin_java_obj_t *tmp_bin_obj = NULL;
-	RBuffer *tbuf = NULL;
-	if (!buf || sz == 0 || sz == UT64_MAX) {
+	RBuffer *tbuf = r_buf_ref (buf);
+	tmp_bin_obj = r_bin_java_new_buf (tbuf, loadaddr, sdb);
+	if (!tmp_bin_obj) {
 		return false;
 	}
-	tbuf = r_buf_new ();
-	r_buf_set_bytes (tbuf, buf, sz);
-	tmp_bin_obj = r_bin_java_new_buf (tbuf, loadaddr, sdb);
 	*bin_obj = tmp_bin_obj;
 	add_bin_obj_to_sdb (tmp_bin_obj);
 	if (bf && bf->file) {
 		tmp_bin_obj->file = strdup (bf->file);
 	}
 	r_buf_free (tbuf);
 	return true;
 }
 
-static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-
-	int result = false;
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	struct r_bin_java_obj_t *bin_obj = NULL;
-
-	load_bytes (bf, (void **)&bin_obj, bytes, sz, bf->o->loadaddr, bf->sdb);
-
-	if (bin_obj) {
-		if (!bf->o->kv) {
-			bf->o->kv = bin_obj->kv;
-		}
-		bf->o->bin_obj = bin_obj;
-		bin_obj->AllJavaBinObjs = DB;
-		// XXX - /\ this is a hack, but (one way but) necessary to get access to
-		// the object addrs from anal. If only global variables are used,
-		// they get "lost" somehow after they are initialized and go out of
-		// scope.
-		//
-		// There are several points of indirection, but here is the gist:
-		// 1) RAnal->(through RBinBind) RBin->RBinJavaObj->DB
-		//
-		// The purpose is to ensure that information about a give class file
-		// can be grabbed at any time from RAnal.  This was tried with global
-		// variables, but failed when attempting to access the DB
-		// in the class.c scope.  Once DB  was moved here, it is initialized
-		// once here and assigned to each of the other RBinJavaObjs.
-		//
-		// Now, the RAnal component of radare can get to each of the
-		// RBinJavaObjs for analysing functions and dependencies using an Sdb.
-		add_bin_obj_to_sdb (bin_obj);
-		if (bf->file) {
-			bin_obj->file = strdup (bf->file);
-		}
-		result = true;
-	}
-	return result;
-}
-
 static void destroy(RBinFile *bf) {
 	r_bin_java_free ((struct r_bin_java_obj_t *) bf->o->bin_obj);
 	sdb_free (DB);
@@ -262,29 +217,28 @@ static RList *libs(RBinFile *bf) {
 RBinPlugin r_bin_plugin_java = {
 	.name = "java",
 	.desc = "java bin plugin",
 	.license = "LGPL3",
 	.init = init,
 	.fini = fini,
 	.get_sdb = &get_sdb,
-	.load = &load,
-	.load_bytes = &load_bytes,
+	.load_buffer = &load_buffer,
 	.destroy = &destroy,
 	.check_bytes = &check_bytes,
 	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = binsym,
 	.entries = &entries,
 	.sections = sections,
 	.symbols = symbols,
 	.imports = &imports,
 	.strings = &strings,
 	.info = &info,
 	.fields = fields,
 	.libs = libs,
 	.lines = &lines,
 	.classes = classes,
 	.demangle_type = retdemangle,
 	.minstrlen = 3,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_xbe.c b/libr/bin/p/bin_xbe.c
index 5422967435..47f9e28f75 100644
--- a/libr/bin/p/bin_xbe.c
+++ b/libr/bin/p/bin_xbe.c
@@ -19,69 +19,69 @@ static bool check_buffer(RBuffer *b) {
 	return false;
 }
 
-static bool load(RBinFile *bf) {
-	r_return_val_if_fail (bf && bf->o, false);
-	r_bin_xbe_obj_t *obj = NULL;
-	const ut8 *bytes = r_buf_data (bf->buf, NULL);
-	bf->o->bin_obj = malloc (sizeof (r_bin_plugin_xbe));
-	obj = bf->o->bin_obj;
-	if (obj) {
-		obj->header = (xbe_header *) bytes;
-		if ((obj->header->ep & 0xf0000000) == 0x40000000) {
-			// Sega Chihiro xbe
-			obj->ep_key = XBE_EP_CHIHIRO;
-			obj->kt_key = XBE_KP_CHIHIRO;
-		} else if ((obj->header->ep ^ XBE_EP_RETAIL) > 0x1000000) {
-			// Debug xbe
-			obj->ep_key = XBE_EP_DEBUG;
-			obj->kt_key = XBE_KP_DEBUG;
-		} else {
-			// Retail xbe
-			obj->ep_key = XBE_EP_RETAIL;
-			obj->kt_key = XBE_KP_RETAIL;
-		}
-		return true;
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	r_bin_xbe_obj_t *obj = R_NEW (r_bin_xbe_obj_t);
+	if (!obj) {
+		return false;
 	}
-	return false;
+	st64 r = r_buf_read_at (buf, 0, (ut8 *)&obj->header, sizeof (obj->header));
+	if (r != sizeof (obj->header)) {
+		R_FREE (obj);
+		return false;
+	}
+
+	if ((obj->header.ep & 0xf0000000) == 0x40000000) {
+		// Sega Chihiro xbe
+		obj->ep_key = XBE_EP_CHIHIRO;
+		obj->kt_key = XBE_KP_CHIHIRO;
+	} else if ((obj->header.ep ^ XBE_EP_RETAIL) > 0x1000000) {
+		// Debug xbe
+		obj->ep_key = XBE_EP_DEBUG;
+		obj->kt_key = XBE_KP_DEBUG;
+	} else {
+		// Retail xbe
+		obj->ep_key = XBE_EP_RETAIL;
+		obj->kt_key = XBE_KP_RETAIL;
+	}
+	*bin_obj = obj;
+	return true;
 }
 
 static void destroy(RBinFile *bf) {
 	R_FREE (bf->o->bin_obj);
-	r_buf_free (bf->buf);
-	bf->buf = NULL;
 }
 
 static RBinAddr *binsym(RBinFile *bf, int type) {
 	if (!bf || !bf->buf || type != R_BIN_SYM_MAIN) {
 		return NULL;
 	}
 	r_bin_xbe_obj_t *obj = bf->o->bin_obj;
 	RBinAddr *ret = R_NEW0 (RBinAddr);
 	if (!ret) {
 		return NULL;
 	}
-	ret->vaddr = obj->header->ep ^ obj->ep_key;
-	ret->paddr = ret->vaddr - obj->header->base;
+	ret->vaddr = obj->header.ep ^ obj->ep_key;
+	ret->paddr = ret->vaddr - obj->header.base;
 	return ret;
 }
 
 static RList *entries(RBinFile *bf) {
 	const r_bin_xbe_obj_t *obj;
 	RList *ret;
 	RBinAddr *ptr = R_NEW0 (RBinAddr);
 	if (!bf || !bf->buf || !bf->o->bin_obj || !ptr) {
 		free (ptr);
 		return NULL;
 	}
 	ret = r_list_new ();
 	if (!ret) {
 		free (ptr);
 		return NULL;
 	}
 	ret->free = free;
 	obj = bf->o->bin_obj;
-	ptr->vaddr = obj->header->ep ^ obj->ep_key;
-	ptr->paddr = ptr->vaddr - obj->header->base;
+	ptr->vaddr = obj->header.ep ^ obj->ep_key;
+	ptr->paddr = ptr->vaddr - obj->header.base;
 	r_list_append (ret, ptr);
 	return ret;
 }
@@ -89,69 +89,69 @@ static RList *entries(RBinFile *bf) {
 static RList *sections(RBinFile *bf) {
 	xbe_section *sect = NULL;
 	r_bin_xbe_obj_t *obj = NULL;
 	xbe_header *h = NULL;
 	RList *ret = NULL;
 	char tmp[0x100];
 	int i, r;
 	ut32 addr;
 
 	if (!bf || !bf->o || !bf->o->bin_obj || !bf->buf) {
 		return NULL;
 	}
 	obj = bf->o->bin_obj;
-	h = obj->header;
+	h = &obj->header;
 	if (h->sections < 1) {
 		return NULL;
 	}
 	ret = r_list_new ();
 	if (!ret) {
 		return NULL;
 	}
 	ret->free = free;
 	if (h->sections < 1 || h->sections > 255) {
 		goto out_error;
 	}
 	sect = calloc (h->sections, sizeof (xbe_section));
 	if (!sect) {
 		goto out_error;
 	}
 	addr = h->sechdr_addr - h->base;
 	if (addr > bf->size || addr + (sizeof(xbe_section) * h->sections) > bf->size) {
 		goto out_error;
 	}
 	r = r_buf_read_at (bf->buf, addr, (ut8 *) sect, sizeof(xbe_section) * h->sections);
 	if (r < 1) {
 		goto out_error;
 	}
 	for (i = 0; i < h->sections; i++) {
 		RBinSection *item = R_NEW0 (RBinSection);
 		addr = sect[i].name_addr - h->base;
 		tmp[0] = 0;
 		if (addr > bf->size || addr + sizeof (tmp) > bf->size) {
 			free (item);
 			goto out_error;
 		}
 		r = r_buf_read_at (bf->buf, addr, (ut8 *) tmp, sizeof (tmp));
 		if (r < 1) {
 			free (item);
 			goto out_error;
 		}
 		tmp[sizeof (tmp) - 1] = 0;
 		item->name = r_str_newf ("%s.%i", tmp, i);
 		item->paddr = sect[i].offset;
 		item->vaddr = sect[i].vaddr;
 		item->size = sect[i].size;
 		item->vsize = sect[i].vsize;
 		item->add = true;
 
 		item->perm = R_PERM_R;
 		if (sect[i].flags & SECT_FLAG_X) {
 			item->perm |= R_PERM_X;
 		}
 		if (sect[i].flags & SECT_FLAG_W) {
 			item->perm |= R_PERM_W;
 		}
 		r_list_append (ret, item);
 	}
 	free (sect);
 	return ret;
@@ -164,76 +164,76 @@ out_error:
 static RList *libs(RBinFile *bf) {
 	r_bin_xbe_obj_t *obj;
 	xbe_header *h = NULL;
 	int i, off, libs, r;
 	xbe_lib lib;
 	RList *ret;
 	char *s;
 	ut32 addr;
 
 	if (!bf || !bf->o || !bf->o->bin_obj) {
 		return NULL;
 	}
 	obj = bf->o->bin_obj;
-	h = obj->header;
+	h = &obj->header;
 	ret = r_list_new ();
 	if (!ret) {
 		return NULL;
 	}
 	ret->free = free;
 	if (h->kernel_lib_addr < h->base) {
 		off = 0;
 	} else {
 		off = h->kernel_lib_addr - h->base;
 	}
 	if (off > bf->size || off + sizeof(xbe_lib) > bf->size) {
 		goto out_error;
 	}
 	r = r_buf_read_at (bf->buf, off, (ut8 *) &lib, sizeof(xbe_lib));
 	if (r < 1) {
 		goto out_error;
 	}
 	lib.name[7] = 0;
 	s = r_str_newf ("%s %i.%i.%i", lib.name, lib.major, lib.minor, lib.build);
 	if (s) {
 		r_list_append (ret, s);
 	}
 	if (h->xapi_lib_addr < h->base) {
 		off = 0;
 	} else {
 		off = h->xapi_lib_addr - h->base;
 	}
 	if (off > bf->size || off + sizeof(xbe_lib) > bf->size) {
 		goto out_error;
 	}
 	r = r_buf_read_at (bf->buf, off, (ut8 *) &lib, sizeof(xbe_lib));
 	if (r < 1) {
 		goto out_error;
 	}
 
 	lib.name[7] = 0;
 	s = r_str_newf ("%s %i.%i.%i", lib.name, lib.major, lib.minor, lib.build);
 	if (s) {
 		r_list_append (ret, s);
 	}
 	libs = h->lib_versions;
 	if (libs < 1) {
 		goto out_error;
 	}
 	for (i = 0; i < libs; i++) {
 		addr = h->lib_versions_addr - h->base + (i * sizeof (xbe_lib));
 		if (addr > bf->size || addr + sizeof (xbe_lib) > bf->size) {
 			goto out_error;
 		}
 		r = r_buf_read_at (bf->buf, addr, (ut8 *) &lib, sizeof (xbe_lib));
 		if (r < 1) {
 			goto out_error;
 		}
 		// make sure it ends with 0
 		lib.name[7] = '\0';
 		s = r_str_newf ("%s %i.%i.%i", lib.name, lib.major, lib.minor, lib.build);
 		if (s) {
 			r_list_append (ret, s);
 		}
 	}
 
 	return ret;
@@ -245,68 +245,68 @@ out_error:
 static RList *symbols(RBinFile *bf) {
 	r_bin_xbe_obj_t *obj;
 	xbe_header *h;
 	RList *ret;
 	int i, found = false;
 	ut32 thunk_addr[XBE_MAX_THUNK];
 	ut32 kt_addr;
 	xbe_section sect;
 	ut32 addr;
 
 	if (!bf || !bf->o || !bf->o->bin_obj) {
 		return NULL;
 	}
 
 	obj = bf->o->bin_obj;
-	h = obj->header;
+	h = &obj->header;
 	kt_addr = h->kernel_thunk_addr ^ obj->kt_key;
 	ret = r_list_new ();
 	if (!ret) {
 		return NULL;
 	}
 	ret->free = free;
 	eprintf ("sections %d\n", h->sections);
 	int limit = h->sections;
 	if (limit * (sizeof(xbe_section)) >= bf->size - h->sechdr_addr) {
 		goto out_error;
 	}
 	for (i = 0; found == false && i < limit; i++) {
 		addr = h->sechdr_addr - h->base + (sizeof (xbe_section) * i);
 		if (addr > bf->size || addr + sizeof(sect) > bf->size) {
 			goto out_error;
 		}
 		r_buf_read_at (bf->buf, addr, (ut8 *) &sect, sizeof(sect));
 		if (kt_addr >= sect.vaddr && kt_addr < sect.vaddr + sect.vsize) {
 			found = true;
 		}
 	}
 	if (!found) {
 		goto out_error;
 	}
 	addr = sect.offset + (kt_addr - sect.vaddr);
 	if (addr > bf->size || addr + sizeof(thunk_addr) > bf->size) {
 		goto out_error;
 	}
 	i = r_buf_read_at (bf->buf, addr, (ut8 *) &thunk_addr, sizeof (thunk_addr));
 	if (i != sizeof (thunk_addr)) {
 		goto out_error;
 	}
 	for (i = 0; i < XBE_MAX_THUNK && thunk_addr[i]; i++) {
 		RBinSymbol *sym = R_NEW0 (RBinSymbol);
 		if (!sym) {
 			goto out_error;
 		}
 		const ut32 thunk_index = thunk_addr[i] ^ 0x80000000;
 		// Basic sanity checks
 		if (thunk_addr[i] & 0x80000000 && thunk_index < XBE_MAX_THUNK) {
 			eprintf ("%d\n", thunk_index);
 			sym->name = r_str_newf ("kt.%s", kt_name[thunk_index]);
 			sym->vaddr = (h->kernel_thunk_addr ^ obj->kt_key) + (4 * i);
 			sym->paddr = sym->vaddr - h->base;
 			sym->size = 4;
 			sym->ordinal = i;
 			r_list_append (ret, sym);
 		} else {
 			free (sym);
 		}
 	}
 	return ret;
@@ -318,56 +318,56 @@ out_error:
 static RBinInfo *info(RBinFile *bf) {
 	r_bin_xbe_obj_t *obj;
 	RBinInfo *ret;
 	ut8 dbg_name[256];
 
 	if (!bf || !bf->buf) {
 		return NULL;
 	}
 
 	ret = R_NEW0 (RBinInfo);
 	if (!ret) {
 		return NULL;
 	}
 
 	obj = bf->o->bin_obj;
 
 	memset (dbg_name, 0, sizeof (dbg_name));
-	r_buf_read_at (bf->buf, obj->header->debug_name_addr -\
-		obj->header->base, dbg_name, sizeof (dbg_name));
+	r_buf_read_at (bf->buf, obj->header.debug_name_addr -\
+		obj->header.base, dbg_name, sizeof (dbg_name));
 	dbg_name[sizeof(dbg_name) - 1] = 0;
 	ret->file = strdup ((char *) dbg_name);
 	ret->bclass = strdup ("program");
 	ret->machine = strdup ("Microsoft Xbox");
 	ret->os = strdup ("xbox");
 	ret->type = strdup ("Microsoft Xbox executable");
 	ret->arch = strdup ("x86");
 	ret->has_va = 1;
 	ret->bits = 32;
 	ret->big_endian = 0;
 	ret->dbg_info = 0;
 	ret->lang = NULL;
 	return ret;
 }
 
 static ut64 baddr(RBinFile *bf) {
 	r_bin_xbe_obj_t *obj = bf->o->bin_obj;
-	return obj->header->base;
+	return obj->header.base;
 }
 
 RBinPlugin r_bin_plugin_xbe = {
 	.name = "xbe",
 	.desc = "Microsoft Xbox xbe format r_bin plugin",
 	.license = "LGPL3",
-	.load = &load,
+	.load_buffer = &load_buffer,
 	.destroy = &destroy,
 	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.info = &info,
 	.libs = &libs,
 };
 
 #ifndef CORELIB
diff --git a/libr/include/r_util/r_buf.h b/libr/include/r_util/r_buf.h
index dd9057b849..0c999d096d 100644
--- a/libr/include/r_util/r_buf.h
+++ b/libr/include/r_util/r_buf.h
@@ -16,11 +16,11 @@ typedef struct r_buf_t RBuffer;
 
 typedef bool (*RBufferInit)(RBuffer *b, const void *user);
 typedef bool (*RBufferFini)(RBuffer *b);
-typedef int (*RBufferRead)(RBuffer *b, ut8 *buf, size_t len);
-typedef int (*RBufferWrite)(RBuffer *b, const ut8 *buf, size_t len);
+typedef st64 (*RBufferRead)(RBuffer *b, ut8 *buf, ut64 len);
+typedef st64 (*RBufferWrite)(RBuffer *b, const ut8 *buf, ut64 len);
 typedef ut64 (*RBufferGetSize)(RBuffer *b);
 typedef bool (*RBufferResize)(RBuffer *b, ut64 newsize);
-typedef int (*RBufferSeek)(RBuffer *b, st64 addr, int whence);
+typedef st64 (*RBufferSeek)(RBuffer *b, st64 addr, int whence);
 typedef ut8 *(*RBufferGetWholeBuf)(RBuffer *b, ut64 *sz);
 typedef void (*RBufferFreeWholeBuf)(RBuffer *b);
 typedef RList *(*RBufferNonEmptyList)(RBuffer *b);
@@ -73,30 +73,30 @@ R_API RBuffer *r_buf_new_sparse(ut8 Oxff);
 /* methods */
 R_API bool r_buf_dump(RBuffer *buf, const char *file);
 R_API bool r_buf_set_bytes(RBuffer *b, const ut8 *buf, ut64 length);
-R_API int r_buf_append_string(RBuffer *b, const char *str);
+R_API st64 r_buf_append_string(RBuffer *b, const char *str);
 R_API bool r_buf_append_buf(RBuffer *b, RBuffer *a);
-R_API bool r_buf_append_bytes(RBuffer *b, const ut8 *buf, size_t length);
-R_API bool r_buf_append_nbytes(RBuffer *b, size_t length);
+R_API bool r_buf_append_bytes(RBuffer *b, const ut8 *buf, ut64 length);
+R_API bool r_buf_append_nbytes(RBuffer *b, ut64 length);
 R_API bool r_buf_append_ut16(RBuffer *b, ut16 n);
-R_API bool r_buf_append_buf_slice(RBuffer *b, RBuffer *a, ut64 offset, int size);
+R_API bool r_buf_append_buf_slice(RBuffer *b, RBuffer *a, ut64 offset, ut64 size);
 R_API bool r_buf_append_ut32(RBuffer *b, ut32 n);
 R_API bool r_buf_append_ut64(RBuffer *b, ut64 n);
-R_API bool r_buf_prepend_bytes(RBuffer *b, const ut8 *buf, size_t length);
-R_API int r_buf_insert_bytes(RBuffer *b, ut64 addr, const ut8 *buf, size_t length);
+R_API bool r_buf_prepend_bytes(RBuffer *b, const ut8 *buf, ut64 length);
+R_API st64 r_buf_insert_bytes(RBuffer *b, ut64 addr, const ut8 *buf, ut64 length);
 R_API char *r_buf_to_string(RBuffer *b);
-R_API char *r_buf_get_string (RBuffer *b, ut64 addr);
-R_API int r_buf_read(RBuffer *b, ut8 *buf, size_t len);
+R_API char *r_buf_get_string(RBuffer *b, ut64 addr);
+R_API st64 r_buf_read(RBuffer *b, ut8 *buf, ut64 len);
 R_API ut8 r_buf_read8(RBuffer *b);
-R_API int r_buf_fread(RBuffer *b, ut8 *buf, const char *fmt, int n);
-R_API int r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, int len);
+R_API st64 r_buf_fread(RBuffer *b, ut8 *buf, const char *fmt, int n);
+R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len);
 R_API ut8 r_buf_read8_at(RBuffer *b, ut64 addr);
 R_API ut64 r_buf_tell(RBuffer *b);
-R_API int r_buf_seek(RBuffer *b, st64 addr, int whence);
-R_API int r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n);
-R_API int r_buf_write(RBuffer *b, const ut8 *buf, size_t len);
-R_API int r_buf_fwrite(RBuffer *b, const ut8 *buf, const char *fmt, int n);
-R_API int r_buf_write_at(RBuffer *b, ut64 addr, const ut8 *buf, int len);
-R_API int r_buf_fwrite_at(RBuffer *b, ut64 addr, const ut8 *buf, const char *fmt, int n);
+R_API st64 r_buf_seek(RBuffer *b, st64 addr, int whence);
+R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n);
+R_API st64 r_buf_write(RBuffer *b, const ut8 *buf, ut64 len);
+R_API st64 r_buf_fwrite(RBuffer *b, const ut8 *buf, const char *fmt, int n);
+R_API st64 r_buf_write_at(RBuffer *b, ut64 addr, const ut8 *buf, ut64 len);
+R_API st64 r_buf_fwrite_at(RBuffer *b, ut64 addr, const ut8 *buf, const char *fmt, int n);
 // WARNING: this function should be used with care because it may allocate the
 // entire buffer in memory. Consider using the r_buf_read* APIs instead and read
 // only the chunks you need.
@@ -198,20 +198,20 @@ static inline ut64 r_buf_read_ble64_at(RBuffer *b, ut64 addr, bool big_endian) {
 	return r == sizeof (buf)? r_read_ble64 (buf, big_endian): UT64_MAX;
 }
 
-R_API int r_buf_uleb128(RBuffer *b, ut64 *v);
-R_API int r_buf_sleb128(RBuffer *b, st64 *v);
+R_API st64 r_buf_uleb128(RBuffer *b, ut64 *v);
+R_API st64 r_buf_sleb128(RBuffer *b, st64 *v);
 
-static inline int r_buf_uleb128_at(RBuffer *b, ut64 addr, ut64 *v) {
+static inline st64 r_buf_uleb128_at(RBuffer *b, ut64 addr, ut64 *v) {
 	r_buf_seek (b, addr, R_BUF_SET);
 	return r_buf_uleb128 (b, v);
 }
-static inline int r_buf_sleb128_at(RBuffer *b, ut64 addr, st64 *v) {
+static inline st64 r_buf_sleb128_at(RBuffer *b, ut64 addr, st64 *v) {
 	r_buf_seek (b, addr, R_BUF_SET);
 	return r_buf_sleb128 (b, v);
 }
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif //  R_BUF_H
diff --git a/libr/util/buf.c b/libr/util/buf.c
index 246d8f59fe..6182f2f390 100644
--- a/libr/util/buf.c
+++ b/libr/util/buf.c
@@ -35,17 +35,17 @@ static ut64 buf_get_size(RBuffer *b) {
 	return b->methods->get_size? b->methods->get_size (b): UT64_MAX;
 }
 
-static int buf_read(RBuffer *b, ut8 *buf, size_t len) {
+static st64 buf_read(RBuffer *b, ut8 *buf, size_t len) {
 	r_return_val_if_fail (b && b->methods, -1);
 	return b->methods->read? b->methods->read (b, buf, len): -1;
 }
 
-static int buf_write(RBuffer *b, const ut8 *buf, size_t len) {
+static st64 buf_write(RBuffer *b, const ut8 *buf, size_t len) {
 	r_return_val_if_fail (b && b->methods, -1);
 	return b->methods->write? b->methods->write (b, buf, len): -1;
 }
 
-static int buf_seek(RBuffer *b, st64 addr, int whence) {
+static st64 buf_seek(RBuffer *b, st64 addr, int whence) {
 	r_return_val_if_fail (b && b->methods, -1);
 	return b->methods->seek? b->methods->seek (b, addr, whence): -1;
 }
@@ -240,7 +240,7 @@ R_API bool r_buf_dump(RBuffer *b, const char *file) {
 	return r_file_dump (file, tmp, tmpsz, 0);
 }
 
-R_API int r_buf_seek(RBuffer *b, st64 addr, int whence) {
+R_API st64 r_buf_seek(RBuffer *b, st64 addr, int whence) {
 	r_return_val_if_fail (b, -1);
 	return buf_seek (b, addr, whence);
 }
@@ -263,7 +263,7 @@ R_API bool r_buf_set_bytes(RBuffer *b, const ut8 *buf, ut64 length) {
 	return r_buf_seek (b, 0, R_BUF_SET) >= 0;
 }
 
-R_API bool r_buf_prepend_bytes(RBuffer *b, const ut8 *buf, size_t length) {
+R_API bool r_buf_prepend_bytes(RBuffer *b, const ut8 *buf, ut64 length) {
 	r_return_val_if_fail (b && buf && !b->readonly, false);
 	return r_buf_insert_bytes (b, 0, buf, length) >= 0;
 }
@@ -282,59 +282,59 @@ R_API char *r_buf_to_string(RBuffer *b) {
 	return s;
 }
 
-R_API bool r_buf_append_bytes(RBuffer *b, const ut8 *buf, size_t length) {
+R_API bool r_buf_append_bytes(RBuffer *b, const ut8 *buf, ut64 length) {
 	r_return_val_if_fail (b && buf && !b->readonly, false);
 
 	if (r_buf_seek (b, 0, R_BUF_END) < 0) {
 		return false;
 	}
 
 	return r_buf_write (b, buf, length) >= 0;
 }
 
-R_API bool r_buf_append_nbytes(RBuffer *b, size_t length) {
+R_API bool r_buf_append_nbytes(RBuffer *b, ut64 length) {
 	r_return_val_if_fail (b && !b->readonly, false);
 	ut8 *buf = R_NEWS0 (ut8, length);
 	if (!buf) {
 		return false;
 	}
 	bool res = r_buf_append_bytes (b, buf, length);
 	free (buf);
 	return res;
 }
 
-R_API int r_buf_insert_bytes(RBuffer *b, ut64 addr, const ut8 *buf, size_t length) {
+R_API st64 r_buf_insert_bytes(RBuffer *b, ut64 addr, const ut8 *buf, ut64 length) {
 	r_return_val_if_fail (b && !b->readonly, -1);
-	int pos, r = r_buf_seek (b, 0, R_BUF_CUR);
+	st64 pos, r = r_buf_seek (b, 0, R_BUF_CUR);
 	if (r < 0) {
 		return r;
 	}
 	pos = r;
 	r = r_buf_seek (b, addr, R_BUF_SET);
 	if (r < 0) {
 		goto restore_pos;
 	}
 
 	ut64 sz = r_buf_size (b);
 	ut8 *tmp = R_NEWS (ut8, sz - addr);
 	r = r_buf_read (b, tmp, sz - addr);
 	if (r < 0) {
 		goto free_tmp;
 	}
-	size_t tmp_length = (size_t)r;
+	st64 tmp_length = r;
 	if (!r_buf_resize (b, sz + length)) {
 		goto free_tmp;
 	}
 	r = r_buf_seek (b, addr + length, R_BUF_SET);
 	if (r < 0) {
 		goto free_tmp;
 	}
 	r = r_buf_write (b, tmp, tmp_length);
 	if (r < 0) {
 		goto free_tmp;
 	}
 	r = r_buf_seek (b, addr, R_BUF_SET);
 	if (r < 0) {
 		goto free_tmp;
 	}
 	r = r_buf_write (b, buf, length);
@@ -367,16 +367,16 @@ R_API bool r_buf_append_buf(RBuffer *b, RBuffer *a) {
 	return r_buf_append_bytes (b, tmp, sz);
 }
 
-R_API bool r_buf_append_buf_slice(RBuffer *b, RBuffer *a, ut64 offset, int size) {
+R_API bool r_buf_append_buf_slice(RBuffer *b, RBuffer *a, ut64 offset, ut64 size) {
 	r_return_val_if_fail (b && a && !b->readonly, false);
 	ut8 *tmp = R_NEWS (ut8, size);
 	bool res = false;
 
 	if (!tmp) {
 		return false;
 	}
-	int r = r_buf_read_at (a, offset, tmp, size);
+	st64 r = r_buf_read_at (a, offset, tmp, size);
 	if (r < 0) {
 		goto err;
 	}
 	res = r_buf_append_bytes (b, tmp, r);
@@ -388,192 +388,193 @@ err:
 // return an heap-allocated string read from the RBuffer b at address addr. The
 // length depends on the first '\0' found in the buffer. If there is no '\0' in
 // the buffer, there is no string, thus NULL is returned.
 R_API char *r_buf_get_string(RBuffer *b, ut64 addr) {
 	const int MIN_RES_SZ = 64;
 	ut8 *res = R_NEWS (ut8, MIN_RES_SZ + 1);
 	ut64 sz = 0;
-	int r = r_buf_read_at (b, addr, res, MIN_RES_SZ);
+	st64 r = r_buf_read_at (b, addr, res, MIN_RES_SZ);
 	bool null_found = false;
 	while (r > 0) {
 		const ut8 *needle = r_mem_mem (res + sz, r, (ut8 *)"\x00", 1);
 		if (needle) {
 			sz += (needle - (res + sz));
 			null_found = true;
 			break;
 		}
 		sz += r;
 		addr += r;
 
 		ut8 *restmp = realloc (res, sz + MIN_RES_SZ + 1);
 		if (!restmp) {
 			free (res);
 			return NULL;
 		}
 		res = restmp;
 		r = r_buf_read_at (b, addr, res + sz, MIN_RES_SZ);
 	}
 	if (r < 0 || !null_found) {
 		free (res);
 		return NULL;
 	}
 	return (char *)res;
 }
 
-R_API int r_buf_read(RBuffer *b, ut8 *buf, size_t len) {
+R_API st64 r_buf_read(RBuffer *b, ut8 *buf, ut64 len) {
 	r_return_val_if_fail (b && buf, -1);
-	int r = buf_read (b, buf, len);
+	ut64 r = buf_read (b, buf, len);
 	if (r >= 0 && r < len) {
 		memset (buf + r, b->Oxff_priv, len - r);
 	}
 	return r;
 }
 
-R_API int r_buf_write(RBuffer *b, const ut8 *buf, size_t len) {
+R_API st64 r_buf_write(RBuffer *b, const ut8 *buf, ut64 len) {
 	r_return_val_if_fail (b && buf && !b->readonly, -1);
 	return buf_write (b, buf, len);
 }
 
 R_API ut8 r_buf_read8(RBuffer *b) {
 	ut8 res;
-	int r = r_buf_read (b, &res, sizeof (res));
-	return r == sizeof (res)? res :b->Oxff_priv;
+	st64 r = r_buf_read (b, &res, sizeof (res));
+	return r == sizeof (res)? res: b->Oxff_priv;
 }
 
 R_API ut8 r_buf_read8_at(RBuffer *b, ut64 addr) {
 	ut8 res;
-	int r = r_buf_read_at (b, addr, &res, sizeof (res));
+	st64 r = r_buf_read_at (b, addr, &res, sizeof (res));
 	return r == sizeof (res)? res: b->Oxff_priv;
 }
 
-static int buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) {
-	int i, res = 0;
+static st64 buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) {
+	st64 res = 0;
+	int i;
 	for (i = 0; i < n; ++i) {
 		int j;
 		int m = 1;
 		int tsize = 2;
 		bool bigendian = true;
 
 		for (j = 0; fmt[j]; ++j) {
 			switch (fmt[j]) {
 			case '0':
 			case '1':
 			case '2':
 			case '3':
 			case '4':
 			case '5':
 			case '6':
 			case '7':
 			case '8':
 			case '9':
 				if (m == 1) {
 					m = r_num_get (NULL, &fmt[j]);
 				}
 				continue;
 			case 's': tsize = 2; bigendian = false; break;
 			case 'S': tsize = 2; bigendian = true; break;
 			case 'i': tsize = 4; bigendian = false; break;
 			case 'I': tsize = 4; bigendian = true; break;
 			case 'l': tsize = 8; bigendian = false; break;
 			case 'L': tsize = 8; bigendian = true; break;
 			case 'c': tsize = 1; bigendian = false; break;
 			default: return -1;
 			}
 
 			int k;
 			for (k = 0; k < m; k++) {
 				ut8 tmp[sizeof (ut64)];
 				ut8 d1;
 				ut16 d2;
 				ut32 d3;
 				ut64 d4;
-				int r = r_buf_read (src, tmp, tsize);
+				st64 r = r_buf_read (src, tmp, tsize);
 				if (r < tsize) {
 					return -1;
 				}
 
 				switch (tsize) {
 				case 1:
 					d1 = r_read_ble8 (tmp);
 					r = r_buf_write (dst, (ut8 *)&d1, 1);
 					break;
 				case 2:
 					d2 = r_read_ble16 (tmp, bigendian);
 					r = r_buf_write (dst, (ut8 *)&d2, 2);
 					break;
 				case 4:
 					d3 = r_read_ble32 (tmp, bigendian);
 					r = r_buf_write (dst, (ut8 *)&d3, 4);
 					break;
 				case 8:
 					d4 = r_read_ble64 (tmp, bigendian);
 					r = r_buf_write (dst, (ut8 *)&d4, 8);
 					break;
 				}
 				if (r < 0) {
 					return -1;
 				}
 				res += r;
 			}
 
 			m = 1;
 			bigendian = true;
 		}
 	}
 	return res;
 }
 
-R_API int r_buf_fread(RBuffer *b, ut8 *buf, const char *fmt, int n) {
+R_API st64 r_buf_fread(RBuffer *b, ut8 *buf, const char *fmt, int n) {
 	r_return_val_if_fail (b && buf && fmt, -1);
 	// XXX: we assume the caller knows what he's doing
 	RBuffer *dst = r_buf_new_with_pointers (buf, UT64_MAX, false);
-	int res = buf_format (dst, b, fmt, n);
+	st64 res = buf_format (dst, b, fmt, n);
 	r_buf_free (dst);
 	return res;
 }
 
-R_API int r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {
+R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {
 	r_return_val_if_fail (b && buf && fmt, -1);
 	int r = r_buf_seek (b, addr, R_BUF_SET);
 	if (r < 0) {
 		return r;
 	}
 	return r_buf_fread (b, buf, fmt, n);
 }
 
-R_API int r_buf_fwrite(RBuffer *b, const ut8 *buf, const char *fmt, int n) {
+R_API st64 r_buf_fwrite(RBuffer *b, const ut8 *buf, const char *fmt, int n) {
 	r_return_val_if_fail (b && buf && fmt && !b->readonly, -1);
 	// XXX: we assume the caller knows what he's doing
 	RBuffer *src = r_buf_new_with_pointers (buf, UT64_MAX, false);
-	int res = buf_format (b, src, fmt, n);
+	st64 res = buf_format (b, src, fmt, n);
 	r_buf_free (src);
 	return res;
 }
 
-R_API int r_buf_fwrite_at(RBuffer *b, ut64 addr, const ut8 *buf, const char *fmt, int n) {
+R_API st64 r_buf_fwrite_at(RBuffer *b, ut64 addr, const ut8 *buf, const char *fmt, int n) {
 	r_return_val_if_fail (b && buf && fmt && !b->readonly, -1);
-	int r = r_buf_seek (b, addr, R_BUF_SET);
+	st64 r = r_buf_seek (b, addr, R_BUF_SET);
 	if (r < 0) {
 		return r;
 	}
 	return r_buf_fwrite (b, buf, fmt, n);
 }
 
-R_API int r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, int len) {
+R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {
 	r_return_val_if_fail (b && buf, -1);
-	int r = r_buf_seek (b, addr, R_BUF_SET);
+	st64 r = r_buf_seek (b, addr, R_BUF_SET);
 	if (r < 0) {
 		return r;
 	}
 
 	return r_buf_read (b, buf, len);
 }
 
-R_API int r_buf_write_at(RBuffer *b, ut64 addr, const ut8 *buf, int len) {
+R_API st64 r_buf_write_at(RBuffer *b, ut64 addr, const ut8 *buf, ut64 len) {
 	r_return_val_if_fail (b && buf && !b->readonly, -1);
-	int r = r_buf_seek (b, addr, R_BUF_SET);
+	st64 r = r_buf_seek (b, addr, R_BUF_SET);
 	if (r < 0) {
 		return r;
 	}
 
 	return r_buf_write (b, buf, len);
 }
@@ -604,7 +605,7 @@ R_API void r_buf_free(RBuffer *b) {
 	}
 }
 
-R_API int r_buf_append_string(RBuffer *b, const char *str) {
+R_API st64 r_buf_append_string(RBuffer *b, const char *str) {
 	r_return_val_if_fail (b && str && !b->readonly, false);
 	return r_buf_append_bytes (b, (const ut8 *)str, strlen (str));
 }
@@ -625,46 +626,45 @@ R_API RList *r_buf_nonempty_list(RBuffer *b) {
 	return b->methods->nonempty_list? b->methods->nonempty_list (b): NULL;
 }
 
-R_API int r_buf_uleb128(RBuffer *b, ut64 *v) {
+R_API st64 r_buf_uleb128(RBuffer *b, ut64 *v) {
 	ut8 c = 0xff;
 	ut64 s = 0, sum = 0, l = 0;
 	do {
 		ut8 data;
-		int r = r_buf_read (b, &data, sizeof (data));
+		st64 r = r_buf_read (b, &data, sizeof (data));
 		if (r <= 0) {
 			return -1;
 		}
 		c = data & 0xff;
 		sum |= ((ut64) (c & 0x7f) << s);
 		s += 7;
 		l++;
 	} while (c & 0x80);
 	if (v) {
 		*v = sum;
 	}
 	return l;
 }
 
-R_API int r_buf_sleb128(RBuffer *b, st64 *v) {
-	st64 result = 0;
-	int offset = 0;
+R_API st64 r_buf_sleb128(RBuffer *b, st64 *v) {
+	st64 result = 0, offset = 0;
 	ut8 value;
 	do {
 		st64 chunk;
-		int r = r_buf_read (b, &value, sizeof (value));
+		st64 r = r_buf_read (b, &value, sizeof (value));
 		if (r != sizeof (value)) {
 			return -1;
 		}
 		chunk = value & 0x7f;
 		result |= (chunk << offset);
 		offset += 7;
 	} while (value & 0x80);
 
 	if ((value & 0x40) != 0) {
 		result |= ~0ULL << offset;
 	}
 	if (v) {
 		*v = result;
 	}
 	return offset / 7;
 }
diff --git a/libr/util/buf_bytes.c b/libr/util/buf_bytes.c
index 33f6160d41..7b26b5d874 100644
--- a/libr/util/buf_bytes.c
+++ b/libr/util/buf_bytes.c
@@ -70,23 +70,23 @@ static bool buf_bytes_resize(RBuffer *b, ut64 newsize) {
 	return true;
 }
 
-static int buf_bytes_read(RBuffer *b, ut8 *buf, size_t len) {
+static st64 buf_bytes_read(RBuffer *b, ut8 *buf, ut64 len) {
 	struct buf_bytes_priv *priv = get_priv_bytes (b);
-	size_t real_len = priv->length < priv->offset? 0: R_MIN (priv->length - priv->offset, len);
+	ut64 real_len = priv->length < priv->offset? 0: R_MIN (priv->length - priv->offset, len);
 	memmove (buf, priv->buf + priv->offset, real_len);
 	priv->offset += real_len;
 	return real_len;
 }
 
-static int buf_bytes_write(RBuffer *b, const ut8 *buf, size_t len) {
+static st64 buf_bytes_write(RBuffer *b, const ut8 *buf, ut64 len) {
 	struct buf_bytes_priv *priv = get_priv_bytes (b);
 	if (priv->offset > priv->length || priv->offset + len >= priv->length) {
 		bool r = r_buf_resize (b, priv->offset + len);
 		if (!r) {
 			return -1;
 		}
 	}
 	memmove (priv->buf + priv->offset, buf, len);
 	priv->offset += len;
 	return len;
 }
@@ -96,25 +96,25 @@ static ut64 buf_bytes_get_size(RBuffer *b) {
 	return priv->length;
 }
 
-static int buf_bytes_seek(RBuffer *b, st64 addr, int whence) {
+static st64 buf_bytes_seek(RBuffer *b, st64 addr, int whence) {
 	struct buf_bytes_priv *priv = get_priv_bytes (b);
 	if (addr < 0 && (-addr) > (st64)priv->offset) {
 		return -1;
 	}
 
 	switch (whence) {
 	case R_BUF_CUR:
 		priv->offset += addr;
 		break;
 	case R_BUF_SET:
 		priv->offset = addr;
 		break;
 	case R_BUF_END:
 		priv->offset = priv->length + addr;
 		break;
 	default:
 		r_warn_if_reached ();
 		return -1;
 	}
 	return priv->offset;
 }
diff --git a/libr/util/buf_file.c b/libr/util/buf_file.c
index 5983e96c1e..caf4836615 100644
--- a/libr/util/buf_file.c
+++ b/libr/util/buf_file.c
@@ -49,22 +49,22 @@ static ut64 buf_file_get_size(RBuffer *b) {
 	return (ut64)res;
 }
 
-static int buf_file_read(RBuffer *b, ut8 *buf, size_t len) {
+static st64 buf_file_read(RBuffer *b, ut8 *buf, ut64 len) {
 	struct buf_file_priv *priv = get_priv_file (b);
 	return r_sandbox_read (priv->fd, buf, len);
 }
 
-static int buf_file_write(RBuffer *b, const ut8 *buf, size_t len) {
+static st64 buf_file_write(RBuffer *b, const ut8 *buf, ut64 len) {
 	struct buf_file_priv *priv = get_priv_file (b);
 	return r_sandbox_write (priv->fd, buf, len);
 }
 
-static int buf_file_seek(RBuffer *b, st64 addr, int whence) {
+static st64 buf_file_seek(RBuffer *b, st64 addr, int whence) {
 	struct buf_file_priv *priv = get_priv_file (b);
 	switch (whence) {
 	case R_BUF_CUR: whence = SEEK_CUR; break;
 	case R_BUF_SET: whence = SEEK_SET; break;
 	case R_BUF_END: whence = SEEK_END; break;
 	}
 	return r_sandbox_lseek (priv->fd, addr, whence);
 }
diff --git a/libr/util/buf_io.c b/libr/util/buf_io.c
index 5e5fad5fca..55daf998c9 100644
--- a/libr/util/buf_io.c
+++ b/libr/util/buf_io.c
@@ -35,22 +35,22 @@ static bool buf_io_fini(RBuffer *b) {
 	return true;
 }
 
-static int buf_io_seek(RBuffer *b, st64 addr, int whence) {
+static st64 buf_io_seek(RBuffer *b, st64 addr, int whence) {
 	struct buf_io_priv *priv = get_priv_io (b);
 	int io_whence;
 
 	switch (whence) {
 	default:
 		r_warn_if_reached ();
 	case R_BUF_SET:
 		io_whence = R_IO_SEEK_SET;
 		break;
 	case R_BUF_END:
 		io_whence = R_IO_SEEK_END;
 		break;
 	case R_BUF_CUR:
 		io_whence = R_IO_SEEK_CUR;
 		break;
 	}
 	return priv->iob->fd_seek (priv->iob->io, priv->fd, addr, io_whence);
 }
@@ -65,12 +65,12 @@ static bool buf_io_resize(RBuffer *b, ut64 newsize) {
 	return priv->iob->fd_resize (priv->iob->io, priv->fd, newsize);
 }
 
-static int buf_io_read(RBuffer *b, ut8 *buf, size_t len) {
+static st64 buf_io_read(RBuffer *b, ut8 *buf, ut64 len) {
 	struct buf_io_priv *priv = get_priv_io (b);
 	return priv->iob->fd_read (priv->iob->io, priv->fd, buf, len);
 }
 
-static int buf_io_write(RBuffer *b, const ut8 *buf, size_t len) {
+static st64 buf_io_write(RBuffer *b, const ut8 *buf, ut64 len) {
 	struct buf_io_priv *priv = get_priv_io (b);
 	return priv->iob->fd_write (priv->iob->io, priv->fd, buf, len);
 }
diff --git a/libr/util/buf_ref.c b/libr/util/buf_ref.c
index 3457438391..8ee825a9b2 100644
--- a/libr/util/buf_ref.c
+++ b/libr/util/buf_ref.c
@@ -50,16 +50,16 @@ static bool buf_ref_resize(RBuffer *b, ut64 newsize) {
 	return true;
 }
 
-static int buf_ref_read(RBuffer *b, ut8 *buf, size_t len) {
+static st64 buf_ref_read(RBuffer *b, ut8 *buf, ut64 len) {
 	struct buf_ref_priv *priv = get_priv_ref (b);
 	if (priv->size < priv->cur) {
 		return -1;
 	}
 	len = R_MIN (len, priv->size - priv->cur);
-	int r = r_buf_read_at (priv->parent, priv->base + priv->cur, buf, len);
+	st64 r = r_buf_read_at (priv->parent, priv->base + priv->cur, buf, len);
 	if (r < 0) {
 		return r;
 	}
 	priv->cur += r;
 	return r;
 }
@@ -69,21 +69,21 @@ static ut64 buf_ref_get_size(RBuffer *b) {
 	return priv->size;
 }
 
-static int buf_ref_seek(RBuffer *b, st64 addr, int whence) {
+static st64 buf_ref_seek(RBuffer *b, st64 addr, int whence) {
 	struct buf_ref_priv *priv = get_priv_ref (b);
 	switch (whence) {
 	case R_BUF_CUR:
 		priv->cur += addr;
 		break;
 	case R_BUF_SET:
 		priv->cur = addr;
 		break;
 	case R_BUF_END:
 		priv->cur = priv->size + addr;
 		break;
 	default:
 		r_warn_if_reached ();
 		return -1;
 	}
 	return priv->cur;
 }
diff --git a/libr/util/buf_sparse.c b/libr/util/buf_sparse.c
index 842eff7a18..cdadea0942 100644
--- a/libr/util/buf_sparse.c
+++ b/libr/util/buf_sparse.c
@@ -31,45 +31,45 @@ static bool sparse_limits(RList *l, ut64 *max) {
 	return set;
 }
 
-static RBufferSparse *sparse_append(RList *l, ut64 addr, const ut8 *data, int len) {
-	if (l && data && len > 0) {
+static RBufferSparse *sparse_append(RList *l, ut64 addr, const ut8 *data, ut64 len) {
+	if (l && data) {
 		RBufferSparse *s = R_NEW0 (RBufferSparse);
 		if (s) {
 			s->data = calloc (1, len);
 			if (s->data) {
 				s->from = addr;
 				s->to = addr + len;
 				s->size = len;
 				memcpy (s->data, data, len);
 				return r_list_append (l, s)? s: NULL;
 			}
 			free (s);
 		}
 	}
 	return NULL;
 }
 
 //ret -1 if failed; # of bytes copied if success
-static int sparse_write(RList *l, ut64 addr, const ut8 *data, int len) {
+static st64 sparse_write(RList *l, ut64 addr, const ut8 *data, ut64 len) {
 	RBufferSparse *s;
 	RListIter *iter;
-	int olen = len;
+	ut64 olen = len;
 
 	r_list_foreach (l, iter, s) {
 		if (addr >= s->from && addr < s->to) {
-			int delta = addr - s->from;
-			int reallen = s->size - delta >= len? len: s->size - delta;
+			ut64 delta = addr - s->from;
+			ut64 reallen = s->size - delta >= len? len: s->size - delta;
 			memcpy (s->data + delta, data, reallen);
 			data += reallen;
 			len -= reallen;
 			addr += reallen;
 		}
 		if (len == 0) {
 			return olen;
 		}
 	}
 	if (len > 0 && !sparse_append (l, addr, data, len)) {
 		return -1;
 	}
 	return olen;
 }
@@ -139,65 +139,65 @@ static ut64 buf_sparse_size(RBuffer *b) {
 	return sparse_limits (priv->sparse, &max)? max: 0;
 }
 
-static int buf_sparse_read(RBuffer *b, ut8 *buf, size_t len) {
+static st64 buf_sparse_read(RBuffer *b, ut8 *buf, ut64 len) {
 	struct buf_sparse_priv *priv = get_priv_sparse (b);
 	RBufferSparse *c;
 	RListIter *iter;
 	ut64 max = 0;
 
 	memset (buf, b->Oxff_priv, len);
 	r_list_foreach (priv->sparse, iter, c) {
 		if (max < c->to) {
 			max = c->to;
 		}
 		if (priv->offset < c->to && c->from < priv->offset + len) {
 			if (priv->offset < c->from) {
-				int l = R_MIN (priv->offset + len - c->from, c->size);
+				ut64 l = R_MIN (priv->offset + len - c->from, c->size);
 				memcpy (buf + c->from - priv->offset, c->data, l);
 			} else {
-				int l = R_MIN (c->to - priv->offset, len);
+				ut64 l = R_MIN (c->to - priv->offset, len);
 				memcpy (buf, c->data + priv->offset - c->from, l);
 			}
 		}
 	}
 	if (priv->offset > max) {
 		return -1;
 	}
-	int r = R_MIN (max - priv->offset, len);
+	ut64 r = R_MIN (max - priv->offset, len);
 	priv->offset += r;
 	return r;
 }
 
-static int buf_sparse_write(RBuffer *b, const ut8 *buf, size_t len) {
+static st64 buf_sparse_write(RBuffer *b, const ut8 *buf, ut64 len) {
 	struct buf_sparse_priv *priv = get_priv_sparse (b);
-	int r = sparse_write (priv->sparse, priv->offset, buf, len);
+	st64 r = sparse_write (priv->sparse, priv->offset, buf, len);
 	priv->offset += r;
 	return r;
 }
 
-static int buf_sparse_seek(RBuffer *b, st64 addr, int whence) {
+static st64 buf_sparse_seek(RBuffer *b, st64 addr, int whence) {
 	struct buf_sparse_priv *priv = get_priv_sparse (b);
 	ut64 max;
 	if (addr < 0 && (-addr) > (st64)priv->offset) {
 		return -1;
 	}
 
 	switch (whence) {
 	case R_BUF_CUR:
 		priv->offset += addr;
 		break;
 	case R_BUF_SET:
 		priv->offset = addr;
 		break;
 	case R_BUF_END:
 		if (!sparse_limits (priv->sparse, &max)) {
 			max = 0;
 		}
 		priv->offset = max + addr;
 		break;
 	default:
 		r_warn_if_reached ();
 		return -1;
 	}
 	return priv->offset;
 }
