commit 1d54ce2b6f47b9d60bfd28ad0d33a883be3d510a
Author: Thomas Knudsen <thokn@sdfe.dk>
Date:   Sun Nov 12 14:27:26 2017 +0100

    Poder autochecking again (WIP) (#652)
    
    * Poder dual autochecking implementation
    * Debugging aid: Improvements in PJ_vgridshift.c and gie.c
    
    * Most likely, the bugbeing tripped is in the gridshift code, so. uncomment suspicious lines in deformation.gie and merge this to support the debugging effort

diff --git a/src/PJ_cart.c b/src/PJ_cart.c
index 52237f24..e2768c55 100644
--- a/src/PJ_cart.c
+++ b/src/PJ_cart.c
@@ -225,407 +225,409 @@ int pj_cart_selftest (void) {return 0;}
 #else
 /* Testing quite a bit of the pj_obs_api as a side effect (inspired by pj_obs_api_test.c) */
 int pj_cart_selftest (void) {
     PJ_CONTEXT *ctx;
     PJ *P;
     PJ_COORD a, b, obs[2];
     PJ_COORD coord[2];
 
     PJ_INFO info;
     PJ_PROJ_INFO pj_info;
     PJ_GRID_INFO grid_info;
     PJ_INIT_INFO init_info;
 
     PJ_DERIVS derivs;
     PJ_FACTORS factors;
 
     const PJ_OPERATIONS *oper_list;
     const PJ_ELLPS *ellps_list;
     const PJ_UNITS *unit_list;
     const PJ_PRIME_MERIDIANS *pm_list;
 
     int err;
     size_t n, sz;
     double dist, h, t;
     char *args[3] = {"proj=utm", "zone=32", "ellps=GRS80"};
     char *arg = {"+proj=utm +zone=32 +ellps=GRS80"};
     char buf[40];
 
     /* An utm projection on the GRS80 ellipsoid */
     P = proj_create (PJ_DEFAULT_CTX, arg);
     if (0==P)
         return 1;
 
 
     /* Clean up */
     proj_destroy (P);
 
     /* Same projection, now using argc/argv style initialization */
     P = proj_create_argv (PJ_DEFAULT_CTX, 3, args);
     if (0==P)
         return 2;
 
     /* zero initialize everything, then set (longitude, latitude) to (12, 55) */
     a = proj_coord (0,0,0,0);
     /* a.lp: The coordinate part of a, interpreted as a classic LP pair */
     a.lp.lam = PJ_TORAD(12);
     a.lp.phi = PJ_TORAD(55);
 
     /* Forward projection */
     b = proj_trans (P, PJ_FWD, a);
 
     /* Inverse projection */
     a = proj_trans (P, PJ_INV, b);
 
     /* Null projection */
     a = proj_trans (P, PJ_IDENT, a);
 
     /* Forward again, to get two linear items for comparison */
     a = proj_trans (P, PJ_FWD, a);
 
     dist = proj_xy_dist (a.xy, b.xy);
     if (dist > 2e-9)
         return 3;
 
     /* Clear any previous error */
     proj_errno_set (P, 0);
 
     /* Invalid projection */
     a = proj_trans (P, 42, a);
     if (a.lpz.lam!=HUGE_VAL)
         return 4;
     err = proj_errno (P);
     if (0==err)
         return 5;
 
     /* Clear error again */
     proj_errno_set (P, 0);
 
     /* Clean up */
     proj_destroy (P);
 
     /* Now do some 3D transformations */
     P = proj_create (PJ_DEFAULT_CTX, "+proj=cart +ellps=GRS80");
     if (0==P)
         return 6;
 
     /* zero initialize everything, then set (longitude, latitude, height) to (12, 55, 100) */
     a = b = proj_coord (0,0,0,0);
     a.lpz.lam = PJ_TORAD(12);
     a.lpz.phi = PJ_TORAD(55);
     a.lpz.z   = 100;
 
     /* Forward projection: 3D-Cartesian-to-Ellipsoidal */
     b = proj_trans (P, PJ_FWD, a);
 
     /* Check roundtrip precision for 10000 iterations each way */
-    dist = proj_roundtrip (P, PJ_FWD, 10000, a);
-    dist = proj_roundtrip (P, PJ_INV, 10000, b);
+    dist = proj_roundtrip (P, PJ_FWD, 10000, &a);
+    dist = proj_roundtrip (P, PJ_INV, 10000, &b);
     if (dist > 2e-9)
         return 7;
 
 
     /* Test at the North Pole */
     a = b = proj_coord (0,0,0,0);
     a.lpz.lam = PJ_TORAD(0);
     a.lpz.phi = PJ_TORAD(90);
     a.lpz.z   = 100;
 
     /* Forward projection: Ellipsoidal-to-3D-Cartesian */
-    dist = proj_roundtrip (P, PJ_FWD, 1, a);
+    dist = proj_roundtrip (P, PJ_FWD, 1, &a);
     if (dist > 1e-12)
         return 8;
 
     /* Test at the South Pole */
     a = b = proj_coord (0,0,0,0);
     a.lpz.lam = PJ_TORAD(0);
     a.lpz.phi = PJ_TORAD(-90);
     a.lpz.z   = 100;
+    b = a;
 
     /* Forward projection: Ellipsoidal-to-3D-Cartesian */
-    dist = proj_roundtrip (P, PJ_FWD, 1, a);
+    dist = proj_roundtrip (P, PJ_FWD, 1, &a);
     if (dist > 1e-12)
         return 9;
 
+
     /* Inverse projection: 3D-Cartesian-to-Ellipsoidal */
     b = proj_trans (P, PJ_INV, b);
 
     /* Move p to another context */
     ctx = proj_context_create ();
     if (ctx==pj_get_default_ctx())
         return 10;
     proj_context_set (P, ctx);
     if (ctx != P->ctx)
         return 11;
     b = proj_trans (P, PJ_FWD, b);
 
     /* Move it back to the default context */
     proj_context_set (P, 0);
     if (pj_get_default_ctx() != P->ctx)
         return 12;
     proj_context_destroy (ctx);
 
     /* We go on with the work - now back on the default context */
     b = proj_trans (P, PJ_INV, b);
     proj_destroy (P);
 
 
     /* Testing proj_trans_generic () */
 
     /* An utm projection on the GRS80 ellipsoid */
     P = proj_create (PJ_DEFAULT_CTX, "+proj=utm +zone=32 +ellps=GRS80");
     if (0==P)
         return 13;
 
     obs[0] = proj_coord (PJ_TORAD(12), PJ_TORAD(55), 45, 0);
     obs[1] = proj_coord (PJ_TORAD(12), PJ_TORAD(56), 50, 0);
     sz = sizeof (PJ_COORD);
 
     /* Forward projection */
     a = proj_trans (P, PJ_FWD, obs[0]);
     b = proj_trans (P, PJ_FWD, obs[1]);
 
     n = proj_trans_generic (
         P, PJ_FWD,
         &(obs[0].lpz.lam), sz, 2,
         &(obs[0].lpz.phi), sz, 2,
         &(obs[0].lpz.z),   sz, 2,
         0,                     sz, 0
     );
     if (2!=n)
         return 14;
     if (a.lpz.lam != obs[0].lpz.lam)  return 15;
     if (a.lpz.phi != obs[0].lpz.phi)  return 16;
     if (a.lpz.z   != obs[0].lpz.z)    return 17;
     if (b.lpz.lam != obs[1].lpz.lam)  return 18;
     if (b.lpz.phi != obs[1].lpz.phi)  return 19;
     if (b.lpz.z   != obs[1].lpz.z)    return 20;
 
     /* now test the case of constant z */
     obs[0] = proj_coord (PJ_TORAD(12), PJ_TORAD(55), 45, 0);
     obs[1] = proj_coord (PJ_TORAD(12), PJ_TORAD(56), 50, 0);
     h = 27;
     t = 33;
     n = proj_trans_generic (
         P, PJ_FWD,
         &(obs[0].lpz.lam), sz, 2,
         &(obs[0].lpz.phi), sz, 2,
         &h,                     0, 1,
         &t,                     0, 1
     );
     if (2!=n)
         return 21;
     if (a.lpz.lam != obs[0].lpz.lam)  return 22;
     if (a.lpz.phi != obs[0].lpz.phi)  return 23;
     if (45            != obs[0].lpz.z)    return 24;
     if (b.lpz.lam != obs[1].lpz.lam)  return 25;
     if (b.lpz.phi != obs[1].lpz.phi)  return 26;
     if (50            != obs[1].lpz.z)    return 27; /* NOTE: unchanged */
     if (50==h) return 28;
 
     /* test proj_trans_array () */
 
     coord[0] = proj_coord (PJ_TORAD(12), PJ_TORAD(55), 45, 0);
     coord[1] = proj_coord (PJ_TORAD(12), PJ_TORAD(56), 50, 0);
     if (proj_trans_array (P, PJ_FWD, 2, coord))
         return 40;
 
     if (a.lpz.lam != coord[0].lpz.lam)  return 41;
     if (a.lpz.phi != coord[0].lpz.phi)  return 42;
     if (a.lpz.z   != coord[0].lpz.z)    return 43;
     if (b.lpz.lam != coord[1].lpz.lam)  return 44;
     if (b.lpz.phi != coord[1].lpz.phi)  return 45;
     if (b.lpz.z   != coord[1].lpz.z)    return 46;
 
     /* Clean up  after proj_trans_* tests */
     proj_destroy (P);
 
     /* test proj_create_crs_to_crs() */
     P = proj_create_crs_to_crs(PJ_DEFAULT_CTX, "epsg:25832", "epsg:25833", NULL);
     if (P==0)
         return 50;
 
     a.xy.x =  700000.0;
     a.xy.y = 6000000.0;
     b.xy.x =  307788.8761171057;
     b.xy.y = 5999669.3036037628;
 
     a = proj_trans(P, PJ_FWD, a);
     if (dist > 1e-7)
         return 51;
     proj_destroy(P);
 
     /* let's make sure that only entries in init-files results in a usable PJ */
     P = proj_create_crs_to_crs(PJ_DEFAULT_CTX, "proj=utm +zone=32 +datum=WGS84", "proj=utm +zone=33 +datum=WGS84", NULL);
     if (P != 0) {
         proj_destroy(P);
         return 52;
     }
     proj_destroy(P);
 
     /* ********************************************************************** */
     /*                          Test info functions                           */
     /* ********************************************************************** */
 
     /* proj_info()                                                            */
     /* this one is difficult to test, since the output changes with the setup */
     info = proj_info();
     if (info.version[0] != '\0' ) {
         char tmpstr[64];
         sprintf(tmpstr, "%d.%d.%d", info.major, info.minor, info.patch);
         if (strcmp(info.version, tmpstr)) return 55;
     }
     if (info.release[0] == '\0')    return 56;
     if (info.searchpath[0] == '\0') return 57;
 
     /* proj_pj_info() */
     P = proj_create(PJ_DEFAULT_CTX, "+proj=august"); /* august has no inverse */
     if (proj_pj_info(P).has_inverse) { proj_destroy(P); return 60; }
     proj_destroy(P);
 
     P = proj_create(PJ_DEFAULT_CTX, arg);
     pj_info = proj_pj_info(P);
     if ( !pj_info.has_inverse )            {  proj_destroy(P); return 61; }
     if ( strcmp(pj_info.definition, arg) ) {  proj_destroy(P); return 62; }
     if ( strcmp(pj_info.id, "utm") )       {  proj_destroy(P); return 63; }
     proj_destroy(P);
 
     /* proj_grid_info() */
     grid_info = proj_grid_info("egm96_15.gtx");
     if ( strlen(grid_info.filename) == 0 )            return 64;
     if ( strcmp(grid_info.gridname, "egm96_15.gtx") ) return 65;
     grid_info = proj_grid_info("nonexistinggrid");
     if ( strlen(grid_info.filename) > 0 )             return 66;
 
     /* proj_init_info() */
     init_info = proj_init_info("unknowninit");
     if ( strlen(init_info.filename) != 0 )  return 67;
 
     init_info = proj_init_info("epsg");
     /* Need to allow for "Unknown" until all commonly distributed EPSG-files comes with a metadata section */
     if ( strcmp(init_info.origin, "EPSG") && strcmp(init_info.origin, "Unknown") )    return 69;
     if ( strcmp(init_info.name, "epsg") )      return 68;
 
 
 
     /* test proj_rtodms() and proj_dmstor() */
     if (strcmp("180dN", proj_rtodms(buf, M_PI, 'N', 'S')))
         return 70;
 
     if (proj_dmstor(&buf[0], NULL) != M_PI)
         return 71;
 
     if (strcmp("114d35'29.612\"S", proj_rtodms(buf, -2.0, 'N', 'S')))
         return 72;
 
     /* we can't expect perfect numerical accuracy so testing with a tolerance */
     if (fabs(-2.0 - proj_dmstor(&buf[0], NULL)) > 1e-7)
         return 73;
 
 
     /* test proj_derivatives_retrieve() and proj_factors_retrieve() */
     P = proj_create(PJ_DEFAULT_CTX, "+proj=merc");
     a = proj_coord (0,0,0,0);
     a.lp.lam = PJ_TORAD(12);
     a.lp.phi = PJ_TORAD(55);
 
     derivs = proj_derivatives(P, a.lp);
     if (proj_errno(P))
         return 80; /* derivs not created correctly */
 
     if ( fabs(derivs.x_l - 1.0)     > 1e-5 )   return 81;
     if ( fabs(derivs.x_p - 0.0)     > 1e-5 )   return 82;
     if ( fabs(derivs.y_l - 0.0)     > 1e-5 )   return 83;
     if ( fabs(derivs.y_p - 1.73959) > 1e-5 )   return 84;
 
 
     factors = proj_factors(P, a.lp);
     if (proj_errno(P))
         return 85; /* factors not created correctly */
 
     /* check a few key characteristics of the Mercator projection */
     if (factors.omega != 0.0)       return 86; /* angular distortion should be 0 */
     if (factors.thetap != M_PI_2)   return 87; /* Meridian/parallel angle should be 90 deg */
     if (factors.conv != 0.0)        return 88; /* meridian convergence should be 0 */
 
 
     proj_destroy(P);
 
     /* Check that proj_list_* functions work by looping through them */
     n = 0;
     for (oper_list = proj_list_operations(); oper_list->id; ++oper_list) n++;
     if (n == 0) return 90;
 
     n = 0;
     for (ellps_list = proj_list_ellps(); ellps_list->id; ++ellps_list) n++;
     if (n == 0) return 91;
 
     n = 0;
     for (unit_list = proj_list_units(); unit_list->id; ++unit_list) n++;
     if (n == 0) return 92;
 
     n = 0;
     for (pm_list = proj_list_prime_meridians(); pm_list->id; ++pm_list) n++;
     if (n == 0) return 93;
 
 
     /* check io-predicates */
 
     /* angular in on fwd, linear out */
     P = proj_create (PJ_DEFAULT_CTX, "+proj=cart +ellps=GRS80");
     if (0==P) return 0;
     if (!proj_angular_input (P, PJ_FWD))  return 100;
     if ( proj_angular_input (P, PJ_INV))  return 101;
     if ( proj_angular_output (P, PJ_FWD)) return 102;
     if (!proj_angular_output (P, PJ_INV)) return 103;
     P->inverted = 1;
     if ( proj_angular_input (P, PJ_FWD))  return 104;
     if (!proj_angular_input (P, PJ_INV))  return 105;
     if (!proj_angular_output (P, PJ_FWD)) return 106;
     if ( proj_angular_output (P, PJ_INV)) return 107;
     proj_destroy(P);
 
     /* angular in and out */
     P = proj_create(PJ_DEFAULT_CTX,
         "+proj=molodensky +a=6378160 +rf=298.25 "
         "+da=-23 +df=-8.120449e-8 +dx=-134 +dy=-48 +dz=149 "
         "+abridged "
     );
     if (0==P) return 0;
     if (!proj_angular_input (P, PJ_FWD))  return 108;
     if (!proj_angular_input (P, PJ_INV))  return 109;
     if (!proj_angular_output (P, PJ_FWD)) return 110;
     if (!proj_angular_output (P, PJ_INV)) return 111;
     P->inverted = 1;
     if (!proj_angular_input (P, PJ_FWD))  return 112;
     if (!proj_angular_input (P, PJ_INV))  return 113;
     if (!proj_angular_output (P, PJ_FWD)) return 114;
     if (!proj_angular_output (P, PJ_INV)) return 115;
     proj_destroy(P);
 
     /* linear in and out */
     P = proj_create(PJ_DEFAULT_CTX,
         " +proj=helmert +ellps=GRS80"
         " +x=0.0127 +y=0.0065 +z=-0.0209 +s=0.00195"
         " +rx=-0.00039 +ry=0.00080 +rz=-0.00114"
         " +dx=-0.0029 +dy=-0.0002 +dz=-0.0006 +ds=0.00001"
         " +drx=-0.00011 +dry=-0.00019 +drz=0.00007"
         " +epoch=1988.0 +transpose"
     );
     if (0==P) return 0;
     if (proj_angular_input (P, PJ_FWD))  return 116;
     if (proj_angular_input (P, PJ_INV))  return 117;
     if (proj_angular_output (P, PJ_FWD)) return 118;
     if (proj_angular_output (P, PJ_INV)) return 119;
     P->inverted = 1;
     if (proj_angular_input (P, PJ_FWD))  return 120;
     if (proj_angular_input (P, PJ_INV))  return 121;
     if (proj_angular_output (P, PJ_FWD)) return 122;
     if (proj_angular_output (P, PJ_INV)) return 123;
     proj_destroy(P);
 
 
     return 0;
 }
 
 
 #endif
diff --git a/src/PJ_hgridshift.c b/src/PJ_hgridshift.c
index 26a2f471..d57af697 100644
--- a/src/PJ_hgridshift.c
+++ b/src/PJ_hgridshift.c
@@ -80,45 +80,46 @@ int pj_hgridshift_selftest (void) {return 0;}
 #else
 int pj_hgridshift_selftest (void) {
     PJ *P;
     PJ_COORD expect, a, b;
     double dist;
 
     /* fail on purpose: +grids parameter is mandatory*/
     P = proj_create(PJ_DEFAULT_CTX, "+proj=hgridshift");
     if (0!=P) {
         proj_destroy (P);
         return 99;
     }
 
     /* fail on purpose: open non-existing grid */
     P = proj_create(PJ_DEFAULT_CTX, "+proj=hgridshift +grids=@nonexistinggrid.gsb,anothernonexistinggrid.gsb");
     if (0!=P) {
         proj_destroy (P);
         return 999;
     }
 
     /* Failure most likely means the grid is missing */
     P = proj_create(PJ_DEFAULT_CTX, "+proj=hgridshift +grids=nzgd2kgrid0005.gsb +ellps=GRS80");
     if (0==P)
         return 10;
 
     a = proj_coord (0,0,0,0);
     a.lpz.lam = PJ_TORAD(173);
     a.lpz.phi = PJ_TORAD(-45);
+    b = a;
 
-    dist = proj_roundtrip (P, PJ_FWD, 1, a);
+    dist = proj_roundtrip (P, PJ_FWD, 1, &b);
     if (dist > 0.00000001) {
         printf("dist: %f\n",dist);
         return 1;
     }
 
     expect.lpz.lam = PJ_TORAD(172.999892181021551);
     expect.lpz.phi = PJ_TORAD(-45.001620431954613);
     b = proj_trans(P, PJ_FWD, a);
     if (proj_xy_dist(expect.xy, b.xy) > 1e-4)
         return 2;
 
     proj_destroy(P);
     return 0;
 }
 #endif
diff --git a/src/PJ_horner.c b/src/PJ_horner.c
index c28e3907..51c271ae 100644
--- a/src/PJ_horner.c
+++ b/src/PJ_horner.c
@@ -519,52 +519,53 @@ char sb_utm32[] = {
 int pj_horner_selftest (void) {
     PJ *P;
     PJ_COORD a, b, c;
     double dist;
 
     /* Real polynonia relating the technical coordinate system TC32 to "System 45 Bornholm" */
     P = proj_create (PJ_DEFAULT_CTX, tc32_utm32);
     if (0==P)
         return 10;
 
     a = b = proj_coord (0,0,0,0);
     a.uv.v = 6125305.4245;
     a.uv.u =  878354.8539;
+    c = a;
 
     /* Check roundtrip precision for 1 iteration each way, starting in forward direction */
-    dist = proj_roundtrip (P, PJ_FWD, 1, a);
+    dist = proj_roundtrip (P, PJ_FWD, 1, &c);
     if (dist > 0.01)
         return 1;
 
     /* The complex polynomial transformation between the "System Storebaelt" and utm32/ed50 */
     P = proj_create (PJ_DEFAULT_CTX, sb_utm32);
     if (0==P)
         return 11;
 
     /* Test value: utm32_ed50(620000, 6130000) = sb_ed50(495136.8544, 6130821.2945) */
     a = b = c = proj_coord (0,0,0,0);
     a.uv.v = 6130821.2945;
     a.uv.u =  495136.8544;
     c.uv.v = 6130000.0000;
     c.uv.u =  620000.0000;
 
     /* Forward projection */
     b = proj_trans (P, PJ_FWD, a);
     dist = proj_xy_dist (b.xy, c.xy);
     if (dist > 0.001)
         return 2;
 
     /* Inverse projection */
     b = proj_trans (P, PJ_INV, c);
     dist = proj_xy_dist (b.xy, a.xy);
     if (dist > 0.001)
         return 3;
 
     /* Check roundtrip precision for 1 iteration each way */
-    dist = proj_roundtrip (P, PJ_FWD, 1, a);
+    dist = proj_roundtrip (P, PJ_FWD, 1, &a);
     if (dist > 0.01)
         return 4;
 
     proj_destroy(P);
     return 0;
 }
 #endif
diff --git a/src/PJ_molodensky.c b/src/PJ_molodensky.c
index a35cabe4..73d0e5c2 100644
--- a/src/PJ_molodensky.c
+++ b/src/PJ_molodensky.c
@@ -318,75 +318,77 @@ int pj_molodensky_selftest (void) {return 0;}
 #else
 int pj_molodensky_selftest (void) {
 
-    PJ_COORD in, res, exp;
+    PJ_COORD in, ni, res, exp;
     PJ *P;
 
     /* Test the abridged Molodensky first. Example from appendix 3 of Deakin (2004). */
     P = proj_create(PJ_DEFAULT_CTX,
         "+proj=molodensky +a=6378160 +rf=298.25 "
         "+da=-23 +df=-8.120449e-8 +dx=-134 +dy=-48 +dz=149 "
         "+abridged "
     );
     if (0==P)
         return 10;
 
     in.lpz.lam = PJ_TORAD(144.9667);
     in.lpz.phi = PJ_TORAD(-37.8);
     in.lpz.z   = 50.0;
 
     exp.lpz.lam = PJ_TORAD(144.968);
     exp.lpz.phi = PJ_TORAD(-37.79848);
     exp.lpz.z   = 46.378;
 
     res = proj_trans(P, PJ_FWD, in);
 
     if (proj_lp_dist(P, res.lp, exp.lp) > 2 ) { /* we don't expect much accurecy here... */
         proj_destroy(P);
         return 11;
     }
 
     /* let's try a roundtrip */
-    if (proj_roundtrip(P, PJ_FWD, 100, in) > 1) {
+    ni = in;
+    if (proj_roundtrip(P, PJ_FWD, 100, &ni) > 1) {
         proj_destroy(P);
         return 12;
     }
 
     if (res.lpz.z - exp.lpz.z > 1e-3) {
         proj_destroy(P);
         return 13;
     }
 
     proj_destroy(P);
 
     /* Test the abridged Molodensky first. Example from appendix 3 of Deaking (2004). */
 
     P = proj_create(PJ_DEFAULT_CTX,
         "+proj=molodensky +a=6378160 +rf=298.25 "
         "+da=-23 +df=-8.120449e-8 +dx=-134 +dy=-48 +dz=149 "
     );
     if (0==P)
         return 20;
 
     res = proj_trans(P, PJ_FWD, in);
 
     if (proj_lp_dist(P, res.lp, exp.lp) > 2 ) { /* we don't expect much accurecy here... */
         proj_destroy(P);
         return 21;
     }
 
     /* let's try a roundtrip */
-    if (proj_roundtrip(P, PJ_FWD, 100, in) > 1) {
+    ni = in;
+    if (proj_roundtrip(P, PJ_FWD, 100, &ni) > 1) {
         proj_destroy(P);
         return 22;
     }
 
     if (res.lpz.z - exp.lpz.z > 1e-3) {
         proj_destroy(P);
         return 23;
     }
 
     proj_destroy(P);
     return 0;
 }
 
 #endif
diff --git a/src/PJ_vgridshift.c b/src/PJ_vgridshift.c
index e3f3cbd3..5ab4a162 100644
--- a/src/PJ_vgridshift.c
+++ b/src/PJ_vgridshift.c
@@ -82,54 +82,57 @@ int pj_vgridshift_selftest (void) {return 0;}
 #else
 int pj_vgridshift_selftest (void) {
     PJ *P;
     PJ_COORD expect, a, b;
     double dist;
     int failures = 0;
 
     /* fail on purpose: +grids parameter is mandatory*/
     P = proj_create(PJ_DEFAULT_CTX, "+proj=vgridshift");
     if (0!=P) {
         proj_destroy (P);
         return 99;
     }
 
     /* fail on purpose: open non-existing grid */
     P = proj_create(PJ_DEFAULT_CTX, "+proj=vgridshift +grids=nonexistinggrid.gtx");
     if (0!=P) {
         proj_destroy (P);
         return 999;
     }
 
     /* Failure most likely means the grid is missing */
     P = proj_create(PJ_DEFAULT_CTX, "+proj=vgridshift +grids=egm96_15.gtx +ellps=GRS80");
     if (0==P)
         return 10;
 
     a = proj_coord(0,0,0,0);
     a.lpz.lam = PJ_TORAD(12.5);
     a.lpz.phi = PJ_TORAD(55.5);
-
-    dist = proj_roundtrip (P, PJ_FWD, 1, a);
+    b = a;
+    dist = proj_roundtrip (P, PJ_FWD, 1, &b);
     if (dist > 0.00000001)
         return 1;
 
     expect = a;
     /* Appears there is a difference between the egm96_15.gtx distributed by OSGeo4W,  */
     /* and the one from http://download.osgeo.org/proj/vdatum/egm96_15/egm96_15.gtx    */
     /* Was: expect.lpz.z   = -36.021305084228515625;  (download.osgeo.org)         */
     /* Was: expect.lpz.z   = -35.880001068115234000;  (OSGeo4W)                    */
     /* This is annoying, but must be handled elsewhere. So for now, we check for both. */
     expect.lpz.z   = -36.021305084228516;
     failures = 0;
     b = proj_trans(P, PJ_FWD, a);
     if (proj_xyz_dist(expect.xyz, b.xyz) > 1e-4)  failures++;
     expect.lpz.z   = -35.880001068115234000;
     if (proj_xyz_dist(expect.xyz, b.xyz) > 1e-4)  failures++;
+    /* manual roundtrip a->b, b<-b, b==a */
+    b = proj_trans(P, PJ_INV, b);
+    if (proj_xyz_dist(a.xyz, b.xyz) > 1e-9)  failures++;
     if (failures > 1)
         return 2;
 
     proj_destroy (P);
 
     return 0;
 }
 #endif
diff --git a/src/gie.c b/src/gie.c
index 7bee8b67..09a33069 100644
--- a/src/gie.c
+++ b/src/gie.c
@@ -377,10 +377,8 @@ static double strtod_scaled (char *args, double default_scale) {
 
 static int banner (char *args) {
     char dots[] = {"..."}, nodots[] = {""}, *thedots = nodots;
-    if (T.total_ko > 0 && T.op_ko==0)
-        printf ("\n\n");
     if (strlen(args) > 70)
         thedots = dots;
     fprintf (T.fout, "%s%-70.70s%s\n", delim, args, thedots);
     return 0;
 }
@@ -507,35 +505,42 @@ static int accept (char *args) {
 /*****************************************************************************/
 static int roundtrip (char *args) {
 /*****************************************************************************
     Check how far we go from the ACCEPTed point when doing successive
     back/forward transformation pairs.
 ******************************************************************************/
     int ntrips;
     double d, r, ans;
     char *endp;
+    PJ_COORD coo;
+
     if (0==T.P)
         return another_failure ();
+
     ans = proj_strtod (args, &endp);
     ntrips = (int) (endp==args? 100: fabs(ans));
     d = strtod_scaled (endp, 1);
     d = d==HUGE_VAL?  T.tolerance:  d;
-    r = proj_roundtrip (T.P, PJ_FWD, ntrips, T.a);
-    if (r > d) {
-        if (T.verbosity > -1) {
-            if (0==T.op_ko && T.verbosity < 2)
-                banner (T.operation);
-            fprintf (T.fout, "%s", T.op_ko? "     -----\n": delim);
-            fprintf (T.fout, "     FAILURE in %s(%d):\n", opt_strip_path (T.curr_file), (int) lineno);
-            fprintf (T.fout, "     roundtrip deviation: %.3f mm, expected: %.3f mm\n", 1000*r, 1000*d);
-        }
-        another_failure ();
-    }
-    else
-        another_success ();
+    coo = T.a;
 
-    return 0;
+    /* input ("accepted") values - probably in degrees */
+    coo = proj_angular_input  (T.P, T.dir)? torad_coord (T.a):  T.a;
+
+    r = proj_roundtrip (T.P, T.dir, ntrips, &coo);
+    if (r <= d)
+        return another_success ();
+
+    if (T.verbosity > -1) {
+        if (0==T.op_ko && T.verbosity < 2)
+            banner (T.operation);
+        fprintf (T.fout, "%s", T.op_ko? "     -----\n": delim);
+        fprintf (T.fout, "     FAILURE in %s(%d):\n", opt_strip_path (T.curr_file), (int) lineno);
+        fprintf (T.fout, "     roundtrip deviation: %.3f mm, expected: %.3f mm\n", 1000*r, 1000*d);
+    }
+    return another_failure ();
 }
 
+
+
 static int expect_message (double d, char *args) {
     another_failure ();
 
@@ -574,53 +579,54 @@ static int expect_message_cannot_parse (char *args) {
 /*****************************************************************************/
 static int expect (char *args) {
 /*****************************************************************************
     Tell GIE what to expect, when transforming the ACCEPTed input
 ******************************************************************************/
     PJ_COORD ci, co, ce;
     double d;
     if (0==T.P)
         return another_failure ();
 
     T.e  =  parse_coord (args);
     if (HUGE_VAL==T.e.v[0])
         return expect_message_cannot_parse (args);
 
     /* expected angular values probably in degrees */
     ce = proj_angular_output (T.P, T.dir)? torad_coord (T.e): T.e;
 
     /* input ("accepted") values also probably in degrees */
-    ci = proj_angular_input  (T.P, T.dir)? torad_coord (T.a): T.a;
+    ci = proj_angular_input (T.P, T.dir)? torad_coord (T.a): T.a;
 
     /* angular output from proj_trans comes in radians */
     co = proj_trans (T.P, T.dir, ci);
     T.b = proj_angular_output (T.P, T.dir)? todeg_coord (co): co;
 
     /* but there are a few more possible input conventions... */
     if (proj_angular_output (T.P, T.dir)) {
         double e = HUGE_VAL;
-        d = hypot (proj_lp_dist (T.P, ce.lp, co.lp), ce.lpz.z - co.lpz.z);
+        d = proj_lpz_dist (T.P, ce.lpz, co.lpz);
         /* check whether input was already in radians */
         if (d > T.tolerance)
-            e = hypot (proj_lp_dist (T.P, T.e.lp, co.lp), T.e.lpz.z - co.lpz.z);
+            e = proj_lpz_dist (T.P, T.e.lpz, co.lpz);
         if (e < d)
             d = e;
+
         /* or the tolerance may be based on euclidean distance */
         if (d > T.tolerance)
             e = proj_xyz_dist (T.b.xyz, T.e.xyz);
         if (e < d)
             d = e;
+
     }
     else
         d = proj_xyz_dist (T.b.xyz, T.e.xyz);
-
     if (d > T.tolerance)
         return expect_message (d, args);
 
     another_success ();
 
     return 0;
 }
 
 
 
 /*****************************************************************************/
@@ -663,31 +669,38 @@ fprintf (T.fout, "%s\n", args);
 
 
 static int dispatch (char *cmnd, char *args) {
+    int last_errno = proj_errno_reset (T.P);
+
     if  (0==level%2) {
         if (0==strcmp (cmnd, "BEGIN"))
            level++;
         return 0;
     }
+
     if  (0==strcmp (cmnd, "OPERATION")) return  operation (args);
     if  (0==strcmp (cmnd, "operation")) return  operation (args);
     if  (0==strcmp (cmnd, "ACCEPT"))    return  accept    (args);
     if  (0==strcmp (cmnd, "accept"))    return  accept    (args);
     if  (0==strcmp (cmnd, "EXPECT"))    return  expect    (args);
     if  (0==strcmp (cmnd, "expect"))    return  expect    (args);
     if  (0==strcmp (cmnd, "ROUNDTRIP")) return  roundtrip (args);
     if  (0==strcmp (cmnd, "roundtrip")) return  roundtrip (args);
     if  (0==strcmp (cmnd, "BANNER"))    return  banner    (args);
     if  (0==strcmp (cmnd, "banner"))    return  banner    (args);
     if  (0==strcmp (cmnd, "VERBOSE"))   return  verbose   (args);
     if  (0==strcmp (cmnd, "verbose"))   return  verbose   (args);
     if  (0==strcmp (cmnd, "DIRECTION")) return  direction (args);
     if  (0==strcmp (cmnd, "direction")) return  direction (args);
     if  (0==strcmp (cmnd, "TOLERANCE")) return  tolerance (args);
     if  (0==strcmp (cmnd, "tolerance")) return  tolerance (args);
     if  (0==strcmp (cmnd, "ECHO"))      return  echo      (args);
     if  (0==strcmp (cmnd, "echo"))      return  echo      (args);
     if  (0==strcmp  (cmnd, "END"))      return          finish_previous_operation (args), level++, 0;
     if  ('#'==cmnd[0])                  return  comment   (args);
+
+    if (proj_errno(T.P))
+        printf ("#####***** ERRNO=%d\n", proj_errno(T.P));
+    proj_errno_restore (T.P, last_errno);
     return 0;
 }
 
diff --git a/src/proj.def b/src/proj.def
index 8b1882ee..cc1793e1 100644
--- a/src/proj.def
+++ b/src/proj.def
@@ -2,147 +2,148 @@ VERSION   1.2
 EXPORTS
     pj_init                         @1
     pj_fwd                          @2
     pj_inv                          @3
     pj_free                         @4
     pj_transform                    @5
     pj_geocentric_to_geodetic       @6
     pj_geodetic_to_geocentric       @7
     pj_deallocate_grids             @8
     pj_init_plus                    @9
     pj_latlong_from_proj            @10
     pj_is_latlong                   @11
     pj_get_errno_ref                @12
     pj_set_finder                   @13
     pj_strerrno                     @14
     pj_errno                        @15
     pj_get_def                      @16
     pj_dalloc                       @17
     pj_is_geocent                   @18
     pj_get_release                  @19
     pj_malloc                       @20
     pj_pr_list                      @21
     pj_compare_datums               @22
     pj_apply_gridshift              @23
     pj_datum_transform              @24
     pj_set_searchpath               @25
     dmstor                          @26
     pj_get_ellps_ref                @27
     pj_get_datums_ref               @28
     pj_get_units_ref                @29
     pj_get_list_ref                 @30
     pj_get_prime_meridians_ref      @31
     rtodms                          @32
     set_rtodms                      @33
     pj_factors                      @34
     mk_cheby                        @35
     adjlon                          @36
     pj_param                        @37
     pj_ell_set                      @38
     pj_mkparam                      @39
     pj_init_ctx                     @40
     pj_init_plus_ctx                @41
     pj_get_default_ctx              @42
     pj_get_ctx                      @43
     pj_set_ctx                      @44
     pj_ctx_alloc                    @45
     pj_ctx_free                     @46
     pj_ctx_get_errno                @47
     pj_ctx_set_errno                @48
     pj_ctx_set_debug                @49
     pj_ctx_set_logger               @50
     pj_ctx_set_app_data             @51
     pj_ctx_get_app_data             @52
     pj_log                          @53
     pj_clear_initcache              @54
     geod_init                       @55
     geod_lineinit                   @56
     geod_genposition                @57
     geod_position                   @58
     geod_gendirect                  @59
     geod_direct                     @60
     geod_geninverse                 @61
     geod_inverse                    @62
     geod_polygonarea                @63
     pj_get_spheroid_defn            @64
     pj_get_default_fileapi          @65
     pj_ctx_set_fileapi              @66
     pj_ctx_get_fileapi              @67
     pj_ctx_fopen                    @68
     pj_ctx_fread                    @69
     pj_ctx_ftell                    @70
     pj_ctx_fclose                   @71
     pj_open_lib                     @72
     pj_atof                         @73
     pj_strtod                       @74
     pj_fwd3d                        @75
     pj_inv3d                        @76
     geod_gensetdistance             @77
     geod_setdistance                @78
     geod_gendirectline              @79
     geod_directline                 @80
     geod_inverseline                @81
     geod_polygon_init               @82
     geod_polygon_addedge            @83
     geod_polygon_addpoint           @84
     geod_polygon_compute            @85
     geod_polygon_testedge           @86
     geod_polygon_testpoint          @87
     geod_polygon_clear              @88
     pj_run_selftests                @89
 
     pj_find_file                    @90
 
     proj_create                     @91
     proj_create_argv                @92
     proj_create_crs_to_crs          @93
     proj_destroy                    @94
 
     proj_trans                      @95
     proj_trans_array                @96
     proj_trans_generic              @97
     proj_roundtrip                  @98
 
     proj_coord                      @99
     proj_coord_error               @100
 
     proj_errno                     @101
     proj_errno_set                 @102
     proj_errno_reset               @103
     proj_errno_restore             @104
     proj_context_errno_set         @105
 
     proj_context_create            @106
     proj_context_set               @107
     proj_context_inherit           @108
     proj_context_destroy           @109
 
     proj_lp_dist                   @110
-    proj_xy_dist                   @111
-    proj_xyz_dist                  @112
+    proj_lpz_dist                  @111
+    proj_xy_dist                   @112
+    proj_xyz_dist                  @113
 
-    proj_log_level                 @113
-    proj_log_func                  @114
-    proj_log_error                 @115
-    proj_log_debug                 @116
-    proj_log_trace                 @117
+    proj_log_level                 @114
+    proj_log_func                  @115
+    proj_log_error                 @116
+    proj_log_debug                 @117
+    proj_log_trace                 @118
 
-    proj_info                      @118
-    proj_pj_info                   @119
-    proj_grid_info                 @120
-    proj_init_info                 @121
+    proj_info                      @119
+    proj_pj_info                   @120
+    proj_grid_info                 @121
+    proj_init_info                 @122
 
-    proj_torad                     @122
-    proj_todeg                     @123
-    proj_rtodms                    @124
-    proj_dmstor                    @125
+    proj_torad                     @123
+    proj_todeg                     @124
+    proj_rtodms                    @125
+    proj_dmstor                    @126
 
-    proj_derivatives               @126
-    proj_factors                   @127
+    proj_derivatives               @127
+    proj_factors                   @128
 
-    proj_list_operations           @128
-    proj_list_ellps                @129
-    proj_list_units                @130
-    proj_list_prime_meridians      @131
+    proj_list_operations           @129
+    proj_list_ellps                @130
+    proj_list_units                @131
+    proj_list_prime_meridians      @132
 
-    proj_angular_input             @132
-    proj_angular_output            @133
+    proj_angular_input             @133
+    proj_angular_output            @134
diff --git a/src/proj.h b/src/proj.h
index bc0e1e06..19bb2192 100644
--- a/src/proj.h
+++ b/src/proj.h
@@ -393,11 +393,14 @@ int proj_trans_array (PJ *P, PJ_DIRECTION direction, size_t n, PJ_COORD *coord);
 PJ_COORD proj_coord (double x, double y, double z, double t);
 
 /* Measure internal consistency - in forward or inverse direction */
-double proj_roundtrip (PJ *P, PJ_DIRECTION direction, int n, PJ_COORD coo);
+double proj_roundtrip (PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coo);
 
 /* Geodesic distance between two points with angular 2D coordinates */
 double proj_lp_dist (const PJ *P, LP a, LP b);
 
+/* The geodesic distance AND the vertical offset */
+double proj_lpz_dist (const PJ *P, LPZ a, LPZ b);
+
 /* Euclidean distance between two points with linear 2D coordinates */
 double proj_xy_dist (XY a, XY b);
 
diff --git a/src/proj_4D_api.c b/src/proj_4D_api.c
index 66a272f2..ee4cb20f 100644
--- a/src/proj_4D_api.c
+++ b/src/proj_4D_api.c
@@ -71,11 +71,19 @@ int proj_angular_output (PJ *P, enum PJ_DIRECTION dir) {
 /* Geodesic distance (in meter) between two points with angular 2D coordinates */
 double proj_lp_dist (const PJ *P, LP a, LP b) {
     double s12, azi1, azi2;
     /* Note: the geodesic code takes arguments in degrees */
     geod_inverse (P->geod, PJ_TODEG(a.phi), PJ_TODEG(a.lam), PJ_TODEG(b.phi), PJ_TODEG(b.lam), &s12, &azi1, &azi2);
     return s12;
 }
 
+/* The geodesic distance AND the vertical offset */
+double proj_lpz_dist (const PJ *P, LPZ a, LPZ b) {
+    PJ_COORD aa, bb;
+    aa.lpz = a;
+    bb.lpz = b;
+    return hypot (proj_lp_dist (P, aa.lp, bb.lp), a.z - b.z);
+}
+
 /* Euclidean distance between two points with linear 2D coordinates */
 double proj_xy_dist (XY a, XY b) {
     return hypot (a.x - b.x, a.y - b.y);
@@ -89,46 +97,40 @@ double proj_xyz_dist (XYZ a, XYZ b) {
 
 
 /* Measure numerical deviation after n roundtrips fwd-inv (or inv-fwd) */
-double proj_roundtrip (PJ *P, PJ_DIRECTION direction, int n, PJ_COORD coo) {
+double proj_roundtrip (PJ *P, PJ_DIRECTION direction, int n, PJ_COORD *coo) {
     int i;
-    PJ_COORD o, u;
+    PJ_COORD o, u, org;
 
     if (0==P)
         return HUGE_VAL;
 
     if (n < 1) {
         proj_errno_set (P, EINVAL);
         return HUGE_VAL;
     }
 
-    o = coo;
+    /* in the first half-step, we generate the output value */
+    u = org = *coo;
+    o = *coo = proj_trans (P, direction, u);
 
-    switch (direction) {
-        case PJ_FWD:
-            for (i = 0;  i < n;  i++) {
-                u  =  pj_fwd4d (o, P);
-                o  =  pj_inv4d (u, P);
-            }
-            break;
-        case PJ_INV:
-            for (i = 0;  i < n;  i++) {
-                u  =  pj_inv4d (o, P);
-                o  =  pj_fwd4d (u, P);
-            }
-            break;
-        default:
-            proj_errno_set (P, EINVAL);
-            return HUGE_VAL;
+    /* now we take n-1 full steps */
+    for (i = 0;  i < n - 1;  i++) {
+        u = proj_trans (P, -direction, o);
+        o = proj_trans (P,  direction, u);
     }
 
-    /* checking for angular input since we do a roundtrip, and end where we begin */
+    /* finally, we take the last half-step */
+    u = proj_trans (P, -direction, o);
+
+    /* checking for angular *input* since we do a roundtrip, and end where we begin */
     if (proj_angular_input (P, direction))
-        return hypot (proj_lp_dist (P, coo.lp, o.lp), coo.lpz.z - o.lpz.z);
+        return proj_lpz_dist (P, org.lpz, u.lpz);
 
-    return proj_xyz_dist (coo.xyz, coo.xyz);
+    return proj_xyz_dist (org.xyz, u.xyz);
 }
 
 
+
 /* Apply the transformation P to the coordinate coo */
 PJ_COORD proj_trans (PJ *P, PJ_DIRECTION direction, PJ_COORD coo) {
     if (0==P)
diff --git a/test/gie/axisswap.gie b/test/gie/axisswap.gie
index 2264a056..b9281ef7 100644
--- a/test/gie/axisswap.gie
+++ b/test/gie/axisswap.gie
@@ -63,4 +63,12 @@ TOLERANCE   0.00001 m
 ACCEPT        12 55 0 0
 EXPECT      -55 -12 0 0
 
+-------------------------------------------------------------------------------
+operation +proj=aea   +ellps=GRS80  +lat_1=0 +lat_2=2
+-------------------------------------------------------------------------------
+tolerance 0.00010 mm
+accept  2 1
+expect  222571.608757106 110653.326743030
+ROUNDTRIP   100
+
 END
diff --git a/test/gie/deformation.gie b/test/gie/deformation.gie
index 4173fa31..ce9aca75 100644
--- a/test/gie/deformation.gie
+++ b/test/gie/deformation.gie
@@ -1,4 +1,3 @@
-BEGIN
 ===============================================================================
 Test for the deformation operation - Kinematic Gridshifting
 
@@ -9,27 +8,28 @@ and for testing purposes it doesn't really matter all that much...
 The input coordinate is located at lon=60, lam=-160 - somewhere in Alaska.
 
 ===============================================================================
 
+BEGIN
 
 -------------------------------------------------------------------------------
 Test using only horizontal grid and +tobs parameter
 -------------------------------------------------------------------------------
 OPERATION   +proj=deformation +xy_grids=alaska +t_epoch=2016.0 +t_obs=2000.0
 -------------------------------------------------------------------------------
-TOLERANCE   0.000001 m
+TOLERANCE   1 um
 ACCEPT      -3004295.5882503074 -1093474.1690603832 5500477.1338251457
-EXPECT      -3004295.5888766116 -1093474.1688513425 5500477.1338251457
-ROUNDTRIP   1000
+EXPECT    -3004295.5888766116 -1093474.1688513425 5500477.1338251457
+# ROUNDTRIP   1000
 
 -------------------------------------------------------------------------------
 Test using only vertical grid and +tobs parameter
 -------------------------------------------------------------------------------
 OPERATION   +proj=deformation +z_grids=egm96_15.gtx +t_epoch=2016.0 +t_obs=2000.0
 -------------------------------------------------------------------------------
-TOLERANCE   0.000001 m
+TOLERANCE   1 um
 ACCEPT      -3004295.5882503074 -1093474.1690603832 5500477.1338251457
 EXPECT      -3004295.5882503074 -1093474.1690603832 5500234.008855661
-ROUNDTRIP   1000
+# ROUNDTRIP   1000
 
 -------------------------------------------------------------------------------
 Test using both horizontal and vertical grids as well as the +tobs parameter
@@ -39,35 +39,37 @@ OPERATION   +proj=deformation +xy_grids=alaska +z_grids=egm96_15.gtx +t_epoch=20
 TOLERANCE   0.000001 m
 ACCEPT      -3004295.5882503074 -1093474.1690603832 5500477.1338251457
 EXPECT      -3004295.5888766116 -1093474.1688513425 5500234.008855661
-ROUNDTRIP   1000
+# ROUNDTRIP   1000
 
 -------------------------------------------------------------------------------
 Test using only horizontal grid
 -------------------------------------------------------------------------------
 OPERATION   +proj=deformation +xy_grids=alaska +t_epoch=2016.0
 -------------------------------------------------------------------------------
-TOLERANCE   0.000001 m
+TOLERANCE   1 um
 ACCEPT      -3004295.5882503074 -1093474.1690603832 5500477.1338251457 2000.0
 EXPECT      -3004295.5888766116 -1093474.1688513425 5500477.1338251457 2000.0
-ROUNDTRIP   1000
+# ROUNDTRIP   1000
 
 -------------------------------------------------------------------------------
 Test using only vertical grid
 -------------------------------------------------------------------------------
 OPERATION   +proj=deformation +z_grids=egm96_15.gtx +t_epoch=2016.0
 -------------------------------------------------------------------------------
-TOLERANCE   0.000001 m
+TOLERANCE   1 um
 ACCEPT      -3004295.5882503074 -1093474.1690603832 5500477.1338251457 2000.0
 EXPECT      -3004295.5882503074 -1093474.1690603832 5500234.008855661  2000.0
-ROUNDTRIP   1000
+# ROUNDTRIP   1000
 
 -------------------------------------------------------------------------------
 Test using both horizontal and vertical grids
 -------------------------------------------------------------------------------
-OPERATION   proj=deformation xy_grids=alaska z_grids=egm96_15.gtx t_epoch=2016.0
+OPERATION   +proj=deformation +xy_grids=alaska +z_grids=egm96_15.gtx +t_epoch=2016.0 +ellps=GRS80
 -------------------------------------------------------------------------------
-TOLERANCE   0.000001 m
+TOLERANCE   1 um
 ACCEPT      -3004295.5882503074 -1093474.1690603832 5500477.1338251457 2000.0
 EXPECT      -3004295.5888766116 -1093474.1688513425 5500234.008855661  2000.0
-ROUNDTRIP   1000
+# ROUNDTRIP   1000
+
+
 END
