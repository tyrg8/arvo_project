commit dd0e099a4cf51ec01064065778b1d3bfb314f201
Author: Francesc Alted <faltet@gmail.com>
Date:   Sun Feb 7 13:37:26 2021 +0100

    New frame type meta. Unifyied file extensions for frames.

diff --git a/README_CFRAME_FORMAT.rst b/README_CFRAME_FORMAT.rst
index aab0ae58..68adc8cd 100644
--- a/README_CFRAME_FORMAT.rst
+++ b/README_CFRAME_FORMAT.rst
@@ -1,8 +1,8 @@
 Blosc2 Contiguous Frame Format
 ==============================
 
-Blosc (as of version 2.0.0) has a contiguous frame format (cframe for short) that allows for the storage of different Blosc data chunks contiguously,
-either in-memory or on-disk.
+Blosc (as of version 2.0.0) has a contiguous frame format (cframe for short) that allows for the storage of
+different Blosc data chunks contiguously, either in-memory or on-disk.
 
 The frame is composed of a header, a chunks section, and a trailer::
 
@@ -22,38 +22,38 @@ Header
 The header contains information needed to decompress the Blosc chunks contained in the frame. It is encoded using
 `msgpack <https://msgpack.org>`_ and the format is as follows::
 
     |-0-|-1-|-2-|-3-|-4-|-5-|-6-|-7-|-8-|-9-|-A-|-B-|-C-|-D-|-E-|-F-|-10|-11|-12|-13|-14|-15|-16|-17|
     | 9X| aX| "b2frame\0"                   | d2| header_size   | cf| frame_size                    |
     |---|---|-------------------------------|---|---------------|---|-------------------------------|
       ^   ^       ^                           ^                   ^
       |   |       |                           |                   |
       |   |       |                           |                   +--[msgpack] uint64
       |   |       |                           |
       |   |       |                           +--[msgpack] int32
       |   |       +---magic number, currently "b2frame"
       |   +------[msgpack] str with 8 elements
       +---[msgpack] fixarray with X=0xD (13) elements
 
     |-18|-19|-1A|-1B|-1C|-1D|-1E|-1F|-20|-21|-22|-23|-24|-25|-26|-27|-28|-29|-2A|-2B|-2C|-2D|-2E|
     | a4|_f0|_f1|_f2|_f3| d3| uncompressed_size             | d3| compressed_size               |
     |---|---|---|---|---|---|-------------------------------|---|-------------------------------|
       ^   ^   ^   ^   ^   ^                                   ^
       |   |   |   |   |   |                                   +--[msgpack] int64
       |   |   |   |   |   +--[msgpack] int64
       |   |   |   |   +-- reserved flags
       |   |   |   +--codec_flags (see below)
-      |   |   +---reserved flags
+      |   |   +---frame_type (see below)
       |   +------general_flags (see below)
       +---[msgpack] str with 4 elements (flags)
 
     |-2F|-30|-31|-32|-33|-34|-35|-36|-37|-38|-39|-3A|-3B|-3C|-3D|-3E|-3F|
     | d2| type_size     | d2| chunk_size    | d1| tcomp | d1|tdecomp| cX|
     |---|---------------|---|---------------|---|-------|---|-------|---|
       ^                   ^                   ^     ^     ^     ^     ^
       |                   |                   |     |     |     |     +--[msgpack] bool for has_usermeta
       |                   |                   |     |     |     +--number of threads for decompression
       |                   |                   |     |     +-- [msgpack] int16
       |                   |                   |     +--number of threads for compression
       |                   |                   +---[msgpack] int16
       |                   +------[msgpack] int32
       +---[msgpack] int32
@@ -76,84 +76,99 @@ frame. It is up to the user to store whatever data they want with the only (stro
 using the msgpack format. Here is the format for the *metalayers*::
 
   |-52|-53|-54|-55|-56|-----------------------
   | 93| cd| idx   | de| map_of_metalayers
   |---|---------------|-----------------------
     ^   ^    ^      ^
     |   |    |      |
     |   |    |      +--[msgpack] map of name/offset pairs
     |   |    +--size of the map
     |   +--[msgpack] uint16
     +-- [msgpack] fixarray with 3 elements
 
 :header_size:
     (``int32``) Size of the header of the frame (including metalayers).
 
 :frame_size:
     (``uint64``) Size of the whole frame (including compressed data).
 
 :general_flags:
     (``uint8``) General flags.
 
     :``0`` to ``3``:
         Format version.
     :``4`` and ``5``:
         Enumerated for chunk offsets.
 
         :``0``:
             32-bit
         :``1``:
             64-bit
         :``2``:
             128-bit
         :``3``:
             256-bit
     :``6``:
         Chunks of fixed length (0) or variable length (1)
     :``7``:
         Reserved
 
+:frame_type:
+    (``uint8``) The type of frame.
+
+    :``0`` to ``3``:
+        Enumerated for the type of frame (up to 16).
+
+        :``0``:
+            ``Contiguous``
+        :``1``:
+            ``Sparse (directory)``
+        :``2 to 15``:
+            Reserved
+
+    :``4`` to ``7``: Reserved for user-defined frame types (up to 16)
+
 :codec_flags:
     (``uint8``) Compressor enumeration (defaults for all the chunks in storage).
 
     :``0`` to ``3``:
         Enumerated for codecs (up to 16).
 
         :``0``:
             ``blosclz``
         :``1``:
             ``lz4`` or ``lz4hc``
         :``2``:
             ``snappy``
         :``3``:
             ``zlib``
         :``4``:
             ``zstd``
-        :``5``:
+        :``5 to 15``:
             Reserved
     :``4`` to ``7``: Compression level (up to 16)
 
 :reserved_flags:
     (``uint8``) Space reserved.
 
 :uncompressed_size:
     (``int64``) Size of uncompressed data in frame (excluding metadata).
 
 :compressed_size:
     (``int64``) Size of compressed data in frame (excluding metadata).
 
 :type_size:
     (``int32``) Size of each item.
 
 :chunk_size:
     (``int32``) Size of each data chunk.  0 if not a fixed chunksize.
 
 :tcomp:
     (``int16``) Number of threads for compression.  If 0, same than `cctx`.
 
 :tdecomp:
     (``int16``) Number of threads for decompression.  If 0, same than `dctx`.
 
 :map of metalayers:
     This is a *msgpack-formattted* map for the different metalayers.  The keys will be a string (0xa0 + namelen) for
     the names of the metalayers, followed by an int32 (0xd2) for the *offset* of the value of this metalayer.  The
     actual value will be encoded as a bin32 (0xc6) value later in frame.
diff --git a/README_SFRAME_FORMAT.rst b/README_SFRAME_FORMAT.rst
index 2eaedbb6..a102660d 100644
--- a/README_SFRAME_FORMAT.rst
+++ b/README_SFRAME_FORMAT.rst
@@ -3,7 +3,7 @@ Blosc2 Sparse Frame Format
 
 Blosc (as of version 2.0.0) has a sparse frame (sframe for short) format that allows for non-contiguous storage of Blosc data chunks on disk.
 
-When creating an sparse frame one must denote the `storage.contiguous` as false and provide a name (which will be a directory) in `storage.urlpath` for the sframe to be stored. It is recommended to name the directory with the `.b2sframe` extension.
+When creating an sparse frame one must denote the `storage.contiguous` as false and provide a name (which represents a directory, but in the future it could be an arbitrary URL) in `storage.urlpath` for the sframe to be stored. It is recommended to name the directory with the `.b2frame` (or `.b2f` for short) extension.
 
 An sframe is made up of a frame index file and the chunks stored in the same directory on-disk.  The frame file follows the format described in the `contiguous frame format <README_CFRAME_FORMAT.rst>`_ document, with the difference that the frame's chunks section is made up of multiple files (one per chunk). The frame index file name is always `chunks.b2frame`, and it also contains the metadata for the sframe.
 
@@ -25,14 +25,14 @@ Structure example
 ^^^^^^^^^^^^^^^^^
 As shown below, an sframe of 4 chunks will be composed of a directory with each chunk file and the frame file::
 
- dir.b2sframe/
+ dir.b2frame/
  │
  ├── 00000000.chunk
  │
  ├── 00000001.chunk
  │
  ├── 00000002.chunk
  │
  ├── 00000003.chunk
  │
  └── chunks.b2frame
@@ -42,21 +42,21 @@ Insertion example
 ^^^^^^^^^^^^^^^^^
 When doing an insertion in the nth position, in the same position of the index chunk will be the real chunk index which will be the numbers of chunks that there were before inserting the new one. Following the previous example, it its shown the content of the directory and the index chunk before and after an insertion in the 2nd position::
 
  Before                                 After
 
- dir.b2sframe/                          dir.b2sframe/
+ dir.b2frame/                          dir.b2frame/
  │                                      │
  ├── 00000000.chunk                     ├── 00000000.chunk
  │                                      │
  ├── 00000001.chunk                     ├── 00000001.chunk
  │                                      │
  ├── 00000002.chunk                     ├── 00000002.chunk
  │                                      │
  ├── 00000003.chunk                     ├── 00000003.chunk
  │                                      │
  └── chunks.b2frame                     ├── 00000004.chunk
                                         │
                                         └── chunks.b2frame
 
  Possible index                         New index
  chunk content:  [0, 1, 2, 3]           chunk content: [0, 1, 4, 2, 3]
diff --git a/blosc/blosc2.h b/blosc/blosc2.h
index c6d41f6e..ca36722e 100644
--- a/blosc/blosc2.h
+++ b/blosc/blosc2.h
@@ -248,38 +248,39 @@ enum {
 /**
  * @brief Error codes
  */
 enum {
   BLOSC2_ERROR_SUCCESS = 0,           //<! Success
   BLOSC2_ERROR_FAILURE = -1,          //<! Generic failure
   BLOSC2_ERROR_STREAM = 2,            //<! Bad stream
   BLOSC2_ERROR_DATA = -3,             //<! Invalid data
   BLOSC2_ERROR_MEMORY_ALLOC = -4,     //<! Memory alloc/realloc failure
   BLOSC2_ERROR_READ_BUFFER = -5,      //!< Not enough space to read
   BLOSC2_ERROR_WRITE_BUFFER = -6,     //!< Not enough space to write
   BLOSC2_ERROR_CODEC_SUPPORT = -7,    //!< Codec not supported
   BLOSC2_ERROR_CODEC_PARAM = -8,      //!< Invalid parameter supplied to codec
   BLOSC2_ERROR_CODEC_DICT = -9,       //!< Codec dictionary error
   BLOSC2_ERROR_VERSION_SUPPORT = -10, //!< Version not supported
   BLOSC2_ERROR_INVALID_HEADER = -11,  //!< Invalid value in header
   BLOSC2_ERROR_INVALID_PARAM = -12,   //!< Invalid parameter supplied to function
   BLOSC2_ERROR_FILE_READ = -13,       //!< File read failure
   BLOSC2_ERROR_FILE_WRITE = -14,      //!< File write failure
   BLOSC2_ERROR_FILE_OPEN = -15,       //!< File open failure
   BLOSC2_ERROR_NOT_FOUND = -16,       //!< Not found
   BLOSC2_ERROR_RUN_LENGTH = -17,      //!< Bad run length encoding
   BLOSC2_ERROR_FILTER_PIPELINE = -18, //!< Filter pipeline error
   BLOSC2_ERROR_CHUNK_INSERT = -19,    //!< Chunk insert failure
   BLOSC2_ERROR_CHUNK_APPEND = -20,    //!< Chunk append failure
   BLOSC2_ERROR_CHUNK_UPDATE = -21,    //!< Chunk update failure
   BLOSC2_ERROR_2GB_LIMIT = -22,       //!< Sizes larger than 2gb not supported
   BLOSC2_ERROR_SCHUNK_COPY = -23,     //!< Super-chunk copy failure
+  BLOSC2_ERROR_FRAME_TYPE = -24,      //!< Wrong type for frame
 };
 
 /**
  * @brief Initialize the Blosc library environment.
  *
  * You must call this previous to any other Blosc call, unless you want
  * Blosc to be used simultaneously in a multi-threaded environment, in
  * which case you can use the
  * @see #blosc2_compress_ctx #blosc2_decompress_ctx pair.
  */
diff --git a/blosc/frame.c b/blosc/frame.c
index 90f44792..f7c4dde8 100644
--- a/blosc/frame.c
+++ b/blosc/frame.c
@@ -116,268 +116,270 @@ int frame_free(blosc2_frame_s* frame) {
 void *new_header_frame(blosc2_schunk *schunk, blosc2_frame_s *frame) {
   if (frame == NULL) {
     return NULL;
   }
   uint8_t* h2 = calloc(FRAME_HEADER_MINLEN, 1);
   uint8_t* h2p = h2;
 
   // The msgpack header starts here
   *h2p = 0x90;  // fixarray...
   *h2p += 13;   // ...with 13 elements
   h2p += 1;
 
   // Magic number
   *h2p = 0xa0 + 8;  // str with 8 elements
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
   strcpy((char*)h2p, "b2frame");
   h2p += 8;
 
   // Header size
   *h2p = 0xd2;  // int32
   h2p += 1 + 4;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Total frame size
   *h2p = 0xcf;  // uint64
   // Fill it with frame->len which is known *after* the creation of the frame (e.g. when updating the header)
   int64_t flen = frame->len;
   swap_store(h2 + FRAME_LEN, &flen, sizeof(flen));
   h2p += 1 + 8;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Flags
   *h2p = 0xa0 + 4;  // str with 4 elements
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // General flags
   *h2p = BLOSC2_VERSION_FRAME_FORMAT;  // version
   *h2p += 0x10;  // 64-bit offsets.  We only support this for now.
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
-  // Reserved flags
+  // Frame type
+  // We only support contiguous and sparse directories frames currently
+  *h2p = frame->sframe ? 1 : 0;
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Codec flags
   *h2p = schunk->compcode;
   *h2p += (schunk->clevel) << 4u;  // clevel
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Reserved flags
   *h2p = 0;
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Uncompressed size
   *h2p = 0xd3;  // int64
   h2p += 1;
   int64_t nbytes = schunk->nbytes;
   swap_store(h2p, &nbytes, sizeof(nbytes));
   h2p += 8;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Compressed size
   *h2p = 0xd3;  // int64
   h2p += 1;
   int64_t cbytes = schunk->cbytes;
   swap_store(h2p, &cbytes, sizeof(cbytes));
   h2p += 8;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Type size
   *h2p = 0xd2;  // int32
   h2p += 1;
   int32_t typesize = schunk->typesize;
   swap_store(h2p, &typesize, sizeof(typesize));
   h2p += 4;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Chunk size
   *h2p = 0xd2;  // int32
   h2p += 1;
   int32_t chunksize = schunk->chunksize;
   swap_store(h2p, &chunksize, sizeof(chunksize));
   h2p += 4;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Number of threads for compression
   *h2p = 0xd1;  // int16
   h2p += 1;
   int16_t nthreads = (int16_t)schunk->cctx->nthreads;
   swap_store(h2p, &nthreads, sizeof(nthreads));
   h2p += 2;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // Number of threads for decompression
   *h2p = 0xd1;  // int16
   h2p += 1;
   nthreads = (int16_t)schunk->dctx->nthreads;
   swap_store(h2p, &nthreads, sizeof(nthreads));
   h2p += 2;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // The boolean for FRAME_HAS_USERMETA
   *h2p = (schunk->usermeta_len > 0) ? (uint8_t)0xc3 : (uint8_t)0xc2;
   h2p += 1;
   if (h2p - h2 >= FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   // The space for FRAME_FILTER_PIPELINE
   *h2p = 0xd8;  //  fixext 16
   h2p += 1;
   if (BLOSC2_MAX_FILTERS > FRAME_FILTER_PIPELINE_MAX) {
     return NULL;
   }
   // Store the filter pipeline in header
   uint8_t* mp_filters = h2 + FRAME_FILTER_PIPELINE + 1;
   uint8_t* mp_meta = h2 + FRAME_FILTER_PIPELINE + 1 + FRAME_FILTER_PIPELINE_MAX;
   int nfilters = 0;
   for (int i = 0; i < BLOSC2_MAX_FILTERS; i++) {
     if (schunk->filters[i] != BLOSC_NOFILTER) {
       mp_filters[nfilters] = schunk->filters[i];
       mp_meta[nfilters] = schunk->filters_meta[i];
       nfilters++;
     }
   }
   *h2p = (uint8_t)nfilters;
   h2p += 1;
   h2p += 16;
   if (h2p - h2 != FRAME_HEADER_MINLEN) {
     return NULL;
   }
 
   int32_t hsize = FRAME_HEADER_MINLEN;
 
   // Now, deal with metalayers
   int16_t nmetalayers = schunk->nmetalayers;
   if (nmetalayers < 0 || nmetalayers > BLOSC2_MAX_METALAYERS) {
     return NULL;
   }
 
   // Make space for the header of metalayers (array marker, size, map of offsets)
   h2 = realloc(h2, (size_t)hsize + 1 + 1 + 2 + 1 + 2);
   h2p = h2 + hsize;
 
   // The msgpack header for the metalayers (array_marker, size, map of offsets, list of metalayers)
   *h2p = 0x90 + 3;  // array with 3 elements
   h2p += 1;
 
   // Size for the map (index) of offsets, including this uint16 size (to be filled out later on)
   *h2p = 0xcd;  // uint16
   h2p += 1 + 2;
 
   // Map (index) of offsets for optional metalayers
   *h2p = 0xde;  // map 16 with N keys
   h2p += 1;
   swap_store(h2p, &nmetalayers, sizeof(nmetalayers));
   h2p += sizeof(nmetalayers);
   int32_t current_header_len = (int32_t)(h2p - h2);
   int32_t *offtooff = malloc(nmetalayers * sizeof(int32_t));
   for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
     if (frame == NULL) {
       return NULL;
     }
     blosc2_metalayer *metalayer = schunk->metalayers[nmetalayer];
     uint8_t namelen = (uint8_t) strlen(metalayer->name);
     h2 = realloc(h2, (size_t)current_header_len + 1 + namelen + 1 + 4);
     h2p = h2 + current_header_len;
     // Store the metalayer
     if (namelen >= (1U << 5U)) {  // metalayer strings cannot be longer than 32 bytes
       free(offtooff);
       return NULL;
     }
     *h2p = (uint8_t)0xa0 + namelen;  // str
     h2p += 1;
     memcpy(h2p, metalayer->name, namelen);
     h2p += namelen;
     // Space for storing the offset for the value of this metalayer
     *h2p = 0xd2;  // int32
     h2p += 1;
     offtooff[nmetalayer] = (int32_t)(h2p - h2);
     h2p += 4;
     current_header_len += 1 + namelen + 1 + 4;
   }
   int32_t hsize2 = (int32_t)(h2p - h2);
   if (hsize2 != current_header_len) {  // sanity check
     return NULL;
   }
 
   // Map size + int16 size
   if ((uint32_t) (hsize2 - hsize) >= (1U << 16U)) {
     return NULL;
   }
   uint16_t map_size = (uint16_t) (hsize2 - hsize);
   swap_store(h2 + FRAME_IDX_SIZE, &map_size, sizeof(map_size));
 
   // Make space for an (empty) array
   hsize = (int32_t)(h2p - h2);
   h2 = realloc(h2, (size_t)hsize + 2 + 1 + 2);
   h2p = h2 + hsize;
 
   // Now, store the values in an array
   *h2p = 0xdc;  // array 16 with N elements
   h2p += 1;
   swap_store(h2p, &nmetalayers, sizeof(nmetalayers));
   h2p += sizeof(nmetalayers);
   current_header_len = (int32_t)(h2p - h2);
   for (int nmetalayer = 0; nmetalayer < nmetalayers; nmetalayer++) {
     if (frame == NULL) {
       return NULL;
     }
     blosc2_metalayer *metalayer = schunk->metalayers[nmetalayer];
     h2 = realloc(h2, (size_t)current_header_len + 1 + 4 + metalayer->content_len);
     h2p = h2 + current_header_len;
     // Store the serialized contents for this metalayer
     *h2p = 0xc6;  // bin32
     h2p += 1;
     swap_store(h2p, &(metalayer->content_len), sizeof(metalayer->content_len));
     h2p += 4;
     memcpy(h2p, metalayer->content, metalayer->content_len);  // buffer, no need to swap
     h2p += metalayer->content_len;
     // Update the offset now that we know it
     swap_store(h2 + offtooff[nmetalayer], &current_header_len, sizeof(current_header_len));
     current_header_len += 1 + 4 + metalayer->content_len;
   }
   free(offtooff);
   hsize = (int32_t)(h2p - h2);
   if (hsize != current_header_len) {  // sanity check
     return NULL;
   }
 
   // Set the length of the whole header now that we know it
   swap_store(h2 + FRAME_HEADER_LEN, &hsize, sizeof(hsize));
 
   return h2;
 }
@@ -386,94 +388,106 @@ void *new_header_frame(blosc2_schunk *schunk, blosc2_frame_s *frame) {
 int get_header_info(blosc2_frame_s *frame, int32_t *header_len, int64_t *frame_len, int64_t *nbytes,
                     int64_t *cbytes, int32_t *chunksize, int32_t *nchunks, int32_t *typesize,
                     uint8_t *compcode, uint8_t *clevel, uint8_t *filters, uint8_t *filters_meta) {
   uint8_t* framep = frame->cframe;
   uint8_t header[FRAME_HEADER_MINLEN];
 
   if (frame->len <= 0) {
     return BLOSC2_ERROR_READ_BUFFER;
   }
 
   if (frame->cframe == NULL) {
     size_t rbytes = 0;
     FILE* fp = NULL;
     if (frame->sframe) {
       char* sframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(sframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(sframe_name, "rb");
       free(sframe_name);
     }
     else {
       fp = fopen(frame->urlpath, "rb");
     }
     if (fp != NULL) {
       rbytes = fread(header, 1, FRAME_HEADER_MINLEN, fp);
       fclose(fp);
     }
     (void) rbytes;
     if (rbytes != FRAME_HEADER_MINLEN) {
       return BLOSC2_ERROR_FILE_READ;
     }
     framep = header;
   }
 
+  // Consistency check for frame type
+  uint8_t frame_type = framep[FRAME_TYPE];
+  if (frame->sframe) {
+    if (frame_type != FRAME_DIRECTORY_TYPE) {
+      return BLOSC2_ERROR_FRAME_TYPE;
+    }
+  } else {
+    if (frame_type != FRAME_CONTIGUOUS_TYPE) {
+      return BLOSC2_ERROR_FRAME_TYPE;
+    }
+  }
+
   // Fetch some internal lengths
   swap_store(header_len, framep + FRAME_HEADER_LEN, sizeof(*header_len));
   swap_store(frame_len, framep + FRAME_LEN, sizeof(*frame_len));
   swap_store(nbytes, framep + FRAME_NBYTES, sizeof(*nbytes));
   swap_store(cbytes, framep + FRAME_CBYTES, sizeof(*cbytes));
   swap_store(chunksize, framep + FRAME_CHUNKSIZE, sizeof(*chunksize));
   if (typesize != NULL) {
     swap_store(typesize, framep + FRAME_TYPESIZE, sizeof(*typesize));
   }
 
   if (*header_len <= 0 || *header_len > *frame_len) {
     BLOSC_TRACE_ERROR("Header length is invalid or exceeds length of the frame.");
     return BLOSC2_ERROR_INVALID_HEADER;
   }
 
   // Codecs
   uint8_t frame_codecs = framep[FRAME_CODECS];
   if (clevel != NULL) {
     *clevel = frame_codecs >> 4u;
   }
   if (compcode != NULL) {
     *compcode = frame_codecs & 0xFu;
   }
 
   // Filters
   if (filters != NULL && filters_meta != NULL) {
     uint8_t nfilters = framep[FRAME_FILTER_PIPELINE];
     if (nfilters > BLOSC2_MAX_FILTERS) {
       BLOSC_TRACE_ERROR("The number of filters in frame header are too large for Blosc2.");
       return BLOSC2_ERROR_INVALID_HEADER;
     }
     uint8_t *filters_ = framep + FRAME_FILTER_PIPELINE + 1;
     uint8_t *filters_meta_ = framep + FRAME_FILTER_PIPELINE + 1 + FRAME_FILTER_PIPELINE_MAX;
     for (int i = 0; i < nfilters; i++) {
       filters[i] = filters_[i];
       filters_meta[i] = filters_meta_[i];
     }
   }
 
   if (*nbytes > 0 && *chunksize > 0) {
     // We can compute the number of chunks only when the frame has actual data
     *nchunks = (int32_t) (*nbytes / *chunksize);
     if (*nbytes % *chunksize > 0) {
       if (*nchunks == INT32_MAX) {
         BLOSC_TRACE_ERROR("Number of chunks exceeds maximum allowed.");
         return BLOSC2_ERROR_INVALID_HEADER;
       }
       *nchunks += 1;
     }
 
     // Sanity check for compressed sizes
     if ((*cbytes < 0) || ((int64_t)*nchunks * *chunksize < *nbytes)) {
       BLOSC_TRACE_ERROR("Invalid compressed size in frame header.");
       return BLOSC2_ERROR_INVALID_HEADER;
     }
   } else {
     *nchunks = 0;
   }
 
   return 0;
 }
@@ -867,57 +881,57 @@ int64_t frame_from_schunk(blosc2_schunk *schunk, blosc2_frame_s *frame) {
 // Get the compressed data offsets
 uint8_t* get_coffsets(blosc2_frame_s *frame, int32_t header_len, int64_t cbytes, int32_t *off_cbytes) {
   if (frame->coffsets != NULL) {
     if (off_cbytes != NULL) {
       *off_cbytes = *(int32_t *) (frame->coffsets + BLOSC2_CHUNK_CBYTES);
     }
     return frame->coffsets;
   }
   if (frame->cframe != NULL) {
     int64_t off_pos = header_len + cbytes;
     // Check that there is enough room to read Blosc header
     if (off_pos < 0 || off_pos + BLOSC_EXTENDED_HEADER_LENGTH > frame->len) {
       BLOSC_TRACE_ERROR("Cannot read the offsets outside of frame boundary.");
       return NULL;
     }
     // For in-memory frames, the coffset is just one pointer away
     uint8_t* off_start = frame->cframe + off_pos;
     if (off_cbytes != NULL) {
       *off_cbytes = *(int32_t*) (off_start + BLOSC2_CHUNK_CBYTES);
     }
     return off_start;
   }
 
   int64_t trailer_offset = get_trailer_offset(frame, header_len, true);
   int32_t coffsets_cbytes;
   if (frame->sframe) {
     coffsets_cbytes = (int32_t) (trailer_offset - (header_len + 0));
   }
   else {
     coffsets_cbytes = (int32_t) (trailer_offset - (header_len + cbytes));
   }
   if (off_cbytes != NULL) {
     *off_cbytes = coffsets_cbytes;
   }
   FILE* fp = NULL;
   uint8_t* coffsets = malloc((size_t)coffsets_cbytes);
   if (frame->sframe) {
     char* sframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
     sprintf(sframe_name, "%s/chunks.b2frame", frame->urlpath);
     fp = fopen(sframe_name, "rb");
     free(sframe_name);
     fseek(fp, header_len + 0, SEEK_SET);
   }
   else {
     fp = fopen(frame->urlpath, "rb");
     fseek(fp, header_len + cbytes, SEEK_SET);
   }
   size_t rbytes = fread(coffsets, 1, (size_t)coffsets_cbytes, fp);
   fclose(fp);
   if (rbytes != (size_t)coffsets_cbytes) {
-    BLOSC_TRACE_ERROR("Cannot read the offsets out of the fileframe.");
+    BLOSC_TRACE_ERROR("Cannot read the offsets out of the frame.");
     free(coffsets);
     return NULL;
   }
   frame->coffsets = coffsets;
   return coffsets;
 }
@@ -1011,91 +1025,91 @@ int frame_update_header(blosc2_frame_s* frame, blosc2_schunk* schunk, bool new)
 /* Get the (compressed) usermeta chunk out of a frame */
 int32_t frame_get_usermeta(blosc2_frame_s* frame, uint8_t** usermeta) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
     return ret;
   }
   int64_t trailer_offset = get_trailer_offset(frame, header_len, nbytes > 0);
   if (trailer_offset < 0) {
     BLOSC_TRACE_ERROR("Unable to get the trailer offset from frame.");
     return (int32_t)trailer_offset;
   }
   if (trailer_offset + FRAME_TRAILER_USERMETA_LEN_OFFSET + (signed)sizeof(int32_t) > frame_len) {
     BLOSC_TRACE_ERROR("Invalid trailer offset exceeds frame length.");
     return BLOSC2_ERROR_READ_BUFFER;
   }
 
   // Get the size of usermeta (inside the trailer)
   int32_t usermeta_len_network;
   if (frame->cframe != NULL) {
     memcpy(&usermeta_len_network, frame->cframe + trailer_offset + FRAME_TRAILER_USERMETA_LEN_OFFSET, sizeof(int32_t));
   }
   else {
     FILE* fp = NULL;
     if (frame->sframe) {
       char* sframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(sframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(sframe_name, "rb");
       free(sframe_name);
     }
     else {
       fp = fopen(frame->urlpath, "rb");
     }
     fseek(fp, trailer_offset + FRAME_TRAILER_USERMETA_LEN_OFFSET, SEEK_SET);
     size_t rbytes = fread(&usermeta_len_network, 1, sizeof(int32_t), fp);
     fclose(fp);
     if (rbytes != sizeof(int32_t)) {
-      BLOSC_TRACE_ERROR("Cannot access the usermeta_len out of the fileframe.");
+      BLOSC_TRACE_ERROR("Cannot access the usermeta_len out of the frame.");
       return BLOSC2_ERROR_READ_BUFFER;
     }
   }
   int32_t usermeta_len;
   swap_store(&usermeta_len, &usermeta_len_network, sizeof(int32_t));
 
   if (usermeta_len < 0) {
     BLOSC_TRACE_ERROR("Invalid usermeta length.");
     return BLOSC2_ERROR_READ_BUFFER;
   }
   if (usermeta_len == 0) {
     *usermeta = NULL;
     return 0;
   }
   if (trailer_offset + FRAME_TRAILER_USERMETA_OFFSET + usermeta_len > frame_len) {
     BLOSC_TRACE_ERROR("Invalid usermeta offset exceeds frame length.");
     return -1;
   }
 
   *usermeta = malloc(usermeta_len);
   if (frame->cframe != NULL) {
     memcpy(*usermeta, frame->cframe + trailer_offset + FRAME_TRAILER_USERMETA_OFFSET, usermeta_len);
   }
   else {
     FILE* fp = NULL;
     if (frame->sframe) {
       char* sframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(sframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(sframe_name, "rb+");
       free(sframe_name);
     }
     else {
       fp = fopen(frame->urlpath, "rb+");
     }
     fseek(fp, trailer_offset + FRAME_TRAILER_USERMETA_OFFSET, SEEK_SET);
     size_t rbytes = fread(*usermeta, 1, usermeta_len, fp);
     fclose(fp);
     if (rbytes != (size_t)usermeta_len) {
       BLOSC_TRACE_ERROR("Cannot read the complete usermeta chunk in frame. %ld != %ld.",
               (long)rbytes, (long)usermeta_len);
       return BLOSC2_ERROR_READ_BUFFER;
     }
   }
 
   return usermeta_len;
 }
@@ -1211,50 +1225,50 @@ static int frame_get_metalayers_from_header(blosc2_frame_s* frame, blosc2_schunk
 int frame_get_metalayers(blosc2_frame_s* frame, blosc2_schunk* schunk) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get the header info from frame.");
     return ret;
   }
 
   // Get the header
   uint8_t* header = NULL;
   if (frame->cframe != NULL) {
     header = frame->cframe;
   } else {
     size_t rbytes = 0;
     header = malloc(header_len);
     FILE* fp = NULL;
     if (frame->sframe) {
       char* sframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(sframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(sframe_name, "rb");
       free(sframe_name);
     }
     else {
       fp = fopen(frame->urlpath, "rb");
     }
     if (fp != NULL) {
       rbytes = fread(header, 1, header_len, fp);
       fclose(fp);
     }
     if (rbytes != (size_t) header_len) {
-      BLOSC_TRACE_ERROR("Cannot access the header out of the fileframe.");
+      BLOSC_TRACE_ERROR("Cannot access the header out of the frame.");
       free(header);
       return BLOSC2_ERROR_FILE_READ;
     }
   }
 
   ret = frame_get_metalayers_from_header(frame, schunk, header, header_len);
 
   if (frame->cframe == NULL) {
     free(header);
   }
 
   return ret;
 }
@@ -1550,431 +1564,431 @@ int frame_special_chunk(int64_t special_value, int32_t nbytes, int32_t typesize,
 /* Return a compressed chunk that is part of a frame in the `chunk` parameter.
  * If the frame is disk-based, a buffer is allocated for the (compressed) chunk,
  * and hence a free is needed.  You can check if the chunk requires a free with the `needs_free`
  * parameter.
  * If the chunk does not need a free, it means that a pointer to the location in frame is returned
  * in the `chunk` parameter.
  *
  * The size of the (compressed) chunk is returned.  If some problem is detected, a negative code
  * is returned instead.
 */
 int frame_get_chunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int32_t typesize;
   int32_t chunk_cbytes;
 
   *chunk = NULL;
   *needs_free = false;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             &typesize, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return ret;
   }
 
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                     "('%d') in frame.", nchunk, nchunks);
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   // Get the offset to nchunk
   int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);
 
   if (offset < 0) {
     // Special value
     chunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
     int rc = frame_special_chunk(offset, chunksize, typesize, chunk, chunk_cbytes, needs_free);
     if (rc < 0) {
       return rc;
     }
     goto end;
   }
 
   if (frame->sframe) {
     // Sparse on-disk
     nchunk = offset;
     return sframe_get_chunk(frame, nchunk, chunk, needs_free);
   }
   if (frame->cframe == NULL) {
     FILE* fp = fopen(frame->urlpath, "rb");
     fseek(fp, header_len + offset + BLOSC2_CHUNK_CBYTES, SEEK_SET);
     size_t rbytes = fread(&chunk_cbytes, 1, sizeof(chunk_cbytes), fp);
     if (rbytes != sizeof(chunk_cbytes)) {
-      BLOSC_TRACE_ERROR("Cannot read the cbytes for chunk in the fileframe.");
+      BLOSC_TRACE_ERROR("Cannot read the cbytes for chunk in the frame.");
       fclose(fp);
       return BLOSC2_ERROR_FILE_READ;
     }
     chunk_cbytes = sw32_(&chunk_cbytes);
     *chunk = malloc((size_t)chunk_cbytes);
     fseek(fp, header_len + offset, SEEK_SET);
     rbytes = fread(*chunk, 1, (size_t)chunk_cbytes, fp);
     fclose(fp);
     if (rbytes != (size_t)chunk_cbytes) {
-      BLOSC_TRACE_ERROR("Cannot read the chunk out of the fileframe.");
+      BLOSC_TRACE_ERROR("Cannot read the chunk out of the frame.");
       return BLOSC2_ERROR_FILE_READ;
     }
     *needs_free = true;
   } else {
     // The chunk is in memory and just one pointer away
     *chunk = frame->cframe + header_len + offset;
     chunk_cbytes = sw32_(*chunk + BLOSC2_CHUNK_CBYTES);
   }
 
   end:
   return chunk_cbytes;
 }
 
 
 /* Return a compressed chunk that is part of a frame in the `chunk` parameter.
  * If the frame is disk-based, a buffer is allocated for the (lazy) chunk,
  * and hence a free is needed.  You can check if the chunk requires a free with the `needs_free`
  * parameter.
  * If the chunk does not need a free, it means that the frame is in memory and that just a
  * pointer to the location of the chunk in memory is returned.
  *
  * The size of the (compressed, potentially lazy) chunk is returned.  If some problem is detected,
  * a negative code is returned instead.
 */
 int frame_get_lazychunk(blosc2_frame_s *frame, int nchunk, uint8_t **chunk, bool *needs_free) {
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int32_t typesize;
   size_t lazychunk_cbytes;
 
   *chunk = NULL;
   *needs_free = false;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             &typesize, NULL, NULL, NULL, NULL);
   if (ret < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return ret;
   }
 
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("nchunk ('%d') exceeds the number of chunks "
                       "('%d') in frame.", nchunk, nchunks);
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   // Get the offset to nchunk
   int64_t offset = get_coffset(frame, header_len, cbytes, nchunk);
 
   if (offset < 0) {
     // Special value
     lazychunk_cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
     int rc = frame_special_chunk(offset, chunksize, typesize, chunk,
                                  (int32_t)lazychunk_cbytes, needs_free);
     if (rc < 0) {
       return rc;
     }
     goto end;
   }
 
   if (frame->cframe == NULL) {
     // TODO: make this portable across different endianness
     // Get info for building a lazy chunk
     size_t chunk_nbytes;
     size_t chunk_cbytes;
     size_t chunk_blocksize;
     uint8_t header[BLOSC_MIN_HEADER_LENGTH];
     FILE* fp = NULL;
     if (frame->sframe) {
       // The chunk is not in the frame
       char* chunkpath = malloc(strlen(frame->urlpath) + 1 + 8 + strlen(".chunk") + 1);
       sprintf(chunkpath, "%s/%08X.chunk", frame->urlpath, (unsigned int)offset);
       fp = fopen(chunkpath, "rb");
       free(chunkpath);
     }
     else {
       fp = fopen(frame->urlpath, "rb");
       fseek(fp, header_len + offset, SEEK_SET);
     }
     size_t rbytes = fread(header, 1, BLOSC_MIN_HEADER_LENGTH, fp);
     if (rbytes != BLOSC_MIN_HEADER_LENGTH) {
-      BLOSC_TRACE_ERROR("Cannot read the header for chunk in the fileframe.");
+      BLOSC_TRACE_ERROR("Cannot read the header for chunk in the frame.");
       fclose(fp);
       return BLOSC2_ERROR_FILE_READ;
     }
     blosc_cbuffer_sizes(header, &chunk_nbytes, &chunk_cbytes, &chunk_blocksize);
     size_t nblocks = chunk_nbytes / chunk_blocksize;
     size_t leftover_block = chunk_nbytes % chunk_blocksize;
     nblocks = leftover_block ? nblocks + 1 : nblocks;
     // Allocate space for the lazy chunk
     size_t trailer_len = sizeof(int32_t) + sizeof(int64_t) + nblocks * sizeof(int32_t);
     size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH + nblocks * sizeof(int32_t);
     lazychunk_cbytes = trailer_offset + trailer_len;
     *chunk = malloc(lazychunk_cbytes);
     *needs_free = true;
     // Read just the full header and bstarts section too (lazy partial length)
     if (frame->sframe) {
       fseek(fp, 0, SEEK_SET);
     }
     else {
       fseek(fp, header_len + offset, SEEK_SET);
     }
     rbytes = fread(*chunk, 1, trailer_offset, fp);
     fclose(fp);
     if (rbytes != trailer_offset) {
-      BLOSC_TRACE_ERROR("Cannot read the (lazy) chunk out of the fileframe.");
+      BLOSC_TRACE_ERROR("Cannot read the (lazy) chunk out of the frame.");
       return BLOSC2_ERROR_FILE_READ;
     }
 
     // Mark chunk as lazy
     uint8_t* blosc2_flags = *chunk + BLOSC2_CHUNK_BLOSC2_FLAGS;
     *blosc2_flags |= 0x08U;
 
     // Add the trailer (currently, nchunk + offset + block_csizes)
     *(int32_t*)(*chunk + trailer_offset) = nchunk;
     *(int64_t*)(*chunk + trailer_offset + sizeof(int32_t)) = header_len + offset;
 
     int32_t* block_csizes = malloc(nblocks * sizeof(int32_t));
 
     int memcpyed = *(*chunk + BLOSC2_CHUNK_FLAGS) & (uint8_t)BLOSC_MEMCPYED;
     if (memcpyed) {
       // When memcpyed the blocksizes are trivial to compute
       for (int i = 0; i < (int)nblocks; i++) {
         block_csizes[i] = (int)chunk_blocksize;
       }
     }
     else {
       // In regular, compressed chunks, we need to sort the bstarts (they can be out
       // of order because of multi-threading), and get a reverse index too.
       memcpy(block_csizes, *chunk + BLOSC_EXTENDED_HEADER_LENGTH, nblocks * sizeof(int32_t));
       // Helper structure to keep track of original indexes
       struct csize_idx *csize_idx = malloc(nblocks * sizeof(struct csize_idx));
       for (int n = 0; n < (int)nblocks; n++) {
         csize_idx[n].val = block_csizes[n];
         csize_idx[n].idx = n;
       }
       qsort(csize_idx, nblocks, sizeof(struct csize_idx), &sort_offset);
       // Compute the actual csizes
       int idx;
       for (int n = 0; n < (int)nblocks - 1; n++) {
         idx = csize_idx[n].idx;
         block_csizes[idx] = csize_idx[n + 1].val - csize_idx[n].val;
       }
       idx = csize_idx[nblocks - 1].idx;
       block_csizes[idx] = (int)chunk_cbytes - csize_idx[nblocks - 1].val;
       free(csize_idx);
     }
     // Copy the csizes at the end of the trailer
     void *trailer_csizes = *chunk + lazychunk_cbytes - nblocks * sizeof(int32_t);
     memcpy(trailer_csizes, block_csizes, nblocks * sizeof(int32_t));
     free(block_csizes);
   } else {
     // The chunk is in memory and just one pointer away
     *chunk = frame->cframe + header_len + offset;
     lazychunk_cbytes = sw32_(*chunk + BLOSC2_CHUNK_CBYTES);
   }
 
   end:
   return (int)lazychunk_cbytes;
 }
 
 
 /* Append an existing chunk into a frame. */
 void* frame_append_chunk(blosc2_frame_s* frame, void* chunk, blosc2_schunk* schunk) {
   int8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
 
   /* The uncompressed and compressed sizes start at byte 4 and 12 */
   int32_t nbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_NBYTES);
   int32_t cbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_CBYTES);
 
   if ((nchunks > 0) && (nbytes_chunk > chunksize)) {
     BLOSC_TRACE_ERROR("Appending chunks with a larger chunksize than frame is "
                       "not allowed yet %d != %d.", nbytes_chunk, chunksize);
     return NULL;
   }
 
   // Check that we are not appending a small chunk after another small chunk
   if (chunksize == 0 && (nchunks > 0) && (nbytes_chunk < chunksize)) {
     uint8_t* last_chunk;
     bool needs_free;
     int retcode = frame_get_lazychunk(frame, nchunks - 1, &last_chunk, &needs_free);
     if (retcode < 0) {
       BLOSC_TRACE_ERROR("Cannot get the last chunk (in position %d).",
                         nchunks - 1);
       return NULL;
     }
     int32_t last_nbytes = sw32_(last_chunk + BLOSC2_CHUNK_NBYTES);
     if (needs_free) {
       free(last_chunk);
     }
     if ((last_nbytes < chunksize) && (nbytes < chunksize)) {
       BLOSC_TRACE_ERROR("Appending two consecutive chunks with a chunksize smaller "
                         "than the frame chunksize is not allowed yet: %d != %d.",
                         nbytes_chunk, chunksize);
       return NULL;
     }
   }
 
   // Get the current offsets and add one more
   int32_t off_nbytes = (nchunks + 1) * sizeof(int64_t);
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       free(offsets);
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets,
                                                 nchunks * sizeof(int64_t));
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // Add the new offset
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_ZERO_RUNLEN:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
       swap_store(offsets + nchunks, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_NAN_RUNLEN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
       swap_store(offsets + nchunks, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     default:
       if (frame->sframe) {
         offsets[nchunks] = nchunks;
       }
       else {
         offsets[nchunks] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = sizeof(int64_t);  // 64-bit offsets
   // The params below have been fine-tuned with the zero_runlen bench
   cctx->nthreads = 4;  // 4 threads seems a decent default for nowadays CPUs
   // cctx->compcode = BLOSC_LZ4;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = cbytes + cbytes_chunk;
   int64_t new_frame_len;
   if (frame->sframe) {
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   }
   else {
     size_t wbytes;
     if (frame->sframe) {
       // Update the offsets chunk in the chunks frame
       if (cbytes_chunk != 0) {
         if (sframe_create_chunk(frame, chunk, nchunks, cbytes_chunk) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       char* sframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(sframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(sframe_name, "rb+");
       free(sframe_name);
       fseek(fp, header_len, SEEK_SET);
       wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
       if (wbytes != (size_t)cbytes_chunk) {
-        BLOSC_TRACE_ERROR("Cannot write the full chunk to fileframe.");
+        BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         fclose(fp);
         return NULL;
       }
       wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     }
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
-      BLOSC_TRACE_ERROR("Cannot write the offsets to fileframe.");
+      BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
   }
   // Invalidate the cache for chunk offsets
   if (frame->coffsets != NULL) {
     free(frame->coffsets);
     frame->coffsets = NULL;
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -1983,173 +1997,173 @@ void* frame_append_chunk(blosc2_frame_s* frame, void* chunk, blosc2_schunk* schu
 void* frame_insert_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_schunk* schunk) {
   uint8_t* chunk_ = chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
 
   int32_t cbytes_chunk = sw32_(chunk_ + BLOSC2_CHUNK_CBYTES);
 
   // Get the current offsets
   int32_t off_nbytes = (nchunks + 1) * 8;
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // TODO: Improvement: Check if new chunk is smaller than previous one
 
   // Add the new offset
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_ZERO_RUNLEN:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
       swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
           break;
     case BLOSC2_NAN_RUNLEN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
       swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     default:
       // Add the new offset
       for (int i = nchunks; i > nchunk; i--) {
         offsets[i] = offsets[i - 1];
       }
       if (frame->sframe) {
         offsets[nchunk] = nchunks;
       }
       else {
         offsets[nchunk] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = 8;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = cbytes + cbytes_chunk;
 
   int64_t new_frame_len;
   if (frame->sframe) {
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   // Add the chunk and update meta
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     size_t wbytes;
     if (frame->sframe) {
       if (cbytes_chunk != 0) {
         if (sframe_create_chunk(frame, chunk, nchunks, cbytes_chunk) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       // Update the offsets chunk in the chunks frame
       char* sframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(sframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(sframe_name, "rb+");
       free(sframe_name);
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
       if (wbytes != (size_t)cbytes_chunk) {
-        BLOSC_TRACE_ERROR("Cannot write the full chunk to fileframe.");
+        BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
-      BLOSC_TRACE_ERROR("Cannot write the offsets to fileframe.");
+      BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -2158,166 +2172,166 @@ void* frame_insert_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_
 void* frame_update_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_schunk* schunk) {
   uint8_t *chunk_ = (uint8_t *) chunk;
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int rc = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                            NULL, NULL, NULL, NULL, NULL);
   if (rc < 0) {
     BLOSC_TRACE_ERROR("Unable to get meta info from frame.");
     return NULL;
   }
   if (nchunk >= nchunks) {
     BLOSC_TRACE_ERROR("The chunk must already exist.");
     return NULL;
   }
 
   int32_t cbytes_chunk = sw32_((uint8_t*)chunk + BLOSC2_CHUNK_CBYTES);
 
   // Get the current offsets
   int32_t off_nbytes = nchunks * 8;
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
   if (nchunks > 0) {
     int32_t coffsets_cbytes = 0;
     uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
     if (coffsets == NULL) {
       BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
       return NULL;
     }
     if (coffsets_cbytes == 0) {
       coffsets_cbytes = cbytes;
     }
 
     // Decompress offsets
     blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
     blosc2_context *dctx = blosc2_create_dctx(off_dparams);
     int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes, offsets, nchunks * 8);
     blosc2_free_ctx(dctx);
     if (prev_nbytes < 0) {
       free(offsets);
       BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
       return NULL;
     }
   }
 
   // Add the new offset
   int special_value = (chunk_[BLOSC2_CHUNK_BLOSC2_FLAGS] & 0x30) >> 4;
   uint64_t offset_value = ((uint64_t)1 << 63);
   switch (special_value) {
     case BLOSC2_ZERO_RUNLEN:
       // Zero chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_ZERO_RUNLEN << (8 * 7);  // indicate a chunk of zeros
       swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     case BLOSC2_NAN_RUNLEN:
       // NaN chunk.  Code it in a special way.
       offset_value += (uint64_t)BLOSC2_NAN_RUNLEN << (8 * 7);  // indicate a chunk of NANs
       swap_store(offsets + nchunk, &offset_value, sizeof(uint64_t));
       cbytes_chunk = 0;   // we don't need to store the chunk
       break;
     default:
       if (frame->sframe) {
         // In case there was a reorder
         offsets[nchunk] = nchunk;
       }
       else {
         // Add the new offset
         offsets[nchunk] = cbytes;
       }
   }
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = 8;
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   free(offsets);
   if (new_off_cbytes < 0) {
     free(off_chunk);
     return NULL;
   }
 
   int64_t new_cbytes = schunk->cbytes;
   int64_t new_frame_len;
   if (frame->sframe) {
     // The chunk is not stored in the frame
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + new_cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   FILE* fp = NULL;
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return NULL;
     }
     /* Copy the chunk */
     memcpy(framep + header_len + cbytes, chunk, (size_t)cbytes_chunk);
     /* Copy the offsets */
     memcpy(framep + header_len + new_cbytes, off_chunk, (size_t)new_off_cbytes);
   } else {
     size_t wbytes;
     if (frame->sframe) {
       if (cbytes_chunk) {
         if (sframe_create_chunk(frame, chunk, nchunk, cbytes_chunk) == NULL) {
           BLOSC_TRACE_ERROR("Cannot write the full chunk.");
           return NULL;
         }
       }
       // Update the offsets chunk in the chunks frame
       char* sframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(sframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(sframe_name, "rb+");
       free(sframe_name);
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
       wbytes = fwrite(chunk, 1, (size_t)cbytes_chunk, fp);  // the new chunk
       if (wbytes != (size_t)cbytes_chunk) {
-        BLOSC_TRACE_ERROR("Cannot write the full chunk to fileframe.");
+        BLOSC_TRACE_ERROR("Cannot write the full chunk to frame.");
         fclose(fp);
         return NULL;
       }
     }
     wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
-      BLOSC_TRACE_ERROR("Cannot write the offsets to fileframe.");
+      BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return NULL;
     }
     // Invalidate the cache for chunk offsets
     if (frame->coffsets != NULL) {
       free(frame->coffsets);
       frame->coffsets = NULL;
     }
   }
   free(chunk);  // chunk has always to be a copy when reaching here...
   free(off_chunk);
 
   frame->len = new_frame_len;
   rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return NULL;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return NULL;
   }
 
   return frame;
 }
@@ -2326,128 +2340,128 @@ void* frame_update_chunk(blosc2_frame_s* frame, int nchunk, void* chunk, blosc2_
 int frame_reorder_offsets(blosc2_frame_s* frame, const int* offsets_order, blosc2_schunk* schunk) {
   // Get header info
   int32_t header_len;
   int64_t frame_len;
   int64_t nbytes;
   int64_t cbytes;
   int32_t chunksize;
   int32_t nchunks;
   int ret = get_header_info(frame, &header_len, &frame_len, &nbytes, &cbytes, &chunksize, &nchunks,
                             NULL, NULL, NULL, NULL, NULL);
   if (ret < 0) {
       BLOSC_TRACE_ERROR("Cannot get the header info for the frame.");
       return ret;
   }
 
   // Get the current offsets and add one more
   int32_t off_nbytes = nchunks * sizeof(int64_t);
   int64_t* offsets = (int64_t *) malloc((size_t)off_nbytes);
 
   int32_t coffsets_cbytes = 0;
   uint8_t *coffsets = get_coffsets(frame, header_len, cbytes, &coffsets_cbytes);
   if (coffsets == NULL) {
     BLOSC_TRACE_ERROR("Cannot get the offsets for the frame.");
     free(offsets);
     return BLOSC2_ERROR_DATA;
   }
 
   // Decompress offsets
   blosc2_dparams off_dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_context *dctx = blosc2_create_dctx(off_dparams);
   int32_t prev_nbytes = blosc2_decompress_ctx(dctx, coffsets, coffsets_cbytes,
                                               offsets, off_nbytes);
   blosc2_free_ctx(dctx);
   if (prev_nbytes < 0) {
     free(offsets);
     BLOSC_TRACE_ERROR("Cannot decompress the offsets chunk.");
     return prev_nbytes;
   }
 
   // Make a copy of the chunk offsets and reorder it
   int64_t *offsets_copy = malloc(prev_nbytes);
   memcpy(offsets_copy, offsets, prev_nbytes);
 
   for (int i = 0; i < nchunks; ++i) {
     offsets[i] = offsets_copy[offsets_order[i]];
   }
   free(offsets_copy);
 
   // Re-compress the offsets again
   blosc2_context* cctx = blosc2_create_cctx(BLOSC2_CPARAMS_DEFAULTS);
   cctx->typesize = sizeof(int64_t);
   void* off_chunk = malloc((size_t)off_nbytes + BLOSC_MAX_OVERHEAD);
   int32_t new_off_cbytes = blosc2_compress_ctx(cctx, offsets, off_nbytes,
                                                off_chunk, off_nbytes + BLOSC_MAX_OVERHEAD);
   blosc2_free_ctx(cctx);
 
   if (new_off_cbytes < 0) {
     free(offsets);
     free(off_chunk);
     return new_off_cbytes;
   }
   free(offsets);
   int64_t new_frame_len;
   if (frame->sframe) {
     // The chunks are not in the frame
     new_frame_len = header_len + 0 + new_off_cbytes + frame->trailer_len;
   }
   else {
     new_frame_len = header_len + cbytes + new_off_cbytes + frame->trailer_len;
   }
 
   if (frame->cframe != NULL) {
     uint8_t* framep = frame->cframe;
     /* Make space for the new chunk and copy it */
     frame->cframe = framep = realloc(framep, (size_t)new_frame_len);
     if (framep == NULL) {
       BLOSC_TRACE_ERROR("Cannot realloc space for the frame.");
       return BLOSC2_ERROR_MEMORY_ALLOC;
     }
     /* Copy the offsets */
     memcpy(framep + header_len + cbytes, off_chunk, (size_t)new_off_cbytes);
   }
   else {
     FILE* fp = NULL;
     if (frame->sframe) {
       // Update the offsets chunk in the chunks frame
       char* sframe_name = malloc(strlen(frame->urlpath) + strlen("/chunks.b2frame") + 1);
       sprintf(sframe_name, "%s/chunks.b2frame", frame->urlpath);
       fp = fopen(sframe_name, "rb+");
       free(sframe_name);
       fseek(fp, header_len + 0, SEEK_SET);
     }
     else {
       // Regular frame
       fp = fopen(frame->urlpath, "rb+");
       fseek(fp, header_len + cbytes, SEEK_SET);
     }
     size_t wbytes = fwrite(off_chunk, 1, (size_t)new_off_cbytes, fp);  // the new offsets
     fclose(fp);
     if (wbytes != (size_t)new_off_cbytes) {
-      BLOSC_TRACE_ERROR("Cannot write the offsets to fileframe.");
+      BLOSC_TRACE_ERROR("Cannot write the offsets to frame.");
       return BLOSC2_ERROR_FILE_WRITE;
     }
   }
 
   // Invalidate the cache for chunk offsets
   if (frame->coffsets != NULL) {
     free(frame->coffsets);
     frame->coffsets = NULL;
   }
   free(off_chunk);
 
   frame->len = new_frame_len;
   int rc = frame_update_header(frame, schunk, false);
   if (rc < 0) {
     return rc;
   }
 
   rc = frame_update_trailer(frame, schunk);
   if (rc < 0) {
     return rc;
   }
 
   return 0;
 }
 
 
 /* Decompress and return a chunk that is part of a frame. */
diff --git a/blosc/frame.h b/blosc/frame.h
index 9fd19740..964db93a 100644
--- a/blosc/frame.h
+++ b/blosc/frame.h
@@ -1,41 +1,47 @@
 /*********************************************************************
   Blosc - Blocked Shuffling and Compression Library
 
   Author: The Blosc Developers <blosc@blosc.org>
 
   See LICENSE.txt for details about copyright and rights to use.
 **********************************************************************/
 
 #ifndef BLOSC_FRAME_H
 #define BLOSC_FRAME_H
 
 #include <stdio.h>
 #include <stdint.h>
 
+// Different types of frames
+#define FRAME_CONTIGUOUS_TYPE 0
+#define FRAME_DIRECTORY_TYPE 1
+
+
 // Constants for metadata placement in header
 #define FRAME_HEADER_MAGIC 2
 #define FRAME_HEADER_LEN (FRAME_HEADER_MAGIC + 8 + 1)  // 11
 #define FRAME_LEN (FRAME_HEADER_LEN + 4 + 1)  // 16
 #define FRAME_FLAGS (FRAME_LEN + 8 + 1)  // 25
+#define FRAME_TYPE (FRAME_FLAGS + 1)  // 26
 #define FRAME_CODECS (FRAME_FLAGS + 2)  // 27
 #define FRAME_NBYTES (FRAME_FLAGS + 4 + 1)  // 30
 #define FRAME_CBYTES (FRAME_NBYTES + 8 + 1)  // 39
 #define FRAME_TYPESIZE (FRAME_CBYTES + 8 + 1) // 48
 #define FRAME_CHUNKSIZE (FRAME_TYPESIZE + 4 + 1)  // 53
 #define FRAME_NTHREADS_C (FRAME_CHUNKSIZE + 4 + 1)  // 58
 #define FRAME_NTHREADS_D (FRAME_NTHREADS_C + 2 + 1)  // 61
 #define FRAME_HAS_USERMETA (FRAME_NTHREADS_D + 2)  // 63
 #define FRAME_FILTER_PIPELINE (FRAME_HAS_USERMETA + 1 + 1) // 65
 #define FRAME_HEADER_MINLEN (FRAME_FILTER_PIPELINE + 1 + 16)  // 82 <- minimum length
 #define FRAME_METALAYERS (FRAME_HEADER_MINLEN)  // 82
 #define FRAME_IDX_SIZE (FRAME_METALAYERS + 1 + 1)  // 84
 
 #define FRAME_FILTER_PIPELINE_MAX (8)  // the maximum number of filters that can be stored in header
 
 #define FRAME_TRAILER_VERSION_BETA2 (0U)  // for beta.2 and former
 #define FRAME_TRAILER_VERSION (1U)        // can be up to 127
 
 #define FRAME_TRAILER_USERMETA_LEN_OFFSET (3)  // offset to usermeta length
 #define FRAME_TRAILER_USERMETA_OFFSET (7)  // offset to usermeta chunk
 #define FRAME_TRAILER_MINLEN (30)  // minimum length for the trailer (msgpack overhead)
 #define FRAME_TRAILER_LEN_OFFSET (22)  // offset to trailer length (counting from the end)
diff --git a/blosc/schunk.c b/blosc/schunk.c
index a7c81c96..22036ee8 100644
--- a/blosc/schunk.c
+++ b/blosc/schunk.c
@@ -107,57 +107,57 @@ void update_schunk_properties(struct blosc2_schunk* schunk) {
 /* Create a new super-chunk */
 blosc2_schunk* blosc2_schunk_new(const blosc2_storage storage) {
   blosc2_schunk* schunk = calloc(1, sizeof(blosc2_schunk));
   schunk->version = 0;     /* pre-first version */
 
   // Get the storage with proper defaults
   schunk->storage = get_new_storage(&storage, &BLOSC2_CPARAMS_DEFAULTS, &BLOSC2_DPARAMS_DEFAULTS);
   // ...and update internal properties
   update_schunk_properties(schunk);
 
   if (!storage.contiguous && storage.urlpath != NULL){
     char* urlpath;
     char last_char = storage.urlpath[strlen(storage.urlpath) - 1];
     if (last_char == '\\' || last_char == '/') {
       urlpath = malloc(strlen(storage.urlpath));
       strncpy(urlpath, storage.urlpath, strlen(storage.urlpath) - 1);
       urlpath[strlen(storage.urlpath) - 1] = '\0';
     }
     else {
       urlpath = malloc(strlen(storage.urlpath) + 1);
       strcpy(urlpath, storage.urlpath);
     }
     // Create directory
     if (mkdir(urlpath, 0777) == -1) {
       BLOSC_TRACE_ERROR("Error during the creation of the directory, maybe it already exists.");
       return NULL;
     }
-    // We want a frame as storage
+    // We want a sparse (directory) frame as storage
     blosc2_frame_s* frame = frame_new(urlpath);
     free(urlpath);
     frame->sframe = true;
     // Initialize frame (basically, encode the header)
     int64_t frame_len = frame_from_schunk(schunk, frame);
     if (frame_len < 0) {
       BLOSC_TRACE_ERROR("Error during the conversion of schunk to frame.");
       return NULL;
     }
     schunk->frame = (blosc2_frame*)frame;
   }
   if (storage.contiguous){
-    // We want a frame as storage
+    // We want a contiguous frame as storage
     blosc2_frame_s* frame = frame_new(storage.urlpath);
     frame->sframe = false;
     // Initialize frame (basically, encode the header)
     int64_t frame_len = frame_from_schunk(schunk, frame);
     if (frame_len < 0) {
       BLOSC_TRACE_ERROR("Error during the conversion of schunk to frame.");
       return NULL;
     }
     schunk->frame = (blosc2_frame*)frame;
   }
 
   return schunk;
 }
 
 
 /* Create an empty super-chunk */
diff --git a/examples/sframe_simple.c b/examples/sframe_simple.c
index e7d83758..c8125402 100644
--- a/examples/sframe_simple.c
+++ b/examples/sframe_simple.c
@@ -29,78 +29,78 @@
 int main(void) {
   static int32_t data[CHUNKSIZE];
   static int32_t data_dest[CHUNKSIZE];
   size_t isize = CHUNKSIZE * sizeof(int32_t);
   int dsize;
   int64_t nbytes, cbytes;
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   blosc2_dparams dparams = BLOSC2_DPARAMS_DEFAULTS;
   blosc2_schunk* schunk;
   int i, nchunk;
   blosc_timestamp_t last, current;
   double ttotal;
 
   printf("Blosc version info: %s (%s)\n", blosc_get_version_string(), BLOSC_VERSION_DATE);
   /* Create a super-chunk container */
   cparams.typesize = sizeof(int32_t);
   cparams.clevel = 9;
   cparams.nthreads = NTHREADS;
   dparams.nthreads = NTHREADS;
-  blosc2_storage storage = {false, "dir1.b2sframe", .cparams=&cparams, .dparams=&dparams};
+  blosc2_storage storage = {false, "dir1.b2frame", .cparams=&cparams, .dparams=&dparams};
   schunk = blosc2_schunk_new(storage);
 
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     for (i = 0; i < CHUNKSIZE; i++) {
       data[i] = i * nchunk;
     }
     int nchunks = blosc2_schunk_append_buffer(schunk, data, isize);
     if (nchunks != nchunk + 1) {
       printf("Unexpected nchunks!");
       return -1;
     }
   }
   /* Gather some info */
   nbytes = schunk->nbytes;
   cbytes = schunk->cbytes;
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Compression ratio: %.1f MB -> %.1f MB (%.1fx)\n",
          nbytes / MB, cbytes / MB, (1. * nbytes) / cbytes);
   printf("Compression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Retrieve and decompress the chunks (0-based count) */
   blosc_set_timestamp(&last);
   for (nchunk = NCHUNKS-1; nchunk >= 0; nchunk--) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, data_dest, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       return dsize;
     }
   }
   blosc_set_timestamp(&current);
   ttotal = blosc_elapsed_secs(last, current);
   printf("Decompression time: %.3g s, %.1f MB/s\n",
          ttotal, nbytes / (ttotal * MB));
 
   /* Check integrity of the second chunk (made of non-zeros) */
   blosc2_schunk_decompress_chunk(schunk, 1, data_dest, isize);
   for (i = 0; i < CHUNKSIZE; i++) {
     if (data_dest[i] != i) {
       printf("Decompressed data differs from original %d, %d!\n",
              i, data_dest[i]);
       return -1;
     }
   }
 
   printf("Successful roundtrip data <-> schunk !\n");
 
   /* Remove directory */
   blosc2_remove_dir(storage.urlpath);
   /* Free resources */
   /* Destroy the super-chunk */
   blosc2_schunk_free(schunk);
 
   return 0;
 }
 
diff --git a/tests/test_copy.c b/tests/test_copy.c
index 11cfad17..f86831f6 100644
--- a/tests/test_copy.c
+++ b/tests/test_copy.c
@@ -46,39 +46,39 @@ CUTEST_TEST_DATA(copy) {
 CUTEST_TEST_SETUP(copy) {
   blosc_init();
   data->cparams = BLOSC2_CPARAMS_DEFAULTS;
   data->cparams.typesize = sizeof(int32_t);
   data->cparams.clevel = 9;
   data->cparams.nthreads = NTHREADS;
 
   data->cparams2 = BLOSC2_CPARAMS_DEFAULTS;
   data->cparams2.typesize = sizeof(int32_t);
   data->cparams2.clevel = 2;
   data->cparams2.nthreads = NTHREADS;
   data->cparams2.blocksize = 10000;
 
   CUTEST_PARAMETRIZE(nchunks, int32_t, CUTEST_DATA(
       0, 1, 10, 20
   ));
   CUTEST_PARAMETRIZE(different_cparams, bool, CUTEST_DATA(
       false, true
   ));
   CUTEST_PARAMETRIZE(metalayers, bool, CUTEST_DATA(
       false, true
   ));
   CUTEST_PARAMETRIZE(usermeta, bool, CUTEST_DATA(
       false, true
   ));
   CUTEST_PARAMETRIZE(backend, test_copy_backend, CUTEST_DATA(
       {false, NULL},  // memory - schunk
-      {true, NULL},  // memory - frame
-      {true, "test_copy.b2frame"}, // disk - frame
-      {false, "test_copy.b2sframe"}, // disk - sframe
+      {true, NULL},  // memory - cframe
+      {true, "test_copy.b2frame"}, // disk - cframe
+      {false, "test_copy_s.b2frame"}, // disk - sframe
   ));
   CUTEST_PARAMETRIZE(backend2, test_copy_backend, CUTEST_DATA(
       {false, NULL},  // memory - schunk
-      {true, NULL},  // memory - frame
-      {true, "test_copy2.b2frame"}, // disk - frame
-      {false, "test_copy2.b2sframe"}, // disk - sframe
+      {true, NULL},  // memory - cframe
+      {true, "test_copy2.b2frame"}, // disk - cframe
+      {false, "test_copy2_s.b2frame"}, // disk - sframe
   ));
 }
 
diff --git a/tests/test_insert_chunk.c b/tests/test_insert_chunk.c
index 30390ead..a0384fbf 100644
--- a/tests/test_insert_chunk.c
+++ b/tests/test_insert_chunk.c
@@ -49,9 +49,9 @@ typedef struct {
 
 test_storage tstorage[] = {
     {false, NULL},  // memory - schunk
-    {true, NULL},  // memory - frame
-    {true, "test_insert_chunk.b2frame"}, // disk - frame
-    {false, "test_insert_chunk.b2sframe"}, // disk - sframe
+    {true, NULL},  // memory - cframe
+    {true, "test_insert_chunk.b2frame"}, // disk - cframe
+    {false, "test_insert_chunk_s.b2frame"}, // disk - sframe
 };
 
 bool tcopy[] = {
diff --git a/tests/test_reorder_offsets.c b/tests/test_reorder_offsets.c
index c0ba03f8..345f479f 100644
--- a/tests/test_reorder_offsets.c
+++ b/tests/test_reorder_offsets.c
@@ -33,10 +33,10 @@ typedef struct {
 }test_storage;
 
 test_storage tstorage[] = {
-    // {false, NULL},  // memory - schunk
-    // {true, NULL},  // memory - frame
-    // {true, "test_reorder_offsets.b2frame"}, // disk - frame
-    {false, "test_reorder_offsets.b2sframe"}, // disk - sframe
+    {false, NULL},  // memory - schunk
+    {true, NULL},  // memory - frame
+    {true, "test_reorder_offsets.b2frame"}, // disk - cframe
+    {false, "test_reorder_offsets_s.b2frame"}, // disk - sframe
 };
 
 int32_t tnchunks[] = {5, 12, 24, 33, 1};
diff --git a/tests/test_sframe.c b/tests/test_sframe.c
index 19e9feee..4b4b9772 100644
--- a/tests/test_sframe.c
+++ b/tests/test_sframe.c
@@ -264,56 +264,56 @@ static char* test_sframe_simple(void) {
 
 
 static char *all_tests(void) {
-  directory = "dir1.b2sframe";
+  directory = "dir1.b2frame";
 
   nchunks = 0;
   mu_run_test(test_sframe_simple);
 
   nchunks = 1;
   mu_run_test(test_sframe_simple);
 
   nchunks = 2;
   mu_run_test(test_sframe_simple);
 
   nchunks = 10;
   mu_run_test(test_sframe_simple);
 
   // Check directory with a trailing slash
-  directory = "dir1.b2sframe/";
+  directory = "dir1.b2frame/";
   nchunks = 0;
   mu_run_test(test_sframe_simple);
 
   nchunks = 1;
   mu_run_test(test_sframe_simple);
 
   // Iterate over all different parameters
   for (int i = 0; i < (int)sizeof(nchunks_) / (int)sizeof(int); i++) {
     nchunks = nchunks_[i];
     for (int isplits = 0; isplits < 2; isplits++) {
       for (int imultithread = 0; imultithread < 2; imultithread++) {
         for (int ifree_new = 0; ifree_new < 2; ifree_new++) {
           for (int ifilter_pipeline = 0; ifilter_pipeline < 2; ifilter_pipeline++) {
             for (int imetalayers = 0; imetalayers < 2; imetalayers++) {
               for (int iusermeta = 0; iusermeta < 2; iusermeta++) {
                 splits = (bool) isplits;
                 multithread = (bool) imultithread;
                 free_new = (bool) ifree_new;
                 filter_pipeline = (bool) ifilter_pipeline;
                 metalayers = (bool) imetalayers;
                 usermeta = (bool) iusermeta;
-                snprintf(buf, sizeof(buf), "test_sframe_nc%d.b2sframe", nchunks);
+                snprintf(buf, sizeof(buf), "test_sframe_nc%d.b2frame", nchunks);
                 directory = buf;
                 mu_run_test(test_sframe);
-                snprintf(buf, sizeof(buf), "test_sframe_nc%d.b2sframe/", nchunks);
+                snprintf(buf, sizeof(buf), "test_sframe_nc%d.b2frame/", nchunks);
                 directory = buf;
                 mu_run_test(test_sframe);
               }
             }
           }
         }
       }
     }
   }
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_sframe_lazychunk.c b/tests/test_sframe_lazychunk.c
index 9fe5f132..45afa16b 100644
--- a/tests/test_sframe_lazychunk.c
+++ b/tests/test_sframe_lazychunk.c
@@ -107,77 +107,77 @@ static char* test_lazy_chunk(void) {
 }
 
 static char *all_tests(void) {
-  directory = "dir1.b2sframe/";
+  directory = "dir1.b2frame/";
   nchunks = 0;
   clevel = 5;
   nthreads = 1;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 1;
   clevel = 5;
   nthreads = 2;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 1;
   clevel = 0;
   nthreads = 2;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 10;
   clevel = 5;
   nthreads = 1;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 10;
   clevel = 5;
   nthreads = 2;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 10;
   clevel = 0;
   nthreads = 1;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 10;
   clevel = 0;
   nthreads = 2;
   mu_run_test(test_lazy_chunk);
 
-  directory = "dir1.b2sframe";
+  directory = "dir1.b2frame";
   nchunks = 0;
   clevel = 5;
   nthreads = 1;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 1;
   clevel = 5;
   nthreads = 2;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 1;
   clevel = 0;
   nthreads = 2;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 10;
   clevel = 5;
   nthreads = 1;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 10;
   clevel = 5;
   nthreads = 2;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 10;
   clevel = 0;
   nthreads = 1;
   mu_run_test(test_lazy_chunk);
 
   nchunks = 10;
   clevel = 0;
   nthreads = 2;
   mu_run_test(test_lazy_chunk);
 
   return EXIT_SUCCESS;
 }
diff --git a/tests/test_update_chunk.c b/tests/test_update_chunk.c
index c326171b..a0d05798 100644
--- a/tests/test_update_chunk.c
+++ b/tests/test_update_chunk.c
@@ -46,9 +46,9 @@ typedef struct {
 
 test_storage tstorage[] = {
     {false, NULL},  // memory - schunk
-    {true, NULL},  // memory - frame
-    {true, "test_update_chunk.b2frame"}, // disk - frame
-    {false, "test_update_chunk.b2sframe"}, // disk - sframe
+    {true, NULL},  // memory - cframe
+    {true, "test_update_chunk.b2frame"}, // disk - cframe
+    {false, "test_update_chunk_s.b2frame"}, // disk - sframe
 };
 
 static char* test_update_chunk(void) {
diff --git a/tests/test_zero_runlen.c b/tests/test_zero_runlen.c
index e9606c03..8caa473b 100644
--- a/tests/test_zero_runlen.c
+++ b/tests/test_zero_runlen.c
@@ -45,22 +45,22 @@ CUTEST_TEST_DATA(zero_runlen) {
 CUTEST_TEST_SETUP(zero_runlen) {
   blosc_init();
   data->cparams = BLOSC2_CPARAMS_DEFAULTS;
   data->cparams.typesize = sizeof(int32_t);
   data->cparams.compcode = BLOSC_BLOSCLZ;
   data->cparams.clevel = 9;
   data->cparams.nthreads = NTHREADS;
 
   CUTEST_PARAMETRIZE(svalue, int, CUTEST_DATA(
       ZERO_DETECTION,
       CHECK_ZEROS,
       CHECK_NANS,
       CHECK_VALUES
   ));
   CUTEST_PARAMETRIZE(backend, test_zero_runlen_backend, CUTEST_DATA(
       {false, NULL},  // memory - schunk
-      {true, NULL},  // memory - frame
-      {true, "test_zero_runlen.b2frame"}, // disk - frame
-      {false, "test_zero_runlen.b2sframe"}, // disk - sframe
+      {true, NULL},  // memory - cframe
+      {true, "test_zero_runlen.b2frame"}, // disk - cframe
+      {false, "test_zero_runlen_s.b2frame"}, // disk - sframe
   ));
 }
 
