commit 60288a5083135a89f1ebb8d3608d53769dbe6417
Merge: aedd2a33d f630fded4
Author: Sean Parkinson <sean@wolfssl.com>
Date:   Wed Jul 21 09:00:03 2021 +1000

    Merge pull request #4222 from TakayukiMatsuo/tk12625
    
    SSL APIs: Add sanity check to some APIs

diff --git a/src/ssl.c b/src/ssl.c
index 6178ea557..27317ff07 100644
--- a/src/ssl.c
+++ b/src/ssl.c
@@ -2897,31 +2897,36 @@ static int _Rehandshake(WOLFSSL* ssl)
 /* do a secure renegotiation handshake, user forced, we discourage */
 int wolfSSL_Rehandshake(WOLFSSL* ssl)
 {
-    int ret = WOLFSSL_SUCCESS;
+    int ret;
     WOLFSSL_ENTER("wolfSSL_Rehandshake");
 
+    if (ssl == NULL)
+        return WOLFSSL_FAILURE;
+
+    ret = WOLFSSL_SUCCESS;
+
     if (ssl->options.side == WOLFSSL_SERVER_END) {
         /* Reset option to send certificate verify. */
         ssl->options.sendVerify = 0;
     }
     else {
         /* Reset resuming flag to do full secure handshake. */
         ssl->options.resuming = 0;
         #ifdef HAVE_SESSION_TICKET
             /* Clearing the ticket. */
             ret = wolfSSL_UseSessionTicket(ssl);
         #endif
     }
 
 #ifdef HAVE_SESSION_TICKET
     if (ret == WOLFSSL_SUCCESS)
 #endif
         ret = _Rehandshake(ssl);
 
     return ret;
 }
 
 
 #ifndef NO_WOLFSSL_CLIENT
 
 /* do a secure resumption handshake, user forced, we discourage */
@@ -4082,9 +4087,12 @@ WOLFSSL_ABI
 int wolfSSL_pending(WOLFSSL* ssl)
 {
     WOLFSSL_ENTER("SSL_pending");
+    if (ssl == NULL)
+        return WOLFSSL_FAILURE;
+
     return ssl->buffers.clearOutputBuffer.length;
 }
 
 
 #ifndef WOLFSSL_LEANPSK
 /* turn on handshake group messages for context */
@@ -11693,25 +11701,29 @@ WOLFSSL_ABI
 long wolfSSL_CTX_set_session_cache_mode(WOLFSSL_CTX* ctx, long mode)
 {
     WOLFSSL_ENTER("SSL_CTX_set_session_cache_mode");
+
+    if (ctx == NULL)
+        return WOLFSSL_FAILURE;
+
     if (mode == WOLFSSL_SESS_CACHE_OFF)
         ctx->sessionCacheOff = 1;
 
     if ((mode & WOLFSSL_SESS_CACHE_NO_AUTO_CLEAR) != 0)
         ctx->sessionCacheFlushOff = 1;
 
 #ifdef HAVE_EXT_CACHE
     if ((mode & WOLFSSL_SESS_CACHE_NO_INTERNAL_STORE) != 0)
         ctx->internalCacheOff = 1;
 #endif
 
     return WOLFSSL_SUCCESS;
 }
 
 #endif /* NO_SESSION_CACHE */
 
 
 #if !defined(NO_CERTS)
 #if defined(PERSIST_CERT_CACHE)
 
 
 #define WOLFSSL_CACHE_CERT_VERSION 1
@@ -14901,2223 +14913,2227 @@ int wolfSSL_check_domain_name(WOLFSSL* ssl, const char* dn)
 /* turn on wolfSSL zlib compression
    returns WOLFSSL_SUCCESS for success, else error (not built in)
 */
 int wolfSSL_set_compression(WOLFSSL* ssl)
 {
     WOLFSSL_ENTER("wolfSSL_set_compression");
     (void)ssl;
 #ifdef HAVE_LIBZ
     ssl->options.usingCompression = 1;
     return WOLFSSL_SUCCESS;
 #else
     return NOT_COMPILED_IN;
 #endif
 }
 
 
 #ifndef USE_WINDOWS_API
     #ifndef NO_WRITEV
 
         /* simulate writev semantics, doesn't actually do block at a time though
            because of SSL_write behavior and because front adds may be small */
         int wolfSSL_writev(WOLFSSL* ssl, const struct iovec* iov, int iovcnt)
         {
         #ifdef WOLFSSL_SMALL_STACK
             byte   staticBuffer[1]; /* force heap usage */
         #else
             byte   staticBuffer[FILE_BUFFER_SIZE];
         #endif
             byte* myBuffer  = staticBuffer;
             int   dynamic   = 0;
             int   sending   = 0;
             int   idx       = 0;
             int   i;
             int   ret;
 
             WOLFSSL_ENTER("wolfSSL_writev");
 
             for (i = 0; i < iovcnt; i++)
                 sending += (int)iov[i].iov_len;
 
             if (sending > (int)sizeof(staticBuffer)) {
                 myBuffer = (byte*)XMALLOC(sending, ssl->heap,
                                                            DYNAMIC_TYPE_WRITEV);
                 if (!myBuffer)
                     return MEMORY_ERROR;
 
                 dynamic = 1;
             }
 
             for (i = 0; i < iovcnt; i++) {
                 XMEMCPY(&myBuffer[idx], iov[i].iov_base, iov[i].iov_len);
                 idx += (int)iov[i].iov_len;
             }
 
            /* myBuffer may not initialized fully, but the sending length will be */
             PRAGMA_GCC_IGNORE("GCC diagnostic ignored \"-Wmaybe-uninitialized\"");
             ret = wolfSSL_write(ssl, myBuffer, sending);
             PRAGMA_GCC_POP;
 
             if (dynamic)
                 XFREE(myBuffer, ssl->heap, DYNAMIC_TYPE_WRITEV);
 
             return ret;
         }
     #endif
 #endif
 
 
 #ifdef WOLFSSL_CALLBACKS
 
     typedef struct itimerval Itimerval;
 
     /* don't keep calling simple functions while setting up timer and signals
        if no inlining these are the next best */
 
     #define AddTimes(a, b, c)                       \
         do {                                        \
             c.tv_sec  = a.tv_sec  + b.tv_sec;       \
             c.tv_usec = a.tv_usec + b.tv_usec;      \
             if (c.tv_usec >=  1000000) {            \
                 c.tv_sec++;                         \
                 c.tv_usec -= 1000000;               \
             }                                       \
         } while (0)
 
 
     #define SubtractTimes(a, b, c)                  \
         do {                                        \
             c.tv_sec  = a.tv_sec  - b.tv_sec;       \
             c.tv_usec = a.tv_usec - b.tv_usec;      \
             if (c.tv_usec < 0) {                    \
                 c.tv_sec--;                         \
                 c.tv_usec += 1000000;               \
             }                                       \
         } while (0)
 
     #define CmpTimes(a, b, cmp)                     \
         ((a.tv_sec  ==  b.tv_sec) ?                 \
             (a.tv_usec cmp b.tv_usec) :             \
             (a.tv_sec  cmp b.tv_sec))               \
 
 
     /* do nothing handler */
     static void myHandler(int signo)
     {
         (void)signo;
         return;
     }
 
 
     static int wolfSSL_ex_wrapper(WOLFSSL* ssl, HandShakeCallBack hsCb,
                                  TimeoutCallBack toCb, WOLFSSL_TIMEVAL timeout)
     {
         int       ret        = WOLFSSL_FATAL_ERROR;
         int       oldTimerOn = 0;   /* was timer already on */
         WOLFSSL_TIMEVAL startTime;
         WOLFSSL_TIMEVAL endTime;
         WOLFSSL_TIMEVAL totalTime;
         Itimerval myTimeout;
         Itimerval oldTimeout; /* if old timer adjust from total time to reset */
         struct sigaction act, oact;
 
         #define ERR_OUT(x) { ssl->hsInfoOn = 0; ssl->toInfoOn = 0; return x; }
 
         if (hsCb) {
             ssl->hsInfoOn = 1;
             InitHandShakeInfo(&ssl->handShakeInfo, ssl);
         }
         if (toCb) {
             ssl->toInfoOn = 1;
             InitTimeoutInfo(&ssl->timeoutInfo);
 
             if (gettimeofday(&startTime, 0) < 0)
                 ERR_OUT(GETTIME_ERROR);
 
             /* use setitimer to simulate getitimer, init 0 myTimeout */
             myTimeout.it_interval.tv_sec  = 0;
             myTimeout.it_interval.tv_usec = 0;
             myTimeout.it_value.tv_sec     = 0;
             myTimeout.it_value.tv_usec    = 0;
             if (setitimer(ITIMER_REAL, &myTimeout, &oldTimeout) < 0)
                 ERR_OUT(SETITIMER_ERROR);
 
             if (oldTimeout.it_value.tv_sec || oldTimeout.it_value.tv_usec) {
                 oldTimerOn = 1;
 
                 /* is old timer going to expire before ours */
                 if (CmpTimes(oldTimeout.it_value, timeout, <)) {
                     timeout.tv_sec  = oldTimeout.it_value.tv_sec;
                     timeout.tv_usec = oldTimeout.it_value.tv_usec;
                 }
             }
             myTimeout.it_value.tv_sec  = timeout.tv_sec;
             myTimeout.it_value.tv_usec = timeout.tv_usec;
 
             /* set up signal handler, don't restart socket send/recv */
             act.sa_handler = myHandler;
             sigemptyset(&act.sa_mask);
             act.sa_flags = 0;
 #ifdef SA_INTERRUPT
             act.sa_flags |= SA_INTERRUPT;
 #endif
             if (sigaction(SIGALRM, &act, &oact) < 0)
                 ERR_OUT(SIGACT_ERROR);
 
             if (setitimer(ITIMER_REAL, &myTimeout, 0) < 0)
                 ERR_OUT(SETITIMER_ERROR);
         }
 
         /* do main work */
 #ifndef NO_WOLFSSL_CLIENT
         if (ssl->options.side == WOLFSSL_CLIENT_END)
             ret = wolfSSL_connect(ssl);
 #endif
 #ifndef NO_WOLFSSL_SERVER
         if (ssl->options.side == WOLFSSL_SERVER_END)
             ret = wolfSSL_accept(ssl);
 #endif
 
         /* do callbacks */
         if (toCb) {
             if (oldTimerOn) {
                 gettimeofday(&endTime, 0);
                 SubtractTimes(endTime, startTime, totalTime);
                 /* adjust old timer for elapsed time */
                 if (CmpTimes(totalTime, oldTimeout.it_value, <))
                     SubtractTimes(oldTimeout.it_value, totalTime,
                                   oldTimeout.it_value);
                 else {
                     /* reset value to interval, may be off */
                     oldTimeout.it_value.tv_sec = oldTimeout.it_interval.tv_sec;
                     oldTimeout.it_value.tv_usec =oldTimeout.it_interval.tv_usec;
                 }
                 /* keep iter the same whether there or not */
             }
             /* restore old handler */
             if (sigaction(SIGALRM, &oact, 0) < 0)
                 ret = SIGACT_ERROR;    /* more pressing error, stomp */
             else
                 /* use old settings which may turn off (expired or not there) */
                 if (setitimer(ITIMER_REAL, &oldTimeout, 0) < 0)
                     ret = SETITIMER_ERROR;
 
             /* if we had a timeout call callback */
             if (ssl->timeoutInfo.timeoutName[0]) {
                 ssl->timeoutInfo.timeoutValue.tv_sec  = timeout.tv_sec;
                 ssl->timeoutInfo.timeoutValue.tv_usec = timeout.tv_usec;
                 (toCb)(&ssl->timeoutInfo);
             }
             /* clean up */
             FreeTimeoutInfo(&ssl->timeoutInfo, ssl->heap);
             ssl->toInfoOn = 0;
         }
         if (hsCb) {
             FinishHandShakeInfo(&ssl->handShakeInfo);
             (hsCb)(&ssl->handShakeInfo);
             ssl->hsInfoOn = 0;
         }
         return ret;
     }
 
 
 #ifndef NO_WOLFSSL_CLIENT
 
     int wolfSSL_connect_ex(WOLFSSL* ssl, HandShakeCallBack hsCb,
                           TimeoutCallBack toCb, WOLFSSL_TIMEVAL timeout)
     {
         WOLFSSL_ENTER("wolfSSL_connect_ex");
         return wolfSSL_ex_wrapper(ssl, hsCb, toCb, timeout);
     }
 
 #endif
 
 
 #ifndef NO_WOLFSSL_SERVER
 
     int wolfSSL_accept_ex(WOLFSSL* ssl, HandShakeCallBack hsCb,
                          TimeoutCallBack toCb, WOLFSSL_TIMEVAL timeout)
     {
         WOLFSSL_ENTER("wolfSSL_accept_ex");
         return wolfSSL_ex_wrapper(ssl, hsCb, toCb, timeout);
     }
 
 #endif
 
 #endif /* WOLFSSL_CALLBACKS */
 
 
 #ifndef NO_PSK
 
     void wolfSSL_CTX_set_psk_client_callback(WOLFSSL_CTX* ctx,
                                          wc_psk_client_callback cb)
     {
         WOLFSSL_ENTER("SSL_CTX_set_psk_client_callback");
 
         if (ctx == NULL)
             return;
 
         ctx->havePSK = 1;
         ctx->client_psk_cb = cb;
     }
 
     void wolfSSL_set_psk_client_callback(WOLFSSL* ssl,wc_psk_client_callback cb)
     {
         byte haveRSA = 1;
         int  keySz   = 0;
 
         WOLFSSL_ENTER("SSL_set_psk_client_callback");
 
         if (ssl == NULL)
             return;
 
         ssl->options.havePSK = 1;
         ssl->options.client_psk_cb = cb;
 
         #ifdef NO_RSA
             haveRSA = 0;
         #endif
         #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
         #endif
         InitSuites(ssl->suites, ssl->version, keySz, haveRSA, TRUE,
                    ssl->options.haveDH, ssl->options.haveNTRU,
                    ssl->options.haveECDSAsig, ssl->options.haveECC,
                    ssl->options.haveStaticECC, ssl->options.haveAnon,
                    ssl->options.side);
     }
     #ifdef OPENSSL_EXTRA
     /**
      * set call back function for psk session use
      * @param ssl  a pointer to WOLFSSL structure
      * @param cb   a function pointer to wc_psk_use_session_cb
      * @return none
      */
     void wolfSSL_set_psk_use_session_callback(WOLFSSL* ssl, 
                                                 wc_psk_use_session_cb_func cb)
     {
         WOLFSSL_ENTER("wolfSSL_set_psk_use_session_callback");
         
         ssl->options.havePSK = 1;
         ssl->options.session_psk_cb = cb;
         
         WOLFSSL_LEAVE("wolfSSL_set_psk_use_session_callback", WOLFSSL_SUCCESS);
     }
     #endif
     
     void wolfSSL_CTX_set_psk_server_callback(WOLFSSL_CTX* ctx,
                                          wc_psk_server_callback cb)
     {
         WOLFSSL_ENTER("SSL_CTX_set_psk_server_callback");
         if (ctx == NULL)
             return;
         ctx->havePSK = 1;
         ctx->server_psk_cb = cb;
     }
 
     void wolfSSL_set_psk_server_callback(WOLFSSL* ssl,wc_psk_server_callback cb)
     {
         byte haveRSA = 1;
         int  keySz   = 0;
 
         WOLFSSL_ENTER("SSL_set_psk_server_callback");
         if (ssl == NULL)
             return;
 
         ssl->options.havePSK = 1;
         ssl->options.server_psk_cb = cb;
 
         #ifdef NO_RSA
             haveRSA = 0;
         #endif
         #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
         #endif
         InitSuites(ssl->suites, ssl->version, keySz, haveRSA, TRUE,
                    ssl->options.haveDH, ssl->options.haveNTRU,
                    ssl->options.haveECDSAsig, ssl->options.haveECC,
                    ssl->options.haveStaticECC, ssl->options.haveAnon,
                    ssl->options.side);
     }
 
     const char* wolfSSL_get_psk_identity_hint(const WOLFSSL* ssl)
     {
         WOLFSSL_ENTER("SSL_get_psk_identity_hint");
 
         if (ssl == NULL || ssl->arrays == NULL)
             return NULL;
 
         return ssl->arrays->server_hint;
     }
 
 
     const char* wolfSSL_get_psk_identity(const WOLFSSL* ssl)
     {
         WOLFSSL_ENTER("SSL_get_psk_identity");
 
         if (ssl == NULL || ssl->arrays == NULL)
             return NULL;
 
         return ssl->arrays->client_identity;
     }
 
     int wolfSSL_CTX_use_psk_identity_hint(WOLFSSL_CTX* ctx, const char* hint)
     {
         WOLFSSL_ENTER("SSL_CTX_use_psk_identity_hint");
         if (hint == 0)
             ctx->server_hint[0] = '\0';
         else {
             /* Qt does not call CTX_set_*_psk_callbacks where havePSK is set */
             #ifdef WOLFSSL_QT
             ctx->havePSK=1;
             #endif
             XSTRNCPY(ctx->server_hint, hint, MAX_PSK_ID_LEN);
             ctx->server_hint[MAX_PSK_ID_LEN] = '\0'; /* null term */
         }
         return WOLFSSL_SUCCESS;
     }
 
     int wolfSSL_use_psk_identity_hint(WOLFSSL* ssl, const char* hint)
     {
         WOLFSSL_ENTER("SSL_use_psk_identity_hint");
 
         if (ssl == NULL || ssl->arrays == NULL)
             return WOLFSSL_FAILURE;
 
         if (hint == 0)
             ssl->arrays->server_hint[0] = 0;
         else {
             XSTRNCPY(ssl->arrays->server_hint, hint,
                                             sizeof(ssl->arrays->server_hint)-1);
             ssl->arrays->server_hint[sizeof(ssl->arrays->server_hint)-1] = '\0';
         }
         return WOLFSSL_SUCCESS;
     }
 
     void* wolfSSL_get_psk_callback_ctx(WOLFSSL* ssl)
     {
         return ssl ? ssl->options.psk_ctx : NULL;
     }
     void* wolfSSL_CTX_get_psk_callback_ctx(WOLFSSL_CTX* ctx)
     {
         return ctx ? ctx->psk_ctx : NULL;
     }
     int wolfSSL_set_psk_callback_ctx(WOLFSSL* ssl, void* psk_ctx)
     {
         if (ssl == NULL)
             return WOLFSSL_FAILURE;
         ssl->options.psk_ctx = psk_ctx;
         return WOLFSSL_SUCCESS;
     }
     int wolfSSL_CTX_set_psk_callback_ctx(WOLFSSL_CTX* ctx, void* psk_ctx)
     {
         if (ctx == NULL)
             return WOLFSSL_FAILURE;
         ctx->psk_ctx = psk_ctx;
         return WOLFSSL_SUCCESS;
     }
 #endif /* NO_PSK */
 
 
 #ifdef HAVE_ANON
 
     int wolfSSL_CTX_allow_anon_cipher(WOLFSSL_CTX* ctx)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_allow_anon_cipher");
 
         if (ctx == NULL)
             return WOLFSSL_FAILURE;
 
         ctx->haveAnon = 1;
 
         return WOLFSSL_SUCCESS;
     }
 
 #endif /* HAVE_ANON */
 
 
 #ifndef NO_CERTS
 /* used to be defined on NO_FILESYSTEM only, but are generally useful */
 
     int wolfSSL_CTX_load_verify_buffer_ex(WOLFSSL_CTX* ctx,
                                          const unsigned char* in,
                                          long sz, int format, int userChain,
                                          word32 flags)
     {
         int verify;
         int ret = WOLFSSL_FAILURE;
 
         WOLFSSL_ENTER("wolfSSL_CTX_load_verify_buffer_ex");
 
         verify = GET_VERIFY_SETTING_CTX(ctx);
         if (flags & WOLFSSL_LOAD_FLAG_DATE_ERR_OKAY)
             verify = VERIFY_SKIP_DATE;
 
         if (format == WOLFSSL_FILETYPE_PEM)
             ret = ProcessChainBuffer(ctx, in, sz, format, CA_TYPE, NULL,
                                       verify);
         else
             ret = ProcessBuffer(ctx, in, sz, format, CA_TYPE, NULL, NULL,
                                  userChain, verify);
         WOLFSSL_LEAVE("wolfSSL_CTX_load_verify_buffer_ex", ret);
         return ret;
     }
 
     /* wolfSSL extension allows DER files to be loaded from buffers as well */
     int wolfSSL_CTX_load_verify_buffer(WOLFSSL_CTX* ctx,
                                        const unsigned char* in,
                                        long sz, int format)
     {
         return wolfSSL_CTX_load_verify_buffer_ex(ctx, in, sz, format, 0,
             WOLFSSL_LOAD_VERIFY_DEFAULT_FLAGS);
     }
 
     int wolfSSL_CTX_load_verify_chain_buffer_format(WOLFSSL_CTX* ctx,
                                        const unsigned char* in,
                                        long sz, int format)
     {
         return wolfSSL_CTX_load_verify_buffer_ex(ctx, in, sz, format, 1,
             WOLFSSL_LOAD_VERIFY_DEFAULT_FLAGS);
     }
 
 
 #ifdef WOLFSSL_TRUST_PEER_CERT
     int wolfSSL_CTX_trust_peer_buffer(WOLFSSL_CTX* ctx,
                                        const unsigned char* in,
                                        long sz, int format)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_trust_peer_buffer");
 
         /* sanity check on arguments */
         if (sz < 0 || in == NULL || ctx == NULL) {
             return BAD_FUNC_ARG;
         }
 
         if (format == WOLFSSL_FILETYPE_PEM)
             return ProcessChainBuffer(ctx, in, sz, format, TRUSTED_PEER_TYPE,
                                       NULL, GET_VERIFY_SETTING_CTX(ctx));
         else
             return ProcessBuffer(ctx, in, sz, format, TRUSTED_PEER_TYPE, NULL,
                                  NULL, 0, GET_VERIFY_SETTING_CTX(ctx));
     }
 #endif /* WOLFSSL_TRUST_PEER_CERT */
 
 
     int wolfSSL_CTX_use_certificate_buffer(WOLFSSL_CTX* ctx,
                                  const unsigned char* in, long sz, int format)
     {
         int ret = WOLFSSL_FAILURE;
 
         WOLFSSL_ENTER("wolfSSL_CTX_use_certificate_buffer");
         ret = ProcessBuffer(ctx, in, sz, format, CERT_TYPE, NULL, NULL, 0,
                              GET_VERIFY_SETTING_CTX(ctx));
         WOLFSSL_LEAVE("wolfSSL_CTX_use_certificate_buffer", ret);
         return ret;
     }
 
 
     int wolfSSL_CTX_use_PrivateKey_buffer(WOLFSSL_CTX* ctx,
                                  const unsigned char* in, long sz, int format)
     {
         int ret = WOLFSSL_FAILURE;
 
         WOLFSSL_ENTER("wolfSSL_CTX_use_PrivateKey_buffer");
         ret = ProcessBuffer(ctx, in, sz, format, PRIVATEKEY_TYPE, NULL, NULL,
                              0, GET_VERIFY_SETTING_CTX(ctx));
         WOLFSSL_LEAVE("wolfSSL_CTX_use_PrivateKey_buffer", ret);
         return ret;
     }
 
 #ifdef HAVE_PKCS11
     int wolfSSL_CTX_use_PrivateKey_id(WOLFSSL_CTX* ctx, const unsigned char* id,
                                       long sz, int devId, long keySz)
     {
         int ret = wolfSSL_CTX_use_PrivateKey_Id(ctx, id, sz, devId);
 
         if (ret == WOLFSSL_SUCCESS)
             ctx->privateKeySz = (word32)keySz;
 
         return ret;
     }
 
     int wolfSSL_CTX_use_PrivateKey_Id(WOLFSSL_CTX* ctx, const unsigned char* id,
                                       long sz, int devId)
     {
         int ret = WOLFSSL_FAILURE;
 
         FreeDer(&ctx->privateKey);
         if (AllocDer(&ctx->privateKey, (word32)sz, PRIVATEKEY_TYPE,
                                                               ctx->heap) == 0) {
             XMEMCPY(ctx->privateKey->buffer, id, sz);
             ctx->privateKeyId = 1;
             if (devId != INVALID_DEVID)
                 ctx->privateKeyDevId = devId;
             else
                 ctx->privateKeyDevId = ctx->devId;
 
             ret = WOLFSSL_SUCCESS;
         }
 
         return ret;
     }
 
     int wolfSSL_CTX_use_PrivateKey_Label(WOLFSSL_CTX* ctx, const char* label,
                                          int devId)
     {
         int ret = WOLFSSL_FAILURE;
         word32 sz = (word32)XSTRLEN(label) + 1;
 
         FreeDer(&ctx->privateKey);
         if (AllocDer(&ctx->privateKey, (word32)sz, PRIVATEKEY_TYPE,
                                                               ctx->heap) == 0) {
             XMEMCPY(ctx->privateKey->buffer, label, sz);
             ctx->privateKeyLabel = 1;
             if (devId != INVALID_DEVID)
                 ctx->privateKeyDevId = devId;
             else
                 ctx->privateKeyDevId = ctx->devId;
 
             ret = WOLFSSL_SUCCESS;
         }
 
         return ret;
     }
 #endif
 
     int wolfSSL_CTX_use_certificate_chain_buffer_format(WOLFSSL_CTX* ctx,
                                  const unsigned char* in, long sz, int format)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_use_certificate_chain_buffer_format");
         return ProcessBuffer(ctx, in, sz, format, CERT_TYPE, NULL, NULL, 1,
                              GET_VERIFY_SETTING_CTX(ctx));
     }
 
     int wolfSSL_CTX_use_certificate_chain_buffer(WOLFSSL_CTX* ctx,
                                  const unsigned char* in, long sz)
     {
         return wolfSSL_CTX_use_certificate_chain_buffer_format(ctx, in, sz,
                                                             WOLFSSL_FILETYPE_PEM);
     }
 
 
 #ifndef NO_DH
 
     /* server wrapper for ctx or ssl Diffie-Hellman parameters */
     static int wolfSSL_SetTmpDH_buffer_wrapper(WOLFSSL_CTX* ctx, WOLFSSL* ssl,
                                                const unsigned char* buf,
                                                long sz, int format)
     {
         DerBuffer* der = NULL;
         int    ret      = 0;
         word32 pSz = MAX_DH_SIZE;
         word32 gSz = MAX_DH_SIZE;
     #ifdef WOLFSSL_SMALL_STACK
         byte*  p = NULL;
         byte*  g = NULL;
     #else
         byte   p[MAX_DH_SIZE];
         byte   g[MAX_DH_SIZE];
     #endif
 
         if (ctx == NULL || buf == NULL)
             return BAD_FUNC_ARG;
 
         ret = AllocDer(&der, 0, DH_PARAM_TYPE, ctx->heap);
         if (ret != 0) {
             return ret;
         }
         der->buffer = (byte*)buf;
         der->length = (word32)sz;
 
     #ifdef WOLFSSL_SMALL_STACK
         p = (byte*)XMALLOC(pSz, NULL, DYNAMIC_TYPE_PUBLIC_KEY);
         g = (byte*)XMALLOC(gSz, NULL, DYNAMIC_TYPE_PUBLIC_KEY);
 
         if (p == NULL || g == NULL) {
             XFREE(p, NULL, DYNAMIC_TYPE_PUBLIC_KEY);
             XFREE(g, NULL, DYNAMIC_TYPE_PUBLIC_KEY);
             return MEMORY_E;
         }
     #endif
 
         if (format != WOLFSSL_FILETYPE_ASN1 && format != WOLFSSL_FILETYPE_PEM)
             ret = WOLFSSL_BAD_FILETYPE;
         else {
             if (format == WOLFSSL_FILETYPE_PEM) {
 #ifdef WOLFSSL_PEM_TO_DER
                 FreeDer(&der);
                 ret = PemToDer(buf, sz, DH_PARAM_TYPE, &der, ctx->heap,
                                NULL, NULL);
     #ifdef WOLFSSL_WPAS
         #ifndef NO_DSA
                 if (ret < 0) {
                     ret = PemToDer(buf, sz, DSA_PARAM_TYPE, &der, ctx->heap,
                                NULL, NULL);
                 }
         #endif
     #endif /* WOLFSSL_WPAS */
 #else
                 ret = NOT_COMPILED_IN;
 #endif /* WOLFSSL_PEM_TO_DER */
             }
 
             if (ret == 0) {
                 if (wc_DhParamsLoad(der->buffer, der->length, p, &pSz, g, &gSz) < 0)
                     ret = WOLFSSL_BAD_FILETYPE;
                 else if (ssl)
                     ret = wolfSSL_SetTmpDH(ssl, p, pSz, g, gSz);
                 else
                     ret = wolfSSL_CTX_SetTmpDH(ctx, p, pSz, g, gSz);
             }
         }
 
         FreeDer(&der);
 
     #ifdef WOLFSSL_SMALL_STACK
         XFREE(p, NULL, DYNAMIC_TYPE_PUBLIC_KEY);
         XFREE(g, NULL, DYNAMIC_TYPE_PUBLIC_KEY);
     #endif
 
         return ret;
     }
 
 
     /* server Diffie-Hellman parameters, WOLFSSL_SUCCESS on ok */
     int wolfSSL_SetTmpDH_buffer(WOLFSSL* ssl, const unsigned char* buf, long sz,
                                int format)
     {
         if (ssl == NULL)
             return BAD_FUNC_ARG;
 
         return wolfSSL_SetTmpDH_buffer_wrapper(ssl->ctx, ssl, buf, sz, format);
     }
 
 
     /* server ctx Diffie-Hellman parameters, WOLFSSL_SUCCESS on ok */
     int wolfSSL_CTX_SetTmpDH_buffer(WOLFSSL_CTX* ctx, const unsigned char* buf,
                                    long sz, int format)
     {
         return wolfSSL_SetTmpDH_buffer_wrapper(ctx, NULL, buf, sz, format);
     }
 
 #endif /* NO_DH */
 
 
     int wolfSSL_use_certificate_buffer(WOLFSSL* ssl,
                                  const unsigned char* in, long sz, int format)
     {
         WOLFSSL_ENTER("wolfSSL_use_certificate_buffer");
         if (ssl == NULL)
             return BAD_FUNC_ARG;
 
         return ProcessBuffer(ssl->ctx, in, sz, format, CERT_TYPE, ssl, NULL, 0,
                              GET_VERIFY_SETTING_SSL(ssl));
     }
 
 
     int wolfSSL_use_PrivateKey_buffer(WOLFSSL* ssl,
                                  const unsigned char* in, long sz, int format)
     {
         WOLFSSL_ENTER("wolfSSL_use_PrivateKey_buffer");
         if (ssl == NULL)
             return BAD_FUNC_ARG;
 
         return ProcessBuffer(ssl->ctx, in, sz, format, PRIVATEKEY_TYPE,
                              ssl, NULL, 0, GET_VERIFY_SETTING_SSL(ssl));
     }
 
 #ifdef WOLF_CRYPTO_CB
     int wolfSSL_use_PrivateKey_id(WOLFSSL* ssl, const unsigned char* id,
                                   long sz, int devId, long keySz)
     {
         int ret = wolfSSL_use_PrivateKey_Id(ssl, id, sz, devId);
 
         if (ret == WOLFSSL_SUCCESS)
             ssl->buffers.keySz = (word32)keySz;
 
         return ret;
     }
 
     int wolfSSL_use_PrivateKey_Id(WOLFSSL* ssl, const unsigned char* id,
                                   long sz, int devId)
     {
         int ret = WOLFSSL_FAILURE;
 
         if (ssl->buffers.weOwnKey)
             FreeDer(&ssl->buffers.key);
         if (AllocDer(&ssl->buffers.key, (word32)sz, PRIVATEKEY_TYPE,
                                                             ssl->heap) == 0) {
             XMEMCPY(ssl->buffers.key->buffer, id, sz);
             ssl->buffers.weOwnKey = 1;
             ssl->buffers.keyId = 1;
             if (devId != INVALID_DEVID)
                 ssl->buffers.keyDevId = devId;
             else
                 ssl->buffers.keyDevId = ssl->devId;
 
             ret = WOLFSSL_SUCCESS;
         }
 
         return ret;
     }
 
     int wolfSSL_use_PrivateKey_Label(WOLFSSL* ssl, const char* label, int devId)
     {
         int ret = WOLFSSL_FAILURE;
         word32 sz = (word32)XSTRLEN(label) + 1;
 
         if (ssl->buffers.weOwnKey)
             FreeDer(&ssl->buffers.key);
         if (AllocDer(&ssl->buffers.key, (word32)sz, PRIVATEKEY_TYPE,
                                                             ssl->heap) == 0) {
             XMEMCPY(ssl->buffers.key->buffer, label, sz);
             ssl->buffers.weOwnKey = 1;
             ssl->buffers.keyLabel = 1;
             if (devId != INVALID_DEVID)
                 ssl->buffers.keyDevId = devId;
             else
                 ssl->buffers.keyDevId = ssl->devId;
 
             ret = WOLFSSL_SUCCESS;
         }
 
         return ret;
     }
 #endif
 
     int wolfSSL_use_certificate_chain_buffer_format(WOLFSSL* ssl,
                                  const unsigned char* in, long sz, int format)
     {
         WOLFSSL_ENTER("wolfSSL_use_certificate_chain_buffer_format");
         if (ssl == NULL)
             return BAD_FUNC_ARG;
 
         return ProcessBuffer(ssl->ctx, in, sz, format, CERT_TYPE,
                              ssl, NULL, 1, GET_VERIFY_SETTING_SSL(ssl));
     }
 
     int wolfSSL_use_certificate_chain_buffer(WOLFSSL* ssl,
                                  const unsigned char* in, long sz)
     {
         return wolfSSL_use_certificate_chain_buffer_format(ssl, in, sz,
                                                             WOLFSSL_FILETYPE_PEM);
     }
 
 
     /* unload any certs or keys that SSL owns, leave CTX as is
        WOLFSSL_SUCCESS on ok */
     int wolfSSL_UnloadCertsKeys(WOLFSSL* ssl)
     {
         if (ssl == NULL) {
             WOLFSSL_MSG("Null function arg");
             return BAD_FUNC_ARG;
         }
 
         if (ssl->buffers.weOwnCert && !ssl->keepCert) {
             WOLFSSL_MSG("Unloading cert");
             FreeDer(&ssl->buffers.certificate);
             #ifdef KEEP_OUR_CERT
             wolfSSL_X509_free(ssl->ourCert);
             ssl->ourCert = NULL;
             #endif
             ssl->buffers.weOwnCert = 0;
         }
 
         if (ssl->buffers.weOwnCertChain) {
             WOLFSSL_MSG("Unloading cert chain");
             FreeDer(&ssl->buffers.certChain);
             ssl->buffers.weOwnCertChain = 0;
         }
 
         if (ssl->buffers.weOwnKey) {
             WOLFSSL_MSG("Unloading key");
             FreeDer(&ssl->buffers.key);
             ssl->buffers.weOwnKey = 0;
         }
 
         return WOLFSSL_SUCCESS;
     }
 
 
     int wolfSSL_CTX_UnloadCAs(WOLFSSL_CTX* ctx)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_UnloadCAs");
 
         if (ctx == NULL)
             return BAD_FUNC_ARG;
 
         return wolfSSL_CertManagerUnloadCAs(ctx->cm);
     }
 
 
 #ifdef WOLFSSL_TRUST_PEER_CERT
     int wolfSSL_CTX_Unload_trust_peers(WOLFSSL_CTX* ctx)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_Unload_trust_peers");
 
         if (ctx == NULL)
             return BAD_FUNC_ARG;
 
         return wolfSSL_CertManagerUnload_trust_peers(ctx->cm);
     }
 #endif /* WOLFSSL_TRUST_PEER_CERT */
 /* old NO_FILESYSTEM end */
 #endif /* !NO_CERTS */
 
 
 #ifdef OPENSSL_EXTRA
 
     int wolfSSL_add_all_algorithms(void)
     {
         WOLFSSL_ENTER("wolfSSL_add_all_algorithms");
         if (wolfSSL_Init() == WOLFSSL_SUCCESS)
             return WOLFSSL_SUCCESS;
         else
             return WOLFSSL_FATAL_ERROR;
     }
 
     int wolfSSL_OpenSSL_add_all_algorithms_noconf(void)
     {
         WOLFSSL_ENTER("wolfSSL_OpenSSL_add_all_algorithms_noconf");
 
         if  (wolfSSL_add_all_algorithms() == WOLFSSL_FATAL_ERROR)
             return WOLFSSL_FATAL_ERROR;
 
         return  WOLFSSL_SUCCESS;
     }
 
     int wolfSSL_OpenSSL_add_all_algorithms_conf(void)
     {
         WOLFSSL_ENTER("wolfSSL_OpenSSL_add_all_algorithms_conf");
         /* This function is currently the same as
         wolfSSL_OpenSSL_add_all_algorithms_noconf since we do not employ
         the use of a wolfssl.cnf type configuration file and is only used for
         OpenSSL compatability. */
 
         if (wolfSSL_add_all_algorithms() == WOLFSSL_FATAL_ERROR) {
             return WOLFSSL_FATAL_ERROR;
         }
         return WOLFSSL_SUCCESS;
     }
 
    /* returns previous set cache size which stays constant */
     long wolfSSL_CTX_sess_set_cache_size(WOLFSSL_CTX* ctx, long sz)
     {
         /* cache size fixed at compile time in wolfSSL */
         (void)ctx;
         (void)sz;
         WOLFSSL_MSG("session cache is set at compile time");
         #ifndef NO_SESSION_CACHE
             return (long)(SESSIONS_PER_ROW * SESSION_ROWS);
         #else
             return 0;
         #endif
     }
 
 #endif
 
 #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
     void wolfSSL_CTX_set_quiet_shutdown(WOLFSSL_CTX* ctx, int mode)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_set_quiet_shutdown");
         if (mode)
             ctx->quietShutdown = 1;
     }
 
 
     void wolfSSL_set_quiet_shutdown(WOLFSSL* ssl, int mode)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_set_quiet_shutdown");
         if (mode)
             ssl->options.quietShutdown = 1;
     }
 #endif /* OPENSSL_EXTRA || WOLFSSL_EXTRA || WOLFSSL_WPAS_SMALL */
 
 #ifdef OPENSSL_EXTRA
 #ifndef NO_BIO
     void wolfSSL_set_bio(WOLFSSL* ssl, WOLFSSL_BIO* rd, WOLFSSL_BIO* wr)
     {
         WOLFSSL_ENTER("wolfSSL_set_bio");
 
         if (ssl == NULL) {
             WOLFSSL_MSG("Bad argument, ssl was NULL");
             return;
         }
 
         /* free any existing WOLFSSL_BIOs in use but don't free those in
          * a chain */
         if (ssl->biord != NULL) {
             if (ssl->biord != ssl->biowr) {
                 if (ssl->biowr != NULL && ssl->biowr->prev != NULL)
                     wolfSSL_BIO_free(ssl->biowr);
                 ssl->biowr = NULL;
             }
             if (ssl->biord->prev != NULL)
                 wolfSSL_BIO_free(ssl->biord);
             ssl->biord = NULL;
         }
 
         ssl->biord = rd;
         ssl->biowr = wr;
 
         /* set SSL to use BIO callbacks instead */
         if (((ssl->cbioFlag & WOLFSSL_CBIO_RECV) == 0)) {
             ssl->CBIORecv = BioReceive;
         }
         if (((ssl->cbioFlag & WOLFSSL_CBIO_SEND) == 0)) {
             ssl->CBIOSend = BioSend;
         }
 
         /* User programs should always retry reading from these BIOs */
         if (rd) {
             /* User writes to rd */
             BIO_set_retry_write(rd);
         }
         if (wr) {
             /* User reads from wr */
             BIO_set_retry_read(wr);
         }
     }
 #endif /* !NO_BIO */
 #endif /* OPENSSL_EXTRA */
 
 #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA) || defined(HAVE_WEBSERVER)
     void wolfSSL_CTX_set_client_CA_list(WOLFSSL_CTX* ctx,
                                        WOLF_STACK_OF(WOLFSSL_X509_NAME)* names)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_set_client_CA_list");
     #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA)
         if (ctx != NULL)
             ctx->ca_names = names;
     #else
         (void)ctx;
         (void)names;
     #endif
     }
 
 
     /* returns the CA's set on server side or the CA's sent from server when
      * on client side */
 #if defined(SESSION_CERTS) && defined(OPENSSL_ALL)
     WOLF_STACK_OF(WOLFSSL_X509_NAME)* wolfSSL_get_client_CA_list(
             const WOLFSSL* ssl)
     {
         WOLFSSL_ENTER("wolfSSL_get_client_CA_list");
 
         if (ssl == NULL) {
             WOLFSSL_MSG("Bad argument passed to wolfSSL_get_client_CA_list");
             return NULL;
         }
 
         /* return list of CAs sent from the server */
         if (ssl->options.side == WOLFSSL_CLIENT_END) {
             WOLF_STACK_OF(WOLFSSL_X509)* sk;
 
             sk = wolfSSL_get_peer_cert_chain(ssl);
             if (sk != NULL) {
                 WOLF_STACK_OF(WOLFSSL_X509_NAME)* ret;
                 WOLFSSL_X509* x509;
 
                 ret = wolfSSL_sk_X509_NAME_new(NULL);
                 do {
                     x509 = wolfSSL_sk_X509_pop(sk);
                     if (x509 != NULL) {
                         if (wolfSSL_X509_get_isCA(x509)) {
                             if (wolfSSL_sk_X509_NAME_push(ret,
                                     wolfSSL_X509_get_subject_name(x509)) != 0) {
                                 WOLFSSL_MSG("Error pushing X509 name to stack");
                                 /* continue on to try other certificates and
                                  * do not fail out here */
                             }
                         }
                         wolfSSL_X509_free(x509);
                     }
                 } while (x509 != NULL);
                 wolfSSL_sk_X509_free(sk);
                 return ret;
             }
             return NULL;
         }
         else {
             /* currently only can be set in the CTX */
             return ssl->ctx->ca_names;
         }
     }
 #endif /* SESSION_CERTS */
 
 
     #if defined(OPENSSL_ALL) || defined(OPENSSL_EXTRA) || \
         defined(WOLFSSL_NGINX) || defined (WOLFSSL_HAPROXY)
     /* registers client cert callback, called during handshake if server
        requests client auth but user has not loaded client cert/key */
     void wolfSSL_CTX_set_client_cert_cb(WOLFSSL_CTX *ctx, client_cert_cb cb)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_set_client_cert_cb");
 
         if (ctx != NULL) {
             ctx->CBClientCert = cb;
         }
     }
     #endif /* OPENSSL_ALL || OPENSSL_EXTRA || WOLFSSL_NGINX || WOLFSSL_HAPROXY */
 
 #endif /* OPENSSL_EXTRA || WOLFSSL_EXTRA || HAVE_WEBSERVER */
 
 #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA)
     WOLF_STACK_OF(WOLFSSL_X509_NAME)* wolfSSL_CTX_get_client_CA_list(
             const WOLFSSL_CTX *s)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_get_client_CA_list");
 
         if (s == NULL)
             return NULL;
 
         return s->ca_names;
     }
 #endif
 
 #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER)
 #ifndef NO_BIO
     #if !defined(NO_RSA) && !defined(NO_CERTS)
     WOLF_STACK_OF(WOLFSSL_X509_NAME)* wolfSSL_load_client_CA_file(const char* fname)
     {
         /* The webserver build is using this to load a CA into the server
          * for client authentication as an option. Have this return NULL in
          * that case. If OPENSSL_EXTRA is enabled, go ahead and include
          * the function. */
     #ifdef OPENSSL_EXTRA
         WOLFSSL_STACK *list = NULL;
         WOLFSSL_STACK *node;
         WOLFSSL_BIO* bio;
         WOLFSSL_X509 *cert = NULL;
         WOLFSSL_X509_NAME *subjectName = NULL;
         unsigned long err;
 
         WOLFSSL_ENTER("wolfSSL_load_client_CA_file");
 
         bio = wolfSSL_BIO_new_file(fname, "rb");
         if (bio == NULL)
             return NULL;
 
         /* Read each certificate in the chain out of the file. */
         while (wolfSSL_PEM_read_bio_X509(bio, &cert, NULL, NULL) != NULL) {
             subjectName = wolfSSL_X509_get_subject_name(cert);
             if (subjectName == NULL)
                 break;
 
             node = wolfSSL_sk_new_node(NULL);
             if (node == NULL)
                 break;
             node->type = STACK_TYPE_X509_NAME;
 
             /* Need a persistent copy of the subject name. */
             node->data.name = wolfSSL_X509_NAME_dup(subjectName);
             if (node->data.name != NULL) {
                 /*
                 * Original cert will be freed so make sure not to try to access
                 * it in the future.
                 */
                 node->data.name->x509 = NULL;
             }
 
             /* Put node on the front of the list. */
             node->num  = (list == NULL) ? 1 : list->num + 1;
             node->next = list;
             list = node;
 
             wolfSSL_X509_free(cert);
             cert = NULL;
         }
 
         err = wolfSSL_ERR_peek_last_error();
 
         if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
                 ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
             /*
              * wolfSSL_PEM_read_bio_X509 pushes an ASN_NO_PEM_HEADER error
              * to the error queue on file end. This should not be left
              * for the caller to find so we clear the last error.
              */
             wc_RemoveErrorNode(-1);
         }
 
         wolfSSL_X509_free(cert);
         wolfSSL_BIO_free(bio);
         return list;
     #else
         (void)fname;
         return NULL;
     #endif
     }
     #endif
 #endif /* !NO_BIO */
 #endif /* OPENSSL_EXTRA || HAVE_WEBSERVER */
 
 #ifdef OPENSSL_EXTRA
     #if !defined(NO_RSA) && !defined(NO_CERTS)
     int wolfSSL_CTX_add_client_CA(WOLFSSL_CTX* ctx, WOLFSSL_X509* x509)
     {
         WOLFSSL_STACK *node = NULL;
         WOLFSSL_X509_NAME *subjectName = NULL;
 
         WOLFSSL_ENTER("wolfSSL_CTX_add_client_CA");
 
         if (ctx == NULL || x509 == NULL){
             WOLFSSL_MSG("Bad argument");
             return SSL_FAILURE;
         }
 
         subjectName = wolfSSL_X509_get_subject_name(x509);
         if (subjectName == NULL){
             WOLFSSL_MSG("invalid x509 data");
             return SSL_FAILURE;
         }
 
         /* Alloc stack struct */
         node = (WOLF_STACK_OF(WOLFSSL_X509_NAME)*)XMALLOC(
                                            sizeof(WOLF_STACK_OF(WOLFSSL_X509_NAME)),
                                            NULL, DYNAMIC_TYPE_OPENSSL);
         if (node == NULL){
             WOLFSSL_MSG("memory allocation error");
             return SSL_FAILURE;
         }
         XMEMSET(node, 0, sizeof(WOLF_STACK_OF(WOLFSSL_X509_NAME)));
 
         /* Alloc and copy WOLFSSL_X509_NAME */
         node->data.name = (WOLFSSL_X509_NAME*)XMALLOC(
                                               sizeof(WOLFSSL_X509_NAME),
                                               NULL, DYNAMIC_TYPE_OPENSSL);
         if (node->data.name == NULL) {
             XFREE(node, NULL, DYNAMIC_TYPE_OPENSSL);
             WOLFSSL_MSG("memory allocation error");
             return SSL_FAILURE;
         }
         XMEMCPY(node->data.name, subjectName, sizeof(WOLFSSL_X509_NAME));
         XMEMSET(subjectName, 0, sizeof(WOLFSSL_X509_NAME));
 
         /* push new node onto head of stack */
         node->num = (ctx->ca_names == NULL) ? 1 : ctx->ca_names->num + 1;
         node->next = ctx->ca_names;
         ctx->ca_names = node;
         return WOLFSSL_SUCCESS;
     }
     #endif
 
     #ifndef NO_WOLFSSL_STUB
     int wolfSSL_CTX_set_default_verify_paths(WOLFSSL_CTX* ctx)
     {
         /* TODO:, not needed in goahead */
         (void)ctx;
         WOLFSSL_STUB("SSL_CTX_set_default_verify_paths");
         return SSL_NOT_IMPLEMENTED;
     }
     #endif
 
     #if defined(WOLFCRYPT_HAVE_SRP) && !defined(NO_SHA256) \
         && !defined(WC_NO_RNG)
     static const byte srp_N[] = {
         0xEE, 0xAF, 0x0A, 0xB9, 0xAD, 0xB3, 0x8D, 0xD6, 0x9C, 0x33, 0xF8,
         0x0A, 0xFA, 0x8F, 0xC5, 0xE8, 0x60, 0x72, 0x61, 0x87, 0x75, 0xFF,
         0x3C, 0x0B, 0x9E, 0xA2, 0x31, 0x4C, 0x9C, 0x25, 0x65, 0x76, 0xD6,
         0x74, 0xDF, 0x74, 0x96, 0xEA, 0x81, 0xD3, 0x38, 0x3B, 0x48, 0x13,
         0xD6, 0x92, 0xC6, 0xE0, 0xE0, 0xD5, 0xD8, 0xE2, 0x50, 0xB9, 0x8B,
         0xE4, 0x8E, 0x49, 0x5C, 0x1D, 0x60, 0x89, 0xDA, 0xD1, 0x5D, 0xC7,
         0xD7, 0xB4, 0x61, 0x54, 0xD6, 0xB6, 0xCE, 0x8E, 0xF4, 0xAD, 0x69,
         0xB1, 0x5D, 0x49, 0x82, 0x55, 0x9B, 0x29, 0x7B, 0xCF, 0x18, 0x85,
         0xC5, 0x29, 0xF5, 0x66, 0x66, 0x0E, 0x57, 0xEC, 0x68, 0xED, 0xBC,
         0x3C, 0x05, 0x72, 0x6C, 0xC0, 0x2F, 0xD4, 0xCB, 0xF4, 0x97, 0x6E,
         0xAA, 0x9A, 0xFD, 0x51, 0x38, 0xFE, 0x83, 0x76, 0x43, 0x5B, 0x9F,
         0xC6, 0x1D, 0x2F, 0xC0, 0xEB, 0x06, 0xE3
     };
     static const byte srp_g[] = {
         0x02
     };
 
     int wolfSSL_CTX_set_srp_username(WOLFSSL_CTX* ctx, char* username)
     {
         int r = 0;
         SrpSide srp_side = SRP_CLIENT_SIDE;
         byte salt[SRP_SALT_SIZE];
 
         WOLFSSL_ENTER("wolfSSL_CTX_set_srp_username");
         if (ctx == NULL || ctx->srp == NULL || username==NULL)
             return SSL_FAILURE;
 
         if (ctx->method->side == WOLFSSL_SERVER_END){
             srp_side = SRP_SERVER_SIDE;
         } else if (ctx->method->side == WOLFSSL_CLIENT_END){
             srp_side = SRP_CLIENT_SIDE;
         } else {
             WOLFSSL_MSG("Init CTX failed");
             return SSL_FAILURE;
         }
 
         if (wc_SrpInit(ctx->srp, SRP_TYPE_SHA256, srp_side) < 0) {
             WOLFSSL_MSG("Init SRP CTX failed");
             XFREE(ctx->srp, ctx->heap, DYNAMIC_TYPE_SRP);
             ctx->srp = NULL;
             return SSL_FAILURE;
         }
         r = wc_SrpSetUsername(ctx->srp, (const byte*)username,
                               (word32)XSTRLEN(username));
         if (r < 0) {
             WOLFSSL_MSG("fail to set srp username.");
             return SSL_FAILURE;
         }
 
         /* if wolfSSL_CTX_set_srp_password has already been called, */
         /* execute wc_SrpSetPassword here */
         if (ctx->srp_password != NULL) {
             WC_RNG rng;
             if (wc_InitRng(&rng) < 0){
                 WOLFSSL_MSG("wc_InitRng failed");
                 return SSL_FAILURE;
             }
             XMEMSET(salt, 0, sizeof(salt)/sizeof(salt[0]));
             r = wc_RNG_GenerateBlock(&rng, salt, sizeof(salt)/sizeof(salt[0]));
             wc_FreeRng(&rng);
             if (r <  0) {
                 WOLFSSL_MSG("wc_RNG_GenerateBlock failed");   
                 return SSL_FAILURE;
             }
 
             if (wc_SrpSetParams(ctx->srp, srp_N, sizeof(srp_N)/sizeof(srp_N[0]),
                                 srp_g, sizeof(srp_g)/sizeof(srp_g[0]),
                                 salt, sizeof(salt)/sizeof(salt[0])) < 0) {
                 WOLFSSL_MSG("wc_SrpSetParam failed");
                 return SSL_FAILURE;
             }
             r = wc_SrpSetPassword(ctx->srp,
                      (const byte*)ctx->srp_password,
                      (word32)XSTRLEN((char *)ctx->srp_password));
             if (r < 0) {
                 WOLFSSL_MSG("fail to set srp password.");
                 return SSL_FAILURE;
             }
             
             XFREE(ctx->srp_password, ctx->heap, DYNAMIC_TYPE_SRP);
             ctx->srp_password = NULL;
         }
 
         return WOLFSSL_SUCCESS;
     }
 
     int wolfSSL_CTX_set_srp_password(WOLFSSL_CTX* ctx, char* password)
     {
         int r;
         byte salt[SRP_SALT_SIZE];
 
         WOLFSSL_ENTER("wolfSSL_CTX_set_srp_password");
         if (ctx == NULL || ctx->srp == NULL || password == NULL)
             return SSL_FAILURE;
 
         if (ctx->srp->user != NULL) {
             WC_RNG rng;
             if (wc_InitRng(&rng) < 0) {
                 WOLFSSL_MSG("wc_InitRng failed");
                 return SSL_FAILURE;
             }
             XMEMSET(salt, 0, sizeof(salt)/sizeof(salt[0]));
             r = wc_RNG_GenerateBlock(&rng, salt, sizeof(salt)/sizeof(salt[0]));
             wc_FreeRng(&rng);
             if (r <  0) {
                 WOLFSSL_MSG("wc_RNG_GenerateBlock failed");
                 return SSL_FAILURE;
             }
             if (wc_SrpSetParams(ctx->srp, srp_N, sizeof(srp_N)/sizeof(srp_N[0]),
                                 srp_g, sizeof(srp_g)/sizeof(srp_g[0]),
                                 salt, sizeof(salt)/sizeof(salt[0])) < 0){
                 WOLFSSL_MSG("wc_SrpSetParam failed");
                 wc_FreeRng(&rng);
                 return SSL_FAILURE;
             }
             r = wc_SrpSetPassword(ctx->srp, (const byte*)password,
                                   (word32)XSTRLEN(password));
             if (r < 0) {
                 WOLFSSL_MSG("wc_SrpSetPassword failed.");
                 wc_FreeRng(&rng);
                 return SSL_FAILURE;
             }
             if (ctx->srp_password != NULL){
                 XFREE(ctx->srp_password,NULL,
                       DYNAMIC_TYPE_SRP);
                 ctx->srp_password = NULL;
             }
             wc_FreeRng(&rng);
         } else {
             /* save password for wolfSSL_set_srp_username */
             if (ctx->srp_password != NULL)
                 XFREE(ctx->srp_password,ctx->heap, DYNAMIC_TYPE_SRP);
 
             ctx->srp_password = (byte*)XMALLOC(XSTRLEN(password) + 1, ctx->heap,
                                                DYNAMIC_TYPE_SRP);
             if (ctx->srp_password == NULL){
                 WOLFSSL_MSG("memory allocation error");
                 return SSL_FAILURE;
             }
             XMEMCPY(ctx->srp_password, password, XSTRLEN(password) + 1);
         }
         return WOLFSSL_SUCCESS;
     }
 
     /**
      * The modulus passed to wc_SrpSetParams in ssl.c is constant so check
      * that the requested strength is less than or equal to the size of the
      * static modulus size.
      * @param ctx Not used
      * @param strength Minimum number of bits for the modulus
      * @return 1 if strength is less than or equal to static modulus
      *         0 if strength is greater than static modulus
      */
     int  wolfSSL_CTX_set_srp_strength(WOLFSSL_CTX *ctx, int strength)
     {
         (void)ctx;
         WOLFSSL_ENTER("wolfSSL_CTX_set_srp_strength");
         if (strength > (int)(sizeof(srp_N)*8)) {
             WOLFSSL_MSG("Bad Parameter");
             return WOLFSSL_FAILURE;
         }
         return WOLFSSL_SUCCESS;
     }
 
     char* wolfSSL_get_srp_username(WOLFSSL *ssl)
     {
         if (ssl && ssl->ctx && ssl->ctx->srp) {
             return (char*) ssl->ctx->srp->user;
         }
         return NULL;
     }
     #endif /* WOLFCRYPT_HAVE_SRP && !NO_SHA256 && !WC_NO_RNG */
 
     /* keyblock size in bytes or -1 */
     int wolfSSL_get_keyblock_size(WOLFSSL* ssl)
     {
         if (ssl == NULL)
             return WOLFSSL_FATAL_ERROR;
 
         return 2 * (ssl->specs.key_size + ssl->specs.iv_size +
                     ssl->specs.hash_size);
     }
 
 #endif /* OPENSSL_EXTRA */
 
 #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL)
 
     /* store keys returns WOLFSSL_SUCCESS or -1 on error */
     int wolfSSL_get_keys(WOLFSSL* ssl, unsigned char** ms, unsigned int* msLen,
                                      unsigned char** sr, unsigned int* srLen,
                                      unsigned char** cr, unsigned int* crLen)
     {
         if (ssl == NULL || ssl->arrays == NULL)
             return WOLFSSL_FATAL_ERROR;
 
         *ms = ssl->arrays->masterSecret;
         *sr = ssl->arrays->serverRandom;
         *cr = ssl->arrays->clientRandom;
 
         *msLen = SECRET_LEN;
         *srLen = RAN_LEN;
         *crLen = RAN_LEN;
 
         return WOLFSSL_SUCCESS;
     }
 
     void wolfSSL_set_accept_state(WOLFSSL* ssl)
     {
         WOLFSSL_ENTER("wolfSSL_set_accept_state");
+
+        if (ssl == NULL)
+            return;
+
         if (ssl->options.side == WOLFSSL_CLIENT_END) {
     #ifdef HAVE_ECC
             ecc_key key;
             word32 idx = 0;
 
             if (ssl->options.haveStaticECC && ssl->buffers.key != NULL) {
                 if (wc_ecc_init(&key) >= 0) {
                     if (wc_EccPrivateKeyDecode(ssl->buffers.key->buffer, &idx, &key,
                                                    ssl->buffers.key->length) != 0) {
                         ssl->options.haveECDSAsig = 0;
                         ssl->options.haveECC = 0;
                         ssl->options.haveStaticECC = 0;
                     }
                     wc_ecc_free(&key);
                 }
             }
     #endif
 
     #ifndef NO_DH
             if (!ssl->options.haveDH && ssl->ctx->haveDH) {
                 ssl->buffers.serverDH_P = ssl->ctx->serverDH_P;
                 ssl->buffers.serverDH_G = ssl->ctx->serverDH_G;
                 ssl->options.haveDH = 1;
             }
     #endif
         }
 
         if (InitSSL_Side(ssl, WOLFSSL_SERVER_END) != WOLFSSL_SUCCESS) {
             WOLFSSL_MSG("Error initializing server side");
         }
     }
 
 #endif /* OPENSSL_EXTRA || WOLFSSL_EXTRA || WOLFSSL_WPAS_SMALL */
 
     /* return true if connection established */
     int wolfSSL_is_init_finished(WOLFSSL* ssl)
     {
         if (ssl == NULL)
             return 0;
 
         if (ssl->options.handShakeState == HANDSHAKE_DONE)
             return 1;
 
         return 0;
     }
 
 #ifdef OPENSSL_EXTRA
 
     void wolfSSL_CTX_set_tmp_rsa_callback(WOLFSSL_CTX* ctx,
                                       WOLFSSL_RSA*(*f)(WOLFSSL*, int, int))
     {
         /* wolfSSL verifies all these internally */
         (void)ctx;
         (void)f;
     }
 
 
     void wolfSSL_set_shutdown(WOLFSSL* ssl, int opt)
     {
         WOLFSSL_ENTER("wolfSSL_set_shutdown");
         if(ssl==NULL) {
             WOLFSSL_MSG("Shutdown not set. ssl is null");
             return;
         }
 
         ssl->options.sentNotify =  (opt&WOLFSSL_SENT_SHUTDOWN) > 0;
         ssl->options.closeNotify = (opt&WOLFSSL_RECEIVED_SHUTDOWN) > 0;
     }
 
 
     long wolfSSL_CTX_get_options(WOLFSSL_CTX* ctx)
     {
         WOLFSSL_ENTER("wolfSSL_CTX_get_options");
         WOLFSSL_MSG("wolfSSL options are set through API calls and macros");
         if(ctx == NULL)
             return BAD_FUNC_ARG;
         return ctx->mask;
     }
 
 #endif
 
     static long wolf_set_options(long old_op, long op);
     long wolfSSL_CTX_set_options(WOLFSSL_CTX* ctx, long opt)
     {
         WOLFSSL_ENTER("SSL_CTX_set_options");
 
         if (ctx == NULL)
             return BAD_FUNC_ARG;
 
         ctx->mask = wolf_set_options(ctx->mask, opt);
 
 #if defined(HAVE_SESSION_TICKET) && !defined(NO_WOLFSSL_SERVER) && \
     defined(OPENSSL_EXTRA)
         if (ctx->mask & SSL_OP_NO_TICKET) {
             ctx->ticketEncCb = NULL;
             ctx->ticketEncCtx = NULL;
             WOLFSSL_MSG("\tSSL_OP_NO_TICKET");
         }
 #endif
 
         return ctx->mask;
     }
 
 #ifdef OPENSSL_EXTRA
 
     long wolfSSL_CTX_clear_options(WOLFSSL_CTX* ctx, long opt)
     {
         WOLFSSL_ENTER("SSL_CTX_clear_options");
         if(ctx == NULL)
             return BAD_FUNC_ARG;
         ctx->mask &= ~opt;
         return ctx->mask;
     }
 
     int wolfSSL_set_rfd(WOLFSSL* ssl, int rfd)
     {
         WOLFSSL_ENTER("SSL_set_rfd");
         ssl->rfd = rfd;      /* not used directly to allow IO callbacks */
 
         ssl->IOCB_ReadCtx  = &ssl->rfd;
 
     #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             ssl->IOCB_ReadCtx = &ssl->buffers.dtlsCtx;
             ssl->buffers.dtlsCtx.rfd = rfd;
         }
     #endif
 
         return WOLFSSL_SUCCESS;
     }
 
 
     int wolfSSL_set_wfd(WOLFSSL* ssl, int wfd)
     {
         WOLFSSL_ENTER("SSL_set_wfd");
         ssl->wfd = wfd;      /* not used directly to allow IO callbacks */
 
         ssl->IOCB_WriteCtx  = &ssl->wfd;
 
         return WOLFSSL_SUCCESS;
     }
 #endif /* OPENSSL_EXTRA */
 
 #if !defined(NO_CERTS) && (defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL))
     WOLFSSL_X509_STORE* wolfSSL_CTX_get_cert_store(WOLFSSL_CTX* ctx)
     {
         if (ctx == NULL) {
             return NULL;
         }
 
         return &ctx->x509_store;
     }
 
     void wolfSSL_CTX_set_cert_store(WOLFSSL_CTX* ctx, WOLFSSL_X509_STORE* str)
     {
         if (ctx == NULL || str == NULL || ctx->cm == str->cm) {
             return;
         }
 
         if (wolfSSL_CertManager_up_ref(str->cm) != WOLFSSL_SUCCESS) {
             WOLFSSL_MSG("wolfSSL_CertManager_up_ref error");
             return;
         }
         /* free cert manager if have one */
         if (ctx->cm != NULL) {
             wolfSSL_CertManagerFree(ctx->cm);
         }
         ctx->cm               = str->cm;
         ctx->x509_store.cm    = str->cm;
 
         /* free existing store if it exists */
         wolfSSL_X509_STORE_free(ctx->x509_store_pt);
         ctx->x509_store.cache = str->cache;
         ctx->x509_store_pt    = str; /* take ownership of store and free it
                                         with CTX free */
         ctx->cm->x509_store_p = ctx->x509_store_pt;/* CTX has onwership
                                                     and free it with CTX free*/
     }
 
 
 #endif /* !NO_CERTS && (OPENSSL_EXTRA || WOLFSSL_WPAS_SMALL) */
 
 #ifdef OPENSSL_EXTRA
 #ifndef NO_BIO
     WOLFSSL_BIO_METHOD* wolfSSL_BIO_f_md(void)
     {
         static WOLFSSL_BIO_METHOD meth;
 
         WOLFSSL_ENTER("wolfSSL_BIO_f_md");
         meth.type = WOLFSSL_BIO_MD;
 
         return &meth;
     }
 
     /* return the context and initialize the BIO state */
     int wolfSSL_BIO_get_md_ctx(WOLFSSL_BIO *bio, WOLFSSL_EVP_MD_CTX **mdcp)
     {
         int ret = WOLFSSL_FAILURE;
 
         if ((bio != NULL) && (mdcp != NULL)) {
             *mdcp = (WOLFSSL_EVP_MD_CTX*)bio->ptr;
             ret = WOLFSSL_SUCCESS;
         }
 
         return ret;
     }
 
     WOLFSSL_BIO_METHOD* wolfSSL_BIO_f_buffer(void)
     {
         static WOLFSSL_BIO_METHOD meth;
 
         WOLFSSL_ENTER("BIO_f_buffer");
         meth.type = WOLFSSL_BIO_BUFFER;
 
         return &meth;
     }
 
     #ifndef NO_WOLFSSL_STUB
     long wolfSSL_BIO_set_write_buffer_size(WOLFSSL_BIO* bio, long size)
     {
         /* wolfSSL has internal buffer, compatibility only */
         WOLFSSL_ENTER("BIO_set_write_buffer_size");
         WOLFSSL_MSG("Buffer resize failed");
         WOLFSSL_STUB("BIO_set_write_buffer_size");
         (void)bio;
         (void) size;
 
         /* Even though this is only a STUB at the moment many user applications
          * may attempt to use this. OpenSSL documentation specifies the return
          * "return 1 if the buffer was successfully resized or 0 for failure."
          * since wolfSSL does not resize the buffer will always return failure
          * by default due to memory concerns until this stub is promoted to
          * a non-stub function */
         return WOLFSSL_FAILURE; /* 0, no resize happened */
     }
     #endif
 
     WOLFSSL_BIO_METHOD* wolfSSL_BIO_s_bio(void)
     {
         static WOLFSSL_BIO_METHOD bio_meth;
 
         WOLFSSL_ENTER("wolfSSL_BIO_s_bio");
         bio_meth.type = WOLFSSL_BIO_BIO;
 
         return &bio_meth;
     }
 
 
 #ifndef NO_FILESYSTEM
     WOLFSSL_BIO_METHOD* wolfSSL_BIO_s_file(void)
     {
         static WOLFSSL_BIO_METHOD file_meth;
 
         WOLFSSL_ENTER("wolfSSL_BIO_s_file");
         file_meth.type = WOLFSSL_BIO_FILE;
 
         return &file_meth;
     }
 #endif
 
 
     WOLFSSL_BIO_METHOD* wolfSSL_BIO_f_ssl(void)
     {
         static WOLFSSL_BIO_METHOD meth;
 
         WOLFSSL_ENTER("wolfSSL_BIO_f_ssl");
         meth.type = WOLFSSL_BIO_SSL;
 
         return &meth;
     }
 
 
     WOLFSSL_BIO_METHOD *wolfSSL_BIO_s_socket(void)
     {
         static WOLFSSL_BIO_METHOD meth;
 
         WOLFSSL_ENTER("wolfSSL_BIO_s_socket");
         meth.type = WOLFSSL_BIO_SOCKET;
 
         return &meth;
     }
 
 
     WOLFSSL_BIO* wolfSSL_BIO_new_socket(int sfd, int closeF)
     {
         WOLFSSL_BIO* bio = wolfSSL_BIO_new(wolfSSL_BIO_s_socket());
 
         WOLFSSL_ENTER("BIO_new_socket");
         if (bio) {
             bio->type  = WOLFSSL_BIO_SOCKET;
             bio->shutdown = (byte)closeF;
             bio->num   = sfd;
         }
         return bio;
     }
 
     /**
      * Create new socket BIO object. This is a pure TCP connection with
      * no SSL or TLS protection.
      * @param str IP address to connect to
      * @return New BIO object or NULL on failure
      */
     WOLFSSL_BIO *wolfSSL_BIO_new_connect(const char *str)
     {
         WOLFSSL_BIO *bio;
         WOLFSSL_ENTER("wolfSSL_BIO_new_connect");
         bio = wolfSSL_BIO_new(wolfSSL_BIO_s_socket());
         if (bio) {
             bio->ip = str;
             bio->type  = WOLFSSL_BIO_SOCKET;
         }
         return bio;
     }
 
     /**
      * Set the port to connect to in the BIO object
      * @param b BIO object
      * @param port destination port
      * @return WOLFSSL_SUCCESS on success and WOLFSSL_FAILURE on failure
      */
     long wolfSSL_BIO_set_conn_port(WOLFSSL_BIO *b, char* port)
     {
         int p;
         WOLFSSL_ENTER("wolfSSL_BIO_set_conn_port");
 
         if (!b || !port) {
             WOLFSSL_ENTER("Bad parameter");
             return WOLFSSL_FAILURE;
         }
 
         p = XATOI(port);
         if (!p || p < 0) {
             WOLFSSL_ENTER("Port parsing error");
             return WOLFSSL_FAILURE;
         }
 
         b->port = (word16)p;
         return WOLFSSL_SUCCESS;
     }
 
 #ifdef HAVE_HTTP_CLIENT
     /**
      * Attempt to connect to the destination address and port
      * @param b BIO object
      * @return WOLFSSL_SUCCESS on success and WOLFSSL_FAILURE on failure
      */
     long wolfSSL_BIO_do_connect(WOLFSSL_BIO *b)
     {
         SOCKET_T sfd = SOCKET_INVALID;
         WOLFSSL_ENTER("wolfSSL_BIO_do_connect");
 
         if (!b) {
             WOLFSSL_ENTER("Bad parameter");
             return WOLFSSL_FAILURE;
         }
 
         while (b && b->type != WOLFSSL_BIO_SOCKET)
             b = b->next;
 
         if (!b) {
             WOLFSSL_ENTER("No socket BIO in chain");
             return WOLFSSL_FAILURE;
         }
 
         if (wolfIO_TcpConnect(&sfd, b->ip, b->port, 0) < 0 ) {
             WOLFSSL_ENTER("wolfIO_TcpConnect error");
             return WOLFSSL_FAILURE;
         }
 
         b->num = sfd;
         b->shutdown = BIO_CLOSE;
         return WOLFSSL_SUCCESS;
     }
 #endif /* HAVE_HTTP_CLIENT */
 
     int wolfSSL_BIO_eof(WOLFSSL_BIO* b)
     {
         WOLFSSL_ENTER("BIO_eof");
         if ((b != NULL) && (b->eof))
             return 1;
 
         return 0;
     }
 
     long wolfSSL_BIO_do_handshake(WOLFSSL_BIO *b)
     {
         WOLFSSL_ENTER("wolfSSL_BIO_do_handshake");
         if (b == NULL) {
             WOLFSSL_MSG("Bad parameter");
             return WOLFSSL_FAILURE;
         }
         if (b->type == WOLFSSL_BIO_SSL && b->ptr != NULL) {
             return wolfSSL_negotiate((WOLFSSL*)b->ptr);
         }
         else {
             WOLFSSL_MSG("Not SSL BIO or no SSL object set");
             return WOLFSSL_FAILURE;
         }
     }
 
     long wolfSSL_BIO_set_ssl(WOLFSSL_BIO* b, WOLFSSL* ssl, int closeF)
     {
         long ret = WOLFSSL_FAILURE;
 
         WOLFSSL_ENTER("wolfSSL_BIO_set_ssl");
 
         if (b != NULL) {
             b->ptr   = ssl;
             b->shutdown = (byte)closeF;
             if (b->next != NULL)
                 wolfSSL_set_bio(ssl, b->next, b->next);
     /* add to ssl for bio free if SSL_free called before/instead of free_all? */
             ret = WOLFSSL_SUCCESS;
         }
 
         return ret;
     }
 
 #ifndef NO_FILESYSTEM
     long wolfSSL_BIO_set_fd(WOLFSSL_BIO* b, int fd, int closeF)
     {
         WOLFSSL_ENTER("wolfSSL_BIO_set_fd");
 
         if (b != NULL) {
             b->num = fd;
             b->shutdown = (byte)closeF;
         }
 
         return WOLFSSL_SUCCESS;
     }
 #endif
 
     /* Sets the close flag */
     int wolfSSL_BIO_set_close(WOLFSSL_BIO *b, long flag)
     {
         WOLFSSL_ENTER("wolfSSL_BIO_set_close");
         if (b != NULL) {
             b->shutdown = (byte)flag;
         }
 
         return WOLFSSL_SUCCESS;
     }
 
 #if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10100000L
     WOLFSSL_BIO* wolfSSL_BIO_new(const WOLFSSL_BIO_METHOD* method)
 #else
     WOLFSSL_BIO* wolfSSL_BIO_new(WOLFSSL_BIO_METHOD* method)
 #endif
     {
         WOLFSSL_BIO* bio;
 
         WOLFSSL_ENTER("wolfSSL_BIO_new");
         if (method == NULL) {
             WOLFSSL_MSG("Bad method pointer passed in");
             return NULL;
         }
 
         bio = (WOLFSSL_BIO*) XMALLOC(sizeof(WOLFSSL_BIO), 0,
                 DYNAMIC_TYPE_OPENSSL);
         if (bio) {
             XMEMSET(bio, 0, sizeof(WOLFSSL_BIO));
             bio->type = (byte)method->type;
 #if defined(OPENSSL_VERSION_NUMBER) && OPENSSL_VERSION_NUMBER >= 0x10100000L
             bio->method = (WOLFSSL_BIO_METHOD*)method;
 #else
             bio->method = method;
 #endif
             bio->shutdown = BIO_CLOSE; /* default to close things */
             bio->num = -1; /* Default to invalid socket */
             bio->init = 1;
             if (method->type != WOLFSSL_BIO_FILE &&
                     method->type != WOLFSSL_BIO_SOCKET &&
                     method->type != WOLFSSL_BIO_MD) {
                 bio->mem_buf =(WOLFSSL_BUF_MEM*)XMALLOC(sizeof(WOLFSSL_BUF_MEM),
                                                        0, DYNAMIC_TYPE_OPENSSL);
                 if (bio->mem_buf == NULL) {
                     WOLFSSL_MSG("Memory error");
                     wolfSSL_BIO_free(bio);
                     return NULL;
                 }
                 bio->mem_buf->data = (char*)bio->ptr;
             }
 
             if (method->type == WOLFSSL_BIO_MD) {
                 bio->ptr = wolfSSL_EVP_MD_CTX_new();
                 if (bio->ptr == NULL) {
                     WOLFSSL_MSG("Memory error");
                     wolfSSL_BIO_free(bio);
                     return NULL;
                 }
             }
 
             /* check if is custom method */
             if (method->createCb) {
                 method->createCb(bio);
             }
         }
         return bio;
     }
 
     WOLFSSL_BIO* wolfSSL_BIO_new_mem_buf(const void* buf, int len)
     {
         WOLFSSL_BIO* bio = NULL;
 
         if (buf == NULL) {
             return bio;
         }
 
         bio = wolfSSL_BIO_new(wolfSSL_BIO_s_mem());
         if (bio == NULL) {
             return bio;
         }
 
         if (len < 0) {
             /* The length of the string including terminating null. */
             len = (int)XSTRLEN((const char*)buf) + 1;
         }
         bio->num = bio->wrSz = len;
         bio->ptr = (byte*)XMALLOC(len, 0, DYNAMIC_TYPE_OPENSSL);
         if (bio->ptr == NULL) {
             wolfSSL_BIO_free(bio);
             return NULL;
         }
         if (bio->mem_buf != NULL) {
             bio->mem_buf->data = (char*)bio->ptr;
             bio->mem_buf->length = bio->num;
         }
 
         XMEMCPY(bio->ptr, buf, len);
 
         return bio;
     }
 
     /*
      * Note : If the flag BIO_NOCLOSE is set then freeing memory buffers is up
      *        to the application.
      * Returns 1 on success, 0 on failure
      */
     int wolfSSL_BIO_free(WOLFSSL_BIO* bio)
     {
         int ret;
 
         /* unchain?, doesn't matter in goahead since from free all */
         WOLFSSL_ENTER("wolfSSL_BIO_free");
         if (bio) {
 #ifdef HAVE_EX_DATA_CLEANUP_HOOKS
             wolfSSL_CRYPTO_cleanup_ex_data(&bio->ex_data);
 #endif
             if (bio->infoCb) {
                 /* info callback is called before free */
                 ret = (int)bio->infoCb(bio, WOLFSSL_BIO_CB_FREE, NULL, 0, 0, 1);
                 if (ret <= 0) {
                     return ret;
                 }
             }
 
             /* call custom set free callback */
             if (bio->method && bio->method->freeCb) {
                 bio->method->freeCb(bio);
             }
 
             /* remove from pair by setting the paired bios pair to NULL */
             if (bio->pair != NULL) {
                 bio->pair->pair = NULL;
             }
 
             if (bio->shutdown) {
                 if (bio->type == WOLFSSL_BIO_SSL && bio->ptr)
                     wolfSSL_free((WOLFSSL*)bio->ptr);
             #ifdef CloseSocket
                 if (bio->type == WOLFSSL_BIO_SOCKET && bio->num)
                     CloseSocket(bio->num);
              #endif
             }
 
         #ifndef NO_FILESYSTEM
             if (bio->type == WOLFSSL_BIO_FILE && bio->shutdown == BIO_CLOSE) {
                 if (bio->ptr) {
                     XFCLOSE((XFILE)bio->ptr);
                 }
             #if !defined(USE_WINDOWS_API) && !defined(NO_WOLFSSL_DIR)\
                 && !defined(WOLFSSL_NUCLEUS) && !defined(WOLFSSL_NUCLEUS_1_2)
                 else if (bio->num != -1) {
                     XCLOSE(bio->num);
                 }
             #endif
             }
         #endif
 
             if (bio->shutdown != BIO_NOCLOSE) {
                 if (bio->type == WOLFSSL_BIO_MEMORY && bio->ptr != NULL) {
                     if (bio->mem_buf != NULL) {
                         if (bio->mem_buf->data != (char*)bio->ptr) {
                             XFREE(bio->ptr, bio->heap, DYNAMIC_TYPE_OPENSSL);
                             bio->ptr = NULL;
                         }
                     }
                     else {
                         XFREE(bio->ptr, bio->heap, DYNAMIC_TYPE_OPENSSL);
                         bio->ptr = NULL;
                     }
                 }
                 if (bio->mem_buf != NULL) {
                     wolfSSL_BUF_MEM_free(bio->mem_buf);
                     bio->mem_buf = NULL;
                 }
             }
 
             if (bio->type == WOLFSSL_BIO_MD) {
                 wolfSSL_EVP_MD_CTX_free((WOLFSSL_EVP_MD_CTX*)bio->ptr);
             }
 
             XFREE(bio, 0, DYNAMIC_TYPE_OPENSSL);
             return WOLFSSL_SUCCESS;
         }
         return WOLFSSL_FAILURE;
     }
 
     /* like BIO_free, but no return value */
     void wolfSSL_BIO_vfree(WOLFSSL_BIO* bio)
     {
         wolfSSL_BIO_free(bio);
     }
 
 
     void wolfSSL_BIO_free_all(WOLFSSL_BIO* bio)
     {
         WOLFSSL_ENTER("BIO_free_all");
         while (bio) {
             WOLFSSL_BIO* next = bio->next;
             wolfSSL_BIO_free(bio);
             bio = next;
         }
     }
 
 
     WOLFSSL_BIO* wolfSSL_BIO_push(WOLFSSL_BIO* top, WOLFSSL_BIO* append)
     {
         WOLFSSL_ENTER("BIO_push");
         top->next    = append;
         append->prev = top;
 
         /* SSL BIO's should use the next object in the chain for IO */
         if (top->type == WOLFSSL_BIO_SSL && top->ptr)
             wolfSSL_set_bio((WOLFSSL*)top->ptr, append, append);
 
         return top;
     }
 #endif /* !NO_BIO */
 #endif /* OPENSSL_EXTRA */
 
 #ifdef WOLFSSL_ENCRYPTED_KEYS
 
     void wolfSSL_CTX_set_default_passwd_cb_userdata(WOLFSSL_CTX* ctx,
                                                    void* userdata)
     {
         WOLFSSL_ENTER("SSL_CTX_set_default_passwd_cb_userdata");
         if (ctx)
             ctx->passwd_userdata = userdata;
     }
 
 
     void wolfSSL_CTX_set_default_passwd_cb(WOLFSSL_CTX* ctx,pem_password_cb* cb)
     {
         WOLFSSL_ENTER("SSL_CTX_set_default_passwd_cb");
         if (ctx)
             ctx->passwd_cb = cb;
     }
 
     pem_password_cb* wolfSSL_CTX_get_default_passwd_cb(WOLFSSL_CTX *ctx)
     {
         if (ctx == NULL || ctx->passwd_cb == NULL) {
             return NULL;
         }
 
         return ctx->passwd_cb;
     }
 
 
     void* wolfSSL_CTX_get_default_passwd_cb_userdata(WOLFSSL_CTX *ctx)
     {
         if (ctx == NULL) {
             return NULL;
         }
 
         return ctx->passwd_userdata;
     }
 
 #endif /* WOLFSSL_ENCRYPTED_KEYS */
 
 
 #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER)
     int wolfSSL_num_locks(void)
     {
         return 0;
     }
 
     void wolfSSL_set_locking_callback(void (*f)(int, int, const char*, int))
     {
         WOLFSSL_ENTER("wolfSSL_set_locking_callback");
 
         if (wc_SetMutexCb(f) != 0) {
             WOLFSSL_MSG("Error when setting mutex call back");
         }
     }
 
 
     typedef unsigned long (idCb)(void);
     static idCb* inner_idCb = NULL;
 
     unsigned long wolfSSL_thread_id(void)
     {
         if (inner_idCb != NULL) {
             return inner_idCb();
         }
         else {
             return 0;
         }
     }
 
 
     void wolfSSL_set_id_callback(unsigned long (*f)(void))
     {
         inner_idCb = f;
     }
 
     unsigned long wolfSSL_ERR_get_error(void)
     {
         WOLFSSL_ENTER("wolfSSL_ERR_get_error");
 
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)
         {
             unsigned long ret = wolfSSL_ERR_peek_error_line_data(NULL, NULL,
                                                                  NULL, NULL);
             wc_RemoveErrorNode(-1);
             return ret;
         }
 #elif (defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE))
         {
             int ret = wc_PullErrorNode(NULL, NULL, NULL);
 
             if (ret < 0) {
                 if (ret == BAD_STATE_E) return 0; /* no errors in queue */
                 WOLFSSL_MSG("Error with pulling error node!");
                 WOLFSSL_LEAVE("wolfSSL_ERR_get_error", ret);
                 ret = 0 - ret; /* return absolute value of error */
 
                 /* panic and try to clear out nodes */
                 wc_ClearErrorNodes();
             }
 
             return (unsigned long)ret;
         }
 #else
         return (unsigned long)(0 - NOT_COMPILED_IN);
 #endif
     }
 
 #if (defined(OPENSSL_EXTRA) || defined(DEBUG_WOLFSSL_VERBOSE))
 #ifndef NO_BIO
     /* print out and clear all errors */
     void wolfSSL_ERR_print_errors(WOLFSSL_BIO* bio)
     {
         const char* file = NULL;
         const char* reason = NULL;
         int ret;
         int line = 0;
         char buf[WOLFSSL_MAX_ERROR_SZ * 2];
 
         WOLFSSL_ENTER("wolfSSL_ERR_print_errors");
 
         if (bio == NULL) {
             WOLFSSL_MSG("BIO passed in was null");
             return;
         }
 
         do {
         ret = wc_PeekErrorNode(0, &file, &reason, &line);
         if (ret >= 0) {
             const char* r = wolfSSL_ERR_reason_error_string(0 - ret);
             XSNPRINTF(buf, sizeof(buf), "error:%d:wolfSSL library:%s:%s:%d\n",
                     ret, r, file, line);
             wolfSSL_BIO_write(bio, buf, (int)XSTRLEN(buf));
             wc_RemoveErrorNode(0);
         }
         } while (ret >= 0);
         if (wolfSSL_BIO_write(bio, "", 1) != 1) {
             WOLFSSL_MSG("Issue writing final string terminator");
         }
     }
 #endif /* !NO_BIO */
 #endif /* OPENSSL_EXTRA || DEBUG_WOLFSSL_VERBOSE */
 
 #endif /* OPENSSL_EXTRA || HAVE_WEBSERVER */
 
 #if defined(OPENSSL_EXTRA) || defined(WOLFSSL_WPAS_SMALL) || \
     defined(HAVE_SECRET_CALLBACK)
 #if !defined(NO_WOLFSSL_SERVER)
