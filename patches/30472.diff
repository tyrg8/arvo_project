commit 89b97a0fbf9ac3ffaec9368e6bc81e7f34f1873c
Author: kaleb-himes <kaleb@wolfssl.com>
Date:   Tue Feb 9 18:42:23 2021 -0700

    Implement peer feedback

diff --git a/IDE/VisualDSP/include.am b/IDE/VisualDSP/include.am
deleted file mode 100644
index a12daf3ff..000000000
--- a/IDE/VisualDSP/include.am
+++ /dev/null
@@ -1,6 +0,0 @@
-# vim:ft=automake
-# included from Top Level Makefile.am
-# All paths should be given relative to the root
-
-EXTRA_DIST+= IDE/VisualDSP++/user_settings.h
-EXTRA_DIST+= IDE/VisualDSP++/wolf-tasks.c
diff --git a/IDE/VisualDSP/user_settings.h b/IDE/VisualDSP/user_settings.h
index 44cf3c3f5..5d33914ae 100644
--- a/IDE/VisualDSP/user_settings.h
+++ b/IDE/VisualDSP/user_settings.h
@@ -27,726 +27,726 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #include "fusioncfg.h"
 
+/* Previously was included in ssl.c but for the sake of portability and existing
+ * projects, moved to IDE specific user_settings.h (stdarg.h include)
+ */
+#include <stdarg.h>
+
 /* ------------------------------------------------------------------------- */
 /* Platform */
 /* ------------------------------------------------------------------------- */
 #undef  WOLFSSL_GENERAL_ALIGNMENT
 #define WOLFSSL_GENERAL_ALIGNMENT   4
 
 #undef  SINGLE_THREADED
 #define SINGLE_THREADED
 
 #undef  WOLFSSL_SMALL_STACK
 //#define WOLFSSL_SMALL_STACK
 
 #undef  WOLFSSL_USER_IO
 // #define WOLFSSL_USER_IO
 
 #define HAVE_PKCS8
 
 /* ------------------------------------------------------------------------- */
 /* Math Configuration */
 /* ------------------------------------------------------------------------- */
 #undef  SIZEOF_LONG_LONG
 #define SIZEOF_LONG_LONG 8
 
 #undef USE_FAST_MATH
 #if 1
     #define USE_FAST_MATH
 
     #undef  TFM_TIMING_RESISTANT
     #define TFM_TIMING_RESISTANT
 
     /* Optimizations */
     //#define TFM_ARM
 #endif
 
 /* Wolf Single Precision Math */
 #undef WOLFSSL_SP
 #if 0
     #define WOLFSSL_SP
     //#define WOLFSSL_SP_SMALL      /* use smaller version of code */
     #define WOLFSSL_HAVE_SP_RSA
     #define WOLFSSL_HAVE_SP_DH
     #define WOLFSSL_HAVE_SP_ECC
     #define WOLFSSL_SP_CACHE_RESISTANT
     //#define WOLFSSL_SP_MATH     /* only SP math - eliminates fast math code */
 
     /* 64 or 32 bit version */
     //#define WOLFSSL_SP_ASM      /* required if using the ASM versions */
     //#define WOLFSSL_SP_ARM32_ASM
     //#define WOLFSSL_SP_ARM64_ASM
 #endif
 
 /* ------------------------------------------------------------------------- */
 /* FIPS - Requires eval or license from wolfSSL */
 /* ------------------------------------------------------------------------- */
 #undef  HAVE_FIPS
 #if 1
     #define HAVE_FIPS
 
     #undef  HAVE_FIPS_VERSION
     #define HAVE_FIPS_VERSION 2
 
     #ifdef SINGLE_THREADED
         #undef  NO_THREAD_LS
         #define NO_THREAD_LS
     #endif
+
+    #define NO_ATTRIBUTE_CONSTRUCTOR /* Required on ADSP BLACKFIN where memory
+                                      * is zeroized after
+                                      * __attribute__((constructor)) and before
+                                      * main();
+                                      */
 #endif
 
 
 /* ------------------------------------------------------------------------- */
 /* Crypto */
 /* ------------------------------------------------------------------------- */
 /* RSA */
 #undef NO_RSA
 #if 1
     #ifdef USE_FAST_MATH
         /* Maximum math bits (Max RSA key bits * 2) */
         #undef  FP_MAX_BITS
         #define FP_MAX_BITS     8192
     #endif
 
     /* half as much memory but twice as slow */
     #undef  RSA_LOW_MEM
     //#define RSA_LOW_MEM
 
     /* Enables blinding mode, to prevent timing attacks */
     #if 1
         #undef  WC_RSA_BLINDING
         #define WC_RSA_BLINDING
     #else
         #undef  WC_NO_HARDEN
         #define WC_NO_HARDEN
     #endif
 
     /* RSA PSS Support */
     #if 1
         #define WC_RSA_PSS
     #endif
 
     #if 1
         #define WC_RSA_NO_PADDING
     #endif
 #else
     #define NO_RSA
 #endif
 
 /* ECC */
 #undef HAVE_ECC
 #if 1
     #define HAVE_ECC
 
     /* Manually define enabled curves */
     #undef  ECC_USER_CURVES
     //#define ECC_USER_CURVES
 
     #ifdef ECC_USER_CURVES
         /* Manual Curve Selection */
         //#define HAVE_ECC192
         //#define HAVE_ECC224
         #undef NO_ECC256
         //#define HAVE_ECC384
         //#define HAVE_ECC521
     #endif
 
     /* Fixed point cache (speeds repeated operations against same private key) */
     #undef  FP_ECC
     //#define FP_ECC
     #ifdef FP_ECC
         /* Bits / Entries */
         #undef  FP_ENTRIES
         #define FP_ENTRIES  2
         #undef  FP_LUT
         #define FP_LUT      4
     #endif
 
     /* Optional ECC calculation method */
     /* Note: doubles heap usage, but slightly faster */
     #undef  ECC_SHAMIR
     #define ECC_SHAMIR
 
     /* Reduces heap usage, but slower */
     #undef  ECC_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
 
     /* Enable cofactor support */
     #ifdef HAVE_FIPS
         #undef  HAVE_ECC_CDH
         #define HAVE_ECC_CDH
         
         #define NO_STRICT_ECDSA_LEN
     #endif
 
     /* Validate import */
     #ifdef HAVE_FIPS
         #undef  WOLFSSL_VALIDATE_ECC_IMPORT
         #define WOLFSSL_VALIDATE_ECC_IMPORT
     #endif
 
     /* Compressed Key Support */
     #undef  HAVE_COMP_KEY
     //#define HAVE_COMP_KEY
 
     /* Use alternate ECC size for ECC math */
     #ifdef USE_FAST_MATH
         #ifdef NO_RSA
             /* Custom fastmath size if not using RSA */
             /* MAX = ROUND32(ECC BITS 256) + SIZE_OF_MP_DIGIT(32) */
             #undef  FP_MAX_BITS
             #define FP_MAX_BITS     (256 + 32)
         #else
             #undef  ALT_ECC_SIZE
             #define ALT_ECC_SIZE
         #endif
 
         /* Speedups specific to curve */
         #ifndef NO_ECC256
             #undef  TFM_ECC256
             #define TFM_ECC256
         #endif
     #endif
 #endif
 
 /* DH */
 #undef  NO_DH
 #if 1
     /* Use table for DH instead of -lm (math) lib dependency */
     #if 0
         #define WOLFSSL_DH_CONST
         #define HAVE_FFDHE_2048
         #define HAVE_FFDHE_4096
         #define HAVE_DH_DEFAULT_PARAMS
         //#define HAVE_FFDHE_6144
         //#define HAVE_FFDHE_8192
     #endif
 
     #ifdef HAVE_FIPS
         #define WOLFSSL_VALIDATE_FFC_IMPORT
         #define HAVE_FFDHE_Q
     #endif
 #else
     #define NO_DH
 #endif
 
 
 /* AES */
 #undef NO_AES
 #if 1
     #undef  HAVE_AES_CBC
     #define HAVE_AES_CBC
 
     #undef  HAVE_AESGCM
     #define HAVE_AESGCM
 
     /* GCM Method: GCM_SMALL, GCM_WORD32 or GCM_TABLE */
     #define GCM_SMALL
 
     #undef  WOLFSSL_AES_DIRECT
     #define WOLFSSL_AES_DIRECT
 
     #undef  HAVE_AES_ECB
     #define HAVE_AES_ECB
 
     #undef  WOLFSSL_AES_COUNTER
     #define WOLFSSL_AES_COUNTER
 
     #undef  HAVE_AESCCM
     #define HAVE_AESCCM
 #else
     #define NO_AES
 #endif
 
 
 /* DES3 */
 #undef NO_DES3
 #if 1
 #else
     #define NO_DES3
 #endif
 
 /* ChaCha20 / Poly1305 */
 #undef HAVE_CHACHA
 #undef HAVE_POLY1305
 #if 0
     #define HAVE_CHACHA
     #define HAVE_POLY1305
 
     /* Needed for Poly1305 */
     #undef  HAVE_ONE_TIME_AUTH
     #define HAVE_ONE_TIME_AUTH
 #endif
 
 /* Ed25519 / Curve25519 */
 #undef HAVE_CURVE25519
 #undef HAVE_ED25519
 #if 0
     #define HAVE_CURVE25519
     #define HAVE_ED25519 /* ED25519 Requires SHA512 */
 
     /* Optionally use small math (less flash usage, but much slower) */
     #if 1
         #define CURVED25519_SMALL
     #endif
 #endif
 
 
 /* ------------------------------------------------------------------------- */
 /* Hashing */
 /* ------------------------------------------------------------------------- */
 /* Sha */
 #undef NO_SHA
 #if 1
     /* 1k smaller, but 25% slower */
     //#define USE_SLOW_SHA
 #else
     #define NO_SHA
 #endif
 
 /* Sha256 */
 #undef NO_SHA256
 #if 1
     /* not unrolled - ~2k smaller and ~25% slower */
     //#define USE_SLOW_SHA256
 
     /* Sha224 */
     #if 1
         #define WOLFSSL_SHA224
     #endif
 #else
     #define NO_SHA256
 #endif
 
 /* Sha512 */
 #undef WOLFSSL_SHA512
 #if 1
     #define WOLFSSL_SHA512
 
     /* Sha384 */
     #undef  WOLFSSL_SHA384
     #if 1
         #define WOLFSSL_SHA384
     #endif
 
     /* over twice as small, but 50% slower */
     //#define USE_SLOW_SHA512
 #endif
 
 /* Sha3 */
 #undef WOLFSSL_SHA3
 #if 1
     #define WOLFSSL_SHA3
     #ifdef HAVE_FIPS
         #define WOLFSSL_NO_SHAKE256
     #endif
 #endif
 
 /* MD5 */
 #undef  NO_MD5
 #if 1
 
 #else
     #define NO_MD5
 #endif
 
 /* HKDF */
 #undef HAVE_HKDF
 #if 1
     #define HAVE_HKDF
 #endif
 
 /* CMAC */
 #undef WOLFSSL_CMAC
 #if 1
     #define WOLFSSL_CMAC
 #endif
 
 
 /* ------------------------------------------------------------------------- */
 /* Benchmark / Test */
 /* ------------------------------------------------------------------------- */
 /* Use reduced benchmark / test sizes */
 #undef  BENCH_EMBEDDED
 #define BENCH_EMBEDDED
 
 #undef  USE_CERT_BUFFERS_2048
 //#define USE_CERT_BUFFERS_2048
 
 //#undef  USE_CERT_BUFFERS_1024
 //#define USE_CERT_BUFFERS_1024
 
 #undef  USE_CERT_BUFFERS_256
 //#define USE_CERT_BUFFERS_256
 
 
 /* ------------------------------------------------------------------------- */
 /* Debugging */
 /* ------------------------------------------------------------------------- */
 
 #undef DEBUG_WOLFSSL
 #undef NO_ERROR_STRINGS
 #if 1 //for debug wolfssl_init.
     #define DEBUG_WOLFSSL
 #else
     #if 0
         #define NO_ERROR_STRINGS
     #endif
 #endif
 
 
 /* ------------------------------------------------------------------------- */
 /* Memory */
 /* ------------------------------------------------------------------------- */
 
 /* Override Memory API's */
 #if 1
     #undef  XMALLOC_OVERRIDE
     #define XMALLOC_OVERRIDE
 
     #include <fclstdlib.h>
 
     #define XMALLOC(n, h, t)     FCL_MALLOC(n)
     #define XFREE(p, h, t)       FCL_FREE(p)
     #define XREALLOC(p, n, h, t) FCL_REALLOC(p, n)
 
     #define XATOI(s)     FCL_ATOI(s)
 #endif
 
 #if 0
     /* Static memory requires fast math */
     #define WOLFSSL_STATIC_MEMORY
 
     /* Disable fallback malloc/free */
     #define WOLFSSL_NO_MALLOC
     #if 0
         #define WOLFSSL_MALLOC_CHECK /* trap malloc failure */
     #endif
 #endif
 
 /* Memory callbacks */
 #if 0
     #undef  USE_WOLFSSL_MEMORY
     #define USE_WOLFSSL_MEMORY
 
     /* Use this to measure / print heap usage */
     #if 0
         #undef  WOLFSSL_TRACK_MEMORY
         #define WOLFSSL_TRACK_MEMORY
 
         #undef  WOLFSSL_DEBUG_MEMORY
         #define WOLFSSL_DEBUG_MEMORY
     #endif
 #else
     #ifndef WOLFSSL_STATIC_MEMORY
         #define NO_WOLFSSL_MEMORY
         /* Otherwise we will use stdlib malloc, free and realloc */
     #endif
 #endif
 
 
 /* ------------------------------------------------------------------------- */
 /* Port */
 /* ------------------------------------------------------------------------- */
 
 /* Override Current Time */
 /* Allows custom "custom_time()" function to be used for benchmark */
 //#define WOLFSSL_USER_CURRTIME
 //#define WOLFSSL_GMTIME
 //#define USER_TICKS
 //extern unsigned long my_time(unsigned long* timer);
 //#define XTIME my_time
 #if 1
     #include "fcltime.h"
     #define time_t fclTime_t
     #define USER_TIME
     time_t fclTime( time_t* tod );
     #define XTIME fclTime
     #define XCTIME fclCtime
     #define HAVE_TIME_T_TYPE
 #endif
 
 /* ------------------------------------------------------------------------- */
 /* RNG */
 /* ------------------------------------------------------------------------- */
 
 /* Seed Source */
 /* Size of returned HW RNG value */
 #if 0   
     #define CUSTOM_RAND_TYPE      unsigned int
     extern unsigned int my_rng_seed_gen(void);
     #undef  CUSTOM_RAND_GENERATE
     #define CUSTOM_RAND_GENERATE  my_rng_seed_gen
 #endif
 
 /* Choose RNG method */
 #if 1
     /* Use built-in P-RNG (SHA256 based) with HW RNG */
     /* P-RNG + HW RNG (P-RNG is ~8K) */
     #undef  HAVE_HASHDRBG
     #define HAVE_HASHDRBG
 #else
     #undef  WC_NO_HASHDRBG
     #define WC_NO_HASHDRBG
     /* Bypass P-RNG and use only HW RNG */
     extern int my_rng_gen_block(unsigned char* output, unsigned int sz);
     #undef  CUSTOM_RAND_GENERATE_BLOCK
     #define CUSTOM_RAND_GENERATE_BLOCK  my_rng_gen_block
 #endif
 
 
 /* ------------------------------------------------------------------------- */
 /* Custom Standard Lib */
 /* ------------------------------------------------------------------------- */
 /* Allows override of all standard library functions */
 #undef STRING_USER
 #if 1
     #define STRING_USER
 
     #include <fclstring.h>
 
     #undef  USE_WOLF_STRSEP
     #define USE_WOLF_STRSEP
     #define XSTRSEP(s1,d)     wc_strsep((s1),(d))
 
     #undef  USE_WOLF_STRTOK
     #define USE_WOLF_STRTOK
     #define XSTRTOK(s1,d,ptr) wc_strtok((s1),(d),(ptr))
 
-    // TBD drowe: add a new FCL_STRNSTR and implement the new fclStrnstr code in common/clib/string/fclstrstr.c
-    // For now use the unsafe version
     #define XSTRNSTR(s1,s2,n) FCL_STRSTR((s1),(s2))
 
     #define XMEMCPY(d,s,l)    FCL_MEMCPY((d),(s),(l))
     #define XMEMSET(b,c,l)    FCL_MEMSET((b),(c),(l))
     #define XMEMCMP(s1,s2,n)  FCL_MEMCMP((s1),(s2),(n))
     #define XMEMMOVE(d,s,l)   FCL_MEMMOVE((d),(s),(l))
 
     #define XSTRLEN(s1)       FCL_STRLEN((s1))
     #define XSTRNCPY(s1,s2,n) FCL_STRNCPY((s1),(s2),(n))
     #define XSTRSTR(s1,s2)    FCL_STRSTR((s1),(s2))
 
     #define XSTRNCMP(s1,s2,n)     FCL_STRNCMP((s1),(s2),(n))
     #define XSTRNCAT(s1,s2,n)     FCL_STRNCAT((s1),(s2),(n))
     #define XSTRNCASECMP(s1,s2,n) FCL_STRNCASECMP((s1),(s2),(n))
 
     #define XSNPRINTF FCL_SNPRINTF
 #endif
 
 
 
 /* ------------------------------------------------------------------------- */
 /* Enable Features */
 /* ------------------------------------------------------------------------- */
 #undef WOLFSSL_TLS13
 #if 0
     #define WOLFSSL_TLS13
 #endif
 
 #undef WOLFSSL_KEY_GEN
 #if 1
     #define WOLFSSL_KEY_GEN
 #endif
 
 #if defined(HAVE_FIPS) && !defined(WOLFSSL_KEY_GEN)
     #define WOLFSSL_OLD_PRIME_CHECK
 #endif
 
 #undef  KEEP_PEER_CERT
 //#define KEEP_PEER_CERT
 
 #undef  HAVE_COMP_KEY
 //#define HAVE_COMP_KEY
 
 #undef  HAVE_TLS_EXTENSIONS
 //#define HAVE_TLS_EXTENSIONS
 
 #undef  HAVE_SUPPORTED_CURVES
 #define HAVE_SUPPORTED_CURVES
 
 #undef  WOLFSSL_BASE64_ENCODE
 #define WOLFSSL_BASE64_ENCODE
 
 /* TLS Session Cache */
 #if 0
     #define SMALL_SESSION_CACHE
 #else
  //   #define NO_SESSION_CACHE
 #endif
 
 
 #undef WOLFSSL_ALLOW_SSLV3
 #define WOLFSSL_ALLOW_SSLV3
 
 #undef WOLFSSL_ALLOW_TLSV10
 #define WOLFSSL_ALLOW_TLSV10
 
 
 /* ------------------------------------------------------------------------- */
 /* Disable Features */
 /* ------------------------------------------------------------------------- */
 #undef  NO_WOLFSSL_SERVER
 //#define NO_WOLFSSL_SERVER
 
 #undef  NO_WOLFSSL_CLIENT
 //#define NO_WOLFSSL_CLIENT
 
 #undef  NO_CRYPT_TEST
 //#define NO_CRYPT_TEST
 
 #undef  NO_CRYPT_BENCHMARK
 //#define NO_CRYPT_BENCHMARK
 
 #undef  WOLFCRYPT_ONLY
 //#define WOLFCRYPT_ONLY
 
 /* In-lining of misc.c functions */
 /* If defined, must include wolfcrypt/src/misc.c in build */
 /* Slower, but about 1k smaller */
 #undef  NO_INLINE
 //#define NO_INLINE
 
 #undef  NO_FILESYSTEM
 //#define NO_FILESYSTEM
 
 #undef  NO_WRITEV
 #define NO_WRITEV
 
 #undef  NO_MAIN_DRIVER
 #define NO_MAIN_DRIVER
 
 #undef  NO_DEV_RANDOM
 //#define NO_DEV_RANDOM
 
 #undef  NO_DSA
 //#define NO_DSA
 
 #undef  NO_RC4
 #define NO_RC4
 
 #undef  NO_OLD_TLS
 //#define NO_OLD_TLS
 
 #undef  NO_HC128
 #define NO_HC128
 
 #undef  NO_RABBIT
 #define NO_RABBIT
 
 #undef  NO_PSK
 #define NO_PSK
 
 #undef  NO_MD4
 #define NO_MD4
 
 #undef  NO_PWDBASED
 //#define NO_PWDBASED
 
 #undef  NO_CODING
 //#define NO_CODING
 
 #undef  NO_ASN_TIME
 //#define NO_ASN_TIME
 
 #undef  NO_CERTS
 //#define NO_CERTS
 
 #undef  NO_SIG_WRAPPER
 //#define NO_SIG_WRAPPER
 
 #undef NO_MAIN_DRIVER
 #define NO_MAIN_DRIVER
 
 #undef BLACKFIN_BUILD
 #define BLACKFIN_BUILD
 
 #ifdef BLACKFIN_BUILD
 
     #include <builtins.h>
 
     #undef WOLFSSL_HAVE_MAX
     #define WOLFSSL_HAVE_MAX
 
     #undef WOLFSSL_HAVE_MIN
     #define WOLFSSL_HAVE_MIN
 
     #include <fss_telnet_shell.h>
 
     #define XMALLOC_OVERRIDE /* Need to use FCL stdlib instead of stdlib.h */
 
     extern void *          fclMalloc   (unsigned int size);
     extern void            fclFree     (void * memoryPointer);
     extern void *          fclRealloc  (void * memoryPointer, unsigned int size);
     #define XMALLOC(a, b, c) fclMalloc(a)
     #define XFREE(a, b, c) fclFree(a)
     #define XREALLOC(a, b, c, d) fclRealloc(a, b)
 
     /*************************************************************
      * wolfSSL testing
      */
 
     typedef struct wolfArgs {
         int argc;
         char** argv;
         int return_code;
         struct fssShellInfo* info;  
     } wolfArgs;
 
     #define printf FCL_PRINTF
 
-    /* CAVP TESTING */
-    #define NO_WOLFCAVP_MAIN_DRIVER
     #define WOLFSSL_BASE16
-    #define USE_UART_READ_LINE
-    #define USE_NORMAL_PRINTF
-    #define VERIFY_GENERATED_PSS_SIGS
-    #define NO_ATTRIBUTE_CONSTRUCTOR
 
     extern int aes_test_for_fips_hash(void);
     int wolfcrypt_test_taskEnter(void *args);
     int wolfcrypt_harness_taskEnter(void *args);
     int wolf_task_start(void* voidinfo, char* argline);
     int wolf_task_results(void* voidinfo, char* argline);
     void wolfFIPS_Module_start(void);
 
     /* For op testing */
    #define USE_CERT_BUFFERS_2048
    #define USE_CERT_BUFFERS_256
    //#define NO_FILESYSTEM
-   
-// #define HAVE_FORCE_FIPS_FAILURE
 
-   #define OPENSSL_EXTRA  //to test if iprgw project need it. AES_xxx wolfSSL_AES_xxx Aes_EncryptDirect
+   #define OPENSSL_EXTRA
    #define OPENSSL_ALL
    #define HAVE_EX_DATA
     #define WOLFSSL_EVP_DECRYPT_LEGACY
 
-   
+
    /* TLS 1.3 support */
-   
    #define WOLFSSL_TLS13
    #define HAVE_TLS_EXTENSIONS
    #define HAVE_SUPPORTED_CURVES
    #define HAVE_ECC
    #define HAVE_HKDF
    #define HAVE_FFDHE_4096
    #define WC_RSA_PSS
-   
+
    /* for static ciphers */
    #define WOLFSSL_STATIC_RSA
     #define WOLFSSL_STATIC_PSK
     #define WOLFSSL_STATIC_EPHEMERAL
    #define WOLFSSL_SNIFFER
-   
+
    /* TEMPORARY */
    #define USING_JTAG
 #endif /* BLACKFIN_BUILD */
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif /* WOLFSSL_USER_SETTINGS_H */
 
diff --git a/src/internal.c b/src/internal.c
index f44268612..6b4abaebf 100644
--- a/src/internal.c
+++ b/src/internal.c
@@ -1,102 +1,101 @@
 /* internal.c
  *
  * Copyright (C) 2006-2020 wolfSSL Inc.
  *
  * This file is part of wolfSSL.
  *
  * wolfSSL is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * wolfSSL is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  */
 
 
 
 #ifdef HAVE_CONFIG_H
     #include <config.h>
 #endif
 
 #include <wolfssl/wolfcrypt/settings.h>
 
 /*
  * WOLFSSL_SMALL_CERT_VERIFY:
  *     Verify the certificate signature without using DecodedCert. Doubles up
  *     on some code but allows smaller peak heap memory usage.
  *     Cannot be used with WOLFSSL_NONBLOCK_OCSP.
  * WOLFSSL_ALT_CERT_CHAINS:
  *     Allows CA's to be presented by peer, but not part of a valid chain.
  *     Default wolfSSL behavior is to require validation of all presented peer
  *     certificates. This also allows loading intermediate CA's as trusted
  *     and ignoring no signer failures for CA's up the chain to root.
  * WOLFSSL_DTLS_RESEND_ONLY_TIMEOUT:
  *     Enable resending the previous DTLS handshake flight only on a network
  *     read timeout. By default we resend in two more cases, when we receive:
  *     - an out of order last msg of the peer's flight
  *     - a duplicate of the first msg from the peer's flight
  */
 
 
 #ifdef EXTERNAL_OPTS_OPENVPN
 #error EXTERNAL_OPTS_OPENVPN should not be defined\
     when building wolfSSL
 #endif
 
 #ifndef WOLFCRYPT_ONLY
 
 #include <wolfssl/internal.h>
 #include <wolfssl/error-ssl.h>
 #include <wolfssl/wolfcrypt/asn.h>
 #include <wolfssl/wolfcrypt/dh.h>
 #ifdef NO_INLINE
     #include <wolfssl/wolfcrypt/misc.h>
 #else
     #define WOLFSSL_MISC_INCLUDED
     #include <wolfcrypt/src/misc.c>
 #endif
 #if defined(OPENSSL_EXTRA) && defined(WOLFCRYPT_HAVE_SRP) && !defined(NO_SHA)
     #include <wolfssl/wolfcrypt/srp.h>
 #endif
 
 #ifdef HAVE_LIBZ
     #include "zlib.h"
 #endif
 
 #ifdef HAVE_NTRU
     #include "libntruencrypt/ntru_crypto.h"
 #endif
 
 #if defined(DEBUG_WOLFSSL) || defined(SHOW_SECRETS) || \
     defined(CHACHA_AEAD_TEST) || defined(WOLFSSL_SESSION_EXPORT_DEBUG)
     #ifndef NO_STDIO_FILESYSTEM
-        #ifndef FUSION_RTOS
-        #include <stdio.h>
-    #endif
         #ifdef FUSION_RTOS
-          #include <fclstdio.h>
-         #endif
+            #include <fclstdio.h>
+        #else
+            #include <stdio.h>
+        #endif
     #endif
 #endif
 
 #ifdef __sun
     #include <sys/filio.h>
 #endif
 
 
 #define ERROR_OUT(err, eLabel) { ret = (err); goto eLabel; }
 
 #ifdef _MSC_VER
     /* disable for while(0) cases at the .c level for now */
     #pragma warning(disable:4127)
 #endif
 
 #if defined(WOLFSSL_CALLBACKS) && !defined(LARGE_STATIC_BUFFERS)
     #error \
diff --git a/src/sniffer.c b/src/sniffer.c
index 33588059b..6f6d996ec 100644
--- a/src/sniffer.c
+++ b/src/sniffer.c
@@ -1,114 +1,118 @@
 /* sniffer.c
  *
  * Copyright (C) 2006-2020 wolfSSL Inc.
  *
  * This file is part of wolfSSL.
  *
  * wolfSSL is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * wolfSSL is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  */
 
 
 #ifdef HAVE_CONFIG_H
     #include <config.h>
 #endif
 
 #include <wolfssl/wolfcrypt/settings.h>
 #include <wolfssl/wolfcrypt/wc_port.h>
 
 /* xctime */
 #ifndef XCTIME
    #define XCTIME ctime
 #endif
 
 /* only in this file, to avoid confusing future ports leave
  * these defines here. Do not move to wc_port.h */
-#ifdef FUSION_RTOS
+#ifdef USER_CUSTOM_SNIFFX
+    /* To be implemented in user_settings.h */
+    #warning "Please implement Sniffer porting in user_settings.h"
+#elif defined(FUSION_RTOS)
     #include <fcl_network.h>
     #define XINET_NTOA FNS_INET_NTOA
     #define XINET_ATON FNS_INET_ATON
     #define XINET_PTON(a,b,c,d) FNS_INET_PTON((a),(b),(c),(d),NULL)
     #define XINET_NTOP(a,b,c,d) FNS_INET_NTOP((a),(b),(c),(d),NULL)
     #define XINET_ADDR FNS_INET_ADDR
     #define XHTONS FNS_HTONS
     #define XNTOHS FNS_NTOHS
     #define XHTONL FNS_HTONL
     #define XNTOHL FNS_NTOHL
     #define XINADDR_NONE FNS_INADDR_NONE
 #else
+    /* default */
     #define XINET_NTOA inet_ntoa
     #define XINET_ATON inet_aton
     #define XINET_PTON(a,b,c) inet_pton((a),(b),(c))
     #define XINET_NTOP inet_ntop
     #define XINET_ADDR inet_addr
     #define XHTONS htons
     #define XNTOHS ntohs
     #define XHTONL htonl
     #define XNTOHL ntohl
     #define XINADDR_NONE INADDR_NONE
 #endif
 
 #if !defined(WOLFCRYPT_ONLY) && !defined(NO_FILESYSTEM)
 #ifdef WOLFSSL_SNIFFER
 
 #include <assert.h>
 #include <time.h>
 
 #ifdef FUSION_RTOS
     #include <fns_inet.h>
     #ifdef TCP_PROTOCOL
         #undef TCP_PROTOCOL
     #endif
 #else
     #ifndef _WIN32
         #include <arpa/inet.h>
     #else
         #include <WS2tcpip.h>
     #endif
 #endif
 
 #ifdef _WIN32
     #define SNPRINTF _snprintf
 #else
     #define SNPRINTF snprintf
 #endif
 
 #include <wolfssl/internal.h>
 #include <wolfssl/error-ssl.h>
 #include <wolfssl/sniffer.h>
 #include <wolfssl/sniffer_error.h>
 #ifdef NO_INLINE
     #include <wolfssl/wolfcrypt/misc.h>
 #else
     #define WOLFSSL_MISC_INCLUDED
     #include <wolfcrypt/src/misc.c>
 #endif
 
 #ifdef WOLF_CRYPTO_CB
     #include <wolfssl/wolfcrypt/cryptocb.h>
     #ifdef HAVE_INTEL_QA_SYNC
         #include <wolfssl/wolfcrypt/port/intel/quickassist_sync.h>
     #endif
     #ifdef HAVE_CAVIUM_OCTEON_SYNC
         #include <wolfssl/wolfcrypt/port/cavium/cavium_octeon_sync.h>
     #endif
 #endif
 
 
 #ifndef WOLFSSL_SNIFFER_TIMEOUT
     #define WOLFSSL_SNIFFER_TIMEOUT 900
     /* Cache unclosed Sessions for 15 minutes since last used */
 #endif
 
 /* Misc constants */
diff --git a/src/ssl.c b/src/ssl.c
index e24193f61..49d0bdcac 100644
--- a/src/ssl.c
+++ b/src/ssl.c
@@ -1,154 +1,153 @@
 /* ssl.c
  *
  * Copyright (C) 2006-2020 wolfSSL Inc.
  *
  * This file is part of wolfSSL.
  *
  * wolfSSL is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
  *
  * wolfSSL is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
  */
 
 
 #ifdef HAVE_CONFIG_H
     #include <config.h>
 #endif
 
 #include <wolfssl/wolfcrypt/settings.h>
 #if defined(OPENSSL_EXTRA) && !defined(_WIN32)
     /* turn on GNU extensions for XVASPRINTF with wolfSSL_BIO_printf */
     #undef  _GNU_SOURCE
     #define _GNU_SOURCE
-    #include <stdarg.h>
 #endif
 
 #if !defined(WOLFCRYPT_ONLY) || defined(OPENSSL_EXTRA) || \
     defined(OPENSSL_EXTRA_X509_SMALL)
 
 #include <wolfssl/internal.h>
 #include <wolfssl/error-ssl.h>
 #include <wolfssl/wolfcrypt/coding.h>
 #ifdef NO_INLINE
     #include <wolfssl/wolfcrypt/misc.h>
 #else
     #define WOLFSSL_MISC_INCLUDED
     #include <wolfcrypt/src/misc.c>
 #endif
 
 #ifdef HAVE_ERRNO_H
     #include <errno.h>
 #endif
 
 
 #if !defined(WOLFSSL_ALLOW_NO_SUITES) && !defined(WOLFCRYPT_ONLY)
     #if defined(NO_DH) && !defined(HAVE_ECC) && !defined(WOLFSSL_STATIC_RSA) \
                 && !defined(WOLFSSL_STATIC_DH) && !defined(WOLFSSL_STATIC_PSK) \
                 && !defined(HAVE_CURVE25519) && !defined(HAVE_CURVE448)
         #error "No cipher suites defined because DH disabled, ECC disabled, and no static suites defined. Please see top of README"
     #endif
     #ifdef WOLFSSL_CERT_GEN
         /* need access to Cert struct for creating certificate */
         #include <wolfssl/wolfcrypt/asn_public.h>
     #endif
 #endif
 
 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) || \
         defined(HAVE_WEBSERVER) || defined(WOLFSSL_KEY_GEN)
     #include <wolfssl/openssl/evp.h>
     /* openssl headers end, wolfssl internal headers next */
 #endif
 
 #include <wolfssl/wolfcrypt/wc_encrypt.h>
 
 #ifndef NO_RSA
     #include <wolfssl/wolfcrypt/rsa.h>
 #endif
 
 #ifdef OPENSSL_EXTRA
     /* openssl headers begin */
     #include <wolfssl/openssl/aes.h>
     #include <wolfssl/openssl/hmac.h>
     #include <wolfssl/openssl/crypto.h>
     #include <wolfssl/openssl/des.h>
     #include <wolfssl/openssl/bn.h>
     #include <wolfssl/openssl/buffer.h>
     #include <wolfssl/openssl/dh.h>
     #include <wolfssl/openssl/rsa.h>
     #include <wolfssl/openssl/pem.h>
     #include <wolfssl/openssl/ec.h>
     #include <wolfssl/openssl/ec25519.h>
     #include <wolfssl/openssl/ed25519.h>
     #include <wolfssl/openssl/ec448.h>
     #include <wolfssl/openssl/ed448.h>
     #include <wolfssl/openssl/ecdsa.h>
     #include <wolfssl/openssl/ecdh.h>
     #include <wolfssl/openssl/err.h>
     #include <wolfssl/openssl/opensslv.h>
     #include <wolfssl/openssl/rc4.h>
     #include <wolfssl/openssl/stack.h>
     #include <wolfssl/openssl/x509_vfy.h>
     /* openssl headers end, wolfssl internal headers next */
     #include <wolfssl/wolfcrypt/hmac.h>
     #include <wolfssl/wolfcrypt/random.h>
     #include <wolfssl/wolfcrypt/des3.h>
     #include <wolfssl/wolfcrypt/ecc.h>
     #include <wolfssl/wolfcrypt/md4.h>
     #include <wolfssl/wolfcrypt/md5.h>
     #include <wolfssl/wolfcrypt/arc4.h>
     #include <wolfssl/wolfcrypt/idea.h>
     #include <wolfssl/wolfcrypt/curve25519.h>
     #include <wolfssl/wolfcrypt/ed25519.h>
     #include <wolfssl/wolfcrypt/curve448.h>
     #if defined(OPENSSL_ALL) || defined(HAVE_STUNNEL)
         #include <wolfssl/openssl/ocsp.h>
         #include <wolfssl/openssl/lhash.h>
         #include <wolfssl/openssl/txt_db.h>
     #endif /* WITH_STUNNEL */
     #if defined(WOLFSSL_SHA512) || defined(WOLFSSL_SHA384)
         #include <wolfssl/wolfcrypt/sha512.h>
     #endif
     #if defined(WOLFCRYPT_HAVE_SRP) && !defined(NO_SHA256) \
         && !defined(WC_NO_RNG)
         #include <wolfssl/wolfcrypt/srp.h>
     #endif
     #if defined(HAVE_FIPS) || defined(HAVE_SELFTEST)
         #include <wolfssl/wolfcrypt/pkcs7.h>
     #endif
     #if defined(OPENSSL_ALL) && defined(HAVE_PKCS7)
         #include <wolfssl/openssl/pkcs7.h>
     #endif /* OPENSSL_ALL && HAVE_PKCS7 */
 #endif
 
 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
     #include <wolfssl/openssl/x509v3.h>
     int SetIndividualInternal(WOLFSSL_BIGNUM* bn, mp_int* mpi);
     int SetIndividualExternal(WOLFSSL_BIGNUM** bn, mp_int* mpi);
     int oid2nid(word32 oid, int grp);
 #endif
 
 #if defined(WOLFSSL_QT)
     #include <wolfssl/wolfcrypt/sha.h>
 #endif
 
 #ifdef NO_ASN
     #include <wolfssl/wolfcrypt/dh.h>
 #endif
 #endif /* !WOLFCRYPT_ONLY || OPENSSL_EXTRA */
 
 #define WOLFSSL_EVP_INCLUDED
 #include "wolfcrypt/src/evp.c"
 
 #ifndef WOLFCRYPT_ONLY
 
 #ifdef OPENSSL_EXTRA
 /* Global pointer to constant BN on */
diff --git a/src/tls13.c b/src/tls13.c
index 7aec3a3be..b16cdb1d5 100644
--- a/src/tls13.c
+++ b/src/tls13.c
@@ -1142,258 +1142,271 @@ int DeriveTls13Keys(WOLFSSL* ssl, int secret, int side, int store)
 end:
 #ifdef WOLFSSL_SMALL_STACK
     XFREE(key_dig, ssl->heap, DYNAMIC_TYPE_DIGEST);
 #endif
 
     return ret;
 }
 
 #ifdef HAVE_SESSION_TICKET
 #if defined(USER_TICKS)
 #if 0
     word32 TimeNowInMilliseconds(void)
     {
         /*
         write your own clock tick function if don't want gettimeofday()
         needs millisecond accuracy but doesn't have to correlated to EPOCH
         */
     }
 #endif
 
 #elif defined(TIME_OVERRIDES)
     #ifndef HAVE_TIME_T_TYPE
         typedef long time_t;
     #endif
     extern time_t XTIME(time_t * timer);
 
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         return (word32) XTIME(0) * 1000;
     }
 
 #elif defined(XTIME_MS)
     word32 TimeNowInMilliseconds(void)
     {
         return (word32)XTIME_MS(0);
     }
 
 #elif defined(USE_WINDOWS_API)
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         static int           init = 0;
         static LARGE_INTEGER freq;
         LARGE_INTEGER        count;
 
         if (!init) {
             QueryPerformanceFrequency(&freq);
             init = 1;
         }
 
         QueryPerformanceCounter(&count);
 
         return (word32)(count.QuadPart / (freq.QuadPart / 1000));
     }
 
 #elif defined(HAVE_RTP_SYS)
     #include "rtptime.h"
 
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         return (word32)rtp_get_system_sec() * 1000;
     }
 #elif defined(WOLFSSL_DEOS)
     word32 TimeNowInMilliseconds(void)
     {
         const word32 systemTickTimeInHz = 1000000 / systemTickInMicroseconds();
         word32 *systemTickPtr = systemTickPointer();
 
         return (word32) (*systemTickPtr/systemTickTimeInHz) * 1000;
     }
 #elif defined(MICRIUM)
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         OS_TICK ticks = 0;
         OS_ERR  err;
 
         ticks = OSTimeGet(&err);
 
         return (word32) (ticks / OSCfg_TickRate_Hz) * 1000;
     }
 #elif defined(MICROCHIP_TCPIP_V5)
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         return (word32) (TickGet() / (TICKS_PER_SECOND / 1000));
     }
 #elif defined(MICROCHIP_TCPIP)
     #if defined(MICROCHIP_MPLAB_HARMONY)
         #include <system/tmr/sys_tmr.h>
 
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         return (word32)(SYS_TMR_TickCountGet() /
                         (SYS_TMR_TickCounterFrequencyGet() / 1000));
     }
     #else
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         return (word32)(SYS_TICK_Get() / (SYS_TICK_TicksPerSecondGet() / 1000));
     }
 
     #endif
 
 #elif defined(FREESCALE_MQX) || defined(FREESCALE_KSDK_MQX)
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         TIME_STRUCT mqxTime;
 
         _time_get_elapsed(&mqxTime);
 
         return (word32) mqxTime.SECONDS * 1000;
     }
 #elif defined(FREESCALE_FREE_RTOS) || defined(FREESCALE_KSDK_FREERTOS)
     #include "include/task.h"
 
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         return (unsigned int)(((float)xTaskGetTickCount()) /
                               (configTICK_RATE_HZ / 1000));
     }
 #elif defined(FREESCALE_KSDK_BM)
     #include "lwip/sys.h" /* lwIP */
 
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         return sys_now();
     }
 #elif defined(WOLFSSL_TIRTOS)
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         return (word32) Seconds_get() * 1000;
     }
 #elif defined(WOLFSSL_UTASKER)
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         return (word32)(uTaskerSystemTick / (TICK_RESOLUTION / 1000));
     }
 #elif defined(WOLFSSL_LINUXKM)
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
     #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
         return (word32)(ktime_get_real_ns() / (s64)1000000);
     #else
         return (word32)(ktime_get_real_ns() / (ktime_t)1000000);
     #endif
     }
-#else
+#elif defined(FUSION_RTOS)
     /* The time in milliseconds.
      * Used for tickets to represent difference between when first seen and when
      * sending.
      *
      * returns the time in milliseconds as a 32-bit value.
      */
     word32 TimeNowInMilliseconds(void)
     {
         struct timeval now;
-#ifdef FUSION_RTOS
         if (FCL_GETTIMEOFDAY(&now, 0) < 0)
             return (word32)GETTIME_ERROR;
-            //TODO research why negative error code returns as word32
+
+        /* Convert to milliseconds number. */
+        return (word32)(now.tv_sec * 1000 + now.tv_usec / 1000);
+    }
+
 #else
+    /* The time in milliseconds.
+     * Used for tickets to represent difference between when first seen and when
+     * sending.
+     *
+     * returns the time in milliseconds as a 32-bit value.
+     */
+    word32 TimeNowInMilliseconds(void)
+    {
+        struct timeval now;
+
         if (gettimeofday(&now, 0) < 0)
             return (word32)GETTIME_ERROR;
-#endif
+
         /* Convert to milliseconds number. */
         return (word32)(now.tv_sec * 1000 + now.tv_usec / 1000);
     }
 #endif
 #endif /* HAVE_SESSION_TICKET || !NO_PSK */
 
 
 /* Extract the handshake header information.
  *
  * ssl       The SSL/TLS object.
  * input     The buffer holding the message data.
  * inOutIdx  On entry, the index into the buffer of the handshake data.
  *           On exit, the start of the handshake data.
  * type      Type of handshake message.
  * size      The length of the handshake message data.
  * totalSz   The total size of data in the buffer.
  * returns BUFFER_E if there is not enough input data and 0 on success.
  */
diff --git a/src/wolfio.c b/src/wolfio.c
index 9ca62700f..1f5030d99 100644
--- a/src/wolfio.c
+++ b/src/wolfio.c
@@ -696,26 +696,9 @@ static int linuxkm_recv(struct socket *socket, void *buf, int size,
 int wolfIO_Recv(SOCKET_T sd, char *buf, int sz, int rdFlags)
 {
     int recvd;
 
-#ifdef FUSION_RTOS
-    int err;
-retry:
-    recvd = (int)RECV_FUNCTION(sd, buf, sz, rdFlags, &err);
-
-    if(recvd < 0) {
-       if(err==63)
-       {
-           UARTF("FUSION IO RETRY %d\r\n", err);
-           fclThreadSleep(10);
-           goto retry; 
-       }
-       UARTF("FUSION IO ERROR %d\r\n", err);
-    }
-    //TODO handle return value in err
-#else
     recvd = (int)RECV_FUNCTION(sd, buf, sz, rdFlags);
-#endif
     recvd = TranslateReturnCode(recvd, sd);
 
     return recvd;
 }
@@ -723,104 +706,90 @@ retry:
 int wolfIO_Send(SOCKET_T sd, char *buf, int sz, int wrFlags)
 {
     int sent;
-#ifdef FUSION_RTOS
-    int err;
-retry:
-    sent = (int)SEND_FUNCTION(sd, buf, sz, wrFlags, &err);
-    if(sent < 0) {
-       if(err==63)
-       {
-           UARTF("FUSION IO SEND RETRY %d\r\n", err);
-           fclThreadSleep(10);
-           goto retry; 
-       }
-       UARTF("FUSION IO SEND ERROR %d\r\n", err);
-    }
-#else
+
     sent = (int)SEND_FUNCTION(sd, buf, sz, wrFlags);
-#endif
     sent = TranslateReturnCode(sent, sd);
 
     return sent;
 }
 
 #endif /* USE_WOLFSSL_IO */
 
 
 #ifdef HAVE_HTTP_CLIENT
 
 #ifndef HAVE_IO_TIMEOUT
     #define io_timeout_sec 0
 #else
 
     #ifndef DEFAULT_TIMEOUT_SEC
         #define DEFAULT_TIMEOUT_SEC 0 /* no timeout */
     #endif
 
     static int io_timeout_sec = DEFAULT_TIMEOUT_SEC;
 
     void wolfIO_SetTimeout(int to_sec)
     {
         io_timeout_sec = to_sec;
     }
 
     int wolfIO_SetBlockingMode(SOCKET_T sockfd, int non_blocking)
     {
         int ret = 0;
 
     #ifdef USE_WINDOWS_API
         unsigned long blocking = non_blocking;
         ret = ioctlsocket(sockfd, FIONBIO, &blocking);
         if (ret == SOCKET_ERROR)
             ret = -1;
     #else
         ret = fcntl(sockfd, F_GETFL, 0);
         if (ret >= 0) {
             if (non_blocking)
                 ret |= O_NONBLOCK;
             else
                 ret &= ~O_NONBLOCK;
             ret = fcntl(sockfd, F_SETFL, ret);
         }
     #endif
         if (ret < 0) {
             WOLFSSL_MSG("wolfIO_SetBlockingMode failed");
         }
 
         return ret;
     }
 
     int wolfIO_Select(SOCKET_T sockfd, int to_sec)
     {
         fd_set rfds, wfds;
         int nfds = 0;
         struct timeval timeout = { (to_sec > 0) ? to_sec : 0, 0};
         int ret;
 
     #ifndef USE_WINDOWS_API
         nfds = (int)sockfd + 1;
     #endif
 
         FD_ZERO(&rfds);
         FD_SET(sockfd, &rfds);
         wfds = rfds;
 
         ret = select(nfds, &rfds, &wfds, NULL, &timeout);
         if (ret == 0) {
         #ifdef DEBUG_HTTP
             printf("Timeout: %d\n", ret);
         #endif
             return HTTP_TIMEOUT;
         }
         else if (ret > 0) {
             if (FD_ISSET(sockfd, &wfds)) {
                 if (!FD_ISSET(sockfd, &rfds)) {
                     return 0;
                 }
             }
         }
                     WOLFSSL_MSG("Select error");
 
         return SOCKET_ERROR_E;
     }
 #endif /* HAVE_IO_TIMEOUT */
@@ -1435,87 +1404,81 @@ int wolfIO_HttpProcessResponseOcsp(int sfd, byte** respBuf,
 /* in default wolfSSL callback ctx is the heap pointer */
 int EmbedOcspLookup(void* ctx, const char* url, int urlSz,
                         byte* ocspReqBuf, int ocspReqSz, byte** ocspRespBuf)
 {
     SOCKET_T sfd = SOCKET_INVALID;
     word16   port;
     int      ret = -1;
 #ifdef WOLFSSL_SMALL_STACK
     char*    path;
     char*    domainName;
 #else
     char     path[MAX_URL_ITEM_SIZE];
     char     domainName[MAX_URL_ITEM_SIZE];
 #endif
 
 #ifdef WOLFSSL_SMALL_STACK
     path = (char*)XMALLOC(MAX_URL_ITEM_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);
     if (path == NULL)
         return MEMORY_E;
 
     domainName = (char*)XMALLOC(MAX_URL_ITEM_SIZE, NULL,
             DYNAMIC_TYPE_TMP_BUFFER);
     if (domainName == NULL) {
         XFREE(path, NULL, DYNAMIC_TYPE_TMP_BUFFER);
         return MEMORY_E;
     }
 #endif
 
     if (ocspReqBuf == NULL || ocspReqSz == 0) {
         WOLFSSL_MSG("OCSP request is required for lookup");
     }
     else if (ocspRespBuf == NULL) {
         WOLFSSL_MSG("Cannot save OCSP response");
     }
     else if (wolfIO_DecodeUrl(url, urlSz, domainName, path, &port) < 0) {
         WOLFSSL_MSG("Unable to decode OCSP URL");
     }
     else {
         /* Note, the library uses the EmbedOcspRespFree() callback to
          * free this buffer. */
         int   httpBufSz = HTTP_SCRATCH_BUFFER_SIZE;
         byte* httpBuf   = (byte*)XMALLOC(httpBufSz, ctx, DYNAMIC_TYPE_OCSP);
 
         if (httpBuf == NULL) {
             WOLFSSL_MSG("Unable to create OCSP response buffer");
         }
         else {
             httpBufSz = wolfIO_HttpBuildRequestOcsp(domainName, path, ocspReqSz,
                                                             httpBuf, httpBufSz);
 
             ret = wolfIO_TcpConnect(&sfd, domainName, port, io_timeout_sec);
             if (ret != 0) {
                 WOLFSSL_MSG("OCSP Responder connection failed");
             }
             else if (wolfIO_Send(sfd, (char*)httpBuf, httpBufSz, 0) !=
                                                                     httpBufSz) {
                 WOLFSSL_MSG("OCSP http request failed");
             }
             else if (wolfIO_Send(sfd, (char*)ocspReqBuf, ocspReqSz, 0) !=
                                                                     ocspReqSz) {
                 WOLFSSL_MSG("OCSP ocsp request failed");
             }
             else {
                 ret = wolfIO_HttpProcessResponseOcsp(sfd, ocspRespBuf, httpBuf,
                                                  HTTP_SCRATCH_BUFFER_SIZE, ctx);
             }
-            if (sfd != SOCKET_INVALID) {
-            #ifdef FUSION_RTOS
-                int err;
-                CloseSocket(sfd, &err);
-            #else
+            if (sfd != SOCKET_INVALID)
                 CloseSocket(sfd);
-            #endif
-            }
             XFREE(httpBuf, ctx, DYNAMIC_TYPE_OCSP);
         }
     }
 
 #ifdef WOLFSSL_SMALL_STACK
     XFREE(path,       NULL, DYNAMIC_TYPE_TMP_BUFFER);
     XFREE(domainName, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 #endif
 
     return ret;
 }
 
 /* in default callback ctx is heap hint */
diff --git a/wolfssl/wolfcrypt/wc_port.h b/wolfssl/wolfcrypt/wc_port.h
index bd5f08baa..1ce533e8a 100644
--- a/wolfssl/wolfcrypt/wc_port.h
+++ b/wolfssl/wolfcrypt/wc_port.h
@@ -464,626 +464,601 @@ WOLFSSL_API int wolfCrypt_Init(void);
 WOLFSSL_API int wolfCrypt_Cleanup(void);
 
 #ifdef WOLFSSL_TRACK_MEMORY_VERBOSE
     WOLFSSL_API long wolfCrypt_heap_peakAllocs_checkpoint(void);
     WOLFSSL_API long wolfCrypt_heap_peakBytes_checkpoint(void);
 #endif
 
 
 /* FILESYSTEM SECTION */
 /* filesystem abstraction layer, used by ssl.c */
 #ifndef NO_FILESYSTEM
 
 #if defined(EBSNET)
     #include "vfapi.h"
     #include "vfile.h"
 
     int ebsnet_fseek(int a, long b, int c); /* Not prototyped in vfile.h per
                                              * EBSnet feedback */
 
     #define XFILE                    int
     #define XFOPEN(NAME, MODE)       vf_open((const char *)NAME, VO_RDONLY, 0);
     #define XFSEEK                   ebsnet_fseek
     #define XFTELL                   vf_tell
     #define XREWIND                  vf_rewind
     #define XFREAD(BUF, SZ, AMT, FD) vf_read(FD, BUF, SZ*AMT)
     #define XFWRITE(BUF, SZ, AMT, FD) vf_write(FD, BUF, SZ*AMT)
     #define XFCLOSE                  vf_close
     #define XSEEK_END                VSEEK_END
     #define XBADFILE                 -1
     #define XFGETS(b,s,f)            -2 /* Not ported yet */
-    #define XVFPRINTF                vfprintf
-    #define XVSNPRINTF               vsnprintf
-    #define XFPUTS                   fputs
-    #define XSPRINTF                 sprintf
 
 #elif defined(LSR_FS)
     #include <fs.h>
     #define XFILE                   struct fs_file*
     #define XFOPEN(NAME, MODE)      fs_open((char*)NAME);
     #define XFSEEK(F, O, W)         (void)F
     #define XFTELL(F)               (F)->len
     #define XREWIND(F)              (void)F
     #define XFREAD(BUF, SZ, AMT, F) fs_read(F, (char*)BUF, SZ*AMT)
     #define XFWRITE(BUF, SZ, AMT, F) fs_write(F, (char*)BUF, SZ*AMT)
     #define XFCLOSE                 fs_close
     #define XSEEK_END               0
     #define XBADFILE                NULL
     #define XFGETS(b,s,f)           -2 /* Not ported yet */
-    #define XVFPRINTF               vfprintf
-    #define XVSNPRINTF              vsnprintf
-    #define XFPUTS                  fputs
-    #define XSPRINTF                sprintf
 
 #elif defined(FREESCALE_MQX) || defined(FREESCALE_KSDK_MQX)
     #define XFILE                   MQX_FILE_PTR
     #define XFOPEN                  fopen
     #define XFSEEK                  fseek
     #define XFTELL                  ftell
     #define XREWIND(F)              fseek(F, 0, IO_SEEK_SET)
     #define XFREAD                  fread
     #define XFWRITE                 fwrite
     #define XFCLOSE                 fclose
     #define XSEEK_END               IO_SEEK_END
     #define XBADFILE                NULL
     #define XFGETS                  fgets
-    #define XVFPRINTF               vfprintf
-    #define XVSNPRINTF              vsnprintf
-    #define XFPUTS                  fputs
-    #define XSPRINTF                sprintf
 
 #elif defined(WOLFSSL_DEOS)
     #define NO_FILESYSTEM
     #warning "TODO - DDC-I Certifiable Fast File System for Deos is not integrated"
     /* #define XFILE      bfd * */
-    #define XVFPRINTF  vfprintf
-    #define XVSNPRINTF vsnprintf
-    #define XFPUTS     fputs
-    #define XSPRINTF   sprintf
 
 #elif defined(MICRIUM)
     #include <fs_api.h>
     #define XFILE      FS_FILE*
     #define XFOPEN     fs_fopen
     #define XFSEEK     fs_fseek
     #define XFTELL     fs_ftell
     #define XREWIND    fs_rewind
     #define XFREAD     fs_fread
     #define XFWRITE    fs_fwrite
     #define XFCLOSE    fs_fclose
     #define XSEEK_END  FS_SEEK_END
     #define XBADFILE   NULL
     #define XFGETS(b,s,f) -2 /* Not ported yet */
-    #define XVFPRINTF  vfprintf
-    #define XVSNPRINTF vsnprintf
-    #define XFPUTS     fputs
-    #define XSPRINTF   sprintf
 
 #elif defined(WOLFSSL_NUCLEUS_1_2)
     #include "fal/inc/fal.h"
     #define XFILE      FILE*
     #define XFOPEN     fopen
     #define XFSEEK     fseek
     #define XFTELL     ftell
     #define XREWIND    rewind
     #define XFREAD     fread
     #define XFWRITE    fwrite
     #define XFCLOSE    fclose
     #define XSEEK_END  PSEEK_END
     #define XBADFILE   NULL
-    #define XVFPRINTF  vfprintf
-    #define XVSNPRINTF vsnprintf
-    #define XFPUTS     fputs
-    #define XSPRINTF   sprintf
 
 #elif defined(WOLFSSL_APACHE_MYNEWT)
     #include <fs/fs.h>
     #define XFILE  struct fs_file*
 
     #define XFOPEN     mynewt_fopen
     #define XFSEEK     mynewt_fseek
     #define XFTELL     mynewt_ftell
     #define XREWIND    mynewt_rewind
     #define XFREAD     mynewt_fread
     #define XFWRITE    mynewt_fwrite
     #define XFCLOSE    mynewt_fclose
     #define XSEEK_END  2
     #define XBADFILE   NULL
     #define XFGETS(b,s,f) -2 /* Not ported yet */
-    #define XVFPRINTF  vfprintf
-    #define XVSNPRINTF vsnprintf
-    #define XFPUTS     fputs
-    #define XSPRINTF   sprintf
 
 #elif defined(WOLFSSL_ZEPHYR)
     #include <fs.h>
 
     #define XFILE      struct fs_file_t*
     #define STAT       struct fs_dirent
 
     XFILE z_fs_open(const char* filename, const char* perm);
     int z_fs_close(XFILE file);
 
     #define XFOPEN              z_fs_open
     #define XFCLOSE             z_fs_close
     #define XFSEEK              fs_seek
     #define XFTELL              fs_tell
     #define XFREWIND            fs_rewind
     #define XREWIND(F)          fs_seek(F, 0, FS_SEEK_SET)
     #define XFREAD(P,S,N,F)     fs_read(F, P, S*N)
     #define XFWRITE(P,S,N,F)    fs_write(F, P, S*N)
     #define XSEEK_END           FS_SEEK_END
     #define XBADFILE            NULL
     #define XFGETS(b,s,f)       -2 /* Not ported yet */
-    #define XVFPRINTF           vfprintf
-    #define XVSNPRINTF          vsnprintf
-    #define XFPUTS              fputs
-    #define XSPRINTF            sprintf
 
 #elif defined(WOLFSSL_TELIT_M2MB)
     #define XFILE                    INT32
     #define XFOPEN(NAME, MODE)       m2mb_fs_open((NAME), 0, (MODE))
     #define XFSEEK(F, O, W)          m2mb_fs_lseek((F), (O), (W))
     #define XFTELL(F)                m2mb_fs_lseek((F), 0, M2MB_SEEK_END)
     #define XREWIND(F)               (void)F
     #define XFREAD(BUF, SZ, AMT, F)  m2mb_fs_read((F), (BUF), (SZ)*(AMT))
     #define XFWRITE(BUF, SZ, AMT, F) m2mb_fs_write((F), (BUF), (SZ)*(AMT))
     #define XFCLOSE                  m2mb_fs_close
     #define XSEEK_END                M2MB_SEEK_END
     #define XBADFILE                 -1
     #define XFGETS(b,s,f)            -2 /* Not ported yet */
-    #define XVFPRINTF  vfprintf
-    #define XVSNPRINTF               vsnprintf
-    #define XFPUTS                   fputs
-    #define XSPRINTF                 sprintf
 
 #elif defined (WOLFSSL_XILINX)
     #include "xsdps.h"
     #include "ff.h"
 
     /* workaround to declare variable and provide type */
     #define XFILE                    FIL curFile; FIL*
     #define XFOPEN(NAME, MODE)       ({ FRESULT res; res = f_open(&curFile, (NAME), (FA_OPEN_ALWAYS | FA_WRITE | FA_READ)); (res == FR_OK) ? &curFile : NULL; })
     #define XFSEEK(F, O, W)          f_lseek((F), (O))
     #define XFTELL(F)                f_tell((F))
     #define XREWIND(F)               f_rewind((F))
     #define XFREAD(BUF, SZ, AMT, F)  ({ FRESULT res; UINT br; res = f_read((F), (BUF), (SZ)*(AMT), &br); (void)br; res; })
     #define XFWRITE(BUF, SZ, AMT, F) ({ FRESULT res; UINT written; res = f_write((F), (BUF), (SZ)*(AMT), &written); (void)written; res; })
     #define XFCLOSE(F)               f_close((F))
     #define XSEEK_END                0
     #define XBADFILE                 NULL
     #define XFGETS(b,s,f)            f_gets((b), (s), (f))
-    #define XVFPRINTF  vfprintf
-    #define XVSNPRINTF               vsnprintf
-    #define XFPUTS                   fputs
-    #define XSPRINTF                 sprintf
 
 #elif defined(FUSION_RTOS)
     #include <fclstdio.h>
     #include <fclunistd.h>
     #include <fcldirent.h>
     #include <sys/fclstat.h>
-   #include <fclstring.h>
-   #include <fcl_os.h>
+    #include <fclstring.h>
+    #include <fcl_os.h>
     #define XFILE     FCL_FILE*
     #define XFOPEN    FCL_FOPEN
     #define XFSEEK    FCL_FSEEK
     #define XFTELL    FCL_FTELL
     #define XREWIND   FCL_REWIND
     #define XFREAD    FCL_FREAD
     #define XFWRITE   FCL_FWRITE
     #define XFCLOSE   FCL_FCLOSE
     #define XSEEK_END SEEK_END
     #define XBADFILE  NULL
     #define XFGETS    FCL_FGETS
     #define XFPUTS    FCL_FPUTS
     #define XFPRINTF  FCL_FPRINTF
     #define XVFPRINTF FCL_VFPRINTF
     #define XVSNPRINTF  FCL_VSNPRINTF
     #define XSNPRINTF  FCL_SNPRINTF
     #define XSPRINTF  FCL_SPRINTF
     #define DIR       FCL_DIR
     #define stat      FCL_STAT
     #define opendir   FCL_OPENDIR
     #define closedir  FCL_CLOSEDIR
     #define readdir   FCL_READDIR
     #define dirent    fclDirent 
     #define strncasecmp FCL_STRNCASECMP
 
+    /* FUSION SPECIFIC ERROR CODE */
+    #define FUSION_IO_SEND_E 63
+
 #elif defined(WOLFSSL_USER_FILESYSTEM)
     /* To be defined in user_settings.h */
 #else
     /* stdio, default case */
     #include <stdio.h>
     #define XFILE      FILE*
     #if defined(WOLFSSL_MDK_ARM)
         extern FILE * wolfSSL_fopen(const char *name, const char *mode) ;
         #define XFOPEN     wolfSSL_fopen
     #else
         #define XFOPEN     fopen
     #endif
     #define XFDOPEN    fdopen
     #define XFSEEK     fseek
     #define XFTELL     ftell
     #define XREWIND    rewind
     #define XFREAD     fread
     #define XFWRITE    fwrite
     #define XFCLOSE    fclose
     #define XSEEK_END  SEEK_END
     #define XBADFILE   NULL
     #define XFGETS     fgets
     #define XFPRINTF   fprintf
-    #define XVFPRINTF  vfprintf
-    #define XVSNPRINTF vsnprintf
-    #define XFPUTS     fputs
-    #define XSPRINTF   sprintf
 
     #if !defined(USE_WINDOWS_API) && !defined(NO_WOLFSSL_DIR)\
         && !defined(WOLFSSL_NUCLEUS) && !defined(WOLFSSL_NUCLEUS_1_2)
         #include <dirent.h>
         #include <unistd.h>
         #include <sys/stat.h>
         #define XWRITE      write
         #define XREAD       read
         #define XCLOSE      close
     #endif
 #endif
 
+/* Defaults, user may over-ride with user_settings.h or in a porting section
+ * above
+ */
+#ifndef XVFPRINTF
+    #define XVFPRINTF  vfprintf
+#endif
+#ifndef XVSNPRINTF
+    #define XVSNPRINTF vsnprintf
+#endif
+#ifndef XFPUTS
+    #define XFPUTS     fputs
+#endif
+#ifndef XSPRINTF
+    #define XSPRINTF   sprintf
+#endif
+
     #ifndef MAX_FILENAME_SZ
         #define MAX_FILENAME_SZ  256 /* max file name length */
     #endif
     #ifndef MAX_PATH
         #define MAX_PATH 256
     #endif
 
     WOLFSSL_LOCAL int wc_FileLoad(const char* fname, unsigned char** buf, 
         size_t* bufLen, void* heap);
 
 #if !defined(NO_WOLFSSL_DIR) && !defined(WOLFSSL_NUCLEUS) && \
     !defined(WOLFSSL_NUCLEUS_1_2)
     typedef struct ReadDirCtx {
     #ifdef USE_WINDOWS_API
         WIN32_FIND_DATAA FindFileData;
         HANDLE hFind;
     #elif defined(WOLFSSL_ZEPHYR)
         struct fs_dirent entry;
         struct fs_dir_t  dir;
         struct fs_dirent s;
         struct fs_dir_t* dirp;
 
     #elif defined(WOLFSSL_TELIT_M2MB)
         M2MB_DIR_T* dir;
         struct M2MB_DIRENT* entry;
         struct M2MB_STAT s;
     #else
         struct dirent* entry;
         DIR*   dir;
         struct stat s;
     #endif
         char name[MAX_FILENAME_SZ];
     } ReadDirCtx;
 
     #define WC_READDIR_NOFILE -1
 
     WOLFSSL_API int wc_ReadDirFirst(ReadDirCtx* ctx, const char* path, char** name);
     WOLFSSL_API int wc_ReadDirNext(ReadDirCtx* ctx, const char* path, char** name);
     WOLFSSL_API void wc_ReadDirClose(ReadDirCtx* ctx);
 #endif /* !NO_WOLFSSL_DIR */
 
 #endif /* !NO_FILESYSTEM */
 
 
 /* MIN/MAX MACRO SECTION */
 /* Windows API defines its own min() macro. */
 #if defined(USE_WINDOWS_API)
     #if defined(min) || defined(WOLFSSL_MYSQL_COMPATIBLE)
         #define WOLFSSL_HAVE_MIN
     #endif /* min */
     #if defined(max) || defined(WOLFSSL_MYSQL_COMPATIBLE)
         #define WOLFSSL_HAVE_MAX
     #endif /* max */
 #endif /* USE_WINDOWS_API */
 
 
 /* TIME SECTION */
 /* Time functions */
 #ifndef NO_ASN_TIME
 #if defined(USER_TIME)
     /* Use our gmtime and time_t/struct tm types.
        Only needs seconds since EPOCH using XTIME function.
        time_t XTIME(time_t * timer) {}
     */
     #define WOLFSSL_GMTIME
     #ifndef HAVE_TM_TYPE
         #define USE_WOLF_TM
     #endif
     #ifndef HAVE_TIME_T_TYPE
         #define USE_WOLF_TIME_T
     #endif
 
 #elif defined(TIME_OVERRIDES)
     /* Override XTIME() and XGMTIME() functionality.
        Requires user to provide these functions:
         time_t XTIME(time_t * timer) {}
         struct tm* XGMTIME(const time_t* timer, struct tm* tmp) {}
     */
     #ifndef HAVE_TIME_T_TYPE
         #define USE_WOLF_TIME_T
     #endif
     #ifndef HAVE_TM_TYPE
         #define USE_WOLF_TM
     #endif
     #define NEED_TMP_TIME
 
 #elif defined(WOLFSSL_XILINX)
     #ifndef XTIME
         #define XTIME(t1)       xilinx_time((t1))
     #endif
     #include <time.h>
 
 #elif defined(HAVE_RTP_SYS)
     #include "os.h"           /* dc_rtc_api needs    */
     #include "dc_rtc_api.h"   /* to get current time */
 
     /* uses parital <time.h> structures */
     #define XTIME(tl)       (0)
     #define XGMTIME(c, t)   rtpsys_gmtime((c))
 
 #elif defined(WOLFSSL_DEOS)
     #define XTIME(t1)       deos_time((t1))
     #define WOLFSSL_GMTIME
     #define USE_WOLF_TM
     #define USE_WOLF_TIME_T
 
 #elif defined(MICRIUM)
     #include <clk.h>
     #include <time.h>
     #define XTIME(t1)       micrium_time((t1))
     #define WOLFSSL_GMTIME
 
 #elif defined(MICROCHIP_TCPIP_V5) || defined(MICROCHIP_TCPIP)
     #include <time.h>
     extern time_t pic32_time(time_t* timer);
     #define XTIME(t1)       pic32_time((t1))
     #define XGMTIME(c, t)   gmtime((c))
 
 #elif defined(FREESCALE_MQX) || defined(FREESCALE_KSDK_MQX)
     #ifdef FREESCALE_MQX_4_0
         #include <time.h>
         extern time_t mqx_time(time_t* timer);
     #else
         #define HAVE_GMTIME_R
     #endif
     #define XTIME(t1)       mqx_time((t1))
 
 #elif defined(FREESCALE_KSDK_BM) || defined(FREESCALE_FREE_RTOS) || defined(FREESCALE_KSDK_FREERTOS)
     #include <time.h>
     #ifndef XTIME
         /*extern time_t ksdk_time(time_t* timer);*/
         #define XTIME(t1)   ksdk_time((t1))
     #endif
     #define XGMTIME(c, t)   gmtime((c))
 
 #elif defined(WOLFSSL_ATMEL) && defined(WOLFSSL_ATMEL_TIME)
     #define XTIME(t1)       atmel_get_curr_time_and_date((t1))
     #define WOLFSSL_GMTIME
     #define USE_WOLF_TM
     #define USE_WOLF_TIME_T
 
 #elif defined(WOLFSSL_WICED)
     #include <time.h>
     time_t wiced_pseudo_unix_epoch_time(time_t * timer);
     #define XTIME(t1)       wiced_pseudo_unix_epoch_time((t1))
     #define HAVE_GMTIME_R
 
 #elif defined(IDIRECT_DEV_TIME)
     /*Gets the timestamp from cloak software owned by VT iDirect
     in place of time() from <time.h> */
     #include <time.h>
     #define XTIME(t1)       idirect_time((t1))
     #define XGMTIME(c, t)   gmtime((c))
 
 #elif defined(_WIN32_WCE)
     #include <windows.h>
     #define XTIME(t1)       windows_time((t1))
     #define WOLFSSL_GMTIME
 
 #elif defined(WOLFSSL_APACHE_MYNEWT)
     #include "os/os_time.h"
     #define XTIME(t1)       mynewt_time((t1))
     #define WOLFSSL_GMTIME
     #define USE_WOLF_TM
     #define USE_WOLF_TIME_T
 
 #elif defined(WOLFSSL_ZEPHYR)
     #ifndef _POSIX_C_SOURCE
         #include <posix/time.h>
     #else
         #include <sys/time.h>
     #endif
 
     typedef signed int time_t;
 
     time_t z_time(time_t *timer);
 
     #define XTIME(tl)       z_time((tl))
     #define XGMTIME(c, t)   gmtime((c))
     #define WOLFSSL_GMTIME
 
     #define USE_WOLF_TM
 
 #elif defined(WOLFSSL_TELIT_M2MB)
     typedef long time_t;
     extern time_t m2mb_xtime(time_t * timer);
     #define XTIME(tl)       m2mb_xtime((tl))
     #ifdef WOLFSSL_TLS13
         extern time_t m2mb_xtime_ms(time_t * timer);
         #define XTIME_MS(tl)    m2mb_xtime_ms((tl))
     #endif
     #ifndef NO_CRYPT_BENCHMARK
         extern double m2mb_xtime_bench(int reset);
         #define WOLFSSL_CURRTIME_REMAP m2mb_xtime_bench
     #endif
     #define XGMTIME(c, t)   gmtime((c))
     #define WOLFSSL_GMTIME
     #define USE_WOLF_TM
 
 
 #elif defined(WOLFSSL_LINUXKM)
     #ifdef BUILDING_WOLFSSL
 
     /* includes are all above, with incompatible warnings masked out. */
     #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 5, 0)
     typedef __kernel_time_t time_t;
     #else
     typedef __kernel_time64_t time_t;
     #endif
     extern time_t time(time_t * timer);
     #define XTIME time
     #define WOLFSSL_GMTIME
     #define XGMTIME(c, t) gmtime(c)
     #define NO_TIMEVAL 1
 
     #endif /* BUILDING_WOLFSSL */
 
 #else
     /* default */
     /* uses complete <time.h> facility */
     #include <time.h>
     #if defined(HAVE_SYS_TIME_H)
         #include <sys/time.h>
     #endif
 
     /* PowerPC time_t is int */
     #ifdef __PPC__
         #define TIME_T_NOT_64BIT
     #endif
 #endif
 
 #ifdef SIZEOF_TIME_T
     /* check if size of time_t from autoconf is less than 8 bytes (64bits) */
     #if SIZEOF_TIME_T < 8
         #undef  TIME_T_NOT_64BIT
         #define TIME_T_NOT_64BIT
     #endif
 #endif
 #ifdef TIME_T_NOT_LONG
     /* one old reference to TIME_T_NOT_LONG in GCC-ARM example README
      * this keeps support for the old macro name */
     #undef  TIME_T_NOT_64BIT
     #define TIME_T_NOT_64BIT
 #endif
 
 /* Map default time functions */
 #if !defined(XTIME) && !defined(TIME_OVERRIDES) && !defined(USER_TIME)
     #ifdef TEST_BEFORE_DATE
     #define XTIME(tl)       (946681200UL) /* Jan 1, 2000 */
     #else
     #define XTIME(tl)       time((tl))
     #endif
 #endif
 #if !defined(XGMTIME) && !defined(TIME_OVERRIDES)
     /* Always use gmtime_r if available. */
     #if defined(HAVE_GMTIME_R)
         #define XGMTIME(c, t)   gmtime_r((c), (t))
         #define NEED_TMP_TIME
     #else
         #define XGMTIME(c, t)   gmtime((c))
     #endif
 #endif
 #if !defined(XVALIDATE_DATE) && !defined(HAVE_VALIDATE_DATE)
     #define USE_WOLF_VALIDDATE
     #define XVALIDATE_DATE(d, f, t) wc_ValidateDate((d), (f), (t))
 #endif
 
 /* wolf struct tm and time_t */
 #if defined(USE_WOLF_TM)
     struct tm {
         int  tm_sec;     /* seconds after the minute [0-60] */
         int  tm_min;     /* minutes after the hour [0-59] */
         int  tm_hour;    /* hours since midnight [0-23] */
         int  tm_mday;    /* day of the month [1-31] */
         int  tm_mon;     /* months since January [0-11] */
         int  tm_year;    /* years since 1900 */
         int  tm_wday;    /* days since Sunday [0-6] */
         int  tm_yday;    /* days since January 1 [0-365] */
         int  tm_isdst;   /* Daylight Savings Time flag */
         long tm_gmtoff;  /* offset from CUT in seconds */
         char *tm_zone;   /* timezone abbreviation */
     };
 #endif /* USE_WOLF_TM */
 #if defined(USE_WOLF_TIME_T)
     typedef long time_t;
 #endif
 #if defined(USE_WOLF_SUSECONDS_T)
     typedef long suseconds_t;
 #endif
 #if defined(USE_WOLF_TIMEVAL_T)
     struct timeval
     {
         time_t tv_sec;
         suseconds_t tv_usec;
     };
 #endif
 
     /* forward declarations */
 #if defined(USER_TIME)
     struct tm* gmtime(const time_t* timer);
     extern time_t XTIME(time_t * timer);
 
     #ifdef STACK_TRAP
         /* for stack trap tracking, don't call os gmtime on OS X/linux,
            uses a lot of stack spce */
         extern time_t time(time_t * timer);
         #define XTIME(tl)  time((tl))
     #endif /* STACK_TRAP */
 
 #elif defined(TIME_OVERRIDES)
     extern time_t XTIME(time_t * timer);
     extern struct tm* XGMTIME(const time_t* timer, struct tm* tmp);
 #elif defined(WOLFSSL_GMTIME)
     struct tm* gmtime(const time_t* timer);
 #endif
 #endif /* NO_ASN_TIME */
 
 
 #ifndef WOLFSSL_LEANPSK
     char* mystrnstr(const char* s1, const char* s2, unsigned int n);
 #endif
 
 #ifndef FILE_BUFFER_SIZE
     #define FILE_BUFFER_SIZE 1024     /* default static file buffer size for input, \
                                     will use dynamic buffer if not big enough */
 #endif
 
 #ifdef HAVE_CAVIUM_OCTEON_SYNC
     /* By default, the OCTEON's global variables are all thread local. This
      * tag allows them to be shared between threads. */
     #include "cvmx-platform.h"
     #define WOLFSSL_GLOBAL CVMX_SHARED
 #else
     #define WOLFSSL_GLOBAL
 #endif
 
 #ifdef WOLFSSL_DSP
     #include "wolfssl_dsp.h"
 
     /* callbacks for setting handle */
     typedef int (*wolfSSL_DSP_Handle_cb)(remote_handle64 *handle, int finished,
                                          void *ctx);
     WOLFSSL_API int wolfSSL_GetHandleCbSet();
     WOLFSSL_API int wolfSSL_SetHandleCb(wolfSSL_DSP_Handle_cb in);
     WOLFSSL_LOCAL int wolfSSL_InitHandle();
     WOLFSSL_LOCAL void wolfSSL_CleanupHandle();
 #endif
 
 #ifdef WOLFSSL_SCE
     #ifndef WOLFSSL_SCE_GSCE_HANDLE
         #define WOLFSSL_SCE_GSCE_HANDLE g_sce
     #endif
 #endif
 
 #ifdef __cplusplus
     }  /* extern "C" */
 #endif
 
 #endif /* WOLF_CRYPT_PORT_H */
diff --git a/wolfssl/wolfio.h b/wolfssl/wolfio.h
index bb6b6cff3..77fcf83ff 100644
--- a/wolfssl/wolfio.h
+++ b/wolfssl/wolfio.h
@@ -374,30 +374,33 @@ WOLFSSL_API  int wolfIO_Send(SOCKET_T sd, char *buf, int sz, int wrFlags);
 WOLFSSL_API  int wolfIO_Recv(SOCKET_T sd, char *buf, int sz, int rdFlags);
 
 #endif /* USE_WOLFSSL_IO || HAVE_HTTP_CLIENT */
 
 #ifndef WOLFSSL_NO_SOCK
 #ifdef USE_WINDOWS_API
     #ifndef CloseSocket
         #define CloseSocket(s) closesocket(s)
     #endif
     #define StartTCP() { WSADATA wsd; WSAStartup(0x0002, &wsd); }
 #elif defined(WOLFSSL_MDK_ARM) || defined(WOLFSSL_KEIL_TCP_NET)
     #ifndef CloseSocket
         extern int closesocket(int);
         #define CloseSocket(s) closesocket(s)
     #endif
     #define StartTCP()
 #elif defined(FUSION_RTOS)
     #ifndef CloseSocket
-        #define CloseSocket FNS_CLOSE
+        #define CloseSocket(s) do {                     \
+                                    int err;            \
+                                    FNS_CLOSE(s, &err); \
+                                } while(0)
     #endif
 #else
     #ifndef CloseSocket
         #define CloseSocket(s) close(s)
     #endif
     #define StartTCP()
     #ifdef FREERTOS_TCP_WINSIM
         extern int close(int);
     #endif
 #endif
 #endif /* WOLFSSL_NO_SOCK */
