commit 5960b92b652b51cc53852e7ba3c9b65abceb0452
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Tue Feb 13 07:21:45 2018 -0500

    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=6278

diff --git a/coders/sun.c b/coders/sun.c
index fe6277de9..f6a749f8d 100644
--- a/coders/sun.c
+++ b/coders/sun.c
@@ -157,531 +157,532 @@ static MagickBooleanType DecodeImage(const unsigned char *compressed_pixels,
   (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(compressed_pixels != (unsigned char *) NULL);
   assert(pixels != (unsigned char *) NULL);
   p=compressed_pixels;
   q=pixels;
   while (((size_t) (p-compressed_pixels) < length) &&
          ((size_t) (q-pixels) < extent))
   {
     byte=(*p++);
     if (byte != 128U)
       *q++=byte;
     else
       {
         /*
           Runlength-encoded packet: <count><byte>.
         */
         if (((size_t) (p-compressed_pixels) >= length))
           break;
         count=(*p++);
         if (count > 0)
           {
             if (((size_t) (p-compressed_pixels) >= length))
               break;
             byte=(*p++);
           }
         while ((count >= 0) && ((size_t) (q-pixels) < extent))
         {
           *q++=byte;
           count--;
         }
      }
   }
   return(((size_t) (q-pixels) == extent) ? MagickTrue : MagickFalse);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   R e a d S U N I m a g e                                                   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ReadSUNImage() reads a SUN image file and returns it.  It allocates
 %  the memory necessary for the new Image structure and returns a pointer to
 %  the new image.
 %
 %  The format of the ReadSUNImage method is:
 %
 %      Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image_info: the image info.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)
 {
 #define RMT_EQUAL_RGB  1
 #define RMT_NONE  0
 #define RMT_RAW  2
 #define RT_STANDARD  1
 #define RT_ENCODED  2
 #define RT_FORMAT_RGB  3
 
   typedef struct _SUNInfo
   {
     unsigned int
       magic,
       width,
       height,
       depth,
       length,
       type,
       maptype,
       maplength;
   } SUNInfo;
 
   Image
     *image;
 
   int
     bit;
 
   MagickBooleanType
     status;
 
   MagickSizeType
     number_pixels;
 
   register Quantum
     *q;
 
   register ssize_t
     i,
     x;
 
   register unsigned char
     *p;
 
   size_t
     bytes_per_line,
     extent,
     height,
     pixels_length,
     quantum;
 
   ssize_t
     count,
     y;
 
   SUNInfo
     sun_info;
 
   unsigned char
     *sun_data,
     *sun_pixels;
 
   /*
     Open image file.
   */
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   /*
     Read SUN raster header.
   */
   (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));
   sun_info.magic=ReadBlobMSBLong(image);
   do
   {
     /*
       Verify SUN identifier.
     */
     if (sun_info.magic != 0x59a66a95)
       ThrowReaderException(CorruptImageError,"ImproperImageHeader");
     sun_info.width=ReadBlobMSBLong(image);
     sun_info.height=ReadBlobMSBLong(image);
     sun_info.depth=ReadBlobMSBLong(image);
     sun_info.length=ReadBlobMSBLong(image);
     sun_info.type=ReadBlobMSBLong(image);
     sun_info.maptype=ReadBlobMSBLong(image);
     sun_info.maplength=ReadBlobMSBLong(image);
     if (sun_info.maplength > GetBlobSize(image))
       ThrowReaderException(CorruptImageError,"InsufficientImageDataInFile");
     extent=sun_info.height*sun_info.width;
     if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))
       ThrowReaderException(CorruptImageError,"ImproperImageHeader");
     if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&
         (sun_info.type != RT_FORMAT_RGB))
       ThrowReaderException(CorruptImageError,"ImproperImageHeader");
     if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))
       ThrowReaderException(CorruptImageError,"ImproperImageHeader");
     if ((sun_info.depth != 1) && (sun_info.depth != 8) &&
         (sun_info.depth != 24) && (sun_info.depth != 32))
       ThrowReaderException(CorruptImageError,"ImproperImageHeader");
     if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&
         (sun_info.maptype != RMT_RAW))
       ThrowReaderException(CoderError,"ColormapTypeNotSupported");
     image->columns=sun_info.width;
     image->rows=sun_info.height;
     image->depth=sun_info.depth <= 8 ? sun_info.depth :
       MAGICKCORE_QUANTUM_DEPTH;
     if (sun_info.depth < 24)
       {
         size_t
           one;
 
         image->colors=sun_info.maplength;
         one=1;
         if (sun_info.maptype == RMT_NONE)
           image->colors=one << sun_info.depth;
         if (sun_info.maptype == RMT_EQUAL_RGB)
           image->colors=sun_info.maplength/3;
         if (image->colors == 0)
           ThrowReaderException(CorruptImageError,"ImproperImageHeader");
         if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
           ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
       }
     switch (sun_info.maptype)
     {
       case RMT_NONE:
         break;
       case RMT_EQUAL_RGB:
       {
         unsigned char
           *sun_colormap;
 
         /*
           Read SUN raster colormap.
         */
         sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
           sizeof(*sun_colormap));
         if (sun_colormap == (unsigned char *) NULL)
           ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
         count=ReadBlob(image,image->colors,sun_colormap);
         if (count != (ssize_t) image->colors)
           {
             sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
             ThrowReaderException(CorruptImageError,"UnexpectedEndOfFile");
           }
         for (i=0; i < (ssize_t) image->colors; i++)
           image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(
             sun_colormap[i]);
         count=ReadBlob(image,image->colors,sun_colormap);
         if (count != (ssize_t) image->colors)
           {
             sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
             ThrowReaderException(CorruptImageError,"UnexpectedEndOfFile");
           }
         for (i=0; i < (ssize_t) image->colors; i++)
           image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(
             sun_colormap[i]);
         count=ReadBlob(image,image->colors,sun_colormap);
         if (count != (ssize_t) image->colors)
           {
             sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
             ThrowReaderException(CorruptImageError,"UnexpectedEndOfFile");
           }
         for (i=0; i < (ssize_t) image->colors; i++)
           image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(
             sun_colormap[i]);
         sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
         break;
       }
       case RMT_RAW:
       {
         unsigned char
           *sun_colormap;
 
         /*
           Read SUN raster colormap.
         */
         sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,
           sizeof(*sun_colormap));
         if (sun_colormap == (unsigned char *) NULL)
           ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
         count=ReadBlob(image,sun_info.maplength,sun_colormap);
         sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);
         if (count != (ssize_t) sun_info.maplength)
           ThrowReaderException(CorruptImageError,"UnexpectedEndOfFile");
         break;
       }
       default:
         ThrowReaderException(CoderError,"ColormapTypeNotSupported");
     }
     image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :
       UndefinedPixelTrait;
     image->columns=sun_info.width;
     image->rows=sun_info.height;
     if (image_info->ping != MagickFalse)
       {
         (void) CloseBlob(image);
         return(GetFirstImageInList(image));
       }
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
     if (sun_info.length == 0)
       ThrowReaderException(ResourceLimitError,"ImproperImageHeader");
     number_pixels=(MagickSizeType) (image->columns*image->rows);
     if ((sun_info.type != RT_ENCODED) &&
         ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))
       ThrowReaderException(CorruptImageError,"ImproperImageHeader");
     if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)
       ThrowReaderException(CorruptImageError,"ImproperImageHeader");
     bytes_per_line=sun_info.width*sun_info.depth;
     if (sun_info.length > GetBlobSize(image))
       ThrowReaderException(CorruptImageError,"InsufficientImageDataInFile");
     sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,
       sizeof(*sun_data));
     if (sun_data == (unsigned char *) NULL)
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
     count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);
     if (count != (ssize_t) sun_info.length)
       {
         sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
         ThrowReaderException(CorruptImageError,"UnableToReadImageData");
       }
     height=sun_info.height;
     if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||
         ((bytes_per_line/sun_info.depth) != sun_info.width))
       {
         sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
         ThrowReaderException(ResourceLimitError,"ImproperImageHeader");
       }
     quantum=sun_info.depth == 1 ? 15 : 7;
     bytes_per_line+=quantum;
     bytes_per_line<<=1;
     if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))
       {
         sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
         ThrowReaderException(ResourceLimitError,"ImproperImageHeader");
       }
     bytes_per_line>>=4;
     if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)
       {
         sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
         ThrowReaderException(ResourceLimitError,"ImproperImageHeader");
       }
     pixels_length=height*bytes_per_line;
     sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,
       sizeof(*sun_pixels));
     if (sun_pixels == (unsigned char *) NULL)
       {
         sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
         ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
       }
-    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));
+    (void) ResetMagickMemory(sun_pixels,0,(pixels_length+image->rows)*
+      sizeof(*sun_pixels));
     if (sun_info.type == RT_ENCODED)
       {
         status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);
         if (status == MagickFalse)
           {
             sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
             sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
             ThrowReaderException(CorruptImageError,"UnableToReadImageData");
           }
       }
     else
       {
         if (sun_info.length > pixels_length)
           {
             sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
             sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
             ThrowReaderException(ResourceLimitError,"ImproperImageHeader");
           }
         (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);
       }
     sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);
     /*
       Convert SUN raster image to pixel packets.
     */
     p=sun_pixels;
     if (sun_info.depth == 1)
       for (y=0; y < (ssize_t) image->rows; y++)
       {
         q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
         if (q == (Quantum *) NULL)
           break;
         for (x=0; x < ((ssize_t) image->columns-7); x+=8)
         {
           for (bit=7; bit >= 0; bit--)
           {
             SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),
               q);
             q+=GetPixelChannels(image);
           }
           p++;
         }
         if ((image->columns % 8) != 0)
           {
             for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)
             {
               SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :
                 0x01),q);
               q+=GetPixelChannels(image);
             }
             p++;
           }
         if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
           p++;
         if (SyncAuthenticPixels(image,exception) == MagickFalse)
           break;
         if (image->previous == (Image *) NULL)
           {
             status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
               image->rows);
             if (status == MagickFalse)
               break;
           }
       }
     else
       if (image->storage_class == PseudoClass)
         {
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               SetPixelIndex(image,ConstrainColormapIndex(image,*p,exception),q);
               p++;
               q+=GetPixelChannels(image);
             }
             if ((image->columns % 2) != 0)
               p++;
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
         }
       else
         {
           size_t
             bytes_per_pixel;
 
           bytes_per_pixel=3;
           if (image->alpha_trait != UndefinedPixelTrait)
             bytes_per_pixel++;
           if (bytes_per_line == 0)
             bytes_per_line=bytes_per_pixel*image->columns;
           for (y=0; y < (ssize_t) image->rows; y++)
           {
             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
             if (q == (Quantum *) NULL)
               break;
             for (x=0; x < (ssize_t) image->columns; x++)
             {
               if (image->alpha_trait != UndefinedPixelTrait)
                 SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);
               if (sun_info.type == RT_STANDARD)
                 {
                   SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                   SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                   SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                 }
               else
                 {
                   SetPixelRed(image,ScaleCharToQuantum(*p++),q);
                   SetPixelGreen(image,ScaleCharToQuantum(*p++),q);
                   SetPixelBlue(image,ScaleCharToQuantum(*p++),q);
                 }
               if (image->colors != 0)
                 {
                   SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)
                     GetPixelRed(image,q)].red),q);
                   SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)
                     GetPixelGreen(image,q)].green),q);
                   SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)
                     GetPixelBlue(image,q)].blue),q);
                 }
               q+=GetPixelChannels(image);
             }
             if (((bytes_per_pixel*image->columns) % 2) != 0)
               p++;
             if (SyncAuthenticPixels(image,exception) == MagickFalse)
               break;
             if (image->previous == (Image *) NULL)
               {
                 status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                 image->rows);
                 if (status == MagickFalse)
                   break;
               }
           }
         }
     if (image->storage_class == PseudoClass)
       (void) SyncImage(image,exception);
     sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",
           image->filename);
         break;
       }
     /*
       Proceed to next image.
     */
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     sun_info.magic=ReadBlobMSBLong(image);
     if (sun_info.magic == 0x59a66a95)
       {
         /*
           Allocate next image structure.
         */
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   } while (sun_info.magic == 0x59a66a95);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   R e g i s t e r S U N I m a g e                                           %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  RegisterSUNImage() adds attributes for the SUN image format to
 %  the list of supported formats.  The attributes include the image format
 %  tag, a method to read and/or write the format, whether the format
 %  supports the saving of more than one frame to the same file or blob,
 %  whether the format supports native in-memory I/O, and a brief
 %  description of the format.
 %
 %  The format of the RegisterSUNImage method is:
 %
 %      size_t RegisterSUNImage(void)
 %
 */
