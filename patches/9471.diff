commit 71d9816081d9e0a0e5dc490ecf9be0fd06ce160c
Author: drons <drons@list.ru>
Date:   Wed Jul 18 00:40:23 2018 +0300

    RMF: Rework read pipeline. Remove RasterIO(GF_Read...) call from IWriteBlock.

diff --git a/gdal/frmts/rmf/rmfdataset.cpp b/gdal/frmts/rmf/rmfdataset.cpp
index 5a4502923e..20143507ca 100644
--- a/gdal/frmts/rmf/rmfdataset.cpp
+++ b/gdal/frmts/rmf/rmfdataset.cpp
@@ -149,63 +149,6 @@ RMFRasterBand::RMFRasterBand( RMFDataset *poDSIn, int nBandIn,
 
 RMFRasterBand::~RMFRasterBand() {}
 
-/************************************************************************/
-/*                              ReadBuffer()                            */
-/*                                                                      */
-/* Helper function to read specified amount of bytes from the input     */
-/* file stream.                                                         */
-/************************************************************************/
-
-CPLErr RMFRasterBand::ReadBuffer( GByte *pabyBuf, GUInt32 nBytes ) const
-{
-    RMFDataset  *poGDS = reinterpret_cast<RMFDataset *>( poDS );
-
-    CPLAssert( pabyBuf != nullptr && poGDS->fp != nullptr );
-
-    const vsi_l_offset nOffset = VSIFTellL( poGDS->fp );
-
-    if( VSIFReadL( pabyBuf, 1, nBytes, poGDS->fp ) < nBytes )
-    {
-        // XXX
-        if( poGDS->eAccess == GA_Update )
-        {
-            return CE_Failure;
-        }
-        else
-        {
-            CPLError( CE_Failure, CPLE_FileIO,
-                      "Can't read at offset %ld from input file.\n%s",
-                      static_cast<long>( nOffset ), VSIStrerror( errno ) );
-            return CE_Failure;
-        }
-    }
-
-#ifdef CPL_MSB
-    if( poGDS->eRMFType == RMFT_MTW )
-    {
-        if( poGDS->sHeader.nBitDepth == 16 )
-        {
-            for( GUInt32 i = 0; i < nBytes; i += 2 )
-                CPL_SWAP16PTR( pabyBuf + i );
-        }
-
-        else if( poGDS->sHeader.nBitDepth == 32 )
-        {
-            for( GUInt32 i = 0; i < nBytes; i += 4 )
-                CPL_SWAP32PTR( pabyBuf + i );
-        }
-
-        else if( poGDS->sHeader.nBitDepth == 64 )
-        {
-            for( GUInt32 i = 0; i < nBytes; i += 8 )
-                CPL_SWAPDOUBLE( pabyBuf + i );
-        }
-    }
-#endif
-
-    return CE_None;
-}
-
 /************************************************************************/
 /*                             IReadBlock()                             */
 /************************************************************************/
@@ -213,388 +156,256 @@ CPLErr RMFRasterBand::ReadBuffer( GByte *pabyBuf, GUInt32 nBytes ) const
 CPLErr RMFRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,
                                   void * pImage )
 {
     RMFDataset  *poGDS = reinterpret_cast<RMFDataset *>( poDS );
 
     CPLAssert( poGDS != nullptr
                && nBlockXOff >= 0
                && nBlockYOff >= 0
                && pImage != nullptr );
 
-    memset( pImage, 0, nBlockBytes );
-
-    const GUInt32 nTile = nBlockYOff * poGDS->nXTiles + nBlockXOff;
-    if( 2 * nTile + 1 >= poGDS->sHeader.nTileTblSize / sizeof(GUInt32) )
-    {
-        return CE_Failure;
-    }
-
-    GUInt32 nTileBytes = poGDS->paiTiles[2 * nTile + 1];
-    const GUInt32 nCurBlockYSize =
-        (nLastTileHeight
-         && static_cast<GUInt32>( nBlockYOff ) == poGDS->nYTiles - 1 )
-        ? nLastTileHeight
-        : nBlockYSize;
-
-    vsi_l_offset nTileOffset =
-        poGDS->GetFileOffset( poGDS->paiTiles[2 * nTile] );
-
-    if( nTileOffset == 0 )
-    {
-        return CE_None;
-    }
-
-    if( VSIFSeekL( poGDS->fp, nTileOffset, SEEK_SET ) < 0 )
-    {
-        // XXX: We will not report error here, because file just may be
-        // in update state and data for this block will be available later
-        if( poGDS->eAccess == GA_Update )
-            return CE_None;
-
-        CPLError( CE_Failure, CPLE_FileIO,
-                  "Can't seek to offset %ld in input file to read data.\n%s",
-                  static_cast<long>( nTileOffset ),
-                  VSIStrerror( errno ) );
-        return CE_Failure;
-    }
+    memset(pImage, 0, nBlockBytes);
 
     GUInt32 nRawXSize = nBlockXSize;
     GUInt32 nRawYSize = nBlockYSize;
 
     if( nLastTileWidth && (GUInt32)nBlockXOff == poGDS->nXTiles - 1 )
         nRawXSize = nLastTileWidth;
 
     if( nLastTileHeight && (GUInt32)nBlockYOff == poGDS->nYTiles - 1 )
         nRawYSize = nLastTileHeight;
 
-    if( poGDS->nBands == 1 &&
-        ( poGDS->sHeader.nBitDepth == 8
-          || poGDS->sHeader.nBitDepth == 16
-          || poGDS->sHeader.nBitDepth == 32
-          || poGDS->sHeader.nBitDepth == 64 ) )
-    {
-        if( nTileBytes > nBlockBytes )
-            nTileBytes = nBlockBytes;
+    GUInt32 nRawBytes = nRawXSize * nRawYSize * poGDS->sHeader.nBitDepth / 8;
 
-/* -------------------------------------------------------------------- */
-/*  Decompress buffer, if needed.                                       */
-/* -------------------------------------------------------------------- */
-        if( poGDS->Decompress )
-        {
-            GUInt32 nRawBytes;
-
-            nRawBytes = poGDS->nBands * nRawXSize * nRawYSize * nDataSize;
-
-            if( nRawBytes > nTileBytes )
-            {
-                GByte *pabyTile = reinterpret_cast<GByte *>(
-                    VSIMalloc( nTileBytes ) );
-
-                if( !pabyTile )
-                {
-                    CPLError( CE_Failure, CPLE_FileIO,
-                            "Can't allocate tile block of size %lu.\n%s",
-                            (unsigned long) nTileBytes, VSIStrerror( errno ) );
-                    return CE_Failure;
-                }
-
-                if( ReadBuffer( pabyTile, nTileBytes ) == CE_Failure )
-                {
-                    // XXX: Do not fail here, just return empty block
-                    // and continue reading.
-                    CPLFree( pabyTile );
-                    return CE_None;
-                }
-
-                size_t nDecompressedSize =
-                    (*poGDS->Decompress)( pabyTile, nTileBytes,
-                                          reinterpret_cast<GByte*>( pImage ),
-                                          nRawBytes, nRawXSize, nRawYSize );
-                CPLFree( pabyTile );
-                if(nDecompressedSize != (size_t)nRawBytes)
-                {
-                    CPLError( CE_Failure, CPLE_FileIO,
-                              "Can't decompress tile xOff %d yOff %d. "
-                              "Raw tile size is %lu but decompressed is %lu. "
-                              "Compressed tile size is %lu",
-                              nBlockXOff, nBlockYOff,
-                              static_cast<unsigned long>(nRawBytes),
-                              static_cast<unsigned long>(nDecompressedSize),
-                              static_cast<unsigned long>(nTileBytes));
-                    return CE_Failure;
-                }
-                // nTileBytes = nRawBytes;
-            }
-            else
-            {
-                if( ReadBuffer( reinterpret_cast<GByte *>( pImage ),
-                                nTileBytes ) == CE_Failure )
-                {
-                    // XXX: Do not fail here, just return empty block
-                    // and continue reading.
-                    return CE_None;
-                }
-            }
-        }
-        else
+    //Direct read optimization
+    if(poGDS->nBands == 1 && poGDS->sHeader.nBitDepth >= 8 &&
+       nRawXSize == static_cast<GUInt32>(nBlockXSize) &&
+       nRawYSize == static_cast<GUInt32>(nBlockYSize))
+    {
+        if(CE_None != poGDS->ReadTile(nBlockXOff, nBlockYOff,
+                                      reinterpret_cast<GByte*>(pImage),
+                                      nRawBytes, nRawXSize, nRawYSize))
         {
-            if( ReadBuffer( reinterpret_cast<GByte *>( pImage ),
-                            nTileBytes ) == CE_Failure )
-            {
-                // XXX: Do not fail here, just return empty block
-                // and continue reading.
-                return CE_None;
-            }
+            CPLError(CE_Failure, CPLE_FileIO,
+                     "Failed to read tile xOff %d yOff %d",
+                     nBlockXOff, nBlockYOff);
+            return CE_Failure;
         }
+        return CE_None;
     }
-    else if( poGDS->eRMFType == RMFT_RSW )
-    {
-        if(poGDS->pabyCurrentTile == nullptr ||
-           poGDS->nCurrentTileXOff != nBlockXOff ||
-           poGDS->nCurrentTileYOff != nBlockYOff ||
-           poGDS->nCurrentTileBytes == 0)
-        {
-            const GUInt32 nMaxBlockBytes = nBlockBytes * 4; // 4 bands
-            if( nTileBytes > nMaxBlockBytes )
-            {
-                CPLDebug("RMF",
-                         "Only reading %u bytes instead of the %u declared "
-                         "in the tile array",
-                         nMaxBlockBytes, nTileBytes);
-                nTileBytes = nMaxBlockBytes;
-            }
-
-            GByte *pabyNewTile = reinterpret_cast<GByte *>(
-                    VSIRealloc(poGDS->pabyCurrentTile, std::max(1U, nTileBytes)));
-            if( !pabyNewTile )
+#ifdef DEBUG
+    CPLDebug("RMF", "IReadBlock nBand %d, RawSize [%d, %d], Bits %d",
+             nBand, nRawXSize, nRawYSize, (int)poGDS->sHeader.nBitDepth);
+#endif //DEBUG
+    if(poGDS->pabyCurrentTile == nullptr ||
+       poGDS->nCurrentTileXOff != nBlockXOff ||
+       poGDS->nCurrentTileYOff != nBlockYOff ||
+       poGDS->nCurrentTileBytes != nRawBytes)
+    {
+        if(poGDS->pabyCurrentTile == nullptr)
+        {
+            GUInt32 nMaxTileBytes = poGDS->sHeader.nTileWidth *
+                                    poGDS->sHeader.nTileHeight *
+                                    poGDS->sHeader.nBitDepth / 8;
+            poGDS->pabyCurrentTile =
+               reinterpret_cast<GByte*>(VSIMalloc(std::max(1U, nMaxTileBytes)));
+            if(!poGDS->pabyCurrentTile)
             {
-                CPLError( CE_Failure, CPLE_FileIO,
-                          "Can't allocate tile block of size %lu.\n%s",
-                          (unsigned long)nTileBytes, VSIStrerror( errno ) );
+                CPLError(CE_Failure, CPLE_OutOfMemory,
+                         "Can't allocate tile block of size %lu.\n%s",
+                         static_cast<unsigned long>(nMaxTileBytes),
+                         VSIStrerror(errno));
                 poGDS->nCurrentTileBytes = 0;
                 return CE_Failure;
             }
-            poGDS->pabyCurrentTile = pabyNewTile;
-
-            poGDS->nCurrentTileXOff = nBlockXOff;
-            poGDS->nCurrentTileYOff = nBlockYOff;
-            poGDS->nCurrentTileBytes = nTileBytes;
-
-            if(CE_Failure == ReadBuffer(poGDS->pabyCurrentTile,
-                                        poGDS->nCurrentTileBytes))
-            {
-                // XXX: Do not fail here, just return empty block
-                // and continue reading.
-                poGDS->nCurrentTileBytes = 0;
-                return CE_None;
-            }
-
-/* -------------------------------------------------------------------- */
-/*  If buffer was compressed, decompress it first.                      */
-/* -------------------------------------------------------------------- */
-            if( poGDS->Decompress )
-            {
-                GUInt32 nRawBytes;
-
-                nRawBytes = nRawXSize * nRawYSize *
-                            poGDS->sHeader.nBitDepth / 8;
-                if( nRawBytes > poGDS->nCurrentTileBytes )
-                {
-                    GByte *pabyRawBuf = reinterpret_cast<GByte *>(
-                        VSIMalloc( nRawBytes ) );
-                    if( pabyRawBuf == nullptr )
-                    {
-                        CPLError( CE_Failure, CPLE_FileIO,
-                                  "Can't allocate a buffer for raw data of "
-                                  "size %lu.\n%s",
-                                  static_cast<unsigned long>( nRawBytes ),
-                                  VSIStrerror( errno ) );
-                        poGDS->nCurrentTileBytes = 0;
-                        return CE_Failure;
-                    }
-
-                    size_t  nDecompressedSize =
-                        (*poGDS->Decompress)( poGDS->pabyCurrentTile,
-                                              poGDS->nCurrentTileBytes,
-                                              pabyRawBuf, nRawBytes,
-                                              nRawXSize, nRawYSize );
+        }
 
-                    if(nDecompressedSize != (size_t)nRawBytes)
-                    {
-                        CPLError( CE_Failure, CPLE_FileIO,
-                                  "Can't decompress tile xOff %d yOff %d. "
-                                  "Raw tile size is %lu but decompressed is %lu. "
-                                  "Compressed tile size is %lu",
-                                  nBlockXOff, nBlockYOff,
-                                  static_cast<unsigned long>(nRawBytes),
-                                  static_cast<unsigned long>(nDecompressedSize),
-                                  static_cast<unsigned long>(poGDS->nCurrentTileBytes));
-                        poGDS->nCurrentTileBytes = 0;
-                        CPLFree(pabyRawBuf);
-                        return CE_Failure;
-                    }
+        poGDS->nCurrentTileXOff = nBlockXOff;
+        poGDS->nCurrentTileYOff = nBlockYOff;
+        poGDS->nCurrentTileBytes = nRawBytes;
 
-                    CPLFree( poGDS->pabyCurrentTile );
-                    poGDS->pabyCurrentTile = pabyRawBuf;
-                    poGDS->nCurrentTileBytes = nRawBytes;
-                }
-            }
+        if(CE_None != poGDS->ReadTile(nBlockXOff, nBlockYOff,
+                                      poGDS->pabyCurrentTile, nRawBytes,
+                                      nRawXSize, nRawYSize))
+        {
+            CPLError(CE_Failure, CPLE_FileIO,
+                     "Failed to read tile xOff %d yOff %d",
+                     nBlockXOff, nBlockYOff);
+            poGDS->nCurrentTileBytes = 0;
+            return CE_Failure;
         }
+    }
+
 /* -------------------------------------------------------------------- */
 /*  Deinterleave pixels from input buffer.                              */
 /* -------------------------------------------------------------------- */
-        if( poGDS->sHeader.nBitDepth == 24 || poGDS->sHeader.nBitDepth == 32 )
-        {
-            GUInt32 nTileSize = poGDS->nCurrentTileBytes / nBytesPerPixel;
 
-            if( nTileSize > nBlockSize )
-                nTileSize = nBlockSize;
-
-            if(poGDS->bReverseBandLayout && poGDS->nCurrentTileBytes > nTileBytes)
-            {
-                for( GUInt32 i = 0; i < nTileSize; i++ )
-                {
-                    reinterpret_cast<GByte *>( pImage )[i] =
-                        poGDS->pabyCurrentTile[i * nBytesPerPixel + nBand - 1];
-                }
-            }
-            else
-            {
-                for( GUInt32 i = 0; i < nTileSize; i++ )
-                {
-                    // Colour triplets in RMF file organized in reverse order:
-                    // blue, green, red. When we have 32-bit RMF the forth byte
-                    // in quadruplet should be discarded as it has no meaning.
-                    // That is why we always use 3 byte count in the following
-                    // pabyTemp index.
-                    reinterpret_cast<GByte *>( pImage )[i] =
-                        poGDS->pabyCurrentTile[i * nBytesPerPixel + 3 - nBand];
-                }
-            }
+    if((poGDS->eRMFType == RMFT_RSW &&
+        (poGDS->sHeader.nBitDepth == 8 ||
+         poGDS->sHeader.nBitDepth == 24 ||
+         poGDS->sHeader.nBitDepth == 32)) ||
+       (poGDS->eRMFType == RMFT_MTW))
+    {
+        size_t  nTilePixelSize = poGDS->sHeader.nBitDepth / 8;
+        size_t  nTileLineSize = nTilePixelSize * nRawXSize;
+        size_t  nBlockLineSize = nDataSize * nBlockXSize;
+        int     iDstBand = (poGDS->nBands - nBand);
+        for(GUInt32 iLine = 0; iLine != nRawYSize; ++iLine)
+        {
+            GByte* pabySrc;
+            GByte* pabyDst;
+            pabySrc = poGDS->pabyCurrentTile +
+                      iLine * nTileLineSize +
+                      iDstBand * nDataSize;
+            pabyDst = reinterpret_cast<GByte*>(pImage) +
+                      iLine * nBlockLineSize;
+            GDALCopyWords(pabySrc, eDataType, static_cast<int>(nTilePixelSize),
+                          pabyDst, eDataType, static_cast<int>(nDataSize),
+                          nRawXSize);
         }
+        return CE_None;
+    }
+    else if(poGDS->eRMFType == RMFT_RSW &&
+            poGDS->sHeader.nBitDepth == 16 &&
+            poGDS->nBands == 3)
+    {
+        size_t  nTilePixelBits = poGDS->sHeader.nBitDepth;
+        size_t  nTileLineSize = nTilePixelBits * nRawXSize / 8;
+        size_t  nBlockLineSize = nDataSize * nBlockXSize;
 
-        else if( poGDS->sHeader.nBitDepth == 16 )
+        for(GUInt32 iLine = 0; iLine != nRawYSize; ++iLine)
         {
-            GUInt32 nTileSize = poGDS->nCurrentTileBytes / nBytesPerPixel;
-
-            if( nTileSize > nBlockSize )
-                nTileSize = nBlockSize;
+            GUInt16* pabySrc;
+            GByte* pabyDst;
+            pabySrc = reinterpret_cast<GUInt16*>(poGDS->pabyCurrentTile +
+                                                 iLine * nTileLineSize);
+            pabyDst = reinterpret_cast<GByte*>(pImage) +
+                      iLine * nBlockLineSize;
 
-            for( GUInt32 i = 0; i < nTileSize; i++ )
+            for( GUInt32 i = 0; i < nRawXSize; i++ )
             {
                 switch( nBand )
                 {
                     case 1:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            static_cast<GByte>((reinterpret_cast<GUInt16 *>(
-                                poGDS->pabyCurrentTile )[i] & 0x7c00) >> 7);
+                        pabyDst[i] =
+                            static_cast<GByte>((pabySrc[i] & 0x7c00) >> 7);
                         break;
                     case 2:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            static_cast<GByte>((reinterpret_cast<GUInt16 *>(
-                                poGDS->pabyCurrentTile )[i] & 0x03e0) >> 2);
+                        pabyDst[i] =
+                            static_cast<GByte>((pabySrc[i] & 0x03e0) >> 2);
                         break;
                     case 3:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            static_cast<GByte>((reinterpret_cast<GUInt16 *>(
-                                poGDS->pabyCurrentTile)[i] & 0x1F) << 3);
+                        pabyDst[i] =
+                            static_cast<GByte>((pabySrc[i] & 0x1F) << 3);
                         break;
                     default:
                         break;
                 }
             }
         }
-        else if( poGDS->sHeader.nBitDepth == 4 )
+        return CE_None;
+    }
+    else if(poGDS->eRMFType == RMFT_RSW &&
+            poGDS->nBands == 1 &&
+            poGDS->sHeader.nBitDepth == 4)
+    {
+        if( poGDS->nCurrentTileBytes != (nBlockSize+1) / 2 )
         {
-            GByte *pabyTemp = poGDS->pabyCurrentTile;
+            CPLError(CE_Failure, CPLE_AppDefined,
+                     "Tile has %d bytes, %d were expected",
+                     poGDS->nCurrentTileBytes, (nBlockSize+1) / 2 );
+            return CE_Failure;
+        }
 
-            if( poGDS->nCurrentTileBytes != (nBlockSize+1) / 2 )
-            {
-                CPLError(CE_Failure, CPLE_AppDefined,
-                         "Tile has %d bytes, %d were expected",
-                         poGDS->nCurrentTileBytes, (nBlockSize+1) / 2 );
-                return CE_Failure;
-            }
+        size_t  nTilePixelBits = poGDS->sHeader.nBitDepth;
+        size_t  nTileLineSize = nTilePixelBits * nRawXSize / 8;
+        size_t  nBlockLineSize = nDataSize * nBlockXSize;
 
-            for( GUInt32 i = 0; i < nBlockSize; i++ )
+        for(GUInt32 iLine = 0; iLine != nRawYSize; ++iLine)
+        {
+            GByte* pabySrc;
+            GByte* pabyDst;
+            pabySrc = poGDS->pabyCurrentTile +
+                      iLine * nTileLineSize;
+            pabyDst = reinterpret_cast<GByte*>(pImage) +
+                      iLine * nBlockLineSize;
+            for( GUInt32 i = 0; i < nRawXSize; ++i )
             {
                 if( i & 0x01 )
-                    reinterpret_cast<GByte *>( pImage )[i]
-                        = (*pabyTemp++ & 0xF0) >> 4;
+                    pabyDst[i] = (*pabySrc++ & 0xF0) >> 4;
                 else
-                    reinterpret_cast<GByte *>( pImage )[i] = *pabyTemp & 0x0F;
+                    pabyDst[i] = *pabySrc & 0x0F;
             }
         }
-        else if( poGDS->sHeader.nBitDepth == 1 )
+        return CE_None;
+    }
+    else if(poGDS->eRMFType == RMFT_RSW &&
+            poGDS->nBands == 1 &&
+            poGDS->sHeader.nBitDepth == 1)
+    {
+        if( poGDS->nCurrentTileBytes != (nBlockSize+7) / 8 )
         {
-            GByte *pabyTemp = poGDS->pabyCurrentTile;
-
-            if( poGDS->nCurrentTileBytes != (nBlockSize+7) / 8 )
-            {
-                CPLError(CE_Failure, CPLE_AppDefined,
-                         "Tile has %d bytes, %d were expected",
-                         poGDS->nCurrentTileBytes, (nBlockSize+7) / 8 );
+            CPLError(CE_Failure, CPLE_AppDefined,
+                     "Tile has %d bytes, %d were expected",
+                     poGDS->nCurrentTileBytes, (nBlockSize+7) / 8 );
                 return CE_Failure;
-            }
+        }
+
+        size_t  nTilePixelBits = poGDS->sHeader.nBitDepth;
+        size_t  nTileLineSize = nTilePixelBits * nRawXSize / 8;
+        size_t  nBlockLineSize = nDataSize * nBlockXSize;
+
+        for(GUInt32 iLine = 0; iLine != nRawYSize; ++iLine)
+        {
+            GByte* pabySrc;
+            GByte* pabyDst;
+            pabySrc = poGDS->pabyCurrentTile +
+                      iLine * nTileLineSize;
+            pabyDst = reinterpret_cast<GByte*>(pImage) +
+                      iLine * nBlockLineSize;
 
-            for( GUInt32 i = 0; i < nBlockSize; i++ )
+            for(GUInt32 i = 0; i < nRawXSize; ++i)
             {
-                switch( i & 0x7 )
+                switch(i & 0x7)
                 {
                     case 0:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            (*pabyTemp & 0x80) >> 7;
+                        pabyDst[i] = (*pabySrc & 0x80) >> 7;
                         break;
                     case 1:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            (*pabyTemp & 0x40) >> 6;
+                        pabyDst[i] = (*pabySrc & 0x40) >> 6;
                         break;
                     case 2:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            (*pabyTemp & 0x20) >> 5;
+                        pabyDst[i] = (*pabySrc & 0x20) >> 5;
                         break;
                     case 3:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            (*pabyTemp & 0x10) >> 4;
+                        pabyDst[i] = (*pabySrc & 0x10) >> 4;
                         break;
                     case 4:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            (*pabyTemp & 0x08) >> 3;
+                        pabyDst[i] = (*pabySrc & 0x08) >> 3;
                         break;
                     case 5:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            (*pabyTemp & 0x04) >> 2;
+                        pabyDst[i] = (*pabySrc & 0x04) >> 2;
                         break;
                     case 6:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            (*pabyTemp & 0x02) >> 1;
+                        pabyDst[i] = (*pabySrc & 0x02) >> 1;
                         break;
                     case 7:
-                        reinterpret_cast<GByte *>( pImage )[i] =
-                            *pabyTemp++ & 0x01;
+                        pabyDst[i] = *pabySrc++ & 0x01;
                         break;
                     default:
                         break;
                 }
             }
         }
+        return CE_None;
     }
 
-    if( nLastTileWidth
-        && static_cast<GUInt32>( nBlockXOff ) == poGDS->nXTiles - 1 )
-    {
-        for( GUInt32 iRow = nCurBlockYSize - 1; iRow > 0; iRow-- )
-        {
-            memmove( reinterpret_cast<GByte *>( pImage )
-                     + nBlockXSize * iRow * nDataSize,
-                     reinterpret_cast<GByte *>( pImage ) +
-                     iRow * nLastTileWidth * nDataSize,
-                     nLastTileWidth * nDataSize );
-        }
-    }
+    CPLError(CE_Failure, CPLE_AppDefined,
+             "Invalid block data type. BitDepth %d, nBands %d",
+             static_cast<int>(poGDS->sHeader.nBitDepth), poGDS->nBands);
 
-    return CE_None;
+    return CE_Failure;
 }
 
 /************************************************************************/
 /*                            IWriteBlock()                             */
 /************************************************************************/
@@ -602,114 +413,109 @@ CPLErr RMFRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,
 CPLErr RMFRasterBand::IWriteBlock( int nBlockXOff, int nBlockYOff,
                                    void * pImage )
 {
     CPLAssert(poDS != nullptr
               && nBlockXOff >= 0
               && nBlockYOff >= 0
               && pImage != nullptr);
 
     RMFDataset *poGDS = reinterpret_cast<RMFDataset *>(poDS);
 
+    //First drop current tile read by IReadBlock
+    poGDS->nCurrentTileBytes = 0;
+
     GUInt32 nRawXSize = nBlockXSize;
     GUInt32 nRawYSize = nBlockYSize;
 
     if(nLastTileWidth && static_cast<GUInt32>(nBlockXOff) == poGDS->nXTiles - 1)
        nRawXSize = nLastTileWidth;
 
     if(nLastTileHeight && static_cast<GUInt32>(nBlockYOff) == poGDS->nYTiles - 1)
        nRawYSize = nLastTileHeight;
 
     size_t  nTilePixelSize = nDataSize * poGDS->nBands;
     size_t  nTileLineSize = nTilePixelSize * nRawXSize;
     size_t  nTileSize = nTileLineSize * nRawYSize;
     size_t  nBlockLineSize = nDataSize * nBlockXSize;
 
 #ifdef DEBUG
-    CPLDebug("RMF", "BlockSize [%d, %d], RawSize [%d, %d], size %d, nBand %d",
+    CPLDebug("RMF", "IWriteBlock BlockSize [%d, %d], RawSize [%d, %d], size %d, nBand %d",
              nBlockXSize, nBlockYSize, nRawXSize, nRawYSize,
              static_cast<int>(nTileSize), nBand);
 #endif // DEBUG
 
     if(poGDS->nBands == 1 &&
        nRawXSize == static_cast<GUInt32>(nBlockXSize) &&
        nRawYSize == static_cast<GUInt32>(nBlockYSize))
     {//Immediate write
         return poGDS->WriteTile(nBlockXOff, nBlockYOff,
                                 reinterpret_cast<GByte*>(pImage),
                                 nRawXSize * nRawYSize * nDataSize,
                                 nRawXSize, nRawYSize);
     }
     else
     {//Try to construct full tile in memory and write later
         const GUInt32 nTile = nBlockYOff * poGDS->nXTiles + nBlockXOff;
 
         // Find tile
         auto    poTile(poGDS->oUnfinishedTiles.find(nTile));
         if(poTile == poGDS->oUnfinishedTiles.end())
         {
             RMFTileData  oTile;
             oTile.oData.resize(nTileSize);
             // If not found, but exist on disk than read it
             if(poGDS->paiTiles[2 * nTile + 1])
             {
-                GDALRasterIOExtraArg    oExtArg;
-                INIT_RASTERIO_EXTRA_ARG(oExtArg);
-
-                //TODO: Add RMFDataset::ReadTile(...)
-                CPLErr eRes = poGDS->IRasterIO(GF_Read, nBlockXOff*nBlockXSize,
-                                 nBlockYOff*nBlockYSize, nRawXSize, nRawYSize,
-                                 oTile.oData.data(), nRawXSize, nRawYSize,
-                                 eDataType, poGDS->nBands, nullptr,
-                                 nTilePixelSize, nTileLineSize, nDataSize,
-                                 &oExtArg);
+                CPLErr eRes;
+                eRes = poGDS->ReadTile(nBlockXOff, nBlockYOff, oTile.oData.data(),
+                                       nTileSize, nRawXSize, nRawYSize);
                 if(eRes != CE_None)
                 {
                     CPLError(CE_Failure, CPLE_FileIO,
                             "Can't read block with offset [%d, %d]",
                             nBlockXOff, nBlockYOff);
                     return eRes;
                 }
             }
             poTile = poGDS->oUnfinishedTiles.insert(poGDS->oUnfinishedTiles.end(),
                                                 std::make_pair(nTile, oTile));
         }
 
         GByte*  pabyTileData = poTile->second.oData.data();
 
         // Copy new data to a tile
-        int iDstBand = poGDS->bReverseBandLayout ?
-                            (nBand - 1) : (poGDS->nBands - nBand);
+        int iDstBand = (poGDS->nBands - nBand);
         for(GUInt32 iLine = 0; iLine != nRawYSize; ++iLine)
         {
             const GByte* pabySrc;
             GByte* pabyDst;
             pabySrc = reinterpret_cast<const GByte*>(pImage) +
                       iLine * nBlockLineSize;
             pabyDst = pabyTileData +
                       iLine * nTileLineSize +
                       iDstBand * nDataSize;
             GDALCopyWords(pabySrc, eDataType, static_cast<int>(nDataSize),
                           pabyDst, eDataType, static_cast<int>(nTilePixelSize),
                           nRawXSize);
         }
         ++poTile->second.nBandsWritten;
 
         // Write to disk if tile is finished
         if(poTile->second.nBandsWritten == poGDS->nBands)
         {
             poGDS->WriteTile(nBlockXOff, nBlockYOff,
                              pabyTileData, nTileSize,
                              nRawXSize, nRawYSize);
             poGDS->oUnfinishedTiles.erase(poTile);
         }
 #ifdef DEBUG
         CPLDebug("RMF", "poGDS->oUnfinishedTiles.size() %d",
                  static_cast<int>(poGDS->oUnfinishedTiles.size()));
 #endif //DEBUG
     }
 
     return CE_None;
 }
 
 /************************************************************************/
 /*                          GetNoDataValue()                            */
 /************************************************************************/
@@ -842,22 +648,23 @@ GDALRasterBand* RMFRasterBand::GetOverview(int i)
 CPLErr RMFRasterBand::IRasterIO(GDALRWFlag eRWFlag, int nXOff, int nYOff,
                                int nXSize, int nYSize, void* pData,
                                int nBufXSize, int nBufYSize, GDALDataType eType,
                                GSpacing nPixelSpace, GSpacing nLineSpace,
                                GDALRasterIOExtraArg* psExtraArg)
 {
     RMFDataset *poGDS = reinterpret_cast<RMFDataset *>(poDS);
 
     if(eRWFlag == GF_Read &&
        poGDS->poCompressData != nullptr &&
        poGDS->poCompressData->oThreadPool.GetThreadCount() > 0)
     {
         poGDS->poCompressData->oThreadPool.WaitCompletion();
     }
+
     return GDALRasterBand::IRasterIO(eRWFlag, nXOff, nYOff, nXSize, nYSize,
                                      pData, nBufXSize, nBufYSize, eType,
                                      nPixelSpace, nLineSpace, psExtraArg);
 }
 
 /************************************************************************/
 /*                       GetColorInterpretation()                       */
 /************************************************************************/
@@ -897,37 +704,37 @@ GDALColorInterp RMFRasterBand::GetColorInterpretation()
 RMFDataset::RMFDataset() :
     eRMFType(RMFT_RSW),
     nXTiles(0),
     nYTiles(0),
     paiTiles(nullptr),
+    pabyDecompressBuffer(nullptr),
     pabyCurrentTile(nullptr),
     nCurrentTileXOff(-1),
     nCurrentTileYOff(-1),
     nCurrentTileBytes(0),
     nColorTableSize(0),
     pabyColorTable(nullptr),
     poColorTable(nullptr),
     pszProjection(CPLStrdup( "" )),
     pszUnitType(CPLStrdup( RMF_UnitsEmpty )),
     bBigEndian(false),
     bHeaderDirty(false),
     fp(nullptr),
     Decompress(nullptr),
     Compress(nullptr),
     nHeaderOffset(0),
-    poParentDS(nullptr),
-    bReverseBandLayout(false)
+    poParentDS(nullptr)
 {
     nBands = 0;
     adfGeoTransform[0] = 0.0;
     adfGeoTransform[1] = 1.0;
     adfGeoTransform[2] = 0.0;
     adfGeoTransform[3] = 0.0;
     adfGeoTransform[4] = 0.0;
     adfGeoTransform[5] = 1.0;
     memset( &sHeader, 0, sizeof(sHeader) );
     memset( &sExtHeader, 0, sizeof(sExtHeader) );
 }
 
 /************************************************************************/
 /*                            ~RMFDataset()                             */
 /************************************************************************/
@@ -935,30 +742,31 @@ RMFDataset::RMFDataset() :
 RMFDataset::~RMFDataset()
 {
     RMFDataset::FlushCache();
     for( size_t n = 0; n != poOvrDatasets.size(); ++n )
     {
         poOvrDatasets[n]->RMFDataset::FlushCache();
     }
 
-    CPLFree( paiTiles );
-    CPLFree( pabyCurrentTile );
+    VSIFree( paiTiles );
+    VSIFree( pabyDecompressBuffer );
+    VSIFree( pabyCurrentTile );
     CPLFree( pszProjection );
     CPLFree( pszUnitType );
     CPLFree( pabyColorTable );
     if( poColorTable != nullptr )
         delete poColorTable;
 
     for( size_t n = 0; n != poOvrDatasets.size(); ++n )
     {
         GDALClose( poOvrDatasets[n] );
     }
 
     if( fp != nullptr && poParentDS == nullptr )
     {
         VSIFCloseL( fp );
     }
 }
 
 /************************************************************************/
 /*                          GetGeoTransform()                           */
 /************************************************************************/
@@ -1350,563 +1158,563 @@ do {                                                                    \
 #define RMF_READ_DOUBLE(ptr, value, offset)                             \
 do {                                                                    \
     (value) = *reinterpret_cast<double*>((ptr) + (offset));             \
     if( poDS->bBigEndian )                                              \
     {                                                                   \
         CPL_MSBPTR64(&(value));                                         \
     }                                                                   \
     else                                                                \
     {                                                                   \
         CPL_LSBPTR64(&(value));                                         \
     }                                                                   \
 } while( false );
 
 /* -------------------------------------------------------------------- */
 /*  Read the main header.                                               */
 /* -------------------------------------------------------------------- */
 
     {
         GByte abyHeader[RMF_HEADER_SIZE] = {};
 
         VSIFSeekL( poDS->fp, nNextHeaderOffset, SEEK_SET );
         if( VSIFReadL( abyHeader, 1, sizeof(abyHeader),
                        poDS->fp ) != sizeof(abyHeader) )
         {
             delete poDS;
             return nullptr;
         }
 
         if( memcmp(abyHeader, RMF_SigMTW, sizeof(RMF_SigMTW)) == 0 )
         {
             poDS->eRMFType = RMFT_MTW;
         }
         else if( memcmp(abyHeader, RMF_SigRSW_BE, sizeof(RMF_SigRSW_BE)) == 0 )
         {
             poDS->eRMFType = RMFT_RSW;
             poDS->bBigEndian = true;
         }
         else
         {
             poDS->eRMFType = RMFT_RSW;
         }
 
         memcpy( poDS->sHeader.bySignature, abyHeader, RMF_SIGNATURE_SIZE );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.iVersion, 4 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nSize, 8 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nOvrOffset, 12 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.iUserID, 16 );
         memcpy( poDS->sHeader.byName, abyHeader + 20,
                 sizeof(poDS->sHeader.byName) );
         poDS->sHeader.byName[sizeof(poDS->sHeader.byName) - 1] = '\0';
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nBitDepth, 52 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nHeight, 56 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nWidth, 60 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nXTiles, 64 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nYTiles, 68 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nTileHeight, 72 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nTileWidth, 76 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nLastTileHeight, 80 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nLastTileWidth, 84 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nROIOffset, 88 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nROISize, 92 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nClrTblOffset, 96 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nClrTblSize, 100 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nTileTblOffset, 104 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nTileTblSize, 108 );
         RMF_READ_LONG( abyHeader, poDS->sHeader.iMapType, 124 );
         RMF_READ_LONG( abyHeader, poDS->sHeader.iProjection, 128 );
         RMF_READ_LONG( abyHeader, poDS->sHeader.iEPSGCode, 132 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.dfScale, 136 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.dfResolution, 144 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.dfPixelSize, 152 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.dfLLY, 160 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.dfLLX, 168 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.dfStdP1, 176 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.dfStdP2, 184 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.dfCenterLong, 192 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.dfCenterLat, 200 );
         poDS->sHeader.iCompression = *(abyHeader + 208);
         poDS->sHeader.iMaskType = *(abyHeader + 209);
         poDS->sHeader.iMaskStep = *(abyHeader + 210);
         poDS->sHeader.iFrameFlag = *(abyHeader + 211);
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nFlagsTblOffset, 212 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nFlagsTblSize, 216 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nFileSize0, 220 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nFileSize1, 224 );
         poDS->sHeader.iUnknown = *(abyHeader + 228);
         poDS->sHeader.iGeorefFlag = *(abyHeader + 244);
         poDS->sHeader.iInverse = *(abyHeader + 245);
         poDS->sHeader.iJpegQuality = *(abyHeader + 246);
         memcpy( poDS->sHeader.abyInvisibleColors,
                 abyHeader + 248, sizeof(poDS->sHeader.abyInvisibleColors) );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.adfElevMinMax[0], 280 );
         RMF_READ_DOUBLE( abyHeader, poDS->sHeader.adfElevMinMax[1], 288 );
         RMF_READ_DOUBLE(abyHeader, poDS->sHeader.dfNoData, 296);
 
         RMF_READ_ULONG( abyHeader, poDS->sHeader.iElevationUnit, 304 );
         poDS->sHeader.iElevationType = *(abyHeader + 308);
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nExtHdrOffset, 312 );
         RMF_READ_ULONG( abyHeader, poDS->sHeader.nExtHdrSize, 316 );
     }
 
     if( poParentDS != nullptr )
     {
         if( 0 != memcmp( poDS->sHeader.bySignature,
                          poParentDS->sHeader.bySignature,
                          RMF_SIGNATURE_SIZE ) )
         {
             CPLError( CE_Warning, CPLE_IllegalArg,
                       "Invalid subheader signature." );
             delete poDS;
             return nullptr;
         }
     }
 
 /* -------------------------------------------------------------------- */
 /*  Read the extended header.                                           */
 /* -------------------------------------------------------------------- */
 
     if( poDS->sHeader.nExtHdrOffset && poDS->sHeader.nExtHdrSize )
     {
         if( poDS->sHeader.nExtHdrSize > 1000000 )
         {
             delete poDS;
             return nullptr;
         }
         GByte *pabyExtHeader = reinterpret_cast<GByte *>(
-            VSICalloc( poDS->sHeader.nExtHdrSize, 1 ) );
+            CPLCalloc( poDS->sHeader.nExtHdrSize, 1 ) );
         if( pabyExtHeader == nullptr )
         {
             delete poDS;
             return nullptr;
         }
 
         VSIFSeekL( poDS->fp, poDS->GetFileOffset( poDS->sHeader.nExtHdrOffset ),
                    SEEK_SET );
         VSIFReadL( pabyExtHeader, 1, poDS->sHeader.nExtHdrSize, poDS->fp );
 
         if( poDS->sHeader.nExtHdrSize >= 36 + 4 )
         {
             RMF_READ_LONG( pabyExtHeader, poDS->sExtHeader.nEllipsoid, 24 );
             RMF_READ_LONG( pabyExtHeader, poDS->sExtHeader.nDatum, 32 );
             RMF_READ_LONG( pabyExtHeader, poDS->sExtHeader.nZone, 36 );
         }
 
         CPLFree( pabyExtHeader );
     }
 
 #undef RMF_READ_DOUBLE
 #undef RMF_READ_LONG
 #undef RMF_READ_ULONG
 
     CPLDebug( "RMF", "Version %d", poDS->sHeader.iVersion );
 
 #ifdef DEBUG
 
     CPLDebug( "RMF", "%s image has width %d, height %d, bit depth %d, "
               "compression scheme %d, %s, nodata %f",
               (poDS->eRMFType == RMFT_MTW) ? "MTW" : "RSW",
               poDS->sHeader.nWidth, poDS->sHeader.nHeight,
               poDS->sHeader.nBitDepth, poDS->sHeader.iCompression,
               poDS->bBigEndian ? "big endian" : "little endian",
               poDS->sHeader.dfNoData );
     CPLDebug( "RMF", "Size %d, offset to overview %#lx, user ID %d, "
               "ROI offset %#lx, ROI size %d",
               poDS->sHeader.nSize,
               static_cast<unsigned long>( poDS->sHeader.nOvrOffset ),
               poDS->sHeader.iUserID,
               static_cast<unsigned long>( poDS->sHeader.nROIOffset ),
               poDS->sHeader.nROISize );
     CPLDebug( "RMF", "Map type %d, projection %d, scale %f, resolution %f, ",
               poDS->sHeader.iMapType, poDS->sHeader.iProjection,
               poDS->sHeader.dfScale, poDS->sHeader.dfResolution );
     CPLDebug( "RMF", "EPSG %d ", (int)poDS->sHeader.iEPSGCode );
     CPLDebug( "RMF", "Georeferencing: pixel size %f, LLX %f, LLY %f",
               poDS->sHeader.dfPixelSize,
               poDS->sHeader.dfLLX, poDS->sHeader.dfLLY );
     if( poDS->sHeader.nROIOffset && poDS->sHeader.nROISize )
     {
         GInt32 nValue = 0;
 
         CPLDebug( "RMF", "ROI coordinates:" );
         /* coverity[tainted_data] */
         for( GUInt32 i = 0; i < poDS->sHeader.nROISize; i += sizeof(nValue) )
         {
             if( VSIFSeekL( poDS->fp,
                            poDS->GetFileOffset( poDS->sHeader.nROIOffset + i ),
                            SEEK_SET ) != 0 ||
                 VSIFReadL( &nValue, 1, sizeof(nValue),
                            poDS->fp ) != sizeof(nValue) )
             {
                 CPLDebug("RMF", "Cannot read ROI at index %u", i);
                 break;
                 //delete poDS;
                 //return nullptr;
             }
 
             CPLDebug( "RMF", "%d", nValue );
         }
     }
 #endif
     if( poDS->sHeader.nWidth >= INT_MAX ||
         poDS->sHeader.nHeight >= INT_MAX ||
         !GDALCheckDatasetDimensions(poDS->sHeader.nWidth, poDS->sHeader.nHeight) )
     {
         delete poDS;
         return nullptr;
     }
 
 /* -------------------------------------------------------------------- */
 /*  Read array of blocks offsets/sizes.                                 */
 /* -------------------------------------------------------------------- */
 
     // To avoid useless excessive memory allocation
     if( poDS->sHeader.nTileTblSize > 1000000 )
     {
         VSIFSeekL( poDS->fp, 0, SEEK_END );
         vsi_l_offset nFileSize = VSIFTellL( poDS->fp );
         if( nFileSize < poDS->sHeader.nTileTblSize )
         {
             delete poDS;
             return nullptr;
         }
     }
 
     if( VSIFSeekL( poDS->fp,
                    poDS->GetFileOffset( poDS->sHeader.nTileTblOffset ),
                    SEEK_SET ) < 0 )
     {
         delete poDS;
         return nullptr;
     }
 
     poDS->paiTiles = reinterpret_cast<GUInt32 *>(
         VSIMalloc( poDS->sHeader.nTileTblSize ) );
     if( !poDS->paiTiles )
     {
         delete poDS;
         return nullptr;
     }
 
     if( VSIFReadL( poDS->paiTiles, 1, poDS->sHeader.nTileTblSize,
                    poDS->fp ) < poDS->sHeader.nTileTblSize )
     {
         CPLDebug( "RMF", "Can't read tiles offsets/sizes table." );
         delete poDS;
         return nullptr;
     }
 
 #ifdef CPL_MSB
     if( !poDS->bBigEndian )
     {
         for( GUInt32 i = 0;
              i < poDS->sHeader.nTileTblSize / sizeof(GUInt32);
              i++ )
             CPL_SWAP32PTR( poDS->paiTiles + i );
     }
 #else
     if( poDS->bBigEndian )
     {
         for( GUInt32 i = 0;
              i < poDS->sHeader.nTileTblSize / sizeof(GUInt32);
              i++ )
             CPL_SWAP32PTR( poDS->paiTiles + i );
     }
 #endif
 
 #ifdef DEBUG
     CPLDebug( "RMF", "List of block offsets/sizes:" );
 
     for( GUInt32 i = 0;
          i < poDS->sHeader.nTileTblSize / sizeof(GUInt32);
          i += 2 )
     {
         CPLDebug( "RMF", "    %u / %u",
                   poDS->paiTiles[i], poDS->paiTiles[i + 1] );
     }
 #endif
 
 /* -------------------------------------------------------------------- */
 /*  Set up essential image parameters.                                  */
 /* -------------------------------------------------------------------- */
     GDALDataType eType = GDT_Byte;
 
     poDS->nRasterXSize = poDS->sHeader.nWidth;
     poDS->nRasterYSize = poDS->sHeader.nHeight;
 
     if( poDS->eRMFType == RMFT_RSW )
     {
         switch( poDS->sHeader.nBitDepth )
         {
             case 32:
             case 24:
             case 16:
                 poDS->nBands = 3;
                 break;
             case 1:
             case 4:
             case 8:
                 if( poParentDS != nullptr && poParentDS->poColorTable != nullptr )
                 {
                     poDS->poColorTable = poParentDS->poColorTable->Clone();
                 }
                 else
                 {
                     // Allocate memory for colour table and read it
                     poDS->nColorTableSize = 1 << poDS->sHeader.nBitDepth;
                     GUInt32 nExpectedColorTableBytes = poDS->nColorTableSize * 4;
                     if(nExpectedColorTableBytes > poDS->sHeader.nClrTblSize )
                     {
                         // We could probably test for strict equality in
                         // the above test ???
                         CPLDebug( "RMF",
                                   "Wrong color table size. "
                                   "Expected %u, got %u.",
                                   nExpectedColorTableBytes,
                                   poDS->sHeader.nClrTblSize );
                         delete poDS;
                         return nullptr;
                     }
                     poDS->pabyColorTable = reinterpret_cast<GByte *>(
                         VSIMalloc( nExpectedColorTableBytes ) );
                     if( poDS->pabyColorTable == nullptr )
                     {
                         CPLDebug( "RMF", "Can't allocate color table." );
                         delete poDS;
                         return nullptr;
                     }
                     if( VSIFSeekL( poDS->fp,
                                    poDS->GetFileOffset( poDS->sHeader.nClrTblOffset ),
                                    SEEK_SET ) < 0 )
                     {
                         CPLDebug( "RMF",
                                   "Can't seek to color table location." );
                         delete poDS;
                         return nullptr;
                     }
                     if( VSIFReadL( poDS->pabyColorTable, 1,
                                    nExpectedColorTableBytes, poDS->fp )
                         < nExpectedColorTableBytes )
                     {
                         CPLDebug( "RMF", "Can't read color table." );
                         delete poDS;
                         return nullptr;
                     }
 
                     poDS->poColorTable = new GDALColorTable();
                     for( GUInt32 i = 0; i < poDS->nColorTableSize; i++ )
                     {
                         const GDALColorEntry oEntry = {
                             poDS->pabyColorTable[i * 4],     // Red
                             poDS->pabyColorTable[i * 4 + 1], // Green
                             poDS->pabyColorTable[i * 4 + 2], // Blue
                             255                              // Alpha
                         };
 
                         poDS->poColorTable->SetColorEntry( i, &oEntry );
                     }
                 }
                 poDS->nBands = 1;
                 break;
             default:
                 break;
         }
         eType = GDT_Byte;
     }
     else
     {
         poDS->nBands = 1;
         if( poDS->sHeader.nBitDepth == 8 )
             eType = GDT_Byte;
         else if( poDS->sHeader.nBitDepth == 16 )
             eType = GDT_Int16;
         else if( poDS->sHeader.nBitDepth == 32 )
             eType = GDT_Int32;
         else if( poDS->sHeader.nBitDepth == 64 )
             eType = GDT_Float64;
     }
 
     if( poDS->sHeader.nTileWidth == 0 || poDS->sHeader.nTileWidth > INT_MAX ||
         poDS->sHeader.nTileHeight == 0 || poDS->sHeader.nTileHeight > INT_MAX )
     {
         CPLDebug("RMF", "Invalid tile dimension : %u x %u",
                  poDS->sHeader.nTileWidth, poDS->sHeader.nTileHeight);
         delete poDS;
         return nullptr;
     }
 
     const int nDataSize = GDALGetDataTypeSizeBytes( eType );
     const int nBlockXSize = static_cast<int>(poDS->sHeader.nTileWidth);
     const int nBlockYSize = static_cast<int>(poDS->sHeader.nTileHeight);
     if( nDataSize == 0 ||
         nBlockXSize > INT_MAX / nBlockYSize ||
         nBlockYSize > INT_MAX / nDataSize ||
         nBlockXSize > INT_MAX / (nBlockYSize * nDataSize) )
     {
         CPLDebug ("RMF", "Too big raster / tile dimension");
         delete poDS;
         return nullptr;
     }
 
     poDS->nXTiles = DIV_ROUND_UP( poDS->nRasterXSize, nBlockXSize );
     poDS->nYTiles = DIV_ROUND_UP( poDS->nRasterYSize, nBlockYSize );
 
 #ifdef DEBUG
     CPLDebug( "RMF", "Image is %d tiles wide, %d tiles long",
               poDS->nXTiles, poDS->nYTiles );
 #endif
 
 /* -------------------------------------------------------------------- */
 /*  Choose compression scheme.                                          */
 /* -------------------------------------------------------------------- */
     if(CE_None != poDS->SetupCompression(eType, poOpenInfo->pszFilename))
     {
         delete poDS;
         return nullptr;
     }
 
     if(poOpenInfo->eAccess == GA_Update)
     {
         if(poParentDS == nullptr)
         {
             if(CE_None != poDS->InitCompressorData(poOpenInfo->papszOpenOptions))
             {
                 delete poDS;
                 return nullptr;
             }
         }
         else
         {
             poDS->poCompressData = poParentDS->poCompressData;
         }
     }
 /* -------------------------------------------------------------------- */
 /*  Create band information objects.                                    */
 /* -------------------------------------------------------------------- */
     for( int iBand = 1; iBand <= poDS->nBands; iBand++ )
         poDS->SetBand( iBand, new RMFRasterBand( poDS, iBand, eType ) );
 
     if(poDS->nBands > 1)
     {
         poDS->SetMetadataItem("INTERLEAVE", "PIXEL", "IMAGE_STRUCTURE");
     }
 /* -------------------------------------------------------------------- */
 /*  Set up projection.                                                  */
 /*                                                                      */
 /*  XXX: If projection value is not specified, but image still have     */
 /*  georeferencing information, assume Gauss-Kruger projection.         */
 /* -------------------------------------------------------------------- */
     if(poDS->sHeader.iEPSGCode > RMF_EPSG_MIN_CODE ||
        poDS->sHeader.iProjection > 0 ||
        (poDS->sHeader.dfPixelSize != 0.0 &&
         poDS->sHeader.dfLLX != 0.0 &&
         poDS->sHeader.dfLLY != 0.0))
     {
         OGRSpatialReference oSRS;
         GInt32 nProj =
             (poDS->sHeader.iProjection) ? poDS->sHeader.iProjection : 1;
         double padfPrjParams[8] = {
             poDS->sHeader.dfStdP1,
             poDS->sHeader.dfStdP2,
             poDS->sHeader.dfCenterLat,
             poDS->sHeader.dfCenterLong,
             1.0,
             0.0,
             0.0,
             0.0
           };
 
         // XXX: Compute zone number for Gauss-Kruger (Transverse Mercator)
         // projection if it is not specified.
         if( nProj == 1L && poDS->sHeader.dfCenterLong == 0.0 )
         {
             if( poDS->sExtHeader.nZone == 0 )
             {
                 double centerXCoord = poDS->sHeader.dfLLX +
                     (poDS->nRasterXSize * poDS->sHeader.dfPixelSize / 2.0);
                 padfPrjParams[7] =
                     floor((centerXCoord - 500000.0 ) / 1000000.0);
             }
             else
             {
                 padfPrjParams[7] = poDS->sExtHeader.nZone;
             }
         }
 
         OGRErr  res = OGRERR_FAILURE;
         if(nProj >= 0 &&
            (poDS->sExtHeader.nDatum >= 0 || poDS->sExtHeader.nEllipsoid >= 0))
         {
             res = oSRS.importFromPanorama( nProj, poDS->sExtHeader.nDatum,
                                  poDS->sExtHeader.nEllipsoid, padfPrjParams );
         }
 
         if(poDS->sHeader.iEPSGCode > RMF_EPSG_MIN_CODE &&
            (OGRERR_NONE != res || oSRS.IsLocal()))
         {
             oSRS.importFromEPSG(poDS->sHeader.iEPSGCode);
         }
 
         if( poDS->pszProjection )
             CPLFree( poDS->pszProjection );
         oSRS.exportToWkt( &poDS->pszProjection );
     }
 
 /* -------------------------------------------------------------------- */
 /*  Set up georeferencing.                                              */
 /* -------------------------------------------------------------------- */
     if( (poDS->eRMFType == RMFT_RSW && poDS->sHeader.iGeorefFlag) ||
         (poDS->eRMFType == RMFT_MTW && poDS->sHeader.dfPixelSize != 0.0) )
     {
         poDS->adfGeoTransform[0] = poDS->sHeader.dfLLX;
         poDS->adfGeoTransform[3] = poDS->sHeader.dfLLY
             + poDS->nRasterYSize * poDS->sHeader.dfPixelSize;
         poDS->adfGeoTransform[1] = poDS->sHeader.dfPixelSize;
         poDS->adfGeoTransform[5] = - poDS->sHeader.dfPixelSize;
         poDS->adfGeoTransform[2] = 0.0;
         poDS->adfGeoTransform[4] = 0.0;
     }
 
 /* -------------------------------------------------------------------- */
 /*  Set units.                                                          */
 /* -------------------------------------------------------------------- */
 
     if( poDS->eRMFType == RMFT_MTW )
     {
         CPLFree(poDS->pszUnitType);
         poDS->pszUnitType = RMFUnitTypeToStr(poDS->sHeader.iElevationUnit);
     }
 
 /* -------------------------------------------------------------------- */
 /*  Report some other dataset related information.                      */
 /* -------------------------------------------------------------------- */
 
     if( poDS->eRMFType == RMFT_MTW )
     {
         char szTemp[256] = {};
 
         snprintf(szTemp, sizeof(szTemp), "%g", poDS->sHeader.adfElevMinMax[0]);
         poDS->SetMetadataItem( "ELEVATION_MINIMUM", szTemp );
 
         snprintf(szTemp, sizeof(szTemp), "%g", poDS->sHeader.adfElevMinMax[1]);
         poDS->SetMetadataItem( "ELEVATION_MAXIMUM", szTemp );
 
         poDS->SetMetadataItem( "ELEVATION_UNITS", poDS->pszUnitType );
 
         snprintf(szTemp, sizeof(szTemp), "%d", poDS->sHeader.iElevationType);
         poDS->SetMetadataItem( "ELEVATION_TYPE", szTemp );
     }
 
 /* -------------------------------------------------------------------- */
 /*      Check for overviews.                                            */
 /* -------------------------------------------------------------------- */
     if( nNextHeaderOffset == 0 && poParentDS == nullptr )
     {
         poDS->oOvManager.Initialize( poDS, poOpenInfo->pszFilename );
     }
 
     return poDS;
 }
 
 /************************************************************************/
 /*                               Create()                               */
 /************************************************************************/
@@ -1921,336 +1729,335 @@ GDALDataset *RMFDataset::Create( const char * pszFilename,
 GDALDataset *RMFDataset::Create( const char * pszFilename,
                                  int nXSize, int nYSize, int nBands,
                                  GDALDataType eType, char **papszParmList,
                                  RMFDataset* poParentDS, double dfOvFactor )
 
 {
     if( nBands != 1 && nBands != 3 )
     {
         CPLError( CE_Failure, CPLE_NotSupported,
                   "RMF driver doesn't support %d bands. Must be 1 or 3.",
                   nBands );
 
         return nullptr;
     }
 
     if( nBands == 1
         && eType != GDT_Byte
         && eType != GDT_Int16
         && eType != GDT_Int32
         && eType != GDT_Float64 )
     {
          CPLError(
              CE_Failure, CPLE_AppDefined,
              "Attempt to create RMF dataset with an illegal data type (%s), "
              "only Byte, Int16, Int32 and Float64 types supported "
              "by the format for single-band images.",
              GDALGetDataTypeName(eType) );
 
         return nullptr;
     }
 
     if( nBands == 3 && eType != GDT_Byte )
     {
          CPLError(
              CE_Failure, CPLE_AppDefined,
              "Attempt to create RMF dataset with an illegal data type (%s), "
              "only Byte type supported by the format for three-band images.",
              GDALGetDataTypeName(eType) );
 
         return nullptr;
     }
 
 /* -------------------------------------------------------------------- */
 /*  Create the dataset.                                                 */
 /* -------------------------------------------------------------------- */
     RMFDataset *poDS = new RMFDataset();
 
     GUInt32 nBlockXSize =
         ( nXSize < RMF_DEFAULT_BLOCKXSIZE ) ? nXSize : RMF_DEFAULT_BLOCKXSIZE;
     GUInt32 nBlockYSize =
         ( nYSize < RMF_DEFAULT_BLOCKYSIZE ) ? nYSize : RMF_DEFAULT_BLOCKYSIZE;
     double dfScale;
     double dfResolution;
     double dfPixelSize;
     if( poParentDS == nullptr )
     {
         poDS->fp = VSIFOpenL( pszFilename, "w+b" );
         if( poDS->fp == nullptr )
         {
             CPLError( CE_Failure, CPLE_OpenFailed, "Unable to create file %s.",
                       pszFilename );
             delete poDS;
             return nullptr;
         }
 
         dfScale = RMF_DEFAULT_SCALE;
         dfResolution = RMF_DEFAULT_RESOLUTION;
         dfPixelSize = 1;
 
         if( CPLFetchBool( papszParmList, "MTW", false) )
             poDS->eRMFType = RMFT_MTW;
         else
             poDS->eRMFType = RMFT_RSW;
 
         GUInt32 iVersion = RMF_VERSION;
         const char *pszRMFHUGE = CSLFetchNameValue(papszParmList, "RMFHUGE");
 
         if( pszRMFHUGE == nullptr )
             pszRMFHUGE = "NO";// Keep old behavior by default
 
         if( EQUAL(pszRMFHUGE,"NO") )
         {
             iVersion = RMF_VERSION;
         }
         else if( EQUAL(pszRMFHUGE,"YES") )
         {
             iVersion = RMF_VERSION_HUGE;
         }
         else if( EQUAL(pszRMFHUGE,"IF_SAFER") )
         {
             const double dfImageSize =
                 static_cast<double>(nXSize) *
                 static_cast<double>(nYSize) *
                 static_cast<double>(nBands) *
                 static_cast<double>(GDALGetDataTypeSizeBytes(eType));
             if( dfImageSize > 3.0*1024.0*1024.0*1024.0 )
             {
                 iVersion = RMF_VERSION_HUGE;
             }
             else
             {
                 iVersion = RMF_VERSION;
             }
         }
 
         const char *pszValue = CSLFetchNameValue(papszParmList,"BLOCKXSIZE");
         if( pszValue != nullptr )
             nBlockXSize = atoi( pszValue );
         if( static_cast<int>(nBlockXSize) <= 0 )
             nBlockXSize = RMF_DEFAULT_BLOCKXSIZE;
 
         pszValue = CSLFetchNameValue(papszParmList,"BLOCKYSIZE");
         if( pszValue != nullptr )
             nBlockYSize = atoi( pszValue );
         if( static_cast<int>(nBlockYSize) <= 0 )
             nBlockYSize = RMF_DEFAULT_BLOCKXSIZE;
 
         if( poDS->eRMFType == RMFT_MTW )
             memcpy( poDS->sHeader.bySignature, RMF_SigMTW, RMF_SIGNATURE_SIZE );
         else
             memcpy( poDS->sHeader.bySignature, RMF_SigRSW, RMF_SIGNATURE_SIZE );
         poDS->sHeader.iVersion = iVersion;
         poDS->sHeader.nOvrOffset = 0x00;
     }
     else
     {
         poDS->fp = poParentDS->fp;
         memcpy( poDS->sHeader.bySignature, poParentDS->sHeader.bySignature,
                 RMF_SIGNATURE_SIZE );
         poDS->sHeader.iVersion = poParentDS->sHeader.iVersion;
         poDS->eRMFType = poParentDS->eRMFType;
         nBlockXSize = poParentDS->sHeader.nTileWidth;
         nBlockYSize = poParentDS->sHeader.nTileHeight;
         dfScale = poParentDS->sHeader.dfScale;
         dfResolution = poParentDS->sHeader.dfResolution/dfOvFactor;
         dfPixelSize = poParentDS->sHeader.dfPixelSize*dfOvFactor;
 
         poDS->nHeaderOffset = poParentDS->GetLastOffset();
         poParentDS->sHeader.nOvrOffset =
                poDS->GetRMFOffset( poDS->nHeaderOffset, &poDS->nHeaderOffset );
         poParentDS->bHeaderDirty = true;
         VSIFSeekL( poDS->fp, poDS->nHeaderOffset, SEEK_SET );
         poDS->poParentDS = poParentDS;
         CPLDebug( "RMF",
                   "Create overview subfile at " CPL_FRMT_GUIB
                   " with size %dx%d, parent overview offset %d",
                   poDS->nHeaderOffset, nXSize, nYSize,
                   poParentDS->sHeader.nOvrOffset );
     }
 /* -------------------------------------------------------------------- */
 /*  Fill the RMFHeader                                                  */
 /* -------------------------------------------------------------------- */
     CPLDebug( "RMF", "Version %d", poDS->sHeader.iVersion );
 
     poDS->sHeader.iUserID = 0x00;
     memset( poDS->sHeader.byName, 0, sizeof(poDS->sHeader.byName) );
     poDS->sHeader.nBitDepth = GDALGetDataTypeSizeBits( eType ) * nBands;
     poDS->sHeader.nHeight = nYSize;
     poDS->sHeader.nWidth = nXSize;
     poDS->sHeader.nTileWidth = nBlockXSize;
     poDS->sHeader.nTileHeight = nBlockYSize;
 
     poDS->nXTiles = poDS->sHeader.nXTiles =
         ( nXSize + poDS->sHeader.nTileWidth - 1 ) / poDS->sHeader.nTileWidth;
     poDS->nYTiles = poDS->sHeader.nYTiles =
         ( nYSize + poDS->sHeader.nTileHeight - 1 ) / poDS->sHeader.nTileHeight;
     poDS->sHeader.nLastTileHeight = nYSize % poDS->sHeader.nTileHeight;
     if( !poDS->sHeader.nLastTileHeight )
         poDS->sHeader.nLastTileHeight = poDS->sHeader.nTileHeight;
     poDS->sHeader.nLastTileWidth = nXSize % poDS->sHeader.nTileWidth;
     if( !poDS->sHeader.nLastTileWidth )
         poDS->sHeader.nLastTileWidth = poDS->sHeader.nTileWidth;
 
     poDS->sHeader.nROIOffset = 0x00;
     poDS->sHeader.nROISize = 0x00;
 
     vsi_l_offset nCurPtr = poDS->nHeaderOffset + RMF_HEADER_SIZE;
 
     // Extended header
     poDS->sHeader.nExtHdrOffset = poDS->GetRMFOffset( nCurPtr, &nCurPtr );
     poDS->sHeader.nExtHdrSize = RMF_EXT_HEADER_SIZE;
     nCurPtr += poDS->sHeader.nExtHdrSize;
 
     // Color table
     if( poDS->eRMFType == RMFT_RSW && nBands == 1 )
     {
         if( poDS->sHeader.nBitDepth > 8 )
         {
             CPLError( CE_Failure, CPLE_AppDefined,
                       "Cannot create color table of RSW with nBitDepth = %d. "
                       "Retry with MTW ?",
                       poDS->sHeader.nBitDepth );
             delete poDS;
             return nullptr;
         }
 
         poDS->sHeader.nClrTblOffset = poDS->GetRMFOffset( nCurPtr, &nCurPtr );
         poDS->nColorTableSize = 1 << poDS->sHeader.nBitDepth;
         poDS->sHeader.nClrTblSize = poDS->nColorTableSize * 4;
         poDS->pabyColorTable = reinterpret_cast<GByte *>(
             VSI_MALLOC_VERBOSE( poDS->sHeader.nClrTblSize ) );
         if( poDS->pabyColorTable == nullptr )
         {
             delete poDS;
             return nullptr;
         }
         for( GUInt32 i = 0; i < poDS->nColorTableSize; i++ )
         {
             poDS->pabyColorTable[i * 4] =
                 poDS->pabyColorTable[i * 4 + 1] =
                 poDS->pabyColorTable[i * 4 + 2] = (GByte) i;
                 poDS->pabyColorTable[i * 4 + 3] = 0;
         }
         nCurPtr += poDS->sHeader.nClrTblSize;
     }
     else
     {
         poDS->sHeader.nClrTblOffset = 0x00;
         poDS->sHeader.nClrTblSize = 0x00;
     }
 
     // Blocks table
     poDS->sHeader.nTileTblOffset = poDS->GetRMFOffset( nCurPtr, &nCurPtr );
     poDS->sHeader.nTileTblSize =
         poDS->sHeader.nXTiles * poDS->sHeader.nYTiles * 4 * 2;
     poDS->paiTiles = reinterpret_cast<GUInt32 *>(
         CPLCalloc( poDS->sHeader.nTileTblSize, 1 ) );
     // nCurPtr += poDS->sHeader.nTileTblSize;
     const GUInt32 nTileSize =
         poDS->sHeader.nTileWidth * poDS->sHeader.nTileHeight
         * GDALGetDataTypeSizeBytes( eType );
     poDS->sHeader.nSize =
         poDS->paiTiles[poDS->sHeader.nTileTblSize / 4 - 2] + nTileSize;
 
     // Elevation units
     poDS->sHeader.iElevationUnit = RMFStrToUnitType(poDS->pszUnitType);
 
     poDS->sHeader.iMapType = -1;
     poDS->sHeader.iProjection = -1;
     poDS->sHeader.iEPSGCode = -1;
     poDS->sHeader.dfScale = dfScale;
     poDS->sHeader.dfResolution = dfResolution;
     poDS->sHeader.dfPixelSize = dfPixelSize;
     poDS->sHeader.iMaskType = 0;
     poDS->sHeader.iMaskStep = 0;
     poDS->sHeader.iFrameFlag = 0;
     poDS->sHeader.nFlagsTblOffset = 0x00;
     poDS->sHeader.nFlagsTblSize = 0x00;
     poDS->sHeader.nFileSize0 = 0x00;
     poDS->sHeader.nFileSize1 = 0x00;
     poDS->sHeader.iUnknown = 0;
     poDS->sHeader.iGeorefFlag = 0;
     poDS->sHeader.iInverse = 0;
     poDS->sHeader.iJpegQuality = 0;
     memset( poDS->sHeader.abyInvisibleColors, 0,
             sizeof(poDS->sHeader.abyInvisibleColors) );
     poDS->sHeader.iElevationType = 0;
 
     poDS->nRasterXSize = nXSize;
     poDS->nRasterYSize = nYSize;
     poDS->eAccess = GA_Update;
     poDS->nBands = nBands;
 
     if(poParentDS == nullptr)
     {
         poDS->sHeader.adfElevMinMax[0] = 0.0;
         poDS->sHeader.adfElevMinMax[1] = 0.0;
         poDS->sHeader.dfNoData = 0.0;
         poDS->sHeader.iCompression = GetCompressionType(
                                         CSLFetchNameValue(papszParmList,
                                                           "COMPRESS"));
         if(CE_None != poDS->InitCompressorData(papszParmList))
         {
             delete poDS;
             return nullptr;
         }
 
         if(poDS->sHeader.iCompression == RMF_COMPRESSION_JPEG)
         {
             const char* pszJpegQuality = CSLFetchNameValue(papszParmList,
                                                            "JPEG_QUALITY");
             if(pszJpegQuality == nullptr)
             {
                 poDS->sHeader.iJpegQuality = 75;
             }
             else
             {
                 int iJpegQuality = atoi(pszJpegQuality);
                 if( iJpegQuality < 10 || iJpegQuality > 100)
                 {
                     CPLError(CE_Failure, CPLE_IllegalArg,
                              "JPEG_QUALITY=%s is not a legal value in the range 10-100.\n"
                              "Defaulting to 75",
                              pszJpegQuality);
                     iJpegQuality = 75;
                 }
                 poDS->sHeader.iJpegQuality = static_cast<GByte>(iJpegQuality);
             }
         }
 
         if(CE_None != poDS->SetupCompression(eType, pszFilename))
         {
             delete poDS;
             return nullptr;
         }
     }
     else
     {
         poDS->sHeader.adfElevMinMax[0] = poParentDS->sHeader.adfElevMinMax[0];
         poDS->sHeader.adfElevMinMax[1] = poParentDS->sHeader.adfElevMinMax[1];
         poDS->sHeader.dfNoData = poParentDS->sHeader.dfNoData;
         poDS->sHeader.iCompression = poParentDS->sHeader.iCompression;
         poDS->sHeader.iJpegQuality = poParentDS->sHeader.iJpegQuality;
         poDS->Decompress = poParentDS->Decompress;
         poDS->Compress = poParentDS->Compress;
         poDS->poCompressData = poParentDS->poCompressData;
-        poDS->bReverseBandLayout = poParentDS->bReverseBandLayout;
     }
 
     if(nBands > 1)
     {
         poDS->SetMetadataItem("INTERLEAVE", "PIXEL", "IMAGE_STRUCTURE");
     }
 
     poDS->WriteHeader();
 
 /* -------------------------------------------------------------------- */
 /*      Create band information objects.                                */
 /* -------------------------------------------------------------------- */
     for( int iBand = 1; iBand <= poDS->nBands; iBand++ )
         poDS->SetBand( iBand, new RMFRasterBand( poDS, iBand, eType ) );
 
     return reinterpret_cast<GDALDataset *>( poDS );
 }
 
 //GIS Panorama 11 was introduced new format for huge files (greater than 3 Gb)
@@ -2663,53 +2470,52 @@ GByte RMFDataset::GetCompressionType(const char* pszCompressName)
 int RMFDataset::SetupCompression(GDALDataType eType, const char* pszFilename)
 {
 /* -------------------------------------------------------------------- */
 /*  XXX: The DEM compression method seems to be only applicable         */
 /*  to Int32 data.                                                      */
 /* -------------------------------------------------------------------- */
     if( sHeader.iCompression == RMF_COMPRESSION_NONE )
     {
         Decompress = nullptr;
         Compress = nullptr;
     }
     else if( sHeader.iCompression == RMF_COMPRESSION_LZW )
     {
         Decompress = &LZWDecompress;
         Compress = &LZWCompress;
         SetMetadataItem("COMPRESSION", "LZW", "IMAGE_STRUCTURE");
     }
     else if( sHeader.iCompression == RMF_COMPRESSION_JPEG
              && eType == GDT_Byte && nBands == RMF_JPEG_BAND_COUNT)
     {
 #ifdef HAVE_LIBJPEG
         CPLString   oBuf;
         oBuf.Printf("%d", (int)sHeader.iJpegQuality);
         Decompress = &JPEGDecompress;
         Compress = &JPEGCompress;
-        bReverseBandLayout = true;
         SetMetadataItem("JPEG_QUALITY", oBuf.c_str(), "IMAGE_STRUCTURE");
         SetMetadataItem("COMPRESSION", "JPEG", "IMAGE_STRUCTURE");
 #else //HAVE_LIBJPEG
          CPLError(CE_Failure, CPLE_AppDefined,
              "JPEG codec is needed to open <%s>.\n"
              "Please rebuild GDAL with libjpeg support.",
              pszFilename);
         return CE_Failure;
 #endif //HAVE_LIBJPEG
     }
     else if( sHeader.iCompression == RMF_COMPRESSION_DEM
              && eType == GDT_Int32 && nBands == RMF_DEM_BAND_COUNT )
     {
         Decompress = &DEMDecompress;
         Compress = &DEMCompress;
         SetMetadataItem("COMPRESSION", "RMF_DEM", "IMAGE_STRUCTURE");
     }
     else
     {
          CPLError(CE_Failure, CPLE_AppDefined,
              "Unknown compression #%d at file <%s>.",
              (int)sHeader.iCompression, pszFilename);
         return CE_Failure;
     }
 
     return CE_None;
 }
@@ -2901,97 +2707,225 @@ CPLErr RMFDataset::WriteTile(int nBlockXOff, int nBlockYOff,
 CPLErr RMFDataset::WriteRawTile(int nBlockXOff, int nBlockYOff,
                                 GByte* pabyData, size_t nTileBytes)
 {
     CPLAssert(nBlockXOff >= 0
               && nBlockYOff >= 0
               && pabyData != nullptr
               && nTileBytes > 0);
 
     const GUInt32 nTile = nBlockYOff * nXTiles + nBlockXOff;
 
     vsi_l_offset nTileOffset = GetFileOffset( paiTiles[2 * nTile] );
     size_t       nTileSize = static_cast<size_t>(paiTiles[2 * nTile + 1]);
 
     if(nTileOffset && nTileSize <= nTileBytes)
     {
         if( VSIFSeekL( fp, nTileOffset, SEEK_SET ) < 0 )
         {
             CPLError( CE_Failure, CPLE_FileIO,
                 "Can't seek to offset %ld in output file to write data.\n%s",
                       static_cast<long>( nTileOffset ),
                       VSIStrerror( errno ) );
             return CE_Failure;
         }
     }
     else
     {
         if( VSIFSeekL( fp, 0, SEEK_END ) < 0 )
         {
             CPLError( CE_Failure, CPLE_FileIO,
                 "Can't seek to offset %ld in output file to write data.\n%s",
                       static_cast<long>( nTileOffset ),
                       VSIStrerror( errno ) );
             return CE_Failure;
         }
         nTileOffset = VSIFTellL( fp );
         vsi_l_offset nNewTileOffset = 0;
         paiTiles[2 * nTile] = GetRMFOffset( nTileOffset, &nNewTileOffset );
 
         if( nTileOffset != nNewTileOffset )
         {
             if( VSIFSeekL( fp, nNewTileOffset, SEEK_SET ) < 0 )
             {
                 CPLError( CE_Failure, CPLE_FileIO,
                           "Can't seek to offset %ld in output file to "
                           "write data.\n%s",
                           static_cast<long>( nNewTileOffset ),
                           VSIStrerror( errno ) );
                 return CE_Failure;
             }
         }
         bHeaderDirty = true;
     }
 
 #ifdef CPL_MSB
     // Compressed tiles are already with proper byte order
     if(eRMFType == RMFT_MTW &&
        sHeader.iCompression == RMF_COMPRESSION_NONE)
     {
         //Byte swap can be done in place
         if( sHeader.nBitDepth == 16 )
         {
             for( size_t i = 0; i < nTileBytes; i += 2 )
                 CPL_SWAP16PTR( pabyData + i );
         }
         else if( sHeader.nBitDepth == 32 )
         {
             for( size_t i = 0; i < nTileBytes; i += 4 )
                 CPL_SWAP32PTR( pabyData + i );
         }
         else if( sHeader.nBitDepth == 64 )
         {
             for( size_t i = 0; i < nTileBytes; i += 8 )
                 CPL_SWAPDOUBLE( pabyData + i );
         }
     }
 #endif
 
     bool bOk = (VSIFWriteL(pabyData, 1, nTileBytes, fp) == nTileBytes);
 
     if(!bOk)
     {
         CPLError(CE_Failure, CPLE_FileIO,
                  "Can't write tile with X offset %d and Y offset %d.\n%s",
                  nBlockXOff, nBlockYOff, VSIStrerror(errno));
         return CE_Failure;
     }
 
     paiTiles[2 * nTile + 1] = static_cast<GUInt32>(nTileBytes);
     bHeaderDirty = true;
 
     return CE_None;
+}
+
+CPLErr RMFDataset::ReadTile(int nBlockXOff, int nBlockYOff,
+                            GByte* pabyData, size_t nRawBytes,
+                            GUInt32 nRawXSize, GUInt32 nRawYSize)
+{
+    const GUInt32 nTile = nBlockYOff * nXTiles + nBlockXOff;
+    if(2 * nTile + 1 >= sHeader.nTileTblSize / sizeof(GUInt32))
+    {
+        return CE_Failure;
+    }
+
+    GUInt32 nTileBytes = paiTiles[2 * nTile + 1];
+    vsi_l_offset nTileOffset = GetFileOffset(paiTiles[2 * nTile]);
+
+    if(nTileOffset == 0)
+    {
+        return CE_None;
+    }
+
+#ifdef DEBUG
+    CPLDebug("RMF", "Read RawSize [%d, %d], nTileBytes %d, nRawBytes %d",
+             nRawXSize, nRawYSize,
+             static_cast<int>(nTileBytes),
+             static_cast<int>(nRawBytes));
+#endif // DEBUG
+
+    if(VSIFSeekL(fp, nTileOffset, SEEK_SET) < 0)
+    {
+        // XXX: We will not report error here, because file just may be
+        // in update state and data for this block will be available later
+        if(eAccess == GA_Update)
+            return CE_None;
+
+        CPLError(CE_Failure, CPLE_FileIO,
+                 "Can't seek to offset %ld in input file to read data.\n%s",
+                 static_cast<long>(nTileOffset),
+                 VSIStrerror( errno ));
+        return CE_Failure;
+    }
+
+    if(Decompress == nullptr ||
+       nTileBytes == nRawBytes)
+    {
+        if(nTileBytes != nRawBytes)
+        {
+            CPLError(CE_Failure, CPLE_AppDefined,
+                     "RMF: Invalid tile size %lu, expected %lu",
+                     static_cast<unsigned long>(nTileBytes),
+                     static_cast<unsigned long>(nRawBytes));
+            return CE_Failure;
+        }
+
+        if(VSIFReadL(pabyData, 1, nRawBytes, fp) < nRawBytes)
+        {
+            CPLError( CE_Failure, CPLE_FileIO,
+                      "RMF: Can't read at offset %lu from input file.\n%s",
+                      static_cast<unsigned long>(nTileOffset),
+                      VSIStrerror(errno));
+            return CE_Failure;
+        }
 
+#ifdef CPL_MSB
+    if(eRMFType == RMFT_MTW)
+    {
+        if(sHeader.nBitDepth == 16)
+        {
+            for(GUInt32 i = 0; i < nRawBytes; i += 2)
+                CPL_SWAP16PTR(pabyData + i);
+        }
+        else if(sHeader.nBitDepth == 32)
+        {
+            for(GUInt32 i = 0; i < nRawBytes; i += 4)
+                CPL_SWAP32PTR(pabyData + i);
+        }
+        else if(sHeader.nBitDepth == 64)
+        {
+            for( GUInt32 i = 0; i < nRawBytes; i += 8)
+                CPL_SWAPDOUBLE(pabyData + i);
+        }
+    }
+#endif
+        return CE_None;
+    }
+
+    if(pabyDecompressBuffer == nullptr)
+    {
+        GUInt32 nMaxTileBytes = sHeader.nTileWidth * sHeader.nTileHeight *
+                                sHeader.nBitDepth / 8;
+        pabyDecompressBuffer =
+           reinterpret_cast<GByte*>(VSIMalloc(std::max(1U, nMaxTileBytes)));
+        if(!pabyDecompressBuffer)
+        {
+            CPLError(CE_Failure, CPLE_OutOfMemory,
+                     "Can't allocate decompress buffer of size %lu.\n%s",
+                     static_cast<unsigned long>(nMaxTileBytes),
+                     VSIStrerror(errno));
+            return CE_Failure;
+        }
+    }
+
+    if(VSIFReadL(pabyDecompressBuffer, 1, nTileBytes, fp) < nTileBytes)
+    {
+        CPLError( CE_Failure, CPLE_FileIO,
+                  "RMF: Can't read at offset %lu from input file.\n%s",
+                  static_cast<unsigned long>(nTileOffset), VSIStrerror(errno));
+        return CE_Failure;
+    }
+
+    size_t  nDecompressedSize =
+                    Decompress(pabyDecompressBuffer, nTileBytes,
+                               pabyData, static_cast<GUInt32>(nRawBytes),
+                               nRawXSize, nRawYSize);
+
+    if(nDecompressedSize != (size_t)nRawBytes)
+    {
+        CPLError( CE_Failure, CPLE_FileIO,
+                  "Can't decompress tile xOff %d yOff %d. "
+                  "Raw tile size is %lu but decompressed is %lu. "
+                  "Compressed tile size is %lu",
+                  nBlockXOff, nBlockYOff,
+                  static_cast<unsigned long>(nRawBytes),
+                  static_cast<unsigned long>(nDecompressedSize),
+                  static_cast<unsigned long>(nTileBytes));
+        return CE_Failure;
+    }
+    // We don't need to swap bytes here,
+    // because decompressed data is in proper byte order
+    return CE_None;
 }
 
 /************************************************************************/
 /*                        GDALRegister_RMF()                            */
 /************************************************************************/
diff --git a/gdal/frmts/rmf/rmfdataset.h b/gdal/frmts/rmf/rmfdataset.h
index aec933f85a..aecd41b7e8 100644
--- a/gdal/frmts/rmf/rmfdataset.h
+++ b/gdal/frmts/rmf/rmfdataset.h
@@ -190,129 +190,133 @@ class RMFDataset final: public GDALDataset
 {
     friend class RMFRasterBand;
 private:
     RMFHeader       sHeader;
     RMFExtHeader    sExtHeader;
     RMFType         eRMFType;
     GUInt32         nXTiles;
     GUInt32         nYTiles;
     GUInt32         *paiTiles;
+    GByte           *pabyDecompressBuffer;
     GByte           *pabyCurrentTile;
     int             nCurrentTileXOff;
     int             nCurrentTileYOff;
     GUInt32         nCurrentTileBytes;
     GUInt32         nColorTableSize;
     GByte           *pabyColorTable;
     GDALColorTable  *poColorTable;
     double          adfGeoTransform[6];
     char            *pszProjection;
 
     char            *pszUnitType;
 
     bool            bBigEndian;
     bool            bHeaderDirty;
 
     VSILFILE        *fp;
 
     std::shared_ptr<RMFCompressData> poCompressData;
     std::map<GUInt32, RMFTileData>   oUnfinishedTiles;
 
     CPLErr          WriteHeader();
     static size_t   LZWDecompress( const GByte*, GUInt32, GByte*, GUInt32, GUInt32, GUInt32 );
     static size_t   LZWCompress(const GByte*, GUInt32, GByte*, GUInt32, GUInt32, GUInt32 , const RMFDataset*);
 #ifdef HAVE_LIBJPEG
     static size_t   JPEGDecompress( const GByte*, GUInt32, GByte*, GUInt32, GUInt32, GUInt32 );
     static size_t   JPEGCompress( const GByte*, GUInt32, GByte*, GUInt32, GUInt32, GUInt32, const RMFDataset* );
 #endif //HAVE_LIBJPEG
     static size_t   DEMDecompress( const GByte*, GUInt32, GByte*, GUInt32, GUInt32, GUInt32 );
     static size_t   DEMCompress( const GByte*, GUInt32, GByte*, GUInt32, GUInt32, GUInt32, const RMFDataset* );
 
     /*!
         Tile decompress callback
         pabyIn - input compressed data
         nSizeIn - input compressed data size (in bytes)
         pabyOut - pointer to uncompressed data
         nSizeOut - maximum uncompressed data size
         nTileSx - width of uncompressed tile (in pixels)
         nTileSy - height of uncompressed tile (in pixels)
 
         Returns: actual uncompressed data size or 0 on error (if nSizeOut is
                  small returns 0 too).
     */
     size_t          (*Decompress)(const GByte* pabyIn, GUInt32 nSizeIn,
                                   GByte* pabyOut, GUInt32 nSizeOut,
                                   GUInt32 nTileSx, GUInt32 nTileSy);
 
     /*!
         Tile compress callback
         pabyIn - input uncompressed data
         nSizeIn - input uncompressed data size (in bytes)
         pabyOut - pointer to compressed data
         nSizeOut - maximum compressed data size
         nTileSx - width of uncompressed tile (in pixels)
         nTileSy - height of uncompressed tile (in pixels)
         poDS - pointer to parent dataset
 
         Returns: actual compressed data size or 0 on error (if nSizeOut is
                  small returns 0 too).
     */
     size_t          (*Compress)(const GByte* pabyIn, GUInt32 nSizeIn,
                                 GByte* pabyOut, GUInt32 nSizeOut ,
                                 GUInt32 nTileSx, GUInt32 nTileSy,
                                 const RMFDataset* poDS);
 
     std::vector<RMFDataset*>    poOvrDatasets;
     vsi_l_offset                nHeaderOffset;
     RMFDataset*                 poParentDS;
-    bool                        bReverseBandLayout;
 
   public:
                 RMFDataset();
         virtual ~RMFDataset();
 
     static int          Identify( GDALOpenInfo * poOpenInfo );
     static GDALDataset  *Open( GDALOpenInfo * );
     static GDALDataset  *Open(GDALOpenInfo *, RMFDataset* poParentDS, vsi_l_offset nNextHeaderOffset );
     static GDALDataset  *Create( const char *, int, int, int,
                                  GDALDataType, char ** );
     static GDALDataset  *Create( const char *, int, int, int,
                                  GDALDataType, char **,
                                  RMFDataset* poParentDS, double dfOvFactor );
     virtual void        FlushCache() override;
 
     virtual CPLErr      GetGeoTransform( double * padfTransform ) override;
     virtual CPLErr      SetGeoTransform( double * ) override;
     virtual const char  *GetProjectionRef() override;
     virtual CPLErr      SetProjection( const char * ) override;
     virtual CPLErr      IBuildOverviews( const char * pszResampling,
                                          int nOverviews, int * panOverviewList,
                                          int nBandsIn, int * panBandList,
                                          GDALProgressFunc pfnProgress,
                                          void * pProgressData ) override;
     virtual CPLErr IRasterIO( GDALRWFlag eRWFlag,
                               int nXOff, int nYOff, int nXSize, int nYSize,
                               void * pData, int nBufXSize, int nBufYSize,
                               GDALDataType eBufType,
                               int nBandCount, int *panBandMap,
                               GSpacing nPixelSpace, GSpacing nLineSpace,
                               GSpacing nBandSpace,
                               GDALRasterIOExtraArg* psExtraArg ) override;
     vsi_l_offset        GetFileOffset( GUInt32 iRMFOffset ) const;
     GUInt32             GetRMFOffset( vsi_l_offset iFileOffset, vsi_l_offset* piNewFileOffset ) const;
     RMFDataset*         OpenOverview( RMFDataset* poParentDS, GDALOpenInfo* );
     vsi_l_offset        GetLastOffset() const;
     CPLErr              CleanOverviews();
     static GByte        GetCompressionType(const char* pszCompressName);
     int                 SetupCompression(GDALDataType eType,
                                          const char* pszFilename);
     static void         WriteTileJobFunc(void* pData);
     CPLErr              InitCompressorData(char **papszParmList);
     CPLErr              WriteTile(int nBlockXOff, int nBlockYOff,
                                   GByte* pabyData, size_t nBytes,
                                   GUInt32 nRawXSize, GUInt32 nRawYSize);
     CPLErr              WriteRawTile(int nBlockXOff, int nBlockYOff,
                                      GByte* pabyData, size_t nBytes);
+    CPLErr              ReadTile(int nBlockXOff, int nBlockYOff,
+                                 GByte* pabyData, size_t nBytes,
+                                 GUInt32 nRawXSize, GUInt32 nRawYSize);
+
 };
 
 /************************************************************************/
 /*                            RMFRasterBand                             */
 /************************************************************************/
@@ -320,38 +324,36 @@ private:
 class RMFRasterBand final: public GDALRasterBand
 {
     friend class RMFDataset;
 
   private:
 
     GUInt32     nBytesPerPixel;
     GUInt32     nBlockSize;
     GUInt32     nBlockBytes;
     GUInt32     nLastTileWidth;
     GUInt32     nLastTileHeight;
     GUInt32     nDataSize;
 
-    CPLErr   ReadBuffer( GByte *, GUInt32 ) const;
-
   public:
 
                 RMFRasterBand( RMFDataset *, int, GDALDataType );
         virtual ~RMFRasterBand();
 
     virtual CPLErr          IReadBlock( int, int, void * ) override;
     virtual CPLErr          IWriteBlock( int, int, void * ) override;
     virtual double          GetNoDataValue(int *pbSuccess = nullptr) override;
     virtual CPLErr          SetNoDataValue( double dfNoData ) override;
     virtual const char      *GetUnitType() override;
     virtual GDALColorInterp GetColorInterpretation() override;
     virtual GDALColorTable  *GetColorTable() override;
     virtual CPLErr          SetUnitType( const char * ) override;
     virtual CPLErr          SetColorTable( GDALColorTable * ) override;
     virtual int             GetOverviewCount() override;
     virtual GDALRasterBand* GetOverview( int i ) override;
     virtual CPLErr          IRasterIO(GDALRWFlag eRWFlag, int nXOff, int nYOff,
                                       int nXSize, int nYSize, void * pData,
                                       int nBufXSize, int nBufYSize,
                                       GDALDataType eBufType,
                                       GSpacing nPixelSpace, GSpacing nLineSpace,
                                       GDALRasterIOExtraArg* psExtraArg ) override;
 };
diff --git a/gdal/frmts/rmf/rmfjpeg.cpp b/gdal/frmts/rmf/rmfjpeg.cpp
index 4cbd27664a..1ba742b632 100644
--- a/gdal/frmts/rmf/rmfjpeg.cpp
+++ b/gdal/frmts/rmf/rmfjpeg.cpp
@@ -41,89 +41,89 @@
 size_t RMFDataset::JPEGDecompress(const GByte* pabyIn, GUInt32 nSizeIn,
                                   GByte* pabyOut, GUInt32 nSizeOut,
                                   GUInt32 nRawXSize, GUInt32 nRawYSize)
 {
     if(pabyIn == nullptr ||
        pabyOut == nullptr ||
        nSizeOut < nSizeIn ||
        nSizeIn < 2)
        return 0;
 
     CPLString   osTmpFilename;
     VSILFILE*   fp;
 
     osTmpFilename.Printf("/vsimem/rmfjpeg/%p.jpg", pabyIn);
 
     fp = VSIFileFromMemBuffer(osTmpFilename, const_cast<GByte*>(pabyIn),
                               nSizeIn, FALSE);
 
     if(fp == nullptr)
     {
         CPLError(CE_Failure, CPLE_AppDefined,
                  "RMF JPEG: Can't create %s file", osTmpFilename.c_str());
         return 0;
     }
 
     const char*     apszAllowedDrivers[] = {"JPEG", nullptr};
     GDALDatasetH    hTile;
 
 
     CPLConfigOptionSetter   oNoReadDir("GDAL_DISABLE_READDIR_ON_OPEN",
                                        "EMPTY_DIR", false);
 
     hTile = GDALOpenEx(osTmpFilename, GDAL_OF_RASTER | GDAL_OF_INTERNAL,
                        apszAllowedDrivers, nullptr, nullptr);
 
     if(hTile == nullptr)
     {
         CPLError(CE_Failure, CPLE_AppDefined,
                  "RMF JPEG: Can't open %s file", osTmpFilename.c_str());
         VSIFCloseL(fp);
         VSIUnlink(osTmpFilename);
         return 0;
     }
 
     if(GDALGetRasterCount(hTile) != RMF_JPEG_BAND_COUNT)
     {
         CPLError(CE_Failure, CPLE_AppDefined,
                  "RMF JPEG: Invalid band count %d in tile, must be %d",
                  GDALGetRasterCount(hTile), (int)RMF_JPEG_BAND_COUNT);
         GDALClose(hTile);
         VSIFCloseL(fp);
         VSIUnlink(osTmpFilename);
         return 0;
     }
 
     int nBandCount = GDALGetRasterCount(hTile);
     int nImageWidth = std::min(GDALGetRasterXSize(hTile),
                                static_cast<int>(nRawXSize));
     int nImageHeight = std::min(GDALGetRasterYSize(hTile),
                                 static_cast<int>(nRawYSize));
     CPLErr  eErr;
     size_t  nRet;
-
+    int     aBandMap[RMF_JPEG_BAND_COUNT] = {3, 2, 1};
     eErr = GDALDatasetRasterIO(hTile, GF_Read, 0, 0,
                                nImageWidth, nImageHeight, pabyOut,
                                nImageWidth, nImageHeight, GDT_Byte,
-                               nBandCount, nullptr,
+                               nBandCount, aBandMap,
                                nBandCount, nRawXSize * nBandCount, 1);
     if(CE_None != eErr)
     {
         CPLError(CE_Failure, CPLE_AppDefined,
                  "RMF JPEG: Error decompress JPEG tile");
         nRet = 0;
     }
     else
     {
         nRet = static_cast<size_t>(nRawXSize * nBandCount * nImageHeight);
     }
 
     GDALClose(hTile);
     VSIFCloseL(fp);
     VSIUnlink(osTmpFilename);
 
     return nRet;
 }
 
 /************************************************************************/
 /*                            JPEGCompress()                            */
 /************************************************************************/
@@ -131,87 +131,88 @@ size_t RMFDataset::JPEGDecompress(const GByte* pabyIn, GUInt32 nSizeIn,
 size_t RMFDataset::JPEGCompress(const GByte* pabyIn, GUInt32 nSizeIn,
                                 GByte* pabyOut, GUInt32 nSizeOut,
                                 GUInt32 nRawXSize, GUInt32 nRawYSize,
                                 const RMFDataset* poDS)
 {
     if(pabyIn == nullptr ||
        pabyOut == nullptr ||
        nSizeIn < 2)
        return 0;
 
     GDALDriverH hJpegDriver = GDALGetDriverByName("JPEG");
 
     if(hJpegDriver == nullptr)
     {
         CPLError(CE_Failure, CPLE_AppDefined,
                  "RMF: JPEG driver not found");
         return 0;
     }
 
     GDALDataType    eType = GDT_Byte;
     GDALDataset*    poMemDS = MEMDataset::Create("", nRawXSize, nRawYSize, 0,
                                                  eType, nullptr);
 
     for(int iBand = 0; iBand < RMF_JPEG_BAND_COUNT; ++iBand)
     {
         char szBuffer[32] = {};
-        int nRet = CPLPrintPointer(szBuffer, (void*)(pabyIn + iBand),
+        const GByte* pabyBand = pabyIn + (RMF_JPEG_BAND_COUNT - iBand - 1);
+        int nRet = CPLPrintPointer(szBuffer, (void*)(pabyBand),
                                    sizeof(szBuffer));
         szBuffer[nRet] = 0;
 
         char szBuffer0[64] = {};
         snprintf( szBuffer0, sizeof(szBuffer0), "DATAPOINTER=%s", szBuffer );
 
         char szBuffer1[64] = "PIXELOFFSET=3";
         char szBuffer2[64] = {};
         snprintf( szBuffer2, sizeof(szBuffer2),
                   "LINEOFFSET=%d", nRawXSize*RMF_JPEG_BAND_COUNT );
 
         char* apszOptions[4] = { szBuffer0, szBuffer1, szBuffer2, nullptr };
 
         poMemDS->AddBand(eType, apszOptions);
     }
 
     CPLString   osTmpFilename;
     osTmpFilename.Printf("/vsimem/rmfjpeg/%p.jpg", pabyIn);
 
     char szQuality[32] = {};
     if(poDS != nullptr && poDS->sHeader.iJpegQuality > 0)
     {
         snprintf(szQuality, sizeof(szQuality),
                  "QUALITY=%d", (int)poDS->sHeader.iJpegQuality);
     }
     else
     {
         snprintf(szQuality, sizeof(szQuality), "QUALITY=75");
     }
 
     char* apszJpegOptions[2] = {szQuality, nullptr};
 
     GDALDatasetH   hJpeg = GDALCreateCopy(hJpegDriver, osTmpFilename, poMemDS,
                                           0, apszJpegOptions, nullptr, nullptr);
     GDALClose(poMemDS);
 
     if(hJpeg == nullptr)
     {
         CPLError(CE_Failure, CPLE_AppDefined,
                  "RMF JPEG: Error compress JPEG tile");
         VSIUnlink(osTmpFilename);
         return 0;
     }
 
     GDALClose(hJpeg);
 
     vsi_l_offset    nDataLength = 0;
     GByte* pabyBuffer = VSIGetMemFileBuffer(osTmpFilename, &nDataLength, TRUE);
 
     if(nDataLength < nSizeOut)
     {
         memcpy(pabyOut, pabyBuffer, static_cast<size_t>(nDataLength));
         CPLFree(pabyBuffer);
         return static_cast<size_t>(nDataLength);
     }
 
     CPLFree(pabyBuffer);
     return 0;
 }
 #endif //HAVE_LIBJPEG
