commit 98d3198c61b001643a97010b6c0e109c72567bc8
Author: Cristy <mikayla-grace@urban-warrior.org>
Date:   Sun Feb 9 20:14:05 2020 -0500

    ...

diff --git a/MagickCore/color.c b/MagickCore/color.c
index 58e9099d6..d83676dbe 100644
--- a/MagickCore/color.c
+++ b/MagickCore/color.c
@@ -1093,139 +1093,139 @@ MagickExport const ColorInfo *GetColorInfo(const char *name,
   ExceptionInfo *exception)
 {
   return(GetColorCompliance(name,AllCompliance,exception));
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   C o n c a t e n a t e C o l o r C o m p o n e n t                         %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  ConcatenateColorComponent() returns the pixel as a canonical string.
 %
 %  The format of the ConcatenateColorComponent() method is:
 %
 %      void ConcatenateColorComponent(const PixelInfo *pixel,
 %        const PixelChannel channel,const ComplianceType compliance,
 %        char *tuple)
 %
 %  A description of each parameter follows.
 %
 %    o pixel:  The pixel.
 %
 %    o channel:  The pixel channel.
 %
 %    o compliance: Adhere to this color standard: SVG, X11, or XPM.
 %
 %    o tuple:  The color tuple.
 %
 */
 MagickExport void ConcatenateColorComponent(const PixelInfo *pixel,
   const PixelChannel channel,const ComplianceType compliance,char *tuple)
 {
   char
     component[MagickPathExtent];
 
   float
     color,
     scale;
 
   color=0.0f;
   scale=QuantumRange;
   if ((compliance != NoCompliance) || (pixel->depth <= 8))
     scale=255.0f;
-  if ((compliance != NoCompliance) &&
-      (IssRGBCompatibleColorspace(pixel->colorspace) != MagickFalse))
-    scale=100.0f;
   switch (channel)
   {
     case RedPixelChannel:
     {
       color=pixel->red;
       if (IsHueCompatibleColorspace(pixel->colorspace) != MagickFalse)
         scale=360.0f;
       if ((compliance != NoCompliance) && (pixel->colorspace == LabColorspace))
         scale=100.0f;
       break;
     }
     case GreenPixelChannel:
     {
       color=pixel->green;
       if (IsHueCompatibleColorspace(pixel->colorspace) != MagickFalse)
         scale=100.0f;
       if ((compliance != NoCompliance) && (pixel->colorspace == LabColorspace))
         color-=QuantumRange/2.0f;
       break;
     }
     case BluePixelChannel:
     {
       color=pixel->blue;
       if (IsHueCompatibleColorspace(pixel->colorspace) != MagickFalse)
         scale=100.0f;
       if (pixel->colorspace == LabColorspace)
         color-=QuantumRange/2.0f;
       break;
     }
     case AlphaPixelChannel:
     {
       color=pixel->alpha;
       if (compliance != NoCompliance)
         scale=1.0f;
       break;
     }
     case BlackPixelChannel:
     {
       color=pixel->black;
       break;
     }
     case IndexPixelChannel:
     {
       color=pixel->index;
       break;
     }
     default:
       break;
   }
+  if ((compliance != NoCompliance) && ((color-(ssize_t) color) > 0.01f) &&
+      (IssRGBCompatibleColorspace(pixel->colorspace) != MagickFalse))
+    scale=100.0f;
   if (scale != 100.0f)
     (void) FormatLocaleString(component,MagickPathExtent,"%.*g",
       GetMagickPrecision(),(double) (scale*QuantumScale*color));
   else
     (void) FormatLocaleString(component,MagickPathExtent,"%.*g%%",
       GetMagickPrecision(),(double) (scale*QuantumScale*color));
   (void) ConcatenateMagickString(tuple,component,MagickPathExtent);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   G e t C o l o r I n f o L i s t                                           %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  GetColorInfoList() returns any colors that match the specified pattern.
 %
 %  The format of the GetColorInfoList function is:
 %
 %      const ColorInfo **GetColorInfoList(const char *pattern,
 %        size_t *number_colors,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o pattern: Specifies a pointer to a text string containing a pattern.
 %
 %    o number_colors:  This integer returns the number of colors in the list.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 
 #if defined(__cplusplus) || defined(c_plusplus)
diff --git a/MagickCore/vision.c b/MagickCore/vision.c
index 8486f4561..4fdcba020 100644
--- a/MagickCore/vision.c
+++ b/MagickCore/vision.c
@@ -131,801 +131,802 @@ static int CCObjectInfoCompare(const void *x,const void *y)
 MagickExport Image *ConnectedComponentsImage(const Image *image,
   const size_t connectivity,CCObjectInfo **objects,ExceptionInfo *exception)
 {
 #define ConnectedComponentsImageTag  "ConnectedComponents/Image"
 
   CacheView
     *component_view,
     *image_view,
     *object_view;
 
   CCObjectInfo
     *object;
 
   char
     *c;
 
   const char
     *artifact,
     *metric = "";
 
   double
     max_threshold,
     min_threshold;
 
   Image
     *component_image;
 
   MagickBooleanType
     status;
 
   MagickOffsetType
     progress;
 
   MatrixInfo
     *equivalences;
 
   RectangleInfo
     bounding_box;
 
   register ssize_t
     i;
 
   size_t
     size;
 
   ssize_t
     background_id,
     connect4[2][2] = { { -1,  0 }, {  0, -1 } },
     connect8[4][2] = { { -1, -1 }, { -1,  0 }, { -1,  1 }, {  0, -1 } },
     dx,
     dy,
     first,
     last,
     n,
     step,
     y;
 
   /*
     Initialize connected components image attributes.
   */
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   if (objects != (CCObjectInfo **) NULL)
     *objects=(CCObjectInfo *) NULL;
   component_image=CloneImage(image,0,0,MagickTrue,exception);
   if (component_image == (Image *) NULL)
     return((Image *) NULL);
   component_image->depth=MAGICKCORE_QUANTUM_DEPTH;
   if (AcquireImageColormap(component_image,MaxColormapSize,exception) == MagickFalse)
     {
       component_image=DestroyImage(component_image);
       ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
     }
   /*
     Initialize connected components equivalences.
   */
   size=image->columns*image->rows;
   if (image->columns != (size/image->rows))
     {
       component_image=DestroyImage(component_image);
       ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
     }
   equivalences=AcquireMatrixInfo(size,1,sizeof(ssize_t),exception);
   if (equivalences == (MatrixInfo *) NULL)
     {
       component_image=DestroyImage(component_image);
       return((Image *) NULL);
     }
   for (n=0; n < (ssize_t) (image->columns*image->rows); n++)
     (void) SetMatrixElement(equivalences,n,0,&n);
   object=(CCObjectInfo *) AcquireQuantumMemory(MaxColormapSize,sizeof(*object));
   if (object == (CCObjectInfo *) NULL)
     {
       equivalences=DestroyMatrixInfo(equivalences);
       component_image=DestroyImage(component_image);
       ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
     }
   (void) memset(object,0,MaxColormapSize*sizeof(*object));
   for (i=0; i < (ssize_t) MaxColormapSize; i++)
   {
     object[i].id=i;
     object[i].bounding_box.x=(ssize_t) image->columns;
     object[i].bounding_box.y=(ssize_t) image->rows;
     GetPixelInfo(image,&object[i].color);
   }
   /*
     Find connected components.
   */
   status=MagickTrue;
   progress=0;
   image_view=AcquireVirtualCacheView(image,exception);
   for (n=0; n < (ssize_t) (connectivity > 4 ? 4 : 2); n++)
   {
     if (status == MagickFalse)
       continue;
     dx=connectivity > 4 ? connect8[n][1] : connect4[n][1];
     dy=connectivity > 4 ? connect8[n][0] : connect4[n][0];
     for (y=0; y < (ssize_t) image->rows; y++)
     {
       register const Quantum
         *magick_restrict p;
 
       register ssize_t
         x;
 
       if (status == MagickFalse)
         continue;
       p=GetCacheViewVirtualPixels(image_view,0,y-1,image->columns,3,exception);
       if (p == (const Quantum *) NULL)
         {
           status=MagickFalse;
           continue;
         }
       p+=GetPixelChannels(image)*image->columns;
       for (x=0; x < (ssize_t) image->columns; x++)
       {
         PixelInfo
           pixel,
           target;
 
         ssize_t
           neighbor_offset,
           obj,
           offset,
           ox,
           oy,
           root;
 
         /*
           Is neighbor an authentic pixel and a different color than the pixel?
         */
         GetPixelInfoPixel(image,p,&pixel);
         if (((x+dx) < 0) || ((x+dx) >= (ssize_t) image->columns) ||
             ((y+dy) < 0) || ((y+dy) >= (ssize_t) image->rows))
           {
             p+=GetPixelChannels(image);
             continue;
           }
         neighbor_offset=dy*(GetPixelChannels(image)*image->columns)+dx*
           GetPixelChannels(image);
         GetPixelInfoPixel(image,p+neighbor_offset,&target);
         if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse)
           {
             p+=GetPixelChannels(image);
             continue;
           }
         /*
           Resolve this equivalence.
         */
         offset=y*image->columns+x;
         neighbor_offset=dy*image->columns+dx;
         ox=offset;
         status=GetMatrixElement(equivalences,ox,0,&obj);
         while (obj != ox)
         {
           ox=obj;
           status=GetMatrixElement(equivalences,ox,0,&obj);
         }
         oy=offset+neighbor_offset;
         status=GetMatrixElement(equivalences,oy,0,&obj);
         while (obj != oy)
         {
           oy=obj;
           status=GetMatrixElement(equivalences,oy,0,&obj);
         }
         if (ox < oy)
           {
             status=SetMatrixElement(equivalences,oy,0,&ox);
             root=ox;
           }
         else
           {
             status=SetMatrixElement(equivalences,ox,0,&oy);
             root=oy;
           }
         ox=offset;
         status=GetMatrixElement(equivalences,ox,0,&obj);
         while (obj != root)
         {
           status=GetMatrixElement(equivalences,ox,0,&obj);
           status=SetMatrixElement(equivalences,ox,0,&root);
         }
         oy=offset+neighbor_offset;
         status=GetMatrixElement(equivalences,oy,0,&obj);
         while (obj != root)
         {
           status=GetMatrixElement(equivalences,oy,0,&obj);
           status=SetMatrixElement(equivalences,oy,0,&root);
         }
         status=SetMatrixElement(equivalences,y*image->columns+x,0,&root);
         p+=GetPixelChannels(image);
       }
     }
   }
   /*
     Label connected components.
   */
   n=0;
   component_view=AcquireAuthenticCacheView(component_image,exception);
   for (y=0; y < (ssize_t) component_image->rows; y++)
   {
     register const Quantum
       *magick_restrict p;
 
     register Quantum
       *magick_restrict q;
 
     register ssize_t
       x;
 
     if (status == MagickFalse)
       continue;
     p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
     q=QueueCacheViewAuthenticPixels(component_view,0,y,component_image->columns,
       1,exception);
     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
       {
         status=MagickFalse;
         continue;
       }
     for (x=0; x < (ssize_t) component_image->columns; x++)
     {
       ssize_t
         id,
         offset;
 
       offset=y*image->columns+x;
       status=GetMatrixElement(equivalences,offset,0,&id);
       if (id != offset)
         status=GetMatrixElement(equivalences,id,0,&id);
       else
         {
           id=n++;
           if (id >= (ssize_t) MaxColormapSize)
             break;
         }
       status=SetMatrixElement(equivalences,offset,0,&id);
       if (x < object[id].bounding_box.x)
         object[id].bounding_box.x=x;
       if (x >= (ssize_t) object[id].bounding_box.width)
         object[id].bounding_box.width=(size_t) x;
       if (y < object[id].bounding_box.y)
         object[id].bounding_box.y=y;
       if (y >= (ssize_t) object[id].bounding_box.height)
         object[id].bounding_box.height=(size_t) y;
       object[id].color.red+=QuantumScale*GetPixelRed(image,p);
       object[id].color.green+=QuantumScale*GetPixelGreen(image,p);
       object[id].color.blue+=QuantumScale*GetPixelBlue(image,p);
       if (image->alpha_trait != UndefinedPixelTrait)
         object[id].color.alpha+=QuantumScale*GetPixelAlpha(image,p);
       if (image->colorspace == CMYKColorspace)
         object[id].color.black+=QuantumScale*GetPixelBlack(image,p);
       object[id].centroid.x+=x;
       object[id].centroid.y+=y;
       object[id].area++;
       SetPixelIndex(component_image,(Quantum) id,q);
       p+=GetPixelChannels(image);
       q+=GetPixelChannels(component_image);
     }
     if (n > (ssize_t) MaxColormapSize)
       break;
     if (SyncCacheViewAuthenticPixels(component_view,exception) == MagickFalse)
       status=MagickFalse;
     if (image->progress_monitor != (MagickProgressMonitor) NULL)
       {
         MagickBooleanType
           proceed;
 
         progress++;
         proceed=SetImageProgress(image,ConnectedComponentsImageTag,progress,
           image->rows);
         if (proceed == MagickFalse)
           status=MagickFalse;
       }
   }
   component_view=DestroyCacheView(component_view);
   image_view=DestroyCacheView(image_view);
   equivalences=DestroyMatrixInfo(equivalences);
   if (n > (ssize_t) MaxColormapSize)
     {
       object=(CCObjectInfo *) RelinquishMagickMemory(object);
       component_image=DestroyImage(component_image);
       ThrowImageException(ResourceLimitError,"TooManyObjects");
     }
   background_id=0;
   min_threshold=0.0;
   max_threshold=0.0;
   component_image->colors=(size_t) n;
   for (i=0; i < (ssize_t) component_image->colors; i++)
   {
     object[i].bounding_box.width-=(object[i].bounding_box.x-1);
     object[i].bounding_box.height-=(object[i].bounding_box.y-1);
     object[i].color.red/=(object[i].area/QuantumRange);
     object[i].color.green/=(object[i].area/QuantumRange);
     object[i].color.blue/=(object[i].area/QuantumRange);
     if (image->alpha_trait != UndefinedPixelTrait)
       object[i].color.alpha/=(object[i].area/QuantumRange);
     if (image->colorspace == CMYKColorspace)
       object[i].color.black/=(object[i].area/QuantumRange);
     object[i].centroid.x/=object[i].area;
     object[i].centroid.y/=object[i].area;
     max_threshold+=object[i].area;
     if (object[i].area > object[background_id].area)
       background_id=i;
   }
   max_threshold+=MagickEpsilon;
   artifact=GetImageArtifact(image,"connected-components:background-id");
   if (artifact != (const char *) NULL)
     background_id=(ssize_t) StringToDouble(artifact,(char **) NULL);
   artifact=GetImageArtifact(image,"connected-components:area-threshold");
   if (artifact != (const char *) NULL)
     {
       /*
         Merge any object not within the min and max area threshold.
       */
       (void) sscanf(artifact,"%lf%*[ -]%lf",&min_threshold,&max_threshold);
       for (i=0; i < (ssize_t) component_image->colors; i++)
         if (((object[i].area < min_threshold) ||
              (object[i].area >= max_threshold)) && (i != background_id))
           object[i].merge=MagickTrue;
     }
   artifact=GetImageArtifact(image,"connected-components:keep-colors");
   if (artifact != (const char *) NULL)
     {
       register const char
         *p;
 
       /*
         Keep selected objects based on color, merge others.
       */
       for (i=0; i < (ssize_t) component_image->colors; i++)
         object[i].merge=MagickTrue;
       for (p=artifact;  ; )
       {
         char
           color[MagickPathExtent];
 
         PixelInfo
           pixel;
 
         register const char
           *q;
 
         for (q=p; *q != '\0'; q++)
           if (*q == ';')
             break;
         (void) CopyMagickString(color,p,(size_t) MagickMin(q-p+1,
           MagickPathExtent));
         (void) QueryColorCompliance(color,AllCompliance,&pixel,exception);
         for (i=0; i < (ssize_t) component_image->colors; i++)
           if (IsFuzzyEquivalencePixelInfo(&object[i].color,&pixel) != MagickFalse)
             object[i].merge=MagickFalse;
         if (*q == '\0')
           break;
         p=q+1;
       }
     }
   artifact=GetImageArtifact(image,"connected-components:keep-ids");
   if (artifact == (const char *) NULL)
     artifact=GetImageArtifact(image,"connected-components:keep");
   if (artifact != (const char *) NULL)
     {
       /*
         Keep selected objects based on id, merge others.
       */
       for (i=0; i < (ssize_t) component_image->colors; i++)
         object[i].merge=MagickTrue;
       for (c=(char *) artifact; *c != '\0';)
       {
         while ((isspace((int) ((unsigned char) *c)) != 0) || (*c == ','))
           c++;
         first=(ssize_t) strtol(c,&c,10);
         if (first < 0)
           first+=(ssize_t) component_image->colors;
         last=first;
         while (isspace((int) ((unsigned char) *c)) != 0)
           c++;
         if (*c == '-')
           {
             last=(ssize_t) strtol(c+1,&c,10);
             if (last < 0)
               last+=(ssize_t) component_image->colors;
           }
         step=(ssize_t) (first > last ? -1 : 1);
         for ( ; first != (last+step); first+=step)
           object[first].merge=MagickFalse;
       }
     }
   artifact=GetImageArtifact(image,"connected-components:keep-top");
   if (artifact != (const char *) NULL)
     {
       CCObjectInfo
         *top_objects;
 
       ssize_t
         top_ids;
 
       /*
         Keep top objects.
       */
       top_ids=(ssize_t) StringToDouble(artifact,(char **) NULL);
       top_objects=(CCObjectInfo *) AcquireQuantumMemory(component_image->colors,
         sizeof(*top_objects));
       if (top_objects == (CCObjectInfo *) NULL)
         {
           object=(CCObjectInfo *) RelinquishMagickMemory(object);
           component_image=DestroyImage(component_image);
           ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
         }
       (void) memcpy(top_objects,object,component_image->colors*sizeof(*object));
       qsort((void *) top_objects,component_image->colors,sizeof(*top_objects),
         CCObjectInfoCompare);
       for (i=top_ids+1; i < (ssize_t) component_image->colors; i++)
         object[top_objects[i].id].merge=MagickTrue;
       top_objects=(CCObjectInfo *) RelinquishMagickMemory(top_objects);
     }
   artifact=GetImageArtifact(image,"connected-components:perimeter-threshold");
   if (artifact != (const char *) NULL)
     {
       /*
         Merge any object not within the min and max perimeter threshold.
       */
       (void) sscanf(artifact,"%lf%*[ -]%lf",&min_threshold,&max_threshold);
       metric="perimeter";
       for (i=0; i < (ssize_t) component_image->colors; i++)
         object[i].metric=0.0;
       component_view=AcquireAuthenticCacheView(component_image,exception);
       object_view=AcquireVirtualCacheView(component_image,exception);
       for (i=0; i < (ssize_t) component_image->colors; i++)
       {
         register ssize_t
           j;
 
         /*
           Compute perimeter of each object.
         */
         if (status == MagickFalse)
           continue;
         bounding_box=object[i].bounding_box;
         for (y=0; y < (ssize_t) bounding_box.height; y++)
         {
           register const Quantum
             *magick_restrict p;
 
           register ssize_t
             x;
 
           if (status == MagickFalse)
             continue;
           p=GetCacheViewVirtualPixels(component_view,bounding_box.x,
             bounding_box.y+y,bounding_box.width,1,exception);
           if (p == (const Quantum *) NULL)
             {
               status=MagickFalse;
               continue;
             }
           for (x=0; x < (ssize_t) bounding_box.width; x++)
           {
             if (status == MagickFalse)
               continue;
             j=(ssize_t) GetPixelIndex(component_image,p);
             if (j == i)
               for (n=0; n < (ssize_t) 2; n++)
               {
                 register const Quantum
                   *p;
 
                 if (status == MagickFalse)
                   continue;
                 dx=connect4[n][1];
                 dy=connect4[n][0];
                 p=GetCacheViewVirtualPixels(object_view,bounding_box.x+x+dx,
                   bounding_box.y+y+dy,1,1,exception);
                 if (p == (const Quantum *) NULL)
                   {
                     status=MagickFalse;
                     break;
                   }
                 j=(ssize_t) GetPixelIndex(component_image,p);
                 if (j != i)
                   object[i].metric+=2;
               }
             p+=GetPixelChannels(component_image);
           }
         }
       }
       object_view=DestroyCacheView(object_view);
       component_view=DestroyCacheView(component_view);
       for (i=0; i < (ssize_t) component_image->colors; i++)
         if (((object[i].metric < min_threshold) ||
              (object[i].metric >= max_threshold)) && (i != background_id))
           object[i].merge=MagickTrue;
     }
   artifact=GetImageArtifact(image,"connected-components:remove-colors");
   if (artifact != (const char *) NULL)
     {
       register const char
         *p;
 
       /*
         Remove selected objects based on color, keep others.
       */
       for (p=artifact;  ; )
       {
         char
           color[MagickPathExtent];
 
         PixelInfo
           pixel;
 
         register const char
           *q;
 
         for (q=p; *q != '\0'; q++)
           if (*q == ';')
             break;
         (void) CopyMagickString(color,p,(size_t) MagickMin(q-p+1,
           MagickPathExtent));
         (void) QueryColorCompliance(color,AllCompliance,&pixel,exception);
         for (i=0; i < (ssize_t) component_image->colors; i++)
           if (IsFuzzyEquivalencePixelInfo(&object[i].color,&pixel) != MagickFalse)
             object[i].merge=MagickTrue;
         if (*q == '\0')
           break;
         p=q+1;
       }
     }
   artifact=GetImageArtifact(image,"connected-components:remove-ids");
   if (artifact == (const char *) NULL)
     artifact=GetImageArtifact(image,"connected-components:remove");
   if (artifact != (const char *) NULL)
     for (c=(char *) artifact; *c != '\0';)
     {
       /*
         Remove selected objects based on id, keep others.
       */
       while ((isspace((int) ((unsigned char) *c)) != 0) || (*c == ','))
         c++;
       first=(ssize_t) strtol(c,&c,10);
       if (first < 0)
         first+=(ssize_t) component_image->colors;
       last=first;
       while (isspace((int) ((unsigned char) *c)) != 0)
         c++;
       if (*c == '-')
         {
           last=(ssize_t) strtol(c+1,&c,10);
           if (last < 0)
             last+=(ssize_t) component_image->colors;
         }
       step=(ssize_t) (first > last ? -1 : 1);
       for ( ; first != (last+step); first+=step)
         object[first].merge=MagickTrue;
     }
   /*
     Merge any object not within the min and max area threshold.
   */
   component_view=AcquireAuthenticCacheView(component_image,exception);
   object_view=AcquireVirtualCacheView(component_image,exception);
   for (i=0; i < (ssize_t) component_image->colors; i++)
   {
     register ssize_t
       j;
 
     size_t
       id;
 
     if (status == MagickFalse)
       continue;
     if ((object[i].merge == MagickFalse) || (i == background_id))
       continue;  /* keep object */
     /*
       Merge this object.
     */
     for (j=0; j < (ssize_t) component_image->colors; j++)
       object[j].census=0;
     bounding_box=object[i].bounding_box;
     for (y=0; y < (ssize_t) bounding_box.height; y++)
     {
       register const Quantum
         *magick_restrict p;
 
       register ssize_t
         x;
 
       if (status == MagickFalse)
         continue;
       p=GetCacheViewVirtualPixels(component_view,bounding_box.x,
         bounding_box.y+y,bounding_box.width,1,exception);
       if (p == (const Quantum *) NULL)
         {
           status=MagickFalse;
           continue;
         }
       for (x=0; x < (ssize_t) bounding_box.width; x++)
       {
         if (status == MagickFalse)
           continue;
         j=(ssize_t) GetPixelIndex(component_image,p);
         if (j == i)
           for (n=0; n < (ssize_t) (connectivity > 4 ? 4 : 2); n++)
           {
             register const Quantum
               *p;
 
             /*
               Compute area of adjacent objects.
             */
             if (status == MagickFalse)
               continue;
             dx=connectivity > 4 ? connect8[n][1] : connect4[n][1];
             dy=connectivity > 4 ? connect8[n][0] : connect4[n][0];
             p=GetCacheViewVirtualPixels(object_view,bounding_box.x+x+dx,
               bounding_box.y+y+dy,1,1,exception);
             if (p == (const Quantum *) NULL)
               {
                 status=MagickFalse;
                 break;
               }
             j=(ssize_t) GetPixelIndex(component_image,p);
             if (j != i)
               object[j].census++;
           }
         p+=GetPixelChannels(component_image);
       }
     }
     /*
       Merge with object of greatest adjacent area.
     */
     id=0;
     for (j=1; j < (ssize_t) component_image->colors; j++)
       if (object[j].census > object[id].census)
         id=(size_t) j;
     object[id].area+=object[i].area;
     object[i].area=0.0;
     for (y=0; y < (ssize_t) bounding_box.height; y++)
     {
       register Quantum
         *magick_restrict q;
 
       register ssize_t
         x;
 
       if (status == MagickFalse)
         continue;
       q=GetCacheViewAuthenticPixels(component_view,bounding_box.x,
         bounding_box.y+y,bounding_box.width,1,exception);
       if (q == (Quantum *) NULL)
         {
           status=MagickFalse;
           continue;
         }
       for (x=0; x < (ssize_t) bounding_box.width; x++)
       {
         if ((ssize_t) GetPixelIndex(component_image,q) == i)
           SetPixelIndex(component_image,(Quantum) id,q);
         q+=GetPixelChannels(component_image);
       }
       if (SyncCacheViewAuthenticPixels(component_view,exception) == MagickFalse)
         status=MagickFalse;
     }
   }
   object_view=DestroyCacheView(object_view);
   component_view=DestroyCacheView(component_view);
   artifact=GetImageArtifact(image,"connected-components:mean-color");
   if (IsStringTrue(artifact) != MagickFalse)
     {
       /*
         Replace object with mean color.
       */
       for (i=0; i < (ssize_t) component_image->colors; i++)
         component_image->colormap[i]=object[i].color;
     }
   (void) SyncImage(component_image,exception);
   artifact=GetImageArtifact(image,"connected-components:verbose");
   if ((IsStringTrue(artifact) != MagickFalse) ||
       (objects != (CCObjectInfo **) NULL))
     {
       /*
         Report statistics on each unique object.
       */
       for (i=0; i < (ssize_t) component_image->colors; i++)
       {
         object[i].bounding_box.width=0;
         object[i].bounding_box.height=0;
         object[i].bounding_box.x=(ssize_t) component_image->columns;
         object[i].bounding_box.y=(ssize_t) component_image->rows;
         object[i].centroid.x=0;
         object[i].centroid.y=0;
         object[i].census=object[i].area == 0.0 ? 0.0 : 1.0;
         object[i].area=0;
       }
       component_view=AcquireVirtualCacheView(component_image,exception);
       for (y=0; y < (ssize_t) component_image->rows; y++)
       {
         register const Quantum
           *magick_restrict p;
 
         register ssize_t
           x;
 
         if (status == MagickFalse)
           continue;
         p=GetCacheViewVirtualPixels(component_view,0,y,component_image->columns,
           1,exception);
         if (p == (const Quantum *) NULL)
           {
             status=MagickFalse;
             continue;
           }
         for (x=0; x < (ssize_t) component_image->columns; x++)
         {
           size_t
             id;
 
           id=(size_t) GetPixelIndex(component_image,p);
           if (x < object[id].bounding_box.x)
             object[id].bounding_box.x=x;
           if (x > (ssize_t) object[id].bounding_box.width)
             object[id].bounding_box.width=(size_t) x;
           if (y < object[id].bounding_box.y)
             object[id].bounding_box.y=y;
           if (y > (ssize_t) object[id].bounding_box.height)
             object[id].bounding_box.height=(size_t) y;
           object[id].centroid.x+=x;
           object[id].centroid.y+=y;
           object[id].area++;
           p+=GetPixelChannels(component_image);
         }
       }
       for (i=0; i < (ssize_t) component_image->colors; i++)
       {
         object[i].bounding_box.width-=(object[i].bounding_box.x-1);
         object[i].bounding_box.height-=(object[i].bounding_box.y-1);
         object[i].centroid.x=object[i].centroid.x/object[i].area;
         object[i].centroid.y=object[i].centroid.y/object[i].area;
       }
       component_view=DestroyCacheView(component_view);
       qsort((void *) object,component_image->colors,sizeof(*object),
         CCObjectInfoCompare);
       if (objects == (CCObjectInfo **) NULL)
         {
           artifact=GetImageArtifact(image,
             "connected-components:exclude-header");
           if (IsStringTrue(artifact) == MagickFalse)
             {
-              (void) fprintf(stdout,"Objects (id: bounding-box centroid area");
+              (void) fprintf(stdout,
+                "Objects (id: bounding-box centroid area mean-color");
               if (*metric != '\0')
                 (void) fprintf(stdout," %s",metric);
-              (void) fprintf(stdout," mean-color):\n");
+              (void) fprintf(stdout,"):\n");
             }
           for (i=0; i < (ssize_t) component_image->colors; i++)
             if (object[i].census > 0.0)
               {
                 char
                   mean_color[MagickPathExtent];
 
                 GetColorTuple(&object[i].color,MagickFalse,mean_color);
                 (void) fprintf(stdout,
-                  "  %.20g: %.20gx%.20g%+.20g%+.20g %.1f,%.1f %.20g",
+                  "  %.20g: %.20gx%.20g%+.20g%+.20g %.1f,%.1f %.20g %s",
                   (double) object[i].id,(double) object[i].bounding_box.width,
                   (double) object[i].bounding_box.height,(double)
                   object[i].bounding_box.x,(double) object[i].bounding_box.y,
                   object[i].centroid.x,object[i].centroid.y,(double)
-                  object[i].area);
+                  object[i].area,mean_color);
                 if (*metric != '\0')
                   (void) fprintf(stdout," %.20g",object[i].metric);
-                (void) fprintf(stdout," %s\n",mean_color);
+                (void) fprintf(stdout,"\n");
               }
         }
     }
   if (objects == (CCObjectInfo **) NULL)
     object=(CCObjectInfo *) RelinquishMagickMemory(object);
   else
     *objects=object;
   return(component_image);
 }
