commit df740b5ebcccb9b46bed8c4f6f8e9b04b3e4441c
Author: Mallikarjun Kamble <mallikarjun.kamble@ittiam.com>
Date:   Fri Dec 8 15:46:42 2023 +0530

    Added fixes for hang

diff --git a/decoder/svc/isvcd_api.c b/decoder/svc/isvcd_api.c
index 6fd595c..5adfbb1 100644
--- a/decoder/svc/isvcd_api.c
+++ b/decoder/svc/isvcd_api.c
@@ -4719,1035 +4719,1034 @@ WORD32 isvcd_pre_parse_refine_au(svc_dec_ctxt_t *ps_svcd_ctxt, ivd_video_decode_
 WORD32 isvcd_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
     dec_struct_t *ps_dec;
     dec_struct_t *ps_dec_zero_lyr;
     svc_dec_lyr_struct_t *ps_svc_lyr_dec;
     svc_dec_lyr_struct_t *ps_svc_lyr_zero_dec;
 
     svc_dec_ctxt_t *ps_svcd_ctxt;
     WORD32 i4_err_status = 0;
 
     UWORD32 bytes_consumed = 0;
     WORD32 ret = 0, api_ret_value = IV_SUCCESS;
     isvcd_video_decode_ip_t *ps_h264d_dec_ip;
     isvcd_video_decode_op_t *ps_h264d_dec_op;
     ivd_video_decode_ip_t *ps_dec_ip;
     ivd_video_decode_op_t *ps_dec_op;
     UWORD8 u1_res_id;
 
     ithread_set_name((void *) "Parse_thread");
 
     ps_svcd_ctxt = (svc_dec_ctxt_t *) (dec_hdl->pv_codec_handle);
     ps_svc_lyr_dec = &ps_svcd_ctxt->ps_svc_dec_lyr[0];
     ps_dec = &ps_svc_lyr_dec->s_dec;
 
     ps_h264d_dec_ip = (isvcd_video_decode_ip_t *) pv_api_ip;
     ps_h264d_dec_op = (isvcd_video_decode_op_t *) pv_api_op;
     ps_dec_ip = &ps_h264d_dec_ip->s_ivd_video_decode_ip_t;
     ps_dec_op = &ps_h264d_dec_op->s_ivd_video_decode_op_t;
 
     {
         UWORD32 u4_size;
         u4_size = ps_dec_op->u4_size;
         memset(ps_h264d_dec_op, 0, sizeof(isvcd_video_decode_op_t));
         ps_dec_op->u4_size = u4_size;
     }
 
     ps_dec->pv_dec_out = ps_dec_op;
     if(ps_dec->init_done != 1)
     {
         return IV_FAIL;
     }
 
     /*Data memory barries instruction,so that bitstream write by the application
      * is complete*/
     DATA_SYNC();
 
     if(0 == ps_dec->u1_flushfrm)
     {
         if(ps_dec_ip->pv_stream_buffer == NULL)
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
             return IV_FAIL;
         }
         if(ps_dec_ip->u4_num_Bytes <= 16)
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
             return IV_FAIL;
         }
     }
 #ifdef KEEP_THREADS_ACTIVE
     {
         UWORD32 i;
         ps_dec->i4_break_threads = 0;
         for(i = 0; i < 2; i++)
         {
             ret = ithread_mutex_lock(ps_dec->apv_proc_start_mutex[i]);
             RETURN_IF((ret != IV_SUCCESS), ret);
 
             ps_dec->ai4_process_start[i] = PROC_INIT;
 
             ret = ithread_mutex_unlock(ps_dec->apv_proc_start_mutex[i]);
             RETURN_IF((ret != IV_SUCCESS), ret);
         }
     }
 #else
     ps_dec->u4_dec_thread_created = 0;
     ps_dec->u4_bs_deblk_thread_created = 0;
 #endif
     ps_dec_op->u4_num_bytes_consumed = 0;
     ps_dec_op->i4_reorder_depth = -1;
     ps_dec_op->i4_display_index = DEFAULT_POC;
 
     ps_dec->ps_out_buffer = NULL;
     if(ps_dec_ip->u4_size >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
         ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
 
     if(0 == ps_dec->u4_share_disp_buf && ps_dec->i4_decode_header == 0)
     {
         UWORD32 i;
         if((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||
            (ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
             return IV_FAIL;
         }
 
         for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
         {
             if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
             {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
                 return IV_FAIL;
             }
 
             if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
             {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                 return IV_FAIL;
             }
         }
     }
 
     if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
     {
         ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
         return IV_FAIL;
     }
 
     ps_dec_op->u4_error_code = 0;
     ps_dec_op->e_pic_type = IV_NA_FRAME;
     ps_dec_op->u4_output_present = 0;
     ps_dec_op->u4_frame_decoded_flag = 0;
 
     /* In case the decoder is not in flush mode(in shared mode),
      then decoder has to pick up a buffer to write current frame.
      Check if a frame is available in such cases */
     if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1 && ps_dec->u1_flushfrm == 0)
     {
         UWORD32 i;
         WORD32 disp_avail = 0, free_id;
 
         /* Check if at least one buffer is available with the codec */
         /* If not then return to application with error */
         for(i = 0; i < ps_dec->u1_pic_bufs; i++)
         {
             if(0 == ps_dec->u4_disp_buf_mapping[i] || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
             {
                 disp_avail = 1;
                 break;
             }
         }
 
         if(0 == disp_avail)
         {
             /* If something is queued for display wait for that buffer to be returned
              */
 
             ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
             ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
             return (IV_FAIL);
         }
 
         while(1)
         {
             pic_buffer_t *ps_pic_buf;
             ps_pic_buf = (pic_buffer_t *) ih264_buf_mgr_get_next_free(
                 (buf_mgr_t *) ps_dec->pv_pic_buf_mgr, &free_id);
 
             if(ps_pic_buf == NULL)
             {
                 UWORD32 display_queued = 0;
 
                 /* check if any buffer was given for display which is not returned yet */
                 for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
                 {
                     if(0 != ps_dec->u4_disp_buf_mapping[i])
                     {
                         display_queued = 1;
                         break;
                     }
                 }
                 /* If some buffer is queued for display, then codec has to singal an
                  error and wait for that buffer to be returned. If nothing is queued for
                  display then codec has ownership of all display buffers and it can
                  reuse any of the existing buffers and continue decoding */
 
                 if(1 == display_queued)
                 {
                     /* If something is queued for display wait for that buffer to be
                      * returned */
                     ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                     ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
                     return (IV_FAIL);
                 }
             }
             else
             {
                 /* If the buffer is with display, then mark it as in use and then look
                  * for a buffer again */
                 if(1 == ps_dec->u4_disp_buf_mapping[free_id])
                 {
                     ih264_buf_mgr_set_status((buf_mgr_t *) ps_dec->pv_pic_buf_mgr, free_id,
                                              BUF_MGR_IO);
                 }
                 else
                 {
                     /**
                      *  Found a free buffer for present call. Release it now.
                      *  Will be again obtained later.
                      */
                     ih264_buf_mgr_release((buf_mgr_t *) ps_dec->pv_pic_buf_mgr, free_id,
                                           BUF_MGR_IO);
                     break;
                 }
             }
         }
     }
 
     if(ps_dec->u1_enable_mb_info && (ps_dec->i4_header_decoded & DECODED_SPS_MASK))
     {
         UWORD32 blk_qp_map_size = ps_h264d_dec_ip->u4_8x8_blk_qp_map_size;
         UWORD32 blk_type_map_size = ps_h264d_dec_ip->u4_8x8_blk_type_map_size;
         UWORD32 blk_8x8_map_size = ps_dec->u4_total_mbs << 2;
         if((ps_h264d_dec_ip->pu1_8x8_blk_qp_map && blk_qp_map_size < blk_8x8_map_size) ||
            (ps_h264d_dec_ip->pu1_8x8_blk_type_map && blk_type_map_size < blk_8x8_map_size))
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IH264D_INSUFFICIENT_METADATA_BUFFER;
             return IV_FAIL;
         }
     }
 
     if(ps_dec->u1_flushfrm && (1 == ps_svcd_ctxt->u1_pre_parse_in_flush))
     {
         if(ps_dec->u1_init_dec_flag == 0)
         {
             ps_dec->u1_flushfrm = 0;
             return (IV_FAIL);
         }
 
         ps_svc_lyr_dec = &ps_svcd_ctxt->ps_svc_dec_lyr[ps_svcd_ctxt->s_vcl_nal.i4_num_res_lyrs - 1];
         ps_dec = &ps_svc_lyr_dec->s_dec;
         ps_dec->u4_fmt_conv_cur_row = 0;
         ps_dec->u4_output_present = 0;
         ps_dec->s_disp_op.u4_error_code = 1;
 
         ps_dec->ps_out_buffer = NULL;
         if(ps_dec_ip->u4_size >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
         {
             ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
         }
         ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer, &(ps_dec->s_disp_op));
         if(0 == ps_dec->s_disp_op.u4_error_code)
         {
             /* check output buffer size given by the application */
             if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)
             {
                 ps_dec_op->u4_error_code = IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                 return (IV_FAIL);
             }
 
             ps_dec->u4_fmt_conv_cur_row = 0;
             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op), ps_dec->u4_fmt_conv_cur_row,
                                   ps_dec->u4_fmt_conv_num_rows);
             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
             ps_dec->u4_output_present = 1;
             if(ps_dec->u1_enable_mb_info)
             {
                 UWORD32 disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
                 if(ps_h264d_dec_ip->pu1_8x8_blk_qp_map)
                 {
                     ps_h264d_dec_op->pu1_8x8_blk_qp_map = ps_h264d_dec_ip->pu1_8x8_blk_qp_map;
                     ps_h264d_dec_op->u4_8x8_blk_qp_map_size = ps_dec->u4_total_mbs << 2;
                     ih264_memcpy(ps_h264d_dec_op->pu1_8x8_blk_qp_map,
                                  ps_dec->as_buf_id_info_map[disp_buf_id].pu1_qp_map,
                                  ps_dec->u4_total_mbs << 2);
                 }
                 if(ps_h264d_dec_ip->pu1_8x8_blk_type_map)
                 {
                     ps_h264d_dec_op->pu1_8x8_blk_type_map = ps_h264d_dec_ip->pu1_8x8_blk_type_map;
                     ps_h264d_dec_op->u4_8x8_blk_type_map_size = ps_dec->u4_total_mbs << 2;
                     ih264_memcpy(ps_h264d_dec_op->pu1_8x8_blk_type_map,
                                  ps_dec->as_buf_id_info_map[disp_buf_id].pu1_mb_type_map,
                                  ps_dec->u4_total_mbs << 2);
                 }
             }
         }
         ih264d_export_sei_params(&ps_dec_op->s_sei_decode_op, ps_dec);
 
         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 
         ps_dec_op->u4_pic_wd = (UWORD32) ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32) ps_dec->u2_disp_height;
         ps_dec_op->i4_reorder_depth = ps_dec->i4_reorder_depth;
         ps_dec_op->i4_display_index = ps_dec->i4_display_index;
         ps_dec_op->u4_new_seq = 0;
 
         ps_dec_op->u4_output_present = ps_dec->u4_output_present;
         ps_dec_op->u4_progressive_frame_flag = ps_dec->s_disp_op.u4_progressive_frame_flag;
         ps_dec_op->e_output_format = ps_dec->s_disp_op.e_output_format;
         ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
         ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
         ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
         ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
 
         /*In the case of flush ,since no frame is decoded set pic type as invalid*/
         ps_dec_op->u4_is_ref_flag = UINT32_MAX;
         ps_dec_op->e_pic_type = IV_NA_FRAME;
         ps_dec_op->u4_frame_decoded_flag = 0;
 
         if(0 == ps_dec->s_disp_op.u4_error_code)
         {
             return (IV_SUCCESS);
         }
         else
             return (IV_FAIL);
     }
 
     if(ps_dec->u1_res_changed == 1)
     {
         /*if resolution has changed and all buffers have been flushed, reset
          * decoder*/
         if(((buf_mgr_t *) ps_dec->pv_pic_buf_mgr)->pv_mutex != NULL)
             ih264_buf_mgr_free(ps_dec->pv_pic_buf_mgr);
         if(((buf_mgr_t *) ps_dec->pv_mv_buf_mgr)->pv_mutex != NULL)
             ih264_buf_mgr_free(ps_dec->pv_mv_buf_mgr);
 
         isvcd_init_decoder(ps_svc_lyr_dec);
     }
 
     DEBUG_THREADS_PRINTF(" Starting process call\n");
 
     {
         vcl_node_t *ps_cur_node;
         UWORD8 u1_num_res_lyrs;
         vcl_buf_hdr_t *ps_vcl_buf;
         UWORD8 flush_decode = 1;
         ps_svcd_ctxt->u1_pre_parse_in_flush = 0;
 
         ret = isvcd_pre_parse_refine_au(ps_svcd_ctxt, ps_dec_ip, &ps_dec_op->u4_num_bytes_consumed);
         ps_svcd_ctxt->u1_pre_parse_in_flush = (ret == FLUSH);
 
         if(ret != OK)
         {
             UWORD32 error = ih264d_map_error((UWORD32) ret);
             if(ret != NOT_OK)
             {
                 ps_dec_op->u4_error_code = error | ret;
             }
             if((ps_dec_op->u4_error_code >> IVD_FATALERROR) & 1)
             {
                 ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
             }
             api_ret_value = IV_FAIL;
             if((ret == IVD_RES_CHANGED) || (ret == IVD_MEM_ALLOC_FAILED) ||
                (ret == ERROR_UNAVAIL_PICBUF_T) || (ret == ERROR_UNAVAIL_MVBUF_T) ||
                (ret == ERROR_INV_SPS_PPS_T) || (ret == ERROR_FEATURE_UNAVAIL) ||
                (ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED) ||
                (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))
             {
                 ps_dec->u4_slice_start_code_found = 0;
             }
             if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
             {
                 api_ret_value = IV_FAIL;
             }
 
             if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
             {
                 api_ret_value = IV_FAIL;
             }
         }
 
         if(NOT_OK == ret)
         {
             if(ps_dec->u4_pic_buf_got == 0)
             {
                 ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                 ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;
 
                 isvcd_fill_output_struct_from_context(ps_svc_lyr_dec, ps_dec_op);
 
                 ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                 ps_dec_op->u4_frame_decoded_flag = 0;
                 return (IV_FAIL);
             }
             return (IV_SUCCESS);
         }
 
         u1_num_res_lyrs = ps_svcd_ctxt->s_vcl_nal.i4_num_res_lyrs;
 
         /* error concelment: exit till next IDR if any of Non Target layers are
          * corrupted */
         {
             ps_cur_node = ps_svcd_ctxt->s_vcl_nal.ps_bot_node;
 
             if(NULL != ps_cur_node)
             {
                 if(!ps_cur_node->i4_idr_pic_flag)
                 {
                     if(u1_num_res_lyrs != ps_svcd_ctxt->u1_prev_num_res_layers)
                     {
                         ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                         ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                         return IV_FAIL;
                     }
                 }
                 else
                 {
                     if(u1_num_res_lyrs != ps_svcd_ctxt->u1_prev_num_res_layers)
                     {
                         ps_svcd_ctxt->u1_prev_num_res_layers = u1_num_res_lyrs;
                     }
                 }
             }
         }
         if(ps_svcd_ctxt->u1_prev_num_res_layers != u1_num_res_lyrs && (u1_num_res_lyrs != 0))
         {
             ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_num_res_lyrs - 1;
             ps_dec = &ps_svc_lyr_dec->s_dec;
 
             if(ps_dec->u1_init_dec_flag == 1)
             {
                 ih264d_release_pics_in_dpb((void *) ps_dec, ps_dec->u1_pic_bufs);
                 ih264d_release_display_bufs(ps_dec);
                 ih264_disp_mgr_init((disp_mgr_t *) ps_dec->pv_disp_buf_mgr);
 
                 ih264_buf_mgr_reset(ps_dec->pv_pic_buf_mgr);
                 ih264_buf_mgr_reset(ps_dec->pv_mv_buf_mgr);
                 ih264d_init_ref_bufs(ps_dec->ps_dpb_mgr);
             }
 
             // ps_svcd_ctxt->u1_prev_num_res_layers = u1_num_res_lyrs;
         }
         ps_svcd_ctxt->u1_parse_nal_unit_error = 0;
 
         if((1 == ps_svcd_ctxt->u1_exit_till_next_IDR) &&
            (ps_svcd_ctxt->s_vcl_nal.ps_bot_node != NULL))
         {
             if(1 == ps_svcd_ctxt->s_vcl_nal.ps_bot_node->i4_idr_pic_flag)
             {
                 ps_svcd_ctxt->u1_exit_till_next_IDR = 0;
 
                 for(u1_res_id = 0; u1_res_id < u1_num_res_lyrs; u1_res_id++)
                 {
                     ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_res_id;
                     ps_dec = &ps_svc_lyr_dec->s_dec;
                     ih264_buf_mgr_reset(ps_dec->pv_pic_buf_mgr);
                     ih264_buf_mgr_reset(ps_dec->pv_mv_buf_mgr);
                 }
             }
             else
             {
                 ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                 return IV_FAIL;
             }
         }
 
         if((0 == ps_dec->i4_decode_header) && (OK == ret))
         {
             flush_decode = 0;
             ps_cur_node = ps_svcd_ctxt->s_vcl_nal.ps_bot_node;
             ps_svc_lyr_zero_dec = ps_svcd_ctxt->ps_svc_dec_lyr;
             ps_dec_zero_lyr = &ps_svc_lyr_zero_dec->s_dec;
             /* master loop */
 
             for(u1_res_id = 0; u1_res_id < u1_num_res_lyrs; u1_res_id++)
             {
                 UWORD8 u1_layer_nal_data_present = 0;
                 ps_svcd_ctxt->u1_cur_layer_id = u1_res_id;
                 ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_res_id;
                 ps_svc_lyr_dec->u1_res_init_done = 0;
-                ps_svc_lyr_dec->u1_first_mb_addr_check = 1;
                 ps_dec = &ps_svc_lyr_dec->s_dec;
 
                 ps_dec->i4_decode_header = ps_dec_zero_lyr->i4_decode_header;
                 ps_dec->i4_header_decoded = ps_dec_zero_lyr->i4_header_decoded;
                 ps_dec->u1_pic_decode_done = 0;
                 ps_dec->u4_fmt_conv_cur_row = 0;
 
                 ps_dec->u4_output_present = 0;
                 ps_dec->s_disp_op.u4_error_code = 1;
                 ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
                 ps_dec->u4_ts = ps_dec_ip->u4_ts;
                 ps_dec->i4_frametype = IV_NA_FRAME;
                 ps_dec->i4_content_type = IV_CONTENTTYPE_NA;
 
                 ps_dec->u4_slice_start_code_found = 0;
                 ps_dec->u2_cur_mb_addr = 0;
                 ps_dec->u2_total_mbs_coded = 0;
                 ps_dec->u2_cur_slice_num = 0;
                 ps_dec->cur_dec_mb_num = 0;
                 ps_dec->cur_recon_mb_num = 0;
                 ps_dec->u4_first_slice_in_pic = 1;
                 ps_dec->u1_slice_header_done = 0;
                 ps_dec->u1_dangling_field = 0;
 
                 ps_dec->u4_dec_thread_created = 0;
                 ps_dec->u4_bs_deblk_thread_created = 0;
                 ps_dec->u4_cur_bs_mb_num = 0;
                 ps_dec->u4_cur_deblk_mb_num = 0;
                 ps_dec->u4_start_recon_deblk = 0;
                 ps_dec->u4_sps_cnt_in_process = 0;
                 ps_dec->u4_pic_buf_got = 0;
                 ps_dec->pv_dec_out = ps_dec_op;
 
                 if(ps_dec_ip->u4_size >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
                     ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
 
                 ps_dec->u1_nal_unit_type = ps_cur_node->i4_nal_unit_type;
                 ps_dec->u1_separate_parse = 0;
                 if(u1_res_id == (u1_num_res_lyrs - 1))
                 {
                     ps_svc_lyr_dec->u1_layer_identifier = TARGET_LAYER;
                     if(ps_dec->u4_num_cores >= 2)
                     {
                         ps_dec->u4_num_cores = 2;
                         ps_dec->u1_separate_parse = 1;
                     }
                 }
                 else if(u1_res_id == 0)
                 {
                     ps_svc_lyr_dec->u1_layer_identifier = BASE_LAYER;
                     ps_dec->u1_separate_parse = 0;
                     ps_dec->u4_num_cores = 1;
                 }
                 else if(u1_res_id != 0)
                 {
                     ps_svc_lyr_dec->u1_layer_identifier = MEDIAL_ENHANCEMENT_LAYER;
                     ps_dec->u1_separate_parse = 0;
                     ps_dec->u4_num_cores = 1;
                 }
                 else
                 {
                     return IV_FAIL;
                 }
 
                 ps_svc_lyr_dec->u1_base_res_flag = (0 == u1_res_id);
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_idr_flag = ps_cur_node->i4_idr_pic_flag;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_dependency_id = ps_cur_node->i4_dependency_id;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_priority_id = ps_cur_node->i4_priority_id;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_no_inter_layer_pred_flag =
                     ps_cur_node->u1_acc_no_int_pred;
 
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_quality_id = ps_cur_node->i4_quality_id;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_temporal_id = ps_cur_node->i4_temporal_id;
 
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_use_ref_base_pic_flag =
                     ps_cur_node->i4_use_ref_base;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_discardable_flag = 0;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_svc_ext_flag = (u1_res_id > 1);
                 ps_svc_lyr_dec->u4_pps_id_for_layer = UINT32_MAX;
                 ps_vcl_buf = ps_cur_node->ps_first_vcl_nal;
                 ps_svc_lyr_dec->u1_error_in_cur_frame = 0;
 
                 /* Only for Non target Layers*/
                 if(NULL != ps_cur_node->ps_top_node)
                 {
                     ps_svc_lyr_dec->u1_inter_lyr_disable_dblk_filter_idc =
                         ps_cur_node->ps_top_node->i4_inter_lyr_dblk_idc;
                     ps_svc_lyr_dec->i1_inter_lyr_slice_alpha_c0_offset =
                         ps_cur_node->ps_top_node->i4_inter_lyr_alpha_c0_offset;
                     ps_svc_lyr_dec->i1_inter_lyr_slice_beta_offset =
                         ps_cur_node->ps_top_node->i4_inter_lyr_beta_offset;
                 }
 
                 while(NULL != ps_vcl_buf)
                 {
                     u1_layer_nal_data_present = 1;
                     ps_dec->ps_bitstrm->u4_ofst = 0;
                     ps_dec->ps_bitstrm->pu4_buffer =
                         (UWORD32 *) ((UWORD8 *) ps_vcl_buf + ps_vcl_buf->i4_buf_offset +
                                      ps_vcl_buf->i4_slice_offset);
 
                     ps_dec->ps_bitstrm->u4_max_ofst = ps_vcl_buf->u4_max_bits;
 
                     ps_dec_op->u4_frame_decoded_flag = 0;
                     ret = isvcd_parse_nal_unit(ps_svc_lyr_dec, ps_cur_node->i4_nal_ref_idc);
                     if(ret != OK)
                     {
                         ps_svcd_ctxt->u1_parse_nal_unit_error = 1;
                         break;
                     }
 
                     /* go to the next slice */
                     ps_vcl_buf = ps_vcl_buf->ps_next;
                 }
                 /* error concelment: exit till next IDR if a Layer data is missing */
                 if(0 == u1_layer_nal_data_present)
                 {
                     ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                     ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                     return IV_FAIL;
                 }
                 /* error concelment: exit till next IDR if any of Non Target layers are
                  * corrupted */
                 if((ret != OK) && (u1_res_id != (u1_num_res_lyrs - 1)))
                 {
                     ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                     ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                     return IV_FAIL;
                 }
 
                 if((ret != OK) && (u1_res_id == (u1_num_res_lyrs - 1)))
                 {
                     ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_num_res_lyrs - 1;
                     ps_dec = &ps_svc_lyr_dec->s_dec;
 
                     if((0 == ps_svcd_ctxt->u4_num_sps_ctr) || (0 == ps_svcd_ctxt->u4_num_pps_ctr) ||
                        (NULL == ps_dec->ps_cur_pps) || (ps_svc_lyr_dec->u1_res_init_done == 0))
                     {
                         ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                         ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                         ih264d_signal_decode_thread(ps_dec);
                         return IV_FAIL;
                     }
                 }
                 ps_cur_node = ps_cur_node->ps_top_node;
 
                 if((ps_dec->u4_pic_buf_got == 1) && (ret != IVD_MEM_ALLOC_FAILED) &&
                    ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
                 {
                     // last slice - missing/corruption
                     WORD32 num_mb_skipped;
                     WORD32 prev_slice_err;
                     pocstruct_t temp_poc;
                     WORD32 ret1;
                     WORD32 ht_in_mbs;
                     ht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);
                     num_mb_skipped =
                         (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs) - ps_dec->u2_total_mbs_coded;
 
                     if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
                         prev_slice_err = 1;
                     else
                         prev_slice_err = 2;
 
                     if(ps_dec->u2_total_mbs_coded == 0)
                     {
                         prev_slice_err = 1;
                     }
                     ret1 = isvcd_mark_err_slice_skip(
                         ps_svc_lyr_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL,
                         ps_dec->ps_cur_slice->u2_frame_num, &temp_poc, prev_slice_err);
 
                     if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||
                        (ret1 == ERROR_INV_SPS_PPS_T) || (ret1 == ERROR_CORRUPTED_SLICE) ||
                        (ret == NOT_OK))
                     {
                         ret = ret1;
                     }
                 }
 
                 if((ret == IVD_RES_CHANGED) || (ret == IVD_MEM_ALLOC_FAILED) ||
                    (ret == ERROR_UNAVAIL_PICBUF_T) || (ret == ERROR_UNAVAIL_MVBUF_T) ||
                    (ret == ERROR_INV_SPS_PPS_T) || (ret == ERROR_CORRUPTED_SLICE) ||
                    (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE) || (ret == NOT_OK))
                 {
                     ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                     /* signal the decode thread */
                     ih264d_signal_decode_thread(ps_dec);
                     /* dont consume bitstream for change in resolution case */
                     if(ret == IVD_RES_CHANGED)
                     {
                         ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                     }
                     return IV_FAIL;
                 }
 
                 /* Multi thread - for target Layer decoding*/
                 if((ps_dec->u1_separate_parse) &&
                    (ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER) &&
                    (0 == ps_svc_lyr_dec->u1_error_in_cur_frame))
                 {
                     /* If Format conversion is not complete,
                      complete it here */
                     if(ps_dec->u4_num_cores == 2)
                     {
                         /*do deblocking of all mbs*/
                         if((ps_dec->u4_nmb_deblk == 0) && (ps_dec->u4_start_recon_deblk == 1) &&
                            (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
                         {
                             UWORD8 u1_end_of_row = 0;
                             UWORD32 u4_max_addr;
                             tfr_ctxt_t s_tfr_ctxt = {0};
                             tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
                             pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;
                             UWORD32 u4_slice_end = 0;
 
                             /*BS is done for all mbs while parsing*/
                             u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                             /* BS is moved post recon gen in SVC ext*/
 
                             ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                                        ps_dec->u2_frm_wd_in_mbs, 0);
 
                             {
                                 while(u4_slice_end != 1)
                                 {
                                     dec_mb_info_t *p_cur_mb;
                                     WORD32 i, bs_mb_grp;
                                     bs_mb_grp = ps_dec->cur_dec_mb_num - ps_dec->u4_cur_bs_mb_num;
 
                                     for(i = 0; i < bs_mb_grp; i++)
                                     {
                                         p_cur_mb =
                                             &ps_dec->ps_frm_mb_info[ps_dec->u4_cur_bs_mb_num];
 
                                         DEBUG_THREADS_PRINTF("ps_dec->u4_cur_bs_mb_num = %d\n",
                                                              ps_dec->u4_cur_bs_mb_num);
                                         isvcd_compute_bs_non_mbaff_thread(ps_svc_lyr_dec, p_cur_mb,
                                                                           ps_dec->u4_cur_bs_mb_num);
 
                                         ps_dec->u4_cur_bs_mb_num++;
                                         ps_dec->u4_bs_cur_slice_num_mbs++;
                                     }
                                     if(ps_dec->u4_cur_bs_mb_num > u4_max_addr)
                                     {
                                         u4_slice_end = 1;
                                         u1_end_of_row = 1;
                                     }
                                     /*deblock MB group*/
                                     {
                                         UWORD32 u4_num_mbs;
 
                                         if(ps_dec->u4_cur_bs_mb_num > ps_dec->u4_cur_deblk_mb_num)
                                         {
                                             if(u1_end_of_row)
                                             {
                                                 u4_num_mbs = ps_dec->u4_cur_bs_mb_num -
                                                              ps_dec->u4_cur_deblk_mb_num;
                                             }
                                             else
                                             {
                                                 u4_num_mbs = ps_dec->u4_cur_bs_mb_num -
                                                              ps_dec->u4_cur_deblk_mb_num - 1;
                                             }
                                         }
                                         else
                                             u4_num_mbs = 0;
 
                                         ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs, ps_tfr_cxt,
                                                                   0);
                                     }
                                 }
                             }
                         }
                     }
 
                     /*signal the decode thread*/
                     ih264d_signal_decode_thread(ps_dec);
                 }
                 else if((ps_dec->u1_separate_parse) &&
                         (ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER))
                 {
                     /*signal the decode thread*/
                     ih264d_signal_decode_thread(ps_dec);
                 }
 
                 DATA_SYNC();
 
                 if((ps_dec_op->u4_error_code & 0xff) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
                 {
                     ps_dec_op->u4_pic_wd = (UWORD32) ps_dec->u2_disp_width;
                     ps_dec_op->u4_pic_ht = (UWORD32) ps_dec->u2_disp_height;
                     ps_dec_op->i4_reorder_depth = ps_dec->i4_reorder_depth;
                 }
 
                 // Report if header (sps and pps) has not been decoded yet
                 if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
                 {
                     ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);
                     api_ret_value = IV_FAIL;
                 }
 
                 if((ps_dec->u4_pic_buf_got == 1) && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
                 {
                     /* For field pictures, set bottom and top picture decoded u4_flag correctly */
 
                     if(ps_dec->ps_cur_slice->u1_field_pic_flag)
                     {
                         if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
                         {
                             ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
                         }
                         else
                         {
                             ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
                         }
                     }
                     else
                     {
                         ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
                     }
 
                     /* if new frame in not found (if we are still getting slices from
                      * previous frame) ih264d_deblock_display is not called. Such frames
                      * will not be added to reference /display
                      */
                     if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
                     {
                         /* Calling Function to deblock Picture and Display */
                         ret = ih264d_deblock_display(ps_dec);
                     }
 
                     /*set to complete ,as we dont support partial frame decode*/
                     if(ps_dec->i4_header_decoded == 3)
                     {
                         ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
                     }
 
                     /*Update the i4_frametype at the end of picture*/
                     if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
                     {
                         ps_dec->i4_frametype = IV_IDR_FRAME;
                     }
                     else if(ps_dec->i4_pic_type == B_SLICE)
                     {
                         ps_dec->i4_frametype = IV_B_FRAME;
                     }
                     else if(ps_dec->i4_pic_type == P_SLICE)
                     {
                         ps_dec->i4_frametype = IV_P_FRAME;
                     }
                     else if(ps_dec->i4_pic_type == I_SLICE)
                     {
                         ps_dec->i4_frametype = IV_I_FRAME;
                     }
                     else
                     {
                         H264_DEC_DEBUG_PRINT("Shouldn't come here\n");
                     }
 
                     // Update the content type
                     ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;
 
                     ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
                     ps_dec->u4_total_frames_decoded =
                         ps_dec->u4_total_frames_decoded - ps_dec->ps_cur_slice->u1_field_pic_flag;
                 }
 
                 /* In case the decoder is configured to run in low delay mode,
                  * then get display buffer and then format convert.
                  * Note in this mode, format conversion does not run paralelly in a
                  * thread and adds to the codec cycles
                  */
                 if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode) && ps_dec->u1_init_dec_flag)
                 {
                     ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
                                                   &(ps_dec->s_disp_op));
 
                     if(0 == ps_dec->s_disp_op.u4_error_code)
                     {
                         ps_dec->u4_fmt_conv_cur_row = 0;
                         ps_dec->u4_output_present = 1;
                     }
                     else
                     {
                         ps_dec->u4_output_present = 0;
                     }
                 }
 
                 isvcd_fill_output_struct_from_context(ps_svc_lyr_dec, ps_dec_op);
 
                 /* If Format conversion is not complete,
                  complete it here */
                 /* For Non -target Layers , Buffers are retrived but not displayed*/
 
                 if((ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER) &&
                    ps_dec->u4_output_present &&
                    (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
                 {
                     ps_dec->u4_fmt_conv_num_rows =
                         ps_dec->s_disp_frame_info.u4_y_ht - ps_dec->u4_fmt_conv_cur_row;
                     ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op), ps_dec->u4_fmt_conv_cur_row,
                                           ps_dec->u4_fmt_conv_num_rows);
                     ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
                 }
 
                 ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 
                 if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
                 {
                     ps_dec_op->u4_progressive_frame_flag = 1;
                     if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
                     {
                         if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag) &&
                            (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                             ps_dec_op->u4_progressive_frame_flag = 0;
                     }
                 }
 
                 if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
                 {
                     ps_dec->u1_top_bottom_decoded = 0;
                 }
                 /*--------------------------------------------------------------------*/
                 /* Do End of Pic processing.                                          */
                 /* Should be called only if frame was decoded in previous process call*/
                 /*--------------------------------------------------------------------*/
                 if(ps_dec->u4_pic_buf_got == 1)
                 {
                     if(1 == ps_dec->u1_last_pic_not_decoded)
                     {
                         ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);
 
                         if(ret != OK) return ret;
 
                         ret = ih264d_end_of_pic(ps_dec);
                         if(ret != OK) return ret;
                     }
                     else
                     {
                         ret = ih264d_end_of_pic(ps_dec);
                         if(ret != OK) return ret;
                     }
                 }
 
                 if(ps_dec->u1_enable_mb_info && ps_dec->u4_output_present)
                 {
                     UWORD32 disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
                     if(ps_h264d_dec_ip->pu1_8x8_blk_qp_map)
                     {
                         ps_h264d_dec_op->pu1_8x8_blk_qp_map = ps_h264d_dec_ip->pu1_8x8_blk_qp_map;
                         ps_h264d_dec_op->u4_8x8_blk_qp_map_size = ps_dec->u4_total_mbs << 2;
                         ih264_memcpy(ps_h264d_dec_op->pu1_8x8_blk_qp_map,
                                      ps_dec->as_buf_id_info_map[disp_buf_id].pu1_qp_map,
                                      ps_dec->u4_total_mbs << 2);
                     }
                     if(ps_h264d_dec_ip->pu1_8x8_blk_type_map)
                     {
                         ps_h264d_dec_op->pu1_8x8_blk_type_map =
                             ps_h264d_dec_ip->pu1_8x8_blk_type_map;
                         ps_h264d_dec_op->u4_8x8_blk_type_map_size = ps_dec->u4_total_mbs << 2;
                         ih264_memcpy(ps_h264d_dec_op->pu1_8x8_blk_type_map,
                                      ps_dec->as_buf_id_info_map[disp_buf_id].pu1_mb_type_map,
                                      ps_dec->u4_total_mbs << 2);
                     }
                 }
                 /*Data memory barrier instruction,so that yuv write by the library is
                  * complete*/
                 DATA_SYNC();
 
                 H264_DEC_DEBUG_PRINT("The num bytes consumed: %d\n",
                                      ps_dec_op->u4_num_bytes_consumed);
             }
         }
         /* highest layer for flush validation */
 
         if((ps_dec->u1_flushfrm) && (1 == flush_decode))
         {
             u1_res_id = u1_num_res_lyrs - 1;
             ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_res_id;
             ps_dec = &ps_svc_lyr_dec->s_dec;
 
             ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer, &(ps_dec->s_disp_op));
             if(0 == ps_dec->s_disp_op.u4_error_code)
             {
                 /* check output buffer size given by the application */
                 if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)
                 {
                     ps_dec_op->u4_error_code = IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                     return (IV_FAIL);
                 }
 
                 ps_dec->u4_fmt_conv_cur_row = 0;
                 ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
                 ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op), ps_dec->u4_fmt_conv_cur_row,
                                       ps_dec->u4_fmt_conv_num_rows);
                 ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
                 ps_dec->u4_output_present = 1;
             }
             else
             {
                 ps_dec->u4_output_present = 0;
             }
             ih264d_export_sei_params(&ps_dec_op->s_sei_decode_op, ps_dec);
 
             ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 
             ps_dec_op->u4_pic_wd = (UWORD32) ps_dec->u2_disp_width;
             ps_dec_op->u4_pic_ht = (UWORD32) ps_dec->u2_disp_height;
             ps_dec_op->i4_reorder_depth = ps_dec->i4_reorder_depth;
             ps_dec_op->i4_display_index = ps_dec->i4_display_index;
 
             ps_dec_op->u4_new_seq = 0;
             ps_dec_op->u4_output_present = (ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER)
                                                ? ps_dec->u4_output_present
                                                : 0;
             ps_dec_op->u4_progressive_frame_flag = ps_dec->s_disp_op.u4_progressive_frame_flag;
             ps_dec_op->e_output_format = ps_dec->s_disp_op.e_output_format;
             ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
             ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
             ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
             ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
 
             /*In the case of flush ,since no frame is decoded set pic type as invalid*/
             ps_dec_op->u4_is_ref_flag = UINT32_MAX;
             ps_dec_op->e_pic_type = IV_NA_FRAME;
             ps_dec_op->u4_frame_decoded_flag = 0;
 
             if(0 == ps_dec->s_disp_op.u4_error_code)
             {
                 return (IV_SUCCESS);
             }
             else
                 return (IV_FAIL);
         }
     }
 
     if((ps_dec_op->u4_error_code & 0xff) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
     {
         ps_dec_op->u4_pic_wd = (UWORD32) ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32) ps_dec->u2_disp_height;
         ps_dec_op->i4_reorder_depth = ps_dec->i4_reorder_depth;
     }
     return api_ret_value;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :  isvcd_set_display_frame                                 */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 09 2021   Kishore         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
diff --git a/decoder/svc/isvcd_parse_ebslice.c b/decoder/svc/isvcd_parse_ebslice.c
index 604d0fd..b1807ea 100644
--- a/decoder/svc/isvcd_parse_ebslice.c
+++ b/decoder/svc/isvcd_parse_ebslice.c
@@ -1418,757 +1418,746 @@ WORD32 isvcd_parse_bmb_non_direct_cavlc(svc_dec_lyr_struct_t *ps_svc_lyr_dec,
 /*!
 **************************************************************************
 * \if Function name : ih264d_decode_ebslice \endif
 *
 * \brief
 *    Decodes an EB Slice
 *
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_ebslice(svc_dec_lyr_struct_t *ps_svc_lyr_dec, UWORD16 u2_first_mb_in_slice)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     WORD32 i_status = OK;
     dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
     dec_slice_params_t *ps_slice = ps_dec->ps_cur_slice;
     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
     dec_svc_seq_params_t *ps_subset_seq;
     dec_slice_svc_ext_params_t *ps_svc_slice_params = NULL;
     dec_subset_seq_params_t *ps_sps_svc_ext = NULL;
     dec_nal_unit_svc_ext_params_t *ps_nal_svc_ext = NULL;
     UWORD8 u1_ref_idx_re_flag_lx;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD64 u8_ref_idx_l0, u8_ref_idx_l1;
     UWORD32 u4_temp;
     WORD32 i_temp;
     WORD32 ret;
 
     ps_nal_svc_ext = ps_svc_lyr_dec->ps_nal_svc_ext;
     ps_subset_seq = ps_svc_lyr_dec->ps_cur_subset_sps;
     ps_sps_svc_ext = &ps_subset_seq->s_sps_svc_ext;
     ps_svc_slice_params = &ps_svc_lyr_dec->s_svc_slice_params;
 
     /*--------------------------------------------------------------------*/
     /* Read remaining contents of the slice header                        */
     /*--------------------------------------------------------------------*/
     {
         WORD8 *pi1_buf;
         WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
         WORD32 *pi4_mv = (WORD32 *) pi2_mv;
         WORD16 *pi16_refFrame;
         pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
         pi16_refFrame = (WORD16 *) pi1_buf;
         *pi4_mv = 0;
         *(pi4_mv + 1) = 0;
         *pi16_refFrame = OUT_OF_RANGE_REF;
         ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8) -1;
         ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8) -1;
     }
 
     if(0 == ps_svc_lyr_dec->ps_nal_svc_ext->u1_quality_id)
     {
         ps_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("Slice Header SVC ext: num_ref_idx_override_flag",
                        ps_slice->u1_num_ref_idx_active_override_flag);
 
         u8_ref_idx_l0 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
         u8_ref_idx_l1 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[1];
         if(ps_slice->u1_num_ref_idx_active_override_flag)
         {
             u8_ref_idx_l0 = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("Slice Header SVC ext: num_ref_idx_l0_active_minus1", u8_ref_idx_l0 - 1);
 
             u8_ref_idx_l1 = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("Slice Header SVC ext: num_ref_idx_l1_active_minus1", u8_ref_idx_l1 - 1);
         }
 
         {
             UWORD8 u1_max_ref_idx = H264_MAX_REF_PICS;
             if(ps_slice->u1_field_pic_flag)
             {
                 u1_max_ref_idx = H264_MAX_REF_PICS << 1;
             }
             if((u8_ref_idx_l0 >= u1_max_ref_idx) || (u8_ref_idx_l1 >= u1_max_ref_idx))
             {
                 return ERROR_NUM_REF;
             }
             ps_slice->u1_num_ref_idx_lx_active[0] = (UWORD8) u8_ref_idx_l0;
             ps_slice->u1_num_ref_idx_lx_active[1] = (UWORD8) u8_ref_idx_l1;
         }
 
         ih264d_init_ref_idx_lx_b(ps_dec);
         /* Store the value for future slices in the same picture */
         ps_dec->u1_num_ref_idx_lx_active_prev = ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
 
         u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("Slice Header SVC ext: ref_pic_list_reordering_flag_l0",
                        u1_ref_idx_re_flag_lx);
 
         /* Modified temporarily */
         if(u1_ref_idx_re_flag_lx)
         {
             WORD8 ret;
             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
             ret = ih264d_ref_idx_reordering(ps_dec, 0);
             if(ret == -1) return ERROR_REFIDX_ORDER_T;
         }
         else
             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
 
         u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("Slice Header SVC ext: ref_pic_list_reordering_flag_l1",
                        u1_ref_idx_re_flag_lx);
 
         /* Modified temporarily */
         if(u1_ref_idx_re_flag_lx)
         {
             WORD8 ret;
             ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_mod_dpb[1];
             ret = ih264d_ref_idx_reordering(ps_dec, 1);
             if(ret == -1) return ERROR_REFIDX_ORDER_T;
         }
         else
             ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];
 
         /* Create refIdx to POC mapping */
         {
             void **ppv_map_ref_idx_to_poc_lx;
             WORD8 idx;
             struct pic_buffer_t *ps_pic;
 
             ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
             ppv_map_ref_idx_to_poc_lx[0] = 0;
             ppv_map_ref_idx_to_poc_lx++;
             for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
             {
                 ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
                 ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
             }
 
             ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
 
             ppv_map_ref_idx_to_poc_lx[0] = 0;
             ppv_map_ref_idx_to_poc_lx++;
             for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1]; idx++)
             {
                 ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
                 ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
             }
 
             if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
             {
                 void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
 
                 ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L0;
                 ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L0;
 
                 ppv_map_ref_idx_to_poc_lx_t[0] = 0;
                 ppv_map_ref_idx_to_poc_lx_t++;
                 ppv_map_ref_idx_to_poc_lx_b[0] = 0;
                 ppv_map_ref_idx_to_poc_lx_b++;
                 for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
                 {
                     ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
                     ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
                     ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);
 
                     ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
                     ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;
 
                     ppv_map_ref_idx_to_poc_lx_t += 2;
                     ppv_map_ref_idx_to_poc_lx_b += 2;
                 }
 
                 ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L1;
                 ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L1;
 
                 ppv_map_ref_idx_to_poc_lx_t[0] = 0;
                 ppv_map_ref_idx_to_poc_lx_t++;
                 ppv_map_ref_idx_to_poc_lx_b[0] = 0;
                 ppv_map_ref_idx_to_poc_lx_b++;
                 for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1]; idx++)
                 {
                     UWORD8 u1_tmp_idx = idx << 1;
                     ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
                     ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx] = (ps_pic->pu1_buf1);
                     ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx + 1] = (ps_pic->pu1_buf1);
 
                     ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx] = (ps_pic->pu1_buf1) + 1;
                     ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx + 1] = (ps_pic->pu1_buf1) + 1;
                 }
             }
 
             /* BS is moved post recon gen in SVC ext*/
             if(ps_dec->u4_num_cores >= 2)
             {
                 WORD32 num_entries;
                 WORD32 size;
                 num_entries = MAX_FRAMES;
                 if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) && (0 == ps_dec->i4_display_delay))
                 {
                     num_entries = 1;
                 }
 
                 num_entries = ((2 * num_entries) + 1);
                 num_entries *= 2;
 
                 size = num_entries * sizeof(void *);
                 size += PAD_MAP_IDX_POC * sizeof(void *);
 
                 memcpy((void *) ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
                        ps_dec->ppv_map_ref_idx_to_poc, size);
             }
         }
 
         if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag &&
            (ps_dec->ps_cur_slice->u1_field_pic_flag == 0))
         {
             ih264d_convert_frm_mbaff_list(ps_dec);
         }
 
         if(ps_pps->u1_wted_bipred_idc == 1)
         {
             if(!ps_nal_svc_ext->u1_no_inter_layer_pred_flag)
             {
                 ps_svc_slice_params->u1_base_pred_weight_table_flag =
                     ih264d_get_bit_h264(ps_bitstrm);
                 COPYTHECONTEXT("Slice Header SVC ext: u1_base_pred_weight_table_flag",
                                ps_svc_slice_params->u1_base_pred_weight_table_flag);
             }
 
             if(ps_nal_svc_ext->u1_no_inter_layer_pred_flag ||
                !ps_svc_slice_params->u1_base_pred_weight_table_flag)
             {
                 ih264d_parse_pred_weight_table(ps_slice, ps_bitstrm);
 
                 ih264d_form_pred_weight_matrix(ps_dec);
                 ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
             }
         }
         else if(ps_pps->u1_wted_bipred_idc == 2)
         {
             /* Implicit Weighted prediction */
             ps_slice->u2_log2Y_crwd = 0x0505;
             ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
             ih264d_get_implicit_weights(ps_dec);
         }
         else
             ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
 
         ps_dec->ps_parse_cur_slice->u2_log2Y_crwd = ps_dec->ps_cur_slice->u2_log2Y_crwd;
 
         /* G050 */
         if(ps_slice->u1_nal_ref_idc != 0)
         {
             if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
             {
                 dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
                 dec_seq_params_t *ps_sps_tmp = ps_pps->ps_sps;
                 UWORD8 u1_nal_unit_type_tmp = ps_dec->u1_nal_unit_type;
 
                 ps_pps->ps_sps = ps_dec->ps_cur_sps;
                 if(ps_svc_lyr_dec->ps_nal_svc_ext->u1_idr_flag)
                     ps_dec->u1_nal_unit_type = IDR_SLICE_NAL;
 
                 i_temp = ih264d_read_mmco_commands(ps_dec);
 
                 ps_pps->ps_sps = ps_sps_tmp;
                 ps_dec->u1_nal_unit_type = u1_nal_unit_type_tmp;
 
                 if(i_temp < 0)
                 {
                     return ERROR_DBP_MANAGER_T;
                 }
                 ps_dec->u4_bitoffset = i_temp;
             }
             else
                 ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
 
             if(!ps_sps_svc_ext->u1_slice_header_restriction_flag)
             {
                 ps_svc_slice_params->u1_store_ref_base_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
                 COPYTHECONTEXT("SPS_SVC_EXT: u1_store_ref_base_pic_flag",
                                ps_svc_slice_params->u1_store_ref_base_pic_flag);
 
                 if(0 != ps_svc_slice_params->u1_store_ref_base_pic_flag)
                 {
                     return NOT_OK;
                 }
                 if(((1 == ps_nal_svc_ext->u1_use_ref_base_pic_flag) ||
                     (1 == ps_svc_slice_params->u1_store_ref_base_pic_flag)) &&
                    (!ps_nal_svc_ext->u1_idr_flag))
                 {
                     i_status = isvcd_dec_ref_base_pic_marking(
                         &ps_svc_slice_params->s_ref_base_pic_marking_svc_ext, ps_bitstrm);
                     if(i_status != OK)
                     {
                         return i_status;
                     }
                 }
             }
         }
     }
     /* G050 */
     /*Code is present in standard but omitted in the reference code*/
     if(ps_pps->u1_entropy_coding_mode == CABAC)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > MAX_CABAC_INIT_IDC)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
         ps_slice->u1_cabac_init_idc = u4_temp;
         COPYTHECONTEXT("Slice Header SVC ext: cabac_init_idc", ps_slice->u1_cabac_init_idc);
     }
 
     {
         /* Read slice_qp_delta */
         WORD64 i8_temp =
             (WORD64) ps_pps->u1_pic_init_qp + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if((i8_temp < MIN_H264_QP) || (i8_temp > MAX_H264_QP))
         {
             return ERROR_INV_RANGE_QP_T;
         }
         ps_slice->u1_slice_qp = (UWORD8) i8_temp;
         COPYTHECONTEXT("Slice Header SVC ext: slice_qp_delta",
                        (WORD8) (ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));
     }
     if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
         COPYTHECONTEXT("Slice Header SVC ext: disable_deblocking_filter_idc", u4_temp);
         ps_slice->u1_disable_dblk_filter_idc = u4_temp;
         if(u4_temp != 1)
         {
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_slice->i1_slice_alpha_c0_offset = i_temp;
             COPYTHECONTEXT("Slice Header SVC ext: slice_alpha_c0_offset_div2",
                            ps_slice->i1_slice_alpha_c0_offset >> 1);
 
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_slice->i1_slice_beta_offset = i_temp;
             COPYTHECONTEXT("Slice Header SVC ext: slice_beta_offset_div2",
                            ps_slice->i1_slice_beta_offset >> 1);
         }
         else
         {
             ps_slice->i1_slice_alpha_c0_offset = 0;
             ps_slice->i1_slice_beta_offset = 0;
         }
     }
     else
     {
         ps_slice->u1_disable_dblk_filter_idc = 0;
         ps_slice->i1_slice_alpha_c0_offset = 0;
         ps_slice->i1_slice_beta_offset = 0;
     }
 
     /* add the remaining part of the code for svc extension from reference */
     ret = isvcd_set_default_slice_header_ext(ps_svc_lyr_dec);
     if(ret != OK)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
 
     ret = isvcd_parse_slice_header(ps_svc_lyr_dec);
     if(ret != OK)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
 
-    ret = isvcd_parse_interlayer_resamp_func_init(ps_svc_lyr_dec, u2_first_mb_in_slice);
-    if(ret != OK)
-    {
-        return ERROR_CORRUPTED_SLICE;
-    }
-
     ps_dec->u1_slice_header_done = 2;
     if(!ps_svc_slice_params->u1_slice_skip_flag)
     {
         if(ps_pps->u1_entropy_coding_mode)
         {
             SWITCHOFFTRACE;
             SWITCHONTRACECABAC;
             ps_svc_lyr_dec->pf_parse_inter_slice_svc_ext =
                 isvcd_parse_inter_slice_data_cabac_enh_lyr;
             ps_svc_lyr_dec->pf_parse_inter_mb_svc_ext = isvcd_parse_bmb_cabac;
             isvcd_init_cabac_contexts(B_SLICE, ps_dec);
 
             if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
                 ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
             else
                 ps_dec->pf_get_mb_info = isvcd_get_mb_info_cabac_nonmbaff;
         }
         else
         {
             SWITCHONTRACE;
             SWITCHOFFTRACECABAC;
             ps_svc_lyr_dec->pf_parse_inter_slice_svc_ext =
                 isvcd_parse_inter_slice_data_cavlc_enh_lyr;
             ps_svc_lyr_dec->pf_parse_inter_mb_svc_ext = isvcd_parse_bmb_cavlc;
             if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
                 ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
             else
                 ps_dec->pf_get_mb_info = isvcd_get_mb_info_cavlc_nonmbaff;
         }
     }
     else
     {
         return ERROR_FEATURE_UNAVAIL;
     }
 
     ret = ih264d_cal_col_pic(ps_dec);
     if(ret != OK) return ret;
     ps_dec->u1_B = 1;
     ps_dec->pf_mvpred_ref_tfr_nby2mb = isvcd_mv_pred_ref_tfr_nby2_ebmb;
     ret = ps_svc_lyr_dec->pf_parse_inter_slice_svc_ext(ps_svc_lyr_dec, ps_slice,
                                                        u2_first_mb_in_slice);
     if(ret != OK) return ret;
 
     return OK;
 }
 
 /*!
 **************************************************************************
 * \if Function name : isvcd_parse_bslice \endif
 *
 * \brief
 *    Decodes a B Slice
 *
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_bslice(svc_dec_lyr_struct_t *ps_svc_lyr_dec, UWORD16 u2_first_mb_in_slice)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
     dec_slice_params_t *ps_slice = ps_dec->ps_cur_slice;
     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
     UWORD8 u1_ref_idx_re_flag_lx;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD64 u8_ref_idx_l0, u8_ref_idx_l1;
     UWORD32 u4_temp;
     WORD32 i_temp;
     WORD32 ret;
 
     /*--------------------------------------------------------------------*/
     /* Read remaining contents of the slice header                        */
     /*--------------------------------------------------------------------*/
     {
         WORD8 *pi1_buf;
         WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
         WORD32 *pi4_mv = (WORD32 *) pi2_mv;
         WORD16 *pi16_refFrame;
         pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
         pi16_refFrame = (WORD16 *) pi1_buf;
         *pi4_mv = 0;
         *(pi4_mv + 1) = 0;
         *pi16_refFrame = OUT_OF_RANGE_REF;
         ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8) -1;
         ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8) -1;
     }
 
     ps_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SH: num_ref_idx_override_flag", ps_slice->u1_num_ref_idx_active_override_flag);
 
     u8_ref_idx_l0 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
     u8_ref_idx_l1 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[1];
     if(ps_slice->u1_num_ref_idx_active_override_flag)
     {
         u8_ref_idx_l0 = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SH: num_ref_idx_l0_active_minus1", u8_ref_idx_l0 - 1);
 
         u8_ref_idx_l1 = (UWORD64) 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SH: num_ref_idx_l1_active_minus1", u8_ref_idx_l1 - 1);
     }
 
     {
         UWORD8 u1_max_ref_idx = H264_MAX_REF_PICS;
         if(ps_slice->u1_field_pic_flag)
         {
             u1_max_ref_idx = H264_MAX_REF_PICS << 1;
         }
         if((u8_ref_idx_l0 >= u1_max_ref_idx) || (u8_ref_idx_l1 >= u1_max_ref_idx))
         {
             return ERROR_NUM_REF;
         }
         ps_slice->u1_num_ref_idx_lx_active[0] = (UWORD8) u8_ref_idx_l0;
         ps_slice->u1_num_ref_idx_lx_active[1] = (UWORD8) u8_ref_idx_l1;
     }
 
     ih264d_init_ref_idx_lx_b(ps_dec);
     /* Store the value for future slices in the same picture */
     ps_dec->u1_num_ref_idx_lx_active_prev = ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0];
 
     u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SH: ref_pic_list_reordering_flag_l0", u1_ref_idx_re_flag_lx);
 
     /* Modified temporarily */
     if(u1_ref_idx_re_flag_lx)
     {
         WORD8 ret;
         ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
         ret = ih264d_ref_idx_reordering(ps_dec, 0);
         if(ret == -1) return ERROR_REFIDX_ORDER_T;
     }
     else
         ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
 
     u1_ref_idx_re_flag_lx = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SH: ref_pic_list_reordering_flag_l1", u1_ref_idx_re_flag_lx);
 
     /* Modified temporarily */
     if(u1_ref_idx_re_flag_lx)
     {
         WORD8 ret;
         ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_mod_dpb[1];
         ret = ih264d_ref_idx_reordering(ps_dec, 1);
         if(ret == -1) return ERROR_REFIDX_ORDER_T;
     }
     else
         ps_dec->ps_ref_pic_buf_lx[1] = ps_dec->ps_dpb_mgr->ps_init_dpb[1];
 
     /* Create refIdx to POC mapping */
     {
         void **ppv_map_ref_idx_to_poc_lx;
         WORD8 idx;
         struct pic_buffer_t *ps_pic;
 
         ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
         ppv_map_ref_idx_to_poc_lx[0] = 0;
         ppv_map_ref_idx_to_poc_lx++;
         for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
         {
             ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
             ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
         }
 
         ppv_map_ref_idx_to_poc_lx = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
 
         ppv_map_ref_idx_to_poc_lx[0] = 0;
         ppv_map_ref_idx_to_poc_lx++;
         for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1]; idx++)
         {
             ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
             ppv_map_ref_idx_to_poc_lx[idx] = (ps_pic->pu1_buf1);
         }
 
         if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
         {
             void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
 
             ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L0;
             ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L0;
 
             ppv_map_ref_idx_to_poc_lx_t[0] = 0;
             ppv_map_ref_idx_to_poc_lx_t++;
             ppv_map_ref_idx_to_poc_lx_b[0] = 0;
             ppv_map_ref_idx_to_poc_lx_b++;
             for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
             {
                 ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
                 ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
                 ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);
 
                 ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
                 ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;
 
                 ppv_map_ref_idx_to_poc_lx_t += 2;
                 ppv_map_ref_idx_to_poc_lx_b += 2;
             }
 
             ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L1;
             ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L1;
 
             ppv_map_ref_idx_to_poc_lx_t[0] = 0;
             ppv_map_ref_idx_to_poc_lx_t++;
             ppv_map_ref_idx_to_poc_lx_b[0] = 0;
             ppv_map_ref_idx_to_poc_lx_b++;
             for(idx = 0; idx < ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1]; idx++)
             {
                 UWORD8 u1_tmp_idx = idx << 1;
                 ps_pic = ps_dec->ps_ref_pic_buf_lx[1][idx];
                 ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx] = (ps_pic->pu1_buf1);
                 ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx + 1] = (ps_pic->pu1_buf1);
 
                 ppv_map_ref_idx_to_poc_lx_b[u1_tmp_idx] = (ps_pic->pu1_buf1) + 1;
                 ppv_map_ref_idx_to_poc_lx_t[u1_tmp_idx + 1] = (ps_pic->pu1_buf1) + 1;
             }
         }
     }
 
     if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag && (ps_dec->ps_cur_slice->u1_field_pic_flag == 0))
     {
         ih264d_convert_frm_mbaff_list(ps_dec);
     }
 
     if(ps_pps->u1_wted_bipred_idc == 1)
     {
         ret = ih264d_parse_pred_weight_table(ps_slice, ps_bitstrm);
         if(ret != OK) return ret;
         ih264d_form_pred_weight_matrix(ps_dec);
         ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
     }
     else if(ps_pps->u1_wted_bipred_idc == 2)
     {
         /* Implicit Weighted prediction */
         ps_slice->u2_log2Y_crwd = 0x0505;
         ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
         ih264d_get_implicit_weights(ps_dec);
     }
     else
         ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
 
     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd = ps_dec->ps_cur_slice->u2_log2Y_crwd;
 
     /* G050 */
     if(ps_slice->u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
         {
             dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
             dec_seq_params_t *ps_sps_tmp = ps_pps->ps_sps;
             UWORD8 u1_nal_unit_type_tmp = ps_dec->u1_nal_unit_type;
 
             ps_pps->ps_sps = ps_dec->ps_cur_sps;
             if(ps_svc_lyr_dec->ps_nal_svc_ext->u1_idr_flag)
                 ps_dec->u1_nal_unit_type = IDR_SLICE_NAL;
 
             i_temp = ih264d_read_mmco_commands(ps_dec);
 
             ps_pps->ps_sps = ps_sps_tmp;
             ps_dec->u1_nal_unit_type = u1_nal_unit_type_tmp;
 
             if(i_temp < 0)
             {
                 return ERROR_DBP_MANAGER_T;
             }
             ps_dec->u4_bitoffset = i_temp;
         }
         else
             ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
     }
     /* G050 */
 
     if(ps_pps->u1_entropy_coding_mode == CABAC)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > MAX_CABAC_INIT_IDC)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
         ps_slice->u1_cabac_init_idc = u4_temp;
         COPYTHECONTEXT("SH: cabac_init_idc", ps_slice->u1_cabac_init_idc);
     }
     {
         /* Read slice_qp_delta */
         WORD64 i8_temp =
             (WORD64) ps_pps->u1_pic_init_qp + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if((i8_temp < MIN_H264_QP) || (i8_temp > MAX_H264_QP))
         {
             return ERROR_INV_RANGE_QP_T;
         }
         ps_slice->u1_slice_qp = (UWORD8) i8_temp;
         COPYTHECONTEXT("SH: slice_qp_delta",
                        (WORD8) (ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));
     }
     if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
         COPYTHECONTEXT("SH: disable_deblocking_filter_idc", u4_temp);
         ps_slice->u1_disable_dblk_filter_idc = u4_temp;
         if(u4_temp != 1)
         {
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_slice->i1_slice_alpha_c0_offset = i_temp;
             COPYTHECONTEXT("SH: slice_alpha_c0_offset_div2",
                            ps_slice->i1_slice_alpha_c0_offset >> 1);
 
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_slice->i1_slice_beta_offset = i_temp;
             COPYTHECONTEXT("SH: slice_beta_offset_div2", ps_slice->i1_slice_beta_offset >> 1);
         }
         else
         {
             ps_slice->i1_slice_alpha_c0_offset = 0;
             ps_slice->i1_slice_beta_offset = 0;
         }
     }
     else
     {
         ps_slice->u1_disable_dblk_filter_idc = 0;
         ps_slice->i1_slice_alpha_c0_offset = 0;
         ps_slice->i1_slice_beta_offset = 0;
     }
 
-    ret = isvcd_parse_interlayer_resamp_func_init(ps_svc_lyr_dec, u2_first_mb_in_slice);
-    if(ret != OK)
-    {
-        return ERROR_CORRUPTED_SLICE;
-    }
     ps_dec->u1_slice_header_done = 2;
 
     if(ps_pps->u1_entropy_coding_mode)
     {
         SWITCHOFFTRACE;
         SWITCHONTRACECABAC;
         ps_svc_lyr_dec->pf_parse_svc_inter_slice = isvcd_parse_inter_slice_data_cabac;
         ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cabac;
         ih264d_init_cabac_contexts(B_SLICE, ps_dec);
 
         if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
         else
             ps_dec->pf_get_mb_info = isvcd_get_mb_info_cabac_nonmbaff;
     }
     else
     {
         SWITCHONTRACE;
         SWITCHOFFTRACECABAC;
         ps_svc_lyr_dec->pf_parse_svc_inter_slice = isvcd_parse_inter_slice_data_cavlc;
         ps_dec->pf_parse_inter_mb = ih264d_parse_bmb_cavlc;
         if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
         else
             ps_dec->pf_get_mb_info = isvcd_get_mb_info_cavlc_nonmbaff;
     }
 
     ret = ih264d_cal_col_pic(ps_dec);
     if(ret != OK) return ret;
     ps_dec->u1_B = 1;
     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_bmb;
     ret = ps_svc_lyr_dec->pf_parse_svc_inter_slice(ps_svc_lyr_dec, ps_slice, u2_first_mb_in_slice);
     if(ret != OK) return ret;
 
     return OK;
 }
diff --git a/decoder/svc/isvcd_parse_eislice.c b/decoder/svc/isvcd_parse_eislice.c
index 4b3728c..c412fc5 100644
--- a/decoder/svc/isvcd_parse_eislice.c
+++ b/decoder/svc/isvcd_parse_eislice.c
@@ -964,236 +964,231 @@ WORD32 isvcd_parse_imb_cavlc(svc_dec_lyr_struct_t *ps_svc_lyr_dec, dec_mb_info_t
 /*!
 **************************************************************************
 * \if Function name : ih264d_decode_eislice \endif
 *
 * \brief
 *    Decodes an EI Slice
 *
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_eislice(svc_dec_lyr_struct_t *ps_svc_lyr_dec, UWORD16 u2_first_mb_in_slice)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     WORD32 i_status = OK;
     dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
     dec_slice_params_t *ps_slice = ps_dec->ps_cur_slice;
     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
     dec_seq_params_t *ps_seq;
     dec_svc_seq_params_t *ps_subset_seq;
     dec_slice_svc_ext_params_t *ps_svc_slice_params = NULL;
     dec_subset_seq_params_t *ps_sps_svc_ext = NULL;
     dec_nal_unit_svc_ext_params_t *ps_nal_svc_ext = NULL;
     UWORD32 u4_temp;
     WORD32 i_temp;
     WORD32 ret;
     UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
 
     ps_nal_svc_ext = ps_svc_lyr_dec->ps_nal_svc_ext;
     ps_seq = ps_dec->ps_cur_sps;
     ps_subset_seq =
         &ps_svc_lyr_dec->ps_subset_sps[MAX_NUM_SEQ_PARAMS + ps_seq->u1_seq_parameter_set_id];
     ps_sps_svc_ext = &ps_subset_seq->s_sps_svc_ext;
     ps_svc_slice_params = &ps_svc_lyr_dec->s_svc_slice_params;
 
     if(0 == ps_svc_lyr_dec->ps_nal_svc_ext->u1_quality_id)
     {
         /*--------------------------------------------------------------------*/
         /* Read remaining contents of the slice header                        */
         /*--------------------------------------------------------------------*/
         /* dec_ref_pic_marking function */
         /* G050 */
         if(ps_slice->u1_nal_ref_idc != 0)
         {
             if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
             {
                 dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
                 dec_seq_params_t *ps_sps_tmp = ps_pps->ps_sps;
                 UWORD8 u1_nal_unit_type_tmp = ps_dec->u1_nal_unit_type;
 
                 ps_pps->ps_sps = ps_dec->ps_cur_sps;
                 if(ps_svc_lyr_dec->ps_nal_svc_ext->u1_idr_flag)
                     ps_dec->u1_nal_unit_type = IDR_SLICE_NAL;
 
                 i_temp = ih264d_read_mmco_commands(ps_dec);
 
                 ps_pps->ps_sps = ps_sps_tmp;
                 ps_dec->u1_nal_unit_type = u1_nal_unit_type_tmp;
                 if(i_temp < 0)
                 {
                     return ERROR_DBP_MANAGER_T;
                 }
                 ps_dec->u4_bitoffset = i_temp;
             }
             else
                 ps_dec->ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
 
             if(!ps_sps_svc_ext->u1_slice_header_restriction_flag)
             {
                 ps_svc_slice_params->u1_store_ref_base_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
                 COPYTHECONTEXT("SPS_SVC_EXT: u1_store_ref_base_pic_flag",
                                ps_svc_slice_params->u1_store_ref_base_pic_flag);
 
                 if(0 != ps_svc_slice_params->u1_store_ref_base_pic_flag)
                 {
                     return NOT_OK;
                 }
                 if(((1 == ps_nal_svc_ext->u1_use_ref_base_pic_flag) ||
                     (1 == ps_svc_slice_params->u1_store_ref_base_pic_flag)) &&
                    (!ps_nal_svc_ext->u1_idr_flag))
                 {
                     i_status = isvcd_dec_ref_base_pic_marking(
                         &ps_svc_slice_params->s_ref_base_pic_marking_svc_ext, ps_bitstrm);
                     if(i_status != OK)
                     {
                         return i_status;
                     }
                 }
             }
         }
     }
 
     {
         /* G050 */
         /* Read slice_qp_delta */
         WORD64 i8_temp =
             (WORD64) ps_pps->u1_pic_init_qp + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if((i8_temp < MIN_H264_QP) || (i8_temp > MAX_H264_QP)) return ERROR_INV_RANGE_QP_T;
         ps_slice->u1_slice_qp = (UWORD8) i8_temp;
         COPYTHECONTEXT("Slice Header SVC ext: slice_qp_delta",
                        ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp);
     }
 
     if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("Slice Header SVC ext: disable_deblocking_filter_idc", u4_temp);
 
         if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
         ps_slice->u1_disable_dblk_filter_idc = u4_temp;
         if(u4_temp != 1)
         {
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_slice->i1_slice_alpha_c0_offset = i_temp;
             COPYTHECONTEXT("Slice Header SVC ext: slice_alpha_c0_offset_div2",
                            ps_slice->i1_slice_alpha_c0_offset >> 1);
 
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_slice->i1_slice_beta_offset = i_temp;
             COPYTHECONTEXT("Slice Header SVC ext: slice_beta_offset_div2",
                            ps_slice->i1_slice_beta_offset >> 1);
         }
         else
         {
             ps_slice->i1_slice_alpha_c0_offset = 0;
             ps_slice->i1_slice_beta_offset = 0;
         }
     }
     else
     {
         ps_slice->u1_disable_dblk_filter_idc = 0;
         ps_slice->i1_slice_alpha_c0_offset = 0;
         ps_slice->i1_slice_beta_offset = 0;
     }
 
     /* add the remaining part of the code for svc extension from reference */
     ret = isvcd_set_default_slice_header_ext(ps_svc_lyr_dec);
     if(ret != OK)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
 
     ret = isvcd_parse_slice_header(ps_svc_lyr_dec);
     if(ret != OK)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
 
     /* Initialization to check if number of motion vector per 2 Mbs */
     /* are exceeding the range or not */
     ps_dec->u2_mv_2mb[0] = 0;
     ps_dec->u2_mv_2mb[1] = 0;
 
-    ret = isvcd_parse_interlayer_resamp_func_init(ps_svc_lyr_dec, u2_first_mb_in_slice);
-    if(ret != OK)
-    {
-        return ERROR_CORRUPTED_SLICE;
-    }
     /*set slice header cone to 2 ,to indicate  correct header*/
     ps_dec->u1_slice_header_done = 2;
 
     if(!ps_svc_slice_params->u1_slice_skip_flag)
     {
         if(ps_pps->u1_entropy_coding_mode)
         {
             SWITCHOFFTRACE;
             SWITCHONTRACECABAC;
             if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
             {
                 ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
             }
             else
                 ps_dec->pf_get_mb_info = isvcd_get_mb_info_cabac_nonmbaff;
 
             ret = isvcd_parse_eislice_data_cabac(ps_svc_lyr_dec, ps_slice, u2_first_mb_in_slice);
             if(ret != OK) return ret;
             SWITCHONTRACE;
             SWITCHOFFTRACECABAC;
         }
         else
         {
             if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
             {
                 ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
             }
             else
                 ps_dec->pf_get_mb_info = isvcd_get_mb_info_cavlc_nonmbaff;
             ret = isvcd_parse_eislice_data_cavlc(ps_svc_lyr_dec, ps_slice, u2_first_mb_in_slice);
             if(ret != OK) return ret;
         }
     }
     else
     {
         return ERROR_FEATURE_UNAVAIL;
     }
 
     return OK;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_parse_eislice_data_cabac                          */
 /*                                                                           */
 /*  Description   : This function parses cabac syntax of a inter slice on    */
 /*                  N MB basis.                                              */
 /*                                                                           */
 /*  Inputs        : ps_dec                                                   */
 /*                  sliceparams                                              */
 /*                  firstMbInSlice                                           */
 /*                                                                           */
 /*  Processing    : 1. After parsing syntax for N MBs those N MBs are        */
 /*                     decoded till the end of slice.                        */
 /*                                                                           */
 /*  Returns       : 0                                                        */
 /*                                                                           */
 /*  Issues        : <List any issues or problems with this function>         */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         24 06 2005   Kishore         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -1957,147 +1952,142 @@ WORD32 isvcd_parse_imb_cabac(svc_dec_lyr_struct_t *ps_svc_lyr_dec, dec_mb_info_t
 /*!
 **************************************************************************
 * \if Function name : isvcd_decode_islice \endif
 *
 * \brief
 *    Decodes an I Slice
 *
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_islice(svc_dec_lyr_struct_t *ps_svc_lyr_dec, UWORD16 u2_first_mb_in_slice)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
     dec_slice_params_t *ps_slice = ps_dec->ps_cur_slice;
     UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
     UWORD32 u4_temp;
     WORD32 i_temp;
     WORD32 ret;
 
     /*--------------------------------------------------------------------*/
     /* Read remaining contents of the slice header                        */
     /*--------------------------------------------------------------------*/
     /* dec_ref_pic_marking function */
     /* G050 */
     if(ps_slice->u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
         {
             dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
             dec_seq_params_t *ps_sps_tmp = ps_pps->ps_sps;
             UWORD8 u1_nal_unit_type_tmp = ps_dec->u1_nal_unit_type;
 
             ps_pps->ps_sps = ps_dec->ps_cur_sps;
             if(ps_svc_lyr_dec->ps_nal_svc_ext->u1_idr_flag)
                 ps_dec->u1_nal_unit_type = IDR_SLICE_NAL;
 
             i_temp = ih264d_read_mmco_commands(ps_dec);
             ps_pps->ps_sps = ps_sps_tmp;
             ps_dec->u1_nal_unit_type = u1_nal_unit_type_tmp;
 
             if(i_temp < 0)
             {
                 return ERROR_DBP_MANAGER_T;
             }
             ps_dec->u4_bitoffset = i_temp;
         }
         else
             ps_dec->ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
     }
 
     {
         /* G050 */
         /* Read slice_qp_delta */
         WORD64 i8_temp =
             (WORD64) ps_pps->u1_pic_init_qp + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if((i8_temp < MIN_H264_QP) || (i8_temp > MAX_H264_QP)) return ERROR_INV_RANGE_QP_T;
         ps_slice->u1_slice_qp = (UWORD8) i8_temp;
         COPYTHECONTEXT("SH: slice_qp_delta", ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp);
     }
     if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SH: disable_deblocking_filter_idc", u4_temp);
 
         if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
         ps_slice->u1_disable_dblk_filter_idc = u4_temp;
         if(u4_temp != 1)
         {
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_slice->i1_slice_alpha_c0_offset = i_temp;
             COPYTHECONTEXT("SH: slice_alpha_c0_offset_div2",
                            ps_slice->i1_slice_alpha_c0_offset >> 1);
 
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_slice->i1_slice_beta_offset = i_temp;
             COPYTHECONTEXT("SH: slice_beta_offset_div2", ps_slice->i1_slice_beta_offset >> 1);
         }
         else
         {
             ps_slice->i1_slice_alpha_c0_offset = 0;
             ps_slice->i1_slice_beta_offset = 0;
         }
     }
     else
     {
         ps_slice->u1_disable_dblk_filter_idc = 0;
         ps_slice->i1_slice_alpha_c0_offset = 0;
         ps_slice->i1_slice_beta_offset = 0;
     }
 
     /* Initialization to check if number of motion vector per 2 Mbs */
     /* are exceeding the range or not */
     ps_dec->u2_mv_2mb[0] = 0;
     ps_dec->u2_mv_2mb[1] = 0;
 
-    ret = isvcd_parse_interlayer_resamp_func_init(ps_svc_lyr_dec, u2_first_mb_in_slice);
-    if(ret != OK)
-    {
-        return ERROR_CORRUPTED_SLICE;
-    }
     /*set slice header cone to 2 ,to indicate  correct header*/
     ps_dec->u1_slice_header_done = 2;
     if(ps_pps->u1_entropy_coding_mode)
     {
         SWITCHOFFTRACE;
         SWITCHONTRACECABAC;
         if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
         {
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
         }
         else
             ps_dec->pf_get_mb_info = isvcd_get_mb_info_cabac_nonmbaff;
 
         ret = isvcd_parse_islice_data_cabac(ps_svc_lyr_dec, ps_slice, u2_first_mb_in_slice);
         if(ret != OK) return ret;
         SWITCHONTRACE;
         SWITCHOFFTRACECABAC;
     }
     else
     {
         if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
         {
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
         }
         else
             ps_dec->pf_get_mb_info = isvcd_get_mb_info_cavlc_nonmbaff;
         ret = isvcd_parse_islice_data_cavlc(ps_svc_lyr_dec, ps_slice, u2_first_mb_in_slice);
         if(ret != OK) return ret;
     }
 
     return OK;
 }
diff --git a/decoder/svc/isvcd_parse_epslice.c b/decoder/svc/isvcd_parse_epslice.c
index 7603049..36621ba 100644
--- a/decoder/svc/isvcd_parse_epslice.c
+++ b/decoder/svc/isvcd_parse_epslice.c
@@ -86,421 +86,416 @@ void isvcd_init_cabac_contexts(UWORD8 u1_slice_type, dec_struct_t *ps_dec);
 /*!
 **************************************************************************
 * \if Function name : isvcd_parse_epslice \endif
 *
 * \brief
 *    Decodes a EP Slice
 *
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_epslice(svc_dec_lyr_struct_t *ps_svc_lyr_dec, UWORD16 u2_first_mb_in_slice)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     WORD32 i_status = OK;
     dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
     dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
     dec_seq_params_t *ps_seq;
     dec_svc_seq_params_t *ps_subset_seq;
     dec_slice_svc_ext_params_t *ps_svc_slice_params = NULL;
     dec_subset_seq_params_t *ps_sps_svc_ext = NULL;
     dec_nal_unit_svc_ext_params_t *ps_nal_svc_ext = NULL;
 
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
     UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
 
     UWORD64 u8_ref_idx_l0;
     UWORD32 u4_temp;
     WORD32 i_temp;
     WORD32 ret;
     WORD64 i8_temp;
 
     ps_nal_svc_ext = ps_svc_lyr_dec->ps_nal_svc_ext;
     ps_seq = ps_pps->ps_sps;
     ps_seq += MAX_NUM_SEQ_PARAMS;
     ps_subset_seq =
         &ps_svc_lyr_dec->ps_subset_sps[MAX_NUM_SEQ_PARAMS + ps_seq->u1_seq_parameter_set_id];
     ps_sps_svc_ext = &ps_subset_seq->s_sps_svc_ext;
     ps_svc_slice_params = &ps_svc_lyr_dec->s_svc_slice_params;
 
     /*--------------------------------------------------------------------*/
     /* Read remaining contents of the slice header                        */
     /*--------------------------------------------------------------------*/
     {
         WORD8 *pi1_buf;
         WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
         WORD32 *pi4_mv = (WORD32 *) pi2_mv;
         WORD16 *pi16_refFrame;
 
         pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
         pi16_refFrame = (WORD16 *) pi1_buf;
         *pi4_mv = 0;
         *(pi4_mv + 1) = 0;
         *pi16_refFrame = OUT_OF_RANGE_REF;
         ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8) -1;
         ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8) -1;
     }
 
     if(0 == ps_svc_lyr_dec->ps_nal_svc_ext->u1_quality_id)
     {
         ps_cur_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(ps_bitstrm);
 
         COPYTHECONTEXT("Slice Header SVC ext: num_ref_idx_override_flag",
                        ps_cur_slice->u1_num_ref_idx_active_override_flag);
 
         u8_ref_idx_l0 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
         if(ps_cur_slice->u1_num_ref_idx_active_override_flag)
         {
             u8_ref_idx_l0 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf) + (UWORD64) 1;
         }
 
         {
             UWORD8 u1_max_ref_idx = H264_MAX_REF_PICS << u1_field_pic_flag;
             if(u8_ref_idx_l0 > u1_max_ref_idx)
             {
                 return ERROR_NUM_REF;
             }
             ps_cur_slice->u1_num_ref_idx_lx_active[0] = (UWORD8) u8_ref_idx_l0;
             COPYTHECONTEXT("Slice Header SVC ext: num_ref_idx_l0_active_minus1",
                            ps_cur_slice->u1_num_ref_idx_lx_active[0] - 1);
         }
 
         {
             UWORD8 uc_refIdxReFlagL0 = ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("Slice Header SVC ext: ref_pic_list_reordering_flag_l0",
                            uc_refIdxReFlagL0);
 
             ih264d_init_ref_idx_lx_p(ps_dec);
             /* Store the value for future slices in the same picture */
             ps_dec->u1_num_ref_idx_lx_active_prev = ps_cur_slice->u1_num_ref_idx_lx_active[0];
 
             /* Modified temporarily */
             if(uc_refIdxReFlagL0)
             {
                 WORD8 ret;
                 ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
                 ret = ih264d_ref_idx_reordering(ps_dec, 0);
                 if(ret == -1) return ERROR_REFIDX_ORDER_T;
                 ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
             }
             else
                 ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
         }
         /* Create refIdx to POC mapping */
         {
             void **pui_map_ref_idx_to_poc_lx0, **pui_map_ref_idx_to_poc_lx1;
             WORD8 idx;
             struct pic_buffer_t *ps_pic;
 
             pui_map_ref_idx_to_poc_lx0 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
             pui_map_ref_idx_to_poc_lx0[0] = 0;
             pui_map_ref_idx_to_poc_lx0++;
             for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
             {
                 ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
                 pui_map_ref_idx_to_poc_lx0[idx] = (ps_pic->pu1_buf1);
             }
 
             /* Bug Fix Deblocking */
             pui_map_ref_idx_to_poc_lx1 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
             pui_map_ref_idx_to_poc_lx1[0] = 0;
 
             if(u1_mbaff)
             {
                 void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
                 void **ppv_map_ref_idx_to_poc_lx_t1, **ppv_map_ref_idx_to_poc_lx_b1;
                 ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L0;
                 ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L0;
 
                 ppv_map_ref_idx_to_poc_lx_t[0] = 0;
                 ppv_map_ref_idx_to_poc_lx_t++;
                 ppv_map_ref_idx_to_poc_lx_b[0] = 0;
                 ppv_map_ref_idx_to_poc_lx_b++;
 
                 idx = 0;
                 for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
                 {
                     ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
                     ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
                     ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);
 
                     ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
                     ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;
 
                     ppv_map_ref_idx_to_poc_lx_t += 2;
                     ppv_map_ref_idx_to_poc_lx_b += 2;
                 }
                 ppv_map_ref_idx_to_poc_lx_t1 = ps_dec->ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L1;
                 ppv_map_ref_idx_to_poc_lx_t1[0] = 0;
                 ppv_map_ref_idx_to_poc_lx_b1 = ps_dec->ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L1;
                 ppv_map_ref_idx_to_poc_lx_b1[0] = 0;
             }
             /* BS is moved post recon gen in libsvc*/
             if(ps_dec->u4_num_cores >= 2)
             {
                 WORD32 num_entries;
                 WORD32 size;
 
                 num_entries = MAX_FRAMES;
                 if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) && (0 == ps_dec->i4_display_delay))
                 {
                     num_entries = 1;
                 }
                 num_entries = ((2 * num_entries) + 1);
                 num_entries *= 2;
 
                 size = num_entries * sizeof(void *);
                 size += PAD_MAP_IDX_POC * sizeof(void *);
 
                 memcpy((void *) ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc,
                        ps_dec->ppv_map_ref_idx_to_poc, size);
             }
         }
         if(ps_pps->u1_wted_pred_flag)
         {
             if(!ps_nal_svc_ext->u1_no_inter_layer_pred_flag)
             {
                 ps_svc_slice_params->u1_base_pred_weight_table_flag =
                     ih264d_get_bit_h264(ps_bitstrm);
                 COPYTHECONTEXT("Slice Header SVC ext: u1_base_pred_weight_table_flag",
                                ps_svc_slice_params->u1_base_pred_weight_table_flag);
             }
 
             if(ps_nal_svc_ext->u1_no_inter_layer_pred_flag ||
                !ps_svc_slice_params->u1_base_pred_weight_table_flag)
             {
                 ret = ih264d_parse_pred_weight_table(ps_cur_slice, ps_bitstrm);
                 if(ret != OK) return ret;
 
                 ih264d_form_pred_weight_matrix(ps_dec);
                 ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
             }
         }
         else
         {
             ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
             ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
         }
 
         ps_dec->ps_parse_cur_slice->u2_log2Y_crwd = ps_dec->ps_cur_slice->u2_log2Y_crwd;
 
         if(u1_mbaff && (u1_field_pic_flag == 0))
         {
             ih264d_convert_frm_mbaff_list(ps_dec);
         }
 
         /* G050 */
         if(ps_cur_slice->u1_nal_ref_idc != 0)
         {
             if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
             {
                 dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
                 dec_seq_params_t *ps_sps_tmp = ps_pps->ps_sps;
                 UWORD8 u1_nal_unit_type_tmp = ps_dec->u1_nal_unit_type;
 
                 ps_pps->ps_sps = ps_dec->ps_cur_sps;
 
                 if(ps_svc_lyr_dec->ps_nal_svc_ext->u1_idr_flag)
                     ps_dec->u1_nal_unit_type = IDR_SLICE_NAL;
 
                 i_temp = ih264d_read_mmco_commands(ps_dec);
 
                 ps_pps->ps_sps = ps_sps_tmp;
                 ps_dec->u1_nal_unit_type = u1_nal_unit_type_tmp;
 
                 if(i_temp < 0)
                 {
                     return ERROR_DBP_MANAGER_T;
                 }
                 ps_dec->u4_bitoffset = i_temp;
             }
             else
                 ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
 
             if(!ps_sps_svc_ext->u1_slice_header_restriction_flag)
             {
                 ps_svc_slice_params->u1_store_ref_base_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
                 COPYTHECONTEXT("SPS_SVC_EXT: u1_store_ref_base_pic_flag",
                                ps_svc_slice_params->u1_store_ref_base_pic_flag);
 
                 if(0 != ps_svc_slice_params->u1_store_ref_base_pic_flag)
                 {
                     return NOT_OK;
                 }
                 if(((1 == ps_nal_svc_ext->u1_use_ref_base_pic_flag) ||
                     (1 == ps_svc_slice_params->u1_store_ref_base_pic_flag)) &&
                    (!ps_nal_svc_ext->u1_idr_flag))
                 {
                     i_status = isvcd_dec_ref_base_pic_marking(
                         &ps_svc_slice_params->s_ref_base_pic_marking_svc_ext, ps_bitstrm);
                     if(i_status != OK)
                     {
                         return i_status;
                     }
                 }
             }
         }
     }
     /* G050 */
 
     if(ps_pps->u1_entropy_coding_mode == CABAC)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(u4_temp > MAX_CABAC_INIT_IDC)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
         ps_cur_slice->u1_cabac_init_idc = u4_temp;
         COPYTHECONTEXT("Slice Header SVC ext: cabac_init_idc", ps_cur_slice->u1_cabac_init_idc);
     }
 
     /* Read slice_qp_delta */
     i8_temp = (WORD64) ps_pps->u1_pic_init_qp + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if((i8_temp < MIN_H264_QP) || (i8_temp > MAX_H264_QP))
     {
         return ERROR_INV_RANGE_QP_T;
     }
     ps_cur_slice->u1_slice_qp = (UWORD8) i8_temp;
     COPYTHECONTEXT("Slice Header SVC ext: slice_qp_delta",
                    (WORD8) (ps_cur_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));
 
     if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
 
         COPYTHECONTEXT("Slice Header SVC ext: disable_deblocking_filter_idc", u4_temp);
         ps_cur_slice->u1_disable_dblk_filter_idc = u4_temp;
         if(u4_temp != 1)
         {
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_cur_slice->i1_slice_alpha_c0_offset = i_temp;
             COPYTHECONTEXT("Slice Header SVC ext: slice_alpha_c0_offset_div2",
                            ps_cur_slice->i1_slice_alpha_c0_offset >> 1);
 
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_cur_slice->i1_slice_beta_offset = i_temp;
             COPYTHECONTEXT("Slice Header SVC ext: slice_beta_offset_div2",
                            ps_cur_slice->i1_slice_beta_offset >> 1);
         }
         else
         {
             ps_cur_slice->i1_slice_alpha_c0_offset = 0;
             ps_cur_slice->i1_slice_beta_offset = 0;
         }
     }
     else
     {
         ps_cur_slice->u1_disable_dblk_filter_idc = 0;
         ps_cur_slice->i1_slice_alpha_c0_offset = 0;
         ps_cur_slice->i1_slice_beta_offset = 0;
     }
 
     /* add the remaining part of the code for svc extension from reference */
     ret = isvcd_set_default_slice_header_ext(ps_svc_lyr_dec);
     if(ret != OK)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
 
     ret = isvcd_parse_slice_header(ps_svc_lyr_dec);
     if(ret != OK)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
 
-    ret = isvcd_parse_interlayer_resamp_func_init(ps_svc_lyr_dec, u2_first_mb_in_slice);
-    if(ret != OK)
-    {
-        return ERROR_CORRUPTED_SLICE;
-    }
     ps_dec->u1_slice_header_done = 2;
 
     if(!ps_svc_slice_params->u1_slice_skip_flag)
     {
         if(ps_pps->u1_entropy_coding_mode)
         {
             SWITCHOFFTRACE;
             SWITCHONTRACECABAC;
             ps_svc_lyr_dec->pf_parse_inter_slice_svc_ext =
                 isvcd_parse_inter_slice_data_cabac_enh_lyr;
             ps_svc_lyr_dec->pf_parse_inter_mb_svc_ext = isvcd_parse_pmb_cabac;
 
             isvcd_init_cabac_contexts(P_SLICE, ps_dec);
 
             if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
                 ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
             else
                 ps_dec->pf_get_mb_info = isvcd_get_mb_info_cabac_nonmbaff;
         }
         else
         {
             SWITCHONTRACE;
             SWITCHOFFTRACECABAC;
             ps_svc_lyr_dec->pf_parse_inter_slice_svc_ext =
                 isvcd_parse_inter_slice_data_cavlc_enh_lyr;
             ps_svc_lyr_dec->pf_parse_inter_mb_svc_ext = isvcd_parse_pmb_cavlc;
 
             if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
             {
                 ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
             }
             else
                 ps_dec->pf_get_mb_info = isvcd_get_mb_info_cavlc_nonmbaff;
         }
     }
     else
     {
         return ERROR_FEATURE_UNAVAIL;
     }
 
     ps_dec->u1_B = 0;
     ps_dec->pf_mvpred_ref_tfr_nby2mb = isvcd_mv_pred_ref_tfr_nby2_epmb;
     ret = ps_svc_lyr_dec->pf_parse_inter_slice_svc_ext(ps_svc_lyr_dec, ps_cur_slice,
                                                        u2_first_mb_in_slice);
     if(ret != OK) return ret;
 
     return OK;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_parse_inter_slice_data_cabac                       */
 /*                                                                           */
 /*  Description   : This function parses cabac syntax of a inter slice on    */
 /*                  N MB basis.                                              */
 /*                                                                           */
 /*  Inputs        : ps_dec                                                   */
 /*                  sliceparams                                              */
 /*                  firstMbInSlice                                           */
 /*                                                                           */
 /*  Processing    : 1. After parsing syntax for N MBs those N MBs are        */
 /*                     decoded till the end of slice.                        */
 /*                  2. MV prediction and DMA happens on a N/2 MB basis.      */
 /*                                                                           */
 /*  Returns       : 0                                                        */
 /*                                                                           */
 /*  Issues        : <List any issues or problems with this function>         */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         13 07 2002   Jay             Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -3221,285 +3216,283 @@ WORD32 isvcd_parse_interlayer_resamp_func_init(svc_dec_lyr_struct_t *ps_svc_lyr_
 /*!
 **************************************************************************
 * \if Function name : isvcd_decode_pslice \endif
 *
 * \brief
 *    Decodes a P Slice
 *
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_pslice(svc_dec_lyr_struct_t *ps_svc_lyr_dec, UWORD16 u2_first_mb_in_slice)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
     dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
     UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag;
     UWORD64 u8_ref_idx_l0;
     UWORD32 u4_temp;
     WORD32 i_temp;
     WORD32 ret;
     WORD64 i8_temp;
 
     /*--------------------------------------------------------------------*/
     /* Read remaining contents of the slice header                        */
     /*--------------------------------------------------------------------*/
     {
         WORD8 *pi1_buf;
         WORD16 *pi2_mv = ps_dec->s_default_mv_pred.i2_mv;
         WORD32 *pi4_mv = (WORD32 *) pi2_mv;
         WORD16 *pi16_refFrame;
 
         pi1_buf = ps_dec->s_default_mv_pred.i1_ref_frame;
         pi16_refFrame = (WORD16 *) pi1_buf;
         *pi4_mv = 0;
         *(pi4_mv + 1) = 0;
         *pi16_refFrame = OUT_OF_RANGE_REF;
         ps_dec->s_default_mv_pred.u1_col_ref_pic_idx = (UWORD8) -1;
         ps_dec->s_default_mv_pred.u1_pic_type = (UWORD8) -1;
     }
 
     ps_cur_slice->u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264(ps_bitstrm);
     COPYTHECONTEXT("SH: num_ref_idx_override_flag",
                    ps_cur_slice->u1_num_ref_idx_active_override_flag);
 
     u8_ref_idx_l0 = ps_dec->ps_cur_pps->u1_num_ref_idx_lx_active[0];
     if(ps_cur_slice->u1_num_ref_idx_active_override_flag)
     {
         u8_ref_idx_l0 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf) + (UWORD64) 1;
     }
 
     {
         UWORD8 u1_max_ref_idx = H264_MAX_REF_PICS << u1_field_pic_flag;
         if(u8_ref_idx_l0 >= u1_max_ref_idx)
         {
             return ERROR_NUM_REF;
         }
         ps_cur_slice->u1_num_ref_idx_lx_active[0] = (UWORD8) u8_ref_idx_l0;
         COPYTHECONTEXT("SH: num_ref_idx_l0_active_minus1",
                        ps_cur_slice->u1_num_ref_idx_lx_active[0] - 1);
     }
 
     {
         UWORD8 uc_refIdxReFlagL0 = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SH: ref_pic_list_reordering_flag_l0", uc_refIdxReFlagL0);
 
         ih264d_init_ref_idx_lx_p(ps_dec);
         /* Store the value for future slices in the same picture */
         ps_dec->u1_num_ref_idx_lx_active_prev = ps_cur_slice->u1_num_ref_idx_lx_active[0];
 
         /* Modified temporarily */
         if(uc_refIdxReFlagL0)
         {
             WORD8 ret;
             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
             ret = ih264d_ref_idx_reordering(ps_dec, 0);
             if(ret == -1) return ERROR_REFIDX_ORDER_T;
             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_mod_dpb[0];
         }
         else
             ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0];
     }
     /* Create refIdx to POC mapping */
     {
         void **pui_map_ref_idx_to_poc_lx0, **pui_map_ref_idx_to_poc_lx1;
         WORD8 idx;
         struct pic_buffer_t *ps_pic;
 
         pui_map_ref_idx_to_poc_lx0 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L0;
         pui_map_ref_idx_to_poc_lx0[0] = 0;
         pui_map_ref_idx_to_poc_lx0++;
         for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
         {
             ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
             pui_map_ref_idx_to_poc_lx0[idx] = (ps_pic->pu1_buf1);
         }
 
         /* Bug Fix Deblocking */
         pui_map_ref_idx_to_poc_lx1 = ps_dec->ppv_map_ref_idx_to_poc + FRM_LIST_L1;
         pui_map_ref_idx_to_poc_lx1[0] = 0;
 
         if(u1_mbaff)
         {
             void **ppv_map_ref_idx_to_poc_lx_t, **ppv_map_ref_idx_to_poc_lx_b;
             void **ppv_map_ref_idx_to_poc_lx_t1, **ppv_map_ref_idx_to_poc_lx_b1;
             ppv_map_ref_idx_to_poc_lx_t = ps_dec->ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L0;
             ppv_map_ref_idx_to_poc_lx_b = ps_dec->ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L0;
             ppv_map_ref_idx_to_poc_lx_t[0] = 0;
             ppv_map_ref_idx_to_poc_lx_t++;
             ppv_map_ref_idx_to_poc_lx_b[0] = 0;
             ppv_map_ref_idx_to_poc_lx_b++;
             idx = 0;
             for(idx = 0; idx < ps_cur_slice->u1_num_ref_idx_lx_active[0]; idx++)
             {
                 ps_pic = ps_dec->ps_ref_pic_buf_lx[0][idx];
                 ppv_map_ref_idx_to_poc_lx_t[0] = (ps_pic->pu1_buf1);
                 ppv_map_ref_idx_to_poc_lx_b[1] = (ps_pic->pu1_buf1);
                 ppv_map_ref_idx_to_poc_lx_b[0] = (ps_pic->pu1_buf1) + 1;
                 ppv_map_ref_idx_to_poc_lx_t[1] = (ps_pic->pu1_buf1) + 1;
                 ppv_map_ref_idx_to_poc_lx_t += 2;
                 ppv_map_ref_idx_to_poc_lx_b += 2;
             }
             ppv_map_ref_idx_to_poc_lx_t1 = ps_dec->ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L1;
             ppv_map_ref_idx_to_poc_lx_t1[0] = 0;
             ppv_map_ref_idx_to_poc_lx_b1 = ps_dec->ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L1;
             ppv_map_ref_idx_to_poc_lx_b1[0] = 0;
         }
     }
     if(ps_pps->u1_wted_pred_flag)
     {
         ret = ih264d_parse_pred_weight_table(ps_cur_slice, ps_bitstrm);
         if(ret != OK) return ret;
 
         ih264d_form_pred_weight_matrix(ps_dec);
         ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
     }
     else
     {
         ps_dec->ps_cur_slice->u2_log2Y_crwd = 0;
         ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat;
     }
 
     ps_dec->ps_parse_cur_slice->u2_log2Y_crwd = ps_dec->ps_cur_slice->u2_log2Y_crwd;
 
     if(u1_mbaff && (u1_field_pic_flag == 0))
     {
         ih264d_convert_frm_mbaff_list(ps_dec);
     }
 
     /* G050 */
     if(ps_cur_slice->u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
         {
             dec_pic_params_t *ps_pps = ps_dec->ps_cur_pps;
             dec_seq_params_t *ps_sps_tmp = ps_pps->ps_sps;
             UWORD8 u1_nal_unit_type_tmp = ps_dec->u1_nal_unit_type;
 
             ps_pps->ps_sps = ps_dec->ps_cur_sps;
             if(ps_svc_lyr_dec->ps_nal_svc_ext->u1_idr_flag)
                 ps_dec->u1_nal_unit_type = IDR_SLICE_NAL;
 
             i_temp = ih264d_read_mmco_commands(ps_dec);
 
             ps_pps->ps_sps = ps_sps_tmp;
             ps_dec->u1_nal_unit_type = u1_nal_unit_type_tmp;
 
             if(i_temp < 0)
             {
                 return ERROR_DBP_MANAGER_T;
             }
             ps_dec->u4_bitoffset = i_temp;
         }
         else
             ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
     }
     /* G050 */
 
     if(ps_pps->u1_entropy_coding_mode == CABAC)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
         if(u4_temp > MAX_CABAC_INIT_IDC)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
         ps_cur_slice->u1_cabac_init_idc = u4_temp;
         COPYTHECONTEXT("SH: cabac_init_idc", ps_cur_slice->u1_cabac_init_idc);
     }
 
     /* Read slice_qp_delta */
     i8_temp = (WORD64) ps_pps->u1_pic_init_qp + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if((i8_temp < MIN_H264_QP) || (i8_temp > MAX_H264_QP))
     {
         return ERROR_INV_RANGE_QP_T;
     }
     ps_cur_slice->u1_slice_qp = (UWORD8) i8_temp;
     COPYTHECONTEXT("SH: slice_qp_delta",
                    (WORD8) (ps_cur_slice->u1_slice_qp - ps_pps->u1_pic_init_qp));
 
     if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
         {
             return ERROR_INV_SLICE_HDR_T;
         }
 
         COPYTHECONTEXT("SH: disable_deblocking_filter_idc", u4_temp);
         ps_cur_slice->u1_disable_dblk_filter_idc = u4_temp;
         if(u4_temp != 1)
         {
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_cur_slice->i1_slice_alpha_c0_offset = i_temp;
             COPYTHECONTEXT("SH: slice_alpha_c0_offset_div2",
                            ps_cur_slice->i1_slice_alpha_c0_offset >> 1);
 
             i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf) << 1;
             if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
             {
                 return ERROR_INV_SLICE_HDR_T;
             }
             ps_cur_slice->i1_slice_beta_offset = i_temp;
             COPYTHECONTEXT("SH: slice_beta_offset_div2", ps_cur_slice->i1_slice_beta_offset >> 1);
         }
         else
         {
             ps_cur_slice->i1_slice_alpha_c0_offset = 0;
             ps_cur_slice->i1_slice_beta_offset = 0;
         }
     }
     else
     {
         ps_cur_slice->u1_disable_dblk_filter_idc = 0;
         ps_cur_slice->i1_slice_alpha_c0_offset = 0;
         ps_cur_slice->i1_slice_beta_offset = 0;
     }
 
-    isvcd_parse_interlayer_resamp_func_init(ps_svc_lyr_dec, u2_first_mb_in_slice);
-
     ps_dec->u1_slice_header_done = 2;
     if(ps_pps->u1_entropy_coding_mode)
     {
         SWITCHOFFTRACE;
         SWITCHONTRACECABAC;
         ps_svc_lyr_dec->pf_parse_svc_inter_slice = isvcd_parse_inter_slice_data_cabac;
         ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cabac;
         ih264d_init_cabac_contexts(P_SLICE, ps_dec);
 
         if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
         else
             ps_dec->pf_get_mb_info = isvcd_get_mb_info_cabac_nonmbaff;
     }
     else
     {
         SWITCHONTRACE;
         SWITCHOFFTRACECABAC;
         ps_svc_lyr_dec->pf_parse_svc_inter_slice = isvcd_parse_inter_slice_data_cavlc;
         ps_dec->pf_parse_inter_mb = ih264d_parse_pmb_cavlc;
         if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
         {
             ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
         }
         else
             ps_dec->pf_get_mb_info = isvcd_get_mb_info_cavlc_nonmbaff;
     }
 
     ps_dec->u1_B = 0;
     ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
     ret = ps_svc_lyr_dec->pf_parse_svc_inter_slice(ps_svc_lyr_dec, ps_cur_slice,
                                                    u2_first_mb_in_slice);
     if(ret != OK) return ret;
 
     return OK;
 }
diff --git a/decoder/svc/isvcd_parse_slice.c b/decoder/svc/isvcd_parse_slice.c
index 2dfba52..0ebe265 100644
--- a/decoder/svc/isvcd_parse_slice.c
+++ b/decoder/svc/isvcd_parse_slice.c
@@ -640,933 +640,934 @@ WORD32 isvcd_start_of_pic(svc_dec_lyr_struct_t *ps_svc_lyr_dec, WORD32 i4_poc,
     ps_dec->u4_first_slice_in_pic = 0;
     H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex);
     return OK;
 }
 /*!
 **************************************************************************
 * \if Function name : isvcd_parse_decode_slice_ext_nal \endif
 *
 * \brief
 *    Parses a slice extension NAL
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_decode_slice_ext_nal(UWORD8 u1_is_idr_slice, UWORD8 u1_nal_ref_idc,
                                         svc_dec_lyr_struct_t *ps_svc_lyr_dec)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
     dec_pic_params_t *ps_pps;
     dec_seq_params_t *ps_seq;
     dec_svc_seq_params_t *ps_subset_seq;
     dec_slice_params_t *ps_cur_slice = NULL;
     dec_slice_svc_ext_params_t *ps_svc_slice_params = NULL;
 
     pocstruct_t s_tmp_poc = {0};
     WORD32 i_delta_poc[2] = {0};
     WORD32 i4_poc = 0;
     UWORD16 u2_first_mb_in_slice, u2_frame_num;
     UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;
     UWORD32 u4_idr_pic_id = 0;
     UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;
 
     UWORD8 u1_nal_unit_type;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     WORD8 i1_is_end_of_poc;
     WORD32 ret;
     WORD32 prev_slice_err, num_mb_skipped;
     UWORD8 u1_mbaff;
     pocstruct_t *ps_cur_poc;
     UWORD32 u4_temp;
     WORD32 i_temp;
     svc_dec_ctxt_t *psvcd_dec_ctxt;
     dec_struct_t *ps_dec_cur_lyr_minus_1;
     svc_dec_lyr_struct_t *ps_svc_cur_lyr_dec_minus_1;
 
     ps_cur_slice = ps_dec->ps_cur_slice;
     ps_svc_slice_params = &ps_svc_lyr_dec->s_svc_slice_params;
 
     /* read FirstMbInSlice  and slice type*/
     ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;
     u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u2_first_mb_in_slice > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))
     {
         return ERROR_CORRUPTED_SLICE;
     }
 
     /*we currently don not support ASO*/
     if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag) <= ps_dec->u2_cur_mb_addr) &&
        (ps_dec->u4_first_slice_in_pic == 0))
     {
         return ERROR_CORRUPTED_SLICE;
     }
 
-    if(ps_svc_lyr_dec->u1_first_mb_addr_check == 1)
+    if(ps_dec->u4_first_slice_in_pic == 1)
     {
         if(u2_first_mb_in_slice != 0)
         {
             return ERROR_CORRUPTED_SLICE;
         }
-        else
-        {
-            ps_svc_lyr_dec->u1_first_mb_addr_check = 0;
-        }
     }
 
     COPYTHECONTEXT("Slice Header SVC ext: first_mb_in_slice", u2_first_mb_in_slice);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 
     if(u4_temp > 9) return ERROR_INV_SLC_TYPE_T;
 
     u1_slice_type = u4_temp;
     COPYTHECONTEXT("Slice Header SVC ext: slice_type", (u1_slice_type));
     /* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */
     /* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/
     /* will be of same type of current                            */
     if(u1_slice_type > 4)
     {
         u1_slice_type -= 5;
     }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_PIC_SET_ID) return ERROR_INV_SLICE_HDR_T;
     /* discard slice if pic param is invalid */
     COPYTHECONTEXT("Slice Header SVC ext: pic_parameter_set_id", u4_temp);
     ps_pps = &ps_dec->ps_pps[u4_temp];
     if(FALSE == ps_pps->u1_is_valid)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
     /* slices in a layer should have same PPS id*/
     if(UINT32_MAX == ps_svc_lyr_dec->u4_pps_id_for_layer)
     {
         ps_svc_lyr_dec->u4_pps_id_for_layer = u4_temp;
     }
     else if(u4_temp != ps_svc_lyr_dec->u4_pps_id_for_layer)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
     ps_seq = ps_pps->ps_sps;
     ps_seq += MAX_NUM_SEQ_PARAMS;
     ps_subset_seq =
         &ps_svc_lyr_dec->ps_subset_sps[MAX_NUM_SEQ_PARAMS + ps_seq->u1_seq_parameter_set_id];
 
     ps_dec->ps_cur_sps = ps_seq;
     ps_svc_lyr_dec->ps_cur_subset_sps = ps_subset_seq;
 
     if(!ps_seq) return ERROR_INV_SLICE_HDR_T;
     if(FALSE == ps_seq->u1_is_valid) return ERROR_INV_SLICE_HDR_T;
     if(ps_seq->u1_mb_aff_flag) return ERROR_INV_SLICE_HDR_T;
     if(ps_seq->u1_level_idc > H264_LEVEL_4_2) return ERROR_INV_SLICE_HDR_T;
     if(!ps_seq->u1_frame_mbs_only_flag) return ERROR_INV_SLICE_HDR_T;
     if(OK != isvcd_verify_level(ps_seq->u1_level_idc)) return ERROR_INV_SLICE_HDR_T;
 
     if(ps_dec->u1_init_dec_flag == 1)
     {
         if(ps_dec->u2_frm_wd_in_mbs != ps_seq->u2_frm_wd_in_mbs) return ERROR_INV_SLICE_HDR_T;
         if(ps_dec->u2_frm_ht_in_mbs != ps_seq->u2_frm_ht_in_mbs) return ERROR_INV_SLICE_HDR_T;
     }
 
     ps_dec->i4_reorder_depth = ps_subset_seq->i4_reorder_depth;
 
     ps_dec->u2_disp_height = ps_subset_seq->u2_disp_height;
     ps_dec->u2_disp_width = ps_subset_seq->u2_disp_width;
 
     if(ps_svc_lyr_dec->u1_layer_id > 0)
     {
         psvcd_dec_ctxt = ps_svc_lyr_dec->ps_svcd_ctxt;
         ps_svc_cur_lyr_dec_minus_1 =
             &psvcd_dec_ctxt->ps_svc_dec_lyr[ps_svc_lyr_dec->u1_layer_id - 1];
 
         ps_dec_cur_lyr_minus_1 = &ps_svc_cur_lyr_dec_minus_1->s_dec;
 
         if((ps_dec_cur_lyr_minus_1->u2_pic_wd > ps_subset_seq->u2_pic_wd) ||
            (ps_dec_cur_lyr_minus_1->u2_pic_ht > ps_subset_seq->u2_pic_ht))
         {
             return ERROR_CORRUPTED_SLICE;
         }
     }
 
     ps_dec->u2_pic_wd = ps_subset_seq->u2_pic_wd;
     ps_dec->u2_pic_ht = ps_subset_seq->u2_pic_ht;
     ps_dec->u4_total_mbs = ps_seq->u2_total_num_of_mbs << (1 - ps_seq->u1_frame_mbs_only_flag);
 
     /* Determining the Width and Height of Frame from that of Picture */
     ps_dec->u2_frm_wd_y = ps_subset_seq->u2_frm_wd_y;
     ps_dec->u2_frm_ht_y = ps_subset_seq->u2_frm_ht_y;
 
     ps_dec->u2_frm_wd_uv = ps_subset_seq->u2_frm_wd_uv;
     ps_dec->u2_frm_ht_uv = ps_subset_seq->u2_frm_ht_uv;
 
     ps_dec->s_pad_mgr.u1_pad_len_y_v = ps_subset_seq->u1_pad_len_y_v;
     ps_dec->s_pad_mgr.u1_pad_len_cr_v = ps_subset_seq->u1_pad_len_cr_v;
 
     ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
     ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
 
     ps_dec->u2_crop_offset_y = ps_subset_seq->u2_crop_offset_y;
     ps_dec->u2_crop_offset_uv = ps_subset_seq->u2_crop_offset_uv;
 
     /* Get the frame num */
     u2_frame_num = ih264d_get_bits_h264(ps_bitstrm, ps_seq->u1_bits_in_frm_num);
 
     COPYTHECONTEXT("Slice Header SVC ext: frame_num", u2_frame_num);
     if(!ps_dec->u1_first_slice_in_stream && ps_dec->u4_first_slice_in_pic)
     {
         pocstruct_t *ps_prev_poc = &ps_dec->s_prev_pic_poc;
         pocstruct_t *ps_cur_poc = &ps_dec->s_cur_pic_poc;
 
         ps_dec->u2_mbx = 0xffff;
         ps_dec->u2_mby = 0;
 
         if((0 == u1_is_idr_slice) && ps_cur_slice->u1_nal_ref_idc)
             ps_dec->u2_prev_ref_frame_num = ps_cur_slice->u2_frame_num;
 
         if(u1_is_idr_slice || ps_cur_slice->u1_mmco_equalto5) ps_dec->u2_prev_ref_frame_num = 0;
 
         if(ps_dec->ps_cur_sps->u1_gaps_in_frame_num_value_allowed_flag)
         {
             isvcd_decode_gaps_in_frame_num(ps_dec, u2_frame_num);
         }
 
         ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
         ps_prev_poc->u2_frame_num = ps_cur_poc->u2_frame_num;
         ps_prev_poc->u1_mmco_equalto5 = ps_cur_slice->u1_mmco_equalto5;
         if(ps_cur_slice->u1_nal_ref_idc)
         {
             ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
             ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
             ps_prev_poc->i4_delta_pic_order_cnt_bottom = ps_cur_poc->i4_delta_pic_order_cnt_bottom;
             ps_prev_poc->i4_delta_pic_order_cnt[0] = ps_cur_poc->i4_delta_pic_order_cnt[0];
             ps_prev_poc->i4_delta_pic_order_cnt[1] = ps_cur_poc->i4_delta_pic_order_cnt[1];
             ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field;
         }
 
         ps_dec->u2_total_mbs_coded = 0;
     }
     /* Get the field related flags  */
     if(!ps_seq->u1_frame_mbs_only_flag)
     {
         u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("Slice Header SVC ext: field_pic_flag", u1_field_pic_flag);
         u1_bottom_field_flag = 0;
 
         if(u1_field_pic_flag)
         {
             ps_dec->pu1_inv_scan = (UWORD8 *) gau1_ih264d_inv_scan_fld;
             u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("Slice Header SVC ext: bottom_field_flag", u1_bottom_field_flag);
         }
         else
         {
             ps_dec->pu1_inv_scan = (UWORD8 *) gau1_ih264d_inv_scan;
         }
     }
     else
     {
         u1_field_pic_flag = 0;
         u1_bottom_field_flag = 0;
         ps_dec->pu1_inv_scan = (UWORD8 *) gau1_ih264d_inv_scan;
     }
 
     u1_nal_unit_type = SLICE_NAL;
     if(u1_is_idr_slice)
     {
         u1_nal_unit_type = IDR_SLICE_NAL;
         u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_idr_pic_id > 65535) return ERROR_INV_SLICE_HDR_T;
         COPYTHECONTEXT("Slice Header SVC ext:  ", u4_idr_pic_id);
     }
 
     /* read delta pic order count information*/
     i_delta_poc[0] = i_delta_poc[1] = 0;
     s_tmp_poc.i4_pic_order_cnt_lsb = 0;
     s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
     u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;
     if(u1_pic_order_cnt_type == 0)
     {
         i_temp = ih264d_get_bits_h264(ps_bitstrm, ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);
         if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb) return ERROR_INV_SLICE_HDR_T;
         s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;
         COPYTHECONTEXT("Slice Header SVC ext: pic_order_cnt_lsb", s_tmp_poc.i4_pic_order_cnt_lsb);
 
         if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))
         {
             s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("Slice Header SVC ext: delta_pic_order_cnt_bottom",
                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);
         }
     }
 
     s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;
     s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;
     if(u1_pic_order_cnt_type == 1 && (!ps_seq->u1_delta_pic_order_always_zero_flag))
     {
         s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("Slice Header SVC ext: delta_pic_order_cnt[0]",
                        s_tmp_poc.i4_delta_pic_order_cnt[0]);
 
         if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)
         {
             s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("Slice Header SVC ext: delta_pic_order_cnt[1]",
                            s_tmp_poc.i4_delta_pic_order_cnt[1]);
         }
     }
 
     if(ps_pps->u1_redundant_pic_cnt_present_flag)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > MAX_REDUNDANT_PIC_CNT) return ERROR_INV_SLICE_HDR_T;
         u1_redundant_pic_cnt = u4_temp;
         COPYTHECONTEXT("Slice Header SVC ext: redundant_pic_cnt", u1_redundant_pic_cnt);
     }
 
     /*--------------------------------------------------------------------*/
     /* Check if the slice is part of new picture                          */
     /*--------------------------------------------------------------------*/
     /* First slice of a picture is always considered as part of new picture */
     i1_is_end_of_poc = 1;
     ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;
 
     if(ps_dec->u4_first_slice_in_pic == 0)
     {
         i1_is_end_of_poc =
             ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc, &s_tmp_poc, &ps_dec->s_cur_pic_poc,
                                  ps_cur_slice, u1_pic_order_cnt_type, u1_nal_unit_type,
                                  u4_idr_pic_id, u1_field_pic_flag, u1_bottom_field_flag);
         if(i1_is_end_of_poc)
         {
             ps_dec->u1_first_slice_in_stream = 0;
             return ERROR_INCOMPLETE_FRAME;
         }
     }
 
     /*--------------------------------------------------------------------*/
     /* Check for error in slice and parse the missing/corrupted MB's      */
     /* as skip-MB's in an inserted P-slice                                */
     /*--------------------------------------------------------------------*/
     u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);
     prev_slice_err = 0;
 
     if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)
     {
         /* If the current slice is not a field or frame number of the current
          * slice doesn't match with previous slice, and decoder is expecting
          * to decode a field i.e. ps_dec->u1_top_bottom_decoded is not 0 and
          * is not (TOP_FIELD_ONLY | BOT_FIELD_ONLY), treat it as a dangling
          * field */
         if((u1_field_pic_flag == 0 || u2_frame_num != ps_dec->u2_prv_frame_num) &&
            ps_dec->u1_top_bottom_decoded != 0 &&
            ps_dec->u1_top_bottom_decoded != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))
         {
             ps_dec->u1_dangling_field = 1;
             if(ps_dec->u4_first_slice_in_pic)
             {
                 // first slice - dangling field
                 prev_slice_err = 1;
             }
             else
             {
                 // last slice - dangling field
                 prev_slice_err = 2;
             }
 
             if(ps_dec->u1_top_bottom_decoded == TOP_FIELD_ONLY)
                 ps_cur_slice->u1_bottom_field_flag = 1;
             else
                 ps_cur_slice->u1_bottom_field_flag = 0;
 
             num_mb_skipped =
                 (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs) - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &ps_dec->s_cur_pic_poc;
 
             u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;
         }
         else if(ps_dec->u4_first_slice_in_pic)
         {
             if(u2_first_mb_in_slice > 0)
             {
                 // first slice - missing/header corruption
                 prev_slice_err = 1;
                 num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
                 ps_cur_poc = &s_tmp_poc;
 
                 // initializing slice parameters
                 ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
                 ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
                 ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
                 ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;
                 ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
                 ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
                 ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
                 ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
                 ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);
             }
         }
         else
         {
             /* since i1_is_end_of_poc is set ,means new frame num is encountered. so
              * conceal the current frame completely */
             prev_slice_err = 2;
             num_mb_skipped =
                 (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs) - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &s_tmp_poc;
         }
     }
     else
     {
         if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)
         {
             // previous slice - missing/corruption
             prev_slice_err = 2;
             num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff) - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &s_tmp_poc;
         }
         else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)
         {
             return ERROR_CORRUPTED_SLICE;
         }
     }
     if(prev_slice_err)
     {
         ret = isvcd_mark_err_slice_skip((svc_dec_lyr_struct_t *) ps_dec, num_mb_skipped,
                                         u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);
 
         if(ps_dec->u1_dangling_field == 1)
         {
             ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;
             ps_dec->u1_first_slice_in_stream = 0;
             ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
             return ERROR_DANGLING_FIELD_IN_PIC;
         }
 
         if(prev_slice_err == 2)
         {
             ps_dec->u1_first_slice_in_stream = 0;
             return ERROR_INCOMPLETE_FRAME;
         }
 
         if(ps_dec->u2_total_mbs_coded >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
         {
             /* return if all MBs in frame are parsed*/
             ps_dec->u1_first_slice_in_stream = 0;
             return ERROR_IN_LAST_SLICE_OF_PIC;
         }
 
         if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
         {
             ih264d_err_pic_dispbuf_mgr(ps_dec);
             return ERROR_NEW_FRAME_EXPECTED;
         }
 
         if(ret != OK) return ret;
 
         i1_is_end_of_poc = 0;
     }
 
     if(u1_field_pic_flag)
     {
         ps_dec->u2_prv_frame_num = u2_frame_num;
     }
 
     if(ps_cur_slice->u1_mmco_equalto5)
     {
         WORD32 i4_temp_poc;
         WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
         WORD64 i8_result;
         if(!ps_cur_slice->u1_field_pic_flag)  // or a complementary field pair
         {
             i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
             i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
             i4_temp_poc = MIN(i4_top_field_order_poc, i4_bot_field_order_poc);
         }
         else if(!ps_cur_slice->u1_bottom_field_flag)
             i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         else
             i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
 
         i8_result = (WORD64) i4_temp_poc - ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         if(IS_OUT_OF_RANGE_S32(i8_result))
         {
             return ERROR_INV_POC;
         }
         ps_dec->ps_cur_pic->i4_top_field_order_cnt = (WORD32) i8_result;
         i8_result = (WORD64) i4_temp_poc - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
         if(IS_OUT_OF_RANGE_S32(i8_result))
         {
             return ERROR_INV_POC;
         }
         ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = (WORD32) i8_result;
         ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;
         ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
     }
     if(ps_dec->u4_first_slice_in_pic)
     {
         ret = isvcd_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num, &ps_dec->s_prev_pic_poc,
                                          &s_tmp_poc, ps_cur_slice, ps_pps, u1_nal_ref_idc,
                                          u1_bottom_field_flag, u1_field_pic_flag, &i4_poc, ps_dec);
         if(ret != OK) return ret;
         /* Display seq no calculations */
         if(i4_poc >= ps_dec->i4_max_poc) ps_dec->i4_max_poc = i4_poc;
         /* IDR Picture or POC wrap around */
         if(i4_poc == 0)
         {
             WORD64 i8_temp;
             i8_temp = (WORD64) ps_dec->i4_prev_max_display_seq + ps_dec->i4_max_poc +
                       ps_dec->u1_max_dec_frame_buffering + 1;
             /*If i4_prev_max_display_seq overflows integer range, reset it */
             ps_dec->i4_prev_max_display_seq = IS_OUT_OF_RANGE_S32(i8_temp) ? 0 : i8_temp;
             ps_dec->i4_max_poc = 0;
         }
     }
 
     /* Increment only if the current slice has atleast 1 more MB */
     if(ps_dec->u4_first_slice_in_pic == 0 &&
        (ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <
         (UWORD32) (ps_dec->u2_total_mbs_coded >> ps_dec->ps_cur_slice->u1_mbaff_frame_flag)))
     {
         ps_dec->ps_parse_cur_slice++;
         ps_dec->u2_cur_slice_num++;
         // in the case of single core increment ps_decode_cur_slice
         if(ps_dec->u1_separate_parse == 0)
         {
             ps_dec->ps_decode_cur_slice++;
         }
     }
 
     ps_dec->u1_slice_header_done = 0;
 
     /*--------------------------------------------------------------------*/
     /* Copy the values read from the bitstream to the slice header and then*/
     /* If the slice is first slice in picture, then do Start of Picture   */
     /* processing.                                                        */
     /*--------------------------------------------------------------------*/
     ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];
     ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];
     ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
     ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;
     ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
     ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
     ps_cur_slice->u1_slice_type = u1_slice_type;
     ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;
 
     ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
     ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
     ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
     ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
 
     if(ps_seq->u1_frame_mbs_only_flag)
         ps_cur_slice->u1_direct_8x8_inference_flag = ps_seq->u1_direct_8x8_inference_flag;
     else
         ps_cur_slice->u1_direct_8x8_inference_flag = 1;
 
     if(0 == ps_svc_lyr_dec->ps_nal_svc_ext->u1_quality_id)
     {
         if(B_SLICE == u1_slice_type)
         {
             ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("Slice Header SVC ext: direct_spatial_mv_pred_flag",
                            ps_cur_slice->u1_direct_spatial_mv_pred_flag);
 
             if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)
                 ps_cur_slice->pf_decodeDirect = isvcd_decode_spatial_direct;
             else
                 ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;
             if(!((ps_seq->u1_mb_aff_flag) && (!u1_field_pic_flag)))
                 ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;
         }
         else
         {
             if(!((ps_seq->u1_mb_aff_flag) && (!u1_field_pic_flag))) /*check if this is valid here */
                 ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
         }
     }
 
     if(ps_dec->u4_first_slice_in_pic)
     {
         if(u2_first_mb_in_slice == 0)
         {
             ret = isvcd_start_of_pic(ps_svc_lyr_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);
             if(ret != OK) return ret;
             /*inter layer buffer intialization */
             ps_svc_lyr_dec->ps_inter_lyr_mb_prms_cur_mb =
                 ps_svc_lyr_dec->ps_inter_lyr_mb_prms_frm_start;
             ps_svc_lyr_dec->ps_il_pred_mv_bank_buf_cur_mb =
                 ps_svc_lyr_dec->ps_il_pred_mv_bank_buf_base;
         }
 
         ps_dec->u4_output_present = 0;
 
         {
             ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer, &(ps_dec->s_disp_op));
             /* If error code is non-zero then there is no buffer available for
             display, hence avoid format conversion */
 
             if(0 != ps_dec->s_disp_op.u4_error_code)
             {
                 ps_dec->u4_output_present = 0;
                 ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
             }
             else
                 ps_dec->u4_output_present = 1;
         }
+        ret = isvcd_parse_interlayer_resamp_func_init(ps_svc_lyr_dec, u2_first_mb_in_slice);
+        if(ret != OK)
+        {
+            return ERROR_CORRUPTED_SLICE;
+        }
         if((ps_dec->u1_separate_parse == 1) &&
-           (ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER))
+           (ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER) && (ps_svc_lyr_dec->u1_res_init_done == 1))
         {
             if(ps_dec->u4_dec_thread_created == 0)
             {
                 ithread_create(ps_dec->pv_dec_thread_handle, NULL,
                                (void *) isvcd_decode_picture_thread, (void *) ps_dec);
 
                 ps_dec->u4_dec_thread_created = 1;
             }
 #ifdef KEEP_THREADS_ACTIVE
             ret = ithread_mutex_lock(ps_dec->apv_proc_start_mutex[0]);
             RETURN_IF((ret != IV_SUCCESS), ret);
 
             ps_dec->ai4_process_start[0] = PROC_START;
             ret = ithread_cond_signal(ps_dec->apv_proc_start_condition[0]);
             RETURN_IF((ret != IV_SUCCESS), ret);
 
             ret = ithread_mutex_unlock(ps_dec->apv_proc_start_mutex[0]);
             RETURN_IF((ret != IV_SUCCESS), ret);
 #endif
 #ifdef KEEP_THREADS_ACTIVE
             if(ps_dec->u4_bs_deblk_thread_created)
             {
                 ret = ithread_mutex_lock(ps_dec->apv_proc_start_mutex[1]);
                 RETURN_IF((ret != IV_SUCCESS), ret);
 
                 ps_dec->ai4_process_start[1] = PROC_START;
                 ret = ithread_cond_signal(ps_dec->apv_proc_start_condition[1]);
                 RETURN_IF((ret != IV_SUCCESS), ret);
 
                 ret = ithread_mutex_unlock(ps_dec->apv_proc_start_mutex[1]);
                 RETURN_IF((ret != IV_SUCCESS), ret);
             }
 #endif
         }
     }
 
     /* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */
     {
         UWORD8 uc_nofield_nombaff;
 
         uc_nofield_nombaff =
             ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0) &&
              (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0) && (u1_slice_type != B_SLICE) &&
              (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));
 
         /* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */
 
         if(uc_nofield_nombaff)
         {
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
         }
         else
         {
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;
         }
     }
 
     /*
      * Decide whether to decode the current picture or not
      */
     {
         dec_err_status_t *ps_err = ps_dec->ps_dec_err_status;
         if(ps_err->u4_frm_sei_sync == u2_frame_num)
         {
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
             ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
         }
         ps_err->u4_cur_frm = u2_frame_num;
     }
 
     /* Decision for decoding if the picture is to be skipped */
     {
         WORD32 i4_skip_b_pic, i4_skip_p_pic;
 
         i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT) && (B_SLICE == u1_slice_type) &&
                         (0 == u1_nal_ref_idc);
 
         i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT) && (P_SLICE == u1_slice_type) &&
                         (0 == u1_nal_ref_idc);
 
         /**************************************************************/
         /* Skip the B picture if skip mask is set for B picture and   */
         /* Current B picture is a non reference B picture or there is */
         /* no user for reference B picture                            */
         /**************************************************************/
         if(i4_skip_b_pic)
         {
             ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
             /* Don't decode the picture in SKIP-B mode if that picture is B */
             /* and also it is not to be used as a reference picture         */
             ps_dec->u1_last_pic_not_decoded = 1;
 
             return OK;
         }
         /**************************************************************/
         /* Skip the P picture if skip mask is set for P picture and   */
         /* Current P picture is a non reference P picture or there is */
         /* no user for reference P picture                            */
         /**************************************************************/
         if(i4_skip_p_pic)
         {
             ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
             /* Don't decode the picture in SKIP-P mode if that picture is P */
             /* and also it is not to be used as a reference picture         */
             ps_dec->u1_last_pic_not_decoded = 1;
 
             return OK;
         }
     }
 
     {
         UWORD16 u2_mb_x, u2_mb_y;
 
         ps_dec->i4_submb_ofst =
             ((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE) -
             SUB_BLK_SIZE;
         if(u2_first_mb_in_slice)
         {
             UWORD8 u1_mb_aff;
             UWORD8 u1_field_pic;
             UWORD16 u2_frm_wd_in_mbs;
             u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
             u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;
             u1_field_pic = ps_cur_slice->u1_field_pic_flag;
 
             {
                 UWORD32 x_offset;
                 UWORD32 y_offset;
                 UWORD32 u4_frame_stride;
                 tfr_ctxt_t *ps_trns_addr;  // = &ps_dec->s_tran_addrecon_parse;
 
                 if(ps_dec->u1_separate_parse)
                 {
                     ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
                 }
                 else
                 {
                     ps_trns_addr = &ps_dec->s_tran_addrecon;
                 }
                 u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
                 u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
 
                 u2_mb_y <<= u1_mb_aff;
 
                 if((u2_mb_x > u2_frm_wd_in_mbs - 1) || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))
                 {
                     return ERROR_CORRUPTED_SLICE;
                 }
 
                 u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;
                 x_offset = u2_mb_x << 4;
                 y_offset = (u2_mb_y * u4_frame_stride) << 4;
 
                 ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset + y_offset;
 
                 u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;
                 x_offset >>= 1;
                 y_offset = (u2_mb_y * u4_frame_stride) << 3;
 
                 x_offset *= YUV420SP_FACTOR;
 
                 ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset + y_offset;
                 ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset + y_offset;
 
                 ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
                 ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
                 ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;
 
                 // assign the deblock structure pointers to start of slice
                 if(ps_dec->u1_separate_parse == 1)
                 {
                     ps_dec->ps_deblk_mbn =
                         ps_dec->ps_deblk_pic + (u2_first_mb_in_slice << u1_mb_aff);
                 }
                 else
                 {
                     ps_dec->ps_deblk_mbn =
                         ps_dec->ps_deblk_pic + (u2_first_mb_in_slice << u1_mb_aff);
                 }
 
                 ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);
 
                 ps_dec->ps_mv_cur =
                     ps_dec->s_cur_pic.ps_mv + ((u2_first_mb_in_slice << u1_mb_aff) << 4);
             }
         }
         else
         {
             tfr_ctxt_t *ps_trns_addr;
 
             if(ps_dec->u1_separate_parse)
             {
                 ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
             }
             else
             {
                 ps_trns_addr = &ps_dec->s_tran_addrecon;
             }
 
             u2_mb_x = 0xffff;
             u2_mb_y = 0;
             // assign the deblock structure pointers to start of slice
             ps_dec->u2_cur_mb_addr = 0;
             ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
             ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
             ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
             ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
             ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;
 
             ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
             ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
             ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;
         }
 
         ps_dec->ps_part = ps_dec->ps_parse_part_params;
 
         ps_dec->u2_mbx = (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
         ps_dec->u2_mby = (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
         ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;
         ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
         ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
     }
 
     /* RBSP stop bit is used for CABAC decoding*/
     ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;
 
     ps_dec->u1_B = (u1_slice_type == B_SLICE);
     ps_dec->u4_next_mb_skip = 0;
 
     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->ps_cur_slice->u2_first_mb_in_slice;
     ps_dec->ps_parse_cur_slice->slice_type = ps_dec->ps_cur_slice->u1_slice_type;
 
     ps_dec->u4_start_recon_deblk = 1;
     {
         WORD32 num_entries;
         WORD32 size;
         UWORD8 *pu1_buf;
 
         num_entries = MAX_FRAMES;
         if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) && (0 == ps_dec->i4_display_delay))
         {
             num_entries = 1;
         }
         num_entries = ((2 * num_entries) + 1);
         num_entries *= 2;
 
         size = num_entries * sizeof(void *);
         size += PAD_MAP_IDX_POC * sizeof(void *);
 
         pu1_buf = (UWORD8 *) ps_dec->pv_map_ref_idx_to_poc_buf;
         pu1_buf += size * ps_dec->u2_cur_slice_num;
         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (void *) pu1_buf;
     }
 
     if(ps_dec->u1_separate_parse)
     {
         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
     }
     else
     {
         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
     }
 
     ret = ih264d_fix_error_in_dpb(ps_dec);
     if(ret < 0) return ERROR_DBP_MANAGER_T;
 
     /*Default initializing default values for some parameters*/
     ps_svc_slice_params->u1_slice_skip_flag = 0;
     ps_svc_slice_params->u1_adaptive_base_mode_flag = 0;
     ps_svc_slice_params->u1_default_base_mode_flag = 0;
     ps_svc_slice_params->u1_adaptive_motion_prediction_flag = 0;
     ps_svc_slice_params->u1_default_motion_prediction_flag = 0;
     ps_svc_slice_params->u1_adaptive_residual_prediction_flag = 0;
     ps_svc_slice_params->u1_default_residual_prediction_flag = 0;
 
     if(u1_slice_type == I_SLICE)
     {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;
 
         ret = isvcd_parse_eislice(ps_svc_lyr_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)
             ps_dec->i4_pic_type = I_SLICE;
     }
     else if(u1_slice_type == P_SLICE)
     {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
         ret = isvcd_parse_epslice(ps_svc_lyr_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         if(ps_dec->i4_pic_type != B_SLICE) ps_dec->i4_pic_type = P_SLICE;
     }
     else if(u1_slice_type == B_SLICE)
     {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
         ret = isvcd_parse_ebslice(ps_svc_lyr_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         ps_dec->i4_pic_type = B_SLICE;
     }
     else
         return ERROR_INV_SLC_TYPE_T;
 
     if(ps_dec->u1_slice_header_done)
     {
         /* set to zero to indicate a valid slice has been decoded */
         ps_dec->u1_first_slice_in_stream = 0;
     }
 
     if(ret != OK) return ret;
 
     if(u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
         {
             memcpy((void *) ps_dec->ps_dpb_cmds, (void *) (&(ps_dec->s_dpb_cmds_scratch)),
                    sizeof(dpb_commands_t));
         }
     }
 
     /* storing last Mb X and MbY of the slice */
     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
 
     /* End of Picture detection */
     if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))
     {
         ps_dec->u1_pic_decode_done = 1;
     }
 
     {
         dec_err_status_t *ps_err = ps_dec->ps_dec_err_status;
         if((ps_err->u1_err_flag & REJECT_PB_PICS) && (ps_err->u1_cur_pic_type == PIC_TYPE_I))
         {
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
         }
     }
 
     PRINT_BIN_BIT_RATIO(ps_dec)
 
     return ret;
 }
 
 /*!
 **************************************************************************
 * \if Function name : isvcd_set_default_slice_header_ext \endif
 *
 * \brief
 *    sets the default values for the svc slice header attr
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
@@ -1893,900 +1894,901 @@ WORD32 isvcd_parse_slice_header(svc_dec_lyr_struct_t *ps_svc_lyr_dec)
 WORD32 isvcd_parse_decode_slice(UWORD8 u1_is_idr_slice, UWORD8 u1_nal_ref_idc,
                                 svc_dec_lyr_struct_t *ps_svc_lyr_dec /* SVC Decoder parameters */
 )
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm;
     dec_pic_params_t *ps_pps;
     dec_seq_params_t *ps_seq;
     dec_svc_seq_params_t *ps_subset_seq;
     dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
     pocstruct_t s_tmp_poc = {0};
     WORD32 i_delta_poc[2] = {0};
     WORD32 i4_poc = 0;
     UWORD16 u2_first_mb_in_slice, u2_frame_num;
     UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;
     UWORD32 u4_idr_pic_id = 0;
     UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;
     UWORD8 u1_nal_unit_type;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     WORD8 i1_is_end_of_poc;
 
     WORD32 ret;
     WORD32 prev_slice_err, num_mb_skipped;
     UWORD8 u1_mbaff;
     pocstruct_t *ps_cur_poc;
 
     UWORD32 u4_temp;
     WORD32 i_temp;
     svc_dec_ctxt_t *psvcd_dec_ctxt;
     dec_struct_t *ps_dec_cur_lyr_minus_1;
     svc_dec_lyr_struct_t *ps_svc_cur_lyr_dec_minus_1;
 
     /* read FirstMbInSlice  and slice type*/
     ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;
     u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u2_first_mb_in_slice > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))
     {
         return ERROR_CORRUPTED_SLICE;
     }
 
     /*we currently don not support ASO*/
     if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag) <= ps_dec->u2_cur_mb_addr) &&
        (ps_dec->u4_first_slice_in_pic == 0))
     {
         return ERROR_CORRUPTED_SLICE;
     }
 
-    if(ps_svc_lyr_dec->u1_first_mb_addr_check == 1)
+    if(ps_dec->u4_first_slice_in_pic == 1)
     {
         if(u2_first_mb_in_slice != 0)
         {
             return ERROR_CORRUPTED_SLICE;
         }
-        else
-        {
-            ps_svc_lyr_dec->u1_first_mb_addr_check = 0;
-        }
     }
 
     COPYTHECONTEXT("SH: first_mb_in_slice", u2_first_mb_in_slice);
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp > 9) return ERROR_INV_SLC_TYPE_T;
 
     u1_slice_type = u4_temp;
     COPYTHECONTEXT("SH: slice_type", (u1_slice_type));
     /* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */
     /* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/
     /* will be of same type of current                            */
     if(u1_slice_type > 4)
     {
         u1_slice_type -= 5;
     }
 
     u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
     if(u4_temp & MASK_ERR_PIC_SET_ID) return ERROR_INV_SLICE_HDR_T;
     /* discard slice if pic param is invalid */
     COPYTHECONTEXT("SH: pic_parameter_set_id", u4_temp);
     ps_pps = &ps_dec->ps_pps[u4_temp];
     if(FALSE == ps_pps->u1_is_valid)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
     /* slices in a layer should have same PPS id*/
     if(UINT32_MAX == ps_svc_lyr_dec->u4_pps_id_for_layer)
     {
         ps_svc_lyr_dec->u4_pps_id_for_layer = u4_temp;
     }
     else if(u4_temp != ps_svc_lyr_dec->u4_pps_id_for_layer)
     {
         return ERROR_INV_SLICE_HDR_T;
     }
     ps_seq = ps_pps->ps_sps;
     ps_dec->ps_cur_sps = ps_seq;
     ps_subset_seq = &ps_svc_lyr_dec->ps_subset_sps[ps_seq->u1_seq_parameter_set_id];
     ps_svc_lyr_dec->ps_cur_subset_sps = ps_subset_seq;
     if(!ps_seq) return ERROR_INV_SLICE_HDR_T;
     if(FALSE == ps_seq->u1_is_valid) return ERROR_INV_SLICE_HDR_T;
     if(ps_seq->u1_mb_aff_flag) return ERROR_INV_SLICE_HDR_T;
     if(ps_seq->u1_level_idc > H264_LEVEL_4_2) return ERROR_INV_SLICE_HDR_T;
     if(!ps_seq->u1_frame_mbs_only_flag) return ERROR_INV_SLICE_HDR_T;
     if(OK != isvcd_verify_level(ps_seq->u1_level_idc)) return ERROR_INV_SLICE_HDR_T;
     if(ps_dec->u1_init_dec_flag == 1)
     {
         if(ps_dec->u2_frm_wd_in_mbs != ps_seq->u2_frm_wd_in_mbs) return ERROR_INV_SLICE_HDR_T;
         if(ps_dec->u2_frm_ht_in_mbs != ps_seq->u2_frm_ht_in_mbs) return ERROR_INV_SLICE_HDR_T;
     }
 
     if(ps_seq->u1_profile_idc == BASE_PROFILE_IDC)
     {
         if(ps_pps->u1_entropy_coding_mode != 0)
         {
             return ERROR_INV_SPS_PPS_T;
         }
     }
 
     ps_dec->i4_reorder_depth = ps_subset_seq->i4_reorder_depth;
     ps_dec->u2_disp_height = ps_subset_seq->u2_disp_height;
     ps_dec->u2_disp_width = ps_subset_seq->u2_disp_width;
 
     if(ps_svc_lyr_dec->u1_layer_id > 0)
     {
         psvcd_dec_ctxt = ps_svc_lyr_dec->ps_svcd_ctxt;
         ps_svc_cur_lyr_dec_minus_1 =
             &psvcd_dec_ctxt->ps_svc_dec_lyr[ps_svc_lyr_dec->u1_layer_id - 1];
 
         ps_dec_cur_lyr_minus_1 = &ps_svc_cur_lyr_dec_minus_1->s_dec;
 
         if((ps_dec_cur_lyr_minus_1->u2_pic_wd > ps_subset_seq->u2_pic_wd) ||
            (ps_dec_cur_lyr_minus_1->u2_pic_ht > ps_subset_seq->u2_pic_ht))
         {
             return ERROR_CORRUPTED_SLICE;
         }
     }
 
     ps_dec->u2_pic_wd = ps_subset_seq->u2_pic_wd;
     ps_dec->u2_pic_ht = ps_subset_seq->u2_pic_ht;
     ps_dec->u4_total_mbs = ps_seq->u2_total_num_of_mbs << (1 - ps_seq->u1_frame_mbs_only_flag);
 
     /* Determining the Width and Height of Frame from that of Picture */
     ps_dec->u2_frm_wd_y = ps_subset_seq->u2_frm_wd_y;
     ps_dec->u2_frm_ht_y = ps_subset_seq->u2_frm_ht_y;
 
     ps_dec->u2_frm_wd_uv = ps_subset_seq->u2_frm_wd_uv;
     ps_dec->u2_frm_ht_uv = ps_subset_seq->u2_frm_ht_uv;
 
     ps_dec->s_pad_mgr.u1_pad_len_y_v = ps_subset_seq->u1_pad_len_y_v;
     ps_dec->s_pad_mgr.u1_pad_len_cr_v = ps_subset_seq->u1_pad_len_cr_v;
     ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
     ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs;
 
     ps_dec->u2_crop_offset_y = ps_subset_seq->u2_crop_offset_y;
     ps_dec->u2_crop_offset_uv = ps_subset_seq->u2_crop_offset_uv;
 
     /* Get the frame num */
     u2_frame_num = ih264d_get_bits_h264(ps_bitstrm, ps_seq->u1_bits_in_frm_num);
     COPYTHECONTEXT("SH: frame_num", u2_frame_num);
 
     if(!ps_dec->u1_first_slice_in_stream && ps_dec->u4_first_slice_in_pic)
     {
         pocstruct_t *ps_prev_poc = &ps_dec->s_prev_pic_poc;
         pocstruct_t *ps_cur_poc = &ps_dec->s_cur_pic_poc;
 
         ps_dec->u2_mbx = 0xffff;
         ps_dec->u2_mby = 0;
 
         if((0 == u1_is_idr_slice) && ps_cur_slice->u1_nal_ref_idc)
             ps_dec->u2_prev_ref_frame_num = ps_cur_slice->u2_frame_num;
 
         if(u1_is_idr_slice || ps_cur_slice->u1_mmco_equalto5) ps_dec->u2_prev_ref_frame_num = 0;
 
         if(ps_dec->ps_cur_sps->u1_gaps_in_frame_num_value_allowed_flag)
         {
             isvcd_decode_gaps_in_frame_num(ps_dec, u2_frame_num);
         }
 
         ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
         ps_prev_poc->u2_frame_num = ps_cur_poc->u2_frame_num;
         ps_prev_poc->u1_mmco_equalto5 = ps_cur_slice->u1_mmco_equalto5;
         if(ps_cur_slice->u1_nal_ref_idc)
         {
             ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
             ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
             ps_prev_poc->i4_delta_pic_order_cnt_bottom = ps_cur_poc->i4_delta_pic_order_cnt_bottom;
             ps_prev_poc->i4_delta_pic_order_cnt[0] = ps_cur_poc->i4_delta_pic_order_cnt[0];
             ps_prev_poc->i4_delta_pic_order_cnt[1] = ps_cur_poc->i4_delta_pic_order_cnt[1];
             ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field;
         }
 
         ps_dec->u2_total_mbs_coded = 0;
     }
     /* Get the field related flags  */
     if(!ps_seq->u1_frame_mbs_only_flag)
     {
         u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SH: field_pic_flag", u1_field_pic_flag);
         u1_bottom_field_flag = 0;
 
         if(u1_field_pic_flag)
         {
             ps_dec->pu1_inv_scan = (UWORD8 *) gau1_ih264d_inv_scan_fld;
             u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);
             COPYTHECONTEXT("SH: bottom_field_flag", u1_bottom_field_flag);
         }
         else
         {
             ps_dec->pu1_inv_scan = (UWORD8 *) gau1_ih264d_inv_scan;
         }
     }
     else
     {
         u1_field_pic_flag = 0;
         u1_bottom_field_flag = 0;
 
         ps_dec->pu1_inv_scan = (UWORD8 *) gau1_ih264d_inv_scan;
     }
 
     u1_nal_unit_type = SLICE_NAL;
     if(u1_is_idr_slice)
     {
         u1_nal_unit_type = IDR_SLICE_NAL;
         u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_idr_pic_id > 65535) return ERROR_INV_SLICE_HDR_T;
         COPYTHECONTEXT("SH:  ", u4_idr_pic_id);
     }
 
     /* read delta pic order count information*/
     i_delta_poc[0] = i_delta_poc[1] = 0;
     s_tmp_poc.i4_pic_order_cnt_lsb = 0;
     s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
     u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;
     if(u1_pic_order_cnt_type == 0)
     {
         i_temp = ih264d_get_bits_h264(ps_bitstrm, ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);
         if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb) return ERROR_INV_SLICE_HDR_T;
         s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;
         COPYTHECONTEXT("SH: pic_order_cnt_lsb", s_tmp_poc.i4_pic_order_cnt_lsb);
 
         if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))
         {
             s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SH: delta_pic_order_cnt_bottom",
                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);
         }
     }
 
     s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;
     s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;
     if(u1_pic_order_cnt_type == 1 && (!ps_seq->u1_delta_pic_order_always_zero_flag))
     {
         s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         COPYTHECONTEXT("SH: delta_pic_order_cnt[0]", s_tmp_poc.i4_delta_pic_order_cnt[0]);
 
         if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)
         {
             s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
             COPYTHECONTEXT("SH: delta_pic_order_cnt[1]", s_tmp_poc.i4_delta_pic_order_cnt[1]);
         }
     }
 
     if(ps_pps->u1_redundant_pic_cnt_present_flag)
     {
         u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
         if(u4_temp > MAX_REDUNDANT_PIC_CNT) return ERROR_INV_SLICE_HDR_T;
         u1_redundant_pic_cnt = u4_temp;
         COPYTHECONTEXT("SH: redundant_pic_cnt", u1_redundant_pic_cnt);
     }
 
     /*--------------------------------------------------------------------*/
     /* Check if the slice is part of new picture                          */
     /*--------------------------------------------------------------------*/
     /* First slice of a picture is always considered as part of new picture */
     i1_is_end_of_poc = 1;
     ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;
 
     if(ps_dec->u4_first_slice_in_pic == 0)
     {
         i1_is_end_of_poc =
             ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc, &s_tmp_poc, &ps_dec->s_cur_pic_poc,
                                  ps_cur_slice, u1_pic_order_cnt_type, u1_nal_unit_type,
                                  u4_idr_pic_id, u1_field_pic_flag, u1_bottom_field_flag);
         if(i1_is_end_of_poc)
         {
             ps_dec->u1_first_slice_in_stream = 0;
             return ERROR_INCOMPLETE_FRAME;
         }
     }
 
     /*--------------------------------------------------------------------*/
     /* Check for error in slice and parse the missing/corrupted MB's      */
     /* as skip-MB's in an inserted P-slice                                */
     /*--------------------------------------------------------------------*/
     u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);
     prev_slice_err = 0;
 
     if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)
     {
         /* If the current slice is not a field or frame number of the current
          * slice doesn't match with previous slice, and decoder is expecting
          * to decode a field i.e. ps_dec->u1_top_bottom_decoded is not 0 and
          * is not (TOP_FIELD_ONLY | BOT_FIELD_ONLY), treat it as a dangling
          * field */
         if((u1_field_pic_flag == 0 || u2_frame_num != ps_dec->u2_prv_frame_num) &&
            ps_dec->u1_top_bottom_decoded != 0 &&
            ps_dec->u1_top_bottom_decoded != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))
         {
             ps_dec->u1_dangling_field = 1;
             if(ps_dec->u4_first_slice_in_pic)
             {
                 // first slice - dangling field
                 prev_slice_err = 1;
             }
             else
             {
                 // last slice - dangling field
                 prev_slice_err = 2;
             }
 
             if(ps_dec->u1_top_bottom_decoded == TOP_FIELD_ONLY)
                 ps_cur_slice->u1_bottom_field_flag = 1;
             else
                 ps_cur_slice->u1_bottom_field_flag = 0;
 
             num_mb_skipped =
                 (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs) - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &ps_dec->s_cur_pic_poc;
 
             u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;
         }
         else if(ps_dec->u4_first_slice_in_pic)
         {
             if(u2_first_mb_in_slice > 0)
             {
                 /* first slice - missing/header corruption */
                 prev_slice_err = 1;
                 num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
                 ps_cur_poc = &s_tmp_poc;
 
                 /* initializing slice parameters */
                 ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
                 ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
                 ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
                 ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;
                 ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
                 ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
                 ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
                 ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
                 ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);
             }
         }
         else
         {
             /* since i1_is_end_of_poc is set ,means new frame num is encountered. so
              * conceal the current frame completely */
             prev_slice_err = 2;
             num_mb_skipped =
                 (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs) - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &s_tmp_poc;
         }
     }
     else
     {
         if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)
         {
             // previous slice - missing/corruption
             prev_slice_err = 2;
             num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff) - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &s_tmp_poc;
         }
         else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)
         {
             return ERROR_CORRUPTED_SLICE;
         }
     }
     if(prev_slice_err)
     {
         ret = isvcd_mark_err_slice_skip((svc_dec_lyr_struct_t *) ps_dec, num_mb_skipped,
                                         u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);
 
         if(ps_dec->u1_dangling_field == 1)
         {
             ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;
             ps_dec->u1_first_slice_in_stream = 0;
             ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
             return ERROR_DANGLING_FIELD_IN_PIC;
         }
 
         if(prev_slice_err == 2)
         {
             ps_dec->u1_first_slice_in_stream = 0;
             return ERROR_INCOMPLETE_FRAME;
         }
 
         if(ps_dec->u2_total_mbs_coded >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
         {
             /* return if all MBs in frame are parsed*/
             ps_dec->u1_first_slice_in_stream = 0;
             return ERROR_IN_LAST_SLICE_OF_PIC;
         }
 
         if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
         {
             ih264d_err_pic_dispbuf_mgr(ps_dec);
             return ERROR_NEW_FRAME_EXPECTED;
         }
 
         if(ret != OK) return ret;
 
         i1_is_end_of_poc = 0;
     }
 
     if(u1_field_pic_flag)
     {
         ps_dec->u2_prv_frame_num = u2_frame_num;
     }
 
     if(ps_cur_slice->u1_mmco_equalto5 && NULL != ps_dec->ps_cur_pic)
     {
         WORD32 i4_temp_poc;
         WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;
         WORD64 i8_result;
         if(!ps_cur_slice->u1_field_pic_flag)
         {
             i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
             i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
             i4_temp_poc = MIN(i4_top_field_order_poc, i4_bot_field_order_poc);
         }
         else if(!ps_cur_slice->u1_bottom_field_flag)
             i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         else
             i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
 
         i8_result = (WORD64) i4_temp_poc - ps_dec->ps_cur_pic->i4_top_field_order_cnt;
         if(IS_OUT_OF_RANGE_S32(i8_result))
         {
             return ERROR_INV_POC;
         }
         ps_dec->ps_cur_pic->i4_top_field_order_cnt = (WORD32) i8_result;
         i8_result = (WORD64) i4_temp_poc - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
         if(IS_OUT_OF_RANGE_S32(i8_result))
         {
             return ERROR_INV_POC;
         }
         ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = (WORD32) i8_result;
         ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;
         ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
     }
     if(ps_dec->u4_first_slice_in_pic)
     {
         ret = isvcd_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num, &ps_dec->s_prev_pic_poc,
                                          &s_tmp_poc, ps_cur_slice, ps_pps, u1_nal_ref_idc,
                                          u1_bottom_field_flag, u1_field_pic_flag, &i4_poc, ps_dec);
         if(ret != OK) return ret;
         /* Display seq no calculations */
         if(i4_poc >= ps_dec->i4_max_poc) ps_dec->i4_max_poc = i4_poc;
         /* IDR Picture or POC wrap around */
         if(i4_poc == 0)
         {
             WORD64 i8_temp;
             i8_temp = (WORD64) ps_dec->i4_prev_max_display_seq + ps_dec->i4_max_poc +
                       ps_dec->u1_max_dec_frame_buffering + 1;
             /*If i4_prev_max_display_seq overflows integer range, reset it */
             ps_dec->i4_prev_max_display_seq = IS_OUT_OF_RANGE_S32(i8_temp) ? 0 : i8_temp;
             ps_dec->i4_max_poc = 0;
         }
     }
 
     /* Increment only if the current slice has atleast 1 more MB */
     if(ps_dec->u4_first_slice_in_pic == 0 &&
        (ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice <
         (UWORD32) (ps_dec->u2_total_mbs_coded >> ps_dec->ps_cur_slice->u1_mbaff_frame_flag)))
     {
         ps_dec->ps_parse_cur_slice++;
         ps_dec->u2_cur_slice_num++;
         // in the case of single core increment ps_decode_cur_slice
         if(ps_dec->u1_separate_parse == 0)
         {
             ps_dec->ps_decode_cur_slice++;
         }
     }
 
     ps_dec->u1_slice_header_done = 0;
 
     /*--------------------------------------------------------------------*/
     /* Copy the values read from the bitstream to the slice header and then*/
     /* If the slice is first slice in picture, then do Start of Picture   */
     /* processing.                                                        */
     /*--------------------------------------------------------------------*/
     ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];
     ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];
     ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
     ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;
     ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
     ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
     ps_cur_slice->u1_slice_type = u1_slice_type;
     ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;
 
     ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
     ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
     ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
     ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
 
     if(ps_seq->u1_frame_mbs_only_flag)
         ps_cur_slice->u1_direct_8x8_inference_flag = ps_seq->u1_direct_8x8_inference_flag;
     else
         ps_cur_slice->u1_direct_8x8_inference_flag = 1;
 
     if(u1_slice_type == B_SLICE)
     {
         ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(ps_bitstrm);
         COPYTHECONTEXT("SH: direct_spatial_mv_pred_flag",
                        ps_cur_slice->u1_direct_spatial_mv_pred_flag);
 
         if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)
             ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;
         else
             ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;
         if(!((ps_seq->u1_mb_aff_flag) && (!u1_field_pic_flag)))
             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;
     }
     else
     {
         if(!((ps_seq->u1_mb_aff_flag) && (!u1_field_pic_flag)))
             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
     }
 
     if(ps_dec->u4_first_slice_in_pic)
     {
         if(u2_first_mb_in_slice == 0)
         {
             ret = isvcd_start_of_pic(ps_svc_lyr_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);
             if(ret != OK) return ret;
             /*inter layer buffer intialization */
             ps_svc_lyr_dec->ps_inter_lyr_mb_prms_cur_mb =
                 ps_svc_lyr_dec->ps_inter_lyr_mb_prms_frm_start;
             ps_svc_lyr_dec->ps_il_pred_mv_bank_buf_cur_mb =
                 ps_svc_lyr_dec->ps_il_pred_mv_bank_buf_base;
         }
 
         ps_dec->u4_output_present = 0;
 
         {
             ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer, &(ps_dec->s_disp_op));
             /* If error code is non-zero then there is no buffer available for
             display, hence avoid format conversion */
 
             if(0 != ps_dec->s_disp_op.u4_error_code)
             {
                 ps_dec->u4_output_present = 0;
                 ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
             }
             else
                 ps_dec->u4_output_present = 1;
         }
-        if(ps_dec->u1_separate_parse == 1)
+        ret = isvcd_parse_interlayer_resamp_func_init(ps_svc_lyr_dec, u2_first_mb_in_slice);
+        if(ret != OK)
+        {
+            return ERROR_CORRUPTED_SLICE;
+        }
+        if((ps_dec->u1_separate_parse == 1) && (ps_svc_lyr_dec->u1_res_init_done == 1))
         {
             if(ps_dec->u4_dec_thread_created == 0)
             {
                 if(ps_svc_lyr_dec->u1_layer_identifier != TARGET_LAYER)
                 {
                     ithread_create(ps_dec->pv_dec_thread_handle, NULL,
                                    (void *) isvcd_decode_picture_thread, (void *) ps_dec);
 
                     ps_dec->u4_dec_thread_created = 1;
                 }
                 else
                 {
                     ithread_create(ps_dec->pv_dec_thread_handle, NULL,
                                    (void *) ih264d_decode_picture_thread, (void *) ps_dec);
 
                     ps_dec->u4_dec_thread_created = 1;
                 }
             }
 #ifdef KEEP_THREADS_ACTIVE
             ret = ithread_mutex_lock(ps_dec->apv_proc_start_mutex[0]);
             RETURN_IF((ret != IV_SUCCESS), ret);
 
             ps_dec->ai4_process_start[0] = PROC_START;
             ret = ithread_cond_signal(ps_dec->apv_proc_start_condition[0]);
             RETURN_IF((ret != IV_SUCCESS), ret);
 
             ret = ithread_mutex_unlock(ps_dec->apv_proc_start_mutex[0]);
             RETURN_IF((ret != IV_SUCCESS), ret);
 #endif
 #ifdef KEEP_THREADS_ACTIVE
             if(ps_dec->u4_bs_deblk_thread_created)
             {
                 ret = ithread_mutex_lock(ps_dec->apv_proc_start_mutex[1]);
                 RETURN_IF((ret != IV_SUCCESS), ret);
 
                 ps_dec->ai4_process_start[1] = PROC_START;
                 ret = ithread_cond_signal(ps_dec->apv_proc_start_condition[1]);
                 RETURN_IF((ret != IV_SUCCESS), ret);
 
                 ret = ithread_mutex_unlock(ps_dec->apv_proc_start_mutex[1]);
                 RETURN_IF((ret != IV_SUCCESS), ret);
             }
 #endif
         }
     }
 
     /* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */
     {
         UWORD8 uc_nofield_nombaff;
 
         uc_nofield_nombaff =
             ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0) &&
              (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0) && (u1_slice_type != B_SLICE) &&
              (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));
 
         /* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */
 
         if(uc_nofield_nombaff)
         {
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
         }
         else
         {
             ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;
             ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;
         }
     }
 
     /*
      * Decide whether to decode the current picture or not
      */
     {
         dec_err_status_t *ps_err = ps_dec->ps_dec_err_status;
         if(ps_err->u4_frm_sei_sync == u2_frame_num)
         {
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
             ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
         }
         ps_err->u4_cur_frm = u2_frame_num;
     }
 
     /* Decision for decoding if the picture is to be skipped */
     {
         WORD32 i4_skip_b_pic, i4_skip_p_pic;
 
         i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT) && (B_SLICE == u1_slice_type) &&
                         (0 == u1_nal_ref_idc);
 
         i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT) && (P_SLICE == u1_slice_type) &&
                         (0 == u1_nal_ref_idc);
 
         /**************************************************************/
         /* Skip the B picture if skip mask is set for B picture and   */
         /* Current B picture is a non reference B picture or there is */
         /* no user for reference B picture                            */
         /**************************************************************/
         if(i4_skip_b_pic)
         {
             ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
             /* Don't decode the picture in SKIP-B mode if that picture is B */
             /* and also it is not to be used as a reference picture         */
             ps_dec->u1_last_pic_not_decoded = 1;
 
             return OK;
         }
         /**************************************************************/
         /* Skip the P picture if skip mask is set for P picture and   */
         /* Current P picture is a non reference P picture or there is */
         /* no user for reference P picture                            */
         /**************************************************************/
         if(i4_skip_p_pic)
         {
             ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
             /* Don't decode the picture in SKIP-P mode if that picture is P */
             /* and also it is not to be used as a reference picture         */
             ps_dec->u1_last_pic_not_decoded = 1;
 
             return OK;
         }
     }
 
     {
         UWORD16 u2_mb_x, u2_mb_y;
 
         ps_dec->i4_submb_ofst =
             ((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE) -
             SUB_BLK_SIZE;
         if(u2_first_mb_in_slice)
         {
             UWORD8 u1_mb_aff;
             UWORD8 u1_field_pic;
             UWORD16 u2_frm_wd_in_mbs;
             u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
             u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;
             u1_field_pic = ps_cur_slice->u1_field_pic_flag;
 
             {
                 UWORD32 x_offset;
                 UWORD32 y_offset;
                 UWORD32 u4_frame_stride;
                 tfr_ctxt_t *ps_trns_addr;
 
                 if(ps_dec->u1_separate_parse)
                 {
                     ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
                 }
                 else
                 {
                     ps_trns_addr = &ps_dec->s_tran_addrecon;
                 }
                 u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
                 u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
 
                 u2_mb_y <<= u1_mb_aff;
 
                 if((u2_mb_x > u2_frm_wd_in_mbs - 1) || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))
                 {
                     return ERROR_CORRUPTED_SLICE;
                 }
 
                 u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;
                 x_offset = u2_mb_x << 4;
                 y_offset = (u2_mb_y * u4_frame_stride) << 4;
 
                 ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset + y_offset;
 
                 u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;
                 x_offset >>= 1;
                 y_offset = (u2_mb_y * u4_frame_stride) << 3;
 
                 x_offset *= YUV420SP_FACTOR;
 
                 ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset + y_offset;
                 ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset + y_offset;
 
                 ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
                 ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
                 ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;
 
                 /* assign the deblock structure pointers to start of slice */
                 if(ps_dec->u1_separate_parse == 1)
                 {
                     ps_dec->ps_deblk_mbn =
                         ps_dec->ps_deblk_pic + (u2_first_mb_in_slice << u1_mb_aff);
                 }
                 else
                 {
                     ps_dec->ps_deblk_mbn =
                         ps_dec->ps_deblk_pic + (u2_first_mb_in_slice << u1_mb_aff);
                 }
 
                 ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);
 
                 ps_dec->ps_mv_cur =
                     ps_dec->s_cur_pic.ps_mv + ((u2_first_mb_in_slice << u1_mb_aff) << 4);
             }
         }
         else
         {
             tfr_ctxt_t *ps_trns_addr;
 
             if(ps_dec->u1_separate_parse)
             {
                 ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
             }
             else
             {
                 ps_trns_addr = &ps_dec->s_tran_addrecon;
             }
 
             u2_mb_x = 0xffff;
             u2_mb_y = 0;
             // assign the deblock structure pointers to start of slice
             ps_dec->u2_cur_mb_addr = 0;
             ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
             ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
             ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
             ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
             ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;
 
             ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
             ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
             ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;
         }
 
         ps_dec->ps_part = ps_dec->ps_parse_part_params;
 
         ps_dec->u2_mbx = (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
         ps_dec->u2_mby = (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
         ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;
         ps_dec->i2_prev_slice_mbx = (WORD16) ps_dec->u2_mbx;
         ps_dec->i2_prev_slice_mby = (WORD16) ps_dec->u2_mby;
     }
 
     /* RBSP stop bit is used for CABAC decoding*/
     ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;
 
     ps_dec->u1_B = (u1_slice_type == B_SLICE);
     ps_dec->u4_next_mb_skip = 0;
 
     ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->ps_cur_slice->u2_first_mb_in_slice;
     ps_dec->ps_parse_cur_slice->slice_type = ps_dec->ps_cur_slice->u1_slice_type;
 
     ps_dec->u4_start_recon_deblk = 1;
     {
         WORD32 num_entries;
         WORD32 size;
         UWORD8 *pu1_buf;
 
         num_entries = MAX_FRAMES;
         if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) && (0 == ps_dec->i4_display_delay))
         {
             num_entries = 1;
         }
         num_entries = ((2 * num_entries) + 1);
         num_entries *= 2;
 
         size = num_entries * sizeof(void *);
         size += PAD_MAP_IDX_POC * sizeof(void *);
 
         pu1_buf = (UWORD8 *) ps_dec->pv_map_ref_idx_to_poc_buf;
         pu1_buf += size * ps_dec->u2_cur_slice_num;
         ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (void *) pu1_buf;
     }
 
     if(ps_dec->u1_separate_parse)
     {
         ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
     }
     else
     {
         ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
     }
 
     ret = ih264d_fix_error_in_dpb(ps_dec);
     if(ret < 0) return ERROR_DBP_MANAGER_T;
 
     if(u1_slice_type == I_SLICE)
     {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;
 
         ret = isvcd_parse_islice(ps_svc_lyr_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)
             ps_dec->i4_pic_type = I_SLICE;
     }
     else if(u1_slice_type == P_SLICE)
     {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
         ret = isvcd_parse_pslice(ps_svc_lyr_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         if(ps_dec->i4_pic_type != B_SLICE) ps_dec->i4_pic_type = P_SLICE;
     }
     else if(u1_slice_type == B_SLICE)
     {
         ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
         ret = isvcd_parse_bslice(ps_svc_lyr_dec, u2_first_mb_in_slice);
         ps_dec->u1_pr_sl_type = u1_slice_type;
         ps_dec->i4_pic_type = B_SLICE;
     }
     else
         return ERROR_INV_SLC_TYPE_T;
 
     if(ps_dec->u1_slice_header_done)
     {
         /* set to zero to indicate a valid slice has been decoded */
         ps_dec->u1_first_slice_in_stream = 0;
     }
 
     if(ret != OK) return ret;
 
     if(u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
         {
             memcpy((void *) ps_dec->ps_dpb_cmds, (void *) (&(ps_dec->s_dpb_cmds_scratch)),
                    sizeof(dpb_commands_t));
         }
     }
 
     /* storing last Mb X and MbY of the slice */
     ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
     ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
 
     /* End of Picture detection */
 
     if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))
     {
         ps_dec->u1_pic_decode_done = 1;
     }
 
     {
         dec_err_status_t *ps_err = ps_dec->ps_dec_err_status;
         if((ps_err->u1_err_flag & REJECT_PB_PICS) && (ps_err->u1_cur_pic_type == PIC_TYPE_I))
         {
             ps_err->u1_err_flag = ACCEPT_ALL_PICS;
         }
     }
 
     PRINT_BIN_BIT_RATIO(ps_dec)
 
     return ret;
 }
\ No newline at end of file
diff --git a/decoder/svc/isvcd_process_epslice.c b/decoder/svc/isvcd_process_epslice.c
index 29e9bbb..b351319 100644
--- a/decoder/svc/isvcd_process_epslice.c
+++ b/decoder/svc/isvcd_process_epslice.c
@@ -91,125 +91,90 @@ void isvcd_retrive_infer_mode_mv(svc_dec_lyr_struct_t *ps_svc_lyr_dec, mv_pred_t
     return;
 }
 /*!
  **************************************************************************
  * \if Function name : isvcd_interlyr_motion_mode_pred \endif
  *
  * \brief
  *
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
 WORD32 isvcd_interlyr_motion_mode_pred(svc_dec_lyr_struct_t *ps_svc_lyr_dec,
                                        dec_mb_info_t *ps_cur_mb_info,
                                        dec_svc_mb_info_t *ps_svc_cur_mb_info,
                                        parse_pmbarams_t *ps_mb_part_info,
                                        parse_part_params_t *ps_part)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     WORD32 i4_inter_layer_pred_req_flag;
     WORD32 i4_listx;
     WORD32 i4_mb_mode = -1;
     i4_inter_layer_pred_req_flag = SVCD_FALSE;
     i4_listx = (ps_dec->ps_cur_slice->u1_slice_type == B_SLICE) ? 2 : 1;
     /* check Base mode flag and motion predcition flags */
     if(1 == ps_svc_cur_mb_info->u1_base_mode_flag)
     {
         i4_inter_layer_pred_req_flag = SVCD_TRUE;
     }
     else
     {
         UWORD8 u1_mot_pred_flag;
 
         /* get the packed the motion pred flag of list 0 */
         u1_mot_pred_flag = ps_svc_cur_mb_info->au1_motion_pred_flag[0];
 
         /* extract the last 4 bits */
         u1_mot_pred_flag &= 0x0F;
 
         if(0 != u1_mot_pred_flag)
         {
             i4_inter_layer_pred_req_flag = SVCD_TRUE;
         }
 
         /* check for list 1 flags if required */
         if((2 == i4_listx) && (SVCD_FALSE == i4_inter_layer_pred_req_flag))
         {
             /* get the packed the motion pred flag of list 1 */
             u1_mot_pred_flag = ps_svc_cur_mb_info->au1_motion_pred_flag[1];
 
             /* extract the last 4 bits */
             u1_mot_pred_flag &= 0x0F;
 
             if(0 != u1_mot_pred_flag)
             {
                 i4_inter_layer_pred_req_flag = SVCD_TRUE;
             }
         }
     }
 
     if(SVCD_TRUE == i4_inter_layer_pred_req_flag)
     {
         mode_motion_ctxt_t *ps_ctxt;
         mode_motion_lyr_ctxt *ps_lyr_mem;
 
         ps_ctxt = (mode_motion_ctxt_t *) ps_svc_lyr_dec->pv_mode_mv_sample_ctxt;
         /* get the current layer ctxt */
         ps_lyr_mem = &ps_ctxt->as_res_lyr_mem[ps_ctxt->i4_res_id];
 
-#if 0
-        /* In case of error mb_mode is set to skip */
-        if(ps_svc_lyr_dec->u1_res_init_done == 0)
-        {
-            mv_pred_t *ps_motion_pred;
-            ps_motion_pred = ps_ctxt->ps_motion_pred_struct;
-            ps_motion_pred = ps_ctxt->ps_motion_pred_struct;
-            memset(ps_motion_pred, 0, sizeof(mv_pred_t));
-
-            i4_mb_mode = -1;
-            ps_cur_mb_info->u1_mb_type = MB_SKIP;
-            ps_mb_part_info->u1_num_part = 1;
-
-            ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
-            ps_mb_part_info->u1_col_info[0] = (PRED_16x16 << 6);
-            ps_mb_part_info->i1_ref_idx[0][0] = 0;
-
-            ps_svc_cur_mb_info->u1_residual_prediction_flag = 0;
-            ps_svc_cur_mb_info->au1_motion_pred_flag[0] = 0;
-            ps_svc_cur_mb_info->au1_motion_pred_flag[1] = 0;
-            ps_svc_cur_mb_info->u1_base_mode_flag = 0;
-
-            ps_part->u1_partwidth = 4;  // interms of 4x4
-            ps_part->u1_partheight = 4;
-            ps_part->u1_pred_mode = PRED_L0;
-            ps_part->u1_is_direct = 0;
-            ps_part->u1_sub_mb_num = 0;
-
-            if(2 == i4_listx)
-            {
-                ps_mb_part_info->i1_ref_idx[1][0] = -1;
-            }
-        }
-        else
-#endif
         {
             ps_ctxt->i4_listx = i4_listx;
 
             i4_mb_mode =
                 ps_lyr_mem->pf_inter_lyr_pred(ps_svc_lyr_dec->pv_mode_mv_sample_ctxt, ps_cur_mb_info,
                                           ps_svc_cur_mb_info, ps_dec, ps_mb_part_info, ps_part);
         }
     }
     return i4_mb_mode;
 }
 /*!
  **************************************************************************
  * \if Function name : isvcd_mv_pred_ref_tfr_nby2_epmb \endif
  *
  * \brief
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
diff --git a/decoder/svc/isvcd_structs.h b/decoder/svc/isvcd_structs.h
index b891acb..fefd32d 100644
--- a/decoder/svc/isvcd_structs.h
+++ b/decoder/svc/isvcd_structs.h
@@ -438,230 +438,229 @@ typedef struct
 typedef struct _SvcDecLyrStruct
 {
     dec_struct_t s_dec;
 
     /*Pred + Res = Target when csbp is zero*/
     ih264_pred_residual_recon_ft *pf_pred_residual_recon_luma_4x4;
 
     ih264_pred_residual_recon_ft *pf_pred_residual_recon_luma_8x8;
 
     ih264_pred_residual_recon_ft *pf_pred_residual_recon_luma_16x16;
 
     ih264_pred_residual_recon_chroma_ft *pf_pred_residual_recon_chroma_4x4;
 
     ih264_pred_residual_recon_chroma_ft *pf_pred_residual_recon_chroma_8x8;
 
     /* IT + Res + Recon*/
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_4x4;
 
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_4x4_dc;
 
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_8x8;
 
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_8x8_dc;
 
     ih264_iquant_itrans_residual_recon_chroma_ft *pf_iquant_itrans_residual_recon_chroma_4x4;
 
     ih264_iquant_itrans_residual_recon_chroma_ft *pf_iquant_itrans_residual_recon_chroma_4x4_dc;
 
     /* Res nnz*/
     ih264_residual_ft *pf_residual_luma_4x4;
     ih264_residual_ft *pf_residual_luma_8x8;
     ih264_residual_ft *pf_residual_luma_16x16;
 
     ih264_residual_chroma_ft *pf_residual_chroma_cb_cr_8x8;
 
     /*IT + residual */
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_4x4;
 
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_4x4_dc;
 
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_8x8;
 
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_8x8_dc;
 
     ih264_iquant_itrans_residual_chroma_ft *pf_iquant_itrans_residual_chroma_4x4;
 
     ih264_iquant_itrans_residual_chroma_ft *pf_iquant_itrans_residual_chroma_4x4_dc;
 
     /* IT */
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_4x4;
 
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_4x4_dc;
 
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_8x8;
 
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_8x8_dc;
 
     ih264_iquant_itrans_chroma_ft *pf_iquant_itrans_chroma_4x4;
 
     ih264_iquant_itrans_chroma_ft *pf_iquant_itrans_chroma_4x4_dc;
 
     /**
      *SVC extension parsing strcture place holders
      */
     dec_nal_unit_svc_ext_params_t *ps_nal_svc_ext;
     dec_prefix_nal_unit_svc_ext_params_t s_pre_nal_unit_svc_ext;
     dec_svc_crop_wnd_offset_t *ps_crop_wnd_offset;
     UWORD8 *apu1_crop_wnd_flag[MAX_DEP_LYRS_IN_RES];
 
     /**
      *contexts for the CABAC related parsing
      */
     bin_ctxt_model_t *ps_base_mode_flag;
     bin_ctxt_model_t *ps_motion_prediction_flag_l0;
     bin_ctxt_model_t *ps_motion_prediction_flag_l1;
     bin_ctxt_model_t *ps_residual_prediction_flag;
 
     /**
      * Function pointers to read Params common to CAVLC and CABAC
      */
     WORD32(*pf_parse_inter_mb_svc_ext)
     (struct _SvcDecLyrStruct *ps_dec, dec_mb_info_t *ps_cur_mb_info,
      dec_svc_mb_info_t *ps_svc_cur_mb_info, UWORD8 u1_mb_num, UWORD8 u1_num_mbsNby2);
 
     WORD32(*pf_parse_inter_slice_svc_ext)
     (struct _SvcDecLyrStruct *ps_dec, dec_slice_params_t *ps_slice, UWORD16 u2_first_mb_in_slice);
 
     /**
      * Function pointers to parse inter slice data
      */
 
     WORD32(*pf_parse_svc_inter_slice)
     (struct _SvcDecLyrStruct *ps_dec, dec_slice_params_t *ps_slice, UWORD16 u2_first_mb_in_slice);
 
     /* inter layer precition buffers */
 
     /* 4x4 level */
     mv_pred_t *ps_il_pred_mv_bank_buf_base;
 
     /* 16x16 level */
     inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_base;
     inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_frm_start;
     inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_cur_mb;
     UWORD16 u2_inter_lyr_mb_prms_stride;
     UWORD32 u4_inter_lyr_mb_prms_size; /* in Bytes */
 
     /* full frame size : -255 -255 */
     WORD16 *pi2_il_residual_resample_luma_base;
     WORD16 *pi2_il_residual_resample_chroma_base;
     WORD16 *pi2_il_residual_resample_mb_luma_frm_start;
     WORD16 *pi2_il_residual_resample_mb_chroma_frm_start;
 
     UWORD16 u2_residual_resample_luma_stride;
     UWORD16 u2_residual_resample_chroma_stride;
     UWORD32 u4_residual_resample_luma_size;   /* in Bytes */
     UWORD32 u4_residual_resample_chroma_size; /* in Bytes */
 
     mv_pred_t *ps_il_pred_mv_bank_buf_cur_mb;
 
     UWORD8 *pu1_crop_wnd_flag;
     /*
      * Layer info flag - Base layer; Intermediate Enhancement Layers; Target
      * Enhacement Layer.
      */
     UWORD8 u1_layer_identifier;
     /* layer id of the current layer */
     UWORD8 u1_layer_id;
     /* flag to indicate if spatial layers are dyadic */
     UWORD8 u1_dyadic_flag;
     /* flag to indicate if current layer is base layer */
     UWORD8 u1_base_res_flag;
     /* reference layer for inter layer prediction, no quality layers */
     UWORD8 u1_ref_layer_id;
 
     UWORD8 u1_restricted_res_change_flag;
 
     res_prms_t s_res_prms;
 
     void *pv_ref_lyr_offset;
     void *pv_mode_mv_sample_ctxt;
     void *pv_ii_pred_ctxt;
     void *pv_residual_sample_ctxt;
 
     void *pv_intra_sample_ctxt;
     /*!< projected locations buffer pointer exported by Intra Upsampling module
     for luma this buffer contains the projected offsets and window width in
     reference layer for each MB (in horizontal direction) of current resolution
     layer.*/
     ref_mb_map_t *ps_intsam_luma_map_horz;
 
     /*!< projected locations buffer pointer exported by Intra Upsampling module
       for chroma this buffer contains the projected offsets and window width in
       reference layer
       for each MB (in horizontal direction) of current resolution layer.*/
     ref_mb_map_t *ps_intsam_chroma_map_horz;
 
     /*!< projected locations  buffer pointer exported by Intra Upsampling module
        for luma this buffer contains the projected offsets and window width in
        reference layer for each MB (in vertical direction) of current resolution
        layer. */
     ref_mb_map_t *ps_intsam_luma_map_vert;
 
     /*!<  projected locations buffer pointer exported by Intra Upsampling module
        for chroma this buffer contains the projected offsets and window width in
        reference layer for each MB (in vertical direction) of current resolution
        layer.  */
     ref_mb_map_t *ps_intsam_chroma_map_vert;
 
     /*!< projected locations buffer pointer exported by Residual Upsampling module
     for luma. this buffer contains the projected offsets and window width in
     reference layer for each MB (in horizontal direction) of current resolution
     layer. */
     ref_mb_map_t *ps_ressam_luma_map_horz;
 
     /*!< projected locations buffer pointer exported by Residual Upsampling module
         for chroma. this buffer contains the projected offsets and window width in
        reference layer
         for each MB (in horizontal direction) of current resolution layer. */
     ref_mb_map_t *ps_ressam_chroma_map_horz;
 
     /*!< projected locationscbuffer pointercexported by Residual Upsampling
     modulec for chroma. this buffer contains the projected offsets and window
     width in reference layer for each MB (in vertical direction) ofv    current
     resolution layer. */
     ref_mb_map_t *ps_ressam_luma_map_vert;
 
     /*!< projected locationscbuffer pointerccexported by Residual Upsampling
     module for chroma.cthis buffer contains the projected offsets and window width
     in reference layer for each MB (in vertical direction) of current resolution
     layer.*/
     ref_mb_map_t *ps_ressam_chroma_map_vert;
 
     /* pointer to decoder layer referered by current layer */
     void *ps_dec_svc_ref_layer;
     /* pointer to master context */
     void *ps_svcd_ctxt;
 
     UWORD8 u1_inter_lyr_disable_dblk_filter_idc;
     WORD8 i1_inter_lyr_slice_alpha_c0_offset;
     WORD8 i1_inter_lyr_slice_beta_offset;
 
     UWORD8 *pu1_ii_resamp_buffer_luma;
     UWORD8 *pu1_ii_resamp_buffer_chroma;
 
     dec_slice_svc_ext_params_t s_svc_slice_params;
     dec_svc_seq_params_t *ps_subset_sps;
     dec_svc_seq_params_t *ps_cur_subset_sps;
     void *pv_scratch_subset_sps;
 
     /* Variables Required for N MB design */
     dec_svc_mb_info_t *ps_svc_nmb_info;
 
     dec_svc_mb_info_t *ps_svc_frm_mb_info;
 
     void (*pf_svc_compute_bs)(struct _SvcDecLyrStruct *ps_svc_lyr_dec,
                               struct _DecMbInfo *ps_cur_mb_info, const UWORD16 u2_mbxn_mb);
 
     UWORD16 *pu2_frm_res_luma_csbp;
     WORD32 i4_frm_res_luma_csbp_stride;
 
     UWORD8 *pu1_svc_base_mode_flag;
     WORD32 i4_frm_svc_base_mode_cabac_stride;
     WORD32 i4_frm_svc_base_mode_cabac_size;
     UWORD32 u4_pps_id_for_layer;
     UWORD8 u1_error_in_cur_frame;
     UWORD8 u1_res_init_done;
-    UWORD8 u1_first_mb_addr_check;
 } svc_dec_lyr_struct_t;
 
 typedef struct
