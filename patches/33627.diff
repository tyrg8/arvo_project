commit 3c0a7c159a77a58bbe128324091d39b02e77822f
Merge: 6bb612c 67b96cc
Author: Vova <vshymanskyi@gmail.com>
Date:   Tue May 4 23:24:32 2021 +0300

    Merge branch 'main' of https://github.com/wasm3/wasm3

diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
index 5b88d05..ad9fbb8 100644
--- a/.github/workflows/tests.yml
+++ b/.github/workflows/tests.yml
@@ -9,590 +9,590 @@ on:
 jobs:
   linux:
     runs-on: ubuntu-latest
     name: linux-${{ matrix.config.target }}
     timeout-minutes: 10
 
     strategy:
       fail-fast: false
       matrix:
         config:
         - {target: clang,       cc: clang,      }
         - {target: clang-x86,   cc: clang,      flags: -DCMAKE_C_FLAGS="-m32",    install: "gcc-multilib"   }
         - {target: gcc,         cc: gcc,        }
         # Builds without uvwasi
         - {target: gcc-no-uvwasi,   cc: gcc,    flags: -DBUILD_WASI=simple   }
         - {target: clang-no-uvwasi, cc: clang,  flags: -DBUILD_WASI=simple   }
         # Debug builds
         - {target: gcc-debug,               cc: gcc,    flags: -DCMAKE_BUILD_TYPE=Debug                         }
         - {target: clang-no-uvwasi-debug,   cc: clang,  flags: -DCMAKE_BUILD_TYPE=Debug -DBUILD_WASI=simple     }
 
         # TODO: fails on numeric operations
         #- {target: gcc-x86,     cc: gcc,        flags: "-m32",                    install: "gcc-multilib"   }
 
     steps:
     - uses: actions/checkout@v2
     - name: Install ${{ matrix.config.install }}
       if: ${{ matrix.config.install }}
       run: |
         sudo apt install ${{ matrix.config.install }}
     - name: Configure
       env:
         CC: ${{ matrix.config.cc }}
         CFLAGS: ${{ matrix.config.cflags }}
       run: |
         mkdir build
         cd build
         cmake ${{ matrix.config.flags }} ..
     - name: Build
       run: |
         cmake --build build
     - name: Test WebAssembly spec
       run: cd test && python3 run-spec-test.py
     - name: Test previous WebAssembly specs
       run: |
         cd test
         python3 run-spec-test.py --spec=v1.1
     - name: Test WASI apps
       run: cd test && python3 run-wasi-test.py
 
   linux-alpine:
     runs-on: ubuntu-latest
     container: alpine:3.10
 
     steps:
     - uses: actions/checkout@v2
     - name: Prepare
       run: apk add build-base cmake python3 git --update-cache
     - name: Configure
       run: |
         mkdir build
         cd build
         cmake ..
     - name: Build
       run: cmake --build build
     - name: Test WebAssembly spec
       run: cd test && python3 run-spec-test.py
     - name: Test WASI apps
       run: cd test && python3 run-wasi-test.py
 
   macos:
     runs-on: macos-latest
     name: macos-${{ matrix.config.target }}
     timeout-minutes: 10
 
     strategy:
       fail-fast: false
       matrix:
         config:
         - {target: uvwasi,      }
         - {target: no-uvwasi,   flags: -DBUILD_WASI=simple   }
 
     steps:
     - uses: actions/checkout@v2
     - name: Configure
       run: |
         mkdir build
         cd build
         cmake ${{ matrix.config.flags }} ..
     - name: Build
       run: |
         cmake --build build
     - name: Test WebAssembly spec
       run: cd test && python3 run-spec-test.py
     - name: Test previous WebAssembly specs
       run: |
         cd test
         python3 run-spec-test.py --spec=v1.1
     - name: Test WASI apps
       run: cd test && python3 run-wasi-test.py
 
   windows:
     runs-on: windows-latest
     name: windows-${{ matrix.config.target }}
     timeout-minutes: 10
 
     strategy:
       fail-fast: false
       matrix:
         config:
         - {target: clang-x64,   platform: "-A x64",     toolset: "-T ClangCL"   }
         - {target: msvc-x64,    platform: "-A x64",     toolset: ""             }
         - {target: clang-x86,   platform: "-A Win32",   toolset: "-T ClangCL"   }
         - {target: msvc-x86,    platform: "-A Win32",   toolset: ""             }
         # Builds without uvwasi
         - {target: clang-x64-no-uvwasi,   platform: "-A x64",     toolset: "-T ClangCL",  flags: "-DBUILD_WASI=simple"   }
         - {target: msvc-x64-no-uvwasi,    platform: "-A x64",     toolset: "",            flags: "-DBUILD_WASI=simple"   }
         - {target: clang-x86-no-uvwasi,   platform: "-A Win32",   toolset: "-T ClangCL",  flags: "-DBUILD_WASI=simple"   }
         - {target: msvc-x86-no-uvwasi,    platform: "-A Win32",   toolset: "",            flags: "-DBUILD_WASI=simple"   }
 
     defaults:
       run:
         shell: cmd
 
     steps:
     - uses: actions/checkout@v2
     - name: Configure
       run: |
         mkdir build
         cd build
         cmake ${{ matrix.config.platform }} ${{ matrix.config.toolset }} ${{ matrix.config.flags }} ..
     - name: Build
       run: |
         cmake --build build --config Release
         cp ./build/Release/wasm3.exe ./build/
     - name: Test WebAssembly spec
       run: |
         cd test
         python run-spec-test.py
     - name: Test previous WebAssembly specs
       run: |
         cd test
         python run-spec-test.py --spec=v1.1
     - name: Test WASI apps
       run: |
         cd test
         python run-wasi-test.py
 
   wasi:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Install Python dependencies
       run: |
         python3 -m pip install pip==20.1.1
         python3 -m pip install --upgrade setuptools wheel
         pip3 --version
     - name: Install Wasienv
       env:
         WASMER_RELEASE_TAG: "1.0.2"
       run: curl https://raw.githubusercontent.com/wasienv/wasienv/master/install.sh | sh
     - name: Configure
       run: |
         source $HOME/.wasienv/wasienv.sh
         mkdir build-wasi
         cd build-wasi
         wasimake cmake ..
     - name: Build
       run: |
         source $HOME/.wasienv/wasienv.sh
         cmake --build build-wasi
     - name: Test WebAssembly spec (in Wasmer)
       run: |
         source $HOME/.wasmer/wasmer.sh
         cd test
         python3 run-spec-test.py --exec "wasmer run --mapdir=/:. ../build-wasi/wasm3.wasm -- --repl"
 
     - name: Test WASI apps (in Wasmer)
       run: |
         source $HOME/.wasmer/wasmer.sh
         cd test
         python3 run-wasi-test.py --exec "wasmer run --mapdir=/:. ../build-wasi/wasm3.wasm --" --fast
 
     - name: Configure (native)
       run: |
         mkdir build
         cd build
         cmake ..
     - name: Build (native)
       run: |
         cmake --build build
     - name: Test WebAssembly spec (in Wasm3, self-hosting)
       run: |
         cd test
         cp ../build-wasi/wasm3.wasm ./
         python3 run-spec-test.py --exec "../build/wasm3 --stack-size 2097152 ../build-wasi/wasm3.wasm --repl"
     - name: Test WASI apps (in Wasm3, self-hosting)
       run: |
         cd test
         python3 run-wasi-test.py --fast --exec "../build/wasm3 --stack-size 2097152 ../build-wasi/wasm3.wasm"
 
   ios:
     runs-on: macos-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: List Xcode versions
       run: ls /Applications | grep Xcode
     - name: Select Xcode 11
       run: sudo xcode-select -switch /Applications/Xcode_11.3.app
     - name: Build (iPhone 11)
       run: |
         cd platforms/ios
         xcodebuild build -scheme wasm3 -project wasm3.xcodeproj -configuration Release -destination 'platform=iOS Simulator,name=iPhone 11,OS=13.3'
 
   android:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - uses: seanmiddleditch/gha-setup-ninja@master
     - name: Set up JDK 1.8
       uses: actions/setup-java@v1
       with:
         java-version: 1.8
     - name: Install NDK
       run: |
         sudo ${ANDROID_HOME}/tools/bin/sdkmanager --install "ndk;22.0.7026061"
     - name: Build
       run: |
         cd platforms/android
         ./gradlew build
 
   python:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - name: Checkout
       uses: actions/checkout@v2
       with:
         path: wasm3
     - name: Checkout pywasm3
       uses: actions/checkout@v2
       with:
         repository: wasm3/pywasm3
         path: pywasm3
     - name: Set up Python
       uses: actions/setup-python@v2
     - name: Update and Build Python module
       run: |
         rm -rf ./pywasm3/wasm3
         cp -r wasm3/source ./pywasm3/wasm3
         pip install ./pywasm3
     - name: Install WABT
       run: |
         sudo apt install wabt
     - name: Test
       run: |
         pip install pytest
         cd ./pywasm3
         pytest
 
   cosmopolitan:
     runs-on: ubuntu-20.04
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Build αcτµαlly pδrταblε εxεcµταblε
       run: |
         cd platforms/cosmopolitan
         gcc -v
         ./build.sh
     - name: Prepare tests
       run: |
         cd test
         cp ../platforms/cosmopolitan/wasm3.com ./wasm3-lin.com
         cp ../platforms/cosmopolitan/wasm3.com ./wasm3-win.com
         sudo sh -c "echo ':APE:M::MZqFpD::/bin/sh:' >/proc/sys/fs/binfmt_misc/register"
     - name: Test WebAssembly spec
       run: |
         cd test
         python3 run-spec-test.py --exec "./wasm3-lin.com --repl"
     - name: Test WASI apps
       run: |
         cd test
         python3 run-wasi-test.py --fast --exec "./wasm3-lin.com"
     - name: Install Wine64
       run: |
         sudo apt install wine64
         wine --version
     - name: Test WebAssembly spec (in Wine)
       run: |
         cd test
         python3 run-spec-test.py --exec "wine ./wasm3-win.com --repl"
     - name: Test WASI apps (in Wine)
       run: |
         cd test
         python3 run-wasi-test.py --fast --exec "wine ./wasm3-win.com"
 
   cross-qemu:
     runs-on: ubuntu-20.04
     name: cross-qemu-${{ matrix.config.target }}
     timeout-minutes: 10
 
     strategy:
       fail-fast: false
       matrix:
         config:
         #- {target: i386,    toolchain: gcc-multilib,              cc: clang -m32,                 qemu: qemu-i386-static    }
         - {target: arm,     toolchain: gcc-arm-linux-gnueabi,     cc: arm-linux-gnueabi-gcc,      qemu: qemu-arm-static     }
         - {target: armhf,   toolchain: gcc-arm-linux-gnueabihf,   cc: arm-linux-gnueabihf-gcc,    qemu: qemu-arm-static     }
         - {target: aarch64, toolchain: gcc-aarch64-linux-gnu,     cc: aarch64-linux-gnu-gcc,      qemu: qemu-aarch64-static }
         - {target: riscv64, toolchain: gcc-riscv64-linux-gnu,     cc: riscv64-linux-gnu-gcc,      qemu: qemu-riscv64-static }
         - {target: ppc,     toolchain: gcc-powerpc-linux-gnu,     cc: powerpc-linux-gnu-gcc,      qemu: qemu-ppc-static     }
         - {target: ppc64,   toolchain: gcc-powerpc64-linux-gnu,   cc: powerpc64-linux-gnu-gcc,    qemu: qemu-ppc64-static   }
         #- {target: ppc64le, toolchain: gcc-powerpc64le-linux-gnu, cc: powerpc64le-linux-gnu-gcc,  qemu: qemu-ppc64le-static }
         - {target: s390x,   toolchain: gcc-s390x-linux-gnu,       cc: s390x-linux-gnu-gcc,        qemu: qemu-s390x-static   }
         - {target: mips,    toolchain: gcc-mips-linux-gnu,          cc: mips-linux-gnu-gcc,         qemu: qemu-mips-static     }
         - {target: mips64,  toolchain: gcc-mips64-linux-gnuabi64,   cc: mips64-linux-gnuabi64-gcc,  qemu: qemu-mips64-static   }
         - {target: mipsel,  toolchain: gcc-mipsel-linux-gnu,        cc: mipsel-linux-gnu-gcc,       qemu: qemu-mipsel-static   }
         - {target: mips64el,toolchain: gcc-mips64el-linux-gnuabi64, cc: mips64el-linux-gnuabi64-gcc,qemu: qemu-mips64el-static }
         - {target: alpha,   toolchain: gcc-alpha-linux-gnu,       cc: alpha-linux-gnu-gcc,        qemu: qemu-alpha-static   }
         - {target: sparc64, toolchain: gcc-sparc64-linux-gnu,     cc: sparc64-linux-gnu-gcc,      qemu: qemu-sparc64-static, skip_wasi: true }
 
         #- {target: i386 (u64 slots),    toolchain: gcc-multilib,              cc: clang -m32,                 qemu: qemu-i386-static,     cflags: -Dd_m3Use32BitSlots=0  }
         - {target: arm (u64 slots),     toolchain: gcc-arm-linux-gnueabi,     cc: arm-linux-gnueabi-gcc,      qemu: qemu-arm-static,      cflags: -Dd_m3Use32BitSlots=0  }
         - {target: aarch64 (u64 slots), toolchain: gcc-aarch64-linux-gnu,     cc: aarch64-linux-gnu-gcc,      qemu: qemu-aarch64-static,  cflags: -Dd_m3Use32BitSlots=0  }
         - {target: ppc (u64 slots),     toolchain: gcc-powerpc-linux-gnu,     cc: powerpc-linux-gnu-gcc,      qemu: qemu-ppc-static,      cflags: -Dd_m3Use32BitSlots=0  }
         - {target: ppc64 (u64 slots),   toolchain: gcc-powerpc64-linux-gnu,   cc: powerpc64-linux-gnu-gcc,    qemu: qemu-ppc64-static,    cflags: -Dd_m3Use32BitSlots=0  }
 
     steps:
     - uses: actions/checkout@v2
     - name: Install QEMU
       run: |
         sudo apt install qemu-user-static
     - name: Install ${{ matrix.config.toolchain }}
       run: |
         sudo apt install ${{ matrix.config.toolchain }}
     - name: Build
       run: |
         mkdir build
         cd build
         ${{ matrix.config.cc }} -DASSERTS -Dd_m3HasWASI ${{ matrix.config.cflags }} \
             -I../source ../source/*.c ../platforms/app/main.c \
             -O3 -g0 -flto -lm -static \
             -o wasm3
     - name: Test WebAssembly spec
       run: |
         cd test
         python3 run-spec-test.py --exec "${{ matrix.config.qemu }} ../build/wasm3 --repl"
     - name: Test WASI apps
       if: ${{ !matrix.config.skip_wasi }}
       run: |
         cd test
         python3 run-wasi-test.py --fast --exec "${{ matrix.config.qemu }} ../build/wasm3"
 
   platformio:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Set up Python
       uses: actions/setup-python@v2
       with:
         python-version: '3.x'
     - name: Install PlatformIO
       run: |
         python -m pip install --upgrade pip
         pip install -U platformio
     - name: Build AVR ATmega1284
       run: |
         cd platforms/embedded/arduino
         pio run -e mega1284
         ! nm .pio/build/mega1284/firmware.elf | grep printf
     - name: Build ESP8266
       run: |
         cd platforms/embedded/esp8266
         pio run
     # TODO:
     #- name: Build ESP32
     #  run: |
     #    cd platforms/embedded/esp32-pio
     #    pio run
 
   platformio-arm:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Set up Python
       uses: actions/setup-python@v2
       with:
         python-version: '3.x'
     - name: Install PlatformIO
       run: |
         python -m pip install --upgrade pip
         pip install -U platformio
     - name: Build Arduino MKR1000
       run: |
         cd platforms/embedded/arduino
         pio run -e mkr1000
     - name: Build Blue Pill (JeeH)
       run: |
         cd platforms/embedded/bluepill
         pio run
     - name: Build TinyBLE
       run: |
         cd platforms/embedded/arduino
         pio run -e tinyBLE
     - name: Build MXChip AZ3166
       run: |
         cd platforms/embedded/arduino
         pio run -e az3166
 
   platformio-riscv:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Set up Python
       uses: actions/setup-python@v2
       with:
         python-version: '3.x'
     - name: Install PlatformIO
       run: |
         python -m pip install --upgrade pip
         pip install -U platformio
     - name: Build HiFive1
       run: |
         cd platforms/embedded/hifive1
         pio run
     - name: Build Sipeed MAIX
       run: |
         cd platforms/embedded/arduino
         pio run -e maix
 
   particle:
     runs-on: ubuntu-latest
     timeout-minutes: 10
     if: "github.event_name == 'push'"
 
     steps:
     - uses: actions/checkout@v2
     - name: Set up Particle CLI
       run: sudo npm install -g particle-cli
     - name: Log in
       env:
         PARTICLE_TOKEN: ${{ secrets.PARTICLE_TOKEN }}
       run: particle login --token $PARTICLE_TOKEN
     - name: Build Photon
       run: |
         cd platforms/embedded/particle
         particle compile --followSymlinks photon
 
   esp32-idf:
     runs-on: ubuntu-latest
     container: igrr/idf-qemu:release-v4.0-esp-develop-20191228
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Build for ESP32 (IDF v4.0)
       run: |
         . $IDF_PATH/export.sh
         cd platforms/embedded/esp32-idf
         export EXTRA_CFLAGS="-Werror"
         idf.py build
       shell: bash
     - name: Test for ESP32 in QEMU
       run: |
         cd platforms/embedded/esp32-idf
         make-flash-img.sh wasm3 flash_img.bin
         qemu-system-xtensa -machine esp32 -nographic -drive file=flash_img.bin,if=mtd,format=raw -no-reboot | tee out.txt
         grep "Result: 46368" out.txt
         grep "Elapsed: " out.txt
         grep "Restarting..." out.txt
         test $(($(grep "ets Jun  8 2016" out.txt | wc -l))) -eq 1
     - name: Check that IDF and PIO examples are in sync
       run: |
         diff -q platforms/embedded/esp32-idf/main/main.cpp platforms/embedded/esp32-pio/src/main.cpp
       # TODO: also check that the build flags are in sync
 
   cpp:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
       - uses: actions/checkout@v2
       - name: Configure
         run: |
           cd platforms/cpp
           mkdir build
           cd build
           cmake ..
       - name: Build
         run: |
           cd platforms/cpp
           cmake --build build
       - name: Run
         run: |
           cd platforms/cpp/build
           ./wasm3_cpp_example
 
   as-cpp:
     name: maintenance (build as C++)
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Build
       run: |
         mkdir build
         cd build
-        g++ -xc++ -Dd_m3HasWASI \
+        clang -xc++ -Dd_m3HasWASI \
             -I../source ../source/*.c ../platforms/app/main.c \
             -O3 -g0 -lm \
             -o wasm3
     - name: Test
       run: ./build/wasm3 ./test/wasi/simple/test.wasm
 
   with-logs:
     name: maintenance (debug logs)
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Build
       run: |
         mkdir build
         cd build
-        g++ -xc++ -Dd_m3HasWASI -DDEBUG \
+        clang -xc++ -Dd_m3HasWASI -DDEBUG \
             -Dd_m3EnableOpTracing=1     \
             -Dd_m3EnableStrace=1        \
             -Dd_m3LogParse=1            \
             -Dd_m3LogModule=1           \
             -Dd_m3LogCompile=1          \
             -Dd_m3LogWasmStack=1        \
             -Dd_m3LogEmit=1             \
             -Dd_m3LogCodePages=1        \
             -Dd_m3LogRuntime=1          \
             -Dd_m3LogNativeStack=1      \
             -I../source ../source/*.c ../platforms/app/main.c \
             -O3 -g0 -lm \
             -o wasm3
     - name: Test
       run: ./build/wasm3 ./test/wasi/simple/test.wasm > /dev/null
 
   preprocessed-ops:
     name: maintenance (preprocess ops)
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Install sponge
       run: |
         sudo apt install moreutils
     - name: Build
       run: |
         make -f extra/utils.mk preprocess
         mkdir build
         cd build
         gcc -Dd_m3HasWASI \
             -I../source ../source/*.c ../platforms/app/main.c \
             -O3 -g0 -lm \
             -o wasm3
     - name: Test
       run: ./build/wasm3 ./test/wasi/simple/test.wasm
 
   spellcheck:
     runs-on: ubuntu-latest
     steps:
     - name: Set up Python
       uses: actions/setup-python@v2
     - name: Install codespell
       run: |
         pip install codespell
     - name: Spellcheck
       run: |
         codespell
diff --git a/README.md b/README.md
index 4f97654..892fb60 100644
--- a/README.md
+++ b/README.md
@@ -83,28 +83,29 @@ In many situations, speed is not the main concern. Runtime executable size, memo
 Wasm3 started as a research project and remains so by many means. Evaluating the engine in different environments is part of the research. Given that we have `Lua`, `JS`, `Python`, `Lisp`, `...` running on MCUs, `WebAssembly` is actually a promising alternative. It provides toolchain decoupling as well as a completely sandboxed, well-defined, predictable environment. Among practical use cases we can list `edge computing`, `scripting`, running `IoT rules`, `smart contracts`, etc.
 
 ## Used by
 
 [<img src="https://wasmcloud.dev/images/logo.png" height="32" />](https://wasmcloud.dev/)　
 [<img src="/extra/wowcube.png" height="32" />](https://wowcube.com/)　
 [<img src="/extra/scailable.png" height="32" />](https://scailable.net/)　
 [<img src="/extra/blynk.png" height="32" />](https://blynk.io/)　
 [<img src="/extra/iden3.svg" height="32" />](https://www.iden3.io/)　
 [<img src="https://user-images.githubusercontent.com/1506708/114701856-069ce700-9d2c-11eb-9b72-9ce2dfd9f0fb.png" height="32" />](https://github.com/kateinoigakukun/wasmic-ios)　
 [<img src="https://www.balena.io/blog/content/images/2018/10/balena_logo.png" height="32" />](https://github.com/balena-io-playground/balena-wasm3)　
 [<img src="https://krustlet.dev/images/horizontal.svg" height="32" />](https://github.com/deislabs/krustlet-wasm3)　
 [<img src="/extra/shareup_app.svg" height="24" />](https://shareup.app/blog/introducing-shareup/)　
 [<img src="/extra/txiki_js.png" height="32" />](https://github.com/saghul/txiki.js)　
 
 ## Further Resources
 
 [Demos](./docs/Demos.md)  
+[Cookbook](./docs/Cookbook.md)  
 [Installation instructions](./docs/Installation.md)  
 [Build and Development instructions](./docs/Development.md)  
 [Supported Hardware](./docs/Hardware.md)  
 [Testing & Fuzzing](./docs/Testing.md)  
 [Performance](./docs/Performance.md)  
 [Interpreter Architecture](./docs/Interpreter.md)  
 [Logging](./docs/Diagnostics.md)  
 [Awesome WebAssembly Tools](https://github.com/vshymanskyy/awesome-wasm-tools/blob/main/README.md)
 
 ### License
diff --git a/docs/Cookbook.md b/docs/Cookbook.md
new file mode 100644
index 0000000..f89a3c8
--- /dev/null
+++ b/docs/Cookbook.md
@@ -0,0 +1,394 @@
+# WASM module examples
+
+### Rust WASI app
+
+Create a new project:
+```sh
+$ cargo new --bin hello
+$ cd hello
+$ rustup target add wasm32-wasi
+```
+
+Build and run:
+```sh
+$ cargo build --release --target wasm32-wasi
+
+$ wasm3 ./target/wasm32-wasi/release/hello.wasm
+Hello, world!
+```
+
+### AssemblyScript WASI app
+
+Create `hello.ts`:
+```ts
+import "wasi"
+import {Console} from "as-wasi"
+
+Console.log('Hello World!');
+```
+
+Create `package.json`:
+```json
+{
+  "scripts": {
+    "asbuild:debug":        "asc hello.ts -b hello.wasm --debug",
+    "asbuild:optimized":    "asc hello.ts -b hello.wasm -O3s --noAssert",
+    "asbuild:tiny":         "asc hello.ts -b hello.wasm -O3z --noAssert --runtime stub --use abort=",
+    "build":                "npm run asbuild:optimized"
+  },
+  "devDependencies": {
+    "assemblyscript": "*",
+    "as-wasi": "*"
+  }
+}
+```
+
+Build and run:
+```sh
+$ npm install
+$ npm run build
+
+$ wasm3 hello.wasm
+Hello World!
+```
+
+### TinyGo WASI app
+
+Create `hello.go`:
+```go
+package main
+
+import "fmt"
+
+func main() {
+    fmt.Printf("Hello, %s!\n", "world")
+}
+```
+
+Build and run:
+```sh
+$ tinygo build -o hello.wasm -target wasi -no-debug hello.go
+
+$ wasm3 hello.wasm
+Hello, world!
+```
+
+### Zig WASI app
+
+Create `hello.zig`:
+```zig
+const std = @import("std");
+
+pub fn main() !void {
+    const stdout = std.io.getStdOut().writer();
+    try stdout.print("Hello, {s}!\n", .{"world"});
+}
+```
+
+Build and run:
+```sh
+$ zig build-exe -O ReleaseSmall -target wasm32-wasi hello.zig
+
+$ wasm3 hello.wasm
+Hello, world!
+```
+
+## Zig library
+
+Create `add.zig`:
+```zig
+export fn add(a: i32, b: i32) i64 {
+    return a + b;
+}
+```
+
+Build and run:
+```sh
+$ zig build-lib add.zig -O ReleaseSmall -target wasm32-freestanding
+
+$ wasm3 --repl add.wasm
+wasm3> add 1 2
+Result: 3
+```
+
+### C/C++ WASI app
+
+The easiest way to start is to use [Wasienv](https://github.com/wasienv/wasienv).
+
+Create `hello.cpp`:
+```cpp
+#include <iostream>
+
+int main() {
+    std::cout << "Hello, world!" << std::endl;
+    return 0;
+}
+```
+
+Or `hello.c`:
+```c
+#include <stdio.h>
+
+int main() {
+   printf("Hello, %s!\n", "world");
+   return 0;
+}
+```
+
+Build and run:
+```sh
+$ wasic++ -O3 hello.cpp -o hello.wasm
+$ wasicc -O3 hello.c -o hello.wasm
+
+$ wasm3 hello.wasm
+Hello World!
+```
+
+Limitations:
+- `setjmp/longjmp` and `C++ exceptions` are not available
+- no support for `threads` and `atomics`
+- no support for `dynamic libraries`
+
+### WAT WASI app
+
+Create `hello.wat`:
+```wat
+(module
+    ;; wasi_snapshot_preview1!fd_write(file_descriptor, *iovs, iovs_len, nwritten) -> status_code
+    (import "wasi_snapshot_preview1" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
+
+    (memory 1)
+    (export "memory" (memory 0))
+
+    ;; Put a message to linear memory at offset 32
+    (data (i32.const 32) "Hello, world!\n")
+
+    (func $main (export "_start")
+        ;; Create a new io vector at address 0x4
+        (i32.store (i32.const 4) (i32.const 32))  ;; iov.iov_base - pointer to the start of the message
+        (i32.store (i32.const 8) (i32.const 14))  ;; iov.iov_len  - length of the message
+
+        (call $fd_write
+            (i32.const 1)  ;; file_descriptor - 1 for stdout
+            (i32.const 4)  ;; *iovs           - pointer to the io vector
+            (i32.const 1)  ;; iovs_len        - count of items in io vector
+            (i32.const 20) ;; nwritten        - where to store the number of bytes written
+        )
+        drop ;; discard the WASI status code
+    )
+)
+```
+
+
+Build and run:
+```sh
+$ wat2wasm hello.wat -o hello.wasm
+
+$ wasm3 hello.wasm    
+Hello, world!
+```
+
+### WAT library
+
+Create `swap.wat`:
+```wat
+(module
+  (func (export "swap") (param i32 i32) (result i32 i32)
+    (get_local 1)
+    (get_local 0)
+  )
+)
+```
+
+Build and run:
+```sh
+$ wat2wasm swap.wat -o swap.wasm
+
+$ wasm3 --repl swap.wasm
+wasm3> :invoke swap 123 456
+Result: 456:i32, 123:i32
+```
+
+# Tracing
+
+Drag'n'drop any of the WASI apps to [`WebAssembly.sh`](https://webassembly.sh/) and run:
+```sh
+$ wasm3-strace /tmp/hello.wasm
+```
+
+The execution trace will be produced:
+```js
+_start () {
+  __wasilibc_init_preopen () {
+    malloc (i32: 16) {
+      dlmalloc (i32: 16) {
+        sbrk (i32: 0) {
+        } = 131072
+        sbrk (i32: 65536) {
+```
+<details>
+  <summary>Click to expand!</summary>
+
+```js
+        } = 131072
+      } = 131088
+    } = 131088
+    calloc (i32: 24, i32: 0) {
+      dlmalloc (i32: 96) {
+      } = 131120
+      memset (i32: 131120, i32: 65504, i32: 0) {
+      } = 131120
+    } = 131120
+    po_map_assertvalid (i32: 131088) {
+    }
+    po_map_assertvalid (i32: 131088) {
+    }
+  }
+  wasi_unstable!fd_prestat_get(3, 65528) { <native> } = 0
+  malloc (i32: 2) {
+    dlmalloc (i32: 2) {
+    } = 131232
+  } = 131232
+  wasi_unstable!fd_prestat_dir_name(3, 131232, 1) { <native> } = 0
+  __wasilibc_register_preopened_fd (i32: 3, i32: 131120) {
+    po_map_assertvalid (i32: 131088) {
+    }
+    po_map_assertvalid (i32: 131088) {
+    }
+    strdup (i32: 131232) {
+      strlen (i32: 131232) {
+      } = 1
+      malloc (i32: 2) {
+        dlmalloc (i32: 2) {
+        } = 131248
+      } = 131248
+      memcpy (i32: 131248, i32: 131233, i32: 131232) {
+      } = 131248
+    } = 131248
+    wasi_unstable!fd_fdstat_get(3, 65496) { <native> } = 0
+    po_map_assertvalid (i32: 131088) {
+    }
+    po_map_assertvalid (i32: 131088) {
+    }
+  } = 0
+  free (i32: 131232) {
+    dlfree (i32: 131232) {
+    }
+  }
+  wasi_unstable!fd_prestat_get(4, 65528) { <native> } = 0
+  malloc (i32: 2) {
+    dlmalloc (i32: 2) {
+    } = 131232
+  } = 131232
+  wasi_unstable!fd_prestat_dir_name(4, 131232, 1) { <native> } = 0
+  __wasilibc_register_preopened_fd (i32: 4, i32: 131120) {
+    po_map_assertvalid (i32: 131088) {
+    }
+    po_map_assertvalid (i32: 131088) {
+    }
+    strdup (i32: 131232) {
+      strlen (i32: 131232) {
+      } = 1
+      malloc (i32: 2) {
+        dlmalloc (i32: 2) {
+        } = 131264
+      } = 131264
+      memcpy (i32: 131264, i32: 131233, i32: 131232) {
+      } = 131264
+    } = 131264
+    wasi_unstable!fd_fdstat_get(4, 65496) { <native> } = 0
+    po_map_assertvalid (i32: 131088) {
+    }
+    po_map_assertvalid (i32: 131088) {
+    }
+  } = 0
+  free (i32: 131232) {
+    dlfree (i32: 131232) {
+    }
+  }
+  wasi_unstable!fd_prestat_get(5, 65528) { <native> } = 8
+  __wasm_call_ctors () {
+  }
+  __original_main () {
+    printf (i32: 65536, i32: 0) {
+      vfprintf (i32: 69512, i32: 0, i32: 65536) {
+        printf_core (i32: 0, i32: -1, i32: 65536, i32: -16, i32: 65480) {
+        } = 0
+        __towrite (i32: 69512) {
+        } = 0
+        printf_core (i32: 69512, i32: 8, i32: 65536, i32: -1, i32: 65480) {
+          __fwritex (i32: 65536, i32: 0, i32: 7) {
+            memcpy (i32: 68472, i32: 0, i32: 65536) {
+            } = 68472
+          } = 7
+          __fwritex (i32: 65543, i32: 0, i32: 0) {
+            memcpy (i32: 68479, i32: 0, i32: 65543) {
+            } = 68479
+          } = 0
+          pop_arg (i32: 64456, i32: 0, i32: 9) {
+          }
+          strnlen (i32: 65548, i32: 0) {
+            memchr (i32: 65548, i32: 4, i32: 0) {
+            } = 65553
+          } = 5
+          __fwritex (i32: 67222, i32: 65553, i32: 0) {
+            memcpy (i32: 68479, i32: 0, i32: 67222) {
+            } = 68479
+          } = 0
+          __fwritex (i32: 65548, i32: 65553, i32: 5) {
+            memcpy (i32: 68479, i32: 0, i32: 65548) {
+            } = 68479
+          } = 5
+          __fwritex (i32: 65545, i32: 0, i32: 2) {
+            __stdout_write (i32: 69512, i32: 0, i32: 65545) {
+              __isatty (i32: 1) {
+                wasi_unstable!fd_fdstat_get(1, 64376) { <native> } = 0
+              } = 1
+              __stdio_write (i32: 69512, i32: 64368, i32: 65545) {
+                writev (i32: 1, i32: -16, i32: 64384) {
+Hello, world!
+                  wasi_unstable!fd_write(1, 64384, 2, 64380) { <native> } = 0
+                } = 14
+              } = 2
+            } = 2
+            memcpy (i32: 68472, i32: -1, i32: 65547) {
+            } = 68472
+          } = 2
+        } = 14
+      } = 14
+    } = 14
+  } = 0
+  __prepare_for_exit () {
+    dummy () {
+    }
+    __stdio_exit () {
+      __ofl_lock () {
+      } = 69504
+    }
+  }
+}
+```
+</details>
+
+# Gas Metering
+
+```sh
+$ npm install -g wasm-metering
+
+$ wasm-meter hello.wasm hello-metered.wasm
+
+$ wasm3 hello-metered.wasm       
+Warning: Gas is limited to 500000000.0000
+Hello, world!
+Gas used: 20.8950
+
+$ wasm3 --gas-limit 10 hello-metered.wasm
+Warning: Gas is limited to 10.0000
+Gas used: 10.0309
+Error: [trap] Out of gas
+```
+
+# Other resources
+
+- [WebAssembly by examples](https://wasmbyexample.dev/home.en-us.html) by Aaron Turner
+- [Writing WebAssembly](https://docs.wasmtime.dev/wasm.html) in Wasmtime docs
diff --git a/platforms/app/main.c b/platforms/app/main.c
index 172ede8..49d6535 100644
--- a/platforms/app/main.c
+++ b/platforms/app/main.c
@@ -43,6 +43,7 @@ int wasm_bins_qty = 0;
 
 #if defined(GAS_LIMIT)
 
+static int64_t initial_gas = GAS_FACTOR * GAS_LIMIT;
 static int64_t current_gas = GAS_FACTOR * GAS_LIMIT;
 static bool is_gas_metered = false;
 
@@ -208,6 +209,15 @@ M3Result repl_load_hex  (u32 fsize)
     return result;
 }
 
+void print_gas_used()
+{
+#if defined(GAS_LIMIT)
+    if (is_gas_metered) {
+        fprintf(stderr, "Gas used: %0.4f\n", (double)(initial_gas - current_gas) / GAS_FACTOR);
+    }
+#endif
+}
+
 void print_backtrace()
 {
     IM3BacktraceInfo info = m3_GetBacktrace(runtime);
@@ -238,72 +248,72 @@ void print_backtrace()
 M3Result repl_call  (const char* name, int argc, const char* argv[])
 {
     IM3Function func;
     M3Result result = m3_FindFunction (&func, runtime, name);
     if (result) return result;
 
     if (argc && (!strcmp(name, "main") || !strcmp(name, "_main"))) {
         return "passing arguments to libc main() not implemented";
     }
 
     if (!strcmp(name, "_start")) {
 #if defined(LINK_WASI)
         m3_wasi_context_t* wasi_ctx = m3_GetWasiContext();
         wasi_ctx->argc = argc;
         wasi_ctx->argv = argv;
 
         result = m3_CallArgv(func, 0, NULL);
 
+        print_gas_used();
+
         if (result == m3Err_trapExit) {
             exit(wasi_ctx->exit_code);
         }
 
         return result;
 #else
         return "WASI not linked";
 #endif
     }
 
     int arg_count = m3_GetArgCount(func);
     int ret_count = m3_GetRetCount(func);
     if (argc < arg_count) {
         return "not enough arguments";
     } else if (argc > arg_count) {
         return "too many arguments";
     }
 
     result = m3_CallArgv (func, argc, argv);
 
-#if defined(GAS_LIMIT)
-    if (is_gas_metered) {
-        fprintf(stderr, "Gas used: %0.4f\n", (double)((GAS_FACTOR * GAS_LIMIT) - current_gas) / GAS_FACTOR);
-    }
-#endif
+    print_gas_used();
 
     if (result) return result;
 
     static uint64_t    valbuff[128];
     static const void* valptrs[128];
     memset(valbuff, 0, sizeof(valbuff));
     for (int i = 0; i < ret_count; i++) {
         valptrs[i] = &valbuff[i];
     }
     result = m3_GetResults (func, ret_count, valptrs);
     if (result) return result;
 
     if (ret_count <= 0) {
         fprintf (stderr, "Result: <Empty Stack>\n");
     }
     for (int i = 0; i < ret_count; i++) {
         switch (m3_GetRetType(func, i)) {
         case c_m3Type_i32:  fprintf (stderr, "Result: %" PRIi32 "\n", *(i32*)valptrs[i]);  break;
         case c_m3Type_i64:  fprintf (stderr, "Result: %" PRIi64 "\n", *(i64*)valptrs[i]);  break;
+# if d_m3HasFloat
         case c_m3Type_f32:  fprintf (stderr, "Result: %" PRIf32 "\n", *(f32*)valptrs[i]);  break;
         case c_m3Type_f64:  fprintf (stderr, "Result: %" PRIf64 "\n", *(f64*)valptrs[i]);  break;
+# endif
         default: return "unknown return type";
         }
     }
 
     return result;
 }
 
 // :invoke is used by spec tests, so it treats floats as raw data
@@ -533,132 +543,136 @@ void print_usage() {
 int  main  (int i_argc, const char* i_argv[])
 {
     M3Result result = m3Err_none;
     env = m3_NewEnvironment ();
     runtime = NULL;
 
     bool argRepl = false;
     bool argDumpOnTrap = false;
     const char* argFile = NULL;
     const char* argFunc = "_start";
     unsigned argStackSize = 64*1024;
 
 //    m3_PrintM3Info ();
 
     ARGV_SHIFT(); // Skip executable name
 
     while (i_argc > 0)
     {
         const char* arg = i_argv[0];
         if (arg[0] != '-') break;
 
         ARGV_SHIFT();
         if (!strcmp("--help", arg) or !strcmp("-h", arg)) {
             print_usage();
             return 0;
         } else if (!strcmp("--version", arg)) {
             print_version();
             return 0;
         } else if (!strcmp("--repl", arg)) {
             argRepl = true;
         } else if (!strcmp("--dump-on-trap", arg)) {
             argDumpOnTrap = true;
         } else if (!strcmp("--stack-size", arg)) {
             const char* tmp = "65536";
             ARGV_SET(tmp);
             argStackSize = atol(tmp);
+        } else if (!strcmp("--gas-limit", arg)) {
+            const char* tmp = "0";
+            ARGV_SET(tmp);
+            initial_gas = current_gas = GAS_FACTOR * atol(tmp);
         } else if (!strcmp("--dir", arg)) {
             const char* argDir;
             ARGV_SET(argDir);
             (void)argDir;
         } else if (!strcmp("--func", arg) or !strcmp("-f", arg)) {
             ARGV_SET(argFunc);
         }
     }
 
     if ((argRepl and (i_argc > 1)) or   // repl supports 0 or 1 args
         (not argRepl and (i_argc < 1))  // normal expects at least 1
     ) {
         print_usage();
         return 1;
     }
 
     ARGV_SET(argFile);
 
     result = repl_init(argStackSize);
     if (result) FATAL("repl_init: %s", result);
 
     if (argFile) {
         result = repl_load(argFile);
         if (result) FATAL("repl_load: %s", result);
 
         if (argFunc and not argRepl) {
             if (!strcmp(argFunc, "_start")) {
                 // When passing args to WASI, include wasm filename as argv[0]
                 result = repl_call(argFunc, i_argc+1, i_argv-1);
             } else {
                 result = repl_call(argFunc, i_argc, i_argv);
             }
 
             if (result) {
                 if (argDumpOnTrap) {
                     repl_dump();
                 }
                 print_backtrace();
                 goto _onfatal;
             }
         }
     }
 
     while (argRepl)
     {
         char cmd_buff[2048] = { 0, };
         char* argv[32] = { 0, };
         fprintf(stdout, "wasm3> ");
         fflush(stdout);
         if (!fgets(cmd_buff, sizeof(cmd_buff), stdin)) {
             return 0;
         }
         int argc = split_argv(cmd_buff, argv);
         if (argc <= 0) {
             continue;
         }
         result = m3Err_none;
         if (!strcmp(":init", argv[0])) {
             result = repl_init(argStackSize);
         } else if (!strcmp(":version", argv[0])) {
             print_version();
         } else if (!strcmp(":exit", argv[0])) {
             repl_free();
             return 0;
         } else if (!strcmp(":load", argv[0])) {             // :load <filename>
             result = repl_load(argv[1]);
         } else if (!strcmp(":load-hex", argv[0])) {         // :load-hex <size>\n <hex-encoded-binary>
             result = repl_load_hex(atol(argv[1]));
         } else if (!strcmp(":get-global", argv[0])) {
             result = repl_global_get(argv[1]);
         } else if (!strcmp(":set-global", argv[0])) {
             result = repl_global_set(argv[1], argv[2]);
         } else if (!strcmp(":dump", argv[0])) {
             result = repl_dump();
         } else if (!strcmp(":invoke", argv[0])) {
             unescape(argv[1]);
             result = repl_invoke(argv[1], argc-2, (const char**)(argv+2));
         } else if (argv[0][0] == ':') {
             result = "no such command";
         } else {
             unescape(argv[0]);
             result = repl_call(argv[0], argc-1, (const char**)(argv+1));
             if (result) {
                 print_backtrace();
             }
         }
 
         if (result == m3Err_trapExit) {
             //TODO: fprintf(stderr, M3_ARCH "-wasi: exit(%d)\n", runtime->exit_code);
         } else if (result) {
             fprintf (stderr, "Error: %s", result);
             M3ErrorInfo info;
             m3_GetErrorInfo (runtime, &info);
             fprintf (stderr, " (%s)\n", info.message);
         }
     }
diff --git a/platforms/app_fuzz/fuzzer.c b/platforms/app_fuzz/fuzzer.c
index 76e236b..b97d649 100644
--- a/platforms/app_fuzz/fuzzer.c
+++ b/platforms/app_fuzz/fuzzer.c
@@ -15,34 +15,35 @@
 int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 {
     M3Result result = m3Err_none;
 
     if (size < 8 || size > 256*1024) {
         return 0;
     }
 
     IM3Environment env = m3_NewEnvironment ();
     if (env) {
         IM3Runtime runtime = m3_NewRuntime (env, 128, NULL);
         if (runtime) {
             IM3Module module = NULL;
             result = m3_ParseModule (env, &module, data, size);
             if (module) {
                 result = m3_LoadModule (runtime, module);
                 if (result == 0) {
                     IM3Function f = NULL;
                     result = m3_FindFunction (&f, runtime, "fib");
+                    /* TODO:
                     if (f) {
                         m3_CallV (f, 10);
-                    }
+                    }*/
                 } else {
                     m3_FreeModule (module);
                 }
             }
 
             m3_FreeRuntime(runtime);
         }
         m3_FreeEnvironment(env);
     }
 
     return 0;
 }
diff --git a/source/m3_compile.c b/source/m3_compile.c
index 76e6ccd..835f1f6 100644
--- a/source/m3_compile.c
+++ b/source/m3_compile.c
@@ -1071,9 +1071,9 @@ _   (ReadLEB_i64 (& value, & o->wasm, o->wasmEnd));
 _   (PushConst (o, value, c_m3Type_i64));                       m3log (compile, d_indent " (const i64 = %" PRIi64 ")", get_indention_string (o), value);
     _catch: return result;
 }
 
 
-#if d_m3HasFloat
+#if d_m3ImplementFloat
 M3Result  Compile_Const_f32  (IM3Compilation o, m3opcode_t i_opcode)
 {
     M3Result result;
@@ -2148,262 +2148,269 @@ _   (Compile_Operator (o, i_opcode));
 const M3OpInfo c_operations [] =
 {
     M3OP( "unreachable",         0, none,   d_logOp (Unreachable),              Compile_Unreachable ),  // 0x00
     M3OP( "nop",                 0, none,   d_emptyOpList,                      Compile_Nop ),          // 0x01 .
     M3OP( "block",               0, none,   d_emptyOpList,                      Compile_LoopOrBlock ),  // 0x02
     M3OP( "loop",                0, none,   d_logOp (Loop),                     Compile_LoopOrBlock ),  // 0x03
     M3OP( "if",                 -1, none,   d_emptyOpList,                      Compile_If ),           // 0x04
     M3OP( "else",                0, none,   d_emptyOpList,                      Compile_Nop ),          // 0x05
 
     M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED,                          // 0x06 - 0x0a
 
     M3OP( "end",                 0, none,   d_emptyOpList,                      Compile_End ),          // 0x0b
     M3OP( "br",                  0, none,   d_logOp (Branch),                   Compile_Branch ),       // 0x0c
     M3OP( "br_if",              -1, none,   d_logOp2 (BranchIf_r, BranchIf_s),  Compile_Branch ),       // 0x0d
     M3OP( "br_table",           -1, none,   d_logOp (BranchTable),              Compile_BranchTable ),  // 0x0e
     M3OP( "return",              0, any,    d_logOp (Return),                   Compile_Return ),       // 0x0f
     M3OP( "call",                0, any,    d_logOp (Call),                     Compile_Call ),         // 0x10
     M3OP( "call_indirect",       0, any,    d_logOp (CallIndirect),             Compile_CallIndirect ), // 0x11
     M3OP( "return_call",         0, any,    d_emptyOpList,                      Compile_Call ),         // 0x12 TODO: Optimize
     M3OP( "return_call_indirect",0, any,    d_emptyOpList,                      Compile_CallIndirect ), // 0x13
 
     M3OP_RESERVED,  M3OP_RESERVED,                                                                      // 0x14 - 0x15
     M3OP_RESERVED,  M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED,                                        // 0x16 - 0x19
 
     M3OP( "drop",               -1, none,   d_emptyOpList,                      Compile_Drop ),         // 0x1a
     M3OP( "select",             -2, any,    d_emptyOpList,                      Compile_Select  ),      // 0x1b
 
     M3OP_RESERVED,  M3OP_RESERVED, M3OP_RESERVED, M3OP_RESERVED,                                        // 0x1c - 0x1f
 
     M3OP( "local.get",          1,  any,    d_emptyOpList,                      Compile_GetLocal ),     // 0x20
     M3OP( "local.set",          1,  none,   d_emptyOpList,                      Compile_SetLocal ),     // 0x21
     M3OP( "local.tee",          0,  any,    d_emptyOpList,                      Compile_SetLocal ),     // 0x22
     M3OP( "global.get",         1,  none,   d_emptyOpList,                      Compile_GetSetGlobal ), // 0x23
     M3OP( "global.set",         1,  none,   d_emptyOpList,                      Compile_GetSetGlobal ), // 0x24
 
     M3OP_RESERVED,  M3OP_RESERVED, M3OP_RESERVED,                                                       // 0x25 - 0x27
 
     M3OP( "i32.load",           0,  i_32,   d_unaryOpList (i32, Load_i32),      Compile_Load_Store ),   // 0x28
     M3OP( "i64.load",           0,  i_64,   d_unaryOpList (i64, Load_i64),      Compile_Load_Store ),   // 0x29
     M3OP_F( "f32.load",         0,  f_32,   d_unaryOpList (f32, Load_f32),      Compile_Load_Store ),   // 0x2a
     M3OP_F( "f64.load",         0,  f_64,   d_unaryOpList (f64, Load_f64),      Compile_Load_Store ),   // 0x2b
 
     M3OP( "i32.load8_s",        0,  i_32,   d_unaryOpList (i32, Load_i8),       Compile_Load_Store ),   // 0x2c
     M3OP( "i32.load8_u",        0,  i_32,   d_unaryOpList (i32, Load_u8),       Compile_Load_Store ),   // 0x2d
     M3OP( "i32.load16_s",       0,  i_32,   d_unaryOpList (i32, Load_i16),      Compile_Load_Store ),   // 0x2e
     M3OP( "i32.load16_u",       0,  i_32,   d_unaryOpList (i32, Load_u16),      Compile_Load_Store ),   // 0x2f
 
     M3OP( "i64.load8_s",        0,  i_64,   d_unaryOpList (i64, Load_i8),       Compile_Load_Store ),   // 0x30
     M3OP( "i64.load8_u",        0,  i_64,   d_unaryOpList (i64, Load_u8),       Compile_Load_Store ),   // 0x31
     M3OP( "i64.load16_s",       0,  i_64,   d_unaryOpList (i64, Load_i16),      Compile_Load_Store ),   // 0x32
     M3OP( "i64.load16_u",       0,  i_64,   d_unaryOpList (i64, Load_u16),      Compile_Load_Store ),   // 0x33
     M3OP( "i64.load32_s",       0,  i_64,   d_unaryOpList (i64, Load_i32),      Compile_Load_Store ),   // 0x34
     M3OP( "i64.load32_u",       0,  i_64,   d_unaryOpList (i64, Load_u32),      Compile_Load_Store ),   // 0x35
 
     M3OP( "i32.store",          -2, none,   d_binOpList (i32, Store_i32),       Compile_Load_Store ),   // 0x36
     M3OP( "i64.store",          -2, none,   d_binOpList (i64, Store_i64),       Compile_Load_Store ),   // 0x37
     M3OP_F( "f32.store",        -2, none,   d_storeFpOpList (f32, Store_f32),   Compile_Load_Store ),   // 0x38
     M3OP_F( "f64.store",        -2, none,   d_storeFpOpList (f64, Store_f64),   Compile_Load_Store ),   // 0x39
 
     M3OP( "i32.store8",         -2, none,   d_binOpList (i32, Store_u8),        Compile_Load_Store ),   // 0x3a
     M3OP( "i32.store16",        -2, none,   d_binOpList (i32, Store_i16),       Compile_Load_Store ),   // 0x3b
 
     M3OP( "i64.store8",         -2, none,   d_binOpList (i64, Store_u8),        Compile_Load_Store ),   // 0x3c
     M3OP( "i64.store16",        -2, none,   d_binOpList (i64, Store_i16),       Compile_Load_Store ),   // 0x3d
     M3OP( "i64.store32",        -2, none,   d_binOpList (i64, Store_i32),       Compile_Load_Store ),   // 0x3e
 
     M3OP( "memory.size",        1,  i_32,   d_logOp (MemSize),                  Compile_Memory_Size ),  // 0x3f
     M3OP( "memory.grow",        1,  i_32,   d_logOp (MemGrow),                  Compile_Memory_Grow ),  // 0x40
 
     M3OP( "i32.const",          1,  i_32,   d_logOp (Const32),                  Compile_Const_i32 ),    // 0x41
     M3OP( "i64.const",          1,  i_64,   d_logOp (Const64),                  Compile_Const_i64 ),    // 0x42
     M3OP_F( "f32.const",        1,  f_32,   d_emptyOpList,                      Compile_Const_f32 ),    // 0x43
     M3OP_F( "f64.const",        1,  f_64,   d_emptyOpList,                      Compile_Const_f64 ),    // 0x44
 
     M3OP( "i32.eqz",            0,  i_32,   d_unaryOpList (i32, EqualToZero)        , NULL  ),          // 0x45
     M3OP( "i32.eq",             -1, i_32,   d_commutativeBinOpList (i32, Equal)     , NULL  ),          // 0x46
     M3OP( "i32.ne",             -1, i_32,   d_commutativeBinOpList (i32, NotEqual)  , NULL  ),          // 0x47
     M3OP( "i32.lt_s",           -1, i_32,   d_binOpList (i32, LessThan)             , NULL  ),          // 0x48
     M3OP( "i32.lt_u",           -1, i_32,   d_binOpList (u32, LessThan)             , NULL  ),          // 0x49
     M3OP( "i32.gt_s",           -1, i_32,   d_binOpList (i32, GreaterThan)          , NULL  ),          // 0x4a
     M3OP( "i32.gt_u",           -1, i_32,   d_binOpList (u32, GreaterThan)          , NULL  ),          // 0x4b
     M3OP( "i32.le_s",           -1, i_32,   d_binOpList (i32, LessThanOrEqual)      , NULL  ),          // 0x4c
     M3OP( "i32.le_u",           -1, i_32,   d_binOpList (u32, LessThanOrEqual)      , NULL  ),          // 0x4d
     M3OP( "i32.ge_s",           -1, i_32,   d_binOpList (i32, GreaterThanOrEqual)   , NULL  ),          // 0x4e
     M3OP( "i32.ge_u",           -1, i_32,   d_binOpList (u32, GreaterThanOrEqual)   , NULL  ),          // 0x4f
 
     M3OP( "i64.eqz",            0,  i_32,   d_unaryOpList (i64, EqualToZero)        , NULL  ),          // 0x50
     M3OP( "i64.eq",             -1, i_32,   d_commutativeBinOpList (i64, Equal)     , NULL  ),          // 0x51
     M3OP( "i64.ne",             -1, i_32,   d_commutativeBinOpList (i64, NotEqual)  , NULL  ),          // 0x52
     M3OP( "i64.lt_s",           -1, i_32,   d_binOpList (i64, LessThan)             , NULL  ),          // 0x53
     M3OP( "i64.lt_u",           -1, i_32,   d_binOpList (u64, LessThan)             , NULL  ),          // 0x54
     M3OP( "i64.gt_s",           -1, i_32,   d_binOpList (i64, GreaterThan)          , NULL  ),          // 0x55
     M3OP( "i64.gt_u",           -1, i_32,   d_binOpList (u64, GreaterThan)          , NULL  ),          // 0x56
     M3OP( "i64.le_s",           -1, i_32,   d_binOpList (i64, LessThanOrEqual)      , NULL  ),          // 0x57
     M3OP( "i64.le_u",           -1, i_32,   d_binOpList (u64, LessThanOrEqual)      , NULL  ),          // 0x58
     M3OP( "i64.ge_s",           -1, i_32,   d_binOpList (i64, GreaterThanOrEqual)   , NULL  ),          // 0x59
     M3OP( "i64.ge_u",           -1, i_32,   d_binOpList (u64, GreaterThanOrEqual)   , NULL  ),          // 0x5a
 
     M3OP_F( "f32.eq",           -1, i_32,   d_commutativeBinOpList (f32, Equal)     , NULL  ),          // 0x5b
     M3OP_F( "f32.ne",           -1, i_32,   d_commutativeBinOpList (f32, NotEqual)  , NULL  ),          // 0x5c
     M3OP_F( "f32.lt",           -1, i_32,   d_binOpList (f32, LessThan)             , NULL  ),          // 0x5d
     M3OP_F( "f32.gt",           -1, i_32,   d_binOpList (f32, GreaterThan)          , NULL  ),          // 0x5e
     M3OP_F( "f32.le",           -1, i_32,   d_binOpList (f32, LessThanOrEqual)      , NULL  ),          // 0x5f
     M3OP_F( "f32.ge",           -1, i_32,   d_binOpList (f32, GreaterThanOrEqual)   , NULL  ),          // 0x60
 
     M3OP_F( "f64.eq",           -1, i_32,   d_commutativeBinOpList (f64, Equal)     , NULL  ),          // 0x61
     M3OP_F( "f64.ne",           -1, i_32,   d_commutativeBinOpList (f64, NotEqual)  , NULL  ),          // 0x62
     M3OP_F( "f64.lt",           -1, i_32,   d_binOpList (f64, LessThan)             , NULL  ),          // 0x63
     M3OP_F( "f64.gt",           -1, i_32,   d_binOpList (f64, GreaterThan)          , NULL  ),          // 0x64
     M3OP_F( "f64.le",           -1, i_32,   d_binOpList (f64, LessThanOrEqual)      , NULL  ),          // 0x65
     M3OP_F( "f64.ge",           -1, i_32,   d_binOpList (f64, GreaterThanOrEqual)   , NULL  ),          // 0x66
 
     M3OP( "i32.clz",            0,  i_32,   d_unaryOpList (u32, Clz)                , NULL  ),          // 0x67
     M3OP( "i32.ctz",            0,  i_32,   d_unaryOpList (u32, Ctz)                , NULL  ),          // 0x68
     M3OP( "i32.popcnt",         0,  i_32,   d_unaryOpList (u32, Popcnt)             , NULL  ),          // 0x69
 
     M3OP( "i32.add",            -1, i_32,   d_commutativeBinOpList (i32, Add)       , NULL  ),          // 0x6a
     M3OP( "i32.sub",            -1, i_32,   d_binOpList (i32, Subtract)             , NULL  ),          // 0x6b
     M3OP( "i32.mul",            -1, i_32,   d_commutativeBinOpList (i32, Multiply)  , NULL  ),          // 0x6c
     M3OP( "i32.div_s",          -1, i_32,   d_binOpList (i32, Divide)               , NULL  ),          // 0x6d
     M3OP( "i32.div_u",          -1, i_32,   d_binOpList (u32, Divide)               , NULL  ),          // 0x6e
     M3OP( "i32.rem_s",          -1, i_32,   d_binOpList (i32, Remainder)            , NULL  ),          // 0x6f
     M3OP( "i32.rem_u",          -1, i_32,   d_binOpList (u32, Remainder)            , NULL  ),          // 0x70
     M3OP( "i32.and",            -1, i_32,   d_commutativeBinOpList (u32, And)       , NULL  ),          // 0x71
     M3OP( "i32.or",             -1, i_32,   d_commutativeBinOpList (u32, Or)        , NULL  ),          // 0x72
     M3OP( "i32.xor",            -1, i_32,   d_commutativeBinOpList (u32, Xor)       , NULL  ),          // 0x73
     M3OP( "i32.shl",            -1, i_32,   d_binOpList (u32, ShiftLeft)            , NULL  ),          // 0x74
     M3OP( "i32.shr_s",          -1, i_32,   d_binOpList (i32, ShiftRight)           , NULL  ),          // 0x75
     M3OP( "i32.shr_u",          -1, i_32,   d_binOpList (u32, ShiftRight)           , NULL  ),          // 0x76
     M3OP( "i32.rotl",           -1, i_32,   d_binOpList (u32, Rotl)                 , NULL  ),          // 0x77
     M3OP( "i32.rotr",           -1, i_32,   d_binOpList (u32, Rotr)                 , NULL  ),          // 0x78
 
     M3OP( "i64.clz",            0,  i_64,   d_unaryOpList (u64, Clz)                , NULL  ),          // 0x79
     M3OP( "i64.ctz",            0,  i_64,   d_unaryOpList (u64, Ctz)                , NULL  ),          // 0x7a
     M3OP( "i64.popcnt",         0,  i_64,   d_unaryOpList (u64, Popcnt)             , NULL  ),          // 0x7b
 
     M3OP( "i64.add",            -1, i_64,   d_commutativeBinOpList (i64, Add)       , NULL  ),          // 0x7c
     M3OP( "i64.sub",            -1, i_64,   d_binOpList (i64, Subtract)             , NULL  ),          // 0x7d
     M3OP( "i64.mul",            -1, i_64,   d_commutativeBinOpList (i64, Multiply)  , NULL  ),          // 0x7e
     M3OP( "i64.div_s",          -1, i_64,   d_binOpList (i64, Divide)               , NULL  ),          // 0x7f
     M3OP( "i64.div_u",          -1, i_64,   d_binOpList (u64, Divide)               , NULL  ),          // 0x80
     M3OP( "i64.rem_s",          -1, i_64,   d_binOpList (i64, Remainder)            , NULL  ),          // 0x81
     M3OP( "i64.rem_u",          -1, i_64,   d_binOpList (u64, Remainder)            , NULL  ),          // 0x82
     M3OP( "i64.and",            -1, i_64,   d_commutativeBinOpList (u64, And)       , NULL  ),          // 0x83
     M3OP( "i64.or",             -1, i_64,   d_commutativeBinOpList (u64, Or)        , NULL  ),          // 0x84
     M3OP( "i64.xor",            -1, i_64,   d_commutativeBinOpList (u64, Xor)       , NULL  ),          // 0x85
     M3OP( "i64.shl",            -1, i_64,   d_binOpList (u64, ShiftLeft)            , NULL  ),          // 0x86
     M3OP( "i64.shr_s",          -1, i_64,   d_binOpList (i64, ShiftRight)           , NULL  ),          // 0x87
     M3OP( "i64.shr_u",          -1, i_64,   d_binOpList (u64, ShiftRight)           , NULL  ),          // 0x88
     M3OP( "i64.rotl",           -1, i_64,   d_binOpList (u64, Rotl)                 , NULL  ),          // 0x89
     M3OP( "i64.rotr",           -1, i_64,   d_binOpList (u64, Rotr)                 , NULL  ),          // 0x8a
 
     M3OP_F( "f32.abs",          0,  f_32,   d_unaryOpList(f32, Abs)                 , NULL  ),          // 0x8b
     M3OP_F( "f32.neg",          0,  f_32,   d_unaryOpList(f32, Negate)              , NULL  ),          // 0x8c
     M3OP_F( "f32.ceil",         0,  f_32,   d_unaryOpList(f32, Ceil)                , NULL  ),          // 0x8d
     M3OP_F( "f32.floor",        0,  f_32,   d_unaryOpList(f32, Floor)               , NULL  ),          // 0x8e
     M3OP_F( "f32.trunc",        0,  f_32,   d_unaryOpList(f32, Trunc)               , NULL  ),          // 0x8f
     M3OP_F( "f32.nearest",      0,  f_32,   d_unaryOpList(f32, Nearest)             , NULL  ),          // 0x90
     M3OP_F( "f32.sqrt",         0,  f_32,   d_unaryOpList(f32, Sqrt)                , NULL  ),          // 0x91
 
     M3OP_F( "f32.add",          -1, f_32,   d_commutativeBinOpList (f32, Add)       , NULL  ),          // 0x92
     M3OP_F( "f32.sub",          -1, f_32,   d_binOpList (f32, Subtract)             , NULL  ),          // 0x93
     M3OP_F( "f32.mul",          -1, f_32,   d_commutativeBinOpList (f32, Multiply)  , NULL  ),          // 0x94
     M3OP_F( "f32.div",          -1, f_32,   d_binOpList (f32, Divide)               , NULL  ),          // 0x95
     M3OP_F( "f32.min",          -1, f_32,   d_commutativeBinOpList (f32, Min)       , NULL  ),          // 0x96
     M3OP_F( "f32.max",          -1, f_32,   d_commutativeBinOpList (f32, Max)       , NULL  ),          // 0x97
     M3OP_F( "f32.copysign",     -1, f_32,   d_binOpList (f32, CopySign)             , NULL  ),          // 0x98
 
     M3OP_F( "f64.abs",          0,  f_64,   d_unaryOpList(f64, Abs)                 , NULL  ),          // 0x99
     M3OP_F( "f64.neg",          0,  f_64,   d_unaryOpList(f64, Negate)              , NULL  ),          // 0x9a
     M3OP_F( "f64.ceil",         0,  f_64,   d_unaryOpList(f64, Ceil)                , NULL  ),          // 0x9b
     M3OP_F( "f64.floor",        0,  f_64,   d_unaryOpList(f64, Floor)               , NULL  ),          // 0x9c
     M3OP_F( "f64.trunc",        0,  f_64,   d_unaryOpList(f64, Trunc)               , NULL  ),          // 0x9d
     M3OP_F( "f64.nearest",      0,  f_64,   d_unaryOpList(f64, Nearest)             , NULL  ),          // 0x9e
     M3OP_F( "f64.sqrt",         0,  f_64,   d_unaryOpList(f64, Sqrt)                , NULL  ),          // 0x9f
 
     M3OP_F( "f64.add",          -1, f_64,   d_commutativeBinOpList (f64, Add)       , NULL  ),          // 0xa0
     M3OP_F( "f64.sub",          -1, f_64,   d_binOpList (f64, Subtract)             , NULL  ),          // 0xa1
     M3OP_F( "f64.mul",          -1, f_64,   d_commutativeBinOpList (f64, Multiply)  , NULL  ),          // 0xa2
     M3OP_F( "f64.div",          -1, f_64,   d_binOpList (f64, Divide)               , NULL  ),          // 0xa3
     M3OP_F( "f64.min",          -1, f_64,   d_commutativeBinOpList (f64, Min)       , NULL  ),          // 0xa4
     M3OP_F( "f64.max",          -1, f_64,   d_commutativeBinOpList (f64, Max)       , NULL  ),          // 0xa5
     M3OP_F( "f64.copysign",     -1, f_64,   d_binOpList (f64, CopySign)             , NULL  ),          // 0xa6
 
     M3OP( "i32.wrap/i64",       0,  i_32,   d_unaryOpList (i32, Wrap_i64),          NULL    ),          // 0xa7
     M3OP_F( "i32.trunc_s/f32",  0,  i_32,   d_convertOpList (i32_Trunc_f32),        Compile_Convert ),  // 0xa8
     M3OP_F( "i32.trunc_u/f32",  0,  i_32,   d_convertOpList (u32_Trunc_f32),        Compile_Convert ),  // 0xa9
     M3OP_F( "i32.trunc_s/f64",  0,  i_32,   d_convertOpList (i32_Trunc_f64),        Compile_Convert ),  // 0xaa
     M3OP_F( "i32.trunc_u/f64",  0,  i_32,   d_convertOpList (u32_Trunc_f64),        Compile_Convert ),  // 0xab
 
     M3OP( "i64.extend_s/i32",   0,  i_64,   d_unaryOpList (i64, Extend_i32),        NULL    ),          // 0xac
     M3OP( "i64.extend_u/i32",   0,  i_64,   d_unaryOpList (i64, Extend_u32),        NULL    ),          // 0xad
 
     M3OP_F( "i64.trunc_s/f32",  0,  i_64,   d_convertOpList (i64_Trunc_f32),        Compile_Convert ),  // 0xae
     M3OP_F( "i64.trunc_u/f32",  0,  i_64,   d_convertOpList (u64_Trunc_f32),        Compile_Convert ),  // 0xaf
     M3OP_F( "i64.trunc_s/f64",  0,  i_64,   d_convertOpList (i64_Trunc_f64),        Compile_Convert ),  // 0xb0
     M3OP_F( "i64.trunc_u/f64",  0,  i_64,   d_convertOpList (u64_Trunc_f64),        Compile_Convert ),  // 0xb1
 
     M3OP_F( "f32.convert_s/i32",0,  f_32,   d_convertOpList (f32_Convert_i32),      Compile_Convert ),  // 0xb2
     M3OP_F( "f32.convert_u/i32",0,  f_32,   d_convertOpList (f32_Convert_u32),      Compile_Convert ),  // 0xb3
     M3OP_F( "f32.convert_s/i64",0,  f_32,   d_convertOpList (f32_Convert_i64),      Compile_Convert ),  // 0xb4
     M3OP_F( "f32.convert_u/i64",0,  f_32,   d_convertOpList (f32_Convert_u64),      Compile_Convert ),  // 0xb5
 
     M3OP_F( "f32.demote/f64",   0,  f_32,   d_unaryOpList (f32, Demote_f64),        NULL    ),          // 0xb6
 
     M3OP_F( "f64.convert_s/i32",0,  f_64,   d_convertOpList (f64_Convert_i32),      Compile_Convert ),  // 0xb7
     M3OP_F( "f64.convert_u/i32",0,  f_64,   d_convertOpList (f64_Convert_u32),      Compile_Convert ),  // 0xb8
     M3OP_F( "f64.convert_s/i64",0,  f_64,   d_convertOpList (f64_Convert_i64),      Compile_Convert ),  // 0xb9
     M3OP_F( "f64.convert_u/i64",0,  f_64,   d_convertOpList (f64_Convert_u64),      Compile_Convert ),  // 0xba
 
     M3OP_F( "f64.promote/f32",  0,  f_64,   d_unaryOpList (f64, Promote_f32),       NULL    ),          // 0xbb
 
     M3OP_F( "i32.reinterpret/f32",0,i_32,   d_convertOpList (i32_Reinterpret_f32),  Compile_Convert ),  // 0xbc
     M3OP_F( "i64.reinterpret/f64",0,i_64,   d_convertOpList (i64_Reinterpret_f64),  Compile_Convert ),  // 0xbd
     M3OP_F( "f32.reinterpret/i32",0,f_32,   d_convertOpList (f32_Reinterpret_i32),  Compile_Convert ),  // 0xbe
     M3OP_F( "f64.reinterpret/i64",0,f_64,   d_convertOpList (f64_Reinterpret_i64),  Compile_Convert ),  // 0xbf
 
     M3OP( "i32.extend8_s",       0,  i_32,   d_unaryOpList (i32, Extend8_s),        NULL    ),          // 0xc0
     M3OP( "i32.extend16_s",      0,  i_32,   d_unaryOpList (i32, Extend16_s),       NULL    ),          // 0xc1
     M3OP( "i64.extend8_s",       0,  i_64,   d_unaryOpList (i64, Extend8_s),        NULL    ),          // 0xc2
     M3OP( "i64.extend16_s",      0,  i_64,   d_unaryOpList (i64, Extend16_s),       NULL    ),          // 0xc3
     M3OP( "i64.extend32_s",      0,  i_64,   d_unaryOpList (i64, Extend32_s),       NULL    ),          // 0xc4
 
 # ifdef DEBUG // for codepage logging. the order doesn't matter:
 #   define d_m3DebugOp(OP) M3OP (#OP, 0, none, { op_##OP })
+
+# if d_m3HasFloat
 #   define d_m3DebugTypedOp(OP) M3OP (#OP, 0, none, { op_##OP##_i32, op_##OP##_i64, op_##OP##_f32, op_##OP##_f64, })
+# else
+#   define d_m3DebugTypedOp(OP) M3OP (#OP, 0, none, { op_##OP##_i32, op_##OP##_i64 })
+# endif
 
     d_m3DebugOp (Compile),          d_m3DebugOp (Entry),            d_m3DebugOp (End),
     d_m3DebugOp (Unsupported),      d_m3DebugOp (CallRawFunction),
 
     d_m3DebugOp (GetGlobal_s32),    d_m3DebugOp (GetGlobal_s64),    d_m3DebugOp (ContinueLoop),     d_m3DebugOp (ContinueLoopIf),
 
     d_m3DebugOp (CopySlot_32),      d_m3DebugOp (PreserveCopySlot_32), d_m3DebugOp (If_s),          d_m3DebugOp (BranchIfPrologue_s),
     d_m3DebugOp (CopySlot_64),      d_m3DebugOp (PreserveCopySlot_64), d_m3DebugOp (If_r),          d_m3DebugOp (BranchIfPrologue_r),
 
     d_m3DebugOp (Select_i32_rss),   d_m3DebugOp (Select_i32_srs),   d_m3DebugOp (Select_i32_ssr),   d_m3DebugOp (Select_i32_sss),
     d_m3DebugOp (Select_i64_rss),   d_m3DebugOp (Select_i64_srs),   d_m3DebugOp (Select_i64_ssr),   d_m3DebugOp (Select_i64_sss),
 
+# if d_m3HasFloat
     d_m3DebugOp (Select_f32_sss),   d_m3DebugOp (Select_f32_srs),   d_m3DebugOp (Select_f32_ssr),
     d_m3DebugOp (Select_f32_rss),   d_m3DebugOp (Select_f32_rrs),   d_m3DebugOp (Select_f32_rsr),
 
     d_m3DebugOp (Select_f64_sss),   d_m3DebugOp (Select_f64_srs),   d_m3DebugOp (Select_f64_ssr),
     d_m3DebugOp (Select_f64_rss),   d_m3DebugOp (Select_f64_rrs),   d_m3DebugOp (Select_f64_rsr),
+# endif
 
     d_m3DebugTypedOp (SetGlobal),   d_m3DebugOp (SetGlobal_s32),    d_m3DebugOp (SetGlobal_s64),
 
     d_m3DebugTypedOp (SetRegister), d_m3DebugTypedOp (SetSlot),     d_m3DebugTypedOp (PreserveSetSlot),
 # endif
 
 # ifdef d_m3EnableExtendedOpcodes
 # ifdef DEBUG
     d_m3DebugOp (MemFill),
     d_m3DebugOp (MemCopy),
 #endif
     
     [0xFC] = M3OP( "0xFC", 0, c_m3Type_unknown,   d_emptyOpList,  Compile_ExtendedOpcode ),
 # endif
 
 # ifdef DEBUG
     M3OP( "termination", 0, c_m3Type_unknown ) // for find_operation_info
 # endif
 };
diff --git a/source/m3_core.c b/source/m3_core.c
index 2618b51..e21faf3 100644
--- a/source/m3_core.c
+++ b/source/m3_core.c
@@ -251,19 +251,19 @@ M3Result  Read_u64  (u64 * o_value, bytes_t * io_bytes, cbytes_t i_end)
 M3Result  Read_u32  (u32 * o_value, bytes_t * io_bytes, cbytes_t i_end)
 {
     const u8 * ptr = * io_bytes;
     ptr += sizeof (u32);
 
     if (ptr <= i_end)
     {
         memcpy(o_value, * io_bytes, sizeof(u32));
         M3_BSWAP_u32(*o_value);
         * io_bytes = ptr;
         return m3Err_none;
     }
     else return m3Err_wasmUnderrun;
 }
 
-#if d_m3HasFloat || d_m3NoFloatDynamic
+#if d_m3ImplementFloat
 
 M3Result  Read_f64  (f64 * o_value, bytes_t * io_bytes, cbytes_t i_end)
 {
diff --git a/source/m3_core.h b/source/m3_core.h
index 71d827d..745a24b 100644
--- a/source/m3_core.h
+++ b/source/m3_core.h
@@ -27,11 +27,9 @@
 
 d_m3BeginExternC
 
+#define d_m3ImplementFloat (d_m3HasFloat || d_m3NoFloatDynamic)
+
 #if !defined(d_m3ShortTypesDefined)
-#if d_m3HasFloat || d_m3NoFloatDynamic
-typedef double          f64;
-typedef float           f32;
-#endif
 
 typedef uint64_t        u64;
 typedef int64_t         i64;
@@ -41,7 +39,13 @@ typedef uint16_t        u16;
 typedef int16_t         i16;
 typedef uint8_t         u8;
 typedef int8_t          i8;
+
+#if d_m3ImplementFloat
+typedef double          f64;
+typedef float           f32;
+#endif
+
 #endif // d_m3ShortTypesDefined
 
 #define PRIf32          "f"
 #define PRIf64          "lf"
@@ -224,7 +228,7 @@ u32         SizeOfType              (u8 i_m3Type);
 
 M3Result    Read_u64                (u64 * o_value, bytes_t * io_bytes, cbytes_t i_end);
 M3Result    Read_u32                (u32 * o_value, bytes_t * io_bytes, cbytes_t i_end);
-#if d_m3HasFloat || d_m3NoFloatDynamic
+#if d_m3ImplementFloat
 M3Result    Read_f64                (f64 * o_value, bytes_t * io_bytes, cbytes_t i_end);
 M3Result    Read_f32                (f32 * o_value, bytes_t * io_bytes, cbytes_t i_end);
 #endif
diff --git a/source/m3_env.c b/source/m3_env.c
index dbaca05..997a406 100644
--- a/source/m3_env.c
+++ b/source/m3_env.c
@@ -611,16 +611,18 @@ IM3Global  m3_FindGlobal  (IM3Module               io_module,
 M3Result  m3_GetGlobal  (IM3Global                 i_global,
                          IM3TaggedValue            o_value)
 {
     if (not i_global) return m3Err_globalLookupFailed;
 
     switch (i_global->type) {
     case c_m3Type_i32: o_value->value.i32 = i_global->intValue; break;
     case c_m3Type_i64: o_value->value.i64 = i_global->intValue; break;
+# if d_m3HasFloat
     case c_m3Type_f32: o_value->value.f32 = i_global->f32Value; break;
     case c_m3Type_f64: o_value->value.f64 = i_global->f64Value; break;
+# endif
     default: return m3Err_invalidTypeId;
     }
 
     o_value->type = (M3ValueType)(i_global->type);
     return m3Err_none;
 }
@@ -628,18 +630,20 @@ M3Result  m3_GetGlobal  (IM3Global                 i_global,
 M3Result  m3_SetGlobal  (IM3Global                 i_global,
                          const IM3TaggedValue      i_value)
 {
     if (not i_global) return m3Err_globalLookupFailed;
     // TODO: if (not g->isMutable) return m3Err_globalNotMutable;
 
     if (i_global->type != i_value->type) return m3Err_globalTypeMismatch;
 
     switch (i_value->type) {
     case c_m3Type_i32: i_global->intValue = i_value->value.i32; break;
     case c_m3Type_i64: i_global->intValue = i_value->value.i64; break;
+# if d_m3HasFloat
     case c_m3Type_f32: i_global->f32Value = i_value->value.f32; break;
     case c_m3Type_f64: i_global->f64Value = i_value->value.f64; break;
+# endif
     default: return m3Err_invalidTypeId;
     }
 
     return m3Err_none;
 }
@@ -778,37 +782,39 @@ M3Result  m3_CallV  (IM3Function i_function, ...)
 M3Result  m3_CallVL  (IM3Function i_function, va_list i_args)
 {
     IM3Runtime runtime = i_function->module->runtime;
     IM3FuncType ftype = i_function->funcType;
 
     if (!i_function->compiled) {
         return m3Err_missingCompiledCode;
     }
 
 # if d_m3RecordBacktraces
     ClearBacktrace (runtime);
 # endif
 
     u8* s = GetStackPointerForArgs (i_function);
 
     for (u32 i = 0; i < ftype->numArgs; ++i)
     {
         switch (d_FuncArgType(ftype, i)) {
         case c_m3Type_i32:  *(i32*)(s) = va_arg(i_args, i32);  s += 8; break;
         case c_m3Type_i64:  *(i64*)(s) = va_arg(i_args, i64);  s += 8; break;
+# if d_m3HasFloat
         case c_m3Type_f32:  *(f32*)(s) = va_arg(i_args, f64);  s += 8; break; // f32 is passed as f64
         case c_m3Type_f64:  *(f64*)(s) = va_arg(i_args, f64);  s += 8; break;
+# endif
         default: return "unknown argument type";
         }
     }
     m3StackCheckInit();
     M3Result r = (M3Result) Call (i_function->compiled, (m3stack_t)(runtime->stack), runtime->memory.mallocated, d_m3OpDefaultArgs);
 
     runtime->lastCalled = r ? NULL : i_function;
 
 #if d_m3LogNativeStack
     int stackUsed =  m3StackGetMax();
     fprintf (stderr, "Native stack used: %d\n", stackUsed);
 #endif
 
     return r;
 }
@@ -816,41 +822,43 @@ M3Result  m3_CallVL  (IM3Function i_function, va_list i_args)
 M3Result  m3_Call  (IM3Function i_function, uint32_t i_argc, const void * i_argptrs[])
 {
     IM3Runtime runtime = i_function->module->runtime;
     IM3FuncType ftype = i_function->funcType;
 
     if (i_argc != ftype->numArgs) {
         return m3Err_argumentCountMismatch;
     }
     if (!i_function->compiled) {
         return m3Err_missingCompiledCode;
     }
 
 # if d_m3RecordBacktraces
     ClearBacktrace (runtime);
 # endif
 
     u8* s = GetStackPointerForArgs (i_function);
 
     for (u32 i = 0; i < ftype->numArgs; ++i)
     {
         switch (d_FuncArgType(ftype, i)) {
         case c_m3Type_i32:  *(i32*)(s) = *(i32*)i_argptrs[i];  s += 8; break;
         case c_m3Type_i64:  *(i64*)(s) = *(i64*)i_argptrs[i];  s += 8; break;
+# if d_m3HasFloat
         case c_m3Type_f32:  *(f32*)(s) = *(f32*)i_argptrs[i];  s += 8; break;
         case c_m3Type_f64:  *(f64*)(s) = *(f64*)i_argptrs[i];  s += 8; break;
+# endif
         default: return "unknown argument type";
         }
     }
 
     m3StackCheckInit();
     M3Result r = (M3Result) Call (i_function->compiled, (m3stack_t)(runtime->stack), runtime->memory.mallocated, d_m3OpDefaultArgs);
 
     runtime->lastCalled = r ? NULL : i_function;
 
 #if d_m3LogNativeStack
     int stackUsed =  m3StackGetMax();
     fprintf (stderr, "Native stack used: %d\n", stackUsed);
 #endif
 
     return r;
 }
@@ -858,48 +866,50 @@ M3Result  m3_Call  (IM3Function i_function, uint32_t i_argc, const void * i_argp
 M3Result  m3_CallArgv  (IM3Function i_function, uint32_t i_argc, const char * i_argv[])
 {
     IM3FuncType ftype = i_function->funcType;
     IM3Runtime runtime = i_function->module->runtime;
 
     if (i_argc != ftype->numArgs) {
         return m3Err_argumentCountMismatch;
     }
     if (!i_function->compiled) {
         return m3Err_missingCompiledCode;
     }
 
 # if d_m3RecordBacktraces
     ClearBacktrace (runtime);
 # endif
 
     u8* s = GetStackPointerForArgs (i_function);
 
     for (u32 i = 0; i < ftype->numArgs; ++i)
     {
         switch (d_FuncArgType(ftype, i)) {
         case c_m3Type_i32:  *(i32*)(s) = strtoul(i_argv[i], NULL, 10);  s += 8; break;
         case c_m3Type_i64:  *(i64*)(s) = strtoull(i_argv[i], NULL, 10); s += 8; break;
-        case c_m3Type_f32:  *(f32*)(s) = strtod(i_argv[i], NULL);       s += 8; break;  // strtof would be less portable
+# if d_m3HasFloat
+		case c_m3Type_f32:  *(f32*)(s) = strtod(i_argv[i], NULL);       s += 8; break;  // strtof would be less portable
         case c_m3Type_f64:  *(f64*)(s) = strtod(i_argv[i], NULL);       s += 8; break;
+# endif
         default: return "unknown argument type";
         }
     }
 
     m3StackCheckInit();
     M3Result r = (M3Result) Call (i_function->compiled, (m3stack_t)(runtime->stack), runtime->memory.mallocated, d_m3OpDefaultArgs);
 
     runtime->lastCalled = r ? NULL : i_function;
 
 #if d_m3LogNativeStack
     int stackUsed =  m3StackGetMax();
     fprintf (stderr, "Native stack used: %d\n", stackUsed);
 #endif
 
     return r;
 }
 
 
 //u8 * AlignStackPointerTo64Bits (const u8 * i_stack)
 //{
 //    uintptr_t ptr = (uintptr_t) i_stack;
 //    return (u8 *) ((ptr + 7) & ~7);
 //}
@@ -908,26 +918,28 @@ M3Result  m3_CallArgv  (IM3Function i_function, uint32_t i_argc, const char * i_
 M3Result  m3_GetResults  (IM3Function i_function, uint32_t i_retc, const void * o_retptrs[])
 {
     IM3FuncType ftype = i_function->funcType;
     IM3Runtime runtime = i_function->module->runtime;
 
     if (i_retc != ftype->numRets) {
         return m3Err_argumentCountMismatch;
     }
     if (i_function != runtime->lastCalled) {
         return "function not called";
     }
 
     u8* s = (u8*) runtime->stack;
 
     for (u32 i = 0; i < ftype->numRets; ++i)
     {
         switch (d_FuncRetType(ftype, i)) {
         case c_m3Type_i32:  *(i32*)o_retptrs[i] = *(i32*)(s); s += 8; break;
         case c_m3Type_i64:  *(i64*)o_retptrs[i] = *(i64*)(s); s += 8; break;
+# if d_m3HasFloat
         case c_m3Type_f32:  *(f32*)o_retptrs[i] = *(f32*)(s); s += 8; break;
         case c_m3Type_f64:  *(f64*)o_retptrs[i] = *(f64*)(s); s += 8; break;
+# endif 
         default: return "unknown return type";
         }
     }
     return m3Err_none;
 }
@@ -944,22 +956,24 @@ M3Result  m3_GetResultsV  (IM3Function i_function, ...)
 M3Result  m3_GetResultsVL  (IM3Function i_function, va_list o_rets)
 {
     IM3Runtime runtime = i_function->module->runtime;
     IM3FuncType ftype = i_function->funcType;
 
     if (i_function != runtime->lastCalled) {
         return "function not called";
     }
 
     u8* s = (u8*) runtime->stack;
     for (u32 i = 0; i < ftype->numRets; ++i)
     {
         switch (d_FuncRetType(ftype, i)) {
         case c_m3Type_i32:  *va_arg(o_rets, i32*) = *(i32*)(s);  s += 8; break;
         case c_m3Type_i64:  *va_arg(o_rets, i64*) = *(i64*)(s);  s += 8; break;
+# if d_m3HasFloat
         case c_m3Type_f32:  *va_arg(o_rets, f32*) = *(f32*)(s);  s += 8; break;
         case c_m3Type_f64:  *va_arg(o_rets, f64*) = *(f64*)(s);  s += 8; break;
+# endif
         default: return "unknown argument type";
         }
     }
     return m3Err_none;
 }
@@ -1037,18 +1051,19 @@ void  ReleaseCodePage  (IM3Runtime i_runtime, IM3CodePage i_codePage)
 #if d_m3VerboseErrorMessages
 M3Result  m3Error  (M3Result i_result, IM3Runtime i_runtime, IM3Module i_module, IM3Function i_function,
                     const char * const i_file, u32 i_lineNum, const char * const i_errorMessage, ...)
 {
     if (i_runtime)
     {
-        i_runtime->error = (M3ErrorInfo){ i_result, i_runtime, i_module, i_function, i_file, i_lineNum };
+        i_runtime->error = (M3ErrorInfo){ .result = i_result, .runtime = i_runtime, .module = i_module,
+                                          .function = i_function, .file = i_file, .line = i_lineNum };
         i_runtime->error.message = i_runtime->error_message;
 
         va_list args;
         va_start (args, i_errorMessage);
         vsnprintf (i_runtime->error_message, sizeof(i_runtime->error_message), i_errorMessage, args);
         va_end (args);
     }
 
     return i_result;
 }
 #endif
diff --git a/source/m3_exec_defs.h b/source/m3_exec_defs.h
index 7bb4e81..a7992a7 100644
--- a/source/m3_exec_defs.h
+++ b/source/m3_exec_defs.h
@@ -12,27 +12,35 @@
 
 d_m3BeginExternC
 
-#define m3MemData(mem)              (u8*)(((M3MemoryHeader*)(mem))+1)
-#define m3MemRuntime(mem)           (((M3MemoryHeader*)(mem))->runtime)
-#define m3MemInfo(mem)              (&(((M3MemoryHeader*)(mem))->runtime->memory))
-
-#if d_m3HasFloat
-
-#   define d_m3OpSig                pc_t _pc, m3stack_t _sp, M3MemoryHeader * _mem, m3reg_t _r0, f64 _fp0
-#   define d_m3OpArgs               _sp, _mem, _r0, _fp0
-#   define d_m3OpAllArgs            _pc, _sp, _mem, _r0, _fp0
-#   define d_m3OpDefaultArgs        0, 0.0
-#   define d_m3ClearRegisters       _r0 = 0; _fp0 = 0.0;
-
-#else
-
-#   define d_m3OpSig                pc_t _pc, m3stack_t _sp, M3MemoryHeader * _mem, m3reg_t _r0
-#   define d_m3OpArgs               _sp, _mem, _r0
-#   define d_m3OpAllArgs            _pc, _sp, _mem, _r0
-#   define d_m3OpDefaultArgs        0
-#   define d_m3ClearRegisters       _r0 = 0;
-
-#endif
+# define m3MemData(mem)					(u8*)(((M3MemoryHeader*)(mem))+1)
+# define m3MemRuntime(mem)				(((M3MemoryHeader*)(mem))->runtime)
+# define m3MemInfo(mem)					(&(((M3MemoryHeader*)(mem))->runtime->memory))
+
+# define d_m3BaseOpSig              	pc_t _pc, m3stack_t _sp, M3MemoryHeader * _mem, m3reg_t _r0
+# define d_m3BaseOpArgs               	_sp, _mem, _r0
+# define d_m3BaseOpAllArgs            	_pc, _sp, _mem, _r0
+# define d_m3BaseOpDefaultArgs        	0
+# define d_m3BaseClearRegisters       	_r0 = 0;
+
+# define d_m3ExpOpSig(...)				d_m3BaseOpSig, __VA_ARGS__
+# define d_m3ExpOpArgs(...)				d_m3BaseOpArgs, __VA_ARGS__
+# define d_m3ExpOpAllArgs(...)			d_m3BaseOpAllArgs, __VA_ARGS__
+# define d_m3ExpOpDefaultArgs(...)		d_m3BaseOpDefaultArgs, __VA_ARGS__
+# define d_m3ExpClearRegisters(...)		d_m3BaseClearRegisters; __VA_ARGS__
+
+# if d_m3HasFloat
+#	define d_m3OpSig                d_m3ExpOpSig			(f64 _fp0)
+#   define d_m3OpArgs               d_m3ExpOpArgs			(_fp0)
+#   define d_m3OpAllArgs            d_m3ExpOpAllArgs		(_fp0)
+#   define d_m3OpDefaultArgs        d_m3ExpOpDefaultArgs	(0.)
+#   define d_m3ClearRegisters       d_m3ExpClearRegisters	(_fp0 = 0.;)
+# else
+#	define d_m3OpSig                d_m3BaseOpSig
+#   define d_m3OpArgs               d_m3BaseOpArgs
+#   define d_m3OpAllArgs            d_m3BaseOpAllArgs
+#   define d_m3OpDefaultArgs        d_m3BaseOpDefaultArgs
+#   define d_m3ClearRegisters       d_m3BaseClearRegisters
+# endif
 
 typedef m3ret_t (vectorcall * IM3Operation) (d_m3OpSig);
 
diff --git a/source/m3_parse.c b/source/m3_parse.c
index 4ea7bb1..ed681f5 100644
--- a/source/m3_parse.c
+++ b/source/m3_parse.c
@@ -283,19 +283,19 @@ _   (ReadLEB_u32 (& startFuncIndex, & i_bytes, i_end));
 M3Result  Parse_InitExpr  (M3Module * io_module, bytes_t * io_bytes, cbytes_t i_end)
 {
     M3Result result = m3Err_none;
 
     // this doesn't generate code pages. just walks the wasm bytecode to find the end
 
 #if defined(d_m3PreferStaticAlloc)
     static M3Compilation compilation;
 #else
     M3Compilation compilation;
 #endif
-    compilation = (M3Compilation){ NULL, io_module, * io_bytes, i_end };
+    compilation = (M3Compilation){ .runtime = NULL, .module = io_module, .wasm = * io_bytes, .wasmEnd = i_end };
 
     result = CompileBlockStatements (& compilation);
 
     * io_bytes = compilation.wasm;
 
     return result;
 }
