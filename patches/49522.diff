commit 55eb460d1aa66059da534c5fa7315e0f315cadf8
Merge: a954cf82e 23a01b327
Author: David Garske <david@wolfssl.com>
Date:   Mon Aug 15 21:36:46 2022 -0700

    Merge pull request #5403 from SparkiDev/ecc_import_priv_order
    
    ECC import priv: validate priv is less than order

diff --git a/wolfcrypt/src/ecc.c b/wolfcrypt/src/ecc.c
index 41eecac29..14683e3ec 100644
--- a/wolfcrypt/src/ecc.c
+++ b/wolfcrypt/src/ecc.c
@@ -9818,155 +9818,185 @@ int wc_ecc_export_private_raw(ecc_key* key, byte* qx, word32* qxLen,
 #ifdef HAVE_ECC_KEY_IMPORT
 /* import private key, public part optional if (pub) passed as NULL */
 int wc_ecc_import_private_key_ex(const byte* priv, word32 privSz,
                                  const byte* pub, word32 pubSz, ecc_key* key,
                                  int curve_id)
 {
     int ret;
 #ifdef WOLFSSL_CRYPTOCELL
     const CRYS_ECPKI_Domain_t* pDomain;
 #endif
     if (key == NULL || priv == NULL)
         return BAD_FUNC_ARG;
 
     /* public optional, NULL if only importing private */
     if (pub != NULL) {
     #ifndef NO_ASN
         word32 idx = 0;
         ret = wc_ecc_import_x963_ex(pub, pubSz, key, curve_id);
         if (ret < 0)
             ret = wc_EccPublicKeyDecode(pub, &idx, key, pubSz);
         key->type = ECC_PRIVATEKEY;
     #else
         (void)pubSz;
         ret = NOT_COMPILED_IN;
     #endif
     }
     else {
         /* make sure required variables are reset */
         wc_ecc_reset(key);
 
         /* set key size */
         ret = wc_ecc_set_curve(key, privSz, curve_id);
         key->type = ECC_PRIVATEKEY_ONLY;
     }
 
     if (ret != 0)
         return ret;
 
 #ifdef WOLFSSL_CRYPTOCELL
     pDomain = CRYS_ECPKI_GetEcDomain(cc310_mapCurve(key->dp->id));
     /* import private key - priv checked for NULL at top */
     if (priv[0] != '\0') {
 
         /* Create private key from external key buffer*/
         ret = CRYS_ECPKI_BuildPrivKey(pDomain,
                                       priv,
                                       privSz,
                                       &key->ctx.privKey);
 
         if (ret != SA_SILIB_RET_OK) {
             WOLFSSL_MSG("CRYS_ECPKI_BuildPrivKey failed");
             return ret;
         }
 
         ret = mp_read_unsigned_bin(&key->k, priv, privSz);
     }
 #elif defined(WOLFSSL_SILABS_SE_ACCEL)
     if (ret == MP_OKAY)
         ret = mp_read_unsigned_bin(&key->k, priv, privSz);
 
     if (ret == MP_OKAY) {
         if (pub) {
             ret = silabs_ecc_import(key, key->dp->size);
         }
         else {
             ret = silabs_ecc_import_private(key, key->dp->size);
         }
     }
 #elif defined(WOLFSSL_QNX_CAAM)
     if ((wc_ecc_size(key) + WC_CAAM_MAC_SZ) == (int)privSz) {
     #ifdef WOLFSSL_CAAM_BLACK_KEY_SM
         int part = caamFindUnusedPartition();
         if (part >= 0) {
             CAAM_ADDRESS vaddr = caamGetPartition(part, privSz*3);
             if (vaddr == 0) {
                 WOLFSSL_MSG("Unable to get partition");
                 return MEMORY_E;
             }
 
             key->partNum  = part;
             key->blackKey = (word32)vaddr;
             if (caamWriteToPartition(vaddr, priv, privSz) != 0)
                 return WC_HW_E;
 
             if (pub != NULL) {
                 /* +1 to account for x963 compressed bit */
                 if (caamWriteToPartition(vaddr + privSz, pub + 1, pubSz - 1) != 0)
                     return WC_HW_E;
                 key->securePubKey = (word32)vaddr + privSz;
             }
         }
         else {
             WOLFSSL_MSG("Unable to find an unused partition");
             return MEMORY_E;
         }
     #else
         key->blackKey = CAAM_BLACK_KEY_CCM;
         ret = mp_read_unsigned_bin(&key->k, priv, privSz);
     #endif
     }
     else {
         key->blackKey = 0;
         ret = mp_read_unsigned_bin(&key->k, priv, privSz);
 
         /* If using AES-ECB encrypted black keys check here if key is valid,
          * if not valid than assume is an encrypted key. A public key is needed
          * for testing validity. */
         if (key->devId == WOLFSSL_CAAM_DEVID && (
             wc_ecc_get_curve_id(key->idx) == ECC_SECP256R1 ||
             wc_ecc_get_curve_id(key->idx) == ECC_SECP384R1)) {
             if ((pub != NULL) && (ret == MP_OKAY) &&
                 (_ecc_validate_public_key(key, 1, 1) != MP_OKAY)) {
                 key->blackKey = CAAM_BLACK_KEY_ECB;
             }
             else if ((pub == NULL) && (ret == MP_OKAY)) {
                 WOLFSSL_MSG("Assuming encrypted key with no public key to check");
                 key->blackKey = CAAM_BLACK_KEY_ECB;
             }
             else {
                 WOLFSSL_MSG("Importing key that is not a black key!");
             }
         }
     }
 #else
 
 #ifdef WOLFSSL_VALIDATE_ECC_IMPORT
     SAVE_VECTOR_REGISTERS(return _svr_ret;);
 #endif
 
     ret = mp_read_unsigned_bin(&key->k, priv, privSz);
 #ifdef HAVE_WOLF_BIGINT
     if (ret == 0 &&
                   wc_bigint_from_unsigned_bin(&key->k.raw, priv, privSz) != 0) {
         mp_clear(&key->k);
         ret = ASN_GETINT_E;
     }
 #endif /* HAVE_WOLF_BIGINT */
+#ifdef WOLFSSL_VALIDATE_ECC_IMPORT
+    if (ret == 0) {
+    #ifdef WOLFSSL_SMALL_STACK
+        mp_int* order = NULL;
+    #else
+        mp_int order[1];
+    #endif
+
+    #ifdef WOLFSSL_SMALL_STACK
+        order = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
+        if (order == NULL) {
+            ret = MEMORY_E;
+        }
+    #endif
+
+        if (ret == 0) {
+            ret = mp_init(order);
+        }
+        if (ret == 0) {
+            ret = mp_read_radix(order, key->dp->order, MP_RADIX_HEX);
+        }
+        if ((ret == 0) && (mp_cmp(&key->k, order) != MP_LT)) {
+            ret = ECC_PRIV_KEY_E;
+        }
+
+    #ifdef WOLFSSL_SMALL_STACK
+        XFREE(order, key->heap, DYNAMIC_TYPE_ECC);
+    #endif
+    }
+#endif /* WOLFSSL_VALIDATE_ECC_IMPORT */
 
 #endif /* WOLFSSL_CRYPTOCELL */
 
 #if defined(WOLFSSL_VALIDATE_ECC_IMPORT) && !defined(WOLFSSL_KCAPI_ECC)
     if ((pub != NULL) && (ret == MP_OKAY))
         /* public key needed to perform key validation */
         ret = _ecc_validate_public_key(key, 1, 1);
 
 #endif
 
 #ifdef WOLFSSL_VALIDATE_ECC_IMPORT
     RESTORE_VECTOR_REGISTERS();
 #endif
 
     return ret;
 }
 
 /* ecc private key import, public key in ANSI X9.63 format, private raw */
diff --git a/wolfcrypt/src/sp_arm32.c b/wolfcrypt/src/sp_arm32.c
index 4ef6f7b74..62fd91186 100644
--- a/wolfcrypt/src/sp_arm32.c
+++ b/wolfcrypt/src/sp_arm32.c
@@ -106,91 +106,94 @@ static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 256
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -17670,91 +17673,94 @@ static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 384
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -44704,91 +44710,94 @@ static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 512
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -64709,90 +64718,93 @@ static int sp_256_mod_mul_norm_8(sp_digit* r, const sp_digit* a, const sp_digit*
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_256_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_256.
  *
  * p   Point of type sp_point_256 (result).
  * pm  Point of type ecc_point.
  */
@@ -86090,90 +86102,93 @@ static int sp_384_mod_mul_norm_12(sp_digit* r, const sp_digit* a, const sp_digit
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_384_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_384.
  *
  * p   Point of type sp_point_384 (result).
  * pm  Point of type ecc_point.
  */
@@ -112014,90 +112029,93 @@ static int sp_521_mod_mul_norm_17(sp_digit* r, const sp_digit* a, const sp_digit
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_521_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_521.
  *
  * p   Point of type sp_point_521 (result).
  * pm  Point of type ecc_point.
  */
@@ -140873,90 +140891,93 @@ static void sp_1024_point_free_32(sp_point_1024* p, int clear, void* heap)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_1024_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_1024.
  *
  * p   Point of type sp_point_1024 (result).
  * pm  Point of type ecc_point.
  */
diff --git a/wolfcrypt/src/sp_arm64.c b/wolfcrypt/src/sp_arm64.c
index 5d0c579b4..fc52938a2 100644
--- a/wolfcrypt/src/sp_arm64.c
+++ b/wolfcrypt/src/sp_arm64.c
@@ -147,91 +147,94 @@ static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 256
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -7001,91 +7004,94 @@ static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 384
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -16565,91 +16571,94 @@ static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 512
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -22057,90 +22066,93 @@ static int sp_256_mod_mul_norm_4(sp_digit* r, const sp_digit* a, const sp_digit*
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_256_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_256.
  *
  * p   Point of type sp_point_256 (result).
  * pm  Point of type ecc_point.
  */
@@ -42451,90 +42463,93 @@ static int sp_384_mod_mul_norm_6(sp_digit* r, const sp_digit* a, const sp_digit*
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_384_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_384.
  *
  * p   Point of type sp_point_384 (result).
  * pm  Point of type ecc_point.
  */
@@ -69611,90 +69626,93 @@ static int sp_521_mod_mul_norm_9(sp_digit* r, const sp_digit* a,
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_521_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_521.
  *
  * p   Point of type sp_point_521 (result).
  * pm  Point of type ecc_point.
  */
@@ -114072,90 +114090,93 @@ static void sp_1024_point_free_16(sp_point_1024* p, int clear, void* heap)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_1024_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_1024.
  *
  * p   Point of type sp_point_1024 (result).
  * pm  Point of type ecc_point.
  */
diff --git a/wolfcrypt/src/sp_armthumb.c b/wolfcrypt/src/sp_armthumb.c
index 0401d9a66..c551b09ae 100644
--- a/wolfcrypt/src/sp_armthumb.c
+++ b/wolfcrypt/src/sp_armthumb.c
@@ -106,91 +106,94 @@ static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 256
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -30289,91 +30292,94 @@ static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 384
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -83375,91 +83381,94 @@ static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 512
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -97772,90 +97781,93 @@ static int sp_256_mod_mul_norm_8(sp_digit* r, const sp_digit* a, const sp_digit*
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_256_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_256.
  *
  * p   Point of type sp_point_256 (result).
  * pm  Point of type ecc_point.
  */
@@ -109278,90 +109290,93 @@ static int sp_384_mod_mul_norm_12(sp_digit* r, const sp_digit* a, const sp_digit
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_384_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_384.
  *
  * p   Point of type sp_point_384 (result).
  * pm  Point of type ecc_point.
  */
@@ -120361,90 +120376,93 @@ static int sp_521_mod_mul_norm_17(sp_digit* r, const sp_digit* a, const sp_digit
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_521_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_521.
  *
  * p   Point of type sp_point_521 (result).
  * pm  Point of type ecc_point.
  */
@@ -201981,90 +201999,93 @@ static void sp_1024_point_free_32(sp_point_1024* p, int clear, void* heap)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_1024_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_1024.
  *
  * p   Point of type sp_point_1024 (result).
  * pm  Point of type ecc_point.
  */
diff --git a/wolfcrypt/src/sp_c32.c b/wolfcrypt/src/sp_c32.c
index 365c2e55a..46611a491 100644
--- a/wolfcrypt/src/sp_c32.c
+++ b/wolfcrypt/src/sp_c32.c
@@ -126,91 +126,94 @@ static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 29
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 29
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1fffffff;
         s = 29U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 29U) <= (word32)DIGIT_BIT) {
             s += 29U;
             r[j] &= 0x1fffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 29) {
             r[j] &= 0x1fffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 29 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 256
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -4876,91 +4879,94 @@ static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 29
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 29
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1fffffff;
         s = 29U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 29U) <= (word32)DIGIT_BIT) {
             s += 29U;
             r[j] &= 0x1fffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 29) {
             r[j] &= 0x1fffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 29 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 384
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -8178,91 +8184,94 @@ static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 28
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 28
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xfffffff;
         s = 28U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 28U) <= (word32)DIGIT_BIT) {
             s += 28U;
             r[j] &= 0xfffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 28) {
             r[j] &= 0xfffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 28 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 384
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -12510,91 +12519,94 @@ static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 29
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 29
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1fffffff;
         s = 29U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 29U) <= (word32)DIGIT_BIT) {
             s += 29U;
             r[j] &= 0x1fffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 29) {
             r[j] &= 0x1fffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 29 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 512
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -15680,91 +15692,94 @@ static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 26
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 26
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x3ffffff;
         s = 26U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 26U) <= (word32)DIGIT_BIT) {
             s += 26U;
             r[j] &= 0x3ffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 26) {
             r[j] &= 0x3ffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 26 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 512
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -20381,91 +20396,94 @@ SP_NOINLINE static int sp_256_sub_9(sp_digit* r, const sp_digit* a,
 #endif /* WOLFSSL_SP_SMALL */
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_256_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 29
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 29
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1fffffff;
         s = 29U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 29U) <= (word32)DIGIT_BIT) {
             s += 29U;
             r[j] &= 0x1fffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 29) {
             r[j] &= 0x1fffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 29 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_256.
  *
  * p   Point of type sp_point_256 (result).
  * pm  Point of type ecc_point.
  */
@@ -27581,91 +27599,94 @@ SP_NOINLINE static int sp_384_sub_15(sp_digit* r, const sp_digit* a,
 #endif /* WOLFSSL_SP_SMALL */
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_384_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 26
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 26
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x3ffffff;
         s = 26U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 26U) <= (word32)DIGIT_BIT) {
             s += 26U;
             r[j] &= 0x3ffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 26) {
             r[j] &= 0x3ffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 26 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_384.
  *
  * p   Point of type sp_point_384 (result).
  * pm  Point of type ecc_point.
  */
@@ -35166,91 +35187,94 @@ SP_NOINLINE static int sp_521_sub_21(sp_digit* r, const sp_digit* a,
 #endif /* WOLFSSL_SP_SMALL */
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_521_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 25
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 25
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1ffffff;
         s = 25U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 25U) <= (word32)DIGIT_BIT) {
             s += 25U;
             r[j] &= 0x1ffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 25) {
             r[j] &= 0x1ffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 25 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_521.
  *
  * p   Point of type sp_point_521 (result).
  * pm  Point of type ecc_point.
  */
@@ -43931,90 +43955,93 @@ static void sp_1024_point_free_42(sp_point_1024* p, int clear, void* heap)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_1024_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 25
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 25
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1ffffff;
         s = 25U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 25U) <= (word32)DIGIT_BIT) {
             s += 25U;
             r[j] &= 0x1ffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 25) {
             r[j] &= 0x1ffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 25 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_1024.
  *
  * p   Point of type sp_point_1024 (result).
  * pm  Point of type ecc_point.
  */
diff --git a/wolfcrypt/src/sp_c64.c b/wolfcrypt/src/sp_c64.c
index ba20bc020..0b86384d8 100644
--- a/wolfcrypt/src/sp_c64.c
+++ b/wolfcrypt/src/sp_c64.c
@@ -127,91 +127,94 @@ static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 61
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 61
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1fffffffffffffffL;
         s = 61U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 61U) <= (word32)DIGIT_BIT) {
             s += 61U;
             r[j] &= 0x1fffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 61) {
             r[j] &= 0x1fffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 61 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 256
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -3403,91 +3406,94 @@ static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 57
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 57
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1ffffffffffffffL;
         s = 57U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 57U) <= (word32)DIGIT_BIT) {
             s += 57U;
             r[j] &= 0x1ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 57) {
             r[j] &= 0x1ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 57 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 256
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -7065,91 +7071,94 @@ static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 60
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 60
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xfffffffffffffffL;
         s = 60U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 60U) <= (word32)DIGIT_BIT) {
             s += 60U;
             r[j] &= 0xfffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 60) {
             r[j] &= 0xfffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 60 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 384
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -10272,91 +10281,94 @@ static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 57
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 57
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1ffffffffffffffL;
         s = 57U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 57U) <= (word32)DIGIT_BIT) {
             s += 57U;
             r[j] &= 0x1ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 57) {
             r[j] &= 0x1ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 57 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 384
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -14119,91 +14131,94 @@ static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 59
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 59
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x7ffffffffffffffL;
         s = 59U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 59U) <= (word32)DIGIT_BIT) {
             s += 59U;
             r[j] &= 0x7ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 59) {
             r[j] &= 0x7ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 59 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 512
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -17185,91 +17200,94 @@ static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 53
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 53
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1fffffffffffffL;
         s = 53U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 53U) <= (word32)DIGIT_BIT) {
             s += 53U;
             r[j] &= 0x1fffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 53) {
             r[j] &= 0x1fffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 53 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 512
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -21425,91 +21443,94 @@ SP_NOINLINE static int sp_256_sub_5(sp_digit* r, const sp_digit* a,
 #endif /* WOLFSSL_SP_SMALL */
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_256_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 52
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 52
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xfffffffffffffL;
         s = 52U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 52U) <= (word32)DIGIT_BIT) {
             s += 52U;
             r[j] &= 0xfffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 52) {
             r[j] &= 0xfffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 52 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_256.
  *
  * p   Point of type sp_point_256 (result).
  * pm  Point of type ecc_point.
  */
@@ -28152,91 +28173,94 @@ SP_NOINLINE static int sp_384_sub_7(sp_digit* r, const sp_digit* a,
 #endif /* WOLFSSL_SP_SMALL */
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_384_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 55
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 55
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x7fffffffffffffL;
         s = 55U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 55U) <= (word32)DIGIT_BIT) {
             s += 55U;
             r[j] &= 0x7fffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 55) {
             r[j] &= 0x7fffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 55 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_384.
  *
  * p   Point of type sp_point_384 (result).
  * pm  Point of type ecc_point.
  */
@@ -35568,91 +35592,94 @@ SP_NOINLINE static int sp_521_sub_9(sp_digit* r, const sp_digit* a,
 #endif /* WOLFSSL_SP_SMALL */
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_521_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 58
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 58
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x3ffffffffffffffL;
         s = 58U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 58U) <= (word32)DIGIT_BIT) {
             s += 58U;
             r[j] &= 0x3ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 58) {
             r[j] &= 0x3ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 58 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_521.
  *
  * p   Point of type sp_point_521 (result).
  * pm  Point of type ecc_point.
  */
@@ -43393,90 +43420,93 @@ static void sp_1024_point_free_18(sp_point_1024* p, int clear, void* heap)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_1024_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 57
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 57
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0x1ffffffffffffffL;
         s = 57U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 57U) <= (word32)DIGIT_BIT) {
             s += 57U;
             r[j] &= 0x1ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 57) {
             r[j] &= 0x1ffffffffffffffL;
             if (j + 1 >= size) {
                 break;
             }
             s = 57 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_1024.
  *
  * p   Point of type sp_point_1024 (result).
  * pm  Point of type ecc_point.
  */
diff --git a/wolfcrypt/src/sp_cortexm.c b/wolfcrypt/src/sp_cortexm.c
index 5601e0fcc..33e85ead7 100644
--- a/wolfcrypt/src/sp_cortexm.c
+++ b/wolfcrypt/src/sp_cortexm.c
@@ -115,91 +115,94 @@ static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 256
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -5915,91 +5918,94 @@ static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 384
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -11722,91 +11728,94 @@ static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Write r as big endian to byte array.
  * Fixed length number of bytes written: 512
  *
  * r  A single precision integer.
  * a  Byte array.
  */
@@ -16965,90 +16974,93 @@ static int sp_256_mod_mul_norm_8(sp_digit* r, const sp_digit* a, const sp_digit*
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_256_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_256.
  *
  * p   Point of type sp_point_256 (result).
  * pm  Point of type ecc_point.
  */
@@ -25517,90 +25529,93 @@ static int sp_384_mod_mul_norm_12(sp_digit* r, const sp_digit* a, const sp_digit
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_384_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_384.
  *
  * p   Point of type sp_point_384 (result).
  * pm  Point of type ecc_point.
  */
@@ -32715,90 +32730,93 @@ static int sp_521_mod_mul_norm_17(sp_digit* r, const sp_digit* a, const sp_digit
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_521_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_521.
  *
  * p   Point of type sp_point_521 (result).
  * pm  Point of type ecc_point.
  */
@@ -42405,90 +42423,93 @@ static void sp_1024_point_free_32(sp_point_1024* p, int clear, void* heap)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_1024_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 32
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 32
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffff;
         s = 32U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 32U) <= (word32)DIGIT_BIT) {
             s += 32U;
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 32) {
             r[j] &= 0xffffffff;
             if (j + 1 >= size) {
                 break;
             }
             s = 32 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_1024.
  *
  * p   Point of type sp_point_1024 (result).
  * pm  Point of type ecc_point.
  */
diff --git a/wolfcrypt/src/sp_x86_64.c b/wolfcrypt/src/sp_x86_64.c
index 1a1442708..b0c5abd91 100644
--- a/wolfcrypt/src/sp_x86_64.c
+++ b/wolfcrypt/src/sp_x86_64.c
@@ -104,86 +104,89 @@ static void sp_2048_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_2048_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 #ifdef __cplusplus
@@ -3049,86 +3052,89 @@ static void sp_3072_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_3072_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 #ifdef __cplusplus
@@ -5929,86 +5935,89 @@ static void sp_4096_from_bin(sp_digit* r, int size, const byte* a, int n)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_4096_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 #ifdef __cplusplus
@@ -8111,90 +8120,93 @@ static int sp_256_mod_mul_norm_4(sp_digit* r, const sp_digit* a, const sp_digit*
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_256_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_256.
  *
  * p   Point of type sp_point_256 (result).
  * pm  Point of type ecc_point.
  */
@@ -27091,90 +27103,93 @@ static int sp_384_mod_mul_norm_6(sp_digit* r, const sp_digit* a, const sp_digit*
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_384_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_384.
  *
  * p   Point of type sp_point_384 (result).
  * pm  Point of type ecc_point.
  */
@@ -51878,90 +51893,93 @@ static int sp_521_mod_mul_norm_9(sp_digit* r, const sp_digit* a, const sp_digit*
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_521_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_521.
  *
  * p   Point of type sp_point_521 (result).
  * pm  Point of type ecc_point.
  */
@@ -93031,90 +93049,93 @@ static void sp_1024_point_free_16(sp_point_1024* p, int clear, void* heap)
 /* Convert an mp_int to an array of sp_digit.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  A multi-precision integer.
  */
 static void sp_1024_from_mp(sp_digit* r, int size, const mp_int* a)
 {
 #if DIGIT_BIT == 64
-    int j;
-
-    XMEMCPY(r, a->dp, sizeof(sp_digit) * a->used);
+    int i;
+    int j = 0;
 
-    for (j = a->used; j < size; j++) {
-        r[j] = 0;
+    for (i = 0; i < size; i++) {
+        sp_digit mask =
+            (((sp_digit)(a->used - i - 1)) >> (SP_WORD_SIZE - 1)) - 1;
+        r[i] = a->dp[j] & mask;
+        j += (int)(((sp_digit)1) -
+                   (((sp_digit)(a->used - i - 2)) >> (SP_WORD_SIZE - 1)));
     }
 #elif DIGIT_BIT > 64
     int i;
     int j = 0;
     word32 s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i] << s);
         r[j] &= 0xffffffffffffffffl;
         s = 64U - s;
         if (j + 1 >= size) {
             break;
         }
         /* lint allow cast of mismatch word32 and mp_digit */
         r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
         while ((s + 64U) <= (word32)DIGIT_BIT) {
             s += 64U;
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             if (s < (word32)DIGIT_BIT) {
                 /* lint allow cast of mismatch word32 and mp_digit */
                 r[++j] = (sp_digit)(a->dp[i] >> s); /*lint !e9033*/
             }
             else {
                 r[++j] = (sp_digit)0;
             }
         }
         s = (word32)DIGIT_BIT - s;
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #else
     int i;
     int j = 0;
     int s = 0;
 
     r[0] = 0;
     for (i = 0; i < a->used && j < size; i++) {
         r[j] |= ((sp_digit)a->dp[i]) << s;
         if (s + DIGIT_BIT >= 64) {
             r[j] &= 0xffffffffffffffffl;
             if (j + 1 >= size) {
                 break;
             }
             s = 64 - s;
             if (s == DIGIT_BIT) {
                 r[++j] = 0;
                 s = 0;
             }
             else {
                 r[++j] = a->dp[i] >> s;
                 s = DIGIT_BIT - s;
             }
         }
         else {
             s += DIGIT_BIT;
         }
     }
 
     for (j++; j < size; j++) {
         r[j] = 0;
     }
 #endif
 }
 
 /* Convert a point of type ecc_point to type sp_point_1024.
  *
  * p   Point of type sp_point_1024 (result).
  * pm  Point of type ecc_point.
  */
