commit b1181b108601088e3704a0eb101d251ffafa867e
Merge: 646d3591b 96d0c0769
Author: Kim Kulling <kimkulling@users.noreply.github.com>
Date:   Sun Jun 25 21:20:02 2023 +0200

    Merge branch 'master' into 4508318827937792

diff --git a/code/AssetLib/DXF/DXFLoader.cpp b/code/AssetLib/DXF/DXFLoader.cpp
index 1fb9490cc..6b820d046 100644
--- a/code/AssetLib/DXF/DXFLoader.cpp
+++ b/code/AssetLib/DXF/DXFLoader.cpp
@@ -71,23 +71,24 @@ static const aiColor4D AI_DXF_DEFAULT_COLOR(aiColor4D(0.6f, 0.6f, 0.6f, 0.6f));
 // color indices for DXF - 16 are supported, the table is
 // taken directly from the DXF spec.
 static aiColor4D g_aclrDxfIndexColors[] = {
-    aiColor4D (0.6f, 0.6f, 0.6f, 1.0f),
+    aiColor4D(0.6f, 0.6f, 0.6f, 1.0f),
     aiColor4D (1.0f, 0.0f, 0.0f, 1.0f), // red
     aiColor4D (0.0f, 1.0f, 0.0f, 1.0f), // green
     aiColor4D (0.0f, 0.0f, 1.0f, 1.0f), // blue
     aiColor4D (0.3f, 1.0f, 0.3f, 1.0f), // light green
     aiColor4D (0.3f, 0.3f, 1.0f, 1.0f), // light blue
     aiColor4D (1.0f, 0.3f, 0.3f, 1.0f), // light red
     aiColor4D (1.0f, 0.0f, 1.0f, 1.0f), // pink
     aiColor4D (1.0f, 0.6f, 0.0f, 1.0f), // orange
     aiColor4D (0.6f, 0.3f, 0.0f, 1.0f), // dark orange
     aiColor4D (1.0f, 1.0f, 0.0f, 1.0f), // yellow
     aiColor4D (0.3f, 0.3f, 0.3f, 1.0f), // dark gray
     aiColor4D (0.8f, 0.8f, 0.8f, 1.0f), // light gray
     aiColor4D (0.0f, 00.f, 0.0f, 1.0f), // black
     aiColor4D (1.0f, 1.0f, 1.0f, 1.0f), // white
     aiColor4D (0.6f, 0.0f, 1.0f, 1.0f)  // violet
 };
+
 #define AI_DXF_NUM_INDEX_COLORS (sizeof(g_aclrDxfIndexColors)/sizeof(g_aclrDxfIndexColors[0]))
 #define AI_DXF_ENTITIES_MAGIC_BLOCK "$ASSIMP_ENTITIES_MAGIC"
 
@@ -99,24 +100,16 @@ static const int GroupCode_ZComp = 30;
 static const aiImporterDesc desc = {
     "Drawing Interchange Format (DXF) Importer",
     "",
     "",
     "",
     aiImporterFlags_SupportTextFlavour | aiImporterFlags_LimitedSupport,
     0,
     0,
     0,
     0,
     "dxf"
 };
 
-// ------------------------------------------------------------------------------------------------
-// Constructor to be privately used by Importer
-DXFImporter::DXFImporter() = default;
-
-// ------------------------------------------------------------------------------------------------
-// Destructor, private as well
-DXFImporter::~DXFImporter() = default;
-
 // ------------------------------------------------------------------------------------------------
 // Returns whether the class can handle the format of the given file.
 bool DXFImporter::CanRead( const std::string& filename, IOSystem* pIOHandler, bool /*checkSig*/ ) const {
@@ -215,139 +208,139 @@ void DXFImporter::InternReadFile( const std::string& filename, aiScene* pScene,
 // ------------------------------------------------------------------------------------------------
 void DXFImporter::ConvertMeshes(aiScene* pScene, DXF::FileData& output) {
     // the process of resolving all the INSERT statements can grow the
     // poly-count excessively, so log the original number.
     // XXX Option to import blocks as separate nodes?
     if (!DefaultLogger::isNullLogger()) {
         unsigned int vcount = 0, icount = 0;
         for (const DXF::Block& bl : output.blocks) {
             for (std::shared_ptr<const DXF::PolyLine> pl : bl.lines) {
                 vcount += static_cast<unsigned int>(pl->positions.size());
                 icount += static_cast<unsigned int>(pl->counts.size());
             }
         }
 
         ASSIMP_LOG_VERBOSE_DEBUG("DXF: Unexpanded polycount is ", icount, ", vertex count is ", vcount);
     }
 
-    if (! output.blocks.size()  ) {
+    if (output.blocks.empty()) {
         throw DeadlyImportError("DXF: no data blocks loaded");
     }
 
     DXF::Block* entities( nullptr );
 
     // index blocks by name
     DXF::BlockMap blocks_by_name;
     for (DXF::Block& bl : output.blocks) {
         blocks_by_name[bl.name] = &bl;
         if ( !entities && bl.name == AI_DXF_ENTITIES_MAGIC_BLOCK ) {
             entities = &bl;
         }
     }
 
     if (!entities) {
         throw DeadlyImportError("DXF: no ENTITIES data block loaded");
     }
 
     typedef std::map<std::string, unsigned int> LayerMap;
 
     LayerMap layers;
     std::vector< std::vector< const DXF::PolyLine*> > corr;
 
     // now expand all block references in the primary ENTITIES block
     // XXX this involves heavy memory copying, consider a faster solution for future versions.
     ExpandBlockReferences(*entities,blocks_by_name);
 
     unsigned int cur = 0;
     for (std::shared_ptr<const DXF::PolyLine> pl : entities->lines) {
         if (pl->positions.size()) {
 
             std::map<std::string, unsigned int>::iterator it = layers.find(pl->layer);
             if (it == layers.end()) {
                 ++pScene->mNumMeshes;
 
                 layers[pl->layer] = cur++;
 
                 std::vector< const DXF::PolyLine* > pv;
                 pv.push_back(&*pl);
 
                 corr.push_back(pv);
             }
             else {
                 corr[(*it).second].push_back(&*pl);
             }
         }
     }
 
     if ( 0 == pScene->mNumMeshes) {
         throw DeadlyImportError("DXF: this file contains no 3d data");
     }
 
     pScene->mMeshes = new aiMesh*[ pScene->mNumMeshes ] ();
 
     for(const LayerMap::value_type& elem : layers){
         aiMesh* const mesh =  pScene->mMeshes[elem.second] = new aiMesh();
         mesh->mName.Set(elem.first);
 
         unsigned int cvert = 0,cface = 0;
         for(const DXF::PolyLine* pl : corr[elem.second]){
             // sum over all faces since we need to 'verbosify' them.
             cvert += std::accumulate(pl->counts.begin(),pl->counts.end(),0);
             cface += static_cast<unsigned int>(pl->counts.size());
         }
 
         aiVector3D* verts = mesh->mVertices = new aiVector3D[cvert];
         aiColor4D* colors = mesh->mColors[0] = new aiColor4D[cvert];
         aiFace* faces = mesh->mFaces = new aiFace[cface];
 
         mesh->mNumVertices = cvert;
         mesh->mNumFaces = cface;
 
         unsigned int prims = 0;
         unsigned int overall_indices = 0;
         for(const DXF::PolyLine* pl : corr[elem.second]){
 
             std::vector<unsigned int>::const_iterator it = pl->indices.begin();
             for(unsigned int facenumv : pl->counts) {
                 aiFace& face = *faces++;
                 face.mIndices = new unsigned int[face.mNumIndices = facenumv];
 
                 for (unsigned int i = 0; i < facenumv; ++i) {
                     face.mIndices[i] = overall_indices++;
 
                     ai_assert(pl->positions.size() == pl->colors.size());
                     if (*it >= pl->positions.size()) {
                         throw DeadlyImportError("DXF: vertex index out of bounds");
                     }
 
                     *verts++ = pl->positions[*it];
                     *colors++ = pl->colors[*it++];
                 }
 
                 // set primitive flags now, this saves the extra pass in ScenePreprocessor.
                 switch(face.mNumIndices) {
                     case 1:
                         prims |= aiPrimitiveType_POINT;
                         break;
                     case 2:
                         prims |= aiPrimitiveType_LINE;
                         break;
                     case 3:
                         prims |= aiPrimitiveType_TRIANGLE;
                         break;
                     default:
                         prims |= aiPrimitiveType_POLYGON;
                         break;
                 }
             }
         }
 
         mesh->mPrimitiveTypes = prims;
         mesh->mMaterialIndex = 0;
     }
 
     GenerateHierarchy(pScene,output);
     GenerateMaterials(pScene,output);
 }
 
 
 // ------------------------------------------------------------------------------------------------
@@ -548,363 +541,362 @@ void DXFImporter::ParseEntities(DXF::LineReader& reader, DXF::FileData& output)
 void DXFImporter::ParseInsertion(DXF::LineReader& reader, DXF::FileData& output) {
     output.blocks.back().insertions.emplace_back();
     DXF::InsertBlock& bl = output.blocks.back().insertions.back();
 
     while( !reader.End() && !reader.Is(0)) {
         switch(reader.GroupCode()) {
             // name of referenced block
         case GroupCode_Name:
             bl.name = reader.Value();
             break;
 
             // translation
         case GroupCode_XComp:
             bl.pos.x = reader.ValueAsFloat();
             break;
         case GroupCode_YComp:
             bl.pos.y = reader.ValueAsFloat();
             break;
         case GroupCode_ZComp:
             bl.pos.z = reader.ValueAsFloat();
             break;
 
             // scaling
         case 41:
             bl.scale.x = reader.ValueAsFloat();
             break;
         case 42:
             bl.scale.y = reader.ValueAsFloat();
             break;
         case 43:
             bl.scale.z = reader.ValueAsFloat();
             break;
 
             // rotation angle
         case 50:
             bl.angle = reader.ValueAsFloat();
             break;
         }
         reader++;
     }
 }
 
-#define DXF_POLYLINE_FLAG_CLOSED        0x1
-#define DXF_POLYLINE_FLAG_3D_POLYLINE   0x8
-#define DXF_POLYLINE_FLAG_3D_POLYMESH   0x10
-#define DXF_POLYLINE_FLAG_POLYFACEMESH  0x40
+static constexpr unsigned int DXF_POLYLINE_FLAG_CLOSED = 0x1;
+// Currently unused
+//static constexpr unsigned int DXF_POLYLINE_FLAG_3D_POLYLINE = 0x8;
+//static constexpr unsigned int DXF_POLYLINE_FLAG_3D_POLYMESH = 0x10;
+static constexpr unsigned int DXF_POLYLINE_FLAG_POLYFACEMESH = 0x40;
 
 // ------------------------------------------------------------------------------------------------
 void DXFImporter::ParsePolyLine(DXF::LineReader& reader, DXF::FileData& output) {
     output.blocks.back().lines.push_back( std::shared_ptr<DXF::PolyLine>( new DXF::PolyLine() ) );
     DXF::PolyLine& line = *output.blocks.back().lines.back();
 
     unsigned int iguess = 0, vguess = 0;
     while( !reader.End() && !reader.Is(0,"ENDSEC")) {
 
         if (reader.Is(0,"VERTEX")) {
             ParsePolyLineVertex(++reader,line);
             if (reader.Is(0,"SEQEND")) {
                 break;
             }
             continue;
         }
 
         switch(reader.GroupCode())
         {
         // flags --- important that we know whether it is a
         // polyface mesh or 'just' a line.
         case 70:
             if (!line.flags)    {
                 line.flags = reader.ValueAsSignedInt();
             }
             break;
 
         // optional number of vertices
         case 71:
             vguess = reader.ValueAsSignedInt();
             line.positions.reserve(vguess);
             break;
 
         // optional number of faces
         case 72:
             iguess = reader.ValueAsSignedInt();
             line.indices.reserve(iguess);
             break;
 
         // 8 specifies the layer on which this line is placed on
         case 8:
             line.layer = reader.Value();
             break;
         }
 
         reader++;
     }
 
-    //if (!(line.flags & DXF_POLYLINE_FLAG_POLYFACEMESH))   {
-    //  DefaultLogger::get()->warn((Formatter::format("DXF: polyline not currently supported: "),line.flags));
-    //  output.blocks.back().lines.pop_back();
-    //  return;
-    //}
-
     if (vguess && line.positions.size() != vguess) {
         ASSIMP_LOG_WARN("DXF: unexpected vertex count in polymesh: ",
             line.positions.size(),", expected ", vguess );
     }
 
     if (line.flags & DXF_POLYLINE_FLAG_POLYFACEMESH ) {
         if (line.positions.size() < 3 || line.indices.size() < 3)   {
             ASSIMP_LOG_WARN("DXF: not enough vertices for polymesh; ignoring");
             output.blocks.back().lines.pop_back();
             return;
         }
 
         // if these numbers are wrong, parsing might have gone wild.
         // however, the docs state that applications are not required
         // to set the 71 and 72 fields, respectively, to valid values.
         // So just fire a warning.
         if (iguess && line.counts.size() != iguess) {
             ASSIMP_LOG_WARN( "DXF: unexpected face count in polymesh: ", line.counts.size(),", expected ", iguess );
         }
     }
     else if (!line.indices.size() && !line.counts.size()) {
         // a poly-line - so there are no indices yet.
         size_t guess = line.positions.size() + (line.flags & DXF_POLYLINE_FLAG_CLOSED ? 1 : 0);
         line.indices.reserve(guess);
 
         line.counts.reserve(guess/2);
         for (unsigned int i = 0; i < line.positions.size()/2; ++i) {
             line.indices.push_back(i*2);
             line.indices.push_back(i*2+1);
             line.counts.push_back(2);
         }
 
         // closed polyline?
         if (line.flags & DXF_POLYLINE_FLAG_CLOSED) {
             line.indices.push_back(static_cast<unsigned int>(line.positions.size()-1));
             line.indices.push_back(0);
             line.counts.push_back(2);
         }
     }
 }
 
 #define DXF_VERTEX_FLAG_PART_OF_POLYFACE 0x80
 #define DXF_VERTEX_FLAG_HAS_POSITIONS 0x40
 
 // ------------------------------------------------------------------------------------------------
 void DXFImporter::ParsePolyLineVertex(DXF::LineReader& reader, DXF::PolyLine& line) {
     unsigned int cnti = 0, flags = 0;
     unsigned int indices[4];
 
     aiVector3D out;
     aiColor4D clr = AI_DXF_DEFAULT_COLOR;
 
     while( !reader.End() ) {
 
         if (reader.Is(0)) { // SEQEND or another VERTEX
             break;
         }
 
         switch (reader.GroupCode()) {
         case 8:
                 // layer to which the vertex belongs to - assume that
                 // this is always the layer the top-level poly-line
                 // entity resides on as well.
                 if(reader.Value() != line.layer) {
                     ASSIMP_LOG_WARN("DXF: expected vertex to be part of a poly-face but the 0x128 flag isn't set");
                 }
                 break;
 
         case 70:
                 flags = reader.ValueAsUnsignedInt();
                 break;
 
         // VERTEX COORDINATES
         case GroupCode_XComp:
             out.x = reader.ValueAsFloat();
             break;
 
         case GroupCode_YComp:
             out.y = reader.ValueAsFloat();
             break;
 
         case GroupCode_ZComp:
             out.z = reader.ValueAsFloat();
             break;
 
         // POLYFACE vertex indices
         case 71:
         case 72:
         case 73:
-        case 74:
-            if (cnti == 4) {
-                ASSIMP_LOG_WARN("DXF: more than 4 indices per face not supported; ignoring");
-                break;
+        case 74: {
+                if (cnti == 4) {
+                    ASSIMP_LOG_WARN("DXF: more than 4 indices per face not supported; ignoring");
+                    break;
+                }
+                const int index = reader.ValueAsSignedInt();
+                if (index >= 0) {
+                    indices[cnti++] = static_cast<unsigned int>(index);
+                } else {
+                    ASSIMP_LOG_WARN("DXF: Skip invisible face.");
+                }
             }
-            indices[cnti++] = reader.ValueAsUnsignedInt();
             break;
 
         // color
         case 62:
             clr = g_aclrDxfIndexColors[reader.ValueAsUnsignedInt() % AI_DXF_NUM_INDEX_COLORS];
             break;
         };
 
         reader++;
     }
 
     if (line.flags & DXF_POLYLINE_FLAG_POLYFACEMESH && !(flags & DXF_VERTEX_FLAG_PART_OF_POLYFACE)) {
         ASSIMP_LOG_WARN("DXF: expected vertex to be part of a polyface but the 0x128 flag isn't set");
     }
 
     if (cnti) {
         line.counts.push_back(cnti);
         for (unsigned int i = 0; i < cnti; ++i) {
             // IMPORTANT NOTE: POLYMESH indices are ONE-BASED
             if (indices[i] == 0) {
                 ASSIMP_LOG_WARN("DXF: invalid vertex index, indices are one-based.");
                 --line.counts.back();
                 // Workaround to fix issue 2229
                 if (line.counts.back() == 0) {
                     line.counts.pop_back();
                 }
                 continue;
             }
             line.indices.push_back(indices[i]-1);
         }
     } else {
         line.positions.push_back(out);
         line.colors.push_back(clr);
     }
 }
 
 // ------------------------------------------------------------------------------------------------
-void DXFImporter::Parse3DFace(DXF::LineReader& reader, DXF::FileData& output)
-{
+void DXFImporter::Parse3DFace(DXF::LineReader& reader, DXF::FileData& output) {
     // (note) this is also used for for parsing line entities, so we
     // must handle the vertex_count == 2 case as well.
 
     output.blocks.back().lines.push_back( std::shared_ptr<DXF::PolyLine>( new DXF::PolyLine() )  );
     DXF::PolyLine& line = *output.blocks.back().lines.back();
 
     aiVector3D vip[4];
     aiColor4D  clr = AI_DXF_DEFAULT_COLOR;
 
     bool b[4] = {false,false,false,false};
     while( !reader.End() ) {
 
         // next entity with a groupcode == 0 is probably already the next vertex or polymesh entity
         if (reader.GroupCode() == 0) {
             break;
         }
-        switch (reader.GroupCode())
-        {
+        switch (reader.GroupCode()) {
 
         // 8 specifies the layer
         case 8:
             line.layer = reader.Value();
             break;
 
         // x position of the first corner
         case 10:
             vip[0].x = reader.ValueAsFloat();
             b[2] = true;
             break;
 
         // y position of the first corner
         case 20:
             vip[0].y = reader.ValueAsFloat();
             b[2] = true;
             break;
 
         // z position of the first corner
         case 30:
             vip[0].z = reader.ValueAsFloat();
             b[2] = true;
             break;
 
         // x position of the second corner
         case 11:
             vip[1].x = reader.ValueAsFloat();
             b[3] = true;
             break;
 
         // y position of the second corner
         case 21:
             vip[1].y = reader.ValueAsFloat();
             b[3] = true;
             break;
 
         // z position of the second corner
         case 31:
             vip[1].z = reader.ValueAsFloat();
             b[3] = true;
             break;
 
         // x position of the third corner
         case 12:
             vip[2].x = reader.ValueAsFloat();
             b[0] = true;
             break;
 
         // y position of the third corner
         case 22:
             vip[2].y = reader.ValueAsFloat();
             b[0] = true;
             break;
 
         // z position of the third corner
         case 32:
             vip[2].z = reader.ValueAsFloat();
             b[0] = true;
             break;
 
         // x position of the fourth corner
         case 13:
             vip[3].x = reader.ValueAsFloat();
             b[1] = true;
             break;
 
         // y position of the fourth corner
         case 23:
             vip[3].y = reader.ValueAsFloat();
             b[1] = true;
             break;
 
         // z position of the fourth corner
         case 33:
             vip[3].z = reader.ValueAsFloat();
             b[1] = true;
             break;
 
         // color
         case 62:
             clr = g_aclrDxfIndexColors[reader.ValueAsUnsignedInt() % AI_DXF_NUM_INDEX_COLORS];
             break;
         };
 
         ++reader;
     }
 
     // the fourth corner may even be identical to the third,
     // in this case we treat it as if it didn't exist.
     if (vip[3] == vip[2]) {
         b[1] = false;
     }
 
     // sanity checks to see if we got something meaningful
     if ((b[1] && !b[0]) || !b[2] || !b[3]) {
         ASSIMP_LOG_WARN("DXF: unexpected vertex setup in 3DFACE/LINE/FACE entity; ignoring");
         output.blocks.back().lines.pop_back();
         return;
     }
 
     const unsigned int cnt = (2+(b[0]?1:0)+(b[1]?1:0));
     line.counts.push_back(cnt);
 
     for (unsigned int i = 0; i < cnt; ++i) {
         line.indices.push_back(static_cast<unsigned int>(line.positions.size()));
         line.positions.push_back(vip[i]);
         line.colors.push_back(clr);
     }
 }
 
 #endif // !! ASSIMP_BUILD_NO_DXF_IMPORTER
diff --git a/code/AssetLib/DXF/DXFLoader.h b/code/AssetLib/DXF/DXFLoader.h
index b32ae106f..89a0b79c2 100644
--- a/code/AssetLib/DXF/DXFLoader.h
+++ b/code/AssetLib/DXF/DXFLoader.h
@@ -68,11 +68,11 @@ namespace DXF {
  */
 class DXFImporter : public BaseImporter {
 public:
-    DXFImporter();
-    ~DXFImporter() override;
+    DXFImporter() = default;
+    ~DXFImporter() override = default;
 
     // -------------------------------------------------------------------
     /** Returns whether the class can handle the format of the given file.
     * See BaseImporter::CanRead() for details.  */
     bool CanRead( const std::string& pFile, IOSystem* pIOHandler,
         bool checkSig) const override;
diff --git a/code/AssetLib/MDL/MDLMaterialLoader.cpp b/code/AssetLib/MDL/MDLMaterialLoader.cpp
index fbda40151..f00b6bd03 100644
--- a/code/AssetLib/MDL/MDLMaterialLoader.cpp
+++ b/code/AssetLib/MDL/MDLMaterialLoader.cpp
@@ -442,239 +442,239 @@ void MDLImporter::CreateTexture_3DGS_MDL5(const unsigned char *szData,
 // ------------------------------------------------------------------------------------------------
 // Get a skin from a MDL7 file - more complex than all other subformats
 void MDLImporter::ParseSkinLump_3DGS_MDL7(
         const unsigned char *szCurrent,
         const unsigned char **szCurrentOut,
         aiMaterial *pcMatOut,
         unsigned int iType,
         unsigned int iWidth,
         unsigned int iHeight) {
     std::unique_ptr<aiTexture> pcNew;
     if (szCurrent == nullptr) {
         return;
     }
 
     // get the type of the skin
     unsigned int iMasked = (unsigned int)(iType & 0xF);
 
     if (0x1 == iMasked) {
         // ***** REFERENCE TO ANOTHER SKIN INDEX *****
         int referrer = (int)iWidth;
         pcMatOut->AddProperty<int>(&referrer, 1, AI_MDL7_REFERRER_MATERIAL);
     } else if (0x6 == iMasked) {
         // ***** EMBEDDED DDS FILE *****
         if (1 != iHeight) {
             ASSIMP_LOG_WARN("Found a reference to an embedded DDS texture, "
                             "but texture height is not equal to 1, which is not supported by MED");
         }
         if (iWidth == 0) {
             ASSIMP_LOG_ERROR("Found a reference to an embedded DDS texture, but texture width is zero, aborting import.");
             return;
         }
 
         pcNew.reset(new aiTexture);
         pcNew->mHeight = 0;
         pcNew->mWidth = iWidth;
 
         // place a proper format hint
         pcNew->achFormatHint[0] = 'd';
         pcNew->achFormatHint[1] = 'd';
         pcNew->achFormatHint[2] = 's';
         pcNew->achFormatHint[3] = '\0';
 
         pcNew->pcData = (aiTexel *)new unsigned char[pcNew->mWidth];
         memcpy(pcNew->pcData, szCurrent, pcNew->mWidth);
         szCurrent += iWidth;
     } else if (0x7 == iMasked) {
         // ***** REFERENCE TO EXTERNAL FILE *****
         if (1 != iHeight) {
             ASSIMP_LOG_WARN("Found a reference to an external texture, "
                             "but texture height is not equal to 1, which is not supported by MED");
         }
 
         aiString szFile;
         const size_t iLen = strlen((const char *)szCurrent);
-        size_t iLen2 = iLen + 1;
-        iLen2 = iLen2 > MAXLEN ? MAXLEN : iLen2;
+        size_t iLen2 = iLen > (MAXLEN - 1) ? (MAXLEN - 1) : iLen;
         memcpy(szFile.data, (const char *)szCurrent, iLen2);
+        szFile.data[iLen2] = '\0';
         szFile.length = static_cast<ai_uint32>(iLen2);
 
-        szCurrent += iLen2;
+        szCurrent += iLen2 + 1;
 
         // place this as diffuse texture
         pcMatOut->AddProperty(&szFile, AI_MATKEY_TEXTURE_DIFFUSE(0));
     } else if (iMasked || !iType || (iType && iWidth && iHeight)) {
         pcNew.reset(new aiTexture());
         if (!iHeight || !iWidth) {
             ASSIMP_LOG_WARN("Found embedded texture, but its width "
                             "an height are both 0. Is this a joke?");
 
             // generate an empty chess pattern
             pcNew->mWidth = pcNew->mHeight = 8;
             pcNew->pcData = new aiTexel[64];
             for (unsigned int x = 0; x < 8; ++x) {
                 for (unsigned int y = 0; y < 8; ++y) {
                     const bool bSet = ((0 == x % 2 && 0 != y % 2) ||
                                        (0 != x % 2 && 0 == y % 2));
 
                     aiTexel *pc = &pcNew->pcData[y * 8 + x];
                     pc->r = pc->b = pc->g = (bSet ? 0xFF : 0);
                     pc->a = 0xFF;
                 }
             }
         } else {
             // it is a standard color texture. Fill in width and height
             // and call the same function we used for loading MDL5 files
 
             pcNew->mWidth = iWidth;
             pcNew->mHeight = iHeight;
 
             unsigned int iSkip = 0;
             ParseTextureColorData(szCurrent, iMasked, &iSkip, pcNew.get());
 
             // skip length of texture data
             szCurrent += iSkip;
         }
     }
 
     // sometimes there are MDL7 files which have a monochrome
     // texture instead of material colors ... possible they have
     // been converted to MDL7 from other formats, such as MDL5
     aiColor4D clrTexture;
     if (pcNew)
         clrTexture = ReplaceTextureWithColor(pcNew.get());
     else
         clrTexture.r = get_qnan();
 
     // check whether a material definition is contained in the skin
     if (iType & AI_MDL7_SKINTYPE_MATERIAL) {
         BE_NCONST MDL::Material_MDL7 *pcMatIn = (BE_NCONST MDL::Material_MDL7 *)szCurrent;
         szCurrent = (unsigned char *)(pcMatIn + 1);
         VALIDATE_FILE_SIZE(szCurrent);
 
         aiColor3D clrTemp;
 
 #define COLOR_MULTIPLY_RGB()         \
     if (is_not_qnan(clrTexture.r)) { \
         clrTemp.r *= clrTexture.r;   \
         clrTemp.g *= clrTexture.g;   \
         clrTemp.b *= clrTexture.b;   \
     }
 
         // read diffuse color
         clrTemp.r = pcMatIn->Diffuse.r;
         AI_SWAP4(clrTemp.r);
         clrTemp.g = pcMatIn->Diffuse.g;
         AI_SWAP4(clrTemp.g);
         clrTemp.b = pcMatIn->Diffuse.b;
         AI_SWAP4(clrTemp.b);
         COLOR_MULTIPLY_RGB();
         pcMatOut->AddProperty<aiColor3D>(&clrTemp, 1, AI_MATKEY_COLOR_DIFFUSE);
 
         // read specular color
         clrTemp.r = pcMatIn->Specular.r;
         AI_SWAP4(clrTemp.r);
         clrTemp.g = pcMatIn->Specular.g;
         AI_SWAP4(clrTemp.g);
         clrTemp.b = pcMatIn->Specular.b;
         AI_SWAP4(clrTemp.b);
         COLOR_MULTIPLY_RGB();
         pcMatOut->AddProperty<aiColor3D>(&clrTemp, 1, AI_MATKEY_COLOR_SPECULAR);
 
         // read ambient color
         clrTemp.r = pcMatIn->Ambient.r;
         AI_SWAP4(clrTemp.r);
         clrTemp.g = pcMatIn->Ambient.g;
         AI_SWAP4(clrTemp.g);
         clrTemp.b = pcMatIn->Ambient.b;
         AI_SWAP4(clrTemp.b);
         COLOR_MULTIPLY_RGB();
         pcMatOut->AddProperty<aiColor3D>(&clrTemp, 1, AI_MATKEY_COLOR_AMBIENT);
 
         // read emissive color
         clrTemp.r = pcMatIn->Emissive.r;
         AI_SWAP4(clrTemp.r);
         clrTemp.g = pcMatIn->Emissive.g;
         AI_SWAP4(clrTemp.g);
         clrTemp.b = pcMatIn->Emissive.b;
         AI_SWAP4(clrTemp.b);
         pcMatOut->AddProperty<aiColor3D>(&clrTemp, 1, AI_MATKEY_COLOR_EMISSIVE);
 
 #undef COLOR_MULITPLY_RGB
 
         // FIX: Take the opacity from the ambient color.
         // The doc say something else, but it is fact that MED exports the
         // opacity like this .... oh well.
         clrTemp.r = pcMatIn->Ambient.a;
         AI_SWAP4(clrTemp.r);
         if (is_not_qnan(clrTexture.r)) {
             clrTemp.r *= clrTexture.a;
         }
         pcMatOut->AddProperty<ai_real>(&clrTemp.r, 1, AI_MATKEY_OPACITY);
 
         // read phong power
         int iShadingMode = (int)aiShadingMode_Gouraud;
         AI_SWAP4(pcMatIn->Power);
         if (0.0f != pcMatIn->Power) {
             iShadingMode = (int)aiShadingMode_Phong;
             // pcMatIn is packed, we can't form pointers to its members
             float power = pcMatIn->Power;
             pcMatOut->AddProperty<float>(&power, 1, AI_MATKEY_SHININESS);
         }
         pcMatOut->AddProperty<int>(&iShadingMode, 1, AI_MATKEY_SHADING_MODEL);
     } else if (is_not_qnan(clrTexture.r)) {
         pcMatOut->AddProperty<aiColor4D>(&clrTexture, 1, AI_MATKEY_COLOR_DIFFUSE);
         pcMatOut->AddProperty<aiColor4D>(&clrTexture, 1, AI_MATKEY_COLOR_SPECULAR);
     }
     // if the texture could be replaced by a single material color
     // we don't need the texture anymore
     if (is_not_qnan(clrTexture.r)) {
         pcNew.reset();
     }
 
     // If an ASCII effect description (HLSL?) is contained in the file,
     // we can simply ignore it ...
     if (iType & AI_MDL7_SKINTYPE_MATERIAL_ASCDEF) {
         VALIDATE_FILE_SIZE(szCurrent);
         int32_t iMe = *((int32_t *)szCurrent);
         AI_SWAP4(iMe);
         szCurrent += sizeof(char) * iMe + sizeof(int32_t);
         VALIDATE_FILE_SIZE(szCurrent);
     }
 
     // If an embedded texture has been loaded setup the corresponding
     // data structures in the aiScene instance
     if (pcNew && pScene->mNumTextures <= 999) {
         // place this as diffuse texture
         char current[5];
         ai_snprintf(current, 5, "*%i", this->pScene->mNumTextures);
 
         aiString szFile;
         const size_t iLen = strlen((const char *)current);
         ::memcpy(szFile.data, (const char *)current, iLen + 1);
         szFile.length = (ai_uint32)iLen;
 
         pcMatOut->AddProperty(&szFile, AI_MATKEY_TEXTURE_DIFFUSE(0));
 
         // store the texture
         if (!pScene->mNumTextures) {
             pScene->mNumTextures = 1;
             pScene->mTextures = new aiTexture *[1];
             pScene->mTextures[0] = pcNew.release();
         } else {
             aiTexture **pc = pScene->mTextures;
             pScene->mTextures = new aiTexture *[pScene->mNumTextures + 1];
             for (unsigned int i = 0; i < pScene->mNumTextures; ++i) {
                 pScene->mTextures[i] = pc[i];
             }
 
             pScene->mTextures[pScene->mNumTextures] = pcNew.release();
             pScene->mNumTextures++;
             delete[] pc;
         }
     }
     VALIDATE_FILE_SIZE(szCurrent);
     *szCurrentOut = szCurrent;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Skip a skin lump
diff --git a/code/AssetLib/OFF/OFFLoader.cpp b/code/AssetLib/OFF/OFFLoader.cpp
index cb265029a..f50afb57b 100644
--- a/code/AssetLib/OFF/OFFLoader.cpp
+++ b/code/AssetLib/OFF/OFFLoader.cpp
@@ -106,228 +106,228 @@ static void NextToken(const char **car, const char* end) {
 // ------------------------------------------------------------------------------------------------
 // Imports the given file into the given scene structure.
 void OFFImporter::InternReadFile( const std::string& pFile, aiScene* pScene, IOSystem* pIOHandler) {
     std::unique_ptr<IOStream> file( pIOHandler->Open( pFile, "rb"));
 
     // Check whether we can read from the file
     if (file == nullptr) {
       throw DeadlyImportError("Failed to open OFF file ", pFile, ".");
     }
 
     // allocate storage and copy the contents of the file to a memory buffer
     std::vector<char> mBuffer2;
     TextFileToBuffer(file.get(),mBuffer2);
     const char* buffer = &mBuffer2[0];
 
     // Proper OFF header parser. We only implement normal loading for now.
     bool hasTexCoord = false, hasNormals = false, hasColors = false;
     bool hasHomogenous = false, hasDimension = false;
     unsigned int dimensions = 3;
     const char* car = buffer;
     const char* end = buffer + mBuffer2.size();
     NextToken(&car, end);
 
     if (car < end - 2 && car[0] == 'S' && car[1] == 'T') {
       hasTexCoord = true; car += 2;
     }
     if (car < end - 1 && car[0] == 'C') {
       hasColors = true; car++;
     }
     if (car < end- 1 && car[0] == 'N') {
       hasNormals = true; car++;
     }
     if (car < end - 1 && car[0] == '4') {
       hasHomogenous = true; car++;
     }
     if (car < end - 1 && car[0] == 'n') {
       hasDimension = true; car++;
     }
     if (car < end - 3 && car[0] == 'O' && car[1] == 'F' && car[2] == 'F') {
         car += 3;
 	NextToken(&car, end);
     } else {
       // in case there is no OFF header (which is allowed by the
       // specification...), then we might have unintentionally read an
       // additional dimension from the primitive count fields
       dimensions = 3;
       hasHomogenous = false;
       NextToken(&car, end);
 
       // at this point the next token should be an integer number
       if (car >= end - 1 || *car < '0' || *car > '9') {
 	throw DeadlyImportError("OFF: Header is invalid");
       }
     }
     if (hasDimension) {
         dimensions = strtoul10(car, &car);
 	NextToken(&car, end);
     }
     if (dimensions > 3) {
         throw DeadlyImportError
 	  ("OFF: Number of vertex coordinates higher than 3 unsupported");
     }
 
     NextToken(&car, end);
     const unsigned int numVertices = strtoul10(car, &car);
     NextToken(&car, end);
     const unsigned int numFaces = strtoul10(car, &car);
     NextToken(&car, end);
     strtoul10(car, &car);  // skip edge count
     NextToken(&car, end);
 
     if (!numVertices) {
         throw DeadlyImportError("OFF: There are no valid vertices");
     }
     if (!numFaces) {
         throw DeadlyImportError("OFF: There are no valid faces");
     }
 
     pScene->mNumMeshes = 1;
     pScene->mMeshes = new aiMesh*[ pScene->mNumMeshes ];
 
     aiMesh* mesh = new aiMesh();
     pScene->mMeshes[0] = mesh;
 
     mesh->mNumFaces = numFaces;
     aiFace* faces = new aiFace[mesh->mNumFaces];
     mesh->mFaces = faces;
 
     mesh->mNumVertices = numVertices;
     mesh->mVertices = new aiVector3D[numVertices];
     mesh->mNormals = hasNormals ? new aiVector3D[numVertices] : nullptr;
     mesh->mColors[0] = hasColors ? new aiColor4D[numVertices] : nullptr;
 
     if (hasTexCoord) {
         mesh->mNumUVComponents[0] = 2;
         mesh->mTextureCoords[0] = new aiVector3D[numVertices];
     }
     char line[4096];
     buffer = car;
     const char *sz = car;
 
     // now read all vertex lines
     for (unsigned int i = 0; i < numVertices; ++i) {
         if(!GetNextLine(buffer, line)) {
             ASSIMP_LOG_ERROR("OFF: The number of verts in the header is incorrect");
             break;
         }
         aiVector3D& v = mesh->mVertices[i];
         sz = line;
 
 	// helper array to write a for loop over possible dimension values
 	ai_real* vec[3] = {&v.x, &v.y, &v.z};
 
 	// stop at dimensions: this allows loading 1D or 2D coordinate vertices
         for (unsigned int dim = 0; dim < dimensions; ++dim ) {
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz, *vec[dim]);
 	}
 
 	// if has homogeneous coordinate, divide others by this one
 	if (hasHomogenous) {
 	    SkipSpaces(&sz);
 	    ai_real w = 1.;
 	    sz = fast_atoreal_move<ai_real>(sz, w);
             for (unsigned int dim = 0; dim < dimensions; ++dim ) {
 	        *(vec[dim]) /= w;
 	    }
 	}
 
 	// read optional normals
 	if (hasNormals) {
 	    aiVector3D& n = mesh->mNormals[i];
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz,(ai_real&)n.x);
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz,(ai_real&)n.y);
 	    SkipSpaces(&sz);
 	    fast_atoreal_move<ai_real>(sz,(ai_real&)n.z);
 	}
 
 	// reading colors is a pain because the specification says it can be
 	// integers or floats, and any number of them between 1 and 4 included,
 	// until the next comment or end of line
 	// in theory should be testing type !
 	if (hasColors) {
 	    aiColor4D& c = mesh->mColors[0][i];
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz,(ai_real&)c.r);
             if (*sz != '#' && *sz != '\n' && *sz != '\r') {
 	        SkipSpaces(&sz);
 	        sz = fast_atoreal_move<ai_real>(sz,(ai_real&)c.g);
             } else {
 	        c.g = 0.;
 	    }
             if (*sz != '#' && *sz != '\n' && *sz != '\r') {
 	        SkipSpaces(&sz);
 	        sz = fast_atoreal_move<ai_real>(sz,(ai_real&)c.b);
             } else {
 	        c.b = 0.;
 	    }
             if (*sz != '#' && *sz != '\n' && *sz != '\r') {
 	        SkipSpaces(&sz);
 	        sz = fast_atoreal_move<ai_real>(sz,(ai_real&)c.a);
             } else {
 	        c.a = 1.;
 	    }
 	}
         if (hasTexCoord) {
 	    aiVector3D& t = mesh->mTextureCoords[0][i];
 	    SkipSpaces(&sz);
 	    sz = fast_atoreal_move<ai_real>(sz,(ai_real&)t.x);
 	    SkipSpaces(&sz);
 	    fast_atoreal_move<ai_real>(sz,(ai_real&)t.y);
 	}
     }
 
     // load faces with their indices
     faces = mesh->mFaces;
     for (unsigned int i = 0; i < numFaces; ) {
         if(!GetNextLine(buffer,line)) {
             ASSIMP_LOG_ERROR("OFF: The number of faces in the header is incorrect");
-            break;
+            throw DeadlyImportError("OFF: The number of faces in the header is incorrect");
         }
         unsigned int idx;
         sz = line; SkipSpaces(&sz);
         idx = strtoul10(sz,&sz);
         if(!idx || idx > 9) {
 	        ASSIMP_LOG_ERROR("OFF: Faces with zero indices aren't allowed");
             --mesh->mNumFaces;
             ++i;
             continue;
 	    }
 	    faces->mNumIndices = idx;
         faces->mIndices = new unsigned int[faces->mNumIndices];
         for (unsigned int m = 0; m < faces->mNumIndices;++m) {
             SkipSpaces(&sz);
             idx = strtoul10(sz,&sz);
             if (idx >= numVertices) {
                 ASSIMP_LOG_ERROR("OFF: Vertex index is out of range");
                 idx = numVertices - 1;
             }
             faces->mIndices[m] = idx;
         }
         ++i;
         ++faces;
     }
 
     // generate the output node graph
     pScene->mRootNode = new aiNode();
     pScene->mRootNode->mName.Set("<OFFRoot>");
     pScene->mRootNode->mNumMeshes = 1;
     pScene->mRootNode->mMeshes = new unsigned int [pScene->mRootNode->mNumMeshes];
     pScene->mRootNode->mMeshes[0] = 0;
 
     // generate a default material
     pScene->mNumMaterials = 1;
     pScene->mMaterials = new aiMaterial*[pScene->mNumMaterials];
     aiMaterial* pcMat = new aiMaterial();
 
     aiColor4D clr( ai_real( 0.6 ), ai_real( 0.6 ), ai_real( 0.6 ), ai_real( 1.0 ) );
     pcMat->AddProperty(&clr,1,AI_MATKEY_COLOR_DIFFUSE);
     pScene->mMaterials[0] = pcMat;
 
     const int twosided = 1;
     pcMat->AddProperty(&twosided, 1, AI_MATKEY_TWOSIDED);
 }
 
 #endif // !! ASSIMP_BUILD_NO_OFF_IMPORTER
diff --git a/code/AssetLib/Obj/ObjFileParser.cpp b/code/AssetLib/Obj/ObjFileParser.cpp
index ed416dc93..ad97a470b 100644
--- a/code/AssetLib/Obj/ObjFileParser.cpp
+++ b/code/AssetLib/Obj/ObjFileParser.cpp
@@ -427,115 +427,126 @@ static constexpr char DefaultObjName[] = "defaultobject";
 void ObjFileParser::getFace(aiPrimitiveType type) {
     m_DataIt = getNextToken<DataArrayIt>(m_DataIt, m_DataItEnd);
     if (m_DataIt == m_DataItEnd || *m_DataIt == '\0') {
         return;
     }
 
     ObjFile::Face *face = new ObjFile::Face(type);
     bool hasNormal = false;
 
     const int vSize = static_cast<unsigned int>(m_pModel->mVertices.size());
     const int vtSize = static_cast<unsigned int>(m_pModel->mTextureCoord.size());
     const int vnSize = static_cast<unsigned int>(m_pModel->mNormals.size());
 
     const bool vt = (!m_pModel->mTextureCoord.empty());
     const bool vn = (!m_pModel->mNormals.empty());
     int iPos = 0;
     while (m_DataIt < m_DataItEnd) {
         int iStep = 1;
 
         if (IsLineEnd(*m_DataIt)) {
             break;
         }
 
         if (*m_DataIt == '/') {
             if (type == aiPrimitiveType_POINT) {
                 ASSIMP_LOG_ERROR("Obj: Separator unexpected in point statement");
             }
             iPos++;
         } else if (IsSpaceOrNewLine(*m_DataIt)) {
             iPos = 0;
         } else {
             //OBJ USES 1 Base ARRAYS!!!!
-            const char *token = &(*m_DataIt);
-            const int iVal = ::atoi(token);
+            int iVal;
+            auto end = m_DataIt;
+            // find either the buffer end or the '\0'
+            while (end < m_DataItEnd && *end != '\0')
+                ++end;
+            // avoid temporary string allocation if there is a zero
+            if (end != m_DataItEnd) {
+                iVal = ::atoi(&(*m_DataIt));
+            } else {
+                // otherwise make a zero terminated copy, which is safe to pass to atoi
+                std::string number(&(*m_DataIt), m_DataItEnd - m_DataIt);
+                iVal = ::atoi(number.c_str());
+            }
 
             // increment iStep position based off of the sign and # of digits
             int tmp = iVal;
             if (iVal < 0) {
                 ++iStep;
             }
             while ((tmp = tmp / 10) != 0) {
                 ++iStep;
             }
 
             if (iPos == 1 && !vt && vn)
                 iPos = 2; // skip texture coords for normals if there are no tex coords
 
             if (iVal > 0) {
                 // Store parsed index
                 if (0 == iPos) {
                     face->m_vertices.push_back(iVal - 1);
                 } else if (1 == iPos) {
                     face->m_texturCoords.push_back(iVal - 1);
                 } else if (2 == iPos) {
                     face->m_normals.push_back(iVal - 1);
                     hasNormal = true;
                 } else {
                     reportErrorTokenInFace();
                 }
             } else if (iVal < 0) {
                 // Store relatively index
                 if (0 == iPos) {
                     face->m_vertices.push_back(vSize + iVal);
                 } else if (1 == iPos) {
                     face->m_texturCoords.push_back(vtSize + iVal);
                 } else if (2 == iPos) {
                     face->m_normals.push_back(vnSize + iVal);
                     hasNormal = true;
                 } else {
                     reportErrorTokenInFace();
                 }
             } else {
                 //On error, std::atoi will return 0 which is not a valid value
                 delete face;
                 throw DeadlyImportError("OBJ: Invalid face index.");
             }
         }
         m_DataIt += iStep;
     }
 
     if (face->m_vertices.empty()) {
         ASSIMP_LOG_ERROR("Obj: Ignoring empty face");
         // skip line and clean up
         m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
         delete face;
         return;
     }
 
     // Set active material, if one set
     if (nullptr != m_pModel->mCurrentMaterial) {
         face->m_pMaterial = m_pModel->mCurrentMaterial;
     } else {
         face->m_pMaterial = m_pModel->mDefaultMaterial;
     }
 
     // Create a default object, if nothing is there
     if (nullptr == m_pModel->mCurrentObject) {
         createObject(DefaultObjName);
     }
 
     // Assign face to mesh
     if (nullptr == m_pModel->mCurrentMesh) {
         createMesh(DefaultObjName);
     }
 
     // Store the face
     m_pModel->mCurrentMesh->m_Faces.emplace_back(face);
     m_pModel->mCurrentMesh->m_uiNumIndices += static_cast<unsigned int>(face->m_vertices.size());
     m_pModel->mCurrentMesh->m_uiUVCoordinates[0] += static_cast<unsigned int>(face->m_texturCoords.size());
     if (!m_pModel->mCurrentMesh->m_hasNormals && hasNormal) {
         m_pModel->mCurrentMesh->m_hasNormals = true;
     }
     // Skip the rest of the line
     m_DataIt = skipLine<DataArrayIt>(m_DataIt, m_DataItEnd, m_uiLine);
 }
diff --git a/code/Common/FileSystemFilter.h b/code/Common/FileSystemFilter.h
index d28233ae9..c530153d4 100644
--- a/code/Common/FileSystemFilter.h
+++ b/code/Common/FileSystemFilter.h
@@ -218,117 +218,117 @@ public:
 private:
     // -------------------------------------------------------------------
     /** Build a valid path from a given relative or absolute path.
      */
     void BuildPath (std::string& in) const {
         ai_assert( nullptr != mWrapped );
         // if we can already access the file, great.
         if (in.length() < 3 || mWrapped->Exists(in)) {
             return;
         }
 
         // Determine whether this is a relative path (Windows-specific - most assets are packaged on Windows).
         if (in[1] != ':') {
 
             // append base path and try
             const std::string tmp = mBase + in;
             if (mWrapped->Exists(tmp)) {
                 in = tmp;
                 return;
             }
         }
 
         // Chop of the file name and look in the model directory, if
         // this fails try all sub paths of the given path, i.e.
         // if the given path is foo/bar/something.lwo, try
         // <base>/something.lwo
         // <base>/bar/something.lwo
         // <base>/foo/bar/something.lwo
         std::string::size_type pos = in.rfind('/');
         if (std::string::npos == pos) {
             pos = in.rfind('\\');
         }
 
         if (std::string::npos != pos)   {
             std::string tmp;
             std::string::size_type last_dirsep = std::string::npos;
 
             while(true) {
                 tmp = mBase;
                 tmp += mSep;
 
                 std::string::size_type dirsep = in.rfind('/', last_dirsep);
                 if (std::string::npos == dirsep) {
                     dirsep = in.rfind('\\', last_dirsep);
                 }
 
                 if (std::string::npos == dirsep || dirsep == 0) {
                     // we did try this already.
                     break;
                 }
 
                 last_dirsep = dirsep-1;
 
                 tmp += in.substr(dirsep+1, in.length()-pos);
                 if (mWrapped->Exists(tmp)) {
                     in = tmp;
                     return;
                 }
             }
         }
 
         // hopefully the underlying file system has another few tricks to access this file ...
     }
 
     // -------------------------------------------------------------------
     /** Cleanup the given path
      */
     void Cleanup (std::string& in) const {
         if(in.empty()) {
             return;
         }
 
         // Remove a very common issue when we're parsing file names: spaces at the
         // beginning of the path.
         char last = 0;
         std::string::iterator it = in.begin();
         while (IsSpaceOrNewLine( *it ))++it;
         if (it != in.begin()) {
             in.erase(in.begin(),it+1);
         }
 
         const char separator = getOsSeparator();
-        for (it = in.begin(); it != in.end(); ++it) {
+        for (it = in.begin(); it < in.end(); ++it) {
             const size_t remaining = std::distance(in.end(), it);
             // Exclude :// and \\, which remain untouched.
             // https://sourceforge.net/tracker/?func=detail&aid=3031725&group_id=226462&atid=1067632
             if (remaining >= 3u && !strncmp(&*it, "://", 3 )) {
                 it += 3;
                 continue;
             }
             if (it == in.begin() && remaining >= 2 && !strncmp(&*it, "\\\\", 2)) {
                 it += 2;
                 continue;
             }
 
             // Cleanup path delimiters
             if (*it == '/' || (*it) == '\\') {
                 *it = separator;
 
                 // And we're removing double delimiters, frequent issue with
                 // incorrectly composited paths ...
                 if (last == *it) {
                     it = in.erase(it);
                     --it;
                 }
             } else if (*it == '%' && in.end() - it > 2) {
                 // Hex sequence in URIs
                 if( IsHex((&*it)[0]) && IsHex((&*it)[1]) ) {
                     *it = HexOctetToDecimal(&*it);
                     it = in.erase(it+1,it+2);
                     --it;
                 }
             }
 
             last = *it;
         }
     }
diff --git a/code/Material/MaterialSystem.cpp b/code/Material/MaterialSystem.cpp
index b2f738959..cc8ca2f88 100644
--- a/code/Material/MaterialSystem.cpp
+++ b/code/Material/MaterialSystem.cpp
@@ -37,20 +37,21 @@ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 ----------------------------------------------------------------------
 */
 
 /** @file  MaterialSystem.cpp
  *  @brief Implementation of the material system of the library
  */
 
 #include "MaterialSystem.h"
 #include <assimp/Hash.h>
 #include <assimp/ParsingUtils.h>
 #include <assimp/fast_atof.h>
 #include <assimp/material.h>
 #include <assimp/types.h>
 #include <assimp/DefaultLogger.hpp>
+#include <memory>
 
 using namespace Assimp;
 
@@ -447,75 +448,74 @@ aiReturn aiMaterial::RemoveProperty(const char *pKey, unsigned int type, unsigne
 // ------------------------------------------------------------------------------------------------
 aiReturn aiMaterial::AddBinaryProperty(const void *pInput,
         unsigned int pSizeInBytes,
         const char *pKey,
         unsigned int type,
         unsigned int index,
         aiPropertyTypeInfo pType) {
     ai_assert(pInput != nullptr);
     ai_assert(pKey != nullptr);
     ai_assert(0 != pSizeInBytes);
 
     if (0 == pSizeInBytes) {
         return AI_FAILURE;
     }
 
     // first search the list whether there is already an entry with this key
     unsigned int iOutIndex(UINT_MAX);
     for (unsigned int i = 0; i < mNumProperties; ++i) {
         aiMaterialProperty *prop(mProperties[i]);
 
         if (prop /* just for safety */ && !strcmp(prop->mKey.data, pKey) &&
                 prop->mSemantic == type && prop->mIndex == index) {
 
             delete mProperties[i];
             iOutIndex = i;
         }
     }
 
     // Allocate a new material property
-    aiMaterialProperty *pcNew = new aiMaterialProperty();
+    std::unique_ptr<aiMaterialProperty> pcNew(new aiMaterialProperty());
 
     // .. and fill it
     pcNew->mType = pType;
     pcNew->mSemantic = type;
     pcNew->mIndex = index;
 
     pcNew->mDataLength = pSizeInBytes;
     pcNew->mData = new char[pSizeInBytes];
     memcpy(pcNew->mData, pInput, pSizeInBytes);
 
     pcNew->mKey.length = static_cast<ai_uint32>(::strlen(pKey));
     ai_assert(MAXLEN > pcNew->mKey.length);
     strcpy(pcNew->mKey.data, pKey);
 
     if (UINT_MAX != iOutIndex) {
-        mProperties[iOutIndex] = pcNew;
+        mProperties[iOutIndex] = pcNew.release();
         return AI_SUCCESS;
     }
 
     // resize the array ... double the storage allocated
     if (mNumProperties == mNumAllocated) {
         const unsigned int iOld = mNumAllocated;
         mNumAllocated *= 2;
 
         aiMaterialProperty **ppTemp;
         try {
             ppTemp = new aiMaterialProperty *[mNumAllocated];
         } catch (std::bad_alloc &) {
-            delete pcNew;
             return AI_OUTOFMEMORY;
         }
 
         // just copy all items over; then replace the old array
         memcpy(ppTemp, mProperties, iOld * sizeof(void *));
 
         delete[] mProperties;
         mProperties = ppTemp;
     }
     // push back ...
-    mProperties[mNumProperties++] = pcNew;
+    mProperties[mNumProperties++] = pcNew.release();
 
     return AI_SUCCESS;
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/PostProcessing/FindInvalidDataProcess.cpp b/code/PostProcessing/FindInvalidDataProcess.cpp
index bb8e365a1..aa91139bc 100644
--- a/code/PostProcessing/FindInvalidDataProcess.cpp
+++ b/code/PostProcessing/FindInvalidDataProcess.cpp
@@ -77,80 +77,89 @@ void FindInvalidDataProcess::SetupProperties(const Importer *pImp) {
 // ------------------------------------------------------------------------------------------------
 // Update mesh references in the node graph
 void UpdateMeshReferences(aiNode *node, const std::vector<unsigned int> &meshMapping) {
     if (node->mNumMeshes) {
         unsigned int out = 0;
         for (unsigned int a = 0; a < node->mNumMeshes; ++a) {
 
             unsigned int ref = node->mMeshes[a];
+            if (ref >= meshMapping.size())
+                throw DeadlyImportError("Invalid mesh ref");
+
             if (UINT_MAX != (ref = meshMapping[ref])) {
                 node->mMeshes[out++] = ref;
             }
         }
         // just let the members that are unused, that's much cheaper
         // than a full array realloc'n'copy party ...
         node->mNumMeshes = out;
         if (0 == out) {
             delete[] node->mMeshes;
             node->mMeshes = nullptr;
         }
     }
     // recursively update all children
     for (unsigned int i = 0; i < node->mNumChildren; ++i) {
         UpdateMeshReferences(node->mChildren[i], meshMapping);
     }
 }
 
 // ------------------------------------------------------------------------------------------------
 // Executes the post processing step on the given imported data.
 void FindInvalidDataProcess::Execute(aiScene *pScene) {
     ASSIMP_LOG_DEBUG("FindInvalidDataProcess begin");
 
     bool out = false;
     std::vector<unsigned int> meshMapping(pScene->mNumMeshes);
     unsigned int real = 0;
 
     // Process meshes
     for (unsigned int a = 0; a < pScene->mNumMeshes; a++) {
         int result = ProcessMesh(pScene->mMeshes[a]);
         if (0 == result) {
             out = true;
         }
         if (2 == result) {
             // remove this mesh
             delete pScene->mMeshes[a];
             pScene->mMeshes[a] = nullptr;
 
             meshMapping[a] = UINT_MAX;
             out = true;
             continue;
         }
 
         pScene->mMeshes[real] = pScene->mMeshes[a];
         meshMapping[a] = real++;
     }
 
     // Process animations
     for (unsigned int animIdx = 0; animIdx < pScene->mNumAnimations; ++animIdx) {
         ProcessAnimation(pScene->mAnimations[animIdx]);
     }
 
     if (out) {
         if (real != pScene->mNumMeshes) {
             if (!real) {
                 throw DeadlyImportError("No meshes remaining");
             }
 
             // we need to remove some meshes.
             // therefore we'll also need to remove all references
             // to them from the scenegraph
-            UpdateMeshReferences(pScene->mRootNode, meshMapping);
+            try {
+                UpdateMeshReferences(pScene->mRootNode, meshMapping);
+            } catch (const std::exception&) {
+                // fix the real number of meshes otherwise we'll get double free in the scene destructor
+                pScene->mNumMeshes = real;
+                throw;
+            }
             pScene->mNumMeshes = real;
         }
 
         ASSIMP_LOG_INFO("FindInvalidDataProcess finished. Found issues ...");
     } else {
         ASSIMP_LOG_DEBUG("FindInvalidDataProcess finished. Everything seems to be OK.");
     }
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/contrib/poly2tri_patch.txt b/contrib/poly2tri_patch.txt
deleted file mode 100644
index e9cca4cec..000000000
--- a/contrib/poly2tri_patch.txt
+++ /dev/null
@@ -1,75 +0,0 @@
-diff -r 5de9623d6a50 poly2tri/common/shapes.h
---- a/poly2tri/common/shapes.h	Mon Aug 08 22:26:41 2011 -0400
-+++ b/poly2tri/common/shapes.h	Tue Jan 17 02:36:52 2012 +0100
-@@ -35,6 +35,7 @@
- 
- #include <vector>
- #include <cstddef>
-+#include <stdexcept>
- #include <assert.h>
- #include <cmath>
- 
-@@ -136,7 +137,9 @@
-         p = &p2;
-       } else if (p1.x == p2.x) {
-         // Repeat points
--        assert(false);
-+		  // ASSIMP_CHANGE (aramis_acg)
-+		  throw std::runtime_error("repeat points");
-+        //assert(false);
-       }
-     }
- 
-diff -r 5de9623d6a50 poly2tri/sweep/sweep.cc
---- a/poly2tri/sweep/sweep.cc	Mon Aug 08 22:26:41 2011 -0400
-+++ b/poly2tri/sweep/sweep.cc	Tue Jan 17 02:36:52 2012 +0100
-@@ -113,6 +113,8 @@
-   Point* p1 = triangle->PointCCW(point);
-   Orientation o1 = Orient2d(eq, *p1, ep);
-   if (o1 == COLLINEAR) {
-+	  // ASSIMP_CHANGE (aramis_acg)
-+	  throw std::runtime_error("EdgeEvent - collinear points not supported");
-     if( triangle->Contains(&eq, p1)) {
-       triangle->MarkConstrainedEdge(&eq, p1 );
-       // We are modifying the constraint maybe it would be better to 
-@@ -121,8 +123,8 @@
-       triangle = &triangle->NeighborAcross(point);
-       EdgeEvent( tcx, ep, *p1, triangle, *p1 );
-     } else {
-+	  // ASSIMP_CHANGE (aramis_acg)
-       std::runtime_error("EdgeEvent - collinear points not supported");
--      assert(0);
-     }
-     return;
-   }
-@@ -130,6 +132,9 @@
-   Point* p2 = triangle->PointCW(point);
-   Orientation o2 = Orient2d(eq, *p2, ep);
-   if (o2 == COLLINEAR) {
-+	  // ASSIMP_CHANGE (aramis_acg)
-+	  throw std::runtime_error("EdgeEvent - collinear points not supported");
-+
-     if( triangle->Contains(&eq, p2)) {
-       triangle->MarkConstrainedEdge(&eq, p2 );
-       // We are modifying the constraint maybe it would be better to 
-@@ -138,8 +143,8 @@
-       triangle = &triangle->NeighborAcross(point);
-       EdgeEvent( tcx, ep, *p2, triangle, *p2 );
-     } else {
--      std::runtime_error("EdgeEvent - collinear points not supported");
--      assert(0);
-+      // ASSIMP_CHANGE (aramis_acg)
-+      throw std::runtime_error("EdgeEvent - collinear points not supported");
-     }
-     return;
-   }
-@@ -712,7 +717,8 @@
-     return *ot.PointCW(op);
-   } else{
-     //throw new RuntimeException("[Unsupported] Opposing point on constrained edge");
--    assert(0);
-+	  // ASSIMP_CHANGE (aramis_acg)
-+	  throw std::runtime_error("[Unsupported] Opposing point on constrained edge");
-   }
- }
- 
diff --git a/contrib/zlib/CMakeLists.txt b/contrib/zlib/CMakeLists.txt
index 5bc2d6065..af8aa4f65 100644
--- a/contrib/zlib/CMakeLists.txt
+++ b/contrib/zlib/CMakeLists.txt
@@ -74,17 +74,9 @@ check_include_file(unistd.h Z_HAVE_UNISTD_H)
 if(MSVC)
     SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /wd4131 /wd4127 /wd4244")
     set(CMAKE_DEBUG_POSTFIX "d")
     add_definitions(-D_CRT_SECURE_NO_DEPRECATE)
     add_definitions(-D_CRT_NONSTDC_NO_DEPRECATE)
-    if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" ) # clang-cl
-        SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-deprecated-non-prototype")
-    endif()
-
     include_directories(${CMAKE_CURRENT_SOURCE_DIR})
-else()
-    if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" ) # clang-cl
-        SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-deprecated-non-prototype")
-    endif()
 endif()
 
 if(NOT CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_CURRENT_BINARY_DIR)
