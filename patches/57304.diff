commit 04d1bedd8c3fc5d9e41d11e2d0da08a966b732d3
Author: Nick Wellnhofer <wellnhofer@aevum.de>
Date:   Tue Mar 21 13:08:44 2023 +0100

    parser: Rework shrinking of input buffers
    
    Don't try to grow the input buffer in xmlParserShrink. This makes sure
    that no memory allocations are made and the function always succeeds.
    
    Remove unnecessary invocations of SHRINK. Invoke SHRINK at the end of
    DTD parsing loops.
    
    Shrink before growing.

diff --git a/HTMLparser.c b/HTMLparser.c
index 81bd11f9..3bebda6e 100644
--- a/HTMLparser.c
+++ b/HTMLparser.c
@@ -3098,88 +3098,87 @@ static void
 htmlParseScript(htmlParserCtxtPtr ctxt) {
     xmlChar buf[HTML_PARSER_BIG_BUFFER_SIZE + 5];
     int nbchar = 0;
     int cur,l;
 
-    SHRINK;
     cur = CUR_CHAR(l);
     while (cur != 0) {
 	if ((cur == '<') && (NXT(1) == '/')) {
             /*
              * One should break here, the specification is clear:
              * Authors should therefore escape "</" within the content.
              * Escape mechanisms are specific to each scripting or
              * style sheet language.
              *
              * In recovery mode, only break if end tag match the
              * current tag, effectively ignoring all tags inside the
              * script/style block and treating the entire block as
              * CDATA.
              */
             if (ctxt->recovery) {
                 if (xmlStrncasecmp(ctxt->name, ctxt->input->cur+2,
 				   xmlStrlen(ctxt->name)) == 0)
                 {
                     break; /* while */
                 } else {
 		    htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,
 				 "Element %s embeds close tag\n",
 		                 ctxt->name, NULL);
 		}
             } else {
                 if (((NXT(2) >= 'A') && (NXT(2) <= 'Z')) ||
                     ((NXT(2) >= 'a') && (NXT(2) <= 'z')))
                 {
                     break; /* while */
                 }
             }
 	}
         if (IS_CHAR(cur)) {
 	    COPY_BUF(l,buf,nbchar,cur);
         } else {
             htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                             "Invalid char in CDATA 0x%X\n", cur);
         }
 	NEXTL(l);
 	if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {
             buf[nbchar] = 0;
 	    if (ctxt->sax->cdataBlock!= NULL) {
 		/*
 		 * Insert as CDATA, which is the same as HTML_PRESERVE_NODE
 		 */
 		ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);
 	    } else if (ctxt->sax->characters != NULL) {
 		ctxt->sax->characters(ctxt->userData, buf, nbchar);
 	    }
 	    nbchar = 0;
             SHRINK;
 	}
 	cur = CUR_CHAR(l);
     }
 
     if (ctxt->instate == XML_PARSER_EOF)
         return;
 
     if ((nbchar != 0) && (ctxt->sax != NULL) && (!ctxt->disableSAX)) {
         buf[nbchar] = 0;
 	if (ctxt->sax->cdataBlock!= NULL) {
 	    /*
 	     * Insert as CDATA, which is the same as HTML_PRESERVE_NODE
 	     */
 	    ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);
 	} else if (ctxt->sax->characters != NULL) {
 	    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 	}
     }
 }
 
 
 /**
  * htmlParseCharDataInternal:
  * @ctxt:  an HTML parser context
  * @readahead: optional read ahead character in ascii range
  *
  * parse a CharData section.
  * if we are within a CDATA section ']]>' marks an end of section.
  *
  * [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)
  */
@@ -3343,119 +3342,118 @@ static void
 htmlParsePI(htmlParserCtxtPtr ctxt) {
     xmlChar *buf = NULL;
     int len = 0;
     int size = HTML_PARSER_BUFFER_SIZE;
     int cur, l;
     int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
                     XML_MAX_HUGE_LENGTH :
                     XML_MAX_TEXT_LENGTH;
     const xmlChar *target;
     xmlParserInputState state;
 
     if ((RAW == '<') && (NXT(1) == '?')) {
 	state = ctxt->instate;
         ctxt->instate = XML_PARSER_PI;
 	/*
 	 * this is a Processing Instruction.
 	 */
 	SKIP(2);
-	SHRINK;
 
 	/*
 	 * Parse the target name and check for special support like
 	 * namespace.
 	 */
         target = htmlParseName(ctxt);
 	if (target != NULL) {
 	    if (RAW == '>') {
 		SKIP(1);
 
 		/*
 		 * SAX: PI detected.
 		 */
 		if ((ctxt->sax) && (!ctxt->disableSAX) &&
 		    (ctxt->sax->processingInstruction != NULL))
 		    ctxt->sax->processingInstruction(ctxt->userData,
 		                                     target, NULL);
 		ctxt->instate = state;
 		return;
 	    }
 	    buf = (xmlChar *) xmlMallocAtomic(size);
 	    if (buf == NULL) {
 		htmlErrMemory(ctxt, NULL);
 		ctxt->instate = state;
 		return;
 	    }
 	    cur = CUR;
 	    if (!IS_BLANK(cur)) {
 		htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,
 			  "ParsePI: PI %s space expected\n", target, NULL);
 	    }
             SKIP_BLANKS;
 	    cur = CUR_CHAR(l);
 	    while ((cur != 0) && (cur != '>')) {
 		if (len + 5 >= size) {
 		    xmlChar *tmp;
 
 		    size *= 2;
 		    tmp = (xmlChar *) xmlRealloc(buf, size);
 		    if (tmp == NULL) {
 			htmlErrMemory(ctxt, NULL);
 			xmlFree(buf);
 			ctxt->instate = state;
 			return;
 		    }
 		    buf = tmp;
 		}
                 if (IS_CHAR(cur)) {
 		    COPY_BUF(l,buf,len,cur);
                 } else {
                     htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                                     "Invalid char in processing instruction "
                                     "0x%X\n", cur);
                 }
                 if (len > maxLength) {
                     htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,
                                  "PI %s too long", target, NULL);
                     xmlFree(buf);
                     ctxt->instate = state;
                     return;
                 }
 		NEXTL(l);
 		cur = CUR_CHAR(l);
 	    }
 	    buf[len] = 0;
             if (ctxt->instate == XML_PARSER_EOF) {
                 xmlFree(buf);
                 return;
             }
 	    if (cur != '>') {
 		htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,
 		      "ParsePI: PI %s never end ...\n", target, NULL);
 	    } else {
 		SKIP(1);
 
 		/*
 		 * SAX: PI detected.
 		 */
 		if ((ctxt->sax) && (!ctxt->disableSAX) &&
 		    (ctxt->sax->processingInstruction != NULL))
 		    ctxt->sax->processingInstruction(ctxt->userData,
 		                                     target, buf);
 	    }
 	    xmlFree(buf);
 	} else {
 	    htmlParseErr(ctxt, XML_ERR_PI_NOT_STARTED,
                          "PI is not started correctly", NULL, NULL);
 	}
 	ctxt->instate = state;
     }
 }
 
 /**
  * htmlParseComment:
  * @ctxt:  an HTML parser context
  *
  * Parse an XML (SGML) comment <!-- .... -->
  *
  * [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
  */
@@ -3463,97 +3461,96 @@ static void
 htmlParseComment(htmlParserCtxtPtr ctxt) {
     xmlChar *buf = NULL;
     int len;
     int size = HTML_PARSER_BUFFER_SIZE;
     int q, ql;
     int r, rl;
     int cur, l;
     int next, nl;
     int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
                     XML_MAX_HUGE_LENGTH :
                     XML_MAX_TEXT_LENGTH;
     xmlParserInputState state;
 
     /*
      * Check that there is a comment right here.
      */
     if ((RAW != '<') || (NXT(1) != '!') ||
         (NXT(2) != '-') || (NXT(3) != '-')) return;
 
     state = ctxt->instate;
     ctxt->instate = XML_PARSER_COMMENT;
-    SHRINK;
     SKIP(4);
     buf = (xmlChar *) xmlMallocAtomic(size);
     if (buf == NULL) {
         htmlErrMemory(ctxt, "buffer allocation failed\n");
 	ctxt->instate = state;
 	return;
     }
     len = 0;
     buf[len] = 0;
     q = CUR_CHAR(ql);
     if (q == 0)
         goto unfinished;
     if (q == '>') {
         htmlParseErr(ctxt, XML_ERR_COMMENT_ABRUPTLY_ENDED, "Comment abruptly ended", NULL, NULL);
         cur = '>';
         goto finished;
     }
     NEXTL(ql);
     r = CUR_CHAR(rl);
     if (r == 0)
         goto unfinished;
     if (q == '-' && r == '>') {
         htmlParseErr(ctxt, XML_ERR_COMMENT_ABRUPTLY_ENDED, "Comment abruptly ended", NULL, NULL);
         cur = '>';
         goto finished;
     }
     NEXTL(rl);
     cur = CUR_CHAR(l);
     while ((cur != 0) &&
            ((cur != '>') ||
 	    (r != '-') || (q != '-'))) {
 	NEXTL(l);
 	next = CUR_CHAR(nl);
 
 	if ((q == '-') && (r == '-') && (cur == '!') && (next == '>')) {
 	  htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
 		       "Comment incorrectly closed by '--!>'", NULL, NULL);
 	  cur = '>';
 	  break;
 	}
 
 	if (len + 5 >= size) {
 	    xmlChar *tmp;
 
 	    size *= 2;
 	    tmp = (xmlChar *) xmlRealloc(buf, size);
 	    if (tmp == NULL) {
 	        xmlFree(buf);
 	        htmlErrMemory(ctxt, "growing buffer failed\n");
 		ctxt->instate = state;
 		return;
 	    }
 	    buf = tmp;
 	}
         if (IS_CHAR(q)) {
 	    COPY_BUF(ql,buf,len,q);
         } else {
             htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,
                             "Invalid char in comment 0x%X\n", q);
         }
         if (len > maxLength) {
             htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
                          "comment too long", NULL, NULL);
             xmlFree(buf);
             ctxt->instate = state;
             return;
         }
 
 	q = r;
 	ql = rl;
 	r = cur;
 	rl = l;
 	cur = next;
 	l = nl;
     }
@@ -4343,156 +4340,156 @@ static void
 htmlParseContent(htmlParserCtxtPtr ctxt) {
     xmlChar *currentNode;
     int depth;
     const xmlChar *name;
 
     currentNode = xmlStrdup(ctxt->name);
     depth = ctxt->nameNr;
     while (1) {
         GROW;
 
         if (ctxt->instate == XML_PARSER_EOF)
             break;
 
 	/*
 	 * Our tag or one of it's parent or children is ending.
 	 */
         if ((CUR == '<') && (NXT(1) == '/')) {
 	    if (htmlParseEndTag(ctxt) &&
 		((currentNode != NULL) || (ctxt->nameNr == 0))) {
 		if (currentNode != NULL)
 		    xmlFree(currentNode);
 		return;
 	    }
 	    continue; /* while */
         }
 
 	else if ((CUR == '<') &&
 	         ((IS_ASCII_LETTER(NXT(1))) ||
 		  (NXT(1) == '_') || (NXT(1) == ':'))) {
 	    name = htmlParseHTMLName_nonInvasive(ctxt);
 	    if (name == NULL) {
 	        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
 			 "htmlParseStartTag: invalid element name\n",
 			 NULL, NULL);
 	        /* Dump the bogus tag like browsers do */
                 while ((CUR != 0) && (CUR != '>'))
 	            NEXT;
 
 	        if (currentNode != NULL)
 	            xmlFree(currentNode);
 	        return;
 	    }
 
 	    if (ctxt->name != NULL) {
 	        if (htmlCheckAutoClose(name, ctxt->name) == 1) {
 	            htmlAutoClose(ctxt, name);
 	            continue;
 	        }
 	    }
 	}
 
 	/*
 	 * Has this node been popped out during parsing of
 	 * the next element
 	 */
         if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&
 	    (!xmlStrEqual(currentNode, ctxt->name)))
 	     {
 	    if (currentNode != NULL) xmlFree(currentNode);
 	    return;
 	}
 
 	if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST"script")) ||
 	    (xmlStrEqual(currentNode, BAD_CAST"style")))) {
 	    /*
 	     * Handle SCRIPT/STYLE separately
 	     */
 	    htmlParseScript(ctxt);
 	}
 
         else if ((CUR == '<') && (NXT(1) == '!')) {
             /*
              * Sometimes DOCTYPE arrives in the middle of the document
              */
             if ((UPP(2) == 'D') && (UPP(3) == 'O') &&
                 (UPP(4) == 'C') && (UPP(5) == 'T') &&
                 (UPP(6) == 'Y') && (UPP(7) == 'P') &&
                 (UPP(8) == 'E')) {
                 htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
                              "Misplaced DOCTYPE declaration\n",
                              BAD_CAST "DOCTYPE" , NULL);
                 htmlParseDocTypeDecl(ctxt);
             }
             /*
              * First case :  a comment
              */
             else if ((NXT(2) == '-') && (NXT(3) == '-')) {
                 htmlParseComment(ctxt);
             }
             else {
                 htmlSkipBogusComment(ctxt);
             }
         }
 
         /*
          * Second case : a Processing Instruction.
          */
         else if ((CUR == '<') && (NXT(1) == '?')) {
             htmlParsePI(ctxt);
         }
 
         /*
          * Third case :  a sub-element.
          */
         else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {
             htmlParseElement(ctxt);
         }
         else if (CUR == '<') {
             if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
                 (ctxt->sax->characters != NULL))
                 ctxt->sax->characters(ctxt->userData, BAD_CAST "<", 1);
             NEXT;
         }
 
         /*
          * Fourth case : a reference. If if has not been resolved,
          *    parsing returns it's Name, create the node
          */
         else if (CUR == '&') {
             htmlParseReference(ctxt);
         }
 
         /*
          * Fifth case : end of the resource
          */
         else if (CUR == 0) {
             htmlAutoCloseOnEnd(ctxt);
             break;
         }
 
         /*
          * Last case, text. Note that References are handled directly.
          */
         else {
             htmlParseCharData(ctxt);
         }
 
-        GROW;
         SHRINK;
+        GROW;
     }
     if (currentNode != NULL) xmlFree(currentNode);
 }
 
 /**
  * htmlParseElement:
  * @ctxt:  an HTML parser context
  *
  * DEPRECATED: Internal function, don't use.
  *
  * parse an HTML element, this is highly recursive
  * this is kept for compatibility with previous code versions
  *
  * [39] element ::= EmptyElemTag | STag content ETag
  *
  * [41] Attribute ::= Name Eq AttValue
  */
@@ -4744,192 +4741,192 @@ static void
 htmlParseContentInternal(htmlParserCtxtPtr ctxt) {
     xmlChar *currentNode;
     int depth;
     const xmlChar *name;
 
     depth = ctxt->nameNr;
     if (depth <= 0) {
         currentNode = NULL;
     } else {
         currentNode = xmlStrdup(ctxt->name);
         if (currentNode == NULL) {
             htmlErrMemory(ctxt, NULL);
             return;
         }
     }
     while (1) {
         GROW;
 
         if (ctxt->instate == XML_PARSER_EOF)
             break;
 
 	/*
 	 * Our tag or one of it's parent or children is ending.
 	 */
         if ((CUR == '<') && (NXT(1) == '/')) {
 	    if (htmlParseEndTag(ctxt) &&
 		((currentNode != NULL) || (ctxt->nameNr == 0))) {
 		if (currentNode != NULL)
 		    xmlFree(currentNode);
 
 	        depth = ctxt->nameNr;
                 if (depth <= 0) {
                     currentNode = NULL;
                 } else {
                     currentNode = xmlStrdup(ctxt->name);
                     if (currentNode == NULL) {
                         htmlErrMemory(ctxt, NULL);
                         break;
                     }
                 }
 	    }
 	    continue; /* while */
         }
 
 	else if ((CUR == '<') &&
 	         ((IS_ASCII_LETTER(NXT(1))) ||
 		  (NXT(1) == '_') || (NXT(1) == ':'))) {
 	    name = htmlParseHTMLName_nonInvasive(ctxt);
 	    if (name == NULL) {
 	        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,
 			 "htmlParseStartTag: invalid element name\n",
 			 NULL, NULL);
 	        /* Dump the bogus tag like browsers do */
 	        while ((CUR == 0) && (CUR != '>'))
 	            NEXT;
 
 	        htmlParserFinishElementParsing(ctxt);
 	        if (currentNode != NULL)
 	            xmlFree(currentNode);
 
 	        currentNode = xmlStrdup(ctxt->name);
                 if (currentNode == NULL) {
                     htmlErrMemory(ctxt, NULL);
                     break;
                 }
 	        depth = ctxt->nameNr;
 	        continue;
 	    }
 
 	    if (ctxt->name != NULL) {
 	        if (htmlCheckAutoClose(name, ctxt->name) == 1) {
 	            htmlAutoClose(ctxt, name);
 	            continue;
 	        }
 	    }
 	}
 
 	/*
 	 * Has this node been popped out during parsing of
 	 * the next element
 	 */
         if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&
 	    (!xmlStrEqual(currentNode, ctxt->name)))
 	     {
 	    htmlParserFinishElementParsing(ctxt);
 	    if (currentNode != NULL) xmlFree(currentNode);
 
 	    currentNode = xmlStrdup(ctxt->name);
             if (currentNode == NULL) {
                 htmlErrMemory(ctxt, NULL);
                 break;
             }
 	    depth = ctxt->nameNr;
 	    continue;
 	}
 
 	if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST"script")) ||
 	    (xmlStrEqual(currentNode, BAD_CAST"style")))) {
 	    /*
 	     * Handle SCRIPT/STYLE separately
 	     */
 	    htmlParseScript(ctxt);
 	}
 
         else if ((CUR == '<') && (NXT(1) == '!')) {
             /*
              * Sometimes DOCTYPE arrives in the middle of the document
              */
             if ((UPP(2) == 'D') && (UPP(3) == 'O') &&
                 (UPP(4) == 'C') && (UPP(5) == 'T') &&
                 (UPP(6) == 'Y') && (UPP(7) == 'P') &&
                 (UPP(8) == 'E')) {
                 htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,
                              "Misplaced DOCTYPE declaration\n",
                              BAD_CAST "DOCTYPE" , NULL);
                 htmlParseDocTypeDecl(ctxt);
             }
             /*
              * First case :  a comment
              */
             else if ((NXT(2) == '-') && (NXT(3) == '-')) {
                 htmlParseComment(ctxt);
             }
             else {
                 htmlSkipBogusComment(ctxt);
             }
         }
 
         /*
          * Second case : a Processing Instruction.
          */
         else if ((CUR == '<') && (NXT(1) == '?')) {
             htmlParsePI(ctxt);
         }
 
         /*
          * Third case :  a sub-element.
          */
         else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {
             htmlParseElementInternal(ctxt);
             if (currentNode != NULL) xmlFree(currentNode);
 
             currentNode = xmlStrdup(ctxt->name);
             if (currentNode == NULL) {
                 htmlErrMemory(ctxt, NULL);
                 break;
             }
             depth = ctxt->nameNr;
         }
         else if (CUR == '<') {
             if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
                 (ctxt->sax->characters != NULL))
                 ctxt->sax->characters(ctxt->userData, BAD_CAST "<", 1);
             NEXT;
         }
 
         /*
          * Fourth case : a reference. If if has not been resolved,
          *    parsing returns it's Name, create the node
          */
         else if (CUR == '&') {
             htmlParseReference(ctxt);
         }
 
         /*
          * Fifth case : end of the resource
          */
         else if (CUR == 0) {
             htmlAutoCloseOnEnd(ctxt);
             break;
         }
 
         /*
          * Last case, text. Note that References are handled directly.
          */
         else {
             htmlParseCharData(ctxt);
         }
 
-        GROW;
         SHRINK;
+        GROW;
     }
     if (currentNode != NULL) xmlFree(currentNode);
 }
 
 /**
  * htmlParseContent:
  * @ctxt:  an HTML parser context
  *
  * Parse a content: comment, sub-element, reference or text.
  * This is the entry point when called from parser.c
  */
diff --git a/include/private/parser.h b/include/private/parser.h
index 18036db5..820bb587 100644
--- a/include/private/parser.h
+++ b/include/private/parser.h
@@ -27,7 +27,7 @@ XML_HIDDEN void
 xmlHaltParser(xmlParserCtxtPtr ctxt);
 XML_HIDDEN int
 xmlParserGrow(xmlParserCtxtPtr ctxt);
-XML_HIDDEN int
+XML_HIDDEN void
 xmlParserShrink(xmlParserCtxtPtr ctxt);
 
 #endif /* XML_PARSER_H_PRIVATE__ */
diff --git a/parser.c b/parser.c
index 8e548cda..bf4d08bd 100644
--- a/parser.c
+++ b/parser.c
@@ -4175,80 +4175,79 @@ xmlChar *
 xmlParseSystemLiteral(xmlParserCtxtPtr ctxt) {
     xmlChar *buf = NULL;
     int len = 0;
     int size = XML_PARSER_BUFFER_SIZE;
     int cur, l;
     int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
                     XML_MAX_TEXT_LENGTH :
                     XML_MAX_NAME_LENGTH;
     xmlChar stop;
     int state = ctxt->instate;
 
-    SHRINK;
     if (RAW == '"') {
         NEXT;
 	stop = '"';
     } else if (RAW == '\'') {
         NEXT;
 	stop = '\'';
     } else {
 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 	return(NULL);
     }
 
     buf = (xmlChar *) xmlMallocAtomic(size);
     if (buf == NULL) {
         xmlErrMemory(ctxt, NULL);
 	return(NULL);
     }
     ctxt->instate = XML_PARSER_SYSTEM_LITERAL;
     cur = CUR_CHAR(l);
     while ((IS_CHAR(cur)) && (cur != stop)) { /* checked */
 	if (len + 5 >= size) {
 	    xmlChar *tmp;
 
 	    size *= 2;
 	    tmp = (xmlChar *) xmlRealloc(buf, size);
 	    if (tmp == NULL) {
 	        xmlFree(buf);
 		xmlErrMemory(ctxt, NULL);
 		ctxt->instate = (xmlParserInputState) state;
 		return(NULL);
 	    }
 	    buf = tmp;
 	}
 	COPY_BUF(l,buf,len,cur);
         if (len > maxLength) {
             xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "SystemLiteral");
             xmlFree(buf);
             ctxt->instate = (xmlParserInputState) state;
             return(NULL);
         }
 	NEXTL(l);
 	cur = CUR_CHAR(l);
     }
     buf[len] = 0;
     if (ctxt->instate == XML_PARSER_EOF) {
         xmlFree(buf);
         return(NULL);
     }
     ctxt->instate = (xmlParserInputState) state;
     if (!IS_CHAR(cur)) {
 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
     } else {
 	NEXT;
     }
     return(buf);
 }
 
 /**
  * xmlParsePubidLiteral:
  * @ctxt:  an XML parser context
  *
  * DEPRECATED: Internal function, don't use.
  *
  * parse an XML public literal
  *
  * [12] PubidLiteral ::= '"' PubidChar* '"' | "'" (PubidChar - "'")* "'"
  *
  * Returns the PubidLiteral parsed or NULL.
  */
@@ -4257,64 +4256,63 @@ xmlChar *
 xmlParsePubidLiteral(xmlParserCtxtPtr ctxt) {
     xmlChar *buf = NULL;
     int len = 0;
     int size = XML_PARSER_BUFFER_SIZE;
     int maxLength = (ctxt->options & XML_PARSE_HUGE) ?
                     XML_MAX_TEXT_LENGTH :
                     XML_MAX_NAME_LENGTH;
     xmlChar cur;
     xmlChar stop;
     xmlParserInputState oldstate = ctxt->instate;
 
-    SHRINK;
     if (RAW == '"') {
         NEXT;
 	stop = '"';
     } else if (RAW == '\'') {
         NEXT;
 	stop = '\'';
     } else {
 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);
 	return(NULL);
     }
     buf = (xmlChar *) xmlMallocAtomic(size);
     if (buf == NULL) {
 	xmlErrMemory(ctxt, NULL);
 	return(NULL);
     }
     ctxt->instate = XML_PARSER_PUBLIC_LITERAL;
     cur = CUR;
     while ((IS_PUBIDCHAR_CH(cur)) && (cur != stop)) { /* checked */
 	if (len + 1 >= size) {
 	    xmlChar *tmp;
 
 	    size *= 2;
 	    tmp = (xmlChar *) xmlRealloc(buf, size);
 	    if (tmp == NULL) {
 		xmlErrMemory(ctxt, NULL);
 		xmlFree(buf);
 		return(NULL);
 	    }
 	    buf = tmp;
 	}
 	buf[len++] = cur;
         if (len > maxLength) {
             xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, "Public ID");
             xmlFree(buf);
             return(NULL);
         }
 	NEXT;
 	cur = CUR;
     }
     buf[len] = 0;
     if (ctxt->instate == XML_PARSER_EOF) {
         xmlFree(buf);
         return(NULL);
     }
     if (cur != stop) {
 	xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);
     } else {
 	NEXTL(1);
     }
     ctxt->instate = oldstate;
     return(buf);
 }
@@ -4383,15 +4381,14 @@ void
 xmlParseCharData(xmlParserCtxtPtr ctxt, ATTRIBUTE_UNUSED int cdata) {
     const xmlChar *in;
     int nbchar = 0;
     int line = ctxt->input->line;
     int col = ctxt->input->col;
     int ccol;
 
-    SHRINK;
     GROW;
     /*
      * Accelerated common case where input don't need to be
      * modified before passing it to the handler.
      */
     in = ctxt->input->cur;
     do {
@@ -4531,96 +4528,95 @@ static void
 xmlParseCharDataComplex(xmlParserCtxtPtr ctxt) {
     xmlChar buf[XML_PARSER_BIG_BUFFER_SIZE + 5];
     int nbchar = 0;
     int cur, l;
 
-    SHRINK;
     cur = CUR_CHAR(l);
     while ((cur != '<') && /* checked */
            (cur != '&') &&
 	   (IS_CHAR(cur))) /* test also done in xmlCurrentChar() */ {
 	if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
 	    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);
 	}
 	COPY_BUF(l,buf,nbchar,cur);
 	/* move current position before possible calling of ctxt->sax->characters */
 	NEXTL(l);
 	if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {
 	    buf[nbchar] = 0;
 
 	    /*
 	     * OK the segment is to be consumed as chars.
 	     */
 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
 		if (areBlanks(ctxt, buf, nbchar, 0)) {
 		    if (ctxt->sax->ignorableWhitespace != NULL)
 			ctxt->sax->ignorableWhitespace(ctxt->userData,
 			                               buf, nbchar);
 		} else {
 		    if (ctxt->sax->characters != NULL)
 			ctxt->sax->characters(ctxt->userData, buf, nbchar);
 		    if ((ctxt->sax->characters !=
 		         ctxt->sax->ignorableWhitespace) &&
 			(*ctxt->space == -1))
 			*ctxt->space = -2;
 		}
 	    }
 	    nbchar = 0;
             /* something really bad happened in the SAX callback */
             if (ctxt->instate != XML_PARSER_CONTENT)
                 return;
             SHRINK;
 	}
 	cur = CUR_CHAR(l);
     }
     if (ctxt->instate == XML_PARSER_EOF)
         return;
     if (nbchar != 0) {
         buf[nbchar] = 0;
 	/*
 	 * OK the segment is to be consumed as chars.
 	 */
 	if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {
 	    if (areBlanks(ctxt, buf, nbchar, 0)) {
 		if (ctxt->sax->ignorableWhitespace != NULL)
 		    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);
 	    } else {
 		if (ctxt->sax->characters != NULL)
 		    ctxt->sax->characters(ctxt->userData, buf, nbchar);
 		if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&
 		    (*ctxt->space == -1))
 		    *ctxt->space = -2;
 	    }
 	}
     }
     if ((ctxt->input->cur < ctxt->input->end) && (!IS_CHAR(cur))) {
 	/* Generate the error and skip the offending character */
         xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,
                           "PCDATA invalid Char value %d\n",
 	                  cur ? cur : CUR);
 	NEXT;
     }
 }
 
 /**
  * xmlParseExternalID:
  * @ctxt:  an XML parser context
  * @publicID:  a xmlChar** receiving PubidLiteral
  * @strict: indicate whether we should restrict parsing to only
  *          production [75], see NOTE below
  *
  * DEPRECATED: Internal function, don't use.
  *
  * Parse an External ID or a Public ID
  *
  * NOTE: Productions [75] and [83] interact badly since [75] can generate
  *       'PUBLIC' S PubidLiteral S SystemLiteral
  *
  * [75] ExternalID ::= 'SYSTEM' S SystemLiteral
  *                   | 'PUBLIC' S PubidLiteral S SystemLiteral
  *
  * [83] PublicID ::= 'PUBLIC' S PubidLiteral
  *
  * Returns the function returns SystemLiteral and in the second
  *                case publicID receives PubidLiteral, is strict is off
  *                it is possible to return NULL and have publicID set.
  */
@@ -4629,66 +4625,64 @@ xmlChar *
 xmlParseExternalID(xmlParserCtxtPtr ctxt, xmlChar **publicID, int strict) {
     xmlChar *URI = NULL;
 
-    SHRINK;
-
     *publicID = NULL;
     if (CMP6(CUR_PTR, 'S', 'Y', 'S', 'T', 'E', 'M')) {
         SKIP(6);
 	if (SKIP_BLANKS == 0) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 	                   "Space required after 'SYSTEM'\n");
 	}
 	URI = xmlParseSystemLiteral(ctxt);
 	if (URI == NULL) {
 	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
         }
     } else if (CMP6(CUR_PTR, 'P', 'U', 'B', 'L', 'I', 'C')) {
         SKIP(6);
 	if (SKIP_BLANKS == 0) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 		    "Space required after 'PUBLIC'\n");
 	}
 	*publicID = xmlParsePubidLiteral(ctxt);
 	if (*publicID == NULL) {
 	    xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);
 	}
 	if (strict) {
 	    /*
 	     * We don't handle [83] so "S SystemLiteral" is required.
 	     */
 	    if (SKIP_BLANKS == 0) {
 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 			"Space required after the Public Identifier\n");
 	    }
 	} else {
 	    /*
 	     * We handle [83] so we return immediately, if
 	     * "S SystemLiteral" is not detected. We skip blanks if no
              * system literal was found, but this is harmless since we must
              * be at the end of a NotationDecl.
 	     */
 	    if (SKIP_BLANKS == 0) return(NULL);
 	    if ((CUR != '\'') && (CUR != '"')) return(NULL);
 	}
 	URI = xmlParseSystemLiteral(ctxt);
 	if (URI == NULL) {
 	    xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);
         }
     }
     return(URI);
 }
 
 /**
  * xmlParseCommentComplex:
  * @ctxt:  an XML parser context
  * @buf:  the already parsed part of the buffer
  * @len:  number of bytes in the buffer
  * @size:  allocated size of the buffer
  *
  * Skip an XML (SGML) comment <!-- .... -->
  *  The spec says that "For compatibility, the string "--" (double-hyphen)
  *  must not occur within comments. "
  * This is the slow routine in case the accelerator for ascii didn't work
  *
  * [15] Comment ::= '<!--' ((Char - '-') | ('-' (Char - '-')))* '-->'
  */
@@ -4825,40 +4819,39 @@ void
 xmlParseComment(xmlParserCtxtPtr ctxt) {
     xmlChar *buf = NULL;
     size_t size = XML_PARSER_BUFFER_SIZE;
     size_t len = 0;
     size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
                        XML_MAX_HUGE_LENGTH :
                        XML_MAX_TEXT_LENGTH;
     xmlParserInputState state;
     const xmlChar *in;
     size_t nbchar = 0;
     int ccol;
     int inputid;
 
     /*
      * Check that there is a comment right here.
      */
     if ((RAW != '<') || (NXT(1) != '!'))
         return;
     SKIP(2);
     if ((RAW != '-') || (NXT(1) != '-'))
         return;
     state = ctxt->instate;
     ctxt->instate = XML_PARSER_COMMENT;
     inputid = ctxt->input->id;
     SKIP(2);
-    SHRINK;
     GROW;
 
     /*
      * Accelerated common case where input don't need to be
      * modified before passing it to the handler.
      */
     in = ctxt->input->cur;
     do {
 	if (*in == 0xA) {
 	    do {
 		ctxt->input->line++; ctxt->input->col = 1;
 		in++;
 	    } while (*in == 0xA);
 	}
@@ -5117,145 +5110,144 @@ void
 xmlParsePI(xmlParserCtxtPtr ctxt) {
     xmlChar *buf = NULL;
     size_t len = 0;
     size_t size = XML_PARSER_BUFFER_SIZE;
     size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?
                        XML_MAX_HUGE_LENGTH :
                        XML_MAX_TEXT_LENGTH;
     int cur, l;
     const xmlChar *target;
     xmlParserInputState state;
 
     if ((RAW == '<') && (NXT(1) == '?')) {
 	int inputid = ctxt->input->id;
 	state = ctxt->instate;
         ctxt->instate = XML_PARSER_PI;
 	/*
 	 * this is a Processing Instruction.
 	 */
 	SKIP(2);
-	SHRINK;
 
 	/*
 	 * Parse the target name and check for special support like
 	 * namespace.
 	 */
         target = xmlParsePITarget(ctxt);
 	if (target != NULL) {
 	    if ((RAW == '?') && (NXT(1) == '>')) {
 		if (inputid != ctxt->input->id) {
 		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 	                           "PI declaration doesn't start and stop in"
                                    " the same entity\n");
 		}
 		SKIP(2);
 
 		/*
 		 * SAX: PI detected.
 		 */
 		if ((ctxt->sax) && (!ctxt->disableSAX) &&
 		    (ctxt->sax->processingInstruction != NULL))
 		    ctxt->sax->processingInstruction(ctxt->userData,
 		                                     target, NULL);
 		if (ctxt->instate != XML_PARSER_EOF)
 		    ctxt->instate = state;
 		return;
 	    }
 	    buf = (xmlChar *) xmlMallocAtomic(size);
 	    if (buf == NULL) {
 		xmlErrMemory(ctxt, NULL);
 		ctxt->instate = state;
 		return;
 	    }
 	    if (SKIP_BLANKS == 0) {
 		xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,
 			  "ParsePI: PI %s space expected\n", target);
 	    }
 	    cur = CUR_CHAR(l);
 	    while (IS_CHAR(cur) && /* checked */
 		   ((cur != '?') || (NXT(1) != '>'))) {
 		if (len + 5 >= size) {
 		    xmlChar *tmp;
                     size_t new_size = size * 2;
 		    tmp = (xmlChar *) xmlRealloc(buf, new_size);
 		    if (tmp == NULL) {
 			xmlErrMemory(ctxt, NULL);
 			xmlFree(buf);
 			ctxt->instate = state;
 			return;
 		    }
 		    buf = tmp;
                     size = new_size;
 		}
 		COPY_BUF(l,buf,len,cur);
                 if (len > maxLength) {
                     xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
                                       "PI %s too big found", target);
                     xmlFree(buf);
                     ctxt->instate = state;
                     return;
                 }
 		NEXTL(l);
 		cur = CUR_CHAR(l);
 	    }
 	    buf[len] = 0;
             if (ctxt->instate == XML_PARSER_EOF) {
                 xmlFree(buf);
                 return;
             }
 	    if (cur != '?') {
 		xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,
 		      "ParsePI: PI %s never end ...\n", target);
 	    } else {
 		if (inputid != ctxt->input->id) {
 		    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 	                           "PI declaration doesn't start and stop in"
                                    " the same entity\n");
 		}
 		SKIP(2);
 
 #ifdef LIBXML_CATALOG_ENABLED
 		if (((state == XML_PARSER_MISC) ||
 	             (state == XML_PARSER_START)) &&
 		    (xmlStrEqual(target, XML_CATALOG_PI))) {
 		    xmlCatalogAllow allow = xmlCatalogGetDefaults();
 		    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||
 			(allow == XML_CATA_ALLOW_ALL))
 			xmlParseCatalogPI(ctxt, buf);
 		}
 #endif
 
 
 		/*
 		 * SAX: PI detected.
 		 */
 		if ((ctxt->sax) && (!ctxt->disableSAX) &&
 		    (ctxt->sax->processingInstruction != NULL))
 		    ctxt->sax->processingInstruction(ctxt->userData,
 		                                     target, buf);
 	    }
 	    xmlFree(buf);
 	} else {
 	    xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);
 	}
 	if (ctxt->instate != XML_PARSER_EOF)
 	    ctxt->instate = state;
     }
 }
 
 /**
  * xmlParseNotationDecl:
  * @ctxt:  an XML parser context
  *
  * DEPRECATED: Internal function, don't use.
  *
  * Parse a notation declaration. Always consumes '<!'.
  *
  * [82] NotationDecl ::= '<!NOTATION' S Name S (ExternalID |  PublicID) S? '>'
  *
  * Hence there is actually 3 choices:
  *     'PUBLIC' S PubidLiteral
  *     'PUBLIC' S PubidLiteral S SystemLiteral
  * and 'SYSTEM' S SystemLiteral
  *
  * See the NOTE on xmlParseExternalID().
  */
@@ -5264,82 +5256,81 @@ void
 xmlParseNotationDecl(xmlParserCtxtPtr ctxt) {
     const xmlChar *name;
     xmlChar *Pubid;
     xmlChar *Systemid;
 
     if ((CUR != '<') || (NXT(1) != '!'))
         return;
     SKIP(2);
 
     if (CMP8(CUR_PTR, 'N', 'O', 'T', 'A', 'T', 'I', 'O', 'N')) {
 	int inputid = ctxt->input->id;
-	SHRINK;
 	SKIP(8);
 	if (SKIP_BLANKS == 0) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 			   "Space required after '<!NOTATION'\n");
 	    return;
 	}
 
         name = xmlParseName(ctxt);
 	if (name == NULL) {
 	    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);
 	    return;
 	}
 	if (xmlStrchr(name, ':') != NULL) {
 	    xmlNsErr(ctxt, XML_NS_ERR_COLON,
 		     "colons are forbidden from notation names '%s'\n",
 		     name, NULL, NULL);
 	}
 	if (SKIP_BLANKS == 0) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 		     "Space required after the NOTATION name'\n");
 	    return;
 	}
 
 	/*
 	 * Parse the IDs.
 	 */
 	Systemid = xmlParseExternalID(ctxt, &Pubid, 0);
 	SKIP_BLANKS;
 
 	if (RAW == '>') {
 	    if (inputid != ctxt->input->id) {
 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 	                       "Notation declaration doesn't start and stop"
                                " in the same entity\n");
 	    }
 	    NEXT;
 	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
 		(ctxt->sax->notationDecl != NULL))
 		ctxt->sax->notationDecl(ctxt->userData, name, Pubid, Systemid);
 	} else {
 	    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);
 	}
 	if (Systemid != NULL) xmlFree(Systemid);
 	if (Pubid != NULL) xmlFree(Pubid);
     }
 }
 
 /**
  * xmlParseEntityDecl:
  * @ctxt:  an XML parser context
  *
  * DEPRECATED: Internal function, don't use.
  *
  * Parse an entity declaration. Always consumes '<!'.
  *
  * [70] EntityDecl ::= GEDecl | PEDecl
  *
  * [71] GEDecl ::= '<!ENTITY' S Name S EntityDef S? '>'
  *
  * [72] PEDecl ::= '<!ENTITY' S '%' S Name S PEDef S? '>'
  *
  * [73] EntityDef ::= EntityValue | (ExternalID NDataDecl?)
  *
  * [74] PEDef ::= EntityValue | ExternalID
  *
  * [76] NDataDecl ::= S 'NDATA' S Name
  *
  * [ VC: Notation Declared ]
  * The Name must match the declared name of a notation.
  */
@@ -5348,238 +5339,237 @@ void
 xmlParseEntityDecl(xmlParserCtxtPtr ctxt) {
     const xmlChar *name = NULL;
     xmlChar *value = NULL;
     xmlChar *URI = NULL, *literal = NULL;
     const xmlChar *ndata = NULL;
     int isParameter = 0;
     xmlChar *orig = NULL;
 
     if ((CUR != '<') || (NXT(1) != '!'))
         return;
     SKIP(2);
 
     /* GROW; done in the caller */
     if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {
 	int inputid = ctxt->input->id;
-	SHRINK;
 	SKIP(6);
 	if (SKIP_BLANKS == 0) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 			   "Space required after '<!ENTITY'\n");
 	}
 
 	if (RAW == '%') {
 	    NEXT;
 	    if (SKIP_BLANKS == 0) {
 		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 			       "Space required after '%%'\n");
 	    }
 	    isParameter = 1;
 	}
 
         name = xmlParseName(ctxt);
 	if (name == NULL) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 	                   "xmlParseEntityDecl: no name\n");
             return;
 	}
 	if (xmlStrchr(name, ':') != NULL) {
 	    xmlNsErr(ctxt, XML_NS_ERR_COLON,
 		     "colons are forbidden from entities names '%s'\n",
 		     name, NULL, NULL);
 	}
 	if (SKIP_BLANKS == 0) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 			   "Space required after the entity name\n");
 	}
 
 	ctxt->instate = XML_PARSER_ENTITY_DECL;
 	/*
 	 * handle the various case of definitions...
 	 */
 	if (isParameter) {
 	    if ((RAW == '"') || (RAW == '\'')) {
 	        value = xmlParseEntityValue(ctxt, &orig);
 		if (value) {
 		    if ((ctxt->sax != NULL) &&
 			(!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))
 			ctxt->sax->entityDecl(ctxt->userData, name,
 		                    XML_INTERNAL_PARAMETER_ENTITY,
 				    NULL, NULL, value);
 		}
 	    } else {
 	        URI = xmlParseExternalID(ctxt, &literal, 1);
 		if ((URI == NULL) && (literal == NULL)) {
 		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 		}
 		if (URI) {
 		    xmlURIPtr uri;
 
 		    uri = xmlParseURI((const char *) URI);
 		    if (uri == NULL) {
 		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 				     "Invalid URI: %s\n", URI);
 			/*
 			 * This really ought to be a well formedness error
 			 * but the XML Core WG decided otherwise c.f. issue
 			 * E26 of the XML erratas.
 			 */
 		    } else {
 			if (uri->fragment != NULL) {
 			    /*
 			     * Okay this is foolish to block those but not
 			     * invalid URIs.
 			     */
 			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 			} else {
 			    if ((ctxt->sax != NULL) &&
 				(!ctxt->disableSAX) &&
 				(ctxt->sax->entityDecl != NULL))
 				ctxt->sax->entityDecl(ctxt->userData, name,
 					    XML_EXTERNAL_PARAMETER_ENTITY,
 					    literal, URI, NULL);
 			}
 			xmlFreeURI(uri);
 		    }
 		}
 	    }
 	} else {
 	    if ((RAW == '"') || (RAW == '\'')) {
 	        value = xmlParseEntityValue(ctxt, &orig);
 		if ((ctxt->sax != NULL) &&
 		    (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))
 		    ctxt->sax->entityDecl(ctxt->userData, name,
 				XML_INTERNAL_GENERAL_ENTITY,
 				NULL, NULL, value);
 		/*
 		 * For expat compatibility in SAX mode.
 		 */
 		if ((ctxt->myDoc == NULL) ||
 		    (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {
 		    if (ctxt->myDoc == NULL) {
 			ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 			if (ctxt->myDoc == NULL) {
 			    xmlErrMemory(ctxt, "New Doc failed");
 			    goto done;
 			}
 			ctxt->myDoc->properties = XML_DOC_INTERNAL;
 		    }
 		    if (ctxt->myDoc->intSubset == NULL)
 			ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,
 					    BAD_CAST "fake", NULL, NULL);
 
 		    xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,
 			              NULL, NULL, value);
 		}
 	    } else {
 	        URI = xmlParseExternalID(ctxt, &literal, 1);
 		if ((URI == NULL) && (literal == NULL)) {
 		    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);
 		}
 		if (URI) {
 		    xmlURIPtr uri;
 
 		    uri = xmlParseURI((const char *)URI);
 		    if (uri == NULL) {
 		        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,
 				     "Invalid URI: %s\n", URI);
 			/*
 			 * This really ought to be a well formedness error
 			 * but the XML Core WG decided otherwise c.f. issue
 			 * E26 of the XML erratas.
 			 */
 		    } else {
 			if (uri->fragment != NULL) {
 			    /*
 			     * Okay this is foolish to block those but not
 			     * invalid URIs.
 			     */
 			    xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);
 			}
 			xmlFreeURI(uri);
 		    }
 		}
 		if ((RAW != '>') && (SKIP_BLANKS == 0)) {
 		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 				   "Space required before 'NDATA'\n");
 		}
 		if (CMP5(CUR_PTR, 'N', 'D', 'A', 'T', 'A')) {
 		    SKIP(5);
 		    if (SKIP_BLANKS == 0) {
 			xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 				       "Space required after 'NDATA'\n");
 		    }
 		    ndata = xmlParseName(ctxt);
 		    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
 		        (ctxt->sax->unparsedEntityDecl != NULL))
 			ctxt->sax->unparsedEntityDecl(ctxt->userData, name,
 				    literal, URI, ndata);
 		} else {
 		    if ((ctxt->sax != NULL) &&
 		        (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))
 			ctxt->sax->entityDecl(ctxt->userData, name,
 				    XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 				    literal, URI, NULL);
 		    /*
 		     * For expat compatibility in SAX mode.
 		     * assuming the entity replacement was asked for
 		     */
 		    if ((ctxt->replaceEntities != 0) &&
 			((ctxt->myDoc == NULL) ||
 			(xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {
 			if (ctxt->myDoc == NULL) {
 			    ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);
 			    if (ctxt->myDoc == NULL) {
 			        xmlErrMemory(ctxt, "New Doc failed");
 				goto done;
 			    }
 			    ctxt->myDoc->properties = XML_DOC_INTERNAL;
 			}
 
 			if (ctxt->myDoc->intSubset == NULL)
 			    ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,
 						BAD_CAST "fake", NULL, NULL);
 			xmlSAX2EntityDecl(ctxt, name,
 				          XML_EXTERNAL_GENERAL_PARSED_ENTITY,
 				          literal, URI, NULL);
 		    }
 		}
 	    }
 	}
 	if (ctxt->instate == XML_PARSER_EOF)
 	    goto done;
 	SKIP_BLANKS;
 	if (RAW != '>') {
 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 	            "xmlParseEntityDecl: entity %s not terminated\n", name);
 	    xmlHaltParser(ctxt);
 	} else {
 	    if (inputid != ctxt->input->id) {
 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
 	                       "Entity declaration doesn't start and stop in"
                                " the same entity\n");
 	    }
 	    NEXT;
 	}
 	if (orig != NULL) {
 	    /*
 	     * Ugly mechanism to save the raw entity value.
 	     */
 	    xmlEntityPtr cur = NULL;
 
 	    if (isParameter) {
 	        if ((ctxt->sax != NULL) &&
 		    (ctxt->sax->getParameterEntity != NULL))
 		    cur = ctxt->sax->getParameterEntity(ctxt->userData, name);
 	    } else {
 	        if ((ctxt->sax != NULL) &&
 		    (ctxt->sax->getEntity != NULL))
 		    cur = ctxt->sax->getEntity(ctxt->userData, name);
 		if ((cur == NULL) && (ctxt->userData==ctxt)) {
 		    cur = xmlSAX2GetEntity(ctxt, name);
 		}
 	    }
             if ((cur != NULL) && (cur->orig == NULL)) {
 		cur->orig = orig;
                 orig = NULL;
 	    }
 	}
@@ -5679,70 +5669,69 @@ xmlEnumerationPtr
 xmlParseNotationType(xmlParserCtxtPtr ctxt) {
     const xmlChar *name;
     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
 
     if (RAW != '(') {
 	xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);
 	return(NULL);
     }
-    SHRINK;
     do {
         NEXT;
 	SKIP_BLANKS;
         name = xmlParseName(ctxt);
 	if (name == NULL) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 			   "Name expected in NOTATION declaration\n");
             xmlFreeEnumeration(ret);
 	    return(NULL);
 	}
 	tmp = ret;
 	while (tmp != NULL) {
 	    if (xmlStrEqual(name, tmp->name)) {
 		xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
 	  "standalone: attribute notation value token %s duplicated\n",
 				 name, NULL);
 		if (!xmlDictOwns(ctxt->dict, name))
 		    xmlFree((xmlChar *) name);
 		break;
 	    }
 	    tmp = tmp->next;
 	}
 	if (tmp == NULL) {
 	    cur = xmlCreateEnumeration(name);
 	    if (cur == NULL) {
                 xmlFreeEnumeration(ret);
                 return(NULL);
             }
 	    if (last == NULL) ret = last = cur;
 	    else {
 		last->next = cur;
 		last = cur;
 	    }
 	}
 	SKIP_BLANKS;
     } while (RAW == '|');
     if (RAW != ')') {
 	xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);
         xmlFreeEnumeration(ret);
 	return(NULL);
     }
     NEXT;
     return(ret);
 }
 
 /**
  * xmlParseEnumerationType:
  * @ctxt:  an XML parser context
  *
  * DEPRECATED: Internal function, don't use.
  *
  * parse an Enumeration attribute type.
  *
  * [59] Enumeration ::= '(' S? Nmtoken (S? '|' S? Nmtoken)* S? ')'
  *
  * [ VC: Enumeration ]
  * Values of this type must match one of the Nmtoken tokens in
  * the declaration
  *
  * Returns: the enumeration attribute tree built while parsing
  */
@@ -5751,69 +5740,68 @@ xmlEnumerationPtr
 xmlParseEnumerationType(xmlParserCtxtPtr ctxt) {
     xmlChar *name;
     xmlEnumerationPtr ret = NULL, last = NULL, cur, tmp;
 
     if (RAW != '(') {
 	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);
 	return(NULL);
     }
-    SHRINK;
     do {
         NEXT;
 	SKIP_BLANKS;
         name = xmlParseNmtoken(ctxt);
 	if (name == NULL) {
 	    xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);
 	    return(ret);
 	}
 	tmp = ret;
 	while (tmp != NULL) {
 	    if (xmlStrEqual(name, tmp->name)) {
 		xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,
 	  "standalone: attribute enumeration value token %s duplicated\n",
 				 name, NULL);
 		if (!xmlDictOwns(ctxt->dict, name))
 		    xmlFree(name);
 		break;
 	    }
 	    tmp = tmp->next;
 	}
 	if (tmp == NULL) {
 	    cur = xmlCreateEnumeration(name);
 	    if (!xmlDictOwns(ctxt->dict, name))
 		xmlFree(name);
 	    if (cur == NULL) {
                 xmlFreeEnumeration(ret);
                 return(NULL);
             }
 	    if (last == NULL) ret = last = cur;
 	    else {
 		last->next = cur;
 		last = cur;
 	    }
 	}
 	SKIP_BLANKS;
     } while (RAW == '|');
     if (RAW != ')') {
 	xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);
 	return(ret);
     }
     NEXT;
     return(ret);
 }
 
 /**
  * xmlParseEnumeratedType:
  * @ctxt:  an XML parser context
  * @tree:  the enumeration tree built while parsing
  *
  * DEPRECATED: Internal function, don't use.
  *
  * parse an Enumerated attribute type.
  *
  * [57] EnumeratedType ::= NotationType | Enumeration
  *
  * [58] NotationType ::= 'NOTATION' S '(' S? Name (S? '|' S? Name)* S? ')'
  *
  *
  * Returns: XML_ATTRIBUTE_ENUMERATION or XML_ATTRIBUTE_NOTATION
  */
@@ -5885,45 +5873,44 @@ xmlParseEnumeratedType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
  */
 int
 xmlParseAttributeType(xmlParserCtxtPtr ctxt, xmlEnumerationPtr *tree) {
-    SHRINK;
     if (CMP5(CUR_PTR, 'C', 'D', 'A', 'T', 'A')) {
 	SKIP(5);
 	return(XML_ATTRIBUTE_CDATA);
      } else if (CMP6(CUR_PTR, 'I', 'D', 'R', 'E', 'F', 'S')) {
 	SKIP(6);
 	return(XML_ATTRIBUTE_IDREFS);
      } else if (CMP5(CUR_PTR, 'I', 'D', 'R', 'E', 'F')) {
 	SKIP(5);
 	return(XML_ATTRIBUTE_IDREF);
      } else if ((RAW == 'I') && (NXT(1) == 'D')) {
         SKIP(2);
 	return(XML_ATTRIBUTE_ID);
      } else if (CMP6(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'Y')) {
 	SKIP(6);
 	return(XML_ATTRIBUTE_ENTITY);
      } else if (CMP8(CUR_PTR, 'E', 'N', 'T', 'I', 'T', 'I', 'E', 'S')) {
 	SKIP(8);
 	return(XML_ATTRIBUTE_ENTITIES);
      } else if (CMP8(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N', 'S')) {
 	SKIP(8);
 	return(XML_ATTRIBUTE_NMTOKENS);
      } else if (CMP7(CUR_PTR, 'N', 'M', 'T', 'O', 'K', 'E', 'N')) {
 	SKIP(7);
 	return(XML_ATTRIBUTE_NMTOKEN);
      }
      return(xmlParseEnumeratedType(ctxt, tree));
 }
 
 /**
  * xmlParseAttributeListDecl:
  * @ctxt:  an XML parser context
  *
  * DEPRECATED: Internal function, don't use.
  *
  * Parse an attribute list declaration for an element. Always consumes '<!'.
  *
  * [52] AttlistDecl ::= '<!ATTLIST' S Name AttDef* S? '>'
  *
  * [53] AttDef ::= S Name S AttType S DefaultDecl
  *
  */
@@ -6065,125 +6052,124 @@ xmlElementContentPtr
 xmlParseElementMixedContentDecl(xmlParserCtxtPtr ctxt, int inputchk) {
     xmlElementContentPtr ret = NULL, cur = NULL, n;
     const xmlChar *elem = NULL;
 
     GROW;
     if (CMP7(CUR_PTR, '#', 'P', 'C', 'D', 'A', 'T', 'A')) {
 	SKIP(7);
 	SKIP_BLANKS;
-	SHRINK;
 	if (RAW == ')') {
 	    if (ctxt->input->id != inputchk) {
 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                "Element content declaration doesn't start and"
                                " stop in the same entity\n");
 	    }
 	    NEXT;
 	    ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 	    if (ret == NULL)
 	        return(NULL);
 	    if (RAW == '*') {
 		ret->ocur = XML_ELEMENT_CONTENT_MULT;
 		NEXT;
 	    }
 	    return(ret);
 	}
 	if ((RAW == '(') || (RAW == '|')) {
 	    ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);
 	    if (ret == NULL) return(NULL);
 	}
 	while ((RAW == '|') && (ctxt->instate != XML_PARSER_EOF)) {
 	    NEXT;
 	    if (elem == NULL) {
 	        ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 		if (ret == NULL) {
 		    xmlFreeDocElementContent(ctxt->myDoc, cur);
                     return(NULL);
                 }
 		ret->c1 = cur;
 		if (cur != NULL)
 		    cur->parent = ret;
 		cur = ret;
 	    } else {
 	        n = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 		if (n == NULL) {
 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
                     return(NULL);
                 }
 		n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 		if (n->c1 != NULL)
 		    n->c1->parent = n;
 	        cur->c2 = n;
 		if (n != NULL)
 		    n->parent = cur;
 		cur = n;
 	    }
 	    SKIP_BLANKS;
 	    elem = xmlParseName(ctxt);
 	    if (elem == NULL) {
 		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 			"xmlParseElementMixedContentDecl : Name expected\n");
 		xmlFreeDocElementContent(ctxt->myDoc, ret);
 		return(NULL);
 	    }
 	    SKIP_BLANKS;
 	    GROW;
 	}
 	if ((RAW == ')') && (NXT(1) == '*')) {
 	    if (elem != NULL) {
 		cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,
 		                               XML_ELEMENT_CONTENT_ELEMENT);
 		if (cur->c2 != NULL)
 		    cur->c2->parent = cur;
             }
             if (ret != NULL)
                 ret->ocur = XML_ELEMENT_CONTENT_MULT;
 	    if (ctxt->input->id != inputchk) {
 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                "Element content declaration doesn't start and"
                                " stop in the same entity\n");
 	    }
 	    SKIP(2);
 	} else {
 	    xmlFreeDocElementContent(ctxt->myDoc, ret);
 	    xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);
 	    return(NULL);
 	}
 
     } else {
 	xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);
     }
     return(ret);
 }
 
 /**
  * xmlParseElementChildrenContentDeclPriv:
  * @ctxt:  an XML parser context
  * @inputchk:  the input used for the current entity, needed for boundary checks
  * @depth: the level of recursion
  *
  * parse the declaration for a Mixed Element content
  * The leading '(' and spaces have been skipped in xmlParseElementContentDecl
  *
  *
  * [47] children ::= (choice | seq) ('?' | '*' | '+')?
  *
  * [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?
  *
  * [49] choice ::= '(' S? cp ( S? '|' S? cp )* S? ')'
  *
  * [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'
  *
  * [ VC: Proper Group/PE Nesting ] applies to [49] and [50]
  * TODO Parameter-entity replacement text must be properly nested
  *	with parenthesized groups. That is to say, if either of the
  *	opening or closing parentheses in a choice, seq, or Mixed
  *	construct is contained in the replacement text for a parameter
  *	entity, both must be contained in the same replacement text. For
  *	interoperability, if a parameter-entity reference appears in a
  *	choice, seq, or Mixed construct, its replacement text should not
  *	be empty, and neither the first nor last non-blank character of
  *	the replacement text should be a connector (| or ,).
  *
  * Returns the tree of xmlElementContentPtr describing the element
  *          hierarchy.
  */
@@ -6191,304 +6177,303 @@ static xmlElementContentPtr
 xmlParseElementChildrenContentDeclPriv(xmlParserCtxtPtr ctxt, int inputchk,
                                        int depth) {
     xmlElementContentPtr ret = NULL, cur = NULL, last = NULL, op = NULL;
     const xmlChar *elem;
     xmlChar type = 0;
 
     if (((depth > 128) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
         (depth >  2048)) {
         xmlFatalErrMsgInt(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED,
 "xmlParseElementChildrenContentDecl : depth %d too deep, use XML_PARSE_HUGE\n",
                           depth);
 	return(NULL);
     }
     SKIP_BLANKS;
     GROW;
     if (RAW == '(') {
 	int inputid = ctxt->input->id;
 
         /* Recurse on first child */
 	NEXT;
 	SKIP_BLANKS;
         cur = ret = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
                                                            depth + 1);
         if (cur == NULL)
             return(NULL);
 	SKIP_BLANKS;
 	GROW;
     } else {
 	elem = xmlParseName(ctxt);
 	if (elem == NULL) {
 	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 	    return(NULL);
 	}
         cur = ret = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 	if (cur == NULL) {
 	    xmlErrMemory(ctxt, NULL);
 	    return(NULL);
 	}
 	GROW;
 	if (RAW == '?') {
 	    cur->ocur = XML_ELEMENT_CONTENT_OPT;
 	    NEXT;
 	} else if (RAW == '*') {
 	    cur->ocur = XML_ELEMENT_CONTENT_MULT;
 	    NEXT;
 	} else if (RAW == '+') {
 	    cur->ocur = XML_ELEMENT_CONTENT_PLUS;
 	    NEXT;
 	} else {
 	    cur->ocur = XML_ELEMENT_CONTENT_ONCE;
 	}
 	GROW;
     }
     SKIP_BLANKS;
-    SHRINK;
     while ((RAW != ')') && (ctxt->instate != XML_PARSER_EOF)) {
         /*
 	 * Each loop we parse one separator and one element.
 	 */
         if (RAW == ',') {
 	    if (type == 0) type = CUR;
 
 	    /*
 	     * Detect "Name | Name , Name" error
 	     */
 	    else if (type != CUR) {
 		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 		                  type);
 		if ((last != NULL) && (last != ret))
 		    xmlFreeDocElementContent(ctxt->myDoc, last);
 		if (ret != NULL)
 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 		return(NULL);
 	    }
 	    NEXT;
 
 	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);
 	    if (op == NULL) {
 		if ((last != NULL) && (last != ret))
 		    xmlFreeDocElementContent(ctxt->myDoc, last);
 	        xmlFreeDocElementContent(ctxt->myDoc, ret);
 		return(NULL);
 	    }
 	    if (last == NULL) {
 		op->c1 = ret;
 		if (ret != NULL)
 		    ret->parent = op;
 		ret = cur = op;
 	    } else {
 	        cur->c2 = op;
 		if (op != NULL)
 		    op->parent = cur;
 		op->c1 = last;
 		if (last != NULL)
 		    last->parent = op;
 		cur =op;
 		last = NULL;
 	    }
 	} else if (RAW == '|') {
 	    if (type == 0) type = CUR;
 
 	    /*
 	     * Detect "Name , Name | Name" error
 	     */
 	    else if (type != CUR) {
 		xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,
 		    "xmlParseElementChildrenContentDecl : '%c' expected\n",
 				  type);
 		if ((last != NULL) && (last != ret))
 		    xmlFreeDocElementContent(ctxt->myDoc, last);
 		if (ret != NULL)
 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 		return(NULL);
 	    }
 	    NEXT;
 
 	    op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);
 	    if (op == NULL) {
 		if ((last != NULL) && (last != ret))
 		    xmlFreeDocElementContent(ctxt->myDoc, last);
 		if (ret != NULL)
 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 		return(NULL);
 	    }
 	    if (last == NULL) {
 		op->c1 = ret;
 		if (ret != NULL)
 		    ret->parent = op;
 		ret = cur = op;
 	    } else {
 	        cur->c2 = op;
 		if (op != NULL)
 		    op->parent = cur;
 		op->c1 = last;
 		if (last != NULL)
 		    last->parent = op;
 		cur =op;
 		last = NULL;
 	    }
 	} else {
 	    xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);
 	    if ((last != NULL) && (last != ret))
 	        xmlFreeDocElementContent(ctxt->myDoc, last);
 	    if (ret != NULL)
 		xmlFreeDocElementContent(ctxt->myDoc, ret);
 	    return(NULL);
 	}
 	GROW;
 	SKIP_BLANKS;
 	GROW;
 	if (RAW == '(') {
 	    int inputid = ctxt->input->id;
 	    /* Recurse on second child */
 	    NEXT;
 	    SKIP_BLANKS;
 	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
                                                           depth + 1);
             if (last == NULL) {
 		if (ret != NULL)
 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 		return(NULL);
             }
 	    SKIP_BLANKS;
 	} else {
 	    elem = xmlParseName(ctxt);
 	    if (elem == NULL) {
 		xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);
 		if (ret != NULL)
 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 		return(NULL);
 	    }
 	    last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);
 	    if (last == NULL) {
 		if (ret != NULL)
 		    xmlFreeDocElementContent(ctxt->myDoc, ret);
 		return(NULL);
 	    }
 	    if (RAW == '?') {
 		last->ocur = XML_ELEMENT_CONTENT_OPT;
 		NEXT;
 	    } else if (RAW == '*') {
 		last->ocur = XML_ELEMENT_CONTENT_MULT;
 		NEXT;
 	    } else if (RAW == '+') {
 		last->ocur = XML_ELEMENT_CONTENT_PLUS;
 		NEXT;
 	    } else {
 		last->ocur = XML_ELEMENT_CONTENT_ONCE;
 	    }
 	}
 	SKIP_BLANKS;
 	GROW;
     }
     if ((cur != NULL) && (last != NULL)) {
         cur->c2 = last;
 	if (last != NULL)
 	    last->parent = cur;
     }
     if (ctxt->input->id != inputchk) {
 	xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                        "Element content declaration doesn't start and stop in"
                        " the same entity\n");
     }
     NEXT;
     if (RAW == '?') {
 	if (ret != NULL) {
 	    if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||
 	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
 	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 	    else
 	        ret->ocur = XML_ELEMENT_CONTENT_OPT;
 	}
 	NEXT;
     } else if (RAW == '*') {
 	if (ret != NULL) {
 	    ret->ocur = XML_ELEMENT_CONTENT_MULT;
 	    cur = ret;
 	    /*
 	     * Some normalization:
 	     * (a | b* | c?)* == (a | b | c)*
 	     */
 	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
 		if ((cur->c1 != NULL) &&
 	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
 		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))
 		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 		if ((cur->c2 != NULL) &&
 	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
 		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))
 		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 		cur = cur->c2;
 	    }
 	}
 	NEXT;
     } else if (RAW == '+') {
 	if (ret != NULL) {
 	    int found = 0;
 
 	    if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||
 	        (ret->ocur == XML_ELEMENT_CONTENT_MULT))
 	        ret->ocur = XML_ELEMENT_CONTENT_MULT;
 	    else
 	        ret->ocur = XML_ELEMENT_CONTENT_PLUS;
 	    /*
 	     * Some normalization:
 	     * (a | b*)+ == (a | b)*
 	     * (a | b?)+ == (a | b)*
 	     */
 	    while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {
 		if ((cur->c1 != NULL) &&
 	            ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||
 		     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {
 		    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;
 		    found = 1;
 		}
 		if ((cur->c2 != NULL) &&
 	            ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||
 		     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {
 		    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;
 		    found = 1;
 		}
 		cur = cur->c2;
 	    }
 	    if (found)
 		ret->ocur = XML_ELEMENT_CONTENT_MULT;
 	}
 	NEXT;
     }
     return(ret);
 }
 
 /**
  * xmlParseElementChildrenContentDecl:
  * @ctxt:  an XML parser context
  * @inputchk:  the input used for the current entity, needed for boundary checks
  *
  * DEPRECATED: Internal function, don't use.
  *
  * parse the declaration for a Mixed Element content
  * The leading '(' and spaces have been skipped in xmlParseElementContentDecl
  *
  * [47] children ::= (choice | seq) ('?' | '*' | '+')?
  *
  * [48] cp ::= (Name | choice | seq) ('?' | '*' | '+')?
  *
  * [49] choice ::= '(' S? cp ( S? '|' S? cp )* S? ')'
  *
  * [50] seq ::= '(' S? cp ( S? ',' S? cp )* S? ')'
  *
  * [ VC: Proper Group/PE Nesting ] applies to [49] and [50]
  * TODO Parameter-entity replacement text must be properly nested
  *	with parenthesized groups. That is to say, if either of the
  *	opening or closing parentheses in a choice, seq, or Mixed
  *	construct is contained in the replacement text for a parameter
  *	entity, both must be contained in the same replacement text. For
  *	interoperability, if a parameter-entity reference appears in a
  *	choice, seq, or Mixed construct, its replacement text should not
  *	be empty, and neither the first nor last non-blank character of
  *	the replacement text should be a connector (| or ,).
  *
  * Returns the tree of xmlElementContentPtr describing the element
  *          hierarchy.
  */
@@ -6676,117 +6661,118 @@ static void
 xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
     int *inputIds = NULL;
     size_t inputIdsSize = 0;
     size_t depth = 0;
 
     while (ctxt->instate != XML_PARSER_EOF) {
         if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
             int id = ctxt->input->id;
 
             SKIP(3);
             SKIP_BLANKS;
 
             if (CMP7(CUR_PTR, 'I', 'N', 'C', 'L', 'U', 'D', 'E')) {
                 SKIP(7);
                 SKIP_BLANKS;
                 if (RAW != '[') {
                     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
                     xmlHaltParser(ctxt);
                     goto error;
                 }
                 if (ctxt->input->id != id) {
                     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                    "All markup of the conditional section is"
                                    " not in the same entity\n");
                 }
                 NEXT;
 
                 if (inputIdsSize <= depth) {
                     int *tmp;
 
                     inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);
                     tmp = (int *) xmlRealloc(inputIds,
                             inputIdsSize * sizeof(int));
                     if (tmp == NULL) {
                         xmlErrMemory(ctxt, NULL);
                         goto error;
                     }
                     inputIds = tmp;
                 }
                 inputIds[depth] = id;
                 depth++;
             } else if (CMP6(CUR_PTR, 'I', 'G', 'N', 'O', 'R', 'E')) {
                 size_t ignoreDepth = 0;
 
                 SKIP(6);
                 SKIP_BLANKS;
                 if (RAW != '[') {
                     xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
                     xmlHaltParser(ctxt);
                     goto error;
                 }
                 if (ctxt->input->id != id) {
                     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                    "All markup of the conditional section is"
                                    " not in the same entity\n");
                 }
                 NEXT;
 
                 while (RAW != 0) {
                     if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
                         SKIP(3);
                         ignoreDepth++;
                         /* Check for integer overflow */
                         if (ignoreDepth == 0) {
                             xmlErrMemory(ctxt, NULL);
                             goto error;
                         }
                     } else if ((RAW == ']') && (NXT(1) == ']') &&
                                (NXT(2) == '>')) {
                         if (ignoreDepth == 0)
                             break;
                         SKIP(3);
                         ignoreDepth--;
                     } else {
                         NEXT;
                     }
                 }
 
 		if (RAW == 0) {
 		    xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);
                     goto error;
 		}
                 if (ctxt->input->id != id) {
                     xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                    "All markup of the conditional section is"
                                    " not in the same entity\n");
                 }
                 SKIP(3);
             } else {
                 xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
                 xmlHaltParser(ctxt);
                 goto error;
             }
         } else if ((depth > 0) &&
                    (RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
             depth--;
             if (ctxt->input->id != inputIds[depth]) {
                 xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
                                "All markup of the conditional section is not"
                                " in the same entity\n");
             }
             SKIP(3);
         } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
             xmlParseMarkupDecl(ctxt);
         } else {
             xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
             xmlHaltParser(ctxt);
             goto error;
         }
 
         if (depth == 0)
             break;
 
         SKIP_BLANKS;
+        SHRINK;
         GROW;
     }
 
@@ -6966,78 +6952,79 @@ void
 xmlParseExternalSubset(xmlParserCtxtPtr ctxt, const xmlChar *ExternalID,
                        const xmlChar *SystemID) {
     xmlDetectSAX2(ctxt);
     GROW;
 
     if ((ctxt->encoding == NULL) &&
         (ctxt->input->end - ctxt->input->cur >= 4)) {
         xmlChar start[4];
 	xmlCharEncoding enc;
 
 	start[0] = RAW;
 	start[1] = NXT(1);
 	start[2] = NXT(2);
 	start[3] = NXT(3);
 	enc = xmlDetectCharEncoding(start, 4);
 	if (enc != XML_CHAR_ENCODING_NONE)
 	    xmlSwitchEncoding(ctxt, enc);
     }
 
     if (CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) {
 	xmlParseTextDecl(ctxt);
 	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
 	    /*
 	     * The XML REC instructs us to stop parsing right here
 	     */
 	    xmlHaltParser(ctxt);
 	    return;
 	}
     }
     if (ctxt->myDoc == NULL) {
         ctxt->myDoc = xmlNewDoc(BAD_CAST "1.0");
 	if (ctxt->myDoc == NULL) {
 	    xmlErrMemory(ctxt, "New Doc failed");
 	    return;
 	}
 	ctxt->myDoc->properties = XML_DOC_INTERNAL;
     }
     if ((ctxt->myDoc != NULL) && (ctxt->myDoc->intSubset == NULL))
         xmlCreateIntSubset(ctxt->myDoc, NULL, ExternalID, SystemID);
 
     ctxt->instate = XML_PARSER_DTD;
     ctxt->external = 1;
     SKIP_BLANKS;
     while ((ctxt->instate != XML_PARSER_EOF) && (RAW != 0)) {
 	GROW;
         if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
             xmlParseConditionalSections(ctxt);
         } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
             xmlParseMarkupDecl(ctxt);
         } else {
             xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
             xmlHaltParser(ctxt);
             return;
         }
         SKIP_BLANKS;
+        SHRINK;
     }
 
     if (RAW != 0) {
 	xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
     }
 
 }
 
 /**
  * xmlParseReference:
  * @ctxt:  an XML parser context
  *
  * DEPRECATED: Internal function, don't use.
  *
  * parse and handle entity references in content, depending on the SAX
  * interface, this may end-up in a call to character() if this is a
  * CharRef, a predefined entity, if there is no reference() callback.
  * or if the parser was asked to switch to that mode.
  *
  * Always consumes '&'.
  *
  * [67] Reference ::= EntityRef | CharRef
  */
@@ -8310,88 +8297,90 @@ static void
 xmlParseInternalSubset(xmlParserCtxtPtr ctxt) {
     /*
      * Is there any DTD definition ?
      */
     if (RAW == '[') {
         int baseInputNr = ctxt->inputNr;
         ctxt->instate = XML_PARSER_DTD;
         NEXT;
 	/*
 	 * Parse the succession of Markup declarations and
 	 * PEReferences.
 	 * Subsequence (markupdecl | PEReference | S)*
 	 */
 	SKIP_BLANKS;
 	while (((RAW != ']') || (ctxt->inputNr > baseInputNr)) &&
                (ctxt->instate != XML_PARSER_EOF)) {
 
             /*
              * Conditional sections are allowed from external entities included
              * by PE References in the internal subset.
              */
             if ((ctxt->inputNr > 1) && (ctxt->input->filename != NULL) &&
                 (RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
                 xmlParseConditionalSections(ctxt);
             } else if ((RAW == '<') && ((NXT(1) == '!') || (NXT(1) == '?'))) {
 	        xmlParseMarkupDecl(ctxt);
             } else if (RAW == '%') {
 	        xmlParsePEReference(ctxt);
             } else {
 		xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
                         "xmlParseInternalSubset: error detected in"
                         " Markup declaration\n");
                 xmlHaltParser(ctxt);
                 return;
             }
 	    SKIP_BLANKS;
+            SHRINK;
+            GROW;
 	}
 	if (RAW == ']') {
 	    NEXT;
 	    SKIP_BLANKS;
 	}
     }
 
     /*
      * We should be at the end of the DOCTYPE declaration.
      */
     if (RAW != '>') {
 	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
 	return;
     }
     NEXT;
 }
 
 #ifdef LIBXML_SAX1_ENABLED
 /**
  * xmlParseAttribute:
  * @ctxt:  an XML parser context
  * @value:  a xmlChar ** used to store the value of the attribute
  *
  * DEPRECATED: Internal function, don't use.
  *
  * parse an attribute
  *
  * [41] Attribute ::= Name Eq AttValue
  *
  * [ WFC: No External Entity References ]
  * Attribute values cannot contain direct or indirect entity references
  * to external entities.
  *
  * [ WFC: No < in Attribute Values ]
  * The replacement text of any entity referred to directly or indirectly in
  * an attribute value (other than "&lt;") must not contain a <.
  *
  * [ VC: Attribute Value Type ]
  * The attribute must have been declared; the value must be of the type
  * declared for it.
  *
  * [25] Eq ::= S? '=' S?
  *
  * With namespace:
  *
  * [NS 11] Attribute ::= QName Eq AttValue
  *
  * Also the case QName == xmlns:??? is handled independently as a namespace
  * definition.
  *
  * Returns the attribute name, and the value in *value.
  */
@@ -9214,223 +9203,215 @@ static const xmlChar *
 xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref,
                   const xmlChar **URI, int *tlen) {
     const xmlChar *localname;
     const xmlChar *prefix;
     const xmlChar *attname;
     const xmlChar *aprefix;
     const xmlChar *nsname;
     xmlChar *attvalue;
     const xmlChar **atts = ctxt->atts;
     int maxatts = ctxt->maxatts;
     int nratts, nbatts, nbdef, inputid;
     int i, j, nbNs, attval;
     size_t cur;
     int nsNr = ctxt->nsNr;
 
     if (RAW != '<') return(NULL);
     NEXT1;
 
-    /*
-     * NOTE: it is crucial with the SAX2 API to never call SHRINK beyond that
-     *       point since the attribute values may be stored as pointers to
-     *       the buffer and calling SHRINK would destroy them !
-     *       The Shrinking is only possible once the full set of attribute
-     *       callbacks have been done.
-     */
-    SHRINK;
     cur = ctxt->input->cur - ctxt->input->base;
     inputid = ctxt->input->id;
     nbatts = 0;
     nratts = 0;
     nbdef = 0;
     nbNs = 0;
     attval = 0;
     /* Forget any namespaces added during an earlier parse of this element. */
     ctxt->nsNr = nsNr;
 
     localname = xmlParseQName(ctxt, &prefix);
     if (localname == NULL) {
 	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
 		       "StartTag: invalid element name\n");
         return(NULL);
     }
     *tlen = ctxt->input->cur - ctxt->input->base - cur;
 
     /*
      * Now parse the attributes, it ends up with the ending
      *
      * (S Attribute)* S?
      */
     SKIP_BLANKS;
     GROW;
 
     while (((RAW != '>') &&
 	   ((RAW != '/') || (NXT(1) != '>')) &&
 	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {
 	int len = -1, alloc = 0;
 
 	attname = xmlParseAttribute2(ctxt, prefix, localname,
 	                             &aprefix, &attvalue, &len, &alloc);
         if (attname == NULL) {
 	    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
 	         "xmlParseStartTag: problem parsing attributes\n");
 	    break;
 	}
         if (attvalue == NULL)
             goto next_attr;
 	if (len < 0) len = xmlStrlen(attvalue);
 
         if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {
             const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);
             xmlURIPtr uri;
 
             if (URL == NULL) {
                 xmlErrMemory(ctxt, "dictionary allocation failure");
                 if ((attvalue != NULL) && (alloc != 0))
                     xmlFree(attvalue);
                 localname = NULL;
                 goto done;
             }
             if (*URL != 0) {
                 uri = xmlParseURI((const char *) URL);
                 if (uri == NULL) {
                     xmlNsErr(ctxt, XML_WAR_NS_URI,
                              "xmlns: '%s' is not a valid URI\n",
                                        URL, NULL, NULL);
                 } else {
                     if (uri->scheme == NULL) {
                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
                                   "xmlns: URI %s is not absolute\n",
                                   URL, NULL, NULL);
                     }
                     xmlFreeURI(uri);
                 }
                 if (URL == ctxt->str_xml_ns) {
                     if (attname != ctxt->str_xml) {
                         xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                      "xml namespace URI cannot be the default namespace\n",
                                  NULL, NULL, NULL);
                     }
                     goto next_attr;
                 }
                 if ((len == 29) &&
                     (xmlStrEqual(URL,
                              BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                          "reuse of the xmlns namespace name is forbidden\n",
                              NULL, NULL, NULL);
                     goto next_attr;
                 }
             }
             /*
              * check that it's not a defined namespace
              */
             for (j = 1;j <= nbNs;j++)
                 if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)
                     break;
             if (j <= nbNs)
                 xmlErrAttributeDup(ctxt, NULL, attname);
             else
                 if (nsPush(ctxt, NULL, URL) > 0) nbNs++;
 
         } else if (aprefix == ctxt->str_xmlns) {
             const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len);
             xmlURIPtr uri;
 
             if (attname == ctxt->str_xml) {
                 if (URL != ctxt->str_xml_ns) {
                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                              "xml namespace prefix mapped to wrong URI\n",
                              NULL, NULL, NULL);
                 }
                 /*
                  * Do not keep a namespace definition node
                  */
                 goto next_attr;
             }
             if (URL == ctxt->str_xml_ns) {
                 if (attname != ctxt->str_xml) {
                     xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                              "xml namespace URI mapped to wrong prefix\n",
                              NULL, NULL, NULL);
                 }
                 goto next_attr;
             }
             if (attname == ctxt->str_xmlns) {
                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                          "redefinition of the xmlns prefix is forbidden\n",
                          NULL, NULL, NULL);
                 goto next_attr;
             }
             if ((len == 29) &&
                 (xmlStrEqual(URL,
                              BAD_CAST "http://www.w3.org/2000/xmlns/"))) {
                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                          "reuse of the xmlns namespace name is forbidden\n",
                          NULL, NULL, NULL);
                 goto next_attr;
             }
             if ((URL == NULL) || (URL[0] == 0)) {
                 xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE,
                          "xmlns:%s: Empty XML namespace is not allowed\n",
                               attname, NULL, NULL);
                 goto next_attr;
             } else {
                 uri = xmlParseURI((const char *) URL);
                 if (uri == NULL) {
                     xmlNsErr(ctxt, XML_WAR_NS_URI,
                          "xmlns:%s: '%s' is not a valid URI\n",
                                        attname, URL, NULL);
                 } else {
                     if ((ctxt->pedantic) && (uri->scheme == NULL)) {
                         xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE,
                                   "xmlns:%s: URI %s is not absolute\n",
                                   attname, URL, NULL);
                     }
                     xmlFreeURI(uri);
                 }
             }
 
             /*
              * check that it's not a defined namespace
              */
             for (j = 1;j <= nbNs;j++)
                 if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)
                     break;
             if (j <= nbNs)
                 xmlErrAttributeDup(ctxt, aprefix, attname);
             else
                 if (nsPush(ctxt, attname, URL) > 0) nbNs++;
 
         } else {
             /*
              * Add the pair to atts
              */
             if ((atts == NULL) || (nbatts + 5 > maxatts)) {
                 if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {
                     goto next_attr;
                 }
                 maxatts = ctxt->maxatts;
                 atts = ctxt->atts;
             }
             ctxt->attallocs[nratts++] = alloc;
             atts[nbatts++] = attname;
             atts[nbatts++] = aprefix;
             /*
              * The namespace URI field is used temporarily to point at the
              * base of the current input buffer for non-alloced attributes.
              * When the input buffer is reallocated, all the pointers become
              * invalid, but they can be reconstructed later.
              */
             if (alloc)
                 atts[nbatts++] = NULL;
             else
                 atts[nbatts++] = ctxt->input->base;
             atts[nbatts++] = attvalue;
             attvalue += len;
             atts[nbatts++] = attvalue;
             /*
              * tag if some deallocation is needed
              */
             if (alloc != 0) attval = 1;
             attvalue = NULL; /* moved into atts */
         }
@@ -9823,74 +9804,74 @@ static void
 xmlParseContentInternal(xmlParserCtxtPtr ctxt) {
     int nameNr = ctxt->nameNr;
 
     GROW;
     while ((RAW != 0) &&
 	   (ctxt->instate != XML_PARSER_EOF)) {
 	const xmlChar *cur = ctxt->input->cur;
 
 	/*
 	 * First case : a Processing Instruction.
 	 */
 	if ((*cur == '<') && (cur[1] == '?')) {
 	    xmlParsePI(ctxt);
 	}
 
 	/*
 	 * Second case : a CDSection
 	 */
 	/* 2.6.0 test was *cur not RAW */
 	else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {
 	    xmlParseCDSect(ctxt);
 	}
 
 	/*
 	 * Third case :  a comment
 	 */
 	else if ((*cur == '<') && (NXT(1) == '!') &&
 		 (NXT(2) == '-') && (NXT(3) == '-')) {
 	    xmlParseComment(ctxt);
 	    ctxt->instate = XML_PARSER_CONTENT;
 	}
 
 	/*
 	 * Fourth case :  a sub-element.
 	 */
 	else if (*cur == '<') {
             if (NXT(1) == '/') {
                 if (ctxt->nameNr <= nameNr)
                     break;
 	        xmlParseElementEnd(ctxt);
             } else {
 	        xmlParseElementStart(ctxt);
             }
 	}
 
 	/*
 	 * Fifth case : a reference. If if has not been resolved,
 	 *    parsing returns it's Name, create the node
 	 */
 
 	else if (*cur == '&') {
 	    xmlParseReference(ctxt);
 	}
 
 	/*
 	 * Last case, text. Note that References are handled directly.
 	 */
 	else {
 	    xmlParseCharData(ctxt, 0);
 	}
 
-	GROW;
 	SHRINK;
+	GROW;
     }
 }
 
 /**
  * xmlParseContent:
  * @ctxt:  an XML parser context
  *
  * Parse a content sequence. Stops at EOF or '</'.
  *
  * [43] content ::= (element | CharData | Reference | CDSect | PI | Comment)*
  */
diff --git a/parserInternals.c b/parserInternals.c
index dd165790..ce4f75e0 100644
--- a/parserInternals.c
+++ b/parserInternals.c
@@ -408,56 +408,44 @@ xmlParserInputGrow(xmlParserInputPtr in, int len) {
 /**
  * xmlParserShrink:
  * @ctxt:  an XML parser context
  */
-int
+void
 xmlParserShrink(xmlParserCtxtPtr ctxt) {
     xmlParserInputPtr in = ctxt->input;
     xmlParserInputBufferPtr buf = in->buf;
     size_t used;
-    int ret = 0;
 
     /* Don't shrink memory buffers. */
     if ((buf == NULL) ||
         ((buf->encoder == NULL) && (buf->readcallback == NULL)))
-        return(0);
+        return;
 
     used = in->cur - in->base;
     /*
      * Do not shrink on large buffers whose only a tiny fraction
      * was consumed
      */
     if (used > INPUT_CHUNK) {
 	size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);
 
 	if (res > 0) {
             used -= res;
             if ((res > ULONG_MAX) ||
                 (in->consumed > ULONG_MAX - (unsigned long)res))
                 in->consumed = ULONG_MAX;
             else
                 in->consumed += res;
 	}
     }
 
-    if (xmlBufUse(buf->buffer) < INPUT_CHUNK)
-        ret = xmlParserInputBufferGrow(buf, INPUT_CHUNK);
-
     xmlBufSetInputBaseCur(buf->buffer, in, 0, used);
-
-    /* TODO: Get error code from xmlParserInputBufferGrow */
-    if (ret < 0) {
-        xmlErrInternal(ctxt, "Growing input buffer", NULL);
-        xmlHaltParser(ctxt);
-    }
-
-    return(ret);
 }
 
 /**
  * xmlParserInputShrink:
  * @in:  an XML parser input
  *
  * DEPRECATED: Don't use.
  *
  * This function removes used input for the parser.
  */
