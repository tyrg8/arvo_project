commit 321ba58316e77b5f4d977897aaa4bdbe43a5e38b
Merge: 7db4a5c 37ae5a8
Author: Volodymyr Shymanskyy <vshymanskyi@gmail.com>
Date:   Mon Aug 29 16:57:22 2022 +0300

    Merge branch 'main' of https://github.com/wasm3/wasm3 into main

diff --git a/.github/workflows/tests.yml b/.github/workflows/tests.yml
index 2935b1d..f4893d4 100644
--- a/.github/workflows/tests.yml
+++ b/.github/workflows/tests.yml
@@ -9,611 +9,621 @@ on:
 jobs:
   linux:
     runs-on: ubuntu-latest
     name: linux-${{ matrix.config.target }}
     timeout-minutes: 10
 
     strategy:
       fail-fast: false
       matrix:
         config:
         - {target: clang,       cc: clang,      }
         - {target: clang-x86,   cc: clang,      flags: -DCMAKE_C_FLAGS="-m32",    install: "gcc-multilib"   }
         - {target: gcc,         cc: gcc,        }
         # Builds without uvwasi
         - {target: gcc-no-uvwasi,   cc: gcc,    flags: -DBUILD_WASI=simple   }
         - {target: clang-no-uvwasi, cc: clang,  flags: -DBUILD_WASI=simple   }
         # Debug builds
         - {target: gcc-debug,               cc: gcc,    flags: -DCMAKE_BUILD_TYPE=Debug                         }
         - {target: clang-no-uvwasi-debug,   cc: clang,  flags: -DCMAKE_BUILD_TYPE=Debug -DBUILD_WASI=simple     }
 
         # TODO: fails on numeric operations
         #- {target: gcc-x86,     cc: gcc,        flags: "-m32",                    install: "gcc-multilib"   }
 
     steps:
     - uses: actions/checkout@v2
     - name: Install ${{ matrix.config.install }}
       if: ${{ matrix.config.install }}
       run: |
         sudo apt update
         sudo apt install ${{ matrix.config.install }}
     - name: Configure
       env:
         CC: ${{ matrix.config.cc }}
         CFLAGS: ${{ matrix.config.cflags }}
       run: |
         mkdir build
         cd build
         cmake ${{ matrix.config.flags }} ..
     - name: Build
       run: |
         cmake --build build
     - name: Test WebAssembly spec
       run: cd test && python3 run-spec-test.py
     - name: Test previous WebAssembly specs
       run: |
         cd test
         python3 run-spec-test.py --spec=v1.1
     - name: Test WASI apps
       run: cd test && python3 run-wasi-test.py
 
   linux-alpine:
     runs-on: ubuntu-latest
     container: alpine:3.10
 
     steps:
     - uses: actions/checkout@v2
     - name: Prepare
       run: apk add build-base cmake python3 git --update-cache
     - name: Configure
       run: |
         mkdir build
         cd build
         cmake ..
     - name: Build
       run: cmake --build build
     - name: Test WebAssembly spec
       run: cd test && python3 run-spec-test.py
     - name: Test WASI apps
       run: cd test && python3 run-wasi-test.py
 
+  big-endian-i32-constant:
+    runs-on: ubuntu-latest
+
+    steps:
+    - uses: actions/checkout@v3
+    - name: Get the qemu container
+      run: docker run --rm --privileged multiarch/qemu-user-static --reset -p yes
+    - name: Run tests
+      run: docker run --rm --interactive --mount type=bind,source=$(pwd),target=/host s390x/alpine sh -c "apk add build-base cmake git --update-cache && cd /host && mkdir build && cd build && cmake .. && cd .. && cmake --build build && echo wasm3 built && echo AGFzbQEAAAAGBgF/AEElCwcLAQdteWNvbnN0AwAACARuYW1lAgEA | base64 -d > myconst.wasm && echo ':get-global myconst' | ./build/wasm3 --repl myconst.wasm && echo ':get-global myconst' | ./build/wasm3 --repl myconst.wasm 2>&1 | grep 37"
+
   macos:
     runs-on: macos-latest
     name: macos-${{ matrix.config.target }}
     timeout-minutes: 10
 
     strategy:
       fail-fast: false
       matrix:
         config:
         - {target: uvwasi,      }
         - {target: no-uvwasi,   flags: -DBUILD_WASI=simple   }
 
     steps:
     - uses: actions/checkout@v2
     - name: Configure
       run: |
         mkdir build
         cd build
         cmake ${{ matrix.config.flags }} ..
     - name: Build
       run: |
         cmake --build build
     - name: Test WebAssembly spec
       run: cd test && python3 run-spec-test.py
     - name: Test previous WebAssembly specs
       run: |
         cd test
         python3 run-spec-test.py --spec=v1.1
     - name: Test WASI apps
       run: cd test && python3 run-wasi-test.py
 
   windows:
     runs-on: windows-latest
     name: windows-${{ matrix.config.target }}
     timeout-minutes: 10
 
     strategy:
       fail-fast: false
       matrix:
         config:
         - {target: clang-x64,   platform: "-A x64",     toolset: "-T ClangCL"   }
         - {target: msvc-x64,    platform: "-A x64",     toolset: ""             }
         - {target: clang-x86,   platform: "-A Win32",   toolset: "-T ClangCL"   }
         - {target: msvc-x86,    platform: "-A Win32",   toolset: ""             }
         # Builds without uvwasi
         - {target: clang-x64-no-uvwasi,   platform: "-A x64",     toolset: "-T ClangCL",  flags: "-DBUILD_WASI=simple"   }
         - {target: msvc-x64-no-uvwasi,    platform: "-A x64",     toolset: "",            flags: "-DBUILD_WASI=simple"   }
         - {target: clang-x86-no-uvwasi,   platform: "-A Win32",   toolset: "-T ClangCL",  flags: "-DBUILD_WASI=simple"   }
         - {target: msvc-x86-no-uvwasi,    platform: "-A Win32",   toolset: "",            flags: "-DBUILD_WASI=simple"   }
 
     defaults:
       run:
         shell: cmd
 
     steps:
     - uses: actions/checkout@v2
     - name: Configure
       run: |
         mkdir build
         cd build
         cmake ${{ matrix.config.platform }} ${{ matrix.config.toolset }} ${{ matrix.config.flags }} ..
     - name: Build
       run: |
         cmake --build build --config Release
         cp ./build/Release/wasm3.exe ./build/
     - name: Test WebAssembly spec
       run: |
         cd test
         python run-spec-test.py
     - name: Test previous WebAssembly specs
       run: |
         cd test
         python run-spec-test.py --spec=v1.1
     - name: Test WASI apps
       run: |
         cd test
         python run-wasi-test.py
 
   cygwin-build:
     runs-on: windows-latest
 
     steps:
       - uses: actions/checkout@main
       - name: Set up Cygwin
         uses: egor-tensin/setup-cygwin@master
         with:
             platform: x64
             packages: make gcc-g++ cmake
       - run: cd $GITHUB_WORKSPACE && cmake -DBUILD_WASI=simple . && make
         shell: C:\tools\cygwin\bin\bash.exe --login --norc -eo pipefail -o igncr '{0}'
 
   wasi:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Install Python dependencies
       run: |
         python3 -m pip install pip==20.1.1
         python3 -m pip install --upgrade setuptools wheel
         pip3 --version
     - name: Install Wasienv
       env:
         WASMER_RELEASE_TAG: "1.0.2"
       run: curl https://raw.githubusercontent.com/wasienv/wasienv/master/install.sh | sh
     - name: Configure
       run: |
         source $HOME/.wasienv/wasienv.sh
         mkdir build-wasi
         cd build-wasi
         wasimake cmake ..
     - name: Build
       run: |
         source $HOME/.wasienv/wasienv.sh
         cmake --build build-wasi
     - name: Test WebAssembly spec (in Wasmer)
       run: |
         source $HOME/.wasmer/wasmer.sh
         cd test
         python3 run-spec-test.py --exec "wasmer run --mapdir=/:. ../build-wasi/wasm3.wasm -- --repl"
 
     - name: Test WASI apps (in Wasmer)
       run: |
         source $HOME/.wasmer/wasmer.sh
         cd test
         python3 run-wasi-test.py --exec "wasmer run --mapdir=/:. ../build-wasi/wasm3.wasm --" --fast
 
     - name: Configure (native)
       run: |
         mkdir build
         cd build
         cmake ..
     - name: Build (native)
       run: |
         cmake --build build
     - name: Test WebAssembly spec (in Wasm3, self-hosting)
       run: |
         cd test
         cp ../build-wasi/wasm3.wasm ./
         python3 run-spec-test.py --exec "../build/wasm3 --stack-size 2097152 ../build-wasi/wasm3.wasm --repl"
     - name: Test WASI apps (in Wasm3, self-hosting)
       run: |
         cd test
         python3 run-wasi-test.py --fast --exec "../build/wasm3 --stack-size 2097152 ../build-wasi/wasm3.wasm"
 
   ios:
     runs-on: macos-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: List Xcode versions
       run: ls /Applications | grep Xcode
     - name: Select Xcode 12
       run: sudo xcode-select -switch /Applications/Xcode_12.4.app
     - name: Build (iPhone 11)
       run: |
         cd platforms/ios
         xcodebuild build -scheme wasm3 -project wasm3.xcodeproj -configuration Release -destination 'platform=iOS Simulator,name=iPhone 11,OS=14.4'
 
   android:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - uses: seanmiddleditch/gha-setup-ninja@master
     - name: Set up JDK 1.8
       uses: actions/setup-java@v1
       with:
         java-version: 1.8
     - name: Install NDK
       run: |
         sudo ${ANDROID_HOME}/tools/bin/sdkmanager --install "ndk;22.1.7171670"
         sudo ${ANDROID_HOME}/tools/bin/sdkmanager --uninstall "cmake;3.18.1"
         sudo ${ANDROID_HOME}/tools/bin/sdkmanager --install "cmake;3.10.2.4988404"
     - name: Build
       run: |
         cd platforms/android
         ./gradlew build
 
   python:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - name: Checkout
       uses: actions/checkout@v2
       with:
         path: wasm3
     - name: Checkout pywasm3
       uses: actions/checkout@v2
       with:
         repository: wasm3/pywasm3
         path: pywasm3
     - name: Set up Python
       uses: actions/setup-python@v2
     - name: Update and Build Python module
       run: |
         rm -rf ./pywasm3/wasm3
         cp -r wasm3/source ./pywasm3/wasm3
         pip install ./pywasm3
     - name: Install WABT
       run: |
         sudo apt update
         sudo apt install wabt
     - name: Test
       run: |
         pip install pytest
         cd ./pywasm3
         pytest
 
   cosmopolitan:
     runs-on: ubuntu-20.04
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Build αcτµαlly pδrταblε εxεcµταblε
       run: |
         cd platforms/cosmopolitan
         gcc -v
         ./build.sh
     - name: Prepare tests
       run: |
         cd test
         cp ../platforms/cosmopolitan/wasm3.com ./wasm3-lin.com
         cp ../platforms/cosmopolitan/wasm3.com ./wasm3-win.com
         sudo sh -c "echo ':APE:M::MZqFpD::/bin/sh:' >/proc/sys/fs/binfmt_misc/register"
     - name: Test WebAssembly spec
       run: |
         cd test
         python3 run-spec-test.py --exec "./wasm3-lin.com --repl"
     - name: Test WASI apps
       run: |
         cd test
         python3 run-wasi-test.py --fast --exec "./wasm3-lin.com"
     - name: Install Wine64
       run: |
         sudo apt update
         sudo apt install wine64
         wine --version
     - name: Test WebAssembly spec (in Wine)
       run: |
         cd test
         python3 run-spec-test.py --exec "wine ./wasm3-win.com --repl"
     - name: Test WASI apps (in Wine)
       run: |
         cd test
         python3 run-wasi-test.py --fast --exec "wine ./wasm3-win.com"
 
   cross-qemu:
     runs-on: ubuntu-20.04
     name: cross-qemu-${{ matrix.config.target }}
     timeout-minutes: 10
 
     strategy:
       fail-fast: false
       matrix:
         config:
         #- {target: i386,    toolchain: gcc-multilib,              cc: clang -m32,                 qemu: qemu-i386-static    }
         - {target: arm,     toolchain: gcc-arm-linux-gnueabi,     cc: arm-linux-gnueabi-gcc,      qemu: qemu-arm-static     }
         - {target: armhf,   toolchain: gcc-arm-linux-gnueabihf,   cc: arm-linux-gnueabihf-gcc,    qemu: qemu-arm-static     }
         - {target: aarch64, toolchain: gcc-aarch64-linux-gnu,     cc: aarch64-linux-gnu-gcc,      qemu: qemu-aarch64-static }
         - {target: riscv64, toolchain: gcc-riscv64-linux-gnu,     cc: riscv64-linux-gnu-gcc,      qemu: qemu-riscv64-static }
         - {target: ppc,     toolchain: gcc-powerpc-linux-gnu,     cc: powerpc-linux-gnu-gcc,      qemu: qemu-ppc-static     }
         - {target: ppc64,   toolchain: gcc-powerpc64-linux-gnu,   cc: powerpc64-linux-gnu-gcc,    qemu: qemu-ppc64-static   }
         #- {target: ppc64le, toolchain: gcc-powerpc64le-linux-gnu, cc: powerpc64le-linux-gnu-gcc,  qemu: qemu-ppc64le-static }
         - {target: s390x,   toolchain: gcc-s390x-linux-gnu,       cc: s390x-linux-gnu-gcc,        qemu: qemu-s390x-static   }
         - {target: mips,    toolchain: gcc-mips-linux-gnu,          cc: mips-linux-gnu-gcc,         qemu: qemu-mips-static     }
         - {target: mips64,  toolchain: gcc-mips64-linux-gnuabi64,   cc: mips64-linux-gnuabi64-gcc,  qemu: qemu-mips64-static   }
         - {target: mipsel,  toolchain: gcc-mipsel-linux-gnu,        cc: mipsel-linux-gnu-gcc,       qemu: qemu-mipsel-static   }
         - {target: mips64el,toolchain: gcc-mips64el-linux-gnuabi64, cc: mips64el-linux-gnuabi64-gcc,qemu: qemu-mips64el-static }
         - {target: alpha,   toolchain: gcc-alpha-linux-gnu,       cc: alpha-linux-gnu-gcc,        qemu: qemu-alpha-static   }
         - {target: sparc64, toolchain: gcc-sparc64-linux-gnu,     cc: sparc64-linux-gnu-gcc,      qemu: qemu-sparc64-static, skip_wasi: true }
 
         #- {target: i386 (u64 slots),    toolchain: gcc-multilib,              cc: clang -m32,                 qemu: qemu-i386-static,     cflags: -Dd_m3Use32BitSlots=0  }
         - {target: arm (u64 slots),     toolchain: gcc-arm-linux-gnueabi,     cc: arm-linux-gnueabi-gcc,      qemu: qemu-arm-static,      cflags: -Dd_m3Use32BitSlots=0  }
         - {target: aarch64 (u64 slots), toolchain: gcc-aarch64-linux-gnu,     cc: aarch64-linux-gnu-gcc,      qemu: qemu-aarch64-static,  cflags: -Dd_m3Use32BitSlots=0  }
         - {target: ppc (u64 slots),     toolchain: gcc-powerpc-linux-gnu,     cc: powerpc-linux-gnu-gcc,      qemu: qemu-ppc-static,      cflags: -Dd_m3Use32BitSlots=0  }
         - {target: ppc64 (u64 slots),   toolchain: gcc-powerpc64-linux-gnu,   cc: powerpc64-linux-gnu-gcc,    qemu: qemu-ppc64-static,    cflags: -Dd_m3Use32BitSlots=0  }
 
     steps:
     - uses: actions/checkout@v2
     - name: Install QEMU
       run: |
         sudo apt update
         sudo apt install qemu-user-static
     - name: Install ${{ matrix.config.toolchain }}
       run: |
         sudo apt install ${{ matrix.config.toolchain }}
     - name: Build
       run: |
         mkdir build
         cd build
         ${{ matrix.config.cc }} -DASSERTS -Dd_m3HasWASI ${{ matrix.config.cflags }} \
             -I../source ../source/*.c ../platforms/app/main.c \
             -O3 -g0 -flto -lm -static \
             -o wasm3
     - name: Test WebAssembly spec
       run: |
         cd test
         python3 run-spec-test.py --exec "${{ matrix.config.qemu }} ../build/wasm3 --repl"
     - name: Test WASI apps
       if: ${{ !matrix.config.skip_wasi }}
       run: |
         cd test
         python3 run-wasi-test.py --fast --exec "${{ matrix.config.qemu }} ../build/wasm3"
 
   platformio:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Set up Python
       uses: actions/setup-python@v2
       with:
         python-version: '3.x'
     - name: Install PlatformIO
       run: |
         python -m pip install --upgrade pip
         pip install -U platformio
     - name: Build AVR ATmega1284
       run: |
         cd platforms/embedded/arduino
         pio run -e mega1284
         ! nm .pio/build/mega1284/firmware.elf | grep printf
     - name: Build ESP8266
       run: |
         cd platforms/embedded/esp8266
         pio run
     # TODO:
     #- name: Build ESP32
     #  run: |
     #    cd platforms/embedded/esp32-pio
     #    pio run
 
   platformio-arm:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Set up Python
       uses: actions/setup-python@v2
       with:
         python-version: '3.x'
     - name: Install PlatformIO
       run: |
         python -m pip install --upgrade pip
         pip install -U platformio
     - name: Build Arduino MKR1000
       run: |
         cd platforms/embedded/arduino
         pio run -e mkr1000
     - name: Build Blue Pill (JeeH)
       run: |
         cd platforms/embedded/bluepill
         pio run
     - name: Build TinyBLE
       run: |
         cd platforms/embedded/arduino
         pio run -e tinyBLE
     - name: Build MXChip AZ3166
       run: |
         cd platforms/embedded/arduino
         pio run -e az3166
 
   platformio-riscv:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Set up Python
       uses: actions/setup-python@v2
       with:
         python-version: '3.x'
     - name: Install PlatformIO
       run: |
         python -m pip install --upgrade pip
         pip install -U platformio
     - name: Build HiFive1
       run: |
         cd platforms/embedded/hifive1
         pio run
     - name: Build Sipeed MAIX
       run: |
         cd platforms/embedded/arduino
         pio run -e maix
 
   particle:
     runs-on: ubuntu-latest
     timeout-minutes: 10
     if: "github.event_name == 'push'"
 
     steps:
     - uses: actions/checkout@v2
     - name: Set up Particle CLI
       run: sudo npm install -g particle-cli
     - name: Log in
       env:
         PARTICLE_TOKEN: ${{ secrets.PARTICLE_TOKEN }}
       run: particle login --token $PARTICLE_TOKEN
     - name: Build Photon
       run: |
         cd platforms/embedded/particle
         particle compile --followSymlinks photon
         particle compile --followSymlinks argon
 
   esp32-idf:
     runs-on: ubuntu-latest
     container: igrr/idf-qemu:release-v4.0-esp-develop-20191228
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Build for ESP32 (IDF v4.0)
       run: |
         . $IDF_PATH/export.sh
         cd platforms/embedded/esp32-idf
         export EXTRA_CFLAGS="-Werror"
         idf.py build
       shell: bash
     - name: Test for ESP32 in QEMU
       run: |
         cd platforms/embedded/esp32-idf
         make-flash-img.sh wasm3 flash_img.bin
         qemu-system-xtensa -machine esp32 -nographic -drive file=flash_img.bin,if=mtd,format=raw -no-reboot | tee out.txt
         grep "Result: 46368" out.txt
         grep "Elapsed: " out.txt
         grep "Restarting..." out.txt
         test $(($(grep "ets Jun  8 2016" out.txt | wc -l))) -eq 1
     - name: Check that IDF and PIO examples are in sync
       run: |
         diff -q platforms/embedded/esp32-idf/main/main.cpp platforms/embedded/esp32-pio/src/main.cpp
       # TODO: also check that the build flags are in sync
 
   cpp:
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
       - uses: actions/checkout@v2
       - name: Configure
         run: |
           cd platforms/cpp
           mkdir build
           cd build
           cmake ..
       - name: Build
         run: |
           cd platforms/cpp
           cmake --build build
       - name: Run
         run: |
           cd platforms/cpp/build
           ./wasm3_cpp_example
 
   as-cpp:
     name: maintenance (build as C++)
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Build
       run: |
         mkdir build
         cd build
         clang -xc++ -Dd_m3HasWASI \
             -I../source ../source/*.c ../platforms/app/main.c \
             -O3 -g0 -lm \
             -o wasm3
     - name: Test
       run: ./build/wasm3 ./test/wasi/simple/test.wasm
 
   with-logs:
     name: maintenance (debug logs)
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Build
       run: |
         mkdir build
         cd build
         clang -xc++ -Dd_m3HasWASI -DDEBUG \
             -Dd_m3EnableOpTracing=1     \
             -Dd_m3EnableStrace=1        \
             -Dd_m3LogParse=1            \
             -Dd_m3LogModule=1           \
             -Dd_m3LogCompile=1          \
             -Dd_m3LogWasmStack=1        \
             -Dd_m3LogEmit=1             \
             -Dd_m3LogCodePages=1        \
             -Dd_m3LogRuntime=1          \
             -Dd_m3LogNativeStack=1      \
             -I../source ../source/*.c ../platforms/app/main.c \
             -O3 -g0 -lm \
             -o wasm3
     - name: Test
       run: ./build/wasm3 ./test/wasi/simple/test.wasm > /dev/null
 
   preprocessed-ops:
     name: maintenance (preprocess ops)
     runs-on: ubuntu-latest
     timeout-minutes: 10
 
     steps:
     - uses: actions/checkout@v2
     - name: Install sponge
       run: |
         sudo apt update
         sudo apt install moreutils
     - name: Build
       run: |
         make -f extra/utils.mk preprocess
         mkdir build
         cd build
         gcc -Dd_m3HasWASI \
             -I../source ../source/*.c ../platforms/app/main.c \
             -O3 -g0 -lm \
             -o wasm3
     - name: Test
       run: ./build/wasm3 ./test/wasi/simple/test.wasm
 
   spellcheck:
     runs-on: ubuntu-latest
     steps:
     - name: Set up Python
       uses: actions/setup-python@v2
     - name: Install codespell
       run: |
         pip install codespell
     - name: Spellcheck
       run: |
         codespell
diff --git a/CMakeLists.txt b/CMakeLists.txt
index bba1561..f20ecb2 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -128,26 +128,26 @@ elseif(WASIENV)
   #-flto -Wl,--lto-O3
   set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-z,stack-size=8388608")
 
-elseif(WIN32 AND NOT MINGW)
+elseif(MSVC OR CMAKE_C_COMPILER_FRONTEND_VARIANT MATCHES "MSVC")
 
   set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Dd_m3HasTracer -D_CRT_SECURE_NO_WARNINGS /WX- /diagnostics:column")
 
   string(REGEX REPLACE "/W[0-4]" "/W0" CMAKE_C_FLAGS "${CMAKE_C_FLAGS}")
 
   if (CMAKE_C_COMPILER_ID MATCHES "MSVC")
 
     if("${CMAKE_SIZEOF_VOID_P}" STREQUAL "4")
       set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /d2noftol3")
     endif()
 
     set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} /Oxs /Oy /GS- /Zi /Zo /arch:AVX2")
 
     # Uncomment this if you want to disassemble the release build,
     # for example: dumpbin /DISASM wasm3.exe /out:wasm3.S
     #set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /DEBUG:FULL")
 
   else()
     set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} /Oxs /Oy /GS- /Qvec -Clang -O3")
   endif()
 
   set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /STACK:8388608") # stack size
diff --git a/README.md b/README.md
index ca6a522..edc60dc 100644
--- a/README.md
+++ b/README.md
@@ -86,31 +86,31 @@ In many situations, speed is not the main concern. Runtime executable size, memo
 Wasm3 started as a research project and remains so by many means. Evaluating the engine in different environments is part of the research. Given that we have `Lua`, `JS`, `Python`, `Lisp`, `...` running on MCUs, `WebAssembly` is actually a promising alternative. It provides toolchain decoupling as well as a completely sandboxed, well-defined, predictable environment. Among practical use cases we can list `edge computing`, `scripting`, `plugin systems`, running `IoT rules`, `smart contracts`, etc.
 
 ## Used by
 
 [<img src="https://wasmcloud.dev/images/logo.png" height="32" />](https://wasmcloud.dev)　
 [<img src="/extra/logos/wowcube.png" height="32" />](https://wowcube.com)　
 [<img src="/extra/logos/scailable.png" height="32" />](https://scailable.net)　
 [<img src="/extra/logos/blynk.png" height="32" />](https://blynk.io)　
 [<img src="/extra/logos/iden3.svg" height="32" />](https://www.iden3.io)　
-[<img src="/extra/logos/losant.png" height="32" />](https://github.com/Losant/eea-examples)　
+[<img src="/extra/logos/losant.png" height="28" />](https://github.com/Losant/eea-examples)　
 [<img src="https://user-images.githubusercontent.com/1506708/114701856-069ce700-9d2c-11eb-9b72-9ce2dfd9f0fb.png" height="32" />](https://github.com/kateinoigakukun/wasmic-ios)　
 [<img src="https://www.balena.io/avatar.png" height="32" />](https://github.com/balena-io-playground/balena-wasm3)　
 [<img src="https://krustlet.dev/images/horizontal.svg" height="32" />](https://github.com/deislabs/krustlet-wasm3)　
 [<img src="/extra/logos/shareup_app.svg" height="24" />](https://shareup.app/blog/introducing-shareup)　
 [<img src="https://wasm4.org/img/logo.png" height="32" />](https://wasm4.org)
 
 ## Further Resources
 
 [Demos](./docs/Demos.md)  
 [Installation instructions](./docs/Installation.md)  
 [Cookbook](./docs/Cookbook.md)  
 [Troubleshooting](./docs/Troubleshooting.md)  
 [Build and Development instructions](./docs/Development.md)  
 [Supported Hardware](./docs/Hardware.md)  
 [Testing & Fuzzing](./docs/Testing.md)  
 [Performance](./docs/Performance.md)  
 [Interpreter Architecture](./docs/Interpreter.md)  
 [Logging](./docs/Diagnostics.md)  
 [Awesome WebAssembly Tools](https://github.com/vshymanskyy/awesome-wasm-tools/blob/main/README.md)
 
 ### License
diff --git a/docs/Demos.md b/docs/Demos.md
index d982c1b..cbba624 100644
--- a/docs/Demos.md
+++ b/docs/Demos.md
@@ -1,17 +1,17 @@
 # Wasm3 demos
 
 - **In-browser Wasm3 (with MetaWASI support) on Webassembly.sh** │ [try it](https://webassembly.sh/?run-command=wasm3)
 - **PyGame + pywasm3 examples** | [github](https://github.com/wasm3/pywasm3/tree/main/examples)
 - **DOOM compiled to WASI, running on pywasm3** |  [video](https://twitter.com/wasm3_engine/status/1393588527863144450), [github](https://github.com/wasm3/pywasm3-doom-demo)
 - **WebAssembly On Your Nintendo DS** |  [blog](https://softwayre.com/blog/2021/09/13/webassembly-on-your-nintendo-ds), [github](https://github.com/moxon6/snake-assemblyscript-ds)
 - **Each pixel on this ESP32 board is controlled by a different WebAssembly app** |  [video](https://twitter.com/zubr_kabbi/status/1436833749359017985), [github](https://github.com/kabbi/m5-atom-wasms)
 - **Wasm3 self-compilation using `clang.wasm`** |  [github](https://github.com/wasm3/wasm3-self-compiling)
 - **Dino game**
   - on PyBadge/Arduino | [video](https://twitter.com/vshymanskyy/status/1345048053041029121), [github](https://github.com/wasm3/wasm3-arduino/tree/main/examples/Wasm_Dino_PyBadge)
   - on Raspberry Pi Pico | [github](https://github.com/vshymanskyy/wasm3_dino_rpi_pico)
   - on ESP32 TTGO TDisplay | [github](https://github.com/wasm3/wasm3-arduino/tree/main/examples/Wasm_Dino_ESP32_TDisplay)
 - **Basic WiFi/Gpio access, updating `wasm` file over-the-air** │ [video](https://twitter.com/alvaroviebrantz/status/1221618910803513344), [github](https://github.com/alvarowolfx/wasm-arduino-wifi) [ESP32 / Web] 
 - **RGB lamp animation using WebAssembly** │ [video](https://twitter.com/wasm3_engine/status/1222835097289752576), [github](https://github.com/vshymanskyy/Wasm3_RGB_Lamp) [nRF51 / nRF52 / ESP8266 / ESP32]
 - **LCD display rendering with AssemblyScript** │ [video](https://twitter.com/h1romas4/status/1228581467850100736), [github](https://github.com/h1romas4/m5stack-wasm3-testing) [M5Stack / ESP32]
 - **Conway's Game Of Life with AssemblyScript** │ [video](https://www.youtube.com/watch?v=Hc2sbhGMrig), [github](https://github.com/h1romas4/maixduino-wasm3-testing) [Maixduino / K210]
-
+- **Losant Embedded Edge Agent** | [Python](https://github.com/Losant/eea-examples/tree/main/python), [ESP32](https://github.com/Losant/eea-examples/tree/main/esp32)
diff --git a/platforms/cpp/wasm3_cpp/include/wasm3_cpp.h b/platforms/cpp/wasm3_cpp/include/wasm3_cpp.h
index c12a127..2bdf51a 100644
--- a/platforms/cpp/wasm3_cpp/include/wasm3_cpp.h
+++ b/platforms/cpp/wasm3_cpp/include/wasm3_cpp.h
@@ -1,13 +1,14 @@
 #pragma once
 
 #include <tuple>
 #include <algorithm>
 #include <type_traits>
 #include <iostream>
 #include <vector>
+#include <array>
 #include <memory>
 #include <string>
 #include <iterator>
 #include <cassert>
 
 #include "wasm3.h"
@@ -16,397 +17,397 @@
 namespace wasm3 {
     /** @cond */
     namespace detail {
         typedef uint64_t *stack_type;
         typedef void *mem_type;
         template<typename T, typename...> struct first_type { typedef T type; };
 
         typedef const void *(*m3_api_raw_fn)(IM3Runtime, uint64_t *, void *);
 
         template<typename T>
         void arg_from_stack(T &dest, stack_type &_sp, mem_type mem) {
             m3ApiGetArg(T, tmp);
             dest = tmp;
         }
 
         template<typename T>
         void arg_from_stack(T* &dest, stack_type &_sp, mem_type _mem) {
             m3ApiGetArgMem(T*, tmp);
             dest = tmp;
         };
 
         template<typename T>
         void arg_from_stack(const T* &dest, stack_type &_sp, mem_type _mem) {
             m3ApiGetArgMem(const T*, tmp);
             dest = tmp;
         };
 
         template<char c>
         struct m3_sig {
             static const char value = c;
         };
         template<typename T> struct m3_type_to_sig;
         template<> struct m3_type_to_sig<int32_t> : m3_sig<'i'> {};
         template<> struct m3_type_to_sig<int64_t> : m3_sig<'I'> {};
         template<> struct m3_type_to_sig<float>   : m3_sig<'f'> {};
         template<> struct m3_type_to_sig<double>  : m3_sig<'F'> {};
         template<> struct m3_type_to_sig<void>    : m3_sig<'v'> {};
         template<> struct m3_type_to_sig<void *>  : m3_sig<'*'> {};
         template<> struct m3_type_to_sig<const void *> : m3_sig<'*'> {};
 
 
         template<typename Ret, typename ... Args>
         struct m3_signature {
             constexpr static size_t n_args = sizeof...(Args);
             constexpr static const char value[n_args + 4] = {
                     m3_type_to_sig<Ret>::value,
                     '(',
                     m3_type_to_sig<Args>::value...,
                     ')',
                     0
             };
         };
 
         template <typename ...Args>
         static void get_args_from_stack(stack_type &sp, mem_type mem, std::tuple<Args...> &tuple) {
             std::apply([&](auto &... item) {
                 (arg_from_stack(item, sp, mem), ...);
             }, tuple);
         }
 
         template<typename Func>
         struct wrap_helper;
 
         template <typename Ret, typename ...Args>
         struct wrap_helper<Ret(Args...)> {
             using Func = Ret(Args...);
             static const void *wrap_fn(IM3Runtime rt, IM3ImportContext _ctx, stack_type _sp, mem_type mem) {
                 std::tuple<Args...> args;
                 // The order here matters: m3ApiReturnType should go before calling get_args_from_stack,
                 // since both modify `_sp`, and the return value on the stack is reserved before the arguments.
                 m3ApiReturnType(Ret);
                 get_args_from_stack(_sp, mem, args);
                 Func* function = reinterpret_cast<Func*>(_ctx->userdata);
                 Ret r = std::apply(function, args);
                 m3ApiReturn(r);
             }
         };
 
         template <typename ...Args>
         struct wrap_helper<void(Args...)> {
             using Func = void(Args...);
             static const void *wrap_fn(IM3Runtime rt, IM3ImportContext _ctx, stack_type sp, mem_type mem) {
                 std::tuple<Args...> args;
                 get_args_from_stack(sp, mem, args);
                 Func* function = reinterpret_cast<Func*>(_ctx->userdata);
                 std::apply(function, args);
                 m3ApiSuccess();
             }
         };
 
         template<typename Func>
         class m3_wrapper;
 
         template<typename Ret, typename ... Args>
         class m3_wrapper<Ret(Args...)> {
         public:
             static M3Result link(IM3Module io_module,
                                  const char *const i_moduleName,
                                  const char *const i_functionName,
                                  Ret (*function)(Args...)) {
 
                 return m3_LinkRawFunctionEx(io_module, i_moduleName, i_functionName,
                                             m3_signature<Ret, Args...>::value,
                                             &wrap_helper<Ret(Args...)>::wrap_fn,
                                             reinterpret_cast<void*>(function));
             }
         };
     } // namespace detail
     /** @endcond */
 
     class module;
     class runtime;
     class function;
 
     /**
      * Exception thrown for wasm3 errors.
      *
      * Use error:what() to get the reason as a string.
      */
     class error : public std::runtime_error {
     public:
         explicit error(M3Result err) : std::runtime_error(err) {}
     };
 
     /** @cond */
     namespace detail {
         static inline void check_error(M3Result err) {
             if (err != m3Err_none) {
                 throw error(err);
             }
         }
     } // namespace detail
     /** @endcond */
 
 
     /**
      * Wrapper for WASM3 environment.
      *
      * Runtimes, modules are owned by an environment.
      */
     class environment {
     public:
         environment() {
             m_env.reset(m3_NewEnvironment(), m3_FreeEnvironment);
             if (m_env == nullptr) {
                 throw std::bad_alloc();
             }
         }
 
         /**
          * Create new runtime
          *
          * @param stack_size_bytes  size of the WASM stack for this runtime
          * @return runtime object
          */
         runtime new_runtime(size_t stack_size_bytes);
 
         /**
          * Parse a WASM module from file
          *
          * The parsed module is not loaded into any runtime. Use runtime::load to
          * load the module after parsing it.
          *
          * @param in  file (WASM binary)
          * @return module object
          */
         module parse_module(std::istream &in);
 
         /**
          * Parse a WASM module from binary data
          * 
          * @param data  pointer to the start of the binary
          * @param size  size of the binary
          * @return module object
          */
         module parse_module(const uint8_t *data, size_t size);
 
     protected:
         std::shared_ptr<struct M3Environment> m_env;
     };
 
     /**
      * Wrapper for the runtime, where modules are loaded and executed.
      */
     class runtime {
     public:
         /**
          * Load the module into runtime
          * @param mod  module parsed by environment::parse_module
          */
         void load(module &mod);
 
         /**
          * Get a function handle by name
          * 
          * If the function is not found, throws an exception.
          * @param name  name of a function, c-string
          * @return function object
          */
         function find_function(const char *name);
 
     protected:
         friend class environment;
 
         runtime(const std::shared_ptr<M3Environment> &env, size_t stack_size_bytes)
                 : m_env(env) {
             m_runtime.reset(m3_NewRuntime(env.get(), stack_size_bytes, nullptr), &m3_FreeRuntime);
             if (m_runtime == nullptr) {
                 throw std::bad_alloc();
             }
         }
 
         /* runtime extends the lifetime of the environment */
         std::shared_ptr<M3Environment> m_env;
         std::shared_ptr<M3Runtime> m_runtime;
     };
 
     /**
      * Module object holds a webassembly module
      *
      * It can be constructed by parsing a WASM binary using environment::parse_module.
      * Functions can be linked to the loaded module.
      * Once constructed, modules can be loaded into the runtime.
      */
     class module {
     public:
         /**
          * Link an external function.
          *
          * Throws an exception if the module doesn't reference a function with the given name.
          *
          * @tparam Func Function type (signature)
          * @param module  Name of the module to link the function to, or "*" to link to any module
          * @param function_name  Name of the function (as referenced by the module)
          * @param function  Function to link (a function pointer)
          */
         template<typename Func>
         void link(const char *module, const char *function_name, Func *function);
 
         /**
          * Same as module::link, but doesn't throw an exception if the function is not referenced.
          */
         template<typename Func>
         void link_optional(const char *module, const char *function_name, Func *function);
 
 
     protected:
         friend class environment;
         friend class runtime;
 
         module(const std::shared_ptr<M3Environment> &env, std::istream &in_wasm) {
             in_wasm.unsetf(std::ios::skipws);
             std::copy(std::istream_iterator<uint8_t>(in_wasm),
                       std::istream_iterator<uint8_t>(),
                       std::back_inserter(m_moduleRawData));
             parse(env.get(), m_moduleRawData.data(), m_moduleRawData.size());
         }
 
         module(const std::shared_ptr<M3Environment> &env, const uint8_t *data, size_t size) : m_env(env) {
             m_moduleRawData = std::vector<uint8_t>{data, data + size};
             parse(env.get(), m_moduleRawData.data(), m_moduleRawData.size());
         }
 
         void parse(IM3Environment env, const uint8_t *data, size_t size) {
             IM3Module p;
             M3Result err = m3_ParseModule(env, &p, data, size);
             detail::check_error(err);
             m_module.reset(p, [this](IM3Module module) {
                 if (!m_loaded) {
                     m3_FreeModule(module);
                 }
             });
         }
 
         void load_into(IM3Runtime runtime) {
             M3Result err = m3_LoadModule(runtime, m_module.get());
             detail::check_error(err);
             m_loaded = true;
         }
 
         std::shared_ptr<M3Environment> m_env;
         std::shared_ptr<M3Module> m_module;
         bool m_loaded = false;
         std::vector<uint8_t> m_moduleRawData {};
     };
 
 
     /**
      * Handle of a function. Can be obtained from runtime::find_function method by name.
      */
     class function {
     public:
         /**
          * Call the function with the provided arguments, expressed as strings.
          *
          * Arguments are passed as strings. WASM3 automatically converts them into the types expected
          * by the function being called.
          *
          * Note that the type of the return value must be explicitly specified as a template argument.
          *
          * @return the return value of the function.
          */
         template<typename Ret, typename ... Args>
         typename detail::first_type<Ret,
                 typename std::enable_if<std::is_convertible<Args, const char*>::value>::type...>::type
         call_argv(Args... args) {
             /* std::enable_if above checks that all argument types are convertible const char* */
             const char* argv[] = {args...};
             M3Result res = m3_CallArgv(m_func, sizeof...(args), argv);
             detail::check_error(res);
             Ret ret;
             res = m3_GetResults(m_func, 1, &ret);
             detail::check_error(res);
             return ret;
         }
 
         template<typename ... Args>
         typename detail::first_type<void, 
                 typename std::enable_if<std::is_convertible<Args, const char*>::value>::type...>::type
         call_argv(Args... args) {
             /* std::enable_if above checks that all argument types are convertible const char* */
             const char* argv[] = {args...};
             M3Result res = m3_CallArgv(m_func, sizeof...(args), argv);
             detail::check_error(res);
         }
 
         /**
          * Call the function with the provided arguments (int/float types).
          *
          * Note that the type of the return value must be explicitly specified as a template argument.
          *
          * @return the return value of the function or void.
          */
         template<typename Ret = void, typename ... Args>
         Ret call(Args... args) {
-            const void *arg_ptrs[] = { reinterpret_cast<const void*>(&args)... };
-            M3Result res = m3_Call(m_func, sizeof...(args), arg_ptrs);
+            std::array<const void*, sizeof...(args)> arg_ptrs{ reinterpret_cast<const void*>(&args)... };
+            M3Result res = m3_Call(m_func, arg_ptrs.size(), arg_ptrs.data());
             detail::check_error(res);
 
             if constexpr (!std::is_void<Ret>::value) {
                 Ret ret;
                 const void* ret_ptrs[] = { &ret };
                 res = m3_GetResults(m_func, 1, ret_ptrs);
                 detail::check_error(res);
                 return ret; 
             }
         }
 
     protected:
         friend class runtime;
 
         function(const std::shared_ptr<M3Runtime> &runtime, const char *name) : m_runtime(runtime) {
             M3Result err = m3_FindFunction(&m_func, runtime.get(), name);
             detail::check_error(err);
             assert(m_func != nullptr);
         }
 
         std::shared_ptr<M3Runtime> m_runtime;
         M3Function *m_func = nullptr;
     };
 
     inline runtime environment::new_runtime(size_t stack_size_bytes) {
         return runtime(m_env, stack_size_bytes);
     }
 
     inline module environment::parse_module(std::istream &in) {
         return module(m_env, in);
     }
 
     inline module environment::parse_module(const uint8_t *data, size_t size) {
         return module(m_env, data, size);
     }
 
     inline void runtime::load(module &mod) {
         mod.load_into(m_runtime.get());
     }
 
     inline function runtime::find_function(const char *name) {
         return function(m_runtime, name);
     }
 
     template<typename Func>
     void module::link(const char *module, const char *function_name, Func *function) {
         M3Result ret = detail::m3_wrapper<Func>::link(m_module.get(), module, function_name, function);
         detail::check_error(ret);
     }
 
     template<typename Func>
     void module::link_optional(const char *module, const char *function_name, Func *function) {
         M3Result ret = detail::m3_wrapper<Func>::link(m_module.get(), module, function_name, function);
         if (ret == m3Err_functionLookupFailed) {
             return;
         }
         detail::check_error(ret);
     }
 
 } // namespace wasm3
diff --git a/source/m3_code.c b/source/m3_code.c
index a5dd5d3..b399b82 100644
--- a/source/m3_code.c
+++ b/source/m3_code.c
@@ -1,11 +1,12 @@
 //
 //  m3_code.c
 //
 //  Created by Steven Massey on 4/19/19.
 //  Copyright © 2019 Steven Massey. All rights reserved.
 //
 
+#include <limits.h>
 #include "m3_code.h"
 #include "m3_env.h"
 
 //---------------------------------------------------------------------------------------------------------------------------------
@@ -14,36 +15,50 @@
 IM3CodePage  NewCodePage  (IM3Runtime i_runtime, u32 i_minNumLines)
 {
     IM3CodePage page;
 
+    // check multiplication overflow
+    if (i_minNumLines > UINT_MAX / sizeof (code_t)) {
+        return NULL;
+    }
     u32 pageSize = sizeof (M3CodePageHeader) + sizeof (code_t) * i_minNumLines;
 
+    // check addition overflow
+    if (pageSize < sizeof (M3CodePageHeader)) {
+        return NULL;
+    }
+
     pageSize = (pageSize + (d_m3CodePageAlignSize-1)) & ~(d_m3CodePageAlignSize-1); // align
+    // check alignment overflow
+    if (pageSize == 0) {
+        return NULL;
+    }
+
     page = (IM3CodePage)m3_Malloc ("M3CodePage", pageSize);
 
     if (page)
     {
         page->info.sequence = ++i_runtime->newCodePageSequence;
         page->info.numLines = (pageSize - sizeof (M3CodePageHeader)) / sizeof (code_t);
 
 #if d_m3RecordBacktraces
         u32 pageSizeBt = sizeof (M3CodeMappingPage) + sizeof (M3CodeMapEntry) * page->info.numLines;
         page->info.mapping = (M3CodeMappingPage *)m3_Malloc ("M3CodeMappingPage", pageSizeBt);
 
         if (page->info.mapping)
         {
             page->info.mapping->size = 0;
             page->info.mapping->capacity = page->info.numLines;
         }
         else
         {
             m3_Free (page);
             return NULL;
         }
         page->info.mapping->basePC = GetPageStartPC(page);
 #endif // d_m3RecordBacktraces
 
         m3log (runtime, "new page: %p; seq: %d; bytes: %d; lines: %d", GetPagePC (page), page->info.sequence, pageSize, page->info.numLines);
     }
 
     return page;
 }
diff --git a/source/m3_compile.c b/source/m3_compile.c
index 8a93330..3fa533a 100644
--- a/source/m3_compile.c
+++ b/source/m3_compile.c
@@ -322,11 +322,8 @@ u16  GetExtraSlotForStackIndex  (IM3Compilation o, u16 i_stackIndex)
 static inline
 void  TouchSlot  (IM3Compilation o, u16 i_slot)
 {
-    if (o->function)
-    {
-        // op_Entry uses this value to track and detect stack overflow
-        o->maxStackSlots = M3_MAX (o->maxStackSlots, i_slot + 1);
-    }
+    // op_Entry uses this value to track and detect stack overflow
+    o->maxStackSlots = M3_MAX (o->maxStackSlots, i_slot + 1);
 }
 
 static inline
@@ -1343,7 +1340,7 @@ M3Result  Compile_GetGlobal  (IM3Compilation o, M3Global * i_global)
 
     IM3Operation op = Is64BitType (i_global->type) ? op_GetGlobal_s64 : op_GetGlobal_s32;
 _   (EmitOp (o, op));
-    EmitPointer (o, & i_global->intValue);
+    EmitPointer (o, & i_global->i64Value);
 _   (PushAllocatedSlotAndEmit (o, i_global->type));
 
     _catch: return result;
@@ -1366,7 +1363,7 @@ M3Result  Compile_SetGlobal  (IM3Compilation o, M3Global * i_global)
         else op = Is64BitType (type) ? op_SetGlobal_s64 : op_SetGlobal_s32;
 
 _      (EmitOp (o, op));
-        EmitPointer (o, & i_global->intValue);
+        EmitPointer (o, & i_global->i64Value);
 
         if (IsStackTopInSlot (o))
             EmitSlotOffset (o, GetStackTopSlotNumber (o));
@@ -1900,26 +1897,25 @@ _   (CompileBlock (o, blockType, i_opcode));
 static
 M3Result  CompileElseBlock  (IM3Compilation o, pc_t * o_startPC, IM3FuncType i_blockType)
 {
+    IM3CodePage savedPage = o->page;
 _try {
 
     IM3CodePage elsePage;
 _   (AcquireCompilationCodePage (o, & elsePage));
 
     * o_startPC = GetPagePC (elsePage);
 
-    IM3CodePage savedPage = o->page;
     o->page = elsePage;
 
 _   (CompileBlock (o, i_blockType, c_waOp_else));
 
 _   (EmitOp (o, op_Branch));
     EmitPointer (o, GetPagePC (savedPage));
-
-    ReleaseCompilationCodePage (o);
-
-    o->page = savedPage;
-
 } _catch:
+    if(o->page != savedPage) {
+        ReleaseCompilationCodePage (o);
+    }
+    o->page = savedPage;
     return result;
 }
 
@@ -2697,41 +2693,47 @@ _try {
     if (i_blockOpcode != c_waOp_else)
     {
         for (u16 i = 0; i < numParams; ++i)
         {
             u8 type = GetFuncTypeParamType (i_blockType, numParams - 1 - i);
 _           (PopType (o, type));
         }
     }
-    else o->stackIndex -= numParams;
+    else {
+        if (IsStackPolymorphic (o) && o->block.blockStackIndex + numParams > o->stackIndex) {
+            o->stackIndex = o->block.blockStackIndex;
+        } else {
+            o->stackIndex -= numParams;
+        }
+    }
 
     u16 paramIndex = o->stackIndex;
     block->exitStackIndex = paramIndex; // consume the params at block exit
 
     // keep copies of param slots in the stack
     o->stackIndex = stackIndex;
 
     // find slots for the results ----------------------------
     PushBlockResults (o);
 
     stackIndex = o->stackIndex;
 
     // dealloc but keep record of the result slots in the stack
     u16 numResults = GetFuncTypeNumResults (i_blockType);
     while (numResults--)
         Pop (o);
 
     block->blockStackIndex = o->stackIndex = stackIndex;
 
     // push the params back onto the stack -------------------
     for (u16 i = 0; i < numParams; ++i)
     {
         u8 type = GetFuncTypeParamType (i_blockType, i);
 
         u16 slot = GetSlotForStackIndex (o, paramIndex + i);
         Push (o, type, slot);
 
-        if (slot >= o->slotFirstDynamicIndex)
+        if (slot >= o->slotFirstDynamicIndex && slot != c_slotUnused)
             MarkSlotsAllocatedByType (o, slot, type);
     }
 
     //--------------------------------------------------------
diff --git a/source/m3_env.c b/source/m3_env.c
index 2bb8657..82a198d 100644
--- a/source/m3_env.c
+++ b/source/m3_env.c
@@ -407,39 +407,40 @@ M3Result  ResizeMemory  (IM3Runtime io_runtime, u32 i_numPages)
 M3Result  InitGlobals  (IM3Module io_module)
 {
     M3Result result = m3Err_none;
 
     if (io_module->numGlobals)
     {
         // placing the globals in their structs isn't good for cache locality, but i don't really know what the global
         // access patterns typically look like yet.
 
         //          io_module->globalMemory = m3Alloc (m3reg_t, io_module->numGlobals);
 
         //          if (io_module->globalMemory)
         {
             for (u32 i = 0; i < io_module->numGlobals; ++i)
             {
                 M3Global * g = & io_module->globals [i];                        m3log (runtime, "initializing global: %d", i);
 
                 if (g->initExpr)
                 {
                     bytes_t start = g->initExpr;
-                    result = EvaluateExpression (io_module, & g->intValue, g->type, & start, g->initExpr + g->initExprSize);
+
+                    result = EvaluateExpression (io_module, & g->i64Value, g->type, & start, g->initExpr + g->initExprSize);
 
                     if (not result)
                     {
                         // io_module->globalMemory [i] = initValue;
                     }
                     else break;
                 }
                 else
                 {                                                               m3log (runtime, "importing global");
 
                 }
             }
         }
         //          else result = ErrorModule (m3Err_mallocFailed, io_module, "could allocate globals for module: '%s", io_module->name);
     }
 
     return result;
 }
@@ -645,18 +646,18 @@ IM3Global  m3_FindGlobal  (IM3Module               io_module,
 M3Result  m3_GetGlobal  (IM3Global                 i_global,
                          IM3TaggedValue            o_value)
 {
     if (not i_global) return m3Err_globalLookupFailed;
 
     switch (i_global->type) {
-    case c_m3Type_i32: o_value->value.i32 = i_global->intValue; break;
-    case c_m3Type_i64: o_value->value.i64 = i_global->intValue; break;
+    case c_m3Type_i32: o_value->value.i32 = i_global->i32Value; break;
+    case c_m3Type_i64: o_value->value.i64 = i_global->i64Value; break;
 # if d_m3HasFloat
     case c_m3Type_f32: o_value->value.f32 = i_global->f32Value; break;
     case c_m3Type_f64: o_value->value.f64 = i_global->f64Value; break;
 # endif
     default: return m3Err_invalidTypeId;
     }
 
     o_value->type = (M3ValueType)(i_global->type);
     return m3Err_none;
 }
@@ -664,20 +665,20 @@ M3Result  m3_GetGlobal  (IM3Global                 i_global,
 M3Result  m3_SetGlobal  (IM3Global                 i_global,
                          const IM3TaggedValue      i_value)
 {
     if (not i_global) return m3Err_globalLookupFailed;
     // TODO: if (not g->isMutable) return m3Err_globalNotMutable;
 
     if (i_global->type != i_value->type) return m3Err_globalTypeMismatch;
 
     switch (i_value->type) {
-    case c_m3Type_i32: i_global->intValue = i_value->value.i32; break;
-    case c_m3Type_i64: i_global->intValue = i_value->value.i64; break;
+    case c_m3Type_i32: i_global->i32Value = i_value->value.i32; break;
+    case c_m3Type_i64: i_global->i64Value = i_value->value.i64; break;
 # if d_m3HasFloat
     case c_m3Type_f32: i_global->f32Value = i_value->value.f32; break;
     case c_m3Type_f64: i_global->f64Value = i_value->value.f64; break;
 # endif
     default: return m3Err_invalidTypeId;
     }
 
     return m3Err_none;
 }
diff --git a/source/m3_env.h b/source/m3_env.h
index 970eb30..6183998 100644
--- a/source/m3_env.h
+++ b/source/m3_env.h
@@ -55,20 +55,21 @@ M3DataSegment;
 typedef struct M3Global
 {
     M3ImportInfo            import;
 
     union
     {
-        i64 intValue;
+        i32 i32Value;
+        i64 i64Value;
 #if d_m3HasFloat
         f64 f64Value;
         f32 f32Value;
 #endif
     };
 
     cstr_t                  name;
     bytes_t                 initExpr;       // wasm code
     u32                     initExprSize;
     u8                      type;
     bool                    imported;
     bool                    isMutable;
 }
