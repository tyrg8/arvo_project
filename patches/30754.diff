commit 505514415d345ab14c6c0b04418fdf132da3079b
Merge: fc005f941 0938a0055
Author: Sean Parkinson <sean@wolfssl.com>
Date:   Mon Feb 15 08:20:28 2021 +1000

    Merge pull request #3748 from JacobBarthelmeh/Testing
    
    always check index into certs

diff --git a/src/internal.c b/src/internal.c
index 24797dc54..aacdbfb11 100644
--- a/src/internal.c
+++ b/src/internal.c
@@ -10717,1209 +10717,1209 @@ static int ProcessPeerCertCheckKey(WOLFSSL* ssl, ProcPeerCertArgs* args)
 int ProcessPeerCerts(WOLFSSL* ssl, byte* input, word32* inOutIdx,
                      word32 totalSz)
 {
     int ret = 0;
 #ifdef WOLFSSL_ASYNC_CRYPT
     ProcPeerCertArgs* args = (ProcPeerCertArgs*)ssl->async.args;
     typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
     (void)sizeof(args_test);
 #elif defined(WOLFSSL_NONBLOCK_OCSP)
     ProcPeerCertArgs* args = ssl->nonblockarg;
 #elif defined(WOLFSSL_SMALL_STACK)
     ProcPeerCertArgs* args = NULL;
 #else
     ProcPeerCertArgs  args[1];
 #endif
     byte* subjectHash = NULL;
     int alreadySigner = 0;
 
     WOLFSSL_ENTER("ProcessPeerCerts");
 
 #ifdef WOLFSSL_ASYNC_CRYPT
     ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
     if (ret != WC_NOT_PENDING_E) {
         /* Check for error */
         if (ret < 0)
             goto exit_ppc;
     }
     else
 #elif defined(WOLFSSL_NONBLOCK_OCSP)
     if (args == NULL) {
         args = (ProcPeerCertArgs*)XMALLOC(
             sizeof(ProcPeerCertArgs), ssl->heap, DYNAMIC_TYPE_TMP_BUFFER);
         if (args == NULL) {
             ERROR_OUT(MEMORY_E, exit_ppc);
         }
     }
     if (ssl->nonblockarg == NULL) /* new args */
 #elif defined(WOLFSSL_SMALL_STACK)
     args = (ProcPeerCertArgs*)XMALLOC(
         sizeof(ProcPeerCertArgs), ssl->heap, DYNAMIC_TYPE_TMP_BUFFER);
     if (args == NULL) {
         ERROR_OUT(MEMORY_E, exit_ppc);
     }
 #endif
     {
         /* Reset state */
         ret = 0;
         ssl->options.asyncState = TLS_ASYNC_BEGIN;
         XMEMSET(args, 0, sizeof(ProcPeerCertArgs));
         args->idx = *inOutIdx;
         args->begin = *inOutIdx;
     #ifdef WOLFSSL_ASYNC_CRYPT
         ssl->async.freeArgs = FreeProcPeerCertArgs;
     #elif defined(WOLFSSL_NONBLOCK_OCSP)
         ssl->nonblockarg = args;
     #endif
     }
 
     switch (ssl->options.asyncState)
     {
         case TLS_ASYNC_BEGIN:
         {
             word32 listSz;
 
         #ifdef WOLFSSL_CALLBACKS
             if (ssl->hsInfoOn)
                 AddPacketName(ssl, "Certificate");
             if (ssl->toInfoOn)
                 AddLateName("Certificate", &ssl->timeoutInfo);
         #endif
 
         #ifdef WOLFSSL_TLS13
             if (ssl->options.tls1_3) {
                 byte ctxSz;
 
                 /* Certificate Request Context */
                 if ((args->idx - args->begin) + OPAQUE8_LEN > totalSz)
                     ERROR_OUT(BUFFER_ERROR, exit_ppc);
                 ctxSz = *(input + args->idx);
                 args->idx++;
                 if ((args->idx - args->begin) + ctxSz > totalSz)
                     ERROR_OUT(BUFFER_ERROR, exit_ppc);
             #ifndef NO_WOLFSSL_CLIENT
                 /* Must be empty when received from server. */
                 if (ssl->options.side == WOLFSSL_CLIENT_END) {
                     if (ctxSz != 0) {
                         ERROR_OUT(INVALID_CERT_CTX_E, exit_ppc);
                     }
                 }
             #endif
             #ifndef NO_WOLFSSL_SERVER
                 /* Must contain value sent in request. */
                 if (ssl->options.side == WOLFSSL_SERVER_END) {
                     if (ssl->options.handShakeState != HANDSHAKE_DONE &&
                                                                    ctxSz != 0) {
                         ERROR_OUT(INVALID_CERT_CTX_E, exit_ppc);
                     }
                     else if (ssl->options.handShakeState == HANDSHAKE_DONE) {
                 #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
                          CertReqCtx* curr = ssl->certReqCtx;
                          CertReqCtx* prev = NULL;
                          while (curr != NULL) {
                              if ((ctxSz == curr->len) &&
                                  XMEMCMP(&curr->ctx, input + args->idx, ctxSz)
                                                                          == 0) {
                                      if (prev != NULL)
                                          prev->next = curr->next;
                                      else
                                          ssl->certReqCtx = curr->next;
                                      XFREE(curr, ssl->heap,
                                            DYNAMIC_TYPE_TMP_BUFFER);
                                      break;
                              }
                              prev = curr;
                              curr = curr->next;
                         }
                         if (curr == NULL)
                 #endif
                             ERROR_OUT(INVALID_CERT_CTX_E, exit_ppc);
                     }
                 }
             #endif
                 args->idx += ctxSz;
 
             #ifdef OPENSSL_EXTRA
                 /* allocate buffer for cert extensions */
                 args->exts = (buffer*)XMALLOC(sizeof(buffer) *
                      (ssl->verifyDepth + 1), ssl->heap, DYNAMIC_TYPE_CERT_EXT);
                 if (args->exts == NULL) {
                     ERROR_OUT(MEMORY_E, exit_ppc);
                 }
             #else
                 /* allocate buffer for cert extensions */
                 args->exts = (buffer*)XMALLOC(sizeof(buffer) * MAX_CHAIN_DEPTH,
                                             ssl->heap, DYNAMIC_TYPE_CERT_EXT);
                 if (args->exts == NULL) {
                     ERROR_OUT(MEMORY_E, exit_ppc);
                 }
             #endif
             }
         #endif
 
             /* allocate buffer for certs */
-        #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
-            args->certs = (buffer*)XMALLOC(sizeof(buffer) *
-                    (ssl->verifyDepth + 1), ssl->heap, DYNAMIC_TYPE_DER);
-            if (args->certs == NULL) {
-                ERROR_OUT(MEMORY_E, exit_ppc);
-            }
-            XMEMSET(args->certs, 0, sizeof(buffer) * (ssl->verifyDepth + 1));
-        #else
             args->certs = (buffer*)XMALLOC(sizeof(buffer) * MAX_CHAIN_DEPTH,
                                             ssl->heap, DYNAMIC_TYPE_DER);
             if (args->certs == NULL) {
                 ERROR_OUT(MEMORY_E, exit_ppc);
             }
             XMEMSET(args->certs, 0, sizeof(buffer) * MAX_CHAIN_DEPTH);
-        #endif /* OPENSSL_EXTRA */
 
             /* Certificate List */
             if ((args->idx - args->begin) + OPAQUE24_LEN > totalSz) {
                 ERROR_OUT(BUFFER_ERROR, exit_ppc);
             }
             c24to32(input + args->idx, &listSz);
             args->idx += OPAQUE24_LEN;
             if (listSz > MAX_CERTIFICATE_SZ) {
                 ERROR_OUT(BUFFER_ERROR, exit_ppc);
             }
             if ((args->idx - args->begin) + listSz != totalSz) {
                 ERROR_OUT(BUFFER_ERROR, exit_ppc);
             }
 
             WOLFSSL_MSG("Loading peer's cert chain");
             /* first put cert chain into buffer so can verify top down
                we're sent bottom up */
             while (listSz) {
                 word32 certSz;
 
-            #if !defined(OPENSSL_EXTRA) && !defined(OPENSS_EXTRA_X509_SMALL)
+
+            #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
+                if (args->totalCerts >= MAX_CHAIN_DEPTH) {
+                    ssl->peerVerifyRet = X509_V_ERR_CERT_CHAIN_TOO_LONG;
+                    ret = MAX_CHAIN_ERROR;
+                    WOLFSSL_MSG("Too many certs for MAX_CHAIN_DEPTH");
+                    break; /* break out to avoid reading more certs then buffer
+                            * can hold */
+                }
+            #else
                 if (args->totalCerts >= ssl->verifyDepth ||
                         args->totalCerts >= MAX_CHAIN_DEPTH) {
                     ERROR_OUT(MAX_CHAIN_ERROR, exit_ppc);
                 }
             #endif
 
                 if ((args->idx - args->begin) + OPAQUE24_LEN > totalSz) {
                     ERROR_OUT(BUFFER_ERROR, exit_ppc);
                 }
 
                 c24to32(input + args->idx, &certSz);
                 args->idx += OPAQUE24_LEN;
 
                 if ((args->idx - args->begin) + certSz > totalSz) {
                     ERROR_OUT(BUFFER_ERROR, exit_ppc);
                 }
 
                 args->certs[args->totalCerts].length = certSz;
                 args->certs[args->totalCerts].buffer = input + args->idx;
 
             #ifdef SESSION_CERTS
                 AddSessionCertToChain(&ssl->session.chain,
                     input + args->idx, certSz);
             #endif /* SESSION_CERTS */
 
                 args->idx += certSz;
                 listSz -= certSz + CERT_HEADER_SZ;
 
             #ifdef WOLFSSL_TLS13
                 /* Extensions */
                 if (ssl->options.tls1_3) {
                     word16 extSz;
 
                     if (args->exts == NULL) {
                         ERROR_OUT(BUFFER_ERROR, exit_ppc);
                     }
                     if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {
                         ERROR_OUT(BUFFER_ERROR, exit_ppc);
                     }
                     ato16(input + args->idx, &extSz);
                     args->idx += OPAQUE16_LEN;
                     if ((args->idx - args->begin) + extSz > totalSz) {
                         ERROR_OUT(BUFFER_ERROR, exit_ppc);
                     }
                     /* Store extension data info for later processing. */
                     args->exts[args->totalCerts].length = extSz;
                     args->exts[args->totalCerts].buffer = input + args->idx;
                     args->idx += extSz;
                     listSz -= extSz + OPAQUE16_LEN;
                     ret = TLSX_Parse(ssl, args->exts[args->totalCerts].buffer,
                         args->exts[args->totalCerts].length, certificate, NULL);
                     if (ret < 0) {
                         ERROR_OUT(ret, exit_ppc);
                     }
                 }
             #endif
 
                 args->totalCerts++;
                 WOLFSSL_MSG("\tPut another cert into chain");
             } /* while (listSz) */
 
             args->count = args->totalCerts;
             args->certIdx = 0; /* select peer cert (first one) */
 
             if (args->count == 0 && (ssl->options.mutualAuth ||
                  (ssl->options.failNoCert && IsAtLeastTLSv1_3(ssl->version))) &&
                                       ssl->options.side == WOLFSSL_SERVER_END) {
                 ret = NO_PEER_CERT;
                 DoCertFatalAlert(ssl, ret);
             }
 
             args->dCertInit = 0;
         #ifndef WOLFSSL_SMALL_CERT_VERIFY
             args->dCert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), ssl->heap,
                                                        DYNAMIC_TYPE_DCERT);
             if (args->dCert == NULL) {
                 ERROR_OUT(MEMORY_E, exit_ppc);
             }
             XMEMSET(args->dCert, 0, sizeof(DecodedCert));
         #endif
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_BUILD;
         } /* case TLS_ASYNC_BEGIN */
         FALL_THROUGH;
 
         case TLS_ASYNC_BUILD:
         {
             if (args->count > 0) {
 
                 /* check for trusted peer and get untrustedDepth */
             #if defined(WOLFSSL_TRUST_PEER_CERT) || defined(OPENSSL_EXTRA)
                 if (args->certIdx == 0) {
                 #ifdef WOLFSSL_TRUST_PEER_CERT
                     TrustedPeerCert* tp;
                     int matchType = WC_MATCH_NAME;
                 #endif
 
                     ret = ProcessPeerCertParse(ssl, args, CERT_TYPE, NO_VERIFY,
                         &subjectHash, &alreadySigner);
                     if (ret != 0)
                         goto exit_ppc;
 
                 #ifdef OPENSSL_EXTRA
                     /* Determine untrusted depth */
                     if (!alreadySigner && (!args->dCert ||
                             !args->dCertInit || !args->dCert->selfSigned)) {
                         args->untrustedDepth = 1;
                     }
                 #endif
 
                 #ifdef WOLFSSL_TRUST_PEER_CERT
                     #ifndef NO_SKID
                     if (args->dCert->extAuthKeyIdSet)
                         matchType = WC_MATCH_SKID;
                     #endif
                     tp = GetTrustedPeer(ssl->ctx->cm, subjectHash, matchType);
                     WOLFSSL_MSG("Checking for trusted peer cert");
 
                     if (tp && MatchTrustedPeer(tp, args->dCert)) {
                         WOLFSSL_MSG("Found matching trusted peer cert");
                         args->haveTrustPeer = 1;
                     }
                     else if (tp == NULL) {
                         /* no trusted peer cert */
                         WOLFSSL_MSG("No matching trusted peer cert. Checking CAs");
                     }
                     else {
                         WOLFSSL_MSG("Trusted peer cert did not match!");
                     }
                     if (!args->haveTrustPeer)
                 #endif
                     {
                         /* free cert if not trusted peer */
                         FreeDecodedCert(args->dCert);
                         args->dCertInit = 0;
                     }
                 }
             #endif /* WOLFSSL_TRUST_PEER_CERT || OPENSSL_EXTRA */
 
                 /* check certificate up to peer's first */
                 /* do not verify chain if trusted peer cert found */
                 while (args->count > 1
                 #ifdef WOLFSSL_TRUST_PEER_CERT
                     && !args->haveTrustPeer
                 #endif /* WOLFSSL_TRUST_PEER_CERT */
                 ) {
                     int skipAddCA = 0;
 
                     /* select last certificate */
                     args->certIdx = args->count - 1;
 
                     ret = ProcessPeerCertParse(ssl, args, CERT_TYPE,
                         !ssl->options.verifyNone ? VERIFY : NO_VERIFY,
                         &subjectHash, &alreadySigner);
                 #ifdef WOLFSSL_ASYNC_CRYPT
                     if (ret == WC_PENDING_E)
                         goto exit_ppc;
                 #endif
                     if (ret == 0) {
                         ret = ProcessPeerCertCheckKey(ssl, args);
                     }
 
                     if (ret == 0 && args->dCert->isCA == 0) {
                         WOLFSSL_MSG("Chain cert is not a CA, not adding as one");
                     }
                     else if (ret == 0 && ssl->options.verifyNone) {
                         WOLFSSL_MSG("Chain cert not verified by option, "
                             "not adding as CA");
                     }
                     else if (ret == 0) {
                     #ifdef OPENSSL_EXTRA
                         if (args->certIdx > args->untrustedDepth) {
                             args->untrustedDepth = (char)args->certIdx + 1;
                         }
                     #endif
 
                         if (alreadySigner) {
                             WOLFSSL_MSG("Verified CA from chain and already had it");
                         }
                     }
                     else {
                         WOLFSSL_MSG("Failed to verify CA from chain");
                     #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                         ssl->peerVerifyRet = X509_V_ERR_INVALID_CA;
                     #endif
                     }
 
             #if defined(HAVE_OCSP) || defined(HAVE_CRL)
                     if (ret == 0) {
                         int doCrlLookup = 1;
                 #ifdef HAVE_OCSP
                     #ifdef HAVE_CERTIFICATE_STATUS_REQUEST_V2
                         if (ssl->status_request_v2) {
                             ret = TLSX_CSR2_InitRequests(ssl->extensions,
                                                     args->dCert, 0, ssl->heap);
                         }
                         else /* skips OCSP and force CRL check */
                     #endif /* HAVE_CERTIFICATE_STATUS_REQUEST_V2 */
                         if (ssl->ctx->cm->ocspEnabled &&
                                             ssl->ctx->cm->ocspCheckAll) {
                             WOLFSSL_MSG("Doing Non Leaf OCSP check");
                             ret = CheckCertOCSP_ex(ssl->ctx->cm->ocsp,
                                                     args->dCert, NULL, ssl);
                         #ifdef WOLFSSL_NONBLOCK_OCSP
                             if (ret == OCSP_WANT_READ) {
                                 args->lastErr = ret;
                                 goto exit_ppc;
                             }
                         #endif
                             doCrlLookup = (ret == OCSP_CERT_UNKNOWN);
                             if (ret != 0) {
                                 doCrlLookup = 0;
                                 WOLFSSL_MSG("\tOCSP Lookup not ok");
                             }
                         }
                 #endif /* HAVE_OCSP */
 
                 #ifdef HAVE_CRL
                         if (ret == 0 && doCrlLookup &&
                                     ssl->ctx->cm->crlEnabled &&
                                                 ssl->ctx->cm->crlCheckAll) {
                             WOLFSSL_MSG("Doing Non Leaf CRL check");
                             ret = CheckCertCRL(ssl->ctx->cm->crl, args->dCert);
                         #ifdef WOLFSSL_NONBLOCK_OCSP
                             if (ret == OCSP_WANT_READ) {
                                 args->lastErr = ret;
                                 goto exit_ppc;
                             }
                         #endif
                             if (ret != 0) {
                                 WOLFSSL_MSG("\tCRL check not ok");
                             }
                         }
                 #endif /* HAVE_CRL */
                         (void)doCrlLookup;
                     }
             #endif /* HAVE_OCSP || HAVE_CRL */
-#ifdef OPENSSL_EXTRA
-                    if (ret == 0 && 
-                        /* extend the limit "+1" until reaching 
+            #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
+                    if (ret == 0 &&
+                        /* extend the limit "+1" until reaching
                          * an ultimately trusted issuer.*/
                         args->count > (ssl->verifyDepth + 1)) {
                         ssl->peerVerifyRet = X509_V_ERR_CERT_CHAIN_TOO_LONG;
                         ret = MAX_CHAIN_ERROR;
                     }
-#endif
+            #endif
                     /* Do verify callback */
                     ret = DoVerifyCallback(ssl->ctx->cm, ssl, ret, args);
                     if (ssl->options.verifyNone &&
                               (ret == CRL_MISSING || ret == CRL_CERT_REVOKED)) {
                         WOLFSSL_MSG("Ignoring CRL problem based on verify setting");
                         ret = ssl->error = 0;
                     }
 
                 #ifdef WOLFSSL_ALT_CERT_CHAINS
                     /* For alternate cert chain, its okay for a CA cert to fail
                         with ASN_NO_SIGNER_E here. The "alternate" certificate
                         chain mode only requires that the peer certificate
                         validate to a trusted CA */
                     if (ret != 0 && args->dCert->isCA) {
                         if (ret == ASN_NO_SIGNER_E) {
                             if (!ssl->options.usingAltCertChain) {
                                 WOLFSSL_MSG("Trying alternate cert chain");
                                 ssl->options.usingAltCertChain = 1;
                             }
 
                             ret = 0; /* clear errors and continue */
                             args->verifyErr = 0;
                         }
 
                         /* do not add to certificate manager */
                         skipAddCA = 1;
                     }
                 #endif /* WOLFSSL_ALT_CERT_CHAINS */
 
                     /* If valid CA then add to Certificate Manager */
                     if (ret == 0 && args->dCert->isCA &&
                             !ssl->options.verifyNone && !skipAddCA) {
                         buffer* cert = &args->certs[args->certIdx];
 
                         /* Is valid CA */
                     #if defined(SESSION_CERTS) && defined(WOLFSSL_ALT_CERT_CHAINS)
                         /* if using alternate chain, store the cert used */
                         if (ssl->options.usingAltCertChain) {
                             AddSessionCertToChain(&ssl->session.altChain,
                                 cert->buffer, cert->length);
                         }
                     #endif /* SESSION_CERTS && WOLFSSL_ALT_CERT_CHAINS */
                         if (!alreadySigner) {
                             DerBuffer* add = NULL;
                             ret = AllocDer(&add, cert->length, CA_TYPE, ssl->heap);
                             if (ret < 0)
                                 goto exit_ppc;
 
                             XMEMCPY(add->buffer, cert->buffer, cert->length);
 
                             /* CA already verified above in ParseCertRelative */
                             WOLFSSL_MSG("Adding CA from chain");
                             ret = AddCA(ssl->ctx->cm, &add, WOLFSSL_CHAIN_CA,
                                 NO_VERIFY);
                             if (ret == WOLFSSL_SUCCESS) {
                                 ret = 0;
                             }
                         }
                     }
 
                     /* Handle error codes */
                     if (ret != 0) {
                         if (!ssl->options.verifyNone) {
                             DoCertFatalAlert(ssl, ret);
                         }
                         ssl->error = ret; /* Report SSL error */
 
                         if (args->lastErr == 0) {
                             args->lastErr = ret; /* save error from last time */
                             ret = 0; /* reset error */
                         }
                     }
 
                     FreeDecodedCert(args->dCert);
                     args->dCertInit = 0;
                     args->count--;
                 } /* while (count > 0 && !args->haveTrustPeer) */
             } /* if (count > 0) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_ppc;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_DO;
         } /* case TLS_ASYNC_BUILD */
         FALL_THROUGH;
 
         case TLS_ASYNC_DO:
         {
             /* peer's, may not have one if blank client cert sent by TLSv1.2 */
             if (args->count > 0) {
                 WOLFSSL_MSG("Verifying Peer's cert");
 
                 /* select peer cert (first one) */
                 args->certIdx = 0;
 
                 ret = ProcessPeerCertParse(ssl, args, CERT_TYPE,
                         !ssl->options.verifyNone ? VERIFY : NO_VERIFY,
                         &subjectHash, &alreadySigner);
             #ifdef WOLFSSL_ASYNC_CRYPT
                 if (ret == WC_PENDING_E)
                     goto exit_ppc;
             #endif
                 if (ret == 0) {
                     WOLFSSL_MSG("Verified Peer's cert");
                 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                     ssl->peerVerifyRet = X509_V_OK;
                 #endif
                 #if defined(SESSION_CERTS) && defined(WOLFSSL_ALT_CERT_CHAINS)
                     /* if using alternate chain, store the cert used */
                     if (ssl->options.usingAltCertChain) {
                         buffer* cert = &args->certs[args->certIdx];
                         AddSessionCertToChain(&ssl->session.altChain,
                             cert->buffer, cert->length);
                     }
                 #endif /* SESSION_CERTS && WOLFSSL_ALT_CERT_CHAINS */
 
                     /* Check peer's certificate version number. TLS 1.2 / 1.3
                      * requires the clients certificate be version 3 unless a
                      * different version has been negotiated using RFC 7250 */
                     if ((ret == 0) &&
                             (ssl->options.side == WOLFSSL_SERVER_END)) {
                         if (args->dCert->version != WOLFSSL_X509_V3) {
                             WOLFSSL_MSG("Peers certificate was not version 3!");
                             args->lastErr = ASN_VERSION_E;
                             /* setting last error but not considering it fatal
                              * giving the user a chance to override */
                         }
                     }
 
                     /* check if fatal error */
                     if (args->verifyErr) {
                         args->fatal = 1;
                         ret = args->lastErr;
                     }
                     else {
                         args->fatal = 0;
                     }
                 }
                 else if (ret == ASN_PARSE_E || ret == BUFFER_E) {
                     WOLFSSL_MSG("Got Peer cert ASN PARSE or BUFFER ERROR");
                 #if defined(WOLFSSL_EXTRA_ALERTS) || defined(OPENSSL_EXTRA) || \
                                                defined(OPENSSL_EXTRA_X509_SMALL)
                     DoCertFatalAlert(ssl, ret);
                 #endif
                 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                     ssl->peerVerifyRet = X509_V_ERR_CERT_REJECTED;
                 #endif
                     args->fatal = 1;
                 }
                 else {
                     WOLFSSL_MSG("Failed to verify Peer's cert");
                 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                     ssl->peerVerifyRet = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;
                 #endif
                     if (ssl->verifyCallback) {
                         WOLFSSL_MSG(
                             "\tCallback override available, will continue");
                         /* check if fatal error */
                         args->fatal = (args->verifyErr) ? 1 : 0;
                     #if defined(WOLFSSL_EXTRA_ALERTS) || \
                                                      defined(OPENSSL_EXTRA) || \
                                                defined(OPENSSL_EXTRA_X509_SMALL)
                         if (args->fatal)
                             DoCertFatalAlert(ssl, ret);
                     #endif
                     }
                     else {
                         WOLFSSL_MSG("\tNo callback override available, fatal");
                         args->fatal = 1;
                     #if defined(WOLFSSL_EXTRA_ALERTS) || \
                                                      defined(OPENSSL_EXTRA) || \
                                                defined(OPENSSL_EXTRA_X509_SMALL)
                         DoCertFatalAlert(ssl, ret);
                     #endif
                     }
                 }
 
             #ifdef HAVE_SECURE_RENEGOTIATION
                 if (args->fatal == 0 && !IsAtLeastTLSv1_3(ssl->version)
                                      && ssl->secure_renegotiation
                                      && ssl->secure_renegotiation->enabled) {
 
                     if (IsEncryptionOn(ssl, 0)) {
                         /* compare against previous time */
                         if (ssl->secure_renegotiation->subject_hash_set) {
                             if (XMEMCMP(args->dCert->subjectHash,
                                         ssl->secure_renegotiation->subject_hash,
                                         KEYID_SIZE) != 0) {
                                 WOLFSSL_MSG(
                                   "Peer sent different cert during scr, fatal");
                                 args->fatal = 1;
                                 ret = SCR_DIFFERENT_CERT_E;
                             }
                         }
                     }
 
                     /* cache peer's hash */
                     if (args->fatal == 0) {
                         XMEMCPY(ssl->secure_renegotiation->subject_hash,
                                 args->dCert->subjectHash, KEYID_SIZE);
                         ssl->secure_renegotiation->subject_hash_set = 1;
                     }
                 }
             #endif /* HAVE_SECURE_RENEGOTIATION */
             } /* if (count > 0) */
 
             /* Check for error */
             if (args->fatal && ret != 0) {
                 goto exit_ppc;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_VERIFY;
         } /* case TLS_ASYNC_DO */
         FALL_THROUGH;
 
         case TLS_ASYNC_VERIFY:
         {
             if (args->count > 0) {
             #if defined(HAVE_OCSP) || defined(HAVE_CRL)
                 if (args->fatal == 0) {
                     int doLookup = 1;
 
                     if (ssl->options.side == WOLFSSL_CLIENT_END) {
                 #ifdef HAVE_CERTIFICATE_STATUS_REQUEST
                         if (ssl->status_request) {
                             args->fatal = TLSX_CSR_InitRequest(ssl->extensions,
                                                     args->dCert, ssl->heap);
                             doLookup = 0;
                         #if defined(WOLFSSL_TLS13)
                             if (ssl->options.tls1_3) {
                                 TLSX* ext = TLSX_Find(ssl->extensions,
                                                            TLSX_STATUS_REQUEST);
                                 if (ext != NULL) {
                                     word32 idx = 0;
                                     CertificateStatusRequest* csr =
                                            (CertificateStatusRequest*)ext->data;
                                     ret = ProcessCSR(ssl, csr->response.buffer,
                                                     &idx, csr->response.length);
                                     if (ret < 0)
                                         goto exit_ppc;
                                 }
                             }
                         #endif
                         }
                         /* Ensure a stapling response was seen */
                         else if (ssl->options.tls1_3 &&
                                                  ssl->ctx->cm->ocspMustStaple) {
                              ret = OCSP_CERT_UNKNOWN;
                              goto exit_ppc;
                         }
                 #endif /* HAVE_CERTIFICATE_STATUS_REQUEST */
                 #ifdef HAVE_CERTIFICATE_STATUS_REQUEST_V2
                         if (ssl->status_request_v2) {
                             args->fatal = TLSX_CSR2_InitRequests(ssl->extensions,
                                                     args->dCert, 1, ssl->heap);
                             doLookup = 0;
                         }
                 #endif /* HAVE_CERTIFICATE_STATUS_REQUEST_V2 */
                     }
 
                 #ifdef HAVE_OCSP
                     if (doLookup && ssl->ctx->cm->ocspEnabled) {
                         WOLFSSL_MSG("Doing Leaf OCSP check");
                         ret = CheckCertOCSP_ex(ssl->ctx->cm->ocsp,
                                                     args->dCert, NULL, ssl);
                     #ifdef WOLFSSL_NONBLOCK_OCSP
                         if (ret == OCSP_WANT_READ) {
                             goto exit_ppc;
                         }
                     #endif
                         doLookup = (ret == OCSP_CERT_UNKNOWN);
                         if (ret != 0) {
                             WOLFSSL_MSG("\tOCSP Lookup not ok");
                             args->fatal = 0;
                         #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                             ssl->peerVerifyRet = X509_V_ERR_CERT_REJECTED;
                         #endif
                         }
                     }
                 #endif /* HAVE_OCSP */
 
                 #ifdef HAVE_CRL
                     if (doLookup && ssl->ctx->cm->crlEnabled) {
                         WOLFSSL_MSG("Doing Leaf CRL check");
                         ret = CheckCertCRL(ssl->ctx->cm->crl, args->dCert);
                     #ifdef WOLFSSL_NONBLOCK_OCSP
                         if (ret == OCSP_WANT_READ) {
                             goto exit_ppc;
                         }
                     #endif
                         if (ret != 0) {
                             WOLFSSL_MSG("\tCRL check not ok");
                             args->fatal = 0;
                         #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                             ssl->peerVerifyRet = X509_V_ERR_CERT_REJECTED;
                         #endif
                         }
                     }
                 #endif /* HAVE_CRL */
                     (void)doLookup;
                 }
             #endif /* HAVE_OCSP || HAVE_CRL */
 
             #ifdef KEEP_PEER_CERT
                 if (args->fatal == 0) {
                     int copyRet = 0;
 
                     #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
                         if (ssl->options.handShakeDone) {
                             FreeX509(&ssl->peerCert);
                             InitX509(&ssl->peerCert, 0, ssl->heap);
                         }
                         else
                     #endif
                     #ifdef HAVE_SECURE_RENEGOTIATION
                         if (ssl->secure_renegotiation &&
                                            ssl->secure_renegotiation->enabled) {
                             /* free old peer cert */
                             FreeX509(&ssl->peerCert);
                             InitX509(&ssl->peerCert, 0, ssl->heap);
                         }
                         else
                     #endif
                         {
                         }
 
                     /* set X509 format for peer cert */
                     copyRet = CopyDecodedToX509(&ssl->peerCert, args->dCert);
                     if (copyRet == MEMORY_E) {
                         args->fatal = 1;
                     }
                 }
             #endif /* KEEP_PEER_CERT */
 
             #ifndef IGNORE_KEY_EXTENSIONS
                 #if defined(OPENSSL_EXTRA)
                   /* when compatibility layer is turned on and no verify is
                    * set then ignore the certificate key extension */
                     if (args->dCert->extKeyUsageSet &&
                           args->dCert->extKeyUsageCrit == 0 &&
                           ssl->options.verifyNone) {
                         WOLFSSL_MSG("Not verifying certificate key usage");
                     }
                     else
                 #endif
                 if (args->dCert->extKeyUsageSet) {
                     if ((ssl->specs.kea == rsa_kea) &&
                         (ssl->options.side == WOLFSSL_CLIENT_END) &&
                         (args->dCert->extKeyUsage & KEYUSE_KEY_ENCIPHER) == 0) {
                         ret = KEYUSE_ENCIPHER_E;
                     }
                     if ((ssl->specs.sig_algo == rsa_sa_algo ||
                             (ssl->specs.sig_algo == ecc_dsa_sa_algo &&
                                  !ssl->specs.static_ecdh)) &&
                         (args->dCert->extKeyUsage & KEYUSE_DIGITAL_SIG) == 0) {
                         WOLFSSL_MSG("KeyUse Digital Sig not set");
                         ret = KEYUSE_SIGNATURE_E;
                     }
                 }
 
                 #if defined(OPENSSL_EXTRA)
                     /* when compatibility layer is turned on and no verify is
                      * set then ignore the certificate key extension */
                     if (args->dCert->extExtKeyUsageSet &&
                             args->dCert->extExtKeyUsageCrit == 0 &&
                           ssl->options.verifyNone) {
                                 WOLFSSL_MSG("Not verifying certificate ext key usage");
                     }
                     else
                 #endif
                 if (args->dCert->extExtKeyUsageSet) {
                     if (ssl->options.side == WOLFSSL_CLIENT_END) {
                         if ((args->dCert->extExtKeyUsage &
                                 (EXTKEYUSE_ANY | EXTKEYUSE_SERVER_AUTH)) == 0) {
                             WOLFSSL_MSG("ExtKeyUse Server Auth not set");
                             ret = EXTKEYUSE_AUTH_E;
                         }
                     }
                     else {
                         if ((args->dCert->extExtKeyUsage &
                                 (EXTKEYUSE_ANY | EXTKEYUSE_CLIENT_AUTH)) == 0) {
                             WOLFSSL_MSG("ExtKeyUse Client Auth not set");
                             ret = EXTKEYUSE_AUTH_E;
                         }
                     }
                 }
             #endif /* IGNORE_KEY_EXTENSIONS */
 
                 if (args->fatal) {
                     ssl->error = ret;
                 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                     SendAlert(ssl, alert_fatal, bad_certificate);
                     ssl->peerVerifyRet = X509_V_ERR_CERT_REJECTED;
                 #endif
                     goto exit_ppc;
                 }
 
                 ssl->options.havePeerCert = 1;
 
                 if (!ssl->options.verifyNone && ssl->buffers.domainName.buffer) {
                 #ifndef WOLFSSL_ALLOW_NO_CN_IN_SAN
                     /* Per RFC 5280 section 4.2.1.6, "Whenever such identities
                      * are to be bound into a certificate, the subject
                      * alternative name extension MUST be used." */
                     if (args->dCert->altNames) {
                         if (CheckForAltNames(args->dCert,
                                 (char*)ssl->buffers.domainName.buffer,
                                 NULL) != 1) {
                             WOLFSSL_MSG("DomainName match on alt names failed");
                             /* try to get peer key still */
                             ret = DOMAIN_NAME_MISMATCH;
                         }
                     }
                     else {
                         if (MatchDomainName(
                                  args->dCert->subjectCN,
                                  args->dCert->subjectCNLen,
                                  (char*)ssl->buffers.domainName.buffer) == 0) {
                             WOLFSSL_MSG("DomainName match on common name failed");
                             ret = DOMAIN_NAME_MISMATCH;
                         }
                     }
                 #else /* WOLFSSL_ALL_NO_CN_IN_SAN */
                     /* Old behavior. */
                     if (MatchDomainName(args->dCert->subjectCN,
                                 args->dCert->subjectCNLen,
                                 (char*)ssl->buffers.domainName.buffer) == 0) {
                         WOLFSSL_MSG("DomainName match on common name failed");
                         if (CheckForAltNames(args->dCert,
                                  (char*)ssl->buffers.domainName.buffer,
                                  NULL) != 1) {
                             WOLFSSL_MSG(
                                 "DomainName match on alt names failed too");
                             /* try to get peer key still */
                             ret = DOMAIN_NAME_MISMATCH;
                         }
                     }
                 #endif /* WOLFSSL_ALL_NO_CN_IN_SAN */
                 }
 
                 /* decode peer key */
                 switch (args->dCert->keyOID) {
                 #ifndef NO_RSA
                     case RSAk:
                     {
                         word32 keyIdx = 0;
                         int keyRet = 0;
 
                         if (ssl->peerRsaKey == NULL) {
                             keyRet = AllocKey(ssl, DYNAMIC_TYPE_RSA,
                                                 (void**)&ssl->peerRsaKey);
                         } else if (ssl->peerRsaKeyPresent) {
                             keyRet = ReuseKey(ssl, DYNAMIC_TYPE_RSA,
                                               ssl->peerRsaKey);
                             ssl->peerRsaKeyPresent = 0;
                         }
 
                         if (keyRet != 0 || wc_RsaPublicKeyDecode(
                                args->dCert->publicKey, &keyIdx, ssl->peerRsaKey,
                                                 args->dCert->pubKeySize) != 0) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             ssl->peerRsaKeyPresent = 1;
                     #ifdef WOLFSSL_RENESAS_TSIP_TLS
                         /* copy encrypted tsip key index into ssl object */
                         if (args->dCert->tsip_encRsaKeyIdx) {
                             if (!ssl->peerTsipEncRsaKeyIndex) {
                                 ssl->peerTsipEncRsaKeyIndex = (byte*)XMALLOC(
                                     TSIP_TLS_ENCPUBKEY_SZ_BY_CERTVRFY,
                                     ssl->heap, DYNAMIC_TYPE_RSA);
                                 if (!ssl->peerTsipEncRsaKeyIndex) {
                                     args->lastErr = MEMORY_E;
                                     goto exit_ppc;
                                 }
                             }
 
                             XMEMCPY(ssl->peerTsipEncRsaKeyIndex,
                                         args->dCert->tsip_encRsaKeyIdx,
                                         TSIP_TLS_ENCPUBKEY_SZ_BY_CERTVRFY);
                          }
                     #endif
                     #ifdef HAVE_PK_CALLBACKS
                         #ifndef NO_RSA
                             #if defined(HAVE_SECURE_RENEGOTIATION) || \
                                             defined(WOLFSSL_POST_HANDSHAKE_AUTH)
                             if (ssl->buffers.peerRsaKey.buffer) {
                                 XFREE(ssl->buffers.peerRsaKey.buffer,
                                         ssl->heap, DYNAMIC_TYPE_RSA);
                                 ssl->buffers.peerRsaKey.buffer = NULL;
                             }
                             #endif
 
 
                             ssl->buffers.peerRsaKey.buffer =
                                    (byte*)XMALLOC(args->dCert->pubKeySize,
                                                 ssl->heap, DYNAMIC_TYPE_RSA);
                             if (ssl->buffers.peerRsaKey.buffer == NULL) {
                                 ret = MEMORY_ERROR;
                             }
                             else {
                                 XMEMCPY(ssl->buffers.peerRsaKey.buffer,
                                         args->dCert->publicKey,
                                         args->dCert->pubKeySize);
                                 ssl->buffers.peerRsaKey.length =
                                     args->dCert->pubKeySize;
                             }
                         #endif /* NO_RSA */
                     #endif /* HAVE_PK_CALLBACKS */
                         }
 
                         /* check size of peer RSA key */
                         if (ret == 0 && ssl->peerRsaKeyPresent &&
                                           !ssl->options.verifyNone &&
                                           wc_RsaEncryptSize(ssl->peerRsaKey)
                                               < ssl->options.minRsaKeySz) {
                             ret = RSA_KEY_SIZE_E;
                             WOLFSSL_MSG("Peer RSA key is too small");
                         }
                         break;
                     }
                 #endif /* NO_RSA */
                 #ifdef HAVE_NTRU
                     case NTRUk:
                     {
                         if (args->dCert->pubKeySize > sizeof(ssl->peerNtruKey)) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             XMEMCPY(ssl->peerNtruKey, args->dCert->publicKey,
                                                       args->dCert->pubKeySize);
                             ssl->peerNtruKeyLen =
                                 (word16)args->dCert->pubKeySize;
                             ssl->peerNtruKeyPresent = 1;
                         }
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #ifdef HAVE_ECC
                     case ECDSAk:
                     {
                         int keyRet = 0;
                         word32 idx = 0;
 
                         if (ssl->peerEccDsaKey == NULL) {
                             /* alloc/init on demand */
                             keyRet = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                     (void**)&ssl->peerEccDsaKey);
                         } else if (ssl->peerEccDsaKeyPresent) {
                             keyRet = ReuseKey(ssl, DYNAMIC_TYPE_ECC,
                                               ssl->peerEccDsaKey);
                             ssl->peerEccDsaKeyPresent = 0;
                         }
 
                         if (keyRet != 0 ||
                             wc_EccPublicKeyDecode(args->dCert->publicKey, &idx,
                                                 ssl->peerEccDsaKey,
                                                 args->dCert->pubKeySize) != 0) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             ssl->peerEccDsaKeyPresent = 1;
                     #ifdef HAVE_PK_CALLBACKS
                             if (ssl->buffers.peerEccDsaKey.buffer)
                                 XFREE(ssl->buffers.peerEccDsaKey.buffer,
                                       ssl->heap, DYNAMIC_TYPE_ECC);
                             ssl->buffers.peerEccDsaKey.buffer =
                                    (byte*)XMALLOC(args->dCert->pubKeySize,
                                            ssl->heap, DYNAMIC_TYPE_ECC);
                             if (ssl->buffers.peerEccDsaKey.buffer == NULL) {
                                 ERROR_OUT(MEMORY_ERROR, exit_ppc);
                             }
                             else {
                                 XMEMCPY(ssl->buffers.peerEccDsaKey.buffer,
                                         args->dCert->publicKey,
                                         args->dCert->pubKeySize);
                                 ssl->buffers.peerEccDsaKey.length =
                                         args->dCert->pubKeySize;
                             }
                     #endif /* HAVE_PK_CALLBACKS */
                         }
 
                         /* check size of peer ECC key */
                         if (ret == 0 && ssl->peerEccDsaKeyPresent &&
                                               !ssl->options.verifyNone &&
                                               wc_ecc_size(ssl->peerEccDsaKey)
                                               < ssl->options.minEccKeySz) {
                             ret = ECC_KEY_SIZE_E;
                             WOLFSSL_MSG("Peer ECC key is too small");
                         }
 
                         /* populate curve oid - if missing */
                         if (ssl->options.side == WOLFSSL_CLIENT_END && ssl->ecdhCurveOID == 0)
                             ssl->ecdhCurveOID = args->dCert->pkCurveOID;
                         break;
                     }
                 #endif /* HAVE_ECC */
                 #ifdef HAVE_ED25519
                     case ED25519k:
                     {
                         int keyRet = 0;
                         if (ssl->peerEd25519Key == NULL) {
                             /* alloc/init on demand */
                             keyRet = AllocKey(ssl, DYNAMIC_TYPE_ED25519,
                                     (void**)&ssl->peerEd25519Key);
                         } else if (ssl->peerEd25519KeyPresent) {
                             keyRet = ReuseKey(ssl, DYNAMIC_TYPE_ED25519,
                                               ssl->peerEd25519Key);
                             ssl->peerEd25519KeyPresent = 0;
                         }
 
                         if (keyRet != 0 ||
                             wc_ed25519_import_public(args->dCert->publicKey,
                                                      args->dCert->pubKeySize,
                                                      ssl->peerEd25519Key)
                                                                          != 0) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             ssl->peerEd25519KeyPresent = 1;
                     #ifdef HAVE_PK_CALLBACKS
                             ssl->buffers.peerEd25519Key.buffer =
                                    (byte*)XMALLOC(args->dCert->pubKeySize,
                                            ssl->heap, DYNAMIC_TYPE_ED25519);
                             if (ssl->buffers.peerEd25519Key.buffer == NULL) {
                                 ERROR_OUT(MEMORY_ERROR, exit_ppc);
                             }
                             else {
                                 XMEMCPY(ssl->buffers.peerEd25519Key.buffer,
                                         args->dCert->publicKey,
                                         args->dCert->pubKeySize);
                                 ssl->buffers.peerEd25519Key.length =
                                         args->dCert->pubKeySize;
                             }
                     #endif /*HAVE_PK_CALLBACKS */
                         }
 
                         /* check size of peer ECC key */
                         if (ret == 0 && ssl->peerEd25519KeyPresent &&
                                   !ssl->options.verifyNone &&
                                   ED25519_KEY_SIZE < ssl->options.minEccKeySz) {
                             ret = ECC_KEY_SIZE_E;
                             WOLFSSL_MSG("Peer ECC key is too small");
                         }
 
                         /* populate curve oid - if missing */
                         if (ssl->options.side == WOLFSSL_CLIENT_END && ssl->ecdhCurveOID == 0)
                             ssl->ecdhCurveOID = ECC_X25519_OID;
                         break;
                     }
                 #endif /* HAVE_ED25519 */
                 #ifdef HAVE_ED448
                     case ED448k:
                     {
                         int keyRet = 0;
                         if (ssl->peerEd448Key == NULL) {
                             /* alloc/init on demand */
                             keyRet = AllocKey(ssl, DYNAMIC_TYPE_ED448,
                                     (void**)&ssl->peerEd448Key);
                         } else if (ssl->peerEd448KeyPresent) {
                             keyRet = ReuseKey(ssl, DYNAMIC_TYPE_ED448,
                                     ssl->peerEd448Key);
                             ssl->peerEd448KeyPresent = 0;
                         }
 
                         if (keyRet != 0 ||
                             wc_ed448_import_public(args->dCert->publicKey,
                                     args->dCert->pubKeySize,
                                     ssl->peerEd448Key) != 0) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             ssl->peerEd448KeyPresent = 1;
                     #ifdef HAVE_PK_CALLBACKS
                             ssl->buffers.peerEd448Key.buffer =
                                    (byte*)XMALLOC(args->dCert->pubKeySize,
                                            ssl->heap, DYNAMIC_TYPE_ED448);
                             if (ssl->buffers.peerEd448Key.buffer == NULL) {
                                 ERROR_OUT(MEMORY_ERROR, exit_ppc);
                             }
                             else {
                                 XMEMCPY(ssl->buffers.peerEd448Key.buffer,
                                         args->dCert->publicKey,
                                         args->dCert->pubKeySize);
                                 ssl->buffers.peerEd448Key.length =
                                         args->dCert->pubKeySize;
                             }
                     #endif /*HAVE_PK_CALLBACKS */
                         }
 
                         /* check size of peer ECC key */
                         if (ret == 0 && ssl->peerEd448KeyPresent &&
                                !ssl->options.verifyNone &&
                                ED448_KEY_SIZE < ssl->options.minEccKeySz) {
                             ret = ECC_KEY_SIZE_E;
                             WOLFSSL_MSG("Peer ECC key is too small");
                         }
 
                         /* populate curve oid - if missing */
                         if (ssl->options.side == WOLFSSL_CLIENT_END && ssl->ecdhCurveOID == 0)
                             ssl->ecdhCurveOID = ECC_X448_OID;
                         break;
                     }
                 #endif /* HAVE_ED448 */
                     default:
                         break;
                 }
 
                 /* args->dCert free'd in function cleanup after callback */
             } /* if (count > 0) */
 
             /* Check for error */
             if (args->fatal && ret != 0) {
                 goto exit_ppc;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_FINALIZE;
         } /* case TLS_ASYNC_VERIFY */
         FALL_THROUGH;
 
         case TLS_ASYNC_FINALIZE:
         {
             /* load last error */
             if (args->lastErr != 0 && ret == 0) {
                 ret = args->lastErr;
             }
 
         #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
             if (args->untrustedDepth > ssl->options.verifyDepth) {
                 ssl->peerVerifyRet = X509_V_ERR_CERT_CHAIN_TOO_LONG;
                 ret = MAX_CHAIN_ERROR;
             }
         #endif
 
             /* Do verify callback */
             ret = DoVerifyCallback(ssl->ctx->cm, ssl, ret, args);
 
             if (ssl->options.verifyNone &&
                               (ret == CRL_MISSING || ret == CRL_CERT_REVOKED)) {
                 WOLFSSL_MSG("Ignoring CRL problem based on verify setting");
                 ret = ssl->error = 0;
             }
 
             if (ret != 0) {
                 if (!ssl->options.verifyNone) {
                     DoCertFatalAlert(ssl, ret);
                 }
                 ssl->error = ret; /* Report SSL error */
             }
 
             if (ret == 0 && ssl->options.side == WOLFSSL_CLIENT_END) {
                 ssl->options.serverState = SERVER_CERT_COMPLETE;
             }
 
             if (IsEncryptionOn(ssl, 0)) {
                 args->idx += ssl->keys.padSz;
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                 if (ssl->options.startedETMRead)
                     args->idx += MacSize(ssl);
             #endif
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_END;
         } /* case TLS_ASYNC_FINALIZE */
         FALL_THROUGH;
 
         case TLS_ASYNC_END:
         {
             /* Set final index */
             *inOutIdx = args->idx;
 
             break;
         }
         default:
             ret = INPUT_CASE_ERROR;
             break;
     } /* switch(ssl->options.asyncState) */
