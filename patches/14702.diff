commit 94ebc248653ede802b2bfbf6219e17f487fab3ff
Author: Werner Lemberg <wl@gnu.org>
Date:   Sun May 12 21:05:36 2019 +0200

    [truetype] Doh.  Fix last commit to make it work.
    
    Very embarassing :-)
    
    Reported as
    
      https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14701
      https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14705
      https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14710
    
    * src/truetype/ttgload.c (IS_DEFAULT_INSTANCE): Move up and add
    argument; update all callers.
    (TT_Process_Simple_Glyph): Use it.  The `unrounded' array is active
    for variation fonts only, thus also enclose related code with
    `#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT ...  #endif' where
    necessary.
    Revert commit a113e5d from 2019-05-09, and don't use `extra_points2'
    but allocate a temporary array.
    Speed up the scaling of the `unrounded' array.
    
    * src/truetype/ttgxvar.c (FT_fixedToInt, FT_FixedToFdot6): Fix type
    conversions and rounding.  The unsigned type must have more or equal
    bits to the signed type.

diff --git a/ChangeLog b/ChangeLog
index 52492cd1d..77766c41a 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,2813 +1,2839 @@
+2019-05-12  Werner Lemberg  <wl@gnu.org>
+
+	[truetype] Doh.  Fix last commit to make it work.
+
+	Very embarassing :-)
+
+	Reported as
+
+	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14701
+	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14705
+	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=14710
+
+	* src/truetype/ttgload.c (IS_DEFAULT_INSTANCE): Move up and add
+	argument; update all callers.
+	(TT_Process_Simple_Glyph): Use it.  The `unrounded' array is active
+	for variation fonts only, thus also enclose related code with
+	`#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT ...  #endif' where
+	necessary.
+	Revert commit a113e5d from 2019-05-09, and don't use `extra_points2'
+	but allocate a temporary array.
+	Speed up the scaling of the `unrounded' array.
+
+	* src/truetype/ttgxvar.c (FT_fixedToInt, FT_FixedToFdot6): Fix type
+	conversions and rounding.  The unsigned type must have more or equal
+	bits to the signed type.
+
 2019-05-09  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Increase precision of font variation (#54371).
 
-	This patch make FreeType use font units in 26.6 format internally
+	This patch makes FreeType use font units in 26.6 format internally
 	instead of integers.
 
 	* src/truetype/ttgxvar.c (FT_fixedToFdot6): New macro.
 	(TT_Vary_Apply_Glyph_Deltas): Add argument to output unrounded font
 	coordinates.
 	* src/truetype/ttgxvar.h: Updated.
 
 	* src/truetype/ttgload.c (TT_Process_Simple_Glyph): Use
 	`extra_points2' array to temporarily hold unrounded point
 	coordinates; use them to compute scaled coordinates and linear
 	advance width and height.
 	(load_truetype_code): Adjust similarly.
 
 2019-05-09  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (TT_Process_Simple_Glyph): Minor.
 
 2019-05-08  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Faster fractions.
 
 	* src/smooth/ftgrays.c (SUBPIXELS): Replace with...
 	(FRACT): A fractional coordinate macro to use in...
 	(gray_render_line, gray_render_scanline): ... here.
 
 2019-05-07  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/raster/ftraster.c (Draw_Sweep): Unbreak.
 
 2019-05-05  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/raster/ftraster.c: Clean-ups.
 
 2019-05-05  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c: More use of `FT_fdot14ToFixed'.
 
 2019-05-04  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_render_line): Small shortcut.
 
 2019-05-04  Werner Lemberg  <wl@gnu.org>
 
 	Various clang 8.0 static analyzer fixes.
 
 	Reported by Sender Ghost <lightside@gmx.com>.
 
 	* src/autofit/afcjk.c (af_cjk_hints_compute_edges): Catch a corner
 	case where `edge->first' could be NULL.
 
 	* src/pfr/pfrobjs.c (pfr_slot_load): Remove unnecessary test of
 	`size'.
 
 	* src/raster/ftraster.c (Draw_Sweep): Catch a corner case where
 	`draw_right' might be NULL.
 
 	* src/sfnt/ttmtx.c (tt_face_get_metrics): Fix limit test for
 	`aadvance'.
 	Ensure `abearing' always hold a meaningful result.
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Ensure `subglyph' is
 	not NULL before accessing it.
 	* src/truetype/ttgxvar.c (TT_Set_Named_Instance): Remove unnecessary
 	test of `namedstyle'.
 
 	* src/type42/t42parse.c (t42_parser_done): Ensure
 	`parser->root.funcs.done' is not NULL before accessing it.
 
 2019-05-03  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Miscellaneous macro updates.
 
 	* src/base/ftoutln.c (SCALED): Updated.
 	* src/smooth/ftgrays.c (SCALED): Ditto.
 	(FLOOR, ROUND, CEILING): Removed.
 	* src/psaux/psfixed.h (cf2_fracToFixed): Updated.
 
 2019-05-02  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Tweak LCD filtering.
 
 	* src/base/ftlcdfil.c (ft_lcd_filter_fir, _ft_lcd_filter_legacy):
 	Choose direction from bitmap's pixel_mode.
 	* include/freetype/internal/ftobjs.c (FT_Bitmap_LcdFilterFunc):
 	Updated.
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Updated.
 
 2019-05-02  Werner Lemberg  <wl@gnu.org>
 
 	* vms_make.com: Updated (#56253).
 
 	Remove no longer existing directories (`autohint', `otlayout').
 	Update used base extensions.
 	Activate `autofit' module.
 	Add `gxvalid' module.
 	Update copyright notices.
 
 2019-04-29  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Simplify cubic Bézier flattening.
 
 	The previous implementation is correct but it is too complex.
 	The revised algorithm is based on the fact that each split moves
 	the control points closer to the trisection points on the chord.
 	The corresponding distances are good surrogates for the curve
 	deviation from the straight line.
 
 	This cubic flattening algorithm is somewhat similar to the conic
 	algorithm based the distance from the control point to the middle of
 	the chord.  The cubic distances, however, decrease less predictably
 	but are easy enough to calculate on each step.
 
 	* src/smooth/ftgrays.c (gray_render_cubic): Replace the split
 	condition.
 
 2019-04-26  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Bithacks and cosmetics.
 
 	* src/smooth/ftgrays.c (gray_record_cell, gray_set_cell, gray_hline,
 	gray_render_conic, gray_convert_glyph_inner): Updated.
 
 2019-04-25  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Optimize Bézier bisections.
 
 	* src/raster/ftraster.c (Split_Conic, Split_Cubic): Use shifts and
 	refactor.
 	* src/smooth/ftgrays.c (gray_split_conic, gray_split_cubic): Ditto.
 	* src/base/ftstroke.c (ft_conic_split, ft_cubic_split): Ditto.
 	* src/base/ftbbox.c (cubic_peak): Use shifts.
 
 2019-04-23  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttcmap.c (tt_cmap12_next): Remove dead code.
 
 	Found by clang 8.0's static analyzer and reported by Sender Ghost
 	<lightside@gmx.com>.
 
 2019-04-23  Werner Lemberg  <wl@gnu.org>
 
 	[base] Fix thinko in previous commit.
 
 	* src/base/ftbitmap.c (FT_Bitmap_Blend): Check final width, not
 	target pitch.
 
 	Problem reported by Sender Ghost <lightside@gmx.com>.
 
 2019-04-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftbitmap.c (FT_Bitmap_Blend): Check target pitch.
 
 	Problem reported by Sender Ghost <lightside@gmx.com>.
 
 2019-04-22  Werner Lemberg  <wl@gnu.org>
 
 	Fix return value of `FT_Set_Named_Instance' (#56186).
 
 	* src/truetype/ttgxvar.c (TT_Set_Named_Instance): Correctly handle
 	internal return value -1 of `TT_Set_Var_Design'.
 
 2019-04-18  Werner Lemberg  <wl@gnu.org>
 
 	[pcf] Fix handling of undefined glyph (#56067).
 
 	This commit fixes the changes from 2018-07-21, which broke charmap
 	iteration.  We now add the default character as a new glyph with
 	index 0, thus increasing the number of glyphs by one (as before).
 
 	* src/pcf/pcfread.c (pcf_get_metrics): Adjust to new artificial
 	glyph with index 0.
 	Limit number of elements to 65534.
 	(pcf_get_bitmaps): Ditto.
 	Unify two loops into one; this avoids allocation of an intermediate
 	array.
 	(pcf_get_encodings): Don't flip indices but copy glyph metrics of
 	default character to index 0.
 	Also handle invalid default character.
 
 	* docs/CHANGES: Updated.
 
 2019-04-15  Minmin Gong  <gongminmin@msn.com>
 
 	* CMakeLists.txt: Avoid rewriting of unchanged configuration files.
 
 	Reported as
 
 	  https://savannah.nongnu.org/patch/index.php?9755
 
 2019-04-15  JDG  <JonathanG@iQmetrix.com>
 
 	* src/tools/apinames.c (main): Fix error message.
 
 	Reported as
 
 	  https://savannah.nongnu.org/patch/?9796
 
 2019-04-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Fix segfault in direct mode (#56092).
 
 	* src/base/ftoutln.c (FT_Outline_Render): Set missing clip_box for
 	direct mode.
 	* src/smooth/ftgrays.c (gray_raster_render): Use it.
 
 2019-04-06  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttcmap.c (tt_get_glyph_name): Pacify compiler (#56061).
 
 	This is for Visual Studio 2019 on ARM.
 
 2019-04-06  Werner Lemberg  <wl@gnu.org>
 
 	For distribution, replace `.tar.bz2' with `.tar.xz' bundles.
 
 	* builds/toplevel.mk (build): Do it.
 
 	* README, docs/CHANGES, docs/release: Updated.
 
 2019-04-06  Antony Lee  <anntzer.lee@gmail.com>
 
 	Make `glyph_name' parameter to `FT_Get_Name_Index' a `const'.
 
 	* include/freetype/freetype.h (FT_Get_Name_Index),
 	include/freetype/internal/ftobjs.h (FT_Face_GetGlyphNameIndexFunc),
 	include/freetype/internal/services/svgldict.h
 	(FT_GlyphDict_NameIndexFunc), src/base/ftobjs.c (FT_Get_Name_Index),
 	src/cff/cffdrivr.c (cff_get_name_index), src/sfnt/sfdriver.c
 	(sfnt_get_name_index), src/type1/t1driver.c (t1_get_name_index),
 	src/type42/t42drivr.c (t42_get_name_index): Add `const' to second
 	argument.
 
 2019-03-31  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	[cff] Fix boundary checks.
 
 	642bc7590c701c8cd35a9f60fa899cfa518b17ff introduced dynamically
 	allocated memory when parsing CFF files with the "old" engine.  Bounds
 	checks have never been updated, however, leading to pointless
 	comparisons of pointers in some cases.  This commit presents a
 	solution for bounds checks in the CFF module with an extended logic
 	for the "old" engine while staying as concise as possible for the
 	"new" one.
 
 	* src/cff/cffparse.h: Introduce the struct `CFF_T2_StringRec' and
 	the additional field `t2_strings' within `CFF_ParserRec'.
 
 	* src/cff/cffparse.c (cff_parser_within_limits): Move all boundary
 	checks into this new function and update the rest of `cffparse.c' to
 	use it.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=12137
 
 2019-03-20  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Fix Mongolian blue zone characters.
 
 	* src/autofit/afblue.dat: Use U+200D (ZERO-WIDTH JOINER) characters
 	to get medial forms for some Mongolian characters.
 	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
 
 2019-03-19  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Add support for Mongolian script.
 
 	As a de-facto standard, layouts using this script are constructed
 	horizontally line by line, then the lines are rotated clockwise for
 	vertical display.
 
 	* src/autofit/afblue.dat: Add blue zone data for Mongolian.
 	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
 
 	* src/autofit/afscript.h: Add Mongolian standard characters.
 
 	* src/autofit/afranges.c, src/autofit/afstyles.h: Add Mongolian
 	data.
 
 2019-03-15  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.10.0 released.
 	==========================
 
 
 	Tag sources with `VER-2-10-0'.
 
 	* docs/VERSION.TXT: Add entry for version 2.10.0.
 	* docs/CHANGES: Updated.
 
 	* README, Jamfile (RefDoc), src/base/ftver.rc,
 	builds/windows/vc2010/freetype.vcxproj,
 	builds/windows/vc2010/index.html,
 	builds/windows/visualc/freetype.dsp,
 	builds/windows/visualc/freetype.vcproj,
 	builds/windows/visualc/index.html,
 	builds/windows/visualce/freetype.dsp,
 	builds/windows/visualce/freetype.vcproj,
 	builds/windows/visualce/index.html,
 	builds/wince/vc2005-ce/freetype.vcproj,
 	builds/wince/vc2005-ce/index.html,
 	builds/wince/vc2008-ce/freetype.vcproj,
 	builds/wince/vc2008-ce/index.html: s/2.9.1/2.10.0/, s/291/2100/.
 
 	* include/freetype/freetype.h (FREETYPE_MINOR): Set to 10.
 	(FREETYPE_PATCH): Set to 0.
 
 	* builds/unix/configure.raw (version_info): Set to 23:0:17.
 	* CMakeLists.txt (VERSION_MINOR): Set to 10.
 	(VERSION_PATCH): Set to 0.
 
 	* builds/toplevel.mk (version, winversion): Since the minor version
 	number has two digits now, never omit the patch number.  We would
 	get ambiguous zip file names otherwise.
 	(dist): Remove remnants of `docmaker' tool.
 	(do-dist): Remove unused intermediate files.
 
 	* src/cff/cffparse.c (destrict_c2s_item): Guard function with
 	CFF_CONFIG_OPTION_OLD_ENGINE macro.
 
 2019-03-07  Andrei Alexeyev  <0x416b617269@gmail.com>
             Werner Lemberg  <wl@gnu.org>
 
 	Fix invalid function pointer casts.
 
 	This change should allow Freetype to work on WASM/Emscripten without
 	needing `-s EMULATE_FUNCTION_POINTER_CASTS=1'.
 
 	* src/autofit/afdummy.c (af_dummy_hints_apply): Fix signature.
 
 	* src/cid/cidload.c (cid_parse_font_matrix, parse_fd_array,
 	parse_expansion_factor, parse_font_name): Return `void', not
 	`FT_Error'.
 
 	* include/freetype/internal/ftobjs.h (FT_CMap_CharVarIsDefaultFunc):
 	Fix signature.
 
 2019-03-05  Werner Lemberg  <wl@gnu.org>
 
 	[base] Handle numeric overflow (#55827).
 
 	* src/base/ftglyph.c (FT_Glyph_Get_CBox): Use `FT_PIX_CEIL_LONG'.
 
 2019-03-05  Sebastian Rasmussen  <sebras@gmail.com>
 
 	[psaux] Fix use of uninitialized memory (#55832).
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString): The call to
 	`cf2_arrstack_setCount' may fail because the allocator ran out of
 	memory.  When this happens the stack is still written to before the
 	error condition is checked.  This means that FreeType writes outside
 	of allocated memory.  This commit moves the error check prior to the
 	stack assignment, hence the function now properly returns with an
 	error condition.
 
 2019-02-23  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftbitmap.c (FT_Bitmap_Blend): No fractional offsets.
 
 	The function only provided a framework without an actual
 	implementation, which this commit removes.
 
 2019-02-23  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/update-copyright-year: Insert `(C)'.
 
 2019-02-21  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	[truetype] Mask numeric overflows.
 
 	* src/truetype/ttinterp.c (Move_CVT, Move_CVT_Stretched, Ins_MIRP):
 	Mask numeric overflows.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11681
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11734
 
 2019-02-21  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	[psaux] Mask numeric overflow.
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings): Mask numeric
 	overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=13041
 
 2019-02-16  Wink Saville  <wink@saville.com>
 
 	* src/autofit/afwarp.h (af_warper_compute): Fix declaration.
 
 2019-02-02  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	[truetype] Apply MVAR hasc, hdsc and hlgp metrics to current FT_Face metrics.
 
 	Instead of setting typo or win metrics as the new `FT_Face' metrics
 	indiscriminately, apply only typo deltas to the currently active
 	`FT_Face' metrics.  This prevents line height differences when the
 	default outlines were used as the regular face and instances for
 	everything else, for example.
 
 	* src/truetype/ttgxvar.c (tt_apply_mvar): Implement.
 
 2019-02-02  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	[sfnt] Use typo metrics if OS/2 fsSelection USE_TYPO_METRICS bit is set.
 
 	If the `OS/2' table exists and `fsSelection' bit 7
 	(USE_TYPO_METRICS) is set, use the `sTypo*' set of values to compute
 	the `FT_Face's ascender, descender, and height.  Otherwise, fall
 	back to old behavior.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Implement.
 
 2019-01-18  John Tytgat  <John.Tytgat@esko.com>
 
 	[sfnt] Handle TT fonts having two PostScript font names (#55471).
 
 	* src/sfnt/sfdriver.c (sfnt_get_name_id): Prefer English over any
 	other language found for PostScript font names.
 
 2019-01-08  Chris Liddell <chris.liddell@artifex.com>
 
 	[psaux] Fix closepath (#55414).
 
 	All of the Type 1 path building is done with code common to the
 	revised CFF engine, with the exception of closepath, which was still
 	calling ps_builder_close_contour(), thus previously cached segments
 	were not always written to the path, and glyph corruption, or even
 	invalid outlines were possible.
 
 	* src/psauc/psinterp.c (cf2_interpT2CharString) <cf2_cmdCLOSEPATH>:
 	Switch to calling `cf2_glyphpath_closeOpenPath'.
 
 2018-12-29  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/aflatin2.c: Some fixes from `aflatin.c' (#55310).
 
 2018-12-25  Werner Lemberg  <wl@gnu.org>
 
 	* src/psaux/cffdecode.c (cff_operaor_seac): Fix numeric overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11915
 
 2018-12-12  Werner Lemberg  <wl@gnu.org>
 
 	[gxvalid] Fix compiler warnings.
 
 	* src/gxvalid/gxvjust.c (gxv_just_check_max_gid),
 	src/gxvalid/gxvmort.c (gxv_mort_coverage_validate): Use `FT_UNUSED'.
 
 2018-12-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (TT_Hint_Glyph): Remove useless test.
 
 	`control_len' only gets its value from `n_ins' (and vice versa),
 	which is always read as `unsigned short' and thus can't be larger
 	than 0xFFFF.
 
 2018-12-04  Werner Lemberg  <wl@gnu.org>
 
 	[bdf] Ignore data after `ENDFONT'.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10798
 
 	* src/bdf/bdflib.c (_bdf_parse_end): New function.
 	(_bdf_parse_glyphs): Switch to `_bdf_parse_end' after `ENDFONT' has
 	been encountered.
 
 2018-12-02  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* builds/windows/visualc/freetype.dsp: Dust off.
 
 2018-11-27  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* builds/windows/vc2010/freetype.vcxproj: Simplify.
 
 2018-11-27  Chris Liddell  <chris.liddell@artifex.com>
 
 	[type1,cff] Add FT_{Set,Get}_MM_WeightVector API calls.
 
 	For multiple master fonts, common usage (in Postscript) is to modify
 	the WeightVector of an existing font instance, this addition
 	supports that use.
 
 	* include/freetype/ftmm.h, src/base/ftmm.c (FT_Set_MM_WeightVector,
 	FT_Get_MM_WeightVector): New API functions.
 
 	* include/freetype/internalservices/svmm.h
 	(FT_Set_MM_WeightVector_Func, FT_Get_MM_WeightVector_Func): New
 	function types.
 	(MultiMasters): Add `set_mm_weightvector' and `get_mm_weightvector'
 	members.
 	(FT_DEFINE_SERVICE_MULTIMASTERSREC): Updated.
 
 	* src/cffcffdrivr.c (cff_set_mm_weightvector,
 	cff_get_mm_weightvector): New functions.
 	(cff_service_multi_masters): Register them.
 
 	* src/truetype/ttdriver.c (tt_service_gx_multi_masters): Updated.
 	This driver doesn't use the new interface.
 
 	* src/type1/t1load.c (T1_Set_MM_WeightVector,
 	T1_Get_MM_WeightVector): New functions.
 	* src/type1/t1driver.c (t1_service_multi_masters): Register them.
 	* src/type1/t1load.h: Updated.
 
 2018-11-27  Ben Wagner  <bungeman@google.com>
 
 	[cff] Fix compiler warning (#55105).
 
 	* src/cff/cffparse.c (cff_parser_run): Guard label only used if
 	CFF_CONFIG_OPTION_OLD_ENGINE is active.
 
 2018-11-27  Ben Wagner  <bungeman@google.com>
 
 	[truetype] Fix numeric overflow (#55103).
 
 	* src/truetype/ttgload.c (compute_glyph_metrics): Use `SUB_LONG'.
 
 2018-11-25  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[builds] Belated DLL support with vc2002-vc2008.
 
 	The solution and project files should be automatically upgraded for
 	the approriate Visual C++ version.
 
 	* builds/windows/visualc/freetype.{sln,vcproj}: Major upgrades.
 	* builds/windows/visualc/index.html: Document the change.
 	* builds/windows/vc2005, builds/windows/vc2008: Removed as redundant.
 
 2018-11-22  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	* src/cff/cffparse.c: Please the compiler.
 
 2018-11-22  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	[cff] Fix memory overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9869
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10869
 
 	* src/cff/cffparse.c (destruct_t2s_item, cff_parser_run): Store
 	evaluated T2 charstrings in separately allocated memory.
 
 2018-11-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* builds/windows/{visualc,vc2005,vc2008}/freetype.vcproj: Fix it.
 
 2018-11-10  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Placeholder only for library-enabled LCD filtering.
 
 	* src/smooth/ftsmooth.c (ft_smooth_init): Add disabled
 	`FT_Library_SetLcdFilter' call.
 
 2018-11-09  Young Xiao  <yangx92@hotmail.com>
 
 	[psaux] Add safety guard (#54985).
 
 	* src/psaux/psobjs.c (cff_builder_close_contour): Do it.
 
 2018-11-08  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* builds/unix/configure.raw: Require `windows.h' for windres.
 
 2018-11-08  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[ftstroke] Fix unpredictable failures (#54986).
 
 	* src/base/ftstroke.c (ft_sroke_border_lineto): Fix lineto check.
 
 2018-11-08  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[ftstroke] Fix unpredictable failures (#54976).
 
 	* src/base/ftstroke.c (ft_sroke_border_close): Set the start tags.
 
 2018-11-07  Ben Wagner  <bungeman@google.com>
 
 	[truetype] Fix VF check from 2018-09-12 (#54973).
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Use correct
 	offsets for estimates.
 
 2018-11-06  Werner Lemberg  <wl@gnu.org>
 
 	[pshinter] Fix numeric overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11242
 
 	* src/pshinter/pshrec.c (ps_dimension_add_t1stem): Implement it.
 
 2018-11-06  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Fix timeout in old CFF engine.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11260
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings)
 	<cff_op_sqrt> [CFF_CONFIG_OPTION_OLD_ENGINE]: Fix potential endless
 	loop.
 
 2018-11-04  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttgxvar.c: Use enum definitions.
 
 2018-11-03  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttgxvar.c (ft_var_apply_tuple): Adjust condition.
 
 2018-11-03  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttgxvar.c (ft_var_apply_tuple): Tracing tweaks.
 
 2018-11-03  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Revert due to specs: [truetype] Speed up variation IUP.
 
 2018-11-02  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttgxvar.c (ft_var_get_item_delta): Fixed logic.
 
 	Reported and tested by Behdad.
 
 2018-11-02  Shailesh Mistry  <shailesh.mistry@hotmail.co.uk>
 
 	[autofit] Prevent SEGV.
 
 	See
 
 	  https://bugs.ghostscript.com/show_bug.cgi?id=697545
 
 	for more details on how the bug was found.
 
 	* src/autofit/afloader.c (af_loader_load_glyph): Propagate error
 	code.
 
 2018-10-31  Alexei Podtelezhnikov <apodtele@gmail.com>
 
 	[truetype] Speed up variation IUP.
 
 	* src/truetype/ttgxvar.c (tt_delta_interpolate): Separate trivial
 	snapping to the same position from true interpolation.
 
 2018-10-31  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/type1/t1load.c (t1_set_mm_blend): Optimized.
 
 2018-10-31  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/truetype/ttgxvar.c (ft_var_get_item_delta): Optimized.
 
 2018-10-29  Werner Lemberg  <wl@gnu.org>
 
 	[base] Fix numeric overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11080
 
 	* src/base/ftoutln.c (FT_Outline_Get_Orientation): Use `MUL_LONG'.
 
 2018-10-29  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix numeric overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10988
 
 	* src/cff/cffparse.c (cff_parser_run)
 	[CFF_CONFIG_OPTION_OLD_ENGINE]: Use `NEG_LONG'.
 
 2018-10-27  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[sfnt] Make `head' timestamps unsigned.
 
 	It's been more than 2^31 seconds since 1904.
 
 	* include/freetype/tttables.h (TT_Header): Change field types.
 	* src/sfnt/ttload.c (tt_face_load_generic_header): Updated.
 
 2018-10-27  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Revert: Align FreeType with standard C memory management.
 
 2018-10-27  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Fix numeric overflow.
 
 	Triggered by
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=11157
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings) <cff_op_blend>
 	[CFF_CONFIG_OPTION_OLD_ENGINE]: Fix integer overflow.
 
 2018-10-20  Werner Lemberg  <wl@gnu.org>
 
 	Avoid endless loop while tracing (#54858).
 
 	* src/type1/t1load.c (parse_buildchar): Guard tracing stuff with
 	FT_DEBUG_LEVEL_TRACE.
 
 2018-10-17  David Demelier  <markand@malikania.fr>
 
 	* CMakeLists.txt: Specify `RUNTIME DESTINATION'.
 
 	This is needed for DLL builds.
 
 2018-10-07  Werner Lemberg  <wl@gnu.org>
 
 	A missing Unicode cmap is not a fatal error.
 
 	This is a follow-up to the previous commit.
 
 	* src/cff/cffobjs.c (cff_face_init), src/sfnt/sfobjs.c
 	(sfnt_load_face), src/type1/t1objs.c (T1_Face_Init),
 	src/type42/t42objs.c (T42_Face_Init): Implement it.
 
 2018-10-07  Werner Lemberg  <wl@gnu.org>
 
 	Fix handling of FT_CONFIG_OPTION_ADOBE_GLYPH_LIST (#54794).
 
 	* src/cff/cffcmap.c (cff_cmap_unicode_init), src/psaux/t1cmap.c
 	(t1_cmap_unicode_init), src/sfnt/ttcmap.c (tt_cmap_unicode_init):
 	Check `unicodes_init' field.
 
 2018-10-03  Werner Lemberg  <wl@gnu.org>
 
 	[ftgrays] Fix typo in stand-alone mode (#54771).
 
 	* src/smooth/ftgrays.c (FT_THROW) [STANDALONE_ &&
 	FT_DEBUG_LEVEL_TRACE]: Fix call to `FT_ERR_CAT'.
 
 2018-10-02  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Fix segfault.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10768
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings)
 	<cff_op_callothersubr> [CFF_CONFIG_OPTION_OLD_ENGINE]: Check
 	argument.
 
 2018-10-02  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Fix numeric overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10740
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings) <cff_op_roll>
 	[CFF_CONFIG_OPTION_OLD_ENGINE]: Use NEG_INT.
 
 2018-10-02  Werner Lemberg  <wl@gnu.org>
 
 	[pshinter] Handle numeric overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10550
 
 	* src/pshinter/pshglob.c (psh_blues_snap_stem): Mask numeric
 	overflow.
 
 2018-09-27  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Align FreeType with standard C memory management.
 
 	* include/freetype/ftsystem.h: Include FT_TYPES_H.
 	(*FT_Alloc_Func, *FT_Realloc_Func): Use size_t for the size arguments.
 	* src/raster/ftmisc.h: Ditto.
 
 	* builds/amiga/src/base/ftsystem.c, builds/unix/ftsystem.c,
 	* builds/vms/ftsystem.c, src/base/ftsystem.c (ft_alloc, ft_realloc):
 	Use size_t for the size arguments.
 
 	* src/base/ftdbgmem.c (ft_mem_debug_alloc, ft_mem_debug_realloc): Use
 	FT_Offset, aka size_t, for the size arguments.
 
 2018-09-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix handling of `FT_Bool'.
 
 	Before this commit we had code like
 
 	  (FT_Bool)( globals->glyph_styles[gindex] & 0x8000)
 
 	Since `FT_Bool' is defined to be an `unsigned char', the code
 	evaluated to something like
 
 	  (unsigned char)( 0x8532 & 0x8000)
 
 	which in turn expanded to
 
 	  (unsigned char)( 0x8000)
 
 	and finally yielded 0x00 – i.e., false – not as expected.
 
 	Problem reported and analyzed by Tony Smith <tony.smith@macro4.com>.
 
 	* include/freetype/fttypes.h (FT_BOOL): Add a comparison against
 	zero so that we always have a Boolean expression.
 
 	*/*: Replace castings to `FT_Bool' with calls to `FT_BOOL' where
 	possible.
 
 2018-09-23  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[bdf] Speed up charmap access.
 
 	This makes FT_Get_Char_Index and FT_Get_Next_Char 4-5 times faster.
 
 	* src/bdf/bdfdrivr.c (bdf_cmap_char_{index,next}): Help binary search
 	with continuous prediction.
 
 2018-09-22  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bimap): Another tweak.
 
 	This one should be clearer. When the rounded monochrome bbox collapses
 	we add a pixel that covers most if not all original cbox.
 
 2018-09-21  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bimap): Further tweak.
 
 2018-09-21  Ben Wagner  <bungeman@google.com>
 
 	Improve auto-hinter handling of bitmap fonts (#54681).
 
 	For bitmap fonts, `FT_Load_Glyph' should either return an error or
 	not set the format to `FT_GLYPH_FORMAT_OUTLINE'.  However, in this
 	case `FT_Load_Glyph' calls into the auto-hinter which calls back
 	into `FT_Load_Glyph' with `FT_LOAD_NO_SCALE' in the flags, which
 	marks the glyph as `FT_GLYPH_FORMAT_OUTLINE' with an empty path
 	(even though it doesn't have any path).  It appears that the
 	auto-hinter should not be called when the face doesn't have
 	outlines.  The current test for using the auto-hinter in
 	`FT_Load_Glyph' checks whether the driver supports scalable
 	outlines, but not if the face supports scalable outlines.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Directly check whether we have
 	scalable outlines.
 
 2018-09-21  Werner Lemberg  <wl@gnu.org>
 
 	[raster] Fix disappearing vertical lines (#54589).
 
 	* src/raster/ftraster.c (Vertical_Sweep_Span): Handle special case
 	where both left and right outline exactly pass pixel centers.
 
 2018-09-20  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bimap): Tiny rounding tweak.
 
 	This adds pixels in case a contour goes through the center
 	and they need to be turned on in the b/w rasterizer.
 
 2018-09-20  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[pcf] Replace charmap implementation.
 
 	PCF comes with charmap lookup table, aka PCF encodings.  Using it
 	directly makes FT_Get_Char_Index and FT_Get_Next_Char 4-5 times
 	faster than the original BDF-like binary searches.
 
 	* src/pcf/pcf.h (PCF_EncodingRec): Removed.
 	(PCF_FaceRec): Remove `nencodings' and `encodings'.
 	* src/pcf/pcfdrivr.c (pcf_cmap_char_{index,next}): Replaced.
 	* src/pcf/pcfread.c (pcf_get_encodings): Store data differently.
 
 2018-09-20  Werner Lemberg  <wl@gnu.org>
 
 	[base] Remove unused function `FT_GlyphLoader_CopyPoints'.
 
 	* include/freetype/internal/ftgloadr.h, src/base/ftgloadr.c
 	(FT_GlyphLoader_CopyPoints): Do it.
 
 2018-09-19  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[pcf] Prepare to replace charmap implementation.
 
 	* src/pcf/pcf.h (PCF_FaceRec): Updated to include...
 	(PCF_EncRec): ... this new structure to store charmap geometry.
 
 	* src/pcf/pcfread.c (pcf_get_encodings): Store charmap geometry.
 
 2018-09-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Remove unused fields.
 
 	* src/pcf.h (PCF_FaceRec): Remove `charmap' and `charmap_handle'.
 	* src/bdfdrvr.h (BDF_FaceRec): Ditto.
 	* src/winfonts/winfnt.h (FNT_FaceRec): Ditto.
 
 2018-09-17  Werner Lemberg  <wl@gnu.org>
 
 	[pshinter] Handle numeric overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10396
 
 	* src/pshinter/pshglob.c: Include FT_INTERNAL_CALC_H.
 	(psh_blues_snap_stem): Mask numeric overflow.
 
 2018-09-13  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Some fixes for VF checks.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10317
 
 	* src/truetype/ttgxvar.c (ft_var_load_gvar): Properly exit memory
 	frame if we have invalid glyph variation data offsets.
 	(tt_face_vary_cvt): Protect against missing `tuplecoords' array.
 	Fix typo.
 
 2018-09-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfdriver.c (sfnt_get_var_ps_name): Fix last commit.
 
 2018-09-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/sfdriver.c (sfnt_get_var_ps_name): Check `result'.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10316
 
 2018-09-12  John Tytgat  <John.Tytgat@esko.com>
 
 	[sfnt] Better PS name handling (#54629).
 
 	* src/sfnt/sfdriver (IS_WIN, IS_APPLE): Omit language ID checks.
 	(get_win_string, get_apple_string): Return NULL when the PostScript
 	font name characters is not according to specification.
 	(get_win_string): Make trace output work if the high byte if
 	non-zero.
 	(sfnt_get_var_ps_name, sfnt_get_ps_name): Previously we preferred
 	Win PS name (when there is also an Apple PS name); change this into
 	a fallback to Apple PS name in case the Win PS name is invalid.
 
 2018-09-12  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Improve VF check.
 
 	Triggered by
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10255
 
 	* src/truetype/ttgxvar.c (ft_var_load_gvar): Use better limit check
 	for `tupleCount'.
 
 2018-09-12  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (ft_var_load_gvar): Check `glyphoffsets'.
 
 2018-09-10  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	* src/pshinter/pshrec.c (t2_hints_stems): Mask numeric overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10215
 
 2018-09-09  Ben Wagner  <bungeman@google.com>
 
 	* builds/freetype.mk (refdoc-venv): Ensure python version (#54631).
 
 2018-09-07  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix assertion failure.
 
 	Triggered by
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10212
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Reintroduce
 	`opened_frame' (removed in a change from 2018-08-26) to handle
 	deallocation of the second frame.
 
 2018-09-05  Werner Lemberg  <wl@gnu.org>
 
 	Synchronize `ftdebug.c' files.
 
 	* builds/amiga/src/base/ftdebug.c, builds/wince/ftdebug.c,
 	builds/windows/ftdebug.c: Synchronize with `src/base/ftdebug.c'.
 
 2018-09-05  Nikhil Ramakrishnan  <ramakrishnan.nikhil@gmail.com>
 
 	Add documentation guidelines file.
 
 	* docs/DOCGUIDE: New file.
 
 2018-09-04  Werner Lemberg  <wl@gnu.org>
 
 	* devel/ftoption.h: Synchronize with master `ftoption.h'.
 
 2018-09-03  Nikhil Ramakrishnan  <ramakrishnan.nikhil@gmail.com>
 
 	[docwriter] Don't break code snippets accross lines.
 
 	Reported as
 
 	  https://lists.nongnu.org/archive/html/freetype-devel/2018-08/msg00124.html
 
 	* docs/reference/markdown/stylesheets/extra.css (.md-typeset code):
 	Add rule `white-space'.
 
 2018-09-03  Werner Lemberg  <wl@gnu.org>
 
 	*/*: s/PSNames/psnames/.
 
 	Only tracing messages are affected.
 
 2018-09-03  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix heap buffer overflow in CPAL handling.
 
 	* src/sfnt/ttcpal.c (tt_face_palette_set): Fix boundary test.
 	(tt_face_load_cpal): Updated.
 
 2018-09-01  Werner Lemberg  <wl@gnu.org>
 
 	Remove `FT_Outline_{New,Done}_Internal'.
 
 	These public API functions(!) were always undocumented and have
 	escaped all clean-up efforts until now.
 
 	* include/freetype/ftoutln.h (FT_Outline_New_Internal,
 	FT_Outline_Done_Internal): Removed.
 
 	* src/base/ftoutln.h (FT_Outline_New_Internal,
 	FT_Outline_Done_Internal): Merge into...
 	(FT_Outline_New, FT_Outline_Done): ... these functions.
 
 	* docs/README: Updated.
 
 2018-08-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): Check glyph format.
 
 2018-08-31  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	[errors] Refine the macro logic surrounding `FT_Error_String'.
 
 	* include/freetype/fterrors.h (FT_INCLUDE_ERR_PROTOS,
 	FT_ERR_PROTOS_DEFINED): Undefine `FT_INCLUDE_ERR_PROTOS' after
 	checking it and introduce a new macro that takes proper care of
 	multiple-inclusion protection.
 
 2018-08-31  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftdebug.c (FT_Throw): Restore missing `FT_UNUSED' calls.
 
 2018-08-31  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftdebug.c (FT_Throw): Reduce chattiness.
 
 2018-08-31  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/afhints.c (af_glyph_hints_reload): Add initialization.
 
 2018-08-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	Consolidate bitmap presetting and size assessment.
 
 	* include/freetype/internal/ftobjs.h (ft_glyphslot_preset_bitmap):
 	Change return type.
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): Return the bitmap
 	size assessment.
 
 	* src/raster/ftrend1.c (ft_raster1_render): Use it to refuse the
 	rendering of enourmous or far-fetched outlines.
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Ditto.
 
 2018-08-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): Correct mono.
 
 2018-08-30  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	[errors] Introduce a macro to control `FT_Error_String'.
 
 	* devel/ftoption.h (FT_CONFIG_OPTION_ERROR_STRINGS),
 	include/freetype/config/ftoption.h (FT_CONFIG_OPTION_ERROR_STRINGS):
 	New macro.
 
 2018-08-30  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	[errors] Introduce `FT_Error_String'.
 
 	* include/freetype/fterrors.h (FT_Error_String),
 	src/base/fterrors.c (FT_Error_String): Implement `FT_Error_String'.
 
 	* src/base/ftbase.c, src/base/Jamfile (_source),
 	src/base/rules.mk (BASE_SRC): Add `fterrors.c' to the build logic.
 
 	* src/base/ftdebug.c (FT_Throw): Use `FT_Error_String'.
 
 2018-08-30  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Trace `before' and `after' edges of strong points.
 
 	* src/autofit/afhints.h (AF_PointRec) [FT_DEBUG_AUTOFIT]: New arrays
 	`before' and `after'.
 
 	* src/autofit/afhints.c (af_get_strong_edge_index): New auxiliary
 	function.
 	(af_glyph_hints_dump_points): Trace `before' and `after' edges.
 	(af_glyph_hints_align_strong_points) [FT_DEBUG_AUTOFIT]: Set
 	`before' and `after' information.
 
 2018-08-30  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] Overflow-resistant bitmap presetting.
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): Implement it.
 
 2018-08-29  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	Fix numeric overflows.
 
 	* src/pshint/pshalgo.c (psh_hint_align, psh_hint_align_light,
 	psh_hint_table_find_strong_points): Fix numeric overflows.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10083
 
 2018-08-29  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix handling of `roll' op in old engine.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10080
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings) <cff_op_roll>
 	[CFF_CONFIG_OPTION_OLD_ENGINE]: Use modulo for loop count, as
 	documented in the specification.
 
 2018-08-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttobjs.c (tt_size_read_bytecode): Trace CVT values.
 
 2018-08-26  Nikhil Ramakrishnan  <ramakrishnan.nikhil@gmail.com>
 
 	* configure: Copy assets required by docwriter.
 
 	Copy directory `docs/reference/markdown' when FreeType is compiled in a
 	different directory.
 
 	Fixes `make refdoc' if builddir != srcdir.
 
 	Reported as
 
 	  https://lists.nongnu.org/archive/html/freetype-devel/2018-08/msg00083.html
 
 2018-08-26  Werner Lemberg  <wl@gnu.org>
 
 	* src/pshint/pshalgo.c (psh_hint_overlap): Fix numeric overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10057
 
 2018-08-26  Werner Lemberg  <wl@gnu.org>
 
 	Minor tracing adjustments.
 
 	* src/base/ftstream.c (FT_Stream_EnterFrame, FT_Stream_ExitFrame):
 	Trace.
 
 	* src/truetype/ttgload.c (TT_Access_Glyph_Frame): Remove tracing.
 
 2018-08-26  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Avoid nested frames.
 
 	Triggered by
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10054
 
 	* src/truetype/ttgload.c (load_truetype_glyph): Don't use variable
 	`opened_frame' to trace whether a frame must be closed at the end of
 	function: This fails because `TT_Vary_Apply_Glyph_Deltas' (which
 	gets called for space glyphs) uses a frame by itself.  Instead,
 	close the frame after loading the header, then use another frame for
 	the remaining part of the glyph later on.
 
 	Also avoid calling `tt_get_metrics' twice under some circumstances.
 
 2018-08-26  Werner Lemberg  <wl@gnu.org>
 
 	Various minor clean-ups.
 
 	* src/base/ftapi.c: Remove.  Unused.
 	* src/base/Jamfile (_sources): Updated.
 
 	* src/base/ftstream.c (FT_Stream_ReleaseFrame): Remove redundant
 	code.
 
 2018-08-25  Nikhil Ramakrishnan  <ramakrishnan.nikhil@gmail.com>
 
 	Convert documentation markup to Markdown.
 
 	It is the result of a GSoC 2018 project; this separate ChangeLog
 	commit covers the last four commits
 
 	  ae5d1a4cec37557f31aec270332cfe886a62f9a0
 	  53c69ce04faed3dcc68ca0f54cb8d703d8babf69
 	  195728d5ba38f34fb2c2c20807c01656f2f59b66
 	  c962db28ea59225f0105c03d907d4a9b71765687
 
 	* docs/reference/markdown/images/favico.ico,
 	docs/reference/markdown/javascripts/extra.js,
 	docs/reference/markdown/stylesheets/extra.css: New files.
 
 	* docs/reference/.gitignore, docs/reference/README: Updated.
 
 	* src/tools/docmaker/*: Removed.  It has been replaced with
 	`docwriter', a python package available at
 
 	  https://pypi.org/project/docwriter/
 
 	* Jamfile: Updated.
 	* builds/ansi/ansi-def.mk, builds/beos/beos-def.mk,
 	builds/dos/dos-def.mk, builds/os2/os2-def.mk (BIN),
 	builds/unix/unixddef.mk, builds/windows/win32-def.mk: New variable.
 
 	* builds/unix/configure.raw: Check for `python' and `pip'.
 	If not present, warn that `make refdoc' will fail.
 	* builds/unix/unix-def.in (PYTHON, PIP, BIN): New variables.
 
 	* builds/freetype.mk (PYTHON, PIP, VENV_NAME, VENV_DIR, ENV_PYTHON,
 	ENV_PIP): New variables.
 	(refdoc): Updated.
 	(refdoc-venv): New target.
 	(.PHONY): Updated.
 
 2018-08-23  Werner Lemberg  <wl@gnu.org>
 
 	Add macros for handling over-/underflowing `FT_Int64' values.
 
 	* include/freetype/internal/ftcalc.h (ADD_INT64, SUB_INT64,
 	MUL_INT64, DIV_INT64) [FT_LONG64]: New macros.
 
 	* src/base/ftcalc.c (ft_corner_orientation) [FT_LONG64]: Use
 	`SUB_INT64' and `MUL_INT64'.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=10028
 
 2018-08-22  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Improve legibility of `glyf' parsing.
 
 	* src/truetype/ttgload.c (ON_CURVE_POINT, X_SHORT_VECTOR,
 	Y_SHORT_VECTOR, REPEAT_FLAG, X_POSITIVE, SAME_X, Y_POSITIVE, SAME_Y,
 	OVERLAP_SIMPLE): New macros.
 	(TT_Load_Simple_Glyph): Use new macros to make code more readable.
 	Remove useless adjustment of `outline->tags' elements.
 
 2018-08-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttcpal.c (tt_face_load_cpal): Add missing safety check.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9981
 
 2018-08-18  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Avoid slow PS font parsing in case of error.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9955
 
 	* src/psaux/psobjs.c (ps_parser_to_bytes): Set `parser->cursor' even
 	in case of error to avoid potential re-scanning.
 
 2018-08-18  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix heap buffer overflow in old engine.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9967
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings)
 	<cff_op_blend> [CFF_CONFIG_OPTION_OLD_ENGINE]: `num_designs' must be
 	non-zero.
 
 2018-08-16  Young Xiao  <yangx92@hotmail.com>
 
 	* builds/mac/ftmac.c (parse_fond): Fix buffer overrun.
 
 	Reported as bug #54515, duplicate of #43540.
 
 2018-08-16  Werner Lemberg  <wl@gnu.org>
 
 	* builds/*/ftsystem.c (FT_COMPONENT): Updated also.
 
 2018-08-15  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[bdf] Don't track duplicate encodings.
 
 	There is no harm except some umbiguity in broken fonts with duplicate
 	encodings.
 
 	* src/bdf/bdflib.c (_bdf_parse_glyphs): Remove duplicate tracking.
 	(_bdf_parse_t): Remove large `have' bitfield.
 
 2018-08-15  Werner Lemberg  <wl@gnu.org>
 
 	Don't use `trace_' prefix for FT_COMPONENT arguments.
 
 	* include/freetype/internal/ftdebug.h (FT_TRACE_COMP,
 	FT_TRACE_COMP_): New auxiliary macros to add `trace_' prefix.
 	(FT_TRACE): Use `FT_TRACE_COMP'.
 
 	*/* (FT_COMPONENT): Updated.
 
 2018-08-14  Werner Lemberg  <wl@gnu.org>
 
 	Use formatting string in FT_TRACEX calls for non-simple arguments.
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings)
 	<cff_op_hstem, cff_op_hintmask, cff_op_hlineto, cff_op_vhcurveto>:
 	Do it.
 
 	* src/psaux/pshints.c (cf2_hintmap_build): Ditto.
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString) <cf2_cmdHSTEM,
 	cf2_cmdVSTEM, cf2_cmdHLINETO, cf2_cmdRRCURVETO, cf2_cmdCALLSUBR,
 	cf2_escHSTEM3, cf2_cmdHINTMASK, cf2_cmdHVCURVETO>: Ditto.
 
 	* src/truetype/ttinterp.c (TT_RunIns): Ditto.
 
 2018-08-14  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[bdf] Remove unused fields.
 
 	* src/bdf/bdf.h (bdf_font_t): Remove `nmod', `umod', and `modified',
 	which were set but never used.
 	* src/bdf/bdflib.c (_bdf_parse_{glyphs,properties}, bdf_load_font):
 	Updated accordingly.
 
 2018-08-14  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix another segv in old engine.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9872
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings)
 	[CFF_CONFIG_OPTION_OLD_ENGINE]: Disallow invalid T1 opcodes in
 	dictionaries.
 
 2018-08-14  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix missing error handling.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9865
 
 	* src/psaux/cffparse.c (cff_parser_run)
 	[CFF_CONFIG_OPTION_OLD_ENGINE]: Don't ignore return value of
 	`parse_charstrings_old'.
 
 2018-08-14  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[bdf] Remove unused overflow storage.
 
 	* src/bdf/bdf.h (bdf_glyphlist_t): Remove this type.
 	(bdf_font_t): Remove `overflow' field.
 	* src/bdf/bdflib.c (bdf_free_font): Remove `overflow' freeing.
 
 2018-08-14  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix segv in old engine.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9864
 
 	* src/psaux/cffdecode.c (cff_decoder_parse_charstrings)
 	<cff_op_random> [CFF_CONFIG_OPTION_OLD_ENGINE]: Use top dict's
 	`random' field directly if parsing dictionaries.
 
 2018-08-13  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[bdf] Use unsigned types.
 
 	* src/bdf/bdf.h (bdf_glyph_t): Unsign `encoding'.
 	(bdf_font_t): Unsign `default_char'.
 	* src/bdf/bdfdrivr.h (BDF_encoding_el): Unsign `enc'.
 
 	* src/bdf/bdflib.c (_bdf_add_property, _bdf_parse_glyphs,
 	_bdf_parse_start): Updated accordingly.
 	* src/bdf/bdfdrivr.c (bdf_cmap_char_{index,next}): Ditto.
 
 2018-08-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/type42/t42parse.c (t42_parse_sfnts): One more format check.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9832
 
 2018-08-11  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftcalc.c (FT_Matrix_Check): Fix integer overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9811
 
 2018-08-10  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/sfnt/ttsbit.c (tt_sbit_decoder_load_compound): Follow specs.
 
 2018-08-10  Ben Wagner  <bungeman@google.com>
 
 	* src/sfnt/sfobjs.c (sfnt_done_face): Fix memory leak (#54435).
 
 2018-08-10  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Render_Glyph_Internal): Improve tracing.
 
 2018-08-10  Werner Lemberg  <wl@gnu.org>
 
 	Fix clang warnings.
 
 	* src/base/ftdebug.c (ft_trace_level_enabled,
 	ft_trace_level_disabled): Add `static' keyword.
 
 2018-08-09  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[raster, smooth] Reinstate bitmap size limits.
 
 	This again moves outline and bitmap size checks one level up.
 
 	* src/base/ftoutln.c (FT_Outline_Render): Explicitly reject enormous
 	outlines.
 	* src/raster/ftrend1.c (ft_raster1_render): Reject enormous bitmaps
 	and, therefore, outlines that require them.
 	* src/smooth/ftsmooth.c (ft_smooth_render_generic): Ditto.
 
 	* src/raster/ftraster.c (ft_black_render): Remove outline size checks.
 	* src/smooth/ftgrays.c (gray_raster_render): Ditto.
 	[STANDALONE]: Remove `FT_Outline_Get_CBox' copy.
 
 2018-08-08  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[pcf] Revert massive unsigning.
 
 2018-08-08  Werner Lemberg  <wl@gnu.org>
 
 	[smooth] Improve tracing.
 
 	* src/smooth/ftgrays.c (gray_convert_glyph_inner): Only use tracing
 	if called the first time.
 	(gray_convert_glyph): Updated.
 
 2018-08-08  Werner Lemberg  <wl@gnu.org>
 
 	Add internal functions `FT_Trace_Disable' and `FT_Trace_Enable'.
 
 	It sometimes makes sense to suppress tracing informations, for
 	example, if it outputs identical messages again and again.
 
 	* include/freetype/internal/ftdebug.h: Make `ft_trace_levels' a
 	pointer.
 	(FT_Trace_Disable, FT_Trace_Enable): New declarations.
 
 	* src/base/ftdebug.c (ft_trace_levels): Rename to...
 	(ft_trace_levels_enabled): ... this.
 	(ft_trace_levels_disabled): New array.
 	(ft_trace_levels): New pointer.
 	(FT_Trace_Disable, FT_Trace_Enable): Implement.
 	(ft_debug_init): Updated.
 
 2018-08-08  Werner Lemberg  <wl@gnu.org>
 
 	Debugging improvements.
 
 	* src/base/ftobjs.c (pixel_modes): Move this array to top level
 	from ...
 	(FT_Load_Glyph): ... here.
 	(FT_Render_Glyph_Internal): Use `width' x `height' in trace message.
 	Use `pixel_modes'.
 
 2018-08-08  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[pcf] Massive unsigning (part 2).
 
 	Treat all size related properties as unsigned values.
 
 	* src/pcf/pcf.h (PCF_ParsePropertyRec): Use unsigned `name' and
 	`value'.
 	* src/pcf/pcfread.c (pcf_get_properties, pcf_load_font): Updated
 	parsing code and handling of AVERAGE_WIDTH, POINT_SIZE, PIXEL_SIZE,
 	RESOLUTION_X and RESOLUTION_Y.
 
 2018-08-08  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[pcf] Massive unsigning (part 1).
 
 	Unofficial specifications hesitate to use unsigned 32-bit integers.
 	Negative values caused a lot of trouble in the past and it is safer
 	and easier to treat some properties as unsigned.
 
 	* src/pcf/pcf.h (PCF_AccelRec): Use unsigned values for `fontAscent',
 	`fontDescent', and `maxOverlap'.
 	* src/pcf/pcfread.c (pcf_load_font, pcf_get_accel): Updated.
 	* src/pcf/pcfdrivr.c (PCF_Glyph_Load, PCF_Size_Select,
 	PCF_Size_Request): Updated.
 
 2018-08-07  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/pcf/pcfread.c (pcf_get_bitmaps): Unsign `offsets' and
 	`bitmapSizes'.
 
 2018-08-06  Werner Lemberg  <wl@gnu.org>
 
 	* devel/ftoption.h: Synchronize with main `ftoption.h'.
 
 2018-08-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[pcf] Use unsigned types.
 
 	* src/pcf/pcf.h (PCF_Encoding): Use unsigned `enc'.
 	* src/pcf/pcfdrivr.c (pcf_cmap_char_{index,next}): Ditto.
 	* src/pcf/pcfread.c (pcf_get_encodings): Use unsigned types.
 
 2018-08-05  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (compute_glyph_metrics): Fix overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/chromium/issues/detail?id=777151
 
 2018-08-04  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (opcode_name): Fix typos.
 
 2018-08-04  Werner Lemberg  <wl@gnu.org>
 
 	Fix clang warnings.
 
 	* src/base/ftoutln.c (FT_Outline_EmboldenXY): Fix type of
 	`orientation'.
 
 	* src/gxvalid/gxvcommn.c (gx_lookup_value_read): Fix signature.
 
 	* src/pcf/pcfread.c (pcf_get_encodings): Fix type of some variables.
 	Add cast.
 
 	* src/type1/t1load.c (parse_weight_vector): Fix cast.
 
 2018-07-31  Werner Lemberg  <wl@gnu.org>
 
 	* src/cid/cidtoken.h: Handle `XUID' keyword.
 
 2018-07-31  Werner Lemberg  <wl@gnu.org>
 
 	[cid] Trace PostScript dictionaries.
 
 	* src/cid/cidload.c: Include FT_INTERNAL_POSTSCRIPT_AUX_H.
 	(cid_load_keyword, cid_parse_font_matrix, parse_fd_array,
 	parse_expansion_factor, cid_parse_dict): Add tracing calls.
 	(parse_font_name): New function to trace `/FontName' keywords in
 	/FDArray dict.
 	(cid_field_records): Register `parse_font_name'.
 
 2018-07-30  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Fix typo.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9409
 
 	* src/cff/cffdrivr.c (cff_get_cid_from_glyph_index): Fix boundary
 	check.
 
 2018-07-29  Werner Lemberg  <wl@gnu.org>
 
 	* src/pcf/pcfread.c (pcf_get_encodings): Another thinko.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9608
 
 2018-07-28  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Fix Harmony memory management.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9501
 
 	* src/smooth/ftgrays.c (ft_smooth_render_generic): Restore buffer
 	after each rendering in case of failure.
 
 2018-07-28  Werner Lemberg  <wl@gnu.org>
 
 	[type1] Avoid segfaults with `FT_Get_PS_Font_Value'.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9610
 
 	* src/type1/t1driver.c (t1_ps_get_font_value): Protect against NULL.
 
 2018-07-27  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Make `TT_Set_MM_Blend' idempotent (#54388).
 
 	* src/truetype/ttgxvar.c (tt_set_mm_blend): Correctly set
 	`face->doblend' if the current call to the function yields the same
 	blend coordinates as the previous call.
 
 2018-07-27  Werner Lemberg  <wl@gnu.org>
 
 	[psaux, type1]: More tracing improvements.
 
 	* src/psaux/psintrp.c (cf2_interpT2CharString): Trace skipped
 	outline commands.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstring): Fix
 	missing case.
 	(t1_decoder_parse_metrics): Make tracing output more compact.
 
 	* src/type1/t1gload.c (T1_Compute_Max_Advance): Be less verbose.
 	(T1_Get_Advances): Add tracing.
 
 2018-07-25  Werner Lemberg  <wl@gnu.org>
 
 	[psaux, type1] Trace PostScript dictionaries and other things.
 
 	The tracing of /Encoding, /Subrs, and /Charstrings is rudimentary
 	right now.
 
 	* src/psaux/psobjs.c (ps_parser_load_field,
 	ps_parser_load_field_table): Add tracing calls.
 
 	* src/psaux/t1decode.c (t1_decoder_parse_charstrings): Make tracing
 	output more compact.
 
 	* src/type1/t1gload.c (T1_Compute_Max_Advance, T1_Get_Advances): Add
 	tracing messages.
 
 	* src/type1/t1load.c (parse_blend_axis_types,
 	parse_blend_design_positions, parse_blend_design_map,
 	parse_weight_vector, t1_load_keyword, t1_parse_font_matrix,
 	parse_encoding, parse_subrs, parse_charstrings, T1_Open_Face): Add
 	tracing calls.
 
 	* src/type1/t1objs.c (T1_Face_Init): Add tracing call.
 
 	* src/sfnt/sfobjs.c (sfnt_init_face): Make tracing message more
 	verbose.
 
 2018-07-25  Werner Lemberg  <wl@gnu.org>
 
 	Fix minor ASAN run-time warnings.
 
 	* src/base/ftutil.c (ft_mem_alloc, ft_mem_realloc): Only call
 	`FT_MEM_ZERO' if we actually have a buffer.
 	(ft_mem_dup): Only call `ft_memcpy' if we actually have a buffer.
 
 2018-07-24  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[build] Fortify dllexport/dllimport attributes (#53969,#54330).
 
 	We no longer use predefined _DLL, which can be defined for static
 	builds too with /MD. We use DLL_EXPORT and DLL_IMPORT instead,
 	following libtool convention.
 
 	* CMakeLists.txt [WIN32], builds/windows/vc2010/freetype.vcxproj:
 	Define DLL_EXPORT manually.
 
 	* include/freetype/config/ftconfig.h, builds/unix/ftconfig.in,
 	builds/vms/ftconfig.h, builds/windows/vc2010/index.html,
 	src/base/ftver.rc: /_DLL/d, s/FT2_DLLIMPORT/DLL_IMPORT/.
 
 2018-07-24  Werner Lemberg  <wl@gnu.org>
 
 	[type1] Check relationship between number of axes and designs.
 
 	For Multiple Masters fonts we don't support intermediate designs;
 	this implies that
 
 	  number_of_designs == 2 ^^ number_of_axes
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9557
 
 	* src/type1/t1load.c (T1_Open_Face): Ensure above constraint.
 	(T1_Get_MM_Var): Remove now redundant test.
 
 2018-07-24  Hin-Tak Leung  <htl10@users.sourceforge.net>
 
 	[truetype] Match ttdebug's naming of instruction mnemonics.
 
 	* src/truetype/ttinterp.c: The form used in ttdebug,
 	"MDRP[G,B,W,?]", etc., is slightly more readable than
 	"MDRP[00,01,02,03]".
 
 2018-07-24  Werner Lemberg  <wl@gnu.org>
 
 	* src/pcf/pcfread.c (pcf_get_encodings): Thinko.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9561
 
 2018-07-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/pcf/pcfread.c (pcf_get_encodings): Check index of defaultChar.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9527
 
 2018-07-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/pcf/pcfread.c (pcf_load_font): Fix number of glyphs.
 
 	This is an oversight of the module change 2018-07-21.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9524
 
 2018-07-22  Werner Lemberg  <wl@gnu.org>
 
 	[cid] Sanitize `BlueShift' and `BlueFuzz'.
 
 	This code is taken from the type1 module.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9510
 
 	* src/cid/cidload.c (parse_fd_array): Set some private dict default
 	values.
 	(cid_face_open): Do the sanitizing.
 	Fix some tracing messages.
 
 2018-07-21  Werner Lemberg  <wl@gnu.org>
 
 	[pcf] Fix handling of the undefined glyph.
 
 	This change makes the driver use the `defaultChar' property of PCF
 	files.
 
 	* src/pcf/pcf.h (PCF_FaceRec): Change type of `defaultChar' to
 	unsigned.
 
 	* src/pcf/pcfread.c (pcf_get_encodings): Read `defaultChar' as
 	unsigned.
 	Validate `defaultChar'.
 	If `defaultChar' doesn't point to glyph index zero, swap glyphs with
 	index zero and index `defaultChar' and adjust the encodings
 	accordingly.
 
 	* src/pcf/pcfdrivr.c (pcf_cmap_char_index, pcf_cmap_char_next,
 	PCF_Glyph_Load): Undo change from 2002-06-16 which always enforced
 	the first character in the font to be the default character.
 
 2018-07-20  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	Move the legacy fuzz target to the `freetype-testing' repository.
 
 	It can now be found at
 
 	  https://github.com/freetype/freetype2-testing/tree/master/fuzzing/src/legacy
 
 	* src/tools/ftfuzzer: Remove this folder and its contents from the
 	repository.
 
 2018-07-20  Werner Lemberg  <wl@gnu.org>
 
 	[cff] Avoid left-shift of negative numbers (#54322).
 
 	* src/cff/cffgload.c (cff_slot_load): Use multiplication.
 
 2018-07-17  Werner Lemberg  <wl@gnu.org>
 
 	Allow FT_ENCODING_NONE for `FT_Select_Charmap'.
 
 	This is a valid encoding tag for BDF, PCF, and Windows FNT, and
 	there is no reason to disallow it for these formats.
 
 	* src/base/ftobjs.c (FT_Select_Charmap): Implement it.
 
 2018-07-17  Werner Lemberg  <wl@gnu.org>
 
 	* src/pcf/pcfread.c (pcf_get_encodings): Trace `defaultChar'.
 
 2018-07-16  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	* include/freetype/internal/ftcalc.h: Add macros for handling
 	harmless over-/underflowing `FT_Int' values.
 
 	* src/sfnt/sfdriver.c (fixed2float): Fix negation of
 	`(int)(-2147483648)'.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9423
 
 2018-07-16  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (tt_set_mm_blend): Fix off-by-one error.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9412
 
 2018-07-12  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftoutln.c (FT_Outline_Get_Orientation): Init `cbox'.
 
 	Taken from patch #9667, written by Steve Langasek
 	<vorlon@debian.org>.
 
 	This fixes a build failure (most probably a bug in gcc) on ppc64el
 	when building with -O3.
 
 2018-07-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix typo (#54238).
 
 	* src/base/ftcolor.c (FT_Palette_Set_Foreground_Color)
 	[!TT_CONFIG_OPTION_COLOR_LAYERS]: Add return value.
 
 2018-07-05  Werner Lemberg  <wl@gnu.org>
 
 	Adjust table size comparisons (#54242).
 
 	* src/sfnt/ttcpal.c (tt_face_load_cpal): Implement it.
 
 2018-07-05  Werner Lemberg  <wl@gnu.org>
 
 	Fix more 32bit issues (#54208).
 
 	* src/cff/cffload.c (cff_blend_build_vector): Convert assertion into
 	run-time error.
 
 	* src/truetype/ttgxvar.c (ft_var_to_normalized): Protect against
 	numeric overflow.
 
 2018-07-04  Werner Lemberg  <wl@gnu.org>
 
 	Fix 32bit build warnings (#54239).
 
 	* src/base/ftbitmap.c (FT_Bitmap_Blend): Add casts to avoid signed
 	vs. unsigned comparisons.
 
 	* srb/sfnt/ttcolr.c (tt_face_get_colr_layer): Ditto.
 
 2018-07-02  Jeff Carey  <Jeff.Carey@monotype.com>
 
 	* src/psnames/psmodule.c (ps_unicodes_init): Fix alloc debugging.
 
 2018-07-02  Werner Lemberg  <wl@gnu.org>
 
 	s/palette_types/palette_flags/.
 
 	Suggested by Behdad.
 
 2018-07-02  Werner Lemberg  <wl@gnu.org>
 
 	Make `FT_Get_Color_Glyph_Layer' return FT_Bool.
 
 	* include/freetype/freetype.h, src/base/ftobjs.c
 	(FT_Get_Color_Glyph_Layer, FT_Render_Glyph_Internal): Updated.
 
 	* include/freetype/internal/sfnt.h (TT_Get_Colr_Layer_Func),
 	src/sfnt/ttcolr.h, src/sfnt/ttcolr.c (tt_face_get_colr_layer):
 	Updated.
 
 2018-07-01  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Get_Color_Glyph_Layer): Guard SFNT function.
 
 	Reported by Behdad.
 
 2018-06-28  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/base/fttrigon.c (FT_Tan): Improve accuracy.
 	(FT_Vector_Rotate): Simplify.
 
 2018-06-28  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* src/base/ftobjs.c (FT_Set_Charmap): Robustify.
 
 2018-06-25  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Fix memory leak.
 
 	* src/truetype/ttgxvar.c (TT_Vary_Apply_Glyph_Deltas): Add initializers.
 	Fix typo in `goto' destination.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9071
 
 2018-06-25  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgxvar.c (tt_face_vary_cvt): Add initializers.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=9070
 
 2018-06-24  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Increase precision while applying VF deltas.
 
 	It turned out that we incorrectly round CVT and glyph point deltas
 	before accumulation, leading to severe positioning errors if there
 	are many delta values to sum up.
 
 	Problem reported by Akiem Helmling <akiem@underware.nl> and analyzed
 	by Behdad.
 
 	* src/truetype/ttgxvar.c (ft_var_readpackeddelta): Return deltas in
 	16.16 format.
 	(tt_face_var_cvt): Collect deltas in `cvt_deltas', which is a 16.16
 	format array, and add the accumulated values to the CVT at the end
 	of the function.
 	(TT_Vary_Apply_Glyph_Deltas): Store data in `points_org' and
 	`points_out' in 16.16 format.
 	Collect deltas in `point_deltas_x' and `point_deltas_y', which are
 	16.16 format arrays, and add the accumulated values to the glyph
 	coordinates at the end of the function.
 
 2018-06-24  Werner Lemberg  <wl@gnu.org>
 
 	New base function `FT_Matrix_Check' (#54019).
 
 	* src/base/ftcalc.c (FT_Matrix_Check): New base function to properly
 	reject degenerate font matrices.
 
 	* include/freetype/internal/ftcalc.h: Updated.
 
 	* src/cff/cffparse.c (cff_parse_font_matrix), src/cid/cidload.c
 	(cid_parse_font_matrix), src/type1/t1load.c (t1_parse_font_matrix),
 	src/type42/t42parse.c (t42_parse_font_matrix): Use
 	`FT_Matrix_Check'.
 
 2018-06-23  Werner Lemberg  <wl@gnu.org>
 
 	Fix typo.
 
 	Reported by Behdad.
 
 	* src/base/ftcolor.c (FT_Palette_Data_Get)
 	[!TT_CONFIG_OPTION_COLOR_LAYERS]: s/apalette/apalette_data/.
 
 2018-06-21  Werner Lemberg  <wl@gnu.org>
 
 	s/FT_PALETTE_USABLE_WITH_/FT_PALETTE_FOR_/.
 
 	* include/freetype/ftcolor.h, include/freetype/internal/sfnt.h,
 	src/sfnt/ttcolr.c: Do it.
 
 2018-06-19  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix CPAL heap buffer overflow.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8968
 
 	* src/sfnt/ttcpal.c (tt_face_load_cpal): Guard CPAL version 1
 	offsets.
 
 2018-06-19  Werner Lemberg  <wl@gnu.org>
 
 	Doh.  Don't use CPAL or COLR data if tables are missing.
 
 	Reported by Alexei.
 
 	* src/sfnt/ttcolr.c (tt_face_get_colr_layer): Return immediately if
 	`colr' is NULL.
 
 	* src/sfnt/ttcpal.c (tt_face_palette_set): Return immediately, if
 	`cpal' is NULL.
 
 2018-06-17  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] Introduce `FT_New_Glyph'.
 
 	This function facilitates access to full capabilities of FreeType
 	rendering engine for custom glyphs. This can be quite useful for
 	consistent rendering of mathematical and chemical formulas, e.g.
 
 	  https://bugs.chromium.org/p/chromium/issues/detail?id=757078
 
 	* include/freetype/ftglyph.h, src/base/ftglyph.c (FT_New_Glyph): New
 	function.
 
 2018-06-17  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	[bdf] Fix underflow of an unsigned value.
 
 	bdflib.c:1562 could be reached with `font->glyphs_used == 0'.  That
 	caused an underflow of the unsigned value which results in undefined
 	behaviour.
 
 	* src/bdf/bdflib.c (_bdf_parse_glyphs): Bail out earlier than before
 	if the `ENCODING' keyword cannot be found.
 
 2018-06-17  Werner Lemberg  <wl@gnu.org>
 
 	[base] Add tracing for `FT_Bitmap_Blend'.
 
 	* include/freetype/internal/fttrace.h (trace_bitmap): New
 	enumeration.
 
 	* src/base/ftbitmap.c (FT_COMPONENT): Define.
 	(FT_Bitmap_Blend): Add `FT_TRACE5' calls.
 
 2018-06-17  Werner Lemberg  <wl@gnu.org>
 
 	s/trace_bitmap/trace_checksum/.
 
 	* include/freetype/internal/fttrace.h: s/bitmap/checksum/.
 
 	* src/base/ftobjs.c (FT_COMPONENT): s/trace_bitmap/trace_checksum/.
 	Adjust code.
 
 2018-06-16  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix color glyph layer loading.
 
 	* src/sfnt/ttcolr.c (Colr): Add `table_size' field.
 	(tt_face_load_colr): Set it.
 	(tt_face_get_colr_layer): Check pointer limit for layer entries.
 
 2018-06-16  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix color palette loading.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8933
 
 	* src/sfnt/ttcpal.c (Cpal): Add `table_size' field.
 	(tt_face_load_cpal): Set it.
 	(tt_face_palette_set): Check pointer limit for color entries.
 
 2018-06-16  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftbitmap.c (FT_Bitmap_Blend): Avoid integer overflow.
 
 2018-06-16  Werner Lemberg  <wl@gnu.org>
 
 	Add `FT_Bitmap_Blend' API.
 
 	Still missing: Support for negative bitmap pitch and subpixel offset
 	of source bitmap.
 
 	* include/freetype/ftbitmap.h, src/base/ftbitmap.c
 	(FT_Bitmap_Blend): New function.
 
 2018-06-14  Werner Lemberg  <wl@gnu.org>
 
 	Replace `FT_Get_GlyphLayers' with `FT_Get_Color_Glyph_Layer'.
 
 	This avoids any additional allocation of COLR related structures in
 	a glyph slot.
 
 	* include/freetype/freetype.h (FT_Glyph_Layer, FT_Glyph_LayerRec,
 	FT_Get_GlyphLayers): Removed.
 
 	* include/freetype/internal/ftobjs.h (FT_Colr_InternalRec): Removed.
 	(FT_Slot_InternalRec): Remove `color_layers'.
 
 	* include/freetype/internal/sfnt.h (TT_Load_Colr_Layer_Func):
 	Removed.
 	(SFNT_Interface, FT_DEFINE_SFNT_INTERFACE): Remove
 	`load_colr_layer'.
 
 	* src/base/ftobjs.c (ft_glyph_slot_done): Updated.
 	(FT_Render_Glyph_Internal): Use `FT_Get_Color_Glyph_Layer'.
 	(FT_Get_GlyphLayers): Removed.
 
 	* src/sfnt/sfdriver.c (sfnt_interface): Updated.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr_layers): Removed.
 	* src/sfnt/ttcolr.h: Updated.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Updated.
 
 2018-06-14  Werner Lemberg  <wl@gnu.org>
 
 	Provide iterative API to access `COLR' data.
 
 	This solution doesn't store any data in an `FT_GlyphSlot' object.
 
 	* include/freetype/freetype.h (FT_LayerIterator): New structure.
 	(FT_Get_Color_Glyph_Layer): New function.
 
 	* include/freetype/internal/sfnt.h (TT_Get_Colr_Layer_Func): New
 	function type.
 	(SFNT_Interface, FT_DEFINE_SFNT_INTERFACE): Add it.
 
 	* src/base/ftobjs.c (FT_Get_Color_Glyph_Layer): Implement it.
 
 	* src/sfnt/ttcolr.c (tt_face_get_colr_layer): New function.
 	* src/sfnt/ttcolr.h: Updated.
 
 	* src/sfnt/sfdriver.c (sfnt_interface): Updated.
 
 2018-06-14  Werner Lemberg  <wl@gnu.org>
 
 	Add glyph index and glyph load flags to glyph slot.
 
 	* include/freetype/freetype.h (FT_GlyphSlotRec): Rename unused
 	`reserved' field to `glyph_index'.
 
 	* include/freetype/internal/ftobjs.h (FT_Slot_InternalRec): Add
 	`load_flags' field.
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Set new fields.
 
 2018-06-14  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Move `CPAL' stuff into separate files.
 
 	* src/sfnt/sfdriver.c: Include `ttcpal.h'.
 	* src/sfnt/sfnt.c: Include `ttcpal.c'.
 
 	* src/sfnt/ttcolr.c, src/sfnt/ttcolr.h: Move CPAL stuff to ...
 	* src/sfnt/ttcpal.c, src/sfnt/ttcpal.c: ... these new files.
 
 	* src/sfnt/Jamfile (_sources), src/sfnt/rules.mk (SFNT_DRV_SRC):
 	Updated.
 
 	* include/freetype/internal/fttrace.h: Add support for `colr' and
 	`cpal'.
 	Sort entries.
 
 2018-06-13  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Separate `CPAL' and `COLR' table handling.
 
 	Later on we want to support the `SVG' table also, which needs `CPAL'
 	(but not `COLR').
 
 	* include/freetype/internal/sfnt.h (SFNT_Interface): Add `load_cpal'
 	and `free_cpal' fields.
 	(FT_DEFINE_SFNT_INTERFACE): Updated.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Replace
 	`colr_and_cpal' fields with `cpal' and `colr'.
 
 	* src/sfnt/sfdriver.c (sfnt_interface): Updated.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face, sfnt_done_face): Updated.
 
 	* src/sfnt/ttcolr.c (Colr, Cpal): Add `table' field.
 	(ColrCpal): Removed.
 	(tt_face_load_colr): Split off CPAL handling into...
 	(tt_face_load_cpal): ... this new function.
 	(tt_face_free_colr): Split off CPAL handling into...
 	(tt_face_free_cpal): ... this new function.
 	(tt_face_load_colr_layers, tt_face_palette_set): Updated.
 
 	* src/sfnt/ttcolr.h: Updated.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Updated.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix `sizeof' thinko.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr, tt_face_palette_set): Don't
 	use `sizeof' for computing array limit.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	Finish CPAL/COLR support (4/4).
 
 	* src/sfnt/ttcolr.c (tt_face_find_color): Removed.
 	(tt_face_colr_blend_layer): Use `face->palette' instead of calling
 	`tt_face_find_color'.
 	Use and set text foreground color.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	Finish CPAL/COLR support (3/4).
 
 	* src/base/ftcolor.c: Include FT_INTERNAL_SFNT_H.
 	(FT_Palette_Select, FT_Palette_Set_Foreground_Color): Implement
 	functions.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	Finish CPAL/COLR support (2/4).
 
 	* src/sfnt/ttcolr.c (tt_face_palette_set): New function.
 	(tt_face_load_colr): Allocate `face->palette' and call
 	`tt_face_palette_set'.
 	Adjust return error code in case of error.
 
 	* src/sfnt/ttcolr.h: Updated.
 
 	* include/freetype/internal/sfnt.h (TT_Set_Palette_Func): New
 	function type.
 	(SFNT_Interface, FT_DEFINE_SFNT_INTERFACE): Add it.
 
 	* src/sfnt/sfdriver.c (sfnt_interface), src/sfnt/sfobjs.c
 	(sfnt_done_face): Updated.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	Finish CPAL/COLR support (1/4).
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): New fields
 	`palette_index', `palette', `have_foreground_color' and
 	`foreground_color'.
 
 2018-06-12  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Minor.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr_layers):
 	s/palette_index/palette_entry_index/ for consistency.
 	Adjust return error code in case of error.
 
 2018-06-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[raster] Clean up.
 
 	* src/raster/ftraster.c (black_TWorker, SCALED, Set_High_Precision):
 	Clean up after 5-level gray removal (8dc8635874).
 	(Vertical_Sweep_Span): Be brief.
 
 2018-06-10  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix compiler warnings.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr, tt_face_load_colr_layers,
 	tt_face_colr_blend_layer): Add `NULL' initializers.
 
 2018-06-10  Werner Lemberg  <wl@gnu.org>
 
 	s/FT_Palette/FT_Palette_Data/, s/palette/palette_data/.
 
 	* include/freetype/ftcolor.h, include/freetype/internal/tttypes.h,
 	src/base/ftcolor.c, src/sfnt/sfobjs.c, src/sfnt/ttcolr.c: Updated.
 
 2018-06-10  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	CMakeLists: also accept IOS_PLATFORM=SIMULATOR64
 
 	This might be needed to build FreeType for the iOS simulator. See
 	https://savannah.nongnu.org/bugs/index.php?54048. Patch contributed
 	by Steve Robinson.
 
 	* CMakeLists.txt: Accept IOS_PLATFORM=SIMULATOR64
 
 2018-06-10  Werner Lemberg  <wl@gnu.org>
 
 	Implement `FT_Palette_Get'.
 
 	* src/base/ftcolor.c: New file.
 
 	* src/base/Jamefile (_sources), src/base/rules.mk (BASE_SRC),
 	src/base/ftbase.c: Add `ftcolor.c'.
 
 2018-06-10  Werner Lemberg  <wl@gnu.org>
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr): Improve overflow checks.
 
 2018-06-09  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[raster] Deal with pitch sign earlier.
 
 	* src/raster/ftraster.c (black_TWorker): Remove unused `traceG',
 	s/bTarget/bOrigin/.
 	(Render_Glyph): Set `ras.bOrigin' at the bottom-left corner.
 	(Vertical_Sweep_Init, {Vertical,Horizontal}_Sweep_{Span,Drop}):
 	Updated accordingly.
 
 2018-06-09  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Read `CPAL' version 1 tables.
 
 	* include/freetype/internal.tttypes.h: Include FT_COLOR_H.
 	(TT_FaceRec): Add `palette' field.
 
 	* src/sfnt/ttcolr.c: Include FT_COLOR_H.
 	(Cpal): Remove all data covered by the new `palette' field in
 	`TT_FaceRec'.
 	(tt_face_load_colr): Updated.
 	Read `CPAL' version 1 data.
 	(tt_face_load_colr_layers, tt_face_find_color): Updated.
 
 	* src/sfnt/sfobjs.c (sfnt_done_face): Free glyph color palette data.
 
 2018-06-07  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] API for Harmony LCD rendering.
 
 	This introduces `FT_Library_SetLcdGeometry' for setting up arbitrary
 	LCD subpixel geometry including non-striped patterns.
 
 	* src/base/ftlcdfil.c (FT_Library_SetLcdGeometry): New function.
 	* include/freetype/ftlcdfil.h: Document it.
 	* include/freetype/freetype.h: Minor.
 	* include/freetype/ftchapters.h: Minor.
 
 2018-06-06  Werner Lemberg  <wl@gnu.org>
 
 	ftcolor.h: Redesign API.
 
 	While going to implement it I noticed that I need access to most of
 	the `CPAL' elements; I thus plan to add a `cpal' field to
 	`TT_FaceRec', which makes most of the previously suggested API
 	functions obsolete because the fields will be directly accessible.
 
 2018-06-06  Parth Wazurkar  <parthwazurkar@gmail.com>
 
 	[bdf, pcf] Remove deprecated FT_FACE_FLAG_FAST_GLYPHS flag.
 
 	* src/bdf/bdfdrivr.c (BDF_Face_Init): Remove deprecated
 	FT_FACE_FLAG_FAST_GLYPHS flag.
 
 	* src/pcf/pcfread.c (pcf_load_font): Remove deprecated
 	FT_FACE_FLAG_FAST_GLYPHS flag.
 
 2018-06-06  Werner Lemberg  <wl@gnu.org>
 
 	[smooth, raster] Limit bitmap size (#54019).
 
 	* src/raster/ftraster.c [STANDALONE] (FT_Outline_Get_CBox): Add
 	function.
 	[!STANDALONE]: Include FT_OUTLINE_H.
 	(ft_black_render): Compute CBox and reject glyphs larger than
 	0xFFFF x 0xFFFF.
 
 	* src/smooth/ftgrays.c (gray_raster_render): Reject glyphs larger
 	than 0xFFFF x 0xFFFF.
 
 2018-06-03  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	* src/smooth/ftgrays.c (gray_convert_glyph): Remove unused variables.
 
 2018-06-03  Werner Lemberg  <wl@gnu.org>
 
 	* src/tools/glnames.py (main): Emit header in `light' comment style.
 
 2018-06-02  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Attempt to mitigate bug #54019.
 
 	The robust rendering of estra large glyphs came with unbearable cost.
 	The old way of bisecting should fail but fail faster.
 
 	* src/smooth/ftgrays.c (gray_convert_glyph): Switch back to bisecting
 	in y-direction.
 
 2018-06-02  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttinterp.c (Ins_MIRP): Use SUB_LONG; avoid FT_ABS.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8706
 
 2018-06-02  Werner Lemberg  <wl@gnu.org>
 
 	* src/autofit/afwarp.h: Use AF_CONFIG_OPTION_USE_WARPER (#54033).
 
 2018-05-31  Werner Lemberg  <wl@gnu.org>
 
 	* src/raster/ftraster.c (black_TWorker_): Remove `gTarget' field.
 
 	This is no longer used.
 
 2018-05-31  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Get colors from `CPAL' table in right order (#54015).
 
 	* src/sfnt/ttcolr.c (tt_face_find_color): Fix it.
 
 2018-05-30  Werner Lemberg  <wl@gnu.org>
 
 	ftcolor.h: Improve API design, fix typos (#54011, #54014).
 
 	* include/freetype/ftcolor.h (FT_Palette_Get_Names): Replace with...
 	(FT_Palette_Get_Name_IDs): ... this function.
 	(FT_Palette_Get_Entry_Names): Replace with...
 	(FT_Palette_Get_Entry_Name_IDs): ... this function
 	s/FT_Palette_Set_Foreground_COlor/FT_Palette_Set_Foreground_Color/.
 
 2018-05-30  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	Beautify a3cfed5e87232c933bdc64f43e8ebebcfd18b41b.
 
 	* src/autofit/afloader.c (af_loader_load_glyph): Move the
 	initialisationand declaration of variables into the if-block.
 
 2018-05-30  Armin Hasitzka  <prince.cherusker@gmail.com>
 
 	Fix pointer underflow.
 
 	The declaration of `edge2' can be reached with `edge1 == NULL' and
 	`axis->edges == 0' which results in undefined behaviour.
 
 	* src/autofit/afloader.c (af_loader_load_glyph): Initialise `edge2'
 	after checking `axis->num_edges > 1'.  `edge1 != NULL' can be assumed.
 
 2018-05-30  Werner Lemberg  <wl@gnu.org>
 
 	Various minor color fixes.
 
 	* include/freetype/config/ftheader.h (FT_COLOR_H): New macro.
 
 	* include/freetype/internal/ftobjs.h (FT_Colr_Internal): Change
 	type of `load_flags' to `FT_Int32'.
 
 	* include/freetype/internal/sfnt.h (TT_Load_Colr_Layer_Func): Change
 	type of `idx' to `FT_UInt'.
 	(TT_Blend_Colr_Func): Change type of `color_index' to `FT_UInt'.
 
 	* src/base/ftobjs.c (FT_Render_Glyph_Internal): Change type of
 	`load_flags' to `FT_Int32'.
 
 	* src/sfnt/ttcolr.c (find_base_glyph_record,
 	tt_face_load_colr_layers): Change type of `glyph_id' to `FT_UInt'.
 	(tt_face_find_color, tt_face_colr_blend_layer): Change type of
 	`color_index' to `FT_UInt'.
 	Fix signedness and type issues.
 
 	* src/sfnt/ttcolr.h: Updated.
 
 2018-05-25  Nikhil Ramakrishnan  <ramakrishnan.nikhil@gmail.com>
 
 	[docmaker] Fix missing `Defined in (...)' under Windows/Cygwin.
 
 	This platform uses backslashes for paths, which docmaker didn't
 	understand correctly.
 
 	* src/tools/docmaker/tohtml.py (HtmlFormatter::blockEnter): Use
 	`os.path.normpath' to normalize the path for the platform being
 	used.
 
 2018-05-24  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[smooth] Formalize Harmony LCD rendering.
 
 	This generalizes magic outline shifts that make Harmony LCD
 	rendering work in terms of precise two-dimensional RGB subpixel
 	positions. These coordinates are now set in time of the `smooth'
 	module initialization and later used to shift a glyph outline for
 	rendering. FT_RENDER_MODE_LCD and FT_RENDER_MODE_LCD_V use the same
 	coordinates. The letter, however, rotates them before using.
 	The LCD bitmap padding is also calculated using these coordinates.
 
 	* include/freetype/internal/ftobjs.h (FT_LibraryRec): New array field
 	`lcd_geometry'.
 	* src/base/ftlcdfil.c (ft_lcd_padding): Reworked.
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): Updated accordingly.
 
 	* src/smooth/ftsmooth.c [!FT_CONFIG_OPTION_SUBPIXEL_RENDERING]
 	(ft_smooth_init): Initialize `lcd_geometry'.
 	(ft_smooth_render_generic): Formalize outline shifts.
 
 2018-05-22  Werner Lemberg  <wl@gnu.org>
 
 	[truetype] Reject elements of composites with invalid glyph indices.
 
 	Reported as
 
 	  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8413
 
 	* src/truetype/ttgload.c (TT_Load_Composite_Glyph): Implement it.
 
 2018-05-22  Werner Lemberg  <wl@gnu.org>
 
 	* src/truetype/ttgload.c (TT_Load_Simple_Glyph): Trace # of points.
 
 2018-05-20  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/ftcolor.h: New file.
 
 	This is an interface to the `CPAL' OpenType table.  No
 	implementation yet.
 
 2018-05-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	* include/freetype/internal/ftcalc.h (FT_MSB): Verified `_MSC_VER'.
 
 	Actually `_BitScanReverse' is available since VS2005.
 
 2018-05-18  Werner Lemberg  <wl@gnu.org>
 
 	* include/freetype/internal/ftcalc.h (FT_MSB): Use `_MSC_VER' value.
 
 	Older VC versions don't provide `_BitScanReverse'.  We test for VC
 	2013.
 
 	Reported by John Emmas <john@creativepost.co.uk>.
 
 2018-05-17  Werner Lemberg  <wl@gnu.org>
 
 	s/inline/__inline/ for MSVC.
 
 	Reported by John Emmas <john@creativepost.co.uk>.
 
 	* include/freetype/internal/ftcalc.h (FT_MSB) [_MSC_VER]: Do it.
 
 2018-05-16  Werner Lemberg  <wl@gnu.org>
 
 	Add function `FT_Get_GlyphLayers' to access `COLR' table data.
 
 	* include/freetype/internal/ftobjs.h (FT_Glyph_LayerRec): Move this
 	structure to...
 	* include/freetype/freetype.h (FT_Glyph_LayerRec): ... this
 	header file.
 	(FT_Glyph_Layer): New typedef.
 	Update code to use it where appropriate.
 
 	* src/base/ftobjs.c (FT_Get_GlyphLayers): New function.
 
 2018-05-15  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
 	[base] Fix mono bitmap presetting (#53896).
 
 	It is rather fundamental to set monochrome bitmap based on rounded
 	CBox because the b/w rasterizer turns on pixels when their centers are
 	inside the glyph outline. The dropout control is unpredictable and can
 	distort narrow glyphs if the bitmap is too wide.
 
 	Reported by Chris Liddell.
 
 	* src/base/ftobjs.c (ft_glyphslot_preset_bitmap): If BBox boundaries
 	are too close, adjust them before rounding.
 
 2018-05-15  Werner Lemberg  <wl@gnu.org>
 
 	[psaux] Fix compiler warning (#53915).
 
 	* src/psaux/psft.c (cf2_freeT1SeacComponent): Do it.
 
 2018-05-15  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Fix memory leak in handling `COLR' data.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Free old `layers' array
 	before reassigning allocated memory.
 	Only allocate `color_layers' if we don't have one already.
 
 2018-05-15  Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] If `COLR' is present, don't assume that all glyphs use it.
 
 	* src/sfnt/ttcolr.c (tt_face_load_colr_layers): Return FT_Err_Ok if
 	current glyph is not a `COLR' base glyph.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Don't allocate
 	`color_layers' if there are no color layers.
 
 2018-05-14  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Fix signature of `pixel_modes'.
 
 2018-05-14  Werner Lemberg  <wl@gnu.org>
 
 	Provide dummy functions if `TT_CONFIG_OPTION_SFNT_NAMES' is not set.
 
 	* src/base/ftsnames.c [!TT_CONFIG_OPTION_SFNT_NAMES]: Implement it.
 
 2018-05-13  Werner Lemberg  <wl@gnu.org>
 
 	* src/base/ftobjs.c (FT_Load_Glyph): Improve tracing.
 
 2018-05-13  Shao Yu Zhang  <shaozhang@fb.com>
 	    Werner Lemberg  <wl@gnu.org>
 
 	[sfnt] Preliminary support of coloured layer outlines (#44689).
 
 	This commit enables OpenType's COLR/CPAL table handling; a typical
 	application are color emojis that can be scaled to any size.
 
 	If the color palette does not exist or is invalid, the rendering
 	step rasterizes the outline instead.  The current implementation
 	assumes that the foreground is black.
 
 	Enable this by defining option TT_CONFIG_OPTION_COLOR_LAYERS.
 
 	There are still some issues with metrics; additionally, an API to
 	fetch color layers is missing.
 
 	* devel/ftoption.h, include/freetype/config/ftoption.h
 	(TT_CONFIG_OPTION_COLOR_LAYERS): New macro.
 
 	* include/freetype/internal/ftobjs.h (FT_Glyph_LayerRec,
 	FT_Colr_InternalRec): New structures.
 	(FT_Slot_InternalRec): Add `color_layers' field.
 
 	* include/freetype/internal/sfnt.h (TT_Load_Colr_Layer_Func,
 	TT_Blend_Colr_Func): New function types.
 	(SFNT_Interface): Add `load_colr', `free_colr', `load_colr_layer',
 	and `colr_blend' fields.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Add
 	`colr_and_cpal' field.
 
 	* include/freetype/internal/tttags. (TTAG_COLR, TTAG_CPAL): New
 	macros.
 
 	* src/sfnt/ttcolr.c, src/sfnt/ttcolr.h: New files.
 
 	* src/base/ftobjs.c (ft_glyphslot_done, FT_Render_Glyph_Internal):
 	Handle glyph color layers.
 
 	* src/sfnt/Jamfile (_sources), src/sfnt/rules.mk (SFNT_DRV_SRC): Add
 	`ttcolr.c'.
 
 	* src/sfnt/sfdriver.c: Include `ttcolr.h'.
 	(PUT_COLOR_LAYERS): New macro.
 	Update call to `FT_DEFINE_SFNT_INTERFACE'.
 
 	* src/sfnt/sfnt.c: Include `ttcolr.c'.
 
 	* src/sfnt/sfobjs.c (sfnt_load_face): Load `COLR' and `CPAL' tables.
 	(sfnt_done_face): Updated.
 
 	* src/truetype/ttgload.c (TT_Load_Glyph): Handle color layers.
 
 2018-05-12  Arkady Shapkin  <arkady.shapkin@gmail.com>
 
 	Use MS VC++'s _BitScanReverse to calculate MSB (patch #9636).
 
 	* include/freetype/internal/ftcalc.h (FT_MSB) [_MSC_VER]: Implement
 	it.
 
 2018-05-10  Alan Coopersmith  <alan.coopersmith@oracle.com>
 
 	Fix DLL compilation on Solaris.
 
 	AC_COMPILE_IFELSE only tries to compile a `*.c' to a `*.o'.  The
 	Solaris Studio 12.1 through 12.5 compilers see the
 	`-fvisibility=hidden' flag, but ignore it with a warning of:
 
 	  cc: Warning: Option -fvisibility=hidden passed to ld,
 	               if ld is invoked, ignored otherwise
 
 	AC_LINK_IFELSE does the compile and then tries to link the result,
 	at which point the Solaris linker will issue an error:
 
 	  ld: fatal: option '-fvisibility=hidden' is incompatible with
 	      building a dynamic executable
 
 	If we don't use AC_LINK_IFELSE to catch the error, then configure
 	will fail further tests which attempt to link, such as those testing
 	dependencies like `libbz2'.
 
 	Also, don't try adding `-fvisibility' if we have already added
 	`-xldscope', just use one of them, since Sun Studio 12 and earlier
 	compilers only issue a warning, and don't try passing through to the
 	linker to generate an error, so AC_LINK_IFELSE doesn't catch them.
 
 	Tested on Solaris 11.4 beta with compiler versions:
 
 	  Sun Studio 8 (Sun C 5.5)
 	  Sun Studio 10 (Sun C 5.7)
 	  Sun Studio 11 (Sun C 5.8)
 	  Sun Studio 12 (Sun C 5.9)
 	  Sun Studio 12.1 (Sun C 5.10)
 	  Oracle Solaris Studio 12.2 (Sun C 5.11)
 	  Oracle Solaris Studio 12.3 (Sun C 5.12)
 	  Oracle Solaris Studio 12.4 (Sun C 5.13)
 	  Oracle Developer Studio 12.5 (Sun C 5.14)
 	  Oracle Developer Studio 12.6 (Sun C 5.15)
 	  gcc 5.5.0
 	  gcc 7.3.0
 
 	and verified the libfreetype.so.6 generated by each of those
 	compilers exported the same set of symbols.
 
 	* builds/unix/configure.raw: Implement it.
 
 2018-05-08  Werner Lemberg  <wl@gnu.org>
 
 	[autofit] Avoid potential SEGV if running out of memory.
 
 	Problem reported by Shailesh Mistry <shailesh.mistry@hotmail.co.uk>.
 
 	* src/autofit/afshaper.c (af_shaper_buf_create,
 	af_shaper_buf_destroy) [!FT_CONFIG_OPTION_USE_HARFBUZZ]: Don't
 	allocate and free a four-byte buffer.  Instead, make those functions
 	no-ops; the calling functions will provide a pointer to a buffer
 	instead.
 
 	* src/autofit/afcjk.c (af_cjk_metrics_init_widths,
 	af_cjk_metrics_init_blues, af_cjk_metrics_check_digits),
 	src/autofit/aflatin.c (af_latin_metrics_init_widths,
 	af_latin_metrics_init_blues, af_latin_metrics_check_digits)
 	[!FT_CONFIG_OPTION_USE_HARFBUZZ]: Use pointer to local variable for
 	`shaper_buf'.
 
 2018-05-07  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	[cmake] Allow using project as subfolder in other project.
 
 	* CMakeLists.txt: Test for CMake build directory being different
 	from source directory.  Provide other parts of the build system
 	access the full include directory.
 
 2018-05-07  Werner Lemberg  <wl@gnu.org>
 
 	[build] Suppress configure's `nothing to be done' message.
 
 	This is due to calling the configure script via `make' (within the
 	top-level `configure' wrapper script).  The same can happen for all
 	other secondary make targets that are used to only modify the
 	primary one, e.g., `make setup devel'.
 
 	* builds/dos/detect.mk (emx, turboc, watcom, borlandc, borlandc16),
 	builds/os2/detect (visualage, watcom, borlandc, devel),
 	builds/unix/detect.mk (devel, lcc, unix), builds/windows/detect.mk
 	(visualc, watcom, visualage, lcc, mingw32, bcc32, devel-bcc,
 	devel-gcc): Use no-op recipe.
 
 2018-05-04  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	Support symbol visibility features of Sun / Oracle C compilers.
 
 	Reported by Kiyoshi Kanazawa:
 	https://lists.gnu.org/archive/html/freetype-devel/2018-05/msg00008.html
 	Thanks to the suggestions by Alexei and Alan Coopersmith.
 
 	* builds/unix/configure.raw: Check if "-xldscope=hidden" is
 	accepted, and if so, it is added to CFLAGS.  This is the option
 	making Sun / Oracle C compilers hide the symbols from global
 	scope.
 	* include/freetype/config/ftconfig.h: Use "__global" prefix
 	for FT_EXPORT() macro, if SunPro C is newer than Sun ONE
 	Studio 8 (2003).
 	* builds/unix/ftconfig.in: Ditto.
 	* builds/vms/ftconfig.h: Ditto.
 
 2018-05-02  Nikolaus Waxweiler  <madigens@gmail.com>
 
 	Unbreak CMake Windows installation
 
 	* CMakeLists.txt: Generate ftconfig.h on non-UNIX.
 
 2018-05-02  Werner Lemberg  <wl@gnu.org>
 
 	Remove FT_CONFIG_OPTION_PIC and related code.
 
 	*/* [FT_CONFIG_OPTION_PIC]: Remove all code guarded by this
 	preprocessor symbol.
 
 	*/*: Replace `XXX_GET' macros (which could be either a function in
 	PIC mode or an array in non-PIC mode) with `xxx' arrays.
 
 	* include/freetype/internal/ftpic.h, src/autofit/afpic.c,
 	src/autofit/afpic.h, src/base/basepic.c, src/base/basepic.h,
 	src/base/ftpic.c, src/cff/cffpic.c, src/cff/cffpic.h,
 	src/pshinter/pshpic.c, src/pshinter/pshpic.h, src/psnames/pspic.c,
 	src/psnames/pspic.h, src/raster/rastpic.c, src/raster/rastpic.h,
 	src/sfnt/sfntpic.c, src/sfnt/sfntpic.h, src/smooth/ftspic.c,
 	src/smooth/ftspic.h, src/truetype/ttpic.c, src/truetype/ttpic.h:
 	Removed.
 
 
 ----------------------------------------------------------------------------
diff --git a/src/truetype/ttgload.c b/src/truetype/ttgload.c
index d4a87ef09..0111c4053 100644
--- a/src/truetype/ttgload.c
+++ b/src/truetype/ttgload.c
@@ -1,2956 +1,2995 @@
 /****************************************************************************
  *
  * ttgload.c
  *
  *   TrueType Glyph Loader (body).
  *
  * Copyright (C) 1996-2019 by
  * David Turner, Robert Wilhelm, and Werner Lemberg.
  *
  * This file is part of the FreeType project, and may only be used,
  * modified, and distributed under the terms of the FreeType project
  * license, LICENSE.TXT.  By continuing to use, modify, or distribute
  * this file you indicate that you have read the license and
  * understand and accept it fully.
  *
  */
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_DEBUG_H
 #include FT_CONFIG_CONFIG_H
 #include FT_INTERNAL_CALC_H
 #include FT_INTERNAL_STREAM_H
 #include FT_INTERNAL_SFNT_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_OUTLINE_H
 #include FT_DRIVER_H
 #include FT_LIST_H
 
 #include "ttgload.h"
 #include "ttpload.h"
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 #include "ttgxvar.h"
 #endif
 
 #include "tterrors.h"
 #include "ttsubpix.h"
 
 
   /**************************************************************************
    *
    * The macro FT_COMPONENT is used in trace mode.  It is an implicit
    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
    * messages during execution.
    */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  ttgload
 
 
   /**************************************************************************
    *
    * Simple glyph flags.
    */
 #define ON_CURVE_POINT  0x01  /* same value as FT_CURVE_TAG_ON            */
 #define X_SHORT_VECTOR  0x02
 #define Y_SHORT_VECTOR  0x04
 #define REPEAT_FLAG     0x08
 #define X_POSITIVE      0x10  /* two meanings depending on X_SHORT_VECTOR */
 #define SAME_X          0x10
 #define Y_POSITIVE      0x20  /* two meanings depending on Y_SHORT_VECTOR */
 #define SAME_Y          0x20
 #define OVERLAP_SIMPLE  0x40  /* we ignore this value                     */
 
 
   /**************************************************************************
    *
    * Composite glyph flags.
    */
 #define ARGS_ARE_WORDS             0x0001
 #define ARGS_ARE_XY_VALUES         0x0002
 #define ROUND_XY_TO_GRID           0x0004
 #define WE_HAVE_A_SCALE            0x0008
 /* reserved                        0x0010 */
 #define MORE_COMPONENTS            0x0020
 #define WE_HAVE_AN_XY_SCALE        0x0040
 #define WE_HAVE_A_2X2              0x0080
 #define WE_HAVE_INSTR              0x0100
 #define USE_MY_METRICS             0x0200
 #define OVERLAP_COMPOUND           0x0400  /* we ignore this value */
 #define SCALED_COMPONENT_OFFSET    0x0800
 #define UNSCALED_COMPONENT_OFFSET  0x1000
 
 
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+#define IS_DEFAULT_INSTANCE( _face )             \
+          ( !( FT_IS_NAMED_INSTANCE( _face ) ||  \
+               FT_IS_VARIATION( _face )      ) )
+#else
+#define IS_DEFAULT_INSTANCE( _face )  1
+#endif
+
+
   /**************************************************************************
    *
    * Return the horizontal metrics in font units for a given glyph.
    */
   FT_LOCAL_DEF( void )
   TT_Get_HMetrics( TT_Face     face,
                    FT_UInt     idx,
                    FT_Short*   lsb,
                    FT_UShort*  aw )
   {
     ( (SFNT_Service)face->sfnt )->get_metrics( face, 0, idx, lsb, aw );
 
     FT_TRACE5(( "  advance width (font units): %d\n", *aw ));
     FT_TRACE5(( "  left side bearing (font units): %d\n", *lsb ));
   }
 
 
   /**************************************************************************
    *
    * Return the vertical metrics in font units for a given glyph.
    * See function `tt_loader_set_pp' below for explanations.
    */
   FT_LOCAL_DEF( void )
   TT_Get_VMetrics( TT_Face     face,
                    FT_UInt     idx,
                    FT_Pos      yMax,
                    FT_Short*   tsb,
                    FT_UShort*  ah )
   {
     if ( face->vertical_info )
       ( (SFNT_Service)face->sfnt )->get_metrics( face, 1, idx, tsb, ah );
 
     else if ( face->os2.version != 0xFFFFU )
     {
       *tsb = (FT_Short)( face->os2.sTypoAscender - yMax );
       *ah  = (FT_UShort)FT_ABS( face->os2.sTypoAscender -
                                 face->os2.sTypoDescender );
     }
 
     else
     {
       *tsb = (FT_Short)( face->horizontal.Ascender - yMax );
       *ah  = (FT_UShort)FT_ABS( face->horizontal.Ascender -
                                 face->horizontal.Descender );
     }
 
     FT_TRACE5(( "  advance height (font units): %d\n", *ah ));
     FT_TRACE5(( "  top side bearing (font units): %d\n", *tsb ));
   }
 
 
   static FT_Error
   tt_get_metrics( TT_Loader  loader,
                   FT_UInt    glyph_index )
   {
     TT_Face    face   = loader->face;
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 #endif
 
     FT_Error   error;
     FT_Stream  stream = loader->stream;
 
     FT_Short   left_bearing = 0, top_bearing = 0;
     FT_UShort  advance_width = 0, advance_height = 0;
 
     /* we must preserve the stream position          */
     /* (which gets altered by the metrics functions) */
     FT_ULong  pos = FT_STREAM_POS();
 
 
     TT_Get_HMetrics( face, glyph_index,
                      &left_bearing,
                      &advance_width );
     TT_Get_VMetrics( face, glyph_index,
                      loader->bbox.yMax,
                      &top_bearing,
                      &advance_height );
 
     if ( FT_STREAM_SEEK( pos ) )
       return error;
 
     loader->left_bearing = left_bearing;
     loader->advance      = advance_width;
     loader->top_bearing  = top_bearing;
     loader->vadvance     = advance_height;
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
     if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&
          loader->exec                                             )
     {
       loader->exec->sph_tweak_flags = 0;
 
       /* This may not be the right place for this, but it works...  */
       /* Note that we have to unconditionally load the tweaks since */
       /* it is possible that glyphs individually switch ClearType's */
       /* backward compatibility mode on and off.                    */
       sph_set_tweaks( loader, glyph_index );
     }
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 
     if ( !loader->linear_def )
     {
       loader->linear_def = 1;
       loader->linear     = advance_width;
     }
 
     return FT_Err_Ok;
   }
 
 
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 
   static void
   tt_get_metrics_incr_overrides( TT_Loader  loader,
                                  FT_UInt    glyph_index )
   {
     TT_Face  face = loader->face;
 
     FT_Short   left_bearing = 0, top_bearing = 0;
     FT_UShort  advance_width = 0, advance_height = 0;
 
 
     /* If this is an incrementally loaded font check whether there are */
     /* overriding metrics for this glyph.                              */
     if ( face->root.internal->incremental_interface                           &&
          face->root.internal->incremental_interface->funcs->get_glyph_metrics )
     {
       FT_Incremental_MetricsRec  incr_metrics;
       FT_Error                   error;
 
 
       incr_metrics.bearing_x = loader->left_bearing;
       incr_metrics.bearing_y = 0;
       incr_metrics.advance   = loader->advance;
       incr_metrics.advance_v = 0;
 
       error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                 face->root.internal->incremental_interface->object,
                 glyph_index, FALSE, &incr_metrics );
       if ( error )
         goto Exit;
 
       left_bearing  = (FT_Short)incr_metrics.bearing_x;
       advance_width = (FT_UShort)incr_metrics.advance;
 
 #if 0
 
       /* GWW: Do I do the same for vertical metrics? */
       incr_metrics.bearing_x = 0;
       incr_metrics.bearing_y = loader->top_bearing;
       incr_metrics.advance   = loader->vadvance;
 
       error = face->root.internal->incremental_interface->funcs->get_glyph_metrics(
                 face->root.internal->incremental_interface->object,
                 glyph_index, TRUE, &incr_metrics );
       if ( error )
         goto Exit;
 
       top_bearing    = (FT_Short)incr_metrics.bearing_y;
       advance_height = (FT_UShort)incr_metrics.advance;
 
 #endif /* 0 */
 
       loader->left_bearing = left_bearing;
       loader->advance      = advance_width;
       loader->top_bearing  = top_bearing;
       loader->vadvance     = advance_height;
 
       if ( !loader->linear_def )
       {
         loader->linear_def = 1;
         loader->linear     = advance_width;
       }
     }
 
   Exit:
     return;
   }
 
 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 
 
   /**************************************************************************
    *
    * The following functions are used by default with TrueType fonts.
    * However, they can be replaced by alternatives if we need to support
    * TrueType-compressed formats (like MicroType) in the future.
    *
    */
 
   FT_CALLBACK_DEF( FT_Error )
   TT_Access_Glyph_Frame( TT_Loader  loader,
                          FT_UInt    glyph_index,
                          FT_ULong   offset,
                          FT_UInt    byte_count )
   {
     FT_Error   error;
     FT_Stream  stream = loader->stream;
 
     FT_UNUSED( glyph_index );
 
 
     /* the following line sets the `error' variable through macros! */
     if ( FT_STREAM_SEEK( offset ) || FT_FRAME_ENTER( byte_count ) )
       return error;
 
     loader->cursor = stream->cursor;
     loader->limit  = stream->limit;
 
     return FT_Err_Ok;
   }
 
 
   FT_CALLBACK_DEF( void )
   TT_Forget_Glyph_Frame( TT_Loader  loader )
   {
     FT_Stream  stream = loader->stream;
 
 
     FT_FRAME_EXIT();
   }
 
 
   FT_CALLBACK_DEF( FT_Error )
   TT_Load_Glyph_Header( TT_Loader  loader )
   {
     FT_Byte*  p     = loader->cursor;
     FT_Byte*  limit = loader->limit;
 
 
     if ( p + 10 > limit )
       return FT_THROW( Invalid_Outline );
 
     loader->n_contours = FT_NEXT_SHORT( p );
 
     loader->bbox.xMin = FT_NEXT_SHORT( p );
     loader->bbox.yMin = FT_NEXT_SHORT( p );
     loader->bbox.xMax = FT_NEXT_SHORT( p );
     loader->bbox.yMax = FT_NEXT_SHORT( p );
 
     FT_TRACE5(( "  # of contours: %d\n", loader->n_contours ));
     FT_TRACE5(( "  xMin: %4d  xMax: %4d\n", loader->bbox.xMin,
                                             loader->bbox.xMax ));
     FT_TRACE5(( "  yMin: %4d  yMax: %4d\n", loader->bbox.yMin,
                                             loader->bbox.yMax ));
     loader->cursor = p;
 
     return FT_Err_Ok;
   }
 
 
   FT_CALLBACK_DEF( FT_Error )
   TT_Load_Simple_Glyph( TT_Loader  load )
   {
     FT_Error        error;
     FT_Byte*        p          = load->cursor;
     FT_Byte*        limit      = load->limit;
     FT_GlyphLoader  gloader    = load->gloader;
     FT_Int          n_contours = load->n_contours;
     FT_Outline*     outline;
     FT_UShort       n_ins;
     FT_Int          n_points;
 
     FT_Byte         *flag, *flag_limit;
     FT_Byte         c, count;
     FT_Vector       *vec, *vec_limit;
     FT_Pos          x, y;
     FT_Short        *cont, *cont_limit, prev_cont;
     FT_Int          xy_size = 0;
 
 
     /* check that we can add the contours to the glyph */
     error = FT_GLYPHLOADER_CHECK_POINTS( gloader, 0, n_contours );
     if ( error )
       goto Fail;
 
     /* reading the contours' endpoints & number of points */
     cont       = gloader->current.outline.contours;
     cont_limit = cont + n_contours;
 
     /* check space for contours array + instructions count */
     if ( n_contours >= 0xFFF || p + ( n_contours + 1 ) * 2 > limit )
       goto Invalid_Outline;
 
     prev_cont = FT_NEXT_SHORT( p );
 
     if ( n_contours > 0 )
       cont[0] = prev_cont;
 
     if ( prev_cont < 0 )
       goto Invalid_Outline;
 
     for ( cont++; cont < cont_limit; cont++ )
     {
       cont[0] = FT_NEXT_SHORT( p );
       if ( cont[0] <= prev_cont )
       {
         /* unordered contours: this is invalid */
         goto Invalid_Outline;
       }
       prev_cont = cont[0];
     }
 
     n_points = 0;
     if ( n_contours > 0 )
     {
       n_points = cont[-1] + 1;
       if ( n_points < 0 )
         goto Invalid_Outline;
     }
 
     FT_TRACE5(( "  # of points: %d\n", n_points ));
 
     /* note that we will add four phantom points later */
     error = FT_GLYPHLOADER_CHECK_POINTS( gloader, n_points + 4, 0 );
     if ( error )
       goto Fail;
 
     /* reading the bytecode instructions */
     load->glyph->control_len  = 0;
     load->glyph->control_data = NULL;
 
     if ( p + 2 > limit )
       goto Invalid_Outline;
 
     n_ins = FT_NEXT_USHORT( p );
 
     FT_TRACE5(( "  Instructions size: %u\n", n_ins ));
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 
     if ( IS_HINTED( load->load_flags ) )
     {
       FT_ULong  tmp;
 
 
       /* check instructions size */
       if ( ( limit - p ) < n_ins )
       {
         FT_TRACE1(( "TT_Load_Simple_Glyph: instruction count mismatch\n" ));
         error = FT_THROW( Too_Many_Hints );
         goto Fail;
       }
 
       /* we don't trust `maxSizeOfInstructions' in the `maxp' table */
       /* and thus update the bytecode array size by ourselves       */
 
       tmp   = load->exec->glyphSize;
       error = Update_Max( load->exec->memory,
                           &tmp,
                           sizeof ( FT_Byte ),
                           (void*)&load->exec->glyphIns,
                           n_ins );
 
       load->exec->glyphSize = (FT_UShort)tmp;
       if ( error )
         return error;
 
       load->glyph->control_len  = n_ins;
       load->glyph->control_data = load->exec->glyphIns;
 
       if ( n_ins )
         FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
     }
 
 #endif /* TT_USE_BYTECODE_INTERPRETER */
 
     p += n_ins;
 
     outline = &gloader->current.outline;
 
     /* reading the point tags */
     flag       = (FT_Byte*)outline->tags;
     flag_limit = flag + n_points;
 
     FT_ASSERT( flag );
 
     while ( flag < flag_limit )
     {
       if ( p + 1 > limit )
         goto Invalid_Outline;
 
       *flag++ = c = FT_NEXT_BYTE( p );
       if ( c & REPEAT_FLAG )
       {
         if ( p + 1 > limit )
           goto Invalid_Outline;
 
         count = FT_NEXT_BYTE( p );
         if ( flag + (FT_Int)count > flag_limit )
           goto Invalid_Outline;
 
         for ( ; count > 0; count-- )
           *flag++ = c;
       }
     }
 
     /* reading the X coordinates */
 
     vec       = outline->points;
     vec_limit = vec + n_points;
     flag      = (FT_Byte*)outline->tags;
     x         = 0;
 
     if ( p + xy_size > limit )
       goto Invalid_Outline;
 
     for ( ; vec < vec_limit; vec++, flag++ )
     {
       FT_Pos   delta = 0;
       FT_Byte  f     = *flag;
 
 
       if ( f & X_SHORT_VECTOR )
       {
         if ( p + 1 > limit )
           goto Invalid_Outline;
 
         delta = (FT_Pos)FT_NEXT_BYTE( p );
         if ( !( f & X_POSITIVE ) )
           delta = -delta;
       }
       else if ( !( f & SAME_X ) )
       {
         if ( p + 2 > limit )
           goto Invalid_Outline;
 
         delta = (FT_Pos)FT_NEXT_SHORT( p );
       }
 
       x     += delta;
       vec->x = x;
     }
 
     /* reading the Y coordinates */
 
     vec       = gloader->current.outline.points;
     vec_limit = vec + n_points;
     flag      = (FT_Byte*)outline->tags;
     y         = 0;
 
     for ( ; vec < vec_limit; vec++, flag++ )
     {
       FT_Pos   delta = 0;
       FT_Byte  f     = *flag;
 
 
       if ( f & Y_SHORT_VECTOR )
       {
         if ( p + 1 > limit )
           goto Invalid_Outline;
 
         delta = (FT_Pos)FT_NEXT_BYTE( p );
         if ( !( f & Y_POSITIVE ) )
           delta = -delta;
       }
       else if ( !( f & SAME_Y ) )
       {
         if ( p + 2 > limit )
           goto Invalid_Outline;
 
         delta = (FT_Pos)FT_NEXT_SHORT( p );
       }
 
       y     += delta;
       vec->y = y;
 
       /* the cast is for stupid compilers */
       *flag  = (FT_Byte)( f & ON_CURVE_POINT );
     }
 
     outline->n_points   = (FT_Short)n_points;
     outline->n_contours = (FT_Short)n_contours;
 
     load->cursor = p;
 
   Fail:
     return error;
 
   Invalid_Outline:
     error = FT_THROW( Invalid_Outline );
     goto Fail;
   }
 
 
   FT_CALLBACK_DEF( FT_Error )
   TT_Load_Composite_Glyph( TT_Loader  loader )
   {
     FT_Error        error;
     FT_Byte*        p          = loader->cursor;
     FT_Byte*        limit      = loader->limit;
     FT_GlyphLoader  gloader    = loader->gloader;
     FT_Long         num_glyphs = loader->face->root.num_glyphs;
     FT_SubGlyph     subglyph;
     FT_UInt         num_subglyphs;
 
 
     num_subglyphs = 0;
 
     do
     {
       FT_Fixed  xx, xy, yy, yx;
       FT_UInt   count;
 
 
       /* check that we can load a new subglyph */
       error = FT_GlyphLoader_CheckSubGlyphs( gloader, num_subglyphs + 1 );
       if ( error )
         goto Fail;
 
       /* check space */
       if ( p + 4 > limit )
         goto Invalid_Composite;
 
       subglyph = gloader->current.subglyphs + num_subglyphs;
 
       subglyph->arg1 = subglyph->arg2 = 0;
 
       subglyph->flags = FT_NEXT_USHORT( p );
       subglyph->index = FT_NEXT_USHORT( p );
 
       /* we reject composites that have components */
       /* with invalid glyph indices                */
       if ( subglyph->index >= num_glyphs )
         goto Invalid_Composite;
 
       /* check space */
       count = 2;
       if ( subglyph->flags & ARGS_ARE_WORDS )
         count += 2;
       if ( subglyph->flags & WE_HAVE_A_SCALE )
         count += 2;
       else if ( subglyph->flags & WE_HAVE_AN_XY_SCALE )
         count += 4;
       else if ( subglyph->flags & WE_HAVE_A_2X2 )
         count += 8;
 
       if ( p + count > limit )
         goto Invalid_Composite;
 
       /* read arguments */
       if ( subglyph->flags & ARGS_ARE_XY_VALUES )
       {
         if ( subglyph->flags & ARGS_ARE_WORDS )
         {
           subglyph->arg1 = FT_NEXT_SHORT( p );
           subglyph->arg2 = FT_NEXT_SHORT( p );
         }
         else
         {
           subglyph->arg1 = FT_NEXT_CHAR( p );
           subglyph->arg2 = FT_NEXT_CHAR( p );
         }
       }
       else
       {
         if ( subglyph->flags & ARGS_ARE_WORDS )
         {
           subglyph->arg1 = (FT_Int)FT_NEXT_USHORT( p );
           subglyph->arg2 = (FT_Int)FT_NEXT_USHORT( p );
         }
         else
         {
           subglyph->arg1 = (FT_Int)FT_NEXT_BYTE( p );
           subglyph->arg2 = (FT_Int)FT_NEXT_BYTE( p );
         }
       }
 
       /* read transform */
       xx = yy = 0x10000L;
       xy = yx = 0;
 
       if ( subglyph->flags & WE_HAVE_A_SCALE )
       {
         xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
         yy = xx;
       }
       else if ( subglyph->flags & WE_HAVE_AN_XY_SCALE )
       {
         xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
         yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
       }
       else if ( subglyph->flags & WE_HAVE_A_2X2 )
       {
         xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
         yx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
         xy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
         yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
       }
 
       subglyph->transform.xx = xx;
       subglyph->transform.xy = xy;
       subglyph->transform.yx = yx;
       subglyph->transform.yy = yy;
 
       num_subglyphs++;
 
     } while ( subglyph->flags & MORE_COMPONENTS );
 
     gloader->current.num_subglyphs = num_subglyphs;
     FT_TRACE5(( "  %d component%s\n",
                 num_subglyphs,
                 num_subglyphs > 1 ? "s" : "" ));
 
 #ifdef FT_DEBUG_LEVEL_TRACE
     {
       FT_UInt  i;
 
 
       subglyph = gloader->current.subglyphs;
 
       for ( i = 0; i < num_subglyphs; i++ )
       {
         if ( num_subglyphs > 1 )
           FT_TRACE7(( "    subglyph %d:\n", i ));
 
         FT_TRACE7(( "      glyph index: %d\n", subglyph->index ));
 
         if ( subglyph->flags & ARGS_ARE_XY_VALUES )
           FT_TRACE7(( "      offset: x=%d, y=%d\n",
                       subglyph->arg1,
                       subglyph->arg2 ));
         else
           FT_TRACE7(( "      matching points: base=%d, component=%d\n",
                       subglyph->arg1,
                       subglyph->arg2 ));
 
         if ( subglyph->flags & WE_HAVE_A_SCALE )
           FT_TRACE7(( "      scaling: %f\n",
                       subglyph->transform.xx / 65536.0 ));
         else if ( subglyph->flags & WE_HAVE_AN_XY_SCALE )
           FT_TRACE7(( "      scaling: x=%f, y=%f\n",
                       subglyph->transform.xx / 65536.0,
                       subglyph->transform.yy / 65536.0 ));
         else if ( subglyph->flags & WE_HAVE_A_2X2 )
           FT_TRACE7(( "      scaling: xx=%f, yx=%f\n"
                       "               xy=%f, yy=%f\n",
                       subglyph->transform.xx / 65536.0,
                       subglyph->transform.yx / 65536.0,
                       subglyph->transform.xy / 65536.0,
                       subglyph->transform.yy / 65536.0 ));
 
         subglyph++;
       }
     }
 #endif /* FT_DEBUG_LEVEL_TRACE */
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 
     {
       FT_Stream  stream = loader->stream;
 
 
       /* we must undo the FT_FRAME_ENTER in order to point */
       /* to the composite instructions, if we find some.   */
       /* We will process them later.                       */
       /*                                                   */
       loader->ins_pos = (FT_ULong)( FT_STREAM_POS() +
                                     p - limit );
     }
 
 #endif
 
     loader->cursor = p;
 
   Fail:
     return error;
 
   Invalid_Composite:
     error = FT_THROW( Invalid_Composite );
     goto Fail;
   }
 
 
   FT_LOCAL_DEF( void )
   TT_Init_Glyph_Loading( TT_Face  face )
   {
     face->access_glyph_frame   = TT_Access_Glyph_Frame;
     face->read_glyph_header    = TT_Load_Glyph_Header;
     face->read_simple_glyph    = TT_Load_Simple_Glyph;
     face->read_composite_glyph = TT_Load_Composite_Glyph;
     face->forget_glyph_frame   = TT_Forget_Glyph_Frame;
   }
 
 
   static void
   tt_prepare_zone( TT_GlyphZone  zone,
                    FT_GlyphLoad  load,
                    FT_UInt       start_point,
                    FT_UInt       start_contour )
   {
     zone->n_points    = (FT_UShort)load->outline.n_points -
                           (FT_UShort)start_point;
     zone->n_contours  = load->outline.n_contours -
                           (FT_Short)start_contour;
     zone->org         = load->extra_points + start_point;
     zone->cur         = load->outline.points + start_point;
     zone->orus        = load->extra_points2 + start_point;
     zone->tags        = (FT_Byte*)load->outline.tags + start_point;
     zone->contours    = (FT_UShort*)load->outline.contours + start_contour;
     zone->first_point = (FT_UShort)start_point;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Hint_Glyph
    *
    * @Description:
    *   Hint the glyph using the zone prepared by the caller.  Note that
    *   the zone is supposed to include four phantom points.
    */
   static FT_Error
   TT_Hint_Glyph( TT_Loader  loader,
                  FT_Bool    is_composite )
   {
 #if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
     defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
     TT_Face    face   = loader->face;
     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 #endif
 
     TT_GlyphZone  zone = &loader->zone;
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
     FT_Long       n_ins;
 #else
     FT_UNUSED( is_composite );
 #endif
 
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
     n_ins = loader->glyph->control_len;
 
     /* save original point positions in `org' array */
     if ( n_ins > 0 )
       FT_ARRAY_COPY( zone->org, zone->cur, zone->n_points );
 
     /* Reset graphics state. */
     loader->exec->GS = loader->size->GS;
 
     /* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
     /*      completely refer to the (already) hinted subglyphs.     */
     if ( is_composite )
     {
       loader->exec->metrics.x_scale = 1 << 16;
       loader->exec->metrics.y_scale = 1 << 16;
 
       FT_ARRAY_COPY( zone->orus, zone->cur, zone->n_points );
     }
     else
     {
       loader->exec->metrics.x_scale = loader->size->metrics->x_scale;
       loader->exec->metrics.y_scale = loader->size->metrics->y_scale;
     }
 #endif
 
     /* round phantom points */
     zone->cur[zone->n_points - 4].x =
       FT_PIX_ROUND( zone->cur[zone->n_points - 4].x );
     zone->cur[zone->n_points - 3].x =
       FT_PIX_ROUND( zone->cur[zone->n_points - 3].x );
     zone->cur[zone->n_points - 2].y =
       FT_PIX_ROUND( zone->cur[zone->n_points - 2].y );
     zone->cur[zone->n_points - 1].y =
       FT_PIX_ROUND( zone->cur[zone->n_points - 1].y );
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 
     if ( n_ins > 0 )
     {
       FT_Error  error;
 
       FT_GlyphLoader  gloader         = loader->gloader;
       FT_Outline      current_outline = gloader->current.outline;
 
 
       TT_Set_CodeRange( loader->exec, tt_coderange_glyph,
                         loader->exec->glyphIns, n_ins );
 
       loader->exec->is_composite = is_composite;
       loader->exec->pts          = *zone;
 
       error = TT_Run_Context( loader->exec );
       if ( error && loader->exec->pedantic_hinting )
         return error;
 
       /* store drop-out mode in bits 5-7; set bit 2 also as a marker */
       current_outline.tags[0] |=
         ( loader->exec->GS.scan_type << 5 ) | FT_CURVE_TAG_HAS_SCANMODE;
     }
 
 #endif
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
     /* Save possibly modified glyph phantom points unless in v40 backward  */
     /* compatibility mode, where no movement on the x axis means no reason */
     /* to change bearings or advance widths.                               */
     if ( !( driver->interpreter_version == TT_INTERPRETER_VERSION_40 &&
             loader->exec->backward_compatibility ) )
     {
 #endif
       loader->pp1 = zone->cur[zone->n_points - 4];
       loader->pp2 = zone->cur[zone->n_points - 3];
       loader->pp3 = zone->cur[zone->n_points - 2];
       loader->pp4 = zone->cur[zone->n_points - 1];
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
     }
 #endif
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
     if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
     {
       if ( loader->exec->sph_tweak_flags & SPH_TWEAK_DEEMBOLDEN )
         FT_Outline_EmboldenXY( &loader->gloader->current.outline, -24, 0 );
 
       else if ( loader->exec->sph_tweak_flags & SPH_TWEAK_EMBOLDEN )
         FT_Outline_EmboldenXY( &loader->gloader->current.outline, 24, 0 );
     }
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Process_Simple_Glyph
    *
    * @Description:
    *   Once a simple glyph has been loaded, it needs to be processed.
    *   Usually, this means scaling and hinting through bytecode
    *   interpretation.
    */
   static FT_Error
   TT_Process_Simple_Glyph( TT_Loader  loader )
   {
     FT_GlyphLoader  gloader = loader->gloader;
     FT_Error        error   = FT_Err_Ok;
     FT_Outline*     outline;
-    FT_Vector*      unrounded;
     FT_Int          n_points;
 
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+    FT_Memory   memory    = loader->face->root.memory;
+    FT_Vector*  unrounded = NULL;
+#endif
+
 
     outline  = &gloader->current.outline;
     n_points = outline->n_points;
 
     /* set phantom points */
 
     outline->points[n_points    ] = loader->pp1;
     outline->points[n_points + 1] = loader->pp2;
     outline->points[n_points + 2] = loader->pp3;
     outline->points[n_points + 3] = loader->pp4;
 
     outline->tags[n_points    ] = 0;
     outline->tags[n_points + 1] = 0;
     outline->tags[n_points + 2] = 0;
     outline->tags[n_points + 3] = 0;
 
     n_points += 4;
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
-    if ( FT_IS_NAMED_INSTANCE( FT_FACE( loader->face ) ) ||
-         FT_IS_VARIATION( FT_FACE( loader->face ) )      )
+    if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )
     {
-      /* Deltas apply to the unscaled data.                           */
-      /* We temporarily use `extra_points2' to hold unrounded values. */
-      unrounded = gloader->current.extra_points2;
+      if ( FT_NEW_ARRAY( unrounded, n_points ) )
+        goto Exit;
+
+      /* Deltas apply to the unscaled data. */
       error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                           loader->glyph_index,
                                           outline,
                                           unrounded,
                                           (FT_UInt)n_points );
 
       /* recalculate linear horizontal and vertical advances */
       /* if we don't have HVAR and VVAR, respectively        */
 
       /* XXX: change all FreeType modules to store `linear' and `vadvance' */
       /*      in 26.6 format before the `base' module scales them to 16.16 */
       if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
         loader->linear = FT_PIX_ROUND( unrounded[n_points - 3].x -
                                        unrounded[n_points - 4].x ) / 64;
       if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
         loader->vadvance = FT_PIX_ROUND( unrounded[n_points - 1].x -
                                          unrounded[n_points - 2].x ) / 64;
 
       if ( error )
-        return error;
+        goto Exit;
     }
 
 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
+    if ( IS_HINTED( loader->load_flags ) )
+    {
+      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );
+
+      FT_ARRAY_COPY( loader->zone.orus, loader->zone.cur,
+                     loader->zone.n_points + 4 );
+    }
+
     {
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
       TT_Face    face   = loader->face;
       TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 
       FT_String*  family         = face->root.family_name;
       FT_UInt     ppem           = loader->size->metrics->x_ppem;
       FT_String*  style          = face->root.style_name;
       FT_UInt     x_scale_factor = 1000;
 #endif
 
       FT_Vector*  vec   = outline->points;
       FT_Vector*  limit = outline->points + n_points;
 
       FT_Fixed  x_scale = 0; /* pacify compiler */
       FT_Fixed  y_scale = 0;
 
       FT_Bool  do_scale = FALSE;
 
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 
       if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
       {
         /* scale, but only if enabled and only if TT hinting is being used */
         if ( IS_HINTED( loader->load_flags ) )
           x_scale_factor = sph_test_tweak_x_scaling( face,
                                                      family,
                                                      ppem,
                                                      style,
                                                      loader->glyph_index );
         /* scale the glyph */
         if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 ||
              x_scale_factor != 1000                         )
         {
           x_scale = FT_MulDiv( loader->size->metrics->x_scale,
                                (FT_Long)x_scale_factor, 1000 );
           y_scale = loader->size->metrics->y_scale;
 
           /* compensate for any scaling by de/emboldening; */
           /* the amount was determined via experimentation */
           if ( x_scale_factor != 1000 && ppem > 11 )
           {
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
             FT_Vector*  orig_points = outline->points;
 
 
-            outline->points = unrounded;
+            if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )
+              outline->points = unrounded;
+#endif
             FT_Outline_EmboldenXY( outline,
                                    FT_MulFix( 1280 * ppem,
                                               1000 - x_scale_factor ),
                                    0 );
-            outline->points = orig_points;
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+            if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )
+              outline->points = orig_points;
+#endif
           }
           do_scale = TRUE;
         }
       }
       else
 
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 
       {
         /* scale the glyph */
         if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
         {
           x_scale = loader->size->metrics->x_scale;
           y_scale = loader->size->metrics->y_scale;
 
           do_scale = TRUE;
         }
       }
 
       if ( do_scale )
       {
-        for ( ; vec < limit; vec++, unrounded++ )
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+        if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader->face ) ) )
         {
-          vec->x = FT_MulDiv( unrounded->x, x_scale, 0x10000L * 64 );
-          vec->y = FT_MulDiv( unrounded->y, y_scale, 0x10000L * 64 );
+          FT_Vector*  u = unrounded;
+
+          FT_Fixed  xs = x_scale >> 6;
+          FT_Fixed  ys = y_scale >> 6;
+
+
+          for ( ; vec < limit; vec++, u++ )
+          {
+            vec->x = FT_MulFix( u->x, xs );
+            vec->y = FT_MulFix( u->y, ys );
+          }
+        }
+        else
+#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
+        {
+          for ( ; vec < limit; vec++ )
+          {
+            vec->x = FT_MulFix( vec->x, x_scale );
+            vec->y = FT_MulFix( vec->y, y_scale );
+          }
         }
       }
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
       /* if we have a HVAR table, `pp1' and/or `pp2' are already adjusted */
       if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) ||
            !IS_HINTED( loader->load_flags )                                 )
 #endif
       {
         loader->pp1 = outline->points[n_points - 4];
         loader->pp2 = outline->points[n_points - 3];
       }
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
       /* if we have a VVAR table, `pp3' and/or `pp4' are already adjusted */
       if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) ||
            !IS_HINTED( loader->load_flags )                                 )
 #endif
       {
         loader->pp3 = outline->points[n_points - 2];
         loader->pp4 = outline->points[n_points - 1];
       }
     }
 
     if ( IS_HINTED( loader->load_flags ) )
     {
-      tt_prepare_zone( &loader->zone, &gloader->current, 0, 0 );
-
-      FT_ARRAY_COPY( loader->zone.orus, loader->zone.cur,
-                     loader->zone.n_points + 4 );
-
       loader->zone.n_points += 4;
 
       error = TT_Hint_Glyph( loader, 0 );
     }
 
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+  Exit:
+    FT_FREE( unrounded );
+#endif
+
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Process_Composite_Component
    *
    * @Description:
    *   Once a composite component has been loaded, it needs to be
    *   processed.  Usually, this means transforming and translating.
    */
   static FT_Error
   TT_Process_Composite_Component( TT_Loader    loader,
                                   FT_SubGlyph  subglyph,
                                   FT_UInt      start_point,
                                   FT_UInt      num_base_points )
   {
     FT_GlyphLoader  gloader = loader->gloader;
     FT_Outline      current;
     FT_Bool         have_scale;
     FT_Pos          x, y;
 
 
     current.points   = gloader->base.outline.points +
                          num_base_points;
     current.n_points = gloader->base.outline.n_points -
                          (short)num_base_points;
 
     have_scale = FT_BOOL( subglyph->flags & ( WE_HAVE_A_SCALE     |
                                               WE_HAVE_AN_XY_SCALE |
                                               WE_HAVE_A_2X2       ) );
 
     /* perform the transform required for this subglyph */
     if ( have_scale )
       FT_Outline_Transform( &current, &subglyph->transform );
 
     /* get offset */
     if ( !( subglyph->flags & ARGS_ARE_XY_VALUES ) )
     {
       FT_UInt     num_points = (FT_UInt)gloader->base.outline.n_points;
       FT_UInt     k = (FT_UInt)subglyph->arg1;
       FT_UInt     l = (FT_UInt)subglyph->arg2;
       FT_Vector*  p1;
       FT_Vector*  p2;
 
 
       /* match l-th point of the newly loaded component to the k-th point */
       /* of the previously loaded components.                             */
 
       /* change to the point numbers used by our outline */
       k += start_point;
       l += num_base_points;
       if ( k >= num_base_points ||
            l >= num_points      )
         return FT_THROW( Invalid_Composite );
 
       p1 = gloader->base.outline.points + k;
       p2 = gloader->base.outline.points + l;
 
       x = p1->x - p2->x;
       y = p1->y - p2->y;
     }
     else
     {
       x = subglyph->arg1;
       y = subglyph->arg2;
 
       if ( !x && !y )
         return FT_Err_Ok;
 
       /* Use a default value dependent on                                  */
       /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old */
       /* TT fonts which don't set the xxx_COMPONENT_OFFSET bit.            */
 
       if ( have_scale &&
 #ifdef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
            !( subglyph->flags & UNSCALED_COMPONENT_OFFSET ) )
 #else
             ( subglyph->flags & SCALED_COMPONENT_OFFSET ) )
 #endif
       {
 
 #if 0
 
         /********************************************************************
          *
          * This algorithm is what Apple documents.  But it doesn't work.
          */
         int  a = subglyph->transform.xx > 0 ?  subglyph->transform.xx
                                             : -subglyph->transform.xx;
         int  b = subglyph->transform.yx > 0 ?  subglyph->transform.yx
                                             : -subglyph->transform.yx;
         int  c = subglyph->transform.xy > 0 ?  subglyph->transform.xy
                                             : -subglyph->transform.xy;
         int  d = subglyph->transform.yy > 0 ?  subglyph->transform.yy
                                             : -subglyph->transform.yy;
         int  m = a > b ? a : b;
         int  n = c > d ? c : d;
 
 
         if ( a - b <= 33 && a - b >= -33 )
           m *= 2;
         if ( c - d <= 33 && c - d >= -33 )
           n *= 2;
         x = FT_MulFix( x, m );
         y = FT_MulFix( y, n );
 
 #else /* 1 */
 
         /********************************************************************
          *
          * This algorithm is a guess and works much better than the above.
          */
         FT_Fixed  mac_xscale = FT_Hypot( subglyph->transform.xx,
                                          subglyph->transform.xy );
         FT_Fixed  mac_yscale = FT_Hypot( subglyph->transform.yy,
                                          subglyph->transform.yx );
 
 
         x = FT_MulFix( x, mac_xscale );
         y = FT_MulFix( y, mac_yscale );
 
 #endif /* 1 */
 
       }
 
       if ( !( loader->load_flags & FT_LOAD_NO_SCALE ) )
       {
         FT_Fixed  x_scale = loader->size->metrics->x_scale;
         FT_Fixed  y_scale = loader->size->metrics->y_scale;
 
 
         x = FT_MulFix( x, x_scale );
         y = FT_MulFix( y, y_scale );
 
         if ( subglyph->flags & ROUND_XY_TO_GRID )
         {
           TT_Face    face   = loader->face;
           TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 
 
           if ( IS_HINTED( loader->load_flags ) )
           {
             /*
              * We round the horizontal offset only if there is hinting along
              * the x axis; this corresponds to integer advance width values.
              *
              * Theoretically, a glyph's bytecode can toggle ClearType's
              * `backward compatibility' mode, which would allow modification
              * of the advance width.  In reality, however, applications
              * neither allow nor expect modified advance widths if subpixel
              * rendering is active.
              *
              */
             if ( driver->interpreter_version == TT_INTERPRETER_VERSION_35 )
               x = FT_PIX_ROUND( x );
 
             y = FT_PIX_ROUND( y );
           }
         }
       }
     }
 
     if ( x || y )
       FT_Outline_Translate( &current, x, y );
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Process_Composite_Glyph
    *
    * @Description:
    *   This is slightly different from TT_Process_Simple_Glyph, in that
    *   its sole purpose is to hint the glyph.  Thus this function is
    *   only available when bytecode interpreter is enabled.
    */
   static FT_Error
   TT_Process_Composite_Glyph( TT_Loader  loader,
                               FT_UInt    start_point,
                               FT_UInt    start_contour )
   {
     FT_Error     error;
     FT_Outline*  outline;
     FT_UInt      i;
 
 
     outline = &loader->gloader->base.outline;
 
     /* make room for phantom points */
     error = FT_GLYPHLOADER_CHECK_POINTS( loader->gloader,
                                          outline->n_points + 4,
                                          0 );
     if ( error )
       return error;
 
     outline->points[outline->n_points    ] = loader->pp1;
     outline->points[outline->n_points + 1] = loader->pp2;
     outline->points[outline->n_points + 2] = loader->pp3;
     outline->points[outline->n_points + 3] = loader->pp4;
 
     outline->tags[outline->n_points    ] = 0;
     outline->tags[outline->n_points + 1] = 0;
     outline->tags[outline->n_points + 2] = 0;
     outline->tags[outline->n_points + 3] = 0;
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 
     {
       FT_Stream  stream = loader->stream;
       FT_UShort  n_ins, max_ins;
       FT_ULong   tmp;
 
 
       /* TT_Load_Composite_Glyph only gives us the offset of instructions */
       /* so we read them here                                             */
       if ( FT_STREAM_SEEK( loader->ins_pos ) ||
            FT_READ_USHORT( n_ins )           )
         return error;
 
       FT_TRACE5(( "  Instructions size = %d\n", n_ins ));
 
       /* check it */
       max_ins = loader->face->max_profile.maxSizeOfInstructions;
       if ( n_ins > max_ins )
       {
         /* don't trust `maxSizeOfInstructions'; */
         /* only do a rough safety check         */
         if ( (FT_Int)n_ins > loader->byte_len )
         {
           FT_TRACE1(( "TT_Process_Composite_Glyph:"
                       " too many instructions (%d) for glyph with length %d\n",
                       n_ins, loader->byte_len ));
           return FT_THROW( Too_Many_Hints );
         }
 
         tmp   = loader->exec->glyphSize;
         error = Update_Max( loader->exec->memory,
                             &tmp,
                             sizeof ( FT_Byte ),
                             (void*)&loader->exec->glyphIns,
                             n_ins );
 
         loader->exec->glyphSize = (FT_UShort)tmp;
         if ( error )
           return error;
       }
       else if ( n_ins == 0 )
         return FT_Err_Ok;
 
       if ( FT_STREAM_READ( loader->exec->glyphIns, n_ins ) )
         return error;
 
       loader->glyph->control_data = loader->exec->glyphIns;
       loader->glyph->control_len  = n_ins;
     }
 
 #endif
 
     tt_prepare_zone( &loader->zone, &loader->gloader->base,
                      start_point, start_contour );
 
     /* Some points are likely touched during execution of  */
     /* instructions on components.  So let's untouch them. */
     for ( i = 0; i < loader->zone.n_points; i++ )
       loader->zone.tags[i] &= ~FT_CURVE_TAG_TOUCH_BOTH;
 
     loader->zone.n_points += 4;
 
     return TT_Hint_Glyph( loader, 1 );
   }
 
 
   /*
    * Calculate the phantom points
    *
    * Defining the right side bearing (rsb) as
    *
    *   rsb = aw - (lsb + xmax - xmin)
    *
    * (with `aw' the advance width, `lsb' the left side bearing, and `xmin'
    * and `xmax' the glyph's minimum and maximum x value), the OpenType
    * specification defines the initial position of horizontal phantom points
    * as
    *
    *   pp1 = (round(xmin - lsb), 0)      ,
    *   pp2 = (round(pp1 + aw), 0)        .
    *
    * Note that the rounding to the grid (in the device space) is not
    * documented currently in the specification.
    *
    * However, the specification lacks the precise definition of vertical
    * phantom points.  Greg Hitchcock provided the following explanation.
    *
    * - a `vmtx' table is present
    *
    *   For any glyph, the minimum and maximum y values (`ymin' and `ymax')
    *   are given in the `glyf' table, the top side bearing (tsb) and advance
    *   height (ah) are given in the `vmtx' table.  The bottom side bearing
    *   (bsb) is then calculated as
    *
    *     bsb = ah - (tsb + ymax - ymin)       ,
    *
    *   and the initial position of vertical phantom points is
    *
    *     pp3 = (x, round(ymax + tsb))       ,
    *     pp4 = (x, round(pp3 - ah))         .
    *
    *   See below for value `x'.
    *
    * - no `vmtx' table in the font
    *
    *   If there is an `OS/2' table, we set
    *
    *     DefaultAscender = sTypoAscender       ,
    *     DefaultDescender = sTypoDescender     ,
    *
    *   otherwise we use data from the `hhea' table:
    *
    *     DefaultAscender = Ascender         ,
    *     DefaultDescender = Descender       .
    *
    *   With these two variables we can now set
    *
    *     ah = DefaultAscender - sDefaultDescender    ,
    *     tsb = DefaultAscender - yMax                ,
    *
    *   and proceed as if a `vmtx' table was present.
    *
    * Usually we have
    *
    *   x = aw / 2      ,                                                (1)
    *
    * but there is one compatibility case where it can be set to
    *
    *   x = -DefaultDescender -
    *         ((DefaultAscender - DefaultDescender - aw) / 2)     .      (2)
    *
    * and another one with
    *
    *   x = 0     .                                                      (3)
    *
    * In Windows, the history of those values is quite complicated,
    * depending on the hinting engine (that is, the graphics framework).
    *
    *   framework        from                 to       formula
    *  ----------------------------------------------------------
    *    GDI       Windows 98               current      (1)
    *              (Windows 2000 for NT)
    *    GDI+      Windows XP               Windows 7    (2)
    *    GDI+      Windows 8                current      (3)
    *    DWrite    Windows 7                current      (3)
    *
    * For simplicity, FreeType uses (1) for grayscale subpixel hinting and
    * (3) for everything else.
    *
    */
   static void
   tt_loader_set_pp( TT_Loader  loader )
   {
     FT_Bool  subpixel_hinting = 0;
     FT_Bool  grayscale        = 0;
     FT_Bool  use_aw_2         = 0;
 
 #ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
     TT_Driver driver = (TT_Driver)FT_FACE_DRIVER( loader->face );
 #endif
 
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
     if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
     {
       subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting
                                       : 0;
       grayscale        = loader->exec ? loader->exec->grayscale
                                       : 0;
     }
 #endif
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
     if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
     {
       subpixel_hinting = loader->exec ? loader->exec->subpixel_hinting_lean
                                       : 0;
       grayscale        = loader->exec ? loader->exec->grayscale_cleartype
                                       : 0;
     }
 #endif
 
     use_aw_2 = FT_BOOL( subpixel_hinting && grayscale );
 
     loader->pp1.x = loader->bbox.xMin - loader->left_bearing;
     loader->pp1.y = 0;
     loader->pp2.x = loader->pp1.x + loader->advance;
     loader->pp2.y = 0;
 
     loader->pp3.x = use_aw_2 ? loader->advance / 2 : 0;
     loader->pp3.y = loader->bbox.yMax + loader->top_bearing;
     loader->pp4.x = use_aw_2 ? loader->advance / 2 : 0;
     loader->pp4.y = loader->pp3.y - loader->vadvance;
   }
 
 
   /* a utility function to retrieve i-th node from given FT_List */
   static FT_ListNode
   ft_list_get_node_at( FT_List  list,
                        FT_UInt  idx )
   {
     FT_ListNode  cur;
 
 
     if ( !list )
       return NULL;
 
     for ( cur = list->head; cur; cur = cur->next )
     {
       if ( !idx )
         return cur;
 
       idx--;
     }
 
     return NULL;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   load_truetype_glyph
    *
    * @Description:
    *   Loads a given truetype glyph.  Handles composites and uses a
    *   TT_Loader object.
    */
   static FT_Error
   load_truetype_glyph( TT_Loader  loader,
                        FT_UInt    glyph_index,
                        FT_UInt    recurse_count,
                        FT_Bool    header_only )
   {
     FT_Error        error   = FT_Err_Ok;
     FT_Fixed        x_scale, y_scale;
     FT_ULong        offset;
     TT_Face         face    = loader->face;
     FT_GlyphLoader  gloader = loader->gloader;
 
     FT_Bool  opened_frame = 0;
 
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
     FT_StreamRec    inc_stream;
     FT_Data         glyph_data;
     FT_Bool         glyph_data_loaded = 0;
 #endif
 
 
 #ifdef FT_DEBUG_LEVEL_TRACE
     if ( recurse_count )
       FT_TRACE5(( "  nesting level: %d\n", recurse_count ));
 #endif
 
     /* some fonts have an incorrect value of `maxComponentDepth' */
     if ( recurse_count > face->max_profile.maxComponentDepth )
     {
       FT_TRACE1(( "load_truetype_glyph: maxComponentDepth set to %d\n",
                   recurse_count ));
       face->max_profile.maxComponentDepth = (FT_UShort)recurse_count;
     }
 
 #ifndef FT_CONFIG_OPTION_INCREMENTAL
     /* check glyph index */
     if ( glyph_index >= (FT_UInt)face->root.num_glyphs )
     {
       error = FT_THROW( Invalid_Glyph_Index );
       goto Exit;
     }
 #endif
 
     loader->glyph_index = glyph_index;
 
     if ( loader->load_flags & FT_LOAD_NO_SCALE )
     {
       x_scale = 0x10000L;
       y_scale = 0x10000L;
     }
     else
     {
       x_scale = loader->size->metrics->x_scale;
       y_scale = loader->size->metrics->y_scale;
     }
 
     /* Set `offset' to the start of the glyph relative to the start of */
     /* the `glyf' table, and `byte_len' to the length of the glyph in  */
     /* bytes.                                                          */
 
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 
     /* If we are loading glyph data via the incremental interface, set */
     /* the loader stream to a memory stream reading the data returned  */
     /* by the interface.                                               */
     if ( face->root.internal->incremental_interface )
     {
       error = face->root.internal->incremental_interface->funcs->get_glyph_data(
                 face->root.internal->incremental_interface->object,
                 glyph_index, &glyph_data );
       if ( error )
         goto Exit;
 
       glyph_data_loaded = 1;
       offset            = 0;
       loader->byte_len  = glyph_data.length;
 
       FT_ZERO( &inc_stream );
       FT_Stream_OpenMemory( &inc_stream,
                             glyph_data.pointer,
                             (FT_ULong)glyph_data.length );
 
       loader->stream = &inc_stream;
     }
     else
 
 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 
       offset = tt_face_get_location( face, glyph_index,
                                      (FT_UInt*)&loader->byte_len );
 
     if ( loader->byte_len > 0 )
     {
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
       /* for the incremental interface, `glyf_offset' is always zero */
       if ( !face->glyf_offset                          &&
            !face->root.internal->incremental_interface )
 #else
       if ( !face->glyf_offset )
 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
       {
         FT_TRACE2(( "no `glyf' table but non-zero `loca' entry\n" ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       error = face->access_glyph_frame( loader, glyph_index,
                                         face->glyf_offset + offset,
                                         (FT_UInt)loader->byte_len );
       if ( error )
         goto Exit;
 
       /* read glyph header first */
       error = face->read_glyph_header( loader );
 
       face->forget_glyph_frame( loader );
 
       if ( error )
         goto Exit;
     }
 
     /* a space glyph */
     if ( loader->byte_len == 0 || loader->n_contours == 0 )
     {
       loader->bbox.xMin = 0;
       loader->bbox.xMax = 0;
       loader->bbox.yMin = 0;
       loader->bbox.yMax = 0;
     }
 
     /* the metrics must be computed after loading the glyph header */
     /* since we need the glyph's `yMax' value in case the vertical */
     /* metrics must be emulated                                    */
     error = tt_get_metrics( loader, glyph_index );
     if ( error )
       goto Exit;
 
     if ( header_only )
       goto Exit;
 
     if ( loader->byte_len == 0 || loader->n_contours == 0 )
     {
       /* must initialize points before (possibly) overriding */
       /* glyph metrics from the incremental interface        */
       tt_loader_set_pp( loader );
 
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
       tt_get_metrics_incr_overrides( loader, glyph_index );
 #endif
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||
            FT_IS_VARIATION( FT_FACE( face ) )      )
       {
         /* a small outline structure with four elements for */
         /* communication with `TT_Vary_Apply_Glyph_Deltas'  */
         FT_Vector   points[4];
         char        tags[4]     = { 1, 1, 1, 1 };
         short       contours[4] = { 0, 1, 2, 3 };
         FT_Outline  outline;
 
         /* unrounded values */
         FT_Vector  unrounded[4];
 
 
         points[0].x = loader->pp1.x;
         points[0].y = loader->pp1.y;
         points[1].x = loader->pp2.x;
         points[1].y = loader->pp2.y;
 
         points[2].x = loader->pp3.x;
         points[2].y = loader->pp3.y;
         points[3].x = loader->pp4.x;
         points[3].y = loader->pp4.y;
 
         outline.n_points   = 4;
         outline.n_contours = 4;
         outline.points     = points;
         outline.tags       = tags;
         outline.contours   = contours;
 
         /* this must be done before scaling */
         error = TT_Vary_Apply_Glyph_Deltas( loader->face,
                                             glyph_index,
                                             &outline,
                                             unrounded,
                                             (FT_UInt)outline.n_points );
         if ( error )
           goto Exit;
 
         loader->pp1.x = points[0].x;
         loader->pp1.y = points[0].y;
         loader->pp2.x = points[1].x;
         loader->pp2.y = points[1].y;
 
         loader->pp3.x = points[2].x;
         loader->pp3.y = points[2].y;
         loader->pp4.x = points[3].x;
         loader->pp4.y = points[3].y;
 
         /* recalculate linear horizontal and vertical advances */
         /* if we don't have HVAR and VVAR, respectively        */
         if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
           loader->linear = FT_PIX_ROUND( unrounded[1].x -
                                          unrounded[0].x ) / 64;
         if ( !( loader->face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
           loader->vadvance = FT_PIX_ROUND( unrounded[3].x -
                                            unrounded[2].x ) / 64;
       }
 
 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
       /* scale phantom points, if necessary; */
       /* they get rounded in `TT_Hint_Glyph' */
       if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
       {
         loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
         loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
         /* pp1.y and pp2.y are always zero */
 
         loader->pp3.x = FT_MulFix( loader->pp3.x, x_scale );
         loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
         loader->pp4.x = FT_MulFix( loader->pp4.x, x_scale );
         loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
       }
 
       error = FT_Err_Ok;
       goto Exit;
     }
 
     /* must initialize phantom points before (possibly) overriding */
     /* glyph metrics from the incremental interface                */
     tt_loader_set_pp( loader );
 
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
     tt_get_metrics_incr_overrides( loader, glyph_index );
 #endif
 
     /***********************************************************************/
     /***********************************************************************/
     /***********************************************************************/
 
     /* we now open a frame again, right after the glyph header */
     /* (which consists of 10 bytes)                            */
     error = face->access_glyph_frame( loader, glyph_index,
                                       face->glyf_offset + offset + 10,
                                       (FT_UInt)loader->byte_len - 10 );
     if ( error )
       goto Exit;
 
     opened_frame = 1;
 
     /* if it is a simple glyph, load it */
 
     if ( loader->n_contours > 0 )
     {
       error = face->read_simple_glyph( loader );
       if ( error )
         goto Exit;
 
       /* all data have been read */
       face->forget_glyph_frame( loader );
       opened_frame = 0;
 
       error = TT_Process_Simple_Glyph( loader );
       if ( error )
         goto Exit;
 
       FT_GlyphLoader_Add( gloader );
     }
 
     /***********************************************************************/
     /***********************************************************************/
     /***********************************************************************/
 
     /* otherwise, load a composite! */
     else if ( loader->n_contours < 0 )
     {
       FT_Memory  memory = face->root.memory;
 
       FT_UInt   start_point;
       FT_UInt   start_contour;
       FT_ULong  ins_pos;  /* position of composite instructions, if any */
 
       FT_ListNode  node, node2;
 
 
       /* normalize the `n_contours' value */
       loader->n_contours = -1;
 
       /*
        * We store the glyph index directly in the `node->data' pointer,
        * following the glib solution (cf. macro `GUINT_TO_POINTER') with a
        * double cast to make this portable.  Note, however, that this needs
        * pointers with a width of at least 32 bits.
        */
 
       /* clear the nodes filled by sibling chains */
       node = ft_list_get_node_at( &loader->composites, recurse_count );
       for ( node2 = node; node2; node2 = node2->next )
         node2->data = (void*)FT_ULONG_MAX;
 
       /* check whether we already have a composite glyph with this index */
       if ( FT_List_Find( &loader->composites,
                          FT_UINT_TO_POINTER( glyph_index ) ) )
       {
         FT_TRACE1(( "TT_Load_Composite_Glyph:"
                     " infinite recursion detected\n" ));
         error = FT_THROW( Invalid_Composite );
         goto Exit;
       }
 
       else if ( node )
         node->data = FT_UINT_TO_POINTER( glyph_index );
 
       else
       {
         if ( FT_NEW( node ) )
           goto Exit;
         node->data = FT_UINT_TO_POINTER( glyph_index );
         FT_List_Add( &loader->composites, node );
       }
 
       start_point   = (FT_UInt)gloader->base.outline.n_points;
       start_contour = (FT_UInt)gloader->base.outline.n_contours;
 
       /* for each subglyph, read composite header */
       error = face->read_composite_glyph( loader );
       if ( error )
         goto Exit;
 
       /* store the offset of instructions */
       ins_pos = loader->ins_pos;
 
       /* all data we need are read */
       face->forget_glyph_frame( loader );
       opened_frame = 0;
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||
            FT_IS_VARIATION( FT_FACE( face ) )      )
       {
         short        i, limit;
         FT_SubGlyph  subglyph;
 
         FT_Outline  outline;
         FT_Vector*  points    = NULL;
         char*       tags      = NULL;
         short*      contours  = NULL;
         FT_Vector*  unrounded = NULL;
 
 
         limit = (short)gloader->current.num_subglyphs;
 
         /* construct an outline structure for              */
         /* communication with `TT_Vary_Apply_Glyph_Deltas' */
         outline.n_points   = (short)( gloader->current.num_subglyphs + 4 );
         outline.n_contours = outline.n_points;
 
         outline.points   = NULL;
         outline.tags     = NULL;
         outline.contours = NULL;
 
         if ( FT_NEW_ARRAY( points, outline.n_points )    ||
              FT_NEW_ARRAY( tags, outline.n_points )      ||
              FT_NEW_ARRAY( contours, outline.n_points )  ||
              FT_NEW_ARRAY( unrounded, outline.n_points ) )
           goto Exit1;
 
         subglyph = gloader->current.subglyphs;
 
         for ( i = 0; i < limit; i++, subglyph++ )
         {
           /* applying deltas for anchor points doesn't make sense, */
           /* but we don't have to specially check this since       */
           /* unused delta values are zero anyways                  */
           points[i].x = subglyph->arg1;
           points[i].y = subglyph->arg2;
           tags[i]     = 1;
           contours[i] = i;
         }
 
         points[i].x = loader->pp1.x;
         points[i].y = loader->pp1.y;
         tags[i]     = 1;
         contours[i] = i;
 
         i++;
         points[i].x = loader->pp2.x;
         points[i].y = loader->pp2.y;
         tags[i]     = 1;
         contours[i] = i;
 
         i++;
         points[i].x = loader->pp3.x;
         points[i].y = loader->pp3.y;
         tags[i]     = 1;
         contours[i] = i;
 
         i++;
         points[i].x = loader->pp4.x;
         points[i].y = loader->pp4.y;
         tags[i]     = 1;
         contours[i] = i;
 
         outline.points   = points;
         outline.tags     = tags;
         outline.contours = contours;
 
         /* this call provides additional offsets */
         /* for each component's translation      */
         if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas(
                              face,
                              glyph_index,
                              &outline,
                              unrounded,
                              (FT_UInt)outline.n_points ) ) )
           goto Exit1;
 
         subglyph = gloader->current.subglyphs;
 
         for ( i = 0; i < limit; i++, subglyph++ )
         {
           if ( subglyph->flags & ARGS_ARE_XY_VALUES )
           {
             subglyph->arg1 = (FT_Int16)points[i].x;
             subglyph->arg2 = (FT_Int16)points[i].y;
           }
         }
 
         loader->pp1.x = points[i + 0].x;
         loader->pp1.y = points[i + 0].y;
         loader->pp2.x = points[i + 1].x;
         loader->pp2.y = points[i + 1].y;
 
         loader->pp3.x = points[i + 2].x;
         loader->pp3.y = points[i + 2].y;
         loader->pp4.x = points[i + 3].x;
         loader->pp4.y = points[i + 3].y;
 
         /* recalculate linear horizontal and vertical advances */
         /* if we don't have HVAR and VVAR, respectively        */
         if ( !( face->variation_support & TT_FACE_FLAG_VAR_HADVANCE ) )
           loader->linear = FT_PIX_ROUND( unrounded[1].x -
                                          unrounded[0].x ) / 64;
         if ( !( face->variation_support & TT_FACE_FLAG_VAR_VADVANCE ) )
           loader->vadvance = FT_PIX_ROUND( unrounded[3].x -
                                            unrounded[2].x ) / 64;
 
       Exit1:
         FT_FREE( outline.points );
         FT_FREE( outline.tags );
         FT_FREE( outline.contours );
         FT_FREE( unrounded );
 
         if ( error )
           goto Exit;
       }
 
 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
       /* scale phantom points, if necessary; */
       /* they get rounded in `TT_Hint_Glyph' */
       if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
       {
         loader->pp1.x = FT_MulFix( loader->pp1.x, x_scale );
         loader->pp2.x = FT_MulFix( loader->pp2.x, x_scale );
         /* pp1.y and pp2.y are always zero */
 
         loader->pp3.x = FT_MulFix( loader->pp3.x, x_scale );
         loader->pp3.y = FT_MulFix( loader->pp3.y, y_scale );
         loader->pp4.x = FT_MulFix( loader->pp4.x, x_scale );
         loader->pp4.y = FT_MulFix( loader->pp4.y, y_scale );
       }
 
       /* if the flag FT_LOAD_NO_RECURSE is set, we return the subglyph */
       /* `as is' in the glyph slot (the client application will be     */
       /* responsible for interpreting these data)...                   */
       if ( loader->load_flags & FT_LOAD_NO_RECURSE )
       {
         FT_GlyphLoader_Add( gloader );
         loader->glyph->format = FT_GLYPH_FORMAT_COMPOSITE;
 
         goto Exit;
       }
 
       /*********************************************************************/
       /*********************************************************************/
       /*********************************************************************/
 
       {
         FT_UInt      n, num_base_points;
         FT_SubGlyph  subglyph       = NULL;
 
         FT_UInt      num_points     = start_point;
         FT_UInt      num_subglyphs  = gloader->current.num_subglyphs;
         FT_UInt      num_base_subgs = gloader->base.num_subglyphs;
 
         FT_Stream    old_stream     = loader->stream;
         FT_Int       old_byte_len   = loader->byte_len;
 
 
         FT_GlyphLoader_Add( gloader );
 
         /* read each subglyph independently */
         for ( n = 0; n < num_subglyphs; n++ )
         {
           FT_Vector  pp[4];
 
           FT_Int  linear_hadvance;
           FT_Int  linear_vadvance;
 
 
           /* Each time we call `load_truetype_glyph' in this loop, the */
           /* value of `gloader.base.subglyphs' can change due to table */
           /* reallocations.  We thus need to recompute the subglyph    */
           /* pointer on each iteration.                                */
           subglyph = gloader->base.subglyphs + num_base_subgs + n;
 
           pp[0] = loader->pp1;
           pp[1] = loader->pp2;
           pp[2] = loader->pp3;
           pp[3] = loader->pp4;
 
           linear_hadvance = loader->linear;
           linear_vadvance = loader->vadvance;
 
           num_base_points = (FT_UInt)gloader->base.outline.n_points;
 
           error = load_truetype_glyph( loader,
                                        (FT_UInt)subglyph->index,
                                        recurse_count + 1,
                                        FALSE );
           if ( error )
             goto Exit;
 
           /* restore subglyph pointer */
           subglyph = gloader->base.subglyphs + num_base_subgs + n;
 
           /* restore phantom points if necessary */
           if ( !( subglyph->flags & USE_MY_METRICS ) )
           {
             loader->pp1 = pp[0];
             loader->pp2 = pp[1];
             loader->pp3 = pp[2];
             loader->pp4 = pp[3];
 
             loader->linear   = linear_hadvance;
             loader->vadvance = linear_vadvance;
           }
 
           num_points = (FT_UInt)gloader->base.outline.n_points;
 
           if ( num_points == num_base_points )
             continue;
 
           /* gloader->base.outline consists of three parts:           */
           /*                                                          */
           /* 0 ----> start_point ----> num_base_points ----> n_points */
           /*    (1)               (2)                   (3)           */
           /*                                                          */
           /* (1) points that exist from the beginning                 */
           /* (2) component points that have been loaded so far        */
           /* (3) points of the newly loaded component                 */
           error = TT_Process_Composite_Component( loader,
                                                   subglyph,
                                                   start_point,
                                                   num_base_points );
           if ( error )
             goto Exit;
         }
 
         loader->stream   = old_stream;
         loader->byte_len = old_byte_len;
 
         /* process the glyph */
         loader->ins_pos = ins_pos;
         if ( IS_HINTED( loader->load_flags ) &&
 #ifdef TT_USE_BYTECODE_INTERPRETER
              subglyph                        &&
              subglyph->flags & WE_HAVE_INSTR &&
 #endif
              num_points > start_point )
         {
           error = TT_Process_Composite_Glyph( loader,
                                               start_point,
                                               start_contour );
           if ( error )
             goto Exit;
         }
       }
     }
 
     /***********************************************************************/
     /***********************************************************************/
     /***********************************************************************/
 
   Exit:
 
     if ( opened_frame )
       face->forget_glyph_frame( loader );
 
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 
     if ( glyph_data_loaded )
       face->root.internal->incremental_interface->funcs->free_glyph_data(
         face->root.internal->incremental_interface->object,
         &glyph_data );
 
 #endif
 
     return error;
   }
 
 
   static FT_Error
   compute_glyph_metrics( TT_Loader  loader,
                          FT_UInt    glyph_index )
   {
     TT_Face    face   = loader->face;
 #if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
     defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 #endif
 
     FT_BBox       bbox;
     FT_Fixed      y_scale;
     TT_GlyphSlot  glyph = loader->glyph;
     TT_Size       size  = loader->size;
 
 
     y_scale = 0x10000L;
     if ( ( loader->load_flags & FT_LOAD_NO_SCALE ) == 0 )
       y_scale = size->metrics->y_scale;
 
     if ( glyph->format != FT_GLYPH_FORMAT_COMPOSITE )
       FT_Outline_Get_CBox( &glyph->outline, &bbox );
     else
       bbox = loader->bbox;
 
     /* get the device-independent horizontal advance; it is scaled later */
     /* by the base layer.                                                */
     glyph->linearHoriAdvance = loader->linear;
 
     glyph->metrics.horiBearingX = bbox.xMin;
     glyph->metrics.horiBearingY = bbox.yMax;
     glyph->metrics.horiAdvance  = SUB_LONG(loader->pp2.x, loader->pp1.x);
 
     /* Adjust advance width to the value contained in the hdmx table   */
     /* unless FT_LOAD_COMPUTE_METRICS is set or backward compatibility */
     /* mode of the v40 interpreter is active.  See `ttinterp.h' for    */
     /* details on backward compatibility mode.                         */
     if (
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
          !( driver->interpreter_version == TT_INTERPRETER_VERSION_40  &&
             ( loader->exec && loader->exec->backward_compatibility  ) ) &&
 #endif
          !face->postscript.isFixedPitch                                 &&
          IS_HINTED( loader->load_flags )                                &&
          !( loader->load_flags & FT_LOAD_COMPUTE_METRICS )              )
     {
       FT_Byte*  widthp;
 
 
       widthp = tt_face_get_device_metrics( face,
                                            size->metrics->x_ppem,
                                            glyph_index );
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 
       if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
       {
         FT_Bool  ignore_x_mode;
 
 
         ignore_x_mode = FT_BOOL( FT_LOAD_TARGET_MODE( loader->load_flags ) !=
                                  FT_RENDER_MODE_MONO );
 
         if ( widthp                                                   &&
              ( ( ignore_x_mode && loader->exec->compatible_widths ) ||
                 !ignore_x_mode                                      ||
                 SPH_OPTION_BITMAP_WIDTHS                            ) )
           glyph->metrics.horiAdvance = *widthp * 64;
       }
       else
 
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 
       {
         if ( widthp )
           glyph->metrics.horiAdvance = *widthp * 64;
       }
     }
 
     /* set glyph dimensions */
     glyph->metrics.width  = SUB_LONG( bbox.xMax, bbox.xMin );
     glyph->metrics.height = SUB_LONG( bbox.yMax, bbox.yMin );
 
     /* Now take care of vertical metrics.  In the case where there is */
     /* no vertical information within the font (relatively common),   */
     /* create some metrics manually                                   */
     {
       FT_Pos  top;      /* scaled vertical top side bearing  */
       FT_Pos  advance;  /* scaled vertical advance height    */
 
 
       /* Get the unscaled top bearing and advance height. */
       if ( face->vertical_info                   &&
            face->vertical.number_Of_VMetrics > 0 )
       {
         top = (FT_Short)FT_DivFix( loader->pp3.y - bbox.yMax,
                                    y_scale );
 
         if ( loader->pp3.y <= loader->pp4.y )
           advance = 0;
         else
           advance = (FT_UShort)FT_DivFix( loader->pp3.y - loader->pp4.y,
                                           y_scale );
       }
       else
       {
         FT_Pos  height;
 
 
         /* XXX Compute top side bearing and advance height in  */
         /*     Get_VMetrics instead of here.                   */
 
         /* NOTE: The OS/2 values are the only `portable' ones, */
         /*       which is why we use them, if there is an OS/2 */
         /*       table in the font.  Otherwise, we use the     */
         /*       values defined in the horizontal header.      */
 
         height = (FT_Short)FT_DivFix( SUB_LONG( bbox.yMax,
                                                 bbox.yMin ),
                                       y_scale );
         if ( face->os2.version != 0xFFFFU )
           advance = (FT_Pos)( face->os2.sTypoAscender -
                               face->os2.sTypoDescender );
         else
           advance = (FT_Pos)( face->horizontal.Ascender -
                               face->horizontal.Descender );
 
         top = ( advance - height ) / 2;
       }
 
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
       {
         FT_Incremental_InterfaceRec*  incr;
         FT_Incremental_MetricsRec     incr_metrics;
         FT_Error                      error;
 
 
         incr = face->root.internal->incremental_interface;
 
         /* If this is an incrementally loaded font see if there are */
         /* overriding metrics for this glyph.                       */
         if ( incr && incr->funcs->get_glyph_metrics )
         {
           incr_metrics.bearing_x = 0;
           incr_metrics.bearing_y = top;
           incr_metrics.advance   = advance;
 
           error = incr->funcs->get_glyph_metrics( incr->object,
                                                   glyph_index,
                                                   TRUE,
                                                   &incr_metrics );
           if ( error )
             return error;
 
           top     = incr_metrics.bearing_y;
           advance = incr_metrics.advance;
         }
       }
 
       /* GWW: Do vertical metrics get loaded incrementally too? */
 
 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 
       glyph->linearVertAdvance = advance;
 
       /* scale the metrics */
       if ( !( loader->load_flags & FT_LOAD_NO_SCALE ) )
       {
         top     = FT_MulFix( top,     y_scale );
         advance = FT_MulFix( advance, y_scale );
       }
 
       /* XXX: for now, we have no better algorithm for the lsb, but it */
       /*      should work fine.                                        */
       /*                                                               */
       glyph->metrics.vertBearingX = SUB_LONG( glyph->metrics.horiBearingX,
                                               glyph->metrics.horiAdvance / 2 );
       glyph->metrics.vertBearingY = top;
       glyph->metrics.vertAdvance  = advance;
     }
 
     return FT_Err_Ok;
   }
 
 
 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 
   static FT_Error
   load_sbit_image( TT_Size       size,
                    TT_GlyphSlot  glyph,
                    FT_UInt       glyph_index,
                    FT_Int32      load_flags )
   {
     TT_Face             face;
     SFNT_Service        sfnt;
     FT_Stream           stream;
     FT_Error            error;
     TT_SBit_MetricsRec  sbit_metrics;
 
 
     face   = (TT_Face)glyph->face;
     sfnt   = (SFNT_Service)face->sfnt;
     stream = face->root.stream;
 
     error = sfnt->load_sbit_image( face,
                                    size->strike_index,
                                    glyph_index,
                                    (FT_UInt)load_flags,
                                    stream,
                                    &glyph->bitmap,
                                    &sbit_metrics );
     if ( !error )
     {
       glyph->outline.n_points   = 0;
       glyph->outline.n_contours = 0;
 
       glyph->metrics.width  = (FT_Pos)sbit_metrics.width  * 64;
       glyph->metrics.height = (FT_Pos)sbit_metrics.height * 64;
 
       glyph->metrics.horiBearingX = (FT_Pos)sbit_metrics.horiBearingX * 64;
       glyph->metrics.horiBearingY = (FT_Pos)sbit_metrics.horiBearingY * 64;
       glyph->metrics.horiAdvance  = (FT_Pos)sbit_metrics.horiAdvance  * 64;
 
       glyph->metrics.vertBearingX = (FT_Pos)sbit_metrics.vertBearingX * 64;
       glyph->metrics.vertBearingY = (FT_Pos)sbit_metrics.vertBearingY * 64;
       glyph->metrics.vertAdvance  = (FT_Pos)sbit_metrics.vertAdvance  * 64;
 
       glyph->format = FT_GLYPH_FORMAT_BITMAP;
 
       if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
       {
         glyph->bitmap_left = sbit_metrics.vertBearingX;
         glyph->bitmap_top  = sbit_metrics.vertBearingY;
       }
       else
       {
         glyph->bitmap_left = sbit_metrics.horiBearingX;
         glyph->bitmap_top  = sbit_metrics.horiBearingY;
       }
     }
 
     return error;
   }
 
 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
 
 
   static FT_Error
   tt_loader_init( TT_Loader     loader,
                   TT_Size       size,
                   TT_GlyphSlot  glyph,
                   FT_Int32      load_flags,
                   FT_Bool       glyf_table_only )
   {
     TT_Face    face;
     FT_Stream  stream;
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
     FT_Error   error;
     FT_Bool    pedantic = FT_BOOL( load_flags & FT_LOAD_PEDANTIC );
 #if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
     defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( (TT_Face)glyph->face );
 #endif
 #endif
 
 
     face   = (TT_Face)glyph->face;
     stream = face->root.stream;
 
     FT_ZERO( loader );
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 
     /* load execution context */
     if ( IS_HINTED( load_flags ) && !glyf_table_only )
     {
       TT_ExecContext  exec;
       FT_Bool         grayscale = TRUE;
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
       FT_Bool         subpixel_hinting_lean;
       FT_Bool         grayscale_cleartype;
 #endif
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
       FT_Bool  subpixel_hinting = FALSE;
 
 #if 0
       /* not used yet */
       FT_Bool  compatible_widths;
       FT_Bool  symmetrical_smoothing;
       FT_Bool  bgr;
       FT_Bool  vertical_lcd;
       FT_Bool  subpixel_positioned;
       FT_Bool  gray_cleartype;
 #endif
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 
       FT_Bool  reexecute = FALSE;
 
 
       if ( size->bytecode_ready < 0 || size->cvt_ready < 0 )
       {
         error = tt_size_ready_bytecode( size, pedantic );
         if ( error )
           return error;
       }
       else if ( size->bytecode_ready )
         return size->bytecode_ready;
       else if ( size->cvt_ready )
         return size->cvt_ready;
 
       /* query new execution context */
       exec = size->context;
       if ( !exec )
         return FT_THROW( Could_Not_Find_Context );
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
       if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
       {
         subpixel_hinting_lean =
           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                    FT_RENDER_MODE_MONO               );
         grayscale_cleartype =
           FT_BOOL( subpixel_hinting_lean         &&
                    !( ( load_flags         &
                         FT_LOAD_TARGET_LCD )   ||
                       ( load_flags           &
                         FT_LOAD_TARGET_LCD_V ) ) );
         exec->vertical_lcd_lean =
           FT_BOOL( subpixel_hinting_lean    &&
                    ( load_flags           &
                      FT_LOAD_TARGET_LCD_V ) );
       }
       else
       {
         subpixel_hinting_lean   = FALSE;
         grayscale_cleartype     = FALSE;
         exec->vertical_lcd_lean = FALSE;
       }
 #endif
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 
       if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
       {
         subpixel_hinting = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags ) !=
                                       FT_RENDER_MODE_MONO               )  &&
                                     SPH_OPTION_SET_SUBPIXEL                );
 
         if ( subpixel_hinting )
           grayscale = FALSE;
         else if ( SPH_OPTION_SET_GRAYSCALE )
         {
           grayscale        = TRUE;
           subpixel_hinting = FALSE;
         }
         else
           grayscale = FALSE;
 
         if ( FT_IS_TRICKY( glyph->face ) )
           subpixel_hinting = FALSE;
 
         exec->ignore_x_mode      = subpixel_hinting || grayscale;
         exec->rasterizer_version = SPH_OPTION_SET_RASTERIZER_VERSION;
         if ( exec->sph_tweak_flags & SPH_TWEAK_RASTERIZER_35 )
           exec->rasterizer_version = TT_INTERPRETER_VERSION_35;
 
 #if 1
         exec->compatible_widths     = SPH_OPTION_SET_COMPATIBLE_WIDTHS;
         exec->symmetrical_smoothing = TRUE;
         exec->bgr                   = FALSE;
         exec->vertical_lcd          = FALSE;
         exec->subpixel_positioned   = TRUE;
         exec->gray_cleartype        = FALSE;
 #else /* 0 */
         exec->compatible_widths =
           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                    TT_LOAD_COMPATIBLE_WIDTHS );
         exec->symmetrical_smoothing =
           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                    TT_LOAD_SYMMETRICAL_SMOOTHING );
         exec->bgr =
           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                    TT_LOAD_BGR );
         exec->vertical_lcd =
           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                    TT_LOAD_VERTICAL_LCD );
         exec->subpixel_positioned =
           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                    TT_LOAD_SUBPIXEL_POSITIONED );
         exec->gray_cleartype =
           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                    TT_LOAD_GRAY_CLEARTYPE );
 #endif /* 0 */
 
       }
       else
 
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
       if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
         grayscale = FT_BOOL( !subpixel_hinting_lean               &&
                              FT_LOAD_TARGET_MODE( load_flags ) !=
                                FT_RENDER_MODE_MONO                );
       else
 #endif
         grayscale = FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
                                FT_RENDER_MODE_MONO             );
 
       error = TT_Load_Context( exec, face, size );
       if ( error )
         return error;
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 
       if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 )
       {
         /* a change from mono to subpixel rendering (and vice versa) */
         /* requires a re-execution of the CVT program                */
         if ( subpixel_hinting != exec->subpixel_hinting )
         {
           FT_TRACE4(( "tt_loader_init: subpixel hinting change,"
                       " re-executing `prep' table\n" ));
 
           exec->subpixel_hinting = subpixel_hinting;
           reexecute              = TRUE;
         }
 
         /* a change from mono to grayscale rendering (and vice versa) */
         /* requires a re-execution of the CVT program                 */
         if ( grayscale != exec->grayscale )
         {
           FT_TRACE4(( "tt_loader_init: grayscale hinting change,"
                       " re-executing `prep' table\n" ));
 
           exec->grayscale = grayscale;
           reexecute       = TRUE;
         }
       }
       else
 
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 
       {
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
         if ( driver->interpreter_version == TT_INTERPRETER_VERSION_40 )
         {
           /* a change from mono to subpixel rendering (and vice versa) */
           /* requires a re-execution of the CVT program                */
           if ( subpixel_hinting_lean != exec->subpixel_hinting_lean )
           {
             FT_TRACE4(( "tt_loader_init: subpixel hinting change,"
                         " re-executing `prep' table\n" ));
 
             exec->subpixel_hinting_lean = subpixel_hinting_lean;
             reexecute                   = TRUE;
           }
 
           /* a change from colored to grayscale subpixel rendering (and */
           /* vice versa) requires a re-execution of the CVT program     */
           if ( grayscale_cleartype != exec->grayscale_cleartype )
           {
             FT_TRACE4(( "tt_loader_init: grayscale subpixel hinting change,"
                         " re-executing `prep' table\n" ));
 
             exec->grayscale_cleartype = grayscale_cleartype;
             reexecute                 = TRUE;
           }
         }
 #endif
 
         /* a change from mono to grayscale rendering (and vice versa) */
         /* requires a re-execution of the CVT program                 */
         if ( grayscale != exec->grayscale )
         {
           FT_TRACE4(( "tt_loader_init: grayscale hinting change,"
                       " re-executing `prep' table\n" ));
 
           exec->grayscale = grayscale;
           reexecute       = TRUE;
         }
       }
 
       if ( reexecute )
       {
         FT_UInt  i;
 
 
         for ( i = 0; i < size->cvt_size; i++ )
           size->cvt[i] = FT_MulFix( face->cvt[i], size->ttmetrics.scale );
         error = tt_size_run_prep( size, pedantic );
         if ( error )
           return error;
       }
 
       /* check whether the cvt program has disabled hinting */
       if ( exec->GS.instruct_control & 1 )
         load_flags |= FT_LOAD_NO_HINTING;
 
       /* load default graphics state -- if needed */
       if ( exec->GS.instruct_control & 2 )
         exec->GS = tt_default_graphics_state;
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
       /* check whether we have a font hinted for ClearType --           */
       /* note that this flag can also be modified in a glyph's bytecode */
       if ( driver->interpreter_version == TT_INTERPRETER_VERSION_38 &&
            exec->GS.instruct_control & 4                            )
         exec->ignore_x_mode = 0;
 #endif
 
       exec->pedantic_hinting = FT_BOOL( load_flags & FT_LOAD_PEDANTIC );
       loader->exec = exec;
       loader->instructions = exec->glyphIns;
     }
 
 #endif /* TT_USE_BYTECODE_INTERPRETER */
 
     /* get face's glyph loader */
     if ( !glyf_table_only )
     {
       FT_GlyphLoader  gloader = glyph->internal->loader;
 
 
       FT_GlyphLoader_Rewind( gloader );
       loader->gloader = gloader;
     }
 
     loader->load_flags = (FT_ULong)load_flags;
 
     loader->face   = face;
     loader->size   = size;
     loader->glyph  = (FT_GlyphSlot)glyph;
     loader->stream = stream;
 
     loader->composites.head = NULL;
     loader->composites.tail = NULL;
 
     return FT_Err_Ok;
   }
 
 
   static void
   tt_loader_done( TT_Loader  loader )
   {
     FT_List_Finalize( &loader->composites,
                       NULL,
                       loader->face->root.memory,
                       NULL );
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Load_Glyph
    *
    * @Description:
    *   A function used to load a single glyph within a given glyph slot,
    *   for a given size.
    *
    * @Input:
    *   glyph ::
    *     A handle to a target slot object where the glyph
    *     will be loaded.
    *
    *   size ::
    *     A handle to the source face size at which the glyph
    *     must be scaled/loaded.
    *
    *   glyph_index ::
    *     The index of the glyph in the font file.
    *
    *   load_flags ::
    *     A flag indicating what to load for this glyph.  The
    *     FT_LOAD_XXX constants can be used to control the
    *     glyph loading process (e.g., whether the outline
    *     should be scaled, whether to load bitmaps or not,
    *     whether to hint the outline, etc).
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Load_Glyph( TT_Size       size,
                  TT_GlyphSlot  glyph,
                  FT_UInt       glyph_index,
                  FT_Int32      load_flags )
   {
     FT_Error      error;
     TT_LoaderRec  loader;
 
-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
-#define IS_DEFAULT_INSTANCE  ( !( FT_IS_NAMED_INSTANCE( glyph->face ) ||  \
-                                  FT_IS_VARIATION( glyph->face )      ) )
-#else
-#define IS_DEFAULT_INSTANCE  1
-#endif
-
 
     FT_TRACE1(( "TT_Load_Glyph: glyph index %d\n", glyph_index ));
 
 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 
     /* try to load embedded bitmap (if any) */
     if ( size->strike_index != 0xFFFFFFFFUL      &&
          ( load_flags & FT_LOAD_NO_BITMAP ) == 0 &&
-         IS_DEFAULT_INSTANCE                     )
+         IS_DEFAULT_INSTANCE( glyph->face )      )
     {
       FT_Fixed  x_scale = size->root.metrics.x_scale;
       FT_Fixed  y_scale = size->root.metrics.y_scale;
 
 
       error = load_sbit_image( size, glyph, glyph_index, load_flags );
       if ( FT_ERR_EQ( error, Missing_Bitmap ) )
       {
         /* the bitmap strike is incomplete and misses the requested glyph; */
         /* if we have a bitmap-only font, return an empty glyph            */
         if ( !FT_IS_SCALABLE( glyph->face ) )
         {
           TT_Face  face = (TT_Face)glyph->face;
 
           FT_Short  left_bearing = 0;
           FT_Short  top_bearing  = 0;
 
           FT_UShort  advance_width  = 0;
           FT_UShort  advance_height = 0;
 
 
           /* to return an empty glyph, however, we need metrics data   */
           /* from the `hmtx' (or `vmtx') table; the assumption is that */
           /* empty glyphs are missing intentionally, representing      */
           /* whitespace - not having at least horizontal metrics is    */
           /* thus considered an error                                  */
           if ( !face->horz_metrics_size )
             return error;
 
           /* we now construct an empty bitmap glyph */
           TT_Get_HMetrics( face, glyph_index,
                            &left_bearing,
                            &advance_width );
           TT_Get_VMetrics( face, glyph_index,
                            0,
                            &top_bearing,
                            &advance_height );
 
           glyph->outline.n_points   = 0;
           glyph->outline.n_contours = 0;
 
           glyph->metrics.width  = 0;
           glyph->metrics.height = 0;
 
           glyph->metrics.horiBearingX = FT_MulFix( left_bearing, x_scale );
           glyph->metrics.horiBearingY = 0;
           glyph->metrics.horiAdvance  = FT_MulFix( advance_width, x_scale );
 
           glyph->metrics.vertBearingX = 0;
           glyph->metrics.vertBearingY = FT_MulFix( top_bearing, y_scale );
           glyph->metrics.vertAdvance  = FT_MulFix( advance_height, y_scale );
 
           glyph->format            = FT_GLYPH_FORMAT_BITMAP;
           glyph->bitmap.pixel_mode = FT_PIXEL_MODE_MONO;
 
           glyph->bitmap_left = 0;
           glyph->bitmap_top  = 0;
 
           return FT_Err_Ok;
         }
       }
       else if ( error )
       {
         /* return error if font is not scalable */
         if ( !FT_IS_SCALABLE( glyph->face ) )
           return error;
       }
       else
       {
         if ( FT_IS_SCALABLE( glyph->face ) )
         {
           /* for the bbox we need the header only */
           (void)tt_loader_init( &loader, size, glyph, load_flags, TRUE );
           (void)load_truetype_glyph( &loader, glyph_index, 0, TRUE );
           tt_loader_done( &loader );
           glyph->linearHoriAdvance = loader.linear;
           glyph->linearVertAdvance = loader.vadvance;
 
           /* sanity checks: if `xxxAdvance' in the sbit metric */
           /* structure isn't set, use `linearXXXAdvance'      */
           if ( !glyph->metrics.horiAdvance && glyph->linearHoriAdvance )
             glyph->metrics.horiAdvance = FT_MulFix( glyph->linearHoriAdvance,
                                                     x_scale );
           if ( !glyph->metrics.vertAdvance && glyph->linearVertAdvance )
             glyph->metrics.vertAdvance = FT_MulFix( glyph->linearVertAdvance,
                                                     y_scale );
         }
 
         return FT_Err_Ok;
       }
     }
 
 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
 
     /* if FT_LOAD_NO_SCALE is not set, `ttmetrics' must be valid */
     if ( !( load_flags & FT_LOAD_NO_SCALE ) && !size->ttmetrics.valid )
     {
       error = FT_THROW( Invalid_Size_Handle );
       goto Exit;
     }
 
     if ( load_flags & FT_LOAD_SBITS_ONLY )
     {
       error = FT_THROW( Invalid_Argument );
       goto Exit;
     }
 
     error = tt_loader_init( &loader, size, glyph, load_flags, FALSE );
     if ( error )
       goto Exit;
 
     glyph->format        = FT_GLYPH_FORMAT_OUTLINE;
     glyph->num_subglyphs = 0;
     glyph->outline.flags = 0;
 
     /* main loading loop */
     error = load_truetype_glyph( &loader, glyph_index, 0, FALSE );
     if ( !error )
     {
       if ( glyph->format == FT_GLYPH_FORMAT_COMPOSITE )
       {
         glyph->num_subglyphs = loader.gloader->base.num_subglyphs;
         glyph->subglyphs     = loader.gloader->base.subglyphs;
       }
       else
       {
         glyph->outline        = loader.gloader->base.outline;
         glyph->outline.flags &= ~FT_OUTLINE_SINGLE_PASS;
 
         /* Translate array so that (0,0) is the glyph's origin.  Note  */
         /* that this behaviour is independent on the value of bit 1 of */
         /* the `flags' field in the `head' table -- at least major     */
         /* applications like Acroread indicate that.                   */
         if ( loader.pp1.x )
           FT_Outline_Translate( &glyph->outline, -loader.pp1.x, 0 );
       }
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 
       if ( IS_HINTED( load_flags ) )
       {
         if ( loader.exec->GS.scan_control )
         {
           /* convert scan conversion mode to FT_OUTLINE_XXX flags */
           switch ( loader.exec->GS.scan_type )
           {
           case 0: /* simple drop-outs including stubs */
             glyph->outline.flags |= FT_OUTLINE_INCLUDE_STUBS;
             break;
           case 1: /* simple drop-outs excluding stubs */
             /* nothing; it's the default rendering mode */
             break;
           case 4: /* smart drop-outs including stubs */
             glyph->outline.flags |= FT_OUTLINE_SMART_DROPOUTS |
                                     FT_OUTLINE_INCLUDE_STUBS;
             break;
           case 5: /* smart drop-outs excluding stubs  */
             glyph->outline.flags |= FT_OUTLINE_SMART_DROPOUTS;
             break;
 
           default: /* no drop-out control */
             glyph->outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
             break;
           }
         }
         else
           glyph->outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
       }
 
 #endif /* TT_USE_BYTECODE_INTERPRETER */
 
       error = compute_glyph_metrics( &loader, glyph_index );
     }
 
     tt_loader_done( &loader );
 
     /* Set the `high precision' bit flag.                           */
     /* This is _critical_ to get correct output for monochrome      */
     /* TrueType glyphs at all sizes using the bytecode interpreter. */
     /*                                                              */
     if ( !( load_flags & FT_LOAD_NO_SCALE ) &&
          size->metrics->y_ppem < 24         )
       glyph->outline.flags |= FT_OUTLINE_HIGH_PRECISION;
 
   Exit:
 #ifdef FT_DEBUG_LEVEL_TRACE
     if ( error )
       FT_TRACE1(( "  failed (error code 0x%x)\n",
                   error ));
 #endif
 
     return error;
   }
 
 
 /* END */
diff --git a/src/truetype/ttgxvar.c b/src/truetype/ttgxvar.c
index 317340acb..eab423951 100644
--- a/src/truetype/ttgxvar.c
+++ b/src/truetype/ttgxvar.c
@@ -1,4259 +1,4259 @@
 /****************************************************************************
  *
  * ttgxvar.c
  *
  *   TrueType GX Font Variation loader
  *
  * Copyright (C) 2004-2019 by
  * David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.
  *
  * This file is part of the FreeType project, and may only be used,
  * modified, and distributed under the terms of the FreeType project
  * license, LICENSE.TXT.  By continuing to use, modify, or distribute
  * this file you indicate that you have read the license and
  * understand and accept it fully.
  *
  */
 
 
   /**************************************************************************
    *
    * Apple documents the `fvar', `gvar', `cvar', and `avar' tables at
    *
    *   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6[fgca]var.html
    *
    * The documentation for `gvar' is not intelligible; `cvar' refers you
    * to `gvar' and is thus also incomprehensible.
    *
    * The documentation for `avar' appears correct, but Apple has no fonts
    * with an `avar' table, so it is hard to test.
    *
    * Many thanks to John Jenkins (at Apple) in figuring this out.
    *
    *
    * Apple's `kern' table has some references to tuple indices, but as
    * there is no indication where these indices are defined, nor how to
    * interpolate the kerning values (different tuples have different
    * classes) this issue is ignored.
    *
    */
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_DEBUG_H
 #include FT_CONFIG_CONFIG_H
 #include FT_INTERNAL_STREAM_H
 #include FT_INTERNAL_SFNT_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_TRUETYPE_IDS_H
 #include FT_MULTIPLE_MASTERS_H
 #include FT_LIST_H
 
 #include "ttpload.h"
 #include "ttgxvar.h"
 
 #include "tterrors.h"
 
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
 
 #define FT_Stream_FTell( stream )                         \
           (FT_ULong)( (stream)->cursor - (stream)->base )
 #define FT_Stream_SeekSet( stream, off )                               \
           (stream)->cursor =                                           \
             ( (off) < (FT_ULong)( (stream)->limit - (stream)->base ) ) \
                         ? (stream)->base + (off)                       \
                         : (stream)->limit
 
 
   /* some macros we need */
 #define FT_fdot14ToFixed( x )                  \
           ( (FT_Fixed)( (FT_ULong)(x) << 2 ) )
 #define FT_intToFixed( i )                      \
           ( (FT_Fixed)( (FT_ULong)(i) << 16 ) )
-#define FT_fixedToInt( x )                                     \
-          ( (FT_Short)( ( (FT_UInt32)(x) + 0x8000U ) >> 16 ) )
+#define FT_fixedToInt( x )                                    \
+          ( (FT_Short)( ( (FT_ULong)(x) + 0x8000U ) >> 16 ) )
 #define FT_fixedToFdot6( x )                              \
-          ( (FT_Pos)( ( (FT_UInt32)(x) + 0x20 ) >> 10 ) )
+          ( (FT_Pos)( ( (FT_ULong)(x) + 0x200 ) >> 10 ) )
 
 
   /**************************************************************************
    *
    * The macro FT_COMPONENT is used in trace mode.  It is an implicit
    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
    * messages during execution.
    */
 #undef  FT_COMPONENT
 #define FT_COMPONENT  ttgxvar
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                       Internal Routines                       *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /**************************************************************************
    *
    * The macro ALL_POINTS is used in `ft_var_readpackedpoints'.  It
    * indicates that there is a delta for every point without needing to
    * enumerate all of them.
    */
 
   /* ensure that value `0' has the same width as a pointer */
 #define ALL_POINTS  (FT_UShort*)~(FT_PtrDist)0
 
 
 #define GX_PT_POINTS_ARE_WORDS      0x80U
 #define GX_PT_POINT_RUN_COUNT_MASK  0x7FU
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_readpackedpoints
    *
    * @Description:
    *   Read a set of points to which the following deltas will apply.
    *   Points are packed with a run length encoding.
    *
    * @Input:
    *   stream ::
    *     The data stream.
    *
    *   size ::
    *     The size of the table holding the data.
    *
    * @Output:
    *   point_cnt ::
    *     The number of points read.  A zero value means that
    *     all points in the glyph will be affected, without
    *     enumerating them individually.
    *
    * @Return:
    *   An array of FT_UShort containing the affected points or the
    *   special value ALL_POINTS.
    */
   static FT_UShort*
   ft_var_readpackedpoints( FT_Stream  stream,
                            FT_ULong   size,
                            FT_UInt   *point_cnt )
   {
     FT_UShort *points = NULL;
     FT_UInt    n;
     FT_UInt    runcnt;
     FT_UInt    i, j;
     FT_UShort  first;
     FT_Memory  memory = stream->memory;
     FT_Error   error  = FT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     *point_cnt = 0;
 
     n = FT_GET_BYTE();
     if ( n == 0 )
       return ALL_POINTS;
 
     if ( n & GX_PT_POINTS_ARE_WORDS )
     {
       n  &= GX_PT_POINT_RUN_COUNT_MASK;
       n <<= 8;
       n  |= FT_GET_BYTE();
     }
 
     if ( n > size )
     {
       FT_TRACE1(( "ft_var_readpackedpoints: number of points too large\n" ));
       return NULL;
     }
 
     /* in the nested loops below we increase `i' twice; */
     /* it is faster to simply allocate one more slot    */
     /* than to add another test within the loop         */
     if ( FT_NEW_ARRAY( points, n + 1 ) )
       return NULL;
 
     *point_cnt = n;
 
     first = 0;
     i     = 0;
     while ( i < n )
     {
       runcnt = FT_GET_BYTE();
       if ( runcnt & GX_PT_POINTS_ARE_WORDS )
       {
         runcnt     &= GX_PT_POINT_RUN_COUNT_MASK;
         first      += FT_GET_USHORT();
         points[i++] = first;
 
         /* first point not included in run count */
         for ( j = 0; j < runcnt; j++ )
         {
           first      += FT_GET_USHORT();
           points[i++] = first;
           if ( i >= n )
             break;
         }
       }
       else
       {
         first      += FT_GET_BYTE();
         points[i++] = first;
 
         for ( j = 0; j < runcnt; j++ )
         {
           first      += FT_GET_BYTE();
           points[i++] = first;
           if ( i >= n )
             break;
         }
       }
     }
 
     return points;
   }
 
 
 #define GX_DT_DELTAS_ARE_ZERO       0x80U
 #define GX_DT_DELTAS_ARE_WORDS      0x40U
 #define GX_DT_DELTA_RUN_COUNT_MASK  0x3FU
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_readpackeddeltas
    *
    * @Description:
    *   Read a set of deltas.  These are packed slightly differently than
    *   points.  In particular there is no overall count.
    *
    * @Input:
    *   stream ::
    *     The data stream.
    *
    *   size ::
    *     The size of the table holding the data.
    *
    *   delta_cnt ::
    *     The number of deltas to be read.
    *
    * @Return:
    *   An array of FT_Fixed containing the deltas for the affected
    *   points.  (This only gets the deltas for one dimension.  It will
    *   generally be called twice, once for x, once for y.  When used in
    *   cvt table, it will only be called once.)
    *
    *   We use FT_Fixed to avoid accumulation errors while summing up all
    *   deltas (the rounding to integer values happens as the very last
    *   step).
    */
   static FT_Fixed*
   ft_var_readpackeddeltas( FT_Stream  stream,
                            FT_ULong   size,
                            FT_UInt    delta_cnt )
   {
     FT_Fixed  *deltas = NULL;
     FT_UInt    runcnt, cnt;
     FT_UInt    i, j;
     FT_Memory  memory = stream->memory;
     FT_Error   error  = FT_Err_Ok;
 
     FT_UNUSED( error );
 
 
     if ( delta_cnt > size )
     {
       FT_TRACE1(( "ft_var_readpackeddeltas: number of points too large\n" ));
       return NULL;
     }
 
     if ( FT_NEW_ARRAY( deltas, delta_cnt ) )
       return NULL;
 
     i = 0;
     while ( i < delta_cnt )
     {
       runcnt = FT_GET_BYTE();
       cnt    = runcnt & GX_DT_DELTA_RUN_COUNT_MASK;
 
       if ( runcnt & GX_DT_DELTAS_ARE_ZERO )
       {
         /* `runcnt' zeroes get added */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = 0;
       }
       else if ( runcnt & GX_DT_DELTAS_ARE_WORDS )
       {
         /* `runcnt' shorts from the stack */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = FT_intToFixed( FT_GET_SHORT() );
       }
       else
       {
         /* `runcnt' signed bytes from the stack */
         for ( j = 0; j <= cnt && i < delta_cnt; j++ )
           deltas[i++] = FT_intToFixed( FT_GET_CHAR() );
       }
 
       if ( j <= cnt )
       {
         /* bad format */
         FT_FREE( deltas );
         return NULL;
       }
     }
 
     return deltas;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_load_avar
    *
    * @Description:
    *   Parse the `avar' table if present.  It need not be, so we return
    *   nothing.
    *
    * @InOut:
    *   face ::
    *     The font face.
    */
   static void
   ft_var_load_avar( TT_Face  face )
   {
     FT_Stream       stream = FT_FACE_STREAM( face );
     FT_Memory       memory = stream->memory;
     GX_Blend        blend  = face->blend;
     GX_AVarSegment  segment;
     FT_Error        error = FT_Err_Ok;
     FT_Long         version;
     FT_Long         axisCount;
     FT_Int          i, j;
     FT_ULong        table_len;
 
     FT_UNUSED( error );
 
 
     FT_TRACE2(( "AVAR " ));
 
     blend->avar_loaded = TRUE;
     error = face->goto_table( face, TTAG_avar, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       return;
     }
 
     if ( FT_FRAME_ENTER( table_len ) )
       return;
 
     version   = FT_GET_LONG();
     axisCount = FT_GET_LONG();
 
     if ( version != 0x00010000L )
     {
       FT_TRACE2(( "bad table version\n" ));
       goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     if ( axisCount != (FT_Long)blend->mmvar->num_axis )
     {
       FT_TRACE2(( "ft_var_load_avar: number of axes in `avar' and `fvar'\n"
                   "                  table are different\n" ));
       goto Exit;
     }
 
     if ( FT_NEW_ARRAY( blend->avar_segment, axisCount ) )
       goto Exit;
 
     segment = &blend->avar_segment[0];
     for ( i = 0; i < axisCount; i++, segment++ )
     {
       FT_TRACE5(( "  axis %d:\n", i ));
 
       segment->pairCount = FT_GET_USHORT();
       if ( (FT_ULong)segment->pairCount * 4 > table_len                ||
            FT_NEW_ARRAY( segment->correspondence, segment->pairCount ) )
       {
         /* Failure.  Free everything we have done so far.  We must do */
         /* it right now since loading the `avar' table is optional.   */
 
         for ( j = i - 1; j >= 0; j-- )
           FT_FREE( blend->avar_segment[j].correspondence );
 
         FT_FREE( blend->avar_segment );
         blend->avar_segment = NULL;
         goto Exit;
       }
 
       for ( j = 0; j < segment->pairCount; j++ )
       {
         segment->correspondence[j].fromCoord =
           FT_fdot14ToFixed( FT_GET_SHORT() );
         segment->correspondence[j].toCoord =
           FT_fdot14ToFixed( FT_GET_SHORT() );
 
         FT_TRACE5(( "    mapping %.5f to %.5f\n",
                     segment->correspondence[j].fromCoord / 65536.0,
                     segment->correspondence[j].toCoord / 65536.0 ));
       }
 
       FT_TRACE5(( "\n" ));
     }
 
   Exit:
     FT_FRAME_EXIT();
   }
 
 
   static FT_Error
   ft_var_load_item_variation_store( TT_Face          face,
                                     FT_ULong         offset,
                                     GX_ItemVarStore  itemStore )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     FT_Error   error;
     FT_UShort  format;
     FT_ULong   region_offset;
     FT_UInt    i, j, k;
     FT_UInt    shortDeltaCount;
 
     GX_Blend        blend = face->blend;
     GX_ItemVarData  varData;
 
     FT_ULong*  dataOffsetArray = NULL;
 
 
     if ( FT_STREAM_SEEK( offset ) ||
          FT_READ_USHORT( format ) )
       goto Exit;
 
     if ( format != 1 )
     {
       FT_TRACE2(( "ft_var_load_item_variation_store: bad store format %d\n",
                   format ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* read top level fields */
     if ( FT_READ_ULONG( region_offset )         ||
          FT_READ_USHORT( itemStore->dataCount ) )
       goto Exit;
 
     /* we need at least one entry in `itemStore->varData' */
     if ( !itemStore->dataCount )
     {
       FT_TRACE2(( "ft_var_load_item_variation_store: missing varData\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* make temporary copy of item variation data offsets; */
     /* we will parse region list first, then come back     */
     if ( FT_NEW_ARRAY( dataOffsetArray, itemStore->dataCount ) )
       goto Exit;
 
     for ( i = 0; i < itemStore->dataCount; i++ )
     {
       if ( FT_READ_ULONG( dataOffsetArray[i] ) )
         goto Exit;
     }
 
     /* parse array of region records (region list) */
     if ( FT_STREAM_SEEK( offset + region_offset ) )
       goto Exit;
 
     if ( FT_READ_USHORT( itemStore->axisCount )   ||
          FT_READ_USHORT( itemStore->regionCount ) )
       goto Exit;
 
     if ( itemStore->axisCount != (FT_Long)blend->mmvar->num_axis )
     {
       FT_TRACE2(( "ft_var_load_item_variation_store:"
                   " number of axes in item variation store\n"
                   "                                 "
                   " and `fvar' table are different\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     if ( FT_NEW_ARRAY( itemStore->varRegionList, itemStore->regionCount ) )
       goto Exit;
 
     for ( i = 0; i < itemStore->regionCount; i++ )
     {
       GX_AxisCoords  axisCoords;
 
 
       if ( FT_NEW_ARRAY( itemStore->varRegionList[i].axisList,
                          itemStore->axisCount ) )
         goto Exit;
 
       axisCoords = itemStore->varRegionList[i].axisList;
 
       for ( j = 0; j < itemStore->axisCount; j++ )
       {
         FT_Short  start, peak, end;
 
 
         if ( FT_READ_SHORT( start ) ||
              FT_READ_SHORT( peak )  ||
              FT_READ_SHORT( end )   )
           goto Exit;
 
         axisCoords[j].startCoord = FT_fdot14ToFixed( start );
         axisCoords[j].peakCoord  = FT_fdot14ToFixed( peak );
         axisCoords[j].endCoord   = FT_fdot14ToFixed( end );
       }
     }
 
     /* end of region list parse */
 
     /* use dataOffsetArray now to parse varData items */
     if ( FT_NEW_ARRAY( itemStore->varData, itemStore->dataCount ) )
       goto Exit;
 
     for ( i = 0; i < itemStore->dataCount; i++ )
     {
       varData = &itemStore->varData[i];
 
       if ( FT_STREAM_SEEK( offset + dataOffsetArray[i] ) )
         goto Exit;
 
       if ( FT_READ_USHORT( varData->itemCount )      ||
            FT_READ_USHORT( shortDeltaCount )         ||
            FT_READ_USHORT( varData->regionIdxCount ) )
         goto Exit;
 
       /* check some data consistency */
       if ( shortDeltaCount > varData->regionIdxCount )
       {
         FT_TRACE2(( "bad short count %d or region count %d\n",
                     shortDeltaCount,
                     varData->regionIdxCount ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       if ( varData->regionIdxCount > itemStore->regionCount )
       {
         FT_TRACE2(( "inconsistent regionCount %d in varData[%d]\n",
                     varData->regionIdxCount,
                     i ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       /* parse region indices */
       if ( FT_NEW_ARRAY( varData->regionIndices,
                          varData->regionIdxCount ) )
         goto Exit;
 
       for ( j = 0; j < varData->regionIdxCount; j++ )
       {
         if ( FT_READ_USHORT( varData->regionIndices[j] ) )
           goto Exit;
 
         if ( varData->regionIndices[j] >= itemStore->regionCount )
         {
           FT_TRACE2(( "bad region index %d\n",
                       varData->regionIndices[j] ));
           error = FT_THROW( Invalid_Table );
           goto Exit;
         }
       }
 
       /* Parse delta set.                                                */
       /*                                                                 */
       /* On input, deltas are (shortDeltaCount + regionIdxCount) bytes   */
       /* each; on output, deltas are expanded to `regionIdxCount' shorts */
       /* each.                                                           */
       if ( FT_NEW_ARRAY( varData->deltaSet,
                          varData->regionIdxCount * varData->itemCount ) )
         goto Exit;
 
       /* the delta set is stored as a 2-dimensional array of shorts; */
       /* sign-extend signed bytes to signed shorts                   */
       for ( j = 0; j < varData->itemCount * varData->regionIdxCount; )
       {
         for ( k = 0; k < shortDeltaCount; k++, j++ )
         {
           /* read the short deltas */
           FT_Short  delta;
 
 
           if ( FT_READ_SHORT( delta ) )
             goto Exit;
 
           varData->deltaSet[j] = delta;
         }
 
         for ( ; k < varData->regionIdxCount; k++, j++ )
         {
           /* read the (signed) byte deltas */
           FT_Char  delta;
 
 
           if ( FT_READ_CHAR( delta ) )
             goto Exit;
 
           varData->deltaSet[j] = delta;
         }
       }
     }
 
   Exit:
     FT_FREE( dataOffsetArray );
 
     return error;
   }
 
 
   static FT_Error
   ft_var_load_delta_set_index_mapping( TT_Face            face,
                                        FT_ULong           offset,
                                        GX_DeltaSetIdxMap  map,
                                        GX_ItemVarStore    itemStore )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     FT_Error   error;
 
     FT_UShort  format;
     FT_UInt    entrySize;
     FT_UInt    innerBitCount;
     FT_UInt    innerIndexMask;
     FT_UInt    i, j;
 
 
     if ( FT_STREAM_SEEK( offset )        ||
          FT_READ_USHORT( format )        ||
          FT_READ_USHORT( map->mapCount ) )
       goto Exit;
 
     if ( format & 0xFFC0 )
     {
       FT_TRACE2(( "bad map format %d\n", format ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* bytes per entry: 1, 2, 3, or 4 */
     entrySize      = ( ( format & 0x0030 ) >> 4 ) + 1;
     innerBitCount  = ( format & 0x000F ) + 1;
     innerIndexMask = ( 1 << innerBitCount ) - 1;
 
     if ( FT_NEW_ARRAY( map->innerIndex, map->mapCount ) )
       goto Exit;
 
     if ( FT_NEW_ARRAY( map->outerIndex, map->mapCount ) )
       goto Exit;
 
     for ( i = 0; i < map->mapCount; i++ )
     {
       FT_UInt  mapData = 0;
       FT_UInt  outerIndex, innerIndex;
 
 
       /* read map data one unsigned byte at a time, big endian */
       for ( j = 0; j < entrySize; j++ )
       {
         FT_Byte  data;
 
 
         if ( FT_READ_BYTE( data ) )
           goto Exit;
 
         mapData = ( mapData << 8 ) | data;
       }
 
       outerIndex = mapData >> innerBitCount;
 
       if ( outerIndex >= itemStore->dataCount )
       {
         FT_TRACE2(( "outerIndex[%d] == %d out of range\n",
                     i,
                     outerIndex ));
         error = FT_THROW( Invalid_Table );
         goto Exit;
       }
 
       map->outerIndex[i] = outerIndex;
 
       innerIndex = mapData & innerIndexMask;
 
       if ( innerIndex >= itemStore->varData[outerIndex].itemCount )
       {
         FT_TRACE2(( "innerIndex[%d] == %d out of range\n",
                     i,
                     innerIndex ));
         error = FT_THROW( Invalid_Table );
           goto Exit;
       }
 
       map->innerIndex[i] = innerIndex;
     }
 
   Exit:
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_load_hvvar
    *
    * @Description:
    *   If `vertical' is zero, parse the `HVAR' table and set
    *   `blend->hvar_loaded' to TRUE.  On success, `blend->hvar_checked'
    *   is set to TRUE.
    *
    *   If `vertical' is not zero, parse the `VVAR' table and set
    *   `blend->vvar_loaded' to TRUE.  On success, `blend->vvar_checked'
    *   is set to TRUE.
    *
    *   Some memory may remain allocated on error; it is always freed in
    *   `tt_done_blend', however.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   static FT_Error
   ft_var_load_hvvar( TT_Face  face,
                      FT_Bool  vertical )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     GX_Blend  blend = face->blend;
 
     GX_HVVarTable  table;
 
     FT_Error   error;
     FT_UShort  majorVersion;
     FT_ULong   table_len;
     FT_ULong   table_offset;
     FT_ULong   store_offset;
     FT_ULong   widthMap_offset;
 
 
     if ( vertical )
     {
       blend->vvar_loaded = TRUE;
 
       FT_TRACE2(( "VVAR " ));
 
       error = face->goto_table( face, TTAG_VVAR, stream, &table_len );
     }
     else
     {
       blend->hvar_loaded = TRUE;
 
       FT_TRACE2(( "HVAR " ));
 
       error = face->goto_table( face, TTAG_HVAR, stream, &table_len );
     }
 
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       goto Exit;
     }
 
     table_offset = FT_STREAM_POS();
 
     /* skip minor version */
     if ( FT_READ_USHORT( majorVersion ) ||
          FT_STREAM_SKIP( 2 )            )
       goto Exit;
 
     if ( majorVersion != 1 )
     {
       FT_TRACE2(( "bad table version %d\n", majorVersion ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     if ( FT_READ_ULONG( store_offset )    ||
          FT_READ_ULONG( widthMap_offset ) )
       goto Exit;
 
     if ( vertical )
     {
       if ( FT_NEW( blend->vvar_table ) )
         goto Exit;
       table = blend->vvar_table;
     }
     else
     {
       if ( FT_NEW( blend->hvar_table ) )
         goto Exit;
       table = blend->hvar_table;
     }
 
     error = ft_var_load_item_variation_store(
               face,
               table_offset + store_offset,
               &table->itemStore );
     if ( error )
       goto Exit;
 
     if ( widthMap_offset )
     {
       error = ft_var_load_delta_set_index_mapping(
                 face,
                 table_offset + widthMap_offset,
                 &table->widthMap,
                 &table->itemStore );
       if ( error )
         goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
     error = FT_Err_Ok;
 
   Exit:
     if ( !error )
     {
       if ( vertical )
       {
         blend->vvar_checked = TRUE;
 
         /* FreeType doesn't provide functions to quickly retrieve    */
         /* TSB, BSB, or VORG values; we thus don't have to implement */
         /* support for those three item variation stores.            */
 
         face->variation_support |= TT_FACE_FLAG_VAR_VADVANCE;
       }
       else
       {
         blend->hvar_checked = TRUE;
 
         /* FreeType doesn't provide functions to quickly retrieve */
         /* LSB or RSB values; we thus don't have to implement     */
         /* support for those two item variation stores.           */
 
         face->variation_support |= TT_FACE_FLAG_VAR_HADVANCE;
       }
     }
 
     return error;
   }
 
 
   static FT_Int
   ft_var_get_item_delta( TT_Face          face,
                          GX_ItemVarStore  itemStore,
                          FT_UInt          outerIndex,
                          FT_UInt          innerIndex )
   {
     GX_ItemVarData  varData;
     FT_Short*       deltaSet;
 
     FT_UInt   master, j;
     FT_Fixed  netAdjustment = 0;     /* accumulated adjustment */
     FT_Fixed  scaledDelta;
     FT_Fixed  delta;
 
 
     /* See pseudo code from `Font Variations Overview' */
     /* in the OpenType specification.                  */
 
     varData  = &itemStore->varData[outerIndex];
     deltaSet = &varData->deltaSet[varData->regionIdxCount * innerIndex];
 
     /* outer loop steps through master designs to be blended */
     for ( master = 0; master < varData->regionIdxCount; master++ )
     {
       FT_Fixed  scalar      = 0x10000L;
       FT_UInt   regionIndex = varData->regionIndices[master];
 
       GX_AxisCoords  axis = itemStore->varRegionList[regionIndex].axisList;
 
 
       /* inner loop steps through axes in this region */
       for ( j = 0; j < itemStore->axisCount; j++, axis++ )
       {
         /* compute the scalar contribution of this axis; */
         /* ignore invalid ranges                         */
         if ( axis->startCoord > axis->peakCoord ||
              axis->peakCoord > axis->endCoord   )
           continue;
 
         else if ( axis->startCoord < 0 &&
                   axis->endCoord > 0   &&
                   axis->peakCoord != 0 )
           continue;
 
         /* peak of 0 means ignore this axis */
         else if ( axis->peakCoord == 0 )
           continue;
 
         else if ( face->blend->normalizedcoords[j] == axis->peakCoord )
           continue;
 
         /* ignore this region if coords are out of range */
         else if ( face->blend->normalizedcoords[j] <= axis->startCoord ||
                   face->blend->normalizedcoords[j] >= axis->endCoord   )
         {
           scalar = 0;
           break;
         }
 
         /* cumulative product of all the axis scalars */
         else if ( face->blend->normalizedcoords[j] < axis->peakCoord )
           scalar =
             FT_MulDiv( scalar,
                        face->blend->normalizedcoords[j] - axis->startCoord,
                        axis->peakCoord - axis->startCoord );
         else
           scalar =
             FT_MulDiv( scalar,
                        axis->endCoord - face->blend->normalizedcoords[j],
                        axis->endCoord - axis->peakCoord );
       } /* per-axis loop */
 
       /* get the scaled delta for this region */
       delta       = FT_intToFixed( deltaSet[master] );
       scaledDelta = FT_MulFix( scalar, delta );
 
       /* accumulate the adjustments from each region */
       netAdjustment = netAdjustment + scaledDelta;
 
     } /* per-region loop */
 
     return FT_fixedToInt( netAdjustment );
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_hvadvance_adjust
    *
    * @Description:
    *   Apply `HVAR' advance width or `VVAR' advance height adjustment of
    *   a given glyph.
    *
    * @Input:
    *   gindex ::
    *     The glyph index.
    *
    *   vertical ::
    *     If set, handle `VVAR' table.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *
    *   adelta ::
    *     Points to width or height value that gets modified.
    */
   static FT_Error
   tt_hvadvance_adjust( TT_Face  face,
                        FT_UInt  gindex,
                        FT_Int  *avalue,
                        FT_Bool  vertical )
   {
     FT_Error  error = FT_Err_Ok;
     FT_UInt   innerIndex, outerIndex;
     FT_Int    delta;
 
     GX_HVVarTable  table;
 
 
     if ( !face->doblend || !face->blend )
       goto Exit;
 
     if ( vertical )
     {
       if ( !face->blend->vvar_loaded )
       {
         /* initialize vvar table */
         face->blend->vvar_error = ft_var_load_hvvar( face, 1 );
       }
 
       if ( !face->blend->vvar_checked )
       {
         error = face->blend->vvar_error;
         goto Exit;
       }
 
       table = face->blend->vvar_table;
     }
     else
     {
       if ( !face->blend->hvar_loaded )
       {
         /* initialize hvar table */
         face->blend->hvar_error = ft_var_load_hvvar( face, 0 );
       }
 
       if ( !face->blend->hvar_checked )
       {
         error = face->blend->hvar_error;
         goto Exit;
       }
 
       table = face->blend->hvar_table;
     }
 
     /* advance width or height adjustments are always present in an */
     /* `HVAR' or `VVAR' table; no need to test for this capability  */
 
     if ( table->widthMap.innerIndex )
     {
       FT_UInt  idx = gindex;
 
 
       if ( idx >= table->widthMap.mapCount )
         idx = table->widthMap.mapCount - 1;
 
       /* trust that HVAR parser has checked indices */
       outerIndex = table->widthMap.outerIndex[idx];
       innerIndex = table->widthMap.innerIndex[idx];
     }
     else
     {
       GX_ItemVarData  varData;
 
 
       /* no widthMap data */
       outerIndex = 0;
       innerIndex = gindex;
 
       varData = &table->itemStore.varData[outerIndex];
       if ( gindex >= varData->itemCount )
       {
         FT_TRACE2(( "gindex %d out of range\n", gindex ));
         error = FT_THROW( Invalid_Argument );
         goto Exit;
       }
     }
 
     delta = ft_var_get_item_delta( face,
                                    &table->itemStore,
                                    outerIndex,
                                    innerIndex );
 
     FT_TRACE5(( "%s value %d adjusted by %d unit%s (%s)\n",
                 vertical ? "vertical height" : "horizontal width",
                 *avalue,
                 delta,
                 delta == 1 ? "" : "s",
                 vertical ? "VVAR" : "HVAR" ));
 
     *avalue += delta;
 
   Exit:
     return error;
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   tt_hadvance_adjust( TT_Face  face,
                       FT_UInt  gindex,
                       FT_Int  *avalue )
   {
     return tt_hvadvance_adjust( face, gindex, avalue, 0 );
   }
 
 
   FT_LOCAL_DEF( FT_Error )
   tt_vadvance_adjust( TT_Face  face,
                       FT_UInt  gindex,
                       FT_Int  *avalue )
   {
     return tt_hvadvance_adjust( face, gindex, avalue, 1 );
   }
 
 
 #define GX_VALUE_SIZE  8
 
   /* all values are FT_Short or FT_UShort entities; */
   /* we treat them consistently as FT_Short         */
 #define GX_VALUE_CASE( tag, dflt )      \
           case MVAR_TAG_ ## tag :       \
             p = (FT_Short*)&face->dflt; \
             break
 
 #define GX_GASP_CASE( idx )                                       \
           case MVAR_TAG_GASP_ ## idx :                            \
             if ( idx < face->gasp.numRanges - 1 )                 \
               p = (FT_Short*)&face->gasp.gaspRanges[idx].maxPPEM; \
             else                                                  \
               p = NULL;                                           \
             break
 
 
   static FT_Short*
   ft_var_get_value_pointer( TT_Face   face,
                             FT_ULong  mvar_tag )
   {
     FT_Short*  p;
 
 
     switch ( mvar_tag )
     {
       GX_GASP_CASE( 0 );
       GX_GASP_CASE( 1 );
       GX_GASP_CASE( 2 );
       GX_GASP_CASE( 3 );
       GX_GASP_CASE( 4 );
       GX_GASP_CASE( 5 );
       GX_GASP_CASE( 6 );
       GX_GASP_CASE( 7 );
       GX_GASP_CASE( 8 );
       GX_GASP_CASE( 9 );
 
       GX_VALUE_CASE( CPHT, os2.sCapHeight );
       GX_VALUE_CASE( HASC, os2.sTypoAscender );
       GX_VALUE_CASE( HCLA, os2.usWinAscent );
       GX_VALUE_CASE( HCLD, os2.usWinDescent );
       GX_VALUE_CASE( HCOF, horizontal.caret_Offset );
       GX_VALUE_CASE( HCRN, horizontal.caret_Slope_Run );
       GX_VALUE_CASE( HCRS, horizontal.caret_Slope_Rise );
       GX_VALUE_CASE( HDSC, os2.sTypoDescender );
       GX_VALUE_CASE( HLGP, os2.sTypoLineGap );
       GX_VALUE_CASE( SBXO, os2.ySubscriptXOffset);
       GX_VALUE_CASE( SBXS, os2.ySubscriptXSize );
       GX_VALUE_CASE( SBYO, os2.ySubscriptYOffset );
       GX_VALUE_CASE( SBYS, os2.ySubscriptYSize );
       GX_VALUE_CASE( SPXO, os2.ySuperscriptXOffset );
       GX_VALUE_CASE( SPXS, os2.ySuperscriptXSize );
       GX_VALUE_CASE( SPYO, os2.ySuperscriptYOffset );
       GX_VALUE_CASE( SPYS, os2.ySuperscriptYSize );
       GX_VALUE_CASE( STRO, os2.yStrikeoutPosition );
       GX_VALUE_CASE( STRS, os2.yStrikeoutSize );
       GX_VALUE_CASE( UNDO, postscript.underlinePosition );
       GX_VALUE_CASE( UNDS, postscript.underlineThickness );
       GX_VALUE_CASE( VASC, vertical.Ascender );
       GX_VALUE_CASE( VCOF, vertical.caret_Offset );
       GX_VALUE_CASE( VCRN, vertical.caret_Slope_Run );
       GX_VALUE_CASE( VCRS, vertical.caret_Slope_Rise );
       GX_VALUE_CASE( VDSC, vertical.Descender );
       GX_VALUE_CASE( VLGP, vertical.Line_Gap );
       GX_VALUE_CASE( XHGT, os2.sxHeight );
 
     default:
       /* ignore unknown tag */
       p = NULL;
     }
 
     return p;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_load_mvar
    *
    * @Description:
    *   Parse the `MVAR' table.
    *
    *   Some memory may remain allocated on error; it is always freed in
    *   `tt_done_blend', however.
    *
    * @InOut:
    *   face ::
    *     The font face.
    */
   static void
   ft_var_load_mvar( TT_Face  face )
   {
     FT_Stream  stream = FT_FACE_STREAM( face );
     FT_Memory  memory = stream->memory;
 
     GX_Blend         blend = face->blend;
     GX_ItemVarStore  itemStore;
     GX_Value         value, limit;
 
     FT_Error   error;
     FT_UShort  majorVersion;
     FT_ULong   table_len;
     FT_ULong   table_offset;
     FT_UShort  store_offset;
     FT_ULong   records_offset;
 
 
     FT_TRACE2(( "MVAR " ));
 
     error = face->goto_table( face, TTAG_MVAR, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
       return;
     }
 
     table_offset = FT_STREAM_POS();
 
     /* skip minor version */
     if ( FT_READ_USHORT( majorVersion ) ||
          FT_STREAM_SKIP( 2 )            )
       return;
 
     if ( majorVersion != 1 )
     {
       FT_TRACE2(( "bad table version %d\n", majorVersion ));
       return;
     }
 
     if ( FT_NEW( blend->mvar_table ) )
       return;
 
     /* skip reserved entry and value record size */
     if ( FT_STREAM_SKIP( 4 )                             ||
          FT_READ_USHORT( blend->mvar_table->valueCount ) ||
          FT_READ_USHORT( store_offset )                  )
       return;
 
     records_offset = FT_STREAM_POS();
 
     error = ft_var_load_item_variation_store(
               face,
               table_offset + store_offset,
               &blend->mvar_table->itemStore );
     if ( error )
       return;
 
     if ( FT_NEW_ARRAY( blend->mvar_table->values,
                        blend->mvar_table->valueCount ) )
       return;
 
     if ( FT_STREAM_SEEK( records_offset )                                ||
          FT_FRAME_ENTER( blend->mvar_table->valueCount * GX_VALUE_SIZE ) )
       return;
 
     value     = blend->mvar_table->values;
     limit     = value + blend->mvar_table->valueCount;
     itemStore = &blend->mvar_table->itemStore;
 
     for ( ; value < limit; value++ )
     {
       value->tag        = FT_GET_ULONG();
       value->outerIndex = FT_GET_USHORT();
       value->innerIndex = FT_GET_USHORT();
 
       if ( value->outerIndex >= itemStore->dataCount                  ||
            value->innerIndex >= itemStore->varData[value->outerIndex]
                                                   .itemCount          )
       {
         error = FT_THROW( Invalid_Table );
         break;
       }
     }
 
     FT_FRAME_EXIT();
 
     if ( error )
       return;
 
     FT_TRACE2(( "loaded\n" ));
 
     value = blend->mvar_table->values;
     limit = value + blend->mvar_table->valueCount;
 
     /* save original values of the data MVAR is going to modify */
     for ( ; value < limit; value++ )
     {
       FT_Short*  p = ft_var_get_value_pointer( face, value->tag );
 
 
       if ( p )
         value->unmodified = *p;
 #ifdef FT_DEBUG_LEVEL_TRACE
       else
         FT_TRACE1(( "ft_var_load_mvar: Ignoring unknown tag `%c%c%c%c'\n",
                     (FT_Char)( value->tag >> 24 ),
                     (FT_Char)( value->tag >> 16 ),
                     (FT_Char)( value->tag >> 8 ),
                     (FT_Char)( value->tag ) ));
 #endif
     }
 
     face->variation_support |= TT_FACE_FLAG_VAR_MVAR;
   }
 
 
   static FT_Error
   tt_size_reset_iterator( FT_ListNode  node,
                           void*        user )
   {
     TT_Size  size = (TT_Size)node->data;
 
     FT_UNUSED( user );
 
 
     tt_size_reset( size, 1 );
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_apply_mvar
    *
    * @Description:
    *   Apply `MVAR' table adjustments.
    *
    * @InOut:
    *   face ::
    *     The font face.
    */
   FT_LOCAL_DEF( void )
   tt_apply_mvar( TT_Face  face )
   {
     GX_Blend  blend = face->blend;
     GX_Value  value, limit;
     FT_Short  mvar_hasc_delta = 0;
     FT_Short  mvar_hdsc_delta = 0;
     FT_Short  mvar_hlgp_delta = 0;
 
 
     if ( !( face->variation_support & TT_FACE_FLAG_VAR_MVAR ) )
       return;
 
     value = blend->mvar_table->values;
     limit = value + blend->mvar_table->valueCount;
 
     for ( ; value < limit; value++ )
     {
       FT_Short*  p = ft_var_get_value_pointer( face, value->tag );
       FT_Int     delta;
 
 
       delta = ft_var_get_item_delta( face,
                                      &blend->mvar_table->itemStore,
                                      value->outerIndex,
                                      value->innerIndex );
 
       if ( p )
       {
         FT_TRACE5(( "value %c%c%c%c (%d unit%s) adjusted by %d unit%s (MVAR)\n",
                     (FT_Char)( value->tag >> 24 ),
                     (FT_Char)( value->tag >> 16 ),
                     (FT_Char)( value->tag >> 8 ),
                     (FT_Char)( value->tag ),
                     value->unmodified,
                     value->unmodified == 1 ? "" : "s",
                     delta,
                     delta == 1 ? "" : "s" ));
 
         /* since we handle both signed and unsigned values as FT_Short, */
         /* ensure proper overflow arithmetic                            */
         *p = (FT_Short)( value->unmodified + (FT_Short)delta );
 
         /* Treat hasc, hdsc and hlgp specially, see below. */
         if ( value->tag == MVAR_TAG_HASC )
           mvar_hasc_delta = (FT_Short)delta;
         else if ( value->tag == MVAR_TAG_HDSC )
           mvar_hdsc_delta = (FT_Short)delta;
         else if ( value->tag == MVAR_TAG_HLGP )
           mvar_hlgp_delta = (FT_Short)delta;
       }
     }
 
     /* adjust all derived values */
     {
       FT_Face  root = &face->root;
 
       /*
        * Apply the deltas of hasc, hdsc and hlgp to the FT_Face's ascender,
        * descender and height attributes, no matter how they were originally
        * computed.
        *
        * (Code that ignores those and accesses the font's metrics values
        * directly is already served by the delta application code above.)
        *
        * The MVAR table supports variations for both typo and win metrics.
        * According to Behdad Esfahbod, the thinking of the working group was
        * that no one uses win metrics anymore for setting line metrics (the
        * specification even calls these metrics "horizontal clipping
        * ascent/descent", probably for their role on the Windows platform in
        * computing clipping boxes), and new fonts should use typo metrics, so
        * typo deltas should be applied to whatever sfnt_load_face decided the
        * line metrics should be.
        *
        * Before, the following led to different line metrics between default
        * outline and instances, visible when e.g. the default outlines were
        * used as the regular face and instances for everything else:
        *
        * 1. sfnt_load_face applied the hhea metrics by default.
        * 2. This code later applied the typo metrics by default, regardless of
        *    whether they were actually changed or the font had the OS/2 table's
        *    fsSelection's bit 7 (USE_TYPO_METRICS) set.
        */
       FT_Short  current_line_gap = root->height - root->ascender +
                                    root->descender;
 
 
       root->ascender  = root->ascender + mvar_hasc_delta;
       root->descender = root->descender + mvar_hdsc_delta;
       root->height    = root->ascender - root->descender +
                         current_line_gap + mvar_hlgp_delta;
 
       root->underline_position  = face->postscript.underlinePosition -
                                   face->postscript.underlineThickness / 2;
       root->underline_thickness = face->postscript.underlineThickness;
 
       /* iterate over all FT_Size objects and call `tt_size_reset' */
       /* to propagate the metrics changes                          */
       FT_List_Iterate( &root->sizes_list,
                        tt_size_reset_iterator,
                        NULL );
     }
   }
 
 
   typedef struct  GX_GVar_Head_
   {
     FT_Long    version;
     FT_UShort  axisCount;
     FT_UShort  globalCoordCount;
     FT_ULong   offsetToCoord;
     FT_UShort  glyphCount;
     FT_UShort  flags;
     FT_ULong   offsetToData;
 
   } GX_GVar_Head;
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_load_gvar
    *
    * @Description:
    *   Parse the `gvar' table if present.  If `fvar' is there, `gvar' had
    *   better be there too.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   static FT_Error
   ft_var_load_gvar( TT_Face  face )
   {
     FT_Stream     stream = FT_FACE_STREAM( face );
     FT_Memory     memory = stream->memory;
     GX_Blend      blend  = face->blend;
     FT_Error      error;
     FT_UInt       i, j;
     FT_ULong      table_len;
     FT_ULong      gvar_start;
     FT_ULong      offsetToData;
     GX_GVar_Head  gvar_head;
 
     static const FT_Frame_Field  gvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_GVar_Head
 
       FT_FRAME_START( 20 ),
         FT_FRAME_LONG  ( version ),
         FT_FRAME_USHORT( axisCount ),
         FT_FRAME_USHORT( globalCoordCount ),
         FT_FRAME_ULONG ( offsetToCoord ),
         FT_FRAME_USHORT( glyphCount ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_ULONG ( offsetToData ),
       FT_FRAME_END
     };
 
 
     FT_TRACE2(( "GVAR " ));
 
     if ( FT_SET_ERROR( face->goto_table( face,
                                          TTAG_gvar,
                                          stream,
                                          &table_len ) ) )
     {
       FT_TRACE2(( "is missing\n" ));
       goto Exit;
     }
 
     gvar_start = FT_STREAM_POS( );
     if ( FT_STREAM_READ_FIELDS( gvar_fields, &gvar_head ) )
       goto Exit;
 
     if ( gvar_head.version != 0x00010000L )
     {
       FT_TRACE1(( "bad table version\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     if ( gvar_head.axisCount != (FT_UShort)blend->mmvar->num_axis )
     {
       FT_TRACE1(( "ft_var_load_gvar: number of axes in `gvar' and `cvar'\n"
                   "                  table are different\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* rough sanity check, ignoring offsets */
     if ( (FT_ULong)gvar_head.globalCoordCount * gvar_head.axisCount >
            table_len / 2 )
     {
       FT_TRACE1(( "ft_var_load_gvar:"
                   " invalid number of global coordinates\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     /* rough sanity check: offsets can be either 2 or 4 bytes */
     if ( (FT_ULong)gvar_head.glyphCount *
            ( ( gvar_head.flags & 1 ) ? 4 : 2 ) > table_len )
     {
       FT_TRACE1(( "ft_var_load_gvar: invalid number of glyphs\n" ));
       error = FT_THROW( Invalid_Table );
       goto Exit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     blend->gvar_size   = table_len;
     blend->tuplecount  = gvar_head.globalCoordCount;
     blend->gv_glyphcnt = gvar_head.glyphCount;
     offsetToData       = gvar_start + gvar_head.offsetToData;
 
     FT_TRACE5(( "gvar: there %s %d shared coordinate%s:\n",
                 blend->tuplecount == 1 ? "is" : "are",
                 blend->tuplecount,
                 blend->tuplecount == 1 ? "" : "s" ));
 
     if ( FT_NEW_ARRAY( blend->glyphoffsets, blend->gv_glyphcnt + 1 ) )
       goto Exit;
 
     if ( gvar_head.flags & 1 )
     {
       FT_ULong  limit = gvar_start + table_len;
 
 
       /* long offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 4L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; i++ )
       {
         blend->glyphoffsets[i] = offsetToData + FT_GET_ULONG();
         /* use `>', not `>=' */
         if ( blend->glyphoffsets[i] > limit )
         {
           FT_TRACE2(( "ft_var_load_gvar:"
                       " invalid glyph variation data offset for index %d\n",
                       i ));
           error = FT_THROW( Invalid_Table );
           break;
         }
       }
     }
     else
     {
       FT_ULong  limit = gvar_start + table_len;
 
 
       /* short offsets (one more offset than glyphs, to mark size of last) */
       if ( FT_FRAME_ENTER( ( blend->gv_glyphcnt + 1 ) * 2L ) )
         goto Exit;
 
       for ( i = 0; i <= blend->gv_glyphcnt; i++ )
       {
         blend->glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;
         /* use `>', not `>=' */
         if ( blend->glyphoffsets[i] > limit )
         {
           FT_TRACE2(( "ft_var_load_gvar:"
                       " invalid glyph variation data offset for index %d\n",
                       i ));
           error = FT_THROW( Invalid_Table );
           break;
         }
       }
     }
 
     FT_FRAME_EXIT();
     if ( error )
       goto Exit;
 
     if ( blend->tuplecount != 0 )
     {
       if ( FT_NEW_ARRAY( blend->tuplecoords,
                          gvar_head.axisCount * blend->tuplecount ) )
         goto Exit;
 
       if ( FT_STREAM_SEEK( gvar_start + gvar_head.offsetToCoord )         ||
            FT_FRAME_ENTER( blend->tuplecount * gvar_head.axisCount * 2L ) )
         goto Exit;
 
       for ( i = 0; i < blend->tuplecount; i++ )
       {
         FT_TRACE5(( "  [ " ));
         for ( j = 0; j < (FT_UInt)gvar_head.axisCount; j++ )
         {
           blend->tuplecoords[i * gvar_head.axisCount + j] =
             FT_fdot14ToFixed( FT_GET_SHORT() );
           FT_TRACE5(( "%.5f ",
             blend->tuplecoords[i * gvar_head.axisCount + j] / 65536.0 ));
         }
         FT_TRACE5(( "]\n" ));
       }
 
       FT_TRACE5(( "\n" ));
 
       FT_FRAME_EXIT();
     }
 
   Exit:
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   ft_var_apply_tuple
    *
    * @Description:
    *   Figure out whether a given tuple (design) applies to the current
    *   blend, and if so, what is the scaling factor.
    *
    * @Input:
    *   blend ::
    *     The current blend of the font.
    *
    *   tupleIndex ::
    *     A flag saying whether this is an intermediate
    *     tuple or not.
    *
    *   tuple_coords ::
    *     The coordinates of the tuple in normalized axis
    *     units.
    *
    *   im_start_coords ::
    *     The initial coordinates where this tuple starts
    *     to apply (for intermediate coordinates).
    *
    *   im_end_coords ::
    *     The final coordinates after which this tuple no
    *     longer applies (for intermediate coordinates).
    *
    * @Return:
    *   An FT_Fixed value containing the scaling factor.
    */
   static FT_Fixed
   ft_var_apply_tuple( GX_Blend   blend,
                       FT_UShort  tupleIndex,
                       FT_Fixed*  tuple_coords,
                       FT_Fixed*  im_start_coords,
                       FT_Fixed*  im_end_coords )
   {
     FT_UInt   i;
     FT_Fixed  apply = 0x10000L;
 
 
     for ( i = 0; i < blend->num_axis; i++ )
     {
       FT_TRACE6(( "    axis %d coordinate %.5f:\n",
                   i, blend->normalizedcoords[i] / 65536.0 ));
 
       /* It's not clear why (for intermediate tuples) we don't need     */
       /* to check against start/end -- the documentation says we don't. */
       /* Similarly, it's unclear why we don't need to scale along the   */
       /* axis.                                                          */
 
       if ( tuple_coords[i] == 0 )
       {
         FT_TRACE6(( "      tuple coordinate is zero, ignore\n", i ));
         continue;
       }
 
       if ( blend->normalizedcoords[i] == 0 )
       {
         FT_TRACE6(( "      axis coordinate is zero, stop\n" ));
         apply = 0;
         break;
       }
 
       if ( blend->normalizedcoords[i] == tuple_coords[i] )
       {
         FT_TRACE6(( "      tuple coordinate %.5f fits perfectly\n",
                     tuple_coords[i] / 65536.0 ));
         /* `apply' does not change */
         continue;
       }
 
       if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
       {
         /* not an intermediate tuple */
 
         if ( blend->normalizedcoords[i] < FT_MIN( 0, tuple_coords[i] ) ||
              blend->normalizedcoords[i] > FT_MAX( 0, tuple_coords[i] ) )
         {
           FT_TRACE6(( "      tuple coordinate %.5f is exceeded, stop\n",
                       tuple_coords[i] / 65536.0 ));
           apply = 0;
           break;
         }
 
         FT_TRACE6(( "      tuple coordinate %.5f fits\n",
                     tuple_coords[i] / 65536.0 ));
         apply = FT_MulDiv( apply,
                            blend->normalizedcoords[i],
                            tuple_coords[i] );
       }
       else
       {
         /* intermediate tuple */
 
         if ( blend->normalizedcoords[i] <= im_start_coords[i] ||
              blend->normalizedcoords[i] >= im_end_coords[i]   )
         {
           FT_TRACE6(( "      intermediate tuple range ]%.5f;%.5f[ is exceeded,"
                       " stop\n",
                       im_start_coords[i] / 65536.0,
                       im_end_coords[i] / 65536.0 ));
           apply = 0;
           break;
         }
 
         FT_TRACE6(( "      intermediate tuple range ]%.5f;%.5f[ fits\n",
                     im_start_coords[i] / 65536.0,
                     im_end_coords[i] / 65536.0 ));
         if ( blend->normalizedcoords[i] < tuple_coords[i] )
           apply = FT_MulDiv( apply,
                              blend->normalizedcoords[i] - im_start_coords[i],
                              tuple_coords[i] - im_start_coords[i] );
         else
           apply = FT_MulDiv( apply,
                              im_end_coords[i] - blend->normalizedcoords[i],
                              im_end_coords[i] - tuple_coords[i] );
       }
     }
 
     FT_TRACE6(( "    apply factor is %.5f\n", apply / 65536.0 ));
 
     return apply;
   }
 
 
   /* convert from design coordinates to normalized coordinates */
 
   static void
   ft_var_to_normalized( TT_Face    face,
                         FT_UInt    num_coords,
                         FT_Fixed*  coords,
                         FT_Fixed*  normalized )
   {
     GX_Blend        blend;
     FT_MM_Var*      mmvar;
     FT_UInt         i, j;
     FT_Var_Axis*    a;
     GX_AVarSegment  av;
 
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "ft_var_to_normalized:"
                   " only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     /* Axis normalization is a two-stage process.  First we normalize */
     /* based on the [min,def,max] values for the axis to be [-1,0,1]. */
     /* Then, if there's an `avar' table, we renormalize this range.   */
 
     a = mmvar->axis;
     for ( i = 0; i < num_coords; i++, a++ )
     {
       FT_Fixed  coord = coords[i];
 
 
       FT_TRACE5(( "    %d: %.5f\n", i, coord / 65536.0 ));
       if ( coord > a->maximum || coord < a->minimum )
       {
         FT_TRACE1((
           "ft_var_to_normalized: design coordinate %.5f\n"
           "                      is out of range [%.5f;%.5f]; clamping\n",
           coord / 65536.0,
           a->minimum / 65536.0,
           a->maximum / 65536.0 ));
 
         if ( coord > a->maximum )
           coord = a->maximum;
         else
           coord = a->minimum;
       }
 
       if ( coord < a->def )
         normalized[i] = -FT_DivFix( SUB_LONG( coord, a->def ),
                                     SUB_LONG( a->minimum, a->def ) );
       else if ( coord > a->def )
         normalized[i] = FT_DivFix( SUB_LONG( coord, a->def ),
                                    SUB_LONG( a->maximum, a->def ) );
       else
         normalized[i] = 0;
     }
 
     FT_TRACE5(( "\n" ));
 
     for ( ; i < mmvar->num_axis; i++ )
       normalized[i] = 0;
 
     if ( blend->avar_segment )
     {
       FT_TRACE5(( "normalized design coordinates"
                   " before applying `avar' data:\n" ));
 
       av = blend->avar_segment;
       for ( i = 0; i < mmvar->num_axis; i++, av++ )
       {
         for ( j = 1; j < (FT_UInt)av->pairCount; j++ )
         {
           if ( normalized[i] < av->correspondence[j].fromCoord )
           {
             FT_TRACE5(( "  %.5f\n", normalized[i] / 65536.0 ));
 
             normalized[i] =
               FT_MulDiv( normalized[i] - av->correspondence[j - 1].fromCoord,
                          av->correspondence[j].toCoord -
                            av->correspondence[j - 1].toCoord,
                          av->correspondence[j].fromCoord -
                            av->correspondence[j - 1].fromCoord ) +
               av->correspondence[j - 1].toCoord;
             break;
           }
         }
       }
     }
   }
 
 
   /* convert from normalized coordinates to design coordinates */
 
   static void
   ft_var_to_design( TT_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords,
                     FT_Fixed*  design )
   {
     GX_Blend      blend;
     FT_MM_Var*    mmvar;
     FT_Var_Axis*  a;
 
     FT_UInt  i, j, nc;
 
 
     blend = face->blend;
 
     nc = num_coords;
     if ( num_coords > blend->num_axis )
     {
       FT_TRACE2(( "ft_var_to_design:"
                   " only using first %d of %d coordinates\n",
                   blend->num_axis, num_coords ));
       nc = blend->num_axis;
     }
 
     for ( i = 0; i < nc; i++ )
       design[i] = coords[i];
 
     for ( ; i < num_coords; i++ )
       design[i] = 0;
 
     if ( blend->avar_segment )
     {
       GX_AVarSegment  av = blend->avar_segment;
 
 
       FT_TRACE5(( "design coordinates"
                   " after removing `avar' distortion:\n" ));
 
       for ( i = 0; i < nc; i++, av++ )
       {
         for ( j = 1; j < (FT_UInt)av->pairCount; j++ )
         {
           if ( design[i] < av->correspondence[j].toCoord )
           {
             design[i] =
               FT_MulDiv( design[i] - av->correspondence[j - 1].toCoord,
                          av->correspondence[j].fromCoord -
                            av->correspondence[j - 1].fromCoord,
                          av->correspondence[j].toCoord -
                            av->correspondence[j - 1].toCoord ) +
               av->correspondence[j - 1].fromCoord;
 
             FT_TRACE5(( "  %.5f\n", design[i] / 65536.0 ));
             break;
           }
         }
       }
     }
 
     mmvar = blend->mmvar;
     a     = mmvar->axis;
 
     for ( i = 0; i < nc; i++, a++ )
     {
       if ( design[i] < 0 )
         design[i] = a->def + FT_MulFix( design[i],
                                         a->def - a->minimum );
       else if ( design[i] > 0 )
         design[i] = a->def + FT_MulFix( design[i],
                                         a->maximum - a->def );
       else
         design[i] = a->def;
     }
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****               MULTIPLE MASTERS SERVICE FUNCTIONS              *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   typedef struct  GX_FVar_Head_
   {
     FT_Long    version;
     FT_UShort  offsetToData;
     FT_UShort  axisCount;
     FT_UShort  axisSize;
     FT_UShort  instanceCount;
     FT_UShort  instanceSize;
 
   } GX_FVar_Head;
 
 
   typedef struct  fvar_axis_
   {
     FT_ULong   axisTag;
     FT_Fixed   minValue;
     FT_Fixed   defaultValue;
     FT_Fixed   maxValue;
     FT_UShort  flags;
     FT_UShort  nameID;
 
   } GX_FVar_Axis;
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Get_MM_Var
    *
    * @Description:
    *   Check that the font's `fvar' table is valid, parse it, and return
    *   those data.  It also loads (and parses) the `MVAR' table, if
    *   possible.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *     TT_Get_MM_Var initializes the blend structure.
    *
    * @Output:
    *   master ::
    *     The `fvar' data (must be freed by caller).  Can be NULL,
    *     which makes this function simply load MM support.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_MM_Var( TT_Face      face,
                  FT_MM_Var*  *master )
   {
     FT_Stream            stream     = face->root.stream;
     FT_Memory            memory     = face->root.memory;
     FT_ULong             table_len;
     FT_Error             error      = FT_Err_Ok;
     FT_ULong             fvar_start = 0;
     FT_UInt              i, j;
     FT_MM_Var*           mmvar = NULL;
     FT_Fixed*            next_coords;
     FT_Fixed*            nsc;
     FT_String*           next_name;
     FT_Var_Axis*         a;
     FT_Fixed*            c;
     FT_Var_Named_Style*  ns;
     GX_FVar_Head         fvar_head;
     FT_Bool              usePsName  = 0;
     FT_UInt              num_instances;
     FT_UInt              num_axes;
     FT_UShort*           axis_flags;
 
     FT_Offset  mmvar_size;
     FT_Offset  axis_flags_size;
     FT_Offset  axis_size;
     FT_Offset  namedstyle_size;
     FT_Offset  next_coords_size;
     FT_Offset  next_name_size;
 
     FT_Bool  need_init;
 
     static const FT_Frame_Field  fvar_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Head
 
       FT_FRAME_START( 16 ),
         FT_FRAME_LONG      ( version ),
         FT_FRAME_USHORT    ( offsetToData ),
         FT_FRAME_SKIP_SHORT,
         FT_FRAME_USHORT    ( axisCount ),
         FT_FRAME_USHORT    ( axisSize ),
         FT_FRAME_USHORT    ( instanceCount ),
         FT_FRAME_USHORT    ( instanceSize ),
       FT_FRAME_END
     };
 
     static const FT_Frame_Field  fvaraxis_fields[] =
     {
 
 #undef  FT_STRUCTURE
 #define FT_STRUCTURE  GX_FVar_Axis
 
       FT_FRAME_START( 20 ),
         FT_FRAME_ULONG ( axisTag ),
         FT_FRAME_LONG  ( minValue ),
         FT_FRAME_LONG  ( defaultValue ),
         FT_FRAME_LONG  ( maxValue ),
         FT_FRAME_USHORT( flags ),
         FT_FRAME_USHORT( nameID ),
       FT_FRAME_END
     };
 
 
     /* read the font data and set up the internal representation */
     /* if not already done                                       */
 
     need_init = !face->blend;
 
     if ( need_init )
     {
       FT_TRACE2(( "FVAR " ));
 
       /* both `fvar' and `gvar' must be present */
       if ( FT_SET_ERROR( face->goto_table( face, TTAG_gvar,
                                            stream, &table_len ) ) )
       {
         /* CFF2 is an alternate to gvar here */
         if ( FT_SET_ERROR( face->goto_table( face, TTAG_CFF2,
                                              stream, &table_len ) ) )
         {
           FT_TRACE1(( "\n"
                       "TT_Get_MM_Var: `gvar' or `CFF2' table is missing\n" ));
           goto Exit;
         }
       }
 
       if ( FT_SET_ERROR( face->goto_table( face, TTAG_fvar,
                                            stream, &table_len ) ) )
       {
         FT_TRACE1(( "is missing\n" ));
         goto Exit;
       }
 
       fvar_start = FT_STREAM_POS( );
 
       /* the validity of the `fvar' header data was already checked */
       /* in function `sfnt_init_face'                               */
       if ( FT_STREAM_READ_FIELDS( fvar_fields, &fvar_head ) )
         goto Exit;
 
       usePsName = FT_BOOL( fvar_head.instanceSize ==
                            6 + 4 * fvar_head.axisCount );
 
       FT_TRACE2(( "loaded\n" ));
 
       FT_TRACE5(( "%d variation ax%s\n",
                   fvar_head.axisCount,
                   fvar_head.axisCount == 1 ? "is" : "es" ));
 
       if ( FT_NEW( face->blend ) )
         goto Exit;
 
       num_axes              = fvar_head.axisCount;
       face->blend->num_axis = num_axes;
     }
     else
       num_axes = face->blend->num_axis;
 
     /* `num_instances' holds the number of all named instances, */
     /* including the default instance which might be missing    */
     /* in fvar's table of named instances                       */
     num_instances = (FT_UInt)face->root.style_flags >> 16;
 
     /* prepare storage area for MM data; this cannot overflow   */
     /* 32-bit arithmetic because of the size limits used in the */
     /* `fvar' table validity check in `sfnt_init_face'          */
 
     /* the various `*_size' variables, which we also use as     */
     /* offsets into the `mmlen' array, must be multiples of the */
     /* pointer size (except the last one); without such an      */
     /* alignment there might be runtime errors due to           */
     /* misaligned addresses                                     */
 #undef  ALIGN_SIZE
 #define ALIGN_SIZE( n ) \
           ( ( (n) + sizeof (void*) - 1 ) & ~( sizeof (void*) - 1 ) )
 
     mmvar_size       = ALIGN_SIZE( sizeof ( FT_MM_Var ) );
     axis_flags_size  = ALIGN_SIZE( num_axes *
                                    sizeof ( FT_UShort ) );
     axis_size        = ALIGN_SIZE( num_axes *
                                    sizeof ( FT_Var_Axis ) );
     namedstyle_size  = ALIGN_SIZE( num_instances *
                                    sizeof ( FT_Var_Named_Style ) );
     next_coords_size = ALIGN_SIZE( num_instances *
                                    num_axes *
                                    sizeof ( FT_Fixed ) );
     next_name_size   = num_axes * 5;
 
     if ( need_init )
     {
       face->blend->mmvar_len = mmvar_size       +
                                axis_flags_size  +
                                axis_size        +
                                namedstyle_size  +
                                next_coords_size +
                                next_name_size;
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       face->blend->mmvar = mmvar;
 
       /* set up pointers and offsets into the `mmvar' array; */
       /* the data gets filled in later on                    */
 
       mmvar->num_axis =
         num_axes;
       mmvar->num_designs =
         ~0U;                   /* meaningless in this context; each glyph */
                                /* may have a different number of designs  */
                                /* (or tuples, as called by Apple)         */
       mmvar->num_namedstyles =
         num_instances;
 
       /* alas, no public field in `FT_Var_Axis' for axis flags */
       axis_flags =
         (FT_UShort*)( (char*)mmvar + mmvar_size );
       mmvar->axis =
         (FT_Var_Axis*)( (char*)axis_flags + axis_flags_size );
       mmvar->namedstyle =
         (FT_Var_Named_Style*)( (char*)mmvar->axis + axis_size );
 
       next_coords = (FT_Fixed*)( (char*)mmvar->namedstyle +
                                  namedstyle_size );
       for ( i = 0; i < num_instances; i++ )
       {
         mmvar->namedstyle[i].coords  = next_coords;
         next_coords                 += num_axes;
       }
 
       next_name = (FT_String*)( (char*)mmvar->namedstyle +
                                 namedstyle_size + next_coords_size );
       for ( i = 0; i < num_axes; i++ )
       {
         mmvar->axis[i].name  = next_name;
         next_name           += 5;
       }
 
       /* now fill in the data */
 
       if ( FT_STREAM_SEEK( fvar_start + fvar_head.offsetToData ) )
         goto Exit;
 
       a = mmvar->axis;
       for ( i = 0; i < num_axes; i++ )
       {
         GX_FVar_Axis  axis_rec;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  invalid = 0;
 #endif
 
 
         if ( FT_STREAM_READ_FIELDS( fvaraxis_fields, &axis_rec ) )
           goto Exit;
         a->tag     = axis_rec.axisTag;
         a->minimum = axis_rec.minValue;
         a->def     = axis_rec.defaultValue;
         a->maximum = axis_rec.maxValue;
         a->strid   = axis_rec.nameID;
 
         a->name[0] = (FT_String)(   a->tag >> 24 );
         a->name[1] = (FT_String)( ( a->tag >> 16 ) & 0xFF );
         a->name[2] = (FT_String)( ( a->tag >>  8 ) & 0xFF );
         a->name[3] = (FT_String)( ( a->tag       ) & 0xFF );
         a->name[4] = '\0';
 
         *axis_flags = axis_rec.flags;
 
         if ( a->minimum > a->def ||
              a->def > a->maximum )
         {
           a->minimum = a->def;
           a->maximum = a->def;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           invalid = 1;
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( i == 0 )
           FT_TRACE5(( "  idx   tag  "
                    /* "  XXX  `XXXX'" */
                       "    minimum     default     maximum   flags\n" ));
                    /* "  XXXX.XXXXX  XXXX.XXXXX  XXXX.XXXXX  0xXXXX" */
 
         FT_TRACE5(( "  %3d  `%s'"
                     "  %10.5f  %10.5f  %10.5f  0x%04X%s\n",
                     i,
                     a->name,
                     a->minimum / 65536.0,
                     a->def / 65536.0,
                     a->maximum / 65536.0,
                     *axis_flags,
                     invalid ? " (invalid, disabled)" : "" ));
 #endif
 
         a++;
         axis_flags++;
       }
 
       FT_TRACE5(( "\n" ));
 
       /* named instance coordinates are stored as design coordinates; */
       /* we have to convert them to normalized coordinates also       */
       if ( FT_NEW_ARRAY( face->blend->normalized_stylecoords,
                          num_axes * num_instances ) )
         goto Exit;
 
       if ( fvar_head.instanceCount && !face->blend->avar_loaded )
       {
         FT_ULong  offset = FT_STREAM_POS();
 
 
         ft_var_load_avar( face );
 
         if ( FT_STREAM_SEEK( offset ) )
           goto Exit;
       }
 
       FT_TRACE5(( "%d instance%s\n",
                   fvar_head.instanceCount,
                   fvar_head.instanceCount == 1 ? "" : "s" ));
 
       ns  = mmvar->namedstyle;
       nsc = face->blend->normalized_stylecoords;
       for ( i = 0; i < fvar_head.instanceCount; i++, ns++ )
       {
         /* PostScript names add 2 bytes to the instance record size */
         if ( FT_FRAME_ENTER( ( usePsName ? 6L : 4L ) +
                              4L * num_axes ) )
           goto Exit;
 
         ns->strid       =    FT_GET_USHORT();
         (void) /* flags = */ FT_GET_USHORT();
 
         c = ns->coords;
         for ( j = 0; j < num_axes; j++, c++ )
           *c = FT_GET_LONG();
 
         /* valid psid values are 6, [256;32767], and 0xFFFF */
         if ( usePsName )
           ns->psid = FT_GET_USHORT();
         else
           ns->psid = 0xFFFF;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         {
           SFNT_Service  sfnt = (SFNT_Service)face->sfnt;
 
           FT_String*  strname = NULL;
           FT_String*  psname  = NULL;
 
           FT_ULong  pos;
 
 
           pos = FT_STREAM_POS();
 
           if ( ns->strid != 0xFFFF )
           {
             (void)sfnt->get_name( face,
                                   (FT_UShort)ns->strid,
                                   &strname );
             if ( strname && !ft_strcmp( strname, ".notdef" ) )
               strname = NULL;
           }
 
           if ( ns->psid != 0xFFFF )
           {
             (void)sfnt->get_name( face,
                                   (FT_UShort)ns->psid,
                                   &psname );
             if ( psname && !ft_strcmp( psname, ".notdef" ) )
               psname = NULL;
           }
 
           (void)FT_STREAM_SEEK( pos );
 
           FT_TRACE5(( "  instance %d (%s%s%s, %s%s%s)\n",
                       i,
                       strname ? "name: `" : "",
                       strname ? strname : "unnamed",
                       strname ? "'" : "",
                       psname ? "PS name: `" : "",
                       psname ? psname : "no PS name",
                       psname ? "'" : "" ));
 
           FT_FREE( strname );
           FT_FREE( psname );
         }
 #endif /* FT_DEBUG_LEVEL_TRACE */
 
         ft_var_to_normalized( face, num_axes, ns->coords, nsc );
         nsc += num_axes;
 
         FT_FRAME_EXIT();
       }
 
       if ( num_instances != fvar_head.instanceCount )
       {
         SFNT_Service  sfnt = (SFNT_Service)face->sfnt;
 
         FT_Int   found, dummy1, dummy2;
         FT_UInt  strid = ~0U;
 
 
         /* the default instance is missing in array the   */
         /* of named instances; try to synthesize an entry */
         found = sfnt->get_name_id( face,
                                    TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY,
                                    &dummy1,
                                    &dummy2 );
         if ( found )
           strid = TT_NAME_ID_TYPOGRAPHIC_SUBFAMILY;
         else
         {
           found = sfnt->get_name_id( face,
                                      TT_NAME_ID_FONT_SUBFAMILY,
                                      &dummy1,
                                      &dummy2 );
           if ( found )
             strid = TT_NAME_ID_FONT_SUBFAMILY;
         }
 
         if ( found )
         {
           found = sfnt->get_name_id( face,
                                      TT_NAME_ID_PS_NAME,
                                      &dummy1,
                                      &dummy2 );
           if ( found )
           {
             FT_TRACE5(( "TT_Get_MM_Var:"
                         " Adding default instance to named instances\n" ));
 
             ns = &mmvar->namedstyle[fvar_head.instanceCount];
 
             ns->strid = strid;
             ns->psid  = TT_NAME_ID_PS_NAME;
 
             a = mmvar->axis;
             c = ns->coords;
             for ( j = 0; j < num_axes; j++, a++, c++ )
               *c = a->def;
           }
         }
       }
 
       ft_var_load_mvar( face );
     }
 
     /* fill the output array if requested */
 
     if ( master )
     {
       FT_UInt  n;
 
 
       if ( FT_ALLOC( mmvar, face->blend->mmvar_len ) )
         goto Exit;
       FT_MEM_COPY( mmvar, face->blend->mmvar, face->blend->mmvar_len );
 
       axis_flags =
         (FT_UShort*)( (char*)mmvar + mmvar_size );
       mmvar->axis =
         (FT_Var_Axis*)( (char*)axis_flags + axis_flags_size );
       mmvar->namedstyle =
         (FT_Var_Named_Style*)( (char*)mmvar->axis+ axis_size );
 
       next_coords = (FT_Fixed*)( (char*)mmvar->namedstyle +
                                  namedstyle_size );
       for ( n = 0; n < mmvar->num_namedstyles; n++ )
       {
         mmvar->namedstyle[n].coords  = next_coords;
         next_coords                 += num_axes;
       }
 
       a         = mmvar->axis;
       next_name = (FT_String*)( (char*)mmvar->namedstyle +
                                 namedstyle_size + next_coords_size );
       for ( n = 0; n < num_axes; n++ )
       {
         a->name = next_name;
 
         /* standard PostScript names for some standard apple tags */
         if ( a->tag == TTAG_wght )
           a->name = (char*)"Weight";
         else if ( a->tag == TTAG_wdth )
           a->name = (char*)"Width";
         else if ( a->tag == TTAG_opsz )
           a->name = (char*)"OpticalSize";
         else if ( a->tag == TTAG_slnt )
           a->name = (char*)"Slant";
 
         next_name += 5;
         a++;
       }
 
       *master = mmvar;
     }
 
   Exit:
     return error;
   }
 
 
   static FT_Error
   tt_set_mm_blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords,
                    FT_Bool    set_design_coords )
   {
     FT_Error    error = FT_Err_Ok;
     GX_Blend    blend;
     FT_MM_Var*  mmvar;
     FT_UInt     i;
 
     FT_Bool     all_design_coords = FALSE;
 
     FT_Memory   memory = face->root.memory;
 
     enum
     {
       mcvt_retain,
       mcvt_modify,
       mcvt_load
 
     } manageCvt;
 
 
     face->doblend = FALSE;
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "TT_Set_MM_Blend:"
                   " only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     FT_TRACE5(( "TT_Set_MM_Blend:\n"
                 "  normalized design coordinates:\n" ));
 
     for ( i = 0; i < num_coords; i++ )
     {
       FT_TRACE5(( "    %.5f\n", coords[i] / 65536.0 ));
       if ( coords[i] < -0x00010000L || coords[i] > 0x00010000L )
       {
         FT_TRACE1(( "TT_Set_MM_Blend: normalized design coordinate %.5f\n"
                     "                 is out of range [-1;1]\n",
                     coords[i] / 65536.0 ));
         error = FT_THROW( Invalid_Argument );
         goto Exit;
       }
     }
 
     FT_TRACE5(( "\n" ));
 
     if ( !face->is_cff2 && !blend->glyphoffsets )
       if ( FT_SET_ERROR( ft_var_load_gvar( face ) ) )
         goto Exit;
 
     if ( !blend->coords )
     {
       if ( FT_NEW_ARRAY( blend->coords, mmvar->num_axis ) )
         goto Exit;
 
       /* the first time we have to compute all design coordinates */
       all_design_coords = TRUE;
     }
 
     if ( !blend->normalizedcoords )
     {
       if ( FT_NEW_ARRAY( blend->normalizedcoords, mmvar->num_axis ) )
         goto Exit;
 
       manageCvt = mcvt_modify;
 
       /* If we have not set the blend coordinates before this, then the  */
       /* cvt table will still be what we read from the `cvt ' table and  */
       /* we don't need to reload it.  We may need to change it though... */
     }
     else
     {
       FT_Bool    have_diff = 0;
       FT_UInt    j;
       FT_Fixed*  c;
       FT_Fixed*  n;
 
 
       manageCvt = mcvt_retain;
 
       for ( i = 0; i < num_coords; i++ )
       {
         if ( blend->normalizedcoords[i] != coords[i] )
         {
           manageCvt = mcvt_load;
           have_diff = 1;
           break;
         }
       }
 
       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )
       {
         FT_UInt  instance_index = (FT_UInt)face->root.face_index >> 16;
 
 
         c = blend->normalizedcoords + i;
         n = blend->normalized_stylecoords            +
             ( instance_index - 1 ) * mmvar->num_axis +
             i;
 
         for ( j = i; j < mmvar->num_axis; j++, n++, c++ )
           if ( *c != *n )
             have_diff = 1;
       }
       else
       {
         c = blend->normalizedcoords + i;
         for ( j = i; j < mmvar->num_axis; j++, c++ )
           if ( *c != 0 )
             have_diff = 1;
       }
 
       /* return value -1 indicates `no change' */
       if ( !have_diff )
       {
         face->doblend = TRUE;
 
         return -1;
       }
 
       for ( ; i < mmvar->num_axis; i++ )
       {
         if ( blend->normalizedcoords[i] != 0 )
         {
           manageCvt = mcvt_load;
           break;
         }
       }
 
       /* If we don't change the blend coords then we don't need to do  */
       /* anything to the cvt table.  It will be correct.  Otherwise we */
       /* no longer have the original cvt (it was modified when we set  */
       /* the blend last time), so we must reload and then modify it.   */
     }
 
     blend->num_axis = mmvar->num_axis;
     FT_MEM_COPY( blend->normalizedcoords,
                  coords,
                  num_coords * sizeof ( FT_Fixed ) );
 
     if ( set_design_coords )
       ft_var_to_design( face,
                         all_design_coords ? blend->num_axis : num_coords,
                         blend->normalizedcoords,
                         blend->coords );
 
     face->doblend = TRUE;
 
     if ( face->cvt )
     {
       switch ( manageCvt )
       {
       case mcvt_load:
         /* The cvt table has been loaded already; every time we change the */
         /* blend we may need to reload and remodify the cvt table.         */
         FT_FREE( face->cvt );
         face->cvt = NULL;
 
         error = tt_face_load_cvt( face, face->root.stream );
         break;
 
       case mcvt_modify:
         /* The original cvt table is in memory.  All we need to do is */
         /* apply the `cvar' table (if any).                           */
         error = tt_face_vary_cvt( face, face->root.stream );
         break;
 
       case mcvt_retain:
         /* The cvt table is correct for this set of coordinates. */
         break;
       }
     }
 
     /* enforce recomputation of the PostScript name; */
     FT_FREE( face->postscript_name );
     face->postscript_name = NULL;
 
   Exit:
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Set_MM_Blend
    *
    * @Description:
    *   Set the blend (normalized) coordinates for this instance of the
    *   font.  Check that the `gvar' table is reasonable and does some
    *   initial preparation.
    *
    * @InOut:
    *   face ::
    *     The font.
    *     Initialize the blend structure with `gvar' data.
    *
    * @Input:
    *   num_coords ::
    *     The number of available coordinates.  If it is
    *     larger than the number of axes, ignore the excess
    *     values.  If it is smaller than the number of axes,
    *     use the default value (0) for the remaining axes.
    *
    *   coords ::
    *     An array of `num_coords', each between [-1,1].
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_MM_Blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords )
   {
     FT_Error  error;
 
 
     error = tt_set_mm_blend( face, num_coords, coords, 1 );
     if ( error )
       return error;
 
     if ( num_coords )
       face->root.face_flags |= FT_FACE_FLAG_VARIATION;
     else
       face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Get_MM_Blend
    *
    * @Description:
    *   Get the blend (normalized) coordinates for this instance of the
    *   font.
    *
    * @InOut:
    *   face ::
    *     The font.
    *     Initialize the blend structure with `gvar' data.
    *
    * @Input:
    *   num_coords ::
    *     The number of available coordinates.  If it is
    *     larger than the number of axes, set the excess
    *     values to 0.
    *
    *   coords ::
    *     An array of `num_coords', each between [-1,1].
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_MM_Blend( TT_Face    face,
                    FT_UInt    num_coords,
                    FT_Fixed*  coords )
   {
     FT_Error  error = FT_Err_Ok;
     GX_Blend  blend;
     FT_UInt   i, nc;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         return error;
     }
 
     blend = face->blend;
 
     if ( !blend->coords )
     {
       /* select default instance coordinates */
       /* if no instance is selected yet      */
       if ( FT_SET_ERROR( tt_set_mm_blend( face, 0, NULL, 1 ) ) )
         return error;
     }
 
     nc = num_coords;
     if ( num_coords > blend->num_axis )
     {
       FT_TRACE2(( "TT_Get_MM_Blend:"
                   " only using first %d of %d coordinates\n",
                   blend->num_axis, num_coords ));
       nc = blend->num_axis;
     }
 
     if ( face->doblend )
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = blend->normalizedcoords[i];
     }
     else
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = 0;
     }
 
     for ( ; i < num_coords; i++ )
       coords[i] = 0;
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Set_Var_Design
    *
    * @Description:
    *   Set the coordinates for the instance, measured in the user
    *   coordinate system.  Parse the `avar' table (if present) to convert
    *   from user to normalized coordinates.
    *
    * @InOut:
    *   face ::
    *     The font face.
    *     Initialize the blend struct with `gvar' data.
    *
    * @Input:
    *   num_coords ::
    *     The number of available coordinates.  If it is
    *     larger than the number of axes, ignore the excess
    *     values.  If it is smaller than the number of axes,
    *     use the default values for the remaining axes.
    *
    *   coords ::
    *     A coordinate array with `num_coords' elements.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_Var_Design( TT_Face    face,
                      FT_UInt    num_coords,
                      FT_Fixed*  coords )
   {
     FT_Error    error  = FT_Err_Ok;
     GX_Blend    blend;
     FT_MM_Var*  mmvar;
     FT_UInt     i;
     FT_Memory   memory = face->root.memory;
 
     FT_Fixed*  c;
     FT_Fixed*  n;
     FT_Fixed*  normalized = NULL;
 
     FT_Bool  have_diff = 0;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     if ( num_coords > mmvar->num_axis )
     {
       FT_TRACE2(( "TT_Set_Var_Design:"
                   " only using first %d of %d coordinates\n",
                   mmvar->num_axis, num_coords ));
       num_coords = mmvar->num_axis;
     }
 
     if ( !blend->coords )
     {
       if ( FT_NEW_ARRAY( blend->coords, mmvar->num_axis ) )
         goto Exit;
     }
 
     c = blend->coords;
     n = coords;
     for ( i = 0; i < num_coords; i++, n++, c++ )
     {
       if ( *c != *n )
       {
         *c        = *n;
         have_diff = 1;
       }
     }
 
     if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )
     {
       FT_UInt              instance_index;
       FT_Var_Named_Style*  named_style;
 
 
       instance_index = (FT_UInt)face->root.face_index >> 16;
       named_style    = mmvar->namedstyle + instance_index - 1;
 
       n = named_style->coords + num_coords;
       for ( ; i < mmvar->num_axis; i++, n++, c++ )
       {
         if ( *c != *n )
         {
           *c        = *n;
           have_diff = 1;
         }
       }
     }
     else
     {
       FT_Var_Axis*  a;
 
 
       a = mmvar->axis + num_coords;
       for ( ; i < mmvar->num_axis; i++, a++, c++ )
       {
         if ( *c != a->def )
         {
           *c        = a->def;
           have_diff = 1;
         }
       }
     }
 
     /* return value -1 indicates `no change';                      */
     /* we can exit early if `normalizedcoords' is already computed */
     if ( blend->normalizedcoords && !have_diff )
       return -1;
 
     if ( FT_NEW_ARRAY( normalized, mmvar->num_axis ) )
       goto Exit;
 
     if ( !face->blend->avar_loaded )
       ft_var_load_avar( face );
 
     FT_TRACE5(( "TT_Set_Var_Design:\n"
                 "  normalized design coordinates:\n" ));
     ft_var_to_normalized( face, num_coords, blend->coords, normalized );
 
     error = tt_set_mm_blend( face, mmvar->num_axis, normalized, 0 );
     if ( error )
       goto Exit;
 
     if ( num_coords )
       face->root.face_flags |= FT_FACE_FLAG_VARIATION;
     else
       face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;
 
   Exit:
     FT_FREE( normalized );
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Get_Var_Design
    *
    * @Description:
    *   Get the design coordinates of the currently selected interpolated
    *   font.
    *
    * @Input:
    *   face ::
    *     A handle to the source face.
    *
    *   num_coords ::
    *     The number of design coordinates to retrieve.  If it
    *     is larger than the number of axes, set the excess
    *     values to~0.
    *
    * @Output:
    *   coords ::
    *     The design coordinates array.
    *
    * @Return:
    *   FreeType error code.  0~means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Get_Var_Design( TT_Face    face,
                      FT_UInt    num_coords,
                      FT_Fixed*  coords )
   {
     FT_Error  error = FT_Err_Ok;
     GX_Blend  blend;
     FT_UInt   i, nc;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         return error;
     }
 
     blend = face->blend;
 
     if ( !blend->coords )
     {
       /* select default instance coordinates */
       /* if no instance is selected yet      */
       if ( FT_SET_ERROR( tt_set_mm_blend( face, 0, NULL, 1 ) ) )
         return error;
     }
 
     nc = num_coords;
     if ( num_coords > blend->num_axis )
     {
       FT_TRACE2(( "TT_Get_Var_Design:"
                   " only using first %d of %d coordinates\n",
                   blend->num_axis, num_coords ));
       nc = blend->num_axis;
     }
 
     if ( face->doblend )
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = blend->coords[i];
     }
     else
     {
       for ( i = 0; i < nc; i++ )
         coords[i] = 0;
     }
 
     for ( ; i < num_coords; i++ )
       coords[i] = 0;
 
     return FT_Err_Ok;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Set_Named_Instance
    *
    * @Description:
    *   Set the given named instance, also resetting any further
    *   variation.
    *
    * @Input:
    *   face ::
    *     A handle to the source face.
    *
    *   instance_index ::
    *     The instance index, starting with value 1.
    *     Value 0 indicates to not use an instance.
    *
    * @Return:
    *   FreeType error code.  0~means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Set_Named_Instance( TT_Face  face,
                          FT_UInt  instance_index )
   {
     FT_Error    error = FT_ERR( Invalid_Argument );
     GX_Blend    blend;
     FT_MM_Var*  mmvar;
 
     FT_UInt  num_instances;
 
 
     if ( !face->blend )
     {
       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
         goto Exit;
     }
 
     blend = face->blend;
     mmvar = blend->mmvar;
 
     num_instances = (FT_UInt)face->root.style_flags >> 16;
 
     /* `instance_index' starts with value 1, thus `>' */
     if ( instance_index > num_instances )
       goto Exit;
 
     if ( instance_index > 0 )
     {
       FT_Memory     memory = face->root.memory;
       SFNT_Service  sfnt   = (SFNT_Service)face->sfnt;
 
       FT_Var_Named_Style*  named_style;
       FT_String*           style_name;
 
 
       named_style = mmvar->namedstyle + instance_index - 1;
 
       error = sfnt->get_name( face,
                               (FT_UShort)named_style->strid,
                               &style_name );
       if ( error )
         goto Exit;
 
       /* set (or replace) style name */
       FT_FREE( face->root.style_name );
       face->root.style_name = style_name;
 
       /* finally, select the named instance */
       error = TT_Set_Var_Design( face,
                                  mmvar->num_axis,
                                  named_style->coords );
       if ( error )
       {
         /* internal error code -1 means `no change' */
         if ( error == -1 )
           error = FT_Err_Ok;
         goto Exit;
       }
     }
     else
       error = TT_Set_Var_Design( face, 0, NULL );
 
     face->root.face_index  = ( instance_index << 16 )             |
                              ( face->root.face_index & 0xFFFFL );
     face->root.face_flags &= ~FT_FACE_FLAG_VARIATION;
 
   Exit:
     return error;
   }
 
 
   /*************************************************************************/
   /*************************************************************************/
   /*****                                                               *****/
   /*****                     GX VAR PARSING ROUTINES                   *****/
   /*****                                                               *****/
   /*************************************************************************/
   /*************************************************************************/
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_face_vary_cvt
    *
    * @Description:
    *   Modify the loaded cvt table according to the `cvar' table and the
    *   font's blend.
    *
    * @InOut:
    *   face ::
    *     A handle to the target face object.
    *
    * @Input:
    *   stream ::
    *     A handle to the input stream.
    *
    * @Return:
    *   FreeType error code.  0 means success.
    *
    *   Most errors are ignored.  It is perfectly valid not to have a
    *   `cvar' table even if there is a `gvar' and `fvar' table.
    */
   FT_LOCAL_DEF( FT_Error )
   tt_face_vary_cvt( TT_Face    face,
                     FT_Stream  stream )
   {
     FT_Error   error;
     FT_Memory  memory = stream->memory;
 
     FT_ULong  table_start;
     FT_ULong  table_len;
 
     FT_UInt   tupleCount;
     FT_ULong  offsetToData;
 
     FT_ULong  here;
     FT_UInt   i, j;
 
     FT_Fixed*  tuple_coords    = NULL;
     FT_Fixed*  im_start_coords = NULL;
     FT_Fixed*  im_end_coords   = NULL;
 
     GX_Blend  blend = face->blend;
 
     FT_UInt  point_count;
     FT_UInt  spoint_count = 0;
 
     FT_UShort*  sharedpoints = NULL;
     FT_UShort*  localpoints  = NULL;
     FT_UShort*  points;
 
     FT_Fixed*  deltas     = NULL;
     FT_Fixed*  cvt_deltas = NULL;
 
 
     FT_TRACE2(( "CVAR " ));
 
     if ( !blend )
     {
       FT_TRACE2(( "\n"
                   "tt_face_vary_cvt: no blend specified\n" ));
       error = FT_Err_Ok;
       goto Exit;
     }
 
     if ( !face->cvt )
     {
       FT_TRACE2(( "\n"
                   "tt_face_vary_cvt: no `cvt ' table\n" ));
       error = FT_Err_Ok;
       goto Exit;
     }
 
     error = face->goto_table( face, TTAG_cvar, stream, &table_len );
     if ( error )
     {
       FT_TRACE2(( "is missing\n" ));
 
       error = FT_Err_Ok;
       goto Exit;
     }
 
     if ( FT_FRAME_ENTER( table_len ) )
     {
       error = FT_Err_Ok;
       goto Exit;
     }
 
     table_start = FT_Stream_FTell( stream );
     if ( FT_GET_LONG() != 0x00010000L )
     {
       FT_TRACE2(( "bad table version\n" ));
 
       error = FT_Err_Ok;
       goto FExit;
     }
 
     FT_TRACE2(( "loaded\n" ));
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto FExit;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = FT_GET_USHORT();
 
     /* rough sanity test */
     if ( offsetToData + ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) * 4 >
            table_len )
     {
       FT_TRACE2(( "tt_face_vary_cvt:"
                   " invalid CVT variation array header\n" ));
 
       error = FT_THROW( Invalid_Table );
       goto FExit;
     }
 
     offsetToData += table_start;
 
     if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )
     {
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       sharedpoints = ft_var_readpackedpoints( stream,
                                               table_len,
                                               &spoint_count );
       offsetToData = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "cvar: there %s %d tuple%s:\n",
                 ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) == 1 ? "is" : "are",
                 tupleCount & GX_TC_TUPLE_COUNT_MASK,
                 ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) == 1 ? "" : "s" ));
 
     if ( FT_NEW_ARRAY( cvt_deltas, face->cvt_size ) )
       goto FExit;
 
     for ( i = 0; i < ( tupleCount & GX_TC_TUPLE_COUNT_MASK ); i++ )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       FT_TRACE6(( "  tuple %d:\n", i ));
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );
       }
       else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )
       {
         FT_TRACE2(( "tt_face_vary_cvt:"
                     " invalid tuple index\n" ));
 
         error = FT_THROW( Invalid_Table );
         goto FExit;
       }
       else
       {
         if ( !blend->tuplecoords )
         {
           FT_TRACE2(( "tt_face_vary_cvt:"
                       " no valid tuple coordinates available\n" ));
 
           error = FT_THROW( Invalid_Table );
           goto FExit;
         }
 
         FT_MEM_COPY(
           tuple_coords,
           blend->tuplecoords +
             ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis,
           blend->num_axis * sizeof ( FT_Fixed ) );
       }
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           im_start_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );
         for ( j = 0; j < blend->num_axis; j++ )
           im_end_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
 
       if ( apply == 0 )              /* tuple isn't active for our blend */
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )
       {
         localpoints = ft_var_readpackedpoints( stream,
                                                table_len,
                                                &point_count );
         points      = localpoints;
       }
       else
       {
         points      = sharedpoints;
         point_count = spoint_count;
       }
 
       deltas = ft_var_readpackeddeltas( stream,
                                         table_len,
                                         point_count == 0 ? face->cvt_size
                                                          : point_count );
 
       if ( !points                                                        ||
            !deltas                                                        ||
            ( localpoints == ALL_POINTS && point_count != face->cvt_size ) )
         ; /* failure, ignore it */
 
       else if ( localpoints == ALL_POINTS )
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    CVT deltas:\n" ));
 
         /* this means that there are deltas for every entry in cvt */
         for ( j = 0; j < face->cvt_size; j++ )
         {
           FT_Fixed  old_cvt_delta;
 
 
           old_cvt_delta = cvt_deltas[j];
           cvt_deltas[j] = old_cvt_delta + FT_MulFix( deltas[j], apply );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( old_cvt_delta != cvt_deltas[j] )
           {
             FT_TRACE7(( "      %d: %f -> %f\n",
                         j,
                         ( FT_intToFixed( face->cvt[j] ) +
                           old_cvt_delta ) / 65536.0,
                         ( FT_intToFixed( face->cvt[j] ) +
                           cvt_deltas[j] ) / 65536.0 ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       else
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    CVT deltas:\n" ));
 
         for ( j = 0; j < point_count; j++ )
         {
           int       pindex;
           FT_Fixed  old_cvt_delta;
 
 
           pindex = points[j];
           if ( (FT_ULong)pindex >= face->cvt_size )
             continue;
 
           old_cvt_delta      = cvt_deltas[pindex];
           cvt_deltas[pindex] = old_cvt_delta + FT_MulFix( deltas[j], apply );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( old_cvt_delta != cvt_deltas[pindex] )
           {
             FT_TRACE7(( "      %d: %f -> %f\n",
                         pindex,
                         ( FT_intToFixed( face->cvt[pindex] ) +
                           old_cvt_delta ) / 65536.0,
                         ( FT_intToFixed( face->cvt[pindex] ) +
                           cvt_deltas[pindex] ) / 65536.0 ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "\n" ));
 
     for ( i = 0; i < face->cvt_size; i++ )
       face->cvt[i] += FT_fixedToInt( cvt_deltas[i] );
 
   FExit:
     FT_FRAME_EXIT();
 
   Exit:
     if ( sharedpoints != ALL_POINTS )
       FT_FREE( sharedpoints );
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
     FT_FREE( cvt_deltas );
 
     return error;
   }
 
 
   /* Shift the original coordinates of all points between indices `p1' */
   /* and `p2', using the same difference as given by index `ref'.      */
 
   /* modeled after `af_iup_shift' */
 
   static void
   tt_delta_shift( int         p1,
                   int         p2,
                   int         ref,
                   FT_Vector*  in_points,
                   FT_Vector*  out_points )
   {
     int        p;
     FT_Vector  delta;
 
 
     delta.x = out_points[ref].x - in_points[ref].x;
     delta.y = out_points[ref].y - in_points[ref].y;
 
     if ( delta.x == 0 && delta.y == 0 )
       return;
 
     for ( p = p1; p < ref; p++ )
     {
       out_points[p].x += delta.x;
       out_points[p].y += delta.y;
     }
 
     for ( p = ref + 1; p <= p2; p++ )
     {
       out_points[p].x += delta.x;
       out_points[p].y += delta.y;
     }
   }
 
 
   /* Interpolate the original coordinates of all points with indices */
   /* between `p1' and `p2', using `ref1' and `ref2' as the reference */
   /* point indices.                                                  */
 
   /* modeled after `af_iup_interp', `_iup_worker_interpolate', and   */
   /* `Ins_IUP' with spec differences in handling ill-defined cases.  */
   static void
   tt_delta_interpolate( int         p1,
                         int         p2,
                         int         ref1,
                         int         ref2,
                         FT_Vector*  in_points,
                         FT_Vector*  out_points )
   {
     int  p, i;
 
     FT_Pos  out, in1, in2, out1, out2, d1, d2;
 
 
     if ( p1 > p2 )
       return;
 
     /* handle both horizontal and vertical coordinates */
     for ( i = 0; i <= 1; i++ )
     {
       /* shift array pointers so that we can access `foo.y' as `foo.x' */
       in_points  = (FT_Vector*)( (FT_Pos*)in_points + i );
       out_points = (FT_Vector*)( (FT_Pos*)out_points + i );
 
       if ( in_points[ref1].x > in_points[ref2].x )
       {
         p    = ref1;
         ref1 = ref2;
         ref2 = p;
       }
 
       in1  = in_points[ref1].x;
       in2  = in_points[ref2].x;
       out1 = out_points[ref1].x;
       out2 = out_points[ref2].x;
       d1   = out1 - in1;
       d2   = out2 - in2;
 
       /* If the reference points have the same coordinate but different */
       /* delta, inferred delta is zero.  Otherwise interpolate.         */
       if ( in1 != in2 || out1 == out2 )
       {
         FT_Fixed  scale = in1 != in2 ? FT_DivFix( out2 - out1, in2 - in1 )
                                      : 0;
 
 
         for ( p = p1; p <= p2; p++ )
         {
           out = in_points[p].x;
 
           if ( out <= in1 )
             out += d1;
           else if ( out >= in2 )
             out += d2;
           else
             out = out1 + FT_MulFix( out - in1, scale );
 
           out_points[p].x = out;
         }
       }
     }
   }
 
 
   /* Interpolate points without delta values, similar to */
   /* the `IUP' hinting instruction.                      */
 
   /* modeled after `Ins_IUP */
 
   static void
   tt_interpolate_deltas( FT_Outline*  outline,
                          FT_Vector*   out_points,
                          FT_Vector*   in_points,
                          FT_Bool*     has_delta )
   {
     FT_Int  first_point;
     FT_Int  end_point;
 
     FT_Int  first_delta;
     FT_Int  cur_delta;
 
     FT_Int    point;
     FT_Short  contour;
 
 
     /* ignore empty outlines */
     if ( !outline->n_contours )
       return;
 
     contour = 0;
     point   = 0;
 
     do
     {
       end_point   = outline->contours[contour];
       first_point = point;
 
       /* search first point that has a delta */
       while ( point <= end_point && !has_delta[point] )
         point++;
 
       if ( point <= end_point )
       {
         first_delta = point;
         cur_delta   = point;
 
         point++;
 
         while ( point <= end_point )
         {
           /* search next point that has a delta  */
           /* and interpolate intermediate points */
           if ( has_delta[point] )
           {
             tt_delta_interpolate( cur_delta + 1,
                                   point - 1,
                                   cur_delta,
                                   point,
                                   in_points,
                                   out_points );
             cur_delta = point;
           }
 
           point++;
         }
 
         /* shift contour if we only have a single delta */
         if ( cur_delta == first_delta )
           tt_delta_shift( first_point,
                           end_point,
                           cur_delta,
                           in_points,
                           out_points );
         else
         {
           /* otherwise handle remaining points       */
           /* at the end and beginning of the contour */
           tt_delta_interpolate( cur_delta + 1,
                                 end_point,
                                 cur_delta,
                                 first_delta,
                                 in_points,
                                 out_points );
 
           if ( first_delta > 0 )
             tt_delta_interpolate( first_point,
                                   first_delta - 1,
                                   cur_delta,
                                   first_delta,
                                   in_points,
                                   out_points );
         }
       }
       contour++;
 
     } while ( contour < outline->n_contours );
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   TT_Vary_Apply_Glyph_Deltas
    *
    * @Description:
    *   Apply the appropriate deltas to the current glyph.
    *
    * @Input:
    *   face ::
    *     A handle to the target face object.
    *
    *   glyph_index ::
    *     The index of the glyph being modified.
    *
    *   n_points ::
    *     The number of the points in the glyph, including
    *     phantom points.
    *
    * @InOut:
    *   outline ::
    *     The outline to change.
    *
    * @Output:
    *   unrounded ::
    *     An array with `n_points' elements that is filled with unrounded
    *     point coordinates (in 26.6 format).
    *
    * @Return:
    *   FreeType error code.  0 means success.
    */
   FT_LOCAL_DEF( FT_Error )
   TT_Vary_Apply_Glyph_Deltas( TT_Face      face,
                               FT_UInt      glyph_index,
                               FT_Outline*  outline,
                               FT_Vector*   unrounded,
                               FT_UInt      n_points )
   {
     FT_Error   error;
     FT_Stream  stream = face->root.stream;
     FT_Memory  memory = stream->memory;
 
     FT_Vector*  points_org = NULL;  /* coordinates in 16.16 format */
     FT_Vector*  points_out = NULL;  /* coordinates in 16.16 format */
     FT_Bool*    has_delta  = NULL;
 
     FT_ULong  glyph_start;
 
     FT_UInt   tupleCount;
     FT_ULong  offsetToData;
     FT_ULong  dataSize;
 
     FT_ULong  here;
     FT_UInt   i, j;
 
     FT_Fixed*  tuple_coords    = NULL;
     FT_Fixed*  im_start_coords = NULL;
     FT_Fixed*  im_end_coords   = NULL;
 
     GX_Blend  blend = face->blend;
 
     FT_UInt  point_count;
     FT_UInt  spoint_count = 0;
 
     FT_UShort*  sharedpoints = NULL;
     FT_UShort*  localpoints  = NULL;
     FT_UShort*  points;
 
     FT_Fixed*  deltas_x       = NULL;
     FT_Fixed*  deltas_y       = NULL;
     FT_Fixed*  point_deltas_x = NULL;
     FT_Fixed*  point_deltas_y = NULL;
 
 
     if ( !face->doblend || !blend )
       return FT_THROW( Invalid_Argument );
 
     if ( glyph_index >= blend->gv_glyphcnt      ||
          blend->glyphoffsets[glyph_index] ==
            blend->glyphoffsets[glyph_index + 1] )
     {
       FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                   " no variation data for this glyph\n" ));
       return FT_Err_Ok;
     }
 
     if ( FT_NEW_ARRAY( points_org, n_points ) ||
          FT_NEW_ARRAY( points_out, n_points ) ||
          FT_NEW_ARRAY( has_delta, n_points )  )
       goto Fail1;
 
     dataSize = blend->glyphoffsets[glyph_index + 1] -
                  blend->glyphoffsets[glyph_index];
 
     if ( FT_STREAM_SEEK( blend->glyphoffsets[glyph_index] ) ||
          FT_FRAME_ENTER( dataSize )                         )
       goto Fail1;
 
     glyph_start = FT_Stream_FTell( stream );
 
     /* each set of glyph variation data is formatted similarly to `cvar' */
 
     if ( FT_NEW_ARRAY( tuple_coords, blend->num_axis )    ||
          FT_NEW_ARRAY( im_start_coords, blend->num_axis ) ||
          FT_NEW_ARRAY( im_end_coords, blend->num_axis )   )
       goto Fail2;
 
     tupleCount   = FT_GET_USHORT();
     offsetToData = FT_GET_USHORT();
 
     /* rough sanity test */
     if ( offsetToData > dataSize                                ||
          ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) * 4 > dataSize )
     {
       FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                   " invalid glyph variation array header\n" ));
 
       error = FT_THROW( Invalid_Table );
       goto Fail2;
     }
 
     offsetToData += glyph_start;
 
     if ( tupleCount & GX_TC_TUPLES_SHARE_POINT_NUMBERS )
     {
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       sharedpoints = ft_var_readpackedpoints( stream,
                                               blend->gvar_size,
                                               &spoint_count );
       offsetToData = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "gvar: there %s %d tuple%s:\n",
                 ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) == 1 ? "is" : "are",
                 tupleCount & GX_TC_TUPLE_COUNT_MASK,
                 ( tupleCount & GX_TC_TUPLE_COUNT_MASK ) == 1 ? "" : "s" ));
 
     if ( FT_NEW_ARRAY( point_deltas_x, n_points ) ||
          FT_NEW_ARRAY( point_deltas_y, n_points ) )
       goto Fail3;
 
     for ( j = 0; j < n_points; j++ )
     {
       points_org[j].x = FT_intToFixed( outline->points[j].x );
       points_org[j].y = FT_intToFixed( outline->points[j].y );
     }
 
     for ( i = 0; i < ( tupleCount & GX_TC_TUPLE_COUNT_MASK ); i++ )
     {
       FT_UInt   tupleDataSize;
       FT_UInt   tupleIndex;
       FT_Fixed  apply;
 
 
       FT_TRACE6(( "  tuple %d:\n", i ));
 
       tupleDataSize = FT_GET_USHORT();
       tupleIndex    = FT_GET_USHORT();
 
       if ( tupleIndex & GX_TI_EMBEDDED_TUPLE_COORD )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );
       }
       else if ( ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) >= blend->tuplecount )
       {
         FT_TRACE2(( "TT_Vary_Apply_Glyph_Deltas:"
                     " invalid tuple index\n" ));
 
         error = FT_THROW( Invalid_Table );
         goto Fail3;
       }
       else
         FT_MEM_COPY(
           tuple_coords,
           blend->tuplecoords +
             ( tupleIndex & GX_TI_TUPLE_INDEX_MASK ) * blend->num_axis,
           blend->num_axis * sizeof ( FT_Fixed ) );
 
       if ( tupleIndex & GX_TI_INTERMEDIATE_TUPLE )
       {
         for ( j = 0; j < blend->num_axis; j++ )
           im_start_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );
         for ( j = 0; j < blend->num_axis; j++ )
           im_end_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );
       }
 
       apply = ft_var_apply_tuple( blend,
                                   (FT_UShort)tupleIndex,
                                   tuple_coords,
                                   im_start_coords,
                                   im_end_coords );
 
       if ( apply == 0 )              /* tuple isn't active for our blend */
       {
         offsetToData += tupleDataSize;
         continue;
       }
 
       here = FT_Stream_FTell( stream );
 
       FT_Stream_SeekSet( stream, offsetToData );
 
       if ( tupleIndex & GX_TI_PRIVATE_POINT_NUMBERS )
       {
         localpoints = ft_var_readpackedpoints( stream,
                                                blend->gvar_size,
                                                &point_count );
         points      = localpoints;
       }
       else
       {
         points      = sharedpoints;
         point_count = spoint_count;
       }
 
       deltas_x = ft_var_readpackeddeltas( stream,
                                           blend->gvar_size,
                                           point_count == 0 ? n_points
                                                            : point_count );
       deltas_y = ft_var_readpackeddeltas( stream,
                                           blend->gvar_size,
                                           point_count == 0 ? n_points
                                                            : point_count );
 
       if ( !points || !deltas_y || !deltas_x )
         ; /* failure, ignore it */
 
       else if ( points == ALL_POINTS )
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         FT_TRACE7(( "    point deltas:\n" ));
 
         /* this means that there are deltas for every point in the glyph */
         for ( j = 0; j < n_points; j++ )
         {
           FT_Fixed  old_point_delta_x = point_deltas_x[j];
           FT_Fixed  old_point_delta_y = point_deltas_y[j];
 
           FT_Fixed  point_delta_x = FT_MulFix( deltas_x[j], apply );
           FT_Fixed  point_delta_y = FT_MulFix( deltas_y[j], apply );
 
 
           if ( j < n_points - 4 )
           {
             point_deltas_x[j] = old_point_delta_x + point_delta_x;
             point_deltas_y[j] = old_point_delta_y + point_delta_y;
           }
           else
           {
             /* To avoid double adjustment of advance width or height, */
             /* adjust phantom points only if there is no HVAR or VVAR */
             /* support, respectively.                                 */
             if ( j == ( n_points - 4 )        &&
                  !( face->variation_support &
                     TT_FACE_FLAG_VAR_LSB    ) )
               point_deltas_x[j] = old_point_delta_x + point_delta_x;
 
             else if ( j == ( n_points - 3 )          &&
                       !( face->variation_support   &
                          TT_FACE_FLAG_VAR_HADVANCE ) )
               point_deltas_x[j] = old_point_delta_x + point_delta_x;
 
             else if ( j == ( n_points - 2 )        &&
                       !( face->variation_support &
                          TT_FACE_FLAG_VAR_TSB    ) )
               point_deltas_y[j] = old_point_delta_y + point_delta_y;
 
             else if ( j == ( n_points - 1 )          &&
                       !( face->variation_support   &
                          TT_FACE_FLAG_VAR_VADVANCE ) )
               point_deltas_y[j] = old_point_delta_y + point_delta_y;
           }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( point_delta_x || point_delta_y )
           {
             FT_TRACE7(( "      %d: (%f, %f) -> (%f, %f)\n",
                         j,
                         ( FT_intToFixed( outline->points[j].x ) +
                           old_point_delta_x ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].y ) +
                           old_point_delta_y ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].x ) +
                           point_deltas_x[j] ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].y ) +
                           point_deltas_y[j] ) / 65536.0 ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       else
       {
 #ifdef FT_DEBUG_LEVEL_TRACE
         int  count = 0;
 #endif
 
 
         /* we have to interpolate the missing deltas similar to the */
         /* IUP bytecode instruction                                 */
         for ( j = 0; j < n_points; j++ )
         {
           has_delta[j]  = FALSE;
           points_out[j] = points_org[j];
         }
 
         for ( j = 0; j < point_count; j++ )
         {
           FT_UShort  idx = points[j];
 
 
           if ( idx >= n_points )
             continue;
 
           has_delta[idx] = TRUE;
 
           points_out[idx].x += FT_MulFix( deltas_x[j], apply );
           points_out[idx].y += FT_MulFix( deltas_y[j], apply );
         }
 
         /* no need to handle phantom points here,      */
         /* since solitary points can't be interpolated */
         tt_interpolate_deltas( outline,
                                points_out,
                                points_org,
                                has_delta );
 
         FT_TRACE7(( "    point deltas:\n" ));
 
         for ( j = 0; j < n_points; j++ )
         {
           FT_Fixed  old_point_delta_x = point_deltas_x[j];
           FT_Fixed  old_point_delta_y = point_deltas_y[j];
 
           FT_Pos  point_delta_x = points_out[j].x - points_org[j].x;
           FT_Pos  point_delta_y = points_out[j].y - points_org[j].y;
 
 
           if ( j < n_points - 4 )
           {
             point_deltas_x[j] = old_point_delta_x + point_delta_x;
             point_deltas_y[j] = old_point_delta_y + point_delta_y;
           }
           else
           {
             /* To avoid double adjustment of advance width or height, */
             /* adjust phantom points only if there is no HVAR or VVAR */
             /* support, respectively.                                 */
             if ( j == ( n_points - 4 )        &&
                  !( face->variation_support &
                     TT_FACE_FLAG_VAR_LSB    ) )
               point_deltas_x[j] = old_point_delta_x + point_delta_x;
 
             else if ( j == ( n_points - 3 )          &&
                       !( face->variation_support   &
                          TT_FACE_FLAG_VAR_HADVANCE ) )
               point_deltas_x[j] = old_point_delta_x + point_delta_x;
 
             else if ( j == ( n_points - 2 )        &&
                       !( face->variation_support &
                          TT_FACE_FLAG_VAR_TSB    ) )
               point_deltas_y[j] = old_point_delta_y + point_delta_y;
 
             else if ( j == ( n_points - 1 )          &&
                       !( face->variation_support   &
                          TT_FACE_FLAG_VAR_VADVANCE ) )
               point_deltas_y[j] = old_point_delta_y + point_delta_y;
           }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
           if ( point_delta_x || point_delta_y )
           {
             FT_TRACE7(( "      %d: (%f, %f) -> (%f, %f)\n",
                         j,
                         ( FT_intToFixed( outline->points[j].x ) +
                           old_point_delta_x ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].y ) +
                           old_point_delta_y ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].x ) +
                           point_deltas_x[j] ) / 65536.0,
                         ( FT_intToFixed( outline->points[j].y ) +
                           point_deltas_y[j] ) / 65536.0 ));
             count++;
           }
 #endif
         }
 
 #ifdef FT_DEBUG_LEVEL_TRACE
         if ( !count )
           FT_TRACE7(( "      none\n" ));
 #endif
       }
 
       if ( localpoints != ALL_POINTS )
         FT_FREE( localpoints );
       FT_FREE( deltas_x );
       FT_FREE( deltas_y );
 
       offsetToData += tupleDataSize;
 
       FT_Stream_SeekSet( stream, here );
     }
 
     FT_TRACE5(( "\n" ));
 
     for ( i = 0; i < n_points; i++ )
     {
       unrounded[i].x = INT_TO_F26DOT6( outline->points[i].x ) +
                          FT_fixedToFdot6( point_deltas_x[i] );
       unrounded[i].y = INT_TO_F26DOT6( outline->points[i].y ) +
                          FT_fixedToFdot6( point_deltas_y[i] );
 
       outline->points[i].x += FT_fixedToInt( point_deltas_x[i] );
       outline->points[i].y += FT_fixedToInt( point_deltas_y[i] );
     }
 
   Fail3:
     FT_FREE( point_deltas_x );
     FT_FREE( point_deltas_y );
 
   Fail2:
     if ( sharedpoints != ALL_POINTS )
       FT_FREE( sharedpoints );
     FT_FREE( tuple_coords );
     FT_FREE( im_start_coords );
     FT_FREE( im_end_coords );
 
     FT_FRAME_EXIT();
 
   Fail1:
     FT_FREE( points_org );
     FT_FREE( points_out );
     FT_FREE( has_delta );
 
     return error;
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_get_var_blend
    *
    * @Description:
    *   An extended internal version of `TT_Get_MM_Blend' that returns
    *   pointers instead of copying data, without any initialization of
    *   the MM machinery in case it isn't loaded yet.
    */
   FT_LOCAL_DEF( FT_Error )
   tt_get_var_blend( TT_Face      face,
                     FT_UInt     *num_coords,
                     FT_Fixed*   *coords,
                     FT_Fixed*   *normalizedcoords,
                     FT_MM_Var*  *mm_var )
   {
     if ( face->blend )
     {
       if ( num_coords )
         *num_coords       = face->blend->num_axis;
       if ( coords )
         *coords           = face->blend->coords;
       if ( normalizedcoords )
         *normalizedcoords = face->blend->normalizedcoords;
       if ( mm_var )
         *mm_var           = face->blend->mmvar;
     }
     else
     {
       if ( num_coords )
         *num_coords = 0;
       if ( coords )
         *coords     = NULL;
       if ( mm_var )
         *mm_var     = NULL;
     }
 
     return FT_Err_Ok;
   }
 
 
   static void
   ft_var_done_item_variation_store( TT_Face          face,
                                     GX_ItemVarStore  itemStore )
   {
     FT_Memory  memory = FT_FACE_MEMORY( face );
     FT_UInt    i;
 
 
     if ( itemStore->varData )
     {
       for ( i = 0; i < itemStore->dataCount; i++ )
       {
         FT_FREE( itemStore->varData[i].regionIndices );
         FT_FREE( itemStore->varData[i].deltaSet );
       }
 
       FT_FREE( itemStore->varData );
     }
 
     if ( itemStore->varRegionList )
     {
       for ( i = 0; i < itemStore->regionCount; i++ )
         FT_FREE( itemStore->varRegionList[i].axisList );
 
       FT_FREE( itemStore->varRegionList );
     }
   }
 
 
   /**************************************************************************
    *
    * @Function:
    *   tt_done_blend
    *
    * @Description:
    *   Free the blend internal data structure.
    */
   FT_LOCAL_DEF( void )
   tt_done_blend( TT_Face  face )
   {
     FT_Memory  memory = FT_FACE_MEMORY( face );
     GX_Blend   blend  = face->blend;
 
 
     if ( blend )
     {
       FT_UInt  i, num_axes;
 
 
       /* blend->num_axis might not be set up yet */
       num_axes = blend->mmvar->num_axis;
 
       FT_FREE( blend->coords );
       FT_FREE( blend->normalizedcoords );
       FT_FREE( blend->normalized_stylecoords );
       FT_FREE( blend->mmvar );
 
       if ( blend->avar_segment )
       {
         for ( i = 0; i < num_axes; i++ )
           FT_FREE( blend->avar_segment[i].correspondence );
         FT_FREE( blend->avar_segment );
       }
 
       if ( blend->hvar_table )
       {
         ft_var_done_item_variation_store( face,
                                           &blend->hvar_table->itemStore );
 
         FT_FREE( blend->hvar_table->widthMap.innerIndex );
         FT_FREE( blend->hvar_table->widthMap.outerIndex );
         FT_FREE( blend->hvar_table );
       }
 
       if ( blend->vvar_table )
       {
         ft_var_done_item_variation_store( face,
                                           &blend->vvar_table->itemStore );
 
         FT_FREE( blend->vvar_table->widthMap.innerIndex );
         FT_FREE( blend->vvar_table->widthMap.outerIndex );
         FT_FREE( blend->vvar_table );
       }
 
       if ( blend->mvar_table )
       {
         ft_var_done_item_variation_store( face,
                                           &blend->mvar_table->itemStore );
 
         FT_FREE( blend->mvar_table->values );
         FT_FREE( blend->mvar_table );
       }
 
       FT_FREE( blend->tuplecoords );
       FT_FREE( blend->glyphoffsets );
       FT_FREE( blend );
     }
   }
 
 #else /* !TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
   /* ANSI C doesn't like empty source files */
   typedef int  _tt_gxvar_dummy;
 
 #endif /* !TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 
 
 /* END */
