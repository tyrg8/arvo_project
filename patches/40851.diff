commit 3de25bf0bbd2039421e191ff936a31f3900460ae
Author: Neelkamal Semwal <neelkamal.semwal@ittiam.com>
Date:   Wed Mar 10 10:03:39 2021 +0530

    avcenc: Add bitstream overflow check during emulation prevention
    
    Bug: 176533109
    
    Test: poc in the bug description
    
    Change-Id: Ia83383f9b65cbde8d7a50a1af8a054936daa4d78
    (cherry picked from commit b59de5a25f28f0fe411526b2e50bb8052957c517)

diff --git a/encoder/ih264e_bitstream.c b/encoder/ih264e_bitstream.c
index d79f637..9f73f69 100644
--- a/encoder/ih264e_bitstream.c
+++ b/encoder/ih264e_bitstream.c
@@ -111,143 +111,124 @@ IH264E_ERROR_T ih264e_bitstrm_init(bitstrm_t *ps_bitstrm,
 /**
 ******************************************************************************
 *
 *  @brief puts a code with specified number of bits into the bitstream
 *
 *  @par   Description
 *  inserts code_len number of bits from lsb of code_val into the
 *  bitstream. updates context members like u4_cur_word, u4_strm_buf_offset and
 *  i4_bits_left_in_cw. If the total words (u4_strm_buf_offset) exceeds max
 *  available size (u4_max_strm_size), returns error without corrupting data
 *  beyond it
 *
 *  @param[in]    ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @param[in]    u4_code_val
 *  code value that needs to be inserted in the stream.
 *
 *  @param[in]    code_len
 *  indicates code length (in bits) of code_val that would be inserted in
 *  bitstream buffer size. Range of length[1:WORD_SIZE]
 *
 *  @remarks     Assumptions: all bits from bit position code_len to msb of
 *   code_val shall be zero
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
 IH264E_ERROR_T ih264e_put_bits(bitstrm_t *ps_bitstrm,
                                UWORD32 u4_code_val,
                                WORD32 code_len)
 {
     UWORD32 u4_cur_word = ps_bitstrm->u4_cur_word;
     WORD32  bits_left_in_cw = ps_bitstrm->i4_bits_left_in_cw;
 
 
     /* check assumptions made in the module */
     ASSERT(code_len > 0 && code_len <= WORD_SIZE);
 
     if(code_len < WORD_SIZE)
         ASSERT((u4_code_val >> code_len) == 0);
 
     /* sanity check on the bitstream engine state */
     ASSERT(bits_left_in_cw > 0 && bits_left_in_cw <= WORD_SIZE);
 
     ASSERT(ps_bitstrm->i4_zero_bytes_run <= EPB_ZERO_BYTES);
 
     ASSERT(ps_bitstrm->pu1_strm_buffer != NULL);
 
 
     if(bits_left_in_cw > code_len)
     {
         /*******************************************************************/
         /* insert the code in local bitstream word and return              */
         /* code is inserted in position of bits left (post decrement)      */
         /*******************************************************************/
         bits_left_in_cw -= code_len;
         u4_cur_word     |= (u4_code_val << bits_left_in_cw);
 
         ps_bitstrm->u4_cur_word         = u4_cur_word;
         ps_bitstrm->i4_bits_left_in_cw  = bits_left_in_cw;
 
         return(IH264E_SUCCESS);
     }
     else
     {
         /********************************************************************/
         /* 1. insert partial code corresponding to bits left in cur word    */
         /* 2. flush all the bits of cur word to bitstream                   */
         /* 3. insert emulation prevention bytes while flushing the bits     */
         /* 4. insert remaining bits of code starting from msb of cur word   */
         /* 5. update bitsleft in current word and stream buffer offset      */
         /********************************************************************/
-        UWORD32 u4_strm_buf_offset  = ps_bitstrm->u4_strm_buf_offset;
-
-        UWORD32 u4_max_strm_size    = ps_bitstrm->u4_max_strm_size;
-
-        WORD32  zero_run            = ps_bitstrm->i4_zero_bytes_run;
-
-        UWORD8* pu1_strm_buf        = ps_bitstrm->pu1_strm_buffer;
-
+        IH264E_ERROR_T status = IH264E_SUCCESS;
         WORD32  i, rem_bits = (code_len - bits_left_in_cw);
 
-
-        /*********************************************************************/
-        /* Bitstream overflow check                                          */
-        /* NOTE: corner case of epb bytes (max 2 for 32bit word) not handled */
-        /*********************************************************************/
-        if((u4_strm_buf_offset + (WORD_SIZE>>3)) >= u4_max_strm_size)
-        {
-            /* return without corrupting the buffer beyond its size */
-            return(IH264E_BITSTREAM_BUFFER_OVERFLOW);
-        }
-
         /* insert parital code corresponding to bits left in cur word */
         u4_cur_word |= u4_code_val >> rem_bits;
 
         for(i = WORD_SIZE; i > 0; i -= 8)
         {
             /* flush the bits in cur word byte by byte and copy to stream */
             UWORD8   u1_next_byte = (u4_cur_word >> (i-8)) & 0xFF;
 
-            PUTBYTE_EPB(pu1_strm_buf, u4_strm_buf_offset, u1_next_byte, zero_run);
+            status |= ih264e_put_byte_epb(ps_bitstrm, u1_next_byte);
         }
 
         /* insert the remaining bits from code val into current word */
         u4_cur_word = rem_bits ? (u4_code_val << (WORD_SIZE - rem_bits)) : 0;
 
         /* update the state variables and return success */
         ps_bitstrm->u4_cur_word         = u4_cur_word;
         ps_bitstrm->i4_bits_left_in_cw  = WORD_SIZE - rem_bits;
-        ps_bitstrm->i4_zero_bytes_run   = zero_run;
-        ps_bitstrm->u4_strm_buf_offset  = u4_strm_buf_offset;
-        return (IH264E_SUCCESS);
+        return (status);
+
     }
 }
 
 /**
 ******************************************************************************
 *
 *  @brief inserts a 1-bit code into the bitstream
 *
 *  @par   Description
 *  inserts 1bit lsb of code_val into the bitstream
 *  updates context members like u4_cur_word, u4_strm_buf_offset and
 *  i4_bits_left_in_cw. If the total words (u4_strm_buf_offset) exceeds max
 *  available size (u4_max_strm_size), returns error without corrupting data
 *  beyond it
 *
 *  @param[in]    ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @param[in]    u4_code_val
 *  code value that needs to be inserted in the stream.
 *
 *  @remarks     Assumptions: all bits from bit position 1 to msb of code_val
 *  shall be zero
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
@@ -260,87 +241,69 @@ IH264E_ERROR_T ih264e_put_bit(bitstrm_t *ps_bitstrm, UWORD32 u4_code_val)
 /**
 ******************************************************************************
 *
 *  @brief inserts rbsp trailing bits at the end of stream buffer (NAL)
 *
 *  @par   Description
 *  inserts rbsp trailing bits, updates context members like u4_cur_word and
 *  i4_bits_left_in_cw and flushes the same in the bitstream buffer. If the
 *  total words (u4_strm_buf_offset) exceeds max available size
 *  (u4_max_strm_size), returns error without corrupting data beyond it
 *
 *  @param[in]    ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
 IH264E_ERROR_T ih264e_put_rbsp_trailing_bits(bitstrm_t *ps_bitstrm)
 {
     WORD32 i;
     UWORD32 u4_cur_word = ps_bitstrm->u4_cur_word;
     WORD32  bits_left_in_cw = ps_bitstrm->i4_bits_left_in_cw;
     WORD32  bytes_left_in_cw = (bits_left_in_cw - 1) >> 3;
-
-    UWORD32 u4_strm_buf_offset  = ps_bitstrm->u4_strm_buf_offset;
-    UWORD32 u4_max_strm_size    = ps_bitstrm->u4_max_strm_size;
-    WORD32  zero_run            = ps_bitstrm->i4_zero_bytes_run;
-    UWORD8* pu1_strm_buf        = ps_bitstrm->pu1_strm_buffer;
-
-    /*********************************************************************/
-    /* Bitstream overflow check                                          */
-    /* NOTE: corner case of epb bytes (max 2 for 32bit word) not handled */
-    /*********************************************************************/
-    if((u4_strm_buf_offset + (WORD_SIZE>>3) - bytes_left_in_cw) >=
-        u4_max_strm_size)
-    {
-        /* return without corrupting the buffer beyond its size */
-        return(IH264E_BITSTREAM_BUFFER_OVERFLOW);
-    }
+    IH264E_ERROR_T status = IH264E_SUCCESS;
 
     /* insert a 1 at the end of current word and flush all the bits */
     u4_cur_word |= (1 << (bits_left_in_cw - 1));
 
     /* get the bits to be inserted in msbdb of the word */
     //u4_cur_word <<= (WORD_SIZE - bytes_left_in_cw + 1);
 
     for(i = WORD_SIZE; i > (bytes_left_in_cw*8); i -= 8)
     {
         /* flush the bits in cur word byte by byte  and copy to stream */
         UWORD8   u1_next_byte = (u4_cur_word >> (i-8)) & 0xFF;
 
-        PUTBYTE_EPB(pu1_strm_buf, u4_strm_buf_offset, u1_next_byte, zero_run);
+        status |= ih264e_put_byte_epb(ps_bitstrm, u1_next_byte);
     }
 
-    /* update the stream offset */
-    ps_bitstrm->u4_strm_buf_offset  = u4_strm_buf_offset;
-
     /* Default init values for scratch variables of bitstream context */
     ps_bitstrm->u4_cur_word         = 0;
     ps_bitstrm->i4_bits_left_in_cw  = WORD_SIZE;
     ps_bitstrm->i4_zero_bytes_run   = 0;
 
-    return (IH264E_SUCCESS);
+    return (status);
 }
 
 /**
 ******************************************************************************
 *
 *  @brief puts exponential golomb code of a unsigned integer into bitstream
 *
 *  @par   Description
 *  computes uev code for given syntax element and inserts the same into
 *  bitstream by calling ih264e_put_bits() interface.
 *
 *  @param[in]    ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @param[in]    u4_code_num
 *  unsigned integer input whose golomb code is written in stream
 *
 *  @remarks     Assumptions: code value can be represented in less than 16bits
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
diff --git a/encoder/ih264e_bitstream.h b/encoder/ih264e_bitstream.h
index 9cd2b81..5b5c700 100644
--- a/encoder/ih264e_bitstream.h
+++ b/encoder/ih264e_bitstream.h
@@ -1,275 +1,301 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 
 /**
 *******************************************************************************
 * @file
 *  ih264e_bitstream.h
 *
 * @brief
 *  This file contains encoder bitstream engine related structures and
 *  interface prototypes
 *
 * @author
 *  ittiam
 *
 * @remarks
 *  none
 *
 *******************************************************************************
 */
 
 #ifndef IH264E_BITSTREAM_H_
 #define IH264E_BITSTREAM_H_
 
 /*****************************************************************************/
 /* Constant Macros                                                           */
 /*****************************************************************************/
 
 /**
 ******************************************************************************
  *  @brief      defines the maximum number of bits in a bitstream word
 ******************************************************************************
  */
 #define WORD_SIZE         32
 
 /**
 ******************************************************************************
  *  @brief  The number of consecutive zero bytes for emulation prevention check
 ******************************************************************************
  */
 #define EPB_ZERO_BYTES      2
 
 /**
 ******************************************************************************
  *  @brief  Emulation prevention insertion byte
 ******************************************************************************
  */
 #define EPB_BYTE            0x03
 
 
 /**
 ******************************************************************************
  *  @brief  Stream buffer allocated per frame should be atleast MIN_STREAM_SIZE
 ******************************************************************************
  */
 #define MIN_STREAM_SIZE            0x800
 
 
 /*****************************************************************************/
 /* Function Macros                                                           */
 /*****************************************************************************/
 
 /**
 ******************************************************************************
  *  @brief   Macro to check if emulation prevention byte insertion is required
 ******************************************************************************
  */
 #define INSERT_EPB(zero_run, next_byte)                                       \
     ((zero_run) == EPB_ZERO_BYTES) && (0 == ((next_byte) & 0xFC))
 
 /**
 ******************************************************************************
  *  @brief   returns the bit position of a leading 1 (msb) in a code value
 ******************************************************************************
  */
 #if !MSVC
 #define GETRANGE(r,value)   \
 {                           \
     r = 0;                  \
     if(0 == value)          \
         r = 1;              \
     else                    \
     {                       \
         r = 32-CLZ(value);  \
     }\
 }
 #else
 #define GETRANGE(r,value)                 \
 {                                         \
     unsigned long  msb_one_bit = 0;       \
     r = _BitScanReverse(&msb_one_bit, value) ? (UWORD32)(msb_one_bit + 1) : 1 ; \
 }
 #endif
 
 /**
 ******************************************************************************
  *  @brief   returns bits required to code a value
 ******************************************************************************
  */
 #define UE_LENGTH(bits,x)        \
 {                                \
     UWORD32 r_bit;               \
     GETRANGE(r_bit,x+1)          \
     bits =(((r_bit - 1) << 1)+1);\
 }                                \
 
 /**
 ******************************************************************************
  *  @brief  Inserts 1 byte and Emulation Prevention Byte(if any) into bitstream
  *          Increments the stream offset and zero run correspondingly
 ******************************************************************************
  */
 #define PUTBYTE_EPB(ptr,off,byte,zero_run)                      \
 {                                                               \
     if( INSERT_EPB(zero_run, byte) )                            \
     {                                                           \
         ptr[off] = EPB_BYTE;                                    \
         off++;                                                  \
         zero_run = 0;                                           \
     }                                                           \
                                                                 \
     ptr[off] = byte;                                            \
     off++;                                                      \
     zero_run = byte ? 0 : zero_run+1;                           \
 }                                                               \
 
 /**
 ******************************************************************************
  *  @brief  Ensures Byte alignment of the slice header
 ******************************************************************************
  */
 #define BYTE_ALIGNMENT(ps_bitstrm) ih264e_put_rbsp_trailing_bits(ps_bitstrm)
 
 /**
 ******************************************************************************
  *  @brief  Gets number of  bits coded
 ******************************************************************************
  */
 
 #define GET_NUM_BITS(ps_bitstream) ((ps_bitstream->u4_strm_buf_offset << 3) \
                                     + 32 - ps_bitstream->i4_bits_left_in_cw);
 
 
 
 /**
 ******************************************************************************
  *  @macro Align bitstream to byte - Remainig bits are filled with '1'
 ******************************************************************************
 */
 #define BITSTREAM_BYTE_ALIGN(ps_bitstrm)                                    \
    if (ps_bitstrm->i4_bits_left_in_cw & 0x07)                               \
    {                                                                        \
        const WORD32 len = (WORD32)((ps_bitstrm->i4_bits_left_in_cw) & 0x07);\
        ih264e_put_bits(ps_bitstrm, (UWORD32)((1 << len) - 1), len);         \
-   }
-
-
-/**
-******************************************************************************
-* flush the bits in cur word byte by byte  and copy to stream                *
-* (current word is assumed to be byte aligned)                               *
-******************************************************************************
-*/
-#define  BITSTREAM_FLUSH(ps_bitstrm)                                           \
-{                                                                              \
-    WORD32 i;                                                                  \
-    for (i = WORD_SIZE; i > ps_bitstrm->i4_bits_left_in_cw; i -= 8)            \
-    {                                                                          \
-       UWORD8 u1_next_byte = (ps_bitstrm->u4_cur_word >> (i - 8)) & 0xFF;      \
-       PUTBYTE_EPB(ps_bitstrm->pu1_strm_buffer, ps_bitstrm->u4_strm_buf_offset,\
-                   u1_next_byte, ps_bitstrm->i4_zero_bytes_run);               \
-    }                                                                          \
-    ps_bitstrm->u4_cur_word = 0;                                               \
-    ps_bitstrm->i4_bits_left_in_cw = WORD_SIZE;                                \
-}                                                                              \
-
-
+   }                                                                        \
 
 
 /*****************************************************************************/
 /* Structures                                                                */
 /*****************************************************************************/
 
 /**
 ******************************************************************************
  *  @brief      Bitstream context for encoder
 ******************************************************************************
  */
 typedef struct bitstrm
 {
     /** points to start of stream buffer.    */
     UWORD8  *pu1_strm_buffer;
 
     /**
      *  max bitstream size (in bytes).
      *  Encoded stream shall not exceed this size.
      */
     UWORD32 u4_max_strm_size;
 
     /**
      *  byte offset (w.r.t pu1_strm_buffer) where next byte would be written
      *  Bitstream engine makes sure it would not corrupt data beyond
      *  u4_max_strm_size bytes
                                  */
     UWORD32 u4_strm_buf_offset;
 
     /**
      *  current bitstream word; It is a scratch word containing max of
      *  WORD_SIZE bits. Will be copied to stream buffer when the word is
      *  full
                                  */
     UWORD32 u4_cur_word;
 
     /**
      *  signifies number of bits available in u4_cur_word
      *  bits from msb to i4_bits_left_in_cw of u4_cur_word have already been
      *  inserted next bits would be inserted from pos [i4_bits_left_in_cw-1]
      *  Range of this variable [1 : WORD_SIZE]
                                  */
     WORD32  i4_bits_left_in_cw;
 
     /**
      *  signifies the number of consecutive zero bytes propogated from previous
      *  word. It is used for emulation prevention byte insertion in the stream
                                  */
     WORD32  i4_zero_bytes_run;
 
 } bitstrm_t;
 
 
+/**
+******************************************************************************
+*  @brief  Inserts 1 byte and Emulation Prevention Byte(if any) into bitstream
+*          Increments the stream offset and zero run correspondingly
+******************************************************************************
+*/
+static inline IH264E_ERROR_T ih264e_put_byte_epb(bitstrm_t *ps_bitstrm, UWORD8 byte)
+{
+    if (INSERT_EPB(ps_bitstrm->i4_zero_bytes_run, byte))
+    {
+        if ((ps_bitstrm->u4_strm_buf_offset + 1) >= ps_bitstrm->u4_max_strm_size)
+        {
+            return IH264E_BITSTREAM_BUFFER_OVERFLOW;
+        }
+        ps_bitstrm->pu1_strm_buffer[ps_bitstrm->u4_strm_buf_offset++] = EPB_BYTE;
+        ps_bitstrm->i4_zero_bytes_run = 0;
+    }
+
+    if ((ps_bitstrm->u4_strm_buf_offset + 1) >= ps_bitstrm->u4_max_strm_size)
+    {
+        return IH264E_BITSTREAM_BUFFER_OVERFLOW;
+    }
+    ps_bitstrm->pu1_strm_buffer[ps_bitstrm->u4_strm_buf_offset++] = byte;
+    ps_bitstrm->i4_zero_bytes_run = byte ? 0 : ps_bitstrm->i4_zero_bytes_run + 1;
+
+    return IH264E_SUCCESS;
+}
+
+/**
+******************************************************************************
+* flush the bits in cur word byte by byte  and copy to stream                *
+* (current word is assumed to be byte aligned)                               *
+******************************************************************************
+*/
+#define  BITSTREAM_FLUSH(ps_bitstrm, err)                                      \
+{                                                                              \
+    WORD32 i;                                                                  \
+    for (i = WORD_SIZE; i > ps_bitstrm->i4_bits_left_in_cw; i -= 8)            \
+    {                                                                          \
+       UWORD8 u1_next_byte = (ps_bitstrm->u4_cur_word >> (i - 8)) & 0xFF;      \
+       err |= ih264e_put_byte_epb(ps_bitstrm, u1_next_byte);                   \
+    }                                                                          \
+    ps_bitstrm->u4_cur_word = 0;                                               \
+    ps_bitstrm->i4_bits_left_in_cw = WORD_SIZE;                                \
+}                                                                              \
+
+
+
 /*****************************************************************************/
 /* Extern Function Declarations                                              */
 /*****************************************************************************/
 
 /**
 ******************************************************************************
 *
 *  @brief Initializes the encoder bitstream engine
 *
 *  @par   Description
 *  This routine needs to be called at start of slice/frame encode
 *
 *  @param[in]   ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @param[in]   p1_bitstrm_buf
 *  bitstream buffer pointer where the encoded stream is generated in byte order
 *
 *  @param[in]   u4_max_bitstrm_size
 *  indicates maximum bitstream buffer size. (in bytes)
 *  If actual stream size exceeds the maximum size, encoder should
 *   1. Not corrupt data beyond u4_max_bitstrm_size bytes
 *   2. Report an error back to application indicating overflow
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
diff --git a/encoder/ih264e_cabac.c b/encoder/ih264e_cabac.c
index 26ded4d..2d91058 100644
--- a/encoder/ih264e_cabac.c
+++ b/encoder/ih264e_cabac.c
@@ -230,241 +230,232 @@ void ih264e_get_cabac_context(entropy_ctxt_t *ps_ent_ctxt, WORD32 u4_mb_type)
 /**
  *******************************************************************************
  * @brief
  *  flushing at termination: Explained in flowchart 9-12(ITU_T_H264-201402).
  *
  *  @param[in]   ps_cabac_ctxt
  *  pointer to cabac context (handle)
  *
  * @returns  none
  *
  * @remarks
  *  None
  *
  *******************************************************************************
  */
-void ih264e_cabac_flush(cabac_ctxt_t *ps_cabac_ctxt)
+IH264E_ERROR_T ih264e_cabac_flush(cabac_ctxt_t *ps_cabac_ctxt)
 {
-
     /* bit stream ptr */
     bitstrm_t *ps_stream = ps_cabac_ctxt->ps_bitstrm;
     encoding_envirnoment_t *ps_cab_enc_env = &(ps_cabac_ctxt->s_cab_enc_env);
     UWORD32 u4_low = ps_cab_enc_env->u4_code_int_low;
     UWORD32 u4_bits_gen = ps_cab_enc_env->u4_bits_gen;
     UWORD8 *pu1_strm_buf = ps_stream->pu1_strm_buffer;
-    UWORD32 u4_strm_buf_offset = ps_stream->u4_strm_buf_offset;
-    WORD32 zero_run = ps_stream->i4_zero_bytes_run;
     UWORD32 u4_out_standing_bytes = ps_cab_enc_env->u4_out_standing_bytes;
+    IH264E_ERROR_T status = IH264E_SUCCESS;
 
     /************************************************************************/
     /* Insert the carry (propogated in previous byte) along with            */
     /* outstanding bytes (if any) and flush remaining bits                  */
     /************************************************************************/
     {
         /* carry = 1 => putbit(1); carry propogated due to L renorm */
         WORD32 carry = (u4_low >> (u4_bits_gen + CABAC_BITS)) & 0x1;
         WORD32 last_byte;
         WORD32 bits_left;
         WORD32 rem_bits;
 
         if (carry)
         {
             /* CORNER CASE: if the previous data is 0x000003, then EPB will be inserted
              and the data will become 0x00000303 and if the carry is present, it will
              be added with the last byte and it will become 0x00000304 which is not correct
              as per standard */
             /* so check for previous four bytes and if it is equal to 0x00000303
              then subtract u4_strm_buf_offset by 1 */
-            if (pu1_strm_buf[u4_strm_buf_offset - 1] == 0x03
-                            && pu1_strm_buf[u4_strm_buf_offset - 2] == 0x03
-                            && pu1_strm_buf[u4_strm_buf_offset - 3] == 0x00
-                            && pu1_strm_buf[u4_strm_buf_offset - 4] == 0x00)
+            if (pu1_strm_buf[ps_stream->u4_strm_buf_offset - 1] == 0x03
+                            && pu1_strm_buf[ps_stream->u4_strm_buf_offset - 2] == 0x03
+                            && pu1_strm_buf[ps_stream->u4_strm_buf_offset - 3] == 0x00
+                            && pu1_strm_buf[ps_stream->u4_strm_buf_offset - 4] == 0x00)
             {
-                u4_strm_buf_offset -= 1;
+                ps_stream->u4_strm_buf_offset -= 1;
             }
             /* previous byte carry add will not result in overflow to        */
             /* u4_strm_buf_offset - 2 as we track 0xff as outstanding bytes  */
-            pu1_strm_buf[u4_strm_buf_offset - 1] += carry;
-            zero_run = 0;
+            pu1_strm_buf[ps_stream->u4_strm_buf_offset - 1] += carry;
+            ps_stream->i4_zero_bytes_run = 0;
         }
 
         /*        Insert outstanding bytes (if any)         */
         while (u4_out_standing_bytes)
         {
             UWORD8 u1_0_or_ff = carry ? 0 : 0xFF;
 
-            PUTBYTE_EPB(pu1_strm_buf, u4_strm_buf_offset, u1_0_or_ff, zero_run);
+            status |= ih264e_put_byte_epb(ps_stream, u1_0_or_ff);
             u4_out_standing_bytes--;
         }
 
         /*  clear the carry in low */
         u4_low &= ((1 << (u4_bits_gen + CABAC_BITS)) - 1);
 
         /* extract the remaining bits;                                   */
         /* includes additional msb bit of low as per Figure 9-12      */
         bits_left = u4_bits_gen + 1;
         rem_bits = (u4_low >> (u4_bits_gen + CABAC_BITS - bits_left));
 
         if (bits_left >= 8)
         {
             last_byte = (rem_bits >> (bits_left - 8)) & 0xFF;
-            PUTBYTE_EPB(pu1_strm_buf, u4_strm_buf_offset, last_byte, zero_run);
+            status |= ih264e_put_byte_epb(ps_stream, last_byte);
             bits_left -= 8;
         }
 
         /* insert last byte along with rbsp stop bit(1) and 0's in the end */
         last_byte = (rem_bits << (8 - bits_left))
                         | (1 << (7 - bits_left) | (1 << (7 - bits_left - 1)));
         last_byte &= 0xFF;
-        PUTBYTE_EPB(pu1_strm_buf, u4_strm_buf_offset, last_byte, zero_run);
+        status |= ih264e_put_byte_epb(ps_stream, last_byte);
 
         /* update the state variables and return success */
-        ps_stream->u4_strm_buf_offset = u4_strm_buf_offset;
         ps_stream->i4_zero_bytes_run = 0;
         /* Default init values for scratch variables of bitstream context */
         ps_stream->u4_cur_word = 0;
         ps_stream->i4_bits_left_in_cw = WORD_SIZE;
 
     }
+    return status;
 }
 
 /**
  ******************************************************************************
  *
  *  @brief Puts new byte (and outstanding bytes) into bitstream after cabac
  *         renormalization
  *
  *  @par   Description
  *  1. Extract the leading byte of low(L)
  *  2. If leading byte=0xff increment outstanding bytes and return
  *     (as the actual bits depend on carry propogation later)
  *  3. If leading byte is not 0xff check for any carry propogation
  *  4. Insert the carry (propogated in previous byte) along with outstanding
  *     bytes (if any) and leading byte
  *
  *
  *  @param[in]   ps_cabac_ctxt
  *  pointer to cabac context (handle)
  *
  *  @return
  *
  ******************************************************************************
  */
-void ih264e_cabac_put_byte(cabac_ctxt_t *ps_cabac_ctxt)
+IH264E_ERROR_T ih264e_cabac_put_byte(cabac_ctxt_t *ps_cabac_ctxt)
 {
-
     /* bit stream ptr */
     bitstrm_t *ps_stream = ps_cabac_ctxt->ps_bitstrm;
     encoding_envirnoment_t *ps_cab_enc_env = &(ps_cabac_ctxt->s_cab_enc_env);
     UWORD32 u4_low = ps_cab_enc_env->u4_code_int_low;
     UWORD32 u4_bits_gen = ps_cab_enc_env->u4_bits_gen;
+    UWORD8 *pu1_strm_buf = ps_stream->pu1_strm_buffer;
     WORD32 lead_byte = u4_low >> (u4_bits_gen + CABAC_BITS - 8);
+    IH264E_ERROR_T status = IH264E_SUCCESS;
 
     /* Sanity checks */
     ASSERT((ps_cab_enc_env->u4_code_int_range >= 256)
                     && (ps_cab_enc_env->u4_code_int_range < 512));
     ASSERT((u4_bits_gen >= 8));
 
     /* update bits generated and low after extracting leading byte */
     u4_bits_gen -= 8;
     ps_cab_enc_env->u4_code_int_low &= ((1 << (CABAC_BITS + u4_bits_gen)) - 1);
     ps_cab_enc_env->u4_bits_gen = u4_bits_gen;
 
     /************************************************************************/
     /* 1. Extract the leading byte of low(L)                                */
     /* 2. If leading byte=0xff increment outstanding bytes and return       */
     /*      (as the actual bits depend on carry propogation later)          */
     /* 3. If leading byte is not 0xff check for any carry propogation       */
     /* 4. Insert the carry (propogated in previous byte) along with         */
     /*    outstanding bytes (if any) and leading byte                       */
     /************************************************************************/
     if (lead_byte == 0xff)
     {
         /* actual bits depend on carry propogration     */
         ps_cab_enc_env->u4_out_standing_bytes++;
-        return ;
     }
     else
     {
         /* carry = 1 => putbit(1); carry propogated due to L renorm */
         WORD32 carry = (lead_byte >> 8) & 0x1;
-        UWORD8 *pu1_strm_buf = ps_stream->pu1_strm_buffer;
-        UWORD32 u4_strm_buf_offset = ps_stream->u4_strm_buf_offset;
-        WORD32 zero_run = ps_stream->i4_zero_bytes_run;
         UWORD32 u4_out_standing_bytes = ps_cab_enc_env->u4_out_standing_bytes;
 
 
         /*********************************************************************/
         /*        Insert the carry propogated in previous byte               */
         /*                                                                   */
         /* Note : Do not worry about corruption into slice header align byte */
         /*        This is because the first bin cannot result in overflow    */
         /*********************************************************************/
         if (carry)
         {
             /* CORNER CASE: if the previous data is 0x000003, then EPB will be inserted
              and the data will become 0x00000303 and if the carry is present, it will
              be added with the last byte and it will become 0x00000304 which is not correct
              as per standard */
             /* so check for previous four bytes and if it is equal to 0x00000303
              then subtract u4_strm_buf_offset by 1 */
-            if (pu1_strm_buf[u4_strm_buf_offset - 1] == 0x03
-                            && pu1_strm_buf[u4_strm_buf_offset - 2] == 0x03
-                            && pu1_strm_buf[u4_strm_buf_offset - 3] == 0x00
-                            && pu1_strm_buf[u4_strm_buf_offset - 4] == 0x00)
+            if (pu1_strm_buf[ps_stream->u4_strm_buf_offset - 1] == 0x03
+                            && pu1_strm_buf[ps_stream->u4_strm_buf_offset - 2] == 0x03
+                            && pu1_strm_buf[ps_stream->u4_strm_buf_offset - 3] == 0x00
+                            && pu1_strm_buf[ps_stream->u4_strm_buf_offset - 4] == 0x00)
             {
-                u4_strm_buf_offset -= 1;
+                ps_stream->u4_strm_buf_offset -= 1;
             }
             /* previous byte carry add will not result in overflow to        */
             /* u4_strm_buf_offset - 2 as we track 0xff as outstanding bytes  */
-            pu1_strm_buf[u4_strm_buf_offset - 1] += carry;
-            zero_run = 0;
+            pu1_strm_buf[ps_stream->u4_strm_buf_offset - 1] += carry;
+            ps_stream->i4_zero_bytes_run = 0;
         }
 
         /*        Insert outstanding bytes (if any)         */
         while (u4_out_standing_bytes)
         {
             UWORD8 u1_0_or_ff = carry ? 0 : 0xFF;
 
-            PUTBYTE_EPB(pu1_strm_buf, u4_strm_buf_offset, u1_0_or_ff, zero_run);
+            status |= ih264e_put_byte_epb(ps_stream, u1_0_or_ff);
 
             u4_out_standing_bytes--;
         }
         ps_cab_enc_env->u4_out_standing_bytes = 0;
 
         /*        Insert the leading byte                   */
         lead_byte &= 0xFF;
-        PUTBYTE_EPB(pu1_strm_buf, u4_strm_buf_offset, lead_byte, zero_run);
-
-        /* update the state variables and return success */
-        ps_stream->u4_strm_buf_offset = u4_strm_buf_offset;
-        ps_stream->i4_zero_bytes_run = zero_run;
-
+        status |= ih264e_put_byte_epb(ps_stream, lead_byte);
     }
+    return status;
 }
 
 
 
 
  /**
  ******************************************************************************
  *
  *  @brief Codes a bin based on probablilty and mps packed context model
  *
  *  @par   Description
  *  1. Apart from encoding bin, context model is updated as per state transition
  *  2. Range and Low renormalization is done based on bin and original state
  *  3. After renorm bistream is updated (if required)
  *
  *  @param[in]   ps_cabac
  *  pointer to cabac context (handle)
  *
  *  @param[in]   bin
  *  bin(boolean) to be encoded
  *
  *  @param[in]  pu1_bin_ctxts
  *  index of cabac context model containing pState[bits 5-0] | MPS[bit6]
  *
  *  @return
  *
  ******************************************************************************
   */
diff --git a/encoder/ih264e_cabac.h b/encoder/ih264e_cabac.h
index e4722fa..bc4b07c 100644
--- a/encoder/ih264e_cabac.h
+++ b/encoder/ih264e_cabac.h
@@ -178,66 +178,66 @@ void ih264e_get_cabac_context(entropy_ctxt_t *ps_ent_ctxt, WORD32 u4_mb_type);
 /**
  *******************************************************************************
  * @brief
  *  flushing at termination: Explained in flowchart 9-12(ITU_T_H264-201402).
  *
  *  @param[in]   ps_cabac_ctxt
  *  pointer to cabac context (handle)
  *
  * @returns  none
  *
  * @remarks
  *  None
  *
  *******************************************************************************
  */
-void ih264e_cabac_flush(cabac_ctxt_t *ps_cabac_ctxt);
+IH264E_ERROR_T ih264e_cabac_flush(cabac_ctxt_t *ps_cabac_ctxt);
 
 
 /**
  ******************************************************************************
  *
  *  @brief Puts new byte (and outstanding bytes) into bitstream after cabac
  *         renormalization
  *
  *  @par   Description
  *  1. Extract the leading byte of low(L)
  *  2. If leading byte=0xff increment outstanding bytes and return
  *     (as the actual bits depend on carry propogation later)
  *  3. If leading byte is not 0xff check for any carry propogation
  *  4. Insert the carry (propogated in previous byte) along with outstanding
  *     bytes (if any) and leading byte
  *
  *
  *  @param[inout]   ps_cabac_ctxt
  *  pointer to cabac context (handle)
  *
  *  @return
  *
  ******************************************************************************
  */
-void ih264e_cabac_put_byte(cabac_ctxt_t *ps_cabac_ctxt);
+IH264E_ERROR_T ih264e_cabac_put_byte(cabac_ctxt_t *ps_cabac_ctxt);
 
 
 /**
  ******************************************************************************
  *
  *  @brief Codes a bin based on probablilty and mps packed context model
  *
  *  @par   Description
  *  1. Apart from encoding bin, context model is updated as per state transition
  *  2. Range and Low renormalization is done based on bin and original state
  *  3. After renorm bistream is updated (if required)
  *
  *  @param[inout]   ps_cabac
  *  pointer to cabac context (handle)
  *
  *  @param[in]   bin
  *  bin(boolean) to be encoded
  *
  *  @param[in]  pu1_bin_ctxts
  *  index of cabac context model containing pState[bits 5-0] | MPS[bit6]
  *
  *  @return
  *
  ******************************************************************************
  */
diff --git a/encoder/ih264e_process.c b/encoder/ih264e_process.c
index 490c6d8..289053f 100644
--- a/encoder/ih264e_process.c
+++ b/encoder/ih264e_process.c
@@ -279,426 +279,426 @@ IH264E_ERROR_T ih264e_init_entropy_ctxt(process_ctxt_t *ps_proc)
 IH264E_ERROR_T ih264e_entropy(process_ctxt_t *ps_proc)
 {
     /* codec context */
     codec_t *ps_codec = ps_proc->ps_codec;
 
     /* entropy context */
     entropy_ctxt_t *ps_entropy = &ps_proc->s_entropy;
 
     /* cabac context */
     cabac_ctxt_t *ps_cabac_ctxt = ps_entropy->ps_cabac;
 
     /* sps */
     sps_t *ps_sps = ps_entropy->ps_sps_base + (ps_entropy->u4_sps_id % MAX_SPS_CNT);
 
     /* pps */
     pps_t *ps_pps = ps_entropy->ps_pps_base + (ps_entropy->u4_pps_id % MAX_PPS_CNT);
 
     /* slice header */
     slice_header_t *ps_slice_hdr = ps_entropy->ps_slice_hdr_base + (ps_entropy->i4_cur_slice_idx % MAX_SLICE_HDR_CNT);
 
     /* slice type */
     WORD32 i4_slice_type = ps_proc->i4_slice_type;
 
     /* Bitstream structure */
     bitstrm_t *ps_bitstrm = ps_entropy->ps_bitstrm;
 
     /* output buff */
     out_buf_t s_out_buf;
 
     /* sei params */
     sei_params_t s_sei;
 
     /* proc map */
     UWORD8  *pu1_proc_map;
 
     /* entropy map */
     UWORD8  *pu1_entropy_map_curr;
 
     /* proc base idx */
     WORD32 ctxt_sel = ps_proc->i4_encode_api_call_cnt % MAX_CTXT_SETS;
 
     /* temp var */
     WORD32 i4_wd_mbs, i4_ht_mbs;
     UWORD32 u4_mb_cnt, u4_mb_idx, u4_mb_end_idx, u4_insert_per_idr;
     WORD32 bitstream_start_offset, bitstream_end_offset;
     /********************************************************************/
     /*                            BEGIN INIT                            */
     /********************************************************************/
 
     /* entropy encode start address */
     u4_mb_idx = ps_entropy->i4_mb_start_add;
 
     /* entropy encode end address */
     u4_mb_end_idx = ps_entropy->i4_mb_end_add;
 
     /* width in mbs */
     i4_wd_mbs = ps_entropy->i4_wd_mbs;
 
     /* height in mbs */
     i4_ht_mbs = ps_entropy->i4_ht_mbs;
 
     /* total mb cnt */
     u4_mb_cnt = i4_wd_mbs * i4_ht_mbs;
 
     /* proc map */
     pu1_proc_map = ps_proc->pu1_proc_map + ps_entropy->i4_mb_y * i4_wd_mbs;
 
     /* entropy map */
     pu1_entropy_map_curr = ps_entropy->pu1_entropy_map + ps_entropy->i4_mb_y * i4_wd_mbs;
 
     /********************************************************************/
     /* @ start of frame / slice,                                        */
     /*      initialize the output buffer,                               */
     /*      initialize the bit stream buffer,                           */
     /*      check if sps and pps headers have to be generated,          */
     /*      populate and generate slice header                          */
     /********************************************************************/
     if (ps_entropy->i4_sof)
     {
         /********************************************************************/
         /*      initialize the output buffer                                */
         /********************************************************************/
         s_out_buf = ps_codec->as_out_buf[ctxt_sel];
 
         /* is last frame to encode */
         s_out_buf.u4_is_last = ps_entropy->u4_is_last;
 
         /* frame idx */
         s_out_buf.u4_timestamp_high = ps_entropy->u4_timestamp_high;
         s_out_buf.u4_timestamp_low = ps_entropy->u4_timestamp_low;
 
         /********************************************************************/
         /*      initialize the bit stream buffer                            */
         /********************************************************************/
         ih264e_bitstrm_init(ps_bitstrm, s_out_buf.s_bits_buf.pv_buf, s_out_buf.s_bits_buf.u4_bufsize);
 
         /********************************************************************/
         /*                    BEGIN HEADER GENERATION                       */
         /********************************************************************/
         if (1 == ps_entropy->i4_gen_header)
         {
             /* generate sps */
             ps_entropy->i4_error_code = ih264e_generate_sps(ps_bitstrm, ps_sps,
                                                              &ps_codec->s_cfg.s_vui);
             RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
             /* generate pps */
             ps_entropy->i4_error_code = ih264e_generate_pps(ps_bitstrm, ps_pps, ps_sps);
             RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
 
             /* reset i4_gen_header */
             ps_entropy->i4_gen_header = 0;
         }
 
         /* populate slice header */
         ih264e_populate_slice_header(ps_proc, ps_slice_hdr, ps_pps, ps_sps);
 
         /* generate sei */
         u4_insert_per_idr = (NAL_SLICE_IDR == ps_slice_hdr->i1_nal_unit_type);
 
         memset(&s_sei, 0, sizeof(sei_params_t));
         s_sei.u1_sei_mdcv_params_present_flag =
                     ps_codec->s_cfg.s_sei.u1_sei_mdcv_params_present_flag;
         s_sei.s_sei_mdcv_params = ps_codec->s_cfg.s_sei.s_sei_mdcv_params;
         s_sei.u1_sei_cll_params_present_flag =
                     ps_codec->s_cfg.s_sei.u1_sei_cll_params_present_flag;
         s_sei.s_sei_cll_params = ps_codec->s_cfg.s_sei.s_sei_cll_params;
         s_sei.u1_sei_ave_params_present_flag =
                     ps_codec->s_cfg.s_sei.u1_sei_ave_params_present_flag;
         s_sei.s_sei_ave_params = ps_codec->s_cfg.s_sei.s_sei_ave_params;
         s_sei.u1_sei_ccv_params_present_flag = 0;
         s_sei.s_sei_ccv_params =
                     ps_codec->as_inp_list[ps_codec->i4_poc % MAX_NUM_BFRAMES].s_sei_ccv;
 
         if((1 == ps_sps->i1_vui_parameters_present_flag) &&
            (1 == ps_codec->s_cfg.s_vui.u1_video_signal_type_present_flag) &&
            (1 == ps_codec->s_cfg.s_vui.u1_colour_description_present_flag) &&
            (2 != ps_codec->s_cfg.s_vui.u1_colour_primaries) &&
            (2 != ps_codec->s_cfg.s_vui.u1_matrix_coefficients) &&
            (2 != ps_codec->s_cfg.s_vui.u1_transfer_characteristics) &&
            (4 != ps_codec->s_cfg.s_vui.u1_transfer_characteristics) &&
            (5 != ps_codec->s_cfg.s_vui.u1_transfer_characteristics))
         {
             s_sei.u1_sei_ccv_params_present_flag =
             ps_codec->as_inp_list[ps_codec->i4_poc % MAX_NUM_BFRAMES].u1_sei_ccv_params_present_flag;
         }
 
         if((1 == s_sei.u1_sei_mdcv_params_present_flag && u4_insert_per_idr) ||
            (1 == s_sei.u1_sei_cll_params_present_flag && u4_insert_per_idr) ||
            (1 == s_sei.u1_sei_ave_params_present_flag && u4_insert_per_idr) ||
            (1 == s_sei.u1_sei_ccv_params_present_flag))
         {
             ps_entropy->i4_error_code =
                     ih264e_generate_sei(ps_bitstrm, &s_sei, u4_insert_per_idr);
             RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
         }
         ps_codec->as_inp_list[ps_codec->i4_poc % MAX_NUM_BFRAMES].u1_sei_ccv_params_present_flag = 0;
 
         /* generate slice header */
         ps_entropy->i4_error_code = ih264e_generate_slice_header(ps_bitstrm, ps_slice_hdr,
                                                                   ps_pps, ps_sps);
         RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
         /* once start of frame / slice is done, you can reset it */
         /* it is the responsibility of the caller to set this flag */
         ps_entropy->i4_sof = 0;
 
         if (CABAC == ps_entropy->u1_entropy_coding_mode_flag)
         {
             BITSTREAM_BYTE_ALIGN(ps_bitstrm);
-            BITSTREAM_FLUSH(ps_bitstrm);
+            BITSTREAM_FLUSH(ps_bitstrm, ps_entropy->i4_error_code);
             ih264e_init_cabac_ctxt(ps_entropy);
         }
     }
 
     /* begin entropy coding for the mb set */
     while (u4_mb_idx < u4_mb_end_idx)
     {
         /* init ptrs/indices */
         if (ps_entropy->i4_mb_x == i4_wd_mbs)
         {
             ps_entropy->i4_mb_y++;
             ps_entropy->i4_mb_x = 0;
 
             /* packed mb coeff data */
             ps_entropy->pv_mb_coeff_data = ((UWORD8 *)ps_entropy->pv_pic_mb_coeff_data) +
                             ps_entropy->i4_mb_y * ps_codec->u4_size_coeff_data;
 
             /* packed mb header data */
             ps_entropy->pv_mb_header_data = ((UWORD8 *)ps_entropy->pv_pic_mb_header_data) +
                             ps_entropy->i4_mb_y * ps_codec->u4_size_header_data;
 
             /* proc map */
             pu1_proc_map = ps_proc->pu1_proc_map + ps_entropy->i4_mb_y * i4_wd_mbs;
 
             /* entropy map */
             pu1_entropy_map_curr = ps_entropy->pu1_entropy_map + ps_entropy->i4_mb_y * i4_wd_mbs;
         }
 
         DEBUG("\nmb indices x, y %d, %d", ps_entropy->i4_mb_x, ps_entropy->i4_mb_y);
         ENTROPY_TRACE("mb index x %d", ps_entropy->i4_mb_x);
         ENTROPY_TRACE("mb index y %d", ps_entropy->i4_mb_y);
 
         /* wait until the curr mb is core coded */
         /* The wait for curr mb to be core coded is essential when entropy is launched
          * as a separate job
          */
         while (1)
         {
             volatile UWORD8 *pu1_buf1;
             WORD32 idx = ps_entropy->i4_mb_x;
 
             pu1_buf1 = pu1_proc_map + idx;
             if (*pu1_buf1)
                 break;
             ithread_yield();
         }
 
 
         /* write mb layer */
         ps_entropy->i4_error_code = ps_codec->pf_write_mb_syntax_layer
                         [ps_entropy->u1_entropy_coding_mode_flag][i4_slice_type](ps_entropy);
         RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
 
         /* Starting bitstream offset for header in bits */
         bitstream_start_offset = GET_NUM_BITS(ps_bitstrm);
 
         /* set entropy map */
         pu1_entropy_map_curr[ps_entropy->i4_mb_x] = 1;
 
         u4_mb_idx++;
         ps_entropy->i4_mb_x++;
         /* check for eof */
         if (CABAC == ps_entropy->u1_entropy_coding_mode_flag)
         {
             if (ps_entropy->i4_mb_x < i4_wd_mbs)
             {
                 ih264e_cabac_encode_terminate(ps_cabac_ctxt, 0);
             }
         }
 
         if (ps_entropy->i4_mb_x == i4_wd_mbs)
         {
             /* if slices are enabled */
             if (ps_codec->s_cfg.e_slice_mode == IVE_SLICE_MODE_BLOCKS)
             {
                 /* current slice index */
                 WORD32 i4_curr_slice_idx = ps_entropy->i4_cur_slice_idx;
 
                 /* slice map */
                 UWORD8 *pu1_slice_idx = ps_entropy->pu1_slice_idx;
 
                 /* No need to open a slice at end of frame. The current slice can be closed at the time
                  * of signaling eof flag.
                  */
                 if ((u4_mb_idx != u4_mb_cnt) && (i4_curr_slice_idx
                                                 != pu1_slice_idx[u4_mb_idx]))
                 {
                     if (CAVLC == ps_entropy->u1_entropy_coding_mode_flag)
                     { /* mb skip run */
                         if ((i4_slice_type != ISLICE)
                                         && *ps_entropy->pi4_mb_skip_run)
                         {
                             if (*ps_entropy->pi4_mb_skip_run)
                             {
                                 PUT_BITS_UEV(ps_bitstrm, *ps_entropy->pi4_mb_skip_run,
                                             ps_entropy->i4_error_code, "mb skip run");
                                 *ps_entropy->pi4_mb_skip_run = 0;
                                 RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
                             }
                         }
                         /* put rbsp trailing bits for the previous slice */
                         ps_entropy->i4_error_code = ih264e_put_rbsp_trailing_bits(ps_bitstrm);
                         RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
                     }
                     else
                     {
                         ih264e_cabac_encode_terminate(ps_cabac_ctxt, 1);
                     }
 
                     /* update slice header pointer */
                     i4_curr_slice_idx = pu1_slice_idx[u4_mb_idx];
                     ps_entropy->i4_cur_slice_idx = i4_curr_slice_idx;
                     ps_slice_hdr = ps_entropy->ps_slice_hdr_base+ (i4_curr_slice_idx % MAX_SLICE_HDR_CNT);
 
                     /* populate slice header */
                     ps_entropy->i4_mb_start_add = u4_mb_idx;
                     ih264e_populate_slice_header(ps_proc, ps_slice_hdr, ps_pps,
                                                  ps_sps);
 
                     /* generate slice header */
                     ps_entropy->i4_error_code = ih264e_generate_slice_header(
                                     ps_bitstrm, ps_slice_hdr, ps_pps, ps_sps);
                     RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
                     if (CABAC == ps_entropy->u1_entropy_coding_mode_flag)
                     {
                         BITSTREAM_BYTE_ALIGN(ps_bitstrm);
-                        BITSTREAM_FLUSH(ps_bitstrm);
+                        BITSTREAM_FLUSH(ps_bitstrm, ps_entropy->i4_error_code);
                         ih264e_init_cabac_ctxt(ps_entropy);
                     }
                 }
                 else
                 {
                     if (CABAC == ps_entropy->u1_entropy_coding_mode_flag
                                     && u4_mb_idx != u4_mb_cnt)
                     {
                         ih264e_cabac_encode_terminate(ps_cabac_ctxt, 0);
                     }
                 }
             }
         }
 
         /* Ending bitstream offset for header in bits */
         bitstream_end_offset = GET_NUM_BITS(ps_bitstrm);
         ps_entropy->u4_header_bits[i4_slice_type == PSLICE] +=
                         bitstream_end_offset - bitstream_start_offset;
     }
 
     /* check for eof */
     if (u4_mb_idx == u4_mb_cnt)
     {
         /* set end of frame flag */
         ps_entropy->i4_eof = 1;
     }
     else
     {
         if (CABAC == ps_entropy->u1_entropy_coding_mode_flag
                         && ps_codec->s_cfg.e_slice_mode
                                         != IVE_SLICE_MODE_BLOCKS)
         {
             ih264e_cabac_encode_terminate(ps_cabac_ctxt, 0);
         }
     }
 
     if (ps_entropy->i4_eof)
     {
         if (CAVLC == ps_entropy->u1_entropy_coding_mode_flag)
         {
             /* mb skip run */
             if ((i4_slice_type != ISLICE) && *ps_entropy->pi4_mb_skip_run)
             {
                 if (*ps_entropy->pi4_mb_skip_run)
                 {
                     PUT_BITS_UEV(ps_bitstrm, *ps_entropy->pi4_mb_skip_run,
                                  ps_entropy->i4_error_code, "mb skip run");
                     *ps_entropy->pi4_mb_skip_run = 0;
                     RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
                 }
             }
             /* put rbsp trailing bits */
              ps_entropy->i4_error_code = ih264e_put_rbsp_trailing_bits(ps_bitstrm);
              RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
         }
         else
         {
             ih264e_cabac_encode_terminate(ps_cabac_ctxt, 1);
         }
 
         /* update current frame stats to rc library */
         {
             /* number of bytes to stuff */
             WORD32 i4_stuff_bytes;
 
             /* update */
             i4_stuff_bytes = ih264e_update_rc_post_enc(
                             ps_codec, ctxt_sel,
                             (ps_proc->ps_codec->i4_poc == 0));
 
             /* cbr rc - house keeping */
             if (ps_codec->s_rate_control.post_encode_skip[ctxt_sel])
             {
                  ps_entropy->ps_bitstrm->u4_strm_buf_offset = 0;
             }
             else if (i4_stuff_bytes)
             {
                 /* add filler nal units */
                  ps_entropy->i4_error_code = ih264e_add_filler_nal_unit(ps_bitstrm, i4_stuff_bytes);
                  RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
             }
         }
 
         /*
          *Frame number is to be incremented only if the current frame is a
          * reference frame. After each successful frame encode, we increment
          * frame number by 1
          */
         if (!ps_codec->s_rate_control.post_encode_skip[ctxt_sel]
                         && ps_codec->u4_is_curr_frm_ref)
         {
             ps_codec->i4_frame_num++;
         }
         /********************************************************************/
         /*      signal the output                                           */
         /********************************************************************/
         ps_codec->as_out_buf[ctxt_sel].s_bits_buf.u4_bytes =
                         ps_entropy->ps_bitstrm->u4_strm_buf_offset;
 
         DEBUG("entropy status %x", ps_entropy->i4_error_code);
     }
 
     /* Dont execute any further instructions until store synchronization took place */
     DATA_SYNC();
 
     /* allow threads to dequeue entropy jobs */
     ps_codec->au4_entropy_thread_active[ctxt_sel] = 0;
 
     return ps_entropy->i4_error_code;
 }
 
 /**
 *******************************************************************************
 *
 * @brief Packs header information of a mb in to a buffer
 *
 * @par Description:
 *  After the deciding the mode info of a macroblock, the syntax elements
 *  associated with the mb are packed and stored. The entropy thread unpacks
 *  this buffer and generates the end bit stream.
 *
 * @param[in] ps_proc
 *  Pointer to the current process context
 *
 * @returns error status
 *
 * @remarks none
 *
 *******************************************************************************
 */
