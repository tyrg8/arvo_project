commit 56462c122925f716865827cc5505f671c2933aca
Author: Roger A. Light <roger@atchoo.org>
Date:   Wed Apr 19 16:38:10 2023 +0100

    Refactor for more consistent json helper use.

diff --git a/apps/mosquitto_ctrl/broker.c b/apps/mosquitto_ctrl/broker.c
index 23081086..7fea7b64 100644
--- a/apps/mosquitto_ctrl/broker.c
+++ b/apps/mosquitto_ctrl/broker.c
@@ -15,13 +15,14 @@ SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
 Contributors:
    Roger Light - initial implementation and documentation.
 */
 #include "config.h"
 
 #include <cjson/cJSON.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
+#include "json_help.h"
 #include "mosquitto_ctrl.h"
 #include "mosquitto.h"
 
@@ -43,45 +44,43 @@ void broker__print_usage(void)
 static void print_listeners(cJSON *j_response)
 {
 	cJSON *j_data, *j_listeners, *j_listener, *jtmp;
+	char *stmp;
 	int i=1;
 
 	j_data = cJSON_GetObjectItem(j_response, "data");
 	if(j_data == NULL || !cJSON_IsObject(j_data)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	j_listeners = cJSON_GetObjectItem(j_data, "listeners");
 	if(j_listeners == NULL || !cJSON_IsArray(j_listeners)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	cJSON_ArrayForEach(j_listener, j_listeners){
 		printf("Listener %d:\n", i);
 
 		jtmp = cJSON_GetObjectItem(j_listener, "port");
 		if(jtmp && cJSON_IsNumber(jtmp)){
 			printf("  Port:              %d\n", jtmp->valueint);
 		}
 
-		jtmp = cJSON_GetObjectItem(j_listener, "protocol");
-		if(jtmp && cJSON_IsString(jtmp)){
-			printf("  Protocol:          %s\n", jtmp->valuestring);
+		if(json_get_string(j_listener, "protocol", &stmp, false) == MOSQ_ERR_SUCCESS){
+			printf("  Protocol:          %s\n", stmp);
 		}
 
-		jtmp = cJSON_GetObjectItem(j_listener, "socket-path");
-		if(jtmp && cJSON_IsString(jtmp)){
-			printf("  Socket path:       %s\n", jtmp->valuestring);
+		if(json_get_string(j_listener, "socket-path", &stmp, false) == MOSQ_ERR_SUCCESS){
+			printf("  Socket path:       %s\n", stmp);
 		}
 
-		jtmp = cJSON_GetObjectItem(j_listener, "bind-address");
-		if(jtmp && cJSON_IsString(jtmp)){
-			printf("  Bind address:      %s\n", jtmp->valuestring);
+		if(json_get_string(j_listener, "bind-address", &stmp, false) == MOSQ_ERR_SUCCESS){
+			printf("  Bind address:      %s\n", stmp);
 		}
 
 		jtmp = cJSON_GetObjectItem(j_listener, "tls");
 		printf("  TLS:               %s\n", jtmp && cJSON_IsBool(jtmp) && cJSON_IsTrue(jtmp)?"true":"false");
 		printf("\n");
 	}
 }
@@ -90,46 +89,45 @@ static void print_listeners(cJSON *j_response)
 static void print_plugin_info(cJSON *j_response)
 {
 	cJSON *j_data, *j_plugins, *j_plugin, *jtmp, *j_eps;
+	char *stmp;
 	bool first;
 
 	j_data = cJSON_GetObjectItem(j_response, "data");
 	if(j_data == NULL || !cJSON_IsObject(j_data)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	j_plugins = cJSON_GetObjectItem(j_data, "plugins");
 	if(j_plugins == NULL || !cJSON_IsArray(j_plugins)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	cJSON_ArrayForEach(j_plugin, j_plugins){
-		jtmp = cJSON_GetObjectItem(j_plugin, "name");
-		if(jtmp == NULL || !cJSON_IsString(jtmp)){
+		if(json_get_string(j_plugin, "name", &stmp, false) != MOSQ_ERR_SUCCESS){
 			fprintf(stderr, "Error: Invalid response from server.\n");
 			return;
 		}
-		printf("Plugin:            %s\n", jtmp->valuestring);
+		printf("Plugin:            %s\n", stmp);
 
-		jtmp = cJSON_GetObjectItem(j_plugin, "version");
-		if(jtmp && cJSON_IsString(jtmp)){
-			printf("Version:           %s\n", jtmp->valuestring);
+		if(json_get_string(j_plugin, "version", &stmp, false) != MOSQ_ERR_SUCCESS){
+			printf("Version:           %s\n", stmp);
 		}
 
 		j_eps = cJSON_GetObjectItem(j_plugin, "control-endpoints");
 		if(j_eps && cJSON_IsArray(j_eps)){
 			first = true;
 			cJSON_ArrayForEach(jtmp, j_eps){
-				if(jtmp && cJSON_IsString(jtmp)){
+				if(jtmp && cJSON_IsString(jtmp) && jtmp->valuestring){
 					if(first){
 						first = false;
 						printf("Control endpoints: %s\n", jtmp->valuestring);
 					}else{
 						printf("                   %s\n", jtmp->valuestring);
 					}
 				}
 			}
 		}
 	}
 }
@@ -137,53 +135,53 @@ static void print_plugin_info(cJSON *j_response)
 
 static void broker__payload_callback(struct mosq_ctrl *ctrl, long payloadlen, const void *payload)
 {
-	cJSON *tree, *j_responses, *j_response, *j_command, *j_error;
+	cJSON *tree, *j_responses, *j_response, *j_command;
 
 	UNUSED(ctrl);
 
 #if CJSON_VERSION_FULL < 1007013
 	UNUSED(payloadlen);
 	tree = cJSON_Parse(payload);
 #else
 	tree = cJSON_ParseWithLength(payload, (size_t)payloadlen);
 #endif
 	if(tree == NULL){
 		fprintf(stderr, "Error: Payload not JSON.\n");
 		return;
 	}
 
 	j_responses = cJSON_GetObjectItem(tree, "responses");
 	if(j_responses == NULL || !cJSON_IsArray(j_responses)){
 		fprintf(stderr, "Error: Payload missing data.\n");
 		cJSON_Delete(tree);
 		return;
 	}
 
 	j_response = cJSON_GetArrayItem(j_responses, 0);
 	if(j_response == NULL){
 		fprintf(stderr, "Error: Payload missing data.\n");
 		cJSON_Delete(tree);
 		return;
 	}
 
 	j_command = cJSON_GetObjectItem(j_response, "command");
 	if(j_command == NULL){
 		fprintf(stderr, "Error: Payload missing data.\n");
 		cJSON_Delete(tree);
 		return;
 	}
 
-	j_error = cJSON_GetObjectItem(j_response, "error");
-	if(j_error){
-		fprintf(stderr, "%s: Error: %s.\n", j_command->valuestring, j_error->valuestring);
+	char *error;
+	if(json_get_string(j_response, "error", &error, false) == MOSQ_ERR_SUCCESS){
+		fprintf(stderr, "%s: Error: %s.\n", j_command->valuestring, error);
 	}else{
 		if(!strcasecmp(j_command->valuestring, "listPlugins")){
 			print_plugin_info(j_response);
 		}else if(!strcasecmp(j_command->valuestring, "listListeners")){
 			print_listeners(j_response);
 		}else{
 			/* fprintf(stderr, "%s: Success\n", j_command->valuestring); */
 		}
 	}
 	cJSON_Delete(tree);
 }
diff --git a/apps/mosquitto_ctrl/dynsec.c b/apps/mosquitto_ctrl/dynsec.c
index 8a941ad2..151b5c74 100644
--- a/apps/mosquitto_ctrl/dynsec.c
+++ b/apps/mosquitto_ctrl/dynsec.c
@@ -15,21 +15,22 @@ SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
 Contributors:
    Roger Light - initial implementation and documentation.
 */
 #include "config.h"
 
 #include <cjson/cJSON.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #ifndef WIN32
 #  include <strings.h>
 #endif
 
 #include "mosquitto_ctrl.h"
 #include "mosquitto.h"
 #include "base64_mosq.h"
+#include "json_help.h"
 #include "password_mosq.h"
 #include "get_password.h"
 
 #define MAX_STRING_LEN 4096
@@ -100,28 +101,29 @@ void dynsec__print_usage(void)
 
 static void print_list(cJSON *j_response, const char *arrayname, const char *keyname)
 {
-	cJSON *j_data, *j_array, *j_elem, *j_name;
+	cJSON *j_data, *j_array, *j_elem;
 
 	j_data = cJSON_GetObjectItem(j_response, "data");
 	if(j_data == NULL){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	j_array = cJSON_GetObjectItem(j_data, arrayname);
 	if(j_array == NULL || !cJSON_IsArray(j_array)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	cJSON_ArrayForEach(j_elem, j_array){
+		char *stmp;
+
 		if(cJSON_IsObject(j_elem)){
-			j_name = cJSON_GetObjectItem(j_elem, keyname);
-			if(j_name && cJSON_IsString(j_name)){
-				printf("%s\n", j_name->valuestring);
+			if(json_get_string(j_elem, keyname, &stmp, false) == MOSQ_ERR_SUCCESS){
+				printf("%s\n", stmp);
 			}
-		}else if(cJSON_IsString(j_elem)){
+		}else if(cJSON_IsString(j_elem) && j_elem->valuestring){
 			printf("%s\n", j_elem->valuestring);
 		}
 	}
 }
@@ -129,14 +131,16 @@ static void print_list(cJSON *j_response, const char *arrayname, const char *key
 static void print_json_value(cJSON *value, const char *null_value)
 {
 	if(value){
 		if(cJSON_IsString(value)){
-			printf("%s", value->valuestring);
+			if(value->valuestring){
+				printf("%s", value->valuestring);
+			}
 		}else{
 			char buffer[MAX_STRING_LEN];
 			cJSON_PrintPreallocated(value, buffer, sizeof(buffer), 0);
 			printf("%s", buffer);
 		}
 	}else if(null_value){
 		printf("%s",null_value);
 	}
 }
@@ -144,27 +148,28 @@ static void print_json_value(cJSON *value, const char *null_value)
 static void print_json_array(cJSON *j_list, int slen, const char *label, const char *element_name, const char *optional_element_name, const char *optional_element_null_value)
 {
 	cJSON *j_elem;
 
 	if(j_list && cJSON_IsArray(j_list)){
 		cJSON_ArrayForEach(j_elem, j_list){
 			if(cJSON_IsObject(j_elem)){
-				cJSON *jtmp = cJSON_GetObjectItem(j_elem, element_name);
-				if(!jtmp || !cJSON_IsString(jtmp)){
+				char *stmp;
+
+				if(json_get_string(j_elem, element_name, &stmp, false) != MOSQ_ERR_SUCCESS){
 					continue;
 				}
-				printf("%-*s %s", (int)slen, label, jtmp->valuestring);
+				printf("%-*s %s", (int)slen, label, stmp);
 				if(optional_element_name){
 					printf(" (%s: ", optional_element_name);
 					print_json_value(cJSON_GetObjectItem(j_elem,optional_element_name),optional_element_null_value);
 					printf(")");
 				}
-			}else if(cJSON_IsString(j_elem)){
+			}else if(cJSON_IsString(j_elem) && j_elem->valuestring){
 				printf("%-*s %s", (int)slen, label, j_elem->valuestring);
 			}
 			label = "";
 			printf("\n");
 		}
 	}else{
 		printf("%s\n", label);
 	}
 }
@@ -173,40 +178,39 @@ static void print_json_array(cJSON *j_list, int slen, const char *label, const c
 static void print_client(cJSON *j_response)
 {
 	cJSON *j_data, *j_client, *jtmp;
 	const int label_width = strlen( "Connections:");
+	char *stmp;
 
 	j_data = cJSON_GetObjectItem(j_response, "data");
 	if(j_data == NULL || !cJSON_IsObject(j_data)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	j_client = cJSON_GetObjectItem(j_data, "client");
 	if(j_client == NULL || !cJSON_IsObject(j_client)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
-	jtmp = cJSON_GetObjectItem(j_client, "username");
-	if(jtmp == NULL || !cJSON_IsString(jtmp)){
+	if(json_get_string(j_client, "username", &stmp, false) != MOSQ_ERR_SUCCESS){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
-	printf("%-*s %s\n",  label_width, "Username:", jtmp->valuestring);
+	printf("%-*s %s\n",  label_width, "Username:", stmp);
 
-	jtmp = cJSON_GetObjectItem(j_client, "clientid");
-	if(jtmp && cJSON_IsString(jtmp)){
-		printf("%-*s %s\n",  label_width, "Clientid:", jtmp->valuestring);
+	if(json_get_string(j_client, "clientid", &stmp, false) != MOSQ_ERR_SUCCESS){
+		printf("%-*s %s\n",  label_width, "Clientid:", stmp);
 	}else{
 		printf("Clientid:\n");
 	}
 
 	jtmp = cJSON_GetObjectItem(j_client, "disabled");
 	if(jtmp && cJSON_IsBool(jtmp)){
 		printf("%-*s %s\n",  label_width, "Disabled:", cJSON_IsTrue(jtmp)?"true":"false");
 	}
 
 	print_json_array(cJSON_GetObjectItem(j_client, "roles"), label_width, "Roles:",  "rolename", "priority", "-1");
 	print_json_array(cJSON_GetObjectItem(j_client, "groups"), label_width, "Groups:", "groupname", "priority", "-1");
 	print_json_array(cJSON_GetObjectItem(j_client, "connections"), label_width, "Connections:", "address", NULL, NULL);
 }
@@ -214,28 +218,28 @@ static void print_client(cJSON *j_response)
 
 static void print_group(cJSON *j_response)
 {
-	cJSON *j_data, *j_group, *jtmp;
+	cJSON *j_data, *j_group;
 	int label_width = strlen("Groupname:");
+	char *groupname;
 
 	j_data = cJSON_GetObjectItem(j_response, "data");
 	if(j_data == NULL || !cJSON_IsObject(j_data)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	j_group = cJSON_GetObjectItem(j_data, "group");
 	if(j_group == NULL || !cJSON_IsObject(j_group)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
-	jtmp = cJSON_GetObjectItem(j_group, "groupname");
-	if(jtmp == NULL || !cJSON_IsString(jtmp)){
+	if(json_get_string(j_group, "groupname", &groupname, false) != MOSQ_ERR_SUCCESS){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
-	printf("Groupname: %s\n", jtmp->valuestring);
+	printf("Groupname: %s\n", groupname);
 
 	print_json_array(cJSON_GetObjectItem(j_group, "roles"), label_width, "Roles:",  "rolename", "priority", "-1");
 	print_json_array(cJSON_GetObjectItem(j_group, "clients"), label_width, "Clients:",  "username", NULL, NULL);
 }
@@ -244,56 +248,56 @@ static void print_group(cJSON *j_response)
 static void print_role(cJSON *j_response)
 {
 	cJSON *j_data, *j_role, *j_array, *j_elem, *jtmp;
 	bool first;
+	char *stmp;
 
 	j_data = cJSON_GetObjectItem(j_response, "data");
 	if(j_data == NULL || !cJSON_IsObject(j_data)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	j_role = cJSON_GetObjectItem(j_data, "role");
 	if(j_role == NULL || !cJSON_IsObject(j_role)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
-	jtmp = cJSON_GetObjectItem(j_role, "rolename");
-	if(jtmp == NULL || !cJSON_IsString(jtmp)){
+	if(json_get_string(j_role, "rolename", &stmp, false) != MOSQ_ERR_SUCCESS){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
-	printf("Rolename: %s\n", jtmp->valuestring);
+	printf("Rolename: %s\n", stmp);
 
 	j_array = cJSON_GetObjectItem(j_role, "acls");
 	if(j_array && cJSON_IsArray(j_array)){
 		first = true;
 		cJSON_ArrayForEach(j_elem, j_array){
-			jtmp = cJSON_GetObjectItem(j_elem, "acltype");
-			if(jtmp && cJSON_IsString(jtmp)){
+			char *stmp;
+
+			if(json_get_string(j_role, "rolename", &stmp, false) == MOSQ_ERR_SUCCESS){
 				if(first){
 					first = false;
-					printf("ACLs:     %-20s", jtmp->valuestring);
+					printf("ACLs:     %-20s", stmp);
 				}else{
-					printf("          %-20s", jtmp->valuestring);
+					printf("          %-20s", stmp);
 				}
 
 				jtmp = cJSON_GetObjectItem(j_elem, "allow");
 				if(jtmp && cJSON_IsBool(jtmp)){
 					printf(" : %s", cJSON_IsTrue(jtmp)?"allow":"deny ");
 				}
-				jtmp = cJSON_GetObjectItem(j_elem, "topic");
-				if(jtmp && cJSON_IsString(jtmp)){
-					printf(" : %s", jtmp->valuestring);
+				if(json_get_string(j_elem, "topic", &stmp, false) == MOSQ_ERR_SUCCESS){
+					printf(" : %s", stmp);
 				}
 				jtmp = cJSON_GetObjectItem(j_elem, "priority");
 				if(jtmp && cJSON_IsNumber(jtmp)){
 					printf(" (priority: %d)", (int)jtmp->valuedouble);
 				}else{
 					printf(" (priority: -1)");
 				}
 				printf("\n");
 			}
 		}
 	}
 }
@@ -301,126 +305,124 @@ static void print_role(cJSON *j_response)
 
 static void print_anonymous_group(cJSON *j_response)
 {
-	cJSON *j_data, *j_group, *j_groupname;
+	cJSON *j_data, *j_group;
+	char *groupname;
 
 	j_data = cJSON_GetObjectItem(j_response, "data");
 	if(j_data == NULL || !cJSON_IsObject(j_data)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	j_group = cJSON_GetObjectItem(j_data, "group");
 	if(j_group == NULL || !cJSON_IsObject(j_group)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
-	j_groupname = cJSON_GetObjectItem(j_group, "groupname");
-	if(j_groupname == NULL || !cJSON_IsString(j_groupname)){
+	if(json_get_string(j_group, "groupname", &groupname, false) == MOSQ_ERR_SUCCESS){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
-	printf("%s\n", j_groupname->valuestring);
+	printf("%s\n", groupname);
 }
 
 static void print_default_acl_access(cJSON *j_response)
 {
-	cJSON *j_data, *j_acls, *j_acl, *j_acltype, *j_allow;
+	cJSON *j_data, *j_acls, *j_acl;
 
 	j_data = cJSON_GetObjectItem(j_response, "data");
 	if(j_data == NULL || !cJSON_IsObject(j_data)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	j_acls = cJSON_GetObjectItem(j_data, "acls");
 	if(j_acls == NULL || !cJSON_IsArray(j_acls)){
 		fprintf(stderr, "Error: Invalid response from server.\n");
 		return;
 	}
 
 	cJSON_ArrayForEach(j_acl, j_acls){
-		j_acltype = cJSON_GetObjectItem(j_acl, "acltype");
-		j_allow = cJSON_GetObjectItem(j_acl, "allow");
+		char *acltype;
+		bool allow;
 
-		if(j_acltype == NULL || !cJSON_IsString(j_acltype)
-				|| j_allow == NULL || !cJSON_IsBool(j_allow)
-				){
+		if(json_get_string(j_acl, "acltype", &acltype, false) != MOSQ_ERR_SUCCESS
+				|| json_get_bool(j_acl, "allow", &allow, false, false) != MOSQ_ERR_SUCCESS){
 
 			fprintf(stderr, "Error: Invalid response from server.\n");
 			return;
 		}
-		printf("%-20s : %s\n", j_acltype->valuestring, cJSON_IsTrue(j_allow)?"allow":"deny");
+		printf("%-20s : %s\n", acltype, allow?"allow":"deny");
 	}
 }
 
 static void dynsec__payload_callback(struct mosq_ctrl *ctrl, long payloadlen, const void *payload)
 {
-	cJSON *tree, *j_responses, *j_response, *j_command, *j_error;
+	cJSON *tree, *j_responses, *j_response;
+	char *command, *error;
 
 	UNUSED(ctrl);
 
 #if CJSON_VERSION_FULL < 1007013
 	UNUSED(payloadlen);
 	tree = cJSON_Parse(payload);
 #else
 	tree = cJSON_ParseWithLength(payload, (size_t)payloadlen);
 #endif
 	if(tree == NULL){
 		fprintf(stderr, "Error: Payload not JSON.\n");
 		return;
 	}
 
 	j_responses = cJSON_GetObjectItem(tree, "responses");
 	if(j_responses == NULL || !cJSON_IsArray(j_responses)){
 		fprintf(stderr, "Error: Payload missing data.\n");
 		cJSON_Delete(tree);
 		return;
 	}
 
 	j_response = cJSON_GetArrayItem(j_responses, 0);
 	if(j_response == NULL){
 		fprintf(stderr, "Error: Payload missing data.\n");
 		cJSON_Delete(tree);
 		return;
 	}
 
-	j_command = cJSON_GetObjectItem(j_response, "command");
-	if(j_command == NULL){
+	if(json_get_string(j_response, "command", &command, false) != MOSQ_ERR_SUCCESS){
 		fprintf(stderr, "Error: Payload missing data.\n");
 		cJSON_Delete(tree);
 		return;
 	}
 
-	j_error = cJSON_GetObjectItem(j_response, "error");
-	if(j_error){
-		fprintf(stderr, "%s: Error: %s.\n", j_command->valuestring, j_error->valuestring);
+	if(json_get_string(j_response, "error", &error, false) == MOSQ_ERR_SUCCESS){
+		fprintf(stderr, "%s: Error: %s.\n", command, error);
 	}else{
-		if(!strcasecmp(j_command->valuestring, "listClients")){
+		if(!strcasecmp(command, "listClients")){
 			print_list(j_response, "clients", "username");
-		}else if(!strcasecmp(j_command->valuestring, "listGroups")){
+		}else if(!strcasecmp(command, "listGroups")){
 			print_list(j_response, "groups", "groupname");
-		}else if(!strcasecmp(j_command->valuestring, "listRoles")){
+		}else if(!strcasecmp(command, "listRoles")){
 			print_list(j_response, "roles", "rolename");
-		}else if(!strcasecmp(j_command->valuestring, "getClient")){
+		}else if(!strcasecmp(command, "getClient")){
 			print_client(j_response);
-		}else if(!strcasecmp(j_command->valuestring, "getGroup")){
+		}else if(!strcasecmp(command, "getGroup")){
 			print_group(j_response);
-		}else if(!strcasecmp(j_command->valuestring, "getRole")){
+		}else if(!strcasecmp(command, "getRole")){
 			print_role(j_response);
-		}else if(!strcasecmp(j_command->valuestring, "getDefaultACLAccess")){
+		}else if(!strcasecmp(command, "getDefaultACLAccess")){
 			print_default_acl_access(j_response);
-		}else if(!strcasecmp(j_command->valuestring, "getAnonymousGroup")){
+		}else if(!strcasecmp(command, "getAnonymousGroup")){
 			print_anonymous_group(j_response);
 		}else{
-			/* fprintf(stderr, "%s: Success\n", j_command->valuestring); */
+			/* fprintf(stderr, "%s: Success\n", command); */
 		}
 	}
 	cJSON_Delete(tree);
 }
 
 /* ################################################################
  * #
  * # Default ACL access
  * #
  * ################################################################ */
diff --git a/apps/mosquitto_ctrl/dynsec_client.c b/apps/mosquitto_ctrl/dynsec_client.c
index bd6fefdf..d1498b05 100644
--- a/apps/mosquitto_ctrl/dynsec_client.c
+++ b/apps/mosquitto_ctrl/dynsec_client.c
@@ -154,140 +154,140 @@ int dynsec_client__set_id(int argc, char *argv[], cJSON *j_command)
 int dynsec_client__file_set_password(int argc, char *argv[], const char *file)
 {
 	char *username = NULL, *password = NULL;
 	long len;
 	FILE *fptr;
 	char *fstr;
 	cJSON *j_tree, *j_clients, *j_client;
-	cJSON *j_username, *j_password = NULL, *j_salt = NULL, *j_iterations = NULL;
+	cJSON *j_password = NULL, *j_salt = NULL, *j_iterations = NULL;
 	struct dynsec__client client;
 	char *pw_buf = NULL, *salt_buf = NULL;
 	char *json_str;
 	int i;
 	int rc = MOSQ_ERR_UNKNOWN;
 
 	memset(&client, 0, sizeof(client));
 
 	if(argc >= 2){
 		username = argv[0];
 		password = argv[1];
 	}else{
 		return MOSQ_ERR_INVAL;
 	}
 	for(i=2; i<argc; i++){
 		if(!strcmp(argv[i], "-i")){
 			if(i+1 == argc){
 				fprintf(stderr, "Error: -i argument given, but no iterations provided.\n");
 				return MOSQ_ERR_INVAL;
 			}
 			client.pw.iterations = atoi(argv[i+1]);
 			i++;
 		}else{
 			fprintf(stderr, "Error: Unknown argument: %s\n", argv[i]);
 			return MOSQ_ERR_INVAL;
 		}
 	}
 
 	fptr = fopen(file, "rb");
 	if(fptr == NULL){
 		fprintf(stderr, "Error: Unable to open %s.\n", file);
 		return MOSQ_ERR_INVAL;
 	}
 	fseek(fptr, 0, SEEK_END);
 	len = ftell(fptr);
 	fseek(fptr, 0, SEEK_SET);
 	if(len <= 0){
 		fprintf(stderr, "Error: %s is empty.\n", file);
 		fclose(fptr);
 		return MOSQ_ERR_INVAL;
 	}
 
 	fstr = calloc(1, (size_t)len+1);
 	if(fstr == NULL){
 		fclose(fptr);
 		return MOSQ_ERR_NOMEM;
 	}
 	if(fread(fstr, 1, (size_t)len, fptr) != (size_t)len){
 		fprintf(stderr, "Error: Incomplete read of %s.\n", file);
 		fclose(fptr);
 		free(fstr);
 		return MOSQ_ERR_NOMEM;
 	}
 	fclose(fptr);
 
 	j_tree = cJSON_Parse(fstr);
 	free(fstr);
 
 	if(j_tree == NULL){
 		fprintf(stderr, "Error: %s is not valid JSON.\n", file);
 		return MOSQ_ERR_INVAL;
 	}
 
 	j_clients = cJSON_GetObjectItem(j_tree, "clients");
 	if(j_clients == NULL || !cJSON_IsArray(j_clients)){
 		fprintf(stderr, "Error: %s is not a valid dynamic-security config file.\n", file);
 		cJSON_Delete(j_tree);
 		return MOSQ_ERR_INVAL;
 	}
 
 	cJSON_ArrayForEach(j_client, j_clients){
 		if(cJSON_IsObject(j_client) == true){
-			j_username = cJSON_GetObjectItem(j_client, "username");
-			if(j_username && cJSON_IsString(j_username)){
-				if(!strcmp(j_username->valuestring, username)){
+			char *username_json;
+			if(json_get_string(j_client, "username", &username_json, false) == MOSQ_ERR_SUCCESS){
+				if(!strcmp(username_json, username)){
 					if(dynsec_auth__pw_hash(&client, password, client.pw.password_hash, sizeof(client.pw.password_hash), true) != MOSQ_ERR_SUCCESS){
 						fprintf(stderr, "Error: Problem generating password hash.\n");
 						goto error;
 					}
 
 					if(base64__encode(client.pw.password_hash, sizeof(client.pw.password_hash), &pw_buf) != MOSQ_ERR_SUCCESS){
 						fprintf(stderr, "Error: Problem generating password hash.\n");
 						rc = MOSQ_ERR_NOMEM;
 						goto error;
 					}
 					if(base64__encode(client.pw.salt, client.pw.salt_len, &salt_buf) != MOSQ_ERR_SUCCESS){
 						fprintf(stderr, "Error: Problem generating password hash.\n");
 						goto error;
 					}
 					if((j_password = cJSON_CreateString(pw_buf)) == NULL
 							|| (j_salt = cJSON_CreateString(salt_buf)) == NULL
 							|| (j_iterations = cJSON_CreateNumber(client.pw.iterations)) == NULL
 							){
 
 						fprintf(stderr, "Error: Out of memory.\n");
 						rc = MOSQ_ERR_NOMEM;
 						goto error;
 					}
 					cJSON_ReplaceItemInObject(j_client, "password", j_password);
 					cJSON_ReplaceItemInObject(j_client, "salt", j_salt);
 					cJSON_ReplaceItemInObject(j_client, "iterations", j_iterations);
 					j_password = NULL;
 					j_salt = NULL;
 					j_iterations = NULL;
 					free(pw_buf);
 					pw_buf = NULL;
 					free(salt_buf);
 					salt_buf = NULL;
 
 					json_str = cJSON_Print(j_tree);
 					cJSON_Delete(j_tree);
 					if(json_str == NULL){
 						fprintf(stderr, "Error: Out of memory.\n");
 						return MOSQ_ERR_NOMEM;
 					}
 					fptr = fopen(file, "wb");
 					if(fptr == NULL){
 						fprintf(stderr, "Error: Unable to write to %s.\n", file);
 						free(json_str);
 						return MOSQ_ERR_UNKNOWN;
 					}
 					fprintf(fptr, "%s", json_str);
 					free(json_str);
 					fclose(fptr);
 					return MOSQ_ERR_SUCCESS;
 				}
 			}
 		}
 	}
 
 	fprintf(stderr, "Error: Client %s not found.\n", username);
 	return MOSQ_ERR_SUCCESS;
diff --git a/common/json_help.c b/common/json_help.c
index 944332b5..2ca35729 100644
--- a/common/json_help.c
+++ b/common/json_help.c
@@ -76,19 +76,19 @@ int json_get_int(cJSON *json, const char *name, int *value, bool optional, int d
 int json_get_string(cJSON *json, const char *name, char **value, bool optional)
 {
 	cJSON *jtmp;
 
 	*value = NULL;
 
 	jtmp = cJSON_GetObjectItem(json, name);
 	if(jtmp){
 		if(cJSON_IsString(jtmp) == false){
 			return MOSQ_ERR_INVAL;
 		}
-		*value  = jtmp->valuestring;
+		*value = jtmp->valuestring;
 	}else{
 		if(optional == false){
 			return MOSQ_ERR_INVAL;
 		}
 	}
 	return MOSQ_ERR_SUCCESS;
 }
diff --git a/plugins/dynamic-security/clients.c b/plugins/dynamic-security/clients.c
index d3afd087..b2df0fae 100644
--- a/plugins/dynamic-security/clients.c
+++ b/plugins/dynamic-security/clients.c
@@ -108,139 +108,134 @@ void dynsec_clients__cleanup(struct dynsec__data *data)
 int dynsec_clients__config_load(struct dynsec__data *data, cJSON *tree)
 {
 	cJSON *j_clients, *j_client, *jtmp, *j_roles, *j_role;
-	cJSON *j_salt, *j_password, *j_iterations;
 	struct dynsec__client *client;
 	struct dynsec__role *role;
 	unsigned char *buf;
 	unsigned int buf_len;
 	int priority;
 	int iterations;
+	char *username;
 	size_t username_len;
+	char *salt;
+	char *password;
 
 	j_clients = cJSON_GetObjectItem(tree, "clients");
 	if(j_clients == NULL){
 		return 0;
 	}
 
 	if(cJSON_IsArray(j_clients) == false){
 		return 1;
 	}
 
 	cJSON_ArrayForEach(j_client, j_clients){
 		if(cJSON_IsObject(j_client) == true){
 			/* Username */
-			jtmp = cJSON_GetObjectItem(j_client, "username");
-			if(jtmp == NULL || !cJSON_IsString(jtmp)){
+			if(json_get_string(j_client, "username", &username, false) != MOSQ_ERR_SUCCESS){
 				continue;
 			}
-			username_len = strlen(jtmp->valuestring);
+			username_len = strlen(username);
 			if(username_len == 0){
 				continue;
 			}
+			if(dynsec_clients__find(data, username)){
+				continue;
+			}
 
 			client = mosquitto_calloc(1, sizeof(struct dynsec__client) + username_len + 1);
 			if(client == NULL){
 				return MOSQ_ERR_NOMEM;
 			}
-			strncpy(client->username, jtmp->valuestring, username_len);
+			strncpy(client->username, username, username_len);
 
 			jtmp = cJSON_GetObjectItem(j_client, "disabled");
 			if(jtmp && cJSON_IsBool(jtmp)){
 				client->disabled = cJSON_IsTrue(jtmp);
 			}
 
-			/* Salt */
-			j_salt = cJSON_GetObjectItem(j_client, "salt");
-			j_password = cJSON_GetObjectItem(j_client, "password");
-			j_iterations = cJSON_GetObjectItem(j_client, "iterations");
-
-			if(j_salt && cJSON_IsString(j_salt)
-					&& j_password && cJSON_IsString(j_password)
-					&& j_iterations && cJSON_IsNumber(j_iterations)){
+			json_get_int(j_client, "iterations", &iterations, 0, true);
+			if(json_get_string(j_client, "salt", &salt, false) == MOSQ_ERR_SUCCESS
+					&& json_get_string(j_client, "password", &password, false) == MOSQ_ERR_SUCCESS
+					&& iterations > 0){
 
-				iterations = (int)j_iterations->valuedouble;
-				if(iterations < 1){
-					mosquitto_free(client);
-					continue;
-				}else{
-					client->pw.iterations = iterations;
-				}
+				client->pw.iterations = iterations;
 
-				if(base64__decode(j_salt->valuestring, &buf, &buf_len) != MOSQ_ERR_SUCCESS
+				if(base64__decode(salt, &buf, &buf_len) != MOSQ_ERR_SUCCESS
 						|| buf_len > sizeof(client->pw.salt)){
 
 					mosquitto_free(client);
 					continue;
 				}
 				memcpy(client->pw.salt, buf, (size_t)buf_len);
 				client->pw.salt_len = (size_t)buf_len;
 				mosquitto_free(buf);
 
-				if(base64__decode(j_password->valuestring, &buf, &buf_len) != MOSQ_ERR_SUCCESS
+				if(base64__decode(password, &buf, &buf_len) != MOSQ_ERR_SUCCESS
 						|| buf_len != sizeof(client->pw.password_hash)){
 
+					mosquitto_free(buf);
 					mosquitto_free(client);
 					continue;
 				}
 				memcpy(client->pw.password_hash, buf, (size_t)buf_len);
 				mosquitto_free(buf);
 				client->pw.valid = true;
 			}else{
 				client->pw.valid = false;
 			}
 
 			/* Client id */
-			jtmp = cJSON_GetObjectItem(j_client, "clientid");
-			if(jtmp != NULL && cJSON_IsString(jtmp)){
-				client->clientid = mosquitto_strdup(jtmp->valuestring);
+			char *clientid;
+			if(json_get_string(j_client, "clientid", &clientid, false) == MOSQ_ERR_SUCCESS){
+				client->clientid = mosquitto_strdup(clientid);
 				if(client->clientid == NULL){
 					mosquitto_free(client);
 					continue;
 				}
 			}
 
 			/* Text name */
-			jtmp = cJSON_GetObjectItem(j_client, "textname");
-			if(jtmp != NULL && cJSON_IsString(jtmp)){
-				client->text_name = mosquitto_strdup(jtmp->valuestring);
+			char *textname;
+			if(json_get_string(j_client, "textname", &textname, false) == MOSQ_ERR_SUCCESS){
+				client->text_name = mosquitto_strdup(textname);
 				if(client->text_name == NULL){
 					mosquitto_free(client->clientid);
 					mosquitto_free(client);
 					continue;
 				}
 			}
 
 			/* Text description */
-			jtmp = cJSON_GetObjectItem(j_client, "textdescription");
-			if(jtmp != NULL && cJSON_IsString(jtmp)){
-				client->text_description = mosquitto_strdup(jtmp->valuestring);
+			char *textdescription;
+			if(json_get_string(j_client, "textdescription", &textdescription, false) == MOSQ_ERR_SUCCESS){
+				client->text_description = mosquitto_strdup(textdescription);
 				if(client->text_description == NULL){
 					mosquitto_free(client->text_name);
 					mosquitto_free(client->clientid);
 					mosquitto_free(client);
 					continue;
 				}
 			}
 
 			/* Roles */
 			j_roles = cJSON_GetObjectItem(j_client, "roles");
 			if(j_roles && cJSON_IsArray(j_roles)){
 				cJSON_ArrayForEach(j_role, j_roles){
 					if(cJSON_IsObject(j_role)){
-						jtmp = cJSON_GetObjectItem(j_role, "rolename");
-						if(jtmp && cJSON_IsString(jtmp)){
+						char *rolename;
+						if(json_get_string(j_role, "rolename", &rolename, false) == MOSQ_ERR_SUCCESS){
 							json_get_int(j_role, "priority", &priority, true, -1);
-							role = dynsec_roles__find(data, jtmp->valuestring);
+							role = dynsec_roles__find(data, rolename);
 							dynsec_rolelist__client_add(client, role, priority);
 						}
 					}
 				}
 			}
 
 			HASH_ADD(hh, data->clients, username, username_len, client);
 		}
 	}
 	HASH_SORT(data->clients, client_cmp);
 
 	return 0;
 }
@@ -319,149 +314,149 @@ int dynsec_clients__config_save(struct dynsec__data *data, cJSON *tree)
 int dynsec_clients__process_create(struct dynsec__data *data, struct mosquitto_control_cmd *cmd, struct mosquitto *context)
 {
 	char *username, *password, *clientid = NULL;
 	char *text_name, *text_description;
 	struct dynsec__client *client;
 	int rc;
-	cJSON *j_groups, *j_group, *jtmp;
+	cJSON *j_groups, *j_group;
 	int priority;
 	const char *admin_clientid, *admin_username;
 	size_t username_len;
 
 	if(json_get_string(cmd->j_command, "username", &username, false) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing username");
 		return MOSQ_ERR_INVAL;
 	}
 	username_len = strlen(username);
 	if(username_len == 0){
 		mosquitto_control_command_reply(cmd, "Empty username");
 		return MOSQ_ERR_INVAL;
 	}
 	if(mosquitto_validate_utf8(username, (int)username_len) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Username not valid UTF-8");
 		return MOSQ_ERR_INVAL;
 	}
 
 	if(json_get_string(cmd->j_command, "password", &password, true) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing password");
 		return MOSQ_ERR_INVAL;
 	}
 
 	if(json_get_string(cmd->j_command, "clientid", &clientid, true) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing client id");
 		return MOSQ_ERR_INVAL;
 	}
 	if(clientid && mosquitto_validate_utf8(clientid, (int)strlen(clientid)) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Client ID not valid UTF-8");
 		return MOSQ_ERR_INVAL;
 	}
 
 
 	if(json_get_string(cmd->j_command, "textname", &text_name, true) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing textname");
 		return MOSQ_ERR_INVAL;
 	}
 
 	if(json_get_string(cmd->j_command, "textdescription", &text_description, true) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing textdescription");
 		return MOSQ_ERR_INVAL;
 	}
 
 	client = dynsec_clients__find(data, username);
 	if(client){
 		mosquitto_control_command_reply(cmd, "Client already exists");
 		return MOSQ_ERR_SUCCESS;
 	}
 
 	client = mosquitto_calloc(1, sizeof(struct dynsec__client) + username_len + 1);
 	if(client == NULL){
 		mosquitto_control_command_reply(cmd, "Internal error");
 		return MOSQ_ERR_NOMEM;
 	}
 	strncpy(client->username, username, username_len);
 
 	if(text_name){
 		client->text_name = mosquitto_strdup(text_name);
 		if(client->text_name == NULL){
 			mosquitto_control_command_reply(cmd, "Internal error");
 			client__free_item(data, client);
 			return MOSQ_ERR_NOMEM;
 		}
 	}
 	if(text_description){
 		client->text_description = mosquitto_strdup(text_description);
 		if(client->text_description == NULL){
 			mosquitto_control_command_reply(cmd, "Internal error");
 			client__free_item(data, client);
 			return MOSQ_ERR_NOMEM;
 		}
 	}
 
 	if(password){
 		if(dynsec_auth__pw_hash(client, password, client->pw.password_hash, sizeof(client->pw.password_hash), true)){
 			mosquitto_control_command_reply(cmd, "Internal error");
 			client__free_item(data, client);
 			return MOSQ_ERR_NOMEM;
 		}
 		client->pw.valid = true;
 	}
 	if(clientid && strlen(clientid) > 0){
 		client->clientid = mosquitto_strdup(clientid);
 		if(client->clientid == NULL){
 			mosquitto_control_command_reply(cmd, "Internal error");
 			client__free_item(data, client);
 			return MOSQ_ERR_NOMEM;
 		}
 	}
 
 	rc = dynsec_rolelist__load_from_json(data, cmd->j_command, &client->rolelist);
 	if(rc == MOSQ_ERR_SUCCESS || rc == ERR_LIST_NOT_FOUND){
 	}else if(rc == MOSQ_ERR_NOT_FOUND){
 		mosquitto_control_command_reply(cmd, "Role not found");
 		client__free_item(data, client);
 		return MOSQ_ERR_INVAL;
 	}else{
 		if(rc == MOSQ_ERR_INVAL){
 			mosquitto_control_command_reply(cmd, "'roles' not an array or missing/invalid rolename");
 		}else{
 			mosquitto_control_command_reply(cmd, "Internal error");
 		}
 		client__free_item(data, client);
 		return MOSQ_ERR_INVAL;
 	}
 
 	/* Must add user before groups, otherwise adding groups will fail */
 	HASH_ADD_INORDER(hh, data->clients, username, username_len, client, client_cmp);
 
 	j_groups = cJSON_GetObjectItem(cmd->j_command, "groups");
 	if(j_groups && cJSON_IsArray(j_groups)){
 		cJSON_ArrayForEach(j_group, j_groups){
 			if(cJSON_IsObject(j_group)){
-				jtmp = cJSON_GetObjectItem(j_group, "groupname");
-				if(jtmp && cJSON_IsString(jtmp)){
+				char *groupname;
+				if(json_get_string(j_group, "groupname", &groupname, false) == MOSQ_ERR_SUCCESS){
 					json_get_int(j_group, "priority", &priority, true, -1);
-					rc = dynsec_groups__add_client(data, username, jtmp->valuestring, priority, false);
+					rc = dynsec_groups__add_client(data, username, groupname, priority, false);
 					if(rc == ERR_GROUP_NOT_FOUND){
 						mosquitto_control_command_reply(cmd, "Group not found");
 						client__free_item(data, client);
 						return MOSQ_ERR_INVAL;
 					}else if(rc != MOSQ_ERR_SUCCESS){
 						mosquitto_control_command_reply(cmd, "Internal error");
 						client__free_item(data, client);
 						return MOSQ_ERR_INVAL;
 					}
 				}
 			}
 		}
 	}
 
 	dynsec__config_batch_save(data);
 
 	mosquitto_control_command_reply(cmd, NULL);
 
 	admin_clientid = mosquitto_client_id(context);
 	admin_username = mosquitto_client_username(context);
 	mosquitto_log_printf(MOSQ_LOG_INFO, "dynsec: %s/%s | createClient | username=%s | password=%s",
 			admin_clientid, admin_username, username, password?"*****":"no password");
 
 	return MOSQ_ERR_SUCCESS;
 }
@@ -718,172 +713,172 @@ static void client__remove_all_roles(struct dynsec__client *client)
 int dynsec_clients__process_modify(struct dynsec__data *data, struct mosquitto_control_cmd *cmd, struct mosquitto *context)
 {
 	char *username;
 	char *clientid = NULL;
 	char *password = NULL;
 	char *text_name = NULL, *text_description = NULL;
 	bool have_clientid = false, have_text_name = false, have_text_description = false, have_rolelist = false, have_password = false;
 	struct dynsec__client *client;
 	struct dynsec__group *group;
 	struct dynsec__rolelist *rolelist = NULL;
 	char *str;
 	int rc;
 	int priority;
-	cJSON *j_group, *j_groups, *jtmp;
+	cJSON *j_group, *j_groups;
 	const char *admin_clientid, *admin_username;
 
 	if(json_get_string(cmd->j_command, "username", &username, false) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing username");
 		return MOSQ_ERR_INVAL;
 	}
 	if(mosquitto_validate_utf8(username, (int)strlen(username)) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Username not valid UTF-8");
 		return MOSQ_ERR_INVAL;
 	}
 
 	client = dynsec_clients__find(data, username);
 	if(client == NULL){
 		mosquitto_control_command_reply(cmd, "Client not found");
 		return MOSQ_ERR_INVAL;
 	}
 
 	if(json_get_string(cmd->j_command, "clientid", &str, false) == MOSQ_ERR_SUCCESS){
 		have_clientid = true;
 		if(str && strlen(str) > 0){
 			clientid = mosquitto_strdup(str);
 			if(clientid == NULL){
 				mosquitto_control_command_reply(cmd, "Internal error");
 				rc = MOSQ_ERR_NOMEM;
 				goto error;
 			}
 		}else{
 			clientid = NULL;
 		}
 	}
 
 	if(json_get_string(cmd->j_command, "password", &password, false) == MOSQ_ERR_SUCCESS){
 		if(strlen(password) > 0){
 			have_password = true;
 		}
 	}
 
 	if(json_get_string(cmd->j_command, "textname", &str, false) == MOSQ_ERR_SUCCESS){
 		have_text_name = true;
 		text_name = mosquitto_strdup(str);
 		if(text_name == NULL){
 			mosquitto_control_command_reply(cmd, "Internal error");
 			rc = MOSQ_ERR_NOMEM;
 			goto error;
 		}
 	}
 
 	if(json_get_string(cmd->j_command, "textdescription", &str, false) == MOSQ_ERR_SUCCESS){
 		have_text_description = true;
 		text_description = mosquitto_strdup(str);
 		if(text_description == NULL){
 			mosquitto_control_command_reply(cmd, "Internal error");
 			rc = MOSQ_ERR_NOMEM;
 			goto error;
 		}
 	}
 
 	rc = dynsec_rolelist__load_from_json(data, cmd->j_command, &rolelist);
 	if(rc == MOSQ_ERR_SUCCESS){
 		have_rolelist = true;
 	}else if(rc == ERR_LIST_NOT_FOUND){
 		/* There was no list in the JSON, so no modification */
 	}else if(rc == MOSQ_ERR_NOT_FOUND){
 		mosquitto_control_command_reply(cmd, "Role not found");
 		rc = MOSQ_ERR_INVAL;
 		goto error;
 	}else{
 		if(rc == MOSQ_ERR_INVAL){
 			mosquitto_control_command_reply(cmd, "'roles' not an array or missing/invalid rolename");
 		}else{
 			mosquitto_control_command_reply(cmd, "Internal error");
 		}
 		rc = MOSQ_ERR_INVAL;
 		goto error;
 	}
 
 	j_groups = cJSON_GetObjectItem(cmd->j_command, "groups");
 	if(j_groups && cJSON_IsArray(j_groups)){
 		/* Iterate through list to check all groups are valid */
 		cJSON_ArrayForEach(j_group, j_groups){
 			if(cJSON_IsObject(j_group)){
-				jtmp = cJSON_GetObjectItem(j_group, "groupname");
-				if(jtmp && cJSON_IsString(jtmp)){
-					group = dynsec_groups__find(data, jtmp->valuestring);
+				char *groupname;
+				if(json_get_string(j_group, "groupname", &groupname, false) == MOSQ_ERR_SUCCESS){
+					group = dynsec_groups__find(data, groupname);
 					if(group == NULL){
 						mosquitto_control_command_reply(cmd, "'groups' contains an object with a 'groupname' that does not exist");
 						rc = MOSQ_ERR_INVAL;
 						goto error;
 					}
 				}else{
 					mosquitto_control_command_reply(cmd, "'groups' contains an object with an invalid 'groupname'");
 					rc = MOSQ_ERR_INVAL;
 					goto error;
 				}
 			}
 		}
 
 		dynsec__remove_client_from_all_groups(data, username);
 		cJSON_ArrayForEach(j_group, j_groups){
 			if(cJSON_IsObject(j_group)){
-				jtmp = cJSON_GetObjectItem(j_group, "groupname");
-				if(jtmp && cJSON_IsString(jtmp)){
+				char *groupname;
+				if(json_get_string(j_group, "groupname", &groupname, false) == MOSQ_ERR_SUCCESS){
 					json_get_int(j_group, "priority", &priority, true, -1);
-					dynsec_groups__add_client(data, username, jtmp->valuestring, priority, false);
+					dynsec_groups__add_client(data, username, groupname, priority, false);
 				}
 			}
 		}
 	}
 
 	if(have_password){
 		/* FIXME - This is the one call that will result in modification on internal error - note that groups have already been modified */
 		rc = client__set_password(client, password);
 		if(rc != MOSQ_ERR_SUCCESS){
 			mosquitto_control_command_reply(cmd, "Internal error");
 			mosquitto_kick_client_by_username(username, false);
 			/* If this fails we have the situation that the password is set as
 			 * invalid, but the config isn't saved, so restarting the broker
 			 * *now* will mean the client can log in again. This might be
 			 * "good", but is inconsistent, so save the config to be
 			 * consistent. */
 			dynsec__config_batch_save(data);
 			rc = MOSQ_ERR_NOMEM;
 			goto error;
 		}
 	}
 
 	if(have_clientid){
 		mosquitto_free(client->clientid);
 		client->clientid = clientid;
 	}
 
 	if(have_text_name){
 		mosquitto_free(client->text_name);
 		client->text_name = text_name;
 	}
 
 	if(have_text_description){
 		mosquitto_free(client->text_description);
 		client->text_description = text_description;
 	}
 
 	if(have_rolelist){
 		client__remove_all_roles(client);
 		client__add_new_roles(client, rolelist);
 		dynsec_rolelist__cleanup(&rolelist);
 	}
 
 	dynsec__config_batch_save(data);
 	mosquitto_control_command_reply(cmd, NULL);
 
 	/* Enforce any changes */
 	dynsec_kicklist__add(data, username);
 
 	admin_clientid = mosquitto_client_id(context);
 	admin_username = mosquitto_client_username(context);
 	mosquitto_log_printf(MOSQ_LOG_INFO, "dynsec: %s/%s | modifyClient | username=%s",
 			admin_clientid, admin_username, username);
 	return MOSQ_ERR_SUCCESS;
diff --git a/plugins/dynamic-security/default_acl.c b/plugins/dynamic-security/default_acl.c
index 608023fe..e806ece2 100644
--- a/plugins/dynamic-security/default_acl.c
+++ b/plugins/dynamic-security/default_acl.c
@@ -35,42 +35,39 @@ Contributors:
 
 int dynsec__process_set_default_acl_access(struct dynsec__data *data, struct mosquitto_control_cmd *cmd, struct mosquitto *context)
 {
-	cJSON *j_actions, *j_action, *j_acltype, *j_allow;
+	cJSON *j_actions, *j_action;
 	bool allow;
 	const char *admin_clientid, *admin_username;
+	char *acltype;
 
 	j_actions = cJSON_GetObjectItem(cmd->j_command, "acls");
 	if(j_actions == NULL || !cJSON_IsArray(j_actions)){
 		mosquitto_control_command_reply(cmd, "Missing/invalid actions array");
 		return MOSQ_ERR_INVAL;
 	}
 
 	admin_clientid = mosquitto_client_id(context);
 	admin_username = mosquitto_client_username(context);
 
 	cJSON_ArrayForEach(j_action, j_actions){
-		j_acltype = cJSON_GetObjectItem(j_action, "acltype");
-		j_allow = cJSON_GetObjectItem(j_action, "allow");
-		if(j_acltype && cJSON_IsString(j_acltype)
-					&& j_allow && cJSON_IsBool(j_allow)){
+		if(json_get_string(j_action, "acltype", &acltype, false) == MOSQ_ERR_SUCCESS
+				&& json_get_bool(j_action, "allow", &allow, false, false) == MOSQ_ERR_SUCCESS){
 
-			allow = cJSON_IsTrue(j_allow);
-
-			if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_PUB_C_SEND)){
+			if(!strcasecmp(acltype, ACL_TYPE_PUB_C_SEND)){
 				data->default_access.publish_c_send = allow;
-			}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_PUB_C_RECV)){
+			}else if(!strcasecmp(acltype, ACL_TYPE_PUB_C_RECV)){
 				data->default_access.publish_c_recv = allow;
-			}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_SUB_GENERIC)){
+			}else if(!strcasecmp(acltype, ACL_TYPE_SUB_GENERIC)){
 				data->default_access.subscribe = allow;
-			}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_UNSUB_GENERIC)){
+			}else if(!strcasecmp(acltype, ACL_TYPE_UNSUB_GENERIC)){
 				data->default_access.unsubscribe = allow;
 			}
 			mosquitto_log_printf(MOSQ_LOG_INFO, "dynsec: %s/%s | setDefaultACLAccess | acltype=%s | allow=%s",
-					admin_clientid, admin_username, j_acltype->valuestring, allow?"true":"false");
+					admin_clientid, admin_username, acltype, allow?"true":"false");
 		}
 	}
 
 	dynsec__config_batch_save(data);
 	mosquitto_control_command_reply(cmd, NULL);
 	return MOSQ_ERR_SUCCESS;
 }
diff --git a/plugins/dynamic-security/groups.c b/plugins/dynamic-security/groups.c
index 37a67dc9..12e0315f 100644
--- a/plugins/dynamic-security/groups.c
+++ b/plugins/dynamic-security/groups.c
@@ -189,110 +189,116 @@ void dynsec_groups__cleanup(struct dynsec__data *data)
 int dynsec_groups__config_load(struct dynsec__data *data, cJSON *tree)
 {
 	cJSON *j_groups, *j_group;
-	cJSON *j_clientlist, *j_client, *j_username;
-	cJSON *j_roles, *j_role, *j_rolename;
+	cJSON *j_clientlist;
+	cJSON *j_roles;
 
 	struct dynsec__group *group;
 	struct dynsec__role *role;
-	char *str;
 	int priority;
+	char *textname, *textdescription;
+	char *groupname;
 	size_t groupname_len;
 
 	j_groups = cJSON_GetObjectItem(tree, "groups");
 	if(j_groups == NULL){
 		return 0;
 	}
 
 	if(cJSON_IsArray(j_groups) == false){
 		return 1;
 	}
 
 	cJSON_ArrayForEach(j_group, j_groups){
 		if(cJSON_IsObject(j_group) == true){
 			/* Group name */
-			if(json_get_string(j_group, "groupname", &str, false) != MOSQ_ERR_SUCCESS){
+			if(json_get_string(j_group, "groupname", &groupname, false) != MOSQ_ERR_SUCCESS){
 				continue;
 			}
-			groupname_len = strlen(str);
+			groupname_len = strlen(groupname);
 			if(groupname_len == 0){
 				continue;
 			}
+			if(dynsec_groups__find(data, groupname)){
+				continue;
+			}
 
 			group = mosquitto_calloc(1, sizeof(struct dynsec__group) + groupname_len + 1);
 			if(group == NULL){
 				return MOSQ_ERR_NOMEM;
 			}
-			strncpy(group->groupname, str, groupname_len+1);
+			strncpy(group->groupname, groupname, groupname_len+1);
 
 			/* Text name */
-			if(json_get_string(j_group, "textname", &str, false) == MOSQ_ERR_SUCCESS){
-				if(str){
-					group->text_name = strdup(str);
+			if(json_get_string(j_group, "textname", &textname, false) == MOSQ_ERR_SUCCESS){
+				if(textname){
+					group->text_name = strdup(textname);
 					if(group->text_name == NULL){
 						mosquitto_free(group);
 						continue;
 					}
 				}
 			}
 
 			/* Text description */
-			if(json_get_string(j_group, "textdescription", &str, false) == MOSQ_ERR_SUCCESS){
-				if(str){
-					group->text_description = strdup(str);
+			if(json_get_string(j_group, "textdescription", &textdescription, false) == MOSQ_ERR_SUCCESS){
+				if(textdescription){
+					group->text_description = strdup(textdescription);
 					if(group->text_description == NULL){
 						mosquitto_free(group->text_name);
 						mosquitto_free(group);
 						continue;
 					}
 				}
 			}
 
 			/* Roles */
 			j_roles = cJSON_GetObjectItem(j_group, "roles");
 			if(j_roles && cJSON_IsArray(j_roles)){
+				cJSON *j_role;
+
 				cJSON_ArrayForEach(j_role, j_roles){
 					if(cJSON_IsObject(j_role)){
-						j_rolename = cJSON_GetObjectItem(j_role, "rolename");
-						if(j_rolename && cJSON_IsString(j_rolename)){
+						char *rolename;
+						if(json_get_string(j_role, "rolename", &rolename, false) == MOSQ_ERR_SUCCESS){
 							json_get_int(j_role, "priority", &priority, true, -1);
-							role = dynsec_roles__find(data, j_rolename->valuestring);
+							role = dynsec_roles__find(data, rolename);
 							dynsec_rolelist__group_add(group, role, priority);
 						}
 					}
 				}
 			}
 
 			/* This must go before clients are loaded, otherwise the group won't be found */
 			HASH_ADD(hh, data->groups, groupname, groupname_len, group);
 
 			/* Clients */
 			j_clientlist = cJSON_GetObjectItem(j_group, "clients");
 			if(j_clientlist && cJSON_IsArray(j_clientlist)){
+				cJSON *j_client;
 				cJSON_ArrayForEach(j_client, j_clientlist){
 					if(cJSON_IsObject(j_client)){
-						j_username = cJSON_GetObjectItem(j_client, "username");
-						if(j_username && cJSON_IsString(j_username)){
+						char *username;
+						if(json_get_string(j_client, "username", &username, false) == MOSQ_ERR_SUCCESS){
 							json_get_int(j_client, "priority", &priority, true, -1);
-							dynsec_groups__add_client(data, j_username->valuestring, group->groupname, priority, false);
+							dynsec_groups__add_client(data, username, group->groupname, priority, false);
 						}
 					}
 				}
 			}
 		}
 	}
 	HASH_SORT(data->groups, group_cmp);
 
-	j_group = cJSON_GetObjectItem(tree, "anonymousGroup");
-	if(j_group && cJSON_IsString(j_group)){
-		data->anonymous_group = dynsec_groups__find(data, j_group->valuestring);
+	if(json_get_string(tree, "anonymousGroup", &groupname, false) == MOSQ_ERR_SUCCESS){
+		data->anonymous_group = dynsec_groups__find(data, groupname);
 	}
 
 	return 0;
 }
 
 
 /* ################################################################
  * #
  * # Config load and save
  * #
  * ################################################################ */
@@ -910,137 +916,136 @@ int dynsec_groups__process_remove_role(struct dynsec__data *data, struct mosquit
 int dynsec_groups__process_modify(struct dynsec__data *data, struct mosquitto_control_cmd *cmd, struct mosquitto *context)
 {
 	char *groupname = NULL;
 	char *text_name = NULL, *text_description = NULL;
 	struct dynsec__client *client = NULL;
 	struct dynsec__group *group = NULL;
 	struct dynsec__rolelist *rolelist = NULL;
 	bool have_text_name = false, have_text_description = false, have_rolelist = false;
 	char *str;
 	int rc;
 	int priority;
-	cJSON *j_client, *j_clients, *jtmp;
+	cJSON *j_client, *j_clients;
 	const char *admin_clientid, *admin_username;
+	char *username;
 
 	if(json_get_string(cmd->j_command, "groupname", &groupname, false) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing groupname");
 		return MOSQ_ERR_INVAL;
 	}
 	if(mosquitto_validate_utf8(groupname, (int)strlen(groupname)) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Group name not valid UTF-8");
 		return MOSQ_ERR_INVAL;
 	}
 
 	group = dynsec_groups__find(data, groupname);
 	if(group == NULL){
 		mosquitto_control_command_reply(cmd, "Group not found");
 		return MOSQ_ERR_INVAL;
 	}
 
 	if(json_get_string(cmd->j_command, "textname", &str, false) == MOSQ_ERR_SUCCESS){
 		have_text_name = true;
 		text_name = mosquitto_strdup(str);
 		if(text_name == NULL){
 			mosquitto_control_command_reply(cmd, "Internal error");
 			rc = MOSQ_ERR_NOMEM;
 			goto error;
 		}
 	}
 
 	if(json_get_string(cmd->j_command, "textdescription", &str, false) == MOSQ_ERR_SUCCESS){
 		have_text_description = true;
 		text_description = mosquitto_strdup(str);
 		if(text_description == NULL){
 			mosquitto_control_command_reply(cmd, "Internal error");
 			rc = MOSQ_ERR_NOMEM;
 			goto error;
 		}
 	}
 
 	rc = dynsec_rolelist__load_from_json(data, cmd->j_command, &rolelist);
 	if(rc == MOSQ_ERR_SUCCESS){
 		/* Apply changes below */
 		have_rolelist = true;
 	}else if(rc == ERR_LIST_NOT_FOUND){
 		/* There was no list in the JSON, so no modification */
 		rolelist = NULL;
 	}else if(rc == MOSQ_ERR_NOT_FOUND){
 		mosquitto_control_command_reply(cmd, "Role not found");
 		rc = MOSQ_ERR_INVAL;
 		goto error;
 	}else{
 		if(rc == MOSQ_ERR_INVAL){
 			mosquitto_control_command_reply(cmd, "'roles' not an array or missing/invalid rolename");
 		}else{
 			mosquitto_control_command_reply(cmd, "Internal error");
 		}
 		rc = MOSQ_ERR_INVAL;
 		goto error;
 	}
 
 	j_clients = cJSON_GetObjectItem(cmd->j_command, "clients");
 	if(j_clients && cJSON_IsArray(j_clients)){
 		/* Iterate over array to check clients are valid before proceeding */
 		cJSON_ArrayForEach(j_client, j_clients){
 			if(cJSON_IsObject(j_client)){
-				jtmp = cJSON_GetObjectItem(j_client, "username");
-				if(jtmp && cJSON_IsString(jtmp)){
-					client = dynsec_clients__find(data, jtmp->valuestring);
+				if(json_get_string(j_client, "username", &username, false) == MOSQ_ERR_SUCCESS){
+					client = dynsec_clients__find(data, username);
 					if(client == NULL){
 						mosquitto_control_command_reply(cmd, "'clients' contains an object with a 'username' that does not exist");
 						rc = MOSQ_ERR_INVAL;
 						goto error;
 					}
 				}else{
 					mosquitto_control_command_reply(cmd, "'clients' contains an object with an invalid 'username'");
 					rc = MOSQ_ERR_INVAL;
 					goto error;
 				}
 			}
 		}
 
 		/* Kick all clients in the *current* group */
 		group__kick_all(data, group);
 		dynsec__remove_all_clients_from_group(group);
 
 		/* Now we can add the new clients to the group */
 		cJSON_ArrayForEach(j_client, j_clients){
 			if(cJSON_IsObject(j_client)){
-				jtmp = cJSON_GetObjectItem(j_client, "username");
-				if(jtmp && cJSON_IsString(jtmp)){
+				if(json_get_string(j_client, "username", &username, false) == MOSQ_ERR_SUCCESS){
 					json_get_int(j_client, "priority", &priority, true, -1);
-					dynsec_groups__add_client(data, jtmp->valuestring, groupname, priority, false);
+					dynsec_groups__add_client(data, username, groupname, priority, false);
 				}
 			}
 		}
 	}
 
 	/* Apply remaining changes to group, note that user changes are already applied */
 	if(have_text_name){
 		mosquitto_free(group->text_name);
 		group->text_name = text_name;
 	}
 
 	if(have_text_description){
 		mosquitto_free(group->text_description);
 		group->text_description = text_description;
 	}
 
 	if(have_rolelist){
 		dynsec_rolelist__cleanup(&group->rolelist);
 		group->rolelist = rolelist;
 	}
 
 	/* And save */
 	dynsec__config_batch_save(data);
 
 	mosquitto_control_command_reply(cmd, NULL);
 
 	/* Enforce any changes - kick any clients in the *new* group */
 	group__kick_all(data, group);
 
 	admin_clientid = mosquitto_client_id(context);
 	admin_username = mosquitto_client_username(context);
 	mosquitto_log_printf(MOSQ_LOG_INFO, "dynsec: %s/%s | modifyGroup | groupname=%s",
 			admin_clientid, admin_username, groupname);
 
 	return MOSQ_ERR_SUCCESS;
diff --git a/plugins/dynamic-security/rolelist.c b/plugins/dynamic-security/rolelist.c
index 6a5f3664..1965eac4 100644
--- a/plugins/dynamic-security/rolelist.c
+++ b/plugins/dynamic-security/rolelist.c
@@ -171,33 +171,33 @@ int dynsec_rolelist__group_add(struct dynsec__group *group, struct dynsec__role
 
 int dynsec_rolelist__load_from_json(struct dynsec__data *data, cJSON *command, struct dynsec__rolelist **rolelist)
 {
-	cJSON *j_roles, *j_role, *j_rolename;
+	cJSON *j_roles, *j_role;
 	int priority;
 	struct dynsec__role *role;
+	char *rolename;
 
 	j_roles = cJSON_GetObjectItem(command, "roles");
 	if(j_roles){
 		if(cJSON_IsArray(j_roles)){
 			cJSON_ArrayForEach(j_role, j_roles){
-				j_rolename = cJSON_GetObjectItem(j_role, "rolename");
-				if(j_rolename && cJSON_IsString(j_rolename)){
+				if(json_get_string(j_role, "rolename", &rolename, false) == MOSQ_ERR_SUCCESS){
 					json_get_int(j_role, "priority", &priority, true, -1);
-					role = dynsec_roles__find(data, j_rolename->valuestring);
+					role = dynsec_roles__find(data, rolename);
 					if(role){
 						dynsec_rolelist__add(rolelist, role, priority);
 					}else{
 						dynsec_rolelist__cleanup(rolelist);
 						return MOSQ_ERR_NOT_FOUND;
 					}
 				}else{
 					return MOSQ_ERR_INVAL;
 				}
 			}
 			return MOSQ_ERR_SUCCESS;
 		}else{
 			return MOSQ_ERR_INVAL;
 		}
 	}else{
 		return ERR_LIST_NOT_FOUND;
 	}
 }
diff --git a/plugins/dynamic-security/roles.c b/plugins/dynamic-security/roles.c
index 8900bd9e..12168ba0 100644
--- a/plugins/dynamic-security/roles.c
+++ b/plugins/dynamic-security/roles.c
@@ -204,41 +204,44 @@ static int insert_acl_cmp(struct dynsec__acl *a, struct dynsec__acl *b)
 
 static int dynsec_roles__acl_load(cJSON *j_acls, const char *key, struct dynsec__acl **acllist)
 {
-	cJSON *j_acl, *j_type, *jtmp;
+	cJSON *j_acl, *jtmp;
 	struct dynsec__acl *acl;
 	size_t topic_len;
+	char *acltype;
+	char *topic;
 
 	cJSON_ArrayForEach(j_acl, j_acls){
-		j_type = cJSON_GetObjectItem(j_acl, "acltype");
-		if(j_type == NULL || !cJSON_IsString(j_type) || strcasecmp(j_type->valuestring, key) != 0){
+		if(json_get_string(j_acl, "acltype", &acltype, false) != MOSQ_ERR_SUCCESS){
+			continue;
+		}
+		if(strcasecmp(acltype, key) != 0){
 			continue;
 		}
-		jtmp = cJSON_GetObjectItem(j_acl, "topic");
-		if(!jtmp || !cJSON_IsString(jtmp)){
+		if(json_get_string(j_acl, "topic", &topic, false) != MOSQ_ERR_SUCCESS){
 			continue;
 		}
 
-		topic_len = strlen(jtmp->valuestring);
+		topic_len = strlen(topic);
 		if(topic_len == 0){
 			continue;
 		}
 
 		acl = mosquitto_calloc(1, sizeof(struct dynsec__acl) + topic_len + 1);
 		if(acl == NULL){
 			return 1;
 		}
-		strncpy(acl->topic, jtmp->valuestring, topic_len+1);
+		strncpy(acl->topic, topic, topic_len+1);
 
 		json_get_int(j_acl, "priority", &acl->priority, true, 0);
 		json_get_bool(j_acl, "allow", &acl->allow, true, false);
 
 		jtmp = cJSON_GetObjectItem(j_acl, "allow");
 		if(jtmp && cJSON_IsBool(jtmp)){
 			acl->allow = cJSON_IsTrue(jtmp);
 		}
 
 		HASH_ADD_INORDER(hh, *acllist, topic, topic_len, acl, insert_acl_cmp);
 	}
 
 	return 0;
 }
@@ -247,85 +250,88 @@ static int dynsec_roles__acl_load(cJSON *j_acls, const char *key, struct dynsec_
 int dynsec_roles__config_load(struct dynsec__data *data, cJSON *tree)
 {
 	cJSON *j_roles, *j_role, *jtmp, *j_acls;
 	struct dynsec__role *role;
 	size_t rolename_len;
 
 	j_roles = cJSON_GetObjectItem(tree, "roles");
 	if(j_roles == NULL){
 		return 0;
 	}
 
 	if(cJSON_IsArray(j_roles) == false){
 		return 1;
 	}
 
 	cJSON_ArrayForEach(j_role, j_roles){
 		if(cJSON_IsObject(j_role) == true){
 			/* Role name */
-			jtmp = cJSON_GetObjectItem(j_role, "rolename");
-			if(jtmp == NULL || !cJSON_IsString(jtmp)){
+			char *rolename;
+			if(json_get_string(j_role, "rolename", &rolename, false) != MOSQ_ERR_SUCCESS){
 				continue;
 			}
-			rolename_len = strlen(jtmp->valuestring);
+			rolename_len = strlen(rolename);
 			if(rolename_len == 0){
 				continue;
 			}
+			if(dynsec_roles__find(data, rolename)){
+				continue;
+			}
 
 			role = mosquitto_calloc(1, sizeof(struct dynsec__role) + rolename_len + 1);
 			if(role == NULL){
 				return MOSQ_ERR_NOMEM;
 			}
-			strncpy(role->rolename, jtmp->valuestring, rolename_len+1);
+			strncpy(role->rolename, rolename, rolename_len+1);
 
 			/* Text name */
-			jtmp = cJSON_GetObjectItem(j_role, "textname");
-			if(jtmp != NULL){
-				role->text_name = mosquitto_strdup(jtmp->valuestring);
+			char *textname;
+			if(json_get_string(j_role, "textname", &textname, false) == MOSQ_ERR_SUCCESS){
+				role->text_name = mosquitto_strdup(textname);
 				if(role->text_name == NULL){
 					mosquitto_free(role);
 					continue;
 				}
 			}
 
 			/* Text description */
-			jtmp = cJSON_GetObjectItem(j_role, "textdescription");
-			if(jtmp != NULL){
-				role->text_description = mosquitto_strdup(jtmp->valuestring);
+			char *textdescription;
+			if(json_get_string(j_role, "textdescription", &textdescription, false) == MOSQ_ERR_SUCCESS){
+				role->text_description = mosquitto_strdup(textdescription);
 				if(role->text_description == NULL){
 					mosquitto_free(role->text_name);
 					mosquitto_free(role);
 					continue;
 				}
 			}
 
 			/* Allow wildcard subs */
 			jtmp = cJSON_GetObjectItem(j_role, "allowwildcardsubs");
 			if(jtmp != NULL && cJSON_IsBool(jtmp)){
 				role->allow_wildcard_subs = cJSON_IsTrue(jtmp);
 			}else{
 				role->allow_wildcard_subs = true;
 			}
 
 			/* ACLs */
 			j_acls = cJSON_GetObjectItem(j_role, "acls");
 			if(j_acls && cJSON_IsArray(j_acls)){
 				if(dynsec_roles__acl_load(j_acls, ACL_TYPE_PUB_C_SEND, &role->acls.publish_c_send) != 0
 						|| dynsec_roles__acl_load(j_acls, ACL_TYPE_PUB_C_RECV, &role->acls.publish_c_recv) != 0
 						|| dynsec_roles__acl_load(j_acls, ACL_TYPE_SUB_LITERAL, &role->acls.subscribe_literal) != 0
 						|| dynsec_roles__acl_load(j_acls, ACL_TYPE_SUB_PATTERN, &role->acls.subscribe_pattern) != 0
 						|| dynsec_roles__acl_load(j_acls, ACL_TYPE_UNSUB_LITERAL, &role->acls.unsubscribe_literal) != 0
 						|| dynsec_roles__acl_load(j_acls, ACL_TYPE_UNSUB_PATTERN, &role->acls.unsubscribe_pattern) != 0
 						){
 
 					mosquitto_free(role);
 					continue;
 				}
 			}
 
 			HASH_ADD(hh, data->roles, rolename, rolename_len, role);
 		}
 	}
 	HASH_SORT(data->roles, role_cmp);
 
 	return 0;
 }
@@ -597,93 +603,92 @@ int dynsec_roles__process_list(struct dynsec__data *data, struct mosquitto_contr
 int dynsec_roles__process_add_acl(struct dynsec__data *data, struct mosquitto_control_cmd *cmd, struct mosquitto *context)
 {
 	char *rolename;
 	struct dynsec__role *role;
-	cJSON *j_acltype, *j_topic;
 	struct dynsec__acl **acllist, *acl;
 	int rc;
 	const char *admin_clientid, *admin_username;
+	char *topic;
 	size_t topic_len;
+	char *acltype;
 
 	if(json_get_string(cmd->j_command, "rolename", &rolename, false) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing rolename");
 		return MOSQ_ERR_INVAL;
 	}
 	if(mosquitto_validate_utf8(rolename, (int)strlen(rolename)) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Role name not valid UTF-8");
 		return MOSQ_ERR_INVAL;
 	}
 
 	role = dynsec_roles__find(data, rolename);
 	if(role == NULL){
 		mosquitto_control_command_reply(cmd, "Role not found");
 		return MOSQ_ERR_SUCCESS;
 	}
 
-	j_acltype = cJSON_GetObjectItem(cmd->j_command, "acltype");
-	if(j_acltype == NULL || !cJSON_IsString(j_acltype)){
+	if(json_get_string(cmd->j_command, "acltype", &acltype, false) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing acltype");
 		return MOSQ_ERR_SUCCESS;
 	}
-	if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_PUB_C_SEND)){
+	if(!strcasecmp(acltype, ACL_TYPE_PUB_C_SEND)){
 		acllist = &role->acls.publish_c_send;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_PUB_C_RECV)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_PUB_C_RECV)){
 		acllist = &role->acls.publish_c_recv;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_SUB_LITERAL)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_SUB_LITERAL)){
 		acllist = &role->acls.subscribe_literal;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_SUB_PATTERN)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_SUB_PATTERN)){
 		acllist = &role->acls.subscribe_pattern;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_UNSUB_LITERAL)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_UNSUB_LITERAL)){
 		acllist = &role->acls.unsubscribe_literal;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_UNSUB_PATTERN)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_UNSUB_PATTERN)){
 		acllist = &role->acls.unsubscribe_pattern;
 	}else{
 		mosquitto_control_command_reply(cmd, "Unknown acltype");
 		return MOSQ_ERR_SUCCESS;
 	}
 
-	j_topic = cJSON_GetObjectItem(cmd->j_command, "topic");
-	if(j_topic && cJSON_IsString(j_topic)){
-		topic_len = strlen(j_topic->valuestring);
-		if(mosquitto_validate_utf8(j_topic->valuestring, (int)topic_len) != MOSQ_ERR_SUCCESS){
+	if(json_get_string(cmd->j_command, "topic", &topic, false) == MOSQ_ERR_SUCCESS){
+		topic_len = strlen(topic);
+		if(mosquitto_validate_utf8(topic, (int)topic_len) != MOSQ_ERR_SUCCESS){
 			mosquitto_control_command_reply(cmd, "Topic not valid UTF-8");
 			return MOSQ_ERR_INVAL;
 		}
-		rc = mosquitto_sub_topic_check(j_topic->valuestring);
+		rc = mosquitto_sub_topic_check(topic);
 		if(rc != MOSQ_ERR_SUCCESS){
 			mosquitto_control_command_reply(cmd, "Invalid ACL topic");
 			return MOSQ_ERR_INVAL;
 		}
 	}else{
 		mosquitto_control_command_reply(cmd, "Invalid/missing topic");
 		return MOSQ_ERR_SUCCESS;
 	}
 
-	HASH_FIND(hh, *acllist, j_topic->valuestring, topic_len, acl);
+	HASH_FIND(hh, *acllist, topic, topic_len, acl);
 	if(acl){
 		mosquitto_control_command_reply(cmd, "ACL with this topic already exists");
 		return MOSQ_ERR_SUCCESS;
 	}
 
 	acl = mosquitto_calloc(1, sizeof(struct dynsec__acl) + topic_len + 1);
 	if(acl == NULL){
 		mosquitto_control_command_reply(cmd, "Internal error");
 		return MOSQ_ERR_SUCCESS;
 	}
-	strncpy(acl->topic, j_topic->valuestring, topic_len+1);
+	strncpy(acl->topic, topic, topic_len+1);
 
 	json_get_int(cmd->j_command, "priority", &acl->priority, true, 0);
 	json_get_bool(cmd->j_command, "allow", &acl->allow, true, false);
 
 	HASH_ADD_INORDER(hh, *acllist, topic, topic_len, acl, insert_acl_cmp);
 	dynsec__config_batch_save(data);
 	mosquitto_control_command_reply(cmd, NULL);
 
 	role__kick_all(data, role);
 
 	admin_clientid = mosquitto_client_id(context);
 	admin_username = mosquitto_client_username(context);
 	mosquitto_log_printf(MOSQ_LOG_INFO, "dynsec: %s/%s | addRoleACL | rolename=%s | acltype=%s | topic=%s | priority=%d | allow=%s",
-			admin_clientid, admin_username, rolename, j_acltype->valuestring, j_topic->valuestring, acl->priority, acl->allow?"true":"false");
+			admin_clientid, admin_username, rolename, acltype, topic, acl->priority, acl->allow?"true":"false");
 
 	return MOSQ_ERR_SUCCESS;
 }
@@ -692,80 +697,79 @@ int dynsec_roles__process_add_acl(struct dynsec__data *data, struct mosquitto_co
 int dynsec_roles__process_remove_acl(struct dynsec__data *data, struct mosquitto_control_cmd *cmd, struct mosquitto *context)
 {
 	char *rolename;
 	struct dynsec__role *role;
 	struct dynsec__acl **acllist, *acl;
 	char *topic;
-	cJSON *j_acltype;
 	int rc;
 	const char *admin_clientid, *admin_username;
+	char *acltype;
 
 	if(json_get_string(cmd->j_command, "rolename", &rolename, false) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing rolename");
 		return MOSQ_ERR_INVAL;
 	}
 	if(mosquitto_validate_utf8(rolename, (int)strlen(rolename)) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Role name not valid UTF-8");
 		return MOSQ_ERR_INVAL;
 	}
 
 	role = dynsec_roles__find(data, rolename);
 	if(role == NULL){
 		mosquitto_control_command_reply(cmd, "Role not found");
 		return MOSQ_ERR_SUCCESS;
 	}
 
-	j_acltype = cJSON_GetObjectItem(cmd->j_command, "acltype");
-	if(j_acltype == NULL || !cJSON_IsString(j_acltype)){
+	if(json_get_string(cmd->j_command, "acltype", &acltype, false) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid/missing acltype");
 		return MOSQ_ERR_SUCCESS;
 	}
-	if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_PUB_C_SEND)){
+	if(!strcasecmp(acltype, ACL_TYPE_PUB_C_SEND)){
 		acllist = &role->acls.publish_c_send;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_PUB_C_RECV)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_PUB_C_RECV)){
 		acllist = &role->acls.publish_c_recv;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_SUB_LITERAL)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_SUB_LITERAL)){
 		acllist = &role->acls.subscribe_literal;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_SUB_PATTERN)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_SUB_PATTERN)){
 		acllist = &role->acls.subscribe_pattern;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_UNSUB_LITERAL)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_UNSUB_LITERAL)){
 		acllist = &role->acls.unsubscribe_literal;
-	}else if(!strcasecmp(j_acltype->valuestring, ACL_TYPE_UNSUB_PATTERN)){
+	}else if(!strcasecmp(acltype, ACL_TYPE_UNSUB_PATTERN)){
 		acllist = &role->acls.unsubscribe_pattern;
 	}else{
 		mosquitto_control_command_reply(cmd, "Unknown acltype");
 		return MOSQ_ERR_SUCCESS;
 	}
 
 	if(json_get_string(cmd->j_command, "topic", &topic, false)){
 		mosquitto_control_command_reply(cmd, "Invalid/missing topic");
 		return MOSQ_ERR_SUCCESS;
 	}
 	if(mosquitto_validate_utf8(topic, (int)strlen(topic)) != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Topic not valid UTF-8");
 		return MOSQ_ERR_INVAL;
 	}
 	rc = mosquitto_sub_topic_check(topic);
 	if(rc != MOSQ_ERR_SUCCESS){
 		mosquitto_control_command_reply(cmd, "Invalid ACL topic");
 		return MOSQ_ERR_INVAL;
 	}
 
 	HASH_FIND(hh, *acllist, topic, strlen(topic), acl);
 	if(acl){
 		role__free_acl(acllist, acl);
 		dynsec__config_batch_save(data);
 		mosquitto_control_command_reply(cmd, NULL);
 
 		role__kick_all(data, role);
 
 		admin_clientid = mosquitto_client_id(context);
 		admin_username = mosquitto_client_username(context);
 		mosquitto_log_printf(MOSQ_LOG_INFO, "dynsec: %s/%s | removeRoleACL | rolename=%s | acltype=%s | topic=%s",
-				admin_clientid, admin_username, rolename, j_acltype->valuestring, topic);
+				admin_clientid, admin_username, rolename, acltype, topic);
 
 	}else{
 		mosquitto_control_command_reply(cmd, "ACL not found");
 	}
 
 	return MOSQ_ERR_SUCCESS;
 }
diff --git a/plugins/persist-sqlite/restore.c b/plugins/persist-sqlite/restore.c
index 49ea80f7..03f82ec8 100644
--- a/plugins/persist-sqlite/restore.c
+++ b/plugins/persist-sqlite/restore.c
@@ -15,13 +15,14 @@ SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
 Contributors:
    Roger Light - initial implementation and documentation.
 */
 
 #include <stdlib.h>
 #include <string.h>
 #include <sqlite3.h>
 #include <cjson/cJSON.h>
 
+#include "json_help.h"
 #include "mosquitto.h"
 #include "mosquitto_broker.h"
 #include "mqtt_protocol.h"
 #include "persist_sqlite.h"
@@ -58,118 +59,130 @@ static uint8_t hex2nibble(char c)
 static mosquitto_property *json_to_properties(const char *json)
 {
 	mosquitto_property *properties = NULL;
-	cJSON *array, *obj, *j_id, *j_value, *j_name;
+	cJSON *array, *obj, *j_value;
 	int propid, proptype;
 	size_t slen;
 
 	if(!json) return NULL;
 
 	array = cJSON_Parse(json);
 	if(!array) return NULL;
 	if(!cJSON_IsArray(array)){
 		cJSON_Delete(array);
 		return NULL;
 	}
 
 	cJSON_ArrayForEach(obj, array){
-		j_id = cJSON_GetObjectItem(obj, "identifier");
-		j_name = cJSON_GetObjectItem(obj, "name");
+		char *identifier;
+
+		json_get_string(obj, "identifier", &identifier, true);
 		j_value = cJSON_GetObjectItem(obj, "value");
 
-		if(!j_id || !cJSON_IsString(j_id) || !j_value){
+		if(!identifier || !j_value){
 			mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring property whilst restoring, invalid identifier / value");
 			continue;
 		}
-		if(mosquitto_string_to_property_info(j_id->valuestring, &propid, &proptype)){
+		if(mosquitto_string_to_property_info(identifier, &propid, &proptype)){
 			mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring property whilst restoring, unknown identifier");
 			continue;
 		}
 		switch(proptype){
 			case MQTT_PROP_TYPE_BYTE:
 				if(!cJSON_IsNumber(j_value)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is incorrect type", "byte");
 					continue;
 				}
 				if(mosquitto_property_add_byte(&properties, propid, (uint8_t)j_value->valueint)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Out of memory whilst restoring %s property", "byte");
 					continue;
 				}
 				break;
 			case MQTT_PROP_TYPE_INT16:
 				if(!cJSON_IsNumber(j_value)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is incorrect type", "int16");
 					continue;
 				}
 				if(mosquitto_property_add_int16(&properties, propid, (uint16_t)j_value->valueint)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Out of memory whilst restoring %s property", "int16");
 					continue;
 				}
 				break;
 			case MQTT_PROP_TYPE_INT32:
 				if(!cJSON_IsNumber(j_value)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is incorrect type", "int32");
 					continue;
 				}
 				if(mosquitto_property_add_int32(&properties, propid, (uint32_t)j_value->valueint)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Out of memory whilst restoring %s property", "int32");
 					continue;
 				}
 				break;
 			case MQTT_PROP_TYPE_VARINT:
 				if(!cJSON_IsNumber(j_value)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is incorrect type", "varint");
 					continue;
 				}
 				if(mosquitto_property_add_varint(&properties, propid, (uint32_t)j_value->valueint)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Out of memory whilst restoring %s property", "varint");
 					continue;
 				}
 				break;
 			case MQTT_PROP_TYPE_BINARY:
 				if(!cJSON_IsString(j_value)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is incorrect type", "binary");
 					continue;
 				}
-				slen = strlen(j_value->valuestring);
-				if(slen/2 > UINT16_MAX){
-					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is too large", "binary");
-					continue;
-				}
-				for(size_t i=0; i<slen; i+=2){
-					((uint8_t *)j_value->valuestring)[i/2] = (uint8_t)(hex2nibble(j_value->valuestring[i])<<4) + hex2nibble(j_value->valuestring[i+1]);
+				uint8_t *binstr = NULL;
+				uint16_t len = 0;
+
+				if(j_value->valuestring){
+					slen = strlen(j_value->valuestring);
+					if(slen/2 > UINT16_MAX){
+						mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is too large", "binary");
+						continue;
+					}
+					for(size_t i=0; i<slen; i+=2){
+						((uint8_t *)j_value->valuestring)[i/2] = (uint8_t)(hex2nibble(j_value->valuestring[i])<<4) + hex2nibble(j_value->valuestring[i+1]);
+					}
+					binstr = (uint8_t *)j_value->valuestring;
+					len = (uint16_t)slen/2;
 				}
-				if(mosquitto_property_add_binary(&properties, propid, (uint8_t *)j_value->valuestring, (uint16_t)(slen/2))){
+				if(mosquitto_property_add_binary(&properties, propid, binstr, len)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Out of memory whilst restoring %s property", "binary");
 					continue;
 				}
 				break;
 			case MQTT_PROP_TYPE_STRING:
 				if(!cJSON_IsString(j_value)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is incorrect type", "string");
 					continue;
 				}
 				if(mosquitto_property_add_string(&properties, propid, j_value->valuestring)){
 					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Out of memory whilst restoring %s property", "string");
 					continue;
 				}
 				break;
 			case MQTT_PROP_TYPE_STRING_PAIR:
-				if(!cJSON_IsString(j_value)){
-					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is incorrect type", "string pair");
-					continue;
-				}
-				if(!j_name || !cJSON_IsString(j_name)){
-					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring string pair property whilst restoring, name is missing or incorrect type");
-					continue;
-				}
-				if(mosquitto_property_add_string_pair(&properties, propid, j_name->valuestring, j_value->valuestring)){
-					mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Out of memory whilst restoring %s property", "string pair");
-					continue;
+				{
+					char *prop_name;
+
+					if(!cJSON_IsString(j_value)){
+						mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring %s property whilst restoring, value is incorrect type", "string pair");
+						continue;
+					}
+					if(json_get_string(obj, "name", &prop_name, false) != MOSQ_ERR_SUCCESS){
+						mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Ignoring string pair property whilst restoring, name is missing or incorrect type");
+						continue;
+					}
+					if(mosquitto_property_add_string_pair(&properties, propid, prop_name, j_value->valuestring)){
+						mosquitto_log_printf(MOSQ_LOG_WARNING, "Sqlite persistence: Out of memory whilst restoring %s property", "string pair");
+						continue;
+					}
 				}
 				break;
 		}
 	}
 	cJSON_Delete(array);
 
 	return properties;
 }
