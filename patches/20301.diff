commit 16f194c75e05381628ae2b9468fb8004dec9e176
Merge: 3f6779879c 1cccbb8ff1
Author: Nikita Popov <nikita.ppv@gmail.com>
Date:   Mon Jan 27 13:32:51 2020 +0100

    Merge branch 'PHP-7.4'
    
    * PHP-7.4:
      Fix bug #78323: Code 0 is returned on invalid options

diff --git a/ext/standard/basic_functions.c b/ext/standard/basic_functions.c
index 860c94acfb..f6d513f53d 100755
--- a/ext/standard/basic_functions.c
+++ b/ext/standard/basic_functions.c
@@ -1738,184 +1738,184 @@ static int parse_opts(char * opts, opt_struct ** result)
 /* {{{ proto array|false getopt(string options [, array longopts [, int &optind]])
    Get options from the command line argument list */
 PHP_FUNCTION(getopt)
 {
 	char *options = NULL, **argv = NULL;
 	char opt[2] = { '\0' };
 	char *optname;
 	int argc = 0, o;
 	size_t options_len = 0, len;
 	char *php_optarg = NULL;
 	int php_optind = 1;
 	zval val, *args = NULL, *p_longopts = NULL;
 	zval *zoptind = NULL;
 	size_t optname_len = 0;
 	opt_struct *opts, *orig_opts;
 
 	ZEND_PARSE_PARAMETERS_START(1, 3)
 		Z_PARAM_STRING(options, options_len)
 		Z_PARAM_OPTIONAL
 		Z_PARAM_ARRAY(p_longopts)
 		Z_PARAM_ZVAL(zoptind)
 	ZEND_PARSE_PARAMETERS_END();
 
 	/* Init zoptind to 1 */
 	if (zoptind) {
 		ZEND_TRY_ASSIGN_REF_LONG(zoptind, 1);
 	}
 
 	/* Get argv from the global symbol table. We calculate argc ourselves
 	 * in order to be on the safe side, even though it is also available
 	 * from the symbol table. */
 	if ((Z_TYPE(PG(http_globals)[TRACK_VARS_SERVER]) == IS_ARRAY || zend_is_auto_global_str(ZEND_STRL("_SERVER"))) &&
 		((args = zend_hash_find_ex_ind(Z_ARRVAL_P(&PG(http_globals)[TRACK_VARS_SERVER]), ZSTR_KNOWN(ZEND_STR_ARGV), 1)) != NULL ||
 		(args = zend_hash_find_ex_ind(&EG(symbol_table), ZSTR_KNOWN(ZEND_STR_ARGV), 1)) != NULL)
 	) {
 		int pos = 0;
 		zval *entry;
 
  		if (Z_TYPE_P(args) != IS_ARRAY) {
  			RETURN_FALSE;
  		}
  		argc = zend_hash_num_elements(Z_ARRVAL_P(args));
 
 		/* Attempt to allocate enough memory to hold all of the arguments
 		 * and a trailing NULL */
 		argv = (char **) safe_emalloc(sizeof(char *), (argc + 1), 0);
 
 		/* Iterate over the hash to construct the argv array. */
 		ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(args), entry) {
 			zend_string *tmp_arg_str;
 			zend_string *arg_str = zval_get_tmp_string(entry, &tmp_arg_str);
 
 			argv[pos++] = estrdup(ZSTR_VAL(arg_str));
 
 			zend_tmp_string_release(tmp_arg_str);
 		} ZEND_HASH_FOREACH_END();
 
 		/* The C Standard requires argv[argc] to be NULL - this might
 		 * keep some getopt implementations happy. */
 		argv[argc] = NULL;
 	} else {
 		/* Return false if we can't find argv. */
 		RETURN_FALSE;
 	}
 
 	len = parse_opts(options, &opts);
 
 	if (p_longopts) {
 		int count;
 		zval *entry;
 
 		count = zend_hash_num_elements(Z_ARRVAL_P(p_longopts));
 
 		/* the first <len> slots are filled by the one short ops
 		 * we now extend our array and jump to the new added structs */
 		opts = (opt_struct *) erealloc(opts, sizeof(opt_struct) * (len + count + 1));
 		orig_opts = opts;
 		opts += len;
 
 		memset(opts, 0, count * sizeof(opt_struct));
 
 		/* Iterate over the hash to construct the argv array. */
 		ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(p_longopts), entry) {
 			zend_string *tmp_arg_str;
 			zend_string *arg_str = zval_get_tmp_string(entry, &tmp_arg_str);
 
 			opts->need_param = 0;
 			opts->opt_name = estrdup(ZSTR_VAL(arg_str));
 			len = strlen(opts->opt_name);
 			if ((len > 0) && (opts->opt_name[len - 1] == ':')) {
 				opts->need_param++;
 				opts->opt_name[len - 1] = '\0';
 				if ((len > 1) && (opts->opt_name[len - 2] == ':')) {
 					opts->need_param++;
 					opts->opt_name[len - 2] = '\0';
 				}
 			}
 			opts->opt_char = 0;
 			opts++;
 
 			zend_tmp_string_release(tmp_arg_str);
 		} ZEND_HASH_FOREACH_END();
 	} else {
 		opts = (opt_struct*) erealloc(opts, sizeof(opt_struct) * (len + 1));
 		orig_opts = opts;
 		opts += len;
 	}
 
 	/* php_getopt want to identify the last param */
 	opts->opt_char   = '-';
 	opts->need_param = 0;
 	opts->opt_name   = NULL;
 
 	/* Initialize the return value as an array. */
 	array_init(return_value);
 
 	/* after our pointer arithmetic jump back to the first element */
 	opts = orig_opts;
 
 	while ((o = php_getopt(argc, argv, opts, &php_optarg, &php_optind, 0, 1)) != -1) {
 		/* Skip unknown arguments. */
-		if (o == '?') {
+		if (o == PHP_GETOPT_INVALID_ARG) {
 			continue;
 		}
 
 		/* Prepare the option character and the argument string. */
 		if (o == 0) {
 			optname = opts[php_optidx].opt_name;
 		} else {
 			if (o == 1) {
 				o = '-';
 			}
 			opt[0] = o;
 			optname = opt;
 		}
 
 		if (php_optarg != NULL) {
 			/* keep the arg as binary, since the encoding is not known */
 			ZVAL_STRING(&val, php_optarg);
 		} else {
 			ZVAL_FALSE(&val);
 		}
 
 		/* Add this option / argument pair to the result hash. */
 		optname_len = strlen(optname);
 		if (!(optname_len > 1 && optname[0] == '0') && is_numeric_string(optname, optname_len, NULL, NULL, 0) == IS_LONG) {
 			/* numeric string */
 			int optname_int = atoi(optname);
 			if ((args = zend_hash_index_find(Z_ARRVAL_P(return_value), optname_int)) != NULL) {
 				if (Z_TYPE_P(args) != IS_ARRAY) {
 					convert_to_array_ex(args);
 				}
 				zend_hash_next_index_insert(Z_ARRVAL_P(args), &val);
 			} else {
 				zend_hash_index_update(Z_ARRVAL_P(return_value), optname_int, &val);
 			}
 		} else {
 			/* other strings */
 			if ((args = zend_hash_str_find(Z_ARRVAL_P(return_value), optname, strlen(optname))) != NULL) {
 				if (Z_TYPE_P(args) != IS_ARRAY) {
 					convert_to_array_ex(args);
 				}
 				zend_hash_next_index_insert(Z_ARRVAL_P(args), &val);
 			} else {
 				zend_hash_str_add(Z_ARRVAL_P(return_value), optname, strlen(optname), &val);
 			}
 		}
 
 		php_optarg = NULL;
 	}
 
 	/* Set zoptind to php_optind */
 	if (zoptind) {
 		ZEND_TRY_ASSIGN_REF_LONG(zoptind, php_optind);
 	}
 
 	free_longopts(orig_opts);
 	efree(orig_opts);
 	free_argv(argv, argc);
 }
 /* }}} */
 
 /* {{{ proto void flush(void)
    Flush the output buffer */
diff --git a/main/getopt.c b/main/getopt.c
index fc96ad7e08..2160a6f4fe 100644
--- a/main/getopt.c
+++ b/main/getopt.c
@@ -24,28 +24,29 @@
 #define OPTERRNF (2)
 #define OPTERRARG (3)
 
+// Print error message to stderr and return -2 to distinguish it from '?' command line option.
 static int php_opt_error(int argc, char * const *argv, int oint, int optchr, int err, int show_err) /* {{{ */
 {
 	if (show_err)
 	{
 		fprintf(stderr, "Error in argument %d, char %d: ", oint, optchr+1);
 		switch(err)
 		{
 		case OPTERRCOLON:
 			fprintf(stderr, ": in flags\n");
 			break;
 		case OPTERRNF:
 			fprintf(stderr, "option not found %c\n", argv[oint][optchr]);
 			break;
 		case OPTERRARG:
 			fprintf(stderr, "no argument for option %c\n", argv[oint][optchr]);
 			break;
 		default:
 			fprintf(stderr, "unknown\n");
 			break;
 		}
 	}
-	return('?');
+	return PHP_GETOPT_INVALID_ARG;
 }
 /* }}} */
 
diff --git a/main/php_getopt.h b/main/php_getopt.h
index 960def30b5..c68d3969c4 100644
--- a/main/php_getopt.h
+++ b/main/php_getopt.h
@@ -33,4 +33,7 @@ extern PHPAPI int php_optidx;
 PHPAPI int php_getopt(int argc, char* const *argv, const opt_struct opts[], char **optarg, int *optind, int show_err, int arg_start);
 END_EXTERN_C()
 
+/* php_getopt will return this value if there is an error in arguments */
+#define PHP_GETOPT_INVALID_ARG (-2)
+
 #endif
diff --git a/sapi/cgi/cgi_main.c b/sapi/cgi/cgi_main.c
index 10f92d9fd3..2cff48fc61 100644
--- a/sapi/cgi/cgi_main.c
+++ b/sapi/cgi/cgi_main.c
@@ -1947,758 +1947,762 @@ manual page for CGI security</a>.</p>\n\
 <p>For more information about changing this behaviour or re-enabling this webserver,\n\
 consult the installation file that came with this distribution, or visit \n\
 <a href=\"http://php.net/install.windows\">the manual page</a>.</p>\n");
 			} zend_catch {
 			} zend_end_try();
 #if defined(ZTS) && !defined(PHP_DEBUG)
 			/* XXX we're crashing here in msvc6 debug builds at
 			 * php_message_handler_for_zend:839 because
 			 * SG(request_info).path_translated is an invalid pointer.
 			 * It still happens even though I set it to null, so something
 			 * weird is going on.
 			 */
 			tsrm_shutdown();
 #endif
 			free(bindpath);
 			return FAILURE;
 		}
 	}
 
 #ifndef HAVE_ATTRIBUTE_WEAK
 	fcgi_set_logger(fcgi_log);
 #endif
 
 	if (bindpath) {
 		int backlog = 128;
 		if (getenv("PHP_FCGI_BACKLOG")) {
 			backlog = atoi(getenv("PHP_FCGI_BACKLOG"));
 		}
 		fcgi_fd = fcgi_listen(bindpath, backlog);
 		if (fcgi_fd < 0) {
 			fprintf(stderr, "Couldn't create FastCGI listen socket on port %s\n", bindpath);
 #ifdef ZTS
 			tsrm_shutdown();
 #endif
 			return FAILURE;
 		}
 		fastcgi = fcgi_is_fastcgi();
 	}
 
 	/* make php call us to get _ENV vars */
 	php_php_import_environment_variables = php_import_environment_variables;
 	php_import_environment_variables = cgi_php_import_environment_variables;
 
 	if (fastcgi) {
 		/* How many times to run PHP scripts before dying */
 		if (getenv("PHP_FCGI_MAX_REQUESTS")) {
 			max_requests = atoi(getenv("PHP_FCGI_MAX_REQUESTS"));
 			if (max_requests < 0) {
 				fprintf(stderr, "PHP_FCGI_MAX_REQUESTS is not valid\n");
 				return FAILURE;
 			}
 		}
 
 		/* library is already initialized, now init our request */
 		request = fcgi_init_request(fcgi_fd, NULL, NULL, NULL);
 
 		/* Pre-fork or spawn, if required */
 		if (getenv("PHP_FCGI_CHILDREN")) {
 			char * children_str = getenv("PHP_FCGI_CHILDREN");
 			children = atoi(children_str);
 			if (children < 0) {
 				fprintf(stderr, "PHP_FCGI_CHILDREN is not valid\n");
 				return FAILURE;
 			}
 			fcgi_set_mgmt_var("FCGI_MAX_CONNS", sizeof("FCGI_MAX_CONNS")-1, children_str, strlen(children_str));
 			/* This is the number of concurrent requests, equals FCGI_MAX_CONNS */
 			fcgi_set_mgmt_var("FCGI_MAX_REQS",  sizeof("FCGI_MAX_REQS")-1,  children_str, strlen(children_str));
 		} else {
 #ifdef PHP_WIN32
 			/* If this env var is set, the process was invoked as a child. Let
 				it show the original PHP_FCGI_CHILDREN value, while don't care
 				otherwise. */
 			char * children_str = getenv("PHP_FCGI_CHILDREN_FOR_KID");
 			if (children_str) {
 				char putenv_buf[sizeof("PHP_FCGI_CHILDREN")+5];
 
 				snprintf(putenv_buf, sizeof(putenv_buf), "%s=%s", "PHP_FCGI_CHILDREN", children_str);
 				putenv(putenv_buf);
 				putenv("PHP_FCGI_CHILDREN_FOR_KID=");
 
 				SetEnvironmentVariable("PHP_FCGI_CHILDREN", children_str);
 				SetEnvironmentVariable("PHP_FCGI_CHILDREN_FOR_KID", NULL);
 			}
 #endif
 			fcgi_set_mgmt_var("FCGI_MAX_CONNS", sizeof("FCGI_MAX_CONNS")-1, "1", sizeof("1")-1);
 			fcgi_set_mgmt_var("FCGI_MAX_REQS",  sizeof("FCGI_MAX_REQS")-1,  "1", sizeof("1")-1);
 		}
 
 #ifndef PHP_WIN32
 		if (children) {
 			int running = 0;
 			pid_t pid;
 
 			/* Create a process group for ourself & children */
 			setsid();
 			pgroup = getpgrp();
 #ifdef DEBUG_FASTCGI
 			fprintf(stderr, "Process group %d\n", pgroup);
 #endif
 
 			/* Set up handler to kill children upon exit */
 			act.sa_flags = 0;
 			act.sa_handler = fastcgi_cleanup;
 			if (sigaction(SIGTERM, &act, &old_term) ||
 				sigaction(SIGINT,  &act, &old_int)  ||
 				sigaction(SIGQUIT, &act, &old_quit)
 			) {
 				perror("Can't set signals");
 				exit(1);
 			}
 
 			if (fcgi_in_shutdown()) {
 				goto parent_out;
 			}
 
 			while (parent) {
 				do {
 #ifdef DEBUG_FASTCGI
 					fprintf(stderr, "Forking, %d running\n", running);
 #endif
 					pid = fork();
 					switch (pid) {
 					case 0:
 						/* One of the children.
 						 * Make sure we don't go round the
 						 * fork loop any more
 						 */
 						parent = 0;
 
 						/* don't catch our signals */
 						sigaction(SIGTERM, &old_term, 0);
 						sigaction(SIGQUIT, &old_quit, 0);
 						sigaction(SIGINT,  &old_int,  0);
 						zend_signal_init();
 						break;
 					case -1:
 						perror("php (pre-forking)");
 						exit(1);
 						break;
 					default:
 						/* Fine */
 						running++;
 						break;
 					}
 				} while (parent && (running < children));
 
 				if (parent) {
 #ifdef DEBUG_FASTCGI
 					fprintf(stderr, "Wait for kids, pid %d\n", getpid());
 #endif
 					parent_waiting = 1;
 					while (1) {
 						if (wait(&status) >= 0) {
 							running--;
 							break;
 						} else if (exit_signal) {
 							break;
 						}
 					}
 					if (exit_signal) {
 #if 0
 						while (running > 0) {
 							while (wait(&status) < 0) {
 							}
 							running--;
 						}
 #endif
 						goto parent_out;
 					}
 				}
 			}
 		} else {
 			parent = 0;
 			zend_signal_init();
 		}
 
 #else
 		if (children) {
 			wchar_t *cmd_line_tmp, cmd_line[PHP_WIN32_IOUTIL_MAXPATHLEN];
 			size_t cmd_line_len;
 			char kid_buf[16];
 			int i;
 
 			ZeroMemory(&kid_cgi_ps, sizeof(kid_cgi_ps));
 			kids = children < WIN32_MAX_SPAWN_CHILDREN ? children : WIN32_MAX_SPAWN_CHILDREN;
 
 			InitializeCriticalSection(&cleanup_lock);
 			SetConsoleCtrlHandler(fastcgi_cleanup, TRUE);
 
 			/* kids will inherit the env, don't let them spawn */
 			SetEnvironmentVariable("PHP_FCGI_CHILDREN", NULL);
 			/* instead, set a temporary env var, so then the child can read and
 				show the actual setting correctly. */
 			snprintf(kid_buf, 16, "%d", children);
 			SetEnvironmentVariable("PHP_FCGI_CHILDREN_FOR_KID", kid_buf);
 
 			/* The current command line is used as is. This should normally be no issue,
 				even if there were some I/O redirection. If some issues turn out, an
 				extra parsing might be needed here. */
 			cmd_line_tmp = GetCommandLineW();
 			if (!cmd_line_tmp) {
 				DWORD err = GetLastError();
 				char *err_text = php_win32_error_to_msg(err);
 
 				fprintf(stderr, "unable to get current command line: [0x%08lx]: %s\n", err, err_text);
 				php_win32_error_msg_free(err_text);
 
 				goto parent_out;
 			}
 
 			cmd_line_len = wcslen(cmd_line_tmp);
 			if (cmd_line_len > sizeof(cmd_line) - 1) {
 				fprintf(stderr, "command line is too long\n");
 				goto parent_out;
 			}
 			memmove(cmd_line, cmd_line_tmp, (cmd_line_len + 1)*sizeof(wchar_t));
 
 			job = CreateJobObject(NULL, NULL);
 			if (!job) {
 				DWORD err = GetLastError();
 				char *err_text = php_win32_error_to_msg(err);
 
 				fprintf(stderr, "unable to create job object: [0x%08lx]: %s\n", err, err_text);
 
 				php_win32_error_msg_free(err_text);
 
 				goto parent_out;
 			}
 
 			job_info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
 			if (!SetInformationJobObject(job, JobObjectExtendedLimitInformation, &job_info, sizeof(job_info))) {
 				DWORD err = GetLastError();
 				char *err_text = php_win32_error_to_msg(err);
 
 				fprintf(stderr, "unable to configure job object: [0x%08lx]: %s\n", err, err_text);
 				php_win32_error_msg_free(err_text);
 			}
 
 			while (parent) {
 				EnterCriticalSection(&cleanup_lock);
 				if (cleaning_up) {
 					goto parent_loop_end;
 				}
 				LeaveCriticalSection(&cleanup_lock);
 
 				i = kids;
 				while (0 < i--) {
 					DWORD status;
 
 					if (NULL != kid_cgi_ps[i]) {
 						if(!GetExitCodeProcess(kid_cgi_ps[i], &status) || status != STILL_ACTIVE) {
 							CloseHandle(kid_cgi_ps[i]);
 							kid_cgi_ps[i] = NULL;
 						}
 					}
 				}
 
 				i = kids;
 				while (0 < i--) {
 					PROCESS_INFORMATION pi;
 					STARTUPINFOW si;
 
 					if (NULL != kid_cgi_ps[i]) {
 						continue;
 					}
 
 					ZeroMemory(&si, sizeof(si));
 					si.cb = sizeof(si);
 					ZeroMemory(&pi, sizeof(pi));
 
 					si.dwFlags = STARTF_USESTDHANDLES;
 					si.hStdOutput = INVALID_HANDLE_VALUE;
 					si.hStdInput  = (HANDLE)_get_osfhandle(fcgi_fd);
 					si.hStdError  = INVALID_HANDLE_VALUE;
 
 					if (CreateProcessW(NULL, cmd_line, NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {
 						kid_cgi_ps[i] = pi.hProcess;
 						if (!AssignProcessToJobObject(job, pi.hProcess)) {
 							DWORD err = GetLastError();
 							char *err_text = php_win32_error_to_msg(err);
 
 							fprintf(stderr, "unable to assign child process to job object: [0x%08lx]: %s\n", err, err_text);
 							php_win32_error_msg_free(err_text);
 						}
 						CloseHandle(pi.hThread);
 					} else {
 						DWORD err = GetLastError();
 						char *err_text = php_win32_error_to_msg(err);
 
 						kid_cgi_ps[i] = NULL;
 
 						fprintf(stderr, "unable to spawn: [0x%08lx]: %s\n", err, err_text);
 						php_win32_error_msg_free(err_text);
 					}
 				}
 
 				WaitForMultipleObjects(kids, kid_cgi_ps, FALSE, INFINITE);
 			}
 
 parent_loop_end:
 			/* restore my env */
 			SetEnvironmentVariable("PHP_FCGI_CHILDREN", kid_buf);
 
 			DeleteCriticalSection(&cleanup_lock);
 
 			goto parent_out;
 		} else {
 			parent = 0;
 		}
 #endif /* WIN32 */
 	}
 
 	zend_first_try {
 		while (!skip_getopt && (c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 1, 2)) != -1) {
 			switch (c) {
 				case 'T':
 					benchmark = 1;
 					{
 						char *comma = strchr(php_optarg, ',');
 						if (comma) {
 							warmup_repeats = atoi(php_optarg);
 							repeats = atoi(comma + 1);
 #ifdef HAVE_VALGRIND
 							if (warmup_repeats > 0) {
 								CALLGRIND_STOP_INSTRUMENTATION;
 							}
 #endif
 						} else {
 							repeats = atoi(php_optarg);
 						}
 					}
 #ifdef HAVE_GETTIMEOFDAY
 					gettimeofday(&start, NULL);
 #else
 					time(&start);
 #endif
 					break;
 				case 'h':
 				case '?':
+				case PHP_GETOPT_INVALID_ARG:
 					if (request) {
 						fcgi_destroy_request(request);
 					}
 					fcgi_shutdown();
 					no_headers = 1;
 					SG(headers_sent) = 1;
 					php_cgi_usage(argv[0]);
 					php_output_end_all();
 					exit_status = 0;
+					if (c == PHP_GETOPT_INVALID_ARG) {
+						exit_status = 1;
+					}
 					goto out;
 			}
 		}
 		php_optind = orig_optind;
 		php_optarg = orig_optarg;
 
 		/* start of FAST CGI loop */
 		/* Initialise FastCGI request structure */
 #ifdef PHP_WIN32
 		/* attempt to set security impersonation for fastcgi
 		 * will only happen on NT based OS, others will ignore it. */
 		if (fastcgi && CGIG(impersonate)) {
 			fcgi_impersonate();
 		}
 #endif
 		while (!fastcgi || fcgi_accept_request(request) >= 0) {
 			SG(server_context) = fastcgi ? (void *)request : (void *) 1;
 			init_request_info(request);
 
 			if (!cgi && !fastcgi) {
 				while ((c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 0, 2)) != -1) {
 					switch (c) {
 
 						case 'a':	/* interactive mode */
 							printf("Interactive mode enabled\n\n");
 							break;
 
 						case 'C': /* don't chdir to the script directory */
 							SG(options) |= SAPI_OPTION_NO_CHDIR;
 							break;
 
 						case 'e': /* enable extended info output */
 							CG(compiler_options) |= ZEND_COMPILE_EXTENDED_INFO;
 							break;
 
 						case 'f': /* parse file */
 							if (script_file) {
 								efree(script_file);
 							}
 							script_file = estrdup(php_optarg);
 							no_headers = 1;
 							break;
 
 						case 'i': /* php info & quit */
 							if (script_file) {
 								efree(script_file);
 							}
 							if (php_request_startup() == FAILURE) {
 								SG(server_context) = NULL;
 								php_module_shutdown();
 								free(bindpath);
 								return FAILURE;
 							}
 							if (no_headers) {
 								SG(headers_sent) = 1;
 								SG(request_info).no_headers = 1;
 							}
 							php_print_info(0xFFFFFFFF);
 							php_request_shutdown((void *) 0);
 							fcgi_shutdown();
 							exit_status = 0;
 							goto out;
 
 						case 'l': /* syntax check mode */
 							no_headers = 1;
 							behavior = PHP_MODE_LINT;
 							break;
 
 						case 'm': /* list compiled in modules */
 							if (script_file) {
 								efree(script_file);
 							}
 							SG(headers_sent) = 1;
 							php_printf("[PHP Modules]\n");
 							print_modules();
 							php_printf("\n[Zend Modules]\n");
 							print_extensions();
 							php_printf("\n");
 							php_output_end_all();
 							fcgi_shutdown();
 							exit_status = 0;
 							goto out;
 
 						case 'q': /* do not generate HTTP headers */
 							no_headers = 1;
 							break;
 
 						case 'v': /* show php version & quit */
 							if (script_file) {
 								efree(script_file);
 							}
 							no_headers = 1;
 							if (php_request_startup() == FAILURE) {
 								SG(server_context) = NULL;
 								php_module_shutdown();
 								free(bindpath);
 								return FAILURE;
 							}
 							SG(headers_sent) = 1;
 							SG(request_info).no_headers = 1;
 #if ZEND_DEBUG
 							php_printf("PHP %s (%s) (built: %s %s) (DEBUG)\nCopyright (c) The PHP Group\n%s", PHP_VERSION, sapi_module.name, __DATE__, __TIME__, get_zend_version());
 #else
 							php_printf("PHP %s (%s) (built: %s %s)\nCopyright (c) The PHP Group\n%s", PHP_VERSION, sapi_module.name, __DATE__, __TIME__, get_zend_version());
 #endif
 							php_request_shutdown((void *) 0);
 							fcgi_shutdown();
 							exit_status = 0;
 							goto out;
 
 						case 'w':
 							behavior = PHP_MODE_STRIP;
 							break;
 
 						case 'z': /* load extension file */
 							zend_load_extension(php_optarg);
 							break;
 
 						default:
 							break;
 					}
 				}
 
 				if (script_file) {
 					/* override path_translated if -f on command line */
 					if (SG(request_info).path_translated) efree(SG(request_info).path_translated);
 					SG(request_info).path_translated = script_file;
 					/* before registering argv to module exchange the *new* argv[0] */
 					/* we can achieve this without allocating more memory */
 					SG(request_info).argc = argc - (php_optind - 1);
 					SG(request_info).argv = &argv[php_optind - 1];
 					SG(request_info).argv[0] = script_file;
 				} else if (argc > php_optind) {
 					/* file is on command line, but not in -f opt */
 					if (SG(request_info).path_translated) efree(SG(request_info).path_translated);
 					SG(request_info).path_translated = estrdup(argv[php_optind]);
 					/* arguments after the file are considered script args */
 					SG(request_info).argc = argc - php_optind;
 					SG(request_info).argv = &argv[php_optind];
 				}
 
 				if (no_headers) {
 					SG(headers_sent) = 1;
 					SG(request_info).no_headers = 1;
 				}
 
 				/* all remaining arguments are part of the query string
 				 * this section of code concatenates all remaining arguments
 				 * into a single string, separating args with a &
 				 * this allows command lines like:
 				 *
 				 *  test.php v1=test v2=hello+world!
 				 *  test.php "v1=test&v2=hello world!"
 				 *  test.php v1=test "v2=hello world!"
 				*/
 				if (!SG(request_info).query_string && argc > php_optind) {
 					size_t slen = strlen(PG(arg_separator).input);
 					len = 0;
 					for (i = php_optind; i < argc; i++) {
 						if (i < (argc - 1)) {
 							len += strlen(argv[i]) + slen;
 						} else {
 							len += strlen(argv[i]);
 						}
 					}
 
 					len += 2;
 					s = malloc(len);
 					*s = '\0';			/* we are pretending it came from the environment  */
 					for (i = php_optind; i < argc; i++) {
 						strlcat(s, argv[i], len);
 						if (i < (argc - 1)) {
 							strlcat(s, PG(arg_separator).input, len);
 						}
 					}
 					SG(request_info).query_string = s;
 					free_query_string = 1;
 				}
 			} /* end !cgi && !fastcgi */
 
 			/*
 				we never take stdin if we're (f)cgi, always
 				rely on the web server giving us the info
 				we need in the environment.
 			*/
 			if (SG(request_info).path_translated || cgi || fastcgi) {
 				zend_stream_init_filename(&file_handle, SG(request_info).path_translated);
 			} else {
 				zend_stream_init_fp(&file_handle, stdin, "Standard input code");
 			}
 
 			/* request startup only after we've done all we can to
 			 * get path_translated */
 			if (php_request_startup() == FAILURE) {
 				if (fastcgi) {
 					fcgi_finish_request(request, 1);
 				}
 				SG(server_context) = NULL;
 				php_module_shutdown();
 				return FAILURE;
 			}
 			if (no_headers) {
 				SG(headers_sent) = 1;
 				SG(request_info).no_headers = 1;
 			}
 
 			/*
 				at this point path_translated will be set if:
 				1. we are running from shell and got filename was there
 				2. we are running as cgi or fastcgi
 			*/
 			if (cgi || fastcgi || SG(request_info).path_translated) {
 				if (php_fopen_primary_script(&file_handle) == FAILURE) {
 					zend_try {
 						if (errno == EACCES) {
 							SG(sapi_headers).http_response_code = 403;
 							PUTS("Access denied.\n");
 						} else {
 							SG(sapi_headers).http_response_code = 404;
 							PUTS("No input file specified.\n");
 						}
 					} zend_catch {
 					} zend_end_try();
 					/* we want to serve more requests if this is fastcgi
 					 * so cleanup and continue, request shutdown is
 					 * handled later */
 					if (fastcgi) {
 						goto fastcgi_request_done;
 					}
 
 					if (SG(request_info).path_translated) {
 						efree(SG(request_info).path_translated);
 						SG(request_info).path_translated = NULL;
 					}
 
 					if (free_query_string && SG(request_info).query_string) {
 						free(SG(request_info).query_string);
 						SG(request_info).query_string = NULL;
 					}
 
 					php_request_shutdown((void *) 0);
 					SG(server_context) = NULL;
 					php_module_shutdown();
 					sapi_shutdown();
 #ifdef ZTS
 					tsrm_shutdown();
 #endif
 					free(bindpath);
 					return FAILURE;
 				}
 			}
 
 			if (CGIG(check_shebang_line)) {
 				CG(skip_shebang) = 1;
 			}
 
 			switch (behavior) {
 				case PHP_MODE_STANDARD:
 					php_execute_script(&file_handle);
 					break;
 				case PHP_MODE_LINT:
 					PG(during_request_startup) = 0;
 					exit_status = php_lint_script(&file_handle);
 					if (exit_status == SUCCESS) {
 						zend_printf("No syntax errors detected in %s\n", file_handle.filename);
 					} else {
 						zend_printf("Errors parsing %s\n", file_handle.filename);
 					}
 					break;
 				case PHP_MODE_STRIP:
 					if (open_file_for_scanning(&file_handle) == SUCCESS) {
 						zend_strip();
 						zend_file_handle_dtor(&file_handle);
 						php_output_teardown();
 					}
 					return SUCCESS;
 					break;
 				case PHP_MODE_HIGHLIGHT:
 					{
 						zend_syntax_highlighter_ini syntax_highlighter_ini;
 
 						if (open_file_for_scanning(&file_handle) == SUCCESS) {
 							php_get_highlight_struct(&syntax_highlighter_ini);
 							zend_highlight(&syntax_highlighter_ini);
 							if (fastcgi) {
 								goto fastcgi_request_done;
 							}
 							zend_file_handle_dtor(&file_handle);
 							php_output_teardown();
 						}
 						return SUCCESS;
 					}
 					break;
 			}
 
 fastcgi_request_done:
 			{
 				if (SG(request_info).path_translated) {
 					efree(SG(request_info).path_translated);
 					SG(request_info).path_translated = NULL;
 				}
 
 				php_request_shutdown((void *) 0);
 
 				if (exit_status == 0) {
 					exit_status = EG(exit_status);
 				}
 
 				if (free_query_string && SG(request_info).query_string) {
 					free(SG(request_info).query_string);
 					SG(request_info).query_string = NULL;
 				}
 			}
 
 			if (!fastcgi) {
 				if (benchmark) {
 					if (warmup_repeats) {
 						warmup_repeats--;
 						if (!warmup_repeats) {
 #ifdef HAVE_GETTIMEOFDAY
 							gettimeofday(&start, NULL);
 #else
 							time(&start);
 #endif
 #ifdef HAVE_VALGRIND
 							CALLGRIND_START_INSTRUMENTATION;
 #endif
 						}
 						continue;
 					} else {
 						repeats--;
 						if (repeats > 0) {
 							script_file = NULL;
 							php_optind = orig_optind;
 							php_optarg = orig_optarg;
 							continue;
 						}
 					}
 				}
 				break;
 			}
 
 			/* only fastcgi will get here */
 			requests++;
 			if (max_requests && (requests == max_requests)) {
 				fcgi_finish_request(request, 1);
 				free(bindpath);
 				if (max_requests != 1) {
 					/* no need to return exit_status of the last request */
 					exit_status = 0;
 				}
 				break;
 			}
 			/* end of fastcgi loop */
 		}
 
 		if (request) {
 			fcgi_destroy_request(request);
 		}
 		fcgi_shutdown();
 
 		if (cgi_sapi_module.php_ini_path_override) {
 			free(cgi_sapi_module.php_ini_path_override);
 		}
 		if (cgi_sapi_module.ini_entries) {
 			free(cgi_sapi_module.ini_entries);
 		}
 	} zend_catch {
 		exit_status = 255;
 	} zend_end_try();
 
 out:
 	if (benchmark) {
 		int sec;
 #ifdef HAVE_GETTIMEOFDAY
 		int usec;
 
 		gettimeofday(&end, NULL);
 		sec = (int)(end.tv_sec - start.tv_sec);
 		if (end.tv_usec >= start.tv_usec) {
 			usec = (int)(end.tv_usec - start.tv_usec);
 		} else {
 			sec -= 1;
 			usec = (int)(end.tv_usec + 1000000 - start.tv_usec);
 		}
 		fprintf(stderr, "\nElapsed time: %d.%06d sec\n", sec, usec);
 #else
 		time(&end);
 		sec = (int)(end - start);
 		fprintf(stderr, "\nElapsed time: %d sec\n", sec);
 #endif
 	}
 
 parent_out:
 
 	SG(server_context) = NULL;
 	php_module_shutdown();
 	sapi_shutdown();
 
 #ifdef ZTS
 	tsrm_shutdown();
 #endif
 
 #if defined(PHP_WIN32) && ZEND_DEBUG && 0
 	_CrtDumpMemoryLeaks();
 #endif
 
 	return exit_status;
 }
 /* }}} */
diff --git a/sapi/cgi/tests/bug78323.phpt b/sapi/cgi/tests/bug78323.phpt
new file mode 100644
index 0000000000..d89e51874a
--- /dev/null
+++ b/sapi/cgi/tests/bug78323.phpt
@@ -0,0 +1,41 @@
+--TEST--
+Bug #78323 Test exit code and error message for invalid parameters
+--SKIPIF--
+<?php include "skipif.inc"; ?>
+--FILE--
+<?php
+include "include.inc";
+$php = get_cgi_path();
+reset_env_vars();
+
+
+// no argument for option
+ob_start();
+passthru("$php --memory-limit=1G 2>&1", $exitCode);
+$output = ob_get_contents();
+ob_end_clean();
+
+$lines = preg_split('/\R/', $output);
+echo $lines[0], "\n",
+     $lines[1], "\n",
+     "Done: $exitCode\n\n";
+
+
+// Successful execution
+ob_start();
+passthru("$php -dmemory-limit=1G -v", $exitCode);
+$output = ob_get_contents();
+ob_end_clean();
+
+$lines = preg_split('/\R/', $output);
+echo $lines[0], "\n",
+     "Done: $exitCode\n";
+
+?>
+--EXPECTF--
+Error in argument 1, char 1: no argument for option -
+Usage: %s
+Done: 1
+
+PHP %s
+Done: 0
diff --git a/sapi/cli/php_cli.c b/sapi/cli/php_cli.c
index d610c532c9..8cc570f132 100644
--- a/sapi/cli/php_cli.c
+++ b/sapi/cli/php_cli.c
@@ -1148,243 +1148,247 @@ int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine
 #else
 int main(int argc, char *argv[])
 #endif
 {
 #if defined(PHP_WIN32)
 # ifdef PHP_CLI_WIN32_NO_CONSOLE
 	int argc = __argc;
 	char **argv = __argv;
 # endif
 	int num_args;
 	wchar_t **argv_wide;
 	char **argv_save = argv;
 	BOOL using_wide_argv = 0;
 #endif
 
 	int c;
 	int exit_status = SUCCESS;
 	int module_started = 0, sapi_started = 0;
 	char *php_optarg = NULL;
 	int php_optind = 1, use_extended_info = 0;
 	char *ini_path_override = NULL;
 	char *ini_entries = NULL;
 	size_t ini_entries_len = 0;
 	int ini_ignore = 0;
 	sapi_module_struct *sapi_module = &cli_sapi_module;
 
 	/*
 	 * Do not move this initialization. It needs to happen before argv is used
 	 * in any way.
 	 */
 	argv = save_ps_args(argc, argv);
 
 #if defined(PHP_WIN32) && !defined(PHP_CLI_WIN32_NO_CONSOLE)
 	php_win32_console_fileno_set_vt100(STDOUT_FILENO, TRUE);
 	php_win32_console_fileno_set_vt100(STDERR_FILENO, TRUE);
 #endif
 
 	cli_sapi_module.additional_functions = additional_functions;
 
 #if defined(PHP_WIN32) && defined(_DEBUG) && defined(PHP_WIN32_DEBUG_HEAP)
 	{
 		int tmp_flag;
 		_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
 		_CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
 		_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);
 		_CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
 		_CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);
 		_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
 		tmp_flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
 		tmp_flag |= _CRTDBG_DELAY_FREE_MEM_DF;
 		tmp_flag |= _CRTDBG_LEAK_CHECK_DF;
 
 		_CrtSetDbgFlag(tmp_flag);
 	}
 #endif
 
 #if defined(SIGPIPE) && defined(SIG_IGN)
 	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE in standalone mode so
 								that sockets created via fsockopen()
 								don't kill PHP if the remote site
 								closes it.  in apache|apxs mode apache
 								does that for us!  thies@thieso.net
 								20000419 */
 #endif
 
 #ifdef ZTS
 	php_tsrm_startup();
 # ifdef PHP_WIN32
 	ZEND_TSRMLS_CACHE_UPDATE();
 # endif
 #endif
 
 	zend_signal_startup();
 
 #ifdef PHP_WIN32
 	_fmode = _O_BINARY;			/*sets default for file streams to binary */
 	setmode(_fileno(stdin), O_BINARY);		/* make the stdio mode be binary */
 	setmode(_fileno(stdout), O_BINARY);		/* make the stdio mode be binary */
 	setmode(_fileno(stderr), O_BINARY);		/* make the stdio mode be binary */
 #endif
 
-	while ((c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 0, 2))!=-1) {
+	while ((c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 1, 2))!=-1) {
 		switch (c) {
 			case 'c':
 				if (ini_path_override) {
 					free(ini_path_override);
 				}
  				ini_path_override = strdup(php_optarg);
 				break;
 			case 'n':
 				ini_ignore = 1;
 				break;
 			case 'd': {
 				/* define ini entries on command line */
 				size_t len = strlen(php_optarg);
 				char *val;
 
 				if ((val = strchr(php_optarg, '='))) {
 					val++;
 					if (!isalnum(*val) && *val != '"' && *val != '\'' && *val != '\0') {
 						ini_entries = realloc(ini_entries, ini_entries_len + len + sizeof("\"\"\n\0"));
 						memcpy(ini_entries + ini_entries_len, php_optarg, (val - php_optarg));
 						ini_entries_len += (val - php_optarg);
 						memcpy(ini_entries + ini_entries_len, "\"", 1);
 						ini_entries_len++;
 						memcpy(ini_entries + ini_entries_len, val, len - (val - php_optarg));
 						ini_entries_len += len - (val - php_optarg);
 						memcpy(ini_entries + ini_entries_len, "\"\n\0", sizeof("\"\n\0"));
 						ini_entries_len += sizeof("\n\0\"") - 2;
 					} else {
 						ini_entries = realloc(ini_entries, ini_entries_len + len + sizeof("\n\0"));
 						memcpy(ini_entries + ini_entries_len, php_optarg, len);
 						memcpy(ini_entries + ini_entries_len + len, "\n\0", sizeof("\n\0"));
 						ini_entries_len += len + sizeof("\n\0") - 2;
 					}
 				} else {
 					ini_entries = realloc(ini_entries, ini_entries_len + len + sizeof("=1\n\0"));
 					memcpy(ini_entries + ini_entries_len, php_optarg, len);
 					memcpy(ini_entries + ini_entries_len + len, "=1\n\0", sizeof("=1\n\0"));
 					ini_entries_len += len + sizeof("=1\n\0") - 2;
 				}
 				break;
 			}
 #ifndef PHP_CLI_WIN32_NO_CONSOLE
 			case 'S':
 				sapi_module = &cli_server_sapi_module;
 				cli_server_sapi_module.additional_functions = server_additional_functions;
 				break;
 #endif
 			case 'h': /* help & quit */
 			case '?':
 				php_cli_usage(argv[0]);
 				goto out;
+			case PHP_GETOPT_INVALID_ARG: /* print usage on bad options, exit 1 */
+				php_cli_usage(argv[0]);
+				exit_status = 1;
+				goto out;
 			case 'i': case 'v': case 'm':
 				sapi_module = &cli_sapi_module;
 				goto exit_loop;
 			case 'e': /* enable extended info output */
 				use_extended_info = 1;
 				break;
 		}
 	}
 exit_loop:
 
 	sapi_module->ini_defaults = sapi_cli_ini_defaults;
 	sapi_module->php_ini_path_override = ini_path_override;
 	sapi_module->phpinfo_as_text = 1;
 	sapi_module->php_ini_ignore_cwd = 1;
 	sapi_startup(sapi_module);
 	sapi_started = 1;
 
 	sapi_module->php_ini_ignore = ini_ignore;
 
 	sapi_module->executable_location = argv[0];
 
 	if (sapi_module == &cli_sapi_module) {
 		if (ini_entries) {
 			ini_entries = realloc(ini_entries, ini_entries_len + sizeof(HARDCODED_INI));
 			memmove(ini_entries + sizeof(HARDCODED_INI) - 2, ini_entries, ini_entries_len + 1);
 			memcpy(ini_entries, HARDCODED_INI, sizeof(HARDCODED_INI) - 2);
 		} else {
 			ini_entries = malloc(sizeof(HARDCODED_INI));
 			memcpy(ini_entries, HARDCODED_INI, sizeof(HARDCODED_INI));
 		}
 		ini_entries_len += sizeof(HARDCODED_INI) - 2;
 	}
 
 	sapi_module->ini_entries = ini_entries;
 
 	/* startup after we get the above ini override se we get things right */
 	if (sapi_module->startup(sapi_module) == FAILURE) {
 		/* there is no way to see if we must call zend_ini_deactivate()
 		 * since we cannot check if EG(ini_directives) has been initialised
 		 * because the executor's constructor does not set initialize it.
 		 * Apart from that there seems no need for zend_ini_deactivate() yet.
 		 * So we goto out_err.*/
 		exit_status = 1;
 		goto out;
 	}
 	module_started = 1;
 
 #if defined(PHP_WIN32)
 	php_win32_cp_cli_setup();
 	orig_cp = (php_win32_cp_get_orig())->id;
 	/* Ignore the delivered argv and argc, read from W API. This place
 		might be too late though, but this is the earliest place ATW
 		we can access the internal charset information from PHP. */
 	argv_wide = CommandLineToArgvW(GetCommandLineW(), &num_args);
 	PHP_WIN32_CP_W_TO_ANY_ARRAY(argv_wide, num_args, argv, argc)
 	using_wide_argv = 1;
 
 	SetConsoleCtrlHandler(php_cli_win32_ctrl_handler, TRUE);
 #endif
 
 	/* -e option */
 	if (use_extended_info) {
 		CG(compiler_options) |= ZEND_COMPILE_EXTENDED_INFO;
 	}
 
 	zend_first_try {
 #ifndef PHP_CLI_WIN32_NO_CONSOLE
 		if (sapi_module == &cli_sapi_module) {
 #endif
 			exit_status = do_cli(argc, argv);
 #ifndef PHP_CLI_WIN32_NO_CONSOLE
 		} else {
 			exit_status = do_cli_server(argc, argv);
 		}
 #endif
 	} zend_end_try();
 out:
 	if (ini_path_override) {
 		free(ini_path_override);
 	}
 	if (ini_entries) {
 		free(ini_entries);
 	}
 	if (module_started) {
 		php_module_shutdown();
 	}
 	if (sapi_started) {
 		sapi_shutdown();
 	}
 #ifdef ZTS
 	tsrm_shutdown();
 #endif
 
 #if defined(PHP_WIN32)
 	(void)php_win32_cp_cli_restore();
 
 	if (using_wide_argv) {
 		PHP_WIN32_CP_FREE_ARRAY(argv, argc);
 		LocalFree(argv_wide);
 	}
 	argv = argv_save;
 #endif
 	/*
 	 * Do not move this de-initialization. It needs to happen right before
 	 * exiting.
 	 */
 	cleanup_ps_args(argv);
 	exit(exit_status);
 }
 /* }}} */
diff --git a/sapi/cli/tests/015.phpt b/sapi/cli/tests/015.phpt
index 01f5328e99..5a5e6c5190 100644
--- a/sapi/cli/tests/015.phpt
+++ b/sapi/cli/tests/015.phpt
@@ -1,35 +1,35 @@
 --TEST--
 CLI long options
 --SKIPIF--
 <?php
 include "skipif.inc";
 if (substr(PHP_OS, 0, 3) == 'WIN') {
 	die ("skip not for Windows");
 }
 ?>
 --FILE--
 <?php
 
 $php = getenv('TEST_PHP_EXECUTABLE');
 
 
 echo `"$php" -n --version | grep built:`;
 echo `echo "<?php print_r(\\\$argv);" | "$php" -n -- foo bar baz`, "\n";
 echo `"$php" -n --version foo bar baz | grep built:`;
-echo `"$php" -n --notexisting foo bar baz | grep Usage:`;
+echo `"$php" -n --notexisting foo bar baz 2>&1 | grep Usage:`;
 
 echo "Done\n";
 ?>
 --EXPECTF--
 PHP %d.%d.%d%s(cli) (built: %s)%s
 Array
 (
     [0] => Standard input code
     [1] => foo
     [2] => bar
     [3] => baz
 )
 
 PHP %d.%d.%d%s(cli) (built: %s)%s
 Usage: %s [options] [-f] <file> [--] [args...]
 Done
diff --git a/sapi/cli/tests/bug78323.phpt b/sapi/cli/tests/bug78323.phpt
new file mode 100644
index 0000000000..02b18e02a2
--- /dev/null
+++ b/sapi/cli/tests/bug78323.phpt
@@ -0,0 +1,78 @@
+--TEST--
+Bug #78323 Test exit code and error message for invalid parameters
+--SKIPIF--
+<?php
+include "skipif.inc";
+?>
+--FILE--
+<?php
+$php = getenv('TEST_PHP_EXECUTABLE');
+
+// There are 3 types of option errors:
+// 1 : in flags
+// 2 option not found
+// 3 no argument for option
+
+
+// colon in flags
+ob_start();
+passthru("$php -a:Z 2>&1", $exitCode);
+$output = ob_get_contents();
+ob_end_clean();
+
+$lines = preg_split('/\R/', $output);
+echo $lines[0], "\n",
+     $lines[1], "\n",
+     "Done: $exitCode\n\n";
+
+
+// option not found
+ob_start();
+passthru("$php -Z 2>&1", $exitCode);
+$output = ob_get_contents();
+ob_end_clean();
+
+$lines = preg_split('/\R/', $output);
+echo $lines[0], "\n",
+     $lines[1], "\n",
+     "Done: $exitCode\n\n";
+
+
+// no argument for option
+ob_start();
+passthru("$php --memory-limit=1G 2>&1", $exitCode);
+$output = ob_get_contents();
+ob_end_clean();
+
+$lines = preg_split('/\R/', $output);
+echo $lines[0], "\n",
+     $lines[1], "\n",
+     "Done: $exitCode\n\n";
+
+
+// Successful execution
+ob_start();
+passthru("$php -dmemory-limit=1G -v", $exitCode);
+$output = ob_get_contents();
+ob_end_clean();
+
+$lines = preg_split('/\R/', $output);
+echo $lines[0], "\n",
+     "Done: $exitCode\n";
+
+?>
+--EXPECTF--
+Error in argument %d, char %d: : in flags
+Usage: %s [options] [-f] <file> [--] [args...]
+Done: 1
+
+Error in argument %d, char %d: option not found %s
+Usage: %s [options] [-f] <file> [--] [args...]
+Done: 1
+
+Error in argument %d, char %d: no argument for option %s
+Usage: %s [options] [-f] <file> [--] [args...]
+Done: 1
+
+PHP %s
+Done: 0
diff --git a/sapi/fpm/fpm/fpm_main.c b/sapi/fpm/fpm/fpm_main.c
index d00c0c2795..3f1981ada2 100644
--- a/sapi/fpm/fpm/fpm_main.c
+++ b/sapi/fpm/fpm/fpm_main.c
@@ -1537,266 +1537,267 @@ static zend_module_entry cgi_module_entry = {
 /* {{{ main
  */
 int main(int argc, char *argv[])
 {
 	int exit_status = FPM_EXIT_OK;
 	int cgi = 0, c, use_extended_info = 0;
 	zend_file_handle file_handle;
 
 	/* temporary locals */
 	int orig_optind = php_optind;
 	char *orig_optarg = php_optarg;
 	int ini_entries_len = 0;
 	/* end of temporary locals */
 
 	int max_requests = 0;
 	int requests = 0;
 	int fcgi_fd = 0;
 	fcgi_request *request;
 	char *fpm_config = NULL;
 	char *fpm_prefix = NULL;
 	char *fpm_pid = NULL;
 	int test_conf = 0;
 	int force_daemon = -1;
 	int force_stderr = 0;
 	int php_information = 0;
 	int php_allow_to_run_as_root = 0;
 	int ret;
 #if ZEND_RC_DEBUG
 	zend_bool old_rc_debug;
 #endif
 
 #if defined(SIGPIPE) && defined(SIG_IGN)
 	signal(SIGPIPE, SIG_IGN); /* ignore SIGPIPE in standalone mode so
 								that sockets created via fsockopen()
 								don't kill PHP if the remote site
 								closes it.  in apache|apxs mode apache
 								does that for us!  thies@thieso.net
 								20000419 */
 
 	if (0 > fpm_signals_init_mask() || 0 > fpm_signals_block()) {
 		zlog(ZLOG_WARNING, "Could die in the case of too early reload signal");
 	}
 	zlog(ZLOG_DEBUG, "Blocked some signals");
 #endif
 
 #ifdef ZTS
 	php_tsrm_startup();
 #endif
 
 	zend_signal_startup();
 
 	sapi_startup(&cgi_sapi_module);
 	cgi_sapi_module.php_ini_path_override = NULL;
 	cgi_sapi_module.php_ini_ignore_cwd = 1;
 
 #ifndef HAVE_ATTRIBUTE_WEAK
 	fcgi_set_logger(fpm_fcgi_log);
 #endif
 
 	fcgi_init();
 
 	while ((c = php_getopt(argc, argv, OPTIONS, &php_optarg, &php_optind, 0, 2)) != -1) {
 		switch (c) {
 			case 'c':
 				if (cgi_sapi_module.php_ini_path_override) {
 					free(cgi_sapi_module.php_ini_path_override);
 				}
 				cgi_sapi_module.php_ini_path_override = strdup(php_optarg);
 				break;
 
 			case 'n':
 				cgi_sapi_module.php_ini_ignore = 1;
 				break;
 
 			case 'd': {
 				/* define ini entries on command line */
 				int len = strlen(php_optarg);
 				char *val;
 
 				if ((val = strchr(php_optarg, '='))) {
 					val++;
 					if (!isalnum(*val) && *val != '"' && *val != '\'' && *val != '\0') {
 						cgi_sapi_module.ini_entries = realloc(cgi_sapi_module.ini_entries, ini_entries_len + len + sizeof("\"\"\n\0"));
 						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, php_optarg, (val - php_optarg));
 						ini_entries_len += (val - php_optarg);
 						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, "\"", 1);
 						ini_entries_len++;
 						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, val, len - (val - php_optarg));
 						ini_entries_len += len - (val - php_optarg);
 						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, "\"\n\0", sizeof("\"\n\0"));
 						ini_entries_len += sizeof("\n\0\"") - 2;
 					} else {
 						cgi_sapi_module.ini_entries = realloc(cgi_sapi_module.ini_entries, ini_entries_len + len + sizeof("\n\0"));
 						memcpy(cgi_sapi_module.ini_entries + ini_entries_len, php_optarg, len);
 						memcpy(cgi_sapi_module.ini_entries + ini_entries_len + len, "\n\0", sizeof("\n\0"));
 						ini_entries_len += len + sizeof("\n\0") - 2;
 					}
 				} else {
 					cgi_sapi_module.ini_entries = realloc(cgi_sapi_module.ini_entries, ini_entries_len + len + sizeof("=1\n\0"));
 					memcpy(cgi_sapi_module.ini_entries + ini_entries_len, php_optarg, len);
 					memcpy(cgi_sapi_module.ini_entries + ini_entries_len + len, "=1\n\0", sizeof("=1\n\0"));
 					ini_entries_len += len + sizeof("=1\n\0") - 2;
 				}
 				break;
 			}
 
 			case 'y':
 				fpm_config = php_optarg;
 				break;
 
 			case 'p':
 				fpm_prefix = php_optarg;
 				break;
 
 			case 'g':
 				fpm_pid = php_optarg;
 				break;
 
 			case 'e': /* enable extended info output */
 				use_extended_info = 1;
 				break;
 
 			case 't':
 				test_conf++;
 				break;
 
 			case 'm': /* list compiled in modules */
 				cgi_sapi_module.startup(&cgi_sapi_module);
 				php_output_activate();
 				SG(headers_sent) = 1;
 				php_printf("[PHP Modules]\n");
 				print_modules();
 				php_printf("\n[Zend Modules]\n");
 				print_extensions();
 				php_printf("\n");
 				php_output_end_all();
 				php_output_deactivate();
 				fcgi_shutdown();
 				exit_status = FPM_EXIT_OK;
 				goto out;
 
 			case 'i': /* php info & quit */
 				php_information = 1;
 				break;
 
 			case 'R': /* allow to run as root */
 				php_allow_to_run_as_root = 1;
 				break;
 
 			case 'D': /* daemonize */
 				force_daemon = 1;
 				break;
 
 			case 'F': /* nodaemonize */
 				force_daemon = 0;
 				break;
 
 			case 'O': /* force stderr even on non tty */
 				force_stderr = 1;
 				break;
 
 			default:
 			case 'h':
 			case '?':
+			case PHP_GETOPT_INVALID_ARG:
 				cgi_sapi_module.startup(&cgi_sapi_module);
 				php_output_activate();
 				SG(headers_sent) = 1;
 				php_cgi_usage(argv[0]);
 				php_output_end_all();
 				php_output_deactivate();
 				fcgi_shutdown();
-				exit_status = (c == 'h') ? FPM_EXIT_OK : FPM_EXIT_USAGE;
+				exit_status = (c != PHP_GETOPT_INVALID_ARG) ? FPM_EXIT_OK : FPM_EXIT_USAGE;
 				goto out;
 
 			case 'v': /* show php version & quit */
 				cgi_sapi_module.startup(&cgi_sapi_module);
 				if (php_request_startup() == FAILURE) {
 					SG(server_context) = NULL;
 					php_module_shutdown();
 					return FPM_EXIT_SOFTWARE;
 				}
 				SG(headers_sent) = 1;
 				SG(request_info).no_headers = 1;
 
 #if ZEND_DEBUG
 				php_printf("PHP %s (%s) (built: %s %s) (DEBUG)\nCopyright (c) The PHP Group\n%s", PHP_VERSION, sapi_module.name, __DATE__,        __TIME__, get_zend_version());
 #else
 				php_printf("PHP %s (%s) (built: %s %s)\nCopyright (c) The PHP Group\n%s", PHP_VERSION, sapi_module.name, __DATE__, __TIME__,      get_zend_version());
 #endif
 				php_request_shutdown((void *) 0);
 				fcgi_shutdown();
 				exit_status = FPM_EXIT_OK;
 				goto out;
 		}
 	}
 
 	if (php_information) {
 		cgi_sapi_module.phpinfo_as_text = 1;
 		cgi_sapi_module.startup(&cgi_sapi_module);
 		if (php_request_startup() == FAILURE) {
 			SG(server_context) = NULL;
 			php_module_shutdown();
 			return FPM_EXIT_SOFTWARE;
 		}
 		SG(headers_sent) = 1;
 		SG(request_info).no_headers = 1;
 		php_print_info(0xFFFFFFFF);
 		php_request_shutdown((void *) 0);
 		fcgi_shutdown();
 		exit_status = FPM_EXIT_OK;
 		goto out;
 	}
 
 	/* No other args are permitted here as there is no interactive mode */
 	if (argc != php_optind) {
 		cgi_sapi_module.startup(&cgi_sapi_module);
 		php_output_activate();
 		SG(headers_sent) = 1;
 		php_cgi_usage(argv[0]);
 		php_output_end_all();
 		php_output_deactivate();
 		fcgi_shutdown();
 		exit_status = FPM_EXIT_USAGE;
 		goto out;
 	}
 
 	php_optind = orig_optind;
 	php_optarg = orig_optarg;
 
 #ifdef ZTS
 	SG(request_info).path_translated = NULL;
 #endif
 
 	cgi_sapi_module.additional_functions = NULL;
 	cgi_sapi_module.executable_location = argv[0];
 
 	/* startup after we get the above ini override se we get things right */
 	if (cgi_sapi_module.startup(&cgi_sapi_module) == FAILURE) {
 #ifdef ZTS
 		tsrm_shutdown();
 #endif
 		return FPM_EXIT_SOFTWARE;
 	}
 
 	if (use_extended_info) {
 		CG(compiler_options) |= ZEND_COMPILE_EXTENDED_INFO;
 	}
 
 	/* check force_cgi after startup, so we have proper output */
 	if (cgi && CGIG(force_redirect)) {
 		/* Apache will generate REDIRECT_STATUS,
 		 * Netscape and redirect.so will generate HTTP_REDIRECT_STATUS.
 		 * redirect.so and installation instructions available from
 		 * http://www.koehntopp.de/php.
 		 *   -- kk@netuse.de
 		 */
 		if (!getenv("REDIRECT_STATUS") &&
 			!getenv ("HTTP_REDIRECT_STATUS") &&
 			/* this is to allow a different env var to be configured
 			 * in case some server does something different than above */
 			(!CGIG(redirect_status_env) || !getenv(CGIG(redirect_status_env)))
 		) {
 			zend_try {
 				SG(sapi_headers).http_response_code = 400;
 				PUTS("<b>Security Alert!</b> The PHP CGI cannot be accessed directly.\n\n\
 <p>This PHP CGI binary was compiled with force-cgi-redirect enabled.  This\n\
diff --git a/sapi/fpm/tests/bug78323.phpt b/sapi/fpm/tests/bug78323.phpt
new file mode 100644
index 0000000000..cf91020573
--- /dev/null
+++ b/sapi/fpm/tests/bug78323.phpt
@@ -0,0 +1,39 @@
+--TEST--
+FPM: Bug #78323 Test exit code for invalid parameters
+--SKIPIF--
+<?php include "skipif.inc"; ?>
+--FILE--
+<?php
+
+require_once "tester.inc";
+
+$php = \FPM\Tester::findExecutable();
+
+// no argument for option
+ob_start();
+passthru("$php --memory-limit=1G 2>&1", $exitCode);
+$output = ob_get_contents();
+ob_end_clean();
+
+$lines = preg_split('/\R/', $output);
+echo $lines[0], "\n",
+     "Done: $exitCode\n\n";
+
+
+// Successful execution
+ob_start();
+passthru("$php -dmemory-limit=1G -v", $exitCode);
+$output = ob_get_contents();
+ob_end_clean();
+
+$lines = preg_split('/\R/', $output);
+echo $lines[0], "\n",
+     "Done: $exitCode\n";
+
+?>
+--EXPECTF--
+Usage: %s
+Done: 64
+
+PHP %s
+Done: 0
