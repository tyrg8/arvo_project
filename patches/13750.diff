commit 138a06d1b1cd035daf6b6a970c75126e94777822
Author: Brian Salomon <bsalomon@google.com>
Date:   Fri Mar 15 14:33:31 2019 +0000

    Revert "Reland "Update SkCanvas' experimental SkiaRenderer API""
    
    This reverts commit bd9d88a6e4d9730f3aa67227e5a1618180513a87.
    
    Reason for revert: Breaks SkiaRenderer on Android. Rendering is all corrupted, bisected to this change.
    
    Original change's description:
    > Reland "Update SkCanvas' experimental SkiaRenderer API"
    >
    > This reverts commit 90791c202dd2d943565237bf511d929e8bd19951.
    >
    > Reason for revert: Jumped the gun, just need to update blacklist
    >
    > Original change's description:
    > > Revert "Update SkCanvas' experimental SkiaRenderer API"
    > >
    > > This reverts commit 4bf964602ab8758f6e580aaaa69add4fb260c1a6.
    > >
    > > Reason for revert: vulkan dm crashes
    > >
    > > Original change's description:
    > > > Update SkCanvas' experimental SkiaRenderer API
    > > >
    > > > This lifts the temporary functions in SkGpuDevice into SkCanvas and
    > > > deprecates the older experimental_DrawImageSetV1 and
    > > > experimental_DrawEdgeAARect.  The new functions can handle paints and
    > > > transform batching. Internally, SkCanvas routes the old functions to the
    > > > new entry points and all device-level code is updated to handle the new
    > > > API features.
    > > >
    > > > While touching all of the canvas/device/recording areas, the
    > > > experimental functions are grouped in an "EdgeAA" cluster instead of being
    > > > separated into the image category and the rectangle category.
    > > >
    > > > Bug: skia:8739
    > > > Change-Id: I67c2a724873040ad5dc3307ab5b2823ba1eac54b
    > > > Reviewed-on: https://skia-review.googlesource.com/c/skia/+/190221
    > > > Commit-Queue: Michael Ludwig <michaelludwig@google.com>
    > > > Reviewed-by: Brian Salomon <bsalomon@google.com>
    > >
    > > TBR=bsalomon@google.com,robertphillips@google.com,michaelludwig@google.com
    > >
    > > Change-Id: I87a5a258c5a1bd15e16389cdf91743772d6fa98a
    > > No-Presubmit: true
    > > No-Tree-Checks: true
    > > No-Try: true
    > > Bug: skia:8739
    > > Reviewed-on: https://skia-review.googlesource.com/c/skia/+/201226
    > > Reviewed-by: Michael Ludwig <michaelludwig@google.com>
    > > Commit-Queue: Michael Ludwig <michaelludwig@google.com>
    >
    > TBR=bsalomon@google.com,robertphillips@google.com,michaelludwig@google.com
    >
    > Change-Id: I75e9b6cbf079a7739b69a7e208730a930621abf9
    > No-Presubmit: true
    > No-Tree-Checks: true
    > No-Try: true
    > Bug: skia:8739
    > Reviewed-on: https://skia-review.googlesource.com/c/skia/+/201229
    > Reviewed-by: Michael Ludwig <michaelludwig@google.com>
    > Commit-Queue: Michael Ludwig <michaelludwig@google.com>
    > Auto-Submit: Michael Ludwig <michaelludwig@google.com>
    
    TBR=bsalomon@google.com,robertphillips@google.com,michaelludwig@google.com
    
    Change-Id: Ib87ef9b8b8598c16a8a6915920adf0b5dffc644b
    No-Presubmit: true
    No-Tree-Checks: true
    No-Try: true
    Bug: skia:8739
    Reviewed-on: https://skia-review.googlesource.com/c/skia/+/201391
    Reviewed-by: Brian Salomon <bsalomon@google.com>
    Commit-Queue: Brian Salomon <bsalomon@google.com>

diff --git a/gm/compositor_quads.cpp b/gm/compositor_quads.cpp
index befdedf848..69647e59a1 100644
--- a/gm/compositor_quads.cpp
+++ b/gm/compositor_quads.cpp
@@ -180,222 +180,248 @@ class ClipTileRenderer : public SkRefCntBase {
 public:
     virtual ~ClipTileRenderer() {}
 
     // Draw the base rect, possibly clipped by 'clip' if that is not null. The edges to antialias
     // are specified in 'edgeAA' (to make manipulation easier than an unsigned bitfield). 'tileID'
     // represents the location of rect within the tile grid, 'quadID' is the unique ID of the clip
     // region within the tile (reset for each tile).
     //
     // The edgeAA order matches that of clip, so it refers to top, right, bottom, left.
     // Return draw count
     virtual int drawTile(SkCanvas* canvas, const SkRect& rect, const SkPoint clip[4],
                           const bool edgeAA[4], int tileID, int quadID) = 0;
 
     virtual void drawBanner(SkCanvas* canvas) = 0;
 
     // Return draw count
-    virtual int drawTiles(SkCanvas* canvas) {
+    virtual int drawTiles(SkCanvas* canvas, GrContext* context, GrRenderTargetContext* rtc) {
+        // TODO (michaelludwig) - once the quad APIs are in SkCanvas, drop these
+        // cached fields, which drawTile() needs
+        fContext = context;
+
+        SkBaseDevice* device = canvas->getDevice();
+        if (device->context()) {
+            // Pretty sure it's a SkGpuDevice since this is a run as a GPU GM, unfortunately we
+            // don't have RTTI for dynamic_cast
+            fDevice = static_cast<SkGpuDevice*>(device);
+        } else {
+            // This is either Viewer passing an SkPaintFilterCanvas (in which case we could get
+            // it's wrapped proxy to get the SkGpuDevice), or it is an SkColorSpaceXformCanvas
+            // that doesn't expose any access to original device. Unfortunately without RTTI
+            // there is no way to distinguish these cases so just avoid drawing. Once the API
+            // is in SkCanvas, this is a non-issue. Code that works for viewer can be uncommented
+            // to test locally (and must add ClipTileRenderer as a friend in SkPaintFilterCanvas)
+            // SkPaintFilterCanvas* filteredCanvas = static_cast<SkPaintFilterCanvas*>(canvas);
+            // fDevice = static_cast<SkGpuDevice*>(filteredCanvas->proxy()->getDevice());
+            return 0;
+        }
+
         // All three lines in a list
         SkPoint lines[6];
         clipping_line_segment(kClipP1, kClipP2, lines);
         clipping_line_segment(kClipP2, kClipP3, lines + 2);
         clipping_line_segment(kClipP3, kClipP1, lines + 4);
 
         bool edgeAA[4];
         int tileID = 0;
         int drawCount = 0;
         for (int i = 0; i < kRowCount; ++i) {
             for (int j = 0; j < kColCount; ++j) {
                 // The unclipped tile geometry
                 SkRect tile = SkRect::MakeXYWH(j * kTileWidth, i * kTileHeight,
                                                kTileWidth, kTileHeight);
                 // Base edge AA flags if there are no clips; clipped lines will only turn off edges
                 edgeAA[0] = i == 0;             // Top
                 edgeAA[1] = j == kColCount - 1; // Right
                 edgeAA[2] = i == kRowCount - 1; // Bottom
                 edgeAA[3] = j == 0;             // Left
 
                 // Now clip against the 3 lines formed by kClipPx and split into general purpose
                 // quads as needed.
                 int quadCount = 0;
                 drawCount += this->clipTile(canvas, tileID, tile, nullptr, edgeAA, lines, 3,
                                             &quadCount);
                 tileID++;
             }
         }
 
         return drawCount;
     }
 
 protected:
+    // Remembered for convenience in drawTile, set by drawTiles()
+    GrContext* fContext;
+    SkGpuDevice* fDevice;
+
     SkCanvas::QuadAAFlags maskToFlags(const bool edgeAA[4]) const {
         unsigned flags = (edgeAA[0] * SkCanvas::kTop_QuadAAFlag) |
                          (edgeAA[1] * SkCanvas::kRight_QuadAAFlag) |
                          (edgeAA[2] * SkCanvas::kBottom_QuadAAFlag) |
                          (edgeAA[3] * SkCanvas::kLeft_QuadAAFlag);
         return static_cast<SkCanvas::QuadAAFlags>(flags);
     }
 
     // Recursively splits the quadrilateral against the segments stored in 'lines', which must be
     // 2 * lineCount long. Increments 'quadCount' for each split quadrilateral, and invokes the
     // drawTile at leaves.
     int clipTile(SkCanvas* canvas, int tileID, const SkRect& baseRect, const SkPoint quad[4],
                   const bool edgeAA[4], const SkPoint lines[], int lineCount, int* quadCount) {
         if (lineCount == 0) {
             // No lines, so end recursion by drawing the tile. If the tile was never split then
             // 'quad' remains null so that drawTile() can differentiate how it should draw.
             int draws = this->drawTile(canvas, baseRect, quad, edgeAA, tileID, *quadCount);
             *quadCount = *quadCount + 1;
             return draws;
         }
 
         static constexpr int kTL = 0; // Top-left point index in points array
         static constexpr int kTR = 1; // Top-right point index in points array
         static constexpr int kBR = 2; // Bottom-right point index in points array
         static constexpr int kBL = 3; // Bottom-left point index in points array
         static constexpr int kS0 = 4; // First split point index in points array
         static constexpr int kS1 = 5; // Second split point index in points array
 
         SkPoint points[6];
         if (quad) {
             // Copy the original 4 points into set of points to consider
             for (int i = 0; i < 4; ++i) {
                 points[i] = quad[i];
             }
         } else {
             //  Haven't been split yet, so fill in based on the rect
             baseRect.toQuad(points);
         }
 
         // Consider the first line against the 4 quad edges in tile, which should have 0,1, or 2
         // intersection points since the tile is convex.
         int splitIndices[2]; // Edge that was intersected
         int intersectionCount = 0;
         for (int i = 0; i < 4; ++i) {
             SkPoint intersect;
             if (intersect_line_segments(points[i], points[i == 3 ? 0 : i + 1],
                                         lines[0], lines[1], &intersect)) {
                 // If the intersected point is the same as the last found intersection, the line
                 // runs through a vertex, so don't double count it
                 bool duplicate = false;
                 for (int j = 0; j < intersectionCount; ++j) {
                     if (SkScalarNearlyZero((intersect - points[kS0 + j]).length())) {
                         duplicate = true;
                         break;
                     }
                 }
                 if (!duplicate) {
                     points[kS0 + intersectionCount] = intersect;
                     splitIndices[intersectionCount] = i;
                     intersectionCount++;
                 }
             }
         }
 
         if (intersectionCount < 2) {
             // Either the first line never intersected the quad (count == 0), or it intersected at a
             // single vertex without going through quad area (count == 1), so check next line
             return this->clipTile(
                     canvas, tileID, baseRect, quad, edgeAA, lines + 2, lineCount - 1, quadCount);
         }
 
         SkASSERT(intersectionCount == 2);
         // Split the tile points into 2+ sub quads and recurse to the next lines, which may or may
         // not further split the tile. Since the configurations are relatively simple, the possible
         // splits are hardcoded below; subtile quad orderings are such that the sub tiles remain in
         // clockwise order and match expected edges for QuadAAFlags. subtile indices refer to the
         // 6-element 'points' array.
         SkSTArray<3, std::array<int, 4>> subtiles;
         int s2 = -1; // Index of an original vertex chosen for a artificial split
         if (splitIndices[1] - splitIndices[0] == 2) {
             // Opposite edges, so the split trivially forms 2 sub quads
             if (splitIndices[0] == 0) {
                 subtiles.push_back({{kTL, kS0, kS1, kBL}});
                 subtiles.push_back({{kS0, kTR, kBR, kS1}});
             } else {
                 subtiles.push_back({{kTL, kTR, kS0, kS1}});
                 subtiles.push_back({{kS1, kS0, kBR, kBL}});
             }
         } else {
             // Adjacent edges, which makes for a more complicated split, since it forms a degenerate
             // quad (triangle) and a pentagon that must be artificially split. The pentagon is split
             // using one of the original vertices (remembered in 's2'), which adds an additional
             // degenerate quad, but ensures there are no T-junctions.
             switch(splitIndices[0]) {
                 case 0:
                     // Could be connected to edge 1 or edge 3
                     if (splitIndices[1] == 1) {
                         s2 = kBL;
                         subtiles.push_back({{kS0, kTR, kS1, kS0}}); // degenerate
                         subtiles.push_back({{kTL, kS0, edgeAA[0] ? kS0 : kBL, kBL}}); // degenerate
                         subtiles.push_back({{kS0, kS1, kBR, kBL}});
                     } else {
                         SkASSERT(splitIndices[1] == 3);
                         s2 = kBR;
                         subtiles.push_back({{kTL, kS0, kS1, kS1}}); // degenerate
                         subtiles.push_back({{kS1, edgeAA[3] ? kS1 : kBR, kBR, kBL}}); // degenerate
                         subtiles.push_back({{kS0, kTR, kBR, kS1}});
                     }
                     break;
                 case 1:
                     // Edge 0 handled above, should only be connected to edge 2
                     SkASSERT(splitIndices[1] == 2);
                     s2 = kTL;
                     subtiles.push_back({{kS0, kS0, kBR, kS1}}); // degenerate
                     subtiles.push_back({{kTL, kTR, kS0, edgeAA[1] ? kS0 : kTL}}); // degenerate
                     subtiles.push_back({{kTL, kS0, kS1, kBL}});
                     break;
                 case 2:
                     // Edge 1 handled above, should only be connected to edge 3
                     SkASSERT(splitIndices[1] == 3);
                     s2 = kTR;
                     subtiles.push_back({{kS1, kS0, kS0, kBL}}); // degenerate
                     subtiles.push_back({{edgeAA[2] ? kS0 : kTR, kTR, kBR, kS0}}); // degenerate
                     subtiles.push_back({{kTL, kTR, kS0, kS1}});
                     break;
                 case 3:
                     // Fall through, an adjacent edge split that hits edge 3 should have first found
                     // been found with edge 0 or edge 2 for the other end
                 default:
                     SkASSERT(false);
                     return 0;
             }
         }
 
         SkPoint sub[4];
         bool subAA[4];
         int draws = 0;
         for (int i = 0; i < subtiles.count(); ++i) {
             // Fill in the quad points and update edge AA rules for new interior edges
             for (int j = 0; j < 4; ++j) {
                 int p = subtiles[i][j];
                 sub[j] = points[p];
 
                 int np = j == 3 ? subtiles[i][0] : subtiles[i][j + 1];
                 // The "new" edges are the edges that connect between the two split points or
                 // between a split point and the chosen s2 point. Otherwise the edge remains aligned
                 // with the original shape, so should preserve the AA setting.
+                // if ((p == s2 || p >= kS0) && (np == s2 || np >= kS0)) {
                 if ((p >= kS0 && (np == s2 || np >= kS0)) ||
                     ((np >= kS0) && (p == s2 || p >= kS0))) {
                     // New edge
                     subAA[j] = false;
                 } else {
                     // The subtiles indices were arranged so that their edge ordering was still top,
                     // right, bottom, left so 'j' can be used to access edgeAA
                     subAA[j] = edgeAA[j];
                 }
             }
 
             // Split the sub quad with the next line
             draws += this->clipTile(canvas, tileID, baseRect, sub, subAA, lines + 2, lineCount - 1,
                                     quadCount);
         }
         return draws;
     }
 };
 
 static constexpr int kMatrixCount = 5;
 
-class CompositorGM : public skiagm::GM {
+class CompositorGM : public skiagm::GpuGM {
 public:
     CompositorGM(const char* name, sk_sp<ClipTileRenderer> renderer)
             : fName(name) {
@@ -408,68 +434,68 @@ public:
 protected:
     SkISize onISize() override {
         // The GM draws a grid of renderers (rows) x transforms (col). Within each cell, the
         // renderer draws the transformed tile grid, which is approximately
         // (kColCount*kTileWidth, kRowCount*kTileHeight), although it has additional line
         // visualizations and can be transformed outside of those rectangular bounds (i.e. persp),
         // so pad the cell dimensions to be conservative. Must also account for the banner text.
         static constexpr SkScalar kCellWidth = 1.3f * kColCount * kTileWidth;
         static constexpr SkScalar kCellHeight = 1.3f * kRowCount * kTileHeight;
         return SkISize::Make(SkScalarRoundToInt(kCellWidth * kMatrixCount + 175.f),
                              SkScalarRoundToInt(kCellHeight * fRenderers.count() + 75.f));
     }
 
     SkString onShortName() override {
         SkString fullName;
         fullName.appendf("compositor_quads_%s", fName.c_str());
         return fullName;
     }
 
     void onOnceBeforeDraw() override {
         this->configureMatrices();
     }
 
-    void onDraw(SkCanvas* canvas) override {
+    void onDraw(GrContext* ctx, GrRenderTargetContext* rtc, SkCanvas* canvas) override {
         static constexpr SkScalar kGap = 40.f;
         static constexpr SkScalar kBannerWidth = 120.f;
         static constexpr SkScalar kOffset = 15.f;
 
         SkTArray<int> drawCounts(fRenderers.count());
         drawCounts.push_back_n(fRenderers.count(), 0);
 
         canvas->save();
         canvas->translate(kOffset + kBannerWidth, kOffset);
         for (int i = 0; i < fMatrices.count(); ++i) {
             canvas->save();
             draw_text(canvas, fMatrixNames[i].c_str());
 
             canvas->translate(0.f, kGap);
             for (int j = 0; j < fRenderers.count(); ++j) {
                 canvas->save();
                 draw_tile_boundaries(canvas, fMatrices[i]);
                 draw_clipping_boundaries(canvas, fMatrices[i]);
 
                 canvas->concat(fMatrices[i]);
-                drawCounts[j] += fRenderers[j]->drawTiles(canvas);
+                drawCounts[j] += fRenderers[j]->drawTiles(canvas, ctx, rtc);
 
                 canvas->restore();
                 // And advance to the next row
                 canvas->translate(0.f, kGap + kRowCount * kTileHeight);
             }
             // Reset back to the left edge
             canvas->restore();
             // And advance to the next column
             canvas->translate(kGap + kColCount * kTileWidth, 0.f);
         }
         canvas->restore();
 
         // Print a row header, with total draw counts
         canvas->save();
         canvas->translate(kOffset, kGap + 0.5f * kRowCount * kTileHeight);
         for (int j = 0; j < fRenderers.count(); ++j) {
             fRenderers[j]->drawBanner(canvas);
             canvas->translate(0.f, 15.f);
             draw_text(canvas, SkStringPrintf("Draws = %d", drawCounts[j]).c_str());
             canvas->translate(0.f, kGap + kRowCount * kTileHeight);
         }
         canvas->restore();
     }
@@ -530,53 +556,53 @@ class DebugTileRenderer : public ClipTileRenderer {
 public:
 
     static sk_sp<ClipTileRenderer> Make() {
         // Since aa override is disabled, the quad flags arg doesn't matter.
         return sk_sp<ClipTileRenderer>(new DebugTileRenderer(SkCanvas::kAll_QuadAAFlags, false));
     }
 
     static sk_sp<ClipTileRenderer> MakeAA() {
         return sk_sp<ClipTileRenderer>(new DebugTileRenderer(SkCanvas::kAll_QuadAAFlags, true));
     }
 
     static sk_sp<ClipTileRenderer> MakeNonAA() {
         return sk_sp<ClipTileRenderer>(new DebugTileRenderer(SkCanvas::kNone_QuadAAFlags, true));
     }
 
     int drawTile(SkCanvas* canvas, const SkRect& rect, const SkPoint clip[4], const bool edgeAA[4],
                   int tileID, int quadID) override {
         // Colorize the tile based on its grid position and quad ID
         int i = tileID / kColCount;
         int j = tileID % kColCount;
 
         SkColor4f c = {(i + 1.f) / kRowCount, (j + 1.f) / kColCount, .4f, 1.f};
         float alpha = quadID / 10.f;
         c.fR = c.fR * (1 - alpha) + alpha;
         c.fG = c.fG * (1 - alpha) + alpha;
         c.fB = c.fB * (1 - alpha) + alpha;
         c.fA = c.fA * (1 - alpha) + alpha;
 
         SkCanvas::QuadAAFlags aaFlags = fEnableAAOverride ? fAAOverride : this->maskToFlags(edgeAA);
-        canvas->experimental_DrawEdgeAAQuad(
-                rect, clip, aaFlags, c.toSkColor(), SkBlendMode::kSrcOver);
+        fDevice->tmp_drawEdgeAAQuad(
+                rect, clip, clip ? 4 : 0, aaFlags, c.toSkColor(), SkBlendMode::kSrcOver);
         return 1;
     }
 
     void drawBanner(SkCanvas* canvas) override {
         draw_text(canvas, "Edge AA");
         canvas->translate(0.f, 15.f);
 
         SkString config;
         static const char* kFormat = "Ext(%s) - Int(%s)";
         if (fEnableAAOverride) {
             SkASSERT(fAAOverride == SkCanvas::kAll_QuadAAFlags ||
                      fAAOverride == SkCanvas::kNone_QuadAAFlags);
             if (fAAOverride == SkCanvas::kAll_QuadAAFlags) {
                 config.appendf(kFormat, "yes", "yes");
             } else {
                 config.appendf(kFormat, "no", "no");
             }
         } else {
             config.appendf(kFormat, "yes", "no");
         }
         draw_text(canvas, config.c_str());
     }
@@ -597,16 +623,16 @@ class SolidColorRenderer : public ClipTileRenderer {
 public:
 
     static sk_sp<ClipTileRenderer> Make(const SkColor4f& color) {
         return sk_sp<ClipTileRenderer>(new SolidColorRenderer(color));
     }
 
     int drawTile(SkCanvas* canvas, const SkRect& rect, const SkPoint clip[4], const bool edgeAA[4],
                   int tileID, int quadID) override {
-        canvas->experimental_DrawEdgeAAQuad(rect, clip, this->maskToFlags(edgeAA),
-                                            fColor.toSkColor(), SkBlendMode::kSrcOver);
+        fDevice->tmp_drawEdgeAAQuad(rect, clip, clip ? 4 : 0, this->maskToFlags(edgeAA),
+                                    fColor.toSkColor(), SkBlendMode::kSrcOver);
         return 1;
     }
 
     void drawBanner(SkCanvas* canvas) override {
         draw_text(canvas, "Solid Color");
     }
@@ -625,126 +651,127 @@ class TextureSetRenderer : public ClipTileRenderer {
 public:
 
     static sk_sp<ClipTileRenderer> MakeUnbatched(sk_sp<SkImage> image) {
         return Make("Texture", "", std::move(image), nullptr, nullptr, nullptr, nullptr,
                     1.f, true, 0);
     }
 
     static sk_sp<ClipTileRenderer> MakeBatched(sk_sp<SkImage> image, int transformCount) {
         const char* subtitle = transformCount == 0 ? "" : "w/ xforms";
         return Make("Texture Set", subtitle, std::move(image), nullptr, nullptr, nullptr, nullptr,
                     1.f, false, transformCount);
     }
 
     static sk_sp<ClipTileRenderer> MakeShader(const char* name, sk_sp<SkImage> image,
                                               sk_sp<SkShader> shader, bool local) {
         return Make("Shader", name, std::move(image), std::move(shader),
                     nullptr, nullptr, nullptr, 1.f, local, 0);
     }
 
     static sk_sp<ClipTileRenderer> MakeColorFilter(const char* name, sk_sp<SkImage> image,
                                                    sk_sp<SkColorFilter> filter) {
         return Make("Color Filter", name, std::move(image), nullptr, std::move(filter), nullptr,
                     nullptr, 1.f, false, 0);
     }
 
     static sk_sp<ClipTileRenderer> MakeImageFilter(const char* name, sk_sp<SkImage> image,
                                                    sk_sp<SkImageFilter> filter) {
         return Make("Image Filter", name, std::move(image), nullptr, nullptr, std::move(filter),
                     nullptr, 1.f, false, 0);
     }
 
     static sk_sp<ClipTileRenderer> MakeMaskFilter(const char* name, sk_sp<SkImage> image,
                                                   sk_sp<SkMaskFilter> filter) {
         return Make("Mask Filter", name, std::move(image), nullptr, nullptr, nullptr,
                     std::move(filter), 1.f, false, 0);
     }
 
     static sk_sp<ClipTileRenderer> MakeAlpha(sk_sp<SkImage> image, SkScalar alpha) {
         return Make("Alpha", SkStringPrintf("a = %.2f", alpha).c_str(), std::move(image), nullptr,
                     nullptr, nullptr, nullptr, alpha, false, 0);
     }
 
     static sk_sp<ClipTileRenderer> Make(const char* topBanner, const char* bottomBanner,
                                         sk_sp<SkImage> image, sk_sp<SkShader> shader,
                                         sk_sp<SkColorFilter> colorFilter,
                                         sk_sp<SkImageFilter> imageFilter,
                                         sk_sp<SkMaskFilter> maskFilter, SkScalar paintAlpha,
                                         bool resetAfterEachQuad, int transformCount) {
         return sk_sp<ClipTileRenderer>(new TextureSetRenderer(topBanner, bottomBanner,
                 std::move(image), std::move(shader), std::move(colorFilter), std::move(imageFilter),
                 std::move(maskFilter), paintAlpha, resetAfterEachQuad, transformCount));
     }
 
-    int drawTiles(SkCanvas* canvas) override {
+    int drawTiles(SkCanvas* canvas, GrContext* ctx, GrRenderTargetContext* rtc) override {
         SkASSERT(fImage); // initImage should be called before any drawing
-        int draws = this->INHERITED::drawTiles(canvas);
+        int draws = this->INHERITED::drawTiles(canvas, ctx, rtc);
         // Push the last tile set
         draws += this->drawAndReset(canvas);
         return draws;
     }
 
     int drawTile(SkCanvas* canvas, const SkRect& rect, const SkPoint clip[4], const bool edgeAA[4],
                   int tileID, int quadID) override {
         // Now don't actually draw the tile, accumulate it in the growing entry set
-        bool hasClip = false;
+        int clipCount = 0;
         if (clip) {
             // Record the four points into fDstClips
+            clipCount = 4;
             fDstClips.push_back_n(4, clip);
-            hasClip = true;
         }
 
-        int matrixIdx = -1;
+        int preViewIdx = -1;
         if (!fResetEachQuad && fTransformBatchCount > 0) {
             // Handle transform batching. This works by capturing the CTM of the first tile draw,
             // and then calculate the difference between that and future CTMs for later tiles.
-            if (fPreViewMatrices.count() == 0) {
+            if (fPreViewXforms.count() == 0) {
                 fBaseCTM = canvas->getTotalMatrix();
-                fPreViewMatrices.push_back(SkMatrix::I());
-                matrixIdx = 0;
+                fPreViewXforms.push_back(SkMatrix::I());
+                preViewIdx = 0;
             } else {
                 // Calculate matrix s.t. getTotalMatrix() = fBaseCTM * M
                 SkMatrix invBase;
                 if (!fBaseCTM.invert(&invBase)) {
                     SkDebugf("Cannot invert CTM, transform batching will not be correct.\n");
                 } else {
                     SkMatrix preView = SkMatrix::Concat(invBase, canvas->getTotalMatrix());
-                    if (preView != fPreViewMatrices[fPreViewMatrices.count() - 1]) {
+                    if (preView != fPreViewXforms[fPreViewXforms.count() - 1]) {
                         // Add the new matrix
-                        fPreViewMatrices.push_back(preView);
+                        fPreViewXforms.push_back(preView);
                     } // else re-use the last matrix
-                    matrixIdx = fPreViewMatrices.count() - 1;
+                    preViewIdx = fPreViewXforms.count() - 1;
                 }
             }
         }
 
         // This acts like the whole image is rendered over the entire tile grid, so derive local
         // coordinates from 'rect', based on the grid to image transform.
         SkMatrix gridToImage = SkMatrix::MakeRectToRect(SkRect::MakeWH(kColCount * kTileWidth,
                                                                        kRowCount * kTileHeight),
                                                         SkRect::MakeWH(fImage->width(),
                                                                        fImage->height()),
                                                         SkMatrix::kFill_ScaleToFit);
         SkRect localRect = gridToImage.mapRect(rect);
 
         // drawTextureSet automatically derives appropriate local quad from localRect if clipPtr
         // is not null.
-        fSetEntries.push_back(
-                {fImage, localRect, rect, matrixIdx, 1.f, this->maskToFlags(edgeAA), hasClip});
+        fSetEntries.push_back({fImage, localRect, rect, 1.f, this->maskToFlags(edgeAA)});
+        fDstClipCounts.push_back(clipCount);
+        fPreViewIdx.push_back(preViewIdx);
 
         if (fResetEachQuad) {
             // Only ever draw one entry at a time
             return this->drawAndReset(canvas);
         } else {
             return 0;
         }
     }
 
     void drawBanner(SkCanvas* canvas) override {
         if (fTopBanner.size() > 0) {
             draw_text(canvas, fTopBanner.c_str());
         }
         canvas->translate(0.f, 15.f);
         if (fBottomBanner.size() > 0) {
             draw_text(canvas, fBottomBanner.c_str());
         }
     }
@@ -752,121 +779,131 @@ public:
 private:
     SkString fTopBanner;
     SkString fBottomBanner;
 
     sk_sp<SkImage> fImage;
     sk_sp<SkShader> fShader;
     sk_sp<SkColorFilter> fColorFilter;
     sk_sp<SkImageFilter> fImageFilter;
     sk_sp<SkMaskFilter> fMaskFilter;
     SkScalar fPaintAlpha;
 
     // Batching rules
     bool fResetEachQuad;
     int fTransformBatchCount;
 
     SkTArray<SkPoint> fDstClips;
-    SkTArray<SkMatrix> fPreViewMatrices;
+    SkTArray<SkMatrix> fPreViewXforms;
+    // ImageSetEntry does not yet have a fDstClipCount or fPreViewIdx field
+    SkTArray<int> fDstClipCounts;
+    SkTArray<int> fPreViewIdx;
     SkTArray<SkCanvas::ImageSetEntry> fSetEntries;
 
     SkMatrix fBaseCTM;
     int fBatchCount;
 
     TextureSetRenderer(const char* topBanner,
                        const char* bottomBanner,
                        sk_sp<SkImage> image,
                        sk_sp<SkShader> shader,
                        sk_sp<SkColorFilter> colorFilter,
                        sk_sp<SkImageFilter> imageFilter,
                        sk_sp<SkMaskFilter> maskFilter,
                        SkScalar paintAlpha,
                        bool resetEachQuad,
                        int transformBatchCount)
             : fTopBanner(topBanner)
             , fBottomBanner(bottomBanner)
             , fImage(std::move(image))
             , fShader(std::move(shader))
             , fColorFilter(std::move(colorFilter))
             , fImageFilter(std::move(imageFilter))
             , fMaskFilter(std::move(maskFilter))
             , fPaintAlpha(paintAlpha)
             , fResetEachQuad(resetEachQuad)
             , fTransformBatchCount(transformBatchCount)
             , fBatchCount(0) {
         SkASSERT(transformBatchCount >= 0 && (!resetEachQuad || transformBatchCount == 0));
     }
 
     void configureTilePaint(const SkRect& rect, SkPaint* paint) const {
         paint->setAntiAlias(true);
         paint->setFilterQuality(kLow_SkFilterQuality);
         paint->setBlendMode(SkBlendMode::kSrcOver);
 
         // Send non-white RGB, that should be ignored
         paint->setColor4f({1.f, 0.4f, 0.25f, fPaintAlpha}, nullptr);
 
 
         if (fShader) {
             if (fResetEachQuad) {
                 // Apply a local transform in the shader to map from the tile rectangle to (0,0,w,h)
                 static const SkRect kTarget = SkRect::MakeWH(kTileWidth, kTileHeight);
                 SkMatrix local = SkMatrix::MakeRectToRect(kTarget, rect,
                                                           SkMatrix::kFill_ScaleToFit);
                 paint->setShader(fShader->makeWithLocalMatrix(local));
             } else {
                 paint->setShader(fShader);
             }
         }
 
         paint->setColorFilter(fColorFilter);
         paint->setImageFilter(fImageFilter);
         paint->setMaskFilter(fMaskFilter);
     }
 
     int drawAndReset(SkCanvas* canvas) {
         // Early out if there's nothing to draw
         if (fSetEntries.count() == 0) {
-            SkASSERT(fDstClips.count() == 0 && fPreViewMatrices.count() == 0);
+            SkASSERT(fDstClips.count() == 0 && fPreViewXforms.count() == 0 &&
+                     fDstClipCounts.count() == 0 && fPreViewIdx.count() == 0);
             return 0;
         }
 
         if (!fResetEachQuad && fTransformBatchCount > 0) {
             // A batch is completed
             fBatchCount++;
             if (fBatchCount < fTransformBatchCount) {
                 // Haven't hit the point to submit yet, but end the current tile
                 return 0;
             }
 
             // Submitting all tiles back to where fBaseCTM was the canvas' matrix, while the
             // canvas currently has the CTM of the last tile batch, so reset it.
             canvas->setMatrix(fBaseCTM);
         }
 
+        // NOTE: Eventually these will just be stored as a field on each entry
+        SkASSERT(fDstClipCounts.count() == fSetEntries.count());
+        SkASSERT(fPreViewIdx.count() == fSetEntries.count());
+
 #ifdef SK_DEBUG
         int expectedDstClipCount = 0;
-        for (int i = 0; i < fSetEntries.count(); ++i) {
-            expectedDstClipCount += 4 * fSetEntries[i].fHasClip;
-            SkASSERT(fSetEntries[i].fMatrixIndex < 0 ||
-                     fSetEntries[i].fMatrixIndex < fPreViewMatrices.count());
+        for (int i = 0; i < fDstClipCounts.count(); ++i) {
+            expectedDstClipCount += fDstClipCounts[i];
+            SkASSERT(fPreViewIdx[i] < 0 || fPreViewIdx[i] < fPreViewXforms.count());
         }
         SkASSERT(expectedDstClipCount == fDstClips.count());
 #endif
 
         SkPaint paint;
         SkRect lastTileRect = fSetEntries[fSetEntries.count() - 1].fDstRect;
         this->configureTilePaint(lastTileRect, &paint);
 
-        canvas->experimental_DrawEdgeAAImageSet(
-                fSetEntries.begin(), fSetEntries.count(), fDstClips.begin(),
-                fPreViewMatrices.begin(), &paint, SkCanvas::kFast_SrcRectConstraint);
+        fDevice->tmp_drawImageSetV3(fSetEntries.begin(), fDstClipCounts.begin(),
+                                    fPreViewIdx.begin(), fSetEntries.count(),
+                                    fDstClips.begin(), fPreViewXforms.begin(),
+                                    paint, SkCanvas::kFast_SrcRectConstraint);
 
         // Reset for next tile
         fDstClips.reset();
-        fPreViewMatrices.reset();
+        fDstClipCounts.reset();
+        fPreViewXforms.reset();
+        fPreViewIdx.reset();
         fSetEntries.reset();
         fBatchCount = 0;
 
         return 1;
     }
 
     typedef ClipTileRenderer INHERITED;
 };
diff --git a/include/core/SkCanvas.h b/include/core/SkCanvas.h
index b134e37887..42c81a95ca 100644
--- a/include/core/SkCanvas.h
+++ b/include/core/SkCanvas.h
@@ -81,2320 +81,2260 @@ class SK_API SkCanvas {
 public:
 
     /** Allocates raster SkCanvas that will draw directly into pixels.
 
         SkCanvas is returned if all parameters are valid.
         Valid parameters include:
         info dimensions are zero or positive;
         info contains SkColorType and SkAlphaType supported by raster surface;
         pixels is not nullptr;
         rowBytes is zero or large enough to contain info width pixels of SkColorType.
 
         Pass zero for rowBytes to compute rowBytes from info width and size of pixel.
         If rowBytes is greater than zero, it must be equal to or greater than
         info width times bytes required for SkColorType.
 
         Pixel buffer size should be info height times computed rowBytes.
         Pixels are not initialized.
         To access pixels after drawing, call flush() or peekPixels().
 
         @param info      width, height, SkColorType, SkAlphaType, SkColorSpace, of raster surface;
                          width, or height, or both, may be zero
         @param pixels    pointer to destination pixels buffer
         @param rowBytes  interval from one SkSurface row to the next, or zero
         @param props     LCD striping orientation and setting for device independent fonts;
                          may be nullptr
         @return          SkCanvas if all parameters are valid; otherwise, nullptr
     */
     static std::unique_ptr<SkCanvas> MakeRasterDirect(const SkImageInfo& info, void* pixels,
                                                       size_t rowBytes,
                                                       const SkSurfaceProps* props = nullptr);
 
     /** Allocates raster SkCanvas specified by inline image specification. Subsequent SkCanvas
         calls draw into pixels.
         SkColorType is set to kN32_SkColorType.
         SkAlphaType is set to kPremul_SkAlphaType.
         To access pixels after drawing, call flush() or peekPixels().
 
         SkCanvas is returned if all parameters are valid.
         Valid parameters include:
         width and height are zero or positive;
         pixels is not nullptr;
         rowBytes is zero or large enough to contain width pixels of kN32_SkColorType.
 
         Pass zero for rowBytes to compute rowBytes from width and size of pixel.
         If rowBytes is greater than zero, it must be equal to or greater than
         width times bytes required for SkColorType.
 
         Pixel buffer size should be height times rowBytes.
 
         @param width     pixel column count on raster surface created; must be zero or greater
         @param height    pixel row count on raster surface created; must be zero or greater
         @param pixels    pointer to destination pixels buffer; buffer size should be height
                          times rowBytes
         @param rowBytes  interval from one SkSurface row to the next, or zero
         @return          SkCanvas if all parameters are valid; otherwise, nullptr
     */
     static std::unique_ptr<SkCanvas> MakeRasterDirectN32(int width, int height, SkPMColor* pixels,
                                                          size_t rowBytes) {
         return MakeRasterDirect(SkImageInfo::MakeN32Premul(width, height), pixels, rowBytes);
     }
 
     /** Creates an empty SkCanvas with no backing device or pixels, with
         a width and height of zero.
 
         @return  empty SkCanvas
     */
     SkCanvas();
 
     /** Creates SkCanvas of the specified dimensions without a SkSurface.
         Used by subclasses with custom implementations for draw member functions.
 
         If props equals nullptr, SkSurfaceProps are created with
         SkSurfaceProps::InitType settings, which choose the pixel striping
         direction and order. Since a platform may dynamically change its direction when
         the device is rotated, and since a platform may have multiple monitors with
         different characteristics, it is best not to rely on this legacy behavior.
 
         @param width   zero or greater
         @param height  zero or greater
         @param props   LCD striping orientation and setting for device independent fonts;
                        may be nullptr
         @return        SkCanvas placeholder with dimensions
     */
     SkCanvas(int width, int height, const SkSurfaceProps* props = nullptr);
 
     /** Private. For internal use only.
     */
     explicit SkCanvas(sk_sp<SkBaseDevice> device);
 
     /** Constructs a canvas that draws into bitmap.
         Sets SkSurfaceProps::kLegacyFontHost_InitType in constructed SkSurface.
 
         SkBitmap is copied so that subsequently editing bitmap will not affect
         constructed SkCanvas.
 
         May be deprecated in the future.
 
         @param bitmap  width, height, SkColorType, SkAlphaType, and pixel
                        storage of raster surface
         @return        SkCanvas that can be used to draw into bitmap
     */
     explicit SkCanvas(const SkBitmap& bitmap);
 
 #ifdef SK_BUILD_FOR_ANDROID_FRAMEWORK
     /** Private.
      */
     enum class ColorBehavior {
         kLegacy, //!< placeholder
     };
 
     /** Private. For use by Android framework only.
 
         @param bitmap    specifies a bitmap for the canvas to draw into
         @param behavior  specializes this constructor; value is unused
         @return          SkCanvas that can be used to draw into bitmap
     */
     SkCanvas(const SkBitmap& bitmap, ColorBehavior behavior);
 #endif
 
     /** Constructs a canvas that draws into bitmap.
         Use props to match the device characteristics, like LCD striping.
 
         bitmap is copied so that subsequently editing bitmap will not affect
         constructed SkCanvas.
 
         @param bitmap  width, height, SkColorType, SkAlphaType,
                        and pixel storage of raster surface
         @param props   order and orientation of RGB striping; and whether to use
                        device independent fonts
         @return        SkCanvas that can be used to draw into bitmap
     */
     SkCanvas(const SkBitmap& bitmap, const SkSurfaceProps& props);
 
     /** Draws saved layers, if any.
         Frees up resources used by SkCanvas.
     */
     virtual ~SkCanvas();
 
     /** Returns SkImageInfo for SkCanvas. If SkCanvas is not associated with raster surface or
         GPU surface, returned SkColorType is set to kUnknown_SkColorType.
 
         @return  dimensions and SkColorType of SkCanvas
     */
     SkImageInfo imageInfo() const;
 
     /** Copies SkSurfaceProps, if SkCanvas is associated with raster surface or
         GPU surface, and returns true. Otherwise, returns false and leave props unchanged.
 
         @param props  storage for writable SkSurfaceProps
         @return       true if SkSurfaceProps was copied
     */
     bool getProps(SkSurfaceProps* props) const;
 
     /** Triggers the immediate execution of all pending draw operations.
         If SkCanvas is associated with GPU surface, resolves all pending GPU operations.
         If SkCanvas is associated with raster surface, has no effect; raster draw
         operations are never deferred.
     */
     void flush();
 
     /** Gets the size of the base or root layer in global canvas coordinates. The
         origin of the base layer is always (0,0). The area available for drawing may be
         smaller (due to clipping or saveLayer).
 
         @return  integral width and height of base layer
     */
     virtual SkISize getBaseLayerSize() const;
 
     /** Creates SkSurface matching info and props, and associates it with SkCanvas.
         Returns nullptr if no match found.
 
         If props is nullptr, matches SkSurfaceProps in SkCanvas. If props is nullptr and SkCanvas
         does not have SkSurfaceProps, creates SkSurface with default SkSurfaceProps.
 
         @param info   width, height, SkColorType, SkAlphaType, and SkColorSpace
         @param props  SkSurfaceProps to match; may be nullptr to match SkCanvas
         @return       SkSurface matching info and props, or nullptr if no match is available
     */
     sk_sp<SkSurface> makeSurface(const SkImageInfo& info, const SkSurfaceProps* props = nullptr);
 
     /** Returns GPU context of the GPU surface associated with SkCanvas.
 
         @return  GPU context, if available; nullptr otherwise
     */
     virtual GrContext* getGrContext();
 
     /** Returns the pixel base address, SkImageInfo, rowBytes, and origin if the pixels
         can be read directly. The returned address is only valid
         while SkCanvas is in scope and unchanged. Any SkCanvas call or SkSurface call
         may invalidate the returned address and other returned values.
 
         If pixels are inaccessible, info, rowBytes, and origin are unchanged.
 
         @param info      storage for writable pixels' SkImageInfo; may be nullptr
         @param rowBytes  storage for writable pixels' row bytes; may be nullptr
         @param origin    storage for SkCanvas top layer origin, its top-left corner;
                          may be nullptr
         @return          address of pixels, or nullptr if inaccessible
     */
     void* accessTopLayerPixels(SkImageInfo* info, size_t* rowBytes, SkIPoint* origin = nullptr);
 
     /** Returns custom context that tracks the SkMatrix and clip.
 
         Use SkRasterHandleAllocator to blend Skia drawing with custom drawing, typically performed
         by the host platform user interface. The custom context returned is generated by
         SkRasterHandleAllocator::MakeCanvas, which creates a custom canvas with raster storage for
         the drawing destination.
 
         @return  context of custom allocation
     */
     SkRasterHandleAllocator::Handle accessTopRasterHandle() const;
 
     /** Returns true if SkCanvas has direct access to its pixels.
 
         Pixels are readable when SkBaseDevice is raster. Pixels are not readable when SkCanvas
         is returned from GPU surface, returned by SkDocument::beginPage, returned by
         SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility class
         like SkDebugCanvas.
 
         pixmap is valid only while SkCanvas is in scope and unchanged. Any
         SkCanvas or SkSurface call may invalidate the pixmap values.
 
         @param pixmap  storage for pixel state if pixels are readable; otherwise, ignored
         @return        true if SkCanvas has direct access to pixels
     */
     bool peekPixels(SkPixmap* pixmap);
 
     /** Copies SkRect of pixels from SkCanvas into dstPixels. SkMatrix and clip are
         ignored.
 
         Source SkRect corners are (srcX, srcY) and (imageInfo().width(), imageInfo().height()).
         Destination SkRect corners are (0, 0) and (dstInfo.width(), dstInfo.height()).
         Copies each readable pixel intersecting both rectangles, without scaling,
         converting to dstInfo.colorType() and dstInfo.alphaType() if required.
 
         Pixels are readable when SkBaseDevice is raster, or backed by a GPU.
         Pixels are not readable when SkCanvas is returned by SkDocument::beginPage,
         returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility
         class like SkDebugCanvas.
 
         The destination pixel storage must be allocated by the caller.
 
         Pixel values are converted only if SkColorType and SkAlphaType
         do not match. Only pixels within both source and destination rectangles
         are copied. dstPixels contents outside SkRect intersection are unchanged.
 
         Pass negative values for srcX or srcY to offset pixels across or down destination.
 
         Does not copy, and returns false if:
         - Source and destination rectangles do not intersect.
         - SkCanvas pixels could not be converted to dstInfo.colorType() or dstInfo.alphaType().
         - SkCanvas pixels are not readable; for instance, SkCanvas is document-based.
         - dstRowBytes is too small to contain one row of pixels.
 
         @param dstInfo      width, height, SkColorType, and SkAlphaType of dstPixels
         @param dstPixels    storage for pixels; dstInfo.height() times dstRowBytes, or larger
         @param dstRowBytes  size of one destination row; dstInfo.width() times pixel size, or larger
         @param srcX         offset into readable pixels on x-axis; may be negative
         @param srcY         offset into readable pixels on y-axis; may be negative
         @return             true if pixels were copied
     */
     bool readPixels(const SkImageInfo& dstInfo, void* dstPixels, size_t dstRowBytes,
                     int srcX, int srcY);
 
     /** Copies SkRect of pixels from SkCanvas into pixmap. SkMatrix and clip are
         ignored.
 
         Source SkRect corners are (srcX, srcY) and (imageInfo().width(), imageInfo().height()).
         Destination SkRect corners are (0, 0) and (pixmap.width(), pixmap.height()).
         Copies each readable pixel intersecting both rectangles, without scaling,
         converting to pixmap.colorType() and pixmap.alphaType() if required.
 
         Pixels are readable when SkBaseDevice is raster, or backed by a GPU.
         Pixels are not readable when SkCanvas is returned by SkDocument::beginPage,
         returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility
         class like SkDebugCanvas.
 
         Caller must allocate pixel storage in pixmap if needed.
 
         Pixel values are converted only if SkColorType and SkAlphaType
         do not match. Only pixels within both source and destination SkRect
         are copied. pixmap pixels contents outside SkRect intersection are unchanged.
 
         Pass negative values for srcX or srcY to offset pixels across or down pixmap.
 
         Does not copy, and returns false if:
         - Source and destination rectangles do not intersect.
         - SkCanvas pixels could not be converted to pixmap.colorType() or pixmap.alphaType().
         - SkCanvas pixels are not readable; for instance, SkCanvas is document-based.
         - SkPixmap pixels could not be allocated.
         - pixmap.rowBytes() is too small to contain one row of pixels.
 
         @param pixmap  storage for pixels copied from SkCanvas
         @param srcX    offset into readable pixels on x-axis; may be negative
         @param srcY    offset into readable pixels on y-axis; may be negative
         @return        true if pixels were copied
     */
     bool readPixels(const SkPixmap& pixmap, int srcX, int srcY);
 
     /** Copies SkRect of pixels from SkCanvas into bitmap. SkMatrix and clip are
         ignored.
 
         Source SkRect corners are (srcX, srcY) and (imageInfo().width(), imageInfo().height()).
         Destination SkRect corners are (0, 0) and (bitmap.width(), bitmap.height()).
         Copies each readable pixel intersecting both rectangles, without scaling,
         converting to bitmap.colorType() and bitmap.alphaType() if required.
 
         Pixels are readable when SkBaseDevice is raster, or backed by a GPU.
         Pixels are not readable when SkCanvas is returned by SkDocument::beginPage,
         returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility
         class like SkDebugCanvas.
 
         Caller must allocate pixel storage in bitmap if needed.
 
         SkBitmap values are converted only if SkColorType and SkAlphaType
         do not match. Only pixels within both source and destination rectangles
         are copied. SkBitmap pixels outside SkRect intersection are unchanged.
 
         Pass negative values for srcX or srcY to offset pixels across or down bitmap.
 
         Does not copy, and returns false if:
         - Source and destination rectangles do not intersect.
         - SkCanvas pixels could not be converted to bitmap.colorType() or bitmap.alphaType().
         - SkCanvas pixels are not readable; for instance, SkCanvas is document-based.
         - bitmap pixels could not be allocated.
         - bitmap.rowBytes() is too small to contain one row of pixels.
 
         @param bitmap  storage for pixels copied from SkCanvas
         @param srcX    offset into readable pixels on x-axis; may be negative
         @param srcY    offset into readable pixels on y-axis; may be negative
         @return        true if pixels were copied
     */
     bool readPixels(const SkBitmap& bitmap, int srcX, int srcY);
 
     /** Copies SkRect from pixels to SkCanvas. SkMatrix and clip are ignored.
         Source SkRect corners are (0, 0) and (info.width(), info.height()).
         Destination SkRect corners are (x, y) and
         (imageInfo().width(), imageInfo().height()).
 
         Copies each readable pixel intersecting both rectangles, without scaling,
         converting to imageInfo().colorType() and imageInfo().alphaType() if required.
 
         Pixels are writable when SkBaseDevice is raster, or backed by a GPU.
         Pixels are not writable when SkCanvas is returned by SkDocument::beginPage,
         returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility
         class like SkDebugCanvas.
 
         Pixel values are converted only if SkColorType and SkAlphaType
         do not match. Only pixels within both source and destination rectangles
         are copied. SkCanvas pixels outside SkRect intersection are unchanged.
 
         Pass negative values for x or y to offset pixels to the left or
         above SkCanvas pixels.
 
         Does not copy, and returns false if:
         - Source and destination rectangles do not intersect.
         - pixels could not be converted to SkCanvas imageInfo().colorType() or
         imageInfo().alphaType().
         - SkCanvas pixels are not writable; for instance, SkCanvas is document-based.
         - rowBytes is too small to contain one row of pixels.
 
         @param info      width, height, SkColorType, and SkAlphaType of pixels
         @param pixels    pixels to copy, of size info.height() times rowBytes, or larger
         @param rowBytes  size of one row of pixels; info.width() times pixel size, or larger
         @param x         offset into SkCanvas writable pixels on x-axis; may be negative
         @param y         offset into SkCanvas writable pixels on y-axis; may be negative
         @return          true if pixels were written to SkCanvas
     */
     bool writePixels(const SkImageInfo& info, const void* pixels, size_t rowBytes, int x, int y);
 
     /** Copies SkRect from pixels to SkCanvas. SkMatrix and clip are ignored.
         Source SkRect corners are (0, 0) and (bitmap.width(), bitmap.height()).
 
         Destination SkRect corners are (x, y) and
         (imageInfo().width(), imageInfo().height()).
 
         Copies each readable pixel intersecting both rectangles, without scaling,
         converting to imageInfo().colorType() and imageInfo().alphaType() if required.
 
         Pixels are writable when SkBaseDevice is raster, or backed by a GPU.
         Pixels are not writable when SkCanvas is returned by SkDocument::beginPage,
         returned by SkPictureRecorder::beginRecording, or SkCanvas is the base of a utility
         class like SkDebugCanvas.
 
         Pixel values are converted only if SkColorType and SkAlphaType
         do not match. Only pixels within both source and destination rectangles
         are copied. SkCanvas pixels outside SkRect intersection are unchanged.
 
         Pass negative values for x or y to offset pixels to the left or
         above SkCanvas pixels.
 
         Does not copy, and returns false if:
         - Source and destination rectangles do not intersect.
         - bitmap does not have allocated pixels.
         - bitmap pixels could not be converted to SkCanvas imageInfo().colorType() or
         imageInfo().alphaType().
         - SkCanvas pixels are not writable; for instance, SkCanvas is document based.
         - bitmap pixels are inaccessible; for instance, bitmap wraps a texture.
 
         @param bitmap  contains pixels copied to SkCanvas
         @param x       offset into SkCanvas writable pixels on x-axis; may be negative
         @param y       offset into SkCanvas writable pixels on y-axis; may be negative
         @return        true if pixels were written to SkCanvas
     */
     bool writePixels(const SkBitmap& bitmap, int x, int y);
 
     /** Saves SkMatrix and clip.
         Calling restore() discards changes to SkMatrix and clip,
         restoring the SkMatrix and clip to their state when save() was called.
 
         SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat(), setMatrix(),
         and resetMatrix(). Clip may be changed by clipRect(), clipRRect(), clipPath(), clipRegion().
 
         Saved SkCanvas state is put on a stack; multiple calls to save() should be balance
         by an equal number of calls to restore().
 
         Call restoreToCount() with result to restore this and subsequent saves.
 
         @return  depth of saved stack
     */
     int save();
 
     /** Saves SkMatrix and clip, and allocates a SkBitmap for subsequent drawing.
         Calling restore() discards changes to SkMatrix and clip, and draws the SkBitmap.
 
         SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat(),
         setMatrix(), and resetMatrix(). Clip may be changed by clipRect(), clipRRect(),
         clipPath(), clipRegion().
 
         SkRect bounds suggests but does not define the SkBitmap size. To clip drawing to
         a specific rectangle, use clipRect().
 
         Optional SkPaint paint applies alpha, SkColorFilter, SkImageFilter, and
         SkBlendMode when restore() is called.
 
         Call restoreToCount() with returned value to restore this and subsequent saves.
 
         @param bounds  hint to limit the size of the layer; may be nullptr
         @param paint   graphics state for layer; may be nullptr
         @return        depth of saved stack
     */
     int saveLayer(const SkRect* bounds, const SkPaint* paint);
 
     /** Saves SkMatrix and clip, and allocates a SkBitmap for subsequent drawing.
         Calling restore() discards changes to SkMatrix and clip, and draws the SkBitmap.
 
         SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat(),
         setMatrix(), and resetMatrix(). Clip may be changed by clipRect(), clipRRect(),
         clipPath(), clipRegion().
 
         SkRect bounds suggests but does not define the layer size. To clip drawing to
         a specific rectangle, use clipRect().
 
         Optional SkPaint paint applies alpha, SkColorFilter, SkImageFilter, and
         SkBlendMode when restore() is called.
 
         Call restoreToCount() with returned value to restore this and subsequent saves.
 
         @param bounds  hint to limit the size of layer; may be nullptr
         @param paint   graphics state for layer; may be nullptr
         @return        depth of saved stack
     */
     int saveLayer(const SkRect& bounds, const SkPaint* paint) {
         return this->saveLayer(&bounds, paint);
     }
 
     /** Saves SkMatrix and clip, and allocates SkBitmap for subsequent drawing.
 
         Calling restore() discards changes to SkMatrix and clip,
         and blends layer with alpha opacity onto prior layer.
 
         SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat(),
         setMatrix(), and resetMatrix(). Clip may be changed by clipRect(), clipRRect(),
         clipPath(), clipRegion().
 
         SkRect bounds suggests but does not define layer size. To clip drawing to
         a specific rectangle, use clipRect().
 
         alpha of zero is fully transparent, 255 is fully opaque.
 
         Call restoreToCount() with returned value to restore this and subsequent saves.
 
         @param bounds  hint to limit the size of layer; may be nullptr
         @param alpha   opacity of layer
         @return        depth of saved stack
     */
     int saveLayerAlpha(const SkRect* bounds, U8CPU alpha);
 
     /** \enum SkCanvas::SaveLayerFlagsSet
         SaveLayerFlags provides options that may be used in any combination in SaveLayerRec,
         defining how layer allocated by saveLayer() operates. It may be set to zero,
         kPreserveLCDText_SaveLayerFlag, kInitWithPrevious_SaveLayerFlag, or both flags.
     */
     enum SaveLayerFlagsSet {
         // kPreserveLCDText_SaveLayerFlag  = 1 << 1, (no longer used)
         kInitWithPrevious_SaveLayerFlag = 1 << 2, //!< initializes with previous contents
         kMaskAgainstCoverage_EXPERIMENTAL_DONT_USE_SaveLayerFlag =
                                           1 << 3, //!< experimental: do not use
 
 #ifdef SK_SUPPORT_LEGACY_CLIPTOLAYERFLAG
         kDontClipToLayer_Legacy_SaveLayerFlag =
            kDontClipToLayer_PrivateSaveLayerFlag, //!< deprecated
 #endif
     };
 
     typedef uint32_t SaveLayerFlags;
 
     /** \struct SkCanvas::SaveLayerRec
         SaveLayerRec contains the state used to create the layer.
     */
     struct SaveLayerRec {
 
         /** Sets fBounds, fPaint, and fBackdrop to nullptr. Clears fSaveLayerFlags.
 
             @return  empty SaveLayerRec
         */
         SaveLayerRec() {}
 
         /** Sets fBounds, fPaint, and fSaveLayerFlags; sets fBackdrop to nullptr.
 
             @param bounds          layer dimensions; may be nullptr
             @param paint           applied to layer when overlaying prior layer; may be nullptr
             @param saveLayerFlags  SaveLayerRec options to modify layer
             @return                SaveLayerRec with empty fBackdrop
         */
         SaveLayerRec(const SkRect* bounds, const SkPaint* paint, SaveLayerFlags saveLayerFlags = 0)
             : fBounds(bounds)
             , fPaint(paint)
             , fSaveLayerFlags(saveLayerFlags)
         {}
 
         /** Sets fBounds, fPaint, fBackdrop, and fSaveLayerFlags.
 
             @param bounds          layer dimensions; may be nullptr
             @param paint           applied to layer when overlaying prior layer;
                                    may be nullptr
             @param backdrop        If not null, this causes the current layer to be filtered by
                                    backdrop, and then drawn into the new layer
                                    (respecting the current clip).
                                    If null, the new layer is initialized with transparent-black.
             @param saveLayerFlags  SaveLayerRec options to modify layer
             @return                SaveLayerRec fully specified
         */
         SaveLayerRec(const SkRect* bounds, const SkPaint* paint, const SkImageFilter* backdrop,
                      SaveLayerFlags saveLayerFlags)
             : fBounds(bounds)
             , fPaint(paint)
             , fBackdrop(backdrop)
             , fSaveLayerFlags(saveLayerFlags)
         {}
 
         /** Experimental. Not ready for general use.
             Sets fBounds, fPaint, fBackdrop, fClipMask, fClipMatrix, and fSaveLayerFlags.
             clipMatrix uses alpha channel of image, transformed by clipMatrix, to clip
             layer when drawn to SkCanvas.
 
             Implementation is not complete; has no effect if SkBaseDevice is GPU-backed.
 
             @param bounds          layer dimensions; may be nullptr
             @param paint           graphics state applied to layer when overlaying prior
                                    layer; may be nullptr
             @param backdrop        If not null, this causes the current layer to be filtered by
                                    backdrop, and then drawn into the new layer
                                    (respecting the current clip).
                                    If null, the new layer is initialized with transparent-black.
             @param clipMask        clip applied to layer; may be nullptr
             @param clipMatrix      matrix applied to clipMask; may be nullptr to use
                                    identity matrix
             @param saveLayerFlags  SaveLayerRec options to modify layer
             @return                SaveLayerRec fully specified
         */
         SaveLayerRec(const SkRect* bounds, const SkPaint* paint, const SkImageFilter* backdrop,
                      const SkImage* clipMask, const SkMatrix* clipMatrix,
                      SaveLayerFlags saveLayerFlags)
             : fBounds(bounds)
             , fPaint(paint)
             , fBackdrop(backdrop)
             , fClipMask(clipMask)
             , fClipMatrix(clipMatrix)
             , fSaveLayerFlags(saveLayerFlags)
         {}
 
         /** hints at layer size limit */
         const SkRect*        fBounds         = nullptr;
 
         /** modifies overlay */
         const SkPaint*       fPaint          = nullptr;
 
         /**
          *  If not null, this triggers the same initialization behavior as setting
          *  kInitWithPrevious_SaveLayerFlag on fSaveLayerFlags: the current layer is copied into
          *  the new layer, rather than initializing the new layer with transparent-black.
          *  This is then filtered by fBackdrop (respecting the current clip).
          */
         const SkImageFilter* fBackdrop       = nullptr;
 
         /** clips layer with mask alpha */
         const SkImage*       fClipMask       = nullptr;
 
         /** transforms mask alpha used to clip */
         const SkMatrix*      fClipMatrix     = nullptr;
 
         /** preserves LCD text, creates with prior layer contents */
         SaveLayerFlags       fSaveLayerFlags = 0;
     };
 
     /** Saves SkMatrix and clip, and allocates SkBitmap for subsequent drawing.
 
         Calling restore() discards changes to SkMatrix and clip,
         and blends SkBitmap with alpha opacity onto the prior layer.
 
         SkMatrix may be changed by translate(), scale(), rotate(), skew(), concat(),
         setMatrix(), and resetMatrix(). Clip may be changed by clipRect(), clipRRect(),
         clipPath(), clipRegion().
 
         SaveLayerRec contains the state used to create the layer.
 
         Call restoreToCount() with returned value to restore this and subsequent saves.
 
         @param layerRec  layer state
         @return          depth of save state stack before this call was made.
     */
     int saveLayer(const SaveLayerRec& layerRec);
 
     /** Removes changes to SkMatrix and clip since SkCanvas state was
         last saved. The state is removed from the stack.
 
         Does nothing if the stack is empty.
     */
     void restore();
 
     /** Returns the number of saved states, each containing: SkMatrix and clip.
         Equals the number of save() calls less the number of restore() calls plus one.
         The save count of a new canvas is one.
 
         @return  depth of save state stack
     */
     int getSaveCount() const;
 
     /** Restores state to SkMatrix and clip values when save(), saveLayer(),
         saveLayerPreserveLCDTextRequests(), or saveLayerAlpha() returned saveCount.
 
         Does nothing if saveCount is greater than state stack count.
         Restores state to initial values if saveCount is less than or equal to one.
 
         @param saveCount  depth of state stack to restore
     */
     void restoreToCount(int saveCount);
 
     /** Translates SkMatrix by dx along the x-axis and dy along the y-axis.
 
         Mathematically, replaces SkMatrix with a translation matrix
         premultiplied with SkMatrix.
 
         This has the effect of moving the drawing by (dx, dy) before transforming
         the result with SkMatrix.
 
         @param dx  distance to translate on x-axis
         @param dy  distance to translate on y-axis
     */
     void translate(SkScalar dx, SkScalar dy);
 
     /** Scales SkMatrix by sx on the x-axis and sy on the y-axis.
 
         Mathematically, replaces SkMatrix with a scale matrix
         premultiplied with SkMatrix.
 
         This has the effect of scaling the drawing by (sx, sy) before transforming
         the result with SkMatrix.
 
         @param sx  amount to scale on x-axis
         @param sy  amount to scale on y-axis
     */
     void scale(SkScalar sx, SkScalar sy);
 
     /** Rotates SkMatrix by degrees. Positive degrees rotates clockwise.
 
         Mathematically, replaces SkMatrix with a rotation matrix
         premultiplied with SkMatrix.
 
         This has the effect of rotating the drawing by degrees before transforming
         the result with SkMatrix.
 
         @param degrees  amount to rotate, in degrees
     */
     void rotate(SkScalar degrees);
 
     /** Rotates SkMatrix by degrees about a point at (px, py). Positive degrees rotates
         clockwise.
 
         Mathematically, constructs a rotation matrix; premultiplies the rotation matrix by
         a translation matrix; then replaces SkMatrix with the resulting matrix
         premultiplied with SkMatrix.
 
         This has the effect of rotating the drawing about a given point before
         transforming the result with SkMatrix.
 
         @param degrees  amount to rotate, in degrees
         @param px       x-axis value of the point to rotate about
         @param py       y-axis value of the point to rotate about
     */
     void rotate(SkScalar degrees, SkScalar px, SkScalar py);
 
     /** Skews SkMatrix by sx on the x-axis and sy on the y-axis. A positive value of sx
         skews the drawing right as y-axis values increase; a positive value of sy skews
         the drawing down as x-axis values increase.
 
         Mathematically, replaces SkMatrix with a skew matrix premultiplied with SkMatrix.
 
         This has the effect of skewing the drawing by (sx, sy) before transforming
         the result with SkMatrix.
 
         @param sx  amount to skew on x-axis
         @param sy  amount to skew on y-axis
     */
     void skew(SkScalar sx, SkScalar sy);
 
     /** Replaces SkMatrix with matrix premultiplied with existing SkMatrix.
 
         This has the effect of transforming the drawn geometry by matrix, before
         transforming the result with existing SkMatrix.
 
         @param matrix  matrix to premultiply with existing SkMatrix
     */
     void concat(const SkMatrix& matrix);
 
     /** Replaces SkMatrix with matrix.
         Unlike concat(), any prior matrix state is overwritten.
 
         @param matrix  matrix to copy, replacing existing SkMatrix
     */
     void setMatrix(const SkMatrix& matrix);
 
     /** Sets SkMatrix to the identity matrix.
         Any prior matrix state is overwritten.
     */
     void resetMatrix();
 
     /** Replaces clip with the intersection or difference of clip and rect,
         with an aliased or anti-aliased clip edge. rect is transformed by SkMatrix
         before it is combined with clip.
 
         @param rect         SkRect to combine with clip
         @param op           SkClipOp to apply to clip
         @param doAntiAlias  true if clip is to be anti-aliased
     */
     void clipRect(const SkRect& rect, SkClipOp op, bool doAntiAlias);
 
     /** Replaces clip with the intersection or difference of clip and rect.
         Resulting clip is aliased; pixels are fully contained by the clip.
         rect is transformed by SkMatrix before it is combined with clip.
 
         @param rect  SkRect to combine with clip
         @param op    SkClipOp to apply to clip
     */
     void clipRect(const SkRect& rect, SkClipOp op) {
         this->clipRect(rect, op, false);
     }
 
     /** Replaces clip with the intersection of clip and rect.
         Resulting clip is aliased; pixels are fully contained by the clip.
         rect is transformed by SkMatrix
         before it is combined with clip.
 
         @param rect         SkRect to combine with clip
         @param doAntiAlias  true if clip is to be anti-aliased
     */
     void clipRect(const SkRect& rect, bool doAntiAlias = false) {
         this->clipRect(rect, SkClipOp::kIntersect, doAntiAlias);
     }
 
     /** Sets the maximum clip rectangle, which can be set by clipRect(), clipRRect() and
         clipPath() and intersect the current clip with the specified rect.
         The maximum clip affects only future clipping operations; it is not retroactive.
         The clip restriction is not recorded in pictures.
 
         Pass an empty rect to disable maximum clip.
         This private API is for use by Android framework only.
 
         @param rect  maximum allowed clip in device coordinates
     */
     void androidFramework_setDeviceClipRestriction(const SkIRect& rect);
 
     /** Replaces clip with the intersection or difference of clip and rrect,
         with an aliased or anti-aliased clip edge.
         rrect is transformed by SkMatrix
         before it is combined with clip.
 
         @param rrect        SkRRect to combine with clip
         @param op           SkClipOp to apply to clip
         @param doAntiAlias  true if clip is to be anti-aliased
     */
     void clipRRect(const SkRRect& rrect, SkClipOp op, bool doAntiAlias);
 
     /** Replaces clip with the intersection or difference of clip and rrect.
         Resulting clip is aliased; pixels are fully contained by the clip.
         rrect is transformed by SkMatrix before it is combined with clip.
 
         @param rrect  SkRRect to combine with clip
         @param op     SkClipOp to apply to clip
     */
     void clipRRect(const SkRRect& rrect, SkClipOp op) {
         this->clipRRect(rrect, op, false);
     }
 
     /** Replaces clip with the intersection of clip and rrect,
         with an aliased or anti-aliased clip edge.
         rrect is transformed by SkMatrix before it is combined with clip.
 
         @param rrect        SkRRect to combine with clip
         @param doAntiAlias  true if clip is to be anti-aliased
     */
     void clipRRect(const SkRRect& rrect, bool doAntiAlias = false) {
         this->clipRRect(rrect, SkClipOp::kIntersect, doAntiAlias);
     }
 
     /** Replaces clip with the intersection or difference of clip and path,
         with an aliased or anti-aliased clip edge. SkPath::FillType determines if path
         describes the area inside or outside its contours; and if path contour overlaps
         itself or another path contour, whether the overlaps form part of the area.
         path is transformed by SkMatrix before it is combined with clip.
 
         @param path         SkPath to combine with clip
         @param op           SkClipOp to apply to clip
         @param doAntiAlias  true if clip is to be anti-aliased
     */
     void clipPath(const SkPath& path, SkClipOp op, bool doAntiAlias);
 
     /** Replaces clip with the intersection or difference of clip and path.
         Resulting clip is aliased; pixels are fully contained by the clip.
         SkPath::FillType determines if path
         describes the area inside or outside its contours; and if path contour overlaps
         itself or another path contour, whether the overlaps form part of the area.
         path is transformed by SkMatrix
         before it is combined with clip.
 
         @param path  SkPath to combine with clip
         @param op    SkClipOp to apply to clip
     */
     void clipPath(const SkPath& path, SkClipOp op) {
         this->clipPath(path, op, false);
     }
 
     /** Replaces clip with the intersection of clip and path.
         Resulting clip is aliased; pixels are fully contained by the clip.
         SkPath::FillType determines if path
         describes the area inside or outside its contours; and if path contour overlaps
         itself or another path contour, whether the overlaps form part of the area.
         path is transformed by SkMatrix before it is combined with clip.
 
         @param path         SkPath to combine with clip
         @param doAntiAlias  true if clip is to be anti-aliased
     */
     void clipPath(const SkPath& path, bool doAntiAlias = false) {
         this->clipPath(path, SkClipOp::kIntersect, doAntiAlias);
     }
 
     /** Experimental. For testing only.
         Set to simplify clip stack using PathOps.
     */
     void setAllowSimplifyClip(bool allow) {
         fAllowSimplifyClip = allow;
     }
 
     /** Replaces clip with the intersection or difference of clip and SkRegion deviceRgn.
         Resulting clip is aliased; pixels are fully contained by the clip.
         deviceRgn is unaffected by SkMatrix.
 
         @param deviceRgn  SkRegion to combine with clip
         @param op         SkClipOp to apply to clip
     */
     void clipRegion(const SkRegion& deviceRgn, SkClipOp op = SkClipOp::kIntersect);
 
     /** Returns true if SkRect rect, transformed by SkMatrix, can be quickly determined to be
         outside of clip. May return false even though rect is outside of clip.
 
         Use to check if an area to be drawn is clipped out, to skip subsequent draw calls.
 
         @param rect  SkRect to compare with clip
         @return      true if rect, transformed by SkMatrix, does not intersect clip
     */
     bool quickReject(const SkRect& rect) const;
 
     /** Returns true if path, transformed by SkMatrix, can be quickly determined to be
         outside of clip. May return false even though path is outside of clip.
 
         Use to check if an area to be drawn is clipped out, to skip subsequent draw calls.
 
         @param path  SkPath to compare with clip
         @return      true if path, transformed by SkMatrix, does not intersect clip
     */
     bool quickReject(const SkPath& path) const;
 
     /** Returns bounds of clip, transformed by inverse of SkMatrix. If clip is empty,
         return SkRect::MakeEmpty, where all SkRect sides equal zero.
 
         SkRect returned is outset by one to account for partial pixel coverage if clip
         is anti-aliased.
 
         @return  bounds of clip in local coordinates
     */
     SkRect getLocalClipBounds() const;
 
     /** Returns bounds of clip, transformed by inverse of SkMatrix. If clip is empty,
         return false, and set bounds to SkRect::MakeEmpty, where all SkRect sides equal zero.
 
         bounds is outset by one to account for partial pixel coverage if clip
         is anti-aliased.
 
         @param bounds  SkRect of clip in local coordinates
         @return        true if clip bounds is not empty
     */
     bool getLocalClipBounds(SkRect* bounds) const {
         *bounds = this->getLocalClipBounds();
         return !bounds->isEmpty();
     }
 
     /** Returns SkIRect bounds of clip, unaffected by SkMatrix. If clip is empty,
         return SkRect::MakeEmpty, where all SkRect sides equal zero.
 
         Unlike getLocalClipBounds(), returned SkIRect is not outset.
 
         @return  bounds of clip in SkBaseDevice coordinates
     */
     SkIRect getDeviceClipBounds() const;
 
     /** Returns SkIRect bounds of clip, unaffected by SkMatrix. If clip is empty,
         return false, and set bounds to SkRect::MakeEmpty, where all SkRect sides equal zero.
 
         Unlike getLocalClipBounds(), bounds is not outset.
 
         @param bounds  SkRect of clip in device coordinates
         @return        true if clip bounds is not empty
     */
     bool getDeviceClipBounds(SkIRect* bounds) const {
         *bounds = this->getDeviceClipBounds();
         return !bounds->isEmpty();
     }
 
     /** Fills clip with color color.
         mode determines how ARGB is combined with destination.
 
         @param color  unpremultiplied ARGB
         @param mode   SkBlendMode used to combine source color and destination
     */
     void drawColor(SkColor color, SkBlendMode mode = SkBlendMode::kSrcOver);
 
     /** Fills clip with color color using SkBlendMode::kSrc.
         This has the effect of replacing all pixels contained by clip with color.
 
         @param color  unpremultiplied ARGB
     */
     void clear(SkColor color) {
         this->drawColor(color, SkBlendMode::kSrc);
     }
 
     /** Makes SkCanvas contents undefined. Subsequent calls that read SkCanvas pixels,
         such as drawing with SkBlendMode, return undefined results. discard() does
         not change clip or SkMatrix.
 
         discard() may do nothing, depending on the implementation of SkSurface or SkBaseDevice
         that created SkCanvas.
 
         discard() allows optimized performance on subsequent draws by removing
         cached data associated with SkSurface or SkBaseDevice.
         It is not necessary to call discard() once done with SkCanvas;
         any cached data is deleted when owning SkSurface or SkBaseDevice is deleted.
     */
     void discard() { this->onDiscard(); }
 
     /** Fills clip with SkPaint paint. SkPaint components SkMaskFilter, SkShader,
         SkColorFilter, SkImageFilter, and SkBlendMode affect drawing;
         SkPathEffect in paint is ignored.
 
         @param paint  graphics state used to fill SkCanvas
     */
     void drawPaint(const SkPaint& paint);
 
     /** \enum SkCanvas::PointMode
         Selects if an array of points are drawn as discrete points, as lines, or as
         an open polygon.
     */
     enum PointMode {
         kPoints_PointMode,  //!< draw each point separately
         kLines_PointMode,   //!< draw each pair of points as a line segment
         kPolygon_PointMode, //!< draw the array of points as a open polygon
     };
 
     /** Draws pts using clip, SkMatrix and SkPaint paint.
         count is the number of points; if count is less than one, has no effect.
         mode may be one of: kPoints_PointMode, kLines_PointMode, or kPolygon_PointMode.
 
         If mode is kPoints_PointMode, the shape of point drawn depends on paint
         SkPaint::Cap. If paint is set to SkPaint::kRound_Cap, each point draws a
         circle of diameter SkPaint stroke width. If paint is set to SkPaint::kSquare_Cap
         or SkPaint::kButt_Cap, each point draws a square of width and height
         SkPaint stroke width.
 
         If mode is kLines_PointMode, each pair of points draws a line segment.
         One line is drawn for every two points; each point is used once. If count is odd,
         the final point is ignored.
 
         If mode is kPolygon_PointMode, each adjacent pair of points draws a line segment.
         count minus one lines are drawn; the first and last point are used once.
 
         Each line segment respects paint SkPaint::Cap and SkPaint stroke width.
         SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style.
 
         Always draws each element one at a time; is not affected by
         SkPaint::Join, and unlike drawPath(), does not create a mask from all points
         and lines before drawing.
 
         @param mode   whether pts draws points or lines
         @param count  number of points in the array
         @param pts    array of points to draw
         @param paint  stroke, blend, color, and so on, used to draw
     */
     void drawPoints(PointMode mode, size_t count, const SkPoint pts[], const SkPaint& paint);
 
     /** Draws point at (x, y) using clip, SkMatrix and SkPaint paint.
 
         The shape of point drawn depends on paint SkPaint::Cap.
         If paint is set to SkPaint::kRound_Cap, draw a circle of diameter
         SkPaint stroke width. If paint is set to SkPaint::kSquare_Cap or SkPaint::kButt_Cap,
         draw a square of width and height SkPaint stroke width.
         SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style.
 
         @param x      left edge of circle or square
         @param y      top edge of circle or square
         @param paint  stroke, blend, color, and so on, used to draw
     */
     void drawPoint(SkScalar x, SkScalar y, const SkPaint& paint);
 
     /** Draws point p using clip, SkMatrix and SkPaint paint.
 
         The shape of point drawn depends on paint SkPaint::Cap.
         If paint is set to SkPaint::kRound_Cap, draw a circle of diameter
         SkPaint stroke width. If paint is set to SkPaint::kSquare_Cap or SkPaint::kButt_Cap,
         draw a square of width and height SkPaint stroke width.
         SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style.
 
         @param p      top-left edge of circle or square
         @param paint  stroke, blend, color, and so on, used to draw
     */
     void drawPoint(SkPoint p, const SkPaint& paint) {
         this->drawPoint(p.x(), p.y(), paint);
     }
 
     /** Draws line segment from (x0, y0) to (x1, y1) using clip, SkMatrix, and SkPaint paint.
         In paint: SkPaint stroke width describes the line thickness;
         SkPaint::Cap draws the end rounded or square;
         SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style.
 
         @param x0     start of line segment on x-axis
         @param y0     start of line segment on y-axis
         @param x1     end of line segment on x-axis
         @param y1     end of line segment on y-axis
         @param paint  stroke, blend, color, and so on, used to draw
     */
     void drawLine(SkScalar x0, SkScalar y0, SkScalar x1, SkScalar y1, const SkPaint& paint);
 
     /** Draws line segment from p0 to p1 using clip, SkMatrix, and SkPaint paint.
         In paint: SkPaint stroke width describes the line thickness;
         SkPaint::Cap draws the end rounded or square;
         SkPaint::Style is ignored, as if were set to SkPaint::kStroke_Style.
 
         @param p0     start of line segment
         @param p1     end of line segment
         @param paint  stroke, blend, color, and so on, used to draw
     */
     void drawLine(SkPoint p0, SkPoint p1, const SkPaint& paint) {
         this->drawLine(p0.x(), p0.y(), p1.x(), p1.y(), paint);
     }
 
     /** Draws SkRect rect using clip, SkMatrix, and SkPaint paint.
         In paint: SkPaint::Style determines if rectangle is stroked or filled;
         if stroked, SkPaint stroke width describes the line thickness, and
         SkPaint::Join draws the corners rounded or square.
 
         @param rect   rectangle to draw
         @param paint  stroke or fill, blend, color, and so on, used to draw
     */
     void drawRect(const SkRect& rect, const SkPaint& paint);
 
     /** Draws SkIRect rect using clip, SkMatrix, and SkPaint paint.
         In paint: SkPaint::Style determines if rectangle is stroked or filled;
         if stroked, SkPaint stroke width describes the line thickness, and
         SkPaint::Join draws the corners rounded or square.
 
         @param rect   rectangle to draw
         @param paint  stroke or fill, blend, color, and so on, used to draw
     */
     void drawIRect(const SkIRect& rect, const SkPaint& paint) {
         SkRect r;
         r.set(rect);    // promotes the ints to scalars
         this->drawRect(r, paint);
     }
 
     /** Draws SkRegion region using clip, SkMatrix, and SkPaint paint.
         In paint: SkPaint::Style determines if rectangle is stroked or filled;
         if stroked, SkPaint stroke width describes the line thickness, and
         SkPaint::Join draws the corners rounded or square.
 
         @param region  region to draw
         @param paint   SkPaint stroke or fill, blend, color, and so on, used to draw
     */
     void drawRegion(const SkRegion& region, const SkPaint& paint);
 
     /** Draws oval oval using clip, SkMatrix, and SkPaint.
         In paint: SkPaint::Style determines if oval is stroked or filled;
         if stroked, SkPaint stroke width describes the line thickness.
 
         @param oval   SkRect bounds of oval
         @param paint  SkPaint stroke or fill, blend, color, and so on, used to draw
     */
     void drawOval(const SkRect& oval, const SkPaint& paint);
 
     /** Draws SkRRect rrect using clip, SkMatrix, and SkPaint paint.
         In paint: SkPaint::Style determines if rrect is stroked or filled;
         if stroked, SkPaint stroke width describes the line thickness.
 
         rrect may represent a rectangle, circle, oval, uniformly rounded rectangle, or
         may have any combination of positive non-square radii for the four corners.
 
         @param rrect  SkRRect with up to eight corner radii to draw
         @param paint  SkPaint stroke or fill, blend, color, and so on, used to draw
     */
     void drawRRect(const SkRRect& rrect, const SkPaint& paint);
 
     /** Draws SkRRect outer and inner
         using clip, SkMatrix, and SkPaint paint.
         outer must contain inner or the drawing is undefined.
         In paint: SkPaint::Style determines if SkRRect is stroked or filled;
         if stroked, SkPaint stroke width describes the line thickness.
         If stroked and SkRRect corner has zero length radii, SkPaint::Join can
         draw corners rounded or square.
 
         GPU-backed platforms optimize drawing when both outer and inner are
         concave and outer contains inner. These platforms may not be able to draw
         SkPath built with identical data as fast.
 
         @param outer  SkRRect outer bounds to draw
         @param inner  SkRRect inner bounds to draw
         @param paint  SkPaint stroke or fill, blend, color, and so on, used to draw
     */
     void drawDRRect(const SkRRect& outer, const SkRRect& inner, const SkPaint& paint);
 
     /** Draws circle at (cx, cy) with radius using clip, SkMatrix, and SkPaint paint.
         If radius is zero or less, nothing is drawn.
         In paint: SkPaint::Style determines if circle is stroked or filled;
         if stroked, SkPaint stroke width describes the line thickness.
 
         @param cx      circle center on the x-axis
         @param cy      circle center on the y-axis
         @param radius  half the diameter of circle
         @param paint   SkPaint stroke or fill, blend, color, and so on, used to draw
     */
     void drawCircle(SkScalar cx, SkScalar cy, SkScalar radius, const SkPaint& paint);
 
     /** Draws circle at center with radius using clip, SkMatrix, and SkPaint paint.
         If radius is zero or less, nothing is drawn.
         In paint: SkPaint::Style determines if circle is stroked or filled;
         if stroked, SkPaint stroke width describes the line thickness.
 
         @param center  circle center
         @param radius  half the diameter of circle
         @param paint   SkPaint stroke or fill, blend, color, and so on, used to draw
     */
     void drawCircle(SkPoint center, SkScalar radius, const SkPaint& paint) {
         this->drawCircle(center.x(), center.y(), radius, paint);
     }
 
     /** Draws arc using clip, SkMatrix, and SkPaint paint.
 
         Arc is part of oval bounded by oval, sweeping from startAngle to startAngle plus
         sweepAngle. startAngle and sweepAngle are in degrees.
 
         startAngle of zero places start point at the right middle edge of oval.
         A positive sweepAngle places arc end point clockwise from start point;
         a negative sweepAngle places arc end point counterclockwise from start point.
         sweepAngle may exceed 360 degrees, a full circle.
         If useCenter is true, draw a wedge that includes lines from oval
         center to arc end points. If useCenter is false, draw arc between end points.
 
         If SkRect oval is empty or sweepAngle is zero, nothing is drawn.
 
         @param oval        SkRect bounds of oval containing arc to draw
         @param startAngle  angle in degrees where arc begins
         @param sweepAngle  sweep angle in degrees; positive is clockwise
         @param useCenter   if true, include the center of the oval
         @param paint       SkPaint stroke or fill, blend, color, and so on, used to draw
     */
     void drawArc(const SkRect& oval, SkScalar startAngle, SkScalar sweepAngle,
                  bool useCenter, const SkPaint& paint);
 
     /** Draws SkRRect bounded by SkRect rect, with corner radii (rx, ry) using clip,
         SkMatrix, and SkPaint paint.
 
         In paint: SkPaint::Style determines if SkRRect is stroked or filled;
         if stroked, SkPaint stroke width describes the line thickness.
         If rx or ry are less than zero, they are treated as if they are zero.
         If rx plus ry exceeds rect width or rect height, radii are scaled down to fit.
         If rx and ry are zero, SkRRect is drawn as SkRect and if stroked is affected by
         SkPaint::Join.
 
         @param rect   SkRect bounds of SkRRect to draw
         @param rx     axis length on x-axis of oval describing rounded corners
         @param ry     axis length on y-axis of oval describing rounded corners
         @param paint  stroke, blend, color, and so on, used to draw
     */
     void drawRoundRect(const SkRect& rect, SkScalar rx, SkScalar ry, const SkPaint& paint);
 
     /** Draws SkPath path using clip, SkMatrix, and SkPaint paint.
         SkPath contains an array of path contour, each of which may be open or closed.
 
         In paint: SkPaint::Style determines if SkRRect is stroked or filled:
         if filled, SkPath::FillType determines whether path contour describes inside or
         outside of fill; if stroked, SkPaint stroke width describes the line thickness,
         SkPaint::Cap describes line ends, and SkPaint::Join describes how
         corners are drawn.
 
         @param path   SkPath to draw
         @param paint  stroke, blend, color, and so on, used to draw
     */
     void drawPath(const SkPath& path, const SkPaint& paint);
 
     /** Draws SkImage image, with its top-left corner at (left, top),
         using clip, SkMatrix, and optional SkPaint paint.
 
         This is equivalent to drawImageRect() using a dst rect at (x,y) with the
         same width and height of the image.
 
         @param image  uncompressed rectangular map of pixels
         @param left   left side of image
         @param top    top side of image
         @param paint  SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                       and so on; or nullptr
     */
     void drawImage(const SkImage* image, SkScalar left, SkScalar top,
                    const SkPaint* paint = nullptr);
 
     /** Draws SkImage image, with its top-left corner at (left, top),
         using clip, SkMatrix, and optional SkPaint paint.
 
         This is equivalent to drawImageRect() using a dst rect at (x,y) with the
         same width and height of the image.
 
         @param image  uncompressed rectangular map of pixels
         @param left   left side of image
         @param top    pop side of image
         @param paint  SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                       and so on; or nullptr
     */
     void drawImage(const sk_sp<SkImage>& image, SkScalar left, SkScalar top,
                    const SkPaint* paint = nullptr) {
         this->drawImage(image.get(), left, top, paint);
     }
 
     /** \enum SkCanvas::SrcRectConstraint
         SrcRectConstraint controls the behavior at the edge of source SkRect,
         provided to drawImageRect(), trading off speed for precision.
 
         SkFilterQuality in SkPaint may sample multiple pixels in the image. Source SkRect
         restricts the bounds of pixels that may be read. SkFilterQuality may slow down if
         it cannot read outside the bounds, when sampling near the edge of source SkRect.
         SrcRectConstraint specifies whether an SkImageFilter is allowed to read pixels
         outside source SkRect.
     */
     enum SrcRectConstraint {
         kStrict_SrcRectConstraint, //!< sample only inside bounds; slower
         kFast_SrcRectConstraint,   //!< sample outside bounds; faster
     };
 
     /** Draws SkRect src of SkImage image, scaled and translated to fill SkRect dst.
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from image bounds.
 
         If generated mask extends beyond image bounds, replicate image edge colors, just
         as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set
         replicates the image edge color when it samples outside of its bounds.
 
         When using a shader or shader mask filter, its coordinate system is based on the
         current CTM, so will reflect the dst rect geometry and is equivalent to
         drawRect(dst). The src rect is only used to access the provided image.
 
         constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to
         sample within src; set to kFast_SrcRectConstraint allows sampling outside to
         improve performance.
 
         @param image       SkImage containing pixels, dimensions, and format
         @param src         source SkRect of image to draw from
         @param dst         destination SkRect of image to draw to
         @param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                            and so on; or nullptr
         @param constraint  filter strictly within src or draw faster
     */
     void drawImageRect(const SkImage* image, const SkRect& src, const SkRect& dst,
                        const SkPaint* paint,
                        SrcRectConstraint constraint = kStrict_SrcRectConstraint);
 
     /** Draws SkIRect isrc of SkImage image, scaled and translated to fill SkRect dst.
         Note that isrc is on integer pixel boundaries; dst may include fractional
         boundaries. Additionally transform draw using clip, SkMatrix, and optional SkPaint
         paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from image bounds.
 
         If generated mask extends beyond image bounds, replicate image edge colors, just
         as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set
         replicates the image edge color when it samples outside of its bounds.
 
         When using a shader or shader mask filter, its coordinate system is based on the
         current CTM, so will reflect the dst rect geometry and is equivalent to
         drawRect(dst). The src rect is only used to access the provided image.
 
         constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to
         sample within isrc; set to kFast_SrcRectConstraint allows sampling outside to
         improve performance.
 
         @param image       SkImage containing pixels, dimensions, and format
         @param isrc        source SkIRect of image to draw from
         @param dst         destination SkRect of image to draw to
         @param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                            and so on; or nullptr
         @param constraint  filter strictly within isrc or draw faster
     */
     void drawImageRect(const SkImage* image, const SkIRect& isrc, const SkRect& dst,
                        const SkPaint* paint,
                        SrcRectConstraint constraint = kStrict_SrcRectConstraint);
 
     /** Draws SkImage image, scaled and translated to fill SkRect dst, using clip, SkMatrix,
         and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from image bounds.
 
         If generated mask extends beyond image bounds, replicate image edge colors, just
         as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set
         replicates the image edge color when it samples outside of its bounds.
 
         When using a shader or shader mask filter, its coordinate system is based on the
         current CTM, so will reflect the dst rect geometry and is equivalent to
         drawRect(dst).
 
         @param image       SkImage containing pixels, dimensions, and format
         @param dst         destination SkRect of image to draw to
         @param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                            and so on; or nullptr
     */
     void drawImageRect(const SkImage* image, const SkRect& dst, const SkPaint* paint);
 
     /** Draws SkRect src of SkImage image, scaled and translated to fill SkRect dst.
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from image bounds.
 
         If generated mask extends beyond image bounds, replicate image edge colors, just
         as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set
         replicates the image edge color when it samples outside of its bounds.
 
         When using a shader or shader mask filter, its coordinate system is based on the
         current CTM, so will reflect the dst rect geometry and is equivalent to
         drawRect(dst). The src rect is only used to access the provided image.
 
         @param image       SkImage containing pixels, dimensions, and format
         @param src         source SkRect of image to draw from
         @param dst         destination SkRect of image to draw to
         @param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                            and so on; or nullptr
         @param constraint  filter strictly within src or draw faster
     */
     void drawImageRect(const sk_sp<SkImage>& image, const SkRect& src, const SkRect& dst,
                        const SkPaint* paint,
                        SrcRectConstraint constraint = kStrict_SrcRectConstraint) {
         this->drawImageRect(image.get(), src, dst, paint, constraint);
     }
 
     /** Draws SkIRect isrc of SkImage image, scaled and translated to fill SkRect dst.
         isrc is on integer pixel boundaries; dst may include fractional boundaries.
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from image bounds.
 
         If generated mask extends beyond image bounds, replicate image edge colors, just
         as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set
         replicates the image edge color when it samples outside of its bounds.
 
         When using a shader or shader mask filter, its coordinate system is based on the
         current CTM, so will reflect the dst rect geometry and is equivalent to
         drawRect(dst). The src rect is only used to access the provided image.
 
         constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to
         sample within image; set to kFast_SrcRectConstraint allows sampling outside to
         improve performance.
 
         @param image       SkImage containing pixels, dimensions, and format
         @param isrc        source SkIRect of image to draw from
         @param dst         destination SkRect of image to draw to
         @param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                            and so on; or nullptr
         @param constraint  filter strictly within image or draw faster
     */
     void drawImageRect(const sk_sp<SkImage>& image, const SkIRect& isrc, const SkRect& dst,
                        const SkPaint* paint,
                        SrcRectConstraint constraint = kStrict_SrcRectConstraint) {
         this->drawImageRect(image.get(), isrc, dst, paint, constraint);
     }
 
     /** Draws SkImage image, scaled and translated to fill SkRect dst,
         using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from image bounds.
 
         If generated mask extends beyond image bounds, replicate image edge colors, just
         as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set
         replicates the image edge color when it samples outside of its bounds.
 
         When using a shader or shader mask filter, its coordinate system is based on the
         current CTM, so will reflect the dst rect geometry and is equivalent to
         drawRect(dst).
 
         constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to
         sample within image; set to kFast_SrcRectConstraint allows sampling outside to
         improve performance.
 
         @param image       SkImage containing pixels, dimensions, and format
         @param dst         destination SkRect of image to draw to
         @param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                            and so on; or nullptr
     */
     void drawImageRect(const sk_sp<SkImage>& image, const SkRect& dst, const SkPaint* paint) {
         this->drawImageRect(image.get(), dst, paint);
     }
 
     /** Draws SkImage image stretched proportionally to fit into SkRect dst.
         SkIRect center divides the image into nine sections: four sides, four corners, and
         the center. Corners are unmodified or scaled down proportionately if their sides
         are larger than dst; center and four sides are scaled to fit remaining space, if any.
 
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from image bounds. If paint
         SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all
         other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels.
         Any SkMaskFilter on paint is ignored as is paint anti-aliasing state.
 
         If generated mask extends beyond image bounds, replicate image edge colors, just
         as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set
         replicates the image edge color when it samples outside of its bounds.
 
         @param image   SkImage containing pixels, dimensions, and format
         @param center  SkIRect edge of image corners and sides
         @param dst     destination SkRect of image to draw to
         @param paint   SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                        and so on; or nullptr
     */
     void drawImageNine(const SkImage* image, const SkIRect& center, const SkRect& dst,
                        const SkPaint* paint = nullptr);
 
     /** Draws SkImage image stretched proportionally to fit into SkRect dst.
         SkIRect center divides the image into nine sections: four sides, four corners, and
         the center. Corners are not scaled, or scaled down proportionately if their sides
         are larger than dst; center and four sides are scaled to fit remaining space, if any.
 
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from image bounds. If paint
         SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all
         other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels.
         Any SkMaskFilter on paint is ignored as is paint anti-aliasing state.
 
         If generated mask extends beyond image bounds, replicate image edge colors, just
         as SkShader made from SkImage::makeShader with SkShader::kClamp_TileMode set
         replicates the image edge color when it samples outside of its bounds.
 
         @param image   SkImage containing pixels, dimensions, and format
         @param center  SkIRect edge of image corners and sides
         @param dst     destination SkRect of image to draw to
         @param paint   SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                        and so on; or nullptr
     */
     void drawImageNine(const sk_sp<SkImage>& image, const SkIRect& center, const SkRect& dst,
                        const SkPaint* paint = nullptr) {
         this->drawImageNine(image.get(), center, dst, paint);
     }
 
     /** Draws SkBitmap bitmap, with its top-left corner at (left, top),
         using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is not nullptr, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from bitmap bounds.
 
         If generated mask extends beyond bitmap bounds, replicate bitmap edge colors,
         just as SkShader made from SkShader::MakeBitmapShader with
         SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples
         outside of its bounds.
 
         @param bitmap  SkBitmap containing pixels, dimensions, and format
         @param left    left side of bitmap
         @param top     top side of bitmap
         @param paint   SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                        and so on; or nullptr
     */
     void drawBitmap(const SkBitmap& bitmap, SkScalar left, SkScalar top,
                     const SkPaint* paint = nullptr);
 
     /** Draws SkRect src of SkBitmap bitmap, scaled and translated to fill SkRect dst.
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from bitmap bounds.
 
         If generated mask extends beyond bitmap bounds, replicate bitmap edge colors,
         just as SkShader made from SkShader::MakeBitmapShader with
         SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples
         outside of its bounds.
 
         constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to
         sample within src; set to kFast_SrcRectConstraint allows sampling outside to
         improve performance.
 
         @param bitmap      SkBitmap containing pixels, dimensions, and format
         @param src         source SkRect of image to draw from
         @param dst         destination SkRect of image to draw to
         @param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                            and so on; or nullptr
         @param constraint  filter strictly within src or draw faster
     */
     void drawBitmapRect(const SkBitmap& bitmap, const SkRect& src, const SkRect& dst,
                         const SkPaint* paint,
                         SrcRectConstraint constraint = kStrict_SrcRectConstraint);
 
     /** Draws SkIRect isrc of SkBitmap bitmap, scaled and translated to fill SkRect dst.
         isrc is on integer pixel boundaries; dst may include fractional boundaries.
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from bitmap bounds.
 
         If generated mask extends beyond bitmap bounds, replicate bitmap edge colors,
         just as SkShader made from SkShader::MakeBitmapShader with
         SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples
         outside of its bounds.
 
         constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to
         sample within isrc; set to kFast_SrcRectConstraint allows sampling outside to
         improve performance.
 
         @param bitmap      SkBitmap containing pixels, dimensions, and format
         @param isrc        source SkIRect of image to draw from
         @param dst         destination SkRect of image to draw to
         @param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                            and so on; or nullptr
         @param constraint  sample strictly within isrc, or draw faster
     */
     void drawBitmapRect(const SkBitmap& bitmap, const SkIRect& isrc, const SkRect& dst,
                         const SkPaint* paint,
                         SrcRectConstraint constraint = kStrict_SrcRectConstraint);
 
     /** Draws SkBitmap bitmap, scaled and translated to fill SkRect dst.
         bitmap bounds is on integer pixel boundaries; dst may include fractional boundaries.
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from bitmap bounds.
 
         If generated mask extends beyond bitmap bounds, replicate bitmap edge colors,
         just as SkShader made from SkShader::MakeBitmapShader with
         SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples
         outside of its bounds.
 
         constraint set to kStrict_SrcRectConstraint limits SkPaint SkFilterQuality to
         sample within bitmap; set to kFast_SrcRectConstraint allows sampling outside to
         improve performance.
 
         @param bitmap      SkBitmap containing pixels, dimensions, and format
         @param dst         destination SkRect of image to draw to
         @param paint       SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                            and so on; or nullptr
         @param constraint  filter strictly within bitmap or draw faster
     */
     void drawBitmapRect(const SkBitmap& bitmap, const SkRect& dst, const SkPaint* paint,
                         SrcRectConstraint constraint = kStrict_SrcRectConstraint);
 
     /** Draws SkBitmap bitmap stretched proportionally to fit into SkRect dst.
         SkIRect center divides the bitmap into nine sections: four sides, four corners,
         and the center. Corners are not scaled, or scaled down proportionately if their
         sides are larger than dst; center and four sides are scaled to fit remaining
         space, if any.
 
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from bitmap bounds. If paint
         SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all
         other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels.
         Any SkMaskFilter on paint is ignored as is paint anti-aliasing state.
 
         If generated mask extends beyond bitmap bounds, replicate bitmap edge colors,
         just as SkShader made from SkShader::MakeBitmapShader with
         SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples
         outside of its bounds.
 
         @param bitmap  SkBitmap containing pixels, dimensions, and format
         @param center  SkIRect edge of image corners and sides
         @param dst     destination SkRect of image to draw to
         @param paint   SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                        and so on; or nullptr
     */
     void drawBitmapNine(const SkBitmap& bitmap, const SkIRect& center, const SkRect& dst,
                         const SkPaint* paint = nullptr);
 
     /** \struct SkCanvas::Lattice
         SkCanvas::Lattice divides SkBitmap or SkImage into a rectangular grid.
         Grid entries on even columns and even rows are fixed; these entries are
         always drawn at their original size if the destination is large enough.
         If the destination side is too small to hold the fixed entries, all fixed
         entries are proportionately scaled down to fit.
         The grid entries not on even columns and rows are scaled to fit the
         remaining space, if any.
     */
     struct Lattice {
 
         /** \enum SkCanvas::Lattice::RectType
             Optional setting per rectangular grid entry to make it transparent,
             or to fill the grid entry with a color.
         */
         enum RectType : uint8_t {
             kDefault     = 0, //!< draws SkBitmap into lattice rectangle
             kTransparent,     //!< skips lattice rectangle by making it transparent
             kFixedColor,      //!< draws one of fColors into lattice rectangle
         };
 
         const int*      fXDivs;     //!< x-axis values dividing bitmap
         const int*      fYDivs;     //!< y-axis values dividing bitmap
         const RectType* fRectTypes; //!< array of fill types
         int             fXCount;    //!< number of x-coordinates
         int             fYCount;    //!< number of y-coordinates
         const SkIRect*  fBounds;    //!< source bounds to draw from
         const SkColor*  fColors;    //!< array of colors
     };
 
     /** Draws SkBitmap bitmap stretched proportionally to fit into SkRect dst.
 
         SkCanvas::Lattice lattice divides bitmap into a rectangular grid.
         Each intersection of an even-numbered row and column is fixed; like the corners
         of drawBitmapNine(), fixed lattice elements never scale larger than their initial
         size and shrink proportionately when all fixed elements exceed the bitmap
         dimension. All other grid elements scale to fill the available space, if any.
 
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If bitmap is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from bitmap bounds. If paint
         SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all
         other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels.
         Any SkMaskFilter on paint is ignored as is paint anti-aliasing state.
 
         If generated mask extends beyond bitmap bounds, replicate bitmap edge colors,
         just as SkShader made from SkShader::MakeBitmapShader with
         SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples
         outside of its bounds.
 
         @param bitmap   SkBitmap containing pixels, dimensions, and format
         @param lattice  division of bitmap into fixed and variable rectangles
         @param dst      destination SkRect of image to draw to
         @param paint    SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                         and so on; or nullptr
     */
     void drawBitmapLattice(const SkBitmap& bitmap, const Lattice& lattice, const SkRect& dst,
                            const SkPaint* paint = nullptr);
 
     /** Draws SkImage image stretched proportionally to fit into SkRect dst.
 
         SkCanvas::Lattice lattice divides image into a rectangular grid.
         Each intersection of an even-numbered row and column is fixed; like the corners
         of drawBitmapNine(), fixed lattice elements never scale larger than their initial
         size and shrink proportionately when all fixed elements exceed the bitmap
         dimension. All other grid elements scale to fill the available space, if any.
 
         Additionally transform draw using clip, SkMatrix, and optional SkPaint paint.
 
         If SkPaint paint is supplied, apply SkColorFilter, alpha, SkImageFilter,
         SkBlendMode, and SkDrawLooper. If image is kAlpha_8_SkColorType, apply SkShader.
         If paint contains SkMaskFilter, generate mask from image bounds. If paint
         SkFilterQuality set to kNone_SkFilterQuality, disable pixel filtering. For all
         other values of paint SkFilterQuality, use kLow_SkFilterQuality to filter pixels.
         Any SkMaskFilter on paint is ignored as is paint anti-aliasing state.
 
         If generated mask extends beyond bitmap bounds, replicate bitmap edge colors,
         just as SkShader made from SkShader::MakeBitmapShader with
         SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples
         outside of its bounds.
 
         @param image    SkImage containing pixels, dimensions, and format
         @param lattice  division of bitmap into fixed and variable rectangles
         @param dst      destination SkRect of image to draw to
         @param paint    SkPaint containing SkBlendMode, SkColorFilter, SkImageFilter,
                         and so on; or nullptr
     */
     void drawImageLattice(const SkImage* image, const Lattice& lattice, const SkRect& dst,
                           const SkPaint* paint = nullptr);
 
     /**
      * Experimental. Controls anti-aliasing of each edge of images in an image-set.
      */
     enum QuadAAFlags : unsigned {
         kLeft_QuadAAFlag    = 0b0001,
         kTop_QuadAAFlag     = 0b0010,
         kRight_QuadAAFlag   = 0b0100,
         kBottom_QuadAAFlag  = 0b1000,
 
         kNone_QuadAAFlags   = 0b0000,
         kAll_QuadAAFlags    = 0b1111,
     };
 
     /** This is used by the experimental API below. */
     struct ImageSetEntry {
         sk_sp<const SkImage> fImage;
         SkRect fSrcRect;
         SkRect fDstRect;
-        int fMatrixIndex;   // Index into the preViewMatrices arg, or < 0
         float fAlpha;
         unsigned fAAFlags;  // QuadAAFlags
-        bool fHasClip;      // True to use next 4 points in dstClip arg as quad
     };
 
     /**
      * This is an experimental API for the SkiaRenderer Chromium project. The signature will
      * surely evolve if this is not removed. It currently offers no performance advantage over
      * drawing images independently, though may in the future. The antialiasing flags are intended
      * to allow control over each edge's AA status, to allow perfect seaming for tile sets. The
      * current implementation only antialiases if all edges are flagged, however.
      * Results are undefined if an image's src rect is not within the image's bounds.
-     *
-     * Ignores fDstClipCount and fMatrixIndex in the image set entries.
-     * <!deprecated in favor of experimental_DrawEdgeAAImageSet
      */
     void experimental_DrawImageSetV1(const ImageSetEntry imageSet[], int cnt,
                                      SkFilterQuality quality, SkBlendMode mode);
 
     /**
      * This is an experimental API for the SkiaRenderer Chromium project. The signature will
      * surely evolve if this is not removed. The antialiasing flags are intended to allow control
      * over each edge's AA status, to allow perfect seaming for tile sets.
      *
      * When not fully supported, the implementation only antialiases if all edges are flagged.
-     * <!deprecated in favor of experimental_DrawEdgeAAQuad
      */
     void experimental_DrawEdgeAARectV1(const SkRect& r, QuadAAFlags edgeAA, SkColor color,
                                        SkBlendMode mode);
 
-    /**
-     * This is an experimental API for the SkiaRenderer Chromium project, and its API will surely
-     * evolve if it is not removed outright.
-     *
-     * This behaves very similarly to drawRect() combined with a clipPath() formed by clip
-     * quadrilateral. 'rect' and 'clip' are in the same coordinate space. If 'clip' is null, then it
-     * is as if the rectangle was not clipped (or, alternatively, clipped to itself). If not null,
-     * then it must provide 4 points.
-     *
-     * In addition to combining the draw and clipping into one operation, this function adds the
-     * additional capability of controlling each of the rectangle's edges anti-aliasing
-     * independently.  The edges of the clip will respect the per-edge AA flags. It is required that
-     * 'clip' be contained inside 'rect'. In terms of mapping to edge labels, the 'clip' points
-     * should be ordered top-left, top-right, bottom-right, bottom-left so that the edge between [0]
-     * and [1] is "top", [1] and [2] is "right", [2] and [3] is "bottom", and [3] and [0] is "left".
-     * This ordering matches SkRect::toQuad().
-     *
-     * This API only draws solid color, filled rectangles so it does not accept a full SkPaint.
-     */
-    void experimental_DrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4], QuadAAFlags aaFlags,
-                                     SkColor color, SkBlendMode mode);
-    /**
-     * This is an bulk variant of experimental_DrawEdgeAAQuad() that renders 'cnt' textured quads.
-     * For each entry, 'fDstRect' is rendered with its clip (determined by entry's 'fHasClip' and
-     * the current index in 'dstClip'). The entry's fImage is applied to the destination rectangle
-     * by sampling from 'fSrcRect' sub-image.  The corners of 'fSrcRect' map to the corners of
-     * 'fDstRect', just like in drawImageRect(), and they will be properly interpolated when
-     * applying a clip.
-     *
-     * Like experimental_DrawEdgeAAQuad(), each entry can specify edge AA flags that apply to both
-     * the destination rect and its clip.
-     *
-     * If provided, the 'dstClips' array must have length equal 4 * the number of entries with
-     * fHasClip true. If 'dstClips' is null, every entry must have 'fHasClip' set to false. The
-     * destination clip coordinates will be read consecutively with the image set entries, advancing
-     * by 4 points every time an entry with fHasClip is passed.
-     *
-     * This entry point supports per-entry manipulations to the canvas's current matrix. If an
-     * entry provides 'fMatrixIndex' >= 0, it will be drawn as if the canvas's CTM was
-     * canvas->getTotalMatrix() * preViewMatrices[fMatrixIndex]. If 'fMatrixIndex' is less than 0,
-     * the pre-view matrix transform is implicitly the identity, so it will be drawn using just the
-     * current canvas matrix. The pre-view matrix modifies the canvas's view matrix, it does not
-     * affect the local coordinates of each entry.
-     *
-     * An optional paint may be provided, which supports the same subset of features usable with
-     * drawImageRect (i.e. assumed to be filled and no path effects). When a paint is provided, the
-     * image set is drawn as if each image used the applied paint independently, so each is affected
-     * by the image, color, and/or mask filter.
-     */
-    void experimental_DrawEdgeAAImageSet(const ImageSetEntry imageSet[], int cnt,
-                                         const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                                         const SkPaint* paint = nullptr,
-                                         SrcRectConstraint constraint = kStrict_SrcRectConstraint);
-
     /** Draws text, with origin at (x, y), using clip, SkMatrix, SkFont font,
         and SkPaint paint.
 
         When encoding is SkTextEncoding::kUTF8, SkTextEncoding::kUTF16, or
         SkTextEncoding::kUTF32, this function uses the default
         character-to-glyph mapping from the SkTypeface in font.  It does not
         perform typeface fallback for characters not found in the SkTypeface.
         It does not perform kerning or other complex shaping; glyphs are
         positioned based on their default advances.
 
         Text meaning depends on SkTextEncoding.
 
         Text size is affected by SkMatrix and SkFont text size. Default text
         size is 12 point.
 
         All elements of paint: SkPathEffect, SkMaskFilter, SkShader,
         SkColorFilter, SkImageFilter, and SkDrawLooper; apply to text. By
         default, draws filled black glyphs.
 
         @param text        character code points or glyphs drawn
         @param byteLength  byte length of text array
         @param encoding    text encoding used in the text array
         @param x           start of text on x-axis
         @param y           start of text on y-axis
         @param font        typeface, text size and so, used to describe the text
         @param paint       blend, color, and so on, used to draw
     */
     void drawSimpleText(const void* text, size_t byteLength, SkTextEncoding encoding,
                         SkScalar x, SkScalar y, const SkFont& font, const SkPaint& paint);
 
     /** Experimental.
 
         Draws null terminated string, with origin at (x, y), using clip, SkMatrix,
         SkFont font, and SkPaint paint.
 
         This function uses the default character-to-glyph mapping from the
         SkTypeface in font.  It does not perform typeface fallback for
         characters not found in the SkTypeface.  It does not perform kerning;
         glyphs are positioned based on their default advances.
 
         String str is encoded as UTF-8.
 
         Text size is affected by SkMatrix and font text size. Default text
         size is 12 point.
 
         All elements of paint: SkPathEffect, SkMaskFilter, SkShader,
         SkColorFilter, SkImageFilter, and SkDrawLooper; apply to text. By
         default, draws filled black glyphs.
 
         @param str     character code points drawn,
                        ending with a char value of zero
         @param x       start of string on x-axis
         @param y       start of string on y-axis
         @param font    typeface, text size and so, used to describe the text
         @param paint   blend, color, and so on, used to draw
     */
     void drawString(const char str[], SkScalar x, SkScalar y, const SkFont& font,
                     const SkPaint& paint) {
         this->drawSimpleText(str, strlen(str), kUTF8_SkTextEncoding, x, y, font, paint);
     }
 
     /** Experimental.
 
         Draws SkString, with origin at (x, y), using clip, SkMatrix, SkFont font,
         and SkPaint paint.
 
         This function uses the default character-to-glyph mapping from the
         SkTypeface in font.  It does not perform typeface fallback for
         characters not found in the SkTypeface.  It does not perform kerning;
         glyphs are positioned based on their default advances.
 
         SkString str is encoded as UTF-8.
 
         Text size is affected by SkMatrix and SkFont text size. Default text
         size is 12 point.
 
         All elements of paint: SkPathEffect, SkMaskFilter, SkShader,
         SkColorFilter, SkImageFilter, and SkDrawLooper; apply to text. By
         default, draws filled black glyphs.
 
         @param str     character code points drawn,
                        ending with a char value of zero
         @param x       start of string on x-axis
         @param y       start of string on y-axis
         @param font    typeface, text size and so, used to describe the text
         @param paint   blend, color, and so on, used to draw
     */
     void drawString(const SkString& str, SkScalar x, SkScalar y, const SkFont& font,
                     const SkPaint& paint) {
         this->drawSimpleText(str.c_str(), str.size(), kUTF8_SkTextEncoding, x, y, font, paint);
     }
 
     /** Draws SkTextBlob blob at (x, y), using clip, SkMatrix, and SkPaint paint.
 
         blob contains glyphs, their positions, and paint attributes specific to text:
         SkTypeface, SkPaint text size, SkPaint text scale x,
         SkPaint text skew x, SkPaint::Align, SkPaint::Hinting, anti-alias, SkPaint fake bold,
         SkPaint font embedded bitmaps, SkPaint full hinting spacing, LCD text, SkPaint linear text,
         and SkPaint subpixel text.
 
         SkTextEncoding must be set to kGlyphID_SkTextEncoding.
 
         Elements of paint: anti-alias, SkBlendMode, color including alpha,
         SkColorFilter, SkPaint dither, SkDrawLooper, SkMaskFilter, SkPathEffect, SkShader, and
         SkPaint::Style; apply to blob. If SkPaint contains SkPaint::kStroke_Style:
         SkPaint miter limit, SkPaint::Cap, SkPaint::Join, and SkPaint stroke width;
         apply to SkPath created from blob.
 
         @param blob   glyphs, positions, and their paints' text size, typeface, and so on
         @param x      horizontal offset applied to blob
         @param y      vertical offset applied to blob
         @param paint  blend, color, stroking, and so on, used to draw
     */
     void drawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y, const SkPaint& paint);
 
     /** Draws SkTextBlob blob at (x, y), using clip, SkMatrix, and SkPaint paint.
 
         blob contains glyphs, their positions, and paint attributes specific to text:
         SkTypeface, SkPaint text size, SkPaint text scale x,
         SkPaint text skew x, SkPaint::Align, SkPaint::Hinting, anti-alias, SkPaint fake bold,
         SkPaint font embedded bitmaps, SkPaint full hinting spacing, LCD text, SkPaint linear text,
         and SkPaint subpixel text.
 
         SkTextEncoding must be set to kGlyphID_SkTextEncoding.
 
         Elements of paint: SkPathEffect, SkMaskFilter, SkShader, SkColorFilter,
         SkImageFilter, and SkDrawLooper; apply to blob.
 
         @param blob   glyphs, positions, and their paints' text size, typeface, and so on
         @param x      horizontal offset applied to blob
         @param y      vertical offset applied to blob
         @param paint  blend, color, stroking, and so on, used to draw
     */
     void drawTextBlob(const sk_sp<SkTextBlob>& blob, SkScalar x, SkScalar y, const SkPaint& paint) {
         this->drawTextBlob(blob.get(), x, y, paint);
     }
 
     /** Draws SkPicture picture, using clip and SkMatrix.
         Clip and SkMatrix are unchanged by picture contents, as if
         save() was called before and restore() was called after drawPicture().
 
         SkPicture records a series of draw commands for later playback.
 
         @param picture  recorded drawing commands to play
     */
     void drawPicture(const SkPicture* picture) {
         this->drawPicture(picture, nullptr, nullptr);
     }
 
     /** Draws SkPicture picture, using clip and SkMatrix.
         Clip and SkMatrix are unchanged by picture contents, as if
         save() was called before and restore() was called after drawPicture().
 
         SkPicture records a series of draw commands for later playback.
 
         @param picture  recorded drawing commands to play
     */
     void drawPicture(const sk_sp<SkPicture>& picture) {
         this->drawPicture(picture.get());
     }
 
     /** Draws SkPicture picture, using clip and SkMatrix; transforming picture with
         SkMatrix matrix, if provided; and use SkPaint paint alpha, SkColorFilter,
         SkImageFilter, and SkBlendMode, if provided.
 
         matrix transformation is equivalent to: save(), concat(), drawPicture(), restore().
         paint use is equivalent to: saveLayer(), drawPicture(), restore().
 
         @param picture  recorded drawing commands to play
         @param matrix   SkMatrix to rotate, scale, translate, and so on; may be nullptr
         @param paint    SkPaint to apply transparency, filtering, and so on; may be nullptr
     */
     void drawPicture(const SkPicture* picture, const SkMatrix* matrix, const SkPaint* paint);
 
     /** Draws SkPicture picture, using clip and SkMatrix; transforming picture with
         SkMatrix matrix, if provided; and use SkPaint paint alpha, SkColorFilter,
         SkImageFilter, and SkBlendMode, if provided.
 
         matrix transformation is equivalent to: save(), concat(), drawPicture(), restore().
         paint use is equivalent to: saveLayer(), drawPicture(), restore().
 
         @param picture  recorded drawing commands to play
         @param matrix   SkMatrix to rotate, scale, translate, and so on; may be nullptr
         @param paint    SkPaint to apply transparency, filtering, and so on; may be nullptr
     */
     void drawPicture(const sk_sp<SkPicture>& picture, const SkMatrix* matrix,
                      const SkPaint* paint) {
         this->drawPicture(picture.get(), matrix, paint);
     }
 
     /** Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix.
         If vertices texs and vertices colors are defined in vertices, and SkPaint paint
         contains SkShader, SkBlendMode mode combines vertices colors with SkShader.
 
         @param vertices  triangle mesh to draw
         @param mode      combines vertices colors with SkShader, if both are present
         @param paint     specifies the SkShader, used as SkVertices texture; may be nullptr
     */
     void drawVertices(const SkVertices* vertices, SkBlendMode mode, const SkPaint& paint);
 
     /** Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix.
         If vertices texs and vertices colors are defined in vertices, and SkPaint paint
         contains SkShader, SkBlendMode mode combines vertices colors with SkShader.
 
         @param vertices  triangle mesh to draw
         @param mode      combines vertices colors with SkShader, if both are present
         @param paint     specifies the SkShader, used as SkVertices texture, may be nullptr
     */
     void drawVertices(const sk_sp<SkVertices>& vertices, SkBlendMode mode, const SkPaint& paint);
 
     /** Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix. Bone data is used to
         deform vertices with bone weights.
         If vertices texs and vertices colors are defined in vertices, and SkPaint paint
         contains SkShader, SkBlendMode mode combines vertices colors with SkShader.
         The first element of bones should be an object to world space transformation matrix that
         will be applied before performing mesh deformations. If no such transformation is needed,
         it should be the identity matrix.
         boneCount must be at most 80, and thus the size of bones should be at most 80.
 
         @param vertices   triangle mesh to draw
         @param bones      bone matrix data
         @param boneCount  number of bone matrices
         @param mode       combines vertices colors with SkShader, if both are present
         @param paint      specifies the SkShader, used as SkVertices texture, may be nullptr
     */
     void drawVertices(const SkVertices* vertices, const SkVertices::Bone bones[], int boneCount,
                       SkBlendMode mode, const SkPaint& paint);
 
     /** Draws SkVertices vertices, a triangle mesh, using clip and SkMatrix. Bone data is used to
         deform vertices with bone weights.
         If vertices texs and vertices colors are defined in vertices, and SkPaint paint
         contains SkShader, SkBlendMode mode combines vertices colors with SkShader.
         The first element of bones should be an object to world space transformation matrix that
         will be applied before performing mesh deformations. If no such transformation is needed,
         it should be the identity matrix.
         boneCount must be at most 80, and thus the size of bones should be at most 80.
 
         @param vertices   triangle mesh to draw
         @param bones      bone matrix data
         @param boneCount  number of bone matrices
         @param mode       combines vertices colors with SkShader, if both are present
         @param paint      specifies the SkShader, used as SkVertices texture, may be nullptr
     */
     void drawVertices(const sk_sp<SkVertices>& vertices, const SkVertices::Bone bones[],
                       int boneCount, SkBlendMode mode, const SkPaint& paint);
 
     /** Draws a Coons patch: the interpolation of four cubics with shared corners,
         associating a color, and optionally a texture SkPoint, with each corner.
 
         Coons patch uses clip and SkMatrix, paint SkShader, SkColorFilter,
         alpha, SkImageFilter, and SkBlendMode. If SkShader is provided it is treated
         as Coons patch texture; SkBlendMode mode combines color colors and SkShader if
         both are provided.
 
         SkPoint array cubics specifies four SkPath cubic starting at the top-left corner,
         in clockwise order, sharing every fourth point. The last SkPath cubic ends at the
         first point.
 
         Color array color associates colors with corners in top-left, top-right,
         bottom-right, bottom-left order.
 
         If paint contains SkShader, SkPoint array texCoords maps SkShader as texture to
         corners in top-left, top-right, bottom-right, bottom-left order.
 
         @param cubics     SkPath cubic array, sharing common points
         @param colors     color array, one for each corner
         @param texCoords  SkPoint array of texture coordinates, mapping SkShader to corners;
                           may be nullptr
         @param mode       SkBlendMode for colors, and for SkShader if paint has one
         @param paint      SkShader, SkColorFilter, SkBlendMode, used to draw
     */
     void drawPatch(const SkPoint cubics[12], const SkColor colors[4],
                    const SkPoint texCoords[4], SkBlendMode mode, const SkPaint& paint);
 
     /** Draws SkPath cubic Coons patch: the interpolation of four cubics with shared corners,
         associating a color, and optionally a texture SkPoint, with each corner.
 
         Coons patch uses clip and SkMatrix, paint SkShader, SkColorFilter,
         alpha, SkImageFilter, and SkBlendMode. If SkShader is provided it is treated
         as Coons patch texture; SkBlendMode mode combines color colors and SkShader if
         both are provided.
 
         SkPoint array cubics specifies four SkPath cubic starting at the top-left corner,
         in clockwise order, sharing every fourth point. The last SkPath cubic ends at the
         first point.
 
         Color array color associates colors with corners in top-left, top-right,
         bottom-right, bottom-left order.
 
         If paint contains SkShader, SkPoint array texCoords maps SkShader as texture to
         corners in top-left, top-right, bottom-right, bottom-left order.
 
         @param cubics     SkPath cubic array, sharing common points
         @param colors     color array, one for each corner
         @param texCoords  SkPoint array of texture coordinates, mapping SkShader to corners;
                           may be nullptr
         @param paint      SkShader, SkColorFilter, SkBlendMode, used to draw
     */
     void drawPatch(const SkPoint cubics[12], const SkColor colors[4],
                    const SkPoint texCoords[4], const SkPaint& paint) {
         this->drawPatch(cubics, colors, texCoords, SkBlendMode::kModulate, paint);
     }
 
     /** Draws a set of sprites from atlas, using clip, SkMatrix, and optional SkPaint paint.
         paint uses anti-alias, alpha, SkColorFilter, SkImageFilter, and SkBlendMode
         to draw, if present. For each entry in the array, SkRect tex locates sprite in
         atlas, and SkRSXform xform transforms it into destination space.
 
         xform, text, and colors if present, must contain count entries.
         Optional colors are applied for each sprite using SkBlendMode mode, treating
         sprite as source and colors as destination.
         Optional cullRect is a conservative bounds of all transformed sprites.
         If cullRect is outside of clip, canvas can skip drawing.
 
         @param atlas     SkImage containing sprites
         @param xform     SkRSXform mappings for sprites in atlas
         @param tex       SkRect locations of sprites in atlas
         @param colors    one per sprite, blended with sprite using SkBlendMode; may be nullptr
         @param count     number of sprites to draw
         @param mode      SkBlendMode combining colors and sprites
         @param cullRect  bounds of transformed sprites for efficient clipping; may be nullptr
         @param paint     SkColorFilter, SkImageFilter, SkBlendMode, and so on; may be nullptr
     */
     void drawAtlas(const SkImage* atlas, const SkRSXform xform[], const SkRect tex[],
                    const SkColor colors[], int count, SkBlendMode mode, const SkRect* cullRect,
                    const SkPaint* paint);
 
     /** Draws a set of sprites from atlas, using clip, SkMatrix, and optional SkPaint paint.
         paint uses anti-alias, alpha, SkColorFilter, SkImageFilter, and SkBlendMode
         to draw, if present. For each entry in the array, SkRect tex locates sprite in
         atlas, and SkRSXform xform transforms it into destination space.
 
         xform, text, and colors if present, must contain count entries.
         Optional colors is applied for each sprite using SkBlendMode.
         Optional cullRect is a conservative bounds of all transformed sprites.
         If cullRect is outside of clip, canvas can skip drawing.
 
         @param atlas     SkImage containing sprites
         @param xform     SkRSXform mappings for sprites in atlas
         @param tex       SkRect locations of sprites in atlas
         @param colors    one per sprite, blended with sprite using SkBlendMode; may be nullptr
         @param count     number of sprites to draw
         @param mode      SkBlendMode combining colors and sprites
         @param cullRect  bounds of transformed sprites for efficient clipping; may be nullptr
         @param paint     SkColorFilter, SkImageFilter, SkBlendMode, and so on; may be nullptr
     */
     void drawAtlas(const sk_sp<SkImage>& atlas, const SkRSXform xform[], const SkRect tex[],
                    const SkColor colors[], int count, SkBlendMode mode, const SkRect* cullRect,
                    const SkPaint* paint) {
         this->drawAtlas(atlas.get(), xform, tex, colors, count, mode, cullRect, paint);
     }
 
     /** Draws a set of sprites from atlas, using clip, SkMatrix, and optional SkPaint paint.
         paint uses anti-alias, alpha, SkColorFilter, SkImageFilter, and SkBlendMode
         to draw, if present. For each entry in the array, SkRect tex locates sprite in
         atlas, and SkRSXform xform transforms it into destination space.
 
         xform and text must contain count entries.
         Optional cullRect is a conservative bounds of all transformed sprites.
         If cullRect is outside of clip, canvas can skip drawing.
 
         @param atlas     SkImage containing sprites
         @param xform     SkRSXform mappings for sprites in atlas
         @param tex       SkRect locations of sprites in atlas
         @param count     number of sprites to draw
         @param cullRect  bounds of transformed sprites for efficient clipping; may be nullptr
         @param paint     SkColorFilter, SkImageFilter, SkBlendMode, and so on; may be nullptr
     */
     void drawAtlas(const SkImage* atlas, const SkRSXform xform[], const SkRect tex[], int count,
                    const SkRect* cullRect, const SkPaint* paint) {
         this->drawAtlas(atlas, xform, tex, nullptr, count, SkBlendMode::kDst, cullRect, paint);
     }
 
     /** Draws a set of sprites from atlas, using clip, SkMatrix, and optional SkPaint paint.
         paint uses anti-alias, alpha, SkColorFilter, SkImageFilter, and SkBlendMode
         to draw, if present. For each entry in the array, SkRect tex locates sprite in
         atlas, and SkRSXform xform transforms it into destination space.
 
         xform and text must contain count entries.
         Optional cullRect is a conservative bounds of all transformed sprites.
         If cullRect is outside of clip, canvas can skip drawing.
 
         @param atlas     SkImage containing sprites
         @param xform     SkRSXform mappings for sprites in atlas
         @param tex       SkRect locations of sprites in atlas
         @param count     number of sprites to draw
         @param cullRect  bounds of transformed sprites for efficient clipping; may be nullptr
         @param paint     SkColorFilter, SkImageFilter, SkBlendMode, and so on; may be nullptr
     */
     void drawAtlas(const sk_sp<SkImage>& atlas, const SkRSXform xform[], const SkRect tex[],
                    int count, const SkRect* cullRect, const SkPaint* paint) {
         this->drawAtlas(atlas.get(), xform, tex, nullptr, count, SkBlendMode::kDst,
                         cullRect, paint);
     }
 
     /** Draws SkDrawable drawable using clip and SkMatrix, concatenated with
         optional matrix.
 
         If SkCanvas has an asynchronous implementation, as is the case
         when it is recording into SkPicture, then drawable will be referenced,
         so that SkDrawable::draw() can be called when the operation is finalized. To force
         immediate drawing, call SkDrawable::draw() instead.
 
         @param drawable  custom struct encapsulating drawing commands
         @param matrix    transformation applied to drawing; may be nullptr
     */
     void drawDrawable(SkDrawable* drawable, const SkMatrix* matrix = nullptr);
 
     /** Draws SkDrawable drawable using clip and SkMatrix, offset by (x, y).
 
         If SkCanvas has an asynchronous implementation, as is the case
         when it is recording into SkPicture, then drawable will be referenced,
         so that SkDrawable::draw() can be called when the operation is finalized. To force
         immediate drawing, call SkDrawable::draw() instead.
 
         @param drawable  custom struct encapsulating drawing commands
         @param x         offset into SkCanvas writable pixels on x-axis
         @param y         offset into SkCanvas writable pixels on y-axis
     */
     void drawDrawable(SkDrawable* drawable, SkScalar x, SkScalar y);
 
     /** Associates SkRect on SkCanvas with an annotation; a key-value pair, where the key is
         a null-terminated UTF-8 string, and optional value is stored as SkData.
 
         Only some canvas implementations, such as recording to SkPicture, or drawing to
         document PDF, use annotations.
 
         @param rect   SkRect extent of canvas to annotate
         @param key    string used for lookup
         @param value  data holding value stored in annotation
     */
     void drawAnnotation(const SkRect& rect, const char key[], SkData* value);
 
     /** Associates SkRect on SkCanvas when an annotation; a key-value pair, where the key is
         a null-terminated UTF-8 string, and optional value is stored as SkData.
 
         Only some canvas implementations, such as recording to SkPicture, or drawing to
         document PDF, use annotations.
 
         @param rect   SkRect extent of canvas to annotate
         @param key    string used for lookup
         @param value  data holding value stored in annotation
     */
     void drawAnnotation(const SkRect& rect, const char key[], const sk_sp<SkData>& value) {
         this->drawAnnotation(rect, key, value.get());
     }
 
     /** Returns true if clip is empty; that is, nothing will draw.
 
         May do work when called; it should not be called
         more often than needed. However, once called, subsequent calls perform no
         work until clip changes.
 
         @return  true if clip is empty
     */
     virtual bool isClipEmpty() const;
 
     /** Returns true if clip is SkRect and not empty.
         Returns false if the clip is empty, or if it is not SkRect.
 
         @return  true if clip is SkRect and not empty
     */
     virtual bool isClipRect() const;
 
     /** Returns SkMatrix.
         This does not account for translation by SkBaseDevice or SkSurface.
 
         @return  SkMatrix in SkCanvas
     */
     const SkMatrix& getTotalMatrix() const;
 
     ///////////////////////////////////////////////////////////////////////////
 
     // don't call
     virtual GrRenderTargetContext* internal_private_accessTopLayerRenderTargetContext();
     SkIRect internal_private_getTopLayerBounds() const { return getTopLayerBounds(); }
 
     // TEMP helpers until we switch virtual over to const& for src-rect
     void legacy_drawImageRect(const SkImage* image, const SkRect* src, const SkRect& dst,
                               const SkPaint* paint,
                               SrcRectConstraint constraint = kStrict_SrcRectConstraint);
     void legacy_drawBitmapRect(const SkBitmap& bitmap, const SkRect* src, const SkRect& dst,
                                const SkPaint* paint,
                                SrcRectConstraint constraint = kStrict_SrcRectConstraint);
 
     /**
      *  Returns the global clip as a region. If the clip contains AA, then only the bounds
      *  of the clip may be returned.
      */
     void temporary_internal_getRgnClip(SkRegion* region);
 
     void private_draw_shadow_rec(const SkPath&, const SkDrawShadowRec&);
@@ -2403,117 +2343,116 @@ public:
 protected:
     // default impl defers to getDevice()->newSurface(info)
     virtual sk_sp<SkSurface> onNewSurface(const SkImageInfo& info, const SkSurfaceProps& props);
 
     // default impl defers to its device
     virtual bool onPeekPixels(SkPixmap* pixmap);
     virtual bool onAccessTopLayerPixels(SkPixmap* pixmap);
     virtual SkImageInfo onImageInfo() const;
     virtual bool onGetProps(SkSurfaceProps* props) const;
     virtual void onFlush();
 
     // Subclass save/restore notifiers.
     // Overriders should call the corresponding INHERITED method up the inheritance chain.
     // getSaveLayerStrategy()'s return value may suppress full layer allocation.
     enum SaveLayerStrategy {
         kFullLayer_SaveLayerStrategy,
         kNoLayer_SaveLayerStrategy,
     };
 
     virtual void willSave() {}
     // Overriders should call the corresponding INHERITED method up the inheritance chain.
     virtual SaveLayerStrategy getSaveLayerStrategy(const SaveLayerRec& ) {
         return kFullLayer_SaveLayerStrategy;
     }
     // returns true if we should actually perform the saveBehind, or false if we should just save.
     virtual bool onDoSaveBehind(const SkRect*) { return true; }
     virtual void willRestore() {}
     virtual void didRestore() {}
     virtual void didConcat(const SkMatrix& ) {}
     virtual void didSetMatrix(const SkMatrix& ) {}
     virtual void didTranslate(SkScalar dx, SkScalar dy) {
         this->didConcat(SkMatrix::MakeTrans(dx, dy));
     }
 
     // NOTE: If you are adding a new onDraw virtual to SkCanvas, PLEASE add an override to
     // SkCanvasVirtualEnforcer (in SkCanvasVirtualEnforcer.h). This ensures that subclasses using
     // that mechanism  will be required to implement the new function.
     virtual void onDrawPaint(const SkPaint& paint);
     virtual void onDrawRect(const SkRect& rect, const SkPaint& paint);
+    virtual void onDrawEdgeAARect(const SkRect& rect, QuadAAFlags edgeAA, SkColor color,
+                                  SkBlendMode mode);
     virtual void onDrawRRect(const SkRRect& rrect, const SkPaint& paint);
     virtual void onDrawDRRect(const SkRRect& outer, const SkRRect& inner, const SkPaint& paint);
     virtual void onDrawOval(const SkRect& rect, const SkPaint& paint);
     virtual void onDrawArc(const SkRect& rect, SkScalar startAngle, SkScalar sweepAngle,
                            bool useCenter, const SkPaint& paint);
     virtual void onDrawPath(const SkPath& path, const SkPaint& paint);
     virtual void onDrawRegion(const SkRegion& region, const SkPaint& paint);
 
     virtual void onDrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                                 const SkPaint& paint);
 
     virtual void onDrawPatch(const SkPoint cubics[12], const SkColor colors[4],
                            const SkPoint texCoords[4], SkBlendMode mode, const SkPaint& paint);
     virtual void onDrawPoints(PointMode mode, size_t count, const SkPoint pts[],
                               const SkPaint& paint);
 
     // TODO: Remove old signature
     virtual void onDrawVerticesObject(const SkVertices* vertices, SkBlendMode mode,
                                       const SkPaint& paint) {
         this->onDrawVerticesObject(vertices, nullptr, 0, mode, paint);
     }
     virtual void onDrawVerticesObject(const SkVertices* vertices, const SkVertices::Bone bones[],
                                       int boneCount, SkBlendMode mode, const SkPaint& paint);
 
     virtual void onDrawImage(const SkImage* image, SkScalar dx, SkScalar dy, const SkPaint* paint);
     virtual void onDrawImageRect(const SkImage* image, const SkRect* src, const SkRect& dst,
                                  const SkPaint* paint, SrcRectConstraint constraint);
     virtual void onDrawImageNine(const SkImage* image, const SkIRect& center, const SkRect& dst,
                                  const SkPaint* paint);
     virtual void onDrawImageLattice(const SkImage* image, const Lattice& lattice, const SkRect& dst,
                                     const SkPaint* paint);
 
+    virtual void onDrawImageSet(const ImageSetEntry imageSet[], int count, SkFilterQuality,
+                                SkBlendMode);
+
     virtual void onDrawBitmap(const SkBitmap& bitmap, SkScalar dx, SkScalar dy,
                               const SkPaint* paint);
     virtual void onDrawBitmapRect(const SkBitmap& bitmap, const SkRect* src, const SkRect& dst,
                                   const SkPaint* paint, SrcRectConstraint constraint);
     virtual void onDrawBitmapNine(const SkBitmap& bitmap, const SkIRect& center, const SkRect& dst,
                                   const SkPaint* paint);
     virtual void onDrawBitmapLattice(const SkBitmap& bitmap, const Lattice& lattice,
                                      const SkRect& dst, const SkPaint* paint);
 
     virtual void onDrawAtlas(const SkImage* atlas, const SkRSXform xform[], const SkRect rect[],
                              const SkColor colors[], int count, SkBlendMode mode,
                              const SkRect* cull, const SkPaint* paint);
 
     virtual void onDrawAnnotation(const SkRect& rect, const char key[], SkData* value);
     virtual void onDrawShadowRec(const SkPath&, const SkDrawShadowRec&);
 
     virtual void onDrawDrawable(SkDrawable* drawable, const SkMatrix* matrix);
     virtual void onDrawPicture(const SkPicture* picture, const SkMatrix* matrix,
                                const SkPaint* paint);
 
-    virtual void onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4], QuadAAFlags aaFlags,
-                                  SkColor color, SkBlendMode mode);
-    virtual void onDrawEdgeAAImageSet(const ImageSetEntry imageSet[], int count,
-                                      const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                                      const SkPaint* paint, SrcRectConstraint constraint);
-
     enum ClipEdgeStyle {
         kHard_ClipEdgeStyle,
         kSoft_ClipEdgeStyle
     };
 
     virtual void onClipRect(const SkRect& rect, SkClipOp op, ClipEdgeStyle edgeStyle);
     virtual void onClipRRect(const SkRRect& rrect, SkClipOp op, ClipEdgeStyle edgeStyle);
     virtual void onClipPath(const SkPath& path, SkClipOp op, ClipEdgeStyle edgeStyle);
     virtual void onClipRegion(const SkRegion& deviceRgn, SkClipOp op);
 
     virtual void onDiscard();
 
     // Clip rectangle bounds. Called internally by saveLayer.
     // returns false if the entire rectangle is entirely clipped out
     // If non-NULL, The imageFilter parameter will be used to expand the clip
     // and offscreen bounds for any margin required by the filter DAG.
     bool clipRectBounds(const SkRect* bounds, SaveLayerFlags flags, SkIRect* intersection,
                         const SkImageFilter* imageFilter = nullptr);
 
     SkBaseDevice* getTopDevice() const;
@@ -2617,13 +2556,14 @@ private:
     friend class SkAndroidFrameworkUtils;
     friend class SkCanvasPriv;      // needs kDontClipToLayer_PrivateSaveLayerFlag
     friend class SkDrawIter;        // needs setupDrawForLayerDevice()
     friend class AutoDrawLooper;
     friend class SkDebugCanvas;     // needs experimental fAllowSimplifyClip
     friend class SkSurface_Raster;  // needs getDevice()
     friend class SkNoDrawCanvas;    // needs resetForNextPicture()
     friend class SkPictureRecord;   // predrawNotify (why does it need it? <reed>)
     friend class SkOverdrawCanvas;
     friend class SkRasterHandleAllocator;
+    friend class ClipTileRenderer;  // GM needs getTopDevice() until API is in SkCanvas
 protected:
     // For use by SkNoDrawCanvas (via SkCanvasVirtualEnforcer, which can't be a friend)
     SkCanvas(const SkIRect& bounds);
diff --git a/include/core/SkCanvasVirtualEnforcer.h b/include/core/SkCanvasVirtualEnforcer.h
index 4a284b3148..f097911b1c 100644
--- a/include/core/SkCanvasVirtualEnforcer.h
+++ b/include/core/SkCanvasVirtualEnforcer.h
@@ -21,71 +21,69 @@ public:
 protected:
     void onDrawPaint(const SkPaint& paint) override = 0;
     void onDrawRect(const SkRect& rect, const SkPaint& paint) override = 0;
     void onDrawRRect(const SkRRect& rrect, const SkPaint& paint) override = 0;
     void onDrawDRRect(const SkRRect& outer, const SkRRect& inner,
                       const SkPaint& paint) override = 0;
     void onDrawOval(const SkRect& rect, const SkPaint& paint) override = 0;
     void onDrawArc(const SkRect& rect, SkScalar startAngle, SkScalar sweepAngle, bool useCenter,
                    const SkPaint& paint) override = 0;
     void onDrawPath(const SkPath& path, const SkPaint& paint) override = 0;
     void onDrawRegion(const SkRegion& region, const SkPaint& paint) override = 0;
 
     void onDrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                         const SkPaint& paint) override = 0;
 
     void onDrawPatch(const SkPoint cubics[12], const SkColor colors[4],
                      const SkPoint texCoords[4], SkBlendMode mode,
                      const SkPaint& paint) override = 0;
     void onDrawPoints(SkCanvas::PointMode mode, size_t count, const SkPoint pts[],
                       const SkPaint& paint) override = 0;
     void onDrawVerticesObject(const SkVertices*, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode, const SkPaint&) override = 0;
 
     void onDrawImage(const SkImage* image, SkScalar dx, SkScalar dy,
                      const SkPaint* paint) override = 0;
     void onDrawImageRect(const SkImage* image, const SkRect* src, const SkRect& dst,
                          const SkPaint* paint, SkCanvas::SrcRectConstraint constraint) override = 0;
     void onDrawImageNine(const SkImage* image, const SkIRect& center, const SkRect& dst,
                          const SkPaint* paint) override = 0;
     void onDrawImageLattice(const SkImage* image, const SkCanvas::Lattice& lattice,
                             const SkRect& dst, const SkPaint* paint) override = 0;
 
 #ifdef SK_BUILD_FOR_ANDROID_FRAMEWORK
     // This is under active development for Chrome and not used in Android. Hold off on adding
     // implementations in Android's SkCanvas subclasses until this stabilizes.
-    void onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-            SkCanvas::QuadAAFlags aaFlags, SkColor color, SkBlendMode mode) override {}
-    void onDrawEdgeAAImageSet(const SkCanvas::ImageSetEntry imageSet[], int count,
-            const SkPoint dstClips[], const SkMatrix preViewMatrices[], const SkPaint* paint,
-            SkCanvas::SrcRectConstraint constraint) override {}
+    void onDrawImageSet(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality,
+                        SkBlendMode) override {};
+    void onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags edgeAA, SkColor color,
+                          SkBlendMode mode) override {};
 #else
-    void onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-            SkCanvas::QuadAAFlags aaFlags, SkColor color, SkBlendMode mode) override = 0;
-    void onDrawEdgeAAImageSet(const SkCanvas::ImageSetEntry imageSet[], int count,
-            const SkPoint dstClips[], const SkMatrix preViewMatrices[], const SkPaint* paint,
-            SkCanvas::SrcRectConstraint constraint) override = 0;
+    void onDrawImageSet(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality,
+                        SkBlendMode) override = 0;
+    void onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags edgeAA, SkColor color,
+                          SkBlendMode mode) override = 0;
 #endif
 
     void onDrawBitmap(const SkBitmap& bitmap, SkScalar dx, SkScalar dy,
                       const SkPaint* paint) override = 0;
     void onDrawBitmapRect(const SkBitmap& bitmap, const SkRect* src, const SkRect& dst,
                           const SkPaint* paint,
                           SkCanvas::SrcRectConstraint constraint) override = 0;
     void onDrawBitmapNine(const SkBitmap& bitmap, const SkIRect& center, const SkRect& dst,
                           const SkPaint* paint) override = 0;
     void onDrawBitmapLattice(const SkBitmap& bitmap, const SkCanvas::Lattice& lattice,
                              const SkRect& dst, const SkPaint* paint) override = 0;
 
     void onDrawAtlas(const SkImage* atlas, const SkRSXform xform[], const SkRect rect[],
                      const SkColor colors[], int count, SkBlendMode mode, const SkRect* cull,
                      const SkPaint* paint) override = 0;
 
     void onDrawAnnotation(const SkRect& rect, const char key[], SkData* value) override = 0;
     void onDrawShadowRec(const SkPath&, const SkDrawShadowRec&) override = 0;
 
     void onDrawDrawable(SkDrawable* drawable, const SkMatrix* matrix) override = 0;
     void onDrawPicture(const SkPicture* picture, const SkMatrix* matrix,
                        const SkPaint* paint) override = 0;
 };
 
 #endif
diff --git a/include/core/SkOverdrawCanvas.h b/include/core/SkOverdrawCanvas.h
index cbd6646c94..e0d05c82bd 100644
--- a/include/core/SkOverdrawCanvas.h
+++ b/include/core/SkOverdrawCanvas.h
@@ -20,45 +20,42 @@ class SK_API SkOverdrawCanvas : public SkCanvasVirtualEnforcer<SkNWayCanvas> {
 public:
     /* Does not take ownership of canvas */
     SkOverdrawCanvas(SkCanvas*);
 
     void onDrawTextBlob(const SkTextBlob*, SkScalar, SkScalar, const SkPaint&) override;
     void onDrawPatch(const SkPoint[12], const SkColor[4], const SkPoint[4], SkBlendMode,
                      const SkPaint&) override;
     void onDrawPaint(const SkPaint&) override;
     void onDrawRect(const SkRect&, const SkPaint&) override;
+    void onDrawEdgeAARect(const SkRect&, SkCanvas::QuadAAFlags, SkColor, SkBlendMode) override;
     void onDrawRegion(const SkRegion&, const SkPaint&) override;
     void onDrawOval(const SkRect&, const SkPaint&) override;
     void onDrawArc(const SkRect&, SkScalar, SkScalar, bool, const SkPaint&) override;
     void onDrawDRRect(const SkRRect&, const SkRRect&, const SkPaint&) override;
     void onDrawRRect(const SkRRect&, const SkPaint&) override;
     void onDrawPoints(PointMode, size_t, const SkPoint[], const SkPaint&) override;
     void onDrawVerticesObject(const SkVertices*, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode, const SkPaint&) override;
     void onDrawAtlas(const SkImage*, const SkRSXform[], const SkRect[], const SkColor[],
                      int, SkBlendMode, const SkRect*, const SkPaint*) override;
     void onDrawPath(const SkPath&, const SkPaint&) override;
     void onDrawImage(const SkImage*, SkScalar, SkScalar, const SkPaint*) override;
     void onDrawImageRect(const SkImage*, const SkRect*, const SkRect&, const SkPaint*,
                          SrcRectConstraint) override;
     void onDrawImageNine(const SkImage*, const SkIRect&, const SkRect&, const SkPaint*) override;
     void onDrawImageLattice(const SkImage*, const Lattice&, const SkRect&, const SkPaint*) override;
+    void onDrawImageSet(const ImageSetEntry[], int count, SkFilterQuality, SkBlendMode) override;
     void onDrawBitmap(const SkBitmap&, SkScalar, SkScalar, const SkPaint*) override;
     void onDrawBitmapRect(const SkBitmap&, const SkRect*, const SkRect&, const SkPaint*,
                           SrcRectConstraint) override;
     void onDrawBitmapNine(const SkBitmap&, const SkIRect&, const SkRect&, const SkPaint*) override;
     void onDrawBitmapLattice(const SkBitmap&, const Lattice&, const SkRect&,
                              const SkPaint*) override;
     void onDrawDrawable(SkDrawable*, const SkMatrix*) override;
     void onDrawPicture(const SkPicture*, const SkMatrix*, const SkPaint*) override;
 
     void onDrawAnnotation(const SkRect&, const char key[], SkData* value) override;
     void onDrawShadowRec(const SkPath&, const SkDrawShadowRec&) override;
 
-    void onDrawEdgeAAQuad(const SkRect&, const SkPoint[4], SkCanvas::QuadAAFlags, SkColor,
-                          SkBlendMode) override;
-    void onDrawEdgeAAImageSet(const ImageSetEntry[], int count, const SkPoint[], const SkMatrix[],
-                              const SkPaint*, SrcRectConstraint) override;
-
 private:
     void drawPosTextCommon(const SkGlyphID[], int, const SkScalar[], int, const SkPoint&,
                            const SkFont&, const SkPaint&);
diff --git a/include/utils/SkNWayCanvas.h b/include/utils/SkNWayCanvas.h
index 716c3b8f3c..09b071d5c7 100644
--- a/include/utils/SkNWayCanvas.h
+++ b/include/utils/SkNWayCanvas.h
@@ -25,62 +25,60 @@ public:
 protected:
     SkTDArray<SkCanvas*> fList;
 
     void willSave() override;
     SaveLayerStrategy getSaveLayerStrategy(const SaveLayerRec&) override;
     bool onDoSaveBehind(const SkRect*) override;
     void willRestore() override;
 
     void didConcat(const SkMatrix&) override;
     void didSetMatrix(const SkMatrix&) override;
 
     void onDrawDRRect(const SkRRect&, const SkRRect&, const SkPaint&) override;
     virtual void onDrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                                 const SkPaint& paint) override;
     virtual void onDrawPatch(const SkPoint cubics[12], const SkColor colors[4],
                              const SkPoint texCoords[4], SkBlendMode,
                              const SkPaint& paint) override;
 
     void onDrawPaint(const SkPaint&) override;
     void onDrawPoints(PointMode, size_t count, const SkPoint pts[], const SkPaint&) override;
     void onDrawRect(const SkRect&, const SkPaint&) override;
+    void onDrawEdgeAARect(const SkRect&, SkCanvas::QuadAAFlags, SkColor, SkBlendMode) override;
     void onDrawRegion(const SkRegion&, const SkPaint&) override;
     void onDrawOval(const SkRect&, const SkPaint&) override;
     void onDrawArc(const SkRect&, SkScalar, SkScalar, bool, const SkPaint&) override;
     void onDrawRRect(const SkRRect&, const SkPaint&) override;
     void onDrawPath(const SkPath&, const SkPaint&) override;
     void onDrawBitmap(const SkBitmap&, SkScalar left, SkScalar top, const SkPaint*) override;
     void onDrawBitmapRect(const SkBitmap&, const SkRect* src, const SkRect& dst, const SkPaint*,
                           SrcRectConstraint) override;
     void onDrawImage(const SkImage*, SkScalar left, SkScalar top, const SkPaint*) override;
     void onDrawImageRect(const SkImage*, const SkRect* src, const SkRect& dst,
                          const SkPaint*, SrcRectConstraint) override;
     void onDrawBitmapLattice(const SkBitmap&, const Lattice&, const SkRect&,
                              const SkPaint*) override;
     void onDrawImageLattice(const SkImage*, const Lattice&, const SkRect&, const SkPaint*) override;
     void onDrawImageNine(const SkImage*, const SkIRect& center, const SkRect& dst,
                          const SkPaint*) override;
+    void onDrawImageSet(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality,
+                        SkBlendMode) override;
     void onDrawBitmapNine(const SkBitmap&, const SkIRect& center, const SkRect& dst,
                           const SkPaint*) override;
     void onDrawVerticesObject(const SkVertices*, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode, const SkPaint&) override;
     void onDrawAtlas(const SkImage*, const SkRSXform[], const SkRect[], const SkColor[],
                      int, SkBlendMode, const SkRect*, const SkPaint*) override;
     void onDrawShadowRec(const SkPath&, const SkDrawShadowRec&) override;
 
     void onClipRect(const SkRect&, SkClipOp, ClipEdgeStyle) override;
     void onClipRRect(const SkRRect&, SkClipOp, ClipEdgeStyle) override;
     void onClipPath(const SkPath&, SkClipOp, ClipEdgeStyle) override;
     void onClipRegion(const SkRegion&, SkClipOp) override;
 
     void onDrawPicture(const SkPicture*, const SkMatrix*, const SkPaint*) override;
     void onDrawDrawable(SkDrawable*, const SkMatrix*) override;
     void onDrawAnnotation(const SkRect&, const char[], SkData*) override;
 
-    void onDrawEdgeAAQuad(const SkRect&, const SkPoint[4], QuadAAFlags, SkColor,
-                          SkBlendMode) override;
-    void onDrawEdgeAAImageSet(const ImageSetEntry[], int count, const SkPoint[], const SkMatrix[],
-                              const SkPaint*, SrcRectConstraint) override;
-
     void onFlush() override;
 
     class Iter;
diff --git a/include/utils/SkNoDrawCanvas.h b/include/utils/SkNoDrawCanvas.h
index a172632e84..ff1b027548 100644
--- a/include/utils/SkNoDrawCanvas.h
+++ b/include/utils/SkNoDrawCanvas.h
@@ -39,48 +39,46 @@ public:
 protected:
     SaveLayerStrategy getSaveLayerStrategy(const SaveLayerRec& rec) override;
     bool onDoSaveBehind(const SkRect*) override;
 
     // No-op overrides for aborting rasterization earlier than SkNullBlitter.
     void onDrawAnnotation(const SkRect&, const char[], SkData*) override {}
     void onDrawDRRect(const SkRRect&, const SkRRect&, const SkPaint&) override {}
     void onDrawDrawable(SkDrawable*, const SkMatrix*) override {}
     void onDrawTextBlob(const SkTextBlob*, SkScalar, SkScalar, const SkPaint&) override {}
     void onDrawPatch(const SkPoint[12], const SkColor[4], const SkPoint[4], SkBlendMode,
                      const SkPaint&) override {}
 
     void onDrawPaint(const SkPaint&) override {}
     void onDrawPoints(PointMode, size_t, const SkPoint[], const SkPaint&) override {}
     void onDrawRect(const SkRect&, const SkPaint&) override {}
+    void onDrawEdgeAARect(const SkRect&, SkCanvas::QuadAAFlags, SkColor, SkBlendMode) override {}
     void onDrawRegion(const SkRegion&, const SkPaint&) override {}
     void onDrawOval(const SkRect&, const SkPaint&) override {}
     void onDrawArc(const SkRect&, SkScalar, SkScalar, bool, const SkPaint&) override {}
     void onDrawRRect(const SkRRect&, const SkPaint&) override {}
     void onDrawPath(const SkPath&, const SkPaint&) override {}
     void onDrawBitmap(const SkBitmap&, SkScalar, SkScalar, const SkPaint*) override {}
     void onDrawBitmapRect(const SkBitmap&, const SkRect*, const SkRect&, const SkPaint*,
                           SrcRectConstraint) override {}
     void onDrawImage(const SkImage*, SkScalar, SkScalar, const SkPaint*) override {}
     void onDrawImageRect(const SkImage*, const SkRect*, const SkRect&, const SkPaint*,
                          SrcRectConstraint) override {}
     void onDrawImageNine(const SkImage*, const SkIRect&, const SkRect&, const SkPaint*) override {}
     void onDrawBitmapNine(const SkBitmap&, const SkIRect&, const SkRect&,
                           const SkPaint*) override {}
     void onDrawImageLattice(const SkImage*, const Lattice&, const SkRect&,
                             const SkPaint*) override {}
+    void onDrawImageSet(const SkCanvas::ImageSetEntry[], int, SkFilterQuality,
+                        SkBlendMode) override {}
     void onDrawBitmapLattice(const SkBitmap&, const Lattice&, const SkRect&,
                              const SkPaint*) override {}
     void onDrawVerticesObject(const SkVertices*, const SkVertices::Bone[], int, SkBlendMode,
                               const SkPaint&) override {}
     void onDrawAtlas(const SkImage*, const SkRSXform[], const SkRect[], const SkColor[],
                      int, SkBlendMode, const SkRect*, const SkPaint*) override {}
     void onDrawShadowRec(const SkPath&, const SkDrawShadowRec&) override {}
     void onDrawPicture(const SkPicture*, const SkMatrix*, const SkPaint*) override {}
 
-    void onDrawEdgeAAQuad(const SkRect&, const SkPoint[4], QuadAAFlags, SkColor,
-                          SkBlendMode) override {}
-    void onDrawEdgeAAImageSet(const ImageSetEntry[], int, const SkPoint[],
-                              const SkMatrix[], const SkPaint*, SrcRectConstraint) override {}
-
 private:
     typedef SkCanvasVirtualEnforcer<SkCanvas> INHERITED;
 };
diff --git a/include/utils/SkPaintFilterCanvas.h b/include/utils/SkPaintFilterCanvas.h
index 23019d3144..2781a20757 100644
--- a/include/utils/SkPaintFilterCanvas.h
+++ b/include/utils/SkPaintFilterCanvas.h
@@ -54,63 +54,61 @@ public:
 protected:
     /**
      *  Called with the paint that will be used to draw the specified type.
      *  The implementation may modify the paint as they wish (using SkTCopyOnFirstWrite::writable).
      *
      *  The result bool is used to determine whether the draw op is to be
      *  executed (true) or skipped (false).
      *
      *  Note: The base implementation calls onFilter() for top-level/explicit paints only.
      *        To also filter encapsulated paints (e.g. SkPicture, SkTextBlob), clients may need to
      *        override the relevant methods (i.e. drawPicture, drawTextBlob).
      */
     virtual bool onFilter(SkTCopyOnFirstWrite<SkPaint>* paint, Type type) const = 0;
 
     void onDrawPaint(const SkPaint&) override;
     void onDrawPoints(PointMode, size_t count, const SkPoint pts[], const SkPaint&) override;
     void onDrawRect(const SkRect&, const SkPaint&) override;
+    void onDrawEdgeAARect(const SkRect&, SkCanvas::QuadAAFlags, SkColor, SkBlendMode) override;
     void onDrawRRect(const SkRRect&, const SkPaint&) override;
     void onDrawDRRect(const SkRRect&, const SkRRect&, const SkPaint&) override;
     void onDrawRegion(const SkRegion&, const SkPaint&) override;
     void onDrawOval(const SkRect&, const SkPaint&) override;
     void onDrawArc(const SkRect&, SkScalar, SkScalar, bool, const SkPaint&) override;
     void onDrawPath(const SkPath&, const SkPaint&) override;
     void onDrawBitmap(const SkBitmap&, SkScalar left, SkScalar top, const SkPaint*) override;
     void onDrawBitmapRect(const SkBitmap&, const SkRect* src, const SkRect& dst, const SkPaint*,
                           SrcRectConstraint) override;
     void onDrawBitmapNine(const SkBitmap&, const SkIRect& center, const SkRect& dst,
                           const SkPaint*) override;
     void onDrawBitmapLattice(const SkBitmap&, const Lattice&, const SkRect&,
                              const SkPaint*) override;
     void onDrawImage(const SkImage*, SkScalar left, SkScalar top, const SkPaint*) override;
     void onDrawImageRect(const SkImage*, const SkRect* src, const SkRect& dst,
                          const SkPaint*, SrcRectConstraint) override;
     void onDrawImageNine(const SkImage*, const SkIRect& center, const SkRect& dst,
                          const SkPaint*) override;
     void onDrawImageLattice(const SkImage*, const Lattice&, const SkRect&,
                             const SkPaint*) override;
+    void onDrawImageSet(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality,
+                        SkBlendMode) override;
     void onDrawVerticesObject(const SkVertices*, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode, const SkPaint&) override;
     void onDrawPatch(const SkPoint cubics[12], const SkColor colors[4],
                              const SkPoint texCoords[4], SkBlendMode,
                              const SkPaint& paint) override;
     void onDrawPicture(const SkPicture*, const SkMatrix*, const SkPaint*) override;
     void onDrawDrawable(SkDrawable*, const SkMatrix*) override;
 
     void onDrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                         const SkPaint& paint) override;
     void onDrawAtlas(const SkImage*, const SkRSXform[], const SkRect[], const SkColor[],
                      int, SkBlendMode, const SkRect*, const SkPaint*) override;
     void onDrawAnnotation(const SkRect& rect, const char key[], SkData* value) override;
     void onDrawShadowRec(const SkPath& path, const SkDrawShadowRec& rec) override;
 
-    void onDrawEdgeAAQuad(const SkRect&, const SkPoint[4], QuadAAFlags, SkColor,
-                          SkBlendMode) override;
-    void onDrawEdgeAAImageSet(const ImageSetEntry[], int count, const SkPoint[], const SkMatrix[],
-                              const SkPaint*, SrcRectConstraint) override;
-
     // Forwarded to the wrapped canvas.
     sk_sp<SkSurface> onNewSurface(const SkImageInfo&, const SkSurfaceProps&) override;
     bool onPeekPixels(SkPixmap* pixmap) override;
     bool onAccessTopLayerPixels(SkPixmap* pixmap) override;
     SkImageInfo onImageInfo() const override;
     bool onGetProps(SkSurfaceProps* props) const override;
diff --git a/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-ASAN.json b/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-ASAN.json
index 94b01e0bb7..8fc03d79d1 100644
--- a/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-ASAN.json
+++ b/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-ASAN.json
@@ -1,487 +1,483 @@
 [
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "ensure-directory",
       "--mode",
       "0777",
       "[START_DIR]/tmp"
     ],
     "infra_step": true,
     "name": "makedirs tmp_dir"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/skp/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skp VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SKP_VERSION"
     ],
     "infra_step": true,
     "name": "write SKP_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/skimage/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skimage VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SK_IMAGE_VERSION"
     ],
     "infra_step": true,
     "name": "write SK_IMAGE_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/svg/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get svg VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SVG_VERSION"
     ],
     "infra_step": true,
     "name": "write SVG_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_BOT_ID', '')\n"
     ],
     "name": "get swarming bot id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_BOT_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_TASK_ID', '')\n"
     ],
     "name": "get swarming task id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_TASK_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[skia::flavor]/resources/symbolize_stack_trace.py",
       "[START_DIR]",
       "[START_DIR]/build/dm",
       "--resourcePath",
       "[START_DIR]/skia/resources",
       "--skps",
       "[START_DIR]/skp",
       "--images",
       "[START_DIR]/skimage/dm",
       "--colorImages",
       "[START_DIR]/skimage/colorspace",
       "--nameByHash",
       "--properties",
       "gitHash",
       "abc123",
       "builder",
       "Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-ASAN",
       "buildbucket_build_id",
       "123454321",
       "task_id",
       "task_12345",
       "swarming_bot_id",
       "skia-bot-123",
       "swarming_task_id",
       "123456",
       "--svgs",
       "[START_DIR]/svg",
       "--key",
       "arch",
       "x86_64",
       "compiler",
       "Clang",
       "configuration",
       "Debug",
       "cpu_or_gpu",
       "CPU",
       "cpu_or_gpu_value",
       "AVX2",
       "extra_config",
       "ASAN",
       "model",
       "GCE",
       "os",
       "Debian9",
       "style",
       "default",
       "--dont_write",
       "pdf",
       "--randomProcessorTest",
       "--nogpu",
       "--config",
       "8888",
       "pdf",
       "g8",
       "565",
       "pic-8888",
       "tiles_rt-8888",
       "lite-8888",
       "serialize-8888",
       "gbr-8888",
       "f16",
       "srgb",
       "esrgb",
       "narrow",
       "enarrow",
       "p3",
       "ep3",
       "rec2020",
       "erec2020",
       "--src",
       "tests",
       "gm",
       "image",
       "colorImage",
       "svg",
       "--blacklist",
       "~8888",
       "svg",
       "_",
       "_",
       "f16",
       "_",
       "_",
       "dstreadshuffle",
       "gbr-8888",
       "image",
       "_",
       "_",
       "gbr-8888",
       "colorImage",
       "_",
       "_",
       "g8",
       "image",
       "_",
       "_",
       "g8",
       "colorImage",
       "_",
       "_",
       "_",
       "image",
       "gen_platf",
       "error",
       "serialize-8888",
       "gm",
       "_",
       "bleed_image",
       "serialize-8888",
       "gm",
       "_",
       "c_gms",
       "serialize-8888",
       "gm",
       "_",
       "colortype",
       "serialize-8888",
       "gm",
       "_",
       "colortype_xfermodes",
       "serialize-8888",
       "gm",
       "_",
       "drawfilter",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds_0.75_0",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds_1_-0.25",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_match",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_iter",
       "serialize-8888",
       "gm",
       "_",
       "imagemasksubset",
       "serialize-8888",
       "gm",
       "_",
       "bitmapfilters",
       "serialize-8888",
       "gm",
       "_",
       "bitmapshaders",
       "serialize-8888",
       "gm",
       "_",
       "bleed",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_bmp",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_bmp_shader",
       "serialize-8888",
       "gm",
       "_",
       "convex_poly_clip",
       "serialize-8888",
       "gm",
       "_",
       "extractalpha",
       "serialize-8888",
       "gm",
       "_",
       "filterbitmap_checkerboard_32_32_g8",
       "serialize-8888",
       "gm",
       "_",
       "filterbitmap_image_mandrill_64",
       "serialize-8888",
       "gm",
       "_",
       "shadows",
       "serialize-8888",
       "gm",
       "_",
       "simpleaaclip_aaclip",
       "serialize-8888",
       "gm",
       "_",
       "composeshader_bitmap",
       "serialize-8888",
       "gm",
       "_",
       "scaled_tilemodes_npot",
       "serialize-8888",
       "gm",
       "_",
       "scaled_tilemodes",
       "serialize-8888",
       "gm",
       "_",
       "typefacerendering_pfaMac",
       "serialize-8888",
       "gm",
       "_",
       "parsedpaths",
       "serialize-8888",
       "gm",
       "_",
       "ImageGeneratorExternal_rect",
       "serialize-8888",
       "gm",
       "_",
       "ImageGeneratorExternal_shader",
       "serialize-8888",
       "gm",
       "_",
       "shadow_utils",
       "serialize-8888",
       "gm",
       "_",
       "persp_images",
       "serialize-8888",
       "gm",
       "_",
       "all_bitmap_configs",
       "serialize-8888",
       "gm",
       "_",
       "makecolorspace",
       "serialize-8888",
       "gm",
       "_",
       "readpixels",
       "serialize-8888",
       "gm",
       "_",
       "draw_image_set_rect_to_rect",
       "serialize-8888",
       "gm",
       "_",
-      "compositor_quads_shader",
-      "serialize-8888",
-      "gm",
-      "_",
       "analytic_antialias_convex",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_image",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_image_shader",
       "pic-8888",
       "gm",
       "_",
       "drawfilter",
       "lite-8888",
       "gm",
       "_",
       "drawfilter",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-picture",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-picture",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-raster",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-raster",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-ctable",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-ctable",
       "pic-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "lite-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "serialize-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "pic-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "lite-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "serialize-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "pic-8888",
       "gm",
       "_",
       "p3",
       "lite-8888",
       "gm",
       "_",
       "p3",
       "serialize-8888",
       "gm",
       "_",
       "p3",
       "tiles_rt-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "tiles_rt-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "--nonativeFonts",
       "--verbose"
     ],
     "cwd": "[START_DIR]/skia",
     "env": {
       "ASAN_OPTIONS": "symbolize=1 detect_leaks=1",
       "CHROME_HEADLESS": "1",
       "LD_LIBRARY_PATH": "[START_DIR]/clang_linux/lib",
       "LSAN_OPTIONS": "symbolize=1 print_suppressions=1",
       "PATH": "<PATH>:RECIPE_REPO[depot_tools]:[START_DIR]/clang_linux/bin",
       "UBSAN_OPTIONS": "symbolize=1 print_stacktrace=1"
     },
     "name": "symbolized dm"
   },
   {
     "jsonResult": null,
     "name": "$result"
   }
 ]
\ No newline at end of file
diff --git a/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-BonusConfigs.json b/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-BonusConfigs.json
index b7e39adc78..ad2ecc667b 100644
--- a/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-BonusConfigs.json
+++ b/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-BonusConfigs.json
@@ -1,559 +1,555 @@
 [
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "ensure-directory",
       "--mode",
       "0777",
       "[START_DIR]/tmp"
     ],
     "infra_step": true,
     "name": "makedirs tmp_dir"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/skp/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skp VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SKP_VERSION"
     ],
     "infra_step": true,
     "name": "write SKP_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/skimage/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skimage VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SK_IMAGE_VERSION"
     ],
     "infra_step": true,
     "name": "write SK_IMAGE_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/svg/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get svg VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SVG_VERSION"
     ],
     "infra_step": true,
     "name": "write SVG_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "rmtree",
       "[START_DIR]/test"
     ],
     "infra_step": true,
     "name": "rmtree test"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "ensure-directory",
       "--mode",
       "0777",
       "[START_DIR]/test"
     ],
     "infra_step": true,
     "name": "makedirs test"
   },
   {
     "cmd": [
       "python",
       "-u",
       "\nimport contextlib\nimport math\nimport socket\nimport sys\nimport time\nimport urllib2\n\nHASHES_URL = sys.argv[1]\nRETRIES = 5\nTIMEOUT = 60\nWAIT_BASE = 15\n\nsocket.setdefaulttimeout(TIMEOUT)\nfor retry in range(RETRIES):\n  try:\n    with contextlib.closing(\n        urllib2.urlopen(HASHES_URL, timeout=TIMEOUT)) as w:\n      hashes = w.read()\n      with open(sys.argv[2], 'w') as f:\n        f.write(hashes)\n        break\n  except Exception as e:\n    print 'Failed to get uninteresting hashes from %s:' % HASHES_URL\n    print e\n    if retry == RETRIES:\n      raise\n    waittime = WAIT_BASE * math.pow(2, retry)\n    print 'Retry in %d seconds.' % waittime\n    time.sleep(waittime)\n",
       "https://example.com/hashes.txt",
       "[START_DIR]/tmp/uninteresting_hashes.txt"
     ],
     "env": {
       "CHROME_HEADLESS": "1",
       "PATH": "<PATH>:RECIPE_REPO[depot_tools]"
     },
     "infra_step": true,
     "name": "get uninteresting hashes",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@@@@",
       "@@@STEP_LOG_LINE@python.inline@import contextlib@@@",
       "@@@STEP_LOG_LINE@python.inline@import math@@@",
       "@@@STEP_LOG_LINE@python.inline@import socket@@@",
       "@@@STEP_LOG_LINE@python.inline@import sys@@@",
       "@@@STEP_LOG_LINE@python.inline@import time@@@",
       "@@@STEP_LOG_LINE@python.inline@import urllib2@@@",
       "@@@STEP_LOG_LINE@python.inline@@@@",
       "@@@STEP_LOG_LINE@python.inline@HASHES_URL = sys.argv[1]@@@",
       "@@@STEP_LOG_LINE@python.inline@RETRIES = 5@@@",
       "@@@STEP_LOG_LINE@python.inline@TIMEOUT = 60@@@",
       "@@@STEP_LOG_LINE@python.inline@WAIT_BASE = 15@@@",
       "@@@STEP_LOG_LINE@python.inline@@@@",
       "@@@STEP_LOG_LINE@python.inline@socket.setdefaulttimeout(TIMEOUT)@@@",
       "@@@STEP_LOG_LINE@python.inline@for retry in range(RETRIES):@@@",
       "@@@STEP_LOG_LINE@python.inline@  try:@@@",
       "@@@STEP_LOG_LINE@python.inline@    with contextlib.closing(@@@",
       "@@@STEP_LOG_LINE@python.inline@        urllib2.urlopen(HASHES_URL, timeout=TIMEOUT)) as w:@@@",
       "@@@STEP_LOG_LINE@python.inline@      hashes = w.read()@@@",
       "@@@STEP_LOG_LINE@python.inline@      with open(sys.argv[2], 'w') as f:@@@",
       "@@@STEP_LOG_LINE@python.inline@        f.write(hashes)@@@",
       "@@@STEP_LOG_LINE@python.inline@        break@@@",
       "@@@STEP_LOG_LINE@python.inline@  except Exception as e:@@@",
       "@@@STEP_LOG_LINE@python.inline@    print 'Failed to get uninteresting hashes from %s:' % HASHES_URL@@@",
       "@@@STEP_LOG_LINE@python.inline@    print e@@@",
       "@@@STEP_LOG_LINE@python.inline@    if retry == RETRIES:@@@",
       "@@@STEP_LOG_LINE@python.inline@      raise@@@",
       "@@@STEP_LOG_LINE@python.inline@    waittime = WAIT_BASE * math.pow(2, retry)@@@",
       "@@@STEP_LOG_LINE@python.inline@    print 'Retry in %d seconds.' % waittime@@@",
       "@@@STEP_LOG_LINE@python.inline@    time.sleep(waittime)@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_BOT_ID', '')\n"
     ],
     "name": "get swarming bot id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_BOT_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_TASK_ID', '')\n"
     ],
     "name": "get swarming task id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_TASK_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[skia::flavor]/resources/symbolize_stack_trace.py",
       "[START_DIR]",
       "catchsegv",
       "[START_DIR]/build/dm",
       "--resourcePath",
       "[START_DIR]/skia/resources",
       "--skps",
       "[START_DIR]/skp",
       "--images",
       "[START_DIR]/skimage/dm",
       "--colorImages",
       "[START_DIR]/skimage/colorspace",
       "--nameByHash",
       "--properties",
       "gitHash",
       "abc123",
       "builder",
       "Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-BonusConfigs",
       "buildbucket_build_id",
       "123454321",
       "task_id",
       "task_12345",
       "swarming_bot_id",
       "skia-bot-123",
       "swarming_task_id",
       "123456",
       "--svgs",
       "[START_DIR]/svg",
       "--key",
       "arch",
       "x86_64",
       "compiler",
       "Clang",
       "configuration",
       "Debug",
       "cpu_or_gpu",
       "CPU",
       "cpu_or_gpu_value",
       "AVX2",
       "extra_config",
       "BonusConfigs",
       "model",
       "GCE",
       "os",
       "Debian9",
       "style",
       "default",
       "--uninterestingHashesFile",
       "[START_DIR]/tmp/uninteresting_hashes.txt",
       "--writePath",
       "[START_DIR]/[SWARM_OUT_DIR]",
       "--dont_write",
       "pdf",
       "--randomProcessorTest",
       "--nogpu",
       "--config",
       "8888",
       "pdf",
       "g8",
       "565",
       "pic-8888",
       "tiles_rt-8888",
       "lite-8888",
       "serialize-8888",
       "gbr-8888",
       "f16",
       "srgb",
       "esrgb",
       "narrow",
       "enarrow",
       "p3",
       "ep3",
       "rec2020",
       "erec2020",
       "--src",
       "tests",
       "gm",
       "image",
       "colorImage",
       "--blacklist",
       "f16",
       "_",
       "_",
       "dstreadshuffle",
       "gbr-8888",
       "image",
       "_",
       "_",
       "gbr-8888",
       "colorImage",
       "_",
       "_",
       "g8",
       "image",
       "_",
       "_",
       "g8",
       "colorImage",
       "_",
       "_",
       "_",
       "image",
       "gen_platf",
       "error",
       "serialize-8888",
       "gm",
       "_",
       "bleed_image",
       "serialize-8888",
       "gm",
       "_",
       "c_gms",
       "serialize-8888",
       "gm",
       "_",
       "colortype",
       "serialize-8888",
       "gm",
       "_",
       "colortype_xfermodes",
       "serialize-8888",
       "gm",
       "_",
       "drawfilter",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds_0.75_0",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds_1_-0.25",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_match",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_iter",
       "serialize-8888",
       "gm",
       "_",
       "imagemasksubset",
       "serialize-8888",
       "gm",
       "_",
       "bitmapfilters",
       "serialize-8888",
       "gm",
       "_",
       "bitmapshaders",
       "serialize-8888",
       "gm",
       "_",
       "bleed",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_bmp",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_bmp_shader",
       "serialize-8888",
       "gm",
       "_",
       "convex_poly_clip",
       "serialize-8888",
       "gm",
       "_",
       "extractalpha",
       "serialize-8888",
       "gm",
       "_",
       "filterbitmap_checkerboard_32_32_g8",
       "serialize-8888",
       "gm",
       "_",
       "filterbitmap_image_mandrill_64",
       "serialize-8888",
       "gm",
       "_",
       "shadows",
       "serialize-8888",
       "gm",
       "_",
       "simpleaaclip_aaclip",
       "serialize-8888",
       "gm",
       "_",
       "composeshader_bitmap",
       "serialize-8888",
       "gm",
       "_",
       "scaled_tilemodes_npot",
       "serialize-8888",
       "gm",
       "_",
       "scaled_tilemodes",
       "serialize-8888",
       "gm",
       "_",
       "typefacerendering_pfaMac",
       "serialize-8888",
       "gm",
       "_",
       "parsedpaths",
       "serialize-8888",
       "gm",
       "_",
       "ImageGeneratorExternal_rect",
       "serialize-8888",
       "gm",
       "_",
       "ImageGeneratorExternal_shader",
       "serialize-8888",
       "gm",
       "_",
       "shadow_utils",
       "serialize-8888",
       "gm",
       "_",
       "persp_images",
       "serialize-8888",
       "gm",
       "_",
       "all_bitmap_configs",
       "serialize-8888",
       "gm",
       "_",
       "makecolorspace",
       "serialize-8888",
       "gm",
       "_",
       "readpixels",
       "serialize-8888",
       "gm",
       "_",
       "draw_image_set_rect_to_rect",
       "serialize-8888",
       "gm",
       "_",
-      "compositor_quads_shader",
-      "serialize-8888",
-      "gm",
-      "_",
       "analytic_antialias_convex",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_image",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_image_shader",
       "pic-8888",
       "gm",
       "_",
       "drawfilter",
       "lite-8888",
       "gm",
       "_",
       "drawfilter",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-picture",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-picture",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-raster",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-raster",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-ctable",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-ctable",
       "pic-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "lite-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "serialize-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "pic-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "lite-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "serialize-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "pic-8888",
       "gm",
       "_",
       "p3",
       "lite-8888",
       "gm",
       "_",
       "p3",
       "serialize-8888",
       "gm",
       "_",
       "p3",
       "tiles_rt-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "tiles_rt-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "--nonativeFonts",
       "--verbose"
     ],
     "cwd": "[START_DIR]/skia",
     "env": {
       "CHROME_HEADLESS": "1",
       "PATH": "<PATH>:RECIPE_REPO[depot_tools]"
     },
     "name": "symbolized dm"
   },
   {
     "jsonResult": null,
     "name": "$result"
   }
 ]
\ No newline at end of file
diff --git a/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-MSAN.json b/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-MSAN.json
index 72cf107802..a8169891fe 100644
--- a/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-MSAN.json
+++ b/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-MSAN.json
@@ -1,481 +1,477 @@
 [
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "ensure-directory",
       "--mode",
       "0777",
       "[START_DIR]/tmp"
     ],
     "infra_step": true,
     "name": "makedirs tmp_dir"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/skp/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skp VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SKP_VERSION"
     ],
     "infra_step": true,
     "name": "write SKP_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/skimage/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skimage VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SK_IMAGE_VERSION"
     ],
     "infra_step": true,
     "name": "write SK_IMAGE_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/svg/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get svg VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SVG_VERSION"
     ],
     "infra_step": true,
     "name": "write SVG_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_BOT_ID', '')\n"
     ],
     "name": "get swarming bot id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_BOT_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_TASK_ID', '')\n"
     ],
     "name": "get swarming task id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_TASK_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[skia::flavor]/resources/symbolize_stack_trace.py",
       "[START_DIR]",
       "[START_DIR]/build/dm",
       "--resourcePath",
       "[START_DIR]/skia/resources",
       "--skps",
       "[START_DIR]/skp",
       "--images",
       "[START_DIR]/skimage/dm",
       "--colorImages",
       "[START_DIR]/skimage/colorspace",
       "--nameByHash",
       "--properties",
       "gitHash",
       "abc123",
       "builder",
       "Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-MSAN",
       "buildbucket_build_id",
       "123454321",
       "task_id",
       "task_12345",
       "swarming_bot_id",
       "skia-bot-123",
       "swarming_task_id",
       "123456",
       "--svgs",
       "[START_DIR]/svg",
       "--key",
       "arch",
       "x86_64",
       "compiler",
       "Clang",
       "configuration",
       "Debug",
       "cpu_or_gpu",
       "CPU",
       "cpu_or_gpu_value",
       "AVX2",
       "extra_config",
       "MSAN",
       "model",
       "GCE",
       "os",
       "Debian9",
       "style",
       "default",
       "--dont_write",
       "pdf",
       "--nogpu",
       "--config",
       "8888",
       "pdf",
       "g8",
       "565",
       "pic-8888",
       "tiles_rt-8888",
       "lite-8888",
       "serialize-8888",
       "gbr-8888",
       "f16",
       "srgb",
       "esrgb",
       "narrow",
       "enarrow",
       "p3",
       "ep3",
       "rec2020",
       "erec2020",
       "--src",
       "tests",
       "gm",
       "image",
       "colorImage",
       "--blacklist",
       "f16",
       "_",
       "_",
       "dstreadshuffle",
       "gbr-8888",
       "image",
       "_",
       "_",
       "gbr-8888",
       "colorImage",
       "_",
       "_",
       "g8",
       "image",
       "_",
       "_",
       "g8",
       "colorImage",
       "_",
       "_",
       "_",
       "image",
       "gen_platf",
       "error",
       "serialize-8888",
       "gm",
       "_",
       "bleed_image",
       "serialize-8888",
       "gm",
       "_",
       "c_gms",
       "serialize-8888",
       "gm",
       "_",
       "colortype",
       "serialize-8888",
       "gm",
       "_",
       "colortype_xfermodes",
       "serialize-8888",
       "gm",
       "_",
       "drawfilter",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds_0.75_0",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds_1_-0.25",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_match",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_iter",
       "serialize-8888",
       "gm",
       "_",
       "imagemasksubset",
       "serialize-8888",
       "gm",
       "_",
       "bitmapfilters",
       "serialize-8888",
       "gm",
       "_",
       "bitmapshaders",
       "serialize-8888",
       "gm",
       "_",
       "bleed",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_bmp",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_bmp_shader",
       "serialize-8888",
       "gm",
       "_",
       "convex_poly_clip",
       "serialize-8888",
       "gm",
       "_",
       "extractalpha",
       "serialize-8888",
       "gm",
       "_",
       "filterbitmap_checkerboard_32_32_g8",
       "serialize-8888",
       "gm",
       "_",
       "filterbitmap_image_mandrill_64",
       "serialize-8888",
       "gm",
       "_",
       "shadows",
       "serialize-8888",
       "gm",
       "_",
       "simpleaaclip_aaclip",
       "serialize-8888",
       "gm",
       "_",
       "composeshader_bitmap",
       "serialize-8888",
       "gm",
       "_",
       "scaled_tilemodes_npot",
       "serialize-8888",
       "gm",
       "_",
       "scaled_tilemodes",
       "serialize-8888",
       "gm",
       "_",
       "typefacerendering_pfaMac",
       "serialize-8888",
       "gm",
       "_",
       "parsedpaths",
       "serialize-8888",
       "gm",
       "_",
       "ImageGeneratorExternal_rect",
       "serialize-8888",
       "gm",
       "_",
       "ImageGeneratorExternal_shader",
       "serialize-8888",
       "gm",
       "_",
       "shadow_utils",
       "serialize-8888",
       "gm",
       "_",
       "persp_images",
       "serialize-8888",
       "gm",
       "_",
       "all_bitmap_configs",
       "serialize-8888",
       "gm",
       "_",
       "makecolorspace",
       "serialize-8888",
       "gm",
       "_",
       "readpixels",
       "serialize-8888",
       "gm",
       "_",
       "draw_image_set_rect_to_rect",
       "serialize-8888",
       "gm",
       "_",
-      "compositor_quads_shader",
-      "serialize-8888",
-      "gm",
-      "_",
       "analytic_antialias_convex",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_image",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_image_shader",
       "pic-8888",
       "gm",
       "_",
       "drawfilter",
       "lite-8888",
       "gm",
       "_",
       "drawfilter",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-picture",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-picture",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-raster",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-raster",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-ctable",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-ctable",
       "pic-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "lite-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "serialize-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "pic-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "lite-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "serialize-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "pic-8888",
       "gm",
       "_",
       "p3",
       "lite-8888",
       "gm",
       "_",
       "p3",
       "serialize-8888",
       "gm",
       "_",
       "p3",
       "tiles_rt-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "tiles_rt-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "--match",
       "~Once",
       "~Shared",
       "--nonativeFonts",
       "--verbose"
     ],
     "cwd": "[START_DIR]/skia",
     "env": {
       "CHROME_HEADLESS": "1",
       "LD_LIBRARY_PATH": "[START_DIR]/clang_linux/msan:[START_DIR]/clang_linux/lib",
       "PATH": "<PATH>:RECIPE_REPO[depot_tools]:[START_DIR]/clang_linux/bin"
     },
     "name": "symbolized dm"
   },
   {
     "jsonResult": null,
     "name": "$result"
   }
 ]
\ No newline at end of file
diff --git a/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Release-All-TSAN.json b/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Release-All-TSAN.json
index d6c5255792..6c4cf1c33e 100644
--- a/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Release-All-TSAN.json
+++ b/infra/bots/recipes/test.expected/Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Release-All-TSAN.json
@@ -1,484 +1,480 @@
 [
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "ensure-directory",
       "--mode",
       "0777",
       "[START_DIR]/tmp"
     ],
     "infra_step": true,
     "name": "makedirs tmp_dir"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/skp/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skp VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SKP_VERSION"
     ],
     "infra_step": true,
     "name": "write SKP_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/skimage/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skimage VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SK_IMAGE_VERSION"
     ],
     "infra_step": true,
     "name": "write SK_IMAGE_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]/skia/infra/bots/assets/svg/VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get svg VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]/resources/fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]/tmp/SVG_VERSION"
     ],
     "infra_step": true,
     "name": "write SVG_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_BOT_ID', '')\n"
     ],
     "name": "get swarming bot id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_BOT_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_TASK_ID', '')\n"
     ],
     "name": "get swarming task id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_TASK_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[skia::flavor]/resources/symbolize_stack_trace.py",
       "[START_DIR]",
       "[START_DIR]/build/dm",
       "--resourcePath",
       "[START_DIR]/skia/resources",
       "--skps",
       "[START_DIR]/skp",
       "--images",
       "[START_DIR]/skimage/dm",
       "--colorImages",
       "[START_DIR]/skimage/colorspace",
       "--nameByHash",
       "--properties",
       "gitHash",
       "abc123",
       "builder",
       "Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Release-All-TSAN",
       "buildbucket_build_id",
       "123454321",
       "task_id",
       "task_12345",
       "swarming_bot_id",
       "skia-bot-123",
       "swarming_task_id",
       "123456",
       "--svgs",
       "[START_DIR]/svg",
       "--key",
       "arch",
       "x86_64",
       "compiler",
       "Clang",
       "configuration",
       "Release",
       "cpu_or_gpu",
       "CPU",
       "cpu_or_gpu_value",
       "AVX2",
       "extra_config",
       "TSAN",
       "model",
       "GCE",
       "os",
       "Debian9",
       "style",
       "default",
       "--dont_write",
       "pdf",
       "--randomProcessorTest",
       "--nogpu",
       "--config",
       "8888",
       "pdf",
       "g8",
       "565",
       "pic-8888",
       "tiles_rt-8888",
       "lite-8888",
       "serialize-8888",
       "gbr-8888",
       "f16",
       "srgb",
       "esrgb",
       "narrow",
       "enarrow",
       "p3",
       "ep3",
       "rec2020",
       "erec2020",
       "--src",
       "tests",
       "gm",
       "image",
       "colorImage",
       "--blacklist",
       "f16",
       "_",
       "_",
       "dstreadshuffle",
       "gbr-8888",
       "image",
       "_",
       "_",
       "gbr-8888",
       "colorImage",
       "_",
       "_",
       "g8",
       "image",
       "_",
       "_",
       "g8",
       "colorImage",
       "_",
       "_",
       "_",
       "image",
       "gen_platf",
       "error",
       "serialize-8888",
       "gm",
       "_",
       "bleed_image",
       "serialize-8888",
       "gm",
       "_",
       "c_gms",
       "serialize-8888",
       "gm",
       "_",
       "colortype",
       "serialize-8888",
       "gm",
       "_",
       "colortype_xfermodes",
       "serialize-8888",
       "gm",
       "_",
       "drawfilter",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds_0.75_0",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds_1_-0.25",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_bounds",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_match",
       "serialize-8888",
       "gm",
       "_",
       "fontmgr_iter",
       "serialize-8888",
       "gm",
       "_",
       "imagemasksubset",
       "serialize-8888",
       "gm",
       "_",
       "bitmapfilters",
       "serialize-8888",
       "gm",
       "_",
       "bitmapshaders",
       "serialize-8888",
       "gm",
       "_",
       "bleed",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_bmp",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_bmp_shader",
       "serialize-8888",
       "gm",
       "_",
       "convex_poly_clip",
       "serialize-8888",
       "gm",
       "_",
       "extractalpha",
       "serialize-8888",
       "gm",
       "_",
       "filterbitmap_checkerboard_32_32_g8",
       "serialize-8888",
       "gm",
       "_",
       "filterbitmap_image_mandrill_64",
       "serialize-8888",
       "gm",
       "_",
       "shadows",
       "serialize-8888",
       "gm",
       "_",
       "simpleaaclip_aaclip",
       "serialize-8888",
       "gm",
       "_",
       "composeshader_bitmap",
       "serialize-8888",
       "gm",
       "_",
       "scaled_tilemodes_npot",
       "serialize-8888",
       "gm",
       "_",
       "scaled_tilemodes",
       "serialize-8888",
       "gm",
       "_",
       "typefacerendering_pfaMac",
       "serialize-8888",
       "gm",
       "_",
       "parsedpaths",
       "serialize-8888",
       "gm",
       "_",
       "ImageGeneratorExternal_rect",
       "serialize-8888",
       "gm",
       "_",
       "ImageGeneratorExternal_shader",
       "serialize-8888",
       "gm",
       "_",
       "shadow_utils",
       "serialize-8888",
       "gm",
       "_",
       "persp_images",
       "serialize-8888",
       "gm",
       "_",
       "all_bitmap_configs",
       "serialize-8888",
       "gm",
       "_",
       "makecolorspace",
       "serialize-8888",
       "gm",
       "_",
       "readpixels",
       "serialize-8888",
       "gm",
       "_",
       "draw_image_set_rect_to_rect",
       "serialize-8888",
       "gm",
       "_",
-      "compositor_quads_shader",
-      "serialize-8888",
-      "gm",
-      "_",
       "analytic_antialias_convex",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_image",
       "serialize-8888",
       "gm",
       "_",
       "bleed_alpha_image_shader",
       "pic-8888",
       "gm",
       "_",
       "drawfilter",
       "lite-8888",
       "gm",
       "_",
       "drawfilter",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-picture",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-picture",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-raster",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-raster",
       "pic-8888",
       "gm",
       "_",
       "image-cacherator-from-ctable",
       "serialize-8888",
       "gm",
       "_",
       "image-cacherator-from-ctable",
       "pic-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "lite-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "serialize-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "pic-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "lite-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "serialize-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "pic-8888",
       "gm",
       "_",
       "p3",
       "lite-8888",
       "gm",
       "_",
       "p3",
       "serialize-8888",
       "gm",
       "_",
       "p3",
       "tiles_rt-8888",
       "gm",
       "_",
       "complexclip4_bw",
       "tiles_rt-8888",
       "gm",
       "_",
       "complexclip4_aa",
       "--match",
       "~ReadWriteAlpha",
       "~RGBA4444TextureTest",
       "~RGB565TextureTest",
       "--nonativeFonts",
       "--verbose"
     ],
     "cwd": "[START_DIR]/skia",
     "env": {
       "CHROME_HEADLESS": "1",
       "LD_LIBRARY_PATH": "[START_DIR]/clang_linux/lib",
       "PATH": "<PATH>:RECIPE_REPO[depot_tools]:[START_DIR]/clang_linux/bin",
       "TSAN_OPTIONS": "report_signal_unsafe=0"
     },
     "name": "symbolized dm"
   },
   {
     "jsonResult": null,
     "name": "$result"
   }
 ]
\ No newline at end of file
diff --git a/infra/bots/recipes/test.expected/Test-Win10-Clang-NUC8i5BEK-GPU-IntelIris655-x86_64-Debug-All-Vulkan.json b/infra/bots/recipes/test.expected/Test-Win10-Clang-NUC8i5BEK-GPU-IntelIris655-x86_64-Debug-All-Vulkan.json
index 66339f8340..ace6c2908b 100644
--- a/infra/bots/recipes/test.expected/Test-Win10-Clang-NUC8i5BEK-GPU-IntelIris655-x86_64-Debug-All-Vulkan.json
+++ b/infra/bots/recipes/test.expected/Test-Win10-Clang-NUC8i5BEK-GPU-IntelIris655-x86_64-Debug-All-Vulkan.json
@@ -1,610 +1,606 @@
 [
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]\\resources\\fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "ensure-directory",
       "--mode",
       "0777",
       "[START_DIR]\\tmp"
     ],
     "infra_step": true,
     "name": "makedirs tmp_dir"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]\\resources\\fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]\\skia\\infra\\bots\\assets\\skp\\VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skp VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]\\resources\\fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]\\tmp\\SKP_VERSION"
     ],
     "infra_step": true,
     "name": "write SKP_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]\\resources\\fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]\\skia\\infra\\bots\\assets\\skimage\\VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get skimage VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]\\resources\\fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]\\tmp\\SK_IMAGE_VERSION"
     ],
     "infra_step": true,
     "name": "write SK_IMAGE_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]\\resources\\fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "[START_DIR]\\skia\\infra\\bots\\assets\\svg\\VERSION",
       "/path/to/tmp/"
     ],
     "infra_step": true,
     "name": "Get svg VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]\\resources\\fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "copy",
       "42",
       "[START_DIR]\\tmp\\SVG_VERSION"
     ],
     "infra_step": true,
     "name": "write SVG_VERSION"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]\\resources\\fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "rmtree",
       "[START_DIR]\\test"
     ],
     "infra_step": true,
     "name": "rmtree test"
   },
   {
     "cmd": [
       "python",
       "-u",
       "RECIPE_MODULE[recipe_engine::file]\\resources\\fileutil.py",
       "--json-output",
       "/path/to/tmp/json",
       "ensure-directory",
       "--mode",
       "0777",
       "[START_DIR]\\test"
     ],
     "infra_step": true,
     "name": "makedirs test"
   },
   {
     "cmd": [
       "python",
       "-u",
       "\nimport contextlib\nimport math\nimport socket\nimport sys\nimport time\nimport urllib2\n\nHASHES_URL = sys.argv[1]\nRETRIES = 5\nTIMEOUT = 60\nWAIT_BASE = 15\n\nsocket.setdefaulttimeout(TIMEOUT)\nfor retry in range(RETRIES):\n  try:\n    with contextlib.closing(\n        urllib2.urlopen(HASHES_URL, timeout=TIMEOUT)) as w:\n      hashes = w.read()\n      with open(sys.argv[2], 'w') as f:\n        f.write(hashes)\n        break\n  except Exception as e:\n    print 'Failed to get uninteresting hashes from %s:' % HASHES_URL\n    print e\n    if retry == RETRIES:\n      raise\n    waittime = WAIT_BASE * math.pow(2, retry)\n    print 'Retry in %d seconds.' % waittime\n    time.sleep(waittime)\n",
       "https://example.com/hashes.txt",
       "[START_DIR]\\tmp\\uninteresting_hashes.txt"
     ],
     "env": {
       "CHROME_HEADLESS": "1",
       "PATH": "<PATH>;RECIPE_REPO[depot_tools]"
     },
     "infra_step": true,
     "name": "get uninteresting hashes",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@@@@",
       "@@@STEP_LOG_LINE@python.inline@import contextlib@@@",
       "@@@STEP_LOG_LINE@python.inline@import math@@@",
       "@@@STEP_LOG_LINE@python.inline@import socket@@@",
       "@@@STEP_LOG_LINE@python.inline@import sys@@@",
       "@@@STEP_LOG_LINE@python.inline@import time@@@",
       "@@@STEP_LOG_LINE@python.inline@import urllib2@@@",
       "@@@STEP_LOG_LINE@python.inline@@@@",
       "@@@STEP_LOG_LINE@python.inline@HASHES_URL = sys.argv[1]@@@",
       "@@@STEP_LOG_LINE@python.inline@RETRIES = 5@@@",
       "@@@STEP_LOG_LINE@python.inline@TIMEOUT = 60@@@",
       "@@@STEP_LOG_LINE@python.inline@WAIT_BASE = 15@@@",
       "@@@STEP_LOG_LINE@python.inline@@@@",
       "@@@STEP_LOG_LINE@python.inline@socket.setdefaulttimeout(TIMEOUT)@@@",
       "@@@STEP_LOG_LINE@python.inline@for retry in range(RETRIES):@@@",
       "@@@STEP_LOG_LINE@python.inline@  try:@@@",
       "@@@STEP_LOG_LINE@python.inline@    with contextlib.closing(@@@",
       "@@@STEP_LOG_LINE@python.inline@        urllib2.urlopen(HASHES_URL, timeout=TIMEOUT)) as w:@@@",
       "@@@STEP_LOG_LINE@python.inline@      hashes = w.read()@@@",
       "@@@STEP_LOG_LINE@python.inline@      with open(sys.argv[2], 'w') as f:@@@",
       "@@@STEP_LOG_LINE@python.inline@        f.write(hashes)@@@",
       "@@@STEP_LOG_LINE@python.inline@        break@@@",
       "@@@STEP_LOG_LINE@python.inline@  except Exception as e:@@@",
       "@@@STEP_LOG_LINE@python.inline@    print 'Failed to get uninteresting hashes from %s:' % HASHES_URL@@@",
       "@@@STEP_LOG_LINE@python.inline@    print e@@@",
       "@@@STEP_LOG_LINE@python.inline@    if retry == RETRIES:@@@",
       "@@@STEP_LOG_LINE@python.inline@      raise@@@",
       "@@@STEP_LOG_LINE@python.inline@    waittime = WAIT_BASE * math.pow(2, retry)@@@",
       "@@@STEP_LOG_LINE@python.inline@    print 'Retry in %d seconds.' % waittime@@@",
       "@@@STEP_LOG_LINE@python.inline@    time.sleep(waittime)@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_BOT_ID', '')\n"
     ],
     "name": "get swarming bot id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_BOT_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "python",
       "-u",
       "import os\nprint os.environ.get('SWARMING_TASK_ID', '')\n"
     ],
     "name": "get swarming task id",
     "stdout": "/path/to/tmp/",
     "~followup_annotations": [
       "@@@STEP_LOG_LINE@python.inline@import os@@@",
       "@@@STEP_LOG_LINE@python.inline@print os.environ.get('SWARMING_TASK_ID', '')@@@",
       "@@@STEP_LOG_END@python.inline@@@"
     ]
   },
   {
     "cmd": [
       "[START_DIR]\\build\\dm",
       "--resourcePath",
       "[START_DIR]\\skia\\resources",
       "--skps",
       "[START_DIR]\\skp",
       "--images",
       "[START_DIR]\\skimage\\dm",
       "--colorImages",
       "[START_DIR]\\skimage\\colorspace",
       "--nameByHash",
       "--properties",
       "gitHash",
       "abc123",
       "builder",
       "Test-Win10-Clang-NUC8i5BEK-GPU-IntelIris655-x86_64-Debug-All-Vulkan",
       "buildbucket_build_id",
       "123454321",
       "task_id",
       "task_12345",
       "swarming_bot_id",
       "skia-bot-123",
       "swarming_task_id",
       "123456",
       "--svgs",
       "[START_DIR]\\svg",
       "--key",
       "arch",
       "x86_64",
       "compiler",
       "Clang",
       "configuration",
       "Debug",
       "cpu_or_gpu",
       "GPU",
       "cpu_or_gpu_value",
       "IntelIris655",
       "extra_config",
       "Vulkan",
       "model",
       "NUC8i5BEK",
       "os",
       "Win10",
       "style",
       "default",
       "--uninterestingHashesFile",
       "[START_DIR]\\tmp\\uninteresting_hashes.txt",
       "--writePath",
       "[START_DIR]\\[SWARM_OUT_DIR]",
       "--dont_write",
       "pdf",
       "--randomProcessorTest",
       "--nocpu",
       "--config",
       "vk",
       "--src",
       "tests",
       "gm",
       "image",
       "colorImage",
       "svg",
       "--blacklist",
       "_",
       "svg",
       "_",
       "svgparse_",
       "_",
       "image",
       "gen_platf",
       "pal8os2v2.bmp",
       "_",
       "image",
       "gen_platf",
       "pal8os2v2-16.bmp",
       "_",
       "image",
       "gen_platf",
       "rgba32abf.bmp",
       "_",
       "image",
       "gen_platf",
       "rgb24prof.bmp",
       "_",
       "image",
       "gen_platf",
       "rgb24lprof.bmp",
       "_",
       "image",
       "gen_platf",
       "8bpp-pixeldata-cropped.bmp",
       "_",
       "image",
       "gen_platf",
       "4bpp-pixeldata-cropped.bmp",
       "_",
       "image",
       "gen_platf",
       "32bpp-pixeldata-cropped.bmp",
       "_",
       "image",
       "gen_platf",
       "24bpp-pixeldata-cropped.bmp",
       "_",
       "image",
       "gen_platf",
       "testimgari.jpg",
       "_",
       "image",
       "gen_platf",
       "rle8-height-negative.bmp",
       "_",
       "image",
       "gen_platf",
       "rle4-height-negative.bmp",
       "_",
       "image",
       "gen_platf",
       "error",
       "_",
       "image",
       "_",
       "interlaced1.png",
       "_",
       "image",
       "_",
       "interlaced2.png",
       "_",
       "image",
       "_",
       "interlaced3.png",
       "_",
       "image",
       "_",
       ".arw",
       "_",
       "image",
       "_",
       ".cr2",
       "_",
       "image",
       "_",
       ".dng",
       "_",
       "image",
       "_",
       ".nef",
       "_",
       "image",
       "_",
       ".nrw",
       "_",
       "image",
       "_",
       ".orf",
       "_",
       "image",
       "_",
       ".raf",
       "_",
       "image",
       "_",
       ".rw2",
       "_",
       "image",
       "_",
       ".pef",
       "_",
       "image",
       "_",
       ".srw",
       "_",
       "image",
       "_",
       ".ARW",
       "_",
       "image",
       "_",
       ".CR2",
       "_",
       "image",
       "_",
       ".DNG",
       "_",
       "image",
       "_",
       ".NEF",
       "_",
       "image",
       "_",
       ".NRW",
       "_",
       "image",
       "_",
       ".ORF",
       "_",
       "image",
       "_",
       ".RAF",
       "_",
       "image",
       "_",
       ".RW2",
       "_",
       "image",
       "_",
       ".PEF",
       "_",
       "image",
       "_",
       ".SRW",
       "vk",
       "gm",
       "_",
       "aarectmodes",
       "vk",
       "gm",
       "_",
       "aaxfermodes",
       "vk",
       "gm",
       "_",
-      "compositor_quads_filter",
-      "vk",
-      "gm",
-      "_",
       "crbug_892988",
       "vk",
       "gm",
       "_",
       "dftext",
       "vk",
       "gm",
       "_",
       "dftext_blob_persp",
       "vk",
       "gm",
       "_",
       "dont_clip_to_layer",
       "vk",
       "gm",
       "_",
       "drawregionmodes",
       "vk",
       "gm",
       "_",
       "filterfastbounds",
       "vk",
       "gm",
       "_",
       "fontmgr_iter",
       "vk",
       "gm",
       "_",
       "fontmgr_match",
       "vk",
       "gm",
       "_",
       "fontscaler",
       "vk",
       "gm",
       "_",
       "fontscalerdistortable",
       "vk",
       "gm",
       "_",
       "gammagradienttext",
       "vk",
       "gm",
       "_",
       "gammatext",
       "vk",
       "gm",
       "_",
       "gradtext",
       "vk",
       "gm",
       "_",
       "hairmodes",
       "vk",
       "gm",
       "_",
       "imagefilters_xfermodes",
       "vk",
       "gm",
       "_",
       "imagefiltersclipped",
       "vk",
       "gm",
       "_",
       "imagefiltersscaled",
       "vk",
       "gm",
       "_",
       "imagefiltersstroked",
       "vk",
       "gm",
       "_",
       "imagefilterstransformed",
       "vk",
       "gm",
       "_",
       "imageresizetiled",
       "vk",
       "gm",
       "_",
       "lcdblendmodes",
       "vk",
       "gm",
       "_",
       "lcdoverlap",
       "vk",
       "gm",
       "_",
       "lcdtext",
       "vk",
       "gm",
       "_",
       "lcdtextsize",
       "vk",
       "gm",
       "_",
       "matriximagefilter",
       "vk",
       "gm",
       "_",
       "resizeimagefilter",
       "vk",
       "gm",
       "_",
       "rotate_imagefilter",
       "vk",
       "gm",
       "_",
       "savelayer_lcdtext",
       "vk",
       "gm",
       "_",
       "shadermaskfilter_image",
       "vk",
       "gm",
       "_",
       "srcmode",
       "vk",
       "gm",
       "_",
       "surfaceprops",
       "vk",
       "gm",
       "_",
       "textblobgeometrychange",
       "vk",
       "gm",
       "_",
       "textbloblooper",
       "vk",
       "gm",
       "_",
       "textblobrandomfont",
       "vk",
       "gm",
       "_",
       "textfilter_color",
       "vk",
       "gm",
       "_",
       "textfilter_image",
       "vk",
       "gm",
       "_",
       "tilemodes",
       "vk",
       "gm",
       "_",
       "varied_text_clipped_lcd",
       "vk",
       "gm",
       "_",
       "varied_text_ignorable_clip_lcd",
       "vk",
       "gm",
       "_",
       "mixedtextblobs",
       "vk",
       "gm",
       "_",
       "textblobmixedsizes",
       "vk",
       "gm",
       "_",
       "textblobmixedsizes_df",
       "--nonativeFonts",
       "--reduceOpListSplitting",
       "--verbose"
     ],
     "env": {
       "CHROME_HEADLESS": "1",
       "PATH": "<PATH>;RECIPE_REPO[depot_tools]"
     },
     "name": "dm"
   },
   {
     "jsonResult": null,
     "name": "$result"
   }
 ]
\ No newline at end of file
diff --git a/infra/bots/recipes/test.py b/infra/bots/recipes/test.py
index b91fbece65..d7bf09be09 100644
--- a/infra/bots/recipes/test.py
+++ b/infra/bots/recipes/test.py
@@ -41,797 +41,795 @@ def upload_dm_results(buildername):
 def dm_flags(api, bot):
   args = []
   configs = []
   blacklisted = []
 
   def blacklist(quad):
     config, src, options, name = (
         quad.split(' ') if isinstance(quad, str) else quad)
     if (config == '_' or
         config in configs or
         (config[0] == '~' and config[1:] in configs)):
       blacklisted.extend([config, src, options, name])
 
   # We've been spending lots of time writing out and especially uploading
   # .pdfs, but not doing anything further with them.  skia:6821
   args.extend(['--dont_write', 'pdf'])
 
   # This enables non-deterministic random seeding of the GPU FP optimization
   # test.
   # Not Android due to:
   #  - https://skia.googlesource.com/skia/+/
   #    5910ed347a638ded8cd4c06dbfda086695df1112/BUILD.gn#160
   #  - https://skia.googlesource.com/skia/+/
   #    ce06e261e68848ae21cac1052abc16bc07b961bf/tests/ProcessorTest.cpp#307
   # Not MSAN due to:
   #  - https://skia.googlesource.com/skia/+/
   #    0ac06e47269a40c177747310a613d213c95d1d6d/infra/bots/recipe_modules/
   #    flavor/gn_flavor.py#80
   if 'Android' not in bot and 'MSAN' not in bot:
     args.append('--randomProcessorTest')
 
   # 32-bit desktop bots tend to run out of memory, because they have relatively
   # far more cores than RAM (e.g. 32 cores, 3G RAM).  Hold them back a bit.
   if '-x86-' in bot and not 'NexusPlayer' in bot:
     args.extend(['--threads', '4'])
 
   # Nexus7 runs out of memory due to having 4 cores and only 1G RAM.
   if 'CPU' in bot and 'Nexus7' in bot:
     args.extend(['--threads', '2'])
 
   # MotoG4 occasionally fails when multiple threads read the same image file.
   if 'CPU' in bot and 'MotoG4' in bot:
     args.extend(['--threads', '0'])
 
   if 'Chromecast' in bot:
     args.extend(['--threads', '0'])
 
   # Avoid issues with dynamically exceeding resource cache limits.
   if 'Test' in bot and 'DISCARDABLE' in bot:
     args.extend(['--threads', '0'])
 
   # See if staying on the main thread helps skia:6748.
   if 'Test-iOS' in bot:
     args.extend(['--threads', '0'])
 
   # Android's kernel will occasionally attempt to kill our process, using
   # SIGINT, in an effort to free up resources. If requested, that signal
   # is ignored and dm will keep attempting to proceed until we actually
   # exhaust the available resources.
   if ('NexusPlayer' in bot or
       'Chromecast' in bot):
     args.append('--ignoreSigInt')
 
   if 'SwiftShader' in api.vars.extra_tokens:
     configs.extend(['gles', 'glesdft'])
     args.append('--disableDriverCorrectnessWorkarounds')
 
   elif api.vars.builder_cfg.get('cpu_or_gpu') == 'CPU':
     args.append('--nogpu')
 
     configs.append('8888')
 
     if 'BonusConfigs' in bot or ('SAN' in bot and 'GCE' in bot):
       configs.extend([
         'pdf',
         'g8', '565',
         'pic-8888', 'tiles_rt-8888', 'lite-8888', 'serialize-8888',
         'gbr-8888',
         'f16', 'srgb', 'esrgb', 'narrow', 'enarrow',
         'p3', 'ep3', 'rec2020', 'erec2020'])
 
   elif api.vars.builder_cfg.get('cpu_or_gpu') == 'GPU':
     args.append('--nocpu')
 
     # Add in either gles or gl configs to the canonical set based on OS
     sample_count = '8'
     gl_prefix = 'gl'
     if 'Android' in bot or 'iOS' in bot:
       sample_count = '4'
       # We want to test the OpenGL config not the GLES config on the Shield
       if 'NVIDIA_Shield' not in bot:
         gl_prefix = 'gles'
     elif 'Intel' in bot:
       sample_count = ''
     elif 'ChromeOS' in bot:
       gl_prefix = 'gles'
 
     if 'NativeFonts' in bot:
       configs.append(gl_prefix)
     else:
       configs.extend([gl_prefix,
                       gl_prefix + 'dft',
                       gl_prefix + 'srgb'])
       if sample_count is not '':
         configs.append(gl_prefix + 'msaa' + sample_count)
 
     # The NP produces a long error stream when we run with MSAA. The Tegra3 just
     # doesn't support it.
     if ('NexusPlayer' in bot or
         'Tegra3'      in bot or
         # We aren't interested in fixing msaa bugs on current iOS devices.
         'iPad4' in bot or
         'iPadPro' in bot or
         'iPhone6' in bot or
         'iPhone7' in bot or
         # skia:5792
         'IntelHD530'   in bot or
         'IntelIris540' in bot):
       configs = [x for x in configs if 'msaa' not in x]
 
     # The NP produces different images for dft on every run.
     if 'NexusPlayer' in bot:
       configs = [x for x in configs if 'dft' not in x]
 
     # We want to test both the OpenGL config and the GLES config on Linux Intel:
     # GL is used by Chrome, GLES is used by ChromeOS.
     # Also do the Ganesh threading verification test (render with and without
     # worker threads, using only the SW path renderer, and compare the results).
     if 'Intel' in bot and api.vars.is_linux:
       configs.extend(['gles',
                       'glesdft',
                       'glessrgb',
                       'gltestthreading'])
       # skbug.com/6333, skbug.com/6419, skbug.com/6702
       blacklist('gltestthreading gm _ lcdblendmodes')
       blacklist('gltestthreading gm _ lcdoverlap')
       blacklist('gltestthreading gm _ textbloblooper')
       # All of these GMs are flaky, too:
       blacklist('gltestthreading gm _ bleed_alpha_bmp')
       blacklist('gltestthreading gm _ bleed_alpha_bmp_shader')
       blacklist('gltestthreading gm _ bleed_alpha_image')
       blacklist('gltestthreading gm _ bleed_alpha_image_shader')
       blacklist('gltestthreading gm _ savelayer_with_backdrop')
       blacklist('gltestthreading gm _ persp_shaders_bw')
       blacklist('gltestthreading gm _ dftext_blob_persp')
       blacklist('gltestthreading gm _ dftext')
     # skbug.com/7523 - Flaky on various GPUs
       blacklist('gltestthreading gm _ orientation')
 
     # CommandBuffer bot *only* runs the command_buffer config.
     if 'CommandBuffer' in bot:
       configs = ['commandbuffer']
 
     # ANGLE bot *only* runs the angle configs
     if 'ANGLE' in bot:
       configs = ['angle_d3d11_es2',
                  'angle_d3d9_es2',
                  'angle_gl_es2',
                  'angle_d3d11_es3']
       if sample_count is not '':
         configs.append('angle_d3d11_es2_msaa' + sample_count)
         configs.append('angle_d3d11_es3_msaa' + sample_count)
       if 'GTX' in bot or 'Quadro' in bot:
         # See skia:7823 and chromium:693090.
         configs.append('angle_gl_es3')
         if sample_count is not '':
           configs.append('angle_gl_es2_msaa' + sample_count)
           configs.append('angle_gl_es3_msaa' + sample_count)
       if 'NUC5i7RYH' in bot:
         # skbug.com/7376
         blacklist('_ test _ ProcessorCloneTest')
 
     # Vulkan bot *only* runs the vk config.
     if 'Vulkan' in bot:
       configs = ['vk']
 
     if 'Metal' in bot:
       configs = ['mtl']
 
     # Test 1010102 on our Linux/NVIDIA bots and the persistent cache config
     # on the GL bots.
     if ('QuadroP400' in bot and 'PreAbandonGpuContext' not in bot and
         'TSAN' not in bot and api.vars.is_linux):
       if 'Vulkan' in bot:
         configs.append('vk1010102')
         # Decoding transparent images to 1010102 just looks bad
         blacklist('vk1010102 image _ _')
       else:
         configs.extend(['gl1010102', 'gltestpersistentcache'])
         # Decoding transparent images to 1010102 just looks bad
         blacklist('gl1010102 image _ _')
         # These tests produce slightly different pixels run to run on NV.
         blacklist('gltestpersistentcache gm _ atlastext')
         blacklist('gltestpersistentcache gm _ dftext')
         blacklist('gltestpersistentcache gm _ glyph_pos_h_b')
 
     # Test SkColorSpaceXformCanvas and rendering to wrapped dsts on a few bots
     # Also test 'glenarrow', which hits F16 surfaces and F16 vertex colors.
     if 'BonusConfigs' in api.vars.extra_tokens:
       configs = ['gbr-gl', 'glbetex', 'glbert', 'glenarrow']
 
 
     if 'ChromeOS' in bot:
       # Just run GLES for now - maybe add gles_msaa4 in the future
       configs = ['gles']
 
     if 'Chromecast' in bot:
       configs = ['gles']
 
     # Test coverage counting path renderer.
     if 'CCPR' in bot:
       configs = [c for c in configs if c == 'gl' or c == 'gles']
       args.extend(['--pr', 'ccpr', '--cachePathMasks', 'false'])
 
     # DDL is a GPU-only feature
     if 'DDL1' in bot:
       # This bot generates gl and vk comparison images for the large skps
       configs = [c for c in configs if c == 'gl' or c == 'vk']
       args.extend(['--skpViewportSize', "2048"])
       args.extend(['--pr', '~small'])
     if 'DDL3' in bot:
       # This bot generates the ddl-gl and ddl-vk images for the
       # large skps and the gms
       ddl_configs = ['ddl-' + c for c in configs if c == 'gl' or c == 'vk']
       ddl2_configs = ['ddl2-' + c for c in configs if c == 'gl' or c == 'vk']
       configs = ddl_configs + ddl2_configs
       args.extend(['--skpViewportSize', "2048"])
       args.extend(['--gpuThreads', "0"])
 
     if 'Lottie' in bot:
       configs = ['gl']
 
   tf = api.vars.builder_cfg.get('test_filter')
   if 'All' != tf:
     # Expected format: shard_XX_YY
     parts = tf.split('_')
     if len(parts) == 3:
       args.extend(['--shard', parts[1]])
       args.extend(['--shards', parts[2]])
     else: # pragma: nocover
       raise Exception('Invalid task name - bad shards: %s' % tf)
 
   args.append('--config')
   args.extend(configs)
 
   # Run tests, gms, and image decoding tests everywhere.
   args.extend('--src tests gm image lottie colorImage svg skp'.split(' '))
   if api.vars.builder_cfg.get('cpu_or_gpu') == 'GPU':
     # Don't run the 'svgparse_*' svgs on GPU.
     blacklist('_ svg _ svgparse_')
   elif bot == 'Test-Debian9-Clang-GCE-CPU-AVX2-x86_64-Debug-All-ASAN':
     # Only run the CPU SVGs on 8888.
     blacklist('~8888 svg _ _')
   else:
     # On CPU SVGs we only care about parsing. Only run them on the above bot.
     args.remove('svg')
 
   # Eventually I'd like these to pass, but for now just skip 'em.
   if 'SK_FORCE_RASTER_PIPELINE_BLITTER' in bot:
     args.remove('tests')
 
   if 'NativeFonts' in bot:  # images won't exercise native font integration :)
     args.remove('image')
     args.remove('colorImage')
 
   def remove_from_args(arg):
     if arg in args:
       args.remove(arg)
 
   if 'DDL' in bot:
     # The DDL bots just render the large skps and the gms
     remove_from_args('tests')
     remove_from_args('image')
     remove_from_args('colorImage')
     remove_from_args('svg')
   else:
     # Currently, only the DDL bots render skps
     remove_from_args('skp')
 
   if 'Lottie' in api.vars.builder_cfg.get('extra_config', ''):
     # Only run the lotties on Lottie bots.
     remove_from_args('tests')
     remove_from_args('gm')
     remove_from_args('image')
     remove_from_args('colorImage')
     remove_from_args('svg')
     remove_from_args('skp')
   else:
     remove_from_args('lottie')
 
   # TODO: ???
   blacklist('f16 _ _ dstreadshuffle')
   blacklist('glsrgb image _ _')
   blacklist('glessrgb image _ _')
 
   # Not any point to running these.
   blacklist('gbr-8888 image _ _')
   blacklist('gbr-8888 colorImage _ _')
 
   # --src image --config g8 means "decode into Gray8", which isn't supported.
   blacklist('g8 image _ _')
   blacklist('g8 colorImage _ _')
 
   if 'Valgrind' in bot:
     # These take 18+ hours to run.
     blacklist('pdf gm _ fontmgr_iter')
     blacklist('pdf _ _ PANO_20121023_214540.jpg')
     blacklist('pdf skp _ worldjournal')
     blacklist('pdf skp _ desk_baidu.skp')
     blacklist('pdf skp _ desk_wikipedia.skp')
     blacklist('_ svg _ _')
 
   if 'iOS' in bot:
     blacklist(gl_prefix + ' skp _ _')
 
   if 'Mac' in bot or 'iOS' in bot:
     # CG fails on questionable bmps
     blacklist('_ image gen_platf rgba32abf.bmp')
     blacklist('_ image gen_platf rgb24prof.bmp')
     blacklist('_ image gen_platf rgb24lprof.bmp')
     blacklist('_ image gen_platf 8bpp-pixeldata-cropped.bmp')
     blacklist('_ image gen_platf 4bpp-pixeldata-cropped.bmp')
     blacklist('_ image gen_platf 32bpp-pixeldata-cropped.bmp')
     blacklist('_ image gen_platf 24bpp-pixeldata-cropped.bmp')
 
     # CG has unpredictable behavior on this questionable gif
     # It's probably using uninitialized memory
     blacklist('_ image gen_platf frame_larger_than_image.gif')
 
     # CG has unpredictable behavior on incomplete pngs
     # skbug.com/5774
     blacklist('_ image gen_platf inc0.png')
     blacklist('_ image gen_platf inc1.png')
     blacklist('_ image gen_platf inc2.png')
     blacklist('_ image gen_platf inc3.png')
     blacklist('_ image gen_platf inc4.png')
     blacklist('_ image gen_platf inc5.png')
     blacklist('_ image gen_platf inc6.png')
     blacklist('_ image gen_platf inc7.png')
     blacklist('_ image gen_platf inc8.png')
     blacklist('_ image gen_platf inc9.png')
     blacklist('_ image gen_platf inc10.png')
     blacklist('_ image gen_platf inc11.png')
     blacklist('_ image gen_platf inc12.png')
     blacklist('_ image gen_platf inc13.png')
     blacklist('_ image gen_platf inc14.png')
     blacklist('_ image gen_platf incInterlaced.png')
 
     # These images fail after Mac 10.13.1 upgrade.
     blacklist('_ image gen_platf incInterlaced.gif')
     blacklist('_ image gen_platf inc1.gif')
     blacklist('_ image gen_platf inc0.gif')
     blacklist('_ image gen_platf butterfly.gif')
 
   # WIC fails on questionable bmps
   if 'Win' in bot:
     blacklist('_ image gen_platf pal8os2v2.bmp')
     blacklist('_ image gen_platf pal8os2v2-16.bmp')
     blacklist('_ image gen_platf rgba32abf.bmp')
     blacklist('_ image gen_platf rgb24prof.bmp')
     blacklist('_ image gen_platf rgb24lprof.bmp')
     blacklist('_ image gen_platf 8bpp-pixeldata-cropped.bmp')
     blacklist('_ image gen_platf 4bpp-pixeldata-cropped.bmp')
     blacklist('_ image gen_platf 32bpp-pixeldata-cropped.bmp')
     blacklist('_ image gen_platf 24bpp-pixeldata-cropped.bmp')
     if 'x86_64' in bot and 'CPU' in bot:
       # This GM triggers a SkSmallAllocator assert.
       blacklist('_ gm _ composeshader_bitmap')
 
   if 'Win' in bot or 'Mac' in bot:
     # WIC and CG fail on arithmetic jpegs
     blacklist('_ image gen_platf testimgari.jpg')
     # More questionable bmps that fail on Mac, too. skbug.com/6984
     blacklist('_ image gen_platf rle8-height-negative.bmp')
     blacklist('_ image gen_platf rle4-height-negative.bmp')
 
   # These PNGs have CRC errors. The platform generators seem to draw
   # uninitialized memory without reporting an error, so skip them to
   # avoid lots of images on Gold.
   blacklist('_ image gen_platf error')
 
   if 'Android' in bot or 'iOS' in bot or 'Chromecast' in bot:
     # This test crashes the N9 (perhaps because of large malloc/frees). It also
     # is fairly slow and not platform-specific. So we just disable it on all of
     # Android and iOS. skia:5438
     blacklist('_ test _ GrShape')
 
   if api.vars.internal_hardware_label == '2':
     # skia:7160
     blacklist('_ test _ SRGBReadWritePixels')
     blacklist('_ test _ SRGBMipMap')
 
   if api.vars.internal_hardware_label == '5':
     # http://b/118312149#comment9
     blacklist('_ test _ SRGBReadWritePixels')
 
   # skia:4095
   bad_serialize_gms = ['bleed_image',
                        'c_gms',
                        'colortype',
                        'colortype_xfermodes',
                        'drawfilter',
                        'fontmgr_bounds_0.75_0',
                        'fontmgr_bounds_1_-0.25',
                        'fontmgr_bounds',
                        'fontmgr_match',
                        'fontmgr_iter',
                        'imagemasksubset']
 
   # skia:5589
   bad_serialize_gms.extend(['bitmapfilters',
                             'bitmapshaders',
                             'bleed',
                             'bleed_alpha_bmp',
                             'bleed_alpha_bmp_shader',
                             'convex_poly_clip',
                             'extractalpha',
                             'filterbitmap_checkerboard_32_32_g8',
                             'filterbitmap_image_mandrill_64',
                             'shadows',
                             'simpleaaclip_aaclip'])
   # skia:5595
   bad_serialize_gms.extend(['composeshader_bitmap',
                             'scaled_tilemodes_npot',
                             'scaled_tilemodes'])
 
   # skia:5778
   bad_serialize_gms.append('typefacerendering_pfaMac')
   # skia:5942
   bad_serialize_gms.append('parsedpaths')
 
   # these use a custom image generator which doesn't serialize
   bad_serialize_gms.append('ImageGeneratorExternal_rect')
   bad_serialize_gms.append('ImageGeneratorExternal_shader')
 
   # skia:6189
   bad_serialize_gms.append('shadow_utils')
 
   # skia:7938
   bad_serialize_gms.append('persp_images')
 
   # Not expected to round trip encoding/decoding.
   bad_serialize_gms.append('all_bitmap_configs')
   bad_serialize_gms.append('makecolorspace')
   bad_serialize_gms.append('readpixels')
   bad_serialize_gms.append('draw_image_set_rect_to_rect')
-  bad_serialize_gms.append('compositor_quads_shader')
 
   # This GM forces a path to be convex. That property doesn't survive
   # serialization.
   bad_serialize_gms.append('analytic_antialias_convex')
 
   for test in bad_serialize_gms:
     blacklist(['serialize-8888', 'gm', '_', test])
 
   if 'Mac' not in bot:
     for test in ['bleed_alpha_image', 'bleed_alpha_image_shader']:
       blacklist(['serialize-8888', 'gm', '_', test])
   # It looks like we skip these only for out-of-memory concerns.
   if 'Win' in bot or 'Android' in bot:
     for test in ['verylargebitmap', 'verylarge_picture_image']:
       blacklist(['serialize-8888', 'gm', '_', test])
   if 'Mac' in bot and 'CPU' in bot:
     # skia:6992
     blacklist(['pic-8888', 'gm', '_', 'encode-platform'])
     blacklist(['serialize-8888', 'gm', '_', 'encode-platform'])
 
   # skia:4769
   for test in ['drawfilter']:
     blacklist([   'pic-8888', 'gm', '_', test])
     blacklist([  'lite-8888', 'gm', '_', test])
   # skia:4703
   for test in ['image-cacherator-from-picture',
                'image-cacherator-from-raster',
                'image-cacherator-from-ctable']:
     blacklist([      'pic-8888', 'gm', '_', test])
     blacklist(['serialize-8888', 'gm', '_', test])
 
   # GM that requires raster-backed canvas
   for test in ['complexclip4_bw', 'complexclip4_aa', 'p3']:
     blacklist([      'pic-8888', 'gm', '_', test])
     blacklist([     'lite-8888', 'gm', '_', test])
     blacklist(['serialize-8888', 'gm', '_', test])
 
   # GM that not support tiles_rt
   for test in ['complexclip4_bw', 'complexclip4_aa']:
     blacklist([ 'tiles_rt-8888', 'gm', '_', test])
 
   # Extensions for RAW images
   r = ['arw', 'cr2', 'dng', 'nef', 'nrw', 'orf', 'raf', 'rw2', 'pef', 'srw',
        'ARW', 'CR2', 'DNG', 'NEF', 'NRW', 'ORF', 'RAF', 'RW2', 'PEF', 'SRW']
 
   # skbug.com/4888
   # Blacklist RAW images (and a few large PNGs) on GPU bots
   # until we can resolve failures.
   if 'GPU' in bot:
     blacklist('_ image _ interlaced1.png')
     blacklist('_ image _ interlaced2.png')
     blacklist('_ image _ interlaced3.png')
     for raw_ext in r:
       blacklist('_ image _ .%s' % raw_ext)
 
   # Blacklist memory intensive tests on 32-bit bots.
   if ('Win8' in bot or 'Win2016' in bot) and 'x86-' in bot:
     blacklist('_ image f16 _')
     blacklist('_ image _ abnormal.wbmp')
     blacklist('_ image _ interlaced1.png')
     blacklist('_ image _ interlaced2.png')
     blacklist('_ image _ interlaced3.png')
     for raw_ext in r:
       blacklist('_ image _ .%s' % raw_ext)
 
   if 'Nexus5' in bot and 'GPU' in bot:
     # skia:5876
     blacklist(['_', 'gm', '_', 'encode-platform'])
 
   if 'AndroidOne-GPU' in bot:  # skia:4697, skia:4704, skia:4694, skia:4705
     blacklist(['_',            'gm', '_', 'bigblurs'])
     blacklist(['_',            'gm', '_', 'bleed'])
     blacklist(['_',            'gm', '_', 'bleed_alpha_bmp'])
     blacklist(['_',            'gm', '_', 'bleed_alpha_bmp_shader'])
     blacklist(['_',            'gm', '_', 'bleed_alpha_image'])
     blacklist(['_',            'gm', '_', 'bleed_alpha_image_shader'])
     blacklist(['_',            'gm', '_', 'bleed_image'])
     blacklist(['_',            'gm', '_', 'dropshadowimagefilter'])
     blacklist(['_',            'gm', '_', 'filterfastbounds'])
     blacklist([gl_prefix,      'gm', '_', 'imageblurtiled'])
     blacklist(['_',            'gm', '_', 'imagefiltersclipped'])
     blacklist(['_',            'gm', '_', 'imagefiltersscaled'])
     blacklist(['_',            'gm', '_', 'imageresizetiled'])
     blacklist(['_',            'gm', '_', 'matrixconvolution'])
     blacklist(['_',            'gm', '_', 'strokedlines'])
     if sample_count is not '':
       gl_msaa_config = gl_prefix + 'msaa' + sample_count
       blacklist([gl_msaa_config, 'gm', '_', 'imageblurtiled'])
       blacklist([gl_msaa_config, 'gm', '_', 'imagefiltersbase'])
 
   match = []
   if 'Valgrind' in bot: # skia:3021
     match.append('~Threaded')
 
   if 'Valgrind' in bot and 'PreAbandonGpuContext' in bot:
     # skia:6575
     match.append('~multipicturedraw_')
 
   if 'CommandBuffer' in bot:
     # https://crbug.com/697030
     match.append('~HalfFloatAlphaTextureTest')
 
   if 'AndroidOne' in bot:
     match.append('~WritePixels')  # skia:4711
     match.append('~PremulAlphaRoundTrip_Gpu')  # skia:7501
     match.append('~ReimportImageTextureWithMipLevels')  # skia:8090
 
   if 'Chromecast' in bot:
     if 'GPU' in bot:
       # skia:6687
       match.append('~animated-image-blurs')
       match.append('~blur_0.01')
       match.append('~blur_image_filter')
       match.append('~check_small_sigma_offset')
       match.append('~imageblur2')
       match.append('~lighting')
       match.append('~longpathdash')
       match.append('~matrixconvolution')
       match.append('~textblobmixedsizes_df')
       match.append('~textblobrandomfont')
     # Blacklisted to avoid OOM (we see DM just end with "broken pipe")
     match.append('~bigbitmaprect_')
     match.append('~DrawBitmapRect')
     match.append('~drawbitmaprect')
     match.append('~GM_animated-image-blurs')
     match.append('~ImageFilterBlurLargeImage')
     match.append('~savelayer_clipmask')
     match.append('~TextBlobCache')
     match.append('~verylarge')
 
   if 'GalaxyS6' in bot:
     match.append('~SpecialImage') # skia:6338
     match.append('~skbug6653') # skia:6653
 
   if 'MSAN' in bot:
     match.extend(['~Once', '~Shared'])  # Not sure what's up with these tests.
 
   if 'TSAN' in bot:
     match.extend(['~ReadWriteAlpha'])   # Flaky on TSAN-covered on nvidia bots.
     match.extend(['~RGBA4444TextureTest',  # Flakier than they are important.
                   '~RGB565TextureTest'])
 
   # By default, we test with GPU threading enabled, unless specifically
   # disabled.
   if 'NoGPUThreads' in bot:
     args.extend(['--gpuThreads', '0'])
 
   if 'Vulkan' in bot and 'Adreno530' in bot:
       # skia:5777
       match.extend(['~CopySurface'])
 
   if 'Vulkan' in bot and 'Adreno' in bot:
       # skia:7663
       match.extend(['~WritePixelsNonTextureMSAA_Gpu'])
       match.extend(['~WritePixelsMSAA_Gpu'])
 
   if 'Vulkan' in bot and api.vars.is_linux and 'IntelIris640' in bot:
     match.extend(['~VkHeapTests']) # skia:6245
 
   if api.vars.is_linux and 'IntelIris640' in bot:
     match.extend(['~GLPrograms']) # skia:7849
 
   if 'Vulkan' in bot and api.vars.is_linux and 'IntelHD405' in bot:
     # skia:7322
     blacklist(['vk', 'gm', '_', 'skbug_257'])
     blacklist(['vk', 'gm', '_', 'filltypespersp'])
     match.append('~^ClearOp$')
     match.append('~^CopySurface$')
     match.append('~^ImageNewShader_GPU$')
     match.append('~^InitialTextureClear$')
     match.append('~^PinnedImageTest$')
     match.append('~^ReadPixels_Gpu$')
     match.append('~^ReadPixels_Texture$')
     match.append('~^SRGBReadWritePixels$')
     match.append('~^VkUploadPixelsTests$')
     match.append('~^WritePixelsNonTexture_Gpu$')
     match.append('~^WritePixelsNonTextureMSAA_Gpu$')
     match.append('~^WritePixels_Gpu$')
     match.append('~^WritePixelsMSAA_Gpu$')
 
   if 'Vulkan' in bot and 'GTX660' in bot and 'Win' in bot:
     # skbug.com/8047
     match.append('~FloatingPointTextureTest$')
 
   if 'Vulkan' in bot and 'Win10' in bot and 'IntelIris655' in bot:
     # skia:8659
     blacklist(['vk', 'gm', '_', 'aarectmodes'])
     blacklist(['vk', 'gm', '_', 'aaxfermodes'])
-    blacklist(['vk', 'gm', '_', 'compositor_quads_filter'])
     blacklist(['vk', 'gm', '_', 'crbug_892988'])
     blacklist(['vk', 'gm', '_', 'dftext'])
     blacklist(['vk', 'gm', '_', 'dftext_blob_persp'])
     blacklist(['vk', 'gm', '_', 'dont_clip_to_layer'])
     blacklist(['vk', 'gm', '_', 'drawregionmodes'])
     blacklist(['vk', 'gm', '_', 'filterfastbounds'])
     blacklist(['vk', 'gm', '_', 'fontmgr_iter'])
     blacklist(['vk', 'gm', '_', 'fontmgr_match'])
     blacklist(['vk', 'gm', '_', 'fontscaler'])
     blacklist(['vk', 'gm', '_', 'fontscalerdistortable'])
     blacklist(['vk', 'gm', '_', 'gammagradienttext'])
     blacklist(['vk', 'gm', '_', 'gammatext'])
     blacklist(['vk', 'gm', '_', 'gradtext'])
     blacklist(['vk', 'gm', '_', 'hairmodes'])
     blacklist(['vk', 'gm', '_', 'imagefilters_xfermodes'])
     blacklist(['vk', 'gm', '_', 'imagefiltersclipped'])
     blacklist(['vk', 'gm', '_', 'imagefiltersscaled'])
     blacklist(['vk', 'gm', '_', 'imagefiltersstroked'])
     blacklist(['vk', 'gm', '_', 'imagefilterstransformed'])
     blacklist(['vk', 'gm', '_', 'imageresizetiled'])
     blacklist(['vk', 'gm', '_', 'lcdblendmodes'])
     blacklist(['vk', 'gm', '_', 'lcdoverlap'])
     blacklist(['vk', 'gm', '_', 'lcdtext'])
     blacklist(['vk', 'gm', '_', 'lcdtextsize'])
     blacklist(['vk', 'gm', '_', 'matriximagefilter'])
     blacklist(['vk', 'gm', '_', 'resizeimagefilter'])
     blacklist(['vk', 'gm', '_', 'rotate_imagefilter'])
     blacklist(['vk', 'gm', '_', 'savelayer_lcdtext'])
     blacklist(['vk', 'gm', '_', 'shadermaskfilter_image'])
     blacklist(['vk', 'gm', '_', 'srcmode'])
     blacklist(['vk', 'gm', '_', 'surfaceprops'])
     blacklist(['vk', 'gm', '_', 'textblobgeometrychange'])
     blacklist(['vk', 'gm', '_', 'textbloblooper'])
     blacklist(['vk', 'gm', '_', 'textblobrandomfont'])
     blacklist(['vk', 'gm', '_', 'textfilter_color'])
     blacklist(['vk', 'gm', '_', 'textfilter_image'])
     blacklist(['vk', 'gm', '_', 'tilemodes'])
     blacklist(['vk', 'gm', '_', 'varied_text_clipped_lcd'])
     blacklist(['vk', 'gm', '_', 'varied_text_ignorable_clip_lcd'])
     if 'Debug' in bot:
       blacklist(['vk', 'gm', '_', 'mixedtextblobs'])
       blacklist(['vk', 'gm', '_', 'textblobmixedsizes'])
       blacklist(['vk', 'gm', '_', 'textblobmixedsizes_df'])
 
   if 'MoltenVK' in bot:
     # skbug.com/7959
     blacklist(['_', 'gm', '_', 'vertices_scaled_shader'])
     blacklist(['_', 'gm', '_', 'vertices'])
     match.append('~^InitialTextureClear$')
     match.append('~^RGB565TextureTest$')
     match.append('~^RGBA4444TextureTest$')
     match.append('~^TextureIdleProcFlushTest$')
     match.append('~^WritePixelsNonTextureMSAA_Gpu$')
 
   if 'ANGLE' in bot:
     # skia:7835
     match.append('~BlurMaskBiggerThanDest')
 
   if 'IntelIris6100' in bot and 'ANGLE' in bot and 'Release' in bot:
     # skia:7376
     match.append('~^ProcessorOptimizationValidationTest$')
 
   if ('IntelIris6100' in bot or 'IntelHD4400' in bot) and 'ANGLE' in bot:
     # skia:6857
     blacklist(['angle_d3d9_es2', 'gm', '_', 'lighting'])
 
   if 'Chorizo' in bot:
     # skia:8869
     blacklist(['_', 'gm', '_', 'compositor_quads_filter'])
 
   if 'PowerVRGX6250' in bot:
     match.append('~gradients_view_perspective_nodither') #skia:6972
 
   if '-arm-' in bot and 'ASAN' in bot:
     # TODO: can we run with env allocator_may_return_null=1 instead?
     match.append('~BadImage')
 
   if 'Mac' in bot and 'IntelHD6000' in bot:
     # skia:7574
     match.append('~^ProcessorCloneTest$')
     match.append('~^GrMeshTest$')
 
   if 'Mac' in bot and 'IntelHD615' in bot:
     # skia:7603
     match.append('~^GrMeshTest$')
 
   if 'Metal' in bot:
     # skia:8243
     match.append('~^DDLMakeRenderTargetTest$')
     match.append('~^DDLNonTextureabilityTest$')
     match.append('~^DDLOperatorEqTest$')
     match.append('~^DDLSurfaceCharacterizationTest$')
     match.append('~^GrContext_colorTypeSupportedAsImage$')
     match.append('~^GrContext_colorTypeSupportedAsSurface$')
     match.append('~^GrContext_maxSurfaceSamplesForColorType$')
     match.append('~^GrContextFactory_sharedContexts$')
     match.append('~^GrDefaultPathRendererTest$')
     match.append('~^GrPipelineDynamicStateTest$')
     match.append('~^InitialTextureClear$')
     match.append('~^PromiseImageTextureFullCache$')
     match.append('~^PromiseImageTextureReuseDifferentConfig$')
     match.append('~^SurfaceSemaphores$')
     match.append('~^SurfaceTest$')
     match.append('~^TransferPixelsTest$')
     match.append('~^VertexAttributeCount$')
     match.append('~^WritePixelsNonTexture_Gpu$')
     if 'Mac' in bot:
       match.append('~^RGB565TextureTest$')
       match.append('~^RGBA4444TextureTest$')
       match.append('~^TextureIdleProcFlushTest$')
 
   if 'Wuffs' in api.vars.extra_tokens:
     # skia:8750
     blacklist(['_', 'tests', '_', 'Codec_partial'])
     # skia:8762
     blacklist(['_', 'tests', '_', 'Codec_gif'])
 
   if blacklisted:
     args.append('--blacklist')
     args.extend(blacklisted)
 
   if match:
     args.append('--match')
     args.extend(match)
 
   # These bots run out of memory running RAW codec tests. Do not run them in
   # parallel
   if 'NexusPlayer' in bot or 'Nexus5' in bot or 'Nexus9' in bot:
     args.append('--noRAW_threading')
 
   if 'FSAA' in bot:
     args.extend(['--analyticAA', 'false', '--deltaAA', 'false'])
   if 'FAAA' in bot:
     args.extend(['--deltaAA', 'false', '--forceAnalyticAA'])
   if 'FDAA' in bot:
     args.extend(['--deltaAA', '--forceDeltaAA'])
 
   if 'NativeFonts' not in bot:
     args.append('--nonativeFonts')
 
   if 'GDI' in bot:
     args.append('--gdi')
 
   if ('QuadroP400' in bot or
       'Adreno540' in bot or
       'IntelHD2000' in bot or   # gen 6 - sandy bridge
       'IntelHD4400' in bot or   # gen 7 - haswell
       'IntelHD405' in bot or    # gen 8 - cherryview braswell
       'IntelIris6100' in bot or # gen 8 - broadwell
       'IntelIris540' in bot or  # gen 9 - skylake
       'IntelIris640' in bot or  # gen 9 - kaby lake
       'IntelIris655' in bot or  # gen 9 - coffee lake
       'MaliT760' in bot or
       'MaliT860' in bot or
       'MaliT880' in bot):
     args.extend(['--reduceOpListSplitting'])
 
   # Let's make all bots produce verbose output by default.
   args.append('--verbose')
 
   return args
diff --git a/src/core/SkCanvas.cpp b/src/core/SkCanvas.cpp
index 720ac60529..9e0b426e36 100644
--- a/src/core/SkCanvas.cpp
+++ b/src/core/SkCanvas.cpp
@@ -1876,6 +1876,23 @@ void SkCanvas::drawImageLattice(const SkImage* image, const Lattice& lattice, co
     }
 }
 
+void SkCanvas::experimental_DrawImageSetV1(const ImageSetEntry imageSet[], int cnt,
+                                           SkFilterQuality filterQuality, SkBlendMode mode) {
+    TRACE_EVENT0("skia", TRACE_FUNC);
+    RETURN_ON_NULL(imageSet);
+    RETURN_ON_FALSE(cnt);
+
+    this->onDrawImageSet(imageSet, cnt, filterQuality, mode);
+}
+
+void SkCanvas::experimental_DrawEdgeAARectV1(const SkRect& r, QuadAAFlags edgeAA, SkColor color,
+                                             SkBlendMode mode) {
+    TRACE_EVENT0("skia", TRACE_FUNC);
+    // To avoid redundant logic in our culling code and various backends, we always sort rects
+    // before passing them along.
+    this->onDrawEdgeAARect(r.makeSorted(), edgeAA, color, mode);
+}
+
 void SkCanvas::drawBitmap(const SkBitmap& bitmap, SkScalar dx, SkScalar dy, const SkPaint* paint) {
     TRACE_EVENT0("skia", TRACE_FUNC);
     if (bitmap.drawsNothing()) {
@@ -1995,56 +2012,6 @@ void SkCanvas::onDrawShadowRec(const SkPath& path, const SkDrawShadowRec& rec) {
     LOOPER_END
 }
 
-void SkCanvas::experimental_DrawImageSetV1(const ImageSetEntry imageSet[], int cnt,
-                                           SkFilterQuality filterQuality, SkBlendMode mode) {
-    TRACE_EVENT0("skia", TRACE_FUNC);
-    RETURN_ON_NULL(imageSet);
-    RETURN_ON_FALSE(cnt);
-
-    // DrawImageSetV1 is the same as DrawEdgeAAImageSet by making a paint from its filterQuality and
-    // blend mode, and not providing any clip region. To safely handle that, we make a copy of the
-    // entry set and set fHasClip to false and fMatrixIndex to -1 on each entry. Since this
-    // function will be going away, that performance hit is acceptable.
-    SkTArray<ImageSetEntry> safeImages(cnt);
-    for (int i = 0; i < cnt; ++i) {
-        ImageSetEntry& e = safeImages.push_back();
-        e = imageSet[i];
-        e.fHasClip = false;
-        e.fMatrixIndex = -1;
-    }
-
-    SkPaint paint;
-    paint.setFilterQuality(filterQuality);
-    paint.setBlendMode(mode);
-    this->onDrawEdgeAAImageSet(safeImages.begin(), cnt, nullptr, nullptr, &paint,
-                               kFast_SrcRectConstraint);
-}
-
-void SkCanvas::experimental_DrawEdgeAARectV1(const SkRect& r, QuadAAFlags edgeAA, SkColor color,
-                                             SkBlendMode mode) {
-    TRACE_EVENT0("skia", TRACE_FUNC);
-    // To avoid redundant logic in our culling code and various backends, we always sort rects
-    // before passing them along.
-    // DrawEdgeAARectV1 is the same as DrawEdgeAAQuad when no clip region is specified
-    this->onDrawEdgeAAQuad(r.makeSorted(), nullptr, edgeAA, color, mode);
-}
-
-void SkCanvas::experimental_DrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                           QuadAAFlags aaFlags, SkColor color, SkBlendMode mode) {
-    TRACE_EVENT0("skia", TRACE_FUNC);
-    // Make sure the rect is sorted before passing it along
-    this->onDrawEdgeAAQuad(rect.makeSorted(), clip, aaFlags, color, mode);
-}
-
-void SkCanvas::experimental_DrawEdgeAAImageSet(const ImageSetEntry imageSet[], int cnt,
-                                               const SkPoint dstClips[],
-                                               const SkMatrix preViewMatrices[],
-                                               const SkPaint* paint,
-                                               SrcRectConstraint constraint) {
-    TRACE_EVENT0("skia", TRACE_FUNC);
-    this->onDrawEdgeAAImageSet(imageSet, cnt, dstClips, preViewMatrices, paint, constraint);
-}
-
 //////////////////////////////////////////////////////////////////////////////
 //  These are the virtual drawing methods
 //////////////////////////////////////////////////////////////////////////////
@@ -2136,6 +2103,20 @@ void SkCanvas::onDrawRect(const SkRect& r, const SkPaint& paint) {
     }
 }
 
+void SkCanvas::onDrawEdgeAARect(const SkRect& r, QuadAAFlags edgeAA, SkColor color,
+                                SkBlendMode mode) {
+    SkASSERT(r.isSorted());
+
+    SkPaint paint;
+    LOOPER_BEGIN(paint, nullptr)
+
+    while (iter.next()) {
+        iter.fDevice->drawEdgeAARect(r, edgeAA, color, mode);
+    }
+
+    LOOPER_END
+}
+
 void SkCanvas::onDrawRegion(const SkRegion& region, const SkPaint& paint) {
     SkRect regionRect = SkRect::Make(region.getBounds());
     if (paint.canComputeFastBounds()) {
@@ -2531,6 +2512,16 @@ void SkCanvas::onDrawImageLattice(const SkImage* image, const Lattice& lattice,
     LOOPER_END
 }
 
+void SkCanvas::onDrawImageSet(const ImageSetEntry imageSet[], int count,
+                              SkFilterQuality filterQuality, SkBlendMode mode) {
+    SkPaint paint;
+    LOOPER_BEGIN(paint, nullptr)
+    while (iter.next()) {
+        iter.fDevice->drawImageSet(imageSet, count, filterQuality, mode);
+    }
+    LOOPER_END
+}
+
 void SkCanvas::onDrawBitmapLattice(const SkBitmap& bitmap, const Lattice& lattice,
                                    const SkRect& dst, const SkPaint* paint) {
     SkPaint realPaint;
@@ -2698,40 +2689,7 @@ void SkCanvas::onDrawAnnotation(const SkRect& rect, const char key[], SkData* va
     LOOPER_END
 }
 
-void SkCanvas::onDrawEdgeAAQuad(const SkRect& r, const SkPoint clip[4],  QuadAAFlags edgeAA,
-                                SkColor color, SkBlendMode mode) {
-    SkASSERT(r.isSorted());
-
-    // If this used a paint, it would be a filled color with blend mode, which does not
-    // need to use an autodraw loop, so use SkDrawIter directly.
-    if (this->quickReject(r)) {
-        return;
-    }
-
-    this->predrawNotify();
-    SkDrawIter iter(this);
-    while(iter.next()) {
-        iter.fDevice->drawEdgeAAQuad(r, clip, edgeAA, color, mode);
-    }
-}
-
-void SkCanvas::onDrawEdgeAAImageSet(const ImageSetEntry imageSet[], int count,
-                                    const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                                    const SkPaint* paint, SrcRectConstraint constraint) {
-    SkPaint realPaint;
-    init_image_paint(&realPaint, paint);
-
-    // Looper is used when there are image filters, which drawEdgeAAImageSet needs to support
-    // for Chromium's RenderPassDrawQuads' filters.
-    LOOPER_BEGIN(realPaint, nullptr)
-    while (iter.next()) {
-        iter.fDevice->drawEdgeAAImageSet(
-                imageSet, count, dstClips, preViewMatrices, looper.paint(), constraint);
-    }
-    LOOPER_END
-}
-
 //////////////////////////////////////////////////////////////////////////////
 // These methods are NOT virtual, and therefore must call back into virtual
 // methods, rather than actually drawing themselves.
 //////////////////////////////////////////////////////////////////////////////
diff --git a/src/core/SkCanvasPriv.cpp b/src/core/SkCanvasPriv.cpp
index 5249687d31..35c9866398 100644
--- a/src/core/SkCanvasPriv.cpp
+++ b/src/core/SkCanvasPriv.cpp
@@ -83,17 +83,3 @@ void SkCanvasPriv::WriteLattice(SkWriteBuffer& buffer, const SkCanvas::Lattice&
     buffer.writePad32(storage.get(), size);
 }
 
-void SkCanvasPriv::GetDstClipAndMatrixCounts(const SkCanvas::ImageSetEntry set[], int count,
-                                             int* totalDstClipCount, int* totalMatrixCount) {
-    int dstClipCount = 0;
-    int maxMatrixIndex = -1;
-    for (int i = 0; i < count; ++i) {
-        dstClipCount += 4 * set[i].fHasClip;
-        if (set[i].fMatrixIndex > maxMatrixIndex) {
-            maxMatrixIndex = set[i].fMatrixIndex;
-        }
-    }
-
-    *totalDstClipCount = dstClipCount;
-    *totalMatrixCount = maxMatrixIndex + 1;
-}
diff --git a/src/core/SkCanvasPriv.h b/src/core/SkCanvasPriv.h
index e06e06a41e..cb2540177a 100644
--- a/src/core/SkCanvasPriv.h
+++ b/src/core/SkCanvasPriv.h
@@ -27,28 +27,22 @@ class SkCanvasPriv {
 public:
     enum {
         kDontClipToLayer_SaveLayerFlag = SkCanvas::kDontClipToLayer_PrivateSaveLayerFlag,
     };
 
     // The lattice has pointers directly into the readbuffer
     static bool ReadLattice(SkReadBuffer&, SkCanvas::Lattice*);
 
     static void WriteLattice(SkWriteBuffer&, const SkCanvas::Lattice&);
 
     // return the byte-size of the lattice, even if the buffer is null
     // storage must be 4-byte aligned
     static size_t WriteLattice(void* storage, const SkCanvas::Lattice&);
 
     static SkCanvas::SaveLayerFlags LegacySaveFlagsToSaveLayerFlags(uint32_t legacySaveFlags);
 
     static int SaveBehind(SkCanvas* canvas, const SkRect* subset) {
         return canvas->only_axis_aligned_saveBehind(subset);
     }
-
-    // The experimental_DrawEdgeAAImageSet API accepts separate dstClips and preViewMatrices arrays,
-    // where entries refer into them, but no explicit size is provided. Given a set of entries,
-    // computes the minimum length for these arrays that would provide index access errors.
-    static void GetDstClipAndMatrixCounts(const SkCanvas::ImageSetEntry set[], int count,
-                                          int* totalDstClipCount, int* totalMatrixCount);
 };
 
 #endif
diff --git a/src/core/SkColorSpaceXformCanvas.cpp b/src/core/SkColorSpaceXformCanvas.cpp
index bfbdfa7b66..ceb014e7b5 100644
--- a/src/core/SkColorSpaceXformCanvas.cpp
+++ b/src/core/SkColorSpaceXformCanvas.cpp
@@ -34,289 +34,283 @@ class SkColorSpaceXformCanvas : public SkCanvasVirtualEnforcer<SkNoDrawCanvas> {
 public:
     SkColorSpaceXformCanvas(SkCanvas* target, sk_sp<SkColorSpace> targetCS,
                             std::unique_ptr<SkColorSpaceXformer> xformer)
         : SkCanvasVirtualEnforcer<SkNoDrawCanvas>(SkIRect::MakeSize(target->getBaseLayerSize()))
         , fTarget(target)
         , fTargetCS(targetCS)
         , fXformer(std::move(xformer))
     {
         // Set the matrix and clip to match |fTarget|.  Otherwise, we'll answer queries for
         // bounds/matrix differently than |fTarget| would.
         SkCanvas::onClipRect(SkRect::Make(fTarget->getDeviceClipBounds()),
                              SkClipOp::kIntersect, kHard_ClipEdgeStyle);
         SkCanvas::setMatrix(fTarget->getTotalMatrix());
     }
 
     SkImageInfo onImageInfo() const override {
         return fTarget->imageInfo().makeColorSpace(fTargetCS);
     }
 
     void onDrawPaint(const SkPaint& paint) override {
         fTarget->drawPaint(fXformer->apply(paint));
     }
 
     void onDrawRect(const SkRect& rect, const SkPaint& paint) override {
         fTarget->drawRect(rect, fXformer->apply(paint));
     }
+    void onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa, SkColor color,
+                          SkBlendMode mode) override {
+        fTarget->experimental_DrawEdgeAARectV1(rect, aa, fXformer->apply(color), mode);
+    }
     void onDrawOval(const SkRect& oval, const SkPaint& paint) override {
         fTarget->drawOval(oval, fXformer->apply(paint));
     }
     void onDrawRRect(const SkRRect& rrect, const SkPaint& paint) override {
         fTarget->drawRRect(rrect, fXformer->apply(paint));
     }
     void onDrawDRRect(const SkRRect& outer, const SkRRect& inner, const SkPaint& paint) override {
         fTarget->drawDRRect(outer, inner, fXformer->apply(paint));
     }
     void onDrawPath(const SkPath& path, const SkPaint& paint) override {
         fTarget->drawPath(path, fXformer->apply(paint));
     }
     void onDrawArc(const SkRect& oval, SkScalar start, SkScalar sweep, bool useCenter,
                    const SkPaint& paint) override {
         fTarget->drawArc(oval, start, sweep, useCenter, fXformer->apply(paint));
     }
     void onDrawRegion(const SkRegion& region, const SkPaint& paint) override {
         fTarget->drawRegion(region, fXformer->apply(paint));
     }
     void onDrawPatch(const SkPoint cubics[12], const SkColor colors[4], const SkPoint texs[4],
                      SkBlendMode mode, const SkPaint& paint) override {
         SkColor xformed[4];
         if (colors) {
             fXformer->apply(xformed, colors, 4);
             colors = xformed;
         }
 
         fTarget->drawPatch(cubics, colors, texs, mode, fXformer->apply(paint));
     }
     void onDrawPoints(PointMode mode, size_t count, const SkPoint* pts,
                       const SkPaint& paint) override {
         fTarget->drawPoints(mode, count, pts, fXformer->apply(paint));
     }
 
     void onDrawVerticesObject(const SkVertices* vertices, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode mode, const SkPaint& paint) override {
         sk_sp<SkVertices> copy;
         if (vertices->hasColors()) {
             int count = vertices->vertexCount();
             SkSTArray<8, SkColor> xformed(count);
             fXformer->apply(xformed.begin(), vertices->colors(), count);
             copy = SkVertices::MakeCopy(vertices->mode(), count, vertices->positions(),
                                         vertices->texCoords(), xformed.begin(),
                                         vertices->boneIndices(), vertices->boneWeights(),
                                         vertices->indexCount(), vertices->indices());
             vertices = copy.get();
         }
 
         fTarget->drawVertices(vertices, bones, boneCount, mode, fXformer->apply(paint));
     }
 
     void onDrawTextBlob(const SkTextBlob* blob,
                         SkScalar x, SkScalar y,
                         const SkPaint& paint) override {
         fTarget->drawTextBlob(blob, x, y, fXformer->apply(paint));
     }
 
     void onDrawImage(const SkImage* img,
                      SkScalar l, SkScalar t,
                      const SkPaint* paint) override {
         if (!fTarget->quickReject(SkRect::Make(img->bounds()).makeOffset(l,t))) {
             fTarget->drawImage(prepareImage(img).get(), l, t, MaybePaint(paint, fXformer.get()));
         }
     }
     void onDrawImageRect(const SkImage* img,
                          const SkRect* src, const SkRect& dst,
                          const SkPaint* paint, SrcRectConstraint constraint) override {
         if (!fTarget->quickReject(dst)) {
             fTarget->drawImageRect(prepareImage(img).get(),
                                    src ? *src : SkRect::MakeIWH(img->width(), img->height()), dst,
                                    MaybePaint(paint, fXformer.get()), constraint);
         }
     }
     void onDrawImageNine(const SkImage* img,
                          const SkIRect& center, const SkRect& dst,
                          const SkPaint* paint) override {
         if (!fTarget->quickReject(dst)) {
             fTarget->drawImageNine(prepareImage(img).get(), center, dst,
                                    MaybePaint(paint, fXformer.get()));
         }
     }
     void onDrawImageLattice(const SkImage* img,
                             const Lattice& lattice, const SkRect& dst,
                             const SkPaint* paint) override {
         if (!fTarget->quickReject(dst)) {
             SkSTArray<16, SkColor> colorBuffer;
             int count = lattice.fRectTypes && lattice.fColors ?
                         (lattice.fXCount + 1) * (lattice.fYCount + 1) : 0;
             colorBuffer.reset(count);
             fTarget->drawImageLattice(prepareImage(img).get(),
                                       fXformer->apply(lattice, colorBuffer.begin(), count),
                                       dst, MaybePaint(paint, fXformer.get()));
         }
     }
+    void onDrawImageSet(const SkCanvas::ImageSetEntry set[], int count,
+                        SkFilterQuality filterQuality, SkBlendMode mode) override {
+        SkAutoTArray<ImageSetEntry> xformedSet(count);
+        for (int i = 0; i < count; ++i) {
+            xformedSet[i].fImage = this->prepareImage(set[i].fImage.get());
+            xformedSet[i].fSrcRect = set[i].fSrcRect;
+            xformedSet[i].fDstRect = set[i].fDstRect;
+            xformedSet[i].fAlpha = set[i].fAlpha;
+            xformedSet[i].fAAFlags = set[i].fAAFlags;
+        }
+        fTarget->experimental_DrawImageSetV1(xformedSet.get(), count, filterQuality, mode);
+    }
 
     void onDrawAtlas(const SkImage* atlas, const SkRSXform* xforms, const SkRect* tex,
                      const SkColor* colors, int count, SkBlendMode mode,
                      const SkRect* cull, const SkPaint* paint) override {
         SkSTArray<8, SkColor> xformed;
         if (colors) {
             xformed.reset(count);
             fXformer->apply(xformed.begin(), colors, count);
             colors = xformed.begin();
         }
         fTarget->drawAtlas(prepareImage(atlas).get(), xforms, tex, colors, count, mode, cull,
                            MaybePaint(paint, fXformer.get()));
     }
 
     // TODO: quick reject bitmap draw calls before transforming too?
     void onDrawBitmap(const SkBitmap& bitmap,
                       SkScalar l, SkScalar t,
                       const SkPaint* paint) override {
         if (this->skipXform(bitmap)) {
             return fTarget->drawBitmap(bitmap, l, t, MaybePaint(paint, fXformer.get()));
         }
 
         fTarget->drawImage(fXformer->apply(bitmap).get(), l, t, MaybePaint(paint, fXformer.get()));
     }
     void onDrawBitmapRect(const SkBitmap& bitmap,
                           const SkRect* src, const SkRect& dst,
                           const SkPaint* paint, SrcRectConstraint constraint) override {
         if (this->skipXform(bitmap)) {
             return fTarget->drawBitmapRect(bitmap,
                     src ? *src : SkRect::MakeIWH(bitmap.width(), bitmap.height()), dst,
                     MaybePaint(paint, fXformer.get()), constraint);
         }
 
         fTarget->drawImageRect(fXformer->apply(bitmap).get(),
                                src ? *src : SkRect::MakeIWH(bitmap.width(), bitmap.height()), dst,
                                MaybePaint(paint, fXformer.get()), constraint);
     }
     void onDrawBitmapNine(const SkBitmap& bitmap,
                           const SkIRect& center, const SkRect& dst,
                           const SkPaint* paint) override {
         if (this->skipXform(bitmap)) {
             return fTarget->drawBitmapNine(bitmap, center, dst, MaybePaint(paint, fXformer.get()));
         }
 
         fTarget->drawImageNine(fXformer->apply(bitmap).get(), center, dst,
                                MaybePaint(paint, fXformer.get()));
 
     }
     void onDrawBitmapLattice(const SkBitmap& bitmap,
                              const Lattice& lattice, const SkRect& dst,
                              const SkPaint* paint) override {
         if (this->skipXform(bitmap)) {
             return fTarget->drawBitmapLattice(bitmap, lattice, dst,
                                               MaybePaint(paint, fXformer.get()));
         }
 
         SkSTArray<16, SkColor> colorBuffer;
         int count = lattice.fRectTypes && lattice.fColors?
                     (lattice.fXCount + 1) * (lattice.fYCount + 1) : 0;
         colorBuffer.reset(count);
         fTarget->drawImageLattice(fXformer->apply(bitmap).get(),
                                   fXformer->apply(lattice, colorBuffer.begin(), count), dst,
                                   MaybePaint(paint, fXformer.get()));
     }
     void onDrawShadowRec(const SkPath& path, const SkDrawShadowRec& rec) override {
         SkDrawShadowRec newRec(rec);
         newRec.fAmbientColor = fXformer->apply(rec.fAmbientColor);
         newRec.fSpotColor = fXformer->apply(rec.fSpotColor);
         fTarget->private_draw_shadow_rec(path, newRec);
     }
     void onDrawPicture(const SkPicture* pic,
                        const SkMatrix* matrix,
                        const SkPaint* paint) override {
         SkCanvas::onDrawPicture(pic, matrix, MaybePaint(paint, fXformer.get()));
     }
     void onDrawDrawable(SkDrawable* drawable, const SkMatrix* matrix) override {
         SkCanvas::onDrawDrawable(drawable, matrix);
     }
 
-    void onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                          QuadAAFlags aa, SkColor color, SkBlendMode mode) override {
-        fTarget->experimental_DrawEdgeAAQuad(
-                rect, clip, aa, fXformer->apply(color), mode);
-    }
-    void onDrawEdgeAAImageSet(const ImageSetEntry set[], int count,
-                              const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                              const SkPaint* paint, SrcRectConstraint constraint) override {
-        SkAutoTArray<ImageSetEntry> xformedSet(count);
-        for (int i = 0; i < count; ++i) {
-            xformedSet[i].fImage = this->prepareImage(set[i].fImage.get());
-            xformedSet[i].fSrcRect = set[i].fSrcRect;
-            xformedSet[i].fDstRect = set[i].fDstRect;
-            xformedSet[i].fMatrixIndex = set[i].fMatrixIndex;
-            xformedSet[i].fAlpha = set[i].fAlpha;
-            xformedSet[i].fAAFlags = set[i].fAAFlags;
-            xformedSet[i].fHasClip = set[i].fHasClip;
-        }
-        fTarget->experimental_DrawEdgeAAImageSet(xformedSet.get(), count, dstClips, preViewMatrices,
-                                                 MaybePaint(paint, fXformer.get()), constraint);
-    }
-
     SaveLayerStrategy getSaveLayerStrategy(const SaveLayerRec& rec) override {
         sk_sp<SkImageFilter> backdrop = rec.fBackdrop ? fXformer->apply(rec.fBackdrop) : nullptr;
         sk_sp<SkImage> clipMask = rec.fClipMask ? fXformer->apply(rec.fClipMask) : nullptr;
         fTarget->saveLayer({
             rec.fBounds,
             MaybePaint(rec.fPaint, fXformer.get()),
             backdrop.get(),
             clipMask.get(),
             rec.fClipMatrix,
             rec.fSaveLayerFlags,
         });
         return kNoLayer_SaveLayerStrategy;
     }
 
     // Everything from here on should be uninteresting strictly proxied state-change calls.
     void willSave()    override { fTarget->save(); }
     void willRestore() override { fTarget->restore(); }
 
     void didConcat   (const SkMatrix& m) override { fTarget->concat   (m); }
     void didSetMatrix(const SkMatrix& m) override { fTarget->setMatrix(m); }
 
     void onClipRect(const SkRect& clip, SkClipOp op, ClipEdgeStyle style) override {
         SkCanvas::onClipRect(clip, op, style);
         fTarget->clipRect(clip, op, style);
     }
     void onClipRRect(const SkRRect& clip, SkClipOp op, ClipEdgeStyle style) override {
         SkCanvas::onClipRRect(clip, op, style);
         fTarget->clipRRect(clip, op, style);
     }
     void onClipPath(const SkPath& clip, SkClipOp op, ClipEdgeStyle style) override {
         SkCanvas::onClipPath(clip, op, style);
         fTarget->clipPath(clip, op, style);
     }
     void onClipRegion(const SkRegion& clip, SkClipOp op) override {
         SkCanvas::onClipRegion(clip, op);
         fTarget->clipRegion(clip, op);
     }
 
     void onDrawAnnotation(const SkRect& rect, const char* key, SkData* val) override {
         fTarget->drawAnnotation(rect, key, val);
     }
 
     sk_sp<SkSurface> onNewSurface(const SkImageInfo& info, const SkSurfaceProps& props) override {
         return fTarget->makeSurface(info, &props);
     }
 
     SkISize getBaseLayerSize() const override { return fTarget->getBaseLayerSize(); }
     bool isClipEmpty() const override { return fTarget->isClipEmpty(); }
     bool isClipRect() const override { return fTarget->isClipRect(); }
     bool onPeekPixels(SkPixmap* pixmap) override { return fTarget->peekPixels(pixmap); }
     bool onAccessTopLayerPixels(SkPixmap* pixmap) override {
         SkImageInfo info;
         size_t rowBytes;
         SkIPoint* origin = nullptr;
         void* addr = fTarget->accessTopLayerPixels(&info, &rowBytes, origin);
         if (addr) {
             *pixmap = SkPixmap(info, addr, rowBytes);
             return true;
         }
         return false;
     }
 
     GrContext* getGrContext() override { return fTarget->getGrContext(); }
     bool onGetProps(SkSurfaceProps* props) const override { return fTarget->getProps(props); }
     void onFlush() override { return fTarget->flush(); }
     GrRenderTargetContext* internal_private_accessTopLayerRenderTargetContext() override {
         return fTarget->internal_private_accessTopLayerRenderTargetContext();
     }
diff --git a/src/core/SkDevice.cpp b/src/core/SkDevice.cpp
index a52bd84c63..d44dda8337 100644
--- a/src/core/SkDevice.cpp
+++ b/src/core/SkDevice.cpp
@@ -128,6 +128,16 @@ void SkBaseDevice::drawDRRect(const SkRRect& outer,
     this->drawPath(path, paint, true);
 }
 
+void SkBaseDevice::drawEdgeAARect(const SkRect& r, SkCanvas::QuadAAFlags aa, SkColor color,
+                                  SkBlendMode mode) {
+    SkPaint paint;
+    paint.setColor(color);
+    paint.setBlendMode(mode);
+    paint.setAntiAlias(aa == SkCanvas::kAll_QuadAAFlags);
+
+    this->drawRect(r, paint);
+}
+
 void SkBaseDevice::drawPatch(const SkPoint cubics[12], const SkColor colors[4],
                              const SkPoint texCoords[4], SkBlendMode bmode, const SkPaint& paint) {
     SkISize lod = SkPatchUtils::GetLevelOfDetail(cubics, &this->ctm());
@@ -194,6 +204,22 @@ void SkBaseDevice::drawImageLattice(const SkImage* image,
     }
 }
 
+void SkBaseDevice::drawImageSet(const SkCanvas::ImageSetEntry images[], int count,
+                                SkFilterQuality filterQuality, SkBlendMode mode) {
+    SkPaint paint;
+    paint.setFilterQuality(SkTPin(filterQuality, kNone_SkFilterQuality, kLow_SkFilterQuality));
+    paint.setBlendMode(mode);
+    for (int i = 0; i < count; ++i) {
+        // TODO: Handle per-edge AA. Right now this mirrors the SkiaRenderer component of Chrome
+        // which turns off antialiasing unless all four edges should be antialiased. This avoids
+        // seaming in tiled composited layers.
+        paint.setAntiAlias(images[i].fAAFlags == SkCanvas::kAll_QuadAAFlags);
+        paint.setAlpha(SkToUInt(SkTClamp(SkScalarRoundToInt(images[i].fAlpha * 255), 0, 255)));
+        this->drawImageRect(images[i].fImage.get(), &images[i].fSrcRect, images[i].fDstRect, paint,
+                            SkCanvas::kFast_SrcRectConstraint);
+    }
+}
+
 void SkBaseDevice::drawBitmapLattice(const SkBitmap& bitmap,
                                      const SkCanvas::Lattice& lattice, const SkRect& dst,
                                      const SkPaint& paint) {
@@ -220,99 +246,35 @@ static SkPoint* quad_to_tris(SkPoint tris[6], const SkPoint quad[4]) {
 void SkBaseDevice::drawAtlas(const SkImage* atlas, const SkRSXform xform[],
                              const SkRect tex[], const SkColor colors[], int quadCount,
                              SkBlendMode mode, const SkPaint& paint) {
     const int triCount = quadCount << 1;
     const int vertexCount = triCount * 3;
     uint32_t flags = SkVertices::kHasTexCoords_BuilderFlag;
     if (colors) {
         flags |= SkVertices::kHasColors_BuilderFlag;
     }
     SkVertices::Builder builder(SkVertices::kTriangles_VertexMode, vertexCount, 0, flags);
 
     SkPoint* vPos = builder.positions();
     SkPoint* vTex = builder.texCoords();
     SkColor* vCol = builder.colors();
     for (int i = 0; i < quadCount; ++i) {
         SkPoint tmp[4];
         xform[i].toQuad(tex[i].width(), tex[i].height(), tmp);
         vPos = quad_to_tris(vPos, tmp);
 
         tex[i].toQuad(tmp);
         vTex = quad_to_tris(vTex, tmp);
 
         if (colors) {
             sk_memset32(vCol, colors[i], 6);
             vCol += 6;
         }
     }
     SkPaint p(paint);
     p.setShader(atlas->makeShader());
     this->drawVertices(builder.detach().get(), nullptr, 0, mode, p);
 }
 
-
-void SkBaseDevice::drawEdgeAAQuad(const SkRect& r, const SkPoint clip[4],
-                                  SkCanvas::QuadAAFlags aa, SkColor color, SkBlendMode mode) {
-    SkPaint paint;
-    paint.setColor(color);
-    paint.setBlendMode(mode);
-    paint.setAntiAlias(aa == SkCanvas::kAll_QuadAAFlags);
-
-    if (clip) {
-        // Draw the clip directly as a quad since it's a filled color with no local coords
-        SkPath clipPath;
-        clipPath.addPoly(clip, 4, true);
-        this->drawPath(clipPath, paint);
-    } else {
-        this->drawRect(r, paint);
-    }
-}
-
-void SkBaseDevice::drawEdgeAAImageSet(const SkCanvas::ImageSetEntry images[], int count,
-                                      const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                                      const SkPaint& paint,
-                                      SkCanvas::SrcRectConstraint constraint) {
-    SkASSERT(paint.getStyle() == SkPaint::kFill_Style);
-    SkASSERT(!paint.getPathEffect());
-
-    SkPaint entryPaint = paint;
-    const SkMatrix baseCTM = this->ctm();
-    int clipIndex = 0;
-    for (int i = 0; i < count; ++i) {
-        // TODO: Handle per-edge AA. Right now this mirrors the SkiaRenderer component of Chrome
-        // which turns off antialiasing unless all four edges should be antialiased. This avoids
-        // seaming in tiled composited layers.
-        entryPaint.setAntiAlias(images[i].fAAFlags == SkCanvas::kAll_QuadAAFlags);
-        entryPaint.setAlphaf(paint.getAlphaf() * images[i].fAlpha);
-
-        bool needsRestore = false;
-        SkASSERT(images[i].fMatrixIndex < 0 || preViewMatrices);
-        if (images[i].fMatrixIndex >= 0) {
-            this->save();
-            this->setGlobalCTM(SkMatrix::Concat(
-                    baseCTM, preViewMatrices[images[i].fMatrixIndex]));
-            needsRestore = true;
-        }
-
-        SkASSERT(!images[i].fHasClip || dstClips);
-        if (images[i].fHasClip) {
-            // Since drawImageRect requires a srcRect, the dst clip is implemented as a true clip
-            if (!needsRestore) {
-                this->save();
-                needsRestore = true;
-            }
-            SkPath clipPath;
-            clipPath.addPoly(dstClips + clipIndex, 4, true);
-            this->clipPath(clipPath, SkClipOp::kIntersect, entryPaint.isAntiAlias());
-            clipIndex += 4;
-        }
-        this->drawImageRect(images[i].fImage.get(), &images[i].fSrcRect, images[i].fDstRect,
-                            entryPaint, constraint);
-        if (needsRestore) {
-            this->restore(baseCTM);
-        }
-    }
-}
-
 ///////////////////////////////////////////////////////////////////////////////////////////////////
 
 void SkBaseDevice::drawDrawable(SkDrawable* drawable, const SkMatrix* matrix, SkCanvas* canvas) {
diff --git a/src/core/SkDevice.h b/src/core/SkDevice.h
index 5a0f246ee5..c0796cda69 100644
--- a/src/core/SkDevice.h
+++ b/src/core/SkDevice.h
@@ -129,203 +129,200 @@ public:
 protected:
     enum TileUsage {
         kPossible_TileUsage,    //!< the created device may be drawn tiled
         kNever_TileUsage,       //!< the created device will never be drawn tiled
     };
 
     struct TextFlags {
         uint32_t    fFlags;     // SkPaint::getFlags()
     };
 
     virtual void onSave() {}
     virtual void onRestore() {}
     virtual void onClipRect(const SkRect& rect, SkClipOp, bool aa) {}
     virtual void onClipRRect(const SkRRect& rrect, SkClipOp, bool aa) {}
     virtual void onClipPath(const SkPath& path, SkClipOp, bool aa) {}
     virtual void onClipRegion(const SkRegion& deviceRgn, SkClipOp) {}
     virtual void onSetDeviceClipRestriction(SkIRect* mutableClipRestriction) {}
     virtual bool onClipIsAA() const = 0;
     virtual void onAsRgnClip(SkRegion*) const = 0;
     enum ClipType {
         kEmpty_ClipType,
         kRect_ClipType,
         kComplex_ClipType
     };
     virtual ClipType onGetClipType() const = 0;
 
     /** These are called inside the per-device-layer loop for each draw call.
      When these are called, we have already applied any saveLayer operations,
      and are handling any looping from the paint.
      */
     virtual void drawPaint(const SkPaint& paint) = 0;
     virtual void drawPoints(SkCanvas::PointMode mode, size_t count,
                             const SkPoint[], const SkPaint& paint) = 0;
     virtual void drawRect(const SkRect& r,
                           const SkPaint& paint) = 0;
     virtual void drawRegion(const SkRegion& r,
                             const SkPaint& paint);
     virtual void drawOval(const SkRect& oval,
                           const SkPaint& paint) = 0;
     /** By the time this is called we know that abs(sweepAngle) is in the range [0, 360). */
     virtual void drawArc(const SkRect& oval, SkScalar startAngle,
                          SkScalar sweepAngle, bool useCenter, const SkPaint& paint);
     virtual void drawRRect(const SkRRect& rr,
                            const SkPaint& paint) = 0;
 
     // Default impl calls drawPath()
     virtual void drawDRRect(const SkRRect& outer,
                             const SkRRect& inner, const SkPaint&);
 
+    // Default impl always calls drawRect() with a solid-color paint, setting it to anti-aliased
+    // only when all edge flags are set.
+    virtual void drawEdgeAARect(const SkRect& r, SkCanvas::QuadAAFlags aa, SkColor color,
+                                SkBlendMode mode);
+
     /**
      *  If pathIsMutable, then the implementation is allowed to cast path to a
      *  non-const pointer and modify it in place (as an optimization). Canvas
      *  may do this to implement helpers such as drawOval, by placing a temp
      *  path on the stack to hold the representation of the oval.
      */
     virtual void drawPath(const SkPath& path,
                           const SkPaint& paint,
                           bool pathIsMutable = false) = 0;
     virtual void drawSprite(const SkBitmap& bitmap,
                             int x, int y, const SkPaint& paint) = 0;
 
     /**
      *  The default impl. will create a bitmap-shader from the bitmap,
      *  and call drawRect with it.
      */
     virtual void drawBitmapRect(const SkBitmap&,
                                 const SkRect* srcOrNull, const SkRect& dst,
                                 const SkPaint& paint,
                                 SkCanvas::SrcRectConstraint) = 0;
     virtual void drawBitmapNine(const SkBitmap&, const SkIRect& center,
                                 const SkRect& dst, const SkPaint&);
     virtual void drawBitmapLattice(const SkBitmap&, const SkCanvas::Lattice&,
                                    const SkRect& dst, const SkPaint&);
 
     virtual void drawImageRect(const SkImage*, const SkRect* src, const SkRect& dst,
                                const SkPaint&, SkCanvas::SrcRectConstraint);
     virtual void drawImageNine(const SkImage*, const SkIRect& center,
                                const SkRect& dst, const SkPaint&);
     virtual void drawImageLattice(const SkImage*, const SkCanvas::Lattice&,
                                   const SkRect& dst, const SkPaint&);
 
+    virtual void drawImageSet(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality,
+                              SkBlendMode);
+
     virtual void drawVertices(const SkVertices*, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode, const SkPaint&) = 0;
     virtual void drawShadow(const SkPath&, const SkDrawShadowRec&);
 
     virtual void drawGlyphRunList(const SkGlyphRunList& glyphRunList) = 0;
     // default implementation calls drawVertices
     virtual void drawPatch(const SkPoint cubics[12], const SkColor colors[4],
                            const SkPoint texCoords[4], SkBlendMode, const SkPaint& paint);
 
     // default implementation calls drawPath
     virtual void drawAtlas(const SkImage* atlas, const SkRSXform[], const SkRect[],
                            const SkColor[], int count, SkBlendMode, const SkPaint&);
 
     virtual void drawAnnotation(const SkRect&, const char[], SkData*) {}
 
-    // Default impl always calls drawRect() with a solid-color paint, setting it to anti-aliased
-    // only when all edge flags are set. If there's a clip region, it draws that using drawPath,
-    // or uses clipPath().
-    virtual void drawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                SkCanvas::QuadAAFlags aaFlags, SkColor color, SkBlendMode mode);
-    // Default impl uses drawImageRect per entry, being anti-aliased only when an entry's edge flags
-    // are all set. If there's a clip region, it will be applied using clipPath().
-    virtual void drawEdgeAAImageSet(const SkCanvas::ImageSetEntry[], int count,
-                                    const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                                    const SkPaint& paint, SkCanvas::SrcRectConstraint);
-
     /** The SkDevice passed will be an SkDevice which was returned by a call to
         onCreateDevice on this device with kNeverTile_TileExpectation.
      */
     virtual void drawDevice(SkBaseDevice*, int x, int y, const SkPaint&) = 0;
 
     void drawGlyphRunRSXform(const SkFont&, const SkGlyphID[], const SkRSXform[], int count,
                              SkPoint origin, const SkPaint& paint);
 
     virtual void drawDrawable(SkDrawable*, const SkMatrix*, SkCanvas*);
 
     virtual void drawSpecial(SkSpecialImage*, int x, int y, const SkPaint&,
                              SkImage* clipImage, const SkMatrix& clipMatrix);
     virtual sk_sp<SkSpecialImage> makeSpecial(const SkBitmap&);
     virtual sk_sp<SkSpecialImage> makeSpecial(const SkImage*);
     virtual sk_sp<SkSpecialImage> snapSpecial();
     virtual void setImmutable() {}
 
     bool readPixels(const SkPixmap&, int x, int y);
 
     virtual sk_sp<SkSpecialImage> snapBackImage(const SkIRect&);    // default returns null
 
     ///////////////////////////////////////////////////////////////////////////
 
     virtual GrContext* context() const { return nullptr; }
 
     virtual sk_sp<SkSurface> makeSurface(const SkImageInfo&, const SkSurfaceProps&);
     virtual bool onPeekPixels(SkPixmap*) { return false; }
 
     /**
      *  The caller is responsible for "pre-clipping" the dst. The impl can assume that the dst
      *  image at the specified x,y offset will fit within the device's bounds.
      *
      *  This is explicitly asserted in readPixels(), the public way to call this.
      */
     virtual bool onReadPixels(const SkPixmap&, int x, int y);
 
     /**
      *  The caller is responsible for "pre-clipping" the src. The impl can assume that the src
      *  image at the specified x,y offset will fit within the device's bounds.
      *
      *  This is explicitly asserted in writePixelsDirect(), the public way to call this.
      */
     virtual bool onWritePixels(const SkPixmap&, int x, int y);
 
     virtual bool onAccessPixels(SkPixmap*) { return false; }
 
     struct CreateInfo {
         static SkPixelGeometry AdjustGeometry(const SkImageInfo&, TileUsage, SkPixelGeometry,
                                               bool preserveLCDText);
 
         // The constructor may change the pixel geometry based on other parameters.
         CreateInfo(const SkImageInfo& info,
                    TileUsage tileUsage,
                    SkPixelGeometry geo)
             : fInfo(info)
             , fTileUsage(tileUsage)
             , fPixelGeometry(AdjustGeometry(info, tileUsage, geo, false))
         {}
 
         CreateInfo(const SkImageInfo& info,
                    TileUsage tileUsage,
                    SkPixelGeometry geo,
                    bool preserveLCDText,
                    bool trackCoverage,
                    SkRasterHandleAllocator* allocator)
             : fInfo(info)
             , fTileUsage(tileUsage)
             , fPixelGeometry(AdjustGeometry(info, tileUsage, geo, preserveLCDText))
             , fTrackCoverage(trackCoverage)
             , fAllocator(allocator)
         {}
 
         const SkImageInfo       fInfo;
         const TileUsage         fTileUsage;
         const SkPixelGeometry   fPixelGeometry;
         const bool              fTrackCoverage = false;
         SkRasterHandleAllocator* fAllocator = nullptr;
     };
 
     /**
      *  Create a new device based on CreateInfo. If the paint is not null, then it represents a
      *  preview of how the new device will be composed with its creator device (this).
      *
      *  The subclass may be handed this device in drawDevice(), so it must always return
      *  a device that it knows how to draw, and that it knows how to identify if it is not of the
      *  same subclass (since drawDevice is passed a SkBaseDevice*). If the subclass cannot fulfill
      *  that contract (e.g. PDF cannot support some settings on the paint) it should return NULL,
      *  and the caller may then decide to explicitly create a bitmapdevice, knowing that later
      *  it could not call drawDevice with it (but it could call drawSprite or drawBitmap).
      */
     virtual SkBaseDevice* onCreateDevice(const CreateInfo&, const SkPaint*) {
         return nullptr;
     }
 
     // A helper function used by derived classes to log the scale factor of a bitmap or image draw.
     static void LogDrawScaleFactor(const SkMatrix& view, const SkMatrix& srcToDst, SkFilterQuality);
@@ -333,49 +330,51 @@ protected:
 private:
     friend class SkAndroidFrameworkUtils;
     friend class SkCanvas;
     friend struct DeviceCM; //for setMatrixClip
     friend class SkDraw;
     friend class SkDrawIter;
     friend class SkSurface_Raster;
     friend class DeviceTestingAccess;
 
     // Temporarily friend the SkGlyphRunBuilder until drawPosText is gone.
     friend class SkGlyphRun;
     friend class SkGlyphRunList;
     friend class SkGlyphRunBuilder;
 
+    friend class ClipTileRenderer;  // GM needs context() until API is in SkCanvas
+
     // used to change the backend's pixels (and possibly config/rowbytes)
     // but cannot change the width/height, so there should be no change to
     // any clip information.
     // TODO: move to SkBitmapDevice
     virtual void replaceBitmapBackendForRasterSurface(const SkBitmap&) {}
 
     virtual bool forceConservativeRasterClip() const { return false; }
 
     /**
      * Don't call this!
      */
     virtual GrRenderTargetContext* accessRenderTargetContext() { return nullptr; }
 
     // just called by SkCanvas when built as a layer
     void setOrigin(const SkMatrix& ctm, int x, int y);
 
     /** Causes any deferred drawing to the device to be completed.
      */
     virtual void flush() {}
 
     virtual SkImageFilterCache* getImageFilterCache() { return nullptr; }
 
     friend class SkNoPixelsDevice;
     friend class SkBitmapDevice;
     void privateResize(int w, int h) {
         *const_cast<SkImageInfo*>(&fInfo) = fInfo.makeWH(w, h);
     }
 
     SkIPoint             fOrigin;
     const SkImageInfo    fInfo;
     const SkSurfaceProps fSurfaceProps;
     SkMatrix             fCTM;
 
     typedef SkRefCnt INHERITED;
 };
diff --git a/src/core/SkLiteDL.cpp b/src/core/SkLiteDL.cpp
index 7083a7afaa..1c9c742894 100644
--- a/src/core/SkLiteDL.cpp
+++ b/src/core/SkLiteDL.cpp
@@ -50,430 +50,415 @@ static const D* pod(const T* op, size_t offset = 0) {
 namespace {
 #define TYPES(M)                                                                       \
     M(Flush) M(Save) M(Restore) M(SaveLayer) M(SaveBehind)                             \
     M(Concat) M(SetMatrix) M(Translate)                                                \
     M(ClipPath) M(ClipRect) M(ClipRRect) M(ClipRegion)                                 \
-    M(DrawPaint) M(DrawPath) M(DrawRect)                                               \
+    M(DrawPaint) M(DrawPath) M(DrawRect) M(DrawEdgeAARect)                             \
     M(DrawRegion) M(DrawOval) M(DrawArc)                                               \
     M(DrawRRect) M(DrawDRRect) M(DrawAnnotation) M(DrawDrawable) M(DrawPicture)        \
-    M(DrawImage) M(DrawImageNine) M(DrawImageRect) M(DrawImageLattice)                 \
+    M(DrawImage) M(DrawImageNine) M(DrawImageRect) M(DrawImageLattice) M(DrawImageSet) \
     M(DrawTextBlob)                                                                    \
-    M(DrawPatch) M(DrawPoints) M(DrawVertices) M(DrawAtlas) M(DrawShadowRec)           \
-    M(DrawEdgeAAQuad) M(DrawEdgeAAImageSet)
+    M(DrawPatch) M(DrawPoints) M(DrawVertices) M(DrawAtlas) M(DrawShadowRec)
 
 #define M(T) T,
     enum class Type : uint8_t { TYPES(M) };
 #undef M
 
     struct Op {
         uint32_t type :  8;
         uint32_t skip : 24;
     };
     static_assert(sizeof(Op) == 4, "");
 
     struct Flush final : Op {
         static const auto kType = Type::Flush;
         void draw(SkCanvas* c, const SkMatrix&) const { c->flush(); }
     };
 
     struct Save final : Op {
         static const auto kType = Type::Save;
         void draw(SkCanvas* c, const SkMatrix&) const { c->save(); }
     };
     struct Restore final : Op {
         static const auto kType = Type::Restore;
         void draw(SkCanvas* c, const SkMatrix&) const { c->restore(); }
     };
     struct SaveLayer final : Op {
         static const auto kType = Type::SaveLayer;
         SaveLayer(const SkRect* bounds, const SkPaint* paint,
                   const SkImageFilter* backdrop, const SkImage* clipMask,
                   const SkMatrix* clipMatrix, SkCanvas::SaveLayerFlags flags) {
             if (bounds) { this->bounds = *bounds; }
             if (paint)  { this->paint  = *paint;  }
             this->backdrop = sk_ref_sp(backdrop);
             this->clipMask = sk_ref_sp(clipMask);
             this->clipMatrix = clipMatrix ? *clipMatrix : SkMatrix::I();
             this->flags = flags;
         }
         SkRect                     bounds = kUnset;
         SkPaint                    paint;
         sk_sp<const SkImageFilter> backdrop;
         sk_sp<const SkImage>       clipMask;
         SkMatrix                   clipMatrix;
         SkCanvas::SaveLayerFlags   flags;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->saveLayer({ maybe_unset(bounds), &paint, backdrop.get(), clipMask.get(),
                            clipMatrix.isIdentity() ? nullptr : &clipMatrix, flags });
         }
     };
     struct SaveBehind final : Op {
         static const auto kType = Type::SaveBehind;
         SaveBehind(const SkRect* subset) {
             if (subset) { this->subset = *subset; }
         }
         SkRect  subset = kUnset;
         void draw(SkCanvas* c, const SkMatrix&) const {
             SkCanvasPriv::SaveBehind(c, maybe_unset(subset));
         }
     };
     struct Concat final : Op {
         static const auto kType = Type::Concat;
         Concat(const SkMatrix& matrix) : matrix(matrix) {}
         SkMatrix matrix;
         void draw(SkCanvas* c, const SkMatrix&) const { c->concat(matrix); }
     };
     struct SetMatrix final : Op {
         static const auto kType = Type::SetMatrix;
         SetMatrix(const SkMatrix& matrix) : matrix(matrix) {}
         SkMatrix matrix;
         void draw(SkCanvas* c, const SkMatrix& original) const {
             c->setMatrix(SkMatrix::Concat(original, matrix));
         }
     };
     struct Translate final : Op {
         static const auto kType = Type::Translate;
         Translate(SkScalar dx, SkScalar dy) : dx(dx), dy(dy) {}
         SkScalar dx,dy;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->translate(dx, dy);
         }
     };
 
     struct ClipPath final : Op {
         static const auto kType = Type::ClipPath;
         ClipPath(const SkPath& path, SkClipOp op, bool aa) : path(path), op(op), aa(aa) {}
         SkPath   path;
         SkClipOp op;
         bool     aa;
         void draw(SkCanvas* c, const SkMatrix&) const { c->clipPath(path, op, aa); }
     };
     struct ClipRect final : Op {
         static const auto kType = Type::ClipRect;
         ClipRect(const SkRect& rect, SkClipOp op, bool aa) : rect(rect), op(op), aa(aa) {}
         SkRect   rect;
         SkClipOp op;
         bool     aa;
         void draw(SkCanvas* c, const SkMatrix&) const { c->clipRect(rect, op, aa); }
     };
     struct ClipRRect final : Op {
         static const auto kType = Type::ClipRRect;
         ClipRRect(const SkRRect& rrect, SkClipOp op, bool aa) : rrect(rrect), op(op), aa(aa) {}
         SkRRect  rrect;
         SkClipOp op;
         bool     aa;
         void draw(SkCanvas* c, const SkMatrix&) const { c->clipRRect(rrect, op, aa); }
     };
     struct ClipRegion final : Op {
         static const auto kType = Type::ClipRegion;
         ClipRegion(const SkRegion& region, SkClipOp op) : region(region), op(op) {}
         SkRegion region;
         SkClipOp op;
         void draw(SkCanvas* c, const SkMatrix&) const { c->clipRegion(region, op); }
     };
 
     struct DrawPaint final : Op {
         static const auto kType = Type::DrawPaint;
         DrawPaint(const SkPaint& paint) : paint(paint) {}
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const { c->drawPaint(paint); }
     };
     struct DrawPath final : Op {
         static const auto kType = Type::DrawPath;
         DrawPath(const SkPath& path, const SkPaint& paint) : path(path), paint(paint) {}
         SkPath  path;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const { c->drawPath(path, paint); }
     };
     struct DrawRect final : Op {
         static const auto kType = Type::DrawRect;
         DrawRect(const SkRect& rect, const SkPaint& paint) : rect(rect), paint(paint) {}
         SkRect  rect;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const { c->drawRect(rect, paint); }
     };
+    struct DrawEdgeAARect final : Op {
+        static const auto kType = Type::DrawEdgeAARect;
+        DrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa, SkColor color,
+                       SkBlendMode mode)
+            : rect(rect), aa(aa), color(color), mode(mode) {}
+        SkRect rect;
+        SkCanvas::QuadAAFlags aa;
+        SkColor color;
+        SkBlendMode mode;
+        void draw(SkCanvas* c, const SkMatrix&) const {
+            c->experimental_DrawEdgeAARectV1(rect, aa, color, mode);
+        }
+    };
     struct DrawRegion final : Op {
         static const auto kType = Type::DrawRegion;
         DrawRegion(const SkRegion& region, const SkPaint& paint) : region(region), paint(paint) {}
         SkRegion region;
         SkPaint  paint;
         void draw(SkCanvas* c, const SkMatrix&) const { c->drawRegion(region, paint); }
     };
     struct DrawOval final : Op {
         static const auto kType = Type::DrawOval;
         DrawOval(const SkRect& oval, const SkPaint& paint) : oval(oval), paint(paint) {}
         SkRect  oval;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const { c->drawOval(oval, paint); }
     };
     struct DrawArc final : Op {
         static const auto kType = Type::DrawArc;
         DrawArc(const SkRect& oval, SkScalar startAngle, SkScalar sweepAngle, bool useCenter,
                 const SkPaint& paint)
             : oval(oval), startAngle(startAngle), sweepAngle(sweepAngle), useCenter(useCenter)
             , paint(paint) {}
         SkRect  oval;
         SkScalar startAngle;
         SkScalar sweepAngle;
         bool useCenter;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const { c->drawArc(oval, startAngle, sweepAngle,
                                                                    useCenter, paint); }
     };
     struct DrawRRect final : Op {
         static const auto kType = Type::DrawRRect;
         DrawRRect(const SkRRect& rrect, const SkPaint& paint) : rrect(rrect), paint(paint) {}
         SkRRect rrect;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const { c->drawRRect(rrect, paint); }
     };
     struct DrawDRRect final : Op {
         static const auto kType = Type::DrawDRRect;
         DrawDRRect(const SkRRect& outer, const SkRRect& inner, const SkPaint& paint)
             : outer(outer), inner(inner), paint(paint) {}
         SkRRect outer, inner;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const { c->drawDRRect(outer, inner, paint); }
     };
 
     struct DrawAnnotation final : Op {
         static const auto kType = Type::DrawAnnotation;
         DrawAnnotation(const SkRect& rect, SkData* value) : rect(rect), value(sk_ref_sp(value)) {}
         SkRect        rect;
         sk_sp<SkData> value;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->drawAnnotation(rect, pod<char>(this), value.get());
         }
     };
     struct DrawDrawable final : Op {
         static const auto kType = Type::DrawDrawable;
         DrawDrawable(SkDrawable* drawable, const SkMatrix* matrix) : drawable(sk_ref_sp(drawable)) {
             if (matrix) { this->matrix = *matrix; }
         }
         sk_sp<SkDrawable> drawable;
         SkMatrix          matrix = SkMatrix::I();
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->drawDrawable(drawable.get(), &matrix);
         }
     };
     struct DrawPicture final : Op {
         static const auto kType = Type::DrawPicture;
         DrawPicture(const SkPicture* picture, const SkMatrix* matrix, const SkPaint* paint)
             : picture(sk_ref_sp(picture)) {
             if (matrix) { this->matrix = *matrix; }
             if (paint)  { this->paint  = *paint; has_paint = true; }
         }
         sk_sp<const SkPicture> picture;
         SkMatrix               matrix = SkMatrix::I();
         SkPaint                paint;
         bool                   has_paint = false;  // TODO: why is a default paint not the same?
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->drawPicture(picture.get(), &matrix, has_paint ? &paint : nullptr);
         }
     };
 
     struct DrawImage final : Op {
         static const auto kType = Type::DrawImage;
         DrawImage(sk_sp<const SkImage>&& image, SkScalar x, SkScalar y, const SkPaint* paint)
             : image(std::move(image)), x(x), y(y) {
             if (paint) { this->paint = *paint; }
         }
         sk_sp<const SkImage> image;
         SkScalar x,y;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const { c->drawImage(image.get(), x,y, &paint); }
     };
     struct DrawImageNine final : Op {
         static const auto kType = Type::DrawImageNine;
         DrawImageNine(sk_sp<const SkImage>&& image,
                       const SkIRect& center, const SkRect& dst, const SkPaint* paint)
             : image(std::move(image)), center(center), dst(dst) {
             if (paint) { this->paint = *paint; }
         }
         sk_sp<const SkImage> image;
         SkIRect center;
         SkRect  dst;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->drawImageNine(image.get(), center, dst, &paint);
         }
     };
     struct DrawImageRect final : Op {
         static const auto kType = Type::DrawImageRect;
         DrawImageRect(sk_sp<const SkImage>&& image, const SkRect* src, const SkRect& dst,
                       const SkPaint* paint, SkCanvas::SrcRectConstraint constraint)
             : image(std::move(image)), dst(dst), constraint(constraint) {
             this->src = src ? *src : SkRect::MakeIWH(this->image->width(), this->image->height());
             if (paint) { this->paint = *paint; }
         }
         sk_sp<const SkImage> image;
         SkRect src, dst;
         SkPaint paint;
         SkCanvas::SrcRectConstraint constraint;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->drawImageRect(image.get(), src, dst, &paint, constraint);
         }
     };
     struct DrawImageLattice final : Op {
         static const auto kType = Type::DrawImageLattice;
         DrawImageLattice(sk_sp<const SkImage>&& image, int xs, int ys, int fs,
                          const SkIRect& src, const SkRect& dst, const SkPaint* paint)
             : image(std::move(image)), xs(xs), ys(ys), fs(fs), src(src), dst(dst) {
             if (paint) { this->paint = *paint; }
         }
         sk_sp<const SkImage> image;
         int                  xs, ys, fs;
         SkIRect              src;
         SkRect               dst;
         SkPaint              paint;
         void draw(SkCanvas* c, const SkMatrix&) const {
             auto xdivs = pod<int>(this, 0),
                  ydivs = pod<int>(this, xs*sizeof(int));
             auto colors = (0 == fs) ? nullptr :
                           pod<SkColor>(this, (xs+ys)*sizeof(int));
             auto flags = (0 == fs) ? nullptr :
                          pod<SkCanvas::Lattice::RectType>(this, (xs+ys)*sizeof(int)+
                                                           fs*sizeof(SkColor));
             c->drawImageLattice(image.get(), {xdivs, ydivs, flags, xs, ys, &src, colors}, dst,
                                 &paint);
         }
     };
+    struct DrawImageSet final : Op {
+        static const auto kType = Type::DrawImageSet;
+        DrawImageSet(const SkCanvas::ImageSetEntry set[], int count, SkFilterQuality quality,
+                     SkBlendMode xfermode)
+                : count(count), quality(quality), xfermode(xfermode), set(count) {
+            std::copy_n(set, count, this->set.get());
+        }
+        int                                   count;
+        SkFilterQuality                       quality;
+        SkBlendMode                           xfermode;
+        SkAutoTArray<SkCanvas::ImageSetEntry> set;
+        void draw(SkCanvas* c, const SkMatrix&) const {
+            c->experimental_DrawImageSetV1(set.get(), count, quality, xfermode);
+        }
+    };
     struct DrawTextBlob final : Op {
         static const auto kType = Type::DrawTextBlob;
         DrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y, const SkPaint& paint)
             : blob(sk_ref_sp(blob)), x(x), y(y), paint(paint) {}
         sk_sp<const SkTextBlob> blob;
         SkScalar x,y;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->drawTextBlob(blob.get(), x,y, paint);
         }
     };
 
     struct DrawPatch final : Op {
         static const auto kType = Type::DrawPatch;
         DrawPatch(const SkPoint cubics[12], const SkColor colors[4], const SkPoint texs[4],
                   SkBlendMode bmode, const SkPaint& paint)
             : xfermode(bmode), paint(paint)
         {
             copy_v(this->cubics, cubics, 12);
             if (colors) { copy_v(this->colors, colors, 4); has_colors = true; }
             if (texs  ) { copy_v(this->texs  , texs  , 4); has_texs   = true; }
         }
         SkPoint           cubics[12];
         SkColor           colors[4];
         SkPoint           texs[4];
         SkBlendMode       xfermode;
         SkPaint           paint;
         bool              has_colors = false;
         bool              has_texs   = false;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->drawPatch(cubics, has_colors ? colors : nullptr, has_texs ? texs : nullptr,
                          xfermode, paint);
         }
     };
     struct DrawPoints final : Op {
         static const auto kType = Type::DrawPoints;
         DrawPoints(SkCanvas::PointMode mode, size_t count, const SkPaint& paint)
             : mode(mode), count(count), paint(paint) {}
         SkCanvas::PointMode mode;
         size_t              count;
         SkPaint             paint;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->drawPoints(mode, count, pod<SkPoint>(this), paint);
         }
     };
     struct DrawVertices final : Op {
         static const auto kType = Type::DrawVertices;
         DrawVertices(const SkVertices* v, int bc, SkBlendMode m, const SkPaint& p)
             : vertices(sk_ref_sp(const_cast<SkVertices*>(v)))
             , boneCount(bc)
             , mode(m)
             , paint(p) {}
         sk_sp<SkVertices> vertices;
         int boneCount;
         SkBlendMode mode;
         SkPaint paint;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->drawVertices(vertices, pod<SkVertices::Bone>(this), boneCount, mode, paint);
         }
     };
     struct DrawAtlas final : Op {
         static const auto kType = Type::DrawAtlas;
         DrawAtlas(const SkImage* atlas, int count, SkBlendMode xfermode,
                   const SkRect* cull, const SkPaint* paint, bool has_colors)
             : atlas(sk_ref_sp(atlas)), count(count), xfermode(xfermode), has_colors(has_colors) {
             if (cull)  { this->cull  = *cull; }
             if (paint) { this->paint = *paint; }
         }
         sk_sp<const SkImage> atlas;
         int                  count;
         SkBlendMode          xfermode;
         SkRect               cull = kUnset;
         SkPaint              paint;
         bool                 has_colors;
         void draw(SkCanvas* c, const SkMatrix&) const {
             auto xforms = pod<SkRSXform>(this, 0);
             auto   texs = pod<SkRect>(this, count*sizeof(SkRSXform));
             auto colors = has_colors
                 ? pod<SkColor>(this, count*(sizeof(SkRSXform) + sizeof(SkRect)))
                 : nullptr;
             c->drawAtlas(atlas.get(), xforms, texs, colors, count, xfermode,
                          maybe_unset(cull), &paint);
         }
     };
     struct DrawShadowRec final : Op {
         static const auto kType = Type::DrawShadowRec;
         DrawShadowRec(const SkPath& path, const SkDrawShadowRec& rec)
             : fPath(path), fRec(rec)
         {}
         SkPath          fPath;
         SkDrawShadowRec fRec;
         void draw(SkCanvas* c, const SkMatrix&) const {
             c->private_draw_shadow_rec(fPath, fRec);
         }
     };
-
-    struct DrawEdgeAAQuad final : Op {
-        static const auto kType = Type::DrawEdgeAAQuad;
-        DrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                       SkCanvas::QuadAAFlags aa, SkColor color, SkBlendMode mode)
-            : rect(rect), hasClip(clip != nullptr), aa(aa), color(color), mode(mode) {
-                if (clip) {
-                    for (int i = 0; i < 4; ++i) {
-                        this->clip[i] = clip[i];
-                    }
-                }
-            }
-        SkRect rect;
-        SkPoint clip[4];
-        bool hasClip;
-        SkCanvas::QuadAAFlags aa;
-        SkColor color;
-        SkBlendMode mode;
-        void draw(SkCanvas* c, const SkMatrix&) const {
-            c->experimental_DrawEdgeAAQuad(rect, hasClip ? clip : nullptr, aa, color, mode);
-        }
-    };
-    struct DrawEdgeAAImageSet final : Op {
-        static const auto kType = Type::DrawEdgeAAImageSet;
-        DrawEdgeAAImageSet(const SkCanvas::ImageSetEntry set[], int count, int dstClipCount,
-                     const SkPaint* paint, SkCanvas::SrcRectConstraint constraint)
-                : count(count), set(count), dstClipCount(dstClipCount), constraint(constraint) {
-            std::copy_n(set, count, this->set.get());
-            if (paint) { this->paint = *paint; }
-        }
-        int count;
-        SkAutoTArray<SkCanvas::ImageSetEntry> set;
-        int dstClipCount;
-        SkPaint paint;
-        SkCanvas::SrcRectConstraint constraint;
-        void draw(SkCanvas* c, const SkMatrix&) const {
-            auto dstClips = pod<SkPoint>(this);
-            auto preViewMatrices = pod<SkMatrix>(this, dstClipCount * sizeof(SkPoint));
-            c->experimental_DrawEdgeAAImageSet(
-                    set.get(), count, dstClips, preViewMatrices, &paint, constraint);
-        }
-    };
 }
 
 template <typename T, typename... Args>
@@ -548,6 +533,10 @@ void SkLiteDL::drawPath(const SkPath& path, const SkPaint& paint) {
 void SkLiteDL::drawRect(const SkRect& rect, const SkPaint& paint) {
     this->push<DrawRect>(0, rect, paint);
 }
+void SkLiteDL::drawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa, SkColor color,
+                              SkBlendMode mode) {
+    this->push<DrawEdgeAARect>(0, rect, aa, color, mode);
+}
 void SkLiteDL::drawRegion(const SkRegion& region, const SkPaint& paint) {
     this->push<DrawRegion>(0, region, paint);
 }
@@ -603,6 +592,11 @@ void SkLiteDL::drawImageLattice(sk_sp<const SkImage> image, const SkCanvas::Latt
                 lattice.fRectTypes, fs);
 }
 
+void SkLiteDL::drawImageSet(const SkCanvas::ImageSetEntry set[], int count,
+                            SkFilterQuality filterQuality, SkBlendMode mode) {
+    this->push<DrawImageSet>(0, set, count, filterQuality, mode);
+}
+
 void SkLiteDL::drawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y, const SkPaint& paint) {
     this->push<DrawTextBlob>(0, blob, x,y, paint);
 }
@@ -642,24 +636,6 @@ void SkLiteDL::drawShadowRec(const SkPath& path, const SkDrawShadowRec& rec) {
     this->push<DrawShadowRec>(0, path, rec);
 }
 
-void SkLiteDL::drawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                              SkCanvas::QuadAAFlags aa, SkColor color, SkBlendMode mode) {
-    this->push<DrawEdgeAAQuad>(0, rect, clip, aa, color, mode);
-}
-
-void SkLiteDL::drawEdgeAAImageSet(const SkCanvas::ImageSetEntry set[], int count,
-                            const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                            const SkPaint* paint, SkCanvas::SrcRectConstraint constraint) {
-    int totalDstClipCount, totalMatrixCount;
-    SkCanvasPriv::GetDstClipAndMatrixCounts(set, count, &totalDstClipCount, &totalMatrixCount);
-
-    size_t bytes = totalDstClipCount * sizeof(SkPoint) + totalMatrixCount * sizeof(SkMatrix);
-    void* pod = this->push<DrawEdgeAAImageSet>(
-            bytes, set, count, totalDstClipCount, paint, constraint);
-    copy_v(pod, dstClips, totalDstClipCount,
-           preViewMatrices, totalMatrixCount);
-}
-
 typedef void(*draw_fn)(const void*,  SkCanvas*, const SkMatrix&);
 typedef void(*void_fn)(const void*);
 
diff --git a/src/core/SkLiteDL.h b/src/core/SkLiteDL.h
index ea9a5fa2b5..a6041bc2d6 100644
--- a/src/core/SkLiteDL.h
+++ b/src/core/SkLiteDL.h
@@ -20,66 +20,62 @@ class SkLiteDL final {
 public:
     ~SkLiteDL();
 
     void draw(SkCanvas* canvas) const;
 
     void reset();
     bool empty() const { return fUsed == 0; }
 
     void flush();
 
     void save();
     void saveLayer(const SkRect*, const SkPaint*, const SkImageFilter*, const SkImage*,
                    const SkMatrix*, SkCanvas::SaveLayerFlags);
     void saveBehind(const SkRect*);
     void restore();
 
     void    concat (const SkMatrix&);
     void setMatrix (const SkMatrix&);
     void translate(SkScalar, SkScalar);
     void translateZ(SkScalar);
 
     void clipPath  (const   SkPath&, SkClipOp, bool aa);
     void clipRect  (const   SkRect&, SkClipOp, bool aa);
     void clipRRect (const  SkRRect&, SkClipOp, bool aa);
     void clipRegion(const SkRegion&, SkClipOp);
 
     void drawPaint (const SkPaint&);
     void drawPath  (const SkPath&, const SkPaint&);
     void drawRect  (const SkRect&, const SkPaint&);
+    void drawEdgeAARect(const SkRect&, SkCanvas::QuadAAFlags, SkColor, SkBlendMode);
     void drawRegion(const SkRegion&, const SkPaint&);
     void drawOval  (const SkRect&, const SkPaint&);
     void drawArc   (const SkRect&, SkScalar, SkScalar, bool, const SkPaint&);
     void drawRRect (const SkRRect&, const SkPaint&);
     void drawDRRect(const SkRRect&, const SkRRect&, const SkPaint&);
 
     void drawAnnotation     (const SkRect&, const char*, SkData*);
     void drawDrawable       (SkDrawable*, const SkMatrix*);
     void drawPicture        (const SkPicture*, const SkMatrix*, const SkPaint*);
 
     void drawTextBlob   (const SkTextBlob*, SkScalar,SkScalar, const SkPaint&);
 
     void drawImage    (sk_sp<const SkImage>, SkScalar,SkScalar,             const SkPaint*);
     void drawImageNine(sk_sp<const SkImage>, const SkIRect&, const SkRect&, const SkPaint*);
     void drawImageRect(sk_sp<const SkImage>, const SkRect*, const SkRect&,  const SkPaint*,
                        SkCanvas::SrcRectConstraint);
     void drawImageLattice(sk_sp<const SkImage>, const SkCanvas::Lattice&,
                           const SkRect&, const SkPaint*);
+    void drawImageSet(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality, SkBlendMode);
 
     void drawPatch(const SkPoint[12], const SkColor[4], const SkPoint[4],
                    SkBlendMode, const SkPaint&);
     void drawPoints(SkCanvas::PointMode, size_t, const SkPoint[], const SkPaint&);
     void drawVertices(const SkVertices*, const SkVertices::Bone bones[], int boneCount, SkBlendMode,
                       const SkPaint&);
     void drawAtlas(const SkImage*, const SkRSXform[], const SkRect[], const SkColor[], int,
                    SkBlendMode, const SkRect*, const SkPaint*);
     void drawShadowRec(const SkPath&, const SkDrawShadowRec&);
 
-    void drawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4], SkCanvas::QuadAAFlags aaFlags,
-                        SkColor color, SkBlendMode mode);
-    void drawEdgeAAImageSet(const SkCanvas::ImageSetEntry[], int count, const SkPoint dstClips[],
-                            const SkMatrix preViewMatrices[], const SkPaint* paint,
-                            SkCanvas::SrcRectConstraint constraint);
-
 private:
     template <typename T, typename... Args>
     void* push(size_t, Args&&...);
diff --git a/src/core/SkLiteRecorder.cpp b/src/core/SkLiteRecorder.cpp
index f95dc34be2..6dda8d6fa9 100644
--- a/src/core/SkLiteRecorder.cpp
+++ b/src/core/SkLiteRecorder.cpp
@@ -66,6 +66,10 @@ void SkLiteRecorder::onDrawPath(const SkPath& path, const SkPaint& paint) {
 void SkLiteRecorder::onDrawRect(const SkRect& rect, const SkPaint& paint) {
     fDL->drawRect(rect, paint);
 }
+void SkLiteRecorder::onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa, SkColor color,
+                                      SkBlendMode mode) {
+    fDL->drawEdgeAARect(rect, aa, color, mode);
+}
 void SkLiteRecorder::onDrawRegion(const SkRegion& region, const SkPaint& paint) {
     fDL->drawRegion(region, paint);
 }
@@ -143,6 +147,11 @@ void SkLiteRecorder::onDrawImageLattice(const SkImage* img,
     fDL->drawImageLattice(sk_ref_sp(img), lattice, dst, paint);
 }
 
+void SkLiteRecorder::onDrawImageSet(const ImageSetEntry set[], int count,
+                                    SkFilterQuality filterQuality, SkBlendMode mode) {
+    fDL->drawImageSet(set, count, filterQuality, mode);
+}
+
 void SkLiteRecorder::onDrawPatch(const SkPoint cubics[12],
                                  const SkColor colors[4], const SkPoint texCoords[4],
                                  SkBlendMode bmode, const SkPaint& paint) {
@@ -162,23 +171,12 @@ void SkLiteRecorder::onDrawAtlas(const SkImage* atlas,
                                  const SkRSXform xforms[],
                                  const SkRect texs[],
                                  const SkColor colors[],
                                  int count,
                                  SkBlendMode bmode,
                                  const SkRect* cull,
                                  const SkPaint* paint) {
     fDL->drawAtlas(atlas, xforms, texs, colors, count, bmode, cull, paint);
 }
 void SkLiteRecorder::onDrawShadowRec(const SkPath& path, const SkDrawShadowRec& rec) {
     fDL->drawShadowRec(path, rec);
 }
-
-void SkLiteRecorder::onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                      QuadAAFlags aaFlags, SkColor color, SkBlendMode mode) {
-  fDL->drawEdgeAAQuad(rect, clip, aaFlags, color, mode);
-}
-void SkLiteRecorder::onDrawEdgeAAImageSet(const ImageSetEntry set[], int count,
-                                          const SkPoint dstClips[],
-                                          const SkMatrix preViewMatrices[], const SkPaint* paint,
-                                          SkCanvas::SrcRectConstraint constraint) {
-  fDL->drawEdgeAAImageSet(set, count, dstClips, preViewMatrices, paint, constraint);
-}
diff --git a/src/core/SkLiteRecorder.h b/src/core/SkLiteRecorder.h
index 7b54f89716..81eedb341c 100644
--- a/src/core/SkLiteRecorder.h
+++ b/src/core/SkLiteRecorder.h
@@ -17,67 +17,64 @@ class SkLiteRecorder final : public SkCanvasVirtualEnforcer<SkNoDrawCanvas> {
 public:
     SkLiteRecorder();
     void reset(SkLiteDL*, const SkIRect& bounds);
 
     sk_sp<SkSurface> onNewSurface(const SkImageInfo&, const SkSurfaceProps&) override;
 
     void willSave() override;
     SaveLayerStrategy getSaveLayerStrategy(const SaveLayerRec&) override;
     bool onDoSaveBehind(const SkRect*) override;
     void willRestore() override;
 
     void onFlush() override;
 
     void didConcat(const SkMatrix&) override;
     void didSetMatrix(const SkMatrix&) override;
     void didTranslate(SkScalar, SkScalar) override;
 
     void onClipRect  (const   SkRect&, SkClipOp, ClipEdgeStyle) override;
     void onClipRRect (const  SkRRect&, SkClipOp, ClipEdgeStyle) override;
     void onClipPath  (const   SkPath&, SkClipOp, ClipEdgeStyle) override;
     void onClipRegion(const SkRegion&, SkClipOp) override;
 
     void onDrawPaint (const SkPaint&) override;
     void onDrawPath  (const SkPath&, const SkPaint&) override;
     void onDrawRect  (const SkRect&, const SkPaint&) override;
+    void onDrawEdgeAARect(const SkRect&, SkCanvas::QuadAAFlags, SkColor, SkBlendMode) override;
     void onDrawRegion(const SkRegion&, const SkPaint&) override;
     void onDrawOval  (const SkRect&, const SkPaint&) override;
     void onDrawArc(const SkRect&, SkScalar, SkScalar, bool, const SkPaint&) override;
     void onDrawRRect (const SkRRect&, const SkPaint&) override;
     void onDrawDRRect(const SkRRect&, const SkRRect&, const SkPaint&) override;
 
     void onDrawDrawable(SkDrawable*, const SkMatrix*) override;
     void onDrawPicture(const SkPicture*, const SkMatrix*, const SkPaint*) override;
     void onDrawAnnotation(const SkRect&, const char[], SkData*) override;
 
     void onDrawTextBlob(const SkTextBlob*, SkScalar, SkScalar, const SkPaint&) override;
 
     void onDrawBitmap(const SkBitmap&, SkScalar, SkScalar, const SkPaint*) override;
     void onDrawBitmapLattice(const SkBitmap&, const Lattice&, const SkRect&,
                              const SkPaint*) override;
     void onDrawBitmapNine(const SkBitmap&, const SkIRect&, const SkRect&, const SkPaint*) override;
     void onDrawBitmapRect(const SkBitmap&, const SkRect*, const SkRect&, const SkPaint*,
                           SrcRectConstraint) override;
 
     void onDrawImage(const SkImage*, SkScalar, SkScalar, const SkPaint*) override;
     void onDrawImageLattice(const SkImage*, const Lattice&, const SkRect&, const SkPaint*) override;
     void onDrawImageNine(const SkImage*, const SkIRect&, const SkRect&, const SkPaint*) override;
     void onDrawImageRect(const SkImage*, const SkRect*, const SkRect&, const SkPaint*,
                          SrcRectConstraint) override;
+    void onDrawImageSet(const ImageSetEntry[], int count, SkFilterQuality, SkBlendMode) override;
 
     void onDrawPatch(const SkPoint[12], const SkColor[4],
                      const SkPoint[4], SkBlendMode, const SkPaint&) override;
     void onDrawPoints(PointMode, size_t count, const SkPoint pts[], const SkPaint&) override;
     void onDrawVerticesObject(const SkVertices*, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode, const SkPaint&) override;
     void onDrawAtlas(const SkImage*, const SkRSXform[], const SkRect[], const SkColor[],
                      int, SkBlendMode, const SkRect*, const SkPaint*) override;
     void onDrawShadowRec(const SkPath&, const SkDrawShadowRec&) override;
 
-    void onDrawEdgeAAQuad(const SkRect&, const SkPoint[4], QuadAAFlags, SkColor,
-                          SkBlendMode) override;
-    void onDrawEdgeAAImageSet(const ImageSetEntry[], int count, const SkPoint[], const SkMatrix[],
-                              const SkPaint*, SrcRectConstraint) override;
-
 private:
     typedef SkCanvasVirtualEnforcer<SkNoDrawCanvas> INHERITED;
 
diff --git a/src/core/SkOverdrawCanvas.cpp b/src/core/SkOverdrawCanvas.cpp
index ef611cd69e..a7b39bbb66 100644
--- a/src/core/SkOverdrawCanvas.cpp
+++ b/src/core/SkOverdrawCanvas.cpp
@@ -117,6 +117,11 @@ void SkOverdrawCanvas::onDrawRect(const SkRect& rect, const SkPaint& paint) {
     fList[0]->onDrawRect(rect, this->overdrawPaint(paint));
 }
 
+void SkOverdrawCanvas::onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa, SkColor color,
+                                        SkBlendMode mode) {
+    fList[0]->onDrawRect(rect, fPaint);
+}
+
 void SkOverdrawCanvas::onDrawRegion(const SkRegion& region, const SkPaint& paint) {
     fList[0]->onDrawRegion(region, this->overdrawPaint(paint));
 }
@@ -206,6 +211,13 @@ void SkOverdrawCanvas::onDrawImageLattice(const SkImage* image, const Lattice& l
     }
 }
 
+void SkOverdrawCanvas::onDrawImageSet(const ImageSetEntry set[], int count, SkFilterQuality,
+                                      SkBlendMode) {
+    for (int i = 0; i < count; ++i) {
+        fList[0]->onDrawRect(set[i].fDstRect, fPaint);
+    }
+}
+
 void SkOverdrawCanvas::onDrawBitmap(const SkBitmap& bitmap, SkScalar x, SkScalar y,
                                     const SkPaint*) {
     fList[0]->onDrawRect(SkRect::MakeXYWH(x, y, bitmap.width(), bitmap.height()), fPaint);
@@ -244,41 +256,6 @@ void SkOverdrawCanvas::onDrawShadowRec(const SkPath& path, const SkDrawShadowRec
     fList[0]->onDrawRect(bounds, fPaint);
 }
 
-void SkOverdrawCanvas::onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                        QuadAAFlags aa, SkColor color, SkBlendMode mode) {
-    if (clip) {
-        SkPath path;
-        path.addPoly(clip, 4, true);
-        fList[0]->onDrawPath(path, fPaint);
-    } else {
-        fList[0]->onDrawRect(rect, fPaint);
-    }
-}
-
-void SkOverdrawCanvas::onDrawEdgeAAImageSet(const ImageSetEntry set[], int count,
-                                            const SkPoint dstClips[],
-                                            const SkMatrix preViewMatrices[], const SkPaint* paint,
-                                            SrcRectConstraint constraint) {
-    int clipIndex = 0;
-    for (int i = 0; i < count; ++i) {
-        if (set[i].fMatrixIndex >= 0) {
-            fList[0]->save();
-            fList[0]->concat(preViewMatrices[set[i].fMatrixIndex]);
-        }
-        if (set[i].fHasClip) {
-            SkPath path;
-            path.addPoly(dstClips + clipIndex, 4, true);
-            clipIndex += 4;
-            fList[0]->onDrawPath(path, fPaint);
-        } else {
-            fList[0]->onDrawRect(set[i].fDstRect, fPaint);
-        }
-        if (set[i].fMatrixIndex >= 0) {
-            fList[0]->restore();
-        }
-    }
-}
-
 inline SkPaint SkOverdrawCanvas::overdrawPaint(const SkPaint& paint) {
     SkPaint newPaint = fPaint;
     newPaint.setStyle(paint.getStyle());
diff --git a/src/core/SkPictureFlat.h b/src/core/SkPictureFlat.h
index 34e4dfb11d..de1c269485 100644
--- a/src/core/SkPictureFlat.h
+++ b/src/core/SkPictureFlat.h
@@ -19,91 +19,91 @@
 /*
  * Note: While adding new DrawTypes, it is necessary to add to the end of this list
  *       and update LAST_DRAWTYPE_ENUM to avoid having the code read older skps wrong.
  *       (which can cause segfaults)
  *
  *       Reordering can be done during version updates.
  */
 enum DrawType {
     UNUSED,
     CLIP_PATH,
     CLIP_REGION,
     CLIP_RECT,
     CLIP_RRECT,
     CONCAT,
     DRAW_BITMAP_RETIRED_2016_REMOVED_2018,
     DRAW_BITMAP_MATRIX_RETIRED_2016_REMOVED_2018,
     DRAW_BITMAP_NINE_RETIRED_2016_REMOVED_2018,
     DRAW_BITMAP_RECT_RETIRED_2016_REMOVED_2018,
     DRAW_CLEAR,
     DRAW_DATA,
     DRAW_OVAL,
     DRAW_PAINT,
     DRAW_PATH,
     DRAW_PICTURE,
     DRAW_POINTS,
     DRAW_POS_TEXT_REMOVED_1_2019,
     DRAW_POS_TEXT_TOP_BOTTOM_REMOVED_1_2019,
     DRAW_POS_TEXT_H_REMOVED_1_2019,
     DRAW_POS_TEXT_H_TOP_BOTTOM_REMOVED_1_2019,
     DRAW_RECT,
     DRAW_RRECT,
     DRAW_SPRITE_RETIRED_2015_REMOVED_2018,
     DRAW_TEXT_REMOVED_1_2019,
     DRAW_TEXT_ON_PATH_RETIRED_08_2018_REMOVED_10_2018,
     DRAW_TEXT_TOP_BOTTOM_REMOVED_1_2019,
     DRAW_VERTICES_RETIRED_03_2017_REMOVED_01_2018,
     RESTORE,
     ROTATE,
     SAVE,
     SAVE_LAYER_SAVEFLAGS_DEPRECATED,
     SCALE,
     SET_MATRIX,
     SKEW,
     TRANSLATE,
     NOOP,
     BEGIN_COMMENT_GROUP_obsolete,
     COMMENT_obsolete,
     END_COMMENT_GROUP_obsolete,
 
     // new ops -- feel free to re-alphabetize on next version bump
     DRAW_DRRECT,
     PUSH_CULL,  // deprecated, M41 was last Chromium version to write this to an .skp
     POP_CULL,   // deprecated, M41 was last Chromium version to write this to an .skp
 
     DRAW_PATCH, // could not add in aphabetical order
     DRAW_PICTURE_MATRIX_PAINT,
     DRAW_TEXT_BLOB,
     DRAW_IMAGE,
     DRAW_IMAGE_RECT_STRICT_obsolete,
     DRAW_ATLAS,
     DRAW_IMAGE_NINE,
     DRAW_IMAGE_RECT,
 
     SAVE_LAYER_SAVELAYERFLAGS_DEPRECATED_JAN_2016_REMOVED_01_2018,
     SAVE_LAYER_SAVELAYERREC,
 
     DRAW_ANNOTATION,
     DRAW_DRAWABLE,
     DRAW_DRAWABLE_MATRIX,
     DRAW_TEXT_RSXFORM_DEPRECATED_DEC_2018,
 
     TRANSLATE_Z, // deprecated (M60)
 
     DRAW_SHADOW_REC,
     DRAW_IMAGE_LATTICE,
     DRAW_ARC,
     DRAW_REGION,
     DRAW_VERTICES_OBJECT,
 
     FLUSH,
 
-    DRAW_EDGEAA_IMAGE_SET,
+    DRAW_IMAGE_SET,
 
     SAVE_BEHIND,
 
-    DRAW_EDGEAA_QUAD,
+    DRAW_EDGEAA_RECT,
 
-    LAST_DRAWTYPE_ENUM = DRAW_EDGEAA_QUAD,
+    LAST_DRAWTYPE_ENUM = DRAW_EDGEAA_RECT,
 };
 
 enum DrawVertexFlags {
diff --git a/src/core/SkPicturePlayback.cpp b/src/core/SkPicturePlayback.cpp
index 4a51ab0ba7..e0120dddfd 100644
--- a/src/core/SkPicturePlayback.cpp
+++ b/src/core/SkPicturePlayback.cpp
@@ -112,507 +112,486 @@ static void validate_offsetToRestore(SkReadBuffer* reader, size_t offsetToRestor
 void SkPicturePlayback::handleOp(SkReadBuffer* reader,
                                  DrawType op,
                                  uint32_t size,
                                  SkCanvas* canvas,
                                  const SkMatrix& initialMatrix) {
 #define BREAK_ON_READ_ERROR(r) if (!r->isValid()) break
 
     switch (op) {
         case NOOP: {
             SkASSERT(size >= 4);
             reader->skip(size - 4);
         } break;
         case FLUSH:
             canvas->flush();
             break;
         case CLIP_PATH: {
             const SkPath& path = fPictureData->getPath(reader);
             uint32_t packed = reader->readInt();
             SkClipOp clipOp = ClipParams_unpackRegionOp(reader, packed);
             bool doAA = ClipParams_unpackDoAA(packed);
             size_t offsetToRestore = reader->readInt();
             validate_offsetToRestore(reader, offsetToRestore);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->clipPath(path, clipOp, doAA);
             if (canvas->isClipEmpty() && offsetToRestore) {
                 reader->skip(offsetToRestore - reader->offset());
             }
         } break;
         case CLIP_REGION: {
             SkRegion region;
             reader->readRegion(&region);
             uint32_t packed = reader->readInt();
             SkClipOp clipOp = ClipParams_unpackRegionOp(reader, packed);
             size_t offsetToRestore = reader->readInt();
             validate_offsetToRestore(reader, offsetToRestore);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->clipRegion(region, clipOp);
             if (canvas->isClipEmpty() && offsetToRestore) {
                 reader->skip(offsetToRestore - reader->offset());
             }
         } break;
         case CLIP_RECT: {
             SkRect rect;
             reader->readRect(&rect);
             uint32_t packed = reader->readInt();
             SkClipOp clipOp = ClipParams_unpackRegionOp(reader, packed);
             bool doAA = ClipParams_unpackDoAA(packed);
             size_t offsetToRestore = reader->readInt();
             validate_offsetToRestore(reader, offsetToRestore);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->clipRect(rect, clipOp, doAA);
             if (canvas->isClipEmpty() && offsetToRestore) {
                 reader->skip(offsetToRestore - reader->offset());
             }
         } break;
         case CLIP_RRECT: {
             SkRRect rrect;
             reader->readRRect(&rrect);
             uint32_t packed = reader->readInt();
             SkClipOp clipOp = ClipParams_unpackRegionOp(reader, packed);
             bool doAA = ClipParams_unpackDoAA(packed);
             size_t offsetToRestore = reader->readInt();
             validate_offsetToRestore(reader, offsetToRestore);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->clipRRect(rrect, clipOp, doAA);
             if (canvas->isClipEmpty() && offsetToRestore) {
                 reader->skip(offsetToRestore - reader->offset());
             }
         } break;
         case PUSH_CULL: break;  // Deprecated, safe to ignore both push and pop.
         case POP_CULL:  break;
         case CONCAT: {
             SkMatrix matrix;
             reader->readMatrix(&matrix);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->concat(matrix);
             break;
         }
         case DRAW_ANNOTATION: {
             SkRect rect;
             reader->readRect(&rect);
             SkString key;
             reader->readString(&key);
             sk_sp<SkData> data = reader->readByteArrayAsData();
             BREAK_ON_READ_ERROR(reader);
             SkASSERT(data);
 
             canvas->drawAnnotation(rect, key.c_str(), data.get());
         } break;
         case DRAW_ARC: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             SkRect rect;
             reader->readRect(&rect);
             SkScalar startAngle = reader->readScalar();
             SkScalar sweepAngle = reader->readScalar();
             int useCenter = reader->readInt();
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawArc(rect, startAngle, sweepAngle, SkToBool(useCenter), *paint);
             }
         } break;
         case DRAW_ATLAS: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             const SkImage* atlas = fPictureData->getImage(reader);
             const uint32_t flags = reader->readUInt();
             const int count = reader->readUInt();
             const SkRSXform* xform = (const SkRSXform*)reader->skip(count, sizeof(SkRSXform));
             const SkRect* tex = (const SkRect*)reader->skip(count, sizeof(SkRect));
             const SkColor* colors = nullptr;
             SkBlendMode mode = SkBlendMode::kDst;
             if (flags & DRAW_ATLAS_HAS_COLORS) {
                 colors = (const SkColor*)reader->skip(count, sizeof(SkColor));
                 mode = (SkBlendMode)reader->readUInt();
             }
             const SkRect* cull = nullptr;
             if (flags & DRAW_ATLAS_HAS_CULL) {
                 cull = (const SkRect*)reader->skip(sizeof(SkRect));
             }
             BREAK_ON_READ_ERROR(reader);
 
             canvas->drawAtlas(atlas, xform, tex, colors, count, mode, cull, paint);
         } break;
         case DRAW_CLEAR: {
             auto c = reader->readInt();
             BREAK_ON_READ_ERROR(reader);
 
             canvas->clear(c);
         } break;
         case DRAW_DATA: {
             // This opcode is now dead, just need to skip it for backwards compatibility
             size_t length = reader->readInt();
             (void)reader->skip(length);
             // skip handles padding the read out to a multiple of 4
         } break;
         case DRAW_DRAWABLE: {
             auto* d = fPictureData->getDrawable(reader);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->drawDrawable(d);
         } break;
         case DRAW_DRAWABLE_MATRIX: {
             SkMatrix matrix;
             reader->readMatrix(&matrix);
             SkDrawable* drawable = fPictureData->getDrawable(reader);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->drawDrawable(drawable, &matrix);
         } break;
         case DRAW_DRRECT: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             SkRRect outer, inner;
             reader->readRRect(&outer);
             reader->readRRect(&inner);
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawDRRect(outer, inner, *paint);
             }
         } break;
-        case DRAW_EDGEAA_QUAD: {
+        case DRAW_EDGEAA_RECT: {
             SkRect rect;
             reader->readRect(&rect);
             SkCanvas::QuadAAFlags aaFlags = static_cast<SkCanvas::QuadAAFlags>(reader->read32());
             SkColor color = reader->read32();
             SkBlendMode blend = static_cast<SkBlendMode>(reader->read32());
-            bool hasClip = reader->readInt();
-            SkPoint clip[4];
-            if (hasClip) {
-                for (int i = 0; i < 4; ++i) {
-                    reader->readPoint(&clip[i]);
-                }
-            }
             BREAK_ON_READ_ERROR(reader);
-            canvas->experimental_DrawEdgeAAQuad(rect, hasClip ? clip : nullptr,
-                                                aaFlags, color, blend);
-        } break;
-        case DRAW_EDGEAA_IMAGE_SET: {
-            int cnt = reader->readInt();
-            if (!reader->validate(cnt >= 0)) {
-                break;
-            }
-            const SkPaint* paint = fPictureData->getPaint(reader);
-            SkCanvas::SrcRectConstraint constraint = (SkCanvas::SrcRectConstraint)reader->readInt();
-            SkAutoTArray<SkCanvas::ImageSetEntry> set(cnt);
-            for (int i = 0; i < cnt; ++i) {
-                set[i].fImage = sk_ref_sp(fPictureData->getImage(reader));
-                reader->readRect(&set[i].fSrcRect);
-                reader->readRect(&set[i].fDstRect);
-                set[i].fMatrixIndex = reader->readInt();
-                set[i].fAlpha = reader->readScalar();
-                set[i].fAAFlags = reader->readUInt();
-                set[i].fHasClip = reader->readInt();
-            }
 
-            int dstClipCount = reader->readInt();
-            SkTArray<SkPoint> dstClips(dstClipCount);
-            for (int i = 0; i < dstClipCount; ++i) {
-                reader->readPoint(&dstClips.push_back());
-            }
-            int matrixCount = reader->readInt();
-            SkTArray<SkMatrix> matrices(matrixCount);
-            for (int i = 0; i < matrixCount; ++i) {
-                reader->readMatrix(&matrices.push_back());
-            }
-            BREAK_ON_READ_ERROR(reader);
-
-            canvas->experimental_DrawEdgeAAImageSet(set.get(), cnt, dstClips.begin(),
-                                                    matrices.begin(), paint, constraint);
+            canvas->experimental_DrawEdgeAARectV1(rect, aaFlags, color, blend);
         } break;
         case DRAW_IMAGE: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             const SkImage* image = fPictureData->getImage(reader);
             SkPoint loc;
             reader->readPoint(&loc);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->drawImage(image, loc.fX, loc.fY, paint);
         } break;
         case DRAW_IMAGE_LATTICE: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             const SkImage* image = fPictureData->getImage(reader);
             SkCanvas::Lattice lattice;
             (void)SkCanvasPriv::ReadLattice(*reader, &lattice);
             const SkRect* dst = reader->skipT<SkRect>();
             BREAK_ON_READ_ERROR(reader);
 
             canvas->drawImageLattice(image, lattice, *dst, paint);
         } break;
         case DRAW_IMAGE_NINE: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             const SkImage* image = fPictureData->getImage(reader);
             SkIRect center;
             reader->readIRect(&center);
             SkRect dst;
             reader->readRect(&dst);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->drawImageNine(image, center, dst, paint);
         } break;
         case DRAW_IMAGE_RECT: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             const SkImage* image = fPictureData->getImage(reader);
             SkRect storage;
             const SkRect* src = get_rect_ptr(reader, &storage);   // may be null
             SkRect dst;
             reader->readRect(&dst);     // required
             // DRAW_IMAGE_RECT_STRICT assumes this constraint, and doesn't store it
             SkCanvas::SrcRectConstraint constraint = SkCanvas::kStrict_SrcRectConstraint;
             if (DRAW_IMAGE_RECT == op) {
                 // newer op-code stores the constraint explicitly
                 constraint = (SkCanvas::SrcRectConstraint)reader->readInt();
             }
             BREAK_ON_READ_ERROR(reader);
 
             canvas->legacy_drawImageRect(image, src, dst, paint, constraint);
         } break;
+        case DRAW_IMAGE_SET: {
+            int cnt = reader->readInt();
+            if (!reader->validate(cnt >= 0)) {
+                break;
+            }
+            SkFilterQuality filterQuality = (SkFilterQuality)reader->readUInt();
+            SkBlendMode mode = (SkBlendMode)reader->readUInt();
+            SkAutoTArray<SkCanvas::ImageSetEntry> set(cnt);
+            for (int i = 0; i < cnt; ++i) {
+                set[i].fImage = sk_ref_sp(fPictureData->getImage(reader));
+                reader->readRect(&set[i].fSrcRect);
+                reader->readRect(&set[i].fDstRect);
+                set[i].fAlpha = reader->readScalar();
+                set[i].fAAFlags = reader->readUInt();
+            }
+            BREAK_ON_READ_ERROR(reader);
+
+            canvas->experimental_DrawImageSetV1(set.get(), cnt, filterQuality, mode);
+        } break;
         case DRAW_OVAL: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             SkRect rect;
             reader->readRect(&rect);
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawOval(rect, *paint);
             }
         } break;
         case DRAW_PAINT: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawPaint(*paint);
             }
         } break;
         case DRAW_PATCH: {
             const SkPaint* paint = fPictureData->getPaint(reader);
 
             const SkPoint* cubics = (const SkPoint*)reader->skip(SkPatchUtils::kNumCtrlPts,
                                                                  sizeof(SkPoint));
             uint32_t flag = reader->readInt();
             const SkColor* colors = nullptr;
             if (flag & DRAW_VERTICES_HAS_COLORS) {
                 colors = (const SkColor*)reader->skip(SkPatchUtils::kNumCorners, sizeof(SkColor));
             }
             const SkPoint* texCoords = nullptr;
             if (flag & DRAW_VERTICES_HAS_TEXS) {
                 texCoords = (const SkPoint*)reader->skip(SkPatchUtils::kNumCorners,
                                                          sizeof(SkPoint));
             }
             SkBlendMode bmode = SkBlendMode::kModulate;
             if (flag & DRAW_VERTICES_HAS_XFER) {
                 unsigned mode = reader->readInt();
                 if (mode <= (unsigned)SkBlendMode::kLastMode) {
                     bmode = (SkBlendMode)mode;
                 }
             }
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawPatch(cubics, colors, texCoords, bmode, *paint);
             }
         } break;
         case DRAW_PATH: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             const auto& path = fPictureData->getPath(reader);
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawPath(path, *paint);
             }
         } break;
         case DRAW_PICTURE: {
             const auto* pic = fPictureData->getPicture(reader);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->drawPicture(pic);
         } break;
         case DRAW_PICTURE_MATRIX_PAINT: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             SkMatrix matrix;
             reader->readMatrix(&matrix);
             const SkPicture* pic = fPictureData->getPicture(reader);
             BREAK_ON_READ_ERROR(reader);
 
             canvas->drawPicture(pic, &matrix, paint);
         } break;
         case DRAW_POINTS: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             SkCanvas::PointMode mode = (SkCanvas::PointMode)reader->readInt();
             size_t count = reader->readInt();
             const SkPoint* pts = (const SkPoint*)reader->skip(count, sizeof(SkPoint));
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawPoints(mode, count, pts, *paint);
             }
         } break;
         case DRAW_RECT: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             SkRect rect;
             reader->readRect(&rect);
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawRect(rect, *paint);
             }
         } break;
         case DRAW_REGION: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             SkRegion region;
             reader->readRegion(&region);
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawRegion(region, *paint);
             }
         } break;
         case DRAW_RRECT: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             SkRRect rrect;
             reader->readRRect(&rrect);
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawRRect(rrect, *paint);
             }
         } break;
         case DRAW_SHADOW_REC: {
             const auto& path = fPictureData->getPath(reader);
             SkDrawShadowRec rec;
             reader->readPoint3(&rec.fZPlaneParams);
             reader->readPoint3(&rec.fLightPos);
             rec.fLightRadius = reader->readScalar();
             if (reader->isVersionLT(SkReadBuffer::kTwoColorDrawShadow_Version)) {
                 SkScalar ambientAlpha = reader->readScalar();
                 SkScalar spotAlpha = reader->readScalar();
                 SkColor color = reader->read32();
                 rec.fAmbientColor = SkColorSetA(color, SkColorGetA(color)*ambientAlpha);
                 rec.fSpotColor = SkColorSetA(color, SkColorGetA(color)*spotAlpha);
             } else {
                 rec.fAmbientColor = reader->read32();
                 rec.fSpotColor = reader->read32();
             }
             rec.fFlags = reader->read32();
             BREAK_ON_READ_ERROR(reader);
 
             canvas->private_draw_shadow_rec(path, rec);
         } break;
         case DRAW_TEXT_BLOB: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             const SkTextBlob* blob = fPictureData->getTextBlob(reader);
             SkScalar x = reader->readScalar();
             SkScalar y = reader->readScalar();
             BREAK_ON_READ_ERROR(reader);
 
             if (paint) {
                 canvas->drawTextBlob(blob, x, y, *paint);
             }
         } break;
         case DRAW_VERTICES_OBJECT: {
             const SkPaint* paint = fPictureData->getPaint(reader);
             const SkVertices* vertices = fPictureData->getVertices(reader);
             const int boneCount = reader->readInt();
             const SkVertices::Bone* bones = boneCount ?
                     (const SkVertices::Bone*) reader->skip(boneCount, sizeof(SkVertices::Bone)) :
                     nullptr;
             SkBlendMode bmode = reader->read32LE(SkBlendMode::kLastMode);
             BREAK_ON_READ_ERROR(reader);
 
             if (paint && vertices) {
                 canvas->drawVertices(vertices, bones, boneCount, bmode, *paint);
             }
         } break;
         case RESTORE:
             canvas->restore();
             break;
         case ROTATE: {
             auto deg = reader->readScalar();
             canvas->rotate(deg);
         } break;
         case SAVE:
             canvas->save();
             break;
         case SAVE_BEHIND: {
             uint32_t flags = reader->readInt();
             const SkRect* subset = nullptr;
             SkRect storage;
             if (flags & SAVEBEHIND_HAS_SUBSET) {
                 reader->readRect(&storage);
                 subset = &storage;
             }
             SkCanvasPriv::SaveBehind(canvas, subset);
         } break;
         case SAVE_LAYER_SAVEFLAGS_DEPRECATED: {
             SkRect storage;
             const SkRect* boundsPtr = get_rect_ptr(reader, &storage);
             const SkPaint* paint = fPictureData->getPaint(reader);
             auto flags = SkCanvasPriv::LegacySaveFlagsToSaveLayerFlags(reader->readInt());
             BREAK_ON_READ_ERROR(reader);
 
             canvas->saveLayer(SkCanvas::SaveLayerRec(boundsPtr, paint, flags));
         } break;
         case SAVE_LAYER_SAVELAYERREC: {
             SkCanvas::SaveLayerRec rec(nullptr, nullptr, nullptr, nullptr, nullptr, 0);
             SkMatrix clipMatrix;
             const uint32_t flatFlags = reader->readInt();
             SkRect bounds;
             if (flatFlags & SAVELAYERREC_HAS_BOUNDS) {
                 reader->readRect(&bounds);
                 rec.fBounds = &bounds;
             }
             if (flatFlags & SAVELAYERREC_HAS_PAINT) {
                 rec.fPaint = fPictureData->getPaint(reader);
             }
             if (flatFlags & SAVELAYERREC_HAS_BACKDROP) {
                 if (const auto* paint = fPictureData->getPaint(reader)) {
                     rec.fBackdrop = paint->getImageFilter();
                 }
             }
             if (flatFlags & SAVELAYERREC_HAS_FLAGS) {
                 rec.fSaveLayerFlags = reader->readInt();
             }
             if (flatFlags & SAVELAYERREC_HAS_CLIPMASK) {
                 rec.fClipMask = fPictureData->getImage(reader);
             }
             if (flatFlags & SAVELAYERREC_HAS_CLIPMATRIX) {
                 reader->readMatrix(&clipMatrix);
                 rec.fClipMatrix = &clipMatrix;
             }
             BREAK_ON_READ_ERROR(reader);
 
             canvas->saveLayer(rec);
         } break;
         case SCALE: {
             SkScalar sx = reader->readScalar();
             SkScalar sy = reader->readScalar();
             canvas->scale(sx, sy);
         } break;
         case SET_MATRIX: {
             SkMatrix matrix;
             reader->readMatrix(&matrix);
             matrix.postConcat(initialMatrix);
             canvas->setMatrix(matrix);
         } break;
         case SKEW: {
             SkScalar sx = reader->readScalar();
             SkScalar sy = reader->readScalar();
             canvas->skew(sx, sy);
         } break;
         case TRANSLATE: {
             SkScalar dx = reader->readScalar();
             SkScalar dy = reader->readScalar();
             canvas->translate(dx, dy);
         } break;
         default:
             reader->validate(false);    // unknown op
             break;
     }
 
 #undef BREAK_ON_READ_ERROR
 }
diff --git a/src/core/SkPictureRecord.cpp b/src/core/SkPictureRecord.cpp
index d8bc36bc5d..01115bfdce 100644
--- a/src/core/SkPictureRecord.cpp
+++ b/src/core/SkPictureRecord.cpp
@@ -467,6 +467,18 @@ void SkPictureRecord::onDrawRect(const SkRect& rect, const SkPaint& paint) {
     this->validate(initialOffset, size);
 }
 
+void SkPictureRecord::onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa,
+                                       SkColor color, SkBlendMode mode) {
+    // op + rect + aa flags + color + mode
+    size_t size = 4 * kUInt32Size + sizeof(rect);
+    size_t initialOffset = this->addDraw(DRAW_EDGEAA_RECT, &size);
+    this->addRect(rect);
+    this->addInt((int) aa);
+    this->addInt((int) color);
+    this->addInt((int) mode);
+    this->validate(initialOffset, size);
+}
+
 void SkPictureRecord::onDrawRegion(const SkRegion& region, const SkPaint& paint) {
     // op + paint index + region
     size_t regionBytes = region.writeToMemory(nullptr);
@@ -562,6 +574,25 @@ void SkPictureRecord::onDrawImageLattice(const SkImage* image, const Lattice& la
     this->validate(initialOffset, size);
 }
 
+void SkPictureRecord::onDrawImageSet(const SkCanvas::ImageSetEntry set[], int count,
+                                     SkFilterQuality filterQuality, SkBlendMode mode) {
+    // op + count + alpha + fq + mode + (image index, src rect, dst rect, alpha, aa flags) * cnt
+    size_t size =
+            4 * kUInt32Size + (2 * kUInt32Size + 2 * sizeof(SkRect) + sizeof(SkScalar)) * count;
+    size_t initialOffset = this->addDraw(DRAW_IMAGE_SET, &size);
+    this->addInt(count);
+    this->addInt((int)filterQuality);
+    this->addInt((int)mode);
+    for (int i = 0; i < count; ++i) {
+        this->addImage(set[i].fImage.get());
+        this->addRect(set[i].fSrcRect);
+        this->addRect(set[i].fDstRect);
+        this->addScalar(set[i].fAlpha);
+        this->addInt((int)set[i].fAAFlags);
+    }
+    this->validate(initialOffset, size);
+}
+
 void SkPictureRecord::onDrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                                      const SkPaint& paint) {
 
@@ -731,59 +762,6 @@ void SkPictureRecord::onDrawAnnotation(const SkRect& rect, const char key[], SkD
     this->validate(initialOffset, size);
 }
 
-void SkPictureRecord::onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                       SkCanvas::QuadAAFlags aa, SkColor color, SkBlendMode mode) {
-
-    // op + rect + aa flags + color + mode + hasClip(as int) + clipCount*points
-    size_t size = 5 * kUInt32Size + sizeof(rect) + (clip ? 4 : 0) * sizeof(SkPoint);
-    size_t initialOffset = this->addDraw(DRAW_EDGEAA_QUAD, &size);
-    this->addRect(rect);
-    this->addInt((int) aa);
-    this->addInt((int) color);
-    this->addInt((int) mode);
-    this->addInt(clip != nullptr);
-    if (clip) {
-        this->addPoints(clip, 4);
-    }
-    this->validate(initialOffset, size);
-}
-
-void SkPictureRecord::onDrawEdgeAAImageSet(const SkCanvas::ImageSetEntry set[], int count,
-                                           const SkPoint dstClips[],
-                                           const SkMatrix preViewMatrices[],
-                                           const SkPaint* paint,
-                                           SkCanvas::SrcRectConstraint constraint) {
-    static constexpr size_t kMatrixSize = 9 * sizeof(SkScalar); // *not* sizeof(SkMatrix)
-    // op + count + paint + constraint + (image index, src rect, dst rect, alpha, aa flags,
-    // hasClip(int), matrixIndex) * cnt + totalClipCount + dstClips + totalMatrixCount + matrices
-    int totalDstClipCount, totalMatrixCount;
-    SkCanvasPriv::GetDstClipAndMatrixCounts(set, count, &totalDstClipCount, &totalMatrixCount);
-
-    size_t size = 6 * kUInt32Size + sizeof(SkPoint) * totalDstClipCount +
-                  kMatrixSize * totalMatrixCount +
-                  (4 * kUInt32Size + 2 * sizeof(SkRect) + sizeof(SkScalar)) * count;
-    size_t initialOffset = this->addDraw(DRAW_EDGEAA_IMAGE_SET, &size);
-    this->addInt(count);
-    this->addPaintPtr(paint);
-    this->addInt((int) constraint);
-    for (int i = 0; i < count; ++i) {
-        this->addImage(set[i].fImage.get());
-        this->addRect(set[i].fSrcRect);
-        this->addRect(set[i].fDstRect);
-        this->addInt(set[i].fMatrixIndex);
-        this->addScalar(set[i].fAlpha);
-        this->addInt((int)set[i].fAAFlags);
-        this->addInt(set[i].fHasClip);
-    }
-    this->addInt(totalDstClipCount);
-    this->addPoints(dstClips, totalDstClipCount);
-    this->addInt(totalMatrixCount);
-    for (int i = 0; i < totalMatrixCount; ++i) {
-        this->addMatrix(preViewMatrices[i]);
-    }
-    this->validate(initialOffset, size);
-}
-
 ///////////////////////////////////////////////////////////////////////////////
 
 // De-duping helper.
diff --git a/src/core/SkPictureRecord.h b/src/core/SkPictureRecord.h
index f355e415b5..77137c4716 100644
--- a/src/core/SkPictureRecord.h
+++ b/src/core/SkPictureRecord.h
@@ -148,95 +148,92 @@ private:
 protected:
     void validate(size_t initialOffset, size_t size) const {
         SkASSERT(fWriter.bytesWritten() == initialOffset + size);
     }
 
     sk_sp<SkSurface> onNewSurface(const SkImageInfo&, const SkSurfaceProps&) override;
     bool onPeekPixels(SkPixmap*) override { return false; }
 
     void onFlush() override;
 
     void willSave() override;
     SaveLayerStrategy getSaveLayerStrategy(const SaveLayerRec&) override;
     bool onDoSaveBehind(const SkRect*) override;
     void willRestore() override;
 
     void didConcat(const SkMatrix&) override;
     void didSetMatrix(const SkMatrix&) override;
 
     void onDrawDRRect(const SkRRect&, const SkRRect&, const SkPaint&) override;
 
     void onDrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                                 const SkPaint& paint) override;
 
     void onDrawPatch(const SkPoint cubics[12], const SkColor colors[4],
                      const SkPoint texCoords[4], SkBlendMode, const SkPaint& paint) override;
     void onDrawAtlas(const SkImage*, const SkRSXform[], const SkRect[], const SkColor[], int,
                      SkBlendMode, const SkRect*, const SkPaint*) override;
 
     void onDrawPaint(const SkPaint&) override;
     void onDrawPoints(PointMode, size_t count, const SkPoint pts[], const SkPaint&) override;
     void onDrawRect(const SkRect&, const SkPaint&) override;
+    void onDrawEdgeAARect(const SkRect&, SkCanvas::QuadAAFlags, SkColor, SkBlendMode) override;
     void onDrawRegion(const SkRegion&, const SkPaint&) override;
     void onDrawOval(const SkRect&, const SkPaint&) override;
     void onDrawArc(const SkRect&, SkScalar, SkScalar, bool, const SkPaint&) override;
     void onDrawRRect(const SkRRect&, const SkPaint&) override;
     void onDrawPath(const SkPath&, const SkPaint&) override;
     void onDrawImage(const SkImage*, SkScalar left, SkScalar top, const SkPaint*) override;
     void onDrawImageRect(const SkImage*, const SkRect* src, const SkRect& dst,
                          const SkPaint*, SrcRectConstraint) override;
     void onDrawImageNine(const SkImage*, const SkIRect& center, const SkRect& dst,
                          const SkPaint*) override;
     void onDrawImageLattice(const SkImage*, const SkCanvas::Lattice& lattice, const SkRect& dst,
                             const SkPaint*) override;
-
+    void onDrawImageSet(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality,
+                        SkBlendMode) override;
     void onDrawShadowRec(const SkPath&, const SkDrawShadowRec&) override;
     void onDrawVerticesObject(const SkVertices*, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode, const SkPaint&) override;
 
     void onClipRect(const SkRect&, SkClipOp, ClipEdgeStyle) override;
     void onClipRRect(const SkRRect&, SkClipOp, ClipEdgeStyle) override;
     void onClipPath(const SkPath&, SkClipOp, ClipEdgeStyle) override;
     void onClipRegion(const SkRegion&, SkClipOp) override;
 
     void onDrawPicture(const SkPicture*, const SkMatrix*, const SkPaint*) override;
 
     void onDrawDrawable(SkDrawable*, const SkMatrix*) override;
     void onDrawAnnotation(const SkRect&, const char[], SkData*) override;
 
-    void onDrawEdgeAAQuad(const SkRect&, const SkPoint[4], QuadAAFlags, SkColor,
-                          SkBlendMode) override;
-    void onDrawEdgeAAImageSet(const ImageSetEntry[], int count, const SkPoint[], const SkMatrix[],
-                              const SkPaint*, SrcRectConstraint) override;
-
     int addPathToHeap(const SkPath& path);  // does not write to ops stream
 
     // These entry points allow the writing of matrices, clips, saves &
     // restores to be deferred (e.g., if the MC state is being collapsed and
     // only written out as needed).
     void recordConcat(const SkMatrix& matrix);
     void recordTranslate(const SkMatrix& matrix);
     void recordScale(const SkMatrix& matrix);
     size_t recordClipRect(const SkRect& rect, SkClipOp op, bool doAA);
     size_t recordClipRRect(const SkRRect& rrect, SkClipOp op, bool doAA);
     size_t recordClipPath(int pathID, SkClipOp op, bool doAA);
     size_t recordClipRegion(const SkRegion& region, SkClipOp op);
     void recordSave();
     void recordSaveLayer(const SaveLayerRec&);
     void recordRestore(bool fillInSkips = true);
 
     // SHOULD NEVER BE CALLED
     void onDrawBitmap(const SkBitmap&, SkScalar left, SkScalar top, const SkPaint*) override {
         SK_ABORT("not reached");
     }
     void onDrawBitmapRect(const SkBitmap&, const SkRect* src, const SkRect& dst, const SkPaint*,
                           SrcRectConstraint) override {
         SK_ABORT("not reached");
     }
     void onDrawBitmapNine(const SkBitmap&, const SkIRect& center, const SkRect& dst,
                           const SkPaint*) override {
         SK_ABORT("not reached");
     }
     void onDrawBitmapLattice(const SkBitmap&, const SkCanvas::Lattice& lattice, const SkRect& dst,
                              const SkPaint*) override {
         SK_ABORT("not reached");
     }
diff --git a/src/core/SkRecordDraw.cpp b/src/core/SkRecordDraw.cpp
index b6a303338f..4dcc45502f 100644
--- a/src/core/SkRecordDraw.cpp
+++ b/src/core/SkRecordDraw.cpp
@@ -115,6 +115,7 @@ template <> void Draw::draw(const DrawImageLattice& r) {
 
 DRAW(DrawImageRect, legacy_drawImageRect(r.image.get(), r.src, r.dst, r.paint, r.constraint));
 DRAW(DrawImageNine, drawImageNine(r.image.get(), r.center, r.dst, r.paint));
+DRAW(DrawImageSet, experimental_DrawImageSetV1(r.set.get(), r.count, r.quality, r.mode));
 DRAW(DrawOval, drawOval(r.oval, r.paint));
 DRAW(DrawPaint, drawPaint(r.paint));
 DRAW(DrawPath, drawPath(r.path, r.paint));
@@ -123,6 +124,7 @@ DRAW(DrawPicture, drawPicture(r.picture.get(), &r.matrix, r.paint));
 DRAW(DrawPoints, drawPoints(r.mode, r.count, r.pts, r.paint));
 DRAW(DrawRRect, drawRRect(r.rrect, r.paint));
 DRAW(DrawRect, drawRect(r.rect, r.paint));
+DRAW(DrawEdgeAARect, experimental_DrawEdgeAARectV1(r.rect, r.aa, r.color, r.mode));
 DRAW(DrawRegion, drawRegion(r.region, r.paint));
 DRAW(DrawTextBlob, drawTextBlob(r.blob.get(), r.x, r.y, r.paint));
 DRAW(DrawAtlas, drawAtlas(r.atlas.get(),
@@ -130,12 +132,6 @@ DRAW(DrawAtlas, drawAtlas(r.atlas.get(),
 DRAW(DrawVertices, drawVertices(r.vertices, r.bones, r.boneCount, r.bmode, r.paint));
 DRAW(DrawShadowRec, private_draw_shadow_rec(r.path, r.rec));
 DRAW(DrawAnnotation, drawAnnotation(r.rect, r.key.c_str(), r.value.get()));
-
-DRAW(DrawEdgeAAQuad, experimental_DrawEdgeAAQuad(
-        r.rect, r.clip, r.aa, r.color, r.mode));
-DRAW(DrawEdgeAAImageSet, experimental_DrawEdgeAAImageSet(
-        r.set.get(), r.count, r.dstClips, r.preViewMatrices, r.paint, r.constraint));
-
 #undef DRAW
 
 template <> void Draw::draw(const DrawDrawable& r) {
@@ -238,283 +234,269 @@ public:
 private:
     struct SaveBounds {
         int controlOps;        // Number of control ops in this Save block, including the Save.
         Bounds bounds;         // Bounds of everything in the block.
         const SkPaint* paint;  // Unowned.  If set, adjusts the bounds of all ops in this block.
         SkMatrix ctm;
     };
 
     // Only Restore, SetMatrix, Concat, and Translate change the CTM.
     template <typename T> void updateCTM(const T&) {}
     void updateCTM(const Restore& op)   { fCTM = op.matrix; }
     void updateCTM(const SetMatrix& op) { fCTM = op.matrix; }
     void updateCTM(const Concat& op)    { fCTM.preConcat(op.matrix); }
     void updateCTM(const Translate& op) { fCTM.preTranslate(op.dx, op.dy); }
 
     // The bounds of these ops must be calculated when we hit the Restore
     // from the bounds of the ops in the same Save block.
     void trackBounds(const Save&)          { this->pushSaveBlock(nullptr); }
     void trackBounds(const SaveLayer& op)  { this->pushSaveBlock(op.paint); }
     void trackBounds(const SaveBehind&)    { this->pushSaveBlock(nullptr); }
     void trackBounds(const Restore&) { fBounds[fCurrentOp] = this->popSaveBlock(); }
 
     void trackBounds(const SetMatrix&)         { this->pushControl(); }
     void trackBounds(const Concat&)            { this->pushControl(); }
     void trackBounds(const Translate&)         { this->pushControl(); }
     void trackBounds(const ClipRect&)          { this->pushControl(); }
     void trackBounds(const ClipRRect&)         { this->pushControl(); }
     void trackBounds(const ClipPath&)          { this->pushControl(); }
     void trackBounds(const ClipRegion&)        { this->pushControl(); }
 
 
     // For all other ops, we can calculate and store the bounds directly now.
     template <typename T> void trackBounds(const T& op) {
         fBounds[fCurrentOp] = this->bounds(op);
         this->updateSaveBounds(fBounds[fCurrentOp]);
     }
 
     void pushSaveBlock(const SkPaint* paint) {
         // Starting a new Save block.  Push a new entry to represent that.
         SaveBounds sb;
         sb.controlOps = 0;
         // If the paint affects transparent black,
         // the bound shouldn't be smaller than the cull.
         sb.bounds =
             PaintMayAffectTransparentBlack(paint) ? fCullRect : Bounds::MakeEmpty();
         sb.paint = paint;
         sb.ctm = this->fCTM;
 
         fSaveStack.push_back(sb);
         this->pushControl();
     }
 
     static bool PaintMayAffectTransparentBlack(const SkPaint* paint) {
         if (paint) {
             // FIXME: this is very conservative
             if (paint->getImageFilter() || paint->getColorFilter()) {
                 return true;
             }
 
             // Unusual blendmodes require us to process a saved layer
             // even with operations outisde the clip.
             // For example, DstIn is used by masking layers.
             // https://code.google.com/p/skia/issues/detail?id=1291
             // https://crbug.com/401593
             switch (paint->getBlendMode()) {
                 // For each of the following transfer modes, if the source
                 // alpha is zero (our transparent black), the resulting
                 // blended alpha is not necessarily equal to the original
                 // destination alpha.
                 case SkBlendMode::kClear:
                 case SkBlendMode::kSrc:
                 case SkBlendMode::kSrcIn:
                 case SkBlendMode::kDstIn:
                 case SkBlendMode::kSrcOut:
                 case SkBlendMode::kDstATop:
                 case SkBlendMode::kModulate:
                     return true;
                     break;
                 default:
                     break;
             }
         }
         return false;
     }
 
     Bounds popSaveBlock() {
         // We're done the Save block.  Apply the block's bounds to all control ops inside it.
         SaveBounds sb;
         fSaveStack.pop(&sb);
 
         while (sb.controlOps --> 0) {
             this->popControl(sb.bounds);
         }
 
         // This whole Save block may be part another Save block.
         this->updateSaveBounds(sb.bounds);
 
         // If called from a real Restore (not a phony one for balance), it'll need the bounds.
         return sb.bounds;
     }
 
     void pushControl() {
         fControlIndices.push_back(fCurrentOp);
         if (!fSaveStack.isEmpty()) {
             fSaveStack.top().controlOps++;
         }
     }
 
     void popControl(const Bounds& bounds) {
         fBounds[fControlIndices.top()] = bounds;
         fControlIndices.pop();
     }
 
     void updateSaveBounds(const Bounds& bounds) {
         // If we're in a Save block, expand its bounds to cover these bounds too.
         if (!fSaveStack.isEmpty()) {
             fSaveStack.top().bounds.join(bounds);
         }
     }
 
     Bounds bounds(const Flush&) const { return fCullRect; }
 
     Bounds bounds(const DrawPaint&) const { return fCullRect; }
     Bounds bounds(const NoOp&)  const { return Bounds::MakeEmpty(); }    // NoOps don't draw.
 
     Bounds bounds(const DrawRect& op) const { return this->adjustAndMap(op.rect, &op.paint); }
+    Bounds bounds(const DrawEdgeAARect& op) const { return this->adjustAndMap(op.rect, nullptr); }
+
     Bounds bounds(const DrawRegion& op) const {
         SkRect rect = SkRect::Make(op.region.getBounds());
         return this->adjustAndMap(rect, &op.paint);
     }
     Bounds bounds(const DrawOval& op) const { return this->adjustAndMap(op.oval, &op.paint); }
     // Tighter arc bounds?
     Bounds bounds(const DrawArc& op) const { return this->adjustAndMap(op.oval, &op.paint); }
     Bounds bounds(const DrawRRect& op) const {
         return this->adjustAndMap(op.rrect.rect(), &op.paint);
     }
     Bounds bounds(const DrawDRRect& op) const {
         return this->adjustAndMap(op.outer.rect(), &op.paint);
     }
     Bounds bounds(const DrawImage& op) const {
         const SkImage* image = op.image.get();
         SkRect rect = SkRect::MakeXYWH(op.left, op.top, image->width(), image->height());
 
         return this->adjustAndMap(rect, op.paint);
     }
     Bounds bounds(const DrawImageLattice& op) const {
         return this->adjustAndMap(op.dst, op.paint);
     }
     Bounds bounds(const DrawImageRect& op) const {
         return this->adjustAndMap(op.dst, op.paint);
     }
     Bounds bounds(const DrawImageNine& op) const {
         return this->adjustAndMap(op.dst, op.paint);
     }
+    Bounds bounds(const DrawImageSet& op) const {
+        SkRect rect = SkRect::MakeEmpty();
+        for (int i = 0; i < op.count; ++i) {
+            rect.join(this->adjustAndMap(op.set[i].fDstRect, nullptr));
+        }
+        return rect;
+    }
     Bounds bounds(const DrawPath& op) const {
         return op.path.isInverseFillType() ? fCullRect
                                            : this->adjustAndMap(op.path.getBounds(), &op.paint);
     }
     Bounds bounds(const DrawPoints& op) const {
         SkRect dst;
         dst.set(op.pts, op.count);
 
         // Pad the bounding box a little to make sure hairline points' bounds aren't empty.
         SkScalar stroke = SkMaxScalar(op.paint.getStrokeWidth(), 0.01f);
         dst.outset(stroke/2, stroke/2);
 
         return this->adjustAndMap(dst, &op.paint);
     }
     Bounds bounds(const DrawPatch& op) const {
         SkRect dst;
         dst.set(op.cubics, SkPatchUtils::kNumCtrlPts);
         return this->adjustAndMap(dst, &op.paint);
     }
     Bounds bounds(const DrawVertices& op) const {
         return this->adjustAndMap(op.vertices->bounds(), &op.paint);
     }
 
     Bounds bounds(const DrawAtlas& op) const {
         if (op.cull) {
             // TODO: <reed> can we pass nullptr for the paint? Isn't cull already "correct"
             // for the paint (by the caller)?
             return this->adjustAndMap(*op.cull, op.paint);
         } else {
             return fCullRect;
         }
     }
 
     Bounds bounds(const DrawShadowRec& op) const {
         SkRect bounds;
         SkDrawShadowMetrics::GetLocalBounds(op.path, op.rec, fCTM, &bounds);
         return this->adjustAndMap(bounds, nullptr);
     }
 
     Bounds bounds(const DrawPicture& op) const {
         SkRect dst = op.picture->cullRect();
         op.matrix.mapRect(&dst);
         return this->adjustAndMap(dst, op.paint);
     }
 
     Bounds bounds(const DrawTextBlob& op) const {
         SkRect dst = op.blob->bounds();
         dst.offset(op.x, op.y);
         return this->adjustAndMap(dst, &op.paint);
     }
 
     Bounds bounds(const DrawDrawable& op) const {
         return this->adjustAndMap(op.worstCaseBounds, nullptr);
     }
 
     Bounds bounds(const DrawAnnotation& op) const {
         return this->adjustAndMap(op.rect, nullptr);
     }
-    Bounds bounds(const DrawEdgeAAQuad& op) const {
-        SkRect bounds = op.rect;
-        if (op.clip) {
-            bounds.setBounds(op.clip, 4);
-        }
-        return this->adjustAndMap(bounds, nullptr);
-    }
-    Bounds bounds(const DrawEdgeAAImageSet& op) const {
-        SkRect rect = SkRect::MakeEmpty();
-        int clipIndex = 0;
-        for (int i = 0; i < op.count; ++i) {
-            SkRect entryBounds = op.set[i].fDstRect;
-            if (op.set[i].fHasClip) {
-                entryBounds.setBounds(op.dstClips + clipIndex, 4);
-                clipIndex += 4;
-            }
-            if (op.set[i].fMatrixIndex >= 0) {
-                op.preViewMatrices[op.set[i].fMatrixIndex].mapRect(&entryBounds);
-            }
-            rect.join(this->adjustAndMap(entryBounds, nullptr));
-        }
-        return rect;
-    }
 
     // Returns true if rect was meaningfully adjusted for the effects of paint,
     // false if the paint could affect the rect in unknown ways.
     static bool AdjustForPaint(const SkPaint* paint, SkRect* rect) {
         if (paint) {
             if (paint->canComputeFastBounds()) {
                 *rect = paint->computeFastBounds(*rect, rect);
                 return true;
             }
             return false;
         }
         return true;
     }
 
     bool adjustForSaveLayerPaints(SkRect* rect, int savesToIgnore = 0) const {
         for (int i = fSaveStack.count() - 1 - savesToIgnore; i >= 0; i--) {
             SkMatrix inverse;
             if (!fSaveStack[i].ctm.invert(&inverse)) {
                 return false;
             }
             inverse.mapRect(rect);
             if (!AdjustForPaint(fSaveStack[i].paint, rect)) {
                 return false;
             }
             fSaveStack[i].ctm.mapRect(rect);
         }
         return true;
     }
 
     const int fNumRecords;
 
     // We do not guarantee anything for operations outside of the cull rect
     const SkRect fCullRect;
 
     // Conservative identity-space bounds for each op in the SkRecord.
     Bounds* fBounds;
 
     // We walk fCurrentOp through the SkRecord,
     // as we go using updateCTM() to maintain the exact CTM (fCTM).
     int fCurrentOp;
     SkMatrix fCTM;
 
     // Used to track the bounds of Save/Restore blocks and the control ops inside them.
     SkTDArray<SaveBounds> fSaveStack;
     SkTDArray<int>   fControlIndices;
 };
 
 }  // namespace SkRecords
diff --git a/src/core/SkRecorder.cpp b/src/core/SkRecorder.cpp
index ef43f81505..bfe1067bbd 100644
--- a/src/core/SkRecorder.cpp
+++ b/src/core/SkRecorder.cpp
@@ -151,6 +151,11 @@ void SkRecorder::onDrawRect(const SkRect& rect, const SkPaint& paint) {
     this->append<SkRecords::DrawRect>(paint, rect);
 }
 
+void SkRecorder::onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa, SkColor color,
+                                  SkBlendMode mode) {
+    this->append<SkRecords::DrawEdgeAARect>(rect, aa, color, mode);
+}
+
 void SkRecorder::onDrawRegion(const SkRegion& region, const SkPaint& paint) {
     this->append<SkRecords::DrawRegion>(paint, region);
 }
@@ -253,6 +258,15 @@ void SkRecorder::onDrawImageLattice(const SkImage* image, const Lattice& lattice
            this->copy(lattice.fColors, flagCount), *lattice.fBounds, dst);
 }
 
+void SkRecorder::onDrawImageSet(const ImageSetEntry set[], int count, SkFilterQuality filterQuality,
+                                SkBlendMode mode) {
+    SkAutoTArray<ImageSetEntry> setCopy(count);
+    for (int i = 0; i < count; ++i) {
+        setCopy[i] = set[i];
+    }
+    this->append<SkRecords::DrawImageSet>(std::move(setCopy), count, filterQuality, mode);
+}
+
 void SkRecorder::onDrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                                 const SkPaint& paint) {
     TRY_MINIRECORDER(drawTextBlob, blob, x, y, paint);
@@ -310,28 +324,6 @@ void SkRecorder::onDrawAnnotation(const SkRect& rect, const char key[], SkData*
     this->append<SkRecords::DrawAnnotation>(rect, SkString(key), sk_ref_sp(value));
 }
 
-void SkRecorder::onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                  QuadAAFlags aa, SkColor color, SkBlendMode mode) {
-    this->append<SkRecords::DrawEdgeAAQuad>(
-            rect, this->copy(clip, 4), aa, color, mode);
-}
-
-void SkRecorder::onDrawEdgeAAImageSet(const ImageSetEntry set[], int count,
-                                      const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                                      const SkPaint* paint, SrcRectConstraint constraint) {
-    int totalDstClipCount, totalMatrixCount;
-    SkCanvasPriv::GetDstClipAndMatrixCounts(set, count, &totalDstClipCount, &totalMatrixCount);
-
-    SkAutoTArray<ImageSetEntry> setCopy(count);
-    for (int i = 0; i < count; ++i) {
-        setCopy[i] = set[i];
-    }
-
-    this->append<SkRecords::DrawEdgeAAImageSet>(this->copy(paint), std::move(setCopy), count,
-            this->copy(dstClips, totalDstClipCount),
-            this->copy(preViewMatrices, totalMatrixCount), constraint);
-}
-
 void SkRecorder::onFlush() {
     this->append<SkRecords::Flush>();
 }
diff --git a/src/core/SkRecorder.h b/src/core/SkRecorder.h
index a1d3a69afa..6b4c7fe1cd 100644
--- a/src/core/SkRecorder.h
+++ b/src/core/SkRecorder.h
@@ -41,83 +41,81 @@ class SkRecorder final : public SkCanvasVirtualEnforcer<SkNoDrawCanvas> {
 public:
     // Does not take ownership of the SkRecord.
     SkRecorder(SkRecord*, int width, int height, SkMiniRecorder* = nullptr);   // legacy version
     SkRecorder(SkRecord*, const SkRect& bounds, SkMiniRecorder* = nullptr);
 
     enum DrawPictureMode { Record_DrawPictureMode, Playback_DrawPictureMode };
     void reset(SkRecord*, const SkRect& bounds, DrawPictureMode, SkMiniRecorder* = nullptr);
 
     size_t approxBytesUsedBySubPictures() const { return fApproxBytesUsedBySubPictures; }
 
     SkDrawableList* getDrawableList() const { return fDrawableList.get(); }
     std::unique_ptr<SkDrawableList> detachDrawableList() { return std::move(fDrawableList); }
 
     // Make SkRecorder forget entirely about its SkRecord*; all calls to SkRecorder will fail.
     void forgetRecord();
 
     void onFlush() override;
 
     void willSave() override;
     SaveLayerStrategy getSaveLayerStrategy(const SaveLayerRec&) override;
     bool onDoSaveBehind(const SkRect*) override;
     void willRestore() override {}
     void didRestore() override;
 
     void didConcat(const SkMatrix&) override;
     void didSetMatrix(const SkMatrix&) override;
     void didTranslate(SkScalar, SkScalar) override;
 
     void onDrawDRRect(const SkRRect&, const SkRRect&, const SkPaint&) override;
     void onDrawDrawable(SkDrawable*, const SkMatrix*) override;
     void onDrawTextBlob(const SkTextBlob* blob,
                         SkScalar x,
                         SkScalar y,
                         const SkPaint& paint) override;
     void onDrawPatch(const SkPoint cubics[12], const SkColor colors[4],
                      const SkPoint texCoords[4], SkBlendMode,
                      const SkPaint& paint) override;
 
     void onDrawPaint(const SkPaint&) override;
     void onDrawPoints(PointMode, size_t count, const SkPoint pts[], const SkPaint&) override;
     void onDrawRect(const SkRect&, const SkPaint&) override;
+    void onDrawEdgeAARect(const SkRect&, SkCanvas::QuadAAFlags, SkColor, SkBlendMode) override;
     void onDrawRegion(const SkRegion&, const SkPaint&) override;
     void onDrawOval(const SkRect&, const SkPaint&) override;
     void onDrawArc(const SkRect&, SkScalar, SkScalar, bool, const SkPaint&) override;
     void onDrawRRect(const SkRRect&, const SkPaint&) override;
     void onDrawPath(const SkPath&, const SkPaint&) override;
     void onDrawBitmap(const SkBitmap&, SkScalar left, SkScalar top, const SkPaint*) override;
     void onDrawBitmapRect(const SkBitmap&, const SkRect* src, const SkRect& dst, const SkPaint*,
                           SrcRectConstraint) override;
     void onDrawImage(const SkImage*, SkScalar left, SkScalar top, const SkPaint*) override;
     void onDrawImageRect(const SkImage*, const SkRect* src, const SkRect& dst,
                          const SkPaint*, SrcRectConstraint) override;
     void onDrawImageNine(const SkImage*, const SkIRect& center, const SkRect& dst,
                          const SkPaint*) override;
     void onDrawBitmapNine(const SkBitmap&, const SkIRect& center, const SkRect& dst,
                           const SkPaint*) override;
     void onDrawImageLattice(const SkImage*, const Lattice& lattice, const SkRect& dst,
                             const SkPaint*) override;
     void onDrawBitmapLattice(const SkBitmap&, const Lattice& lattice, const SkRect& dst,
                              const SkPaint*) override;
+    void onDrawImageSet(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality,
+                        SkBlendMode) override;
     void onDrawVerticesObject(const SkVertices*, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode, const SkPaint&) override;
     void onDrawAtlas(const SkImage*, const SkRSXform[], const SkRect[], const SkColor[],
                      int count, SkBlendMode, const SkRect* cull, const SkPaint*) override;
     void onDrawShadowRec(const SkPath&, const SkDrawShadowRec&) override;
 
     void onClipRect(const SkRect& rect, SkClipOp, ClipEdgeStyle) override;
     void onClipRRect(const SkRRect& rrect, SkClipOp, ClipEdgeStyle) override;
     void onClipPath(const SkPath& path, SkClipOp, ClipEdgeStyle) override;
     void onClipRegion(const SkRegion& deviceRgn, SkClipOp) override;
 
     void onDrawPicture(const SkPicture*, const SkMatrix*, const SkPaint*) override;
 
     void onDrawAnnotation(const SkRect&, const char[], SkData*) override;
 
-    void onDrawEdgeAAQuad(const SkRect&, const SkPoint[4], QuadAAFlags, SkColor,
-                          SkBlendMode) override;
-    void onDrawEdgeAAImageSet(const ImageSetEntry[], int count, const SkPoint[], const SkMatrix[],
-                              const SkPaint*, SrcRectConstraint) override;
-
     sk_sp<SkSurface> onNewSurface(const SkImageInfo&, const SkSurfaceProps&) override;
 
     void flushMiniRecorder();
diff --git a/src/core/SkRecords.h b/src/core/SkRecords.h
index 6612a06b88..8f80924ab4 100644
--- a/src/core/SkRecords.h
+++ b/src/core/SkRecords.h
@@ -28,53 +28,52 @@
 namespace SkRecords {
 
 // A list of all the types of canvas calls we can record.
 // Each of these is reified into a struct below.
 //
 // (We're using the macro-of-macro trick here to do several different things with the same list.)
 //
 // We leave this SK_RECORD_TYPES macro defined for use by code that wants to operate on SkRecords
 // types polymorphically.  (See SkRecord::Record::{visit,mutate} for an example.)
 //
 // Order doesn't technically matter here, but the compiler can generally generate better code if
 // you keep them semantically grouped, especially the Draws.  It's also nice to leave NoOp at 0.
 #define SK_RECORD_TYPES(M)                                          \
     M(NoOp)                                                         \
     M(Flush)                                                        \
     M(Restore)                                                      \
     M(Save)                                                         \
     M(SaveLayer)                                                    \
     M(SaveBehind)                                                   \
     M(SetMatrix)                                                    \
     M(Translate)                                                    \
     M(Concat)                                                       \
     M(ClipPath)                                                     \
     M(ClipRRect)                                                    \
     M(ClipRect)                                                     \
     M(ClipRegion)                                                   \
     M(DrawArc)                                                      \
     M(DrawDrawable)                                                 \
     M(DrawImage)                                                    \
     M(DrawImageLattice)                                             \
     M(DrawImageRect)                                                \
     M(DrawImageNine)                                                \
+    M(DrawImageSet)                                                 \
     M(DrawDRRect)                                                   \
     M(DrawOval)                                                     \
     M(DrawPaint)                                                    \
     M(DrawPath)                                                     \
     M(DrawPatch)                                                    \
     M(DrawPicture)                                                  \
     M(DrawPoints)                                                   \
     M(DrawRRect)                                                    \
     M(DrawRect)                                                     \
+    M(DrawEdgeAARect)                                               \
     M(DrawRegion)                                                   \
     M(DrawTextBlob)                                                 \
     M(DrawAtlas)                                                    \
     M(DrawVertices)                                                 \
     M(DrawShadowRec)                                                \
-    M(DrawAnnotation)                                               \
-    M(DrawEdgeAAQuad)                                               \
-    M(DrawEdgeAAImageSet)
-
+    M(DrawAnnotation)
 
 // Defines SkRecords::Type, an enum of all record types.
 #define ENUM(T) T##_Type,
@@ -259,7 +258,12 @@ RECORD(DrawImageNine, kDraw_Tag|kHasImage_Tag|kHasPaint_Tag,
         Optional<SkPaint> paint;
         sk_sp<const SkImage> image;
         SkIRect center;
         SkRect dst);
+RECORD(DrawImageSet, kDraw_Tag|kHasImage_Tag,
+       SkAutoTArray<SkCanvas::ImageSetEntry> set;
+       int count;
+       SkFilterQuality quality;
+       SkBlendMode mode);
 RECORD(DrawOval, kDraw_Tag|kHasPaint_Tag,
         SkPaint paint;
         SkRect oval);
@@ -283,6 +287,11 @@ RECORD(DrawRRect, kDraw_Tag|kHasPaint_Tag,
 RECORD(DrawRect, kDraw_Tag|kHasPaint_Tag,
         SkPaint paint;
         SkRect rect);
+RECORD(DrawEdgeAARect, kDraw_Tag,
+       SkRect rect;
+       SkCanvas::QuadAAFlags aa;
+       SkColor color;
+       SkBlendMode mode);
 RECORD(DrawRegion, kDraw_Tag|kHasPaint_Tag,
         SkPaint paint;
         SkRegion region);
@@ -319,21 +328,8 @@ RECORD(DrawAnnotation, 0,  // TODO: kDraw_Tag, skia:5548
        SkRect rect;
        SkString key;
        sk_sp<SkData> value);
-RECORD(DrawEdgeAAQuad, kDraw_Tag,
-       SkRect rect;
-       PODArray<SkPoint> clip;
-       SkCanvas::QuadAAFlags aa;
-       SkColor color;
-       SkBlendMode mode);
-RECORD(DrawEdgeAAImageSet, kDraw_Tag|kHasImage_Tag|kHasPaint_Tag,
-       Optional<SkPaint> paint;
-       SkAutoTArray<SkCanvas::ImageSetEntry> set;
-       int count;
-       PODArray<SkPoint> dstClips;
-       PODArray<SkMatrix> preViewMatrices;
-       SkCanvas::SrcRectConstraint constraint);
 #undef RECORD
 
 }  // namespace SkRecords
 
 #endif//SkRecords_DEFINED
diff --git a/src/gpu/SkGpuDevice.cpp b/src/gpu/SkGpuDevice.cpp
index aa40a3d552..0e0efb4c0d 100644
--- a/src/gpu/SkGpuDevice.cpp
+++ b/src/gpu/SkGpuDevice.cpp
@@ -397,33 +397,43 @@ void SkGpuDevice::drawRect(const SkRect& rect, const SkPaint& paint) {
                                    this->ctm(), rect, &style);
 }
 
-void SkGpuDevice::drawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                 SkCanvas::QuadAAFlags aaFlags, SkColor color, SkBlendMode mode) {
+void SkGpuDevice::drawEdgeAARect(const SkRect& r, SkCanvas::QuadAAFlags aa, SkColor color,
+                                 SkBlendMode mode) {
+    this->tmp_drawEdgeAAQuad(r, nullptr, 0, aa, color, mode);
+}
+
+void SkGpuDevice::tmp_drawEdgeAAQuad(const SkRect& rect, const SkPoint clip[], int clipCount,
+                                     SkCanvas::QuadAAFlags aaFlags, SkColor color,
+                                     SkBlendMode mode) {
     ASSERT_SINGLE_OWNER
-    GR_CREATE_TRACE_MARKER_CONTEXT("SkGpuDevice", "drawEdgeAAQuad", fContext.get());
+    GR_CREATE_TRACE_MARKER_CONTEXT("SkGpuDevice", "tmp_drawEdgeAAQuad", fContext.get());
+
+    // Only no clip or a quad clip is currently supported
+    SkASSERT(clipCount == 0 || clipCount == 4);
+    SkASSERT(clipCount == 0 || clip);
 
     SkPMColor4f dstColor = SkColor4fPrepForDst(SkColor4f::FromColor(color),
                                               fRenderTargetContext->colorSpaceInfo(),
                                               *fContext->priv().caps())
                            .premul();
 
     GrPaint grPaint;
     grPaint.setColor4f(dstColor);
     if (mode != SkBlendMode::kSrcOver) {
         grPaint.setXPFactory(SkBlendMode_AsXPFactory(mode));
     }
 
     // This is exclusively meant for tiling operations, so keep AA enabled to handle MSAA seaming
     GrQuadAAFlags grAA = SkToGrQuadAAFlags(aaFlags);
-    if (clip) {
+    if (clipCount > 0) {
         // Use fillQuadWithEdgeAA
         fRenderTargetContext->fillQuadWithEdgeAA(this->clip(), std::move(grPaint), GrAA::kYes, grAA,
                                                  this->ctm(), clip, nullptr);
     } else {
         // Use fillRectWithEdgeAA to preserve mathematical properties of dst being rectangular
         fRenderTargetContext->fillRectWithEdgeAA(this->clip(), std::move(grPaint), GrAA::kYes, grAA,
                                                  this->ctm(), rect);
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -1394,6 +1404,16 @@ void SkGpuDevice::drawBitmapLattice(const SkBitmap& bitmap,
     this->drawProducerLattice(&maker, std::move(iter), dst, paint);
 }
 
+void SkGpuDevice::drawImageSet(const SkCanvas::ImageSetEntry set[], int count,
+                               SkFilterQuality filterQuality, SkBlendMode mode) {
+    SkPaint paint;
+    paint.setBlendMode(mode);
+    paint.setFilterQuality(filterQuality);
+    paint.setAntiAlias(true);
+    this->tmp_drawImageSetV3(set, nullptr, nullptr, count, nullptr, nullptr, paint,
+                             SkCanvas::kFast_SrcRectConstraint);
+}
+
 static bool init_vertices_paint(GrContext* context, const GrColorSpaceInfo& colorSpaceInfo,
                                 const SkPaint& skPaint, const SkMatrix& matrix, SkBlendMode bmode,
                                 bool hasTexs, bool hasColors, GrPaint* grPaint) {
diff --git a/src/gpu/SkGpuDevice.h b/src/gpu/SkGpuDevice.h
index 21072a6518..b41b8c894e 100644
--- a/src/gpu/SkGpuDevice.h
+++ b/src/gpu/SkGpuDevice.h
@@ -35,99 +35,110 @@ class SkGpuDevice : public SkClipStackDevice {
 public:
     enum InitContents {
         kClear_InitContents,
         kUninit_InitContents
     };
 
     /**
      * Creates an SkGpuDevice from a GrRenderTargetContext whose backing width/height is
      * different than its actual width/height (e.g., approx-match scratch texture).
      */
     static sk_sp<SkGpuDevice> Make(GrContext*, sk_sp<GrRenderTargetContext> renderTargetContext,
                                    int width, int height, InitContents);
 
     /**
      * New device that will create an offscreen renderTarget based on the ImageInfo and
      * sampleCount. The mipMapped flag tells the gpu to create the underlying render target with
      * mips. The Budgeted param controls whether the device's backing store counts against the
      * resource cache budget. On failure, returns nullptr.
      * This entry point creates a kExact backing store. It is used when creating SkGpuDevices
      * for SkSurfaces.
      */
     static sk_sp<SkGpuDevice> Make(GrContext*, SkBudgeted, const SkImageInfo&,
                                    int sampleCount, GrSurfaceOrigin, const SkSurfaceProps*,
                                    GrMipMapped mipMapped, InitContents);
 
     ~SkGpuDevice() override {}
 
     GrContext* context() const override { return fContext.get(); }
 
     // set all pixels to 0
     void clearAll();
 
     void replaceRenderTargetContext(bool shouldRetainContent);
 
     GrRenderTargetContext* accessRenderTargetContext() override;
 
     void drawPaint(const SkPaint& paint) override;
     void drawPoints(SkCanvas::PointMode mode, size_t count, const SkPoint[],
                     const SkPaint& paint) override;
     void drawRect(const SkRect& r, const SkPaint& paint) override;
+    void drawEdgeAARect(const SkRect& r, SkCanvas::QuadAAFlags edgeAA, SkColor color,
+                        SkBlendMode mode) override;
     void drawRRect(const SkRRect& r, const SkPaint& paint) override;
     void drawDRRect(const SkRRect& outer, const SkRRect& inner, const SkPaint& paint) override;
     void drawRegion(const SkRegion& r, const SkPaint& paint) override;
     void drawOval(const SkRect& oval, const SkPaint& paint) override;
     void drawArc(const SkRect& oval, SkScalar startAngle, SkScalar sweepAngle,
                  bool useCenter, const SkPaint& paint) override;
     void drawPath(const SkPath& path, const SkPaint& paint, bool pathIsMutable) override;
     void drawBitmapRect(const SkBitmap&, const SkRect* srcOrNull, const SkRect& dst,
                         const SkPaint& paint, SkCanvas::SrcRectConstraint) override;
     void drawSprite(const SkBitmap& bitmap, int x, int y,
                     const SkPaint& paint) override;
     void drawGlyphRunList(const SkGlyphRunList& glyphRunList) override;
     void drawVertices(const SkVertices*, const SkVertices::Bone bones[], int boneCount, SkBlendMode,
                       const SkPaint&) override;
     void drawShadow(const SkPath&, const SkDrawShadowRec&) override;
     void drawAtlas(const SkImage* atlas, const SkRSXform[], const SkRect[],
                    const SkColor[], int count, SkBlendMode, const SkPaint&) override;
     void drawDevice(SkBaseDevice*, int x, int y, const SkPaint&) override;
 
     void drawImageRect(const SkImage*, const SkRect* src, const SkRect& dst,
                        const SkPaint&, SkCanvas::SrcRectConstraint) override;
 
     void drawImageNine(const SkImage* image, const SkIRect& center,
                        const SkRect& dst, const SkPaint& paint) override;
     void drawBitmapNine(const SkBitmap& bitmap, const SkIRect& center,
                         const SkRect& dst, const SkPaint& paint) override;
 
     void drawImageLattice(const SkImage*, const SkCanvas::Lattice&,
                           const SkRect& dst, const SkPaint&) override;
     void drawBitmapLattice(const SkBitmap&, const SkCanvas::Lattice&,
                            const SkRect& dst, const SkPaint&) override;
+    void drawImageSet(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality,
+                      SkBlendMode) override;
 
     void drawDrawable(SkDrawable*, const SkMatrix*, SkCanvas* canvas) override;
 
     void drawSpecial(SkSpecialImage*, int left, int top, const SkPaint& paint,
                      SkImage*, const SkMatrix&) override;
-
-    void drawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                        SkCanvas::QuadAAFlags aaFlags, SkColor color, SkBlendMode mode) override;
-    void drawEdgeAAImageSet(const SkCanvas::ImageSetEntry[], int count, const SkPoint dstClips[],
-                            const SkMatrix[], const SkPaint&, SkCanvas::SrcRectConstraint) override;
-
     sk_sp<SkSpecialImage> makeSpecial(const SkBitmap&) override;
     sk_sp<SkSpecialImage> makeSpecial(const SkImage*) override;
     sk_sp<SkSpecialImage> snapSpecial() override;
     sk_sp<SkSpecialImage> snapBackImage(const SkIRect&) override;
 
     void flush() override;
     GrSemaphoresSubmitted flushAndSignalSemaphores(SkSurface::BackendSurfaceAccess access,
                                                    SkSurface::FlushFlags flags,
                                                    int numSemaphores,
                                                    GrBackendSemaphore signalSemaphores[]);
     bool wait(int numSemaphores, const GrBackendSemaphore* waitSemaphores);
 
     bool onAccessPixels(SkPixmap*) override;
 
+    // Temporary interface until it gets lifted up to SkDevice and exposed in SkCanvas
+
+    /*
+     * dstClipCounts[] is a parallel array to the image entries, acting like the intended
+     * dstClipCount field in ImageSetEntry. Similarly, preViewMatrixIdx is parallel and will
+     * become an index field in ImageSetEntry that specifies an entry in the matrix array.
+     */
+    void tmp_drawImageSetV3(const SkCanvas::ImageSetEntry[],
+            int dstClipCounts[], int preViewMatrixIdx[], int count,
+            const SkPoint dstClips[], const SkMatrix preViewMatrices[], const SkPaint& paint,
+            SkCanvas::SrcRectConstraint constraint = SkCanvas::kStrict_SrcRectConstraint);
+    void tmp_drawEdgeAAQuad(const SkRect& rect, const SkPoint clip[], int clipCount,
+                            SkCanvas::QuadAAFlags aaFlags, SkColor color, SkBlendMode mode);
 protected:
     bool onReadPixels(const SkPixmap&, int, int) override;
     bool onWritePixels(const SkPixmap&, int, int) override;
diff --git a/src/gpu/SkGpuDevice_drawTexture.cpp b/src/gpu/SkGpuDevice_drawTexture.cpp
index d23097c46e..8c280d5de1 100644
--- a/src/gpu/SkGpuDevice_drawTexture.cpp
+++ b/src/gpu/SkGpuDevice_drawTexture.cpp
@@ -454,111 +454,119 @@ void SkGpuDevice::drawImageQuad(const SkImage* image, const SkRect* srcRect, con
     // Otherwise don't know how to draw it
 }
 
-void SkGpuDevice::drawEdgeAAImageSet(const SkCanvas::ImageSetEntry set[], int count,
-                                     const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                                     const SkPaint& paint, SkCanvas::SrcRectConstraint constraint) {
+// For ease-of-use, the temporary API treats null dstClipCounts as if it were the proper sized
+// array, filled with all 0s (so dstClips can be null too)
+void SkGpuDevice::tmp_drawImageSetV3(const SkCanvas::ImageSetEntry set[], int dstClipCounts[],
+                                     int preViewMatrixIdx[], int count, const SkPoint dstClips[],
+                                     const SkMatrix preViewMatrices[], const SkPaint& paint,
+                                     SkCanvas::SrcRectConstraint constraint) {
     SkASSERT(count > 0);
 
     if (!can_use_draw_texture(paint)) {
         // Send every entry through drawImageQuad() to handle the more complicated paint
         int dstClipIndex = 0;
         for (int i = 0; i < count; ++i) {
             // Only no clip or quad clip are supported
-            SkASSERT(!set[i].fHasClip || dstClips);
-            SkASSERT(set[i].fMatrixIndex < 0 || preViewMatrices);
+            SkASSERT(!dstClipCounts || dstClipCounts[i] == 0 || dstClipCounts[i] == 4);
+
+            int xform = preViewMatrixIdx ? preViewMatrixIdx[i] : -1;
+            SkASSERT(xform < 0 || preViewMatrices);
 
             // Always send GrAA::kYes to preserve seaming across tiling in MSAA
             this->drawImageQuad(set[i].fImage.get(), &set[i].fSrcRect, &set[i].fDstRect,
-                    set[i].fHasClip ? dstClips + dstClipIndex : nullptr,
+                    (dstClipCounts && dstClipCounts[i] > 0) ? dstClips + dstClipIndex : nullptr,
                     GrAA::kYes, SkToGrQuadAAFlags(set[i].fAAFlags),
-                    set[i].fMatrixIndex < 0 ? nullptr : preViewMatrices + set[i].fMatrixIndex,
-                    paint, constraint);
-            dstClipIndex += 4 * set[i].fHasClip;
+                    xform < 0 ? nullptr : preViewMatrices + xform, paint, constraint);
+            if (dstClipCounts) {
+                dstClipIndex += dstClipCounts[i];
+            }
         }
         return;
     }
 
     GrSamplerState::Filter filter = kNone_SkFilterQuality == paint.getFilterQuality() ?
             GrSamplerState::Filter::kNearest : GrSamplerState::Filter::kBilerp;
     SkBlendMode mode = paint.getBlendMode();
 
     SkAutoTArray<GrRenderTargetContext::TextureSetEntry> textures(count);
     // We accumulate compatible proxies until we find an an incompatible one or reach the end and
     // issue the accumulated 'n' draws starting at 'base'.
     int base = 0, n = 0;
     auto draw = [&] {
         if (n > 0) {
             auto textureXform = GrColorSpaceXform::Make(
                     set[base].fImage->colorSpace(), set[base].fImage->alphaType(),
                     fRenderTargetContext->colorSpaceInfo().colorSpace(), kPremul_SkAlphaType);
             fRenderTargetContext->drawTextureSet(this->clip(), textures.get() + base, n,
                                                  filter, mode, GrAA::kYes, this->ctm(),
                                                  std::move(textureXform));
         }
     };
     int dstClipIndex = 0;
     for (int i = 0; i < count; ++i) {
         // Manage the dst clip pointer tracking before any continues are used so we don't lose
         // our place in the dstClips array.
-        SkASSERT(!set[i].fHasClip || dstClips);
-        const SkPoint* clip = set[i].fHasClip ? dstClips + dstClipIndex : nullptr;
-        dstClipIndex += 4 * set[i].fHasClip;
-
+        int clipCount = (dstClipCounts ? dstClipCounts[i] : 0);
+        SkASSERT(clipCount == 0 || (dstClipCounts[i] == 4 && dstClips));
+        const SkPoint* clip = clipCount > 0 ? dstClips + dstClipIndex : nullptr;
+        if (dstClipCounts) {
+            dstClipIndex += dstClipCounts[i];
+        }
         // The default SkBaseDevice implementation is based on drawImageRect which does not allow
         // non-sorted src rects. TODO: Decide this is OK or make sure we handle it.
         if (!set[i].fSrcRect.isSorted()) {
             draw();
             base = i + 1;
             n = 0;
             continue;
         }
 
         uint32_t uniqueID;
         textures[i].fProxy = as_IB(set[i].fImage.get())->refPinnedTextureProxy(this->context(),
                                                                                &uniqueID);
         if (!textures[i].fProxy) {
             // FIXME(michaelludwig) - If asTextureProxyRef fails, does going through drawImageQuad
             // make sense? Does that catch the lazy-image cases then?
             // FIXME(michaelludwig) - Both refPinnedTextureProxy and asTextureProxyRef for YUVA
             // images force flatten the planes. It would be nice to detect a YUVA image entry and
             // send it to drawImageQuad (which uses a special effect for YUV)
             textures[i].fProxy =
                     as_IB(set[i].fImage.get())
                             ->asTextureProxyRef(fContext.get(), GrSamplerState::ClampBilerp(),
                                                 nullptr);
             // If we failed to make a proxy then flush the accumulated set and reset for the next
             // image.
             if (!textures[i].fProxy) {
                 draw();
                 base = i + 1;
                 n = 0;
                 continue;
             }
         }
 
-        SkASSERT(set[i].fMatrixIndex < 0 || preViewMatrices);
+        int xform = preViewMatrixIdx ? preViewMatrixIdx[i] : -1;
+        SkASSERT(xform < 0 || preViewMatrices);
 
         textures[i].fSrcRect = set[i].fSrcRect;
         textures[i].fDstRect = set[i].fDstRect;
         textures[i].fDstClipQuad = clip;
-        textures[i].fPreViewMatrix =
-                set[i].fMatrixIndex < 0 ? nullptr : preViewMatrices + set[i].fMatrixIndex;
+        textures[i].fPreViewMatrix = xform < 0 ? nullptr : preViewMatrices + xform;
         textures[i].fAlpha = set[i].fAlpha * paint.getAlphaf();
         textures[i].fAAFlags = SkToGrQuadAAFlags(set[i].fAAFlags);
 
         if (n > 0 &&
             (!GrTextureProxy::ProxiesAreCompatibleAsDynamicState(textures[i].fProxy.get(),
                                                                  textures[base].fProxy.get()) ||
              set[i].fImage->alphaType() != set[base].fImage->alphaType() ||
              !SkColorSpace::Equals(set[i].fImage->colorSpace(), set[base].fImage->colorSpace()))) {
             draw();
             base = i;
             n = 1;
         } else {
             ++n;
         }
     }
     draw();
 }
 
 // TODO (michaelludwig) - to be removed when drawBitmapRect doesn't need it anymore
diff --git a/src/utils/SkNWayCanvas.cpp b/src/utils/SkNWayCanvas.cpp
index 39d5a402ba..1e6cd89083 100644
--- a/src/utils/SkNWayCanvas.cpp
+++ b/src/utils/SkNWayCanvas.cpp
@@ -162,6 +162,14 @@ void SkNWayCanvas::onDrawRect(const SkRect& rect, const SkPaint& paint) {
     }
 }
 
+void SkNWayCanvas::onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa, SkColor color,
+                                    SkBlendMode mode) {
+    Iter iter(fList);
+    while (iter.next()) {
+        iter->experimental_DrawEdgeAARectV1(rect, aa, color, mode);
+    }
+}
+
 void SkNWayCanvas::onDrawRegion(const SkRegion& region, const SkPaint& paint) {
     Iter iter(fList);
     while (iter.next()) {
@@ -269,6 +277,14 @@ void SkNWayCanvas::onDrawImageLattice(const SkImage* image, const Lattice& latti
     }
 }
 
+void SkNWayCanvas::onDrawImageSet(const SkCanvas::ImageSetEntry set[], int count,
+                                  SkFilterQuality filterQuality, SkBlendMode mode) {
+    Iter iter(fList);
+    while (iter.next()) {
+        iter->experimental_DrawImageSetV1(set, count, filterQuality, mode);
+    }
+}
+
 void SkNWayCanvas::onDrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                                   const SkPaint &paint) {
     Iter iter(fList);
@@ -332,24 +348,6 @@ void SkNWayCanvas::onDrawAnnotation(const SkRect& rect, const char key[], SkData
     }
 }
 
-void SkNWayCanvas::onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                    QuadAAFlags aa, SkColor color, SkBlendMode mode) {
-    Iter iter(fList);
-    while (iter.next()) {
-        iter->experimental_DrawEdgeAAQuad(rect, clip, aa, color, mode);
-    }
-}
-
-void SkNWayCanvas::onDrawEdgeAAImageSet(const ImageSetEntry set[], int count,
-                                        const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                                        const SkPaint* paint, SrcRectConstraint constraint) {
-    Iter iter(fList);
-    while (iter.next()) {
-        iter->experimental_DrawEdgeAAImageSet(
-                set, count, dstClips, preViewMatrices, paint, constraint);
-    }
-}
-
 void SkNWayCanvas::onFlush() {
     Iter iter(fList);
     while (iter.next()) {
diff --git a/src/utils/SkPaintFilterCanvas.cpp b/src/utils/SkPaintFilterCanvas.cpp
index f09e6c2ea7..ded7fc2fba 100644
--- a/src/utils/SkPaintFilterCanvas.cpp
+++ b/src/utils/SkPaintFilterCanvas.cpp
@@ -64,6 +64,17 @@ void SkPaintFilterCanvas::onDrawRect(const SkRect& rect, const SkPaint& paint) {
     }
 }
 
+void SkPaintFilterCanvas::onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa,
+                                           SkColor color, SkBlendMode mode) {
+    SkPaint paint;
+    paint.setColor(color);
+    paint.setBlendMode(mode);
+    AutoPaintFilter apf(this, kRect_Type, paint);
+    if (apf.shouldDraw()) {
+        this->SkNWayCanvas::onDrawEdgeAARect(rect, aa, paint.getColor(), paint.getBlendMode());
+    }
+}
+
 void SkPaintFilterCanvas::onDrawRRect(const SkRRect& rrect, const SkPaint& paint) {
     AutoPaintFilter apf(this, kRRect_Type, paint);
     if (apf.shouldDraw()) {
@@ -173,6 +184,17 @@ void SkPaintFilterCanvas::onDrawImageLattice(const SkImage* image, const Lattice
     }
 }
 
+void SkPaintFilterCanvas::onDrawImageSet(const SkCanvas::ImageSetEntry set[], int count,
+                                         SkFilterQuality filterQuality, SkBlendMode mode) {
+    SkPaint paint;
+    paint.setBlendMode(mode);
+    AutoPaintFilter apf(this, kBitmap_Type, &paint);
+    mode = paint.getBlendMode();
+    if (apf.shouldDraw()) {
+        this->SkNWayCanvas::onDrawImageSet(set, count, filterQuality, mode);
+    }
+}
+
 void SkPaintFilterCanvas::onDrawVerticesObject(const SkVertices* vertices,
                                                const SkVertices::Bone bones[], int boneCount,
                                                SkBlendMode bmode, const SkPaint& paint) {
@@ -234,29 +256,6 @@ void SkPaintFilterCanvas::onDrawShadowRec(const SkPath& path, const SkDrawShadow
     this->SkNWayCanvas::onDrawShadowRec(path, rec);
 }
 
-void SkPaintFilterCanvas::onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                           QuadAAFlags aa, SkColor color, SkBlendMode mode) {
-    SkPaint paint;
-    paint.setColor(color);
-    paint.setBlendMode(mode);
-    AutoPaintFilter apf(this, kRect_Type, paint);
-    if (apf.shouldDraw()) {
-        this->SkNWayCanvas::onDrawEdgeAAQuad(rect, clip, aa, apf.paint()->getColor(),
-                                             apf.paint()->getBlendMode());
-    }
-}
-
-void SkPaintFilterCanvas::onDrawEdgeAAImageSet(const ImageSetEntry set[], int count,
-                                               const SkPoint dstClips[],
-                                               const SkMatrix preViewMatrices[],
-                                               const SkPaint* paint, SrcRectConstraint constraint) {
-    AutoPaintFilter apf(this, kBitmap_Type, paint);
-    if (apf.shouldDraw()) {
-        this->SkNWayCanvas::onDrawEdgeAAImageSet(
-                set, count, dstClips, preViewMatrices, apf.paint(), constraint);
-    }
-}
-
 sk_sp<SkSurface> SkPaintFilterCanvas::onNewSurface(const SkImageInfo& info,
                                                    const SkSurfaceProps& props) {
     return proxy()->makeSurface(info, &props);
diff --git a/tools/debugger/SkDebugCanvas.cpp b/tools/debugger/SkDebugCanvas.cpp
index 7580dc6612..45eaf96f7c 100644
--- a/tools/debugger/SkDebugCanvas.cpp
+++ b/tools/debugger/SkDebugCanvas.cpp
@@ -362,6 +362,11 @@ void SkDebugCanvas::onDrawImageNine(const SkImage* image, const SkIRect& center,
     this->addDrawCommand(new SkDrawImageNineCommand(image, center, dst, paint));
 }
 
+void SkDebugCanvas::onDrawImageSet(const SkCanvas::ImageSetEntry set[], int count,
+                                   SkFilterQuality filterQuality, SkBlendMode mode) {
+    this->addDrawCommand(new SkDrawImageSetCommand(set, count, filterQuality, mode));
+}
+
 void SkDebugCanvas::onDrawOval(const SkRect& oval, const SkPaint& paint) {
     this->addDrawCommand(new SkDrawOvalCommand(oval, paint));
 }
@@ -402,6 +407,11 @@ void SkDebugCanvas::onDrawRect(const SkRect& rect, const SkPaint& paint) {
     addDrawCommand(new SkDrawRectCommand(rect, paint));
 }
 
+void SkDebugCanvas::onDrawEdgeAARect(const SkRect& rect, SkCanvas::QuadAAFlags aa, SkColor color,
+                                     SkBlendMode mode) {
+    this->addDrawCommand(new SkDrawEdgeAARectCommand(rect, aa, color, mode));
+}
+
 void SkDebugCanvas::onDrawRRect(const SkRRect& rrect, const SkPaint& paint) {
     this->addDrawCommand(new SkDrawRRectCommand(rrect, paint));
 }
@@ -445,18 +455,6 @@ void SkDebugCanvas::onDrawDrawable(SkDrawable* drawable, const SkMatrix* matrix)
     this->addDrawCommand(new SkDrawDrawableCommand(drawable, matrix));
 }
 
-void SkDebugCanvas::onDrawEdgeAAQuad(const SkRect& rect, const SkPoint clip[4],
-                                     QuadAAFlags aa, SkColor color, SkBlendMode mode) {
-    this->addDrawCommand(new SkDrawEdgeAAQuadCommand(rect, clip, aa, color, mode));
-}
-
-void SkDebugCanvas::onDrawEdgeAAImageSet(const ImageSetEntry set[], int count,
-                                         const SkPoint dstClips[], const SkMatrix preViewMatrices[],
-                                         const SkPaint* paint, SrcRectConstraint constraint) {
-    this->addDrawCommand(new SkDrawEdgeAAImageSetCommand(set, count, dstClips, preViewMatrices,
-                                                         paint, constraint));
-}
-
 void SkDebugCanvas::willRestore() {
     this->addDrawCommand(new SkRestoreCommand());
     this->INHERITED::willRestore();
diff --git a/tools/debugger/SkDebugCanvas.h b/tools/debugger/SkDebugCanvas.h
index 56da424e02..9ae2950a35 100644
--- a/tools/debugger/SkDebugCanvas.h
+++ b/tools/debugger/SkDebugCanvas.h
@@ -116,61 +116,58 @@ public:
 protected:
     void willSave() override;
     SaveLayerStrategy getSaveLayerStrategy(const SaveLayerRec &) override;
     bool onDoSaveBehind(const SkRect*) override;
     void willRestore() override;
 
     void didConcat(const SkMatrix &) override;
 
     void didSetMatrix(const SkMatrix &) override;
 
     void onDrawAnnotation(const SkRect&, const char[], SkData*) override;
     void onDrawDRRect(const SkRRect&, const SkRRect&, const SkPaint&) override;
     void onDrawTextBlob(const SkTextBlob* blob, SkScalar x, SkScalar y,
                         const SkPaint& paint) override;
 
     void onDrawPatch(const SkPoint cubics[12], const SkColor colors[4],
                      const SkPoint texCoords[4], SkBlendMode, const SkPaint& paint) override;
     void onDrawPaint(const SkPaint&) override;
 
     void onDrawRect(const SkRect&, const SkPaint&) override;
+    void onDrawEdgeAARect(const SkRect&, SkCanvas::QuadAAFlags, SkColor, SkBlendMode) override;
     void onDrawOval(const SkRect&, const SkPaint&) override;
     void onDrawArc(const SkRect&, SkScalar, SkScalar, bool, const SkPaint&) override;
     void onDrawRRect(const SkRRect&, const SkPaint&) override;
     void onDrawPoints(PointMode, size_t count, const SkPoint pts[], const SkPaint&) override;
     void onDrawVerticesObject(const SkVertices*, const SkVertices::Bone bones[], int boneCount,
                               SkBlendMode, const SkPaint&) override;
     void onDrawPath(const SkPath&, const SkPaint&) override;
     void onDrawRegion(const SkRegion&, const SkPaint&) override;
     void onDrawBitmap(const SkBitmap&, SkScalar left, SkScalar top, const SkPaint*) override;
     void onDrawBitmapLattice(const SkBitmap&, const Lattice&, const SkRect&,
                              const SkPaint*) override;
     void onDrawBitmapRect(const SkBitmap&, const SkRect* src, const SkRect& dst, const SkPaint*,
                           SrcRectConstraint) override;
     void onDrawImage(const SkImage*, SkScalar left, SkScalar top, const SkPaint*) override;
     void onDrawImageLattice(const SkImage* image, const Lattice& lattice,
                             const SkRect& dst, const SkPaint* paint) override;
     void onDrawImageRect(const SkImage*, const SkRect* src, const SkRect& dst,
                          const SkPaint*, SrcRectConstraint) override;
+    void onDrawImageSet(const ImageSetEntry[], int count, SkFilterQuality, SkBlendMode) override;
     void onDrawBitmapNine(const SkBitmap&, const SkIRect& center, const SkRect& dst,
                           const SkPaint*) override;
     void onDrawImageNine(const SkImage*, const SkIRect& center, const SkRect& dst,
                          const SkPaint*) override;
     void onDrawAtlas(const SkImage*, const SkRSXform[], const SkRect[], const SkColor[],
                      int, SkBlendMode, const SkRect*, const SkPaint*) override;
     void onClipRect(const SkRect&, SkClipOp, ClipEdgeStyle) override;
     void onClipRRect(const SkRRect&, SkClipOp, ClipEdgeStyle) override;
     void onClipPath(const SkPath&, SkClipOp, ClipEdgeStyle) override;
     void onClipRegion(const SkRegion& region, SkClipOp) override;
     void onDrawShadowRec(const SkPath&, const SkDrawShadowRec&) override;
 
     void onDrawDrawable(SkDrawable*, const SkMatrix*) override;
     void onDrawPicture(const SkPicture*, const SkMatrix*, const SkPaint*) override;
 
-    void onDrawEdgeAAQuad(const SkRect&, const SkPoint[4], QuadAAFlags, SkColor,
-                          SkBlendMode) override;
-    void onDrawEdgeAAImageSet(const ImageSetEntry[], int count, const SkPoint[], const SkMatrix[],
-                              const SkPaint*, SrcRectConstraint) override;
-
 private:
     SkTDArray<SkDrawCommand*> fCommandVector;
     SkMatrix fMatrix;
diff --git a/tools/debugger/SkDrawCommand.cpp b/tools/debugger/SkDrawCommand.cpp
index 347cc2651f..d9723acd7b 100644
--- a/tools/debugger/SkDrawCommand.cpp
+++ b/tools/debugger/SkDrawCommand.cpp
@@ -1,200 +1,199 @@
 /*
  * Copyright 2012 Google Inc.
  *
  * Use of this source code is governed by a BSD-style license that can be
  * found in the LICENSE file.
  */
 
 #include "SkDrawCommand.h"
 
 #include <algorithm>
 #include "SkAutoMalloc.h"
-#include "SkCanvasPriv.h"
 #include "SkClipOpPriv.h"
 #include "SkColorFilter.h"
 #include "SkDashPathEffect.h"
 #include "SkDrawable.h"
 #include "SkImageFilter.h"
 #include "SkJsonWriteBuffer.h"
 #include "SkLatticeIter.h"
 #include "SkMaskFilterBase.h"
 #include "SkPaintDefaults.h"
 #include "SkPathEffect.h"
 #include "SkPicture.h"
 #include "SkPngEncoder.h"
 #include "SkReadBuffer.h"
 #include "SkRectPriv.h"
 #include "SkShadowFlags.h"
 #include "SkTHash.h"
 #include "SkTextBlobPriv.h"
 #include "SkTypeface.h"
 #include "SkWriteBuffer.h"
 
 #define SKDEBUGCANVAS_ATTRIBUTE_COMMAND           "command"
 #define SKDEBUGCANVAS_ATTRIBUTE_VISIBLE           "visible"
 #define SKDEBUGCANVAS_ATTRIBUTE_MATRIX            "matrix"
 #define SKDEBUGCANVAS_ATTRIBUTE_DRAWDEPTHTRANS    "drawDepthTranslation"
 #define SKDEBUGCANVAS_ATTRIBUTE_COORDS            "coords"
 #define SKDEBUGCANVAS_ATTRIBUTE_EDGING            "edging"
 #define SKDEBUGCANVAS_ATTRIBUTE_HINTING           "hinting"
 #define SKDEBUGCANVAS_ATTRIBUTE_BOUNDS            "bounds"
 #define SKDEBUGCANVAS_ATTRIBUTE_PAINT             "paint"
 #define SKDEBUGCANVAS_ATTRIBUTE_OUTER             "outer"
 #define SKDEBUGCANVAS_ATTRIBUTE_INNER             "inner"
 #define SKDEBUGCANVAS_ATTRIBUTE_MODE              "mode"
 #define SKDEBUGCANVAS_ATTRIBUTE_POINTS            "points"
 #define SKDEBUGCANVAS_ATTRIBUTE_PATH              "path"
 #define SKDEBUGCANVAS_ATTRIBUTE_TEXT              "text"
 #define SKDEBUGCANVAS_ATTRIBUTE_COLOR             "color"
 #define SKDEBUGCANVAS_ATTRIBUTE_ALPHA             "alpha"
 #define SKDEBUGCANVAS_ATTRIBUTE_BLENDMODE         "blendMode"
 #define SKDEBUGCANVAS_ATTRIBUTE_STYLE             "style"
 #define SKDEBUGCANVAS_ATTRIBUTE_STROKEWIDTH       "strokeWidth"
 #define SKDEBUGCANVAS_ATTRIBUTE_STROKEMITER       "strokeMiter"
 #define SKDEBUGCANVAS_ATTRIBUTE_STROKEJOIN        "strokeJoin"
 #define SKDEBUGCANVAS_ATTRIBUTE_CAP               "cap"
 #define SKDEBUGCANVAS_ATTRIBUTE_ANTIALIAS         "antiAlias"
 #define SKDEBUGCANVAS_ATTRIBUTE_DITHER            "dither"
 #define SKDEBUGCANVAS_ATTRIBUTE_FAKEBOLDTEXT      "fakeBoldText"
 #define SKDEBUGCANVAS_ATTRIBUTE_LINEARTEXT        "linearText"
 #define SKDEBUGCANVAS_ATTRIBUTE_SUBPIXELTEXT      "subpixelText"
 #define SKDEBUGCANVAS_ATTRIBUTE_DEVKERNTEXT       "devKernText"
 #define SKDEBUGCANVAS_ATTRIBUTE_LCDRENDERTEXT     "lcdRenderText"
 #define SKDEBUGCANVAS_ATTRIBUTE_EMBEDDEDBITMAPTEXT "embeddedBitmapText"
 #define SKDEBUGCANVAS_ATTRIBUTE_AUTOHINTING       "forceAutoHinting"
 #define SKDEBUGCANVAS_ATTRIBUTE_REGION            "region"
 #define SKDEBUGCANVAS_ATTRIBUTE_REGIONOP          "op"
 #define SKDEBUGCANVAS_ATTRIBUTE_EDGESTYLE         "edgeStyle"
 #define SKDEBUGCANVAS_ATTRIBUTE_DEVICEREGION      "deviceRegion"
 #define SKDEBUGCANVAS_ATTRIBUTE_BLUR              "blur"
 #define SKDEBUGCANVAS_ATTRIBUTE_SIGMA             "sigma"
 #define SKDEBUGCANVAS_ATTRIBUTE_QUALITY           "quality"
 #define SKDEBUGCANVAS_ATTRIBUTE_TEXTSIZE          "textSize"
 #define SKDEBUGCANVAS_ATTRIBUTE_TEXTSCALEX        "textScaleX"
 #define SKDEBUGCANVAS_ATTRIBUTE_TEXTSKEWX         "textSkewX"
 #define SKDEBUGCANVAS_ATTRIBUTE_DASHING           "dashing"
 #define SKDEBUGCANVAS_ATTRIBUTE_INTERVALS         "intervals"
 #define SKDEBUGCANVAS_ATTRIBUTE_PHASE             "phase"
 #define SKDEBUGCANVAS_ATTRIBUTE_FILLTYPE          "fillType"
 #define SKDEBUGCANVAS_ATTRIBUTE_VERBS             "verbs"
 #define SKDEBUGCANVAS_ATTRIBUTE_NAME              "name"
 #define SKDEBUGCANVAS_ATTRIBUTE_DATA              "data"
 #define SKDEBUGCANVAS_ATTRIBUTE_VALUES            "values"
 #define SKDEBUGCANVAS_ATTRIBUTE_SHADER            "shader"
 #define SKDEBUGCANVAS_ATTRIBUTE_PATHEFFECT        "pathEffect"
 #define SKDEBUGCANVAS_ATTRIBUTE_MASKFILTER        "maskFilter"
 #define SKDEBUGCANVAS_ATTRIBUTE_XFERMODE          "xfermode"
 #define SKDEBUGCANVAS_ATTRIBUTE_LOOPER            "looper"
 #define SKDEBUGCANVAS_ATTRIBUTE_BACKDROP          "backdrop"
 #define SKDEBUGCANVAS_ATTRIBUTE_COLORFILTER       "colorfilter"
 #define SKDEBUGCANVAS_ATTRIBUTE_IMAGEFILTER       "imagefilter"
 #define SKDEBUGCANVAS_ATTRIBUTE_IMAGE             "image"
 #define SKDEBUGCANVAS_ATTRIBUTE_BITMAP            "bitmap"
 #define SKDEBUGCANVAS_ATTRIBUTE_SRC               "src"
 #define SKDEBUGCANVAS_ATTRIBUTE_DST               "dst"
 #define SKDEBUGCANVAS_ATTRIBUTE_CENTER            "center"
 #define SKDEBUGCANVAS_ATTRIBUTE_STRICT            "strict"
 #define SKDEBUGCANVAS_ATTRIBUTE_DESCRIPTION       "description"
 #define SKDEBUGCANVAS_ATTRIBUTE_X                 "x"
 #define SKDEBUGCANVAS_ATTRIBUTE_Y                 "y"
 #define SKDEBUGCANVAS_ATTRIBUTE_RUNS              "runs"
 #define SKDEBUGCANVAS_ATTRIBUTE_POSITIONS         "positions"
 #define SKDEBUGCANVAS_ATTRIBUTE_GLYPHS            "glyphs"
 #define SKDEBUGCANVAS_ATTRIBUTE_FONT              "font"
 #define SKDEBUGCANVAS_ATTRIBUTE_TYPEFACE          "typeface"
 #define SKDEBUGCANVAS_ATTRIBUTE_CUBICS            "cubics"
 #define SKDEBUGCANVAS_ATTRIBUTE_COLORS            "colors"
 #define SKDEBUGCANVAS_ATTRIBUTE_TEXTURECOORDS     "textureCoords"
 #define SKDEBUGCANVAS_ATTRIBUTE_FILTERQUALITY     "filterQuality"
 #define SKDEBUGCANVAS_ATTRIBUTE_STARTANGLE        "startAngle"
 #define SKDEBUGCANVAS_ATTRIBUTE_SWEEPANGLE        "sweepAngle"
 #define SKDEBUGCANVAS_ATTRIBUTE_USECENTER         "useCenter"
 #define SKDEBUGCANVAS_ATTRIBUTE_SHORTDESC         "shortDesc"
 #define SKDEBUGCANVAS_ATTRIBUTE_UNIQUE_ID         "uniqueID"
 #define SKDEBUGCANVAS_ATTRIBUTE_WIDTH             "width"
 #define SKDEBUGCANVAS_ATTRIBUTE_HEIGHT            "height"
 #define SKDEBUGCANVAS_ATTRIBUTE_ALPHA             "alpha"
 #define SKDEBUGCANVAS_ATTRIBUTE_LATTICE           "lattice"
 #define SKDEBUGCANVAS_ATTRIBUTE_LATTICEXCOUNT     "xCount"
 #define SKDEBUGCANVAS_ATTRIBUTE_LATTICEYCOUNT     "yCount"
 #define SKDEBUGCANVAS_ATTRIBUTE_LATTICEXDIVS      "xDivs"
 #define SKDEBUGCANVAS_ATTRIBUTE_LATTICEYDIVS      "yDivs"
 #define SKDEBUGCANVAS_ATTRIBUTE_LATTICEFLAGS      "flags"
 #define SKDEBUGCANVAS_ATTRIBUTE_ZPLANE            "zPlane"
 #define SKDEBUGCANVAS_ATTRIBUTE_LIGHTPOSITION     "lightPositions"
 #define SKDEBUGCANVAS_ATTRIBUTE_AMBIENTCOLOR      "ambientColor"
 #define SKDEBUGCANVAS_ATTRIBUTE_SPOTCOLOR         "spotColor"
 #define SKDEBUGCANVAS_ATTRIBUTE_LIGHTRADIUS       "lightRadius"
 
 #define SKDEBUGCANVAS_VERB_MOVE                   "move"
 #define SKDEBUGCANVAS_VERB_LINE                   "line"
 #define SKDEBUGCANVAS_VERB_QUAD                   "quad"
 #define SKDEBUGCANVAS_VERB_CUBIC                  "cubic"
 #define SKDEBUGCANVAS_VERB_CONIC                  "conic"
 #define SKDEBUGCANVAS_VERB_CLOSE                  "close"
 
 #define SKDEBUGCANVAS_STYLE_FILL                  "fill"
 #define SKDEBUGCANVAS_STYLE_STROKE                "stroke"
 #define SKDEBUGCANVAS_STYLE_STROKEANDFILL         "strokeAndFill"
 
 #define SKDEBUGCANVAS_POINTMODE_POINTS            "points"
 #define SKDEBUGCANVAS_POINTMODE_LINES             "lines"
 #define SKDEBUGCANVAS_POINTMODE_POLYGON           "polygon"
 
 #define SKDEBUGCANVAS_REGIONOP_DIFFERENCE         "difference"
 #define SKDEBUGCANVAS_REGIONOP_INTERSECT          "intersect"
 #define SKDEBUGCANVAS_REGIONOP_UNION              "union"
 #define SKDEBUGCANVAS_REGIONOP_XOR                "xor"
 #define SKDEBUGCANVAS_REGIONOP_REVERSE_DIFFERENCE "reverseDifference"
 #define SKDEBUGCANVAS_REGIONOP_REPLACE            "replace"
 
 #define SKDEBUGCANVAS_BLURSTYLE_NORMAL            "normal"
 #define SKDEBUGCANVAS_BLURSTYLE_SOLID             "solid"
 #define SKDEBUGCANVAS_BLURSTYLE_OUTER             "outer"
 #define SKDEBUGCANVAS_BLURSTYLE_INNER             "inner"
 
 #define SKDEBUGCANVAS_BLURQUALITY_LOW             "low"
 #define SKDEBUGCANVAS_BLURQUALITY_HIGH            "high"
 
 #define SKDEBUGCANVAS_FILLTYPE_WINDING            "winding"
 #define SKDEBUGCANVAS_FILLTYPE_EVENODD            "evenOdd"
 #define SKDEBUGCANVAS_FILLTYPE_INVERSEWINDING     "inverseWinding"
 #define SKDEBUGCANVAS_FILLTYPE_INVERSEEVENODD     "inverseEvenOdd"
 
 #define SKDEBUGCANVAS_CAP_BUTT                    "butt"
 #define SKDEBUGCANVAS_CAP_ROUND                   "round"
 #define SKDEBUGCANVAS_CAP_SQUARE                  "square"
 
 #define SKDEBUGCANVAS_MITER_JOIN                  "miter"
 #define SKDEBUGCANVAS_ROUND_JOIN                  "round"
 #define SKDEBUGCANVAS_BEVEL_JOIN                  "bevel"
 
 #define SKDEBUGCANVAS_COLORTYPE_ARGB4444          "ARGB4444"
 #define SKDEBUGCANVAS_COLORTYPE_RGBA8888          "RGBA8888"
 #define SKDEBUGCANVAS_COLORTYPE_BGRA8888          "BGRA8888"
 #define SKDEBUGCANVAS_COLORTYPE_565               "565"
 #define SKDEBUGCANVAS_COLORTYPE_GRAY8             "Gray8"
 #define SKDEBUGCANVAS_COLORTYPE_INDEX8            "Index8"
 #define SKDEBUGCANVAS_COLORTYPE_ALPHA8            "Alpha8"
 
 #define SKDEBUGCANVAS_ALPHATYPE_OPAQUE            "opaque"
 #define SKDEBUGCANVAS_ALPHATYPE_PREMUL            "premul"
 #define SKDEBUGCANVAS_ALPHATYPE_UNPREMUL          "unpremul"
 #define SKDEBUGCANVAS_ALPHATYPE_UNKNOWN           "unknown"
 
 #define SKDEBUGCANVAS_FILTERQUALITY_NONE          "none"
 #define SKDEBUGCANVAS_FILTERQUALITY_LOW           "low"
 #define SKDEBUGCANVAS_FILTERQUALITY_MEDIUM        "medium"
 #define SKDEBUGCANVAS_FILTERQUALITY_HIGH          "high"
 
 #define SKDEBUGCANVAS_HINTING_NONE                "none"
 #define SKDEBUGCANVAS_HINTING_SLIGHT              "slight"
 #define SKDEBUGCANVAS_HINTING_NORMAL              "normal"
 #define SKDEBUGCANVAS_HINTING_FULL                "full"
 
 #define SKDEBUGCANVAS_EDGING_ALIAS                "alias"
 #define SKDEBUGCANVAS_EDGING_ANTIALIAS            "antialias"
 #define SKDEBUGCANVAS_EDGING_SUBPIXELANTIALIAS    "subpixelantialias"
 
 #define SKDEBUGCANVAS_SHADOWFLAG_TRANSPARENT_OCC  "transparentOccluder"
 #define SKDEBUGCANVAS_SHADOWFLAG_GEOMETRIC_ONLY   "geometricOnly"
@@ -212,48 +211,47 @@ SkDrawCommand::SkDrawCommand(OpType type)
 const char* SkDrawCommand::GetCommandString(OpType type) {
     switch (type) {
         case kBeginDrawPicture_OpType: return "BeginDrawPicture";
         case kClear_OpType: return "DrawClear";
         case kClipPath_OpType: return "ClipPath";
         case kClipRegion_OpType: return "ClipRegion";
         case kClipRect_OpType: return "ClipRect";
         case kClipRRect_OpType: return "ClipRRect";
         case kConcat_OpType: return "Concat";
         case kDrawAnnotation_OpType: return "DrawAnnotation";
         case kDrawBitmap_OpType: return "DrawBitmap";
         case kDrawBitmapLattice_OpType: return "DrawBitmapLattice";
         case kDrawBitmapNine_OpType: return "DrawBitmapNine";
         case kDrawBitmapRect_OpType: return "DrawBitmapRect";
         case kDrawDRRect_OpType: return "DrawDRRect";
         case kDrawImage_OpType: return "DrawImage";
         case kDrawImageLattice_OpType: return "DrawImageLattice";
         case kDrawImageNine_OpType: return "DrawImageNine";
         case kDrawImageRect_OpType: return "DrawImageRect";
+        case kDrawImageSet_OpType: return "DrawImageSet";
         case kDrawOval_OpType: return "DrawOval";
         case kDrawPaint_OpType: return "DrawPaint";
         case kDrawPatch_OpType: return "DrawPatch";
         case kDrawPath_OpType: return "DrawPath";
         case kDrawArc_OpType: return "DrawArc";
         case kDrawPoints_OpType: return "DrawPoints";
         case kDrawRect_OpType: return "DrawRect";
         case kDrawRRect_OpType: return "DrawRRect";
         case kDrawRegion_OpType: return "DrawRegion";
         case kDrawShadow_OpType: return "DrawShadow";
         case kDrawTextBlob_OpType: return "DrawTextBlob";
         case kDrawVertices_OpType: return "DrawVertices";
         case kDrawAtlas_OpType: return "DrawAtlas";
         case kDrawDrawable_OpType: return "DrawDrawable";
-        case kDrawEdgeAAQuad_OpType: return "DrawEdgeAAQuad";
-        case kDrawEdgeAAImageSet_OpType: return "DrawEdgeAAImageSet";
         case kEndDrawPicture_OpType: return "EndDrawPicture";
         case kRestore_OpType: return "Restore";
         case kSave_OpType: return "Save";
         case kSaveLayer_OpType: return "SaveLayer";
         case kSetMatrix_OpType: return "SetMatrix";
         default:
             SkDebugf("OpType error 0x%08x\n", type);
             SkASSERT(0);
             break;
     }
     SkDEBUGFAIL("DrawType UNUSED\n");
     return nullptr;
 }
@@ -1479,6 +1477,20 @@ void SkDrawImageRectCommand::toJSON(SkJSONWriter& writer, UrlDataManager& urlDat
     writer.appendString(SKDEBUGCANVAS_ATTRIBUTE_SHORTDESC, str_append(&desc, fDst)->c_str());
 }
 
+SkDrawImageSetCommand::SkDrawImageSetCommand(const SkCanvas::ImageSetEntry set[], int count,
+                                             SkFilterQuality filterQuality, SkBlendMode mode)
+        : INHERITED(kDrawImageSet_OpType)
+        , fSet(count)
+        , fCount(count)
+        , fFilterQuality(filterQuality)
+        , fMode(mode) {
+    std::copy_n(set, count, fSet.get());
+}
+
+void SkDrawImageSetCommand::execute(SkCanvas* canvas) const {
+    canvas->experimental_DrawImageSetV1(fSet.get(), fCount, fFilterQuality, fMode);
+}
+
 SkDrawImageNineCommand::SkDrawImageNineCommand(const SkImage* image, const SkIRect& center,
                                                const SkRect& dst, const SkPaint* paint)
     : INHERITED(kDrawImageNine_OpType)
@@ -1887,6 +1899,19 @@ void SkDrawRectCommand::toJSON(SkJSONWriter& writer, UrlDataManager& urlDataMana
     writer.appendString(SKDEBUGCANVAS_ATTRIBUTE_SHORTDESC, str_append(&desc, fRect)->c_str());
 }
 
+SkDrawEdgeAARectCommand::SkDrawEdgeAARectCommand(const SkRect& rect, SkCanvas::QuadAAFlags aa,
+                                                 SkColor color, SkBlendMode mode)
+    : INHERITED(kDrawEdgeAARect_OpType) {
+    fRect = rect;
+    fAA = aa;
+    fColor = color;
+    fMode = mode;
+}
+
+void SkDrawEdgeAARectCommand::execute(SkCanvas* canvas) const {
+    canvas->experimental_DrawEdgeAARectV1(fRect, fAA, fColor, fMode);
+}
+
 SkDrawRRectCommand::SkDrawRRectCommand(const SkRRect& rrect, const SkPaint& paint)
     : INHERITED(kDrawRRect_OpType) {
     fRRect = rrect;
@@ -1971,52 +1996,6 @@ void SkDrawShadowCommand::toJSON(SkJSONWriter& writer, UrlDataManager& urlDataMa
 
 ///////////////////////////////////////////////////////////////////////////////////////////////////
 
-SkDrawEdgeAAQuadCommand::SkDrawEdgeAAQuadCommand(const SkRect& rect, const SkPoint clip[],
-                                                 SkCanvas::QuadAAFlags aa, SkColor color,
-                                                 SkBlendMode mode)
-        : INHERITED(kDrawEdgeAAQuad_OpType)
-        , fRect(rect)
-        , fHasClip(clip != nullptr)
-        , fAA(aa)
-        , fColor(color)
-        , fMode(mode) {
-    if (clip) {
-        for (int i = 0; i < 4; ++i) {
-            fClip[i] = clip[i];
-        }
-    }
-}
-
-void SkDrawEdgeAAQuadCommand::execute(SkCanvas* canvas) const {
-    canvas->experimental_DrawEdgeAAQuad(fRect, fHasClip ? fClip : nullptr, fAA, fColor, fMode);
-}
-
-SkDrawEdgeAAImageSetCommand::SkDrawEdgeAAImageSetCommand(
-        const SkCanvas::ImageSetEntry set[], int count, const SkPoint dstClips[],
-        const SkMatrix preViewMatrices[], const SkPaint* paint,
-        SkCanvas::SrcRectConstraint constraint)
-        : INHERITED(kDrawEdgeAAImageSet_OpType)
-        , fSet(count)
-        , fCount(count)
-        , fPaint(paint)
-        , fConstraint(constraint) {
-    int totalDstClipCount, totalMatrixCount;
-    SkCanvasPriv::GetDstClipAndMatrixCounts(set, count, &totalDstClipCount, &totalMatrixCount);
-
-    std::copy_n(set, count, fSet.get());
-    fDstClips.reset(totalDstClipCount);
-    std::copy_n(dstClips, totalDstClipCount, fDstClips.get());
-    fPreViewMatrices.reset(totalMatrixCount);
-    std::copy_n(preViewMatrices, totalMatrixCount, fPreViewMatrices.get());
-}
-
-void SkDrawEdgeAAImageSetCommand::execute(SkCanvas* canvas) const {
-    canvas->experimental_DrawEdgeAAImageSet(fSet.get(), fCount, fDstClips.get(),
-            fPreViewMatrices.get(), fPaint.getMaybeNull(), fConstraint);
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////////////
-
 SkDrawDrawableCommand::SkDrawDrawableCommand(SkDrawable* drawable, const SkMatrix* matrix)
     : INHERITED(kDrawDrawable_OpType)
     , fDrawable(SkRef(drawable))
diff --git a/tools/debugger/SkDrawCommand.h b/tools/debugger/SkDrawCommand.h
index 0812d850d0..7c386bcbc8 100644
--- a/tools/debugger/SkDrawCommand.h
+++ b/tools/debugger/SkDrawCommand.h
@@ -27,88 +27,88 @@ class SkDrawCommand {
 public:
     enum OpType {
         kBeginDrawPicture_OpType,
         kClear_OpType,
         kClipPath_OpType,
         kClipRegion_OpType,
         kClipRect_OpType,
         kClipRRect_OpType,
         kConcat_OpType,
         kDrawAnnotation_OpType,
         kDrawBitmap_OpType,
         kDrawBitmapLattice_OpType,
         kDrawBitmapNine_OpType,
         kDrawBitmapRect_OpType,
         kDrawDRRect_OpType,
         kDrawImage_OpType,
         kDrawImageLattice_OpType,
         kDrawImageNine_OpType,
         kDrawImageRect_OpType,
+        kDrawImageSet_OpType,
         kDrawOval_OpType,
         kDrawArc_OpType,
         kDrawPaint_OpType,
         kDrawPatch_OpType,
         kDrawPath_OpType,
         kDrawPoints_OpType,
         kDrawRect_OpType,
+        kDrawEdgeAARect_OpType,
         kDrawRRect_OpType,
         kDrawRegion_OpType,
         kDrawShadow_OpType,
         kDrawTextBlob_OpType,
         kDrawVertices_OpType,
         kDrawAtlas_OpType,
         kDrawDrawable_OpType,
-        kDrawEdgeAAQuad_OpType,
-        kDrawEdgeAAImageSet_OpType,
         kEndDrawPicture_OpType,
         kRestore_OpType,
         kSave_OpType,
         kSaveLayer_OpType,
         kSetMatrix_OpType,
 
         kLast_OpType = kSetMatrix_OpType
     };
 
     static const int kOpTypeCount = kLast_OpType + 1;
 
     static void WritePNG(SkBitmap bitmap, SkWStream& out);
 
     SkDrawCommand(OpType opType);
 
     virtual ~SkDrawCommand() {}
 
     bool isVisible() const {
         return fVisible;
     }
 
     void setVisible(bool toggle) {
         fVisible = toggle;
     }
 
     virtual void execute(SkCanvas*) const = 0;
 
     virtual bool render(SkCanvas* canvas) const { return false; }
 
     virtual void toJSON(SkJSONWriter& writer, UrlDataManager& urlDataManager) const;
 
     static const char* GetCommandString(OpType type);
 
     // Helper methods for converting things to JSON
     static void MakeJsonColor(SkJSONWriter&, const SkColor color);
     static void MakeJsonColor4f(SkJSONWriter&, const SkColor4f& color);
     static void MakeJsonPoint(SkJSONWriter&, const SkPoint& point);
     static void MakeJsonPoint(SkJSONWriter&, SkScalar x, SkScalar y);
     static void MakeJsonPoint3(SkJSONWriter&, const SkPoint3& point);
     static void MakeJsonRect(SkJSONWriter&, const SkRect& rect);
     static void MakeJsonIRect(SkJSONWriter&, const SkIRect&);
     static void MakeJsonMatrix(SkJSONWriter&, const SkMatrix&);
     static void MakeJsonPath(SkJSONWriter&, const SkPath& path);
     static void MakeJsonRegion(SkJSONWriter&, const SkRegion& region);
     static void MakeJsonPaint(SkJSONWriter&, const SkPaint& paint, UrlDataManager& urlDataManager);
     static void MakeJsonLattice(SkJSONWriter&, const SkCanvas::Lattice& lattice);
 
     static void flatten(const SkFlattenable* flattenable, SkJSONWriter& writer,
                         UrlDataManager& urlDataManager);
     static bool flatten(const SkImage& image, SkJSONWriter& writer,
                         UrlDataManager& urlDataManager);
     static bool flatten(const SkBitmap& bitmap, SkJSONWriter& writer,
                         UrlDataManager& urlDataManager);
@@ -360,6 +360,20 @@ private:
     typedef SkDrawCommand INHERITED;
 };
 
+class SkDrawImageSetCommand : public SkDrawCommand {
+public:
+    SkDrawImageSetCommand(const SkCanvas::ImageSetEntry[], int count, SkFilterQuality, SkBlendMode);
+    void execute(SkCanvas* canvas) const override;
+
+private:
+    SkAutoTArray<SkCanvas::ImageSetEntry> fSet;
+    int fCount;
+    SkFilterQuality fFilterQuality;
+    SkBlendMode fMode;
+
+    typedef SkDrawCommand INHERITED;
+};
+
 class SkDrawOvalCommand : public SkDrawCommand {
 public:
     SkDrawOvalCommand(const SkRect& oval, const SkPaint& paint);
@@ -529,6 +543,21 @@ private:
     typedef SkDrawCommand INHERITED;
 };
 
+class SkDrawEdgeAARectCommand : public SkDrawCommand {
+public:
+    SkDrawEdgeAARectCommand(const SkRect& rect, SkCanvas::QuadAAFlags aa, SkColor color,
+                            SkBlendMode mode);
+    void execute(SkCanvas* canvas) const override;
+
+private:
+    SkRect  fRect;
+    SkCanvas::QuadAAFlags fAA;
+    SkColor fColor;
+    SkBlendMode fMode;
+
+    typedef SkDrawCommand INHERITED;
+};
+
 class SkDrawRRectCommand : public SkDrawCommand {
 public:
     SkDrawRRectCommand(const SkRRect& rrect, const SkPaint& paint);
@@ -650,41 +679,7 @@ public:
 private:
     sk_sp<SkDrawable> fDrawable;
     SkTLazy<SkMatrix> fMatrix;
 
     typedef SkDrawCommand INHERITED;
 };
-
-class SkDrawEdgeAAQuadCommand : public SkDrawCommand {
-public:
-    SkDrawEdgeAAQuadCommand(const SkRect& rect, const SkPoint clip[4],
-                            SkCanvas::QuadAAFlags aa, SkColor color, SkBlendMode mode);
-    void execute(SkCanvas* canvas) const override;
-
-private:
-    SkRect  fRect;
-    SkPoint fClip[4];
-    int fHasClip;
-    SkCanvas::QuadAAFlags fAA;
-    SkColor fColor;
-    SkBlendMode fMode;
-
-    typedef SkDrawCommand INHERITED;
-};
-
-class SkDrawEdgeAAImageSetCommand : public SkDrawCommand {
-public:
-    SkDrawEdgeAAImageSetCommand(const SkCanvas::ImageSetEntry[], int count, const SkPoint[],
-                                const SkMatrix[], const SkPaint*, SkCanvas::SrcRectConstraint);
-    void execute(SkCanvas* canvas) const override;
-
-private:
-    SkAutoTArray<SkCanvas::ImageSetEntry> fSet;
-    int fCount;
-    SkAutoTArray<SkPoint> fDstClips;
-    SkAutoTArray<SkMatrix> fPreViewMatrices;
-    SkTLazy<SkPaint> fPaint;
-    SkCanvas::SrcRectConstraint fConstraint;
-
-    typedef SkDrawCommand INHERITED;
-};
 #endif
