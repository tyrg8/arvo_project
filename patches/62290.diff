commit 82f4e69094b7d6e4200d14ba64ac9937f337710d
Author: Mallikarjun Kamble <mallikarjun.kamble@ittiam.com>
Date:   Fri Oct 27 17:40:44 2023 +0530

    svcdec: Fixes for NULL dereferencing in inter-layer functions
    
    Resolution level initialization is tracked in inter layer prediction functions
    
    Bug = ossfuzz:62290
    Test: svc_dec_fuzzer

diff --git a/decoder/svc/isvcd_api.c b/decoder/svc/isvcd_api.c
index c449fba..f3ac778 100644
--- a/decoder/svc/isvcd_api.c
+++ b/decoder/svc/isvcd_api.c
@@ -4719,1033 +4719,1034 @@ WORD32 isvcd_pre_parse_refine_au(svc_dec_ctxt_t *ps_svcd_ctxt, ivd_video_decode_
 WORD32 isvcd_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
     dec_struct_t *ps_dec;
     dec_struct_t *ps_dec_zero_lyr;
     svc_dec_lyr_struct_t *ps_svc_lyr_dec;
     svc_dec_lyr_struct_t *ps_svc_lyr_zero_dec;
 
     svc_dec_ctxt_t *ps_svcd_ctxt;
     WORD32 i4_err_status = 0;
 
     UWORD32 bytes_consumed = 0;
     WORD32 ret = 0, api_ret_value = IV_SUCCESS;
     isvcd_video_decode_ip_t *ps_h264d_dec_ip;
     isvcd_video_decode_op_t *ps_h264d_dec_op;
     ivd_video_decode_ip_t *ps_dec_ip;
     ivd_video_decode_op_t *ps_dec_op;
     UWORD8 u1_res_id;
 
     ithread_set_name((void *) "Parse_thread");
 
     ps_svcd_ctxt = (svc_dec_ctxt_t *) (dec_hdl->pv_codec_handle);
     ps_svc_lyr_dec = &ps_svcd_ctxt->ps_svc_dec_lyr[0];
     ps_dec = &ps_svc_lyr_dec->s_dec;
 
     ps_h264d_dec_ip = (isvcd_video_decode_ip_t *) pv_api_ip;
     ps_h264d_dec_op = (isvcd_video_decode_op_t *) pv_api_op;
     ps_dec_ip = &ps_h264d_dec_ip->s_ivd_video_decode_ip_t;
     ps_dec_op = &ps_h264d_dec_op->s_ivd_video_decode_op_t;
 
     {
         UWORD32 u4_size;
         u4_size = ps_dec_op->u4_size;
         memset(ps_h264d_dec_op, 0, sizeof(isvcd_video_decode_op_t));
         ps_dec_op->u4_size = u4_size;
     }
 
     ps_dec->pv_dec_out = ps_dec_op;
     if(ps_dec->init_done != 1)
     {
         return IV_FAIL;
     }
 
     /*Data memory barries instruction,so that bitstream write by the application
      * is complete*/
     DATA_SYNC();
 
     if(0 == ps_dec->u1_flushfrm)
     {
         if(ps_dec_ip->pv_stream_buffer == NULL)
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
             return IV_FAIL;
         }
         if(ps_dec_ip->u4_num_Bytes <= 16)
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
             return IV_FAIL;
         }
     }
 #ifdef KEEP_THREADS_ACTIVE
     {
         UWORD32 i;
         ps_dec->i4_break_threads = 0;
         for(i = 0; i < 2; i++)
         {
             ret = ithread_mutex_lock(ps_dec->apv_proc_start_mutex[i]);
             RETURN_IF((ret != IV_SUCCESS), ret);
 
             ps_dec->ai4_process_start[i] = PROC_INIT;
 
             ret = ithread_mutex_unlock(ps_dec->apv_proc_start_mutex[i]);
             RETURN_IF((ret != IV_SUCCESS), ret);
         }
     }
 #else
     ps_dec->u4_dec_thread_created = 0;
     ps_dec->u4_bs_deblk_thread_created = 0;
 #endif
     ps_dec_op->u4_num_bytes_consumed = 0;
     ps_dec_op->i4_reorder_depth = -1;
     ps_dec_op->i4_display_index = DEFAULT_POC;
 
     ps_dec->ps_out_buffer = NULL;
     if(ps_dec_ip->u4_size >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
         ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
 
     if(0 == ps_dec->u4_share_disp_buf && ps_dec->i4_decode_header == 0)
     {
         UWORD32 i;
         if((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||
            (ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
             return IV_FAIL;
         }
 
         for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)
         {
             if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)
             {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
                 return IV_FAIL;
             }
 
             if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)
             {
                 ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                 ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                 return IV_FAIL;
             }
         }
     }
 
     if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)
     {
         ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;
         return IV_FAIL;
     }
 
     ps_dec_op->u4_error_code = 0;
     ps_dec_op->e_pic_type = IV_NA_FRAME;
     ps_dec_op->u4_output_present = 0;
     ps_dec_op->u4_frame_decoded_flag = 0;
 
     /* In case the decoder is not in flush mode(in shared mode),
      then decoder has to pick up a buffer to write current frame.
      Check if a frame is available in such cases */
     if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1 && ps_dec->u1_flushfrm == 0)
     {
         UWORD32 i;
         WORD32 disp_avail = 0, free_id;
 
         /* Check if at least one buffer is available with the codec */
         /* If not then return to application with error */
         for(i = 0; i < ps_dec->u1_pic_bufs; i++)
         {
             if(0 == ps_dec->u4_disp_buf_mapping[i] || 1 == ps_dec->u4_disp_buf_to_be_freed[i])
             {
                 disp_avail = 1;
                 break;
             }
         }
 
         if(0 == disp_avail)
         {
             /* If something is queued for display wait for that buffer to be returned
              */
 
             ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
             ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
             return (IV_FAIL);
         }
 
         while(1)
         {
             pic_buffer_t *ps_pic_buf;
             ps_pic_buf = (pic_buffer_t *) ih264_buf_mgr_get_next_free(
                 (buf_mgr_t *) ps_dec->pv_pic_buf_mgr, &free_id);
 
             if(ps_pic_buf == NULL)
             {
                 UWORD32 display_queued = 0;
 
                 /* check if any buffer was given for display which is not returned yet */
                 for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)
                 {
                     if(0 != ps_dec->u4_disp_buf_mapping[i])
                     {
                         display_queued = 1;
                         break;
                     }
                 }
                 /* If some buffer is queued for display, then codec has to singal an
                  error and wait for that buffer to be returned. If nothing is queued for
                  display then codec has ownership of all display buffers and it can
                  reuse any of the existing buffers and continue decoding */
 
                 if(1 == display_queued)
                 {
                     /* If something is queued for display wait for that buffer to be
                      * returned */
                     ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
                     ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
                     return (IV_FAIL);
                 }
             }
             else
             {
                 /* If the buffer is with display, then mark it as in use and then look
                  * for a buffer again */
                 if(1 == ps_dec->u4_disp_buf_mapping[free_id])
                 {
                     ih264_buf_mgr_set_status((buf_mgr_t *) ps_dec->pv_pic_buf_mgr, free_id,
                                              BUF_MGR_IO);
                 }
                 else
                 {
                     /**
                      *  Found a free buffer for present call. Release it now.
                      *  Will be again obtained later.
                      */
                     ih264_buf_mgr_release((buf_mgr_t *) ps_dec->pv_pic_buf_mgr, free_id,
                                           BUF_MGR_IO);
                     break;
                 }
             }
         }
     }
 
     if(ps_dec->u1_enable_mb_info && (ps_dec->i4_header_decoded & DECODED_SPS_MASK))
     {
         UWORD32 blk_qp_map_size = ps_h264d_dec_ip->u4_8x8_blk_qp_map_size;
         UWORD32 blk_type_map_size = ps_h264d_dec_ip->u4_8x8_blk_type_map_size;
         UWORD32 blk_8x8_map_size = ps_dec->u4_total_mbs << 2;
         if((ps_h264d_dec_ip->pu1_8x8_blk_qp_map && blk_qp_map_size < blk_8x8_map_size) ||
            (ps_h264d_dec_ip->pu1_8x8_blk_type_map && blk_type_map_size < blk_8x8_map_size))
         {
             ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
             ps_dec_op->u4_error_code |= IH264D_INSUFFICIENT_METADATA_BUFFER;
             return IV_FAIL;
         }
     }
 
     if(ps_dec->u1_flushfrm && (1 == ps_svcd_ctxt->u1_pre_parse_in_flush))
     {
         if(ps_dec->u1_init_dec_flag == 0)
         {
             ps_dec->u1_flushfrm = 0;
             return (IV_FAIL);
         }
 
         ps_svc_lyr_dec = &ps_svcd_ctxt->ps_svc_dec_lyr[ps_svcd_ctxt->s_vcl_nal.i4_num_res_lyrs - 1];
         ps_dec = &ps_svc_lyr_dec->s_dec;
         ps_dec->u4_fmt_conv_cur_row = 0;
         ps_dec->u4_output_present = 0;
         ps_dec->s_disp_op.u4_error_code = 1;
 
         ps_dec->ps_out_buffer = NULL;
         if(ps_dec_ip->u4_size >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
         {
             ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
         }
         ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer, &(ps_dec->s_disp_op));
         if(0 == ps_dec->s_disp_op.u4_error_code)
         {
             /* check output buffer size given by the application */
             if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)
             {
                 ps_dec_op->u4_error_code = IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                 return (IV_FAIL);
             }
 
             ps_dec->u4_fmt_conv_cur_row = 0;
             ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
             ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op), ps_dec->u4_fmt_conv_cur_row,
                                   ps_dec->u4_fmt_conv_num_rows);
             ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
             ps_dec->u4_output_present = 1;
             if(ps_dec->u1_enable_mb_info)
             {
                 UWORD32 disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
                 if(ps_h264d_dec_ip->pu1_8x8_blk_qp_map)
                 {
                     ps_h264d_dec_op->pu1_8x8_blk_qp_map = ps_h264d_dec_ip->pu1_8x8_blk_qp_map;
                     ps_h264d_dec_op->u4_8x8_blk_qp_map_size = ps_dec->u4_total_mbs << 2;
                     ih264_memcpy(ps_h264d_dec_op->pu1_8x8_blk_qp_map,
                                  ps_dec->as_buf_id_info_map[disp_buf_id].pu1_qp_map,
                                  ps_dec->u4_total_mbs << 2);
                 }
                 if(ps_h264d_dec_ip->pu1_8x8_blk_type_map)
                 {
                     ps_h264d_dec_op->pu1_8x8_blk_type_map = ps_h264d_dec_ip->pu1_8x8_blk_type_map;
                     ps_h264d_dec_op->u4_8x8_blk_type_map_size = ps_dec->u4_total_mbs << 2;
                     ih264_memcpy(ps_h264d_dec_op->pu1_8x8_blk_type_map,
                                  ps_dec->as_buf_id_info_map[disp_buf_id].pu1_mb_type_map,
                                  ps_dec->u4_total_mbs << 2);
                 }
             }
         }
         ih264d_export_sei_params(&ps_dec_op->s_sei_decode_op, ps_dec);
 
         ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 
         ps_dec_op->u4_pic_wd = (UWORD32) ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32) ps_dec->u2_disp_height;
         ps_dec_op->i4_reorder_depth = ps_dec->i4_reorder_depth;
         ps_dec_op->i4_display_index = ps_dec->i4_display_index;
         ps_dec_op->u4_new_seq = 0;
 
         ps_dec_op->u4_output_present = ps_dec->u4_output_present;
         ps_dec_op->u4_progressive_frame_flag = ps_dec->s_disp_op.u4_progressive_frame_flag;
         ps_dec_op->e_output_format = ps_dec->s_disp_op.e_output_format;
         ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
         ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
         ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
         ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
 
         /*In the case of flush ,since no frame is decoded set pic type as invalid*/
         ps_dec_op->u4_is_ref_flag = UINT32_MAX;
         ps_dec_op->e_pic_type = IV_NA_FRAME;
         ps_dec_op->u4_frame_decoded_flag = 0;
 
         if(0 == ps_dec->s_disp_op.u4_error_code)
         {
             return (IV_SUCCESS);
         }
         else
             return (IV_FAIL);
     }
 
     if(ps_dec->u1_res_changed == 1)
     {
         /*if resolution has changed and all buffers have been flushed, reset
          * decoder*/
         if(((buf_mgr_t *) ps_dec->pv_pic_buf_mgr)->pv_mutex != NULL)
             ih264_buf_mgr_free(ps_dec->pv_pic_buf_mgr);
         if(((buf_mgr_t *) ps_dec->pv_mv_buf_mgr)->pv_mutex != NULL)
             ih264_buf_mgr_free(ps_dec->pv_mv_buf_mgr);
 
         isvcd_init_decoder(ps_svc_lyr_dec);
     }
 
     DEBUG_THREADS_PRINTF(" Starting process call\n");
 
     {
         vcl_node_t *ps_cur_node;
         UWORD8 u1_num_res_lyrs;
         vcl_buf_hdr_t *ps_vcl_buf;
         UWORD8 flush_decode = 1;
         ps_svcd_ctxt->u1_pre_parse_in_flush = 0;
 
         ret = isvcd_pre_parse_refine_au(ps_svcd_ctxt, ps_dec_ip, &ps_dec_op->u4_num_bytes_consumed);
         ps_svcd_ctxt->u1_pre_parse_in_flush = (ret == FLUSH);
 
         if(ret != OK)
         {
             UWORD32 error = ih264d_map_error((UWORD32) ret);
             if(ret != NOT_OK)
             {
                 ps_dec_op->u4_error_code = error | ret;
             }
             if((ps_dec_op->u4_error_code >> IVD_FATALERROR) & 1)
             {
                 ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
             }
             api_ret_value = IV_FAIL;
             if((ret == IVD_RES_CHANGED) || (ret == IVD_MEM_ALLOC_FAILED) ||
                (ret == ERROR_UNAVAIL_PICBUF_T) || (ret == ERROR_UNAVAIL_MVBUF_T) ||
                (ret == ERROR_INV_SPS_PPS_T) || (ret == ERROR_FEATURE_UNAVAIL) ||
                (ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED) ||
                (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))
             {
                 ps_dec->u4_slice_start_code_found = 0;
             }
             if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))
             {
                 api_ret_value = IV_FAIL;
             }
 
             if(ret == ERROR_IN_LAST_SLICE_OF_PIC)
             {
                 api_ret_value = IV_FAIL;
             }
         }
 
         if(NOT_OK == ret)
         {
             if(ps_dec->u4_pic_buf_got == 0)
             {
                 ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;
                 ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;
 
                 isvcd_fill_output_struct_from_context(ps_svc_lyr_dec, ps_dec_op);
 
                 ps_dec_op->u4_error_code = ps_dec->i4_error_code;
                 ps_dec_op->u4_frame_decoded_flag = 0;
                 return (IV_FAIL);
             }
             return (IV_SUCCESS);
         }
 
         u1_num_res_lyrs = ps_svcd_ctxt->s_vcl_nal.i4_num_res_lyrs;
 
         /* error concelment: exit till next IDR if any of Non Target layers are
          * corrupted */
         {
             ps_cur_node = ps_svcd_ctxt->s_vcl_nal.ps_bot_node;
 
             if(NULL != ps_cur_node)
             {
                 if(!ps_cur_node->i4_idr_pic_flag)
                 {
                     if(u1_num_res_lyrs != ps_svcd_ctxt->u1_prev_num_res_layers)
                     {
                         ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                         ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                         return IV_FAIL;
                     }
                 }
                 else
                 {
                     if(u1_num_res_lyrs != ps_svcd_ctxt->u1_prev_num_res_layers)
                     {
                         ps_svcd_ctxt->u1_prev_num_res_layers = u1_num_res_lyrs;
                     }
                 }
             }
         }
         if(ps_svcd_ctxt->u1_prev_num_res_layers != u1_num_res_lyrs && (u1_num_res_lyrs != 0))
         {
             ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_num_res_lyrs - 1;
             ps_dec = &ps_svc_lyr_dec->s_dec;
 
             if(ps_dec->u1_init_dec_flag == 1)
             {
                 ih264d_release_pics_in_dpb((void *) ps_dec, ps_dec->u1_pic_bufs);
                 ih264d_release_display_bufs(ps_dec);
                 ih264_disp_mgr_init((disp_mgr_t *) ps_dec->pv_disp_buf_mgr);
 
                 ih264_buf_mgr_reset(ps_dec->pv_pic_buf_mgr);
                 ih264_buf_mgr_reset(ps_dec->pv_mv_buf_mgr);
                 ih264d_init_ref_bufs(ps_dec->ps_dpb_mgr);
             }
 
             // ps_svcd_ctxt->u1_prev_num_res_layers = u1_num_res_lyrs;
         }
         ps_svcd_ctxt->u1_parse_nal_unit_error = 0;
 
         if((1 == ps_svcd_ctxt->u1_exit_till_next_IDR) &&
            (ps_svcd_ctxt->s_vcl_nal.ps_bot_node != NULL))
         {
             if(1 == ps_svcd_ctxt->s_vcl_nal.ps_bot_node->i4_idr_pic_flag)
             {
                 ps_svcd_ctxt->u1_exit_till_next_IDR = 0;
 
                 for(u1_res_id = 0; u1_res_id < u1_num_res_lyrs; u1_res_id++)
                 {
                     ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_res_id;
                     ps_dec = &ps_svc_lyr_dec->s_dec;
                     ih264_buf_mgr_reset(ps_dec->pv_pic_buf_mgr);
                     ih264_buf_mgr_reset(ps_dec->pv_mv_buf_mgr);
                 }
             }
             else
             {
                 ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                 return IV_FAIL;
             }
         }
 
         if((0 == ps_dec->i4_decode_header) && (OK == ret))
         {
             flush_decode = 0;
             ps_cur_node = ps_svcd_ctxt->s_vcl_nal.ps_bot_node;
             ps_svc_lyr_zero_dec = ps_svcd_ctxt->ps_svc_dec_lyr;
             ps_dec_zero_lyr = &ps_svc_lyr_zero_dec->s_dec;
             /* master loop */
 
             for(u1_res_id = 0; u1_res_id < u1_num_res_lyrs; u1_res_id++)
             {
                 UWORD8 u1_layer_nal_data_present = 0;
                 ps_svcd_ctxt->u1_cur_layer_id = u1_res_id;
                 ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_res_id;
+                ps_svc_lyr_dec->u1_res_init_done = 0;
                 ps_dec = &ps_svc_lyr_dec->s_dec;
 
                 ps_dec->i4_decode_header = ps_dec_zero_lyr->i4_decode_header;
                 ps_dec->i4_header_decoded = ps_dec_zero_lyr->i4_header_decoded;
                 ps_dec->u1_pic_decode_done = 0;
                 ps_dec->u4_fmt_conv_cur_row = 0;
 
                 ps_dec->u4_output_present = 0;
                 ps_dec->s_disp_op.u4_error_code = 1;
                 ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;
                 ps_dec->u4_ts = ps_dec_ip->u4_ts;
                 ps_dec->i4_frametype = IV_NA_FRAME;
                 ps_dec->i4_content_type = IV_CONTENTTYPE_NA;
 
                 ps_dec->u4_slice_start_code_found = 0;
                 ps_dec->u2_cur_mb_addr = 0;
                 ps_dec->u2_total_mbs_coded = 0;
                 ps_dec->u2_cur_slice_num = 0;
                 ps_dec->cur_dec_mb_num = 0;
                 ps_dec->cur_recon_mb_num = 0;
                 ps_dec->u4_first_slice_in_pic = 1;
                 ps_dec->u1_slice_header_done = 0;
                 ps_dec->u1_dangling_field = 0;
 
                 ps_dec->u4_dec_thread_created = 0;
                 ps_dec->u4_bs_deblk_thread_created = 0;
                 ps_dec->u4_cur_bs_mb_num = 0;
                 ps_dec->u4_cur_deblk_mb_num = 0;
                 ps_dec->u4_start_recon_deblk = 0;
                 ps_dec->u4_sps_cnt_in_process = 0;
                 ps_dec->u4_pic_buf_got = 0;
                 ps_dec->pv_dec_out = ps_dec_op;
 
                 if(ps_dec_ip->u4_size >= offsetof(ivd_video_decode_ip_t, s_out_buffer))
                     ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
 
                 ps_dec->u1_nal_unit_type = ps_cur_node->i4_nal_unit_type;
                 ps_dec->u1_separate_parse = 0;
                 if(u1_res_id == (u1_num_res_lyrs - 1))
                 {
                     ps_svc_lyr_dec->u1_layer_identifier = TARGET_LAYER;
                     if(ps_dec->u4_num_cores >= 2)
                     {
                         ps_dec->u4_num_cores = 2;
                         ps_dec->u1_separate_parse = 1;
                     }
                 }
                 else if(u1_res_id == 0)
                 {
                     ps_svc_lyr_dec->u1_layer_identifier = BASE_LAYER;
                     ps_dec->u1_separate_parse = 0;
                     ps_dec->u4_num_cores = 1;
                 }
                 else if(u1_res_id != 0)
                 {
                     ps_svc_lyr_dec->u1_layer_identifier = MEDIAL_ENHANCEMENT_LAYER;
                     ps_dec->u1_separate_parse = 0;
                     ps_dec->u4_num_cores = 1;
                 }
                 else
                 {
                     return IV_FAIL;
                 }
 
                 ps_svc_lyr_dec->u1_base_res_flag = (0 == u1_res_id);
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_idr_flag = ps_cur_node->i4_idr_pic_flag;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_dependency_id = ps_cur_node->i4_dependency_id;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_priority_id = ps_cur_node->i4_priority_id;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_no_inter_layer_pred_flag =
                     ps_cur_node->u1_acc_no_int_pred;
 
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_quality_id = ps_cur_node->i4_quality_id;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_temporal_id = ps_cur_node->i4_temporal_id;
 
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_use_ref_base_pic_flag =
                     ps_cur_node->i4_use_ref_base;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_discardable_flag = 0;
                 ps_svc_lyr_dec->ps_nal_svc_ext->u1_svc_ext_flag = (u1_res_id > 1);
                 ps_svc_lyr_dec->u4_pps_id_for_layer = UINT32_MAX;
                 ps_vcl_buf = ps_cur_node->ps_first_vcl_nal;
                 ps_svc_lyr_dec->u1_error_in_cur_frame = 0;
 
                 /* Only for Non target Layers*/
                 if(NULL != ps_cur_node->ps_top_node)
                 {
                     ps_svc_lyr_dec->u1_inter_lyr_disable_dblk_filter_idc =
                         ps_cur_node->ps_top_node->i4_inter_lyr_dblk_idc;
                     ps_svc_lyr_dec->i1_inter_lyr_slice_alpha_c0_offset =
                         ps_cur_node->ps_top_node->i4_inter_lyr_alpha_c0_offset;
                     ps_svc_lyr_dec->i1_inter_lyr_slice_beta_offset =
                         ps_cur_node->ps_top_node->i4_inter_lyr_beta_offset;
                 }
 
                 while(NULL != ps_vcl_buf)
                 {
                     u1_layer_nal_data_present = 1;
                     ps_dec->ps_bitstrm->u4_ofst = 0;
                     ps_dec->ps_bitstrm->pu4_buffer =
                         (UWORD32 *) ((UWORD8 *) ps_vcl_buf + ps_vcl_buf->i4_buf_offset +
                                      ps_vcl_buf->i4_slice_offset);
 
                     ps_dec->ps_bitstrm->u4_max_ofst = ps_vcl_buf->u4_max_bits;
 
                     ps_dec_op->u4_frame_decoded_flag = 0;
                     ret = isvcd_parse_nal_unit(ps_svc_lyr_dec, ps_cur_node->i4_nal_ref_idc);
                     if(ret != OK)
                     {
                         ps_svcd_ctxt->u1_parse_nal_unit_error = 1;
                         break;
                     }
 
                     /* go to the next slice */
                     ps_vcl_buf = ps_vcl_buf->ps_next;
                 }
                 /* error concelment: exit till next IDR if a Layer data is missing */
                 if(0 == u1_layer_nal_data_present)
                 {
                     ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                     ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                     return IV_FAIL;
                 }
                 /* error concelment: exit till next IDR if any of Non Target layers are
                  * corrupted */
                 if((ret != OK) && (u1_res_id != (u1_num_res_lyrs - 1)))
                 {
                     ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                     ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                     return IV_FAIL;
                 }
 
                 if((ret != OK) && (u1_res_id == (u1_num_res_lyrs - 1)))
                 {
                     ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_num_res_lyrs - 1;
                     ps_dec = &ps_svc_lyr_dec->s_dec;
 
                     if((0 == ps_svcd_ctxt->u4_num_sps_ctr) || (0 == ps_svcd_ctxt->u4_num_pps_ctr) ||
                        (NULL == ps_dec->ps_cur_pps))
                     {
                         ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                         ps_dec_op->u4_error_code = ERROR_UNKNOWN_NAL;
                         ih264d_signal_decode_thread(ps_dec);
                         return IV_FAIL;
                     }
                 }
                 ps_cur_node = ps_cur_node->ps_top_node;
 
                 if((ps_dec->u4_pic_buf_got == 1) && (ret != IVD_MEM_ALLOC_FAILED) &&
                    ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
                 {
                     // last slice - missing/corruption
                     WORD32 num_mb_skipped;
                     WORD32 prev_slice_err;
                     pocstruct_t temp_poc;
                     WORD32 ret1;
                     WORD32 ht_in_mbs;
                     ht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);
                     num_mb_skipped =
                         (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs) - ps_dec->u2_total_mbs_coded;
 
                     if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))
                         prev_slice_err = 1;
                     else
                         prev_slice_err = 2;
 
                     if(ps_dec->u2_total_mbs_coded == 0)
                     {
                         prev_slice_err = 1;
                     }
                     ret1 = isvcd_mark_err_slice_skip(
                         ps_svc_lyr_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL,
                         ps_dec->ps_cur_slice->u2_frame_num, &temp_poc, prev_slice_err);
 
                     if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||
                        (ret1 == ERROR_INV_SPS_PPS_T) || (ret1 == ERROR_CORRUPTED_SLICE) ||
                        (ret == NOT_OK))
                     {
                         ret = ret1;
                     }
                 }
 
                 if((ret == IVD_RES_CHANGED) || (ret == IVD_MEM_ALLOC_FAILED) ||
                    (ret == ERROR_UNAVAIL_PICBUF_T) || (ret == ERROR_UNAVAIL_MVBUF_T) ||
                    (ret == ERROR_INV_SPS_PPS_T) || (ret == ERROR_CORRUPTED_SLICE) ||
                    (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE) || (ret == NOT_OK))
                 {
                     ps_svcd_ctxt->u1_exit_till_next_IDR = 1;
                     /* signal the decode thread */
                     ih264d_signal_decode_thread(ps_dec);
                     /* dont consume bitstream for change in resolution case */
                     if(ret == IVD_RES_CHANGED)
                     {
                         ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;
                     }
                     return IV_FAIL;
                 }
 
                 /* Multi thread - for target Layer decoding*/
                 if((ps_dec->u1_separate_parse) &&
                    (ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER) &&
                    (0 == ps_svc_lyr_dec->u1_error_in_cur_frame))
                 {
                     /* If Format conversion is not complete,
                      complete it here */
                     if(ps_dec->u4_num_cores == 2)
                     {
                         /*do deblocking of all mbs*/
                         if((ps_dec->u4_nmb_deblk == 0) && (ps_dec->u4_start_recon_deblk == 1) &&
                            (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))
                         {
                             UWORD8 u1_end_of_row = 0;
                             UWORD32 u4_max_addr;
                             tfr_ctxt_t s_tfr_ctxt = {0};
                             tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;
                             pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;
                             UWORD32 u4_slice_end = 0;
 
                             /*BS is done for all mbs while parsing*/
                             u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;
                             /* BS is moved post recon gen in SVC ext*/
 
                             ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,
                                                        ps_dec->u2_frm_wd_in_mbs, 0);
 
                             {
                                 while(u4_slice_end != 1)
                                 {
                                     dec_mb_info_t *p_cur_mb;
                                     WORD32 i, bs_mb_grp;
                                     bs_mb_grp = ps_dec->cur_dec_mb_num - ps_dec->u4_cur_bs_mb_num;
 
                                     for(i = 0; i < bs_mb_grp; i++)
                                     {
                                         p_cur_mb =
                                             &ps_dec->ps_frm_mb_info[ps_dec->u4_cur_bs_mb_num];
 
                                         DEBUG_THREADS_PRINTF("ps_dec->u4_cur_bs_mb_num = %d\n",
                                                              ps_dec->u4_cur_bs_mb_num);
                                         isvcd_compute_bs_non_mbaff_thread(ps_svc_lyr_dec, p_cur_mb,
                                                                           ps_dec->u4_cur_bs_mb_num);
 
                                         ps_dec->u4_cur_bs_mb_num++;
                                         ps_dec->u4_bs_cur_slice_num_mbs++;
                                     }
                                     if(ps_dec->u4_cur_bs_mb_num > u4_max_addr)
                                     {
                                         u4_slice_end = 1;
                                         u1_end_of_row = 1;
                                     }
                                     /*deblock MB group*/
                                     {
                                         UWORD32 u4_num_mbs;
 
                                         if(ps_dec->u4_cur_bs_mb_num > ps_dec->u4_cur_deblk_mb_num)
                                         {
                                             if(u1_end_of_row)
                                             {
                                                 u4_num_mbs = ps_dec->u4_cur_bs_mb_num -
                                                              ps_dec->u4_cur_deblk_mb_num;
                                             }
                                             else
                                             {
                                                 u4_num_mbs = ps_dec->u4_cur_bs_mb_num -
                                                              ps_dec->u4_cur_deblk_mb_num - 1;
                                             }
                                         }
                                         else
                                             u4_num_mbs = 0;
 
                                         ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs, ps_tfr_cxt,
                                                                   0);
                                     }
                                 }
                             }
                         }
                     }
 
                     /*signal the decode thread*/
                     ih264d_signal_decode_thread(ps_dec);
                 }
                 else if((ps_dec->u1_separate_parse) &&
                         (ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER))
                 {
                     /*signal the decode thread*/
                     ih264d_signal_decode_thread(ps_dec);
                 }
 
                 DATA_SYNC();
 
                 if((ps_dec_op->u4_error_code & 0xff) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
                 {
                     ps_dec_op->u4_pic_wd = (UWORD32) ps_dec->u2_disp_width;
                     ps_dec_op->u4_pic_ht = (UWORD32) ps_dec->u2_disp_height;
                     ps_dec_op->i4_reorder_depth = ps_dec->i4_reorder_depth;
                 }
 
                 // Report if header (sps and pps) has not been decoded yet
                 if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)
                 {
                     ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);
                     api_ret_value = IV_FAIL;
                 }
 
                 if((ps_dec->u4_pic_buf_got == 1) && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))
                 {
                     /* For field pictures, set bottom and top picture decoded u4_flag correctly */
 
                     if(ps_dec->ps_cur_slice->u1_field_pic_flag)
                     {
                         if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)
                         {
                             ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;
                         }
                         else
                         {
                             ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;
                         }
                     }
                     else
                     {
                         ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
                     }
 
                     /* if new frame in not found (if we are still getting slices from
                      * previous frame) ih264d_deblock_display is not called. Such frames
                      * will not be added to reference /display
                      */
                     if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)
                     {
                         /* Calling Function to deblock Picture and Display */
                         ret = ih264d_deblock_display(ps_dec);
                     }
 
                     /*set to complete ,as we dont support partial frame decode*/
                     if(ps_dec->i4_header_decoded == 3)
                     {
                         ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;
                     }
 
                     /*Update the i4_frametype at the end of picture*/
                     if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)
                     {
                         ps_dec->i4_frametype = IV_IDR_FRAME;
                     }
                     else if(ps_dec->i4_pic_type == B_SLICE)
                     {
                         ps_dec->i4_frametype = IV_B_FRAME;
                     }
                     else if(ps_dec->i4_pic_type == P_SLICE)
                     {
                         ps_dec->i4_frametype = IV_P_FRAME;
                     }
                     else if(ps_dec->i4_pic_type == I_SLICE)
                     {
                         ps_dec->i4_frametype = IV_I_FRAME;
                     }
                     else
                     {
                         H264_DEC_DEBUG_PRINT("Shouldn't come here\n");
                     }
 
                     // Update the content type
                     ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;
 
                     ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;
                     ps_dec->u4_total_frames_decoded =
                         ps_dec->u4_total_frames_decoded - ps_dec->ps_cur_slice->u1_field_pic_flag;
                 }
 
                 /* In case the decoder is configured to run in low delay mode,
                  * then get display buffer and then format convert.
                  * Note in this mode, format conversion does not run paralelly in a
                  * thread and adds to the codec cycles
                  */
                 if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode) && ps_dec->u1_init_dec_flag)
                 {
                     ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,
                                                   &(ps_dec->s_disp_op));
 
                     if(0 == ps_dec->s_disp_op.u4_error_code)
                     {
                         ps_dec->u4_fmt_conv_cur_row = 0;
                         ps_dec->u4_output_present = 1;
                     }
                     else
                     {
                         ps_dec->u4_output_present = 0;
                     }
                 }
 
                 isvcd_fill_output_struct_from_context(ps_svc_lyr_dec, ps_dec_op);
 
                 /* If Format conversion is not complete,
                  complete it here */
                 /* For Non -target Layers , Buffers are retrived but not displayed*/
 
                 if((ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER) &&
                    ps_dec->u4_output_present &&
                    (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))
                 {
                     ps_dec->u4_fmt_conv_num_rows =
                         ps_dec->s_disp_frame_info.u4_y_ht - ps_dec->u4_fmt_conv_cur_row;
                     ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op), ps_dec->u4_fmt_conv_cur_row,
                                           ps_dec->u4_fmt_conv_num_rows);
                     ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
                 }
 
                 ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 
                 if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)
                 {
                     ps_dec_op->u4_progressive_frame_flag = 1;
                     if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))
                     {
                         if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag) &&
                            (0 == ps_dec->ps_sps->u1_mb_aff_flag))
                             ps_dec_op->u4_progressive_frame_flag = 0;
                     }
                 }
 
                 if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)
                 {
                     ps_dec->u1_top_bottom_decoded = 0;
                 }
                 /*--------------------------------------------------------------------*/
                 /* Do End of Pic processing.                                          */
                 /* Should be called only if frame was decoded in previous process call*/
                 /*--------------------------------------------------------------------*/
                 if(ps_dec->u4_pic_buf_got == 1)
                 {
                     if(1 == ps_dec->u1_last_pic_not_decoded)
                     {
                         ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);
 
                         if(ret != OK) return ret;
 
                         ret = ih264d_end_of_pic(ps_dec);
                         if(ret != OK) return ret;
                     }
                     else
                     {
                         ret = ih264d_end_of_pic(ps_dec);
                         if(ret != OK) return ret;
                     }
                 }
 
                 if(ps_dec->u1_enable_mb_info && ps_dec->u4_output_present)
                 {
                     UWORD32 disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
                     if(ps_h264d_dec_ip->pu1_8x8_blk_qp_map)
                     {
                         ps_h264d_dec_op->pu1_8x8_blk_qp_map = ps_h264d_dec_ip->pu1_8x8_blk_qp_map;
                         ps_h264d_dec_op->u4_8x8_blk_qp_map_size = ps_dec->u4_total_mbs << 2;
                         ih264_memcpy(ps_h264d_dec_op->pu1_8x8_blk_qp_map,
                                      ps_dec->as_buf_id_info_map[disp_buf_id].pu1_qp_map,
                                      ps_dec->u4_total_mbs << 2);
                     }
                     if(ps_h264d_dec_ip->pu1_8x8_blk_type_map)
                     {
                         ps_h264d_dec_op->pu1_8x8_blk_type_map =
                             ps_h264d_dec_ip->pu1_8x8_blk_type_map;
                         ps_h264d_dec_op->u4_8x8_blk_type_map_size = ps_dec->u4_total_mbs << 2;
                         ih264_memcpy(ps_h264d_dec_op->pu1_8x8_blk_type_map,
                                      ps_dec->as_buf_id_info_map[disp_buf_id].pu1_mb_type_map,
                                      ps_dec->u4_total_mbs << 2);
                     }
                 }
                 /*Data memory barrier instruction,so that yuv write by the library is
                  * complete*/
                 DATA_SYNC();
 
                 H264_DEC_DEBUG_PRINT("The num bytes consumed: %d\n",
                                      ps_dec_op->u4_num_bytes_consumed);
             }
         }
         /* highest layer for flush validation */
 
         if((ps_dec->u1_flushfrm) && (1 == flush_decode))
         {
             u1_res_id = u1_num_res_lyrs - 1;
             ps_svc_lyr_dec = ps_svcd_ctxt->ps_svc_dec_lyr + u1_res_id;
             ps_dec = &ps_svc_lyr_dec->s_dec;
 
             ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer, &(ps_dec->s_disp_op));
             if(0 == ps_dec->s_disp_op.u4_error_code)
             {
                 /* check output buffer size given by the application */
                 if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)
                 {
                     ps_dec_op->u4_error_code = IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                     return (IV_FAIL);
                 }
 
                 ps_dec->u4_fmt_conv_cur_row = 0;
                 ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;
                 ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op), ps_dec->u4_fmt_conv_cur_row,
                                       ps_dec->u4_fmt_conv_num_rows);
                 ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;
                 ps_dec->u4_output_present = 1;
             }
             else
             {
                 ps_dec->u4_output_present = 0;
             }
             ih264d_export_sei_params(&ps_dec_op->s_sei_decode_op, ps_dec);
 
             ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));
 
             ps_dec_op->u4_pic_wd = (UWORD32) ps_dec->u2_disp_width;
             ps_dec_op->u4_pic_ht = (UWORD32) ps_dec->u2_disp_height;
             ps_dec_op->i4_reorder_depth = ps_dec->i4_reorder_depth;
             ps_dec_op->i4_display_index = ps_dec->i4_display_index;
 
             ps_dec_op->u4_new_seq = 0;
             ps_dec_op->u4_output_present = (ps_svc_lyr_dec->u1_layer_identifier == TARGET_LAYER)
                                                ? ps_dec->u4_output_present
                                                : 0;
             ps_dec_op->u4_progressive_frame_flag = ps_dec->s_disp_op.u4_progressive_frame_flag;
             ps_dec_op->e_output_format = ps_dec->s_disp_op.e_output_format;
             ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;
             ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;
             ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;
             ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;
 
             /*In the case of flush ,since no frame is decoded set pic type as invalid*/
             ps_dec_op->u4_is_ref_flag = UINT32_MAX;
             ps_dec_op->e_pic_type = IV_NA_FRAME;
             ps_dec_op->u4_frame_decoded_flag = 0;
 
             if(0 == ps_dec->s_disp_op.u4_error_code)
             {
                 return (IV_SUCCESS);
             }
             else
                 return (IV_FAIL);
         }
     }
 
     if((ps_dec_op->u4_error_code & 0xff) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)
     {
         ps_dec_op->u4_pic_wd = (UWORD32) ps_dec->u2_disp_width;
         ps_dec_op->u4_pic_ht = (UWORD32) ps_dec->u2_disp_height;
         ps_dec_op->i4_reorder_depth = ps_dec->i4_reorder_depth;
     }
     return api_ret_value;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :  isvcd_set_display_frame                                 */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 09 2021   Kishore         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
diff --git a/decoder/svc/isvcd_parse_ebslice.c b/decoder/svc/isvcd_parse_ebslice.c
index d805764..604d0fd 100644
--- a/decoder/svc/isvcd_parse_ebslice.c
+++ b/decoder/svc/isvcd_parse_ebslice.c
@@ -218,421 +218,422 @@ WORD32 isvcd_parse_bmb_cabac(svc_dec_lyr_struct_t *ps_svc_lyr_dec, dec_mb_info_t
     /*RESIDUAL FOR Start to end idx*/
     ih264d_parse_residual4x4_cabac(ps_dec, ps_cur_mb_info, 0);
     if(EXCEED_OFFSET(ps_dec->ps_bitstrm)) return ERROR_EOB_TERMINATE_T;
     return OK;
 }
 /*!
  **************************************************************************
  * \if Function name : isvcd_mv_pred_ref_tfr_nby2_ebmb \endif
  *
  * \brief
  *    This function computes the mv pred for b frame
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
 WORD32 isvcd_mv_pred_ref_tfr_nby2_ebmb(dec_struct_t *ps_dec, UWORD8 u1_mb_idx, UWORD8 u1_num_mbs)
 {
     svc_dec_lyr_struct_t *ps_svc_lyr_dec = (svc_dec_lyr_struct_t *) ps_dec;
     parse_pmbarams_t *ps_mb_part_info;
     parse_part_params_t *ps_part;
     mv_pred_t *ps_mv_nmb, *ps_mv_nmb_start, *ps_mv_ntop, *ps_mv_ntop_start;
     pic_buffer_t *ps_ref_frame;
     UWORD8 u1_direct_mode_width;
     UWORD8 i, j;
     dec_mb_info_t *ps_cur_mb_info;
     dec_svc_mb_info_t *ps_svc_cur_mb_info;
     const UWORD8 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
     UWORD8 u1_field;
     WORD32 ret = 0;
     WORD16 i2_mv_x, i2_mv_y;
 
     ps_dec->i4_submb_ofst -= (u1_num_mbs - u1_mb_idx) << 4;
     ps_mb_part_info = ps_dec->ps_parse_mb_data;
     ps_part = ps_dec->ps_parse_part_params;
 
     /* N/2 Mb MvPred and Transfer Setup Loop */
     for(i = u1_mb_idx; i < u1_num_mbs; i++, ps_mb_part_info++)
     {
         UWORD8 u1_colz = 0;
         ps_dec->i4_submb_ofst += SUB_BLK_SIZE;
         /* Restore the slice scratch MbX and MbY context */
         ps_cur_mb_info = ps_dec->ps_nmb_info + i;
         ps_svc_cur_mb_info = ps_svc_lyr_dec->ps_svc_nmb_info + i;
         u1_field = ps_cur_mb_info->u1_mb_field_decodingflag;
         ps_mv_nmb_start = ps_dec->ps_mv_cur + (i << 4);
         ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;
         ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
         ps_dec->u1_currB_type = 0;
         ps_dec->u2_mv_2mb[i & 0x1] = 0;
 
         /* Look for MV Prediction and Reference Transfer in Non-I Mbs */
         if(!ps_mb_part_info->u1_isI_mb)
         {
             UWORD8 u1_blk_no;
             WORD16 i1_ref_idx, i1_ref_idx1;
             UWORD8 u1_pred_mode;
             UWORD8 u1_sub_mb_x, u1_sub_mb_y, u1_sub_mb_num;
             UWORD8 u1_lx, u1_lx_start, u1_lxend, u1_tmp_lx;
             UWORD8 u1_num_part, u1_num_ref, u1_wd, u1_ht;
             UWORD32 *pu4_wt_offst;
             UWORD8 u1_scale_ref, u4_bot_mb;
             deblk_mb_t *ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + i;
             WORD8(*pi1_ref_idx)[MAX_REFIDX_INFO_PER_MB] = ps_mb_part_info->i1_ref_idx;
             WORD8 *pi1_ref_idx0 = pi1_ref_idx[0], *pi1_ref_idx1 = pi1_ref_idx[1];
             UWORD32 **ppu4_wt_ofst = ps_mb_part_info->pu4_wt_offst;
             WORD32 i4_mb_mode_svc;
             UWORD8 u1_motion_pred_flag_l0 = ps_svc_cur_mb_info->au1_motion_pred_flag[0];
             UWORD8 u1_motion_pred_flag_l1 = ps_svc_cur_mb_info->au1_motion_pred_flag[1];
 
             /* MB Level initialisations */
             ps_dec->u4_num_pmbair = i >> u1_mbaff;
             ps_dec->u1_mb_idx_mv = i;
 
             i4_mb_mode_svc = isvcd_interlyr_motion_mode_pred(
                 ps_svc_lyr_dec, ps_cur_mb_info, ps_svc_cur_mb_info, ps_mb_part_info, ps_part);
 
             if((-1 == i4_mb_mode_svc) || (SVC_INTER_MB == i4_mb_mode_svc))
             {
                 ps_mv_ntop_start =
                     ps_mv_nmb_start - (ps_dec->u2_frm_wd_in_mbs << (4 + u1_mbaff)) + 12;
 
                 u1_num_part = ps_mb_part_info->u1_num_part;
                 ps_cur_deblk_mb->u1_mb_type |= (u1_num_part > 1) << 1;
                 u1_direct_mode_width = (1 == ps_mb_part_info->u1_num_part) ? 16 : 8;
 
                 ps_cur_mb_info->u4_pred_info_pkd_idx = ps_dec->u4_pred_info_pkd_idx;
                 ps_cur_mb_info->u1_num_pred_parts = 0;
 
                 /****************************************************/
                 /* weighted u4_ofst pointer calculations, this loop  */
                 /* runs maximum 4 times, even in direct cases       */
                 /****************************************************/
                 u1_scale_ref = u1_mbaff & ps_cur_mb_info->u1_mb_field_decodingflag;
                 u4_bot_mb = 1 - ps_cur_mb_info->u1_topmb;
                 if(ps_dec->ps_cur_pps->u1_wted_bipred_idc)
                 {
                     u1_num_ref = MIN(u1_num_part, 4);
                     if(PART_DIRECT_16x16 != ps_part->u1_is_direct)
                     {
                         for(u1_blk_no = 0; u1_blk_no < u1_num_ref; u1_blk_no++)
                         {
                             i1_ref_idx = MAX(pi1_ref_idx0[u1_blk_no], 0);
                             if(u1_scale_ref) i1_ref_idx >>= 1;
                             i1_ref_idx *= ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1];
                             if(u1_scale_ref)
                                 i1_ref_idx += (MAX(pi1_ref_idx1[u1_blk_no], 0) >> 1);
                             else
                                 i1_ref_idx += MAX(pi1_ref_idx1[u1_blk_no], 0);
                             pu4_wt_offst = (UWORD32 *) &ps_dec->pu4_wt_ofsts[2 * X3(i1_ref_idx)];
 
                             if(pi1_ref_idx0[u1_blk_no] < 0) pu4_wt_offst += 1;
 
                             ppu4_wt_ofst[u1_blk_no] = pu4_wt_offst;
                             if(u1_scale_ref && (ps_dec->ps_cur_pps->u1_wted_bipred_idc == 2))
                             {
                                 i1_ref_idx = MAX(pi1_ref_idx0[u1_blk_no], 0);
                                 i1_ref_idx *=
                                     (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1] << 1);
                                 i1_ref_idx += MAX(pi1_ref_idx1[u1_blk_no], 0);
                                 if(u4_bot_mb)
                                 {
                                     i1_ref_idx +=
                                         (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0] << 1) *
                                         (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[1] << 1);
                                 }
                                 pu4_wt_offst =
                                     (UWORD32 *) &ps_dec->pu4_mbaff_wt_mat[2 * X3(i1_ref_idx)];
                                 ppu4_wt_ofst[u1_blk_no] = pu4_wt_offst;
                             }
                         }
                     }
                 }
 
                 /**************************************************/
                 /* Loop on Partitions                             */
                 /* direct mode is reflected as a single partition */
                 /**************************************************/
                 for(j = 0; j < u1_num_part; j++, ps_part++)
                 {
                     u1_sub_mb_num = ps_part->u1_sub_mb_num;
                     ps_dec->u1_sub_mb_num = u1_sub_mb_num;
 
                     if(PART_NOT_DIRECT != ps_part->u1_is_direct)
                     {
                         /**************************************************/
                         /* Direct Mode, Call DecodeSpatial/TemporalDirect */
                         /* only (those will in turn call FormMbPartInfo)  */
                         /**************************************************/
                         ret = isvcd_decode_spatial_direct(ps_dec, u1_direct_mode_width,
                                                           ps_cur_mb_info, i);
                         if(ret != OK) return ret;
                         ps_cur_deblk_mb->u1_mb_type |= (ps_dec->u1_currB_type << 1);
                     }
                     else
                     {
                         mv_pred_t s_mvPred = {0};
                         /**************************************************/
                         /* Non Direct Mode, Call Motion Vector Predictor  */
                         /* and FormMbpartInfo                             */
                         /**************************************************/
                         u1_sub_mb_x = u1_sub_mb_num & 0x03;
                         u1_sub_mb_y = u1_sub_mb_num >> 2;
                         u1_blk_no = (u1_num_part < 4)
                                         ? j
                                         : (((u1_sub_mb_y >> 1) << 1) + (u1_sub_mb_x >> 1));
 
                         ps_mv_ntop = ps_mv_ntop_start + u1_sub_mb_x;
                         ps_mv_nmb = ps_mv_nmb_start + u1_sub_mb_num;
 
                         /* Populate the colpic info and reference frames */
                         s_mvPred.i1_ref_frame[0] = pi1_ref_idx0[u1_blk_no];
                         s_mvPred.i1_ref_frame[1] = pi1_ref_idx1[u1_blk_no];
                         u1_pred_mode = ps_part->u1_pred_mode;
                         u1_wd = ps_part->u1_partwidth;
                         u1_ht = ps_part->u1_partheight;
 
                         if(1 != ps_svc_cur_mb_info->u1_base_mode_flag)
                         {
                             u1_lx_start = 0;
                             u1_lxend = 2;
                             if(PRED_L0 == u1_pred_mode)
                             {
                                 s_mvPred.i2_mv[2] = 0;
                                 s_mvPred.i2_mv[3] = 0;
                                 if(0 == (u1_motion_pred_flag_l0 & (1 << u1_blk_no)))
                                 {
                                     u1_lxend = 1;
                                 }
                                 else
                                 {
                                     u1_lxend = 0;
                                 }
                             }
                             else if(PRED_L1 == u1_pred_mode)
                             {
                                 s_mvPred.i2_mv[0] = 0;
                                 s_mvPred.i2_mv[1] = 0;
                                 if(0 == (u1_motion_pred_flag_l1 & (1 << u1_blk_no)))
                                 {
                                     u1_lx_start = 1;
                                 }
                                 else
                                 {
                                     u1_lx_start = 2;
                                 }
                             }
                             else  // Bi Pred
                             {
                                 if(0 == (u1_motion_pred_flag_l0 & (1 << u1_blk_no)))
                                 {
                                     u1_lxend = 1;
                                 }
                                 if(0 == (u1_motion_pred_flag_l1 & (1 << u1_blk_no)))
                                 {
                                     u1_lx_start = 1;
                                 }
                                 if((0 != (u1_motion_pred_flag_l0 & (1 << u1_blk_no))) &&
                                    (0 != (u1_motion_pred_flag_l1 & (1 << u1_blk_no))))
                                 {
                                     u1_lx_start = 0;
                                     u1_lxend = 0;
                                 }
                                 if((0 == (u1_motion_pred_flag_l0 & (1 << u1_blk_no))) &&
                                    (0 == (u1_motion_pred_flag_l1 & (1 << u1_blk_no))))
                                 {
                                     u1_lx_start = 0;
                                     u1_lxend = 2;
                                 }
                             }
                             ps_dec->pf_mvpred(ps_dec, ps_cur_mb_info, ps_mv_nmb, ps_mv_ntop,
                                               &s_mvPred, u1_sub_mb_num, u1_wd, u1_lx_start,
                                               u1_lxend, ps_cur_mb_info->u1_mb_mc_mode);
                         }
 
                         /* for generic case based on pred mode derived / signalled */
                         u1_lx_start = 0;
                         u1_lxend = 2;
                         if(PRED_L0 == u1_pred_mode)
                         {
                             s_mvPred.i2_mv[2] = 0;
                             s_mvPred.i2_mv[3] = 0;
                             u1_lxend = 1;
                         }
                         if(PRED_L1 == u1_pred_mode)
                         {
                             s_mvPred.i2_mv[0] = 0;
                             s_mvPred.i2_mv[1] = 0;
                             u1_lx_start = 1;
                         }
 
                         /**********************************************************/
                         /* Loop on number of predictors, 1 Each for Forw Backw    */
                         /* Loop 2 times for BiDirect mode                         */
                         /**********************************************************/
                         for(u1_lx = u1_lx_start; u1_lx < u1_lxend; u1_lx++)
                         {
                             UWORD8 u1_motion_pred_flag =
                                 u1_lx ? u1_motion_pred_flag_l1 : u1_motion_pred_flag_l0;
 
                             if((0 != (u1_motion_pred_flag & (1 << u1_blk_no))) ||
                                (ps_svc_cur_mb_info->u1_base_mode_flag))
                             {
                                 isvcd_retrive_infer_mode_mv(ps_svc_lyr_dec, &s_mvPred, u1_lx,
                                                             u1_sub_mb_num);
                             }
                             /********************************************************/
                             /* Predict Mv                                           */
                             /* Add Mv Residuals and store back                      */
                             /********************************************************/
                             u1_tmp_lx = (u1_lx << 1);
                             i1_ref_idx = s_mvPred.i1_ref_frame[u1_lx];
                             /********************************************************************/
                             /* If reference index is inferred from the base layer and it is     */
                             /* exceeding the number of active reference in the current layer.   */
                             /* Then reference index is clipped to the max in the current layer  */
                             /********************************************************************/
                             if(ps_svc_cur_mb_info->u1_base_mode_flag == 1)
                             {
                                 if(i1_ref_idx > (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[u1_lx] - 1))
                                 {
                                     i1_ref_idx = ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[u1_lx] - 1;
                                 }
                             }
                             if(0 == ps_svc_cur_mb_info->u1_base_mode_flag)
                             {
                                 i2_mv_x = ps_mv_nmb->i2_mv[u1_tmp_lx];
                                 i2_mv_y = ps_mv_nmb->i2_mv[u1_tmp_lx + 1];
 
                                 i2_mv_x += s_mvPred.i2_mv[u1_tmp_lx];
                                 i2_mv_y += s_mvPred.i2_mv[u1_tmp_lx + 1];
 
                                 s_mvPred.i2_mv[u1_tmp_lx] = i2_mv_x;
                                 s_mvPred.i2_mv[u1_tmp_lx + 1] = i2_mv_y;
                             }
                             else
                             {
                                 i2_mv_x = s_mvPred.i2_mv[u1_tmp_lx];
                                 i2_mv_y = s_mvPred.i2_mv[u1_tmp_lx + 1];
                             }
 
                             /********************************************************/
                             /* Transfer setup call                                  */
                             /* convert RefIdx if it is MbAff                        */
                             /* Pass Weight Offset and refFrame                      */
                             /********************************************************/
                             i1_ref_idx1 = i1_ref_idx >> u1_scale_ref;
 
                             if(-1 == i1_ref_idx1) return NOT_OK;
                             if(u1_scale_ref && ((i1_ref_idx & 0x01) != u4_bot_mb))
                                 i1_ref_idx1 += MAX_REF_BUFS;
                             ps_ref_frame = ps_dec->ps_ref_pic_buf_lx[u1_lx][i1_ref_idx1];
 
                             /* Storing Colocated-Zero u4_flag */
                             if(u1_lx == u1_lx_start)
                             {
                                 /* Fill colocated info in MvPred structure */
                                 s_mvPred.u1_col_ref_pic_idx = ps_ref_frame->u1_mv_buf_id;
                                 s_mvPred.u1_pic_type = ps_ref_frame->u1_pic_type;
 
                                 /* Calculating colocated zero information */
                                 u1_colz =
                                     (u1_field << 1) | ((i1_ref_idx == 0) && (ABS(i2_mv_x) <= 1) &&
                                                        (ABS(i2_mv_y) <= 1));
                                 u1_colz |= ps_mb_part_info->u1_col_info[u1_blk_no];
                             }
 
                             pu4_wt_offst = ppu4_wt_ofst[u1_blk_no];
                             {
                                 pred_info_pkd_t *ps_pred_pkd;
                                 WORD16 i2_mv[2];
 
                                 i2_mv[0] = i2_mv_x;
                                 i2_mv[1] = i2_mv_y;
 
                                 ps_pred_pkd = ps_dec->ps_pred_pkd + ps_dec->u4_pred_info_pkd_idx;
                                 ih264d_fill_pred_info(i2_mv, u1_wd, u1_ht, u1_sub_mb_num,
                                                       u1_pred_mode, ps_pred_pkd,
                                                       ps_ref_frame->u1_pic_buf_id, i1_ref_idx,
                                                       pu4_wt_offst, ps_ref_frame->u1_pic_type);
                                 ps_dec->u4_pred_info_pkd_idx++;
                                 ps_cur_mb_info->u1_num_pred_parts++;
                             }
                         }
                         if(ps_mv_nmb)
                         {
                             ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb, u1_sub_mb_num, u1_colz,
                                                u1_ht, u1_wd);
                         }
                         else
                         {
                             return NOT_OK;
                         }
                     }
                 }
                 /* to take care of 16 parttitions increment for base mode flag case*/
                 if(1 == ps_svc_cur_mb_info->u1_base_mode_flag)
                 {
                     ps_part += (MAX_NUM_MB_PART - u1_num_part);
                 }
             }
             else
             {
                 /* Set zero values in case of Intra Mbs */
                 mv_pred_t s_mvPred = {{0, 0, 0, 0}, {-1, -1}, 0, 0};
                 /* to take care of 16 parttitions increment for base mode flag case*/
                 if(1 != ps_svc_cur_mb_info->u1_base_mode_flag)
                 {
                     return NOT_OK;
                 }
 
                 ps_cur_deblk_mb->u1_mb_type |= D_INTRA_IBL;
                 if((ps_svc_lyr_dec->u1_layer_identifier != TARGET_LAYER) &&
                    (DBLK_ENABLED == ps_dec->ps_cur_slice->u1_disable_dblk_filter_idc))
                 {
                     ps_cur_deblk_mb->u1_deblocking_mode = MB_ENABLE_FILTERING;
                 }
 
                 ps_part += (MAX_NUM_MB_PART);
                 /* Storing colocated zero information */
                 if(ps_mv_nmb_start)
                 {
                     ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0,
                                        (UWORD8) (u1_field << 1), 4, 4);
                 }
                 else
                 {
                     return NOT_OK;
                 }
             }
         }
         else
         {
             /* Set zero values in case of Intra Mbs */
             mv_pred_t s_mvPred = {{0, 0, 0, 0}, {-1, -1}, 0, 0};
             /* Storing colocated zero information */
             if(ps_mv_nmb_start)
             {
                 ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0, (UWORD8) (u1_field << 1),
                                    4, 4);
             }
             else
             {
                 return NOT_OK;
             }
         }
     }
+
     return OK;
 }
 
 /*!
 **************************************************************************
 * \if Function name : isvcd_parse_bmb_cavlc \endif
 *
 * \brief
 *    This function parses CAVLC syntax of a B MB.
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
diff --git a/decoder/svc/isvcd_parse_epslice.c b/decoder/svc/isvcd_parse_epslice.c
index bfd32bb..7603049 100644
--- a/decoder/svc/isvcd_parse_epslice.c
+++ b/decoder/svc/isvcd_parse_epslice.c
@@ -3178,51 +3178,55 @@ WORD32 isvcd_mark_err_slice_skip(svc_dec_lyr_struct_t *ps_svc_lyr_dec, WORD32 nu
 * \brief
 *    This function initilizes default values for svcd inter layer func.
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
 WORD32 isvcd_parse_interlayer_resamp_func_init(svc_dec_lyr_struct_t *ps_svc_lyr_dec,
                                                UWORD16 u2_first_mb_in_slice)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     dec_slice_params_t *ps_slice = ps_dec->ps_cur_slice;
     WORD32 ret = OK;
+    if(ps_svc_lyr_dec->u1_res_init_done == 1)
+        return ret;
 
     if(TARGET_LAYER != ps_svc_lyr_dec->u1_layer_identifier)
     {
         ps_slice->u1_disable_dblk_filter_idc = ps_svc_lyr_dec->u1_inter_lyr_disable_dblk_filter_idc;
         ps_slice->i1_slice_alpha_c0_offset = ps_svc_lyr_dec->i1_inter_lyr_slice_alpha_c0_offset;
         ps_slice->i1_slice_beta_offset = ps_svc_lyr_dec->i1_inter_lyr_slice_beta_offset;
     }
 
     if(0 == u2_first_mb_in_slice)
     {
         ret = isvcd_populate_res_prms(ps_svc_lyr_dec);
         if(ret != OK) return NOT_OK;
         isvcd_crop_wnd_flag_res_int(ps_svc_lyr_dec);
         ret = isvcd_comp_mode_mv_res_init(ps_svc_lyr_dec);
         if(ret != OK) return NOT_OK;
         ret = isvcd_ii_pred_res_init(ps_svc_lyr_dec);
         if(ret != OK) return NOT_OK;
         ret = isvcd_intra_resamp_res_init(ps_svc_lyr_dec);
         if(ret != OK) return NOT_OK;
         ret = isvcd_residual_samp_res_init(ps_svc_lyr_dec);
         if(ret != OK) return NOT_OK;
+
+        ps_svc_lyr_dec->u1_res_init_done = 1;
     }
 
     return ret;
 }
 
 /*!
 **************************************************************************
 * \if Function name : isvcd_decode_pslice \endif
 *
 * \brief
 *    Decodes a P Slice
 *
 *
 * \return
 *    0 on Success and Error code otherwise
 **************************************************************************
 */
diff --git a/decoder/svc/isvcd_process_epslice.c b/decoder/svc/isvcd_process_epslice.c
index cbcce8c..62bc5bf 100644
--- a/decoder/svc/isvcd_process_epslice.c
+++ b/decoder/svc/isvcd_process_epslice.c
@@ -91,411 +91,447 @@ void isvcd_retrive_infer_mode_mv(svc_dec_lyr_struct_t *ps_svc_lyr_dec, mv_pred_t
     return;
 }
 /*!
  **************************************************************************
  * \if Function name : isvcd_interlyr_motion_mode_pred \endif
  *
  * \brief
  *
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
 WORD32 isvcd_interlyr_motion_mode_pred(svc_dec_lyr_struct_t *ps_svc_lyr_dec,
                                        dec_mb_info_t *ps_cur_mb_info,
                                        dec_svc_mb_info_t *ps_svc_cur_mb_info,
                                        parse_pmbarams_t *ps_mb_part_info,
                                        parse_part_params_t *ps_part)
 {
     dec_struct_t *ps_dec = &ps_svc_lyr_dec->s_dec;
     WORD32 i4_inter_layer_pred_req_flag;
     WORD32 i4_listx;
     WORD32 i4_mb_mode = -1;
     i4_inter_layer_pred_req_flag = SVCD_FALSE;
     i4_listx = (ps_dec->ps_cur_slice->u1_slice_type == B_SLICE) ? 2 : 1;
     /* check Base mode flag and motion predcition flags */
     if(1 == ps_svc_cur_mb_info->u1_base_mode_flag)
     {
         i4_inter_layer_pred_req_flag = SVCD_TRUE;
     }
     else
     {
         UWORD8 u1_mot_pred_flag;
 
         /* get the packed the motion pred flag of list 0 */
         u1_mot_pred_flag = ps_svc_cur_mb_info->au1_motion_pred_flag[0];
 
         /* extract the last 4 bits */
         u1_mot_pred_flag &= 0x0F;
 
         if(0 != u1_mot_pred_flag)
         {
             i4_inter_layer_pred_req_flag = SVCD_TRUE;
         }
 
         /* check for list 1 flags if required */
         if((2 == i4_listx) && (SVCD_FALSE == i4_inter_layer_pred_req_flag))
         {
             /* get the packed the motion pred flag of list 1 */
             u1_mot_pred_flag = ps_svc_cur_mb_info->au1_motion_pred_flag[1];
 
             /* extract the last 4 bits */
             u1_mot_pred_flag &= 0x0F;
 
             if(0 != u1_mot_pred_flag)
             {
                 i4_inter_layer_pred_req_flag = SVCD_TRUE;
             }
         }
     }
 
     if(SVCD_TRUE == i4_inter_layer_pred_req_flag)
     {
         mode_motion_ctxt_t *ps_ctxt;
         mode_motion_lyr_ctxt *ps_lyr_mem;
 
         ps_ctxt = (mode_motion_ctxt_t *) ps_svc_lyr_dec->pv_mode_mv_sample_ctxt;
         /* get the current layer ctxt */
         ps_lyr_mem = &ps_ctxt->as_res_lyr_mem[ps_ctxt->i4_res_id];
 
-        ps_ctxt->i4_listx = i4_listx;
+        /* In case of error mb_mode is set to skip */
+        if(ps_svc_lyr_dec->u1_res_init_done == 0)
+        {
+            mv_pred_t *ps_motion_pred;
+            ps_motion_pred = ps_ctxt->ps_motion_pred_struct;
+            ps_motion_pred = ps_ctxt->ps_motion_pred_struct;
+            memset(ps_motion_pred, 0, sizeof(mv_pred_t));
+
+            i4_mb_mode = -1;
+            ps_cur_mb_info->u1_mb_type = MB_SKIP;
+            ps_mb_part_info->u1_num_part = 1;
+
+            ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
+            ps_mb_part_info->u1_col_info[0] = (PRED_16x16 << 6);
+            ps_mb_part_info->i1_ref_idx[0][0] = 0;
+
+            ps_svc_cur_mb_info->u1_residual_prediction_flag = 0;
+            ps_svc_cur_mb_info->au1_motion_pred_flag[0] = 0;
+            ps_svc_cur_mb_info->au1_motion_pred_flag[1] = 0;
+            ps_svc_cur_mb_info->u1_base_mode_flag = 0;
+
+            ps_part->u1_partwidth = 4;  // interms of 4x4
+            ps_part->u1_partheight = 4;
+            ps_part->u1_pred_mode = PRED_L0;
+            ps_part->u1_is_direct = 0;
+            ps_part->u1_sub_mb_num = 0;
+
+            if(2 == i4_listx)
+            {
+                ps_mb_part_info->i1_ref_idx[1][0] = -1;
+            }
+        }
+        else
+        {
+            ps_ctxt->i4_listx = i4_listx;
 
-        i4_mb_mode =
-            ps_lyr_mem->pf_inter_lyr_pred(ps_svc_lyr_dec->pv_mode_mv_sample_ctxt, ps_cur_mb_info,
+            i4_mb_mode =
+                ps_lyr_mem->pf_inter_lyr_pred(ps_svc_lyr_dec->pv_mode_mv_sample_ctxt, ps_cur_mb_info,
                                           ps_svc_cur_mb_info, ps_dec, ps_mb_part_info, ps_part);
+        }
     }
     return i4_mb_mode;
 }
 /*!
  **************************************************************************
  * \if Function name : isvcd_mv_pred_ref_tfr_nby2_epmb \endif
  *
  * \brief
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
 WORD32 isvcd_mv_pred_ref_tfr_nby2_epmb(dec_struct_t *ps_dec, UWORD8 u1_mb_idx, UWORD8 u1_num_mbs)
 {
     svc_dec_lyr_struct_t *ps_svc_lyr_dec = (svc_dec_lyr_struct_t *) ps_dec;
     parse_pmbarams_t *ps_mb_part_info;
     parse_part_params_t *ps_part;
     mv_pred_t *ps_mv_nmb, *ps_mv_nmb_start, *ps_mv_ntop, *ps_mv_ntop_start;
     UWORD32 i, j;
     const UWORD32 u1_mbaff = ps_dec->ps_cur_slice->u1_mbaff_frame_flag;
     dec_mb_info_t *ps_cur_mb_info;
     dec_svc_mb_info_t *ps_svc_cur_mb_info;
     WORD32 i2_mv_x, i2_mv_y;
 
     ps_dec->i4_submb_ofst -= (u1_num_mbs - u1_mb_idx) << 4;
     ps_mb_part_info = ps_dec->ps_parse_mb_data;
     ps_part = ps_dec->ps_parse_part_params;
 
     /* N/2 Mb MvPred and Transfer Setup Loop */
     for(i = u1_mb_idx; i < u1_num_mbs; i++, ps_mb_part_info++)
     {
         UWORD32 u1_colz;
         UWORD32 u1_field;
         mv_pred_t s_mvPred = {0};
         mv_pred_t *ps_mv_pred = &s_mvPred;
 
         *ps_mv_pred = ps_dec->s_default_mv_pred;
 
         ps_dec->i4_submb_ofst += SUB_BLK_SIZE;
 
         /* Restore the slice scratch MbX and MbY context */
         ps_cur_mb_info = ps_dec->ps_nmb_info + i;
         ps_svc_cur_mb_info = ps_svc_lyr_dec->ps_svc_nmb_info + i;
         u1_field = ps_cur_mb_info->u1_mb_field_decodingflag;
 
         ps_mv_nmb_start = ps_dec->ps_mv_cur + (i << 4);
         ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;
         ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
         ps_dec->u2_mv_2mb[i & 0x1] = 0;
 
         /* Look for MV Prediction and Reference Transfer in Non-I Mbs */
         if(!ps_mb_part_info->u1_isI_mb)
         {
             UWORD32 u1_blk_no;
             WORD32 i1_ref_idx, i1_ref_idx1;
             UWORD32 u1_sub_mb_x, u1_sub_mb_y, u1_sub_mb_num;
             UWORD32 u1_num_part, u1_num_ref, u1_wd, u1_ht;
             UWORD32 *pu4_wt_offst, **ppu4_wt_ofst;
             UWORD32 u1_scale_ref, u4_bot_mb;
             WORD8 *pi1_ref_idx = ps_mb_part_info->i1_ref_idx[0];
             pic_buffer_t *ps_ref_frame, **pps_ref_frame;
             deblk_mb_t *ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + i;
             WORD32 i4_mb_mode_svc;
             UWORD8 u1_motion_pred_flag_l0 = ps_svc_cur_mb_info->au1_motion_pred_flag[0];
 
             /* MB Level initialisations */
             ps_dec->u4_num_pmbair = i >> u1_mbaff;
             ps_dec->u1_mb_idx_mv = i;
             ppu4_wt_ofst = ps_mb_part_info->pu4_wt_offst;
             pps_ref_frame = ps_dec->ps_ref_pic_buf_lx[0];
 
             i4_mb_mode_svc = isvcd_interlyr_motion_mode_pred(
                 ps_svc_lyr_dec, ps_cur_mb_info, ps_svc_cur_mb_info, ps_mb_part_info, ps_part);
 
             if((-1 == i4_mb_mode_svc) || (SVC_INTER_MB == i4_mb_mode_svc))
             {
                 ps_mv_ntop_start =
                     ps_mv_nmb_start - (ps_dec->u2_frm_wd_in_mbs << (4 + u1_mbaff)) + 12;
 
                 u1_num_part = ps_mb_part_info->u1_num_part;
                 ps_cur_deblk_mb->u1_mb_type |= (u1_num_part > 1) << 1;
                 ps_cur_mb_info->u4_pred_info_pkd_idx = ps_dec->u4_pred_info_pkd_idx;
                 ps_cur_mb_info->u1_num_pred_parts = 0;
 
                 /****************************************************/
                 /* weighted u4_ofst pointer calculations, this loop  */
                 /* runs maximum 4 times, even in direct cases       */
                 /****************************************************/
                 u1_scale_ref = u1_mbaff & u1_field;
 
                 u4_bot_mb = 1 - ps_cur_mb_info->u1_topmb;
                 if(ps_dec->ps_cur_pps->u1_wted_pred_flag)
                 {
                     u1_num_ref = MIN(u1_num_part, 4);
                     for(u1_blk_no = 0; u1_blk_no < u1_num_ref; u1_blk_no++)
                     {
                         i1_ref_idx = pi1_ref_idx[u1_blk_no];
                         if(u1_scale_ref) i1_ref_idx >>= 1;
                         pu4_wt_offst = (UWORD32 *) &ps_dec->pu4_wt_ofsts[2 * X3(i1_ref_idx)];
                         ppu4_wt_ofst[u1_blk_no] = pu4_wt_offst;
                     }
                 }
                 else
                 {
                     ppu4_wt_ofst[0] = NULL;
                     ppu4_wt_ofst[1] = NULL;
                     ppu4_wt_ofst[2] = NULL;
                     ppu4_wt_ofst[3] = NULL;
                 }
 
                 /**************************************************/
                 /* Loop on Partitions                             */
                 /**************************************************/
                 for(j = 0; j < u1_num_part; j++, ps_part++)
                 {
                     u1_sub_mb_num = ps_part->u1_sub_mb_num;
                     ps_dec->u1_sub_mb_num = u1_sub_mb_num;
 
                     if(PART_NOT_DIRECT != ps_part->u1_is_direct)
                     {
                         /* Mb Skip Mode */
                         /* Setting the default and other members of MvPred Structure */
                         s_mvPred.i2_mv[2] = -1;
                         s_mvPred.i2_mv[3] = -1;
                         s_mvPred.i1_ref_frame[0] = 0;
                         i1_ref_idx = (u1_scale_ref && u4_bot_mb) ? MAX_REF_BUFS : 0;
                         ps_ref_frame = pps_ref_frame[i1_ref_idx];
                         s_mvPred.u1_col_ref_pic_idx = ps_ref_frame->u1_mv_buf_id;
                         s_mvPred.u1_pic_type = ps_ref_frame->u1_pic_type;
                         pu4_wt_offst = (UWORD32 *) &ps_dec->pu4_wt_ofsts[0];
 
                         ps_dec->pf_mvpred(ps_dec, ps_cur_mb_info, ps_mv_nmb_start, ps_mv_ntop_start,
                                           &s_mvPred, 0, 4, 0, 1, MB_SKIP);
 
                         {
                             pred_info_pkd_t *ps_pred_pkd;
                             ps_pred_pkd = ps_dec->ps_pred_pkd + ps_dec->u4_pred_info_pkd_idx;
                             ih264d_fill_pred_info(s_mvPred.i2_mv, 4, 4, 0, PRED_L0, ps_pred_pkd,
                                                   ps_ref_frame->u1_pic_buf_id,
                                                   (i1_ref_idx >> u1_scale_ref), pu4_wt_offst,
                                                   ps_ref_frame->u1_pic_type);
 
                             ps_dec->u4_pred_info_pkd_idx++;
                             ps_cur_mb_info->u1_num_pred_parts++;
                         }
 
                         /* Storing colocated zero information */
                         u1_colz = ((ABS(s_mvPred.i2_mv[0]) <= 1) && (ABS(s_mvPred.i2_mv[1]) <= 1)) +
                                   (u1_field << 1);
 
                         if(ps_mv_nmb_start)
                         {
                             ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0, u1_colz, 4,
                                                4);
                         }
                         else
                         {
                             return NOT_OK;
                         }
                     }
                     else
                     {
                         u1_sub_mb_x = u1_sub_mb_num & 0x03;
                         u1_sub_mb_y = u1_sub_mb_num >> 2;
                         u1_blk_no = (u1_num_part < 4)
                                         ? j
                                         : (((u1_sub_mb_y >> 1) << 1) + (u1_sub_mb_x >> 1));
 
                         ps_mv_ntop = ps_mv_ntop_start + u1_sub_mb_x;
                         ps_mv_nmb = ps_mv_nmb_start + u1_sub_mb_num;
 
                         u1_wd = ps_part->u1_partwidth;
                         u1_ht = ps_part->u1_partheight;
 
                         /* Populate the colpic info and reference frames */
                         i1_ref_idx = pi1_ref_idx[u1_blk_no];
                         /********************************************************************/
                         /* If reference index is inferred from the base layer and it is     */
                         /* exceeding the number of active reference in the current layer.   */
                         /* Then reference index is clipped to the max in the current layer  */
                         /********************************************************************/
                         if(ps_svc_cur_mb_info->u1_base_mode_flag == 1)
                         {
                             if(i1_ref_idx > (ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0] - 1))
                             {
                                 i1_ref_idx = ps_dec->ps_cur_slice->u1_num_ref_idx_lx_active[0] - 1;
                             }
                         }
                         s_mvPred.i1_ref_frame[0] = i1_ref_idx;
 
                         if((1 != ps_svc_cur_mb_info->u1_base_mode_flag) &&
                            (0 == (u1_motion_pred_flag_l0 & (1 << u1_blk_no))))
                         {
                             /********************************************************/
                             /* Predict Mv                                           */
                             /* Add Mv Residuals and store back                      */
                             /********************************************************/
                             ps_dec->pf_mvpred(ps_dec, ps_cur_mb_info, ps_mv_nmb, ps_mv_ntop,
                                               &s_mvPred, u1_sub_mb_num, u1_wd, 0, 1,
                                               ps_cur_mb_info->u1_mb_mc_mode);
 
                             i2_mv_x = ps_mv_nmb->i2_mv[0];
                             i2_mv_y = ps_mv_nmb->i2_mv[1];
                             i2_mv_x += s_mvPred.i2_mv[0];
                             i2_mv_y += s_mvPred.i2_mv[1];
                             s_mvPred.i2_mv[0] = i2_mv_x;
                             s_mvPred.i2_mv[1] = i2_mv_y;
                         }
                         else
                         {
                             isvcd_retrive_infer_mode_mv(ps_svc_lyr_dec, &s_mvPred, 0,
                                                         u1_sub_mb_num);
 
                             if(0 != (u1_motion_pred_flag_l0 & (1 << u1_blk_no)))
                             {
                                 i2_mv_x = ps_mv_nmb->i2_mv[0];
                                 i2_mv_y = ps_mv_nmb->i2_mv[1];
                                 i2_mv_x += s_mvPred.i2_mv[0];
                                 i2_mv_y += s_mvPred.i2_mv[1];
                                 s_mvPred.i2_mv[0] = i2_mv_x;
                                 s_mvPred.i2_mv[1] = i2_mv_y;
                             }
                             i2_mv_x = s_mvPred.i2_mv[0];
                             i2_mv_y = s_mvPred.i2_mv[1];
                         }
                         /********************************************************/
                         /* Transfer setup call                                  */
                         /* convert RefIdx if it is MbAff                        */
                         /* Pass Weight Offset and refFrame                      */
                         /********************************************************/
                         i1_ref_idx1 = i1_ref_idx >> u1_scale_ref;
                         if(u1_scale_ref && ((i1_ref_idx & 0x01) != u4_bot_mb))
                             i1_ref_idx1 += MAX_REF_BUFS;
                         if(-1 == i1_ref_idx1) return NOT_OK;
                         ps_ref_frame = pps_ref_frame[i1_ref_idx1];
                         pu4_wt_offst = ppu4_wt_ofst[u1_blk_no];
 
                         {
                             pred_info_pkd_t *ps_pred_pkd;
                             ps_pred_pkd = ps_dec->ps_pred_pkd + ps_dec->u4_pred_info_pkd_idx;
                             ih264d_fill_pred_info(s_mvPred.i2_mv, u1_wd, u1_ht, u1_sub_mb_num,
                                                   PRED_L0, ps_pred_pkd, ps_ref_frame->u1_pic_buf_id,
                                                   (i1_ref_idx >> u1_scale_ref), pu4_wt_offst,
                                                   ps_ref_frame->u1_pic_type);
 
                             ps_dec->u4_pred_info_pkd_idx++;
                             ps_cur_mb_info->u1_num_pred_parts++;
                         }
 
                         /* Fill colocated info in MvPred structure */
                         s_mvPred.u1_col_ref_pic_idx = ps_ref_frame->u1_mv_buf_id;
                         s_mvPred.u1_pic_type = ps_ref_frame->u1_pic_type;
 
                         /* Calculating colocated zero information */
                         u1_colz = (u1_field << 1) |
                                   ((i1_ref_idx == 0) && (ABS(i2_mv_x) <= 1) && (ABS(i2_mv_y) <= 1));
                         u1_colz |= ps_mb_part_info->u1_col_info[u1_blk_no];
 
                         /* Replicate the motion vectors and colzero u4_flag  */
                         /* for all sub-partitions                         */
 
                         if(ps_mv_nmb)
                         {
                             ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb, u1_sub_mb_num, u1_colz,
                                                u1_ht, u1_wd);
                         }
                         else
                         {
                             return NOT_OK;
                         }
                     }
                 }
 
                 /* to take care of 16 parttitions increment for base mode flag case*/
                 if(1 == ps_svc_cur_mb_info->u1_base_mode_flag)
                 {
                     ps_part += (MAX_NUM_MB_PART - u1_num_part);
                 }
             }
             else
             {
                 ps_cur_deblk_mb->u1_mb_type |= D_INTRA_IBL;
                 if((ps_svc_lyr_dec->u1_layer_identifier != TARGET_LAYER) &&
                    (DBLK_ENABLED == ps_dec->ps_cur_slice->u1_disable_dblk_filter_idc))
                 {
                     ps_cur_deblk_mb->u1_deblocking_mode = MB_ENABLE_FILTERING;
                 }
                 /* to take care of 16 parttitions increment for base mode flag case*/
                 if(1 != ps_svc_cur_mb_info->u1_base_mode_flag)
                 {
                     return NOT_OK;
                 }
                 {
                     ps_part += (MAX_NUM_MB_PART);
                 }
                 /* Storing colocated zero information */
                 if(ps_mv_nmb_start)
                 {
                     ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0,
                                        (UWORD8) (u1_field << 1), 4, 4);
                 }
                 else
                 {
                     return NOT_OK;
                 }
             }
         }
         else
         {
             /* Storing colocated zero information */
             if(ps_mv_nmb_start)
             {
                 ih264d_rep_mv_colz(ps_dec, &s_mvPred, ps_mv_nmb_start, 0, (UWORD8) (u1_field << 1),
                                    4, 4);
             }
             else
             {
                 return NOT_OK;
             }
         }
     }
+
     return OK;
 }
 /*!
  **************************************************************************
  * \if Function name : isvcd_update_intra_mb_inter_layer_info \endif
  *
  * \brief : IT
  *    This function decodes an Inter MB fornfor ot target base layers
  *    Only for Progressive : saves residual for upper enhancement layers
  *
  * \return
  *    0 on Success and Error code otherwise
  **************************************************************************
  */
diff --git a/decoder/svc/isvcd_structs.h b/decoder/svc/isvcd_structs.h
index 1959202..fefd32d 100644
--- a/decoder/svc/isvcd_structs.h
+++ b/decoder/svc/isvcd_structs.h
@@ -438,228 +438,229 @@ typedef struct
 typedef struct _SvcDecLyrStruct
 {
     dec_struct_t s_dec;
 
     /*Pred + Res = Target when csbp is zero*/
     ih264_pred_residual_recon_ft *pf_pred_residual_recon_luma_4x4;
 
     ih264_pred_residual_recon_ft *pf_pred_residual_recon_luma_8x8;
 
     ih264_pred_residual_recon_ft *pf_pred_residual_recon_luma_16x16;
 
     ih264_pred_residual_recon_chroma_ft *pf_pred_residual_recon_chroma_4x4;
 
     ih264_pred_residual_recon_chroma_ft *pf_pred_residual_recon_chroma_8x8;
 
     /* IT + Res + Recon*/
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_4x4;
 
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_4x4_dc;
 
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_8x8;
 
     ih264_iquant_itrans_residual_recon_ft *pf_iquant_itrans_residual_recon_luma_8x8_dc;
 
     ih264_iquant_itrans_residual_recon_chroma_ft *pf_iquant_itrans_residual_recon_chroma_4x4;
 
     ih264_iquant_itrans_residual_recon_chroma_ft *pf_iquant_itrans_residual_recon_chroma_4x4_dc;
 
     /* Res nnz*/
     ih264_residual_ft *pf_residual_luma_4x4;
     ih264_residual_ft *pf_residual_luma_8x8;
     ih264_residual_ft *pf_residual_luma_16x16;
 
     ih264_residual_chroma_ft *pf_residual_chroma_cb_cr_8x8;
 
     /*IT + residual */
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_4x4;
 
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_4x4_dc;
 
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_8x8;
 
     ih264_iquant_itrans_residual_ft *pf_iquant_itrans_residual_luma_8x8_dc;
 
     ih264_iquant_itrans_residual_chroma_ft *pf_iquant_itrans_residual_chroma_4x4;
 
     ih264_iquant_itrans_residual_chroma_ft *pf_iquant_itrans_residual_chroma_4x4_dc;
 
     /* IT */
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_4x4;
 
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_4x4_dc;
 
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_8x8;
 
     ih264_iquant_itrans_ft *pf_iquant_itrans_luma_8x8_dc;
 
     ih264_iquant_itrans_chroma_ft *pf_iquant_itrans_chroma_4x4;
 
     ih264_iquant_itrans_chroma_ft *pf_iquant_itrans_chroma_4x4_dc;
 
     /**
      *SVC extension parsing strcture place holders
      */
     dec_nal_unit_svc_ext_params_t *ps_nal_svc_ext;
     dec_prefix_nal_unit_svc_ext_params_t s_pre_nal_unit_svc_ext;
     dec_svc_crop_wnd_offset_t *ps_crop_wnd_offset;
     UWORD8 *apu1_crop_wnd_flag[MAX_DEP_LYRS_IN_RES];
 
     /**
      *contexts for the CABAC related parsing
      */
     bin_ctxt_model_t *ps_base_mode_flag;
     bin_ctxt_model_t *ps_motion_prediction_flag_l0;
     bin_ctxt_model_t *ps_motion_prediction_flag_l1;
     bin_ctxt_model_t *ps_residual_prediction_flag;
 
     /**
      * Function pointers to read Params common to CAVLC and CABAC
      */
     WORD32(*pf_parse_inter_mb_svc_ext)
     (struct _SvcDecLyrStruct *ps_dec, dec_mb_info_t *ps_cur_mb_info,
      dec_svc_mb_info_t *ps_svc_cur_mb_info, UWORD8 u1_mb_num, UWORD8 u1_num_mbsNby2);
 
     WORD32(*pf_parse_inter_slice_svc_ext)
     (struct _SvcDecLyrStruct *ps_dec, dec_slice_params_t *ps_slice, UWORD16 u2_first_mb_in_slice);
 
     /**
      * Function pointers to parse inter slice data
      */
 
     WORD32(*pf_parse_svc_inter_slice)
     (struct _SvcDecLyrStruct *ps_dec, dec_slice_params_t *ps_slice, UWORD16 u2_first_mb_in_slice);
 
     /* inter layer precition buffers */
 
     /* 4x4 level */
     mv_pred_t *ps_il_pred_mv_bank_buf_base;
 
     /* 16x16 level */
     inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_base;
     inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_frm_start;
     inter_lyr_mb_prms_t *ps_inter_lyr_mb_prms_cur_mb;
     UWORD16 u2_inter_lyr_mb_prms_stride;
     UWORD32 u4_inter_lyr_mb_prms_size; /* in Bytes */
 
     /* full frame size : -255 -255 */
     WORD16 *pi2_il_residual_resample_luma_base;
     WORD16 *pi2_il_residual_resample_chroma_base;
     WORD16 *pi2_il_residual_resample_mb_luma_frm_start;
     WORD16 *pi2_il_residual_resample_mb_chroma_frm_start;
 
     UWORD16 u2_residual_resample_luma_stride;
     UWORD16 u2_residual_resample_chroma_stride;
     UWORD32 u4_residual_resample_luma_size;   /* in Bytes */
     UWORD32 u4_residual_resample_chroma_size; /* in Bytes */
 
     mv_pred_t *ps_il_pred_mv_bank_buf_cur_mb;
 
     UWORD8 *pu1_crop_wnd_flag;
     /*
      * Layer info flag - Base layer; Intermediate Enhancement Layers; Target
      * Enhacement Layer.
      */
     UWORD8 u1_layer_identifier;
     /* layer id of the current layer */
     UWORD8 u1_layer_id;
     /* flag to indicate if spatial layers are dyadic */
     UWORD8 u1_dyadic_flag;
     /* flag to indicate if current layer is base layer */
     UWORD8 u1_base_res_flag;
     /* reference layer for inter layer prediction, no quality layers */
     UWORD8 u1_ref_layer_id;
 
     UWORD8 u1_restricted_res_change_flag;
 
     res_prms_t s_res_prms;
 
     void *pv_ref_lyr_offset;
     void *pv_mode_mv_sample_ctxt;
     void *pv_ii_pred_ctxt;
     void *pv_residual_sample_ctxt;
 
     void *pv_intra_sample_ctxt;
     /*!< projected locations buffer pointer exported by Intra Upsampling module
     for luma this buffer contains the projected offsets and window width in
     reference layer for each MB (in horizontal direction) of current resolution
     layer.*/
     ref_mb_map_t *ps_intsam_luma_map_horz;
 
     /*!< projected locations buffer pointer exported by Intra Upsampling module
       for chroma this buffer contains the projected offsets and window width in
       reference layer
       for each MB (in horizontal direction) of current resolution layer.*/
     ref_mb_map_t *ps_intsam_chroma_map_horz;
 
     /*!< projected locations  buffer pointer exported by Intra Upsampling module
        for luma this buffer contains the projected offsets and window width in
        reference layer for each MB (in vertical direction) of current resolution
        layer. */
     ref_mb_map_t *ps_intsam_luma_map_vert;
 
     /*!<  projected locations buffer pointer exported by Intra Upsampling module
        for chroma this buffer contains the projected offsets and window width in
        reference layer for each MB (in vertical direction) of current resolution
        layer.  */
     ref_mb_map_t *ps_intsam_chroma_map_vert;
 
     /*!< projected locations buffer pointer exported by Residual Upsampling module
     for luma. this buffer contains the projected offsets and window width in
     reference layer for each MB (in horizontal direction) of current resolution
     layer. */
     ref_mb_map_t *ps_ressam_luma_map_horz;
 
     /*!< projected locations buffer pointer exported by Residual Upsampling module
         for chroma. this buffer contains the projected offsets and window width in
        reference layer
         for each MB (in horizontal direction) of current resolution layer. */
     ref_mb_map_t *ps_ressam_chroma_map_horz;
 
     /*!< projected locationscbuffer pointercexported by Residual Upsampling
     modulec for chroma. this buffer contains the projected offsets and window
     width in reference layer for each MB (in vertical direction) ofv    current
     resolution layer. */
     ref_mb_map_t *ps_ressam_luma_map_vert;
 
     /*!< projected locationscbuffer pointerccexported by Residual Upsampling
     module for chroma.cthis buffer contains the projected offsets and window width
     in reference layer for each MB (in vertical direction) of current resolution
     layer.*/
     ref_mb_map_t *ps_ressam_chroma_map_vert;
 
     /* pointer to decoder layer referered by current layer */
     void *ps_dec_svc_ref_layer;
     /* pointer to master context */
     void *ps_svcd_ctxt;
 
     UWORD8 u1_inter_lyr_disable_dblk_filter_idc;
     WORD8 i1_inter_lyr_slice_alpha_c0_offset;
     WORD8 i1_inter_lyr_slice_beta_offset;
 
     UWORD8 *pu1_ii_resamp_buffer_luma;
     UWORD8 *pu1_ii_resamp_buffer_chroma;
 
     dec_slice_svc_ext_params_t s_svc_slice_params;
     dec_svc_seq_params_t *ps_subset_sps;
     dec_svc_seq_params_t *ps_cur_subset_sps;
     void *pv_scratch_subset_sps;
 
     /* Variables Required for N MB design */
     dec_svc_mb_info_t *ps_svc_nmb_info;
 
     dec_svc_mb_info_t *ps_svc_frm_mb_info;
 
     void (*pf_svc_compute_bs)(struct _SvcDecLyrStruct *ps_svc_lyr_dec,
                               struct _DecMbInfo *ps_cur_mb_info, const UWORD16 u2_mbxn_mb);
 
     UWORD16 *pu2_frm_res_luma_csbp;
     WORD32 i4_frm_res_luma_csbp_stride;
 
     UWORD8 *pu1_svc_base_mode_flag;
     WORD32 i4_frm_svc_base_mode_cabac_stride;
     WORD32 i4_frm_svc_base_mode_cabac_size;
     UWORD32 u4_pps_id_for_layer;
     UWORD8 u1_error_in_cur_frame;
+    UWORD8 u1_res_init_done;
 } svc_dec_lyr_struct_t;
 
 typedef struct
