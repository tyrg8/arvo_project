commit 706c2a112d1c0eec1d97326c00c09428031fd04c
Merge: ed035670b 40a04fdbc
Author: John Cupitt <jcupitt@gmail.com>
Date:   Wed Jun 23 12:25:43 2021 +0100

    Merge branch '8.11'

diff --git a/ChangeLog b/ChangeLog
index c9b9980eb..cb3f725a7 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,609 +1,615 @@
 14/6/21 started 8.12
 - all tools support `--version`
 
+14/8/20 started 8.11.1
+- add more example code to C docs
+- update libtool support in configure.ac 
+- more startup info if VIPS_INFO is set
+- command-line programs set glib prgname (no longer set for you by VIPS_INIT)
+
 14/8/20 started 8.11
 - add vips_jpegload_source() and vips_svgload_source() to public C API
 - integrate doxygen in build system to generate C++ API docs
 - improve C++ API doc comments
 - add VipsInterpolate and guint64 support to C++ API 
 - add VImage::new_from_memory_steal [Zeranoe]
 - vipsthumbnail supports stdin / stdout thumbnailing
 - have a lock just for pdfium [DarthSim]
 - get pdfium load building again [Projkt-James]
 - add _source load support for pdfium
 - add "seed" param to perlin, worley and gaussnoise
 - add vips_source_g_input_stream_new() to load images from a GInputStream
 - add openslideload_source(), vipsload_source(), vipssave_target()
 - add hist path to rank for large windows on uchar images
 - better 8/16-bit choice for pngsave
 - avoid NaN in mapim [afontenot]
 - hist_find outputs a double histogram for large images [erdmann]
 - fix ref leaks in mosaicing package
 - run libvips leak test in CI 
 - add vips_fitsload_source(), vips_niftiload_source()
 - png and gif load note background colour as metadata [781545872]
 - add vips_image_[set|get]_array_double()
 - add GIF load with libnsgif
 - add jp2kload, jp2ksave
 - add jp2k compression to tiff load and save
 - add JPEG-XL load and save
 - add black_point_compensation flag for icc transforms
 - add "rgba" flag to vips_text() to enable full colour text rendering
 - move openslide, libheif, poppler and magick to loadable modules [kleisauke]
 - better detection of invalid ICC profiles, better fallback paths
 - add "premultiply" flag to tiffsave
 - new threading model has a singe threadpool shared by all pipelines [kleisauke]
 
 30/4/21 start 8.10.7
 - better vips7 PNG load compatibility [SkyDiverCool]
 - fix load of large PPM images from a pipe [ewelot]
 
 22/12/20 start 8.10.6
 - don't seek on bad file descriptors [kleisauke]
 - check for null memory sources [kleisauke]
 - improve ppmload, fixing a couple of small bugs
 - improve EOF detection in jpegload [bozaro]
 - improve error detection in spngload [randy408]
 - fix includes of glib headers in C++ [lovell]
 - fix build with more modern librsvg [lovell]
 - fix a possible segv with very wide images [f1ac]
 - fix issue thumbnailing RGBA images in linear mode [jjonesrs]
 - improve vipsthumbnail profile handling
 - fix tiff deflate predictor setting [Adios]
 - fix vector path for composite on i386 [kleisauke]
 
 18/12/20 started 8.10.5
 - fix potential /0 in animated webp load [lovell]
 
 14/12/20 started 8.10.4
 - fix spng detection
 
 18/10/20 started 8.10.3
 - relax heic is_a rules [hisham]
 - fix vips7 webp load [barryspearce]
 - fix out of bounds exif read in heifload
 - fix out of bounds read in tiffload
 - fix tiffsave region shrink mode [imgifty]
 - add missing flushes on write to target [harukizaemon]
 - hide info messages you could get with some older glibs [kleisauke]
 - fix --no-strip on dzsave with icc-profiles [altert]
 - better GraphicsMagick image write [bfriesen]
 - add missing read loops to spng, heif, giflib and ppm load [kleisauke]
 - block zero width or height images from imagemagick load [Koen1999]
 - check for overflow in gifload height [lovell]
 - fix msb_first default in ppm load and save [ewelot]
 - force binary mode on win for connection read / write [Alreiber]
 - better testing for output to target [barryspearce]
 - ppmload_source was missing is_a [ewelot]
 - improve webpload rounding and blending behaviour [lovell]
 - fix range clip in int32 -> unsigned casts [ewelot]
 - fix precision error in clip of float -> int casts [ewelot]
 - fix load of HEIC images with 0 length metadata [ddennedy-gpsw]
 - revise rounding in reduce [kleisauke]
 
 6/9/20 started 8.10.2
 - update magicksave/load profile handling [kelilevi]
 - better demand hint rules [kaas3000]
 - fix tiff thumbnail from buffer and source [vansante]
 - in jpegsave, don't set JFIF resolution if we set EXIF resolution
 - bump minimum libheif version to 1.3 [lovell]
 - dzsave in iiif mode could set info.json dimensions off by one [Linden6]
 - pdfload allows dpi and scale to both be set [le0daniel]
 - allow gaussblur sigma zero, meaning no blur
 - better heif signature detection [lovell]
 - fix vips_fractsurf() typo [kleisauke]
 - better heif EOF detection [lovell]
 - fix gir build with g-o-i 1.66+ [László]
 - improve seek behaviour on pipes
 - add "speed" param to heifsave [lovell]
 - fix regression in C path for dilate / erode [kleisauke]
 - fix build with libheif save but no load [estepnv]
 
 9/8/20 started 8.10.1
 - fix markdown -> xml conversion in doc generation
 - remove typedef redefinitions to please old gccs
 - fix regression in tiff pyramid thumbnailing [tand826]
 - stop 0-length buffer being passed to imagemagick [lovell]
 - convert no-profile CMYK to RGB on save [augustocdias]
 - ensure SVG loader skips input with chars outside x09-x7F range [lovell]
 - better mask sizing in gaussmat [johntrunc]
 - fix tiffsave "squash" handling [barryspearce]
 - fix jpegload autorotate [chregu]
 - only start the background render thread on first use
 
 24/1/20 started 8.10.0
 - more conformat IIIF output from dzsave [regisrob]
 - add @id to dzsave to set IIIF id property [regisrob]
 - add max and min to region shrink [rgluskin]
 - allow \ as an escape character in vips_break_token() [akemrir]
 - tiffsave has a "depth" param to set max pyr depth
 - libtiff LOGLUV images load and save as libvips XYZ 
 - add gifload_source, csvload_source, csvsave_target, matrixload_source,
   matrixsave_source, pdfload_source, heifload_source, heifsave_target,
   ppmload_source, ppmsave_target
 - revise vipsthumbnail flags
 - add VIPS_LEAK env var
 - add vips_pipe_read_limit_set(), --vips-pipe-read-limit,
   VIPS_PIPE_READ_LIMIT
 - revise gifload to fix BACKGROUND and PREVIOUS dispose [alon-ne]
 - add subsample_mode, deprecate no_subsample in jpegsave [Elad-Laufer]
 - add vips_isdirf()
 - add PAGENUMBER support to tiff write [jclavoie-jive]
 - add "all" mode to smartcrop 
 - flood fill could stop half-way for some very complex shapes
 - better handling of unaligned reads in multipage tiffs [petoor]
 - mark old --delete option to vipsthumbnail as deprecated [UweOhse]
 - png save with a bad ICC profile just gives a warning
 - add "premultipled" option to vips_affine(), clarified vips_resize() 
   behaviour with alpha channels
 - improve bioformats support with read and write of tiff subifd pyramids
 - thumbnail exploits subifd pyramids
 - handle all EXIF orientation cases, deprecate 
   vips_autorot_get_angle() [Elad-Laufer]
 - load PNGs with libspng, if possible
 - deprecate heifload autorotate -- it's now always on
 - revised resize improves accuracy [kleisauke]
 - add --vips-config flag to show configuration info
 - add "bitdepth" param to tiff save, deprecate "squash" [MathemanFlo]
 - tiff load and save now supports 2 and 4 bit data [MathemanFlo]
 - pngsave @bitdepth parameter lets you write 1, 2 and 4 bit PNGs
 - ppmsave also uses "bitdepth" now, for consistency
 - reduce operation cache max to 100
 - rework the final bits of vips7 for vips8 [kleisauke]
 - --disable-deprecated now works [kleisauke]
 - vipsheader allows "stdin" as a filename
 - gifload allows gifs with images outside the canvas
 - wasm compatibility patches [kleisauke]
 - webpsave has a @profile param
 
 24/4/20 started 8.9.3
 - better iiif tile naming [IllyaMoskvin]
 
 31/1/19 started 8.9.2
 - fix a deadlock with --vips-leak [DarthSim]
 - better gifload behaviour for DISPOSAL_UNSPECIFIED [DarthSim]
 - ban ppm max_value < 0 
 - add fuzz corpus to dist
 - detect read errors correctly in source_sniff
 - fix regression in autorot [malomalo]
 - thumbnail on HEIC images could select the thumbnail incorrectly under some
   size modes [ZorinArsenij]
 
 20/6/19 started 8.9.1
 - don't use the new source loaders for new_from_file or new_from_buffer, it
   will break the loader priority system
 - fix thumbnail autorot [janko]
 - fix a warning with magicksave with no delay array [chregu]
 - fix a race in tiled tiff load [kleisauke]
 - better imagemagick init [LebronCurry]
 - lock for metadata changes [jcupitt]
 
 20/6/19 started 8.9.0
 - add vips_image_get/set_array_int()
 - disable webp alpha output if all frame fill the canvas and are solid
 - support arrays of delays for animated images [deftomat]
 - add "unlimited" flag to svgload
 - disable webp alpha output if all frames fill the canvas and are solid
 - add "compression" option to heifsave [lovell]
 - support webp and zstd compression in tiff
 - loaders use "minimise" to close input files earlier
 - integrate support for oss-fuzz [omira-sch]
 - add vips_switch() / vips_case() ... fast many-way ifthenelse
 - better const handling for arithmetic operators fixes comparisons against out
   of range values
 - sharpen restores input colourspace
 - handle alpha in heifload / heifsave [meyermarcel]
 - add @interpretation and @format to rawload
 - nifti load/save uses double for all floating point metadata
 - add vips_error_buffer_copy()
 - add VipsSource and VipsTarget: a universal IO class for loaders and savers
 - jpeg, png, tiff (though not tiffsave), rad, svg, ppm and webp use the 
   new IO class
 - rewritten ppm load/save is faster and uses less memory
 - add @no_strip option to dzsave [kalozka1]
 - add iiif layout to dzsave
 - fix use of resolution-unit metadata on tiff save [kayarre]
 - support TIFF CIELAB images with alpha [angelmixu]
 - support TIFF with premultiplied alpha in any band 
 - block metadata changes on shared images [pvdz]
 - RGB and sRGB are synonmous
 
 17/9/19 started 8.8.4
 - improve compatibility with older imagemagick versions
 - remove realpath, since it can fail on systems with grsec
 
 31/8/19 started 8.8.3
 - revert sharpen restoring the input colourspace
 - xres/yres tiffsave params were in pixels/cm [f--f]
 
 9/7/19 started 8.8.2
 - better early shutdown in readers
 - don't attempt to save large XMP to jpeg [tnextday]
 - always fetch HEIC metadata from the main image [zhoux2016]
 - fix loop in malformed ppm [Kyle-Kyle]
 - better support for PNGs with long comment names
 - fix build with GM
 - add locks for pdfium load
 - fix build with MSVC 
 - fix a problem with shinkv tail processing [angelmixu]
 - fix a read one byte beyond buffer bug in jpegload
 - make GIF parsing less strict
 - better feof() handling in GIF load
 - clip coding and interpretation on vips image read
 - check image bounds for GIF load
 - prevent over-pre-shrink in thumbnail [kleisauke]
 - fix sharpen with sigma 0.5 [2h4dl]
 - sharpen restores input colourspace
 - verify bands/format for coded images
 - improve data_length handling for jpeg metadata
 
 24/5/19 started 8.8.1
 - improve realpath() use on older libc
 - better magickload error messages
 - more consistent behaviour for page-height metadata
 - fix for composite with many small images and some combinations of blend modes
 - fix memleak in tiff pyr save to memory [scossu]
 - istiff attempts to read the first directory rather than just testing the
   magic number [przemyslawpluta]
 - much faster ismagick() [jcupitt]
 - better behaviour for vips_region_fetch() if request lies partly ouside image
 - remove 256 band limit in arithmetic.c [erdmann]
 - disable Orc if building with CET [lovell]
 - fix vipsthumbnail with pyr tiff [kleisauke]
 - text autofit could occasionally terminate early [levmorozov]
 - fewer warnings on tiffload [chregu]
 - vips_resize() breaks aspect ratio and limits shrink to prevent <1px 
   dimensions [lovell]
 
 21/9/18 started 8.8.0
 - much faster smartcrop [lovell]
 - add low/high to smartcrop [jcupitt]
 - add XMP support to png read/write [jcupitt]
 - deprecate thumbnail auto_rotate, add no_rotate [jcupitt]
 - implement thumbnail shrink-on-load for openslide images [jcupitt]
 - add animated webp support [jcupitt]
 - revise vips_cast() to improve behaviour with uint images [erdmann]
 - add bandand()/or()/eor() to cplusplus binding [clcaalu]
 - implement shrink-on-load for tiff pyramids [jcupitt]
 - added vips_image_set_blob_copy() [jcupitt]
 - don't stop composite on first non-transparent image [felixbuenemann, GDmac]
 - add vips_rect_overlapsrect()
 - composite is much faster at positioning subimages
 - stop tiff pyr layers if width or height drop to 1 [gvincke]
 - dzsave has a new skip_blanks option
 - add vips_CMYK2XYZ() and vips_XYZ2CMYK(), plus associated routes 
 - include cmyk and srgb fallback profiles
 - add vips_profile_load() and use it everywhere
 - fix race in temp filename creation [lhecker]
 - add @reduction_effort param to webpsave [lovell]
 - add @option_string param to thumbnail_buffer [kleisauke]
 - add XMP, IPCT, ICC, EXIF etc. support to magickload/magicksave
 - much lower memuse for gifload
 - tilecache speedups
 - add vips_heifload(), vips_heifsave()
 - add heif thumbnail support to vips_thumbnail()
 - free threadpool earlier, reducing mem growth for some long-running 
   processes [jtorresfabra]
 - add vips_region_fetch() / _width() / _height() for language bindings
 - vips_text() supports justification
 - move vips_image_set_kill() and iskilled() to the public API
 - dzsave to szi sets suffix correctly [martinweihrauch]
 - dzsave szi writes "scan-properties.xml"
 - add vips_image_(get|set)_image()
 - add openslideload option to attach all associated images as metadata
 - dzsave to szi will write all associated images
 - remove old c++ and python interfaces
 - vipsthumbnail can thumbnail animated and multipage images
 - deprecate webpload @shrink, use @scale instead
 
 31/3/19 started 8.7.5
 - better buffer sizing in tiff reader [omira-sch]
 
 4/1/19 started 8.7.4
 - magickload with magick6 API did not chain exceptions correctly causing a
   memory leak under some conditions [kleisauke]
 - zero memory on allocate to prevent write of uninitialized memory under some 
   error conditions [Balint Varga-Perke]
 
 21/11/18 started 8.7.3
 - fix infinite loop for autofit with non-scaleable font 
 - mapim was not offsetting by window offset [erdmann]
 - better rounding for scale [kleisauke]
 - fix a memleak in magick6load [kleisauke]
 
 21/11/18 started 8.7.2
 - more info output for temp files to help diagnose problems
 - vips_text() could set the wrong DPI
 - vips_text() leaked in autofit mode
 
 23/9/18 started 8.7.1
 - update function list in docs [janko-m] 
 - test for g_str_to_ascii() [jcupitt]
 - fix temp file open on Windows and fallback on linux [lovell]
 
 23/12/17 started 8.7.0
 - add magicksave, save image with libMagick [dlemstra]
 - remove jpeg thumbnail from EXIF if "jpeg-thumbnail-data" has been removed by
   user
 - hough_line scales width to 0 - 180, not 0 - 360
 - hough_line is 4x faster
 - hough_circle is 2x faster
 - add vips_sobel() and vips_canny() edge detectors
 - add vips_rotate() ... a convenience method for vips_similarity()
 - svgload was missing is_a [lovell]
 - better header sniffing for small files
 - drop incompatible ICC profiles before save
 - better hasalpha rules
 - create funcs always make MULTIBAND (ie. no alpha)
 - use O_TMPFILE, if available [Alexander--]
 - set "interlaced=1" for interlaced JPG and PNG images
 - add PDFium PDF loader
 - jpegload adds a jpeg-chroma-subsample field with eg. 4:4:4 for no
   chrominance subsampling. 
 - tiffload, pdfload, magickload set VIPS_META_N_PAGES "n-pages" metadata item
 - add fontfile option to vips_text() [fangqiao]
 - add vips_transpose3d() -- swap major dimensions in a volumetric image
 - remove vips7 stuff from default API ... you must now #include it explicitly
 - added vips_argument_get_id() to fix derived classes on win32 [angelmixu]
 - fix compile with MSVC 2017 [angelmixu]
 - pdfload has a option for background 
 - vips7 C++ interface defaults off
 - make members, getters and operators "const" in cpp API
 - composite has params for x/y position of sub-images [medakk]
 - add Mitchell kernel
 - pyramid builders have a choice of 2x2 shrinkers [harukizaemon]
 - add `palette` option to pngsave [felixbuenemann]
 - add basic nifti load/save support
 - support writing string-valued fields via libexif
 - paste in the test suite from pyvips
 - get EXIF tag names from tag plus ifd [@Nan619]
 - escape ASCII control characters in XML
 - magickload now sniffs some file types itself
 - update radiance load from upstream
 - add region_shrink to tiffsave
 - mapim could fail for float index images with coordinates out of int range
 - scale openexr alpha to 0 - 255
 - close input earlier, when we can [kleisauke]
 - add vips_object_get_args() for language bindings [kleisauke]
 
 12/3/18 started 8.6.4
 - better fitting of fonts with overhanging edges [Adrià]
 - revise C++ example [fangqiao]
 - strict round down on jpeg shrink on load [davidwood]
 - configure test for g++ 7.2 and composite.cpp
 - don't Ping in magickload, too unreliable
 - ensure WebP can add metadata when compiled with libwebpmux [lovell]
 - improve accuracy of vector path convolution [felixbuenemann]
 
 12/2/18 started 8.6.3
 - use pkg-config to find libjpeg, if we can
 - better clean of output image in vips_image_write() fixes a crash 
   writing twice to memory
 - better rounding behaviour in convolution means we hit the vector path more
   often
 - fix a crash if a delayed load failed [gsharpsh00ter]
 - icc_import attaches the fallback profile if it used it
 
 5/1/18 started 8.6.2
 - vips_sink_screen() keeps a ref to the input image ... stops a rare race
 - fix a minor accidental ABI break in 8.6.0 -> 8.6.1 [remicollet]
 - fix read of plane-separate TIFFs with large strips [remicollet]
 - fix a C++ warning in composite.cpp [lovell]
 - remove number of images limit in composite
 - composite allows 1 mode ... reused for all joins
 - fix race in vips_sink() for seq read 
 
 10/12/17 started 8.6.1
 - fix mmap window new/free cycling 
 - fix some compiler warnings
 - remove the 64-image limit on bandary operations
 - better version date [bmwiedemann]
 - bump wrapper script version [bgilbert]
 - fix a memleak on error during jpeg buffer write [lovell]
 - fix misspelling of IPTC as IPCT [lovell]
 - seq could be set on small images opened in random-access mode [aferrero2707]
 - fix small memleak in dzsave [lovell]
 - small speedup for rgb->g [lovell]
 
 15/4/17 started 8.6.0
 - supports fits images with leading non-image HDUs, thanks benepo
 - add vips_image_new_from_image() and vips_image_new_from_image1() ... make a
   constant image
 - add new_from_image() to Python as well
 - slight change to cpp new_from_image() to match py/C behaviour
 - vips_conv(), vips_compass(), vips_convsep() default to FLOAT precision
 - add FORCE resize mode to break aspect ratio
 - add vips_thumbnail_image()
 - better prefix guessing on Windows, thanks tumagonx
 - savers support a "page_height" option for multipage save
 - rename 'disc' as 'memory' and default off
 - add vips_find_trim(), search for non-background areas 
 - remove lcms1 support, it had bitrotted
 - `join` tagged as seq
 - support tiffsave_buffer for pyramids, thanks bubba
 - thumbnail and vipsthumbnail have an option for rendering intent, thanks 
   kleisauke 
 - set file create time on Windows, thanks dlong500
 - remove python tests ... moved to pyvips test suite
 - vips7 and vips8 python bindings default to off ... use the new pyvips
   binding instead
 - better svgload: larger output, handle missing width/height, thanks lovell
 - add vips_gravity() ... embed, but with direction rather than position
 - vips_text() can autofit text to a box, thanks gargsms
 - add vips_composite() / vips_composite2(): merge a set of images with 
   a set of blend modes
 - better gobject-introspection annotations, thanks astavale 
 - vips_image_write() severs all links between images, when it can ... thanks
   Warren and Nakilon
 - vector path for convolution is more accurate and can handle larger masks
 - linear and cubic kernels for reduce are higher quality
 - added vips_value_set_blob_free()
 - "--size Nx" to vipsthumbnail was broken, thanks jrochkind 
 - fix build with gcc 7
 - add vips_fill_nearest() ... fill pixels with nearest colour
 - add VIPS_COMBINE_MIN, a new combining mode for vips_compass()
 - vips_hist_find_indexed() now has a @combine parameter
 - vips_affine() and vips_similarity() have a "background" parameter
 - fix nasty jaggies on the edges of affine output, thanks chregu
 - add gif-delay, gif-comment and gif-loop metadata
 - add dispose handling to gifload
 - dzsave outputs extra right and bottom overlap-only tiles, for closer spec
   adherence
 - deprecate the "centre" option for vips_resize(): it's now always on
 - setting the EXIF data block automatically sets other image tags
 - add "extend" option to affine; resize uses it to stop black edges
 
 29/8/17 started 8.5.9
 - make --fail stop jpeg read on any libjpeg warning, thanks @mceachen
 - don't build enumtypes so often, removing perl as a compile dependency
 - fix a crash with heavy use of draw operations from language bindings, 
   thanks @Nakilon 
 
 2/8/17 started 8.5.8
 - fix transparency detection in merge, thanks Haida
 - define env var VIPS_WARNING to hide warning messages
 - shut down dzsave output earlier to help mark-sweep bindings
 - fix webp thumbnail upscale, thanks Kleis
 
 9/6/17 started 8.5.7
 - better smartcrop
 - transform cmyk->rgb automatically on write if there's an embedded profile
   and the saver does not support cmyk
 - fix DPI mixup in svgload ... we were writing images about 20% too large,
   thanks Fosk
 
 19/5/17 started 8.5.6
 - tiff read with start page > 0 could break edge tiles or strips
 - raise b64 limit to allow for huge profiles (thanks jaume)
 - fix error return in blob save (thanks jaume)
 - tag vipsprofile as py2 (thanks ioquatix)
 - don't cache thumbnail (thanks tomasc)
 
 23/4/17 started 8.5.5
 - doc polishing
 - more improvements for truncated PNG files, thanks juyunsang 
 - improve corrupted jpg handling, thanks juyunsang
 - fix small test suite issues on os x
 
 23/4/17 started 8.5.4
 - don't depend on image width when setting n_lines, thanks kleisauke
 
 7/4/17 started 8.5.3
 - more link fixing in docs 
 - revise cache sizing again to help out of order errors under heavy load, thanks
   kleisauke
 
 25/3/17 started 8.5.2
 - better behaviour for truncated PNG files, thanks Yury
 - missing proto for vips_tiffsave_buffer(), thanks greut
 - move some docs from the wiki and blog into core libvips docs
 - add support for markdown in docs
 
 25/3/17 started 8.5.1
 - init more classes earlier, thanks David
 
 13/10/16 started 8.5.0
 - rewritten buffer system is safer and frees memory earlier
 - added tiff save to buffer
 - added dzsave save to buffer (zip only)
 - revise header get/set functions
 - better vipsheader behaviour with complex field types
 - added vips_image_hasalpha()
 - added vips_thumbnail() / vips_thumbnail_buffer()
 - webpload/webpsave read and write icc, xmp, exif metadata
 - better >4gb detect for zip dzsave output [Felix Bünemann]
 - all loaders have a @fail option, meaning fail on first warning, though it
   only does anything for jpg and csv
 - add vips_image_get_fields() to help bindings
 - add tiff multi-page read/write
 - add VIPS_META_PAGE_HEIGHT metadata
 - IM6/IM7 magickload supports page/n/page-height, all_frames deprecated
 - gifload supports n/page-height
 - added #defines for VIPS_SONAME, VIPS_LIBRARY_CURRENT, VIPS_LIBRARY_REVISION,
   VIPS_LIBRARY_AGE
 - better support for bscale / bzero in fits images
 - deprecate vips_warn() / vips_info(); use g_warning() / g_info() instead
 - vipsthumbnail supports much fancier geometry strings, thanks tomasc
 - vips_thumbnail() has new @size option
 - fix --vips-cache-max etc. 
 - add compute reordering, plus some new API to support it:
   vips_reorder_margin_hint() and vips_reorder_prepare_many(), thanks
   aferrero2707
 - kick load operations from cache on read error, thanks gaillard 
 - fix return from C++ assignment operator overloads (+=, -= etc) 
 - add @max_slope to vips_hist_local() to implement CLAHE, thanks hunter-87
 - vips_gaussnoise() pixels are reproducible on recalc, thanks MvGulik
 - max/min sort values by y and x coordinate
 - tiff read uses libtiff scanline API if rows-per-strip is large
 - vips_region_shrink() knows about alpha, helps dzsave and tiffsave
 - use expat, not libxml, for XML load ... removes a required dependency, since
   we get expat as part of glib
 - new sequential mode infrastructure is faster and more flexible
 - add vips_smartcrop(), based on sharp's smartcropper
 - vipsthumbnail has a --smartcrop option
 - added vips_rot90() etc. convenience functions
 - fix vips_resize() bug when hscale and vscale were very different
 
 8/12/16 started 8.4.5
 - allow libgsf-1.14.26 to help centos, thanks tdiprima
 
 11/11/16 started 8.4.4
 - fix crash in vips.exe arg parsing on Windows, thanks Yury
 
 18/10/16 started 8.4.3
 - fix error detection in gif_close, thanks aaron42net
 - fix tiny threading memleak
 - improve compatibility with very old glib, see #548
 
 27/9/16 started 8.4.2
 - small doc improvements
 - fix error message for metadata fetch type mismatch
 - resolve a race condition in thread shutdown, thanks Lovell
 
 1/5/16 started 8.4
 - many more wepsave options [Felix Bünemann]
 - added quant_table option to wepsave [Felix Bünemann]
 - added @n option to pdfload, thanks andris
 - dzsave won't write empty tiles in google mode, thanks bverem, perog,
   felixbuenemann
 - allow nested [] in CLI args
 - restore BandFmt on unpremultiply in vipsthumbnail
 - better python detection and build [Felix Bünemann]
 - max-alpha defaults to 65535 for RGB16/GREY16
 - added radsave_buffer [Henri Chain]
 - support tiff orientation tag
 - autorotate option for tiff load
 - tiffsave converts for jpg if jpg compression is turned on
 - tiffsave supports --strip
 - conversions to GREY16 could lock
 - free pixel buffers on image close as well as thread exit ... stops main 
   thread buffers clogging up the system
 - dzsave can write compressed zips [Felix Bünemann]
 - vips_image_write() only refs the input when it has to ... makes it easier to
   combine many images in bounded memory
 - VImage::write() implementation was missing
 - VImage::write() return value changed from void to VImage to help chaining
 - added C++ arithmetic assignment overloads, += etc. 
 - VImage::ifthenelse() with double args was missing =0 on options
 - better accuracy for reducev with smarter multiplication
 - better quality for vips_resize() with linear/cubic kernels 
 - pyvips8 can create new metadata
 - better upsizing with vips_resize()
 - add imagemagick v7 support, thanks sachinwalia2k8 
 - added vips_worley(), vips_perlin() noise generators
 - added vips_convf(), vips_convi(), vips_convasep(), vips_conva() ... 
   im_conv*() functions rewritten as classes
 - vips_convsep() calls vips_convasep() for the approximate case
 - new fixed-point vector path for convi is up to about 2x faster
 - gif loader can make 1, 2, 3, or 4 bands depending on file contents
 - support --strip for pngsave
 - add svgz support [Felix Bünemann]
 - rename boostrap.sh -> autogen.sh to help snapcraft
 - support unicode filenames on Windows 
 - added VIPS_ROUND as well as VIPS_RINT
 - resize/reduce*/shrink*/affine now round output size to nearest rather than 
   rounding down, thanks ioquatix
 - better support for tile overlaps in google maps mode in dzsave
 - dzsave puts vips-properties.xml in the main dir for gm and zoomify layouts
 - resize and reduce have @centre option for centre convention downsampling
 - vipsthumbnail uses centre convention to better match imagemagick
diff --git a/configure.ac b/configure.ac
index bf20f7942..e610f0ed1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -4,9 +4,9 @@
 
 AC_INIT([vips], [8.12.0], [vipsip@jiscmail.ac.uk])
 # required for gobject-introspection
-AC_PREREQ(2.62)
+AC_PREREQ([2.69])
 
 # gobject-introspection recommends -Wno-portability
 # foreign stops complaints about a missing README (we use README.md instead)
 # and missing INSTALL (the standard Gnu INSTALL is not very useful)
 # subdir-objects lets us have dummy.cc in a subdir
@@ -117,8 +117,7 @@ AC_DEFINE_UNQUOTED(G_LOG_DOMAIN, "VIPS", [Domain for glib logging messages.])
 
 m4_define([debug_default], [no])
 AC_ARG_ENABLE(debug,
-  AC_HELP_STRING([--enable-debug=@<:@no/minimum/yes@:>@],
-    [turn on debugging @<:@default=debug_default()@:>@]),,
+  AS_HELP_STRING([--enable-debug=@<:@no/minimum/yes@:>@],[turn on debugging @<:@default=debug_default()@:>@]),,
   enable_debug=debug_default())
 
 if test x"$enable_debug" = x"yes"; then
@@ -180,8 +179,8 @@ AC_DEFINE_UNQUOTED(VIPS_ICC_DIR,"$profile_dir",[default directory for ICC profil
 # we want largefile support, if possible
 AC_SYS_LARGEFILE
 
-# we use libtool
-LT_INIT
+# we use libtool and can generate DLLs cleanly on win32 if necessary
+LT_INIT([win32-dll])
 
 # Checks for programs.
 AC_PROG_AWK
@@ -285,21 +284,6 @@ AC_HEADER_DIRENT
 AC_HEADER_STDC
 AC_CHECK_HEADERS([errno.h math.h fcntl.h limits.h stdlib.h string.h sys/file.h sys/ioctl.h sys/param.h sys/time.h sys/mman.h sys/types.h sys/stat.h unistd.h io.h direct.h windows.h])
 
-# uncomment to change which libs we build
-# AC_DISABLE_SHARED
-# AC_DISABLE_STATIC
-AC_LIBTOOL_WIN32_DLL
-AC_CHECK_TOOL(DLLWRAP, dllwrap)
-AC_CHECK_TOOL(DLLTOOL, dlltool)
-AC_CHECK_TOOL(OBJDUMP, objdump)
-AC_CHECK_TOOL(RANLIB, ranlib)
-AC_CHECK_TOOL(STRIP, strip)
-AC_CHECK_TOOL(AR, ar)
-AC_CHECK_TOOL(AS, as)
-AC_CHECK_TOOL(LD, ld)
-AC_PROVIDE([AC_LIBTOOL_WIN32_DLL])
-AC_PROG_LIBTOOL
-
 # Checks for typedefs, structures, and compiler characteristics.
 AC_C_RESTRICT
 AX_GCC_VAR_ATTRIBUTE(vector_size)
@@ -321,21 +305,21 @@ fi
 # we need to be able to shuffle vectors in C++
 if test x"$ax_cv_have_var_attribute_vector_size" = x"yes"; then
   AC_MSG_CHECKING([for C++ vector shuffle])
   AC_LANG_PUSH([C++])
-  AC_TRY_COMPILE([
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     typedef float v4f __attribute__((vector_size(4 * sizeof(float)),aligned(16)));
-  ],[
+  ]], [[
     v4f f; f[3] = 99;
-  ],[
+  ]])],[
     AC_MSG_RESULT([yes])
     have_vector_shuffle=yes
-  ], [
+  ],[
     AC_MSG_RESULT([no])
     have_vector_shuffle=no
   ])
   AC_LANG_POP([C++])
 
   if test x"$have_vector_shuffle" = x"yes"; then
     AC_DEFINE_UNQUOTED(HAVE_VECTOR_SHUFFLE, 1,
       [define if your C++ can shuffle vectors])
   fi
@@ -344,17 +328,17 @@ fi
 # we also need to be able to mix vector and scalar arithmetic
 if test x"$have_vector_shuffle" = x"yes"; then
   AC_MSG_CHECKING([for C++ vector arithmetic])
   AC_LANG_PUSH([C++])
-  AC_TRY_COMPILE([
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     typedef float v4f __attribute__((vector_size(4 * sizeof(float)),aligned(16)));
-  ],[
+  ]], [[
     v4f f = {1, 2, 3, 4}; f *= 12.0; 
     v4f g = {5, 6, 7, 8}; f = g > 0 ? g : -1 * g;
-  ],[
+  ]])],[
     AC_MSG_RESULT([yes])
     have_vector_arith=yes
-  ], [
+  ],[
     AC_MSG_RESULT([no])
     have_vector_arith=no
   ])
   AC_LANG_POP([C++])
@@ -363,27 +347,27 @@ fi
 # gcc 7.2 seems to work, but then gets confused by signed constants in 
 # templates
 if test x"$have_vector_arith" = x"yes"; then
   AC_MSG_CHECKING([for C++ signed constants in vector templates])
   AC_LANG_PUSH([C++])
-  AC_TRY_COMPILE([
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     typedef float v4f __attribute__((vector_size(4 * sizeof(float)),aligned(16)));
     template <typename T>
     static void
     h( v4f B )
     {
         v4f f;
         f = -1 * B;
     }
-  ],[
-  ],[
+  ]], [[
+  ]])],[
     AC_MSG_RESULT([yes])
-  ], [
+  ],[
     AC_MSG_RESULT([no])
     have_vector_arith=no
   ])
   AC_LANG_POP([C++])
 
   if test x"$have_vector_arith" = x"yes"; then
     AC_DEFINE_UNQUOTED(HAVE_VECTOR_ARITH, 1,
       [define if your C++ can mix vector and scalar arithmetic])
   fi
@@ -1429,32 +1413,29 @@ fi
 VIPS_CFLAGS="$VIPS_CFLAGS $VIPS_DEBUG_FLAGS $REQUIRED_CFLAGS"
 VIPS_LIBS="$VIPS_LIBS $REQUIRED_LIBS -lm"
 
-# autoconf hates multi-line AC_SUBST so we have to have another copy of this
-# thing
+# build options relevant at runtime ... this becomes `vips --vips-config`
+# output
 VIPS_CONFIG="\
 enable debug: $enable_debug, \
 enable deprecated library components: $enable_deprecated, \
 enable modules: $gmodule_supported_flag, \
-enable docs with gtkdoc: $enable_gtk_doc, \
-gobject introspection:  $found_introspection, \
-RAD load/save: $with_radiance, \
-Analyze7 load/save: $with_analyze, \
-PPM load/save: $with_ppm, \
-GIF load:  $with_nsgif, \
-generate C++ docs: $with_doxygen, \
 use fftw3 for FFT: $with_fftw, \
 accelerate loops with orc: $with_orc, \
 ICC profile support with lcms: $with_lcms, \
 zlib: $with_zlib, \
 text rendering with pangocairo: $with_pangocairo, \
 font file support with fontconfig: $with_fontconfig, \
+RAD load/save: $with_radiance, \
+Analyze7 load/save: $with_analyze, \
+PPM load/save: $with_ppm, \
+GIF load:  $with_nsgif, \
 EXIF metadata support with libexif: $with_libexif, \
 JPEG load/save with libjpeg: $with_jpeg, \
 JXL load/save with libjxl: $with_libjxl (dynamic module: $with_libjxl_module), \
 JPEG2000 load/save with libopenjp2: $with_libopenjp2, \
 PNG load with libspng: $with_libspng, \
 PNG load/save with libpng: $with_png, \
-8bpp PNG quantisation: $with_imagequant, \
+PNG quantisation to 8 bit: $with_imagequant, \
 TIFF load/save with libtiff: $with_tiff, \
 image pyramid save: $with_gsf, \
 HEIC/AVIF load/save with libheif: $with_heif (dynamic module: $with_heif_module), \
@@ -1463,7 +1444,7 @@ PDF load with PDFium:  $with_pdfium, \
 PDF load with poppler-glib: $with_poppler (dynamic module: $with_poppler_module), \
 SVG load with librsvg-2.0: $with_rsvg, \
 EXR load with OpenEXR: $with_OpenEXR, \
-slide load with OpenSlide: $with_openslide (dynamic module: $with_openslide_module), \
+OpenSlide load: $with_openslide (dynamic module: $with_openslide_module), \
 Matlab load with matio: $with_matio, \
 NIfTI load/save with niftiio: $with_nifti, \
 FITS load/save with cfitsio: $with_cfitsio, \
@@ -1568,7 +1549,7 @@ PNG load with libspng:                  $with_libspng
  (requires libspng-0.6 or later)
 PNG load/save with libpng:              $with_png
  (requires libpng-1.2.9 or later)
-8bpp PNG quantisation:                  $with_imagequant
+PNG quantisation to 8 bit:              $with_imagequant
  (requires libimagequant)
 TIFF load/save with libtiff:            $with_tiff
 image pyramid save:                     $with_gsf
@@ -1582,7 +1563,7 @@ PDF load with poppler-glib:             $with_poppler (dynamic module: $with_pop
 SVG load with librsvg-2.0:              $with_rsvg
  (requires librsvg-2.0 2.34.0 or later)
 EXR load with OpenEXR:                  $with_OpenEXR
-slide load with OpenSlide:              $with_openslide (dynamic module: $with_openslide_module)
+OpenSlide support:                      $with_openslide (dynamic module: $with_openslide_module)
  (requires openslide-3.3.0 or later)
 Matlab load with matio:                 $with_matio
 NIfTI load/save with niftiio:           $with_nifti
diff --git a/doc/using-C.xml b/doc/using-C.xml
index ab43f2a67..2ad7083da 100644
--- a/doc/using-C.xml
+++ b/doc/using-C.xml
@@ -1,90 +1,93 @@
 <?xml version="1.0"?>
 <!-- vim: set ts=2 sw=2 expandtab: --> 
 <!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
 ]>
 <refentry id="using-from-c">
   <refmeta>
     <refentrytitle>VIPS from C</refentrytitle>
     <manvolnum>3</manvolnum>
     <refmiscinfo>VIPS Library</refmiscinfo>
   </refmeta>
 
   <refnamediv>
     <refname>Using VIPS</refname>
     <refpurpose>How to use the VIPS library from C</refpurpose>
   </refnamediv>
 
   <refsect3 id="using-C-intro">
     <title>Introduction</title>
     <para>
       VIPS comes with a convenient, high-level C API. You should read the API 
       docs for full details, but this section will try to give a brief 
       overview. 
     </para>
   </refsect3>
 
   <refsect3 id="using-C-startup">
     <title>Library startup</title>
     <para>
       When your program starts, use VIPS_INIT()
       to start up the VIPS library. You should pass it the name
       of your program, usually <code>argv[0]</code>. Use
       vips_shutdown() when you exit. VIPS_INIT() is a macro to let it check 
       that the libvips library you have linked to matches the libvips headers 
       you included. 
     </para>
 
     <para>
       You can add the VIPS flags to your %GObject command-line processing
       with vips_add_option_entries().
     </para>
   </refsect3>
 
   <refsect3 id="using-C-vipsimage">
     <title>The #VipsImage class</title>
     <para>
       The basic data object is the #VipsImage. You can create an
       image from a file on disc or from an area of memory, either
       as a C-style array, or as a formatted object, like JPEG. See
       vips_image_new_from_file() and friends.  Loading an
       image is fast: VIPS read just enough of the image to be able to get
       the various properties, such as width, but no decoding occurs until 
       pixel values are really needed.
     </para>
 
     <para>
       Once you have an image, you can get properties from it in the usual way. 
       You can use projection functions, like vips_image_get_width() or 
       g_object_get(), to get %GObject properties. All VIPS objects are
       immutable, meaning you can only get properties, you can't set them.
       See <link linkend="libvips-header">VIPS Header</link> to read about 
       image properties.
     </para>
   </refsect3>
 
   <refsect3 id="using-C-ref">
     <title>Reference counting</title>
     <para>
       VIPS is based on the %GObject library and is therefore reference counted. 
       vips_image_new_from_file() returns an object with a count of 1. 
       When you are done with an image, use g_object_unref() to dispose of it. 
       If you pass an image to an operation and that operation needs to keep a 
       copy of the image, it will ref it. So you can unref an image as soon as 
       you no longer need it, you don't need to hang on to it in case anyone 
       else is still using it. 
     </para>
 
     <para>
-      See #VipsOperation for more detail on VIPS 
-      reference counting conventions.
+      See #VipsOperation for more detail on VIPS
+      reference counting conventions. See the <link
+      linkend="reference-pools-ref">Reference pools</link>
+      section below for a way to automate reference counting in C.
     </para>
+
   </refsect3>
 
   <refsect3 id="using-C-operations">
     <title>VIPS operations</title>
     <para>
       Use things like vips_embed() to manipulate your images. You use it from 
       C like this:
 
 <programlisting language="C">
@@ -131,23 +134,23 @@ usage:
    embed in out x y width height
 where:
    in           - Input image, input VipsImage
    out          - Output image, output VipsImage
    x            - Left edge of input in output, input gint
-			                default: 0
-			                min: -1000000000, max: 1000000000
+                      default: 0
+                      min: -1000000000, max: 1000000000
    y            - Top edge of input in output, input gint
-			                default: 0
-			                min: -1000000000, max: 1000000000
+                      default: 0
+                      min: -1000000000, max: 1000000000
    width        - Image width in pixels, input gint
-			                default: 1
-			                min: 1, max: 1000000000
+                      default: 1
+                      min: 1, max: 1000000000
    height       - Image height in pixels, input gint
-			                default: 1
-			                min: 1, max: 1000000000
+                      default: 1
+                      min: 1, max: 1000000000
 optional arguments:
    extend       - How to generate the extra pixels, input VipsExtend
-			                default: black
-			                allowed: black, copy, repeat, mirror, white, background
+                      default: black
+                      allowed: black, copy, repeat, mirror, white, background
    background   - Colour for background pixels, input VipsArrayDouble
 operation flags: sequential-unbuffered 
 </programlisting>
@@ -228,40 +231,136 @@ int
 main( int argc, char **argv )
 {
   VipsImage *in;
   double mean;
   VipsImage *out;
 
   if( VIPS_INIT( argv[0] ) )
     vips_error_exit( NULL ); 
 
   if( argc != 3 )
     vips_error_exit( "usage: %s infile outfile", argv[0] ); 
   
   if( !(in = vips_image_new_from_file( argv[1], NULL )) )
     vips_error_exit( NULL );
 
   printf( "image width = %d\n", vips_image_get_width( in ) ); 
 
   if( vips_avg( in, &amp;mean, NULL ) )
     vips_error_exit( NULL );
 
   printf( "mean pixel value = %g\n", mean ); 
 
   if( vips_invert( in, &amp;out, NULL ) )
     vips_error_exit( NULL );
 
   g_object_unref( in ); 
 
   if( vips_image_write_to_file( out, argv[2], NULL ) )
     vips_error_exit( NULL );
 
   g_object_unref( out ); 
 
   return( 0 );
 }
 </programlisting>
+</example>
+
+  </refsect3>
+
+  <refsect3 id="reference-pools-ref">
+    <title>Reference pools</title>
+    <para>
+      libvips has a simple system to automate at least some reference counting 
+      issues. Reference pools are arrays of object pointers which will be 
+      released automatically when some other object is finalized. 
+    </para>
+
+    <para>
+      The code below crops a many-page image (perhaps a GIF or PDF). It 
+      splits the image into separate pages, crops each page, reassembles the 
+      cropped areas, and saves again. It creates a <code>context</code> 
+      object representing the state of processing, and 
+      <code>crop_animation</code> allocates two reference pools off that using 
+      <code>vips_object_local_array</code>, one to hold the cropped frames, 
+      and one to assemble and copy the result.
+    </para>
+
+    <para>
+      All unreffing is handled by <code>main</code>, and it doesn't need to 
+      know anything about <code>crop_animation</code>.
+    </para>
+
+<example>
+<title>Reference pool example</title>
+<programlisting language="C">
+#include &lt;vips/vips.h&gt;
+
+static int
+crop_animation( VipsObject *context, VipsImage *image, VipsImage **out,
+  int left, int top, int width, int height )
+{
+  int page_height = vips_image_get_page_height( image );
+  int n_pages = image-&gt;Ysize / page_height;
+  VipsImage **page = (VipsImage **) vips_object_local_array( context, n_pages );
+  VipsImage **copy = (VipsImage **) vips_object_local_array( context, 1 );
+
+  int i;
+
+  /* Split the image into cropped frames.
+   */
+  for( i = 0; i &lt; n_pages; i++ )
+    if( vips_crop( image, &amp;page[i],
+      left, page_height * i + top, width, height, NULL ) )
+      return( -1 );
+
+  /* Reassemble the frames and set the page height. You must copy before 
+   * modifying metadata.
+   */
+  if( vips_arrayjoin( page, &amp;copy[0], n_pages, "across", 1, NULL ) ||
+    vips_copy( copy[0], out, NULL ) )
+    return( -1 );
+  vips_image_set_int( *out, "page-height", height );
+
+  return( 0 );
+}
+
+int 
+main( int argc, char **argv )
+{
+  VipsImage *image;
+  VipsObject *context;
+  VipsImage *x;
+
+  if( VIPS_INIT( NULL ) ) 
+    vips_error_exit( NULL ); 
+
+  if( !(image = vips_image_new_from_file( argv[1], 
+    "access", VIPS_ACCESS_SEQUENTIAL,
+    NULL )) )
+    vips_error_exit( NULL ); 
+
+  context = VIPS_OBJECT( vips_image_new() );
+  if( crop_animation( context, image, &amp;x, 10, 10, 500, 500 ) ) {
+    g_object_unref( image );
+    g_object_unref( context );
+    vips_error_exit( NULL ); 
+  }
+  g_object_unref( image );
+  g_object_unref( context );
+  image = x;
+
+  if( vips_image_write_to_file( image, argv[2], NULL ) ) {
+    g_object_unref( image );
+    vips_error_exit( NULL ); 
+  }
+
+  g_object_unref( image );
+
+  return( 0 );
+}
+</programlisting>
 </example>
 
   </refsect3>
 
 </refentry>
diff --git a/libvips/foreign/jp2ksave.c b/libvips/foreign/jp2ksave.c
index ac6b83c34..62420b1b6 100644
--- a/libvips/foreign/jp2ksave.c
+++ b/libvips/foreign/jp2ksave.c
@@ -182,17 +182,15 @@ static void
 vips_foreign_save_jp2k_warning_callback( const char *msg, void *client )
 {
 #ifdef DEBUG
-	g_warning( "jp2ksave: %s",  class->nickname, msg );
+	g_warning( "jp2ksave: %s", msg );
 #endif /*DEBUG*/
 }
 
-/* The openjpeg info and warning callbacks are incredibly chatty.
- */
 static void 
 vips_foreign_save_jp2k_info_callback( const char *msg, void *client )
 {
 #ifdef DEBUG
-	g_info( "jp2ksave: %s",  class->nickname, msg );
+	g_info( "jp2ksave: %s", msg );
 #endif /*DEBUG*/
 }
 
diff --git a/libvips/iofuncs/init.c b/libvips/iofuncs/init.c
index b7b9e8e0b..4700acac1 100644
--- a/libvips/iofuncs/init.c
+++ b/libvips/iofuncs/init.c
@@ -260,57 +260,53 @@ static int
 vips_load_plugins( const char *fmt, ... )
 {
         va_list ap;
         char dir_name[VIPS_PATH_MAX];
         GDir *dir;
 	const char *name;
         int result;
 
 	/* Silently succeed if we can't do modules.
 	 */
 	if( !g_module_supported() )
 		return( 0 );
 
         va_start( ap, fmt );
         (void) vips_vsnprintf( dir_name, VIPS_PATH_MAX - 1, fmt, ap );
         va_end( ap );
 
-#ifdef DEBUG
-	printf( "vips_load_plugins: searching \"%s\"\n", dir_name );
-#endif /*DEBUG*/
+	g_info( "searching \"%s\"", dir_name );
 
         if( !(dir = g_dir_open( dir_name, 0, NULL )) ) 
 		/* Silent success for dir not there.
 		 */
                 return( 0 );
 
         result = 0;
         while( (name = g_dir_read_name( dir )) )
                 if( vips_ispostfix( name, "." G_MODULE_SUFFIX )
 #if ENABLE_DEPRECATED
 				|| vips_ispostfix( name, ".plg" ) 
 #endif
 			) { 
 			char path[VIPS_PATH_MAX];
 			GModule *module;
 
 			vips_snprintf( path, VIPS_PATH_MAX - 1, 
 				"%s" G_DIR_SEPARATOR_S "%s", dir_name, name );
 
-#ifdef DEBUG
-			printf( "vips_load_plugins: loading \"%s\"\n", path );
-#endif /*DEBUG*/
+			g_info( "loading \"%s\"", path );
 
 			module = g_module_open( path, G_MODULE_BIND_LAZY );
 			if( !module ) {
 				g_warning( _( "unable to load \"%s\" -- %s" ), 
 					path, g_module_error() ); 
 				result = -1;
 			}
                 }
         g_dir_close( dir );
 
 	return( result );
 }
 
 /* Install this log handler to hide warning messages.
  */
@@ -388,230 +384,237 @@ int
 vips_init( const char *argv0 )
 {
 	extern GType vips_system_get_type( void );
 	extern GType write_thread_state_get_type( void );
 	extern GType sink_memory_thread_state_get_type( void ); 
 	extern GType render_thread_state_get_type( void ); 
 	extern GType vips_source_get_type( void ); 
 	extern GType vips_source_custom_get_type( void ); 
 	extern GType vips_target_get_type( void ); 
 	extern GType vips_target_custom_get_type( void ); 
 	extern GType vips_g_input_stream_get_type( void ); 
 
 	static gboolean started = FALSE;
 	static gboolean done = FALSE;
 	const char *vips_min_stack_size;
 	const char *prefix;
 	const char *libdir;
 	char *locale;
 
 	/* Two stage done handling: 'done' means we've completed, 'started'
 	 * means we're currently initialising. Use this to prevent recursive
 	 * invocation.
 	 */
 	if( done )
 		/* Called more than once, we succeeded, just return OK.
 		 */
 		return( 0 );
 	if( started ) 
 		/* Recursive invocation, something has broken horribly.
 		 * Hopefully the first init will handle it.
 		 */
 		return( 0 );
 	started = TRUE;
 
+	if( g_getenv( "VIPS_INFO" )
+#if ENABLE_DEPRECATED
+		|| g_getenv( "IM_INFO" )
+#endif
+	)
+		vips_verbose();
+	if( g_getenv( "VIPS_PROFILE" ) )
+		vips_profile_set( TRUE );
+	if( g_getenv( "VIPS_LEAK" ) )
+		vips_leak_set( TRUE );
+	if( g_getenv( "VIPS_TRACE" ) )
+		vips_cache_set_trace( TRUE );
+	if( g_getenv( "VIPS_PIPE_READ_LIMIT" ) ) 
+		vips_pipe_read_limit = 
+			g_ascii_strtoll( g_getenv( "VIPS_PIPE_READ_LIMIT" ),
+				NULL, 10 );
+	vips_pipe_read_limit_set( vips_pipe_read_limit );
+
 #ifdef G_OS_WIN32
 	/* Windows has a limit of 512 files open at once for the fopen() family
 	 * of functions, and 2048 for the _open() family. This raises the limit
 	 * of fopen() to the same level as _open().
 	 *
 	 * It will not go any higher than this, unfortunately.  
 	 */
 	(void) _setmaxstdio( 2048 );
 #endif /*G_OS_WIN32*/
 
 	vips__threadpool_init();
 	vips__buffer_init();
 	vips__meta_init();
 
 	/* This does an unsynchronised static hash table init on first call --
 	 * we have to make sure we do this single-threaded. See: 
 	 * https://github.com/openslide/openslide/issues/161
 	 */
 #if !GLIB_CHECK_VERSION( 2, 48, 1 )
 	(void) g_get_language_names(); 
 #endif
 
 	if( !vips__global_lock )
 		vips__global_lock = vips_g_mutex_new();
 
 	if( !vips__global_timer )
 		vips__global_timer = g_timer_new();
 
 	VIPS_SETSTR( vips__argv0, argv0 );
 	vips__prgname = g_path_get_basename( argv0 );
 
 	vips__thread_profile_attach( "main" );
 
 	/* We can't do VIPS_GATE_START() until command-line processing
 	 * happens, since vips__thread_profile may not be set yet. Call
 	 * directly. 
 	 */
 	vips__thread_gate_start( "init: main" ); 
 	vips__thread_gate_start( "init: startup" ); 
 
 	/* Try to discover our prefix. 
 	 */
+        if( (prefix = g_getenv( "VIPSHOME" )) )
+		g_info( "VIPSHOME = %s", prefix );
 	if( !(prefix = vips_guess_prefix( argv0, "VIPSHOME" )) || 
 		!(libdir = vips_guess_libdir( argv0, "VIPSHOME" )) ) 
 		return( -1 );
 
+	g_info( "VIPS_PREFIX = %s", VIPS_PREFIX );
+	g_info( "VIPS_LIBDIR = %s", VIPS_LIBDIR );
+	g_info( "prefix = %s", prefix );
+	g_info( "libdir = %s", libdir );
+
 	/* Get i18n .mo files from $VIPSHOME/share/locale/.
 	 */
 	locale = g_build_filename( prefix, "share", "locale", NULL );
 	bindtextdomain( GETTEXT_PACKAGE, locale );
 	g_free( locale );
 	bind_textdomain_codeset( GETTEXT_PACKAGE, "UTF-8" );
 
-	if( g_getenv( "VIPS_INFO" )
-#if ENABLE_DEPRECATED
-		|| g_getenv( "IM_INFO" )
-#endif
-	)
-		vips_verbose();
-	if( g_getenv( "VIPS_PROFILE" ) )
-		vips_profile_set( TRUE );
-	if( g_getenv( "VIPS_LEAK" ) )
-		vips_leak_set( TRUE );
-	if( g_getenv( "VIPS_TRACE" ) )
-		vips_cache_set_trace( TRUE );
-	if( g_getenv( "VIPS_PIPE_READ_LIMIT" ) ) 
-		vips_pipe_read_limit = 
-			g_ascii_strtoll( g_getenv( "VIPS_PIPE_READ_LIMIT" ),
-				NULL, 10 );
-	vips_pipe_read_limit_set( vips_pipe_read_limit );
-
 	/* Register base vips types.
 	 */
 	(void) vips_image_get_type();
 	(void) vips_region_get_type();
 	(void) write_thread_state_get_type();
 	(void) sink_memory_thread_state_get_type(); 
 	(void) render_thread_state_get_type(); 
 	(void) vips_source_get_type(); 
 	(void) vips_source_custom_get_type(); 
 	(void) vips_target_get_type(); 
 	(void) vips_target_custom_get_type(); 
 	vips__meta_init_types();
 	vips__interpolate_init();
 
 #if ENABLE_DEPRECATED
 	im__format_init();
 #endif
 
 	/* Start up operator cache.
 	 */
 	vips__cache_init();
 
 	/* Recomp reordering system.
 	 */
 	vips__reorder_init();
 
 	/* Start up packages.
 	 */
 	(void) vips_system_get_type();
 	vips_arithmetic_operation_init();
 	vips_conversion_operation_init();
 	vips_create_operation_init();
 	vips_foreign_operation_init();
 	vips_resample_operation_init();
 	vips_colour_operation_init();
 	vips_histogram_operation_init();
 	vips_convolution_operation_init();
 	vips_freqfilt_operation_init();
 	vips_morphology_operation_init();
 	vips_draw_operation_init();
 	vips_mosaicing_operation_init();
 	vips_g_input_stream_get_type(); 
 
 	/* Load any vips8 modules from the vips libdir. Keep going, even if
 	 * some modules fail to load. 
 	 */
 	(void) vips_load_plugins( "%s/vips-modules-%d.%d", 
 		libdir, VIPS_MAJOR_VERSION, VIPS_MINOR_VERSION );
 
 #if ENABLE_DEPRECATED
 	/* Load any vips8 plugins from the vips libdir.
 	 */
 	(void) vips_load_plugins( "%s/vips-plugins-%d.%d", 
 		libdir, VIPS_MAJOR_VERSION, VIPS_MINOR_VERSION );
 
 	/* Load up any vips7 plugins in the vips libdir. We don't error on 
 	 * failure, it's too annoying to have VIPS refuse to start because of 
 	 * a broken plugin.
 	 */
 	if( im_load_plugins( "%s/vips-%d.%d", 
 		libdir, VIPS_MAJOR_VERSION, VIPS_MINOR_VERSION ) ) {
 		g_warning( "%s", vips_error_buffer() );
 		vips_error_clear();
 	}
 
 	/* Also load from libdir. This is old and slightly broken behaviour
 	 * :-( kept for back compat convenience.
 	 */
 	if( im_load_plugins( "%s", libdir ) ) {
 		g_warning( "%s", vips_error_buffer() );
 		vips_error_clear();
 	}
 #endif
 
 	/* Get the run-time compiler going.
 	 */
 	vips_vector_init();
 
 #ifdef HAVE_GSF
 	/* Use this for structured file write.
 	 */
 	gsf_init();
 #endif /*HAVE_GSF*/
 
 	/* Register vips_shutdown(). This may well not get called and many
 	 * platforms don't support it anyway.
 	 */
 #ifdef HAVE_ATEXIT
 	atexit( vips_shutdown );
 #endif /*HAVE_ATEXIT*/
 
 #ifdef DEBUG_LEAK
 	vips__image_pixels_quark = 
 		g_quark_from_static_string( "vips-image-pixels" ); 
 #endif /*DEBUG_LEAK*/
 
 	done = TRUE;
 
 	/* If VIPS_WARNING is defined, suppress all warning messages from vips.
 	 *
 	 * Libraries should not call g_log_set_handler(), it is
 	 * supposed to be for the application layer, but this can be awkward to
 	 * set up if you are using libvips from something like Ruby. Allow this
 	 * env var hack as a workaround. 
 	 */
 	if( g_getenv( "VIPS_WARNING" )
 #if ENABLE_DEPRECATED
 		|| g_getenv( "IM_WARNING" )
 #endif
 	)
 		g_log_set_handler( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING, 
 			empty_log_handler, NULL );
 
 	/* Set a minimum stacksize, if we can.
 	 */
         if( (vips_min_stack_size = g_getenv( "VIPS_MIN_STACK_SIZE" )) )
 		(void) set_stacksize( vips__parse_size( vips_min_stack_size ) );
 
 	vips__thread_gate_stop( "init: startup" ); 
 
 	return( 0 );
 }
 
 /* Call this before vips stuff that uses stuff we need to have inited.
  */
@@ -949,64 +952,57 @@ static char *
 extract_prefix( const char *dir, const char *name )
 {
 	char edir[VIPS_PATH_MAX];
 	char vname[VIPS_PATH_MAX];
 	int i;
 
-#ifdef DEBUG
-	printf( "extract_prefix: trying for dir = \"%s\", name = \"%s\"\n", 
-		dir, name );
-#endif /*DEBUG*/
+	g_info( "trying for dir = \"%s\", name = \"%s\"", dir, name );
 
 	/* Is dir relative? Prefix with cwd.
 	 */
 	if( !g_path_is_absolute( dir ) ) {
 		char *cwd; 
 
 		cwd = g_get_current_dir();
 		vips_snprintf( edir, VIPS_PATH_MAX, 
 			"%s" G_DIR_SEPARATOR_S "%s", cwd, dir );
 		g_free( cwd );
 	}
 	else {
 		vips_strncpy( edir, dir, VIPS_PATH_MAX );
 	}
 
 	/* Chop off the trailing prog name, plus the trailing
 	 * G_DIR_SEPARATOR_S.
 	 */
 	if( !vips_ispostfix( edir, name ) ) 
 		return( NULL );
 	vips_strncpy( vname, edir, VIPS_PATH_MAX );
 	vname[strlen( edir ) - strlen( name ) - 1] = '\0';
 
 	/* Remove any "/./", any trailing "/.", any trailing "/".
 	 */
 	for( i = 0; i < (int) strlen( vname ); i++ ) 
 		if( vips_isprefix( G_DIR_SEPARATOR_S "." G_DIR_SEPARATOR_S, 
 			vname + i ) )
 			memmove( vname + i, vname + i + 2, 
 				strlen( vname + i + 2 ) + 1 );
 	if( vips_ispostfix( vname, G_DIR_SEPARATOR_S "." ) )
 		vname[strlen( vname ) - 2] = '\0';
 	if( vips_ispostfix( vname, G_DIR_SEPARATOR_S ) )
 		vname[strlen( vname ) - 1] = '\0';
 
-#ifdef DEBUG
-	printf( "extract_prefix: canonicalised path = \"%s\"\n", vname );
-#endif /*DEBUG*/
+	g_info( "canonicalised path = \"%s\"", vname );
 
 	/* Ought to be a "/bin" at the end now.
 	 */
 	if( !vips_ispostfix( vname, G_DIR_SEPARATOR_S "bin" ) ) 
 		return( NULL );
 	vname[strlen( vname ) - strlen( G_DIR_SEPARATOR_S "bin" )] = '\0';
 
-#ifdef DEBUG
-	printf( "extract_prefix: found \"%s\"\n", vname );
-#endif /*DEBUG*/
+	g_info( "found \"%s\"", vname );
 
 	return( vips_strdup( NULL, vname ) );
 }
 
 /* Search a path for a file ... we overwrite the PATH string passed in.
  */
@@ -1014,30 +1010,28 @@ static char *
 scan_path( char *path, const char *name )
 {
 	char *p, *q;
 	char *prefix;
 
 	for( p = path; 
 		(q = vips_break_token( p, G_SEARCHPATH_SEPARATOR_S )); p = q ) {
 		char str[VIPS_PATH_MAX];
 
 		/* Form complete path.
 		 */
 		vips_snprintf( str, VIPS_PATH_MAX, 
 			"%s" G_DIR_SEPARATOR_S "%s", p, name );
 
-#ifdef DEBUG
-		printf( "scan_path: looking in \"%s\" for \"%s\"\n", 
+		g_info( "looking in \"%s\" for \"%s\"", 
 			p, name );
-#endif /*DEBUG*/
 
 		if( vips_existsf( "%s", str ) && 
 			(prefix = extract_prefix( str, name )) ) {
 			return( prefix );
 		}
 	}
 
 	return( NULL );
 }
 
 /* Look for a file along PATH. If we find it, look for an enclosing prefix.
  */
@@ -1045,36 +1039,34 @@ static char *
 find_file( const char *name )
 {
 	const char *path = g_getenv( "PATH" );
 	char *prefix;
 	char full_path[VIPS_PATH_MAX];
 
 	if( !path )
 		return( NULL );
 
-#ifdef DEBUG
-	printf( "vips_guess_prefix: g_getenv( \"PATH\" ) == \"%s\"\n", path );
-#endif /*DEBUG*/
+	g_info( "g_getenv( \"PATH\" ) == \"%s\"", path );
 
 #ifdef G_OS_WIN32
 {
 	char *dir; 
 
 	/* Windows always searches '.' first, so prepend cwd to path.
 	 */
 	dir = g_get_current_dir();
 	vips_snprintf( full_path, VIPS_PATH_MAX, 
 		"%s" G_SEARCHPATH_SEPARATOR_S "%s", dir, path );
 	g_free( dir ); 
 }
 #else /*!G_OS_WIN32*/
 	vips_strncpy( full_path, path, VIPS_PATH_MAX );
 #endif /*G_OS_WIN32*/
 
 	if( (prefix = scan_path( full_path, name )) ) 
 		return( prefix );
 
 	return( NULL );
 }
 
 /* Guess a value for the install PREFIX.
  */
@@ -1082,81 +1074,83 @@ static const char *
 guess_prefix( const char *argv0, const char *name )
 {
 	char *prefix;
 
+	/* We've already checked for VIPSHOME. If the configure-time
+	 * library prefix looks OK, use the configure-time prefix.
+	 */
+	if( vips_existsf( "%s/vips-modules-%d.%d", 
+		VIPS_LIBDIR, VIPS_MAJOR_VERSION, VIPS_MINOR_VERSION ) ) {
+		g_info( "found %s/vips-modules-%d.%d", 
+			VIPS_LIBDIR, VIPS_MAJOR_VERSION, VIPS_MINOR_VERSION );
+		g_info( "using configure-time prefix" );
+		return( VIPS_PREFIX );
+	}
+
 	/* Try to guess from argv0.
 	 */
 	if( argv0 ) {
 		if( g_path_is_absolute( argv0 ) ) {
 			/* Must point to our executable.
 			 */
 			if( (prefix = extract_prefix( argv0, name )) ) {
-#ifdef DEBUG
-				printf( "vips_guess_prefix: found \"%s\" from "
-					"argv0\n", prefix );
-#endif /*DEBUG*/
+				g_info( "found \"%s\" from argv0", prefix );
 				return( prefix );
 			} 
 		}
 
 		/* Look along path for name.
 		 */
 		if( (prefix = find_file( name )) ) {
-#ifdef DEBUG
-			printf( "vips_guess_prefix: found \"%s\" from "
-				"PATH\n", prefix );
-#endif /*DEBUG*/
+			g_info( "found \"%s\" from PATH", prefix );
 			return( prefix );
 		}
         }
 
 	/* Try to guess from cwd. Only if this is a relative path, though. 
 	 */
 	if( argv0 &&
 		!g_path_is_absolute( argv0 ) ) {
 		char *dir;
 		char full_path[VIPS_PATH_MAX];
 		char *resolved;
 
 		dir = g_get_current_dir(); 
 		vips_snprintf( full_path, VIPS_PATH_MAX, 
 			"%s" G_DIR_SEPARATOR_S "%s", dir, argv0 );
 		g_free( dir ); 
 
 		if( (resolved = vips_realpath( full_path )) ) {
 			prefix = extract_prefix( resolved, name );
 			g_free( resolved );
 
 			if( prefix ) { 
-#ifdef DEBUG
-				printf( "vips_guess_prefix: found \"%s\" "
-					"from cwd\n", prefix );
-#endif /*DEBUG*/
+				g_info( "found \"%s\" from cwd", prefix );
 				return( prefix );
 			}
 		}
 	}
 
 	/* Fall back to the configure-time prefix.
 	 */
 	return( VIPS_PREFIX );
 }
 
 /** 
  * vips_guess_prefix:
  * @argv0: program name (typically argv[0])
  * @env_name: save prefix in this environment variable
  *
  * vips_guess_prefix() tries to guess the install directory. You should pass 
  * in the value of argv[0] (the name your program was run as) as a clue to 
  * help it out, plus the name of the environment variable you let the user 
  * override your package install area with (eg. "VIPSHOME"). 
  *
  * On success, vips_guess_prefix() returns the prefix it discovered, and as a 
  * side effect, sets the environment variable (if it's not set).
  *
  * Don't free the return string!
  * 
  * See also: vips_guess_libdir().
  *
  * Returns: (transfer none): the install prefix as a static string, do not free.
  */
@@ -1164,51 +1158,46 @@ const char *
 vips_guess_prefix( const char *argv0, const char *env_name )
 {
         const char *prefix;
 
 	/* Already set?
 	 */
-        if( (prefix = g_getenv( env_name )) ) {
-#ifdef DEBUG
-		printf( "vips_guess_prefix: found \"%s\" in environment\n", 
-			prefix );
-#endif /*DEBUG*/
+        if( (prefix = g_getenv( env_name )) ) 
                 return( prefix );
-	}
 
 #ifdef G_OS_WIN32
 	prefix = vips__windows_prefix();
 #else /*!G_OS_WIN32*/
 {
         char *basename;
 
 	basename = g_path_get_basename( argv0 );
 	prefix = guess_prefix( argv0, basename );
 	g_free( basename ); 
 }
 #endif /*G_OS_WIN32*/
 
 	g_setenv( env_name, prefix, TRUE );
 
 	return( prefix );
 }
 
 /** 
  * vips_guess_libdir:
  * @argv0: program name (typically argv[0])
  * @env_name: save prefix in this environment variable
  *
  * vips_guess_libdir() tries to guess the install directory (usually the 
  * configure libdir, or $prefix/lib). You should pass 
  * in the value of argv[0] (the name your program was run as) as a clue to 
  * help it out, plus the name of the environment variable you let the user 
  * override your package install area with (eg. "VIPSHOME"). 
  *
  * On success, vips_guess_libdir() returns the libdir it discovered, and as a 
  * side effect, sets the prefix environment variable (if it's not set).
  *
  * Don't free the return string!
  * 
  * See also: vips_guess_prefix().
  *
  * Returns: (transfer none): the libdir as a static string, do not free.
  */
@@ -1216,36 +1205,29 @@ const char *
 vips_guess_libdir( const char *argv0, const char *env_name )
 {
 	const char *prefix = vips_guess_prefix( argv0, env_name );
         static char *libdir = NULL;
 
 	if( libdir )
 		return( libdir );
 
 	/* Have we been moved since configure? If not, use the configure-time
 	 * libdir.
 	 */
 	if( strcmp( prefix, VIPS_PREFIX ) == 0 ) 
 		libdir = VIPS_LIBDIR;
 	else if ( strstr(VIPS_LIBDIR, "/lib64") )
 		libdir = g_strdup_printf( "%s/lib64", prefix );
 	else
 		libdir = g_strdup_printf( "%s/lib", prefix );
 
-#ifdef DEBUG
-	printf( "vips_guess_libdir: VIPS_PREFIX = %s\n", VIPS_PREFIX );
-	printf( "vips_guess_libdir: VIPS_LIBDIR = %s\n", VIPS_LIBDIR );
-	printf( "vips_guess_libdir: prefix = %s\n", prefix );
-	printf( "vips_guess_libdir: libdir = %s\n", libdir );
-#endif /*DEBUG*/
-
 	return( libdir );
 }
 
 /**
  * vips_version_string:
  *
  * Get the VIPS version as a static string, including a build date and time.
  * Do not free.
  *
  * Returns: (transfer none): a static version string
  */
diff --git a/tools/vips.c b/tools/vips.c
index 355523529..a88530e91 100644
--- a/tools/vips.c
+++ b/tools/vips.c
@@ -511,253 +511,261 @@ int
 main( int argc, char **argv )
 {
 	char *action;
 	GOptionContext *context;
 	GOptionGroup *main_group;
 	GOptionGroup *group;
 	VipsOperation *operation;
 #if ENABLE_DEPRECATED
 	im_function *fn;
 #endif
 	int i, j;
 	gboolean handled;
 
 	GError *error = NULL;
 
 	if( VIPS_INIT( argv[0] ) )
 		vips_error_exit( NULL );
 	textdomain( GETTEXT_PACKAGE );
 	setlocale( LC_ALL, "" );
 
+{
+	char *basename;
+
+	basename = g_path_get_basename( argv[0] );
+	g_set_prgname( basename );
+	g_free( basename );
+}
+
 	/* On Windows, argv is ascii-only .. use this to get a utf-8 version of
 	 * the args.
 	 */
 #ifdef G_OS_WIN32
 	argv = g_win32_get_command_line();
 #endif /*G_OS_WIN32*/
 
 #ifdef DEBUG_FATAL
 	/* Set masks for debugging ... stop on any problem. 
 	 */
 	g_log_set_always_fatal(
 		G_LOG_FLAG_RECURSION |
 		G_LOG_FLAG_FATAL |
 		G_LOG_LEVEL_ERROR |
 		G_LOG_LEVEL_CRITICAL |
 		G_LOG_LEVEL_WARNING );
 #endif /*!DEBUG_FATAL*/
 
 	context = g_option_context_new( _( "[ACTION] [OPTIONS] [PARAMETERS] - "
 		"VIPS driver program" ) );
 
 	/* Add and parse the outermost options: the ones this program uses.
 	 * For example, we need
 	 * to be able to spot that in the case of "--plugin ./poop.plg" we
 	 * must remove two args.
 	 */
 	main_group = g_option_group_new( NULL, NULL, NULL, NULL, NULL );
 	g_option_group_add_entries( main_group, main_option );
 	vips_add_option_entries( main_group ); 
 	g_option_group_set_translation_domain( main_group, GETTEXT_PACKAGE );
 	g_option_context_set_main_group( context, main_group );
 
 	/* We add more options later, for example as options to vips8
 	 * operations. Ignore any unknown options in this first parse.
 	 */
 	g_option_context_set_ignore_unknown_options( context, TRUE );
 
 	/* "vips" with no arguments does "vips --help".
 	 */
 	if( argc == 1 ) { 
 		char *help;
 
 		help = g_option_context_get_help( context, TRUE, NULL );
 		printf( "%s", help );
 		g_free( help );
 
 		exit( 0 );
 	}
 
 	/* Also disable help output: we want to be able to display full help
 	 * in a second pass after all options have been created.
 	 */
 	g_option_context_set_help_enabled( context, FALSE );
 
 #ifdef G_OS_WIN32
 	if( !g_option_context_parse_strv( context, &argv, &error ) ) 
 #else /*!G_OS_WIN32*/
 	if( !g_option_context_parse( context, &argc, &argv, &error ) ) 
 #endif /*G_OS_WIN32*/
 	{
 		if( error ) {
 			fprintf( stderr, "%s\n", error->message );
 			g_error_free( error );
 		}
 
 		vips_error_exit( NULL );
 	}
 
 	/* On Windows, argc will not have been updated by
 	 * g_option_context_parse_strv().
 	 */
 	for( argc = 0; argv[argc]; argc++ )
 		;
 
 	if( main_option_plugin ) {
 #if ENABLE_DEPRECATED
 		if( !im_load_plugin( main_option_plugin ) )
 			vips_error_exit( NULL );
 #else /*!ENABLE_DEPRECATED*/
 		GModule *module;
 
 		module = g_module_open( main_option_plugin, G_MODULE_BIND_LAZY );
 		if( !module ) {
 			vips_error_exit( _( "unable to load \"%s\" -- %s" ),
 				main_option_plugin, g_module_error() );
 		}
 #endif
 	}
 
 	if( main_option_version ) 
 		printf( "vips-%s\n", vips_version_string() );
 
 	/* Reenable help and unknown option detection ready for the second
 	 * option parse.
 	 */
 	g_option_context_set_ignore_unknown_options( context, FALSE );
 	g_option_context_set_help_enabled( context, TRUE );
 
 	/* Try to find our action.
 	 */
 	handled = FALSE;
 	action = NULL;
 
 	/* Should we try to run the thing we are named as?
 	 */
 	if( !isvips( g_get_prgname() ) ) 
 		action = argv[0];
 
 	if( !action ) {
 		/* Look for the first non-option argument, if any, and make 
 		 * that our action. The parse above will have removed most of
 		 * them, but --help (for example) could still remain. 
 		 */
 		for( i = 1; i < argc; i++ )
 			if( argv[i][0] != '-' ) {
 				action = argv[i];
 
 				/* Remove the action from argv.
 				 */
 				for( j = i; j < argc; j++ )
 					argv[j] = argv[j + 1];
 				argc -= 1;
 
 				break;
 			}
 	}
 
 	/* Could be one of our built-in actions.
 	 */
 	if( action ) 
 		for( i = 0; i < VIPS_NUMBER( actions ); i++ )
 			if( strcmp( action, actions[i].name ) == 0 ) {
 				group = add_operation_group( context, NULL );
 				g_option_group_add_entries( group, 
 					actions[i].group );
 				parse_options( context, &argc, argv );
 
 				if( actions[i].action( argc - 1, argv + 1 ) ) 
 					vips_error_exit( "%s", action );
 
 				handled = TRUE;
 				break;
 			}
 
 #if ENABLE_DEPRECATED
 	/* Could be a vips7 im_function. We need to test for vips7 first,
 	 * since we don't want to use the vips7 compat wrappers in vips8
 	 * unless we have to. They don't support all args types.
 	 */
 	if( action && 
 		!handled && 
 		(fn = im_find_function( action )) ) {
 		if( im_run_command( action, argc - 1, argv + 1 ) ) {
 			if( argc == 1 ) 
 				usage( fn );
 			else
 				vips_error_exit( NULL );
 		}
 
 		handled = TRUE;
 	}
 
 	/* im_find_function() set an error msg.
 	 */
 	if( action &&
 		!handled )
 		vips_error_clear();
 #endif
 
 	/* Could be a vips8 VipsOperation.
 	 */
 	if( action && 
 		!handled && 
 		(operation = vips_operation_new( action )) ) {
 		group = add_operation_group( context, operation );
 		vips_call_options( group, operation );
 		parse_options( context, &argc, argv );
 
 		if( vips_call_argv( operation, argc - 1, argv + 1 ) ) {
 			if( argc == 1 ) 
 				vips_operation_class_print_usage( 
 					VIPS_OPERATION_GET_CLASS( operation ) );
 
 			vips_object_unref_outputs( VIPS_OBJECT( operation ) );
 			g_object_unref( operation );
 
 			if( argc == 1 )
 				/* We don't exit with an error for something
 				 * like "vips fitsload" failing, we use it to
 				 * decide if an optional component has been
 				 * configured. If we've been built without
 				 * fits support, fitsload will fail to find
 				 * the operation and we'll error with "unknown
 				 * action" below.
 				 */
 				exit( 0 );
 			else
 				vips_error_exit( NULL );
 		}
 
 		vips_object_unref_outputs( VIPS_OBJECT( operation ) );
 		g_object_unref( operation );
 
 		handled = TRUE;
 	}
 
 	/* vips_operation_new() sets an error msg for unknown operation.
 	 */
 	if( action &&
 		!handled )
 		vips_error_clear();
 
 	if( action && 
 		!handled ) {
 		vips_error_exit( _( "unknown action \"%s\"" ), action );
 	}
 
 	/* Still not handled? We may not have called parse_options(), so
 	 * --help args may not have been processed.
 	 */
 	if( !handled )
 		parse_options( context, &argc, argv );
 
 	g_option_context_free( context );
 
 #ifdef G_OS_WIN32
 	g_strfreev( argv ); 
 #endif /*G_OS_WIN32*/
 
 	vips_shutdown();
 
 	return( 0 );
 }
diff --git a/tools/vipsedit.c b/tools/vipsedit.c
index 18d4c4321..1052d2ec8 100644
--- a/tools/vipsedit.c
+++ b/tools/vipsedit.c
@@ -131,159 +131,167 @@ int
 main( int argc, char **argv )
 {
 	GOptionContext *context;
 	GOptionGroup *main_group;
 	GError *error = NULL;
 	VipsImage *im;
 	unsigned char header[VIPS_SIZEOF_HEADER];
 
 	if( VIPS_INIT( argv[0] ) )
 	        vips_error_exit( "%s", _( "unable to start VIPS" ) );
 	textdomain( GETTEXT_PACKAGE );
 	setlocale( LC_ALL, "" );
 
+{
+	char *basename;
+
+	basename = g_path_get_basename( argv[0] );
+	g_set_prgname( basename );
+	g_free( basename );
+}
+
 	/* On Windows, argv is ascii-only .. use this to get a utf-8 version of
 	 * the args.
 	 */
 #ifdef G_OS_WIN32
 	argv = g_win32_get_command_line();
 #endif /*G_OS_WIN32*/
 
 	context = g_option_context_new( 
 		_( "vipsedit - edit vips file header" ) );
 	main_group = g_option_group_new( NULL, NULL, NULL, NULL, NULL );
 	g_option_group_add_entries( main_group, entries );
 	vips_add_option_entries( main_group ); 
 	g_option_group_set_translation_domain( main_group, GETTEXT_PACKAGE );
 	g_option_context_set_main_group( context, main_group );
 
 #ifdef G_OS_WIN32
 	if( !g_option_context_parse_strv( context, &argv, &error ) ) 
 #else /*!G_OS_WIN32*/
 	if( !g_option_context_parse( context, &argc, &argv, &error ) ) 
 #endif /*G_OS_WIN32*/
 	{
 		vips_g_error( &error );
 
 		exit( -1 );
 	}
 
 	/* On Windows, argc will not have been updated by
 	 * g_option_context_parse_strv().
 	 */
 	for( argc = 0; argv[argc]; argc++ )
 		;
 
 	if( version ) 
 		printf( "vips-%s\n", vips_version_string() );
 
 	if( argc != 2 ) { 
 		fprintf( stderr, _( "usage: %s [OPTION...] vips-file\n" ), 
 			g_get_prgname() );
 
 		exit( -1 );
 	}
 
 	if( !(im = vips_image_new_from_file( argv[1], NULL )) )
 		vips_error_exit( _( "could not open image %s" ), argv[1] );
 
 	vips__seek( im->fd, 0, SEEK_SET );
 	if( read( im->fd, header, VIPS_SIZEOF_HEADER ) !=
 		VIPS_SIZEOF_HEADER ||
 		vips__read_header_bytes( im, header ) )
 		vips_error_exit( _( "could not read VIPS header for %s" ),
 			im->filename );
 
 	if( endian ) {
 		if( strcmp( endian, "little" ) == 0 )
 			im->magic = VIPS_MAGIC_INTEL;
 		else if( strcmp( endian, "big" ) == 0 )
 			im->magic = VIPS_MAGIC_SPARC;
 		else
 			vips_error_exit( _( "bad endian-ness %s, "
 				"should be 'big' or 'little'" ), endian );
 	}
 	if( xsize ) 
 		parse_pint( xsize, &im->Xsize );
 	if( ysize ) 
 		parse_pint( ysize, &im->Ysize );
 	if( bands ) 
 		parse_pint( bands, &im->Bands );
 	if( format ) {
 		int f;
 
 		if( (f = vips_enum_from_nick( argv[0],
 				VIPS_TYPE_BAND_FORMAT, format )) < 0 )
 			vips_error_exit( _( "bad format %s" ), format );
 
 		im->BandFmt = f;
 
 		/* We don't use this, but make sure it's set in case any 
 		 * old binaries are expecting it.
 		 */
 		im->Bbits = vips_format_sizeof( f ) << 3;
 	}
 	if( interpretation ) {
 		int i;
 
 		if( (i = vips_enum_from_nick( argv[0], 
 				VIPS_TYPE_INTERPRETATION, interpretation )) < 0 )
 			vips_error_exit( _( "bad interpretation %s" ), 
 				interpretation );
 
 		im->Type = i;
 	}
 	if( coding ) {
 		int c;
 
 		if( (c = vips_enum_from_nick( argv[0],
 				VIPS_TYPE_CODING, coding )) < 0 )
 			vips_error_exit( _( "bad coding %s" ), coding );
 
 		im->Coding = c;
 	}
 	if( xres ) 
 		im->Xres = atof( xres );
 	if( yres ) 
 		im->Yres = atof( yres );
 	if( xoffset ) 
 		im->Xoffset = atoi( xoffset );
 	if( yoffset ) 
 		im->Yoffset = atoi( yoffset );
 
 	if( vips__seek( im->fd, 0, SEEK_SET ) == (off_t) -1 )
 		vips_error_exit( _( "could not seek on %s" ), im->filename );
 	if( vips__write_header_bytes( im, header ) ||
 		vips__write( im->fd, header, VIPS_SIZEOF_HEADER ) )
 		vips_error_exit( _( "could not write to %s" ), im->filename );
 
 	if( setext ) {
 		char *xml;
 		size_t size;
 
 		if( !(xml = vips__file_read( stdin, "stdin", &size )) )
 			vips_error_exit( "%s", _( "could not get ext data" ) );
 
 		/* Strip trailing whitespace ... we can get stray \n at the 
 		 * end, eg. "echo | vipsedit --setext fred.v".
 		 */
 		while( size > 0 && isspace( xml[size - 1] ) )
 			size -= 1;
 
 		if( vips__write_extension_block( im, xml, size ) )
 			vips_error_exit( "%s", _( "could not set extension" ) );
 		g_free( xml );
 	}
 
 	g_object_unref( im );
 
 	g_option_context_free( context );
 
 #ifdef G_OS_WIN32
 	g_strfreev( argv ); 
 #endif /*G_OS_WIN32*/
 
 	vips_shutdown();
 
 	return( 0 );
 }
 
diff --git a/tools/vipsheader.c b/tools/vipsheader.c
index ed79f9d63..c992d6bb8 100644
--- a/tools/vipsheader.c
+++ b/tools/vipsheader.c
@@ -170,94 +170,102 @@ int
 main( int argc, char *argv[] )
 {
 	GOptionContext *context;
 	GOptionGroup *main_group;
 	GError *error = NULL;
 	int i;
 	int result;
 
 	if( VIPS_INIT( argv[0] ) )
 	        vips_error_exit( "unable to start VIPS" );
 	textdomain( GETTEXT_PACKAGE );
 	setlocale( LC_ALL, "" );
 
+{
+	char *basename;
+
+	basename = g_path_get_basename( argv[0] );
+	g_set_prgname( basename );
+	g_free( basename );
+}
+
 	/* On Windows, argv is ascii-only .. use this to get a utf-8 version of
 	 * the args.
 	 */
 #ifdef G_OS_WIN32
 	argv = g_win32_get_command_line();
 #endif /*G_OS_WIN32*/
 
         context = g_option_context_new( _( "- print image header" ) );
 	main_group = g_option_group_new( NULL, NULL, NULL, NULL, NULL );
 	g_option_group_add_entries( main_group, main_option );
 	vips_add_option_entries( main_group ); 
 	g_option_group_set_translation_domain( main_group, GETTEXT_PACKAGE );
 	g_option_context_set_main_group( context, main_group );
 
 #ifdef G_OS_WIN32
 	if( !g_option_context_parse_strv( context, &argv, &error ) ) 
 #else /*!G_OS_WIN32*/
 	if( !g_option_context_parse( context, &argc, &argv, &error ) ) 
 #endif /*G_OS_WIN32*/
 	{
 		if( error ) {
 			fprintf( stderr, "%s\n", error->message );
 			g_error_free( error );
 		}
 
 		vips_error_exit( "try \"%s --help\"", g_get_prgname() );
 	}
 
 	g_option_context_free( context );
 
 	if( version ) 
 		printf( "vips-%s\n", vips_version_string() );
 
 	result = 0;
 
 	for( i = 1; argv[i]; i++ ) {
 		VipsImage *image;
 		char filename[VIPS_PATH_MAX];
                 char option_string[VIPS_PATH_MAX];
 
 		vips__filename_split8( argv[i], filename, option_string );
 		if( strcmp( filename, "stdin" ) == 0 ) {
 			VipsSource *source;
 
                         if( !(source = vips_source_new_from_descriptor( 0 )) )
                                 return( -1 );
                         if( !(image = vips_image_new_from_source( source,
                                 option_string, NULL )) ) {
                                 VIPS_UNREF( source );
                                 return( -1 );
                         }
                         VIPS_UNREF( source );
 		}
 		else {
 			if( !(image = 
 				vips_image_new_from_file( argv[i], NULL )) ) {
 				print_error();
 				result = 1;
 			}
 		}
 
 		if( image && 
 			print_header( image, argv[2] != NULL ) ) {
 			print_error();
 			result = 1;
 		}
 
 		if( image )
 			g_object_unref( image );
 	}
 
 	/* We don't free this on error exit, sadly.
 	 */
 #ifdef G_OS_WIN32
 	g_strfreev( argv ); 
 #endif /*G_OS_WIN32*/
 
 	vips_shutdown();
 
 	return( result );
 }
diff --git a/tools/vipsthumbnail.c b/tools/vipsthumbnail.c
index afb956fde..685182017 100644
--- a/tools/vipsthumbnail.c
+++ b/tools/vipsthumbnail.c
@@ -486,94 +486,98 @@ int
 main( int argc, char **argv )
 {
 	GOptionContext *context;
 	GOptionGroup *main_group;
 	GError *error = NULL;
 	int i;
 	int result;
 
 	if( VIPS_INIT( argv[0] ) )
 	        vips_error_exit( "unable to start VIPS" );
 	textdomain( GETTEXT_PACKAGE );
 	setlocale( LC_ALL, "" );
 
-	/* The operation cache is not useful for processing many files.
-	vips_cache_set_max( 0 );
-	 */
+{
+	char *basename;
+
+	basename = g_path_get_basename( argv[0] );
+	g_set_prgname( basename );
+	g_free( basename );
+}
 
 	/* On Windows, argv is ascii-only .. use this to get a utf-8 version of
 	 * the args.
 	 */
 #ifdef G_OS_WIN32
 	argv = g_win32_get_command_line();
 #endif /*G_OS_WIN32*/
 
         context = g_option_context_new( _( "- thumbnail generator" ) );
 
 	main_group = g_option_group_new( NULL, NULL, NULL, NULL, NULL );
 	g_option_group_add_entries( main_group, options );
 	vips_add_option_entries( main_group ); 
 	g_option_group_set_translation_domain( main_group, GETTEXT_PACKAGE );
 	g_option_context_set_main_group( context, main_group );
 
 #ifdef G_OS_WIN32
 	if( !g_option_context_parse_strv( context, &argv, &error ) ) 
 #else /*!G_OS_WIN32*/
 	if( !g_option_context_parse( context, &argc, &argv, &error ) ) 
 #endif /*G_OS_WIN32*/
 	{
 		if( error ) {
 			fprintf( stderr, "%s\n", error->message );
 			g_error_free( error );
 		}
 
 		vips_error_exit( "try \"%s --help\"", g_get_prgname() );
 	}
 
 	g_option_context_free( context );
 
 	if( version ) 
 		printf( "vips-%s\n", vips_version_string() );
 
 	if( thumbnail_size && 
 		thumbnail_parse_geometry( thumbnail_size ) )
 		vips_error_exit( NULL ); 
 
 #ifndef HAVE_EXIF
 	if( rotate_image ) 
 		g_warning( "%s",
 			_( "auto-rotate disabled: "
 			      "libvips built without exif support" ) );
 #endif /*!HAVE_EXIF*/
 
 	result = 0;
 
 	for( i = 1; argv[i]; i++ ) {
 		/* Hang resources for processing this thumbnail off @process.
 		 */
 		VipsObject *process = VIPS_OBJECT( vips_image_new() ); 
 
 		if( thumbnail_process( process, argv[i] ) ) {
 			fprintf( stderr, "%s: unable to thumbnail %s\n", 
 				argv[0], argv[i] );
 			fprintf( stderr, "%s", vips_error_buffer() );
 			vips_error_clear();
 
 			/* We had a conversion failure: return an error code
 			 * when we finally exit.
 			 */
 			result = -1;
 		}
 
 		g_object_unref( process );
 	}
 
 	/* We don't free this on error exit, sadly.
 	 */
 #ifdef G_OS_WIN32
 	g_strfreev( argv ); 
 #endif /*G_OS_WIN32*/
 
 	vips_shutdown();
 
 	return( result );
 }
