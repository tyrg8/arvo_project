commit a1ec2655d242d528af0337c4ee28059f245999e8
Author: Even Rouault <even.rouault@spatialys.com>
Date:   Tue Jun 4 09:57:25 2019 +0200

    COG: add reprojection support

diff --git a/autotest/gcore/cog.py b/autotest/gcore/cog.py
index 113ea66f5f..24e3de1473 100755
--- a/autotest/gcore/cog.py
+++ b/autotest/gcore/cog.py
@@ -223,3 +223,152 @@ def test_cog_creation_of_overviews_with_mask():
     gdal.GetDriverByName('GTiff').Delete(filename)
     gdal.Unlink(directory)
 
+
+
+###############################################################################
+# Test full world reprojection to WebMercator
+
+
+def test_cog_small_world_to_web_mercator():
+
+    tab = [ 0 ]
+    def my_cbk(pct, _, arg):
+        assert pct >= tab[0]
+        tab[0] = pct
+        return 1
+
+    directory = '/vsimem/test_cog_small_world_to_web_mercator'
+    gdal.Mkdir(directory, 0o755)
+    filename = directory + '/cog.tif'
+    src_ds = gdal.Open('../gdrivers/data/small_world.tif')
+    ds = gdal.GetDriverByName('COG').CreateCopy(filename, src_ds,
+        options = ['TILING_SCHEME=GoogleMapsCompatible', 'COMPRESS=JPEG'],
+        callback = my_cbk,
+        callback_data = tab)
+    assert tab[0] == 1.0
+    assert ds
+    assert len(gdal.ReadDir(directory)) == 1 # check that the temp file has gone away
+
+    ds = None
+    ds = gdal.Open(filename)
+    assert ds.RasterCount == 3
+    assert ds.RasterXSize == 256
+    assert ds.RasterYSize == 256
+    assert ds.GetRasterBand(1).GetMaskFlags() == gdal.GMF_PER_DATASET
+    assert ds.GetRasterBand(1).GetBlockSize() == [256, 256]
+    gt = ds.GetGeoTransform()
+    expected_gt = [-20037508.342789248, 156543.033928041, 0.0,
+                   20037508.342789248, 0.0, -156543.033928041]
+    for i in range(6):
+        if abs(gt[i] - expected_gt[i]) > 1e-10 * abs(expected_gt[i]):
+            assert False, gt
+    got_cs = [ds.GetRasterBand(i+1).Checksum() for i in range(3)]
+    if sys.platform == 'darwin' and gdal.GetConfigOption('TRAVIS', None) is not None:
+        assert got_cs != [0, 0, 0]
+    else:
+        assert got_cs == [26293, 23439, 14955]
+    assert ds.GetRasterBand(1).GetMaskBand().Checksum() == 17849
+    assert ds.GetRasterBand(1).GetOverviewCount() == 0
+    ds = None
+    _check_cog(filename)
+
+    src_ds = None
+    gdal.GetDriverByName('GTiff').Delete(filename)
+    gdal.Unlink(directory)
+
+
+
+###############################################################################
+# Test reprojection of small extent to WebMercator
+
+
+def test_cog_byte_to_web_mercator():
+
+    tab = [ 0 ]
+    def my_cbk(pct, _, arg):
+        assert pct >= tab[0]
+        tab[0] = pct
+        return 1
+
+    directory = '/vsimem/test_cog_byte_to_web_mercator'
+    gdal.Mkdir(directory, 0o755)
+    filename = directory + '/cog.tif'
+    src_ds = gdal.Open('data/byte.tif')
+    ds = gdal.GetDriverByName('COG').CreateCopy(filename, src_ds,
+        options = ['TILING_SCHEME=GoogleMapsCompatible', 'ALIGNED_LEVELS=3'],
+        callback = my_cbk,
+        callback_data = tab)
+    assert tab[0] == 1.0
+    assert ds
+    assert len(gdal.ReadDir(directory)) == 1 # check that the temp file has gone away
+
+    ds = None
+    ds = gdal.Open(filename)
+    assert ds.RasterCount == 2
+    assert ds.RasterXSize == 1024
+    assert ds.RasterYSize == 1024
+    assert ds.GetRasterBand(1).GetMaskFlags() == gdal.GMF_ALPHA + gdal.GMF_PER_DATASET
+    assert ds.GetRasterBand(1).GetBlockSize() == [256,256]
+    gt = ds.GetGeoTransform()
+    expected_gt = [-13149614.849955443, 76.43702828517598, 0.0,
+                   4070118.8821290657, 0.0, -76.43702828517598]
+    for i in range(6):
+        if abs(gt[i] - expected_gt[i]) > 1e-10 * abs(expected_gt[i]):
+            assert False, gt
+    assert ds.GetRasterBand(1).Checksum() == 4363
+    assert ds.GetRasterBand(1).GetMaskBand().Checksum() == 4356
+    assert ds.GetRasterBand(1).GetOverviewCount() == 2
+    ds = None
+    _check_cog(filename)
+
+    src_ds = None
+    gdal.GetDriverByName('GTiff').Delete(filename)
+    gdal.Unlink(directory)
+
+
+
+
+###############################################################################
+# Same as previous test case but with other input options
+
+
+def test_cog_byte_to_web_mercator_manual():
+
+    directory = '/vsimem/test_cog_byte_to_web_mercator_manual'
+    gdal.Mkdir(directory, 0o755)
+    filename = directory + '/cog.tif'
+    src_ds = gdal.Open('data/byte.tif')
+    res = 76.43702828517598
+    minx = -13149614.849955443
+    maxx = minx + 1024 * res
+    maxy = 4070118.8821290657
+    miny = maxy - 1024 * res
+    ds = gdal.GetDriverByName('COG').CreateCopy(filename, src_ds,
+        options = ['BLOCKSIZE=256',
+                   'TARGET_SRS=EPSG:3857',
+                   'RES=%.18g' % res,
+                   'EXTENT=%.18g,%.18g,%.18g,%.18g' % (minx,miny,maxx,maxy)])
+    assert ds
+
+    ds = None
+    ds = gdal.Open(filename)
+    assert ds.RasterCount == 2
+    assert ds.RasterXSize == 1024
+    assert ds.RasterYSize == 1024
+    assert ds.GetRasterBand(1).GetMaskFlags() == gdal.GMF_ALPHA + gdal.GMF_PER_DATASET
+    assert ds.GetRasterBand(1).GetBlockSize() == [256,256]
+    gt = ds.GetGeoTransform()
+    expected_gt = [-13149614.849955443, 76.43702828517598, 0.0,
+                   4070118.8821290657, 0.0, -76.43702828517598]
+    for i in range(6):
+        if abs(gt[i] - expected_gt[i]) > 1e-10 * abs(expected_gt[i]):
+            assert False, gt
+    assert ds.GetRasterBand(1).Checksum() == 4363
+    assert ds.GetRasterBand(1).GetMaskBand().Checksum() == 4356
+    assert ds.GetRasterBand(1).GetOverviewCount() == 2
+    ds = None
+
+    src_ds = None
+    gdal.GetDriverByName('GTiff').Delete(filename)
+    gdal.Unlink(directory)
+
diff --git a/gdal/doc/source/drivers/raster/cog.rst b/gdal/doc/source/drivers/raster/cog.rst
index ea06c5d6ef..66bd2a1bd0 100644
--- a/gdal/doc/source/drivers/raster/cog.rst
+++ b/gdal/doc/source/drivers/raster/cog.rst
@@ -12,7 +12,8 @@ This driver supports the creation of Cloud Optimized GeoTIFF (COG)
 
 It essentially relies upon the :ref:`raster.gtiff` driver with the
 ``COPY_SRC_OVERVIEWS=YES`` creation option, but automatically does the needed
-preprocessing stage (creation of overviews on imagery and/or mask) if not already
+preprocessing stages (reprojection if asked and creation of overviews on
+imagery and/or mask) if not already
 done, and also takes care of morphing the input dataset into the expected form
 when using some compression types (for example a RGBA dataset will be transparently
 converted to a RGB+mask dataset when selecting JPEG compression)
@@ -29,89 +30,124 @@ Driver capabilities
 Creation Options
 ----------------
 
+General creation options
+************************
+
 -  **BLOCKSIZE=n**: Sets the tile width and height in pixels. Defaults to 512.
 
 -  **COMPRESS=[NONE/LZW/JPEG/DEFLATE/ZSTD/WEBP]**: Set the compression to use.
 
    * ``JPEG`` should generally only be used with
      Byte data (8 bit per channel). But if GDAL is built with internal libtiff and
      libjpeg, it is    possible to read and write TIFF files with 12bit JPEG compressed TIFF
      files (seen as UInt16 bands with NBITS=12). See the `"8 and 12 bit
      JPEG in TIFF" <http://trac.osgeo.org/gdal/wiki/TIFF12BitJPEG>`__ wiki
      page for more details.
      For the COG driver, JPEG compression for 3 or 4-band images automatically
      selects the PHOTOMETRIC=YCBCR colorspace with a 4:2:2 subsampling of the Y,Cb,Cr
      components.
 
    * ``LZW``, ``DEFLATE`` and ``ZSTD`` compressions can be used with the PREDICTOR creation option.
 
    * ``ZSTD`` is available when using internal libtiff and if GDAL built against 
      libzstd >=1.0, or if built against external libtiff with zstd support.
 
 -  **LEVEL=integer_value**: DEFLATE/ZSTD compression level. A lower number will
    result in faster compression but less efficient compression rate.
    1 is the fastest. For DEFLATE, 9 is the slowest/higher compression rate
    (the default is 6)
    For ZSTD, 22 is the slowest/higher compression rate (the default is 9)
 
 -  **QUALITY=integer_value**: JPEG/WEBP quality setting. A value of 100 is best
    quality (least compression), and 1 is worst quality (best compression).
    The default is 75. For WEBP, QUALITY=100 automatically turns on lossless mode.
 
 -  **NUM_THREADS=number_of_threads/ALL_CPUS**: Enable
    multi-threaded compression by specifying the number of worker
    threads. Default is compression in the main thread.
 
 -  **PREDICTOR=[YES/NO]**: Set the predictor for LZW, DEFLATE and ZSTD
    compression. The default is NO.
 
 -  **BIGTIFF=YES/NO/IF_NEEDED/IF_SAFER**: Control whether the created
    file is a BigTIFF or a classic TIFF.
 
    -  ``YES`` forces BigTIFF.
    -  ``NO`` forces classic TIFF.
    -  ``IF_NEEDED`` will only create a BigTIFF if it is clearly needed (in
       the uncompressed case, and image larger than 4GB. So no effect
       when using a compression).
    -  ``IF_SAFER`` will create BigTIFF if the resulting file \*might\*
       exceed 4GB. Note: this is only a heuristics that might not always
       work depending on compression ratios.
 
    BigTIFF is a TIFF variant which can contain more than 4GiB of data
    (size of classic TIFF is limited by that value). This option is
    available if GDAL is built with libtiff library version 4.0 or
    higher. The default is IF_NEEDED.
 
    When creating a new GeoTIFF with no compression, GDAL computes in
    advance the size of the resulting file. If that computed file size is
    over 4GiB, GDAL will automatically decide to create a BigTIFF file.
    However, when compression is used, it is not possible in advance to
    known the final size of the file, so classical TIFF will be chosen.
    In that case, the user must explicitly require the creation of a
    BigTIFF with BIGTIFF=YES if the final file is anticipated to be too
    big for classical TIFF format. If BigTIFF creation is not explicitly
    asked or guessed and the resulting file is too big for classical
    TIFF, libtiff will fail with an error message like
    "TIFFAppendToStrip:Maximum TIFF file size exceeded".
 
 -  **RESAMPLING=[NEAREST/AVERAGE/BILINEAR/CUBIC/CUBICSPLINE/LANCZOS]**:
-   Resampling method used for overview generation. For paletted images,
+   Resampling method used for overview generation or reprojection.
+   For paletted images,
    NEAREST is used by default, otherwise it is CUBIC.
 
 - **OVERVIEWS=[AUTO/IGNORE_EXISTING/FORCE_USE_EXISTING]**: Describe the behaviour
   regarding source overviews.
   
   - ``AUTO`` (default): source overviews will be
     used if present (even if the dimension of the smallest level is not < 512 pixels),
     and if not present will be automatically generated.
 
   - ``IGNORE_EXISTING``: potential existing overviews on the source dataset will
     be ignored and new overviews will be automatically generated.
 
   - ``FORCE_USE_EXISTING``: potential existing overviews on the source will
     be used (even if the dimension of the smallest level is not < 512 pixels), and
     if there is no source overview, none will be generated.
 
+Reprojection related creation options
+*************************************
+
+- **TILING_SCHEME=CUSTOM/GoogleMapsCompatible**: If set to ``GoogleMapsCompatible``,
+  reprojection to EPSG:3857 using a GoogleMapsCompatible tiling schme will be
+  automatically done. The default block size in that case will be 256. If
+  explicitly setting another block size, this one will be taken into account
+  (that is if setting a higher value than 256, the original GoogleMapsCompatible
+  tiling scheme is modified to take into account the size of the HiDiPi tiles).
+  In GoogleMapsCompatible mode, TARGET_SRS, RES and EXTENT options are ignored.
+
+- **TARGET_SRS=string**: to force reprojection of the input dataset to another
+  SRS. The string can be a WKT string, a EPSG:XXXX code or a PROJ string.
+
+- **RES=value**: Set the resolution of the target raster, in the units of
+  TARGET_SRS. Only taken into account if TARGET_SRS is specified.
+
+- **EXTENT=minx,miny,maxx,maxy**: Set the extent of the target raster, in the
+  units of TARGET_SRS. Only taken into account if TARGET_SRS is specified.
+
+- **ALIGNED_LEVELS=INT**: Number of overview levels for which GeoTIFF tile and
+  WebMercator tiles match. When specifying this option, padding tiles will be
+  added to the left and top sides of the target raster, when needed, so that
+  a GeoTIFF tile matches with a tile of the GoogleMapsCompatible tiling scheme.
+  Only taken into account if TILING_SCHEME=GoogleMapsCompatible. As up to
+  2^ALIGNED_LEVELS tiles can be added in each dimension, it is the responsibility
+  of the user to use this setting with care (a hard limit of 10 is enforced by
+  the driver).
+  
+- **ADD_ALPHA=YES/NO**: Whether an alpha band is added in case of reprojection.
+  Defaults to YES.
 
 File format details
 -------------------
@@ -254,6 +290,13 @@ have modified the  TIFF file in a way that breaks the optimizations. If an optim
 detects an inconsistency, it can then fallbacks to the regular/slower method of using 
 TileOffset[i] + TileByteCount[i].
 
+Examples
+--------
+
+::
+
+    gdal_translate world.tif world_webmerc_cog.tif -of COG -co TILING_SCHEME=GoogleMapsCompatible -co COMPRESS=JPEG
+
 See Also
 --------
 
diff --git a/gdal/frmts/gtiff/cogdriver.cpp b/gdal/frmts/gtiff/cogdriver.cpp
index 8c0771d7a7..321f5e92db 100644
--- a/gdal/frmts/gtiff/cogdriver.cpp
+++ b/gdal/frmts/gtiff/cogdriver.cpp
@@ -1,36 +1,38 @@
 /******************************************************************************
  *
  * Project:  COG Driver
  * Purpose:  Cloud optimized GeoTIFF write support.
  * Author:   Even Rouault <even dot rouault at spatialys dot com>
  *
  ******************************************************************************
  * Copyright (c) 2019, Even Rouault <even dot rouault at spatialys dot com>
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the "Software"),
  * to deal in the Software without restriction, including without limitation
  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
  * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included
  * in all copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  ****************************************************************************/
 
 #include "gdal_priv.h"
 #include "gtiff.h"
 #include "gt_overview.h"
 #include "gdal_utils.h"
+#include "gdalwarper.h"
 
+#include <algorithm>
 #include <memory>
 #include <vector>
 
@@ -60,283 +62,634 @@ static bool HasZSTDCompression()
 /*                           GetTmpFilename()                           */
 /************************************************************************/
 
-static CPLString GetTmpFilename(GDALDataset *poSrcDS,
+static CPLString GetTmpFilename(const char* pszFilename,
                                 const char* pszExt)
 {
     CPLString osTmpOverviewFilename;
     // Check if we can create a temporary file close to the source
     // dataset
     VSIStatBufL sStatBuf;
-    if( VSIStatL(poSrcDS->GetDescription(), &sStatBuf) == 0 )
+    if( VSIStatL(pszFilename, &sStatBuf) == 0 )
     {
-        osTmpOverviewFilename.Printf("%s.%s", poSrcDS->GetDescription(), pszExt);
+        osTmpOverviewFilename.Printf("%s.%s", pszFilename, pszExt);
         VSILFILE* fp = VSIFOpenL(osTmpOverviewFilename, "wb");
         if( fp == nullptr )
             osTmpOverviewFilename.clear();
         else
             VSIFCloseL(fp);
     }
     if( osTmpOverviewFilename.empty() )
     {
         osTmpOverviewFilename = CPLGenerateTempFilename(
-            CPLGetBasename(poSrcDS->GetDescription()));
+            CPLGetBasename(pszFilename));
         osTmpOverviewFilename += '.';
         osTmpOverviewFilename += pszExt;
     }
     return osTmpOverviewFilename;
 }
 
 /************************************************************************/
-/*                            COGCreateCopy()                           */
+/*                             GetResampling()                          */
 /************************************************************************/
 
-static GDALDataset* COGCreateCopy( const char * pszFilename,
-                                   GDALDataset *poSrcDS,
-                                   int /*bStrict*/, char ** papszOptions,
-                                   GDALProgressFunc pfnProgress,
-                                   void * pProgressData )
+static const char* GetResampling(GDALDataset* poSrcDS)
+{
+    return poSrcDS->GetRasterBand(1)->GetColorTable() ? "NEAREST" : "CUBIC";
+}
+
+/************************************************************************/
+/*                        CreateReprojectedDS()                         */
+/************************************************************************/
+
+static std::unique_ptr<GDALDataset> CreateReprojectedDS(
+                                GDALDataset *poSrcDS,
+                                const char * const* papszOptions,
+                                GDALProgressFunc pfnProgress,
+                                void * pProgressData,
+                                double& dfCurPixels,
+                                double& dfTotalPixelsToProcess)
+{
+    CPLString osTargetSRS(CSLFetchNameValueDef(papszOptions, "TARGET_SRS", ""));
+    CPLString osTilingScheme(CSLFetchNameValueDef(papszOptions,
+                                                  "TILING_SCHEME", "CUSTOM"));
+    CPLString osExtent(CSLFetchNameValueDef(papszOptions, "EXTENT", ""));
+    CPLString osRes(CSLFetchNameValueDef(papszOptions, "RES", ""));
+    if( EQUAL(osTilingScheme, "GoogleMapsCompatible") )
+        osTargetSRS = "EPSG:3857";
+
+    CPLStringList aosTO;
+    aosTO.SetNameValue( "DST_SRS", osTargetSRS );
+    void* hTransformArg =
+            GDALCreateGenImgProjTransformer2( poSrcDS, nullptr, aosTO.List() );
+    if( hTransformArg == nullptr )
+    {
+        return nullptr;
+    }
+
+    GDALTransformerInfo* psInfo = static_cast<GDALTransformerInfo*>(hTransformArg);
+    double adfGeoTransform[6];
+    double adfExtent[4];
+    int    nXSize, nYSize;
+
+    if ( GDALSuggestedWarpOutput2( poSrcDS,
+                                  psInfo->pfnTransform, hTransformArg,
+                                  adfGeoTransform,
+                                  &nXSize, &nYSize,
+                                  adfExtent, 0 ) != CE_None )
+    {
+        GDALDestroyGenImgProjTransformer( hTransformArg );
+        return nullptr;
+    }
+
+    GDALDestroyGenImgProjTransformer( hTransformArg );
+    hTransformArg = nullptr;
+
+
+    // Hack to compensate for GDALSuggestedWarpOutput2() failure when
+    // reprojection latitude = +/- 90 to EPSG:3857.
+    double adfSrcGeoTransform[6];
+    OGRSpatialReference oTargetSRS;
+    oTargetSRS.SetFromUserInput(osTargetSRS);
+    const char* pszAuthCode = oTargetSRS.GetAuthorityCode(nullptr);
+    const int nEPSGCode = pszAuthCode ? atoi(pszAuthCode) : 0;
+    if( nEPSGCode == 3857 && poSrcDS->GetGeoTransform(adfSrcGeoTransform) == CE_None )
+    {
+        const char* pszSrcWKT = poSrcDS->GetProjectionRef();
+        if( pszSrcWKT != nullptr && pszSrcWKT[0] != '\0' )
+        {
+            OGRSpatialReference oSrcSRS;
+            if( oSrcSRS.SetFromUserInput( pszSrcWKT ) == OGRERR_NONE &&
+                oSrcSRS.IsGeographic() )
+            {
+                const double minLat =
+                    std::min(adfSrcGeoTransform[3],
+                             adfSrcGeoTransform[3] +
+                             poSrcDS->GetRasterYSize() *
+                             adfSrcGeoTransform[5]);
+                const double maxLat =
+                    std::max(adfSrcGeoTransform[3],
+                             adfSrcGeoTransform[3] +
+                             poSrcDS->GetRasterYSize() *
+                             adfSrcGeoTransform[5]);
+                double maxNorthing = adfGeoTransform[3];
+                double minNorthing =
+                    adfGeoTransform[3] + adfGeoTransform[5] * nYSize;
+                bool bChanged = false;
+                const double SPHERICAL_RADIUS = 6378137.0;
+                const double MAX_GM =
+                    SPHERICAL_RADIUS * M_PI;  // 20037508.342789244
+                if( maxLat > 89.9999999 )
+                {
+                    bChanged = true;
+                    maxNorthing = MAX_GM;
+                }
+                if( minLat <= -89.9999999 )
+                {
+                    bChanged = true;
+                    minNorthing = -MAX_GM;
+                }
+                if( bChanged )
+                {
+                    adfGeoTransform[3] = maxNorthing;
+                    nYSize = int((maxNorthing - minNorthing) / (-adfGeoTransform[5]) + 0.5);
+                    adfExtent[1] = maxNorthing + nYSize * adfGeoTransform[5];
+                    adfExtent[3] = maxNorthing;
+                }
+            }
+        }
+    }
+
+    double dfMinX = adfExtent[0];
+    double dfMinY = adfExtent[1];
+    double dfMaxX = adfExtent[2];
+    double dfMaxY = adfExtent[3];
+    double dfRes = adfGeoTransform[1];
+
+    if( EQUAL(osTilingScheme, "GoogleMapsCompatible") )
+    {
+        const int nBlockSize = atoi(CSLFetchNameValueDef(
+            papszOptions, "BLOCKSIZE", "256"));
+        const double dfPixelXSizeZoomLevel0 = 156543.0339280410 * 256 / nBlockSize;
+        const double dfOriX = -(dfPixelXSizeZoomLevel0 * nBlockSize) / 2.0;
+        const double dfOriY = -dfOriX;
+        double dfComputedRes = adfGeoTransform[1];
+        double dfPrevRes = 0.0;
+        dfRes = 0.0;
+        int nZoomLevel = 0;  // Used after for.
+        for( ; nZoomLevel < 25; nZoomLevel++ )
+        {
+            dfRes = dfPixelXSizeZoomLevel0 / (1 << nZoomLevel);
+            if( dfComputedRes > dfRes )
+                break;
+            dfPrevRes = dfRes;
+        }
+        if( nZoomLevel == 25 )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined,
+                    "Could not find an appropriate zoom level");
+            return nullptr;
+        }
+        if( nZoomLevel > 0 )
+        {
+            if( dfPrevRes / dfComputedRes < dfComputedRes / dfRes )
+            {
+                nZoomLevel --;
+                dfRes = dfPixelXSizeZoomLevel0 / (1 << nZoomLevel);
+            }
+        }
+        CPLDebug("COG", "Using ZOOM_LEVEL %d", nZoomLevel);
+
+        const double dfTileExtent = dfRes * nBlockSize;
+        int nTLTileX = static_cast<int>(std::floor((dfMinX - dfOriX) / dfTileExtent));
+        int nTLTileY = static_cast<int>(std::floor((dfOriY - dfMaxY) / dfTileExtent));
+        int nBRTileX = static_cast<int>(std::ceil((dfMaxX - dfOriX) / dfTileExtent));
+        int nBRTileY = static_cast<int>(std::ceil((dfOriY - dfMinY) / dfTileExtent));
+
+        const int nAlignedLevels = std::min(10, atoi(
+        CSLFetchNameValueDef(papszOptions, "ALIGNED_LEVELS", "0")));
+        if( nAlignedLevels >= 1 )
+        {
+            const int nAlignment = ((1 << (nAlignedLevels-1))-1);
+            nTLTileX &= ~nAlignment;
+            nTLTileY &= ~nAlignment;
+            nBRTileY = (nBRTileY + nAlignment) & ~nAlignment;
+            nBRTileX = (nBRTileX + nAlignment) & ~nAlignment;
+        }
+        nTLTileX = std::max(0, nTLTileX);
+        nTLTileY = std::max(0, nTLTileY);
+        nBRTileX = std::min(1 << nZoomLevel, nBRTileX);
+        nBRTileY = std::min(1 << nZoomLevel, nBRTileY);
+
+        dfMinX = dfOriX + nTLTileX * dfTileExtent;
+        dfMinY = dfOriY - nBRTileY * dfTileExtent;
+        dfMaxX = dfOriX + nBRTileX * dfTileExtent;
+        dfMaxY = dfOriY - nTLTileY * dfTileExtent;
+        nXSize = static_cast<int>(std::round((dfMaxX - dfMinX) / dfRes));
+        nYSize = static_cast<int>(std::round((dfMaxY - dfMinY) / dfRes));
+    }
+    else if( !osExtent.empty() || !osRes.empty() )
+    {
+        CPLStringList aosTokens(CSLTokenizeString2(osExtent, ",", 0));
+        if( aosTokens.size() != 4 )
+        {
+            CPLError(CE_Failure, CPLE_AppDefined,
+                     "Invalid value for EXTENT");
+            return nullptr;
+        }
+        dfMinX = CPLAtof(aosTokens[0]);
+        dfMinY = CPLAtof(aosTokens[1]);
+        dfMaxX = CPLAtof(aosTokens[2]);
+        dfMaxY = CPLAtof(aosTokens[3]);
+        if( !osRes.empty() )
+            dfRes = CPLAtof(osRes);
+    }
+
+    nXSize = static_cast<int>(std::round((dfMaxX - dfMinX) / dfRes));
+    nYSize = static_cast<int>(std::round((dfMaxY - dfMinY) / dfRes));
+
+    char** papszArg = nullptr;
+    // We could have done a warped VRT, but overview building on it might be
+    // slow, so materialize as GTiff
+    papszArg = CSLAddString(papszArg, "-of");
+    papszArg = CSLAddString(papszArg, "GTiff");
+    papszArg = CSLAddString(papszArg, "-co");
+    papszArg = CSLAddString(papszArg, "TILED=YES");
+    papszArg = CSLAddString(papszArg, "-co");
+    papszArg = CSLAddString(papszArg, "SPARSE_OK=YES");
+    const char* pszBIGTIFF = CSLFetchNameValue(papszOptions, "BIGTIFF");
+    if( pszBIGTIFF )
+    {
+        papszArg = CSLAddString(papszArg, "-co");
+        papszArg = CSLAddString(papszArg, (CPLString("BIGTIFF=") + pszBIGTIFF).c_str());
+    }
+    papszArg = CSLAddString(papszArg, "-co");
+    papszArg = CSLAddString(papszArg,
+                    HasZSTDCompression() ? "COMPRESS=ZSTD" : "COMPRESS=LZW");
+    papszArg = CSLAddString(papszArg, "-t_srs");
+    papszArg = CSLAddString(papszArg, osTargetSRS);
+    papszArg = CSLAddString(papszArg, "-te");
+    papszArg = CSLAddString(papszArg, CPLSPrintf("%.18g,", dfMinX));
+    papszArg = CSLAddString(papszArg, CPLSPrintf("%.18g,", dfMinY));
+    papszArg = CSLAddString(papszArg, CPLSPrintf("%.18g,", dfMaxX));
+    papszArg = CSLAddString(papszArg, CPLSPrintf("%.18g,", dfMaxY));
+    papszArg = CSLAddString(papszArg, "-ts");
+    papszArg = CSLAddString(papszArg, CPLSPrintf("%d", nXSize));
+    papszArg = CSLAddString(papszArg, CPLSPrintf("%d", nYSize));
+    int bHasNoData = FALSE;
+    poSrcDS->GetRasterBand(1)->GetNoDataValue(&bHasNoData);
+    if( !bHasNoData && CPLTestBool(CSLFetchNameValueDef(
+            papszOptions, "ADD_ALPHA", "YES")) )
+    {
+        papszArg = CSLAddString(papszArg, "-dstalpha");
+    }
+    papszArg = CSLAddString(papszArg, "-r");
+    const char* pszResampling = CSLFetchNameValueDef(papszOptions,
+        "RESAMPLING", GetResampling(poSrcDS));
+    papszArg = CSLAddString(papszArg, pszResampling);
+    const char* pszNumThreads = CSLFetchNameValue(papszOptions, "NUM_THREADS");
+    if( pszNumThreads )
+    {
+        papszArg = CSLAddString(papszArg, "-wo");
+        papszArg = CSLAddString(papszArg, (CPLString("NUM_THREADS=") + pszNumThreads).c_str());
+    }
+
+    const auto poFirstBand = poSrcDS->GetRasterBand(1);
+    const bool bHasMask = poFirstBand->GetMaskFlags() == GMF_PER_DATASET;
+
+    const int nBands = poSrcDS->GetRasterCount();
+    const char* pszOverviews = CSLFetchNameValueDef(
+        papszOptions, "OVERVIEWS", "AUTO");
+    dfTotalPixelsToProcess =
+        double(nXSize) * nYSize * (nBands + (bHasMask ? 1 : 0)) +
+        (bHasMask && !EQUAL(pszOverviews, "FORCE_USE_EXISTING") ? double(nXSize) * nYSize / 3 : 0) +
+        (!EQUAL(pszOverviews, "FORCE_USE_EXISTING") ? double(nXSize) * nYSize * nBands / 3: 0) +
+        double(nXSize) * nYSize * (nBands + (bHasMask ? 1 : 0)) * 4. / 3;
+
+    auto psOptions = GDALWarpAppOptionsNew(papszArg, nullptr);
+    CSLDestroy(papszArg);
+    const double dfNextPixels =
+        double(nXSize) * nYSize * (nBands + (bHasMask ? 1 : 0));
+    void* pScaledProgress = GDALCreateScaledProgress(
+                dfCurPixels / dfTotalPixelsToProcess,
+                dfNextPixels / dfTotalPixelsToProcess,
+                pfnProgress, pProgressData );
+    dfCurPixels = dfNextPixels;
+
+    CPLDebug("COG", "Reprojecting source dataset");
+    GDALWarpAppOptionsSetProgress(psOptions, GDALScaledProgress, pScaledProgress );
+    CPLString osTmpFile(GetTmpFilename(poSrcDS->GetDescription(), "_warped.tif"));
+    auto hSrcDS = GDALDataset::ToHandle(poSrcDS);
+    auto hRet = GDALWarp( osTmpFile, nullptr,
+                          1, &hSrcDS,
+                          psOptions, nullptr);
+    GDALWarpAppOptionsFree(psOptions);
+
+    GDALDestroyScaledProgress(pScaledProgress);
+
+    return std::unique_ptr<GDALDataset>(GDALDataset::FromHandle(hRet));
+}
+
+/************************************************************************/
+/*                            GDALCOGCreator                            */
+/************************************************************************/
+
+struct GDALCOGCreator final
+{
+    std::unique_ptr<GDALDataset> m_poReprojectedDS{};
+    std::unique_ptr<GDALDataset> m_poRGBMaskDS{};
+    CPLString                    m_osTmpOverviewFilename{};
+    CPLString                    m_osTmpMskOverviewFilename{};
+
+    ~GDALCOGCreator();
+
+    GDALDataset* Create(const char * pszFilename,
+                        GDALDataset * const poSrcDS,
+                        char ** papszOptions,
+                        GDALProgressFunc pfnProgress,
+                        void * pProgressData );
+};
+
+/************************************************************************/
+/*                    GDALCOGCreator::~GDALCOGCreator()                 */
+/************************************************************************/
+
+GDALCOGCreator::~GDALCOGCreator()
+{
+    if( m_poReprojectedDS )
+    {
+        CPLString osProjectedDSName(m_poReprojectedDS->GetDescription());
+        // Destroy m_poRGBMaskDS before m_poReprojectedDS since the former
+        // references the later
+        m_poRGBMaskDS.reset();
+        m_poReprojectedDS.reset();
+        VSIUnlink(osProjectedDSName);
+    }
+    if( !m_osTmpOverviewFilename.empty() )
+    {
+        VSIUnlink(m_osTmpOverviewFilename);
+    }
+    if( !m_osTmpMskOverviewFilename.empty() )
+    {
+        VSIUnlink(m_osTmpMskOverviewFilename);
+    }
+}
+
+/************************************************************************/
+/*                    GDALCOGCreator::Create()                          */
+/************************************************************************/
+
+GDALDataset* GDALCOGCreator::Create(const char * pszFilename,
+                                    GDALDataset * const poSrcDS,
+                                    char ** papszOptions,
+                                    GDALProgressFunc pfnProgress,
+                                    void * pProgressData )
 {
     if( pfnProgress == nullptr )
         pfnProgress = GDALDummyProgress;
 
-    const char* pszCompress = CSLFetchNameValueDef(papszOptions, "COMPRESS", "NONE");
-    std::unique_ptr<GDALDataset> poTmpDS;
-    if( EQUAL(pszCompress, "JPEG") &&
-        poSrcDS->GetRasterCount() == 4 )
+    if( poSrcDS->GetRasterCount() == 0 )
+    {
+        CPLError(CE_Failure, CPLE_NotSupported,
+                 "COG driver does not support 0-band source raster");
+        return nullptr;
+    }
+
+    CPLConfigOptionSetter oSetterReportDirtyBlockFlushing(
+        "GDAL_REPORT_DIRTY_BLOCK_FLUSHING", "NO", true);
+
+    CPLString osSrcFilename(poSrcDS->GetDescription());
+
+    double dfCurPixels = 0;
+    double dfTotalPixelsToProcess = 0;
+    GDALDataset* poCurDS = poSrcDS;
+
+    if( !EQUAL(CSLFetchNameValueDef(papszOptions, "TILING_SCHEME", "CUSTOM"),
+              "CUSTOM") ||
+        CSLFetchNameValue(papszOptions, "TARGET_SRS") != nullptr )
+    {
+        m_poReprojectedDS =
+            CreateReprojectedDS(poCurDS, papszOptions, pfnProgress, pProgressData,
+                                dfCurPixels, dfTotalPixelsToProcess);
+        if( !m_poReprojectedDS )
+            return nullptr;
+        poCurDS = m_poReprojectedDS.get();
+    }
+
+    CPLString osCompress = CSLFetchNameValueDef(papszOptions, "COMPRESS", "NONE");
+    if( EQUAL(osCompress, "JPEG") &&
+        poCurDS->GetRasterCount() == 4 )
     {
         char** papszArg = nullptr;
         papszArg = CSLAddString(papszArg, "-of");
         papszArg = CSLAddString(papszArg, "VRT");
         papszArg = CSLAddString(papszArg, "-b");
         papszArg = CSLAddString(papszArg, "1");
         papszArg = CSLAddString(papszArg, "-b");
         papszArg = CSLAddString(papszArg, "2");
         papszArg = CSLAddString(papszArg, "-b");
         papszArg = CSLAddString(papszArg, "3");
         papszArg = CSLAddString(papszArg, "-mask");
         papszArg = CSLAddString(papszArg, "4");
         GDALTranslateOptions* psOptions = GDALTranslateOptionsNew(papszArg, nullptr);
         CSLDestroy(papszArg);
         GDALDatasetH hRGBMaskDS = GDALTranslate("",
-                                                GDALDataset::ToHandle(poSrcDS),
+                                                GDALDataset::ToHandle(poCurDS),
                                                 psOptions,
                                                 nullptr);
         GDALTranslateOptionsFree(psOptions);
         if( !hRGBMaskDS )
+        {
             return nullptr;
-        poTmpDS.reset( GDALDataset::FromHandle(hRGBMaskDS) );
-        poSrcDS = poTmpDS.get();
+        }
+        m_poRGBMaskDS.reset( GDALDataset::FromHandle(hRGBMaskDS) );
+        poCurDS = m_poRGBMaskDS.get();
     }
 
-    const int nBands = poSrcDS->GetRasterCount();
-    if( nBands == 0 )
+    const int nBands = poCurDS->GetRasterCount();
+    const int nXSize = poCurDS->GetRasterXSize();
+    const int nYSize = poCurDS->GetRasterYSize();
+
+    CPLString osBlockSize(CSLFetchNameValueDef(papszOptions, "BLOCKSIZE", ""));
+    if( osBlockSize.empty() )
     {
-        CPLError(CE_Failure, CPLE_NotSupported,
-                 "COG driver does not support 0-band source raster");
-        return nullptr;
+        if( EQUAL(CSLFetchNameValueDef(papszOptions, "TILING_SCHEME", "CUSTOM"),
+            "GoogleMapsCompatible") )
+            osBlockSize = "256";
+        else
+            osBlockSize = "512";
     }
-    const int nXSize = poSrcDS->GetRasterXSize();
-    const int nYSize = poSrcDS->GetRasterYSize();
-    CPLString osTmpOverviewFilename;
-    CPLString osTmpMskOverviewFilename;
-    const int nOvrThresholdSize = 512;
 
-    const auto poFirstBand = poSrcDS->GetRasterBand(1);
+    const int nOvrThresholdSize = atoi(osBlockSize);
+
+    const auto poFirstBand = poCurDS->GetRasterBand(1);
     const bool bHasMask = poFirstBand->GetMaskFlags() == GMF_PER_DATASET;
 
     const char* pszOverviews = CSLFetchNameValueDef(
         papszOptions, "OVERVIEWS", "AUTO");
     const bool bGenerateMskOvr = 
         !EQUAL(pszOverviews, "FORCE_USE_EXISTING") &&
         bHasMask &&
         (nXSize > nOvrThresholdSize || nYSize > nOvrThresholdSize) &&
         (EQUAL(pszOverviews, "IGNORE_EXISTING") ||
          poFirstBand->GetMaskBand()->GetOverviewCount() == 0);
     const bool bGenerateOvr =
         !EQUAL(pszOverviews, "FORCE_USE_EXISTING") &&
         (nXSize > nOvrThresholdSize || nYSize > nOvrThresholdSize) &&
         (EQUAL(pszOverviews, "IGNORE_EXISTING") ||
          poFirstBand->GetOverviewCount() == 0);
 
     std::vector<int> anOverviewLevels;
     int nTmpXSize = nXSize;
     int nTmpYSize = nYSize;
     int nOvrFactor = 2;
     while( nTmpXSize > nOvrThresholdSize || nTmpYSize > nOvrThresholdSize )
     {
         anOverviewLevels.push_back(nOvrFactor);
         nOvrFactor *= 2;
         nTmpXSize /= 2;
         nTmpYSize /= 2;
     }
 
-    double dfTotalPixelsProcessed = 
-        (bGenerateMskOvr ? double(nXSize) * nYSize / 3 : 0) +
-        (bGenerateOvr ? double(nXSize) * nYSize * nBands / 3: 0) +
-        double(nXSize) * nYSize * (nBands + (bHasMask ? 1 : 0)) * 4. / 3;
-    double dfCurPixels = 0;
+    if( dfTotalPixelsToProcess == 0.0 )
+    {
+        dfTotalPixelsToProcess =
+            (bGenerateMskOvr ? double(nXSize) * nYSize / 3 : 0) +
+            (bGenerateOvr ? double(nXSize) * nYSize * nBands / 3: 0) +
+            double(nXSize) * nYSize * (nBands + (bHasMask ? 1 : 0)) * 4. / 3;
+    }
 
     CPLStringList aosOverviewOptions;
     aosOverviewOptions.SetNameValue("COMPRESS",
                         HasZSTDCompression() ? "ZSTD" : "LZW");
     aosOverviewOptions.SetNameValue("NUM_THREADS",
                         CSLFetchNameValue(papszOptions, "NUM_THREADS"));
 
     if( bGenerateMskOvr )
     {
         CPLDebug("COG", "Generating overviews of the mask");
-        osTmpMskOverviewFilename = GetTmpFilename(poSrcDS, "msk.ovr.tmp");
+        m_osTmpMskOverviewFilename = GetTmpFilename(osSrcFilename, "msk.ovr.tmp");
         GDALRasterBand* poSrcMask = poFirstBand->GetMaskBand();
 
         double dfNextPixels = dfCurPixels + double(nXSize) * nYSize / 3;
         void* pScaledProgress = GDALCreateScaledProgress(
-                dfCurPixels / dfTotalPixelsProcessed,
-                dfNextPixels / dfTotalPixelsProcessed,
+                dfCurPixels / dfTotalPixelsToProcess,
+                dfNextPixels / dfTotalPixelsToProcess,
                 pfnProgress, pProgressData );
         dfCurPixels = dfNextPixels;
 
         CPLErr eErr = GTIFFBuildOverviewsEx(
-            osTmpMskOverviewFilename,
+            m_osTmpMskOverviewFilename,
             1, &poSrcMask,
             static_cast<int>(anOverviewLevels.size()),
             &anOverviewLevels[0],
             "NEAREST",
             aosOverviewOptions.List(),
             GDALScaledProgress, pScaledProgress );
 
         GDALDestroyScaledProgress(pScaledProgress);
         if( eErr != CE_None )
         {
-            if( !osTmpMskOverviewFilename.empty() )
-            {
-                VSIUnlink(osTmpMskOverviewFilename);
-            }
             return nullptr;
         }
     }
 
     if( bGenerateOvr )
     {
         CPLDebug("COG", "Generating overviews of the imagery");
-        osTmpOverviewFilename = GetTmpFilename(poSrcDS, "ovr.tmp");
+        m_osTmpOverviewFilename = GetTmpFilename(osSrcFilename, "ovr.tmp");
         std::vector<GDALRasterBand*> apoSrcBands;
         for( int i = 0; i < nBands; i++ )
-            apoSrcBands.push_back( poSrcDS->GetRasterBand(i+1) );
+            apoSrcBands.push_back( poCurDS->GetRasterBand(i+1) );
         const char* pszResampling = CSLFetchNameValueDef(papszOptions,
-            "RESAMPLING",
-            poFirstBand->GetColorTable() ? "NEAREST" : "CUBIC");
+            "RESAMPLING", GetResampling(poSrcDS));
 
         double dfNextPixels = dfCurPixels + double(nXSize) * nYSize * nBands / 3;
         void* pScaledProgress = GDALCreateScaledProgress(
-                dfCurPixels / dfTotalPixelsProcessed,
-                dfNextPixels / dfTotalPixelsProcessed,
+                dfCurPixels / dfTotalPixelsToProcess,
+                dfNextPixels / dfTotalPixelsToProcess,
                 pfnProgress, pProgressData );
         dfCurPixels = dfNextPixels;
 
-        if( !osTmpMskOverviewFilename.empty() )
+        if( !m_osTmpMskOverviewFilename.empty() )
         {
             aosOverviewOptions.SetNameValue("MASK_OVERVIEW_DATASET",
-                                            osTmpMskOverviewFilename);
+                                            m_osTmpMskOverviewFilename);
         }
         CPLErr eErr = GTIFFBuildOverviewsEx(
-            osTmpOverviewFilename,
+            m_osTmpOverviewFilename,
             nBands, &apoSrcBands[0],
             static_cast<int>(anOverviewLevels.size()),
             &anOverviewLevels[0],
             pszResampling,
             aosOverviewOptions.List(),
             GDALScaledProgress, pScaledProgress );
 
         GDALDestroyScaledProgress(pScaledProgress);
         if( eErr != CE_None )
         {
-            if( !osTmpOverviewFilename.empty() )
-            {
-                VSIUnlink(osTmpOverviewFilename);
-            }
-            if( !osTmpMskOverviewFilename.empty() )
-            {
-                VSIUnlink(osTmpMskOverviewFilename);
-            }
             return nullptr;
         }
     }
 
     CPLStringList aosOptions;
     aosOptions.SetNameValue("COPY_SRC_OVERVIEWS", "YES");
-    CPLString osBlockSize(CSLFetchNameValueDef(papszOptions, "BLOCKSIZE", "512"));
-    aosOptions.SetNameValue("COMPRESS", pszCompress);
+    aosOptions.SetNameValue("COMPRESS", osCompress);
     aosOptions.SetNameValue("TILED", "YES");
     aosOptions.SetNameValue("BLOCKXSIZE", osBlockSize);
     aosOptions.SetNameValue("BLOCKYSIZE", osBlockSize);
     if( CPLTestBool(CSLFetchNameValueDef(papszOptions, "PREDICTOR", "FALSE")) )
         aosOptions.SetNameValue("PREDICTOR", "2");
     const char* pszQuality = CSLFetchNameValue(papszOptions, "QUALITY");
-    if( EQUAL(pszCompress, "JPEG") )
+    if( EQUAL(osCompress, "JPEG") )
     {
         aosOptions.SetNameValue("JPEG_QUALITY", pszQuality);
         if( nBands == 3 )
             aosOptions.SetNameValue("PHOTOMETRIC", "YCBCR");
     }
-    else if( EQUAL(pszCompress, "WEBP") )
+    else if( EQUAL(osCompress, "WEBP") )
     {
         if( pszQuality && atoi(pszQuality) == 100 )
             aosOptions.SetNameValue("WEBP_LOSSLESS", "YES");
         aosOptions.SetNameValue("WEBP_LEVEL", pszQuality);
     }
-    else if( EQUAL(pszCompress, "DEFLATE") )
+    else if( EQUAL(osCompress, "DEFLATE") )
     {
         aosOptions.SetNameValue("ZLEVEL",
                                 CSLFetchNameValue(papszOptions, "LEVEL"));
     }
-    else if( EQUAL(pszCompress, "ZSTD") )
+    else if( EQUAL(osCompress, "ZSTD") )
     {
         aosOptions.SetNameValue("ZSTD_LEVEL",
                                 CSLFetchNameValue(papszOptions, "LEVEL"));
     }
     aosOptions.SetNameValue("BIGTIFF",
                                 CSLFetchNameValue(papszOptions, "BIGTIFF"));
     aosOptions.SetNameValue("NUM_THREADS",
                                 CSLFetchNameValue(papszOptions, "NUM_THREADS"));
 
-    if( !osTmpOverviewFilename.empty() )
+    if( !m_osTmpOverviewFilename.empty() )
     {
-        aosOptions.SetNameValue("@OVERVIEW_DATASET", osTmpOverviewFilename);
+        aosOptions.SetNameValue("@OVERVIEW_DATASET", m_osTmpOverviewFilename);
     }
-    if( !osTmpMskOverviewFilename.empty() )
+    if( !m_osTmpMskOverviewFilename.empty() )
     {
-        aosOptions.SetNameValue("@MASK_OVERVIEW_DATASET", osTmpMskOverviewFilename);
+        aosOptions.SetNameValue("@MASK_OVERVIEW_DATASET", m_osTmpMskOverviewFilename);
     }
 
     GDALDriver* poGTiffDrv = GDALDriver::FromHandle(GDALGetDriverByName("GTiff"));
     if( !poGTiffDrv )
         return nullptr;
     void* pScaledProgress = GDALCreateScaledProgress(
-            dfCurPixels / dfTotalPixelsProcessed,
+            dfCurPixels / dfTotalPixelsToProcess,
             1.0,
             pfnProgress, pProgressData );
 
     CPLConfigOptionSetter oSetterInternalMask(
         "GDAL_TIFF_INTERNAL_MASK", "YES", false);
 
-    auto poRet = poGTiffDrv->CreateCopy(pszFilename, poSrcDS, false,
+    auto poRet = poGTiffDrv->CreateCopy(pszFilename, poCurDS, false,
                                         aosOptions.List(),
                                         GDALScaledProgress, pScaledProgress);
 
     GDALDestroyScaledProgress(pScaledProgress);
 
-    if( !osTmpOverviewFilename.empty() )
-    {
-        VSIUnlink(osTmpOverviewFilename);
-    }
-    if( !osTmpMskOverviewFilename.empty() )
-    {
-        VSIUnlink(osTmpMskOverviewFilename);
-    }
-
     return poRet;
 }
 
+/************************************************************************/
+/*                            COGCreateCopy()                           */
+/************************************************************************/
+
+static GDALDataset* COGCreateCopy( const char * pszFilename,
+                                   GDALDataset *poSrcDS,
+                                   int /*bStrict*/, char ** papszOptions,
+                                   GDALProgressFunc pfnProgress,
+                                   void * pProgressData )
+{
+    return GDALCOGCreator().Create(pszFilename, poSrcDS,
+                                   papszOptions, pfnProgress, pProgressData);
+}
+
 /************************************************************************/
 /*                          GDALRegister_COG()                          */
 /************************************************************************/
@@ -344,70 +697,88 @@ static GDALDataset* COGCreateCopy( const char * pszFilename,
 void GDALRegister_COG()
 
 {
     if( GDALGetDriverByName( "COG" ) != nullptr )
         return;
 
     bool bHasLZW = false;
     bool bHasDEFLATE = false;
     bool bHasLZMA = false;
     bool bHasZSTD = false;
     bool bHasJPEG = false;
     bool bHasWebP = false;
     CPLString osCompressValues(GTiffGetCompressValues(
         bHasLZW, bHasDEFLATE, bHasLZMA, bHasZSTD, bHasJPEG, bHasWebP,
         true /* bForCOG */));
 
     CPLString osOptions;
     osOptions = "<CreationOptionList>"
                 "   <Option name='COMPRESS' type='string-select'>";
     osOptions += osCompressValues;
     osOptions += "   </Option>";
     if( bHasLZW || bHasDEFLATE || bHasZSTD )
     {
         osOptions += "   <Option name='LEVEL' type='int' "
             "description='DEFLATE/ZSTD compression level: 1 (fastest)'/>";
         osOptions += "   <Option name='PREDICTOR' type='boolean' default='FALSE'/>";
     }
     if( bHasJPEG || bHasWebP )
     {
         osOptions += "   <Option name='QUALITY' type='int' "
                      "description='JPEG/WEBP quality 1-100' default='75'/>";
     }
     osOptions +=
 "   <Option name='NUM_THREADS' type='string' "
         "description='Number of worker threads for compression. "
         "Can be set to ALL_CPUS' default='1'/>"
 "   <Option name='BLOCKSIZE' type='int' "
         "description='Tile size in pixels' min='128' default='512'/>"
-"   <Option name='BIGTIFF' type='string-select' description='Force creation of BigTIFF file'>"
+"   <Option name='BIGTIFF' type='string-select' description='"
+        "Force creation of BigTIFF file'>"
 "     <Value>YES</Value>"
 "     <Value>NO</Value>"
 "     <Value>IF_NEEDED</Value>"
 "     <Value>IF_SAFER</Value>"
 "   </Option>"
 "   <Option name='RESAMPLING' type='string' "
-        "description='Resampling method for overviews'/>"
-"   <Option name='OVERVIEWS' type='string-select' description='Behaviour regarding overviews'>"
+        "description='Resampling method for overviews or warping'/>"
+"   <Option name='OVERVIEWS' type='string-select' description='"
+        "Behaviour regarding overviews'>"
 "     <Value>AUTO</Value>"
 "     <Value>IGNORE_EXISTING</Value>"
 "     <Value>FORCE_USE_EXISTING</Value>"
 "   </Option>"
+"  <Option name='TILING_SCHEME' type='string-select' description='"
+        "Which tiling scheme to use' default='CUSTOM'>"
+"    <Value>CUSTOM</Value>"
+"    <Value>GoogleMapsCompatible</Value>"
+"  </Option>"
+"   <Option name='TARGET_SRS' type='string' "
+        "description='Target SRS as EPSG:XXXX, WKT or PROJ string for reprojection'/>"
+"  <Option name='RES' type='double' description='"
+        "Target resolution for reprojection'/>"
+"  <Option name='EXTENT' type='string' description='"
+        "Target extent as minx,miny,maxx,maxy for reprojection'/>"
+"  <Option name='ALIGNED_LEVELS' type='int' description='"
+        "Number of overview levels for which GeoTIFF tile and WebMercator "
+        "tiles match'/>"
+"  <Option name='ADD_ALPHA' type='boolean' description='Can be set to NO to "
+        "disable the addition of an alpha band in case of reprojection' default='YES'/>"
 "</CreationOptionList>";
 
     auto poDriver = new GDALDriver();
     poDriver->SetDescription( "COG" );
     poDriver->SetMetadataItem( GDAL_DCAP_RASTER, "YES" );
     poDriver->SetMetadataItem( GDAL_DMD_LONGNAME, "Cloud optimized GeoTIFF generator" );
     poDriver->SetMetadataItem( GDAL_DMD_HELPTOPIC, "cog.html" );
     poDriver->SetMetadataItem( GDAL_DMD_CREATIONOPTIONLIST, osOptions );
 
     poDriver->SetMetadataItem( GDAL_DMD_CREATIONDATATYPES,
                                "Byte UInt16 Int16 UInt32 Int32 Float32 "
                                "Float64 CInt16 CInt32 CFloat32 CFloat64" );
 
     poDriver->SetMetadataItem( GDAL_DCAP_VIRTUALIO, "YES" );
 
     poDriver->pfnCreateCopy = COGCreateCopy;
 
     GetGDALDriverManager()->RegisterDriver( poDriver );
 }
diff --git a/gdal/gcore/gdalabstractbandblockcache.cpp b/gdal/gcore/gdalabstractbandblockcache.cpp
index 36a28489f9..0708c8d413 100644
--- a/gdal/gcore/gdalabstractbandblockcache.cpp
+++ b/gdal/gcore/gdalabstractbandblockcache.cpp
@@ -216,17 +216,18 @@ void GDALAbstractBandBlockCache::IncDirtyBlocks( int nInc )
 void GDALAbstractBandBlockCache::StartDirtyBlockFlushingLog()
 {
     m_nInitialDirtyBlocksInFlushCache = 0;
     if( m_nDirtyBlocks > 0 && CPLIsDefaultErrorHandlerAndCatchDebug() )
     {
         const char *pszDebug = CPLGetConfigOption("CPL_DEBUG", nullptr);
-        if( pszDebug && (EQUAL(pszDebug, "ON") || EQUAL(pszDebug, "GDAL")) )
+        if( pszDebug && (EQUAL(pszDebug, "ON") || EQUAL(pszDebug, "GDAL")) &&
+            CPLGetConfigOption("GDAL_REPORT_DIRTY_BLOCK_FLUSHING", nullptr) == nullptr )
         {
             m_nInitialDirtyBlocksInFlushCache = m_nDirtyBlocks;
             m_nLastTick = -1;
         }
     }
 }
 
 /************************************************************************/
 /*                      UpdateDirtyBlockFlushingLog()                   */
 /************************************************************************/
