commit f6ffc2105937be2baf48aa808ab6a32ad2e09a1f
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Fri Jun 8 20:03:36 2018 -0400

    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=8782

diff --git a/MagickCore/blob.c b/MagickCore/blob.c
index bce361eac..9484541b5 100644
--- a/MagickCore/blob.c
+++ b/MagickCore/blob.c
@@ -1152,123 +1152,125 @@ MagickExport void DuplicateBlob(Image *image,const Image *duplicate)
 {
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(duplicate != (Image *) NULL);
   assert(duplicate->signature == MagickCoreSignature);
   DestroyBlob(image);
   image->blob=ReferenceBlob(duplicate->blob);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +  E O F B l o b                                                              %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  EOFBlob() returns a non-zero value when EOF has been detected reading from
 %  a blob or file.
 %
 %  The format of the EOFBlob method is:
 %
 %      int EOFBlob(const Image *image)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 */
 MagickExport int EOFBlob(const Image *image)
 {
   BlobInfo
     *magick_restrict blob_info;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(image->blob != (BlobInfo *) NULL);
   assert(image->blob->type != UndefinedStream);
   blob_info=image->blob;
   switch (blob_info->type)
   {
     case UndefinedStream:
     case StandardStream:
       break;
     case FileStream:
     case PipeStream:
     {
       blob_info->eof=feof(blob_info->file_info.file) != 0 ? MagickTrue :
         MagickFalse;
       break;
     }
     case ZipStream:
     {
-      blob_info->eof=MagickFalse;
+#if defined(MAGICKCORE_ZLIB_DELEGATE)
+      blob_info->eof=gzeof(blob_info->file_info.gzfile);
+#endif
       break;
     }
     case BZipStream:
     {
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
       int
         status;
 
       status=0;
       (void) BZ2_bzerror(blob_info->file_info.bzfile,&status);
       blob_info->eof=status == BZ_UNEXPECTED_EOF ? MagickTrue : MagickFalse;
 #endif
       break;
     }
     case FifoStream:
     {
       blob_info->eof=MagickFalse;
       break;
     }
     case BlobStream:
       break;
     case CustomStream:
       break;
   }
   return((int) blob_info->eof);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   F i l e T o B l o b                                                       %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  FileToBlob() returns the contents of a file as a buffer terminated with
 %  the '\0' character.  The length of the buffer (not including the extra
 %  terminating '\0' character) is returned via the 'length' parameter.  Free
 %  the buffer with RelinquishMagickMemory().
 %
 %  The format of the FileToBlob method is:
 %
 %      void *FileToBlob(const char *filename,const size_t extent,
 %        size_t *length,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o blob:  FileToBlob() returns the contents of a file as a blob.  If
 %      an error occurs NULL is returned.
 %
 %    o filename: the filename.
 %
 %    o extent:  The maximum length of the blob.
 %
 %    o length: On return, this reflects the actual length of the blob.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
diff --git a/MagickCore/draw.c b/MagickCore/draw.c
index 1d67c7d60..603f1b052 100644
--- a/MagickCore/draw.c
+++ b/MagickCore/draw.c
@@ -1,106 +1,106 @@
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %                        DDDD   RRRR    AAA   W   W                           %
 %                        D   D  R   R  A   A  W   W                           %
 %                        D   D  RRRR   AAAAA  W W W                           %
 %                        D   D  R RN   A   A  WW WW                           %
 %                        DDDD   R  R   A   A  W   W                           %
 %                                                                             %
 %                                                                             %
 %                     MagickCore Image Drawing Methods                        %
 %                                                                             %
 %                                                                             %
 %                              Software Design                                %
 %                                   Cristy                                    %
 %                                 July 1998                                   %
 %                                                                             %
 %                                                                             %
 %  Copyright 1999-2018 ImageMagick Studio LLC, a non-profit organization      %
 %  dedicated to making software imaging solutions freely available.           %
 %                                                                             %
 %  You may not use this file except in compliance with the License.  You may  %
 %  obtain a copy of the License at                                            %
 %                                                                             %
 %    https://www.imagemagick.org/script/license.php                           %
 %                                                                             %
 %  Unless required by applicable law or agreed to in writing, software        %
 %  distributed under the License is distributed on an "AS IS" BASIS,          %
 %  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %
 %  See the License for the specific language governing permissions and        %
 %  limitations under the License.                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Bill Radcliffe of Corbis (www.corbis.com) contributed the polygon
 % rendering code based on Paul Heckbert's "Concave Polygon Scan Conversion",
 % Graphics Gems, 1990.  Leonard Rosenthal and David Harr of Appligent
 % (www.appligent.com) contributed the dash pattern, linecap stroking
 % algorithm, and minor rendering improvements.
 %
 */
 
 /*
   Include declarations.
 */
 #include "MagickCore/studio.h"
 #include "MagickCore/annotate.h"
 #include "MagickCore/artifact.h"
 #include "MagickCore/blob.h"
 #include "MagickCore/cache.h"
 #include "MagickCore/cache-private.h"
 #include "MagickCore/cache-view.h"
 #include "MagickCore/channel.h"
 #include "MagickCore/color.h"
 #include "MagickCore/colorspace-private.h"
 #include "MagickCore/composite.h"
 #include "MagickCore/composite-private.h"
 #include "MagickCore/constitute.h"
 #include "MagickCore/draw.h"
 #include "MagickCore/draw-private.h"
 #include "MagickCore/enhance.h"
 #include "MagickCore/exception.h"
 #include "MagickCore/exception-private.h"
 #include "MagickCore/gem.h"
 #include "MagickCore/geometry.h"
 #include "MagickCore/image-private.h"
 #include "MagickCore/list.h"
 #include "MagickCore/log.h"
 #include "MagickCore/memory-private.h"
 #include "MagickCore/monitor.h"
 #include "MagickCore/monitor-private.h"
 #include "MagickCore/option.h"
 #include "MagickCore/paint.h"
 #include "MagickCore/pixel-accessor.h"
 #include "MagickCore/pixel-private.h"
 #include "MagickCore/property.h"
 #include "MagickCore/resample.h"
 #include "MagickCore/resample-private.h"
 #include "MagickCore/resource_.h"
 #include "MagickCore/splay-tree.h"
 #include "MagickCore/string_.h"
 #include "MagickCore/string-private.h"
 #include "MagickCore/thread-private.h"
 #include "MagickCore/token.h"
 #include "MagickCore/transform-private.h"
 #include "MagickCore/utility.h"
 
 /*
   Define declarations.
 */
 #define BezierQuantum  200
 #define DrawEpsilon  (1.0e-10)
-#define MaxBezierCoordinates  262144
+#define MaxBezierCoordinates  2097152
 #define ThrowPointExpectedException(token,exception) \
 { \
   (void) ThrowMagickException(exception,GetMagickModule(),DrawError, \
     "NonconformingDrawingPrimitiveDefinition","`%s'",token); \
   status=MagickFalse; \
   break; \
 }
 
 /*
   Typedef declarations.
 */
@@ -1619,249 +1619,251 @@ static Image *DrawCompositeMask(Image *image,const DrawInfo *draw_info,
   /*
     Draw a mask path.
   */
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(draw_info != (const DrawInfo *) NULL);
   composite_mask=AcquireImage((const ImageInfo *) NULL,exception);
   status=SetImageExtent(composite_mask,image->columns,image->rows,exception);
   if (status == MagickFalse)
     return(DestroyImage(composite_mask));
   (void) SetImageMask(composite_mask,CompositePixelMask,(Image *) NULL,
     exception);
   (void) QueryColorCompliance("#0000",AllCompliance,
     &composite_mask->background_color,exception);
   composite_mask->background_color.alpha=(MagickRealType) TransparentAlpha;
   composite_mask->background_color.alpha_trait=BlendPixelTrait;
   (void) SetImageBackgroundColor(composite_mask,exception);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"\nbegin mask-path %s",
       id);
   clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   (void) CloneString(&clone_info->primitive,mask_path);
   (void) QueryColorCompliance("#ffffff",AllCompliance,&clone_info->fill,
     exception);
   (void) QueryColorCompliance("#00000000",AllCompliance,&clone_info->stroke,
     exception);
   clone_info->stroke_width=0.0;
   clone_info->alpha=OpaqueAlpha;
   status=DrawImage(composite_mask,clone_info,exception);
   clone_info=DestroyDrawInfo(clone_info);
   separate_mask=SeparateImage(composite_mask,AlphaChannel,exception);
   if (separate_mask != (Image *) NULL)
     {
       composite_mask=DestroyImage(composite_mask);
       composite_mask=separate_mask;
       status=NegateImage(composite_mask,MagickFalse,exception);
       if (status == MagickFalse)
         composite_mask=DestroyImage(composite_mask);
     }
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"end mask-path");
   return(composite_mask);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   D r a w D a s h P o l y g o n                                             %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawDashPolygon() draws a dashed polygon (line, rectangle, ellipse) on the
 %  image while respecting the dash offset and dash pattern attributes.
 %
 %  The format of the DrawDashPolygon method is:
 %
 %      MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,
 %        const PrimitiveInfo *primitive_info,Image *image,
 %        ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o draw_info: the draw info.
 %
 %    o primitive_info: Specifies a pointer to a PrimitiveInfo structure.
 %
 %    o image: the image.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 static MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info,
   const PrimitiveInfo *primitive_info,Image *image,ExceptionInfo *exception)
 {
   double
     length,
     maximum_length,
     offset,
     scale,
     total_length;
 
   DrawInfo
     *clone_info;
 
   MagickStatusType
     status;
 
   PrimitiveInfo
     *dash_polygon;
 
   register double
     dx,
     dy;
 
   register ssize_t
     i;
 
   size_t
     number_vertices;
 
   ssize_t
     j,
     n;
 
   assert(draw_info != (const DrawInfo *) NULL);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    begin draw-dash");
   for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ;
   number_vertices=(size_t) i;
   dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
     (2UL*number_vertices+32UL),sizeof(*dash_polygon));
   if (dash_polygon == (PrimitiveInfo *) NULL)
     return(MagickFalse);
   (void) memset(dash_polygon,0,(2UL*number_vertices+32UL)*
     sizeof(*dash_polygon));
   clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   clone_info->miterlimit=0;
   dash_polygon[0]=primitive_info[0];
   scale=ExpandAffine(&draw_info->affine);
   length=scale*draw_info->dash_pattern[0];
   offset=fabs(draw_info->dash_offset) >= DrawEpsilon ?
     scale*draw_info->dash_offset : 0.0;
   j=1;
   for (n=0; offset > 0.0; j=0)
   {
     if (draw_info->dash_pattern[n] <= 0.0)
       break;
     length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5));
     if (offset > length)
       {
         offset-=length;
         n++;
         length=scale*draw_info->dash_pattern[n];
         continue;
       }
     if (offset < length)
       {
         length-=offset;
         offset=0.0;
         break;
       }
     offset=0.0;
     n++;
   }
   status=MagickTrue;
   maximum_length=0.0;
   total_length=0.0;
   for (i=1; (i < (ssize_t) number_vertices) && (length >= 0.0); i++)
   {
     dx=primitive_info[i].point.x-primitive_info[i-1].point.x;
     dy=primitive_info[i].point.y-primitive_info[i-1].point.y;
     maximum_length=hypot(dx,dy);
+    if (maximum_length > MaxBezierCoordinates)
+      break;
     if (fabs(length) < DrawEpsilon)
       {
         n++;
         if (fabs(draw_info->dash_pattern[n]) < DrawEpsilon)
           n=0;
         length=scale*draw_info->dash_pattern[n];
       }
     for (total_length=0.0; (length >= 0.0) && (maximum_length >= (total_length+length)); )
     {
       total_length+=length;
       if ((n & 0x01) != 0)
         {
           dash_polygon[0]=primitive_info[0];
           dash_polygon[0].point.x=(double) (primitive_info[i-1].point.x+dx*
             total_length*PerceptibleReciprocal(maximum_length));
           dash_polygon[0].point.y=(double) (primitive_info[i-1].point.y+dy*
             total_length*PerceptibleReciprocal(maximum_length));
           j=1;
         }
       else
         {
           if ((j+1) > (ssize_t) number_vertices)
             break;
           dash_polygon[j]=primitive_info[i-1];
           dash_polygon[j].point.x=(double) (primitive_info[i-1].point.x+dx*
             total_length*PerceptibleReciprocal(maximum_length));
           dash_polygon[j].point.y=(double) (primitive_info[i-1].point.y+dy*
             total_length*PerceptibleReciprocal(maximum_length));
           dash_polygon[j].coordinates=1;
           j++;
           dash_polygon[0].coordinates=(size_t) j;
           dash_polygon[j].primitive=UndefinedPrimitive;
           status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);
         }
       n++;
       if (fabs(draw_info->dash_pattern[n]) < DrawEpsilon)
         n=0;
       length=scale*draw_info->dash_pattern[n];
     }
     length-=(maximum_length-total_length);
     if ((n & 0x01) != 0)
       continue;
     dash_polygon[j]=primitive_info[i];
     dash_polygon[j].coordinates=1;
     j++;
   }
   if ((total_length < maximum_length) && ((n & 0x01) == 0) && (j > 1))
     {
       dash_polygon[j]=primitive_info[i-1];
       dash_polygon[j].point.x+=DrawEpsilon;
       dash_polygon[j].point.y+=DrawEpsilon;
       dash_polygon[j].coordinates=1;
       j++;
       dash_polygon[0].coordinates=(size_t) j;
       dash_polygon[j].primitive=UndefinedPrimitive;
       status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception);
     }
   dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon);
   clone_info=DestroyDrawInfo(clone_info);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"    end draw-dash");
   return(status != 0 ? MagickTrue : MagickFalse);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %     D r a w G r a d i e n t I m a g e                                       %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawGradientImage() draws a linear gradient on the image.
 %
 %  The format of the DrawGradientImage method is:
 %
 %      MagickBooleanType DrawGradientImage(Image *image,
 %        const DrawInfo *draw_info,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o draw_info: the draw info.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
@@ -2204,28 +2206,29 @@ MagickExport MagickBooleanType DrawGradientImage(Image *image,
 static MagickBooleanType CheckPrimitiveExtent(MVGInfo *mvg_info,
   const size_t pad)
 {
   PrimitiveInfo
     *primitive_info;
 
   size_t
     extent;
 
   /*
     Check if there is enough storage for drawing pimitives.
   */
   extent=(size_t) mvg_info->offset+pad+4096;
   if (extent <= *mvg_info->extent)
-    return(MagickFalse);
+    return(MagickTrue);
   primitive_info=(*mvg_info->primitive_info);
-  primitive_info=ResizeQuantumMemory(primitive_info,extent,
-    sizeof(*primitive_info));
+  primitive_info=AcquireQuantumMemory(extent,sizeof(*primitive_info));
   if (primitive_info == (PrimitiveInfo *) NULL)
     {
       (void) ThrowMagickException(mvg_info->exception,GetMagickModule(),
         ResourceLimitError,"MemoryAllocationFailed","`%s'","");
       return(MagickFalse);
     }
+  (void) memcpy(primitive_info,*mvg_info->primitive_info,*mvg_info->extent);
+  (void) RelinquishMagickMemory(*mvg_info->primitive_info);
   *mvg_info->primitive_info=primitive_info;
   *mvg_info->extent=extent;
   return(MagickTrue);
 }
@@ -2345,1923 +2348,1925 @@ static inline void TracePoint(PrimitiveInfo *primitive_info,
 MagickExport MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,
   ExceptionInfo *exception)
 {
 #define RenderImageTag  "Render/Image"
 
   AffineMatrix
     affine,
     current;
 
   char
     keyword[MagickPathExtent],
     geometry[MagickPathExtent],
     *next_token,
     pattern[MagickPathExtent],
     *primitive,
     *token;
 
   const char
     *q;
 
   double
     angle,
     coordinates,
     factor,
     primitive_extent;
 
   DrawInfo
     **graphic_context;
 
   MagickBooleanType
     proceed;
 
   MagickStatusType
     status;
 
   MVGInfo
     mvg_info;
 
   PointInfo
     point;
 
   PrimitiveInfo
     *primitive_info;
 
   PrimitiveType
     primitive_type;
 
   register const char
     *p;
 
   register ssize_t
     i,
     x;
 
   SegmentInfo
     bounds;
 
   size_t
     extent,
     number_points,
     number_stops;
 
   SplayTreeInfo
     *macros;
 
   ssize_t
     defsDepth,
     j,
     k,
     n,
     symbolDepth;
 
   StopInfo
     *stops;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(draw_info != (DrawInfo *) NULL);
   assert(draw_info->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   if ((draw_info->primitive == (char *) NULL) ||
       (*draw_info->primitive == '\0'))
     return(MagickFalse);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
   if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
     return(MagickFalse);
   if (image->alpha_trait == UndefinedPixelTrait)
     {
       status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);
       if (status == MagickFalse)
         return(status);
     }
   primitive=(char *) NULL;
   if (*draw_info->primitive != '@')
     primitive=AcquireString(draw_info->primitive);
   else
     if ((strlen(draw_info->primitive) > 1) &&
         (*(draw_info->primitive+1) != '-'))
       primitive=FileToString(draw_info->primitive+1,~0UL,exception);
   if (primitive == (char *) NULL)
     return(MagickFalse);
   primitive_extent=(double) strlen(primitive);
   (void) SetImageArtifact(image,"MVG",primitive);
   n=0;
   number_stops=0;
   stops=(StopInfo *) NULL;
   /*
     Allocate primitive info memory.
   */
   graphic_context=(DrawInfo **) AcquireMagickMemory(sizeof(*graphic_context));
   if (graphic_context == (DrawInfo **) NULL)
     {
       primitive=DestroyString(primitive);
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
   number_points=4096;
   primitive_info=(PrimitiveInfo *) AcquireQuantumMemory((size_t) number_points,
     sizeof(*primitive_info));
   if (primitive_info == (PrimitiveInfo *) NULL)
     {
       primitive=DestroyString(primitive);
       for ( ; n >= 0; n--)
         graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
       graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
   (void) memset(primitive_info,0,(size_t) number_points*
     sizeof(*primitive_info));
   mvg_info.primitive_info=(&primitive_info);
   mvg_info.extent=(&number_points);
   mvg_info.offset=0;
   mvg_info.exception=exception;
   graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   graphic_context[n]->viewbox=image->page;
   if ((image->page.width == 0) || (image->page.height == 0))
     {
       graphic_context[n]->viewbox.width=image->columns;
       graphic_context[n]->viewbox.height=image->rows;
     }
   token=AcquireString(primitive);
   extent=strlen(token)+MagickPathExtent;
   defsDepth=0;
   symbolDepth=0;
   macros=GetMVGMacros(primitive);
   status=MagickTrue;
   for (q=primitive; *q != '\0'; )
   {
     /*
       Interpret graphic primitive.
     */
     GetNextToken(q,&q,MagickPathExtent,keyword);
     if (*keyword == '\0')
       break;
     if (*keyword == '#')
       {
         /*
           Comment.
         */
         while ((*q != '\n') && (*q != '\0'))
           q++;
         continue;
       }
     p=q-strlen(keyword)-1;
     primitive_type=UndefinedPrimitive;
     current=graphic_context[n]->affine;
     GetAffineMatrix(&affine);
     switch (*keyword)
     {
       case ';':
         break;
       case 'a':
       case 'A':
       {
         if (LocaleCompare("affine",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.sx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.rx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ry=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.sy=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.tx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ty=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("alpha",keyword) == 0)
           {
             primitive_type=AlphaPrimitive;
             break;
           }
         if (LocaleCompare("arc",keyword) == 0)
           {
             primitive_type=ArcPrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'b':
       case 'B':
       {
         if (LocaleCompare("bezier",keyword) == 0)
           {
             primitive_type=BezierPrimitive;
             break;
           }
         if (LocaleCompare("border-color",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             status&=QueryColorCompliance(token,AllCompliance,
               &graphic_context[n]->border_color,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'c':
       case 'C':
       {
         if (LocaleCompare("class",keyword) == 0)
           {
             const char
               *mvg_class;
 
             GetNextToken(q,&q,extent,token);
             if (*token == '\0')
               {
                 status=MagickFalse;
                 break;
               }
             mvg_class=(const char *) GetValueFromSplayTree(macros,token);
             if (mvg_class != (const char *) NULL)
               {
                 char
                   *elements;
 
                 ssize_t
                   offset;
 
                 /*
                   Inject class elements in stream.
                 */
                 offset=(ssize_t) (p-primitive);
                 elements=AcquireString(primitive);
                 elements[offset]='\0';
                 (void) ConcatenateString(&elements,mvg_class);
                 (void) ConcatenateString(&elements,"\n");
                 (void) ConcatenateString(&elements,q);
                 primitive=DestroyString(primitive);
                 primitive=elements;
                 q=primitive+offset;
               }
             break;
           }
         if (LocaleCompare("clip-path",keyword) == 0)
           {
             const char
               *clip_path;
 
             /*
               Take a node from within the MVG document, and duplicate it here.
             */
             GetNextToken(q,&q,extent,token);
             if (*token == '\0')
               {
                 status=MagickFalse;
                 break;
               }
             (void) CloneString(&graphic_context[n]->clip_mask,token);
             clip_path=(const char *) GetValueFromSplayTree(macros,token);
             if (clip_path != (const char *) NULL)
               {
                 if (graphic_context[n]->clipping_mask != (Image *) NULL)
                   graphic_context[n]->clipping_mask=
                     DestroyImage(graphic_context[n]->clipping_mask);
                 graphic_context[n]->clipping_mask=DrawClippingMask(image,
                   graphic_context[n],token,clip_path,exception);
                 if (draw_info->compliance != SVGCompliance)
                   (void) DrawClipPath(image,graphic_context[n],
                     graphic_context[n]->clip_mask,exception);
               }
             break;
           }
         if (LocaleCompare("clip-rule",keyword) == 0)
           {
             ssize_t
               fill_rule;
 
             GetNextToken(q,&q,extent,token);
             fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
               token);
             if (fill_rule == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->fill_rule=(FillRule) fill_rule;
             break;
           }
         if (LocaleCompare("clip-units",keyword) == 0)
           {
             ssize_t
               clip_units;
 
             GetNextToken(q,&q,extent,token);
             clip_units=ParseCommandOption(MagickClipPathOptions,MagickFalse,
               token);
             if (clip_units == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->clip_units=(ClipPathUnits) clip_units;
             if (clip_units == ObjectBoundingBox)
               {
                 GetAffineMatrix(&current);
                 affine.sx=draw_info->bounds.x2;
                 affine.sy=draw_info->bounds.y2;
                 affine.tx=draw_info->bounds.x1;
                 affine.ty=draw_info->bounds.y1;
                 break;
               }
             break;
           }
         if (LocaleCompare("circle",keyword) == 0)
           {
             primitive_type=CirclePrimitive;
             break;
           }
         if (LocaleCompare("color",keyword) == 0)
           {
             primitive_type=ColorPrimitive;
             break;
           }
         if (LocaleCompare("compliance",keyword) == 0)
           {
             /*
               MVG compliance associates a clipping mask with an image; SVG
               compliance associates a clipping mask with a graphics context.
             */
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->compliance=(ComplianceType) ParseCommandOption(
               MagickComplianceOptions,MagickFalse,token);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'd':
       case 'D':
       {
         if (LocaleCompare("decorate",keyword) == 0)
           {
             ssize_t
               decorate;
 
             GetNextToken(q,&q,extent,token);
             decorate=ParseCommandOption(MagickDecorateOptions,MagickFalse,
               token);
             if (decorate == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->decorate=(DecorationType) decorate;
             break;
           }
         if (LocaleCompare("density",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->density,token);
             break;
           }
         if (LocaleCompare("direction",keyword) == 0)
           {
             ssize_t
               direction;
 
             GetNextToken(q,&q,extent,token);
             direction=ParseCommandOption(MagickDirectionOptions,MagickFalse,
               token);
             if (direction == -1)
               status=MagickFalse;
             else
               graphic_context[n]->direction=(DirectionType) direction;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'e':
       case 'E':
       {
         if (LocaleCompare("ellipse",keyword) == 0)
           {
             primitive_type=EllipsePrimitive;
             break;
           }
         if (LocaleCompare("encoding",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->encoding,token);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'f':
       case 'F':
       {
         if (LocaleCompare("fill",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             (void) FormatLocaleString(pattern,MagickPathExtent,"%s",token);
             if (GetImageArtifact(image,pattern) != (const char *) NULL)
               (void) DrawPatternPath(image,draw_info,token,
                 &graphic_context[n]->fill_pattern,exception);
             else
               {
                 status&=QueryColorCompliance(token,AllCompliance,
                   &graphic_context[n]->fill,exception);
                 if (graphic_context[n]->fill_alpha != OpaqueAlpha)
                   graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;
               }
             break;
           }
         if (LocaleCompare("fill-opacity",keyword) == 0)
           {
             double
               opacity;
 
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             opacity=MagickMin(MagickMax(factor*
               StringToDouble(token,&next_token),0.0),1.0);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             graphic_context[n]->fill_alpha*=opacity;
             if (graphic_context[n]->fill_alpha != OpaqueAlpha)
               graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;
             break;
           }
         if (LocaleCompare("fill-rule",keyword) == 0)
           {
             ssize_t
               fill_rule;
 
             GetNextToken(q,&q,extent,token);
             fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
               token);
             if (fill_rule == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->fill_rule=(FillRule) fill_rule;
             break;
           }
         if (LocaleCompare("font",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->font,token);
             if (LocaleCompare("none",token) == 0)
               graphic_context[n]->font=(char *) RelinquishMagickMemory(
                 graphic_context[n]->font);
             break;
           }
         if (LocaleCompare("font-family",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->family,token);
             break;
           }
         if (LocaleCompare("font-size",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->pointsize=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("font-stretch",keyword) == 0)
           {
             ssize_t
               stretch;
 
             GetNextToken(q,&q,extent,token);
             stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,token);
             if (stretch == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->stretch=(StretchType) stretch;
             break;
           }
         if (LocaleCompare("font-style",keyword) == 0)
           {
             ssize_t
               style;
 
             GetNextToken(q,&q,extent,token);
             style=ParseCommandOption(MagickStyleOptions,MagickFalse,token);
             if (style == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->style=(StyleType) style;
             break;
           }
         if (LocaleCompare("font-weight",keyword) == 0)
           {
             ssize_t
               weight;
 
             GetNextToken(q,&q,extent,token);
             weight=ParseCommandOption(MagickWeightOptions,MagickFalse,token);
             if (weight == -1)
               weight=(ssize_t) StringToUnsignedLong(token);
             graphic_context[n]->weight=(size_t) weight;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'g':
       case 'G':
       {
         if (LocaleCompare("gradient-units",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("gravity",keyword) == 0)
           {
             ssize_t
               gravity;
 
             GetNextToken(q,&q,extent,token);
             gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,token);
             if (gravity == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->gravity=(GravityType) gravity;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'i':
       case 'I':
       {
         if (LocaleCompare("image",keyword) == 0)
           {
             ssize_t
               compose;
 
             primitive_type=ImagePrimitive;
             GetNextToken(q,&q,extent,token);
             compose=ParseCommandOption(MagickComposeOptions,MagickFalse,token);
             if (compose == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->compose=(CompositeOperator) compose;
             break;
           }
         if (LocaleCompare("interline-spacing",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->interline_spacing=StringToDouble(token,
               &next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("interword-spacing",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->interword_spacing=StringToDouble(token,
               &next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'k':
       case 'K':
       {
         if (LocaleCompare("kerning",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->kerning=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'l':
       case 'L':
       {
         if (LocaleCompare("line",keyword) == 0)
           {
             primitive_type=LinePrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'm':
       case 'M':
       {
         if (LocaleCompare("mask",keyword) == 0)
           {
             const char
               *mask_path;
 
             /*
               Take a node from within the MVG document, and duplicate it here.
             */
             GetNextToken(q,&q,extent,token);
             mask_path=(const char *) GetValueFromSplayTree(macros,token);
             if (mask_path != (char *) NULL)
               {
                 if (graphic_context[n]->composite_mask != (Image *) NULL)
                   graphic_context[n]->composite_mask=
                     DestroyImage(graphic_context[n]->composite_mask);
                 graphic_context[n]->composite_mask=DrawCompositeMask(image,
                   graphic_context[n],token,mask_path,exception);
                 if (draw_info->compliance != SVGCompliance)
                   status=SetImageMask(image,CompositePixelMask,
                     graphic_context[n]->composite_mask,exception);
               }
             break;
           }
         break;
       }
       case 'o':
       case 'O':
       {
         if (LocaleCompare("offset",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("opacity",keyword) == 0)
           {
             double
               opacity;
 
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             opacity=MagickMin(MagickMax(factor*
               StringToDouble(token,&next_token),0.0),1.0);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             graphic_context[n]->fill_alpha*=opacity;
             if (graphic_context[n]->fill_alpha != OpaqueAlpha)
               graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;
             graphic_context[n]->stroke_alpha*=opacity;
             if (graphic_context[n]->stroke_alpha != OpaqueAlpha)
               graphic_context[n]->stroke.alpha=graphic_context[n]->stroke_alpha;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'p':
       case 'P':
       {
         if (LocaleCompare("path",keyword) == 0)
           {
             primitive_type=PathPrimitive;
             break;
           }
         if (LocaleCompare("point",keyword) == 0)
           {
             primitive_type=PointPrimitive;
             break;
           }
         if (LocaleCompare("polyline",keyword) == 0)
           {
             primitive_type=PolylinePrimitive;
             break;
           }
         if (LocaleCompare("polygon",keyword) == 0)
           {
             primitive_type=PolygonPrimitive;
             break;
           }
         if (LocaleCompare("pop",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (LocaleCompare("class",token) == 0)
               break;
             if (LocaleCompare("clip-path",token) == 0)
               break;
             if (LocaleCompare("defs",token) == 0)
               {
                 defsDepth--;
                 graphic_context[n]->render=defsDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             if (LocaleCompare("gradient",token) == 0)
               break;
             if (LocaleCompare("graphic-context",token) == 0)
               {
                 if (n <= 0)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       DrawError,"UnbalancedGraphicContextPushPop","`%s'",token);
                     status=MagickFalse;
                     n=0;
                     break;
                   }
                 if ((graphic_context[n]->clip_mask != (char *) NULL) &&
                     (draw_info->compliance != SVGCompliance))
                   if (LocaleCompare(graphic_context[n]->clip_mask,
                       graphic_context[n-1]->clip_mask) != 0)
                     (void) SetImageMask(image,WritePixelMask,(Image *) NULL,
                       exception);
                 graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
                 n--;
                 break;
               }
             if (LocaleCompare("mask",token) == 0)
               break;
             if (LocaleCompare("pattern",token) == 0)
               break;
             if (LocaleCompare("symbol",token) == 0)
               {
                 symbolDepth--;
                 graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             status=MagickFalse;
             break;
           }
         if (LocaleCompare("push",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (LocaleCompare("class",token) == 0)
               {
                 /*
                   Class context.
                 */
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"class") != 0)
                     continue;
                   break;
                 }
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("clip-path",token) == 0)
               {
                 char
                   name[MaxTextExtent];
 
                 const char
                   *clip_path;
 
                 GetNextToken(q,&q,extent,token);
                 (void) FormatLocaleString(name,MaxTextExtent,"%s",token);
                 clip_path=(const char *) GetValueFromSplayTree(macros,name);
                 if (clip_path != (char *) NULL)
                   (void) SetImageArtifact(image,name,clip_path);
                 break;
               }
             if (LocaleCompare("defs",token) == 0)
               {
                 defsDepth++;
                 graphic_context[n]->render=defsDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             if (LocaleCompare("gradient",token) == 0)
               {
                 char
                   key[2*MagickPathExtent],
                   name[MagickPathExtent],
                   type[MagickPathExtent];
 
                 SegmentInfo
                   segment;
 
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(type,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 segment.x1=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.y1=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.x2=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.y2=StringToDouble(token,&next_token);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 if (LocaleCompare(type,"radial") == 0)
                   {
                     GetNextToken(q,&q,extent,token);
                     if (*token == ',')
                       GetNextToken(q,&q,extent,token);
                   }
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"gradient") != 0)
                     continue;
                   break;
                 }
                 if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))
                   {
                     status=MagickFalse;
                     break;
                   }
                 (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
                 bounds.x1=graphic_context[n]->affine.sx*segment.x1+
                   graphic_context[n]->affine.ry*segment.y1+
                   graphic_context[n]->affine.tx;
                 bounds.y1=graphic_context[n]->affine.rx*segment.x1+
                   graphic_context[n]->affine.sy*segment.y1+
                   graphic_context[n]->affine.ty;
                 bounds.x2=graphic_context[n]->affine.sx*segment.x2+
                   graphic_context[n]->affine.ry*segment.y2+
                   graphic_context[n]->affine.tx;
                 bounds.y2=graphic_context[n]->affine.rx*segment.x2+
                   graphic_context[n]->affine.sy*segment.y2+
                   graphic_context[n]->affine.ty;
                 (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
                 (void) SetImageArtifact(image,key,token);
                 (void) FormatLocaleString(key,MagickPathExtent,"%s-type",name);
                 (void) SetImageArtifact(image,key,type);
                 (void) FormatLocaleString(key,MagickPathExtent,"%s-geometry",
                   name);
                 (void) FormatLocaleString(geometry,MagickPathExtent,
                   "%gx%g%+.15g%+.15g",
                   MagickMax(fabs(bounds.x2-bounds.x1+1.0),1.0),
                   MagickMax(fabs(bounds.y2-bounds.y1+1.0),1.0),
                   bounds.x1,bounds.y1);
                 (void) SetImageArtifact(image,key,geometry);
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("graphic-context",token) == 0)
               {
                 n++;
                 graphic_context=(DrawInfo **) ResizeQuantumMemory(
                   graphic_context,(size_t) (n+1),sizeof(*graphic_context));
                 if (graphic_context == (DrawInfo **) NULL)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       ResourceLimitError,"MemoryAllocationFailed","`%s'",
                       image->filename);
                     break;
                   }
                 graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
                   graphic_context[n-1]);
                 if (*q == '"')
                   GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("mask",token) == 0)
               {
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("pattern",token) == 0)
               {
                 char
                   key[2*MagickPathExtent],
                   name[MagickPathExtent];
 
                 RectangleInfo
                   bounds;
 
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 bounds.x=(ssize_t) ceil(StringToDouble(token,&next_token)-0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 bounds.y=(ssize_t) ceil(StringToDouble(token,&next_token)-0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 bounds.width=(size_t) floor(StringToDouble(token,&next_token)+
                   0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 bounds.height=(size_t) floor(StringToDouble(token,&next_token)+
                   0.5);
                 if (token == next_token)
                   ThrowPointExpectedException(token,exception);
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"pattern") != 0)
                     continue;
                   break;
                 }
                 if ((q == (char *) NULL) || (p == (char *) NULL) || ((q-4) < p))
                   {
                     status=MagickFalse;
                     break;
                   }
                 (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
                 (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
                 (void) SetImageArtifact(image,key,token);
                 (void) FormatLocaleString(key,MagickPathExtent,"%s-geometry",
                   name);
                 (void) FormatLocaleString(geometry,MagickPathExtent,
                   "%.20gx%.20g%+.20g%+.20g",(double)bounds.width,(double)
                   bounds.height,(double)bounds.x,(double) bounds.y);
                 (void) SetImageArtifact(image,key,geometry);
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("symbol",token) == 0)
               {
                 symbolDepth++;
                 graphic_context[n]->render=symbolDepth > 0 ? MagickFalse :
                   MagickTrue;
                 break;
               }
             status=MagickFalse;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'r':
       case 'R':
       {
         if (LocaleCompare("rectangle",keyword) == 0)
           {
             primitive_type=RectanglePrimitive;
             break;
           }
         if (LocaleCompare("rotate",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             affine.sx=cos(DegreesToRadians(fmod((double) angle,360.0)));
             affine.rx=sin(DegreesToRadians(fmod((double) angle,360.0)));
             affine.ry=(-sin(DegreesToRadians(fmod((double) angle,360.0))));
             affine.sy=cos(DegreesToRadians(fmod((double) angle,360.0)));
             break;
           }
         if (LocaleCompare("roundRectangle",keyword) == 0)
           {
             primitive_type=RoundRectanglePrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 's':
       case 'S':
       {
         if (LocaleCompare("scale",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.sx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.sy=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("skewX",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             affine.ry=sin(DegreesToRadians(angle));
             break;
           }
         if (LocaleCompare("skewY",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             affine.rx=(-tan(DegreesToRadians(angle)/2.0));
             break;
           }
         if (LocaleCompare("stop-color",keyword) == 0)
           {
             PixelInfo
               stop_color;
 
             number_stops++;
             if (number_stops == 1)
               stops=(StopInfo *) AcquireQuantumMemory(2,sizeof(*stops));
             else
               if (number_stops > 2)
                 stops=(StopInfo *) ResizeQuantumMemory(stops,number_stops,
                   sizeof(*stops));
             if (stops == (StopInfo *) NULL)
               {
                 (void) ThrowMagickException(exception,GetMagickModule(),
                   ResourceLimitError,"MemoryAllocationFailed","`%s'",
                   image->filename);
                 break;
               }
             GetNextToken(q,&q,extent,token);
             status&=QueryColorCompliance(token,AllCompliance,&stop_color,
               exception);
             stops[number_stops-1].color=stop_color;
             GetNextToken(q,&q,extent,token);
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             stops[number_stops-1].offset=factor*StringToDouble(token,
               &next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("stroke",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             (void) FormatLocaleString(pattern,MagickPathExtent,"%s",token);
             if (GetImageArtifact(image,pattern) != (const char *) NULL)
               (void) DrawPatternPath(image,draw_info,token,
                 &graphic_context[n]->stroke_pattern,exception);
             else
               {
                 status&=QueryColorCompliance(token,AllCompliance,
                   &graphic_context[n]->stroke,exception);
                 if (graphic_context[n]->stroke_alpha != OpaqueAlpha)
                   graphic_context[n]->stroke.alpha=
                     graphic_context[n]->stroke_alpha;
                }
             break;
           }
         if (LocaleCompare("stroke-antialias",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->stroke_antialias=StringToLong(token) != 0 ?
               MagickTrue : MagickFalse;
             break;
           }
         if (LocaleCompare("stroke-dasharray",keyword) == 0)
           {
             if (graphic_context[n]->dash_pattern != (double *) NULL)
               graphic_context[n]->dash_pattern=(double *)
                 RelinquishMagickMemory(graphic_context[n]->dash_pattern);
             if (IsPoint(q) != MagickFalse)
               {
                 const char
                   *r;
 
                 r=q;
                 GetNextToken(r,&r,extent,token);
                 if (*token == ',')
                   GetNextToken(r,&r,extent,token);
                 for (x=0; IsPoint(token) != MagickFalse; x++)
                 {
                   GetNextToken(r,&r,extent,token);
                   if (*token == ',')
                     GetNextToken(r,&r,extent,token);
                 }
                 graphic_context[n]->dash_pattern=(double *)
                   AcquireQuantumMemory((size_t) (2UL*x+2UL),
                   sizeof(*graphic_context[n]->dash_pattern));
                 if (graphic_context[n]->dash_pattern == (double *) NULL)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       ResourceLimitError,"MemoryAllocationFailed","`%s'",
                       image->filename);
                     status=MagickFalse;
                     break;
                   }
                 (void) memset(graphic_context[n]->dash_pattern,0,(size_t)
                   (2UL*x+2UL)*sizeof(*graphic_context[n]->dash_pattern));
                 for (j=0; j < x; j++)
                 {
                   GetNextToken(q,&q,extent,token);
                   if (*token == ',')
                     GetNextToken(q,&q,extent,token);
                   graphic_context[n]->dash_pattern[j]=StringToDouble(token,
                     &next_token);
                   if (token == next_token)
                     ThrowPointExpectedException(token,exception);
                   if (graphic_context[n]->dash_pattern[j] < 0.0)
                     status=MagickFalse;
                 }
                 if ((x & 0x01) != 0)
                   for ( ; j < (2*x); j++)
                     graphic_context[n]->dash_pattern[j]=
                       graphic_context[n]->dash_pattern[j-x];
                 graphic_context[n]->dash_pattern[j]=0.0;
                 break;
               }
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("stroke-dashoffset",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->dash_offset=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("stroke-linecap",keyword) == 0)
           {
             ssize_t
               linecap;
 
             GetNextToken(q,&q,extent,token);
             linecap=ParseCommandOption(MagickLineCapOptions,MagickFalse,token);
             if (linecap == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->linecap=(LineCap) linecap;
             break;
           }
         if (LocaleCompare("stroke-linejoin",keyword) == 0)
           {
             ssize_t
               linejoin;
 
             GetNextToken(q,&q,extent,token);
             linejoin=ParseCommandOption(MagickLineJoinOptions,MagickFalse,
               token);
             if (linejoin == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->linejoin=(LineJoin) linejoin;
             break;
           }
         if (LocaleCompare("stroke-miterlimit",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->miterlimit=StringToUnsignedLong(token);
             break;
           }
         if (LocaleCompare("stroke-opacity",keyword) == 0)
           {
             double
               opacity;
 
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             opacity=MagickMin(MagickMax(factor*
               StringToDouble(token,&next_token),0.0),1.0);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             graphic_context[n]->stroke_alpha*=opacity;
             if (graphic_context[n]->stroke_alpha != OpaqueAlpha)
               graphic_context[n]->stroke.alpha=graphic_context[n]->stroke_alpha;
             break;
           }
         if (LocaleCompare("stroke-width",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (graphic_context[n]->clip_path != MagickFalse)
               break;
             graphic_context[n]->stroke_width=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 't':
       case 'T':
       {
         if (LocaleCompare("text",keyword) == 0)
           {
             primitive_type=TextPrimitive;
             break;
           }
         if (LocaleCompare("text-align",keyword) == 0)
           {
             ssize_t
               align;
 
             GetNextToken(q,&q,extent,token);
             align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);
             if (align == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->align=(AlignType) align;
             break;
           }
         if (LocaleCompare("text-anchor",keyword) == 0)
           {
             ssize_t
               align;
 
             GetNextToken(q,&q,extent,token);
             align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);
             if (align == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->align=(AlignType) align;
             break;
           }
         if (LocaleCompare("text-antialias",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->text_antialias=StringToLong(token) != 0 ?
               MagickTrue : MagickFalse;
             break;
           }
         if (LocaleCompare("text-undercolor",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             status&=QueryColorCompliance(token,AllCompliance,
               &graphic_context[n]->undercolor,exception);
             break;
           }
         if (LocaleCompare("translate",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.tx=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ty=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'u':
       case 'U':
       {
         if (LocaleCompare("use",keyword) == 0)
           {
             const char
               *use;
 
             /*
               Get a macro from the MVG document, and "use" it here.
             */
             GetNextToken(q,&q,extent,token);
             use=(const char *) GetValueFromSplayTree(macros,token);
             if (use != (char *) NULL)
               {
                 DrawInfo
                   *clone_info;
 
                 clone_info=CloneDrawInfo((ImageInfo *) NULL,graphic_context[n]);
                 (void) CloneString(&clone_info->primitive,use);
                 status=DrawImage(image,clone_info,exception);
                 clone_info=DestroyDrawInfo(clone_info);
               }
             break;
           }
         break;
       }
       case 'v':
       case 'V':
       {
         if (LocaleCompare("viewbox",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.x=(ssize_t) ceil(StringToDouble(token,
               &next_token)-0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.y=(ssize_t) ceil(StringToDouble(token,
               &next_token)-0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.width=(size_t) floor(StringToDouble(
               token,&next_token)+0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.height=(size_t) floor(StringToDouble(
               token,&next_token)+0.5);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       default:
       {
         status=MagickFalse;
         break;
       }
     }
     if (status == MagickFalse)
       break;
     if ((fabs(affine.sx-1.0) >= DrawEpsilon) ||
         (fabs(affine.rx) >= DrawEpsilon) || (fabs(affine.ry) >= DrawEpsilon) ||
         (fabs(affine.sy-1.0) >= DrawEpsilon) ||
         (fabs(affine.tx) >= DrawEpsilon) || (fabs(affine.ty) >= DrawEpsilon))
       {
         graphic_context[n]->affine.sx=current.sx*affine.sx+current.ry*affine.rx;
         graphic_context[n]->affine.rx=current.rx*affine.sx+current.sy*affine.rx;
         graphic_context[n]->affine.ry=current.sx*affine.ry+current.ry*affine.sy;
         graphic_context[n]->affine.sy=current.rx*affine.ry+current.sy*affine.sy;
         graphic_context[n]->affine.tx=current.sx*affine.tx+current.ry*affine.ty+
           current.tx;
         graphic_context[n]->affine.ty=current.rx*affine.tx+current.sy*affine.ty+
           current.ty;
       }
     if (primitive_type == UndefinedPrimitive)
       {
         if (*q == '\0')
           {
             if (number_stops > 1)
               {
                 GradientType
                   type;
 
               type=LinearGradient;
               if (draw_info->gradient.type == RadialGradient)
                 type=RadialGradient;
               (void) GradientImage(image,type,PadSpread,stops,number_stops,
                 exception);
              }
            if (number_stops > 0)
              stops=(StopInfo *) RelinquishMagickMemory(stops);
           }
         if (image->debug != MagickFalse)
           (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  %.*s",(int)
             (q-p),p);
         continue;
       }
     /*
       Parse the primitive attributes.
     */
     i=0;
     mvg_info.offset=i;
     j=0;
     primitive_info[0].point.x=0.0;
     primitive_info[0].point.y=0.0;
     primitive_info[0].coordinates=0;
     primitive_info[0].method=FloodfillMethod;
     primitive_info[0].closed_subpath=MagickFalse;
     for (x=0; *q != '\0'; x++)
     {
       /*
         Define points.
       */
       if (IsPoint(q) == MagickFalse)
         break;
       GetNextToken(q,&q,extent,token);
       point.x=StringToDouble(token,&next_token);
       if (token == next_token)
         ThrowPointExpectedException(token,exception);
       GetNextToken(q,&q,extent,token);
       if (*token == ',')
         GetNextToken(q,&q,extent,token);
       point.y=StringToDouble(token,&next_token);
       if (token == next_token)
         ThrowPointExpectedException(token,exception);
       GetNextToken(q,(const char **) NULL,extent,token);
       if (*token == ',')
         GetNextToken(q,&q,extent,token);
       primitive_info[i].primitive=primitive_type;
       primitive_info[i].point=point;
       primitive_info[i].coordinates=0;
       primitive_info[i].method=FloodfillMethod;
       primitive_info[i].closed_subpath=MagickFalse;
       i++;
       mvg_info.offset=i;
       if (i < (ssize_t) number_points)
         continue;
-      (void) CheckPrimitiveExtent(&mvg_info,number_points);
+      status&=CheckPrimitiveExtent(&mvg_info,number_points);
     }
     if (status == MagickFalse)
       break;
     primitive_info[j].primitive=primitive_type;
     primitive_info[j].coordinates=(size_t) x;
     primitive_info[j].method=FloodfillMethod;
     primitive_info[j].closed_subpath=MagickFalse;
     primitive_info[j].text=(char *) NULL;
     /*
       Circumscribe primitive within a circle.
     */
     bounds.x1=primitive_info[j].point.x;
     bounds.y1=primitive_info[j].point.y;
     bounds.x2=primitive_info[j].point.x;
     bounds.y2=primitive_info[j].point.y;
     for (k=1; k < (ssize_t) primitive_info[j].coordinates; k++)
     {
       point=primitive_info[j+k].point;
       if (point.x < bounds.x1)
         bounds.x1=point.x;
       if (point.y < bounds.y1)
         bounds.y1=point.y;
       if (point.x > bounds.x2)
         bounds.x2=point.x;
       if (point.y > bounds.y2)
         bounds.y2=point.y;
     }
     /*
       Speculate how many points our primitive might consume.
     */
     coordinates=(double) primitive_info[j].coordinates;
     switch (primitive_type)
     {
       case RectanglePrimitive:
       {
         coordinates*=5;
         break;
       }
       case RoundRectanglePrimitive:
       {
         double
           alpha,
           beta,
           radius;
 
         alpha=bounds.x2-bounds.x1;
         beta=bounds.y2-bounds.y1;
         radius=hypot((double) alpha,(double) beta);
         coordinates*=5;
         coordinates+=2*((size_t) ceil((double) MagickPI*radius))+6*
           BezierQuantum+360;
         break;
       }
       case BezierPrimitive:
       {
         if (primitive_info[j].coordinates > 107)
           {
             (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
               "TooManyBezierCoordinates","`%s'",token);
             status=MagickFalse;
             break;
           }
         coordinates=(double) (BezierQuantum*primitive_info[j].coordinates);
         break;
       }
       case PathPrimitive:
       {
         char
           *s,
           *t;
 
         GetNextToken(q,&q,extent,token);
         coordinates=1;
         t=token;
         for (s=token; *s != '\0'; s=t)
         {
           double
             value;
 
           value=StringToDouble(s,&t);
           (void) value;
           if (s == t)
             {
               t++;
               continue;
             }
           coordinates++;
         }
         for (s=token; *s != '\0'; s++)
           if (strspn(s,"AaCcQqSsTt") != 0)
             coordinates+=(20*BezierQuantum)+360;
         break;
       }
       case CirclePrimitive:
       case ArcPrimitive:
       case EllipsePrimitive:
       {
         double
           alpha,
           beta,
           radius;
 
         alpha=bounds.x2-bounds.x1;
         beta=bounds.y2-bounds.y1;
         radius=hypot(alpha,beta);
         coordinates=2.0*(ceil(MagickPI*radius))+6*BezierQuantum+360.0;
         break;
       }
       default:
         break;
     }
     if (coordinates > MaxBezierCoordinates)
       {
         (void) ThrowMagickException(exception,GetMagickModule(),
-          DrawError,"TooManyBezierCoordinates","`%s'",token);
+          ResourceLimitError,"MemoryAllocationFailed","`%s'",token);
         status=MagickFalse;
       }
     if (status == MagickFalse)
       break;
     if (((MagickSizeType) (i+coordinates)) >= number_points)
       {
         /*
           Resize based on speculative points required by primitive.
         */
         number_points+=coordinates+1;
         if (number_points < (size_t) coordinates)
           {
             (void) ThrowMagickException(exception,GetMagickModule(),
               ResourceLimitError,"MemoryAllocationFailed","`%s'",
               image->filename);
             break;
           }
         mvg_info.offset=i;
-        (void) CheckPrimitiveExtent(&mvg_info,number_points);
+        status&=CheckPrimitiveExtent(&mvg_info,number_points);
       }
-    (void) CheckPrimitiveExtent(&mvg_info,4096);
+    status&=CheckPrimitiveExtent(&mvg_info,4096);
+    if (status == MagickFalse)
+      break;
     mvg_info.offset=j;
     switch (primitive_type)
     {
       case PointPrimitive:
       default:
       {
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         TracePoint(primitive_info+j,primitive_info[j].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case LinePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceLine(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case RectanglePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceRectangle(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case RoundRectanglePrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+2].point.x < 0.0) ||
             (primitive_info[j+2].point.y < 0.0))
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.x-primitive_info[j].point.x) < 0.0)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.y-primitive_info[j].point.y) < 0.0)
           {
             status=MagickFalse;
             break;
           }
         TraceRoundRectangle(&mvg_info,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case ArcPrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             primitive_type=UndefinedPrimitive;
             break;
           }
         TraceArc(&mvg_info,primitive_info[j].point,primitive_info[j+1].point,
           primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case EllipsePrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             status=MagickFalse;
             break;
           }
         if ((primitive_info[j+1].point.x < 0.0) ||
             (primitive_info[j+1].point.y < 0.0))
           {
             status=MagickFalse;
             break;
           }
         TraceEllipse(&mvg_info,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case CirclePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceCircle(&mvg_info,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case PolylinePrimitive:
       {
         if (primitive_info[j].coordinates < 1)
           {
             status=MagickFalse;
             break;
           }
         break;
       }
       case PolygonPrimitive:
       {
         if (primitive_info[j].coordinates < 3)
           {
             status=MagickFalse;
             break;
           }
         primitive_info[i]=primitive_info[j];
         primitive_info[i].coordinates=0;
         primitive_info[j].coordinates++;
         primitive_info[j].closed_subpath=MagickTrue;
         i++;
         break;
       }
       case BezierPrimitive:
       {
         if (primitive_info[j].coordinates < 3)
           {
             status=MagickFalse;
             break;
           }
         TraceBezier(&mvg_info,primitive_info[j].coordinates);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case PathPrimitive:
       {
         coordinates=(double) TracePath(&mvg_info,token,exception);
         if (coordinates == 0.0)
           {
             status=MagickFalse;
             break;
           }
         i=(ssize_t) (j+coordinates);
         break;
       }
       case AlphaPrimitive:
       case ColorPrimitive:
       {
         ssize_t
           method;
 
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         GetNextToken(q,&q,extent,token);
         method=ParseCommandOption(MagickMethodOptions,MagickFalse,token);
         if (method == -1)
           {
             status=MagickFalse;
             break;
           }
         primitive_info[j].method=(PaintMethod) method;
         break;
       }
       case TextPrimitive:
       {
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         if (*token != ',')
           GetNextToken(q,&q,extent,token);
         primitive_info[j].text=AcquireString(token);
         break;
       }
       case ImagePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         GetNextToken(q,&q,extent,token);
         primitive_info[j].text=AcquireString(token);
         break;
       }
     }
     mvg_info.offset=i;
     if (primitive_info == (PrimitiveInfo *) NULL)
       break;
     if (image->debug != MagickFalse)
       (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  %.*s",(int) (q-p),p);
     if (status == MagickFalse)
       break;
     primitive_info[i].primitive=UndefinedPrimitive;
     if (i == 0)
       continue;
     /*
       Transform points.
     */
     for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
     {
       point=primitive_info[i].point;
       primitive_info[i].point.x=graphic_context[n]->affine.sx*point.x+
         graphic_context[n]->affine.ry*point.y+graphic_context[n]->affine.tx;
       primitive_info[i].point.y=graphic_context[n]->affine.rx*point.x+
         graphic_context[n]->affine.sy*point.y+graphic_context[n]->affine.ty;
       point=primitive_info[i].point;
       if (point.x < graphic_context[n]->bounds.x1)
         graphic_context[n]->bounds.x1=point.x;
       if (point.y < graphic_context[n]->bounds.y1)
         graphic_context[n]->bounds.y1=point.y;
       if (point.x > graphic_context[n]->bounds.x2)
         graphic_context[n]->bounds.x2=point.x;
       if (point.y > graphic_context[n]->bounds.y2)
         graphic_context[n]->bounds.y2=point.y;
       if (primitive_info[i].primitive == ImagePrimitive)
         break;
       if (i >= (ssize_t) number_points)
         ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
     }
     if (graphic_context[n]->render != MagickFalse)
       {
         if ((n != 0) && (draw_info->compliance != SVGCompliance) &&
             (graphic_context[n]->clip_mask != (char *) NULL) &&
             (LocaleCompare(graphic_context[n]->clip_mask,
              graphic_context[n-1]->clip_mask) != 0))
           status&=DrawClipPath(image,graphic_context[n],
             graphic_context[n]->clip_mask,exception);
         status&=DrawPrimitive(image,graphic_context[n],primitive_info,
           exception);
       }
     if (primitive_info->text != (char *) NULL)
       primitive_info->text=(char *) RelinquishMagickMemory(
         primitive_info->text);
     proceed=SetImageProgress(image,RenderImageTag,q-primitive,(MagickSizeType)
       primitive_extent);
     if (proceed == MagickFalse)
       break;
     if (status == 0)
       break;
   }
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"end draw-image");
   /*
     Relinquish resources.
   */
   macros=DestroySplayTree(macros);
   token=DestroyString(token);
   if (primitive_info != (PrimitiveInfo *) NULL)
     primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
   primitive=DestroyString(primitive);
   if (stops != (StopInfo *) NULL)
     stops=(StopInfo *) RelinquishMagickMemory(stops);
   for ( ; n >= 0; n--)
     graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
   graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
   if (status == MagickFalse)
     ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
       keyword);
   return(status != 0 ? MagickTrue : MagickFalse);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   D r a w P a t t e r n P a t h                                             %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawPatternPath() draws a pattern.
 %
 %  The format of the DrawPatternPath method is:
 %
 %      MagickBooleanType DrawPatternPath(Image *image,const DrawInfo *draw_info,
 %        const char *name,Image **pattern,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o draw_info: the draw info.
 %
 %    o name: the pattern name.
 %
 %    o image: the image.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
@@ -5906,98 +5911,99 @@ static void TraceArcPath(MVGInfo *mvg_info,const PointInfo start,
 static void TraceBezier(MVGInfo *mvg_info,const size_t number_coordinates)
 {
   double
     alpha,
     *coefficients,
     weight;
 
   PointInfo
     end,
     point,
     *points;
 
   PrimitiveInfo
     *primitive_info;
 
   register PrimitiveInfo
     *p;
 
   register ssize_t
     i,
     j;
 
   size_t
     control_points,
     quantum;
 
   /*
     Allocate coefficients.
   */
   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   quantum=number_coordinates;
   for (i=0; i < (ssize_t) number_coordinates; i++)
   {
     for (j=i+1; j < (ssize_t) number_coordinates; j++)
     {
       alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x);
       if (alpha > (double) quantum)
         quantum=(size_t) alpha;
       alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y);
       if (alpha > (double) quantum)
         quantum=(size_t) alpha;
     }
   }
   quantum=(size_t) MagickMin((double) quantum/number_coordinates,
     (double) BezierQuantum);
   control_points=quantum*number_coordinates;
-  if (CheckPrimitiveExtent(mvg_info,control_points+1) != MagickFalse)
-    primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
+  if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse)
+    return;
+  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   coefficients=(double *) AcquireQuantumMemory((size_t)
     number_coordinates,sizeof(*coefficients));
   points=(PointInfo *) AcquireQuantumMemory((size_t) control_points,
     sizeof(*points));
   if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL))
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
   /*
     Compute bezier points.
   */
   end=primitive_info[number_coordinates-1].point;
   for (i=0; i < (ssize_t) number_coordinates; i++)
     coefficients[i]=Permutate((ssize_t) number_coordinates-1,i);
   weight=0.0;
   for (i=0; i < (ssize_t) control_points; i++)
   {
     p=primitive_info;
     point.x=0.0;
     point.y=0.0;
     alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0);
     for (j=0; j < (ssize_t) number_coordinates; j++)
     {
       point.x+=alpha*coefficients[j]*p->point.x;
       point.y+=alpha*coefficients[j]*p->point.y;
       alpha*=weight/(1.0-weight);
       p++;
     }
     points[i]=point;
     weight+=1.0/control_points;
   }
   /*
     Bezier curves are just short segmented polys.
   */
   p=primitive_info;
   for (i=0; i < (ssize_t) control_points; i++)
   {
     TracePoint(p,points[i]);
     p+=p->coordinates;
   }
   TracePoint(p,end);
   p+=p->coordinates;
   primitive_info->coordinates=(size_t) (p-primitive_info);
   primitive_info->closed_subpath=MagickFalse;
   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
   {
     p->primitive=primitive_info->primitive;
     p--;
   }
   points=(PointInfo *) RelinquishMagickMemory(points);
   coefficients=(double *) RelinquishMagickMemory(coefficients);
 }
@@ -6027,69 +6033,70 @@ static void TraceCircle(MVGInfo *mvg_info,const PointInfo start,
 static void TraceEllipse(MVGInfo *mvg_info,const PointInfo center,
   const PointInfo radii,const PointInfo arc)
 {
   double
     delta,
     step,
     x,
     y;
 
   PointInfo
     angle,
     point;
 
   PrimitiveInfo
     *primitive_info;
 
   register PrimitiveInfo
     *p;
 
   register ssize_t
     i;
 
   size_t
     extent;
 
   /*
     Ellipses are just short segmented polys.
   */
   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   primitive_info->coordinates=0;
   if ((fabs(radii.x) < DrawEpsilon) || (fabs(radii.y) < DrawEpsilon))
     return;
   delta=2.0*PerceptibleReciprocal(MagickMax(radii.x,radii.y));
   step=MagickPI/8.0;
   if ((delta >= 0.0) && (delta < (MagickPI/8.0)))
     step=MagickPI/(4.0*(MagickPI*PerceptibleReciprocal(delta)/2.0));
   angle.x=DegreesToRadians(arc.x);
   y=arc.y;
   while (y < arc.x)
     y+=360.0;
   angle.y=DegreesToRadians(y);
   extent=(size_t) ceil((angle.y-angle.x)/step)+1;
-  if (CheckPrimitiveExtent(mvg_info,extent) != MagickFalse)
-    primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
+  if (CheckPrimitiveExtent(mvg_info,extent) == MagickFalse)
+    return;
+  primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   for (p=primitive_info; angle.x < angle.y; angle.x+=step)
   {
     point.x=cos(fmod(angle.x,DegreesToRadians(360.0)))*radii.x+center.x;
     point.y=sin(fmod(angle.x,DegreesToRadians(360.0)))*radii.y+center.y;
     TracePoint(p,point);
     p+=p->coordinates;
   }
   point.x=cos(fmod(angle.y,DegreesToRadians(360.0)))*radii.x+center.x;
   point.y=sin(fmod(angle.y,DegreesToRadians(360.0)))*radii.y+center.y;
   TracePoint(p,point);
   p+=p->coordinates;
   primitive_info->coordinates=(size_t) (p-primitive_info);
   primitive_info->closed_subpath=MagickFalse;
   x=fabs(primitive_info[0].point.x-
     primitive_info[primitive_info->coordinates-1].point.x);
   y=fabs(primitive_info[0].point.y-
     primitive_info[primitive_info->coordinates-1].point.y);
   if ((x <= DrawEpsilon) && (y <= DrawEpsilon))
     primitive_info->closed_subpath=MagickTrue;
   for (i=0; i < (ssize_t) primitive_info->coordinates; i++)
   {
     p->primitive=primitive_info->primitive;
     p--;
   }
 }
@@ -6114,503 +6121,500 @@ static void TraceLine(PrimitiveInfo *primitive_info,const PointInfo start,
 static size_t TracePath(MVGInfo *mvg_info,const char *path,
   ExceptionInfo *exception)
 {
   char
     *next_token,
     token[MagickPathExtent];
 
   const char
     *p;
 
   double
     x,
     y;
 
   int
     attribute,
     last_attribute;
 
   MagickBooleanType
     status;
 
   PointInfo
     end = {0.0, 0.0},
     points[4] = { {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0} },
     point = {0.0, 0.0},
     start = {0.0, 0.0};
 
   PrimitiveInfo
     *primitive_info;
 
   PrimitiveType
     primitive_type;
 
   register PrimitiveInfo
     *q;
 
   register ssize_t
     i;
 
   size_t
     number_coordinates,
     z_count;
 
   ssize_t
     subpath_offset;
 
   subpath_offset=mvg_info->offset;
   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   status=MagickTrue;
   attribute=0;
   number_coordinates=0;
   z_count=0;
   primitive_type=primitive_info->primitive;
   q=primitive_info;
   for (p=path; *p != '\0'; )
   {
     if (status == MagickFalse)
       break;
     while (isspace((int) ((unsigned char) *p)) != 0)
       p++;
     if (*p == '\0')
       break;
     last_attribute=attribute;
     attribute=(int) (*p++);
     switch (attribute)
     {
       case 'a':
       case 'A':
       {
         double
           angle = 0.0;
 
         MagickBooleanType
           large_arc = MagickFalse,
           sweep = MagickFalse;
 
         PointInfo
           arc = {0.0, 0.0};
 
         /*
           Elliptical arc.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           arc.x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           arc.y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           angle=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           large_arc=StringToLong(token) != 0 ? MagickTrue : MagickFalse;
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
-          sweep=fabs(StringToDouble(token,&next_token)) < DrawEpsilon ?
-            MagickFalse : MagickTrue;
-          if (token == next_token)
-            ThrowPointExpectedException(token,exception);
+          sweep=StringToLong(token) != 0 ? MagickTrue : MagickFalse;
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           end.x=(double) (attribute == (int) 'A' ? x : point.x+x);
           end.y=(double) (attribute == (int) 'A' ? y : point.y+y);
           TraceArcPath(mvg_info,point,end,arc,angle,large_arc,sweep);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'c':
       case 'C':
       {
         /*
           Cubic Bézier curve.
         */
         do
         {
           points[0]=point;
           for (i=1; i < 4; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             end.x=(double) (attribute == (int) 'C' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'C' ? y : point.y+y);
             points[i]=end;
           }
           for (i=0; i < 4; i++)
             (q+i)->point=points[i];
           TraceBezier(mvg_info,4);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'H':
       case 'h':
       {
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'H' ? x: point.x+x);
-          if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
-              (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
-            q=(*mvg_info->primitive_info)+mvg_info->offset;
+          if (CheckPrimitiveExtent(mvg_info,4096) == MagickFalse)
+            return(0);
+          q=(*mvg_info->primitive_info)+mvg_info->offset;
           TracePoint(q,point);
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'l':
       case 'L':
       {
         /*
           Line to.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'L' ? x : point.x+x);
           point.y=(double) (attribute == (int) 'L' ? y : point.y+y);
-          if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
-              (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
-            q=(*mvg_info->primitive_info)+mvg_info->offset;
+          if (CheckPrimitiveExtent(mvg_info,4096) == MagickFalse)
+            return(0);
+          q=(*mvg_info->primitive_info)+mvg_info->offset;
           TracePoint(q,point);
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'M':
       case 'm':
       {
         /*
           Move to.
         */
         if (mvg_info->offset != subpath_offset)
           {
             primitive_info=(*mvg_info->primitive_info)+subpath_offset;
             primitive_info->coordinates=(size_t) (q-primitive_info);
             number_coordinates+=primitive_info->coordinates;
             primitive_info=q;
             subpath_offset=mvg_info->offset;
           }
         i=0;
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'M' ? x : point.x+x);
           point.y=(double) (attribute == (int) 'M' ? y : point.y+y);
           if (i == 0)
             start=point;
           i++;
-          if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
-              (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
-            q=(*mvg_info->primitive_info)+mvg_info->offset;
+          if (CheckPrimitiveExtent(mvg_info,4096) == MagickFalse)
+            return(0);
+          q=(*mvg_info->primitive_info)+mvg_info->offset;
           TracePoint(q,point);
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'q':
       case 'Q':
       {
         /*
           Quadratic Bézier curve.
         */
         do
         {
           points[0]=point;
           for (i=1; i < 3; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             if (*p == ',')
               p++;
             end.x=(double) (attribute == (int) 'Q' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'Q' ? y : point.y+y);
             points[i]=end;
           }
           for (i=0; i < 3; i++)
             (q+i)->point=points[i];
           TraceBezier(mvg_info,3);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 's':
       case 'S':
       {
         /*
           Cubic Bézier curve.
         */
         do
         {
           points[0]=points[3];
           points[1].x=2.0*points[3].x-points[2].x;
           points[1].y=2.0*points[3].y-points[2].y;
           for (i=2; i < 4; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             if (*p == ',')
               p++;
             end.x=(double) (attribute == (int) 'S' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'S' ? y : point.y+y);
             points[i]=end;
           }
           if (strchr("CcSs",last_attribute) == (char *) NULL)
             {
               points[0]=point;
               points[1]=point;
             }
           for (i=0; i < 4; i++)
             (q+i)->point=points[i];
           TraceBezier(mvg_info,4);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           last_attribute=attribute;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 't':
       case 'T':
       {
         /*
           Quadratic Bézier curve.
         */
         do
         {
           points[0]=points[2];
           points[1].x=2.0*points[2].x-points[1].x;
           points[1].y=2.0*points[2].y-points[1].y;
           for (i=2; i < 3; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             end.x=(double) (attribute == (int) 'T' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'T' ? y : point.y+y);
             points[i]=end;
           }
           if (status == MagickFalse)
             break;
           if (strchr("QqTt",last_attribute) == (char *) NULL)
             {
               points[0]=point;
               points[1]=point;
             }
           for (i=0; i < 3; i++)
             (q+i)->point=points[i];
           TraceBezier(mvg_info,3);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           last_attribute=attribute;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'v':
       case 'V':
       {
         /*
           Line to.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.y=(double) (attribute == (int) 'V' ? y : point.y+y);
-          if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
-              (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
-            q=(*mvg_info->primitive_info)+mvg_info->offset;
+          if (CheckPrimitiveExtent(mvg_info,4096) == MagickFalse)
+            return(0);
+          q=(*mvg_info->primitive_info)+mvg_info->offset;
           TracePoint(q,point);
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'z':
       case 'Z':
       {
         /*
           Close path.
         */
         point=start;
-        if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
-            (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
-          q=(*mvg_info->primitive_info)+mvg_info->offset;
+        if (CheckPrimitiveExtent(mvg_info,4096) == MagickFalse)
+          return(0);
+        q=(*mvg_info->primitive_info)+mvg_info->offset;
         TracePoint(q,point);
         mvg_info->offset+=q->coordinates;
         q+=q->coordinates;
         primitive_info->coordinates=(size_t) (q-primitive_info);
         primitive_info->closed_subpath=MagickTrue;
         number_coordinates+=primitive_info->coordinates;
         primitive_info=q;
         subpath_offset=mvg_info->offset;
         z_count++;
         break;
       }
       default:
       {
         ThrowPointExpectedException(token,exception);
         break;
       }
     }
   }
   if (status == MagickFalse)
     return(0);
   primitive_info=(*mvg_info->primitive_info)+subpath_offset;
   primitive_info->coordinates=(size_t) (q-primitive_info);
   number_coordinates+=primitive_info->coordinates;
   for (i=0; i < (ssize_t) number_coordinates; i++)
   {
     q--;
     q->primitive=primitive_type;
     if (z_count > 1)
       q->method=FillToBorderMethod;
   }
   q=primitive_info;
   return(number_coordinates);
 }
