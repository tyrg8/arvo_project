commit f4925bd5ebb2db38263eef0ec816bf393293cf9c
Author: Michael Tuexen <tuexen@fh-muenster.de>
Date:   Sat Oct 17 22:35:33 2020 +0200

    Improve the handling of cookie life times.
    The staleness reported in an error cause is in us, not ms.
    Enforce limits on the life time via sysct; and socket options
    consistently. Update the description of the sysctl variable to
    use the right unit. Also do some minor cleanups.
    This also fixes an interger overflow issue if the peer can
    modify the cookie. This was reported by Felix Weinrank by fuzz testing
    the userland stack and in
    https://oss-fuzz.com/testcase-detail/4800394024452096

diff --git a/usrsctplib/netinet/sctp.h b/usrsctplib/netinet/sctp.h
index 45ae1be..f0dc35a 100755
--- a/usrsctplib/netinet/sctp.h
+++ b/usrsctplib/netinet/sctp.h
@@ -34,24 +34,24 @@
 
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: head/sys/netinet/sctp.h 365071 2020-09-01 21:19:14Z mjg $");
+__FBSDID("$FreeBSD: head/sys/netinet/sctp.h 366750 2020-10-16 10:44:48Z tuexen $");
 #endif
 
 #ifndef _NETINET_SCTP_H_
 #define _NETINET_SCTP_H_
 
 #if defined(__APPLE__) || defined(__linux__)
 #include <stdint.h>
 #endif
 #include <sys/types.h>
 
 #if !defined(_WIN32)
 #define SCTP_PACKED __attribute__((packed))
 #else
 #pragma pack (push, 1)
 #define SCTP_PACKED
 #endif
 
 /*
  * SCTP protocol - RFC4960.
  */
@@ -439,227 +439,228 @@ struct sctp_error_no_user_data {
 struct sctp_error_auth_invalid_hmac {
 	struct sctp_error_cause cause;	/* code=SCTP_CAUSE_UNSUPPORTED_HMACID */
 	uint16_t hmac_id;
 } SCTP_PACKED;
 
 /*
  * Main SCTP chunk types we place these here so natd and f/w's in user land
  * can find them.
  */
 /************0x00 series ***********/
 #define SCTP_DATA		0x00
 #define SCTP_INITIATION		0x01
 #define SCTP_INITIATION_ACK	0x02
 #define SCTP_SELECTIVE_ACK	0x03
 #define SCTP_HEARTBEAT_REQUEST	0x04
 #define SCTP_HEARTBEAT_ACK	0x05
 #define SCTP_ABORT_ASSOCIATION	0x06
 #define SCTP_SHUTDOWN		0x07
 #define SCTP_SHUTDOWN_ACK	0x08
 #define SCTP_OPERATION_ERROR	0x09
 #define SCTP_COOKIE_ECHO	0x0a
 #define SCTP_COOKIE_ACK		0x0b
 #define SCTP_ECN_ECHO		0x0c
 #define SCTP_ECN_CWR		0x0d
 #define SCTP_SHUTDOWN_COMPLETE	0x0e
 /* RFC4895 */
 #define SCTP_AUTHENTICATION     0x0f
 /* EY nr_sack chunk id*/
 #define SCTP_NR_SELECTIVE_ACK	0x10
 /************0x40 series ***********/
 #define SCTP_IDATA		0x40
 /************0x80 series ***********/
 /* RFC5061 */
 #define	SCTP_ASCONF_ACK		0x80
 /* draft-ietf-stewart-pktdrpsctp */
 #define SCTP_PACKET_DROPPED	0x81
 /* draft-ietf-stewart-strreset-xxx */
 #define SCTP_STREAM_RESET       0x82
 
 /* RFC4820                         */
 #define SCTP_PAD_CHUNK          0x84
 /************0xc0 series ***********/
 /* RFC3758 */
 #define SCTP_FORWARD_CUM_TSN	0xc0
 /* RFC5061 */
 #define SCTP_ASCONF		0xc1
 #define SCTP_IFORWARD_CUM_TSN	0xc2
 
 /* ABORT and SHUTDOWN COMPLETE FLAG */
 #define SCTP_HAD_NO_TCB		0x01
 
 /* Packet dropped flags */
 #define SCTP_FROM_MIDDLE_BOX	SCTP_HAD_NO_TCB
 #define SCTP_BADCRC		0x02
 #define SCTP_PACKET_TRUNCATED	0x04
 
 /* Flag for ECN -CWR */
 #define SCTP_CWR_REDUCE_OVERRIDE 0x01
 #define SCTP_CWR_IN_SAME_WINDOW  0x02
 
 #define SCTP_SAT_NETWORK_MIN	400	/* min ms for RTT to set satellite
 					 * time */
 #define SCTP_SAT_NETWORK_BURST_INCR  2	/* how many times to multiply maxburst
 					 * in sat */
 
 /* Data Chuck Specific Flags */
 #define SCTP_DATA_FRAG_MASK        0x03
 #define SCTP_DATA_MIDDLE_FRAG      0x00
 #define SCTP_DATA_LAST_FRAG        0x01
 #define SCTP_DATA_FIRST_FRAG       0x02
 #define SCTP_DATA_NOT_FRAG         0x03
 #define SCTP_DATA_UNORDERED        0x04
 #define SCTP_DATA_SACK_IMMEDIATELY 0x08
 /* ECN Nonce: SACK Chunk Specific Flags */
 #define SCTP_SACK_NONCE_SUM        0x01
 
 /* CMT DAC algorithm SACK flag */
 #define SCTP_SACK_CMT_DAC          0x80
 
 /*
  * PCB flags (in sctp_flags bitmask).
  * Note the features and flags are meant
  * for use by netstat.
  */
 #define SCTP_PCB_FLAGS_UDPTYPE		0x00000001
 #define SCTP_PCB_FLAGS_TCPTYPE		0x00000002
 #define SCTP_PCB_FLAGS_BOUNDALL		0x00000004
 #define SCTP_PCB_FLAGS_ACCEPTING	0x00000008
 #define SCTP_PCB_FLAGS_UNBOUND		0x00000010
 #define SCTP_PCB_FLAGS_SND_ITERATOR_UP  0x00000020
 #define SCTP_PCB_FLAGS_CLOSE_IP         0x00040000
 #define SCTP_PCB_FLAGS_WAS_CONNECTED    0x00080000
 #define SCTP_PCB_FLAGS_WAS_ABORTED      0x00100000
 /* TCP model support */
 
 #define SCTP_PCB_FLAGS_CONNECTED	0x00200000
 #define SCTP_PCB_FLAGS_IN_TCPPOOL	0x00400000
 #define SCTP_PCB_FLAGS_DONT_WAKE	0x00800000
 #define SCTP_PCB_FLAGS_WAKEOUTPUT	0x01000000
 #define SCTP_PCB_FLAGS_WAKEINPUT	0x02000000
 #define SCTP_PCB_FLAGS_BOUND_V6		0x04000000
 #define SCTP_PCB_FLAGS_BLOCKING_IO	0x08000000
 #define SCTP_PCB_FLAGS_SOCKET_GONE	0x10000000
 #define SCTP_PCB_FLAGS_SOCKET_ALLGONE	0x20000000
 #define SCTP_PCB_FLAGS_SOCKET_CANT_READ	0x40000000
 #if defined(__Userspace__)
 #define SCTP_PCB_FLAGS_BOUND_CONN       0x80000000
 
 /* flags to copy to new PCB */
 #define SCTP_PCB_COPY_FLAGS		(SCTP_PCB_FLAGS_BOUNDALL|\
 					 SCTP_PCB_FLAGS_WAKEINPUT|\
 					 SCTP_PCB_FLAGS_BOUND_V6|\
 					 SCTP_PCB_FLAGS_BOUND_CONN)
 #else
 
 /* flags to copy to new PCB */
 #define SCTP_PCB_COPY_FLAGS		(SCTP_PCB_FLAGS_BOUNDALL|\
 					 SCTP_PCB_FLAGS_WAKEINPUT|\
 					 SCTP_PCB_FLAGS_BOUND_V6)
 #endif
 
 /*
  * PCB Features (in sctp_features bitmask)
  */
 #define SCTP_PCB_FLAGS_DO_NOT_PMTUD      0x0000000000000001
 #define SCTP_PCB_FLAGS_EXT_RCVINFO       0x0000000000000002 /* deprecated */
 #define SCTP_PCB_FLAGS_DONOT_HEARTBEAT   0x0000000000000004
 #define SCTP_PCB_FLAGS_FRAG_INTERLEAVE   0x0000000000000008
 #define SCTP_PCB_FLAGS_INTERLEAVE_STRMS  0x0000000000000010
 #define SCTP_PCB_FLAGS_DO_ASCONF         0x0000000000000020
 #define SCTP_PCB_FLAGS_AUTO_ASCONF       0x0000000000000040
 /* socket options */
 #define SCTP_PCB_FLAGS_NODELAY           0x0000000000000100
 #define SCTP_PCB_FLAGS_AUTOCLOSE         0x0000000000000200
 #define SCTP_PCB_FLAGS_RECVDATAIOEVNT    0x0000000000000400 /* deprecated */
 #define SCTP_PCB_FLAGS_RECVASSOCEVNT     0x0000000000000800
 #define SCTP_PCB_FLAGS_RECVPADDREVNT     0x0000000000001000
 #define SCTP_PCB_FLAGS_RECVPEERERR       0x0000000000002000
 #define SCTP_PCB_FLAGS_RECVSENDFAILEVNT  0x0000000000004000 /* deprecated */
 #define SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT  0x0000000000008000
 #define SCTP_PCB_FLAGS_ADAPTATIONEVNT    0x0000000000010000
 #define SCTP_PCB_FLAGS_PDAPIEVNT         0x0000000000020000
 #define SCTP_PCB_FLAGS_AUTHEVNT          0x0000000000040000
 #define SCTP_PCB_FLAGS_STREAM_RESETEVNT  0x0000000000080000
 #define SCTP_PCB_FLAGS_NO_FRAGMENT       0x0000000000100000
 #define SCTP_PCB_FLAGS_EXPLICIT_EOR      0x0000000000400000
 #define SCTP_PCB_FLAGS_NEEDS_MAPPED_V4   0x0000000000800000
 #define SCTP_PCB_FLAGS_MULTIPLE_ASCONFS  0x0000000001000000
 #define SCTP_PCB_FLAGS_PORTREUSE         0x0000000002000000
 #define SCTP_PCB_FLAGS_DRYEVNT           0x0000000004000000
 #define SCTP_PCB_FLAGS_RECVRCVINFO       0x0000000008000000
 #define SCTP_PCB_FLAGS_RECVNXTINFO       0x0000000010000000
 #define SCTP_PCB_FLAGS_ASSOC_RESETEVNT   0x0000000020000000
 #define SCTP_PCB_FLAGS_STREAM_CHANGEEVNT 0x0000000040000000
 #define SCTP_PCB_FLAGS_RECVNSENDFAILEVNT 0x0000000080000000
 
 /*-
  * mobility_features parameters (by micchie).Note
  * these features are applied against the
  * sctp_mobility_features flags.. not the sctp_features
  * flags.
  */
 #define SCTP_MOBILITY_BASE               0x00000001
 #define SCTP_MOBILITY_FASTHANDOFF        0x00000002
 #define SCTP_MOBILITY_PRIM_DELETED       0x00000004
 
 /* Smallest PMTU allowed when disabling PMTU discovery */
 #define SCTP_SMALLEST_PMTU 512
 /* Largest PMTU allowed when disabling PMTU discovery */
 #define SCTP_LARGEST_PMTU  65536
 
 #if defined(_WIN32)
 #pragma pack(pop)
 #endif
 #undef SCTP_PACKED
 
 #include <netinet/sctp_uio.h>
 
 /* This dictates the size of the packet
  * collection buffer. This only applies
  * if SCTP_PACKET_LOGGING is enabled in
  * your config.
  */
 #define SCTP_PACKET_LOG_SIZE 65536
 
 /* Maximum delays and such a user can set for options that
  * take ms.
  */
 #define SCTP_MAX_SACK_DELAY 500 /* per RFC4960 */
 #define SCTP_MAX_HB_INTERVAL 14400000 /* 4 hours in ms */
+#define SCTP_MIN_COOKIE_LIFE     1000 /* 1 second in ms */
 #define SCTP_MAX_COOKIE_LIFE  3600000 /* 1 hour in ms */
 
 /* Types of logging/KTR tracing  that can be enabled via the
  * sysctl net.inet.sctp.sctp_logging. You must also enable
  * SUBSYS tracing.
  * Note that you must have the SCTP option in the kernel
  * to enable these as well.
  */
 #define SCTP_BLK_LOGGING_ENABLE				0x00000001
 #define SCTP_CWND_MONITOR_ENABLE			0x00000002
 #define SCTP_CWND_LOGGING_ENABLE			0x00000004
 #define SCTP_FLIGHT_LOGGING_ENABLE			0x00000020
 #define SCTP_FR_LOGGING_ENABLE				0x00000040
 #define SCTP_LOCK_LOGGING_ENABLE			0x00000080
 #define SCTP_MAP_LOGGING_ENABLE				0x00000100
 #define SCTP_MBCNT_LOGGING_ENABLE			0x00000200
 #define SCTP_MBUF_LOGGING_ENABLE			0x00000400
 #define SCTP_NAGLE_LOGGING_ENABLE			0x00000800
 #define SCTP_RECV_RWND_LOGGING_ENABLE			0x00001000
 #define SCTP_RTTVAR_LOGGING_ENABLE			0x00002000
 #define SCTP_SACK_LOGGING_ENABLE			0x00004000
 #define SCTP_SACK_RWND_LOGGING_ENABLE			0x00008000
 #define SCTP_SB_LOGGING_ENABLE				0x00010000
 #define SCTP_STR_LOGGING_ENABLE				0x00020000
 #define SCTP_WAKE_LOGGING_ENABLE			0x00040000
 #define SCTP_LOG_MAXBURST_ENABLE			0x00080000
 #define SCTP_LOG_RWND_ENABLE    			0x00100000
 #define SCTP_LOG_SACK_ARRIVALS_ENABLE			0x00200000
 #define SCTP_LTRACE_CHUNK_ENABLE			0x00400000
 #define SCTP_LTRACE_ERROR_ENABLE			0x00800000
 #define SCTP_LAST_PACKET_TRACING			0x01000000
 #define SCTP_THRESHOLD_LOGGING				0x02000000
 #define SCTP_LOG_AT_SEND_2_SCTP				0x04000000
 #define SCTP_LOG_AT_SEND_2_OUTQ				0x08000000
 #define SCTP_LOG_TRY_ADVANCE				0x10000000
 
 #endif				/* !_NETINET_SCTP_H_ */
diff --git a/usrsctplib/netinet/sctp_input.c b/usrsctplib/netinet/sctp_input.c
index 582ad0b..90e3449 100755
--- a/usrsctplib/netinet/sctp_input.c
+++ b/usrsctplib/netinet/sctp_input.c
@@ -34,31 +34,31 @@
 
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: head/sys/netinet/sctp_input.c 366489 2020-10-06 14:26:05Z tuexen $");
+__FBSDID("$FreeBSD: head/sys/netinet/sctp_input.c 366750 2020-10-16 10:44:48Z tuexen $");
 #endif
 
 #include <netinet/sctp_os.h>
 #include <netinet/sctp_var.h>
 #include <netinet/sctp_sysctl.h>
 #include <netinet/sctp_pcb.h>
 #include <netinet/sctp_header.h>
 #include <netinet/sctputil.h>
 #include <netinet/sctp_output.h>
 #include <netinet/sctp_input.h>
 #include <netinet/sctp_auth.h>
 #include <netinet/sctp_indata.h>
 #include <netinet/sctp_asconf.h>
 #include <netinet/sctp_bsd_addr.h>
 #include <netinet/sctp_timer.h>
 #include <netinet/sctp_crc32.h>
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <netinet/sctp_kdtrace.h>
 #endif
 #if defined(INET) || defined(INET6)
 #if !defined(_WIN32)
 #include <netinet/udp.h>
 #endif
 #endif
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <sys/smp.h>
 #endif
@@ -1226,178 +1226,175 @@ static int
 sctp_handle_error(struct sctp_chunkhdr *ch,
                   struct sctp_tcb *stcb, struct sctp_nets *net, uint32_t limit)
 {
 	struct sctp_error_cause *cause;
 	struct sctp_association *asoc;
 	uint32_t remaining_length, adjust;
 	uint16_t code, cause_code, cause_length;
 #if defined(__APPLE__) && !defined(__Userspace__)
 	struct socket *so;
 #endif
 
 	/* parse through all of the errors and process */
 	asoc = &stcb->asoc;
 	cause = (struct sctp_error_cause *)((caddr_t)ch +
 	    sizeof(struct sctp_chunkhdr));
 	remaining_length = ntohs(ch->chunk_length);
 	if (remaining_length > limit) {
 		remaining_length = limit;
 	}
 	if (remaining_length >= sizeof(struct sctp_chunkhdr)) {
 		remaining_length -= sizeof(struct sctp_chunkhdr);
 	} else {
 		remaining_length = 0;
 	}
 	code = 0;
 	while (remaining_length >= sizeof(struct sctp_error_cause)) {
 		/* Process an Error Cause */
 		cause_code = ntohs(cause->code);
 		cause_length = ntohs(cause->length);
 		if ((cause_length > remaining_length) || (cause_length == 0)) {
 			/* Invalid cause length, possibly due to truncation. */
 			SCTPDBG(SCTP_DEBUG_INPUT1, "Bogus length in cause - bytes left: %u cause length: %u\n",
 				remaining_length, cause_length);
 			return (0);
 		}
 		if (code == 0) {
 			/* report the first error cause */
 			code = cause_code;
 		}
 		switch (cause_code) {
 		case SCTP_CAUSE_INVALID_STREAM:
 		case SCTP_CAUSE_MISSING_PARAM:
 		case SCTP_CAUSE_INVALID_PARAM:
 		case SCTP_CAUSE_NO_USER_DATA:
 			SCTPDBG(SCTP_DEBUG_INPUT1, "Software error we got a %u back? We have a bug :/ (or do they?)\n",
 				cause_code);
 			break;
 		case SCTP_CAUSE_NAT_COLLIDING_STATE:
 			SCTPDBG(SCTP_DEBUG_INPUT2, "Received Colliding state, ERROR flags: %x\n",
 				ch->chunk_flags);
 			if (sctp_handle_nat_colliding_state(stcb)) {
 				return (0);
 			}
 			break;
 		case SCTP_CAUSE_NAT_MISSING_STATE:
 			SCTPDBG(SCTP_DEBUG_INPUT2, "Received missing state, ERROR flags: %x\n",
 			                           ch->chunk_flags);
 			if (sctp_handle_nat_missing_state(stcb, net)) {
 				return (0);
 			}
 			break;
 		case SCTP_CAUSE_STALE_COOKIE:
 			/*
 			 * We only act if we have echoed a cookie and are
 			 * waiting.
 			 */
 			if ((cause_length >= sizeof(struct sctp_error_stale_cookie)) &&
 			    (SCTP_GET_STATE(stcb) == SCTP_STATE_COOKIE_ECHOED)) {
 				struct sctp_error_stale_cookie *stale_cookie;
 
 				stale_cookie = (struct sctp_error_stale_cookie *)cause;
-				asoc->cookie_preserve_req = ntohl(stale_cookie->stale_time);
-				/* Double it to be more robust on RTX */
-				if (asoc->cookie_preserve_req <= UINT32_MAX / 2) {
-					asoc->cookie_preserve_req *= 2;
-				} else {
-					asoc->cookie_preserve_req = UINT32_MAX;
-				}
+				/* stable_time is in usec, convert to msec. */
+				asoc->cookie_preserve_req = ntohl(stale_cookie->stale_time) / 1000;
+				/* Double it to be more robust on RTX. */
+				asoc->cookie_preserve_req *= 2;
 				asoc->stale_cookie_count++;
 				if (asoc->stale_cookie_count >
 				    asoc->max_init_times) {
 					sctp_abort_notification(stcb, 0, 0, NULL, SCTP_SO_NOT_LOCKED);
 					/* now free the asoc */
 #if defined(__APPLE__) && !defined(__Userspace__)
 					so = SCTP_INP_SO(stcb->sctp_ep);
 					atomic_add_int(&stcb->asoc.refcnt, 1);
 					SCTP_TCB_UNLOCK(stcb);
 					SCTP_SOCKET_LOCK(so, 1);
 					SCTP_TCB_LOCK(stcb);
 					atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 					(void)sctp_free_assoc(stcb->sctp_ep, stcb, SCTP_NORMAL_PROC,
 							      SCTP_FROM_SCTP_INPUT + SCTP_LOC_12);
 #if defined(__APPLE__) && !defined(__Userspace__)
 					SCTP_SOCKET_UNLOCK(so, 1);
 #endif
 					return (-1);
 				}
 				/* blast back to INIT state */
 				sctp_toss_old_cookies(stcb, &stcb->asoc);
 				SCTP_SET_STATE(stcb, SCTP_STATE_COOKIE_WAIT);
 				sctp_stop_all_cookie_timers(stcb);
 				sctp_send_initiate(stcb->sctp_ep, stcb, SCTP_SO_NOT_LOCKED);
 			}
 			break;
 		case SCTP_CAUSE_UNRESOLVABLE_ADDR:
 			/*
 			 * Nothing we can do here, we don't do hostname
 			 * addresses so if the peer does not like my IPv6
 			 * (or IPv4 for that matter) it does not matter. If
 			 * they don't support that type of address, they can
 			 * NOT possibly get that packet type... i.e. with no
 			 * IPv6 you can't receive a IPv6 packet. so we can
 			 * safely ignore this one. If we ever added support
 			 * for HOSTNAME Addresses, then we would need to do
 			 * something here.
 			 */
 			break;
 		case SCTP_CAUSE_UNRECOG_CHUNK:
 			if (cause_length >= sizeof(struct sctp_error_unrecognized_chunk)) {
 				struct sctp_error_unrecognized_chunk *unrec_chunk;
 
 				unrec_chunk = (struct sctp_error_unrecognized_chunk *)cause;
 				sctp_process_unrecog_chunk(stcb, unrec_chunk->ch.chunk_type);
 			}
 			break;
 		case SCTP_CAUSE_UNRECOG_PARAM:
 			/* XXX: We only consider the first parameter */
 			if (cause_length >= sizeof(struct sctp_error_cause) + sizeof(struct sctp_paramhdr)) {
 				struct sctp_paramhdr *unrec_parameter;
 
 				unrec_parameter = (struct sctp_paramhdr *)(cause + 1);
 				sctp_process_unrecog_param(stcb, ntohs(unrec_parameter->param_type));
 			}
 			break;
 		case SCTP_CAUSE_COOKIE_IN_SHUTDOWN:
 			/*
 			 * We ignore this since the timer will drive out a
 			 * new cookie anyway and there timer will drive us
 			 * to send a SHUTDOWN_COMPLETE. We can't send one
 			 * here since we don't have their tag.
 			 */
 			break;
 		case SCTP_CAUSE_DELETING_LAST_ADDR:
 		case SCTP_CAUSE_RESOURCE_SHORTAGE:
 		case SCTP_CAUSE_DELETING_SRC_ADDR:
 			/*
 			 * We should NOT get these here, but in a
 			 * ASCONF-ACK.
 			 */
 			SCTPDBG(SCTP_DEBUG_INPUT2, "Peer sends ASCONF errors in a error cause with code %u.\n",
 				cause_code);
 			break;
 		case SCTP_CAUSE_OUT_OF_RESC:
 			/*
 			 * And what, pray tell do we do with the fact that
 			 * the peer is out of resources? Not really sure we
 			 * could do anything but abort. I suspect this
 			 * should have came WITH an abort instead of in a
 			 * OP-ERROR.
 			 */
 			break;
 		default:
 			SCTPDBG(SCTP_DEBUG_INPUT1, "sctp_handle_error: unknown code 0x%x\n",
 				cause_code);
 			break;
 		}
 		adjust = SCTP_SIZE32(cause_length);
 		if (remaining_length >= adjust) {
 			remaining_length -= adjust;
 		} else {
 			remaining_length = 0;
 		}
 		cause = (struct sctp_error_cause *)((caddr_t)cause + adjust);
 	}
 	sctp_ulp_notify(SCTP_NOTIFY_REMOTE_ERROR, stcb, code, ch, SCTP_SO_NOT_LOCKED);
 	return (0);
 }
@@ -2544,578 +2541,598 @@ static struct mbuf *
 sctp_handle_cookie_echo(struct mbuf *m, int iphlen, int offset,
     struct sockaddr *src, struct sockaddr *dst,
     struct sctphdr *sh, struct sctp_cookie_echo_chunk *cp,
     struct sctp_inpcb **inp_p, struct sctp_tcb **stcb, struct sctp_nets **netp,
     int auth_skipped, uint32_t auth_offset, uint32_t auth_len,
     struct sctp_tcb **locked_tcb,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
     uint8_t mflowtype, uint32_t mflowid,
 #endif
     uint32_t vrf_id, uint16_t port)
 {
 	struct sctp_state_cookie *cookie;
 	struct sctp_tcb *l_stcb = *stcb;
 	struct sctp_inpcb *l_inp;
 	struct sockaddr *to;
 	struct sctp_pcb *ep;
 	struct mbuf *m_sig;
 	uint8_t calc_sig[SCTP_SIGNATURE_SIZE], tmp_sig[SCTP_SIGNATURE_SIZE];
 	uint8_t *sig;
 #if defined(__Userspace__) && defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)
 	uint8_t cookie_ok = 1;
 #else
 	uint8_t cookie_ok = 0;
 #endif
 	unsigned int sig_offset, cookie_offset;
 	unsigned int cookie_len;
 	struct timeval now;
-	struct timeval time_expires;
+	struct timeval time_entered, time_expires;
 	int notification = 0;
 	struct sctp_nets *netl;
 	int had_a_existing_tcb = 0;
 	int send_int_conf = 0;
 #ifdef INET
 	struct sockaddr_in sin;
 #endif
 #ifdef INET6
 	struct sockaddr_in6 sin6;
 #endif
 #if defined(__Userspace__)
 	struct sockaddr_conn sconn;
 #endif
 
 	SCTPDBG(SCTP_DEBUG_INPUT2,
 		"sctp_handle_cookie: handling COOKIE-ECHO\n");
 
 	if (inp_p == NULL) {
 		return (NULL);
 	}
 	cookie = &cp->cookie;
 	cookie_offset = offset + sizeof(struct sctp_chunkhdr);
 	cookie_len = ntohs(cp->ch.chunk_length);
 
 	if (cookie_len < sizeof(struct sctp_cookie_echo_chunk) +
 	    sizeof(struct sctp_init_chunk) +
 	    sizeof(struct sctp_init_ack_chunk) + SCTP_SIGNATURE_SIZE) {
 		/* cookie too small */
 		return (NULL);
 	}
 	if ((cookie->peerport != sh->src_port) ||
 	    (cookie->myport != sh->dest_port) ||
 	    (cookie->my_vtag != sh->v_tag)) {
 		/*
 		 * invalid ports or bad tag.  Note that we always leave the
 		 * v_tag in the header in network order and when we stored
 		 * it in the my_vtag slot we also left it in network order.
 		 * This maintains the match even though it may be in the
 		 * opposite byte order of the machine :->
 		 */
 		return (NULL);
 	}
 #if defined(__Userspace__)
 	/*
 	 * Recover the AF_CONN addresses within the cookie.
 	 * This needs to be done in the buffer provided for later processing
 	 * of the cookie and in the mbuf chain for HMAC validation.
 	 */
 	if ((cookie->addr_type == SCTP_CONN_ADDRESS) && (src->sa_family == AF_CONN)) {
 		struct sockaddr_conn *sconnp = (struct sockaddr_conn *)src;
 
 		memcpy(cookie->address, &sconnp->sconn_addr , sizeof(void *));
 		m_copyback(m, cookie_offset + offsetof(struct sctp_state_cookie, address),
 		           (int)sizeof(void *), (caddr_t)&sconnp->sconn_addr);
 	}
 	if ((cookie->laddr_type == SCTP_CONN_ADDRESS) && (dst->sa_family == AF_CONN)) {
 		struct sockaddr_conn *sconnp = (struct sockaddr_conn *)dst;
 
 		memcpy(cookie->laddress, &sconnp->sconn_addr , sizeof(void *));
 		m_copyback(m, cookie_offset + offsetof(struct sctp_state_cookie, laddress),
 		           (int)sizeof(void *), (caddr_t)&sconnp->sconn_addr);
 	}
 #endif
 	/*
 	 * split off the signature into its own mbuf (since it should not be
 	 * calculated in the sctp_hmac_m() call).
 	 */
 	sig_offset = offset + cookie_len - SCTP_SIGNATURE_SIZE;
 	m_sig = m_split(m, sig_offset, M_NOWAIT);
 	if (m_sig == NULL) {
 		/* out of memory or ?? */
 		return (NULL);
 	}
 #ifdef SCTP_MBUF_LOGGING
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 		sctp_log_mbc(m_sig, SCTP_MBUF_SPLIT);
 	}
 #endif
 
 	/*
 	 * compute the signature/digest for the cookie
 	 */
 	ep = &(*inp_p)->sctp_ep;
 	l_inp = *inp_p;
 	if (l_stcb) {
 		SCTP_TCB_UNLOCK(l_stcb);
 	}
 	SCTP_INP_RLOCK(l_inp);
 	if (l_stcb) {
 		SCTP_TCB_LOCK(l_stcb);
 	}
 	/* which cookie is it? */
 	if ((cookie->time_entered.tv_sec < (long)ep->time_of_secret_change) &&
 	    (ep->current_secret_number != ep->last_secret_number)) {
 		/* it's the old cookie */
 		(void)sctp_hmac_m(SCTP_HMAC,
 		    (uint8_t *)ep->secret_key[(int)ep->last_secret_number],
 		    SCTP_SECRET_SIZE, m, cookie_offset, calc_sig, 0);
 	} else {
 		/* it's the current cookie */
 		(void)sctp_hmac_m(SCTP_HMAC,
 		    (uint8_t *)ep->secret_key[(int)ep->current_secret_number],
 		    SCTP_SECRET_SIZE, m, cookie_offset, calc_sig, 0);
 	}
 	/* get the signature */
 	SCTP_INP_RUNLOCK(l_inp);
 	sig = (uint8_t *) sctp_m_getptr(m_sig, 0, SCTP_SIGNATURE_SIZE, (uint8_t *) & tmp_sig);
 	if (sig == NULL) {
 		/* couldn't find signature */
 		sctp_m_freem(m_sig);
 		return (NULL);
 	}
 	/* compare the received digest with the computed digest */
 	if (timingsafe_bcmp(calc_sig, sig, SCTP_SIGNATURE_SIZE) != 0) {
 		/* try the old cookie? */
 		if ((cookie->time_entered.tv_sec == (long)ep->time_of_secret_change) &&
 		    (ep->current_secret_number != ep->last_secret_number)) {
 			/* compute digest with old */
 			(void)sctp_hmac_m(SCTP_HMAC,
 			    (uint8_t *)ep->secret_key[(int)ep->last_secret_number],
 			    SCTP_SECRET_SIZE, m, cookie_offset, calc_sig, 0);
 			/* compare */
 			if (timingsafe_bcmp(calc_sig, sig, SCTP_SIGNATURE_SIZE) == 0)
 				cookie_ok = 1;
 		}
 	} else {
 		cookie_ok = 1;
 	}
 
 	/*
 	 * Now before we continue we must reconstruct our mbuf so that
 	 * normal processing of any other chunks will work.
 	 */
 	{
 		struct mbuf *m_at;
 
 		m_at = m;
 		while (SCTP_BUF_NEXT(m_at) != NULL) {
 			m_at = SCTP_BUF_NEXT(m_at);
 		}
 		SCTP_BUF_NEXT(m_at) = m_sig;
 	}
 
 	if (cookie_ok == 0) {
 		SCTPDBG(SCTP_DEBUG_INPUT2, "handle_cookie_echo: cookie signature validation failed!\n");
 		SCTPDBG(SCTP_DEBUG_INPUT2,
 			"offset = %u, cookie_offset = %u, sig_offset = %u\n",
 			(uint32_t) offset, cookie_offset, sig_offset);
 		return (NULL);
 	}
 
+	if (sctp_ticks_to_msecs(cookie->cookie_life) > SCTP_MAX_COOKIE_LIFE) {
+		SCTPDBG(SCTP_DEBUG_INPUT2, "handle_cookie_echo: Invalid cookie lifetime\n");
+		return (NULL);
+	}
+	time_entered.tv_sec = cookie->time_entered.tv_sec;
+	time_entered.tv_usec = cookie->time_entered.tv_usec;
+	if ((time_entered.tv_sec < 0) ||
+	    (time_entered.tv_usec < 0) ||
+	    (time_entered.tv_usec >= 1000000)) {
+		/* Invalid time stamp. Cookie must have been modified. */
+		SCTPDBG(SCTP_DEBUG_INPUT2, "handle_cookie_echo: Invalid time stamp\n");
+		return (NULL);
+	}
+	(void)SCTP_GETTIME_TIMEVAL(&now);
+#if !(defined(__FreeBSD__) && !defined(__Userspace__))
+	if (timercmp(&now, &time_entered, <)) {
+#else
+	if (timevalcmp(&now, &time_entered, <)) {
+#endif
+		SCTPDBG(SCTP_DEBUG_INPUT2, "handle_cookie_echo: cookie generated in the future!\n");
+		return (NULL);
+	}
 	/*
-	 * check the cookie timestamps to be sure it's not stale
+	 * Check the cookie timestamps to be sure it's not stale.
+	 * cookie_life is in ticks, so we convert to seconds.
 	 */
-	(void)SCTP_GETTIME_TIMEVAL(&now);
-	/* Expire time is in Ticks, so we convert to seconds */
-	time_expires.tv_sec = cookie->time_entered.tv_sec + sctp_ticks_to_secs(cookie->cookie_life);
-	time_expires.tv_usec = cookie->time_entered.tv_usec;
+	time_expires.tv_sec = time_entered.tv_sec + sctp_ticks_to_secs(cookie->cookie_life);
+	time_expires.tv_usec = time_entered.tv_usec;
 #if !(defined(__FreeBSD__) && !defined(__Userspace__))
 	if (timercmp(&now, &time_expires, >))
 #else
 	if (timevalcmp(&now, &time_expires, >))
 #endif
 	{
 		/* cookie is stale! */
 		struct mbuf *op_err;
 		struct sctp_error_stale_cookie *cause;
 		struct timeval diff;
 		uint32_t staleness;
 
 		op_err = sctp_get_mbuf_for_msg(sizeof(struct sctp_error_stale_cookie),
 		                               0, M_NOWAIT, 1, MT_DATA);
 		if (op_err == NULL) {
 			/* FOOBAR */
 			return (NULL);
 		}
 		/* Set the len */
 		SCTP_BUF_LEN(op_err) = sizeof(struct sctp_error_stale_cookie);
 		cause = mtod(op_err, struct sctp_error_stale_cookie *);
 		cause->cause.code = htons(SCTP_CAUSE_STALE_COOKIE);
-		cause->cause.length = htons((sizeof(struct sctp_paramhdr) +
-		    (sizeof(uint32_t))));
+		cause->cause.length = htons(sizeof(struct sctp_error_stale_cookie));
 #if !(defined(__FreeBSD__) && !defined(__Userspace__))
 		timersub(&now, &time_expires, &diff);
 #else
 		diff = now;
 		timevalsub(&diff, &time_expires);
 #endif
 		if ((uint32_t)diff.tv_sec > UINT32_MAX / 1000000) {
 			staleness = UINT32_MAX;
 		} else {
 			staleness = diff.tv_sec * 1000000;
 		}
 		if (UINT32_MAX - staleness >= (uint32_t)diff.tv_usec) {
 			staleness += diff.tv_usec;
 		} else {
 			staleness = UINT32_MAX;
 		}
 		cause->stale_time = htonl(staleness);
 		sctp_send_operr_to(src, dst, sh, cookie->peers_vtag, op_err,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 		                   mflowtype, mflowid, l_inp->fibnum,
 #endif
 		                   vrf_id, port);
 		return (NULL);
 	}
 	/*
 	 * Now we must see with the lookup address if we have an existing
 	 * asoc. This will only happen if we were in the COOKIE-WAIT state
 	 * and a INIT collided with us and somewhere the peer sent the
 	 * cookie on another address besides the single address our assoc
 	 * had for him. In this case we will have one of the tie-tags set at
 	 * least AND the address field in the cookie can be used to look it
 	 * up.
 	 */
 	to = NULL;
 	switch (cookie->addr_type) {
 #ifdef INET6
 	case SCTP_IPV6_ADDRESS:
 		memset(&sin6, 0, sizeof(sin6));
 		sin6.sin6_family = AF_INET6;
 #ifdef HAVE_SIN6_LEN
 		sin6.sin6_len = sizeof(sin6);
 #endif
 		sin6.sin6_port = sh->src_port;
 		sin6.sin6_scope_id = cookie->scope_id;
 		memcpy(&sin6.sin6_addr.s6_addr, cookie->address,
 		    sizeof(sin6.sin6_addr.s6_addr));
 		to = (struct sockaddr *)&sin6;
 		break;
 #endif
 #ifdef INET
 	case SCTP_IPV4_ADDRESS:
 		memset(&sin, 0, sizeof(sin));
 		sin.sin_family = AF_INET;
 #ifdef HAVE_SIN_LEN
 		sin.sin_len = sizeof(sin);
 #endif
 		sin.sin_port = sh->src_port;
 		sin.sin_addr.s_addr = cookie->address[0];
 		to = (struct sockaddr *)&sin;
 		break;
 #endif
 #if defined(__Userspace__)
 	case SCTP_CONN_ADDRESS:
 		memset(&sconn, 0, sizeof(struct sockaddr_conn));
 		sconn.sconn_family = AF_CONN;
 #ifdef HAVE_SCONN_LEN
 		sconn.sconn_len = sizeof(struct sockaddr_conn);
 #endif
 		sconn.sconn_port = sh->src_port;
 		memcpy(&sconn.sconn_addr, cookie->address, sizeof(void *));
 		to = (struct sockaddr *)&sconn;
 		break;
 #endif
 	default:
 		/* This should not happen */
 		return (NULL);
 	}
 	if (*stcb == NULL) {
 		/* Yep, lets check */
 		*stcb = sctp_findassociation_ep_addr(inp_p, to, netp, dst, NULL);
 		if (*stcb == NULL) {
 			/*
 			 * We should have only got back the same inp. If we
 			 * got back a different ep we have a problem. The
 			 * original findep got back l_inp and now
 			 */
 			if (l_inp != *inp_p) {
 				SCTP_PRINTF("Bad problem find_ep got a diff inp then special_locate?\n");
 			}
 		} else {
 			if (*locked_tcb == NULL) {
 				/* In this case we found the assoc only
 				 * after we locked the create lock. This means
 				 * we are in a colliding case and we must make
 				 * sure that we unlock the tcb if its one of the
 				 * cases where we throw away the incoming packets.
 				 */
 				*locked_tcb = *stcb;
 
 				/* We must also increment the inp ref count
 				 * since the ref_count flags was set when we
 				 * did not find the TCB, now we found it which
 				 * reduces the refcount.. we must raise it back
 				 * out to balance it all :-)
 				 */
 				SCTP_INP_INCR_REF((*stcb)->sctp_ep);
 				if ((*stcb)->sctp_ep != l_inp) {
 					SCTP_PRINTF("Huh? ep:%p diff then l_inp:%p?\n",
 						    (void *)(*stcb)->sctp_ep, (void *)l_inp);
 				}
 			}
 		}
 	}
 
 	cookie_len -= SCTP_SIGNATURE_SIZE;
 	if (*stcb == NULL) {
 		/* this is the "normal" case... get a new TCB */
 		*stcb = sctp_process_cookie_new(m, iphlen, offset, src, dst, sh,
 		                                cookie, cookie_len, *inp_p,
 		                                netp, to, &notification,
 		                                auth_skipped, auth_offset, auth_len,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 		                                mflowtype, mflowid,
 #endif
 		                                vrf_id, port);
 	} else {
 		/* this is abnormal... cookie-echo on existing TCB */
 		had_a_existing_tcb = 1;
 		*stcb = sctp_process_cookie_existing(m, iphlen, offset,
 		                                     src, dst, sh,
 						     cookie, cookie_len, *inp_p, *stcb, netp, to,
 						     &notification, auth_skipped, auth_offset, auth_len,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 		                                     mflowtype, mflowid,
 #endif
 		                                     vrf_id, port);
 	}
 
 	if (*stcb == NULL) {
 		/* still no TCB... must be bad cookie-echo */
 		return (NULL);
 	}
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 	if (*netp != NULL) {
 		(*netp)->flowtype = mflowtype;
 		(*netp)->flowid = mflowid;
 	}
 #endif
 	/*
 	 * Ok, we built an association so confirm the address we sent the
 	 * INIT-ACK to.
 	 */
 	netl = sctp_findnet(*stcb, to);
 	/*
 	 * This code should in theory NOT run but
 	 */
 	if (netl == NULL) {
 		/* TSNH! Huh, why do I need to add this address here? */
 		if (sctp_add_remote_addr(*stcb, to, NULL, port,
 		                         SCTP_DONOT_SETSCOPE, SCTP_IN_COOKIE_PROC)) {
 			return (NULL);
 		}
 		netl = sctp_findnet(*stcb, to);
 	}
 	if (netl) {
 		if (netl->dest_state & SCTP_ADDR_UNCONFIRMED) {
 			netl->dest_state &= ~SCTP_ADDR_UNCONFIRMED;
 			(void)sctp_set_primary_addr((*stcb), (struct sockaddr *)NULL,
 			    netl);
 			send_int_conf = 1;
 		}
 	}
 	sctp_start_net_timers(*stcb);
 	if ((*inp_p)->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) {
 		if (!had_a_existing_tcb ||
 		    (((*inp_p)->sctp_flags & SCTP_PCB_FLAGS_CONNECTED) == 0)) {
 			/*
 			 * If we have a NEW cookie or the connect never
 			 * reached the connected state during collision we
 			 * must do the TCP accept thing.
 			 */
 			struct socket *so, *oso;
 			struct sctp_inpcb *inp;
 
 			if (notification == SCTP_NOTIFY_ASSOC_RESTART) {
 				/*
 				 * For a restart we will keep the same
 				 * socket, no need to do anything. I THINK!!
 				 */
 				sctp_ulp_notify(notification, *stcb, 0, NULL, SCTP_SO_NOT_LOCKED);
 				if (send_int_conf) {
 					sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_CONFIRMED,
 					                (*stcb), 0, (void *)netl, SCTP_SO_NOT_LOCKED);
 				}
 				return (m);
 			}
 			oso = (*inp_p)->sctp_socket;
 			atomic_add_int(&(*stcb)->asoc.refcnt, 1);
 			SCTP_TCB_UNLOCK((*stcb));
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			CURVNET_SET(oso->so_vnet);
 #endif
 #if defined(__APPLE__) && !defined(__Userspace__)
 			SCTP_SOCKET_LOCK(oso, 1);
 #endif
 			so = sonewconn(oso, 0
 #if defined(__APPLE__) && !defined(__Userspace__)
 			    ,NULL
 #endif
 			    );
 #if defined(__APPLE__) && !defined(__Userspace__)
 			SCTP_SOCKET_UNLOCK(oso, 1);
 #endif
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			CURVNET_RESTORE();
 #endif
 			SCTP_TCB_LOCK((*stcb));
 			atomic_subtract_int(&(*stcb)->asoc.refcnt, 1);
 
 			if (so == NULL) {
 				struct mbuf *op_err;
 #if defined(__APPLE__) && !defined(__Userspace__)
 				struct socket *pcb_so;
 #endif
 				/* Too many sockets */
 				SCTPDBG(SCTP_DEBUG_INPUT1, "process_cookie_new: no room for another socket!\n");
 				op_err = sctp_generate_cause(SCTP_CAUSE_OUT_OF_RESC, "");
 				sctp_abort_association(*inp_p, NULL, m, iphlen,
 						       src, dst, sh, op_err,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 				                       mflowtype, mflowid,
 #endif
 				                       vrf_id, port);
 #if defined(__APPLE__) && !defined(__Userspace__)
 				pcb_so = SCTP_INP_SO(*inp_p);
 				atomic_add_int(&(*stcb)->asoc.refcnt, 1);
 				SCTP_TCB_UNLOCK((*stcb));
 				SCTP_SOCKET_LOCK(pcb_so, 1);
 				SCTP_TCB_LOCK((*stcb));
 				atomic_subtract_int(&(*stcb)->asoc.refcnt, 1);
 #endif
 				(void)sctp_free_assoc(*inp_p, *stcb, SCTP_NORMAL_PROC,
 				                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_23);
 #if defined(__APPLE__) && !defined(__Userspace__)
 				SCTP_SOCKET_UNLOCK(pcb_so, 1);
 #endif
 				return (NULL);
 			}
 			inp = (struct sctp_inpcb *)so->so_pcb;
 			SCTP_INP_INCR_REF(inp);
 			/*
 			 * We add the unbound flag here so that
 			 * if we get an soabort() before we get the
 			 * move_pcb done, we will properly cleanup.
 			 */
 			inp->sctp_flags = (SCTP_PCB_FLAGS_TCPTYPE |
 			    SCTP_PCB_FLAGS_CONNECTED |
 			    SCTP_PCB_FLAGS_IN_TCPPOOL |
 			    SCTP_PCB_FLAGS_UNBOUND |
 			    (SCTP_PCB_COPY_FLAGS & (*inp_p)->sctp_flags) |
 			    SCTP_PCB_FLAGS_DONT_WAKE);
 			inp->sctp_features = (*inp_p)->sctp_features;
 			inp->sctp_mobility_features = (*inp_p)->sctp_mobility_features;
 			inp->sctp_socket = so;
 			inp->sctp_frag_point = (*inp_p)->sctp_frag_point;
 			inp->max_cwnd = (*inp_p)->max_cwnd;
 			inp->sctp_cmt_on_off = (*inp_p)->sctp_cmt_on_off;
 			inp->ecn_supported = (*inp_p)->ecn_supported;
 			inp->prsctp_supported = (*inp_p)->prsctp_supported;
 			inp->auth_supported = (*inp_p)->auth_supported;
 			inp->asconf_supported = (*inp_p)->asconf_supported;
 			inp->reconfig_supported = (*inp_p)->reconfig_supported;
 			inp->nrsack_supported = (*inp_p)->nrsack_supported;
 			inp->pktdrop_supported = (*inp_p)->pktdrop_supported;
 			inp->partial_delivery_point = (*inp_p)->partial_delivery_point;
 			inp->sctp_context = (*inp_p)->sctp_context;
 			inp->local_strreset_support = (*inp_p)->local_strreset_support;
 			inp->fibnum = (*inp_p)->fibnum;
 			inp->inp_starting_point_for_iterator = NULL;
 #if defined(__Userspace__)
 			inp->ulp_info = (*inp_p)->ulp_info;
 			inp->recv_callback = (*inp_p)->recv_callback;
 			inp->send_callback = (*inp_p)->send_callback;
 			inp->send_sb_threshold = (*inp_p)->send_sb_threshold;
 #endif
 			/*
 			 * copy in the authentication parameters from the
 			 * original endpoint
 			 */
 			if (inp->sctp_ep.local_hmacs)
 				sctp_free_hmaclist(inp->sctp_ep.local_hmacs);
 			inp->sctp_ep.local_hmacs =
 			    sctp_copy_hmaclist((*inp_p)->sctp_ep.local_hmacs);
 			if (inp->sctp_ep.local_auth_chunks)
 				sctp_free_chunklist(inp->sctp_ep.local_auth_chunks);
 			inp->sctp_ep.local_auth_chunks =
 			    sctp_copy_chunklist((*inp_p)->sctp_ep.local_auth_chunks);
 
 			/*
 			 * Now we must move it from one hash table to
 			 * another and get the tcb in the right place.
 			 */
 
 			/* This is where the one-2-one socket is put into
 			 * the accept state waiting for the accept!
 			 */
 			if (*stcb) {
 				SCTP_ADD_SUBSTATE(*stcb, SCTP_STATE_IN_ACCEPT_QUEUE);
 			}
 			sctp_move_pcb_and_assoc(*inp_p, inp, *stcb);
 
 			atomic_add_int(&(*stcb)->asoc.refcnt, 1);
 			SCTP_TCB_UNLOCK((*stcb));
 
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			sctp_pull_off_control_to_new_inp((*inp_p), inp, *stcb,
 			    0);
 #else
 			sctp_pull_off_control_to_new_inp((*inp_p), inp, *stcb, M_NOWAIT);
 #endif
 			SCTP_TCB_LOCK((*stcb));
 			atomic_subtract_int(&(*stcb)->asoc.refcnt, 1);
 
 			/* now we must check to see if we were aborted while
 			 * the move was going on and the lock/unlock happened.
 			 */
 			if (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {
 				/* yep it was, we leave the
 				 * assoc attached to the socket since
 				 * the sctp_inpcb_free() call will send
 				 * an abort for us.
 				 */
 				SCTP_INP_DECR_REF(inp);
 				return (NULL);
 			}
 			SCTP_INP_DECR_REF(inp);
 			/* Switch over to the new guy */
 			*inp_p = inp;
 			sctp_ulp_notify(notification, *stcb, 0, NULL, SCTP_SO_NOT_LOCKED);
 			if (send_int_conf) {
 				sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_CONFIRMED,
 				                (*stcb), 0, (void *)netl, SCTP_SO_NOT_LOCKED);
 			}
 
 			/* Pull it from the incomplete queue and wake the guy */
 #if defined(__APPLE__) && !defined(__Userspace__)
 			atomic_add_int(&(*stcb)->asoc.refcnt, 1);
 			SCTP_TCB_UNLOCK((*stcb));
 			SCTP_SOCKET_LOCK(so, 1);
 #endif
 			soisconnected(so);
 #if defined(__APPLE__) && !defined(__Userspace__)
 			SCTP_TCB_LOCK((*stcb));
 			atomic_subtract_int(&(*stcb)->asoc.refcnt, 1);
 			SCTP_SOCKET_UNLOCK(so, 1);
 #endif
 			return (m);
 		}
 	}
 	if (notification) {
 		sctp_ulp_notify(notification, *stcb, 0, NULL, SCTP_SO_NOT_LOCKED);
 	}
 	if (send_int_conf) {
 		sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_CONFIRMED,
 		                (*stcb), 0, (void *)netl, SCTP_SO_NOT_LOCKED);
 	}
 	return (m);
 }
@@ -4708,1013 +4725,1013 @@ static struct sctp_tcb *
 sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
     struct sockaddr *src, struct sockaddr *dst,
     struct sctphdr *sh, struct sctp_chunkhdr *ch, struct sctp_inpcb *inp,
     struct sctp_tcb *stcb, struct sctp_nets **netp, int *fwd_tsn_seen,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
     uint8_t mflowtype, uint32_t mflowid, uint16_t fibnum,
 #endif
     uint32_t vrf_id, uint16_t port)
 {
 	struct sctp_association *asoc;
 	struct mbuf *op_err;
 	char msg[SCTP_DIAG_INFO_LEN];
 	uint32_t vtag_in;
 	int num_chunks = 0;	/* number of control chunks processed */
 	uint32_t chk_length, contiguous;
 	int ret;
 	int abort_no_unlock = 0;
 	int ecne_seen = 0;
 	/*
 	 * How big should this be, and should it be alloc'd? Lets try the
 	 * d-mtu-ceiling for now (2k) and that should hopefully work ...
 	 * until we get into jumbo grams and such..
 	 */
 	uint8_t chunk_buf[SCTP_CHUNK_BUFFER_SIZE];
 	int got_auth = 0;
 	uint32_t auth_offset = 0, auth_len = 0;
 	int auth_skipped = 0;
 	int asconf_cnt = 0;
 #if defined(__APPLE__) && !defined(__Userspace__)
 	struct socket *so;
 #endif
 
 	SCTPDBG(SCTP_DEBUG_INPUT1, "sctp_process_control: iphlen=%u, offset=%u, length=%u stcb:%p\n",
 		iphlen, *offset, length, (void *)stcb);
 
 	if (stcb) {
 		SCTP_TCB_LOCK_ASSERT(stcb);
 	}
 	/* validate chunk header length... */
 	if (ntohs(ch->chunk_length) < sizeof(*ch)) {
 		SCTPDBG(SCTP_DEBUG_INPUT1, "Invalid header length %d\n",
 			ntohs(ch->chunk_length));
 		*offset = length;
 		return (stcb);
 	}
 	/*
 	 * validate the verification tag
 	 */
 	vtag_in = ntohl(sh->v_tag);
 
 	if (ch->chunk_type == SCTP_INITIATION) {
 		SCTPDBG(SCTP_DEBUG_INPUT1, "Its an INIT of len:%d vtag:%x\n",
 			ntohs(ch->chunk_length), vtag_in);
 		if (vtag_in != 0) {
 			/* protocol error- silently discard... */
 			SCTP_STAT_INCR(sctps_badvtag);
 			if (stcb != NULL) {
 				SCTP_TCB_UNLOCK(stcb);
 			}
 			return (NULL);
 		}
 	} else if (ch->chunk_type != SCTP_COOKIE_ECHO) {
 		/*
 		 * If there is no stcb, skip the AUTH chunk and process
 		 * later after a stcb is found (to validate the lookup was
 		 * valid.
 		 */
 		if ((ch->chunk_type == SCTP_AUTHENTICATION) &&
 		    (stcb == NULL) &&
 		    (inp->auth_supported == 1)) {
 			/* save this chunk for later processing */
 			auth_skipped = 1;
 			auth_offset = *offset;
 			auth_len = ntohs(ch->chunk_length);
 
 			/* (temporarily) move past this chunk */
 			*offset += SCTP_SIZE32(auth_len);
 			if (*offset >= length) {
 				/* no more data left in the mbuf chain */
 				*offset = length;
 				return (NULL);
 			}
 			ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 								   sizeof(struct sctp_chunkhdr), chunk_buf);
 		}
 		if (ch == NULL) {
 			/* Help */
 			*offset = length;
 			return (stcb);
 		}
 		if (ch->chunk_type == SCTP_COOKIE_ECHO) {
 			goto process_control_chunks;
 		}
 		/*
 		 * first check if it's an ASCONF with an unknown src addr we
 		 * need to look inside to find the association
 		 */
 		if (ch->chunk_type == SCTP_ASCONF && stcb == NULL) {
 			struct sctp_chunkhdr *asconf_ch = ch;
 			uint32_t asconf_offset = 0, asconf_len = 0;
 
 			/* inp's refcount may be reduced */
 			SCTP_INP_INCR_REF(inp);
 
 			asconf_offset = *offset;
 			do {
 				asconf_len = ntohs(asconf_ch->chunk_length);
 				if (asconf_len < sizeof(struct sctp_asconf_paramhdr))
 					break;
 				stcb = sctp_findassociation_ep_asconf(m,
 				                                      *offset,
 				                                      dst,
 				                                      sh, &inp, netp, vrf_id);
 				if (stcb != NULL)
 					break;
 				asconf_offset += SCTP_SIZE32(asconf_len);
 				asconf_ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, asconf_offset,
 										  sizeof(struct sctp_chunkhdr), chunk_buf);
 			} while (asconf_ch != NULL && asconf_ch->chunk_type == SCTP_ASCONF);
 			if (stcb == NULL) {
 				/*
 				 * reduce inp's refcount if not reduced in
 				 * sctp_findassociation_ep_asconf().
 				 */
 				SCTP_INP_DECR_REF(inp);
 			}
 
 			/* now go back and verify any auth chunk to be sure */
 			if (auth_skipped && (stcb != NULL)) {
 				struct sctp_auth_chunk *auth;
 
 				if (auth_len <= SCTP_CHUNK_BUFFER_SIZE) {
 					auth = (struct sctp_auth_chunk *)sctp_m_getptr(m, auth_offset, auth_len, chunk_buf);
 					got_auth = 1;
 					auth_skipped = 0;
 				} else {
 					auth = NULL;
 				}
 				if ((auth == NULL) || sctp_handle_auth(stcb, auth, m,
 								       auth_offset)) {
 					/* auth HMAC failed so dump it */
 					*offset = length;
 					return (stcb);
 				} else {
 					/* remaining chunks are HMAC checked */
 					stcb->asoc.authenticated = 1;
 				}
 			}
 		}
 		if (stcb == NULL) {
 			SCTP_SNPRINTF(msg, sizeof(msg), "OOTB, %s:%d at %s", __FILE__, __LINE__, __func__);
 			op_err = sctp_generate_cause(SCTP_BASE_SYSCTL(sctp_diag_info_code),
 			                             msg);
 			/* no association, so it's out of the blue... */
 			sctp_handle_ootb(m, iphlen, *offset, src, dst, sh, inp, op_err,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			                 mflowtype, mflowid, inp->fibnum,
 #endif
 					 vrf_id, port);
 			*offset = length;
 			return (NULL);
 		}
 		asoc = &stcb->asoc;
 		/* ABORT and SHUTDOWN can use either v_tag... */
 		if ((ch->chunk_type == SCTP_ABORT_ASSOCIATION) ||
 		    (ch->chunk_type == SCTP_SHUTDOWN_COMPLETE) ||
 		    (ch->chunk_type == SCTP_PACKET_DROPPED)) {
 			/* Take the T-bit always into account. */
 			if ((((ch->chunk_flags & SCTP_HAD_NO_TCB) == 0) &&
 			     (vtag_in == asoc->my_vtag)) ||
 			    (((ch->chunk_flags & SCTP_HAD_NO_TCB) == SCTP_HAD_NO_TCB) &&
 			     (asoc->peer_vtag != htonl(0)) &&
 			     (vtag_in == asoc->peer_vtag))) {
 				/* this is valid */
 			} else {
 				/* drop this packet... */
 				SCTP_STAT_INCR(sctps_badvtag);
 				if (stcb != NULL) {
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				return (NULL);
 			}
 		} else if (ch->chunk_type == SCTP_SHUTDOWN_ACK) {
 			if (vtag_in != asoc->my_vtag) {
 				/*
 				 * this could be a stale SHUTDOWN-ACK or the
 				 * peer never got the SHUTDOWN-COMPLETE and
 				 * is still hung; we have started a new asoc
 				 * but it won't complete until the shutdown
 				 * is completed
 				 */
 				if (stcb != NULL) {
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_SNPRINTF(msg, sizeof(msg), "OOTB, %s:%d at %s", __FILE__, __LINE__, __func__);
 				op_err = sctp_generate_cause(SCTP_BASE_SYSCTL(sctp_diag_info_code),
 				                             msg);
 				sctp_handle_ootb(m, iphlen, *offset, src, dst,
 				                 sh, inp, op_err,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 				                 mflowtype, mflowid, fibnum,
 #endif
 				                 vrf_id, port);
 				return (NULL);
 			}
 		} else {
 			/* for all other chunks, vtag must match */
 			if (vtag_in != asoc->my_vtag) {
 				/* invalid vtag... */
 				SCTPDBG(SCTP_DEBUG_INPUT3,
 					"invalid vtag: %xh, expect %xh\n",
 					vtag_in, asoc->my_vtag);
 				SCTP_STAT_INCR(sctps_badvtag);
 				if (stcb != NULL) {
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				*offset = length;
 				return (NULL);
 			}
 		}
 	}			/* end if !SCTP_COOKIE_ECHO */
 	/*
 	 * process all control chunks...
 	 */
 	if (((ch->chunk_type == SCTP_SELECTIVE_ACK) ||
 	     (ch->chunk_type == SCTP_NR_SELECTIVE_ACK) ||
 	     (ch->chunk_type == SCTP_HEARTBEAT_REQUEST)) &&
 	    (SCTP_GET_STATE(stcb) == SCTP_STATE_COOKIE_ECHOED)) {
 		/* implied cookie-ack.. we must have lost the ack */
 		sctp_handle_cookie_ack((struct sctp_cookie_ack_chunk *)ch, stcb,
 				       *netp);
 	}
 
  process_control_chunks:
 	while (IS_SCTP_CONTROL(ch)) {
 		/* validate chunk length */
 		chk_length = ntohs(ch->chunk_length);
 		SCTPDBG(SCTP_DEBUG_INPUT2, "sctp_process_control: processing a chunk type=%u, len=%u\n",
 			ch->chunk_type, chk_length);
 		SCTP_LTRACE_CHK(inp, stcb, ch->chunk_type, chk_length);
 		if (chk_length < sizeof(*ch) ||
 		    (*offset + (int)chk_length) > length) {
 			*offset = length;
 			return (stcb);
 		}
 		SCTP_STAT_INCR_COUNTER64(sctps_incontrolchunks);
 		/*
 		 * INIT and INIT-ACK only gets the init ack "header" portion
 		 * only because we don't have to process the peer's COOKIE.
 		 * All others get a complete chunk.
 		 */
 		switch (ch->chunk_type) {
 		case SCTP_INITIATION:
 			contiguous = sizeof(struct sctp_init_chunk);
 			break;
 		case SCTP_INITIATION_ACK:
 			contiguous = sizeof(struct sctp_init_ack_chunk);
 			break;
 		default:
 			contiguous = min(chk_length, sizeof(chunk_buf));
 			break;
 		}
 		ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 		                                           contiguous,
 		                                           chunk_buf);
 		if (ch == NULL) {
 			*offset = length;
 			if (stcb != NULL) {
 				SCTP_TCB_UNLOCK(stcb);
 			}
 			return (NULL);
 		}
 
 		num_chunks++;
 		/* Save off the last place we got a control from */
 		if (stcb != NULL) {
 			if (((netp != NULL) && (*netp != NULL)) || (ch->chunk_type == SCTP_ASCONF)) {
 				/*
 				 * allow last_control to be NULL if
 				 * ASCONF... ASCONF processing will find the
 				 * right net later
 				 */
 				if ((netp != NULL) && (*netp != NULL))
 					stcb->asoc.last_control_chunk_from = *netp;
 			}
 		}
 #ifdef SCTP_AUDITING_ENABLED
 		sctp_audit_log(0xB0, ch->chunk_type);
 #endif
 
 		/* check to see if this chunk required auth, but isn't */
 		if ((stcb != NULL) &&
 		    sctp_auth_is_required_chunk(ch->chunk_type, stcb->asoc.local_auth_chunks) &&
 		    !stcb->asoc.authenticated) {
 			/* "silently" ignore */
 			SCTP_STAT_INCR(sctps_recvauthmissing);
 			goto next_chunk;
 		}
 		switch (ch->chunk_type) {
 		case SCTP_INITIATION:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_INIT\n");
 			/* The INIT chunk must be the only chunk. */
 			if ((num_chunks > 1) ||
 			    (length - *offset > (int)SCTP_SIZE32(chk_length))) {
 				/* RFC 4960 requires that no ABORT is sent */
 				*offset = length;
 				if (stcb != NULL) {
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				return (NULL);
 			}
 			/* Honor our resource limit. */
 			if (chk_length > SCTP_LARGEST_INIT_ACCEPTED) {
 				op_err = sctp_generate_cause(SCTP_CAUSE_OUT_OF_RESC, "");
 				sctp_abort_association(inp, stcb, m, iphlen,
 						       src, dst, sh, op_err,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 				                       mflowtype, mflowid,
 #endif
 				                       vrf_id, port);
 				*offset = length;
 				return (NULL);
 			}
 			sctp_handle_init(m, iphlen, *offset, src, dst, sh,
 			                 (struct sctp_init_chunk *)ch, inp,
 			                 stcb, *netp, &abort_no_unlock,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			                 mflowtype, mflowid,
 #endif
 			                 vrf_id, port);
 			*offset = length;
 			if ((!abort_no_unlock) && (stcb != NULL)) {
 				SCTP_TCB_UNLOCK(stcb);
 			}
 			return (NULL);
 			break;
 		case SCTP_PAD_CHUNK:
 			break;
 		case SCTP_INITIATION_ACK:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_INIT_ACK\n");
 			if (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {
 				/* We are not interested anymore */
 				if ((stcb != NULL) && (stcb->asoc.total_output_queue_size)) {
 					;
 				} else {
 					*offset = length;
 					if (stcb != NULL) {
 #if defined(__APPLE__) && !defined(__Userspace__)
 						so = SCTP_INP_SO(inp);
 						atomic_add_int(&stcb->asoc.refcnt, 1);
 						SCTP_TCB_UNLOCK(stcb);
 						SCTP_SOCKET_LOCK(so, 1);
 						SCTP_TCB_LOCK(stcb);
 						atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 						(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
 						                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_29);
 #if defined(__APPLE__) && !defined(__Userspace__)
 						SCTP_SOCKET_UNLOCK(so, 1);
 #endif
 					}
 					return (NULL);
 				}
 			}
 			/* The INIT-ACK chunk must be the only chunk. */
 			if ((num_chunks > 1) ||
 			    (length - *offset > (int)SCTP_SIZE32(chk_length))) {
 				*offset = length;
 				return (stcb);
 			}
 			if ((netp != NULL) && (*netp != NULL)) {
 				ret = sctp_handle_init_ack(m, iphlen, *offset,
 				                           src, dst, sh,
 				                           (struct sctp_init_ack_chunk *)ch,
 				                           stcb, *netp,
 				                           &abort_no_unlock,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 				                           mflowtype, mflowid,
 #endif
 				                           vrf_id);
 			} else {
 				ret = -1;
 			}
 			*offset = length;
 			if (abort_no_unlock) {
 				return (NULL);
 			}
 			/*
 			 * Special case, I must call the output routine to
 			 * get the cookie echoed
 			 */
 			if ((stcb != NULL) && (ret == 0)) {
 				sctp_chunk_output(stcb->sctp_ep, stcb, SCTP_OUTPUT_FROM_CONTROL_PROC, SCTP_SO_NOT_LOCKED);
 			}
 			return (stcb);
 			break;
 		case SCTP_SELECTIVE_ACK:
 		case SCTP_NR_SELECTIVE_ACK:
 		{
 			int abort_now = 0;
 			uint32_t a_rwnd, cum_ack;
 			uint16_t num_seg, num_nr_seg, num_dup;
 			uint8_t flags;
 			int offset_seg, offset_dup;
 
 			SCTPDBG(SCTP_DEBUG_INPUT3, "%s\n",
 				ch->chunk_type == SCTP_SELECTIVE_ACK ? "SCTP_SACK" : "SCTP_NR_SACK");
 			SCTP_STAT_INCR(sctps_recvsacks);
 			if (stcb == NULL) {
 				SCTPDBG(SCTP_DEBUG_INDATA1, "No stcb when processing %s chunk\n",
 				        (ch->chunk_type == SCTP_SELECTIVE_ACK) ? "SCTP_SACK" : "SCTP_NR_SACK");
 				break;
 			}
 			if (ch->chunk_type == SCTP_SELECTIVE_ACK) {
 				if (chk_length < sizeof(struct sctp_sack_chunk)) {
 					SCTPDBG(SCTP_DEBUG_INDATA1, "Bad size on SACK chunk, too small\n");
 					break;
 				}
 			} else {
 				if (stcb->asoc.nrsack_supported == 0) {
 					goto unknown_chunk;
 				}
 				if (chk_length < sizeof(struct sctp_nr_sack_chunk)) {
 					SCTPDBG(SCTP_DEBUG_INDATA1, "Bad size on NR_SACK chunk, too small\n");
 					break;
 				}
 			}
 			if (SCTP_GET_STATE(stcb) == SCTP_STATE_SHUTDOWN_ACK_SENT) {
 				/*-
 				 * If we have sent a shutdown-ack, we will pay no
 				 * attention to a sack sent in to us since
 				 * we don't care anymore.
 				 */
 				break;
 			}
 			flags = ch->chunk_flags;
 			if (ch->chunk_type == SCTP_SELECTIVE_ACK) {
 				struct sctp_sack_chunk *sack;
 
 				sack = (struct sctp_sack_chunk *)ch;
 				cum_ack = ntohl(sack->sack.cum_tsn_ack);
 				num_seg = ntohs(sack->sack.num_gap_ack_blks);
 				num_nr_seg = 0;
 				num_dup = ntohs(sack->sack.num_dup_tsns);
 				a_rwnd = ntohl(sack->sack.a_rwnd);
 				if (sizeof(struct sctp_sack_chunk) +
 				    num_seg * sizeof(struct sctp_gap_ack_block) +
 				    num_dup * sizeof(uint32_t) != chk_length) {
 					SCTPDBG(SCTP_DEBUG_INDATA1, "Bad size of SACK chunk\n");
 					break;
 				}
 				offset_seg = *offset + sizeof(struct sctp_sack_chunk);
 				offset_dup = offset_seg + num_seg * sizeof(struct sctp_gap_ack_block);
 			} else {
 				struct sctp_nr_sack_chunk *nr_sack;
 
 				nr_sack = (struct sctp_nr_sack_chunk *)ch;
 				cum_ack = ntohl(nr_sack->nr_sack.cum_tsn_ack);
 				num_seg = ntohs(nr_sack->nr_sack.num_gap_ack_blks);
 				num_nr_seg = ntohs(nr_sack->nr_sack.num_nr_gap_ack_blks);
 				num_dup = ntohs(nr_sack->nr_sack.num_dup_tsns);
 				a_rwnd = ntohl(nr_sack->nr_sack.a_rwnd);
 				if (sizeof(struct sctp_nr_sack_chunk) +
 				    (num_seg + num_nr_seg) * sizeof(struct sctp_gap_ack_block) +
 				    num_dup * sizeof(uint32_t) != chk_length) {
 					SCTPDBG(SCTP_DEBUG_INDATA1, "Bad size of NR_SACK chunk\n");
 					break;
 				}
 				offset_seg = *offset + sizeof(struct sctp_nr_sack_chunk);
 				offset_dup = offset_seg + (num_seg + num_nr_seg) * sizeof(struct sctp_gap_ack_block);
 			}
 			SCTPDBG(SCTP_DEBUG_INPUT3, "%s process cum_ack:%x num_seg:%d a_rwnd:%d\n",
 				(ch->chunk_type == SCTP_SELECTIVE_ACK) ? "SCTP_SACK" : "SCTP_NR_SACK",
 			        cum_ack, num_seg, a_rwnd);
 			stcb->asoc.seen_a_sack_this_pkt = 1;
 			if ((stcb->asoc.pr_sctp_cnt == 0) &&
 			    (num_seg == 0) && (num_nr_seg == 0) &&
 			    SCTP_TSN_GE(cum_ack, stcb->asoc.last_acked_seq) &&
 			    (stcb->asoc.saw_sack_with_frags == 0) &&
 			    (stcb->asoc.saw_sack_with_nr_frags == 0) &&
 			    (!TAILQ_EMPTY(&stcb->asoc.sent_queue))) {
 				/*
 				 * We have a SIMPLE sack having no
 				 * prior segments and data on sent
 				 * queue to be acked. Use the
 				 * faster path sack processing. We
 				 * also allow window update sacks
 				 * with no missing segments to go
 				 * this way too.
 				 */
 				sctp_express_handle_sack(stcb, cum_ack, a_rwnd,
 				                         &abort_now, ecne_seen);
 			} else {
 				if ((netp != NULL) && (*netp != NULL)) {
 					sctp_handle_sack(m, offset_seg, offset_dup, stcb,
 					                 num_seg, num_nr_seg, num_dup, &abort_now, flags,
 					                 cum_ack, a_rwnd, ecne_seen);
 				}
 			}
 			if (abort_now) {
 				/* ABORT signal from sack processing */
 				*offset = length;
 				return (NULL);
 			}
 			if (TAILQ_EMPTY(&stcb->asoc.send_queue) &&
 			    TAILQ_EMPTY(&stcb->asoc.sent_queue) &&
 			    (stcb->asoc.stream_queue_cnt == 0)) {
 				sctp_ulp_notify(SCTP_NOTIFY_SENDER_DRY, stcb,  0, NULL, SCTP_SO_NOT_LOCKED);
 			}
 			break;
 		}
 		case SCTP_HEARTBEAT_REQUEST:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_HEARTBEAT\n");
 			if ((stcb != NULL) && (netp != NULL) && (*netp != NULL)) {
 				SCTP_STAT_INCR(sctps_recvheartbeat);
 				sctp_send_heartbeat_ack(stcb, m, *offset,
 							chk_length, *netp);
 			}
 			break;
 		case SCTP_HEARTBEAT_ACK:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_HEARTBEAT_ACK\n");
 			if ((stcb == NULL) || (chk_length != sizeof(struct sctp_heartbeat_chunk))) {
 				/* Its not ours */
 				*offset = length;
 				return (stcb);
 			}
 			SCTP_STAT_INCR(sctps_recvheartbeatack);
 			if ((netp != NULL) && (*netp != NULL)) {
 				sctp_handle_heartbeat_ack((struct sctp_heartbeat_chunk *)ch,
 							  stcb, *netp);
 			}
 			break;
 		case SCTP_ABORT_ASSOCIATION:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_ABORT, stcb %p\n",
 				(void *)stcb);
 			*offset = length;
 			if ((stcb != NULL) && (netp != NULL) && (*netp != NULL)) {
 				if (sctp_handle_abort((struct sctp_abort_chunk *)ch, stcb, *netp)) {
 					return (NULL);
 				} else {
 					return (stcb);
 				}
 			} else {
 				return (NULL);
 			}
 			break;
 		case SCTP_SHUTDOWN:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_SHUTDOWN, stcb %p\n",
 				(void *)stcb);
 			if ((stcb == NULL) || (chk_length != sizeof(struct sctp_shutdown_chunk))) {
 				*offset = length;
 				return (stcb);
 			}
 			if ((netp != NULL) && (*netp != NULL)) {
 				int abort_flag = 0;
 
 				sctp_handle_shutdown((struct sctp_shutdown_chunk *)ch,
 						     stcb, *netp, &abort_flag);
 				if (abort_flag) {
 					*offset = length;
 					return (NULL);
 				}
 			}
 			break;
 		case SCTP_SHUTDOWN_ACK:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_SHUTDOWN_ACK, stcb %p\n", (void *)stcb);
 			if ((stcb != NULL) && (netp != NULL) && (*netp != NULL)) {
 				sctp_handle_shutdown_ack((struct sctp_shutdown_ack_chunk *)ch, stcb, *netp);
 			}
 			*offset = length;
 			return (NULL);
 			break;
 		case SCTP_OPERATION_ERROR:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_OP_ERR\n");
 			if ((stcb != NULL) && (netp != NULL) && (*netp != NULL) &&
 			    sctp_handle_error(ch, stcb, *netp, contiguous) < 0) {
 				*offset = length;
 				return (NULL);
 			}
 			break;
 		case SCTP_COOKIE_ECHO:
 			SCTPDBG(SCTP_DEBUG_INPUT3,
 				"SCTP_COOKIE_ECHO, stcb %p\n", (void *)stcb);
 			if ((stcb != NULL) && (stcb->asoc.total_output_queue_size > 0)) {
 				;
 			} else {
 				if (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {
 					/* We are not interested anymore */
 				abend:
 					if (stcb != NULL) {
 						SCTP_TCB_UNLOCK(stcb);
 					}
 					*offset = length;
 					return (NULL);
 				}
 			}
 			/*-
 			 * First are we accepting? We do this again here
 			 * since it is possible that a previous endpoint WAS
 			 * listening responded to a INIT-ACK and then
 			 * closed. We opened and bound.. and are now no
 			 * longer listening.
 			 *
 			 * XXXGL: notes on checking listen queue length.
 			 * 1) SCTP_IS_LISTENING() doesn't necessarily mean
 			 *    SOLISTENING(), because a listening "UDP type"
 			 *    socket isn't listening in terms of the socket
 			 *    layer.  It is a normal data flow socket, that
 			 *    can fork off new connections.  Thus, we should
 			 *    look into sol_qlen only in case we are !UDP.
 			 * 2) Checking sol_qlen in general requires locking
 			 *    the socket, and this code lacks that.
 			 */
 			if ((stcb == NULL) &&
 			    (!SCTP_IS_LISTENING(inp) ||
 			     (!(inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			      inp->sctp_socket->sol_qlen >= inp->sctp_socket->sol_qlimit))) {
 #else
 			      inp->sctp_socket->so_qlen >= inp->sctp_socket->so_qlimit))) {
 #endif
 				if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) &&
 				    (SCTP_BASE_SYSCTL(sctp_abort_if_one_2_one_hits_limit))) {
 					op_err = sctp_generate_cause(SCTP_CAUSE_OUT_OF_RESC, "");
 					sctp_abort_association(inp, stcb, m, iphlen,
 					                       src, dst, sh, op_err,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 					                       mflowtype, mflowid,
 #endif
 					                       vrf_id, port);
 				}
 				*offset = length;
 				return (NULL);
 			} else {
 				struct mbuf *ret_buf;
 				struct sctp_inpcb *linp;
 				struct sctp_tmit_chunk *chk;
 
 				if (stcb) {
 					linp = NULL;
 				} else {
 					linp = inp;
 				}
 
 				if (linp != NULL) {
 					SCTP_ASOC_CREATE_LOCK(linp);
 					if ((inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) ||
 					    (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE)) {
 						SCTP_ASOC_CREATE_UNLOCK(linp);
 						goto abend;
 					}
 				}
 
 				if (netp != NULL) {
 					struct sctp_tcb *locked_stcb;
 
 					locked_stcb = stcb;
 					ret_buf =
 						sctp_handle_cookie_echo(m, iphlen,
 						                        *offset,
 						                        src, dst,
 						                        sh,
 						                        (struct sctp_cookie_echo_chunk *)ch,
 						                        &inp, &stcb, netp,
 						                        auth_skipped,
 						                        auth_offset,
 						                        auth_len,
 						                        &locked_stcb,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 						                        mflowtype,
 						                        mflowid,
 #endif
 						                        vrf_id,
 						                        port);
 					if ((locked_stcb != NULL) && (locked_stcb != stcb)) {
 						SCTP_TCB_UNLOCK(locked_stcb);
 					}
 					if (stcb != NULL) {
 						SCTP_TCB_LOCK_ASSERT(stcb);
 					}
 				} else {
 					ret_buf = NULL;
 				}
 				if (linp != NULL) {
 					SCTP_ASOC_CREATE_UNLOCK(linp);
 				}
 				if (ret_buf == NULL) {
 					if (stcb != NULL) {
 						SCTP_TCB_UNLOCK(stcb);
 					}
 					SCTPDBG(SCTP_DEBUG_INPUT3,
 						"GAK, null buffer\n");
 					*offset = length;
 					return (NULL);
 				}
 				/* if AUTH skipped, see if it verified... */
 				if (auth_skipped) {
 					got_auth = 1;
 					auth_skipped = 0;
 				}
 				/* Restart the timer if we have pending data */
 				TAILQ_FOREACH(chk, &stcb->asoc.sent_queue, sctp_next) {
 					if (chk->whoTo != NULL) {
 						break;
 					}
 				}
 				if (chk != NULL) {
 					sctp_timer_start(SCTP_TIMER_TYPE_SEND, stcb->sctp_ep, stcb, chk->whoTo);
 				}
 			}
 			break;
 		case SCTP_COOKIE_ACK:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_COOKIE_ACK, stcb %p\n", (void *)stcb);
 			if ((stcb == NULL) || chk_length != sizeof(struct sctp_cookie_ack_chunk)) {
 				return (stcb);
 			}
 			if (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {
 				/* We are not interested anymore */
 				if ((stcb) && (stcb->asoc.total_output_queue_size)) {
 					;
 				} else if (stcb) {
 #if defined(__APPLE__) && !defined(__Userspace__)
 					so = SCTP_INP_SO(inp);
 					atomic_add_int(&stcb->asoc.refcnt, 1);
 					SCTP_TCB_UNLOCK(stcb);
 					SCTP_SOCKET_LOCK(so, 1);
 					SCTP_TCB_LOCK(stcb);
 					atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 					(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
 					                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_30);
 #if defined(__APPLE__) && !defined(__Userspace__)
 					SCTP_SOCKET_UNLOCK(so, 1);
 #endif
 					*offset = length;
 					return (NULL);
 				}
 			}
 			if ((netp != NULL) && (*netp != NULL)) {
 				sctp_handle_cookie_ack((struct sctp_cookie_ack_chunk *)ch, stcb, *netp);
 			}
 			break;
 		case SCTP_ECN_ECHO:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_ECN_ECHO\n");
 			if ((stcb == NULL) || (chk_length != sizeof(struct sctp_ecne_chunk))) {
 				/* Its not ours */
 				*offset = length;
 				return (stcb);
 			}
 			if (stcb->asoc.ecn_supported == 0) {
 				goto unknown_chunk;
 			}
 			sctp_handle_ecn_echo((struct sctp_ecne_chunk *)ch, stcb);
 			ecne_seen = 1;
 			break;
 		case SCTP_ECN_CWR:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_ECN_CWR\n");
 			if ((stcb == NULL) || (chk_length != sizeof(struct sctp_cwr_chunk))) {
 				*offset = length;
 				return (stcb);
 			}
 			if (stcb->asoc.ecn_supported == 0) {
 				goto unknown_chunk;
 			}
 			sctp_handle_ecn_cwr((struct sctp_cwr_chunk *)ch, stcb, *netp);
 			break;
 		case SCTP_SHUTDOWN_COMPLETE:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_SHUTDOWN_COMPLETE, stcb %p\n", (void *)stcb);
 			/* must be first and only chunk */
 			if ((num_chunks > 1) ||
 			    (length - *offset > (int)SCTP_SIZE32(chk_length))) {
 				*offset = length;
 				return (stcb);
 			}
 			if ((stcb != NULL) && (netp != NULL) && (*netp != NULL)) {
 				sctp_handle_shutdown_complete((struct sctp_shutdown_complete_chunk *)ch,
 							      stcb, *netp);
 			}
 			*offset = length;
 			return (NULL);
 			break;
 		case SCTP_ASCONF:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_ASCONF\n");
 			if (stcb != NULL) {
 				if (stcb->asoc.asconf_supported == 0) {
 					goto unknown_chunk;
 				}
 				sctp_handle_asconf(m, *offset, src,
 						   (struct sctp_asconf_chunk *)ch, stcb, asconf_cnt == 0);
 				asconf_cnt++;
 			}
 			break;
 		case SCTP_ASCONF_ACK:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_ASCONF_ACK\n");
 			if (chk_length < sizeof(struct sctp_asconf_ack_chunk)) {
 				/* Its not ours */
 				*offset = length;
 				return (stcb);
 			}
 			if ((stcb != NULL) && (netp != NULL) && (*netp != NULL)) {
 				if (stcb->asoc.asconf_supported == 0) {
 					goto unknown_chunk;
 				}
 				/* He's alive so give him credit */
 				if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_THRESHOLD_LOGGING) {
 					sctp_misc_ints(SCTP_THRESHOLD_CLEAR,
 						       stcb->asoc.overall_error_count,
 						       0,
 						       SCTP_FROM_SCTP_INPUT,
 						       __LINE__);
 				}
 				stcb->asoc.overall_error_count = 0;
 				sctp_handle_asconf_ack(m, *offset,
 						       (struct sctp_asconf_ack_chunk *)ch, stcb, *netp, &abort_no_unlock);
 				if (abort_no_unlock)
 					return (NULL);
 			}
 			break;
 		case SCTP_FORWARD_CUM_TSN:
 		case SCTP_IFORWARD_CUM_TSN:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "%s\n",
 				ch->chunk_type == SCTP_FORWARD_CUM_TSN ? "FORWARD_TSN" : "I_FORWARD_TSN");
 			if (chk_length < sizeof(struct sctp_forward_tsn_chunk)) {
 				/* Its not ours */
 				*offset = length;
 				return (stcb);
 			}
 
 			if (stcb != NULL) {
 				int abort_flag = 0;
 
 				if (stcb->asoc.prsctp_supported == 0) {
 					goto unknown_chunk;
 				}
 				if (((stcb->asoc.idata_supported == 1) && (ch->chunk_type == SCTP_FORWARD_CUM_TSN)) ||
 				    ((stcb->asoc.idata_supported == 0) && (ch->chunk_type == SCTP_IFORWARD_CUM_TSN))) {
 					if (ch->chunk_type == SCTP_FORWARD_CUM_TSN) {
 						SCTP_SNPRINTF(msg, sizeof(msg), "%s", "FORWARD-TSN chunk received when I-FORWARD-TSN was negotiated");
 					} else {
 						SCTP_SNPRINTF(msg, sizeof(msg), "%s", "I-FORWARD-TSN chunk received when FORWARD-TSN was negotiated");
 					}
 					op_err = sctp_generate_cause(SCTP_CAUSE_PROTOCOL_VIOLATION, msg);
 					sctp_abort_an_association(inp, stcb, op_err, SCTP_SO_NOT_LOCKED);
 					*offset = length;
 					return (NULL);
 				}
 				*fwd_tsn_seen = 1;
 				if (inp->sctp_flags & SCTP_PCB_FLAGS_SOCKET_GONE) {
 					/* We are not interested anymore */
 #if defined(__APPLE__) && !defined(__Userspace__)
 					so = SCTP_INP_SO(inp);
 					atomic_add_int(&stcb->asoc.refcnt, 1);
 					SCTP_TCB_UNLOCK(stcb);
 					SCTP_SOCKET_LOCK(so, 1);
 					SCTP_TCB_LOCK(stcb);
 					atomic_subtract_int(&stcb->asoc.refcnt, 1);
 #endif
 					(void)sctp_free_assoc(inp, stcb, SCTP_NORMAL_PROC,
 					                      SCTP_FROM_SCTP_INPUT + SCTP_LOC_31);
 #if defined(__APPLE__) && !defined(__Userspace__)
 					SCTP_SOCKET_UNLOCK(so, 1);
 #endif
 					*offset = length;
 					return (NULL);
 				}
 				/*
 				 * For sending a SACK this looks like DATA
 				 * chunks.
 				 */
 				stcb->asoc.last_data_chunk_from = stcb->asoc.last_control_chunk_from;
 				sctp_handle_forward_tsn(stcb,
 							(struct sctp_forward_tsn_chunk *)ch, &abort_flag, m, *offset);
 				if (abort_flag) {
 					*offset = length;
 					return (NULL);
 				}
 			}
 			break;
 		case SCTP_STREAM_RESET:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_STREAM_RESET\n");
 			if ((stcb == NULL) || (chk_length < sizeof(struct sctp_stream_reset_tsn_req))) {
 				/* Its not ours */
 				*offset = length;
 				return (stcb);
 			}
 			if (stcb->asoc.reconfig_supported == 0) {
 				goto unknown_chunk;
 			}
 			if (sctp_handle_stream_reset(stcb, m, *offset, ch)) {
 				/* stop processing */
 				*offset = length;
 				return (NULL);
 			}
 			break;
 		case SCTP_PACKET_DROPPED:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_PACKET_DROPPED\n");
 			/* re-get it all please */
 			if (chk_length < sizeof(struct sctp_pktdrop_chunk)) {
 				/* Its not ours */
 				*offset = length;
 				return (stcb);
 			}
 
 			if ((stcb != NULL) && (netp != NULL) && (*netp != NULL)) {
 				if (stcb->asoc.pktdrop_supported == 0) {
 					goto unknown_chunk;
 				}
 				sctp_handle_packet_dropped((struct sctp_pktdrop_chunk *)ch,
 							   stcb, *netp,
 							   min(chk_length, contiguous));
 			}
 			break;
 		case SCTP_AUTHENTICATION:
 			SCTPDBG(SCTP_DEBUG_INPUT3, "SCTP_AUTHENTICATION\n");
 			if (stcb == NULL) {
 				/* save the first AUTH for later processing */
 				if (auth_skipped == 0) {
 					auth_offset = *offset;
 					auth_len = chk_length;
 					auth_skipped = 1;
 				}
 				/* skip this chunk (temporarily) */
 				goto next_chunk;
 			}
 			if (stcb->asoc.auth_supported == 0) {
 				goto unknown_chunk;
 			}
 			if ((chk_length < (sizeof(struct sctp_auth_chunk))) ||
 			    (chk_length > (sizeof(struct sctp_auth_chunk) +
 					   SCTP_AUTH_DIGEST_LEN_MAX))) {
 				/* Its not ours */
 				*offset = length;
 				return (stcb);
 			}
 			if (got_auth == 1) {
 				/* skip this chunk... it's already auth'd */
 				goto next_chunk;
 			}
 			got_auth = 1;
 			if (sctp_handle_auth(stcb, (struct sctp_auth_chunk *)ch, m, *offset)) {
 				/* auth HMAC failed so dump the packet */
 				*offset = length;
 				return (stcb);
 			} else {
 				/* remaining chunks are HMAC checked */
 				stcb->asoc.authenticated = 1;
 			}
 			break;
 
 		default:
 		unknown_chunk:
 			/* it's an unknown chunk! */
 			if ((ch->chunk_type & 0x40) &&
 			    (stcb != NULL) &&
 			    (SCTP_GET_STATE(stcb) != SCTP_STATE_EMPTY) &&
 			    (SCTP_GET_STATE(stcb) != SCTP_STATE_INUSE) &&
 			    (SCTP_GET_STATE(stcb) != SCTP_STATE_COOKIE_WAIT)) {
 				struct sctp_gen_error_cause *cause;
 				int len;
 
 				op_err = sctp_get_mbuf_for_msg(sizeof(struct sctp_gen_error_cause),
 				                               0, M_NOWAIT, 1, MT_DATA);
 				if (op_err != NULL) {
 					len = min(SCTP_SIZE32(chk_length), (uint32_t)(length - *offset));
 					cause = mtod(op_err, struct sctp_gen_error_cause *);
-					cause->code =  htons(SCTP_CAUSE_UNRECOG_CHUNK);
+					cause->code = htons(SCTP_CAUSE_UNRECOG_CHUNK);
 					cause->length = htons((uint16_t)(len + sizeof(struct sctp_gen_error_cause)));
 					SCTP_BUF_LEN(op_err) = sizeof(struct sctp_gen_error_cause);
 					SCTP_BUF_NEXT(op_err) = SCTP_M_COPYM(m, *offset, len, M_NOWAIT);
 					if (SCTP_BUF_NEXT(op_err) != NULL) {
 #ifdef SCTP_MBUF_LOGGING
 						if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_MBUF_LOGGING_ENABLE) {
 							sctp_log_mbc(SCTP_BUF_NEXT(op_err), SCTP_MBUF_ICOPY);
 						}
 #endif
 						sctp_queue_op_err(stcb, op_err);
 					} else {
 						sctp_m_freem(op_err);
 					}
 				}
 			}
 			if ((ch->chunk_type & 0x80) == 0) {
 				/* discard this packet */
 				*offset = length;
 				return (stcb);
 			}	/* else skip this bad chunk and continue... */
 			break;
 		}		/* switch (ch->chunk_type) */
 
 	next_chunk:
 		/* get the next chunk */
 		*offset += SCTP_SIZE32(chk_length);
 		if (*offset >= length) {
 			/* no more data left in the mbuf chain */
 			break;
 		}
 		ch = (struct sctp_chunkhdr *)sctp_m_getptr(m, *offset,
 							   sizeof(struct sctp_chunkhdr), chunk_buf);
 		if (ch == NULL) {
 			*offset = length;
 			return (stcb);
 		}
 	}			/* while */
 
 	if ((asconf_cnt > 0) && (stcb != NULL)) {
 		sctp_send_asconf_ack(stcb);
 	}
 	return (stcb);
 }
 
 /*
  * common input chunk processing (v4 and v6)
  */
diff --git a/usrsctplib/netinet/sctp_output.c b/usrsctplib/netinet/sctp_output.c
index 8b6fa0e..350b436 100755
--- a/usrsctplib/netinet/sctp_output.c
+++ b/usrsctplib/netinet/sctp_output.c
@@ -34,55 +34,55 @@
 
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: head/sys/netinet/sctp_output.c 366517 2020-10-07 15:22:48Z tuexen $");
+__FBSDID("$FreeBSD: head/sys/netinet/sctp_output.c 366750 2020-10-16 10:44:48Z tuexen $");
 #endif
 
 #include <netinet/sctp_os.h>
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <sys/proc.h>
 #endif
 #include <netinet/sctp_var.h>
 #include <netinet/sctp_sysctl.h>
 #include <netinet/sctp_header.h>
 #include <netinet/sctp_pcb.h>
 #include <netinet/sctputil.h>
 #include <netinet/sctp_output.h>
 #include <netinet/sctp_uio.h>
 #include <netinet/sctputil.h>
 #include <netinet/sctp_auth.h>
 #include <netinet/sctp_timer.h>
 #include <netinet/sctp_asconf.h>
 #include <netinet/sctp_indata.h>
 #include <netinet/sctp_bsd_addr.h>
 #include <netinet/sctp_input.h>
 #include <netinet/sctp_crc32.h>
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <netinet/sctp_kdtrace.h>
 #endif
 #if defined(__linux__)
 #define __FAVOR_BSD    /* (on Ubuntu at least) enables UDP header field names like BSD in RFC 768 */
 #endif
 #if defined(INET) || defined(INET6)
 #if !defined(_WIN32)
 #include <netinet/udp.h>
 #endif
 #endif
 #if !defined(__Userspace__)
 #if defined(__APPLE__)
 #include <netinet/in.h>
 #endif
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <netinet/udp_var.h>
 #include <machine/in_cksum.h>
 #endif
 #endif
 #if defined(__Userspace__) && defined(INET6)
 #include <netinet6/sctp6_var.h>
 #endif
 #if defined(__APPLE__) && !defined(__Userspace__)
 #if !(defined(APPLE_LEOPARD) || defined(APPLE_SNOWLEOPARD))
 #define SCTP_MAX_LINKHDR 16
 #endif
 #endif
 
 #define SCTP_MAX_GAPS_INARRAY 4
@@ -5059,293 +5059,293 @@ void
 sctp_send_initiate(struct sctp_inpcb *inp, struct sctp_tcb *stcb, int so_locked)
 {
 	struct mbuf *m, *m_last;
 	struct sctp_nets *net;
 	struct sctp_init_chunk *init;
 	struct sctp_supported_addr_param *sup_addr;
 	struct sctp_adaptation_layer_indication *ali;
 	struct sctp_supported_chunk_types_param *pr_supported;
 	struct sctp_paramhdr *ph;
 	int cnt_inits_to = 0;
 	int error;
 	uint16_t num_ext, chunk_len, padding_len, parameter_len;
 
 #if defined(__APPLE__) && !defined(__Userspace__)
 	if (so_locked) {
 		sctp_lock_assert(SCTP_INP_SO(inp));
 	} else {
 		sctp_unlock_assert(SCTP_INP_SO(inp));
 	}
 #endif
 	/* INIT's always go to the primary (and usually ONLY address) */
 	net = stcb->asoc.primary_destination;
 	if (net == NULL) {
 		net = TAILQ_FIRST(&stcb->asoc.nets);
 		if (net == NULL) {
 			/* TSNH */
 			return;
 		}
 		/* we confirm any address we send an INIT to */
 		net->dest_state &= ~SCTP_ADDR_UNCONFIRMED;
 		(void)sctp_set_primary_addr(stcb, NULL, net);
 	} else {
 		/* we confirm any address we send an INIT to */
 		net->dest_state &= ~SCTP_ADDR_UNCONFIRMED;
 	}
 	SCTPDBG(SCTP_DEBUG_OUTPUT4, "Sending INIT\n");
 #ifdef INET6
 	if (net->ro._l_addr.sa.sa_family == AF_INET6) {
 		/*
 		 * special hook, if we are sending to link local it will not
 		 * show up in our private address count.
 		 */
 		if (IN6_IS_ADDR_LINKLOCAL(&net->ro._l_addr.sin6.sin6_addr))
 			cnt_inits_to = 1;
 	}
 #endif
 	if (SCTP_OS_TIMER_PENDING(&net->rxt_timer.timer)) {
 		/* This case should not happen */
 		SCTPDBG(SCTP_DEBUG_OUTPUT4, "Sending INIT - failed timer?\n");
 		return;
 	}
 	/* start the INIT timer */
 	sctp_timer_start(SCTP_TIMER_TYPE_INIT, inp, stcb, net);
 
 	m = sctp_get_mbuf_for_msg(MCLBYTES, 1, M_NOWAIT, 1, MT_DATA);
 	if (m == NULL) {
 		/* No memory, INIT timer will re-attempt. */
 		SCTPDBG(SCTP_DEBUG_OUTPUT4, "Sending INIT - mbuf?\n");
 		return;
 	}
 	chunk_len = (uint16_t)sizeof(struct sctp_init_chunk);
 	padding_len = 0;
 	/* Now lets put the chunk header in place */
 	init = mtod(m, struct sctp_init_chunk *);
 	/* now the chunk header */
 	init->ch.chunk_type = SCTP_INITIATION;
 	init->ch.chunk_flags = 0;
 	/* fill in later from mbuf we build */
 	init->ch.chunk_length = 0;
 	/* place in my tag */
 	init->init.initiate_tag = htonl(stcb->asoc.my_vtag);
 	/* set up some of the credits. */
 	init->init.a_rwnd = htonl(max(inp->sctp_socket?SCTP_SB_LIMIT_RCV(inp->sctp_socket):0,
 	                              SCTP_MINIMAL_RWND));
 	init->init.num_outbound_streams = htons(stcb->asoc.pre_open_streams);
 	init->init.num_inbound_streams = htons(stcb->asoc.max_inbound_streams);
 	init->init.initial_tsn = htonl(stcb->asoc.init_seq_number);
 
 	/* Adaptation layer indication parameter */
 	if (inp->sctp_ep.adaptation_layer_indicator_provided) {
 		parameter_len = (uint16_t)sizeof(struct sctp_adaptation_layer_indication);
 		ali = (struct sctp_adaptation_layer_indication *)(mtod(m, caddr_t) + chunk_len);
 		ali->ph.param_type = htons(SCTP_ULP_ADAPTATION);
 		ali->ph.param_length = htons(parameter_len);
 		ali->indication = htonl(inp->sctp_ep.adaptation_layer_indicator);
 		chunk_len += parameter_len;
 	}
 
 	/* ECN parameter */
 	if (stcb->asoc.ecn_supported == 1) {
 		parameter_len = (uint16_t)sizeof(struct sctp_paramhdr);
 		ph = (struct sctp_paramhdr *)(mtod(m, caddr_t) + chunk_len);
 		ph->param_type = htons(SCTP_ECN_CAPABLE);
 		ph->param_length = htons(parameter_len);
 		chunk_len += parameter_len;
 	}
 
 	/* PR-SCTP supported parameter */
 	if (stcb->asoc.prsctp_supported == 1) {
 		parameter_len = (uint16_t)sizeof(struct sctp_paramhdr);
 		ph = (struct sctp_paramhdr *)(mtod(m, caddr_t) + chunk_len);
 		ph->param_type = htons(SCTP_PRSCTP_SUPPORTED);
 		ph->param_length = htons(parameter_len);
 		chunk_len += parameter_len;
 	}
 
 	/* Add NAT friendly parameter. */
 	if (SCTP_BASE_SYSCTL(sctp_inits_include_nat_friendly)) {
 		parameter_len = (uint16_t)sizeof(struct sctp_paramhdr);
 		ph = (struct sctp_paramhdr *)(mtod(m, caddr_t) + chunk_len);
 		ph->param_type = htons(SCTP_HAS_NAT_SUPPORT);
 		ph->param_length = htons(parameter_len);
 		chunk_len += parameter_len;
 	}
 
 	/* And now tell the peer which extensions we support */
 	num_ext = 0;
 	pr_supported = (struct sctp_supported_chunk_types_param *)(mtod(m, caddr_t) + chunk_len);
 	if (stcb->asoc.prsctp_supported == 1) {
 		pr_supported->chunk_types[num_ext++] = SCTP_FORWARD_CUM_TSN;
 		if (stcb->asoc.idata_supported) {
 			pr_supported->chunk_types[num_ext++] = SCTP_IFORWARD_CUM_TSN;
 		}
 	}
 	if (stcb->asoc.auth_supported == 1) {
 		pr_supported->chunk_types[num_ext++] = SCTP_AUTHENTICATION;
 	}
 	if (stcb->asoc.asconf_supported == 1) {
 		pr_supported->chunk_types[num_ext++] = SCTP_ASCONF;
 		pr_supported->chunk_types[num_ext++] = SCTP_ASCONF_ACK;
 	}
 	if (stcb->asoc.reconfig_supported == 1) {
 		pr_supported->chunk_types[num_ext++] = SCTP_STREAM_RESET;
 	}
 	if (stcb->asoc.idata_supported) {
 		pr_supported->chunk_types[num_ext++] = SCTP_IDATA;
 	}
 	if (stcb->asoc.nrsack_supported == 1) {
 		pr_supported->chunk_types[num_ext++] = SCTP_NR_SELECTIVE_ACK;
 	}
 	if (stcb->asoc.pktdrop_supported == 1) {
 		pr_supported->chunk_types[num_ext++] = SCTP_PACKET_DROPPED;
 	}
 	if (num_ext > 0) {
 		parameter_len = (uint16_t)sizeof(struct sctp_supported_chunk_types_param) + num_ext;
 		pr_supported->ph.param_type = htons(SCTP_SUPPORTED_CHUNK_EXT);
 		pr_supported->ph.param_length = htons(parameter_len);
 		padding_len = SCTP_SIZE32(parameter_len) - parameter_len;
 		chunk_len += parameter_len;
 	}
 	/* add authentication parameters */
 	if (stcb->asoc.auth_supported) {
 		/* attach RANDOM parameter, if available */
 		if (stcb->asoc.authinfo.random != NULL) {
 			struct sctp_auth_random *randp;
 
 			if (padding_len > 0) {
 				memset(mtod(m, caddr_t) + chunk_len, 0, padding_len);
 				chunk_len += padding_len;
 				padding_len = 0;
 			}
 			randp = (struct sctp_auth_random *)(mtod(m, caddr_t) + chunk_len);
 			parameter_len = (uint16_t)sizeof(struct sctp_auth_random) + stcb->asoc.authinfo.random_len;
 			/* random key already contains the header */
 			memcpy(randp, stcb->asoc.authinfo.random->key, parameter_len);
 			padding_len = SCTP_SIZE32(parameter_len) - parameter_len;
 			chunk_len += parameter_len;
 		}
 		/* add HMAC_ALGO parameter */
 		if (stcb->asoc.local_hmacs != NULL) {
 			struct sctp_auth_hmac_algo *hmacs;
 
 			if (padding_len > 0) {
 				memset(mtod(m, caddr_t) + chunk_len, 0, padding_len);
 				chunk_len += padding_len;
 				padding_len = 0;
 			}
 			hmacs = (struct sctp_auth_hmac_algo *)(mtod(m, caddr_t) + chunk_len);
 			parameter_len = (uint16_t)(sizeof(struct sctp_auth_hmac_algo) +
 			                           stcb->asoc.local_hmacs->num_algo * sizeof(uint16_t));
 			hmacs->ph.param_type = htons(SCTP_HMAC_LIST);
 			hmacs->ph.param_length = htons(parameter_len);
 			sctp_serialize_hmaclist(stcb->asoc.local_hmacs, (uint8_t *)hmacs->hmac_ids);
 			padding_len = SCTP_SIZE32(parameter_len) - parameter_len;
 			chunk_len += parameter_len;
 		}
 		/* add CHUNKS parameter */
 		if (stcb->asoc.local_auth_chunks != NULL) {
 			struct sctp_auth_chunk_list *chunks;
 
 			if (padding_len > 0) {
 				memset(mtod(m, caddr_t) + chunk_len, 0, padding_len);
 				chunk_len += padding_len;
 				padding_len = 0;
 			}
 			chunks = (struct sctp_auth_chunk_list *)(mtod(m, caddr_t) + chunk_len);
 			parameter_len = (uint16_t)(sizeof(struct sctp_auth_chunk_list) +
 			                           sctp_auth_get_chklist_size(stcb->asoc.local_auth_chunks));
 			chunks->ph.param_type = htons(SCTP_CHUNK_LIST);
 			chunks->ph.param_length = htons(parameter_len);
 			sctp_serialize_auth_chunks(stcb->asoc.local_auth_chunks, chunks->chunk_types);
 			padding_len = SCTP_SIZE32(parameter_len) - parameter_len;
 			chunk_len += parameter_len;
 		}
 	}
 
 	/* now any cookie time extensions */
-	if (stcb->asoc.cookie_preserve_req) {
+	if (stcb->asoc.cookie_preserve_req > 0) {
 		struct sctp_cookie_perserve_param *cookie_preserve;
 
 		if (padding_len > 0) {
 			memset(mtod(m, caddr_t) + chunk_len, 0, padding_len);
 			chunk_len += padding_len;
 			padding_len = 0;
 		}
 		parameter_len = (uint16_t)sizeof(struct sctp_cookie_perserve_param);
 		cookie_preserve = (struct sctp_cookie_perserve_param *)(mtod(m, caddr_t) + chunk_len);
 		cookie_preserve->ph.param_type = htons(SCTP_COOKIE_PRESERVE);
 		cookie_preserve->ph.param_length = htons(parameter_len);
 		cookie_preserve->time = htonl(stcb->asoc.cookie_preserve_req);
 		stcb->asoc.cookie_preserve_req = 0;
 		chunk_len += parameter_len;
 	}
 
 	if (stcb->asoc.scope.ipv4_addr_legal || stcb->asoc.scope.ipv6_addr_legal) {
 		uint8_t i;
 
 		if (padding_len > 0) {
 			memset(mtod(m, caddr_t) + chunk_len, 0, padding_len);
 			chunk_len += padding_len;
 			padding_len = 0;
 		}
 		parameter_len = (uint16_t)sizeof(struct sctp_paramhdr);
 		if (stcb->asoc.scope.ipv4_addr_legal) {
 			parameter_len += (uint16_t)sizeof(uint16_t);
 		}
 		if (stcb->asoc.scope.ipv6_addr_legal) {
 			parameter_len += (uint16_t)sizeof(uint16_t);
 		}
 		sup_addr = (struct sctp_supported_addr_param *)(mtod(m, caddr_t) + chunk_len);
 		sup_addr->ph.param_type = htons(SCTP_SUPPORTED_ADDRTYPE);
 		sup_addr->ph.param_length = htons(parameter_len);
 		i = 0;
 		if (stcb->asoc.scope.ipv4_addr_legal) {
 			sup_addr->addr_type[i++] = htons(SCTP_IPV4_ADDRESS);
 		}
 		if (stcb->asoc.scope.ipv6_addr_legal) {
 			sup_addr->addr_type[i++] = htons(SCTP_IPV6_ADDRESS);
 		}
 		padding_len = 4 - 2 * i;
 		chunk_len += parameter_len;
 	}
 
 	SCTP_BUF_LEN(m) = chunk_len;
 	/* now the addresses */
 	/* To optimize this we could put the scoping stuff
 	 * into a structure and remove the individual uint8's from
 	 * the assoc structure. Then we could just sifa in the
 	 * address within the stcb. But for now this is a quick
 	 * hack to get the address stuff teased apart.
 	 */
 	m_last = sctp_add_addresses_to_i_ia(inp, stcb, &stcb->asoc.scope,
 	                                    m, cnt_inits_to,
 	                                    &padding_len, &chunk_len);
 
 	init->ch.chunk_length = htons(chunk_len);
 	if (padding_len > 0) {
 		if (sctp_add_pad_tombuf(m_last, padding_len) == NULL) {
 			sctp_m_freem(m);
 			return;
 		}
 	}
 	SCTPDBG(SCTP_DEBUG_OUTPUT4, "Sending INIT - calls lowlevel_output\n");
 	if ((error = sctp_lowlevel_chunk_output(inp, stcb, net,
 	                                        (struct sockaddr *)&net->ro._l_addr,
 	                                        m, 0, NULL, 0, 0, 0, 0,
 	                                        inp->sctp_lport, stcb->rport, htonl(0),
 	                                        net->port, NULL,
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 	                                        0, 0,
 #endif
 	                                        so_locked))) {
 		SCTPDBG(SCTP_DEBUG_OUTPUT4, "Gak send error %d\n", error);
 		if (error == ENOBUFS) {
 			stcb->asoc.ifp_had_enobuf = 1;
 			SCTP_STAT_INCR(sctps_lowlevelerr);
 		}
 	} else {
 		stcb->asoc.ifp_had_enobuf = 0;
 	}
 	SCTP_STAT_INCR_COUNTER64(sctps_outcontrolchunks);
 	(void)SCTP_GETTIME_TIMEVAL(&net->last_sent_time);
 }
diff --git a/usrsctplib/netinet/sctp_sysctl.h b/usrsctplib/netinet/sctp_sysctl.h
index 54aaa62..006a11f 100755
--- a/usrsctplib/netinet/sctp_sysctl.h
+++ b/usrsctplib/netinet/sctp_sysctl.h
@@ -34,11 +34,11 @@
 
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: head/sys/netinet/sctp_sysctl.h 365071 2020-09-01 21:19:14Z mjg $");
+__FBSDID("$FreeBSD: head/sys/netinet/sctp_sysctl.h 366750 2020-10-16 10:44:48Z tuexen $");
 #endif
 
 #ifndef _NETINET_SCTP_SYSCTL_H_
 #define _NETINET_SCTP_SYSCTL_H_
 
 #include <netinet/sctp_os.h>
 #include <netinet/sctp_constants.h>
@@ -46,571 +46,571 @@ __FBSDID("$FreeBSD: head/sys/netinet/sctp_sysctl.h 365071 2020-09-01 21:19:14Z m
 struct sctp_sysctl {
 	uint32_t sctp_sendspace;
 	uint32_t sctp_recvspace;
 	uint32_t sctp_auto_asconf;
 	uint32_t sctp_multiple_asconfs;
 	uint32_t sctp_ecn_enable;
 	uint32_t sctp_pr_enable;
 	uint32_t sctp_auth_enable;
 	uint32_t sctp_asconf_enable;
 	uint32_t sctp_reconfig_enable;
 	uint32_t sctp_nrsack_enable;
 	uint32_t sctp_pktdrop_enable;
 	uint32_t sctp_fr_max_burst_default;
 #if !(defined(__FreeBSD__)  && !defined(__Userspace__))
 	uint32_t sctp_no_csum_on_loopback;
 #endif
 	uint32_t sctp_peer_chunk_oh;
 	uint32_t sctp_max_burst_default;
 	uint32_t sctp_max_chunks_on_queue;
 	uint32_t sctp_hashtblsize;
 	uint32_t sctp_pcbtblsize;
 	uint32_t sctp_min_split_point;
 	uint32_t sctp_chunkscale;
 	uint32_t sctp_delayed_sack_time_default;
 	uint32_t sctp_sack_freq_default;
 	uint32_t sctp_system_free_resc_limit;
 	uint32_t sctp_asoc_free_resc_limit;
 	uint32_t sctp_heartbeat_interval_default;
 	uint32_t sctp_pmtu_raise_time_default;
 	uint32_t sctp_shutdown_guard_time_default;
 	uint32_t sctp_secret_lifetime_default;
 	uint32_t sctp_rto_max_default;
 	uint32_t sctp_rto_min_default;
 	uint32_t sctp_rto_initial_default;
 	uint32_t sctp_init_rto_max_default;
 	uint32_t sctp_valid_cookie_life_default;
 	uint32_t sctp_init_rtx_max_default;
 	uint32_t sctp_assoc_rtx_max_default;
 	uint32_t sctp_path_rtx_max_default;
 	uint32_t sctp_path_pf_threshold;
 	uint32_t sctp_add_more_threshold;
 	uint32_t sctp_nr_incoming_streams_default;
 	uint32_t sctp_nr_outgoing_streams_default;
 	uint32_t sctp_cmt_on_off;
 	uint32_t sctp_cmt_use_dac;
 	uint32_t sctp_use_cwnd_based_maxburst;
 	uint32_t sctp_nat_friendly;
 	uint32_t sctp_L2_abc_variable;
 	uint32_t sctp_mbuf_threshold_count;
 	uint32_t sctp_do_drain;
 	uint32_t sctp_hb_maxburst;
 	uint32_t sctp_abort_if_one_2_one_hits_limit;
 	uint32_t sctp_min_residual;
 	uint32_t sctp_max_retran_chunk;
 	uint32_t sctp_logging_level;
 	/* JRS - Variable for default congestion control module */
 	uint32_t sctp_default_cc_module;
 	/* RS - Variable for default stream scheduling module */
 	uint32_t sctp_default_ss_module;
 	uint32_t sctp_default_frag_interleave;
 	uint32_t sctp_mobility_base;
 	uint32_t sctp_mobility_fasthandoff;
 	uint32_t sctp_inits_include_nat_friendly;
 	uint32_t sctp_rttvar_bw;
 	uint32_t sctp_rttvar_rtt;
 	uint32_t sctp_rttvar_eqret;
 	uint32_t sctp_steady_step;
 	uint32_t sctp_use_dccc_ecn;
 	uint32_t sctp_diag_info_code;
 #if defined(SCTP_LOCAL_TRACE_BUF)
 #if defined(_WIN32) && !defined(__Userspace__)
 	struct sctp_log *sctp_log;
 #else
 	struct sctp_log sctp_log;
 #endif
 #endif
 	uint32_t sctp_udp_tunneling_port;
 	uint32_t sctp_enable_sack_immediately;
 	uint32_t sctp_vtag_time_wait;
 	uint32_t sctp_buffer_splitting;
 	uint32_t sctp_initial_cwnd;
 	uint32_t sctp_blackhole;
 	uint32_t sctp_sendall_limit;
 #if defined(SCTP_DEBUG)
 	uint32_t sctp_debug_on;
 #endif
 #if defined(__APPLE__) && !defined(__Userspace__)
 	uint32_t sctp_ignore_vmware_interfaces;
 	uint32_t sctp_main_timer;
 	uint32_t sctp_addr_watchdog_limit;
 	uint32_t sctp_vtag_watchdog_limit;
 #endif
 #if defined(__APPLE__) && !defined(__Userspace__)
 	uint32_t sctp_output_unlocked;
 #endif
 };
 
 /*
  * limits for the sysctl variables
  */
 /* maxdgram: Maximum outgoing SCTP buffer size */
 #define SCTPCTL_MAXDGRAM_DESC		"Maximum outgoing SCTP buffer size"
 #define SCTPCTL_MAXDGRAM_MIN		0
 #define SCTPCTL_MAXDGRAM_MAX		0xFFFFFFFF
 #if defined(__Userspace__)
 #define SCTPCTL_MAXDGRAM_DEFAULT	SB_MAX
 #else
 #define SCTPCTL_MAXDGRAM_DEFAULT	262144	/* 256k */
 #endif
 
 /* recvspace: Maximum incoming SCTP buffer size */
 #define SCTPCTL_RECVSPACE_DESC		"Maximum incoming SCTP buffer size"
 #define SCTPCTL_RECVSPACE_MIN		0
 #define SCTPCTL_RECVSPACE_MAX		0xFFFFFFFF
 #if defined(__Userspace__)
 #define SCTPCTL_RECVSPACE_DEFAULT	SB_RAW
 #else
 #define SCTPCTL_RECVSPACE_DEFAULT	262144	/* 256k */
 #endif
 
 /* autoasconf: Enable SCTP Auto-ASCONF */
 #define SCTPCTL_AUTOASCONF_DESC		"Enable SCTP Auto-ASCONF"
 #define SCTPCTL_AUTOASCONF_MIN		0
 #define SCTPCTL_AUTOASCONF_MAX		1
 #define SCTPCTL_AUTOASCONF_DEFAULT	1
 
 /* autoasconf: Enable SCTP Auto-ASCONF */
 #define SCTPCTL_MULTIPLEASCONFS_DESC	"Enable SCTP Muliple-ASCONFs"
 #define SCTPCTL_MULTIPLEASCONFS_MIN	0
 #define SCTPCTL_MULTIPLEASCONFS_MAX	1
 #define SCTPCTL_MULTIPLEASCONFS_DEFAULT	SCTP_DEFAULT_MULTIPLE_ASCONFS
 
 /* ecn_enable: Enable SCTP ECN */
 #define SCTPCTL_ECN_ENABLE_DESC		"Enable SCTP ECN"
 #define SCTPCTL_ECN_ENABLE_MIN		0
 #define SCTPCTL_ECN_ENABLE_MAX		1
 #define SCTPCTL_ECN_ENABLE_DEFAULT	1
 
 /* pr_enable: Enable PR-SCTP */
 #define SCTPCTL_PR_ENABLE_DESC		"Enable PR-SCTP"
 #define SCTPCTL_PR_ENABLE_MIN		0
 #define SCTPCTL_PR_ENABLE_MAX		1
 #define SCTPCTL_PR_ENABLE_DEFAULT	1
 
 /* auth_enable: Enable SCTP AUTH function */
 #define SCTPCTL_AUTH_ENABLE_DESC	"Enable SCTP AUTH function"
 #define SCTPCTL_AUTH_ENABLE_MIN		0
 #define SCTPCTL_AUTH_ENABLE_MAX		1
 #define SCTPCTL_AUTH_ENABLE_DEFAULT	1
 
 /* asconf_enable: Enable SCTP ASCONF */
 #define SCTPCTL_ASCONF_ENABLE_DESC	"Enable SCTP ASCONF"
 #define SCTPCTL_ASCONF_ENABLE_MIN	0
 #define SCTPCTL_ASCONF_ENABLE_MAX	1
 #define SCTPCTL_ASCONF_ENABLE_DEFAULT	1
 
 /* reconfig_enable: Enable SCTP RE-CONFIG */
 #define SCTPCTL_RECONFIG_ENABLE_DESC	"Enable SCTP RE-CONFIG"
 #define SCTPCTL_RECONFIG_ENABLE_MIN	0
 #define SCTPCTL_RECONFIG_ENABLE_MAX	1
 #define SCTPCTL_RECONFIG_ENABLE_DEFAULT	1
 
 /* nrsack_enable: Enable NR_SACK */
 #define SCTPCTL_NRSACK_ENABLE_DESC	"Enable SCTP NR-SACK"
 #define SCTPCTL_NRSACK_ENABLE_MIN	0
 #define SCTPCTL_NRSACK_ENABLE_MAX	1
 #define SCTPCTL_NRSACK_ENABLE_DEFAULT	0
 
 /* pktdrop_enable: Enable SCTP Packet Drop Reports */
 #define SCTPCTL_PKTDROP_ENABLE_DESC	"Enable SCTP PKTDROP"
 #define SCTPCTL_PKTDROP_ENABLE_MIN	0
 #define SCTPCTL_PKTDROP_ENABLE_MAX	1
 #define SCTPCTL_PKTDROP_ENABLE_DEFAULT	0
 
 /* loopback_nocsum: Enable NO Csum on packets sent on loopback */
 #define SCTPCTL_LOOPBACK_NOCSUM_DESC	"Enable NO Csum on packets sent on loopback"
 #define SCTPCTL_LOOPBACK_NOCSUM_MIN	0
 #define SCTPCTL_LOOPBACK_NOCSUM_MAX	1
 #define SCTPCTL_LOOPBACK_NOCSUM_DEFAULT	1
 
 /* peer_chkoh: Amount to debit peers rwnd per chunk sent */
 #define SCTPCTL_PEER_CHKOH_DESC		"Amount to debit peers rwnd per chunk sent"
 #define SCTPCTL_PEER_CHKOH_MIN		0
 #define SCTPCTL_PEER_CHKOH_MAX		0xFFFFFFFF
 #define SCTPCTL_PEER_CHKOH_DEFAULT	256
 
 /* maxburst: Default max burst for sctp endpoints */
 #define SCTPCTL_MAXBURST_DESC		"Default max burst for sctp endpoints"
 #define SCTPCTL_MAXBURST_MIN		0
 #define SCTPCTL_MAXBURST_MAX		0xFFFFFFFF
 #define SCTPCTL_MAXBURST_DEFAULT	SCTP_DEF_MAX_BURST
 
 /* fr_maxburst: Default max burst for sctp endpoints when fast retransmitting */
 #define SCTPCTL_FRMAXBURST_DESC		"Default max burst for SCTP endpoints when fast retransmitting"
 #define SCTPCTL_FRMAXBURST_MIN		0
 #define SCTPCTL_FRMAXBURST_MAX		0xFFFFFFFF
 #define SCTPCTL_FRMAXBURST_DEFAULT	SCTP_DEF_FRMAX_BURST
 
 /* maxchunks: Default max chunks on queue per asoc */
 #define SCTPCTL_MAXCHUNKS_DESC		"Default max chunks on queue per asoc"
 #define SCTPCTL_MAXCHUNKS_MIN		0
 #define SCTPCTL_MAXCHUNKS_MAX		0xFFFFFFFF
 #define SCTPCTL_MAXCHUNKS_DEFAULT	SCTP_ASOC_MAX_CHUNKS_ON_QUEUE
 
 /* tcbhashsize: Tunable for Hash table sizes */
 #define SCTPCTL_TCBHASHSIZE_DESC	"Tunable for TCB hash table sizes"
 #define SCTPCTL_TCBHASHSIZE_MIN		1
 #define SCTPCTL_TCBHASHSIZE_MAX		0xFFFFFFFF
 #define SCTPCTL_TCBHASHSIZE_DEFAULT	SCTP_TCBHASHSIZE
 
 /* pcbhashsize: Tunable for PCB Hash table sizes */
 #define SCTPCTL_PCBHASHSIZE_DESC	"Tunable for PCB hash table sizes"
 #define SCTPCTL_PCBHASHSIZE_MIN		1
 #define SCTPCTL_PCBHASHSIZE_MAX		0xFFFFFFFF
 #define SCTPCTL_PCBHASHSIZE_DEFAULT	SCTP_PCBHASHSIZE
 
 /* min_split_point: Minimum size when splitting a chunk */
 #define SCTPCTL_MIN_SPLIT_POINT_DESC	"Minimum size when splitting a chunk"
 #define SCTPCTL_MIN_SPLIT_POINT_MIN	0
 #define SCTPCTL_MIN_SPLIT_POINT_MAX	0xFFFFFFFF
 #define SCTPCTL_MIN_SPLIT_POINT_DEFAULT	SCTP_DEFAULT_SPLIT_POINT_MIN
 
 /* chunkscale: Tunable for Scaling of number of chunks and messages */
 #define SCTPCTL_CHUNKSCALE_DESC		"Tunable for scaling of number of chunks and messages"
 #define SCTPCTL_CHUNKSCALE_MIN		1
 #define SCTPCTL_CHUNKSCALE_MAX		0xFFFFFFFF
 #define SCTPCTL_CHUNKSCALE_DEFAULT	SCTP_CHUNKQUEUE_SCALE
 
 /* delayed_sack_time: Default delayed SACK timer in ms */
 #define SCTPCTL_DELAYED_SACK_TIME_DESC	"Default delayed SACK timer in ms"
 #define SCTPCTL_DELAYED_SACK_TIME_MIN	0
 #define SCTPCTL_DELAYED_SACK_TIME_MAX	0xFFFFFFFF
 #define SCTPCTL_DELAYED_SACK_TIME_DEFAULT	SCTP_RECV_MSEC
 
 /* sack_freq: Default SACK frequency */
 #define SCTPCTL_SACK_FREQ_DESC		"Default SACK frequency"
 #define SCTPCTL_SACK_FREQ_MIN		0
 #define SCTPCTL_SACK_FREQ_MAX		0xFFFFFFFF
 #define SCTPCTL_SACK_FREQ_DEFAULT	SCTP_DEFAULT_SACK_FREQ
 
 /* sys_resource: Max number of cached resources in the system */
 #define SCTPCTL_SYS_RESOURCE_DESC	"Max number of cached resources in the system"
 #define SCTPCTL_SYS_RESOURCE_MIN	0
 #define SCTPCTL_SYS_RESOURCE_MAX	0xFFFFFFFF
 #define SCTPCTL_SYS_RESOURCE_DEFAULT	SCTP_DEF_SYSTEM_RESC_LIMIT
 
 /* asoc_resource: Max number of cached resources in an asoc */
 #define SCTPCTL_ASOC_RESOURCE_DESC	"Max number of cached resources in an asoc"
 #define SCTPCTL_ASOC_RESOURCE_MIN	0
 #define SCTPCTL_ASOC_RESOURCE_MAX	0xFFFFFFFF
 #define SCTPCTL_ASOC_RESOURCE_DEFAULT	SCTP_DEF_ASOC_RESC_LIMIT
 
 /* heartbeat_interval: Default heartbeat interval in ms */
 #define SCTPCTL_HEARTBEAT_INTERVAL_DESC	"Default heartbeat interval in ms"
 #define SCTPCTL_HEARTBEAT_INTERVAL_MIN	0
 #define SCTPCTL_HEARTBEAT_INTERVAL_MAX	0xFFFFFFFF
 #define SCTPCTL_HEARTBEAT_INTERVAL_DEFAULT	SCTP_HB_DEFAULT_MSEC
 
 /* pmtu_raise_time: Default PMTU raise timer in seconds */
 #define SCTPCTL_PMTU_RAISE_TIME_DESC	"Default PMTU raise timer in seconds"
 #define SCTPCTL_PMTU_RAISE_TIME_MIN	0
 #define SCTPCTL_PMTU_RAISE_TIME_MAX	0xFFFFFFFF
 #define SCTPCTL_PMTU_RAISE_TIME_DEFAULT	SCTP_DEF_PMTU_RAISE_SEC
 
 /* shutdown_guard_time: Default shutdown guard timer in seconds */
 #define SCTPCTL_SHUTDOWN_GUARD_TIME_DESC	"Shutdown guard timer in seconds (0 means 5 times RTO.Max)"
 #define SCTPCTL_SHUTDOWN_GUARD_TIME_MIN		0
 #define SCTPCTL_SHUTDOWN_GUARD_TIME_MAX		0xFFFFFFFF
 #define SCTPCTL_SHUTDOWN_GUARD_TIME_DEFAULT	0
 
 /* secret_lifetime: Default secret lifetime in seconds */
 #define SCTPCTL_SECRET_LIFETIME_DESC	"Default secret lifetime in seconds"
 #define SCTPCTL_SECRET_LIFETIME_MIN	0
 #define SCTPCTL_SECRET_LIFETIME_MAX	0xFFFFFFFF
 #define SCTPCTL_SECRET_LIFETIME_DEFAULT	SCTP_DEFAULT_SECRET_LIFE_SEC
 
 /* rto_max: Default maximum retransmission timeout in ms */
 #define SCTPCTL_RTO_MAX_DESC		"Default maximum retransmission timeout in ms"
 #define SCTPCTL_RTO_MAX_MIN		0
 #define SCTPCTL_RTO_MAX_MAX		0xFFFFFFFF
 #define SCTPCTL_RTO_MAX_DEFAULT		SCTP_RTO_UPPER_BOUND
 
 /* rto_min: Default minimum retransmission timeout in ms */
 #define SCTPCTL_RTO_MIN_DESC		"Default minimum retransmission timeout in ms"
 #define SCTPCTL_RTO_MIN_MIN		0
 #define SCTPCTL_RTO_MIN_MAX		0xFFFFFFFF
 #define SCTPCTL_RTO_MIN_DEFAULT		SCTP_RTO_LOWER_BOUND
 
 /* rto_initial: Default initial retransmission timeout in ms */
 #define SCTPCTL_RTO_INITIAL_DESC	"Default initial retransmission timeout in ms"
 #define SCTPCTL_RTO_INITIAL_MIN		0
 #define SCTPCTL_RTO_INITIAL_MAX		0xFFFFFFFF
 #define SCTPCTL_RTO_INITIAL_DEFAULT	SCTP_RTO_INITIAL
 
 /* init_rto_max: Default maximum retransmission timeout during association setup in ms */
 #define SCTPCTL_INIT_RTO_MAX_DESC	"Default maximum retransmission timeout during association setup in ms"
 #define SCTPCTL_INIT_RTO_MAX_MIN	0
 #define SCTPCTL_INIT_RTO_MAX_MAX	0xFFFFFFFF
 #define SCTPCTL_INIT_RTO_MAX_DEFAULT	SCTP_RTO_UPPER_BOUND
 
-/* valid_cookie_life: Default cookie lifetime in sec */
-#define SCTPCTL_VALID_COOKIE_LIFE_DESC	"Default cookie lifetime in seconds"
-#define SCTPCTL_VALID_COOKIE_LIFE_MIN	0
-#define SCTPCTL_VALID_COOKIE_LIFE_MAX	0xFFFFFFFF
+/* valid_cookie_life: Default cookie lifetime in ms */
+#define SCTPCTL_VALID_COOKIE_LIFE_DESC		"Default cookie lifetime in ms"
+#define SCTPCTL_VALID_COOKIE_LIFE_MIN		SCTP_MIN_COOKIE_LIFE
+#define SCTPCTL_VALID_COOKIE_LIFE_MAX		SCTP_MAX_COOKIE_LIFE
 #define SCTPCTL_VALID_COOKIE_LIFE_DEFAULT	SCTP_DEFAULT_COOKIE_LIFE
 
 /* init_rtx_max: Default maximum number of retransmission for INIT chunks */
 #define SCTPCTL_INIT_RTX_MAX_DESC	"Default maximum number of retransmissions for INIT chunks"
 #define SCTPCTL_INIT_RTX_MAX_MIN	0
 #define SCTPCTL_INIT_RTX_MAX_MAX	0xFFFFFFFF
 #define SCTPCTL_INIT_RTX_MAX_DEFAULT	SCTP_DEF_MAX_INIT
 
 /* assoc_rtx_max: Default maximum number of retransmissions per association */
 #define SCTPCTL_ASSOC_RTX_MAX_DESC	"Default maximum number of retransmissions per association"
 #define SCTPCTL_ASSOC_RTX_MAX_MIN	0
 #define SCTPCTL_ASSOC_RTX_MAX_MAX	0xFFFFFFFF
 #define SCTPCTL_ASSOC_RTX_MAX_DEFAULT	SCTP_DEF_MAX_SEND
 
 /* path_rtx_max: Default maximum of retransmissions per path */
 #define SCTPCTL_PATH_RTX_MAX_DESC	"Default maximum of retransmissions per path"
 #define SCTPCTL_PATH_RTX_MAX_MIN	0
 #define SCTPCTL_PATH_RTX_MAX_MAX	0xFFFFFFFF
 #define SCTPCTL_PATH_RTX_MAX_DEFAULT	SCTP_DEF_MAX_PATH_RTX
 
 /* path_pf_threshold: threshold for considering the path potentially failed */
 #define SCTPCTL_PATH_PF_THRESHOLD_DESC		"Default potentially failed threshold"
 #define SCTPCTL_PATH_PF_THRESHOLD_MIN		0
 #define SCTPCTL_PATH_PF_THRESHOLD_MAX		0xFFFF
 #define SCTPCTL_PATH_PF_THRESHOLD_DEFAULT	SCTPCTL_PATH_PF_THRESHOLD_MAX
 
 /* add_more_on_output: When space-wise is it worthwhile to try to add more to a socket send buffer */
 #define SCTPCTL_ADD_MORE_ON_OUTPUT_DESC	"When space-wise is it worthwhile to try to add more to a socket send buffer"
 #define SCTPCTL_ADD_MORE_ON_OUTPUT_MIN	0
 #define SCTPCTL_ADD_MORE_ON_OUTPUT_MAX	0xFFFFFFFF
 #define SCTPCTL_ADD_MORE_ON_OUTPUT_DEFAULT SCTP_DEFAULT_ADD_MORE
 
 /* incoming_streams: Default number of incoming streams */
 #define SCTPCTL_INCOMING_STREAMS_DESC	"Default number of incoming streams"
 #define SCTPCTL_INCOMING_STREAMS_MIN	1
 #define SCTPCTL_INCOMING_STREAMS_MAX	65535
 #define SCTPCTL_INCOMING_STREAMS_DEFAULT SCTP_ISTREAM_INITIAL
 
 /* outgoing_streams: Default number of outgoing streams */
 #define SCTPCTL_OUTGOING_STREAMS_DESC	"Default number of outgoing streams"
 #define SCTPCTL_OUTGOING_STREAMS_MIN	1
 #define SCTPCTL_OUTGOING_STREAMS_MAX	65535
 #define SCTPCTL_OUTGOING_STREAMS_DEFAULT SCTP_OSTREAM_INITIAL
 
 /* cmt_on_off: CMT on/off flag */
 #define SCTPCTL_CMT_ON_OFF_DESC		"CMT settings"
 #define SCTPCTL_CMT_ON_OFF_MIN		SCTP_CMT_OFF
 #define SCTPCTL_CMT_ON_OFF_MAX		SCTP_CMT_MAX
 #define SCTPCTL_CMT_ON_OFF_DEFAULT	SCTP_CMT_OFF
 
 /* cmt_use_dac: CMT DAC on/off flag */
 #define SCTPCTL_CMT_USE_DAC_DESC	"CMT DAC on/off flag"
 #define SCTPCTL_CMT_USE_DAC_MIN		0
 #define SCTPCTL_CMT_USE_DAC_MAX		1
 #define SCTPCTL_CMT_USE_DAC_DEFAULT    	0
 
 /* cwnd_maxburst: Use a CWND adjusting to implement maxburst */
 #define SCTPCTL_CWND_MAXBURST_DESC	"Adjust congestion control window to limit maximum burst when sending"
 #define SCTPCTL_CWND_MAXBURST_MIN	0
 #define SCTPCTL_CWND_MAXBURST_MAX	1
 #define SCTPCTL_CWND_MAXBURST_DEFAULT	1
 
 /* nat_friendly: SCTP NAT friendly operation */
 #define SCTPCTL_NAT_FRIENDLY_DESC	"SCTP NAT friendly operation"
 #define SCTPCTL_NAT_FRIENDLY_MIN	0
 #define SCTPCTL_NAT_FRIENDLY_MAX	1
 #define SCTPCTL_NAT_FRIENDLY_DEFAULT	1
 
 /* abc_l_var: SCTP ABC max increase per SACK (L) */
 #define SCTPCTL_ABC_L_VAR_DESC		"SCTP ABC max increase per SACK (L)"
 #define SCTPCTL_ABC_L_VAR_MIN		0
 #define SCTPCTL_ABC_L_VAR_MAX		0xFFFFFFFF
 #define SCTPCTL_ABC_L_VAR_DEFAULT	2
 
 /* max_chained_mbufs: Default max number of small mbufs on a chain */
 #define SCTPCTL_MAX_CHAINED_MBUFS_DESC	"Default max number of small mbufs on a chain"
 #define SCTPCTL_MAX_CHAINED_MBUFS_MIN	0
 #define SCTPCTL_MAX_CHAINED_MBUFS_MAX	0xFFFFFFFF
 #define SCTPCTL_MAX_CHAINED_MBUFS_DEFAULT	SCTP_DEFAULT_MBUFS_IN_CHAIN
 
 /* do_sctp_drain: Should SCTP respond to the drain calls */
 #define SCTPCTL_DO_SCTP_DRAIN_DESC	"Should SCTP respond to the drain calls"
 #define SCTPCTL_DO_SCTP_DRAIN_MIN	0
 #define SCTPCTL_DO_SCTP_DRAIN_MAX	1
 #define SCTPCTL_DO_SCTP_DRAIN_DEFAULT	1
 
 /* hb_max_burst: Confirmation Heartbeat max burst? */
 #define SCTPCTL_HB_MAX_BURST_DESC	"Confirmation Heartbeat max burst"
 #define SCTPCTL_HB_MAX_BURST_MIN	1
 #define SCTPCTL_HB_MAX_BURST_MAX	0xFFFFFFFF
 #define SCTPCTL_HB_MAX_BURST_DEFAULT	SCTP_DEF_HBMAX_BURST
 
 /* abort_at_limit: When one-2-one hits qlimit abort */
 #define SCTPCTL_ABORT_AT_LIMIT_DESC	"Abort when one-to-one hits qlimit"
 #define SCTPCTL_ABORT_AT_LIMIT_MIN	0
 #define SCTPCTL_ABORT_AT_LIMIT_MAX	1
 #define SCTPCTL_ABORT_AT_LIMIT_DEFAULT	0
 
 /* min_residual: min residual in a data fragment leftover */
 #define SCTPCTL_MIN_RESIDUAL_DESC	"Minimum residual data chunk in second part of split"
 #define SCTPCTL_MIN_RESIDUAL_MIN	20
 #define SCTPCTL_MIN_RESIDUAL_MAX	65535
 #define SCTPCTL_MIN_RESIDUAL_DEFAULT	1452
 
 /* max_retran_chunk: max chunk retransmissions */
 #define SCTPCTL_MAX_RETRAN_CHUNK_DESC	"Maximum times an unlucky chunk can be retransmitted before assoc abort"
 #define SCTPCTL_MAX_RETRAN_CHUNK_MIN	0
 #define SCTPCTL_MAX_RETRAN_CHUNK_MAX	65535
 #define SCTPCTL_MAX_RETRAN_CHUNK_DEFAULT	30
 
 /* sctp_logging: This gives us logging when the options are enabled */
 #define SCTPCTL_LOGGING_LEVEL_DESC	"Ltrace/KTR trace logging level"
 #define SCTPCTL_LOGGING_LEVEL_MIN	0
 #define SCTPCTL_LOGGING_LEVEL_MAX	0xffffffff
 #define SCTPCTL_LOGGING_LEVEL_DEFAULT	0
 
 /* JRS - default congestion control module sysctl */
 #define SCTPCTL_DEFAULT_CC_MODULE_DESC		"Default congestion control module"
 #define SCTPCTL_DEFAULT_CC_MODULE_MIN		0
 #define SCTPCTL_DEFAULT_CC_MODULE_MAX		2
 #define SCTPCTL_DEFAULT_CC_MODULE_DEFAULT	0
 
 /* RS - default stream scheduling module sysctl */
 #define SCTPCTL_DEFAULT_SS_MODULE_DESC		"Default stream scheduling module"
 #define SCTPCTL_DEFAULT_SS_MODULE_MIN		0
 #define SCTPCTL_DEFAULT_SS_MODULE_MAX		5
 #define SCTPCTL_DEFAULT_SS_MODULE_DEFAULT	0
 
 /* RRS - default fragment interleave */
 #define SCTPCTL_DEFAULT_FRAG_INTERLEAVE_DESC	"Default fragment interleave level"
 #define SCTPCTL_DEFAULT_FRAG_INTERLEAVE_MIN	0
 #define SCTPCTL_DEFAULT_FRAG_INTERLEAVE_MAX	2
 #define SCTPCTL_DEFAULT_FRAG_INTERLEAVE_DEFAULT	1
 
 /* mobility_base: Enable SCTP mobility support */
 #define SCTPCTL_MOBILITY_BASE_DESC	"Enable SCTP base mobility"
 #define SCTPCTL_MOBILITY_BASE_MIN	0
 #define SCTPCTL_MOBILITY_BASE_MAX	1
 #define SCTPCTL_MOBILITY_BASE_DEFAULT	0
 
 /* mobility_fasthandoff: Enable SCTP fast handoff support */
 #define SCTPCTL_MOBILITY_FASTHANDOFF_DESC	"Enable SCTP fast handoff"
 #define SCTPCTL_MOBILITY_FASTHANDOFF_MIN	0
 #define SCTPCTL_MOBILITY_FASTHANDOFF_MAX	1
 #define SCTPCTL_MOBILITY_FASTHANDOFF_DEFAULT	0
 
 /* Enable SCTP/UDP tunneling port */
 #define SCTPCTL_UDP_TUNNELING_PORT_DESC		"Set the SCTP/UDP tunneling port"
 #define SCTPCTL_UDP_TUNNELING_PORT_MIN		0
 #define SCTPCTL_UDP_TUNNELING_PORT_MAX		65535
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #define SCTPCTL_UDP_TUNNELING_PORT_DEFAULT	0
 #else
 #define SCTPCTL_UDP_TUNNELING_PORT_DEFAULT	SCTP_OVER_UDP_TUNNELING_PORT
 #endif
 
 /* Enable sending of the SACK-IMMEDIATELY bit */
 #define SCTPCTL_SACK_IMMEDIATELY_ENABLE_DESC	"Enable sending of the SACK-IMMEDIATELY-bit"
 #define SCTPCTL_SACK_IMMEDIATELY_ENABLE_MIN	0
 #define SCTPCTL_SACK_IMMEDIATELY_ENABLE_MAX	1
 #define SCTPCTL_SACK_IMMEDIATELY_ENABLE_DEFAULT	SCTPCTL_SACK_IMMEDIATELY_ENABLE_MAX
 
 /* Enable sending of the NAT-FRIENDLY message */
 #define SCTPCTL_NAT_FRIENDLY_INITS_DESC	"Enable sending of the nat-friendly SCTP option on INITs"
 #define SCTPCTL_NAT_FRIENDLY_INITS_MIN	0
 #define SCTPCTL_NAT_FRIENDLY_INITS_MAX	1
 #define SCTPCTL_NAT_FRIENDLY_INITS_DEFAULT	SCTPCTL_NAT_FRIENDLY_INITS_MIN
 
 /* Vtag time wait in seconds */
 #define SCTPCTL_TIME_WAIT_DESC	"Vtag time wait time in seconds, 0 disables it"
 #define SCTPCTL_TIME_WAIT_MIN	0
 #define SCTPCTL_TIME_WAIT_MAX	0xffffffff
 #define SCTPCTL_TIME_WAIT_DEFAULT	SCTP_TIME_WAIT
 
 /* Enable Send/Receive buffer splitting */
 #define SCTPCTL_BUFFER_SPLITTING_DESC		"Enable send/receive buffer splitting"
 #define SCTPCTL_BUFFER_SPLITTING_MIN		0
 #define SCTPCTL_BUFFER_SPLITTING_MAX		0x3
 #define SCTPCTL_BUFFER_SPLITTING_DEFAULT	SCTPCTL_BUFFER_SPLITTING_MIN
 
 /* Initial congestion window in MTUs */
 #define SCTPCTL_INITIAL_CWND_DESC	"Defines the initial congestion window size in MTUs"
 #define SCTPCTL_INITIAL_CWND_MIN	0
 #define SCTPCTL_INITIAL_CWND_MAX	0xffffffff
 #define SCTPCTL_INITIAL_CWND_DEFAULT	3
 
 /* rttvar smooth avg for bw calc  */
 #define SCTPCTL_RTTVAR_BW_DESC	"Shift amount DCCC uses for bw smoothing on rtt calc"
 #define SCTPCTL_RTTVAR_BW_MIN	0
 #define SCTPCTL_RTTVAR_BW_MAX	32
 #define SCTPCTL_RTTVAR_BW_DEFAULT	4
 
 /* rttvar smooth avg for bw calc  */
 #define SCTPCTL_RTTVAR_RTT_DESC	"Shift amount DCCC uses for rtt smoothing on rtt calc"
 #define SCTPCTL_RTTVAR_RTT_MIN	0
 #define SCTPCTL_RTTVAR_RTT_MAX	32
 #define SCTPCTL_RTTVAR_RTT_DEFAULT	5
 
 #define SCTPCTL_RTTVAR_EQRET_DESC	"Whether DCCC increases cwnd when the rtt and bw are unchanged"
 #define SCTPCTL_RTTVAR_EQRET_MIN	0
 #define SCTPCTL_RTTVAR_EQRET_MAX	1
 #define SCTPCTL_RTTVAR_EQRET_DEFAULT	0
 
 #define SCTPCTL_RTTVAR_STEADYS_DESC	"Number of identical bw measurements DCCC takes to try step down of cwnd"
 #define SCTPCTL_RTTVAR_STEADYS_MIN	0
 #define SCTPCTL_RTTVAR_STEADYS_MAX	0xFFFF
 #define SCTPCTL_RTTVAR_STEADYS_DEFAULT	20 /* 0 means disable feature */
 
 #define SCTPCTL_RTTVAR_DCCCECN_DESC	"Enable ECN for DCCC."
 #define SCTPCTL_RTTVAR_DCCCECN_MIN	0
 #define SCTPCTL_RTTVAR_DCCCECN_MAX	1
 #define SCTPCTL_RTTVAR_DCCCECN_DEFAULT	1 /* 0 means disable feature */
 
 #define SCTPCTL_BLACKHOLE_DESC		"Enable SCTP blackholing, see blackhole(4) for more details"
 #define SCTPCTL_BLACKHOLE_MIN		0
 #define SCTPCTL_BLACKHOLE_MAX		2
 #define SCTPCTL_BLACKHOLE_DEFAULT	SCTPCTL_BLACKHOLE_MIN
 
 /* sendall_limit: Maximum message with SCTP_SENDALL */
 #define SCTPCTL_SENDALL_LIMIT_DESC	"Maximum size of a message send with SCTP_SENDALL"
 #define SCTPCTL_SENDALL_LIMIT_MIN	0
 #define SCTPCTL_SENDALL_LIMIT_MAX	0xFFFFFFFF
 #define SCTPCTL_SENDALL_LIMIT_DEFAULT	1432
 
 #define SCTPCTL_DIAG_INFO_CODE_DESC	"Diagnostic information error cause code"
 #define SCTPCTL_DIAG_INFO_CODE_MIN	0
 #define SCTPCTL_DIAG_INFO_CODE_MAX	65535
 #define SCTPCTL_DIAG_INFO_CODE_DEFAULT	0
 
 #if defined(SCTP_DEBUG)
 /* debug: Configure debug output */
 #define SCTPCTL_DEBUG_DESC	"Configure debug output"
 #define SCTPCTL_DEBUG_MIN	0
 #define SCTPCTL_DEBUG_MAX	0xFFFFFFFF
 #define SCTPCTL_DEBUG_DEFAULT	0
 #endif
 
 #if defined(__APPLE__) && !defined(__Userspace__)
 #define SCTPCTL_MAIN_TIMER_DESC		"Main timer interval in ms"
 #define SCTPCTL_MAIN_TIMER_MIN		1
 #define SCTPCTL_MAIN_TIMER_MAX		0xFFFFFFFF
 #define SCTPCTL_MAIN_TIMER_DEFAULT	10
 
 #define SCTPCTL_IGNORE_VMWARE_INTERFACES_DESC		"Ignore VMware Interfaces"
 #define SCTPCTL_IGNORE_VMWARE_INTERFACES_MIN		0
 #define SCTPCTL_IGNORE_VMWARE_INTERFACES_MAX		1
 #define SCTPCTL_IGNORE_VMWARE_INTERFACES_DEFAULT	SCTPCTL_IGNORE_VMWARE_INTERFACES_MAX
 
 #define SCTPCTL_OUTPUT_UNLOCKED_DESC	"Unlock socket when sending packets down to IP"
 #define SCTPCTL_OUTPUT_UNLOCKED_MIN	0
 #define SCTPCTL_OUTPUT_UNLOCKED_MAX	1
 #define SCTPCTL_OUTPUT_UNLOCKED_DEFAULT	SCTPCTL_OUTPUT_UNLOCKED_MIN
 
 #define	SCTPCTL_ADDR_WATCHDOG_LIMIT_DESC	"Address watchdog limit"
 #define	SCTPCTL_ADDR_WATCHDOG_LIMIT_MIN		0
 #define	SCTPCTL_ADDR_WATCHDOG_LIMIT_MAX		0xFFFFFFFF
 #define	SCTPCTL_ADDR_WATCHDOG_LIMIT_DEFAULT	SCTPCTL_ADDR_WATCHDOG_LIMIT_MIN
 
 #define	SCTPCTL_VTAG_WATCHDOG_LIMIT_DESC	"VTag watchdog limit"
 #define	SCTPCTL_VTAG_WATCHDOG_LIMIT_MIN		0
 #define	SCTPCTL_VTAG_WATCHDOG_LIMIT_MAX		0xFFFFFFFF
 #define	SCTPCTL_VTAG_WATCHDOG_LIMIT_DEFAULT	SCTPCTL_VTAG_WATCHDOG_LIMIT_MIN
 
 #endif
 #if defined(_KERNEL) || defined(__Userspace__)
 #if defined(__FreeBSD__) || defined(__APPLE__) || defined(__Userspace__)
 #if defined(SYSCTL_DECL)
diff --git a/usrsctplib/netinet/sctp_usrreq.c b/usrsctplib/netinet/sctp_usrreq.c
index f287f30..56e5ba8 100755
--- a/usrsctplib/netinet/sctp_usrreq.c
+++ b/usrsctplib/netinet/sctp_usrreq.c
@@ -34,36 +34,36 @@
 
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <sys/cdefs.h>
-__FBSDID("$FreeBSD: head/sys/netinet/sctp_usrreq.c 366480 2020-10-06 10:41:04Z tuexen $");
+__FBSDID("$FreeBSD: head/sys/netinet/sctp_usrreq.c 366750 2020-10-16 10:44:48Z tuexen $");
 #endif
 
 #include <netinet/sctp_os.h>
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <sys/proc.h>
 #endif
 #include <netinet/sctp_pcb.h>
 #include <netinet/sctp_header.h>
 #include <netinet/sctp_var.h>
 #ifdef INET6
 #include <netinet6/sctp6_var.h>
 #endif
 #include <netinet/sctp_sysctl.h>
 #include <netinet/sctp_output.h>
 #include <netinet/sctp_uio.h>
 #include <netinet/sctp_asconf.h>
 #include <netinet/sctputil.h>
 #include <netinet/sctp_indata.h>
 #include <netinet/sctp_timer.h>
 #include <netinet/sctp_auth.h>
 #include <netinet/sctp_bsd_addr.h>
 #if defined(__Userspace__)
 #include <netinet/sctp_callout.h>
 #else
 #include <netinet/udp.h>
 #endif
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 #include <sys/eventhandler.h>
 #endif
 #if defined(HAVE_SCTP_PEELOFF_SOCKOPT)
 #include <netinet/sctp_peeloff.h>
 #endif				/* HAVE_SCTP_PEELOFF_SOCKOPT */
@@ -4415,3310 +4415,3313 @@ static int
 #endif
 sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 	    void *p)
 {
 	int error, set_opt;
 	uint32_t *mopt;
 	struct sctp_tcb *stcb = NULL;
 	struct sctp_inpcb *inp = NULL;
 	uint32_t vrf_id;
 
 	if (optval == NULL) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
 	inp = (struct sctp_inpcb *)so->so_pcb;
 	if (inp == NULL) {
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
 	vrf_id = inp->def_vrf_id;
 
 	error = 0;
 	switch (optname) {
 	case SCTP_NODELAY:
 	case SCTP_AUTOCLOSE:
 	case SCTP_AUTO_ASCONF:
 	case SCTP_EXPLICIT_EOR:
 	case SCTP_DISABLE_FRAGMENTS:
 	case SCTP_USE_EXT_RCVINFO:
 	case SCTP_I_WANT_MAPPED_V4_ADDR:
 		/* copy in the option value */
 		SCTP_CHECK_AND_CAST(mopt, optval, uint32_t, optsize);
 		set_opt = 0;
 		if (error)
 			break;
 		switch (optname) {
 		case SCTP_DISABLE_FRAGMENTS:
 			set_opt = SCTP_PCB_FLAGS_NO_FRAGMENT;
 			break;
 		case SCTP_AUTO_ASCONF:
 			/*
 			 * NOTE: we don't really support this flag
 			 */
 			if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) {
 				/* only valid for bound all sockets */
 				if ((SCTP_BASE_SYSCTL(sctp_auto_asconf) == 0) &&
 				    (*mopt != 0)) {
 					/* forbidden by admin */
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EPERM);
 					return (EPERM);
 				}
 				set_opt = SCTP_PCB_FLAGS_AUTO_ASCONF;
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				return (EINVAL);
 			}
 			break;
 		case SCTP_EXPLICIT_EOR:
 			set_opt = SCTP_PCB_FLAGS_EXPLICIT_EOR;
 			break;
 		case SCTP_USE_EXT_RCVINFO:
 			set_opt = SCTP_PCB_FLAGS_EXT_RCVINFO;
 			break;
 		case SCTP_I_WANT_MAPPED_V4_ADDR:
 			if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) {
 				set_opt = SCTP_PCB_FLAGS_NEEDS_MAPPED_V4;
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				return (EINVAL);
 			}
 			break;
 		case SCTP_NODELAY:
 			set_opt = SCTP_PCB_FLAGS_NODELAY;
 			break;
 		case SCTP_AUTOCLOSE:
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				return (EINVAL);
 			}
 			set_opt = SCTP_PCB_FLAGS_AUTOCLOSE;
 			/*
 			 * The value is in ticks. Note this does not effect
 			 * old associations, only new ones.
 			 */
 			inp->sctp_ep.auto_close_time = sctp_secs_to_ticks(*mopt);
 			break;
 		}
 		SCTP_INP_WLOCK(inp);
 		if (*mopt != 0) {
 			sctp_feature_on(inp, set_opt);
 		} else {
 			sctp_feature_off(inp, set_opt);
 		}
 		SCTP_INP_WUNLOCK(inp);
 		break;
 	case SCTP_REUSE_PORT:
 	{
 		SCTP_CHECK_AND_CAST(mopt, optval, uint32_t, optsize);
 		if ((inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND)  == 0) {
 			/* Can't set it after we are bound */
 			error = EINVAL;
 			break;
 		}
 		if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE)) {
 			/* Can't do this for a 1-m socket */
 			error = EINVAL;
 			break;
 		}
 		if (optval)
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_PORTREUSE);
 		else
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_PORTREUSE);
 		break;
 	}
 	case SCTP_PARTIAL_DELIVERY_POINT:
 	{
 		uint32_t *value;
 
 		SCTP_CHECK_AND_CAST(value, optval, uint32_t, optsize);
 		if (*value > SCTP_SB_LIMIT_RCV(so)) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		inp->partial_delivery_point = *value;
 		break;
 	}
 	case SCTP_FRAGMENT_INTERLEAVE:
 		/* not yet until we re-write sctp_recvmsg() */
 	{
 		uint32_t *level;
 
 		SCTP_CHECK_AND_CAST(level, optval, uint32_t, optsize);
 		if (*level == SCTP_FRAG_LEVEL_2) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE);
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS);
 		} else if (*level == SCTP_FRAG_LEVEL_1) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE);
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS);
 		} else if (*level == SCTP_FRAG_LEVEL_0) {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE);
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS);
 
 		} else {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 		}
 		break;
 	}
 	case SCTP_INTERLEAVING_SUPPORTED:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				if (av->assoc_value == 0) {
 					inp->idata_supported = 0;
 				} else {
 					if ((sctp_is_feature_on(inp, SCTP_PCB_FLAGS_FRAG_INTERLEAVE))  &&
 					    (sctp_is_feature_on(inp, SCTP_PCB_FLAGS_INTERLEAVE_STRMS))) {
 						inp->idata_supported = 1;
 					} else {
 						/* Must have Frag interleave and stream interleave on */
 						SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 						error = EINVAL;
 					}
 				}
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_CMT_ON_OFF:
 		if (SCTP_BASE_SYSCTL(sctp_cmt_on_off)) {
 			struct sctp_assoc_value *av;
 
 			SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 			if (av->assoc_value > SCTP_CMT_MAX) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
 			SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 			if (stcb) {
 				stcb->asoc.sctp_cmt_on_off = av->assoc_value;
 				SCTP_TCB_UNLOCK(stcb);
 			} else {
 				if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 				    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 				    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 				     ((av->assoc_id == SCTP_FUTURE_ASSOC) ||
 				      (av->assoc_id == SCTP_ALL_ASSOC)))) {
 					SCTP_INP_WLOCK(inp);
 					inp->sctp_cmt_on_off = av->assoc_value;
 					SCTP_INP_WUNLOCK(inp);
 				}
 				if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 				    ((av->assoc_id == SCTP_CURRENT_ASSOC) ||
 				     (av->assoc_id == SCTP_ALL_ASSOC))) {
 					SCTP_INP_RLOCK(inp);
 					LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 						SCTP_TCB_LOCK(stcb);
 						stcb->asoc.sctp_cmt_on_off = av->assoc_value;
 						SCTP_TCB_UNLOCK(stcb);
 					}
 					SCTP_INP_RUNLOCK(inp);
 				}
 			}
 		} else {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOPROTOOPT);
 			error = ENOPROTOOPT;
 		}
 		break;
 	case SCTP_PLUGGABLE_CC:
 	{
 		struct sctp_assoc_value *av;
 		struct sctp_nets *net;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		if ((av->assoc_value != SCTP_CC_RFC2581) &&
 		    (av->assoc_value != SCTP_CC_HSTCP) &&
 		    (av->assoc_value != SCTP_CC_HTCP) &&
 		    (av->assoc_value != SCTP_CC_RTCC)) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 		if (stcb) {
 			stcb->asoc.cc_functions = sctp_cc_functions[av->assoc_value];
 			stcb->asoc.congestion_control_module = av->assoc_value;
 			if (stcb->asoc.cc_functions.sctp_set_initial_cc_param != NULL) {
 				TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 					stcb->asoc.cc_functions.sctp_set_initial_cc_param(stcb, net);
 				}
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((av->assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (av->assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				inp->sctp_ep.sctp_default_cc_module = av->assoc_value;
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((av->assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (av->assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					stcb->asoc.cc_functions = sctp_cc_functions[av->assoc_value];
 					stcb->asoc.congestion_control_module = av->assoc_value;
 					if (stcb->asoc.cc_functions.sctp_set_initial_cc_param != NULL) {
 						TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 							stcb->asoc.cc_functions.sctp_set_initial_cc_param(stcb, net);
 						}
 					}
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_CC_OPTION:
 	{
 		struct sctp_cc_option *cc_opt;
 
 		SCTP_CHECK_AND_CAST(cc_opt, optval, struct sctp_cc_option, optsize);
 		SCTP_FIND_STCB(inp, stcb, cc_opt->aid_value.assoc_id);
 		if (stcb == NULL) {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    (cc_opt->aid_value.assoc_id == SCTP_CURRENT_ASSOC)) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					if (stcb->asoc.cc_functions.sctp_cwnd_socket_option) {
 						(*stcb->asoc.cc_functions.sctp_cwnd_socket_option)(stcb, 1, cc_opt);
 					}
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			} else {
 				error = EINVAL;
 			}
 		} else {
 			if (stcb->asoc.cc_functions.sctp_cwnd_socket_option == NULL) {
 				error = ENOTSUP;
 			} else {
 				error = (*stcb->asoc.cc_functions.sctp_cwnd_socket_option)(stcb, 1,
 											   cc_opt);
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		}
 		break;
 	}
 	case SCTP_PLUGGABLE_SS:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		if ((av->assoc_value != SCTP_SS_DEFAULT) &&
 		    (av->assoc_value != SCTP_SS_ROUND_ROBIN) &&
 		    (av->assoc_value != SCTP_SS_ROUND_ROBIN_PACKET) &&
 		    (av->assoc_value != SCTP_SS_PRIORITY) &&
 		    (av->assoc_value != SCTP_SS_FAIR_BANDWITH) &&
 		    (av->assoc_value != SCTP_SS_FIRST_COME)) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 		if (stcb) {
 			SCTP_TCB_SEND_LOCK(stcb);
 			stcb->asoc.ss_functions.sctp_ss_clear(stcb, &stcb->asoc, 1, 1);
 			stcb->asoc.ss_functions = sctp_ss_functions[av->assoc_value];
 			stcb->asoc.stream_scheduling_module = av->assoc_value;
 			stcb->asoc.ss_functions.sctp_ss_init(stcb, &stcb->asoc, 1);
 			SCTP_TCB_SEND_UNLOCK(stcb);
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((av->assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (av->assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				inp->sctp_ep.sctp_default_ss_module = av->assoc_value;
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((av->assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (av->assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					SCTP_TCB_SEND_LOCK(stcb);
 					stcb->asoc.ss_functions.sctp_ss_clear(stcb, &stcb->asoc, 1, 1);
 					stcb->asoc.ss_functions = sctp_ss_functions[av->assoc_value];
 					stcb->asoc.stream_scheduling_module = av->assoc_value;
 					stcb->asoc.ss_functions.sctp_ss_init(stcb, &stcb->asoc, 1);
 					SCTP_TCB_SEND_UNLOCK(stcb);
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_SS_VALUE:
 	{
 		struct sctp_stream_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_stream_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 		if (stcb) {
 			if ((av->stream_id >= stcb->asoc.streamoutcnt) ||
 			    (stcb->asoc.ss_functions.sctp_ss_set_value(stcb, &stcb->asoc, &stcb->asoc.strmout[av->stream_id],
 			                                               av->stream_value) < 0)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    (av->assoc_id == SCTP_CURRENT_ASSOC)) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					if (av->stream_id < stcb->asoc.streamoutcnt) {
 						stcb->asoc.ss_functions.sctp_ss_set_value(stcb,
 						                                          &stcb->asoc,
 						                                          &stcb->asoc.strmout[av->stream_id],
 						                                          av->stream_value);
 					}
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			} else {
 				/* Can't set stream value without association */
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_CLR_STAT_LOG:
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EOPNOTSUPP);
 		error = EOPNOTSUPP;
 		break;
 	case SCTP_CONTEXT:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			stcb->asoc.context = av->assoc_value;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((av->assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (av->assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				inp->sctp_context = av->assoc_value;
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((av->assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (av->assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					stcb->asoc.context = av->assoc_value;
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_VRF_ID:
 	{
 		uint32_t *default_vrfid;
 #ifdef SCTP_MVRF
 		int i;
 #endif
 		SCTP_CHECK_AND_CAST(default_vrfid, optval, uint32_t, optsize);
 		if (*default_vrfid > SCTP_MAX_VRF_ID) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 #ifdef SCTP_MVRF
 		for (i = 0; i < inp->num_vrfs; i++) {
 			/* The VRF must be in the VRF list */
 			if (*default_vrfid == inp->m_vrf_ids[i]) {
 				SCTP_INP_WLOCK(inp);
 				inp->def_vrf_id = *default_vrfid;
 				SCTP_INP_WUNLOCK(inp);
 				goto sctp_done;
 			}
 		}
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		error = EINVAL;
 #else
 		inp->def_vrf_id = *default_vrfid;
 #endif
 #ifdef SCTP_MVRF
 	sctp_done:
 #endif
 		break;
 	}
 	case SCTP_DEL_VRF_ID:
 	{
 #ifdef SCTP_MVRF
 		uint32_t *del_vrfid;
 		int i, fnd = 0;
 
 		SCTP_CHECK_AND_CAST(del_vrfid, optval, uint32_t, optsize);
 		if (*del_vrfid > SCTP_MAX_VRF_ID) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		if (inp->num_vrfs == 1) {
 			/* Can't delete last one */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		if ((inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) == 0) {
 			/* Can't add more once you are bound */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		SCTP_INP_WLOCK(inp);
 		for (i = 0; i < inp->num_vrfs; i++) {
 			if (*del_vrfid == inp->m_vrf_ids[i]) {
 				fnd = 1;
 				break;
 			}
 		}
 		if (!fnd) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		if (i != (inp->num_vrfs - 1)) {
 			/* Take bottom one and move to this slot */
 			inp->m_vrf_ids[i] = inp->m_vrf_ids[(inp->num_vrfs-1)];
 		}
 		if (*del_vrfid == inp->def_vrf_id) {
 			/* Take the first one as the new default */
 			inp->def_vrf_id = inp->m_vrf_ids[0];
 		}
 		/* Drop the number by one killing last one */
 		inp->num_vrfs--;
 #else
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EOPNOTSUPP);
 		error = EOPNOTSUPP;
 #endif
 		break;
 	}
 	case SCTP_ADD_VRF_ID:
 	{
 #ifdef SCTP_MVRF
 		uint32_t *add_vrfid;
 		int i;
 
 		SCTP_CHECK_AND_CAST(add_vrfid, optval, uint32_t, optsize);
 		if (*add_vrfid > SCTP_MAX_VRF_ID) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		if ((inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) == 0) {
 			/* Can't add more once you are bound */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		SCTP_INP_WLOCK(inp);
 		/* Verify its not already here */
 		for (i = 0; i < inp->num_vrfs; i++) {
 			if (*add_vrfid == inp->m_vrf_ids[i]) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EALREADY);
 				error = EALREADY;
 				SCTP_INP_WUNLOCK(inp);
 				break;
 			}
 		}
 		if ((inp->num_vrfs + 1) > inp->vrf_size) {
 			/* need to grow array */
 			uint32_t *tarray;
 			SCTP_MALLOC(tarray, uint32_t *,
 				    (sizeof(uint32_t) * (inp->vrf_size + SCTP_DEFAULT_VRF_SIZE)),
 				    SCTP_M_MVRF);
 			if (tarray == NULL) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOMEM);
 				error = ENOMEM;
 				SCTP_INP_WUNLOCK(inp);
 				break;
 			}
 			memcpy(tarray, inp->m_vrf_ids, (sizeof(uint32_t) * inp->vrf_size));
 			SCTP_FREE(inp->m_vrf_ids, SCTP_M_MVRF);
 			inp->m_vrf_ids = tarray;
 			inp->vrf_size += SCTP_DEFAULT_VRF_SIZE;
 		}
 		inp->m_vrf_ids[inp->num_vrfs] = *add_vrfid;
 		inp->num_vrfs++;
 		SCTP_INP_WUNLOCK(inp);
 #else
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EOPNOTSUPP);
 		error = EOPNOTSUPP;
 #endif
 		break;
 	}
 	case SCTP_DELAYED_SACK:
 	{
 		struct sctp_sack_info *sack;
 
 		SCTP_CHECK_AND_CAST(sack, optval, struct sctp_sack_info, optsize);
 		SCTP_FIND_STCB(inp, stcb, sack->sack_assoc_id);
 		if (sack->sack_delay) {
 			if (sack->sack_delay > SCTP_MAX_SACK_DELAY) {
 				error = EINVAL;
 				if (stcb != NULL) {
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				break;
 			}
 		}
 		if (stcb) {
 			if (sack->sack_delay) {
 				stcb->asoc.delayed_ack = sack->sack_delay;
 			}
 			if (sack->sack_freq) {
 				stcb->asoc.sack_freq = sack->sack_freq;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((sack->sack_assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (sack->sack_assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				if (sack->sack_delay) {
 					inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_RECV] = sctp_msecs_to_ticks(sack->sack_delay);
 				}
 				if (sack->sack_freq) {
 					inp->sctp_ep.sctp_sack_freq = sack->sack_freq;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((sack->sack_assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (sack->sack_assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					if (sack->sack_delay) {
 						stcb->asoc.delayed_ack = sack->sack_delay;
 					}
 					if (sack->sack_freq) {
 						stcb->asoc.sack_freq = sack->sack_freq;
 					}
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_AUTH_CHUNK:
 	{
 		struct sctp_authchunk *sauth;
 
 		SCTP_CHECK_AND_CAST(sauth, optval, struct sctp_authchunk, optsize);
 
 		SCTP_INP_WLOCK(inp);
 		if (sctp_auth_add_chunk(sauth->sauth_chunk, inp->sctp_ep.local_auth_chunks)) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 		} else {
 			inp->auth_supported = 1;
 		}
 		SCTP_INP_WUNLOCK(inp);
 		break;
 	}
 	case SCTP_AUTH_KEY:
 	{
 		struct sctp_authkey *sca;
 		struct sctp_keyhead *shared_keys;
 		sctp_sharedkey_t *shared_key;
 		sctp_key_t *key = NULL;
 		size_t size;
 
 		SCTP_CHECK_AND_CAST(sca, optval, struct sctp_authkey, optsize);
 		if (sca->sca_keylength == 0) {
 			size = optsize - sizeof(struct sctp_authkey);
 		} else {
 			if (sca->sca_keylength + sizeof(struct sctp_authkey) <= optsize) {
 				size = sca->sca_keylength;
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
 		}
 		SCTP_FIND_STCB(inp, stcb, sca->sca_assoc_id);
 
 		if (stcb) {
 			shared_keys = &stcb->asoc.shared_keys;
 			/* clear the cached keys for this key id */
 			sctp_clear_cachedkeys(stcb, sca->sca_keynumber);
 			/*
 			 * create the new shared key and
 			 * insert/replace it
 			 */
 			if (size > 0) {
 				key = sctp_set_key(sca->sca_key, (uint32_t) size);
 				if (key == NULL) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOMEM);
 					error = ENOMEM;
 					SCTP_TCB_UNLOCK(stcb);
 					break;
 				}
 			}
 			shared_key = sctp_alloc_sharedkey();
 			if (shared_key == NULL) {
 				sctp_free_key(key);
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOMEM);
 				error = ENOMEM;
 				SCTP_TCB_UNLOCK(stcb);
 				break;
 			}
 			shared_key->key = key;
 			shared_key->keyid = sca->sca_keynumber;
 			error = sctp_insert_sharedkey(shared_keys, shared_key);
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((sca->sca_assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (sca->sca_assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				shared_keys = &inp->sctp_ep.shared_keys;
 				/*
 				 * clear the cached keys on all assocs for
 				 * this key id
 				 */
 				sctp_clear_cachedkeys_ep(inp, sca->sca_keynumber);
 				/*
 				 * create the new shared key and
 				 * insert/replace it
 				 */
 				if (size > 0) {
 					key = sctp_set_key(sca->sca_key, (uint32_t) size);
 					if (key == NULL) {
 						SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOMEM);
 						error = ENOMEM;
 						SCTP_INP_WUNLOCK(inp);
 						break;
 					}
 				}
 				shared_key = sctp_alloc_sharedkey();
 				if (shared_key == NULL) {
 					sctp_free_key(key);
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOMEM);
 					error = ENOMEM;
 					SCTP_INP_WUNLOCK(inp);
 					break;
 				}
 				shared_key->key = key;
 				shared_key->keyid = sca->sca_keynumber;
 				error = sctp_insert_sharedkey(shared_keys, shared_key);
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((sca->sca_assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (sca->sca_assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					shared_keys = &stcb->asoc.shared_keys;
 					/* clear the cached keys for this key id */
 					sctp_clear_cachedkeys(stcb, sca->sca_keynumber);
 					/*
 					 * create the new shared key and
 					 * insert/replace it
 					 */
 					if (size > 0) {
 						key = sctp_set_key(sca->sca_key, (uint32_t) size);
 						if (key == NULL) {
 							SCTP_TCB_UNLOCK(stcb);
 							continue;
 						}
 					}
 					shared_key = sctp_alloc_sharedkey();
 					if (shared_key == NULL) {
 						sctp_free_key(key);
 						SCTP_TCB_UNLOCK(stcb);
 						continue;
 					}
 					shared_key->key = key;
 					shared_key->keyid = sca->sca_keynumber;
 					error = sctp_insert_sharedkey(shared_keys, shared_key);
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_HMAC_IDENT:
 	{
 		struct sctp_hmacalgo *shmac;
 		sctp_hmaclist_t *hmaclist;
 		uint16_t hmacid;
 		uint32_t i;
 
 		SCTP_CHECK_AND_CAST(shmac, optval, struct sctp_hmacalgo, optsize);
 		if ((optsize < sizeof(struct sctp_hmacalgo) + shmac->shmac_number_of_idents * sizeof(uint16_t)) ||
 		    (shmac->shmac_number_of_idents > 0xffff)) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 
 		hmaclist = sctp_alloc_hmaclist((uint16_t)shmac->shmac_number_of_idents);
 		if (hmaclist == NULL) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOMEM);
 			error = ENOMEM;
 			break;
 		}
 		for (i = 0; i < shmac->shmac_number_of_idents; i++) {
 			hmacid = shmac->shmac_idents[i];
 			if (sctp_auth_add_hmacid(hmaclist, hmacid)) {
 				/* invalid HMACs were found */;
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				sctp_free_hmaclist(hmaclist);
 				goto sctp_set_hmac_done;
 			}
 		}
 		for (i = 0; i < hmaclist->num_algo; i++) {
 			if (hmaclist->hmac[i] == SCTP_AUTH_HMAC_ID_SHA1) {
 				/* already in list */
 				break;
 			}
 		}
 		if (i == hmaclist->num_algo) {
 			/* not found in list */
 			sctp_free_hmaclist(hmaclist);
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		/* set it on the endpoint */
 		SCTP_INP_WLOCK(inp);
 		if (inp->sctp_ep.local_hmacs)
 			sctp_free_hmaclist(inp->sctp_ep.local_hmacs);
 		inp->sctp_ep.local_hmacs = hmaclist;
 		SCTP_INP_WUNLOCK(inp);
 	sctp_set_hmac_done:
 		break;
 	}
 	case SCTP_AUTH_ACTIVE_KEY:
 	{
 		struct sctp_authkeyid *scact;
 
 		SCTP_CHECK_AND_CAST(scact, optval, struct sctp_authkeyid, optsize);
 		SCTP_FIND_STCB(inp, stcb, scact->scact_assoc_id);
 
 		/* set the active key on the right place */
 		if (stcb) {
 			/* set the active key on the assoc */
 			if (sctp_auth_setactivekey(stcb,
 						   scact->scact_keynumber)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL,
 						    SCTP_FROM_SCTP_USRREQ,
 						    EINVAL);
 				error = EINVAL;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((scact->scact_assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (scact->scact_assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				if (sctp_auth_setactivekey_ep(inp, scact->scact_keynumber)) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((scact->scact_assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (scact->scact_assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					sctp_auth_setactivekey(stcb, scact->scact_keynumber);
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_AUTH_DELETE_KEY:
 	{
 		struct sctp_authkeyid *scdel;
 
 		SCTP_CHECK_AND_CAST(scdel, optval, struct sctp_authkeyid, optsize);
 		SCTP_FIND_STCB(inp, stcb, scdel->scact_assoc_id);
 
 		/* delete the key from the right place */
 		if (stcb) {
 			if (sctp_delete_sharedkey(stcb, scdel->scact_keynumber)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((scdel->scact_assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (scdel->scact_assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				if (sctp_delete_sharedkey_ep(inp, scdel->scact_keynumber)) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((scdel->scact_assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (scdel->scact_assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					sctp_delete_sharedkey(stcb, scdel->scact_keynumber);
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_AUTH_DEACTIVATE_KEY:
 	{
 		struct sctp_authkeyid *keyid;
 
 		SCTP_CHECK_AND_CAST(keyid, optval, struct sctp_authkeyid, optsize);
 		SCTP_FIND_STCB(inp, stcb, keyid->scact_assoc_id);
 
 		/* deactivate the key from the right place */
 		if (stcb) {
 			if (sctp_deact_sharedkey(stcb, keyid->scact_keynumber)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((keyid->scact_assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (keyid->scact_assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				if (sctp_deact_sharedkey_ep(inp, keyid->scact_keynumber)) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((keyid->scact_assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (keyid->scact_assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					sctp_deact_sharedkey(stcb, keyid->scact_keynumber);
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_ENABLE_STREAM_RESET:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		if (av->assoc_value & (~SCTP_ENABLE_VALUE_MASK)) {
 		        SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 		if (stcb) {
 			stcb->asoc.local_strreset_support = (uint8_t)av->assoc_value;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((av->assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (av->assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				inp->local_strreset_support = (uint8_t)av->assoc_value;
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((av->assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (av->assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					stcb->asoc.local_strreset_support = (uint8_t)av->assoc_value;
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_RESET_STREAMS:
 	{
 		struct sctp_reset_streams *strrst;
 		int i, send_out = 0;
 		int send_in = 0;
 
 		SCTP_CHECK_AND_CAST(strrst, optval, struct sctp_reset_streams, optsize);
 		SCTP_FIND_STCB(inp, stcb, strrst->srs_assoc_id);
 		if (stcb == NULL) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
 		if (stcb->asoc.reconfig_supported == 0) {
 			/*
 			 * Peer does not support the chunk type.
 			 */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EOPNOTSUPP);
 			error = EOPNOTSUPP;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if (SCTP_GET_STATE(stcb) != SCTP_STATE_OPEN) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if (sizeof(struct sctp_reset_streams) +
 		    strrst->srs_number_streams * sizeof(uint16_t) > optsize) {
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if (strrst->srs_flags & SCTP_STREAM_RESET_INCOMING) {
 			send_in = 1;
 			if (stcb->asoc.stream_reset_outstanding) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EALREADY);
 				error = EALREADY;
 				SCTP_TCB_UNLOCK(stcb);
 				break;
 			}
 		}
 		if (strrst->srs_flags & SCTP_STREAM_RESET_OUTGOING) {
 			send_out = 1;
 		}
 		if ((strrst->srs_number_streams > SCTP_MAX_STREAMS_AT_ONCE_RESET) && send_in) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOMEM);
 			error = ENOMEM;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if ((send_in == 0) && (send_out == 0)) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		for (i = 0; i < strrst->srs_number_streams; i++) {
 			if ((send_in) &&
 			    (strrst->srs_stream_list[i] >= stcb->asoc.streamincnt)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
 			if ((send_out) &&
 			    (strrst->srs_stream_list[i] >= stcb->asoc.streamoutcnt)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
 		}
 		if (error) {
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if (send_out) {
 			int cnt;
 			uint16_t strm;
 			if (strrst->srs_number_streams) {
 				for (i = 0, cnt = 0; i < strrst->srs_number_streams; i++) {
 					strm = strrst->srs_stream_list[i];
 					if (stcb->asoc.strmout[strm].state == SCTP_STREAM_OPEN) {
 						stcb->asoc.strmout[strm].state = SCTP_STREAM_RESET_PENDING;
 						cnt++;
 					}
 				}
 			} else {
 				/* Its all */
 				for (i = 0, cnt = 0; i < stcb->asoc.streamoutcnt; i++) {
 					if (stcb->asoc.strmout[i].state == SCTP_STREAM_OPEN) {
 						stcb->asoc.strmout[i].state = SCTP_STREAM_RESET_PENDING;
 						cnt++;
 					}
 				}
 			}
 		}
 		if (send_in) {
 			error = sctp_send_str_reset_req(stcb, strrst->srs_number_streams,
 							strrst->srs_stream_list,
 							send_in, 0, 0, 0, 0, 0);
 		} else {
 			error = sctp_send_stream_reset_out_if_possible(stcb, SCTP_SO_LOCKED);
 		}
 		if (error == 0) {
 			sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_STRRST_REQ, SCTP_SO_LOCKED);
 		} else {
 			 /*
 			  * For outgoing streams don't report any problems in
 			  * sending the request to the application.
 			  * XXX: Double check resetting incoming streams.
 			  */
 			error = 0;
 		}
 		SCTP_TCB_UNLOCK(stcb);
 		break;
 	}
 	case SCTP_ADD_STREAMS:
 	{
 		struct sctp_add_streams *stradd;
 		uint8_t addstream = 0;
 		uint16_t add_o_strmcnt = 0;
 		uint16_t add_i_strmcnt = 0;
 
 		SCTP_CHECK_AND_CAST(stradd, optval, struct sctp_add_streams, optsize);
 		SCTP_FIND_STCB(inp, stcb, stradd->sas_assoc_id);
 		if (stcb == NULL) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
 		if (stcb->asoc.reconfig_supported == 0) {
 			/*
 			 * Peer does not support the chunk type.
 			 */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EOPNOTSUPP);
 			error = EOPNOTSUPP;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if (SCTP_GET_STATE(stcb) != SCTP_STATE_OPEN) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if (stcb->asoc.stream_reset_outstanding) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EALREADY);
 			error = EALREADY;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if ((stradd->sas_outstrms == 0) &&
 		    (stradd->sas_instrms == 0)) {
 			error = EINVAL;
 			goto skip_stuff;
 		}
 		if (stradd->sas_outstrms) {
 			addstream = 1;
 			/* We allocate here */
 			add_o_strmcnt = stradd->sas_outstrms;
 			if ((((int)add_o_strmcnt) + ((int)stcb->asoc.streamoutcnt)) > 0x0000ffff) {
 				/* You can't have more than 64k */
 				error = EINVAL;
 				goto skip_stuff;
 			}
 		}
 		if (stradd->sas_instrms) {
 			int cnt;
 
 			addstream |= 2;
 			/* We allocate inside sctp_send_str_reset_req() */
 			add_i_strmcnt = stradd->sas_instrms;
 			cnt = add_i_strmcnt;
 			cnt += stcb->asoc.streamincnt;
 			if (cnt > 0x0000ffff) {
 				/* You can't have more than 64k */
 				error = EINVAL;
 				goto skip_stuff;
 			}
 			if (cnt > (int)stcb->asoc.max_inbound_streams) {
 				/* More than you are allowed */
 				error = EINVAL;
 				goto skip_stuff;
 			}
 		}
 		error = sctp_send_str_reset_req(stcb, 0, NULL, 0, 0, addstream, add_o_strmcnt, add_i_strmcnt, 0);
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_STRRST_REQ, SCTP_SO_LOCKED);
 	skip_stuff:
 		SCTP_TCB_UNLOCK(stcb);
 		break;
 	}
 	case SCTP_RESET_ASSOC:
 	{
 		int i;
 		uint32_t *value;
 
 		SCTP_CHECK_AND_CAST(value, optval, uint32_t, optsize);
 		SCTP_FIND_STCB(inp, stcb, (sctp_assoc_t) *value);
 		if (stcb == NULL) {
 		        SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
 		if (stcb->asoc.reconfig_supported == 0) {
 			/*
 			 * Peer does not support the chunk type.
 			 */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EOPNOTSUPP);
 			error = EOPNOTSUPP;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if (SCTP_GET_STATE(stcb) != SCTP_STATE_OPEN) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		if (stcb->asoc.stream_reset_outstanding) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EALREADY);
 			error = EALREADY;
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		/* Is there any data pending in the send or sent queues? */
 		if (!TAILQ_EMPTY(&stcb->asoc.send_queue) ||
 		    !TAILQ_EMPTY(&stcb->asoc.sent_queue)) {
 		busy_out:
 			error = EBUSY;
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, error);
 			SCTP_TCB_UNLOCK(stcb);
 			break;
 		}
 		/* Do any streams have data queued? */
 		for (i = 0; i < stcb->asoc.streamoutcnt; i++) {
 			if (!TAILQ_EMPTY(&stcb->asoc.strmout[i].outqueue)) {
 				goto busy_out;
 			}
 		}
 		error = sctp_send_str_reset_req(stcb, 0, NULL, 0, 1, 0, 0, 0, 0);
 		sctp_chunk_output(inp, stcb, SCTP_OUTPUT_FROM_STRRST_REQ, SCTP_SO_LOCKED);
 		SCTP_TCB_UNLOCK(stcb);
 		break;
 	}
 	case SCTP_CONNECT_X:
 		if (optsize < (sizeof(int) + sizeof(struct sockaddr_in))) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		error = sctp_do_connect_x(so, inp, optval, optsize, p, 0);
 		break;
 	case SCTP_CONNECT_X_DELAYED:
 		if (optsize < (sizeof(int) + sizeof(struct sockaddr_in))) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		error = sctp_do_connect_x(so, inp, optval, optsize, p, 1);
 		break;
 	case SCTP_CONNECT_X_COMPLETE:
 	{
 		struct sockaddr *sa;
 
 		/* FIXME MT: check correct? */
 		SCTP_CHECK_AND_CAST(sa, optval, struct sockaddr, optsize);
 
 		/* find tcb */
 		if (inp->sctp_flags & SCTP_PCB_FLAGS_CONNECTED) {
 			SCTP_INP_RLOCK(inp);
 			stcb = LIST_FIRST(&inp->sctp_asoc_list);
 			if (stcb) {
 				SCTP_TCB_LOCK(stcb);
 			}
 			SCTP_INP_RUNLOCK(inp);
 		} else {
 			/* We increment here since sctp_findassociation_ep_addr() wil
 			 * do a decrement if it finds the stcb as long as the locked
 			 * tcb (last argument) is NOT a TCB.. aka NULL.
 			 */
 			SCTP_INP_INCR_REF(inp);
 			stcb = sctp_findassociation_ep_addr(&inp, sa, NULL, NULL, NULL);
 			if (stcb == NULL) {
 				SCTP_INP_DECR_REF(inp);
 			}
 		}
 
 		if (stcb == NULL) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT);
 			error = ENOENT;
 			break;
 		}
 		if (stcb->asoc.delayed_connection == 1) {
 			stcb->asoc.delayed_connection = 0;
 			(void)SCTP_GETTIME_TIMEVAL(&stcb->asoc.time_entered);
 			sctp_timer_stop(SCTP_TIMER_TYPE_INIT, inp, stcb,
 					stcb->asoc.primary_destination,
 					SCTP_FROM_SCTP_USRREQ + SCTP_LOC_8);
 			sctp_send_initiate(inp, stcb, SCTP_SO_LOCKED);
 		} else {
 			/*
 			 * already expired or did not use delayed
 			 * connectx
 			 */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EALREADY);
 			error = EALREADY;
 		}
 		SCTP_TCB_UNLOCK(stcb);
 		break;
 	}
 	case SCTP_MAX_BURST:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			stcb->asoc.max_burst = av->assoc_value;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((av->assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (av->assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				inp->sctp_ep.max_burst = av->assoc_value;
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((av->assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (av->assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					stcb->asoc.max_burst = av->assoc_value;
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_MAXSEG:
 	{
 		struct sctp_assoc_value *av;
 		int ovh;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) {
 			ovh = SCTP_MED_OVERHEAD;
 		} else {
 			ovh = SCTP_MED_V4_OVERHEAD;
 		}
 		if (stcb) {
 			if (av->assoc_value) {
 				stcb->asoc.sctp_frag_point = (av->assoc_value + ovh);
 			} else {
 				stcb->asoc.sctp_frag_point = SCTP_DEFAULT_MAXSEGMENT;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				/* FIXME MT: I think this is not in tune with the API ID */
 				if (av->assoc_value) {
 					inp->sctp_frag_point = (av->assoc_value + ovh);
 				} else {
 					inp->sctp_frag_point = SCTP_DEFAULT_MAXSEGMENT;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_EVENTS:
 	{
 		struct sctp_event_subscribe *events;
 
 		SCTP_CHECK_AND_CAST(events, optval, struct sctp_event_subscribe, optsize);
 
 		SCTP_INP_WLOCK(inp);
 		if (events->sctp_data_io_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_RECVDATAIOEVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_RECVDATAIOEVNT);
 		}
 
 		if (events->sctp_association_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_RECVASSOCEVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_RECVASSOCEVNT);
 		}
 
 		if (events->sctp_address_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_RECVPADDREVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_RECVPADDREVNT);
 		}
 
 		if (events->sctp_send_failure_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_RECVSENDFAILEVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_RECVSENDFAILEVNT);
 		}
 
 		if (events->sctp_peer_error_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_RECVPEERERR);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_RECVPEERERR);
 		}
 
 		if (events->sctp_shutdown_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT);
 		}
 
 		if (events->sctp_partial_delivery_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_PDAPIEVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_PDAPIEVNT);
 		}
 
 		if (events->sctp_adaptation_layer_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_ADAPTATIONEVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_ADAPTATIONEVNT);
 		}
 
 		if (events->sctp_authentication_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_AUTHEVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_AUTHEVNT);
 		}
 
 		if (events->sctp_sender_dry_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_DRYEVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_DRYEVNT);
 		}
 
 		if (events->sctp_stream_reset_event) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_STREAM_RESETEVNT);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_STREAM_RESETEVNT);
 		}
 		SCTP_INP_WUNLOCK(inp);
 
 		SCTP_INP_RLOCK(inp);
 		LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 			SCTP_TCB_LOCK(stcb);
 			if (events->sctp_association_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_RECVASSOCEVNT);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_RECVASSOCEVNT);
 			}
 			if (events->sctp_address_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_RECVPADDREVNT);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_RECVPADDREVNT);
 			}
 			if (events->sctp_send_failure_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_RECVSENDFAILEVNT);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_RECVSENDFAILEVNT);
 			}
 			if (events->sctp_peer_error_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_RECVPEERERR);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_RECVPEERERR);
 			}
 			if (events->sctp_shutdown_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT);
 			}
 			if (events->sctp_partial_delivery_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_PDAPIEVNT);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_PDAPIEVNT);
 			}
 			if (events->sctp_adaptation_layer_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_ADAPTATIONEVNT);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_ADAPTATIONEVNT);
 			}
 			if (events->sctp_authentication_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_AUTHEVNT);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_AUTHEVNT);
 			}
 			if (events->sctp_sender_dry_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_DRYEVNT);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_DRYEVNT);
 			}
 			if (events->sctp_stream_reset_event) {
 				sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_STREAM_RESETEVNT);
 			} else {
 				sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_STREAM_RESETEVNT);
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		}
 		/* Send up the sender dry event only for 1-to-1 style sockets. */
 		if (events->sctp_sender_dry_event) {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL)) {
 				stcb = LIST_FIRST(&inp->sctp_asoc_list);
 				if (stcb) {
 					SCTP_TCB_LOCK(stcb);
 					if (TAILQ_EMPTY(&stcb->asoc.send_queue) &&
 					    TAILQ_EMPTY(&stcb->asoc.sent_queue) &&
 					    (stcb->asoc.stream_queue_cnt == 0)) {
 						sctp_ulp_notify(SCTP_NOTIFY_SENDER_DRY, stcb,  0, NULL, SCTP_SO_LOCKED);
 					}
 					SCTP_TCB_UNLOCK(stcb);
 				}
 			}
 		}
 		SCTP_INP_RUNLOCK(inp);
 		break;
 	}
 	case SCTP_ADAPTATION_LAYER:
 	{
 		struct sctp_setadaptation *adap_bits;
 
 		SCTP_CHECK_AND_CAST(adap_bits, optval, struct sctp_setadaptation, optsize);
 		SCTP_INP_WLOCK(inp);
 		inp->sctp_ep.adaptation_layer_indicator = adap_bits->ssb_adaptation_ind;
 		inp->sctp_ep.adaptation_layer_indicator_provided = 1;
 		SCTP_INP_WUNLOCK(inp);
 		break;
 	}
 #ifdef SCTP_DEBUG
 	case SCTP_SET_INITIAL_DBG_SEQ:
 	{
 		uint32_t *vvv;
 
 		SCTP_CHECK_AND_CAST(vvv, optval, uint32_t, optsize);
 		SCTP_INP_WLOCK(inp);
 		inp->sctp_ep.initial_sequence_debug = *vvv;
 		SCTP_INP_WUNLOCK(inp);
 		break;
 	}
 #endif
 	case SCTP_DEFAULT_SEND_PARAM:
 	{
 		struct sctp_sndrcvinfo *s_info;
 
 		SCTP_CHECK_AND_CAST(s_info, optval, struct sctp_sndrcvinfo, optsize);
 		SCTP_FIND_STCB(inp, stcb, s_info->sinfo_assoc_id);
 
 		if (stcb) {
 			if (s_info->sinfo_stream < stcb->asoc.streamoutcnt) {
 				memcpy(&stcb->asoc.def_send, s_info, min(optsize, sizeof(stcb->asoc.def_send)));
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((s_info->sinfo_assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (s_info->sinfo_assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				memcpy(&inp->def_send, s_info, min(optsize, sizeof(inp->def_send)));
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((s_info->sinfo_assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (s_info->sinfo_assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					if (s_info->sinfo_stream < stcb->asoc.streamoutcnt) {
 						memcpy(&stcb->asoc.def_send, s_info, min(optsize, sizeof(stcb->asoc.def_send)));
 					}
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_PEER_ADDR_PARAMS:
 	{
 		struct sctp_paddrparams *paddrp;
 		struct sctp_nets *net;
 		struct sockaddr *addr;
 #if defined(INET) && defined(INET6)
 		struct sockaddr_in sin_store;
 #endif
 
 		SCTP_CHECK_AND_CAST(paddrp, optval, struct sctp_paddrparams, optsize);
 		SCTP_FIND_STCB(inp, stcb, paddrp->spp_assoc_id);
 
 #if defined(INET) && defined(INET6)
 		if (paddrp->spp_address.ss_family == AF_INET6) {
 			struct sockaddr_in6 *sin6;
 
 			sin6 = (struct sockaddr_in6 *)&paddrp->spp_address;
 			if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
 				in6_sin6_2_sin(&sin_store, sin6);
 				addr = (struct sockaddr *)&sin_store;
 			} else {
 				addr = (struct sockaddr *)&paddrp->spp_address;
 			}
 		} else {
 			addr = (struct sockaddr *)&paddrp->spp_address;
 		}
 #else
 		addr = (struct sockaddr *)&paddrp->spp_address;
 #endif
 		if (stcb != NULL) {
 			net = sctp_findnet(stcb, addr);
 		} else {
 			/* We increment here since sctp_findassociation_ep_addr() wil
 			 * do a decrement if it finds the stcb as long as the locked
 			 * tcb (last argument) is NOT a TCB.. aka NULL.
 			 */
 			net = NULL;
 			SCTP_INP_INCR_REF(inp);
 			stcb = sctp_findassociation_ep_addr(&inp, addr,
 			                                    &net, NULL, NULL);
 			if (stcb == NULL) {
 				SCTP_INP_DECR_REF(inp);
 			}
 		}
 		if ((stcb != NULL) && (net == NULL)) {
 #ifdef INET
 			if (addr->sa_family == AF_INET) {
 				struct sockaddr_in *sin;
 
 				sin = (struct sockaddr_in *)addr;
 				if (sin->sin_addr.s_addr != INADDR_ANY) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					SCTP_TCB_UNLOCK(stcb);
 					error = EINVAL;
 					break;
 				}
 			} else
 #endif
 #ifdef INET6
 			if (addr->sa_family == AF_INET6) {
 				struct sockaddr_in6 *sin6;
 
 				sin6 = (struct sockaddr_in6 *)addr;
 				if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					SCTP_TCB_UNLOCK(stcb);
 					error = EINVAL;
 					break;
 				}
 			} else
 #endif
 #if defined(__Userspace__)
 			if (addr->sa_family == AF_CONN) {
 				struct sockaddr_conn *sconn;
 
 				sconn = (struct sockaddr_conn *)addr;
 				if (sconn->sconn_addr != NULL) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					SCTP_TCB_UNLOCK(stcb);
 					error = EINVAL;
 					break;
 				}
 			} else
 #endif
 			{
 				error = EAFNOSUPPORT;
 				SCTP_TCB_UNLOCK(stcb);
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, error);
 				break;
 			}
 		}
 		/* sanity checks */
 		if ((paddrp->spp_flags & SPP_HB_ENABLE) && (paddrp->spp_flags & SPP_HB_DISABLE)) {
 			if (stcb)
 				SCTP_TCB_UNLOCK(stcb);
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			return (EINVAL);
 		}
 
 		if ((paddrp->spp_flags & SPP_PMTUD_ENABLE) && (paddrp->spp_flags & SPP_PMTUD_DISABLE)) {
 			if (stcb)
 				SCTP_TCB_UNLOCK(stcb);
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			return (EINVAL);
 		}
 		if ((paddrp->spp_flags & SPP_PMTUD_DISABLE) &&
 		    ((paddrp->spp_pathmtu < SCTP_SMALLEST_PMTU) ||
 		     (paddrp->spp_pathmtu > SCTP_LARGEST_PMTU))) {
 			if (stcb)
 				SCTP_TCB_UNLOCK(stcb);
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			return (EINVAL);
 		}
 
 		if (stcb != NULL) {
 			/************************TCB SPECIFIC SET ******************/
 			if (net != NULL) {
 				/************************NET SPECIFIC SET ******************/
 				if (paddrp->spp_flags & SPP_HB_DISABLE) {
 					if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED) &&
 					    !(net->dest_state & SCTP_ADDR_NOHB)) {
 						sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
 								SCTP_FROM_SCTP_USRREQ + SCTP_LOC_9);
 					}
 					net->dest_state |= SCTP_ADDR_NOHB;
 				}
 				if (paddrp->spp_flags & SPP_HB_ENABLE) {
 					if (paddrp->spp_hbinterval) {
 						net->heart_beat_delay = paddrp->spp_hbinterval;
 					} else if (paddrp->spp_flags & SPP_HB_TIME_IS_ZERO) {
 						net->heart_beat_delay = 0;
 					}
 					sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
 					                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_10);
 					sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net);
 					net->dest_state &= ~SCTP_ADDR_NOHB;
 				}
 				if (paddrp->spp_flags & SPP_HB_DEMAND) {
 					if (SCTP_GET_STATE(stcb) == SCTP_STATE_OPEN) {
 						sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 						sctp_chunk_output(inp, stcb,  SCTP_OUTPUT_FROM_SOCKOPT, SCTP_SO_LOCKED);
 						sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net);
 					}
 				}
 				if (paddrp->spp_flags & SPP_PMTUD_DISABLE) {
 					if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
 						sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
 								SCTP_FROM_SCTP_USRREQ + SCTP_LOC_11);
 					}
 					net->dest_state |= SCTP_ADDR_NO_PMTUD;
 					net->mtu = paddrp->spp_pathmtu;
 					switch (net->ro._l_addr.sa.sa_family) {
 #ifdef INET
 					case AF_INET:
 						net->mtu += SCTP_MIN_V4_OVERHEAD;
 						break;
 #endif
 #ifdef INET6
 					case AF_INET6:
 						net->mtu += SCTP_MIN_OVERHEAD;
 						break;
 #endif
 #if defined(__Userspace__)
 					case AF_CONN:
 						net->mtu += sizeof(struct sctphdr);
 						break;
 #endif
 					default:
 						break;
 					}
 					if (net->mtu < stcb->asoc.smallest_mtu) {
 						sctp_pathmtu_adjustment(stcb, net->mtu);
 					}
 				}
 				if (paddrp->spp_flags & SPP_PMTUD_ENABLE) {
 					if (!SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
 						sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 					}
 					net->dest_state &= ~SCTP_ADDR_NO_PMTUD;
 				}
 				if (paddrp->spp_pathmaxrxt) {
 					if (net->dest_state & SCTP_ADDR_PF) {
 						if (net->error_count > paddrp->spp_pathmaxrxt) {
 							net->dest_state &= ~SCTP_ADDR_PF;
 						}
 					} else {
 						if ((net->error_count <= paddrp->spp_pathmaxrxt) &&
 						    (net->error_count > net->pf_threshold)) {
 							net->dest_state |= SCTP_ADDR_PF;
 							sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 							                stcb->sctp_ep, stcb, net,
 							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_12);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 						}
 					}
 					if (net->dest_state & SCTP_ADDR_REACHABLE) {
 						if (net->error_count > paddrp->spp_pathmaxrxt) {
 							net->dest_state &= ~SCTP_ADDR_REACHABLE;
 							sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_DOWN, stcb, 0, net, SCTP_SO_LOCKED);
 						}
 					} else {
 						if (net->error_count <= paddrp->spp_pathmaxrxt) {
 							net->dest_state |= SCTP_ADDR_REACHABLE;
 							sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_UP, stcb, 0, net, SCTP_SO_LOCKED);
 						}
 					}
 					net->failure_threshold = paddrp->spp_pathmaxrxt;
 				}
 				if (paddrp->spp_flags & SPP_DSCP) {
 					net->dscp = paddrp->spp_dscp & 0xfc;
 					net->dscp |= 0x01;
 				}
 #ifdef INET6
 				if (paddrp->spp_flags & SPP_IPV6_FLOWLABEL) {
 					if (net->ro._l_addr.sa.sa_family == AF_INET6) {
 						net->flowlabel = paddrp->spp_ipv6_flowlabel & 0x000fffff;
 						net->flowlabel |= 0x80000000;
 					}
 				}
 #endif
 			} else {
 				/************************ASSOC ONLY -- NO NET SPECIFIC SET ******************/
 				if (paddrp->spp_pathmaxrxt != 0) {
 					stcb->asoc.def_net_failure = paddrp->spp_pathmaxrxt;
 					TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 						if (net->dest_state & SCTP_ADDR_PF) {
 							if (net->error_count > paddrp->spp_pathmaxrxt) {
 								net->dest_state &= ~SCTP_ADDR_PF;
 							}
 						} else {
 							if ((net->error_count <= paddrp->spp_pathmaxrxt) &&
 							    (net->error_count > net->pf_threshold)) {
 								net->dest_state |= SCTP_ADDR_PF;
 								sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 								sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 								                stcb->sctp_ep, stcb, net,
 								                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_13);
 								sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 							}
 						}
 						if (net->dest_state & SCTP_ADDR_REACHABLE) {
 							if (net->error_count > paddrp->spp_pathmaxrxt) {
 								net->dest_state &= ~SCTP_ADDR_REACHABLE;
 								sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_DOWN, stcb, 0, net, SCTP_SO_LOCKED);
 							}
 						} else {
 							if (net->error_count <= paddrp->spp_pathmaxrxt) {
 								net->dest_state |= SCTP_ADDR_REACHABLE;
 								sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_UP, stcb, 0, net, SCTP_SO_LOCKED);
 							}
 						}
 						net->failure_threshold = paddrp->spp_pathmaxrxt;
 					}
 				}
 
 				if (paddrp->spp_flags & SPP_HB_ENABLE) {
 					if (paddrp->spp_hbinterval != 0) {
 						stcb->asoc.heart_beat_delay = paddrp->spp_hbinterval;
 					} else if (paddrp->spp_flags & SPP_HB_TIME_IS_ZERO) {
 						stcb->asoc.heart_beat_delay = 0;
 					}
 					/* Turn back on the timer */
 					TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 						if (paddrp->spp_hbinterval != 0) {
 							net->heart_beat_delay = paddrp->spp_hbinterval;
 						} else if (paddrp->spp_flags & SPP_HB_TIME_IS_ZERO) {
 							net->heart_beat_delay = 0;
 						}
 						if (net->dest_state & SCTP_ADDR_NOHB) {
 							net->dest_state &= ~SCTP_ADDR_NOHB;
 						}
 						sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net,
 								SCTP_FROM_SCTP_USRREQ + SCTP_LOC_14);
 						sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, inp, stcb, net);
 					}
 					sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_DONOT_HEARTBEAT);
 				}
 				if (paddrp->spp_flags & SPP_HB_DISABLE) {
 					TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 						if (!(net->dest_state & SCTP_ADDR_NOHB)) {
 							net->dest_state |= SCTP_ADDR_NOHB;
 							if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED)) {
 								sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 								                inp, stcb, net,
 								                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_15);
 							}
 						}
 					}
 					sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_DONOT_HEARTBEAT);
 				}
 				if (paddrp->spp_flags & SPP_PMTUD_DISABLE) {
 					TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 						if (SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
 							sctp_timer_stop(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net,
 									SCTP_FROM_SCTP_USRREQ + SCTP_LOC_16);
 						}
 						net->dest_state |= SCTP_ADDR_NO_PMTUD;
 						net->mtu = paddrp->spp_pathmtu;
 						switch (net->ro._l_addr.sa.sa_family) {
 #ifdef INET
 						case AF_INET:
 							net->mtu += SCTP_MIN_V4_OVERHEAD;
 							break;
 #endif
 #ifdef INET6
 						case AF_INET6:
 							net->mtu += SCTP_MIN_OVERHEAD;
 							break;
 #endif
 #if defined(__Userspace__)
 						case AF_CONN:
 							net->mtu += sizeof(struct sctphdr);
 							break;
 #endif
 						default:
 							break;
 						}
 						if (net->mtu < stcb->asoc.smallest_mtu) {
 							sctp_pathmtu_adjustment(stcb, net->mtu);
 						}
 					}
 					stcb->asoc.default_mtu = paddrp->spp_pathmtu;
 					sctp_stcb_feature_on(inp, stcb, SCTP_PCB_FLAGS_DO_NOT_PMTUD);
 				}
 				if (paddrp->spp_flags & SPP_PMTUD_ENABLE) {
 					TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 						if (!SCTP_OS_TIMER_PENDING(&net->pmtu_timer.timer)) {
 							sctp_timer_start(SCTP_TIMER_TYPE_PATHMTURAISE, inp, stcb, net);
 						}
 						net->dest_state &= ~SCTP_ADDR_NO_PMTUD;
 					}
 					stcb->asoc.default_mtu = 0;
 					sctp_stcb_feature_off(inp, stcb, SCTP_PCB_FLAGS_DO_NOT_PMTUD);
 				}
 				if (paddrp->spp_flags & SPP_DSCP) {
 					TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 						net->dscp = paddrp->spp_dscp & 0xfc;
 						net->dscp |= 0x01;
 					}
 					stcb->asoc.default_dscp = paddrp->spp_dscp & 0xfc;
 					stcb->asoc.default_dscp |= 0x01;
 				}
 #ifdef INET6
 				if (paddrp->spp_flags & SPP_IPV6_FLOWLABEL) {
 					TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 						if (net->ro._l_addr.sa.sa_family == AF_INET6) {
 							net->flowlabel = paddrp->spp_ipv6_flowlabel & 0x000fffff;
 							net->flowlabel |= 0x80000000;
 						}
 					}
 					stcb->asoc.default_flowlabel = paddrp->spp_ipv6_flowlabel & 0x000fffff;
 					stcb->asoc.default_flowlabel |= 0x80000000;
 				}
 #endif
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			/************************NO TCB, SET TO default stuff ******************/
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (paddrp->spp_assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				/*
 				 * For the TOS/FLOWLABEL stuff you set it
 				 * with the options on the socket
 				 */
 				if (paddrp->spp_pathmaxrxt != 0) {
 					inp->sctp_ep.def_net_failure = paddrp->spp_pathmaxrxt;
 				}
 
 				if (paddrp->spp_flags & SPP_HB_TIME_IS_ZERO)
 					inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = 0;
 				else if (paddrp->spp_hbinterval != 0) {
 					if (paddrp->spp_hbinterval > SCTP_MAX_HB_INTERVAL)
 						paddrp->spp_hbinterval= SCTP_MAX_HB_INTERVAL;
 					inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = sctp_msecs_to_ticks(paddrp->spp_hbinterval);
 				}
 
 				if (paddrp->spp_flags & SPP_HB_ENABLE) {
 					if (paddrp->spp_flags & SPP_HB_TIME_IS_ZERO) {
 						inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = 0;
 					} else if (paddrp->spp_hbinterval) {
 						inp->sctp_ep.sctp_timeoutticks[SCTP_TIMER_HEARTBEAT] = sctp_msecs_to_ticks(paddrp->spp_hbinterval);
 					}
 					sctp_feature_off(inp, SCTP_PCB_FLAGS_DONOT_HEARTBEAT);
 				} else if (paddrp->spp_flags & SPP_HB_DISABLE) {
 					sctp_feature_on(inp, SCTP_PCB_FLAGS_DONOT_HEARTBEAT);
 				}
 				if (paddrp->spp_flags & SPP_PMTUD_ENABLE) {
 					inp->sctp_ep.default_mtu = 0;
 					sctp_feature_off(inp, SCTP_PCB_FLAGS_DO_NOT_PMTUD);
 				} else if (paddrp->spp_flags & SPP_PMTUD_DISABLE) {
 					inp->sctp_ep.default_mtu = paddrp->spp_pathmtu;
 					sctp_feature_on(inp, SCTP_PCB_FLAGS_DO_NOT_PMTUD);
 				}
 				if (paddrp->spp_flags & SPP_DSCP) {
 					inp->sctp_ep.default_dscp = paddrp->spp_dscp & 0xfc;
 					inp->sctp_ep.default_dscp |= 0x01;
 				}
 #ifdef INET6
 				if (paddrp->spp_flags & SPP_IPV6_FLOWLABEL) {
 					if (inp->sctp_flags & SCTP_PCB_FLAGS_BOUND_V6) {
 						inp->sctp_ep.default_flowlabel = paddrp->spp_ipv6_flowlabel & 0x000fffff;
 						inp->sctp_ep.default_flowlabel |= 0x80000000;
 					}
 				}
 #endif
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_RTOINFO:
 	{
 		struct sctp_rtoinfo *srto;
 		uint32_t new_init, new_min, new_max;
 
 		SCTP_CHECK_AND_CAST(srto, optval, struct sctp_rtoinfo, optsize);
 		SCTP_FIND_STCB(inp, stcb, srto->srto_assoc_id);
 
 		if (stcb) {
 			if (srto->srto_initial)
 				new_init = srto->srto_initial;
 			else
 				new_init = stcb->asoc.initial_rto;
 			if (srto->srto_max)
 				new_max = srto->srto_max;
 			else
 				new_max = stcb->asoc.maxrto;
 			if (srto->srto_min)
 				new_min = srto->srto_min;
 			else
 				new_min = stcb->asoc.minrto;
 			if ((new_min <= new_init) && (new_init <= new_max)) {
 				stcb->asoc.initial_rto = new_init;
 				stcb->asoc.maxrto = new_max;
 				stcb->asoc.minrto = new_min;
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (srto->srto_assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				if (srto->srto_initial)
 					new_init = srto->srto_initial;
 				else
 					new_init = inp->sctp_ep.initial_rto;
 				if (srto->srto_max)
 					new_max = srto->srto_max;
 				else
 					new_max = inp->sctp_ep.sctp_maxrto;
 				if (srto->srto_min)
 					new_min = srto->srto_min;
 				else
 					new_min = inp->sctp_ep.sctp_minrto;
 				if ((new_min <= new_init) && (new_init <= new_max)) {
 					inp->sctp_ep.initial_rto = new_init;
 					inp->sctp_ep.sctp_maxrto = new_max;
 					inp->sctp_ep.sctp_minrto = new_min;
 				} else {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_ASSOCINFO:
 	{
 		struct sctp_assocparams *sasoc;
 
 		SCTP_CHECK_AND_CAST(sasoc, optval, struct sctp_assocparams, optsize);
 		SCTP_FIND_STCB(inp, stcb, sasoc->sasoc_assoc_id);
-		if (sasoc->sasoc_cookie_life) {
+		if (sasoc->sasoc_cookie_life > 0) {
 			/* boundary check the cookie life */
-			if (sasoc->sasoc_cookie_life < 1000)
-				sasoc->sasoc_cookie_life = 1000;
+			if (sasoc->sasoc_cookie_life < SCTP_MIN_COOKIE_LIFE) {
+				sasoc->sasoc_cookie_life = SCTP_MIN_COOKIE_LIFE;
+			}
 			if (sasoc->sasoc_cookie_life > SCTP_MAX_COOKIE_LIFE) {
 				sasoc->sasoc_cookie_life = SCTP_MAX_COOKIE_LIFE;
 			}
 		}
 		if (stcb) {
-			if (sasoc->sasoc_asocmaxrxt)
+			if (sasoc->sasoc_asocmaxrxt > 0) {
 				stcb->asoc.max_send_times = sasoc->sasoc_asocmaxrxt;
-			if (sasoc->sasoc_cookie_life) {
+			}
+			if (sasoc->sasoc_cookie_life > 0) {
 				stcb->asoc.cookie_life = sctp_msecs_to_ticks(sasoc->sasoc_cookie_life);
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (sasoc->sasoc_assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
-				if (sasoc->sasoc_asocmaxrxt)
+				if (sasoc->sasoc_asocmaxrxt > 0) {
 					inp->sctp_ep.max_send_times = sasoc->sasoc_asocmaxrxt;
-				if (sasoc->sasoc_cookie_life) {
+				}
+				if (sasoc->sasoc_cookie_life > 0) {
 					inp->sctp_ep.def_cookie_life = sctp_msecs_to_ticks(sasoc->sasoc_cookie_life);
 				}
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_INITMSG:
 	{
 		struct sctp_initmsg *sinit;
 
 		SCTP_CHECK_AND_CAST(sinit, optval, struct sctp_initmsg, optsize);
 		SCTP_INP_WLOCK(inp);
 		if (sinit->sinit_num_ostreams)
 			inp->sctp_ep.pre_open_stream_count = sinit->sinit_num_ostreams;
 
 		if (sinit->sinit_max_instreams)
 			inp->sctp_ep.max_open_streams_intome = sinit->sinit_max_instreams;
 
 		if (sinit->sinit_max_attempts)
 			inp->sctp_ep.max_init_times = sinit->sinit_max_attempts;
 
 		if (sinit->sinit_max_init_timeo)
 			inp->sctp_ep.initial_init_rto_max = sinit->sinit_max_init_timeo;
 		SCTP_INP_WUNLOCK(inp);
 		break;
 	}
 	case SCTP_PRIMARY_ADDR:
 	{
 		struct sctp_setprim *spa;
 		struct sctp_nets *net;
 		struct sockaddr *addr;
 #if defined(INET) && defined(INET6)
 		struct sockaddr_in sin_store;
 #endif
 
 		SCTP_CHECK_AND_CAST(spa, optval, struct sctp_setprim, optsize);
 		SCTP_FIND_STCB(inp, stcb, spa->ssp_assoc_id);
 
 #if defined(INET) && defined(INET6)
 		if (spa->ssp_addr.ss_family == AF_INET6) {
 			struct sockaddr_in6 *sin6;
 
 			sin6 = (struct sockaddr_in6 *)&spa->ssp_addr;
 			if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
 				in6_sin6_2_sin(&sin_store, sin6);
 				addr = (struct sockaddr *)&sin_store;
 			} else {
 				addr = (struct sockaddr *)&spa->ssp_addr;
 			}
 		} else {
 			addr = (struct sockaddr *)&spa->ssp_addr;
 		}
 #else
 		addr = (struct sockaddr *)&spa->ssp_addr;
 #endif
 		if (stcb != NULL) {
 			net = sctp_findnet(stcb, addr);
 		} else {
 			/* We increment here since sctp_findassociation_ep_addr() wil
 			 * do a decrement if it finds the stcb as long as the locked
 			 * tcb (last argument) is NOT a TCB.. aka NULL.
 			 */
 			net = NULL;
 			SCTP_INP_INCR_REF(inp);
 			stcb = sctp_findassociation_ep_addr(&inp, addr,
 			                                    &net, NULL, NULL);
 			if (stcb == NULL) {
 				SCTP_INP_DECR_REF(inp);
 			}
 		}
 
 		if ((stcb != NULL) && (net != NULL)) {
 			if (net != stcb->asoc.primary_destination) {
 				if (!(net->dest_state & SCTP_ADDR_UNCONFIRMED)) {
 					/* Ok we need to set it */
 					if (sctp_set_primary_addr(stcb, (struct sockaddr *)NULL, net) == 0) {
 						if ((stcb->asoc.alternate) &&
 						    (!(net->dest_state & SCTP_ADDR_PF)) &&
 						    (net->dest_state & SCTP_ADDR_REACHABLE)) {
 							sctp_free_remote_addr(stcb->asoc.alternate);
 							stcb->asoc.alternate = NULL;
 						}
 					} else {
 						SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 						error = EINVAL;
 					}
 				} else {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 				}
 			}
 		} else {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 		}
 		if (stcb != NULL) {
 			SCTP_TCB_UNLOCK(stcb);
 		}
 		break;
 	}
 	case SCTP_SET_DYNAMIC_PRIMARY:
 	{
 		union sctp_sockstore *ss;
 #ifdef SCTP_MVRF
 		int i, fnd = 0;
 #endif
 #if !defined(_WIN32) && !defined(__Userspace__)
 #if defined(__APPLE__)
 		struct proc *proc;
 #endif
 #if defined(__FreeBSD__)
 		error = priv_check(curthread,
 				   PRIV_NETINET_RESERVEDPORT);
 #elif defined(__APPLE__)
 		proc = (struct proc *)p;
 		if (p) {
 			error = suser(proc->p_ucred, &proc->p_acflag);
 		} else {
 			break;
 		}
 #else
 		error = suser(p, 0);
 #endif
 		if (error)
 			break;
 #endif
 
 		SCTP_CHECK_AND_CAST(ss, optval, union sctp_sockstore, optsize);
 		/* SUPER USER CHECK? */
 #ifdef SCTP_MVRF
 		for (i = 0; i < inp->num_vrfs; i++) {
 			if (vrf_id == inp->m_vrf_ids[i]) {
 				fnd = 1;
 				break;
 			}
 		}
 		if (!fnd) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 #endif
 		error = sctp_dynamic_set_primary(&ss->sa, vrf_id);
 		break;
 	}
 	case SCTP_SET_PEER_PRIMARY_ADDR:
 	{
 		struct sctp_setpeerprim *sspp;
 		struct sockaddr *addr;
 #if defined(INET) && defined(INET6)
 		struct sockaddr_in sin_store;
 #endif
 
 		SCTP_CHECK_AND_CAST(sspp, optval, struct sctp_setpeerprim, optsize);
 		SCTP_FIND_STCB(inp, stcb, sspp->sspp_assoc_id);
 		if (stcb != NULL) {
 			struct sctp_ifa *ifa;
 
 #if defined(INET) && defined(INET6)
 			if (sspp->sspp_addr.ss_family == AF_INET6) {
 				struct sockaddr_in6 *sin6;
 
 				sin6 = (struct sockaddr_in6 *)&sspp->sspp_addr;
 				if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
 					in6_sin6_2_sin(&sin_store, sin6);
 					addr = (struct sockaddr *)&sin_store;
 				} else {
 					addr = (struct sockaddr *)&sspp->sspp_addr;
 				}
 			} else {
 				addr = (struct sockaddr *)&sspp->sspp_addr;
 			}
 #else
 			addr = (struct sockaddr *)&sspp->sspp_addr;
 #endif
 			ifa = sctp_find_ifa_by_addr(addr, stcb->asoc.vrf_id, SCTP_ADDR_NOT_LOCKED);
 			if (ifa == NULL) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				goto out_of_it;
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_BOUNDALL) == 0) {
 				/* Must validate the ifa found is in our ep */
 				struct sctp_laddr *laddr;
 				int found = 0;
 
 				LIST_FOREACH(laddr, &inp->sctp_addr_list, sctp_nxt_addr) {
 					if (laddr->ifa == NULL) {
 						SCTPDBG(SCTP_DEBUG_OUTPUT1, "%s: NULL ifa\n",
 							__func__);
 						continue;
 					}
 					if ((sctp_is_addr_restricted(stcb, laddr->ifa)) &&
 					    (!sctp_is_addr_pending(stcb, laddr->ifa))) {
 						continue;
 					}
 					if (laddr->ifa == ifa) {
 						found = 1;
 						break;
 					}
 				}
 				if (!found) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 					goto out_of_it;
 				}
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			} else {
 				switch (addr->sa_family) {
 #ifdef INET
 				case AF_INET:
 				{
 					struct sockaddr_in *sin;
 
 					sin = (struct sockaddr_in *)addr;
 					if (prison_check_ip4(inp->ip_inp.inp.inp_cred,
 					                     &sin->sin_addr) != 0) {
 						SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 						error = EINVAL;
 						goto out_of_it;
 					}
 					break;
 				}
 #endif
 #ifdef INET6
 				case AF_INET6:
 				{
 					struct sockaddr_in6 *sin6;
 
 					sin6 = (struct sockaddr_in6 *)addr;
 					if (prison_check_ip6(inp->ip_inp.inp.inp_cred,
 					                     &sin6->sin6_addr) != 0) {
 						SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 						error = EINVAL;
 						goto out_of_it;
 					}
 					break;
 				}
 #endif
 				default:
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 					goto out_of_it;
 				}
 #endif
 			}
 			if (sctp_set_primary_ip_address_sa(stcb, addr) != 0) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 			sctp_chunk_output(inp, stcb,  SCTP_OUTPUT_FROM_SOCKOPT, SCTP_SO_LOCKED);
 		out_of_it:
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 		}
 		break;
 	}
 	case SCTP_BINDX_ADD_ADDR:
 	{
 		struct sockaddr *sa;
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 		struct thread *td;
 
 		td = (struct thread *)p;
 #endif
 		SCTP_CHECK_AND_CAST(sa, optval, struct sockaddr, optsize);
 #ifdef INET
 		if (sa->sa_family == AF_INET) {
 			if (optsize < sizeof(struct sockaddr_in)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			if (td != NULL &&
 			    (error = prison_local_ip4(td->td_ucred, &(((struct sockaddr_in *)sa)->sin_addr)))) {
 				SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_USRREQ, error);
 				break;
 			}
 #endif
 		} else
 #endif
 #ifdef INET6
 		if (sa->sa_family == AF_INET6) {
 			if (optsize < sizeof(struct sockaddr_in6)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			if (td != NULL &&
 			    (error = prison_local_ip6(td->td_ucred,
 			                              &(((struct sockaddr_in6 *)sa)->sin6_addr),
 			                              (SCTP_IPV6_V6ONLY(inp) != 0))) != 0) {
 				SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_USRREQ, error);
 				break;
 			}
 #endif
 		} else
 #endif
 		{
 			error = EAFNOSUPPORT;
 			break;
 		}
 		sctp_bindx_add_address(so, inp, sa, vrf_id, &error, p);
 		break;
 	}
 	case SCTP_BINDX_REM_ADDR:
 	{
 		struct sockaddr *sa;
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 		struct thread *td;
 		td = (struct thread *)p;
 
 #endif
 		SCTP_CHECK_AND_CAST(sa, optval, struct sockaddr, optsize);
 #ifdef INET
 		if (sa->sa_family == AF_INET) {
 			if (optsize < sizeof(struct sockaddr_in)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			if (td != NULL &&
 			    (error = prison_local_ip4(td->td_ucred, &(((struct sockaddr_in *)sa)->sin_addr)))) {
 				SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_USRREQ, error);
 				break;
 			}
 #endif
 		} else
 #endif
 #ifdef INET6
 		if (sa->sa_family == AF_INET6) {
 			if (optsize < sizeof(struct sockaddr_in6)) {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 				break;
 			}
 #if defined(__FreeBSD__) && !defined(__Userspace__)
 			if (td != NULL &&
 			    (error = prison_local_ip6(td->td_ucred,
 			                              &(((struct sockaddr_in6 *)sa)->sin6_addr),
 			                              (SCTP_IPV6_V6ONLY(inp) != 0))) != 0) {
 				SCTP_LTRACE_ERR_RET(inp, stcb, NULL, SCTP_FROM_SCTP_USRREQ, error);
 				break;
 			}
 #endif
 		} else
 #endif
 		{
 			error = EAFNOSUPPORT;
 			break;
 		}
 		sctp_bindx_delete_address(inp, sa, vrf_id, &error);
 		break;
 	}
 #if defined(__APPLE__) && !defined(__Userspace__)
 	case SCTP_LISTEN_FIX:
 		/* only applies to one-to-many sockets */
 		if (inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) {
 			/* make sure the ACCEPTCONN flag is OFF */
 			so->so_options &= ~SO_ACCEPTCONN;
 		} else {
 			/* otherwise, not allowed */
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 		}
 		break;
 #endif
 	case SCTP_EVENT:
 	{
 		struct sctp_event *event;
 		uint32_t event_type;
 
 		SCTP_CHECK_AND_CAST(event, optval, struct sctp_event, optsize);
 		SCTP_FIND_STCB(inp, stcb, event->se_assoc_id);
 		switch (event->se_type) {
 		case SCTP_ASSOC_CHANGE:
 			event_type = SCTP_PCB_FLAGS_RECVASSOCEVNT;
 			break;
 		case SCTP_PEER_ADDR_CHANGE:
 			event_type = SCTP_PCB_FLAGS_RECVPADDREVNT;
 			break;
 		case SCTP_REMOTE_ERROR:
 			event_type = SCTP_PCB_FLAGS_RECVPEERERR;
 			break;
 		case SCTP_SEND_FAILED:
 			event_type = SCTP_PCB_FLAGS_RECVSENDFAILEVNT;
 			break;
 		case SCTP_SHUTDOWN_EVENT:
 			event_type = SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT;
 			break;
 		case SCTP_ADAPTATION_INDICATION:
 			event_type = SCTP_PCB_FLAGS_ADAPTATIONEVNT;
 			break;
 		case SCTP_PARTIAL_DELIVERY_EVENT:
 			event_type = SCTP_PCB_FLAGS_PDAPIEVNT;
 			break;
 		case SCTP_AUTHENTICATION_EVENT:
 			event_type = SCTP_PCB_FLAGS_AUTHEVNT;
 			break;
 		case SCTP_STREAM_RESET_EVENT:
 			event_type = SCTP_PCB_FLAGS_STREAM_RESETEVNT;
 			break;
 		case SCTP_SENDER_DRY_EVENT:
 			event_type = SCTP_PCB_FLAGS_DRYEVNT;
 			break;
 		case SCTP_NOTIFICATIONS_STOPPED_EVENT:
 			event_type = 0;
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOTSUP);
 			error = ENOTSUP;
 			break;
 		case SCTP_ASSOC_RESET_EVENT:
 			event_type = SCTP_PCB_FLAGS_ASSOC_RESETEVNT;
 			break;
 		case SCTP_STREAM_CHANGE_EVENT:
 			event_type = SCTP_PCB_FLAGS_STREAM_CHANGEEVNT;
 			break;
 		case SCTP_SEND_FAILED_EVENT:
 			event_type = SCTP_PCB_FLAGS_RECVNSENDFAILEVNT;
 			break;
 		default:
 			event_type = 0;
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		if (event_type > 0) {
 			if (stcb) {
 				if (event->se_on) {
 					sctp_stcb_feature_on(inp, stcb, event_type);
 					if (event_type == SCTP_PCB_FLAGS_DRYEVNT) {
 						if (TAILQ_EMPTY(&stcb->asoc.send_queue) &&
 						    TAILQ_EMPTY(&stcb->asoc.sent_queue) &&
 						    (stcb->asoc.stream_queue_cnt == 0)) {
 							sctp_ulp_notify(SCTP_NOTIFY_SENDER_DRY, stcb,  0, NULL, SCTP_SO_LOCKED);
 						}
 					}
 				} else {
 					sctp_stcb_feature_off(inp, stcb, event_type);
 				}
 				SCTP_TCB_UNLOCK(stcb);
 			} else {
 				/*
 				 * We don't want to send up a storm of events,
 				 * so return an error for sender dry events
 				 */
 				if ((event_type == SCTP_PCB_FLAGS_DRYEVNT) &&
 				    (inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 				    ((event->se_assoc_id == SCTP_ALL_ASSOC) ||
 				     (event->se_assoc_id == SCTP_CURRENT_ASSOC))) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOTSUP);
 					error = ENOTSUP;
 					break;
 				}
 				if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 				    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 				    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 				     ((event->se_assoc_id == SCTP_FUTURE_ASSOC) ||
 				      (event->se_assoc_id == SCTP_ALL_ASSOC)))) {
 					SCTP_INP_WLOCK(inp);
 					if (event->se_on) {
 						sctp_feature_on(inp, event_type);
 					} else {
 						sctp_feature_off(inp, event_type);
 					}
 					SCTP_INP_WUNLOCK(inp);
 				}
 				if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 				    ((event->se_assoc_id == SCTP_CURRENT_ASSOC) ||
 				     (event->se_assoc_id == SCTP_ALL_ASSOC))) {
 					SCTP_INP_RLOCK(inp);
 					LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 						SCTP_TCB_LOCK(stcb);
 						if (event->se_on) {
 							sctp_stcb_feature_on(inp, stcb, event_type);
 						} else {
 							sctp_stcb_feature_off(inp, stcb, event_type);
 						}
 						SCTP_TCB_UNLOCK(stcb);
 					}
 					SCTP_INP_RUNLOCK(inp);
 				}
 			}
 		} else {
 			if (stcb) {
 				SCTP_TCB_UNLOCK(stcb);
 			}
 		}
 		break;
 	}
 	case SCTP_RECVRCVINFO:
 	{
 		int *onoff;
 
 		SCTP_CHECK_AND_CAST(onoff, optval, int, optsize);
 		SCTP_INP_WLOCK(inp);
 		if (*onoff != 0) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_RECVRCVINFO);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_RECVRCVINFO);
 		}
 		SCTP_INP_WUNLOCK(inp);
 		break;
 	}
 	case SCTP_RECVNXTINFO:
 	{
 		int *onoff;
 
 		SCTP_CHECK_AND_CAST(onoff, optval, int, optsize);
 		SCTP_INP_WLOCK(inp);
 		if (*onoff != 0) {
 			sctp_feature_on(inp, SCTP_PCB_FLAGS_RECVNXTINFO);
 		} else {
 			sctp_feature_off(inp, SCTP_PCB_FLAGS_RECVNXTINFO);
 		}
 		SCTP_INP_WUNLOCK(inp);
 		break;
 	}
 	case SCTP_DEFAULT_SNDINFO:
 	{
 		struct sctp_sndinfo *info;
 		uint16_t policy;
 
 		SCTP_CHECK_AND_CAST(info, optval, struct sctp_sndinfo, optsize);
 		SCTP_FIND_STCB(inp, stcb, info->snd_assoc_id);
 
 		if (stcb) {
 			if (info->snd_sid < stcb->asoc.streamoutcnt) {
 				stcb->asoc.def_send.sinfo_stream = info->snd_sid;
 				policy = PR_SCTP_POLICY(stcb->asoc.def_send.sinfo_flags);
 				stcb->asoc.def_send.sinfo_flags = info->snd_flags;
 				stcb->asoc.def_send.sinfo_flags |= policy;
 				stcb->asoc.def_send.sinfo_ppid = info->snd_ppid;
 				stcb->asoc.def_send.sinfo_context = info->snd_context;
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((info->snd_assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (info->snd_assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				inp->def_send.sinfo_stream = info->snd_sid;
 				policy = PR_SCTP_POLICY(inp->def_send.sinfo_flags);
 				inp->def_send.sinfo_flags = info->snd_flags;
 				inp->def_send.sinfo_flags |= policy;
 				inp->def_send.sinfo_ppid = info->snd_ppid;
 				inp->def_send.sinfo_context = info->snd_context;
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((info->snd_assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (info->snd_assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					if (info->snd_sid < stcb->asoc.streamoutcnt) {
 						stcb->asoc.def_send.sinfo_stream = info->snd_sid;
 						policy = PR_SCTP_POLICY(stcb->asoc.def_send.sinfo_flags);
 						stcb->asoc.def_send.sinfo_flags = info->snd_flags;
 						stcb->asoc.def_send.sinfo_flags |= policy;
 						stcb->asoc.def_send.sinfo_ppid = info->snd_ppid;
 						stcb->asoc.def_send.sinfo_context = info->snd_context;
 					}
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_DEFAULT_PRINFO:
 	{
 		struct sctp_default_prinfo *info;
 
 		SCTP_CHECK_AND_CAST(info, optval, struct sctp_default_prinfo, optsize);
 		SCTP_FIND_STCB(inp, stcb, info->pr_assoc_id);
 
 		if (info->pr_policy > SCTP_PR_SCTP_MAX) {
 			if (stcb) {
 				SCTP_TCB_UNLOCK(stcb);
 			}
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			break;
 		}
 		if (stcb) {
 			stcb->asoc.def_send.sinfo_flags &= 0xfff0;
 			stcb->asoc.def_send.sinfo_flags |= info->pr_policy;
 			stcb->asoc.def_send.sinfo_timetolive = info->pr_value;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     ((info->pr_assoc_id == SCTP_FUTURE_ASSOC) ||
 			      (info->pr_assoc_id == SCTP_ALL_ASSOC)))) {
 				SCTP_INP_WLOCK(inp);
 				inp->def_send.sinfo_flags &= 0xfff0;
 				inp->def_send.sinfo_flags |= info->pr_policy;
 				inp->def_send.sinfo_timetolive = info->pr_value;
 				SCTP_INP_WUNLOCK(inp);
 			}
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			    ((info->pr_assoc_id == SCTP_CURRENT_ASSOC) ||
 			     (info->pr_assoc_id == SCTP_ALL_ASSOC))) {
 				SCTP_INP_RLOCK(inp);
 				LIST_FOREACH(stcb, &inp->sctp_asoc_list, sctp_tcblist) {
 					SCTP_TCB_LOCK(stcb);
 					stcb->asoc.def_send.sinfo_flags &= 0xfff0;
 					stcb->asoc.def_send.sinfo_flags |= info->pr_policy;
 					stcb->asoc.def_send.sinfo_timetolive = info->pr_value;
 					SCTP_TCB_UNLOCK(stcb);
 				}
 				SCTP_INP_RUNLOCK(inp);
 			}
 		}
 		break;
 	}
 	case SCTP_PEER_ADDR_THLDS:
 		/* Applies to the specific association */
 	{
 		struct sctp_paddrthlds *thlds;
 		struct sctp_nets *net;
 		struct sockaddr *addr;
 #if defined(INET) && defined(INET6)
 		struct sockaddr_in sin_store;
 #endif
 
 		SCTP_CHECK_AND_CAST(thlds, optval, struct sctp_paddrthlds, optsize);
 		SCTP_FIND_STCB(inp, stcb, thlds->spt_assoc_id);
 
 #if defined(INET) && defined(INET6)
 		if (thlds->spt_address.ss_family == AF_INET6) {
 			struct sockaddr_in6 *sin6;
 
 			sin6 = (struct sockaddr_in6 *)&thlds->spt_address;
 			if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
 				in6_sin6_2_sin(&sin_store, sin6);
 				addr = (struct sockaddr *)&sin_store;
 			} else {
 				addr = (struct sockaddr *)&thlds->spt_address;
 			}
 		} else {
 			addr = (struct sockaddr *)&thlds->spt_address;
 		}
 #else
 		addr = (struct sockaddr *)&thlds->spt_address;
 #endif
 		if (stcb != NULL) {
 			net = sctp_findnet(stcb, addr);
 		} else {
 			/* We increment here since sctp_findassociation_ep_addr() wil
 			 * do a decrement if it finds the stcb as long as the locked
 			 * tcb (last argument) is NOT a TCB.. aka NULL.
 			 */
 			net = NULL;
 			SCTP_INP_INCR_REF(inp);
 			stcb = sctp_findassociation_ep_addr(&inp, addr,
 			                                    &net, NULL, NULL);
 			if (stcb == NULL) {
 				SCTP_INP_DECR_REF(inp);
 			}
 		}
 		if ((stcb != NULL) && (net == NULL)) {
 #ifdef INET
 			if (addr->sa_family == AF_INET) {
 				struct sockaddr_in *sin;
 
 				sin = (struct sockaddr_in *)addr;
 				if (sin->sin_addr.s_addr != INADDR_ANY) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					SCTP_TCB_UNLOCK(stcb);
 					error = EINVAL;
 					break;
 				}
 			} else
 #endif
 #ifdef INET6
 			if (addr->sa_family == AF_INET6) {
 				struct sockaddr_in6 *sin6;
 
 				sin6 = (struct sockaddr_in6 *)addr;
 				if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					SCTP_TCB_UNLOCK(stcb);
 					error = EINVAL;
 					break;
 				}
 			} else
 #endif
 #if defined(__Userspace__)
 			if (addr->sa_family == AF_CONN) {
 				struct sockaddr_conn *sconn;
 
 				sconn = (struct sockaddr_conn *)addr;
 				if (sconn->sconn_addr != NULL) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					SCTP_TCB_UNLOCK(stcb);
 					error = EINVAL;
 					break;
 				}
 			} else
 #endif
 			{
 				error = EAFNOSUPPORT;
 				SCTP_TCB_UNLOCK(stcb);
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, error);
 				break;
 			}
 		}
 		if (thlds->spt_pathcpthld != 0xffff) {
 			if (stcb != NULL) {
 				SCTP_TCB_UNLOCK(stcb);
 			}
 			error = EINVAL;
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, error);
 			break;
 		}
 		if (stcb != NULL) {
 			if (net != NULL) {
 				net->failure_threshold = thlds->spt_pathmaxrxt;
 				net->pf_threshold = thlds->spt_pathpfthld;
 				if (net->dest_state & SCTP_ADDR_PF) {
 					if ((net->error_count > net->failure_threshold) ||
 					    (net->error_count <= net->pf_threshold)) {
 						net->dest_state &= ~SCTP_ADDR_PF;
 					}
 				} else {
 					if ((net->error_count > net->pf_threshold) &&
 					    (net->error_count <= net->failure_threshold)) {
 						net->dest_state |= SCTP_ADDR_PF;
 						sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 						sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 						                stcb->sctp_ep, stcb, net,
 						                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_17);
 						sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 					}
 				}
 				if (net->dest_state & SCTP_ADDR_REACHABLE) {
 					if (net->error_count > net->failure_threshold) {
 						net->dest_state &= ~SCTP_ADDR_REACHABLE;
 						sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_DOWN, stcb, 0, net, SCTP_SO_LOCKED);
 					}
 				} else {
 					if (net->error_count <= net->failure_threshold) {
 						net->dest_state |= SCTP_ADDR_REACHABLE;
 						sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_UP, stcb, 0, net, SCTP_SO_LOCKED);
 					}
 				}
 			} else {
 				TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 					net->failure_threshold = thlds->spt_pathmaxrxt;
 					net->pf_threshold = thlds->spt_pathpfthld;
 					if (net->dest_state & SCTP_ADDR_PF) {
 						if ((net->error_count > net->failure_threshold) ||
 						    (net->error_count <= net->pf_threshold)) {
 							net->dest_state &= ~SCTP_ADDR_PF;
 						}
 					} else {
 						if ((net->error_count > net->pf_threshold) &&
 						    (net->error_count <= net->failure_threshold)) {
 							net->dest_state |= SCTP_ADDR_PF;
 							sctp_send_hb(stcb, net, SCTP_SO_LOCKED);
 							sctp_timer_stop(SCTP_TIMER_TYPE_HEARTBEAT,
 							                stcb->sctp_ep, stcb, net,
 							                SCTP_FROM_SCTP_USRREQ + SCTP_LOC_18);
 							sctp_timer_start(SCTP_TIMER_TYPE_HEARTBEAT, stcb->sctp_ep, stcb, net);
 						}
 					}
 					if (net->dest_state & SCTP_ADDR_REACHABLE) {
 						if (net->error_count > net->failure_threshold) {
 							net->dest_state &= ~SCTP_ADDR_REACHABLE;
 							sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_DOWN, stcb, 0, net, SCTP_SO_LOCKED);
 						}
 					} else {
 						if (net->error_count <= net->failure_threshold) {
 							net->dest_state |= SCTP_ADDR_REACHABLE;
 							sctp_ulp_notify(SCTP_NOTIFY_INTERFACE_UP, stcb, 0, net, SCTP_SO_LOCKED);
 						}
 					}
 				}
 				stcb->asoc.def_net_failure = thlds->spt_pathmaxrxt;
 				stcb->asoc.def_net_pf_threshold = thlds->spt_pathpfthld;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (thlds->spt_assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				inp->sctp_ep.def_net_failure = thlds->spt_pathmaxrxt;
 				inp->sctp_ep.def_net_pf_threshold = thlds->spt_pathpfthld;
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_REMOTE_UDP_ENCAPS_PORT:
 	{
 		struct sctp_udpencaps *encaps;
 		struct sctp_nets *net;
 		struct sockaddr *addr;
 #if defined(INET) && defined(INET6)
 		struct sockaddr_in sin_store;
 #endif
 
 		SCTP_CHECK_AND_CAST(encaps, optval, struct sctp_udpencaps, optsize);
 		SCTP_FIND_STCB(inp, stcb, encaps->sue_assoc_id);
 
 #if defined(INET) && defined(INET6)
 		if (encaps->sue_address.ss_family == AF_INET6) {
 			struct sockaddr_in6 *sin6;
 
 			sin6 = (struct sockaddr_in6 *)&encaps->sue_address;
 			if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
 				in6_sin6_2_sin(&sin_store, sin6);
 				addr = (struct sockaddr *)&sin_store;
 			} else {
 				addr = (struct sockaddr *)&encaps->sue_address;
 			}
 		} else {
 			addr = (struct sockaddr *)&encaps->sue_address;
 		}
 #else
 		addr = (struct sockaddr *)&encaps->sue_address;
 #endif
 		if (stcb != NULL) {
 			net = sctp_findnet(stcb, addr);
 		} else {
 			/* We increment here since sctp_findassociation_ep_addr() wil
 			 * do a decrement if it finds the stcb as long as the locked
 			 * tcb (last argument) is NOT a TCB.. aka NULL.
 			 */
 			net = NULL;
 			SCTP_INP_INCR_REF(inp);
 			stcb = sctp_findassociation_ep_addr(&inp, addr, &net, NULL, NULL);
 			if (stcb == NULL) {
 				SCTP_INP_DECR_REF(inp);
 			}
 		}
 		if ((stcb != NULL) && (net == NULL)) {
 #ifdef INET
 			if (addr->sa_family == AF_INET) {
 				struct sockaddr_in *sin;
 
 				sin = (struct sockaddr_in *)addr;
 				if (sin->sin_addr.s_addr != INADDR_ANY) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					SCTP_TCB_UNLOCK(stcb);
 					error = EINVAL;
 					break;
 				}
 			} else
 #endif
 #ifdef INET6
 			if (addr->sa_family == AF_INET6) {
 				struct sockaddr_in6 *sin6;
 
 				sin6 = (struct sockaddr_in6 *)addr;
 				if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					SCTP_TCB_UNLOCK(stcb);
 					error = EINVAL;
 					break;
 				}
 			} else
 #endif
 #if defined(__Userspace__)
 			if (addr->sa_family == AF_CONN) {
 				struct sockaddr_conn *sconn;
 
 				sconn = (struct sockaddr_conn *)addr;
 				if (sconn->sconn_addr != NULL) {
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					SCTP_TCB_UNLOCK(stcb);
 					error = EINVAL;
 					break;
 				}
 			} else
 #endif
 			{
 					error = EAFNOSUPPORT;
 					SCTP_TCB_UNLOCK(stcb);
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, error);
 					break;
 				}
 		}
 
 		if (stcb != NULL) {
 			if (net != NULL) {
 				net->port = encaps->sue_port;
 			} else {
 				stcb->asoc.port = encaps->sue_port;
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (encaps->sue_assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				inp->sctp_ep.port = encaps->sue_port;
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_ECN_SUPPORTED:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				if (av->assoc_value == 0) {
 					inp->ecn_supported = 0;
 				} else {
 					inp->ecn_supported = 1;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_PR_SUPPORTED:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				if (av->assoc_value == 0) {
 					inp->prsctp_supported = 0;
 				} else {
 					inp->prsctp_supported = 1;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_AUTH_SUPPORTED:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				if ((av->assoc_value == 0) &&
 				    (inp->asconf_supported == 1)) {
 				    	/* AUTH is required for ASCONF */
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 				} else {
 					SCTP_INP_WLOCK(inp);
 					if (av->assoc_value == 0) {
 						inp->auth_supported = 0;
 					} else {
 						inp->auth_supported = 1;
 					}
 					SCTP_INP_WUNLOCK(inp);
 				}
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_ASCONF_SUPPORTED:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				if ((av->assoc_value != 0) &&
 				    (inp->auth_supported == 0)) {
 				    	/* AUTH is required for ASCONF */
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 					error = EINVAL;
 				} else {
 					SCTP_INP_WLOCK(inp);
 					if (av->assoc_value == 0) {
 						inp->asconf_supported = 0;
 						sctp_auth_delete_chunk(SCTP_ASCONF,
 						                       inp->sctp_ep.local_auth_chunks);
 						sctp_auth_delete_chunk(SCTP_ASCONF_ACK,
 						                       inp->sctp_ep.local_auth_chunks);
 					} else {
 						inp->asconf_supported = 1;
 						sctp_auth_add_chunk(SCTP_ASCONF,
 						                    inp->sctp_ep.local_auth_chunks);
 						sctp_auth_add_chunk(SCTP_ASCONF_ACK,
 						                    inp->sctp_ep.local_auth_chunks);
 					}
 					SCTP_INP_WUNLOCK(inp);
 				}
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_RECONFIG_SUPPORTED:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				if (av->assoc_value == 0) {
 					inp->reconfig_supported = 0;
 				} else {
 					inp->reconfig_supported = 1;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_NRSACK_SUPPORTED:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				if (av->assoc_value == 0) {
 					inp->nrsack_supported = 0;
 				} else {
 					inp->nrsack_supported = 1;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_PKTDROP_SUPPORTED:
 	{
 		struct sctp_assoc_value *av;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			error = EINVAL;
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				if (av->assoc_value == 0) {
 					inp->pktdrop_supported = 0;
 				} else {
 					inp->pktdrop_supported = 1;
 				}
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	case SCTP_MAX_CWND:
 	{
 		struct sctp_assoc_value *av;
 		struct sctp_nets *net;
 
 		SCTP_CHECK_AND_CAST(av, optval, struct sctp_assoc_value, optsize);
 		SCTP_FIND_STCB(inp, stcb, av->assoc_id);
 
 		if (stcb) {
 			stcb->asoc.max_cwnd = av->assoc_value;
 			if (stcb->asoc.max_cwnd > 0) {
 				TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 					if ((net->cwnd > stcb->asoc.max_cwnd) &&
 					    (net->cwnd > (net->mtu - sizeof(struct sctphdr)))) {
 						net->cwnd = stcb->asoc.max_cwnd;
 						if (net->cwnd < (net->mtu - sizeof(struct sctphdr))) {
 							net->cwnd = net->mtu - sizeof(struct sctphdr);
 						}
 					}
 				}
 			}
 			SCTP_TCB_UNLOCK(stcb);
 		} else {
 			if ((inp->sctp_flags & SCTP_PCB_FLAGS_TCPTYPE) ||
 			    (inp->sctp_flags & SCTP_PCB_FLAGS_IN_TCPPOOL) ||
 			    ((inp->sctp_flags & SCTP_PCB_FLAGS_UDPTYPE) &&
 			     (av->assoc_id == SCTP_FUTURE_ASSOC))) {
 				SCTP_INP_WLOCK(inp);
 				inp->max_cwnd = av->assoc_value;
 				SCTP_INP_WUNLOCK(inp);
 			} else {
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 				error = EINVAL;
 			}
 		}
 		break;
 	}
 	default:
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOPROTOOPT);
 		error = ENOPROTOOPT;
 		break;
 	} /* end switch (opt) */
 	return (error);
 }
 
 #if !defined(__Userspace__)
