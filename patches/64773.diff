commit 7a1830a7b43562912c0fb555ef2bd101da624b21
Author: Even Rouault <even.rouault@spatialys.com>
Date:   Wed Dec 6 22:39:15 2023 +0100

    shpopen.c: correctly use uint32_t (was broken in 74d53797679e924cc8d57df6759eec673fa4f38e, master only, fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=64773)

diff --git a/ogr/ogrsf_frmts/shape/shpopen.c b/ogr/ogrsf_frmts/shape/shpopen.c
index e6a44dd27a..9a8d07a043 100644
--- a/ogr/ogrsf_frmts/shape/shpopen.c
+++ b/ogr/ogrsf_frmts/shape/shpopen.c
@@ -105,152 +105,152 @@ static void SwapWord(int length, void *wordP)
 void SHPAPI_CALL SHPWriteHeader(SHPHandle psSHP)
 {
     if (psSHP->fpSHX == SHPLIB_NULLPTR)
     {
         psSHP->sHooks.Error("SHPWriteHeader failed : SHX file is closed");
         return;
     }
 
     /* -------------------------------------------------------------------- */
     /*      Prepare header block for .shp file.                             */
     /* -------------------------------------------------------------------- */
 
     unsigned char abyHeader[100] = {0};
     abyHeader[2] = 0x27; /* magic cookie */
     abyHeader[3] = 0x0a;
 
-    int32_t i32 = psSHP->nFileSize / 2; /* file size */
+    uint32_t i32 = psSHP->nFileSize / 2; /* file size */
     ByteCopy(&i32, abyHeader + 24, 4);
     if (!bBigEndian)
         SwapWord(4, abyHeader + 24);
 
     i32 = 1000; /* version */
     ByteCopy(&i32, abyHeader + 28, 4);
     if (bBigEndian)
         SwapWord(4, abyHeader + 28);
 
     i32 = psSHP->nShapeType; /* shape type */
     ByteCopy(&i32, abyHeader + 32, 4);
     if (bBigEndian)
         SwapWord(4, abyHeader + 32);
 
     double dValue = psSHP->adBoundsMin[0]; /* set bounds */
     ByteCopy(&dValue, abyHeader + 36, 8);
     if (bBigEndian)
         SwapWord(8, abyHeader + 36);
 
     dValue = psSHP->adBoundsMin[1];
     ByteCopy(&dValue, abyHeader + 44, 8);
     if (bBigEndian)
         SwapWord(8, abyHeader + 44);
 
     dValue = psSHP->adBoundsMax[0];
     ByteCopy(&dValue, abyHeader + 52, 8);
     if (bBigEndian)
         SwapWord(8, abyHeader + 52);
 
     dValue = psSHP->adBoundsMax[1];
     ByteCopy(&dValue, abyHeader + 60, 8);
     if (bBigEndian)
         SwapWord(8, abyHeader + 60);
 
     dValue = psSHP->adBoundsMin[2]; /* z */
     ByteCopy(&dValue, abyHeader + 68, 8);
     if (bBigEndian)
         SwapWord(8, abyHeader + 68);
 
     dValue = psSHP->adBoundsMax[2];
     ByteCopy(&dValue, abyHeader + 76, 8);
     if (bBigEndian)
         SwapWord(8, abyHeader + 76);
 
     dValue = psSHP->adBoundsMin[3]; /* m */
     ByteCopy(&dValue, abyHeader + 84, 8);
     if (bBigEndian)
         SwapWord(8, abyHeader + 84);
 
     dValue = psSHP->adBoundsMax[3];
     ByteCopy(&dValue, abyHeader + 92, 8);
     if (bBigEndian)
         SwapWord(8, abyHeader + 92);
 
     /* -------------------------------------------------------------------- */
     /*      Write .shp file header.                                         */
     /* -------------------------------------------------------------------- */
     if (psSHP->sHooks.FSeek(psSHP->fpSHP, 0, 0) != 0 ||
         psSHP->sHooks.FWrite(abyHeader, 100, 1, psSHP->fpSHP) != 1)
     {
         char szErrorMsg[200];
 
         snprintf(szErrorMsg, sizeof(szErrorMsg),
                  "Failure writing .shp header: %s", strerror(errno));
         szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
         psSHP->sHooks.Error(szErrorMsg);
         return;
     }
 
     /* -------------------------------------------------------------------- */
     /*      Prepare, and write .shx file header.                            */
     /* -------------------------------------------------------------------- */
-    i32 = (psSHP->nRecords * 2 * sizeof(int32_t) + 100) / 2; /* file size */
+    i32 = (psSHP->nRecords * 2 * sizeof(uint32_t) + 100) / 2; /* file size */
     ByteCopy(&i32, abyHeader + 24, 4);
     if (!bBigEndian)
         SwapWord(4, abyHeader + 24);
 
     if (psSHP->sHooks.FSeek(psSHP->fpSHX, 0, 0) != 0 ||
         psSHP->sHooks.FWrite(abyHeader, 100, 1, psSHP->fpSHX) != 1)
     {
         char szErrorMsg[200];
 
         snprintf(szErrorMsg, sizeof(szErrorMsg),
                  "Failure writing .shx header: %s", strerror(errno));
         szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
         psSHP->sHooks.Error(szErrorMsg);
 
         return;
     }
 
     /* -------------------------------------------------------------------- */
     /*      Write out the .shx contents.                                    */
     /* -------------------------------------------------------------------- */
-    int32_t *panSHX =
-        STATIC_CAST(int32_t *, malloc(sizeof(int32_t) * 2 * psSHP->nRecords));
+    uint32_t *panSHX =
+        STATIC_CAST(uint32_t *, malloc(sizeof(uint32_t) * 2 * psSHP->nRecords));
     if (panSHX == SHPLIB_NULLPTR)
     {
         psSHP->sHooks.Error("Failure allocatin panSHX");
         return;
     }
 
     for (int i = 0; i < psSHP->nRecords; i++)
     {
         panSHX[i * 2] = psSHP->panRecOffset[i] / 2;
         panSHX[i * 2 + 1] = psSHP->panRecSize[i] / 2;
         if (!bBigEndian)
             SwapWord(4, panSHX + i * 2);
         if (!bBigEndian)
             SwapWord(4, panSHX + i * 2 + 1);
     }
 
-    if (STATIC_CAST(int, psSHP->sHooks.FWrite(panSHX, sizeof(int32_t) * 2,
+    if (STATIC_CAST(int, psSHP->sHooks.FWrite(panSHX, sizeof(uint32_t) * 2,
                                               psSHP->nRecords, psSHP->fpSHX)) !=
         psSHP->nRecords)
     {
         char szErrorMsg[200];
 
         snprintf(szErrorMsg, sizeof(szErrorMsg),
                  "Failure writing .shx contents: %s", strerror(errno));
         szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
         psSHP->sHooks.Error(szErrorMsg);
     }
 
     free(panSHX);
 
     /* -------------------------------------------------------------------- */
     /*      Flush to disk.                                                  */
     /* -------------------------------------------------------------------- */
     psSHP->sHooks.FFlush(psSHP->fpSHP);
     psSHP->sHooks.FFlush(psSHP->fpSHX);
 }
 
 /************************************************************************/
 /*                              SHPOpen()                               */
 /************************************************************************/
@@ -1017,160 +1017,160 @@ SHPHandle SHPAPI_CALL SHPCreate(const char *pszLayer, int nShapeType)
 SHPHandle SHPAPI_CALL SHPCreateLL(const char *pszLayer, int nShapeType,
                                   const SAHooks *psHooks)
 {
 /* -------------------------------------------------------------------- */
 /*      Establish the byte order on this system.                        */
 /* -------------------------------------------------------------------- */
 #if !defined(bBigEndian)
     {
         int i = 1;
         if (*((unsigned char *)&i) == 1)
             bBigEndian = false;
         else
             bBigEndian = true;
     }
 #endif
 
     /* -------------------------------------------------------------------- */
     /*      Open the two files so we can write their headers.               */
     /* -------------------------------------------------------------------- */
     const int nLenWithoutExtension = SHPGetLenWithoutExtension(pszLayer);
     char *pszFullname = STATIC_CAST(char *, malloc(nLenWithoutExtension + 5));
     memcpy(pszFullname, pszLayer, nLenWithoutExtension);
     memcpy(pszFullname + nLenWithoutExtension, ".shp", 5);
     SAFile fpSHP = psHooks->FOpen(pszFullname, "w+b");
     if (fpSHP == SHPLIB_NULLPTR)
     {
         char szErrorMsg[200];
         snprintf(szErrorMsg, sizeof(szErrorMsg), "Failed to create file %s: %s",
                  pszFullname, strerror(errno));
         psHooks->Error(szErrorMsg);
 
         free(pszFullname);
         return NULL;
     }
 
     memcpy(pszFullname + nLenWithoutExtension, ".shx", 5);
     SAFile fpSHX = psHooks->FOpen(pszFullname, "w+b");
     if (fpSHX == SHPLIB_NULLPTR)
     {
         char szErrorMsg[200];
         snprintf(szErrorMsg, sizeof(szErrorMsg), "Failed to create file %s: %s",
                  pszFullname, strerror(errno));
         psHooks->Error(szErrorMsg);
 
         free(pszFullname);
         psHooks->FClose(fpSHP);
         return NULL;
     }
 
     free(pszFullname);
     pszFullname = SHPLIB_NULLPTR;
 
     /* -------------------------------------------------------------------- */
     /*      Prepare header block for .shp file.                             */
     /* -------------------------------------------------------------------- */
     unsigned char abyHeader[100];
     memset(abyHeader, 0, sizeof(abyHeader));
 
     abyHeader[2] = 0x27; /* magic cookie */
     abyHeader[3] = 0x0a;
 
-    int32_t i32 = 50; /* file size */
+    uint32_t i32 = 50; /* file size */
     ByteCopy(&i32, abyHeader + 24, 4);
     if (!bBigEndian)
         SwapWord(4, abyHeader + 24);
 
     i32 = 1000; /* version */
     ByteCopy(&i32, abyHeader + 28, 4);
     if (bBigEndian)
         SwapWord(4, abyHeader + 28);
 
     i32 = nShapeType; /* shape type */
     ByteCopy(&i32, abyHeader + 32, 4);
     if (bBigEndian)
         SwapWord(4, abyHeader + 32);
 
     double dValue = 0.0; /* set bounds */
     ByteCopy(&dValue, abyHeader + 36, 8);
     ByteCopy(&dValue, abyHeader + 44, 8);
     ByteCopy(&dValue, abyHeader + 52, 8);
     ByteCopy(&dValue, abyHeader + 60, 8);
 
     /* -------------------------------------------------------------------- */
     /*      Write .shp file header.                                         */
     /* -------------------------------------------------------------------- */
     if (psHooks->FWrite(abyHeader, 100, 1, fpSHP) != 1)
     {
         char szErrorMsg[200];
 
         snprintf(szErrorMsg, sizeof(szErrorMsg),
                  "Failed to write .shp header: %s", strerror(errno));
         szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
         psHooks->Error(szErrorMsg);
 
         free(pszFullname);
         psHooks->FClose(fpSHP);
         psHooks->FClose(fpSHX);
         return NULL;
     }
 
     /* -------------------------------------------------------------------- */
     /*      Prepare, and write .shx file header.                            */
     /* -------------------------------------------------------------------- */
     i32 = 50; /* file size */
     ByteCopy(&i32, abyHeader + 24, 4);
     if (!bBigEndian)
         SwapWord(4, abyHeader + 24);
 
     if (psHooks->FWrite(abyHeader, 100, 1, fpSHX) != 1)
     {
         char szErrorMsg[200];
 
         snprintf(szErrorMsg, sizeof(szErrorMsg),
                  "Failure writing .shx header: %s", strerror(errno));
         szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
         psHooks->Error(szErrorMsg);
 
         free(pszFullname);
         psHooks->FClose(fpSHP);
         psHooks->FClose(fpSHX);
         return NULL;
     }
 
     SHPHandle psSHP = STATIC_CAST(SHPHandle, calloc(sizeof(SHPInfo), 1));
 
     psSHP->bUpdated = FALSE;
     memcpy(&(psSHP->sHooks), psHooks, sizeof(SAHooks));
 
     psSHP->fpSHP = fpSHP;
     psSHP->fpSHX = fpSHX;
     psSHP->nShapeType = nShapeType;
     psSHP->nFileSize = 100;
     psSHP->panRecOffset =
         STATIC_CAST(unsigned int *, malloc(sizeof(unsigned int)));
     psSHP->panRecSize =
         STATIC_CAST(unsigned int *, malloc(sizeof(unsigned int)));
 
     if (psSHP->panRecOffset == SHPLIB_NULLPTR ||
         psSHP->panRecSize == SHPLIB_NULLPTR)
     {
         psSHP->sHooks.Error("Not enough memory to allocate requested memory");
         psSHP->sHooks.FClose(psSHP->fpSHP);
         psSHP->sHooks.FClose(psSHP->fpSHX);
         if (psSHP->panRecOffset)
             free(psSHP->panRecOffset);
         if (psSHP->panRecSize)
             free(psSHP->panRecSize);
         free(psSHP);
         return SHPLIB_NULLPTR;
     }
 
     return psSHP;
 }
 
 /************************************************************************/
 /*                           _SHPSetBounds()                            */
 /*                                                                      */
 /*      Compute a bounds rectangle for a shape, and set it into the     */
 /*      indicated location in the record.                               */
 /************************************************************************/
@@ -1368,502 +1368,502 @@ SHPObject SHPAPI_CALL1(*)
 int SHPAPI_CALL SHPWriteObject(SHPHandle psSHP, int nShapeId,
                                SHPObject *psObject)
 {
     psSHP->bUpdated = TRUE;
 
     /* -------------------------------------------------------------------- */
     /*      Ensure that shape object matches the type of the file it is     */
     /*      being written to.                                               */
     /* -------------------------------------------------------------------- */
     assert(psObject->nSHPType == psSHP->nShapeType ||
            psObject->nSHPType == SHPT_NULL);
 
     /* -------------------------------------------------------------------- */
     /*      Ensure that -1 is used for appends.  Either blow an             */
     /*      assertion, or if they are disabled, set the shapeid to -1       */
     /*      for appends.                                                    */
     /* -------------------------------------------------------------------- */
     assert(nShapeId == -1 || (nShapeId >= 0 && nShapeId < psSHP->nRecords));
 
     if (nShapeId != -1 && nShapeId >= psSHP->nRecords)
         nShapeId = -1;
 
     /* -------------------------------------------------------------------- */
     /*      Add the new entity to the in memory index.                      */
     /* -------------------------------------------------------------------- */
     if (nShapeId == -1 && psSHP->nRecords + 1 > psSHP->nMaxRecords)
     {
         /* This cannot overflow given that we check that the file size does
          * not grow over 4 GB, and the minimum size of a record is 12 bytes,
          * hence the maximm value for nMaxRecords is 357,913,941
          */
         int nNewMaxRecords = psSHP->nMaxRecords + psSHP->nMaxRecords / 3 + 100;
         unsigned int *panRecOffsetNew;
         unsigned int *panRecSizeNew;
 
         panRecOffsetNew = STATIC_CAST(
             unsigned int *, realloc(psSHP->panRecOffset,
                                     sizeof(unsigned int) * nNewMaxRecords));
         if (panRecOffsetNew == SHPLIB_NULLPTR)
         {
             psSHP->sHooks.Error("Failed to write shape object. "
                                 "Memory allocation error.");
             return -1;
         }
         psSHP->panRecOffset = panRecOffsetNew;
 
         panRecSizeNew = STATIC_CAST(
             unsigned int *,
             realloc(psSHP->panRecSize, sizeof(unsigned int) * nNewMaxRecords));
         if (panRecSizeNew == SHPLIB_NULLPTR)
         {
             psSHP->sHooks.Error("Failed to write shape object. "
                                 "Memory allocation error.");
             return -1;
         }
         psSHP->panRecSize = panRecSizeNew;
 
         psSHP->nMaxRecords = nNewMaxRecords;
     }
 
     /* -------------------------------------------------------------------- */
     /*      Initialize record.                                              */
     /* -------------------------------------------------------------------- */
 
     /* The following computation cannot overflow on 32-bit platforms given that
      * the user had to allocate arrays of at least that size. */
     size_t nRecMaxSize =
         psObject->nVertices * 4 * sizeof(double) + psObject->nParts * 8;
     /* But the following test could trigger on 64-bit platforms on huge
      * geometries. */
     const unsigned nExtraSpaceForGeomHeader = 128;
     if (nRecMaxSize > UINT_MAX - nExtraSpaceForGeomHeader)
     {
         psSHP->sHooks.Error("Failed to write shape object. Too big geometry.");
         return -1;
     }
     nRecMaxSize += nExtraSpaceForGeomHeader;
     unsigned char *pabyRec = STATIC_CAST(unsigned char *, malloc(nRecMaxSize));
     if (pabyRec == SHPLIB_NULLPTR)
     {
         psSHP->sHooks.Error("Failed to write shape object. "
                             "Memory allocation error.");
         return -1;
     }
 
     /* -------------------------------------------------------------------- */
     /*      Extract vertices for a Polygon or Arc.                          */
     /* -------------------------------------------------------------------- */
     unsigned int nRecordSize = 0;
     const bool bFirstFeature = psSHP->nRecords == 0;
 
     if (psObject->nSHPType == SHPT_POLYGON ||
         psObject->nSHPType == SHPT_POLYGONZ ||
         psObject->nSHPType == SHPT_POLYGONM || psObject->nSHPType == SHPT_ARC ||
         psObject->nSHPType == SHPT_ARCZ || psObject->nSHPType == SHPT_ARCM ||
         psObject->nSHPType == SHPT_MULTIPATCH)
     {
-        int32_t nPoints = psObject->nVertices;
-        int32_t nParts = psObject->nParts;
+        uint32_t nPoints = psObject->nVertices;
+        uint32_t nParts = psObject->nParts;
 
         _SHPSetBounds(pabyRec + 12, psObject);
 
         if (bBigEndian)
             SwapWord(4, &nPoints);
         if (bBigEndian)
             SwapWord(4, &nParts);
 
         ByteCopy(&nPoints, pabyRec + 40 + 8, 4);
         ByteCopy(&nParts, pabyRec + 36 + 8, 4);
 
         nRecordSize = 52;
 
         /*
          * Write part start positions.
          */
         ByteCopy(psObject->panPartStart, pabyRec + 44 + 8,
                  4 * psObject->nParts);
         for (int i = 0; i < psObject->nParts; i++)
         {
             if (bBigEndian)
                 SwapWord(4, pabyRec + 44 + 8 + 4 * i);
             nRecordSize += 4;
         }
 
         /*
          * Write multipatch part types if needed.
          */
         if (psObject->nSHPType == SHPT_MULTIPATCH)
         {
             memcpy(pabyRec + nRecordSize, psObject->panPartType,
                    4 * psObject->nParts);
             for (int i = 0; i < psObject->nParts; i++)
             {
                 if (bBigEndian)
                     SwapWord(4, pabyRec + nRecordSize);
                 nRecordSize += 4;
             }
         }
 
         /*
          * Write the (x,y) vertex values.
          */
         for (int i = 0; i < psObject->nVertices; i++)
         {
             ByteCopy(psObject->padfX + i, pabyRec + nRecordSize, 8);
             ByteCopy(psObject->padfY + i, pabyRec + nRecordSize + 8, 8);
 
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
 
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize + 8);
 
             nRecordSize += 2 * 8;
         }
 
         /*
          * Write the Z coordinates (if any).
          */
         if (psObject->nSHPType == SHPT_POLYGONZ ||
             psObject->nSHPType == SHPT_ARCZ ||
             psObject->nSHPType == SHPT_MULTIPATCH)
         {
             ByteCopy(&(psObject->dfZMin), pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
 
             ByteCopy(&(psObject->dfZMax), pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
 
             for (int i = 0; i < psObject->nVertices; i++)
             {
                 ByteCopy(psObject->padfZ + i, pabyRec + nRecordSize, 8);
                 if (bBigEndian)
                     SwapWord(8, pabyRec + nRecordSize);
                 nRecordSize += 8;
             }
         }
 
         /*
          * Write the M values, if any.
          */
         if (psObject->bMeasureIsUsed &&
             (psObject->nSHPType == SHPT_POLYGONM ||
              psObject->nSHPType == SHPT_ARCM
 #ifndef DISABLE_MULTIPATCH_MEASURE
              || psObject->nSHPType == SHPT_MULTIPATCH
 #endif
              || psObject->nSHPType == SHPT_POLYGONZ ||
              psObject->nSHPType == SHPT_ARCZ))
         {
             ByteCopy(&(psObject->dfMMin), pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
 
             ByteCopy(&(psObject->dfMMax), pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
 
             for (int i = 0; i < psObject->nVertices; i++)
             {
                 ByteCopy(psObject->padfM + i, pabyRec + nRecordSize, 8);
                 if (bBigEndian)
                     SwapWord(8, pabyRec + nRecordSize);
                 nRecordSize += 8;
             }
         }
     }
 
     /* -------------------------------------------------------------------- */
     /*      Extract vertices for a MultiPoint.                              */
     /* -------------------------------------------------------------------- */
     else if (psObject->nSHPType == SHPT_MULTIPOINT ||
              psObject->nSHPType == SHPT_MULTIPOINTZ ||
              psObject->nSHPType == SHPT_MULTIPOINTM)
     {
-        int32_t nPoints = psObject->nVertices;
+        uint32_t nPoints = psObject->nVertices;
 
         _SHPSetBounds(pabyRec + 12, psObject);
 
         if (bBigEndian)
             SwapWord(4, &nPoints);
         ByteCopy(&nPoints, pabyRec + 44, 4);
 
         for (int i = 0; i < psObject->nVertices; i++)
         {
             ByteCopy(psObject->padfX + i, pabyRec + 48 + i * 16, 8);
             ByteCopy(psObject->padfY + i, pabyRec + 48 + i * 16 + 8, 8);
 
             if (bBigEndian)
                 SwapWord(8, pabyRec + 48 + i * 16);
             if (bBigEndian)
                 SwapWord(8, pabyRec + 48 + i * 16 + 8);
         }
 
         nRecordSize = 48 + 16 * psObject->nVertices;
 
         if (psObject->nSHPType == SHPT_MULTIPOINTZ)
         {
             ByteCopy(&(psObject->dfZMin), pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
 
             ByteCopy(&(psObject->dfZMax), pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
 
             for (int i = 0; i < psObject->nVertices; i++)
             {
                 ByteCopy(psObject->padfZ + i, pabyRec + nRecordSize, 8);
                 if (bBigEndian)
                     SwapWord(8, pabyRec + nRecordSize);
                 nRecordSize += 8;
             }
         }
 
         if (psObject->bMeasureIsUsed &&
             (psObject->nSHPType == SHPT_MULTIPOINTZ ||
              psObject->nSHPType == SHPT_MULTIPOINTM))
         {
             ByteCopy(&(psObject->dfMMin), pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
 
             ByteCopy(&(psObject->dfMMax), pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
 
             for (int i = 0; i < psObject->nVertices; i++)
             {
                 ByteCopy(psObject->padfM + i, pabyRec + nRecordSize, 8);
                 if (bBigEndian)
                     SwapWord(8, pabyRec + nRecordSize);
                 nRecordSize += 8;
             }
         }
     }
 
     /* -------------------------------------------------------------------- */
     /*      Write point.                                                    */
     /* -------------------------------------------------------------------- */
     else if (psObject->nSHPType == SHPT_POINT ||
              psObject->nSHPType == SHPT_POINTZ ||
              psObject->nSHPType == SHPT_POINTM)
     {
         ByteCopy(psObject->padfX, pabyRec + 12, 8);
         ByteCopy(psObject->padfY, pabyRec + 20, 8);
 
         if (bBigEndian)
             SwapWord(8, pabyRec + 12);
         if (bBigEndian)
             SwapWord(8, pabyRec + 20);
 
         nRecordSize = 28;
 
         if (psObject->nSHPType == SHPT_POINTZ)
         {
             ByteCopy(psObject->padfZ, pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
         }
 
         if (psObject->bMeasureIsUsed && (psObject->nSHPType == SHPT_POINTZ ||
                                          psObject->nSHPType == SHPT_POINTM))
         {
             ByteCopy(psObject->padfM, pabyRec + nRecordSize, 8);
             if (bBigEndian)
                 SwapWord(8, pabyRec + nRecordSize);
             nRecordSize += 8;
         }
     }
 
     /* -------------------------------------------------------------------- */
     /*      Not much to do for null geometries.                             */
     /* -------------------------------------------------------------------- */
     else if (psObject->nSHPType == SHPT_NULL)
     {
         nRecordSize = 12;
     }
     else
     {
         /* unknown type */
         assert(false);
     }
 
     /* -------------------------------------------------------------------- */
     /*      Establish where we are going to put this record. If we are      */
     /*      rewriting the last record of the file, then we can update it in */
     /*      place. Otherwise if rewriting an existing record, and it will   */
     /*      fit, then put it  back where the original came from.  Otherwise */
     /*      write at the end.                                               */
     /* -------------------------------------------------------------------- */
     SAOffset nRecordOffset;
     bool bAppendToLastRecord = false;
     bool bAppendToFile = false;
     if (nShapeId != -1 &&
         psSHP->panRecOffset[nShapeId] + psSHP->panRecSize[nShapeId] + 8 ==
             psSHP->nFileSize)
     {
         nRecordOffset = psSHP->panRecOffset[nShapeId];
         bAppendToLastRecord = true;
     }
     else if (nShapeId == -1 || psSHP->panRecSize[nShapeId] < nRecordSize - 8)
     {
         if (psSHP->nFileSize > UINT_MAX - nRecordSize)
         {
             char str[255];
             snprintf(str, sizeof(str),
                      "Failed to write shape object. "
                      "The maximum file size of %u has been reached. "
                      "The current record of size %u cannot be added.",
                      psSHP->nFileSize, nRecordSize);
             str[sizeof(str) - 1] = '\0';
             psSHP->sHooks.Error(str);
             free(pabyRec);
             return -1;
         }
 
         bAppendToFile = true;
         nRecordOffset = psSHP->nFileSize;
     }
     else
     {
         nRecordOffset = psSHP->panRecOffset[nShapeId];
     }
 
     /* -------------------------------------------------------------------- */
     /*      Set the shape type, record number, and record size.             */
     /* -------------------------------------------------------------------- */
-    int32_t i32 =
+    uint32_t i32 =
         (nShapeId < 0) ? psSHP->nRecords + 1 : nShapeId + 1; /* record # */
     if (!bBigEndian)
         SwapWord(4, &i32);
     ByteCopy(&i32, pabyRec, 4);
 
     i32 = (nRecordSize - 8) / 2; /* record size */
     if (!bBigEndian)
         SwapWord(4, &i32);
     ByteCopy(&i32, pabyRec + 4, 4);
 
     i32 = psObject->nSHPType; /* shape type */
     if (bBigEndian)
         SwapWord(4, &i32);
     ByteCopy(&i32, pabyRec + 8, 4);
 
     /* -------------------------------------------------------------------- */
     /*      Write out record.                                               */
     /* -------------------------------------------------------------------- */
 
     /* -------------------------------------------------------------------- */
     /*      Guard FSeek with check for whether we're already at position;   */
     /*      no-op FSeeks defeat network filesystems' write buffering.       */
     /* -------------------------------------------------------------------- */
     if (psSHP->sHooks.FTell(psSHP->fpSHP) != nRecordOffset)
     {
         if (psSHP->sHooks.FSeek(psSHP->fpSHP, nRecordOffset, 0) != 0)
         {
             char szErrorMsg[200];
 
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Error in psSHP->sHooks.FSeek() while writing object to "
                      ".shp file: %s",
                      strerror(errno));
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
 
             free(pabyRec);
             return -1;
         }
     }
     if (psSHP->sHooks.FWrite(pabyRec, nRecordSize, 1, psSHP->fpSHP) < 1)
     {
         char szErrorMsg[200];
 
         snprintf(szErrorMsg, sizeof(szErrorMsg),
                  "Error in psSHP->sHooks.FWrite() while writing object of %u "
                  "bytes to .shp file: %s",
                  nRecordSize, strerror(errno));
         szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
         psSHP->sHooks.Error(szErrorMsg);
 
         free(pabyRec);
         return -1;
     }
 
     free(pabyRec);
 
     if (bAppendToLastRecord)
     {
         psSHP->nFileSize = psSHP->panRecOffset[nShapeId] + nRecordSize;
     }
     else if (bAppendToFile)
     {
         if (nShapeId == -1)
             nShapeId = psSHP->nRecords++;
 
         psSHP->panRecOffset[nShapeId] = psSHP->nFileSize;
         psSHP->nFileSize += nRecordSize;
     }
     psSHP->panRecSize[nShapeId] = nRecordSize - 8;
 
     /* -------------------------------------------------------------------- */
     /*      Expand file wide bounds based on this shape.                    */
     /* -------------------------------------------------------------------- */
     if (bFirstFeature)
     {
         if (psObject->nSHPType == SHPT_NULL || psObject->nVertices == 0)
         {
             psSHP->adBoundsMin[0] = psSHP->adBoundsMax[0] = 0.0;
             psSHP->adBoundsMin[1] = psSHP->adBoundsMax[1] = 0.0;
             psSHP->adBoundsMin[2] = psSHP->adBoundsMax[2] = 0.0;
             psSHP->adBoundsMin[3] = psSHP->adBoundsMax[3] = 0.0;
         }
         else
         {
             psSHP->adBoundsMin[0] = psSHP->adBoundsMax[0] = psObject->padfX[0];
             psSHP->adBoundsMin[1] = psSHP->adBoundsMax[1] = psObject->padfY[0];
             psSHP->adBoundsMin[2] = psSHP->adBoundsMax[2] =
                 psObject->padfZ ? psObject->padfZ[0] : 0.0;
             psSHP->adBoundsMin[3] = psSHP->adBoundsMax[3] =
                 psObject->padfM ? psObject->padfM[0] : 0.0;
         }
     }
 
     for (int i = 0; i < psObject->nVertices; i++)
     {
         psSHP->adBoundsMin[0] = MIN(psSHP->adBoundsMin[0], psObject->padfX[i]);
         psSHP->adBoundsMin[1] = MIN(psSHP->adBoundsMin[1], psObject->padfY[i]);
         psSHP->adBoundsMax[0] = MAX(psSHP->adBoundsMax[0], psObject->padfX[i]);
         psSHP->adBoundsMax[1] = MAX(psSHP->adBoundsMax[1], psObject->padfY[i]);
         if (psObject->padfZ)
         {
             psSHP->adBoundsMin[2] =
                 MIN(psSHP->adBoundsMin[2], psObject->padfZ[i]);
             psSHP->adBoundsMax[2] =
                 MAX(psSHP->adBoundsMax[2], psObject->padfZ[i]);
         }
         if (psObject->padfM)
         {
             psSHP->adBoundsMin[3] =
                 MIN(psSHP->adBoundsMin[3], psObject->padfM[i]);
             psSHP->adBoundsMax[3] =
                 MAX(psSHP->adBoundsMax[3], psObject->padfM[i]);
         }
     }
 
     return (nShapeId);
 }
 
 /************************************************************************/
 /*                         SHPAllocBuffer()                             */
 /************************************************************************/
@@ -1922,785 +1922,785 @@ static unsigned char *SHPReallocObjectBufIfNecessary(SHPHandle psSHP,
 SHPObject SHPAPI_CALL1(*) SHPReadObject(SHPHandle psSHP, int hEntity)
 {
     /* -------------------------------------------------------------------- */
     /*      Validate the record/entity number.                              */
     /* -------------------------------------------------------------------- */
     if (hEntity < 0 || hEntity >= psSHP->nRecords)
         return SHPLIB_NULLPTR;
 
     /* -------------------------------------------------------------------- */
     /*      Read offset/length from SHX loading if necessary.               */
     /* -------------------------------------------------------------------- */
     if (psSHP->panRecOffset[hEntity] == 0 && psSHP->fpSHX != SHPLIB_NULLPTR)
     {
         unsigned int nOffset;
         unsigned int nLength;
 
         if (psSHP->sHooks.FSeek(psSHP->fpSHX, 100 + 8 * hEntity, 0) != 0 ||
             psSHP->sHooks.FRead(&nOffset, 1, 4, psSHP->fpSHX) != 4 ||
             psSHP->sHooks.FRead(&nLength, 1, 4, psSHP->fpSHX) != 4)
         {
             char str[128];
             snprintf(str, sizeof(str),
                      "Error in fseek()/fread() reading object from .shx file "
                      "at offset %d",
                      100 + 8 * hEntity);
             str[sizeof(str) - 1] = '\0';
 
             psSHP->sHooks.Error(str);
             return SHPLIB_NULLPTR;
         }
         if (!bBigEndian)
             SwapWord(4, &nOffset);
         if (!bBigEndian)
             SwapWord(4, &nLength);
 
         if (nOffset > STATIC_CAST(unsigned int, INT_MAX))
         {
             char str[128];
             snprintf(str, sizeof(str), "Invalid offset for entity %d", hEntity);
             str[sizeof(str) - 1] = '\0';
 
             psSHP->sHooks.Error(str);
             return SHPLIB_NULLPTR;
         }
         if (nLength > STATIC_CAST(unsigned int, INT_MAX / 2 - 4))
         {
             char str[128];
             snprintf(str, sizeof(str), "Invalid length for entity %d", hEntity);
             str[sizeof(str) - 1] = '\0';
 
             psSHP->sHooks.Error(str);
             return SHPLIB_NULLPTR;
         }
 
         psSHP->panRecOffset[hEntity] = nOffset * 2;
         psSHP->panRecSize[hEntity] = nLength * 2;
     }
 
     /* -------------------------------------------------------------------- */
     /*      Ensure our record buffer is large enough.                       */
     /* -------------------------------------------------------------------- */
     const int nEntitySize = psSHP->panRecSize[hEntity] + 8;
     if (nEntitySize > psSHP->nBufSize)
     {
         int nNewBufSize = nEntitySize;
         if (nNewBufSize < INT_MAX - nNewBufSize / 3)
             nNewBufSize += nNewBufSize / 3;
         else
             nNewBufSize = INT_MAX;
 
         /* Before allocating too much memory, check that the file is big enough */
         /* and do not trust the file size in the header the first time we */
         /* need to allocate more than 10 MB */
         if (nNewBufSize >= 10 * 1024 * 1024)
         {
             if (psSHP->nBufSize < 10 * 1024 * 1024)
             {
                 SAOffset nFileSize;
                 psSHP->sHooks.FSeek(psSHP->fpSHP, 0, 2);
                 nFileSize = psSHP->sHooks.FTell(psSHP->fpSHP);
                 if (nFileSize >= UINT_MAX)
                     psSHP->nFileSize = UINT_MAX;
                 else
                     psSHP->nFileSize = STATIC_CAST(unsigned int, nFileSize);
             }
 
             if (psSHP->panRecOffset[hEntity] >= psSHP->nFileSize ||
                 /* We should normally use nEntitySize instead of*/
                 /* psSHP->panRecSize[hEntity] in the below test, but because of */
                 /* the case of non conformant .shx files detailed a bit below, */
                 /* let be more tolerant */
                 psSHP->panRecSize[hEntity] >
                     psSHP->nFileSize - psSHP->panRecOffset[hEntity])
             {
                 char str[128];
                 snprintf(str, sizeof(str),
                          "Error in fread() reading object of size %d at offset "
                          "%u from .shp file",
                          nEntitySize, psSHP->panRecOffset[hEntity]);
                 str[sizeof(str) - 1] = '\0';
 
                 psSHP->sHooks.Error(str);
                 return SHPLIB_NULLPTR;
             }
         }
 
         unsigned char *pabyRecNew =
             STATIC_CAST(unsigned char *, realloc(psSHP->pabyRec, nNewBufSize));
         if (pabyRecNew == SHPLIB_NULLPTR)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Not enough memory to allocate requested memory "
                      "(nNewBufSize=%d). "
                      "Probably broken SHP file",
                      nNewBufSize);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             return SHPLIB_NULLPTR;
         }
 
         /* Only set new buffer size after successful alloc */
         psSHP->pabyRec = pabyRecNew;
         psSHP->nBufSize = nNewBufSize;
     }
 
     /* In case we were not able to reallocate the buffer on a previous step */
     if (psSHP->pabyRec == SHPLIB_NULLPTR)
     {
         return SHPLIB_NULLPTR;
     }
 
     /* -------------------------------------------------------------------- */
     /*      Read the record.                                                */
     /* -------------------------------------------------------------------- */
     if (psSHP->sHooks.FSeek(psSHP->fpSHP, psSHP->panRecOffset[hEntity], 0) != 0)
     {
         /*
          * TODO - mloskot: Consider detailed diagnostics of shape file,
          * for example to detect if file is truncated.
          */
         char str[128];
         snprintf(str, sizeof(str),
                  "Error in fseek() reading object from .shp file at offset %u",
                  psSHP->panRecOffset[hEntity]);
         str[sizeof(str) - 1] = '\0';
 
         psSHP->sHooks.Error(str);
         return SHPLIB_NULLPTR;
     }
 
     const int nBytesRead = STATIC_CAST(
         int, psSHP->sHooks.FRead(psSHP->pabyRec, 1, nEntitySize, psSHP->fpSHP));
 
     /* Special case for a shapefile whose .shx content length field is not equal */
     /* to the content length field of the .shp, which is a violation of "The */
     /* content length stored in the index record is the same as the value stored in the main */
     /* file record header." (http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf, page 24) */
     /* Actually in that case the .shx content length is equal to the .shp content length + */
     /* 4 (16 bit words), representing the 8 bytes of the record header... */
     if (nBytesRead >= 8 && nBytesRead == nEntitySize - 8)
     {
         /* Do a sanity check */
         int nSHPContentLength;
         memcpy(&nSHPContentLength, psSHP->pabyRec + 4, 4);
         if (!bBigEndian)
             SwapWord(4, &(nSHPContentLength));
         if (nSHPContentLength < 0 || nSHPContentLength > INT_MAX / 2 - 4 ||
             2 * nSHPContentLength + 8 != nBytesRead)
         {
             char str[128];
             snprintf(str, sizeof(str),
                      "Sanity check failed when trying to recover from "
                      "inconsistent .shx/.shp with shape %d",
                      hEntity);
             str[sizeof(str) - 1] = '\0';
 
             psSHP->sHooks.Error(str);
             return SHPLIB_NULLPTR;
         }
     }
     else if (nBytesRead != nEntitySize)
     {
         /*
          * TODO - mloskot: Consider detailed diagnostics of shape file,
          * for example to detect if file is truncated.
          */
         char str[128];
         snprintf(str, sizeof(str),
                  "Error in fread() reading object of size %d at offset %u from "
                  ".shp file",
                  nEntitySize, psSHP->panRecOffset[hEntity]);
         str[sizeof(str) - 1] = '\0';
 
         psSHP->sHooks.Error(str);
         return SHPLIB_NULLPTR;
     }
 
     if (8 + 4 > nEntitySize)
     {
         char szErrorMsg[160];
         snprintf(szErrorMsg, sizeof(szErrorMsg),
                  "Corrupted .shp file : shape %d : nEntitySize = %d", hEntity,
                  nEntitySize);
         szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
         psSHP->sHooks.Error(szErrorMsg);
         return SHPLIB_NULLPTR;
     }
     int nSHPType;
     memcpy(&nSHPType, psSHP->pabyRec + 8, 4);
 
     if (bBigEndian)
         SwapWord(4, &(nSHPType));
 
     /* -------------------------------------------------------------------- */
     /*      Allocate and minimally initialize the object.                   */
     /* -------------------------------------------------------------------- */
     SHPObject *psShape;
     if (psSHP->bFastModeReadObject)
     {
         if (psSHP->psCachedObject->bFastModeReadObject)
         {
             psSHP->sHooks.Error("Invalid read pattern in fast read mode. "
                                 "SHPDestroyObject() should be called.");
             return SHPLIB_NULLPTR;
         }
 
         psShape = psSHP->psCachedObject;
         memset(psShape, 0, sizeof(SHPObject));
     }
     else
     {
         psShape = STATIC_CAST(SHPObject *, calloc(1, sizeof(SHPObject)));
     }
     psShape->nShapeId = hEntity;
     psShape->nSHPType = nSHPType;
     psShape->bMeasureIsUsed = FALSE;
     psShape->bFastModeReadObject = psSHP->bFastModeReadObject;
 
     /* ==================================================================== */
     /*  Extract vertices for a Polygon or Arc.                              */
     /* ==================================================================== */
     if (psShape->nSHPType == SHPT_POLYGON || psShape->nSHPType == SHPT_ARC ||
         psShape->nSHPType == SHPT_POLYGONZ ||
         psShape->nSHPType == SHPT_POLYGONM || psShape->nSHPType == SHPT_ARCZ ||
         psShape->nSHPType == SHPT_ARCM || psShape->nSHPType == SHPT_MULTIPATCH)
     {
         if (40 + 8 + 4 > nEntitySize)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Corrupted .shp file : shape %d : nEntitySize = %d",
                      hEntity, nEntitySize);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             SHPDestroyObject(psShape);
             return SHPLIB_NULLPTR;
         }
         /* -------------------------------------------------------------------- */
         /*      Get the X/Y bounds.                                             */
         /* -------------------------------------------------------------------- */
         memcpy(&(psShape->dfXMin), psSHP->pabyRec + 8 + 4, 8);
         memcpy(&(psShape->dfYMin), psSHP->pabyRec + 8 + 12, 8);
         memcpy(&(psShape->dfXMax), psSHP->pabyRec + 8 + 20, 8);
         memcpy(&(psShape->dfYMax), psSHP->pabyRec + 8 + 28, 8);
 
         if (bBigEndian)
             SwapWord(8, &(psShape->dfXMin));
         if (bBigEndian)
             SwapWord(8, &(psShape->dfYMin));
         if (bBigEndian)
             SwapWord(8, &(psShape->dfXMax));
         if (bBigEndian)
             SwapWord(8, &(psShape->dfYMax));
 
         /* -------------------------------------------------------------------- */
         /*      Extract part/point count, and build vertex and part arrays      */
         /*      to proper size.                                                 */
         /* -------------------------------------------------------------------- */
-        int32_t nPoints;
+        uint32_t nPoints;
         memcpy(&nPoints, psSHP->pabyRec + 40 + 8, 4);
-        int32_t nParts;
+        uint32_t nParts;
         memcpy(&nParts, psSHP->pabyRec + 36 + 8, 4);
 
         if (bBigEndian)
             SwapWord(4, &nPoints);
         if (bBigEndian)
             SwapWord(4, &nParts);
 
         /* nPoints and nParts are unsigned */
         if (/* nPoints < 0 || nParts < 0 || */
             nPoints > 50 * 1000 * 1000 || nParts > 10 * 1000 * 1000)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Corrupted .shp file : shape %d, nPoints=%u, nParts=%u.",
                      hEntity, nPoints, nParts);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             SHPDestroyObject(psShape);
             return SHPLIB_NULLPTR;
         }
 
         /* With the previous checks on nPoints and nParts, */
         /* we should not overflow here and after */
         /* since 50 M * (16 + 8 + 8) = 1 600 MB */
         int nRequiredSize = 44 + 8 + 4 * nParts + 16 * nPoints;
         if (psShape->nSHPType == SHPT_POLYGONZ ||
             psShape->nSHPType == SHPT_ARCZ ||
             psShape->nSHPType == SHPT_MULTIPATCH)
         {
             nRequiredSize += 16 + 8 * nPoints;
         }
         if (psShape->nSHPType == SHPT_MULTIPATCH)
         {
             nRequiredSize += 4 * nParts;
         }
         if (nRequiredSize > nEntitySize)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Corrupted .shp file : shape %d, nPoints=%u, nParts=%u, "
                      "nEntitySize=%d.",
                      hEntity, nPoints, nParts, nEntitySize);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             SHPDestroyObject(psShape);
             return SHPLIB_NULLPTR;
         }
 
         unsigned char *pBuffer = SHPLIB_NULLPTR;
         unsigned char **ppBuffer = SHPLIB_NULLPTR;
 
         if (psShape->bFastModeReadObject)
         {
             const int nObjectBufSize =
                 4 * sizeof(double) * nPoints + 2 * sizeof(int) * nParts;
             pBuffer = SHPReallocObjectBufIfNecessary(psSHP, nObjectBufSize);
             ppBuffer = &pBuffer;
         }
 
         psShape->nVertices = nPoints;
         psShape->padfX = STATIC_CAST(
             double *, SHPAllocBuffer(ppBuffer, sizeof(double) * nPoints));
         psShape->padfY = STATIC_CAST(
             double *, SHPAllocBuffer(ppBuffer, sizeof(double) * nPoints));
         psShape->padfZ = STATIC_CAST(
             double *, SHPAllocBuffer(ppBuffer, sizeof(double) * nPoints));
         psShape->padfM = STATIC_CAST(
             double *, SHPAllocBuffer(ppBuffer, sizeof(double) * nPoints));
 
         psShape->nParts = nParts;
         psShape->panPartStart =
             STATIC_CAST(int *, SHPAllocBuffer(ppBuffer, nParts * sizeof(int)));
         psShape->panPartType =
             STATIC_CAST(int *, SHPAllocBuffer(ppBuffer, nParts * sizeof(int)));
 
         if (psShape->padfX == SHPLIB_NULLPTR ||
             psShape->padfY == SHPLIB_NULLPTR ||
             psShape->padfZ == SHPLIB_NULLPTR ||
             psShape->padfM == SHPLIB_NULLPTR ||
             psShape->panPartStart == SHPLIB_NULLPTR ||
             psShape->panPartType == SHPLIB_NULLPTR)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Not enough memory to allocate requested memory "
                      "(nPoints=%u, nParts=%u) for shape %d. "
                      "Probably broken SHP file",
                      nPoints, nParts, hEntity);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             SHPDestroyObject(psShape);
             return SHPLIB_NULLPTR;
         }
 
-        for (int i = 0; STATIC_CAST(int32_t, i) < nParts; i++)
+        for (int i = 0; STATIC_CAST(uint32_t, i) < nParts; i++)
             psShape->panPartType[i] = SHPP_RING;
 
         /* -------------------------------------------------------------------- */
         /*      Copy out the part array from the record.                        */
         /* -------------------------------------------------------------------- */
         memcpy(psShape->panPartStart, psSHP->pabyRec + 44 + 8, 4 * nParts);
-        for (int i = 0; STATIC_CAST(int32_t, i) < nParts; i++)
+        for (int i = 0; STATIC_CAST(uint32_t, i) < nParts; i++)
         {
             if (bBigEndian)
                 SwapWord(4, psShape->panPartStart + i);
 
             /* We check that the offset is inside the vertex array */
             if (psShape->panPartStart[i] < 0 ||
                 (psShape->panPartStart[i] >= psShape->nVertices &&
                  psShape->nVertices > 0) ||
                 (psShape->panPartStart[i] > 0 && psShape->nVertices == 0))
             {
                 char szErrorMsg[160];
                 snprintf(szErrorMsg, sizeof(szErrorMsg),
                          "Corrupted .shp file : shape %d : panPartStart[%d] = "
                          "%d, nVertices = %d",
                          hEntity, i, psShape->panPartStart[i],
                          psShape->nVertices);
                 szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
                 psSHP->sHooks.Error(szErrorMsg);
                 SHPDestroyObject(psShape);
                 return SHPLIB_NULLPTR;
             }
             if (i > 0 &&
                 psShape->panPartStart[i] <= psShape->panPartStart[i - 1])
             {
                 char szErrorMsg[160];
                 snprintf(szErrorMsg, sizeof(szErrorMsg),
                          "Corrupted .shp file : shape %d : panPartStart[%d] = "
                          "%d, panPartStart[%d] = %d",
                          hEntity, i, psShape->panPartStart[i], i - 1,
                          psShape->panPartStart[i - 1]);
                 szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
                 psSHP->sHooks.Error(szErrorMsg);
                 SHPDestroyObject(psShape);
                 return SHPLIB_NULLPTR;
             }
         }
 
         int nOffset = 44 + 8 + 4 * nParts;
 
         /* -------------------------------------------------------------------- */
         /*      If this is a multipatch, we will also have parts types.         */
         /* -------------------------------------------------------------------- */
         if (psShape->nSHPType == SHPT_MULTIPATCH)
         {
             memcpy(psShape->panPartType, psSHP->pabyRec + nOffset, 4 * nParts);
-            for (int i = 0; STATIC_CAST(int32_t, i) < nParts; i++)
+            for (int i = 0; STATIC_CAST(uint32_t, i) < nParts; i++)
             {
                 if (bBigEndian)
                     SwapWord(4, psShape->panPartType + i);
             }
 
             nOffset += 4 * nParts;
         }
 
         /* -------------------------------------------------------------------- */
         /*      Copy out the vertices from the record.                          */
         /* -------------------------------------------------------------------- */
-        for (int i = 0; STATIC_CAST(int32_t, i) < nPoints; i++)
+        for (int i = 0; STATIC_CAST(uint32_t, i) < nPoints; i++)
         {
             memcpy(psShape->padfX + i, psSHP->pabyRec + nOffset + i * 16, 8);
 
             memcpy(psShape->padfY + i, psSHP->pabyRec + nOffset + i * 16 + 8,
                    8);
 
             if (bBigEndian)
                 SwapWord(8, psShape->padfX + i);
             if (bBigEndian)
                 SwapWord(8, psShape->padfY + i);
         }
 
         nOffset += 16 * nPoints;
 
         /* -------------------------------------------------------------------- */
         /*      If we have a Z coordinate, collect that now.                    */
         /* -------------------------------------------------------------------- */
         if (psShape->nSHPType == SHPT_POLYGONZ ||
             psShape->nSHPType == SHPT_ARCZ ||
             psShape->nSHPType == SHPT_MULTIPATCH)
         {
             memcpy(&(psShape->dfZMin), psSHP->pabyRec + nOffset, 8);
             memcpy(&(psShape->dfZMax), psSHP->pabyRec + nOffset + 8, 8);
 
             if (bBigEndian)
                 SwapWord(8, &(psShape->dfZMin));
             if (bBigEndian)
                 SwapWord(8, &(psShape->dfZMax));
 
-            for (int i = 0; STATIC_CAST(int32_t, i) < nPoints; i++)
+            for (int i = 0; STATIC_CAST(uint32_t, i) < nPoints; i++)
             {
                 memcpy(psShape->padfZ + i,
                        psSHP->pabyRec + nOffset + 16 + i * 8, 8);
                 if (bBigEndian)
                     SwapWord(8, psShape->padfZ + i);
             }
 
             nOffset += 16 + 8 * nPoints;
         }
         else if (psShape->bFastModeReadObject)
         {
             psShape->padfZ = SHPLIB_NULLPTR;
         }
 
         /* -------------------------------------------------------------------- */
         /*      If we have a M measure value, then read it now.  We assume      */
         /*      that the measure can be present for any shape if the size is    */
         /*      big enough, but really it will only occur for the Z shapes      */
         /*      (options), and the M shapes.                                    */
         /* -------------------------------------------------------------------- */
         if (nEntitySize >= STATIC_CAST(int, nOffset + 16 + 8 * nPoints))
         {
             memcpy(&(psShape->dfMMin), psSHP->pabyRec + nOffset, 8);
             memcpy(&(psShape->dfMMax), psSHP->pabyRec + nOffset + 8, 8);
 
             if (bBigEndian)
                 SwapWord(8, &(psShape->dfMMin));
             if (bBigEndian)
                 SwapWord(8, &(psShape->dfMMax));
 
-            for (int i = 0; STATIC_CAST(int32_t, i) < nPoints; i++)
+            for (int i = 0; STATIC_CAST(uint32_t, i) < nPoints; i++)
             {
                 memcpy(psShape->padfM + i,
                        psSHP->pabyRec + nOffset + 16 + i * 8, 8);
                 if (bBigEndian)
                     SwapWord(8, psShape->padfM + i);
             }
             psShape->bMeasureIsUsed = TRUE;
         }
         else if (psShape->bFastModeReadObject)
         {
             psShape->padfM = SHPLIB_NULLPTR;
         }
     }
 
     /* ==================================================================== */
     /*  Extract vertices for a MultiPoint.                                  */
     /* ==================================================================== */
     else if (psShape->nSHPType == SHPT_MULTIPOINT ||
              psShape->nSHPType == SHPT_MULTIPOINTM ||
              psShape->nSHPType == SHPT_MULTIPOINTZ)
     {
         if (44 + 4 > nEntitySize)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Corrupted .shp file : shape %d : nEntitySize = %d",
                      hEntity, nEntitySize);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             SHPDestroyObject(psShape);
             return SHPLIB_NULLPTR;
         }
-        int32_t nPoints;
+        uint32_t nPoints;
         memcpy(&nPoints, psSHP->pabyRec + 44, 4);
 
         if (bBigEndian)
             SwapWord(4, &nPoints);
 
         /* nPoints is unsigned */
         if (/* nPoints < 0 || */ nPoints > 50 * 1000 * 1000)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Corrupted .shp file : shape %d : nPoints = %u", hEntity,
                      nPoints);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             SHPDestroyObject(psShape);
             return SHPLIB_NULLPTR;
         }
 
         int nRequiredSize = 48 + nPoints * 16;
         if (psShape->nSHPType == SHPT_MULTIPOINTZ)
         {
             nRequiredSize += 16 + nPoints * 8;
         }
         if (nRequiredSize > nEntitySize)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Corrupted .shp file : shape %d : nPoints = %u, "
                      "nEntitySize = %d",
                      hEntity, nPoints, nEntitySize);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             SHPDestroyObject(psShape);
             return SHPLIB_NULLPTR;
         }
 
         unsigned char *pBuffer = SHPLIB_NULLPTR;
         unsigned char **ppBuffer = SHPLIB_NULLPTR;
 
         if (psShape->bFastModeReadObject)
         {
             const int nObjectBufSize = 4 * sizeof(double) * nPoints;
             pBuffer = SHPReallocObjectBufIfNecessary(psSHP, nObjectBufSize);
             ppBuffer = &pBuffer;
         }
 
         psShape->nVertices = nPoints;
 
         psShape->padfX = STATIC_CAST(
             double *, SHPAllocBuffer(ppBuffer, sizeof(double) * nPoints));
         psShape->padfY = STATIC_CAST(
             double *, SHPAllocBuffer(ppBuffer, sizeof(double) * nPoints));
         psShape->padfZ = STATIC_CAST(
             double *, SHPAllocBuffer(ppBuffer, sizeof(double) * nPoints));
         psShape->padfM = STATIC_CAST(
             double *, SHPAllocBuffer(ppBuffer, sizeof(double) * nPoints));
 
         if (psShape->padfX == SHPLIB_NULLPTR ||
             psShape->padfY == SHPLIB_NULLPTR ||
             psShape->padfZ == SHPLIB_NULLPTR ||
             psShape->padfM == SHPLIB_NULLPTR)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Not enough memory to allocate requested memory "
                      "(nPoints=%u) for shape %d. "
                      "Probably broken SHP file",
                      nPoints, hEntity);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             SHPDestroyObject(psShape);
             return SHPLIB_NULLPTR;
         }
 
-        for (int i = 0; STATIC_CAST(int32_t, i) < nPoints; i++)
+        for (int i = 0; STATIC_CAST(uint32_t, i) < nPoints; i++)
         {
             memcpy(psShape->padfX + i, psSHP->pabyRec + 48 + 16 * i, 8);
             memcpy(psShape->padfY + i, psSHP->pabyRec + 48 + 16 * i + 8, 8);
 
             if (bBigEndian)
                 SwapWord(8, psShape->padfX + i);
             if (bBigEndian)
                 SwapWord(8, psShape->padfY + i);
         }
 
         int nOffset = 48 + 16 * nPoints;
 
         /* -------------------------------------------------------------------- */
         /*      Get the X/Y bounds.                                             */
         /* -------------------------------------------------------------------- */
         memcpy(&(psShape->dfXMin), psSHP->pabyRec + 8 + 4, 8);
         memcpy(&(psShape->dfYMin), psSHP->pabyRec + 8 + 12, 8);
         memcpy(&(psShape->dfXMax), psSHP->pabyRec + 8 + 20, 8);
         memcpy(&(psShape->dfYMax), psSHP->pabyRec + 8 + 28, 8);
 
         if (bBigEndian)
             SwapWord(8, &(psShape->dfXMin));
         if (bBigEndian)
             SwapWord(8, &(psShape->dfYMin));
         if (bBigEndian)
             SwapWord(8, &(psShape->dfXMax));
         if (bBigEndian)
             SwapWord(8, &(psShape->dfYMax));
 
         /* -------------------------------------------------------------------- */
         /*      If we have a Z coordinate, collect that now.                    */
         /* -------------------------------------------------------------------- */
         if (psShape->nSHPType == SHPT_MULTIPOINTZ)
         {
             memcpy(&(psShape->dfZMin), psSHP->pabyRec + nOffset, 8);
             memcpy(&(psShape->dfZMax), psSHP->pabyRec + nOffset + 8, 8);
 
             if (bBigEndian)
                 SwapWord(8, &(psShape->dfZMin));
             if (bBigEndian)
                 SwapWord(8, &(psShape->dfZMax));
 
-            for (int i = 0; STATIC_CAST(int32_t, i) < nPoints; i++)
+            for (int i = 0; STATIC_CAST(uint32_t, i) < nPoints; i++)
             {
                 memcpy(psShape->padfZ + i,
                        psSHP->pabyRec + nOffset + 16 + i * 8, 8);
                 if (bBigEndian)
                     SwapWord(8, psShape->padfZ + i);
             }
 
             nOffset += 16 + 8 * nPoints;
         }
         else if (psShape->bFastModeReadObject)
             psShape->padfZ = SHPLIB_NULLPTR;
 
         /* -------------------------------------------------------------------- */
         /*      If we have a M measure value, then read it now.  We assume      */
         /*      that the measure can be present for any shape if the size is    */
         /*      big enough, but really it will only occur for the Z shapes      */
         /*      (options), and the M shapes.                                    */
         /* -------------------------------------------------------------------- */
         if (nEntitySize >= STATIC_CAST(int, nOffset + 16 + 8 * nPoints))
         {
             memcpy(&(psShape->dfMMin), psSHP->pabyRec + nOffset, 8);
             memcpy(&(psShape->dfMMax), psSHP->pabyRec + nOffset + 8, 8);
 
             if (bBigEndian)
                 SwapWord(8, &(psShape->dfMMin));
             if (bBigEndian)
                 SwapWord(8, &(psShape->dfMMax));
 
-            for (int i = 0; STATIC_CAST(int32_t, i) < nPoints; i++)
+            for (int i = 0; STATIC_CAST(uint32_t, i) < nPoints; i++)
             {
                 memcpy(psShape->padfM + i,
                        psSHP->pabyRec + nOffset + 16 + i * 8, 8);
                 if (bBigEndian)
                     SwapWord(8, psShape->padfM + i);
             }
             psShape->bMeasureIsUsed = TRUE;
         }
         else if (psShape->bFastModeReadObject)
             psShape->padfM = SHPLIB_NULLPTR;
     }
 
     /* ==================================================================== */
     /*      Extract vertices for a point.                                   */
     /* ==================================================================== */
     else if (psShape->nSHPType == SHPT_POINT ||
              psShape->nSHPType == SHPT_POINTM ||
              psShape->nSHPType == SHPT_POINTZ)
     {
         psShape->nVertices = 1;
         if (psShape->bFastModeReadObject)
         {
             psShape->padfX = &(psShape->dfXMin);
             psShape->padfY = &(psShape->dfYMin);
             psShape->padfZ = &(psShape->dfZMin);
             psShape->padfM = &(psShape->dfMMin);
             psShape->padfZ[0] = 0.0;
             psShape->padfM[0] = 0.0;
         }
         else
         {
             psShape->padfX = STATIC_CAST(double *, calloc(1, sizeof(double)));
             psShape->padfY = STATIC_CAST(double *, calloc(1, sizeof(double)));
             psShape->padfZ = STATIC_CAST(double *, calloc(1, sizeof(double)));
             psShape->padfM = STATIC_CAST(double *, calloc(1, sizeof(double)));
         }
 
         if (20 + 8 + ((psShape->nSHPType == SHPT_POINTZ) ? 8 : 0) > nEntitySize)
         {
             char szErrorMsg[160];
             snprintf(szErrorMsg, sizeof(szErrorMsg),
                      "Corrupted .shp file : shape %d : nEntitySize = %d",
                      hEntity, nEntitySize);
             szErrorMsg[sizeof(szErrorMsg) - 1] = '\0';
             psSHP->sHooks.Error(szErrorMsg);
             SHPDestroyObject(psShape);
             return SHPLIB_NULLPTR;
         }
         memcpy(psShape->padfX, psSHP->pabyRec + 12, 8);
         memcpy(psShape->padfY, psSHP->pabyRec + 20, 8);
 
         if (bBigEndian)
             SwapWord(8, psShape->padfX);
         if (bBigEndian)
             SwapWord(8, psShape->padfY);
 
         int nOffset = 20 + 8;
 
         /* -------------------------------------------------------------------- */
         /*      If we have a Z coordinate, collect that now.                    */
         /* -------------------------------------------------------------------- */
         if (psShape->nSHPType == SHPT_POINTZ)
         {
             memcpy(psShape->padfZ, psSHP->pabyRec + nOffset, 8);
 
             if (bBigEndian)
                 SwapWord(8, psShape->padfZ);
 
             nOffset += 8;
         }
 
         /* -------------------------------------------------------------------- */
         /*      If we have a M measure value, then read it now.  We assume      */
         /*      that the measure can be present for any shape if the size is    */
         /*      big enough, but really it will only occur for the Z shapes      */
         /*      (options), and the M shapes.                                    */
         /* -------------------------------------------------------------------- */
         if (nEntitySize >= nOffset + 8)
         {
             memcpy(psShape->padfM, psSHP->pabyRec + nOffset, 8);
 
             if (bBigEndian)
                 SwapWord(8, psShape->padfM);
             psShape->bMeasureIsUsed = TRUE;
         }
 
         /* -------------------------------------------------------------------- */
         /*      Since no extents are supplied in the record, we will apply      */
         /*      them from the single vertex.                                    */
         /* -------------------------------------------------------------------- */
         psShape->dfXMin = psShape->dfXMax = psShape->padfX[0];
         psShape->dfYMin = psShape->dfYMax = psShape->padfY[0];
         psShape->dfZMin = psShape->dfZMax = psShape->padfZ[0];
         psShape->dfMMin = psShape->dfMMax = psShape->padfM[0];
     }
 
     return (psShape);
 }
 
 /************************************************************************/
 /*                            SHPTypeName()                             */
 /************************************************************************/
