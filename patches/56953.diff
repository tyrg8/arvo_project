commit 02fd447dbbcc68d6e3cf819ccc0f8fb6c9bb07aa
Author: Michal Josef Špaček <michal.josef.spacek@gmail.com>
Date:   Thu Dec 14 20:12:11 2023 +0100

    Remove zero_5 from header

diff --git a/include/dwg.h b/include/dwg.h
index 2adcc31a..b20ae1ba 100644
--- a/include/dwg.h
+++ b/include/dwg.h
@@ -9355,35 +9355,34 @@ typedef struct _dwg_AcDs
 typedef struct _dwg_header
 {
   Dwg_Version_Type version;      /* calculated from the header magic */
   Dwg_Version_Type from_version; /* option. set by --as (convert from) */
-  BITCODE_RC zero_5[5];
   BITCODE_RC is_maint;
   BITCODE_RC zero_one_or_three;
   BITCODE_RS numentity_sections; /* < R13, always 3 */
   BITCODE_RS numheader_vars;    /* < R13 */
   BITCODE_RL thumbnail_address; /* THUMBNAIL or AdDb:Preview */
   BITCODE_RC dwg_version;
   BITCODE_RC maint_version;
   BITCODE_RL entities_start;    /* < R13 */
   BITCODE_RL entities_end;      /* < R13 */
   BITCODE_RL blocks_start;      /* < R13 */
   BITCODE_RL blocks_size;       /* < R13 */
   BITCODE_RL extras_start;      /* < R13 */
   BITCODE_RL extras_size;       /* < R13 */
   BITCODE_RS codepage;
   BITCODE_RC unknown_0;           /* R2004+ */
   BITCODE_RC app_dwg_version;     /* R2004+ */
   BITCODE_RC app_maint_version;   /* R2004+ */
   BITCODE_RL security_type;       /* R2004+ */
   BITCODE_RL rl_1c_address;       /* R2004+ mostly 0 */
   BITCODE_RL summaryinfo_address; /* R2004+ */
   BITCODE_RL vbaproj_address;     /* R2004+ */
   BITCODE_RL r2004_header_address; /* R2004+ */
   BITCODE_RL sections;            // as in the header, 5 or 6 usually
   BITCODE_RL num_sections;        // as allocated, many more
   Dwg_Section *section;
   Dwg_Section_InfoHdr section_infohdr; /* R2004+ */
   Dwg_Section_Info *section_info;
 } Dwg_Header;
 
 #pragma pack(1)
diff --git a/src/decode.c b/src/decode.c
index fe9701fe..b3e3b022 100644
--- a/src/decode.c
+++ b/src/decode.c
@@ -125,131 +125,126 @@ static int objfreespace_private (Bit_Chain *restrict dat,
 EXPORT int
 dwg_decode (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
-  char magic[8];
+  char magic[11];
 
   dwg->num_object_refs = 0;
   // dwg->num_layers = 0; // see now dwg->layer_control->num_entries
   dwg->num_entities = 0;
   dwg->num_objects = 0;
   dwg->num_classes = 0;
   dwg->thumbnail.size = 0;
   dwg->thumbnail.chain = NULL;
   dwg->header.num_sections = 0;
   dwg->header.section_infohdr.num_desc = 0;
   dwg->dwg_class = NULL;
   dwg->object_ref = NULL;
   dwg->object = NULL;
   dwg->object_map = hash_new (dat->size / 1000);
   if (!dwg->object_map)
     {
       // whatever, we are obviously on a tiny system
       dwg->object_map = hash_new (1024);
       if (!dwg->object_map)
         {
           LOG_ERROR ("Out of memory");
           return DWG_ERR_OUTOFMEM;
         }
     }
   dwg->dirty_refs = 1;
 
   // memset (&dwg->header, 0, sizeof (dwg->header)); // no, needed for magic
   memset (&dwg->header_vars, 0, sizeof (dwg->header_vars));
   memset (&dwg->summaryinfo, 0, sizeof (dwg->summaryinfo));
   memset (&dwg->r2004_header, 0, sizeof (dwg->r2004_header));
   memset (&dwg->auxheader, 0, sizeof (dwg->auxheader));
   memset (&dwg->secondheader, 0, sizeof (dwg->secondheader));
   memset (&dwg->objfreespace, 0, sizeof (dwg->objfreespace));
 
   if (dwg->opts)
     {
       loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;
       dat->opts = dwg->opts;
     }
 
 #ifdef USE_TRACING
   /* Before starting, set the logging level, but only do so once.  */
   if (!env_var_checked_p)
     {
       char *probe = getenv ("LIBREDWG_TRACE");
       if (probe)
         loglevel = atoi (probe);
       env_var_checked_p = true;
     }
 #endif /* USE_TRACING */
 
   /* Version */
   dat->byte = 0;
   dat->bit = 0;
   if (!dat->chain
       || dat->size < 58) // saw the smallest r2.10 DWG with 1095 bytes
     {
       LOG_ERROR ("dwg too small: %" PRIuSIZE " bytes", dat->size);
       return DWG_ERR_INVALIDDWG;
     }
-  strncpy (magic, (const char *)dat->chain, 6);
-  if (memcmp (dat->chain, "AC103-4", 7) == 0)
-    {
-      magic[6] = '4';
-      magic[7] = '\0';
-    }
-  else
-    magic[6] = '\0';
+  strncpy (magic, (const char *)dat->chain, 11);
+  magic[10] = '\0';
 
   dwg->header.from_version = dwg_version_hdr_type (magic);
   if (!dwg->header.from_version)
     {
       if (strncmp (magic, "AC", 2)) // let's ignore MC0.0 for now
         {
           LOG_ERROR ("Invalid DWG, magic: %s", magic);
         }
       else
         {
           LOG_ERROR ("Invalid or unimplemented DWG version code %s", magic);
         }
       return DWG_ERR_INVALIDDWG;
     }
   dat->from_version = dwg->header.from_version;
   if (!dwg->header.version) // target version not set
     {
       dat->version = dwg->header.version = dat->from_version;
     }
   LOG_INFO ("This file's version code is: %s (%s)\n", magic,
             dwg_version_type (dat->from_version))
 
+  dat->byte = 0xb; // After magic string.
   PRE (R_13b1)
   {
     Dwg_Object *ctrl;
     int error = decode_preR13 (dat, dwg);
     if (error <= DWG_ERR_CRITICAL)
       {
         ctrl = &dwg->object[0];
         dwg->block_control = *ctrl->tio.object->tio.BLOCK_CONTROL;
       }
     return error;
   }
   VERSIONS (R_13b1, R_2000)
   {
     return decode_R13_R2000 (dat, dwg);
   }
   VERSION (R_2004)
   {
     return decode_R2004 (dat, dwg);
   }
   VERSION (R_2007)
   {
     return decode_R2007 (dat, dwg);
   }
   SINCE (R_2010)
   {
     read_r2007_init (dwg); // sets loglevel only for now
     return decode_R2004 (dat, dwg);
   }
 
   // This line should not be reached
   LOG_ERROR ("LibreDWG does not support this DWG version: %s (%s).", magic,
              dwg_version_type (dat->from_version))
   return DWG_ERR_INVALIDDWG;
 }
 
 /* ODA 3.2.6 SECTION-LOCATOR RECORDS: p.21
    This is an ODA calculation mistake, it's not needed at all.
@@ -303,262 +298,262 @@ static int
 decode_R13_R2000 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
   Dwg_Object *obj = NULL;
   unsigned int section_size = 0;
   BITCODE_RS crc, crc2;
   size_t size, startpos, endpos, lastmap, pvz = 0;
   size_t object_begin, object_end;
   BITCODE_BL j;
   int error = 0;
   int sentinel_size = 16;
   const char *section_names[]
       = { "AcDb:Header",       "AcDb:Classes",  "AcDb:Handles",
           "AcDb:ObjFreeSpace", "AcDb:Template", "AcDb:AuxHeader" };
 
   {
     int i;
     Dwg_Header *_obj = &dwg->header;
     Bit_Chain *hdl_dat = dat;
     BITCODE_BL vcount;
-    dat->byte = 0x06;
+
     // clang-format off
     #include "header.spec"
     // clang-format on
   }
 
   /* Section Locator Records 0x15 */
   if (dat->byte != 0x15)
     {
       LOG_ERROR ("Wrong HEADER Section Locator Records at %" PRIuSIZE,
                  dat->byte)
       return DWG_ERR_INVALIDDWG;
     }
   assert (dat->byte == 0x15);
   dwg->header.sections = bit_read_RL (dat);
   LOG_TRACE ("\nnum_sections: " FORMAT_RL " [RL]\n", dwg->header.sections)
   if ((error = dwg_sections_init (dwg)))
     return error;
   /* section 0: header vars
    *         1: class section
    *         2: object map
    *         3: optional: ObjFreeSpace
    *         -: 2ndHeader and its sentinels
    *         4: optional: Template (MEASUREMENT)
    *         5: optional: AuxHeader (no sentinels, since R13c3)
    */
   for (j = 0; j < dwg->header.num_sections; j++)
     {
       dwg->header.section[j].number = (BITCODE_RLd)bit_read_RC (dat);
       dwg->header.section[j].address = (BITCODE_RLL)bit_read_RL (dat);
       dwg->header.section[j].size = bit_read_RL (dat);
       if (j < 6)
         strcpy (dwg->header.section[j].name, section_names[j]);
       LOG_TRACE ("section[%u].number:  %8d [RC] %s\n", j,
                  (int)dwg->header.section[j].number,
                  dwg->header.section[j].name)
       LOG_TRACE ("section[%u].address: %8u [RL]\n", j,
                  (unsigned)dwg->header.section[j].address)
       LOG_TRACE ("section[%u].size:    %8u [RL]\n", j,
                  (unsigned)dwg->header.section[j].size);
       if (dwg->header.section[j].address + dwg->header.section[j].size
           > dat->size)
         {
           LOG_ERROR ("section[%u] address or size overflow: %" PRIu64
                      " + " FORMAT_RL " > %" PRIuSIZE,
                      j, dwg->header.section[j].address,
                      dwg->header.section[j].size, dat->size);
           return DWG_ERR_INVALIDDWG;
         }
     }
 
   // Check CRC up to now (note: ODA has a bug here)
   crc2 = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now
   crc = bit_read_RS (dat);
   LOG_TRACE ("crc: %04X [RSx] from 0-%" PRIuSIZE "\n", (unsigned)crc,
              dat->byte - 2);
   if (crc != crc2)
     {
       LOG_ERROR ("Header CRC mismatch %04X <=> %04X", (unsigned)crc,
                  (unsigned)crc2);
       error |= DWG_ERR_WRONGCRC;
     }
 
   if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_HEADER_END)))
     LOG_TRACE ("         HEADER (end):    %4u\n", (unsigned)dat->byte)
 
   /*-------------------------------------------------------------------------
    * Section 5 AuxHeader
    * R13c3+, mostly redundant file header information. no sentinels
    */
   if (dwg->header.sections == 6 && dwg->header.version >= R_13c3)
     {
       Dwg_AuxHeader *_obj = &dwg->auxheader;
       Bit_Chain *hdl_dat = dat;
       size_t end_address = dwg->header.section[SECTION_AUXHEADER_R2000].address
                            + dwg->header.section[SECTION_AUXHEADER_R2000].size;
 
       obj = NULL;
       dat->byte = dwg->header.section[SECTION_AUXHEADER_R2000].address;
       LOG_TRACE ("\n"
                  "=======> AuxHeader:       %4zu\n",
                  dat->byte)
       LOG_TRACE ("         AuxHeader (end): %4zu\n", end_address)
       if (dat->size < end_address)
         {
           LOG_ERROR ("Invalid AuxHeader size: buffer overflow")
           error |= DWG_ERR_SECTIONNOTFOUND;
         }
       else
         {
           size_t old_size = dat->size;
           BITCODE_BL vcount;
           dat->size = end_address;
           // clang-format off
           #include "auxheader.spec"
           // clang-format on
           dat->size = old_size;
         }
     }
 
   /*-------------------------------------------------------------------------
    * Thumbnail Image (pre-r13c3 before, since r13c3 at the end)
    */
   if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_BEGIN)))
     {
       size_t start_address;
 
       dat->bit = 0;
       start_address = dat->byte;
       LOG_TRACE ("\n=======> Thumbnail:       %4zu\n", start_address - 16);
       if (dwg->header.thumbnail_address
           && dwg->header.thumbnail_address != (BITCODE_RL)(dat->byte - 16))
         LOG_WARN ("Illegal header.thumbnail_address: %i != %" PRIuSIZE,
                   dwg->header.thumbnail_address, dat->byte - 16)
       dwg->header.thumbnail_address = (dat->byte - 16) & 0xFFFFFFFF;
       if (bit_search_sentinel (dat, dwg_sentinel (DWG_SENTINEL_THUMBNAIL_END)))
         {
           BITCODE_RL bmpsize;
           LOG_TRACE ("         Thumbnail (end): %4zu\n", dat->byte)
           if ((dat->byte - 16) < start_address)
             {
               LOG_ERROR ("Illegal header.thumbnail_size: %" PRIuSIZE
                          " < %" PRIuSIZE,
                          dat->byte - 16, start_address);
             }
           else if ((dat->byte - 16) - start_address < 10)
             {
               LOG_TRACE ("No header.thumbnail: %" PRIuSIZE " < 10",
                          dat->byte - 16 - start_address);
             }
           else
             {
               BITCODE_RC type;
               assert ((dat->byte - 16) >= start_address);
               dwg->thumbnail.size = (dat->byte - 16) - start_address;
               dwg->thumbnail.chain
                   = (unsigned char *)calloc (dwg->thumbnail.size, 1);
               dwg->thumbnail.byte = 0;
               if (!dwg->thumbnail.chain)
                 {
                   LOG_ERROR ("Out of memory");
                   return DWG_ERR_OUTOFMEM;
                 }
               memcpy (dwg->thumbnail.chain, &dat->chain[start_address],
                       dwg->thumbnail.size);
               dat->byte += dwg->thumbnail.size;
               dwg_bmp (dwg, &bmpsize, &type);
               if (bmpsize > dwg->thumbnail.size)
                 LOG_ERROR ("thumbnail size overflow: %i > %" PRIuSIZE "\n",
                            bmpsize, dwg->thumbnail.size)
             }
         }
     }
 
   /*-------------------------------------------------------------------------
    * Header Variables, section 0
    */
 
   LOG_INFO ("\n"
             "=======> Header Variables:         %4u\n",
             (unsigned int)dwg->header.section[SECTION_HEADER_R13].address)
   LOG_INFO ("         Header Variables   (end): %4u\n",
             (unsigned int)(dwg->header.section[SECTION_HEADER_R13].address
                            + dwg->header.section[SECTION_HEADER_R13].size))
   if (dwg->header.section[SECTION_HEADER_R13].address < 58
       || dwg->header.section[SECTION_HEADER_R13].address
                  + dwg->header.section[SECTION_HEADER_R13].size
              > dat->size)
     {
       LOG_ERROR ("Invalid Header section, skipped")
       error |= DWG_ERR_SECTIONNOTFOUND;
       goto classes_section;
     }
   // after sentinel
   dat->byte = pvz = dwg->header.section[SECTION_HEADER_R13].address + 16;
   // LOG_HANDLE ("@ 0x" FORMAT_RLLx ".%" PRIuSIZE "\n", bit_position (dat)/8,
   // bit_position (dat)%8);
 #define MAX_HEADER_SIZE 2048
   dwg->header_vars.size = bit_read_RL (dat);
   LOG_TRACE ("         Length: " FORMAT_RL " [RL]\n", dwg->header_vars.size)
   if (dwg->header_vars.size > MAX_HEADER_SIZE)
     {
       LOG_WARN ("Fixup illegal Header Length");
       dwg->header_vars.size = dwg->header.section[SECTION_HEADER_R13].size;
       if (dwg->header_vars.size > 20)
         dwg->header_vars.size -= 16 + 4;
     }
   dat->bit = 0;
 
   error |= dwg_decode_header_variables (dat, dat, dat, dwg);
 
   // LOG_HANDLE ("@ 0x" FORMAT_RLLx ".%" PRIuSIZE "\n", bit_position (dat)/8,
   // bit_position (dat)%8); check slack Check CRC, hardcoded to 2 before end
   // sentinel
   if (dwg->header_vars.size < MAX_HEADER_SIZE)
     {
       size_t crcpos = pvz + dwg->header_vars.size + 4;
       if (dat->bit || dat->byte != crcpos)
         {
           unsigned char r = 8 - dat->bit;
           LOG_HANDLE (" padding: %zd byte, %d bits\n", crcpos - dat->byte, r);
         }
       LOG_HANDLE (" crc pos: %" PRIuSIZE "\n", crcpos);
       bit_set_position (dat, crcpos * 8);
       crc = bit_read_RS (dat);
       LOG_TRACE ("crc: %04X [RSx] from %" PRIuSIZE "-%" PRIuSIZE "=%zd\n", crc,
                  pvz, dat->byte - 2, dat->byte - 2 - pvz);
     }
   else
     {
       LOG_WARN ("Skip crc with illegal Header Length");
       error |= DWG_ERR_SECTIONNOTFOUND;
       goto classes_section;
     }
   crc2 = 0;
   // LOG_HANDLE ("@ 0x" FORMAT_RLLx "\n", bit_position (dat)/8);
   // LOG_HANDLE ("HEADER_R13.address of size 0x" FORMAT_RLLx "\n", pvz);
   // LOG_HANDLE ("HEADER_R13.size %d\n",
   // dwg->header.section[SECTION_HEADER_R13].size);
   // typical sizes: 400-599
   if (dwg->header.section[SECTION_HEADER_R13].size > 34
       && dwg->header.section[SECTION_HEADER_R13].size < 0xfff
       && pvz < dat->byte
       && pvz + dwg->header.section[SECTION_HEADER_R13].size < dat->size)
     {
       // not dwg->header_vars.size, rather -4 (minus the section_size).
       // section_size + data, i.e. minus the 2x sentinel (32) + crc itself (2)
       // if we would include the crc we would always get 0000
       BITCODE_RL crc_size = dwg->header.section[SECTION_HEADER_R13].size - 34;
       LOG_HANDLE (" calc header crc size: " FORMAT_RL "\n", crc_size);
       crc2 = bit_calc_CRC (0xC0C1, &dat->chain[pvz], crc_size);
     }
   if (crc != crc2)
     {
       LOG_WARN ("Header Section[%d] CRC mismatch %04X <=> %04X",
                 (int)dwg->header.section[SECTION_HEADER_R13].number, crc,
                 crc2);
       error |= DWG_ERR_WRONGCRC;
     }
 
   /*-------------------------------------------------------------------------
    * Classes, section 1
    */
@@ -3360,108 +3355,105 @@ static int
 decode_R2004 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
   int j, error = 0;
   Dwg_Section *section;
 
   {
     Dwg_Header *_obj = &dwg->header;
     Dwg_Object *obj = NULL;
     Bit_Chain *hdl_dat = dat;
     int i;
     BITCODE_BL vcount;
 
-    dat->byte = 0x06;
-    if (dat->from_version >= R_2022b)
-      dat->byte = 0x07;
     // clang-format off
     #include "header.spec"
     // clang-format on
   }
   LOG_HANDLE ("\nempty R2004 slack (@%" PRIuSIZE ".0-%u.0, %ld):\n",
               dat->byte - 54, 0x80, (long)(0x80 - (dat->byte - 54)));
   LOG_TF (HANDLE, &dat->chain[dat->byte], (int)(0x80 - dat->byte));
 
   error |= decode_R2004_header (dat, dwg);
   if (error > DWG_ERR_CRITICAL)
     return error;
 
   error |= read_R2004_section_map (dat, dwg);
   if (!dwg->header.section || error >= DWG_ERR_CRITICAL)
     {
       LOG_ERROR ("Failed to read R2004 Section Page Map.")
       return error | DWG_ERR_INTERNALERROR;
     }
 
   /*-------------------------------------------------------------------------
    * Section Info
    */
   section = find_section (dwg, dwg->r2004_header.section_info_id);
   if (section)
     {
       Dwg_Object *obj = NULL;
       Dwg_Section *_obj = section;
       LOG_TRACE ("\n=== Data Section (Section Info %d) @%lx ===\n",
                  dwg->r2004_header.section_info_id,
                  (unsigned long)section->address)
       dat->byte = section->address;
 
       FIELD_RLx (section_type, 0);
       if (FIELD_VALUE (section_type) != 0x4163003b)
         {
           LOG_ERROR ("Invalid Data Section Page Map type 0x%x != 0x4163003b",
                      FIELD_VALUE (section_type));
           return DWG_ERR_SECTIONNOTFOUND;
         }
       FIELD_RL (decomp_data_size, 0);
       FIELD_RL (comp_data_size, 0);
       FIELD_RL (compression_type, 0);
       FIELD_RLx (checksum, 0);
 
       // Data section map, par 4.5
       error |= read_R2004_section_info (dat, dwg, _obj->comp_data_size,
                                         _obj->decomp_data_size);
     }
   else
     error |= DWG_ERR_SECTIONNOTFOUND;
 
   error |= read_2004_section_header (dat, dwg);
   if (dwg->header.summaryinfo_address)
     error |= read_2004_section_summary (dat, dwg);
   error |= read_2004_section_classes (dat, dwg);
   error |= read_2004_section_handles (dat, dwg);
   error |= read_2004_section_auxheader (dat, dwg);
   if (dwg->header.thumbnail_address)
     error |= read_2004_section_preview (dat, dwg);
   error |= read_2004_section_appinfo (dat, dwg);
   error |= read_2004_section_appinfohistory (dat, dwg);
   error |= read_2004_section_filedeplist (dat, dwg);
   error |= read_2004_section_security (dat, dwg);
   error |= read_2004_section_revhistory (dat, dwg);
   error |= read_2004_section_objfreespace (dat, dwg);
   error |= read_2004_section_template (dat, dwg);
   if (dwg->header.vbaproj_address)
     error |= read_2004_section_vbaproject (dat, dwg);
   // error |= read_2004_section_signature (dat, dwg);
   error |= read_2004_section_acds (dat, dwg);
 
   /* Clean up. XXX? Need this to write the sections, at least the name and
    * type
    */
 #if 0
   if (dwg->header.section_info != NULL)
     {
       unsigned u;
       for (u = 0; u < dwg->header.num_infos; ++u)
         if (dwg->header.section_info[u].sections != 0)
           free(dwg->header.section_info[u].sections);
 
       free(dwg->header.section_info);
       dwg->header.num_infos = 0;
     }
 #endif
 
   LOG_INFO ("\nnum_objects: %lu\n", (unsigned long)dwg->num_objects)
   LOG_TRACE ("num_object_refs: %lu\n", (unsigned long)dwg->num_object_refs)
   LOG_TRACE ("Resolving pointers from ObjectRef vector:\n")
   error |= resolve_objectref_vector (dat, dwg);
   return error;
 }
@@ -3470,46 +3462,45 @@ static int
 decode_R2007 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
   Bit_Chain hdl_dat = { 0 };
   int error;
 
   hdl_dat = *dat;
   {
     int i;
     Dwg_Header *_obj = &dwg->header;
     Dwg_Object *obj = NULL;
     BITCODE_BL vcount;
 
-    dat->byte = 0x06;
     // clang-format off
     #include "header.spec"
     // clang-format on
   }
 
   // this includes classes, header, handles + objects
   error = read_r2007_meta_data (dat, &hdl_dat, dwg);
 
   LOG_INFO ("\nnum_objects: %lu\n", (unsigned long)dwg->num_objects)
   LOG_TRACE ("num_object_refs: %lu\n", (unsigned long)dwg->num_object_refs)
   if (error >= DWG_ERR_CRITICAL)
     {
       LOG_ERROR ("Failed to read 2007 meta data")
       return error;
     }
 
   LOG_TRACE ("Resolving pointers from ObjectRef vector:\n")
   return error | resolve_objectref_vector (dat, dwg);
 }
 
 /*--------------------------------------------------------------------------------
  * Private functions
  *
  * EED "Extended Entity Data":
  * There's an array of obj->num_eed obj->eed[] entries.
  * Each eed member has size, handle, the raw[size] buffer and the decoded data.
  * Each obj->eed[].data member is further separated into DXF+1000 codes, for
  * strings, numbers, points, ...
  * Those subgroups have an empty raw, size, and the prev. handle.
  */
 
 #undef LOG_POS
 #define LOG_POS LOG_RPOS
diff --git a/src/decode_r11.c b/src/decode_r11.c
index bcc95d7b..de775e42 100644
--- a/src/decode_r11.c
+++ b/src/decode_r11.c
@@ -623,206 +623,206 @@ EXPORT int
 decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)
 {
   BITCODE_RL num_entities;
   BITCODE_RL blocks_start = 0, blocks_end = 0, blocks_size = 0;
   BITCODE_RL extras_start = 0, extras_end = 0, extras_size = 0;
   // BITCODE_RS rs2;
   Dwg_Object *obj = NULL;
   int error = 0;
   // Bit_Chain dat_save = *dat;
 
   loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
   {
     int i;
     Dwg_Header *_obj = (Dwg_Header *)&dwg->header;
     // Bit_Chain *hdl_dat = dat;
     BITCODE_BL vcount;
-    dat->byte = 0x06;
+
     // clang-format off
     #include "header.spec"
     // clang-format on
   }
   LOG_TRACE ("@0x%zx\n", dat->byte); // 0x14
   SINCE (R_2_0b)
   {
     // Block entities
     blocks_start = dwg->header.blocks_start;
     blocks_size = dwg->header.blocks_size;
     if (blocks_size > 0xffffff)
       {
         blocks_size &= 0xffffff;
         LOG_TRACE ("blocks_size => " FORMAT_RLx "\n", blocks_size);
       }
     blocks_end = blocks_start + blocks_size;
     // Extra entities
     extras_start = dwg->header.extras_start;
     extras_size = dwg->header.extras_size;
     if (extras_size > 0xffffff)
       {
         extras_size &= 0xffffff;
         LOG_TRACE ("extras_size => " FORMAT_RLx "\n", extras_size);
       }
     extras_end = extras_start + extras_size;
   }
 
   // setup all the new control objects
   error |= dwg_add_Document (dwg, 0);
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   SINCE (R_2_0b)
   {
     dwg->header.section[0].number = 0;
     dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;
     strcpy (dwg->header.section[0].name, "HEADER");
 
     // The 5 tables (num_sections always 5): 3 RS + 1 RL address
     LOG_INFO ("==========================================\n")
     // dat_save = *dat;
     error |= decode_preR13_section_hdr ("BLOCK", SECTION_BLOCK, dat, dwg);
     if (error >= DWG_ERR_CRITICAL)
       return error;
     error |= decode_preR13_section_hdr ("LAYER", SECTION_LAYER, dat, dwg);
     if (error >= DWG_ERR_CRITICAL)
       return error;
     error |= decode_preR13_section_hdr ("STYLE", SECTION_STYLE, dat, dwg);
     if (error >= DWG_ERR_CRITICAL)
       return error;
     error |= decode_preR13_section_hdr ("LTYPE", SECTION_LTYPE, dat, dwg);
     if (error >= DWG_ERR_CRITICAL)
       return error;
     error |= decode_preR13_section_hdr ("VIEW", SECTION_VIEW, dat, dwg);
     if (error >= DWG_ERR_CRITICAL)
       return error;
   }
   LOG_TRACE ("@0x%zx\n", dat->byte); // 0x5e
   if (dat->size < 0x1f0)             // AC1.50 0x1f9 74 vars
     {
       LOG_ERROR ("DWG too small %" PRIuSIZE, (size_t)dat->size)
       return DWG_ERR_INVALIDDWG;
     }
 
   LOG_TRACE ("==========================================\n")
   error |= decode_preR13_header_variables (dat, dwg);
   LOG_TRACE ("@0x%zx\n", dat->byte);
   if (error >= DWG_ERR_CRITICAL)
     return error;
   if (dat->byte + 2 >= dat->size)
     {
       LOG_ERROR ("post HEADER overflow")
       return error | DWG_ERR_CRITICAL;
     }
   SINCE (R_11)
   {
     // crc16 + DWG_SENTINEL_R11_ENTITIES_BEGIN
     BITCODE_RS crc, crcc;
     crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now
     crc = bit_read_RS (dat);
     LOG_TRACE ("crc: %04X [RSx] from 0-0x%zx\n", crc, dat->byte - 2);
     if (crc != crcc)
       {
         LOG_ERROR ("Header CRC mismatch %04X <=> %04X", crc, crcc);
         error |= DWG_ERR_WRONGCRC;
       }
   }
 
   PRE (R_10)
   {
     num_entities = dwg->header_vars.numentities;
   }
   LATER_VERSIONS
   {
     num_entities = 0;
   }
   PRE (R_2_0b)
   {
     dwg->header.entities_start = dat->byte & 0xFFFFFFFF;
     dwg->header.entities_end = dwg->header_vars.dwg_size;
   }
 
   // entities
   error |= decode_preR13_entities (
       dwg->header.entities_start, dwg->header.entities_end, num_entities,
       dwg->header.entities_end - dwg->header.entities_start, dat, dwg,
       ENTITIES_SECTION_INDEX);
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   PRE (R_2_0b)
   {
     // this has usually some slack at the end.
     return error;
   }
 
   error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);
   if (error >= DWG_ERR_CRITICAL)
     return error;
   error |= decode_preR13_section (SECTION_LAYER, dat, dwg);
   if (error >= DWG_ERR_CRITICAL)
     return error;
   error |= decode_preR13_section (SECTION_STYLE, dat, dwg);
   if (error >= DWG_ERR_CRITICAL)
     return error;
   error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);
   if (error >= DWG_ERR_CRITICAL)
     return error;
   error |= decode_preR13_section (SECTION_VIEW, dat, dwg);
   if (error >= DWG_ERR_CRITICAL)
     return error;
   if (dwg->header.num_sections >= SECTION_VPORT) // r10
     {
       error |= decode_preR13_section (SECTION_UCS, dat, dwg);
       if (error >= DWG_ERR_CRITICAL)
         return error;
       error |= decode_preR13_section (SECTION_VPORT, dat, dwg);
       if (error >= DWG_ERR_CRITICAL)
         return error;
     }
   if (dwg->header.num_sections >= SECTION_APPID) // r10
     {
       error |= decode_preR13_section (SECTION_APPID, dat, dwg);
       if (error >= DWG_ERR_CRITICAL)
         return error;
     }
   if (dwg->header.num_sections >= SECTION_VX) // r11
     {
       error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);
       if (error >= DWG_ERR_CRITICAL)
         return error;
       error |= decode_preR13_section (SECTION_VX, dat, dwg);
       if (error >= DWG_ERR_CRITICAL)
         return error;
     }
 
   // block entities
   error |= decode_preR13_entities (blocks_start, blocks_end, 0, blocks_size,
                                    dat, dwg, BLOCKS_SECTION_INDEX);
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   // extra entities
   error |= decode_preR13_entities (extras_start, extras_end, 0, extras_size,
                                    dat, dwg, EXTRAS_SECTION_INDEX);
   if (error >= DWG_ERR_CRITICAL)
     return error;
 
   // aux header
   SINCE (R_11)
   {
     error |= decode_r11_auxheader (dat, dwg);
     if (error >= DWG_ERR_CRITICAL)
       return error;
   }
 
   if (dat->byte < dat->size)
     {
       size_t len = dat->size - dat->byte;
       BITCODE_TF unknown = bit_read_TF (dat, len);
       LOG_TRACE ("unknown (%" PRIuSIZE "):", len);
       LOG_TRACE_TF (unknown, len);
       free (unknown);
     }
 
   if (dwg->dirty_refs)
     dwg_resolve_objectrefs_silent (dwg);
   return 0;
 }
diff --git a/src/encode.c b/src/encode.c
index 641c19ab..88e8f2af 100644
--- a/src/encode.c
+++ b/src/encode.c
@@ -2461,1895 +2461,1895 @@ EXPORT int
 dwg_encode (Dwg_Data *restrict dwg, Bit_Chain *restrict dat)
 {
   int ckr_missing = 1;
   int error = 0;
   BITCODE_BL i, j;
   size_t section_address, header_crc_address = 0;
   size_t pvzadr;
   size_t last_offset;
   unsigned int ckr;
   unsigned int sec_size = 0;
   BITCODE_RLL last_handle;
   Object_Map *restrict omap;
   Bit_Chain *old_dat = NULL, *str_dat, *hdl_dat;
   Dwg_Section_Type sec_id;
   Dwg_Version_Type orig_from_version = dwg->header.from_version;
   Bit_Chain sec_dat[SECTION_SYSTEM_MAP + 1]; // to encode each r2004 section
   // check order of sections explicitly
   enum {
     before_header,
     before_handles,
     after_auxheader,
   } thumbnail_position;
   enum {
     after_class,
     after_2ndheader,
   } template_position;
 
   dwg->cur_index = 0;
   if (dwg->opts)
     loglevel = dwg->opts & DWG_OPTS_LOGLEVEL;
 #ifdef USE_TRACING
   /* Before starting, set the logging level, but only do so once.  */
   if (!env_var_checked_p)
     {
       char *probe = getenv ("LIBREDWG_TRACE");
       if (probe)
         loglevel = atoi (probe);
       env_var_checked_p = true;
     }
 #endif /* USE_TRACING */
 
   if (dwg->header.version != dwg->header.from_version)
     LOG_TRACE ("Encode version %s (%s) from version %s (%s)\n",
                dwg_version_codes (dwg->header.version),
                dwg_version_type (dwg->header.version),
                dwg_version_codes (dwg->header.from_version),
                dwg_version_type (dwg->header.from_version))
   else
     LOG_TRACE ("Encode version %s (%s)\n",
                dwg_version_codes (dwg->header.version),
                dwg_version_type (dwg->header.version));
 
 #ifdef ENCODE_UNKNOWN_AS_DUMMY
   // We cannot write unknown_bits into another version, or when it's coming
   // from DXF. Write a PLACEHOLDER/DUMMY or POINT instead. Later maybe PROXY.
   // This is controversial and breaks roundtrip tests, but helps
   // ACAD imports.
   if (dwg_supports_eed (dwg) &&
       (dwg->header.version != dwg->header.from_version
        || (dwg->opts & DWG_OPTS_IN)))
     {
       int fixup = 0;
       // Scan for invalid/unstable/unsupported objects and entities
       // and eliminate or replace them with placeholders.
       LOG_TRACE ("Scan for unsupported objects\n");
       for (i = 0; i < dwg->num_objects; i++)
         {
           Dwg_Object *obj = &dwg->object[i];
           if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ
               || obj->fixedtype == DWG_TYPE_UNKNOWN_ENT
               // WIPEOUT causes hang, TABLEGEOMETRY crash, MATERIAL causes ODA errors
 #ifndef DEBUG_CLASSES
                       || (dwg->opts & DWG_OPTS_IN
                           && (obj->fixedtype == DWG_TYPE_WIPEOUT
                               || obj->fixedtype == DWG_TYPE_TABLEGEOMETRY
                               || obj->fixedtype == DWG_TYPE_MATERIAL))
 #endif
               )
             {
               fixup++;
               break;
             }
         }
       if (fixup)
         {
           BITCODE_RLL new_appid;
           BITCODE_BS placeholder_type = 0;
           LOG_TRACE ("Found unsupported objects, add APPID LibreDWG\n");
           new_appid = add_LibreDWG_APPID (dwg);
           if (new_appid)
             {
               fixup = 0;
               // if not found leaves placeholder_type at 0 to use DUMMY
               LOG_HANDLE ("find_class ACDBPLACEHOLDER\n");
               dwg_find_class (dwg, "ACDBPLACEHOLDER", &placeholder_type);
               if (placeholder_type < 500)
                 {
                   LOG_ERROR ("Invalid class_id %d for ACDBPLACEHOLDER",
                              (int)placeholder_type);
                   placeholder_type = 0;
                 }
               for (i = 0; i < dwg->num_objects; i++)
                 {
                   Dwg_Object *obj = &dwg->object[i];
                   if (obj->fixedtype == DWG_TYPE_UNKNOWN_OBJ
                       || obj->fixedtype == DWG_TYPE_UNKNOWN_ENT
 #ifndef DEBUG_CLASSES
                       || (dwg->opts & DWG_OPTS_IN
                           && (obj->fixedtype == DWG_TYPE_WIPEOUT
                               || obj->fixedtype == DWG_TYPE_TABLEGEOMETRY
                               || obj->fixedtype == DWG_TYPE_MATERIAL))
 #endif
                       )
                     {
                       fixup++;
                       // replace entities with points, objects with
                       // placeholders
                       LOG_HANDLE ("encode_unknown_as_dummy\n");
                       encode_unknown_as_dummy (dat, obj, placeholder_type);
                     }
                   // what to do with links to MATERIAL/...
                   if (dwg->header.version >= R_13b1
                       && obj->handle.value == 0xC
                       && obj->fixedtype == DWG_TYPE_DICTIONARY)
                     fixup_NOD (dwg, obj); // named object dict
                 }
               LOG_TRACE ("Fixed %d unsupported objects\n\n", fixup);
             }
         }
     }
 #endif
   if (dwg_supports_eed (dwg) && dwg->header.version < R_2010
       && dwg->header.from_version >= R_2010)
     {
       // Scan for objects with EED for class_version fields.
       LOG_TRACE ("Scan for downconverting objects to EED\n");
       for (i = 0; i < dwg->num_objects; i++)
         {
           Dwg_Object *obj = &dwg->object[i];
           if (obj->fixedtype == DWG_TYPE_MLEADERSTYLE)
             downconvert_MLEADERSTYLE (obj);
           else if (obj->fixedtype == DWG_TYPE_DIMSTYLE)
             downconvert_DIMSTYLE (dat, obj); // so far Annotative only
         }
     }
 
   bit_chain_alloc (dat);
   hdl_dat = dat; // split later in objects/entities
   if (!dat->version)
     {
       dat->version = dwg->header.version;
       dat->from_version = dwg->header.from_version;
       dat->opts = dwg->opts;
     }
   dat->codepage = dwg->header.codepage;
 
   if (dwg->header.from_version > R_2000 && dwg->header.version <= R_2000)
     {
       remove_EXEMPT_FROM_CAD_STANDARDS_APPID (dat, dwg);
     }
 
   /*------------------------------------------------------------
    * Header
    */
   strcpy ((char *)dat->chain,
           dwg_version_codes (dwg->header.version)); // Chain version
-  dat->byte += 6;
+  dat->byte += 11;
 
   {
     BITCODE_BL vcount;
     // set dwg_version from release
     const struct dwg_versions *_verp
         = dwg_version_struct (dwg->header.version);
     Dwg_Header *_obj = &dwg->header;
     Dwg_Object *obj = NULL;
     if ((dwg->header.version < R_13b1 && !_obj->numheader_vars) // ie from DXF
         || (dwg->header.version >= R_13b1 && !_obj->dwg_version))
       {
         _obj->zero_one_or_three = 1;
         if (_verp)
           _obj->dwg_version = _verp->dwg_version;
         if (dwg->header.version > R_13b1)
           {
             // can be improved with r2004 by another lookup table
             _obj->is_maint = 0xf;
             _obj->maint_version = 29;
           }
         /*
         switch (dwg->header.version)
           {
           case R_9:
             _obj->dwg_version = 0x0b;
             break;
           case R_10:
             _obj->dwg_version = 0x0d;
             break;
           case R_11:
             _obj->dwg_version = 0x10;
             break;
           case R_13:
             _obj->dwg_version = 0x13;
             break;
           case R_13c3:
             _obj->dwg_version = 0x14;
             break;
           case R_14:
             _obj->dwg_version = 0x15;
             break;
           case R_2000:
             _obj->dwg_version = 0x17;
             _obj->is_maint = 0xf;
             break;
           case R_2004:
             _obj->dwg_version = 0x19; // or 0x18/0x1a
             _obj->is_maint = 0x68;
             break;
           case R_2007:
             _obj->dwg_version = 0x1b;
             _obj->is_maint = 0x32;
             break;
           case R_2010:
             _obj->dwg_version = 0x1d;
             _obj->is_maint = 0x6d;
             break;
           case R_2013:
             _obj->dwg_version = 0x1f;
             _obj->is_maint = 0x7d;
             break;
           case R_2018:
             _obj->dwg_version = 0x21;
             _obj->is_maint = 0x1d;
             break;
           case R_INVALID:
           case R_AFTER:
           case R_1_1:
           case R_1_2:
           case R_1_3:
           case R_1_4:
           case R_2_0:
           case R_2_1:
           case R_2_21:
           case R_2_22:
           case R_2_4:
           case R_2_5:
           case R_2_6:
           case R_9c1:
           case R_11b1:
           case R_11b2:
           case R_12:
           default:
             break;
           }
           */
         if (!_obj->app_dwg_version)
           _obj->app_dwg_version = _obj->dwg_version;
       }
     if (!_obj->codepage)
       _obj->codepage = dat->codepage;
     if (!_obj->blocks_size)
       _obj->blocks_size = 0x40000000;
     if (!_obj->extras_size)
       _obj->extras_size = 0x80000000;
     VERSIONS (R_2_0b, R_13b1)
     {
       _obj->numentity_sections = 3;
     }
     SINCE (R_2004)
     {
       if (!_obj->r2004_header_address)
         _obj->r2004_header_address = 128;
     }
 
       // clang-format off
     #include "header.spec"
     // clang-format on
   }
   section_address = dat->byte;
 
 #define WE_CAN                                                                \
   "This version of LibreDWG is only capable of encoding "                     \
   "versions r1.1-r2000 (code: MC0.0-AC1015) DWG files.\n"
 
   PRE (R_13b1)
   {
     BITCODE_RL numentities, addr;
     size_t hdr_offset, hdr_end;
     BITCODE_BL last_entity_idx, end_idx;
     BITCODE_BLd first_entity_idx = 0;
     Dwg_Object *first_block;
 
     if (dwg->header.version == R_INVALID
         || dwg->header.from_version == R_INVALID)
       {
         LOG_ERROR (WE_CAN "Invalid or missing FILEHEADER.version");
         return DWG_ERR_INVALIDDWG;
       }
 
     SINCE (R_2_0b)
     {
       if (!dwg->header.section
           || dwg->header.version != dwg->header.from_version)
         {
           dwg_sections_init (dwg);
         }
       // get the tables from the CONTROL objects
       encode_preR13_section_hdr ("BLOCK", SECTION_BLOCK, dat, dwg);
       encode_preR13_section_hdr ("LAYER", SECTION_LAYER, dat, dwg);
       encode_preR13_section_hdr ("STYLE", SECTION_STYLE, dat, dwg);
       encode_preR13_section_hdr ("LTYPE", SECTION_LTYPE, dat, dwg);
       encode_preR13_section_hdr ("VIEW", SECTION_VIEW, dat, dwg);
       /* The rest is embedded into header_variables_r11.spec below */
     }
 
     hdr_offset = dat->byte;
     encode_preR13_header_variables (dat, dwg);
     hdr_end = dat->byte;
     // the sentinel starts 16 before entities_start
     SINCE (R_11)
     {
       if (!dwg->header.num_sections)
         dwg->header.num_sections = SECTION_VX;
       bit_write_RS (dat, 0); // crc placeholder
       LOG_TRACE ("crc 0 [RSx]\n");
       write_sentinel (dat, DWG_SENTINEL_R11_ENTITIES_BEGIN);
     }
     else if (!dwg->header.num_sections) dwg->header.num_sections
         = dwg->header.numheader_vars <= 129   ? SECTION_VIEW
           : dwg->header.numheader_vars <= 158 ? SECTION_VPORT
           : dwg->header.numheader_vars <= 160 ? SECTION_APPID
                                               : SECTION_VX;
     dwg->header.entities_start = dat->byte & 0xFFFFFFFF;
     // LOG_TRACE ("\nentities 0x%x:\n", dwg->header.entities_start);
     dwg->cur_index = 0;
     // collect all entities (non-blocks)
     numentities
         = encode_preR13_entities (ENTITIES_SECTION_INDEX, dat, dwg, &error);
     dwg->cur_index += numentities;
     if (!dwg->header.entities_end)
       dwg->header.entities_end = dat->byte & 0xFFFFFFFF;
     LOG_TRACE ("\nentities %u 0x%x - 0x%x\n", numentities,
                dwg->header.entities_start, dwg->header.entities_end);
     write_sentinel (dat, DWG_SENTINEL_R11_ENTITIES_END);
 
     // patch all the section tbl->address
     addr = dwg->header.entities_end + (dat->version >= R_11 ? 0x20 : 0);
     encode_check_num_sections (dwg->header.num_sections, dwg);
     if (dwg->header.from_version >= R_13b1)
       {
         /* r2000 has e.g.
          * section 0: header vars
          *         1: class section
          *         2: object map
          *         3: optional: ObjFreeSpace
          *         4: optional: Template
          *         5: optional: AuxHeader (no sentinels, since R13c3)
          */
         LOG_ERROR ("FIXME convert sections from CONTROL objects to tables");
       }
     if (dwg->header.from_version < R_13b1 && dwg->header.section)
       {
         for (int id = (int)SECTION_BLOCK; id <= (int)dwg->header.num_sections;
              id++)
           {
             Dwg_Section *tbl = &dwg->header.section[id];
             BITCODE_RL pos = dat->byte & 0xFFFFFFFF;
             if (!tbl || !tbl->address)
               continue;
             dat->byte = tbl->address;
             LOG_TRACE ("%s.address => " FORMAT_RLx " [RLx] @%u.0\n", tbl->name, addr,
                        (unsigned)tbl->address);
             bit_write_RL (dat, addr);
             tbl->address = addr;
             addr += tbl->size * tbl->number;
             if (dat->version >= R_11)
               addr += 0x20;
             dat->byte = pos;
           }
       }
 
     PRE (R_2_0b)
     {
       // patch these numbers into the header
       BITCODE_RL dwg_size = dat->byte & 0xFFFFFFFF;
       dat->byte = 0x0c + 24;
       if (dwg_size != dwg->header_vars.dwg_size)
         LOG_TRACE ("-dwg_size: %u [RL] @%" PRIuSIZE ".0\n", (unsigned)dwg_size,
                    dat->byte);
       bit_write_RL (dat, dwg_size);
       if (numentities != dwg->header_vars.numentities)
         LOG_TRACE ("-numentities: %u [RS] @%" PRIuSIZE ".0\n",
                    (unsigned)numentities, dat->byte);
       bit_write_RS (dat, numentities & 0xFFFF);
       dat->byte = dwg_size;
       LOG_TRACE ("Wrote %u bytes\n", (unsigned)dwg_size);
       return error;
     }
     SINCE (R_2_0b)
     {
       BITCODE_RL num_block_entities, num_extra_entities, blocks_end,
           extras_end, jump_index;
       BITCODE_RL endblk_index = dwg->num_objects - 1;
       Dwg_Object *last_endblk;
 
       error |= encode_preR13_section (SECTION_BLOCK, dat, dwg);
       error |= encode_preR13_section (SECTION_LAYER, dat, dwg);
       error |= encode_preR13_section (SECTION_STYLE, dat, dwg);
       error |= encode_preR13_section (SECTION_LTYPE, dat, dwg);
       error |= encode_preR13_section (SECTION_VIEW, dat, dwg);
 
       if (dwg->header.num_sections >= SECTION_VPORT)
         {
           error |= encode_preR13_section (SECTION_UCS, dat, dwg);
           error |= encode_preR13_section (SECTION_VPORT, dat, dwg);
         }
       if (dwg->header.num_sections >= SECTION_APPID)
         error |= encode_preR13_section (SECTION_APPID, dat, dwg);
       if (dwg->header.num_sections >= SECTION_VX)
         {
           error |= encode_preR13_section (SECTION_DIMSTYLE, dat, dwg);
           error |= encode_preR13_section (SECTION_VX, dat, dwg);
         }
       // encode block entities
       write_sentinel (dat, DWG_SENTINEL_R11_BLOCK_ENTITIES_BEGIN);
       dwg->header.blocks_start = dat->byte & 0xFFFFFFFF;
       if (dat->version >= R_2_0b
           && (first_block = dwg_find_first_type (dwg, DWG_TYPE_BLOCK)))
         {
           num_block_entities = encode_preR13_entities (BLOCKS_SECTION_INDEX,
                                                        dat, dwg, &error);
           dwg->header.blocks_size
               = (dat->byte - dwg->header.blocks_start) & 0xFFFFFFFF;
         }
       else
         {
           num_block_entities = 0;
           dwg->header.blocks_size = 0;
         }
       write_sentinel (dat, DWG_SENTINEL_R11_BLOCK_ENTITIES_END);
       if (dwg->header.version > R_2_22)
         dwg->header.blocks_size += 0x40000000;
       LOG_TRACE ("\nblock_entities %u 0x%x - 0x%x (0x%x)\n",
                  num_block_entities, dwg->header.blocks_start,
                  dwg->header.blocks_start
                      + (dwg->header.blocks_size & 0xffffff),
                  dwg->header.blocks_size);
 
       // encode extra entities.
       write_sentinel (dat, DWG_SENTINEL_R11_EXTRA_ENTITIES_BEGIN);
       dwg->header.extras_start = dat->byte & 0xFFFFFFFF;
       if (dwg->num_objects)
         {
           num_extra_entities = encode_preR13_entities (EXTRAS_SECTION_INDEX,
                                                        dat, dwg, &error);
           dwg->header.extras_size
               = 0x80000000
                 + ((dat->byte - dwg->header.extras_start) & 0x8FFFFFFF);
         }
       else
         num_extra_entities = 0;
       write_sentinel (dat, DWG_SENTINEL_R11_EXTRA_ENTITIES_END);
       LOG_TRACE ("\nextra_entities %u 0x%x - 0x%x (0x%x)\n",
                  num_extra_entities, dwg->header.extras_start,
                  dwg->header.extras_start
                      + (dwg->header.extras_size & 0xffffff),
                  dwg->header.extras_size);
       PRE (R_10)
       {
         if (dwg->header_vars.numentities != numentities + num_block_entities)
           {
             dwg->header_vars.numentities = numentities + num_block_entities;
             LOG_WARN ("Fixed numentities: %u\n", dwg->header_vars.numentities);
           }
       }
       SINCE (R_11)
       {
         error |= encode_r11_auxheader (dat, dwg);
       }
       addr = dat->byte & 0xFFFFFFFF;
       LOG_TRACE ("@0x%x -> ", addr);
       if (error >= DWG_ERR_CRITICAL)
         return error;
       // patch these numbers into the header
       dat->byte = 0x14; // header section_address
       dat->bit = 0;
       bit_write_RL (dat, dwg->header.entities_start);
       LOG_TRACE ("0x14:\nentities_start: 0x%x [RLx]\n",
                  dwg->header.entities_start);
       bit_write_RL (dat, dwg->header.entities_end);
       LOG_TRACE ("entities_end: 0x%x [RLx]\n", dwg->header.entities_end);
       bit_write_RL (dat, dwg->header.blocks_start);
       LOG_TRACE ("blocks_start: 0x%x [RLx]\n", dwg->header.blocks_start);
       bit_write_RL (dat, dwg->header.blocks_size);
       LOG_TRACE ("blocks_size: 0x%x [RLx]\n", dwg->header.blocks_size);
       bit_write_RL (dat, dwg->header.extras_start);
       LOG_TRACE ("extras_start: 0x%x [RLx]\n", dwg->header.extras_start);
       bit_write_RL (dat, dwg->header.extras_size);
       LOG_TRACE ("extras_size: 0x%x [RLx]\n", dwg->header.extras_size);
       SINCE (R_11)
       {
         BITCODE_RS crc;
         dat->byte = dwg->header.entities_start - 18;
         assert (dat->byte == hdr_end);
         crc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte);
         LOG_TRACE ("crc: %04X [RSx] from 0-0x%zx\n", crc, dat->byte); // -0x6bd
         bit_write_RS (dat, crc);
       }
     }
     VERSIONS (R_2_0b, R_9c1)
     {
       LOG_TRACE ("@0x%zx ->", dat->byte);
       dat->byte = hdr_offset + (3 * 8);
       LOG_TRACE ("0x%zx", dat->byte);
       bit_write_RS (dat, dwg->header_vars.numentities);
       LOG_TRACE ("numentities: %u [RS]\n", dwg->header_vars.numentities);
     }
     dat->byte = addr;
     LOG_TRACE ("Wrote %" PRIuSIZE " bytes\n", dat->byte);
     dat->size = addr;
     return error;
   }
 
   thumbnail_position = after_auxheader;
   template_position = after_2ndheader;
   VERSIONS (R_13b1, R_2004)
   {
     /* section 0: Header vars
      *         1: Classes
                   Template (r13 only, optional)
                   padding (r13c3+)
                   THUMBNAIL
      *         2: Handles
      *         3: ObjFreeSpace (r13c3+, optional)
                   + 2NDHEADER (r13-r2000)
      *         4: Template (r14-r2000, optional)
      *         5: AuxHeader (r2000, no sentinels)
      *         6: THUMBNAIL (r13c3+, not a section)
      */
     
     /* Usually 3-5, max 6 */
     if (!dwg->header.num_sections
         || (dat->from_version >= R_2004 && dwg->header.num_sections > 6))
       {
         if (dwg->header.version <= R_2000)
           {
             if (dwg->secondheader.num_sections)
               dwg->header.num_sections = dwg->secondheader.num_sections;
             else
               dwg->header.num_sections
                   = dwg->auxheader.dwg_version && dwg->header.version == R_2000
                         ? 6
                         : 5;
           }
         else
           dwg->header.num_sections = 6;
         // minimal DXF:
         // if (dwg->opts & (DWG_OPTS_INDXF | DWG_OPTS_MINIMAL)
         //    && (!dwg->header_vars.HANDSEED ||
         //    !dwg->header_vars.TDCREATE.days))
         //  {
         //    dwg->header.num_sections = 5;
         //    // hack to trigger IF_ENCODE_FROM_EARLIER defaults. undone after
         //    // HEADER
         //    dat->from_version = R_11;
         //    if (dat->version <= dat->from_version)
         //      dat->from_version = (Dwg_Version_Type)((int)dat->version - 1);
         //  }
       }
     error |= dwg_sections_init (dwg);
     if (error >= DWG_ERR_CRITICAL)
       return error;
     LOG_TRACE ("sections: " FORMAT_RL " [RL]\n", dwg->header.sections);
     bit_write_RL (dat, dwg->header.sections);
     section_address = dat->byte;             // save section address
     dat->byte += (dwg->header.sections * 9); /* RC + 2*RL */
     header_crc_address = dat->byte;
     bit_write_CRC (dat, 0, 0xC0C1);
     write_sentinel (dat, DWG_SENTINEL_HEADER_END);
 
     // compute the old section order
     if (dwg->header.thumbnail_address)
       {
         if (dwg->header.section[SECTION_HEADER_R13].address
             && dwg->header.thumbnail_address
                    < dwg->header.section[SECTION_HEADER_R13].address)
           thumbnail_position = before_header; // r13 if empty
         else if (dwg->secondheader.sections[SECTION_HEADER_R13].address
             && dwg->header.thumbnail_address
                    < dwg->secondheader.sections[SECTION_HEADER_R13].address)
           thumbnail_position = before_header; // r13 if empty
         else if (dwg->secondheader.sections[SECTION_AUXHEADER_R2000].address
                  && dwg->header.thumbnail_address
                     > dwg->secondheader.sections[SECTION_AUXHEADER_R2000].address)
           thumbnail_position = after_auxheader;
         else if (dwg->header.num_sections > SECTION_AUXHEADER_R2000
                  && dwg->header.section[SECTION_AUXHEADER_R2000].address
                  && dwg->header.thumbnail_address
                     > dwg->header.section[SECTION_AUXHEADER_R2000].address)
           thumbnail_position = after_auxheader;
       }
     else
       {
         PRE (R_13c3)
           thumbnail_position = before_handles;
         VERSIONS (R_13c3, R_2000)
           thumbnail_position = after_auxheader;
         SINCE (R_2004)
           thumbnail_position = before_header;
       }
     VERSION (R_13)
       template_position = after_class;
 
     // on downconvert add the missing VX_CONTROL object
     if (dwg->header.version < R_2004 && !dwg->header_vars.VX_CONTROL_OBJECT)
       {
         Dwg_Object *obj;
         obj = dwg_find_first_type (dwg, DWG_TYPE_VX_CONTROL);
         if (!obj)
           {
             Dwg_Object_VX_TABLE_RECORD *_obj = dwg_add_VX (dwg, "");
             Dwg_Object *o
               = dwg_find_first_type (dwg, DWG_TYPE_VX_TABLE_RECORD);
             obj = dwg_find_first_type (dwg, DWG_TYPE_VX_CONTROL);
             LOG_TRACE ("adding VX_CONTROL object " FORMAT_RLL "\n",
                        obj->handle.value);
             _obj->is_on = 1;
             dwg->header_vars.VX_TABLE_RECORD
               = dwg_add_handleref (dwg, 5, o->handle.value, NULL);
           }
         if (obj)
           dwg->header_vars.VX_CONTROL_OBJECT
             = dwg_add_handleref (dwg, 3, obj->handle.value, obj);
       }
 
     /*------------------------------------------------------------
      * AuxHeader section 5
      * R2000+, mostly redundant file header information
      */
     if (dwg->header.sections > 5 && dwg->header.version >= R_2000)
       {
         Dwg_AuxHeader *_obj = &dwg->auxheader;
         Dwg_Object *obj = NULL;
         BITCODE_BL vcount;
         assert (!dat->bit);
         LOG_INFO ("\n=======> AuxHeader: %8zu\n", dat->byte); // size: 123
 
         dwg->header.section[SECTION_AUXHEADER_R2000].number = 5;
         dwg->header.section[SECTION_AUXHEADER_R2000].address = dat->byte;
 
         if (!_obj->dwg_version) // todo: needed?
           {
             BITCODE_RS def_unknown_6rs[] = { 4, 0x565, 0, 0, 2, 1 };
             LOG_TRACE ("Use AuxHeader defaults...\n");
             FIELD_VALUE (aux_intro[0]) = 0xff;
             FIELD_VALUE (aux_intro[1]) = 0x77;
             FIELD_VALUE (aux_intro[2]) = 0x01;
             FIELD_VALUE (minus_1) = -1;
             FIELD_VALUE (dwg_version) = dwg->header.dwg_version;
             FIELD_VALUE (maint_version) = dwg->header.maint_version;
             FIELD_VALUE (dwg_version_1) = dwg->header.dwg_version;
             FIELD_VALUE (dwg_version_2) = dwg->header.dwg_version;
             FIELD_VALUE (maint_version_1) = dwg->header.maint_version;
             FIELD_VALUE (maint_version_2) = dwg->header.maint_version;
             memcpy (FIELD_VALUE (unknown_6rs), def_unknown_6rs,
                     sizeof (def_unknown_6rs));
             memcpy (&_obj->TDCREATE, &dwg->header_vars.TDCREATE,
                     sizeof (BITCODE_TIMERLL));
             memcpy (&_obj->TDUPDATE, &dwg->header_vars.TDUPDATE,
                     sizeof (BITCODE_TIMERLL));
             if (dwg->header_vars.HANDSEED)
               FIELD_VALUE (HANDSEED) = dwg->header_vars.HANDSEED->absolute_ref;
           }
 
         // clang-format off
         #include "auxheader.spec"
         // clang-format on
 
         dwg->header.section[SECTION_AUXHEADER_R2000].size
             = (BITCODE_RL)(dat->byte
                            - dwg->header.section[SECTION_AUXHEADER_R2000]
                                  .address);
         assert (!dat->bit);
       }
     
     if ((thumbnail_position == before_header
          || thumbnail_position == after_auxheader)
         && dwg->header.version < R_2000)
       {
         error |= encode_r13_thumbnail (dwg, dat, header_crc_address);
       }
   } // VERSIONS (R_13b1, R_2004)
 
   VERSION (R_2007)
   {
     LOG_ERROR (WE_CAN "We don't encode R2007 sections yet");
     dat->version = dwg->header.version = R_2010; // rather do 2010
     // return DWG_ERR_NOTYETSUPPORTED;
   }
 
   /* r2004 file header (compressed + encrypted) */
   SINCE (R_2004)
   {
     LOG_INFO ("\n");
     LOG_ERROR (WE_CAN "Writing R2004 sections not yet finished");
 
     memset (&sec_dat, 0, (SECTION_SYSTEM_MAP + 1) * sizeof (Bit_Chain));
     if (dwg->header.section_infohdr.num_desc && !dwg->header.section_info)
       dwg->header.section_info = (Dwg_Section_Info *)calloc (
           dwg->header.section_infohdr.num_desc, sizeof (Dwg_Section_Info));
     LOG_TRACE ("\n#### r2004 File Header ####\n");
     if (dat->byte + 0x80 >= dat->size - 1)
       {
         dwg->header.num_sections = 28; // room for some object pages
         dwg->header.section = (Dwg_Section *)calloc (28, sizeof (Dwg_Section));
       }
     if (!dwg->header.section_info)
       {
         dwg->header.section_infohdr.num_desc = SECTION_SYSTEM_MAP + 1;
         dwg->header.section_info = (Dwg_Section_Info *)calloc (
             SECTION_SYSTEM_MAP + 1, sizeof (Dwg_Section_Info));
       }
   }
 
   /*------------------------------------------------------------
    * Header Variables
    */
   SINCE (R_2004)
   {
     sec_id = SECTION_HEADER;
     bit_chain_init_dat (&sec_dat[sec_id], sizeof (Dwg_Header) + 64, dat);
     str_dat = hdl_dat = dat = &sec_dat[sec_id];
   }
   assert (!dat->bit);
   LOG_INFO ("\n=======> Header Variables:   %4zu\n", dat->byte);
   if (!dwg->header.section)
     {
       LOG_ERROR ("Empty header.section");
       return DWG_ERR_OUTOFMEM;
     }
   dwg->header.section[0].number = 0;
   dwg->header.section[0].address = dat->byte;
   write_sentinel (dat, DWG_SENTINEL_VARIABLE_BEGIN);
 
   pvzadr = dat->byte; // Size position
   {
     bit_write_RL (dat, 540); // Size placeholder
     // if (dat->version >= R_2007)
     //  str_dat = dat;
     dwg_encode_header_variables (dat, hdl_dat, dat, dwg);
     // undo minimal HEADER hack
     if (dat->from_version != orig_from_version)
       dat->from_version = orig_from_version;
     encode_patch_RLsize (dat, pvzadr);
     bit_write_CRC (dat, pvzadr, 0xC0C1);
 
     // XXX trying to fix CRC 2-byte overflow. Must find actual reason.
     // dat->byte -= 2;
     write_sentinel (dat, DWG_SENTINEL_VARIABLE_END);
     assert ((int64_t)dat->byte > (int64_t)dwg->header.section[0].address);
     dwg->header.section[0].size
         = ((int64_t)dat->byte - (int64_t)dwg->header.section[0].address)
           & 0xFFFFFFFF;
     LOG_TRACE ("         Header Variables (end): %4zu\n", dat->byte);
 
     /*------------------------------------------------------------
      * Classes
      */
     SINCE (R_2004)
     {
       sec_id = SECTION_CLASSES;
       bit_chain_init_dat (&sec_dat[sec_id],
                           (sizeof (Dwg_Class) * dwg->num_classes) + 32, dat);
       str_dat = hdl_dat = dat = &sec_dat[sec_id];
     }
     else sec_id = (Dwg_Section_Type)SECTION_CLASSES_R13;
     LOG_INFO ("\n=======> Classes: %4zu (%d)\n", dat->byte, dwg->num_classes);
     if (dwg->num_classes > 5000)
       {
         LOG_ERROR ("Invalid dwg->num_classes %d", dwg->num_classes)
         dwg->num_classes = 0;
         error |= DWG_ERR_VALUEOUTOFBOUNDS | DWG_ERR_CLASSESNOTFOUND;
       }
     dwg->header.section[sec_id].number = 1;
     dwg->header.section[sec_id].address = dat->byte; // FIXME
     write_sentinel (dat, DWG_SENTINEL_CLASS_BEGIN);
     pvzadr = dat->byte;    // Size position
     bit_write_RL (dat, 0); // Size placeholder
 
     for (j = 0; j < dwg->num_classes; j++)
       {
         Dwg_Class *klass;
         klass = &dwg->dwg_class[j];
         bit_write_BS (dat, klass->number);
         bit_write_BS (dat, klass->proxyflag);
         SINCE (R_2007)
         {
           bit_write_T (dat, klass->appname);
           bit_write_T (dat, klass->cppname);
         }
         else
         {
           bit_write_TV (dat, klass->appname);
           bit_write_TV (dat, klass->cppname);
         }
         SINCE (R_2007) // only when we have it. like not for 2004 => 2007
                        // conversions
         {
           if (klass->dxfname_u)
             bit_write_TU (dat, klass->dxfname_u);
           else
             bit_write_T (dat, klass->dxfname);
         }
         else // we always have this one
             bit_write_TV (dat, klass->dxfname);
         bit_write_B (dat, klass->is_zombie);
         bit_write_BS (dat, klass->item_class_id);
         LOG_TRACE ("Class %d 0x%x %s\n"
                    " %s \"%s\" %d 0x%x\n",
                    klass->number, klass->proxyflag, klass->dxfname,
                    klass->cppname, klass->appname, klass->is_zombie,
                    klass->item_class_id)
 
         SINCE (R_2007)
         {
           if (dat->from_version < R_2007 && !klass->dwg_version)
             {
               // defaults
               klass->dwg_version = (BITCODE_BL)dwg->header.dwg_version;
               klass->maint_version = (BITCODE_BL)dwg->header.maint_version;
               // TODO num_instances
             }
           bit_write_BL (dat, klass->num_instances);
           bit_write_BL (dat, klass->dwg_version);
           bit_write_BL (dat, klass->maint_version);
           bit_write_BL (dat, klass->unknown_1);
           bit_write_BL (dat, klass->unknown_2);
           LOG_TRACE (" %d %d\n", (int)klass->num_instances,
                      (int)klass->dwg_version);
         }
       }
 
     /* Write the size of the section at its beginning
      */
     assert (pvzadr);
     encode_patch_RLsize (dat, pvzadr);
     bit_write_CRC (dat, pvzadr, 0xC0C1);
     write_sentinel (dat, DWG_SENTINEL_CLASS_END);
     dwg->header.section[SECTION_CLASSES_R13].size
         = (dat->byte - dwg->header.section[SECTION_CLASSES_R13].address)
           & 0xFFFFFFFF;
     LOG_TRACE ("       Classes (end): %4zu\n", dat->byte);
     bit_write_RL (dat, 0x0DCA);
     LOG_TRACE ("unknown: %04X [RL]\n", 0x0DCA);
   }
 
   if (template_position == after_class
       && (int)dwg->header.num_sections > (int)SECTION_TEMPLATE_R13)
     {
       error |= encode_template (dwg, dat,
                                 (Dwg_Section_Type)SECTION_TEMPLATE_R13);
     }
   if (thumbnail_position == before_handles)
     {
       error |= encode_r13_thumbnail (dwg, dat, header_crc_address);
     }
 
   old_dat = dat;
   /*------------------------------------------------------------
    * Objects
    */
   SINCE (R_2004)
   {
     sec_id = SECTION_OBJECTS;
     bit_chain_alloc (&sec_dat[sec_id]);
     str_dat = hdl_dat = dat = &sec_dat[sec_id];
     bit_chain_set_version (dat, old_dat);
   }
   LOG_INFO ("\n=======> Objects: %4zu\n", dat->byte);
   pvzadr = dat->byte;
 
   /* Sort object-map by ascending handles
    */
   LOG_TRACE ("num_objects: %i\n", dwg->num_objects);
   LOG_TRACE ("num_object_refs: %i\n", dwg->num_object_refs);
   omap = (Object_Map *)calloc (dwg->num_objects, sizeof (Object_Map));
   if (!omap)
     {
       LOG_ERROR ("Out of memory");
       return DWG_ERR_OUTOFMEM;
     }
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)
     {
       LOG_HANDLE ("\nSorting objects...\n");
       for (i = 0; i < dwg->num_objects; i++)
         fprintf (OUTPUT, "Object(%3i): " FORMAT_RLLx " / idx: %u\n", i,
                  dwg->object[i].handle.value, dwg->object[i].index);
     }
   // init unsorted
   for (i = 0; i < dwg->num_objects; i++)
     {
       Dwg_Object *obj = &dwg->object[i];
       if (obj->type == DWG_TYPE_UNUSED)
         {
           LOG_TRACE ("Skip unused object %s " FORMAT_BL " " FORMAT_RLLx "\n",
                      obj->name ? obj->name : "", i, obj->handle.value)
           continue;
         }
       if (obj->type == DWG_TYPE_FREED)
         {
           LOG_TRACE ("Skip freed object %s " FORMAT_BL " " FORMAT_RLLx "\n",
                      obj->name ? obj->name : "", i, obj->handle.value)
           continue;
         }
       omap[i].index = i; // i.e. dwg->object[j].index
       omap[i].handle = dwg->object[i].handle.value;
     }
   // insertion sort
   for (i = 0; i < dwg->num_objects; i++)
     {
       Object_Map tmap;
       j = i;
       tmap = omap[i];
       while (j > 0 && omap[j - 1].handle > tmap.handle)
         {
           omap[j] = omap[j - 1];
           j--;
         }
       omap[j] = tmap;
     }
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)
     {
       LOG_HANDLE ("\nSorted handles:\n");
       for (i = 0; i < dwg->num_objects; i++)
         fprintf (OUTPUT, "Handle(%3i): " FORMAT_RLLx " / idx: " FORMAT_BL "\n",
                  i, omap[i].handle, omap[i].index);
     }
 
   UNTIL (R_2000)
   {
     dwg->objfreespace.objects_address = dat->byte & UINT32_MAX;
   }
   /* Write the sorted objects
    */
   for (i = 0; i < dwg->num_objects; i++)
     {
       Dwg_Object *obj;
       BITCODE_BL index = omap[i].index;
       BITCODE_UMC hdloff = omap[i].handle - (i ? omap[i - 1].handle : 0);
       BITCODE_MC off = (dat->byte - (i ? omap[i - 1].address : 0)) & INT32_MAX;
       size_t end_address;
       if (!index && !omap[i].handle)
         continue; // skipped objects
       LOG_TRACE ("\n> Next object: " FORMAT_BL " Handleoff: " FORMAT_UMC
                  " [UMC] Offset: " FORMAT_MC " [MC] @%" PRIuSIZE "\n"
                  "==========================================\n",
                  i, hdloff, off, dat->byte);
       omap[i].address = dat->byte;
       if (index > dwg->num_objects)
         {
           LOG_ERROR ("Invalid object map index " FORMAT_BL ", max " FORMAT_BL
                      ". Skipping",
                      index, dwg->num_objects)
           error |= DWG_ERR_VALUEOUTOFBOUNDS;
           continue;
         }
       obj = &dwg->object[index];
       if (obj->type == DWG_TYPE_UNUSED || obj->type == DWG_TYPE_FREED)
         {
           continue;
         }
         // change the address to the linearly sorted one
 #ifndef NDEBUG
       PRE (R_2004)
       assert (dat->byte);
 #endif
       if (!obj->parent)
         obj->parent = dwg;
       error |= dwg_encode_add_object (obj, dat, dat->byte);
 
 #ifndef NDEBUG
       // check if this object overwrote at address 0. but with r2004 it starts
       // fresh.
       if (dwg->header.version >= R_1_2 && dwg->header.version < R_2004)
         {
           if (dat->size < 6 || dat->chain[0] != 'A' || dat->chain[1] != 'C')
             {
               LOG_ERROR ("Encode overwrite pos 0, invalid DWG magic");
               return DWG_ERR_INVALIDDWG;
             }
           assert (dat->size > 6);
           assert (dat->chain[0] == 'A');
           assert (dat->chain[1] == 'C');
         }
 #endif
       end_address = omap[i].address + (size_t)obj->size; // from RL
       if (end_address > dat->size)
         {
           assert (obj->size < DWG_MAX_OBJSIZE);
           dat->size = end_address;
           bit_chain_alloc (dat);
         }
     }
 
   if (DWG_LOGLEVEL >= DWG_LOGLEVEL_HANDLE)
     {
       LOG_HANDLE ("\nSorted objects:\n");
       for (i = 0; i < dwg->num_objects; i++)
         LOG_HANDLE ("Object(%d): " FORMAT_RLLx " / Address: %" PRIuSIZE
                     " / Idx: " FORMAT_BL "\n",
                     i, omap[i].handle, omap[i].address, omap[i].index);
     }
   bit_write_CRC (dat, pvzadr, 0xC0C1);
 
   /*------------------------------------------------------------
    * Object-map
    * split into chunks of max. 2030
    */
   LOG_INFO ("\n=======> Object Map: %4zu\n", dat->byte);
   pvzadr = dat->byte; // Correct value of section size must be written later
   SINCE (R_2004)
   {
     sec_id = SECTION_HANDLES;
     bit_chain_init_dat (&sec_dat[sec_id], (8 * dwg->num_objects) + 32, dat);
     str_dat = hdl_dat = dat = &sec_dat[sec_id];
   }
   else
   {
     sec_id = (Dwg_Section_Type)SECTION_HANDLES_R13;
     dwg->header.section[sec_id].number = 2;
     dwg->header.section[sec_id].address = dat->byte;
     dat->byte += 2;
   }
 
   last_offset = 0;
   last_handle = 0;
   for (i = 0; i < dwg->num_objects; i++)
     {
       BITCODE_BL index;
       BITCODE_UMC handleoff;
       BITCODE_MC offset;
 
       index = omap[i].index;
       if (!index && !omap[i].handle)
         continue; // skipped objects
       handleoff = omap[i].handle - last_handle;
       bit_write_UMC (dat, handleoff);
       LOG_HANDLE ("Handleoff(%3i): " FORMAT_UMC " [UMC] (" FORMAT_RLLx "), ",
                   index, handleoff, omap[i].handle)
       last_handle = omap[i].handle;
 
       offset = (omap[i].address - last_offset) & INT32_MAX;
       bit_write_MC (dat, offset);
       last_offset = omap[i].address;
       LOG_HANDLE ("Offset: " FORMAT_MC " [MC] @%" PRIuSIZE "\n", offset,
                   last_offset);
 
       ckr_missing = 1;
       if (dat->byte - pvzadr > 2030) // 2029
         {
           ckr_missing = 0;
           assert (pvzadr);
 #ifdef ENCODE_PATCH_RSSIZE
           encode_patch_RSsize (dat, pvzadr);
 #else
           sec_size = (dat->byte - pvzadr) & UINT_MAX;
           dat->chain[pvzadr] = sec_size >> 8;
           dat->chain[pvzadr + 1] = sec_size & 0xFF;
           LOG_TRACE ("Handles page size: %u [RS_BE] @%" PRIuSIZE "\n",
                      sec_size, pvzadr);
 #endif
           bit_write_CRC_BE (dat, pvzadr, 0xC0C1);
 
           pvzadr = dat->byte;
           dat->byte += 2;
           last_offset = 0;
           last_handle = 0;
         }
     }
   // printf ("Obj size: %u\n", i);
   if (ckr_missing)
     {
 #ifndef NDEBUG
       PRE (R_2004)
       assert (pvzadr);
 #endif
       if (pvzadr + 1 >= dat->size)
         bit_chain_alloc (dat);
 #ifdef ENCODE_PATCH_RSSIZE
       encode_patch_RSsize (dat, pvzadr);
 #else
       sec_size = (dat->byte - pvzadr) & UINT_MAX;
       dat->chain[pvzadr] = sec_size >> 8;
       dat->chain[pvzadr + 1] = sec_size & 0xFF;
       LOG_TRACE ("Handles page size: %u [RS_BE] @%" PRIuSIZE "\n", sec_size,
                  pvzadr);
 #endif
       bit_write_CRC_BE (dat, pvzadr, 0xC0C1);
     }
 #ifndef NDEBUG
   if (dwg->header.version >= R_1_2 && dwg->header.version < R_2004)
     {
       if (dat->size < 4 || dat->chain[0] != 'A' || dat->chain[1] != 'C')
         {
           LOG_ERROR ("Encode overwrite pos 0");
           return DWG_ERR_INVALIDDWG;
         }
       assert (dat->chain[0] == 'A');
       assert (dat->chain[1] == 'C');
     }
   PRE (R_2004)
   assert (dat->byte);
 #endif
   pvzadr = dat->byte;
   bit_write_RS_BE (dat, 2); // last section_size 2
   LOG_TRACE ("Handles page size: %u [RS_BE] @%" PRIuSIZE "\n", 2, pvzadr);
   bit_write_CRC_BE (dat, pvzadr, 0xC0C1);
 
   /* Calculate and write the size of the object map
    */
   dwg->header.section[sec_id].size
       = (dat->byte - dwg->header.section[sec_id].address) & 0xFFFFFFFF;
   free (omap);
 
   /*------------------------------------------------------------
    * ObjFreeSpace and Second header - r13-r2000 only.
    * Note: partially also since r2004.
    */
   if (dwg->header.version >= R_13 && dwg->header.version < R_2004
       && dwg->header.num_sections >= 3)
     {
       struct _dwg_secondheader *_obj = &dwg->secondheader;
       Dwg_Object *obj = NULL;
 
       assert (dat->byte);
       dwg->header.section[SECTION_OBJFREESPACE_R13].number = 3;
       if (dwg->objfreespace.numnums)
         {
           LOG_INFO ("\n=======> ObjFreeSpace 3 (start): %4u\n",
                     (unsigned)dat->byte);
           dwg->header.section[SECTION_OBJFREESPACE_R13].address = dat->byte;
           dwg->header.section[SECTION_OBJFREESPACE_R13].size = 53;
           error |= encode_objfreespace_private (dat, dwg);
           LOG_INFO ("=======> ObjFreeSpace 3 (end): %4u\n",
                     (unsigned)dat->byte);
         }
 
       LOG_INFO ("\n=======> Second Header: %4zu\n", dat->byte);
       pvzadr = dat->byte;
       LOG_INSANE ("pvzadr: %" PRIuSIZE "\n", pvzadr);
       write_sentinel (dat, DWG_SENTINEL_2NDHEADER_BEGIN);
       dwg->secondheader.address = (BITCODE_RL)pvzadr & UINT32_MAX;
       dwg->r2004_header.secondheader_address = pvzadr;
       if (!_obj->size && !_obj->num_sections)
         {
           const char *code = dwg_version_codes (dwg->header.version);
           LOG_TRACE ("Use secondheader defaults...\n");
           strcpy ((char *)&_obj->version[0], &code[0]);
           memset (&_obj->version[7], 0, 4);
           // TODO detect what it is
           _obj->junk_r14 = UINT64_C (0x989543D074AE8021);
         }
       _obj->is_maint = dwg->header.is_maint;
       _obj->zero_one_or_three = dwg->header.zero_one_or_three;
       _obj->dwg_version
           = (BITCODE_RS)(((BITCODE_RS)dwg->header.maint_version << 8)
                          | dwg->header.dwg_version);
       _obj->codepage = dwg->header.codepage;
       // always recompute sections, even with dwgrewrite
       _obj->num_sections = dwg->header.num_sections;
       for (i = 0; i < MIN (_obj->num_sections, 7U); i++)
         {
           _obj->sections[i].nr = dwg->header.section[i].number;
           _obj->sections[i].address = dwg->header.section[i].address;
           _obj->sections[i].size = dwg->header.section[i].size;
         }
       if (dwg->header.num_sections > SECTION_TEMPLATE_R13
           && !dwg->header.section[SECTION_TEMPLATE_R13].address)
         {
           // most dwg"s leave the 3 and 4 section addresses and sizes empty
           _obj->sections[4].nr = 4;
         }
       // always set handles from the header vars
       if (!_obj->num_handles)
         _obj->num_handles = 14;
 
 #define SET_HDL(i, NAM)                                                       \
   _obj->handles[i].nr = i;                                                    \
   if (dwg->header_vars.NAM                                                    \
       && _obj->handles[i].num_hdl != dwg->header_vars.NAM->handleref.size)    \
     {                                                                         \
       _obj->handles[i].num_hdl = MAX (dwg->header_vars.NAM->handleref.size, 8);\
     }                                                                         \
   if (dwg->header_vars.NAM)                                                   \
     {                                                                         \
       unsigned char chain[8];                                                 \
       Bit_Chain hdat                                                          \
           = { chain, 8L, 0L, 0, 0, R_INVALID, R_INVALID, NULL, 30 };          \
       bit_H_to_dat (&hdat, &dwg->header_vars.NAM->handleref);                 \
       _obj->handles[i].name = #NAM;                                           \
       for (int k = 0; k < MIN ((int)_obj->handles[i].num_hdl, 8); k++)        \
         _obj->handles[i].hdl[k] = hdat.chain[k];                              \
     }
 
       SET_HDL (0, HANDSEED);
       SET_HDL (1, BLOCK_CONTROL_OBJECT);
       SET_HDL (2, LAYER_CONTROL_OBJECT);
       SET_HDL (3, STYLE_CONTROL_OBJECT);
       SET_HDL (4, LTYPE_CONTROL_OBJECT);
       SET_HDL (5, VIEW_CONTROL_OBJECT);
       SET_HDL (6, UCS_CONTROL_OBJECT);
       SET_HDL (7, VPORT_CONTROL_OBJECT);
       SET_HDL (8, APPID_CONTROL_OBJECT);
       SET_HDL (9, DIMSTYLE_CONTROL_OBJECT);
       SET_HDL (10, VX_CONTROL_OBJECT);
       SET_HDL (11, DICTIONARY_NAMED_OBJECT);
       SET_HDL (12, DICTIONARY_ACAD_MLINESTYLE);
       SET_HDL (13, DICTIONARY_ACAD_GROUP);
 
       encode_secondheader_private (dat, dwg);
       dwg->secondheader.size = (BITCODE_RL)(dat->byte - pvzadr) & UINT32_MAX;
       encode_patch_RLsize (dat, pvzadr);
       bit_write_CRC (dat, pvzadr, 0xC0C1);
       VERSIONS (R_14, R_2000) {
         FIELD_RLL (junk_r14, 0);
       }
       write_sentinel (dat, DWG_SENTINEL_2NDHEADER_END);
     }
 
   /*------------------------------------------------------------
    * MEASUREMENT/Template Section 4
    * In a DXF under header_vars
    */
   SINCE (R_2004)
   {
     sec_id = SECTION_TEMPLATE;
     bit_chain_init_dat (&sec_dat[sec_id], 16, dat);
     str_dat = hdl_dat = dat = &sec_dat[sec_id];
   }
   else sec_id = (Dwg_Section_Type)SECTION_TEMPLATE_R13;
 
   if (template_position == after_2ndheader
       && (int)dwg->header.num_sections > (int)sec_id)
     {
       error |= encode_template (dwg, dat, sec_id);
     }
   if (thumbnail_position == after_auxheader)
   {
     error |= encode_r13_thumbnail (dwg, dat, header_crc_address);
   }
 
   /* End of the file
    */
   dat->size = dat->byte;
   SINCE (R_2004)
   {
 #ifdef __cplusplus
     int type;
 #else
     Dwg_Section_Type type;
 #endif
     Dwg_Object *obj = NULL;
     BITCODE_BL vcount, rcount3;
     size_t size;
     unsigned total_size = 0;
 
     // write remaining section data
     for (type = SECTION_OBJFREESPACE; type < SECTION_SYSTEM_MAP; type++)
       {
         if (type != SECTION_OBJECTS && type != SECTION_PREVIEW)
           LOG_TRACE ("\n=== Section %s ===\n", dwg_section_name (dwg, type))
         switch (type)
           {
           case SECTION_HEADER: // ignore, already done
           case SECTION_AUXHEADER:
           case SECTION_CLASSES:
           case SECTION_HANDLES:
           case SECTION_TEMPLATE:
           case SECTION_PREVIEW:
           case SECTION_OBJECTS:
           case SECTION_UNKNOWN: // deferred
           case SECTION_INFO:
           case SECTION_SYSTEM_MAP:
             break;
           case SECTION_OBJFREESPACE:
             {
               bit_chain_alloc (&sec_dat[type]);
               hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
               error |= encode_objfreespace_private (dat, dwg);
               LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte);
             }
             break;
           case SECTION_REVHISTORY:
             {
               Dwg_RevHistory *_obj = &dwg->revhistory;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "revhistory.spec"
               LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte)
             }
             break;
           case SECTION_SUMMARYINFO:
             {
               Dwg_SummaryInfo *_obj = &dwg->summaryinfo;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "summaryinfo.spec"
               LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte)
             }
             break;
           case SECTION_APPINFO:
             {
               Dwg_AppInfo *_obj = &dwg->appinfo;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "appinfo.spec"
               LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte)
             }
             break;
           case SECTION_APPINFOHISTORY:
             {
 #if 0
               Dwg_AppInfoHistory *_obj = &dwg->appinfohistory;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #  include "appinfohistory.spec"
               LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte)
 #endif
             }
             break;
           case SECTION_FILEDEPLIST:
             {
               Dwg_FileDepList *_obj = &dwg->filedeplist;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "filedeplist.spec"
               LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte)
             }
             break;
           case SECTION_SECURITY:
             {
               Dwg_Security *_obj = &dwg->security;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
 #include "security.spec"
               LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte)
             }
             break;
           case SECTION_SIGNATURE:
             {
 #if 0
               Dwg_Signature *_obj = &dwg->signature;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
               {
 #  include "signature.spec"
               }
               LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte)
 #endif
             }
             break;
           case SECTION_ACDS:
             {
 #if 0
               Dwg_AcDs *_obj = &dwg->acds;
               bit_chain_alloc (&sec_dat[type]);
               str_dat = hdl_dat = dat = &sec_dat[type];
               bit_chain_set_version (dat, old_dat);
               {
 #  include "acds.spec"
               }
               LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte)
 #endif
             }
             break;
           case SECTION_VBAPROJECT: // nyi
           default:
             break;
           }
       }
     // and write system and data section maps.
     dat = old_dat;
 
     /*-------------------------------------------------------------------------
      * Section map and info
      */
     // no gaps, so header->numsections == r2004_header->numsections
     // get together all the section sizes, and set the addresses
     {
       int ssize;
       int si, info_id;
       unsigned address;
 
       const Dwg_Section_Type section_map_order[] = {
         // R2004_Header
         SECTION_UNKNOWN, // the empty section 128-256
         SECTION_SECURITY,       SECTION_FILEDEPLIST, SECTION_ACDS,
         SECTION_VBAPROJECT,
         SECTION_APPINFOHISTORY, //? at least before AppInfo
         SECTION_APPINFO,        SECTION_PREVIEW,
         SECTION_SUMMARYINFO, // sometimes this is before Preview
         SECTION_REVHISTORY,     SECTION_OBJECTS,     SECTION_OBJFREESPACE,
         SECTION_TEMPLATE,       SECTION_HANDLES,     SECTION_CLASSES,
         SECTION_AUXHEADER,      SECTION_HEADER,      SECTION_SIGNATURE,
 
         SECTION_INFO,           SECTION_SYSTEM_MAP
       };
 
       // not the order in the system map, but the order in the dat stream.
       const Dwg_Section_Type stream_order[]
           = {                  // R2004_Header
               SECTION_UNKNOWN, // the empty section 128-256
               SECTION_SUMMARYINFO, SECTION_PREVIEW,        SECTION_VBAPROJECT,
               SECTION_APPINFO,     SECTION_APPINFOHISTORY, SECTION_FILEDEPLIST,
               SECTION_ACDS,        SECTION_REVHISTORY,     SECTION_SECURITY,
               SECTION_OBJECTS,     SECTION_OBJFREESPACE,   SECTION_TEMPLATE,
               SECTION_HANDLES,     SECTION_CLASSES,        SECTION_AUXHEADER,
               SECTION_HEADER,      SECTION_SIGNATURE,
 
               SECTION_INFO,        SECTION_SYSTEM_MAP
             };
 
       dwg->r2004_header.numsections = 0;
       dwg->r2004_header.numgaps = 0;
 
       // sec_dat[SECTION_UNKNOWN].byte = 0;
       sec_dat[SECTION_INFO].byte = 10
                                    + (dwg->header.section_infohdr.num_desc
                                       * sizeof (Dwg_Section_Info));
       // only a guess, reserve at least one page
       sec_dat[SECTION_SYSTEM_MAP].byte = (4 * 20 * sizeof (Dwg_Section));
 
       section_address = 0x100;
       // first all the data pages, than a number gap of 1, and last the two
       // system page maps, info and system_map the data_pages (system_map
       // sections) can include multiple pages of the same type.
       LOG_TRACE ("\n=== Section map and info page sizes ===\n");
       for (si = 0, info_id = 0, type = SECTION_UNKNOWN;
            type <= SECTION_SYSTEM_MAP; type++, i++)
         {
           if (sec_dat[type].byte)
             {
               const unsigned int max_decomp_size
                   = section_max_decomp_size (dwg, (Dwg_Section_Type)type);
               const char *name = dwg_section_name (dwg, type);
               Dwg_Section_Info *info;
               if (sec_dat[type].bit)
                 {
                   LOG_WARN ("Unpadded section %d", type);
                   sec_dat[type].byte++;
                 }
               ssize = (int)sec_dat[type].byte;
               sec_dat[type].size = ssize;
               if (info_id >= (int)dwg->header.section_infohdr.num_desc)
                 {
                   dwg->header.section_infohdr.num_desc = info_id + 1;
                   dwg->header.section_info = (Dwg_Section_Info *)realloc (
                       dwg->header.section_info,
                       (info_id + 1) * sizeof (Dwg_Section_Info));
                 }
               info = &dwg->header.section_info[info_id];
               info->fixedtype = (Dwg_Section_Type)type;
               info->type = type;
               info->unknown = 1;
               if (name && si
                   && type < SECTION_INFO) // not UNKNOWN and the last two
                 strcpy (info->name, name);
               else
                 memset (info->name, 0, 64);
               info->size = ssize;
               info->max_decomp_size = max_decomp_size;
               info->encrypted
                   = section_encrypted (dwg, (Dwg_Section_Type)type);
               info->compressed
                   = 1 + section_compressed (dwg, (Dwg_Section_Type)type);
 #ifndef HAVE_COMPRESS_R2004_SECTION
               info->compressed = 1;
 #endif
               // pre-calc numsections for both
               if ((unsigned)ssize <= max_decomp_size)
                 info->num_sections = 1;
               else
                 {
                   info->num_sections = (unsigned)ssize / max_decomp_size;
                   if ((unsigned)ssize % max_decomp_size)
                     info->num_sections++;
                 }
               info->sections = (Dwg_Section **)calloc (info->num_sections,
                                                        sizeof (Dwg_Section *));
               // enough sections?
               if (si + info->num_sections > dwg->header.num_sections)
                 {
                   Dwg_Section *oldsecs = dwg->header.section;
                   dwg->header.num_sections = si + info->num_sections;
                   dwg->header.section = (Dwg_Section *)realloc (
                       dwg->header.section,
                       dwg->header.num_sections * sizeof (Dwg_Section));
                   if (dwg->header.section != oldsecs)
                     // need to rebuild all info->sections
                     section_info_rebuild (dwg, (Dwg_Section_Type)type);
                 }
               {
                 int ssi = 0;
                 do
                   {
                     Dwg_Section *sec = &dwg->header.section[si];
                     total_size += ssize;
                     sec->number = si + 1; // index starting at 1
                     sec->size = MIN (max_decomp_size, (unsigned)ssize);
                     sec->decomp_data_size = sec->size;
                     sec->type = (Dwg_Section_Type)type;
                     sec->compression_type = info->compressed;
                     info->sections[ssi] = sec;
                     LOG_TRACE ("section[%d] %s[%d].sections[%d]: number=%d "
                                "size=%d\n",
                                si, dwg_section_name (dwg, type), info_id, ssi,
                                sec->number, (int)sec->size);
                     ssize -= max_decomp_size;
                     ssi++; // info->sections index
                     si++;  // section index
                   }
                 while (ssize > (int)max_decomp_size); // keep same type
               }
               info_id++;
             }
           else
             LOG_TRACE ("section_info %s is empty, skipped. size=0\n",
                        dwg_section_name (dwg, type));
         }
       dwg->r2004_header.numsections = si;
       // section_info [27] and section_map [28] as two last already added.
       if ((unsigned)si > dwg->header.num_sections) // needed?
         {
           Dwg_Section *oldsecs = dwg->header.section;
           dwg->header.num_sections = si;
           dwg->header.section = (Dwg_Section *)realloc (
               dwg->header.section, si * sizeof (Dwg_Section));
           if (dwg->header.section != oldsecs)
             section_info_rebuild (dwg, SECTION_SYSTEM_MAP);
         }
       dwg->r2004_header.section_info_id
           = dwg->r2004_header.numsections + 1; // a gap of 3
       dwg->r2004_header.section_map_id = dwg->r2004_header.numsections + 2;
       dwg->r2004_header.section_array_size = dwg->r2004_header.numsections + 2;
       dwg->r2004_header.last_section_id = dwg->r2004_header.section_map_id;
       dwg->header.section[si - 2].number = dwg->r2004_header.section_info_id;
       dwg->header.section[si - 1].number = dwg->r2004_header.section_map_id;
 
       LOG_TRACE ("\n=== Section Info %d in map order ===\n",
                  dwg->r2004_header.section_info_id);
       // write into sec_dat[type] first, then compress
       sec_id = SECTION_INFO;
       sec_dat[sec_id].size = sec_dat[sec_id].byte;
       bit_chain_alloc (&sec_dat[sec_id]);
       dat = &sec_dat[sec_id];
       bit_chain_set_version (dat, old_dat);
       bit_set_position (dat, 0); // so far we faked the content. now write it
 
       {
         Dwg_Section_InfoHdr *_obj = &dwg->header.section_infohdr;
         Dwg_Section *sec = &dwg->header.section[si - 2];
         Dwg_Section_Info *info
             = find_section_info_type (dwg, (Dwg_Section_Type)sec_id);
         // index starting at 1
         sec->number = dwg->r2004_header.section_info_id;
         sec->size = MIN (0x7400, sec->size);
         sec->decomp_data_size = sec->size;
         sec->type = (Dwg_Section_Type)type;
         if (info)
           {
             sec->compression_type = info->compressed;
             // very unlikely, more than 1 page
             info->sections[0] = sec;
           }
         if (_obj->compressed == 2 && sec->size <= MIN_COMPRESSED_SECTION)
           _obj->compressed = 1;
 #ifndef HAVE_COMPRESS_R2004_SECTION
         _obj->compressed = 1;
 #endif
         LOG_HANDLE ("InfoHdr @%" PRIuSIZE ".0\n", dat->byte);
         FIELD_RL (num_desc, 0);
         FIELD_RL (compressed, 0);
         FIELD_RL (max_size, 0);
         FIELD_RL (encrypted, 0);
         FIELD_RL (num_desc2, 0);
       }
       for (i = 0; i < ARRAY_SIZE (section_map_order); i++)
         {
           Dwg_Section_Info *_obj;
           type = section_map_order[i];
           _obj = find_section_info_type (dwg, (Dwg_Section_Type)type);
           if (_obj)
             {
               assert (type == _obj->fixedtype);
               LOG_TRACE ("\nSection_Info %s [%d]\n",
                          dwg_section_name (dwg, type), i);
               FIELD_RLLu (size, 0);
               FIELD_RL (num_sections, 0);
               FIELD_RL (max_decomp_size, 0);
               FIELD_RL (unknown, 0);
               FIELD_RL (compressed, 0);
               FIELD_RL (type, 0);
               FIELD_RL (encrypted, 0);
               bit_write_TF (dat, (unsigned char *)_obj->name, 64);
               LOG_TRACE ("name: %s\n", *_obj->name ? _obj->name : "");
             }
         }
 
       LOG_TRACE ("\n=== Section System Map %d in map order ===\n",
                  dwg->r2004_header.section_map_id);
       sec_id = SECTION_SYSTEM_MAP;
       type = SECTION_SYSTEM_MAP;
       {
         // Dwg_Section_InfoHdr *_obj = &dwg->header.section_infohdr;
         Dwg_Section *sec = &dwg->header.section[si - 1];
         Dwg_Section_Info *info
             = find_section_info_type (dwg, (Dwg_Section_Type)type);
         if (!info || !info->sections)
           {
             LOG_ERROR ("SECTION_SYSTEM_MAP not found");
             return DWG_ERR_SECTIONNOTFOUND;
           }
 
         sec_dat[sec_id].size = sec_dat[sec_id].byte;
         bit_chain_alloc (&sec_dat[sec_id]);
         str_dat = hdl_dat = dat = &sec_dat[sec_id];
         bit_chain_set_version (dat, old_dat);
         bit_set_position (dat, 0); // so far we faked the content. now write it
 
         // index starting at 1
         sec->number = dwg->r2004_header.section_map_id;
         sec->size = MIN (0x7400, sec->size);
         sec->decomp_data_size = sec->size;
         sec->type = (Dwg_Section_Type)type;
         sec->compression_type = info->compressed;
         // very unlikely, more than 1 page
         info->sections[0] = sec;
       }
 
       address = 0x100;
       for (i = 0; i < dwg->header.num_sections; i++)
         {
           Dwg_Section *_obj = &dwg->header.section[i];
 
           FIELD_RL (number, 0);
           FIELD_RL (size, 0);
           _obj->address = address;
           FIELD_RLL (address, 0);
           address += _obj->size;
           if (_obj->number > INT32_MAX) // gap. unused. we deleted all gaps
             {
               FIELD_RL (parent, 0);
               FIELD_RL (left, 0);
               FIELD_RL (right, 0);
               FIELD_RL (x00, 0);
             }
         }
       dwg->r2004_header.decomp_data_size
           = dat->byte & 0xFFFFFFFF; // system_map_size
       LOG_TRACE ("-size: %" PRIuSIZE "\n", dat->byte);
 
       dat = old_dat;
 #ifndef NDEBUG
       if (dwg->header.version >= R_1_2)
         {
           if (dat->size < 4 || dat->chain[0] != 'A' || dat->chain[1] != 'C')
             {
               LOG_ERROR ("Encode overwrite pos 0");
               return DWG_ERR_INVALIDDWG;
             }
           assert (dat->chain[0] == 'A');
           assert (dat->chain[1] == 'C');
           PRE (R_2004)
           assert (dat->byte <= 0x100);
           LATER_VERSIONS
           assert (dat->byte <= 0x140);
         }
 #endif
 
       // now write all the sections in the stream order
       LOG_TRACE ("\n=== Write sections in stream order ===\n");
       size = total_size
              + (8 * ((dwg->r2004_header.numsections + 2) * 24)); // no gaps
       dat->byte = section_address;
       if (dat->byte + size >= dat->size)
         {
           dat->size = dat->byte + size;
           bit_chain_alloc (dat);
         }
       LOG_HANDLE ("@%" PRIuSIZE ".0\n", dat->byte);
       for (i = 0; i < ARRAY_SIZE (stream_order); i++)
         {
           Dwg_Section_Info *info;
           type = stream_order[i];
           info = find_section_info_type (dwg, (Dwg_Section_Type)type);
           if (info)
             {
               LOG_TRACE ("Write %s pages @%" PRIuSIZE " (%u/%" PRIuSIZE ")\n",
                          dwg_section_name (dwg, type), dat->byte,
                          info->num_sections, sec_dat[type].size);
               for (unsigned k = 0; k < info->num_sections; k++)
                 {
                   Dwg_Section *sec = info->sections[k];
                   if (!sec)
                     {
                       LOG_ERROR ("empty info->sections[%u]", k);
                       continue;
                     }
                   if (!sec_dat[type].chain)
                     {
                       LOG_ERROR ("empty %s.chain",
                                  dwg_section_name (dwg, type));
                       continue;
                     }
 #ifndef NDEBUG
                   if (info->fixedtype < SECTION_INFO)
                     assert (info->fixedtype == sec->type);
 #endif
                   if (info->fixedtype == SECTION_SUMMARYINFO)
                     dwg->header.summaryinfo_address = dat->byte & 0xFFFFFFFF;
                   else if (info->fixedtype == SECTION_PREVIEW)
                     dwg->header.thumbnail_address = dat->byte & 0xFFFFFFFF;
                   else if (info->fixedtype == SECTION_VBAPROJECT)
                     dwg->header.vbaproj_address = dat->byte & 0xFFFFFFFF;
                   else if (info->fixedtype == SECTION_SYSTEM_MAP)
                     {
                       dwg->r2004_header.section_map_address
                           = dat->byte - 0x100;
                       dwg->r2004_header.last_section_address
                           = dat->byte + sec->size - 0x100;
                       dwg->r2004_header.secondheader_address = 0; // TODO
                     }
                   sec->address = dat->byte;
 
                   if (info->encrypted)
                     {
                       BITCODE_RC *decr = (BITCODE_RC *)calloc (sec->size, 1);
                       LOG_HANDLE ("Encrypt %s (%u/%d)\n", info->name, k,
                                   sec->size);
                       decrypt_R2004_header (decr, sec_dat[type].chain,
                                             sec->size);
                       free (sec_dat[type].chain);
                       sec_dat[type].chain = decr;
                     }
                   assert (sec->size <= MIN_COMPRESSED_SECTION
                               ? info->compressed == 1
                               : 1);
                   if (info->compressed == 2)
                     {
                       LOG_HANDLE ("Compress %s (%u/%d)\n", info->name, k,
                                   sec->size);
                       compress_R2004_section (dat, sec_dat[type].chain,
                                               sec->size, &sec->comp_data_size);
                       LOG_TRACE ("sec->comp_data_size: " FORMAT_RL "\n",
                                  sec->comp_data_size);
                     }
                   else
                     {
                       LOG_HANDLE ("Copy uncompressed %s (%u/%d)\n", info->name,
                                   k, sec->size);
                       copy_R2004_section (dat, sec_dat[type].chain, sec->size,
                                           &sec->comp_data_size);
                     }
                 }
             }
           bit_chain_free (&sec_dat[type]);
         }
     }
 
     {
       Dwg_R2004_Header *_obj = &dwg->r2004_header;
       Bit_Chain file_dat = {
         NULL, sizeof (Dwg_R2004_Header), 0UL, 0, 0, R_INVALID, R_INVALID, NULL,
         30
       };
       Bit_Chain *orig_dat = dat;
       /* "AcFssFcAJMB" encrypted: 6840F8F7922AB5EF18DD0BF1 */
       const char enc_file_ID_string[]
           = "\x68\x40\xF8\xF7\x92\x2A\xB5\xEF\x18\xDD\x0B\xF1";
       uint32_t checksum;
 
       file_dat.chain = (unsigned char *)calloc (1, sizeof (Dwg_R2004_Header));
       dat = &file_dat;
       LOG_TRACE ("\nSection R2004_Header @0x100\n");
       memcpy (_obj->file_ID_string, "AcFssFcAJMB", 12);
 
       checksum = _obj->crc32;
       LOG_HANDLE ("old crc32: 0x%x\n", _obj->crc32);
       _obj->crc32 = 0;
       // recalc the CRC32, without the padding, but the crc32 as 0
       _obj->crc32
           = bit_calc_CRC32 (0, (unsigned char *)&dwg->r2004_header, 0x6c);
       LOG_HANDLE ("calc crc32: 0x%x\n", _obj->crc32);
 
       // clang-format off
       #include "r2004_file_header.spec"
       // clang-format on
 
       // go back and encrypt it
       dat = orig_dat;
       decrypt_R2004_header (&dat->chain[0x80], file_dat.chain,
                             sizeof (Dwg_R2004_Header));
       bit_chain_free (&file_dat);
       LOG_HANDLE ("encrypted R2004_Header:\n");
       LOG_TF (HANDLE, &dat->chain[0x80], (int)sizeof (Dwg_R2004_Header));
       if (memcmp (&dat->chain[0x80], enc_file_ID_string,
                   sizeof (enc_file_ID_string) - 1))
         {
           LOG_ERROR ("r2004_file_header encryption error");
           return error | DWG_ERR_INVALIDDWG;
         }
     } // R2004_Header
   }   // R_2004
 
   assert (!dat->bit);
   dat->size = dat->byte;
   LOG_INFO ("\nFinal DWG size: %u\n", (unsigned)dat->size);
 
   UNTIL (R_2000)
   {
     /* Patch section addresses
      */
     assert (section_address);
     dat->byte = section_address;
     dat->bit = 0;
     LOG_INFO ("\n=======> section addresses: %4zu\n", dat->byte);
     for (j = 0; j < dwg->header.num_sections; j++)
       {
         LOG_TRACE ("section[%u].number: %4d [RC] %s\n", j,
                    (int)dwg->header.section[j].number,
                    j < 6 ? dwg_section_name (dwg, j) : "");
         LOG_TRACE ("section[%u].offset: %4lu [RL]\n", j,
                    (unsigned long)dwg->header.section[j].address);
         LOG_TRACE ("section[%u].size:   %4lu [RL]\n", j,
                    (unsigned long)dwg->header.section[j].size);
         if ((size_t)dwg->header.section[j].address
                 + dwg->header.section[j].size
             > dat->size)
           {
             if (is_section_r13_critical ((Dwg_Section_Type_r13)j))
               {
                 LOG_ERROR ("section[%u] %s address or size overflow", j,
                            j < 6 ? dwg_section_name (dwg, j) : "");
                 return DWG_ERR_INVALIDDWG;
               }
             else
               {
                 LOG_WARN ("section[%u] %s address or size overflow, skipped",
                           j, j < 6 ? dwg_section_name (dwg, j) : "");
                 dwg->header.section[j].address = 0;
                 dwg->header.section[j].size = 0;
               }
           }
         bit_write_RC (dat, dwg->header.section[j].number);
         bit_write_RL (dat, dwg->header.section[j].address);
         bit_write_RL (dat, dwg->header.section[j].size);
       }
 
     /* Write CRC's
      */
     bit_write_CRC (dat, 0, 0);
     dat->byte -= 2;
     ckr = bit_read_CRC (dat);
     dat->byte -= 2;
     // FIXME: r13-2000 only
     switch (dwg->header.sections)
       {
       case 3:
         ckr ^= 0xA598;
         break;
       case 4:
         ckr ^= 0x8101;
         break;
       case 5:
         ckr ^= 0x3CC4;
         break;
       case 6:
         ckr ^= 0x8461;
         break;
       default:
         break;
       }
     bit_write_RS (dat, ckr);
     LOG_TRACE ("crc: %04X (from 0)\n", ckr);
   }
 
   return 0;
 }
 // clang-format off
diff --git a/src/header.spec b/src/header.spec
index 4c60eec4..3f05e4d9 100644
--- a/src/header.spec
+++ b/src/header.spec
@@ -1,101 +1,93 @@
 /* -*- c -*- */
 /*****************************************************************************/
 /*  LibreDWG - free implementation of the DWG file format                    */
 /*                                                                           */
 /*  Copyright (C) 2018 Free Software Foundation, Inc.                        */
 /*                                                                           */
 /*  This library is free software, licensed under the terms of the GNU       */
 /*  General Public License as published by the Free Software Foundation,     */
 /*  either version 3 of the License, or (at your option) any later version.  */
 /*  You should have received a copy of the GNU General Public License        */
 /*  along with this program.  If not, see <http://www.gnu.org/licenses/>.    */
 /*****************************************************************************/
 
 /*
  * header.spec: DWG file header specification
  * written by Reini Urban
  */
 
 #include "spec.h"
 
-// char version[6] handled separately. older releases just had a version[12]
-#ifdef IS_JSON
-  KEY (zero_5);
-  fprintf (dat->fh, "[ %d, %d, %d, %d, %d ]",
-          _obj->zero_5[0], _obj->zero_5[1], _obj->zero_5[2], _obj->zero_5[3],
-          _obj->zero_5[4]);
-#else
-  FIELD_VECTOR_INL (zero_5, RC, 5, 0)
-#endif
+  // char version[11] handled separately
   FIELD_RC (is_maint, 0);
 
   VERSIONS (R_2_0b, R_13b1) {
     FIELD_RC (zero_one_or_three, 0); // 1,3,0,5,0,0x00cd,0
     /*
        AC1.50: 3, 5, 74; 3, 5, 83;
        AC2.10: 3, 5, 83
        AC1001: 3, 5, 101
        AC1002: 3, 5, 104; 3, 5, 114
        AC1003: 3, 5, 120; 3, 5, 122
        AC1004: 3, 5, 129
        AC1006: 3, 5, 158; 3, 5, 160
        AC1009: 3, 5, 204; 3, 5, 205
      */
     FIELD_RS (numentity_sections, 0); // 3
     FIELD_CAST (sections, RS, RL, 0); // 5 or 6. the real size is num_sections
     FIELD_RS (numheader_vars, 0); // 74,83,101,104,114,120,122,129,158,160,204,205
     FIELD_RC (dwg_version, 0); // 0
 
     // The 3 entitity data sections
     FIELD_RLx (entities_start, 0);
     FIELD_RLx (entities_end, 0);
     FIELD_RLx (blocks_start, 0);
     FIELD_RLx (blocks_size, 0);
     FIELD_RLx (extras_start, 0);
     FIELD_RLx (extras_size, 0);
   }
   SINCE (R_13b1) {
     FIELD_RC (zero_one_or_three, 0);
     FIELD_RL (thumbnail_address, 0); //@0x0d
     FIELD_RC (dwg_version, 0); // of app which stored it. eg. SaveAs
     FIELD_RC (maint_version, 0);
     ENCODER {
        if (!FIELD_VALUE (codepage))
          FIELD_VALUE (codepage) = dat->codepage;
     }
     FIELD_RS (codepage, 0); //@0x13: 29/30 for ANSI_1252, since r2007 UCS-16
     LOG_TRACE ("%s\n", dwg_codepage_dxfstr ((Dwg_Codepage)FIELD_VALUE (codepage)))
     DECODER {
       dat->codepage = FIELD_VALUE (codepage);
     }
   }
 
   /* Until R_2004 here follows the sections */
   SINCE (R_2004) {
     IF_ENCODE_FROM_EARLIER {
       FIELD_VALUE (app_dwg_version) = FIELD_VALUE (dwg_version);
       FIELD_VALUE (app_maint_version) = FIELD_VALUE (maint_version);
       FIELD_VALUE (r2004_header_address) = 0x80;
     }
     FIELD_RC (unknown_0, 0);
     FIELD_RC (app_dwg_version, 0);
     FIELD_RC (app_maint_version, 0);
     FIELD_RL (security_type, 0); /* 0x0001 = encrypt data (for all sections but
 				             AcDb:Preview and AcDb:SummaryInfo)
 				    0x0002 = encrypt properties (for AcDb:Preview
 				             and AcDb:SummaryInfo)
 				    0x0010 = sign data
 				    0x0020 = add timestamp */
     FIELD_RL (rl_1c_address, 0); /* mostly 0, probably some unused section */
     FIELD_RL (summaryinfo_address, 0);
     FIELD_RL (vbaproj_address, 0);
     FIELD_RL (r2004_header_address, 0); /* mostly 128/0x80 */
     ENCODER {
       for (i = 0; i < 54; i++)
         bit_write_RC (dat, 0);
     }
     else {
       dat->byte += 54; // empty slack
     }
     /* at 0x80 follows the encrypted r2004_header */
   }
diff --git a/src/in_json.c b/src/in_json.c
index 530feb24..8ea1d677 100644
--- a/src/in_json.c
+++ b/src/in_json.c
@@ -1035,111 +1035,102 @@ static int
 json_FILEHEADER (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
                  jsmntokens_t *restrict tokens)
 {
   const char *section = "FILEHEADER";
   const jsmntok_t *t = &tokens->tokens[tokens->index];
   Dwg_Header *_obj = &dwg->header;
   Dwg_Object *obj = NULL;
   char version[80];
   int size = t->size;
 
   if (t->type != JSMN_OBJECT)
     {
       LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s OBJECT",
                  t_typename[t->type], tokens->index, tokens->num_tokens,
                  section);
       json_advance_unknown (dat, tokens, t->type, 0);
       return DWG_ERR_INVALIDTYPE;
     }
   LOG_TRACE ("\n%s pos:%d [%d keys]\n--------------------\n", section,
              tokens->index, t->size);
   tokens->index++;
   JSON_TOKENS_CHECK_OVERFLOW_ERR
   // t = &tokens->tokens[tokens->index];
   // json_expect(tokens, STRING);
   // FIELD_TV (version, 0);
   for (int i = 0; i < size; i++)
     {
       char key[80];
       json_fixed_key (key, dat, tokens);
       JSON_TOKENS_CHECK_OVERFLOW_ERR
       t = &tokens->tokens[tokens->index];
       if (strEQc (key, "version"))
         {
           version[0] = '\0';
           json_fixed_key (version, dat, tokens);
           dat->from_version = dwg->header.from_version
               = dwg_version_hdr_type (version);
           // is_tu = dat->from_version >= R_2007;
           LOG_TRACE ("FILEHEADER.from_version = %s (%s)\n", version,
                      dwg_version_type (dat->from_version));
           if (dat->from_version == R_INVALID)
             {
               LOG_ERROR ("Invalid FILEHEADER.version %s", version);
               return DWG_ERR_INVALIDDWG;
             }
         }
-      // FIELD_VECTOR_INL (zero_5, RL, 5, 0)
-      else if (strEQc (key, "zero_5") && t->type == JSMN_ARRAY)
-        {
-          tokens->index++;
-          for (int j = 0; j < MIN (5, t->size); j++)
-            {
-              _obj->zero_5[j] = json_long (dat, tokens);
-            }
-        }
       // clang-format off
       FIELD_RC (is_maint, 0)
       FIELD_RC (zero_one_or_three, 0)
       // preR13 only
       FIELD_RS (numentity_sections, 0)
       FIELD_RL (sections, 0)
       FIELD_RS (numheader_vars, 0)
       FIELD_RLx (entities_start, 0)
       FIELD_RLx (entities_end, 0)
       FIELD_RLx (blocks_start, 0)
       FIELD_RLx (blocks_size, 0)
       FIELD_RLx (extras_start, 0)
       FIELD_RLx (extras_size, 0)
 
       FIELD_RLx (thumbnail_address, 0) //@0x0d
       FIELD_RC (dwg_version, 0)
       FIELD_RC (maint_version, 0)
       FIELD_RS (codepage, 0) //@0x13: 29/30 for ANSI_1252, since r2007 UTF-16
       // SINCE (R_2004)
       FIELD_RC (unknown_0, 0)
       FIELD_RC (app_dwg_version, 0)
       FIELD_RC (app_maint_version, 0)
       FIELD_RL (security_type, 0)
       FIELD_RL (rl_1c_address, 0) /* mostly 0 */
       FIELD_RL (summaryinfo_address, 0)
       FIELD_RL (vbaproj_address, 0)
       FIELD_RL (r2004_header_address, 0) /* mostly 128/0x80 */
           // clang-format on
 
           else if (strEQc (key, "HEADER"))
       {
         LOG_WARN ("Unexpected next section %s", key)
         tokens->index--;
         tokens->index--;
         return 0;
       }
       else
       {
         LOG_ERROR ("Unknown %s.%s ignored", section, key);
         tokens->index++;
       }
     }
   LOG_TRACE ("End of %s\n", section)
   // revised beta version
   {
     Dwg_Version_Type v = dwg_version_hdr_type2 (version, _obj->dwg_version);
     if (v != R_INVALID && v != dwg->header.from_version)
       {
         dat->from_version = dwg->header.from_version = v;
         LOG_TRACE ("FILEHEADER.from_version = %s (%s) via dwg_version\n",
                    version, dwg_version_type (v));
       }
   }
   tokens->index--;
   return 0;
 }
