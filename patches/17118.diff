commit 054b285ddb4a8542e6862ca7d39633e96c67e61d
Author: tbeu <tbeu@users.noreply.github.com>
Date:   Sun Jan 3 15:07:48 2021 +0100

    Fix illegal memory access
    
    As reported by https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=27267

diff --git a/src/mat.c b/src/mat.c
index 3f5bf67..0bf6695 100644
--- a/src/mat.c
+++ b/src/mat.c
@@ -289,58 +289,59 @@ int Mul(size_t* res, size_t a, size_t b)
 /** @brief Adds two unsigned integers
  *
  * @param res Result
  * @param a First operand
  * @param b Second operand
  * @retval 0 on success
  */
 int Add(size_t* res, size_t a, size_t b)
 {
     if ( !psnip_safe_size_add(res, a, b) ) {
         *res = 0;
         return MATIO_E_INDEX_TOO_BIG;
     }
 
     return MATIO_E_NO_ERROR;
 }
 
 /** @brief Read from file and check success
  *
  * @param buf Buffer for reading
  * @param size Element size in bytes
  * @param count Element count
  * @param fp File pointer
  * @param[out] bytesread Number of bytes read from the file
+ * @param acceptEOF Flag for valid read beyond EOF
  * @retval 0 on success
  */
 int
-Read(void* buf, size_t size, size_t count, FILE* fp, size_t* bytesread) {
+Read(void* buf, size_t size, size_t count, FILE* fp, size_t* bytesread, int acceptEOF) {
     const size_t readcount = fread(buf, size, count, fp);
     int err = readcount != count;
     if ( NULL != bytesread ) {
         *bytesread += readcount*size;
     }
-    if ( err && feof(fp) && 0 == readcount) {
+    if ( acceptEOF && err && feof(fp) && 0 == readcount) {
         err = MATIO_E_NO_ERROR;
     }
     if ( err ) {
         Mat_Warning("Unexpected end-of-file: Read %zu"
             " bytes, expected %zu"
             " bytes", readcount*size, count*size);
         memset(buf, 0, count*size);
     }
     return err;
 }
 
 /*
  *===================================================================
  *                 Public Functions
  *===================================================================
  */
 
 /** @brief Get the version of the library
  *
  * Gets the version number of the library
  * @param major Pointer to store the library major version number
  * @param minor Pointer to store the library minor version number
  * @param release Pointer to store the library release version number
  */
diff --git a/src/mat4.c b/src/mat4.c
index c09c525..de5a15e 100644
--- a/src/mat4.c
+++ b/src/mat4.c
@@ -909,176 +909,176 @@ matvar_t *
 Mat_VarReadNextInfo4(mat_t *mat)
 {
     int       M,O,data_type,class_type;
     mat_int32_t tmp;
     long      nBytes;
     matvar_t *matvar = NULL;
     union {
         mat_uint32_t u;
         mat_uint8_t  c[4];
     } endian;
 
     if ( mat == NULL || mat->fp == NULL )
         return NULL;
 
     {
         size_t nbytes = 0;
-        int err = Read(&tmp, sizeof(mat_int32_t), 1, (FILE*)mat->fp, &nbytes);
+        int err = Read(&tmp, sizeof(mat_int32_t), 1, (FILE*)mat->fp, &nbytes, READ_ACCEPT_EOF);
         if ( err || 0 == nbytes )
             return NULL;
     }
 
     endian.u = 0x01020304;
 
     /* See if MOPT may need byteswapping */
     if ( tmp < 0 || tmp > 4052 ) {
         if ( Mat_int32Swap(&tmp) > 4052 ) {
             return NULL;
         }
     }
 
     M = (int)floor(tmp / 1000.0);
     switch ( M ) {
         case 0:
             /* IEEE little endian */
             mat->byteswap = endian.c[0] != 4;
             break;
         case 1:
             /* IEEE big endian */
             mat->byteswap = endian.c[0] != 1;
             break;
         default:
             /* VAX, Cray, or bogus */
             return NULL;
     }
 
     tmp -= M*1000;
     O = (int)floor(tmp / 100.0);
     /* O must be zero */
     if ( 0 != O ) {
         return NULL;
     }
 
     if ( NULL == (matvar = Mat_VarCalloc()) )
         return NULL;
 
     tmp -= O*100;
     data_type = (int)floor(tmp / 10.0);
     /* Convert the V4 data type */
     switch ( data_type ) {
         case 0:
             matvar->data_type = MAT_T_DOUBLE;
             break;
         case 1:
             matvar->data_type = MAT_T_SINGLE;
             break;
         case 2:
             matvar->data_type = MAT_T_INT32;
             break;
         case 3:
             matvar->data_type = MAT_T_INT16;
             break;
         case 4:
             matvar->data_type = MAT_T_UINT16;
             break;
         case 5:
             matvar->data_type = MAT_T_UINT8;
             break;
         default:
             Mat_VarFree(matvar);
             return NULL;
     }
 
     tmp -= data_type*10;
     class_type = (int)floor(tmp / 1.0);
     switch ( class_type ) {
         case 0:
             matvar->class_type = MAT_C_DOUBLE;
             break;
         case 1:
             matvar->class_type = MAT_C_CHAR;
             break;
         case 2:
             matvar->class_type = MAT_C_SPARSE;
             break;
         default:
             Mat_VarFree(matvar);
             return NULL;
     }
 
     matvar->rank = 2;
     matvar->dims = (size_t*)calloc(2, sizeof(*matvar->dims));
     if ( NULL == matvar->dims ) {
         Mat_VarFree(matvar);
         return NULL;
     }
-    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL) ) {
+    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL, READ_STRICT) ) {
         Mat_VarFree(matvar);
         return NULL;
     }
     if ( mat->byteswap )
         Mat_int32Swap(&tmp);
     matvar->dims[0] = tmp;
 
-    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL) ) {
+    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL, READ_STRICT) ) {
         Mat_VarFree(matvar);
         return NULL;
     }
     if ( mat->byteswap )
         Mat_int32Swap(&tmp);
     matvar->dims[1] = tmp;
 
-    if ( 0 != Read(&(matvar->isComplex), sizeof(int), 1, (FILE*)mat->fp, NULL) ) {
+    if ( 0 != Read(&(matvar->isComplex), sizeof(int), 1, (FILE*)mat->fp, NULL, READ_STRICT) ) {
         Mat_VarFree(matvar);
         return NULL;
     }
     if ( matvar->isComplex && MAT_C_CHAR == matvar->class_type ) {
         Mat_VarFree(matvar);
         return NULL;
     }
-    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL) ) {
+    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL, READ_STRICT) ) {
         Mat_VarFree(matvar);
         return NULL;
     }
     if ( mat->byteswap )
         Mat_int32Swap(&tmp);
     /* Check that the length of the variable name is at least 1 */
     if ( tmp < 1 ) {
         Mat_VarFree(matvar);
         return NULL;
     }
     matvar->name = (char*)malloc(tmp);
     if ( NULL == matvar->name ) {
         Mat_VarFree(matvar);
         return NULL;
     }
-    if ( 0 != Read(matvar->name, sizeof(char), tmp, (FILE*)mat->fp, NULL) ) {
+    if ( 0 != Read(matvar->name, sizeof(char), tmp, (FILE*)mat->fp, NULL, READ_STRICT) ) {
         Mat_VarFree(matvar);
         return NULL;
     } else {
         matvar->name[tmp - 1] = '\0';
     }
 
     matvar->internal->datapos = ftell((FILE*)mat->fp);
     if ( matvar->internal->datapos == -1L ) {
         Mat_VarFree(matvar);
         Mat_Critical("Couldn't determine file position");
         return NULL;
     }
     {
         int err;
         size_t tmp2 = Mat_SizeOf(matvar->data_type);
         if ( matvar->isComplex )
             tmp2 *= 2;
         err = Mat_MulDims(matvar, &tmp2);
         if ( err ) {
             Mat_VarFree(matvar);
             Mat_Critical("Integer multiplication overflow");
             return NULL;
         }
 
         nBytes = (long)tmp2;
     }
     (void)fseek((FILE*)mat->fp,nBytes,SEEK_CUR);
 
     return matvar;
 }
diff --git a/src/mat5.c b/src/mat5.c
index d29f9f0..d39f714 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -478,91 +478,91 @@ static size_t
 ReadSparse(mat_t *mat, matvar_t *matvar, mat_uint32_t *n, mat_uint32_t **v)
 {
     int data_in_tag = 0;
     enum matio_types packed_type;
     mat_uint32_t tag[2];
     size_t bytesread = 0;
     mat_uint32_t N = 0;
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
         matvar->internal->z->avail_in = 0;
         if ( 0 != Inflate(mat, matvar->internal->z, tag, 4, &bytesread) ) {
             return bytesread;
         }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             N = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
             (void)ReadCompressedUInt32Data(mat,matvar->internal->z,
                         &N,MAT_T_UINT32,1);
         }
 #endif
     } else {
-        if ( 0 != Read(tag, 4, 1, (FILE*)mat->fp, &bytesread) ) {
+        if ( 0 != Read(tag, 4, 1, (FILE*)mat->fp, &bytesread, READ_STRICT) ) {
             return bytesread;
         }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             N = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
-            if ( 0 != Read(&N, 4, 1, (FILE*)mat->fp, &bytesread) ) {
+            if ( 0 != Read(&N, 4, 1, (FILE*)mat->fp, &bytesread, READ_STRICT) ) {
                 return bytesread;
             }
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(&N);
         }
     }
     if ( 0 == N )
         return bytesread;
     *n = N / 4;
     *v = (mat_uint32_t*)calloc(N, 1);
     if ( NULL != *v ) {
         int nBytes;
         if ( matvar->compression == MAT_COMPRESSION_NONE ) {
             nBytes = ReadUInt32Data(mat,*v,packed_type,*n);
             /*
                 * If the data was in the tag we started on a 4-byte
                 * boundary so add 4 to make it an 8-byte
                 */
             nBytes *= Mat_SizeOf(packed_type);
             if ( data_in_tag )
                 nBytes+=4;
             if ( (nBytes % 8) != 0 )
                 (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
         } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                             *v,packed_type,*n);
             /*
                 * If the data was in the tag we started on a 4-byte
                 * boundary so add 4 to make it an 8-byte
                 */
             if ( data_in_tag )
                 nBytes+=4;
             if ( (nBytes % 8) != 0 )
                 InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif
         }
     } else {
         Mat_Critical("Couldn't allocate memory");
     }
 
     return bytesread;
 }
 
 #if HAVE_ZLIB
 /** @brief determines the number of bytes needed to store the given variable
  *
  * @ingroup mat_internal
  * @param matvar MAT variable
  * @param size the number of bytes needed to store the variable
  * @return 0 on success
  */
@@ -976,383 +976,383 @@ static size_t
 ReadNextCell( mat_t *mat, matvar_t *matvar )
 {
     size_t bytesread = 0, i;
     int err;
     matvar_t **cells = NULL;
     size_t nelems = 1;
 
     err = Mat_MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return bytesread;
     }
     matvar->data_size = sizeof(matvar_t *);
     err = Mul(&matvar->nbytes, nelems, matvar->data_size);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return bytesread;
     }
 
     matvar->data = calloc(nelems, matvar->data_size);
     if ( NULL == matvar->data ) {
         if ( NULL != matvar->name )
             Mat_Critical("Couldn't allocate memory for %s->data", matvar->name);
         return bytesread;
     }
     cells = (matvar_t **)matvar->data;
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
         mat_uint32_t uncomp_buf[16] = {0,};
         mat_uint32_t nBytes;
         mat_uint32_t array_flags;
 
         for ( i = 0; i < nelems; i++ ) {
             cells[i] = Mat_VarCalloc();
             if ( NULL == cells[i] ) {
                 Mat_Critical("Couldn't allocate memory for cell %zu", i);
                 continue;
             }
 
             /* Read variable tag for cell */
             uncomp_buf[0] = 0;
             uncomp_buf[1] = 0;
             err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
             if ( err ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
             }
             nBytes = uncomp_buf[1];
             if ( 0 == nBytes ) {
                 /* Empty cell: Memory optimization */
                 free(cells[i]->internal);
                 cells[i]->internal = NULL;
                 continue;
             } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 Mat_Critical("cells[%zu], Uncompressed type not MAT_T_MATRIX", i);
                 break;
             }
             cells[i]->compression = MAT_COMPRESSION_ZLIB;
             err = Inflate(mat, matvar->internal->z, uncomp_buf, 16, &bytesread);
             if ( err ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 break;
             }
             nBytes -= 16;
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
                 (void)Mat_uint32Swap(uncomp_buf+2);
                 (void)Mat_uint32Swap(uncomp_buf+3);
             }
             /* Array Flags */
             if ( uncomp_buf[0] == MAT_T_UINT32 ) {
                 array_flags = uncomp_buf[2];
                 cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                 cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
                 cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
                 cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                 if ( cells[i]->class_type == MAT_C_SPARSE ) {
                     /* Need to find a more appropriate place to store nzmax */
                     cells[i]->nbytes = uncomp_buf[3];
                 }
             } else {
                 Mat_Critical("Expected MAT_T_UINT32 for array tags, got %d", uncomp_buf[0]);
                 InflateSkip(mat, matvar->internal->z, nBytes, &bytesread);
             }
             if ( cells[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
                 err = InflateRankDims(mat, matvar->internal->z, uncomp_buf, sizeof(uncomp_buf), &dims, &bytesread);
                 if ( NULL == dims ) {
                     dims = uncomp_buf + 2;
                 } else {
                     do_clean = 1;
                 }
                 if ( err ) {
                     if ( do_clean ) {
                         free(dims);
                     }
                     Mat_VarFree(cells[i]);
                     cells[i] = NULL;
                     break;
                 }
                 nBytes -= 8;
                 if ( mat->byteswap ) {
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
                 /* Rank and Dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
                     size_t size;
                     cells[i]->rank = uncomp_buf[1];
                     nBytes -= cells[i]->rank;
                     cells[i]->rank /= 4;
                     if ( 0 == do_clean && cells[i]->rank > 13 ) {
                         int rank = cells[i]->rank;
                         cells[i]->rank = 0;
                         Mat_Critical("%d is not a valid rank", rank);
                         continue;
                     }
                     err = Mul(&size, cells[i]->rank, sizeof(*cells[i]->dims));
                     if ( err ) {
                         if ( do_clean ) {
                             free(dims);
                         }
                         Mat_VarFree(cells[i]);
                         cells[i] = NULL;
                         Mat_Critical("Integer multiplication overflow");
                         continue;
                     }
                     cells[i]->dims = (size_t*)malloc(size);
                     if ( mat->byteswap ) {
                         for ( j = 0; j < cells[i]->rank; j++ )
                             cells[i]->dims[j] = Mat_uint32Swap(dims + j);
                     } else {
                         for ( j = 0; j < cells[i]->rank; j++ )
                             cells[i]->dims[j] = dims[j];
                     }
                     if ( cells[i]->rank % 2 != 0 )
                         nBytes -= 4;
                 }
                 if ( do_clean ){
                     free(dims);
                 }
                 /* Variable name tag */
                 err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
                 if ( err ) {
                     Mat_VarFree(cells[i]);
                     cells[i] = NULL;
                     break;
                 }
                 nBytes -= 8;
                 if ( mat->byteswap ) {
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
                 /* Handle cell elements written with a variable name */
                 if ( uncomp_buf[1] > 0 ) {
                     /* Name of variable */
                     if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
                         mat_uint32_t len = uncomp_buf[1];
 
                         if ( len % 8 > 0 ) {
                             if ( len < UINT32_MAX - 8 + (len % 8) )
                               len = len + 8 - (len % 8);
                             else {
                                 Mat_VarFree(cells[i]);
                                 cells[i] = NULL;
                                 break;
                             }
                         }
                         cells[i]->name = (char*)malloc(len + 1);
                         nBytes -= len;
                         if ( NULL != cells[i]->name ) {
                             /* Variable name */
                             err = Inflate(mat, matvar->internal->z, cells[i]->name, len, &bytesread);
                             if ( err ) {
                                 Mat_VarFree(cells[i]);
                                 cells[i] = NULL;
                                 break;
                             }
                             cells[i]->name[len] = '\0';
                         }
                     } else {
                         mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;
                         if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                             /* Name packed in tag */
                             cells[i]->name = (char*)malloc(len+1);
                             if ( NULL != cells[i]->name ) {
                                 memcpy(cells[i]->name,uncomp_buf+1,len);
                                 cells[i]->name[len] = '\0';
                             }
                         }
                     }
                 }
                 cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
                 if ( cells[i]->internal->z != NULL ) {
                     err = inflateCopy(cells[i]->internal->z,matvar->internal->z);
                     if ( err == Z_OK ) {
                         cells[i]->internal->datapos = ftell((FILE*)mat->fp);
                         if ( cells[i]->internal->datapos != -1L ) {
                             cells[i]->internal->datapos -= matvar->internal->z->avail_in;
                             if ( cells[i]->class_type == MAT_C_STRUCT )
                                 bytesread += ReadNextStructField(mat, cells[i]);
                             else if ( cells[i]->class_type == MAT_C_CELL )
                                 bytesread += ReadNextCell(mat, cells[i]);
                             else if ( nBytes <= (1 << MAX_WBITS) ) {
                                 /* Memory optimization: Read data if less in size
                                    than the zlib inflate state (approximately) */
                                 err = Mat_VarRead5(mat, cells[i]);
                                 cells[i]->internal->data = cells[i]->data;
                                 cells[i]->data = NULL;
                             }
                             (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);
                         } else {
                             Mat_Critical("Couldn't determine file position");
                         }
                         if ( cells[i]->internal->data != NULL ||
                              cells[i]->class_type == MAT_C_STRUCT ||
                              cells[i]->class_type == MAT_C_CELL ) {
                             /* Memory optimization: Free inflate state */
                             inflateEnd(cells[i]->internal->z);
                             free(cells[i]->internal->z);
                             cells[i]->internal->z = NULL;
                         }
                     } else {
                         Mat_Critical("inflateCopy returned error %s",zError(err));
                     }
                 } else {
                     Mat_Critical("Couldn't allocate memory");
                 }
             }
             InflateSkip(mat, matvar->internal->z, nBytes, &bytesread);
         }
 #else
         Mat_Critical("Not compiled with zlib support");
 #endif
 
     } else {
         mat_uint32_t buf[6] = {0,};
         mat_uint32_t nBytes;
         mat_uint32_t array_flags;
 
         for ( i = 0; i < nelems; i++ ) {
             size_t nbytes = 0;
             mat_uint32_t name_len;
             cells[i] = Mat_VarCalloc();
             if ( NULL == cells[i] ) {
                 Mat_Critical("Couldn't allocate memory for cell %zu", i);
                 continue;
             }
 
             /* Read variable tag for cell */
-            err = Read(buf, 4, 2, (FILE*)mat->fp, &nbytes);
+            err = Read(buf, 4, 2, (FILE*)mat->fp, &nbytes, READ_STRICT);
 
             /* Empty cells at the end of a file may cause an EOF */
             if ( 0 == err && 0 == nbytes )
                 continue;
             bytesread += nbytes;
             if ( err ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
             }
             nBytes = buf[1];
             if ( 0 == nBytes ) {
                 /* Empty cell: Memory optimization */
                 free(cells[i]->internal);
                 cells[i]->internal = NULL;
                 continue;
             } else if ( buf[0] != MAT_T_MATRIX ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 Mat_Critical("cells[%zu] not MAT_T_MATRIX, fpos = %ld", i,
                     ftell((FILE*)mat->fp));
                 break;
             }
 
             /* Read array flags and the dimensions tag */
-            err = Read(buf, 4, 6, (FILE*)mat->fp, &bytesread);
+            err = Read(buf, 4, 6, (FILE*)mat->fp, &bytesread, READ_STRICT);
             if ( err ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
                 (void)Mat_uint32Swap(buf+2);
                 (void)Mat_uint32Swap(buf+3);
                 (void)Mat_uint32Swap(buf+4);
                 (void)Mat_uint32Swap(buf+5);
             }
             nBytes-=24;
             /* Array flags */
             if ( buf[0] == MAT_T_UINT32 ) {
                array_flags = buf[2];
                cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
                cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
                cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( cells[i]->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
                    cells[i]->nbytes = buf[3];
                }
             }
             /* Rank and dimension */
             nbytes = 0;
             err = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5], &nbytes);
             bytesread += nbytes;
             nBytes -= nbytes;
             if ( err ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 break;
             }
             /* Variable name tag */
-            if ( 0 != Read(buf, 1, 8, (FILE*)mat->fp, &bytesread) ) {
+            if ( 0 != Read(buf, 1, 8, (FILE*)mat->fp, &bytesread, READ_STRICT) ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 break;
             }
             nBytes -= 8;
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
             }
             name_len = 0;
             if ( buf[1] > 0 ) {
                 /* Name of variable */
                 if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
                     name_len = buf[1];
                     if ( name_len % 8 > 0 ) {
                         if ( name_len < UINT32_MAX - 8 + (name_len % 8) ) {
                             name_len = name_len + 8 - (name_len % 8);
                         } else {
                             Mat_VarFree(cells[i]);
                             cells[i] = NULL;
                             break;
                         }
                     }
                     nBytes -= name_len;
                     (void)fseek((FILE*)mat->fp,name_len,SEEK_CUR);
                 }
             }
             cells[i]->internal->datapos = ftell((FILE*)mat->fp);
             if ( cells[i]->internal->datapos != -1L ) {
                 if ( cells[i]->class_type == MAT_C_STRUCT )
                     bytesread+=ReadNextStructField(mat,cells[i]);
                 if ( cells[i]->class_type == MAT_C_CELL )
                     bytesread+=ReadNextCell(mat,cells[i]);
                 (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos+nBytes,SEEK_SET);
             } else {
                 Mat_Critical("Couldn't determine file position");
             }
         }
     }
 
     return bytesread;
 }
 
 /** @brief Reads the next struct field of the structure in @c matvar
  *
  * Reads the next struct fields (fieldname length,names,data headers for all
  * the fields
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar MAT variable pointer
  * @return Number of bytes read
  */
@@ -1360,487 +1360,487 @@ static size_t
 ReadNextStructField( mat_t *mat, matvar_t *matvar )
 {
     mat_uint32_t fieldname_size;
     int err;
     size_t bytesread = 0, nfields, i;
     matvar_t **fields = NULL;
     size_t nelems = 1, nelems_x_nfields;
 
     err = Mat_MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return bytesread;
     }
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
         mat_uint32_t uncomp_buf[16] = {0,};
         mat_uint32_t array_flags, len;
 
         /* Field name length */
         err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
         if ( err ) {
             return bytesread;
         }
         if ( mat->byteswap ) {
             (void)Mat_uint32Swap(uncomp_buf);
             (void)Mat_uint32Swap(uncomp_buf+1);
         }
         if ( (uncomp_buf[0] & 0x0000ffff) == MAT_T_INT32 && uncomp_buf[1] > 0 ) {
             fieldname_size = uncomp_buf[1];
         } else {
             Mat_Critical("Error getting fieldname size");
             return bytesread;
         }
 
         /* Field name tag */
         err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
         if ( err ) {
             return bytesread;
         }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(uncomp_buf);
         /* Name of field */
         if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
             if ( mat->byteswap )
                 len = Mat_uint32Swap(uncomp_buf+1);
             else
                 len = uncomp_buf[1];
             nfields = len / fieldname_size;
             if ( nfields*fieldname_size % 8 != 0 )
                 i = 8-(nfields*fieldname_size % 8);
             else
                 i = 0;
             if ( nfields ) {
                 char *ptr = (char*)malloc(nfields*fieldname_size+i);
                 if ( NULL != ptr ) {
                     err = Inflate(mat, matvar->internal->z, ptr, (unsigned int)(nfields*fieldname_size+i), &bytesread);
                     if ( 0 == err ) {
                         SetFieldNames(matvar, ptr, nfields, fieldname_size);
                     } else {
                         matvar->internal->fieldnames = NULL;
                     }
                     free(ptr);
                 }
             } else {
                 matvar->internal->num_fields = 0;
                 matvar->internal->fieldnames = NULL;
             }
         } else {
             len = (uncomp_buf[0] & 0xffff0000) >> 16;
             if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                 /* Name packed in tag */
                 nfields = len / fieldname_size;
                 if ( nfields ) {
                     SetFieldNames(matvar, (char*)(uncomp_buf + 1), nfields, fieldname_size);
                 } else {
                     matvar->internal->num_fields = 0;
                     matvar->internal->fieldnames = NULL;
                 }
             } else {
                 nfields = 0;
             }
         }
 
         matvar->data_size = sizeof(matvar_t *);
         err = Mul(&nelems_x_nfields, nelems, nfields);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return bytesread;
         }
         err = Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return bytesread;
         }
         if ( !matvar->nbytes )
             return bytesread;
 
         matvar->data = calloc(nelems_x_nfields, matvar->data_size);
         if ( NULL == matvar->data ) {
             Mat_Critical("Couldn't allocate memory for the data");
             return bytesread;
         }
 
         fields = (matvar_t**)matvar->data;
         for ( i = 0; i < nelems; i++ ) {
             size_t k;
             for ( k = 0; k < nfields; k++ ) {
                 fields[i*nfields+k] = Mat_VarCalloc();
             }
         }
         if ( NULL != matvar->internal->fieldnames ) {
             for ( i = 0; i < nelems; i++ ) {
                 size_t k;
                 for ( k = 0; k < nfields; k++ ) {
                     if ( NULL != matvar->internal->fieldnames[k] ) {
                         fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);
                     }
                 }
             }
         }
 
         for ( i = 0; i < nelems_x_nfields; i++ ) {
             mat_uint32_t nBytes;
             /* Read variable tag for struct field */
             err = Inflate(mat, matvar->internal->z,uncomp_buf, 8, &bytesread);
             if ( err ) {
                 Mat_VarFree(fields[i]);
                 fields[i] = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
             }
             nBytes = uncomp_buf[1];
             if ( uncomp_buf[0] != MAT_T_MATRIX ) {
                 Mat_VarFree(fields[i]);
                 fields[i] = NULL;
                 Mat_Critical("fields[%zu], Uncompressed type not MAT_T_MATRIX", i);
                 break;
             } else if ( 0 == nBytes ) {
                 /* Empty field: Memory optimization */
                 free(fields[i]->internal);
                 fields[i]->internal = NULL;
                 continue;
             }
             fields[i]->compression = MAT_COMPRESSION_ZLIB;
             err = Inflate(mat, matvar->internal->z, uncomp_buf, 16, &bytesread);
             if ( err ) {
                 Mat_VarFree(fields[i]);
                 fields[i] = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
                 (void)Mat_uint32Swap(uncomp_buf+2);
                 (void)Mat_uint32Swap(uncomp_buf+3);
             }
             nBytes -= 16;
             /* Array flags */
             if ( uncomp_buf[0] == MAT_T_UINT32 ) {
                array_flags = uncomp_buf[2];
                fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
                fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
                fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( fields[i]->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
                    fields[i]->nbytes = uncomp_buf[3];
                }
             } else {
                 Mat_Critical("Expected MAT_T_UINT32 for array tags, got %d", uncomp_buf[0]);
                 InflateSkip(mat, matvar->internal->z, nBytes, &bytesread);
             }
             if ( fields[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
                 err = InflateRankDims(mat, matvar->internal->z, uncomp_buf, sizeof(uncomp_buf), &dims, &bytesread);
                 if ( NULL == dims ) {
                     dims = uncomp_buf + 2;
                 } else {
                     do_clean = 1;
                 }
                 if ( err ) {
                     if ( do_clean ) {
                         free(dims);
                     }
                     Mat_VarFree(fields[i]);
                     fields[i] = NULL;
                     break;
                 }
                 nBytes -= 8;
                 if ( mat->byteswap ) {
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
                     size_t size;
                     fields[i]->rank = uncomp_buf[1];
                     nBytes -= fields[i]->rank;
                     fields[i]->rank /= 4;
                     if ( 0 == do_clean && fields[i]->rank > 13 ) {
                         int rank = fields[i]->rank;
                         fields[i]->rank = 0;
                         Mat_Critical("%d is not a valid rank", rank);
                         continue;
                     }
                     err = Mul(&size, fields[i]->rank, sizeof(*fields[i]->dims));
                     if ( err ) {
                         if ( do_clean ) {
                             free(dims);
                         }
                         Mat_VarFree(fields[i]);
                         fields[i] = NULL;
                         Mat_Critical("Integer multiplication overflow");
                         continue;
                     }
                     fields[i]->dims = (size_t*)malloc(size);
                     if ( mat->byteswap ) {
                         for ( j = 0; j < fields[i]->rank; j++ )
                             fields[i]->dims[j] = Mat_uint32Swap(dims+j);
                     } else {
                         for ( j = 0; j < fields[i]->rank; j++ )
                             fields[i]->dims[j] = dims[j];
                     }
                     if ( fields[i]->rank % 2 != 0 )
                         nBytes -= 4;
                 }
                 if ( do_clean ) {
                     free(dims);
                 }
                 /* Variable name tag */
                 err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
                 if ( err ) {
                     Mat_VarFree(fields[i]);
                     fields[i] = NULL;
                     break;
                 }
                 nBytes -= 8;
                 fields[i]->internal->z = (z_streamp)calloc(1, sizeof(z_stream));
                 if ( fields[i]->internal->z != NULL ) {
                     err = inflateCopy(fields[i]->internal->z,matvar->internal->z);
                     if ( err == Z_OK ) {
                         fields[i]->internal->datapos = ftell((FILE*)mat->fp);
                         if ( fields[i]->internal->datapos != -1L ) {
                             fields[i]->internal->datapos -= matvar->internal->z->avail_in;
                             if ( fields[i]->class_type == MAT_C_STRUCT )
                                 bytesread += ReadNextStructField(mat, fields[i]);
                             else if ( fields[i]->class_type == MAT_C_CELL )
                                 bytesread += ReadNextCell(mat, fields[i]);
                             else if ( nBytes <= (1 << MAX_WBITS) ) {
                                 /* Memory optimization: Read data if less in size
                                    than the zlib inflate state (approximately) */
                                 err = Mat_VarRead5(mat,fields[i]);
                                 fields[i]->internal->data = fields[i]->data;
                                 fields[i]->data = NULL;
                             }
                             (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos,SEEK_SET);
                         } else {
                             Mat_Critical("Couldn't determine file position");
                         }
                         if ( fields[i]->internal->data != NULL ||
                              fields[i]->class_type == MAT_C_STRUCT ||
                              fields[i]->class_type == MAT_C_CELL ) {
                             /* Memory optimization: Free inflate state */
                             inflateEnd(fields[i]->internal->z);
                             free(fields[i]->internal->z);
                             fields[i]->internal->z = NULL;
                         }
                     } else {
                         Mat_Critical("inflateCopy returned error %s",zError(err));
                     }
                 } else {
                     Mat_Critical("Couldn't allocate memory");
                 }
             }
             InflateSkip(mat, matvar->internal->z, nBytes, &bytesread);
         }
 #else
         Mat_Critical("Not compiled with zlib support");
 #endif
     } else {
         mat_uint32_t buf[6] = {0,};
         mat_uint32_t array_flags, len;
 
-        err = Read(buf, 4, 2, (FILE*)mat->fp, &bytesread);
+        err = Read(buf, 4, 2, (FILE*)mat->fp, &bytesread, READ_STRICT);
         if ( err ) {
             return bytesread;
         }
         if ( mat->byteswap ) {
             (void)Mat_uint32Swap(buf);
             (void)Mat_uint32Swap(buf+1);
         }
         if ( (buf[0] & 0x0000ffff) == MAT_T_INT32 && buf[1] > 0 ) {
             fieldname_size = buf[1];
         } else {
             Mat_Critical("Error getting fieldname size");
             return bytesread;
         }
 
         /* Field name tag */
-        err = Read(buf, 4, 2, (FILE*)mat->fp, &bytesread);
+        err = Read(buf, 4, 2, (FILE*)mat->fp, &bytesread, READ_STRICT);
         if ( err ) {
             return bytesread;
         }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(buf);
         /* Name of field */
         if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
             if ( mat->byteswap )
                 len = Mat_uint32Swap(buf+1);
             else
                 len = buf[1];
             nfields = len / fieldname_size;
             if ( nfields ) {
                 char *ptr = (char*)malloc(nfields*fieldname_size);
                 if ( NULL != ptr ) {
-                    err = Read(ptr, 1, nfields*fieldname_size, (FILE*)mat->fp, &bytesread);
+                    err = Read(ptr, 1, nfields*fieldname_size, (FILE*)mat->fp, &bytesread, READ_STRICT);
                     if ( 0 == err ) {
                         SetFieldNames(matvar, ptr, nfields, fieldname_size);
                     } else {
                         matvar->internal->fieldnames = NULL;
                     }
                     free(ptr);
                 }
                 if ( (nfields*fieldname_size) % 8 ) {
                     (void)fseek((FILE*)mat->fp,8-((nfields*fieldname_size) % 8),SEEK_CUR);
                     bytesread+=8-((nfields*fieldname_size) % 8);
                 }
             } else {
                 matvar->internal->num_fields = 0;
                 matvar->internal->fieldnames = NULL;
             }
        } else {
             len = (buf[0] & 0xffff0000) >> 16;
             if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                 /* Name packed in tag */
                 nfields = len / fieldname_size;
                 if ( nfields ) {
                     SetFieldNames(matvar, (char*)(buf + 1), nfields, fieldname_size);
                 } else {
                     matvar->internal->num_fields = 0;
                     matvar->internal->fieldnames = NULL;
                 }
             } else {
                 nfields = 0;
             }
         }
 
         matvar->data_size = sizeof(matvar_t *);
         err = Mul(&nelems_x_nfields, nelems, nfields);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return bytesread;
         }
         err = Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return bytesread;
         }
         if ( !matvar->nbytes )
             return bytesread;
 
         matvar->data = calloc(nelems_x_nfields, matvar->data_size);
         if ( NULL == matvar->data )
             return bytesread;
 
         fields = (matvar_t**)matvar->data;
         for ( i = 0; i < nelems_x_nfields; i++ ) {
             mat_uint32_t nBytes;
 
             fields[i] = Mat_VarCalloc();
             if ( NULL == fields[i] ) {
                 Mat_Critical("Couldn't allocate memory for field %zu", i);
                 continue;
             }
 
             /* Read variable tag for struct field */
-            err = Read(buf, 4, 2, (FILE*)mat->fp, &bytesread);
+            err = Read(buf, 4, 2, (FILE*)mat->fp, &bytesread, READ_STRICT);
             if ( err ) {
                 Mat_VarFree(fields[i]);
                 fields[i] = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
             }
             nBytes = buf[1];
             if ( buf[0] != MAT_T_MATRIX ) {
                 Mat_VarFree(fields[i]);
                 fields[i] = NULL;
                 Mat_Critical("fields[%zu] not MAT_T_MATRIX, fpos = %ld", i,
                     ftell((FILE*)mat->fp));
                 break;
             } else if ( 0 == nBytes ) {
                 /* Empty field: Memory optimization */
                 free(fields[i]->internal);
                 fields[i]->internal = NULL;
                 continue;
             }
 
             /* Read array flags and the dimensions tag */
-            err = Read(buf, 4, 6, (FILE*)mat->fp, &bytesread);
+            err = Read(buf, 4, 6, (FILE*)mat->fp, &bytesread, READ_STRICT);
             if ( err ) {
                 Mat_VarFree(fields[i]);
                 fields[i] = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
                 (void)Mat_uint32Swap(buf+2);
                 (void)Mat_uint32Swap(buf+3);
                 (void)Mat_uint32Swap(buf+4);
                 (void)Mat_uint32Swap(buf+5);
             }
             nBytes-=24;
             /* Array flags */
             if ( buf[0] == MAT_T_UINT32 ) {
                 array_flags = buf[2];
                 fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                 fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
                 fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
                 fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                 if ( fields[i]->class_type == MAT_C_SPARSE ) {
                     /* Need to find a more appropriate place to store nzmax */
                     fields[i]->nbytes = buf[3];
                 }
             }
             /* Rank and dimension */
             {
                 size_t nbytes = 0;
                 err = ReadRankDims(mat, fields[i], (enum matio_types)buf[4], buf[5], &nbytes);
                 bytesread += nbytes;
                 nBytes -= nbytes;
                 if ( err ) {
                     Mat_VarFree(fields[i]);
                     fields[i] = NULL;
                     break;
                 }
             }
             /* Variable name tag */
-            err = Read(buf, 1, 8, (FILE*)mat->fp, &bytesread);
+            err = Read(buf, 1, 8, (FILE*)mat->fp, &bytesread, READ_STRICT);
             if ( err ) {
                 Mat_VarFree(fields[i]);
                 fields[i] = NULL;
                 break;
             }
             nBytes-=8;
             fields[i]->internal->datapos = ftell((FILE*)mat->fp);
             if ( fields[i]->internal->datapos != -1L ) {
                 if ( fields[i]->class_type == MAT_C_STRUCT )
                     bytesread+=ReadNextStructField(mat,fields[i]);
                 else if ( fields[i]->class_type == MAT_C_CELL )
                     bytesread+=ReadNextCell(mat,fields[i]);
                 (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos+nBytes,SEEK_SET);
             } else {
                 Mat_Critical("Couldn't determine file position");
             }
         }
 
         if ( NULL != matvar->internal->fieldnames ) {
             for ( i = 0; i < nelems; i++ ) {
                 size_t k;
                 for ( k = 0; k < nfields; k++ ) {
                     if ( NULL != matvar->internal->fieldnames[k] && NULL != fields[i*nfields+k] ) {
                         fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);
                     }
                 }
             }
         }
     }
 
     return bytesread;
 }
 
 /** @brief Reads the function handle data of the function handle in @c matvar
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar MAT variable pointer
  * @return Number of bytes read
  */
@@ -1894,52 +1894,52 @@ static int
 ReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type, mat_uint32_t nbytes, size_t* read_bytes)
 {
     int err = MATIO_E_NO_ERROR;
     /* Rank and dimension */
     if ( data_type == MAT_T_INT32 ) {
         matvar->rank = nbytes / sizeof(mat_uint32_t);
         matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
         if ( NULL != matvar->dims ) {
             int i;
             mat_uint32_t buf;
 
             for ( i = 0; i < matvar->rank; i++) {
-                err = Read(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, read_bytes);
+                err = Read(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, read_bytes, READ_STRICT);
                 if ( MATIO_E_NO_ERROR == err ) {
                     if ( mat->byteswap ) {
                         matvar->dims[i] = Mat_uint32Swap(&buf);
                     } else {
                         matvar->dims[i] = buf;
                     }
                 } else {
                     free(matvar->dims);
                     matvar->dims = NULL;
                     matvar->rank = 0;
                     return err;
                 }
             }
 
             if ( matvar->rank % 2 != 0 ) {
-                err = Read(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, read_bytes);
+                err = Read(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, read_bytes, READ_STRICT);
                 if ( err ) {
                     free(matvar->dims);
                     matvar->dims = NULL;
                     matvar->rank = 0;
                     return err;
                 }
             }
         } else {
             matvar->rank = 0;
             err = MATIO_E_OUT_OF_MEMORY;
             Mat_Critical("Error allocating memory for dims");
         }
     }
     return err;
 }
 
 /** @brief Writes the header and data for a given type
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar pointer to the mat variable
  * @retval 0 on success
  */
@@ -2868,178 +2868,178 @@ static int
 Mat_VarReadNumeric5(mat_t *mat,matvar_t *matvar,void *data,size_t N)
 {
     int nBytes = 0, data_in_tag = 0, err = MATIO_E_NO_ERROR;
     enum matio_types packed_type = MAT_T_UNKNOWN;
     mat_uint32_t tag[2];
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
         matvar->internal->z->avail_in = 0;
         err = Inflate(mat, matvar->internal->z, tag, 4, NULL);
         if ( err ) {
             return err;
         }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
 
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             nBytes = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
             err = Inflate(mat, matvar->internal->z, tag+1, 4, NULL);
             if ( err ) {
                 return err;
             }
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(tag+1);
             nBytes = tag[1];
         }
 #endif
     } else {
-        err = Read(tag, 4, 1, (FILE*)mat->fp, NULL);
+        err = Read(tag, 4, 1, (FILE*)mat->fp, NULL, READ_STRICT);
         if ( err ) {
             return err;
         }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             nBytes = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
-            err = Read(tag+1, 4, 1, (FILE*)mat->fp, NULL);
+            err = Read(tag+1, 4, 1, (FILE*)mat->fp, NULL, READ_STRICT);
             if ( err ) {
                 return err;
             }
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(tag+1);
             nBytes = tag[1];
         }
     }
     if ( nBytes == 0 ) {
         matvar->nbytes = 0;
         return err;
     }
 
     if ( matvar->compression == MAT_COMPRESSION_NONE ) {
         switch ( matvar->class_type ) {
             case MAT_C_DOUBLE:
                 nBytes = ReadDoubleData(mat,(double*)data,packed_type,N);
                 break;
             case MAT_C_SINGLE:
                 nBytes = ReadSingleData(mat,(float*)data,packed_type,N);
                 break;
             case MAT_C_INT64:
 #ifdef HAVE_MAT_INT64_T
                 nBytes = ReadInt64Data(mat,(mat_int64_t*)data,packed_type,N);
 #endif
                 break;
             case MAT_C_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                 nBytes = ReadUInt64Data(mat,(mat_uint64_t*)data,packed_type,N);
 #endif
                 break;
             case MAT_C_INT32:
                 nBytes = ReadInt32Data(mat,(mat_int32_t*)data,packed_type,N);
                 break;
             case MAT_C_UINT32:
                 nBytes = ReadUInt32Data(mat,(mat_uint32_t*)data,packed_type,N);
                 break;
             case MAT_C_INT16:
                 nBytes = ReadInt16Data(mat,(mat_int16_t*)data,packed_type,N);
                 break;
             case MAT_C_UINT16:
                 nBytes = ReadUInt16Data(mat,(mat_uint16_t*)data,packed_type,N);
                 break;
             case MAT_C_INT8:
                 nBytes = ReadInt8Data(mat,(mat_int8_t*)data,packed_type,N);
                 break;
             case MAT_C_UINT8:
                 nBytes = ReadUInt8Data(mat,(mat_uint8_t*)data,packed_type,N);
                 break;
             default:
                 break;
         }
         nBytes *= Mat_SizeOf(packed_type);
         /*
          * If the data was in the tag we started on a 4-byte
          * boundary so add 4 to make it an 8-byte
          */
         if ( data_in_tag )
             nBytes+=4;
         if ( (nBytes % 8) != 0 )
             (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
     } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
         switch ( matvar->class_type ) {
             case MAT_C_DOUBLE:
                 nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,(double*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_SINGLE:
                 nBytes = ReadCompressedSingleData(mat,matvar->internal->z,(float*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_INT64:
 #ifdef HAVE_MAT_INT64_T
                 nBytes = ReadCompressedInt64Data(mat,matvar->internal->z,(mat_int64_t*)data,
                                                  packed_type,N);
 #endif
                 break;
             case MAT_C_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                 nBytes = ReadCompressedUInt64Data(mat,matvar->internal->z,(mat_uint64_t*)data,
                                                   packed_type,N);
 #endif
                 break;
             case MAT_C_INT32:
                 nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,(mat_int32_t*)data,
                                                  packed_type,N);
                 break;
             case MAT_C_UINT32:
                 nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,(mat_uint32_t*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_INT16:
                 nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,(mat_int16_t*)data,
                                                  packed_type,N);
                 break;
             case MAT_C_UINT16:
                 nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,(mat_uint16_t*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_INT8:
                 nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,(mat_int8_t*)data,
                                                 packed_type,N);
                 break;
             case MAT_C_UINT8:
                 nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,(mat_uint8_t*)data,
                                                  packed_type,N);
                 break;
             default:
                 break;
         }
         /*
          * If the data was in the tag we started on a 4-byte
          * boundary so add 4 to make it an 8-byte
          */
         if ( data_in_tag )
             nBytes+=4;
         if ( (nBytes % 8) != 0 )
             err = InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif
     }
     return err;
 }
 
 /** @if mat_devman
  * @brief Reads the data of a version 5 MAT variable
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar MAT variable pointer to read the data
  * @retval 0 on success
  * @endif
  */
@@ -3047,1112 +3047,1112 @@ int
 Mat_VarRead5(mat_t *mat, matvar_t *matvar)
 {
     int nBytes = 0, byteswap, data_in_tag = 0, err;
     size_t nelems = 1;
     enum matio_types packed_type = MAT_T_UNKNOWN;
     long fpos;
     mat_uint32_t tag[2];
     size_t bytesread = 0;
 
     if ( matvar == NULL )
         return MATIO_E_BAD_ARGUMENT;
     else if ( matvar->rank == 0 )        /* An empty data set */
         return MATIO_E_NO_ERROR;
 #if HAVE_ZLIB
     else if ( NULL != matvar->internal->data ) {
         /* Data already read in ReadNextStructField or ReadNextCell */
         matvar->data = matvar->internal->data;
         matvar->internal->data = NULL;
         return MATIO_E_NO_ERROR;
     }
 #endif
     fpos = ftell((FILE*)mat->fp);
     if ( fpos == -1L ) {
         Mat_Critical("Couldn't determine file position");
         return MATIO_E_GENERIC_READ_ERROR;
     }
     err = Mat_MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return err;
     }
     byteswap = mat->byteswap;
     switch ( matvar->class_type ) {
         case MAT_C_EMPTY:
             matvar->nbytes = 0;
             matvar->data_size = sizeof(double);
             matvar->data_type = MAT_T_DOUBLE;
             matvar->rank = 2;
             if ( NULL != matvar->dims ) {
                 free(matvar->dims);
             }
             matvar->dims = (size_t*)calloc(matvar->rank, sizeof(*(matvar->dims)));
             break;
         case MAT_C_DOUBLE:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(double);
             matvar->data_type = MAT_T_DOUBLE;
             break;
         case MAT_C_SINGLE:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(float);
             matvar->data_type = MAT_T_SINGLE;
             break;
         case MAT_C_INT64:
 #ifdef HAVE_MAT_INT64_T
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int64_t);
             matvar->data_type = MAT_T_INT64;
 #endif
             break;
         case MAT_C_UINT64:
 #ifdef HAVE_MAT_UINT64_T
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint64_t);
             matvar->data_type = MAT_T_UINT64;
 #endif
             break;
         case MAT_C_INT32:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int32_t);
             matvar->data_type = MAT_T_INT32;
             break;
         case MAT_C_UINT32:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint32_t);
             matvar->data_type = MAT_T_UINT32;
             break;
         case MAT_C_INT16:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int16_t);
             matvar->data_type = MAT_T_INT16;
             break;
         case MAT_C_UINT16:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint16_t);
             matvar->data_type = MAT_T_UINT16;
             break;
         case MAT_C_INT8:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int8_t);
             matvar->data_type = MAT_T_INT8;
             break;
         case MAT_C_UINT8:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint8_t);
             matvar->data_type = MAT_T_UINT8;
             break;
         case MAT_C_CHAR:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
                 matvar->internal->z->avail_in = 0;
                 err = Inflate(mat, matvar->internal->z, tag, 4, &bytesread);
                 if ( err ) {
                     break;
                 }
                 if ( byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     nBytes = (tag[0] & 0xffff0000) >> 16;
                 } else {
                     data_in_tag = 0;
                     err = Inflate(mat, matvar->internal->z, tag+1, 4, &bytesread);
                     if ( err ) {
                         break;
                     }
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag+1);
                     nBytes = tag[1];
                 }
 #endif
                 matvar->data_type = packed_type;
                 matvar->data_size = Mat_SizeOf(matvar->data_type);
                 matvar->nbytes = nBytes;
             } else {
-                err = Read(tag, 4, 1, (FILE*)mat->fp, &bytesread);
+                err = Read(tag, 4, 1, (FILE*)mat->fp, &bytesread, READ_STRICT);
                 if ( err ) {
                     break;
                 }
                 if ( byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     /* nBytes = (tag[0] & 0xffff0000) >> 16; */
                 } else {
                     data_in_tag = 0;
-                    err = Read(tag+1, 4, 1, (FILE*)mat->fp, &bytesread);
+                    err = Read(tag+1, 4, 1, (FILE*)mat->fp, &bytesread, READ_STRICT);
                     if ( err ) {
                         break;
                     }
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag+1);
                     /* nBytes = tag[1]; */
                 }
                 matvar->data_type = MAT_T_UINT8;
                 matvar->data_size = Mat_SizeOf(MAT_T_UINT8);
                 err = Mul(&matvar->nbytes, nelems, matvar->data_size);
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
             }
             if ( matvar->isComplex ) {
                 break;
             }
             if ( 0 == matvar->nbytes ) {
                 matvar->data = calloc(1, 1);
             } else {
                 matvar->data = calloc(matvar->nbytes, 1);
             }
             if ( NULL == matvar->data ) {
                 err = MATIO_E_OUT_OF_MEMORY;
                 Mat_Critical("Couldn't allocate memory for the data");
                 break;
             }
             if ( 0 == matvar->nbytes ) {
                 break;
             }
             {
                 size_t nbytes;
                 err = Mul(&nbytes, nelems, matvar->data_size);
                 if ( err || nbytes > matvar->nbytes ) {
                     break;
                 }
             }
             if ( matvar->compression == MAT_COMPRESSION_NONE ) {
                 nBytes = ReadCharData(mat,(char*)matvar->data,packed_type,nelems);
                 /*
                  * If the data was in the tag we started on a 4-byte
                  * boundary so add 4 to make it an 8-byte
                  */
                 if ( data_in_tag )
                     nBytes+=4;
                 if ( (nBytes % 8) != 0 )
                     (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
             } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
                 nBytes = ReadCompressedCharData(mat,matvar->internal->z,
                              (char*)matvar->data,packed_type,(int)nelems);
                 /*
                  * If the data was in the tag we started on a 4-byte
                  * boundary so add 4 to make it an 8-byte
                  */
                 if ( data_in_tag )
                     nBytes+=4;
                 if ( (nBytes % 8) != 0 )
                     InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif
             }
             break;
         case MAT_C_STRUCT:
         {
             matvar_t **fields;
             size_t i, nelems_x_nfields;
 
             matvar->data_type = MAT_T_STRUCT;
             err = Mul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
             if ( err || !matvar->nbytes || !matvar->data_size || NULL == matvar->data )
                 break;
             fields = (matvar_t **)matvar->data;
             for ( i = 0; i < nelems_x_nfields; i++ ) {
                 if ( NULL != fields[i] ) {
                     err = Mat_VarRead5(mat,fields[i]);
                     if (err )
                         break;
                 }
             }
             break;
         }
         case MAT_C_CELL:
         {
             matvar_t **cells;
             size_t i;
 
             if ( NULL == matvar->data ) {
                 Mat_Critical("Data is NULL for cell array %s",matvar->name);
                 err = MATIO_E_FILE_FORMAT_VIOLATION;
                 break;
             }
             cells = (matvar_t **)matvar->data;
             for ( i = 0; i < nelems; i++ ) {
                 if ( NULL != cells[i] ) {
                     err = Mat_VarRead5(mat, cells[i]);
                     if ( err )
                         break;
                 }
             }
             /* FIXME: */
             matvar->data_type = MAT_T_CELL;
             break;
         }
         case MAT_C_SPARSE:
         {
             mat_uint32_t N = 0;
             mat_sparse_t *sparse;
 
             matvar->data_size = sizeof(mat_sparse_t);
             matvar->data      = calloc(1, matvar->data_size);
             if ( matvar->data == NULL ) {
                 err = MATIO_E_OUT_OF_MEMORY;
                 Mat_Critical("Mat_VarRead5: Allocation of data pointer failed");
                 break;
             }
             sparse = (mat_sparse_t*)matvar->data;
             sparse->nzmax  = matvar->nbytes;
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             /*  Read ir    */
             bytesread += ReadSparse(mat, matvar, &sparse->nir, &sparse->ir);
             /*  Read jc    */
             bytesread += ReadSparse(mat, matvar, &sparse->njc, &sparse->jc);
             /*  Read data  */
             if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
                 matvar->internal->z->avail_in = 0;
                 err = Inflate(mat, matvar->internal->z, tag, 4, &bytesread);
                 if ( err ) {
                     break;
                 }
                 if ( mat->byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     N = (tag[0] & 0xffff0000) >> 16;
                 } else {
                     data_in_tag = 0;
                     (void)ReadCompressedUInt32Data(mat,matvar->internal->z,
                              &N,MAT_T_UINT32,1);
                 }
 #endif
             } else {
-                err = Read(tag, 4, 1, (FILE*)mat->fp, &bytesread);
+                err = Read(tag, 4, 1, (FILE*)mat->fp, &bytesread, READ_STRICT);
                 if ( err ) {
                     break;
                 }
                 if ( mat->byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     N = (tag[0] & 0xffff0000) >> 16;
                 } else {
                     data_in_tag = 0;
-                    err = Read(&N, 4, 1, (FILE*)mat->fp, &bytesread);
+                    err = Read(&N, 4, 1, (FILE*)mat->fp, &bytesread, READ_STRICT);
                     if ( err ) {
                         break;
                     }
                     if ( mat->byteswap )
                         (void)Mat_uint32Swap(&N);
                 }
             }
             if ( matvar->isLogical && packed_type == MAT_T_DOUBLE ) {
                 /* For some reason, MAT says the data type is a double,
                  * but it appears to be written as 8-bit unsigned integer.
                  */
                 packed_type = MAT_T_UINT8;
             }
 #if defined(EXTENDED_SPARSE)
             matvar->data_type = packed_type;
 #else
             matvar->data_type = MAT_T_DOUBLE;
 #endif
             {
                 size_t s_type = Mat_SizeOf(packed_type);
                 if ( s_type == 0 )
                     break;
                 sparse->ndata = N / s_type;
             }
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data;
                 size_t nbytes;
                 err = Mul(&nbytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
                 complex_data = ComplexMalloc(nbytes);
                 if ( NULL == complex_data ) {
                     err = MATIO_E_OUT_OF_MEMORY;
                     Mat_Critical("Couldn't allocate memory for the complex sparse data");
                     break;
                 }
                 if ( matvar->compression == MAT_COMPRESSION_NONE ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadDoubleData(mat,(double*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadSingleData(mat,(float*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else
                     nBytes = ReadDoubleData(mat,(double*)complex_data->Re,
                                  packed_type,sparse->ndata);
 #endif
                     nBytes *= Mat_SizeOf(packed_type);
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 
                     /* Complex Data Tag */
-                    err = Read(tag, 4, 1, (FILE*)mat->fp, &bytesread);
+                    err = Read(tag, 4, 1, (FILE*)mat->fp, &bytesread, READ_STRICT);
                     if ( err ) {
                         break;
                     }
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag);
                     packed_type = TYPE_FROM_TAG(tag[0]);
                     if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                         data_in_tag = 1;
                         nBytes = (tag[0] & 0xffff0000) >> 16;
                     } else {
                         data_in_tag = 0;
-                        err = Read(tag+1, 4, 1, (FILE*)mat->fp, &bytesread);
+                        err = Read(tag+1, 4, 1, (FILE*)mat->fp, &bytesread, READ_STRICT);
                         if ( err ) {
                             break;
                         }
                         if ( byteswap )
                             (void)Mat_uint32Swap(tag+1);
                         nBytes = tag[1];
                     }
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadDoubleData(mat,(double*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadSingleData(mat,(float*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else /* EXTENDED_SPARSE */
                     nBytes = ReadDoubleData(mat,(double*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif /* EXTENDED_SPARSE */
                     nBytes *= Mat_SizeOf(packed_type);
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
                 } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadCompressedSingleData(mat,matvar->internal->z,
                                  (float*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadCompressedInt64Data(mat,
                                 matvar->internal->z,(mat_int64_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadCompressedUInt64Data(mat,
                                 matvar->internal->z,(mat_uint64_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                                  (mat_int32_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                                  (mat_uint32_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,
                                  (mat_int16_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,
                                  (mat_uint16_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,
                                  (mat_int8_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,
                                  (mat_uint8_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else    /* EXTENDED_SPARSE */
                     nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Re,packed_type,sparse->ndata);
 #endif    /* EXTENDED_SPARSE */
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         InflateSkip(mat,matvar->internal->z,8-(nBytes % 8), NULL);
 
                     /* Complex Data Tag */
                     err = Inflate(mat, matvar->internal->z, tag, 4, NULL);
                     if ( err ) {
                         ComplexFree(complex_data);
                         break;
                     }
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag);
 
                     packed_type = TYPE_FROM_TAG(tag[0]);
                     if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                         data_in_tag = 1;
                         nBytes = (tag[0] & 0xffff0000) >> 16;
                     } else {
                         data_in_tag = 0;
                         err = Inflate(mat, matvar->internal->z, tag+1, 4, NULL);
                         if ( err ) {
                             ComplexFree(complex_data);
                             break;
                         }
                         if ( byteswap )
                             (void)Mat_uint32Swap(tag+1);
                         nBytes = tag[1];
                     }
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadCompressedSingleData(mat,matvar->internal->z,
                                  (float*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadCompressedInt64Data(mat,
                                 matvar->internal->z,(mat_int64_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadCompressedUInt64Data(mat,
                                 matvar->internal->z,(mat_uint64_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                                  (mat_int32_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                                  (mat_uint32_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,
                                  (mat_int16_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,
                                  (mat_uint16_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,
                                  (mat_int8_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,
                                  (mat_uint8_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else    /* EXTENDED_SPARSE */
                     nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Im,packed_type,sparse->ndata);
 #endif    /* EXTENDED_SPARSE */
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         err = InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif    /* HAVE_ZLIB */
                 }
                 sparse->data = complex_data;
             } else { /* isComplex */
                 size_t nbytes;
                 err = Mul(&nbytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
                 sparse->data = malloc(nbytes);
                 if ( sparse->data == NULL ) {
                     err = MATIO_E_OUT_OF_MEMORY;
                     Mat_Critical("Couldn't allocate memory for the sparse data");
                     break;
                 }
                 if ( matvar->compression == MAT_COMPRESSION_NONE ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadDoubleData(mat,(double*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadSingleData(mat,(float*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadInt64Data(mat,(mat_int64_t*)sparse->data,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadUInt64Data(mat,(mat_uint64_t*)sparse->data,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadInt32Data(mat,(mat_int32_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadUInt32Data(mat,(mat_uint32_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadInt16Data(mat,(mat_int16_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadUInt16Data(mat,(mat_uint16_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadInt8Data(mat,(mat_int8_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadUInt8Data(mat,(mat_uint8_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else
                     nBytes = ReadDoubleData(mat,(double*)sparse->data,packed_type,
                                  sparse->ndata);
 #endif
                     nBytes *= Mat_SizeOf(packed_type);
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
                 } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadCompressedSingleData(mat,matvar->internal->z,
                                  (float*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadCompressedInt64Data(mat,
                                 matvar->internal->z,(mat_int64_t*)sparse->data,packed_type,
                                 sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadCompressedUInt64Data(mat,
                                 matvar->internal->z,(mat_uint64_t*)sparse->data,packed_type,
                                 sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                                  (mat_int32_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                                  (mat_uint32_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,
                                  (mat_int16_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,
                                  (mat_uint16_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,
                                  (mat_int8_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,
                                  (mat_uint8_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else   /* EXTENDED_SPARSE */
                     nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)sparse->data,packed_type,sparse->ndata);
 #endif   /* EXTENDED_SPARSE */
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         err = InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif   /* HAVE_ZLIB */
                 }
             }
             break;
         }
         case MAT_C_FUNCTION:
         {
             matvar_t **functions;
             size_t nfunctions = 0;
 
             if ( !matvar->nbytes || !matvar->data_size )
                 break;
             nfunctions = matvar->nbytes / matvar->data_size;
             functions = (matvar_t **)matvar->data;
             if ( NULL != functions ) {
                 size_t i;
                 for ( i = 0; i < nfunctions; i++ ) {
                    err = Mat_VarRead5(mat,functions[i]);
                    if ( err)
                        break;
                 }
             }
             /* FIXME: */
             matvar->data_type = MAT_T_FUNCTION;
             break;
         }
         case MAT_C_OBJECT:
             Mat_Warning("Mat_VarRead5: %d is not a supported class", matvar->class_type);
             break;
         default:
             err = MATIO_E_OPERATION_NOT_SUPPORTED;
             Mat_Critical("Mat_VarRead5: %d is not a supported class", matvar->class_type);
             break;
     }
     switch ( matvar->class_type ) {
         case MAT_C_DOUBLE:
         case MAT_C_SINGLE:
 #ifdef HAVE_MAT_INT64_T
         case MAT_C_INT64:
 #endif
 #ifdef HAVE_MAT_UINT64_T
         case MAT_C_UINT64:
 #endif
         case MAT_C_INT32:
         case MAT_C_UINT32:
         case MAT_C_INT16:
         case MAT_C_UINT16:
         case MAT_C_INT8:
         case MAT_C_UINT8:
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data;
 
                 err = Mul(&matvar->nbytes, nelems, matvar->data_size);
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
 
                 complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
                     err = MATIO_E_OUT_OF_MEMORY;
                     Mat_Critical("Couldn't allocate memory for the complex data");
                     break;
                 }
 
                 err = Mat_VarReadNumeric5(mat,matvar,complex_data->Re,nelems);
                 if ( err ) {
                     ComplexFree(complex_data);
                     break;
                 }
                 err = Mat_VarReadNumeric5(mat,matvar,complex_data->Im,nelems);
                 if ( err ) {
                     ComplexFree(complex_data);
                     break;
                 }
                 matvar->data = complex_data;
             } else {
                 void * data;
                 err = Mul(&matvar->nbytes, nelems, matvar->data_size);
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
 
                 data = malloc(matvar->nbytes);
                 if ( NULL == data ) {
                     err = MATIO_E_OUT_OF_MEMORY;
                     Mat_Critical("Couldn't allocate memory for the data");
                     break;
                 }
                 err = Mat_VarReadNumeric5(mat,matvar,data,nelems);
                 if ( err ) {
                     free(data);
                     break;
                 }
                 matvar->data = data;
             }
         default:
             break;
     }
     (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);
 
     return err;
 }
 
 #if HAVE_ZLIB
 #define GET_DATA_SLABN_RANK_LOOP \
     do { \
         for ( j = 1; j < rank; j++ ) { \
             cnt[j]++; \
             if ( (cnt[j] % edge[j]) == 0 ) { \
                 cnt[j] = 0; \
                 if ( (I % dimp[j]) != 0 ) { \
                     ptr_in += dimp[j]-(I % dimp[j])+dimp[j-1]*start[j]; \
                     I += dimp[j]-(I % dimp[j]) + dimp[j-1]*start[j]; \
                 } else if ( start[j] ) { \
                     ptr_in += dimp[j-1]*start[j]; \
                     I += dimp[j-1]*start[j]; \
                 } \
             } else { \
                 I += inc[j]; \
                 ptr_in += inc[j]; \
                 break; \
             } \
         } \
     } while (0)
 
 #define GET_DATA_SLAB2(T) \
     do { \
         ptr_in += start[1]*dims[0] + start[0]; \
         for ( i = 0; i < edge[1]; i++ ) { \
             for ( j = 0; j < edge[0]; j++ ) { \
                 *ptr = (T)(*(ptr_in+j*stride[0])); \
                 ptr++; \
             } \
             ptr_in += stride[1]*dims[0]; \
         } \
     } while (0)
 
 #define GET_DATA_SLABN(T) \
     do { \
         inc[0]  = stride[0]-1; \
         dimp[0] = dims[0]; \
         N       = edge[0]; \
         I       = 0; /* start[0]; */ \
         for ( i = 1; i < rank; i++ ) { \
             inc[i]  = stride[i]-1; \
             dimp[i] = dims[i-1]; \
             for ( j = i; j--; ) { \
                 inc[i]  *= dims[j]; \
                 dimp[i] *= dims[j+1]; \
             } \
             N *= edge[i]; \
             I += dimp[i-1]*start[i]; \
         } \
         ptr_in += I; \
         if ( stride[0] == 1 ) { \
             for ( i = 0; i < N; i+=edge[0] ) { \
                 int k; \
                 if ( start[0] ) { \
                     ptr_in += start[0]; \
                     I += start[0]; \
                 } \
                 for ( k = 0; k < edge[0]; k++ ) { \
                     *(ptr+i+k) = (T)(*(ptr_in+k)); \
                 } \
                 I += dims[0]-start[0]; \
                 ptr_in += dims[0]-start[0]; \
                 GET_DATA_SLABN_RANK_LOOP; \
             } \
         } else { \
             for ( i = 0; i < N; i+=edge[0] ) { \
                 if ( start[0] ) { \
                     ptr_in += start[0]; \
                     I += start[0]; \
                 } \
                 for ( j = 0; j < edge[0]; j++ ) { \
                     *(ptr+i+j) = (T)(*ptr_in); \
                     ptr_in += stride[0]; \
                     I += stride[0]; \
                 } \
                 I += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \
                 ptr_in += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \
                 GET_DATA_SLABN_RANK_LOOP; \
             } \
         } \
     } while (0)
 
 #ifdef HAVE_MAT_INT64_T
 #define GET_DATA_SLAB2_INT64(T) \
     do { \
         if ( MAT_T_INT64 == data_type ) { \
             mat_int64_t *ptr_in = (mat_int64_t *)data_in; \
             GET_DATA_SLAB2(T); \
             err = MATIO_E_NO_ERROR; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLAB2_INT64(T)
 #endif /* HAVE_MAT_INT64_T */
 
 #ifdef HAVE_MAT_UINT64_T
 #define GET_DATA_SLAB2_UINT64(T) \
     do { \
         if ( MAT_T_UINT64 == data_type ) { \
             mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \
             GET_DATA_SLAB2(T); \
             err = MATIO_E_NO_ERROR; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLAB2_UINT64(T)
 #endif /* HAVE_MAT_UINT64_T */
 
 #define GET_DATA_SLAB2_TYPE(T) \
     do { \
         switch ( data_type ) { \
             case MAT_T_DOUBLE: \
             { \
                 double *ptr_in = (double *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_SINGLE: \
             { \
                 float *ptr_in = (float *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_INT32: \
             { \
                 mat_int32_t *ptr_in = (mat_int32_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_UINT32: \
             { \
                 mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_INT16: \
             { \
                 mat_int16_t *ptr_in = (mat_int16_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_UINT16: \
             { \
                 mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_INT8: \
             { \
                 mat_int8_t *ptr_in = (mat_int8_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_UINT8: \
             { \
                 mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             default: \
                 err = MATIO_E_OPERATION_NOT_SUPPORTED; \
                 GET_DATA_SLAB2_INT64(T); \
                 GET_DATA_SLAB2_UINT64(T); \
                 break; \
         } \
     } while (0)
 
 #ifdef HAVE_MAT_INT64_T
 #define GET_DATA_SLABN_INT64(T) \
     do { \
         if ( MAT_T_INT64 == data_type ) { \
             mat_int64_t *ptr_in = (mat_int64_t *)data_in; \
             GET_DATA_SLABN(T); \
             err = MATIO_E_NO_ERROR; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLABN_INT64(T)
 #endif /* HAVE_MAT_INT64_T */
 
 #ifdef HAVE_MAT_UINT64_T
 #define GET_DATA_SLABN_UINT64(T) \
     do { \
         if ( MAT_T_UINT64 == data_type ) { \
             mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \
             GET_DATA_SLABN(T); \
             err = 0; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLABN_UINT64(T)
 #endif /* HAVE_MAT_UINT64_T */
 
 #define GET_DATA_SLABN_TYPE(T) \
     do { \
         switch ( data_type ) { \
             case MAT_T_DOUBLE: \
             { \
                 double *ptr_in = (double *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_SINGLE: \
             { \
                 float *ptr_in = (float *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_INT32: \
             { \
                 mat_int32_t *ptr_in = (mat_int32_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_UINT32: \
             { \
                 mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_INT16: \
             { \
                 mat_int16_t *ptr_in = (mat_int16_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_UINT16: \
             { \
                 mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_INT8: \
             { \
                 mat_int8_t *ptr_in = (mat_int8_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_UINT8: \
             { \
                 mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             default: \
                 err = MATIO_E_OPERATION_NOT_SUPPORTED; \
                 GET_DATA_SLABN_INT64(T); \
                 GET_DATA_SLABN_UINT64(T); \
                 break; \
         } \
     } while (0)
@@ -4468,245 +4468,245 @@ int
 Mat_VarReadData5(mat_t *mat,matvar_t *matvar,void *data,
     int *start,int *stride,int *edge)
 {
     int err = MATIO_E_NO_ERROR, real_bytes = 0;
     mat_int32_t tag[2];
 #if HAVE_ZLIB
     z_stream z;
 #endif
 
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
     if ( matvar->compression == MAT_COMPRESSION_NONE ) {
-        err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+        err = Read(tag, 4, 2, (FILE*)mat->fp, NULL, READ_STRICT);
         if ( err ) {
             return err;
         }
         if ( mat->byteswap ) {
             (void)Mat_int32Swap(tag);
             (void)Mat_int32Swap(tag+1);
         }
         matvar->data_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
             (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
             real_bytes = 4+(tag[0] >> 16);
         } else {
             real_bytes = 8+tag[1];
         }
 #if HAVE_ZLIB
     } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
         if ( NULL != matvar->internal->data ) {
             /* Data already read in ReadNextStructField or ReadNextCell */
             if ( matvar->isComplex ) {
                 mat_complex_split_t *ci, *co;
 
                 co = (mat_complex_split_t*)data;
                 ci = (mat_complex_split_t*)matvar->internal->data;
                 err = GetDataSlab(ci->Re, co->Re, matvar->class_type,
                     matvar->data_type, matvar->dims, start, stride, edge,
                     matvar->rank, matvar->nbytes);
                 if ( MATIO_E_NO_ERROR == err )
                     err = GetDataSlab(ci->Im, co->Im, matvar->class_type,
                         matvar->data_type, matvar->dims, start, stride, edge,
                         matvar->rank, matvar->nbytes);
                 return err;
             } else {
                 return GetDataSlab(matvar->internal->data, data, matvar->class_type,
                     matvar->data_type, matvar->dims, start, stride, edge,
                     matvar->rank, matvar->nbytes);
             }
         }
 
         err = inflateCopy(&z,matvar->internal->z);
         if ( err != Z_OK ) {
             Mat_Critical("inflateCopy returned error %s",zError(err));
             return MATIO_E_FILE_FORMAT_VIOLATION;
         }
         z.avail_in = 0;
         err = Inflate(mat, &z, tag, 4, NULL);
         if ( err ) {
             return err;
         }
         if ( mat->byteswap ) {
             (void)Mat_int32Swap(tag);
         }
         matvar->data_type = TYPE_FROM_TAG(tag[0]);
         if ( !(tag[0] & 0xffff0000) ) {/* Data is NOT packed in the tag */
             err = Inflate(mat, &z, tag+1, 4, NULL);
             if ( err ) {
                 return err;
             }
             if ( mat->byteswap ) {
                 (void)Mat_int32Swap(tag+1);
             }
             real_bytes = 8+tag[1];
         } else {
             real_bytes = 4+(tag[0] >> 16);
         }
 #endif
     }
     if ( real_bytes % 8 )
         real_bytes += (8-(real_bytes % 8));
 
     if ( matvar->rank == 2 ) {
         if ( (size_t)stride[0]*(edge[0]-1)+start[0]+1 > matvar->dims[0] )
             err = MATIO_E_BAD_ARGUMENT;
         else if ( (size_t)stride[1]*(edge[1]-1)+start[1]+1 > matvar->dims[1] )
             err = MATIO_E_BAD_ARGUMENT;
         else if ( matvar->compression == MAT_COMPRESSION_NONE ) {
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
                 ReadDataSlab2(mat,complex_data->Re,matvar->class_type,
                     matvar->data_type,matvar->dims,start,stride,edge);
                 (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);
-                err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+                err = Read(tag, 4, 2, (FILE*)mat->fp, NULL, READ_STRICT);
                 if ( err ) {
                     return err;
                 }
                 if ( mat->byteswap ) {
                     (void)Mat_int32Swap(tag);
                     (void)Mat_int32Swap(tag+1);
                 }
                 matvar->data_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
                     (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
                 }
                 ReadDataSlab2(mat,complex_data->Im,matvar->class_type,
                               matvar->data_type,matvar->dims,start,stride,edge);
             } else {
                 ReadDataSlab2(mat,data,matvar->class_type,
                     matvar->data_type,matvar->dims,start,stride,edge);
             }
         }
 #if HAVE_ZLIB
         else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
                 ReadCompressedDataSlab2(mat,&z,complex_data->Re,
                     matvar->class_type,matvar->data_type,matvar->dims,
                     start,stride,edge);
 
                 (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
 
                 /* Reset zlib knowledge to before reading real tag */
                 inflateEnd(&z);
                 err = inflateCopy(&z,matvar->internal->z);
                 if ( err != Z_OK ) {
                     Mat_Critical("inflateCopy returned error %s",zError(err));
                     return MATIO_E_FILE_FORMAT_VIOLATION;
                 }
                 InflateSkip(mat, &z, real_bytes, NULL);
                 z.avail_in = 0;
                 err = Inflate(mat, &z, tag, 4, NULL);
                 if ( err ) {
                     return err;
                 }
                 if ( mat->byteswap ) {
                     (void)Mat_int32Swap(tag);
                 }
                 matvar->data_type = TYPE_FROM_TAG(tag[0]);
                 if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/
                     InflateSkip(mat, &z, 4, NULL);
                 }
                 ReadCompressedDataSlab2(mat,&z,complex_data->Im,
                     matvar->class_type,matvar->data_type,matvar->dims,
                     start,stride,edge);
             } else {
                 ReadCompressedDataSlab2(mat,&z,data,matvar->class_type,
                     matvar->data_type,matvar->dims,start,stride,edge);
             }
             inflateEnd(&z);
         }
 #endif
     } else {
         if ( matvar->compression == MAT_COMPRESSION_NONE ) {
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
                 ReadDataSlabN(mat,complex_data->Re,matvar->class_type,
                     matvar->data_type,matvar->rank,matvar->dims,
                     start,stride,edge);
 
                 (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);
-                err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+                err = Read(tag, 4, 2, (FILE*)mat->fp, NULL, READ_STRICT);
                 if ( err ) {
                     return err;
                 }
                 if ( mat->byteswap ) {
                     (void)Mat_int32Swap(tag);
                     (void)Mat_int32Swap(tag+1);
                 }
                 matvar->data_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
                     (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
                 }
                 ReadDataSlabN(mat,complex_data->Im,matvar->class_type,
                     matvar->data_type,matvar->rank,matvar->dims,
                     start,stride,edge);
             } else {
                 ReadDataSlabN(mat,data,matvar->class_type,matvar->data_type,
                     matvar->rank,matvar->dims,start,stride,edge);
             }
         }
 #if HAVE_ZLIB
         else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
                 ReadCompressedDataSlabN(mat,&z,complex_data->Re,
                     matvar->class_type,matvar->data_type,matvar->rank,
                     matvar->dims,start,stride,edge);
 
                 (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
                 /* Reset zlib knowledge to before reading real tag */
                 inflateEnd(&z);
                 err = inflateCopy(&z,matvar->internal->z);
                 if ( err != Z_OK ) {
                     Mat_Critical("inflateCopy returned error %s",zError(err));
                     return MATIO_E_FILE_FORMAT_VIOLATION;
                 }
                 InflateSkip(mat, &z, real_bytes, NULL);
                 z.avail_in = 0;
                 err = Inflate(mat, &z, tag, 4, NULL);
                 if ( err ) {
                     return err;
                 }
                 if ( mat->byteswap ) {
                     (void)Mat_int32Swap(tag);
                 }
                 matvar->data_type = TYPE_FROM_TAG(tag[0]);
                 if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/
                     InflateSkip(mat, &z, 4, NULL);
                 }
                 ReadCompressedDataSlabN(mat,&z,complex_data->Im,
                     matvar->class_type,matvar->data_type,matvar->rank,
                     matvar->dims,start,stride,edge);
             } else {
                 ReadCompressedDataSlabN(mat,&z,data,matvar->class_type,
                     matvar->data_type,matvar->rank,matvar->dims,
                     start,stride,edge);
             }
             inflateEnd(&z);
         }
 #endif
     }
     if ( err == MATIO_E_NO_ERROR ) {
         matvar->data_type = ClassType2DataType(matvar->class_type);
         matvar->data_size = Mat_SizeOfClass(matvar->class_type);
     }
     return err;
 }
 
 /** @brief Reads a subset of a MAT variable using a 1-D indexing
  *
  * Reads data from a MAT variable using a linear (1-D) indexing mode. The
  * variable must have been read by Mat_VarReadInfo.
  * @ingroup MAT
  * @param mat MAT file to read data from
  * @param matvar MAT variable information
  * @param data pointer to store data in (must be pre-allocated)
  * @param start starting index
  * @param stride stride of data
  * @param edge number of elements to read
  * @retval 0 on success
  */
@@ -4714,172 +4714,172 @@ int
 Mat_VarReadDataLinear5(mat_t *mat,matvar_t *matvar,void *data,int start,
                       int stride,int edge)
 {
     int err = MATIO_E_NO_ERROR, real_bytes = 0;
     mat_int32_t tag[2];
 #if HAVE_ZLIB
     z_stream z;
 #endif
     size_t nelems = 1;
 
     if ( mat->version == MAT_FT_MAT4 )
         return -1;
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
     if ( matvar->compression == MAT_COMPRESSION_NONE ) {
-        err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+        err = Read(tag, 4, 2, (FILE*)mat->fp, NULL, READ_STRICT);
         if ( err ) {
             return err;
         }
         if ( mat->byteswap ) {
             (void)Mat_int32Swap(tag);
             (void)Mat_int32Swap(tag+1);
         }
         matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);
         if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
             (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
             real_bytes = 4+(tag[0] >> 16);
         } else {
             real_bytes = 8+tag[1];
         }
 #if HAVE_ZLIB
     } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
         if ( NULL != matvar->internal->data ) {
             /* Data already read in ReadNextStructField or ReadNextCell */
             if ( matvar->isComplex ) {
                 mat_complex_split_t *ci, *co;
 
                 co = (mat_complex_split_t*)data;
                 ci = (mat_complex_split_t*)matvar->internal->data;
                 err = GetDataLinear(ci->Re, co->Re, matvar->class_type,
                     matvar->data_type, start, stride, edge);
                 if ( err == MATIO_E_NO_ERROR )
                     err = GetDataLinear(ci->Im, co->Im, matvar->class_type,
                         matvar->data_type, start, stride, edge);
                 return err;
             } else {
                 return GetDataLinear(matvar->internal->data, data, matvar->class_type,
                     matvar->data_type, start, stride, edge);
             }
         }
 
         matvar->internal->z->avail_in = 0;
         err = inflateCopy(&z,matvar->internal->z);
         if ( err != Z_OK ) {
             Mat_Critical("inflateCopy returned error %s",zError(err));
             return MATIO_E_FILE_FORMAT_VIOLATION;
         }
         err = Inflate(mat, &z, tag, 4, NULL);
         if ( err ) {
             return err;
         }
         if ( mat->byteswap ) {
             (void)Mat_int32Swap(tag);
             (void)Mat_int32Swap(tag+1);
         }
         matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);
         if ( !(tag[0] & 0xffff0000) ) {/* Data is NOT packed in the tag */
             err = Inflate(mat, &z, tag+1, 4, NULL);
             if ( err ) {
                 return err;
             }
             if ( mat->byteswap ) {
                 (void)Mat_int32Swap(tag+1);
             }
             real_bytes = 8+tag[1];
         } else {
             real_bytes = 4+(tag[0] >> 16);
         }
 #endif
     }
     if ( real_bytes % 8 )
         real_bytes += (8-(real_bytes % 8));
 
     err = Mat_MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return err;
     }
 
     if ( (size_t)stride*(edge-1)+start+1 > nelems ) {
         err = MATIO_E_BAD_ARGUMENT;
     } else if ( matvar->compression == MAT_COMPRESSION_NONE ) {
         if ( matvar->isComplex ) {
             mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
             ReadDataSlab1(mat,complex_data->Re,matvar->class_type,
                           matvar->data_type,start,stride,edge);
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);
-            err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+            err = Read(tag, 4, 2, (FILE*)mat->fp, NULL, READ_STRICT);
             if ( err ) {
                 return err;
             }
             if ( mat->byteswap ) {
                 (void)Mat_int32Swap(tag);
                 (void)Mat_int32Swap(tag+1);
             }
             matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);
             if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
                 (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
             }
             ReadDataSlab1(mat,complex_data->Im,matvar->class_type,
                           matvar->data_type,start,stride,edge);
         } else {
             ReadDataSlab1(mat,data,matvar->class_type,
                           matvar->data_type,start,stride,edge);
         }
 #if HAVE_ZLIB
     } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
         if ( matvar->isComplex ) {
             mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
             ReadCompressedDataSlab1(mat,&z,complex_data->Re,
                 matvar->class_type,matvar->data_type,start,stride,edge);
 
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
 
             /* Reset zlib knowledge to before reading real tag */
             inflateEnd(&z);
             err = inflateCopy(&z, matvar->internal->z);
             if ( err != Z_OK ) {
                 Mat_Critical("inflateCopy returned error %s",zError(err));
                 return MATIO_E_FILE_FORMAT_VIOLATION;
             }
             InflateSkip(mat, &z, real_bytes, NULL);
             z.avail_in = 0;
             err = Inflate(mat, &z, tag, 4, NULL);
             if ( err ) {
                 return err;
             }
             if ( mat->byteswap ) {
                 (void)Mat_int32Swap(tag);
             }
             matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);
             if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/
                 InflateSkip(mat, &z, 4, NULL);
             }
             ReadCompressedDataSlab1(mat,&z,complex_data->Im,
                 matvar->class_type,matvar->data_type,start,stride,edge);
         } else {
             ReadCompressedDataSlab1(mat,&z,data,matvar->class_type,
                 matvar->data_type,start,stride,edge);
         }
         inflateEnd(&z);
 #endif
     }
 
     matvar->data_type = ClassType2DataType(matvar->class_type);
     matvar->data_size = Mat_SizeOfClass(matvar->class_type);
 
     return err;
 }
 
 /** @if mat_devman
  * @brief Writes a matlab variable to a version 5 matlab file
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar pointer to the mat variable
  * @param compress option to compress the variable
  *                 (only works for numeric types)
  * @retval 0 on success
  * @endif
  */
@@ -5147,343 +5147,343 @@ matvar_t *
 Mat_VarReadNextInfo5( mat_t *mat )
 {
     int err;
     mat_uint32_t data_type, array_flags, nBytes;
     long fpos;
     matvar_t *matvar = NULL;
 
     if ( mat == NULL || mat->fp == NULL )
         return NULL;
 
     fpos = ftell((FILE*)mat->fp);
     if ( fpos == -1L ) {
         Mat_Critical("Couldn't determine file position");
         return NULL;
     }
     {
         size_t nbytes = 0;
-        err = Read(&data_type, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, &nbytes);
+        err = Read(&data_type, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, &nbytes, READ_ACCEPT_EOF);
         if ( err || 0 == nbytes )
             return NULL;
     }
-    err = Read(&nBytes, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, NULL);
+    err = Read(&nBytes, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, NULL, READ_STRICT);
     if ( err )
         return NULL;
     if ( mat->byteswap ) {
         (void)Mat_uint32Swap(&data_type);
         (void)Mat_uint32Swap(&nBytes);
     }
     if ( nBytes > INT32_MAX - 8 - (mat_uint32_t)fpos )
         return NULL;
     switch ( data_type ) {
         case MAT_T_COMPRESSED:
         {
 #if HAVE_ZLIB
             mat_uint32_t uncomp_buf[16] = {0,};
             int nbytes;
             size_t bytesread = 0;
 
             matvar = Mat_VarCalloc();
             if ( NULL == matvar ) {
                 Mat_Critical("Couldn't allocate memory");
                 break;
             }
 
             matvar->compression = MAT_COMPRESSION_ZLIB;
             matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
             err = inflateInit(matvar->internal->z);
             if ( err != Z_OK ) {
                 Mat_VarFree(matvar);
                 matvar = NULL;
                 Mat_Critical("inflateInit returned %s",zError(err));
                 break;
             }
 
             /* Read variable tag */
             err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
             }
             nbytes = uncomp_buf[1];
             if ( uncomp_buf[0] != MAT_T_MATRIX ) {
                 (void)fseek((FILE*)mat->fp,(long)(nBytes-bytesread),SEEK_CUR);
                 Mat_VarFree(matvar);
                 matvar = NULL;
                 Mat_Critical("Uncompressed type not MAT_T_MATRIX");
                 break;
             }
             /* Array flags */
             err = Inflate(mat, matvar->internal->z, uncomp_buf, 16, &bytesread);
             if ( err ) {
                 Mat_VarFree(matvar);
                 matvar = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+2);
                 (void)Mat_uint32Swap(uncomp_buf+3);
             }
             /* Array flags */
             if ( uncomp_buf[0] == MAT_T_UINT32 ) {
                 array_flags = uncomp_buf[2];
                 matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                 matvar->isComplex  = (array_flags & MAT_F_COMPLEX);
                 matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);
                 matvar->isLogical  = (array_flags & MAT_F_LOGICAL);
                 if ( matvar->class_type == MAT_C_SPARSE ) {
                     /* Need to find a more appropriate place to store nzmax */
                     matvar->nbytes = uncomp_buf[3];
                 }
             }
             if ( matvar->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
                 err = InflateRankDims(mat, matvar->internal->z, uncomp_buf, sizeof(uncomp_buf), &dims, &bytesread);
                 if ( NULL == dims ) {
                     dims = uncomp_buf + 2;
                 } else {
                     do_clean = 1;
                 }
                 if ( err ) {
                     if ( do_clean ) {
                         free(dims);
                     }
                     Mat_VarFree(matvar);
                     matvar = NULL;
                     break;
                 }
                 if ( mat->byteswap ) {
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
                     size_t size;
                     nbytes = uncomp_buf[1];
                     matvar->rank = nbytes / 4;
                     if ( 0 == do_clean && matvar->rank > 13 ) {
                         int rank = matvar->rank;
                         matvar->rank = 0;
                         Mat_Critical("%d is not a valid rank", rank);
                         break;
                     }
                     err = Mul(&size, matvar->rank, sizeof(*matvar->dims));
                     if ( err ) {
                         if ( do_clean ) {
                             free(dims);
                         }
                         (void)fseek((FILE*)mat->fp,(long)(nBytes-bytesread),SEEK_CUR);
                         Mat_VarFree(matvar);
                         matvar = NULL;
                         Mat_Critical("Integer multiplication overflow");
                         break;
                     }
                     matvar->dims = (size_t*)malloc(size);
                     if ( NULL == matvar->dims ) {
                         if ( do_clean )
                             free(dims);
                         (void)fseek((FILE*)mat->fp,(long)(nBytes-bytesread),SEEK_CUR);
                         Mat_VarFree(matvar);
                         matvar = NULL;
                         Mat_Critical("Couldn't allocate memory");
                         break;
                     }
                     if ( mat->byteswap ) {
                         for ( j = 0; j < matvar->rank; j++ )
                             matvar->dims[j] = Mat_uint32Swap(dims + j);
                     } else {
                         for ( j = 0; j < matvar->rank; j++ )
                             matvar->dims[j] = dims[j];
                     }
                 }
                 if ( do_clean ) {
                     free(dims);
                 }
                 /* Variable name tag */
                 err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
                 if ( err ) {
                     Mat_VarFree(matvar);
                     matvar = NULL;
                     break;
                 }
                 if ( mat->byteswap )
                     (void)Mat_uint32Swap(uncomp_buf);
                 /* Name of variable */
                 if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
                     mat_uint32_t len, len_pad;
                     if ( mat->byteswap )
                         len = Mat_uint32Swap(uncomp_buf+1);
                     else
                         len = uncomp_buf[1];
 
                     if ( len % 8 == 0 )
                         len_pad = len;
                     else if ( len < UINT32_MAX - 8 + (len % 8) )
                         len_pad = len + 8 - (len % 8);
                     else {
                         Mat_VarFree(matvar);
                         matvar = NULL;
                         break;
                     }
                     matvar->name = (char*)malloc(len_pad + 1);
                     if ( NULL != matvar->name ) {
                         /* Variable name */
                         err = Inflate(mat, matvar->internal->z, matvar->name, len_pad, &bytesread);
                         if ( err )  {
                             Mat_VarFree(matvar);
                             matvar = NULL;
                             break;
                         }
                         matvar->name[len] = '\0';
                     }
                 } else {
                     mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;
                     if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                         /* Name packed in tag */
                         matvar->name = (char*)malloc(len+1);
                         if ( NULL != matvar->name ) {
                             memcpy(matvar->name,uncomp_buf+1,len);
                             matvar->name[len] = '\0';
                         }
                     }
                 }
                 if ( matvar->class_type == MAT_C_STRUCT )
                     (void)ReadNextStructField(mat,matvar);
                 else if ( matvar->class_type == MAT_C_CELL )
                     (void)ReadNextCell(mat,matvar);
                 (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
                 matvar->internal->datapos = ftell((FILE*)mat->fp);
                 if ( matvar->internal->datapos == -1L ) {
                     Mat_Critical("Couldn't determine file position");
                 }
             }
             (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
             break;
 #else
             Mat_Critical("Compressed variable found in \"%s\", but matio was "
                          "built without zlib support",mat->filename);
             (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
             return NULL;
 #endif
         }
         case MAT_T_MATRIX:
         {
             mat_uint32_t buf[6];
 
             /* Read array flags and the dimensions tag */
-            err = Read(buf, 4, 6, (FILE*)mat->fp, NULL);
+            err = Read(buf, 4, 6, (FILE*)mat->fp, NULL, READ_STRICT);
             if ( err ) {
                 (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
                 (void)Mat_uint32Swap(buf+2);
                 (void)Mat_uint32Swap(buf+3);
                 (void)Mat_uint32Swap(buf+4);
                 (void)Mat_uint32Swap(buf+5);
             }
 
             matvar = Mat_VarCalloc();
             if ( NULL == matvar ) {
                 Mat_Critical("Couldn't allocate memory");
                 break;
             }
 
             /* Array flags */
             if ( buf[0] == MAT_T_UINT32 || buf[0] == MAT_T_INT32 ) { /* Also allow INT32 for SWAN */
                array_flags = buf[2];
                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);
                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);
                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( matvar->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
                    matvar->nbytes = buf[3];
                }
             }
             /* Rank and dimension */
             {
                 size_t nbytes = 0;
                 err = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5], &nbytes);
-                if ( 0 == nbytes && 0 < matvar->rank ) {
+                if ( err ) {
                     Mat_VarFree(matvar);
                     matvar = NULL;
                     (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                     break;
                 }
             }
             /* Variable name tag */
-            err = Read(buf, 4, 2, (FILE*)mat->fp, NULL);
+            err = Read(buf, 4, 2, (FILE*)mat->fp, NULL, READ_STRICT);
             if ( err ) {
                 Mat_VarFree(matvar);
                 matvar = NULL;
                 (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                 break;
             }
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(buf);
             /* Name of variable */
             if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
                 mat_uint32_t len, len_pad;
                 if ( mat->byteswap )
                     len = Mat_uint32Swap(buf+1);
                 else
                     len = buf[1];
                 if ( len % 8 == 0 )
                     len_pad = len;
                 else if ( len < UINT32_MAX - 8 + (len % 8) )
                     len_pad = len + 8 - (len % 8);
                 else {
                     Mat_VarFree(matvar);
                     matvar = NULL;
                     (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                     break;
                 }
                 matvar->name = (char*)malloc(len_pad + 1);
                 if ( NULL != matvar->name ) {
-                    err = Read(matvar->name, 1, len_pad, (FILE*)mat->fp, NULL);
+                    err = Read(matvar->name, 1, len_pad, (FILE*)mat->fp, NULL, READ_STRICT);
                     if ( MATIO_E_NO_ERROR == err ) {
                         matvar->name[len] = '\0';
                     } else {
                         Mat_VarFree(matvar);
                         matvar = NULL;
                         (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                         break;
                     }
                 }
             } else {
                 mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;
                 if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                     /* Name packed in tag */
                     matvar->name = (char*)malloc(len+1);
                     if ( NULL != matvar->name ) {
                         memcpy(matvar->name, buf+1, len);
                         matvar->name[len] = '\0';
                     }
                 }
             }
             if ( matvar->class_type == MAT_C_STRUCT )
                 (void)ReadNextStructField(mat,matvar);
             else if ( matvar->class_type == MAT_C_CELL )
                 (void)ReadNextCell(mat,matvar);
             else if ( matvar->class_type == MAT_C_FUNCTION )
                 (void)ReadNextFunctionHandle(mat,matvar);
             matvar->internal->datapos = ftell((FILE*)mat->fp);
             if ( matvar->internal->datapos == -1L ) {
                 Mat_Critical("Couldn't determine file position");
             }
             (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
             break;
         }
         default:
             Mat_Critical("%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)",
                          data_type);
             return NULL;
     }
 
     return matvar;
 }
diff --git a/src/matio_private.h b/src/matio_private.h
index a2aef9d..09287f7 100644
--- a/src/matio_private.h
+++ b/src/matio_private.h
@@ -1,64 +1,67 @@
 /*
  * Copyright (c) 2008-2021, Christopher C. Hulbert
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef MATIO_PRIVATE_H
 #define MATIO_PRIVATE_H
 
 #include "matioConfig.h"
 #include "matio.h"
 #if HAVE_ZLIB
 #   include <zlib.h>
 #endif
 #if defined(MAT73) && MAT73
 #   include <hdf5.h>
 #endif
 
 #ifndef EXTERN
 #   ifdef __cplusplus
 #       define EXTERN extern "C"
 #   else
 #       define EXTERN extern
 #   endif
 #endif
 
 #if HAVE_ZLIB
 #   define ZLIB_BYTE_PTR(a) ((Bytef *)(a))
 #endif
 
 #if !defined(READ_BLOCK_SIZE)
 #define READ_BLOCK_SIZE (8192)
 #endif
 
 #define _CAT(X, Y) X ## Y
 #define CAT(X, Y) _CAT(X, Y)
 
+#define READ_STRICT (0)
+#define READ_ACCEPT_EOF (1)
+
 /** @if mat_devman
  * @brief Matlab MAT File information
  *
  * Contains information about a Matlab MAT file
  * @ingroup mat_internal
  * @endif
  */
@@ -226,7 +229,7 @@ EXTERN enum matio_types ClassType2DataType(enum matio_classes class_type);
 EXTERN int Add(size_t* res, size_t a, size_t b);
 EXTERN int Mul(size_t* res, size_t a, size_t b);
 EXTERN int Mat_MulDims(const matvar_t *matvar, size_t* nelems);
-EXTERN int Read(void* buf, size_t size, size_t count, FILE* fp, size_t* bytesread);
+EXTERN int Read(void* buf, size_t size, size_t count, FILE* fp, size_t* bytesread, int checkEOF);
 
 /* io.c */
 #if defined(_WIN32) && defined(_MSC_VER)
