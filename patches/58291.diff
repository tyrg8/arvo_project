commit 88a960a86b9ffbabd17a4bbcf767e26514c4678e
Author: Michael Buckley <michael@buckleyisms.com>
Date:   Mon Aug 28 16:47:21 2023 -0700

    Properly bounds check packet_authagent_open() (#1179)
    
    * Properly bounds check packet_authagent_open
    * packet.c: use strlen instead of sizeof for strings
    * Make LIBSSH_CHANNEL's channel_type_len a size_t
    * packet_authagent_open: use size_t for offset
    
    Credit:
    Michael Buckley, signed off by Will Cosgrove

diff --git a/src/libssh2_priv.h b/src/libssh2_priv.h
index 9d6137e6..66cce068 100644
--- a/src/libssh2_priv.h
+++ b/src/libssh2_priv.h
@@ -413,103 +413,103 @@ typedef struct _libssh2_channel_data
 struct _LIBSSH2_CHANNEL
 {
     struct list_node node;
 
     unsigned char *channel_type;
-    unsigned channel_type_len;
+    size_t channel_type_len;
 
     /* channel's program exit status */
     int exit_status;
 
     /* channel's program exit signal (without the SIG prefix) */
     char *exit_signal;
 
     libssh2_channel_data local, remote;
     /* Amount of bytes to be refunded to receive window (but not yet sent) */
     uint32_t adjust_queue;
     /* Data immediately available for reading */
     size_t read_avail;
 
     LIBSSH2_SESSION *session;
 
     void *abstract;
       LIBSSH2_CHANNEL_CLOSE_FUNC((*close_cb));
 
     /* State variables used in libssh2_channel_setenv_ex() */
     libssh2_nonblocking_states setenv_state;
     unsigned char *setenv_packet;
     size_t setenv_packet_len;
     unsigned char setenv_local_channel[4];
     packet_requirev_state_t setenv_packet_requirev_state;
 
     /* State variables used in libssh2_channel_request_pty_ex()
        libssh2_channel_request_pty_size_ex() */
     libssh2_nonblocking_states reqPTY_state;
     unsigned char reqPTY_packet[41 + 256];
     size_t reqPTY_packet_len;
     unsigned char reqPTY_local_channel[4];
     packet_requirev_state_t reqPTY_packet_requirev_state;
 
     /* State variables used in libssh2_channel_x11_req_ex() */
     libssh2_nonblocking_states reqX11_state;
     unsigned char *reqX11_packet;
     size_t reqX11_packet_len;
     unsigned char reqX11_local_channel[4];
     packet_requirev_state_t reqX11_packet_requirev_state;
 
     /* State variables used in libssh2_channel_process_startup() */
     libssh2_nonblocking_states process_state;
     unsigned char *process_packet;
     size_t process_packet_len;
     unsigned char process_local_channel[4];
     packet_requirev_state_t process_packet_requirev_state;
 
     /* State variables used in libssh2_channel_flush_ex() */
     libssh2_nonblocking_states flush_state;
     size_t flush_refund_bytes;
     size_t flush_flush_bytes;
 
     /* State variables used in libssh2_channel_receive_window_adjust() */
     libssh2_nonblocking_states adjust_state;
     unsigned char adjust_adjust[9];     /* packet_type(1) + channel(4) +
                                            adjustment(4) */
 
     /* State variables used in libssh2_channel_read_ex() */
     libssh2_nonblocking_states read_state;
 
     uint32_t read_local_id;
 
     /* State variables used in libssh2_channel_write_ex() */
     libssh2_nonblocking_states write_state;
     unsigned char write_packet[13];
     size_t write_packet_len;
     size_t write_bufwrite;
 
     /* State variables used in libssh2_channel_close() */
     libssh2_nonblocking_states close_state;
     unsigned char close_packet[5];
 
     /* State variables used in libssh2_channel_wait_closedeof() */
     libssh2_nonblocking_states wait_eof_state;
 
     /* State variables used in libssh2_channel_wait_closed() */
     libssh2_nonblocking_states wait_closed_state;
 
     /* State variables used in libssh2_channel_free() */
     libssh2_nonblocking_states free_state;
 
     /* State variables used in libssh2_channel_handle_extended_data2() */
     libssh2_nonblocking_states extData2_state;
 
     /* State variables used in libssh2_channel_request_auth_agent() */
     libssh2_nonblocking_states req_auth_agent_try_state;
     libssh2_nonblocking_states req_auth_agent_state;
     unsigned char req_auth_agent_packet[36];
     size_t req_auth_agent_packet_len;
     unsigned char req_auth_agent_local_channel[4];
     packet_requirev_state_t req_auth_agent_requirev_state;
 
     /* State variables used in libssh2_channel_signal_ex() */
     libssh2_nonblocking_states sendsignal_state;
     unsigned char *sendsignal_packet;
     size_t sendsignal_packet_len;
 };
diff --git a/src/packet.c b/src/packet.c
index e3ccf814..cff51489 100644
--- a/src/packet.c
+++ b/src/packet.c
@@ -66,212 +66,212 @@ static inline int
 packet_queue_listener(LIBSSH2_SESSION * session, unsigned char *data,
                       size_t datalen,
                       packet_queue_listener_state_t *listen_state)
 {
     /*
      * Look for a matching listener
      */
     /* 17 = packet_type(1) + channel(4) + reason(4) + descr(4) + lang(4) */
-    size_t packet_len = 17 + (sizeof(FwdNotReq) - 1);
+    size_t packet_len = 17 + strlen(FwdNotReq);
     unsigned char *p;
     LIBSSH2_LISTENER *listn = _libssh2_list_first(&session->listeners);
     char failure_code = SSH_OPEN_ADMINISTRATIVELY_PROHIBITED;
     int rc;
 
     if(listen_state->state == libssh2_NB_state_idle) {
-        size_t offset = (sizeof("forwarded-tcpip") - 1) + 5;
+        size_t offset = strlen("forwarded-tcpip") + 5;
         size_t temp_len = 0;
         struct string_buf buf;
         buf.data = data;
         buf.dataptr = buf.data;
         buf.len = datalen;
 
         if(datalen < offset) {
             return _libssh2_error(session, LIBSSH2_ERROR_OUT_OF_BOUNDARY,
                                   "Unexpected packet size");
         }
 
         buf.dataptr += offset;
 
         if(_libssh2_get_u32(&buf, &(listen_state->sender_channel))) {
             return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
                                   "Data too short extracting channel");
         }
         if(_libssh2_get_u32(&buf, &(listen_state->initial_window_size))) {
             return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
                                   "Data too short extracting window size");
         }
         if(_libssh2_get_u32(&buf, &(listen_state->packet_size))) {
             return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
                                   "Data too short extracting packet");
         }
         if(_libssh2_get_string(&buf, &(listen_state->host), &temp_len)) {
             return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
                                   "Data too short extracting host");
         }
         listen_state->host_len = (uint32_t)temp_len;
 
         if(_libssh2_get_u32(&buf, &(listen_state->port))) {
             return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
                                   "Data too short extracting port");
         }
         if(_libssh2_get_string(&buf, &(listen_state->shost), &temp_len)) {
             return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
                                   "Data too short extracting shost");
         }
         listen_state->shost_len = (uint32_t)temp_len;
 
         if(_libssh2_get_u32(&buf, &(listen_state->sport))) {
             return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
                                   "Data too short extracting sport");
         }
 
         _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                        "Remote received connection from %s:%ld to %s:%ld",
                        listen_state->shost, listen_state->sport,
                        listen_state->host, listen_state->port));
 
         listen_state->state = libssh2_NB_state_allocated;
     }
 
     if(listen_state->state != libssh2_NB_state_sent) {
         while(listn) {
             if((listn->port == (int) listen_state->port) &&
                 (strlen(listn->host) == listen_state->host_len) &&
                 (memcmp (listn->host, listen_state->host,
                          listen_state->host_len) == 0)) {
                 /* This is our listener */
                 LIBSSH2_CHANNEL *channel = NULL;
                 listen_state->channel = NULL;
 
                 if(listen_state->state == libssh2_NB_state_allocated) {
                     if(listn->queue_maxsize &&
                         (listn->queue_maxsize <= listn->queue_size)) {
                         /* Queue is full */
                         failure_code = SSH_OPEN_RESOURCE_SHORTAGE;
                         _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                                        "Listener queue full, ignoring"));
                         listen_state->state = libssh2_NB_state_sent;
                         break;
                     }
 
                     channel = LIBSSH2_CALLOC(session, sizeof(LIBSSH2_CHANNEL));
                     if(!channel) {
                         _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
                                        "Unable to allocate a channel for "
                                        "new connection");
                         failure_code = SSH_OPEN_RESOURCE_SHORTAGE;
                         listen_state->state = libssh2_NB_state_sent;
                         break;
                     }
                     listen_state->channel = channel;
 
                     channel->session = session;
-                    channel->channel_type_len = sizeof("forwarded-tcpip") - 1;
+                    channel->channel_type_len = strlen("forwarded-tcpip");
                     channel->channel_type = LIBSSH2_ALLOC(session,
                                                           channel->
                                                           channel_type_len +
                                                           1);
                     if(!channel->channel_type) {
                         _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
                                        "Unable to allocate a channel for new"
                                        " connection");
                         LIBSSH2_FREE(session, channel);
                         failure_code = SSH_OPEN_RESOURCE_SHORTAGE;
                         listen_state->state = libssh2_NB_state_sent;
                         break;
                     }
                     memcpy(channel->channel_type, "forwarded-tcpip",
                            channel->channel_type_len + 1);
 
                     channel->remote.id = listen_state->sender_channel;
                     channel->remote.window_size_initial =
                         LIBSSH2_CHANNEL_WINDOW_DEFAULT;
                     channel->remote.window_size =
                         LIBSSH2_CHANNEL_WINDOW_DEFAULT;
                     channel->remote.packet_size =
                         LIBSSH2_CHANNEL_PACKET_DEFAULT;
 
                     channel->local.id = _libssh2_channel_nextid(session);
                     channel->local.window_size_initial =
                         listen_state->initial_window_size;
                     channel->local.window_size =
                         listen_state->initial_window_size;
                     channel->local.packet_size = listen_state->packet_size;
 
                     _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                                    "Connection queued: channel %lu/%lu "
                                    "win %lu/%lu packet %lu/%lu",
                                    channel->local.id, channel->remote.id,
                                    channel->local.window_size,
                                    channel->remote.window_size,
                                    channel->local.packet_size,
                                    channel->remote.packet_size));
 
                     p = listen_state->packet;
                     *(p++) = SSH_MSG_CHANNEL_OPEN_CONFIRMATION;
                     _libssh2_store_u32(&p, channel->remote.id);
                     _libssh2_store_u32(&p, channel->local.id);
                     _libssh2_store_u32(&p,
                                        channel->remote.window_size_initial);
                     _libssh2_store_u32(&p, channel->remote.packet_size);
 
                     listen_state->state = libssh2_NB_state_created;
                 }
 
                 if(listen_state->state == libssh2_NB_state_created) {
                     rc = _libssh2_transport_send(session, listen_state->packet,
                                                  17, NULL, 0);
                     if(rc == LIBSSH2_ERROR_EAGAIN)
                         return rc;
                     else if(rc) {
                         listen_state->state = libssh2_NB_state_idle;
                         return _libssh2_error(session, rc,
                                               "Unable to send channel "
                                               "open confirmation");
                     }
 
                     /* Link the channel into the end of the queue list */
                     if(listen_state->channel) {
                         _libssh2_list_add(&listn->queue,
                                           &listen_state->channel->node);
                         listn->queue_size++;
                     }
 
                     listen_state->state = libssh2_NB_state_idle;
                     return 0;
                 }
             }
 
             listn = _libssh2_list_next(&listn->node);
         }
 
         listen_state->state = libssh2_NB_state_sent;
     }
 
     /* We're not listening to you */
     p = listen_state->packet;
     *(p++) = SSH_MSG_CHANNEL_OPEN_FAILURE;
     _libssh2_store_u32(&p, listen_state->sender_channel);
     _libssh2_store_u32(&p, failure_code);
-    _libssh2_store_str(&p, FwdNotReq, sizeof(FwdNotReq) - 1);
+    _libssh2_store_str(&p, FwdNotReq, strlen(FwdNotReq));
     _libssh2_htonu32(p, 0);
 
     rc = _libssh2_transport_send(session, listen_state->packet,
                                  packet_len, NULL, 0);
     if(rc == LIBSSH2_ERROR_EAGAIN) {
         return rc;
     }
     else if(rc) {
         listen_state->state = libssh2_NB_state_idle;
         return _libssh2_error(session, rc, "Unable to send open failure");
 
     }
     listen_state->state = libssh2_NB_state_idle;
     return 0;
 }
 
 /*
  * packet_x11_open
  *
  * Accept a forwarded X11 connection
  */
@@ -279,181 +279,181 @@ static inline int
 packet_x11_open(LIBSSH2_SESSION * session, unsigned char *data,
                 size_t datalen,
                 packet_x11_open_state_t *x11open_state)
 {
     int failure_code = SSH_OPEN_CONNECT_FAILED;
     /* 17 = packet_type(1) + channel(4) + reason(4) + descr(4) + lang(4) */
-    size_t packet_len = 17 + (sizeof(X11FwdUnAvil) - 1);
+    size_t packet_len = 17 + strlen(X11FwdUnAvil);
     unsigned char *p;
     LIBSSH2_CHANNEL *channel = x11open_state->channel;
     int rc;
 
     if(x11open_state->state == libssh2_NB_state_idle) {
 
-        size_t offset = (sizeof("x11") - 1) + 5;
+        size_t offset = strlen("x11") + 5;
         size_t temp_len = 0;
         struct string_buf buf;
         buf.data = data;
         buf.dataptr = buf.data;
         buf.len = datalen;
 
         if(datalen < offset) {
             _libssh2_error(session, LIBSSH2_ERROR_INVAL,
                            "unexpected data length");
             failure_code = SSH_OPEN_CONNECT_FAILED;
             goto x11_exit;
         }
 
         buf.dataptr += offset;
 
         if(_libssh2_get_u32(&buf, &(x11open_state->sender_channel))) {
             _libssh2_error(session, LIBSSH2_ERROR_INVAL,
                            "unexpected sender channel size");
             failure_code = SSH_OPEN_CONNECT_FAILED;
             goto x11_exit;
         }
         if(_libssh2_get_u32(&buf, &(x11open_state->initial_window_size))) {
             _libssh2_error(session, LIBSSH2_ERROR_INVAL,
                            "unexpected window size");
             failure_code = SSH_OPEN_CONNECT_FAILED;
             goto x11_exit;
         }
         if(_libssh2_get_u32(&buf, &(x11open_state->packet_size))) {
             _libssh2_error(session, LIBSSH2_ERROR_INVAL,
                            "unexpected window size");
             failure_code = SSH_OPEN_CONNECT_FAILED;
             goto x11_exit;
         }
         if(_libssh2_get_string(&buf, &(x11open_state->shost), &temp_len)) {
             _libssh2_error(session, LIBSSH2_ERROR_INVAL,
                            "unexpected host size");
             failure_code = SSH_OPEN_CONNECT_FAILED;
             goto x11_exit;
         }
         x11open_state->shost_len = (uint32_t)temp_len;
 
         if(_libssh2_get_u32(&buf, &(x11open_state->sport))) {
             _libssh2_error(session, LIBSSH2_ERROR_INVAL,
                            "unexpected port size");
             failure_code = SSH_OPEN_CONNECT_FAILED;
             goto x11_exit;
         }
 
         _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                        "X11 Connection Received from %s:%ld on channel %lu",
                        x11open_state->shost, x11open_state->sport,
                        x11open_state->sender_channel));
 
         x11open_state->state = libssh2_NB_state_allocated;
     }
 
     if(session->x11) {
         if(x11open_state->state == libssh2_NB_state_allocated) {
             channel = LIBSSH2_CALLOC(session, sizeof(LIBSSH2_CHANNEL));
             if(!channel) {
                 _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
                                "allocate a channel for new connection");
                 failure_code = SSH_OPEN_RESOURCE_SHORTAGE;
                 goto x11_exit;
             }
 
             channel->session = session;
-            channel->channel_type_len = sizeof("x11") - 1;
+            channel->channel_type_len = strlen("x11");
             channel->channel_type = LIBSSH2_ALLOC(session,
                                                   channel->channel_type_len +
                                                   1);
             if(!channel->channel_type) {
                 _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
                                "allocate a channel for new connection");
                 LIBSSH2_FREE(session, channel);
                 failure_code = SSH_OPEN_RESOURCE_SHORTAGE;
                 goto x11_exit;
             }
             memcpy(channel->channel_type, "x11",
                    channel->channel_type_len + 1);
 
             channel->remote.id = x11open_state->sender_channel;
             channel->remote.window_size_initial =
                 LIBSSH2_CHANNEL_WINDOW_DEFAULT;
             channel->remote.window_size = LIBSSH2_CHANNEL_WINDOW_DEFAULT;
             channel->remote.packet_size = LIBSSH2_CHANNEL_PACKET_DEFAULT;
 
             channel->local.id = _libssh2_channel_nextid(session);
             channel->local.window_size_initial =
                 x11open_state->initial_window_size;
             channel->local.window_size = x11open_state->initial_window_size;
             channel->local.packet_size = x11open_state->packet_size;
 
             _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                            "X11 Connection established: channel %lu/%lu "
                            "win %lu/%lu packet %lu/%lu",
                            channel->local.id, channel->remote.id,
                            channel->local.window_size,
                            channel->remote.window_size,
                            channel->local.packet_size,
                            channel->remote.packet_size));
             p = x11open_state->packet;
             *(p++) = SSH_MSG_CHANNEL_OPEN_CONFIRMATION;
             _libssh2_store_u32(&p, channel->remote.id);
             _libssh2_store_u32(&p, channel->local.id);
             _libssh2_store_u32(&p, channel->remote.window_size_initial);
             _libssh2_store_u32(&p, channel->remote.packet_size);
 
             x11open_state->state = libssh2_NB_state_created;
         }
 
         if(x11open_state->state == libssh2_NB_state_created) {
             rc = _libssh2_transport_send(session, x11open_state->packet, 17,
                                          NULL, 0);
             if(rc == LIBSSH2_ERROR_EAGAIN) {
                 return rc;
             }
             else if(rc) {
                 x11open_state->state = libssh2_NB_state_idle;
                 return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_SEND,
                                       "Unable to send channel open "
                                       "confirmation");
             }
 
             /* Link the channel into the session */
             _libssh2_list_add(&session->channels, &channel->node);
 
             /*
              * Pass control to the callback, they may turn right around and
              * free the channel, or actually use it
              */
             LIBSSH2_X11_OPEN(channel, (char *)x11open_state->shost,
                              x11open_state->sport);
 
             x11open_state->state = libssh2_NB_state_idle;
             return 0;
         }
     }
     else
         failure_code = SSH_OPEN_RESOURCE_SHORTAGE;
     /* fall-trough */
 x11_exit:
     p = x11open_state->packet;
     *(p++) = SSH_MSG_CHANNEL_OPEN_FAILURE;
     _libssh2_store_u32(&p, x11open_state->sender_channel);
     _libssh2_store_u32(&p, failure_code);
-    _libssh2_store_str(&p, X11FwdUnAvil, sizeof(X11FwdUnAvil) - 1);
+    _libssh2_store_str(&p, X11FwdUnAvil, strlen(X11FwdUnAvil));
     _libssh2_htonu32(p, 0);
 
     rc = _libssh2_transport_send(session, x11open_state->packet, packet_len,
                                  NULL, 0);
     if(rc == LIBSSH2_ERROR_EAGAIN) {
         return rc;
     }
     else if(rc) {
         x11open_state->state = libssh2_NB_state_idle;
         return _libssh2_error(session, rc, "Unable to send open failure");
     }
     x11open_state->state = libssh2_NB_state_idle;
     return 0;
 }
 
 /*
  * packet_authagent_open
  *
  * Open a connection to authentication agent
  */
@@ -461,154 +461,171 @@ static inline int
 packet_authagent_open(LIBSSH2_SESSION * session,
                       unsigned char *data, size_t datalen,
                       packet_authagent_state_t *authagent_state)
 {
     int failure_code = SSH_OPEN_CONNECT_FAILED;
     /* 17 = packet_type(1) + channel(4) + reason(4) + descr(4) + lang(4) */
-    size_t packet_len = 17 + (sizeof(X11FwdUnAvil) - 1);
+    size_t packet_len = 17 + strlen(X11FwdUnAvil);
     unsigned char *p;
     LIBSSH2_CHANNEL *channel = authagent_state->channel;
     int rc;
+    struct string_buf buf;
+    size_t offset = strlen("auth-agent@openssh.org") + 5;
 
-    (void)datalen;
+    buf.data = data;
+    buf.dataptr = buf.data;
+    buf.len = datalen;
+
+    buf.dataptr += offset;
+
+    if(datalen < offset) {
+        return _libssh2_error(session, LIBSSH2_ERROR_OUT_OF_BOUNDARY,
+                              "Unexpected packet size");
+    }
 
     if(authagent_state->state == libssh2_NB_state_idle) {
-        unsigned char *s = data + (sizeof("auth-agent@openssh.org") - 1) + 5;
-        authagent_state->sender_channel = _libssh2_ntohu32(s);
-        s += 4;
-        authagent_state->initial_window_size = _libssh2_ntohu32(s);
-        s += 4;
-        authagent_state->packet_size = _libssh2_ntohu32(s);
+        if(_libssh2_get_u32(&buf, &(authagent_state->sender_channel))) {
+            return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
+                                  "Data too short extracting channel");
+        }
+        if(_libssh2_get_u32(&buf, &(authagent_state->initial_window_size))) {
+            return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
+                                  "Data too short extracting window size");
+        }
+        if(_libssh2_get_u32(&buf, &(authagent_state->packet_size))) {
+            return _libssh2_error(session, LIBSSH2_ERROR_BUFFER_TOO_SMALL,
+                                  "Data too short extracting packet");
+        }
 
         _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                        "Auth Agent Connection Received on channel %lu",
                        authagent_state->sender_channel));
 
         authagent_state->state = libssh2_NB_state_allocated;
     }
 
     if(session->authagent) {
         if(authagent_state->state == libssh2_NB_state_allocated) {
             channel = LIBSSH2_ALLOC(session, sizeof(LIBSSH2_CHANNEL));
             authagent_state->channel = channel;
 
             if(!channel) {
                 _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
                                "allocate a channel for new connection");
                 failure_code = SSH_OPEN_RESOURCE_SHORTAGE;
                 goto authagent_exit;
             }
             memset(channel, 0, sizeof(LIBSSH2_CHANNEL));
 
             channel->session = session;
-            channel->channel_type_len = sizeof("auth agent") - 1;
+            channel->channel_type_len = strlen("auth agent");
             channel->channel_type = LIBSSH2_ALLOC(session,
                                                   channel->channel_type_len +
                                                   1);
             if(!channel->channel_type) {
                 _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
                                "allocate a channel for new connection");
                 LIBSSH2_FREE(session, channel);
                 failure_code = SSH_OPEN_RESOURCE_SHORTAGE;
                 goto authagent_exit;
             }
             memcpy(channel->channel_type, "auth agent",
                    channel->channel_type_len + 1);
 
             channel->remote.id = authagent_state->sender_channel;
             channel->remote.window_size_initial =
                 LIBSSH2_CHANNEL_WINDOW_DEFAULT;
             channel->remote.window_size = LIBSSH2_CHANNEL_WINDOW_DEFAULT;
             channel->remote.packet_size = LIBSSH2_CHANNEL_PACKET_DEFAULT;
 
             channel->local.id = _libssh2_channel_nextid(session);
             channel->local.window_size_initial =
                 authagent_state->initial_window_size;
             channel->local.window_size = authagent_state->initial_window_size;
             channel->local.packet_size = authagent_state->packet_size;
 
             _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                            "Auth Agent Connection established: channel "
                            "%lu/%lu win %lu/%lu packet %lu/%lu",
                            channel->local.id, channel->remote.id,
                            channel->local.window_size,
                            channel->remote.window_size,
                            channel->local.packet_size,
                            channel->remote.packet_size));
 
             p = authagent_state->packet;
             *(p++) = SSH_MSG_CHANNEL_OPEN_CONFIRMATION;
             _libssh2_store_u32(&p, channel->remote.id);
             _libssh2_store_u32(&p, channel->local.id);
             _libssh2_store_u32(&p, channel->remote.window_size_initial);
             _libssh2_store_u32(&p, channel->remote.packet_size);
 
             authagent_state->state = libssh2_NB_state_created;
         }
 
         if(authagent_state->state == libssh2_NB_state_created) {
             rc = _libssh2_transport_send(session, authagent_state->packet, 17,
                                          NULL, 0);
             if(rc == LIBSSH2_ERROR_EAGAIN) {
                 return rc;
             }
             else if(rc) {
                 authagent_state->state = libssh2_NB_state_idle;
                 return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_SEND,
                                       "Unable to send channel open "
                                       "confirmation");
             }
 
             /* Link the channel into the session */
             _libssh2_list_add(&session->channels, &channel->node);
 
             /* mess with stuff so we don't keep reading the same packet
                over and over */
             session->packet.total_num = 0;
             session->fullpacket_state = libssh2_NB_state_idle;
 
             /* Pass control to the callback, they may turn right around and
                and free the channel, or actually use it */
 
             LIBSSH2_AUTHAGENT(channel);
 
             authagent_state->state = libssh2_NB_state_idle;
             return 0;
         }
     }
     else
         failure_code = SSH_OPEN_RESOURCE_SHORTAGE;
 
     /* fall-through */
 authagent_exit:
     p = authagent_state->packet;
     *(p++) = SSH_MSG_CHANNEL_OPEN_FAILURE;
     _libssh2_store_u32(&p, authagent_state->sender_channel);
     _libssh2_store_u32(&p, failure_code);
-    _libssh2_store_str(&p, AuthAgentUnavail, sizeof(AuthAgentUnavail) - 1);
+    _libssh2_store_str(&p, AuthAgentUnavail, strlen(AuthAgentUnavail));
     _libssh2_htonu32(p, 0);
 
     rc = _libssh2_transport_send(session, authagent_state->packet, packet_len,
                                  NULL, 0);
     if(rc == LIBSSH2_ERROR_EAGAIN) {
         return rc;
     }
     else if(rc) {
         authagent_state->state = libssh2_NB_state_idle;
         return _libssh2_error(session, rc, "Unable to send open failure");
     }
     authagent_state->state = libssh2_NB_state_idle;
     return 0;
 }
 
 /*
  * _libssh2_packet_add
  *
  * Create a new packet and attach it to the brigade. Called from the transport
  * layer when it has received a packet.
  *
  * The input pointer 'data' is pointing to allocated data that this function
  * is asked to deal with so on failure OR success, it must be freed fine.
  * The only exception is when the return code is LIBSSH2_ERROR_EAGAIN.
  *
  * This function will always be called with 'datalen' greater than zero.
  */
@@ -938,239 +955,241 @@ libssh2_packet_add_jump_point5:
                 /* Adjust the window based on the block we just freed */
 libssh2_packet_add_jump_point1:
                 session->packAdd_state = libssh2_NB_state_jump1;
                 rc = _libssh2_channel_receive_window_adjust(session->
                                                             packAdd_channelp,
                                                     (uint32_t)(datalen - 13),
                                                             1, NULL);
                 if(rc == LIBSSH2_ERROR_EAGAIN)
                     return rc;
 
                 session->packAdd_state = libssh2_NB_state_idle;
                 return 0;
             }
 
             /*
              * REMEMBER! remote means remote as source of data,
              * NOT remote window!
              */
             if(channelp->remote.packet_size < (datalen - data_head)) {
                 /*
                  * Spec says we MAY ignore bytes sent beyond
                  * packet_size
                  */
                 _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED,
                                "Packet contains more data than we offered"
                                " to receive, truncating");
                 datalen = channelp->remote.packet_size + data_head;
             }
             if(channelp->remote.window_size <= channelp->read_avail) {
                 /*
                  * Spec says we MAY ignore bytes sent beyond
                  * window_size
                  */
                 _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,
                                "The current receive window is full,"
                                " data ignored");
                 LIBSSH2_FREE(session, data);
                 session->packAdd_state = libssh2_NB_state_idle;
                 return 0;
             }
             /* Reset EOF status */
             channelp->remote.eof = 0;
 
             if(channelp->read_avail + datalen - data_head >
                 channelp->remote.window_size) {
                 _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED,
                                "Remote sent more data than current "
                                "window allows, truncating");
                 datalen = channelp->remote.window_size -
                     channelp->read_avail + data_head;
             }
 
             /* Update the read_avail counter. The window size will be
              * updated once the data is actually read from the queue
              * from an upper layer */
             channelp->read_avail += datalen - data_head;
 
             _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                            "increasing read_avail by %lu bytes to %lu/%lu",
                            (long)(datalen - data_head),
                            (long)channelp->read_avail,
                            (long)channelp->remote.window_size));
 
             break;
 
             /*
               byte      SSH_MSG_CHANNEL_EOF
               uint32    recipient channel
             */
 
         case SSH_MSG_CHANNEL_EOF:
             if(datalen >= 5)
                 channelp =
                     _libssh2_channel_locate(session,
                                             _libssh2_ntohu32(data + 1));
             if(!channelp)
                 /* We may have freed already, just quietly ignore this... */
                 ;
             else {
                 _libssh2_debug((session,
                                LIBSSH2_TRACE_CONN,
                                "EOF received for channel %lu/%lu",
                                channelp->local.id,
                                channelp->remote.id));
                 channelp->remote.eof = 1;
             }
             LIBSSH2_FREE(session, data);
             session->packAdd_state = libssh2_NB_state_idle;
             return 0;
 
             /*
               byte      SSH_MSG_CHANNEL_REQUEST
               uint32    recipient channel
               string    request type in US-ASCII characters only
               boolean   want reply
               ....      type-specific data follows
             */
 
         case SSH_MSG_CHANNEL_REQUEST:
             if(datalen >= 9) {
                 uint32_t channel = _libssh2_ntohu32(data + 1);
                 uint32_t len = _libssh2_ntohu32(data + 5);
                 unsigned char want_reply = 1;
 
                 if((len + 9) < datalen)
                     want_reply = data[len + 9];
 
                 _libssh2_debug((session,
                                LIBSSH2_TRACE_CONN,
                                "Channel %d received request type %.*s (wr %X)",
                                channel, len, data + 9, want_reply));
 
-                if(len == sizeof("exit-status") - 1
-                    && (sizeof("exit-status") - 1 + 9) <= datalen
+                if(len == strlen("exit-status")
+                    && (strlen("exit-status") + 9) <= datalen
                     && !memcmp("exit-status", data + 9,
-                               sizeof("exit-status") - 1)) {
+                               strlen("exit-status"))) {
 
                     /* we've got "exit-status" packet. Set the session value */
                     if(datalen >= 20)
                         channelp =
                             _libssh2_channel_locate(session, channel);
 
-                    if(channelp && (sizeof("exit-status") + 13) <= datalen) {
+                    if(channelp && (strlen("exit-status") + 14) <= datalen) {
                         channelp->exit_status =
-                            _libssh2_ntohu32(data + 9 + sizeof("exit-status"));
+                            _libssh2_ntohu32(data + 10 +
+                                             strlen("exit-status"));
                         _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                                        "Exit status %lu received for "
                                        "channel %lu/%lu",
                                        channelp->exit_status,
                                        channelp->local.id,
                                        channelp->remote.id));
                     }
 
                 }
-                else if(len == sizeof("exit-signal") - 1
-                         && (sizeof("exit-signal") - 1 + 9) <= datalen
+                else if(len == strlen("exit-signal")
+                         && (strlen("exit-signal") + 9) <= datalen
                          && !memcmp("exit-signal", data + 9,
-                                    sizeof("exit-signal") - 1)) {
+                                    strlen("exit-signal"))) {
                     /* command terminated due to signal */
                     if(datalen >= 20)
                         channelp = _libssh2_channel_locate(session, channel);
 
-                    if(channelp && (sizeof("exit-signal") + 13) <= datalen) {
+                    if(channelp && (strlen("exit-signal") + 14) <= datalen) {
                         /* set signal name (without SIG prefix) */
                         uint32_t namelen =
-                            _libssh2_ntohu32(data + 9 + sizeof("exit-signal"));
+                            _libssh2_ntohu32(data + 10 +
+                                             strlen("exit-signal"));
 
                         if(namelen <= UINT_MAX - 1) {
                             channelp->exit_signal =
                                 LIBSSH2_ALLOC(session, namelen + 1);
                         }
                         else {
                             channelp->exit_signal = NULL;
                         }
 
                         if(!channelp->exit_signal)
                             rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
                                                 "memory for signal name");
-                        else if((sizeof("exit-signal") + 13 + namelen <=
+                        else if((strlen("exit-signal") + 14 + namelen <=
                                  datalen)) {
                             memcpy(channelp->exit_signal,
-                                   data + 13 + sizeof("exit-signal"), namelen);
+                                   data + 14 + strlen("exit-signal"), namelen);
                             channelp->exit_signal[namelen] = '\0';
                             /* TODO: save error message and language tag */
                             _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                                            "Exit signal %s received for "
                                            "channel %lu/%lu",
                                            channelp->exit_signal,
                                            channelp->local.id,
                                            channelp->remote.id));
                         }
                     }
                 }
 
 
                 if(want_reply) {
                     unsigned char packet[5];
 libssh2_packet_add_jump_point4:
                     session->packAdd_state = libssh2_NB_state_jump4;
                     packet[0] = SSH_MSG_CHANNEL_FAILURE;
                     memcpy(&packet[1], data + 1, 4);
                     rc = _libssh2_transport_send(session, packet, 5, NULL, 0);
                     if(rc == LIBSSH2_ERROR_EAGAIN)
                         return rc;
                 }
             }
             LIBSSH2_FREE(session, data);
             session->packAdd_state = libssh2_NB_state_idle;
             return rc;
 
             /*
               byte      SSH_MSG_CHANNEL_CLOSE
               uint32    recipient channel
             */
 
         case SSH_MSG_CHANNEL_CLOSE:
             if(datalen >= 5)
                 channelp =
                     _libssh2_channel_locate(session,
                                             _libssh2_ntohu32(data + 1));
             if(!channelp) {
                 /* We may have freed already, just quietly ignore this... */
                 LIBSSH2_FREE(session, data);
                 session->packAdd_state = libssh2_NB_state_idle;
                 return 0;
             }
             _libssh2_debug((session, LIBSSH2_TRACE_CONN,
                            "Close received for channel %lu/%lu",
                            channelp->local.id,
                            channelp->remote.id));
 
             channelp->remote.close = 1;
             channelp->remote.eof = 1;
 
             LIBSSH2_FREE(session, data);
             session->packAdd_state = libssh2_NB_state_idle;
             return 0;
 
             /*
               byte      SSH_MSG_CHANNEL_OPEN
               string    "session"
               uint32    sender channel
               uint32    initial window size
               uint32    maximum packet size
             */
 
         case SSH_MSG_CHANNEL_OPEN:
             if(datalen < 17)
                 ;
-            else if((datalen >= (sizeof("forwarded-tcpip") + 4)) &&
-                     ((sizeof("forwarded-tcpip") - 1) ==
+            else if((datalen >= (strlen("forwarded-tcpip") + 5)) &&
+                     (strlen("forwarded-tcpip") ==
                       _libssh2_ntohu32(data + 1))
                      &&
                      (memcmp(data + 5, "forwarded-tcpip",
-                             sizeof("forwarded-tcpip") - 1) == 0)) {
+                             strlen("forwarded-tcpip")) == 0)) {
 
                 /* init the state struct */
                 memset(&session->packAdd_Qlstn_state, 0,
                        sizeof(session->packAdd_Qlstn_state));
@@ -1178,12 +1197,12 @@ libssh2_packet_add_jump_point4:
 libssh2_packet_add_jump_point2:
                 session->packAdd_state = libssh2_NB_state_jump2;
                 rc = packet_queue_listener(session, data, datalen,
                                            &session->packAdd_Qlstn_state);
             }
-            else if((datalen >= (sizeof("x11") + 4)) &&
-                     ((sizeof("x11") - 1) == _libssh2_ntohu32(data + 1)) &&
-                     (memcmp(data + 5, "x11", sizeof("x11") - 1) == 0)) {
+            else if((datalen >= (strlen("x11") + 5)) &&
+                     ((strlen("x11")) == _libssh2_ntohu32(data + 1)) &&
+                     (memcmp(data + 5, "x11", strlen("x11")) == 0)) {
 
                 /* init the state struct */
                 memset(&session->packAdd_x11open_state, 0,
                        sizeof(session->packAdd_x11open_state));
@@ -1191,14 +1210,14 @@ libssh2_packet_add_jump_point2:
 libssh2_packet_add_jump_point3:
                 session->packAdd_state = libssh2_NB_state_jump3;
                 rc = packet_x11_open(session, data, datalen,
                                      &session->packAdd_x11open_state);
             }
-            else if((datalen >= (sizeof("auth-agent@openssh.com") + 4)) &&
-                    ((sizeof("auth-agent@openssh.com") - 1) ==
+            else if((datalen >= (strlen("auth-agent@openssh.com") + 5)) &&
+                    (strlen("auth-agent@openssh.com") ==
                       _libssh2_ntohu32(data + 1)) &&
                     (memcmp(data + 5, "auth-agent@openssh.com",
-                            sizeof("auth-agent@openssh.com") - 1) == 0)) {
+                            strlen("auth-agent@openssh.com")) == 0)) {
 
                 /* init the state struct */
                 memset(&session->packAdd_authagent_state, 0,
                        sizeof(session->packAdd_authagent_state));
