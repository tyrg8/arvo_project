commit 499d060fb12ecacf83489d62bcf95214d4e8ad0a
Author: Ivan Nardi <12729895+IvanNardi@users.noreply.github.com>
Date:   Mon Aug 14 17:15:20 2023 +0200

    Fix some errors and leaks found while fuzzing locally (#7757)

diff --git a/attic/include/Flow.h b/attic/include/Flow.h
index 81922d9d6..45e412edd 100644
--- a/attic/include/Flow.h
+++ b/attic/include/Flow.h
@@ -72,379 +72,380 @@ typedef enum {
 class Flow : public GenericHashEntry {
  private:
   Host *cli_host, *srv_host;
   u_int16_t cli_port, srv_port;
   u_int16_t vlanId;
   FlowState state;
   u_int8_t protocol, src2dst_tcp_flags, dst2src_tcp_flags;
   struct ndpi_flow_struct *ndpiFlow;
   bool detection_completed, protocol_processed, blacklist_alarm_emitted,
     cli2srv_direction, twh_over, dissect_next_http_packet, passVerdict,
     check_tor, l7_protocol_guessed, flow_alerted,
     good_low_flow_detected, good_ssl_hs,
     quota_exceeded, cli_quota_app_proto, cli_quota_is_category, srv_quota_app_proto, srv_quota_is_category;
   u_int16_t diff_num_http_requests;
 #ifdef NTOPNG_PRO
   FlowProfile *trafficProfile;
   CounterTrend throughputTrend, goodputTrend, thptRatioTrend;
 #endif
   ndpi_protocol ndpiDetectedProtocol;
   void *cli_id, *srv_id;
   char *json_info, *host_server_name, *bt_hash;
   bool dump_flow_traffic, badFlow;
 
   union {
     struct {
       char *last_url, *last_method;
       char *last_content_type;
       u_int16_t last_return_code;
     } http;
 
     struct {
       char *last_query;
     } dns;
 
     struct {
       char *client_signature, *server_signature;
     } ssh;
 
     struct {
       char *certificate, *server_certificate;
       FlowSSLStage cli_stage, srv_stage;
       u_int8_t hs_packets;
       bool is_data;
       /* firstdata refers to the time where encryption is active on both ends */
       bool firstdata_seen;
       struct timeval clienthello_time, hs_end_time, lastdata_time;
       float hs_delta_time, delta_firstData, deltaTime_data;
     } ssl;
 
     struct {
       u_int8_t icmp_type, icmp_code;
     } icmp;
   } protos;
 
   struct {
     struct site_categories category;
     bool categorized_requested;
   } categorization;
 
   /* Process Information */
   ProcessInfo *client_proc, *server_proc;
 
   /* Stats */
   u_int32_t cli2srv_packets, srv2cli_packets;
   u_int64_t cli2srv_bytes, srv2cli_bytes;
   /* https://en.wikipedia.org/wiki/Goodput */
   u_int64_t cli2srv_goodput_bytes, srv2cli_goodput_bytes;
 
   /* TCP stats */
   TCPPacketStats tcp_stats_s2d, tcp_stats_d2s;
   u_int16_t cli2srv_window, srv2cli_window;
 
   time_t doNotExpireBefore; /*
 			       Used for collected flows via ZMQ to make sure that they are not immediately
 			       expired if their last seen time is back in time with respect to ntopng
 			    */
 
   struct timeval synTime, synAckTime, ackTime; /* network Latency (3-way handshake) */
   struct timeval clientNwLatency; /* The RTT/2 between the client and nprobe */
   struct timeval serverNwLatency; /* The RTT/2 between nprobe and the server */
   struct timeval c2sFirstGoodputTime;
   float rttSec, applLatencyMsec;
 
   FlowPacketStats cli2srvStats, srv2cliStats;
   FlowActivityDetection *activityDetection;
 
   /* Counter values at last host update */
   struct {
     u_int32_t cli2srv_packets, srv2cli_packets;
     u_int64_t cli2srv_bytes, srv2cli_bytes;
     u_int64_t cli2srv_goodput_bytes, srv2cli_goodput_bytes;
     u_int32_t last_dump;
   } last_db_dump;
 
 #ifdef NTOPNG_PRO
   struct {
     struct {
       u_int8_t ingress, egress;
     } cli2srv;
 
     struct {
       u_int8_t ingress, egress;
     } srv2cli;
   } flowShaperIds;
 #endif
   struct timeval last_update_time;
 
   float bytes_thpt, goodput_bytes_thpt, top_bytes_thpt, top_goodput_bytes_thpt, top_pkts_thpt;
   float bytes_thpt_cli2srv, goodput_bytes_thpt_cli2srv;
   float bytes_thpt_srv2cli, goodput_bytes_thpt_srv2cli;
   float pkts_thpt, pkts_thpt_cli2srv, pkts_thpt_srv2cli;
   ValueTrend bytes_thpt_trend, goodput_bytes_thpt_trend, pkts_thpt_trend;
   //TimeSeries<float> *bytes_rate;
   u_int64_t cli2srv_last_packets, srv2cli_last_packets,
     prev_cli2srv_last_packets, prev_srv2cli_last_packets;
   u_int64_t cli2srv_last_bytes, srv2cli_last_bytes,
     cli2srv_last_goodput_bytes, srv2cli_last_goodput_bytes,
     prev_cli2srv_last_bytes, prev_srv2cli_last_bytes,
     prev_cli2srv_last_goodput_bytes, prev_srv2cli_last_goodput_bytes;
 
   //  tcpFlags = tp->th_flags, tcpSeqNum = ntohl(tp->th_seq), tcpAckNum = ntohl(tp->th_ack), tcpWin = ntohs(tp->th_win);
   char* intoaV4(unsigned int addr, char* buf, u_short bufLen);
   void processLua(lua_State* vm, ProcessInfo *proc, bool client);
   void processJson(bool is_src, json_object *my_object, ProcessInfo *proc);
   void checkBlacklistedFlow();
   void allocDPIMemory();
   bool checkTor(char *hostname);
   void checkFlowCategory();
   void setBittorrentHash(char *hash);
   bool isLowGoodput();
   void updatePacketStats(InterarrivalStats *stats, const struct timeval *when);
   void dumpPacketStats(lua_State* vm, bool cli2srv_direction);
   inline u_int32_t getCurrentInterArrivalTime(time_t now, bool cli2srv_direction) {
     return(1000 /* msec */
 	   * (now - (cli2srv_direction ? cli2srvStats.pktTime.lastTime.tv_sec : srv2cliStats.pktTime.lastTime.tv_sec)));
   }
   char* printTCPflags(u_int8_t flags, char *buf, u_int buf_len);
   inline bool isProto(u_int16_t p ) { return((ndpi_get_lower_proto(ndpiDetectedProtocol) == p) ? true : false); }
 #ifdef NTOPNG_PRO
   bool updateDirectionShapers(bool src2dst_direction, u_int8_t *ingress_shaper_id, u_int8_t *egress_shaper_id);
 #endif
   void dumpFlowAlert();
   bool skipProtocolFamilyCategorization(u_int16_t proto_id);
 
  public:
   Flow(NetworkInterface *_iface,
        u_int16_t _vlanId, u_int8_t _protocol,
        u_int8_t cli_mac[6], IpAddress *_cli_ip, u_int16_t _cli_port,
        u_int8_t srv_mac[6], IpAddress *_srv_ip, u_int16_t _srv_port,
        time_t _first_seen, time_t _last_seen);
   ~Flow();
 
   FlowStatus getFlowStatus();
   struct site_categories* getFlowCategory(bool force_categorization);
   void categorizeFlow();
   void freeDPIMemory();
   bool isTiny();
   inline bool isSSL()                  { return(isProto(NDPI_PROTOCOL_SSL));  }
   inline bool isSSH()                  { return(isProto(NDPI_PROTOCOL_SSH));  }
   inline bool isDNS()                  { return(isProto(NDPI_PROTOCOL_DNS));  }
   inline bool isHTTP()                 { return(isProto(NDPI_PROTOCOL_HTTP)); }
+  inline bool isHTTP_PROXY()           { return(isProto(NDPI_PROTOCOL_HTTP_PROXY)); }
   inline bool isICMP()                 { return(isProto(NDPI_PROTOCOL_IP_ICMP) || isProto(NDPI_PROTOCOL_IP_ICMPV6)); }
   char* serialize(bool es_json = false);
   json_object* flow2json();
   json_object* flow2es(json_object *flow_object);
   inline u_int8_t getTcpFlags()        { return(src2dst_tcp_flags | dst2src_tcp_flags);  };
   inline u_int8_t getTcpFlagsCli2Srv() { return(src2dst_tcp_flags);                      };
   inline u_int8_t getTcpFlagsSrv2Cli() { return(dst2src_tcp_flags);                      };
 #ifdef NTOPNG_PRO
   bool isPassVerdict();
 #endif
   void setDropVerdict()         { passVerdict = false; };
 
   u_int32_t getPid(bool client);
   u_int32_t getFatherPid(bool client);
   char* get_username(bool client);
   char* get_proc_name(bool client);
   u_int32_t getNextTcpSeq(u_int8_t tcpFlags, u_int32_t tcpSeqNum, u_int32_t payloadLen) ;
   double toMs(const struct timeval *t);
   void timeval_diff(struct timeval *begin, const struct timeval *end, struct timeval *result, u_short divide_by_two);
   inline char* getFlowServerInfo() {
     return (isSSL() && protos.ssl.certificate) ? protos.ssl.certificate : host_server_name;
   }
   inline char* getBitTorrentHash() { return(bt_hash);          };
   inline void  setBTHash(char *h)  { if(!h) return; if(bt_hash) { free(bt_hash); bt_hash = NULL; }; bt_hash = strdup(h); }
   inline void  setServerName(char *v)  { if(host_server_name) free(host_server_name);  host_server_name = strdup(v); }
   void updateTcpFlags(const struct bpf_timeval *when,
 		      u_int8_t flags, bool src2dst_direction);
   void incTcpBadStats(bool src2dst_direction,
           u_int32_t ooo_pkts, u_int32_t retr_pkts, u_int32_t lost_pkts);
 
   void updateTcpSeqNum(const struct bpf_timeval *when,
 		       u_int32_t seq_num, u_int32_t ack_seq_num,
 		       u_int16_t window, u_int8_t flags,
 		       u_int16_t payload_len, bool src2dst_direction);
 
   void updateSeqNum(time_t when, u_int32_t sN, u_int32_t aN);
   void processDetectedProtocol();
   void setDetectedProtocol(ndpi_protocol proto_id, bool forceDetection);
   void setJSONInfo(const char *json);
   bool isFlowPeer(char *numIP, u_int16_t vlanId);
   void incStats(bool cli2srv_direction, u_int pkt_len,
 		u_int8_t *payload, u_int payload_len, u_int8_t l4_proto,
 		const struct timeval *when);
   void updateActivities();
   void addFlowStats(bool cli2srv_direction, u_int in_pkts, u_int in_bytes, u_int in_goodput_bytes,
 		    u_int out_pkts, u_int out_bytes, u_int out_goodput_bytes, time_t last_seen);
   inline bool isDetectionCompleted()              { return(detection_completed);             };
   inline struct ndpi_flow_struct* get_ndpi_flow() { return(ndpiFlow);                        };
   inline void* get_cli_id()                       { return(cli_id);                          };
   inline void* get_srv_id()                       { return(srv_id);                          };
   inline u_int32_t get_cli_ipv4()                 { return(cli_host->get_ip()->get_ipv4());  };
   inline u_int32_t get_srv_ipv4()                 { return(srv_host->get_ip()->get_ipv4());  };
   inline u_int16_t get_cli_port()                 { return(ntohs(cli_port));                 };
   inline u_int16_t get_srv_port()                 { return(ntohs(srv_port));                 };
   inline u_int16_t get_vlan_id()                  { return(vlanId);                          };
   inline u_int8_t  get_protocol()                 { return(protocol);                        };
   inline u_int64_t get_bytes()                    { return(cli2srv_bytes+srv2cli_bytes);     };
   inline u_int64_t get_bytes_cli2srv()            { return(cli2srv_bytes);                   };
   inline u_int64_t get_bytes_srv2cli()            { return(srv2cli_bytes);                   };
   inline u_int64_t get_goodput_bytes()            { return(cli2srv_goodput_bytes+srv2cli_goodput_bytes);     };
   inline u_int64_t get_packets()                  { return(cli2srv_packets+srv2cli_packets); };
   inline u_int64_t get_packets_cli2srv()          { return(cli2srv_packets);                 };
   inline u_int64_t get_packets_srv2cli()          { return(srv2cli_packets);                 };
   inline u_int64_t get_partial_bytes()            { return(get_bytes() - (last_db_dump.cli2srv_bytes+last_db_dump.srv2cli_bytes));       };
   inline u_int64_t get_partial_bytes_cli2srv()    { return(cli2srv_bytes - last_db_dump.cli2srv_bytes);       };
   inline u_int64_t get_partial_bytes_srv2cli()    { return(srv2cli_bytes - last_db_dump.srv2cli_bytes);       };
   inline u_int64_t get_partial_packets_cli2srv()  { return(cli2srv_packets - last_db_dump.cli2srv_packets);   };
   inline u_int64_t get_partial_packets_srv2cli()  { return(srv2cli_packets - last_db_dump.srv2cli_packets);   };
   inline u_int64_t get_partial_goodput_bytes()    { return(get_goodput_bytes() - (last_db_dump.cli2srv_goodput_bytes+last_db_dump.srv2cli_goodput_bytes));       };
   inline u_int64_t get_partial_packets()          { return(get_packets() - (last_db_dump.cli2srv_packets+last_db_dump.srv2cli_packets)); };
   inline float get_bytes_thpt()                   { return(bytes_thpt);                      };
   inline float get_goodput_bytes_thpt()           { return(goodput_bytes_thpt);              };
 
   inline time_t get_partial_first_seen()          { return(last_db_dump.last_dump == 0 ? get_first_seen() : last_db_dump.last_dump); };
   inline time_t get_partial_last_seen()           { return(get_last_seen()); };
   inline u_int32_t get_duration()                 { return((u_int32_t)(get_last_seen()-get_first_seen())); };
   inline char* get_protocol_name()                { return(Utils::l4proto2name(protocol));   };
   inline ndpi_protocol get_detected_protocol()    { return(ndpiDetectedProtocol);          };
   void fixAggregatedFlowFields();
   inline bool isCategorizationOngoing()           { return(categorization.categorized_requested); };
   inline ndpi_protocol_category_t get_detected_protocol_category() { return ndpi_get_proto_category(iface->get_ndpi_struct(), ndpiDetectedProtocol); };
   inline Host* get_cli_host()                     { return(cli_host);                        };
   inline Host* get_srv_host()                     { return(srv_host);                        };
   inline char* get_json_info()			  { return(json_info);                       };
   inline ndpi_protocol_breed_t get_protocol_breed() { return(ndpi_get_proto_breed(iface->get_ndpi_struct(), ndpiDetectedProtocol.app_protocol)); };
   inline char* get_protocol_breed_name()            { return(ndpi_get_proto_breed_name(iface->get_ndpi_struct(),
 										       ndpi_get_proto_breed(iface->get_ndpi_struct(),
 													    ndpiDetectedProtocol.app_protocol))); };
   char* get_detected_protocol_name(char *buf, u_int buf_len) {
     return(ndpi_protocol2name(iface->get_ndpi_struct(), ndpiDetectedProtocol, buf, buf_len));
   }
 
   u_int32_t get_packetsLost();
   u_int32_t get_packetsRetr();
   u_int32_t get_packetsOOO();
 
   u_int64_t get_current_bytes_cli2srv();
   u_int64_t get_current_bytes_srv2cli();
   u_int64_t get_current_goodput_bytes_cli2srv();
   u_int64_t get_current_goodput_bytes_srv2cli();
   u_int64_t get_current_packets_cli2srv();
   u_int64_t get_current_packets_srv2cli();
   void handle_process(ProcessInfo *pinfo, bool client_process);
   inline bool idle() { return(false); } /* Idle flows are checked in Flow::update_hosts_stats */
   bool isReadyToPurge();
   inline bool is_l7_protocol_guessed() { return(l7_protocol_guessed); };
   char* print(char *buf, u_int buf_len);
   void update_hosts_stats(struct timeval *tv);
 #ifdef NTOPNG_PRO
   void update_pools_stats(const struct timeval *tv,
 			  u_int64_t diff_sent_packets, u_int64_t diff_sent_bytes,
 			  u_int64_t diff_rcvd_packets, u_int64_t diff_rcvd_bytes);
 #endif
   u_int32_t key();
   static u_int32_t key(Host *cli, u_int16_t cli_port,
 		       Host *srv, u_int16_t srv_port,
 		       u_int16_t vlan_id,
 		       u_int16_t protocol);
   void lua(lua_State* vm, AddressTree * ptree, DetailsLevel details_level, bool asListElement);
   bool equal(u_int8_t *src_eth, u_int8_t *dst_eth,
 	     IpAddress *_cli_ip, IpAddress *_srv_ip,
 	     u_int16_t _cli_port, u_int16_t _srv_port,
 	     u_int16_t _vlanId, u_int8_t _protocol,
 	     bool *src2srv_direction);
   void sumStats(nDPIStats *stats);
   void guessProtocol();
   bool dumpFlow(bool idle_flow);
   bool dumpFlowTraffic(void);
   bool match(AddressTree *ptree);
   inline Host* get_real_client() { return(cli2srv_direction ? cli_host : srv_host); }
   inline Host* get_real_server() { return(cli2srv_direction ? srv_host : cli_host); }
   inline bool isBadFlow()        { return(badFlow); }
   inline bool isSuspiciousFlowThpt();
   void dissectSSL(u_int8_t *payload, u_int16_t payload_len, const struct bpf_timeval *when, bool cli2srv);
   void dissectHTTP(bool src2dst_direction, char *payload, u_int16_t payload_len);
   void dissectBittorrent(char *payload, u_int16_t payload_len);
   void updateInterfaceLocalStats(bool src2dst_direction, u_int num_pkts, u_int pkt_len);
   inline void setICMP(bool src2dst_direction, u_int8_t icmp_type, u_int8_t icmp_code) {
     if(isICMP()) {
       protos.icmp.icmp_type = icmp_type, protos.icmp.icmp_code = icmp_code;
       if(get_cli_host()) get_cli_host()->incICMP(icmp_type, icmp_code, src2dst_direction ? true : false, get_srv_host());
       if(get_srv_host()) get_srv_host()->incICMP(icmp_type, icmp_code, src2dst_direction ? false : true, get_cli_host());
     }
   }
   inline char* getDNSQuery()        { return(isDNS() ? protos.dns.last_query : (char*)"");  }
   inline void  setDNSQuery(char *v) { if(isDNS()) { if(protos.dns.last_query) free(protos.dns.last_query);  protos.dns.last_query = strdup(v); } }
   inline char* getHTTPURL()         { return(isHTTP() ? protos.http.last_url : (char*)"");   }
   inline void  setHTTPURL(char *v)  { if(isHTTP()) { if(protos.http.last_url) free(protos.http.last_url);  protos.http.last_url = strdup(v); } }
   inline char* getHTTPContentType() { return(isHTTP() ? protos.http.last_content_type : (char*)"");   }
   inline char* getSSLCertificate()  { return(isSSL() ? protos.ssl.certificate : (char*)""); }
   bool isSSLProto();
   inline bool isSSLData()              { return(isSSLProto() && good_ssl_hs && protos.ssl.is_data);  }
   inline bool isSSLHandshake()         { return(isSSLProto() && good_ssl_hs && !protos.ssl.is_data); }
   inline bool hasSSLHandshakeEnded()   { return(getSSLEncryptionStatus() == SSL_ENCRYPTION_BOTH);    }
   FlowSSLEncryptionStatus getSSLEncryptionStatus();
   void setDumpFlowTraffic(bool what)   { dump_flow_traffic = what; }
   bool getDumpFlowTraffic(void)        { return dump_flow_traffic; }
 #ifdef NTOPNG_PRO
   inline void updateProfile()     { trafficProfile = iface->getFlowProfile(this); }
   inline char* get_profile_name() { return(trafficProfile ? trafficProfile->getName() : (char*)"");}
   void updateFlowShapers();
   void recheckQuota();
 #endif
   inline float getFlowRTT() { return(rttSec); }
   /* http://bradhedlund.com/2008/12/19/how-to-calculate-tcp-throughput-for-long-distance-links/ */
   inline float getCli2SrvMaxThpt() { return(rttSec ? ((float)(cli2srv_window*8)/rttSec) : 0); }
   inline float getSrv2CliMaxThpt() { return(rttSec ? ((float)(srv2cli_window*8)/rttSec) : 0); }
 
   inline u_int32_t getCli2SrvCurrentInterArrivalTime(time_t now) { return(getCurrentInterArrivalTime(now, true));  }
   inline u_int32_t getSrv2CliCurrentInterArrivalTime(time_t now) { return(getCurrentInterArrivalTime(now, false)); }
 
   inline u_int32_t getCli2SrvMinInterArrivalTime()  { return(cli2srvStats.pktTime.min_ms); }
   inline u_int32_t getCli2SrvMaxInterArrivalTime()  { return(cli2srvStats.pktTime.max_ms); }
   inline u_int32_t getCli2SrvAvgInterArrivalTime()  { return((cli2srv_packets < 2) ? 0 : cli2srvStats.pktTime.total_delta_ms / (cli2srv_packets-1)); }
   inline u_int32_t getSrv2CliMinInterArrivalTime()  { return(srv2cliStats.pktTime.min_ms); }
   inline u_int32_t getSrv2CliMaxInterArrivalTime()  { return(srv2cliStats.pktTime.max_ms); }
   inline u_int32_t getSrv2CliAvgInterArrivalTime()  { return((srv2cli_packets < 2) ? 0 : srv2cliStats.pktTime.total_delta_ms / (srv2cli_packets-1)); }
   bool isIdleFlow();
   inline FlowState getFlowState()                   { return(state);                          }
   inline bool      isEstablished()                  { return state == flow_state_established; }
   inline bool      isFlowAlerted()                  { return(flow_alerted);                   }
   inline void      setFlowAlerted()                 { flow_alerted = true;                    }
 
   void setActivityFilter(ActivityFilterID fid, const activity_filter_config * config);
 
   inline bool getActivityFilterId(ActivityFilterID *out) {
     if(activityDetection && activityDetection->filterSet) {
         *out = activityDetection->filterId; return true;
     }
     return false;
   }
 
   bool invokeActivityFilter(const struct timeval *when, bool cli2srv, u_int16_t payload_len);
 
   inline void setActivityId(UserActivityID id) {
     if(activityDetection == NULL) return;
     activityDetection->activityId = id; activityDetection->activitySet = true;
   }
 
   inline bool getActivityId(UserActivityID *out) {
     if(activityDetection == NULL) return false;
     if(activityDetection->activitySet) {
       *out = activityDetection->activityId; return true;
     }
     return false;
   }
 
 #ifdef NTOPNG_PRO
   void getFlowShapers(bool src2dst_direction, u_int8_t *shaper_ingress, u_int8_t *shaper_egress) {
     if(src2dst_direction)
       *shaper_ingress = flowShaperIds.cli2srv.ingress, *shaper_egress = flowShaperIds.cli2srv.egress;
     else
       *shaper_ingress = flowShaperIds.srv2cli.ingress, *shaper_egress = flowShaperIds.srv2cli.egress;
   }
 #endif
 };
 
 #endif /* _FLOW_H_ */
diff --git a/fuzz/fuzz_dissect_packet.cpp b/fuzz/fuzz_dissect_packet.cpp
index 8b71db438..08f9bb571 100644
--- a/fuzz/fuzz_dissect_packet.cpp
+++ b/fuzz/fuzz_dissect_packet.cpp
@@ -173,36 +173,36 @@ DEFINE_PROTO_FUZZER(const ntopng_fuzz::Pcap &message) {
 extern "C" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {
     if (len == 0) return -1;
 
     FILE *fd = fmemopen((void *)buf, len, "r");
     if (fd == NULL) {
         std::cerr << "Cannot create the file descriptor with fmemopen"
                   << std::endl;
         return -1;
     }
 
     char pcap_error_buffer[PCAP_ERRBUF_SIZE];
     pcap_t *pcap_handle;
     const u_char *pkt;
     struct pcap_pkthdr *hdr;
     u_int16_t p;
     Host *srcHost = NULL, *dstHost = NULL;
     Flow *flow = NULL;
 
     pcap_handle = pcap_fopen_offline(fd, pcap_error_buffer);
     if (pcap_handle == NULL) goto end;
     iface->set_datalink(pcap_datalink(pcap_handle));
     pcap_setnonblock(pcap_handle, 1, pcap_error_buffer);
 
     while (pcap_next_ex(pcap_handle, &hdr, &pkt) > 0) {
         iface->dissectPacket(DUMMY_BRIDGE_INTERFACE_ID, true, NULL, hdr, pkt,
                              &p, &srcHost, &dstHost, &flow);
     }
+    pcap_close(pcap_handle);
 
 end:
-    fclose(fd);
     iface->cleanup();
 
     return 0;
 }
 
 #endif
diff --git a/include/Flow.h b/include/Flow.h
index 774880a8c..0c069dd98 100644
--- a/include/Flow.h
+++ b/include/Flow.h
@@ -38,1307 +38,1308 @@ class FlowCheck;
 class Flow : public GenericHashEntry {
  private:
   Host *cli_host, *srv_host;
   IpAddress *cli_ip_addr, *srv_ip_addr;
   ICMPinfo *icmp_info;
   u_int32_t privateFlowId /* Used to store specific flow info such as DNS
                              TransactionId */
       ;
   u_int8_t cli2srv_tos, srv2cli_tos; /* RFC 2474, 3168 */
   u_int16_t cli_port, srv_port;
   u_int16_t vlanId;
   u_int32_t vrfId;
   u_int32_t srcAS, dstAS, prevAdjacentAS, nextAdjacentAS;
   u_int32_t protocolErrorCode;
   u_int8_t protocol, src2dst_tcp_flags, dst2src_tcp_flags, flow_verdict;
   u_int16_t flow_score;
   u_int8_t view_cli_mac[6], view_srv_mac[6];
   struct ndpi_flow_struct *ndpiFlow;
   ndpi_risk ndpi_flow_risk_bitmap;
   /* The bitmap of all possible flow alerts set by FlowCheck subclasses.
      When no alert is set, the flow is in flow_alert_normal.
 
      A flow can have multiple alerts but at most ONE of its alerts is
      predominant of a flow, which is written into `predominant_alert`.
   */
   Bitmap128 alerts_map;
   FlowAlertType predominant_alert;   /* This is the predominant alert */
   u_int16_t predominant_alert_score; /* The score associated to the predominant
                                         alert */
   struct {
     u_int8_t is_cli_attacker : 1, is_cli_victim : 1, is_srv_attacker : 1,
         is_srv_victim : 1, auto_acknowledge : 1;
   } predominant_alert_info;
 
   char *json_protocol_info, *riskInfo;
 
   /* Calculate the entropy on the first MAX_ENTROPY_BYTES bytes */
   struct {
     struct ndpi_analyze_struct *c2s, *s2c;
   } initial_bytes_entropy;
 
   u_int32_t hash_entry_id; /* Uniquely identify this Flow inside the flows_hash
                               hash table */
 
   u_int16_t detection_completed : 1, extra_dissection_completed : 1,
       twh_over : 1, twh_ok : 1, dissect_next_http_packet : 1, passVerdict : 1,
       flow_dropped_counts_increased : 1, quota_exceeded : 1, swap_done : 1,
       swap_requested : 1, has_malicious_cli_signature : 1,
       has_malicious_srv_signature : 1, src2dst_tcp_zero_window : 1,
       dst2src_tcp_zero_window : 1, non_zero_payload_observed : 1,
       is_periodic_flow : 1;
 
   ndpi_multimedia_flow_type rtp_stream_type;
 #ifdef ALERTED_FLOWS_DEBUG
   bool iface_alert_inc, iface_alert_dec;
 #endif
 #ifdef NTOPNG_PRO
   bool ingress2egress_direction;
   bool lateral_movement;
   PeriodicityStatus periodicity_status;
 #ifndef HAVE_NEDGE
   FlowProfile *trafficProfile;
 #else
   u_int8_t routing_table_id;
   u_int16_t cli2srv_in, cli2srv_out, srv2cli_in, srv2cli_out;
   L7PolicySource_t cli_quota_source, srv_quota_source;
 #endif
   CounterTrend throughputTrend, goodputTrend, thptRatioTrend;
 #endif
   char *ndpiAddressFamilyProtocol;
   ndpi_protocol ndpiDetectedProtocol;
   custom_app_t custom_app;
 
   struct {
     bool alertTriggered;
     u_int8_t score;
     char *msg;
   } customFlowAlert;
   json_object *json_info;
   ndpi_serializer *tlv_info;
   ndpi_confidence_t confidence;
   char *host_server_name, *bt_hash;
   IEC104Stats *iec104;
 #ifdef NTOPNG_PRO
   ModbusStats *modbus;
 #endif
   char *suspicious_dga_domain; /* Stores the suspicious DGA domain for flows
                                   with NDPI_SUSPICIOUS_DGA_DOMAIN */
   OSType operating_system;
 #ifdef HAVE_NEDGE
   u_int32_t last_conntrack_update;
   u_int32_t marker;
 #endif
   struct {
     char *source;
     json_object *json;
   } external_alert;
   bool
       trigger_immediate_periodic_update; /* needed to process external alerts */
   time_t next_call_periodic_update; /* The time at which the periodic lua script
                                        on this flow shall be called */
 
   /* Flow payload */
   u_int16_t flow_payload_len;
   char *flow_payload;
 
   union {
     struct {
       char *last_url, *last_user_agent, *last_server;
       ndpi_http_method last_method;
       u_int16_t last_return_code;
     } http;
 
     struct {
       char *last_query;
       char *last_query_shadow;
       time_t
           last_query_update_time; /* The time when the last query was updated */
       u_int16_t last_query_type;
       u_int16_t last_return_code;
     } dns;
 
     struct {
       char *name, *name_txt, *ssid;
       char *answer;
     } mdns;
 
     struct {
       char *location;
     } ssdp;
 
     struct {
       char *name;
     } netbios;
 
     struct {
       char *client_signature, *server_signature;
       struct {
         /* https://engineering.salesforce.com/open-sourcing-hassh-abed3ae5044c
          */
         char *client_hash, *server_hash;
       } hassh;
     } ssh;
 
     struct {
       u_int16_t tls_version;
       u_int32_t notBefore, notAfter;
       char *client_alpn, *client_tls_supported_versions, *issuerDN, *subjectDN;
       char *client_requested_server_name, *server_names;
       /* Certificate dissection */
       struct {
         /* https://engineering.salesforce.com/tls-fingerprinting-with-ja3-and-ja3s-247362855967
          */
         char *client_hash, *server_hash;
         u_int16_t server_cipher;
         ndpi_cipher_weakness server_unsafe_cipher;
       } ja3;
     } tls;
 
     struct {
       struct {
         u_int8_t icmp_type, icmp_code;
       } cli2srv, srv2cli;
       u_int16_t max_icmp_payload_size;
 
       struct {
         float min_entropy, max_entropy;
       } client_to_server;
     } icmp;
   } protos;
 
   struct {
     u_int32_t device_ip;
     u_int32_t in_index, out_index;
     u_int16_t observation_point_id;
   } flow_device;
 
   /* eBPF Information */
   ParsedeBPF *ebpf;
 
   /* Stats */
   FlowTrafficStats stats;
 
   /* IP stats */
   IPPacketStats ip_stats_s2d, ip_stats_d2s;
 
   /* TCP stats */
   TCPSeqNum tcp_seq_s2d, tcp_seq_d2s;
   u_int16_t cli2srv_window, srv2cli_window;
 
   struct timeval synTime, synAckTime,
       ackTime;                    /* network Latency (3-way handshake) */
   struct timeval clientNwLatency; /* The RTT/2 between the client and nprobe */
   struct timeval serverNwLatency; /* The RTT/2 between nprobe and the server */
   struct timeval c2sFirstGoodputTime;
   float rttSec, applLatencyMsec;
 
   InterarrivalStats *cli2srvPktTime, *srv2cliPktTime;
 
   /* Counter values at last host update */
   struct {
     PartializableFlowTrafficStats *partial;
     PartializableFlowTrafficStats delta;
     time_t first_seen, last_seen;
     bool in_progress; /* Set to true when the flow is enqueued to be dumped */
   } last_db_dump;
 
   /* Lazily initialized and used by a possible view interface */
   ViewInterfaceFlowStats *viewFlowStats;
 
   /* Partial used to periodically update stats out of flows */
   PartializableFlowTrafficStats *periodic_stats_update_partial;
 
 #ifdef HAVE_NEDGE
   struct {
     struct {
       TrafficShaper *ingress, *egress;
     } cli2srv;
 
     struct {
       TrafficShaper *ingress, *egress;
     } srv2cli;
   } flowShaperIds;
 #endif
   struct timeval last_update_time;
 
   float top_bytes_thpt, top_goodput_bytes_thpt, top_pkts_thpt;
   float bytes_thpt_cli2srv, goodput_bytes_thpt_cli2srv;
   float bytes_thpt_srv2cli, goodput_bytes_thpt_srv2cli;
   float pkts_thpt_cli2srv, pkts_thpt_srv2cli;
   ValueTrend bytes_thpt_trend, goodput_bytes_thpt_trend, pkts_thpt_trend;
 
   /*
      IMPORTANT NOTE
 
      if you add a new 'directional' field such as cliX and serverX
      you need to handle it in the Flow::swap() method
   */
 
   void deferredInitialization();
   char *intoaV4(unsigned int addr, char *buf, u_short bufLen);
   void allocDPIMemory();
   bool checkTor(char *hostname);
   void setBittorrentHash(char *hash);
   void updateThroughputStats(float tdiff_msec, u_int32_t diff_sent_packets,
                              u_int64_t diff_sent_bytes,
                              u_int64_t diff_sent_goodput_bytes,
                              u_int32_t diff_rcvd_packets,
                              u_int64_t diff_rcvd_bytes,
                              u_int64_t diff_rcvd_goodput_bytes);
   static void updatePacketStats(InterarrivalStats *stats,
                                 const struct timeval *when, bool update_iat);
   char *printTCPState(char *const buf, u_int buf_len) const;
   void update_pools_stats(NetworkInterface *iface, Host *cli_host,
                           Host *srv_host, const struct timeval *tv,
                           u_int64_t diff_sent_packets,
                           u_int64_t diff_sent_bytes,
                           u_int64_t diff_rcvd_packets,
                           u_int64_t diff_rcvd_bytes) const;
   /*
     Check (and possibly enqueues) the flow for dump
    */
   void dumpCheck(time_t t, bool last_dump_before_free);
   void updateCliJA3();
   void updateSrvJA3();
   void updateHASSH(bool as_client);
   void processExtraDissectedInformation();
   void processDetectedProtocol(
       u_int8_t *payload, u_int16_t payload_len); /* nDPI detected protocol */
   void processDetectedProtocolData(); /* nDPI detected protocol data (e.g.,
                                          ndpiFlow->host_server_name) */
   void setExtraDissectionCompleted();
   void setProtocolDetectionCompleted(u_int8_t *payload, u_int16_t payload_len);
   void updateProtocol(ndpi_protocol proto_id);
   const char *cipher_weakness2str(ndpi_cipher_weakness w) const;
   bool get_partial_traffic_stats(PartializableFlowTrafficStats **dst,
                                  PartializableFlowTrafficStats *delta,
                                  bool *first_partial) const;
   void lua_tos(lua_State *vm);
   void lua_confidence(lua_State *vm);
   void updateEntropy(struct ndpi_analyze_struct *e, u_int8_t *payload,
                      u_int payload_len);
   void lua_entropy(lua_State *vm);
   void luaScore(lua_State *vm);
   void luaIEC104(lua_State *vm);
   void callFlowUpdate(time_t t);
   /*
     Method to trigger alerts, synchronous or asynchronous, depending on the last
     argument.
     - Asynchronous: The alerts bitmap is updated and the predominant alert is
     possibly updated. Recipients enqueue is not performed.
     - Synchronous:  The alerts bitmap is updated and the predominant alert is
     possibly updated. Immediate alert JSON generation and enqueue to the
     recipients are performed as well.
    */
   bool setAlertsBitmap(FlowAlertType alert_type, u_int16_t cli_inc,
                        u_int16_t srv_inc, bool async);
   void setNormalToAlertedCounters();
   /* Decreases scores on both client and server hosts when the flow is being
    * destructed */
   void decAllFlowScores();
   void updateServerPortsStats(Host *server_host, ndpi_protocol *proto);
   void updateClientContactedPorts(Host *client, ndpi_protocol *proto);
   void updateTCPHostServices(Host *cli_h, Host *srv_h);
   void updateUDPHostServices();
 
  public:
   Flow(NetworkInterface *_iface, u_int16_t _u_int16_t,
        u_int16_t _observation_point_id, u_int32_t _private_flow_id,
        u_int8_t _protocol, Mac *_cli_mac, IpAddress *_cli_ip,
        u_int16_t _cli_port, Mac *_srv_mac, IpAddress *_srv_ip,
        u_int16_t _srv_port, const ICMPinfo *const icmp_info, time_t _first_seen,
        time_t _last_seen, u_int8_t *_view_cli_mac, u_int8_t *_view_srv_mac);
   ~Flow();
 
   inline Bitmap128 getAlertsBitmap() const { return (alerts_map); }
 
   /* Enqueues an alert to all available flow recipients. */
   bool enqueueAlertToRecipients(FlowAlert *alert);
 
   /*
     Called by FlowCheck subclasses to trigger a flow alert. This is an
     asynchronous call, faster, but can cause the alert JSON to be generated
     after the call. The FlowCheck should implement the buildAlert() method which
     is called in the predominant check to actually build the FlowAlert object.
    */
   bool triggerAlertAsync(FlowAlertType alert_type, u_int16_t cli_score_inc,
                          u_int16_t srv_score_inc);
 
   /*
      Called by FlowCheck subclasses to trigger a flow alert. This is a
      syncrhonous call, more expensive, but causes the alert (FlowAlert) to be
      immediately enqueued to all recipients.
    */
   bool triggerAlertSync(FlowAlert *alert, u_int16_t cli_score_inc,
                         u_int16_t srv_score_inc);
 
   /*
     Enqueues the predominant alert of the flow to all available flow recipients.
    */
   void enqueuePredominantAlert();
 
   inline void setFlowVerdict(u_int8_t _flow_verdict) {
     flow_verdict = _flow_verdict;
   };
 
   inline void setPredominantAlert(FlowAlertType alert_type, u_int16_t score);
   inline FlowAlertType getPredominantAlert() const {
     return predominant_alert;
   };
   inline u_int16_t getPredominantAlertScore() const {
     return predominant_alert_score;
   };
   inline AlertLevel getPredominantAlertSeverity() const {
     return Utils::mapScoreToSeverity(predominant_alert_score);
   };
   inline bool isFlowAlerted() const {
     return (predominant_alert.id != flow_alert_normal);
   };
 
   void setPredominantAlertInfo(FlowAlert *alert);
   inline bool isPredominantAlertAutoAck() {
     return !!predominant_alert_info.auto_acknowledge;
   };
   inline u_int8_t isClientAttacker() {
     return predominant_alert_info.is_cli_attacker;
   };
   inline u_int8_t isClientVictim() {
     return predominant_alert_info.is_cli_victim;
   };
   inline u_int8_t isServerAttacker() {
     return predominant_alert_info.is_srv_attacker;
   };
   inline u_int8_t isServerVictim() {
     return predominant_alert_info.is_srv_victim;
   };
   inline char *getProtocolInfo() { return json_protocol_info; };
 
   void setProtocolJSONInfo();
   void getProtocolJSONInfo(ndpi_serializer *serializer);
 
   inline char *getJa3CliHash() { return (protos.tls.ja3.client_hash); }
 
   bool isBlacklistedFlow() const;
   bool isBlacklistedClient() const;
   bool isBlacklistedServer() const;
   struct site_categories *getFlowCategory(bool force_categorization);
   void freeDPIMemory();
   static const ndpi_protocol ndpiUnknownProtocol;
   bool isTiny() const;
   inline bool isProto(u_int16_t p) const {
     return (((ndpiDetectedProtocol.master_protocol == p) ||
              (ndpiDetectedProtocol.app_protocol == p))
                 ? true
                 : false);
   }
   bool isTLS() const;
   inline bool isEncryptedProto() const {
     return (ndpi_is_encrypted_proto(iface->get_ndpi_struct(),
                                     ndpiDetectedProtocol));
   }
   inline bool isSSH() const { return (isProto(NDPI_PROTOCOL_SSH)); }
   inline bool isDNS() const { return (isProto(NDPI_PROTOCOL_DNS)); }
   inline bool isZoomRTP() const {
     return (isProto(NDPI_PROTOCOL_ZOOM) && (isProto(NDPI_PROTOCOL_RTP) || isProto(NDPI_PROTOCOL_SRTP)) );
   }
   inline bool isIEC60870() const { return (isProto(NDPI_PROTOCOL_IEC60870)); }
   inline bool isModbus()   const { return (isProto(NDPI_PROTOCOL_MODBUS));   }
   inline bool isMDNS() const { return (isProto(NDPI_PROTOCOL_MDNS)); }
   inline bool isSSDP() const { return (isProto(NDPI_PROTOCOL_SSDP)); }
   inline bool isNetBIOS() const { return (isProto(NDPI_PROTOCOL_NETBIOS)); }
   inline bool isDHCP() const { return (isProto(NDPI_PROTOCOL_DHCP)); }
   inline bool isNTP() const { return (isProto(NDPI_PROTOCOL_NTP)); }
   inline bool isSMTP() const {
     return (isProto(NDPI_PROTOCOL_MAIL_SMTP) ||
             isProto(NDPI_PROTOCOL_MAIL_SMTPS));
   }
   inline bool isHTTP() const { return (isProto(NDPI_PROTOCOL_HTTP)); }
+  inline bool isHTTP_PROXY() const { return (isProto(NDPI_PROTOCOL_HTTP_PROXY)); }
   inline bool isICMP() const {
     return (isProto(NDPI_PROTOCOL_IP_ICMP) || isProto(NDPI_PROTOCOL_IP_ICMPV6));
   }
   inline bool isBittorrent() const {
     return (isProto(NDPI_PROTOCOL_BITTORRENT));
   }
 
 #if defined(NTOPNG_PRO)
   inline bool isLateralMovement() const { return (lateral_movement); }
   inline void setLateralMovement(bool change) { lateral_movement = change; }
   PeriodicityStatus getPeriodicity() const { return (periodicity_status); }
   inline void setPeriodicity(PeriodicityStatus _periodicity_status) {
     periodicity_status = _periodicity_status;
   }
 #endif
 
   inline bool isCliDeviceAllowedProtocol() const {
     return !cli_host ||
            cli_host->getDeviceAllowedProtocolStatus(
                get_detected_protocol(), true) == device_proto_allowed;
   }
   inline bool isSrvDeviceAllowedProtocol() const {
     return !srv_host ||
            get_bytes_srv2cli() ==
                0 /* Server must respond to be considered NOT allowed */
            || srv_host->getDeviceAllowedProtocolStatus(
                   get_detected_protocol(), false) == device_proto_allowed;
   }
   inline bool isDeviceAllowedProtocol() const {
     return isCliDeviceAllowedProtocol() && isSrvDeviceAllowedProtocol();
   }
   inline u_int16_t getCliDeviceDisallowedProtocol() const {
     DeviceProtoStatus cli_ps =
         cli_host->getDeviceAllowedProtocolStatus(get_detected_protocol(), true);
     return (cli_ps == device_proto_forbidden_app)
                ? ndpiDetectedProtocol.app_protocol
                : ndpiDetectedProtocol.master_protocol;
   }
   inline u_int16_t getSrvDeviceDisallowedProtocol() const {
     DeviceProtoStatus srv_ps = srv_host->getDeviceAllowedProtocolStatus(
         get_detected_protocol(), false);
     return (srv_ps == device_proto_forbidden_app)
                ? ndpiDetectedProtocol.app_protocol
                : ndpiDetectedProtocol.master_protocol;
   }
   inline bool isMaskedFlow() const {
     return (Utils::maskHost(get_cli_ip_addr()->isLocalHost()) ||
             Utils::maskHost(get_srv_ip_addr()->isLocalHost()));
   };
   inline const char *getServerCipherClass() const {
     return (isTLS() ? cipher_weakness2str(protos.tls.ja3.server_unsafe_cipher)
                     : NULL);
   }
   char *serialize(bool use_labels = false);
   /* Prepares an alert JSON and puts int in the resulting `serializer`. */
   void alert2JSON(FlowAlert *alert, ndpi_serializer *serializer);
   json_object *flow2JSON();
   json_object *flow2es(json_object *flow_object);
   void formatECSInterface(json_object *my_object);
   void formatECSNetwork(json_object *my_object, const IpAddress *addr);
   void formatECSHost(json_object *my_object, bool is_client,
                      const IpAddress *addr, Host *host);
   void formatECSEvent(json_object *my_object);
   void formatECSFlow(json_object *my_object);
   void formatSyslogFlow(json_object *my_object);
   void formatGenericFlow(json_object *my_object);
   void formatECSExtraInfo(json_object *my_object);
   void formatECSAppProto(json_object *my_object);
   void formatECSObserver(json_object *my_object);
 
   inline u_int16_t getLowerProtocol() {
     return (ndpi_get_lower_proto(ndpiDetectedProtocol));
   }
 
   inline void updateJA3C(char *j) {
     if (j && (j[0] != '\0') && (protos.tls.ja3.client_hash == NULL))
       protos.tls.ja3.client_hash = strdup(j);
     updateCliJA3();
   }
   inline void updateJA3S(char *j) {
     if (j && (j[0] != '\0') && (protos.tls.ja3.server_hash == NULL))
       protos.tls.ja3.server_hash = strdup(j);
     updateSrvJA3();
   }
 
   inline u_int8_t getTcpFlags() const {
     return (src2dst_tcp_flags | dst2src_tcp_flags);
   };
   inline u_int8_t getTcpFlagsCli2Srv() const { return (src2dst_tcp_flags); };
   inline u_int8_t getTcpFlagsSrv2Cli() const { return (dst2src_tcp_flags); };
 #ifdef HAVE_NEDGE
   bool checkPassVerdict(const struct tm *now);
   bool isPassVerdict() const;
   inline void setConntrackMarker(u_int32_t marker) { this->marker = marker; }
   inline u_int32_t getConntrackMarker() { return (marker); }
   void incFlowDroppedCounters();
 #endif
   void setDropVerdict();
   u_int32_t getPid(bool client);
   u_int32_t getFatherPid(bool client);
   u_int32_t get_uid(bool client) const;
   char *get_proc_name(bool client);
   char *get_user_name(bool client);
   u_int32_t getNextTcpSeq(u_int8_t tcpFlags, u_int32_t tcpSeqNum,
                           u_int32_t payloadLen);
   static double toMs(const struct timeval *t);
   void timeval_diff(struct timeval *begin, const struct timeval *end,
                     struct timeval *result, u_short divide_by_two);
   char *getFlowInfo(char *buf, u_int buf_len, bool isLuaRequest);
   inline char *getFlowServerInfo() {
     return (isTLS() && protos.tls.client_requested_server_name)
                ? protos.tls.client_requested_server_name
                : host_server_name;
   }
   inline char *getBitTorrentHash() { return (bt_hash); };
   inline void setBTHash(char *h) {
     if (!h) return;
     if (bt_hash) free(bt_hash);
     bt_hash = h;
   }
   inline void setServerName(char *v) {
     if (host_server_name) free(host_server_name);
     host_server_name = v;
   }
   void updateICMPFlood(const struct bpf_timeval *when, bool src2dst_direction);
   void updateDNSFlood(const struct bpf_timeval *when, bool src2dst_direction);
   void updateSNMPFlood(const struct bpf_timeval *when, bool src2dst_direction);
   void updateTcpFlags(const struct bpf_timeval *when, u_int8_t flags,
                       bool src2dst_direction);
   void updateTcpWindow(u_int16_t window, bool src2dst_direction);
   void updateTcpSeqIssues(const ParsedFlow *pf);
   void updateTLS(ParsedFlow *zflow);
   void updateDNS(ParsedFlow *zflow);
   void updateHTTP(ParsedFlow *zflow);
   void updateSuspiciousDGADomain();
   static void incTcpBadStats(bool src2dst_direction, Host *cli, Host *srv,
                              NetworkInterface *iface, u_int32_t ooo_pkts,
                              u_int32_t retr_pkts, u_int32_t lost_pkts,
                              u_int32_t keep_alive_pkts);
 
   void updateTcpSeqNum(const struct bpf_timeval *when, u_int32_t seq_num,
                        u_int32_t ack_seq_num, u_int16_t window, u_int8_t flags,
                        u_int16_t payload_len, bool src2dst_direction);
 
   void updateSeqNum(time_t when, u_int32_t sN, u_int32_t aN);
   void setDetectedProtocol(ndpi_protocol proto_id);
   void processPacket(const struct pcap_pkthdr *h, const u_char *ip_packet,
                      u_int16_t ip_len, u_int64_t packet_time, u_int8_t *payload,
                      u_int16_t payload_len, u_int16_t src_port);
   void processDNSPacket(const u_char *ip_packet, u_int16_t ip_len,
                         u_int64_t packet_time);
   void processIEC60870Packet(bool tx_direction, const u_char *payload,
                              u_int16_t payload_len, struct timeval *packet_time);
 #ifdef NTOPNG_PRO
   void processModbusPacket(bool is_query, const u_char *payload,
 			   u_int16_t payload_len, struct timeval *packet_time);
 #endif
   void endProtocolDissection();
   inline void setCustomApp(custom_app_t ca) {
     memcpy(&custom_app, &ca, sizeof(custom_app));
   };
   inline custom_app_t getCustomApp() const { return custom_app; };
   u_int16_t getStatsProtocol() const;
   void setJSONInfo(json_object *json);
   void setTLVInfo(ndpi_serializer *tlv);
   void incStats(bool cli2srv_direction, u_int pkt_len, u_int8_t *payload,
                 u_int payload_len, u_int8_t l4_proto, u_int8_t is_fragment,
                 u_int16_t tcp_flags, const struct timeval *when,
                 u_int16_t fragment_extra_overhead);
   void addFlowStats(bool new_flow, bool cli2srv_direction, u_int in_pkts,
                     u_int in_bytes, u_int in_goodput_bytes, u_int out_pkts,
                     u_int out_bytes, u_int out_goodput_bytes,
                     u_int in_fragments, u_int out_fragments, time_t first_seen,
                     time_t last_seen);
   void check_swap();
 
   inline bool isThreeWayHandshakeOK() const { return (twh_ok ? true : false); };
   inline bool isDetectionCompleted() const {
     return (detection_completed ? true : false);
   };
   inline bool isOneWay() const {
     return (get_packets() &&
             (!get_packets_cli2srv() || !get_packets_srv2cli()));
   };
   inline bool isBidirectional() const {
     return (get_packets_cli2srv() && get_packets_srv2cli());
   };
   inline bool isRemoteToRemote() const {
     return (cli_host && srv_host && !cli_host->isLocalHost() &&
             !srv_host->isLocalHost());
   };
   inline bool isLocalToRemote() const {
     return get_cli_ip_addr()->isLocalHost() &&
            !get_srv_ip_addr()->isLocalHost();
   };
   inline bool isRemoteToLocal() const {
     return !get_cli_ip_addr()->isLocalHost() &&
            get_srv_ip_addr()->isLocalHost();
   };
   inline bool isLocalToLocal() const {
     return get_cli_ip_addr()->isLocalHost() && get_srv_ip_addr()->isLocalHost();
   };
   inline bool isUnicast() const {
     return (cli_ip_addr && srv_ip_addr &&
             !cli_ip_addr->isBroadMulticastAddress() &&
             !srv_ip_addr->isBroadMulticastAddress());
   };
   inline u_int32_t get_cli_ipv4() const {
     return (cli_host->get_ip()->get_ipv4());
   };
   inline u_int32_t get_srv_ipv4() const {
     return (srv_host->get_ip()->get_ipv4());
   };
   inline ndpi_protocol get_detected_protocol() const {
     return (isDetectionCompleted() ? ndpiDetectedProtocol
                                    : ndpiUnknownProtocol);
   };
   inline struct ndpi_flow_struct *get_ndpi_flow() const { return (ndpiFlow); };
   inline const struct ndpi_in6_addr *get_cli_ipv6() const {
     return (cli_host->get_ip()->get_ipv6());
   };
   inline const struct ndpi_in6_addr *get_srv_ipv6() const {
     return (srv_host->get_ip()->get_ipv6());
   };
   inline u_int16_t get_cli_port() const { return (ntohs(cli_port)); };
   inline u_int16_t get_srv_port() const { return (ntohs(srv_port)); };
   inline u_int16_t get_vlan_id() const { return (vlanId); };
   inline u_int8_t get_protocol() const { return (protocol); };
   inline u_int64_t get_bytes() const {
     return (stats.get_cli2srv_bytes() + stats.get_srv2cli_bytes());
   };
   inline u_int64_t get_bytes_cli2srv() const {
     return (stats.get_cli2srv_bytes());
   };
   inline u_int64_t get_bytes_srv2cli() const {
     return (stats.get_srv2cli_bytes());
   };
   inline u_int64_t get_goodput_bytes() const {
     return (stats.get_cli2srv_goodput_bytes() +
             stats.get_srv2cli_goodput_bytes());
   };
   inline u_int64_t get_goodput_bytes_cli2srv() const {
     return (stats.get_cli2srv_goodput_bytes());
   };
   inline u_int64_t get_goodput_bytes_srv2cli() const {
     return (stats.get_srv2cli_goodput_bytes());
   };
   inline u_int64_t get_packets() const {
     return (stats.get_cli2srv_packets() + stats.get_srv2cli_packets());
   };
   inline u_int32_t get_packets_cli2srv() const {
     return (stats.get_cli2srv_packets());
   };
   inline u_int32_t get_packets_srv2cli() const {
     return (stats.get_srv2cli_packets());
   };
   inline u_int64_t get_partial_bytes() const {
     return get_partial_bytes_cli2srv() + get_partial_bytes_srv2cli();
   };
   inline u_int64_t get_partial_packets() const {
     return get_partial_packets_cli2srv() + get_partial_packets_srv2cli();
   };
   inline u_int64_t get_partial_goodput_bytes() const {
     return last_db_dump.delta.get_cli2srv_goodput_bytes() +
            last_db_dump.delta.get_srv2cli_goodput_bytes();
   };
   inline u_int64_t get_partial_bytes_cli2srv() const {
     return last_db_dump.delta.get_cli2srv_bytes();
   };
   inline u_int64_t get_partial_bytes_srv2cli() const {
     return last_db_dump.delta.get_srv2cli_bytes();
   };
   inline u_int64_t get_partial_packets_cli2srv() const {
     return last_db_dump.delta.get_cli2srv_packets();
   };
   inline u_int64_t get_partial_packets_srv2cli() const {
     return last_db_dump.delta.get_srv2cli_packets();
   };
   inline void set_dump_in_progress() { last_db_dump.in_progress = true; };
   inline void set_dump_done() { last_db_dump.in_progress = false; };
   bool needsExtraDissection();
   bool hasDissectedTooManyPackets();
   bool get_partial_traffic_stats_view(PartializableFlowTrafficStats *delta,
                                       bool *first_partial);
   bool update_partial_traffic_stats_db_dump();
   inline float get_pkts_thpt() const {
     return (pkts_thpt_cli2srv + pkts_thpt_srv2cli);
   };
   inline float get_bytes_thpt() const {
     return (bytes_thpt_cli2srv + bytes_thpt_srv2cli);
   };
   inline float get_goodput_bytes_thpt() const {
     return (goodput_bytes_thpt_cli2srv + goodput_bytes_thpt_srv2cli);
   };
   inline float get_goodput_ratio() const {
     return ((float)(100 * get_goodput_bytes()) / ((float)get_bytes() + 1));
   };
   inline time_t get_partial_first_seen() const {
     return (last_db_dump.first_seen);
   };
   inline time_t get_partial_last_seen() const {
     return (last_db_dump.last_seen);
   };
   inline u_int32_t get_duration() const {
     return ((u_int32_t)(get_last_seen() - get_first_seen()));
   };
   inline char *get_protocol_name() const {
     return (Utils::l4proto2name(protocol));
   };
 
   inline Host *get_cli_host() const { return (cli_host); };
   inline Host *get_srv_host() const { return (srv_host); };
   inline IpAddress *get_cli_ip_addr() const { return (cli_ip_addr); };
   inline IpAddress *get_srv_ip_addr() const { return (srv_ip_addr); };
   inline IpAddress *get_dns_srv_ip_addr() const {
     return ((get_cli_port() == 53) ? get_cli_ip_addr() : get_srv_ip_addr());
   };
   inline IpAddress *get_dhcp_srv_ip_addr() const {
     return ((get_cli_port() == 67) ? get_cli_ip_addr() : get_srv_ip_addr());
   };
 
   inline json_object *get_json_info() const { return (json_info); };
   inline ndpi_serializer *get_tlv_info() const { return (tlv_info); };
   inline void setICMPPayloadSize(u_int16_t size) {
     if (isICMP())
       protos.icmp.max_icmp_payload_size =
           max(protos.icmp.max_icmp_payload_size, size);
   };
   inline u_int16_t getICMPPayloadSize() const {
     return (isICMP() ? protos.icmp.max_icmp_payload_size : 0);
   };
   inline ICMPinfo *getICMPInfo() const { return (isICMP() ? icmp_info : NULL); }
   inline ndpi_protocol_breed_t get_protocol_breed() const {
     return (ndpi_get_proto_breed(
         iface->get_ndpi_struct(),
         isDetectionCompleted() ? ndpi_get_upper_proto(ndpiDetectedProtocol)
                                : NDPI_PROTOCOL_UNKNOWN));
   };
   inline const char *get_protocol_breed_name() const {
     return (ndpi_get_proto_breed_name(iface->get_ndpi_struct(),
                                       get_protocol_breed()));
   };
   inline ndpi_protocol_category_t get_protocol_category() const {
     return (ndpi_get_proto_category(
         iface->get_ndpi_struct(),
         isDetectionCompleted() ? ndpiDetectedProtocol : ndpiUnknownProtocol));
   };
   inline const char *get_protocol_category_name() const {
     return (ndpi_category_get_name(iface->get_ndpi_struct(),
                                    get_protocol_category()));
   };
   char *get_detected_protocol_name(char *buf, u_int buf_len) const {
     return (iface->get_ndpi_full_proto_name(
         isDetectionCompleted() ? ndpiDetectedProtocol : ndpiUnknownProtocol,
         buf, buf_len));
   }
   static inline ndpi_protocol get_ndpi_unknown_protocol() {
     return ndpiUnknownProtocol;
   };
 
   /* NOTE: the caller must ensure that the hosts returned by these methods are
    * not used concurrently by subinterfaces since hosts are shared between all
    * the subinterfaces of the same ViewInterface. */
   inline Host *getViewSharedClient() {
     return (viewFlowStats ? viewFlowStats->getViewSharedClient()
                           : get_cli_host());
   };
   inline Host *getViewSharedServer() {
     return (viewFlowStats ? viewFlowStats->getViewSharedServer()
                           : get_srv_host());
   };
 
   u_int32_t get_packetsLost();
   u_int32_t get_packetsRetr();
   u_int32_t get_packetsOOO();
 
   inline const struct timeval *get_current_update_time() const {
     return &last_update_time;
   };
   u_int64_t get_current_bytes_cli2srv() const;
   u_int64_t get_current_bytes_srv2cli() const;
   u_int64_t get_current_goodput_bytes_cli2srv() const;
   u_int64_t get_current_goodput_bytes_srv2cli() const;
   u_int64_t get_current_packets_cli2srv() const;
   u_int64_t get_current_packets_srv2cli() const;
 
   inline bool is_swap_requested() const {
     return (swap_requested ? true : false);
   };
   inline bool is_swap_done() const { return (swap_done ? true : false); };
   inline void set_swap_done() { swap_done = 1; };
   /*
     Returns actual client and server, that is the client and server as
     determined after the swap heuristic that has taken place.
    */
   inline void get_actual_peers(Host **actual_client,
                                Host **actual_server) const {
     if (is_swap_requested())
       *actual_client = get_srv_host(), *actual_server = get_cli_host();
     else
       *actual_client = get_cli_host(), *actual_server = get_srv_host();
   };
   bool is_hash_entry_state_idle_transition_ready();
   void hosts_periodic_stats_update(NetworkInterface *iface, Host *cli_host,
                                    Host *srv_host,
                                    PartializableFlowTrafficStats *partial,
                                    bool first_partial,
                                    const struct timeval *tv);
   void periodic_stats_update(const struct timeval *tv);
   void set_hash_entry_id(u_int32_t assigned_hash_entry_id);
   u_int32_t get_hash_entry_id() const;
 
   static char *printTCPflags(u_int8_t flags, char *const buf, u_int buf_len);
   char *print(char *buf, u_int buf_len) const;
 
   u_int32_t key();
   static u_int32_t key(Host *cli, u_int16_t cli_port, Host *srv,
                        u_int16_t srv_port, u_int16_t vlan_id,
                        u_int16_t _observation_point_id, u_int16_t protocol);
   void lua(lua_State *vm, AddressTree *ptree, DetailsLevel details_level,
            bool asListElement);
   void lua_get_min_info(lua_State *vm);
   void lua_duration_info(lua_State *vm);
   void lua_snmp_info(lua_State *vm);
   void lua_device_protocol_allowed_info(lua_State *vm);
   void lua_get_tcp_stats(lua_State *vm) const;
 
   void lua_get_unicast_info(lua_State *vm) const;
   void lua_get_status(lua_State *vm) const;
   void lua_get_protocols(lua_State *vm) const;
   void lua_get_bytes(lua_State *vm) const;
   void lua_get_dir_traffic(lua_State *vm, bool cli2srv) const;
   void lua_get_dir_iat(lua_State *vm, bool cli2srv) const;
   void lua_get_packets(lua_State *vm) const;
   void lua_get_throughput(lua_State *vm) const;
   void lua_get_time(lua_State *vm) const;
   void lua_get_ip(lua_State *vm, bool client) const;
   void lua_get_mac(lua_State *vm, bool client) const;
   void lua_get_info(lua_State *vm, bool client) const;
   void lua_get_tls_info(lua_State *vm) const;
   void lua_get_ssh_info(lua_State *vm) const;
   void lua_get_http_info(lua_State *vm) const;
   void lua_get_dns_info(lua_State *vm) const;
   void lua_get_tcp_info(lua_State *vm) const;
   void lua_get_port(lua_State *vm, bool client) const;
   void lua_get_geoloc(lua_State *vm, bool client, bool coords,
                       bool country_city) const;
   void lua_get_risk_info(lua_State *vm);
 
   void getInfo(ndpi_serializer *serializer);
   void getHTTPInfo(ndpi_serializer *serializer) const;
   void getDNSInfo(ndpi_serializer *serializer) const;
   void getICMPInfo(ndpi_serializer *serializer) const;
   void getTLSInfo(ndpi_serializer *serializer) const;
   void getMDNSInfo(ndpi_serializer *serializer) const;
   void getNetBiosInfo(ndpi_serializer *serializer) const;
   void getSSHInfo(ndpi_serializer *serializer) const;
 
   bool equal(const Mac *src_mac, const Mac *dst_mac, const IpAddress *_cli_ip,
              const IpAddress *_srv_ip, u_int16_t _cli_port, u_int16_t _srv_port,
              u_int16_t _u_int16_t, u_int16_t _observation_point_id,
              u_int32_t _private_flow_id, u_int8_t _protocol,
              const ICMPinfo *const icmp_info, bool *src2srv_direction) const;
   void sumStats(nDPIStats *ndpi_stats, FlowStats *stats);
   bool dump(time_t t, bool last_dump_before_free);
   bool match(AddressTree *ptree);
   bool matchFlowIP(IpAddress *ip, u_int16_t vlan_id);
   bool matchFlowVLAN(u_int16_t vlan_id);
   void dissectHTTP(bool src2dst_direction, char *payload,
                    u_int16_t payload_len);
   void dissectDNS(bool src2dst_direction, char *payload, u_int16_t payload_len);
   void dissectTLS(char *payload, u_int16_t payload_len);
   void dissectSSDP(bool src2dst_direction, char *payload,
                    u_int16_t payload_len);
   void dissectMDNS(u_int8_t *payload, u_int16_t payload_len);
   void dissectNetBIOS(u_int8_t *payload, u_int16_t payload_len);
   void dissectBittorrent(char *payload, u_int16_t payload_len);
   void fillZMQFlowCategory(ndpi_protocol *res);
   inline void setICMP(bool src2dst_direction, u_int8_t icmp_type,
                       u_int8_t icmp_code, u_int8_t *icmpdata) {
     if (isICMP()) {
       if (src2dst_direction)
         protos.icmp.cli2srv.icmp_type = icmp_type,
         protos.icmp.cli2srv.icmp_code = icmp_code;
       else
         protos.icmp.srv2cli.icmp_type = icmp_type,
         protos.icmp.srv2cli.icmp_code = icmp_code;
       // if(get_cli_host()) get_cli_host()->incICMP(icmp_type, icmp_code,
       // src2dst_direction ? true : false, get_srv_host()); if(get_srv_host())
       // get_srv_host()->incICMP(icmp_type, icmp_code, src2dst_direction ? false
       // : true, get_cli_host());
     }
   }
   inline void getICMP(u_int8_t *_icmp_type, u_int8_t *_icmp_code) {
     if (isBidirectional())
       *_icmp_type = protos.icmp.srv2cli.icmp_type,
       *_icmp_code = protos.icmp.srv2cli.icmp_code;
     else
       *_icmp_type = protos.icmp.cli2srv.icmp_type,
       *_icmp_code = protos.icmp.cli2srv.icmp_code;
   }
   inline u_int8_t getICMPType() {
     if (isICMP()) {
       return isBidirectional() ? protos.icmp.srv2cli.icmp_type
                                : protos.icmp.cli2srv.icmp_type;
     }
 
     return 0;
   }
 
   inline bool hasInvalidDNSQueryChars() const {
     return (isDNS() && hasRisk(NDPI_INVALID_CHARACTERS));
   }
   inline bool hasMaliciousSignature(bool as_client) const {
     return as_client ? has_malicious_cli_signature
                      : has_malicious_srv_signature;
   }
 
   void setRisk(ndpi_risk r);
   void addRisk(ndpi_risk r);
   inline ndpi_risk getRiskBitmap() const { return ndpi_flow_risk_bitmap; }
   bool hasRisk(ndpi_risk_enum r) const;
   bool hasRisks() const;
   void clearRisks();
   inline void setDGADomain(char *name) {
     if (name) {
       if (suspicious_dga_domain) free(suspicious_dga_domain);
       suspicious_dga_domain = strdup(name);
     }
   }
   inline char *getDGADomain() const {
     return (hasRisk(NDPI_SUSPICIOUS_DGA_DOMAIN) && suspicious_dga_domain
                 ? suspicious_dga_domain
                 : (char *)"");
   }
   inline char *getDNSQuery() const {
     return (isDNS() ? protos.dns.last_query : (char *)"");
   }
   bool setDNSQuery(char *v, bool copy_memory);
   inline void setDNSQueryType(u_int16_t t) {
     if (isDNS()) {
       protos.dns.last_query_type = t;
     }
   }
   inline void setDNSRetCode(u_int16_t c) {
     if (isDNS()) {
       protos.dns.last_return_code = c;
     }
   }
   inline u_int16_t getLastQueryType() {
     return (isDNS() ? protos.dns.last_query_type : 0);
   }
   inline u_int16_t getDNSRetCode() {
     return (isDNS() ? protos.dns.last_return_code : 0);
   }
   inline char *getHTTPURL() {
     return (isHTTP() ? protos.http.last_url : (char *)"");
   }
   inline void setHTTPURL(char *v) {
     if (isHTTP()) {
       if (!protos.http.last_url)
 	protos.http.last_url = v;
       else
 	free(v);
     } else {
       if (v) free(v);
     }
   }
   inline char *getHTTPUserAgent() {
     return (isHTTP() ? protos.http.last_user_agent : (char *)"");
   }
   inline void setHTTPUserAgent(char *v) {
     if (isHTTP()) {
       if (!protos.http.last_user_agent)
 	protos.http.last_user_agent = v;
       else
 	free(v);
     } else {
       if (v) free(v);
     }
   }
   void setHTTPMethod(const char *method, ssize_t method_len);
   void setHTTPMethod(ndpi_http_method m);
   inline void setHTTPRetCode(u_int16_t c) {
     if (isHTTP()) {
       protos.http.last_return_code = c;
     }
   }
   inline u_int16_t getHTTPRetCode() const {
     return isHTTP() ? protos.http.last_return_code : 0;
   };
   inline const char *getHTTPMethod() const {
     return isHTTP() ? ndpi_http_method2str(protos.http.last_method)
                     : (char *)"";
   };
 
   void setExternalAlert(json_object *a);
   inline bool hasExternalAlert() const { return external_alert.json != NULL; };
   inline json_object *getExternalAlert() { return external_alert.json; };
   inline char *getExternalSource() { return external_alert.source; };
   void luaRetrieveExternalAlert(lua_State *vm);
 
   u_int32_t getSrvTcpIssues();
   u_int32_t getCliTcpIssues();
   double getCliRetrPercentage();
   double getSrvRetrPercentage();
 
 #if defined(NTOPNG_PRO) && !defined(HAVE_NEDGE)
   inline void updateProfile() { trafficProfile = iface->getFlowProfile(this); }
   inline char *get_profile_name() {
     return (trafficProfile ? trafficProfile->getName() : (char *)"");
   }
 #endif
   /* http://bradhedlund.com/2008/12/19/how-to-calculate-tcp-throughput-for-long-distance-links/
    */
   inline float getCli2SrvMaxThpt() const {
     return (rttSec ? ((float)(cli2srv_window * 8) / rttSec) : 0);
   }
   inline float getSrv2CliMaxThpt() const {
     return (rttSec ? ((float)(srv2cli_window * 8) / rttSec) : 0);
   }
 
   inline InterarrivalStats *getCli2SrvIATStats() const {
     return cli2srvPktTime;
   }
   inline InterarrivalStats *getSrv2CliIATStats() const {
     return srv2cliPktTime;
   }
 
   inline bool isTCP() const { return protocol == IPPROTO_TCP; };
   inline bool isTCPEstablished() const {
     return (!isTCPClosed() && !isTCPReset() && isThreeWayHandshakeOK());
   }
   inline bool isTCPConnecting() const {
     return (src2dst_tcp_flags == TH_SYN &&
             (!dst2src_tcp_flags || (dst2src_tcp_flags == (TH_SYN | TH_ACK))));
   }
   inline bool isTCPClosed() const {
     return (((src2dst_tcp_flags & (TH_SYN | TH_ACK | TH_FIN)) ==
              (TH_SYN | TH_ACK | TH_FIN)) &&
             ((dst2src_tcp_flags & (TH_SYN | TH_ACK | TH_FIN)) ==
              (TH_SYN | TH_ACK | TH_FIN)));
   }
   inline bool isTCPReset() const {
     return (!isTCPClosed() &&
             ((src2dst_tcp_flags & TH_RST) || (dst2src_tcp_flags & TH_RST)));
   };
   inline bool isTCPRefused() const {
     return (!isThreeWayHandshakeOK() && (dst2src_tcp_flags & TH_RST) == TH_RST);
   };
   inline bool isTCPZeroWindow() const {
     return (src2dst_tcp_zero_window || dst2src_tcp_zero_window);
   };
   inline void setVRFid(u_int32_t v) { vrfId = v; }
   inline void setSrcAS(u_int32_t v) { srcAS = v; }
   inline void setDstAS(u_int32_t v) { dstAS = v; }
   inline void setPrevAdjacentAS(u_int32_t v) { prevAdjacentAS = v; }
   inline void setNextAdjacentAS(u_int32_t v) { nextAdjacentAS = v; }
 
   inline ViewInterfaceFlowStats *getViewInterfaceFlowStats() {
     return (viewFlowStats);
   }
 
   inline double getFlowNwLatency(bool client) const {
     return client ? Utils::timeval2ms(&clientNwLatency)
                   : Utils::timeval2ms(&serverNwLatency);
   };
   inline void setFlowNwLatency(const struct timeval *const tv, bool client) {
     if (client) {
       memcpy(&clientNwLatency, tv, sizeof(*tv));
       if (cli_host)
         cli_host->updateRoundTripTime(Utils::timeval2ms(&clientNwLatency));
     } else {
       memcpy(&serverNwLatency, tv, sizeof(*tv));
       if (srv_host)
         srv_host->updateRoundTripTime(Utils::timeval2ms(&serverNwLatency));
     }
   }
   inline void setFlowTcpWindow(u_int16_t window_val, bool client) {
     if (client)
       cli2srv_window = window_val;
     else
       srv2cli_window = window_val;
   }
   inline void setRtt() {
     rttSec = ((float)(serverNwLatency.tv_sec + clientNwLatency.tv_sec)) +
              ((float)(serverNwLatency.tv_usec + clientNwLatency.tv_usec)) /
                  (float)1000000;
   }
   inline void setFlowApplLatency(float latency_msecs) {
     applLatencyMsec = latency_msecs;
   }
   inline void setFlowDevice(u_int32_t device_ip, u_int16_t observation_point_id,
                             u_int32_t inidx, u_int32_t outidx) {
     ObservationPoint *obs_point;
 
     flow_device.device_ip = device_ip,
     flow_device.observation_point_id = observation_point_id;
     flow_device.in_index = inidx, flow_device.out_index = outidx;
     if (cli_host) cli_host->setLastDeviceIp(device_ip);
     if (srv_host) srv_host->setLastDeviceIp(device_ip);
 
     if ((obs_point = iface->getObsPoint(observation_point_id, true, true)) !=
         NULL)
       obs_point->addProbeIp(device_ip);
   }
   inline u_int32_t getFlowDeviceIP() { return flow_device.device_ip; };
   inline u_int16_t getFlowObservationPointId() {
     return flow_device.observation_point_id;
   };
   inline u_int16_t get_observation_point_id() {
     return (getFlowObservationPointId());
   };
   inline u_int32_t getFlowDeviceInIndex() { return flow_device.in_index; };
   inline u_int32_t getFlowDeviceOutIndex() { return flow_device.out_index; };
 
   inline const u_int16_t getScore() const { return (flow_score); };
 
 #ifdef HAVE_NEDGE
   inline void setLastConntrackUpdate(u_int32_t when) {
     last_conntrack_update = when;
   }
   bool isNetfilterIdleFlow() const;
 
   void setPacketsBytes(time_t now, u_int32_t s2d_pkts, u_int32_t d2s_pkts,
                        u_int64_t s2d_bytes, u_int64_t d2s_bytes);
   void getFlowShapers(bool src2dst_direction, TrafficShaper **shaper_ingress,
                       TrafficShaper **shaper_egress) {
     if (src2dst_direction) {
       *shaper_ingress = flowShaperIds.cli2srv.ingress,
       *shaper_egress = flowShaperIds.cli2srv.egress;
     } else {
       *shaper_ingress = flowShaperIds.srv2cli.ingress,
       *shaper_egress = flowShaperIds.srv2cli.egress;
     }
   }
   bool updateDirectionShapers(bool src2dst_direction,
                               TrafficShaper **ingress_shaper,
                               TrafficShaper **egress_shaper);
   void updateFlowShapers(bool first_update = false);
   void recheckQuota(const struct tm *now);
   inline u_int8_t getFlowRoutingTableId() { return (routing_table_id); }
   inline void setIngress2EgressDirection(bool _ingress2egress) {
     ingress2egress_direction = _ingress2egress;
   }
   inline bool isIngress2EgressDirection() { return (ingress2egress_direction); }
 #endif
   void housekeep(time_t t);
   void setParsedeBPFInfo(const ParsedeBPF *const _ebpf, bool swap_directions);
   inline const ContainerInfo *getClientContainerInfo() const {
     return ebpf && ebpf->container_info_set ? &ebpf->src_container_info : NULL;
   }
   inline const ContainerInfo *getServerContainerInfo() const {
     return ebpf && ebpf->container_info_set ? &ebpf->dst_container_info : NULL;
   }
   inline const ProcessInfo *getClientProcessInfo() const {
     return ebpf && ebpf->process_info_set ? &ebpf->src_process_info : NULL;
   }
   inline const ProcessInfo *getServerProcessInfo() const {
     return ebpf && ebpf->process_info_set ? &ebpf->dst_process_info : NULL;
   }
   inline const TcpInfo *getClientTcpInfo() const {
     return ebpf && ebpf->tcp_info_set ? &ebpf->src_tcp_info : NULL;
   }
   inline const TcpInfo *getServerTcpInfo() const {
     return ebpf && ebpf->tcp_info_set ? &ebpf->dst_tcp_info : NULL;
   }
 
   inline bool isNotPurged() {
     return (getInterface()->isPacketInterface() &&
             getInterface()->is_purge_idle_interface() && (!idle()) &&
             is_active_entry_now_idle(10 * getInterface()->getFlowMaxIdle()));
   }
 
   inline u_int16_t getTLSVersion() {
     return (isTLS() ? protos.tls.tls_version : 0);
   }
   inline u_int32_t getTLSNotBefore() {
     return (isTLS() ? protos.tls.notBefore : 0);
   };
   inline u_int32_t getTLSNotAfter() {
     return (isTLS() ? protos.tls.notAfter : 0);
   };
   inline char *getTLSCertificateIssuerDN() {
     return (isTLS() ? protos.tls.issuerDN : NULL);
   }
   inline char *getTLSCertificateSubjectDN() {
     return (isTLS() ? protos.tls.subjectDN : NULL);
   }
   inline void setTLSCertificateIssuerDN(char *issuer) {
     if (protos.tls.issuerDN) free(protos.tls.issuerDN);
     protos.tls.issuerDN = strdup(issuer);
   }
   inline void setTOS(u_int8_t tos, bool is_cli_tos) {
     if (is_cli_tos) cli2srv_tos = tos;
     srv2cli_tos = tos;
   }
   inline u_int8_t getTOS(bool is_cli_tos) const {
     return (is_cli_tos ? cli2srv_tos : srv2cli_tos);
   }
 
   inline u_int8_t getCli2SrvDSCP() const { return (cli2srv_tos & 0xFC) >> 2; }
   inline u_int8_t getSrv2CliDSCP() const { return (srv2cli_tos & 0xFC) >> 2; }
 
   inline u_int8_t getCli2SrvECN() { return (cli2srv_tos & 0x3); }
   inline u_int8_t getSrv2CliECN() { return (srv2cli_tos & 0x3); }
 
   inline float getEntropy(bool src2dst_direction) {
     struct ndpi_analyze_struct *e = src2dst_direction
                                         ? initial_bytes_entropy.c2s
                                         : initial_bytes_entropy.s2c;
 
     return (e ? ndpi_data_entropy(e) : 0);
   }
 
   inline float getICMPPacketsEntropy() {
     return (protos.icmp.client_to_server.max_entropy -
             protos.icmp.client_to_server.min_entropy);
   }
 
   inline bool timeToPeriodicDump(u_int sec) {
     return ((sec - get_first_seen() >= CONST_DB_DUMP_FREQUENCY) &&
             (sec - get_partial_last_seen() >= CONST_DB_DUMP_FREQUENCY));
   }
 
   u_char *getCommunityId(u_char *community_id, u_int community_id_len);
   void setJSONRiskInfo(char *r);
   char *getJSONRiskInfo();
   void getJSONRiskInfo(ndpi_serializer *serializer);
 
   inline FlowTrafficStats *getTrafficStats() { return (&stats); };
   inline char *get_custom_category_file() const {
     return ((char *)ndpiDetectedProtocol.custom_category_userdata);
   }
 
   inline u_int8_t *getViewCliMac() { return (view_cli_mac); };
   inline u_int8_t *getViewSrvMac() { return (view_srv_mac); };
 
   inline u_int32_t getErrorCode() { return (protocolErrorCode); }
   inline void setErrorCode(u_int32_t rc) { protocolErrorCode = rc; }
 
   inline char *getAddressFamilyProtocol() const {
     return (ndpiAddressFamilyProtocol);
   }
   inline void setAddressFamilyProtocol(char *proto) {
     ndpiAddressFamilyProtocol = strdup(proto);
   }
 
   inline ndpi_confidence_t getConfidence() { return (confidence); }
   inline void setConfidence(ndpi_confidence_t rc) { confidence = rc; }
 
   inline u_int8_t getCliLocation() {
     if (cli_host && cli_host->isMulticastHost())
       return 2;  // Multicast host
     else if (cli_host && cli_host->isLocalHost())
       return 1;  // Local host
     else
       return 0;  // Remote host
   }
   inline u_int8_t getSrvLocation() {
     if (srv_host && srv_host->isMulticastHost())
       return 2;  // Multicast host
     else if (srv_host && srv_host->isLocalHost())
       return 1;  // Local host
     else
       return 0;  // Remote host
   }
 
   inline u_int32_t getPrivateFlowId() const { return (privateFlowId); }
 
   inline bool isCustomFlowAlertTriggered() {
     return (customFlowAlert.alertTriggered);
   }
   inline u_int8_t getCustomFlowAlertScore() { return (customFlowAlert.score); }
   inline char *getCustomFlowAlertMessage() { return (customFlowAlert.msg); }
   void triggerCustomFlowAlert(u_int8_t score, char *msg);
   inline void setRTPStreamType(ndpi_multimedia_flow_type s) {
     rtp_stream_type = s;
   }
   inline ndpi_multimedia_flow_type getRTPStreamType() {
     return (rtp_stream_type);
   }
   inline void setPeriodicFlow() { is_periodic_flow = 1; }
   inline bool isPeriodicFlow() { return (is_periodic_flow ? true : false); }
   void swap();
   bool isDPIDetectedFlow();
 };
 
 #endif /* _FLOW_H_ */
diff --git a/src/Flow.cpp b/src/Flow.cpp
index 1fc6bd59e..55d47a31b 100644
--- a/src/Flow.cpp
+++ b/src/Flow.cpp
@@ -327,151 +327,154 @@ void Flow::freeDPIMemory() {
 Flow::~Flow() {
   bool is_oneway_tcp_udp_flow =
       (((protocol == IPPROTO_TCP) || (protocol == IPPROTO_UDP)) && isOneWay())
           ? true
           : false;
 
   if (getUses() != 0 && !ntop->getGlobals()->isShutdown())
     ntop->getTrace()->traceEvent(TRACE_NORMAL, "[%s] Deleting flow [%u]",
                                  __FUNCTION__, getUses());
 
 #ifdef ALERTED_FLOWS_DEBUG
   if (iface_alert_inc && !iface_alert_dec) {
     char buf[256];
 
     ntop->getTrace()->traceEvent(
         TRACE_WARNING, "[MISMATCH][inc but not dec][alerted: %u] %s",
         isFlowAlerted() ? 1 : 0, print(buf, sizeof(buf)));
   }
 #endif
 
   /*
     Get client and server hosts. Use unsafe* methods to get the client and
     server also for 'viewed' interfaces. For 'Viewed' interfaces, host pointers
     are shared across multiple 'viewed' interfaces and thus they are termed as
     unsafe.
 
     IMPORTANT: only call here methods that are safe (e.g., locked or atomic-ed).
 
     It is fundamental to only call
    */
   Host *cli_u = getViewSharedClient(), *srv_u = getViewSharedServer();
 
   if (getInterface()->isViewed()) /* Score decrements done here for 'viewed'
                                      interfaces to avoid races. */
     decAllFlowScores();
 
   if (cli_u) {
     cli_u->decUses(); /* Decrease the number of uses */
     cli_u->decNumFlows(get_last_seen(), true);
 
     if (is_oneway_tcp_udp_flow) cli_u->incUnidirectionalEgressTCPUDPFlows();
   }
 
   if (!cli_host &&
       cli_ip_addr) /* Dynamically allocated only when cli_host was NULL in Flow
                       constructor (viewed interfaces) */
     delete cli_ip_addr;
 
   if (srv_u) {
     srv_u->decUses(); /* Decrease the number of uses */
     srv_u->decNumFlows(get_last_seen(), false);
 
     if (is_oneway_tcp_udp_flow) {
       srv_u->incUnidirectionalIngressTCPUDPFlows();
 
       if (cli_u) {
         u_int16_t s_port = ntohs(srv_port);
 
         cli_u->setUnidirectionalTCPUDPNoTXEgressFlow(srv_u->get_ip(), s_port);
         srv_u->setContactedTCPUDPServerPortNoTX(s_port);
         srv_u->setUnidirectionalTCPUDPNoTXIngressFlow(cli_u->get_ip(),
                                                       ntohs(srv_port));
       }
     }
   }
 
   if (!srv_host &&
       srv_ip_addr) /* Dynamically allocated only when srv_host was NULL in Flow
                       constructor (viewed interfaces) */
     delete srv_ip_addr;
 
   /*
     Finish deleting other flow data structures
    */
 
   if (riskInfo) free(riskInfo);
   if (viewFlowStats) delete (viewFlowStats);
   if (periodic_stats_update_partial) delete (periodic_stats_update_partial);
   if (last_db_dump.partial) delete (last_db_dump.partial);
   if (json_info) json_object_put(json_info);
   if (tlv_info) {
     ndpi_term_serializer(tlv_info);
     free(tlv_info);
   }
 
   if (host_server_name) free(host_server_name);
   if (iec104) delete iec104;
 #ifdef NTOPNG_PRO
   if (modbus) delete modbus;
 #endif
 
   if (suspicious_dga_domain) free(suspicious_dga_domain);
   if (ndpiAddressFamilyProtocol) free(ndpiAddressFamilyProtocol);
   if (ebpf) delete ebpf;
 
   if (cli2srvPktTime) delete cli2srvPktTime;
   if (srv2cliPktTime) delete srv2cliPktTime;
 
   if (initial_bytes_entropy.c2s)
     ndpi_free_data_analysis(initial_bytes_entropy.c2s, 1);
   if (initial_bytes_entropy.s2c)
     ndpi_free_data_analysis(initial_bytes_entropy.s2c, 1);
 
   if (flow_payload) free(flow_payload);
 
   if (isHTTP()) {
     if (protos.http.last_url) free(protos.http.last_url);
     if (protos.http.last_user_agent) free(protos.http.last_user_agent);
     if (protos.http.last_server) free(protos.http.last_server);
+  } else if (isHTTP_PROXY()) {
+    if (protos.http.last_url) free(protos.http.last_url);
+    if (protos.http.last_user_agent) free(protos.http.last_user_agent);
   } else if (isDNS()) {
     if (protos.dns.last_query) free(protos.dns.last_query);
     if (protos.dns.last_query_shadow) free(protos.dns.last_query_shadow);
   } else if (isMDNS()) {
     if (protos.mdns.answer) free(protos.mdns.answer);
     if (protos.mdns.name) free(protos.mdns.name);
     if (protos.mdns.name_txt) free(protos.mdns.name_txt);
     if (protos.mdns.ssid) free(protos.mdns.ssid);
   } else if (isSSDP()) {
     if (protos.ssdp.location) free(protos.ssdp.location);
   } else if (isNetBIOS()) {
     if (protos.netbios.name) free(protos.netbios.name);
   } else if (isSSH()) {
     if (protos.ssh.client_signature) free(protos.ssh.client_signature);
     if (protos.ssh.server_signature) free(protos.ssh.server_signature);
     if (protos.ssh.hassh.client_hash) free(protos.ssh.hassh.client_hash);
     if (protos.ssh.hassh.server_hash) free(protos.ssh.hassh.server_hash);
   } else if (isTLS()) {
     if (protos.tls.client_requested_server_name)
       free(protos.tls.client_requested_server_name);
     if (protos.tls.server_names) free(protos.tls.server_names);
     if (protos.tls.ja3.client_hash) free(protos.tls.ja3.client_hash);
     if (protos.tls.ja3.server_hash) free(protos.tls.ja3.server_hash);
     if (protos.tls.client_alpn) free(protos.tls.client_alpn);
     if (protos.tls.client_tls_supported_versions)
       free(protos.tls.client_tls_supported_versions);
     if (protos.tls.issuerDN) free(protos.tls.issuerDN);
     if (protos.tls.subjectDN) free(protos.tls.subjectDN);
   }
 
   if (bt_hash) free(bt_hash);
 
   freeDPIMemory();
   if (icmp_info) delete (icmp_info);
   if (json_protocol_info) free(json_protocol_info);
   if (external_alert.json) json_object_put(external_alert.json);
   if (external_alert.source) free(external_alert.source);
 
   if (customFlowAlert.msg) free(customFlowAlert.msg);
 }
 
 /* *************************************** */
diff --git a/src/HostPools.cpp b/src/HostPools.cpp
index 695731b21..ec5bd3143 100644
--- a/src/HostPools.cpp
+++ b/src/HostPools.cpp
@@ -299,196 +299,197 @@ void HostPools::lua(lua_State *vm) {
 void HostPools::reloadPools() {
   char kname[CONST_MAX_LEN_REDIS_KEY];
   char **pools, **pool_members, *at, *member;
   int num_pools, num_members, actual_num_members;
   u_int16_t _pool_id;
   u_int16_t vlan_id;
   VLANAddressTree *new_tree;
   HostPoolStats **new_stats;
   Redis *redis = ntop->getRedis();
 
   if (!iface || (iface->get_id() == -1)) return;
 
   new_tree = new (std::nothrow) VLANAddressTree;
   if(new_tree == NULL) {
     return;
   }
   
   new_stats = new (std::nothrow) HostPoolStats *[MAX_NUM_HOST_POOLS];
   if(new_stats == NULL) {
     delete new_tree;
     return;
   }
   
   for (u_int32_t i = 0; i < MAX_NUM_HOST_POOLS; i++) new_stats[i] = NULL;
 
   snprintf(kname, sizeof(kname), HOST_POOL_IDS_KEY);
 
   /* Always allocate default pool stats */
   if (stats && stats[0]) /* Duplicate existing statistics */
     new_stats[0] = new (std::nothrow) HostPoolStats(*stats[0]);
   else /* Brand new statistics */
     new_stats[0] = new (std::nothrow) HostPoolStats(iface);
 
   /* Set the default pool name into the stats */
   if (new_stats[0]) new_stats[0]->updateName(DEFAULT_POOL_NAME);
 
   /* Keys are pool ids */
   if ((num_pools = redis->smembers(kname, &pools)) == -1) {
     delete new_tree;
-    delete new_stats;
+    delete new_stats[0];
+    delete [] new_stats;
     return; /* Something went wrong with redis? */
   }
   
   for (int i = 0; i < num_pools; i++) {
     if (!pools[i]) continue;
 
     _pool_id = (u_int16_t)atoi(pools[i]);
     if (_pool_id >= MAX_NUM_HOST_POOLS) {
       ntop->getTrace()->traceEvent(
           TRACE_WARNING,
           "Ignoring pool [pool id: %2d]. "
           "Maximum number of host pools for this license is %u, inclusive of "
           "the Not Assigned pool.",
           _pool_id, MAX_NUM_HOST_POOLS);
 
       free(pools[i]);
       continue;
     }
 
     snprintf(kname, sizeof(kname), HOST_POOL_DETAILS_KEY, _pool_id);
 
     if (_pool_id != 0) {            /* Pool id 0 stats already updated */
       if (stats && stats[_pool_id]) /* Duplicate existing statistics */
         new_stats[_pool_id] = new (std::nothrow) HostPoolStats(*stats[_pool_id]);
       else /* Brand new statistics */
         new_stats[_pool_id] = new (std::nothrow) HostPoolStats(iface);
     }
 
     /* Initialize the name */
     if (new_stats[_pool_id]) {
       char name_rsp[POOL_MAX_NAME_LEN];
       redis->hashGet(kname, (char *)"name", name_rsp, sizeof(name_rsp));
       new_stats[_pool_id]->updateName(name_rsp);
     }
 
 #ifdef NTOPNG_PRO
     char rsp[16] = {0};
 
     children_safe[_pool_id] =
         ((redis->hashGet(kname, (char *)CONST_CHILDREN_SAFE, rsp,
                          sizeof(rsp)) != -1) &&
          (!strcmp(rsp, "true")));
 
     forge_global_dns[_pool_id] =
         ((redis->hashGet(kname, (char *)CONST_FORGE_GLOBAL_DNS, rsp,
                          sizeof(rsp)) != -1) &&
          (!strcmp(rsp, "true")));
 
     routing_policy_id[_pool_id] =
         (redis->hashGet(kname, (char *)CONST_ROUTING_POLICY_ID, rsp,
                         sizeof(rsp)) != -1)
             ? atoi(rsp)
             : DEFAULT_ROUTING_TABLE_ID;
     pool_shaper[_pool_id] = (redis->hashGet(kname, (char *)CONST_POOL_SHAPER_ID,
                                             rsp, sizeof(rsp)) != -1)
                                 ? atoi(rsp)
                                 : DEFAULT_SHAPER_ID;
     schedule_bitmap[_pool_id] =
         (redis->hashGet(kname, (char *)CONST_SCHEDULE_BITMAP, rsp,
                         sizeof(rsp)) != -1)
             ? strtol(rsp, NULL, 16)
             : DEFAULT_TIME_SCHEDULE;
 
     enforce_quotas_per_pool_member[_pool_id] =
         ((redis->hashGet(kname, (char *)CONST_ENFORCE_QUOTAS_PER_POOL_MEMBER,
                          rsp, sizeof(rsp)) != -1) &&
          (!strcmp(rsp, "true")));
     ;
     enforce_shapers_per_pool_member[_pool_id] =
         ((redis->hashGet(kname, (char *)CONST_ENFORCE_SHAPERS_PER_POOL_MEMBER,
                          rsp, sizeof(rsp)) != -1) &&
          (!strcmp(rsp, "true")));
     ;
 
 #ifdef HOST_POOLS_DEBUG
     redis->hashGet(kname, (char *)"name", rsp, sizeof(rsp));
     ntop->getTrace()->traceEvent(
         TRACE_NORMAL,
         "Loading pool [%s][iteration: %u][pool_id: %u][name: %s]"
         "[children_safe: %i]"
         "[forge_global_dns: %i]"
         "[pool_shaper: %i]"
         "[schedule_bitmap: %i]"
         "[enforce_quotas_per_pool_member: %i]"
         "[enforce_shapers_per_pool_member: %i]",
         iface->get_name(), i, _pool_id, rsp, children_safe[_pool_id],
         forge_global_dns[_pool_id], pool_shaper[_pool_id],
         schedule_bitmap[_pool_id], enforce_quotas_per_pool_member[_pool_id],
         enforce_shapers_per_pool_member[_pool_id]);
 #endif
 
 #endif /* NTOPNG_PRO */
 
     snprintf(kname, sizeof(kname), HOST_POOL_MEMBERS_KEY, pools[i]);
 
     /* Pool members are the elements of the list */
     if ((num_members = redis->smembers(kname, &pool_members)) > 0) {
       // NOTE: the auto-assigned host_pool must not be limited as it receives
       // devices assigments automatically
       actual_num_members =
           min_val((u_int32_t)num_members,
                   ((_pool_id == ntop->getPrefs()->get_auto_assigned_pool_id())
                        ? MAX_NUM_INTERFACE_HOSTS
                        : MAX_NUM_POOL_MEMBERS));
 
       if (actual_num_members < num_members) {
         ntop->getTrace()->traceEvent(
             TRACE_WARNING,
             "Too many members [pool id: %2d][pool members: %d]. "
             "Maximum number of pool members for this license is %u, so %u pool "
             "members will be ignored.",
             _pool_id, num_members, actual_num_members,
             num_members - actual_num_members, actual_num_members);
       }
 
       for (int k = 0; k < actual_num_members; k++) {
         member = pool_members[k];
 
         if (!member) continue;
 
         if ((at = strchr(member, '@'))) {
           vlan_id = atoi(at + 1);
           *at = '\0';
         } else
           vlan_id = 0;
 
         bool rc;
 
         if (!(rc = new_tree->addAddress(vlan_id, member, _pool_id))
 #ifdef HOST_POOLS_DEBUG
             || true
 #endif
         )
 
           ntop->getTrace()->traceEvent(
               TRACE_NORMAL, "%s tree node for %s [vlan %i] [host pool: %s]",
               rc ? "Successfully added" : "Unable to add", member, vlan_id,
               pools[i]);
 
         free(member);
       }
 
       free(pool_members);
     }
 
     free(pools[i]);
   }
 
   if (pools) free(pools);
 
   swap(new_tree, new_stats);
 
   iface->refreshHostPools();
 }
 
 /* *************************************** */
diff --git a/src/IEC104Stats.cpp b/src/IEC104Stats.cpp
index 982f56695..1a81a6659 100644
--- a/src/IEC104Stats.cpp
+++ b/src/IEC104Stats.cpp
@@ -46,7 +46,7 @@ IEC104Stats::IEC104Stats() {
 
 /* *************************************** */
 
-IEC104Stats::~IEC104Stats() { ndpi_free_data_analysis(i_s_apdu, 0); }
+IEC104Stats::~IEC104Stats() { ndpi_free_data_analysis(i_s_apdu, 1); }
 
 /* *************************************** */
 
diff --git a/src/LocalHost.cpp b/src/LocalHost.cpp
index 70dac0aa6..8b30de7c4 100644
--- a/src/LocalHost.cpp
+++ b/src/LocalHost.cpp
@@ -160,54 +160,56 @@ void LocalHost::deferredInitialization() {
 void LocalHost::addInactiveData() {
   /* Remove the key from the hash, used to get the offline hosts */
   /* Exclude the multicast/broadcast addresses */
   if(!ntop->getRedis() || !isLocalUnicastHost())
     return;
 
   /* Exclude local-link fe80::/10, marked as private */
   if(isIPv6() && isPrivateHost())
     return;
 
   char buf[64], *json_str = NULL;
   ndpi_serializer host_json;
   u_int32_t json_str_len = 0;
   Mac *cur_mac = getMac();
 
   /* In case the MAC is NULL or the MAC is a special */
   /* address or a broadcast address do not include it */
   if(!cur_mac || cur_mac->isSpecialMac() || cur_mac->isBroadcast())
     return;
 
 #if 0
   ntop->getTrace()->traceEvent(TRACE_NORMAL, 
     "Adding Host %s to inactive hosts Interace %d, with MAC: %s",
     ip.print(buf, sizeof(buf)),
     iface->get_id(),
     cur_mac->print(buf, sizeof(buf)));
 #endif                               
  
   ndpi_init_serializer(&host_json, ndpi_serialization_format_json);
   ndpi_serialize_string_string(&host_json, "ip", ip.print(buf, sizeof(buf)));
 
   ndpi_serialize_string_uint64(&host_json, "first_seen", get_first_seen());
   ndpi_serialize_string_uint64(&host_json, "last_seen",  get_last_seen());
 
   if(cur_mac) {
     ndpi_serialize_string_uint32(&host_json, "device_type", getDeviceType());
     ndpi_serialize_string_string(&host_json, "mac", cur_mac->print(buf, sizeof(buf)));
   }
 
   ndpi_serialize_string_uint32(&host_json, "vlan", (u_int16_t) get_vlan_id());
   ndpi_serialize_string_uint32(&host_json, "network", (u_int16_t) get_local_network_id());
   ndpi_serialize_string_string(&host_json, "name", get_name(buf, sizeof(buf), false));
   
 
   
   json_str = ndpi_serializer_get_buffer(&host_json, &json_str_len);
   if ((json_str != NULL) && (json_str_len > 0)) {
     char key[128], redis_key[64];
     snprintf(redis_key, sizeof(redis_key), OFFLINE_LOCAL_HOSTS_KEY, iface->get_id());
     ntop->getRedis()->hashSet(redis_key, getSerializationKey(key, sizeof(key)), json_str);
   }
+
+  ndpi_term_serializer(&host_json);
 }
 
 /* *************************************** */
diff --git a/src/NetworkInterface.cpp b/src/NetworkInterface.cpp
index 2ac31d425..2a1f78152 100644
--- a/src/NetworkInterface.cpp
+++ b/src/NetworkInterface.cpp
@@ -2427,684 +2427,693 @@ u_int16_t NetworkInterface::guessEthType(const u_char *p, u_int len,
 bool NetworkInterface::dissectPacket(u_int32_t bridge_iface_idx,
                                      bool ingressPacket, u_int8_t *sender_mac,
                                      const struct pcap_pkthdr *h,
                                      const u_char *packet,
                                      u_int16_t *ndpiProtocol, Host **srcHost,
                                      Host **dstHost, Flow **flow) {
   struct ndpi_ethhdr *ethernet = NULL, dummy_ethernet;
   u_int64_t time;
   u_int16_t eth_type, ip_offset = 0, vlan_id = 0, eth_offset = 0,
     encapsulation_overhead = 0;
   u_int32_t null_type;
   int pcap_datalink_type = get_datalink();
   bool pass_verdict = true;
   u_int32_t len_on_wire = h->len * getScalingFactor();
   *flow = NULL;
 
   /* Note summy ethernet is always 0 unless sender_mac is set (Netfilter only)
    */
   memset(&dummy_ethernet, 0, sizeof(dummy_ethernet));
 
   pollQueuedeCompanionEvents();
   bcast_domains->reloadBroadcastDomains();
 
   /* Netfilter interfaces don't report MAC addresses on packets */
   if (getIfType() == interface_type_NETFILTER)
     len_on_wire += sizeof(struct ndpi_ethhdr);
 
   if (h->len == 0) {
     return (false);
   } else if (h->len > ifMTU) {
     if (!mtuWarningShown) {
 #ifdef __linux__
       ntop->getTrace()->traceEvent(
 				   TRACE_NORMAL,
 				   "Packets exceeding the expected max size have been received "
 				   "[len: %u][max len: %u].",
 				   h->len, ifMTU);
 
       if (!read_from_pcap_dump()) {
         ntop->getTrace()->traceEvent(
 				     TRACE_WARNING,
 				     "If TSO/GRO is enabled, please disable it for best accuracy");
         if (strchr(ifname, ':') ==
             NULL) /* print ethtool command for standard interfaces only */
           ntop->getTrace()->traceEvent(
 				       TRACE_WARNING,
 				       "using: sudo ethtool -K %s gro off gso off tso off", ifname);
       }
 #endif
       mtuWarningShown = true;
     }
   }
 
   setTimeLastPktRcvd(h->ts.tv_sec);
 
   if (last_purge_idle != (u_int32_t)h->ts.tv_sec) {
     if (!read_from_pcap_dump()) purgeIdle(h->ts.tv_sec);
     last_purge_idle = h->ts.tv_sec;
   }
 
   time = ((uint64_t)h->ts.tv_sec) * 1000 + h->ts.tv_usec / 1000;
 
  datalink_check:
   if (pcap_datalink_type == DLT_NULL) {
     if (h->caplen < sizeof(u_int32_t))
       return (false);
 
     if((eth_offset + sizeof(u_int32_t)) <= h->caplen)
       memcpy(&null_type, &packet[eth_offset], sizeof(u_int32_t));
     else
       return (false);
 
     switch (null_type) {
     case BSD_AF_INET:
       eth_type = ETHERTYPE_IP;
       break;
     case BSD_AF_INET6_BSD:
     case BSD_AF_INET6_FREEBSD:
     case BSD_AF_INET6_DARWIN:
       eth_type = ETHERTYPE_IPV6;
       break;
     default:
       incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
 	       NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
       goto dissect_packet_end; /* Any other non IP protocol */
     }
 
     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
     if (sender_mac) memcpy(&dummy_ethernet.h_source, sender_mac, 6);
     ip_offset = 4 + eth_offset;
   } else if (pcap_datalink_type == DLT_EN10MB) {
     if (h->caplen < sizeof(ndpi_ethhdr))
       return (false);
 
     ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];
     ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;
     eth_type = ntohs(ethernet->h_proto);
   } else if (pcap_datalink_type == 113 /* Linux Cooked Capture */) {
     if (h->caplen < 16)
       return (false);
 
     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
     if (sender_mac) memcpy(&dummy_ethernet.h_source, sender_mac, 6);
     eth_type = (packet[eth_offset + 14] << 8) + packet[eth_offset + 15];
     ip_offset = 16 + eth_offset;
 #ifdef DLT_RAW
   } else if (pcap_datalink_type == DLT_RAW /* Linux TUN/TAP device in TUN mode; Raw IP capture */
              || pcap_datalink_type == 14 /* raw IP DLT_RAW on OpenBSD captures */) {
     if (h->caplen < sizeof(u_int32_t))
       return (false);
 
     switch ((packet[eth_offset] & 0xf0) >> 4) {
     case 4:
       eth_type = ETHERTYPE_IP;
       break;
     case 6:
       eth_type = ETHERTYPE_IPV6;
       break;
     default:
       incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
 	       NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
       goto dissect_packet_end; /* Unknown IP protocol version */
     }
 
     if (sender_mac) memcpy(&dummy_ethernet.h_source, sender_mac, 6);
     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
     ip_offset = eth_offset;
 #endif /* DLT_RAW */
   } else if (pcap_datalink_type == DLT_ENC) {
     if (packet[0] == 2 /* IPv4 */) {
       eth_type = ETHERTYPE_IP;
       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
       ip_offset = 12;
     }
     /* TODO support IPv6 encapsulation one day */
   } else if (pcap_datalink_type == DLT_IPV4) {
     eth_type = ETHERTYPE_IP;
     if (sender_mac) memcpy(&dummy_ethernet.h_source, sender_mac, 6);
     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
     ip_offset = 0;
   } else {
     incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
              NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
     goto dissect_packet_end;
   }
 
   /*
     Make sure this label is BEFORE detunneling of VLAN or MPLS traffic.
     Otherwise, VLAN or MPLS traffic carried inside other tunnels, i.e.,
     GRE or ERSPAN, won't be detunneled.
   */
  decode_packet_eth:
 
   while (ip_offset < h->caplen) {
     if((eth_type == 0x8100 /* VLAN */) && ((ip_offset + sizeof(Ether80211q)) < h->caplen)) {
       Ether80211q *qType = (Ether80211q *)&packet[ip_offset];
 
       vlan_id = ntohs(qType->vlanId) & 0xFFF;
       eth_type = (packet[ip_offset + 2] << 8) + packet[ip_offset + 3];
       ip_offset += 4;
     } else if((eth_type == 0x8847 /* MPLS */) && ((unsigned int)(ip_offset + 2) <  h->caplen)) {
       u_int8_t bos; /* bottom_of_stack */
 
       bos = (((u_int8_t)packet[ip_offset + 2]) & 0x1), ip_offset += 4;
       if (bos) {
         u_int8_t is_ethernet;
 
         eth_type = guessEthType((const u_char *)&packet[ip_offset],
                                 h->caplen - ip_offset, &is_ethernet);
 
         if (is_ethernet) ip_offset += sizeof(struct ndpi_ethhdr);
         break;
       }
     } else
       break;
   }
 
   /* Setting traffic direction based on MAC */
   if (ethernet) {
     if (isTrafficMirrored()) {
       /* Mirror */
       if (isGwMac(ethernet->h_dest)) ingressPacket = false;
     } else if (!areTrafficDirectionsSupported()) {
       /* Interface with no direction info */
       if (isInterfaceMac(ethernet->h_source)) ingressPacket = false;
     }
   }
 
   switch (eth_type) {
   case ETHERTYPE_PPPoE:
     ip_offset += 6 /* PPPoE */;
     /* Now we need to skip the PPP header */
     if (packet[ip_offset] == 0x0)
       eth_type = packet[ip_offset + 1], ip_offset += 2; /* 2 Byte protocol */
     else
       eth_type = packet[ip_offset], ip_offset += 1; /* 1 Byte protocol */
 
     switch (eth_type) {
     case 0x21:
       eth_type = ETHERTYPE_IP;
       break;
 
     case 0x57:
       eth_type = ETHERTYPE_IPV6;
       break;
 
     default:
       incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IP,
 	       NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0,
 	       len_on_wire, 1);
       goto dissect_packet_end;
     }
     goto decode_packet_eth;
     break;
 
   case ETHERTYPE_IP:
     if (h->caplen >= ip_offset + sizeof(struct ndpi_iphdr)) {
       u_int16_t frag_off;
       struct ndpi_iphdr *iph = (struct ndpi_iphdr *)&packet[ip_offset];
       u_short ip_len = ((u_short)iph->ihl * 4);
       struct ndpi_ipv6hdr *ip6 = NULL;
 
       if (iph->version != 4) {
 	/* This is not IPv4 */
 	incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IP,
 		 NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0,
 		 len_on_wire, 1);
 	goto dissect_packet_end;
       } else
 	frag_off = ntohs(iph->frag_off);
 
       if (ntop->getGlobals()->decode_tunnels() &&
 	  (iph->protocol == IPPROTO_GRE) &&
 	  ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */) == 0) &&
 	  h->caplen >= ip_offset + ip_len + sizeof(struct grev1_header)) {
 	struct grev1_header gre;
 	u_int offset = ip_offset + ip_len + sizeof(struct grev1_header);
 
 	memcpy(&gre, &packet[ip_offset + ip_len],
 	       sizeof(struct grev1_header));
 	gre.flags_and_version = ntohs(gre.flags_and_version);
 	gre.proto = ntohs(gre.proto);
 
 	if (gre.flags_and_version &
 	    (GRE_HEADER_CHECKSUM | GRE_HEADER_ROUTING))
 	  offset += 4;
 	if (gre.flags_and_version & GRE_HEADER_KEY) offset += 4;
 	if (gre.flags_and_version & GRE_HEADER_SEQ_NUM) offset += 4;
 
 	if (h->caplen >= offset) {
 	  if (gre.proto == 0x6558 /* Transparent Ethernet Bridging */) {
 	    eth_offset = offset;
 	    goto datalink_check;
 	  } else if (gre.proto == ETHERTYPE_IP) {
 	    ip_offset = offset, encapsulation_overhead = offset;
 	    goto decode_packet_eth;
 	  } else if (gre.proto == ETHERTYPE_IPV6) {
 	    eth_type = ETHERTYPE_IPV6;
 	    ip_offset = offset, encapsulation_overhead = offset;
 	    goto decode_packet_eth;
 	  }
 	}
 
 	/* ERSPAN Type 2 has an 8-byte header
 	   https://tools.ietf.org/html/draft-foschiano-erspan-00 */
 	if (h->caplen >= offset + sizeof(struct ndpi_ethhdr) + 8) {
 	  if (gre.proto == ETH_P_ERSPAN /* ERSPAN type II */) {
 	    offset += 8;
 	    eth_offset = offset, encapsulation_overhead = offset;
 	    ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];
 	    ip_offset = eth_offset + sizeof(struct ndpi_ethhdr);
 	    eth_type = ntohs(ethernet->h_proto);
 	    goto decode_packet_eth;
 	  } else if (gre.proto ==
 		     ETH_P_ERSPAN2 /* ERSPAN version 2 (type III) */) {
 	    if (h->caplen >= offset + sizeof(struct ndpi_ethhdr) + 20) {
 	      offset += 20;
 	      eth_offset = offset, encapsulation_overhead = offset;
 	      ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];
 	      ip_offset = eth_offset + sizeof(struct ndpi_ethhdr);
 	      eth_type = ntohs(ethernet->h_proto);
 	      goto decode_packet_eth;
 	    }
 	  } else {
 	    /* Unknown encapsulation */
 	  }
 	}
       } else if (ntop->getGlobals()->decode_tunnels() &&
 		 iph->protocol == IPPROTO_IPV6 &&
 		 h->caplen >=
 		 ip_offset + ip_len + sizeof(struct ndpi_ipv6hdr)) {
 	/* Detunnel 6in4 tunnel */
 	ip_offset += ip_len;
 	eth_type = ETHERTYPE_IPV6;
 	encapsulation_overhead = ip_offset;
 	goto decode_packet_eth;
       } else if (ntop->getGlobals()->decode_tunnels() &&
 		 (iph->protocol == IPPROTO_UDP) &&
 		 ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */) == 0)) {
+
+	if(ip_offset + ip_len + sizeof(struct ndpi_udphdr) > h->caplen) {
+	  incStats(ingressPacket, h->ts.tv_sec, 0,
+		   NDPI_PROTOCOL_UNKNOWN,
+		   NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire,
+		   1);
+	  goto dissect_packet_end;
+        }
+
 	struct ndpi_udphdr *udp =
 	  (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
 	u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);
 
 	if ((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
 	  /* Check if it's GTPv1 */
 	  u_int offset =
 	    (u_int)(ip_offset + ip_len + sizeof(struct ndpi_udphdr));
 	  u_int8_t flags = packet[offset];
 	  u_int8_t message_type = packet[offset + 1];
 
 	  if ((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) &&
 	      (message_type == 0xFF /* T-PDU */)) {
 	    ip_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr) +
 	      8 /* GTPv1 header len */;
 
 	    if (flags & 0x04) ip_offset += 1; /* next_ext_header is present */
 	    if (flags & 0x02)
 	      ip_offset += 4; /* sequence_number is present (it also includes
 				 next_ext_header and pdu_number) */
 	    if (flags & 0x01) ip_offset += 1; /* pdu_number is present */
 
 	    iph = (struct ndpi_iphdr *)&packet[ip_offset];
 
 	    if (iph->version != 4) {
 	      /* FIX - Add IPv6 support */
 	      incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IPV6,
 		       NDPI_PROTOCOL_UNKNOWN,
 		       NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
 	      goto dissect_packet_end;
 	    }
 	  }
 	} else if ((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
 	  /* https://en.wikipedia.org/wiki/TZSP */
 	  u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
 	  u_int8_t version = packet[offset];
 	  u_int8_t type = packet[offset + 1];
 	  u_int16_t encapsulates = ntohs(*((u_int16_t *)&packet[offset + 2]));
 
 	  if ((version == 1) && (type == 0) && (encapsulates == 1)) {
 	    u_int8_t stop = 0;
 
 	    offset += 4;
 
 	    while ((!stop) && (offset < h->caplen)) {
 	      u_int8_t tag_type = packet[offset];
 	      u_int8_t tag_len;
 
 	      switch (tag_type) {
 	      case 0: /* PADDING Tag */
 		tag_len = 1;
 		break;
 	      case 1: /* END Tag */
 		tag_len = 1, stop = 1;
 		break;
 	      default:
 		tag_len = packet[offset + 1];
 		break;
 	      }
 
 	      offset += tag_len;
 
 	      if (offset >= h->caplen) {
 		incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IPV6,
 			 NDPI_PROTOCOL_UNKNOWN,
 			 NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire,
 			 1);
 		goto dissect_packet_end;
 	      } else {
 		eth_offset = offset;
 		goto datalink_check;
 	      }
 	    }
 	  }
 	} else if (dport == VXLAN_PORT) {
 	  eth_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr) +
 	    sizeof(struct ndpi_vxlanhdr);
 	  goto datalink_check;
 	}
 
 	if ((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {
 	  /*
 	    Control And Provisioning of Wireless Access Points
 
 	    https://www.rfc-editor.org/rfc/rfc5415.txt
 
 	    CAPWAP Header          - variable length (5 MSB of byte 2 of
 	    header) IEEE 802.11 Data Flags - 24 bytes Logical-Link Control   -
 	    8  bytes
 
 	    Total = CAPWAP_header_length + 24 + 8
 	  */
 	  u_short eth_type;
 	  ip_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
 	  u_int8_t capwap_header_len =
 	    ((*(u_int8_t *)&packet[ip_offset + 1]) >> 3) * 4;
 	  ip_offset = ip_offset + capwap_header_len + 24 + 8;
 
 	  if (ip_offset >= h->len) {
 	    incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
 		     NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
 	    goto dissect_packet_end;
 	  }
 	  eth_type = ntohs(*(u_int16_t *)&packet[ip_offset - 2]);
 
 	  switch (eth_type) {
 	  case ETHERTYPE_IP:
 	    iph = (struct ndpi_iphdr *)&packet[ip_offset];
 	    break;
 	  case ETHERTYPE_IPV6:
 	    iph = NULL;
 	    ip6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
 	    break;
 	  default:
 	    incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
 		     NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
 	    goto dissect_packet_end;
 	  }
 	}
       } else if (ntop->getGlobals()->decode_tunnels() &&
 		 (iph->protocol == IPPROTO_IP_IN_IP)) {
 	u_short ip_len = ((u_short)iph->ihl * 4);
 
 	ip_offset += ip_len, eth_type = ETHERTYPE_IP;
 
 	if (ip_offset > h->caplen)
 	  goto dissect_packet_end;
 	else
 	  goto decode_packet_eth;
       }
 
       if (vlan_id && ntop->getPrefs()->do_ignore_vlans()) vlan_id = 0;
       if ((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())
 	vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] +
 		   ip6->ip6_dst.u6_addr.u6_addr8[15]
 		   : iph->saddr + iph->daddr) &
 	  0xFFF;
 
       if (ntop->getPrefs()->do_ignore_macs())
 	ethernet = &dummy_ethernet;
       else if (unlikely(ntop->getPrefs()->do_simulate_macs())) {
 	dummy_ethernet.h_source[0] = 0xb8, dummy_ethernet.h_source[1] = 0x27,
           dummy_ethernet.h_source[2] = 0xeb, dummy_ethernet.h_source[3] = 0xfd,
           dummy_ethernet.h_source[4] = 0x8e,
           dummy_ethernet.h_source[5] = rand() % 8;
 	dummy_ethernet.h_dest[0] = 0xb8, dummy_ethernet.h_dest[1] = 0x27,
           dummy_ethernet.h_dest[2] = 0xeb, dummy_ethernet.h_dest[3] = 0xfd,
           dummy_ethernet.h_dest[4] = 0x8e,
           dummy_ethernet.h_dest[5] = rand() % 8;
 	ethernet = &dummy_ethernet;
       }
 
       try {
 	pass_verdict = processPacket(
 				     bridge_iface_idx, ingressPacket, &h->ts, time, ethernet, vlan_id,
 				     iph, ip6, ip_offset, encapsulation_overhead, len_on_wire, h,
 				     packet, ndpiProtocol, srcHost, dstHost, flow);
       } catch (std::bad_alloc &ba) {
 	static bool oom_warning_sent = false;
 
 	if (!oom_warning_sent) {
 	  ntop->getTrace()->traceEvent(TRACE_WARNING, "Not enough memory");
 	  oom_warning_sent = true;
 	}
       }
     }
     break;
 
   case ETHERTYPE_IPV6:
     if (h->caplen >= ip_offset + sizeof(struct ndpi_ipv6hdr)) {
       struct ndpi_iphdr *iph = NULL;
       struct ndpi_ipv6hdr *ip6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
 
       if ((ntohl(ip6->ip6_hdr.ip6_un1_flow) & 0xF0000000) != 0x60000000) {
 	/* This is not IPv6 */
 	incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IPV6,
 		 NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0,
 		 len_on_wire, 1);
 	goto dissect_packet_end;
       } else {
 	u_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);
 	u_int8_t l4_proto = ip6->ip6_hdr.ip6_un1_nxt;
 
 	if (l4_proto == 0x3C /* IPv6 destination option */) {
 	  u_int8_t *options = (u_int8_t *)ip6 + ipv6_shift;
 	  l4_proto = options[0];
 	  ipv6_shift = 8 * (options[1] + 1);
 	}
 
 	if (ntop->getGlobals()->decode_tunnels() &&
 	    (l4_proto == IPPROTO_GRE) &&
 	    h->caplen >=
 	    ip_offset + ipv6_shift + sizeof(struct grev1_header)) {
 	  struct grev1_header gre;
 	  u_int offset = ip_offset + ipv6_shift + sizeof(struct grev1_header);
 
 	  memcpy(&gre, &packet[ip_offset + ipv6_shift],
 		 sizeof(struct grev1_header));
 	  gre.flags_and_version = ntohs(gre.flags_and_version);
 	  gre.proto = ntohs(gre.proto);
 
 	  if (gre.flags_and_version &
 	      (GRE_HEADER_CHECKSUM | GRE_HEADER_ROUTING))
 	    offset += 4;
 	  if (gre.flags_and_version & GRE_HEADER_KEY) offset += 4;
 	  if (gre.flags_and_version & GRE_HEADER_SEQ_NUM) offset += 4;
 
 	  if (h->caplen >= offset) {
 	    if (gre.proto == ETHERTYPE_IP) {
 	      eth_type = ETHERTYPE_IP;
 	      ip_offset = offset, encapsulation_overhead = offset;
 	      goto decode_packet_eth;
 	    } else if (gre.proto == ETHERTYPE_IPV6) {
 	      ip_offset = offset, encapsulation_overhead = offset;
 	      goto decode_packet_eth;
 	    }
 	  }
 
 	  if (h->caplen >= offset + sizeof(struct ndpi_ethhdr) +
 	      8 /* ERSPAN Type 2 header */) {
 	    if (gre.proto == ETH_P_ERSPAN) {
 	      offset += 8;
 	      eth_offset = offset, encapsulation_overhead = offset;
 	      ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];
 	      ip_offset = eth_offset + sizeof(struct ndpi_ethhdr);
 	      eth_type = ntohs(ethernet->h_proto);
 	      goto decode_packet_eth;
 	    } else if (gre.proto == ETH_P_ERSPAN2) {
 	      ; /* TODO: support ERSPAN Type 3 */
 	    } else {
 	      /* Unknown encapsulation */
 	    }
 	  }
 	} else if (ntop->getGlobals()->decode_tunnels() &&
 		   (l4_proto == IPPROTO_UDP)) {
 	  // ip_offset += ipv6_shift;
 	  if ((ip_offset + ipv6_shift) >= h->len) {
 	    incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IPV6,
 		     NDPI_PROTOCOL_UNKNOWN,
 		     NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
 	    goto dissect_packet_end;
 	  }
 
 	  struct ndpi_udphdr *udp =
 	    (struct ndpi_udphdr *)&packet[ip_offset + ipv6_shift];
 	  u_int16_t sport = udp->source, dport = udp->dest;
 
 	  if ((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {
 	    /*
 	      Control And Provisioning of Wireless Access Points
 
 	      https://www.rfc-editor.org/rfc/rfc5415.txt
 
 	      CAPWAP Header          - variable length (5 MSB of byte 2 of
 	      header) IEEE 802.11 Data Flags - 24 bytes Logical-Link Control
 	      - 8  bytes
 
 	      Total = CAPWAP_header_length + 24 + 8
 	    */
 
 	    u_short eth_type;
 	    ip_offset = ip_offset + ipv6_shift + sizeof(struct ndpi_udphdr);
 	    u_int8_t capwap_header_len =
 	      ((*(u_int8_t *)&packet[ip_offset + 1]) >> 3) * 4;
 	    ip_offset = ip_offset + capwap_header_len + 24 + 8;
 
 	    if (ip_offset >= h->len) {
 	      incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
 		       NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
 	      goto dissect_packet_end;
 	    }
 	    eth_type = ntohs(*(u_int16_t *)&packet[ip_offset - 2]);
 
 	    switch (eth_type) {
 	    case ETHERTYPE_IP:
 	      iph = (struct ndpi_iphdr *)&packet[ip_offset];
 	      ip6 = NULL;
 	      break;
 	    case ETHERTYPE_IPV6:
 	      ip6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
 	      break;
 	    default:
 	      incStats(
 		       ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
 		       NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
 	      goto dissect_packet_end;
 	    }
 	  }
 	} else if (ntop->getGlobals()->decode_tunnels() &&
 		   (l4_proto == IPPROTO_IP_IN_IP)) {
 	  eth_type = ETHERTYPE_IP;
 	  ip_offset += sizeof(struct ndpi_ipv6hdr);
 	  encapsulation_overhead = ip_offset;
 	  goto decode_packet_eth;
 	}
 
 	if (vlan_id && ntop->getPrefs()->do_ignore_vlans()) vlan_id = 0;
 	if ((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())
 	  vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] +
 		     ip6->ip6_dst.u6_addr.u6_addr8[15]
 		     : iph->saddr + iph->daddr) %
 	    0xFF;
 
 	if (ntop->getPrefs()->do_ignore_macs()) ethernet = &dummy_ethernet;
 
 	try {
 	  pass_verdict = processPacket(
 				       bridge_iface_idx, ingressPacket, &h->ts, time, ethernet,
 				       vlan_id, iph, ip6, ip_offset, encapsulation_overhead,
 				       len_on_wire, h, packet, ndpiProtocol, srcHost, dstHost, flow);
 	} catch (std::bad_alloc &ba) {
 	  static bool oom_warning_sent = false;
 
 	  if (!oom_warning_sent) {
 	    ntop->getTrace()->traceEvent(TRACE_WARNING, "Not enough memory");
 	    oom_warning_sent = true;
 	  }
 	}
       }
     }
     break;
 
   default: /* No IPv4 nor IPv6 */
     if (ntop->getPrefs()->do_ignore_macs()) ethernet = &dummy_ethernet;
 
     if (ethernet == NULL) {
       incStats(ingressPacket, h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN,
 	       NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
       goto dissect_packet_end;
     }
 
     Mac *srcMac = getMac(ethernet->h_source, true /* Create if missing */,
 			 true /* Inline call */);
     Mac *dstMac = getMac(ethernet->h_dest, true /* Create if missing */,
 			 true /* Inline call */);
 
     /* NOTE: in nEdge, stats are updated into Flow::update_hosts_stats */
 #ifndef HAVE_NEDGE
     if (srcMac) srcMac->incSentStats(h->ts.tv_sec, 1, len_on_wire);
     if (dstMac) dstMac->incRcvdStats(h->ts.tv_sec, 1, len_on_wire);
 #endif
 
     if ((eth_type == ETHERTYPE_ARP) &&
 	(h->caplen >= (sizeof(arp_header) + sizeof(struct ndpi_ethhdr)))) {
       struct arp_header *arpp = (struct arp_header *)&packet[ip_offset];
       u_int16_t arp_opcode = ntohs(arpp->ar_op);
 
       /* Updates interface broadcast domains, according to what is seen in
        * this ARP that glues together L2 and L3 */
       updateBroadcastDomains(vlan_id, ethernet->h_source, ethernet->h_dest,
 			     ntohl(arpp->arp_spa), ntohl(arpp->arp_tpa));
 
       if (srcMac && dstMac && (!srcMac->isNull() || !dstMac->isNull())) {
 	setSeenMacAddresses();
 	srcMac->setSourceMac();
 
 	if (arp_opcode == 0x1 /* ARP request */) {
 	  arp_requests++;
 	  srcMac->incSentArpRequests();
 	  dstMac->incRcvdArpRequests();
 	} else if (arp_opcode == 0x2 /* ARP reply */) {
 	  arp_replies++;
 	  srcMac->incSentArpReplies();
 	  dstMac->incRcvdArpReplies();
 
 	  checkMacIPAssociation(true, arpp->arp_sha, arpp->arp_spa, srcMac);
 	  checkMacIPAssociation(true, arpp->arp_tha, arpp->arp_tpa, dstMac);
 	}
       }
     }
 
     incStats(ingressPacket, h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN,
 	     NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
     break;
   }
 
  dissect_packet_end:
 
   /* Live packet dump to mongoose */
   if (num_live_captures > 0) deliverLiveCapture(h, packet, *flow);
 
   return (pass_verdict);
 }
 
 /* **************************************************** */
