commit 88ac43ed6a46caa2851b4a60b838bba9f151bd09
Merge: 96185e9b 80e1504f
Author: Theodore Ts'o <tytso@mit.edu>
Date:   Sat Aug 6 02:37:24 2022 -0400

    Merge branch 'maint' into next

diff --git a/configure b/configure
index effd929d..530bc77c 100755
--- a/configure
+++ b/configure
@@ -11254,7 +11254,7 @@ fi
 if test -n "$DLOPEN_LIB" ; then
    ac_cv_func_dlopen=yes
 fi
-for ac_func in  	__secure_getenv 	add_key 	backtrace 	chflags 	dlopen 	fadvise64 	fallocate 	fallocate64 	fchown 	fcntl 	fdatasync 	fstat64 	fsync 	ftruncate64 	futimes 	getcwd 	getdtablesize 	getentropy 	gethostname 	getmntinfo 	getpwuid_r 	getrandom 	getrlimit 	getrusage 	jrand48 	keyctl 	llistxattr 	llseek 	lseek64 	mallinfo 	mbstowcs 	memalign 	mempcpy 	mmap 	msync 	nanosleep 	open64 	pathconf 	posix_fadvise 	posix_fadvise64 	posix_memalign 	prctl 	pread 	pwrite 	pread64 	pwrite64 	secure_getenv 	setmntent 	setresgid 	setresuid 	snprintf 	srandom 	stpcpy 	strcasecmp 	strdup 	strnlen 	strptime 	strtoull 	sync_file_range 	sysconf 	usleep 	utime 	utimes 	valloc
+for ac_func in  	__secure_getenv 	add_key 	backtrace 	chflags 	dlopen 	fadvise64 	fallocate 	fallocate64 	fchown 	fcntl 	fdatasync 	fstat64 	fsync 	ftruncate64 	futimes 	getcwd 	getdtablesize 	getentropy 	gethostname 	getmntinfo 	getpwuid_r 	getrandom 	getrlimit 	getrusage 	jrand48 	keyctl 	llistxattr 	llseek 	lseek64 	mallinfo 	mallinfo2 	mbstowcs 	memalign 	mempcpy 	mmap 	msync 	nanosleep 	open64 	pathconf 	posix_fadvise 	posix_fadvise64 	posix_memalign 	prctl 	pread 	pwrite 	pread64 	pwrite64 	secure_getenv 	setmntent 	setresgid 	setresuid 	snprintf 	srandom 	stpcpy 	strcasecmp 	strdup 	strnlen 	strptime 	strtoull 	sync_file_range 	sysconf 	usleep 	utime 	utimes 	valloc
 do :
   as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
 ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
diff --git a/configure.ac b/configure.ac
index dff3d1ca..8acc4e1c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1186,66 +1186,67 @@ fi
 AC_CHECK_FUNCS(m4_flatten([
 	__secure_getenv
 	add_key
 	backtrace
 	chflags
 	dlopen
 	fadvise64
 	fallocate
 	fallocate64
 	fchown
 	fcntl
 	fdatasync
 	fstat64
 	fsync
 	ftruncate64
 	futimes
 	getcwd
 	getdtablesize
 	getentropy
 	gethostname
 	getmntinfo
 	getpwuid_r
 	getrandom
 	getrlimit
 	getrusage
 	jrand48
 	keyctl
 	llistxattr
 	llseek
 	lseek64
 	mallinfo
+	mallinfo2
 	mbstowcs
 	memalign
 	mempcpy
 	mmap
 	msync
 	nanosleep
 	open64
 	pathconf
 	posix_fadvise
 	posix_fadvise64
 	posix_memalign
 	prctl
 	pread
 	pwrite
 	pread64
 	pwrite64
 	secure_getenv
 	setmntent
 	setresgid
 	setresuid
 	snprintf
 	srandom
 	stpcpy
 	strcasecmp
 	strdup
 	strnlen
 	strptime
 	strtoull
 	sync_file_range
 	sysconf
 	usleep
 	utime
 	utimes
 	valloc
 ]))
diff --git a/e2fsck/extents.c b/e2fsck/extents.c
index 01879f56..86fe00e7 100644
--- a/e2fsck/extents.c
+++ b/e2fsck/extents.c
@@ -464,95 +464,96 @@ static void rebuild_extents(e2fsck_t ctx, const char *pass_name, int pr_header)
 /* Scan a file to see if we should rebuild its extent tree */
 errcode_t e2fsck_check_rebuild_extents(e2fsck_t ctx, ext2_ino_t ino,
 				  struct ext2_inode *inode,
 				  struct problem_context *pctx)
 {
 	struct extent_tree_info	eti;
 	struct ext2_extent_info	info, top_info;
 	struct ext2fs_extent	extent;
 	ext2_extent_handle_t	ehandle;
 	ext2_filsys		fs = ctx->fs;
 	errcode_t		retval;
 
 	/* block map file and we want extent conversion */
 	if (!(inode->i_flags & EXT4_EXTENTS_FL) &&
 	    !(inode->i_flags & EXT4_INLINE_DATA_FL) &&
 	    (ctx->options & E2F_OPT_CONVERT_BMAP)) {
 		return e2fsck_rebuild_extents_later(ctx, ino);
 	}
 
 	if (!(inode->i_flags & EXT4_EXTENTS_FL))
 		return 0;
 	memset(&eti, 0, sizeof(eti));
 	eti.ino = ino;
 
 	/* Otherwise, go scan the extent tree... */
 	retval = ext2fs_extent_open2(fs, ino, inode, &ehandle);
 	if (retval)
 		return 0;
 
 	retval = ext2fs_extent_get_info(ehandle, &top_info);
 	if (retval)
 		goto out;
 
 	/* Check maximum extent depth */
 	pctx->ino = ino;
 	pctx->blk = top_info.max_depth;
 	pctx->blk2 = ext2fs_max_extent_depth(ehandle);
 	if (pctx->blk2 < pctx->blk &&
 	    fix_problem(ctx, PR_1_EXTENT_BAD_MAX_DEPTH, pctx))
 		eti.force_rebuild = 1;
 
 	/* Can we collect extent tree level stats? */
 	pctx->blk = MAX_EXTENT_DEPTH_COUNT;
 	if (pctx->blk2 > pctx->blk)
 		fix_problem(ctx, PR_1E_MAX_EXTENT_TREE_DEPTH, pctx);
 
 	/* We need to fix tree depth problems, but the scan isn't a fix. */
 	if (ctx->options & E2F_OPT_FIXES_ONLY)
 		goto out;
 
 	retval = ext2fs_extent_get(ehandle, EXT2_EXTENT_ROOT, &extent);
 	if (retval)
 		goto out;
 
 	do {
 		retval = ext2fs_extent_get_info(ehandle, &info);
 		if (retval)
 			break;
 
 		/*
 		 * If this is the first extent in an extent block that we
 		 * haven't visited, collect stats on the block.
 		 */
 		if (info.curr_entry == 1 &&
 		    !(extent.e_flags & EXT2_EXTENT_FLAGS_SECOND_VISIT) &&
-		    !eti.force_rebuild) {
+		    !eti.force_rebuild &&
+		    info.curr_level < MAX_EXTENT_DEPTH_COUNT) {
 			struct extent_tree_level *etl;
 
 			etl = eti.ext_info + info.curr_level;
 			etl->num_extents += info.num_entries;
 			etl->max_extents += info.max_entries;
 			/*
 			 * Implementation wart: Splitting extent blocks when
 			 * appending will leave the old block with one free
 			 * entry.  Therefore unless the node is totally full,
 			 * pretend that a non-root extent block can hold one
 			 * fewer entry than it actually does, so that we don't
 			 * repeatedly rebuild the extent tree.
 			 */
 			if (info.curr_level &&
 			    info.num_entries < info.max_entries)
 				etl->max_extents--;
 		}
 
 		/* Skip to the end of a block of leaf nodes */
 		if (extent.e_flags & EXT2_EXTENT_FLAGS_LEAF) {
 			retval = ext2fs_extent_get(ehandle,
 						    EXT2_EXTENT_LAST_SIB,
 						    &extent);
 			if (retval)
 				break;
 		}
 
 		retval = ext2fs_extent_get(ehandle, EXT2_EXTENT_NEXT, &extent);
 	} while (retval == 0);
@@ -564,38 +565,45 @@ out:
 /* Having scanned a file's extent tree, decide if we should rebuild it */
 errcode_t e2fsck_should_rebuild_extents(e2fsck_t ctx,
 				   struct problem_context *pctx,
 				   struct extent_tree_info *eti,
 				   struct ext2_extent_info *info)
 {
 	struct extent_tree_level *ei;
 	int i, j, op;
 	unsigned int extents_per_block;
 
 	if (eti->force_rebuild)
 		goto rebuild;
 
 	if (ctx->options & E2F_OPT_NOOPT_EXTENTS)
 		return 0;
 
 	extents_per_block = (ctx->fs->blocksize -
 			     sizeof(struct ext3_extent_header)) /
 			    sizeof(struct ext3_extent);
+
+	/* If the extent tree is too deep, then rebuild it. */
+	if (info->max_depth > MAX_EXTENT_DEPTH_COUNT) {
+		pctx->blk = info->max_depth;
+		op = PR_1E_CAN_COLLAPSE_EXTENT_TREE;
+		goto rebuild;
+	}
 	/*
 	 * If we can consolidate a level or shorten the tree, schedule the
 	 * extent tree to be rebuilt.
 	 */
 	for (i = 0, ei = eti->ext_info; i < info->max_depth + 1; i++, ei++) {
 		if (ei->max_extents - ei->num_extents > extents_per_block) {
 			pctx->blk = i;
 			op = PR_1E_CAN_NARROW_EXTENT_TREE;
 			goto rebuild;
 		}
 		for (j = 0; j < i; j++) {
 			if (ei->num_extents < eti->ext_info[j].max_extents) {
 				pctx->blk = i;
 				op = PR_1E_CAN_COLLAPSE_EXTENT_TREE;
 				goto rebuild;
 			}
 		}
 	}
 	return 0;
diff --git a/e2fsck/iscan.c b/e2fsck/iscan.c
index 607e4752..33c6a4cd 100644
--- a/e2fsck/iscan.c
+++ b/e2fsck/iscan.c
@@ -98,61 +98,70 @@ static float timeval_subtract(struct timeval *tv1,
 void print_resource_track(const char *desc,
 			  struct resource_track *track, io_channel channel)
 {
 #ifdef HAVE_GETRUSAGE
 	struct rusage r;
 #endif
 	struct timeval time_end;
 
 	gettimeofday(&time_end, 0);
 
 	if (desc)
 		printf("%s: ", desc);
 
 #define kbytes(x)	(((unsigned long long)(x) + 1023) / 1024)
-#ifdef HAVE_MALLINFO
+#ifdef HAVE_MALLINFO2
+	if (1) {
+		struct mallinfo2 malloc_info = mallinfo2();
+
+		printf("Memory used: %lluk/%lluk (%lluk/%lluk), ",
+		       kbytes(malloc_info.arena), kbytes(malloc_info.hblkhd),
+		       kbytes(malloc_info.uordblks),
+		       kbytes(malloc_info.fordblks));
+	} else
+#elif defined HAVE_MALLINFO
 	/* don't use mallinfo() if over 2GB used, since it returns "int" */
 	if ((char *)sbrk(0) - (char *)track->brk_start < 2LL << 30) {
 		struct mallinfo	malloc_info = mallinfo();
 
 		printf("Memory used: %lluk/%lluk (%lluk/%lluk), ",
 		       kbytes(malloc_info.arena), kbytes(malloc_info.hblkhd),
 		       kbytes(malloc_info.uordblks),
 		       kbytes(malloc_info.fordblks));
 	} else
 #endif
 		printf("Memory used: %lluk, ",
 		       kbytes(((char *)sbrk(0)) - ((char *)track->brk_start)));
 
 #ifdef HAVE_GETRUSAGE
 	getrusage(RUSAGE_SELF, &r);
 
 	printf("time: %5.2f/%5.2f/%5.2f\n",
 	       timeval_subtract(&time_end, &track->time_start),
 	       timeval_subtract(&r.ru_utime, &track->user_start),
 	       timeval_subtract(&r.ru_stime, &track->system_start));
 #else
 	printf("elapsed time: %6.3f\n",
 	       timeval_subtract(&time_end, &track->time_start));
 #endif
 #define mbytes(x)	(((x) + 1048575) / 1048576)
 	if (channel && channel->manager && channel->manager->get_stats) {
 		io_stats delta = 0;
 		unsigned long long bytes_read = 0;
 		unsigned long long bytes_written = 0;
 
 		if (desc)
 			printf("%s: ", desc);
 
 		channel->manager->get_stats(channel, &delta);
 		if (delta) {
 			bytes_read = delta->bytes_read - track->bytes_read;
 			bytes_written = delta->bytes_written -
 				track->bytes_written;
 		}
 		printf("I/O read: %lluMB, write: %lluMB, "
 		       "rate: %.2fMB/s\n",
 		       mbytes(bytes_read), mbytes(bytes_written),
 		       (double)mbytes(bytes_read + bytes_written) /
 		       timeval_subtract(&time_end, &track->time_start));
 	}
 }
diff --git a/e2fsck/journal.c b/e2fsck/journal.c
index 2e867234..12487e3d 100644
--- a/e2fsck/journal.c
+++ b/e2fsck/journal.c
@@ -950,249 +950,256 @@ replay_done:
 static errcode_t e2fsck_get_journal(e2fsck_t ctx, journal_t **ret_journal)
 {
 	struct process_block_struct pb;
 	struct ext2_super_block *sb = ctx->fs->super;
 	struct ext2_super_block jsuper;
 	struct problem_context	pctx;
 	struct buffer_head 	*bh;
 	struct inode		*j_inode = NULL;
 	struct kdev_s		*dev_fs = NULL, *dev_journal;
 	const char		*journal_name = 0;
 	journal_t		*journal = NULL;
 	errcode_t		retval = 0;
 	io_manager		io_ptr = 0;
 	unsigned long long	start = 0;
 	int			ret;
 	int			ext_journal = 0;
 	int			tried_backup_jnl = 0;
 
 	clear_problem_context(&pctx);
 
 	journal = e2fsck_allocate_memory(ctx, sizeof(journal_t), "journal");
 	if (!journal) {
 		return EXT2_ET_NO_MEMORY;
 	}
 
 	dev_fs = e2fsck_allocate_memory(ctx, 2*sizeof(struct kdev_s), "kdev");
 	if (!dev_fs) {
 		retval = EXT2_ET_NO_MEMORY;
 		goto errout;
 	}
 	dev_journal = dev_fs+1;
 
 	dev_fs->k_ctx = dev_journal->k_ctx = ctx;
 	dev_fs->k_dev = K_DEV_FS;
 	dev_journal->k_dev = K_DEV_JOURNAL;
 
 	journal->j_dev = dev_journal;
 	journal->j_fs_dev = dev_fs;
 	journal->j_inode = NULL;
 	journal->j_blocksize = ctx->fs->blocksize;
 
 	if (uuid_is_null(sb->s_journal_uuid)) {
-		if (!sb->s_journal_inum) {
+		/*
+		 * The full set of superblock sanity checks haven't
+		 * been performed yet, so we need to do some basic
+		 * checks here to avoid potential array overruns.
+		 */
+		if (!sb->s_journal_inum ||
+		    (sb->s_journal_inum >
+		     (ctx->fs->group_desc_count * sb->s_inodes_per_group))) {
 			retval = EXT2_ET_BAD_INODE_NUM;
 			goto errout;
 		}
 		j_inode = e2fsck_allocate_memory(ctx, sizeof(*j_inode),
 						 "journal inode");
 		if (!j_inode) {
 			retval = EXT2_ET_NO_MEMORY;
 			goto errout;
 		}
 
 		j_inode->i_ctx = ctx;
 		j_inode->i_ino = sb->s_journal_inum;
 
 		if ((retval = ext2fs_read_inode(ctx->fs,
 						sb->s_journal_inum,
 						&j_inode->i_ext2))) {
 		try_backup_journal:
 			if (sb->s_jnl_backup_type != EXT3_JNL_BACKUP_BLOCKS ||
 			    tried_backup_jnl)
 				goto errout;
 			memset(&j_inode->i_ext2, 0, sizeof(struct ext2_inode));
 			memcpy(&j_inode->i_ext2.i_block[0], sb->s_jnl_blocks,
 			       EXT2_N_BLOCKS*4);
 			j_inode->i_ext2.i_size_high = sb->s_jnl_blocks[15];
 			j_inode->i_ext2.i_size = sb->s_jnl_blocks[16];
 			j_inode->i_ext2.i_links_count = 1;
 			j_inode->i_ext2.i_mode = LINUX_S_IFREG | 0600;
 			e2fsck_use_inode_shortcuts(ctx, 1);
 			ctx->stashed_ino = j_inode->i_ino;
 			ctx->stashed_inode = &j_inode->i_ext2;
 			tried_backup_jnl++;
 		}
 		if (!j_inode->i_ext2.i_links_count ||
 		    !LINUX_S_ISREG(j_inode->i_ext2.i_mode)) {
 			retval = EXT2_ET_NO_JOURNAL;
 			goto try_backup_journal;
 		}
 		if (EXT2_I_SIZE(&j_inode->i_ext2) / journal->j_blocksize <
 		    JBD2_MIN_JOURNAL_BLOCKS) {
 			retval = EXT2_ET_JOURNAL_TOO_SMALL;
 			goto try_backup_journal;
 		}
 		pb.last_block = -1;
 		retval = ext2fs_block_iterate3(ctx->fs, j_inode->i_ino,
 					       BLOCK_FLAG_HOLE, 0,
 					       process_journal_block, &pb);
 		if ((pb.last_block + 1) * ctx->fs->blocksize <
 		    (int) EXT2_I_SIZE(&j_inode->i_ext2)) {
 			retval = EXT2_ET_JOURNAL_TOO_SMALL;
 			goto try_backup_journal;
 		}
 		if (tried_backup_jnl && !(ctx->options & E2F_OPT_READONLY)) {
 			retval = ext2fs_write_inode(ctx->fs, sb->s_journal_inum,
 						    &j_inode->i_ext2);
 			if (retval)
 				goto errout;
 		}
 
 		journal->j_total_len = EXT2_I_SIZE(&j_inode->i_ext2) /
 			journal->j_blocksize;
 
 #ifdef USE_INODE_IO
 		retval = ext2fs_inode_io_intern2(ctx->fs, sb->s_journal_inum,
 						 &j_inode->i_ext2,
 						 &journal_name);
 		if (retval)
 			goto errout;
 
 		io_ptr = inode_io_manager;
 #else
 		journal->j_inode = j_inode;
 		ctx->journal_io = ctx->fs->io;
 		if ((ret = jbd2_journal_bmap(journal, 0, &start)) != 0) {
 			retval = (errcode_t) (-1 * ret);
 			goto errout;
 		}
 #endif
 	} else {
 		ext_journal = 1;
 		if (!ctx->journal_name) {
 			char uuid[37];
 
 			uuid_unparse(sb->s_journal_uuid, uuid);
 			ctx->journal_name = blkid_get_devname(ctx->blkid,
 							      "UUID", uuid);
 			if (!ctx->journal_name)
 				ctx->journal_name = blkid_devno_to_devname(sb->s_journal_dev);
 		}
 		journal_name = ctx->journal_name;
 
 		if (!journal_name) {
 			fix_problem(ctx, PR_0_CANT_FIND_JOURNAL, &pctx);
 			retval = EXT2_ET_LOAD_EXT_JOURNAL;
 			goto errout;
 		}
 
 		jfs_debug(1, "Using journal file %s\n", journal_name);
 		io_ptr = unix_io_manager;
 	}
 
 #if 0
 	test_io_backing_manager = io_ptr;
 	io_ptr = test_io_manager;
 #endif
 #ifndef USE_INODE_IO
 	if (ext_journal)
 #endif
 	{
 		int flags = IO_FLAG_RW;
 		if (!(ctx->mount_flags & EXT2_MF_ISROOT &&
 		      ctx->mount_flags & EXT2_MF_READONLY))
 			flags |= IO_FLAG_EXCLUSIVE;
 		if ((ctx->mount_flags & EXT2_MF_READONLY) &&
 		    (ctx->options & E2F_OPT_FORCE))
 			flags &= ~IO_FLAG_EXCLUSIVE;
 
 
 		retval = io_ptr->open(journal_name, flags,
 				      &ctx->journal_io);
 	}
 	if (retval)
 		goto errout;
 
 	io_channel_set_blksize(ctx->journal_io, ctx->fs->blocksize);
 
 	if (ext_journal) {
 		blk64_t maxlen;
 
 		start = ext2fs_journal_sb_start(ctx->fs->blocksize) - 1;
 		bh = getblk(dev_journal, start, ctx->fs->blocksize);
 		if (!bh) {
 			retval = EXT2_ET_NO_MEMORY;
 			goto errout;
 		}
 		ll_rw_block(REQ_OP_READ, 0, 1, &bh);
 		if ((retval = bh->b_err) != 0) {
 			brelse(bh);
 			goto errout;
 		}
 		memcpy(&jsuper, start ? bh->b_data :  bh->b_data + SUPERBLOCK_OFFSET,
 		       sizeof(jsuper));
 #ifdef WORDS_BIGENDIAN
 		if (jsuper.s_magic == ext2fs_swab16(EXT2_SUPER_MAGIC))
 			ext2fs_swap_super(&jsuper);
 #endif
 		if (jsuper.s_magic != EXT2_SUPER_MAGIC ||
 		    !ext2fs_has_feature_journal_dev(&jsuper)) {
 			fix_problem(ctx, PR_0_EXT_JOURNAL_BAD_SUPER, &pctx);
 			retval = EXT2_ET_LOAD_EXT_JOURNAL;
 			brelse(bh);
 			goto errout;
 		}
 		/* Make sure the journal UUID is correct */
 		if (memcmp(jsuper.s_uuid, ctx->fs->super->s_journal_uuid,
 			   sizeof(jsuper.s_uuid))) {
 			fix_problem(ctx, PR_0_JOURNAL_BAD_UUID, &pctx);
 			retval = EXT2_ET_LOAD_EXT_JOURNAL;
 			brelse(bh);
 			goto errout;
 		}
 
 		/* Check the superblock checksum */
 		if (ext2fs_has_feature_metadata_csum(&jsuper)) {
 			struct struct_ext2_filsys fsx;
 			struct ext2_super_block	superx;
 			void *p;
 
 			p = start ? bh->b_data : bh->b_data + SUPERBLOCK_OFFSET;
 			memcpy(&fsx, ctx->fs, sizeof(fsx));
 			memcpy(&superx, ctx->fs->super, sizeof(superx));
 			fsx.super = &superx;
 			ext2fs_set_feature_metadata_csum(fsx.super);
 			if (!ext2fs_superblock_csum_verify(&fsx, p) &&
 			    fix_problem(ctx, PR_0_EXT_JOURNAL_SUPER_CSUM_INVALID,
 					&pctx)) {
 				ext2fs_superblock_csum_set(&fsx, p);
 				mark_buffer_dirty(bh);
 			}
 		}
 		brelse(bh);
 
 		maxlen = ext2fs_blocks_count(&jsuper);
 		journal->j_total_len = (maxlen < 1ULL << 32) ? maxlen : (1ULL << 32) - 1;
 		start++;
 	}
 
 	if (!(bh = getblk(dev_journal, start, journal->j_blocksize))) {
 		retval = EXT2_ET_NO_MEMORY;
 		goto errout;
 	}
 
 	journal->j_sb_buffer = bh;
 	journal->j_superblock = (journal_superblock_t *)bh->b_data;
 	if (ext2fs_has_feature_fast_commit(ctx->fs->super))
 		journal->j_fc_replay_callback = ext4_fc_replay;
 	else
 		journal->j_fc_replay_callback = NULL;
 
 #ifdef USE_INODE_IO
 	if (j_inode)
 		ext2fs_free_mem(&j_inode);
 #endif
 
 	*ret_journal = journal;
 	e2fsck_use_inode_shortcuts(ctx, 0);
 	return 0;
diff --git a/e2fsck/logfile.c b/e2fsck/logfile.c
index 63e9a12f..7bdeae19 100644
--- a/e2fsck/logfile.c
+++ b/e2fsck/logfile.c
@@ -31,8 +31,8 @@ struct string {
 static void alloc_string(struct string *s, int len)
 {
 	s->s = malloc(len);
 /* e2fsck_allocate_memory(ctx, len, "logfile name"); */
-	s->len = len;
+	s->len = s->s ? len : 0;
 	s->end = 0;
 }
 
diff --git a/e2fsck/pass1.c b/e2fsck/pass1.c
index 26b9ab71..6bb72817 100644
--- a/e2fsck/pass1.c
+++ b/e2fsck/pass1.c
@@ -389,25 +389,28 @@ static problem_t check_large_ea_inode(e2fsck_t ctx,
 static void inc_ea_inode_refs(e2fsck_t ctx, struct problem_context *pctx,
 			      struct ext2_ext_attr_entry *first, void *end)
 {
-	struct ext2_ext_attr_entry *entry;
+	struct ext2_ext_attr_entry *entry = first;
+	struct ext2_ext_attr_entry *np = EXT2_EXT_ATTR_NEXT(entry);
 
-	for (entry = first;
-	     (void *)entry < end && !EXT2_EXT_IS_LAST_ENTRY(entry);
-	     entry = EXT2_EXT_ATTR_NEXT(entry)) {
+	while ((void *) entry < end && (void *) np < end &&
+	       !EXT2_EXT_IS_LAST_ENTRY(entry)) {
 		if (!entry->e_value_inum)
-			continue;
+			goto next;
 		if (!ctx->ea_inode_refs) {
 			pctx->errcode = ea_refcount_create(0,
 							   &ctx->ea_inode_refs);
 			if (pctx->errcode) {
 				pctx->num = 4;
 				fix_problem(ctx, PR_1_ALLOCATE_REFCOUNT, pctx);
 				ctx->flags |= E2F_FLAG_ABORT;
 				return;
 			}
 		}
 		ea_refcount_increment(ctx->ea_inode_refs, entry->e_value_inum,
 				      0);
+	next:
+		entry = np;
+		np = EXT2_EXT_ATTR_NEXT(entry);
 	}
 }
 
@@ -2416,244 +2419,245 @@ static void adjust_extattr_refcount(e2fsck_t ctx, ext2_refcount_t refcount,
 /*
  * Handle processing the extended attribute blocks
  */
 static int check_ext_attr(e2fsck_t ctx, struct problem_context *pctx,
 			   char *block_buf, struct ea_quota *ea_block_quota)
 {
 	ext2_filsys fs = ctx->fs;
 	ext2_ino_t	ino = pctx->ino;
 	struct ext2_inode *inode = pctx->inode;
 	blk64_t		blk;
 	char *		end;
 	struct ext2_ext_attr_header *header;
 	struct ext2_ext_attr_entry *first, *entry;
 	blk64_t		quota_blocks = EXT2FS_C2B(fs, 1);
 	__u64		quota_inodes = 0;
 	region_t	region = 0;
 	int		failed_csum = 0;
 
 	ea_block_quota->blocks = 0;
 	ea_block_quota->inodes = 0;
 
 	blk = ext2fs_file_acl_block(fs, inode);
 	if (blk == 0)
 		return 0;
 
 	/*
 	 * If the Extended attribute flag isn't set, then a non-zero
 	 * file acl means that the inode is corrupted.
 	 *
 	 * Or if the extended attribute block is an invalid block,
 	 * then the inode is also corrupted.
 	 */
 	if (!ext2fs_has_feature_xattr(fs->super) ||
 	    (blk < fs->super->s_first_data_block) ||
 	    (blk >= ext2fs_blocks_count(fs->super))) {
 		mark_inode_bad(ctx, ino);
 		return 0;
 	}
 
 	/* If ea bitmap hasn't been allocated, create it */
 	if (!ctx->block_ea_map) {
 		pctx->errcode = e2fsck_allocate_block_bitmap(fs,
 					_("ext attr block map"),
 					EXT2FS_BMAP64_RBTREE, "block_ea_map",
 					&ctx->block_ea_map);
 		if (pctx->errcode) {
 			pctx->num = 2;
 			fix_problem(ctx, PR_1_ALLOCATE_BBITMAP_ERROR, pctx);
 			ctx->flags |= E2F_FLAG_ABORT;
 			return 0;
 		}
 	}
 
 	/* Create the EA refcount structure if necessary */
 	if (!ctx->refcount) {
 		pctx->errcode = ea_refcount_create(0, &ctx->refcount);
 		if (pctx->errcode) {
 			pctx->num = 1;
 			fix_problem(ctx, PR_1_ALLOCATE_REFCOUNT, pctx);
 			ctx->flags |= E2F_FLAG_ABORT;
 			return 0;
 		}
 	}
 
 #if 0
 	/* Debugging text */
 	printf("Inode %u has EA block %u\n", ino, blk);
 #endif
 
 	/* Have we seen this EA block before? */
 	if (ext2fs_fast_test_block_bitmap2(ctx->block_ea_map, blk)) {
 		ea_block_quota->blocks = EXT2FS_C2B(fs, 1);
 		ea_block_quota->inodes = 0;
 
 		if (ctx->ea_block_quota_blocks) {
 			ea_refcount_fetch(ctx->ea_block_quota_blocks, blk,
 					  &quota_blocks);
 			if (quota_blocks)
 				ea_block_quota->blocks = quota_blocks;
 		}
 
 		if (ctx->ea_block_quota_inodes)
 			ea_refcount_fetch(ctx->ea_block_quota_inodes, blk,
 					  &ea_block_quota->inodes);
 
 		if (ea_refcount_decrement(ctx->refcount, blk, 0) == 0)
 			return 1;
 		/* Ooops, this EA was referenced more than it stated */
 		if (!ctx->refcount_extra) {
 			pctx->errcode = ea_refcount_create(0,
 					   &ctx->refcount_extra);
 			if (pctx->errcode) {
 				pctx->num = 2;
 				fix_problem(ctx, PR_1_ALLOCATE_REFCOUNT, pctx);
 				ctx->flags |= E2F_FLAG_ABORT;
 				return 0;
 			}
 		}
 		ea_refcount_increment(ctx->refcount_extra, blk, 0);
 		return 1;
 	}
 
 	/*
 	 * OK, we haven't seen this EA block yet.  So we need to
 	 * validate it
 	 */
 	pctx->blk = blk;
 	pctx->errcode = ext2fs_read_ext_attr3(fs, blk, block_buf, pctx->ino);
 	if (pctx->errcode == EXT2_ET_EXT_ATTR_CSUM_INVALID) {
 		pctx->errcode = 0;
 		failed_csum = 1;
 	} else if (pctx->errcode == EXT2_ET_BAD_EA_HEADER)
 		pctx->errcode = 0;
 
 	if (pctx->errcode &&
 	    fix_problem(ctx, PR_1_READ_EA_BLOCK, pctx)) {
 		pctx->errcode = 0;
 		goto clear_extattr;
 	}
 	header = (struct ext2_ext_attr_header *) block_buf;
 	pctx->blk = ext2fs_file_acl_block(fs, inode);
 	if (((ctx->ext_attr_ver == 1) &&
 	     (header->h_magic != EXT2_EXT_ATTR_MAGIC_v1)) ||
 	    ((ctx->ext_attr_ver == 2) &&
 	     (header->h_magic != EXT2_EXT_ATTR_MAGIC))) {
 		if (fix_problem(ctx, PR_1_BAD_EA_BLOCK, pctx))
 			goto clear_extattr;
 	}
 
 	if (header->h_blocks != 1) {
 		if (fix_problem(ctx, PR_1_EA_MULTI_BLOCK, pctx))
 			goto clear_extattr;
 	}
 
 	if (pctx->errcode && fix_problem(ctx, PR_1_READ_EA_BLOCK, pctx))
 		goto clear_extattr;
 
 	region = region_create(0, fs->blocksize);
 	if (!region) {
 		fix_problem(ctx, PR_1_EA_ALLOC_REGION_ABORT, pctx);
 		ctx->flags |= E2F_FLAG_ABORT;
 		return 0;
 	}
 	if (region_allocate(region, 0, sizeof(struct ext2_ext_attr_header))) {
 		if (fix_problem(ctx, PR_1_EA_ALLOC_COLLISION, pctx))
 			goto clear_extattr;
 	}
 
 	first = (struct ext2_ext_attr_entry *)(header+1);
 	end = block_buf + fs->blocksize;
 	entry = first;
 	while ((char *)entry < end && *(__u32 *)entry) {
 		__u32 hash;
 
 		if (region_allocate(region, (char *)entry - (char *)header,
 			           EXT2_EXT_ATTR_LEN(entry->e_name_len))) {
 			if (fix_problem(ctx, PR_1_EA_ALLOC_COLLISION, pctx))
 				goto clear_extattr;
 			break;
 		}
 		if ((ctx->ext_attr_ver == 1 &&
 		     (entry->e_name_len == 0 || entry->e_name_index != 0)) ||
 		    (ctx->ext_attr_ver == 2 &&
 		     entry->e_name_index == 0)) {
 			if (fix_problem(ctx, PR_1_EA_BAD_NAME, pctx))
 				goto clear_extattr;
 			break;
 		}
 		if (entry->e_value_inum == 0) {
-			if (entry->e_value_offs + entry->e_value_size >
-			    fs->blocksize) {
+			if (entry->e_value_size > EXT2_XATTR_SIZE_MAX ||
+			    (entry->e_value_offs + entry->e_value_size >
+			     fs->blocksize)) {
 				if (fix_problem(ctx, PR_1_EA_BAD_VALUE, pctx))
 					goto clear_extattr;
 				break;
 			}
 			if (entry->e_value_size &&
 			    region_allocate(region, entry->e_value_offs,
 					    EXT2_EXT_ATTR_SIZE(entry->e_value_size))) {
 				if (fix_problem(ctx, PR_1_EA_ALLOC_COLLISION,
 						pctx))
 					goto clear_extattr;
 			}
 
 			hash = ext2fs_ext_attr_hash_entry(entry, block_buf +
 							  entry->e_value_offs);
 
 			if (entry->e_hash != hash) {
 				pctx->num = entry->e_hash;
 				if (fix_problem(ctx, PR_1_ATTR_HASH, pctx))
 					goto clear_extattr;
 				entry->e_hash = hash;
 			}
 		} else {
 			problem_t problem;
 			blk64_t entry_quota_blocks;
 
 			problem = check_large_ea_inode(ctx, entry, pctx,
 						       &entry_quota_blocks);
 			if (problem && fix_problem(ctx, problem, pctx))
 				goto clear_extattr;
 
 			quota_blocks += entry_quota_blocks;
 			quota_inodes++;
 		}
 
 		entry = EXT2_EXT_ATTR_NEXT(entry);
 	}
 	if (region_allocate(region, (char *)entry - (char *)header, 4)) {
 		if (fix_problem(ctx, PR_1_EA_ALLOC_COLLISION, pctx))
 			goto clear_extattr;
 	}
 	region_free(region);
 
 	/*
 	 * We only get here if there was no other errors that were fixed.
 	 * If there was a checksum fail, ask to correct it.
 	 */
 	if (failed_csum &&
 	    fix_problem(ctx, PR_1_EA_BLOCK_ONLY_CSUM_INVALID, pctx)) {
 		pctx->errcode = ext2fs_write_ext_attr3(fs, blk, block_buf,
 						       pctx->ino);
 		if (pctx->errcode)
 			return 0;
 	}
 
 	if (quota_blocks != EXT2FS_C2B(fs, 1U)) {
 		if (!ctx->ea_block_quota_blocks) {
 			pctx->errcode = ea_refcount_create(0,
 						&ctx->ea_block_quota_blocks);
 			if (pctx->errcode) {
 				pctx->num = 3;
 				goto refcount_fail;
 			}
 		}
 		ea_refcount_store(ctx->ea_block_quota_blocks, blk,
 				  quota_blocks);
 	}
 
 	if (quota_inodes) {
 		if (!ctx->ea_block_quota_inodes) {
 			pctx->errcode = ea_refcount_create(0,
 						&ctx->ea_block_quota_inodes);
 			if (pctx->errcode) {
 				pctx->num = 4;
@@ -2848,121 +2852,122 @@ static int has_unaligned_cluster_map(e2fsck_t ctx,
 static void scan_extent_node(e2fsck_t ctx, struct problem_context *pctx,
 			     struct process_block_struct *pb,
 			     blk64_t start_block, blk64_t end_block,
 			     blk64_t eof_block,
 			     ext2_extent_handle_t ehandle,
 			     int try_repairs)
 {
 	struct ext2fs_extent	extent;
 	blk64_t			blk, last_lblk;
 	unsigned int		i, n;
 	int			is_dir, is_leaf;
 	problem_t		problem;
 	struct ext2_extent_info	info;
 	int			failed_csum = 0;
 
 	if (pctx->errcode == EXT2_ET_EXTENT_CSUM_INVALID)
 		failed_csum = 1;
 
 	pctx->errcode = ext2fs_extent_get_info(ehandle, &info);
 	if (pctx->errcode)
 		return;
 	if (!(ctx->options & E2F_OPT_FIXES_ONLY) &&
-	    !pb->eti.force_rebuild) {
+	    !pb->eti.force_rebuild &&
+	    info.curr_level < MAX_EXTENT_DEPTH_COUNT) {
 		struct extent_tree_level *etl;
 
 		etl = pb->eti.ext_info + info.curr_level;
 		etl->num_extents += info.num_entries;
 		etl->max_extents += info.max_entries;
 		/*
 		 * Implementation wart: Splitting extent blocks when appending
 		 * will leave the old block with one free entry.  Therefore
 		 * unless the node is totally full, pretend that a non-root
 		 * extent block can hold one fewer entry than it actually does,
 		 * so that we don't repeatedly rebuild the extent tree.
 		 */
 		if (info.curr_level && info.num_entries < info.max_entries)
 			etl->max_extents--;
 	}
 
 	pctx->errcode = ext2fs_extent_get(ehandle, EXT2_EXTENT_FIRST_SIB,
 					  &extent);
 	while ((pctx->errcode == 0 ||
 		pctx->errcode == EXT2_ET_EXTENT_CSUM_INVALID) &&
 	       info.num_entries-- > 0) {
 		is_leaf = extent.e_flags & EXT2_EXTENT_FLAGS_LEAF;
 		is_dir = LINUX_S_ISDIR(pctx->inode->i_mode);
 		last_lblk = extent.e_lblk + extent.e_len - 1;
 
 		problem = 0;
 		pctx->blk = extent.e_pblk;
 		pctx->blk2 = extent.e_lblk;
 		pctx->num = extent.e_len;
 		pctx->blkcount = extent.e_lblk + extent.e_len;
 
 		if (extent.e_pblk == 0 ||
 		    extent.e_pblk < ctx->fs->super->s_first_data_block ||
 		    extent.e_pblk >= ext2fs_blocks_count(ctx->fs->super))
 			problem = PR_1_EXTENT_BAD_START_BLK;
 		else if (extent.e_lblk < start_block)
 			problem = PR_1_OUT_OF_ORDER_EXTENTS;
 		else if ((end_block && last_lblk > end_block) &&
 			 !(last_lblk > eof_block &&
 			   ((extent.e_flags & EXT2_EXTENT_FLAGS_UNINIT) ||
 			    (pctx->inode->i_flags & EXT4_VERITY_FL))))
 			problem = PR_1_EXTENT_END_OUT_OF_BOUNDS;
 		else if (is_leaf && extent.e_len == 0)
 			problem = PR_1_EXTENT_LENGTH_ZERO;
 		else if (is_leaf &&
 			 (extent.e_pblk + extent.e_len) >
 			 ext2fs_blocks_count(ctx->fs->super))
 			problem = PR_1_EXTENT_ENDS_BEYOND;
 		else if (is_leaf && is_dir && !pctx->inode->i_size_high &&
 			 !ext2fs_has_feature_largedir(ctx->fs->super) &&
 			 ((extent.e_lblk + extent.e_len) >
 			  (1U << (21 - ctx->fs->super->s_log_block_size))))
 			problem = PR_1_TOOBIG_DIR;
 
 		if (is_leaf && problem == 0 && extent.e_len > 0) {
 #if 0
 			printf("extent_region(ino=%u, expect=%llu, "
 			       "lblk=%llu, len=%u)\n", pb->ino,
 			       (unsigned long long) pb->next_lblock,
 			       (unsigned long long) extent.e_lblk,
 			       extent.e_len);
 #endif
 			if (extent.e_lblk < pb->next_lblock)
 				problem = PR_1_EXTENT_COLLISION;
 			else if (extent.e_lblk + extent.e_len > pb->next_lblock)
 				pb->next_lblock = extent.e_lblk + extent.e_len;
 		}
 
 		/*
 		 * Uninitialized blocks in a directory?  Clear the flag and
 		 * we'll interpret the blocks later.
 		 */
 		if (try_repairs && is_dir && problem == 0 &&
 		    (extent.e_flags & EXT2_EXTENT_FLAGS_UNINIT) &&
 		    fix_problem(ctx, PR_1_UNINIT_DBLOCK, pctx)) {
 			extent.e_flags &= ~EXT2_EXTENT_FLAGS_UNINIT;
 			pb->inode_modified = 1;
 			pctx->errcode = ext2fs_extent_replace(ehandle, 0,
 							      &extent);
 			if (pctx->errcode)
 				return;
 			failed_csum = 0;
 		}
 #ifdef CONFIG_DEVELOPER_FEATURES
 		if (try_repairs && !is_dir && problem == 0 &&
 		    (ctx->options & E2F_OPT_CLEAR_UNINIT) &&
 		    (extent.e_flags & EXT2_EXTENT_FLAGS_UNINIT) &&
 		    fix_problem(ctx, PR_1_CLEAR_UNINIT_EXTENT, pctx)) {
 			extent.e_flags &= ~EXT2_EXTENT_FLAGS_UNINIT;
 			pb->inode_modified = 1;
 			pctx->errcode = ext2fs_extent_replace(ehandle, 0,
 							      &extent);
 			if (pctx->errcode)
 				return;
 			failed_csum = 0;
 		}
 #endif
 		if (try_repairs && problem) {
diff --git a/e2fsck/pass3.c b/e2fsck/pass3.c
index cedaaf5a..d6b8c8b4 100644
--- a/e2fsck/pass3.c
+++ b/e2fsck/pass3.c
@@ -1,43 +1,43 @@
 /*
  * pass3.c -- pass #3 of e2fsck: Check for directory connectivity
  *
  * Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999 Theodore Ts'o.
  *
  * %Begin-Header%
  * This file may be redistributed under the terms of the GNU Public
  * License.
  * %End-Header%
  *
  * Pass #3 assures that all directories are connected to the
  * filesystem tree, using the following algorithm:
  *
  * First, the root directory is checked to make sure it exists; if
  * not, e2fsck will offer to create a new one.  It is then marked as
  * "done".
  *
  * Then, pass3 iterates over all directory inodes; for each directory
  * it attempts to trace up the filesystem tree, using dirinfo.parent
  * until it reaches a directory which has been marked "done".  If it
  * can not do so, then the directory must be disconnected, and e2fsck
  * will offer to reconnect it to /lost+found.  While it is chasing
  * parent pointers up the filesystem tree, if pass3 sees a directory
  * twice, then it has detected a filesystem loop, and it will again
- * offer to reconnect the directory to /lost+found in to break the
+ * offer to reconnect the directory to /lost+found in order to break the
  * filesystem loop.
  *
  * Pass 3 also contains the subroutine, e2fsck_reconnect_file() to
  * reconnect inodes to /lost+found; this subroutine is also used by
  * pass 4.  e2fsck_reconnect_file() calls get_lost_and_found(), which
  * is responsible for creating /lost+found if it does not exist.
  *
  * Pass 3 frees the following data structures:
  *     	- The dirinfo directory information cache.
  */
 
 #include "config.h"
 #ifdef HAVE_ERRNO_H
 #include <errno.h>
 #endif
 
 #include "e2fsck.h"
 #include "problem.h"
@@ -273,111 +273,116 @@ skip_new_block:
 /*
  * This subroutine is responsible for making sure that a particular
  * directory is connected to the root; if it isn't we trace it up as
  * far as we can go, and then offer to connect the resulting parent to
  * the lost+found.  We have to do loop detection; if we ever discover
  * a loop, we treat that as a disconnected directory and offer to
  * reparent it to lost+found.
  *
  * However, loop detection is expensive, because for very large
  * filesystems, the inode_loop_detect bitmap is huge, and clearing it
  * is non-trivial.  Loops in filesystems are also a rare error case,
  * and we shouldn't optimize for error cases.  So we try two passes of
  * the algorithm.  The first time, we ignore loop detection and merely
  * increment a counter; if the counter exceeds some extreme threshold,
  * then we try again with the loop detection bitmap enabled.
  */
 static int check_directory(e2fsck_t ctx, ext2_ino_t dir,
 			   struct problem_context *pctx)
 {
 	ext2_filsys 	fs = ctx->fs;
 	ext2_ino_t	ino = dir, parent;
 	int		loop_pass = 0, parent_count = 0;
 
 	while (1) {
 		/*
 		 * Mark this inode as being "done"; by the time we
 		 * return from this function, the inode we either be
 		 * verified as being connected to the directory tree,
 		 * or we will have offered to reconnect this to
 		 * lost+found.
 		 *
 		 * If it was marked done already, then we've reached a
 		 * parent we've already checked.
 		 */
-	  	if (ext2fs_mark_inode_bitmap2(inode_done_map, ino))
+		if (ext2fs_mark_inode_bitmap2(inode_done_map, ino))
 			break;
 
 		if (e2fsck_dir_info_get_parent(ctx, ino, &parent)) {
 			fix_problem(ctx, PR_3_NO_DIRINFO, pctx);
 			return 0;
 		}
 
 		/*
 		 * If this directory doesn't have a parent, or we've
 		 * seen the parent once already, then offer to
 		 * reparent it to lost+found
 		 */
 		if (!parent ||
 		    (loop_pass &&
-		     (ext2fs_test_inode_bitmap2(inode_loop_detect,
-					       parent)))) {
+		     ext2fs_test_inode_bitmap2(inode_loop_detect, parent))) {
 			pctx->ino = ino;
-			if (fix_problem(ctx, PR_3_UNCONNECTED_DIR, pctx)) {
-				if (e2fsck_reconnect_file(ctx, pctx->ino))
+			if (parent)
+				pctx->dir = parent;
+			else
+				ext2fs_lookup(fs, ino, "..", 2, NULL,
+					      &pctx->dir);
+			if (fix_problem(ctx, !parent ? PR_3_UNCONNECTED_DIR :
+						       PR_3_LOOPED_DIR, pctx)) {
+				if (e2fsck_reconnect_file(ctx, pctx->ino)) {
 					ext2fs_unmark_valid(fs);
-				else {
+				} else {
 					fix_dotdot(ctx, pctx->ino,
 						   ctx->lost_and_found);
 					parent = ctx->lost_and_found;
 				}
 			}
 			break;
 		}
 		ino = parent;
 		if (loop_pass) {
 			ext2fs_mark_inode_bitmap2(inode_loop_detect, ino);
 		} else if (parent_count++ > 2048) {
 			/*
 			 * If we've run into a path depth that's
 			 * greater than 2048, try again with the inode
 			 * loop bitmap turned on and start from the
 			 * top.
 			 */
 			loop_pass = 1;
 			if (inode_loop_detect)
 				ext2fs_clear_inode_bitmap(inode_loop_detect);
 			else {
 				pctx->errcode = e2fsck_allocate_inode_bitmap(fs, _("inode loop detection bitmap"), EXT2FS_BMAP64_AUTODIR, "inode_loop_detect", &inode_loop_detect);
 				if (pctx->errcode) {
 					pctx->num = 1;
 					fix_problem(ctx,
 				    PR_3_ALLOCATE_IBITMAP_ERROR, pctx);
 					ctx->flags |= E2F_FLAG_ABORT;
 					return -1;
 				}
 			}
 			ino = dir;
 		}
 	}
 
 	/*
 	 * Make sure that .. and the parent directory are the same;
 	 * offer to fix it if not.
 	 */
 	pctx->ino = dir;
 	if (e2fsck_dir_info_get_dotdot(ctx, dir, &pctx->ino2) ||
 	    e2fsck_dir_info_get_parent(ctx, dir, &pctx->dir)) {
 		fix_problem(ctx, PR_3_NO_DIRINFO, pctx);
 		return 0;
 	}
 	if (pctx->ino2 != pctx->dir) {
 		if (fix_problem(ctx, PR_3_BAD_DOT_DOT, pctx))
 			fix_dotdot(ctx, dir, pctx->dir);
 	}
 	return 0;
 }
 
 /*
  * This routine gets the lost_and_found inode, making it a directory
  * if necessary
  */
diff --git a/e2fsck/problem.c b/e2fsck/problem.c
index f454dcb7..361c1d1a 100644
--- a/e2fsck/problem.c
+++ b/e2fsck/problem.c
@@ -48,34 +48,34 @@
 /*
  * These are the prompts which are used to ask the user if they want
  * to fix a problem.
  */
 static const char *prompt[] = {
-	N_("(no prompt)"),	/* 0 */
-	N_("Fix"),		/* 1 */
-	N_("Clear"),		/* 2 */
-	N_("Relocate"),		/* 3 */
-	N_("Allocate"),		/* 4 */
-	N_("Expand"),		/* 5 */
-	N_("Connect to /lost+found"), /* 6 */
-	N_("Create"),		/* 7 */
-	N_("Salvage"),		/* 8 */
-	N_("Truncate"),		/* 9 */
-	N_("Clear inode"),	/* 10 */
-	N_("Abort"),		/* 11 */
-	N_("Split"),		/* 12 */
-	N_("Continue"),		/* 13 */
-	N_("Clone multiply-claimed blocks"), /* 14 */
-	N_("Delete file"),	/* 15 */
-	N_("Suppress messages"),/* 16 */
-	N_("Unlink"),		/* 17 */
-	N_("Clear HTree index"),/* 18 */
-	N_("Recreate"),		/* 19 */
-	N_("Optimize"),		/* 20 */
-	N_("Clear flag"),	/* 21 */
-	"",			/* 22 */
+	N_("(no prompt)"),			/* PROMPT_NONE		=  0 */
+	N_("Fix"),				/* PROMPT_FIX		=  1 */
+	N_("Clear"),				/* PROMPT_CLEAR		=  2 */
+	N_("Relocate"),				/* PROMPT_RELOCATE	=  3 */
+	N_("Allocate"),				/* PROMPT_CREATE	=  4 */
+	N_("Expand"),				/* PROMPT_EXPAND	=  5 */
+	N_("Connect to /lost+found"),		/* PROMPT_CONNECT	=  6 */
+	N_("Create"),				/* PROMPT_CREATE	=  7 */
+	N_("Salvage"),				/* PROMPT_SALVAGE	=  8 */
+	N_("Truncate"),				/* PROMPT_TRUNCATE	=  9 */
+	N_("Clear inode"),			/* PROMPT_CLEAR_INODE	= 10 */
+	N_("Abort"),				/* PROMPT_ABORT		= 11 */
+	N_("Split"),				/* PROMPT_SPLIT		= 12 */
+	N_("Continue"),				/* PROMPT_CONTINUE	= 13 */
+	N_("Clone multiply-claimed blocks"),	/* PROMPT_CLONE		= 14 */
+	N_("Delete file"),			/* PROMPT_DELETE	= 15 */
+	N_("Suppress messages"),		/* PROMPT_SUPPRESS	= 16 */
+	N_("Unlink"),				/* PROMPT_UNLINK	= 17 */
+	N_("Clear HTree index"),		/* PROMPT_CLEAR_HTREE	= 18 */
+	N_("Recreate"),				/* PROMPT_RECREATE	= 19 */
+	N_("Optimize"),				/* PROMPT_OPTIMIZE	= 20 */
+	N_("Clear flag"),			/* PROMPT_CLEAR_FLAG	= 21 */
+	"",					/* PROMPT_NULL		= 22 */
 };
 
 /*
  * These messages are printed when we are preen mode and we will be
  * automatically fixing the problem.
  */
@@ -113,2237 +113,2243 @@ static const char *preen_msg[] = {
 static struct e2fsck_problem problem_table[] = {
 
 	/* Pre-Pass 1 errors */
 
 	/* Block bitmap for group is not in group */
 	{ PR_0_BB_NOT_GROUP, N_("@b @B for @g %g is not in @g.  (@b %b)\n"),
 	  PROMPT_RELOCATE, PR_LATCH_RELOC, 0, 0, 0 },
 
 	/* Inode bitmap for group is not in group */
 	{ PR_0_IB_NOT_GROUP, N_("@i @B for @g %g is not in @g.  (@b %b)\n"),
 	  PROMPT_RELOCATE, PR_LATCH_RELOC, 0, 0, 0 },
 
 	/* Inode table for group is not in group.  (block nnnn) */
 	{ PR_0_ITABLE_NOT_GROUP,
 	  N_("@i table for @g %g is not in @g.  (@b %b)\n"
 	  "WARNING: SEVERE DATA LOSS POSSIBLE.\n"),
 	  PROMPT_RELOCATE, PR_LATCH_RELOC, 0, 0, 0 },
 
 	/* Superblock corrupt */
 	{ PR_0_SB_CORRUPT,
 	  N_("\nThe @S could not be read or does not describe a valid ext2/ext3/ext4\n"
 	  "@f.  If the @v is valid and it really contains an ext2/ext3/ext4\n"
 	  "@f (and not swap or ufs or something else), then the @S\n"
 	  "is corrupt, and you might try running e2fsck with an alternate @S:\n"
 	  "    e2fsck -b 8193 <@v>\n"
 	  " or\n"
 	  "    e2fsck -b 32768 <@v>\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Filesystem size is wrong */
 	{ PR_0_FS_SIZE_WRONG,
 	  N_("The @f size (according to the @S) is %b @bs\n"
 	  "The physical size of the @v is %c @bs\n"
 	  "Either the @S or the partition table is likely to be corrupt!\n"),
 	  PROMPT_ABORT, 0, 0, 0, 0 },
 
 	/* Fragments not supported */
 	{ PR_0_NO_FRAGMENTS,
 	  N_("@S @b_size = %b, fragsize = %c.\n"
 	  "This version of e2fsck does not support fragment sizes different\n"
 	  "from the @b size.\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Superblock blocks_per_group = bbbb, should have been cccc */
 	{ PR_0_BLOCKS_PER_GROUP,
 	  N_("@S @bs_per_group = %b, should have been %c\n"),
 	  PROMPT_NONE, PR_AFTER_CODE, PR_0_SB_CORRUPT, 0, 0 },
 
 	/* Superblock first_data_block = bbbb, should have been cccc */
 	{ PR_0_FIRST_DATA_BLOCK,
 	  N_("@S first_data_@b = %b, should have been %c\n"),
 	  PROMPT_NONE, PR_AFTER_CODE, PR_0_SB_CORRUPT, 0, 0 },
 
 	/* Filesystem did not have a UUID; generating one */
 	{ PR_0_ADD_UUID,
 	  N_("@f did not have a UUID; generating one.\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Relocate hint */
 	{ PR_0_RELOCATE_HINT,
 	  /* xgettext:no-c-format */
 	  N_("Note: if several inode or block bitmap blocks or part\n"
 	  "of the inode table require relocation, you may wish to try\n"
 	  "running e2fsck with the '-b %S' option first.  The problem\n"
 	  "may lie only with the primary block group descriptors, and\n"
 	  "the backup block group descriptors may be OK.\n\n"),
 	  PROMPT_NONE, PR_PREEN_OK | PR_NOCOLLATE, 0, 0, 0 },
 
 	/* Miscellaneous superblock corruption */
 	{ PR_0_MISC_CORRUPT_SUPER,
 	  N_("Corruption found in @S.  (%s = %N).\n"),
 	  PROMPT_NONE, PR_AFTER_CODE, PR_0_SB_CORRUPT, 0, 0 },
 
 	/* Error determining physical device size of filesystem */
 	{ PR_0_GETSIZE_ERROR,
 	  /* xgettext:no-c-format */
 	  N_("Error determining size of the physical @v: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Inode count in superblock is incorrect */
 	{ PR_0_INODE_COUNT_WRONG,
 	  N_("@i count in @S is %i, @s %j.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	{ PR_0_HURD_CLEAR_FILETYPE,
 	  N_("The Hurd does not support the filetype feature.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Superblock has an invalid journal (inode inum) */
 	{ PR_0_JOURNAL_BAD_INODE,
 	  /* xgettext:no-c-format */
 	  N_("@S has an @n @j (@i %i).\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* External journal has multiple filesystem users (unsupported) */
 	{ PR_0_JOURNAL_UNSUPP_MULTIFS,
 	  N_("External @j has multiple @f users (unsupported).\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Can't find external journal */
 	{ PR_0_CANT_FIND_JOURNAL,
 	  N_("Can't find external @j\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* External journal has bad superblock */
 	{ PR_0_EXT_JOURNAL_BAD_SUPER,
 	  N_("External @j has bad @S\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Superblock has a bad journal UUID */
 	{ PR_0_JOURNAL_BAD_UUID,
 	  N_("External @j does not support this @f\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Filesystem journal superblock is an unknown type */
 	{ PR_0_JOURNAL_UNSUPP_SUPER,
 	  N_("@f @j @S is unknown type %N (unsupported).\n"
 	     "It is likely that your copy of e2fsck is old and/or doesn't "
 	     "support this @j format.\n"
 	     "It is also possible the @j @S is corrupt.\n"),
 	  PROMPT_ABORT, PR_NO_OK | PR_AFTER_CODE, PR_0_JOURNAL_BAD_SUPER,
 	  0, 0 },
 
 	/* Journal superblock is corrupt */
 	{ PR_0_JOURNAL_BAD_SUPER,
 	  N_("@j @S is corrupt.\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Superblock has_journal flag is clear but has a journal */
 	{ PR_0_JOURNAL_HAS_JOURNAL,
 	  N_("@S has_@j flag is clear, but a @j is present.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Superblock needs_recovery flag is set but no journal is present */
 	{ PR_0_JOURNAL_RECOVER_SET,
 	  N_("@S needs_recovery flag is set, but no @j is present.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Superblock needs_recovery flag is set, but journal has data */
 	{ PR_0_JOURNAL_RECOVERY_CLEAR,
 	  N_("@S needs_recovery flag is clear, but @j has data.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Ask if we should clear the journal */
 	{ PR_0_JOURNAL_RESET_JOURNAL,
 	  N_("Clear @j"),
 	  PROMPT_NULL, PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Filesystem revision is 0, but feature flags are set */
 	{ PR_0_FS_REV_LEVEL,
 	  N_("@f has feature flag(s) set, but is a revision 0 @f.  "),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Clearing orphan inode */
 	{ PR_0_ORPHAN_CLEAR_INODE,
 	  N_("%s @o @i %i (uid=%Iu, gid=%Ig, mode=%Im, size=%Is)\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Illegal block found in orphaned inode */
 	{ PR_0_ORPHAN_ILLEGAL_BLOCK_NUM,
 	   N_("@I %B (%b) found in @o @i %i.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Already cleared block found in orphaned inode */
 	{ PR_0_ORPHAN_ALREADY_CLEARED_BLOCK,
 	   N_("Already cleared %B (%b) found in @o @i %i.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Illegal orphan inode in superblock */
 	{ PR_0_ORPHAN_ILLEGAL_HEAD_INODE,
 	  /* xgettext:no-c-format */
 	  N_("@I @o @i %i in @S.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Illegal inode in orphaned inode list */
 	{ PR_0_ORPHAN_ILLEGAL_INODE,
 	  /* xgettext:no-c-format */
 	  N_("@I @i %i in @o @i list.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Journal superblock has an unknown read-only feature flag set */
 	{ PR_0_JOURNAL_UNSUPP_ROCOMPAT,
 	  N_("@j @S has an unknown read-only feature flag set.\n"),
 	  PROMPT_ABORT, 0, 0, 0, 0 },
 
 	/* Journal superblock has an unknown incompatible feature flag set */
 	{ PR_0_JOURNAL_UNSUPP_INCOMPAT,
 	  N_("@j @S has an unknown incompatible feature flag set.\n"),
 	  PROMPT_ABORT, 0, 0, 0, 0 },
 
 	/* Journal version not supported by this e2fsck */
 	{ PR_0_JOURNAL_UNSUPP_VERSION,
 	  N_("@j version not supported by this e2fsck.\n"),
 	  PROMPT_ABORT, 0, 0, 0, 0 },
 
 	/* Moving journal from /file to hidden inode */
 	{ PR_0_MOVE_JOURNAL,
 	  /* xgettext:no-c-format */
 	  N_("Moving @j from /%s to hidden @i.\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error moving journal to hidden file */
 	{ PR_0_ERR_MOVE_JOURNAL,
 	  /* xgettext:no-c-format */
 	  N_("Error moving @j: %m\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Found invalid V2 journal superblock fields */
 	{ PR_0_CLEAR_V2_JOURNAL,
 	  N_("Found @n V2 @j @S fields (from V1 @j).\n"
 	     "Clearing fields beyond the V1 @j @S...\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Ask if we should run the journal anyway */
 	{ PR_0_JOURNAL_RUN,
 	  N_("Run @j anyway"),
 	  PROMPT_NULL, 0, 0, 0, 0 },
 
 	/* Run the journal by default */
 	{ PR_0_JOURNAL_RUN_DEFAULT,
 	  N_("Recovery flag not set in backup @S, so running @j anyway.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Backing up journal inode block information */
 	{ PR_0_BACKUP_JNL,
 	  N_("Backing up @j @i @b information.\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Filesystem does not have resize_inode enabled, but
 	 * s_reserved_gdt_blocks is nnnn; should be zero */
 	{ PR_0_NONZERO_RESERVED_GDT_BLOCKS,
 	  N_("@f does not have resize_@i enabled, but s_reserved_gdt_@bs\n"
 	     "is %N; @s zero.  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Resize_inode not enabled, but the resize inode is non-zero */
 	{ PR_0_CLEAR_RESIZE_INODE,
 	  N_("Resize_@i not enabled, but the resize @i is non-zero.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Resize inode not valid */
 	{ PR_0_RESIZE_INODE_INVALID,
 	  N_("Resize @i not valid.  "),
 	  PROMPT_RECREATE, 0, 0, 0, 0 },
 
 	/* Superblock last mount time is in the future */
 	{ PR_0_FUTURE_SB_LAST_MOUNT,
 	  N_("@S last mount time (%t,\n\tnow = %T) is in the future.\n"),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Superblock last write time is in the future */
 	{ PR_0_FUTURE_SB_LAST_WRITE,
 	  N_("@S last write time (%t,\n\tnow = %T) is in the future.\n"),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Superblock hint for external superblock should be xxxx */
 	{ PR_0_EXTERNAL_JOURNAL_HINT,
 	  /* xgettext:no-c-format */
 	  N_("@S hint for external superblock @s %X.  "),
 	     PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Adding dirhash hint to filesystem */
 	{ PR_0_DIRHASH_HINT,
 	  N_("Adding dirhash hint to @f.\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* group descriptor N checksum is invalid, should be yyyy. */
 	{ PR_0_GDT_CSUM,
 	  N_("@g descriptor %g checksum is %04x, should be %04y.  "),
 	     PROMPT_FIX, PR_PREEN_OK | PR_LATCH_BG_CHECKSUM, 0, 0, 0 },
 
 	/* group descriptor N marked uninitialized without feature set. */
 	{ PR_0_GDT_UNINIT,
 	  /* xgettext:no-c-format */
 	  N_("@g descriptor %g marked uninitialized without feature set.\n"),
 	     PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Group descriptor N has invalid unused inodes count. */
 	{ PR_0_GDT_ITABLE_UNUSED,
 	  N_("@g descriptor %g has invalid unused inodes count %b.  "),
 	     PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Last group block bitmap uninitialized. */
 	{ PR_0_BB_UNINIT_LAST,
 	  N_("Last @g @b @B uninitialized.  "),
 	     PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Journal transaction was corrupt, replay was aborted */
 	{ PR_0_JNL_TXN_CORRUPT,
 	  /* xgettext:no-c-format */
 	  N_("Journal transaction %i was corrupt, replay was aborted.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* The test_fs filesystem flag is set (and ext4 is available) */
 	{ PR_0_CLEAR_TESTFS_FLAG,
 	  N_("The test_fs flag is set (and ext4 is available).  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Last mount time is in the future (fudged) */
 	{ PR_0_FUTURE_SB_LAST_MOUNT_FUDGED,
 	  N_("@S last mount time is in the future.\n\t(by less than a day, "
 	     "probably due to the hardware clock being incorrectly set)\n"),
 	  PROMPT_NONE, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Last write time is in the future (fudged) */
 	{ PR_0_FUTURE_SB_LAST_WRITE_FUDGED,
 	  N_("@S last write time is in the future.\n\t(by less than a day, "
 	     "probably due to the hardware clock being incorrectly set)\n"),
 	  PROMPT_NONE, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* One or more block group descriptor checksums are invalid (latch) */
 	{ PR_0_GDT_CSUM_LATCH,
 	  N_("One or more @b @g descriptor checksums are invalid.  "),
 	     PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Setting free inodes count to right (was wrong) */
 	{ PR_0_FREE_INODE_COUNT,
 	  N_("Setting free @is count to %j (was %i)\n"),
 	  PROMPT_NONE, PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Setting free blocks count to right (was wrong) */
 	{ PR_0_FREE_BLOCK_COUNT,
 	  N_("Setting free @bs count to %c (was %b)\n"),
 	  PROMPT_NONE, PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Making quota inode hidden */
 	{ PR_0_HIDE_QUOTA,
 	  N_("Hiding %U @q @i %i (%Q).\n"),
 	  PROMPT_NONE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Superblock has invalid MMP block. */
 	{ PR_0_MMP_INVALID_BLK,
 	  N_("@S has invalid MMP block.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Superblock has invalid MMP magic. */
 	{ PR_0_MMP_INVALID_MAGIC,
 	  N_("@S has invalid MMP magic.  "),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Opening file system failed */
 	{ PR_0_OPEN_FAILED,
 	  /* xgettext:no-c-format */
 	  N_("ext2fs_open2: %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Checking group descriptor failed */
 	{ PR_0_CHECK_DESC_FAILED,
 	  /* xgettext:no-c-format */
 	  N_("ext2fs_check_desc: %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Superblock metadata_csum supersedes uninit_bg; both feature
 	 * bits cannot be set simultaneously. */
 	{ PR_0_META_AND_GDT_CSUM_SET,
 	  N_("@S metadata_csum supersedes uninit_bg; both feature "
 	     "bits cannot be set simultaneously."),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Superblock MMP block checksum does not match MMP block. */
 	{ PR_0_MMP_CSUM_INVALID,
 	  N_("@S MMP @b checksum does not match.  "),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Superblock 64bit filesystem needs extents to access the whole disk */
 	{ PR_0_64BIT_WITHOUT_EXTENTS,
 	  N_("@S 64bit @f needs extents to access the whole disk.  "),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* The first_meta_bg is too big */
 	{ PR_0_FIRST_META_BG_TOO_BIG,
 	  N_("First_meta_bg is too big.  (%N, max value %g).  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* External journal superblock checksum does not match superblock */
 	{ PR_0_EXT_JOURNAL_SUPER_CSUM_INVALID,
 	  N_("External @j @S checksum does not match @S.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Superblock metadata_csum_seed means nothing without metadata_csum */
 	{ PR_0_CSUM_SEED_WITHOUT_META_CSUM,
 	  N_("@S metadata_csum_seed is not necessary without metadata_csum."),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Error initializing quota context */
 	{ PR_0_QUOTA_INIT_CTX,
 	  /* xgettext:no-c-format */
 	  N_("Error initializing quota context in support library: %m\n"),
 	  PROMPT_NULL, PR_FATAL, 0, 0, 0 },
 
 	/* Bad required extra isize in superblock */
 	{ PR_0_BAD_MIN_EXTRA_ISIZE,
 	  N_("Bad required extra isize in @S (%N).  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Bad desired extra isize in superblock */
 	{ PR_0_BAD_WANT_EXTRA_ISIZE,
 	  N_("Bad desired extra isize in @S (%N).  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Invalid quota inode number */
 	{ PR_0_INVALID_QUOTA_INO,
 	  N_("Invalid %U @q @i %i.  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Too many inodes in the filesystem */
 	{ PR_0_INODE_COUNT_BIG,
 	  N_("@S would have too many inodes (%N).\n"),
 	  PROMPT_NONE, PR_AFTER_CODE, PR_0_SB_CORRUPT, 0, 0 },
 
 	/* Meta_bg and resize_inode are not compatible, disable resize_inode*/
 	{ PR_0_DISABLE_RESIZE_INODE,
 	  N_("Resize_@i and meta_bg features are enabled. Those features are\n"
 	     "not compatible. Resize @i should be disabled.  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Orphan file contains holes */
 	{ PR_0_ORPHAN_FILE_HOLE,
 	  N_("Orphan file (@i %i) contains hole at @b %b. Terminating orphan file recovery.\n"),
 	  PROMPT_NONE, 0 },
 
 	/* Orphan file block has wrong magic */
 	{ PR_0_ORPHAN_FILE_BAD_MAGIC,
 	  N_("Orphan file (@i %i) @b %b contains wrong magic. Terminating orphan file recovery.\n"),
 	  PROMPT_NONE, 0 },
 
 	/* Orphan file block has wrong checksum */
 	{ PR_0_ORPHAN_FILE_BAD_CHECKSUM,
 	  N_("Orphan file (@i %i) @b %b contains wrong checksum. Terminating orphan file recovery.\n"),
 	  PROMPT_NONE, 0 },
 
 	/* Orphan file size isn't multiple of blocks size */
 	{ PR_0_ORPHAN_FILE_WRONG_SIZE,
 	  N_("Orphan file (@i %i) size is not multiple of block size. Terminating orphan file recovery.\n"),
 	  PROMPT_NONE, 0 },
 
 	/* Pass 1 errors */
 
 	/* Pass 1: Checking inodes, blocks, and sizes */
 	{ PR_1_PASS_HEADER,
 	  N_("Pass 1: Checking @is, @bs, and sizes\n"),
 	  PROMPT_NONE, PR_HEADER, 0, 0, 0 },
 
 	/* Root inode is not a directory */
 	{ PR_1_ROOT_NO_DIR, N_("@r is not a @d.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Root inode has dtime set */
 	{ PR_1_ROOT_DTIME,
 	  N_("@r has dtime set (probably due to old mke2fs).  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Reserved inode has bad mode */
 	{ PR_1_RESERVED_BAD_MODE,
 	  N_("Reserved @i %i (%Q) has @n mode.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Deleted inode inum has zero dtime */
 	{ PR_1_ZERO_DTIME,
 	  /* xgettext:no-c-format */
 	  N_("@D @i %i has zero dtime.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Inode inum is in use, but has dtime set */
 	{ PR_1_SET_DTIME,
 	  /* xgettext:no-c-format */
 	  N_("@i %i is in use, but has dtime set.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Inode inum is a zero-length directory */
 	{ PR_1_ZERO_LENGTH_DIR,
 	  /* xgettext:no-c-format */
 	  N_("@i %i is a @z @d.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Group block bitmap at block conflicts with some other fs block */
 	{ PR_1_BB_CONFLICT,
 	  N_("@g %g's @b @B at %b @C.\n"),
 	  PROMPT_RELOCATE, 0, 0, 0, 0 },
 
 	/* Group inode bitmap at block conflicts with some other fs block */
 	{ PR_1_IB_CONFLICT,
 	  N_("@g %g's @i @B at %b @C.\n"),
 	  PROMPT_RELOCATE, 0, 0, 0, 0 },
 
 	/* Group inode table at block conflicts with some other fs block */
 	{ PR_1_ITABLE_CONFLICT,
 	  N_("@g %g's @i table at %b @C.\n"),
 	  PROMPT_RELOCATE, 0, 0, 0, 0 },
 
 	/* Group block bitmap (block) is bad */
 	{ PR_1_BB_BAD_BLOCK,
 	  N_("@g %g's @b @B (%b) is bad.  "),
 	  PROMPT_RELOCATE, 0, 0, 0, 0 },
 
 	/* Group inode bitmap (block) is bad */
 	{ PR_1_IB_BAD_BLOCK,
 	  N_("@g %g's @i @B (%b) is bad.  "),
 	  PROMPT_RELOCATE, 0, 0, 0, 0 },
 
 	/* Inode inum, i_size is small, should be larger */
 	{ PR_1_BAD_I_SIZE,
 	  N_("@i %i, i_size is %Is, @s %N.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Inode inum, i_blocks is small, should be larger */
 	{ PR_1_BAD_I_BLOCKS,
 	  N_("@i %i, i_@bs is %Ib, @s %N.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Illegal block number in inode */
 	{ PR_1_ILLEGAL_BLOCK_NUM,
 	  N_("@I %B (%b) in @i %i.  "),
 	  PROMPT_CLEAR, PR_LATCH_BLOCK, 0, 0, 0 },
 
 	/* Block number overlaps filesystem metadata in inode */
 	{ PR_1_BLOCK_OVERLAPS_METADATA,
 	  N_("%B (%b) overlaps @f metadata in @i %i.  "),
 	  PROMPT_CLEAR, PR_LATCH_BLOCK, 0, 0, 0 },
 
 	/* Inode has illegal blocks (latch question) */
 	{ PR_1_INODE_BLOCK_LATCH,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has illegal @b(s).  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Too many illegal blocks in inode */
 	{ PR_1_TOO_MANY_BAD_BLOCKS,
 	  /* xgettext:no-c-format */
 	  N_("Too many illegal @bs in @i %i.\n"),
 	  PROMPT_CLEAR_INODE, PR_NO_OK, 0, 0, 0 },
 
 	/* Illegal block number in bad block inode */
 	{ PR_1_BB_ILLEGAL_BLOCK_NUM,
 	  N_("@I %B (%b) in bad @b @i.  "),
 	  PROMPT_CLEAR, PR_LATCH_BBLOCK, 0, 0, 0 },
 
 	/* Bad block inode has illegal blocks (latch question) */
 	{ PR_1_INODE_BBLOCK_LATCH,
 	  N_("Bad @b @i has illegal @b(s).  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Duplicate or bad blocks in use! */
 	{ PR_1_DUP_BLOCKS_PREENSTOP,
 	  N_("Duplicate or bad @b in use!\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Bad block number used as bad block inode indirect block */
 	{ PR_1_BBINODE_BAD_METABLOCK,
 	  N_("Bad @b %b used as bad @b @i indirect @b.  "),
 	  PROMPT_CLEAR, PR_LATCH_BBLOCK, 0, 0, 0 },
 
 	/* Inconsistency can't be fixed prompt */
 	{ PR_1_BBINODE_BAD_METABLOCK_PROMPT,
 	  N_("\nThe bad @b @i has probably been corrupted.  You probably\n"
 	     "should stop now and run ""e2fsck -c"" to scan for bad blocks\n"
 	     "in the @f.\n"),
 	  PROMPT_CONTINUE, PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Bad primary block */
 	{ PR_1_BAD_PRIMARY_BLOCK,
 	  N_("\nIf the @b is really bad, the @f can not be fixed.\n"),
 	  PROMPT_NONE, PR_AFTER_CODE, PR_1_BAD_PRIMARY_BLOCK_PROMPT, 0, 0 },
 
 	/* Bad primary block prompt */
 	{ PR_1_BAD_PRIMARY_BLOCK_PROMPT,
 	  N_("You can remove this @b from the bad @b list and hope\n"
 	     "that the @b is really OK.  But there are no guarantees.\n\n"),
 	  PROMPT_CLEAR, PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* The primary superblock block is on the bad block list */
 	{ PR_1_BAD_PRIMARY_SUPERBLOCK,
 	  N_("The primary @S (%b) is on the bad @b list.\n"),
 	  PROMPT_NONE, PR_AFTER_CODE, PR_1_BAD_PRIMARY_BLOCK, 0, 0 },
 
 	/* Bad primary block group descriptors */
 	{ PR_1_BAD_PRIMARY_GROUP_DESCRIPTOR,
 	  N_("Block %b in the primary @g descriptors "
 	     "is on the bad @b list\n"),
 	  PROMPT_NONE, PR_AFTER_CODE, PR_1_BAD_PRIMARY_BLOCK, 0, 0 },
 
 	/* Warning: Group number's superblock (block) is bad */
 	{ PR_1_BAD_SUPERBLOCK,
 	  N_("Warning: Group %g's @S (%b) is bad.\n"),
 	  PROMPT_NONE, PR_PREEN_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Warning: Group number's copy of the group descriptors has a bad
 	 * block */
 	{ PR_1_BAD_GROUP_DESCRIPTORS,
 	  N_("Warning: Group %g's copy of the @g descriptors has a bad "
 	  "@b (%b).\n"),
 	  PROMPT_NONE, PR_PREEN_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Block number claimed for no reason in process_bad_blocks */
 	{ PR_1_PROGERR_CLAIMED_BLOCK,
 	  N_("Programming error?  @b #%b claimed for no reason in "
 	  "process_bad_@b.\n"),
 	  PROMPT_NONE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Allocating number contiguous block(s) in block group number */
 	{ PR_1_RELOC_BLOCK_ALLOCATE,
 	  N_("@A %N contiguous @b(s) in @b @g %g for %s: %m\n"),
 	  PROMPT_NONE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Allocating block buffer for relocating process */
 	{ PR_1_RELOC_MEMORY_ALLOCATE,
 	  /* xgettext:no-c-format */
 	  N_("@A @b buffer for relocating %s\n"),
 	  PROMPT_NONE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Relocating group number's information from X to Y */
 	{ PR_1_RELOC_FROM_TO,
 	  N_("Relocating @g %g's %s from %b to %c...\n"),
 	  PROMPT_NONE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Relocating group number's information to X */
 	{ PR_1_RELOC_TO,
 	  /* xgettext:no-c-format */
 	  N_("Relocating @g %g's %s to %c...\n"), /* xgettext:no-c-format */
 	  PROMPT_NONE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Warning: could not read block number of relocation process */
 	{ PR_1_RELOC_READ_ERR,
 	  N_("Warning: could not read @b %b of %s: %m\n"),
 	  PROMPT_NONE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Warning: could not write block number of relocation process */
 	{ PR_1_RELOC_WRITE_ERR,
 	  N_("Warning: could not write @b %b for %s: %m\n"),
 	  PROMPT_NONE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Error allocating inode bitmap */
 	{ PR_1_ALLOCATE_IBITMAP_ERROR,
 	  N_("@A @i @B (%N): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error allocating block bitmap */
 	{ PR_1_ALLOCATE_BBITMAP_ERROR,
 	  N_("@A @b @B (%N): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error allocating icount link information */
 	{ PR_1_ALLOCATE_ICOUNT,
 	  /* xgettext:no-c-format */
 	  N_("@A icount link information: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error allocating directory block array */
 	{ PR_1_ALLOCATE_DBCOUNT,
 	  /* xgettext:no-c-format */
 	  N_("@A @d @b array: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error while scanning inodes */
 	{ PR_1_ISCAN_ERROR,
 	  /* xgettext:no-c-format */
 	  N_("Error while scanning @is (%i): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error while iterating over blocks in inode */
 	{ PR_1_BLOCK_ITERATE,
 	  /* xgettext:no-c-format */
 	  N_("Error while iterating over @bs in @i %i: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error storing inode count information */
 	{ PR_1_ICOUNT_STORE,
 	  N_("Error storing @i count information (@i=%i, count=%N): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error storing directory block information */
 	{ PR_1_ADD_DBLOCK,
 	  N_("Error storing @d @b information "
 	  "(@i=%i, @b=%b, num=%N): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error reading inode (for clearing) */
 	{ PR_1_READ_INODE,
 	  /* xgettext:no-c-format */
 	  N_("Error reading @i %i: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Suppress messages prompt */
 	{ PR_1_SUPPRESS_MESSAGES, "", PROMPT_SUPPRESS, PR_NO_OK, 0, 0, 0 },
 
 	/* Imagic number has imagic flag set when fs doesn't support it */
 	{ PR_1_SET_IMAGIC,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has imagic flag set.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Immutable flag set on a device or socket inode */
 	{ PR_1_SET_IMMUTABLE,
 	  /* xgettext:no-c-format */
 	  N_("Special (@v/socket/fifo/symlink) file (@i %i) has immutable\n"
 	     "or append-only flag set.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK | PR_PREEN_NO | PR_NO_OK, 0, 0, 0 },
 
 	/* Non-zero size for device, fifo or socket inode */
 	{ PR_1_SET_NONZSIZE,
 	  /* xgettext:no-c-format */
 	  N_("Special (@v/socket/fifo) @i %i has non-zero size.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Filesystem has feature flag(s) set, but is a revision 0 filesystem */
 	{ PR_1_FS_REV_LEVEL,
 	  N_("@f has feature flag(s) set, but is a revision 0 @f.  "),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Journal inode is not in use, but contains data */
 	{ PR_1_JOURNAL_INODE_NOT_CLEAR,
 	  N_("@j @i is not in use, but contains data.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Journal is not a regular file */
 	{ PR_1_JOURNAL_BAD_MODE,
 	  N_("@j is not regular file.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Inode that was part of the orphan list */
 	{ PR_1_LOW_DTIME,
 	  /* xgettext:no-c-format */
 	  N_("@i %i was part of the @o @i list.  "),
 	  PROMPT_FIX, PR_LATCH_LOW_DTIME, 0, 0, 0 },
 
 	/* Inodes that were part of a corrupted orphan linked list found
 	 * (latch question) */
 	{ PR_1_ORPHAN_LIST_REFUGEES,
 	  N_("@is that were part of a corrupted orphan linked list found.  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Error allocating refcount structure */
 	{ PR_1_ALLOCATE_REFCOUNT,
 	  N_("@A refcount structure (%N): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error reading extended attribute block */
 	{ PR_1_READ_EA_BLOCK,
 	  N_("Error reading @a @b %b for @i %i.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Inode number has a bad extended attribute block */
 	{ PR_1_BAD_EA_BLOCK,
 	  N_("@i %i has a bad @a @b %b.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Error reading Extended Attribute block while fixing refcount */
 	{ PR_1_EXTATTR_READ_ABORT,
 	  N_("Error reading @a @b %b (%m).  "),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Extended attribute number has reference count incorrect */
 	{ PR_1_EXTATTR_REFCOUNT,
 	  N_("@a @b %b has reference count %r, @s %N.  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Error writing Extended Attribute block while fixing refcount */
 	{ PR_1_EXTATTR_WRITE_ABORT,
 	  N_("Error writing @a @b %b (%m).  "),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Extended attribute block has h_blocks > 1 */
 	{ PR_1_EA_MULTI_BLOCK,
 	  N_("@a @b %b has h_@bs > 1.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Allocating extended attribute region allocation structure */
 	{ PR_1_EA_ALLOC_REGION_ABORT,
 	  N_("@A @a region allocation structure.  "),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Extended Attribute block number is corrupt (allocation collision) */
 	{ PR_1_EA_ALLOC_COLLISION,
 	  N_("@a @b %b is corrupt (allocation collision).  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Extended attribute block number is corrupt (invalid name) */
 	{ PR_1_EA_BAD_NAME,
 	  N_("@a @b %b is corrupt (@n name).  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Extended attribute block number is corrupt (invalid value) */
 	{ PR_1_EA_BAD_VALUE,
 	  N_("@a @b %b is corrupt (@n value).  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Inode number is too big (latch question) */
 	{ PR_1_INODE_TOOBIG,
 	  /* xgettext:no-c-format */
 	  N_("@i %i is too big.  "), PROMPT_TRUNCATE, 0, 0, 0, 0 },
 
 	/* Problem causes directory to be too big */
 	{ PR_1_TOOBIG_DIR,
 	  N_("%B (%b) causes @d to be too big.  "),
 	  PROMPT_CLEAR, PR_LATCH_TOOBIG, 0, 0, 0 },
 
 	/* Problem causes file to be too big */
 	{ PR_1_TOOBIG_REG,
 	  N_("%B (%b) causes file to be too big.  "),
 	  PROMPT_CLEAR, PR_LATCH_TOOBIG, 0, 0, 0 },
 
 	/* Problem causes symlink to be too big */
 	{ PR_1_TOOBIG_SYMLINK,
 	  N_("%B (%b) causes symlink to be too big.  "),
 	  PROMPT_CLEAR, PR_LATCH_TOOBIG, 0, 0, 0 },
 
 	/* Inode has INDEX_FL flag set on filesystem without htree support  */
 	{ PR_1_HTREE_SET,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has INDEX_FL flag set on @f without htree support.\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Inode number has INDEX_FL flag set but is on a directory */
 	{ PR_1_HTREE_NODIR,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has INDEX_FL flag set but is not a @d.\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* htree directory has an invalid root node */
 	{ PR_1_HTREE_BADROOT,
 	  /* xgettext:no-c-format */
 	  N_("@h %i has an @n root node.\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Htree directory has an unsupported hash version */
 	{ PR_1_HTREE_HASHV,
 	  N_("@h %i has an unsupported hash version (%N)\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Htree directory uses an Incompatible htree root node flag */
 	{ PR_1_HTREE_INCOMPAT,
 	  /* xgettext:no-c-format */
 	  N_("@h %i uses an incompatible htree root node flag.\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Htree directory has a tree depth which is too big */
 	{ PR_1_HTREE_DEPTH,
 	  N_("@h %i has a tree depth (%N) which is too big\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Bad block inode has an indirect block number that conflicts with
 	 * filesystem metadata */
 	{ PR_1_BB_FS_BLOCK,
 	  N_("Bad @b @i has an indirect @b (%b) that conflicts with\n"
 	     "@f metadata.  "),
 	  PROMPT_CLEAR, PR_LATCH_BBLOCK, 0, 0, 0 },
 
 	/* Resize inode (re)creation failed */
 	{ PR_1_RESIZE_INODE_CREATE,
 	  /* xgettext:no-c-format */
 	  N_("Resize @i (re)creation failed: %m."),
 	  PROMPT_CONTINUE, 0, 0, 0, 0 },
 
 	/* inode has a extra size i_extra_isize which is invalid */
 	{ PR_1_EXTRA_ISIZE,
 	  N_("@i %i has a extra size (%IS) which is @n\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Extended attribute in inode has a namelen which is invalid */
 	{ PR_1_ATTR_NAME_LEN,
 	  N_("@a in @i %i has a namelen (%N) which is @n\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Extended attribute in inode has a value offset which is invalid */
 	{ PR_1_ATTR_VALUE_OFFSET,
 	  N_("@a in @i %i has a value offset (%N) which is @n\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* extended attribute in inode has a value block which is invalid */
 	{ PR_1_ATTR_VALUE_BLOCK,
 	  N_("@a in @i %i has a value @b (%N) which is @n (must be 0)\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* extended attribute in inode has a value size which is invalid */
 	{ PR_1_ATTR_VALUE_SIZE,
 	  N_("@a in @i %i has a value size (%N) which is @n\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* extended attribute in inode has a hash which is invalid */
 	{ PR_1_ATTR_HASH,
 	  N_("@a in @i %i has a hash (%N) which is @n\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* inode is a type but it looks like it is really a directory */
 	{ PR_1_TREAT_AS_DIRECTORY,
 	  N_("@i %i is a %It but it looks like it is really a directory.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Error while reading extent tree in inode */
 	{ PR_1_READ_EXTENT,
 	  /* xgettext:no-c-format */
 	  N_("Error while reading over @x tree in @i %i: %m\n"),
 	  PROMPT_CLEAR_INODE, 0, 0, 0, 0 },
 
 	/* Failure to iterate extents in inode */
 	{ PR_1_EXTENT_ITERATE_FAILURE,
 	  N_("Failed to iterate extents in @i %i\n"
 	     "\t(op %s, blk %b, lblk %c): %m\n"),
 	  PROMPT_CLEAR_INODE, 0, 0, 0, 0 },
 
 	/* Inode has an invalid extent starting block */
 	{ PR_1_EXTENT_BAD_START_BLK,
 	  N_("@i %i has an @n extent\n\t(logical @b %c, @n physical @b %b, len %N)\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Inode has an invalid extent that ends beyond filesystem */
 	{ PR_1_EXTENT_ENDS_BEYOND,
 	  N_("@i %i has an @n extent\n\t(logical @b %c, physical @b %b, @n len %N)\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* inode has EXTENTS_FL flag set on filesystem without extents support*/
 	{ PR_1_EXTENTS_SET,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has EXTENTS_FL flag set on @f without extents support.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* inode is in extents format, but superblock is missing EXTENTS feature */
 	{ PR_1_EXTENT_FEATURE,
 	  /* xgettext:no-c-format */
 	  N_("@i %i is in extent format, but @S is missing EXTENTS feature\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* inode missing EXTENTS_FL, but is an extent inode */
 	{ PR_1_UNSET_EXTENT_FL,
 	  /* xgettext:no-c-format */
 	  N_("@i %i missing EXTENT_FL, but is in extents format\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Fast symlink has EXTENTS_FL set */
 	{ PR_1_FAST_SYMLINK_EXTENT_FL,
 	  /* xgettext:no-c-format */
 	  N_("Fast symlink %i has EXTENT_FL set.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Extents are out of order */
 	{ PR_1_OUT_OF_ORDER_EXTENTS,
 	  N_("@i %i has out of order extents\n\t(@n logical @b %c, physical @b %b, len %N)\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	{ PR_1_EXTENT_HEADER_INVALID,
 	  N_("@i %i has an invalid extent node (blk %b, lblk %c)\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Failed to convert subcluster block bitmap */
 	{ PR_1_CONVERT_SUBCLUSTER,
 	  /* xgettext:no-c-format */
 	  N_("Error converting subcluster @b @B: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Quota inode is not a regular file */
 	{ PR_1_QUOTA_BAD_MODE,
 	  N_("@q @i is not a regular file.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Quota inode is not in use, but contains data */
 	{ PR_1_QUOTA_INODE_NOT_CLEAR,
 	  N_("@q @i is not in use, but contains data.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Quota inode is visible to the user */
 	{ PR_1_QUOTA_INODE_NOT_HIDDEN,
 	  N_("@q @i is visible to the user.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* The bad block inode looks invalid */
 	{ PR_1_INVALID_BAD_INODE,
 	  N_("The bad @b @i looks @n.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Extent has zero length extent */
 	{ PR_1_EXTENT_LENGTH_ZERO,
 	  N_("@i %i has zero length extent\n\t(@n logical @b %c, physical @b %b)\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* inode seems to contain garbage */
 	{ PR_1_INODE_IS_GARBAGE,
 	  /* xgettext:no-c-format */
 	  N_("@i %i seems to contain garbage.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* inode passes checks, but checksum does not match inode */
 	{ PR_1_INODE_ONLY_CSUM_INVALID,
 	  /* xgettext:no-c-format */
 	  N_("@i %i passes checks, but checksum does not match @i.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Inode extended attribute is corrupt (allocation collision) */
 	{ PR_1_INODE_EA_ALLOC_COLLISION,
 	  /* xgettext:no-c-format */
 	  N_("@i %i @a is corrupt (allocation collision).  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0},
 
 	/*
 	 * Inode extent block passes checks, but checksum does not match
 	 * extent
 	 */
 	{ PR_1_EXTENT_ONLY_CSUM_INVALID,
 	  N_("@i %i extent block passes checks, but checksum does not match "
 	     "extent\n\t(logical @b %c, physical @b %b, len %N)\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/*
 	 * Inode extended attribute block passes checks, but checksum does not
 	 * match block.
 	 */
 	{ PR_1_EA_BLOCK_ONLY_CSUM_INVALID,
 	  N_("@i %i @a @b %b passes checks, but checksum does not match @b.  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Interior extent node level number of inode doesn't first node down */
 	{ PR_1_EXTENT_INDEX_START_INVALID,
 	  N_("Interior @x node level %N of @i %i:\n"
 	     "Logical start %b does not match logical start %c at next level.  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Inode end of extent exceeds allowed value */
 	{ PR_1_EXTENT_END_OUT_OF_BOUNDS,
 	  N_("@i %i, end of extent exceeds allowed value\n\t(logical @b %c, physical @b %b, len %N)\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Inode has inline data, but superblock is missing INLINE_DATA feature */
 	{ PR_1_INLINE_DATA_FEATURE,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has inline data, but @S is missing INLINE_DATA feature\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* inode has INLINE_DATA_FL flag on filesystem without inline data */
 	{ PR_1_INLINE_DATA_SET,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has INLINE_DATA_FL flag on @f without inline data support.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/*
 	 * Inode block conflicts with critical metadata, skipping block checks
 	 */
 	{ PR_1_CRITICAL_METADATA_COLLISION,
 	  /* xgettext:no-c-format */
 	  N_("@i %i block %b conflicts with critical metadata, skipping block checks.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Directory inode block <block> should be at block <otherblock> */
 	{ PR_1_COLLAPSE_DBLOCK,
 	  N_("@d @i %i @b %b should be at @b %c.  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Extents/inlinedata flag set on a device or socket inode */
 	{ PR_1_UNINIT_DBLOCK,
 	  /* xgettext:no-c-format */
 	  N_("@d @i %i has @x marked uninitialized at @b %c.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Inode logical block (physical block) violates cluster allocation */
 	{ PR_1_MISALIGNED_CLUSTER,
 	  N_("@i %i logical @b %b (physical @b %c) violates cluster allocation rules.\nWill fix in pass 1B.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Inode has INLINE_DATA_FL flag but extended attribute not found */
 	{ PR_1_INLINE_DATA_NO_ATTR,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has INLINE_DATA_FL flag but @a not found.  "),
 	  PROMPT_TRUNCATE, 0, 0, 0, 0 },
 
 	/* Special (device/socket/fifo) file (inode num) has extents
 	 * or inline-data flag set */
 	{ PR_1_SPECIAL_EXTENTS_IDATA,
 	  /* xgettext:no-c-format */
 	  N_("Special (@v/socket/fifo) file (@i %i) has extents\n"
 	     "or inline-data flag set.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK | PR_PREEN_NO | PR_NO_OK, 0, 0, 0 },
 
 	/* Inode has extent header but inline data flag is set */
 	{ PR_1_CLEAR_INLINE_DATA_FOR_EXTENT,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has @x header but inline data flag is set.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Inode seems to have inline data but extent flag is set */
 	{ PR_1_CLEAR_EXTENT_FOR_INLINE_DATA,
 	  /* xgettext:no-c-format */
 	  N_("@i %i seems to have inline data but @x flag is set.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Inode seems to have block map but inline data and extent flags set */
 	{ PR_1_CLEAR_EXTENT_INLINE_DATA_FLAGS,
 	  /* xgettext:no-c-format */
 	  N_("@i %i seems to have @b map but inline data and @x flags set.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Inode has inline data and extent flags but i_block contains junk */
 	{ PR_1_CLEAR_EXTENT_INLINE_DATA_INODE,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has inline data and @x flags set but i_block contains junk.\n"),
 	  PROMPT_CLEAR_INODE, 0, 0, 0, 0 },
 
 	/* Bad block list says the bad block list inode is bad */
 	{ PR_1_BADBLOCKS_IN_BADBLOCKS,
 	  N_("Bad block list says the bad block list @i is bad.  "),
 	  PROMPT_CLEAR_INODE, 0, 0, 0, 0 },
 
 	/* Error allocating extent region allocation structure */
 	{ PR_1_EXTENT_ALLOC_REGION_ABORT,
 	  N_("@A @x region allocation structure.  "),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Inode leaf has a duplicate extent mapping */
 	{ PR_1_EXTENT_COLLISION,
 	  N_("@i %i has a duplicate @x mapping\n\t(logical @b %c, @n physical @b %b, len %N)\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Error allocating memory for encrypted inode list */
 	{ PR_1_ALLOCATE_ENCRYPTED_INODE_LIST,
 	  N_("@A %N bytes of memory for encrypted @i list\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Inode extent tree could be more shallow */
 	{ PR_1_EXTENT_BAD_MAX_DEPTH,
 	  N_("@i %i @x tree could be more shallow (%b; could be <= %c)\n"),
 	  PROMPT_FIX, PR_NO_OK | PR_PREEN_NO | PR_PREEN_OK, 0, 0, 0 },
 
 	/* inode num on bigalloc filesystem cannot be block mapped */
 	{ PR_1_NO_BIGALLOC_BLOCKMAP_FILES,
 	  /* xgettext:no-c-format */
 	  N_("@i %i on bigalloc @f cannot be @b mapped.  "),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Inode has corrupt extent header */
 	{ PR_1_MISSING_EXTENT_HEADER,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has corrupt @x header.  "),
 	  PROMPT_CLEAR_INODE, 0, 0, 0, 0 },
 
 	/* Timestamp(s) on inode beyond 2310-04-04 are likely pre-1970. */
 	{ PR_1_EA_TIME_OUT_OF_RANGE,
 	  /* xgettext:no-c-format */
 	  N_("Timestamp(s) on @i %i beyond 2310-04-04 are likely pre-1970.\n"),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Inode has illegal extended attribute value inode */
 	{ PR_1_ATTR_VALUE_EA_INODE,
 	  N_("@i %i has @I @a value @i %N.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Inode has invalid extended attribute. EA inode missing
 	 * EA_INODE flag. */
 	{ PR_1_ATTR_NO_EA_INODE_FL,
 	  N_("@i %i has @n @a. EA @i %N missing EA_INODE flag.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* EA inode for parent inode missing EA_INODE flag. */
 	{ PR_1_ATTR_SET_EA_INODE_FL,
 	  N_("EA @i %N for parent @i %i missing EA_INODE flag.\n "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Offer to clear uninitialized flag on an extent */
 	{ PR_1_CLEAR_UNINIT_EXTENT,
 	  /* xgettext:no-c-format */
 	  N_("@i %i has @x marked uninitialized at @b %c (len %N).  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Casefold flag set on a non-directory */
 	{ PR_1_CASEFOLD_NONDIR,
 	  N_("@i %i has the casefold flag set but is not a directory.  "),
 	  PROMPT_CLEAR_FLAG, 0, 0, 0, 0 },
 
 	/* Casefold flag set, but file system is missing the casefold feature */
 	{ PR_1_CASEFOLD_FEATURE,
 	  N_("@d %p has the casefold flag, but the\ncasefold feature is not enabled.  "),
 	  PROMPT_CLEAR_FLAG, 0, 0, 0, 0 },
 
 	/* Inode has encrypt flag but no encryption extended attribute */
 	{ PR_1_MISSING_ENCRYPTION_XATTR,
 	  N_("@i %i has encrypt flag but no encryption @a.\n"),
 	  PROMPT_CLEAR_FLAG, 0, 0, 0, 0 },
 
 	/* Encrypted inode has corrupt encryption extended attribute */
 	{ PR_1_CORRUPT_ENCRYPTION_XATTR,
 	  N_("Encrypted @i %i has corrupt encryption @a.\n"),
 	  PROMPT_CLEAR_INODE, 0, 0, 0, 0 },
 
 	/* Htree directory should use SipHash but does not */
 	{ PR_1_HTREE_NEEDS_SIPHASH,
 	  N_("@h %i uses hash version (%N), but should use SipHash (6) \n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Htree directory uses SipHash but should not */
 	{ PR_1_HTREE_CANNOT_SIPHASH,
 	  N_("@h %i uses SipHash, but should not.  "),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Orphan file has bad mode */
 	{ PR_1_ORPHAN_FILE_BAD_MODE,
 	  N_("Orphan file @i %i is not regular file.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK },
 
 	/* Orphan file inode is not in use, but contains data */
 	{ PR_1_ORPHAN_FILE_NOT_CLEAR,
 	  N_("Orphan file @i %i is not in use, but contains data.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK },
 
 	/* Pass 1b errors */
 
 	/* Pass 1B: Rescan for duplicate/bad blocks */
 	{ PR_1B_PASS_HEADER,
 	  N_("\nRunning additional passes to resolve @bs claimed by more than one @i...\n"
 	  "Pass 1B: Rescanning for @m @bs\n"),
 	  PROMPT_NONE, PR_HEADER, 0, 0, 0 },
 
 	/* Duplicate/bad block(s) header */
 	{ PR_1B_DUP_BLOCK_HEADER,
 	  /* xgettext:no-c-format */
 	  N_("@m @b(s) in @i %i:"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Duplicate/bad block(s) in inode */
 	{ PR_1B_DUP_BLOCK,
 	  " %b",
 	  PROMPT_NONE, PR_LATCH_DBLOCK | PR_PREEN_NOHDR, 0, 0, 0 },
 
 	/* Duplicate/bad block(s) end */
 	{ PR_1B_DUP_BLOCK_END,
 	  "\n",
 	  PROMPT_NONE, PR_PREEN_NOHDR, 0, 0, 0 },
 
 	/* Error while scanning inodes */
 	{ PR_1B_ISCAN_ERROR,
 	  /* xgettext:no-c-format */
 	  N_("Error while scanning inodes (%i): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error allocating inode bitmap */
 	{ PR_1B_ALLOCATE_IBITMAP_ERROR,
 	  /* xgettext:no-c-format */
 	  N_("@A @i @B (@i_dup_map): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error while iterating over blocks */
 	{ PR_1B_BLOCK_ITERATE,
 	  /* xgettext:no-c-format */
 	  N_("Error while iterating over @bs in @i %i (%s): %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error adjusting EA refcount */
 	{ PR_1B_ADJ_EA_REFCOUNT,
 	  N_("Error adjusting refcount for @a @b %b (@i %i): %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Duplicate/bad block range in inode */
 	{ PR_1B_DUP_RANGE,
 	  " %b--%c",
 	  PROMPT_NONE, PR_LATCH_DBLOCK | PR_PREEN_NOHDR, 0, 0, 0 },
 
 	/* Pass 1C: Scan directories for inodes with multiply-claimed blocks. */
 	{ PR_1C_PASS_HEADER,
 	  N_("Pass 1C: Scanning directories for @is with @m @bs\n"),
 	  PROMPT_NONE, PR_HEADER, 0, 0, 0 },
 
 
 	/* Pass 1D: Reconciling multiply-claimed blocks */
 	{ PR_1D_PASS_HEADER,
 	  N_("Pass 1D: Reconciling @m @bs\n"),
 	  PROMPT_NONE, PR_HEADER, 0, 0, 0 },
 
 	/* File has duplicate blocks */
 	{ PR_1D_DUP_FILE,
 	  N_("File %Q (@i #%i, mod time %IM) \n"
 	  "  has %r @m @b(s), shared with %N file(s):\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* List of files sharing duplicate blocks */
 	{ PR_1D_DUP_FILE_LIST,
 	  N_("\t%Q (@i #%i, mod time %IM)\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* File sharing blocks with filesystem metadata  */
 	{ PR_1D_SHARE_METADATA,
 	  N_("\t<@f metadata>\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Report of how many duplicate/bad inodes */
 	{ PR_1D_NUM_DUP_INODES,
 	  N_("(There are %N @is containing @m @bs.)\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Duplicated blocks already reassigned or cloned. */
 	{ PR_1D_DUP_BLOCKS_DEALT,
 	  N_("@m @bs already reassigned or cloned.\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Clone duplicate/bad blocks? */
 	{ PR_1D_CLONE_QUESTION,
 	  "", PROMPT_CLONE, PR_NO_OK, 0, 0, 0 },
 
 	/* Delete file? */
 	{ PR_1D_DELETE_QUESTION,
 	  "", PROMPT_DELETE, 0, 0, 0, 0 },
 
 	/* Couldn't clone file (error) */
 	{ PR_1D_CLONE_ERROR,
 	  /* xgettext:no-c-format */
 	  N_("Couldn't clone file: %m\n"), PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Pass 1E Extent tree optimization	*/
 
 	/* Pass 1E: Optimizing extent trees */
 	{ PR_1E_PASS_HEADER,
 	  N_("Pass 1E: Optimizing @x trees\n"),
 	  PROMPT_NONE, PR_HEADER | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Failed to optimize extent tree */
 	{ PR_1E_OPTIMIZE_EXT_ERR,
 	  /* xgettext:no-c-format */
 	  N_("Failed to optimize @x tree %p (%i): %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Optimizing extent trees */
 	{ PR_1E_OPTIMIZE_EXT_HEADER,
 	  N_("Optimizing @x trees: "),
 	  PROMPT_NONE, PR_MSG_ONLY, 0, 0, 0 },
 
 	/* Rebuilding extent tree %d */
 	{ PR_1E_OPTIMIZE_EXT,
 	  " %i",
 	  PROMPT_NONE, PR_LATCH_OPTIMIZE_EXT | PR_PREEN_NOHDR, 0, 0, 0 },
 
 	/* Rebuilding extent tree end */
 	{ PR_1E_OPTIMIZE_EXT_END,
 	  "\n",
 	  PROMPT_NONE, PR_PREEN_NOHDR, 0, 0, 0 },
 
 	/* Internal error: extent tree depth too large */
 	{ PR_1E_MAX_EXTENT_TREE_DEPTH,
 	  N_("Internal error: max extent tree depth too large (%b; expected=%c).\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Inode extent tree could be shorter */
 	{ PR_1E_CAN_COLLAPSE_EXTENT_TREE,
 	  N_("@i %i @x tree (at level %b) could be shorter.  "),
 	  PROMPT_OPTIMIZE, PR_NO_OK | PR_PREEN_NO | PR_PREEN_OK | PR_NOT_A_FIX, 0, 0, 0 },
 
 	/* Inode extent tree could be narrower */
 	{ PR_1E_CAN_NARROW_EXTENT_TREE,
 	  N_("@i %i @x tree (at level %b) could be narrower.  "),
 	  PROMPT_OPTIMIZE, PR_NO_OK | PR_PREEN_NO | PR_PREEN_OK | PR_NOT_A_FIX, 0, 0, 0 },
 
 	/* Pass 2 errors */
 
 	/* Pass 2: Checking directory structure */
 	{ PR_2_PASS_HEADER,
 	  N_("Pass 2: Checking @d structure\n"),
 	  PROMPT_NONE, PR_HEADER, 0, 0, 0 },
 
 	/* Bad inode number for '.' */
 	{ PR_2_BAD_INODE_DOT,
 	  /* xgettext:no-c-format */
 	  N_("@n @i number for '.' in @d @i %i.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Entry 'xxxx' in /a/b/c has bad inode number.*/
 	{ PR_2_BAD_INO,
 	  N_("@E has @n @i #: %Di.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Entry 'xxxx' in /a/b/c has deleted/unused inode nnnnn.*/
 	{ PR_2_UNUSED_INODE,
 	  N_("@E has @D/unused @i %Di.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Directory entry is link to '.' */
 	{ PR_2_LINK_DOT,
 	  N_("@E @L to '.'  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Directory entry points to inode now located in a bad block */
 	{ PR_2_BB_INODE,
 	  N_("@E points to @i (%Di) located in a bad @b.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Directory entry contains a link to a directory */
 	{ PR_2_LINK_DIR,
 	  N_("@E @L to @d %P (%Di).\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Directory entry contains a link to the root directory */
 	{ PR_2_LINK_ROOT,
 	  N_("@E @L to the @r.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Directory entry has illegal characters in its name */
 	{ PR_2_BAD_NAME,
 	  N_("@E has illegal characters in its name.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Missing '.' in directory inode */
 	{ PR_2_MISSING_DOT,
 	  /* xgettext:no-c-format */
 	  N_("Missing '.' in @d @i %i.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Missing '..' in directory inode */
 	{ PR_2_MISSING_DOT_DOT,
 	  /* xgettext:no-c-format */
 	  N_("Missing '..' in @d @i %i.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* First entry in directory inode doesn't contain '.' */
 	{ PR_2_1ST_NOT_DOT,
 	  N_("First @e '%Dn' (@i=%Di) in @d @i %i (%p) @s '.'\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Second entry in directory inode doesn't contain '..' */
 	{ PR_2_2ND_NOT_DOT_DOT,
 	  N_("Second @e '%Dn' (@i=%Di) in @d @i %i @s '..'\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* i_faddr should be zero */
 	{ PR_2_FADDR_ZERO,
 	  N_("i_faddr @F %IF, @s zero.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* i_file_acl should be zero */
 	{ PR_2_FILE_ACL_ZERO,
 	  N_("i_file_acl @F %If, @s zero.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* i_size_high should be zero */
 	{ PR_2_DIR_SIZE_HIGH_ZERO,
 	  N_("i_size_high @F %Id, @s zero.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* i_frag should be zero */
 	{ PR_2_FRAG_ZERO,
 	  N_("i_frag @F %N, @s zero.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* i_fsize should be zero */
 	{ PR_2_FSIZE_ZERO,
 	  N_("i_fsize @F %N, @s zero.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* inode has bad mode */
 	{ PR_2_BAD_MODE,
 	  N_("@i %i (%Q) has @n mode (%Im).\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* directory corrupted */
 	{ PR_2_DIR_CORRUPTED,
 	  N_("@d @i %i, %B, offset %N: @d corrupted\n"),
 	  PROMPT_SALVAGE, 0, 0, 0, 0 },
 
 	/* filename too long */
 	{ PR_2_FILENAME_LONG,
 	  N_("@d @i %i, %B, offset %N: filename too long\n"),
 	  PROMPT_TRUNCATE, 0, 0, 0, 0 },
 
 	/* Directory inode has a missing block (hole) */
 	{ PR_2_DIRECTORY_HOLE,
 	  N_("@d @i %i has an unallocated %B.  "),
 	  PROMPT_ALLOCATE, 0, 0, 0, 0 },
 
 	/* '.' is not NULL terminated */
 	{ PR_2_DOT_NULL_TERM,
 	  /* xgettext:no-c-format */
 	  N_("'.' @d @e in @d @i %i is not NULL terminated\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* '..' is not NULL terminated */
 	{ PR_2_DOT_DOT_NULL_TERM,
 	  /* xgettext:no-c-format */
 	  N_("'..' @d @e in @d @i %i is not NULL terminated\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Illegal character device inode */
 	{ PR_2_BAD_CHAR_DEV,
 	  N_("@i %i (%Q) is an @I character @v.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Illegal block device inode */
 	{ PR_2_BAD_BLOCK_DEV,
 	  N_("@i %i (%Q) is an @I @b @v.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Duplicate '.' entry */
 	{ PR_2_DUP_DOT,
 	  N_("@E is duplicate '.' @e.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Duplicate '..' entry */
 	{ PR_2_DUP_DOT_DOT,
 	  N_("@E is duplicate '..' @e.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Internal error: couldn't find dir_info */
 	{ PR_2_NO_DIRINFO,
 	  /* xgettext:no-c-format */
 	  N_("Internal error: couldn't find dir_info for %i.\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Final rec_len is wrong */
 	{ PR_2_FINAL_RECLEN,
 	  N_("@E has rec_len of %Dr, @s %N.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Error allocating icount structure */
 	{ PR_2_ALLOCATE_ICOUNT,
 	  /* xgettext:no-c-format */
 	  N_("@A icount structure: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error iterating over directory blocks */
 	{ PR_2_DBLIST_ITERATE,
 	  /* xgettext:no-c-format */
 	  N_("Error iterating over @d @bs: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error reading directory block */
 	{ PR_2_READ_DIRBLOCK,
 	  N_("Error reading @d @b %b (@i %i): %m\n"),
 	  PROMPT_CONTINUE, 0, 0, 0, 0 },
 
 	/* Error writing directory block */
 	{ PR_2_WRITE_DIRBLOCK,
 	  N_("Error writing @d @b %b (@i %i): %m\n"),
 	  PROMPT_CONTINUE, 0, 0, 0, 0 },
 
 	/* Error allocating new directory block */
 	{ PR_2_ALLOC_DIRBOCK,
 	  /* xgettext:no-c-format */
 	  N_("@A new @d @b for @i %i (%s): %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error deallocating inode */
 	{ PR_2_DEALLOC_INODE,
 	  /* xgettext:no-c-format */
 	  N_("Error deallocating @i %i: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Directory entry for '.' is big.  Split? */
 	{ PR_2_SPLIT_DOT,
 	  /* xgettext:no-c-format */
 	  N_("@d @e for '.' in %p (%i) is big.\n"),
 	  PROMPT_SPLIT, PR_NO_OK, 0, 0, 0 },
 
 	/* Illegal FIFO inode */
 	{ PR_2_BAD_FIFO,
 	  N_("@i %i (%Q) is an @I FIFO.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Illegal socket inode */
 	{ PR_2_BAD_SOCKET,
 	  N_("@i %i (%Q) is an @I socket.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Directory filetype not set */
 	{ PR_2_SET_FILETYPE,
 	  N_("Setting filetype for @E to %N.\n"),
 	  PROMPT_NONE, PR_PREEN_OK | PR_NO_OK | PR_NO_NOMSG, 0, 0, 0 },
 
 	/* Directory filetype incorrect */
 	{ PR_2_BAD_FILETYPE,
 	  N_("@E has an incorrect filetype (was %Dt, @s %N).\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Directory filetype set on filesystem */
 	{ PR_2_CLEAR_FILETYPE,
 	  N_("@E has filetype set.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Directory filename is null */
 	{ PR_2_NULL_NAME,
 	  N_("@E has a @z name.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Invalid symlink */
 	{ PR_2_INVALID_SYMLINK,
 	  N_("Symlink %Q (@i #%i) is @n.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* i_file_acl (extended attribute block) is bad */
 	{ PR_2_FILE_ACL_BAD,
 	  N_("@a @b @F @n (%If).\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Filesystem contains large files, but has no such flag in sb */
 	{ PR_2_FEATURE_LARGE_FILES,
 	  N_("@f contains large files, but lacks LARGE_FILE flag in @S.\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Node in HTREE directory not referenced */
 	{ PR_2_HTREE_NOTREF,
 	  N_("@p @h %d: %B not referenced\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Node in HTREE directory referenced twice */
 	{ PR_2_HTREE_DUPREF,
 	  N_("@p @h %d: %B referenced twice\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Node in HTREE directory has bad min hash */
 	{ PR_2_HTREE_MIN_HASH,
 	  N_("@p @h %d: %B has bad min hash\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Node in HTREE directory has bad max hash */
 	{ PR_2_HTREE_MAX_HASH,
 	  N_("@p @h %d: %B has bad max hash\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Clear invalid HTREE directory */
 	{ PR_2_HTREE_CLEAR,
 	  N_("@n @h %d (%q).  "), PROMPT_CLEAR_HTREE, 0, 0, 0, 0 },
 
 	/* Filesystem has large directories, but has no such flag in sb */
 	{ PR_2_FEATURE_LARGE_DIRS,
 	  N_("@f has large directories, but lacks LARGE_DIR flag in @S.\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Bad block in htree interior node */
 	{ PR_2_HTREE_BADBLK,
 	  N_("@p @h %d (%q): bad @b number %b.\n"),
 	  PROMPT_CLEAR_HTREE, 0, 0, 0, 0 },
 
 	/* Error adjusting EA refcount */
 	{ PR_2_ADJ_EA_REFCOUNT,
 	  N_("Error adjusting refcount for @a @b %b (@i %i): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Problem in HTREE directory inode: root node is invalid */
 	{ PR_2_HTREE_BAD_ROOT,
 	  /* xgettext:no-c-format */
 	  N_("@p @h %d: root node is @n\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Invalid HTREE limit */
 	{ PR_2_HTREE_BAD_LIMIT,
 	  N_("@p @h %d: %B has @n limit (%N)\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Invalid HTREE count */
 	{ PR_2_HTREE_BAD_COUNT,
 	  N_("@p @h %d: %B has @n count (%N)\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* HTREE interior node has out-of-order hashes in table */
 	{ PR_2_HTREE_HASH_ORDER,
 	  N_("@p @h %d: %B has an unordered hash table\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Node in HTREE directory has invalid depth */
 	{ PR_2_HTREE_BAD_DEPTH,
 	  N_("@p @h %d: %B has @n depth (%N)\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Duplicate directory entry found */
 	{ PR_2_DUPLICATE_DIRENT,
 	  N_("Duplicate @E found.  "),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Non-unique filename found */
 	{ PR_2_NON_UNIQUE_FILE, /* xgettext: no-c-format */
 	  N_("@E has a non-unique filename.\nRename to %s"),
 	  PROMPT_NULL, 0, 0, 0, 0 },
 
 	/* Duplicate directory entry found */
 	{ PR_2_REPORT_DUP_DIRENT,
 	  N_("Duplicate @e '%Dn' found.\n\tMarking %p (%i) to be rebuilt.\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* i_blocks_hi should be zero */
 	{ PR_2_BLOCKS_HI_ZERO,
 	  N_("i_blocks_hi @F %N, @s zero.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Unexpected HTREE block */
 	{ PR_2_UNEXPECTED_HTREE_BLOCK,
 	  N_("Unexpected @b in @h %d (%q).\n"), PROMPT_CLEAR_HTREE, 0,
 	  0, 0, 0 },
 
 	/* Inode found in group where _INODE_UNINIT is set */
 	{ PR_2_INOREF_BG_INO_UNINIT,
 	  N_("@E references @i %Di in @g %g where _INODE_UNINIT is set.\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Inode found in group unused inodes area */
 	{ PR_2_INOREF_IN_UNUSED,
 	  N_("@E references @i %Di found in @g %g's unused inodes area.\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* i_blocks_hi should be zero */
 	{ PR_2_I_FILE_ACL_HI_ZERO,
 	  N_("i_file_acl_hi @F %N, @s zero.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK, 0, 0, 0 },
 
 	/* htree root node fails checksum */
 	{ PR_2_HTREE_ROOT_CSUM_INVALID,
 	  /* xgettext:no-c-format */
 	  N_("@p @h %d: root node fails checksum.\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* htree internal node fails checksum */
 	{ PR_2_HTREE_NODE_CSUM_INVALID,
 	  /* xgettext:no-c-format */
 	  N_("@p @h %d: internal node fails checksum.\n"),
 	  PROMPT_CLEAR_HTREE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* leaf node has no checksum */
 	{ PR_2_LEAF_NODE_MISSING_CSUM,
 	  N_("@d @i %i, %B, offset %N: @d has no checksum.\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* leaf node passes checks but fails checksum */
 	{ PR_2_LEAF_NODE_ONLY_CSUM_INVALID,
 	  N_("@d @i %i, %B: @d passes checks but fails checksum.\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* inline directory inode size must be a multiple of 4 */
 	{ PR_2_BAD_INLINE_DIR_SIZE,
 	  N_("Inline @d @i %i size (%N) must be a multiple of 4.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* fixing size of inline directory inode failed */
 	{ PR_2_FIX_INLINE_DIR_FAILED,
 	  /* xgettext:no-c-format */
 	  N_("Fixing size of inline @d @i %i failed.\n"),
 	  PROMPT_TRUNCATE, 0, 0, 0, 0 },
 
 	/* Encrypted directory entry is too short */
 	{ PR_2_BAD_ENCRYPTED_NAME,
 	  N_("Encrypted @E is too short.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Encrypted directory contains unencrypted file */
 	{ PR_2_UNENCRYPTED_FILE,
 	  N_("Encrypted @E references unencrypted @i %Di.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Encrypted directory contains file with different encryption policy */
 	{ PR_2_INCONSISTENT_ENCRYPTION_POLICY,
 	  N_("Encrypted @E references @i %Di, which has a different encryption policy.\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Casefolded directory entry has illegal characters in its name */
 	{ PR_2_BAD_ENCODED_NAME,
 	  N_("@E has illegal UTF-8 characters in its name.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	 /* Non-unique filename found, but can't rename */
 	 { PR_2_NON_UNIQUE_FILE_NO_RENAME,
 	   N_("Duplicate filename @E found.  "),
 	   PROMPT_CLEAR, 0, 0, 0, 0 },
 
 
 	/* Pass 3 errors */
 
 	/* Pass 3: Checking directory connectivity */
 	{ PR_3_PASS_HEADER,
 	  N_("Pass 3: Checking @d connectivity\n"),
 	  PROMPT_NONE, PR_HEADER, 0, 0, 0 },
 
 	/* Root inode not allocated */
 	{ PR_3_NO_ROOT_INODE,
 	  N_("@r not allocated.  "),
 	  PROMPT_ALLOCATE, 0, 0, 0, 0 },
 
 	/* No room in lost+found */
 	{ PR_3_EXPAND_LF_DIR,
 	  N_("No room in @l @d.  "),
 	  PROMPT_EXPAND, 0, 0, 0, 0 },
 
 	/* Unconnected directory inode */
 	{ PR_3_UNCONNECTED_DIR,
 	  /* xgettext:no-c-format */
-	  N_("Unconnected @d @i %i (%p)\n"),
+	  N_("Unconnected @d @i %i (was in %q)\n"),
 	  PROMPT_CONNECT, 0, 0, 0, 0 },
 
 	/* /lost+found not found */
 	{ PR_3_NO_LF_DIR,
 	  N_("/@l not found.  "),
 	  PROMPT_CREATE, PR_PREEN_OK, 0, 0, 0 },
 
 	/* .. entry is incorrect */
 	{ PR_3_BAD_DOT_DOT,
 	  N_("'..' in %Q (%i) is %P (%j), @s %q (%d).\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Bad or non-existent /lost+found.  Cannot reconnect */
 	{ PR_3_NO_LPF,
 	  /* xgettext:no-c-format */
 	  N_("Bad or non-existent /@l.  Cannot reconnect.\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Could not expand /lost+found */
 	{ PR_3_CANT_EXPAND_LPF,
 	  /* xgettext:no-c-format */
 	  N_("Could not expand /@l: %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Could not reconnect inode */
 	{ PR_3_CANT_RECONNECT,
 	  /* xgettext:no-c-format */
 	  N_("Could not reconnect %i: %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error while trying to find /lost+found */
 	{ PR_3_ERR_FIND_LPF,
 	  /* xgettext:no-c-format */
 	  N_("Error while trying to find /@l: %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error in ext2fs_new_block while creating /lost+found */
 	{ PR_3_ERR_LPF_NEW_BLOCK,
 	  /* xgettext:no-c-format */
 	  N_("ext2fs_new_@b: %m while trying to create /@l @d\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error in ext2fs_new_inode while creating /lost+found */
 	{ PR_3_ERR_LPF_NEW_INODE,
 	  /* xgettext:no-c-format */
 	  N_("ext2fs_new_@i: %m while trying to create /@l @d\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error in ext2fs_new_dir_block while creating /lost+found */
 	{ PR_3_ERR_LPF_NEW_DIR_BLOCK,
 	  /* xgettext:no-c-format */
 	  N_("ext2fs_new_dir_@b: %m while creating new @d @b\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error while writing directory block for /lost+found */
 	{ PR_3_ERR_LPF_WRITE_BLOCK,
 	  /* xgettext:no-c-format */
 	  N_("ext2fs_write_dir_@b: %m while writing the @d @b for /@l\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error while adjusting inode count */
 	{ PR_3_ADJUST_INODE,
 	  /* xgettext:no-c-format */
 	  N_("Error while adjusting @i count on @i %i\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Couldn't fix parent directory -- error */
 	{ PR_3_FIX_PARENT_ERR,
 	  /* xgettext:no-c-format */
 	  N_("Couldn't fix parent of @i %i: %m\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Couldn't fix parent directory -- couldn't find it */
 	{ PR_3_FIX_PARENT_NOFIND,
 	  /* xgettext:no-c-format */
 	  N_("Couldn't fix parent of @i %i: Couldn't find parent @d @e\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error allocating inode bitmap */
 	{ PR_3_ALLOCATE_IBITMAP_ERROR,
 	  N_("@A @i @B (%N): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error creating root directory */
 	{ PR_3_CREATE_ROOT_ERROR,
 	  /* xgettext:no-c-format */
 	  N_("Error creating root @d (%s): %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error creating lost and found directory */
 	{ PR_3_CREATE_LPF_ERROR,
 	  /* xgettext:no-c-format */
 	  N_("Error creating /@l @d (%s): %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Root inode is not directory; aborting */
 	{ PR_3_ROOT_NOT_DIR_ABORT,
 	  N_("@r is not a @d; aborting.\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Cannot proceed without a root inode. */
 	{ PR_3_NO_ROOT_INODE_ABORT,
 	  N_("Cannot proceed without a @r.\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Internal error: couldn't find dir_info */
 	{ PR_3_NO_DIRINFO,
 	  N_("Internal error: couldn't find dir_info for %i.\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Lost+found not a directory */
 	{ PR_3_LPF_NOTDIR,
 	  /* xgettext:no-c-format */
 	  N_("/@l is not a @d (ino=%i)\n"),
 	  PROMPT_UNLINK, 0, 0, 0, 0 },
 
 	/* Lost+found has inline data */
 	{ PR_3_LPF_INLINE_DATA,
 	  N_("/@l has inline data\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
 	/* Cannot allocate /lost+found. */
 	{ PR_3_LPF_NO_SPACE,
 	  N_("Cannot allocate space for /@l.\nPlace lost files in root directory instead"),
 	  PROMPT_NULL, 0, 0, 0, 0 },
 
 	/* Delete some files and re-run e2fsck. */
 	{ PR_3_NO_SPACE_TO_RECOVER,
 	  N_("Insufficient space to recover lost files!\nMove data off the @f and re-run e2fsck.\n\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Lost+found is encrypted */
 	{ PR_3_LPF_ENCRYPTED,
 	  N_("/@l is encrypted\n"),
 	  PROMPT_CLEAR, 0, 0, 0, 0 },
 
+	/* Recursively looped directory inode */
+	{ PR_3_LOOPED_DIR,
+	  /* xgettext:no-c-format */
+	  N_("Recursively looped @d @i %i (%p)\n"),
+	  PROMPT_CONNECT, 0, 0, 0, 0 },
+
 	/* Pass 3A Directory Optimization	*/
 
 	/* Pass 3A: Optimizing directories */
 	{ PR_3A_PASS_HEADER,
 	  N_("Pass 3A: Optimizing directories\n"),
 	  PROMPT_NONE, PR_HEADER | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Error iterating over directories */
 	{ PR_3A_OPTIMIZE_ITER,
 	  /* xgettext:no-c-format */
 	  N_("Failed to create dirs_to_hash iterator: %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Error rehash directory */
 	{ PR_3A_OPTIMIZE_DIR_ERR,
 	  N_("Failed to optimize directory %q (%d): %m\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	/* Rehashing dir header */
 	{ PR_3A_OPTIMIZE_DIR_HEADER,
 	  N_("Optimizing directories: "),
 	  PROMPT_NONE, PR_MSG_ONLY, 0, 0, 0 },
 
 	/* Rehashing directory %d */
 	{ PR_3A_OPTIMIZE_DIR,
 	  " %d",
 	  PROMPT_NONE, PR_LATCH_OPTIMIZE_DIR | PR_PREEN_NOHDR, 0, 0, 0 },
 
 	/* Rehashing dir end */
 	{ PR_3A_OPTIMIZE_DIR_END,
 	  "\n",
 	  PROMPT_NONE, PR_PREEN_NOHDR, 0, 0, 0 },
 
 	/* Pass 4 errors */
 
 	/* Pass 4: Checking reference counts */
 	{ PR_4_PASS_HEADER,
 	  N_("Pass 4: Checking reference counts\n"),
 	  PROMPT_NONE, PR_HEADER, 0, 0, 0 },
 
 	/* Unattached zero-length inode */
 	{ PR_4_ZERO_LEN_INODE,
 	  /* xgettext:no-c-format */
 	  N_("@u @z @i %i.  "),
 	  PROMPT_CLEAR, PR_PREEN_OK|PR_NO_OK, 0, 0, 0 },
 
 	/* Unattached inode */
 	{ PR_4_UNATTACHED_INODE,
 	  /* xgettext:no-c-format */
 	  N_("@u @i %i\n"),
 	  PROMPT_CONNECT, 0, 0, 0, 0 },
 
 	/* Inode ref count wrong */
 	{ PR_4_BAD_REF_COUNT,
 	  N_("@i %i ref count is %Il, @s %N.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	{ PR_4_INCONSISTENT_COUNT,
 	  N_("WARNING: PROGRAMMING BUG IN E2FSCK!\n"
 	  "\tOR SOME BONEHEAD (YOU) IS CHECKING A MOUNTED (LIVE) FILESYSTEM.\n"
 	  "@i_link_info[%i] is %N, @i.i_links_count is %Il.  "
 	  "They @s the same!\n"),
 	  PROMPT_NONE, 0, 0, 0, 0 },
 
 	{ PR_4_EA_INODE_REF_COUNT,
 	  N_("@a @i %i ref count is %N, @s %n. "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* directory exceeds max links, but no DIR_NLINK feature in superblock*/
 	{ PR_4_DIR_NLINK_FEATURE,
 	  N_("@d exceeds max links, but no DIR_NLINK feature in @S.\n"),
 	  PROMPT_FIX, 0, 0, 0, 0 },
 
 	/* Directory inode ref count set to overflow but could be exact value */
 	{ PR_4_DIR_OVERFLOW_REF_COUNT,
 	  N_("@d @i %i ref count set to overflow but could be exact value %N.  "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Pass 5 errors */
 
 	/* Pass 5: Checking group summary information */
 	{ PR_5_PASS_HEADER,
 	  N_("Pass 5: Checking @g summary information\n"),
 	  PROMPT_NONE, PR_HEADER, 0, 0, 0 },
 
 	/* Padding at end of inode bitmap is not set. */
 	{ PR_5_INODE_BMAP_PADDING,
 	  N_("Padding at end of @i @B is not set. "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Padding at end of block bitmap is not set. */
 	{ PR_5_BLOCK_BMAP_PADDING,
 	  N_("Padding at end of @b @B is not set. "),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Block bitmap differences header */
 	{ PR_5_BLOCK_BITMAP_HEADER,
 	  N_("@b @B differences: "),
 	  PROMPT_NONE, PR_PREEN_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Block not used, but marked in bitmap */
 	{ PR_5_BLOCK_UNUSED,
 	  " -%b",
 	  PROMPT_NONE, PR_LATCH_BBITMAP | PR_PREEN_OK | PR_PREEN_NOMSG,
 	  0, 0, 0 },
 
 	/* Block used, but not marked used in bitmap */
 	{ PR_5_BLOCK_USED,
 	  " +%b",
 	  PROMPT_NONE, PR_LATCH_BBITMAP | PR_PREEN_OK | PR_PREEN_NOMSG,
 	  0, 0, 0 },
 
 	/* Block bitmap differences end */
 	{ PR_5_BLOCK_BITMAP_END,
 	  "\n",
 	  PROMPT_FIX, PR_PREEN_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Inode bitmap differences header */
 	{ PR_5_INODE_BITMAP_HEADER,
 	  N_("@i @B differences: "),
 	  PROMPT_NONE, PR_PREEN_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Inode not used, but marked in bitmap */
 	{ PR_5_INODE_UNUSED,
 	  " -%i",
 	  PROMPT_NONE, PR_LATCH_IBITMAP | PR_PREEN_OK | PR_PREEN_NOMSG,
 	  0, 0, 0 },
 
 	/* Inode used, but not marked used in bitmap */
 	{ PR_5_INODE_USED,
 	  " +%i",
 	  PROMPT_NONE, PR_LATCH_IBITMAP | PR_PREEN_OK | PR_PREEN_NOMSG,
 	  0, 0, 0 },
 
 	/* Inode bitmap differences end */
 	{ PR_5_INODE_BITMAP_END,
 	  "\n",
 	  PROMPT_FIX, PR_PREEN_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Free inodes count for group wrong */
 	{ PR_5_FREE_INODE_COUNT_GROUP,
 	  N_("Free @is count wrong for @g #%g (%i, counted=%j).\n"),
 	  PROMPT_FIX, PR_PREEN_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Directories count for group wrong */
 	{ PR_5_FREE_DIR_COUNT_GROUP,
 	  N_("Directories count wrong for @g #%g (%i, counted=%j).\n"),
 	  PROMPT_FIX, PR_PREEN_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Free inodes count wrong */
 	{ PR_5_FREE_INODE_COUNT,
 	  N_("Free @is count wrong (%i, counted=%j).\n"),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Free blocks count for group wrong */
 	{ PR_5_FREE_BLOCK_COUNT_GROUP,
 	  N_("Free @bs count wrong for @g #%g (%b, counted=%c).\n"),
 	  PROMPT_FIX, PR_PREEN_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Free blocks count wrong */
 	{ PR_5_FREE_BLOCK_COUNT,
 	  N_("Free @bs count wrong (%b, counted=%c).\n"),
 	  PROMPT_FIX, PR_PREEN_OK | PR_NO_OK | PR_PREEN_NOMSG, 0, 0, 0 },
 
 	/* Programming error: bitmap endpoints don't match */
 	{ PR_5_BMAP_ENDPOINTS,
 	  N_("PROGRAMMING ERROR: @f (#%N) @B endpoints (%b, %c) don't "
 	  "match calculated @B endpoints (%i, %j)\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Internal error: fudging end of bitmap */
 	{ PR_5_FUDGE_BITMAP_ERROR,
 	  N_("Internal error: fudging end of bitmap (%N)\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error copying in replacement inode bitmap */
 	{ PR_5_COPY_IBITMAP_ERROR,
 	  /* xgettext:no-c-format */
 	  N_("Error copying in replacement @i @B: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Error copying in replacement block bitmap */
 	{ PR_5_COPY_BBITMAP_ERROR,
 	  /* xgettext:no-c-format */
 	  N_("Error copying in replacement @b @B: %m\n"),
 	  PROMPT_NONE, PR_FATAL, 0, 0, 0 },
 
 	/* Block range not used, but marked in bitmap */
 	{ PR_5_BLOCK_RANGE_UNUSED,
 	  " -(%b--%c)",
 	  PROMPT_NONE, PR_LATCH_BBITMAP | PR_PREEN_OK | PR_PREEN_NOMSG,
 	  0, 0, 0 },
 
 	/* Block range used, but not marked used in bitmap */
 	{ PR_5_BLOCK_RANGE_USED,
 	  " +(%b--%c)",
 	  PROMPT_NONE, PR_LATCH_BBITMAP | PR_PREEN_OK | PR_PREEN_NOMSG,
 	  0, 0, 0 },
 
 	/* Inode range not used, but marked in bitmap */
 	{ PR_5_INODE_RANGE_UNUSED,
 	  " -(%i--%j)",
 	  PROMPT_NONE, PR_LATCH_IBITMAP | PR_PREEN_OK | PR_PREEN_NOMSG,
 	  0, 0, 0 },
 
 	/* Inode range used, but not marked used in bitmap */
 	{ PR_5_INODE_RANGE_USED,
 	  " +(%i--%j)",
 	  PROMPT_NONE, PR_LATCH_IBITMAP | PR_PREEN_OK | PR_PREEN_NOMSG,
 	  0, 0, 0 },
 
 	/* Group N block(s) in use but group is marked BLOCK_UNINIT */
 	{ PR_5_BLOCK_UNINIT,
 	  /* xgettext:no-c-format */
 	  N_("@g %g @b(s) in use but @g is marked BLOCK_UNINIT\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Group N inode(s) in use but group is marked INODE_UNINIT */
 	{ PR_5_INODE_UNINIT,
 	  /* xgettext:no-c-format */
 	  N_("@g %g @i(s) in use but @g is marked INODE_UNINIT\n"),
 	  PROMPT_FIX, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Group N inode bitmap does not match checksum */
 	{ PR_5_INODE_BITMAP_CSUM_INVALID,
 	  /* xgettext:no-c-format */
 	  N_("@g %g @i @B does not match checksum.\n"),
 	  PROMPT_FIX, PR_LATCH_IBITMAP | PR_PREEN_OK, 0, 0, 0 },
 
 	/* Group N block bitmap does not match checksum */
 	{ PR_5_BLOCK_BITMAP_CSUM_INVALID,
 	  /* xgettext:no-c-format */
 	  N_("@g %g @b @B does not match checksum.\n"),
 	  PROMPT_FIX, PR_LATCH_BBITMAP | PR_PREEN_OK, 0, 0, 0 },
 
 	/* Post-Pass 5 errors */
 
 	/* Recreate journal if E2F_FLAG_JOURNAL_INODE flag is set */
 	{ PR_6_RECREATE_JOURNAL,
 	  N_("Recreate @j"),
 	  PROMPT_NULL, PR_PREEN_OK | PR_NO_OK, 0, 0, 0 },
 
 	/* Update quota information if it is inconsistent */
 	{ PR_6_UPDATE_QUOTAS,
 	  N_("Update quota info for quota type %N"),
 	  PROMPT_NULL, PR_PREEN_OK, 0, 0, 0 },
 
 	/* Error setting block group checksum info */
 	{ PR_6_SET_BG_CHECKSUM,
 	  /* xgettext:no-c-format */
 	  N_("Error setting @b @g checksum info: %m\n"),
 	  PROMPT_NULL, PR_FATAL, 0, 0, 0 },
 
 	/* Error writing file system info */
 	{ PR_6_FLUSH_FILESYSTEM,
 	  /* xgettext:no-c-format */
 	  N_("Error writing file system info: %m\n"),
 	  PROMPT_NULL, PR_FATAL, 0, 0, 0 },
 
 	/* Error flushing writes to storage device */
 	{ PR_6_IO_FLUSH,
 	  /* xgettext:no-c-format */
 	  N_("Error flushing writes to storage device: %m\n"),
 	  PROMPT_NULL, PR_FATAL, 0, 0, 0 },
 
 	/* Error writing quota information */
 	{ PR_6_WRITE_QUOTAS,
 	  N_("Error writing quota info for quota type %N: %m\n"),
 	  PROMPT_NULL, 0, 0, 0, 0 },
 
 	/* Orphan file without a journal */
 	{ PR_6_ORPHAN_FILE_WITHOUT_JOURNAL,
 	  N_("@S has orphan file without @j.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK },
 
 	/* Orphan file truncation failed */
 	{ PR_6_ORPHAN_FILE_TRUNC_FAILED,
 	  N_("Failed to truncate orphan file.\n"),
 	  PROMPT_NONE, 0 },
 
 	/* Failed to initialize orphan file */
 	{ PR_6_ORPHAN_FILE_CORRUPTED,
 	  N_("Failed to initialize orphan file.\n"),
 	  PROMPT_RECREATE, PR_PREEN_OK },
 
 	/* Cannot fix corrupted orphan file with invalid bitmaps */
 	{ PR_6_ORPHAN_FILE_BITMAP_INVALID,
 	  N_("Cannot fix corrupted orphan file with invalid bitmaps.\n"),
 	  PROMPT_NONE, 0 },
 
 	/* Orphan file creation failed */
 	{ PR_6_ORPHAN_FILE_CREATE_FAILED,
 	  N_("Failed to truncate orphan file (@i %i).\n"),
 	  PROMPT_NONE, 0 },
 
 	/* Orphan file block contains data */
 	{ PR_6_ORPHAN_BLOCK_DIRTY,
 	  N_("Orphan file (@i %i) @b %b is not clean.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK },
 
 	/* orphan_present set but orphan file is empty */
 	{ PR_6_ORPHAN_PRESENT_CLEAN_FILE,
 	  N_("Feature orphan_present is set but orphan file is clean.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK },
 
 	/* orphan_present set but orphan_file is not */
 	{ PR_6_ORPHAN_PRESENT_NO_FILE,
 	  N_("Feature orphan_present is set but feature orphan_file is not.\n"),
 	  PROMPT_CLEAR, PR_PREEN_OK },
 
 	/* Orphan file size isn't multiple of blocks size */
 	{ PR_6_ORPHAN_FILE_WRONG_SIZE,
 	  N_("Orphan file (@i %i) size is not multiple of block size.\n"),
 	  PROMPT_NONE, 0 },
 
 	/* Orphan file contains holes */
 	{ PR_6_ORPHAN_FILE_HOLE,
 	  N_("Orphan file (@i %i) contains hole at @b %b.\n"),
 	  PROMPT_NONE, 0 },
 
 	{ 0 }
 };
 
 /*
  * This is the latch flags register.  It allows several problems to be
  * "latched" together.  This means that the user has to answer but one
  * question for the set of problems, and all of the associated
  * problems will be either fixed or not fixed.
  */
@@ -2390,14 +2396,16 @@ static struct latch_descr *find_latch(int code)
 int end_problem_latch(e2fsck_t ctx, int mask)
 {
 	struct latch_descr *ldesc;
 	struct problem_context pctx;
 	int answer = -1;
 
 	ldesc = find_latch(mask);
+	if (!ldesc)
+		return answer;
 	if (ldesc->end_message && (ldesc->flags & PRL_LATCHED)) {
 		clear_problem_context(&pctx);
 		answer = fix_problem(ctx, ldesc->end_message, &pctx);
 	}
 	ldesc->flags &= ~(PRL_VARIABLE);
 	return answer;
 }
@@ -2488,174 +2496,174 @@ static void print_problem(FILE *f, problem_t code, int answer, int fixed,
 int fix_problem(e2fsck_t ctx, problem_t code, struct problem_context *pctx)
 {
 	ext2_filsys fs = ctx->fs;
 	struct e2fsck_problem *ptr;
 	struct latch_descr *ldesc = 0;
 	const char *message;
 	int		def_yn, answer, ans;
 	int		print_answer = 0;
 	int		suppress = 0;
 	int		fixed = 0;
 
 	ptr = find_problem(code);
 	if (!ptr) {
 		printf(_("Unhandled error code (0x%x)!\n"), code);
 		return 0;
 	}
 	if (!(ptr->flags & PR_CONFIG)) {
 		char	key[9], *new_desc = NULL;
 
 		sprintf(key, "0x%06x", code);
 
 		profile_get_string(ctx->profile, "problems", key,
 				   "description", 0, &new_desc);
 		if (new_desc)
 			ptr->e2p_description = new_desc;
 
 		reconfigure_bool(ctx, ptr, key, PR_PREEN_OK, "preen_ok");
 		reconfigure_bool(ctx, ptr, key, PR_NO_OK, "no_ok");
 		reconfigure_bool(ctx, ptr, key, PR_NO_DEFAULT, "no_default");
 		reconfigure_bool(ctx, ptr, key, PR_MSG_ONLY, "print_message_only");
 		reconfigure_bool(ctx, ptr, key, PR_PREEN_NOMSG, "preen_nomessage");
 		reconfigure_bool(ctx, ptr, key, PR_NOCOLLATE, "no_collate");
 		reconfigure_bool(ctx, ptr, key, PR_NO_NOMSG, "no_nomsg");
 		reconfigure_bool(ctx, ptr, key, PR_PREEN_NOHDR, "preen_noheader");
 		reconfigure_bool(ctx, ptr, key, PR_FORCE_NO, "force_no");
 		reconfigure_bool(ctx, ptr, key, PR_NOT_A_FIX, "not_a_fix");
 		profile_get_integer(ctx->profile, "options",
 				    "max_count_problems", 0, 0,
 				    &ptr->max_count);
 		profile_get_integer(ctx->profile, "problems", key, "max_count",
 				    ptr->max_count, &ptr->max_count);
 
 		ptr->flags |= PR_CONFIG;
 	}
 	def_yn = 1;
 	ptr->count++;
 	if ((ptr->flags & PR_NO_DEFAULT) ||
 	    ((ptr->flags & PR_PREEN_NO) && (ctx->options & E2F_OPT_PREEN)) ||
 	    (ctx->options & E2F_OPT_NO))
 		def_yn= 0;
 
 	/*
 	 * Do special latch processing.  This is where we ask the
 	 * latch question, if it exists
 	 */
-	if (ptr->flags & PR_LATCH_MASK) {
-		ldesc = find_latch(ptr->flags & PR_LATCH_MASK);
+	if (ptr->flags & PR_LATCH_MASK &&
+	    (ldesc = find_latch(ptr->flags & PR_LATCH_MASK)) != NULL) {
 		if (ldesc->question && !(ldesc->flags & PRL_LATCHED)) {
 			ans = fix_problem(ctx, ldesc->question, pctx);
 			if (ans == 1)
 				ldesc->flags |= PRL_YES;
 			if (ans == 0)
 				ldesc->flags |= PRL_NO;
 			ldesc->flags |= PRL_LATCHED;
 		}
 		if (ldesc->flags & PRL_SUPPRESS)
 			suppress++;
 	}
 	if ((ptr->flags & PR_PREEN_NOMSG) &&
 	    (ctx->options & E2F_OPT_PREEN))
 		suppress++;
 	if ((ptr->flags & PR_NO_NOMSG) &&
 	    ((ctx->options & E2F_OPT_NO) || (ptr->flags & PR_FORCE_NO)))
 		suppress++;
 	if (ptr->max_count && (ptr->count > ptr->max_count)) {
 		if (ctx->options & (E2F_OPT_NO | E2F_OPT_YES))
 			suppress++;
 		if ((ctx->options & E2F_OPT_PREEN) &&
 		    (ptr->flags & PR_PREEN_OK))
 			suppress++;
 		if ((ptr->flags & PR_LATCH_MASK) &&
 		    (ldesc->flags & (PRL_YES | PRL_NO)))
 			suppress++;
 		if (ptr->count == ptr->max_count + 1) {
 			if (ctx->problem_logf)
 				fprintf(ctx->problem_logf,
 					"<suppressed code=\"0x%06x\"/>\n",
 					code);
 			printf("...problem 0x%06x suppressed\n",
 			       ptr->e2p_code);
 			fflush(stdout);
 		}
 	}
 	message = ptr->e2p_description;
 	if (*message)
 		message = _(message);
 	if (!suppress) {
 		if ((ctx->options & E2F_OPT_PREEN) &&
 		    !(ptr->flags & PR_PREEN_NOHDR)) {
 			printf("%s: ", ctx->device_name ?
 			       ctx->device_name : ctx->filesystem_name);
 		}
 		if (*message)
 			print_e2fsck_message(stdout, ctx, message, pctx, 1, 0);
 	}
 	if (ctx->logf && message)
 		print_e2fsck_message(ctx->logf, ctx, message, pctx, 1, 0);
 	if (!(ptr->flags & PR_PREEN_OK) && (ptr->prompt != PROMPT_NONE))
 		preenhalt(ctx);
 
 	if (ptr->flags & PR_FATAL)
 		fatal_error(ctx, 0);
 
 	if (ptr->prompt == PROMPT_NONE) {
 		if (ptr->flags & PR_NOCOLLATE)
 			answer = -1;
 		else
 			answer = def_yn;
 	} else {
 		if (ptr->flags & PR_FORCE_NO) {
 			answer = 0;
 			print_answer = 1;
 		} else if (ctx->options & E2F_OPT_PREEN) {
 			answer = def_yn;
 			if (!(ptr->flags & PR_PREEN_NOMSG))
 				print_answer = 1;
 		} else if ((ptr->flags & PR_LATCH_MASK) &&
 			   (ldesc->flags & (PRL_YES | PRL_NO))) {
 			print_answer = 1;
 			if (ldesc->flags & PRL_YES)
 				answer = 1;
 			else
 				answer = 0;
 		} else
 			answer = ask(ctx, (ptr->prompt == PROMPT_NULL) ? "" :
 				     _(prompt[(int) ptr->prompt]), def_yn);
 		if (!answer && !(ptr->flags & PR_NO_OK))
 			ext2fs_unmark_valid(fs);
 
 		if (print_answer) {
 			if (!suppress)
 				printf("%s.\n", answer ?
 				       _(preen_msg[(int) ptr->prompt]) :
 				       _("IGNORED"));
 			if (ctx->logf)
 				fprintf(ctx->logf, "%s.\n", answer ?
 					_(preen_msg[(int) ptr->prompt]) :
 					_("IGNORED"));
 		}
 	}
 
 	if ((ptr->prompt == PROMPT_ABORT) && answer)
 		fatal_error(ctx, 0);
 
 	if (ptr->flags & PR_AFTER_CODE)
 		answer = fix_problem(ctx, ptr->second_code, pctx);
 
 	if (answer && (ptr->prompt != PROMPT_NONE) &&
 	    !(ptr->flags & PR_NOT_A_FIX)) {
 		fixed = 1;
 		ctx->flags |= E2F_FLAG_PROBLEMS_FIXED;
 	}
 
 	if (ctx->problem_logf)
 		print_problem(ctx->problem_logf, code, answer, fixed,
 			      ptr, pctx);
 
 	return answer;
 }
 
 #ifdef UNITTEST
 
 #include <stdlib.h>
 #include <stdio.h>
diff --git a/e2fsck/problem.h b/e2fsck/problem.h
index 530aea69..b47b0c63 100644
--- a/e2fsck/problem.h
+++ b/e2fsck/problem.h
@@ -14,1332 +14,1335 @@ typedef __u32 problem_t;
 struct problem_context {
 	errcode_t	errcode;
 	ext2_ino_t ino, ino2, dir;
 	struct ext2_inode *inode;
 	struct ext2_dir_entry *dirent;
 	blk64_t	blk, blk2;
 	e2_blkcnt_t	blkcount;
 	dgrp_t		group;
 	__u32		csum1, csum2;
 	__u64		num, num2;
 	const char *str;
 };
 
 /*
  * We define a set of "latch groups"; these are problems which are
  * handled as a set.  The user answers once for a particular latch
  * group.
  */
 #define PR_LATCH_MASK	0x0ff0  /* Latch mask */
 #define PR_LATCH_BLOCK	0x0010	/* Latch for illegal blocks (pass 1) */
 #define PR_LATCH_BBLOCK	0x0020	/* Latch for bad block inode blocks (pass 1) */
 #define PR_LATCH_IBITMAP 0x0030 /* Latch for pass 5 inode bitmap proc. */
 #define PR_LATCH_BBITMAP 0x0040 /* Latch for pass 5 inode bitmap proc. */
 #define PR_LATCH_RELOC	0x0050  /* Latch for superblock relocate hint */
 #define PR_LATCH_DBLOCK	0x0060	/* Latch for pass 1b dup block headers */
 #define PR_LATCH_LOW_DTIME 0x0070 /* Latch for pass1 orphaned list refugees */
 #define PR_LATCH_TOOBIG	0x0080	/* Latch for file to big errors */
 #define PR_LATCH_OPTIMIZE_DIR 0x0090 /* Latch for optimize directories */
 #define PR_LATCH_BG_CHECKSUM 0x00A0  /* Latch for block group checksums */
 #define PR_LATCH_OPTIMIZE_EXT 0x00B0  /* Latch for rebuild extents */
 
 #define PR_LATCH(x)	((((x) & PR_LATCH_MASK) >> 4) - 1)
 
 /*
  * Latch group descriptor flags
  */
 #define PRL_YES		0x0001	/* Answer yes */
 #define PRL_NO		0x0002	/* Answer no */
 #define PRL_LATCHED	0x0004	/* The latch group is latched */
 #define PRL_SUPPRESS	0x0008	/* Suppress all latch group questions */
 
 #define PRL_VARIABLE	0x000f	/* All the flags that need to be reset */
 
 /*
  * Pre-Pass 1 errors
  */
 
 /* Block bitmap for group gggg is not in group */
 #define PR_0_BB_NOT_GROUP			0x000001
 
 /* Inode bitmap for group gggg is not in group */
 #define PR_0_IB_NOT_GROUP			0x000002
 
 /* Inode table for group gggg is not in group.  (block nnnn) */
 #define PR_0_ITABLE_NOT_GROUP			0x000003
 
 /* Superblock corrupt */
 #define PR_0_SB_CORRUPT				0x000004
 
 /* Filesystem size is wrong */
 #define PR_0_FS_SIZE_WRONG			0x000005
 
 /* Fragments not supported */
 #define PR_0_NO_FRAGMENTS			0x000006
 
 /* Superblock blocks_per_group = bbbb, should have been cccc */
 #define PR_0_BLOCKS_PER_GROUP			0x000007
 
 /* Superblock first_data_block = bbbb, should have been cccc */
 #define PR_0_FIRST_DATA_BLOCK			0x000008
 
 /* Filesystem did not have a UUID; generating one */
 #define PR_0_ADD_UUID				0x000009
 
 /* Relocate hint */
 #define PR_0_RELOCATE_HINT			0x00000A
 
 /* Miscellaneous superblock corruption */
 #define PR_0_MISC_CORRUPT_SUPER			0x00000B
 
 /* Error determining physical device size of filesystem */
 #define PR_0_GETSIZE_ERROR			0x00000C
 
 /* Inode count in the superblock incorrect */
 #define PR_0_INODE_COUNT_WRONG			0x00000D
 
 /* The Hurd does not support the filetype feature */
 #define PR_0_HURD_CLEAR_FILETYPE		0x00000E
 
 /* Superblock has an invalid journal (inode inum) */
 #define PR_0_JOURNAL_BAD_INODE			0x00000F
 
 /* External journal has multiple filesystem users (unsupported) */
 #define PR_0_JOURNAL_UNSUPP_MULTIFS		0x000010
 
 /* Can't find external journal */
 #define PR_0_CANT_FIND_JOURNAL			0x000011
 
 /* External journal has bad superblock */
 #define PR_0_EXT_JOURNAL_BAD_SUPER		0x000012
 
 /* Superblock has a bad journal UUID */
 #define PR_0_JOURNAL_BAD_UUID			0x000013
 
 /* Filesystem journal superblock is an unknown type */
 #define PR_0_JOURNAL_UNSUPP_SUPER		0x000014
 
 /* Journal superblock is corrupt */
 #define PR_0_JOURNAL_BAD_SUPER			0x000015
 
 /* Superblock has_journal flag is clear but has a journal */
 #define PR_0_JOURNAL_HAS_JOURNAL		0x000016
 
 /* Superblock needs_recovery flag is set but no journal is present */
 #define PR_0_JOURNAL_RECOVER_SET		0x000017
 
 /* Journal has data, but recovery flag is clear */
 #define PR_0_JOURNAL_RECOVERY_CLEAR		0x000018
 
 /* Ask if we should clear the journal */
 #define PR_0_JOURNAL_RESET_JOURNAL		0x000019
 
 /* Filesystem revision is 0, but feature flags are set */
 #define PR_0_FS_REV_LEVEL			0x00001A
 
 /* Clearing orphan inode */
 #define PR_0_ORPHAN_CLEAR_INODE			0x000020
 
 /* Illegal block found in orphaned inode */
 #define PR_0_ORPHAN_ILLEGAL_BLOCK_NUM		0x000021
 
 /* Already cleared block found in orphaned inode */
 #define PR_0_ORPHAN_ALREADY_CLEARED_BLOCK	0x000022
 
 /* Illegal orphan inode in superblock */
 #define PR_0_ORPHAN_ILLEGAL_HEAD_INODE		0x000023
 
 /* Illegal inode in orphaned inode list */
 #define PR_0_ORPHAN_ILLEGAL_INODE		0x000024
 
 /* Journal has unsupported read-only feature - abort */
 #define PR_0_JOURNAL_UNSUPP_ROCOMPAT		0x000025
 
 /* Journal has unsupported incompatible feature - abort */
 #define PR_0_JOURNAL_UNSUPP_INCOMPAT		0x000026
 
 /* Journal version not supported by this e2fsck */
 #define PR_0_JOURNAL_UNSUPP_VERSION		0x000027
 
 /* Moving journal from /file to hidden inode */
 #define	PR_0_MOVE_JOURNAL			0x000028
 
 /* Error moving journal to hidden file */
 #define	PR_0_ERR_MOVE_JOURNAL			0x000029
 
 /* Found invalid V2 journal superblock fields */
 #define PR_0_CLEAR_V2_JOURNAL			0x00002A
 
 /* Run journal anyway */
 #define PR_0_JOURNAL_RUN			0x00002B
 
 /* Run journal anyway by default */
 #define PR_0_JOURNAL_RUN_DEFAULT		0x00002C
 
 /* Backing up journal inode block information */
 #define PR_0_BACKUP_JNL				0x00002D
 
 /* Filesystem does not have resize_inode enabled, but
  * s_reserved_gdt_blocks is nnnn; should be zero */
 #define PR_0_NONZERO_RESERVED_GDT_BLOCKS	0x00002E
 
 /* Resize_inode not enabled, but the resize inode is non-zero */
 #define PR_0_CLEAR_RESIZE_INODE			0x00002F
 
 /* Resize inode not valid */
 #define PR_0_RESIZE_INODE_INVALID		0x000030
 
 /* Superblock last mount time is in the future */
 #define PR_0_FUTURE_SB_LAST_MOUNT		0x000031
 
 /* Superblock last write time is in the future */
 #define PR_0_FUTURE_SB_LAST_WRITE		0x000032
 
 /* Superblock hint for external superblock should be xxxx */
 #define PR_0_EXTERNAL_JOURNAL_HINT		0x000033
 
 /* Adding dirhash hint to filesystem */
 #define PR_0_DIRHASH_HINT			0x000034
 
 /* group descriptor N checksum is invalid, should be yyyy. */
 #define PR_0_GDT_CSUM				0x000035
 
 /* Group descriptor N marked uninitialized without feature set. */
 #define PR_0_GDT_UNINIT				0x000036
 
 /* Block bitmap is not initialised and Inode bitmap is -- NO LONGER USED */
 /* #define PR_0_BB_UNINIT_IB_INIT			0x000037 */
 
 /* Group descriptor N has invalid unused inodes count. */
 #define PR_0_GDT_ITABLE_UNUSED			0x000038
 
 /* Last group block bitmap is uninitialized. */
 #define PR_0_BB_UNINIT_LAST			0x000039
 
 /* Journal transaction was corrupt, replay was aborted */
 #define PR_0_JNL_TXN_CORRUPT			0x00003A
 
 /* The test_fs filesystem flag is set and ext4 is available */
 #define PR_0_CLEAR_TESTFS_FLAG			0x00003B
 
 /* Last mount time is in the future (fudged) */
 #define PR_0_FUTURE_SB_LAST_MOUNT_FUDGED	0x00003C
 
 /* Last write time is in the future (fudged) */
 #define PR_0_FUTURE_SB_LAST_WRITE_FUDGED	0x00003D
 
 /* One or more block group descriptor checksums are invalid (latch) */
 #define PR_0_GDT_CSUM_LATCH			0x00003E
 
 /* Setting free inodes count to right (was wrong) */
 #define PR_0_FREE_INODE_COUNT			0x00003F
 
 /* Setting free blocks count to right (was wrong) */
 #define PR_0_FREE_BLOCK_COUNT			0x000040
 
 /* Making quota inode hidden */
 #define	PR_0_HIDE_QUOTA				0x000041
 
 /* Superblock has invalid MMP block. */
 #define PR_0_MMP_INVALID_BLK			0x000042
 
 /* Superblock has invalid MMP magic. */
 #define PR_0_MMP_INVALID_MAGIC			0x000043
 
 /* Opening file system failed */
 #define PR_0_OPEN_FAILED			0x000044
 
 /* Checking group descriptor failed */
 #define PR_0_CHECK_DESC_FAILED			0x000045
 
 /* Superblock metadata_csum supersedes uninit_bg; both feature
  * bits cannot be set simultaneously. */
 #define PR_0_META_AND_GDT_CSUM_SET		0x000046
 
 /* Superblock MMP block checksum does not match MMP block. */
 #define PR_0_MMP_CSUM_INVALID			0x000047
 
 /* Superblock 64bit filesystem needs extents to access the whole disk */
 #define PR_0_64BIT_WITHOUT_EXTENTS		0x000048
 
 /* The first_meta_bg is too big */
 #define PR_0_FIRST_META_BG_TOO_BIG		0x000049
 
 /* External journal superblock checksum does not match superblock */
 #define PR_0_EXT_JOURNAL_SUPER_CSUM_INVALID	0x00004A
 
 /* metadata_csum_seed means nothing without metadata_csum */
 #define PR_0_CSUM_SEED_WITHOUT_META_CSUM	0x00004B
 
 /* Error initializing quota context */
 #define PR_0_QUOTA_INIT_CTX			0x00004C
 
 /* Bad required extra isize in superblock */
 #define PR_0_BAD_MIN_EXTRA_ISIZE		0x00004D
 
 /* Bad desired extra isize in superblock */
 #define PR_0_BAD_WANT_EXTRA_ISIZE		0x00004E
 
 /* Invalid quota inode number */
 #define PR_0_INVALID_QUOTA_INO			0x00004F
 
 /* Inode count in the superblock incorrect */
 #define PR_0_INODE_COUNT_BIG			0x000050
 
 /* Meta_bg and resize_inode are not compatible, remove resize_inode*/
 #define PR_0_DISABLE_RESIZE_INODE		0x000051
 
 /* Orphan file contains holes */
 #define PR_0_ORPHAN_FILE_HOLE			0x000052
 
 /* Orphan file block has wrong magic */
 #define PR_0_ORPHAN_FILE_BAD_MAGIC		0x000053
 
 /* Orphan file block has wrong checksum */
 #define PR_0_ORPHAN_FILE_BAD_CHECKSUM		0x000054
 
 /* Orphan file size isn't multiple of blocks size */
 #define PR_0_ORPHAN_FILE_WRONG_SIZE		0x000055
 
 /*
  * Pass 1 errors
  */
 
 /* Pass 1: Checking inodes, blocks, and sizes */
 #define PR_1_PASS_HEADER			0x010000
 
 /* Root inode is not a directory */
 #define PR_1_ROOT_NO_DIR			0x010001
 
 /* Root inode has dtime set */
 #define PR_1_ROOT_DTIME				0x010002
 
 /* Reserved inode has bad mode */
 #define PR_1_RESERVED_BAD_MODE			0x010003
 
 /* Deleted inode inum has zero dtime */
 #define PR_1_ZERO_DTIME				0x010004
 
 /* Inode inum is in use, but has dtime set */
 #define PR_1_SET_DTIME				0x010005
 
 /* Inode inum is a zero-length directory */
 #define PR_1_ZERO_LENGTH_DIR			0x010006
 
 /* Group block bitmap at block conflicts with some other fs block */
 #define PR_1_BB_CONFLICT			0x010007
 
 /* Group inode bitmap at block conflicts with some other fs block */
 #define PR_1_IB_CONFLICT			0x010008
 
 /* Group inode table at block conflicts with some other fs block */
 #define PR_1_ITABLE_CONFLICT			0x010009
 
 /* Group block bitmap (block) is bad */
 #define PR_1_BB_BAD_BLOCK			0x01000A
 
 /* Group inode bitmap (block) is bad */
 #define PR_1_IB_BAD_BLOCK			0x01000B
 
 /* Inode i_size is small, should be larger */
 #define PR_1_BAD_I_SIZE				0x01000C
 
 /* Inode i_blocks is small, should be larger */
 #define PR_1_BAD_I_BLOCKS			0x01000D
 
 /* Illegal block number in inode */
 #define PR_1_ILLEGAL_BLOCK_NUM			0x01000E
 
 /* Block number overlaps filesystem metadata in inode */
 #define PR_1_BLOCK_OVERLAPS_METADATA		0x01000F
 
 /* Inode has illegal blocks (latch question) */
 #define PR_1_INODE_BLOCK_LATCH			0x010010
 
 /* Too many illegal blocks in inode */
 #define	PR_1_TOO_MANY_BAD_BLOCKS		0x010011
 
 /* Illegal block number in bad block inode */
 #define PR_1_BB_ILLEGAL_BLOCK_NUM		0x010012
 
 /* Bad block inode has illegal blocks (latch question) */
 #define PR_1_INODE_BBLOCK_LATCH			0x010013
 
 /* Duplicate or bad blocks in use! */
 #define PR_1_DUP_BLOCKS_PREENSTOP		0x010014
 
 /* Bad block number used as bad block inode indirect block */
 #define PR_1_BBINODE_BAD_METABLOCK		0x010015
 
 /* Inconsistency can't be fixed prompt */
 #define PR_1_BBINODE_BAD_METABLOCK_PROMPT	0x010016
 
 /* Bad primary block */
 #define PR_1_BAD_PRIMARY_BLOCK			0x010017
 
 /* Bad primary block prompt */
 #define PR_1_BAD_PRIMARY_BLOCK_PROMPT		0x010018
 
 /* The primary superblock block is on the bad block list */
 #define PR_1_BAD_PRIMARY_SUPERBLOCK		0x010019
 
 /* Bad primary block group descriptors */
 #define PR_1_BAD_PRIMARY_GROUP_DESCRIPTOR	0x01001A
 
 /* Warning: Group number's superblock (block) is bad */
 #define PR_1_BAD_SUPERBLOCK			0x01001B
 
 /* Warning: Group number's copy of the group descriptors has a bad block */
 #define PR_1_BAD_GROUP_DESCRIPTORS		0x01001C
 
 /* Block number claimed for no reason in process_bad_blocks */
 #define PR_1_PROGERR_CLAIMED_BLOCK		0x01001D
 
 /* Allocating number contiguous block(s) in block group number */
 #define PR_1_RELOC_BLOCK_ALLOCATE		0x01001E
 
 /* Allocating block buffer for relocating process */
 #define PR_1_RELOC_MEMORY_ALLOCATE		0x01001F
 
 /* Relocating group number's information from X to Y */
 #define PR_1_RELOC_FROM_TO			0x010020
 
 /* Relocating group number's information to X */
 #define PR_1_RELOC_TO				0x010021
 
 /* Warning: could not read block number of relocation process */
 #define PR_1_RELOC_READ_ERR			0x010022
 
 /* Warning: could not write block number of relocation process */
 #define PR_1_RELOC_WRITE_ERR			0x010023
 
 /* Error allocating inode bitmap */
 #define PR_1_ALLOCATE_IBITMAP_ERROR		0x010024
 
 /* Error allocating block bitmap */
 #define PR_1_ALLOCATE_BBITMAP_ERROR		0x010025
 
 /* Error allocating icount link information */
 #define PR_1_ALLOCATE_ICOUNT			0x010026
 
 /* Error allocating directory block array */
 #define PR_1_ALLOCATE_DBCOUNT			0x010027
 
 /* Error while scanning inodes */
 #define PR_1_ISCAN_ERROR			0x010028
 
 /* Error while iterating over blocks in inode */
 #define PR_1_BLOCK_ITERATE			0x010029
 
 /* Error storing inode count information */
 #define PR_1_ICOUNT_STORE			0x01002A
 
 /* Error storing directory block information */
 #define PR_1_ADD_DBLOCK				0x01002B
 
 /* Error reading inode (for clearing) */
 #define PR_1_READ_INODE				0x01002C
 
 /* Suppress messages prompt */
 #define PR_1_SUPPRESS_MESSAGES			0x01002D
 
 /* Imagic number has imagic flag set when fs doesn't support it */
 #define PR_1_SET_IMAGIC				0x01002F
 
 /* Immutable flag set on a device or socket inode */
 #define PR_1_SET_IMMUTABLE			0x010030
 
 /* Compression flag set on a non-compressed filesystem -- no longer used*/
 /* #define PR_1_COMPR_SET			0x010031 */
 
 /* Non-zero size on on device, fifo or socket inode */
 #define PR_1_SET_NONZSIZE			0x010032
 
 /* Filesystem has feature flag(s) set, but is a revision 0 filesystem */
 #define PR_1_FS_REV_LEVEL			0x010033
 
 /* Journal inode is not in use, but contains data */
 #define PR_1_JOURNAL_INODE_NOT_CLEAR		0x010034
 
 /* Journal is not a regular file */
 #define PR_1_JOURNAL_BAD_MODE			0x010035
 
 /* Inode that was part of the orphan list */
 #define PR_1_LOW_DTIME				0x010036
 
 /* Inodes that were part of a corrupted orphan linked list found
  * (latch question) */
 #define PR_1_ORPHAN_LIST_REFUGEES		0x010037
 
 /* Error allocating refcount structure */
 #define PR_1_ALLOCATE_REFCOUNT			0x010038
 
 /* Error reading extended attribute block */
 #define PR_1_READ_EA_BLOCK			0x010039
 
 /* Inode number has a bad extended attribute block */
 #define PR_1_BAD_EA_BLOCK			0x01003A
 
 /* Error reading Extended Attribute block while fixing refcount -- abort */
 #define PR_1_EXTATTR_READ_ABORT			0x01003B
 
 /* Extended attribute number has reference count incorrect, should be */
 #define PR_1_EXTATTR_REFCOUNT			0x01003C
 
 /* Error writing Extended Attribute block while fixing refcount */
 #define PR_1_EXTATTR_WRITE_ABORT		0x01003D
 
 /* Extended attribute block has h_blocks > 1 */
 #define PR_1_EA_MULTI_BLOCK			0x01003E
 
 /* Allocating extended attribute region allocation structure */
 #define PR_1_EA_ALLOC_REGION_ABORT		0x01003F
 
 /* Extended Attribute block number is corrupt (allocation collision) */
 #define PR_1_EA_ALLOC_COLLISION			0x010040
 
 /* Extended attribute block number is corrupt (invalid name) */
 #define PR_1_EA_BAD_NAME			0x010041
 
 /* Extended attribute block number is corrupt (invalid value) */
 #define PR_1_EA_BAD_VALUE			0x010042
 
 /* Inode number is too big (latch question) */
 #define PR_1_INODE_TOOBIG			0x010043
 
 /* Problem causes directory to be too big */
 #define PR_1_TOOBIG_DIR				0x010044
 
 /* Problem causes file to be too big */
 #define PR_1_TOOBIG_REG				0x010045
 
 /* Problem causes symlink to be too big */
 #define PR_1_TOOBIG_SYMLINK			0x010046
 
 /* Inode has INDEX_FL flag set on filesystem without htree support  */
 #define PR_1_HTREE_SET				0x010047
 
 /* Inode number has INDEX_FL flag set but is on a directory */
 #define PR_1_HTREE_NODIR			0x010048
 
 /* htree directory has an invalid root node */
 #define PR_1_HTREE_BADROOT			0x010049
 
 /* Htree directory has an unsupported hash version */
 #define PR_1_HTREE_HASHV			0x01004A
 
 /* Htree directory uses an Incompatible htree root node flag */
 #define PR_1_HTREE_INCOMPAT			0x01004B
 
 /* Htree directory has a tree depth which is too big */
 #define PR_1_HTREE_DEPTH			0x01004C
 
 /* Bad block inode has an indirect block number that conflicts with
  * filesystem metadata */
 #define PR_1_BB_FS_BLOCK			0x01004D
 
 /* Resize inode (re)creation failed */
 #define PR_1_RESIZE_INODE_CREATE		0x01004E
 
 /* inode has a extra size i_extra_isize which is invalid */
 #define PR_1_EXTRA_ISIZE			0x01004F
 
 /* Extended attribute in inode has a namelen which is invalid */
 #define PR_1_ATTR_NAME_LEN			0x010050
 
 /* Extended attribute in inode has a value offset which is invalid */
 #define PR_1_ATTR_VALUE_OFFSET			0x010051
 
 /* extended attribute in inode has a value block which is invalid */
 #define PR_1_ATTR_VALUE_BLOCK			0x010052
 
 /* extended attribute in inode has a value size which is invalid */
 #define PR_1_ATTR_VALUE_SIZE			0x010053
 
 /* extended attribute in inode has a hash which is invalid */
 #define PR_1_ATTR_HASH				0x010054
 
 /* inode is a type but it looks like it is really a directory */
 #define PR_1_TREAT_AS_DIRECTORY			0x010055
 
 /* Error while reading extent tree in inode */
 #define PR_1_READ_EXTENT			0x010056
 
 /* Failure to iterate extents in inode */
 #define PR_1_EXTENT_ITERATE_FAILURE		0x010057
 
 /* Inode has an invalid extent starting block */
 #define PR_1_EXTENT_BAD_START_BLK		0x010058
 
 /* Inode has an invalid extent that ends beyond filesystem */
 #define PR_1_EXTENT_ENDS_BEYOND			0x010059
 
 /* inode has EXTENTS_FL flag set on filesystem without extents support */
 #define PR_1_EXTENTS_SET			0x01005A
 
 /* inode is in extents format, but superblock is missing EXTENTS feature */
 #define PR_1_EXTENT_FEATURE			0x01005B
 
 /* inode missing EXTENTS_FL, but is an extent inode */
 #define PR_1_UNSET_EXTENT_FL			0x01005C
 
 /* Fast symlink has EXTENTS_FL set */
 #define PR_1_FAST_SYMLINK_EXTENT_FL		0x01005D
 
 /* Extents are out of order */
 #define PR_1_OUT_OF_ORDER_EXTENTS		0x01005E
 
 /* Extent node header invalid */
 #define PR_1_EXTENT_HEADER_INVALID		0x01005F
 
 /* PR_1_EOFBLOCKS_FL_SET 0x010060 was here */
 
 /* Failed to convert subcluster block bitmap */
 #define PR_1_CONVERT_SUBCLUSTER			0x010061
 
 /* Quota inode is not a regular file */
 #define PR_1_QUOTA_BAD_MODE			0x010062
 
 /* Quota inode is not in use, but contains data */
 #define PR_1_QUOTA_INODE_NOT_CLEAR		0x010063
 
 /* Quota inode is visible to the user */
 #define PR_1_QUOTA_INODE_NOT_HIDDEN		0x010064
 
 /* The bad block inode looks invalid */
 #define PR_1_INVALID_BAD_INODE			0x010065
 
 /* Extent has zero length extent */
 #define PR_1_EXTENT_LENGTH_ZERO			0x010066
 
 /* inode seems to contain garbage */
 #define PR_1_INODE_IS_GARBAGE			0x010067
 
 /* inode passes checks, but checksum does not match inode */
 #define PR_1_INODE_ONLY_CSUM_INVALID		0x010068
 
 /* Inode extended attribute is corrupt (allocation collision) */
 #define PR_1_INODE_EA_ALLOC_COLLISION		0x010069
 
 /* Inode extent block passes checks, but checksum does not match extent */
 #define PR_1_EXTENT_ONLY_CSUM_INVALID		0x01006A
 
 /* Inode extended attribute block passes checks, but checksum does not
  * match block. */
 #define PR_1_EA_BLOCK_ONLY_CSUM_INVALID		0x01006C
 
 /* Interior extent node level number of inode doesn't first node down */
 #define PR_1_EXTENT_INDEX_START_INVALID		0x01006D
 
 /* Inode end of extent exceeds allowed value */
 #define PR_1_EXTENT_END_OUT_OF_BOUNDS		0x01006E
 
 /* inode has INLINE_DATA_FL flag on filesystem without inline data */
 #define PR_1_INLINE_DATA_FEATURE		0x01006F
 
 /* inode has INLINE_DATA_FL flag on filesystem without inline data */
 #define PR_1_INLINE_DATA_SET			0x010070
 
 /* Inode block conflicts with critical metadata, skipping block checks */
 #define PR_1_CRITICAL_METADATA_COLLISION	0x010071
 
 /* Directory inode block <block> should be at block <otherblock> */
 #define PR_1_COLLAPSE_DBLOCK			0x010072
 
 /* Directory inode block <block> should be at block <otherblock> */
 #define PR_1_UNINIT_DBLOCK			0x010073
 
 /* Inode logical block (physical block) violates cluster allocation */
 #define PR_1_MISALIGNED_CLUSTER			0x010074
 
 /* Inode has INLINE_DATA_FL flag but extended attribute not found */
 #define PR_1_INLINE_DATA_NO_ATTR		0x010075
 
 /* Special (device/socket/fifo) file (inode num) has extents
  * or inline-data flag set */
 #define PR_1_SPECIAL_EXTENTS_IDATA		0x010076
 
 /* Inode has extent header but inline data flag is set */
 #define PR_1_CLEAR_INLINE_DATA_FOR_EXTENT	0x010077
 
 /* Inode seems to have inline data but extent flag is set */
 #define PR_1_CLEAR_EXTENT_FOR_INLINE_DATA	0x010078
 
 /* Inode seems to have block map but inline data and extent flags set */
 #define PR_1_CLEAR_EXTENT_INLINE_DATA_FLAGS	0x010079
 
 /* Inode has inline data and extent flags but i_block contains junk */
 #define PR_1_CLEAR_EXTENT_INLINE_DATA_INODE	0x01007A
 
 /* Bad block list says the bad block list inode is bad */
 #define PR_1_BADBLOCKS_IN_BADBLOCKS		0x01007B
 
 /* Error allocating extent region allocation structure */
 #define PR_1_EXTENT_ALLOC_REGION_ABORT		0x01007C
 
 /* Inode leaf has a duplicate extent mapping */
 #define PR_1_EXTENT_COLLISION			0x01007D
 
 /* Error allocating memory for encrypted inode list */
 #define PR_1_ALLOCATE_ENCRYPTED_INODE_LIST	0x01007E
 
 /* Inode extent tree could be more shallow */
 #define PR_1_EXTENT_BAD_MAX_DEPTH		0x01007F
 
 /* inode num on bigalloc filesystem cannot be block mapped */
 #define PR_1_NO_BIGALLOC_BLOCKMAP_FILES		0x010080
 
 /* Inode has corrupt extent header */
 #define PR_1_MISSING_EXTENT_HEADER		0x010081
 
 /* Timestamp(s) on inode beyond 2310-04-04 are likely pre-1970. */
 #define PR_1_EA_TIME_OUT_OF_RANGE		0x010082
 
 /* Inode has illegal EA value inode */
 #define PR_1_ATTR_VALUE_EA_INODE		0x010083
 
 /* Parent inode has invalid EA entry. EA inode does not have
  * EXT4_EA_INODE_FL flag. Delete EA entry? */
 #define PR_1_ATTR_NO_EA_INODE_FL		0x010085
 
 /* EA inode for parent inode does not have EXT4_EA_INODE_FL flag */
 #define PR_1_ATTR_SET_EA_INODE_FL		0x010086
 
 /* Offer to clear uninitialized flag on an extent */
 #define PR_1_CLEAR_UNINIT_EXTENT		0x010087
 
 /* Casefold flag set on a non-directory */
 #define PR_1_CASEFOLD_NONDIR			0x010088
 
 /* Casefold flag set, but file system is missing the casefold feature */
 #define PR_1_CASEFOLD_FEATURE			0x010089
 
 /* Inode has encrypt flag but no encryption extended attribute */
 #define PR_1_MISSING_ENCRYPTION_XATTR		0x01008A
 
 /* Encrypted inode has corrupt encryption extended attribute */
 #define PR_1_CORRUPT_ENCRYPTION_XATTR		0x01008B
 
 /* Error allocating memory for casefolded directory list */
 #define PR_1_ALLOCATE_CASEFOLDED_DIRLIST	0x01008C
 
 /* Htree directory should use SipHash but does not */
 #define PR_1_HTREE_NEEDS_SIPHASH		0x01008D
 
 /* Htree directory uses SipHash but should not */
 #define PR_1_HTREE_CANNOT_SIPHASH		0x01008E
 
 /* Orphan file inode is not a regular file */
 #define PR_1_ORPHAN_FILE_BAD_MODE		0x01008F
 
 /* Orphan file inode is not in use, but contains data */
 #define PR_1_ORPHAN_FILE_NOT_CLEAR		0x010090
 
 /*
  * Pass 1b errors
  */
 
 /* Pass 1B: Rescan for duplicate/bad blocks */
 #define PR_1B_PASS_HEADER	0x011000
 
 /* Duplicate/bad block(s) header */
 #define PR_1B_DUP_BLOCK_HEADER	0x011001
 
 /* Duplicate/bad block(s) in inode */
 #define PR_1B_DUP_BLOCK		0x011002
 
 /* Duplicate/bad block(s) end */
 #define PR_1B_DUP_BLOCK_END	0x011003
 
 /* Error while scanning inodes */
 #define PR_1B_ISCAN_ERROR	0x011004
 
 /* Error allocating inode bitmap */
 #define PR_1B_ALLOCATE_IBITMAP_ERROR 0x011005
 
 /* Error while iterating over blocks */
 #define PR_1B_BLOCK_ITERATE	0x011006
 
 /* Error adjusting EA refcount */
 #define PR_1B_ADJ_EA_REFCOUNT	0x011007
 
 /* Duplicate/bad block range in inode */
 #define PR_1B_DUP_RANGE		0x011008
 
 /* Pass 1C: Scan directories for inodes with dup blocks. */
 #define PR_1C_PASS_HEADER	0x012000
 
 
 /* Pass 1D: Reconciling duplicate blocks */
 #define PR_1D_PASS_HEADER	0x013000
 
 /* File has duplicate blocks */
 #define PR_1D_DUP_FILE		0x013001
 
 /* List of files sharing duplicate blocks */
 #define PR_1D_DUP_FILE_LIST	0x013002
 
 /* File sharing blocks with filesystem metadata  */
 #define PR_1D_SHARE_METADATA	0x013003
 
 /* Report of how many duplicate/bad inodes */
 #define PR_1D_NUM_DUP_INODES	0x013004
 
 /* Duplicated blocks already reassigned or cloned. */
 #define PR_1D_DUP_BLOCKS_DEALT	0x013005
 
 /* Clone duplicate/bad blocks? */
 #define PR_1D_CLONE_QUESTION	0x013006
 
 /* Delete file? */
 #define PR_1D_DELETE_QUESTION	0x013007
 
 /* Couldn't clone file (error) */
 #define PR_1D_CLONE_ERROR	0x013008
 
 /*
  * Pass 1e --- rebuilding extent trees
  */
 /* Pass 1e: Rebuilding extent trees */
 #define PR_1E_PASS_HEADER		0x014000
 
 /* Error rehash directory */
 #define PR_1E_OPTIMIZE_EXT_ERR		0x014001
 
 /* Rebuilding extent trees */
 #define PR_1E_OPTIMIZE_EXT_HEADER	0x014002
 
 /* Rebuilding extent %d */
 #define PR_1E_OPTIMIZE_EXT		0x014003
 
 /* Rebuilding extent tree end */
 #define PR_1E_OPTIMIZE_EXT_END		0x014004
 
 /* Internal error: extent tree depth too large */
 #define PR_1E_MAX_EXTENT_TREE_DEPTH	0x014005
 
 /* Inode extent tree could be shorter */
 #define PR_1E_CAN_COLLAPSE_EXTENT_TREE	0x014006
 
 /* Inode extent tree could be narrower */
 #define PR_1E_CAN_NARROW_EXTENT_TREE	0x014007
 
 /*
  * Pass 2 errors
  */
 
 /* Pass 2: Checking directory structure */
 #define PR_2_PASS_HEADER	0x020000
 
 /* Bad inode number for '.' */
 #define PR_2_BAD_INODE_DOT	0x020001
 
 /* Directory entry has bad inode number */
 #define PR_2_BAD_INO		0x020002
 
 /* Directory entry has deleted or unused inode */
 #define PR_2_UNUSED_INODE	0x020003
 
 /* Directory entry is link to '.' */
 #define PR_2_LINK_DOT		0x020004
 
 /* Directory entry points to inode now located in a bad block */
 #define PR_2_BB_INODE		0x020005
 
 /* Directory entry contains a link to a directory */
 #define PR_2_LINK_DIR		0x020006
 
 /* Directory entry contains a link to the root directory */
 #define PR_2_LINK_ROOT		0x020007
 
 /* Directory entry has illegal characters in its name */
 #define PR_2_BAD_NAME		0x020008
 
 /* Missing '.' in directory inode */
 #define PR_2_MISSING_DOT	0x020009
 
 /* Missing '..' in directory inode */
 #define PR_2_MISSING_DOT_DOT	0x02000A
 
 /* First entry in directory inode doesn't contain '.' */
 #define PR_2_1ST_NOT_DOT	0x02000B
 
 /* Second entry in directory inode doesn't contain '..' */
 #define PR_2_2ND_NOT_DOT_DOT	0x02000C
 
 /* i_faddr should be zero */
 #define PR_2_FADDR_ZERO		0x02000D
 
 /* i_file_acl should be zero */
 #define PR_2_FILE_ACL_ZERO	0x02000E
 
 /* i_size_high should be zero */
 #define PR_2_DIR_SIZE_HIGH_ZERO	0x02000F
 
 /* i_frag should be zero */
 #define PR_2_FRAG_ZERO		0x020010
 
 /* i_fsize should be zero */
 #define PR_2_FSIZE_ZERO		0x020011
 
 /* inode has bad mode */
 #define PR_2_BAD_MODE		0x020012
 
 /* directory corrupted */
 #define PR_2_DIR_CORRUPTED	0x020013
 
 /* filename too long */
 #define PR_2_FILENAME_LONG	0x020014
 
 /* Directory inode has a missing block (hole) */
 #define PR_2_DIRECTORY_HOLE	0x020015
 
 /* '.' is not NULL terminated */
 #define PR_2_DOT_NULL_TERM	0x020016
 
 /* '..' is not NULL terminated */
 #define PR_2_DOT_DOT_NULL_TERM	0x020017
 
 /* Illegal character device in inode */
 #define PR_2_BAD_CHAR_DEV	0x020018
 
 /* Illegal block device in inode */
 #define PR_2_BAD_BLOCK_DEV	0x020019
 
 /* Duplicate '.' entry */
 #define PR_2_DUP_DOT		0x02001A
 
 /* Duplicate '..' entry */
 #define PR_2_DUP_DOT_DOT	0x02001B
 
 /* Internal error: couldn't find dir_info */
 #define PR_2_NO_DIRINFO		0x02001C
 
 /* Final rec_len is wrong */
 #define PR_2_FINAL_RECLEN	0x02001D
 
 /* Error allocating icount structure */
 #define PR_2_ALLOCATE_ICOUNT	0x02001E
 
 /* Error iterating over directory blocks */
 #define PR_2_DBLIST_ITERATE	0x02001F
 
 /* Error reading directory block */
 #define PR_2_READ_DIRBLOCK	0x020020
 
 /* Error writing directory block */
 #define PR_2_WRITE_DIRBLOCK	0x020021
 
 /* Error allocating new directory block */
 #define PR_2_ALLOC_DIRBOCK	0x020022
 
 /* Error deallocating inode */
 #define PR_2_DEALLOC_INODE	0x020023
 
 /* Directory entry for '.' is big.  Split? */
 #define PR_2_SPLIT_DOT		0x020024
 
 /* Illegal FIFO */
 #define PR_2_BAD_FIFO		0x020025
 
 /* Illegal socket */
 #define PR_2_BAD_SOCKET		0x020026
 
 /* Directory filetype not set */
 #define PR_2_SET_FILETYPE	0x020027
 
 /* Directory filetype incorrect */
 #define PR_2_BAD_FILETYPE	0x020028
 
 /* Directory filetype set when it shouldn't be */
 #define PR_2_CLEAR_FILETYPE	0x020029
 
 /* Directory filename can't be zero-length  */
 #define PR_2_NULL_NAME		0x020030
 
 /* Invalid symlink */
 #define PR_2_INVALID_SYMLINK	0x020031
 
 /* i_file_acl (extended attribute) is bad */
 #define PR_2_FILE_ACL_BAD	0x020032
 
 /* Filesystem contains large files, but has no such flag in sb */
 #define PR_2_FEATURE_LARGE_FILES 0x020033
 
 /* Node in HTREE directory not referenced */
 #define PR_2_HTREE_NOTREF	0x020034
 
 /* Node in HTREE directory referenced twice */
 #define PR_2_HTREE_DUPREF	0x020035
 
 /* Node in HTREE directory has bad min hash */
 #define PR_2_HTREE_MIN_HASH	0x020036
 
 /* Node in HTREE directory has bad max hash */
 #define PR_2_HTREE_MAX_HASH	0x020037
 
 /* Clear invalid HTREE directory */
 #define PR_2_HTREE_CLEAR	0x020038
 
 /* Filesystem has large directories, but has no such flag in superblock */
 #define PR_2_FEATURE_LARGE_DIRS	0x020039
 
 /* Bad block in htree interior node */
 #define PR_2_HTREE_BADBLK	0x02003A
 
 /* Error adjusting EA refcount */
 #define PR_2_ADJ_EA_REFCOUNT	0x02003B
 
 /* Invalid HTREE root node */
 #define PR_2_HTREE_BAD_ROOT	0x02003C
 
 /* Invalid HTREE limit */
 #define PR_2_HTREE_BAD_LIMIT	0x02003D
 
 /* Invalid HTREE count */
 #define PR_2_HTREE_BAD_COUNT	0x02003E
 
 /* HTREE interior node has out-of-order hashes in table */
 #define PR_2_HTREE_HASH_ORDER	0x02003F
 
 /* Node in HTREE directory has bad depth */
 #define PR_2_HTREE_BAD_DEPTH	0x020040
 
 /* Duplicate directory entry found */
 #define PR_2_DUPLICATE_DIRENT	0x020041
 
 /* Non-unique filename found */
 #define PR_2_NON_UNIQUE_FILE	0x020042
 
 /* Duplicate directory entry found */
 #define PR_2_REPORT_DUP_DIRENT	0x020043
 
 /* i_blocks_hi should be zero */
 #define PR_2_BLOCKS_HI_ZERO	0x020044
 
 /* Unexpected HTREE block */
 #define PR_2_UNEXPECTED_HTREE_BLOCK	0x020045
 
 /* Inode found in group where _INODE_UNINIT is set */
 #define PR_2_INOREF_BG_INO_UNINIT	0x020046
 
 /* Inode found in group unused inodes area */
 #define PR_2_INOREF_IN_UNUSED		0x020047
 
 /* i_file_acl_hi should be zero */
 #define PR_2_I_FILE_ACL_HI_ZERO		0x020048
 
 /* htree root node fails checksum */
 #define PR_2_HTREE_ROOT_CSUM_INVALID	0x020049
 
 /* htree node fails checksum */
 #define PR_2_HTREE_NODE_CSUM_INVALID	0x02004A
 
 /* no space in leaf for checksum */
 #define PR_2_LEAF_NODE_MISSING_CSUM	0x02004C
 
 /* dir leaf node passes checks, but fails checksum */
 #define PR_2_LEAF_NODE_ONLY_CSUM_INVALID	0x02004D
 
 /* bad inline directory size */
 #define PR_2_BAD_INLINE_DIR_SIZE	0x02004E
 
 /* fixing inline dir size failed */
 #define PR_2_FIX_INLINE_DIR_FAILED	0x02004F
 
 /* Encrypted directory entry is too short */
 #define PR_2_BAD_ENCRYPTED_NAME		0x020050
 
 /* Encrypted directory contains unencrypted file */
 #define PR_2_UNENCRYPTED_FILE		0x020051
 
 /* Encrypted directory contains file with different encryption policy */
 #define PR_2_INCONSISTENT_ENCRYPTION_POLICY	0x020052
 
 /* Encoded directory entry has illegal characters in its name */
 #define PR_2_BAD_ENCODED_NAME		0x020053
 
 /* Non-unique filename found, but can't rename */
 #define PR_2_NON_UNIQUE_FILE_NO_RENAME	0x020054
 
 /*
  * Pass 3 errors
  */
 
 /* Pass 3: Checking directory connectivity */
 #define PR_3_PASS_HEADER		0x030000
 
 /* Root inode not allocated */
 #define PR_3_NO_ROOT_INODE		0x030001
 
 /* No room in lost+found */
 #define PR_3_EXPAND_LF_DIR		0x030002
 
 /* Unconnected directory inode */
 #define PR_3_UNCONNECTED_DIR		0x030003
 
 /* /lost+found not found */
 #define PR_3_NO_LF_DIR			0x030004
 
 /* .. entry is incorrect */
 #define PR_3_BAD_DOT_DOT		0x030005
 
 /* Bad or non-existent /lost+found.  Cannot reconnect */
 #define PR_3_NO_LPF			0x030006
 
 /* Could not expand /lost+found */
 #define PR_3_CANT_EXPAND_LPF		0x030007
 
 /* Could not reconnect inode */
 #define PR_3_CANT_RECONNECT		0x030008
 
 /* Error while trying to find /lost+found */
 #define PR_3_ERR_FIND_LPF		0x030009
 
 /* Error in ext2fs_new_block while creating /lost+found */
 #define PR_3_ERR_LPF_NEW_BLOCK		0x03000A
 
 /* Error in ext2fs_new_inode while creating /lost+found */
 #define PR_3_ERR_LPF_NEW_INODE		0x03000B
 
 /* Error in ext2fs_new_dir_block while creating /lost+found */
 #define PR_3_ERR_LPF_NEW_DIR_BLOCK	0x03000C
 
 /* Error while writing directory block for /lost+found */
 #define PR_3_ERR_LPF_WRITE_BLOCK	0x03000D
 
 /* Error while adjusting inode count */
 #define PR_3_ADJUST_INODE		0x03000E
 
 /* Couldn't fix parent directory -- error */
 #define PR_3_FIX_PARENT_ERR		0x03000F
 
 /* Couldn't fix parent directory -- couldn't find it */
 #define PR_3_FIX_PARENT_NOFIND		0x030010
 
 /* Error allocating inode bitmap */
 #define PR_3_ALLOCATE_IBITMAP_ERROR	0x030011
 
 /* Error creating root directory */
 #define PR_3_CREATE_ROOT_ERROR		0x030012
 
 /* Error creating lost and found directory */
 #define PR_3_CREATE_LPF_ERROR		0x030013
 
 /* Root inode is not directory; aborting */
 #define PR_3_ROOT_NOT_DIR_ABORT		0x030014
 
 /* Cannot proceed without a root inode. */
 #define PR_3_NO_ROOT_INODE_ABORT	0x030015
 
 /* Internal error: couldn't find dir_info */
 #define PR_3_NO_DIRINFO			0x030016
 
 /* Lost+found is not a directory */
 #define PR_3_LPF_NOTDIR			0x030017
 
 /* Lost+found has inline data */
 #define PR_3_LPF_INLINE_DATA		0x030018
 
 /* Cannot allocate lost+found */
 #define PR_3_LPF_NO_SPACE		0x030019
 
 /* Insufficient space to recover lost files */
 #define PR_3_NO_SPACE_TO_RECOVER	0x03001A
 
 /* Lost+found is encrypted */
 #define PR_3_LPF_ENCRYPTED		0x03001B
 
+/* Recursively looped directory inode */
+#define PR_3_LOOPED_DIR			0x03001D
+
 /*
  * Pass 3a --- rehashing directories
  */
 /* Pass 3a: Reindexing directories */
 #define PR_3A_PASS_HEADER		0x031000
 
 /* Error iterating over directories */
 #define PR_3A_OPTIMIZE_ITER		0x031001
 
 /* Error rehash directory */
 #define PR_3A_OPTIMIZE_DIR_ERR		0x031002
 
 /* Rehashing dir header */
 #define PR_3A_OPTIMIZE_DIR_HEADER	0x031003
 
 /* Rehashing directory %d */
 #define PR_3A_OPTIMIZE_DIR		0x031004
 
 /* Rehashing dir end */
 #define PR_3A_OPTIMIZE_DIR_END		0x031005
 
 /* Pass 3B is really just 1E */
 
 /*
  * Pass 4 errors
  */
 
 /* Pass 4: Checking reference counts */
 #define PR_4_PASS_HEADER		0x040000
 
 /* Unattached zero-length inode */
 #define PR_4_ZERO_LEN_INODE		0x040001
 
 /* Unattached inode */
 #define PR_4_UNATTACHED_INODE		0x040002
 
 /* Inode ref count wrong */
 #define PR_4_BAD_REF_COUNT		0x040003
 
 /* Inconsistent inode count information cached */
 #define PR_4_INCONSISTENT_COUNT		0x040004
 
 /* Extended attribute inode ref count wrong */
 #define PR_4_EA_INODE_REF_COUNT		0x040005
 
 /* directory exceeds max links, but no DIR_NLINK feature in superblock */
 #define PR_4_DIR_NLINK_FEATURE		0x040006
 
 /* Directory ref count set to overflow but it doesn't have to be */
 #define PR_4_DIR_OVERFLOW_REF_COUNT	0x040007
 
 /*
  * Pass 5 errors
  */
 
 /* Pass 5: Checking group summary information */
 #define PR_5_PASS_HEADER		0x050000
 
 /* Padding at end of inode bitmap is not set. */
 #define PR_5_INODE_BMAP_PADDING		0x050001
 
 /* Padding at end of block bitmap is not set. */
 #define PR_5_BLOCK_BMAP_PADDING		0x050002
 
 /* Block bitmap differences header */
 #define PR_5_BLOCK_BITMAP_HEADER	0x050003
 
 /* Block not used, but marked in bitmap */
 #define PR_5_BLOCK_UNUSED		0x050004
 
 /* Block used, but not marked used in bitmap */
 #define PR_5_BLOCK_USED			0x050005
 
 /* Block bitmap differences end */
 #define PR_5_BLOCK_BITMAP_END		0x050006
 
 /* Inode bitmap differences header */
 #define PR_5_INODE_BITMAP_HEADER	0x050007
 
 /* Inode not used, but marked in bitmap */
 #define PR_5_INODE_UNUSED		0x050008
 
 /* Inode used, but not marked used in bitmap */
 #define PR_5_INODE_USED			0x050009
 
 /* Inode bitmap differences end */
 #define PR_5_INODE_BITMAP_END		0x05000A
 
 /* Free inodes count for group wrong */
 #define PR_5_FREE_INODE_COUNT_GROUP	0x05000B
 
 /* Directories count for group wrong */
 #define PR_5_FREE_DIR_COUNT_GROUP	0x05000C
 
 /* Free inodes count wrong */
 #define PR_5_FREE_INODE_COUNT		0x05000D
 
 /* Free blocks count for group wrong */
 #define PR_5_FREE_BLOCK_COUNT_GROUP	0x05000E
 
 /* Free blocks count wrong */
 #define PR_5_FREE_BLOCK_COUNT		0x05000F
 
 /* Programming error: bitmap endpoints don't match */
 #define PR_5_BMAP_ENDPOINTS		0x050010
 
 /* Internal error: fudging end of bitmap */
 #define PR_5_FUDGE_BITMAP_ERROR		0x050011
 
 /* Error copying in replacement inode bitmap */
 #define PR_5_COPY_IBITMAP_ERROR		0x050012
 
 /* Error copying in replacement block bitmap */
 #define PR_5_COPY_BBITMAP_ERROR		0x050013
 
 /* Block range not used, but marked in bitmap */
 #define PR_5_BLOCK_RANGE_UNUSED		0x050014
 
 /* Block range used, but not marked used in bitmap */
 #define PR_5_BLOCK_RANGE_USED		0x050015
 
 /* Inode range not used, but marked in bitmap */
 #define PR_5_INODE_RANGE_UNUSED		0x050016
 
 /* Inode range used, but not marked used in bitmap */
 #define PR_5_INODE_RANGE_USED		0x050017
 
 /* Block in use but group is marked BLOCK_UNINIT */
 #define PR_5_BLOCK_UNINIT		0x050018
 
 /* Inode in use but group is marked INODE_UNINIT */
 #define PR_5_INODE_UNINIT		0x050019
 
 /* Inode bitmap checksum does not match */
 #define PR_5_INODE_BITMAP_CSUM_INVALID	0x05001A
 
 /* Block bitmap checksum does not match */
 #define PR_5_BLOCK_BITMAP_CSUM_INVALID	0x05001B
 
 /*
  * Post-Pass 5 errors
  */
 
 /* Recreate the journal if E2F_FLAG_JOURNAL_INODE flag is set */
 #define PR_6_RECREATE_JOURNAL		0x060001
 
 /* Update quota information if it is inconsistent */
 #define PR_6_UPDATE_QUOTAS		0x060002
 
 /* Error setting block group checksum info */
 #define PR_6_SET_BG_CHECKSUM		0x060003
 
 /* Error writing file system info */
 #define PR_6_FLUSH_FILESYSTEM		0x060004
 
 /* Error flushing writes to storage device */
 #define PR_6_IO_FLUSH			0x060005
 
 /* Error updating quota information */
 #define PR_6_WRITE_QUOTAS		0x060006
 
 /* Orphan file without a journal */
 #define PR_6_ORPHAN_FILE_WITHOUT_JOURNAL	0x060007
 
 /* Orphan file truncation failed */
 #define PR_6_ORPHAN_FILE_TRUNC_FAILED	0x060008
 
 /* Failed to initialize orphan file */
 #define PR_6_ORPHAN_FILE_CORRUPTED	0x060009
 
 /* Cannot fix corrupted orphan file with invalid bitmaps */
 #define PR_6_ORPHAN_FILE_BITMAP_INVALID	0x06000A
 
 /* Orphan file creation failed */
 #define PR_6_ORPHAN_FILE_CREATE_FAILED	0x06000B
 
 /* Orphan file block contains data */
 #define PR_6_ORPHAN_BLOCK_DIRTY		0x06000C
 
 /* orphan_present set but orphan file is empty */
 #define PR_6_ORPHAN_PRESENT_CLEAN_FILE	0x06000D
 
 /* orphan_present set but orphan_file is not */
 #define PR_6_ORPHAN_PRESENT_NO_FILE	0x06000E
 
 /* Orphan file size isn't multiple of blocks size */
 #define PR_6_ORPHAN_FILE_WRONG_SIZE	0x06000F
 
 /* Orphan file contains holes */
 #define PR_6_ORPHAN_FILE_HOLE		0x060010
 
 /*
  * Function declarations
  */
diff --git a/e2fsck/util.c b/e2fsck/util.c
index 3fe3c988..42740d9e 100644
--- a/e2fsck/util.c
+++ b/e2fsck/util.c
@@ -414,67 +414,76 @@ static _INLINE_ float timeval_subtract(struct timeval *tv1,
 void print_resource_track(e2fsck_t ctx, const char *desc,
 			  struct resource_track *track, io_channel channel)
 {
 #ifdef HAVE_GETRUSAGE
 	struct rusage r;
 #endif
 	struct timeval time_end;
 
 	if ((desc && !(ctx->options & E2F_OPT_TIME2)) ||
 	    (!desc && !(ctx->options & E2F_OPT_TIME)))
 		return;
 
 	e2fsck_clear_progbar(ctx);
 	gettimeofday(&time_end, 0);
 
 	if (desc)
 		log_out(ctx, "%s: ", desc);
 
 #define kbytes(x)	(((unsigned long long)(x) + 1023) / 1024)
-#ifdef HAVE_MALLINFO
+#ifdef HAVE_MALLINFO2
+	if (1) {
+		struct mallinfo2 malloc_info = mallinfo2();
+
+		log_out(ctx, _("Memory used: %lluk/%lluk (%lluk/%lluk), "),
+			kbytes(malloc_info.arena), kbytes(malloc_info.hblkhd),
+			kbytes(malloc_info.uordblks),
+			kbytes(malloc_info.fordblks));
+	} else
+#elif defined HAVE_MALLINFO
 	/* don't use mallinfo() if over 2GB used, since it returns "int" */
 	if ((char *)sbrk(0) - (char *)track->brk_start < 2LL << 30) {
 		struct mallinfo	malloc_info = mallinfo();
 
 		log_out(ctx, _("Memory used: %lluk/%lluk (%lluk/%lluk), "),
 			kbytes(malloc_info.arena), kbytes(malloc_info.hblkhd),
 			kbytes(malloc_info.uordblks),
 			kbytes(malloc_info.fordblks));
 	} else
 #endif
 	log_out(ctx, _("Memory used: %lluk, "),
 		kbytes(((char *)sbrk(0)) - ((char *)track->brk_start)));
 
 #ifdef HAVE_GETRUSAGE
 	getrusage(RUSAGE_SELF, &r);
 
 	log_out(ctx, _("time: %5.2f/%5.2f/%5.2f\n"),
 		timeval_subtract(&time_end, &track->time_start),
 		timeval_subtract(&r.ru_utime, &track->user_start),
 		timeval_subtract(&r.ru_stime, &track->system_start));
 #else
 	log_out(ctx, _("elapsed time: %6.3f\n"),
 		timeval_subtract(&time_end, &track->time_start));
 #endif
 #define mbytes(x)	(((x) + 1048575) / 1048576)
 	if (channel && channel->manager && channel->manager->get_stats) {
 		io_stats delta = 0;
 		unsigned long long bytes_read = 0;
 		unsigned long long bytes_written = 0;
 
 		if (desc)
 			log_out(ctx, "%s: ", desc);
 
 		channel->manager->get_stats(channel, &delta);
 		if (delta) {
 			bytes_read = delta->bytes_read - track->bytes_read;
 			bytes_written = delta->bytes_written -
 				track->bytes_written;
 		}
 		log_out(ctx, "I/O read: %lluMB, write: %lluMB, "
 			"rate: %.2fMB/s\n",
 			mbytes(bytes_read), mbytes(bytes_written),
 			(double)mbytes(bytes_read + bytes_written) /
 			timeval_subtract(&time_end, &track->time_start));
 	}
 }
 #endif /* RESOURCE_TRACK */
diff --git a/lib/config.h.in b/lib/config.h.in
index 9c9de65d..b5856bb5 100644
--- a/lib/config.h.in
+++ b/lib/config.h.in
@@ -1,583 +1,586 @@
 /* lib/config.h.in.  Generated from configure.ac by autoheader.  */
 
 /* Define if building universal (internal helper macro) */
 #undef AC_APPLE_UNIVERSAL_BUILD
 
 /* Define to 1 if debugging the blkid library */
 #undef CONFIG_BLKID_DEBUG
 
 /* Define to 1 to compile findfs */
 #undef CONFIG_BUILD_FINDFS
 
 /* Define to 1 for features for use by ext4 developers */
 #undef CONFIG_DEVELOPER_FEATURES
 
 /* Define to 1 if debugging ext3/4 journal code */
 #undef CONFIG_JBD_DEBUG
 
 /* Define to 1 to enable mmp support */
 #undef CONFIG_MMP
 
 /* Define to 1 to enable tdb support */
 #undef CONFIG_TDB
 
 /* Define to 1 if the testio I/O manager should be enabled */
 #undef CONFIG_TESTIO_DEBUG
 
 /* Define to 1 to disable use of backtrace */
 #undef DISABLE_BACKTRACE
 
 /* Define to 1 to enable bitmap stats. */
 #undef ENABLE_BMAP_STATS
 
 /* Define to 1 to enable bitmap stats. */
 #undef ENABLE_BMAP_STATS_OPS
 
 /* Define to 1 if translation of program messages to the user's native
    language is requested. */
 #undef ENABLE_NLS
 
 /* Define to 1 if you have the `add_key' function. */
 #undef HAVE_ADD_KEY
 
 /* Define to 1 if you have the <attr/xattr.h> header file. */
 #undef HAVE_ATTR_XATTR_H
 
 /* Define to 1 if you have the `backtrace' function. */
 #undef HAVE_BACKTRACE
 
 /* Define to 1 if blkid has blkid_probe_enable_partitions */
 #undef HAVE_BLKID_PROBE_ENABLE_PARTITIONS
 
 /* Define to 1 if blkid has blkid_probe_get_topology */
 #undef HAVE_BLKID_PROBE_GET_TOPOLOGY
 
 /* Define to 1 if blkid has blkid_topology_get_dax */
 #undef HAVE_BLKID_TOPOLOGY_GET_DAX
 
 /* Define to 1 if you have the Mac OS X function
    CFLocaleCopyPreferredLanguages in the CoreFoundation framework. */
 #undef HAVE_CFLOCALECOPYPREFERREDLANGUAGES
 
 /* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
    the CoreFoundation framework. */
 #undef HAVE_CFPREFERENCESCOPYAPPVALUE
 
 /* Define to 1 if you have the `chflags' function. */
 #undef HAVE_CHFLAGS
 
 /* Define if the GNU dcgettext() function is already present or preinstalled.
    */
 #undef HAVE_DCGETTEXT
 
 /* Define to 1 if you have the <dirent.h> header file. */
 #undef HAVE_DIRENT_H
 
 /* Define to 1 if you have the `dlopen' function. */
 #undef HAVE_DLOPEN
 
 /* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
 #undef HAVE_DOPRNT
 
 /* Define to 1 if you have the <errno.h> header file. */
 #undef HAVE_ERRNO_H
 
 /* Define to 1 if you have the <execinfo.h> header file. */
 #undef HAVE_EXECINFO_H
 
 /* Define to 1 if Ext2 ioctls present */
 #undef HAVE_EXT2_IOCTLS
 
 /* Define to 1 if you have the `fadvise64' function. */
 #undef HAVE_FADVISE64
 
 /* Define to 1 if you have the `fallocate' function. */
 #undef HAVE_FALLOCATE
 
 /* Define to 1 if you have the `fallocate64' function. */
 #undef HAVE_FALLOCATE64
 
 /* Define to 1 if you have the `fchown' function. */
 #undef HAVE_FCHOWN
 
 /* Define to 1 if you have the `fcntl' function. */
 #undef HAVE_FCNTL
 
 /* Define to 1 if you have the `fdatasync' function. */
 #undef HAVE_FDATASYNC
 
 /* Define to 1 if you have the `fstat64' function. */
 #undef HAVE_FSTAT64
 
 /* Define to 1 if you have the `fsync' function. */
 #undef HAVE_FSYNC
 
 /* Define to 1 if you have the `ftruncate64' function. */
 #undef HAVE_FTRUNCATE64
 
 /* Define to 1 if you have the <fuse.h> header file. */
 #undef HAVE_FUSE_H
 
 /* Define to 1 if you have the `futimes' function. */
 #undef HAVE_FUTIMES
 
 /* Define to 1 if you have the `getcwd' function. */
 #undef HAVE_GETCWD
 
 /* Define to 1 if you have the `getdtablesize' function. */
 #undef HAVE_GETDTABLESIZE
 
 /* Define to 1 if you have the `getentropy' function. */
 #undef HAVE_GETENTROPY
 
 /* Define to 1 if you have the `gethostname' function. */
 #undef HAVE_GETHOSTNAME
 
 /* Define to 1 if you have the `getmntinfo' function. */
 #undef HAVE_GETMNTINFO
 
 /* Define to 1 if you have the <getopt.h> header file. */
 #undef HAVE_GETOPT_H
 
 /* Define to 1 if you have the `getpwuid_r' function. */
 #undef HAVE_GETPWUID_R
 
 /* Define to 1 if you have the `getrandom' function. */
 #undef HAVE_GETRANDOM
 
 /* Define to 1 if you have the `getrlimit' function. */
 #undef HAVE_GETRLIMIT
 
 /* Define to 1 if you have the `getrusage' function. */
 #undef HAVE_GETRUSAGE
 
 /* Define if the GNU gettext() function is already present or preinstalled. */
 #undef HAVE_GETTEXT
 
 /* Define if you have the iconv() function and it works. */
 #undef HAVE_ICONV
 
 /* Define to 1 if the system has the type `intptr_t'. */
 #undef HAVE_INTPTR_T
 
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
 /* Define to 1 if you have the `jrand48' function. */
 #undef HAVE_JRAND48
 
 /* Define to 1 if you have the `keyctl' function. */
 #undef HAVE_KEYCTL
 
 /* Define to 1 if you have the <linux/falloc.h> header file. */
 #undef HAVE_LINUX_FALLOC_H
 
 /* Define to 1 if you have the <linux/fd.h> header file. */
 #undef HAVE_LINUX_FD_H
 
 /* Define to 1 if you have the <linux/fsmap.h> header file. */
 #undef HAVE_LINUX_FSMAP_H
 
 /* Define to 1 if you have the <linux/loop.h> header file. */
 #undef HAVE_LINUX_LOOP_H
 
 /* Define to 1 if you have the <linux/major.h> header file. */
 #undef HAVE_LINUX_MAJOR_H
 
 /* Define to 1 if you have the <linux/types.h> header file. */
 #undef HAVE_LINUX_TYPES_H
 
 /* Define to 1 if you have the `llistxattr' function. */
 #undef HAVE_LLISTXATTR
 
 /* Define to 1 if you have the `llseek' function. */
 #undef HAVE_LLSEEK
 
 /* Define to 1 if llseek declared in unistd.h */
 #undef HAVE_LLSEEK_PROTOTYPE
 
 /* Define to 1 if you have the `lseek64' function. */
 #undef HAVE_LSEEK64
 
 /* Define to 1 if lseek64 declared in unistd.h */
 #undef HAVE_LSEEK64_PROTOTYPE
 
 /* Define to 1 if you have the <magic.h> header file. */
 #undef HAVE_MAGIC_H
 
 /* Define to 1 if you have the `mallinfo' function. */
 #undef HAVE_MALLINFO
 
+/* Define to 1 if you have the `mallinfo2' function. */
+#undef HAVE_MALLINFO2
+
 /* Define to 1 if you have the <malloc.h> header file. */
 #undef HAVE_MALLOC_H
 
 /* Define to 1 if you have the `mbstowcs' function. */
 #undef HAVE_MBSTOWCS
 
 /* Define to 1 if you have the `memalign' function. */
 #undef HAVE_MEMALIGN
 
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
 /* Define to 1 if you have the `mempcpy' function. */
 #undef HAVE_MEMPCPY
 
 /* Define to 1 if you have the `mmap' function. */
 #undef HAVE_MMAP
 
 /* Define to 1 if you have the <mntent.h> header file. */
 #undef HAVE_MNTENT_H
 
 /* Define to 1 if mount supports nodev. */
 #undef HAVE_MOUNT_NODEV
 
 /* Define to 1 if mount supports nosuid. */
 #undef HAVE_MOUNT_NOSUID
 
 /* Define to 1 if you have the `msync' function. */
 #undef HAVE_MSYNC
 
 /* Define to 1 if you have the `nanosleep' function. */
 #undef HAVE_NANOSLEEP
 
 /* Define to 1 if you have the <netinet/in.h> header file. */
 #undef HAVE_NETINET_IN_H
 
 /* Define to 1 if you have the <net/if_dl.h> header file. */
 #undef HAVE_NET_IF_DL_H
 
 /* Define to 1 if you have the <net/if.h> header file. */
 #undef HAVE_NET_IF_H
 
 /* Define to 1 if you have the `open64' function. */
 #undef HAVE_OPEN64
 
 /* Define to 1 if optreset for getopt is present */
 #undef HAVE_OPTRESET
 
 /* Define to 1 if you have the `pathconf' function. */
 #undef HAVE_PATHCONF
 
 /* Define to 1 if you have the <paths.h> header file. */
 #undef HAVE_PATHS_H
 
 /* Define to 1 if you have the `posix_fadvise' function. */
 #undef HAVE_POSIX_FADVISE
 
 /* Define to 1 if you have the `posix_fadvise64' function. */
 #undef HAVE_POSIX_FADVISE64
 
 /* Define to 1 if you have the `posix_memalign' function. */
 #undef HAVE_POSIX_MEMALIGN
 
 /* Define to 1 if you have the `prctl' function. */
 #undef HAVE_PRCTL
 
 /* Define to 1 if you have the `pread' function. */
 #undef HAVE_PREAD
 
 /* Define to 1 if you have the `pread64' function. */
 #undef HAVE_PREAD64
 
 /* Define if you have POSIX threads libraries and header files. */
 #undef HAVE_PTHREAD
 
 /* Define to 1 if you have the <pthread.h> header file. */
 #undef HAVE_PTHREAD_H
 
 /* Have PTHREAD_PRIO_INHERIT. */
 #undef HAVE_PTHREAD_PRIO_INHERIT
 
 /* Define to 1 if you have the `pwrite' function. */
 #undef HAVE_PWRITE
 
 /* Define to 1 if you have the `pwrite64' function. */
 #undef HAVE_PWRITE64
 
 /* Define to 1 if dirent has d_reclen */
 #undef HAVE_RECLEN_DIRENT
 
 /* Define to 1 if if struct sockaddr contains sa_len */
 #undef HAVE_SA_LEN
 
 /* Define to 1 if you have the `secure_getenv' function. */
 #undef HAVE_SECURE_GETENV
 
 /* Define to 1 if you have the <semaphore.h> header file. */
 #undef HAVE_SEMAPHORE_H
 
 /* Define to 1 if sem_init() exists */
 #undef HAVE_SEM_INIT
 
 /* Define to 1 if you have the <setjmp.h> header file. */
 #undef HAVE_SETJMP_H
 
 /* Define to 1 if you have the `setmntent' function. */
 #undef HAVE_SETMNTENT
 
 /* Define to 1 if you have the `setresgid' function. */
 #undef HAVE_SETRESGID
 
 /* Define to 1 if you have the `setresuid' function. */
 #undef HAVE_SETRESUID
 
 /* Define to 1 if you have the <signal.h> header file. */
 #undef HAVE_SIGNAL_H
 
 /* Define to 1 if you have the `snprintf' function. */
 #undef HAVE_SNPRINTF
 
 /* Define to 1 if you have the `srandom' function. */
 #undef HAVE_SRANDOM
 
 /* Define to 1 if struct stat has st_flags */
 #undef HAVE_STAT_FLAGS
 
 /* Define to 1 if you have the <stdarg.h> header file. */
 #undef HAVE_STDARG_H
 
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
 /* Define to 1 if you have the <stdlib.h> header file. */
 #undef HAVE_STDLIB_H
 
 /* Define to 1 if you have the `stpcpy' function. */
 #undef HAVE_STPCPY
 
 /* Define to 1 if you have the `strcasecmp' function. */
 #undef HAVE_STRCASECMP
 
 /* Define to 1 if you have the `strdup' function. */
 #undef HAVE_STRDUP
 
 /* Define to 1 if you have the <strings.h> header file. */
 #undef HAVE_STRINGS_H
 
 /* Define to 1 if you have the <string.h> header file. */
 #undef HAVE_STRING_H
 
 /* Define to 1 if you have the `strnlen' function. */
 #undef HAVE_STRNLEN
 
 /* Define to 1 if you have the `strptime' function. */
 #undef HAVE_STRPTIME
 
 /* Define to 1 if you have the `strtoull' function. */
 #undef HAVE_STRTOULL
 
 /* Define to 1 if `st_atim' is a member of `struct stat'. */
 #undef HAVE_STRUCT_STAT_ST_ATIM
 
 /* Define to 1 if you have the `sync_file_range' function. */
 #undef HAVE_SYNC_FILE_RANGE
 
 /* Define to 1 if you have the `sysconf' function. */
 #undef HAVE_SYSCONF
 
 /* Define to 1 if you have the <sys/acl.h> header file. */
 #undef HAVE_SYS_ACL_H
 
 /* Define to 1 if you have the <sys/disklabel.h> header file. */
 #undef HAVE_SYS_DISKLABEL_H
 
 /* Define to 1 if you have the <sys/disk.h> header file. */
 #undef HAVE_SYS_DISK_H
 
 /* Define to 1 if you have the <sys/file.h> header file. */
 #undef HAVE_SYS_FILE_H
 
 /* Define to 1 if you have the <sys/ioctl.h> header file. */
 #undef HAVE_SYS_IOCTL_H
 
 /* Define to 1 if you have the <sys/key.h> header file. */
 #undef HAVE_SYS_KEY_H
 
 /* Define to 1 if you have the <sys/mkdev.h> header file. */
 #undef HAVE_SYS_MKDEV_H
 
 /* Define to 1 if you have the <sys/mman.h> header file. */
 #undef HAVE_SYS_MMAN_H
 
 /* Define to 1 if you have the <sys/mount.h> header file. */
 #undef HAVE_SYS_MOUNT_H
 
 /* Define to 1 if you have the <sys/prctl.h> header file. */
 #undef HAVE_SYS_PRCTL_H
 
 /* Define to 1 if you have the <sys/random.h> header file. */
 #undef HAVE_SYS_RANDOM_H
 
 /* Define to 1 if you have the <sys/resource.h> header file. */
 #undef HAVE_SYS_RESOURCE_H
 
 /* Define to 1 if you have the <sys/select.h> header file. */
 #undef HAVE_SYS_SELECT_H
 
 /* Define to 1 if you have the <sys/socket.h> header file. */
 #undef HAVE_SYS_SOCKET_H
 
 /* Define to 1 if you have the <sys/sockio.h> header file. */
 #undef HAVE_SYS_SOCKIO_H
 
 /* Define to 1 if you have the <sys/stat.h> header file. */
 #undef HAVE_SYS_STAT_H
 
 /* Define to 1 if you have the <sys/syscall.h> header file. */
 #undef HAVE_SYS_SYSCALL_H
 
 /* Define to 1 if you have the <sys/sysmacros.h> header file. */
 #undef HAVE_SYS_SYSMACROS_H
 
 /* Define to 1 if you have the <sys/time.h> header file. */
 #undef HAVE_SYS_TIME_H
 
 /* Define to 1 if you have the <sys/types.h> header file. */
 #undef HAVE_SYS_TYPES_H
 
 /* Define to 1 if you have the <sys/un.h> header file. */
 #undef HAVE_SYS_UN_H
 
 /* Define to 1 if you have the <sys/wait.h> header file. */
 #undef HAVE_SYS_WAIT_H
 
 /* Define to 1 if you have the <sys/xattr.h> header file. */
 #undef HAVE_SYS_XATTR_H
 
 /* Define to 1 if you have the <termios.h> header file. */
 #undef HAVE_TERMIOS_H
 
 /* Define to 1 if you have the <termio.h> header file. */
 #undef HAVE_TERMIO_H
 
 /* Define to 1 if ssize_t declared */
 #undef HAVE_TYPE_SSIZE_T
 
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
 /* Define to 1 if you have the `usleep' function. */
 #undef HAVE_USLEEP
 
 /* Define to 1 if you have the `utime' function. */
 #undef HAVE_UTIME
 
 /* Define to 1 if you have the `utimes' function. */
 #undef HAVE_UTIMES
 
 /* Define to 1 if you have the <utime.h> header file. */
 #undef HAVE_UTIME_H
 
 /* Define to 1 if you have the `valloc' function. */
 #undef HAVE_VALLOC
 
 /* Define to 1 if you have the `vprintf' function. */
 #undef HAVE_VPRINTF
 
 /* Define to 1 if you have the `__secure_getenv' function. */
 #undef HAVE___SECURE_GETENV
 
 /* package name for gettext */
 #undef PACKAGE
 
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
 /* Define to the full name of this package. */
 #undef PACKAGE_NAME
 
 /* Define to the full name and version of this package. */
 #undef PACKAGE_STRING
 
 /* Define to the one symbol short name of this package. */
 #undef PACKAGE_TARNAME
 
 /* Define to the home page for this package. */
 #undef PACKAGE_URL
 
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
 /* Define to necessary symbol if this constant uses a non-standard name on
    your system. */
 #undef PTHREAD_CREATE_JOINABLE
 
 /* The size of `int', as computed by sizeof. */
 #undef SIZEOF_INT
 
 /* The size of `long', as computed by sizeof. */
 #undef SIZEOF_LONG
 
 /* The size of `long long', as computed by sizeof. */
 #undef SIZEOF_LONG_LONG
 
 /* The size of `off_t', as computed by sizeof. */
 #undef SIZEOF_OFF_T
 
 /* The size of `short', as computed by sizeof. */
 #undef SIZEOF_SHORT
 
 /* The size of `time_t', as computed by sizeof. */
 #undef SIZEOF_TIME_T
 
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
 /* If the compiler supports a TLS storage class define it to that here */
 #undef TLS
 
 /* Enable extensions on AIX 3, Interix.  */
 #ifndef _ALL_SOURCE
 # undef _ALL_SOURCE
 #endif
 /* Enable GNU extensions on systems that have them.  */
 #ifndef _GNU_SOURCE
 # undef _GNU_SOURCE
 #endif
 /* Enable threading extensions on Solaris.  */
 #ifndef _POSIX_PTHREAD_SEMANTICS
 # undef _POSIX_PTHREAD_SEMANTICS
 #endif
 /* Enable extensions on HP NonStop.  */
 #ifndef _TANDEM_SOURCE
 # undef _TANDEM_SOURCE
 #endif
 /* Enable general extensions on Solaris.  */
 #ifndef __EXTENSIONS__
 # undef __EXTENSIONS__
 #endif
 
 
 /* Define to 1 to build uuidd */
 #undef USE_UUIDD
 
 /* version for gettext */
 #undef VERSION
 
 /* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
    significant byte first (like Motorola and SPARC, unlike Intel). */
 #if defined AC_APPLE_UNIVERSAL_BUILD
 # if defined __BIG_ENDIAN__
 #  define WORDS_BIGENDIAN 1
 # endif
 #else
 # ifndef WORDS_BIGENDIAN
 #  undef WORDS_BIGENDIAN
 # endif
 #endif
 
 /* Define to 1 if Apple Darwin libintl workaround is needed */
 #undef _INTL_REDIRECT_MACROS
 
 /* Define to 1 if on MINIX. */
 #undef _MINIX
 
 /* Define to 2 if the system does not provide POSIX.1 features except with
    this defined. */
 #undef _POSIX_1_SOURCE
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #undef _POSIX_SOURCE
 
 #include <dirpaths.h>
diff --git a/lib/ext2fs/alloc_stats.c b/lib/ext2fs/alloc_stats.c
index 3949f618..6f98bcc7 100644
--- a/lib/ext2fs/alloc_stats.c
+++ b/lib/ext2fs/alloc_stats.c
@@ -61,26 +61,27 @@ void ext2fs_inode_alloc_stats(ext2_filsys fs, ext2_ino_t ino, int inuse)
 void ext2fs_block_alloc_stats2(ext2_filsys fs, blk64_t blk, int inuse)
 {
 	int	group = ext2fs_group_of_blk2(fs, blk);
 
-	if (blk >= ext2fs_blocks_count(fs->super)) {
+	if (blk < fs->super->s_first_data_block ||
+	    blk >= ext2fs_blocks_count(fs->super)) {
 #ifndef OMIT_COM_ERR
 		com_err("ext2fs_block_alloc_stats", 0,
 			"Illegal block number: %lu", (unsigned long) blk);
 #endif
 		return;
 	}
 	if (inuse > 0)
 		ext2fs_mark_block_bitmap2(fs->block_map, blk);
 	else
 		ext2fs_unmark_block_bitmap2(fs->block_map, blk);
 	ext2fs_bg_free_blocks_count_set(fs, group, ext2fs_bg_free_blocks_count(fs, group) - inuse);
 	ext2fs_bg_flags_clear(fs, group, EXT2_BG_BLOCK_UNINIT);
 	ext2fs_group_desc_csum_set(fs, group);
 
 	ext2fs_free_blocks_count_add(fs->super,
 			     -inuse * (blk64_t) EXT2FS_CLUSTER_RATIO(fs));
 	ext2fs_mark_super_dirty(fs);
 	ext2fs_mark_bb_dirty(fs);
 	if (fs->block_alloc_stats)
 		(fs->block_alloc_stats)(fs, (blk64_t) blk, inuse);
 }
diff --git a/lib/ext2fs/dir_iterate.c b/lib/ext2fs/dir_iterate.c
index b2b77693..7798a482 100644
--- a/lib/ext2fs/dir_iterate.c
+++ b/lib/ext2fs/dir_iterate.c
@@ -179,91 +179,95 @@ errcode_t ext2fs_dir_iterate(ext2_filsys fs,
 /*
  * Helper function which is private to this module.  Used by
  * ext2fs_dir_iterate() and ext2fs_dblist_dir_iterate()
  */
 int ext2fs_process_dir_block(ext2_filsys fs,
 			     blk64_t	*blocknr,
 			     e2_blkcnt_t blockcnt,
 			     blk64_t	ref_block EXT2FS_ATTR((unused)),
 			     int	ref_offset EXT2FS_ATTR((unused)),
 			     void	*priv_data)
 {
 	struct dir_context *ctx = (struct dir_context *) priv_data;
 	unsigned int	offset = 0;
 	unsigned int	next_real_entry = 0;
 	int		ret = 0;
 	int		changed = 0;
 	int		do_abort = 0;
 	unsigned int	rec_len, size, buflen;
 	int		entry;
 	struct ext2_dir_entry *dirent;
 	int		csum_size = 0;
 	int		inline_data;
 	errcode_t	retval = 0;
 
 	if (blockcnt < 0)
 		return 0;
 
 	entry = blockcnt ? DIRENT_OTHER_FILE : DIRENT_DOT_FILE;
 
 	/* If a dir has inline data, we don't need to read block */
 	inline_data = !!(ctx->flags & DIRENT_FLAG_INCLUDE_INLINE_DATA);
 	if (!inline_data) {
 		ctx->errcode = ext2fs_read_dir_block4(fs, *blocknr, ctx->buf, 0,
 						      ctx->dir);
 		if (ctx->errcode)
 			return BLOCK_ABORT;
 		/* If we handle a normal dir, we traverse the entire block */
 		buflen = fs->blocksize;
 	} else {
 		buflen = ctx->buflen;
 	}
 
 	if (ext2fs_has_feature_metadata_csum(fs->super))
 		csum_size = sizeof(struct ext2_dir_entry_tail);
 
+	if (buflen < 8) {
+		ctx->errcode = EXT2_ET_DIR_CORRUPTED;
+		return BLOCK_ABORT;
+	}
 	while (offset < buflen - 8) {
 		dirent = (struct ext2_dir_entry *) (ctx->buf + offset);
 		if (ext2fs_get_rec_len(fs, dirent, &rec_len))
 			return BLOCK_ABORT;
 		if (((offset + rec_len) > buflen) ||
 		    (rec_len < 8) ||
 		    ((rec_len % 4) != 0) ||
 		    ((ext2fs_dirent_name_len(dirent)+8) > (int) rec_len)) {
 			ctx->errcode = EXT2_ET_DIR_CORRUPTED;
 			return BLOCK_ABORT;
 		}
 		if (!dirent->inode) {
 			/*
 			 * We just need to check metadata_csum when this
 			 * dir hasn't inline data.  That means that 'buflen'
 			 * should be blocksize.
 			 */
 			if (!inline_data &&
 			    (offset == buflen - csum_size) &&
 			    (dirent->rec_len == csum_size) &&
 			    (dirent->name_len == EXT2_DIR_NAME_LEN_CSUM)) {
 				if (!(ctx->flags & DIRENT_FLAG_INCLUDE_CSUM))
 					goto next;
 				entry = DIRENT_CHECKSUM;
 			} else if (!(ctx->flags & DIRENT_FLAG_INCLUDE_EMPTY))
 				goto next;
 		}
 
 		ret = (ctx->func)(ctx->dir,
 				  (next_real_entry > offset) ?
 				  DIRENT_DELETED_FILE : entry,
 				  dirent, offset,
 				  buflen, ctx->buf,
 				  ctx->priv_data);
 		if (entry < DIRENT_OTHER_FILE)
 			entry++;
 
 		if (ret & DIRENT_CHANGED) {
 			if (ext2fs_get_rec_len(fs, dirent, &rec_len))
 				return BLOCK_ABORT;
 			changed++;
 		}
 		if (ret & DIRENT_ABORT) {
 			do_abort++;
 			break;
 		}
diff --git a/lib/ext2fs/ext2_err.et.in b/lib/ext2fs/ext2_err.et.in
index cf0e00ea..bb1dcf14 100644
--- a/lib/ext2fs/ext2_err.et.in
+++ b/lib/ext2fs/ext2_err.et.in
@@ -551,4 +551,7 @@ ec	EXT2_ET_NO_GDESC,
 ec	EXT2_FILSYS_CORRUPTED,
 	"The internal ext2_filsys data structure appears to be corrupted"
 
+ec	EXT2_ET_EXTENT_CYCLE,
+	"Found cyclic loop in extent tree"
+
 	end
diff --git a/lib/ext2fs/ext2_ext_attr.h b/lib/ext2fs/ext2_ext_attr.h
index f2042ed5..c6068c48 100644
--- a/lib/ext2fs/ext2_ext_attr.h
+++ b/lib/ext2fs/ext2_ext_attr.h
@@ -28,35 +28,46 @@ struct ext2_ext_attr_header {
 struct ext2_ext_attr_entry {
 	__u8	e_name_len;	/* length of name */
 	__u8	e_name_index;	/* attribute name index */
 	__u16	e_value_offs;	/* offset in disk block of value */
 	__u32	e_value_inum;	/* inode in which the value is stored */
 	__u32	e_value_size;	/* size of attribute value */
 	__u32	e_hash;		/* hash value of name and value */
 #if 0
 	char	e_name[0];	/* attribute name */
 #endif
 };
 
 #define EXT2_EXT_ATTR_PAD_BITS		2
 #define EXT2_EXT_ATTR_PAD		((unsigned) 1<<EXT2_EXT_ATTR_PAD_BITS)
 #define EXT2_EXT_ATTR_ROUND		(EXT2_EXT_ATTR_PAD-1)
 #define EXT2_EXT_ATTR_LEN(name_len) \
 	(((name_len) + EXT2_EXT_ATTR_ROUND + \
 	sizeof(struct ext2_ext_attr_entry)) & ~EXT2_EXT_ATTR_ROUND)
 #define EXT2_EXT_ATTR_NEXT(entry) \
 	( (struct ext2_ext_attr_entry *)( \
 	  (char *)(entry) + EXT2_EXT_ATTR_LEN((entry)->e_name_len)) )
 #define EXT2_EXT_ATTR_SIZE(size) \
 	(((size) + EXT2_EXT_ATTR_ROUND) & ~EXT2_EXT_ATTR_ROUND)
 #define EXT2_EXT_IS_LAST_ENTRY(entry) (*((__u32 *)(entry)) == 0UL)
 #define EXT2_EXT_ATTR_NAME(entry) \
 	(((char *) (entry)) + sizeof(struct ext2_ext_attr_entry))
 #define EXT2_XATTR_LEN(name_len) \
 	(((name_len) + EXT2_EXT_ATTR_ROUND + \
 	sizeof(struct ext2_xattr_entry)) & ~EXT2_EXT_ATTR_ROUND)
 #define EXT2_XATTR_SIZE(size) \
 	(((size) + EXT2_EXT_ATTR_ROUND) & ~EXT2_EXT_ATTR_ROUND)
 
+/*
+ * XATTR_SIZE_MAX is currently 64k, but for the purposes of checking
+ * for file system consistency errors, we use a somewhat bigger value.
+ * This allows XATTR_SIZE_MAX to grow in the future, but by using this
+ * instead of INT_MAX for certain consistency checks, we don't need to
+ * worry about arithmetic overflows.  (Actually XATTR_SIZE_MAX is
+ * defined in include/uapi/linux/limits.h, so changing it is going
+ * not going to be trivial....)
+ */
+#define EXT2_XATTR_SIZE_MAX (1 << 24)
+
 #ifdef __KERNEL__
 # ifdef CONFIG_EXT2_FS_EXT_ATTR
 extern int ext2_get_ext_attr(struct inode *, const char *, char *, size_t, int);
diff --git a/lib/ext2fs/extent.c b/lib/ext2fs/extent.c
index b324c7b0..82e75ccd 100644
--- a/lib/ext2fs/extent.c
+++ b/lib/ext2fs/extent.c
@@ -42,11 +42,12 @@
 struct extent_path {
 	char		*buf;
 	int		entries;
 	int		max_entries;
 	int		left;
 	int		visit_num;
 	int		flags;
 	blk64_t		end_blk;
+	blk64_t		blk;
 	void		*curr;
 };
 
@@ -217,78 +218,79 @@ errcode_t ext2fs_extent_open(ext2_filsys fs, ext2_ino_t ino,
 errcode_t ext2fs_extent_open2(ext2_filsys fs, ext2_ino_t ino,
 				    struct ext2_inode *inode,
 				    ext2_extent_handle_t *ret_handle)
 {
 	struct ext2_extent_handle	*handle;
 	errcode_t			retval;
 	int				i;
 	struct ext3_extent_header	*eh;
 
 	EXT2_CHECK_MAGIC(fs, EXT2_ET_MAGIC_EXT2FS_FILSYS);
 
 	if (!inode)
 		if ((ino == 0) || (ino > fs->super->s_inodes_count))
 			return EXT2_ET_BAD_INODE_NUM;
 
 	retval = ext2fs_get_mem(sizeof(struct ext2_extent_handle), &handle);
 	if (retval)
 		return retval;
 	memset(handle, 0, sizeof(struct ext2_extent_handle));
 
 	handle->ino = ino;
 	handle->fs = fs;
 
 	if (inode) {
 		handle->inode = inode;
 	} else {
 		handle->inode = &handle->inodebuf;
 		retval = ext2fs_read_inode(fs, ino, handle->inode);
 		if (retval)
 			goto errout;
 	}
 
 	eh = (struct ext3_extent_header *) &handle->inode->i_block[0];
 
 	for (i=0; i < EXT2_N_BLOCKS; i++)
 		if (handle->inode->i_block[i])
 			break;
 	if (i >= EXT2_N_BLOCKS) {
 		eh->eh_magic = ext2fs_cpu_to_le16(EXT3_EXT_MAGIC);
 		eh->eh_depth = 0;
 		eh->eh_entries = 0;
 		i = (sizeof(handle->inode->i_block) - sizeof(*eh)) /
 			sizeof(struct ext3_extent);
 		eh->eh_max = ext2fs_cpu_to_le16(i);
 		handle->inode->i_flags |= EXT4_EXTENTS_FL;
 	}
 
 	if (!(handle->inode->i_flags & EXT4_EXTENTS_FL)) {
 		retval = EXT2_ET_INODE_NOT_EXTENT;
 		goto errout;
 	}
 
 	retval = ext2fs_extent_header_verify(eh, sizeof(handle->inode->i_block));
 	if (retval)
 		goto errout;
 
 	handle->max_depth = ext2fs_le16_to_cpu(eh->eh_depth);
 	handle->type = ext2fs_le16_to_cpu(eh->eh_magic);
 
 	handle->max_paths = handle->max_depth + 1;
 	retval = ext2fs_get_memzero(handle->max_paths *
 				    sizeof(struct extent_path),
 				    &handle->path);
 	handle->path[0].buf = (char *) handle->inode->i_block;
 
 	handle->path[0].left = handle->path[0].entries =
 		ext2fs_le16_to_cpu(eh->eh_entries);
 	handle->path[0].max_entries = ext2fs_le16_to_cpu(eh->eh_max);
 	handle->path[0].curr = 0;
 	handle->path[0].end_blk =
 		(EXT2_I_SIZE(handle->inode) + fs->blocksize - 1) >>
 		 EXT2_BLOCK_SIZE_BITS(fs->super);
+	handle->path[0].blk = 0;
 	handle->path[0].visit_num = 1;
 	handle->level = 0;
 	handle->magic = EXT2_ET_MAGIC_EXTENT_HANDLE;
 
 	*ret_handle = handle;
 	return 0;
@@ -301,23 +303,23 @@ errout:
 /*
  * This function is responsible for (optionally) moving through the
  * extent tree and then returning the current extent
  */
 errcode_t ext2fs_extent_get(ext2_extent_handle_t handle,
 			    int flags, struct ext2fs_extent *extent)
 {
-	struct extent_path	*path, *newpath;
+	struct extent_path	*path, *newpath, *tp;
 	struct ext3_extent_header	*eh;
 	struct ext3_extent_idx		*ix = 0;
 	struct ext3_extent		*ex;
 	errcode_t			retval;
 	blk64_t				blk;
 	blk64_t				end_blk;
-	int				orig_op, op;
+	int				orig_op, op, l;
 	int				failed_csum = 0;
 
 	EXT2_CHECK_MAGIC(handle, EXT2_ET_MAGIC_EXTENT_HANDLE);
 
 	if (!handle->path)
 		return EXT2_ET_NO_CURRENT_NODE;
 
 	orig_op = op = flags & EXT2_EXTENT_MOVE_MASK;
@@ -325,252 +327,261 @@ errcode_t ext2fs_extent_get(ext2_extent_handle_t handle,
 retry:
 	path = handle->path + handle->level;
 	if ((orig_op == EXT2_EXTENT_NEXT) ||
 	    (orig_op == EXT2_EXTENT_NEXT_LEAF)) {
 		if (handle->level < handle->max_depth) {
 			/* interior node */
 			if (path->visit_num == 0) {
 				path->visit_num++;
 				op = EXT2_EXTENT_DOWN;
 			} else if (path->left > 0)
 				op = EXT2_EXTENT_NEXT_SIB;
 			else if (handle->level > 0)
 				op = EXT2_EXTENT_UP;
 			else
 				return EXT2_ET_EXTENT_NO_NEXT;
 		} else {
 			/* leaf node */
 			if (path->left > 0)
 				op = EXT2_EXTENT_NEXT_SIB;
 			else if (handle->level > 0)
 				op = EXT2_EXTENT_UP;
 			else
 				return EXT2_ET_EXTENT_NO_NEXT;
 		}
 		if (op != EXT2_EXTENT_NEXT_SIB) {
 #ifdef DEBUG_GET_EXTENT
 			printf("<<<< OP = %s\n",
 			       (op == EXT2_EXTENT_DOWN) ? "down" :
 			       ((op == EXT2_EXTENT_UP) ? "up" : "unknown"));
 #endif
 		}
 	}
 
 	if ((orig_op == EXT2_EXTENT_PREV) ||
 	    (orig_op == EXT2_EXTENT_PREV_LEAF)) {
 		if (handle->level < handle->max_depth) {
 			/* interior node */
 			if (path->visit_num > 0 ) {
 				/* path->visit_num = 0; */
 				op = EXT2_EXTENT_DOWN_AND_LAST;
 			} else if (path->left < path->entries-1)
 				op = EXT2_EXTENT_PREV_SIB;
 			else if (handle->level > 0)
 				op = EXT2_EXTENT_UP;
 			else
 				return EXT2_ET_EXTENT_NO_PREV;
 		} else {
 			/* leaf node */
 			if (path->left < path->entries-1)
 				op = EXT2_EXTENT_PREV_SIB;
 			else if (handle->level > 0)
 				op = EXT2_EXTENT_UP;
 			else
 				return EXT2_ET_EXTENT_NO_PREV;
 		}
 		if (op != EXT2_EXTENT_PREV_SIB) {
 #ifdef DEBUG_GET_EXTENT
 			printf("<<<< OP = %s\n",
 			       (op == EXT2_EXTENT_DOWN_AND_LAST) ? "down/last" :
 			       ((op == EXT2_EXTENT_UP) ? "up" : "unknown"));
 #endif
 		}
 	}
 
 	if (orig_op == EXT2_EXTENT_LAST_LEAF) {
 		if ((handle->level < handle->max_depth) &&
 		    (path->left == 0))
 			op = EXT2_EXTENT_DOWN;
 		else
 			op = EXT2_EXTENT_LAST_SIB;
 #ifdef DEBUG_GET_EXTENT
 		printf("<<<< OP = %s\n",
 			   (op == EXT2_EXTENT_DOWN) ? "down" : "last_sib");
 #endif
 	}
 
 	switch (op) {
 	case EXT2_EXTENT_CURRENT:
 		ix = path->curr;
 		break;
 	case EXT2_EXTENT_ROOT:
 		handle->level = 0;
 		path = handle->path + handle->level;
 		/* fallthrough */
 	case EXT2_EXTENT_FIRST_SIB:
 		path->left = path->entries;
 		path->curr = 0;
 		/* fallthrough */
 	case EXT2_EXTENT_NEXT_SIB:
 		if (path->left <= 0)
 			return EXT2_ET_EXTENT_NO_NEXT;
 		if (path->curr) {
 			ix = path->curr;
 			ix++;
 		} else {
 			eh = (struct ext3_extent_header *) path->buf;
 			ix = EXT_FIRST_INDEX(eh);
 		}
 		path->left--;
 		path->curr = ix;
 		path->visit_num = 0;
 		break;
 	case EXT2_EXTENT_PREV_SIB:
 		if (!path->curr ||
 		    path->left+1 >= path->entries)
 			return EXT2_ET_EXTENT_NO_PREV;
 		ix = path->curr;
 		ix--;
 		path->curr = ix;
 		path->left++;
 		if (handle->level < handle->max_depth)
 			path->visit_num = 1;
 		break;
 	case EXT2_EXTENT_LAST_SIB:
 		eh = (struct ext3_extent_header *) path->buf;
 		path->curr = EXT_LAST_EXTENT(eh);
 		ix = path->curr;
 		path->left = 0;
 		path->visit_num = 0;
 		break;
 	case EXT2_EXTENT_UP:
 		if (handle->level <= 0)
 			return EXT2_ET_EXTENT_NO_UP;
 		handle->level--;
 		path--;
 		ix = path->curr;
 		if ((orig_op == EXT2_EXTENT_PREV) ||
 		    (orig_op == EXT2_EXTENT_PREV_LEAF))
 			path->visit_num = 0;
 		break;
 	case EXT2_EXTENT_DOWN:
 	case EXT2_EXTENT_DOWN_AND_LAST:
 		if (!path->curr ||(handle->level >= handle->max_depth))
 			return EXT2_ET_EXTENT_NO_DOWN;
 
 		ix = path->curr;
 		newpath = path + 1;
 		if (!newpath->buf) {
 			retval = ext2fs_get_mem(handle->fs->blocksize,
 						&newpath->buf);
 			if (retval)
 				return retval;
 		}
 		blk = ext2fs_le32_to_cpu(ix->ei_leaf) +
 			((__u64) ext2fs_le16_to_cpu(ix->ei_leaf_hi) << 32);
+		for (l = handle->level, tp = path; l > 0; l--, tp--) {
+			if (blk == tp->blk)
+				return EXT2_ET_EXTENT_CYCLE;
+		}
+		newpath->blk = blk;
 		if ((handle->fs->flags & EXT2_FLAG_IMAGE_FILE) &&
 		    (handle->fs->io != handle->fs->image_io))
 			memset(newpath->buf, 0, handle->fs->blocksize);
 		else {
 			retval = io_channel_read_blk64(handle->fs->io,
 						     blk, 1, newpath->buf);
 			if (retval)
 				return retval;
 		}
 		handle->level++;
 
 		eh = (struct ext3_extent_header *) newpath->buf;
 
 		retval = ext2fs_extent_header_verify(eh, handle->fs->blocksize);
 		if (retval) {
 			handle->level--;
 			return retval;
 		}
 
 		if (!(handle->fs->flags & EXT2_FLAG_IGNORE_CSUM_ERRORS) &&
 		    !ext2fs_extent_block_csum_verify(handle->fs, handle->ino,
 						     eh))
 			failed_csum = 1;
 
 		newpath->left = newpath->entries =
 			ext2fs_le16_to_cpu(eh->eh_entries);
 		newpath->max_entries = ext2fs_le16_to_cpu(eh->eh_max);
 
+		/* Make sure there is at least one extent present */
+		if (newpath->left <= 0)
+			return EXT2_ET_EXTENT_NO_DOWN;
+
 		if (path->left > 0) {
 			ix++;
 			newpath->end_blk = ext2fs_le32_to_cpu(ix->ei_block);
 		} else
 			newpath->end_blk = path->end_blk;
 
 		path = newpath;
 		if (op == EXT2_EXTENT_DOWN) {
 			ix = EXT_FIRST_INDEX((struct ext3_extent_header *) eh);
 			path->curr = ix;
 			path->left = path->entries - 1;
 			path->visit_num = 0;
 		} else {
 			ix = EXT_LAST_INDEX((struct ext3_extent_header *) eh);
 			path->curr = ix;
 			path->left = 0;
 			if (handle->level < handle->max_depth)
 				path->visit_num = 1;
 		}
 #ifdef DEBUG_GET_EXTENT
 		printf("Down to level %d/%d, end_blk=%llu\n",
 			   handle->level, handle->max_depth,
 			   path->end_blk);
 #endif
 		break;
 	default:
 		return EXT2_ET_OP_NOT_SUPPORTED;
 	}
 
 	if (!ix)
 		return EXT2_ET_NO_CURRENT_NODE;
 
 	extent->e_flags = 0;
 #ifdef DEBUG_GET_EXTENT
 	printf("(Left %d)\n", path->left);
 #endif
 
 	if (handle->level == handle->max_depth) {
 		ex = (struct ext3_extent *) ix;
 
 		extent->e_pblk = ext2fs_le32_to_cpu(ex->ee_start) +
 			((__u64) ext2fs_le16_to_cpu(ex->ee_start_hi) << 32);
 		extent->e_lblk = ext2fs_le32_to_cpu(ex->ee_block);
 		extent->e_len = ext2fs_le16_to_cpu(ex->ee_len);
 		extent->e_flags |= EXT2_EXTENT_FLAGS_LEAF;
 		if (extent->e_len > EXT_INIT_MAX_LEN) {
 			extent->e_len -= EXT_INIT_MAX_LEN;
 			extent->e_flags |= EXT2_EXTENT_FLAGS_UNINIT;
 		}
 	} else {
 		extent->e_pblk = ext2fs_le32_to_cpu(ix->ei_leaf) +
 			((__u64) ext2fs_le16_to_cpu(ix->ei_leaf_hi) << 32);
 		extent->e_lblk = ext2fs_le32_to_cpu(ix->ei_block);
 		if (path->left > 0) {
 			ix++;
 			end_blk = ext2fs_le32_to_cpu(ix->ei_block);
 		} else
 			end_blk = path->end_blk;
 
 		extent->e_len = end_blk - extent->e_lblk;
 	}
 	if (path->visit_num)
 		extent->e_flags |= EXT2_EXTENT_FLAGS_SECOND_VISIT;
 
 	if (((orig_op == EXT2_EXTENT_NEXT_LEAF) ||
 	     (orig_op == EXT2_EXTENT_PREV_LEAF)) &&
 	    (handle->level != handle->max_depth))
 		goto retry;
 
 	if ((orig_op == EXT2_EXTENT_LAST_LEAF) &&
 	    ((handle->level != handle->max_depth) ||
 	     (path->left != 0)))
 		goto retry;
 
 	if (failed_csum)
 		return EXT2_ET_EXTENT_CSUM_INVALID;
 
 	return 0;
 }
@@ -1599,76 +1610,80 @@ done:
 errcode_t ext2fs_extent_delete(ext2_extent_handle_t handle, int flags)
 {
 	struct extent_path		*path;
 	char 				*cp;
 	struct ext3_extent_header	*eh;
 	errcode_t			retval = 0;
 
 	EXT2_CHECK_MAGIC(handle, EXT2_ET_MAGIC_EXTENT_HANDLE);
 
 	if (!(handle->fs->flags & EXT2_FLAG_RW))
 		return EXT2_ET_RO_FILSYS;
 
 	if (!handle->path)
 		return EXT2_ET_NO_CURRENT_NODE;
 
 #ifdef DEBUG
 	{
 		struct ext2fs_extent	extent;
 
 		retval = ext2fs_extent_get(handle, EXT2_EXTENT_CURRENT,
 					   &extent);
 		if (retval == 0) {
 			printf("extent delete %u ", handle->ino);
 			dbg_print_extent(0, &extent);
 		}
 	}
 #endif
 
 	path = handle->path + handle->level;
 	if (!path->curr)
 		return EXT2_ET_NO_CURRENT_NODE;
 
 	cp = path->curr;
 
+	/* Sanity check before memmove() */
+	if (path->left < 0)
+		return EXT2_ET_EXTENT_LEAF_BAD;
+
 	if (path->left) {
 		memmove(cp, cp + sizeof(struct ext3_extent_idx),
 			path->left * sizeof(struct ext3_extent_idx));
 		path->left--;
 	} else {
 		struct ext3_extent_idx	*ix = path->curr;
 		ix--;
 		path->curr = ix;
 	}
 	if (--path->entries == 0)
 		path->curr = 0;
 
 	/* if non-root node has no entries left, remove it & parent ptr to it */
 	if (path->entries == 0 && handle->level) {
 		if (!(flags & EXT2_EXTENT_DELETE_KEEP_EMPTY)) {
 			struct ext2fs_extent	extent;
 
 			retval = ext2fs_extent_get(handle, EXT2_EXTENT_UP,
 								&extent);
 			if (retval)
 				return retval;
 
 			retval = ext2fs_extent_delete(handle, flags);
 			handle->inode->i_blocks -=
 				(handle->fs->blocksize *
 				 EXT2FS_CLUSTER_RATIO(handle->fs)) / 512;
 			retval = ext2fs_write_inode(handle->fs, handle->ino,
 						    handle->inode);
 			ext2fs_block_alloc_stats2(handle->fs,
 						  extent.e_pblk, -1);
 		}
 	} else {
 		eh = (struct ext3_extent_header *) path->buf;
 		eh->eh_entries = ext2fs_cpu_to_le16(path->entries);
 		if ((path->entries == 0) && (handle->level == 0)) {
 			eh->eh_depth = 0;
 			handle->max_depth = 0;
 		}
 		retval = update_path(handle);
 	}
 	return retval;
 }
diff --git a/lib/ext2fs/openfs.c b/lib/ext2fs/openfs.c
index 5ec8ed5c..bda8274f 100644
--- a/lib/ext2fs/openfs.c
+++ b/lib/ext2fs/openfs.c
@@ -202,291 +202,295 @@ errcode_t ext2fs_open2(const char *name, const char *io_options,
 	/*
 	 * If the user specifies a specific block # for the
 	 * superblock, then he/she must also specify the block size!
 	 * Otherwise, read the master superblock located at offset
 	 * SUPERBLOCK_OFFSET from the start of the partition.
 	 *
 	 * Note: we only save a backup copy of the superblock if we
 	 * are reading the superblock from the primary superblock location.
 	 */
 	if (superblock) {
 		if (!block_size) {
 			retval = EXT2_ET_INVALID_ARGUMENT;
 			goto cleanup;
 		}
 		io_channel_set_blksize(fs->io, block_size);
 		group_block = superblock;
 		fs->orig_super = 0;
 	} else {
 		io_channel_set_blksize(fs->io, SUPERBLOCK_OFFSET);
 		superblock = 1;
 		group_block = 0;
 		retval = ext2fs_get_mem(SUPERBLOCK_SIZE, &fs->orig_super);
 		if (retval)
 			goto cleanup;
 	}
 retry:
 	retval = io_channel_read_blk(fs->io, superblock, -SUPERBLOCK_SIZE,
 				     fs->super);
 	if (retval)
 		goto cleanup;
 	if (fs->orig_super)
 		memcpy(fs->orig_super, fs->super, SUPERBLOCK_SIZE);
 
 	if (!(fs->flags & EXT2_FLAG_IGNORE_CSUM_ERRORS)) {
 		retval = 0;
 		if (!ext2fs_verify_csum_type(fs, fs->super))
 			retval = EXT2_ET_UNKNOWN_CSUM;
 		if (!ext2fs_superblock_csum_verify(fs, fs->super)) {
 			if (csum_retries++ < 3)
 				goto retry;
 			retval = EXT2_ET_SB_CSUM_INVALID;
 		}
 	}
 
 #ifdef WORDS_BIGENDIAN
 	fs->flags |= EXT2_FLAG_SWAP_BYTES;
 	ext2fs_swap_super(fs->super);
 #else
 	if (fs->flags & EXT2_FLAG_SWAP_BYTES) {
 		retval = EXT2_ET_UNIMPLEMENTED;
 		goto cleanup;
 	}
 #endif
 
 	if (fs->super->s_magic != EXT2_SUPER_MAGIC)
 		retval = EXT2_ET_BAD_MAGIC;
 	if (retval)
 		goto cleanup;
 
 	if (fs->super->s_rev_level > EXT2_LIB_CURRENT_REV) {
 		retval = EXT2_ET_REV_TOO_HIGH;
 		goto cleanup;
 	}
 
 	/*
 	 * Check for feature set incompatibility
 	 */
 	if (!(flags & EXT2_FLAG_FORCE)) {
 		features = fs->super->s_feature_incompat;
 #ifdef EXT2_LIB_SOFTSUPP_INCOMPAT
 		if (flags & EXT2_FLAG_SOFTSUPP_FEATURES)
 			features &= ~EXT2_LIB_SOFTSUPP_INCOMPAT;
 #endif
 		if (features & ~EXT2_LIB_FEATURE_INCOMPAT_SUPP) {
 			retval = EXT2_ET_UNSUPP_FEATURE;
 			goto cleanup;
 		}
 
 		features = fs->super->s_feature_ro_compat;
 #ifdef EXT2_LIB_SOFTSUPP_RO_COMPAT
 		if (flags & EXT2_FLAG_SOFTSUPP_FEATURES)
 			features &= ~EXT2_LIB_SOFTSUPP_RO_COMPAT;
 #endif
 		if ((flags & EXT2_FLAG_RW) &&
 		    (features & ~EXT2_LIB_FEATURE_RO_COMPAT_SUPP)) {
 			retval = EXT2_ET_RO_UNSUPP_FEATURE;
 			goto cleanup;
 		}
 
 		if (!(flags & EXT2_FLAG_JOURNAL_DEV_OK) &&
 		    ext2fs_has_feature_journal_dev(fs->super)) {
 			retval = EXT2_ET_UNSUPP_FEATURE;
 			goto cleanup;
 		}
 	}
 
-	if (fs->super->s_log_block_size >
-	    (unsigned) (EXT2_MAX_BLOCK_LOG_SIZE - EXT2_MIN_BLOCK_LOG_SIZE)) {
+	if ((fs->super->s_log_block_size >
+	     (unsigned) (EXT2_MAX_BLOCK_LOG_SIZE - EXT2_MIN_BLOCK_LOG_SIZE)) ||
+	    (fs->super->s_log_cluster_size >
+	     (unsigned) (EXT2_MAX_CLUSTER_LOG_SIZE - EXT2_MIN_CLUSTER_LOG_SIZE)) ||
+	    (fs->super->s_log_block_size > fs->super->s_log_cluster_size) ||
+	    (fs->super->s_log_groups_per_flex > 31)) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}
 
 	/*
 	 * bigalloc requires cluster-aware bitfield operations, which at the
 	 * moment means we need EXT2_FLAG_64BITS.
 	 */
 	if (ext2fs_has_feature_bigalloc(fs->super) &&
 	    !(flags & EXT2_FLAG_64BITS)) {
 		retval = EXT2_ET_CANT_USE_LEGACY_BITMAPS;
 		goto cleanup;
 	}
 
 	if (!ext2fs_has_feature_bigalloc(fs->super) &&
 	    (fs->super->s_log_block_size != fs->super->s_log_cluster_size)) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}
 	fs->fragsize = fs->blocksize = EXT2_BLOCK_SIZE(fs->super);
 	inode_size = EXT2_INODE_SIZE(fs->super);
 	if ((inode_size < EXT2_GOOD_OLD_INODE_SIZE) ||
 	    (inode_size > fs->blocksize) ||
 	    (inode_size & (inode_size - 1))) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}
 
 	/* Enforce the block group descriptor size */
 	if (ext2fs_has_feature_64bit(fs->super)) {
 		if (fs->super->s_desc_size < EXT2_MIN_DESC_SIZE_64BIT) {
 			retval = EXT2_ET_BAD_DESC_SIZE;
 			goto cleanup;
 		}
 	}
 
 	fs->cluster_ratio_bits = fs->super->s_log_cluster_size -
 		fs->super->s_log_block_size;
 	if (EXT2_BLOCKS_PER_GROUP(fs->super) !=
 	    EXT2_CLUSTERS_PER_GROUP(fs->super) << fs->cluster_ratio_bits) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}
 	fs->inode_blocks_per_group = ((EXT2_INODES_PER_GROUP(fs->super) *
 				       EXT2_INODE_SIZE(fs->super) +
 				       EXT2_BLOCK_SIZE(fs->super) - 1) /
 				      EXT2_BLOCK_SIZE(fs->super));
 	if (block_size) {
 		if (block_size != fs->blocksize) {
 			retval = EXT2_ET_UNEXPECTED_BLOCK_SIZE;
 			goto cleanup;
 		}
 	}
 	/*
 	 * Set the blocksize to the filesystem's blocksize.
 	 */
 	io_channel_set_blksize(fs->io, fs->blocksize);
 
 	/*
 	 * If this is an external journal device, don't try to read
 	 * the group descriptors, because they're not there.
 	 */
 	if (ext2fs_has_feature_journal_dev(fs->super)) {
 		fs->group_desc_count = 0;
 		*ret_fs = fs;
 		return 0;
 	}
 
 	if (EXT2_INODES_PER_GROUP(fs->super) == 0) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}
 	/* Precompute the FS UUID to seed other checksums */
 	ext2fs_init_csum_seed(fs);
 
 	/*
 	 * Read group descriptors
 	 */
 	blocks_per_group = EXT2_BLOCKS_PER_GROUP(fs->super);
 	if (blocks_per_group == 0 ||
 	    blocks_per_group > EXT2_MAX_BLOCKS_PER_GROUP(fs->super) ||
 	    fs->inode_blocks_per_group > EXT2_MAX_INODES_PER_GROUP(fs->super) ||
            EXT2_DESC_PER_BLOCK(fs->super) == 0 ||
            fs->super->s_first_data_block >= ext2fs_blocks_count(fs->super)) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}
 	groups_cnt = ext2fs_div64_ceil(ext2fs_blocks_count(fs->super) -
 				       fs->super->s_first_data_block,
 				       blocks_per_group);
 	if (groups_cnt >> 32) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}
 	fs->group_desc_count = 	groups_cnt;
 	if (!(flags & EXT2_FLAG_IGNORE_SB_ERRORS) &&
 	    (__u64)fs->group_desc_count * EXT2_INODES_PER_GROUP(fs->super) !=
 	    fs->super->s_inodes_count) {
 		retval = EXT2_ET_CORRUPT_SUPERBLOCK;
 		goto cleanup;
 	}
 	fs->desc_blocks = ext2fs_div_ceil(fs->group_desc_count,
 					  EXT2_DESC_PER_BLOCK(fs->super));
 	if (flags & EXT2_FLAG_SUPER_ONLY)
 		goto skip_read_bg;
 	retval = ext2fs_get_array(fs->desc_blocks, fs->blocksize,
 				&fs->group_desc);
 	if (retval)
 		goto cleanup;
 	if (!group_block)
 		group_block = fs->super->s_first_data_block;
 	/*
 	 * On a FS with a 1K blocksize, block 0 is reserved for bootloaders
 	 * so we must increment block numbers to any group 0 items.
 	 *
 	 * However, we cannot touch group_block directly because in the meta_bg
 	 * case, the ext2fs_descriptor_block_loc2() function will interpret
 	 * group_block != s_first_data_block to mean that we want to access the
 	 * backup group descriptors.  This is not what we want if the caller
 	 * set superblock == 0 (i.e. auto-detect the superblock), which is
 	 * what's going on here.
 	 */
 	if (group_block == 0 && fs->blocksize == 1024)
 		group_zero_adjust = 1;
 	dest = (char *) fs->group_desc;
 #ifdef WORDS_BIGENDIAN
 	groups_per_block = EXT2_DESC_PER_BLOCK(fs->super);
 #endif
 	if (ext2fs_has_feature_meta_bg(fs->super) &&
 	    !(flags & EXT2_FLAG_IMAGE_FILE)) {
 		first_meta_bg = fs->super->s_first_meta_bg;
 		if (first_meta_bg > fs->desc_blocks)
 			first_meta_bg = fs->desc_blocks;
 	} else
 		first_meta_bg = fs->desc_blocks;
 	if (first_meta_bg) {
 		retval = io_channel_read_blk(fs->io, group_block +
 					     group_zero_adjust + 1,
 					     first_meta_bg, dest);
 		if (retval)
 			goto cleanup;
 #ifdef WORDS_BIGENDIAN
 		gdp = (struct ext2_group_desc *) dest;
 		for (j=0; j < groups_per_block*first_meta_bg; j++) {
 			gdp = ext2fs_group_desc(fs, fs->group_desc, j);
 			if (gdp)
 				ext2fs_swap_group_desc2(fs, gdp);
 		}
 #endif
 		dest += fs->blocksize*first_meta_bg;
 	}
 
 	for (i = first_meta_bg ; i < fs->desc_blocks; i++) {
 		blk = ext2fs_descriptor_block_loc2(fs, group_block, i);
 		io_channel_cache_readahead(fs->io, blk, 1);
 	}
 
 	for (i=first_meta_bg ; i < fs->desc_blocks; i++) {
 		blk = ext2fs_descriptor_block_loc2(fs, group_block, i);
 		retval = io_channel_read_blk64(fs->io, blk, 1, dest);
 		if (retval)
 			goto cleanup;
 #ifdef WORDS_BIGENDIAN
 		for (j=0; j < groups_per_block; j++) {
 			gdp = ext2fs_group_desc(fs, fs->group_desc,
 						i * groups_per_block + j);
 			if (gdp)
 				ext2fs_swap_group_desc2(fs, gdp);
 		}
 #endif
 		dest += fs->blocksize;
 	}
 
 	fs->stride = fs->super->s_raid_stride;
 
 	/*
 	 * If recovery is from backup superblock, Clear _UNININT flags &
 	 * reset bg_itable_unused to zero
 	 */
 	if (superblock > 1 && ext2fs_has_group_desc_csum(fs)) {
 		dgrp_t group;
 
 		for (group = 0; group < fs->group_desc_count; group++) {
 			ext2fs_bg_flags_clear(fs, group, EXT2_BG_BLOCK_UNINIT);
 			ext2fs_bg_flags_clear(fs, group, EXT2_BG_INODE_UNINIT);
 			ext2fs_bg_itable_unused_set(fs, group, 0);
 			/* The checksum will be reset later, but fix it here
 			 * anyway to avoid printing a lot of spurious errors. */
 			ext2fs_group_desc_csum_set(fs, group);
 		}
 		if (fs->flags & EXT2_FLAG_RW)
 			ext2fs_mark_super_dirty(fs);
 	}
diff --git a/lib/ext2fs/punch.c b/lib/ext2fs/punch.c
index effa1e2d..e2543e1e 100644
--- a/lib/ext2fs/punch.c
+++ b/lib/ext2fs/punch.c
@@ -192,63 +192,67 @@ static void dbg_print_extent(char *desc, struct ext2fs_extent *extent)
 /* Free a range of blocks, respecting cluster boundaries */
 static errcode_t punch_extent_blocks(ext2_filsys fs, ext2_ino_t ino,
 				     struct ext2_inode *inode,
 				     blk64_t lfree_start, blk64_t free_start,
 				     __u32 free_count, int *freed)
 {
 	blk64_t		pblk;
 	int		freed_now = 0;
 	__u32		cluster_freed;
 	errcode_t	retval = 0;
 
+	if (free_start < fs->super->s_first_data_block ||
+	    (free_start + free_count) >= ext2fs_blocks_count(fs->super))
+		return EXT2_ET_BAD_BLOCK_NUM;
+
 	/* No bigalloc?  Just free each block. */
 	if (EXT2FS_CLUSTER_RATIO(fs) == 1) {
 		*freed += free_count;
 		while (free_count-- > 0)
 			ext2fs_block_alloc_stats2(fs, free_start++, -1);
 		return retval;
 	}
 
 	/*
 	 * Try to free up to the next cluster boundary.  We assume that all
 	 * blocks in a logical cluster map to blocks from the same physical
 	 * cluster, and that the offsets within the [pl]clusters match.
 	 */
 	if (free_start & EXT2FS_CLUSTER_MASK(fs)) {
 		retval = ext2fs_map_cluster_block(fs, ino, inode,
 						  lfree_start, &pblk);
 		if (retval)
 			goto errout;
 		if (!pblk) {
 			ext2fs_block_alloc_stats2(fs, free_start, -1);
 			freed_now++;
 		}
 		cluster_freed = EXT2FS_CLUSTER_RATIO(fs) -
 			(free_start & EXT2FS_CLUSTER_MASK(fs));
 		if (cluster_freed > free_count)
 			cluster_freed = free_count;
 		free_count -= cluster_freed;
 		free_start += cluster_freed;
 		lfree_start += cluster_freed;
 	}
 
 	/* Free whole clusters from the middle of the range. */
 	while (free_count > 0 && free_count >= (unsigned) EXT2FS_CLUSTER_RATIO(fs)) {
 		ext2fs_block_alloc_stats2(fs, free_start, -1);
 		freed_now++;
 		cluster_freed = EXT2FS_CLUSTER_RATIO(fs);
 		free_count -= cluster_freed;
 		free_start += cluster_freed;
 		lfree_start += cluster_freed;
 	}
 
 	/* Try to free the last cluster. */
 	if (free_count > 0) {
 		retval = ext2fs_map_cluster_block(fs, ino, inode,
 						  lfree_start, &pblk);
 		if (retval)
 			goto errout;
 		if (!pblk) {
 			ext2fs_block_alloc_stats2(fs, free_start, -1);
 			freed_now++;
 		}
 	}
diff --git a/lib/ext2fs/test_io.c b/lib/ext2fs/test_io.c
index 480e68fc..6843edbc 100644
--- a/lib/ext2fs/test_io.c
+++ b/lib/ext2fs/test_io.c
@@ -248,9 +248,11 @@ static errcode_t test_open(const char *name, int flags, io_channel *channel)
 	return 0;
 
 cleanup:
+	if (io && io->name)
+		ext2fs_free_mem(&io->name);
 	if (io)
 		ext2fs_free_mem(&io);
 	if (data)
 		ext2fs_free_mem(&data);
 	return retval;
 }
diff --git a/lib/ext2fs/undo_io.c b/lib/ext2fs/undo_io.c
index eb56f53d..f4a6d526 100644
--- a/lib/ext2fs/undo_io.c
+++ b/lib/ext2fs/undo_io.c
@@ -781,16 +781,18 @@ static errcode_t undo_open(const char *name, int flags, io_channel *channel)
 cleanup:
 	ext2fs_remove_exit_fn(undo_atexit, data);
 	if (undo_fd >= 0)
 		close(undo_fd);
 	if (data && data->undo_file)
 		io_channel_close(data->undo_file);
 	if (data && data->tdb_file)
 		free(data->tdb_file);
 	if (data && data->real)
 		io_channel_close(data->real);
 	if (data)
 		ext2fs_free_mem(&data);
+	if (io && io->name)
+		ext2fs_free_mem(&io->name);
 	if (io)
 		ext2fs_free_mem(&io);
 	return retval;
 }
diff --git a/lib/ss/execute_cmd.c b/lib/ss/execute_cmd.c
index d443a468..2e2c8cfa 100644
--- a/lib/ss/execute_cmd.c
+++ b/lib/ss/execute_cmd.c
@@ -165,31 +165,33 @@ static int really_execute_command(int sci_idx, int argc, char **argv[])
 int ss_execute_command(int sci_idx, register char *argv[])
 {
 	register int i, argc;
 	char **argp;
 
 	argc = 0;
 	for (argp = argv; *argp; argp++)
 		argc++;
 	argp = (char **)malloc((argc+1)*sizeof(char *));
+	if (!argp)
+		return(ENOMEM);
 	for (i = 0; i <= argc; i++)
 		argp[i] = argv[i];
 	i = really_execute_command(sci_idx, argc, &argp);
 	free(argp);
 	return(i);
 }
 
 /*
  * ss_execute_line(sci_idx, line_ptr)
  *
  * Function:
  *      Parses and executes a command line within a subsystem.
  * Arguments:
  *      sci_idx (int)
  *              ss-internal index for subsystem control info structure
  *      line_ptr (char *)
  *              Pointer to command line to be parsed.
  * Returns:
  *      (int)
  *      	Error code.
  * Notes:
  */
diff --git a/lib/support/mkquota.c b/lib/support/mkquota.c
index 6f4a0b90..9339c994 100644
--- a/lib/support/mkquota.c
+++ b/lib/support/mkquota.c
@@ -91,14 +91,16 @@ int quota_file_exists(ext2_filsys fs, enum quota_type qtype)
 /*
  * Set the value for reserved quota inode number field in superblock.
  */
 void quota_set_sb_inum(ext2_filsys fs, ext2_ino_t ino, enum quota_type qtype)
 {
 	ext2_ino_t *inump;
 
 	inump = quota_sb_inump(fs->super, qtype);
 
 	log_debug("setting quota ino in superblock: ino=%u, type=%d", ino,
 		 qtype);
+	if (inump == NULL)
+		return;
 	*inump = ino;
 	ext2fs_mark_super_dirty(fs);
 }
diff --git a/misc/chattr.1.in b/misc/chattr.1.in
index 922410b6..cd2e0020 100644
--- a/misc/chattr.1.in
+++ b/misc/chattr.1.in
@@ -23,44 +23,77 @@ chattr \- change file attributes on a Linux file system
 .B chattr
 changes the file attributes on a Linux file system.
 .PP
-The format of a symbolic mode is +-=[aAcCdDeFijmPsStTux].
+The format of a symbolic
+.I mode
+is
+.BR +-= [ aAcCdDeFijmPsStTux ].
 .PP
-The operator '+' causes the selected attributes to be added to the
-existing attributes of the files; '-' causes them to be removed; and '='
+The operator
+.RB ' + '
+causes the selected attributes to be added to the
+existing attributes of the files;
+.RB ' - '
+causes them to be removed; and
+.RB ' = '
 causes them to be the only attributes that the files have.
 .PP
-The letters 'aAcCdDeFijmPsStTux' select the new attributes for the files:
-append only (a),
-no atime updates (A),
-compressed (c),
-no copy on write (C),
-no dump (d),
-synchronous directory updates (D),
-extent format (e),
-case-insensitive directory lookups (F),
-immutable (i),
-data journaling (j),
-don't compress (m),
-project hierarchy (P),
-secure deletion (s),
-synchronous updates (S),
-no tail-merging (t),
-top of directory hierarchy (T),
-undeletable (u),
-and direct access for files (x).
+The letters
+.RB ' aAcCdDeFijmPsStTux '
+select the new attributes for the files:
+append only
+.RB ( a ),
+no atime updates
+.RB ( A ),
+compressed
+.RB ( c ),
+no copy on write
+.RB ( C ),
+no dump
+.RB ( d ),
+synchronous directory updates
+.RB ( D ),
+extent format
+.RB ( e ),
+case-insensitive directory lookups
+.RB ( F ),
+immutable
+.RB ( i ),
+data journaling
+.RB ( j ),
+don't compress
+.RB ( m ),
+project hierarchy
+.RB ( P ),
+secure deletion
+.RB ( s ),
+synchronous updates
+.RB ( S ),
+no tail-merging
+.RB ( t ),
+top of directory hierarchy
+.RB ( T ),
+undeletable
+.RB ( u ),
+and direct access for files
+.RB ( x ).
 .PP
 The following attributes are read-only, and may be listed by
 .BR lsattr (1)
 but not modified by chattr:
-encrypted (E),
-indexed directory (I),
-inline data (N),
-and verity (V).
+encrypted
+.RB ( E ),
+indexed directory
+.RB ( I ),
+inline data
+.RB ( N ),
+and verity
+.RB ( V ).
 .PP
 Not all flags are supported or utilized by all file systems; refer to
 file system-specific man pages such as
 .BR btrfs (5),
 .BR ext4 (5),
+.BR mkfs.f2fs (8),
 and
 .BR xfs (5)
 for more file system-specific details.
@@ -256,6 +289,7 @@ is part of the e2fsprogs package and is available from
 http://e2fsprogs.sourceforge.net.
 .SH SEE ALSO
 .BR lsattr (1),
 .BR btrfs (5),
 .BR ext4 (5),
+.BR mkfs.f2fs (8),
 .BR xfs (5).
diff --git a/misc/chattr.c b/misc/chattr.c
index 644ef4e9..c7382a37 100644
--- a/misc/chattr.c
+++ b/misc/chattr.c
@@ -86,7 +86,7 @@ static unsigned long sf;
 static void usage(void)
 {
 	fprintf(stderr,
-		_("Usage: %s [-pRVf] [-+=aAcCdDeijPsStTuFx] [-v version] files...\n"),
+		_("Usage: %s [-RVf] [-+=aAcCdDeijPsStTuFx] [-p project] [-v version] files...\n"),
 		program_name);
 	exit(1);
 }
diff --git a/misc/dumpe2fs.c b/misc/dumpe2fs.c
index 3f4fc4ed..ef6d1cb8 100644
--- a/misc/dumpe2fs.c
+++ b/misc/dumpe2fs.c
@@ -324,34 +324,35 @@ static void list_desc(ext2_filsys fs, int grp_only)
 static void list_bad_blocks(ext2_filsys fs, int dump)
 {
 	badblocks_list		bb_list = 0;
 	badblocks_iterate	bb_iter;
 	blk_t			blk;
 	errcode_t		retval;
 	const char		*header, *fmt;
 
 	retval = ext2fs_read_bb_inode(fs, &bb_list);
 	if (retval) {
 		com_err("ext2fs_read_bb_inode", retval, 0);
 		return;
 	}
 	retval = ext2fs_badblocks_list_iterate_begin(bb_list, &bb_iter);
 	if (retval) {
 		com_err("ext2fs_badblocks_list_iterate_begin", retval,
 			"%s", _("while printing bad block list"));
+		ext2fs_badblocks_list_free(bb_list);
 		return;
 	}
 	if (dump) {
 		header = fmt = "%u\n";
 	} else {
 		header =  _("Bad blocks: %u");
 		fmt = ", %u";
 	}
 	while (ext2fs_badblocks_list_iterate(bb_iter, &blk)) {
 		printf(header ? header : fmt, blk);
 		header = 0;
 	}
 	ext2fs_badblocks_list_iterate_end(bb_iter);
 	if (!dump)
 		fputc('\n', stdout);
 	ext2fs_badblocks_list_free(bb_list);
 }
diff --git a/resize/resize2fs.c b/resize/resize2fs.c
index b9783e8c..cfc81fc7 100644
--- a/resize/resize2fs.c
+++ b/resize/resize2fs.c
@@ -1760,120 +1760,120 @@ static errcode_t resize2fs_get_alloc_block(ext2_filsys fs,
 static errcode_t block_mover(ext2_resize_t rfs)
 {
 	blk64_t			blk, old_blk, new_blk;
 	ext2_filsys		fs = rfs->new_fs;
 	ext2_filsys		old_fs = rfs->old_fs;
 	errcode_t		retval;
 	__u64			c, size;
 	int			to_move, moved;
 	ext2_badblocks_list	badblock_list = 0;
 	int			bb_modified = 0;
 
 	fs->get_alloc_block = resize2fs_get_alloc_block;
 	old_fs->get_alloc_block = resize2fs_get_alloc_block;
 
 	retval = ext2fs_read_bb_inode(old_fs, &badblock_list);
 	if (retval)
 		return retval;
 
 	new_blk = fs->super->s_first_data_block;
 	if (!rfs->itable_buf) {
 		retval = ext2fs_get_array(fs->blocksize,
 					fs->inode_blocks_per_group,
 					&rfs->itable_buf);
 		if (retval)
-			return retval;
+			goto errout;
 	}
 	retval = ext2fs_create_extent_table(&rfs->bmap, 0);
 	if (retval)
-		return retval;
+		goto errout;
 
 	/*
 	 * The first step is to figure out where all of the blocks
 	 * will go.
 	 */
 	to_move = moved = 0;
 	init_block_alloc(rfs);
 	for (blk = B2C(old_fs->super->s_first_data_block);
 	     blk < ext2fs_blocks_count(old_fs->super);
 	     blk += EXT2FS_CLUSTER_RATIO(fs)) {
 		if (!ext2fs_test_block_bitmap2(old_fs->block_map, blk))
 			continue;
 		if (!ext2fs_test_block_bitmap2(rfs->move_blocks, blk))
 			continue;
 		if (ext2fs_badblocks_list_test(badblock_list, blk)) {
 			ext2fs_badblocks_list_del(badblock_list, blk);
 			bb_modified++;
 			continue;
 		}
 
 		new_blk = get_new_block(rfs);
 		if (!new_blk) {
 			retval = ENOSPC;
 			goto errout;
 		}
 		ext2fs_block_alloc_stats2(fs, new_blk, +1);
 		ext2fs_add_extent_entry(rfs->bmap, B2C(blk), B2C(new_blk));
 		to_move++;
 	}
 
 	if (to_move == 0) {
 		if (rfs->bmap) {
 			ext2fs_free_extent_table(rfs->bmap);
 			rfs->bmap = 0;
 		}
 		retval = 0;
 		goto errout;
 	}
 
 	/*
 	 * Step two is to actually move the blocks
 	 */
 	retval =  ext2fs_iterate_extent(rfs->bmap, 0, 0, 0);
 	if (retval) goto errout;
 
 	if (rfs->progress) {
 		retval = (rfs->progress)(rfs, E2_RSZ_BLOCK_RELOC_PASS,
 					 0, to_move);
 		if (retval)
 			goto errout;
 	}
 	while (1) {
 		retval = ext2fs_iterate_extent(rfs->bmap, &old_blk, &new_blk, &size);
 		if (retval) goto errout;
 		if (!size)
 			break;
 		old_blk = C2B(old_blk);
 		new_blk = C2B(new_blk);
 		size = C2B(size);
 #ifdef RESIZE2FS_DEBUG
 		if (rfs->flags & RESIZE_DEBUG_BMOVE)
 			printf("Moving %llu blocks %llu->%llu\n",
 			       (unsigned long long) size,
 			       (unsigned long long) old_blk,
 			       (unsigned long long) new_blk);
 #endif
 		do {
 			c = size;
 			if (c > fs->inode_blocks_per_group)
 				c = fs->inode_blocks_per_group;
 			retval = io_channel_read_blk64(fs->io, old_blk, c,
 						       rfs->itable_buf);
 			if (retval) goto errout;
 			retval = io_channel_write_blk64(fs->io, new_blk, c,
 							rfs->itable_buf);
 			if (retval) goto errout;
 			size -= c;
 			new_blk += c;
 			old_blk += c;
 			moved += c;
 			if (rfs->progress) {
 				io_channel_flush(fs->io);
 				retval = (rfs->progress)(rfs,
 						E2_RSZ_BLOCK_RELOC_PASS,
 						moved, to_move);
 				if (retval)
 					goto errout;
 			}
 		} while (size > 0);
 		io_channel_flush(fs->io);
 	}
@@ -2178,109 +2178,110 @@ out:
 }
 static errcode_t inode_scan_and_fix(ext2_resize_t rfs)
 {
 	struct process_block_struct	pb;
 	ext2_ino_t		ino, new_inode;
 	struct ext2_inode 	*inode = NULL;
 	ext2_inode_scan 	scan = NULL;
 	errcode_t		retval;
 	char			*block_buf = 0;
 	ext2_ino_t		start_to_move;
 	int			inode_size;
 	int			update_ea_inode_refs = 0;
 
 	if ((rfs->old_fs->group_desc_count <=
 	     rfs->new_fs->group_desc_count) &&
 	    !rfs->bmap)
 		return 0;
 
 	set_com_err_hook(quiet_com_err_proc);
 
 	retval = ext2fs_open_inode_scan(rfs->old_fs, 0, &scan);
 	if (retval) goto errout;
 
 	retval = ext2fs_init_dblist(rfs->old_fs, 0);
 	if (retval) goto errout;
 	retval = ext2fs_get_array(rfs->old_fs->blocksize, 3, &block_buf);
 	if (retval) goto errout;
 
 	start_to_move = (rfs->new_fs->group_desc_count *
 			 rfs->new_fs->super->s_inodes_per_group);
 
 	if (rfs->progress) {
 		retval = (rfs->progress)(rfs, E2_RSZ_INODE_SCAN_PASS,
 					 0, rfs->old_fs->group_desc_count);
 		if (retval)
 			goto errout;
 	}
 	ext2fs_set_inode_callback(scan, progress_callback, (void *) rfs);
 	pb.rfs = rfs;
 	pb.inode = inode;
 	pb.error = 0;
 	new_inode = EXT2_FIRST_INODE(rfs->new_fs->super);
 	inode_size = EXT2_INODE_SIZE(rfs->new_fs->super);
 	inode = malloc(inode_size);
 	if (!inode) {
 		retval = ENOMEM;
 		goto errout;
 	}
 	/*
 	 * First, copy all of the inodes that need to be moved
 	 * elsewhere in the inode table
 	 */
 	while (1) {
 		retval = ext2fs_get_next_inode_full(scan, &ino, inode, inode_size);
 		if (retval) goto errout;
 		if (!ino)
 			break;
 
 		if (inode->i_links_count == 0 && ino != EXT2_RESIZE_INO)
 			continue; /* inode not in use */
 
 		pb.is_dir = LINUX_S_ISDIR(inode->i_mode);
 		pb.changed = 0;
 
 		/* Remap EA block */
 		retval = migrate_ea_block(rfs, ino, inode, &pb.changed);
 		if (retval)
 			goto errout;
 
 		new_inode = ino;
 		if (ino <= start_to_move)
 			goto remap_blocks; /* Don't need to move inode. */
 
 		/*
 		 * Find a new inode.  Now that extents and directory blocks
 		 * are tied to the inode number through the checksum, we must
 		 * set up the new inode before we start rewriting blocks.
 		 */
 		retval = ext2fs_new_inode(rfs->new_fs, 0, 0, 0, &new_inode);
 		if (retval)
 			goto errout;
 
 		ext2fs_inode_alloc_stats2(rfs->new_fs, new_inode, +1,
 					  pb.is_dir);
 		/*
 		 * i_ctime field in xattr inodes contain a portion of the ref
 		 * count, do not overwrite.
 		 */
 		if (inode->i_flags & EXT4_EA_INODE_FL)
 			update_ea_inode_refs = 1;
 		else
-			inode->i_ctime = time(0);
+			inode->i_ctime = rfs->old_fs->now ?
+				rfs->old_fs->now : time(0);
 
 		retval = ext2fs_write_inode_full(rfs->old_fs, new_inode,
 						inode, inode_size);
 		if (retval)
 			goto errout;
 		pb.changed = 0;
 
 #ifdef RESIZE2FS_DEBUG
 		if (rfs->flags & RESIZE_DEBUG_INODEMAP)
 			printf("Inode moved %u->%u\n", ino, new_inode);
 #endif
 		if (!rfs->imap) {
 			retval = ext2fs_create_extent_table(&rfs->imap, 0);
 			if (retval)
 				goto errout;
 		}
 		ext2fs_add_extent_entry(rfs->imap, ino, new_inode);
@@ -2373,57 +2374,58 @@ struct istruct {
 static int check_and_change_inodes(ext2_ino_t dir,
 				   int entry EXT2FS_ATTR((unused)),
 				   struct ext2_dir_entry *dirent, int offset,
 				   int	blocksize EXT2FS_ATTR((unused)),
 				   char *buf EXT2FS_ATTR((unused)),
 				   void *priv_data)
 {
 	struct istruct *is = (struct istruct *) priv_data;
 	struct ext2_inode 	inode;
 	ext2_ino_t		new_inode;
 	errcode_t		retval;
 	int			ret = 0;
 
 	if (is->rfs->progress && offset == 0) {
 		io_channel_flush(is->rfs->old_fs->io);
 		is->err = (is->rfs->progress)(is->rfs,
 					      E2_RSZ_INODE_REF_UPD_PASS,
 					      ++is->num, is->max_dirs);
 		if (is->err)
 			return DIRENT_ABORT;
 	}
 
 	/*
 	 * If we have checksums enabled and the inode wasn't present in the
 	 * old fs, then we must rewrite all dir blocks with new checksums.
 	 */
 	if (ext2fs_has_feature_metadata_csum(is->rfs->old_fs->super) &&
 	    !ext2fs_test_inode_bitmap2(is->rfs->old_fs->inode_map, dir))
 		ret |= DIRENT_CHANGED;
 
 	if (!dirent->inode)
 		return ret;
 
 	new_inode = ext2fs_extent_translate(is->rfs->imap, dirent->inode);
 
 	if (!new_inode)
 		return ret;
 #ifdef RESIZE2FS_DEBUG
 	if (is->rfs->flags & RESIZE_DEBUG_INODEMAP)
 		printf("Inode translate (dir=%u, name=%.*s, %u->%u)\n",
 		       dir, ext2fs_dirent_name_len(dirent), dirent->name,
 		       dirent->inode, new_inode);
 #endif
 
 	dirent->inode = new_inode;
 
 	/* Update the directory mtime and ctime */
 	retval = ext2fs_read_inode(is->rfs->old_fs, dir, &inode);
 	if (retval == 0) {
-		inode.i_mtime = inode.i_ctime = time(0);
+		inode.i_mtime = inode.i_ctime = is->rfs->old_fs->now ?
+			is->rfs->old_fs->now : time(0);
 		is->err = ext2fs_write_inode(is->rfs->old_fs, dir, &inode);
 		if (is->err)
 			return ret | DIRENT_ABORT;
 	}
 
 	return ret | DIRENT_CHANGED;
 }
@@ -2842,77 +2844,77 @@ errout:
 /*
  * Finally, recalculate the summary information
  */
 static errcode_t resize2fs_calculate_summary_stats(ext2_filsys fs)
 {
 	errcode_t	retval;
 	blk64_t		blk = fs->super->s_first_data_block;
 	ext2_ino_t	ino;
-	unsigned int	n, c, group, count;
+	unsigned int	n, group, count;
 	blk64_t		total_clusters_free = 0;
 	int		total_inodes_free = 0;
 	int		group_free = 0;
 	int		uninit = 0;
 	char		*bitmap_buf;
 
 	/*
 	 * First calculate the block statistics
 	 */
 	bitmap_buf = malloc(fs->blocksize);
 	if (!bitmap_buf)
 		return ENOMEM;
 	for (group = 0; group < fs->group_desc_count;
 	     group++) {
 		retval = ext2fs_get_block_bitmap_range2(fs->block_map,
 			B2C(blk), fs->super->s_clusters_per_group, bitmap_buf);
 		if (retval) {
 			free(bitmap_buf);
 			return retval;
 		}
 		n = ext2fs_bitcount(bitmap_buf,
 				    fs->super->s_clusters_per_group / 8);
 		group_free = fs->super->s_clusters_per_group - n;
 		total_clusters_free += group_free;
 		ext2fs_bg_free_blocks_count_set(fs, group, group_free);
 		ext2fs_group_desc_csum_set(fs, group);
 		blk += fs->super->s_blocks_per_group;
 	}
 	free(bitmap_buf);
 	ext2fs_free_blocks_count_set(fs->super, C2B(total_clusters_free));
 
 	/*
 	 * Next, calculate the inode statistics
 	 */
 	group_free = 0;
 	count = 0;
 	group = 0;
 
 	/* Protect loop from wrap-around if s_inodes_count maxed */
 	uninit = ext2fs_bg_flags_test(fs, group, EXT2_BG_INODE_UNINIT);
 	for (ino = 1; ino <= fs->super->s_inodes_count && ino > 0; ino++) {
 		if (uninit ||
 		    !ext2fs_fast_test_inode_bitmap2(fs->inode_map, ino)) {
 			group_free++;
 			total_inodes_free++;
 		}
 		count++;
 		if ((count == fs->super->s_inodes_per_group) ||
 		    (ino == fs->super->s_inodes_count)) {
 			ext2fs_bg_free_inodes_count_set(fs, group, group_free);
 			ext2fs_group_desc_csum_set(fs, group);
 			group++;
 			if (group >= fs->group_desc_count)
 				break;
 			count = 0;
 			group_free = 0;
 			uninit = ext2fs_bg_flags_test(fs, group, EXT2_BG_INODE_UNINIT);
 		}
 	}
 	fs->super->s_free_inodes_count = total_inodes_free;
 	ext2fs_mark_super_dirty(fs);
 	return 0;
 }
 
 /*
  *  Journal may have been relocated; update the backup journal blocks
  *  in the superblock.
  */
diff --git a/resize/resource_track.c b/resize/resource_track.c
index f0efe114..f4667060 100644
--- a/resize/resource_track.c
+++ b/resize/resource_track.c
@@ -60,65 +60,72 @@ static float timeval_subtract(struct timeval *tv1,
 void print_resource_track(ext2_resize_t rfs, struct resource_track *track,
 			  io_channel channel)
 {
 #ifdef HAVE_GETRUSAGE
 	struct rusage r;
 #endif
-#ifdef HAVE_MALLINFO
-	struct mallinfo	malloc_info;
+#ifdef HAVE_MALLINFO2
+	struct mallinfo2 malloc_info;
+#elif defined HAVE_MALLINFO
+	struct mallinfo malloc_info;
 #endif
 	struct timeval time_end;
 
 	if ((rfs->flags & RESIZE_DEBUG_RTRACK) == 0)
 		return;
 
 	gettimeofday(&time_end, 0);
 
 	if (track->desc)
 		printf("%s: ", track->desc);
 
-#ifdef HAVE_MALLINFO
 #define kbytes(x)	(((unsigned long)(x) + 1023) / 1024)
+#ifdef HAVE_MALLINFO2
+	malloc_info = mallinfo2();
+	printf("Memory used: %luk/%luk (%luk/%luk), ",
+		kbytes(malloc_info.arena), kbytes(malloc_info.hblkhd),
+		kbytes(malloc_info.uordblks), kbytes(malloc_info.fordblks));
+#elif defined HAVE_MALLINFO
 
 	malloc_info = mallinfo();
 	printf("Memory used: %luk/%luk (%luk/%luk), ",
 		kbytes(malloc_info.arena), kbytes(malloc_info.hblkhd),
 		kbytes(malloc_info.uordblks), kbytes(malloc_info.fordblks));
 #else
 	printf("Memory used: %lu, ",
 		(unsigned long) (((char *) sbrk(0)) -
 				 ((char *) track->brk_start)));
 #endif
 #ifdef HAVE_GETRUSAGE
 	getrusage(RUSAGE_SELF, &r);
 
 	printf("time: %5.2f/%5.2f/%5.2f\n",
 		timeval_subtract(&time_end, &track->time_start),
 		timeval_subtract(&r.ru_utime, &track->user_start),
 		timeval_subtract(&r.ru_stime, &track->system_start));
 #else
 	printf("elapsed time: %6.3f\n",
 		timeval_subtract(&time_end, &track->time_start));
 #endif
 #define mbytes(x)	(((x) + 1048575) / 1048576)
 	if (channel && channel->manager && channel->manager->get_stats) {
 		io_stats delta = 0;
 		unsigned long long bytes_read = 0;
 		unsigned long long bytes_written = 0;
 
 		channel->manager->get_stats(channel, &delta);
 		if (delta) {
 			bytes_read = delta->bytes_read - track->bytes_read;
 			bytes_written = delta->bytes_written -
 				track->bytes_written;
 			if (bytes_read == 0 && bytes_written == 0)
 				goto skip_io;
 			if (track->desc)
 				printf("%s: ", track->desc);
 			printf("I/O read: %lluMB, write: %lluMB, "
 			       "rate: %.2fMB/s\n",
 			       mbytes(bytes_read),
 			       mbytes(bytes_written),
 			       (double)mbytes(bytes_read + bytes_written) /
 			       timeval_subtract(&time_end, &track->time_start));
 		}
 	}
diff --git a/tests/f_bad_encryption/expect.1 b/tests/f_bad_encryption/expect.1
index d743e66f..70270959 100644
--- a/tests/f_bad_encryption/expect.1
+++ b/tests/f_bad_encryption/expect.1
@@ -54,13 +54,13 @@ Encrypted entry '\M-ggCeM-/?M-^BM-{(M-^OM-9M-^QQAM-^N=M-c^Mo' in /edir (12) refe
 Clear? yes
 
 Pass 3: Checking directory connectivity
-Unconnected directory inode 18 (/edir/???)
+Unconnected directory inode 18 (was in /edir)
 Connect to /lost+found? yes
 
-Unconnected directory inode 24 (/edir/???)
+Unconnected directory inode 24 (was in /edir)
 Connect to /lost+found? yes
 
-Unconnected directory inode 27 (/edir/???)
+Unconnected directory inode 27 (was in /edir)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_badroot/expect.1 b/tests/f_badroot/expect.1
index f9d01e57..ff924268 100644
--- a/tests/f_badroot/expect.1
+++ b/tests/f_badroot/expect.1
@@ -9,7 +9,7 @@ Entry '..' in <2>/<11> (11) has deleted/unused inode 2.  Clear? yes
 Pass 3: Checking directory connectivity
 Root inode not allocated.  Allocate? yes
 
-Unconnected directory inode 11 (...)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes
diff --git a/tests/f_encrypted_lpf/expect.1 b/tests/f_encrypted_lpf/expect.1
index 7e215b7d..63ac5f3b 100644
--- a/tests/f_encrypted_lpf/expect.1
+++ b/tests/f_encrypted_lpf/expect.1
@@ -1,7 +1,7 @@
 Pass 1: Checking inodes, blocks, and sizes
 Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
-Unconnected directory inode 12 (/???)
+Unconnected directory inode 12 (was in /)
 Connect to /lost+found? yes
 
 /lost+found is encrypted
@@ -13,7 +13,7 @@ Restarting e2fsck from the beginning...
 Pass 1: Checking inodes, blocks, and sizes
 Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
-Unconnected directory inode 11 (/???)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 Pass 3A: Optimizing directories
diff --git a/tests/f_expand/expect.1.gz b/tests/f_expand/expect.1.gz
index 1015e155..81fe7dd6 100644
Binary files a/tests/f_expand/expect.1.gz and b/tests/f_expand/expect.1.gz differ
diff --git a/tests/f_lpf2/expect.1 b/tests/f_lpf2/expect.1
index 633586cc..ab5d9ba3 100644
--- a/tests/f_lpf2/expect.1
+++ b/tests/f_lpf2/expect.1
@@ -1,12 +1,12 @@
 Pass 1: Checking inodes, blocks, and sizes
 Pass 2: Checking directory structure
 Pass 3: Checking directory connectivity
-Unconnected directory inode 12 (/???)
+Unconnected directory inode 12 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes
 
-Unconnected directory inode 13 (/???)
+Unconnected directory inode 13 (was in /)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_noroot/expect.1 b/tests/f_noroot/expect.1
index 7bdd7cba..f8f652ec 100644
--- a/tests/f_noroot/expect.1
+++ b/tests/f_noroot/expect.1
@@ -11,12 +11,12 @@ Entry '..' in /foo (12) has deleted/unused inode 2.  Clear? yes
 Pass 3: Checking directory connectivity
 Root inode not allocated.  Allocate? yes
 
-Unconnected directory inode 11 (...)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes
 
-Unconnected directory inode 12 (...)
+Unconnected directory inode 12 (was in /lost+found)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_orphan_dotdot_ft/expect.1 b/tests/f_orphan_dotdot_ft/expect.1
index 6a1373f2..60924958 100644
--- a/tests/f_orphan_dotdot_ft/expect.1
+++ b/tests/f_orphan_dotdot_ft/expect.1
@@ -17,13 +17,13 @@ Entry '..' in <12>/<15> (15) has an incorrect filetype (was 2, should be 6).
 Fix? yes
 
 Pass 3: Checking directory connectivity
-Unconnected directory inode 13 (<12>/<13>)
+Unconnected directory inode 13 (was in <12>)
 Connect to /lost+found? yes
 
-Unconnected directory inode 14 (<12>/<14>)
+Unconnected directory inode 14 (was in <12>)
 Connect to /lost+found? yes
 
-Unconnected directory inode 15 (<12>/<15>)
+Unconnected directory inode 15 (was in <12>)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_rebuild_csum_rootdir/expect.1 b/tests/f_rebuild_csum_rootdir/expect.1
index 91e6027d..063fb8cc 100644
--- a/tests/f_rebuild_csum_rootdir/expect.1
+++ b/tests/f_rebuild_csum_rootdir/expect.1
@@ -13,7 +13,7 @@ Pass 3: Checking directory connectivity
 '..' in / (2) is <The NULL inode> (0), should be / (2).
 Fix? yes
 
-Unconnected directory inode 11 (/???)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes
diff --git a/tests/f_recnect_bad/expect.1 b/tests/f_recnect_bad/expect.1
index 97ffcc52..685eedfe 100644
--- a/tests/f_recnect_bad/expect.1
+++ b/tests/f_recnect_bad/expect.1
@@ -12,7 +12,7 @@ i_faddr for inode 13 (/test/???) is 12, should be zero.
 Clear? yes
 
 Pass 3: Checking directory connectivity
-Unconnected directory inode 13 (/test/???)
+Unconnected directory inode 13 (was in /test)
 Connect to /lost+found? yes
 
 Pass 4: Checking reference counts
diff --git a/tests/f_resize_inode_meta_bg/expect.1 b/tests/f_resize_inode_meta_bg/expect.1
index 769f71ae..e248083f 100644
--- a/tests/f_resize_inode_meta_bg/expect.1
+++ b/tests/f_resize_inode_meta_bg/expect.1
@@ -45,7 +45,7 @@ Pass 3: Checking directory connectivity
 '..' in / (2) is <The NULL inode> (0), should be / (2).
 Fix? yes
 
-Unconnected directory inode 11 (/???)
+Unconnected directory inode 11 (was in /)
 Connect to /lost+found? yes
 
 /lost+found not found.  Create? yes
