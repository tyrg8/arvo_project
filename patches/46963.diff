commit 9c22d74cff6d9013173724ab001188f9fdb96933
Author: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date:   Wed Jun 15 11:19:49 2022 +0200

    doc: make pandoc optional (#2866)
    
    Since it's currently unavailable on RHEL 9.

diff --git a/doc/Cite.xml b/doc/Cite.xml
index 4fb6b7adb..a03268e73 100644
--- a/doc/Cite.xml
+++ b/doc/Cite.xml
@@ -1,21 +1,21 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-<refentry id="Cite.md">
+<refentry id="Cite">
 
 
 <para>
   <refmeta> <refentrytitle>Cite</refentrytitle> <manvolnum>3</manvolnum> <refmiscinfo>libvips</refmiscinfo> </refmeta>
 </para>
 <para>
   <refnamediv> <refname>Cite</refname> <refpurpose>References to cite for libvips</refpurpose> </refnamediv>
 </para>
 <para>
   Martinez, K. and Cupitt, J. (2005) <ulink url="http://eprints.ecs.soton.ac.uk/12371">VIPS – a highly tuned image processing software architecture</ulink>. In Proceedings of IEEE International Conference on Image Processing 2, pp. 574-577, Genova.
 </para>
 <para>
   Cupitt, J. and Martinez, K. (1996) <ulink url="http://eprints.soton.ac.uk/252227/1/vipsspie96a.pdf">VIPS: An image processing system for large images</ulink>, Proc. SPIE, vol. 2663, pp. 19–28.
 </para>
 
 
 </refentry>
diff --git a/doc/Examples.xml b/doc/Examples.xml
index d1d6611b9..19143f170 100644
--- a/doc/Examples.xml
+++ b/doc/Examples.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-<refentry id="Examples.md">
+<refentry id="Examples">
 
 
 <para>
   <refmeta> <refentrytitle>Examples</refentrytitle> <manvolnum>3</manvolnum> <refmiscinfo>libvips</refmiscinfo> </refmeta>
 </para>
 <para>
   <refnamediv> <refname>libvips examples</refname> <refpurpose>A few example Python programs using libvips</refpurpose> </refnamediv>
 </para>
 <para>
   This page shows a few libvips examples using Python. They will work with small syntax changes in any language with a libvips binding.
 </para>
 <para>
   The libvips test suite is written in Python and exercises every operation in the API. It’s also a useful source of examples.
 </para>
 <refsect3 xml:id="average-a-region-of-interest-box-on-an-image">
   <title>Average a region of interest box on an image</title>
   <programlisting language="python">
 #!/usr/bin/python3
diff --git a/doc/How-it-opens-files.xml b/doc/How-it-opens-files.xml
index 853799e3c..a7a1bc168 100644
--- a/doc/How-it-opens-files.xml
+++ b/doc/How-it-opens-files.xml
@@ -1,66 +1,66 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-<refentry id="How-it-opens-files.md">
+<refentry id="How-it-opens-files">
 
 
 <para>
   <refmeta> <refentrytitle>Opening files</refentrytitle> <manvolnum>3</manvolnum> <refmiscinfo>libvips</refmiscinfo> </refmeta>
 </para>
 <para>
   <refnamediv> <refname>Opening</refname> <refpurpose>How libvips opens files</refpurpose> </refnamediv>
 </para>
 <para>
   libvips now has at least four different ways of opening image files, each best for different file types, file sizes and image use cases. libvips tries hard to pick the best strategy in each case and mostly you don’t need to know what it is doing behind the scenes, except unfortunately when you do.
 </para>
 <para>
   This page tries to explain what the different strategies are and when each is used. If you are running into unexpected memory, disc or CPU use, this might be helpful. <literal>vips_image_new_from_file()</literal> has the official documentation.
 </para>
 <refsect3 xml:id="direct-access">
   <title>Direct access</title>
   <para>
     This is the fastest and simplest one. The file is mapped directly into the process’s address space and can be read with ordinary pointer access. Small files are completely mapped; large files are mapped in a series of small windows that are shared and which scroll about as pixels are read. Files which are accessed like this can be read by many threads at once, making them especially quick. They also interact well with the computer’s operating system: your OS will use spare memory to cache recently used chunks of the file.
   </para>
   <para>
     For this to be possible, the file format needs to be a simple dump of a memory array. libvips supports direct access for vips, 8-bit binary ppm/pbm/pnm, analyse and raw.
   </para>
   <para>
     libvips has a special direct write mode where pixels can be written directly to the file image. This is used for the <ulink url="libvips-draw.html">draw operators</ulink>.
   </para>
 </refsect3>
 <refsect3 xml:id="random-access-via-load-library">
   <title>Random access via load library</title>
   <para>
     Some image file formats have libraries which allow true random access to image pixels. For example, libtiff lets you read any tile out of a tiled tiff image very quickly. Because the libraries allow true random access, libvips can simply hook the image load library up to the input of the operation pipeline.
   </para>
   <para>
     These libraries are generally single-threaded, so only one thread may read at once, making them slower than simple direct access. Additionally, tiles are often compressed, meaning that each time a tile is fetched it must be decompressed. libvips keeps a cache of recently-decompressed tiles to try to avoid repeatedly decompressing the same tile.
   </para>
   <para>
     libvips can load tiled tiff, tiled OpenEXR, FITS and OpenSlide images in this manner.
   </para>
 </refsect3>
 <refsect3 xml:id="full-decompression">
   <title>Full decompression</title>
   <para>
     Many image load libraries do not support random access. In order to use images of this type as inputs to pipelines, libvips has to convert them to a random access format first.
   </para>
   <para>
     For small images (less than 100mb when decompressed), libvips allocates a large area of memory and decompresses the entire image to that. It then uses that memory buffer of decompressed pixels to feed the pipeline. For large images, libvips decompresses to a temporary file on disc, then loads that temporary file in direct access mode (see above). Note that on open libvips just reads the image header and is quick: the image decompress happens on the first pixel access.
   </para>
   <para>
     You can control this process with environment variables, command-line flags and API calls as you choose, see vips_image_new_from_file(). They let you set the threshold at which libvips switches between memory and disc and where on disc the temporary files are held.
   </para>
   <para>
     This is the slowest and most memory-hungry way to read files, but it’s unavoidable for many file formats. Unless you can use the next one!
   </para>
 </refsect3>
 <refsect3 xml:id="sequential-access">
   <title>Sequential access</title>
   <para>
     This a fairly recent addition to libvips and is a hybrid of the previous two.
   </para>
   <para>
     Imagine how this command might be executed:
   </para>
   <programlisting>
diff --git a/doc/How-it-works.xml b/doc/How-it-works.xml
index 18277cf04..69a243d21 100644
--- a/doc/How-it-works.xml
+++ b/doc/How-it-works.xml
@@ -1,31 +1,31 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-<refentry id="How-it-works.md">
+<refentry id="How-it-works">
 
 
 <para>
   <refmeta> <refentrytitle>How libvips works</refentrytitle> <manvolnum>3</manvolnum> <refmiscinfo>libvips</refmiscinfo> </refmeta>
 </para>
 <para>
   <refnamediv> <refname>Internals</refname> <refpurpose>A high-level technical overview of libvips’s evaluation system</refpurpose> </refnamediv>
 </para>
 <para>
   Compared to most image processing libraries, VIPS needs little RAM and runs quickly, especially on machines with more than one CPU. VIPS achieves this improvement by only keeping the pixels currently being processed in RAM and by having an efficient, threaded image IO system. This page explains how these features are implemented.
 </para>
 <para>
   <emphasis role="strong">Images</emphasis>
 </para>
 <para>
   VIPS images have three dimensions: width, height and bands. Bands usually (though not always) represent colour. These three dimensions can be any size up to 2 ** 31 elements. Every band element in an image has to have the same format. A format is an 8-, 16- or 32-bit int, signed or unsigned, 32- or 64-bit float, and 64- or 128-bit complex.
 </para>
 <para>
   <emphasis role="strong">Regions</emphasis>
 </para>
 <para>
   An image can be very large, much larger than the available memory, so you can’t just access pixels with a pointer *.
 </para>
 <para>
   Instead, you read pixels from an image with a region. This is a rectangular sub-area of an image. In C, the API looks like:
 </para>
 <programlisting language="c">
@@ -53,169 +53,169 @@ VipsPel *pixel = VIPS_REGION_ADDR( region, x, y );
 // everything in libvips is a GObject ... when you're done, 
 // just free with
 g_object_unref( region );
 </programlisting>
 <para>
-  The action that <literal>vips_region_prepare()</literal> takes varies with the type of image. If the image is a file on disc, for example, then VIPS will arrange for a refsect3 of the file to be read in.
+  The action that <literal>vips_region_prepare()</literal> takes varies with the type of image. If the image is a file on disc, for example, then VIPS will arrange for a section of the file to be read in.
 </para>
 <para>
   (* there is an image access mode where you can just use a pointer, but it’s rarely used)
 </para>
 <para>
   <emphasis role="strong">Partial images</emphasis>
 </para>
 <para>
   A partial image is one where, instead of storing a value for each pixel, VIPS stores a function which can make any rectangular area of pixels on demand.
 </para>
 <para>
   If you use <literal>vips_region_prepare()</literal> on a region created on a partial image, VIPS will allocate enough memory to hold the pixels you asked for and use the stored function to calculate values for just those pixels *.
 </para>
 <para>
   The stored function comes in three parts: a start function, a generate function and a stop function. The start function creates a state, the generate function uses the state plus a requested area to calculate pixel values and the stop function frees the state again. Breaking the stored function into three parts is good for SMP scaling: resource allocation and synchronisation mostly happens in start functions, so generate functions can run without having to talk to each other.
 </para>
 <para>
   VIPS makes a set of guarantees about parallelism that make this simple to program. Start and stop functions are mutually exclusive and a state is never used by more than one generate. In other words, a start / generate / generate / stop sequence works like a thread.
 </para>
 <para>
   <inlinemediaobject>
     <imageobject>
       <imagedata fileref="Sequence.png" />
     </imageobject>
   </inlinemediaobject>
 </para>
 <para>
   (* in fact VIPS keeps a cache of calculated pixel buffers and will return a pointer to a previously-calculated buffer if it can)
 </para>
 <para>
   <emphasis role="strong">Operations</emphasis>
 </para>
 <para>
   VIPS operations read input images and write output images, performing some transformation on the pixels. When an operation writes to an image the action it takes depends upon the image type. For example, if the image is a file on disc then VIPS will start a data sink to stream pixels to the file, or if the image is a partial one then it will just attach start / generate / stop functions.
 </para>
 <para>
   Like most threaded image processing systems, all VIPS operations have to be free of side-effects. In other words, operations cannot modify images, they can only create new images. This could result in a lot of copying if an operation is only making a small change to a large image so VIPS has a set of mechanisms to copy image areas by just adjusting pointers. Most of the time no actual copying is necessary and you can perform operations on large images at low cost.
 </para>
 <para>
   <emphasis role="strong">Run-time code generation</emphasis>
 </para>
 <para>
   VIPS uses <ulink url="https://gstreamer.freedesktop.org/modules/orc.html">Orc</ulink>, a run-time compiler, to generate code for some operations. For example, to compute a convolution on an 8-bit image, VIPS will examine the convolution matrix and the source image and generate a tiny program to calculate the convolution. This program is then <quote>compiled</quote> to the vector instruction set for your CPU, for example SSE3 on most x86 processors.
 </para>
 <para>
   Run-time vector code generation typically speeds operations up by a factor of three or four.
 </para>
 <para>
   <emphasis role="strong">Joining operations together</emphasis>
 </para>
 <para>
   The region create / prepare / prepare / free calls you use to get pixels from an image are an exact parallel to the start / generate / generate / stop calls that images use to create pixels. In fact, they are the same: a region on a partial image holds the state created by that image for the generate function that will fill the region with pixels.
 </para>
 <para>
   <inlinemediaobject>
     <imageobject>
       <imagedata fileref="Combine.png" />
     </imageobject>
   </inlinemediaobject>
 </para>
 <para>
   VIPS joins image processing operations together by linking the output of one operation (the start / generate / stop sequence) to the input of the next (the region it uses to get pixels for processing). This link is a single function call, and very fast. Additionally, because of the the split between allocation and processing, once a pipeline of operations has been set up, VIPS is able to run without allocating and freeing memory.
 </para>
 <para>
   This graph (generated by <literal>vipsprofile</literal>, the vips profiler) shows memory use over time for a vips pipeline running on a large image. The bottom trace shows total memory, the upper traces show threads calculating useful results (green), threads blocked on synchronisation (red) and memory allocations (white ticks).
 </para>
 <para>
   <inlinemediaobject>
     <imageobject>
       <imagedata fileref="Memtrace.png" />
     </imageobject>
   </inlinemediaobject>
 </para>
 <para>
   Because the intermediate image is just a small region in memory, a pipeline of operations running together needs very little RAM. In fact, intermediates are small enough that they can fit in L2 cache on most machines, so an entire pipeline can run without touching main memory. And finally, because each thread runs a very cheap copy of just the writeable state of the entire pipeline, threads can run with few locks. VIPS needs just four lock operations per output tile, regardless of the pipeline length or complexity.
 </para>
 <para>
   <emphasis role="strong">Data sources</emphasis>
 </para>
 <para>
-  VIPS has data sources which can supply pixels for processing from a variety of sources. VIPS can stream images from files in VIPS native format, from tiled TIFF files, from binary PPM/PGM/PBM/PFM, from Radiance (HDR) files, from FITS images and from tiled OpenEXR images. VIPS will automatically unpack other formats to temporary disc files for you but this can obviously generate a lot of disc traffic. It also has a special sequential mode for streaming operations on non-random-access formats. Another refsect3 in these docs explains <ulink url="How-it-opens-files.md.html">how libvips opens a file</ulink>. One of the sources uses the <ulink
+  VIPS has data sources which can supply pixels for processing from a variety of sources. VIPS can stream images from files in VIPS native format, from tiled TIFF files, from binary PPM/PGM/PBM/PFM, from Radiance (HDR) files, from FITS images and from tiled OpenEXR images. VIPS will automatically unpack other formats to temporary disc files for you but this can obviously generate a lot of disc traffic. It also has a special sequential mode for streaming operations on non-random-access formats. Another section in these docs explains <ulink url="How-it-opens-files.md.html">how libvips opens a file</ulink>. One of the sources uses the <ulink
   url="http://www.imagemagick.org">ImageMagick</ulink> (or optionally <ulink
   url="http://www.graphicsmagick.org">GraphicsMagick</ulink> library, so VIPS can read any image format that these libraries can read.
 </para>
 <para>
   VIPS images are held on disc as a 64-byte header containing basic image information like width, height, bands and format, then the image data as a single large block of pixels, left-to-right and top-to-bottom, then an XML extension block holding all the image metadata, such as ICC profiles and EXIF blocks.
 </para>
 <para>
   When reading from a large VIPS image (or any other format with the same structure on disc, such as binary PPM), VIPS keeps a set of small rolling windows into the file, some small number of scanlines in size. As pixels are demanded by different threads VIPS will move these windows up and down the file. As a result, VIPS can process images much larger than RAM, even on 32-bit machines.
 </para>
 <para>
   <emphasis role="strong">Data sinks</emphasis>
 </para>
 <para>
   In a demand-driven system, something has to do the demanding. VIPS has a variety of data sinks that you can use to pull image data though a pipeline in various situations. There are sinks that will build a complete image in memory, sinks to draw to a display, sinks to loop over an image (useful for statistical operations, for example) and sinks to stream an image to disc.
 </para>
 <para>
   The disc sink looks something like this:
 </para>
 <para>
   <inlinemediaobject>
     <imageobject>
       <imagedata fileref="Sink.png" />
     </imageobject>
   </inlinemediaobject>
 </para>
 <para>
   The sink keeps two buffers*, each as wide as the image. It starts threads as rapidly as it can up to the concurrency limit, filling each buffer with tiles** of calculated pixels, each thread calculating one tile at once. A separate background thread watches each buffer and, as soon as the last tile in a buffer finishes, writes that complete set of scanlines to disc using whatever image write library is appropriate. VIPS can write with libjpeg, libtiff, libpng and others. It then wipes the buffer and repositions it further down the image, ready for the next set of tiles to stream in.
 </para>
 <para>
   These features in combination mean that, once a pipeline of image processing operations has been built, VIPS can run almost lock-free. This is very important for SMP scaling: you don’t want the synchronization overhead to scale with either the number of threads or the complexity of the pipeline of operations being performed. As a result, VIPS scales almost linearly with increasing numbers of threads:
 </para>
 <para>
   <inlinemediaobject>
     <imageobject>
       <imagedata fileref="Vips-smp.png" />
     </imageobject>
   </inlinemediaobject>
 </para>
 <para>
   Number of CPUs is on the horizontal axis, speedup is on the vertical axis. Taken from the [[Benchmarks]] page.
 </para>
 <para>
   (* there can actually be more than one, it allocate enough buffers to ensure that there are at least two tiles for every thread)
 </para>
 <para>
   (** tiles can be any shape and size, VIPS has a tile hint system that operations use to tell sinks what tile geometry they prefer)
 </para>
 <para>
   <emphasis role="strong">Operation cache</emphasis>
 </para>
 <para>
   Because VIPS operations are free of side-effects*, you can cache them. Every time you call an operation, VIPS searches the cache for a previous call to the same operation with the same arguments. If it finds a match, you get the previous result again. This can give a huge speedup.
 </para>
 <para>
   By default, VIPS caches the last 1,000 operation calls. You can also control the cache size by memory use or by files opened.
 </para>
 <para>
   (* Some vips operations DO have side effects, for example, <literal>vips_draw_circle()</literal> will draw a circle on an image. These operations emit an <quote>invalidate</quote> signal on the image they are called on and this signal makes all downstream operations and caches drop their contents.)
 </para>
 <para>
   <emphasis role="strong">Operation database and APIs</emphasis>
 </para>
 <para>
   VIPS has around 300 image processing operations written in this style. Each operation is a GObject class. You can use the standard GObject calls to walk the class hierarchy and discover operations, and libvips adds a small amount of extra introspection metadata to handle things like optional arguments.
 </para>
 <para>
   The <ulink url="using-from-c.html">C API</ulink> is a set of simple wrappers which create class instances for you. The <ulink url="using-from-cpp.html">C++ API</ulink> is a little fancier and adds things like automatic object lifetime management. The <ulink url="using-cli.html"> command-line interface</ulink> uses introspection to run any vips operation in the class hierarchy.
 </para>
 <para>
   There are bindings for <ulink url="https://libvips.github.io/libvips">many other languages</ulink> on many platforms. Most of these bindings use the introspection system to generate the binding at run-time.
 </para>
 <para>
   <emphasis role="strong">Snip</emphasis>
 </para>
 <para>
   The VIPS GUI, nip2, has its own scripting language called Snip. Snip is a lazy, higher-order, purely functional, object oriented language. Almost all of nip2’s menus are implemented in it, and nip2 workspaces are Snip programs.
 </para>
 <para>
   VIPS operations listed in the operation database appear as Snip functions. For example, <literal>abs</literal> can be used from Snip as:
 </para>
 <programlisting>
 // absolute value of image b
diff --git a/doc/Makefile.am b/doc/Makefile.am
index 036dcded3..8b202858f 100644
--- a/doc/Makefile.am
+++ b/doc/Makefile.am
@@ -114,20 +114,20 @@ IGNORE_HFILES = $(IGNORE_VIPS_INCLUDE) $(IGNORE_VIPS_C)
 # Images to copy into HTML directory.
 # e.g. HTML_IMAGES=$(top_srcdir)/gtk/stock-icons/stock_about_24.png
 HTML_IMAGES = \
 	$(top_srcdir)/doc/images/owl.jpg \
 	$(top_srcdir)/doc/images/tn_owl.jpg \
 	$(top_srcdir)/doc/images/interconvert.png \
 	$(top_srcdir)/doc/images/Combine.png \
 	$(top_srcdir)/doc/images/Memtrace.png \
 	$(top_srcdir)/doc/images/Sequence.png \
 	$(top_srcdir)/doc/images/Sink.png \
 	$(top_srcdir)/doc/images/Vips-smp.png
 
 # we have some files in markdown ... convert to docbook for gtk-doc
 # pandoc makes section headers, we want refsect3 for gtk-doc
 .md.xml:
 	pandoc -s --template="$(realpath pandoc-docbook-template.docbook)" --wrap=none -V title="$<" -f markdown+smart -t docbook -o $@ $<
-	sed -e s/section/refsect3/g < $@ > x.$@ && mv x.$@ $@
+	sed -i -e 's|<section|<refsect3|g' -e 's|</section|</refsect3|g' $@
 
 # Our markdown source files
 markdown_content_files = \
diff --git a/doc/Making-image-pyramids.xml b/doc/Making-image-pyramids.xml
index fdc65f298..6e09c6fa2 100644
--- a/doc/Making-image-pyramids.xml
+++ b/doc/Making-image-pyramids.xml
@@ -1,23 +1,23 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-<refentry id="Making-image-pyramids.md">
+<refentry id="Making-image-pyramids">
 
 
 <para>
   <refmeta> <refentrytitle>Image pyramids</refentrytitle> <manvolnum>3</manvolnum> <refmiscinfo>libvips</refmiscinfo> </refmeta>
 </para>
 <para>
   <refnamediv> <refname>Pyramids</refname> <refpurpose>How to use libvips to make image pyramids</refpurpose> </refnamediv>
 </para>
 <para>
   libvips includes <literal>vips_dzsave()</literal>, an operation that can build image pyramids compatible with <ulink
   url="http://en.wikipedia.org/wiki/Deep_Zoom">DeepZoom</ulink>, Zoomify and <ulink url="https://developers.google.com/maps">Google Maps</ulink> image viewers. It’s fast and can generate pyramids for large images using only a small amount of memory.
 </para>
 <para>
   The TIFF writer, <literal>vips_tiffsave()</literal> can also build tiled pyramidal TIFF images, but that’s very simple to use. This page concentrates on the DeepZoom builder.
 </para>
 <para>
   Run dzsave with no arguments to see a summary:
 </para>
 <programlisting>
@@ -56,18 +56,18 @@ gboolean
             default: false
    compression  - ZIP deflate compression level, input gint
             default: 0
             min: -1, max: 9
    strip        - Strip all metadata from image, input gboolean
             default: false
    background   - Background value, input VipsArrayDouble
 operation flags: sequential nocache 
 </programlisting>
 <para>
   You can also call <literal>vips_dzsave()</literal> from any language with a libvips binding, or by using <literal>.dz</literal> or <literal>.szi</literal> as an output file suffix.
 </para>
 <refsect3 xml:id="writing-deepzoom-pyramids">
-  <title>Writing <link xlink:href="http://en.wikipedia.org/wiki/Deep_Zoom">DeepZoom</link> pyramids</title>
+  <title>Writing DeepZoom pyramids</title>
   <para>
     The <literal>--layout</literal> option sets the basic mode of operation. With no <literal>--layout</literal>, dzsave writes DeepZoom pyramids. For example:
   </para>
   <programlisting>
@@ -84,26 +84,26 @@ $ vips dzsave huge.tif mydz --suffix .jpg[Q=90]
 </programlisting>
   <para>
     will write JPEG tiles with the quality factor set to 90. You can set any format write options you like, see the API docs for <literal>vips_jpegsave()</literal> for details.
   </para>
 </refsect3>
 <refsect3 xml:id="writing-zoomify-pyramids">
   <title>Writing Zoomify pyramids</title>
   <para>
     Use <literal>--layout zoomify</literal> to put dzsave into zoomify mode. For example:
   </para>
   <programlisting>
 $ vips dzsave huge.tif myzoom --layout zoomify
 </programlisting>
   <para>
     This will create a directory called <literal>myzoom</literal> containing a file called <literal>ImageProperties.xml</literal> with the image metadata in, and a series of directories called <literal>TileGroupn</literal>, each containing 256 image tiles.
   </para>
   <para>
     As with DeepZoom, you can use <literal>--suffix</literal> to set jpeg quality.
   </para>
 </refsect3>
 <refsect3 xml:id="writing-google-maps-pyramids">
-  <title>Writing <link xlink:href="https://developers.google.com/maps/">Google Maps</link> pyramids</title>
+  <title>Writing Google Maps pyramids</title>
   <para>
     Use <literal>--layout google</literal> to write Google maps-style pyramids. These are compatible with <ulink url="http://leafletjs.com">Leaflet</ulink>. For example:
   </para>
   <programlisting>
diff --git a/doc/Using-vipsthumbnail.xml b/doc/Using-vipsthumbnail.xml
index 3cb0ae448..f71be4156 100644
--- a/doc/Using-vipsthumbnail.xml
+++ b/doc/Using-vipsthumbnail.xml
@@ -1,19 +1,19 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-<refentry id="Using-vipsthumbnail.md">
+<refentry id="Using-vipsthumbnail">
 
 
 <para>
   <refmeta> <refentrytitle>Using <literal>vipsthumbnail</literal></refentrytitle> <manvolnum>3</manvolnum> <refmiscinfo>libvips</refmiscinfo> </refmeta>
 </para>
 <para>
   <refnamediv> <refname><literal>vipsthumbnail</literal></refname> <refpurpose>Introduction to <literal>vipsthumbnail</literal>, with examples</refpurpose> </refnamediv>
 </para>
 <para>
   libvips ships with a handy command-line image thumbnailer, <literal>vipsthumbnail</literal>. This page introduces it, with some examples.
 </para>
 <para>
   The thumbnailing functionality is implemented by <literal>vips_thumbnail()</literal> and <literal>vips_thumbnail_buffer()</literal> (which thumbnails an image held as a string), see the docs for details. You can use these functions from any language with a libvips binding. For example, from PHP you could write:
 </para>
 <programlisting>
@@ -29,36 +29,36 @@ $ cat k2.jpg | \
     vips thumbnail_source [descriptor=0] .jpg[Q=90] 128 | \
     cat &gt; x.jpg
 </programlisting>
 <refsect3 xml:id="libvips-options">
   <title>libvips options</title>
   <para>
     <literal>vipsthumbnail</literal> supports the usual range of vips command-line options. A few of them are useful:
   </para>
   <para>
     <literal>--vips-cache-trace</literal> shows each operation as libvips starts it. It can be handy to see exactly what operations <literal>vipsthumbnail</literal> is running for you.
   </para>
   <para>
     <literal>--vips-leak</literal> turns on the libvips memory leak checker. As well as reporting leaks (hopefully there are none) it also tracks and reports peak memory use.
   </para>
   <para>
     <literal>--vips-progress</literal> runs a progress indicator during computation. It can be useful to see where libvips is looping and how often.
   </para>
   <para>
     <literal>--vips-info</literal> shows a higher level view of the operations that <literal>vipsthumbnail</literal> is running. 
   </para>
 </refsect3>
 <refsect3 xml:id="looping">
   <title>Looping</title>
   <para>
     <literal>vipsthumbnail</literal> can process many images in one command. For example:
   </para>
   <programlisting>
 $ vipsthumbnail *.jpg
 </programlisting>
   <para>
-    will make a thumbnail for every jpeg in the current directory.  See the <link linkend="output-directory">Output directory</link> refsect3 below to see how to change where thumbnails are written.
+    will make a thumbnail for every jpeg in the current directory.  See the <link linkend="output-directory">Output directory</link> section below to see how to change where thumbnails are written.
   </para>
   <para>
     <literal>vipsthumbnail</literal> will process images one after the other. You can get a good speedup by running several <literal>vipsthumbnail</literal>s in parallel, depending on how much load you want to put on your system. For example:
   </para>
   <programlisting>
diff --git a/doc/binding.md b/doc/binding.md
index 851fbdb22..dee653187 100644
--- a/doc/binding.md
+++ b/doc/binding.md
@@ -169,7 +169,7 @@ the method-missing hook and attempt to run any method calls not implemented by
 the `Image` class as libvips operators. In effect, the binding is generated at
 runtime.
 
-# Dynamic langauge without FFI
+# Dynamic language without FFI
 
 PHP does not have a useful FFI, unfortunately, so for this language a small
 C module implements the general `vips_call()` function for PHP language
diff --git a/doc/binding.xml b/doc/binding.xml
index 24e30f7bd..097651e78 100644
--- a/doc/binding.xml
+++ b/doc/binding.xml
@@ -1,59 +1,59 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-<refentry id="binding.md">
+<refentry id="binding">
 
 
 <para>
   <refmeta> <refentrytitle>How to write bindings</refentrytitle> <manvolnum>3</manvolnum> <refmiscinfo>libvips</refmiscinfo> </refmeta>
 </para>
 <para>
   <refnamediv> <refname>Binding</refname> <refpurpose>Writing bindings for libvips</refpurpose> </refnamediv>
 </para>
 <para>
   There are full libvips bindings for quite a few environments now: C, C++, command-line, Ruby, PHP, Lua, Python and JavaScript (node).
 </para>
 <para>
   This chapter runs through the four main styles that have been found to work well. If you want to write a new binding, one of these should be close to what you need.
 </para>
 <refsect3 xml:id="dont-bind-the-top-level-c-api">
   <title>Don’t bind the top-level C API</title>
   <para>
     The libvips C API (vips_add() and so on) was designed to be easy for humans to write. It is inconvenient and dangerous to use from other languages due to its heavy use of varargs.
   </para>
   <para>
     It’s much better to use the layer below. This lower layer is structured as:
   </para>
   <itemizedlist>
     <listitem>
       <para>
         Create operator. You can use vips_operation_new() to make a new <literal>VipsOperation</literal> object from an operator nickname, like <literal>&quot;add&quot;</literal>.
       </para>
     </listitem>
     <listitem>
       <para>
         Set parameters. You can loop over the operation with vips_argument_map() to get the name and type of each input argument. For each argument, you need to get the value from your language, convert to a <literal>GValue</literal>, then use g_object_set_property() to set that value on the operator.
       </para>
     </listitem>
     <listitem>
       <para>
         Execute with vips_cache_operation_build().
       </para>
     </listitem>
     <listitem>
       <para>
         Extract results. Again, you loop over the operator arguments with vips_argument_map(), but instead of inputs, this time you look for output arguments. You extract their value with g_object_get_property(), and pass the value back to your language.
       </para>
     </listitem>
   </itemizedlist>
   <para>
     For example, you can execute vips_invert() like this:
   </para>
   <programlisting language="c">
 /* compile with
  *
  * gcc -g -Wall callvips.c `pkg-config vips --cflags --libs`
  *
  */
 
 #include &lt;vips/vips.h&gt;
@@ -136,52 +136,52 @@ main( int argc, char **argv )
     return( 0 ); 
 }
 </programlisting>
 </refsect3>
 <refsect3 xml:id="compiled-language-which-can-call-c">
   <title>Compiled language which can call C</title>
   <para>
     The C++ binding uses this lower layer to define a function called <literal>VImage::call()</literal> which can call any libvips operator with a set of variable arguments.
   </para>
   <para>
     A small Python program walks the set of all libvips operators and generates a set of static bindings. For example:
   </para>
   <programlisting language="c++">
 VImage VImage::invert( VOption *options )
 {
     VImage out;
 
     call( &quot;invert&quot;, (options ? options : VImage::option()) -&gt;
         set( &quot;in&quot;, *this ) -&gt;
         set( &quot;out&quot;, &amp;out ) );
 
     return( out );
 }
 </programlisting>
   <para>
     So from C++ you can call any libvips operator (though without static typechecking) with <literal>VImage::call()</literal>, or use the member functions on <literal>VImage</literal> to get type-checked calls for at least the required operator arguments.
   </para>
   <para>
     The <literal>VImage</literal> class also adds automatic reference counting, constant expansion, operator overloads, and various other useful features.
   </para>
 </refsect3>
 <refsect3 xml:id="dynamic-language-with-ffi">
   <title>Dynamic language with FFI</title>
   <para>
     Languages like Ruby, Python, JavaScript and LuaJIT can’t call C directly, but they do support FFI. The bindings for these languages work rather like C++, but use FFI to call into libvips and run operations.
   </para>
   <para>
     Since these languages are dynamic, they can add another trick: they intercept the method-missing hook and attempt to run any method calls not implemented by the <literal>Image</literal> class as libvips operators. In effect, the binding is generated at runtime.
   </para>
 </refsect3>
-<refsect3 xml:id="dynamic-langauge-without-ffi">
-  <title>Dynamic langauge without FFI</title>
+<refsect3 xml:id="dynamic-language-without-ffi">
+  <title>Dynamic language without FFI</title>
   <para>
     PHP does not have a useful FFI, unfortunately, so for this language a small C module implements the general <literal>vips_call()</literal> function for PHP language types, and a larger pure PHP layer makes it convenient to use.
   </para>
 </refsect3>
 <refsect3 xml:id="gobject-introspection">
   <title>gobject-introspection</title>
   <para>
     The C source code to libvips has been marked up with special comments describing the interface in a standard way. These comments are read by the <literal>gobject-introspection</literal> package when libvips is compiled and used to generate a typelib, a description of how to call the library. Many languages have gobject-introspection packages: all you need to do to call libvips from your favorite language is to start g-o-i, load the libvips typelib, and you should have the whole library available. For example, from Python it’s as simple as:
   </para>
   <programlisting language="python">
diff --git a/doc/libvips-from-C++.xml b/doc/libvips-from-C++.xml
index 5511aaf83..381d1bf7a 100644
--- a/doc/libvips-from-C++.xml
+++ b/doc/libvips-from-C++.xml
@@ -1,21 +1,21 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
                   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-<refentry id="libvips-from-C++.md">
+<refentry id="libvips-from-C++">
 
 
 <para>
   <refmeta> <refentrytitle>libvips from C++</refentrytitle> <manvolnum>3</manvolnum> <refmiscinfo>libvips</refmiscinfo> </refmeta>
 </para>
 <para>
   <refnamediv> <refname>C++</refname> <refpurpose>Using libvips from C++</refpurpose> </refnamediv>
 </para>
 <para>
   libvips comes with a convenient C++ API. It is a very thin wrapper over the C API and adds automatic reference counting, exceptions, operator overloads, and automatic constant expansion.
 </para>
 <para>
   See the <ulink url="https://libvips.github.io/libvips/API/8.11/cpp"> C++ API documentation</ulink> for more details.
 </para>
 
 
 </refentry>
diff --git a/doc/meson.build b/doc/meson.build
index 197f49727..25c6a125d 100644
--- a/doc/meson.build
+++ b/doc/meson.build
@@ -67,25 +67,45 @@ markdown_content_files = files(
     'Making-image-pyramids.md',
 )
 
-markdown_content_files_docbook = []
-foreach markdown_content_file : markdown_content_files
+pandoc = find_program('pandoc', required: false)
+
+if pandoc.found()
     # we have some files in markdown ... convert to docbook for gtk-doc
-    # pandoc makes section headers, we want refsect3 for gtk-doc
-    markdown_content_files_docbook += configure_file(
-        input: markdown_content_file,
-        command: [
-            find_program('pandoc'),
+    gen = generator(pandoc,
+        output: '@BASENAME@.xml',
+        arguments: [
             '@INPUT@',
-            '--template', files('pandoc-docbook-template.docbook'),
+            '--template=@0@'.format(join_paths(meson.current_source_dir(), 'pandoc-docbook-template.docbook')),
             '--wrap=none',
             '-V', 'title=@BASENAME@',
             '-f', 'markdown+smart',
             '-t', 'docbook',
             '-o', '@OUTPUT@',
-        ],
-        output: '@BASENAME@.xml',
+        ]
     )
-endforeach
+
+    markdown_content_files_generated = gen.process(markdown_content_files)
+
+    # pandoc makes section headers, we want refsect3 for gtk-doc
+    markdown_content_files_docbook = custom_target('gen-docs',
+        output: 'generated',
+        input: markdown_content_files_generated,
+        command: [ 'sed', '-i', '-e', 's|<section|<refsect3|g', '-e', 's|</section|</refsect3|g', '@INPUT@' ],
+        build_by_default: true
+    )
+else
+    # use the pre-generated docbook files when pandoc is not available
+    markdown_content_files_docbook = files(
+        'How-it-works.xml',
+        'libvips-from-C++.xml',
+        'Using-vipsthumbnail.xml',
+        'How-it-opens-files.xml',
+        'Examples.xml',
+        'Cite.xml',
+        'binding.xml',
+        'Making-image-pyramids.xml',
+    )
+endif
 
 content_files = files(
     'using-command-line.xml',
@@ -118,24 +138,24 @@ docpath = get_option('prefix') / get_option('datadir') / 'gtk-doc' / 'html'
 gnome.gtkdoc('libvips',
     mode: 'none',
     main_xml: 'libvips-docs.xml.in',
     src_dir: [
         join_paths(meson.project_source_root(), 'libvips'),
         join_paths(meson.project_build_root(), 'libvips'),
     ],
     dependencies: libvips_dep,
     scan_args: [
-      '--ignore-headers=' + ' '.join(private_headers),
-      '--rebuild-types',
+        '--ignore-headers=' + ' '.join(private_headers),
+        '--rebuild-types',
     ],
     mkdb_args: [ '--default-includes=vips/vips.h' ],
     fixxref_args: [
-      '--html-dir=@0@'.format(docpath),
-      '--extra-dir=@0@'.format(join_paths(glib_docpath, 'glib')),
-       '--extra-dir=@0@'.format(join_paths(glib_docpath, 'gobject')),
-      '--extra-dir=@0@'.format(join_paths(glib_docpath, 'gio')),
+        '--html-dir=@0@'.format(docpath),
+        '--extra-dir=@0@'.format(join_paths(glib_docpath, 'glib')),
+        '--extra-dir=@0@'.format(join_paths(glib_docpath, 'gobject')),
+        '--extra-dir=@0@'.format(join_paths(glib_docpath, 'gio')),
     ],
     content_files: [ content_files, markdown_content_files_docbook ],
-    expand_content_files: [ content_files, markdown_content_files_docbook ],
+    expand_content_files: [ content_files ],
     html_assets: images,
     install: true
 )
