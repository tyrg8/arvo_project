commit 5f98ccd606310bf6b96e5acd8c5048e359f44908
Author: Jim Derry <balthisar@gmail.com>
Date:   Fri Jul 30 18:32:34 2021 -0400

    Static analyzer fixes.

diff --git a/src/fileio.c b/src/fileio.c
index 61048c0..990916c 100644
--- a/src/fileio.c
+++ b/src/fileio.c
@@ -73,10 +73,11 @@ int TY_(initFileSource)( TidyAllocator *allocator, TidyInputSource* inp, FILE* f
 void TY_(freeFileSource)( TidyInputSource* inp, Bool closeIt )
 {
     FileSource* fin = (FileSource*) inp->sourceData;
     if ( closeIt && fin && fin->fp )
       fclose( fin->fp );
     tidyBufFree( &fin->unget );
-    TidyFree( fin->unget.allocator, fin );
+    if (fin)
+        TidyFree( fin->unget.allocator, fin );
 }
 
 void TIDY_CALL TY_(filesink_putByte)( void* sinkData, byte bv )
diff --git a/src/lexer.c b/src/lexer.c
index fa8d6fb..b0afccd 100644
--- a/src/lexer.c
+++ b/src/lexer.c
@@ -4471,22 +4471,22 @@ Stack* TY_(newStack)(TidyDocImpl *doc, uint capacity)
 /**
  *  Increase the stack size. This will be called automatically when the
  *  current stack is full. If memory allocation fails, then the allocator
  *  will panic the program automatically.
  */
 void TY_(growStack)(Stack *stack)
 {
     uint new_capacity = stack->capacity * 2;
     
-    Node **firstNode = (Node **)TidyAlloc(stack->allocator, new_capacity);
+    Node **firstNode = (Node **)TidyAlloc(stack->allocator, new_capacity * sizeof(Node**));
     
     memcpy( firstNode, stack->firstNode, sizeof(Node**) * (stack->top + 1) );
     TidyFree(stack->allocator, stack->firstNode);
 
     stack->firstNode = firstNode;
     stack->capacity = new_capacity;
 }
 
 
 /**
  * Stack is full when top is equal to the last index.
  */
diff --git a/src/message.c b/src/message.c
index 90f74e0..2f8cf73 100644
--- a/src/message.c
+++ b/src/message.c
@@ -664,207 +664,207 @@ TidyMessageImpl *formatEncodingReport(TidyDocImpl* doc, Node *element, Node *nod
 /* Provides general formatting for the majority of Tidy's reports. Because most
 ** reports use the same basic data derived from the element and node, this
 ** formatter covers the vast majority of Tidy's report messages. Note that this
 ** formatter guarantees the values of TidyReportLevel in the dispatchTable[].
 ** Some of the cases in this formatter start new contexts from the va_list
 ** when the required data is simple. For complex local variable needs, it may
 ** be preferred to write a new formatter.
 */
 TidyMessageImpl *formatStandard(TidyDocImpl* doc, Node *element, Node *node, uint code, uint level, va_list args)
 {
     char nodedesc[ 256 ] = {0};
     char elemdesc[ 256 ] = {0};
     Node* rpt = ( element ? element : node );
 
     TagToString(node, nodedesc, sizeof(nodedesc));
 
     if ( element )
         TagToString(element, elemdesc, sizeof(elemdesc));
 
     switch ( code )
     {
         case CUSTOM_TAG_DETECTED:
         {
             ctmbstr tagtype;
             switch ( cfg( doc, TidyUseCustomTags ) )
             {
                 case TidyCustomBlocklevel:
                     tagtype = tidyLocalizedString( TIDYCUSTOMBLOCKLEVEL_STRING );
                     break;
                 case TidyCustomEmpty:
                     tagtype = tidyLocalizedString( TIDYCUSTOMEMPTY_STRING );
                     break;
                 case TidyCustomInline:
                     tagtype = tidyLocalizedString( TIDYCUSTOMINLINE_STRING );
                     break;
                 case TidyCustomPre:
                 default:
                     tagtype = tidyLocalizedString( TIDYCUSTOMPRE_STRING );
                     break;
             }
             return TY_(tidyMessageCreateWithNode)(doc, element, code, level, elemdesc, tagtype );
         }
 
         case STRING_NO_SYSID:
             return TY_(tidyMessageCreate)( doc, code, level );
             
         case FILE_CANT_OPEN:
         case FILE_CANT_OPEN_CFG:
         case FILE_NOT_FILE:
         case STRING_CONTENT_LOOKS:
         case STRING_DOCTYPE_GIVEN:
         case STRING_MISSING_MALFORMED:
         case STRING_MUTING_TYPE:
         {
             ctmbstr str;
             if ( (str = va_arg( args, ctmbstr)) )
                 return TY_(tidyMessageCreate)( doc, code, level, str );
 
         } break;
 
         case APOS_UNDEFINED:
         case MISSING_SEMICOLON_NCR:
         case MISSING_SEMICOLON:
         case UNESCAPED_AMPERSAND:
         case UNKNOWN_ENTITY:
         {
             ctmbstr entityname;
             if ( !(entityname = va_arg( args, ctmbstr)) )
             {
                 entityname = "NULL";
             }
             return TY_(tidyMessageCreateWithLexer)(doc, code, level, entityname);
         }
 
         case MISSING_ATTRIBUTE:
         {
             ctmbstr name;
             if ( (name = va_arg( args, ctmbstr)) )
                 return TY_(tidyMessageCreateWithNode)(doc, node, code, level, nodedesc, name );
         } break;
 
         case STRING_UNKNOWN_OPTION:
         case OPTION_REMOVED:
         {
             ctmbstr str;
             if ( (str = va_arg( args, ctmbstr)) )
                 return TY_(tidyMessageCreateWithLexer)(doc, code, level, str);
         } break;
 
         case OPTION_REMOVED_UNAPPLIED:
         case STRING_ARGUMENT_BAD:
         {
             ctmbstr s1 = va_arg( args, ctmbstr );
             ctmbstr s2 = va_arg( args, ctmbstr );
             return TY_(tidyMessageCreateWithLexer)(doc, code, level, s1, s2);
         }
 
         case OPTION_REMOVED_APPLIED:
         {
             ctmbstr s1 = va_arg( args, ctmbstr );
             ctmbstr s2 = va_arg( args, ctmbstr );
             ctmbstr s3 = va_arg( args, ctmbstr );
             return TY_(tidyMessageCreateWithLexer)(doc, code, level, s1, s2, s3);
         }
 
 
         case BAD_SURROGATE_LEAD:
         case BAD_SURROGATE_PAIR:
         case BAD_SURROGATE_TAIL:
         {
             uint c1 = va_arg( args, uint );
             uint c2 = va_arg( args, uint );
             return TY_(tidyMessageCreateWithLexer)(doc, code, level, c1, c2);
         }
 
         case SPACE_PRECEDING_XMLDECL:
             /* @TODO: Should this be a TidyInfo "silent" fix? */
             return TY_(tidyMessageCreateWithNode)(doc, node, code, level );
 
         case CANT_BE_NESTED:
         case NOFRAMES_CONTENT:
         case USING_BR_INPLACE_OF:
             /* Can we use `rpt` here? No; `element` has a value in every case. */
             return TY_(tidyMessageCreateWithNode)(doc, node, code, level, nodedesc );
 
         case ELEMENT_VERS_MISMATCH_ERROR:
         case ELEMENT_VERS_MISMATCH_WARN:
             return TY_(tidyMessageCreateWithNode)(doc, node, code, level, nodedesc, HTMLVersion(doc) );
 
         case TAG_NOT_ALLOWED_IN:
             /* Can we use `rpt` here? No; `element` has a value in every case. */
-            return TY_(tidyMessageCreateWithNode)(doc, node, code, level, nodedesc, element->element );
+            return TY_(tidyMessageCreateWithNode)(doc, node, code, level, nodedesc, element ? element->element : NULL );
 
         case INSERTING_TAG:
         case MISSING_STARTTAG:
         case TOO_MANY_ELEMENTS:
         case UNEXPECTED_ENDTAG:
         case UNEXPECTED_ENDTAG_ERR:  /* generated by XML docs */
             /* Can we use `rpt` here? No; `element` has a value in every case. */
             return TY_(tidyMessageCreateWithNode)(doc, node, code, level, node->element );
 
         case UNEXPECTED_ENDTAG_IN:
             /* Can we use `rpt` here? No; `element` has a value in every case. */
-            return TY_(tidyMessageCreateWithNode)(doc, node, code, level, node->element, element->element );
+            return TY_(tidyMessageCreateWithNode)(doc, node, code, level, node->element, element ? element->element : NULL );
 
         case BAD_CDATA_CONTENT:
         case CONTENT_AFTER_BODY:
         case DOCTYPE_AFTER_TAGS:
         case DUPLICATE_FRAMESET:
         case MALFORMED_COMMENT:
         case MALFORMED_COMMENT_DROPPING:
         case MALFORMED_COMMENT_EOS:
         case MALFORMED_COMMENT_WARN:
         case MALFORMED_DOCTYPE:
         case MISSING_DOCTYPE:
         case MISSING_TITLE_ELEMENT:
         case NESTED_QUOTATION:
         case SUSPECTED_MISSING_QUOTE:
         case XML_DECLARATION_DETECTED:
         case BLANK_TITLE_ELEMENT:
             return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level );
 
         case ELEMENT_NOT_EMPTY:
         case FOUND_STYLE_IN_BODY:
         case ILLEGAL_NESTING:
         case MOVED_STYLE_TO_HEAD:
         case TRIM_EMPTY_ELEMENT:
         case UNEXPECTED_END_OF_FILE:
             return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, elemdesc );
 
         case OBSOLETE_ELEMENT:
         case REPLACING_ELEMENT:
         case REPLACING_UNEX_ELEMENT:
             return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, elemdesc, nodedesc );
 
         case ADDED_MISSING_CHARSET:
         case BAD_SUMMARY_HTML5:
         case NESTED_EMPHASIS:
         case PROPRIETARY_ELEMENT:
         case REMOVED_HTML5:
         case UNKNOWN_ELEMENT:
         case UNKNOWN_ELEMENT_LOOKS_CUSTOM:
             return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, nodedesc );
 
         case MISSING_ENDTAG_FOR:
         case MISSING_ENDTAG_OPTIONAL:
         case PREVIOUS_LOCATION:
-            return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, element->element );
+            return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, element? element->element : NULL );
 
         case MISSING_ENDTAG_BEFORE:
-            return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, element->element, nodedesc );
+            return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, element? element->element : NULL, nodedesc );
 
         case COERCE_TO_ENDTAG:
         case NON_MATCHING_ENDTAG:
             return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, node->element, node->element );
         case TOO_MANY_ELEMENTS_IN:
-            return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, node->element, element->element);
+            return TY_(tidyMessageCreateWithNode)(doc, rpt, code, level, node->element, element ? element->element : NULL);
 
     }
 
     return NULL;
 }
 
 
 /* Provides general formatting as formatStandard, except TidyReportLevel is set
 ** dynamically for these items as it cannot be predicted except at runtime.
  */
@@ -1489,36 +1489,36 @@ TidyIterator TY_(getErrorCodeList)()
 /**
  *  Returns the next error code.
  */
 uint TY_(getNextErrorCode)( TidyIterator* iter )
 {
     const tidyStringsKeyItem *item = NULL;
     size_t itemIndex;
     assert( iter != NULL );
     
     itemIndex = (size_t)*iter;
     
     if ( itemIndex > 0 && itemIndex <= tidyErrorCodeListSize() )
     {
         item = &tidyStringsKeys[itemIndex - 1];
         itemIndex++;
     }
     
     *iter = (TidyIterator)( itemIndex <= tidyErrorCodeListSize() ? itemIndex : (size_t)0 );
-    return item->value;
+    return item ? item->value : 0;
 }
 
 
 /*********************************************************************
  * Documentation of configuration options
  *
  * Although most of the strings now come from the language module,
  * generating the documentation by the console application requires a
  * series of cross-references that are generated in this messaging
  * module.
  *********************************************************************/
 
 
 #if SUPPORT_CONSOLE_APP
 /* Cross-references definitions.
  * Note that each list must be terminated with `TidyUnknownOption`.
  */
diff --git a/src/messageobj.c b/src/messageobj.c
index 1b986b7..98b83e8 100644
--- a/src/messageobj.c
+++ b/src/messageobj.c
@@ -57,183 +57,182 @@ static struct printfArg *BuildArgArray( TidyDocImpl *doc, ctmbstr fmt, va_list a
 /** Create an internal representation of a Tidy message with all of
  ** the information that that we know about the message.
  **
  ** The function signature doesn't have to stay static and is a good
  ** place to add instantiation if expanding the API.
  **
  ** We currently know the doc, node, code, line, column, level, and
  ** args, will pre-calculate all of the other members upon creation.
  ** This ensures that we can use members directly, immediately,
  ** without having to use accessors internally.
  **
  ** If any message callback filters are setup by API clients, they
  ** will be called here.
  **
  ** This version serves as the designated initializer and as such
  ** requires every known parameter.
  */
 static TidyMessageImpl *tidyMessageCreateInitV( TidyDocImpl *doc,
                                                 Node *node,
                                                 uint code,
                                                 int line,
                                                 int column,
                                                 TidyReportLevel level,
                                                 va_list args )
 {
     TidyMessageImpl *result = TidyDocAlloc(doc, sizeof(TidyMessageImpl));
     TidyDoc tdoc = tidyImplToDoc(doc);
     va_list args_copy;
     enum { sizeMessageBuf=2048 };
     ctmbstr pattern;
     uint i = 0;
 
 
     /* Things we know... */
 
     result->tidyDoc = doc;
     result->tidyNode = node;
     result->code = code;
     result->line = line;
     result->column = column;
     result->level = level;
     /* Is #719 - set 'muted' before any callbacks. */
     result->muted = no;
     i = 0;
     while ((doc->muted.list) && (doc->muted.list[i] != 0))
     {
         if (doc->muted.list[i] == code)
         {
             result->muted = yes;
             break;
         }
         i++;
     }
 
     /* Things we create... */
 
     va_copy(args_copy, args);
     result->arguments = BuildArgArray(doc, tidyDefaultString(code), args_copy, &result->argcount);
     va_end(args_copy);
 
     result->messageKey = TY_(tidyErrorCodeAsKey)(code);
 
     result->messageFormatDefault = tidyDefaultString(code);
     result->messageFormat = tidyLocalizedString(code);
 
     result->messageDefault = TidyDocAlloc(doc, sizeMessageBuf);
     va_copy(args_copy, args);
     TY_(tmbvsnprintf)(result->messageDefault, sizeMessageBuf, result->messageFormatDefault, args_copy);
     va_end(args_copy);
 
     result->message = TidyDocAlloc(doc, sizeMessageBuf);
     va_copy(args_copy, args);
     TY_(tmbvsnprintf)(result->message, sizeMessageBuf, result->messageFormat, args_copy);
     va_end(args_copy);
 
     /* Some things already hit us localized, and some things need to be
        localized here. Look for these codewords and replace them here.
      */
     TY_(strrep)(result->messageDefault, "STRING_PLAIN_TEXT",      tidyDefaultString(STRING_PLAIN_TEXT));
     TY_(strrep)(result->message,        "STRING_PLAIN_TEXT",      tidyLocalizedString(STRING_PLAIN_TEXT));
 
     TY_(strrep)(result->messageDefault, "STRING_XML_DECLARATION", tidyDefaultString(STRING_XML_DECLARATION));
     TY_(strrep)(result->message,        "STRING_XML_DECLARATION", tidyLocalizedString(STRING_XML_DECLARATION));
 
     TY_(strrep)(result->messageDefault, "STRING_ERROR_COUNT_WARNING", tidyDefaultStringN(STRING_ERROR_COUNT_WARNING, doc->warnings));
     TY_(strrep)(result->message,        "STRING_ERROR_COUNT_WARNING", tidyLocalizedStringN(STRING_ERROR_COUNT_WARNING, doc->warnings));
 
     TY_(strrep)(result->messageDefault, "STRING_ERROR_COUNT_ERROR", tidyDefaultStringN(STRING_ERROR_COUNT_ERROR, doc->errors));
     TY_(strrep)(result->message,        "STRING_ERROR_COUNT_ERROR", tidyLocalizedStringN(STRING_ERROR_COUNT_ERROR, doc->errors));
 
 
     result->messagePosDefault = TidyDocAlloc(doc, sizeMessageBuf);
     result->messagePos = TidyDocAlloc(doc, sizeMessageBuf);
 
     if ( cfgBool(doc, TidyEmacs) && cfgStr(doc, TidyEmacsFile) )
     {
         /* Change formatting to be parsable by GNU Emacs */
         TY_(tmbsnprintf)(result->messagePosDefault, sizeMessageBuf, "%s:%d:%d: ", cfgStr(doc, TidyEmacsFile), line, column);
         TY_(tmbsnprintf)(result->messagePos, sizeMessageBuf, "%s:%d:%d: ", cfgStr(doc, TidyEmacsFile), line, column);
     }
     else if ( cfgBool(doc, TidyShowFilename) && cfgStr(doc, TidyEmacsFile) )
     {
         /* Include filename in output */
         TY_(tmbsnprintf)(result->messagePosDefault, sizeMessageBuf, tidyDefaultString(FN_LINE_COLUMN_STRING),
             cfgStr(doc, TidyEmacsFile), line, column);
         TY_(tmbsnprintf)(result->messagePos, sizeMessageBuf, tidyLocalizedString(FN_LINE_COLUMN_STRING),
             cfgStr(doc, TidyEmacsFile), line, column);
     }
     else
     {
         /* traditional format */
         TY_(tmbsnprintf)(result->messagePosDefault, sizeMessageBuf, tidyDefaultString(LINE_COLUMN_STRING), line, column);
         TY_(tmbsnprintf)(result->messagePos, sizeMessageBuf, tidyLocalizedString(LINE_COLUMN_STRING), line, column);
     }
 
     result->messagePrefixDefault = tidyDefaultString(level);
 
     result->messagePrefix = tidyLocalizedString(level);
 
     if ( line > 0 && column > 0 )
         pattern = "%s%s%s";      /* pattern if there's location information */
     else
         pattern = "%.0s%s%s";    /* otherwise if there isn't */
 
     if ( level > TidyFatal )
         pattern = "%.0s%.0s%s";  /* dialog doesn't have pos or prefix */
 
     result->messageOutputDefault = TidyDocAlloc(doc, sizeMessageBuf);
     TY_(tmbsnprintf)(result->messageOutputDefault, sizeMessageBuf, pattern,
                      result->messagePosDefault, result->messagePrefixDefault,
                      result->messageDefault);
 
     result->messageOutput = TidyDocAlloc(doc, sizeMessageBuf);
     TY_(tmbsnprintf)(result->messageOutput, sizeMessageBuf, pattern,
                      result->messagePos, result->messagePrefix,
                      result->message);
 
     if ( ( cfgBool(doc, TidyMuteShow) == yes ) && level <= TidyFatal )
     {
         /*\ Issue #655 - Unsafe to use output buffer as one of the va_list
          *  input parameters in some snprintf implementations.
         \*/
         ctmbstr pc = TY_(tidyErrorCodeAsKey)(code);
         i = TY_(tmbstrlen)(result->messageOutputDefault);
         if (i < sizeMessageBuf)
             TY_(tmbsnprintf)(result->messageOutputDefault + i, sizeMessageBuf - i, " (%s)", pc );
         i = TY_(tmbstrlen)(result->messageOutput);
         if (i < sizeMessageBuf)
             TY_(tmbsnprintf)(result->messageOutput + i, sizeMessageBuf - i, " (%s)", pc );
-        i = 0;
     }
 
     result->allowMessage = yes;
 
     /* reportFilter is a simple error filter that provides minimal information
        to callback functions, and includes the message buffer in LibTidy's
        configured localization. As it's a "legacy" API, it does not receive
        TidyDialogue messages.*/
     if ( (result->level <= TidyFatal) && doc->reportFilter )
     {
         result->allowMessage = result->allowMessage & doc->reportFilter( tdoc, result->level, result->line, result->column, result->messageOutput );
     }
 
     /* reportCallback is intended to allow LibTidy users to localize messages
        via their own means by providing a key and the parameters to fill it. 
        As it's a "legacy" API, it does not receive TidyDialogue messages. */
     if ( (result->level <= TidyFatal) && doc->reportCallback )
     {
         TidyDoc tdoc = tidyImplToDoc( doc );
         va_copy(args_copy, args);
         result->allowMessage = result->allowMessage & doc->reportCallback( tdoc, result->level, result->line, result->column, result->messageKey, args_copy );
         va_end(args_copy);
     }
 
     /* messageCallback is the newest interface to interrogate Tidy's
        emitted messages. */
     if ( doc->messageCallback )
     {
         result->allowMessage = result->allowMessage & doc->messageCallback( tidyImplToMessage(result) );
     }
 
     return result;
 }
diff --git a/src/parser.c b/src/parser.c
index 2a4fcb9..5d1e866 100644
--- a/src/parser.c
+++ b/src/parser.c
@@ -2238,156 +2238,156 @@ void* TY_(oldParseInline)( TidyDocImpl* doc, Node *element, GetTokenMode mode )
 /** MARK: TY_(oldParseDefList)
  *  Parses the `dl` tag.
  */
 void* TY_(oldParseDefList)(TidyDocImpl* doc, Node *list, GetTokenMode mode)
 {
     Lexer* lexer = doc->lexer;
     Node *node, *parent;
 
     if (list->tag->model & CM_EMPTY)
         return NULL;
 
     lexer->insert = NULL;  /* defer implicit inline start tags */
 
     while ((node = TY_(GetToken)( doc, IgnoreWhitespace)) != NULL)
     {
         if (node->tag == list->tag && node->type == EndTag)
         {
             TY_(FreeNode)( doc, node);
             list->closed = yes;
             return NULL;
         }
 
         /* deal with comments etc. */
         if (InsertMisc(list, node))
             continue;
 
         if (TY_(nodeIsText)(node))
         {
             TY_(UngetToken)( doc );
             node = TY_(InferredTag)(doc, TidyTag_DT);
             TY_(Report)(doc, list, node, MISSING_STARTTAG);
         }
 
         if (node->tag == NULL)
         {
             TY_(Report)(doc, list, node, DISCARDING_UNEXPECTED);
             TY_(FreeNode)( doc, node);
             continue;
         }
 
         /*
           if this is the end tag for an ancestor element
           then infer end tag for this element
         */
         if (node->type == EndTag)
         {
             Bool discardIt = no;
             if ( nodeIsFORM(node) )
             {
                 BadForm( doc );
                 TY_(Report)(doc, list, node, DISCARDING_UNEXPECTED);
                 TY_(FreeNode)( doc, node );
                 continue;
             }
 
             for (parent = list->parent;
                     parent != NULL; parent = parent->parent)
             {
                /* Do not match across BODY to avoid infinite loop
                   between ParseBody and this parser,
                   See http://tidy.sf.net/bug/1098012. */
                 if (nodeIsBODY(parent))
                 {
                     discardIt = yes;
                     break;
                 }
                 if (node->tag == parent->tag)
                 {
                     TY_(Report)(doc, list, node, MISSING_ENDTAG_BEFORE);
 
                     TY_(UngetToken)( doc );
                     return NULL;
                 }
             }
             if (discardIt)
             {
                 TY_(Report)(doc, list, node, DISCARDING_UNEXPECTED);
                 TY_(FreeNode)( doc, node);
                 continue;
             }
         }
 
         /* center in a dt or a dl breaks the dl list in two */
         if ( nodeIsCENTER(node) )
         {
             if (list->content)
                 TY_(InsertNodeAfterElement)(list, node);
             else /* trim empty dl list */
             {
                 TY_(InsertNodeBeforeElement)(list, node);
             }
 
             /* #426885 - fix by Glenn Carroll 19 Apr 00, and
                          Gary Dechaines 11 Aug 00 */
             /* ParseTag can destroy node, if it finds that
              * this <center> is followed immediately by </center>.
              * It's awkward but necessary to determine if this
              * has happened.
              */
             parent = node->parent;
 
             /* and parse contents of center */
             lexer->excludeBlocks = no;
             ParseTag( doc, node, mode);
             lexer->excludeBlocks = yes;
 
             /* now create a new dl element,
              * unless node has been blown away because the
              * center was empty, as above.
              */
-            if (parent->last == node)
+            if (parent && parent->last == node)
             {
                 list = TY_(InferredTag)(doc, TidyTag_DL);
                 TY_(InsertNodeAfterElement)(node, list);
             }
             continue;
         }
 
         if ( !(nodeIsDT(node) || nodeIsDD(node)) )
         {
             TY_(UngetToken)( doc );
 
             if (!(node->tag->model & (CM_BLOCK | CM_INLINE)))
             {
                 TY_(Report)(doc, list, node, TAG_NOT_ALLOWED_IN);
                 return NULL;
             }
 
             /* if DD appeared directly in BODY then exclude blocks */
             if (!(node->tag->model & CM_INLINE) && lexer->excludeBlocks)
                 return NULL;
 
             node = TY_(InferredTag)(doc, TidyTag_DD);
             TY_(Report)(doc, list, node, MISSING_STARTTAG);
         }
 
         if (node->type == EndTag)
         {
             TY_(Report)(doc, list, node, DISCARDING_UNEXPECTED);
             TY_(FreeNode)( doc, node);
             continue;
         }
 
         /* node should be <DT> or <DD>*/
         TY_(InsertNodeAtEnd)(list, node);
         ParseTag( doc, node, IgnoreWhitespace);
     }
 
     TY_(Report)(doc, list, node, MISSING_ENDTAG_FOR);
     return NULL;
 }
 
 
 /** MARK: TY_(oldParseList)
  *  Parses list tags.
  */
@@ -4178,523 +4178,523 @@ void* TY_(oldParseNoFrames)(TidyDocImpl* doc, Node *noframes, GetTokenMode mode)
 /** MARK: TY_(oldParseFrameSet)
  *  Parses the `frameset` tag.
  */
 void* TY_(oldParseFrameSet)(TidyDocImpl* doc, Node *frameset, GetTokenMode ARG_UNUSED(mode))
 {
     Lexer* lexer = doc->lexer;
     Node *node;
 
     if ( cfg(doc, TidyAccessibilityCheckLevel) == 0 )
     {
         doc->badAccess |= BA_USING_FRAMES;
     }
 
     while ((node = TY_(GetToken)(doc, IgnoreWhitespace)) != NULL)
     {
         if (node->tag == frameset->tag && node->type == EndTag)
         {
             TY_(FreeNode)( doc, node);
             frameset->closed = yes;
             TrimSpaces(doc, frameset);
             return NULL;
         }
 
         /* deal with comments etc. */
         if (InsertMisc(frameset, node))
             continue;
 
         if (node->tag == NULL)
         {
             TY_(Report)(doc, frameset, node, DISCARDING_UNEXPECTED);
             TY_(FreeNode)( doc, node);
             continue;
         }
 
         if (TY_(nodeIsElement)(node))
         {
             if (node->tag && node->tag->model & CM_HEAD)
             {
                 MoveToHead(doc, frameset, node);
                 continue;
             }
         }
 
         if ( nodeIsBODY(node) )
         {
             TY_(UngetToken)( doc );
             node = TY_(InferredTag)(doc, TidyTag_NOFRAMES);
             TY_(Report)(doc, frameset, node, INSERTING_TAG);
         }
 
-        if (node->type == StartTag && (node->tag->model & CM_FRAMES))
+        if (node->type == StartTag && (node->tag && node->tag->model & CM_FRAMES))
         {
             TY_(InsertNodeAtEnd)(frameset, node);
             lexer->excludeBlocks = no;
             ParseTag(doc, node, MixedContent);
             continue;
         }
-        else if (node->type == StartEndTag && (node->tag->model & CM_FRAMES))
+        else if (node->type == StartEndTag && (node->tag && node->tag->model & CM_FRAMES))
         {
             TY_(InsertNodeAtEnd)(frameset, node);
             continue;
         }
 
         /* discard unexpected tags */
         /* WAI [6.5.1.4] link is being discarded outside of NOFRAME */
         if ( nodeIsA(node) )
            doc->badAccess |= BA_INVALID_LINK_NOFRAMES;
 
         TY_(Report)(doc, frameset, node, DISCARDING_UNEXPECTED);
         TY_(FreeNode)( doc, node);
     }
 
     TY_(Report)(doc, frameset, node, MISSING_ENDTAG_FOR);
     return NULL;
 }
 
 
 /***************************************************************************//*
  ** MARK: - Parsers
  ***************************************************************************/
 
 
 /** MARK: TY_(ParseHTML)
  *  Parses the `html` tag. At this point, other root-level stuff (doctype,
  *  comments) are already set up, and the bulk of the parsing can be
  *  conducted from here as our nexus.
  */
 Node* TY_(ParseHTML)( TidyDocImpl *doc, Node *html, GetTokenMode mode, Bool popStack )
 {
 #if defined(ENABLE_DEBUG_LOG)
     static int parser_depth = 0;
     static int parser_count = 0;
 #endif
     Node *node = NULL;
     Node *head = NULL;
     Node *frameset = NULL;
     Node *noframes = NULL;
     Bool keepToken = no;
     parserState state = STATE_INITIAL;
 
 #if defined(ENABLE_DEBUG_LOG)
     parser_depth++;
     parser_count++;
     DEBUG_LOG(SPRTF("***Entering ParseHTML, count: %d, depth %d\n", parser_count, parser_depth));
 #endif
 
     TY_(SetOptionBool)( doc, TidyXmlTags, no );
 
     /*
      If we're re-entering, then we need to setup from a previous state,
      instead of starting fresh. We can pull what we need from the document's
      stack.
      */
     if ( popStack )
     {
         TidyParserMemory memory = popMemory( doc );
         node = memory.reentry_node;
         mode = memory.reentry_mode;
         state = memory.reentry_state;
         html = memory.original_node;
         keepToken = node != NULL;
     }
 
     /*
      This main loop pulls tokens from the lexer until we're out of tokens,
      or until there's no more work to do.
      */
     while ( state != STATE_COMPLETE )
     {
         /*
          We don't want to get the next token unless we're
          done with this one. Using this flag is much quicker
          than using `UngetToken()` every time we want to keep
          the token.
          */
         if ( !keepToken )
             node = TY_(GetToken)( doc, IgnoreWhitespace );
         keepToken = no;
 
         switch ( state )
         {
             /**************************************************************
              This case is all about finding a head tag and dealing with
              cases were we don't, so that we can move on to parsing a head
              tag.
              **************************************************************/
             case STATE_INITIAL:
             {
                 /*
                  The only way we can possibly be here is if the lexer
                  had nothing to give us. Thus we'll create our own
                  head, and set the signal to start parsing it.
                  */
                 if (node == NULL)
                 {
                     node = TY_(InferredTag)(doc, TidyTag_HEAD);
                     state = STATE_PARSE_HEAD;
                     keepToken = yes;
                     continue;
                 }
 
                 /* We found exactly what we expected: head. */
                 if ( nodeIsHEAD(node) )
                 {
                     state = STATE_PARSE_HEAD;
                     keepToken = yes;
                     continue;
                 }
 
                 /* We did not expect to find an html closing tag here! */
-                if (node->tag == html->tag && node->type == EndTag)
+                if (html && (node->tag == html->tag) && (node->type == EndTag))
                 {
                     TY_(Report)(doc, html, node, DISCARDING_UNEXPECTED);
                     TY_(FreeNode)( doc, node);
                     continue;
                 }
 
                 /* Find and discard multiple <html> elements. */
                 if (node->tag == html->tag && node->type == StartTag)
                 {
                     TY_(Report)(doc, html, node, DISCARDING_UNEXPECTED);
                     TY_(FreeNode)(doc, node);
                     continue;
                 }
 
                 /* Deal with comments etc. */
                 if (InsertMisc(html, node))
                     continue;
 
                 /* At this point, we didn't find a head tag, so put the
                  token back and create our own head tag, so we can
                  move on.
                  */
                 TY_(UngetToken)( doc );
                 node = TY_(InferredTag)(doc, TidyTag_HEAD);
                 state = STATE_PARSE_HEAD;
                 keepToken = yes;
                 continue;
             } break;
 
 
             /**************************************************************
              This case determines whether we're dealing with body or
              frameset + noframes, and sets things up accordingly.
              **************************************************************/
             case STATE_PRE_BODY:
             {
                 if (node == NULL )
                 {
                     if (frameset == NULL) /* Implied body. */
                     {
                         node = TY_(InferredTag)(doc, TidyTag_BODY);
                         state = STATE_PARSE_BODY;
                         keepToken = yes;
                     } else {
                         state = STATE_COMPLETE;
                     }
 
                     continue;
                 }
 
                 /* Robustly handle html tags. */
                 if (node->tag == html->tag)
                 {
                     if (node->type != StartTag && frameset == NULL)
                         TY_(Report)(doc, html, node, DISCARDING_UNEXPECTED);
 
                     TY_(FreeNode)( doc, node);
                     continue;
                 }
 
                 /* Deal with comments etc. */
                 if (InsertMisc(html, node))
                     continue;
 
                 /* If frameset document, coerce <body> to <noframes> */
                 if ( nodeIsBODY(node) )
                 {
                     if (node->type != StartTag)
                     {
                         TY_(Report)(doc, html, node, DISCARDING_UNEXPECTED);
                         TY_(FreeNode)( doc, node);
                         continue;
                     }
 
                     if ( cfg(doc, TidyAccessibilityCheckLevel) == 0 )
                     {
                         if (frameset != NULL)
                         {
                             TY_(UngetToken)( doc );
 
                             if (noframes == NULL)
                             {
                                 noframes = TY_(InferredTag)(doc, TidyTag_NOFRAMES);
                                 TY_(InsertNodeAtEnd)(frameset, noframes);
                                 TY_(Report)(doc, html, noframes, INSERTING_TAG);
                             }
                             else
                             {
                                 if (noframes->type == StartEndTag)
                                     noframes->type = StartTag;
                             }
 
                             state = STATE_PARSE_NOFRAMES;
                             keepToken = yes;
                             continue;
                         }
                     }
 
                     TY_(ConstrainVersion)(doc, ~VERS_FRAMESET);
                     state = STATE_PARSE_BODY;
                     keepToken = yes;
                     continue;
                 }
 
                 /* Flag an error if we see more than one frameset. */
                 if ( nodeIsFRAMESET(node) )
                 {
                     if (node->type != StartTag)
                     {
                         TY_(Report)(doc, html, node, DISCARDING_UNEXPECTED);
                         TY_(FreeNode)( doc, node);
                         continue;
                     }
 
                     if (frameset != NULL)
                         TY_(Report)(doc, html, node, DUPLICATE_FRAMESET);
                     else
                         frameset = node;
 
                     state = STATE_PARSE_FRAMESET;
                     keepToken = yes;
                     continue;
                 }
 
                 /* If not a frameset document coerce <noframes> to <body>. */
                 if ( nodeIsNOFRAMES(node) )
                 {
                     if (node->type != StartTag)
                     {
                         TY_(Report)(doc, html, node, DISCARDING_UNEXPECTED);
                         TY_(FreeNode)( doc, node);
                         continue;
                     }
 
                     if (frameset == NULL)
                     {
                         TY_(Report)(doc, html, node, DISCARDING_UNEXPECTED);
                         TY_(FreeNode)( doc, node);
                         node = TY_(InferredTag)(doc, TidyTag_BODY);
                         state = STATE_PARSE_BODY;
                         keepToken = yes;
                         continue;
                     }
 
                     if (noframes == NULL)
                     {
                         noframes = node;
                         TY_(InsertNodeAtEnd)(frameset, noframes);
                         state = STATE_PARSE_NOFRAMES;
                         keepToken = yes;
                     }
                     else
                     {
                         TY_(FreeNode)( doc, node);
                     }
 
                     continue;
                 }
 
                 /* Deal with some other element that we're not expecting. */
                 if (TY_(nodeIsElement)(node))
                 {
                     if (node->tag && node->tag->model & CM_HEAD)
                     {
                         MoveToHead(doc, html, node);
                         continue;
                     }
 
                     /* Discard illegal frame element following a frameset. */
                     if ( frameset != NULL && nodeIsFRAME(node) )
                     {
                         TY_(Report)(doc, html, node, DISCARDING_UNEXPECTED);
                         TY_(FreeNode)(doc, node);
                         continue;
                     }
                 }
 
                 TY_(UngetToken)( doc );
 
                 /* Insert other content into noframes element. */
                 if (frameset)
                 {
                     if (noframes == NULL)
                     {
                         noframes = TY_(InferredTag)(doc, TidyTag_NOFRAMES);
                         TY_(InsertNodeAtEnd)(frameset, noframes);
                     }
                     else
                     {
                         TY_(Report)(doc, html, node, NOFRAMES_CONTENT);
                         if (noframes->type == StartEndTag)
                             noframes->type = StartTag;
                     }
 
                     TY_(ConstrainVersion)(doc, VERS_FRAMESET);
                     state = STATE_PARSE_NOFRAMES;
                     keepToken = yes;
                     continue;
                 }
 
                 node = TY_(InferredTag)(doc, TidyTag_BODY);
 
                 /* Issue #132 - disable inserting BODY tag warning
                  BUT only if NOT --show-body-only yes */
                 if (!showingBodyOnly(doc))
                     TY_(Report)(doc, html, node, INSERTING_TAG );
 
                 TY_(ConstrainVersion)(doc, ~VERS_FRAMESET);
                 state = STATE_PARSE_BODY;
                 keepToken = yes;
                 continue;
             } break;
 
 
             /**************************************************************
              In this case, we're ready to parse the head, and move on to
              look for the body or body alternative.
              **************************************************************/
             case STATE_PARSE_HEAD:
             {
                 TidyParserMemory memory;
                 memory.identity = TY_(ParseHTML);
                 memory.mode = mode;
                 memory.original_node = html;
                 memory.reentry_node = node;
                 memory.reentry_mode = mode;
                 memory.reentry_state = STATE_PARSE_HEAD_DONE;
                 TY_(InsertNodeAtEnd)(html, node);
                 pushMemory( doc, memory );
 #if defined(ENABLE_DEBUG_LOG)
                 parser_depth--;
                 DEBUG_LOG(SPRTF("***Exiting ParseHTML, count: %d, depth %d\n", parser_count, parser_depth));
 #endif
                 return node;
             } break;
 
             case STATE_PARSE_HEAD_DONE:
             {
                 head = node;
                 state = STATE_PRE_BODY;
             } break;
 
 
             /**************************************************************
              In this case, we can finally parse a body.
              **************************************************************/
             case STATE_PARSE_BODY:
             {
                 TidyParserMemory memory;
                 memory.identity = NULL; /* we don't need to reenter */
                 memory.mode = mode;
                 memory.original_node = html;
                 memory.reentry_node = NULL;
                 memory.reentry_mode = mode;
                 memory.reentry_state = STATE_COMPLETE;
                 TY_(InsertNodeAtEnd)(html, node);
                 pushMemory( doc, memory );
 #if defined(ENABLE_DEBUG_LOG)
                 parser_depth--;
                 DEBUG_LOG(SPRTF("***Exiting ParseHTML, count: %d, depth %d\n", parser_count, parser_depth));
 #endif
                 return node;
             } break;
 
 
             /**************************************************************
              In this case, we will parse noframes. If necessary, the
              node is already inserted in the proper spot.
              **************************************************************/
             case STATE_PARSE_NOFRAMES:
             {
                 TidyParserMemory memory;
                 memory.identity = TY_(ParseHTML);
                 memory.mode = mode;
                 memory.original_node = html;
                 memory.reentry_node = frameset;
                 memory.reentry_mode = mode;
                 memory.reentry_state = STATE_PARSE_NOFRAMES_DONE;
                 pushMemory( doc, memory );
 #if defined(ENABLE_DEBUG_LOG)
                 parser_depth--;
                 DEBUG_LOG(SPRTF("***Exiting ParseHTML, count: %d, depth %d\n", parser_count, parser_depth));
 #endif
                 return noframes;
             } break;
 
             case STATE_PARSE_NOFRAMES_DONE:
             {
                 frameset = node;
                 state = STATE_PRE_BODY;
             } break;
 
 
             /**************************************************************
              In this case, we parse the frameset, and look for noframes
              content to merge later if necessary.
              **************************************************************/
             case STATE_PARSE_FRAMESET:
             {
                 TidyParserMemory memory;
                 memory.identity = TY_(ParseHTML);
                 memory.mode = mode;
                 memory.original_node = html;
                 memory.reentry_node = frameset;
                 memory.reentry_mode = mode;
                 memory.reentry_state = STATE_PARSE_FRAMESET_DONE;
                 TY_(InsertNodeAtEnd)(html, node);
                 pushMemory( doc, memory );
 #if defined(ENABLE_DEBUG_LOG)
                 parser_depth--;
                 DEBUG_LOG(SPRTF("***Exiting ParseHTML, count: %d, depth %d\n", parser_count, parser_depth));
 #endif
                 return node;
             } break;
 
             case STATE_PARSE_FRAMESET_DONE:
             {
                 frameset = node;
                 /* See if it includes a noframes element so that
                  we can merge subsequent noframes elements.
                  */
                 for (node = frameset->content; node; node = node->next)
                 {
                     if ( nodeIsNOFRAMES(node) )
                         noframes = node;
                 }
                 state = STATE_PRE_BODY;
             } break;
 
 
             /**************************************************************
              We really shouldn't get here, but if we do, finish nicely.
              **************************************************************/
             default:
             {
                 state = STATE_COMPLETE;
             }
         } /* switch */
     } /* while */
 
 #if defined(ENABLE_DEBUG_LOG)
     parser_depth--;
     DEBUG_LOG(SPRTF("***Exiting ParseHTML, count: %d, depth %d\n", parser_count, parser_depth));
 #endif
     return NULL;
 }
 
 
 /** MARK: TY_(ParseBlock)
  *  `element` is a node created by the lexer upon seeing the start tag, or
  *  by the parser when the start tag is inferred
  */
@@ -5310,139 +5310,140 @@ SPRTF("Exit ParseBlock 9b %d...\n",in_parse_block);
 /** MARK: TY_(ParseNamespace)
  *  Act as a generic XML (sub)tree parser: collect each node and add it
  *  to the DOM, without any further validation. It's useful for tags that
  *  have XML-like content, such as `svg` and `math`.
  *  @note Perhaps this is poorly named, as we're not parsing the namespace
  *    of a particular tag, but a tag with XML-like content.
  *  @note This is a non-recursive parser.
  *  @todo Add schema- or other-hierarchy-definition-based validation
  *    of the subtree here.
  */
 Node* TY_(ParseNamespace)( TidyDocImpl* doc, Node *basenode, GetTokenMode mode, Bool popStack )
 {
     Lexer* lexer = doc->lexer;
     Node *node;
     Node *parent = basenode;
     uint istackbase;
     AttVal* av; /* #130 MathML attr and entity fix! */
 
     /* a la <table>: defer popping elements off the inline stack */
     TY_(DeferDup)( doc );
     istackbase = lexer->istackbase;
     lexer->istackbase = lexer->istacksize;
 
     mode = OtherNamespace; /* Preformatted; IgnoreWhitespace; */
 
     while ((node = TY_(GetToken)(doc, mode)) != NULL)
     {
         /*
         fix check to skip action in InsertMisc for regular/empty
         nodes, which we don't want here...
 
         The way we do it here is by checking and processing everything
         and only what remains goes into InsertMisc()
         */
 
         /* is this a close tag? And does it match the current parent node? */
         if (node->type == EndTag)
         {
             /*
             to prevent end tags flowing from one 'alternate namespace' we
             check this in two phases: first we check if the tag is a
             descendant of the current node, and when it is, we check whether
             it is the end tag for a node /within/ or /outside/ the basenode.
             */
             Bool outside;
             Node *mp = FindMatchingDescendant(parent, node, basenode, &outside);
 
             if (mp != NULL)
             {
                 /*
                 when mp != parent as we might expect,
                 infer end tags until we 'hit' the matched
                 parent or the basenode
                 */
                 Node *n;
 
                 for (n = parent;
                      n != NULL && n != basenode->parent && n != mp;
                      n = n->parent)
                 {
                     /* n->implicit = yes; */
                     n->closed = yes;
                     TY_(Report)(doc, n->parent, n, MISSING_ENDTAG_BEFORE);
                 }
 
                 /* Issue #369 - Since 'assert' is DEBUG only, and there are
                    simple cases where these can be fired, removing them
                    pending feedback from the original author!
                    assert(outside == no ? n == mp : 1);
                    assert(outside == yes ? n == basenode->parent : 1);
                    =================================================== */
 
                 if (outside == no)
                 {
                     /* EndTag for a node within the basenode subtree. Roll on... */
-                    n->closed = yes;
+                    if (n)
+                        n->closed = yes;
                     TY_(FreeNode)(doc, node);
 
                     node = n;
                     parent = node->parent;
                 }
                 else
                 {
                     /* EndTag for a node outside the basenode subtree: let the caller handle that. */
                     TY_(UngetToken)( doc );
                     node = basenode;
                     parent = node->parent;
                 }
 
                 /* when we've arrived at the end-node for the base node, it's quitting time */
                 if (node == basenode)
                 {
                     lexer->istackbase = istackbase;
                     assert(basenode->closed == yes);
                     return NULL;
                 }
             }
             else
             {
                 /* unmatched close tag: report an error and discard */
                 /* TY_(Report)(doc, parent, node, NON_MATCHING_ENDTAG); Issue #308 - Seems wrong warning! */
                 TY_(Report)(doc, parent, node, DISCARDING_UNEXPECTED);
                 assert(parent);
                 /* assert(parent->tag != node->tag); Issue #308 - Seems would always be true! */
                 TY_(FreeNode)( doc, node); /* Issue #308 - Discard unexpected end tag memory */
             }
         }
         else if (node->type == StartTag)
         {
             /* #130 MathML attr and entity fix!
                care if it has attributes, and 'accidently' any of those attributes match known */
             for ( av = node->attributes; av; av = av->next )
             {
                 av->dict = 0; /* does something need to be freed? */
             }
             /* add another child to the current parent */
             TY_(InsertNodeAtEnd)(parent, node);
             parent = node;
         }
         else
         {
             /* #130 MathML attr and entity fix!
                care if it has attributes, and 'accidently' any of those attributes match known */
             for ( av = node->attributes; av; av = av->next )
             {
                 av->dict = 0; /* does something need to be freed? */
             }
             TY_(InsertNodeAtEnd)(parent, node);
         }
     }
 
     TY_(Report)(doc, basenode->parent, basenode, MISSING_ENDTAG_FOR);
     return NULL;
 }
 
 
 /** MARK: TY_(ParseInline)
  *  Parse inline element nodes.
  */
diff --git a/src/pprint.c b/src/pprint.c
index 5522981..c433db3 100644
--- a/src/pprint.c
+++ b/src/pprint.c
@@ -1167,83 +1167,81 @@ static Bool AttrNoIndentFirst( /*TidyDocImpl* doc,*/ Node* node, AttVal* attr )
 static void PPrintAttribute( TidyDocImpl* doc, uint indent,
                              Node *node, AttVal *attr )
 {
     TidyPrintImpl* pprint = &doc->pprint;
     Bool xmlOut    = cfgBool( doc, TidyXmlOut );
     Bool xhtmlOut  = cfgBool( doc, TidyXhtmlOut );
     Bool wrapAttrs = cfgBool( doc, TidyWrapAttVals );
     uint ucAttrs   = cfg( doc, TidyUpperCaseAttrs );
     Bool indAttrs  = cfgBool( doc, TidyIndentAttributes );
     uint xtra      = AttrIndent( doc, node, attr );
     Bool first     = AttrNoIndentFirst( /*doc,*/ node, attr );
     tmbstr name    = attr->attribute;
     Bool wrappable = no;
     tchar c;
 
     /* fix for odd attribute indentation bug triggered by long values */
     if (!indAttrs)
       xtra = 0;
 
     if ( indAttrs )
     {
         if ( TY_(nodeIsElement)(node) && !first )
         {
             indent += xtra;
             PCondFlushLineSmart( doc, indent );
         }
-        else
-          indAttrs = no;
     }
 
     CheckWrapIndent( doc, indent );
 
     if ( !xmlOut && !xhtmlOut && attr->dict )
     {
         if ( TY_(IsScript)(doc, name) )
             wrappable = cfgBool( doc, TidyWrapScriptlets );
         else if (!(attrIsCONTENT(attr) || attrIsVALUE(attr) || attrIsALT(attr) || attrIsTITLE(attr)) && wrapAttrs )
             wrappable = yes;
     }
 
     if ( !first && !SetWrap(doc, indent) )
     {
         TY_(PFlushLine)( doc, indent+xtra );  /* Put it on next line */
     }
     else if ( pprint->linelen > 0 )
     {
         AddChar( pprint, ' ' );
     }
 
     /* Attribute name */
     while (*name)
     {
         c = (unsigned char)*name;
 
         if (c > 0x7F)
             name += TY_(GetUTF8)(name, &c);
         else if (ucAttrs == TidyUppercaseYes)
             c = TY_(ToUpper)(c);
 
         AddChar(pprint, c);
         ++name;
     }
 
     CheckWrapIndent( doc, indent );
  
     if ( attr->value == NULL )
     {
         Bool isB = TY_(IsBoolAttribute)(attr);
         Bool scriptAttr = TY_(attrIsEvent)(attr);
 
         if ( xmlOut )
             PPrintAttrValue( doc, indent, isB ? attr->attribute : NULLSTR,
                              attr->delim, no, scriptAttr );
 
         else if ( !isB && !TY_(IsNewNode)(node) )
             PPrintAttrValue( doc, indent, "", attr->delim, yes, scriptAttr );
 
         else 
             SetWrap( doc, indent );
     }
     else
         PPrintAttrValue( doc, indent, attr->value, attr->delim, wrappable, no );
 }
diff --git a/src/streamio.c b/src/streamio.c
index 07f05c7..96a5c7c 100644
--- a/src/streamio.c
+++ b/src/streamio.c
@@ -498,154 +498,152 @@ StreamOut* TY_(UserOutput)( TidyDocImpl *doc, TidyOutputSink* sink, int encoding
 void TY_(WriteChar)( uint c, StreamOut* out )
 {
     /* Translate outgoing newlines */
     if ( LF == c )
     {
       if ( out->nl == TidyCRLF )
           TY_(WriteChar)( CR, out );
       else if ( out->nl == TidyCR )
           c = CR;
     }
 
     if (out->encoding == MACROMAN)
     {
         EncodeMacRoman( c, out );
     }
     else if (out->encoding == WIN1252)
     {
         EncodeWin1252( c, out );
     }
     else if (out->encoding == IBM858)
     {
         EncodeIbm858( c, out );
     }
     else if (out->encoding == LATIN0)
     {
         EncodeLatin0( c, out );
     }
 
     else if (out->encoding == UTF8)
     {
         int count = 0;
         
         TY_(EncodeCharToUTF8Bytes)( c, NULL, &out->sink, &count );
         if (count <= 0)
         {
             /* replacement char 0xFFFD encoded as UTF-8 */
             PutByte(0xEF, out); PutByte(0xBF, out); PutByte(0xBF, out);
         }
     }
 #ifndef NO_NATIVE_ISO2022_SUPPORT
     else if (out->encoding == ISO2022)
     {
         if (c == 0x1b)  /* ESC */
             out->state = FSM_ESC;
         else
         {
             switch (out->state)
             {
             case FSM_ESC:
                 if (c == '$')
                     out->state = FSM_ESCD;
                 else if (c == '(')
                     out->state = FSM_ESCP;
                 else
                     out->state = FSM_ASCII;
                 break;
 
             case FSM_ESCD:
                 if (c == '(')
                     out->state = FSM_ESCDP;
                 else
                     out->state = FSM_NONASCII;
                 break;
 
             case FSM_ESCDP:
                 out->state = FSM_NONASCII;
                 break;
 
             case FSM_ESCP:
                 out->state = FSM_ASCII;
                 break;
 
             case FSM_NONASCII:
                 c &= 0x7F;
                 break;
 
             case FSM_ASCII:
                 break;
             }
         }
 
         PutByte(c, out);
     }
 #endif /* NO_NATIVE_ISO2022_SUPPORT */
 
     else if ( out->encoding == UTF16LE ||
               out->encoding == UTF16BE ||
               out->encoding == UTF16 )
     {
         int i, numChars = 1;
         uint theChars[2];
         
         if ( !TY_(IsValidUTF16FromUCS4)(c) )
         {
             /* invalid UTF-16 value */
-            c = 0;
             numChars = 0;
         }
         else if ( TY_(IsCombinedChar)(c) )
         {
             /* output both, unless something goes wrong */
             numChars = 2;
             if ( !TY_(SplitSurrogatePair)(c, &theChars[0], &theChars[1]) )
             {
-                c = 0;
                 numChars = 0;
             }
         }
         else
         {
             /* just put the char out */
             theChars[0] = c;
         }
         
         for (i = 0; i < numChars; i++)
         {
             c = theChars[i];
             
             if (out->encoding == UTF16LE)
             {
                 uint ch = c & 0xFF; PutByte(ch, out); 
                 ch = (c >> 8) & 0xFF; PutByte(ch, out); 
             }
     
             else if (out->encoding == UTF16BE || out->encoding == UTF16)
             {
                 uint ch = (c >> 8) & 0xFF; PutByte(ch, out); 
                 ch = c & 0xFF; PutByte(ch, out); 
             }
         }
     }
     else if (out->encoding == BIG5 || out->encoding == SHIFTJIS)
     {
         if (c < 128)
             PutByte(c, out);
         else
         {
             uint ch = (c >> 8) & 0xFF; PutByte(ch, out); 
             ch = c & 0xFF; PutByte(ch, out); 
         }
     }
     else
         PutByte( c, out );
 }
 
 
 
 /****************************
 ** Miscellaneous / Helpers
 ****************************/
 
 /* Mapping for Windows Western character set CP 1252
 ** (chars 128-159/U+0080-U+009F) to Unicode.
 */
