commit 82396cfa523b4b7ef16e720d6c353fc85d91841d
Author: jeanlf <jeanlf@gpac.io>
Date:   Thu May 20 13:13:51 2021 +0200

    updated vvcC syntax to FDIS version

diff --git a/applications/mp4box/filedump.c b/applications/mp4box/filedump.c
index 88310571a..defb0c391 100644
--- a/applications/mp4box/filedump.c
+++ b/applications/mp4box/filedump.c
@@ -2244,104 +2244,106 @@ static void dump_key_info(const u8 *key_info, u32 key_info_size, Bool is_protect
 static void DumpMetaItem(GF_ISOFile *file, Bool root_meta, u32 tk_num, char *name)
 {
 	char szInd[2];
 	u32 i, count, primary_id;
 	u32 meta_type = gf_isom_get_meta_type(file, root_meta, tk_num);
 	if (name[0]=='\t') {
 		szInd[0] = '\t';
 		szInd[1] = 0;
 	} else {
 		szInd[0] = 0;
 	}
 
 	count = gf_isom_get_meta_item_count(file, root_meta, tk_num);
+	if (!count && !meta_type) return;
+
 	primary_id = gf_isom_get_meta_primary_item_id(file, root_meta, tk_num);
 	fprintf(stderr, "%s type: \"%s\" - %d resource item(s)\n", name, meta_type ? gf_4cc_to_str(meta_type) : "undefined", (count+(primary_id>0)));
 	switch (gf_isom_has_meta_xml(file, root_meta, tk_num)) {
 	case 1:
 		fprintf(stderr, "%sMeta has XML resource\n", szInd);
 		break;
 	case 2:
 		fprintf(stderr, "%sMeta has BinaryXML resource\n", szInd);
 		break;
 	}
 	if (primary_id) {
 		fprintf(stderr, "%sPrimary Item - ID %d\n", szInd, primary_id);
 	}
 	for (i=0; i<count; i++) {
 		const char *it_name, *mime, *enc, *url, *urn;
 		Bool self_ref;
 		u32 ID;
 		u32 it_type, cenc_scheme, cenc_version;
 		GF_Err e = gf_isom_get_meta_item_info(file, root_meta, tk_num, i+1, &ID, &it_type, &cenc_scheme, &cenc_version, &self_ref, &it_name, &mime, &enc, &url, &urn);
 		if (e) {
 			fprintf(stderr, "%sItem #%d fetch info error: %s\n", szInd, i+1, gf_error_to_string(e) );
 			continue;
 		}
 		fprintf(stderr, "%sItem #%d: ID %d type %s", szInd, i+1, ID, gf_4cc_to_str(it_type));
 		if (self_ref) fprintf(stderr, " Self-Reference");
 		else if (it_name && it_name[0]) fprintf(stderr, " Name \"%s\"", it_name);
 		if (mime) fprintf(stderr, " MIME: \"%s\"", mime);
 		if (enc) fprintf(stderr, " ContentEncoding: \"%s\"", enc);
 
 		if (meta_type == GF_META_ITEM_TYPE_PICT) {
 			GF_ImageItemProperties img_props;
 			e = gf_isom_get_meta_image_props(file, root_meta, tk_num, ID, &img_props);
 			if (e) {
 				fprintf(stderr, " invalid image properties !");
 			} else {
 				u32 j;
 				Bool chan_diff = 0;
 				if (img_props.width && img_props.height) {
 					fprintf(stderr, " size %ux%u", img_props.width, img_props.height);
 				}
 				if (img_props.hSpacing && img_props.vSpacing) {
 					fprintf(stderr, " SAR %u/%u", img_props.hSpacing, img_props.vSpacing);
 				}
 				if (img_props.num_channels) {
 					fprintf(stderr, " %d channel%s (", img_props.num_channels, (img_props.num_channels>1) ? "s" : "");
 					for (j=1; j<img_props.num_channels; j++) {
 						if (img_props.bits_per_channel[0] != img_props.bits_per_channel[j])
 							chan_diff = 1;
 					}
 					if (chan_diff) {
 						for (j=0; j<img_props.num_channels; j++) {
 							if (j) fprintf(stderr, ",");
 							fprintf(stderr, "%d", img_props.bits_per_channel[j]);
 						}
 					} else {
 						fprintf(stderr, "%d", img_props.bits_per_channel[0]);
 					}
 					fprintf(stderr, " bpc)");
 				}
 				if (img_props.hOffset || img_props.vOffset)
 					fprintf(stderr, " Offset %ux%u", img_props.hOffset, img_props.vOffset);
 				if (img_props.alpha) fprintf(stderr, " Alpha");
 				if (img_props.hidden) fprintf(stderr, " Hidden");
 				if (img_props.angle) fprintf(stderr, " Rotate %d", img_props.angle);
 				if (img_props.mirror) fprintf(stderr, " Mirror %d", img_props.mirror);
 				if (img_props.clap_hden || img_props.clap_wden)
 					fprintf(stderr, " Clap %d/%d,%d/%d,%d/%d,%d/%d", img_props.clap_wnum, img_props.clap_wden, img_props.clap_hnum, img_props.clap_hden, img_props.clap_honum, img_props.clap_hoden, img_props.clap_vonum, img_props.clap_voden);
 			}
 		}
 
 		if (cenc_scheme) {
 			Bool is_protected;
 			u8 skip_byte_block, crypt_byte_block;
 			const u8 *key_info;
 			u32 key_info_size;
 			fprintf(stderr, " - Protection scheme: %s v0x%08X", gf_4cc_to_str(cenc_scheme), cenc_version);
 
 			gf_isom_extract_meta_item_get_cenc_info(file, root_meta, tk_num, ID, &is_protected, &skip_byte_block, &crypt_byte_block, &key_info, &key_info_size, NULL, NULL, NULL, NULL);
 			if (skip_byte_block && crypt_byte_block)
 				fprintf(stderr, " - Pattern %d:%d", skip_byte_block, crypt_byte_block);
 			fprintf(stderr, "\n");
 			dump_key_info(key_info, key_info_size, is_protected);
 		}
 		fprintf(stderr, "\n");
 		if (url) fprintf(stderr, "%sURL: %s\n", szInd, url);
 		if (urn) fprintf(stderr, "%sURN: %s\n", szInd, urn);
-
 	}
+	fprintf(stderr, "\n");
 }
 
 
@@ -2448,83 +2450,83 @@ void dump_hevc_track_info(GF_ISOFile *file, u32 trackNum, GF_HEVCConfig *hevccfg
 void dump_vvc_track_info(GF_ISOFile *file, u32 trackNum, GF_VVCConfig *vvccfg
 #if !defined(GPAC_DISABLE_AV_PARSERS)
 	, VVCState *vvc_state
 #endif /*GPAC_DISABLE_AV_PARSERS  && defined(GPAC_DISABLE_HEVC)*/
 	)
 {
 #if !defined(GPAC_DISABLE_AV_PARSERS)
 	u32 idx;
 #endif
 	u32 k;
-	fprintf(stderr, "\tVVC Info:");
-
-	fprintf(stderr, " Profile %d @ Level %d - Chroma Format %s\n", vvccfg->general_profile_idc, vvccfg->general_level_idc, vvccfg->chromaformat_plus_one ? gf_avc_hevc_get_chroma_format_name(vvccfg->chromaformat_plus_one-1) : "n/a");
-	fprintf(stderr, "\n");
 	fprintf(stderr, "\tNAL Unit length bits: %d", 8*vvccfg->nal_unit_size);
-	if (vvccfg->general_constraint_info && vvccfg->num_constraint_info && vvccfg->general_constraint_info[0]) {
-		fprintf(stderr, " - general constraint info 0x");
-		for (idx=0; idx<vvccfg->num_constraint_info; idx++) {
-			fprintf(stderr, "%02X", vvccfg->general_constraint_info[idx]);
+	if (vvccfg->ptl_present) {
+		fprintf(stderr, " Profile %d @ Level %d - Chroma Format %s", vvccfg->general_profile_idc, vvccfg->general_level_idc, gf_avc_hevc_get_chroma_format_name(vvccfg->chroma_format));
+		if (vvccfg->general_constraint_info && vvccfg->num_constraint_info && vvccfg->general_constraint_info[0]) {
+			fprintf(stderr, " - general constraint info 0x");
+			for (idx=0; idx<vvccfg->num_constraint_info; idx++) {
+				fprintf(stderr, "%02X", vvccfg->general_constraint_info[idx]);
+			}
 		}
+		fprintf(stderr, "\n");
+		fprintf(stderr, "\tBit Depth %d - %d temporal layers\n", vvccfg->bit_depth, vvccfg->numTemporalLayers);
 	}
-	fprintf(stderr, "\n");
+
 	fprintf(stderr, "\tParameter Sets: ");
 	for (k=0; k<gf_list_count(vvccfg->param_array); k++) {
 		GF_NALUFFParamArray *ar=gf_list_get(vvccfg->param_array, k);
 		if (ar->type==GF_VVC_NALU_SEQ_PARAM) {
 			fprintf(stderr, "%d SPS ", gf_list_count(ar->nalus));
 		}
 		if (ar->type==GF_VVC_NALU_PIC_PARAM) {
 			fprintf(stderr, "%d PPS ", gf_list_count(ar->nalus));
 		}
 		if (ar->type==GF_VVC_NALU_VID_PARAM) {
 			fprintf(stderr, "%d VPS ", gf_list_count(ar->nalus));
 
 #if !defined(GPAC_DISABLE_AV_PARSERS) && 0 //TODO
 			for (idx=0; idx<gf_list_count(ar->nalus); idx++) {
 				GF_NALUFFParam *vps = gf_list_get(ar->nalus, idx);
 				s32 ps_idx=gf_hevc_read_vps(vps->data, vps->size, hevc_state);
 				if (hevccfg->is_lhvc && (ps_idx>=0)) {
 					non_hevc_base_layer = ! hevc_state->vps[ps_idx].base_layer_internal_flag;
 				}
 			}
 #endif
 
 		}
 	}
 
 	fprintf(stderr, "\n");
 #if !defined(GPAC_DISABLE_AV_PARSERS) && 0 //TODO
 	for (k=0; k<gf_list_count(vvccfg->param_array); k++) {
 		GF_NALUFFParamArray *ar=gf_list_get(vvccfg->param_array, k);
 		u32 width, height;
 		s32 par_n, par_d;
 
 		if (ar->type !=GF_VVC_NALU_SEQ_PARAM) continue;
 		for (idx=0; idx<gf_list_count(ar->nalus); idx++) {
 			GF_Err e;
 			GF_NALUFFParam *sps = gf_list_get(ar->nalus, idx);
 			par_n = par_d = -1;
 			e = gf_vvc_get_sps_info_with_state(vvc_state, sps->data, sps->size, NULL, &width, &height, &par_n, &par_d);
 			if (e==GF_OK) {
 				fprintf(stderr, "\tSPS resolution %dx%d", width, height);
 				if ((par_n>0) && (par_d>0)) {
 					u32 tw, th;
 					gf_isom_get_track_layout_info(file, trackNum, &tw, &th, NULL, NULL, NULL);
 					fprintf(stderr, " - Pixel Aspect Ratio %d:%d - Indicated track size %d x %d", par_n, par_d, tw, th);
 				}
 				fprintf(stderr, "\n");
 			} else {
 				M4_LOG(GF_LOG_ERROR, ("\nFailed to read SPS: %s\n\n", gf_error_to_string(e) ));
 			}
 		}
 	}
 #endif
-	fprintf(stderr, "\tBit Depth %d - %d temporal layers\n", vvccfg->bit_depth_plus_one-1, vvccfg->numTemporalLayers);
 
 	for (k=0; k<gf_list_count(vvccfg->param_array); k++) {
 		GF_NALUFFParamArray *ar=gf_list_get(vvccfg->param_array, k);
 		if (ar->type==GF_VVC_NALU_SEQ_PARAM) print_config_hash(ar->nalus, "SPS");
 		else if (ar->type==GF_VVC_NALU_PIC_PARAM) print_config_hash(ar->nalus, "PPS");
 		else if (ar->type==GF_VVC_NALU_VID_PARAM) print_config_hash(ar->nalus, "VPS");
 	}
 }
diff --git a/include/gpac/mpeg4_odf.h b/include/gpac/mpeg4_odf.h
index a7b5a14ae..536b78e34 100644
--- a/include/gpac/mpeg4_odf.h
+++ b/include/gpac/mpeg4_odf.h
@@ -1022,34 +1022,34 @@ typedef struct
 /*! VVC config record - not a real MPEG-4 descriptor*/
 typedef struct
 {
-	u8 configurationVersion;
 	u8 general_profile_idc;
 	u8 general_tier_flag;
 	u8 general_sub_profile_idc;
 	u8 num_constraint_info;
 	u8 *general_constraint_info;
 	u8 general_level_idc;
 
 	u8 ptl_sublayer_present_mask;
 	u8 sublayer_level_idc[8];
 
-	u8 chromaformat_plus_one;
-	u8 bit_depth_plus_one;
+	u8 chroma_format;
+	u8 bit_depth;
 	u16 avgFrameRate;
 	u8 constantFrameRate;
 	u8 numTemporalLayers;
+	u16 maxPictureWidth, maxPictureHeight;
 
 	Bool ptl_present, ptl_frame_only_constraint, ptl_multilayer_enabled;
 	u8 num_sub_profiles;
 	u32 *sub_profiles_idc;
 
 	u16 ols_idx;
 	u8 nal_unit_size;
 
 	GF_List *param_array;
 
 	Bool write_annex_b;
 } GF_VVCConfig;
 
 
 /*! used for storing AV1 OBUs*/
diff --git a/src/filters/reframe_nalu.c b/src/filters/reframe_nalu.c
index dbe3c6e1e..cf94f97c4 100644
--- a/src/filters/reframe_nalu.c
+++ b/src/filters/reframe_nalu.c
@@ -1101,169 +1101,170 @@ static void naludmx_create_hevc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32
 static void naludmx_create_vvc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar, Bool *has_vvc_base)
 {
 	u32 i, count;
 	u8 layer_id;
 	Bool first = GF_TRUE;
 	Bool first_lvvc = GF_TRUE;
 	GF_VVCConfig *cfg;
 	u32 max_w, max_h, max_ew, max_eh;
 
 	*has_vvc_base = GF_FALSE;
 
 	max_w = max_h = 0;
 	max_ew = max_eh = 0;
 	sar->num = sar->den = 0;
 
 	cfg = gf_odf_vvc_cfg_new();
 	cfg->nal_unit_size = ctx->nal_length;
 
 	//check we have one pps or sps in base layer
 	count = gf_list_count(ctx->sps);
 	for (i=0; i<count; i++) {
 		GF_NALUFFParam *sl = gf_list_get(ctx->sps, i);
 		layer_id = (sl->data[0] & 0x3f);
 		//todo, base is not always 0 !
 		if (!layer_id) {
 			*has_vvc_base = GF_TRUE;
 			break;
 		}
 	}
 	count = gf_list_count(ctx->pps);
 	for (i=0; i<count; i++) {
 		GF_NALUFFParam *sl = gf_list_get(ctx->pps, i);
 		layer_id = (sl->data[0] & 0x3f);
 		//todo, base is not always 0 !
 		if (!layer_id) {
 			*has_vvc_base = GF_TRUE;
 			break;
 		}
 	}
 	//assign vps first so that they are serialized first
 	count = gf_list_count(ctx->vps);
 	for (i=0; i<count; i++) {
 		GF_NALUFFParam *sl = gf_list_get(ctx->vps, i);
 		VVC_VPS *vps = &ctx->vvc_state->vps[sl->id];
 
 		if (!i) {
 			cfg->avgFrameRate = vps->rates[0].avg_pic_rate;
 			cfg->constantFrameRate = vps->rates[0].constand_pic_rate_idc;
 			cfg->numTemporalLayers = vps->max_sub_layers;
 		}
 		if (!ctx->analyze)
 			naludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_VID_PARAM);
 	}
 
 	count = gf_list_count(ctx->sps);
 	for (i=0; i<count; i++) {
 		Bool is_lvvc = GF_FALSE;
 		GF_NALUFFParam *sl = gf_list_get(ctx->sps, i);
 		VVC_SPS *sps = &ctx->vvc_state->sps[sl->id];
 		layer_id = sl->data[0] & 0x3f;
 		if (!layer_id) *has_vvc_base = GF_TRUE;
 
 		if (ctx->explicit || layer_id) {
 			is_lvvc = GF_TRUE;
 		}
 
 		if (first || (is_lvvc && first_lvvc) ) {
 			VVC_VPS *vps = &ctx->vvc_state->vps[sps->vps_id];
-			cfg->configurationVersion = 1;
 			cfg->avgFrameRate = 0;
 			cfg->constantFrameRate = 1;
 			cfg->numTemporalLayers = sps->max_sublayers;
 			cfg->nal_unit_size = ctx->nal_length;
 			cfg->ptl_present = vps->num_ptl ? 1 : 0;
 
 			if (vps->num_ptl) {
 				cfg->num_constraint_info = vps->ptl[0].gci_present ? 1 : 12;
 				cfg->general_profile_idc = vps->ptl[0].general_profile_idc;
 				cfg->general_tier_flag = vps->ptl[0].general_tier_flag;
 				cfg->general_level_idc = vps->ptl[0].general_level_idc;
 				cfg->ptl_frame_only_constraint = vps->ptl[0].frame_only_constraint;
 				cfg->ptl_multilayer_enabled = vps->ptl[0].multilayer_enabled;
 
 				cfg->general_constraint_info = gf_malloc(sizeof(u8) * cfg-> num_constraint_info);
 				if (cfg->general_constraint_info)
 					memcpy(cfg->general_constraint_info, vps->ptl[0].gci, cfg->num_constraint_info);
 
 				//todo set temporal sublayers
 				cfg->ptl_sublayer_present_mask = 0;
 				cfg->num_sub_profiles = 0;
 				cfg->ols_idx = 0;
 			}
-			cfg->chromaformat_plus_one = 1 + sps->chroma_format_idc;
-			cfg->bit_depth_plus_one = 1 + sps->bitdepth;
+			cfg->chroma_format = sps->chroma_format_idc;
+			cfg->bit_depth = sps->bitdepth;
+			cfg->maxPictureWidth = sps->width;
+			cfg->maxPictureHeight = sps->height;
 
 			if (sps->aspect_ratio_info_present_flag && sps->sar_width && sps->sar_height) {
 				sar->num = sps->sar_width;
 				sar->den = sps->sar_height;
 			}
 
 			/*disable frame rate scan, most bitstreams have wrong values there*/
 			if (!ctx->timescale && first && (!ctx->fps.num || !ctx->fps.den) && sps->has_timing_info
 				/*if detected FPS is greater than 1000, assume wrong timing info*/
 				&& (sps->time_scale <= 1000*sps->num_units_in_tick)
 			) {
 				ctx->cur_fps.num = sps->time_scale;
 				ctx->cur_fps.den = sps->num_units_in_tick;
 
 				if (!ctx->fps.num && ctx->dts==ctx->fps.den)
 					ctx->dts = ctx->cur_fps.den;
 			}
 			ctx->fps = ctx->cur_fps;
 		}
 		first = GF_FALSE;
 		if (is_lvvc) {
 			first_lvvc = GF_FALSE;
 			if (sps->width > max_ew) max_ew = sps->width;
 			if (sps->height > max_eh) max_eh = sps->height;
 		} else {
 			if (sps->width > max_w) max_w = sps->width;
 			if (sps->height > max_h) max_h = sps->height;
 		}
 		if (!ctx->analyze)
 			naludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_SEQ_PARAM);
 	}
 
 	count = gf_list_count(ctx->pps);
 	for (i=0; i<count; i++) {
 		GF_NALUFFParam *sl = gf_list_get(ctx->pps, i);
 		layer_id = sl->data[0] & 0x3F;
 		if (!layer_id) *has_vvc_base = GF_TRUE;
 		if (!ctx->analyze)
 			naludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_PIC_PARAM);
 	}
 
 	count = gf_list_count(ctx->vvc_dci);
 	for (i=0; i<count; i++) {
 		GF_NALUFFParam *sl = gf_list_get(ctx->vvc_dci, i);
 		layer_id = sl->data[0] & 0x3F;
 		if (!layer_id) *has_vvc_base = GF_TRUE;
 		if (!ctx->analyze)
 			naludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_DEC_PARAM);
 	}
 
 	count = gf_list_count(ctx->vvc_aps_pre);
 	for (i=0; i<count; i++) {
 		GF_NALUFFParam *sl = gf_list_get(ctx->vvc_aps_pre, i);
 		layer_id = sl->data[0] & 0x3F;
 		if (!layer_id) *has_vvc_base = GF_TRUE;
 		if (!ctx->analyze)
 			naludmx_add_param_nalu(cfg->param_array, sl, GF_VVC_NALU_APS_PREFIX);
 	}
 
 	*dsi = *dsi_enh = NULL;
 	*dsi_size = *dsi_enh_size = 0;
 
 	gf_odf_vvc_cfg_write(cfg, dsi, dsi_size);
 	*max_width = max_w;
 	*max_height = max_h;
 	*max_enh_width = max_ew;
 	*max_enh_height = max_eh;
 
 	count = gf_list_count(cfg->param_array);
 	for (i=0; i<count; i++) {
 		GF_NALUFFParamArray *pa = gf_list_get(cfg->param_array, i);
 		gf_list_reset(pa->nalus);
 	}
 	gf_odf_vvc_cfg_del(cfg);
 }
diff --git a/src/isomedia/avc_ext.c b/src/isomedia/avc_ext.c
index 4fb5a6140..a234825fa 100644
--- a/src/isomedia/avc_ext.c
+++ b/src/isomedia/avc_ext.c
@@ -3014,38 +3014,48 @@ GF_Err vvcc_box_write(GF_Box *s, GF_BitStream *bs)
 GF_Err vvcc_box_size(GF_Box *s)
 {
 	u32 i, count, j, subcount;
 	GF_VVCConfigurationBox *ptr = (GF_VVCConfigurationBox *)s;
 
 	if (!ptr->config) {
 		ptr->size = 0;
 		return GF_OK;
 	}
 
-	ptr->size += 6;
+	ptr->size += 1;
 	if (ptr->config->ptl_present) {
+		ptr->size += 3;
+		//size PTL
 		if (!ptr->config->general_constraint_info)
 			ptr->config->num_constraint_info = 0;
 		if (!ptr->config->sub_profiles_idc)
 			ptr->config->num_sub_profiles = 0;
 
-		ptr->size += 2 + 2 + ptr->config->num_constraint_info + 2 + ptr->config->num_sub_profiles*4;
+		ptr->size += 3 + ptr->config->num_constraint_info;
 		if (ptr->config->numTemporalLayers>1)
 			ptr->size += 1;
 		for (i=0; i<ptr->config->numTemporalLayers; i++) {
 			if (ptr->config->ptl_sublayer_present_mask & (1<<i))
 				ptr->size+=1;
 		}
+		ptr->size += 1 + ptr->config->num_sub_profiles*4;
+		//end size PTL
+		ptr->size += 6;
 	}
 
+	ptr->size += 1;
 	count = gf_list_count(ptr->config->param_array);
 	for (i=0; i<count; i++) {
 		GF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(ptr->config->param_array, i);
-		ptr->size += 3;
+		if ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))
+			ptr->size += 3;
+		else
+			ptr->size += 1;
+
 		subcount = gf_list_count(ar->nalus);
 		for (j=0; j<subcount; j++) {
 			ptr->size += 2 + ((GF_NALUFFParam *)gf_list_get(ar->nalus, j))->size;
 		}
 	}
 	return GF_OK;
 }
 #endif
diff --git a/src/isomedia/box_dump.c b/src/isomedia/box_dump.c
index 445c3cfa8..0669b07e6 100644
--- a/src/isomedia/box_dump.c
+++ b/src/isomedia/box_dump.c
@@ -1704,66 +1704,67 @@ GF_Err hvcc_box_dump(GF_Box *a, FILE * trace)
 GF_Err vvcc_box_dump(GF_Box *a, FILE * trace)
 {
 	u32 i, count;
 	char boxname[256];
 	GF_VVCConfigurationBox *p = (GF_VVCConfigurationBox *) a;
 
 	sprintf(boxname, "VVCConfigurationBox");
 	gf_isom_box_dump_start(a, boxname, trace);
 	gf_fprintf(trace, ">\n");
 
 	if (! p->config) {
 		if (p->size) {
 			gf_fprintf(trace, "<!-- INVALID VVC ENTRY: no VVC config record -->\n");
 		} else {
 			gf_fprintf(trace, "<VVCDecoderConfigurationRecord nal_unit_size=\"\" configurationVersion=\"\" ");
 			gf_fprintf(trace, "general_profile_idc=\"\" general_tier_flag=\"\" general_sub_profile_idc=\"\" general_constraint_info=\"\" general_level_idc=\"\" ");
-			gf_fprintf(trace, "chroma_format=\"\" luma_bit_depth=\"\" chroma_bit_depth=\"\" avgFrameRate=\"\" constantFrameRate=\"\" numTemporalLayers=\"\"");
+			gf_fprintf(trace, "chroma_format=\"\" luma_bit_depth=\"\" chroma_bit_depth=\"\" avgFrameRate=\"\" constantFrameRate=\"\" numTemporalLayers=\"\" maxWidth=\"\" maxHeight=\"\"");
 
 			gf_fprintf(trace, ">\n");
 			gf_fprintf(trace, "<ParameterSetArray nalu_type=\"\" complete_set=\"\">\n");
 			gf_fprintf(trace, "<ParameterSet size=\"\" content=\"\"/>\n");
 			gf_fprintf(trace, "</ParameterSetArray>\n");
 			gf_fprintf(trace, "</VVCDecoderConfigurationRecord>\n");
 		}
 		gf_fprintf(trace, "</VVCConfigurationBox>\n");
 		return GF_OK;
 	}
 
 	gf_fprintf(trace, "<VVCDecoderConfigurationRecord nal_unit_size=\"%d\" ", p->config->nal_unit_size);
-	gf_fprintf(trace, "configurationVersion=\"%u\" ", p->config->configurationVersion);
-	gf_fprintf(trace, "general_profile_idc=\"%u\" ", p->config->general_profile_idc);
-	gf_fprintf(trace, "general_tier_flag=\"%u\" ", p->config->general_tier_flag);
-	gf_fprintf(trace, "general_sub_profile_idc=\"%u\" ", p->config->general_sub_profile_idc);
-	if (p->config->general_constraint_info) {
-		gf_fprintf(trace, "general_constraint_info=\"");
-		dump_data_hex(trace, p->config->general_constraint_info, p->config->num_constraint_info);
-		gf_fprintf(trace, "\" ");
+	if (p->config->ptl_present) {
+
+		gf_fprintf(trace, "chroma_format=\"%s\" chroma_bit_depth=\"%u\" avgFrameRate=\"%u\" constantFrameRate=\"%u\" numTemporalLayers=\"%u\" maxWidth=\"%u\" maxHeight=\"%u\" ",
+			gf_avc_hevc_get_chroma_format_name(p->config->chroma_format),
+			p->config->bit_depth, p->config->avgFrameRate, p->config->constantFrameRate, p->config->numTemporalLayers, p->config->maxPictureWidth, p->config->maxPictureHeight);
+
+		gf_fprintf(trace, "general_profile_idc=\"%u\" ", p->config->general_profile_idc);
+		gf_fprintf(trace, "general_tier_flag=\"%u\" ", p->config->general_tier_flag);
+		gf_fprintf(trace, "general_sub_profile_idc=\"%u\" ", p->config->general_sub_profile_idc);
+		if (p->config->general_constraint_info) {
+			gf_fprintf(trace, "general_constraint_info=\"");
+			dump_data_hex(trace, p->config->general_constraint_info, p->config->num_constraint_info);
+			gf_fprintf(trace, "\" ");
+		}
+		gf_fprintf(trace, "general_level_idc=\"%u\" ", p->config->general_level_idc);
 	}
-	gf_fprintf(trace, "general_level_idc=\"%u\" ", p->config->general_level_idc);
-
-	gf_fprintf(trace, "chroma_format=\"%s\" chroma_bit_depth=\"%u\" avgFrameRate=\"%u\" constantFrameRate=\"%u\" numTemporalLayers=\"%u\" ",
-			p->config->chromaformat_plus_one ? gf_avc_hevc_get_chroma_format_name(p->config->chromaformat_plus_one) : "n/a",
-			p->config->bit_depth_plus_one - 1, p->config->avgFrameRate, p->config->constantFrameRate, p->config->numTemporalLayers);
-
 	gf_fprintf(trace, ">\n");
 
 	count = gf_list_count(p->config->param_array);
 	for (i=0; i<count; i++) {
 		u32 nalucount, j;
 		GF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(p->config->param_array, i);
 		gf_fprintf(trace, "<ParameterSetArray nalu_type=\"%d\" complete_set=\"%d\">\n", ar->type, ar->array_completeness);
 		nalucount = gf_list_count(ar->nalus);
 		for (j=0; j<nalucount; j++) {
 			GF_NALUFFParam *c = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);
 			gf_fprintf(trace, "<ParameterSet size=\"%d\" content=\"", c->size);
 			dump_data(trace, c->data, c->size);
 			gf_fprintf(trace, "\"/>\n");
 		}
 		gf_fprintf(trace, "</ParameterSetArray>\n");
 	}
 
 	gf_fprintf(trace, "</VVCDecoderConfigurationRecord>\n");
 
 	gf_isom_box_dump_done(boxname, a, trace);
 	return GF_OK;
 }
diff --git a/src/isomedia/iff.c b/src/isomedia/iff.c
index 14c1bf8da..2357fc2fe 100644
--- a/src/isomedia/iff.c
+++ b/src/isomedia/iff.c
@@ -1282,318 +1282,318 @@ static GF_Err gf_isom_iff_create_image_item_from_track_internal(GF_ISOFile *movi
 import_next_sample:
 
 	timescale = gf_isom_get_media_timescale(fsrc, imported_track);
 	if (image_props->sample_num) {
 		sample_number = image_props->sample_num;
 		sample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);
 		e = gf_isom_last_error(fsrc);
 	} else if (image_props->time<0) {
 		sample = gf_isom_get_sample(fsrc, imported_track, sample_number, &sample_desc_index);
 		e = gf_isom_last_error(fsrc);
 	} else {
 		e = gf_isom_get_sample_for_media_time(fsrc, imported_track, (u64)(image_props->time*timescale), &sample_desc_index, GF_ISOM_SEARCH_SYNC_FORWARD, &sample, &sample_number, NULL);
 	}
 	if (e || !sample || !sample->IsRAP) {
 		if (!sample) {
 			if (is_first) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("No sample found%s\n", (image_props->time<0) ? "" : " for requested time"));
 			} else {
 				e = GF_OK;
 				goto exit;
 			}
 		} else if ((image_props->time<0) || (image_props->step_time)) {
 			if (image_props->sample_num) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: imported sample %d (DTS "LLU") is not a sync sample (RAP %d size %d)\n", sample_number, sample->DTS, sample->IsRAP, sample->dataLength));
 			} else if (image_props->step_time) {
 				gf_isom_sample_del(&sample);
 				e = GF_OK;
 				goto exit;
 			} else {
 				gf_isom_sample_del(&sample);
 				sample_number++;
 				if (sample_number == gf_isom_get_sample_count(fsrc, imported_track)) {
 					e = GF_OK;
 					goto exit;
 				}
 				goto import_next_sample;
 			}
 		} else {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error no sync sample found after time %g\n", image_props->time));
 		}
 		if (!e) e = GF_BAD_PARAM;
 		goto exit;
 	}
 
 	/* Check if the track type is supported as item type */
 	/* Get the config box if needed */
 	subtype = gf_isom_get_media_subtype(fsrc, imported_track, sample_desc_index);
 	if (gf_isom_is_media_encrypted(fsrc, imported_track, sample_desc_index)) {
 		if (gf_isom_is_cenc_media(fsrc, imported_track, sample_desc_index)) {
 			e = gf_isom_get_original_format_type(fsrc, imported_track, sample_desc_index, &subtype);
 			if (e) goto exit;
 			is_cenc = GF_TRUE;
 		} else {
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Protected sample not using CENC, cannot add as item\n"));
 			e = GF_BAD_PARAM;
 			goto exit;
 		}
 	}
 
 
 	switch (subtype) {
 	case GF_ISOM_SUBTYPE_AVC_H264:
 	case GF_ISOM_SUBTYPE_AVC2_H264:
 	case GF_ISOM_SUBTYPE_AVC3_H264:
 	case GF_ISOM_SUBTYPE_AVC4_H264:
 		//FIXME: in avc1 with multiple descriptor, we should take the right description index
 		config_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AVCC);
 		if (!config_box) { e = GF_OUT_OF_MEM; goto exit; }
 		((GF_AVCConfigurationBox *)config_box)->config = gf_isom_avc_config_get(fsrc, imported_track, sample_desc_index);
 		if (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }
 		item_type = GF_ISOM_SUBTYPE_AVC_H264;
 		config_needed = 1;
 		num_channels = 3;
 		bits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;
 		bits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;
 		bits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;
 		break;
 	case GF_ISOM_SUBTYPE_SVC_H264:
 		config_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_SVCC);
 		if (!config_box) { e = GF_OUT_OF_MEM; goto exit; }
 		((GF_AVCConfigurationBox *)config_box)->config = gf_isom_svc_config_get(fsrc, imported_track, sample_desc_index);
 		if (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }
 		item_type = GF_ISOM_SUBTYPE_SVC_H264;
 		config_needed = 1;
 		num_channels = 3;
 		bits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;
 		bits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;
 		bits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;
 		break;
 	case GF_ISOM_SUBTYPE_MVC_H264:
 		config_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_MVCC);
 		if (!config_box) { e = GF_OUT_OF_MEM; goto exit; }
 		((GF_AVCConfigurationBox *)config_box)->config = gf_isom_mvc_config_get(fsrc, imported_track, sample_desc_index);
 		if (! ((GF_AVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }
 		item_type = GF_ISOM_SUBTYPE_MVC_H264;
 		config_needed = 1;
 		num_channels = 3;
 		bits_per_channel[0] = ((GF_AVCConfigurationBox *)config_box)->config->luma_bit_depth;
 		bits_per_channel[1] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;
 		bits_per_channel[2] = ((GF_AVCConfigurationBox *)config_box)->config->chroma_bit_depth;
 		break;
 	case GF_ISOM_SUBTYPE_HVC1:
 	case GF_ISOM_SUBTYPE_HEV1:
 	case GF_ISOM_SUBTYPE_HVC2:
 	case GF_ISOM_SUBTYPE_HEV2:
 	case GF_ISOM_SUBTYPE_HVT1:
 	case GF_ISOM_SUBTYPE_LHV1:
 	case GF_ISOM_SUBTYPE_LHE1:
 		config_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_HVCC);
 		if (!config_box) { e = GF_OUT_OF_MEM; goto exit; }
 		((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_hevc_config_get(fsrc, imported_track, sample_desc_index);
 		if (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }
 		if (subtype == GF_ISOM_SUBTYPE_HVT1) {
 			item_type = GF_ISOM_SUBTYPE_HVT1;
 		}
 		else {
 			item_type = GF_ISOM_SUBTYPE_HVC1;
 		}
 		config_needed = 1;
 		if (!((GF_HEVCConfigurationBox *)config_box)->config) {
 			((GF_HEVCConfigurationBox *)config_box)->config = gf_isom_lhvc_config_get(fsrc, imported_track, sample_desc_index);
 			if (! ((GF_HEVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }
 			item_type = GF_ISOM_SUBTYPE_LHV1;
 		}
 		num_channels = 3;
 		bits_per_channel[0] = ((GF_HEVCConfigurationBox *)config_box)->config->luma_bit_depth;
 		bits_per_channel[1] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;
 		bits_per_channel[2] = ((GF_HEVCConfigurationBox *)config_box)->config->chroma_bit_depth;
 		//media_brand = GF_ISOM_BRAND_HEIC;
 		break;
 	case GF_ISOM_SUBTYPE_AV01:
 		{
 			config_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_AV1C);
 			if (!config_box) { e = GF_OUT_OF_MEM; goto exit; }
 			((GF_AV1ConfigurationBox *)config_box)->config = gf_isom_av1_config_get(fsrc, imported_track, sample_desc_index);
 			if (! ((GF_AV1ConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }
 			item_type = GF_ISOM_SUBTYPE_AV01;
 			config_needed = 1;
 			u8 depth = ((GF_AV1ConfigurationBox *)config_box)->config->high_bitdepth ? (((GF_AV1ConfigurationBox *)config_box)->config->twelve_bit ? 12 : 10 ) : 8;
 			if (((GF_AV1ConfigurationBox *)config_box)->config->monochrome) {
 				num_channels = 1;
 				bits_per_channel[0] = depth;
 				bits_per_channel[1] = 0;
 				bits_per_channel[2] = 0;
 			} else {
 				num_channels = 3;
 				bits_per_channel[0] = depth;
 				bits_per_channel[1] = depth;
 				bits_per_channel[2] = depth;
 			}
 			// presence of OBU SH in config is not recommended and properties should be used instead of metadata OBUs
 			while (gf_list_count(((GF_AV1ConfigurationBox *)config_box)->config->obu_array)) {
 				GF_AV1_OBUArrayEntry *obu = gf_list_pop_back(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);
 				if (obu) {
 					if (obu->obu) gf_free(obu->obu);
 					gf_free(obu);
 				}
 			}
 			gf_list_del(((GF_AV1ConfigurationBox *)config_box)->config->obu_array);
 			((GF_AV1ConfigurationBox *)config_box)->config->obu_array = NULL;
 			gf_media_av1_layer_size_get(fsrc, imported_track, sample_number, image_props->av1_layer_size);
 			//media_brand = GF_ISOM_BRAND_AVIF;
 		}
 		break;
 
 	case GF_ISOM_SUBTYPE_VVC1:
 		config_box = gf_isom_box_new(GF_ISOM_BOX_TYPE_VVCC);
 		if (!config_box) { e = GF_OUT_OF_MEM; goto exit; }
 		((GF_VVCConfigurationBox *)config_box)->config = gf_isom_vvc_config_get(fsrc, imported_track, sample_desc_index);
 		if (! ((GF_VVCConfigurationBox *)config_box)->config) { e = GF_OUT_OF_MEM; goto exit; }
 		item_type = GF_ISOM_SUBTYPE_VVC1;
 
 		config_needed = 1;
 		num_channels = 3;
-		bits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth_plus_one - 1;
+		bits_per_channel[0] = ((GF_VVCConfigurationBox *)config_box)->config->bit_depth;
 		bits_per_channel[1] = bits_per_channel[2] = bits_per_channel[0];
 		//media_brand = GF_ISOM_BRAND_HEIC;
 		break;
 	default:
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: Codec not supported to create HEIF image items\n"));
 		e = GF_NOT_SUPPORTED;
 		goto exit;
 	}
 	if (config_needed && !config_box && !((GF_AVCConfigurationBox *)config_box)->config) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error: Image type %s requires a missing configuration box\n", gf_4cc_to_str(item_type)));
 		e = GF_BAD_PARAM;
 		goto exit;
 	}
 	/* Get some images properties from the track data */
 	e = gf_isom_get_visual_info(fsrc, imported_track, sample_desc_index, &w, &h);
 	if (e) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error determining image size\n"));
 		goto exit;
 	}
 	e = gf_isom_get_pixel_aspect_ratio(fsrc, imported_track, sample_desc_index, &hSpacing, &vSpacing);
 	if (e) {
 		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("Error determining image aspect ratio\n"));
 		goto exit;
 	}
 	if (!image_props->width && !image_props->height) {
 		image_props->width = w;
 		image_props->height = h;
 	}
 	if (!image_props->hSpacing && !image_props->vSpacing) {
 		image_props->hSpacing = hSpacing;
 		image_props->vSpacing = vSpacing;
 	}
 	image_props->config = config_box;
 	if (!image_props->num_channels) {
 		image_props->num_channels = num_channels;
 		image_props->bits_per_channel[0] = bits_per_channel[0];
 		image_props->bits_per_channel[1] = bits_per_channel[1];
 		image_props->bits_per_channel[2] = bits_per_channel[2];
 	}
 	if (is_cenc) {
 		Bool Is_Encrypted;
 
 		memset(&ipro, 0, sizeof(GF_ImageItemProtection));
 		gf_isom_get_cenc_info(fsrc, imported_track, sample_desc_index, NULL, &ipro.scheme_type, &ipro.scheme_version);
 		e = gf_isom_get_sample_cenc_info(fsrc, imported_track, sample_desc_index, &Is_Encrypted, &ipro.crypt_byte_block, &ipro.skip_byte_block, &ipro.key_info, &ipro.key_info_size);
 		if (e) goto exit;
 
 		if (Is_Encrypted) {
 			sai_size = sai_alloc_size;
 			e = gf_isom_cenc_get_sample_aux_info(fsrc, imported_track, sample_number, sample_desc_index, NULL, &sai, &sai_size);
 			if (e) goto exit;
 
 			if (sai_size > sai_alloc_size)
 				sai_alloc_size = sai_size;
 
 			ipro.sai_data = sai;
 			ipro.sai_data_size = sai_size;
 			image_props->cenc_info = &ipro;
 
 			if (is_first) {
 				u32 i, nb_pssh = gf_isom_get_pssh_count(fsrc);
 				for (i=0; i<nb_pssh; i++) {
 					bin128 SystemID;
 					u32 version;
 					u32 KID_count;
 					const bin128 *KIDs;
 					const u8 *private_data;
 					u32 private_data_size;
 
 					gf_isom_get_pssh_info(fsrc, i+1, SystemID, &version, &KID_count, &KIDs, &private_data, &private_data_size);
 					
 					gf_cenc_set_pssh(movie, SystemID, version, KID_count, (bin128 *) KIDs, (u8 *) private_data, private_data_size, 2);
 				}
 			}
 
 		} else {
 			image_props->cenc_info = NULL;
 		}
 	}
 
 	if (!item_id) {
 		e = gf_isom_meta_get_next_item_id(movie, root_meta, meta_track_number, &item_id);
 		if (e) goto exit;
 	}
 	if (image_props->use_reference) {
 		if (image_props->sample_num) {
 			GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("referring trackID %d sample %d as item %d\n", imported_track, sample_number, item_id));
 		} else {
 			GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("referring trackID %d sample at time %.3f as item %d\n", imported_track, (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));
 		}
 		e = gf_isom_add_meta_item_sample_ref(movie, root_meta, meta_track_number, (!item_name || !strlen(item_name)) ? "Image" : item_name, &item_id, item_type, NULL, NULL, image_props, imported_track, sample_number);
 	} else {
 
 		if (image_props->sample_num) {
 			GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("Adding sample %d as item %d\n", sample_number, item_id));
 		} else {
 			GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, ("Adding sample at time %.3f as item %d\n", (sample->DTS+sample->CTS_Offset)*1.0/timescale, item_id));
 		}
 		e = gf_isom_add_meta_item_memory(movie, root_meta, meta_track_number, (!item_name || !strlen(item_name) ? "Image" : item_name), &item_id, item_type, NULL, NULL, image_props, sample->data, sample->dataLength, item_extent_refs);
 
 	}
 
 	image_props->cenc_info = NULL;
 
 	gf_isom_set_brand_info(movie, GF_ISOM_BRAND_MIF1, 0);
 	gf_isom_reset_alt_brands(movie);
 	// TODO Analyze configuration to determine the brand */
 	//if (media_brand) {
 	//	gf_isom_modify_alternate_brand(movie, media_brand, GF_TRUE);
 	//}
 
 	if (neg_time)
 		image_props->time = -1;
 
 	if (!e && !image_props->sample_num && ((image_props->time<0) || image_props->end_time || image_props->step_time)) {
 		if (image_props->end_time || image_props->step_time) {
 			Double t = (Double) (sample->DTS + sample->CTS_Offset);
 			t /= timescale;
 			if (image_props->step_time) {
 				t += image_props->step_time;
 			} else {
 				//step 1ms
 				t += 0.001;
 			}
 
 			if ((image_props->end_time>0) && (t>image_props->end_time)) {
 				goto exit;
 			}
 			image_props->time = t;
 		}
 
 		item_id=0;
 		gf_isom_sample_del(&sample);
 		if (config_box) {
 			gf_isom_box_del(config_box);
 			config_box = NULL;
 		}
 		is_first = GF_FALSE;
 		if (sample_number >= gf_isom_get_sample_count(fsrc, imported_track)) return e;
 		sample_number++;
 		//avoid recursion this could get quite big
 		goto import_next_sample;
 	}
diff --git a/src/media_tools/isom_tools.c b/src/media_tools/isom_tools.c
index 0459080a8..2016daa12 100644
--- a/src/media_tools/isom_tools.c
+++ b/src/media_tools/isom_tools.c
@@ -3936,8 +3936,12 @@ GF_Err rfc_6381_get_codec_dolby_vision(char *szCodec, u32 subtype, GF_DOVIDecode
 GF_Err rfc_6381_get_codec_vvc(char *szCodec, u32 subtype, GF_VVCConfig *vvcc)
 {
 	assert(vvcc);
 
-	snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, "%s.%d.%s%d", gf_4cc_to_str(subtype), vvcc->general_profile_idc, vvcc->general_tier_flag ? "H" : "L", vvcc->general_level_idc);
+	if ( (subtype==GF_4CC('v','v','c','N')) || (subtype==GF_4CC('v','v','s','1')) ) {
+		snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, "%s", gf_4cc_to_str(subtype));
+	} else {
+		snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, "%s.%d.%s%d", gf_4cc_to_str(subtype), vvcc->general_profile_idc, vvcc->general_tier_flag ? "H" : "L", vvcc->general_level_idc);
+	}
 	return GF_OK;
 }
 GF_Err rfc_6381_get_codec_mpegha(char *szCodec, u32 subtype, u8 *dsi, u32 dsi_size, s32 pl)
diff --git a/src/odf/descriptors.c b/src/odf/descriptors.c
index 69fdf9de4..afc623729 100644
--- a/src/odf/descriptors.c
+++ b/src/odf/descriptors.c
@@ -1083,11 +1083,12 @@ GF_EXPORT
 GF_VVCConfig *gf_odf_vvc_cfg_new()
 {
 	GF_VVCConfig *cfg;
 	GF_SAFEALLOC(cfg, GF_VVCConfig);
 	if (!cfg) return NULL;
 	cfg->param_array = gf_list_new();
-	cfg->configurationVersion = 1;
 	cfg->nal_unit_size = 4;
+	cfg->chroma_format = 1;
+	cfg->bit_depth = 8;
 	return cfg;
 }
 
@@ -1120,90 +1121,94 @@ GF_EXPORT
 GF_Err gf_odf_vvc_cfg_write_bs(GF_VVCConfig *cfg, GF_BitStream *bs)
 {
 	u32 i, count;
 
 	count = gf_list_count(cfg->param_array);
 
 	if (!cfg->write_annex_b) {
-		gf_bs_write_u8(bs, cfg->configurationVersion);
-		gf_bs_write_u16(bs, cfg->avgFrameRate);
-		gf_bs_write_int(bs, cfg->constantFrameRate, 2);
-		gf_bs_write_int(bs, cfg->numTemporalLayers, 3);
+
+		gf_bs_write_int(bs, 0xFF, 5);
 		gf_bs_write_int(bs, cfg->nal_unit_size - 1, 2);
 		gf_bs_write_int(bs, cfg->ptl_present, 1);
 
 		if (cfg->ptl_present) {
 			s32 idx;
+
+			gf_bs_write_int(bs, cfg->ols_idx, 9);
+			gf_bs_write_int(bs, cfg->numTemporalLayers, 3);
+			gf_bs_write_int(bs, cfg->constantFrameRate, 2);
+			gf_bs_write_int(bs, cfg->chroma_format, 2);
+			gf_bs_write_int(bs, cfg->bit_depth - 8, 3);
+			gf_bs_write_int(bs, 0xFF, 5);
+
 			if (!cfg->general_constraint_info)
 				cfg->num_constraint_info = 0;
 
-			gf_bs_write_u8(bs, cfg->num_constraint_info);
+			//write PTL
+			gf_bs_write_int(bs, 0, 2);
+			gf_bs_write_int(bs, cfg->num_constraint_info, 6);
 			gf_bs_write_int(bs, cfg->general_profile_idc, 7);
 			gf_bs_write_int(bs, cfg->general_tier_flag, 1);
 			gf_bs_write_u8(bs, cfg->general_level_idc);
 			gf_bs_write_int(bs, cfg->ptl_frame_only_constraint, 1);
 			gf_bs_write_int(bs, cfg->ptl_multilayer_enabled, 1);
 
 			if (cfg->num_constraint_info) {
 				gf_bs_write_data(bs, cfg->general_constraint_info, cfg->num_constraint_info - 1);
 				gf_bs_write_int(bs, cfg->general_constraint_info[cfg->num_constraint_info - 1], 6);
 			} else {
 				gf_bs_write_int(bs, 0, 6);
 			}
+
 			for (idx=cfg->numTemporalLayers-2; idx>=0; idx--) {
 				u8 val = cfg->ptl_sublayer_present_mask & (1<<idx);
-				gf_bs_write_int(bs, val, 1);
+				gf_bs_write_int(bs, val ? 1 : 0, 1);
 			}
 			for (idx=cfg->numTemporalLayers; idx<=8 && cfg->numTemporalLayers>1; idx++) {
 				gf_bs_write_int(bs, 0, 1);
 			}
 			for (idx=cfg->numTemporalLayers-2; idx>=0; idx--) {
 				if (cfg->ptl_sublayer_present_mask & (1<<idx))
 					gf_bs_write_u8(bs, cfg->sublayer_level_idc[idx]);
 			}
 			if (!cfg->sub_profiles_idc) cfg->num_sub_profiles = 0;
 			gf_bs_write_u8(bs, cfg->num_sub_profiles);
 			for (idx=0; idx<cfg->num_sub_profiles; idx++) {
 				gf_bs_write_u32(bs, cfg->sub_profiles_idc[idx]);
 			}
-			gf_bs_write_int(bs, cfg->ols_idx, 16);
-		}
-		gf_bs_write_int(bs, cfg->chromaformat_plus_one ? 1 : 0, 1);
-		if (cfg->chromaformat_plus_one)
-			gf_bs_write_int(bs, cfg->chromaformat_plus_one - 1, 2);
-		else
-			gf_bs_write_int(bs, 0xFF, 2);
+			//end PTL
 
-		gf_bs_write_int(bs, cfg->bit_depth_plus_one ? 1 : 0, 1);
-		if (cfg->bit_depth_plus_one)
-			gf_bs_write_int(bs, cfg->bit_depth_plus_one - 8 - 1, 3);
-		else
-			gf_bs_write_int(bs, 0xFF, 3);
-
-		gf_bs_write_int(bs, 1, 1);
+			gf_bs_write_u16(bs, cfg->maxPictureWidth);
+			gf_bs_write_u16(bs, cfg->maxPictureHeight);
+			gf_bs_write_u16(bs, cfg->avgFrameRate);
+		}
 		gf_bs_write_int(bs, count, 8);
 	}
 
 	for (i=0; i<count; i++) {
 		u32 nalucount, j;
 		GF_NALUFFParamArray *ar = (GF_NALUFFParamArray*)gf_list_get(cfg->param_array, i);
 
 		nalucount = gf_list_count(ar->nalus);
 		if (!cfg->write_annex_b) {
 			gf_bs_write_int(bs, ar->array_completeness, 1);
-			gf_bs_write_int(bs, 0, 1);
-			gf_bs_write_int(bs, ar->type, 6);
-			gf_bs_write_int(bs, nalucount, 16);
+			gf_bs_write_int(bs, 0, 2);
+			gf_bs_write_int(bs, ar->type, 5);
+
+			if ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))
+				gf_bs_write_int(bs, nalucount, 16);
+			else
+				nalucount = 1;
 		}
 
 		for (j=0; j<nalucount; j++) {
 			GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(ar->nalus, j);
 			if (!cfg->write_annex_b) {
 				gf_bs_write_int(bs, sl->size, 16);
 			} else {
 				gf_bs_write_u32(bs, 1);
 			}
 			gf_bs_write_data(bs, sl->data, sl->size);
 		}
 	}
 	return GF_OK;
 }
@@ -1227,124 +1232,127 @@ GF_EXPORT
 GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs)
 {
 	u32 i, count;
 	GF_VVCConfig *cfg = gf_odf_vvc_cfg_new();
 
-	cfg->configurationVersion = gf_bs_read_u8(bs);
-	cfg->avgFrameRate = gf_bs_read_u16(bs);
-	cfg->constantFrameRate = gf_bs_read_int(bs, 2);
-	cfg->numTemporalLayers = gf_bs_read_int(bs, 3);
+	gf_bs_read_int(bs, 5);
 	cfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2);
 	cfg->ptl_present = gf_bs_read_int(bs, 1);
 
 	if (cfg->ptl_present) {
 		s32 j;
-		cfg->num_constraint_info = gf_bs_read_u8(bs);
+
+		cfg->ols_idx = gf_bs_read_int(bs, 9);
+		cfg->numTemporalLayers = gf_bs_read_int(bs, 3);
+		cfg->constantFrameRate = gf_bs_read_int(bs, 2);
+		cfg->chroma_format = gf_bs_read_int(bs, 2);
+		cfg->bit_depth = 8 + gf_bs_read_int(bs, 3);
+		gf_bs_read_int(bs, 5);
+
+		//parse PTL
+		gf_bs_read_int(bs, 2);
+		cfg->num_constraint_info = gf_bs_read_int(bs, 6);
 		cfg->general_profile_idc = gf_bs_read_int(bs, 7);
 		cfg->general_tier_flag = gf_bs_read_int(bs, 1);
 		cfg->general_level_idc = gf_bs_read_u8(bs);
 		cfg->ptl_frame_only_constraint = gf_bs_read_int(bs, 1);
 		cfg->ptl_multilayer_enabled = gf_bs_read_int(bs, 1);
 
 		if (cfg->num_constraint_info) {
 			cfg->general_constraint_info = gf_malloc(sizeof(u8)*cfg->num_constraint_info);
 			if (!cfg->general_constraint_info) {
 				gf_free(cfg);
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] alloc failed while parsing vvc config\n"));
 				return NULL;
 			}
 			gf_bs_read_data(bs, cfg->general_constraint_info, cfg->num_constraint_info - 1);
 			cfg->general_constraint_info[cfg->num_constraint_info-1] =  gf_bs_read_int(bs, 6);
 		} else {
+			//forbidden in spec!
 			gf_bs_read_int(bs, 6);
 		}
 
 		cfg->ptl_sublayer_present_mask = 0;
 		for (j=cfg->numTemporalLayers-2; j>=0; j--) {
-			u8 val = gf_bs_read_int(bs, 1);
-			cfg->ptl_sublayer_present_mask = val << j;
+			u32 val = gf_bs_read_int(bs, 1);
+			cfg->ptl_sublayer_present_mask |= val << j;
 		}
 		for (j=cfg->numTemporalLayers; j<=8 && cfg->numTemporalLayers>1; j++) {
 			gf_bs_read_int(bs, 1);
 		}
 		for (j=cfg->numTemporalLayers-2; j>=0; j--) {
 			if (cfg->ptl_sublayer_present_mask & (1<<j)) {
 				cfg->sublayer_level_idc[j] = gf_bs_read_u8(bs);
 			}
 		}
 		cfg->num_sub_profiles = gf_bs_read_u8(bs);
 		if (cfg->num_sub_profiles) {
 			cfg->sub_profiles_idc = gf_malloc(sizeof(u32)*cfg->num_sub_profiles);
 			if (!cfg->sub_profiles_idc) {
 				gf_free(cfg->general_constraint_info);
 				gf_free(cfg);
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] alloc failed while parsing vvc config\n"));
 				return NULL;
 			}
 		}
 		for (i=0; i<cfg->num_sub_profiles; i++) {
 			cfg->sub_profiles_idc[i] = gf_bs_read_u32(bs);
 		}
-		cfg->ols_idx = gf_bs_read_u16(bs);
-	}
 
-	if (gf_bs_read_int(bs, 1)) {
-		cfg->chromaformat_plus_one = 1 + gf_bs_read_int(bs, 2);
-	} else {
-		cfg->chromaformat_plus_one = 0;
-		gf_bs_read_int(bs, 2);
-	}
+		//end PTL
 
-	if (gf_bs_read_int(bs, 1)) {
-		cfg->bit_depth_plus_one = 1 + 8 + gf_bs_read_int(bs, 3);
-	} else {
-		cfg->bit_depth_plus_one = 0;
-		gf_bs_read_int(bs, 3);
+		cfg->maxPictureWidth = gf_bs_read_u16(bs);
+		cfg->maxPictureHeight = gf_bs_read_u16(bs);
+		cfg->avgFrameRate = gf_bs_read_u16(bs);
 	}
-	gf_bs_read_int(bs, 1);
 
 	count = gf_bs_read_int(bs, 8);
 	for (i=0; i<count; i++) {
 		u32 nalucount, j;
 		GF_NALUFFParamArray *ar;
 		GF_SAFEALLOC(ar, GF_NALUFFParamArray);
 		if (!ar) {
 			gf_odf_vvc_cfg_del(cfg);
 			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] alloc failed while parsing vvc config\n"));
 			return NULL;
 		}
 		ar->nalus = gf_list_new();
 		gf_list_add(cfg->param_array, ar);
 
 		ar->array_completeness = gf_bs_read_int(bs, 1);
-		gf_bs_read_int(bs, 1);
-		ar->type = gf_bs_read_int(bs, 6);
-		nalucount = gf_bs_read_int(bs, 16);
+		gf_bs_read_int(bs, 2);
+		ar->type = gf_bs_read_int(bs, 5);
+
+		if ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI))
+			nalucount = gf_bs_read_int(bs, 16);
+		else
+			nalucount = 1;
+			
 		for (j=0; j<nalucount; j++) {
 			GF_NALUFFParam *sl;
 			u32 size = gf_bs_read_int(bs, 16);
 			if (size>gf_bs_available(bs)) {
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] Wrong param set size %d\n", size));
 				gf_odf_vvc_cfg_del(cfg);
 				return NULL;
 			}
 			GF_SAFEALLOC(sl, GF_NALUFFParam );
 			if (!sl) {
 				gf_odf_vvc_cfg_del(cfg);
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] alloc failed while parsing vvc config\n"));
 				return NULL;
 			}
 
 			sl->size = size;
 			sl->data = (char *)gf_malloc(sizeof(char) * sl->size);
 			if (!sl->data) {
 				gf_free(sl);
 				gf_odf_vvc_cfg_del(cfg);
 				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso file] alloc failed while parsing vvc config\n"));
 				return NULL;
 			}
 			gf_bs_read_data(bs, sl->data, sl->size);
 			gf_list_add(ar->nalus, sl);
 		}
 	}
 	return cfg;
 }
