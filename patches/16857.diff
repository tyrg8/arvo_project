commit 7a9958485036ef37b4e88df5cbe32bd7ec4c0d25
Author: tbeu <tbeu@users.noreply.github.com>
Date:   Mon Sep 2 22:15:11 2019 +0200

    Fix reading data from v4 MAT file
    
    As reported by https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16857, https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16858, https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16874 and https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16878

diff --git a/src/mat4.c b/src/mat4.c
index c3726a4..db38e80 100644
--- a/src/mat4.c
+++ b/src/mat4.c
@@ -292,348 +292,452 @@ int
 Mat_VarRead4(mat_t *mat,matvar_t *matvar)
 {
     int err;
     size_t nelems = 1;
 
     err = SafeMulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return err;
     }
 
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
 
     switch ( matvar->class_type ) {
         case MAT_C_DOUBLE:
             matvar->data_size = sizeof(double);
             err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
             if ( err ) {
                 Mat_Critical("Integer multiplication overflow");
                 return err;
             }
 
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL != complex_data ) {
-                    matvar->data = complex_data;
-                    ReadDoubleData(mat, (double*)complex_data->Re, matvar->data_type, nelems);
-                    ReadDoubleData(mat, (double*)complex_data->Im, matvar->data_type, nelems);
+                    size_t readcount;
+                    readcount = ReadDoubleData(mat, (double*)complex_data->Re, matvar->data_type, nelems);
+                    err = readcount != nelems;
+                    readcount = ReadDoubleData(mat, (double*)complex_data->Im, matvar->data_type, nelems);
+                    err |= readcount != nelems;
+                    if ( 0 == err ) {
+                       matvar->data = complex_data;
+                    } else {
+                        ComplexFree(complex_data);
+                        return err;
+                    }
                 }
                 else {
                     Mat_Critical("Couldn't allocate memory for the complex data");
-                    err = 1;
+                    return 1;
                 }
             } else {
                 matvar->data = malloc(matvar->nbytes);
                 if ( NULL != matvar->data ) {
-                    ReadDoubleData(mat, (double*)matvar->data, matvar->data_type, nelems);
+                    const size_t readcount = ReadDoubleData(mat, (double*)matvar->data, matvar->data_type, nelems);
+                    if ( readcount != nelems ) {
+                        free(matvar->data);
+                        matvar->data = NULL;
+                        return 1;
+                    }
                 }
                 else {
                     Mat_Critical("Couldn't allocate memory for the data");
-                    err = 1;
+                    return 1;
                 }
             }
             /* Update data type to match format of matvar->data */
             matvar->data_type = MAT_T_DOUBLE;
             break;
         case MAT_C_CHAR:
             matvar->data_size = 1;
             matvar->nbytes = nelems;
             matvar->data = malloc(matvar->nbytes);
             if ( NULL != matvar->data ) {
-                ReadUInt8Data(mat, (mat_uint8_t*)matvar->data, matvar->data_type, nelems);
+                const size_t readcount = ReadUInt8Data(mat, (mat_uint8_t*)matvar->data, matvar->data_type, nelems);
+                if ( readcount != nelems ) {
+                    free(matvar->data);
+                    matvar->data = NULL;
+                    return 1;
+                }
             }
             else {
                 Mat_Critical("Couldn't allocate memory for the data");
-                err = 1;
+                return 1;
             }
             matvar->data_type = MAT_T_UINT8;
             break;
         case MAT_C_SPARSE:
             matvar->data_size = sizeof(mat_sparse_t);
             matvar->data      = malloc(matvar->data_size);
             if ( NULL != matvar->data ) {
                 double tmp;
                 int i;
                 mat_sparse_t* sparse;
                 long fpos;
                 enum matio_types data_type = MAT_T_DOUBLE;
+                size_t readcount;
 
                 /* matvar->dims[1] either is 3 for real or 4 for complex sparse */
                 matvar->isComplex = matvar->dims[1] == 4 ? 1 : 0;
                 sparse = (mat_sparse_t*)matvar->data;
                 sparse->nir = matvar->dims[0] - 1;
                 sparse->nzmax = sparse->nir;
                 sparse->ir = (mat_int32_t*)malloc(sparse->nir*sizeof(mat_int32_t));
                 if ( sparse->ir != NULL ) {
-                    ReadInt32Data(mat, sparse->ir, data_type, sparse->nir);
+                    readcount = ReadInt32Data(mat, sparse->ir, data_type, sparse->nir);
+                    if ( readcount != sparse->nir ) {
+                        free(sparse->ir);
+                        free(matvar->data);
+                        matvar->data = NULL;
+                        return 1;
+                    }
                     for ( i = 0; i < sparse->nir; i++ )
                         sparse->ir[i] = sparse->ir[i] - 1;
                 } else {
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Couldn't allocate memory for the sparse row array");
                     return 1;
                 }
-                ReadDoubleData(mat, &tmp, data_type, 1);
+                readcount = ReadDoubleData(mat, &tmp, data_type, 1);
+                if ( readcount != 1 || tmp > INT_MAX-1 || tmp < 0 ) {
+                    free(sparse->ir);
+                    free(matvar->data);
+                    matvar->data = NULL;
+                    Mat_Critical("Invalid row dimension for sparse matrix");
+                    return 1;
+                }
                 matvar->dims[0] = (size_t)tmp;
 
                 fpos = ftell((FILE*)mat->fp);
                 if ( fpos == -1L ) {
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Couldn't determine file position");
                     return 1;
                 }
-                (void)fseek((FILE*)mat->fp,sparse->nir*Mat_SizeOf(data_type),
-                    SEEK_CUR);
-                ReadDoubleData(mat, &tmp, data_type, 1);
-                if ( tmp > INT_MAX-1 || tmp < 0 ) {
+                (void)fseek((FILE*)mat->fp,sparse->nir*Mat_SizeOf(data_type),SEEK_CUR);
+                readcount = ReadDoubleData(mat, &tmp, data_type, 1);
+                if ( readcount != 1 || tmp > INT_MAX-1 || tmp < 0 ) {
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Invalid column dimension for sparse matrix");
                     return 1;
                 }
                 matvar->dims[1] = (size_t)tmp;
                 (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);
                 if ( matvar->dims[1] > INT_MAX-1 ) {
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Invalid column dimension for sparse matrix");
                     return 1;
                 }
                 sparse->njc = (int)matvar->dims[1] + 1;
                 sparse->jc = (mat_int32_t*)malloc(sparse->njc*sizeof(mat_int32_t));
                 if ( sparse->jc != NULL ) {
                     mat_int32_t *jc;
                     jc = (mat_int32_t*)malloc(sparse->nir*sizeof(mat_int32_t));
                     if ( jc != NULL ) {
                         int j = 0;
                         sparse->jc[0] = 0;
-                        ReadInt32Data(mat, jc, data_type, sparse->nir);
+                        readcount = ReadInt32Data(mat, jc, data_type, sparse->nir);
+                        if ( readcount != sparse->nir ) {
+                            free(jc);
+                            free(sparse->jc);
+                            free(sparse->ir);
+                            free(matvar->data);
+                            matvar->data = NULL;
+                            return 1;
+                        }
                         for ( i = 1; i < sparse->njc-1; i++ ) {
                             while ( j < sparse->nir && jc[j] <= i )
                                 j++;
                             sparse->jc[i] = j;
                         }
                         free(jc);
                         /* terminating nnz */
                         sparse->jc[sparse->njc-1] = sparse->nir;
                     } else {
                         free(sparse->jc);
                         free(sparse->ir);
                         free(matvar->data);
                         matvar->data = NULL;
                         Mat_Critical("Couldn't allocate memory for the sparse index array");
                         return 1;
                     }
                 } else {
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Couldn't allocate memory for the sparse index array");
                     return 1;
                 }
-                ReadDoubleData(mat, &tmp, data_type, 1);
+                readcount = ReadDoubleData(mat, &tmp, data_type, 1);
+                if ( readcount != 1 ) {
+                    free(sparse->jc);
+                    free(sparse->ir);
+                    free(matvar->data);
+                    matvar->data = NULL;
+                    return 1;
+                }
                 sparse->ndata = sparse->nir;
                 data_type = matvar->data_type;
                 if ( matvar->isComplex ) {
                     mat_complex_split_t *complex_data =
                         ComplexMalloc(sparse->ndata*Mat_SizeOf(data_type));
                     if ( NULL != complex_data ) {
                         sparse->data = complex_data;
 #if defined(EXTENDED_SPARSE)
                         switch ( data_type ) {
                             case MAT_T_DOUBLE:
-                                ReadDoubleData(mat, (double*)complex_data->Re,
+                                readcount = ReadDoubleData(mat, (double*)complex_data->Re,
                                     data_type, sparse->ndata);
-                                ReadDoubleData(mat, &tmp, data_type, 1);
-                                ReadDoubleData(mat, (double*)complex_data->Im,
+                                err = readcount != sparse->ndata;
+                                readcount = ReadDoubleData(mat, &tmp, data_type, 1);
+                                err |= readcount != 1;
+                                readcount = ReadDoubleData(mat, (double*)complex_data->Im,
                                     data_type, sparse->ndata);
-                                ReadDoubleData(mat, &tmp, data_type, 1);
+                                err |= readcount != sparse->ndata;
+                                readcount = ReadDoubleData(mat, &tmp, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             case MAT_T_SINGLE:
                             {
                                 float tmp2;
-                                ReadSingleData(mat, (float*)complex_data->Re,
+                                readcount = ReadSingleData(mat, (float*)complex_data->Re,
                                     data_type, sparse->ndata);
-                                ReadSingleData(mat, &tmp2, data_type, 1);
-                                ReadSingleData(mat, (float*)complex_data->Im,
+                                err = readcount != sparse->ndata;
+                                readcount = ReadSingleData(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
+                                readcount = ReadSingleData(mat, (float*)complex_data->Im,
                                     data_type, sparse->ndata);
-                                ReadSingleData(mat, &tmp2, data_type, 1);
+                                err |= readcount != sparse->ndata;
+                                readcount = ReadSingleData(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_INT32:
                             {
                                 mat_int32_t tmp2;
-                                ReadInt32Data(mat, (mat_int32_t*)complex_data->Re,
+                                readcount = ReadInt32Data(mat, (mat_int32_t*)complex_data->Re,
                                     data_type, sparse->ndata);
-                                ReadInt32Data(mat, &tmp2, data_type, 1);
-                                ReadInt32Data(mat, (mat_int32_t*)complex_data->Im,
+                                err = readcount != sparse->ndata;
+                                readcount = ReadInt32Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
+                                readcount = ReadInt32Data(mat, (mat_int32_t*)complex_data->Im,
                                     data_type, sparse->ndata);
-                                ReadInt32Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != sparse->ndata;
+                                readcount = ReadInt32Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_INT16:
                             {
                                 mat_int16_t tmp2;
-                                ReadInt16Data(mat, (mat_int16_t*)complex_data->Re,
+                                readcount = ReadInt16Data(mat, (mat_int16_t*)complex_data->Re,
                                     data_type, sparse->ndata);
-                                ReadInt16Data(mat, &tmp2, data_type, 1);
-                                ReadInt16Data(mat, (mat_int16_t*)complex_data->Im,
+                                err = readcount != sparse->ndata;
+                                readcount = ReadInt16Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
+                                readcount = ReadInt16Data(mat, (mat_int16_t*)complex_data->Im,
                                     data_type, sparse->ndata);
-                                ReadInt16Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != sparse->ndata;
+                                readcount = ReadInt16Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_UINT16:
                             {
                                 mat_uint16_t tmp2;
-                                ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Re,
+                                readcount = ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Re,
                                     data_type, sparse->ndata);
-                                ReadUInt16Data(mat, &tmp2, data_type, 1);
-                                ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Im,
+                                err = readcount != sparse->ndata;
+                                readcount = ReadUInt16Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
+                                readcount = ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Im,
                                     data_type, sparse->ndata);
-                                ReadUInt16Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != sparse->ndata;
+                                readcount = ReadUInt16Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_UINT8:
                             {
                                 mat_uint8_t tmp2;
-                                ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Re,
+                                readcount = ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Re,
                                     data_type, sparse->ndata);
-                                ReadUInt8Data(mat, &tmp2, data_type, 1);
-                                ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Im,
+                                err = readcount != sparse->ndata;
+                                readcount = ReadUInt8Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
+                                readcount = ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Im,
                                     data_type, sparse->ndata);
-                                ReadUInt8Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != sparse->ndata;
+                                readcount = ReadUInt8Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             default:
                                 ComplexFree(complex_data);
                                 free(sparse->jc);
                                 free(sparse->ir);
                                 free(matvar->data);
                                 matvar->data = NULL;
                                 Mat_Critical("Mat_VarRead4: %d is not a supported data type for "
                                     "extended sparse", data_type);
                                 return 1;
                         }
 #else
-                        ReadDoubleData(mat, (double*)complex_data->Re,
+                        readcount = ReadDoubleData(mat, (double*)complex_data->Re,
                             data_type, sparse->ndata);
-                        ReadDoubleData(mat, &tmp, data_type, 1);
-                        ReadDoubleData(mat, (double*)complex_data->Im,
+                        err = readcount != sparse->ndata;
+                        readcount = ReadDoubleData(mat, &tmp, data_type, 1);
+                        err |= readcount != 1;
+                        readcount = ReadDoubleData(mat, (double*)complex_data->Im,
                             data_type, sparse->ndata);
-                        ReadDoubleData(mat, &tmp, data_type, 1);
+                        err |= readcount != sparse->ndata;
+                        readcount = ReadDoubleData(mat, &tmp, data_type, 1);
+                        err |= readcount != 1;
 #endif
+                        if ( err ) {
+                            ComplexFree(complex_data);
+                            free(sparse->jc);
+                            free(sparse->ir);
+                            free(matvar->data);
+                            matvar->data = NULL;
+                            return err;
+                        }
                     }
                     else {
                         free(sparse->jc);
                         free(sparse->ir);
                         free(matvar->data);
                         matvar->data = NULL;
                         Mat_Critical("Couldn't allocate memory for the complex sparse data");
                         return 1;
                     }
                 } else {
                     sparse->data = malloc(sparse->ndata*Mat_SizeOf(data_type));
                     if ( sparse->data != NULL ) {
 #if defined(EXTENDED_SPARSE)
                         switch ( data_type ) {
                             case MAT_T_DOUBLE:
-                                ReadDoubleData(mat, (double*)sparse->data,
+                                readcount = ReadDoubleData(mat, (double*)sparse->data,
                                     data_type, sparse->ndata);
-                                ReadDoubleData(mat, &tmp, data_type, 1);
+                                err = readcount != sparse->ndata;
+                                readcount = ReadDoubleData(mat, &tmp, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             case MAT_T_SINGLE:
                             {
                                 float tmp2;
-                                ReadSingleData(mat, (float*)sparse->data,
+                                readcount = ReadSingleData(mat, (float*)sparse->data,
                                     data_type, sparse->ndata);
-                                ReadSingleData(mat, &tmp2, data_type, 1);
+                                err = readcount != sparse->ndata;
+                                readcount = ReadSingleData(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_INT32:
                             {
                                 mat_int32_t tmp2;
-                                ReadInt32Data(mat, (mat_int32_t*)sparse->data,
+                                readcount = ReadInt32Data(mat, (mat_int32_t*)sparse->data,
                                     data_type, sparse->ndata);
-                                ReadInt32Data(mat, &tmp2, data_type, 1);
+                                err = readcount != sparse->ndata;
+                                readcount = ReadInt32Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_INT16:
                             {
                                 mat_int16_t tmp2;
-                                ReadInt16Data(mat, (mat_int16_t*)sparse->data,
+                                readcount = ReadInt16Data(mat, (mat_int16_t*)sparse->data,
                                     data_type, sparse->ndata);
-                                ReadInt16Data(mat, &tmp2, data_type, 1);
+                                err = readcount != sparse->ndata;
+                                readcount = ReadInt16Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_UINT16:
                             {
                                 mat_uint16_t tmp2;
-                                ReadUInt16Data(mat, (mat_uint16_t*)sparse->data,
+                                readcount = ReadUInt16Data(mat, (mat_uint16_t*)sparse->data,
                                     data_type, sparse->ndata);
-                                ReadUInt16Data(mat, &tmp2, data_type, 1);
+                                err = readcount != sparse->ndata;
+                                readcount = ReadUInt16Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_UINT8:
                             {
                                 mat_uint8_t tmp2;
-                                ReadUInt8Data(mat, (mat_uint8_t*)sparse->data,
+                                readcount = ReadUInt8Data(mat, (mat_uint8_t*)sparse->data,
                                     data_type, sparse->ndata);
-                                ReadUInt8Data(mat, &tmp2, data_type, 1);
+                                err = readcount != sparse->ndata;
+                                readcount = ReadUInt8Data(mat, &tmp2, data_type, 1);
+                                err |= readcount != 1;
                                 break;
                             }
                             default:
                                 free(sparse->data);
                                 free(sparse->jc);
                                 free(sparse->ir);
                                 free(matvar->data);
                                 matvar->data = NULL;
                                 Mat_Critical("Mat_VarRead4: %d is not a supported data type for "
                                     "extended sparse", data_type);
                                 return 1;
                         }
 #else
-                        ReadDoubleData(mat, (double*)sparse->data, data_type, sparse->ndata);
-                        ReadDoubleData(mat, &tmp, data_type, 1);
+                        readcount = ReadDoubleData(mat, (double*)sparse->data, data_type, sparse->ndata);
+                        err = readcount != sparse->ndata;
+                        readcount = ReadDoubleData(mat, &tmp, data_type, 1);
+                        err |= readcount != 1;
 #endif
+                        if ( err ) {
+                            free(sparse->data);
+                            free(sparse->jc);
+                            free(sparse->ir);
+                            free(matvar->data);
+                            matvar->data = NULL;
+                            return err;
+                        }
                     } else {
                         free(sparse->jc);
                         free(sparse->ir);
                         free(matvar->data);
                         matvar->data = NULL;
                         Mat_Critical("Couldn't allocate memory for the sparse data");
                         return 1;
                     }
                 }
                 break;
             }
             else {
                 Mat_Critical("Couldn't allocate memory for the data");
                 return 1;
             }
         default:
             Mat_Critical("MAT V4 data type error");
             return 1;
     }
 
     return err;
 }
 
 /** @if mat_devman
  * @brief Reads a slab of data from a version 4 MAT file for the @c matvar variable
  *
  * @ingroup mat_internal
  * @param mat Version 4 MAT file pointer
  * @param matvar pointer to the mat variable
  * @param data pointer to store the read data in (must be of size
  *             edge[0]*...edge[rank-1]*Mat_SizeOfClass(matvar->class_type))
  * @param start index to start reading data in each dimension
  * @param stride write data every @c stride elements in each dimension
  * @param edge number of elements to read in each dimension
  * @retval 0 on success
  * @endif
  */
diff --git a/src/mat5.c b/src/mat5.c
index 8752003..373c028 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -407,82 +407,83 @@ static size_t
 ReadSparse(mat_t *mat, matvar_t *matvar, int *n, mat_int32_t **v)
 {
     int data_in_tag = 0;
     enum matio_types packed_type;
     mat_uint32_t tag[2];
     size_t bytesread = 0;
     mat_int32_t N = 0;
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
         matvar->internal->z->avail_in = 0;
         InflateDataType(mat,matvar->internal->z,tag);
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             N = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
             (void)ReadCompressedInt32Data(mat,matvar->internal->z,
                         (mat_int32_t*)&N,MAT_T_INT32,1);
         }
 #endif
     } else {
         bytesread += fread(tag,4,1,(FILE*)mat->fp);
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             N = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
             bytesread += fread(&N,4,1,(FILE*)mat->fp);
             if ( mat->byteswap )
                 (void)Mat_int32Swap(&N);
         }
     }
     *n = N / 4;
     *v = (mat_int32_t*)malloc(*n*sizeof(mat_int32_t));
     if ( NULL != *v ) {
         int nBytes;
         if ( matvar->compression == MAT_COMPRESSION_NONE ) {
             nBytes = ReadInt32Data(mat,*v,packed_type,*n);
             /*
                 * If the data was in the tag we started on a 4-byte
                 * boundary so add 4 to make it an 8-byte
                 */
-            if ( data_in_tag )
+            nBytes *= Mat_SizeOf(packed_type);
+			if ( data_in_tag )
                 nBytes+=4;
             if ( (nBytes % 8) != 0 )
                 (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if defined(HAVE_ZLIB)
         } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                             *v,packed_type,*n);
             /*
                 * If the data was in the tag we started on a 4-byte
                 * boundary so add 4 to make it an 8-byte
                 */
             if ( data_in_tag )
                 nBytes+=4;
             if ( (nBytes % 8) != 0 )
                 InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
 #endif
         }
     } else {
         Mat_Critical("Couldn't allocate memory");
     }
 
     return bytesread;
 }
 
 #if defined(HAVE_ZLIB)
 /** @brief determines the number of bytes needed to store the given variable
  *
  * @ingroup mat_internal
  * @param matvar MAT variable
  * @param size the number of bytes needed to store the variable
  * @return 0 on success
  */
@@ -2627,164 +2628,165 @@ static void
 Mat_VarReadNumeric5(mat_t *mat,matvar_t *matvar,void *data,size_t N)
 {
     int nBytes = 0, data_in_tag = 0;
     enum matio_types packed_type = MAT_T_UNKNOWN;
     mat_uint32_t tag[2];
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
         matvar->internal->z->avail_in = 0;
         InflateDataType(mat,matvar->internal->z,tag);
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
 
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             nBytes = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
             InflateDataType(mat,matvar->internal->z,tag+1);
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(tag+1);
             nBytes = tag[1];
         }
 #endif
     } else {
         size_t bytesread = fread(tag,4,1,(FILE*)mat->fp);
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             nBytes = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
             bytesread += fread(tag+1,4,1,(FILE*)mat->fp);
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(tag+1);
             nBytes = tag[1];
         }
     }
     if ( nBytes == 0 ) {
         matvar->nbytes = 0;
         return;
     }
 
     if ( matvar->compression == MAT_COMPRESSION_NONE ) {
         switch ( matvar->class_type ) {
             case MAT_C_DOUBLE:
                 nBytes = ReadDoubleData(mat,(double*)data,packed_type,N);
                 break;
             case MAT_C_SINGLE:
                 nBytes = ReadSingleData(mat,(float*)data,packed_type,N);
                 break;
             case MAT_C_INT64:
 #ifdef HAVE_MAT_INT64_T
                 nBytes = ReadInt64Data(mat,(mat_int64_t*)data,packed_type,N);
 #endif
                 break;
             case MAT_C_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                 nBytes = ReadUInt64Data(mat,(mat_uint64_t*)data,packed_type,N);
 #endif
                 break;
             case MAT_C_INT32:
                 nBytes = ReadInt32Data(mat,(mat_int32_t*)data,packed_type,N);
                 break;
             case MAT_C_UINT32:
                 nBytes = ReadUInt32Data(mat,(mat_uint32_t*)data,packed_type,N);
                 break;
             case MAT_C_INT16:
                 nBytes = ReadInt16Data(mat,(mat_int16_t*)data,packed_type,N);
                 break;
             case MAT_C_UINT16:
                 nBytes = ReadUInt16Data(mat,(mat_uint16_t*)data,packed_type,N);
                 break;
             case MAT_C_INT8:
                 nBytes = ReadInt8Data(mat,(mat_int8_t*)data,packed_type,N);
                 break;
             case MAT_C_UINT8:
                 nBytes = ReadUInt8Data(mat,(mat_uint8_t*)data,packed_type,N);
                 break;
             default:
                 break;
         }
+        nBytes *= Mat_SizeOf(packed_type);
         /*
          * If the data was in the tag we started on a 4-byte
          * boundary so add 4 to make it an 8-byte
          */
         if ( data_in_tag )
             nBytes+=4;
         if ( (nBytes % 8) != 0 )
             (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if defined(HAVE_ZLIB)
     } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
         switch ( matvar->class_type ) {
             case MAT_C_DOUBLE:
                 nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,(double*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_SINGLE:
                 nBytes = ReadCompressedSingleData(mat,matvar->internal->z,(float*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_INT64:
 #ifdef HAVE_MAT_INT64_T
                 nBytes = ReadCompressedInt64Data(mat,matvar->internal->z,(mat_int64_t*)data,
                                                  packed_type,N);
 #endif
                 break;
             case MAT_C_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                 nBytes = ReadCompressedUInt64Data(mat,matvar->internal->z,(mat_uint64_t*)data,
                                                   packed_type,N);
 #endif
                 break;
             case MAT_C_INT32:
                 nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,(mat_int32_t*)data,
                                                  packed_type,N);
                 break;
             case MAT_C_UINT32:
                 nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,(mat_uint32_t*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_INT16:
                 nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,(mat_int16_t*)data,
                                                  packed_type,N);
                 break;
             case MAT_C_UINT16:
                 nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,(mat_uint16_t*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_INT8:
                 nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,(mat_int8_t*)data,
                                                 packed_type,N);
                 break;
             case MAT_C_UINT8:
                 nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,(mat_uint8_t*)data,
                                                  packed_type,N);
                 break;
             default:
                 break;
         }
         /*
          * If the data was in the tag we started on a 4-byte
          * boundary so add 4 to make it an 8-byte
          */
         if ( data_in_tag )
             nBytes+=4;
         if ( (nBytes % 8) != 0 )
             InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
 #endif
     }
 }
 
 /** @if mat_devman
  * @brief Reads the data of a version 5 MAT variable
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar MAT variable pointer to read the data
  * @retval 0 on success
  * @endif
  */
@@ -2792,1033 +2794,1036 @@ int
 Mat_VarRead5(mat_t *mat, matvar_t *matvar)
 {
     int nBytes = 0, byteswap, data_in_tag = 0, err;
     size_t nelems = 1;
     enum matio_types packed_type = MAT_T_UNKNOWN;
     long fpos;
     mat_uint32_t tag[2];
     size_t bytesread = 0;
 
     if ( matvar == NULL )
         return 1;
     else if ( matvar->rank == 0 )        /* An empty data set */
         return 0;
 #if defined(HAVE_ZLIB)
     else if ( NULL != matvar->internal->data ) {
         /* Data already read in ReadNextStructField or ReadNextCell */
         matvar->data = matvar->internal->data;
         matvar->internal->data = NULL;
         return 0;
     }
 #endif
     fpos = ftell((FILE*)mat->fp);
     if ( fpos == -1L ) {
         Mat_Critical("Couldn't determine file position");
         return 1;
     }
     err = SafeMulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return err;
     }
     byteswap = mat->byteswap;
     switch ( matvar->class_type ) {
         case MAT_C_EMPTY:
             matvar->nbytes = 0;
             matvar->data_size = sizeof(double);
             matvar->data_type = MAT_T_DOUBLE;
             matvar->rank = 2;
             matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*(matvar->dims)));
             matvar->dims[0] = 0;
             matvar->dims[1] = 0;
             break;
         case MAT_C_DOUBLE:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(double);
             matvar->data_type = MAT_T_DOUBLE;
             break;
         case MAT_C_SINGLE:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(float);
             matvar->data_type = MAT_T_SINGLE;
             break;
         case MAT_C_INT64:
 #ifdef HAVE_MAT_INT64_T
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int64_t);
             matvar->data_type = MAT_T_INT64;
 #endif
             break;
         case MAT_C_UINT64:
 #ifdef HAVE_MAT_UINT64_T
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint64_t);
             matvar->data_type = MAT_T_UINT64;
 #endif
             break;
         case MAT_C_INT32:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int32_t);
             matvar->data_type = MAT_T_INT32;
             break;
         case MAT_C_UINT32:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint32_t);
             matvar->data_type = MAT_T_UINT32;
             break;
         case MAT_C_INT16:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int16_t);
             matvar->data_type = MAT_T_INT16;
             break;
         case MAT_C_UINT16:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint16_t);
             matvar->data_type = MAT_T_UINT16;
             break;
         case MAT_C_INT8:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int8_t);
             matvar->data_type = MAT_T_INT8;
             break;
         case MAT_C_UINT8:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint8_t);
             matvar->data_type = MAT_T_UINT8;
             break;
         case MAT_C_CHAR:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
                 matvar->internal->z->avail_in = 0;
                 InflateDataType(mat,matvar->internal->z,tag);
                 if ( byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     nBytes = (tag[0] & 0xffff0000) >> 16;
                 } else {
                     data_in_tag = 0;
                     InflateDataType(mat,matvar->internal->z,tag+1);
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag+1);
                     nBytes = tag[1];
                 }
 #endif
                 matvar->data_type = packed_type;
                 matvar->data_size = Mat_SizeOf(matvar->data_type);
                 matvar->nbytes = nBytes;
             } else {
                 bytesread += fread(tag,4,1,(FILE*)mat->fp);
                 if ( byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     /* nBytes = (tag[0] & 0xffff0000) >> 16; */
                 } else {
                     data_in_tag = 0;
                     bytesread += fread(tag+1,4,1,(FILE*)mat->fp);
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag+1);
                     /* nBytes = tag[1]; */
                 }
                 matvar->data_type = MAT_T_UINT8;
                 matvar->data_size = Mat_SizeOf(MAT_T_UINT8);
                 err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
             }
             if ( matvar->isComplex ) {
                 break;
             }
             matvar->data = calloc(matvar->nbytes+1, 1);
             if ( NULL == matvar->data ) {
                 Mat_Critical("Couldn't allocate memory for the data");
                 err = 1;
                 break;
             }
             if ( 0 == matvar->nbytes ) {
                 break;
             }
             {
                 size_t nbytes;
                 err = SafeMul(&nbytes, nelems, matvar->data_size);
                 if ( err || nbytes > matvar->nbytes ) {
                     break;
                 }
             }
             if ( matvar->compression == MAT_COMPRESSION_NONE ) {
                 nBytes = ReadCharData(mat,(char*)matvar->data,packed_type,(int)nelems);
                 /*
                  * If the data was in the tag we started on a 4-byte
                  * boundary so add 4 to make it an 8-byte
                  */
                 if ( data_in_tag )
                     nBytes+=4;
                 if ( (nBytes % 8) != 0 )
                     (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if defined(HAVE_ZLIB)
             } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
                 nBytes = ReadCompressedCharData(mat,matvar->internal->z,
                              (char*)matvar->data,packed_type,(int)nelems);
                 /*
                  * If the data was in the tag we started on a 4-byte
                  * boundary so add 4 to make it an 8-byte
                  */
                 if ( data_in_tag )
                     nBytes+=4;
                 if ( (nBytes % 8) != 0 )
                     InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
 #endif
             }
             break;
         case MAT_C_STRUCT:
         {
             matvar_t **fields;
             size_t i, nelems_x_nfields;
 
             matvar->data_type = MAT_T_STRUCT;
             err = SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
             if ( err || !matvar->nbytes || !matvar->data_size || NULL == matvar->data )
                 break;
             fields = (matvar_t **)matvar->data;
             for ( i = 0; i < nelems_x_nfields; i++ ) {
                 if ( NULL != fields[i] ) {
                     err |= Mat_VarRead5(mat,fields[i]);
                 }
             }
             break;
         }
         case MAT_C_CELL:
         {
             matvar_t **cells;
             size_t i;
 
             if ( NULL == matvar->data ) {
                 Mat_Critical("Data is NULL for cell array %s",matvar->name);
                 err = 1;
                 break;
             }
             cells = (matvar_t **)matvar->data;
             for ( i = 0; i < nelems; i++ ) {
                 if ( NULL != cells[i] ) {
                     err |= Mat_VarRead5(mat, cells[i]);
                 }
             }
             /* FIXME: */
             matvar->data_type = MAT_T_CELL;
             break;
         }
         case MAT_C_SPARSE:
         {
             mat_int32_t N = 0;
             mat_sparse_t *data;
 
             matvar->data_size = sizeof(mat_sparse_t);
             matvar->data      = malloc(matvar->data_size);
             if ( matvar->data == NULL ) {
                 Mat_Critical("Mat_VarRead5: Allocation of data pointer failed");
                 err = 1;
                 break;
             }
             data = (mat_sparse_t*)matvar->data;
             data->nzmax  = matvar->nbytes;
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             /*  Read ir    */
             bytesread += ReadSparse(mat, matvar, &data->nir, &data->ir);
             /*  Read jc    */
             bytesread += ReadSparse(mat, matvar, &data->njc, &data->jc);
             /*  Read data  */
             if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(HAVE_ZLIB)
                 matvar->internal->z->avail_in = 0;
                 InflateDataType(mat,matvar->internal->z,tag);
                 if ( mat->byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     N = (tag[0] & 0xffff0000) >> 16;
                 } else {
                     data_in_tag = 0;
                     (void)ReadCompressedInt32Data(mat,matvar->internal->z,
                              (mat_int32_t*)&N,MAT_T_INT32,1);
                 }
 #endif
             } else {
                 bytesread += fread(tag,4,1,(FILE*)mat->fp);
                 if ( mat->byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     N = (tag[0] & 0xffff0000) >> 16;
                 } else {
                     data_in_tag = 0;
                     bytesread += fread(&N,4,1,(FILE*)mat->fp);
                     if ( mat->byteswap )
                         (void)Mat_int32Swap(&N);
                 }
             }
             if ( matvar->isLogical && packed_type == MAT_T_DOUBLE ) {
                 /* For some reason, MAT says the data type is a double,
                  * but it appears to be written as 8-bit unsigned integer.
                  */
                 packed_type = MAT_T_UINT8;
             }
 #if defined(EXTENDED_SPARSE)
             matvar->data_type = packed_type;
 #else
             matvar->data_type = MAT_T_DOUBLE;
 #endif
             {
                 size_t s_type = Mat_SizeOf(packed_type);
                 if ( s_type == 0 )
                     break;
                 data->ndata = N / s_type;
             }
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data =
                     ComplexMalloc(data->ndata*Mat_SizeOf(matvar->data_type));
                 if ( NULL == complex_data ) {
                     Mat_Critical("Couldn't allocate memory for the complex sparse data");
                     err = 1;
                     break;
                 }
                 if ( matvar->compression == MAT_COMPRESSION_NONE ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadDoubleData(mat,(double*)complex_data->Re,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadSingleData(mat,(float*)complex_data->Re,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Re,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Re,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Re,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Re,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Re,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Re,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Re,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Re,
                                 packed_type,data->ndata);
                             break;
                         default:
                             break;
                     }
 #else
                     nBytes = ReadDoubleData(mat,(double*)complex_data->Re,
                                  packed_type,data->ndata);
 #endif
+                    nBytes *= Mat_SizeOf(packed_type);
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 
                     /* Complex Data Tag */
                     bytesread += fread(tag,4,1,(FILE*)mat->fp);
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag);
                     packed_type = TYPE_FROM_TAG(tag[0]);
                     if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                         data_in_tag = 1;
                         nBytes = (tag[0] & 0xffff0000) >> 16;
                     } else {
                         data_in_tag = 0;
                         bytesread += fread(tag+1,4,1,(FILE*)mat->fp);
                         if ( byteswap )
                             (void)Mat_uint32Swap(tag+1);
                         nBytes = tag[1];
                     }
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadDoubleData(mat,(double*)complex_data->Im,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadSingleData(mat,(float*)complex_data->Im,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Im,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Im,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Im,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Im,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Im,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Im,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Im,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Im,
                                 packed_type,data->ndata);
                             break;
                         default:
                             break;
                     }
 #else /* EXTENDED_SPARSE */
                     nBytes = ReadDoubleData(mat,(double*)complex_data->Im,
                                 packed_type,data->ndata);
 #endif /* EXTENDED_SPARSE */
+                    nBytes *= Mat_SizeOf(packed_type);
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if defined(HAVE_ZLIB)
                 } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Re,packed_type,data->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadCompressedSingleData(mat,matvar->internal->z,
                                  (float*)complex_data->Re,packed_type,data->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadCompressedInt64Data(mat,
                                 matvar->internal->z,(mat_int64_t*)complex_data->Re,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadCompressedUInt64Data(mat,
                                 matvar->internal->z,(mat_uint64_t*)complex_data->Re,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                                  (mat_int32_t*)complex_data->Re,packed_type,data->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                                  (mat_uint32_t*)complex_data->Re,packed_type,data->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,
                                  (mat_int16_t*)complex_data->Re,packed_type,data->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,
                                  (mat_uint16_t*)complex_data->Re,packed_type,data->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,
                                  (mat_int8_t*)complex_data->Re,packed_type,data->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,
                                  (mat_uint8_t*)complex_data->Re,packed_type,data->ndata);
                             break;
                         default:
                             break;
                     }
 #else    /* EXTENDED_SPARSE */
                     nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Re,packed_type,data->ndata);
 #endif    /* EXTENDED_SPARSE */
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
 
                     /* Complex Data Tag */
                     InflateDataType(mat,matvar->internal->z,tag);
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag);
 
                     packed_type = TYPE_FROM_TAG(tag[0]);
                     if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                         data_in_tag = 1;
                         nBytes = (tag[0] & 0xffff0000) >> 16;
                     } else {
                         data_in_tag = 0;
                         InflateDataType(mat,matvar->internal->z,tag+1);
                         if ( byteswap )
                             (void)Mat_uint32Swap(tag+1);
                         nBytes = tag[1];
                     }
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Im,packed_type,data->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadCompressedSingleData(mat,matvar->internal->z,
                                  (float*)complex_data->Im,packed_type,data->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadCompressedInt64Data(mat,
                                 matvar->internal->z,(mat_int64_t*)complex_data->Im,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadCompressedUInt64Data(mat,
                                 matvar->internal->z,(mat_uint64_t*)complex_data->Im,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                                  (mat_int32_t*)complex_data->Im,packed_type,data->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                                  (mat_uint32_t*)complex_data->Im,packed_type,data->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,
                                  (mat_int16_t*)complex_data->Im,packed_type,data->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,
                                  (mat_uint16_t*)complex_data->Im,packed_type,data->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,
                                  (mat_int8_t*)complex_data->Im,packed_type,data->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,
                                  (mat_uint8_t*)complex_data->Im,packed_type,data->ndata);
                             break;
                         default:
                             break;
                     }
 #else    /* EXTENDED_SPARSE */
                     nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Im,packed_type,data->ndata);
 #endif    /* EXTENDED_SPARSE */
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
 #endif    /* HAVE_ZLIB */
                 }
                 data->data = complex_data;
             } else { /* isComplex */
                 data->data = malloc(data->ndata*Mat_SizeOf(matvar->data_type));
                 if ( data->data == NULL ) {
                     Mat_Critical("Couldn't allocate memory for the sparse data");
                     err = 1;
                     break;
                 }
                 if ( matvar->compression == MAT_COMPRESSION_NONE ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadDoubleData(mat,(double*)data->data,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadSingleData(mat,(float*)data->data,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadInt64Data(mat,(mat_int64_t*)data->data,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadUInt64Data(mat,(mat_uint64_t*)data->data,
                                 packed_type,data->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadInt32Data(mat,(mat_int32_t*)data->data,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadUInt32Data(mat,(mat_uint32_t*)data->data,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadInt16Data(mat,(mat_int16_t*)data->data,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadUInt16Data(mat,(mat_uint16_t*)data->data,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadInt8Data(mat,(mat_int8_t*)data->data,
                                 packed_type,data->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadUInt8Data(mat,(mat_uint8_t*)data->data,
                                 packed_type,data->ndata);
                             break;
                         default:
                             break;
                     }
 #else
                     nBytes = ReadDoubleData(mat,(double*)data->data,packed_type,
                                  data->ndata);
 #endif
+                    nBytes *= Mat_SizeOf(packed_type);
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if defined(HAVE_ZLIB)
                 } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)data->data,packed_type,data->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadCompressedSingleData(mat,matvar->internal->z,
                                  (float*)data->data,packed_type,data->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadCompressedInt64Data(mat,
                                 matvar->internal->z,(mat_int64_t*)data->data,packed_type,
                                 data->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadCompressedUInt64Data(mat,
                                 matvar->internal->z,(mat_uint64_t*)data->data,packed_type,
                                 data->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                                  (mat_int32_t*)data->data,packed_type,data->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                                  (mat_uint32_t*)data->data,packed_type,data->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,
                                  (mat_int16_t*)data->data,packed_type,data->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,
                                  (mat_uint16_t*)data->data,packed_type,data->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,
                                  (mat_int8_t*)data->data,packed_type,data->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,
                                  (mat_uint8_t*)data->data,packed_type,data->ndata);
                             break;
                         default:
                             break;
                     }
 #else   /* EXTENDED_SPARSE */
                     nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)data->data,packed_type,data->ndata);
 #endif   /* EXTENDED_SPARSE */
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
 #endif   /* HAVE_ZLIB */
                 }
             }
             break;
         }
         case MAT_C_FUNCTION:
         {
             matvar_t **functions;
             size_t nfunctions = 0;
 
             if ( !matvar->nbytes || !matvar->data_size )
                 break;
             nfunctions = matvar->nbytes / matvar->data_size;
             functions = (matvar_t **)matvar->data;
             if ( NULL != functions ) {
                 size_t i;
                 for ( i = 0; i < nfunctions; i++ ) {
                     Mat_VarRead5(mat,functions[i]);
                 }
             }
             /* FIXME: */
             matvar->data_type = MAT_T_FUNCTION;
             break;
         }
         default:
             Mat_Critical("Mat_VarRead5: %d is not a supported class", matvar->class_type);
             err = 1;
     }
     switch ( matvar->class_type ) {
         case MAT_C_DOUBLE:
         case MAT_C_SINGLE:
 #ifdef HAVE_MAT_INT64_T
         case MAT_C_INT64:
 #endif
 #ifdef HAVE_MAT_UINT64_T
         case MAT_C_UINT64:
 #endif
         case MAT_C_INT32:
         case MAT_C_UINT32:
         case MAT_C_INT16:
         case MAT_C_UINT16:
         case MAT_C_INT8:
         case MAT_C_UINT8:
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data;
 
                 err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
 
                 complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
                     Mat_Critical("Couldn't allocate memory for the complex data");
                     err = 1;
                     break;
                 }
 
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,nelems);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,nelems);
                 matvar->data = complex_data;
             } else {
                 err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
 
                 matvar->data = malloc(matvar->nbytes);
                 if ( NULL == matvar->data ) {
                     Mat_Critical("Couldn't allocate memory for the data");
                     err = 1;
                     break;
                 }
                 Mat_VarReadNumeric5(mat,matvar,matvar->data,nelems);
             }
         default:
             break;
     }
     (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);
 
     return err;
 }
 
 #if defined(HAVE_ZLIB)
 #define GET_DATA_SLABN_RANK_LOOP \
     do { \
         for ( j = 1; j < rank; j++ ) { \
             cnt[j]++; \
             if ( (cnt[j] % edge[j]) == 0 ) { \
                 cnt[j] = 0; \
                 if ( (I % dimp[j]) != 0 ) { \
                     ptr_in += dimp[j]-(I % dimp[j])+dimp[j-1]*start[j]; \
                     I += dimp[j]-(I % dimp[j]) + dimp[j-1]*start[j]; \
                 } else if ( start[j] ) { \
                     ptr_in += dimp[j-1]*start[j]; \
                     I += dimp[j-1]*start[j]; \
                 } \
             } else { \
                 I += inc[j]; \
                 ptr_in += inc[j]; \
                 break; \
             } \
         } \
     } while (0)
 
 #define GET_DATA_SLAB2(T) \
     do { \
         ptr_in += start[1]*dims[0] + start[0]; \
         for ( i = 0; i < edge[1]; i++ ) { \
             for ( j = 0; j < edge[0]; j++ ) { \
                 *ptr = (T)(*(ptr_in+j*stride[0])); \
                 ptr++; \
             } \
             ptr_in += stride[1]*dims[0]; \
         } \
     } while (0)
 
 #define GET_DATA_SLABN(T) \
     do { \
         inc[0]  = stride[0]-1; \
         dimp[0] = dims[0]; \
         N       = edge[0]; \
         I       = 0; /* start[0]; */ \
         for ( i = 1; i < rank; i++ ) { \
             inc[i]  = stride[i]-1; \
             dimp[i] = dims[i-1]; \
             for ( j = i; j--; ) { \
                 inc[i]  *= dims[j]; \
                 dimp[i] *= dims[j+1]; \
             } \
             N *= edge[i]; \
             I += dimp[i-1]*start[i]; \
         } \
         ptr_in += I; \
         if ( stride[0] == 1 ) { \
             for ( i = 0; i < N; i+=edge[0] ) { \
                 int k; \
                 if ( start[0] ) { \
                     ptr_in += start[0]; \
                     I += start[0]; \
                 } \
                 for ( k = 0; k < edge[0]; k++ ) { \
                     *(ptr+i+k) = (T)(*(ptr_in+k)); \
                 } \
                 I += dims[0]-start[0]; \
                 ptr_in += dims[0]-start[0]; \
                 GET_DATA_SLABN_RANK_LOOP; \
             } \
         } else { \
             for ( i = 0; i < N; i+=edge[0] ) { \
                 if ( start[0] ) { \
                     ptr_in += start[0]; \
                     I += start[0]; \
                 } \
                 for ( j = 0; j < edge[0]; j++ ) { \
                     *(ptr+i+j) = (T)(*ptr_in); \
                     ptr_in += stride[0]; \
                     I += stride[0]; \
                 } \
                 I += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \
                 ptr_in += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \
                 GET_DATA_SLABN_RANK_LOOP; \
             } \
         } \
     } while (0)
 
 #ifdef HAVE_MAT_INT64_T
 #define GET_DATA_SLAB2_INT64(T) \
     do { \
         if ( MAT_T_INT64 == data_type ) { \
             mat_int64_t *ptr_in = (mat_int64_t *)data_in; \
             GET_DATA_SLAB2(T); \
             err = 0; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLAB2_INT64(T)
 #endif /* HAVE_MAT_INT64_T */
 
 #ifdef HAVE_MAT_UINT64_T
 #define GET_DATA_SLAB2_UINT64(T) \
     do { \
         if ( MAT_T_UINT64 == data_type ) { \
             mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \
             GET_DATA_SLAB2(T); \
             err = 0; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLAB2_UINT64(T)
 #endif /* HAVE_MAT_UINT64_T */
 
 #define GET_DATA_SLAB2_TYPE(T) \
     do { \
         switch ( data_type ) { \
             case MAT_T_DOUBLE: \
             { \
                 double *ptr_in = (double *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_SINGLE: \
             { \
                 float *ptr_in = (float *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_INT32: \
             { \
                 mat_int32_t *ptr_in = (mat_int32_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_UINT32: \
             { \
                 mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_INT16: \
             { \
                 mat_int16_t *ptr_in = (mat_int16_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_UINT16: \
             { \
                 mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_INT8: \
             { \
                 mat_int8_t *ptr_in = (mat_int8_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_UINT8: \
             { \
                 mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             default: \
                 err = 1; \
                 GET_DATA_SLAB2_INT64(T); \
                 GET_DATA_SLAB2_UINT64(T); \
                 break; \
         } \
     } while (0)
 
 #ifdef HAVE_MAT_INT64_T
 #define GET_DATA_SLABN_INT64(T) \
     do { \
         if ( MAT_T_INT64 == data_type ) { \
             mat_int64_t *ptr_in = (mat_int64_t *)data_in; \
             GET_DATA_SLABN(T); \
             err = 0; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLABN_INT64(T)
 #endif /* HAVE_MAT_INT64_T */
 
 #ifdef HAVE_MAT_UINT64_T
 #define GET_DATA_SLABN_UINT64(T) \
     do { \
         if ( MAT_T_UINT64 == data_type ) { \
             mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \
             GET_DATA_SLABN(T); \
             err = 0; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLABN_UINT64(T)
 #endif /* HAVE_MAT_UINT64_T */
 
 #define GET_DATA_SLABN_TYPE(T) \
     do { \
         switch ( data_type ) { \
             case MAT_T_DOUBLE: \
             { \
                 double *ptr_in = (double *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_SINGLE: \
             { \
                 float *ptr_in = (float *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_INT32: \
             { \
                 mat_int32_t *ptr_in = (mat_int32_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_UINT32: \
             { \
                 mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_INT16: \
             { \
                 mat_int16_t *ptr_in = (mat_int16_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_UINT16: \
             { \
                 mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_INT8: \
             { \
                 mat_int8_t *ptr_in = (mat_int8_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_UINT8: \
             { \
                 mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             default: \
                 err = 1; \
                 GET_DATA_SLABN_INT64(T); \
                 GET_DATA_SLABN_UINT64(T); \
                 break; \
         } \
     } while (0)
diff --git a/src/read_data.c b/src/read_data.c
index ffb9340..80514cd 100644
--- a/src/read_data.c
+++ b/src/read_data.c
@@ -1,293 +1,293 @@
 /** @file read_data.c
  * Matlab MAT version 5 file functions
  * @ingroup MAT
  */
 /*
  * Copyright (c) 2005-2019, Christopher C. Hulbert
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 /* FIXME: Implement Unicode support */
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
 #include <math.h>
 #include <time.h>
 #include "matio_private.h"
 #if defined(HAVE_ZLIB)
 #   include <zlib.h>
 #endif
 
 #define READ_DATA_NOSWAP(T) \
     do { \
         const size_t block_size = READ_BLOCK_SIZE/data_size; \
         if ( len <= block_size ) { \
-            bytesread += fread(v, data_size, len, (FILE*)mat->fp); \
+            readcount += fread(v, data_size, len, (FILE*)mat->fp); \
             for ( i = 0; i < len; i++ ) { \
                 data[i] = (T)v[i]; \
             } \
         } else { \
             size_t j; \
             for ( i = 0; i < len - block_size; i += block_size ) { \
-                bytesread += fread(v, data_size, block_size, (FILE*)mat->fp); \
+                readcount += fread(v, data_size, block_size, (FILE*)mat->fp); \
                 for ( j = 0; j < block_size; j++ ) { \
                     data[i + j] = (T)v[j]; \
                 } \
             } \
             if ( len > i ) { \
-                bytesread += fread(v, data_size, len - i, (FILE*)mat->fp); \
+                readcount += fread(v, data_size, len - i, (FILE*)mat->fp); \
                 for ( j = 0; j < len - i; j++ ) { \
                     data[i + j] = (T)v[j]; \
                 } \
             } \
         } \
     } while (0)
 
 #define READ_DATA(T, SwapFunc) \
     do { \
         if ( mat->byteswap ) { \
             const size_t block_size = READ_BLOCK_SIZE/data_size; \
             if ( len <= block_size ) { \
-                bytesread += fread(v, data_size, len, (FILE*)mat->fp); \
+                readcount += fread(v, data_size, len, (FILE*)mat->fp); \
                 for ( i = 0; i < len; i++ ) { \
                     data[i] = (T)SwapFunc(&v[i]); \
                 } \
             } else { \
                 size_t j; \
                 for ( i = 0; i < len - block_size; i += block_size ) { \
-                    bytesread += fread(v, data_size, block_size, (FILE*)mat->fp); \
+                    readcount += fread(v, data_size, block_size, (FILE*)mat->fp); \
                     for ( j = 0; j < block_size; j++ ) { \
                         data[i + j] = (T)SwapFunc(&v[j]); \
                     } \
                 } \
                 if ( len > i ) { \
-                    bytesread += fread(v, data_size, len - i, (FILE*)mat->fp); \
+                    readcount += fread(v, data_size, len - i, (FILE*)mat->fp); \
                     for ( j = 0; j < len-i; j++ ) { \
                         data[i + j] = (T)SwapFunc(&v[j]); \
                     } \
                 } \
             } \
         } else { \
             READ_DATA_NOSWAP(T); \
         } \
     } while (0)
 
 #if defined(HAVE_ZLIB)
 #define READ_COMPRESSED_DATA_NOSWAP(T) \
     do { \
         const size_t block_size = READ_BLOCK_SIZE/data_size; \
         if ( len <= block_size ) { \
             InflateData(mat, z, v, len*data_size); \
             for ( i = 0; i < len; i++ ) { \
                 data[i] = (T)v[i]; \
             } \
         } else { \
             mat_uint32_t j; \
             len -= block_size; \
             for ( i = 0; i < len; i += block_size ) { \
                 InflateData(mat, z, v, block_size*data_size); \
                 for ( j = 0; j < block_size; j++ ) { \
                     data[i + j] = (T)v[j]; \
                 } \
             } \
             len -= (i - block_size); \
             InflateData(mat, z, v, len*data_size); \
             for ( j = 0; j < len; j++ ) { \
                 data[i + j] = (T)v[j]; \
             } \
         } \
     } while (0)
 
 #define READ_COMPRESSED_DATA(T, SwapFunc) \
     do { \
         if ( mat->byteswap ) { \
             const size_t block_size = READ_BLOCK_SIZE/data_size; \
             if ( len <= block_size ) { \
                 InflateData(mat, z, v, len*data_size); \
                 for ( i = 0; i < len; i++ ) { \
                     data[i] = (T)SwapFunc(&v[i]); \
                 } \
             } else { \
                 mat_uint32_t j; \
                 len -= block_size; \
                 for ( i = 0; i < len; i += block_size ) { \
                     InflateData(mat, z, v, block_size*data_size); \
                     for ( j = 0; j < block_size; j++ ) { \
                         data[i + j] = (T)SwapFunc(&v[j]); \
                     } \
                 } \
                 len -= (i - block_size); \
                 InflateData(mat, z, v, len*data_size); \
                 for ( j = 0; j < len; j++ ) { \
                     data[i + j] = (T)SwapFunc(&v[j]); \
                 } \
             } \
         } else { \
             READ_COMPRESSED_DATA_NOSWAP(T); \
         } \
     } while (0)
 
 #endif
 
 /*
  * --------------------------------------------------------------------------
  *    Routines to read data of any type into arrays of a specific type
  * --------------------------------------------------------------------------
  */
 
 /** @cond mat_devman */
 
 #define READ_TYPE_DOUBLE 1
 #define READ_TYPE_SINGLE 2
 #define READ_TYPE_INT64  3
 #define READ_TYPE_UINT64 4
 #define READ_TYPE_INT32  5
 #define READ_TYPE_UINT32 6
 #define READ_TYPE_INT16  7
 #define READ_TYPE_UINT16 8
 #define READ_TYPE_INT8   9
 #define READ_TYPE_UINT8 10
 
 #define READ_TYPE double
 #define READ_TYPE_TYPE READ_TYPE_DOUBLE
 #define READ_TYPED_FUNC1 ReadDoubleData
 #define READ_TYPED_FUNC2 ReadCompressedDoubleData
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 
 #define READ_TYPE float
 #define READ_TYPE_TYPE READ_TYPE_SINGLE
 #define READ_TYPED_FUNC1 ReadSingleData
 #define READ_TYPED_FUNC2 ReadCompressedSingleData
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 
 #ifdef HAVE_MAT_INT64_T
 #define READ_TYPE mat_int64_t
 #define READ_TYPE_TYPE READ_TYPE_INT64
 #define READ_TYPED_FUNC1 ReadInt64Data
 #define READ_TYPED_FUNC2 ReadCompressedInt64Data
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 #endif /* HAVE_MAT_INT64_T */
 
 #ifdef HAVE_MAT_UINT64_T
 #define READ_TYPE mat_uint64_t
 #define READ_TYPE_TYPE READ_TYPE_UINT64
 #define READ_TYPED_FUNC1 ReadUInt64Data
 #define READ_TYPED_FUNC2 ReadCompressedUInt64Data
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 #endif /* HAVE_MAT_UINT64_T */
 
 #define READ_TYPE mat_int32_t
 #define READ_TYPE_TYPE READ_TYPE_INT32
 #define READ_TYPED_FUNC1 ReadInt32Data
 #define READ_TYPED_FUNC2 ReadCompressedInt32Data
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 
 #define READ_TYPE mat_uint32_t
 #define READ_TYPE_TYPE READ_TYPE_UINT32
 #define READ_TYPED_FUNC1 ReadUInt32Data
 #define READ_TYPED_FUNC2 ReadCompressedUInt32Data
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 
 #define READ_TYPE mat_int16_t
 #define READ_TYPE_TYPE READ_TYPE_INT16
 #define READ_TYPED_FUNC1 ReadInt16Data
 #define READ_TYPED_FUNC2 ReadCompressedInt16Data
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 
 #define READ_TYPE mat_uint16_t
 #define READ_TYPE_TYPE READ_TYPE_UINT16
 #define READ_TYPED_FUNC1 ReadUInt16Data
 #define READ_TYPED_FUNC2 ReadCompressedUInt16Data
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 
 #define READ_TYPE mat_int8_t
 #define READ_TYPE_TYPE READ_TYPE_INT8
 #define READ_TYPED_FUNC1 ReadInt8Data
 #define READ_TYPED_FUNC2 ReadCompressedInt8Data
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 
 #define READ_TYPE mat_uint8_t
 #define READ_TYPE_TYPE READ_TYPE_UINT8
 #define READ_TYPED_FUNC1 ReadUInt8Data
 #define READ_TYPED_FUNC2 ReadCompressedUInt8Data
 #include "read_data_impl.h"
 #undef READ_TYPE
 #undef READ_TYPE_TYPE
 #undef READ_TYPED_FUNC1
 #undef READ_TYPED_FUNC2
 
 #undef READ_DATA
 #undef READ_DATA_NOSWAP
 
 #if defined(HAVE_ZLIB)
 /** @brief Reads data of type @c data_type into a char type
  *
  * Reads from the MAT file @c len compressed elements of data type @c data_type
  * storing them as char's in @c data.
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param z Pointer to the zlib stream for inflation
  * @param data Pointer to store the output char values (len*sizeof(char))
  * @param data_type one of the @c matio_types enumerations which is the source
  *                  data type in the file
  * @param len Number of elements of type @c data_type to read from the file
  * @retval Number of bytes read from the file
  */
diff --git a/src/read_data_impl.h b/src/read_data_impl.h
index 6982382..5543b5a 100644
--- a/src/read_data_impl.h
+++ b/src/read_data_impl.h
@@ -42,296 +42,296 @@
 static size_t
 READ_TYPE_DOUBLE_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_DOUBLE
-    bytesread += fread(data, sizeof(double), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(double), len, (FILE*)mat->fp);
     if ( mat->byteswap ) {
         size_t i;
         for ( i = 0; i < len; i++ ) {
             (void)Mat_doubleSwap(data + i);
         }
     }
 #else
     size_t i;
     const size_t data_size = sizeof(double);
     double v[READ_BLOCK_SIZE/sizeof(double)];
     READ_DATA(READ_TYPE, Mat_doubleSwap);
 #endif
-    return bytesread;
+    return readcount;
 }
 
 static size_t
 READ_TYPE_SINGLE_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_SINGLE
-    bytesread += fread(data, sizeof(float), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(float), len, (FILE*)mat->fp);
     if ( mat->byteswap ) {
         size_t i;
         for ( i = 0; i < len; i++ ) {
             (void)Mat_floatSwap(data + i);
         }
     }
 #else
     size_t i;
     const size_t data_size = sizeof(float);
     float v[READ_BLOCK_SIZE/sizeof(float)];
     READ_DATA(READ_TYPE, Mat_floatSwap);
 #endif
-    return bytesread;
+    return readcount;
 }
 
 static size_t
 READ_TYPE_INT32_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_INT32
-    bytesread += fread(data, sizeof(mat_int32_t), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(mat_int32_t), len, (FILE*)mat->fp);
     if ( mat->byteswap ) {
         size_t i;
         for ( i = 0; i < len; i++ ) {
             (void)Mat_int32Swap(data + i);
         }
     }
 #else
     size_t i;
     const size_t data_size = sizeof(mat_int32_t);
     mat_int32_t v[READ_BLOCK_SIZE/sizeof(mat_int32_t)];
     READ_DATA(READ_TYPE, Mat_int32Swap);
 #endif
-    return bytesread;
+    return readcount;
 }
 
 static size_t
 READ_TYPE_UINT32_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_UINT32
-    bytesread += fread(data, sizeof(mat_uint32_t), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(mat_uint32_t), len, (FILE*)mat->fp);
     if ( mat->byteswap ) {
         size_t i;
         for ( i = 0; i < len; i++ ) {
             (void)Mat_uint32Swap(data + i);
         }
     }
 #else
     size_t i;
     const size_t data_size = sizeof(mat_uint32_t);
     mat_uint32_t v[READ_BLOCK_SIZE/sizeof(mat_uint32_t)];
     READ_DATA(READ_TYPE, Mat_uint32Swap);
 #endif
-    return bytesread;
+    return readcount;
 }
 
 static size_t
 READ_TYPE_INT16_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_INT16
-    bytesread += fread(data, sizeof(mat_int16_t), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(mat_int16_t), len, (FILE*)mat->fp);
     if ( mat->byteswap ) {
         size_t i;
         for ( i = 0; i < len; i++ ) {
             (void)Mat_int16Swap(data + i);
         }
     }
 #else
     size_t i;
     const size_t data_size = sizeof(mat_int16_t);
     mat_int16_t v[READ_BLOCK_SIZE/sizeof(mat_int16_t)];
     READ_DATA(READ_TYPE, Mat_int16Swap);
 #endif
-    return bytesread;
+    return readcount;
 }
 
 static size_t
 READ_TYPE_UINT16_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_UINT16
-    bytesread += fread(data, sizeof(mat_uint16_t), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(mat_uint16_t), len, (FILE*)mat->fp);
     if ( mat->byteswap ) {
         size_t i;
         for ( i = 0; i < len; i++ ) {
             (void)Mat_uint16Swap(data + i);
         }
     }
 #else
     size_t i;
     const size_t data_size = sizeof(mat_uint16_t);
     mat_uint16_t v[READ_BLOCK_SIZE/sizeof(mat_uint16_t)];
     READ_DATA(READ_TYPE, Mat_uint16Swap);
 #endif
-    return bytesread;
+    return readcount;
 }
 
 static size_t
 READ_TYPE_INT8_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_INT8
-    bytesread += fread(data, sizeof(mat_int8_t), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(mat_int8_t), len, (FILE*)mat->fp);
 #else
     size_t i;
     const size_t data_size = sizeof(mat_int8_t);
     mat_int8_t v[READ_BLOCK_SIZE/sizeof(mat_int8_t)];
     READ_DATA_NOSWAP(READ_TYPE);
 #endif
-    return bytesread;
+    return readcount;
 }
 
 static size_t
 READ_TYPE_UINT8_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_UINT8
-    bytesread += fread(data, sizeof(mat_uint8_t), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(mat_uint8_t), len, (FILE*)mat->fp);
 #else
     size_t i;
     const size_t data_size = sizeof(mat_uint8_t);
     mat_uint8_t v[READ_BLOCK_SIZE/sizeof(mat_uint8_t)];
     READ_DATA_NOSWAP(READ_TYPE);
 #endif
-    return bytesread;
+    return readcount;
 }
 
 #ifdef HAVE_MAT_INT64_T
 static size_t
 READ_TYPE_INT64_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_INT64
-    bytesread += fread(data, sizeof(mat_int64_t), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(mat_int64_t), len, (FILE*)mat->fp);
     if ( mat->byteswap ) {
         size_t i;
         for ( i = 0; i < len; i++ ) {
             (void)Mat_int64Swap(data + i);
         }
     }
 #else
     size_t i;
     const size_t data_size = sizeof(mat_int64_t);
     mat_int64_t v[READ_BLOCK_SIZE/sizeof(mat_int64_t)];
     READ_DATA(READ_TYPE, Mat_int64Swap);
 #endif
-    return bytesread;
+    return readcount;
 }
 #endif /* HAVE_MAT_INT64_T */
 
 #ifdef HAVE_MAT_UINT64_T
 static size_t
 READ_TYPE_UINT64_DATA(mat_t *mat, READ_TYPE *data, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount = 0;
 #if READ_TYPE_TYPE == READ_TYPE_UINT64
-    bytesread += fread(data, sizeof(mat_uint64_t), len, (FILE*)mat->fp);
+    readcount += fread(data, sizeof(mat_uint64_t), len, (FILE*)mat->fp);
     if ( mat->byteswap ) {
         size_t i;
         for ( i = 0; i < len; i++ ) {
             (void)Mat_uint64Swap(data + i);
         }
     }
 #else
     size_t i;
     const size_t data_size = sizeof(mat_uint64_t);
     mat_uint64_t v[READ_BLOCK_SIZE/sizeof(mat_uint64_t)];
     READ_DATA(READ_TYPE, Mat_uint64Swap);
 #endif
-    return bytesread;
+    return readcount;
 }
 #endif /* HAVE_MAT_UINT64_T */
 
 
 /** @brief Reads data of type @c data_type into a READ_TYPE type
  *
  * Reads from the MAT file @c len elements of data type @c data_type storing
  * them as READ_TYPE's in @c data.
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param data Pointer to store the output values (len*sizeof(READ_TYPE))
  * @param data_type one of the @c matio_types enumerations which is the source
  *                  data type in the file
  * @param len Number of elements of type @c data_type to read from the file
- * @retval Number of bytes read from the file
+ * @retval Number of elements read from the file
  */
 int
 READ_TYPED_FUNC1(mat_t *mat, READ_TYPE *data, enum matio_types data_type, size_t len)
 {
-    size_t bytesread = 0;
+    size_t readcount;
 
     if ( mat == NULL || data == NULL || mat->fp == NULL )
         return 0;
 
     switch ( data_type ) {
         case MAT_T_DOUBLE:
-            bytesread = READ_TYPE_DOUBLE_DATA(mat, data, len);
+            readcount = READ_TYPE_DOUBLE_DATA(mat, data, len);
             break;
         case MAT_T_SINGLE:
-            bytesread = READ_TYPE_SINGLE_DATA(mat, data, len);
+            readcount = READ_TYPE_SINGLE_DATA(mat, data, len);
             break;
 #ifdef HAVE_MAT_INT64_T
         case MAT_T_INT64:
-            bytesread = READ_TYPE_INT64_DATA(mat, data, len);
+            readcount = READ_TYPE_INT64_DATA(mat, data, len);
             break;
 #endif /* HAVE_MAT_UINT64_T */
 #ifdef HAVE_MAT_UINT64_T
         case MAT_T_UINT64:
-            bytesread = READ_TYPE_UINT64_DATA(mat, data, len);
+            readcount = READ_TYPE_UINT64_DATA(mat, data, len);
             break;
 #endif /* HAVE_MAT_UINT64_T */
         case MAT_T_INT32:
-            bytesread = READ_TYPE_INT32_DATA(mat, data, len);
+            readcount = READ_TYPE_INT32_DATA(mat, data, len);
             break;
         case MAT_T_UINT32:
-            bytesread = READ_TYPE_UINT32_DATA(mat, data, len);
+            readcount = READ_TYPE_UINT32_DATA(mat, data, len);
             break;
         case MAT_T_INT16:
-            bytesread = READ_TYPE_INT16_DATA(mat, data, len);
+            readcount = READ_TYPE_INT16_DATA(mat, data, len);
             break;
         case MAT_T_UINT16:
-            bytesread = READ_TYPE_UINT16_DATA(mat, data, len);
+            readcount = READ_TYPE_UINT16_DATA(mat, data, len);
             break;
         case MAT_T_INT8:
-            bytesread = READ_TYPE_INT8_DATA(mat, data, len);
+            readcount = READ_TYPE_INT8_DATA(mat, data, len);
             break;
         case MAT_T_UINT8:
-            bytesread = READ_TYPE_UINT8_DATA(mat, data, len);
+            readcount = READ_TYPE_UINT8_DATA(mat, data, len);
             break;
         default:
+            readcount = 0;
             break;
     }
-    bytesread *= Mat_SizeOf(data_type);
-    return bytesread;
+    return readcount;
 }
 
 #undef READ_TYPE_DOUBLE_DATA
 #undef READ_TYPE_SINGLE_DATA
 #undef READ_TYPE_INT32_DATA
 #undef READ_TYPE_UINT32_DATA
 #undef READ_TYPE_INT16_DATA
 #undef READ_TYPE_UINT16_DATA
 #undef READ_TYPE_INT8_DATA
 #undef READ_TYPE_UINT8_DATA
 #ifdef HAVE_MAT_INT64_T
 #undef READ_TYPE_INT64_DATA
 #endif /* HAVE_MAT_INT64_T */
 #ifdef HAVE_MAT_UINT64_T
 #undef READ_TYPE_UINT64_DATA
 #endif /* HAVE_MAT_UINT64_T */
 
 #if defined(HAVE_ZLIB)
 
 #define READ_TYPE_DOUBLE_DATA CAT(READ_TYPED_FUNC2, Double)
 #define READ_TYPE_SINGLE_DATA CAT(READ_TYPED_FUNC2, Single)
 #define READ_TYPE_INT32_DATA CAT(READ_TYPED_FUNC2, Int32)
 #define READ_TYPE_UINT32_DATA CAT(READ_TYPED_FUNC2, UInt32)
 #define READ_TYPE_INT16_DATA CAT(READ_TYPED_FUNC2, Int16)
 #define READ_TYPE_UINT16_DATA CAT(READ_TYPED_FUNC2, UInt16)
 #define READ_TYPE_INT8_DATA CAT(READ_TYPED_FUNC2, Int8)
 #define READ_TYPE_UINT8_DATA CAT(READ_TYPED_FUNC2, UInt8)
 #ifdef HAVE_MAT_INT64_T
 #define READ_TYPE_INT64_DATA CAT(READ_TYPED_FUNC2, Int64)
 #endif /* HAVE_MAT_INT64_T */
 #ifdef HAVE_MAT_UINT64_T
 #define READ_TYPE_UINT64_DATA CAT(READ_TYPED_FUNC2, UInt64)
 #endif /* HAVE_MAT_UINT64_T */
