commit 08538b69f35bbc459f2ed8d36f0fb06965262d62
Merge: 66532ed05 134d4cca6
Author: David Garske <david@wolfssl.com>
Date:   Mon Jan 30 15:56:46 2023 -0800

    Merge pull request #6016 from SparkiDev/sp_dh_agree_uinit
    
    DH and SP: sp_DhExp_* called with uninitialized outLen

diff --git a/wolfcrypt/src/dh.c b/wolfcrypt/src/dh.c
index 26f1b4ebb..ef65ed15f 100644
--- a/wolfcrypt/src/dh.c
+++ b/wolfcrypt/src/dh.c
@@ -1289,80 +1289,76 @@ static int GeneratePrivateDh(DhKey* key, WC_RNG* rng, byte* priv,
 static int GeneratePublicDh(DhKey* key, byte* priv, word32 privSz,
     byte* pub, word32* pubSz)
 {
     int ret = 0;
 #ifndef WOLFSSL_SP_MATH
-    word32 binSz = 0;
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
     mp_int* x;
     mp_int* y;
 #else
     mp_int x[1];
     mp_int y[1];
 #endif
 #endif
 
+    if (*pubSz < (word32)mp_unsigned_bin_size(&key->p)) {
+        return WC_KEY_SIZE_E;
+    }
+
 #ifdef WOLFSSL_HAVE_SP_DH
 #ifndef WOLFSSL_SP_NO_2048
     if (mp_count_bits(&key->p) == 2048)
         return sp_DhExp_2048(&key->g, priv, privSz, &key->p, pub, pubSz);
 #endif
 #ifndef WOLFSSL_SP_NO_3072
     if (mp_count_bits(&key->p) == 3072)
         return sp_DhExp_3072(&key->g, priv, privSz, &key->p, pub, pubSz);
 #endif
 #ifdef WOLFSSL_SP_4096
     if (mp_count_bits(&key->p) == 4096)
         return sp_DhExp_4096(&key->g, priv, privSz, &key->p, pub, pubSz);
 #endif
 #endif
 
 #if !defined(WOLFSSL_SP_MATH)
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
     x = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_DH);
     if (x == NULL)
         return MEMORY_E;
     y = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_DH);
     if (y == NULL) {
         XFREE(x, key->heap, DYNAMIC_TYPE_DH);
         return MEMORY_E;
     }
 #endif
     if (mp_init_multi(x, y, 0, 0, 0, 0) != MP_OKAY) {
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
         XFREE(y, key->heap, DYNAMIC_TYPE_DH);
         XFREE(x, key->heap, DYNAMIC_TYPE_DH);
     #endif
         return MP_INIT_E;
     }
 
     if (mp_read_unsigned_bin(x, priv, privSz) != MP_OKAY)
         ret = MP_READ_E;
 
     if (ret == 0 && mp_exptmod(&key->g, x, &key->p, y) != MP_OKAY)
         ret = MP_EXPTMOD_E;
 
-    if (ret == 0) {
-        binSz = mp_unsigned_bin_size(y);
-        if (binSz > *pubSz) {
-            ret = WC_KEY_SIZE_E;
-        }
-    }
-
     if (ret == 0 && mp_to_unsigned_bin(y, pub) != MP_OKAY)
         ret = MP_TO_E;
 
     if (ret == 0)
-        *pubSz = binSz;
+        *pubSz = mp_unsigned_bin_size(y);
 
     mp_clear(y);
     mp_clear(x);
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_NO_MALLOC)
     XFREE(y, key->heap, DYNAMIC_TYPE_DH);
     XFREE(x, key->heap, DYNAMIC_TYPE_DH);
 #endif
 #else
     ret = WC_KEY_SIZE_E;
 #endif
 
     return ret;
 }
diff --git a/wolfcrypt/src/sp_arm32.c b/wolfcrypt/src/sp_arm32.c
index b87095055..93b1144f6 100644
--- a/wolfcrypt/src/sp_arm32.c
+++ b/wolfcrypt/src/sp_arm32.c
@@ -17672,78 +17672,75 @@ static int sp_2048_mod_exp_2_64(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 256 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_2048(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[128];
     sp_digit e[64];
     sp_digit m[64];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 2048) {
         err = MP_READ_E;
     }
     else if (expLen > 256) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 2048) {
         err = MP_READ_E;
     }
-    else if (*outLen < 256U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_2048_from_mp(b, 64, base);
         sp_2048_from_bin(e, 64, exp, expLen);
         sp_2048_from_mp(m, 64, mod);
 
     #ifdef HAVE_FFDHE_2048
         if (base->used == 1 && base->dp[0] == 2 && m[63] == (sp_digit)-1)
             err = sp_2048_mod_exp_2_64(r, e, expLen * 8, m);
         else
     #endif
             err = sp_2048_mod_exp_64(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_2048_to_bin_64(r, out);
         *outLen = 256;
         for (i=0; i<256 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -44872,78 +44869,75 @@ static int sp_3072_mod_exp_2_96(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 384 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[192];
     sp_digit e[96];
     sp_digit m[96];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 3072) {
         err = MP_READ_E;
     }
     else if (expLen > 384) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 3072) {
         err = MP_READ_E;
     }
-    else if (*outLen < 384U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_3072_from_mp(b, 96, base);
         sp_3072_from_bin(e, 96, exp, expLen);
         sp_3072_from_mp(m, 96, mod);
 
     #ifdef HAVE_FFDHE_3072
         if (base->used == 1 && base->dp[0] == 2 && m[95] == (sp_digit)-1)
             err = sp_3072_mod_exp_2_96(r, e, expLen * 8, m);
         else
     #endif
             err = sp_3072_mod_exp_96(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_3072_to_bin_96(r, out);
         *outLen = 384;
         for (i=0; i<384 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -60447,78 +60441,75 @@ static int sp_4096_mod_exp_2_128(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 512 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[256];
     sp_digit e[128];
     sp_digit m[128];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 4096) {
         err = MP_READ_E;
     }
     else if (expLen > 512) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 4096) {
         err = MP_READ_E;
     }
-    else if (*outLen < 512U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_4096_from_mp(b, 128, base);
         sp_4096_from_bin(e, 128, exp, expLen);
         sp_4096_from_mp(m, 128, mod);
 
     #ifdef HAVE_FFDHE_4096
         if (base->used == 1 && base->dp[0] == 2 && m[127] == (sp_digit)-1)
             err = sp_4096_mod_exp_2_128(r, e, expLen * 8, m);
         else
     #endif
             err = sp_4096_mod_exp_128(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_4096_to_bin_128(r, out);
         *outLen = 512;
         for (i=0; i<512 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 #endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */
 
 #endif /* WOLFSSL_SP_4096 */
 
 #endif /* WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH */
 #ifdef WOLFSSL_HAVE_SP_ECC
 #ifndef WOLFSSL_SP_NO_256
 
 /* Point structure to use. */
diff --git a/wolfcrypt/src/sp_arm64.c b/wolfcrypt/src/sp_arm64.c
index 2a38fcd71..ceed0be07 100644
--- a/wolfcrypt/src/sp_arm64.c
+++ b/wolfcrypt/src/sp_arm64.c
@@ -6838,78 +6838,75 @@ static int sp_2048_mod_exp_2_32(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 256 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_2048(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[64];
     sp_digit e[32];
     sp_digit m[32];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 2048) {
         err = MP_READ_E;
     }
     else if (expLen > 256) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 2048) {
         err = MP_READ_E;
     }
-    else if (*outLen < 256U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_2048_from_mp(b, 32, base);
         sp_2048_from_bin(e, 32, exp, expLen);
         sp_2048_from_mp(m, 32, mod);
 
     #ifdef HAVE_FFDHE_2048
         if (base->used == 1 && base->dp[0] == 2 && m[31] == (sp_digit)-1)
             err = sp_2048_mod_exp_2_32(r, e, expLen * 8, m);
         else
     #endif
             err = sp_2048_mod_exp_32(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_2048_to_bin_32(r, out);
         *outLen = 256;
         for (i=0; i<256 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -16444,78 +16441,75 @@ static int sp_3072_mod_exp_2_48(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 384 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[96];
     sp_digit e[48];
     sp_digit m[48];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 3072) {
         err = MP_READ_E;
     }
     else if (expLen > 384) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 3072) {
         err = MP_READ_E;
     }
-    else if (*outLen < 384U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_3072_from_mp(b, 48, base);
         sp_3072_from_bin(e, 48, exp, expLen);
         sp_3072_from_mp(m, 48, mod);
 
     #ifdef HAVE_FFDHE_3072
         if (base->used == 1 && base->dp[0] == 2 && m[47] == (sp_digit)-1)
             err = sp_3072_mod_exp_2_48(r, e, expLen * 8, m);
         else
     #endif
             err = sp_3072_mod_exp_48(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_3072_to_bin_48(r, out);
         *outLen = 384;
         for (i=0; i<384 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -21654,78 +21648,75 @@ static int sp_4096_mod_exp_2_64(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 512 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[128];
     sp_digit e[64];
     sp_digit m[64];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 4096) {
         err = MP_READ_E;
     }
     else if (expLen > 512) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 4096) {
         err = MP_READ_E;
     }
-    else if (*outLen < 512U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_4096_from_mp(b, 64, base);
         sp_4096_from_bin(e, 64, exp, expLen);
         sp_4096_from_mp(m, 64, mod);
 
     #ifdef HAVE_FFDHE_4096
         if (base->used == 1 && base->dp[0] == 2 && m[63] == (sp_digit)-1)
             err = sp_4096_mod_exp_2_64(r, e, expLen * 8, m);
         else
     #endif
             err = sp_4096_mod_exp_64(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_4096_to_bin_64(r, out);
         *outLen = 512;
         for (i=0; i<512 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 #endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */
 
 #endif /* WOLFSSL_SP_4096 */
 
 #endif /* WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH */
 #ifdef WOLFSSL_HAVE_SP_ECC
 #ifndef WOLFSSL_SP_NO_256
 
 /* Point structure to use. */
diff --git a/wolfcrypt/src/sp_armthumb.c b/wolfcrypt/src/sp_armthumb.c
index 863741371..f02df823e 100644
--- a/wolfcrypt/src/sp_armthumb.c
+++ b/wolfcrypt/src/sp_armthumb.c
@@ -30131,78 +30131,75 @@ static int sp_2048_mod_exp_2_64(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 256 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_2048(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[128];
     sp_digit e[64];
     sp_digit m[64];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 2048) {
         err = MP_READ_E;
     }
     else if (expLen > 256) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 2048) {
         err = MP_READ_E;
     }
-    else if (*outLen < 256U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_2048_from_mp(b, 64, base);
         sp_2048_from_bin(e, 64, exp, expLen);
         sp_2048_from_mp(m, 64, mod);
 
     #ifdef HAVE_FFDHE_2048
         if (base->used == 1 && base->dp[0] == 2 && m[63] == (sp_digit)-1)
             err = sp_2048_mod_exp_2_64(r, e, expLen * 8, m);
         else
     #endif
             err = sp_2048_mod_exp_64(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_2048_to_bin_64(r, out);
         *outLen = 256;
         for (i=0; i<256 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -83223,78 +83220,75 @@ static int sp_3072_mod_exp_2_96(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 384 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[192];
     sp_digit e[96];
     sp_digit m[96];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 3072) {
         err = MP_READ_E;
     }
     else if (expLen > 384) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 3072) {
         err = MP_READ_E;
     }
-    else if (*outLen < 384U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_3072_from_mp(b, 96, base);
         sp_3072_from_bin(e, 96, exp, expLen);
         sp_3072_from_mp(m, 96, mod);
 
     #ifdef HAVE_FFDHE_3072
         if (base->used == 1 && base->dp[0] == 2 && m[95] == (sp_digit)-1)
             err = sp_3072_mod_exp_2_96(r, e, expLen * 8, m);
         else
     #endif
             err = sp_3072_mod_exp_96(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_3072_to_bin_96(r, out);
         *outLen = 384;
         for (i=0; i<384 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -96567,78 +96561,75 @@ static int sp_4096_mod_exp_2_128(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 512 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[256];
     sp_digit e[128];
     sp_digit m[128];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 4096) {
         err = MP_READ_E;
     }
     else if (expLen > 512) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 4096) {
         err = MP_READ_E;
     }
-    else if (*outLen < 512U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_4096_from_mp(b, 128, base);
         sp_4096_from_bin(e, 128, exp, expLen);
         sp_4096_from_mp(m, 128, mod);
 
     #ifdef HAVE_FFDHE_4096
         if (base->used == 1 && base->dp[0] == 2 && m[127] == (sp_digit)-1)
             err = sp_4096_mod_exp_2_128(r, e, expLen * 8, m);
         else
     #endif
             err = sp_4096_mod_exp_128(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_4096_to_bin_128(r, out);
         *outLen = 512;
         for (i=0; i<512 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 #endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */
 
 #endif /* WOLFSSL_SP_4096 */
 
 #endif /* WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH */
 #ifdef WOLFSSL_HAVE_SP_ECC
 #ifndef WOLFSSL_SP_NO_256
 
 /* Point structure to use. */
diff --git a/wolfcrypt/src/sp_c32.c b/wolfcrypt/src/sp_c32.c
index 4f7462efc..49838d855 100644
--- a/wolfcrypt/src/sp_c32.c
+++ b/wolfcrypt/src/sp_c32.c
@@ -4608,108 +4608,105 @@ static int sp_2048_mod_exp_2_72(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 256 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_2048(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[72 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 2048) {
         err = MP_READ_E;
     }
     else if (expLen > 256U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 2048) {
         err = MP_READ_E;
     }
-    else if (*outLen < 256U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 72 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 72 * 2;
         m = e + 72;
         r = b;
 
         sp_2048_from_mp(b, 72, base);
         sp_2048_from_bin(e, 72, exp, expLen);
         sp_2048_from_mp(m, 72, mod);
 
     #ifdef HAVE_FFDHE_2048
         if (base->used == 1 && base->dp[0] == 2U &&
                 (m[70] >> 2) == 0xffffL) {
             err = sp_2048_mod_exp_2_72(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_2048_mod_exp_72(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_2048
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_2048_to_bin_72(r, out);
         *outLen = 256;
         for (i=0; i<256U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 72U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -7919,108 +7916,105 @@ static int sp_3072_mod_exp_2_106(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 384 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[106 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 3072) {
         err = MP_READ_E;
     }
     else if (expLen > 384U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 3072) {
         err = MP_READ_E;
     }
-    else if (*outLen < 384U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 106 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 106 * 2;
         m = e + 106;
         r = b;
 
         sp_3072_from_mp(b, 106, base);
         sp_3072_from_bin(e, 106, exp, expLen);
         sp_3072_from_mp(m, 106, mod);
 
     #ifdef HAVE_FFDHE_3072
         if (base->used == 1 && base->dp[0] == 2U &&
                 (m[105] >> 11) == 0xffffL) {
             err = sp_3072_mod_exp_2_106(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_3072_mod_exp_106(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_3072
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_3072_to_bin_106(r, out);
         *outLen = 384;
         for (i=0; i<384U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 106U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -12261,108 +12255,105 @@ static int sp_3072_mod_exp_2_112(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 384 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[112 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 3072) {
         err = MP_READ_E;
     }
     else if (expLen > 384U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 3072) {
         err = MP_READ_E;
     }
-    else if (*outLen < 384U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 112 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 112 * 2;
         m = e + 112;
         r = b;
 
         sp_3072_from_mp(b, 112, base);
         sp_3072_from_bin(e, 112, exp, expLen);
         sp_3072_from_mp(m, 112, mod);
 
     #ifdef HAVE_FFDHE_3072
         if (base->used == 1 && base->dp[0] == 2U &&
                 (m[109] >> 4) == 0xffffL) {
             err = sp_3072_mod_exp_2_112(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_3072_mod_exp_112(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_3072
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_3072_to_bin_112(r, out);
         *outLen = 384;
         for (i=0; i<384U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 112U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -15583,109 +15574,106 @@ static int sp_4096_mod_exp_2_142(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 512 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[142 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 4096) {
         err = MP_READ_E;
     }
     else if (expLen > 512U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 4096) {
         err = MP_READ_E;
     }
-    else if (*outLen < 512U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 142 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 142 * 2;
         m = e + 142;
         r = b;
 
         sp_4096_from_mp(b, 142, base);
         sp_4096_from_bin(e, 142, exp, expLen);
         sp_4096_from_mp(m, 142, mod);
 
     #ifdef HAVE_FFDHE_4096
         if (base->used == 1 && base->dp[0] == 2U &&
                 ((m[141] << 9) | (m[140] >> 20)) == 0xffffL) {
             err = sp_4096_mod_exp_2_142(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_4096_mod_exp_142(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_4096
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_4096_to_bin_142(r, out);
         *outLen = 512;
         for (i=0; i<512U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 142U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 #endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */
 
 #else
 /* Read big endian unsigned byte array into r.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  Byte array.
  * n  Number of bytes in array to read.
  */
@@ -19892,109 +19880,106 @@ static int sp_4096_mod_exp_2_162(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 512 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[162 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 4096) {
         err = MP_READ_E;
     }
     else if (expLen > 512U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 4096) {
         err = MP_READ_E;
     }
-    else if (*outLen < 512U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 162 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 162 * 2;
         m = e + 162;
         r = b;
 
         sp_4096_from_mp(b, 162, base);
         sp_4096_from_bin(e, 162, exp, expLen);
         sp_4096_from_mp(m, 162, mod);
 
     #ifdef HAVE_FFDHE_4096
         if (base->used == 1 && base->dp[0] == 2U &&
                 ((m[157] << 2) | (m[156] >> 24)) == 0xffffL) {
             err = sp_4096_mod_exp_2_162(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_4096_mod_exp_162(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_4096
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_4096_to_bin_162(r, out);
         *outLen = 512;
         for (i=0; i<512U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 162U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 #endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */
 
 #endif /* WOLFSSL_SP_SMALL */
 #endif /* WOLFSSL_SP_4096 */
 
 #endif /* WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH */
 #ifdef WOLFSSL_HAVE_SP_ECC
 #ifndef WOLFSSL_SP_NO_256
 
 /* Point structure to use. */
diff --git a/wolfcrypt/src/sp_c64.c b/wolfcrypt/src/sp_c64.c
index 40b846b2e..318ff17c4 100644
--- a/wolfcrypt/src/sp_c64.c
+++ b/wolfcrypt/src/sp_c64.c
@@ -3130,108 +3130,105 @@ static int sp_2048_mod_exp_2_34(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 256 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_2048(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[34 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 2048) {
         err = MP_READ_E;
     }
     else if (expLen > 256U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 2048) {
         err = MP_READ_E;
     }
-    else if (*outLen < 256U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 34 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 34 * 2;
         m = e + 34;
         r = b;
 
         sp_2048_from_mp(b, 34, base);
         sp_2048_from_bin(e, 34, exp, expLen);
         sp_2048_from_mp(m, 34, mod);
 
     #ifdef HAVE_FFDHE_2048
         if (base->used == 1 && base->dp[0] == 2U &&
                 (m[33] >> 3) == 0xffffffffL) {
             err = sp_2048_mod_exp_2_34(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_2048_mod_exp_34(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_2048
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_2048_to_bin_34(r, out);
         *outLen = 256;
         for (i=0; i<256U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 34U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -6802,108 +6799,105 @@ static int sp_2048_mod_exp_2_36(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 256 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_2048(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[36 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 2048) {
         err = MP_READ_E;
     }
     else if (expLen > 256U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 2048) {
         err = MP_READ_E;
     }
-    else if (*outLen < 256U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 36 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 36 * 2;
         m = e + 36;
         r = b;
 
         sp_2048_from_mp(b, 36, base);
         sp_2048_from_bin(e, 36, exp, expLen);
         sp_2048_from_mp(m, 36, mod);
 
     #ifdef HAVE_FFDHE_2048
         if (base->used == 1 && base->dp[0] == 2U &&
                 (m[35] >> 21) == 0xffffffffL) {
             err = sp_2048_mod_exp_2_36(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_2048_mod_exp_36(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_2048
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_2048_to_bin_36(r, out);
         *outLen = 256;
         for (i=0; i<256U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 36U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -10019,108 +10013,105 @@ static int sp_3072_mod_exp_2_52(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 384 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[52 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 3072) {
         err = MP_READ_E;
     }
     else if (expLen > 384U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 3072) {
         err = MP_READ_E;
     }
-    else if (*outLen < 384U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 52 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 52 * 2;
         m = e + 52;
         r = b;
 
         sp_3072_from_mp(b, 52, base);
         sp_3072_from_bin(e, 52, exp, expLen);
         sp_3072_from_mp(m, 52, mod);
 
     #ifdef HAVE_FFDHE_3072
         if (base->used == 1 && base->dp[0] == 2U &&
                 ((m[51] << 20) | (m[50] >> 40)) == 0xffffffffL) {
             err = sp_3072_mod_exp_2_52(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_3072_mod_exp_52(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_3072
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_3072_to_bin_52(r, out);
         *outLen = 384;
         for (i=0; i<384U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 52U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -13876,108 +13867,105 @@ static int sp_3072_mod_exp_2_54(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 384 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[54 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 3072) {
         err = MP_READ_E;
     }
     else if (expLen > 384U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 3072) {
         err = MP_READ_E;
     }
-    else if (*outLen < 384U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 54 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 54 * 2;
         m = e + 54;
         r = b;
 
         sp_3072_from_mp(b, 54, base);
         sp_3072_from_bin(e, 54, exp, expLen);
         sp_3072_from_mp(m, 54, mod);
 
     #ifdef HAVE_FFDHE_3072
         if (base->used == 1 && base->dp[0] == 2U &&
                 (m[53] >> 19) == 0xffffffffL) {
             err = sp_3072_mod_exp_2_54(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_3072_mod_exp_54(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_3072
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_3072_to_bin_54(r, out);
         *outLen = 384;
         for (i=0; i<384U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 54U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -17094,109 +17082,106 @@ static int sp_4096_mod_exp_2_70(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 512 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[70 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 4096) {
         err = MP_READ_E;
     }
     else if (expLen > 512U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 4096) {
         err = MP_READ_E;
     }
-    else if (*outLen < 512U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 70 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 70 * 2;
         m = e + 70;
         r = b;
 
         sp_4096_from_mp(b, 70, base);
         sp_4096_from_bin(e, 70, exp, expLen);
         sp_4096_from_mp(m, 70, mod);
 
     #ifdef HAVE_FFDHE_4096
         if (base->used == 1 && base->dp[0] == 2U &&
                 ((m[69] << 7) | (m[68] >> 52)) == 0xffffffffL) {
             err = sp_4096_mod_exp_2_70(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_4096_mod_exp_70(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_4096
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_4096_to_bin_70(r, out);
         *outLen = 512;
         for (i=0; i<512U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 70U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 #endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */
 
 #else
 /* Read big endian unsigned byte array into r.
  *
  * r  A single precision integer.
  * size  Maximum number of bytes to convert
  * a  Byte array.
  * n  Number of bytes in array to read.
  */
@@ -21055,109 +21040,106 @@ static int sp_4096_mod_exp_2_78(sp_digit* r, const sp_digit* e, int bits, const
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 512 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit* b = NULL;
 #else
     sp_digit b[78 * 4];
 #endif
     sp_digit* e = NULL;
     sp_digit* m = NULL;
     sp_digit* r = NULL;
     word32 i;
     int err = MP_OKAY;
 
     if (mp_count_bits(base) > 4096) {
         err = MP_READ_E;
     }
     else if (expLen > 512U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 4096) {
         err = MP_READ_E;
     }
-    else if (*outLen < 512U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         b = (sp_digit*)XMALLOC(sizeof(sp_digit) * 78 * 4, NULL,
             DYNAMIC_TYPE_DH);
         if (b == NULL)
             err = MEMORY_E;
     }
 #endif
 
     if (err == MP_OKAY) {
         e = b + 78 * 2;
         m = e + 78;
         r = b;
 
         sp_4096_from_mp(b, 78, base);
         sp_4096_from_bin(e, 78, exp, expLen);
         sp_4096_from_mp(m, 78, mod);
 
     #ifdef HAVE_FFDHE_4096
         if (base->used == 1 && base->dp[0] == 2U &&
                 ((m[77] << 17) | (m[76] >> 36)) == 0xffffffffL) {
             err = sp_4096_mod_exp_2_78(r, e, expLen * 8U, m);
         }
         else {
     #endif
             err = sp_4096_mod_exp_78(r, b, e, expLen * 8U, m, 0);
     #ifdef HAVE_FFDHE_4096
         }
     #endif
     }
 
     if (err == MP_OKAY) {
         sp_4096_to_bin_78(r, out);
         *outLen = 512;
         for (i=0; i<512U && out[i] == 0U; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
 #endif
     {
         /* only "e" is sensitive and needs zeroized */
         if (e != NULL)
             ForceZero(e, sizeof(sp_digit) * 78U);
     #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
         XFREE(b, NULL, DYNAMIC_TYPE_DH);
     #endif
     }
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 #endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */
 
 #endif /* WOLFSSL_SP_SMALL */
 #endif /* WOLFSSL_SP_4096 */
 
 #endif /* WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH */
 #ifdef WOLFSSL_HAVE_SP_ECC
 #ifndef WOLFSSL_SP_NO_256
 
 /* Point structure to use. */
diff --git a/wolfcrypt/src/sp_cortexm.c b/wolfcrypt/src/sp_cortexm.c
index 2c16e7769..5d6f4eedc 100644
--- a/wolfcrypt/src/sp_cortexm.c
+++ b/wolfcrypt/src/sp_cortexm.c
@@ -5757,78 +5757,75 @@ static int sp_2048_mod_exp_2_64(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 256 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_2048(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[128];
     sp_digit e[64];
     sp_digit m[64];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 2048) {
         err = MP_READ_E;
     }
     else if (expLen > 256) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 2048) {
         err = MP_READ_E;
     }
-    else if (*outLen < 256U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_2048_from_mp(b, 64, base);
         sp_2048_from_bin(e, 64, exp, expLen);
         sp_2048_from_mp(m, 64, mod);
 
     #ifdef HAVE_FFDHE_2048
         if (base->used == 1 && base->dp[0] == 2 && m[63] == (sp_digit)-1)
             err = sp_2048_mod_exp_2_64(r, e, expLen * 8, m);
         else
     #endif
             err = sp_2048_mod_exp_64(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_2048_to_bin_64(r, out);
         *outLen = 256;
         for (i=0; i<256 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -11570,78 +11567,75 @@ static int sp_3072_mod_exp_2_96(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 384 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[192];
     sp_digit e[96];
     sp_digit m[96];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 3072) {
         err = MP_READ_E;
     }
     else if (expLen > 384) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 3072) {
         err = MP_READ_E;
     }
-    else if (*outLen < 384U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_3072_from_mp(b, 96, base);
         sp_3072_from_bin(e, 96, exp, expLen);
         sp_3072_from_mp(m, 96, mod);
 
     #ifdef HAVE_FFDHE_3072
         if (base->used == 1 && base->dp[0] == 2 && m[95] == (sp_digit)-1)
             err = sp_3072_mod_exp_2_96(r, e, expLen * 8, m);
         else
     #endif
             err = sp_3072_mod_exp_96(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_3072_to_bin_96(r, out);
         *outLen = 384;
         for (i=0; i<384 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -15561,78 +15555,75 @@ static int sp_4096_mod_exp_2_128(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 512 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
     sp_digit b[256];
     sp_digit e[128];
     sp_digit m[128];
     sp_digit* r = b;
     word32 i;
 
     if (mp_count_bits(base) > 4096) {
         err = MP_READ_E;
     }
     else if (expLen > 512) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 4096) {
         err = MP_READ_E;
     }
-    else if (*outLen < 512U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         sp_4096_from_mp(b, 128, base);
         sp_4096_from_bin(e, 128, exp, expLen);
         sp_4096_from_mp(m, 128, mod);
 
     #ifdef HAVE_FFDHE_4096
         if (base->used == 1 && base->dp[0] == 2 && m[127] == (sp_digit)-1)
             err = sp_4096_mod_exp_2_128(r, e, expLen * 8, m);
         else
     #endif
             err = sp_4096_mod_exp_128(r, b, e, expLen * 8, m, 0);
 
     }
 
     if (err == MP_OKAY) {
         sp_4096_to_bin_128(r, out);
         *outLen = 512;
         for (i=0; i<512 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
 
     }
 
     XMEMSET(e, 0, sizeof(e));
 
     return err;
 }
 #endif /* WOLFSSL_HAVE_SP_DH */
 
 #endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */
 
 #endif /* WOLFSSL_SP_4096 */
 
 #endif /* WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH */
 #ifdef WOLFSSL_HAVE_SP_ECC
 #ifndef WOLFSSL_SP_NO_256
 
 /* Point structure to use. */
diff --git a/wolfcrypt/src/sp_x86_64.c b/wolfcrypt/src/sp_x86_64.c
index 3efdba2db..4304d2121 100644
--- a/wolfcrypt/src/sp_x86_64.c
+++ b/wolfcrypt/src/sp_x86_64.c
@@ -2823,124 +2823,121 @@ static int sp_2048_mod_exp_2_32(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 256 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_2048(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit *b = NULL;
     sp_digit *e = NULL;
     sp_digit *m = NULL;
     sp_digit* r;
 #else
     sp_digit b[64];
     sp_digit e[32];
     sp_digit m[32];
     sp_digit* r = b;
 #endif
     word32 i;
 #ifdef HAVE_INTEL_AVX2
     word32 cpuid_flags = cpuid_get_flags();
 #endif
 
     ASSERT_SAVED_VECTOR_REGISTERS();
 
     if (mp_count_bits(base) > 2048) {
         err = MP_READ_E;
     }
     else if (expLen > 256U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 2048) {
         err = MP_READ_E;
     }
-    else if (*outLen < 256U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         if (((b = (sp_digit *)XMALLOC(64 * sizeof(*b), NULL, DYNAMIC_TYPE_TMP_BUFFER)) == NULL) ||
             ((e = (sp_digit *)XMALLOC(32 * sizeof(*e), NULL, DYNAMIC_TYPE_TMP_BUFFER)) == NULL) ||
             ((m = (sp_digit *)XMALLOC(32 * sizeof(*m), NULL, DYNAMIC_TYPE_TMP_BUFFER)) == NULL))
         {
             err = MEMORY_E;
         } else {
             r = b;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_2048_from_mp(b, 32, base);
         sp_2048_from_bin(e, 32, exp, expLen);
         sp_2048_from_mp(m, 32, mod);
 
     #ifdef HAVE_FFDHE_2048
         if (base->used == 1 && base->dp[0] == 2 && m[31] == (sp_digit)-1) {
 #ifdef HAVE_INTEL_AVX2
             if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
                 err = sp_2048_mod_exp_2_avx2_32(r, e, expLen * 8, m);
             else
 #endif
                 err = sp_2048_mod_exp_2_32(r, e, expLen * 8, m);
         }
         else
     #endif
         {
 #ifdef HAVE_INTEL_AVX2
             if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
                 err = sp_2048_mod_exp_avx2_32(r, b, e, expLen * 8, m, 0);
             else
 #endif
                 err = sp_2048_mod_exp_32(r, b, e, expLen * 8, m, 0);
         }
     }
 
     if (err == MP_OKAY) {
         sp_2048_to_bin_32(r, out);
         *outLen = 256;
         for (i=0; i<256 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
         XFREE(b, NULL, DYNAMIC_TYPE_TMP_BUFFER);
     if (e != NULL) {
         XMEMSET(e, 0, 32);
         XFREE(e, NULL, DYNAMIC_TYPE_TMP_BUFFER);
     }
     if (m != NULL)
         XFREE(m, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 #else
     XMEMSET(e, 0, sizeof(e));
 #endif
 
     return err;
 }
 #endif
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -5724,124 +5721,121 @@ static int sp_3072_mod_exp_2_48(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 384 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_3072(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit *b = NULL;
     sp_digit *e = NULL;
     sp_digit *m = NULL;
     sp_digit* r;
 #else
     sp_digit b[96];
     sp_digit e[48];
     sp_digit m[48];
     sp_digit* r = b;
 #endif
     word32 i;
 #ifdef HAVE_INTEL_AVX2
     word32 cpuid_flags = cpuid_get_flags();
 #endif
 
     ASSERT_SAVED_VECTOR_REGISTERS();
 
     if (mp_count_bits(base) > 3072) {
         err = MP_READ_E;
     }
     else if (expLen > 384U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 3072) {
         err = MP_READ_E;
     }
-    else if (*outLen < 384U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         if (((b = (sp_digit *)XMALLOC(96 * sizeof(*b), NULL, DYNAMIC_TYPE_TMP_BUFFER)) == NULL) ||
             ((e = (sp_digit *)XMALLOC(48 * sizeof(*e), NULL, DYNAMIC_TYPE_TMP_BUFFER)) == NULL) ||
             ((m = (sp_digit *)XMALLOC(48 * sizeof(*m), NULL, DYNAMIC_TYPE_TMP_BUFFER)) == NULL))
         {
             err = MEMORY_E;
         } else {
             r = b;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_3072_from_mp(b, 48, base);
         sp_3072_from_bin(e, 48, exp, expLen);
         sp_3072_from_mp(m, 48, mod);
 
     #ifdef HAVE_FFDHE_3072
         if (base->used == 1 && base->dp[0] == 2 && m[47] == (sp_digit)-1) {
 #ifdef HAVE_INTEL_AVX2
             if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
                 err = sp_3072_mod_exp_2_avx2_48(r, e, expLen * 8, m);
             else
 #endif
                 err = sp_3072_mod_exp_2_48(r, e, expLen * 8, m);
         }
         else
     #endif
         {
 #ifdef HAVE_INTEL_AVX2
             if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
                 err = sp_3072_mod_exp_avx2_48(r, b, e, expLen * 8, m, 0);
             else
 #endif
                 err = sp_3072_mod_exp_48(r, b, e, expLen * 8, m, 0);
         }
     }
 
     if (err == MP_OKAY) {
         sp_3072_to_bin_48(r, out);
         *outLen = 384;
         for (i=0; i<384 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
         XFREE(b, NULL, DYNAMIC_TYPE_TMP_BUFFER);
     if (e != NULL) {
         XMEMSET(e, 0, 48);
         XFREE(e, NULL, DYNAMIC_TYPE_TMP_BUFFER);
     }
     if (m != NULL)
         XFREE(m, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 #else
     XMEMSET(e, 0, sizeof(e));
 #endif
 
     return err;
 }
 #endif
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base  Base. MP integer.
  * exp   Exponent. MP integer.
  * mod   Modulus. MP integer.
  * res   Result. MP integer.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
@@ -7851,124 +7845,121 @@ static int sp_4096_mod_exp_2_64(sp_digit* r, const sp_digit* e, int bits,
 /* Perform the modular exponentiation for Diffie-Hellman.
  *
  * base     Base.
  * exp      Array of bytes that is the exponent.
  * expLen   Length of data, in bytes, in exponent.
  * mod      Modulus.
  * out      Buffer to hold big-endian bytes of exponentiation result.
  *          Must be at least 512 bytes long.
  * outLen   Length, in bytes, of exponentiation result.
  * returns 0 on success, MP_READ_E if there are too many bytes in an array
  * and MEMORY_E if memory allocation fails.
  */
 int sp_DhExp_4096(const mp_int* base, const byte* exp, word32 expLen,
     const mp_int* mod, byte* out, word32* outLen)
 {
     int err = MP_OKAY;
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     sp_digit *b = NULL;
     sp_digit *e = NULL;
     sp_digit *m = NULL;
     sp_digit* r;
 #else
     sp_digit b[128];
     sp_digit e[64];
     sp_digit m[64];
     sp_digit* r = b;
 #endif
     word32 i;
 #ifdef HAVE_INTEL_AVX2
     word32 cpuid_flags = cpuid_get_flags();
 #endif
 
     ASSERT_SAVED_VECTOR_REGISTERS();
 
     if (mp_count_bits(base) > 4096) {
         err = MP_READ_E;
     }
     else if (expLen > 512U) {
         err = MP_READ_E;
     }
     else if (mp_count_bits(mod) != 4096) {
         err = MP_READ_E;
     }
-    else if (*outLen < 512U) {
-        err = BUFFER_E;
-    }
     else if (mp_iseven(mod)) {
         err = MP_VAL;
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (err == MP_OKAY) {
         if (((b = (sp_digit *)XMALLOC(128 * sizeof(*b), NULL, DYNAMIC_TYPE_TMP_BUFFER)) == NULL) ||
             ((e = (sp_digit *)XMALLOC(64 * sizeof(*e), NULL, DYNAMIC_TYPE_TMP_BUFFER)) == NULL) ||
             ((m = (sp_digit *)XMALLOC(64 * sizeof(*m), NULL, DYNAMIC_TYPE_TMP_BUFFER)) == NULL))
         {
             err = MEMORY_E;
         } else {
             r = b;
         }
     }
 #endif
 
     if (err == MP_OKAY) {
         sp_4096_from_mp(b, 64, base);
         sp_4096_from_bin(e, 64, exp, expLen);
         sp_4096_from_mp(m, 64, mod);
 
     #ifdef HAVE_FFDHE_4096
         if (base->used == 1 && base->dp[0] == 2 && m[63] == (sp_digit)-1) {
 #ifdef HAVE_INTEL_AVX2
             if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
                 err = sp_4096_mod_exp_2_avx2_64(r, e, expLen * 8, m);
             else
 #endif
                 err = sp_4096_mod_exp_2_64(r, e, expLen * 8, m);
         }
         else
     #endif
         {
 #ifdef HAVE_INTEL_AVX2
             if (IS_INTEL_BMI2(cpuid_flags) && IS_INTEL_ADX(cpuid_flags))
                 err = sp_4096_mod_exp_avx2_64(r, b, e, expLen * 8, m, 0);
             else
 #endif
                 err = sp_4096_mod_exp_64(r, b, e, expLen * 8, m, 0);
         }
     }
 
     if (err == MP_OKAY) {
         sp_4096_to_bin_64(r, out);
         *outLen = 512;
         for (i=0; i<512 && out[i] == 0; i++) {
             /* Search for first non-zero. */
         }
         *outLen -= i;
         XMEMMOVE(out, out + i, *outLen);
     }
 
 #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SP_NO_MALLOC)
     if (b != NULL)
         XFREE(b, NULL, DYNAMIC_TYPE_TMP_BUFFER);
     if (e != NULL) {
         XMEMSET(e, 0, 64);
         XFREE(e, NULL, DYNAMIC_TYPE_TMP_BUFFER);
     }
     if (m != NULL)
         XFREE(m, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 #else
     XMEMSET(e, 0, sizeof(e));
 #endif
 
     return err;
 }
 #endif
 #endif /* WOLFSSL_HAVE_SP_DH | (WOLFSSL_HAVE_SP_RSA & !WOLFSSL_RSA_PUBLIC_ONLY) */
 
 #endif /* WOLFSSL_SP_4096 */
 
 #endif /* WOLFSSL_HAVE_SP_RSA | WOLFSSL_HAVE_SP_DH */
 #ifdef WOLFSSL_HAVE_SP_ECC
 #ifndef WOLFSSL_SP_NO_256
 
 /* Point structure to use. */
