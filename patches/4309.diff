commit 6c573e7f33380e60b583294e9ec5d68ae351c3cf
Author: Varun Khaneja <ca.aawc@yahoo.com>
Date:   Tue Nov 21 08:18:40 2017 -0800

    Upload v5.6.1.3

diff --git a/arccmt.cpp b/arccmt.cpp
index 79963b2..e0db392 100644
--- a/arccmt.cpp
+++ b/arccmt.cpp
@@ -3,119 +3,126 @@ static bool IsAnsiEscComment(const wchar *Data,size_t Size);
 bool Archive::GetComment(Array<wchar> *CmtData)
 {
   if (!MainComment)
     return false;
   SaveFilePos SavePos(*this);
 
 #ifndef SFX_MODULE
   uint CmtLength;
   if (Format==RARFMT14)
   {
     Seek(SFXSize+SIZEOF_MAINHEAD14,SEEK_SET);
     CmtLength=GetByte();
     CmtLength+=(GetByte()<<8);
   }
   else
 #endif
   {
     if (MainHead.CommentInHeader)
     {
       // Old style (RAR 2.9) archive comment embedded into the main 
       // archive header.
       Seek(SFXSize+SIZEOF_MARKHEAD3+SIZEOF_MAINHEAD3,SEEK_SET);
-      ReadHeader();
+      if (!ReadHeader())
+        return false;
     }
     else
     {
       // Current (RAR 3.0+) version of archive comment.
       Seek(GetStartPos(),SEEK_SET);
       return SearchSubBlock(SUBHEAD_TYPE_CMT)!=0 && ReadCommentData(CmtData);
     }
 #ifndef SFX_MODULE
     // Old style (RAR 2.9) comment header embedded into the main 
     // archive header.
     if (BrokenHeader)
     {
       uiMsg(UIERROR_CMTBROKEN,FileName);
       return false;
     }
     CmtLength=CommHead.HeadSize-SIZEOF_COMMHEAD;
 #endif
   }
 #ifndef SFX_MODULE
   if (Format==RARFMT14 && MainHead.PackComment || Format!=RARFMT14 && CommHead.Method!=0x30)
   {
     if (Format!=RARFMT14 && (CommHead.UnpVer < 15 || CommHead.UnpVer > VER_UNPACK || CommHead.Method > 0x35))
       return false;
     ComprDataIO DataIO;
     DataIO.SetTestMode(true);
     uint UnpCmtLength;
     if (Format==RARFMT14)
     {
 #ifdef RAR_NOCRYPT
       return false;
 #else
       UnpCmtLength=GetByte();
       UnpCmtLength+=(GetByte()<<8);
       CmtLength-=2;
       DataIO.SetCmt13Encryption();
       CommHead.UnpVer=15;
 #endif
     }
     else
       UnpCmtLength=CommHead.UnpSize;
     DataIO.SetFiles(this,NULL);
     DataIO.EnableShowProgress(false);
     DataIO.SetPackedSizeToRead(CmtLength);
     DataIO.UnpHash.Init(HASH_CRC32,1);
+    DataIO.SetNoFileHeader(true); // this->FileHead is not filled yet.
 
     Unpack CmtUnpack(&DataIO);
     CmtUnpack.Init(0x10000,false);
     CmtUnpack.SetDestSize(UnpCmtLength);
     CmtUnpack.DoUnpack(CommHead.UnpVer,false);
 
     if (Format!=RARFMT14 && (DataIO.UnpHash.GetCRC32()&0xffff)!=CommHead.CommCRC)
     {
       uiMsg(UIERROR_CMTBROKEN,FileName);
       return false;
     }
     else
     {
       byte *UnpData;
       size_t UnpDataSize;
       DataIO.GetUnpackedData(&UnpData,&UnpDataSize);
 #ifdef _WIN_ALL
       // If we ever decide to extend it to Android, we'll need to alloc
       // 4x memory for OEM to UTF-8 output here.
       OemToCharBuffA((char *)UnpData,(char *)UnpData,(DWORD)UnpDataSize);
 #endif
       CmtData->Alloc(UnpDataSize+1);
       memset(CmtData->Addr(0),0,CmtData->Size()*sizeof(wchar));
       CharToWide((char *)UnpData,CmtData->Addr(0),CmtData->Size());
       CmtData->Alloc(wcslen(CmtData->Addr(0)));
     }
   }
   else
   {
     if (CmtLength==0)
       return false;
     Array<byte> CmtRaw(CmtLength);
-    Read(&CmtRaw[0],CmtLength);
+    int ReadSize=Read(&CmtRaw[0],CmtLength);
+    if (ReadSize>=0 && (uint)ReadSize<CmtLength) // Comment is shorter than declared.
+    {
+      CmtLength=ReadSize;
+      CmtRaw.Alloc(CmtLength);
+    }
 
     if (Format!=RARFMT14 && CommHead.CommCRC!=(~CRC32(0xffffffff,&CmtRaw[0],CmtLength)&0xffff))
     {
       uiMsg(UIERROR_CMTBROKEN,FileName);
       return false;
     }
     CmtData->Alloc(CmtLength+1);
     CmtRaw.Push(0);
 #ifdef _WIN_ALL
     // If we ever decide to extend it to Android, we'll need to alloc
     // 4x memory for OEM to UTF-8 output here.
     OemToCharA((char *)&CmtRaw[0],(char *)&CmtRaw[0]);
 #endif
     CharToWide((char *)&CmtRaw[0],CmtData->Addr(0),CmtLength);
     CmtData->Alloc(wcslen(CmtData->Addr(0)));
   }
 #endif
   return CmtData->Size() > 0;
 }
diff --git a/archive.cpp b/archive.cpp
index a519177..2abe60d 100644
--- a/archive.cpp
+++ b/archive.cpp
@@ -124,142 +124,142 @@ RARFORMAT Archive::IsSignature(const byte *D,size_t Size)
 bool Archive::IsArchive(bool EnableBroken)
 {
   Encrypted=false;
   BrokenHeader=false; // Might be left from previous volume.
   
 #ifndef SFX_MODULE
   if (IsDevice())
   {
     uiMsg(UIERROR_INVALIDNAME,FileName,FileName);
     return false;
   }
 #endif
   if (Read(MarkHead.Mark,SIZEOF_MARKHEAD3)!=SIZEOF_MARKHEAD3)
     return false;
   SFXSize=0;
   
   RARFORMAT Type;
   if ((Type=IsSignature(MarkHead.Mark,SIZEOF_MARKHEAD3))!=RARFMT_NONE)
   {
     Format=Type;
     if (Format==RARFMT14)
       Seek(Tell()-SIZEOF_MARKHEAD3,SEEK_SET);
   }
   else
   {
     Array<char> Buffer(MAXSFXSIZE);
     long CurPos=(long)Tell();
     int ReadSize=Read(&Buffer[0],Buffer.Size()-16);
     for (int I=0;I<ReadSize;I++)
       if (Buffer[I]==0x52 && (Type=IsSignature((byte *)&Buffer[I],ReadSize-I))!=RARFMT_NONE)
       {
         Format=Type;
         if (Format==RARFMT14 && I>0 && CurPos<28 && ReadSize>31)
         {
           char *D=&Buffer[28-CurPos];
           if (D[0]!=0x52 || D[1]!=0x53 || D[2]!=0x46 || D[3]!=0x58)
             continue;
         }
         SFXSize=CurPos+I;
         Seek(SFXSize,SEEK_SET);
         if (Format==RARFMT15 || Format==RARFMT50)
           Read(MarkHead.Mark,SIZEOF_MARKHEAD3);
         break;
       }
     if (SFXSize==0)
       return false;
   }
   if (Format==RARFMT_FUTURE)
   {
     uiMsg(UIERROR_NEWRARFORMAT,FileName);
     return false;
   }
   if (Format==RARFMT50) // RAR 5.0 signature is by one byte longer.
   {
     if (Read(MarkHead.Mark+SIZEOF_MARKHEAD3,1)!=1 || MarkHead.Mark[SIZEOF_MARKHEAD3]!=0)
       return false;
     MarkHead.HeadSize=SIZEOF_MARKHEAD5;
   }
   else
     MarkHead.HeadSize=SIZEOF_MARKHEAD3;
 
 #ifdef RARDLL
   // If callback function is not set, we cannot get the password,
   // so we skip the initial header processing for encrypted header archive.
   // It leads to skipped archive comment, but the rest of archive data
   // is processed correctly.
   if (Cmd->Callback==NULL)
     SilentOpen=true;
 #endif
 
   bool HeadersLeft; // Any headers left to read.
   // Skip the archive encryption header if any and read the main header.
-  while (HeadersLeft=(ReadHeader()!=0))
+  while ((HeadersLeft=(ReadHeader()!=0))==true) // Additional parentheses to silence Clang.
   {
     SeekToNext();
 
     HEADER_TYPE Type=GetHeaderType();
     // In RAR 5.0 we need to quit after reading HEAD_CRYPT if we wish to
     // avoid the password prompt.
     if (Type==HEAD_MAIN || SilentOpen && Type==HEAD_CRYPT)
       break;
   }
 
   // This check allows to make RS based recovery even if password is incorrect.
   // But we should not do it for EnableBroken or we'll get 'not RAR archive'
   // messages when extracting encrypted archives with wrong password.
   if (FailedHeaderDecryption && !EnableBroken)
     return false;
 
   if (BrokenHeader) // Main archive header is corrupt.
   {
     uiMsg(UIERROR_MHEADERBROKEN,FileName);
     if (!EnableBroken)
       return false;
   }
 
   MainComment=MainHead.CommentInHeader;
 
   // If we process non-encrypted archive or can request a password,
   // we set 'first volume' flag based on file attributes below.
   // It is necessary for RAR 2.x archives, which did not have 'first volume'
   // flag in main header. Also for all RAR formats we need to scan until
   // first file header to set "comment" flag when reading service header.
   // Unless we are in silent mode, we need to know about presence of comment
   // immediately after IsArchive call.
   if (HeadersLeft && (!SilentOpen || !Encrypted))
   {
     SaveFilePos SavePos(*this);
     int64 SaveCurBlockPos=CurBlockPos,SaveNextBlockPos=NextBlockPos;
     HEADER_TYPE SaveCurHeaderType=CurHeaderType;
 
     while (ReadHeader()!=0)
     {
       HEADER_TYPE HeaderType=GetHeaderType();
       if (HeaderType==HEAD_SERVICE)
       {
         // If we have a split service headers, it surely indicates non-first
         // volume. But not split service header does not guarantee the first
         // volume, because we can have split file after non-split archive
         // comment. So we do not quit from loop here.
         FirstVolume=Volume && !SubHead.SplitBefore;
       }
       else
         if (HeaderType==HEAD_FILE)
         {
           FirstVolume=Volume && !FileHead.SplitBefore;
           break;
         }
         else
           if (HeaderType==HEAD_ENDARC) // Might happen if archive contains only a split service header.
             break;
       SeekToNext();
     }
     CurBlockPos=SaveCurBlockPos;
     NextBlockPos=SaveNextBlockPos;
     CurHeaderType=SaveCurHeaderType;
   }
   if (!Volume || FirstVolume)
     wcsncpyz(FirstVolumeName,FileName,ASIZE(FirstVolumeName));
 
   return true;
 }
diff --git a/arcread.cpp b/arcread.cpp
index acba581..a4900f9 100644
--- a/arcread.cpp
+++ b/arcread.cpp
@@ -3,34 +3,41 @@
 size_t Archive::ReadHeader()
 {
   // Once we failed to decrypt an encrypted block, there is no reason to
   // attempt to do it further. We'll never be successful and only generate
   // endless errors.
   if (FailedHeaderDecryption)
     return 0;
 
   CurBlockPos=Tell();
 
   size_t ReadSize;
   switch(Format)
   {
 #ifndef SFX_MODULE
     case RARFMT14:
       ReadSize=ReadHeader14();
       break;
 #endif
     case RARFMT15:
       ReadSize=ReadHeader15();
       break;
     case RARFMT50:
       ReadSize=ReadHeader50();
       break;
   }
 
+  // It is important to check ReadSize>0 here, because it is normal
+  // for RAR2 and RAR3 archives without end of archive block to have
+  // NextBlockPos==CurBlockPos after the end of archive has reached.
   if (ReadSize>0 && NextBlockPos<=CurBlockPos)
   {
     BrokenHeaderMsg();
-    return 0;
+    ReadSize=0;
   }
+
+  if (ReadSize==0)
+    CurHeaderType=HEAD_UNKNOWN;
+
   return ReadSize;
 }
 
@@ -85,14 +92,14 @@ size_t Archive::SearchRR()
 
 void Archive::UnexpEndArcMsg()
 {
-  uint64 ArcSize=FileLength();
+  int64 ArcSize=FileLength();
 
   // If block positions are equal to file size, this is not an error.
   // It can happen when we reached the end of older RAR 1.5 archive,
   // which did not have the end of archive block.
   if (CurBlockPos!=ArcSize || NextBlockPos!=ArcSize)
   {
     uiMsg(UIERROR_UNEXPEOF,FileName);
     ErrHandler.SetErrorCode(RARX_WARNING);
   }
 }
@@ -113,445 +120,452 @@ void Archive::UnkEncVerMsg(const wchar *Name)
 }
 
 
+// Return f in case of signed integer overflow or negative parameters
+// or v1+v2 otherwise. We use it for file offsets, which are signed
+// for compatibility with off_t in POSIX file functions and third party code.
+// Signed integer overflow is the undefined behavior according to
+// C++ standard and it causes fuzzers to complain.
+inline int64 SafeAdd(int64 v1,int64 v2,int64 f)
+{
+  return v1>=0 && v2>=0 && v1<=MAX_INT64-v2 ? v1+v2 : f;
+}
+
+
 size_t Archive::ReadHeader15()
 {
   RawRead Raw(this);
 
   bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD3;
 
   if (Decrypt)
   {
 #ifdef RAR_NOCRYPT // For rarext.dll and unrar_nocrypt.dll.
     return 0;
 #else
     RequestArcPassword();
 
     byte Salt[SIZE_SALT30];
     if (Read(Salt,SIZE_SALT30)!=SIZE_SALT30)
     {
       UnexpEndArcMsg();
       return 0;
     }
     HeadersCrypt.SetCryptKeys(false,CRYPT_RAR30,&Cmd->Password,Salt,NULL,0,NULL,NULL);
     Raw.SetCrypt(&HeadersCrypt);
 #endif
   }
 
   Raw.Read(SIZEOF_SHORTBLOCKHEAD);
   if (Raw.Size()==0)
   {
     UnexpEndArcMsg();
     return 0;
   }
 
   ShortBlock.HeadCRC=Raw.Get2();
 
   ShortBlock.Reset();
 
   uint HeaderType=Raw.Get1();
   ShortBlock.Flags=Raw.Get2();
   ShortBlock.SkipIfUnknown=(ShortBlock.Flags & SKIP_IF_UNKNOWN)!=0;
   ShortBlock.HeadSize=Raw.Get2();
 
   ShortBlock.HeaderType=(HEADER_TYPE)HeaderType;
   if (ShortBlock.HeadSize<SIZEOF_SHORTBLOCKHEAD)
   {
     BrokenHeaderMsg();
     return 0;
   }
 
   // For simpler further processing we map header types common
   // for RAR 1.5 and 5.0 formats to RAR 5.0 values. It does not include
   // header types specific for RAR 1.5 - 4.x only.
   switch(ShortBlock.HeaderType)
   {
     case HEAD3_MAIN:    ShortBlock.HeaderType=HEAD_MAIN;     break;
     case HEAD3_FILE:    ShortBlock.HeaderType=HEAD_FILE;     break;
     case HEAD3_SERVICE: ShortBlock.HeaderType=HEAD_SERVICE;  break;
     case HEAD3_ENDARC:  ShortBlock.HeaderType=HEAD_ENDARC;   break;
   }
   CurHeaderType=ShortBlock.HeaderType;
 
   if (ShortBlock.HeaderType==HEAD3_CMT)
   {
     // Old style (up to RAR 2.9) comment header embedded into main
     // or file header. We must not read the entire ShortBlock.HeadSize here
     // to not break the comment processing logic later.
     Raw.Read(SIZEOF_COMMHEAD-SIZEOF_SHORTBLOCKHEAD);
   }
   else
     if (ShortBlock.HeaderType==HEAD_MAIN && (ShortBlock.Flags & MHD_COMMENT)!=0)
     {
       // Old style (up to RAR 2.9) main archive comment embedded into
       // the main archive header found. While we can read the entire 
       // ShortBlock.HeadSize here and remove this part of "if", it would be
       // waste of memory, because we'll read and process this comment data
       // in other function anyway and we do not need them here now.
       Raw.Read(SIZEOF_MAINHEAD3-SIZEOF_SHORTBLOCKHEAD);
     }
     else
       Raw.Read(ShortBlock.HeadSize-SIZEOF_SHORTBLOCKHEAD);
 
   NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize);
 
   switch(ShortBlock.HeaderType)
   {
     case HEAD_MAIN:
       MainHead.Reset();
       *(BaseBlock *)&MainHead=ShortBlock;
       MainHead.HighPosAV=Raw.Get2();
       MainHead.PosAV=Raw.Get4();
 
       Volume=(MainHead.Flags & MHD_VOLUME)!=0;
       Solid=(MainHead.Flags & MHD_SOLID)!=0;
       Locked=(MainHead.Flags & MHD_LOCK)!=0;
       Protected=(MainHead.Flags & MHD_PROTECT)!=0;
       Encrypted=(MainHead.Flags & MHD_PASSWORD)!=0;
       Signed=MainHead.PosAV!=0 || MainHead.HighPosAV!=0;
       MainHead.CommentInHeader=(MainHead.Flags & MHD_COMMENT)!=0;
     
       // Only for encrypted 3.0+ archives. 2.x archives did not have this
       // flag, so for non-encrypted archives, we'll set it later based on
       // file attributes.
       FirstVolume=(MainHead.Flags & MHD_FIRSTVOLUME)!=0;
 
       NewNumbering=(MainHead.Flags & MHD_NEWNUMBERING)!=0;
       break;
     case HEAD_FILE:
     case HEAD_SERVICE:
       {
         bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;
         FileHeader *hd=FileBlock ? &FileHead:&SubHead;
         hd->Reset();
 
         *(BaseBlock *)hd=ShortBlock;
 
         hd->SplitBefore=(hd->Flags & LHD_SPLIT_BEFORE)!=0;
         hd->SplitAfter=(hd->Flags & LHD_SPLIT_AFTER)!=0;
         hd->Encrypted=(hd->Flags & LHD_PASSWORD)!=0;
         hd->SaltSet=(hd->Flags & LHD_SALT)!=0;
         hd->Solid=FileBlock && (hd->Flags & LHD_SOLID)!=0;
         hd->SubBlock=!FileBlock && (hd->Flags & LHD_SOLID)!=0;
         hd->Dir=(hd->Flags & LHD_WINDOWMASK)==LHD_DIRECTORY;
         hd->WinSize=hd->Dir ? 0:0x10000<<((hd->Flags & LHD_WINDOWMASK)>>5);
         hd->CommentInHeader=(hd->Flags & LHD_COMMENT)!=0;
         hd->Version=(hd->Flags & LHD_VERSION)!=0;
         
         hd->DataSize=Raw.Get4();
         uint LowUnpSize=Raw.Get4();
         hd->HostOS=Raw.Get1();
 
         hd->FileHash.Type=HASH_CRC32;
         hd->FileHash.CRC32=Raw.Get4();
 
         uint FileTime=Raw.Get4();
         hd->UnpVer=Raw.Get1();
         hd->Method=Raw.Get1()-0x30;
         size_t NameSize=Raw.Get2();
         hd->FileAttr=Raw.Get4();
 
         hd->CryptMethod=CRYPT_NONE;
         if (hd->Encrypted)
           switch(hd->UnpVer)
           {
             case 13: hd->CryptMethod=CRYPT_RAR13; break;
             case 15: hd->CryptMethod=CRYPT_RAR15; break;
             case 20: 
             case 26: hd->CryptMethod=CRYPT_RAR20; break;
             default: hd->CryptMethod=CRYPT_RAR30; break;
           }
 
         hd->HSType=HSYS_UNKNOWN;
         if (hd->HostOS==HOST_UNIX || hd->HostOS==HOST_BEOS)
           hd->HSType=HSYS_UNIX;
         else
           if (hd->HostOS<HOST_MAX)
             hd->HSType=HSYS_WINDOWS;
 
         hd->RedirType=FSREDIR_NONE;
 
         // RAR 4.x Unix symlink.
         if (hd->HostOS==HOST_UNIX && (hd->FileAttr & 0xF000)==0xA000)
         {
           hd->RedirType=FSREDIR_UNIXSYMLINK;
           *hd->RedirName=0;
         }
 
         hd->Inherited=!FileBlock && (hd->SubFlags & SUBHEAD_FLAGS_INHERITED)!=0;
         
         hd->LargeFile=(hd->Flags & LHD_LARGE)!=0;
 
         uint HighPackSize,HighUnpSize;
         if (hd->LargeFile)
         {
           HighPackSize=Raw.Get4();
           HighUnpSize=Raw.Get4();
           hd->UnknownUnpSize=(LowUnpSize==0xffffffff && HighUnpSize==0xffffffff);
         }
         else 
         {
           HighPackSize=HighUnpSize=0;
           // UnpSize equal to 0xffffffff without LHD_LARGE flag indicates
           // that we do not know the unpacked file size and must unpack it
           // until we find the end of file marker in compressed data.
           hd->UnknownUnpSize=(LowUnpSize==0xffffffff);
         }
-        hd->PackSize=UINT32TO64(HighPackSize,hd->DataSize);
-        hd->UnpSize=UINT32TO64(HighUnpSize,LowUnpSize);
+        hd->PackSize=INT32TO64(HighPackSize,hd->DataSize);
+        hd->UnpSize=INT32TO64(HighUnpSize,LowUnpSize);
         if (hd->UnknownUnpSize)
           hd->UnpSize=INT64NDF;
 
         char FileName[NM*4];
         size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);
         Raw.GetB((byte *)FileName,ReadNameSize);
         FileName[ReadNameSize]=0;
 
         if (FileBlock)
         {
           *hd->FileName=0;
           if ((hd->Flags & LHD_UNICODE)!=0)
           {
             EncodeFileName NameCoder;
             size_t Length=strlen(FileName);
             Length++;
             if (ReadNameSize>Length)
               NameCoder.Decode(FileName,(byte *)FileName+Length,
                                ReadNameSize-Length,hd->FileName,
                                ASIZE(hd->FileName));
           }
 
           if (*hd->FileName==0)
             ArcCharToWide(FileName,hd->FileName,ASIZE(hd->FileName),ACTW_OEM);
 
 #ifndef SFX_MODULE
           ConvertNameCase(hd->FileName);
 #endif
           ConvertFileHeader(hd);
         }
         else
         {
           CharToWide(FileName,hd->FileName,ASIZE(hd->FileName));
 
           // Calculate the size of optional data.
           int DataSize=int(hd->HeadSize-NameSize-SIZEOF_FILEHEAD3);
           if ((hd->Flags & LHD_SALT)!=0)
             DataSize-=SIZE_SALT30;
 
           if (DataSize>0)
           {
             // Here we read optional additional fields for subheaders.
             // They are stored after the file name and before salt.
             hd->SubData.Alloc(DataSize);
             Raw.GetB(&hd->SubData[0],DataSize);
             if (hd->CmpName(SUBHEAD_TYPE_RR))
             {
               byte *D=&hd->SubData[8];
               RecoverySize=D[0]+((uint)D[1]<<8)+((uint)D[2]<<16)+((uint)D[3]<<24);
               RecoverySize*=512; // Sectors to size.
               int64 CurPos=Tell();
               RecoveryPercent=ToPercent(RecoverySize,CurPos);
               // Round fractional percent exceeding .5 to upper value.
-              if ((int)ToPercent(RecoverySize+CurPos/200,CurPos)>RecoveryPercent)
+              if (ToPercent(RecoverySize+CurPos/200,CurPos)>RecoveryPercent)
                 RecoveryPercent++;
             }
           }
 
           if (hd->CmpName(SUBHEAD_TYPE_CMT))
             MainComment=true;
         }
         if ((hd->Flags & LHD_SALT)!=0)
           Raw.GetB(hd->Salt,SIZE_SALT30);
         hd->mtime.SetDos(FileTime);
         if ((hd->Flags & LHD_EXTTIME)!=0)
         {
           ushort Flags=Raw.Get2();
           RarTime *tbl[4];
           tbl[0]=&FileHead.mtime;
           tbl[1]=&FileHead.ctime;
           tbl[2]=&FileHead.atime;
           tbl[3]=NULL; // Archive time is not used now.
           for (int I=0;I<4;I++)
           {
             RarTime *CurTime=tbl[I];
             uint rmode=Flags>>(3-I)*4;
             if ((rmode & 8)==0 || CurTime==NULL)
               continue;
             if (I!=0)
             {
               uint DosTime=Raw.Get4();
               CurTime->SetDos(DosTime);
             }
             RarLocalTime rlt;
             CurTime->GetLocal(&rlt);
             if (rmode & 4)
               rlt.Second++;
             rlt.Reminder=0;
             int count=rmode&3;
             for (int J=0;J<count;J++)
             {
               byte CurByte=Raw.Get1();
               rlt.Reminder|=(((uint)CurByte)<<((J+3-count)*8));
             }
             // Convert from 100ns RAR precision to REMINDER_PRECISION.
             rlt.Reminder*=RarTime::REMINDER_PRECISION/10000000;
             CurTime->SetLocal(&rlt);
           }
         }
-        NextBlockPos+=hd->PackSize;
+        // Set to 0 in case of overflow, so end of ReadHeader cares about it.
+        NextBlockPos=SafeAdd(NextBlockPos,hd->PackSize,0);
+
         bool CRCProcessedOnly=hd->CommentInHeader;
         ushort HeaderCRC=Raw.GetCRC15(CRCProcessedOnly);
         if (hd->HeadCRC!=HeaderCRC)
         {
           BrokenHeader=true;
           ErrHandler.SetErrorCode(RARX_WARNING);
 
           // If we have a broken encrypted header, we do not need to display
           // the error message here, because it will be displayed for such
           // headers later in this function. Also such headers are unlikely
           // to have anything sensible in file name field, so it is useless
           // to display the file name.
           if (!Decrypt)
             uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);
         }
       }
       break;
     case HEAD_ENDARC:
       *(BaseBlock *)&EndArcHead=ShortBlock;
       EndArcHead.NextVolume=(EndArcHead.Flags & EARC_NEXT_VOLUME)!=0;
       EndArcHead.DataCRC=(EndArcHead.Flags & EARC_DATACRC)!=0;
       EndArcHead.RevSpace=(EndArcHead.Flags & EARC_REVSPACE)!=0;
       EndArcHead.StoreVolNumber=(EndArcHead.Flags & EARC_VOLNUMBER)!=0;
       if (EndArcHead.DataCRC)
         EndArcHead.ArcDataCRC=Raw.Get4();
       if (EndArcHead.StoreVolNumber)
         VolNumber=EndArcHead.VolNumber=Raw.Get2();
       break;
 #ifndef SFX_MODULE
     case HEAD3_CMT:
       *(BaseBlock *)&CommHead=ShortBlock;
       CommHead.UnpSize=Raw.Get2();
       CommHead.UnpVer=Raw.Get1();
       CommHead.Method=Raw.Get1();
       CommHead.CommCRC=Raw.Get2();
       break;
     case HEAD3_SIGN:
       *(BaseBlock *)&SignHead=ShortBlock;
       SignHead.CreationTime=Raw.Get4();
       SignHead.ArcNameSize=Raw.Get2();
       SignHead.UserNameSize=Raw.Get2();
       break;
     case HEAD3_AV:
       *(BaseBlock *)&AVHead=ShortBlock;
       AVHead.UnpVer=Raw.Get1();
       AVHead.Method=Raw.Get1();
       AVHead.AVVer=Raw.Get1();
       AVHead.AVInfoCRC=Raw.Get4();
       break;
     case HEAD3_PROTECT:
       *(BaseBlock *)&ProtectHead=ShortBlock;
       ProtectHead.DataSize=Raw.Get4();
       ProtectHead.Version=Raw.Get1();
       ProtectHead.RecSectors=Raw.Get2();
       ProtectHead.TotalBlocks=Raw.Get4();
       Raw.GetB(ProtectHead.Mark,8);
       NextBlockPos+=ProtectHead.DataSize;
       RecoverySize=ProtectHead.RecSectors*512;
       break;
     case HEAD3_OLDSERVICE:
       *(BaseBlock *)&SubBlockHead=ShortBlock;
       SubBlockHead.DataSize=Raw.Get4();
       NextBlockPos+=SubBlockHead.DataSize;
       SubBlockHead.SubType=Raw.Get2();
       SubBlockHead.Level=Raw.Get1();
       switch(SubBlockHead.SubType)
       {
         case UO_HEAD:
           *(SubBlockHeader *)&UOHead=SubBlockHead;
           UOHead.OwnerNameSize=Raw.Get2();
           UOHead.GroupNameSize=Raw.Get2();
           if (UOHead.OwnerNameSize>=ASIZE(UOHead.OwnerName))
             UOHead.OwnerNameSize=ASIZE(UOHead.OwnerName)-1;
           if (UOHead.GroupNameSize>=ASIZE(UOHead.GroupName))
             UOHead.GroupNameSize=ASIZE(UOHead.GroupName)-1;
           Raw.GetB(UOHead.OwnerName,UOHead.OwnerNameSize);
           Raw.GetB(UOHead.GroupName,UOHead.GroupNameSize);
           UOHead.OwnerName[UOHead.OwnerNameSize]=0;
           UOHead.GroupName[UOHead.GroupNameSize]=0;
           break;
         case MAC_HEAD:
           *(SubBlockHeader *)&MACHead=SubBlockHead;
           MACHead.fileType=Raw.Get4();
           MACHead.fileCreator=Raw.Get4();
           break;
         case EA_HEAD:
         case BEEA_HEAD:
         case NTACL_HEAD:
           *(SubBlockHeader *)&EAHead=SubBlockHead;
           EAHead.UnpSize=Raw.Get4();
           EAHead.UnpVer=Raw.Get1();
           EAHead.Method=Raw.Get1();
           EAHead.EACRC=Raw.Get4();
           break;
         case STREAM_HEAD:
           *(SubBlockHeader *)&StreamHead=SubBlockHead;
           StreamHead.UnpSize=Raw.Get4();
           StreamHead.UnpVer=Raw.Get1();
           StreamHead.Method=Raw.Get1();
           StreamHead.StreamCRC=Raw.Get4();
           StreamHead.StreamNameSize=Raw.Get2();
           if (StreamHead.StreamNameSize>=ASIZE(StreamHead.StreamName))
             StreamHead.StreamNameSize=ASIZE(StreamHead.StreamName)-1;
           Raw.GetB(StreamHead.StreamName,StreamHead.StreamNameSize);
           StreamHead.StreamName[StreamHead.StreamNameSize]=0;
           break;
       }
       break;
 #endif
     default:
       if (ShortBlock.Flags & LONG_BLOCK)
         NextBlockPos+=Raw.Get4();
       break;
   }
   
   ushort HeaderCRC=Raw.GetCRC15(false);
 
   // Old AV header does not have header CRC properly set.
   if (ShortBlock.HeadCRC!=HeaderCRC && ShortBlock.HeaderType!=HEAD3_SIGN &&
       ShortBlock.HeaderType!=HEAD3_AV)
   {
     bool Recovered=false;
     if (ShortBlock.HeaderType==HEAD_ENDARC && EndArcHead.RevSpace)
     {
       // Last 7 bytes of recovered volume can contain zeroes, because
       // REV files store its own information (volume number, etc.) here.
       SaveFilePos SavePos(*this);
       int64 Length=Tell();
       Seek(Length-7,SEEK_SET);
       Recovered=true;
       for (int J=0;J<7;J++)
         if (GetByte()!=0)
           Recovered=false;
     }
     if (!Recovered)
     {
       BrokenHeader=true;
       ErrHandler.SetErrorCode(RARX_CRC);
 
       if (Decrypt)
       {
         uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);
         FailedHeaderDecryption=true;
         return 0;
       }
     }
   }
 
-  if (NextBlockPos<=CurBlockPos)
-  {
-    BrokenHeaderMsg();
-    return 0;
-  }
-
   return Raw.Size();
 }
 
@@ -559,329 +573,326 @@ size_t Archive::ReadHeader15()
 size_t Archive::ReadHeader50()
 {
   RawRead Raw(this);
 
   bool Decrypt=Encrypted && CurBlockPos>(int64)SFXSize+SIZEOF_MARKHEAD5;
 
   if (Decrypt)
   {
 #if defined(RAR_NOCRYPT)
     return 0;
 #else
 
     byte HeadersInitV[SIZE_INITV];
     if (Read(HeadersInitV,SIZE_INITV)!=SIZE_INITV)
     {
       UnexpEndArcMsg();
       return 0;
     }
 
     while (true) // Repeat the password prompt for wrong passwords.
     {
       RequestArcPassword();
 
       byte PswCheck[SIZE_PSWCHECK];
       HeadersCrypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,CryptHead.Salt,HeadersInitV,CryptHead.Lg2Count,NULL,PswCheck);
       // Verify password validity.
       if (CryptHead.UsePswCheck && memcmp(PswCheck,CryptHead.PswCheck,SIZE_PSWCHECK)!=0)
       {
         // This message is used by Android GUI and Windows GUI and SFX to
         // reset cached passwords. Update appropriate code if changed.
         uiMsg(UIWAIT_BADPSW,FileName);
 
         Cmd->Password.Clean();
         continue;
       }
       break;
     }
 
     Raw.SetCrypt(&HeadersCrypt);
 #endif
   }
 
   // Header size must not occupy more than 3 variable length integer bytes
   // resulting in 2 MB maximum header size, so here we read 4 byte CRC32
   // followed by 3 bytes or less of header size.
   const size_t FirstReadSize=7; // Smallest possible block size.
   if (Raw.Read(FirstReadSize)<FirstReadSize)
   {
     UnexpEndArcMsg();
     return 0;
   }
 
   ShortBlock.Reset();
   ShortBlock.HeadCRC=Raw.Get4();
   uint SizeBytes=Raw.GetVSize(4);
   uint64 BlockSize=Raw.GetV();
 
   if (BlockSize==0 || SizeBytes==0)
   {
     BrokenHeaderMsg();
     return 0;
   }
 
   int SizeToRead=int(BlockSize);
   SizeToRead-=FirstReadSize-SizeBytes-4; // Adjust overread size bytes if any.
   uint HeaderSize=4+SizeBytes+(uint)BlockSize;
 
   if (SizeToRead<0 || HeaderSize<SIZEOF_SHORTBLOCKHEAD5)
   {
     BrokenHeaderMsg();
     return 0;
   }
   
   Raw.Read(SizeToRead);
 
   if (Raw.Size()<HeaderSize)
   {
     UnexpEndArcMsg();
     return 0;
   }
 
   uint HeaderCRC=Raw.GetCRC50();
 
   ShortBlock.HeaderType=(HEADER_TYPE)Raw.GetV();
   ShortBlock.Flags=(uint)Raw.GetV();
   ShortBlock.SkipIfUnknown=(ShortBlock.Flags & HFL_SKIPIFUNKNOWN)!=0;
   ShortBlock.HeadSize=HeaderSize;
 
   CurHeaderType=ShortBlock.HeaderType;
 
   bool BadCRC=(ShortBlock.HeadCRC!=HeaderCRC);
   if (BadCRC)
   {
     BrokenHeaderMsg(); // Report, but attempt to process.
 
     BrokenHeader=true;
     ErrHandler.SetErrorCode(RARX_CRC);
 
     if (Decrypt)
     {
       uiMsg(UIERROR_CHECKSUMENC,FileName,FileName);
       FailedHeaderDecryption=true;
       return 0;
     }
   }
   
   uint64 ExtraSize=0;
   if ((ShortBlock.Flags & HFL_EXTRA)!=0)
   {
     ExtraSize=Raw.GetV();
     if (ExtraSize>=ShortBlock.HeadSize)
     {
       BrokenHeaderMsg();
       return 0;
     }
   }
 
   uint64 DataSize=0;
   if ((ShortBlock.Flags & HFL_DATA)!=0)
     DataSize=Raw.GetV();
 
-  NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize)+DataSize;
+  NextBlockPos=CurBlockPos+FullHeaderSize(ShortBlock.HeadSize);
+  // Set to 0 in case of overflow, so end of ReadHeader cares about it.
+  NextBlockPos=SafeAdd(NextBlockPos,DataSize,0);
 
   switch(ShortBlock.HeaderType)
   {
     case HEAD_CRYPT:
       {
         *(BaseBlock *)&CryptHead=ShortBlock;
         uint CryptVersion=(uint)Raw.GetV();
         if (CryptVersion>CRYPT_VERSION)
         {
           UnkEncVerMsg(FileName);
           return 0;
         }
         uint EncFlags=(uint)Raw.GetV();
         CryptHead.UsePswCheck=(EncFlags & CHFL_CRYPT_PSWCHECK)!=0;
         CryptHead.Lg2Count=Raw.Get1();
         if (CryptHead.Lg2Count>CRYPT5_KDF_LG2_COUNT_MAX)
         {
           UnkEncVerMsg(FileName);
           return 0;
         }
         Raw.GetB(CryptHead.Salt,SIZE_SALT50);
         if (CryptHead.UsePswCheck)
         {
           Raw.GetB(CryptHead.PswCheck,SIZE_PSWCHECK);
 
           byte csum[SIZE_PSWCHECK_CSUM];
           Raw.GetB(csum,SIZE_PSWCHECK_CSUM);
 
           sha256_context ctx;
           sha256_init(&ctx);
           sha256_process(&ctx, CryptHead.PswCheck, SIZE_PSWCHECK);
 
           byte Digest[SHA256_DIGEST_SIZE];
           sha256_done(&ctx, Digest);
 
           CryptHead.UsePswCheck=memcmp(csum,Digest,SIZE_PSWCHECK_CSUM)==0;
         }
         Encrypted=true;
       }
       break;
     case HEAD_MAIN:
       {
         MainHead.Reset();
         *(BaseBlock *)&MainHead=ShortBlock;
         uint ArcFlags=(uint)Raw.GetV();
 
         Volume=(ArcFlags & MHFL_VOLUME)!=0;
         Solid=(ArcFlags & MHFL_SOLID)!=0;
         Locked=(ArcFlags & MHFL_LOCK)!=0;
         Protected=(ArcFlags & MHFL_PROTECT)!=0;
         Signed=false;
         NewNumbering=true;
 
         if ((ArcFlags & MHFL_VOLNUMBER)!=0)
           VolNumber=(uint)Raw.GetV();
         else
           VolNumber=0;
         FirstVolume=Volume && VolNumber==0;
 
         if (ExtraSize!=0)
           ProcessExtra50(&Raw,(size_t)ExtraSize,&MainHead);
 
 #ifdef USE_QOPEN
         if (MainHead.Locator && MainHead.QOpenOffset>0 && Cmd->QOpenMode!=QOPEN_NONE)
         {
           // We seek to QO block in the end of archive when processing
           // QOpen.Load, so we need to preserve current block positions
           // to not break normal archive processing by calling function.
           int64 SaveCurBlockPos=CurBlockPos,SaveNextBlockPos=NextBlockPos;
           HEADER_TYPE SaveCurHeaderType=CurHeaderType;
           
           QOpen.Init(this,false);
           QOpen.Load(MainHead.QOpenOffset);
 
           CurBlockPos=SaveCurBlockPos;
           NextBlockPos=SaveNextBlockPos;
           CurHeaderType=SaveCurHeaderType;
         }
 #endif
       }
       break;
     case HEAD_FILE:
     case HEAD_SERVICE:
       {
         FileHeader *hd=ShortBlock.HeaderType==HEAD_FILE ? &FileHead:&SubHead;
         hd->Reset();
         *(BaseBlock *)hd=ShortBlock;
 
         bool FileBlock=ShortBlock.HeaderType==HEAD_FILE;
 
         hd->LargeFile=true;
 
         hd->PackSize=DataSize;
         hd->FileFlags=(uint)Raw.GetV();
         hd->UnpSize=Raw.GetV();
         
         hd->UnknownUnpSize=(hd->FileFlags & FHFL_UNPUNKNOWN)!=0;
         if (hd->UnknownUnpSize)
           hd->UnpSize=INT64NDF;
 
         hd->MaxSize=Max(hd->PackSize,hd->UnpSize);
         hd->FileAttr=(uint)Raw.GetV();
         if ((hd->FileFlags & FHFL_UTIME)!=0)
           hd->mtime.SetUnix((time_t)Raw.Get4());
 
         hd->FileHash.Type=HASH_NONE;
         if ((hd->FileFlags & FHFL_CRC32)!=0)
         {
           hd->FileHash.Type=HASH_CRC32;
           hd->FileHash.CRC32=Raw.Get4();
         }
 
         hd->RedirType=FSREDIR_NONE;
 
         uint CompInfo=(uint)Raw.GetV();
         hd->Method=(CompInfo>>7) & 7;
 
         // "+ 50" to not mix with old RAR format algorithms. For example,
         // we may need to use the compression algorithm 15 in the future,
         // but it was already used in RAR 1.5 and Unpack needs to distinguish
         // them.
         hd->UnpVer=(CompInfo & 0x3f) + 50;
 
         hd->HostOS=(byte)Raw.GetV();
         size_t NameSize=(size_t)Raw.GetV();
         hd->Inherited=(ShortBlock.Flags & HFL_INHERITED)!=0;
 
         hd->HSType=HSYS_UNKNOWN;
         if (hd->HostOS==HOST5_UNIX)
           hd->HSType=HSYS_UNIX;
         else
           if (hd->HostOS==HOST5_WINDOWS)
             hd->HSType=HSYS_WINDOWS;
 
         hd->SplitBefore=(hd->Flags & HFL_SPLITBEFORE)!=0;
         hd->SplitAfter=(hd->Flags & HFL_SPLITAFTER)!=0;
         hd->SubBlock=(hd->Flags & HFL_CHILD)!=0;
         hd->Solid=FileBlock && (CompInfo & FCI_SOLID)!=0;
         hd->Dir=(hd->FileFlags & FHFL_DIRECTORY)!=0;
         hd->WinSize=hd->Dir ? 0:size_t(0x20000)<<((CompInfo>>10)&0xf);
 
         hd->CryptMethod=hd->Encrypted ? CRYPT_RAR50:CRYPT_NONE;
 
         char FileName[NM*4];
         size_t ReadNameSize=Min(NameSize,ASIZE(FileName)-1);
         Raw.GetB((byte *)FileName,ReadNameSize);
         FileName[ReadNameSize]=0;
 
         UtfToWide(FileName,hd->FileName,ASIZE(hd->FileName));
 
         // Should do it before converting names, because extra fields can
         // affect name processing, like in case of NTFS streams.
         if (ExtraSize!=0)
           ProcessExtra50(&Raw,(size_t)ExtraSize,hd);
 
         if (FileBlock)
         {
 #ifndef SFX_MODULE
           ConvertNameCase(hd->FileName);
 #endif
           ConvertFileHeader(hd);
         }
 
         if (!FileBlock && hd->CmpName(SUBHEAD_TYPE_CMT))
           MainComment=true;
 
 #if 0
         // For RAR5 format we read the user specified recovery percent here.
         // It would be useful to do it for shell extension too, so we display
         // the correct recovery record size in archive properties. But then
         // we would need to include the entire recovery record processing
         // code to shell extension, which is not done now.
         if (!FileBlock && hd->CmpName(SUBHEAD_TYPE_RR) && hd->SubData.Size()>0)
         {
           RecoveryPercent=hd->SubData[0];
           RSBlockHeader Header;
           GetRRInfo(this,&Header);
           RecoverySize=Header.RecSectionSize*Header.RecCount;
         }
 #endif
           
         if (BadCRC) // Add the file name to broken header message displayed above.
           uiMsg(UIERROR_FHEADERBROKEN,Archive::FileName,hd->FileName);
       }
       break;
     case HEAD_ENDARC:
       {
         *(BaseBlock *)&EndArcHead=ShortBlock;
         uint ArcFlags=(uint)Raw.GetV();
         EndArcHead.NextVolume=(ArcFlags & EHFL_NEXTVOLUME)!=0;
         EndArcHead.StoreVolNumber=false;
         EndArcHead.DataCRC=false;
         EndArcHead.RevSpace=false;
       }
       break;
   }
 
-  if (NextBlockPos<=CurBlockPos)
-  {
-    BrokenHeaderMsg();
-    return 0;
-  }
   return Raw.Size();
 }
 
 
 #if !defined(RAR_NOCRYPT)
@@ -932,309 +943,312 @@ void Archive::RequestArcPassword()
 void Archive::ProcessExtra50(RawRead *Raw,size_t ExtraSize,BaseBlock *bb)
 {
   // Read extra data from the end of block skipping any fields before it.
   size_t ExtraStart=Raw->Size()-ExtraSize;
   if (ExtraStart<Raw->GetPos())
     return;
   Raw->SetPos(ExtraStart);
   while (Raw->DataLeft()>=2)
   {
     int64 FieldSize=Raw->GetV(); // Needs to be signed for check below and can be negative.
     if (FieldSize<=0 || Raw->DataLeft()==0 || FieldSize>(int64)Raw->DataLeft())
       break;
     size_t NextPos=size_t(Raw->GetPos()+FieldSize);
     uint64 FieldType=Raw->GetV();
 
     FieldSize=int64(NextPos-Raw->GetPos()); // Field size without size and type fields.
 
-    if (FieldSize<0) // FieldType longer than field itself.
+    if (FieldSize<0) // FieldType is longer than expected extra field size.
       break;
 
     if (bb->HeaderType==HEAD_MAIN)
     {
       MainHeader *hd=(MainHeader *)bb;
       if (FieldType==MHEXTRA_LOCATOR)
       {
         hd->Locator=true;
         uint Flags=(uint)Raw->GetV();
         if ((Flags & MHEXTRA_LOCATOR_QLIST)!=0)
         {
           uint64 Offset=Raw->GetV();
           if (Offset!=0) // 0 means that reserved space was not enough to write the offset.
             hd->QOpenOffset=Offset+CurBlockPos;
         }
         if ((Flags & MHEXTRA_LOCATOR_RR)!=0)
         {
           uint64 Offset=Raw->GetV();
           if (Offset!=0) // 0 means that reserved space was not enough to write the offset.
             hd->RROffset=Offset+CurBlockPos;
         }
       }
     }
 
     if (bb->HeaderType==HEAD_FILE || bb->HeaderType==HEAD_SERVICE)
     {
       FileHeader *hd=(FileHeader *)bb;
       switch(FieldType)
       {
         case FHEXTRA_CRYPT:
           {
             FileHeader *hd=(FileHeader *)bb;
             uint EncVersion=(uint)Raw->GetV();
             if (EncVersion > CRYPT_VERSION)
               UnkEncVerMsg(hd->FileName);
             else
             {
               uint Flags=(uint)Raw->GetV();
               hd->UsePswCheck=(Flags & FHEXTRA_CRYPT_PSWCHECK)!=0;
               hd->UseHashKey=(Flags & FHEXTRA_CRYPT_HASHMAC)!=0;
               hd->Lg2Count=Raw->Get1();
               if (hd->Lg2Count>CRYPT5_KDF_LG2_COUNT_MAX)
                 UnkEncVerMsg(hd->FileName);
               Raw->GetB(hd->Salt,SIZE_SALT50);
               Raw->GetB(hd->InitV,SIZE_INITV);
               if (hd->UsePswCheck)
               {
                 Raw->GetB(hd->PswCheck,SIZE_PSWCHECK);
 
                 // It is important to know if password check data is valid.
                 // If it is damaged and header CRC32 fails to detect it,
                 // archiver would refuse to decompress a possibly valid file.
                 // Since we want to be sure distinguishing a wrong password
                 // or corrupt file data, we use 64-bit password check data
                 // and to control its validity we use 32 bits of password
                 // check data SHA-256 additionally to 32-bit header CRC32.
                 byte csum[SIZE_PSWCHECK_CSUM];
                 Raw->GetB(csum,SIZE_PSWCHECK_CSUM);
 
                 sha256_context ctx;
                 sha256_init(&ctx);
                 sha256_process(&ctx, hd->PswCheck, SIZE_PSWCHECK);
 
                 byte Digest[SHA256_DIGEST_SIZE];
                 sha256_done(&ctx, Digest);
 
                 hd->UsePswCheck=memcmp(csum,Digest,SIZE_PSWCHECK_CSUM)==0;
 
                 // RAR 5.21 and earlier set PswCheck field in service records to 0
                 // even if UsePswCheck was present.
                 if (bb->HeaderType==HEAD_SERVICE && memcmp(hd->PswCheck,"\0\0\0\0\0\0\0\0",SIZE_PSWCHECK)==0)
                   hd->UsePswCheck=0;
               }
               hd->SaltSet=true;
               hd->CryptMethod=CRYPT_RAR50;
               hd->Encrypted=true;
             }
           }
           break;
         case FHEXTRA_HASH:
           {
             FileHeader *hd=(FileHeader *)bb;
             uint Type=(uint)Raw->GetV();
             if (Type==FHEXTRA_HASH_BLAKE2)
             {
               hd->FileHash.Type=HASH_BLAKE2;
               Raw->GetB(hd->FileHash.Digest,BLAKE2_DIGEST_SIZE);
             }
           }
           break;
         case FHEXTRA_HTIME:
           if (FieldSize>=5)
           {
             byte Flags=(byte)Raw->GetV();
             bool UnixTime=(Flags & FHEXTRA_HTIME_UNIXTIME)!=0;
             if ((Flags & FHEXTRA_HTIME_MTIME)!=0)
               if (UnixTime)
                 hd->mtime.SetUnix(Raw->Get4());
               else
                 hd->mtime.SetWin(Raw->Get8());
             if ((Flags & FHEXTRA_HTIME_CTIME)!=0)
               if (UnixTime)
                 hd->ctime.SetUnix(Raw->Get4());
               else
                 hd->ctime.SetWin(Raw->Get8());
             if ((Flags & FHEXTRA_HTIME_ATIME)!=0)
               if (UnixTime)
                 hd->atime.SetUnix((time_t)Raw->Get4());
               else
                 hd->atime.SetWin(Raw->Get8());
             if (UnixTime && (Flags & FHEXTRA_HTIME_UNIX_NS)!=0) // Add nanoseconds.
             {
               uint ns;
               if ((Flags & FHEXTRA_HTIME_MTIME)!=0 && (ns=(Raw->Get4() & 0x3fffffff))<1000000000)
                 hd->mtime.Adjust(ns);
               if ((Flags & FHEXTRA_HTIME_CTIME)!=0 && (ns=(Raw->Get4() & 0x3fffffff))<1000000000)
                 hd->ctime.Adjust(ns);
               if ((Flags & FHEXTRA_HTIME_ATIME)!=0 && (ns=(Raw->Get4() & 0x3fffffff))<1000000000)
                 hd->atime.Adjust(ns);
             }
           }
           break;
         case FHEXTRA_VERSION:
           if (FieldSize>=1)
           {
             Raw->GetV(); // Skip flags field.
             uint Version=(uint)Raw->GetV();
             if (Version!=0)
             {
               hd->Version=true;
 
               wchar VerText[20];
               swprintf(VerText,ASIZE(VerText),L";%u",Version);
               wcsncatz(FileHead.FileName,VerText,ASIZE(FileHead.FileName));
             }
           }
           break;
         case FHEXTRA_REDIR:
           {
             hd->RedirType=(FILE_SYSTEM_REDIRECT)Raw->GetV();
             uint Flags=(uint)Raw->GetV();
             hd->DirTarget=(Flags & FHEXTRA_REDIR_DIR)!=0;
             size_t NameSize=(size_t)Raw->GetV();
 
             char UtfName[NM*4];
             *UtfName=0;
             if (NameSize<ASIZE(UtfName)-1)
             {
               Raw->GetB(UtfName,NameSize);
               UtfName[NameSize]=0;
             }
 #ifdef _WIN_ALL
             UnixSlashToDos(UtfName,UtfName,ASIZE(UtfName));
 #endif
             UtfToWide(UtfName,hd->RedirName,ASIZE(hd->RedirName));
           }
           break;
         case FHEXTRA_UOWNER:
           {
             uint Flags=(uint)Raw->GetV();
             hd->UnixOwnerNumeric=(Flags & FHEXTRA_UOWNER_NUMUID)!=0;
             hd->UnixGroupNumeric=(Flags & FHEXTRA_UOWNER_NUMGID)!=0;
             *hd->UnixOwnerName=*hd->UnixGroupName=0;
             if ((Flags & FHEXTRA_UOWNER_UNAME)!=0)
             {
               size_t Length=(size_t)Raw->GetV();
               Length=Min(Length,ASIZE(hd->UnixOwnerName)-1);
               Raw->GetB(hd->UnixOwnerName,Length);
               hd->UnixOwnerName[Length]=0;
             }
             if ((Flags & FHEXTRA_UOWNER_GNAME)!=0)
             {
               size_t Length=(size_t)Raw->GetV();
               Length=Min(Length,ASIZE(hd->UnixGroupName)-1);
               Raw->GetB(hd->UnixGroupName,Length);
               hd->UnixGroupName[Length]=0;
             }
 #ifdef _UNIX
             if (hd->UnixOwnerNumeric)
               hd->UnixOwnerID=(uid_t)Raw->GetV();
             if (hd->UnixGroupNumeric)
               hd->UnixGroupID=(gid_t)Raw->GetV();
 #else
             // Need these fields in Windows too for 'list' command,
             // but uid_t and gid_t are not defined.
             if (hd->UnixOwnerNumeric)
               hd->UnixOwnerID=(uint)Raw->GetV();
             if (hd->UnixGroupNumeric)
               hd->UnixGroupID=(uint)Raw->GetV();
 #endif
             hd->UnixOwnerSet=true;
           }
           break;
         case FHEXTRA_SUBDATA:
           {
             // RAR 5.21 and earlier set FHEXTRA_SUBDATA size to 1 less than
             // required. It did not hurt extraction, because UnRAR 5.21
             // and earlier ignored this field and set FieldSize as data left
             // in entire extra area. But now we set the correct field size
             // and set FieldSize based on the actual extra record size,
             // so we need to adjust it for those older archives here.
             // FHEXTRA_SUBDATA in those archives always belongs to HEAD_SERVICE
             // and always is last in extra area. So since its size is by 1
             // less than needed, we always have 1 byte left in extra area,
             // which fact we use here to detect such archives.
             if (bb->HeaderType==HEAD_SERVICE && Raw->Size()-NextPos==1)
               FieldSize++;
 
             // We cannot allocate too much memory here, because above
             // we check FieldSize againt Raw size and we control that Raw size
             // is sensible when reading headers.
             hd->SubData.Alloc((size_t)FieldSize);
             Raw->GetB(hd->SubData.Addr(0),(size_t)FieldSize);
           }
           break;
       }
     }
 
     Raw->SetPos(NextPos);
   }
 }
 
 
 #ifndef SFX_MODULE
 size_t Archive::ReadHeader14()
 {
   RawRead Raw(this);
   if (CurBlockPos<=(int64)SFXSize)
   {
     Raw.Read(SIZEOF_MAINHEAD14);
     MainHead.Reset();
     byte Mark[4];
     Raw.GetB(Mark,4);
     uint HeadSize=Raw.Get2();
     byte Flags=Raw.Get1();
     NextBlockPos=CurBlockPos+HeadSize;
     CurHeaderType=HEAD_MAIN;
 
     Volume=(Flags & MHD_VOLUME)!=0;
     Solid=(Flags & MHD_SOLID)!=0;
     Locked=(Flags & MHD_LOCK)!=0;
     MainHead.CommentInHeader=(Flags & MHD_COMMENT)!=0;
     MainHead.PackComment=(Flags & MHD_PACK_COMMENT)!=0;
   }
   else
   {
     Raw.Read(SIZEOF_FILEHEAD14);
     FileHead.Reset();
 
     FileHead.HeaderType=HEAD_FILE;
     FileHead.DataSize=Raw.Get4();
     FileHead.UnpSize=Raw.Get4();
     FileHead.FileHash.Type=HASH_RAR14;
     FileHead.FileHash.CRC32=Raw.Get2();
     FileHead.HeadSize=Raw.Get2();
     uint FileTime=Raw.Get4();
     FileHead.FileAttr=Raw.Get1();
     FileHead.Flags=Raw.Get1()|LONG_BLOCK;
     FileHead.UnpVer=(Raw.Get1()==2) ? 13 : 10;
     size_t NameSize=Raw.Get1();
     FileHead.Method=Raw.Get1();
 
     FileHead.SplitBefore=(FileHead.Flags & LHD_SPLIT_BEFORE)!=0;
     FileHead.SplitAfter=(FileHead.Flags & LHD_SPLIT_AFTER)!=0;
     FileHead.Encrypted=(FileHead.Flags & LHD_PASSWORD)!=0;
     FileHead.CryptMethod=FileHead.Encrypted ? CRYPT_RAR13:CRYPT_NONE;
 
     FileHead.PackSize=FileHead.DataSize;
     FileHead.WinSize=0x10000;
 
+    FileHead.HostOS=HOST_MSDOS;
+    FileHead.HSType=HSYS_WINDOWS;
+
     FileHead.mtime.SetDos(FileTime);
 
     Raw.Read(NameSize);
 
     char FileName[NM];
     Raw.GetB((byte *)FileName,Min(NameSize,ASIZE(FileName)));
     FileName[NameSize]=0;
     IntToExt(FileName,FileName,ASIZE(FileName));
     CharToWide(FileName,FileHead.FileName,ASIZE(FileHead.FileName));
     ConvertNameCase(FileHead.FileName);
 
     if (Raw.Size()!=0)
       NextBlockPos=CurBlockPos+FileHead.HeadSize+FileHead.PackSize;
     CurHeaderType=HEAD_FILE;
   }
   return NextBlockPos>CurBlockPos ? Raw.Size() : 0;
 }
 #endif
 
 
 #ifndef SFX_MODULE
diff --git a/cmddata.cpp b/cmddata.cpp
index d8a9391..1b6da65 100644
--- a/cmddata.cpp
+++ b/cmddata.cpp
@@ -1361,16 +1361,16 @@ uint CommandData::GetExclAttr(const wchar *Str)
 #ifndef SFX_MODULE
 bool CommandData::CheckWinSize()
 {
   // Define 0x100000000 as macro to avoid troubles with older compilers.
-  const uint64 MaxDictSize=UINT32TO64(1,0);
+  const uint64 MaxDictSize=INT32TO64(1,0);
   // Limit the dictionary size to 4 GB.
   for (uint64 I=0x10000;I<=MaxDictSize;I*=2)
     if (WinSize==I)
       return true;
   WinSize=0x400000;
   return false;
 }
 #endif
 
 
 #ifndef SFX_MODULE
diff --git a/extract.cpp b/extract.cpp
index 31fba05..abdd928 100644
--- a/extract.cpp
+++ b/extract.cpp
@@ -99,126 +99,126 @@ void CmdExtract::ExtractArchiveInit(Archive &Arc)
 EXTRACT_ARC_CODE CmdExtract::ExtractArchive()
 {
   Archive Arc(Cmd);
   if (!Arc.WOpen(ArcName))
     return EXTRACT_ARC_NEXT;
 
   if (!Arc.IsArchive(true))
   {
 #if !defined(SFX_MODULE) && !defined(RARDLL)
     if (CmpExt(ArcName,L"rev"))
     {
       wchar FirstVolName[NM];
       VolNameToFirstName(ArcName,FirstVolName,ASIZE(FirstVolName),true);
 
       // If several volume names from same volume set are specified
       // and current volume is not first in set and first volume is present
       // and specified too, let's skip the current volume.
       if (wcsicomp(ArcName,FirstVolName)!=0 && FileExist(FirstVolName) &&
           Cmd->ArcNames.Search(FirstVolName,false))
         return EXTRACT_ARC_NEXT;
       RecVolumesTest(Cmd,NULL,ArcName);
       TotalFileCount++; // Suppress "No files to extract" message.
       return EXTRACT_ARC_NEXT;
     }
 #endif
 
     mprintf(St(MNotRAR),ArcName);
 
 #ifndef SFX_MODULE
     if (CmpExt(ArcName,L"rar"))
 #endif
       ErrHandler.SetErrorCode(RARX_WARNING);
     return EXTRACT_ARC_NEXT;
   }
 
   if (Arc.FailedHeaderDecryption) // Bad archive password.
     return EXTRACT_ARC_NEXT;
 
 #ifndef SFX_MODULE
   if (Arc.Volume && !Arc.FirstVolume)
   {
     wchar FirstVolName[NM];
     VolNameToFirstName(ArcName,FirstVolName,ASIZE(FirstVolName),Arc.NewNumbering);
 
     // If several volume names from same volume set are specified
     // and current volume is not first in set and first volume is present
     // and specified too, let's skip the current volume.
     if (wcsicomp(ArcName,FirstVolName)!=0 && FileExist(FirstVolName) &&
         Cmd->ArcNames.Search(FirstVolName,false))
       return EXTRACT_ARC_NEXT;
   }
 #endif
 
-  uint64 VolumeSetSize=0; // Total size of volumes after the current volume.
+  int64 VolumeSetSize=0; // Total size of volumes after the current volume.
 
   if (Arc.Volume)
   {
     // Calculate the total size of all accessible volumes.
     // This size is necessary to display the correct total progress indicator.
 
     wchar NextName[NM];
     wcscpy(NextName,Arc.FileName);
 
     while (true)
     {
       // First volume is already added to DataIO.TotalArcSize 
       // in initial TotalArcSize calculation in DoExtract.
       // So we skip it and start from second volume.
       NextVolumeName(NextName,ASIZE(NextName),!Arc.NewNumbering);
       FindData FD;
       if (FindFile::FastFind(NextName,&FD))
         VolumeSetSize+=FD.Size;
       else
         break;
     }
     DataIO.TotalArcSize+=VolumeSetSize;
   }
 
   ExtractArchiveInit(Arc);
 
   if (*Cmd->Command=='T' || *Cmd->Command=='I')
     Cmd->Test=true;
 
 
   if (*Cmd->Command=='I')
   {
     Cmd->DisablePercentage=true;
   }
   else
     uiStartArchiveExtract(!Cmd->Test,ArcName);
 
   Arc.ViewComment();
 
 
   while (1)
   {
     size_t Size=Arc.ReadHeader();
 
 
     bool Repeat=false;
     if (!ExtractCurrentFile(Arc,Size,Repeat))
       if (Repeat)
       {
         // If we started extraction from not first volume and need to
         // restart it from first, we must correct DataIO.TotalArcSize
         // for correct total progress display. We subtract the size
         // of current volume and all volumes after it and add the size
         // of new (first) volume.
         FindData OldArc,NewArc;
         if (FindFile::FastFind(Arc.FileName,&OldArc) &&
             FindFile::FastFind(ArcName,&NewArc))
           DataIO.TotalArcSize-=VolumeSetSize+OldArc.Size-NewArc.Size;
         return EXTRACT_ARC_REPEAT;
       }
       else
         break;
   }
 
 
 #if !defined(SFX_MODULE) && !defined(RARDLL)
   if (Cmd->Test && Arc.Volume)
     RecVolumesTest(Cmd,&Arc,ArcName);
 #endif
 
   return EXTRACT_ARC_NEXT;
 }
@@ -226,554 +226,556 @@ EXTRACT_ARC_CODE CmdExtract::ExtractArchive()
 
 bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
 {
-  // We can get negative sizes in corrupt archive and it is unacceptable
-  // for size comparisons in CmdExtract::UnstoreFile and ComprDataIO::UnpRead,
-  // where we cast sizes to size_t and can exceed another read or available
-  // size. We could fix it when reading an archive. But we prefer to do it
-  // here, because this function is called directly in unrar.dll, so we fix
-  // bad parameters passed to dll. Also we want to see real negative sizes
-  // in the listing of corrupt archive.
-//  if (Arc.FileHead.PackSize<0)
-//    Arc.FileHead.PackSize=0;
-  if (Arc.FileHead.UnpSize<0)
-    Arc.FileHead.UnpSize=0;
-
   wchar Command=Cmd->Command[0];
   if (HeaderSize==0)
     if (DataIO.UnpVolume)
     {
 #ifdef NOVOLUME
       return false;
 #else
       // Supposing we unpack an old RAR volume without the end of archive
       // record and last file is not split between volumes.
       if (!MergeArchive(Arc,&DataIO,false,Command))
       {
         ErrHandler.SetErrorCode(RARX_WARNING);
         return false;
       }
 #endif
     }
     else
       return false;
+
   HEADER_TYPE HeaderType=Arc.GetHeaderType();
   if (HeaderType!=HEAD_FILE)
   {
 #ifndef SFX_MODULE
     if (HeaderType==HEAD3_OLDSERVICE && PrevProcessed)
       SetExtraInfo20(Cmd,Arc,DestFileName);
 #endif
     if (HeaderType==HEAD_SERVICE && PrevProcessed)
       SetExtraInfo(Cmd,Arc,DestFileName);
     if (HeaderType==HEAD_ENDARC)
       if (Arc.EndArcHead.NextVolume)
       {
 #ifndef NOVOLUME
         if (!MergeArchive(Arc,&DataIO,false,Command))
         {
           ErrHandler.SetErrorCode(RARX_WARNING);
           return false;
         }
 #endif
         Arc.Seek(Arc.CurBlockPos,SEEK_SET);
         return true;
       }
       else
         return false;
     Arc.SeekToNext();
     return true;
   }
   PrevProcessed=false;
 
+  // We can get negative sizes in corrupt archive and it is unacceptable
+  // for size comparisons in ComprDataIO::UnpRead, where we cast sizes
+  // to size_t and can exceed another read or available size. We could fix it
+  // when reading an archive. But we prefer to do it here, because this
+  // function is called directly in unrar.dll, so we fix bad parameters
+  // passed to dll. Also we want to see real negative sizes in the listing
+  // of corrupt archive. To prevent uninitialized data access perform
+  // these checks after rejecting zero length and non-file headers above.
+  if (Arc.FileHead.PackSize<0)
+    Arc.FileHead.PackSize=0;
+  if (Arc.FileHead.UnpSize<0)
+    Arc.FileHead.UnpSize=0;
+
   if (!Cmd->Recurse && MatchedArgs>=Cmd->FileArgs.ItemsCount() && AllMatchesExact)
     return false;
 
   int MatchType=MATCH_WILDSUBPATH;
 
   bool EqualNames=false;
   wchar MatchedArg[NM];
   int MatchNumber=Cmd->IsProcessFile(Arc.FileHead,&EqualNames,MatchType,MatchedArg,ASIZE(MatchedArg));
   bool MatchFound=MatchNumber!=0;
 #ifndef SFX_MODULE
   if (Cmd->ExclPath==EXCL_BASEPATH)
   {
     wcsncpyz(Cmd->ArcPath,MatchedArg,ASIZE(Cmd->ArcPath));
     *PointToName(Cmd->ArcPath)=0;
     if (IsWildcard(Cmd->ArcPath)) // Cannot correctly process path*\* masks here.
       *Cmd->ArcPath=0;
   }
 #endif
   if (MatchFound && !EqualNames)
     AllMatchesExact=false;
 
   Arc.ConvertAttributes();
 
 #if !defined(SFX_MODULE) && !defined(RARDLL)
   if (Arc.FileHead.SplitBefore && FirstFile)
   {
     wchar CurVolName[NM];
     wcsncpyz(CurVolName,ArcName,ASIZE(CurVolName));
     VolNameToFirstName(ArcName,ArcName,ASIZE(ArcName),Arc.NewNumbering);
 
     if (wcsicomp(ArcName,CurVolName)!=0 && FileExist(ArcName))
     {
       // If first volume name does not match the current name and if such
       // volume name really exists, let's unpack from this first volume.
       Repeat=true;
       return false;
     }
 #ifndef RARDLL
     if (!ReconstructDone)
     {
       ReconstructDone=true;
       if (RecVolumesRestore(Cmd,Arc.FileName,true))
       {
         Repeat=true;
         return false;
       }
     }
 #endif
     wcsncpyz(ArcName,CurVolName,ASIZE(ArcName));
   }
 #endif
 
   wchar ArcFileName[NM];
   ConvertPath(Arc.FileHead.FileName,ArcFileName);
 
   if (Arc.FileHead.Version)
   {
     if (Cmd->VersionControl!=1 && !EqualNames)
     {
       if (Cmd->VersionControl==0)
         MatchFound=false;
       int Version=ParseVersionFileName(ArcFileName,false);
       if (Cmd->VersionControl-1==Version)
         ParseVersionFileName(ArcFileName,true);
       else
         MatchFound=false;
     }
   }
   else
     if (!Arc.IsArcDir() && Cmd->VersionControl>1)
       MatchFound=false;
 
   DataIO.UnpVolume=Arc.FileHead.SplitAfter;
   DataIO.NextVolumeMissing=false;
 
   Arc.Seek(Arc.NextBlockPos-Arc.FileHead.PackSize,SEEK_SET);
 
   bool ExtrFile=false;
   bool SkipSolid=false;
 
 #ifndef SFX_MODULE
   if (FirstFile && (MatchFound || Arc.Solid) && Arc.FileHead.SplitBefore)
   {
     if (MatchFound)
     {
       uiMsg(UIERROR_NEEDPREVVOL,Arc.FileName,ArcFileName);
 #ifdef RARDLL
       Cmd->DllError=ERAR_BAD_DATA;
 #endif
       ErrHandler.SetErrorCode(RARX_OPEN);
     }
     MatchFound=false;
   }
 
   FirstFile=false;
 #endif
 
   if (MatchFound || (SkipSolid=Arc.Solid)!=0)
   {
     // First common call of uiStartFileExtract. It is done before overwrite
     // prompts, so if SkipSolid state is changed below, we'll need to make
     // additional uiStartFileExtract calls with updated parameters.
     if (!uiStartFileExtract(ArcFileName,!Cmd->Test,Cmd->Test && Command!='I',SkipSolid))
       return false;
 
     ExtrPrepareName(Arc,ArcFileName,DestFileName,ASIZE(DestFileName));
 
     // DestFileName can be set empty in case of excessive -ap switch.
     ExtrFile=!SkipSolid && *DestFileName!=0 && !Arc.FileHead.SplitBefore;
 
     if ((Cmd->FreshFiles || Cmd->UpdateFiles) && (Command=='E' || Command=='X'))
     {
       FindData FD;
       if (FindFile::FastFind(DestFileName,&FD))
       {
         if (FD.mtime >= Arc.FileHead.mtime)
         {
           // If directory already exists and its modification time is newer 
           // than start of extraction, it is likely it was created 
           // when creating a path to one of already extracted items. 
           // In such case we'll better update its time even if archived 
           // directory is older.
 
           if (!FD.IsDir || FD.mtime<StartTime)
             ExtrFile=false;
         }
       }
       else
         if (Cmd->FreshFiles)
           ExtrFile=false;
     }
 
     if (!CheckUnpVer(Arc,ArcFileName))
     {
       ErrHandler.SetErrorCode(RARX_FATAL);
 #ifdef RARDLL
       Cmd->DllError=ERAR_UNKNOWN_FORMAT;
 #endif
       Arc.SeekToNext();
       return !Arc.Solid; // Can try extracting next file only in non-solid archive.
     }
 
     while (true) // Repeat the password prompt for wrong passwords.
     {
       if (Arc.FileHead.Encrypted)
       {
         // Stop archive extracting if user cancelled a password prompt.
 #ifdef RARDLL
         if (!ExtrDllGetPassword())
         {
           Cmd->DllError=ERAR_MISSING_PASSWORD;
           return false;
         }
 #else
         if (!ExtrGetPassword(Arc,ArcFileName))
         {
           PasswordCancelled=true;
           return false;
         }
 #endif
         // Skip only the current encrypted file if empty password is entered.
         // Actually our "cancel" code above intercepts empty passwords too now,
         // so we keep the code below just in case we'll decide process empty
         // and cancelled passwords differently sometimes.
         if (!Cmd->Password.IsSet())
         {
           ErrHandler.SetErrorCode(RARX_WARNING);
 #ifdef RARDLL
           Cmd->DllError=ERAR_MISSING_PASSWORD;
 #endif
           ExtrFile=false;
         }
       }
 
 
       // Set a password before creating the file, so we can skip creating
       // in case of wrong password.
       SecPassword FilePassword=Cmd->Password;
 #if defined(_WIN_ALL) && !defined(SFX_MODULE)
       ConvertDosPassword(Arc,FilePassword);
 #endif
 
       byte PswCheck[SIZE_PSWCHECK];
       DataIO.SetEncryption(false,Arc.FileHead.CryptMethod,&FilePassword,
              Arc.FileHead.SaltSet ? Arc.FileHead.Salt:NULL,
              Arc.FileHead.InitV,Arc.FileHead.Lg2Count,
              Arc.FileHead.HashKey,PswCheck);
 
       // If header is damaged, we cannot rely on password check value,
       // because it can be damaged too.
       if (Arc.FileHead.Encrypted && Arc.FileHead.UsePswCheck &&
           memcmp(Arc.FileHead.PswCheck,PswCheck,SIZE_PSWCHECK)!=0 &&
           !Arc.BrokenHeader)
       {
         // This message is used by Android GUI and Windows GUI and SFX to
         // reset cached passwords. Update appropriate code if changed.
         uiMsg(UIWAIT_BADPSW,ArcFileName);
 
         if (!PasswordAll) // If entered manually and not through -p<pwd>.
         {
           Cmd->Password.Clean();
           continue; // Request a password again.
         }
 #ifdef RARDLL
         // If we already have ERAR_EOPEN as result of missing volume,
         // we should not replace it with less precise ERAR_BAD_PASSWORD.
         if (Cmd->DllError!=ERAR_EOPEN)
           Cmd->DllError=ERAR_BAD_PASSWORD;
 #endif
         ErrHandler.SetErrorCode(RARX_BADPWD);
         ExtrFile=false;
       }
       break;
     }
 
 #ifdef RARDLL
     if (*Cmd->DllDestName!=0)
       wcsncpyz(DestFileName,Cmd->DllDestName,ASIZE(DestFileName));
 #endif
 
     File CurFile;
 
     bool LinkEntry=Arc.FileHead.RedirType!=FSREDIR_NONE;
     if (LinkEntry && Arc.FileHead.RedirType!=FSREDIR_FILECOPY)
     {
       if (ExtrFile && Command!='P' && !Cmd->Test)
       {
         // Overwrite prompt for symbolic and hard links.
         bool UserReject=false;
         if (FileExist(DestFileName) && !UserReject)
           FileCreate(Cmd,NULL,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime);
         if (UserReject)
           ExtrFile=false;
       }
     }
     else
       if (Arc.IsArcDir())
       {
         if (!ExtrFile || Command=='P' || Command=='I' || Command=='E' || Cmd->ExclPath==EXCL_SKIPWHOLEPATH)
           return true;
         TotalFileCount++;
         ExtrCreateDir(Arc,ArcFileName);
         // It is important to not increment MatchedArgs here, so we extract
         // dir with its entire contents and not dir record only even if
         // dir record precedes files.
         return true;
       }
       else
         if (ExtrFile) // Create files and file copies (FSREDIR_FILECOPY).
           ExtrFile=ExtrCreateFile(Arc,CurFile);
 
     if (!ExtrFile && Arc.Solid)
     {
       SkipSolid=true;
       ExtrFile=true;
 
       // We changed SkipSolid, so we need to call uiStartFileExtract
       // with "Skip" parameter to change the operation status 
       // from "extracting" to "skipping". For example, it can be necessary
       // if user answered "No" to overwrite prompt when unpacking
       // a solid archive.
       if (!uiStartFileExtract(ArcFileName,false,false,true))
         return false;
     }
     if (ExtrFile)
     {
       // Set it in test mode, so we also test subheaders such as NTFS streams
       // after tested file.
       if (Cmd->Test)
         PrevProcessed=true;
 
       bool TestMode=Cmd->Test || SkipSolid; // Unpack to memory, not to disk.
 
       if (!SkipSolid)
       {
         if (!TestMode && Command!='P' && CurFile.IsDevice())
         {
           uiMsg(UIERROR_INVALIDNAME,Arc.FileName,DestFileName);
           ErrHandler.WriteError(Arc.FileName,DestFileName);
         }
         TotalFileCount++;
       }
       FileCount++;
       if (Command!='I')
         if (SkipSolid)
           mprintf(St(MExtrSkipFile),ArcFileName);
         else
           switch(Cmd->Test ? 'T':Command) // "Test" can be also enabled by -t switch.
           {
             case 'T':
               mprintf(St(MExtrTestFile),ArcFileName);
               break;
 #ifndef SFX_MODULE
             case 'P':
               mprintf(St(MExtrPrinting),ArcFileName);
               break;
 #endif
             case 'X':
             case 'E':
               mprintf(St(MExtrFile),DestFileName);
               break;
           }
       if (!Cmd->DisablePercentage)
         mprintf(L"     ");
 
       DataIO.CurUnpRead=0;
       DataIO.CurUnpWrite=0;
       DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,Cmd->Threads);
       DataIO.PackedDataHash.Init(Arc.FileHead.FileHash.Type,Cmd->Threads);
       DataIO.SetPackedSizeToRead(Arc.FileHead.PackSize);
       DataIO.SetFiles(&Arc,&CurFile);
       DataIO.SetTestMode(TestMode);
       DataIO.SetSkipUnpCRC(SkipSolid);
 
 #if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)
       if (!TestMode && !Arc.BrokenHeader &&
           Arc.FileHead.UnpSize>0xffffffff && (Fat32 || !NotFat32))
       {
         if (!Fat32) // Not detected yet.
           NotFat32=!(Fat32=IsFAT(Cmd->ExtrPath));
         if (Fat32)
           uiMsg(UIMSG_FAT32SIZE); // Inform user about FAT32 size limit.
       }
 #endif
 
       if (!TestMode && !Arc.BrokenHeader &&
           (Arc.FileHead.PackSize<<11)>Arc.FileHead.UnpSize &&
           (Arc.FileHead.UnpSize<100000000 || Arc.FileLength()>Arc.FileHead.PackSize))
         CurFile.Prealloc(Arc.FileHead.UnpSize);
 
       CurFile.SetAllowDelete(!Cmd->KeepBroken);
 
       bool FileCreateMode=!TestMode && !SkipSolid && Command!='P';
       bool ShowChecksum=true; // Display checksum verification result.
 
       bool LinkSuccess=true; // Assume success for test mode.
       if (LinkEntry)
       {
         FILE_SYSTEM_REDIRECT Type=Arc.FileHead.RedirType;
 
         if (Type==FSREDIR_HARDLINK || Type==FSREDIR_FILECOPY)
         {
           wchar NameExisting[NM];
           ExtrPrepareName(Arc,Arc.FileHead.RedirName,NameExisting,ASIZE(NameExisting));
           if (FileCreateMode && *NameExisting!=0) // *NameExisting can be 0 in case of excessive -ap switch.
             if (Type==FSREDIR_HARDLINK)
               LinkSuccess=ExtractHardlink(DestFileName,NameExisting,ASIZE(NameExisting));
             else
               LinkSuccess=ExtractFileCopy(CurFile,Arc.FileName,DestFileName,NameExisting,ASIZE(NameExisting));
         }
         else
           if (Type==FSREDIR_UNIXSYMLINK || Type==FSREDIR_WINSYMLINK || Type==FSREDIR_JUNCTION)
           {
             if (FileCreateMode)
               LinkSuccess=ExtractSymlink(Cmd,DataIO,Arc,DestFileName);
           }
           else
           {
             uiMsg(UIERROR_UNKNOWNEXTRA, Arc.FileName, DestFileName);
             LinkSuccess=false;
           }
           
           if (!LinkSuccess || Arc.Format==RARFMT15 && !FileCreateMode)
           {
             // RAR 5.x links have a valid data checksum even in case of
             // failure, because they do not store any data.
             // We do not want to display "OK" in this case.
             // For 4.x symlinks we verify the checksum only when extracting,
             // but not when testing an archive.
             ShowChecksum=false;
           }
           PrevProcessed=FileCreateMode && LinkSuccess;
       }
       else
         if (!Arc.FileHead.SplitBefore)
           if (Arc.FileHead.Method==0)
             UnstoreFile(DataIO,Arc.FileHead.UnpSize);
           else
           {
             Unp->Init(Arc.FileHead.WinSize,Arc.FileHead.Solid);
             Unp->SetDestSize(Arc.FileHead.UnpSize);
 #ifndef SFX_MODULE
             if (Arc.Format!=RARFMT50 && Arc.FileHead.UnpVer<=15)
               Unp->DoUnpack(15,FileCount>1 && Arc.Solid);
             else
 #endif
               Unp->DoUnpack(Arc.FileHead.UnpVer,Arc.FileHead.Solid);
           }
 
       Arc.SeekToNext();
 
       // We check for "split after" flag to detect partially extracted files
       // from incomplete volume sets. For them file header contains packed
       // data hash, which must not be compared against unpacked data hash
       // to prevent accidental match. Moreover, for -m0 volumes packed data
       // hash would match truncated unpacked data hash and lead to fake "OK"
       // in incomplete volume set.
       bool ValidCRC=!Arc.FileHead.SplitAfter && DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL);
 
       // We set AnySolidDataUnpackedWell to true if we found at least one
       // valid non-zero solid file in preceding solid stream. If it is true
       // and if current encrypted file is broken, we do not need to hint
       // about a wrong password and can report CRC error only.
       if (!Arc.FileHead.Solid)
         AnySolidDataUnpackedWell=false; // Reset the flag, because non-solid file is found.
       else
         if (Arc.FileHead.Method!=0 && Arc.FileHead.UnpSize>0 && ValidCRC)
           AnySolidDataUnpackedWell=true;
  
       bool BrokenFile=false;
       
       // Checksum is not calculated in skip solid mode for performance reason.
       if (!SkipSolid && ShowChecksum)
       {
         if (ValidCRC)
         {
           if (Command!='P' && Command!='I')
             mprintf(L"%s%s ",Cmd->DisablePercentage ? L" ":L"\b\b\b\b\b ",
               Arc.FileHead.FileHash.Type==HASH_NONE ? L"  ?":St(MOk));
         }
         else
         {
           if (Arc.FileHead.Encrypted && (!Arc.FileHead.UsePswCheck || 
               Arc.BrokenHeader) && !AnySolidDataUnpackedWell)
             uiMsg(UIERROR_CHECKSUMENC,Arc.FileName,ArcFileName);
           else
             uiMsg(UIERROR_CHECKSUM,Arc.FileName,ArcFileName);
           BrokenFile=true;
           ErrHandler.SetErrorCode(RARX_CRC);
 #ifdef RARDLL
           // If we already have ERAR_EOPEN as result of missing volume
           // or ERAR_BAD_PASSWORD for RAR5 wrong password,
           // we should not replace it with less precise ERAR_BAD_DATA.
           if (Cmd->DllError!=ERAR_EOPEN && Cmd->DllError!=ERAR_BAD_PASSWORD)
             Cmd->DllError=ERAR_BAD_DATA;
 #endif
         }
       }
       else
         mprintf(L"\b\b\b\b\b     ");
 
       if (!TestMode && (Command=='X' || Command=='E') &&
           (!LinkEntry || Arc.FileHead.RedirType==FSREDIR_FILECOPY && LinkSuccess) && 
           (!BrokenFile || Cmd->KeepBroken))
       {
         // We could preallocate more space that really written to broken file.
         if (BrokenFile)
           CurFile.Truncate();
 
 #if defined(_WIN_ALL) || defined(_EMX)
         if (Cmd->ClearArc)
           Arc.FileHead.FileAttr&=~FILE_ATTRIBUTE_ARCHIVE;
 #endif
 
 
         CurFile.SetOpenFileTime(
           Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,
           Cmd->xctime==EXTTIME_NONE ? NULL:&Arc.FileHead.ctime,
           Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);
         CurFile.Close();
 #if defined(_WIN_ALL) && !defined(SFX_MODULE)
         if (Cmd->SetCompressedAttr &&
             (Arc.FileHead.FileAttr & FILE_ATTRIBUTE_COMPRESSED)!=0)
           SetFileCompression(CurFile.FileName,true);
 #endif
         SetFileHeaderExtra(Cmd,Arc,CurFile.FileName);
 
         CurFile.SetCloseFileTime(
           Cmd->xmtime==EXTTIME_NONE ? NULL:&Arc.FileHead.mtime,
           Cmd->xatime==EXTTIME_NONE ? NULL:&Arc.FileHead.atime);
         if (!Cmd->IgnoreGeneralAttr && !SetFileAttr(CurFile.FileName,Arc.FileHead.FileAttr))
           uiMsg(UIERROR_FILEATTR,Arc.FileName,CurFile.FileName);
 
         PrevProcessed=true;
       }
     }
   }
   // It is important to increment it for files, but not dirs. So we extract
   // dir with its entire contents, not just dir record only even if dir
   // record precedes files.
   if (MatchFound)
     MatchedArgs++;
   if (DataIO.NextVolumeMissing)
     return false;
   if (!ExtrFile)
     if (!Arc.Solid)
       Arc.SeekToNext();
     else
       if (!SkipSolid)
         return false;
   return true;
 }
@@ -782,15 +784,17 @@ bool CmdExtract::ExtractCurrentFile(Archive &Arc,size_t HeaderSize,bool &Repeat)
 void CmdExtract::UnstoreFile(ComprDataIO &DataIO,int64 DestUnpSize)
 {
   Array<byte> Buffer(File::CopyBufferSize());
-  while (1)
+  while (true)
   {
-    uint Code=DataIO.UnpRead(&Buffer[0],Buffer.Size());
-    if (Code==0 || (int)Code==-1)
+    int ReadSize=DataIO.UnpRead(&Buffer[0],Buffer.Size());
+    if (ReadSize<=0)
       break;
-    Code=Code<DestUnpSize ? Code:(uint)DestUnpSize;
-    DataIO.UnpWrite(&Buffer[0],Code);
-    if (DestUnpSize>=0)
-      DestUnpSize-=Code;
+    int WriteSize=ReadSize<DestUnpSize ? ReadSize:(int)DestUnpSize;
+    if (WriteSize>0)
+    {
+      DataIO.UnpWrite(&Buffer[0],WriteSize);
+      DestUnpSize-=WriteSize;
+    }
   }
 }
 
@@ -798,28 +802,30 @@ void CmdExtract::UnstoreFile(ComprDataIO &DataIO,int64 DestUnpSize)
 bool CmdExtract::ExtractFileCopy(File &New,wchar *ArcName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize)
 {
   SlashToNative(NameExisting,NameExisting,NameExistingSize); // Not needed for RAR 5.1+ archives.
 
   File Existing;
   if (!Existing.WOpen(NameExisting))
   {
     uiMsg(UIERROR_FILECOPY,ArcName,NameExisting,NameNew);
     uiMsg(UIERROR_FILECOPYHINT,ArcName);
 #ifdef RARDLL
     Cmd->DllError=ERAR_EREFERENCE;
 #endif
     return false;
   }
 
   Array<char> Buffer(0x100000);
+  int64 CopySize=0;
 
   while (true)
   {
     Wait();
     int ReadSize=Existing.Read(&Buffer[0],Buffer.Size());
     if (ReadSize==0)
       break;
     New.Write(&Buffer[0],ReadSize);
+    CopySize+=ReadSize;
   }
 
   return true;
 }
diff --git a/file.cpp b/file.cpp
index 9b4775a..e2bb42a 100644
--- a/file.cpp
+++ b/file.cpp
@@ -499,26 +499,26 @@ bool File::RawSeek(int64 Offset,int Method)
 int64 File::Tell()
 {
   if (hFile==FILE_BAD_HANDLE)
     if (AllowExceptions)
       ErrHandler.SeekError(FileName);
     else
       return -1;
 #ifdef _WIN_ALL
   LONG HighDist=0;
   uint LowDist=SetFilePointer(hFile,0,&HighDist,FILE_CURRENT);
   if (LowDist==0xffffffff && GetLastError()!=NO_ERROR)
     if (AllowExceptions)
       ErrHandler.SeekError(FileName);
     else
       return -1;
-  return UINT32TO64(HighDist,LowDist);
+  return INT32TO64(HighDist,LowDist);
 #else
 #ifdef FILE_USE_OPEN
   return lseek(hFile,0,SEEK_CUR);
 #elif defined(_LARGEFILE_SOURCE) && !defined(_OSF_SOURCE)
   return ftello(hFile);
 #else
   return ftell(hFile);
 #endif
 #endif
 }
@@ -668,25 +668,62 @@ void File::GetOpenFileTime(RarTime *ft)
 }
 
 
-uint64 File::FileLength()
+int64 File::FileLength()
 {
   SaveFilePos SavePos(*this);
   Seek(0,SEEK_END);
-  int64 Pos=Tell();
-  return Pos<0 ? 0 : Pos;
+  return Tell();
 }
 
 
 bool File::IsDevice()
 {
   if (hFile==FILE_BAD_HANDLE)
     return false;
 #ifdef _WIN_ALL
   uint Type=GetFileType(hFile);
   return Type==FILE_TYPE_CHAR || Type==FILE_TYPE_PIPE;
 #else
   return isatty(GetFD());
 #endif
 }
 
 
+#ifndef SFX_MODULE
+int64 File::Copy(File &Dest,int64 Length)
+{
+  Array<byte> Buffer(File::CopyBufferSize());
+  int64 CopySize=0;
+  bool CopyAll=(Length==INT64NDF);
+
+  while (CopyAll || Length>0)
+  {
+    Wait();
+    size_t SizeToRead=(!CopyAll && Length<(int64)Buffer.Size()) ? (size_t)Length:Buffer.Size();
+    byte *Buf=&Buffer[0];
+    int ReadSize=Read(Buf,SizeToRead);
+    if (ReadSize==0)
+      break;
+    size_t WriteSize=ReadSize;
+#ifdef _WIN_ALL
+    // For FAT32 USB flash drives in Windows if first write is 4 KB or more,
+    // write caching is disabled and "write through" is enabled, resulting
+    // in bad performance, especially for many small files. It happens when
+    // we create SFX archive on USB drive, because SFX module is written first.
+    // So we split the first write to small 1 KB followed by rest of data.
+    if (CopySize==0 && WriteSize>=4096)
+    {
+      const size_t FirstWrite=1024;
+      Dest.Write(Buf,FirstWrite);
+      Buf+=FirstWrite;
+      WriteSize-=FirstWrite;
+    }
+#endif
+    Dest.Write(Buf,WriteSize);
+    CopySize+=ReadSize;
+    if (!CopyAll)
+      Length-=ReadSize;
+  }
+  return CopySize;
+}
+#endif
diff --git a/file.hpp b/file.hpp
index 784ef01..f8cff4f 100644
--- a/file.hpp
+++ b/file.hpp
@@ -50,87 +50,88 @@ enum FILE_MODE_FLAGS {
 class File
 {
   private:
     FileHandle hFile;
     bool LastWrite;
     FILE_HANDLETYPE HandleType;
     bool SkipClose;
     bool IgnoreReadErrors;
     bool NewFile;
     bool AllowDelete;
     bool AllowExceptions;
 #ifdef _WIN_ALL
     bool NoSequentialRead;
     uint CreateMode;
 #endif
   protected:
     bool OpenShared; // Set by 'Archive' class.
   public:
     wchar FileName[NM];
 
     FILE_ERRORTYPE ErrorType;
   public:
     File();
     virtual ~File();
     void operator = (File &SrcFile);
     virtual bool Open(const wchar *Name,uint Mode=FMF_READ);
     void TOpen(const wchar *Name);
     bool WOpen(const wchar *Name);
     bool Create(const wchar *Name,uint Mode=FMF_UPDATE|FMF_SHAREREAD);
     void TCreate(const wchar *Name,uint Mode=FMF_UPDATE|FMF_SHAREREAD);
     bool WCreate(const wchar *Name,uint Mode=FMF_UPDATE|FMF_SHAREREAD);
     bool Close();
     bool Delete();
     bool Rename(const wchar *NewName);
     bool Write(const void *Data,size_t Size);
     virtual int Read(void *Data,size_t Size);
     int DirectRead(void *Data,size_t Size);
     virtual void Seek(int64 Offset,int Method);
     bool RawSeek(int64 Offset,int Method);
     virtual int64 Tell();
     void Prealloc(int64 Size);
     byte GetByte();
     void PutByte(byte Byte);
     bool Truncate();
     void Flush();
     void SetOpenFileTime(RarTime *ftm,RarTime *ftc=NULL,RarTime *fta=NULL);
     void SetCloseFileTime(RarTime *ftm,RarTime *fta=NULL);
     static void SetCloseFileTimeByName(const wchar *Name,RarTime *ftm,RarTime *fta);
     void GetOpenFileTime(RarTime *ft);
     bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};
-    uint64 FileLength();
+    int64 FileLength();
     void SetHandleType(FILE_HANDLETYPE Type) {HandleType=Type;}
     FILE_HANDLETYPE GetHandleType() {return HandleType;}
     bool IsDevice();
     static bool RemoveCreated();
     FileHandle GetHandle() {return hFile;}
     void SetHandle(FileHandle Handle) {Close();hFile=Handle;}
     void SetIgnoreReadErrors(bool Mode) {IgnoreReadErrors=Mode;}
+    int64 Copy(File &Dest,int64 Length=INT64NDF);
     void SetAllowDelete(bool Allow) {AllowDelete=Allow;}
     void SetExceptions(bool Allow) {AllowExceptions=Allow;}
 #ifdef _WIN_ALL
     void RemoveSequentialFlag() {NoSequentialRead=true;}
 #endif
 #ifdef _UNIX
     int GetFD()
     {
 #ifdef FILE_USE_OPEN
       return hFile;
 #else
       return fileno(hFile);
 #endif
     }
 #endif
     static size_t CopyBufferSize()
     {
 #ifdef _WIN_ALL
       // USB flash performance is poor with 64 KB buffer, 256+ KB resolved it.
       // For copying from HDD to same HDD the best performance was with 256 KB
       // buffer in XP and with 1 MB buffer in Win10.
       return WinNT()==WNT_WXP ? 0x40000:0x100000;
 #else
       return 0x100000;
 #endif
     }
 };
 
 #endif
diff --git a/filefn.cpp b/filefn.cpp
index edda8f1..4eb7b9b 100644
--- a/filefn.cpp
+++ b/filefn.cpp
@@ -144,34 +144,34 @@ bool IsRemovable(const wchar *Name)
 #ifndef SFX_MODULE
 int64 GetFreeDisk(const wchar *Name)
 {
 #ifdef _WIN_ALL
   wchar Root[NM];
   GetFilePath(Name,Root,ASIZE(Root));
 
   ULARGE_INTEGER uiTotalSize,uiTotalFree,uiUserFree;
   uiUserFree.u.LowPart=uiUserFree.u.HighPart=0;
   if (GetDiskFreeSpaceEx(*Root!=0 ? Root:NULL,&uiUserFree,&uiTotalSize,&uiTotalFree) &&
       uiUserFree.u.HighPart<=uiTotalFree.u.HighPart)
-    return UINT32TO64(uiUserFree.u.HighPart,uiUserFree.u.LowPart);
+    return INT32TO64(uiUserFree.u.HighPart,uiUserFree.u.LowPart);
   return 0;
 #elif defined(_UNIX)
   wchar Root[NM];
   GetFilePath(Name,Root,ASIZE(Root));
   char RootA[NM];
   WideToChar(Root,RootA,ASIZE(RootA));
   struct statvfs sfs;
   if (statvfs(*RootA!=0 ? RootA:".",&sfs)!=0)
     return 0;
   int64 FreeSize=sfs.f_bsize;
   FreeSize=FreeSize*sfs.f_bavail;
   return FreeSize;
 #else
   return 0;
 #endif
 }
 #endif
 
 
 #if defined(_WIN_ALL) && !defined(SFX_MODULE) && !defined(SILENT)
 // Return 'true' for FAT and FAT32, so we can adjust the maximum supported
 // file size to 4 GB for these file systems.
diff --git a/find.cpp b/find.cpp
index 0abe89d..812af6b 100644
--- a/find.cpp
+++ b/find.cpp
@@ -166,53 +166,53 @@ bool FindFile::FastFind(const wchar *FindMask,FindData *fd,bool GetSymLink)
 #ifdef _WIN_ALL
 HANDLE FindFile::Win32Find(HANDLE hFind,const wchar *Mask,FindData *fd)
 {
   WIN32_FIND_DATA FindData;
   if (hFind==INVALID_HANDLE_VALUE)
   {
     hFind=FindFirstFile(Mask,&FindData);
     if (hFind==INVALID_HANDLE_VALUE)
     {
       wchar LongMask[NM];
       if (GetWinLongPath(Mask,LongMask,ASIZE(LongMask)))
         hFind=FindFirstFile(LongMask,&FindData);
     }
     if (hFind==INVALID_HANDLE_VALUE)
     {
       int SysErr=GetLastError();
       // We must not issue an error for "file not found" and "path not found",
       // because it is normal to not find anything for wildcard mask when
       // archiving. Also searching for non-existent file is normal in some
       // other modules, like WinRAR scanning for winrar_theme_description.txt
       // to check if any themes are available.
       fd->Error=SysErr!=ERROR_FILE_NOT_FOUND && 
                 SysErr!=ERROR_PATH_NOT_FOUND &&
                 SysErr!=ERROR_NO_MORE_FILES;
     }
   }
   else
     if (!FindNextFile(hFind,&FindData))
     {
       hFind=INVALID_HANDLE_VALUE;
       fd->Error=GetLastError()!=ERROR_NO_MORE_FILES;
     }
 
   if (hFind!=INVALID_HANDLE_VALUE)
   {
     wcsncpyz(fd->Name,Mask,ASIZE(fd->Name));
     SetName(fd->Name,FindData.cFileName,ASIZE(fd->Name));
-    fd->Size=UINT32TO64(FindData.nFileSizeHigh,FindData.nFileSizeLow);
+    fd->Size=INT32TO64(FindData.nFileSizeHigh,FindData.nFileSizeLow);
     fd->FileAttr=FindData.dwFileAttributes;
     fd->ftCreationTime=FindData.ftCreationTime;
     fd->ftLastAccessTime=FindData.ftLastAccessTime;
     fd->ftLastWriteTime=FindData.ftLastWriteTime;
     fd->mtime.SetWinFT(&FindData.ftLastWriteTime);
     fd->ctime.SetWinFT(&FindData.ftCreationTime);
     fd->atime.SetWinFT(&FindData.ftLastAccessTime);
 
 
   }
   fd->Flags=0;
   return hFind;
 }
 #endif
 
diff --git a/headers.hpp b/headers.hpp
index 2b7baff..9486478 100644
--- a/headers.hpp
+++ b/headers.hpp
@@ -177,86 +177,86 @@ struct MainHeader:BaseBlock
 struct FileHeader:BlockHeader
 {
   byte HostOS;
   byte UnpVer;
   byte Method;
   union {
     uint FileAttr;
     uint SubFlags;
   };
   wchar FileName[NM];
 
   Array<byte> SubData;
 
   RarTime mtime;
   RarTime ctime;
   RarTime atime;
 
-  uint64 PackSize;
-  uint64 UnpSize;
-  uint64 MaxSize; // Reserve size bytes for vint of this size.
+  int64 PackSize;
+  int64 UnpSize;
+  int64 MaxSize; // Reserve size bytes for vint of this size.
 
   HashValue FileHash;
 
   uint FileFlags;
 
   bool SplitBefore;
   bool SplitAfter;
 
   bool UnknownUnpSize;
 
   bool Encrypted;
   CRYPT_METHOD CryptMethod;
   bool SaltSet;
   byte Salt[SIZE_SALT50];
   byte InitV[SIZE_INITV];
   bool UsePswCheck;
   byte PswCheck[SIZE_PSWCHECK];
 
   // Use HMAC calculated from HashKey and checksum instead of plain checksum.
   bool UseHashKey;
 
   // Key to convert checksum to HMAC. Derived from password with PBKDF2
   // using additional iterations.
   byte HashKey[SHA256_DIGEST_SIZE];
 
   uint Lg2Count; // Log2 of PBKDF2 repetition count.
 
   bool Solid;
   bool Dir;
   bool CommentInHeader; // RAR 2.0 file comment.
   bool Version;   // name.ext;ver file name containing the version number.
   size_t WinSize;
   bool Inherited; // New file inherits a subblock when updating a host file (for subblocks only).
 
   // 'true' if file sizes use 8 bytes instead of 4. Not used in RAR 5.0.
   bool LargeFile;
   
   // 'true' for HEAD_SERVICE block, which is a child of preceding file block.
   // RAR 4.x uses 'solid' flag to indicate child subheader blocks in archives.
   bool SubBlock;
 
   HOST_SYSTEM_TYPE HSType;
 
   FILE_SYSTEM_REDIRECT RedirType;
   wchar RedirName[NM];
   bool DirTarget;
 
   bool UnixOwnerSet,UnixOwnerNumeric,UnixGroupNumeric;
   char UnixOwnerName[256],UnixGroupName[256];
 #ifdef _UNIX
   uid_t UnixOwnerID;
   gid_t UnixGroupID;
 #else // Need these Unix fields in Windows too for 'list' command.
   uint UnixOwnerID;
   uint UnixGroupID;
 #endif
 
   void Reset(size_t SubDataSize=0);
 
   bool CmpName(const wchar *Name)
   {
     return(wcscmp(FileName,Name)==0);
   }
 
   FileHeader& operator = (FileHeader &hd);
 };
diff --git a/list.cpp b/list.cpp
index 8e077b3..561122b 100644
--- a/list.cpp
+++ b/list.cpp
@@ -8,175 +8,175 @@ static void ListNewSubHeader(CommandData *Cmd,Archive &Arc);
 
 void ListArchive(CommandData *Cmd)
 {
-  uint64 SumPackSize=0,SumUnpSize=0;
+  int64 SumPackSize=0,SumUnpSize=0;
   uint ArcCount=0,SumFileCount=0;
   bool Technical=(Cmd->Command[1]=='T');
   bool ShowService=Technical && Cmd->Command[2]=='A';
   bool Bare=(Cmd->Command[1]=='B');
   bool Verbose=(Cmd->Command[0]=='V');
 
   wchar ArcName[NM];
   while (Cmd->GetArcName(ArcName,ASIZE(ArcName)))
   {
     if (Cmd->ManualPassword)
       Cmd->Password.Clean(); // Clean user entered password before processing next archive.
 
     Archive Arc(Cmd);
 #ifdef _WIN_ALL
     Arc.RemoveSequentialFlag();
 #endif
     if (!Arc.WOpen(ArcName))
       continue;
     bool FileMatched=true;
     while (1)
     {
-      uint64 TotalPackSize=0,TotalUnpSize=0;
+      int64 TotalPackSize=0,TotalUnpSize=0;
       uint FileCount=0;
       if (Arc.IsArchive(true))
       {
         bool TitleShown=false;
         if (!Bare)
         {
           Arc.ViewComment();
           mprintf(L"\n%s: %s",St(MListArchive),Arc.FileName);
           mprintf(L"\n%s: ",St(MListDetails));
           uint SetCount=0;
           const wchar *Fmt=Arc.Format==RARFMT14 ? L"RAR 1.4":(Arc.Format==RARFMT15 ? L"RAR 4":L"RAR 5");
           mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", Fmt);
           if (Arc.Solid)
             mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListSolid));
           if (Arc.SFXSize>0)
             mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListSFX));
           if (Arc.Volume)
             if (Arc.Format==RARFMT50)
             {
               // RAR 5.0 archives store the volume number in main header,
               // so it is already available now.
               if (SetCount++ > 0)
                 mprintf(L", ");
               mprintf(St(MVolumeNumber),Arc.VolNumber+1);
             }
             else
               mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListVolume));
           if (Arc.Protected)
             mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListRR));
           if (Arc.Locked)
             mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListLock));
           if (Arc.Encrypted)
             mprintf(L"%s%s", SetCount++ > 0 ? L", ":L"", St(MListEncHead));
           mprintf(L"\n");
         }
 
         wchar VolNumText[50];
         *VolNumText=0;
         while(Arc.ReadHeader()>0)
         {
           HEADER_TYPE HeaderType=Arc.GetHeaderType();
           if (HeaderType==HEAD_ENDARC)
           {
 #ifndef SFX_MODULE
             // Only RAR 1.5 archives store the volume number in end record.
             if (Arc.EndArcHead.StoreVolNumber && Arc.Format==RARFMT15)
               swprintf(VolNumText,ASIZE(VolNumText),L"%.10ls %u",St(MListVolume),Arc.VolNumber+1);
 #endif
             if (Technical && ShowService)
             {
               mprintf(L"\n%12ls: %ls",St(MListService),L"EOF");
               if (*VolNumText!=0)
                 mprintf(L"\n%12ls: %ls",St(MListFlags),VolNumText);
               mprintf(L"\n");
             }
             break;
           }
           switch(HeaderType)
           {
             case HEAD_FILE:
               FileMatched=Cmd->IsProcessFile(Arc.FileHead)!=0;
               if (FileMatched)
               {
                 ListFileHeader(Arc,Arc.FileHead,TitleShown,Verbose,Technical,Bare);
                 if (!Arc.FileHead.SplitBefore)
                 {
                   TotalUnpSize+=Arc.FileHead.UnpSize;
                   FileCount++;
                 }
                 TotalPackSize+=Arc.FileHead.PackSize;
               }
               break;
             case HEAD_SERVICE:
               if (FileMatched && !Bare)
               {
                 if (Technical && ShowService)
                   ListFileHeader(Arc,Arc.SubHead,TitleShown,Verbose,true,false);
               }
               break;
           }
           Arc.SeekToNext();
         }
         if (!Bare && !Technical)
           if (TitleShown)
           {
             wchar UnpSizeText[20];
             itoa(TotalUnpSize,UnpSizeText,ASIZE(UnpSizeText));
         
             wchar PackSizeText[20];
             itoa(TotalPackSize,PackSizeText,ASIZE(PackSizeText));
         
             if (Verbose)
             {
               mprintf(L"\n----------- ---------  -------- ----- ---------- -----  --------  ----");
-              mprintf(L"\n%21ls %9ls %3u%%  %-27ls %u",UnpSizeText,
+              mprintf(L"\n%21ls %9ls %3d%%  %-27ls %u",UnpSizeText,
                       PackSizeText,ToPercentUnlim(TotalPackSize,TotalUnpSize),
                       VolNumText,FileCount);
             }
             else
             {
               mprintf(L"\n----------- ---------  ---------- -----  ----");
               mprintf(L"\n%21ls  %-16ls  %u",UnpSizeText,VolNumText,FileCount);
             }
 
             SumFileCount+=FileCount;
             SumUnpSize+=TotalUnpSize;
             SumPackSize+=TotalPackSize;
             mprintf(L"\n");
           }
           else
             mprintf(St(MListNoFiles));
 
         ArcCount++;
 
 #ifndef NOVOLUME
         if (Cmd->VolSize!=0 && (Arc.FileHead.SplitAfter ||
             Arc.GetHeaderType()==HEAD_ENDARC && Arc.EndArcHead.NextVolume) &&
             MergeArchive(Arc,NULL,false,Cmd->Command[0]))
           Arc.Seek(0,SEEK_SET);
         else
 #endif
           break;
       }
       else
       {
         if (Cmd->ArcNames.ItemsCount()<2 && !Bare)
           mprintf(St(MNotRAR),Arc.FileName);
         break;
       }
     }
   }
 
   // Clean user entered password. Not really required, just for extra safety.
   if (Cmd->ManualPassword)
     Cmd->Password.Clean();
 
   if (ArcCount>1 && !Bare && !Technical)
   {
     wchar UnpSizeText[20],PackSizeText[20];
     itoa(SumUnpSize,UnpSizeText,ASIZE(UnpSizeText));
     itoa(SumPackSize,PackSizeText,ASIZE(PackSizeText));
 
     if (Verbose)
-      mprintf(L"%21ls %9ls %3u%% %28ls %u",UnpSizeText,PackSizeText,
+      mprintf(L"%21ls %9ls %3d%% %28ls %u",UnpSizeText,PackSizeText,
               ToPercentUnlim(SumPackSize,SumUnpSize),L"",SumFileCount);
     else
       mprintf(L"%21ls %18s %lu",UnpSizeText,L"",SumFileCount);
   }
 }
@@ -190,222 +190,242 @@ enum LISTCOL_TYPE {
 void ListFileHeader(Archive &Arc,FileHeader &hd,bool &TitleShown,bool Verbose,bool Technical,bool Bare)
 {
   wchar *Name=hd.FileName;
   RARFORMAT Format=Arc.Format;
 
   if (Bare)
   {
     mprintf(L"%s\n",Name);
     return;
   }
 
   if (!TitleShown && !Technical)
   {
     if (Verbose)
     {
       mprintf(L"\n%ls",St(MListTitleV));
       mprintf(L"\n----------- ---------  -------- ----- ---------- -----  --------  ----");
     }
     else
     {
       mprintf(L"\n%ls",St(MListTitleL));
       mprintf(L"\n----------- ---------  ---------- -----  ----");
     }
     TitleShown=true;
   }
 
   wchar UnpSizeText[30],PackSizeText[30];
   if (hd.UnpSize==INT64NDF)
     wcscpy(UnpSizeText,L"?");
   else
     itoa(hd.UnpSize,UnpSizeText,ASIZE(UnpSizeText));
   itoa(hd.PackSize,PackSizeText,ASIZE(PackSizeText));
 
   wchar AttrStr[30];
   if (hd.HeaderType==HEAD_SERVICE)
     swprintf(AttrStr,ASIZE(AttrStr),L"%cB",hd.Inherited ? 'I' : '.');
   else
     ListFileAttr(hd.FileAttr,hd.HSType,AttrStr,ASIZE(AttrStr));
 
   wchar RatioStr[10];
 
   if (hd.SplitBefore && hd.SplitAfter)
     wcscpy(RatioStr,L"<->");
   else
     if (hd.SplitBefore)
       wcscpy(RatioStr,L"<--");
     else
       if (hd.SplitAfter)
         wcscpy(RatioStr,L"-->");
       else
-        swprintf(RatioStr,ASIZE(RatioStr),L"%u%%",ToPercentUnlim(hd.PackSize,hd.UnpSize));
+        swprintf(RatioStr,ASIZE(RatioStr),L"%d%%",ToPercentUnlim(hd.PackSize,hd.UnpSize));
 
   wchar DateStr[50];
   hd.mtime.GetText(DateStr,ASIZE(DateStr),Technical);
 
   if (Technical)
   {
     mprintf(L"\n%12s: %s",St(MListName),Name);
 
     bool FileBlock=hd.HeaderType==HEAD_FILE;
 
     if (!FileBlock && Arc.SubHead.CmpName(SUBHEAD_TYPE_STREAM))
     {
       mprintf(L"\n%12ls: %ls",St(MListType),St(MListStream));
       wchar StreamName[NM];
       GetStreamNameNTFS(Arc,StreamName,ASIZE(StreamName));
       mprintf(L"\n%12ls: %ls",St(MListTarget),StreamName);
     }
     else
     {
       const wchar *Type=St(FileBlock ? (hd.Dir ? MListDir:MListFile):MListService);
     
       if (hd.RedirType!=FSREDIR_NONE)
         switch(hd.RedirType)
         {
           case FSREDIR_UNIXSYMLINK:
             Type=St(MListUSymlink); break;
           case FSREDIR_WINSYMLINK:
             Type=St(MListWSymlink); break;
           case FSREDIR_JUNCTION:
             Type=St(MListJunction); break;
           case FSREDIR_HARDLINK:
             Type=St(MListHardlink); break;
           case FSREDIR_FILECOPY:
             Type=St(MListCopy);     break;
         }
       mprintf(L"\n%12ls: %ls",St(MListType),Type);
       if (hd.RedirType!=FSREDIR_NONE)
         if (Format==RARFMT15)
         {
           char LinkTargetA[NM];
           if (Arc.FileHead.Encrypted)
           {
             // Link data are encrypted. We would need to ask for password
             // and initialize decryption routine to display the link target.
             strncpyz(LinkTargetA,"*<-?->",ASIZE(LinkTargetA));
           }
           else
           {
-            size_t SizeToRead=(size_t)Min(hd.PackSize,ASIZE(LinkTargetA)-1);
-            size_t DataSize=(size_t)Arc.Read(LinkTargetA,SizeToRead);
-            LinkTargetA[Min(DataSize,ASIZE(LinkTargetA)-1)]=0;
+            int DataSize=(int)Min(hd.PackSize,ASIZE(LinkTargetA)-1);
+            Arc.Read(LinkTargetA,DataSize);
+            LinkTargetA[DataSize > 0 ? DataSize : 0] = 0;
           }
           wchar LinkTarget[NM];
           CharToWide(LinkTargetA,LinkTarget,ASIZE(LinkTarget));
           mprintf(L"\n%12ls: %ls",St(MListTarget),LinkTarget);
         }
         else
           mprintf(L"\n%12ls: %ls",St(MListTarget),hd.RedirName);
     }
     if (!hd.Dir)
     {
       mprintf(L"\n%12ls: %ls",St(MListSize),UnpSizeText);
       mprintf(L"\n%12ls: %ls",St(MListPacked),PackSizeText);
       mprintf(L"\n%12ls: %ls",St(MListRatio),RatioStr);
     }
     if (hd.mtime.IsSet())
       mprintf(L"\n%12ls: %ls",St(MListMtime),DateStr);
     if (hd.ctime.IsSet())
     {
       hd.ctime.GetText(DateStr,ASIZE(DateStr),true);
       mprintf(L"\n%12ls: %ls",St(MListCtime),DateStr);
     }
     if (hd.atime.IsSet())
     {
       hd.atime.GetText(DateStr,ASIZE(DateStr),true);
       mprintf(L"\n%12ls: %ls",St(MListAtime),DateStr);
     }
     mprintf(L"\n%12ls: %ls",St(MListAttr),AttrStr);
     if (hd.FileHash.Type==HASH_CRC32)
       mprintf(L"\n%12ls: %8.8X",
         hd.UseHashKey ? L"CRC32 MAC":hd.SplitAfter ? L"Pack-CRC32":L"CRC32",
         hd.FileHash.CRC32);
     if (hd.FileHash.Type==HASH_BLAKE2)
     {
       wchar BlakeStr[BLAKE2_DIGEST_SIZE*2+1];
       BinToHex(hd.FileHash.Digest,BLAKE2_DIGEST_SIZE,NULL,BlakeStr,ASIZE(BlakeStr));
       mprintf(L"\n%12ls: %ls",
         hd.UseHashKey ? L"BLAKE2 MAC":hd.SplitAfter ? L"Pack-BLAKE2":L"BLAKE2",
         BlakeStr);
     }
 
     const wchar *HostOS=L"";
     if (Format==RARFMT50 && hd.HSType!=HSYS_UNKNOWN)
       HostOS=hd.HSType==HSYS_WINDOWS ? L"Windows":L"Unix";
     if (Format==RARFMT15)
     {
       static const wchar *RarOS[]={
         L"DOS",L"OS/2",L"Windows",L"Unix",L"Mac OS",L"BeOS",L"WinCE",L"",L"",L""
       };
       if (hd.HostOS<ASIZE(RarOS))
         HostOS=RarOS[hd.HostOS];
     }
     if (*HostOS!=0)
       mprintf(L"\n%12ls: %ls",St(MListHostOS),HostOS);
 
     mprintf(L"\n%12ls: RAR %ls(v%d) -m%d -md=%d%s",St(MListCompInfo),
             Format==RARFMT15 ? L"3.0":L"5.0",hd.UnpVer,hd.Method,
             hd.WinSize>=0x100000 ? hd.WinSize/0x100000:hd.WinSize/0x400,
             hd.WinSize>=0x100000 ? L"M":L"K");
 
     if (hd.Solid || hd.Encrypted)
     {
       mprintf(L"\n%12ls: ",St(MListFlags));
       if (hd.Solid)
         mprintf(L"%ls ",St(MListSolid));
       if (hd.Encrypted)
         mprintf(L"%ls ",St(MListEnc));
     }
 
     if (hd.Version)
     {
       uint Version=ParseVersionFileName(Name,false);
       if (Version!=0)
         mprintf(L"\n%12ls: %u",St(MListFileVer),Version);
     }
 
     if (hd.UnixOwnerSet)
     {
       mprintf(L"\n%12ls: ",L"Unix owner");
       if (*hd.UnixOwnerName!=0)
         mprintf(L"%ls:",GetWide(hd.UnixOwnerName));
       if (*hd.UnixGroupName!=0)
         mprintf(L"%ls",GetWide(hd.UnixGroupName));
       if ((*hd.UnixOwnerName!=0 || *hd.UnixGroupName!=0) && (hd.UnixOwnerNumeric || hd.UnixGroupNumeric))
         mprintf(L"  ");
       if (hd.UnixOwnerNumeric)
         mprintf(L"#%d:",hd.UnixOwnerID);
       if (hd.UnixGroupNumeric)
         mprintf(L"#%d:",hd.UnixGroupID);
     }
 
     mprintf(L"\n");
     return;
   }
 
   mprintf(L"\n%c%10ls %9ls ",hd.Encrypted ? '*' : ' ',AttrStr,UnpSizeText);
 
   if (Verbose)
     mprintf(L"%9ls %4ls ",PackSizeText,RatioStr);
 
   mprintf(L" %ls  ",DateStr);
 
   if (Verbose)
   {
     if (hd.FileHash.Type==HASH_CRC32)
       mprintf(L"%8.8X  ",hd.FileHash.CRC32);
     else
       if (hd.FileHash.Type==HASH_BLAKE2)
       {
         byte *S=hd.FileHash.Digest;
         mprintf(L"%02x%02x..%02x  ",S[0],S[1],S[31]);
       }
       else
         mprintf(L"????????  ");
   }
   mprintf(L"%ls",Name);
 }
 
+/*
+void ListSymLink(Archive &Arc)
+{
+  if (Arc.FileHead.HSType==HSYS_UNIX && (Arc.FileHead.FileAttr & 0xF000)==0xA000)
+    if (Arc.FileHead.Encrypted)
+    {
+      // Link data are encrypted. We would need to ask for password
+      // and initialize decryption routine to display the link target.
+      mprintf(L"\n%22ls %ls",L"-->",L"*<-?->");
+    }
+    else
+    {
+      char FileName[NM];
+      uint DataSize=(uint)Min(Arc.FileHead.PackSize,sizeof(FileName)-1);
+      Arc.Read(FileName,DataSize);
+      FileName[DataSize]=0;
+      mprintf(L"\n%22ls %ls",L"-->",GetWide(FileName));
+    }
+}
+*/
 
 void ListFileAttr(uint A,HOST_SYSTEM_TYPE HostType,wchar *AttrStr,size_t AttrSize)
 {
diff --git a/makefile b/makefile
index 4f46c2a..f70755f 100644
--- a/makefile
+++ b/makefile
@@ -3,7 +3,7 @@
 
 # Linux using GCC
 CXX=c++
-CXXFLAGS=-O2
+CXXFLAGS=-O2 -Wno-logical-op-parentheses -Wno-switch -Wno-dangling-else
 LIBFLAGS=-fPIC
 DEFINES=-D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -DRAR_SMP
 STRIP=strip
diff --git a/pathfn.cpp b/pathfn.cpp
index a40389c..2868067 100644
--- a/pathfn.cpp
+++ b/pathfn.cpp
@@ -252,40 +252,40 @@ void GetRarDataPath(wchar *Path,size_t MaxSize,bool Create)
 #ifndef SFX_MODULE
 bool EnumConfigPaths(uint Number,wchar *Path,size_t MaxSize,bool Create)
 {
 #ifdef _UNIX
   static const wchar *ConfPath[]={
     L"/etc", L"/etc/rar", L"/usr/lib", L"/usr/local/lib", L"/usr/local/etc"
   };
   if (Number==0)
   {
     char *EnvStr=getenv("HOME");
     if (EnvStr!=NULL)
-      GetWideName(EnvStr,NULL,Path,MaxSize);
+      CharToWide(EnvStr,Path,MaxSize);
     else
-      wcsncpyz(Path, ConfPath[0], MaxSize);
+      wcsncpyz(Path,ConfPath[0],MaxSize);
     return true;
   }
   Number--;
   if (Number>=ASIZE(ConfPath))
     return false;
   wcsncpyz(Path,ConfPath[Number], MaxSize);
   return true;
 #elif defined(_WIN_ALL)
   if (Number>1)
     return false;
   if (Number==0)
     GetRarDataPath(Path,MaxSize,Create);
   else
   {
     GetModuleFileName(NULL,Path,(DWORD)MaxSize);
     RemoveNameFromPath(Path);
   }
   return true;
 #else
   return false;
 #endif
 }
 #endif
 
 
 #ifndef SFX_MODULE
diff --git a/rartypes.hpp b/rartypes.hpp
index 67cfdcc..1ec97c9 100644
--- a/rartypes.hpp
+++ b/rartypes.hpp
@@ -13,20 +13,23 @@ typedef int64_t          int64;  // Signed 64 bits exactly.
 typedef wchar_t          wchar;  // Unicode character
 
 // Get lowest 16 bits.
 #define GET_SHORT16(x) (sizeof(ushort)==2 ? (ushort)(x):((x)&0xffff))
 
 // Make 64 bit integer from two 32 bit.
-#define UINT32TO64(high,low) ((((uint64)(high))<<32)+((uint64)low))
+#define INT32TO64(high,low) ((((uint64)(high))<<32)+((uint64)low))
+
+// Maximum int64 value.
+#define MAX_INT64 int64(INT32TO64(0x7fffffff,0xffffffff))
 
 // Special int64 value, large enough to never be found in real life.
 // We use it in situations, when we need to indicate that parameter 
 // is not defined and probably should be calculated inside of function.
 // Lower part is intentionally 0x7fffffff, not 0xffffffff, to make it 
 // compatible with 32 bit int64.
-#define INT64NDF UINT32TO64(0x7fffffff,0x7fffffff)
+#define INT64NDF INT32TO64(0x7fffffff,0x7fffffff)
 
 // Maximum uint64 value.
-#define MAX_UINT64 UINT32TO64(0xffffffff,0xffffffff)
+#define MAX_UINT64 INT32TO64(0xffffffff,0xffffffff)
 #define UINT64NDF MAX_UINT64
 
 #endif
diff --git a/rawint.hpp b/rawint.hpp
index 9e521e0..3037988 100644
--- a/rawint.hpp
+++ b/rawint.hpp
@@ -27,9 +27,9 @@ inline uint32 RawGet4(const void *Data)
 inline uint64 RawGet8(const void *Data)
 {
 #if defined(BIG_ENDIAN) || !defined(ALLOW_MISALIGNED)
   byte *D=(byte *)Data;
-  return UINT32TO64(RawGet4(D+4),RawGet4(D));
+  return INT32TO64(RawGet4(D+4),RawGet4(D));
 #else
   return *(uint64 *)Data;
 #endif
 }
diff --git a/rawread.cpp b/rawread.cpp
index 6099720..d99bac8 100644
--- a/rawread.cpp
+++ b/rawread.cpp
@@ -108,7 +108,7 @@ uint RawRead::Get4()
 uint64 RawRead::Get8()
 {
   uint Low=Get4(),High=Get4();
-  return UINT32TO64(High,Low);
+  return INT32TO64(High,Low);
 }
 
 
diff --git a/rdwrfn.cpp b/rdwrfn.cpp
index bb1902a..f75f664 100644
--- a/rdwrfn.cpp
+++ b/rdwrfn.cpp
@@ -14,24 +14,25 @@ ComprDataIO::ComprDataIO()
 void ComprDataIO::Init()
 {
   UnpackFromMemory=false;
   UnpackToMemory=false;
   UnpPackedSize=0;
   ShowProgress=true;
   TestMode=false;
   SkipUnpCRC=false;
+  NoFileHeader=false;
   PackVolume=false;
   UnpVolume=false;
   NextVolumeMissing=false;
   SrcFile=NULL;
   DestFile=NULL;
   UnpWrSize=0;
   Command=NULL;
   Encryption=false;
   Decryption=false;
   CurPackRead=CurPackWrite=CurUnpRead=CurUnpWrite=0;
   LastPercent=-1;
   SubHead=NULL;
   SubHeadPos=NULL;
   CurrentCommand=0;
   ProcessedArcSize=TotalArcSize=0;
 }
@@ -51,104 +52,104 @@ ComprDataIO::~ComprDataIO()
 int ComprDataIO::UnpRead(byte *Addr,size_t Count)
 {
 #ifndef RAR_NOCRYPT
   // In case of encryption we need to align read size to encryption 
   // block size. We can do it by simple masking, because unpack read code
   // always reads more than CRYPT_BLOCK_SIZE, so we do not risk to make it 0.
   if (Decryption)
     Count &= ~CRYPT_BLOCK_MASK;
 #endif
   
   int ReadSize=0,TotalRead=0;
   byte *ReadAddr;
   ReadAddr=Addr;
   while (Count > 0)
   {
     Archive *SrcArc=(Archive *)SrcFile;
 
     if (UnpackFromMemory)
     {
       memcpy(Addr,UnpackFromMemoryAddr,UnpackFromMemorySize);
       ReadSize=(int)UnpackFromMemorySize;
       UnpackFromMemorySize=0;
     }
     else
     {
-      size_t SizeToRead=Count>UnpPackedSize ? (size_t)UnpPackedSize:Count;
+      size_t SizeToRead=((int64)Count>UnpPackedSize) ? (size_t)UnpPackedSize:Count;
       if (SizeToRead > 0)
       {
-        if (UnpVolume && Decryption && Count>UnpPackedSize)
+        if (UnpVolume && Decryption && (int64)Count>UnpPackedSize)
         {
           // We need aligned blocks for decryption and we want "Keep broken
           // files" to work efficiently with missing encrypted volumes.
           // So for last data block in volume we adjust the size to read to
           // next equal or smaller block producing aligned total block size.
           // So we'll ask for next volume only when processing few unaligned
           // bytes left in the end, when most of data is already extracted.
           size_t NewTotalRead = TotalRead + SizeToRead;
           size_t Adjust = NewTotalRead - (NewTotalRead  & ~CRYPT_BLOCK_MASK);
           size_t NewSizeToRead = SizeToRead - Adjust;
           if ((int)NewSizeToRead > 0)
             SizeToRead = NewSizeToRead;
         }
 
         if (!SrcFile->IsOpened())
           return -1;
         ReadSize=SrcFile->Read(ReadAddr,SizeToRead);
         FileHeader *hd=SubHead!=NULL ? SubHead:&SrcArc->FileHead;
-        if (hd->SplitAfter)
+        if (!NoFileHeader && hd->SplitAfter)
           PackedDataHash.Update(ReadAddr,ReadSize);
       }
     }
     CurUnpRead+=ReadSize;
     TotalRead+=ReadSize;
 #ifndef NOVOLUME
     // These variable are not used in NOVOLUME mode, so it is better
     // to exclude commands below to avoid compiler warnings.
     ReadAddr+=ReadSize;
     Count-=ReadSize;
 #endif
     UnpPackedSize-=ReadSize;
 
     // Do not ask for next volume if we read something from current volume.
     // If next volume is missing, we need to process all data from current
     // volume before aborting. It helps to recover all possible data
     // in "Keep broken files" mode. But if we process encrypted data,
     // we ask for next volume also if we have non-aligned encryption block.
     // Since we adjust data size for decryption earlier above,
     // it does not hurt "Keep broken files" mode efficiency.
     if (UnpVolume && UnpPackedSize == 0 && 
         (ReadSize==0 || Decryption && (TotalRead & CRYPT_BLOCK_MASK) != 0) )
     {
 #ifndef NOVOLUME
       if (!MergeArchive(*SrcArc,this,true,CurrentCommand))
 #endif
       {
         NextVolumeMissing=true;
         return -1;
       }
     }
     else
       break;
   }
   Archive *SrcArc=(Archive *)SrcFile;
   if (SrcArc!=NULL)
     ShowUnpRead(SrcArc->CurBlockPos+CurUnpRead,UnpArcSize);
   if (ReadSize!=-1)
   {
     ReadSize=TotalRead;
 #ifndef RAR_NOCRYPT
     if (Decryption)
       Decrypt->DecryptBlock(Addr,ReadSize);
 #endif
   }
   Wait();
   return ReadSize;
 }
 
 
 #if defined(RARDLL) && defined(_MSC_VER) && !defined(_WIN_64)
 // Disable the run time stack check for unrar.dll, so we can manipulate
 // with ProcessDataProc call type below. Run time check would intercept
 // a wrong ESP before we restore it.
 #pragma runtime_checks( "s", off )
 #endif
diff --git a/rdwrfn.hpp b/rdwrfn.hpp
index a3e6a25..070010e 100644
--- a/rdwrfn.hpp
+++ b/rdwrfn.hpp
@@ -12,86 +12,88 @@ class Unpack;
 class ComprDataIO
 {
   private:
     void ShowUnpRead(int64 ArcPos,int64 ArcSize);
     void ShowUnpWrite();
 
 
     bool UnpackFromMemory;
     size_t UnpackFromMemorySize;
     byte *UnpackFromMemoryAddr;
 
     bool UnpackToMemory;
     size_t UnpackToMemorySize;
     byte *UnpackToMemoryAddr;
 
     size_t UnpWrSize;
     byte *UnpWrAddr;
 
-    uint64 UnpPackedSize;
+    int64 UnpPackedSize;
 
     bool ShowProgress;
     bool TestMode;
     bool SkipUnpCRC;
+    bool NoFileHeader;
 
     File *SrcFile;
     File *DestFile;
 
     CmdAdd *Command;
 
     FileHeader *SubHead;
     int64 *SubHeadPos;
 
 #ifndef RAR_NOCRYPT
     CryptData *Crypt;
     CryptData *Decrypt;
 #endif
 
 
     int LastPercent;
 
     wchar CurrentCommand;
 
   public:
     ComprDataIO();
     ~ComprDataIO();
     void Init();
     int UnpRead(byte *Addr,size_t Count);
     void UnpWrite(byte *Addr,size_t Count);
     void EnableShowProgress(bool Show) {ShowProgress=Show;}
     void GetUnpackedData(byte **Data,size_t *Size);
-    void SetPackedSizeToRead(uint64 Size) {UnpPackedSize=Size;}
+    void SetPackedSizeToRead(int64 Size) {UnpPackedSize=Size;}
     void SetTestMode(bool Mode) {TestMode=Mode;}
     void SetSkipUnpCRC(bool Skip) {SkipUnpCRC=Skip;}
+    void SetNoFileHeader(bool Mode) {NoFileHeader=Mode;}
     void SetFiles(File *SrcFile,File *DestFile);
     void SetCommand(CmdAdd *Cmd) {Command=Cmd;}
     void SetSubHeader(FileHeader *hd,int64 *Pos) {SubHead=hd;SubHeadPos=Pos;}
     void SetEncryption(bool Encrypt,CRYPT_METHOD Method,SecPassword *Password,
          const byte *Salt,const byte *InitV,uint Lg2Cnt,byte *HashKey,byte *PswCheck);
     void SetAV15Encryption();
     void SetCmt13Encryption();
     void SetUnpackToMemory(byte *Addr,uint Size);
     void SetCurrentCommand(wchar Cmd) {CurrentCommand=Cmd;}
 
 
     bool PackVolume;
     bool UnpVolume;
     bool NextVolumeMissing;
     int64 UnpArcSize;
-    uint64 CurPackRead,CurPackWrite,CurUnpRead,CurUnpWrite;
+    int64 CurPackRead,CurPackWrite,CurUnpRead,CurUnpWrite;
 
 
     // Size of already processed archives.
     // Used to calculate the total operation progress.
     int64 ProcessedArcSize;
 
     int64 TotalArcSize;
 
     DataHash PackedDataHash; // Packed write and unpack read hash.
     DataHash PackHash; // Pack read hash.
     DataHash UnpHash;  // Unpack write hash.
 
     bool Encryption;
     bool Decryption;
 };
 
 #endif
diff --git a/recvol5.cpp b/recvol5.cpp
index 8272b07..fddc25d 100644
--- a/recvol5.cpp
+++ b/recvol5.cpp
@@ -136,285 +136,287 @@ void RecVolumes5::ProcessAreaRS(RecRSThreadData *td)
 bool RecVolumes5::Restore(RAROptions *Cmd,const wchar *Name,bool Silent)
 {
   wchar ArcName[NM];
   wcsncpyz(ArcName,Name,ASIZE(ArcName));
 
   wchar *Num=GetVolNumPart(ArcName);
+  if (Num==ArcName)
+    return false; // Number part is missing in the name.
   while (Num>ArcName && IsDigit(*(Num-1)))
     Num--;
   wcsncpyz(Num,L"*.*",ASIZE(ArcName)-(Num-ArcName));
   
   wchar FirstVolName[NM];
   *FirstVolName=0;
 
   int64 RecFileSize=0;
 
   FindFile VolFind;
   VolFind.SetMask(ArcName);
   FindData fd;
   uint FoundRecVolumes=0;
   while (VolFind.Next(&fd))
   {
     Wait();
 
     Archive *Vol=new Archive(Cmd);
     int ItemPos=-1;
     if (Vol->WOpen(fd.Name))
     {
       if (CmpExt(fd.Name,L"rev"))
       {
         uint RecNum=ReadHeader(Vol,FoundRecVolumes==0);
         if (RecNum!=0)
         {
           if (FoundRecVolumes==0)
             RecFileSize=Vol->FileLength();
 
           ItemPos=RecNum;
           FoundRecVolumes++;
         }
       }
       else
         if (Vol->IsArchive(true) && (Vol->SFXSize>0 || CmpExt(fd.Name,L"rar")))
         {
           if (!Vol->Volume && !Vol->BrokenHeader)
           {
             uiMsg(UIERROR_NOTVOLUME,ArcName);
             return false;
           }
           // We work with archive as with raw data file, so we do not want
           // to spend time to QOpen I/O redirection.
           Vol->QOpenUnload();
       
           Vol->Seek(0,SEEK_SET);
 
           // RAR volume found. Get its number, store the handle in appropriate
           // array slot, clean slots in between if we had to grow the array.
           wchar *Num=GetVolNumPart(fd.Name);
           uint VolNum=0;
           for (uint K=1;Num>=fd.Name && IsDigit(*Num);K*=10,Num--)
             VolNum+=(*Num-'0')*K;
           if (VolNum==0 || VolNum>MaxVolumes)
             continue;
           size_t CurSize=RecItems.Size();
           if (VolNum>CurSize)
           {
             RecItems.Alloc(VolNum);
             for (size_t I=CurSize;I<VolNum;I++)
               RecItems[I].f=NULL;
           }
           ItemPos=VolNum-1;
 
           if (*FirstVolName==0)
             VolNameToFirstName(fd.Name,FirstVolName,ASIZE(FirstVolName),true);
         }
     }
     if (ItemPos==-1)
       delete Vol; // Skip found file, it is not RAR or REV volume.
     else
       if ((uint)ItemPos<RecItems.Size()) // Check if found more REV than needed.
       {
         // Store found RAR or REV volume.
         RecVolItem *Item=RecItems+ItemPos;
         Item->f=Vol;
         Item->New=false;
         wcsncpyz(Item->Name,fd.Name,ASIZE(Item->Name));
       }
   }
 
   if (!Silent || FoundRecVolumes!=0)
     uiMsg(UIMSG_RECVOLFOUND,FoundRecVolumes);
   if (FoundRecVolumes==0)
     return false;
 
   uiMsg(UIMSG_RECVOLCALCCHECKSUM);
 
   MissingVolumes=0;
   for (uint I=0;I<TotalCount;I++)
   {
     RecVolItem *Item=&RecItems[I];
     if (Item->f!=NULL)
     {
       uiMsg(UIMSG_STRING,Item->Name);
 
       uint RevCRC;
       CalcFileSum(Item->f,&RevCRC,NULL,Cmd->Threads,INT64NDF,CALCFSUM_CURPOS);
       Item->Valid=RevCRC==Item->CRC;
       if (!Item->Valid)
       {
         uiMsg(UIMSG_CHECKSUM,Item->Name);
 
         // Close only corrupt REV volumes here. We'll close and rename corrupt
         // RAR volumes later, if we'll know that recovery is possible.
         if (I>=DataCount)
         {
           Item->f->Close();
           Item->f=NULL;
           FoundRecVolumes--;
         }
       }
     }
     if (I<DataCount && (Item->f==NULL || !Item->Valid))
       MissingVolumes++;
   }
 
   uiMsg(UIMSG_RECVOLMISSING,MissingVolumes);
 
   if (MissingVolumes==0)
   {
     uiMsg(UIERROR_RECVOLALLEXIST);
     return false;
   }
 
   if (MissingVolumes>FoundRecVolumes)
   {
     uiMsg(UIERROR_RECVOLFOUND,FoundRecVolumes); // Intentionally not displayed in console mode.
     uiMsg(UIERROR_RECVOLCANNOTFIX);
     return false;
   }
 
   uiMsg(UIMSG_RECONSTRUCTING);
 
   // Create missing and rename bad volumes.
   uint64 MaxVolSize=0;
   for (uint I=0;I<DataCount;I++)
   {
     RecVolItem *Item=&RecItems[I];
     if (Item->FileSize>MaxVolSize)
       MaxVolSize=Item->FileSize;
     if (Item->f!=NULL && !Item->Valid)
     {
       Item->f->Close();
 
       wchar NewName[NM];
       wcscpy(NewName,Item->Name);
       wcscat(NewName,L".bad");
 
       uiMsg(UIMSG_BADARCHIVE,Item->Name);
       uiMsg(UIMSG_RENAMING,Item->Name,NewName);
       RenameFile(Item->Name,NewName);
       delete Item->f;
       Item->f=NULL;
     }
 
     if ((Item->New=(Item->f==NULL))) // Additional parentheses to avoid GCC warning.
     {
       wcsncpyz(Item->Name,FirstVolName,ASIZE(Item->Name));
       uiMsg(UIMSG_CREATING,Item->Name);
       uiMsg(UIEVENT_NEWARCHIVE,Item->Name);
       File *NewVol=new File;
       bool UserReject;
       if (!FileCreate(Cmd,NewVol,Item->Name,ASIZE(Item->Name),&UserReject))
       {
         if (!UserReject)
           ErrHandler.CreateErrorMsg(Item->Name);
         ErrHandler.Exit(UserReject ? RARX_USERBREAK:RARX_CREATE);
       }
       NewVol->Prealloc(Item->FileSize);
       Item->f=NewVol;
       Item->New=true;
     }
     NextVolumeName(FirstVolName,ASIZE(FirstVolName),false);
   }
 
 
   int64 ProcessedSize=0;
   int LastPercent=-1;
   mprintf(L"     ");
 
   // Even though we already preliminary calculated missing volume number,
   // let's do it again now, when we have the final and exact information.
   MissingVolumes=0;
 
   ValidFlags=new bool[TotalCount];
   for (uint I=0;I<TotalCount;I++)
   {
     ValidFlags[I]=RecItems[I].f!=NULL && !RecItems[I].New;
     if (I<DataCount && !ValidFlags[I])
       MissingVolumes++;
   }
 
   // Size of per file buffer.
   RecBufferSize=TotalBufferSize/MissingVolumes;
   if ((RecBufferSize&1)==1) // Must be even for our RS16 codec.
     RecBufferSize--;
 #ifdef USE_SSE
   RecBufferSize&=~(SSE_ALIGNMENT-1); // Align for SSE.
 #endif
 
   uint *Data=new uint[TotalCount];
 
   RSCoder16 RS;
   if (!RS.Init(DataCount,RecCount,ValidFlags))
   {
     delete[] ValidFlags;
     delete[] Data;
     return false; // Should not happen, we check parameter validity above.
   }
 
   RealReadBuffer=new byte[RecBufferSize+SSE_ALIGNMENT];
   byte *ReadBuf=(byte *)ALIGN_VALUE(RealReadBuffer,SSE_ALIGNMENT);
 
   while (true)
   {
     Wait();
 
     int MaxRead=0;
     for (uint I=0,J=DataCount;I<DataCount;I++)
     {
       uint VolNum=I;
       if (!ValidFlags[I]) // If next RAR volume is missing or invalid.
       {
         while (!ValidFlags[J]) // Find next valid REV volume.
           J++;
         VolNum=J++; // Use next valid REV volume data instead of RAR.
       }
       RecVolItem *Item=RecItems+VolNum;
 
       byte *B=&ReadBuf[0];
       int ReadSize=0;
       if (Item->f!=NULL && !Item->New)
         ReadSize=Item->f->Read(B,RecBufferSize);
       if (ReadSize!=RecBufferSize)
         memset(B+ReadSize,0,RecBufferSize-ReadSize);
       if (ReadSize>MaxRead)
         MaxRead=ReadSize;
 
       // We can have volumes of different size. Let's use data chunk
       // for largest volume size.
       uint DataToProcess=(uint)Min(RecBufferSize,MaxVolSize-ProcessedSize);
       ProcessRS(Cmd,I,B,DataToProcess,false);
     }
     if (MaxRead==0)
       break;
 
     for (uint I=0,J=0;I<DataCount;I++)
       if (!ValidFlags[I])
       {
         RecVolItem *Item=RecItems+I;
         size_t WriteSize=(size_t)Min(MaxRead,Item->FileSize);
         Item->f->Write(Buf+(J++)*RecBufferSize,WriteSize);
         Item->FileSize-=WriteSize;
       }
 
     int CurPercent=ToPercent(ProcessedSize,RecFileSize);
     if (!Cmd->DisablePercentage && CurPercent!=LastPercent)
     {
       uiProcessProgress("RV",ProcessedSize,RecFileSize);
       LastPercent=CurPercent;
     }
     ProcessedSize+=MaxRead;
   }
 
   for (uint I=0;I<TotalCount;I++)
     if (RecItems[I].f!=NULL)
       RecItems[I].f->Close();
 
   delete[] ValidFlags;
   delete[] Data;
 #if !defined(SILENT)
   if (!Cmd->DisablePercentage)
     mprintf(L"\b\b\b\b100%%");
   if (!Silent && !Cmd->DisableDone)
     mprintf(St(MDone));
 #endif
   return true;
 }
diff --git a/smallfn.cpp b/smallfn.cpp
index 624dae6..81259d0 100644
--- a/smallfn.cpp
+++ b/smallfn.cpp
@@ -1,19 +1,19 @@
 #include "rar.hpp"
 
-uint ToPercent(uint64 N1,uint64 N2)
+int ToPercent(int64 N1,int64 N2)
 {
   if (N2<N1)
     return 100;
   return ToPercentUnlim(N1,N2);
 }
 
 
 // Allows the percent larger than 100.
-uint ToPercentUnlim(uint64 N1,uint64 N2)
+int ToPercentUnlim(int64 N1,int64 N2)
 {
   if (N2==0)
     return 0;
-  return uint(N1*100/N2);
+  return (int)(N1*100/N2);
 }
 
 
diff --git a/smallfn.hpp b/smallfn.hpp
index d3bcef1..f53daa8 100644
--- a/smallfn.hpp
+++ b/smallfn.hpp
@@ -1,8 +1,8 @@
 #ifndef _RAR_SMALLFN_
 #define _RAR_SMALLFN_
 
-uint ToPercent(uint64 N1,uint64 N2);
-uint ToPercentUnlim(uint64 N1,uint64 N2);
+int ToPercent(int64 N1,int64 N2);
+int ToPercentUnlim(int64 N1,int64 N2);
 void RARInitData();
 
 #endif
diff --git a/timefn.cpp b/timefn.cpp
index 66779eb..63f4660 100644
--- a/timefn.cpp
+++ b/timefn.cpp
@@ -3,65 +3,65 @@
 void RarTime::GetLocal(RarLocalTime *lt)
 {
 #ifdef _WIN_ALL
   FILETIME ft;
   GetWinFT(&ft);
   FILETIME lft;
 
   if (WinNT() < WNT_VISTA)
   {
     // SystemTimeToTzSpecificLocalTime based code produces 1 hour error on XP.
     FileTimeToLocalFileTime(&ft,&lft);
   }
   else
   {
     // We use these functions instead of FileTimeToLocalFileTime according to
     // MSDN recommendation: "To account for daylight saving time
     // when converting a file time to a local time ..."
     SYSTEMTIME st1,st2;
     FileTimeToSystemTime(&ft,&st1);
     SystemTimeToTzSpecificLocalTime(NULL,&st1,&st2);
     SystemTimeToFileTime(&st2,&lft);
 
     // Correct precision loss (low 4 decimal digits) in FileTimeToSystemTime.
     FILETIME rft;
     SystemTimeToFileTime(&st1,&rft);
-    uint64 Corrected=UINT32TO64(ft.dwHighDateTime,ft.dwLowDateTime)-
-                     UINT32TO64(rft.dwHighDateTime,rft.dwLowDateTime)+
-                     UINT32TO64(lft.dwHighDateTime,lft.dwLowDateTime);
+    uint64 Corrected=INT32TO64(ft.dwHighDateTime,ft.dwLowDateTime)-
+                     INT32TO64(rft.dwHighDateTime,rft.dwLowDateTime)+
+                     INT32TO64(lft.dwHighDateTime,lft.dwLowDateTime);
     lft.dwLowDateTime=(DWORD)Corrected;
     lft.dwHighDateTime=(DWORD)(Corrected>>32);
   }
 
   SYSTEMTIME st;
   FileTimeToSystemTime(&lft,&st);
   lt->Year=st.wYear;
   lt->Month=st.wMonth;
   lt->Day=st.wDay;
   lt->Hour=st.wHour;
   lt->Minute=st.wMinute;
   lt->Second=st.wSecond;
   lt->wDay=st.wDayOfWeek;
   lt->yDay=lt->Day-1;
 
   static int mdays[12]={31,28,31,30,31,30,31,31,30,31,30,31};
   for (uint I=1;I<lt->Month && I<=ASIZE(mdays);I++)
     lt->yDay+=mdays[I-1];
 
   if (lt->Month>2 && IsLeapYear(lt->Year))
     lt->yDay++;
 #else
   time_t ut=GetUnix();
   struct tm *t;
   t=localtime(&ut);
 
   lt->Year=t->tm_year+1900;
   lt->Month=t->tm_mon+1;
   lt->Day=t->tm_mday;
   lt->Hour=t->tm_hour;
   lt->Minute=t->tm_min;
   lt->Second=t->tm_sec;
   lt->wDay=t->tm_wday;
   lt->yDay=t->tm_yday;
 #endif
   lt->Reminder=(itime % TICKS_PER_SECOND);
 }
@@ -70,63 +70,63 @@ void RarTime::GetLocal(RarLocalTime *lt)
 void RarTime::SetLocal(RarLocalTime *lt)
 {
 #ifdef _WIN_ALL
   SYSTEMTIME st;
   st.wYear=lt->Year;
   st.wMonth=lt->Month;
   st.wDay=lt->Day;
   st.wHour=lt->Hour;
   st.wMinute=lt->Minute;
   st.wSecond=lt->Second;
   st.wMilliseconds=0;
   st.wDayOfWeek=0;
   FILETIME lft;
   if (SystemTimeToFileTime(&st,&lft))
   {
     FILETIME ft;
 
     if (WinNT() < WNT_VISTA)
     {
       // TzSpecificLocalTimeToSystemTime based code produces 1 hour error on XP.
       LocalFileTimeToFileTime(&lft,&ft);
     }
     else
     {
       // Reverse procedure which we do in GetLocal.
       SYSTEMTIME st1,st2;
       FileTimeToSystemTime(&lft,&st2); // st2 might be unequal to st, because we added lt->Reminder to lft.
       TzSpecificLocalTimeToSystemTime(NULL,&st2,&st1);
       SystemTimeToFileTime(&st1,&ft);
 
       // Correct precision loss (low 4 decimal digits) in FileTimeToSystemTime.
       FILETIME rft;
       SystemTimeToFileTime(&st2,&rft);
-      uint64 Corrected=UINT32TO64(lft.dwHighDateTime,lft.dwLowDateTime)-
-                       UINT32TO64(rft.dwHighDateTime,rft.dwLowDateTime)+
-                       UINT32TO64(ft.dwHighDateTime,ft.dwLowDateTime);
+      uint64 Corrected=INT32TO64(lft.dwHighDateTime,lft.dwLowDateTime)-
+                       INT32TO64(rft.dwHighDateTime,rft.dwLowDateTime)+
+                       INT32TO64(ft.dwHighDateTime,ft.dwLowDateTime);
       ft.dwLowDateTime=(DWORD)Corrected;
       ft.dwHighDateTime=(DWORD)(Corrected>>32);
     }
 
     SetWinFT(&ft);
   }
   else
     Reset();
 #else
   struct tm t;
 
   t.tm_sec=lt->Second;
   t.tm_min=lt->Minute;
   t.tm_hour=lt->Hour;
   t.tm_mday=lt->Day;
   t.tm_mon=lt->Month-1;
   t.tm_year=lt->Year-1900;
   t.tm_isdst=-1;
   SetUnix(mktime(&t));
 #endif
   itime+=lt->Reminder;
 }
 
 
 
 
 #ifdef _WIN_ALL
@@ -183,17 +183,17 @@ void RarTime::SetUnix(time_t ut)
 // Get the high precision Unix time in nanoseconds since 01-01-1970.
 uint64 RarTime::GetUnixNS()
 {
   // 11644473600000000000 - number of ns between 01-01-1601 and 01-01-1970.
-  uint64 ushift=UINT32TO64(0xA1997B0B,0x4C6A0000);
+  uint64 ushift=INT32TO64(0xA1997B0B,0x4C6A0000);
   return itime*(1000000000/TICKS_PER_SECOND)-ushift;
 }
 
 
 // Set the high precision Unix time in nanoseconds since 01-01-1970.
 void RarTime::SetUnixNS(uint64 ns)
 {
   // 11644473600000000000 - number of ns between 01-01-1601 and 01-01-1970.
-  uint64 ushift=UINT32TO64(0xA1997B0B,0x4C6A0000);
+  uint64 ushift=INT32TO64(0xA1997B0B,0x4C6A0000);
   itime=(ns+ushift)/(1000000000/TICKS_PER_SECOND);
 }
 
diff --git a/ulinks.cpp b/ulinks.cpp
index ad2d9cc..1656824 100644
--- a/ulinks.cpp
+++ b/ulinks.cpp
@@ -48,31 +48,34 @@ static bool IsFullPath(const char *PathA) // Unix ASCII version.
 bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)
 {
   char Target[NM];
   if (IsLink(Arc.FileHead.FileAttr))
   {
-    size_t DataSize=(size_t)Min(Arc.FileHead.PackSize,ASIZE(Target)-1);
-    DataIO.UnpRead((byte *)Target,DataSize);
+    size_t DataSize=(size_t)Arc.FileHead.PackSize;
+    if (DataSize>ASIZE(Target)-1)
+      return false;
+    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)
+      return false;
     Target[DataSize]=0;
 
     DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);
     DataIO.UnpHash.Update(Target,strlen(Target));
     DataIO.UnpHash.Result(&Arc.FileHead.FileHash);
 
     // Return true in case of bad checksum, so link will be processed further
     // and extraction routine will report the checksum error.
     if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))
       return true;
 
     wchar TargetW[NM];
     CharToWide(Target,TargetW,ASIZE(TargetW));
     // Check for *TargetW==0 to catch CharToWide failure.
     // Use Arc.FileHead.FileName instead of LinkName, since LinkName
     // can include the destination path as a prefix, which can
     // confuse IsRelativeSymlinkSafe algorithm.
     if (!Cmd->AbsoluteLinks && (*TargetW==0 || IsFullPath(TargetW) ||
         !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))
       return false;
     return UnixSymlink(Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);
   }
   return false;
 }
diff --git a/unicode.cpp b/unicode.cpp
index b426082..8ce752a 100644
--- a/unicode.cpp
+++ b/unicode.cpp
@@ -20,45 +20,63 @@ static const uint MappedStringMark=0xFFFE;
 bool WideToChar(const wchar *Src,char *Dest,size_t DestSize)
 {
   bool RetCode=true;
   *Dest=0; // Set 'Dest' to zero just in case the conversion will fail.
 
 #ifdef _WIN_ALL
   if (WideCharToMultiByte(CP_ACP,0,Src,-1,Dest,(int)DestSize,NULL,NULL)==0)
     RetCode=false;
 
 // wcstombs is broken in Android NDK r9.
 #elif defined(_APPLE)
   WideToUtf(Src,Dest,DestSize);
 
 #elif defined(MBFUNCTIONS)
   if (!WideToCharMap(Src,Dest,DestSize,RetCode))
   {
     mbstate_t ps; // Use thread safe external state based functions.
     memset (&ps, 0, sizeof(ps));
     const wchar *SrcParam=Src; // wcsrtombs can change the pointer.
+
+    // Some implementations of wcsrtombs can cause memory analyzing tools
+    // like valgrind to report uninitialized data access. It happens because
+    // internally these implementations call SSE4 based wcslen function,
+    // which reads 16 bytes at once including those beyond of trailing 0.
     size_t ResultingSize=wcsrtombs(Dest,&SrcParam,DestSize,&ps);
+
+    if (ResultingSize==(size_t)-1 && errno==EILSEQ)
+    {
+      // Aborted on inconvertible character not zero terminating the result.
+      // EILSEQ helps to distinguish it from small output buffer abort.
+      // We want to convert as much as we can, so we clean the output buffer
+      // and repeat conversion.
+      memset (&ps, 0, sizeof(ps));
+      SrcParam=Src; // wcsrtombs can change the pointer.
+      memset(Dest,0,DestSize);
+      ResultingSize=wcsrtombs(Dest,&SrcParam,DestSize,&ps);
+    }
+
     if (ResultingSize==(size_t)-1)
       RetCode=false;
     if (ResultingSize==0 && *Src!=0)
       RetCode=false;
   }
 #else
   for (int I=0;I<DestSize;I++)
   {
     Dest[I]=(char)Src[I];
     if (Src[I]==0)
       break;
   }
 #endif
   if (DestSize>0)
     Dest[DestSize-1]=0;
   
   // We tried to return the empty string if conversion is failed,
   // but it does not work well. WideCharToMultiByte returns 'failed' code
   // and partially converted string even if we wanted to convert only a part
   // of string and passed DestSize smaller than required for fully converted
   // string. Such call is the valid behavior in RAR code and we do not expect
   // the empty string in this case.
 
   return RetCode;
 }
@@ -113,97 +131,96 @@ bool CharToWide(const char *Src,wchar *Dest,size_t DestSize)
 #if defined(_UNIX) && defined(MBFUNCTIONS)
 // Convert and restore mapped inconvertible Unicode characters. 
 // We use it for extended ASCII names in Unix.
 bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)
 {
   // String with inconvertible characters mapped to private use Unicode area
   // must have the mark code somewhere.
   if (wcschr(Src,(wchar)MappedStringMark)==NULL)
     return false;
 
   Success=true;
   uint SrcPos=0,DestPos=0;
-  while (DestPos<DestSize-MB_CUR_MAX)
+  while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX)
   {
-    if (Src[SrcPos]==0)
-    {
-      Dest[DestPos]=0;
-      break;
-    }
     if (uint(Src[SrcPos])==MappedStringMark)
     {
       SrcPos++;
       continue;
     }
     // For security reasons do not restore low ASCII codes, so mapping cannot
     // be used to hide control codes like path separators.
     if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100)
       Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart);
     else
     {
       mbstate_t ps;
       memset(&ps,0,sizeof(ps));
       if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1)
+      {
+        Dest[DestPos]='_';
         Success=false;
+      }
       SrcPos++;
       memset(&ps,0,sizeof(ps));
       int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps);
       DestPos+=Max(Length,1);
     }
   }
+  Dest[Min(DestPos,DestSize-1)]=0;
   return true;
 }
 #endif
 
 
 #if defined(_UNIX) && defined(MBFUNCTIONS)
 // Convert and map inconvertible Unicode characters. 
 // We use it for extended ASCII names in Unix.
 void CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success)
 {
   // Map inconvertible characters to private use Unicode area 0xE000.
   // Mark such string by placing special non-character code before
   // first inconvertible character.
   Success=false;
   bool MarkAdded=false;
   uint SrcPos=0,DestPos=0;
   while (DestPos<DestSize)
   {
     if (Src[SrcPos]==0)
     {
-      Dest[DestPos]=0;
       Success=true;
       break;
     }
     mbstate_t ps;
     memset(&ps,0,sizeof(ps));
     if (mbrtowc(Dest+DestPos,Src+SrcPos,MB_CUR_MAX,&ps)==-1)
     {
       // For security reasons we do not want to map low ASCII characters,
       // so we do not have additional .. and path separator codes.
       if (byte(Src[SrcPos])>=0x80)
       {
         if (!MarkAdded)
         {
           Dest[DestPos++]=MappedStringMark;
           MarkAdded=true;
           if (DestPos>=DestSize)
             break;
         }
         Dest[DestPos++]=byte(Src[SrcPos++])+MapAreaStart;
       }
       else
         break;
     }
     else
     {
       memset(&ps,0,sizeof(ps));
       int Length=mbrlen(Src+SrcPos,MB_CUR_MAX,&ps);
       SrcPos+=Max(Length,1);
       DestPos++;
     }
   }
+  Dest[Min(DestPos,DestSize-1)]=0;
 }
 #endif
 
 
 // SrcSize is in wide characters, not in bytes.
diff --git a/unpack20.cpp b/unpack20.cpp
index 7ace2e4..a7a41c3 100644
--- a/unpack20.cpp
+++ b/unpack20.cpp
@@ -165,90 +165,90 @@ void Unpack::UnpWriteBuf20()
 bool Unpack::ReadTables20()
 {
   byte BitLength[BC20];
   byte Table[MC20*4];
   if (Inp.InAddr>ReadTop-25)
     if (!UnpReadBuf())
       return false;
   uint BitField=Inp.getbits();
   UnpAudioBlock=(BitField & 0x8000)!=0;
 
   if (!(BitField & 0x4000))
     memset(UnpOldTable20,0,sizeof(UnpOldTable20));
   Inp.addbits(2);
 
   uint TableSize;
   if (UnpAudioBlock)
   {
     UnpChannels=((BitField>>12) & 3)+1;
     if (UnpCurChannel>=UnpChannels)
       UnpCurChannel=0;
     Inp.addbits(2);
     TableSize=MC20*UnpChannels;
   }
   else
     TableSize=NC20+DC20+RC20;
 
   for (uint I=0;I<BC20;I++)
   {
     BitLength[I]=(byte)(Inp.getbits() >> 12);
     Inp.addbits(4);
   }
   MakeDecodeTables(BitLength,&BlockTables.BD,BC20);
   for (uint I=0;I<TableSize;)
   {
     if (Inp.InAddr>ReadTop-5)
       if (!UnpReadBuf())
         return false;
     uint Number=DecodeNumber(Inp,&BlockTables.BD);
     if (Number<16)
     {
       Table[I]=(Number+UnpOldTable20[I]) & 0xf;
       I++;
     }
     else
       if (Number==16)
       {
         uint N=(Inp.getbits() >> 14)+3;
         Inp.addbits(2);
         if (I==0)
           return false; // We cannot have "repeat previous" code at the first position.
         else
           while (N-- > 0 && I<TableSize)
           {
             Table[I]=Table[I-1];
             I++;
           }
       }
       else
       {
         uint N;
         if (Number==17)
         {
           N=(Inp.getbits() >> 13)+3;
           Inp.addbits(3);
         }
         else
         {
           N=(Inp.getbits() >> 9)+11;
           Inp.addbits(7);
         }
         while (N-- > 0 && I<TableSize)
           Table[I++]=0;
       }
   }
   TablesRead2=true;
   if (Inp.InAddr>ReadTop)
     return true;
   if (UnpAudioBlock)
     for (uint I=0;I<UnpChannels;I++)
       MakeDecodeTables(&Table[I*MC20],&MD[I],MC20);
   else
   {
     MakeDecodeTables(&Table[0],&BlockTables.LD,NC20);
     MakeDecodeTables(&Table[NC20],&BlockTables.DD,DC20);
     MakeDecodeTables(&Table[NC20+DC20],&BlockTables.RD,RC20);
   }
-  memcpy(UnpOldTable20,Table,sizeof(UnpOldTable20));
+  memcpy(UnpOldTable20,Table,TableSize);
   return true;
 }
 
