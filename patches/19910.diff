commit 030a2e78acf66c5c12e073ec3887a167da7a7195
Author: Alan Modra <amodra@gmail.com>
Date:   Wed Jan 8 11:42:36 2020 +1030

    ubsan: z8k: index 10 out of bounds for type 'unsigned int const[10]'
    
    The fix is the additional ARRAY_SIZE test, the rest just tidies
    variable types rather than adding a cast to avoid warnings.
    
    opcodes/
            * z8k-dis.c: Include libiberty.h
            (instr_data_s): Make max_fetched unsigned.
            (z8k_lookup_instr): Make nibl_index and tabl_index unsigned.
            Don't exceed byte_info bounds.
            (output_instr): Make num_bytes unsigned.
            (unpack_instr): Likewise for nibl_count and loop.
            * z8kgen.c (gas <opcode_entry_type>): Make noperands, length and
            idx unsigned.
            * z8k-opc.h: Regenerate.
    gas/
            * config/tc-z8k.c (md_begin): Make idx unsigned.
            (get_specific): Likewise for this_index.

diff --git a/gas/ChangeLog b/gas/ChangeLog
index 1c61732fab3..46ce02ee650 100644
--- a/gas/ChangeLog
+++ b/gas/ChangeLog
@@ -1,109 +1,114 @@
+2020-01-08  Alan Modra  <amodra@gmail.com>
+
+	* config/tc-z8k.c (md_begin): Make idx unsigned.
+	(get_specific): Likewise for this_index.
+
 2020-01-07  Claudiu Zissulescu  <claziss@synopsys.com>
 
 	* onfig/tc-arc.c (parse_reloc_symbol): New function.
 	(tokenize_arguments): Clean up, use parse_reloc_symbol function.
 	(md_operand): Set X_md to absent.
 	(arc_parse_name): Check for X_md.
 
 2020-01-03  Sergey Belyashov  <sergey.belyashov@gmail.com>
 
 	PR 25311
 	* as.h (TC_STRING_ESCAPES): Provide a default definition.
 	* app.c (do_scrub_chars): Use TC_STRING_ESCAPES instead of
 	NO_STRING_ESCAPES.
 	* read.c (next_char_of_string): Likewise.
 	* config/tc-ppc.h (TC_STRING_ESCAPES): Define.
 	* config/tc-z80.h (TC_STRING_ESCAPES): Define.
 
 2020-01-03  Nick Clifton  <nickc@redhat.com>
 
 	* po/sv.po: Updated Swedish translation.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* testsuite/gas/aarch64/f64mm.s: Scale index of LD1RO{H,W,D}.
 	* testsuite/gas/aarch64/f64mm.d: Adjust expectations.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* testsuite/gas/aarch64/i8mm.s: Add 128-bit form tests for
 	by-element usdot. Add 64-bit form tests for by-element sudot.
 	* testsuite/gas/aarch64/i8mm.d: Adjust expectations.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* testsuite/gas/aarch64/f64mm.s: Drop 'i' from uzip<n>.
 	* testsuite/gas/aarch64/f64mm.d: Adjust expectations.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* testsuite/gas/aarch64/f64mm.d,
 	testsuite/gas/aarch64/sve-movprfx-mm.d: Adjust expectations.
 
 2020-01-02  Sergey Belyashov  <sergey.belyashov@gmail.com>
 
 	* config/tc-z80.c: Add new architectures: Z180 and eZ80. Add
 	support for assembler code generated by SDCC. Add new relocation
 	types. Add z80-elf target support.
 	* config/tc-z80.h: Add z80-elf target support. Enable dollar local
 	labels. Local labels starts from ".L".
 	* NEWS: Mention the new support.
 	* testsuite/gas/all/fwdexp.d: Fix failure due to symbol conflict.
 	* testsuite/gas/all/fwdexp.s: Likewise.
 	* testsuite/gas/all/cond.l: Likewise.
 	* testsuite/gas/all/cond.s: Likewise.
 	* testsuite/gas/all/fwdexp.d: Likewise.
 	* testsuite/gas/all/fwdexp.s: Likewise.
 	* testsuite/gas/elf/section2.e-mips: Likewise.
 	* testsuite/gas/elf/section2.l: Likewise.
 	* testsuite/gas/elf/section2.s: Likewise.
 	* testsuite/gas/macros/app1.d: Likewise.
 	* testsuite/gas/macros/app1.s: Likewise.
 	* testsuite/gas/macros/app2.d: Likewise.
 	* testsuite/gas/macros/app2.s: Likewise.
 	* testsuite/gas/macros/app3.d: Likewise.
 	* testsuite/gas/macros/app3.s: Likewise.
 	* testsuite/gas/macros/app4.d: Likewise.
 	* testsuite/gas/macros/app4.s: Likewise.
 	* testsuite/gas/macros/app4b.s: Likewise.
 	* testsuite/gas/z80/suffix.d: Fix failure on ELF target.
 	* testsuite/gas/z80/z80.exp: Add new tests
 	* testsuite/gas/z80/dollar.d: New file.
 	* testsuite/gas/z80/dollar.s: New file.
 	* testsuite/gas/z80/ez80_adl_all.d: New file.
 	* testsuite/gas/z80/ez80_adl_all.s: New file.
 	* testsuite/gas/z80/ez80_adl_suf.d: New file.
 	* testsuite/gas/z80/ez80_isuf.s: New file.
 	* testsuite/gas/z80/ez80_z80_all.d: New file.
 	* testsuite/gas/z80/ez80_z80_all.s: New file.
 	* testsuite/gas/z80/ez80_z80_suf.d: New file.
 	* testsuite/gas/z80/r800_extra.d: New file.
 	* testsuite/gas/z80/r800_extra.s: New file.
 	* testsuite/gas/z80/r800_ii8.d: New file.
 	* testsuite/gas/z80/r800_z80_doc.d: New file.
 	* testsuite/gas/z80/z180.d: New file.
 	* testsuite/gas/z80/z180.s: New file.
 	* testsuite/gas/z80/z180_z80_doc.d: New file.
 	* testsuite/gas/z80/z80_doc.d: New file.
 	* testsuite/gas/z80/z80_doc.s: New file.
 	* testsuite/gas/z80/z80_ii8.d: New file.
 	* testsuite/gas/z80/z80_ii8.s: New file.
 	* testsuite/gas/z80/z80_in_f_c.d: New file.
 	* testsuite/gas/z80/z80_in_f_c.s: New file.
 	* testsuite/gas/z80/z80_op_ii_ld.d: New file.
 	* testsuite/gas/z80/z80_op_ii_ld.s: New file.
 	* testsuite/gas/z80/z80_out_c_0.d: New file.
 	* testsuite/gas/z80/z80_out_c_0.s: New file.
 	* testsuite/gas/z80/z80_reloc.d: New file.
 	* testsuite/gas/z80/z80_reloc.s: New file.
 	* testsuite/gas/z80/z80_sli.d: New file.
 	* testsuite/gas/z80/z80_sli.s: New file.
 
 2020-01-02  Szabolcs Nagy  <szabolcs.nagy@arm.com>
 
 	* config/tc-arm.c (parse_reg_list): Use REG_TYPE_RN instead of
 	REGLIST_RN.
 
 2020-01-01  Alan Modra  <amodra@gmail.com>
 
 	Update year range in copyright notice of all files.
diff --git a/gas/config/tc-z8k.c b/gas/config/tc-z8k.c
index d61a51f4546..ea4ee3a6b1f 100644
--- a/gas/config/tc-z8k.c
+++ b/gas/config/tc-z8k.c
@@ -143,29 +143,29 @@ void
 md_begin (void)
 {
   const opcode_entry_type *opcode;
-  int idx = -1;
+  unsigned int idx = -1u;
 
   opcode_hash_control = hash_new ();
 
   for (opcode = z8k_table; opcode->name; opcode++)
     {
       /* Only enter unique codes into the table.  */
       if (idx != opcode->idx)
 	hash_insert (opcode_hash_control, opcode->name, (char *) opcode);
       idx = opcode->idx;
     }
 
   /* Default to z8002.  */
   s_segm (z8k_target_from_cmdline ? z8k_target_from_cmdline - 1 : 0);
 
   /* Insert the pseudo ops, too.  */
   for (idx = 0; md_pseudo_table[idx].poc_name; idx++)
     {
       opcode_entry_type *fake_opcode;
       fake_opcode = XNEW (opcode_entry_type);
       fake_opcode->name = md_pseudo_table[idx].poc_name;
       fake_opcode->func = (void *) (md_pseudo_table + idx);
       fake_opcode->opcode = 250;
       hash_insert (opcode_hash_control, fake_opcode->name, fake_opcode);
     }
 }
@@ -858,97 +858,97 @@ static opcode_entry_type *
 get_specific (opcode_entry_type *opcode, op_type *operands)
 {
   opcode_entry_type *this_try = opcode;
   int found = 0;
   unsigned int noperands = opcode->noperands;
 
-  int this_index = opcode->idx;
+  unsigned int this_index = opcode->idx;
 
   while (this_index == opcode->idx && !found)
     {
       unsigned int i;
 
       this_try = opcode++;
       for (i = 0; i < noperands; i++)
 	{
 	  unsigned int mode = operands[i].mode;
 
           if (((mode & CLASS_MASK) == CLASS_IR) && ((this_try->arg_info[i] & CLASS_MASK) == CLASS_IRO))
             {
               mode = operands[i].mode = (operands[i].mode & ~CLASS_MASK) | CLASS_IRO;
             }
 
 	  if ((mode & CLASS_MASK) != (this_try->arg_info[i] & CLASS_MASK))
 	    {
 	      /* It could be a pc rel operand, if this is a da mode
 		 and we like disps, then insert it.  */
 
 	      if (mode == CLASS_DA && this_try->arg_info[i] == CLASS_DISP)
 		{
 		  /* This is the case.  */
 		  operands[i].mode = CLASS_DISP;
 		}
 	      else if (mode == CLASS_BA && this_try->arg_info[i])
 		{
 		  /* Can't think of a way to turn what we've been
 		     given into something that's OK.  */
 		  goto fail;
 		}
 	      else if (this_try->arg_info[i] & CLASS_PR)
 		{
 		  if (mode == CLASS_REG_LONG && segmented_mode)
 		    {
 		      /* OK.  */
 		    }
 		  else if (mode == CLASS_REG_WORD && !segmented_mode)
 		    {
 		      /* OK.  */
 		    }
 		  else
 		    goto fail;
 		}
 	      else
 		goto fail;
 	    }
 	  switch (mode & CLASS_MASK)
 	    {
 	    default:
 	      break;
 	    case CLASS_IRO:
 	      if (operands[i].regsize != CLASS_REG_WORD)
 		as_bad (_("invalid indirect register size"));
 	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
 	      break;
 	    case CLASS_IR:
 	      if ((segmented_mode && operands[i].regsize != CLASS_REG_LONG)
 		  || (!segmented_mode && operands[i].regsize != CLASS_REG_WORD))
 		as_bad (_("invalid indirect register size"));
 	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
 	      break;
 	    case CLASS_X:
 	    case CLASS_BA:
 	    case CLASS_BX:
 	    case CLASS_DISP:
 	    case CLASS_REG:
 	    case CLASS_REG_WORD:
 	    case CLASS_REG_BYTE:
 	    case CLASS_REG_QUAD:
 	    case CLASS_REG_LONG:
 	    case CLASS_REGN0:
 	      reg[this_try->arg_info[i] & ARG_MASK] = operands[i].reg;
 	      break;
 	    case CLASS_CTRL:
 	      if (this_try->opcode == OPC_ldctlb && the_ctrl != 1)
 		as_bad (_("invalid control register name"));
 	      break;
 	    }
 	}
 
       found = 1;
     fail:
       ;
     }
   if (found)
     return this_try;
   else
     return 0;
 }
diff --git a/opcodes/ChangeLog b/opcodes/ChangeLog
index 220b9f4c5f9..011943d55a8 100644
--- a/opcodes/ChangeLog
+++ b/opcodes/ChangeLog
@@ -1,67 +1,79 @@
+2020-01-08  Alan Modra  <amodra@gmail.com>
+
+	* z8k-dis.c: Include libiberty.h
+	(instr_data_s): Make max_fetched unsigned.
+	(z8k_lookup_instr): Make nibl_index and tabl_index unsigned.
+	Don't exceed byte_info bounds.
+	(output_instr): Make num_bytes unsigned.
+	(unpack_instr): Likewise for nibl_count and loop.
+	* z8kgen.c (gas <opcode_entry_type>): Make noperands, length and
+	idx unsigned.
+	* z8k-opc.h: Regenerate.
+
 2020-01-07  Shahab Vahedi  <shahab@synopsys.com>
 
 	* arc-tbl.h (llock): Use 'LLOCK' as class.
 	(llockd): Likewise.
 	(scond): Use 'SCOND' as class.
 	(scondd): Likewise.
 	(llockd): Set data_size_mode to 'C_ZZ_D' which is 64-bit.
 	(scondd): Likewise.
 
 2020-01-06  Alan Modra  <amodra@gmail.com>
 
 	* m32c-ibld.c: Regenerate.
 
 2020-01-06  Alan Modra  <amodra@gmail.com>
 
 	PR 25344
 	* z80-dis.c (suffix): Don't use a local struct buffer copy.
 	Peek at next byte to prevent recursion on repeated prefix bytes.
 	Ensure uninitialised "mybuf" is not accessed.
 	(print_insn_z80): Don't zero n_fetch and n_used here,..
 	(print_insn_z80_buf): ..do it here instead.
 
 2020-01-04  Alan Modra  <amodra@gmail.com>
 
 	* m32r-ibld.c: Regenerate.
 
 2020-01-04  Alan Modra  <amodra@gmail.com>
 
 	* cr16-dis.c (cr16_match_opcode): Avoid shift left of signed value.
 
 2020-01-04  Alan Modra  <amodra@gmail.com>
 
 	* crx-dis.c (match_opcode): Avoid shift left of signed value.
 
 2020-01-04  Alan Modra  <amodra@gmail.com>
 
 	* d30v-dis.c (print_insn): Avoid signed overflow in left shift.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* aarch64-tbl.h (aarch64_opcode_table): Use
 	SVE_ADDR_RX_LSL{1,2,3} for LD1RO{H,W,D}.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* aarch64-tbl.h (aarch64_opcode_table): Correct SIMD
 	forms of SUDOT and USDOT.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* aarch64-tbl.h (aarch64_opcode_table): Drop 'i' from
 	uzip{1,2}.
 	* opcodes/aarch64-dis-2.c: Re-generate.
 
 2020-01-03  Jan Beulich  <jbeulich@suse.com>
 
 	* aarch64-tbl.h (aarch64_opcode_table): Correct 64-bit
 	FMMLA encoding.
 	* opcodes/aarch64-dis-2.c: Re-generate.
 
 2020-01-02  Sergey Belyashov  <sergey.belyashov@gmail.com>
 
 	* z80-dis.c: Add support for eZ80 and Z80 instructions.
 
 2020-01-01  Alan Modra  <amodra@gmail.com>
 
 	Update year range in copyright notice of all files.
diff --git a/opcodes/z8k-dis.c b/opcodes/z8k-dis.c
index 7cd59d86814..cb871decfab 100644
--- a/opcodes/z8k-dis.c
+++ b/opcodes/z8k-dis.c
@@ -1,27 +1,28 @@
 /* Disassemble z8000 code.
    Copyright (C) 1992-2020 Free Software Foundation, Inc.
 
    This file is part of the GNU opcodes library.
 
    This library is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.
 
    It is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
    License for more details.
 
    You should have received a copy of the GNU General Public License
    along with this file; see the file COPYING.  If not, write to the
    Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
    MA 02110-1301, USA.  */
 
 #include "sysdep.h"
 #include "disassemble.h"
+#include "libiberty.h"
 
 #define DEFINE_TABLE
 #include "z8k-opc.h"
 
 #include <setjmp.h>
@@ -29,24 +30,24 @@
 typedef struct
 {
   /* These are all indexed by nibble number (i.e only every other entry
      of bytes is used, and every 4th entry of words).  */
   unsigned char nibbles[24];
   unsigned char bytes[24];
   unsigned short words[24];
 
   /* Nibble number of first word not yet fetched.  */
-  int max_fetched;
+  unsigned int max_fetched;
   bfd_vma insn_start;
   OPCODES_SIGJMP_BUF bailout;
 
   int tabl_index;
   char instr_asmsrc[80];
   unsigned long arg_reg[0x0f];
   unsigned long immediate;
   unsigned long displacement;
   unsigned long address;
   unsigned long cond_code;
   unsigned long ctrl_code;
   unsigned long flags;
   unsigned long interrupts;
 }
@@ -189,89 +190,91 @@ print_insn_z8002 (bfd_vma addr, disassemble_info *info)
 int
 z8k_lookup_instr (unsigned char *nibbles, disassemble_info *info)
 {
-  int nibl_index, tabl_index;
+  unsigned int nibl_index, tabl_index;
   int nibl_matched;
   int need_fetch = 0;
   unsigned short instr_nibl;
   unsigned short tabl_datum, datum_class, datum_value;
 
   nibl_matched = 0;
   tabl_index = 0;
   FETCH_DATA (info, 4);
   while (!nibl_matched && z8k_table[tabl_index].name)
     {
       nibl_matched = 1;
       for (nibl_index = 0;
-	   nibl_index < z8k_table[tabl_index].length * 2 && nibl_matched;
+	   nibl_matched
+	     && nibl_index < ARRAY_SIZE (z8k_table[0].byte_info)
+	     && nibl_index < z8k_table[tabl_index].length * 2;
 	   nibl_index++)
 	{
 	  if ((nibl_index % 4) == 0)
             {
               /* Fetch data only if it isn't already there.  */
               if (nibl_index >= 4 || (nibl_index < 4 && need_fetch))
                 FETCH_DATA (info, nibl_index + 4);   /* Fetch one word at a time.  */
               if (nibl_index < 4)
                 need_fetch = 0;
               else
                 need_fetch = 1;
             }
 	  instr_nibl = nibbles[nibl_index];
 
 	  tabl_datum = z8k_table[tabl_index].byte_info[nibl_index];
 	  datum_class = tabl_datum & CLASS_MASK;
 	  datum_value = ~CLASS_MASK & tabl_datum;
 
 	  switch (datum_class)
 	    {
 	    case CLASS_BIT:
 	      if (datum_value != instr_nibl)
 		nibl_matched = 0;
 	      break;
 	    case CLASS_IGNORE:
 	      break;
 	    case CLASS_00II:
 	      if (!((~instr_nibl) & 0x4))
 		nibl_matched = 0;
 	      break;
 	    case CLASS_01II:
 	      if (!(instr_nibl & 0x4))
 		nibl_matched = 0;
 	      break;
 	    case CLASS_0CCC:
 	      if (!((~instr_nibl) & 0x8))
 		nibl_matched = 0;
 	      break;
 	    case CLASS_1CCC:
 	      if (!(instr_nibl & 0x8))
 		nibl_matched = 0;
 	      break;
 	    case CLASS_0DISP7:
 	      if (!((~instr_nibl) & 0x8))
 		nibl_matched = 0;
 	      nibl_index += 1;
 	      break;
 	    case CLASS_1DISP7:
 	      if (!(instr_nibl & 0x8))
 		nibl_matched = 0;
 	      nibl_index += 1;
 	      break;
 	    case CLASS_REGN0:
 	      if (instr_nibl == 0)
 		nibl_matched = 0;
 	      break;
 	    case CLASS_BIT_1OR2:
 	      if ((instr_nibl | 0x2) != (datum_value | 0x2))
 		nibl_matched = 0;
 	      break;
 	    default:
 	      break;
 	    }
 	}
 
       if (nibl_matched)
 	return tabl_index;
 
       tabl_index++;
     }
   return -1;
 }
@@ -280,16 +283,16 @@ static void
 output_instr (instr_data_s *instr_data,
               unsigned long addr ATTRIBUTE_UNUSED,
               disassemble_info *info)
 {
-  int num_bytes;
+  unsigned int num_bytes;
   char out_str[100];
 
   out_str[0] = 0;
 
   num_bytes = (z8k_table[instr_data->tabl_index].length + seg_length) * 2;
   FETCH_DATA (info, num_bytes);
 
   strcat (out_str, instr_data->instr_asmsrc);
 
   (*info->fprintf_func) (info->stream, "%s", out_str);
 }
@@ -297,176 +300,176 @@ output_instr (instr_data_s *instr_data,
 static void
 unpack_instr (instr_data_s *instr_data, int is_segmented, disassemble_info *info)
 {
-  int nibl_count, loop;
+  unsigned int nibl_count, loop;
   unsigned short instr_nibl, instr_byte, instr_word;
   long instr_long;
   unsigned int tabl_datum, datum_class;
   unsigned short datum_value;
 
   nibl_count = 0;
   loop = 0;
   seg_length = 0;
 
   while (z8k_table[instr_data->tabl_index].byte_info[loop] != 0)
     {
       FETCH_DATA (info, nibl_count + 4 - (nibl_count % 4));
       instr_nibl = instr_data->nibbles[nibl_count];
       instr_byte = instr_data->bytes[nibl_count & ~1];
       instr_word = instr_data->words[nibl_count & ~3];
 
       tabl_datum = z8k_table[instr_data->tabl_index].byte_info[loop];
       datum_class = tabl_datum & CLASS_MASK;
       datum_value = tabl_datum & ~CLASS_MASK;
 
       switch (datum_class)
 	{
 	case CLASS_DISP:
 	  switch (datum_value)
 	    {
 	    case ARG_DISP16:
 	      instr_data->displacement = instr_data->insn_start + 4
 		+ (signed short) (instr_word & 0xffff);
 	      nibl_count += 3;
 	      break;
 	    case ARG_DISP12:
 	      if (instr_word & 0x800)
 		/* Negative 12 bit displacement.  */
 		instr_data->displacement = instr_data->insn_start + 2
 		  - (signed short) ((instr_word & 0xfff) | 0xf000) * 2;
 	      else
 		instr_data->displacement = instr_data->insn_start + 2
 		  - (instr_word & 0x0fff) * 2;
 
 	      nibl_count += 2;
 	      break;
 	    default:
 	      break;
 	    }
 	  break;
 	case CLASS_IMM:
 	  switch (datum_value)
 	    {
 	    case ARG_IMM4:
 	      instr_data->immediate = instr_nibl;
 	      break;
 	    case ARG_NIM4:
 	      instr_data->immediate = (- instr_nibl) & 0xf;
 	      break;
 	    case ARG_NIM8:
 	      instr_data->immediate = (- instr_byte) & 0xff;
 	      nibl_count += 1;
 	      break;
 	    case ARG_IMM8:
 	      instr_data->immediate = instr_byte;
 	      nibl_count += 1;
 	      break;
 	    case ARG_IMM16:
 	      instr_data->immediate = instr_word;
 	      nibl_count += 3;
 	      break;
 	    case ARG_IMM32:
 	      FETCH_DATA (info, nibl_count + 8);
 	      instr_long = (instr_data->words[nibl_count] << 16)
 		| (instr_data->words[nibl_count + 4]);
 	      instr_data->immediate = instr_long;
 	      nibl_count += 7;
 	      break;
 	    case ARG_IMMN:
 	      instr_data->immediate = instr_nibl - 1;
 	      break;
 	    case ARG_IMM4M1:
 	      instr_data->immediate = instr_nibl + 1;
 	      break;
 	    case ARG_IMM_1:
 	      instr_data->immediate = 1;
 	      break;
 	    case ARG_IMM_2:
 	      instr_data->immediate = 2;
 	      break;
 	    case ARG_IMM2:
 	      instr_data->immediate = instr_nibl & 0x3;
 	      break;
 	    default:
 	      break;
 	    }
 	  break;
 	case CLASS_CC:
 	  instr_data->cond_code = instr_nibl;
 	  break;
 	case CLASS_ADDRESS:
 	  if (is_segmented)
 	    {
 	      if (instr_nibl & 0x8)
 		{
 		  FETCH_DATA (info, nibl_count + 8);
 		  instr_long = (instr_data->words[nibl_count] << 16)
 		    | (instr_data->words[nibl_count + 4]);
 		  instr_data->address = ((instr_word & 0x7f00) << 16)
 		    + (instr_long & 0xffff);
 		  nibl_count += 7;
 		  seg_length = 2;
 		}
 	      else
 		{
 		  instr_data->address = ((instr_word & 0x7f00) << 16)
 		    + (instr_word & 0x00ff);
 		  nibl_count += 3;
 		}
 	    }
 	  else
 	    {
 	      instr_data->address = instr_word;
 	      nibl_count += 3;
 	    }
 	  break;
 	case CLASS_0CCC:
 	case CLASS_1CCC:
 	  instr_data->ctrl_code = instr_nibl & 0x7;
 	  break;
 	case CLASS_0DISP7:
 	  instr_data->displacement =
 	    instr_data->insn_start + 2 - (instr_byte & 0x7f) * 2;
 	  nibl_count += 1;
 	  break;
 	case CLASS_1DISP7:
 	  instr_data->displacement =
 	    instr_data->insn_start + 2 - (instr_byte & 0x7f) * 2;
 	  nibl_count += 1;
 	  break;
 	case CLASS_01II:
 	  instr_data->interrupts = instr_nibl & 0x3;
 	  break;
 	case CLASS_00II:
 	  instr_data->interrupts = instr_nibl & 0x3;
 	  break;
 	case CLASS_IGNORE:
 	case CLASS_BIT:
 	  instr_data->ctrl_code = instr_nibl & 0x7;
 	  break;
 	case CLASS_FLAGS:
 	  instr_data->flags = instr_nibl;
 	  break;
 	case CLASS_REG:
 	  instr_data->arg_reg[datum_value] = instr_nibl;
 	  break;
 	case CLASS_REGN0:
 	  instr_data->arg_reg[datum_value] = instr_nibl;
 	  break;
 	case CLASS_DISP8:
 	  instr_data->displacement =
 	    instr_data->insn_start + 2 + (signed char) instr_byte * 2;
 	  nibl_count += 1;
 	  break;
         case CLASS_BIT_1OR2:
           instr_data->immediate = ((instr_nibl >> 1) & 0x1) + 1;
           nibl_count += 1;
 	  break;
 	default:
 	  abort ();
 	  break;
 	}
 
       loop += 1;
       nibl_count += 1;
     }
 }
diff --git a/opcodes/z8k-opc.h b/opcodes/z8k-opc.h
index 68c4ad4800d..35ce4bc655e 100644
--- a/opcodes/z8k-opc.h
+++ b/opcodes/z8k-opc.h
@@ -283,18 +283,18 @@
 typedef struct {
 #ifdef NICENAMES
   const char *nicename;
   int type;
   int cycles;
   int flags;
 #endif
   const char *name;
   unsigned char opcode;
   void (*func) (void);
   unsigned int arg_info[4];
   unsigned int byte_info[10];
-  int noperands;
-  int length;
-  int idx;
+  unsigned int noperands;
+  unsigned int length;
+  unsigned int idx;
 } opcode_entry_type;
 
 #ifdef DEFINE_TABLE
diff --git a/opcodes/z8kgen.c b/opcodes/z8kgen.c
index a1b74ca4f37..b72fcffa357 100644
--- a/opcodes/z8kgen.c
+++ b/opcodes/z8kgen.c
@@ -970,377 +970,377 @@ static void
 gas (void)
 {
   int c = count ();
   int id;
   struct op *p = opt;
   int idx = -1;
   char *oldname = "";
   struct op *new_op = xmalloc (sizeof (struct op) * (c + 1));
 
   memcpy (new_op, p, (c + 1) * sizeof (struct op));
 
   /* Assign unique id.  */
   for (id = 0; id < c; id++)
     new_op[id].id = id;
 
   /* Sort all names in table alphabetically.  */
   qsort (new_op, c, sizeof (struct op), func);
 
   printf ("/* DO NOT EDIT!  -*- buffer-read-only: t -*-\n");
   printf ("   This file is automatically generated by z8kgen.  */\n\n");
   printf ("/* Copyright (C) 2007-2020 Free Software Foundation, Inc.\n\
 \n\
    This file is part of the GNU opcodes library.\n\
 \n\
    This library is free software; you can redistribute it and/or modify\n\
    it under the terms of the GNU General Public License as published by\n\
    the Free Software Foundation; either version 3, or (at your option)\n\
    any later version.\n\
 \n\
    It is distributed in the hope that it will be useful, but WITHOUT\n\
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n\
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n\
    License for more details.\n\
 \n\
    You should have received a copy of the GNU General Public License\n\
    along with this file; see the file COPYING.  If not, write to the\n\
    Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,\n\
    MA 02110-1301, USA.  */\n\n");
 
   printf ("#define ARG_MASK         0x0f\n");
 
   printf ("#define ARG_SRC          0x01\n");
   printf ("#define ARG_DST          0x02\n");
 
   printf ("#define ARG_RS           0x01\n");
   printf ("#define ARG_RD           0x02\n");
   printf ("#define ARG_RA           0x03\n");
   printf ("#define ARG_RB           0x04\n");
   printf ("#define ARG_RR           0x05\n");
   printf ("#define ARG_RX           0x06\n");
 
   printf ("#define ARG_IMM4         0x01\n");
   printf ("#define ARG_IMM8         0x02\n");
   printf ("#define ARG_IMM16        0x03\n");
   printf ("#define ARG_IMM32        0x04\n");
   printf ("#define ARG_IMMN         0x05\n");
   printf ("#define ARG_IMMNMINUS1   0x05\n");
   printf ("#define ARG_IMM_1        0x06\n");
   printf ("#define ARG_IMM_2        0x07\n");
   printf ("#define ARG_DISP16       0x08\n");
   printf ("#define ARG_NIM8         0x09\n");
   printf ("#define ARG_IMM2         0x0a\n");
   printf ("#define ARG_IMM1OR2      0x0b\n");
 
   printf ("#define ARG_DISP12       0x0b\n");
   printf ("#define ARG_NIM4         0x0c\n");
   printf ("#define ARG_DISP8        0x0c\n");
   printf ("#define ARG_IMM4M1       0x0d\n");
 
   printf ("#define CLASS_X          0x10\n");
   printf ("#define CLASS_BA         0x20\n");
   printf ("#define CLASS_DA         0x30\n");
   printf ("#define CLASS_BX         0x40\n");
   printf ("#define CLASS_DISP       0x50\n");
   printf ("#define CLASS_IMM        0x60\n");
   printf ("#define CLASS_CC         0x70\n");
   printf ("#define CLASS_CTRL       0x80\n");
   printf ("#define CLASS_IGNORE     0x90\n");
   printf ("#define CLASS_ADDRESS    0xd0\n");
   printf ("#define CLASS_0CCC       0xe0\n");
   printf ("#define CLASS_1CCC       0xf0\n");
   printf ("#define CLASS_0DISP7    0x100\n");
   printf ("#define CLASS_1DISP7    0x200\n");
   printf ("#define CLASS_01II      0x300\n");
   printf ("#define CLASS_00II      0x400\n");
   printf ("#define CLASS_BIT       0x500\n");
   printf ("#define CLASS_FLAGS     0x600\n");
   printf ("#define CLASS_IR        0x700\n");
   printf ("#define CLASS_IRO       0x800\n");
   printf ("#define CLASS_DISP8     0x900\n");
 
   printf ("#define CLASS_BIT_1OR2  0xa00\n");
   printf ("#define CLASS_REG       0x7000\n");
   printf ("#define CLASS_REG_BYTE  0x2000\n");
   printf ("#define CLASS_REG_WORD  0x3000\n");
   printf ("#define CLASS_REG_QUAD  0x4000\n");
   printf ("#define CLASS_REG_LONG  0x5000\n");
   printf ("#define CLASS_REGN0     0x8000\n");
   printf ("#define CLASS_PR       0x10000\n");
   printf ("#define CLASS_MASK     0x1fff0\n");
 
   printf ("#define OPC_adc      0\n");
   printf ("#define OPC_adcb     1\n");
   printf ("#define OPC_add      2\n");
   printf ("#define OPC_addb     3\n");
   printf ("#define OPC_addl     4\n");
   printf ("#define OPC_and      5\n");
   printf ("#define OPC_andb     6\n");
   printf ("#define OPC_bit      7\n");
   printf ("#define OPC_bitb     8\n");
   printf ("#define OPC_call     9\n");
   printf ("#define OPC_calr    10\n");
   printf ("#define OPC_clr     11\n");
   printf ("#define OPC_clrb    12\n");
   printf ("#define OPC_com     13\n");
   printf ("#define OPC_comb    14\n");
   printf ("#define OPC_comflg  15\n");
   printf ("#define OPC_cp      16\n");
   printf ("#define OPC_cpb     17\n");
   printf ("#define OPC_cpd     18\n");
   printf ("#define OPC_cpdb    19\n");
   printf ("#define OPC_cpdr    20\n");
   printf ("#define OPC_cpdrb   21\n");
   printf ("#define OPC_cpi     22\n");
   printf ("#define OPC_cpib    23\n");
   printf ("#define OPC_cpir    24\n");
   printf ("#define OPC_cpirb   25\n");
   printf ("#define OPC_cpl     26\n");
   printf ("#define OPC_cpsd    27\n");
   printf ("#define OPC_cpsdb   28\n");
   printf ("#define OPC_cpsdr   29\n");
   printf ("#define OPC_cpsdrb  30\n");
   printf ("#define OPC_cpsi    31\n");
   printf ("#define OPC_cpsib   32\n");
   printf ("#define OPC_cpsir   33\n");
   printf ("#define OPC_cpsirb  34\n");
   printf ("#define OPC_dab     35\n");
   printf ("#define OPC_dbjnz   36\n");
   printf ("#define OPC_dec     37\n");
   printf ("#define OPC_decb    38\n");
   printf ("#define OPC_di      39\n");
   printf ("#define OPC_div     40\n");
   printf ("#define OPC_divl    41\n");
   printf ("#define OPC_djnz    42\n");
   printf ("#define OPC_ei      43\n");
   printf ("#define OPC_ex      44\n");
   printf ("#define OPC_exb     45\n");
   printf ("#define OPC_exts    46\n");
   printf ("#define OPC_extsb   47\n");
   printf ("#define OPC_extsl   48\n");
   printf ("#define OPC_halt    49\n");
   printf ("#define OPC_in      50\n");
   printf ("#define OPC_inb     51\n");
   printf ("#define OPC_inc     52\n");
   printf ("#define OPC_incb    53\n");
   printf ("#define OPC_ind     54\n");
   printf ("#define OPC_indb    55\n");
   printf ("#define OPC_indr    56\n");
   printf ("#define OPC_indrb   57\n");
   printf ("#define OPC_ini     58\n");
   printf ("#define OPC_inib    59\n");
   printf ("#define OPC_inir    60\n");
   printf ("#define OPC_inirb   61\n");
   printf ("#define OPC_iret    62\n");
   printf ("#define OPC_jp      63\n");
   printf ("#define OPC_jr      64\n");
   printf ("#define OPC_ld      65\n");
   printf ("#define OPC_lda     66\n");
   printf ("#define OPC_ldar    67\n");
   printf ("#define OPC_ldb     68\n");
   printf ("#define OPC_ldctl   69\n");
   printf ("#define OPC_ldir    70\n");
   printf ("#define OPC_ldirb   71\n");
   printf ("#define OPC_ldk     72\n");
   printf ("#define OPC_ldl     73\n");
   printf ("#define OPC_ldm     74\n");
   printf ("#define OPC_ldps    75\n");
   printf ("#define OPC_ldr     76\n");
   printf ("#define OPC_ldrb    77\n");
   printf ("#define OPC_ldrl    78\n");
   printf ("#define OPC_mbit    79\n");
   printf ("#define OPC_mreq    80\n");
   printf ("#define OPC_mres    81\n");
   printf ("#define OPC_mset    82\n");
   printf ("#define OPC_mult    83\n");
   printf ("#define OPC_multl   84\n");
   printf ("#define OPC_neg     85\n");
   printf ("#define OPC_negb    86\n");
   printf ("#define OPC_nop     87\n");
   printf ("#define OPC_or      88\n");
   printf ("#define OPC_orb     89\n");
   printf ("#define OPC_otdr    90\n");
   printf ("#define OPC_otdrb   91\n");
   printf ("#define OPC_otir    92\n");
   printf ("#define OPC_otirb   93\n");
   printf ("#define OPC_out     94\n");
   printf ("#define OPC_outb    95\n");
   printf ("#define OPC_outd    96\n");
   printf ("#define OPC_outdb   97\n");
   printf ("#define OPC_outi    98\n");
   printf ("#define OPC_outib   99\n");
   printf ("#define OPC_pop    100\n");
   printf ("#define OPC_popl   101\n");
   printf ("#define OPC_push   102\n");
   printf ("#define OPC_pushl  103\n");
   printf ("#define OPC_res    104\n");
   printf ("#define OPC_resb   105\n");
   printf ("#define OPC_resflg 106\n");
   printf ("#define OPC_ret    107\n");
   printf ("#define OPC_rl     108\n");
   printf ("#define OPC_rlb    109\n");
   printf ("#define OPC_rlc    110\n");
   printf ("#define OPC_rlcb   111\n");
   printf ("#define OPC_rldb   112\n");
   printf ("#define OPC_rr     113\n");
   printf ("#define OPC_rrb    114\n");
   printf ("#define OPC_rrc    115\n");
   printf ("#define OPC_rrcb   116\n");
   printf ("#define OPC_rrdb   117\n");
   printf ("#define OPC_sbc    118\n");
   printf ("#define OPC_sbcb   119\n");
   printf ("#define OPC_sda    120\n");
   printf ("#define OPC_sdab   121\n");
   printf ("#define OPC_sdal   122\n");
   printf ("#define OPC_sdl    123\n");
   printf ("#define OPC_sdlb   124\n");
   printf ("#define OPC_sdll   125\n");
   printf ("#define OPC_set    126\n");
   printf ("#define OPC_setb   127\n");
   printf ("#define OPC_setflg 128\n");
   printf ("#define OPC_sin    129\n");
   printf ("#define OPC_sinb   130\n");
   printf ("#define OPC_sind   131\n");
   printf ("#define OPC_sindb  132\n");
   printf ("#define OPC_sindr  133\n");
   printf ("#define OPC_sindrb 134\n");
   printf ("#define OPC_sini   135\n");
   printf ("#define OPC_sinib  136\n");
   printf ("#define OPC_sinir  137\n");
   printf ("#define OPC_sinirb 138\n");
   printf ("#define OPC_sla    139\n");
   printf ("#define OPC_slab   140\n");
   printf ("#define OPC_slal   141\n");
   printf ("#define OPC_sll    142\n");
   printf ("#define OPC_sllb   143\n");
   printf ("#define OPC_slll   144\n");
   printf ("#define OPC_sotdr  145\n");
   printf ("#define OPC_sotdrb 146\n");
   printf ("#define OPC_sotir  147\n");
   printf ("#define OPC_sotirb 148\n");
   printf ("#define OPC_sout   149\n");
   printf ("#define OPC_soutb  150\n");
   printf ("#define OPC_soutd  151\n");
   printf ("#define OPC_soutdb 152\n");
   printf ("#define OPC_souti  153\n");
   printf ("#define OPC_soutib 154\n");
   printf ("#define OPC_sra    155\n");
   printf ("#define OPC_srab   156\n");
   printf ("#define OPC_sral   157\n");
   printf ("#define OPC_srl    158\n");
   printf ("#define OPC_srlb   159\n");
   printf ("#define OPC_srll   160\n");
   printf ("#define OPC_sub    161\n");
   printf ("#define OPC_subb   162\n");
   printf ("#define OPC_subl   163\n");
   printf ("#define OPC_tcc    164\n");
   printf ("#define OPC_tccb   165\n");
   printf ("#define OPC_test   166\n");
   printf ("#define OPC_testb  167\n");
   printf ("#define OPC_testl  168\n");
   printf ("#define OPC_trdb   169\n");
   printf ("#define OPC_trdrb  170\n");
   printf ("#define OPC_trib   171\n");
   printf ("#define OPC_trirb  172\n");
   printf ("#define OPC_trtdrb 173\n");
   printf ("#define OPC_trtib  174\n");
   printf ("#define OPC_trtirb 175\n");
   printf ("#define OPC_trtrb  176\n");
   printf ("#define OPC_tset   177\n");
   printf ("#define OPC_tsetb  178\n");
   printf ("#define OPC_xor    179\n");
   printf ("#define OPC_xorb   180\n");
 
   printf ("#define OPC_ldd    181\n");
   printf ("#define OPC_lddb   182\n");
   printf ("#define OPC_lddr   183\n");
   printf ("#define OPC_lddrb  184\n");
   printf ("#define OPC_ldi    185\n");
   printf ("#define OPC_ldib   186\n");
   printf ("#define OPC_sc     187\n");
   printf ("#define OPC_bpt    188\n");
   printf ("#define OPC_ext0e  188\n");
   printf ("#define OPC_ext0f  188\n");
   printf ("#define OPC_ext8e  188\n");
   printf ("#define OPC_ext8f  188\n");
   printf ("#define OPC_rsvd36 188\n");
   printf ("#define OPC_rsvd38 188\n");
   printf ("#define OPC_rsvd78 188\n");
   printf ("#define OPC_rsvd7e 188\n");
   printf ("#define OPC_rsvd9d 188\n");
   printf ("#define OPC_rsvd9f 188\n");
   printf ("#define OPC_rsvdb9 188\n");
   printf ("#define OPC_rsvdbf 188\n");
   printf ("#define OPC_ldctlb 189\n");
   printf ("#define OPC_trtdb  190\n");
   printf ("#define OPC_brk    191\n");
 #if 0
   for (i = 0; toks[i].token; i++)
     printf ("#define %s\t0x%x\n", toks[i].token, i * 16);
 #endif
   printf ("\ntypedef struct {\n");
 
   printf ("#ifdef NICENAMES\n");
   printf ("  const char *nicename;\n");
   printf ("  int type;\n");
   printf ("  int cycles;\n");
   printf ("  int flags;\n");
   printf ("#endif\n");
   printf ("  const char *name;\n");
   printf ("  unsigned char opcode;\n");
   printf ("  void (*func) (void);\n");
   printf ("  unsigned int arg_info[4];\n");
   printf ("  unsigned int byte_info[%d];\n", BYTE_INFO_LEN);
-  printf ("  int noperands;\n");
-  printf ("  int length;\n");
-  printf ("  int idx;\n");
+  printf ("  unsigned int noperands;\n");
+  printf ("  unsigned int length;\n");
+  printf ("  unsigned int idx;\n");
   printf ("} opcode_entry_type;\n\n");
   printf ("#ifdef DEFINE_TABLE\n");
   printf ("const opcode_entry_type z8k_table[] = {\n");
 
   while (new_op->flags && new_op->flags[0] != '*')
     {
       int nargs;
       int length;
 
       printf ("\n/* %s *** %s */\n", new_op->bits, new_op->name);
       printf ("{\n");
 
       printf ("#ifdef NICENAMES\n");
       printf ("\"%s\",%d,%d,", new_op->name, new_op->type, new_op->cycles);
       {
 	int answer = 0;
 	char *p = new_op->flags;
 
 	while (*p)
 	  {
 	    answer <<= 1;
 
 	    if (*p != '-')
 	      answer |= 1;
 	    p++;
 	  }
 	printf ("0x%02x,\n", answer);
       }
 
       printf ("#endif\n");
 
       nargs = chewname (&new_op->name);
 
       printf ("\n\t");
       chewbits (new_op->bits, &length);
       length /= 2;
       if (length & 1)
 	abort();
 
       if (strcmp (oldname, new_op->name) != 0)
 	idx++;
       printf (",%d,%d,%d", nargs, length, idx);
       oldname = new_op->name;
       printf ("},\n");
       new_op++;
     }
   printf ("\n/* end marker */\n");
   printf ("{\n#ifdef NICENAMES\nNULL,0,0,\n0,\n#endif\n");
   printf ("NULL,0,0,{0,0,0,0},{0,0,0,0,0,0,0,0,0,0},0,0,0}\n};\n");
   printf ("#endif\n");
 }
