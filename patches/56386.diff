commit c0ca3b2979a6f0999c57549986f99334666e8ef7
Author: chamarthi.kishore <chamarthi.kishore@ittiam.com>
Date:   Mon Feb 27 14:31:12 2023 +0530

    svcdec: Bug fix in NON VCL NAL parsing.
    
    BUG=oss-fuzz: 56386
    Test: svc_dec_fuzzer

diff --git a/decoder/svc/isvcd_nal_parse.c b/decoder/svc/isvcd_nal_parse.c
index 6bad007..922e92d 100644
--- a/decoder/svc/isvcd_nal_parse.c
+++ b/decoder/svc/isvcd_nal_parse.c
@@ -336,104 +336,103 @@ WORD32 isvcd_nal_reset_ctxt(nal_parse_ctxt_t *ps_nal_parse_ctxt)
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_pic_reset_ctxt                                      */
 /*                                                                           */
 /*  Description   : This routine performs the picture level initialization.  */
 /*                  This routine shall be called before parsing a access unit*/
 /*                                                                           */
 /*  Inputs        : pv_nal_parse_ctxt - Pointer to context structure         */
 /*                                                                           */
 /*  Globals       : None                                                     */
 /*                                                                           */
 /*  Processing    : 1. Resets the varaibles                                  */
 /*                                                                           */
 /*  Outputs       : Updated context structure                                */
 /*                                                                           */
 /*  Returns       : none                                                     */
 /*                                                                           */
 /*  Issues        : None                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*          DD MM YYYY   Author(s)       Changes                             */
 /*          06 09 2021   Vijay           Draft                               */
 /*                                                                           */
 /*****************************************************************************/
 void isvcd_pic_reset_ctxt(nal_parse_ctxt_t *ps_nal_parse_ctxt)
 {
     WORD32 i4_status;
 
     /*-----------------------------------------------------------------------*/
     /*! Reset NAL boundary detetction logic                                  */
     /*-----------------------------------------------------------------------*/
     i4_status = isvcd_nal_reset_ctxt(ps_nal_parse_ctxt);
 
     UNUSED(i4_status);
 
     /*-----------------------------------------------------------------------*/
     /*! Reset picture boundary detctetion logic                              */
     /*-----------------------------------------------------------------------*/
     ps_nal_parse_ctxt->i4_is_frst_vcl_nal_in_au = SVCD_TRUE;
 
     /*-----------------------------------------------------------------------*/
     /*! Reset VCL and non VCL NAL buffer tracking variables                  */
     /*-----------------------------------------------------------------------*/
     ps_nal_parse_ctxt->pu1_non_vcl_nal_buf = ps_nal_parse_ctxt->pv_non_vcl_nal_buf;
     ps_nal_parse_ctxt->pu1_vcl_nal_buf = ps_nal_parse_ctxt->pv_vcl_nal_buf;
 
     /* reset the bytes left to buffer size */
     ps_nal_parse_ctxt->u4_bytes_left_vcl = MAX_VCL_NAL_BUFF_SIZE;
 
-    /* 85% of the buffer is used. 15% is used to handle error cases*/
-    ps_nal_parse_ctxt->u4_bytes_left_non_vcl = (MAX_NON_VCL_NAL_BUFF_SIZE * 0.85);
+    ps_nal_parse_ctxt->u4_bytes_left_non_vcl = MAX_NON_VCL_NAL_BUFF_SIZE;
 
     /* Offset the buffer to start of vcl data */
     UPDATE_NAL_BUF_PTR(&ps_nal_parse_ctxt->pu1_non_vcl_nal_buf, NON_VCL_NAL,
                        &ps_nal_parse_ctxt->u4_bytes_left_non_vcl);
 
     UPDATE_NAL_BUF_PTR(&ps_nal_parse_ctxt->pu1_vcl_nal_buf, VCL_NAL,
                        &ps_nal_parse_ctxt->u4_bytes_left_vcl);
 
     /* Reset previous field */
     ps_nal_parse_ctxt->ps_prev_non_vcl_buf = NULL;
     ps_nal_parse_ctxt->i4_idr_pic_err_flag = 0;
 
     /*-----------------------------------------------------------------------*/
     /*! Reset other NAL related tracking variables                           */
     /*-----------------------------------------------------------------------*/
     ps_nal_parse_ctxt->i4_num_non_vcl_nals = 0;
 
     /* Reset the vcl nal node buffer context */
     i4_status = isvcd_dqid_ctxt_reset(&ps_nal_parse_ctxt->s_dqid_ctxt);
 
     /* Reset target layer update flag */
     ps_nal_parse_ctxt->i4_tgt_lyr_update = SVCD_TRUE;
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_get_nal_prms                                        */
 /*                                                                           */
 /*  Description   : This routine will update the nal prms                    */
 /*  Inputs        : 1. Start of bitstream buffer containing NAL header       */
 /*                  2. Size of the buffer                                    */
 /*                  3. NAL prms structure                                    */
 /*                  4. Place holder for error code                           */
 /*                  5. Place holder for nal discard flag                     */
 /*                  6. NAL parse context structure                           */
 /*  Globals       : None                                                     */
 /*  Processing    : 1. Parses the NAL header                                 */
 /*                  2. Sets the discard flag                                 */
 /*                  3. If NAL is not discarded and nal is VCL NAL unit then  */
 /*                     decodes the slice prms (prefix nal units are excluded)*/
 /*  Outputs       : Updated NAL prms structure                               */
 /*                  Updated NAL discrd flag                                  */
 /*                  Updates the error code if encountered with error         */
 /*  Returns       : status                                                   */
 /*                                                                           */
 /*  Issues        : None                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 09 2021   Vijay           Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -1739,414 +1738,422 @@ void isvcd_nal_parse_pic_bound_proc(nal_parse_ctxt_t *ps_nal_parse_ctxt, vcl_nal
 WORD32 isvcd_nal_parse_vcl_nal_partial(void *pv_nal_parse_ctxt, UWORD8 *pu1_stream_buffer,
                                        void *pv_out_non_vcl_nal, void *pv_out_vcl_nal,
                                        UWORD32 *pu4_bytes_consumed, UWORD32 *pu4_num_bytes)
 {
     /*! - Search for the NAL boundary
         - If NAL boundary is not found and bytes consumed is lesser than
           minimum buffer size then break out of the loop
         - if it is start of NAL then read the NAL header
         - If it is a VCL NAL then invoke picture boundary detection logic and
           picture boundary is detected then break out of the loop without
           updating the bytes consumed variable
         - NAL discard logic determines whther the current NAL has to be
           discarded or not
         - If NAL is not discarded then populate the vcl or non vcl output
           structures
     */
     nal_parse_ctxt_t *ps_nal_parse_ctxt;
     vcl_nal_t *ps_vcl_nal;
     non_vcl_nal_t *ps_non_vcl_nal;
     nal_unit_t *ps_nal_unit;
     WORD32 i4_nal_start_flag, i4_cur_pos, i4_status;
     WORD32 i4_nal_header_len, i4_more_data_flag;
     UWORD32 u4_bytes_consumed_temp = 0;
     UWORD8 **ppu1_out_buf;
     nal_prms_t *ps_nal_prms;
     WORD32 i4_pic_bound_status;
 
     ps_nal_parse_ctxt = (nal_parse_ctxt_t *) pv_nal_parse_ctxt;
     ps_vcl_nal = (vcl_nal_t *) pv_out_vcl_nal;
     ps_non_vcl_nal = (non_vcl_nal_t *) pv_out_non_vcl_nal;
     ps_nal_unit = (nal_unit_t *) ps_nal_parse_ctxt->pv_nal_unit;
     ps_nal_prms = &ps_nal_parse_ctxt->s_nal_prms;
 
     /* Initialization */
     i4_cur_pos = 0;
     *pu4_bytes_consumed = 0;
     i4_nal_header_len = 0;
     i4_nal_start_flag = SVCD_FALSE;
     i4_more_data_flag = SVCD_TRUE;
     i4_pic_bound_status = PIC_BOUNDARY_FALSE;
 
     ps_non_vcl_nal->i4_num_non_vcl_nals = ps_nal_parse_ctxt->i4_num_non_vcl_nals;
 
     /* Since we do not perform the picture boundary detection */
     /* on the prefix NAL unit, the current picture's prefix   */
     /* NAL unit will be at the bottom of the buffer. Hence    */
     /* it should be copied to top of the buffer               */
     if(SVCD_TRUE == ps_nal_parse_ctxt->i4_is_frst_vcl_nal_in_au)
     {
         nal_buf_t *ps_prefix_nal_buf;
 
         ps_prefix_nal_buf = &ps_nal_parse_ctxt->s_prefix_nal_buf;
         if(SVCD_TRUE == ps_prefix_nal_buf->i4_valid_flag)
         {
             WORD32 i4_buf_size;
             UWORD8 *pu1_vcl_nal;
 
             if(ps_prefix_nal_buf->i4_buf_size > 0)
             {
                 i4_buf_size = ps_prefix_nal_buf->i4_buf_size;
                 i4_buf_size = UP_ALIGN_8(i4_buf_size + BUFFER_ALIGN_4);
             }
             else
             {
                 i4_buf_size = 0;
             }
 
             pu1_vcl_nal = ps_nal_parse_ctxt->pu1_vcl_nal_buf + i4_buf_size;
 
             memmove(ps_nal_parse_ctxt->pu1_vcl_nal_buf, ps_prefix_nal_buf->pu1_buf, i4_buf_size);
             ps_prefix_nal_buf->pu1_buf = ps_nal_parse_ctxt->pu1_vcl_nal_buf;
             ps_nal_parse_ctxt->pu1_vcl_nal_buf = pu1_vcl_nal;
 
             /* subtract the buffer size left */
             ps_nal_parse_ctxt->u4_bytes_left_vcl -= i4_buf_size;
         }
         /* Reset the top and bottom node */
         ps_vcl_nal->ps_top_node = NULL;
         ps_vcl_nal->ps_bot_node = NULL;
         ps_vcl_nal->i1_nal_ref_id_next = -1;
         ps_vcl_nal->u2_frm_num_next = 0;
     }
 
     /* If number of bytes left in the previous process call  */
     /* is is greater or equal to number of bytes in input    */
     /* buffer of the current process call then declare that  */
     /* end of bitstream has occurred and consume the bytes   */
     /* but do not decode                                     */
     if(ps_nal_parse_ctxt->u4_bytes_left >= (UWORD32) *pu4_num_bytes)
     {
         ps_nal_parse_ctxt->i4_discard_nal_flag = SVCD_TRUE;
         *pu4_bytes_consumed = *pu4_num_bytes;
 
         i4_status =
             isvcd_nal_parse_partial_signal_eos(ps_nal_parse_ctxt, ps_vcl_nal, ps_non_vcl_nal);
         /* set the next AU params to default values */
         ps_vcl_nal->i1_nal_ref_id_next = -1;
         ps_vcl_nal->u2_frm_num_next = 0;
 
         return (i4_status);
     }
     ps_nal_parse_ctxt->u4_bytes_left = 0;
 
     /*************************************************************************/
     /*                      LOOP OVER NALs                                   */
     /*************************************************************************/
     do
     {
         nal_buf_t *ps_nal_buf;
         UWORD32 *pu4_bytes_left;
 
         /* Find NAL boundary                */
         if(ANNEX_B == ps_nal_parse_ctxt->i4_input_bitstream_mode)
         {
             i4_nal_start_flag = isvcd_get_annex_b_nal_unit(
                 pu1_stream_buffer, i4_cur_pos, *pu4_num_bytes,
                 &ps_nal_parse_ctxt->i4_find_nal_state, &ps_nal_parse_ctxt->i4_zero_byte_cnt,
                 &u4_bytes_consumed_temp, ps_nal_parse_ctxt->pv_nal_unit, &i4_more_data_flag);
 
             i4_cur_pos += u4_bytes_consumed_temp;
         }
 
         /*********************************************************************/
         /*          READ NAL HEADER AND NAL DISCARD LOGIC                    */
         /*********************************************************************/
 
         /* If it is the start of NAL header perform the following */
         /* 1. Decode NAL header                                   */
         /* 2. Determine whether the NAL has to be discarded or not*/
         /* 3. Detect the picture boundary                         */
         if(SVCD_TRUE == i4_nal_start_flag)
         {
             UWORD32 u4_err_code;
             WORD32 i4_sps_pps_corrupt_status;
             WORD32 i4_internal_dep_id_prev;
 
             /* Get the NAL prms. This involves the following things*/
             /* 1. Decode the NAL header                            */
             /* 2. Set the discard flag                             */
             /* 3. Decode the slice header if needed                */
 
             /* get the dependency id at which the NAl parse is currently */
             /* present */
             i4_internal_dep_id_prev = ps_nal_parse_ctxt->s_int_attr.i4_dependency_id;
 
             i4_status = isvcd_get_nal_prms(
                 ps_nal_unit->pu1_bufs, ps_nal_unit->i4_buf_sizes, ps_nal_prms,
                 &ps_nal_parse_ctxt->s_prefix_nal_prms, &ps_nal_parse_ctxt->s_prefix_nal_buf,
                 &u4_err_code, &i4_sps_pps_corrupt_status, &ps_nal_parse_ctxt->i4_discard_nal_flag,
                 ps_nal_parse_ctxt);
 
             if(NON_ANNEX_B == ps_nal_parse_ctxt->i4_input_bitstream_mode)
             {
                 ps_nal_parse_ctxt->i4_prev_dq_id = ps_nal_prms->i4_dqid;
             }
 
             /* If the error code returned by the "picture boundary" */
             /* detetction is                                        */
             /* 1. Insufficient bitstream size: then store the bytes */
             /*    left and break out of the loop                    */
             /* 2. Corrupted slice: then discard the slice           */
             if((NAL_INSUFFICIENT_DATA == (WORD32) u4_err_code) &&
                (NAL_END != ps_nal_parse_ctxt->i4_find_nal_state))
             {
                 ps_nal_parse_ctxt->u4_bytes_left = *pu4_num_bytes - *pu4_bytes_consumed;
 
                 /* Reset the NAL level tracking variables */
                 isvcd_nal_reset_ctxt(ps_nal_parse_ctxt);
                 break;
             }
             else if(0 != u4_err_code)
             {
                 ps_nal_parse_ctxt->i4_discard_nal_flag = SVCD_TRUE;
 
                 if(SVCD_TRUE == ps_nal_prms->i4_idr_pic_flag)
                 {
                     /* IDR Error handler is called       */
                     /* only if for a given layer the NAL */
                     /* haeder and partial slice decode   */
                     /* routine comes out as no SPS PPS   */
                     /* error. But for Lowest layer in    */
                     /* access unit it is doen always     */
                     if(i4_internal_dep_id_prev != ps_nal_parse_ctxt->s_int_attr.i4_dependency_id)
                     {
                         /* if the target depedency id has been */
                         /* changed while decoding currnet NAL  */
 
                         if((0 != i4_sps_pps_corrupt_status) ||
                            (-1 == ps_nal_parse_ctxt->i4_prev_dq_id))
                         {
                             i4_status =
                                 isvcd_idr_err_hdlr(ps_vcl_nal, ps_nal_prms, ps_nal_parse_ctxt);
                             if(OK != i4_status)
                             {
                                 return i4_status;
                             }
                             UNUSED(i4_status);
 
                             ps_nal_parse_ctxt->i4_tgt_lyr_update = SVCD_FALSE;
                         }
                         else
                         {
                             if(0 == ps_nal_prms->i4_quality_id)
                             {
                                 /* over write the frame number */
                                 ps_nal_parse_ctxt->s_nal_prms.u2_frm_num = 0;
 
                                 /* Get the previous layer's DQID */
                                 if(ps_nal_parse_ctxt->i4_prev_dq_id < ps_nal_prms->i4_dqid)
                                 {
                                     ps_nal_parse_ctxt->i4_prev_dq_id = ps_nal_prms->i4_dqid;
                                     ps_nal_parse_ctxt->i4_is_frst_vcl_nal_in_au = SVCD_FALSE;
                                 }
 
                                 /* update the nal context with the nal */
                                 /* header params */
                                 isvcd_update_nal_ctxt(ps_nal_parse_ctxt, ps_vcl_nal,
                                                       ps_non_vcl_nal);
                             }
                         }
                     }
                 }
             }
 
             /* Populate the derived nal type into bitstream extract*/
             /* context structure                                   */
             i4_nal_header_len = ps_nal_prms->i4_nal_header_len;
             ps_nal_parse_ctxt->i4_nal_type = ps_nal_prms->i4_derived_nal_type;
 
             /* get the accumulated idr pic error flag */
             ps_nal_parse_ctxt->i4_idr_pic_err_flag |=
                 ((SVCD_TRUE == ps_nal_prms->i4_idr_pic_flag) &&
                  (SVCD_FALSE == ps_nal_parse_ctxt->i4_discard_nal_flag) &&
                  (i4_internal_dep_id_prev != ps_nal_parse_ctxt->s_int_attr.i4_dependency_id));
 
             if(ACCESS_UNIT_DELIMITER_RBSP == ps_nal_prms->i4_nal_unit_type)
             {
                 i4_pic_bound_status = PIC_BOUNDARY_TRUE;
                 ps_nal_parse_ctxt->u1_pic_boundary_aud_flag = 1;
                 /* If picture boundary is detected then come out of  */
                 /* the loop                                          */
                 if(PIC_BOUNDARY_TRUE == i4_pic_bound_status)
                 {
                     isvcd_nal_parse_pic_bound_proc(ps_nal_parse_ctxt, ps_vcl_nal, ps_nal_prms);
                     break;
                 }
             }
             /* Perform the picture boundary detetction if all the  */
             /* following conditions are TRUE                       */
             /*  1. VCL NAL                                         */
             /*  2. Not a prefix NAL                                */
             /*  3. Not a discardable NAL                           */
             if((VCL_NAL == ps_nal_prms->i4_derived_nal_type) &&
                (PREFIX_UNIT_NAL != ps_nal_prms->i4_nal_unit_type) &&
                (SVCD_FALSE == ps_nal_parse_ctxt->i4_discard_nal_flag))
             {
                 if(ANNEX_B == ps_nal_parse_ctxt->i4_input_bitstream_mode)
                 {
                     ps_nal_parse_ctxt->u1_pic_boundary_aud_flag = 0;
 
                     i4_status = isvcd_detect_pic_boundary_annex_b(ps_nal_prms, pu1_stream_buffer,
                                                                   i4_cur_pos, &i4_pic_bound_status,
                                                                   ps_nal_parse_ctxt, pu4_num_bytes);
                 }
 
                 /* If picture boundary is detected then come out of  */
                 /* the loop                                          */
                 if(PIC_BOUNDARY_TRUE == i4_pic_bound_status)
                 {
                     isvcd_nal_parse_pic_bound_proc(ps_nal_parse_ctxt, ps_vcl_nal, ps_nal_prms);
                     break;
                 }
             }
 
             if(SVCD_FALSE == ps_nal_parse_ctxt->i4_discard_nal_flag)
             {
                 /* Set the active NAL buffer structure and initialize */
                 /* the nal buffer structure                           */
                 isvcd_get_nal_buf(ps_nal_parse_ctxt, &ps_nal_buf);
                 ps_nal_parse_ctxt->ps_nal_buf = ps_nal_buf;
             }
             else
             {
                 ps_nal_parse_ctxt->ps_nal_buf = NULL;
             }
         }
 
         /*-------------------------------------------------------------------*/
         /* In RFC based bitstreams, this is a dummy update (in this mode, the*/
         /* bytes consumed updation is done by picture boundary dectection    */
         /* But for Annex B based streams this is valid update                */
         /*-------------------------------------------------------------------*/
         *pu4_bytes_consumed += u4_bytes_consumed_temp;
 
         /*********************************************************************/
         /*          EMULATION PREVENTION AND BYTE SWAPPING                   */
         /*********************************************************************/
 
         /* Determine output buffer */
         ps_nal_buf = ps_nal_parse_ctxt->ps_nal_buf;
 
         if(VCL_NAL == ps_nal_parse_ctxt->i4_nal_type)
         {
             ppu1_out_buf = &ps_nal_parse_ctxt->pu1_vcl_nal_buf;
             pu4_bytes_left = &ps_nal_parse_ctxt->u4_bytes_left_vcl;
+            if(*pu4_bytes_left < MAX_VCL_NAL_BUFF_SIZE * 0.05)
+            {
+                return (VCL_NAL_FOUND_FALSE);
+            }
         }
         else
         {
             ppu1_out_buf = &ps_nal_parse_ctxt->pu1_non_vcl_nal_buf;
             pu4_bytes_left = &ps_nal_parse_ctxt->u4_bytes_left_non_vcl;
+            if(*pu4_bytes_left < MAX_NON_VCL_NAL_BUFF_SIZE * 0.05)
+            {
+                return (VCL_NAL_FOUND_FALSE);
+            }
         }
 
         /* if 0 bytes left then discard the current NAL */
         if(0 >= (WORD32) *pu4_bytes_left)
         {
             ps_nal_parse_ctxt->i4_discard_nal_flag = SVCD_TRUE;
         }
 
         /* Perform the emulation prevention and byte swap */
         if(SVCD_FALSE == ps_nal_parse_ctxt->i4_discard_nal_flag)
         {
             UWORD32 u4_output_bytes, u4_buf_inc;
 
             /* Do emulation prevention and byte swapping on all the packets  */
             /* of RFC or current partial or full Annex B NAL unit            */
             {
                 UWORD32 u4_buf_size;
 
                 /* clip the size before emulation prevention */
                 u4_buf_size = (UWORD32) CLIP3(0, (WORD32) *pu4_bytes_left,
                                               (ps_nal_unit->i4_buf_sizes - i4_nal_header_len));
 
                 u4_buf_inc = isvcd_nal_byte_swap_emulation(
                     (UWORD32 *) *ppu1_out_buf, &u4_output_bytes,
                     ps_nal_unit->pu1_bufs + i4_nal_header_len, u4_buf_size,
                     NUM_OF_ZERO_BYTES_BEFORE_START_CODE, &ps_nal_parse_ctxt->s_emulation_ctxt);
 
                 i4_nal_header_len = 0;
                 u4_buf_inc = UP_ALIGN_8(u4_buf_inc);
                 *ppu1_out_buf += u4_buf_inc;
                 *pu4_bytes_left -= u4_buf_inc;
                 ps_nal_buf->i4_buf_size += u4_output_bytes;
             }
         }
 
         /*********************************************************************/
         /*                UPDATE VARIABLES                                   */
         /*********************************************************************/
         if(NAL_END == ps_nal_parse_ctxt->i4_find_nal_state)
         {
             if(SVCD_FALSE == ps_nal_parse_ctxt->i4_discard_nal_flag)
             {
                 /* This fucntions updates output nal ctxt - vcl nal structure*/
                 /* and non vcl nal structure depending upon the current NAL  */
                 /* type.                                                     */
                 /* This will only update parameters which are available at   */
                 /* end of NAL unit like nal unit's total size                */
                 isvcd_update_nal_ctxt(ps_nal_parse_ctxt, ps_vcl_nal, ps_non_vcl_nal);
 
                 UPDATE_NAL_BUF_PTR(ppu1_out_buf, ps_nal_prms->i4_derived_nal_type, pu4_bytes_left);
             }
 
             /* If the prefix NAL unit is not immediatly followed by */
             /* a AVC NAL unit it shall be discarded and hence reset */
             /* is done                                              */
             /* Also if prefix NAL unit is discarded then we should  */
             /* not associate the prefix NAL unit with AVC NAL unit  */
             /* and hence a reset is required                        */
             if((PREFIX_UNIT_NAL != ps_nal_prms->i4_nal_unit_type) ||
                (SVCD_TRUE == ps_nal_parse_ctxt->i4_discard_nal_flag))
             {
                 isvcd_nal_buf_reset(&ps_nal_parse_ctxt->s_prefix_nal_buf);
             }
 
             /* Reset the nal level tracking variables */
             isvcd_nal_reset_ctxt(ps_nal_parse_ctxt);
         }
 
         /*------------- while loop ends here --------------------------------*/
     } while(SVCD_TRUE == i4_more_data_flag);
 
     return (i4_pic_bound_status);
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : isvcd_nal_parse_non_vcl_nal                              */
 /*                                                                           */
 /*  Description   : None                                                     */
 /*                                                                           */
 /*  Inputs        : pv_nal_parse_ctxt - bitstream extract ctxt               */
 /*                      structure                                            */
 /*                  pv_input_bitstream_ctxt - bitstream context              */
 /*                  pv_out_non_vcl_nal - non vcl nal structure (output)      */
 /*                  pu4_bytes_consumed - bytes consumed variable(output)     */
 /*                  pi4_num_packets_consumed - packets consumed (output/RFC) */
 /*                                                                           */
 /*  Globals       : None                                                     */
 /*                                                                           */
 /*  Processing    : None                                                     */
 /*                                                                           */
 /*  Outputs       : Updates bytes consumed variable, packets consumed,       */
 /*                  output structures (non vcl nal)                          */
 /*                                                                           */
 /*  Returns       : If vcl nal is found then VCL_NAL_FOUND_TRUE otherwise    */
 /*                  VCL_NAL_FOUND_FALSE                                      */
 /*                                                                           */
 /*  Issues        : None                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*          DD MM YYYY   Author(s)       Changes                             */
 /*          06 09 2021   Vijay      Draft                                    */
 /*                                                                           */
 /*****************************************************************************/
@@ -2154,266 +2161,274 @@ WORD32 isvcd_nal_parse_vcl_nal_partial(void *pv_nal_parse_ctxt, UWORD8 *pu1_stre
 WORD32 isvcd_nal_parse_non_vcl_nal(void *pv_nal_parse_ctxt, UWORD8 *pu1_stream_buffer,
                                    void *pv_out_non_vcl_nal, UWORD32 *pu4_bytes_consumed,
                                    UWORD32 *pu4_num_bytes)
 {
     /*! - Search for the NAL boundary
         - If NAL boundary is not found and bytes consumed is lesser than
           minimum buffer size then break out of the loop
         - if it is start of NAL then read the NAL header
         - If it is a VCL NAL then return from this fucntion saying that
           VCL NAL found
         - NAL discard logic determines whther the current NAL has to be
           discarded or not
         - If NAL is not discarded then populate the vcl or non vcl output
           structures
     */
 
     nal_parse_ctxt_t *ps_nal_parse_ctxt;
     non_vcl_nal_t *ps_non_vcl_nal;
     nal_unit_t *ps_nal_unit;
     WORD32 i4_nal_start_flag, i4_cur_pos, i4_status;
     WORD32 i4_nal_header_len, i4_more_data_flag;
     UWORD32 u4_bytes_consumed_temp = 0;
     UWORD8 **ppu1_out_buf;
     nal_prms_t *ps_nal_prms;
 
     ps_nal_parse_ctxt = (nal_parse_ctxt_t *) pv_nal_parse_ctxt;
     ps_non_vcl_nal = (non_vcl_nal_t *) pv_out_non_vcl_nal;
     ps_nal_unit = (nal_unit_t *) ps_nal_parse_ctxt->pv_nal_unit;
     ps_nal_prms = &ps_nal_parse_ctxt->s_nal_prms;
 
     /* Initialization */
     i4_cur_pos = 0;
     *pu4_bytes_consumed = 0;
     i4_nal_header_len = 0;
     i4_nal_start_flag = SVCD_FALSE;
     i4_more_data_flag = SVCD_TRUE;
     i4_status = PIC_BOUNDARY_FALSE;
 
     /* reset the target layer update flag */
     ps_nal_parse_ctxt->i4_tgt_lyr_update = SVCD_FALSE;
     /*************************************************************************/
     /*              SEARCHING FOR THE START OF BITSTREAM                     */
     /*************************************************************************/
 
     /*-----------------------------------------------------------------------*/
     /* For Annex B based bitstreams the first start code has to decoded      */
     /* The first start code can come after multiple process call also. This  */
     /* has to be carefully handled                                           */
     /*-----------------------------------------------------------------------*/
 
     if(ANNEX_B == ps_nal_parse_ctxt->i4_input_bitstream_mode &&
        SVCD_TRUE == ps_nal_parse_ctxt->i4_dec_frst_sc_flag)
     {
         WORD32 i4_status;
 
         i4_status =
             isvcd_get_first_start_code(pu1_stream_buffer, pu4_bytes_consumed, pu4_num_bytes);
 
         /*-------------------------------------------------------------------*/
         /* If start code found then proceed with bitstream extraction        */
         /*-------------------------------------------------------------------*/
 
         if(i4_status == SC_NOT_FOUND)
         {
             return (VCL_NAL_FOUND_FALSE);
         }
 
         i4_cur_pos = *pu4_bytes_consumed;
         ps_nal_parse_ctxt->i4_dec_frst_sc_flag = SVCD_FALSE;
     }
 
     /* If number of bytes left in the previous process call  */
     /* is is greater or equal to number of bytes in input    */
     /* buffer of the current process call then declare that  */
     /* end of bitstream has occurred and consume the bytes   */
     /* but do not decode                                     */
     if(ps_nal_parse_ctxt->u4_bytes_left >= (UWORD32) *pu4_num_bytes)
     {
         ps_nal_parse_ctxt->i4_discard_nal_flag = SVCD_TRUE;
         *pu4_bytes_consumed = *pu4_num_bytes;
 
         i4_status = isvcd_nal_parse_partial_signal_eos(ps_nal_parse_ctxt, NULL, ps_non_vcl_nal);
         return (i4_status);
     }
 
     do
     {
         nal_buf_t *ps_nal_buf;
         UWORD32 *pu4_bytes_left;
 
         /*********************************************************************/
         /*                  NAL BOUNDARY DETECTION                           */
         /*********************************************************************/
         /*-------------------------------------------------------------------*/
         /* Detect NAL boundary                                               */
         /* After return,  this NAL boundary detetction logic might be in     */
         /* one of following states:                                          */
         /*  - NAL_START                                                      */
         /*  - FIND_NAL_END                                                   */
         /*  - NAL_END                                                        */
         /*-------------------------------------------------------------------*/
         if(ANNEX_B == ps_nal_parse_ctxt->i4_input_bitstream_mode)
         {
             i4_nal_start_flag = isvcd_get_annex_b_nal_unit(
                 pu1_stream_buffer, i4_cur_pos, *pu4_num_bytes,
                 &ps_nal_parse_ctxt->i4_find_nal_state, &ps_nal_parse_ctxt->i4_zero_byte_cnt,
                 &u4_bytes_consumed_temp, ps_nal_parse_ctxt->pv_nal_unit, &i4_more_data_flag);
 
             i4_cur_pos += u4_bytes_consumed_temp;
         }
 
         /* If current NAL unit is start of new NAL unit then parse the NAL
             header. If the current NAL unit type is VCL NAL then return from
             this function. otherwise apply NAL discard logic and discard the
             NAL if discard NAL flag is true                                  */
 
         if(SVCD_TRUE == i4_nal_start_flag)
         {
             UWORD32 u4_err_code;
             WORD32 i4_sps_pps_corrupt_status;
 
             /* Get the NAL prms. This involves the following things*/
             /* 1. Decode the NAL header                            */
             /* 2. Set the discard flag                             */
             /* 3. Decode the slice header if needed                */
             isvcd_get_nal_prms(ps_nal_unit->pu1_bufs, ps_nal_unit->i4_buf_sizes, ps_nal_prms,
                                &ps_nal_parse_ctxt->s_prefix_nal_prms,
                                &ps_nal_parse_ctxt->s_prefix_nal_buf, &u4_err_code,
                                &i4_sps_pps_corrupt_status, &ps_nal_parse_ctxt->i4_discard_nal_flag,
                                ps_nal_parse_ctxt);
             /* If the error code returned by the "picture boundary" */
             /* detetction is                                        */
             /* 1. Insufficient bitstream size: then store the bytes */
             /*    left and break out of the loop                    */
             /* 2. Corrupted slice: then discard the slice           */
             if((NAL_INSUFFICIENT_DATA == (WORD32) u4_err_code) &&
                (NAL_END != ps_nal_parse_ctxt->i4_find_nal_state))
             {
                 ps_nal_parse_ctxt->u4_bytes_left = *pu4_num_bytes - *pu4_bytes_consumed;
 
                 /* Reset the NAL level tracking variables */
                 isvcd_nal_reset_ctxt(ps_nal_parse_ctxt);
                 break;
             }
             else if(0 != u4_err_code)
             {
                 ps_nal_parse_ctxt->i4_discard_nal_flag = SVCD_TRUE;
             }
 
             /* Populate other paramters based on the nal prms */
             ps_nal_parse_ctxt->i4_nal_type = ps_nal_prms->i4_derived_nal_type;
             i4_nal_header_len = ps_nal_prms->i4_nal_header_len;
 
             /* If derived NAL unit is VCL_NAL then return from this function */
             if(VCL_NAL == ps_nal_prms->i4_derived_nal_type &&
                PREFIX_UNIT_NAL != ps_nal_prms->i4_nal_unit_type)
             {
                 isvcd_pic_reset_ctxt(ps_nal_parse_ctxt);
 
                 return (VCL_NAL_FOUND_TRUE);
             }
 
             /* Set the active NAL buffer structure and initialize */
             /* the nal buffer structure                           */
             isvcd_get_nal_buf(ps_nal_parse_ctxt, &ps_nal_buf);
 
             ps_nal_parse_ctxt->ps_nal_buf = ps_nal_buf;
         }
 
         /* Update the bytes consumed variable */
 
         *pu4_bytes_consumed += u4_bytes_consumed_temp;
 
         ps_nal_buf = ps_nal_parse_ctxt->ps_nal_buf;
         if(VCL_NAL == ps_nal_parse_ctxt->i4_nal_type)
         {
             ppu1_out_buf = &ps_nal_parse_ctxt->pu1_vcl_nal_buf;
             pu4_bytes_left = &ps_nal_parse_ctxt->u4_bytes_left_vcl;
+            if(*pu4_bytes_left < MAX_VCL_NAL_BUFF_SIZE * 0.05)
+            {
+                return (VCL_NAL_FOUND_FALSE);
+            }
         }
         else
         {
             ppu1_out_buf = &ps_nal_parse_ctxt->pu1_non_vcl_nal_buf;
             pu4_bytes_left = &ps_nal_parse_ctxt->u4_bytes_left_non_vcl;
+            if(*pu4_bytes_left < MAX_NON_VCL_NAL_BUFF_SIZE * 0.05)
+            {
+                return (VCL_NAL_FOUND_FALSE);
+            }
         }
 
         /* if 0 bytes left then discard the current NAL */
         if(0 >= (WORD32) *pu4_bytes_left)
         {
             ps_nal_parse_ctxt->i4_discard_nal_flag = SVCD_TRUE;
         }
 
         /* If NAL is not discarded then :
             1) Perform emulation prevention and byte swapping on the RBSP data
             2) Update the NAL unit ctxt:
                 a) If VCL NAL then update DQID list
                 b) If NON VCL NAL then update the non vcl output structure   */
 
         if(SVCD_FALSE == ps_nal_parse_ctxt->i4_discard_nal_flag)
         {
             UWORD32 u4_output_bytes, u4_buf_inc;
 
             {
                 UWORD32 u4_buf_size;
 
                 /* clip the size before emulation prevention */
                 u4_buf_size = (UWORD32) CLIP3(0, (WORD32) *pu4_bytes_left,
                                               (ps_nal_unit->i4_buf_sizes - i4_nal_header_len));
 
                 u4_buf_inc = isvcd_nal_byte_swap_emulation(
                     (UWORD32 *) *ppu1_out_buf, &u4_output_bytes,
                     ps_nal_unit->pu1_bufs + i4_nal_header_len, u4_buf_size,
                     NUM_OF_ZERO_BYTES_BEFORE_START_CODE, &ps_nal_parse_ctxt->s_emulation_ctxt);
                 i4_nal_header_len = 0;
 
                 u4_buf_inc = UP_ALIGN_8(u4_buf_inc);
                 *ppu1_out_buf += u4_buf_inc;
                 *pu4_bytes_left -= u4_buf_inc;
                 ps_nal_buf->i4_buf_size += u4_output_bytes;
             }
         }
 
         /*********************************************************************/
         /*                UPDATE VARIABLES                                   */
         /*********************************************************************/
 
         if(NAL_END == ps_nal_parse_ctxt->i4_find_nal_state)
         {
             /*---------------------------------------------------------------*/
             /* - Update the total bits in the NAL. While doing so bits       */
             /* calculated so far should be converted to SODB length          */
             /*---------------------------------------------------------------*/
             if(SVCD_FALSE == ps_nal_parse_ctxt->i4_discard_nal_flag)
             {
                 isvcd_update_nal_ctxt(ps_nal_parse_ctxt, NULL, ps_non_vcl_nal);
 
                 UPDATE_NAL_BUF_PTR(ppu1_out_buf, ps_nal_prms->i4_derived_nal_type, pu4_bytes_left);
             }
 
             /* If the prefix NAL unit is not immediatly followed by */
             /* a AVC NAL unit it shall be discarded and hence reset */
             /* is done                                              */
             /* Also if prefix NAL unit is discarded then we should  */
             /* not associate the prefix NAL unit with AVC NAL unit  */
             /* and hence a reset is required                        */
             if((PREFIX_UNIT_NAL != ps_nal_prms->i4_nal_unit_type) ||
                (SVCD_TRUE == ps_nal_parse_ctxt->i4_discard_nal_flag))
             {
                 isvcd_nal_buf_reset(&ps_nal_parse_ctxt->s_prefix_nal_buf);
             }
 
             /* Reset NAL level tracking variables */
             isvcd_nal_reset_ctxt(ps_nal_parse_ctxt);
         }
 
         i4_nal_header_len = 0;
         /*------------- while loop ends here --------------------------------*/
     } while(SVCD_TRUE == i4_more_data_flag);
 
     if(i4_more_data_flag == 0)
     {
         isvcd_pic_reset_ctxt(ps_nal_parse_ctxt);
         return (VCL_NAL_FOUND_TRUE);
     }
 
     return (VCL_NAL_FOUND_FALSE);
 }
\ No newline at end of file
