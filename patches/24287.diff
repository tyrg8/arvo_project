commit 6304ec7041f12084b2447e54da0d0118fe30300c
Author: Juan Pedro Bol√≠var Puente <raskolnikov@gnu.org>
Date:   Tue Jul 21 17:55:37 2020 +0200

    Fix flex-vector-gc fuzzer issues related to large concats
    
    Given that flex-vector suports confluent concatenation, we can produce
    absurdly large structures.  At some point, we saturate the internal
    data-structure, producing structures that are simply too deep, and not
    indexable with the given `shift`.
    
    Here, we modify the fuzzer to prevent building such absurdly large
    structures once we reach a saturation point.

diff --git a/extra/fuzzer/flex-vector-gc.cpp b/extra/fuzzer/flex-vector-gc.cpp
index 00c3028..362ee79 100644
--- a/extra/fuzzer/flex-vector-gc.cpp
+++ b/extra/fuzzer/flex-vector-gc.cpp
@@ -23,140 +23,138 @@ using gc_memory = immer::memory_policy<immer::heap_policy<immer::gc_heap>,
 extern "C" int LLVMFuzzerTestOneInput(const std::uint8_t* data,
                                       std::size_t size)
 {
     constexpr auto var_count = 4;
     constexpr auto bits      = 2;
 
     using vector_t    = immer::flex_vector<int, gc_memory, bits, bits>;
     using transient_t = typename vector_t::transient_type;
     using size_t      = std::uint8_t;
 
     auto vs = std::array<vector_t, var_count>{};
     auto ts = std::array<transient_t, var_count>{};
 
     auto is_valid_var = [&](auto idx) { return idx >= 0 && idx < var_count; };
     auto is_valid_var_neq = [](auto other) {
         return [=](auto idx) {
             return idx >= 0 && idx < var_count && idx != other;
         };
     };
     auto is_valid_index = [](auto& v) {
         return [&](auto idx) { return idx >= 0 && idx < v.size(); };
     };
     auto is_valid_size = [](auto& v) {
         return [&](auto idx) { return idx >= 0 && idx <= v.size(); };
     };
     auto can_concat = [](auto&& v1, auto&& v2) {
-        using size_type = decltype(v1.size());
-        auto max        = std::numeric_limits<size_type>::max() >> (bits * 4);
-        return v1.size() < max && v2.size() < max;
+        return v1.size() + v2.size() < vector_t::max_size();
     };
 
     return fuzzer_input{data, size}.run([&](auto& in) {
         enum ops
         {
             op_transient,
             op_persistent,
             op_push_back,
             op_update,
             op_take,
             op_drop,
             op_concat,
             op_push_back_mut,
             op_update_mut,
             op_take_mut,
             op_drop_mut,
             op_prepend_mut,
             op_prepend_mut_move,
             op_append_mut,
             op_append_mut_move,
         };
         auto dst = read<char>(in, is_valid_var);
         switch (read<char>(in)) {
         case op_transient: {
             auto src = read<char>(in, is_valid_var);
             ts[dst]  = vs[src].transient();
             break;
         }
         case op_persistent: {
             auto src = read<char>(in, is_valid_var);
             vs[dst]  = ts[src].persistent();
             break;
         }
         case op_push_back: {
             auto src = read<char>(in, is_valid_var);
             vs[dst]  = vs[src].push_back(42);
             break;
         }
         case op_update: {
             auto src = read<char>(in, is_valid_var);
             auto idx = read<size_t>(in, is_valid_index(vs[src]));
             vs[dst]  = vs[src].update(idx, [](auto x) { return x + 1; });
             break;
         }
         case op_take: {
             auto src = read<char>(in, is_valid_var);
             auto idx = read<size_t>(in, is_valid_size(vs[src]));
             vs[dst]  = vs[src].take(idx);
             break;
         }
         case op_drop: {
             auto src = read<char>(in, is_valid_var);
             auto idx = read<size_t>(in, is_valid_size(vs[src]));
             vs[dst]  = vs[src].drop(idx);
             break;
         }
         case op_concat: {
             auto src  = read<char>(in, is_valid_var);
             auto src2 = read<char>(in, is_valid_var);
             if (can_concat(vs[src], vs[src2]))
                 vs[dst] = vs[src] + vs[src2];
             break;
         }
         case op_push_back_mut: {
             ts[dst].push_back(13);
             break;
         }
         case op_update_mut: {
             auto idx = read<size_t>(in, is_valid_index(ts[dst]));
             ts[dst].update(idx, [](auto x) { return x + 1; });
             break;
         }
         case op_take_mut: {
             auto idx = read<size_t>(in, is_valid_size(ts[dst]));
             ts[dst].take(idx);
             break;
         }
         case op_prepend_mut: {
             auto src = read<char>(in, is_valid_var_neq(dst));
             if (can_concat(ts[dst], ts[src]))
                 ts[dst].prepend(ts[src]);
             break;
         }
         case op_prepend_mut_move: {
             auto src = read<char>(in, is_valid_var_neq(dst));
             if (can_concat(ts[dst], ts[src])) {
                 ts[dst].prepend(std::move(ts[src]));
                 ts[src] = {};
             }
             break;
         }
         case op_append_mut: {
             auto src = read<char>(in, is_valid_var_neq(dst));
             if (can_concat(ts[dst], ts[src]))
                 ts[dst].append(ts[src]);
             break;
         }
         case op_append_mut_move: {
             auto src = read<char>(in, is_valid_var_neq(dst));
             if (can_concat(ts[dst], ts[src])) {
                 ts[dst].append(std::move(ts[src]));
                 ts[src] = {};
             }
             break;
         }
         default:
             break;
         };
         return true;
     });
 }
diff --git a/immer/detail/rbts/rbtree.hpp b/immer/detail/rbts/rbtree.hpp
index b31f5e9..2ad8da8 100644
--- a/immer/detail/rbts/rbtree.hpp
+++ b/immer/detail/rbts/rbtree.hpp
@@ -26,484 +26,490 @@ template <typename T, typename MemoryPolicy, bits_t B, bits_t BL>
 struct rbtree
 {
     using node_t  = node<T, MemoryPolicy, B, BL>;
     using edit_t  = typename node_t::edit_t;
     using owner_t = typename MemoryPolicy::transience_t::owner;
 
     size_t size;
     shift_t shift;
     node_t* root;
     node_t* tail;
 
+    constexpr static size_t max_size()
+    {
+        auto S = sizeof(size_t) * 8;
+        return (size_t{1} << BL) * ipow(size_t{1} << B, (S - BL) / B);
+    }
+
     static const rbtree& empty()
     {
         static const rbtree empty_{
             0, BL, node_t::make_inner_n(0u), node_t::make_leaf_n(0u)};
         return empty_;
     }
 
     template <typename U>
     static auto from_initializer_list(std::initializer_list<U> values)
     {
         auto e      = owner_t{};
         auto result = rbtree{empty()};
         for (auto&& v : values)
             result.push_back_mut(e, v);
         return result;
     }
 
     template <typename Iter,
               typename Sent,
               std::enable_if_t<compatible_sentinel_v<Iter, Sent>, bool> = true>
     static auto from_range(Iter first, Sent last)
     {
         auto e      = owner_t{};
         auto result = rbtree{empty()};
         for (; first != last; ++first)
             result.push_back_mut(e, *first);
         return result;
     }
 
     static auto from_fill(size_t n, T v)
     {
         auto e      = owner_t{};
         auto result = rbtree{empty()};
         while (n-- > 0)
             result.push_back_mut(e, v);
         return result;
     }
 
     rbtree(size_t sz, shift_t sh, node_t* r, node_t* t)
         : size{sz}
         , shift{sh}
         , root{r}
         , tail{t}
     {
         assert(check_tree());
     }
 
     rbtree(const rbtree& other)
         : rbtree{other.size, other.shift, other.root, other.tail}
     {
         inc();
     }
 
     rbtree(rbtree&& other)
         : rbtree{empty()}
     {
         swap(*this, other);
     }
 
     rbtree& operator=(const rbtree& other)
     {
         auto next = other;
         swap(*this, next);
         return *this;
     }
 
     rbtree& operator=(rbtree&& other)
     {
         swap(*this, other);
         return *this;
     }
 
     friend void swap(rbtree& x, rbtree& y)
     {
         using std::swap;
         swap(x.size, y.size);
         swap(x.shift, y.shift);
         swap(x.root, y.root);
         swap(x.tail, y.tail);
     }
 
     ~rbtree() { dec(); }
 
     void inc() const
     {
         root->inc();
         tail->inc();
     }
 
     void dec() const { traverse(dec_visitor()); }
 
     auto tail_size() const { return size ? ((size - 1) & mask<BL>) +1 : 0; }
 
     auto tail_offset() const { return size ? (size - 1) & ~mask<BL> : 0; }
 
     template <typename Visitor, typename... Args>
     void traverse(Visitor v, Args&&... args) const
     {
         auto tail_off  = tail_offset();
         auto tail_size = size - tail_off;
 
         if (tail_off)
             make_regular_sub_pos(root, shift, tail_off).visit(v, args...);
         else
             make_empty_regular_pos(root).visit(v, args...);
 
         make_leaf_sub_pos(tail, tail_size).visit(v, args...);
     }
 
     template <typename Visitor, typename... Args>
     void traverse(Visitor v, size_t first, size_t last, Args&&... args) const
     {
         auto tail_off  = tail_offset();
         auto tail_size = size - tail_off;
 
         if (first < tail_off)
             make_regular_sub_pos(root, shift, tail_off)
                 .visit(v, first, last < tail_off ? last : tail_off, args...);
         if (last > tail_off)
             make_leaf_sub_pos(tail, tail_size)
                 .visit(v,
                        first > tail_off ? first - tail_off : 0,
                        last - tail_off,
                        args...);
     }
 
     template <typename Visitor, typename... Args>
     bool traverse_p(Visitor v, Args&&... args) const
     {
         auto tail_off  = tail_offset();
         auto tail_size = size - tail_off;
         return (tail_off ? make_regular_sub_pos(root, shift, tail_off)
                                .visit(v, args...)
                          : make_empty_regular_pos(root).visit(v, args...)) &&
                make_leaf_sub_pos(tail, tail_size).visit(v, args...);
     }
 
     template <typename Visitor, typename... Args>
     bool traverse_p(Visitor v, size_t first, size_t last, Args&&... args) const
     {
         auto tail_off  = tail_offset();
         auto tail_size = size - tail_off;
 
         return (first < tail_off ? make_regular_sub_pos(root, shift, tail_off)
                                        .visit(v,
                                               first,
                                               last < tail_off ? last : tail_off,
                                               args...)
                                  : true) &&
                (last > tail_off
                     ? make_leaf_sub_pos(tail, tail_size)
                           .visit(v,
                                  first > tail_off ? first - tail_off : 0,
                                  last - tail_off,
                                  args...)
                     : true);
     }
 
     template <typename Visitor>
     decltype(auto) descend(Visitor v, size_t idx) const
     {
         auto tail_off = tail_offset();
         return idx >= tail_off ? make_leaf_descent_pos(tail).visit(v, idx)
                                : visit_regular_descent(root, shift, v, idx);
     }
 
     template <typename Fn>
     void for_each_chunk(Fn&& fn) const
     {
         traverse(for_each_chunk_visitor{}, std::forward<Fn>(fn));
     }
 
     template <typename Fn>
     void for_each_chunk(size_t first, size_t last, Fn&& fn) const
     {
         traverse(for_each_chunk_i_visitor{}, first, last, std::forward<Fn>(fn));
     }
 
     template <typename Fn>
     bool for_each_chunk_p(Fn&& fn) const
     {
         return traverse_p(for_each_chunk_p_visitor{}, std::forward<Fn>(fn));
     }
 
     template <typename Fn>
     bool for_each_chunk_p(size_t first, size_t last, Fn&& fn) const
     {
         return traverse_p(
             for_each_chunk_p_i_visitor{}, first, last, std::forward<Fn>(fn));
     }
 
     bool equals(const rbtree& other) const
     {
         if (size != other.size)
             return false;
         if (size == 0)
             return true;
         return (size <= branches<BL> ||
                 make_regular_sub_pos(root, shift, tail_offset())
                     .visit(equals_visitor{}, other.root)) &&
                make_leaf_sub_pos(tail, tail_size())
                    .visit(equals_visitor{}, other.tail);
     }
 
     void ensure_mutable_tail(edit_t e, count_t n)
     {
         if (!tail->can_mutate(e)) {
             auto new_tail = node_t::copy_leaf_e(e, tail, n);
             dec_leaf(tail, n);
             tail = new_tail;
         }
     }
 
     void push_back_mut(edit_t e, T value)
     {
         auto tail_off = tail_offset();
         auto ts       = size - tail_off;
         if (ts < branches<BL>) {
             ensure_mutable_tail(e, ts);
             new (&tail->leaf()[ts]) T{std::move(value)};
         } else {
             auto new_tail = node_t::make_leaf_e(e, std::move(value));
             try {
                 if (tail_off == size_t{branches<B>} << shift) {
                     auto new_root = node_t::make_inner_e(e);
                     try {
                         auto path = node_t::make_path_e(e, shift, tail);
                         new_root->inner()[0] = root;
                         new_root->inner()[1] = path;
                         root                 = new_root;
                         tail                 = new_tail;
                         shift += B;
                     } catch (...) {
                         node_t::delete_inner_e(new_root);
                         throw;
                     }
                 } else if (tail_off) {
                     auto new_root =
                         make_regular_sub_pos(root, shift, tail_off)
                             .visit(push_tail_mut_visitor<node_t>{}, e, tail);
                     root = new_root;
                     tail = new_tail;
                 } else {
                     auto new_root = node_t::make_path_e(e, shift, tail);
                     assert(tail_off == 0);
                     dec_empty_regular(root);
                     root = new_root;
                     tail = new_tail;
                 }
             } catch (...) {
                 node_t::delete_leaf(new_tail, 1);
                 throw;
             }
         }
         ++size;
     }
 
     rbtree push_back(T value) const
     {
         auto tail_off = tail_offset();
         auto ts       = size - tail_off;
         if (ts < branches<BL>) {
             auto new_tail =
                 node_t::copy_leaf_emplace(tail, ts, std::move(value));
             return {size + 1, shift, root->inc(), new_tail};
         } else {
             auto new_tail = node_t::make_leaf_n(1, std::move(value));
             try {
                 if (tail_off == size_t{branches<B>} << shift) {
                     auto new_root = node_t::make_inner_n(2);
                     try {
                         auto path            = node_t::make_path(shift, tail);
                         new_root->inner()[0] = root;
                         new_root->inner()[1] = path;
                         root->inc();
                         tail->inc();
                         return {size + 1, shift + B, new_root, new_tail};
                     } catch (...) {
                         node_t::delete_inner(new_root, 2);
                         throw;
                     }
                 } else if (tail_off) {
                     auto new_root =
                         make_regular_sub_pos(root, shift, tail_off)
                             .visit(push_tail_visitor<node_t>{}, tail);
                     tail->inc();
                     return {size + 1, shift, new_root, new_tail};
                 } else {
                     auto new_root = node_t::make_path(shift, tail);
                     tail->inc();
                     return {size + 1, shift, new_root, new_tail};
                 }
             } catch (...) {
                 node_t::delete_leaf(new_tail, 1);
                 throw;
             }
         }
     }
 
     const T* array_for(size_t index) const
     {
         return descend(array_for_visitor<T>(), index);
     }
 
     T& get_mut(edit_t e, size_t idx)
     {
         auto tail_off = tail_offset();
         if (idx >= tail_off) {
             ensure_mutable_tail(e, size - tail_off);
             return tail->leaf()[idx & mask<BL>];
         } else {
             return make_regular_sub_pos(root, shift, tail_off)
                 .visit(get_mut_visitor<node_t>{}, idx, e, &root);
         }
     }
 
     const T& get(size_t index) const
     {
         return descend(get_visitor<T>(), index);
     }
 
     const T& get_check(size_t index) const
     {
         if (index >= size)
             throw std::out_of_range{"index out of range"};
         return descend(get_visitor<T>(), index);
     }
 
     const T& front() const { return get(0); }
 
     const T& back() const { return tail->leaf()[(size - 1) & mask<BL>]; }
 
     template <typename FnT>
     void update_mut(edit_t e, size_t idx, FnT&& fn)
     {
         auto& elem = get_mut(e, idx);
         elem       = std::forward<FnT>(fn)(std::move(elem));
     }
 
     template <typename FnT>
     rbtree update(size_t idx, FnT&& fn) const
     {
         auto tail_off = tail_offset();
         if (idx >= tail_off) {
             auto tail_size = size - tail_off;
             auto new_tail =
                 make_leaf_sub_pos(tail, tail_size)
                     .visit(update_visitor<node_t>{}, idx - tail_off, fn);
             return {size, shift, root->inc(), new_tail};
         } else {
             auto new_root = make_regular_sub_pos(root, shift, tail_off)
                                 .visit(update_visitor<node_t>{}, idx, fn);
             return {size, shift, new_root, tail->inc()};
         }
     }
 
     void assoc_mut(edit_t e, size_t idx, T value)
     {
         update_mut(e, idx, [&](auto&&) { return std::move(value); });
     }
 
     rbtree assoc(size_t idx, T value) const
     {
         return update(idx, [&](auto&&) { return std::move(value); });
     }
 
     rbtree take(size_t new_size) const
     {
         auto tail_off = tail_offset();
         if (new_size == 0) {
             return empty();
         } else if (new_size >= size) {
             return *this;
         } else if (new_size > tail_off) {
             auto new_tail = node_t::copy_leaf(tail, new_size - tail_off);
             return {new_size, shift, root->inc(), new_tail};
         } else {
             using std::get;
             auto l = new_size - 1;
             auto v = slice_right_visitor<node_t>();
             auto r = make_regular_sub_pos(root, shift, tail_off).visit(v, l);
             auto new_shift = get<0>(r);
             auto new_root  = get<1>(r);
             auto new_tail  = get<3>(r);
             if (new_root) {
                 IMMER_ASSERT_TAGGED(new_root->compute_shift() == get<0>(r));
                 assert(new_root->check(new_shift, new_size - get<2>(r)));
                 return {new_size, new_shift, new_root, new_tail};
             } else {
                 return {new_size, BL, empty().root->inc(), new_tail};
             }
         }
     }
 
     void take_mut(edit_t e, size_t new_size)
     {
         auto tail_off = tail_offset();
         if (new_size == 0) {
             // todo: more efficient?
             *this = empty();
         } else if (new_size >= size) {
             return;
         } else if (new_size > tail_off) {
             auto ts    = size - tail_off;
             auto newts = new_size - tail_off;
             if (tail->can_mutate(e)) {
                 destroy_n(tail->leaf() + newts, ts - newts);
             } else {
                 auto new_tail = node_t::copy_leaf_e(e, tail, newts);
                 dec_leaf(tail, ts);
                 tail = new_tail;
             }
             size = new_size;
             return;
         } else {
             using std::get;
             auto l = new_size - 1;
             auto v = slice_right_mut_visitor<node_t>();
             auto r = make_regular_sub_pos(root, shift, tail_off).visit(v, l, e);
             auto new_shift = get<0>(r);
             auto new_root  = get<1>(r);
             auto new_tail  = get<3>(r);
             if (new_root) {
                 root  = new_root;
                 shift = new_shift;
             } else {
                 root  = empty().root->inc();
                 shift = BL;
             }
             dec_leaf(tail, size - tail_off);
             size = new_size;
             tail = new_tail;
             return;
         }
     }
 
     bool check_tree() const
     {
 #if IMMER_DEBUG_DEEP_CHECK
         assert(shift >= BL);
         assert(tail_offset() <= size);
         assert(check_root());
         assert(check_tail());
 #endif
         return true;
     }
 
     bool check_tail() const
     {
 #if IMMER_DEBUG_DEEP_CHECK
         if (tail_size() > 0)
             assert(tail->check(0, tail_size()));
 #endif
         return true;
     }
 
     bool check_root() const
     {
 #if IMMER_DEBUG_DEEP_CHECK
         if (tail_offset() > 0)
             assert(root->check(shift, tail_offset()));
         else {
             IMMER_ASSERT_TAGGED(root->kind() == node_t::kind_t::inner);
             assert(shift == BL);
         }
 #endif
         return true;
     }
 };
 
 } // namespace rbts
 } // namespace detail
 } // namespace immer
diff --git a/immer/detail/rbts/rrbtree.hpp b/immer/detail/rbts/rrbtree.hpp
index 7bf59e6..1e8f168 100644
--- a/immer/detail/rbts/rrbtree.hpp
+++ b/immer/detail/rbts/rrbtree.hpp
@@ -30,1367 +30,1383 @@ template <typename T, typename MemoryPolicy, bits_t B, bits_t BL>
 struct rrbtree
 {
     using node_t  = node<T, MemoryPolicy, B, BL>;
     using edit_t  = typename node_t::edit_t;
     using owner_t = typename MemoryPolicy::transience_t::owner;
 
     size_t size;
     shift_t shift;
     node_t* root;
     node_t* tail;
 
+    constexpr static size_t max_size()
+    {
+        auto S = sizeof(size_t) * 8;
+        return std::max(((size_t{1} << BL) - 1), size_t{1}) *
+               ipow((size_t{1} << B) - 1, (S - BL - B) / B);
+    }
+
     static const rrbtree& empty()
     {
         static const rrbtree empty_{
             0, BL, node_t::make_inner_n(0u), node_t::make_leaf_n(0u)};
         return empty_;
     }
 
     template <typename U>
     static auto from_initializer_list(std::initializer_list<U> values)
     {
         auto e      = owner_t{};
         auto result = rrbtree{empty()};
         for (auto&& v : values)
             result.push_back_mut(e, v);
         return result;
     }
 
     template <typename Iter,
               typename Sent,
               std::enable_if_t<compatible_sentinel_v<Iter, Sent>, bool> = true>
     static auto from_range(Iter first, Sent last)
     {
         auto e      = owner_t{};
         auto result = rrbtree{empty()};
         for (; first != last; ++first)
             result.push_back_mut(e, *first);
         return result;
     }
 
     static auto from_fill(size_t n, T v)
     {
         auto e      = owner_t{};
         auto result = rrbtree{empty()};
         while (n-- > 0)
             result.push_back_mut(e, v);
         return result;
     }
 
     rrbtree(size_t sz, shift_t sh, node_t* r, node_t* t)
         : size{sz}
         , shift{sh}
         , root{r}
         , tail{t}
     {
         assert(check_tree());
     }
 
     rrbtree(const rrbtree& other)
         : rrbtree{other.size, other.shift, other.root, other.tail}
     {
         inc();
     }
 
     rrbtree(rrbtree&& other)
         : rrbtree{empty()}
     {
         swap(*this, other);
     }
 
     rrbtree& operator=(const rrbtree& other)
     {
         auto next{other};
         swap(*this, next);
         return *this;
     }
 
     rrbtree& operator=(rrbtree&& other)
     {
         swap(*this, other);
         return *this;
     }
 
     friend void swap(rrbtree& x, rrbtree& y)
     {
         using std::swap;
         swap(x.size, y.size);
         swap(x.shift, y.shift);
         swap(x.root, y.root);
         swap(x.tail, y.tail);
     }
 
     ~rrbtree() { dec(); }
 
     void inc() const
     {
         root->inc();
         tail->inc();
     }
 
     void dec() const { traverse(dec_visitor()); }
 
     auto tail_size() const { return size - tail_offset(); }
 
     auto tail_offset() const
     {
         auto r = root->relaxed();
         assert(r == nullptr || r->d.count);
         return r ? r->d.sizes[r->d.count - 1]
                  : size ? (size - 1) & ~mask<BL>
                         /* otherwise */ : 0;
     }
 
     template <typename Visitor, typename... Args>
     void traverse(Visitor v, Args&&... args) const
     {
         auto tail_off  = tail_offset();
         auto tail_size = size - tail_off;
 
         if (tail_off)
             visit_maybe_relaxed_sub(root, shift, tail_off, v, args...);
         else
             make_empty_regular_pos(root).visit(v, args...);
 
         if (tail_size)
             make_leaf_sub_pos(tail, tail_size).visit(v, args...);
         else
             make_empty_leaf_pos(tail).visit(v, args...);
     }
 
     template <typename Visitor, typename... Args>
     void traverse(Visitor v, size_t first, size_t last, Args&&... args) const
     {
         auto tail_off  = tail_offset();
         auto tail_size = size - tail_off;
 
         if (first < tail_off)
             visit_maybe_relaxed_sub(root,
                                     shift,
                                     tail_off,
                                     v,
                                     first,
                                     last < tail_off ? last : tail_off,
                                     args...);
         if (last > tail_off)
             make_leaf_sub_pos(tail, tail_size)
                 .visit(v,
                        first > tail_off ? first - tail_off : 0,
                        last - tail_off,
                        args...);
     }
 
     template <typename Visitor, typename... Args>
     bool traverse_p(Visitor v, Args&&... args) const
     {
         auto tail_off  = tail_offset();
         auto tail_size = size - tail_off;
         return (tail_off
                     ? visit_maybe_relaxed_sub(root, shift, tail_off, v, args...)
                     : make_empty_regular_pos(root).visit(v, args...)) &&
                (tail_size ? make_leaf_sub_pos(tail, tail_size).visit(v, args...)
                           : make_empty_leaf_pos(tail).visit(v, args...));
     }
 
     template <typename Visitor, typename... Args>
     bool traverse_p(Visitor v, size_t first, size_t last, Args&&... args) const
     {
         auto tail_off  = tail_offset();
         auto tail_size = size - tail_off;
         return (first < tail_off
                     ? visit_maybe_relaxed_sub(root,
                                               shift,
                                               tail_off,
                                               v,
                                               first,
                                               last < tail_off ? last : tail_off,
                                               args...)
                     : true) &&
                (last > tail_off
                     ? make_leaf_sub_pos(tail, tail_size)
                           .visit(v,
                                  first > tail_off ? first - tail_off : 0,
                                  last - tail_off,
                                  args...)
                     : true);
     }
 
     template <typename Visitor>
     decltype(auto) descend(Visitor v, size_t idx) const
     {
         auto tail_off = tail_offset();
         return idx >= tail_off
                    ? make_leaf_descent_pos(tail).visit(v, idx - tail_off)
                    : visit_maybe_relaxed_descent(root, shift, v, idx);
     }
 
     template <typename Fn>
     void for_each_chunk(Fn&& fn) const
     {
         traverse(for_each_chunk_visitor{}, std::forward<Fn>(fn));
     }
 
     template <typename Fn>
     void for_each_chunk(size_t first, size_t last, Fn&& fn) const
     {
         traverse(for_each_chunk_i_visitor{}, first, last, std::forward<Fn>(fn));
     }
 
     template <typename Fn>
     bool for_each_chunk_p(Fn&& fn) const
     {
         return traverse_p(for_each_chunk_p_visitor{}, std::forward<Fn>(fn));
     }
 
     template <typename Fn>
     bool for_each_chunk_p(size_t first, size_t last, Fn&& fn) const
     {
         return traverse_p(
             for_each_chunk_p_i_visitor{}, first, last, std::forward<Fn>(fn));
     }
 
     bool equals(const rrbtree& other) const
     {
         using iter_t = rrbtree_iterator<T, MemoryPolicy, B, BL>;
         if (size != other.size)
             return false;
         if (size == 0)
             return true;
         auto tail_off       = tail_offset();
         auto tail_off_other = other.tail_offset();
         // compare trees
         if (tail_off > 0 && tail_off_other > 0) {
             // other.shift != shift is a theoretical possibility for
             // relaxed trees that sadly we haven't managed to exercise
             // in tests yet...
             if (other.shift >= shift) {
                 if (!visit_maybe_relaxed_sub(other.root,
                                              other.shift,
                                              tail_off_other,
                                              equals_visitor::rrb{},
                                              iter_t{other},
                                              root,
                                              shift,
                                              tail_off))
                     return false;
             } else {
                 if (!visit_maybe_relaxed_sub(root,
                                              shift,
                                              tail_off,
                                              equals_visitor::rrb{},
                                              iter_t{*this},
                                              other.root,
                                              other.shift,
                                              tail_off_other))
                     return false;
             }
         }
         return tail_off == tail_off_other
                    ? make_leaf_sub_pos(tail, tail_size())
                          .visit(equals_visitor{}, other.tail)
                    : tail_off > tail_off_other
                          ? std::equal(tail->leaf(),
                                       tail->leaf() + (size - tail_off),
                                       other.tail->leaf() +
                                           (tail_off - tail_off_other))
                          /* otherwise */
                          : std::equal(tail->leaf(),
                                       tail->leaf() + (size - tail_off),
                                       iter_t{other} + tail_off);
     }
 
     std::tuple<shift_t, node_t*> push_tail(node_t* root,
                                            shift_t shift,
                                            size_t size,
                                            node_t* tail,
                                            count_t tail_size) const
     {
         if (auto r = root->relaxed()) {
             auto new_root =
                 make_relaxed_pos(root, shift, r)
                     .visit(push_tail_visitor<node_t>{}, tail, tail_size);
             if (new_root)
                 return std::make_tuple(shift, new_root);
             else {
                 auto new_root = node_t::make_inner_r_n(2);
                 try {
                     auto new_path        = node_t::make_path(shift, tail);
                     new_root->inner()[0] = root->inc();
                     new_root->inner()[1] = new_path;
                     new_root->relaxed()->d.sizes[0] = size;
                     new_root->relaxed()->d.sizes[1] = size + tail_size;
                     new_root->relaxed()->d.count    = 2u;
                 } catch (...) {
                     node_t::delete_inner_r(new_root, 2);
                     throw;
                 }
                 return std::make_tuple(shift + B, new_root);
             }
         } else if (size == size_t{branches<B>} << shift) {
             auto new_root = node_t::make_inner_n(2);
             try {
                 auto new_path        = node_t::make_path(shift, tail);
                 new_root->inner()[0] = root->inc();
                 new_root->inner()[1] = new_path;
             } catch (...) {
                 node_t::delete_inner(new_root, 2);
                 throw;
             }
             return std::make_tuple(shift + B, new_root);
         } else if (size) {
             auto new_root = make_regular_sub_pos(root, shift, size)
                                 .visit(push_tail_visitor<node_t>{}, tail);
             return std::make_tuple(shift, new_root);
         } else {
             return std::make_tuple(shift, node_t::make_path(shift, tail));
         }
     }
 
     void
     push_tail_mut(edit_t e, size_t tail_off, node_t* tail, count_t tail_size)
     {
         if (auto r = root->relaxed()) {
             auto new_root =
                 make_relaxed_pos(root, shift, r)
                     .visit(push_tail_mut_visitor<node_t>{}, e, tail, tail_size);
             if (new_root) {
                 root = new_root;
             } else {
                 auto new_root = node_t::make_inner_r_e(e);
                 try {
                     auto new_path        = node_t::make_path_e(e, shift, tail);
                     new_root->inner()[0] = root;
                     new_root->inner()[1] = new_path;
                     new_root->relaxed()->d.sizes[0] = tail_off;
                     new_root->relaxed()->d.sizes[1] = tail_off + tail_size;
                     new_root->relaxed()->d.count    = 2u;
                     root                            = new_root;
                     shift += B;
                 } catch (...) {
                     node_t::delete_inner_r_e(new_root);
                     throw;
                 }
             }
         } else if (tail_off == size_t{branches<B>} << shift) {
             auto new_root = node_t::make_inner_e(e);
             try {
                 auto new_path        = node_t::make_path_e(e, shift, tail);
                 new_root->inner()[0] = root;
                 new_root->inner()[1] = new_path;
                 root                 = new_root;
                 shift += B;
             } catch (...) {
                 node_t::delete_inner_e(new_root);
                 throw;
             }
         } else if (tail_off) {
             auto new_root =
                 make_regular_sub_pos(root, shift, tail_off)
                     .visit(push_tail_mut_visitor<node_t>{}, e, tail);
             root = new_root;
         } else {
             auto new_root = node_t::make_path_e(e, shift, tail);
             dec_empty_regular(root);
             root = new_root;
         }
     }
 
     void ensure_mutable_tail(edit_t e, count_t n)
     {
         if (!tail->can_mutate(e)) {
             auto new_tail = node_t::copy_leaf_e(e, tail, n);
             dec_leaf(tail, n);
             tail = new_tail;
         }
     }
 
     void push_back_mut(edit_t e, T value)
     {
         auto ts = tail_size();
         if (ts < branches<BL>) {
             ensure_mutable_tail(e, ts);
             new (&tail->leaf()[ts]) T{std::move(value)};
         } else {
             using std::get;
             auto new_tail = node_t::make_leaf_e(e, std::move(value));
             auto tail_off = tail_offset();
             try {
                 push_tail_mut(e, tail_off, tail, ts);
                 tail = new_tail;
             } catch (...) {
                 node_t::delete_leaf(new_tail, 1u);
                 throw;
             }
         }
         ++size;
     }
 
     rrbtree push_back(T value) const
     {
         auto ts = tail_size();
         if (ts < branches<BL>) {
             auto new_tail =
                 node_t::copy_leaf_emplace(tail, ts, std::move(value));
             return {size + 1, shift, root->inc(), new_tail};
         } else {
             using std::get;
             auto new_tail = node_t::make_leaf_n(1u, std::move(value));
             auto tail_off = tail_offset();
             try {
                 auto new_root =
                     push_tail(root, shift, tail_off, tail, size - tail_off);
                 tail->inc();
                 return {size + 1, get<0>(new_root), get<1>(new_root), new_tail};
             } catch (...) {
                 node_t::delete_leaf(new_tail, 1u);
                 throw;
             }
         }
     }
 
     std::tuple<const T*, size_t, size_t> region_for(size_t idx) const
     {
         using std::get;
         auto tail_off = tail_offset();
         if (idx >= tail_off) {
             return std::make_tuple(tail->leaf(), tail_off, size);
         } else {
             auto subs = visit_maybe_relaxed_sub(
                 root, shift, tail_off, region_for_visitor<T>(), idx);
             auto first = idx - get<1>(subs);
             auto end   = first + get<2>(subs);
             return std::make_tuple(get<0>(subs), first, end);
         }
     }
 
     T& get_mut(edit_t e, size_t idx)
     {
         auto tail_off = tail_offset();
         if (idx >= tail_off) {
             ensure_mutable_tail(e, size - tail_off);
             return tail->leaf()[(idx - tail_off) & mask<BL>];
         } else {
             return visit_maybe_relaxed_sub(root,
                                            shift,
                                            tail_off,
                                            get_mut_visitor<node_t>{},
                                            idx,
                                            e,
                                            &root);
         }
     }
 
     const T& get(size_t index) const
     {
         return descend(get_visitor<T>(), index);
     }
 
     const T& get_check(size_t index) const
     {
         if (index >= size)
             throw std::out_of_range{"out of range"};
         return descend(get_visitor<T>(), index);
     }
 
     const T& front() const { return get(0); }
 
     const T& back() const { return get(size - 1); }
 
     template <typename FnT>
     void update_mut(edit_t e, size_t idx, FnT&& fn)
     {
         auto& elem = get_mut(e, idx);
         elem       = std::forward<FnT>(fn)(std::move(elem));
     }
 
     template <typename FnT>
     rrbtree update(size_t idx, FnT&& fn) const
     {
         auto tail_off = tail_offset();
         if (idx >= tail_off) {
             auto tail_size = size - tail_off;
             auto new_tail =
                 make_leaf_sub_pos(tail, tail_size)
                     .visit(update_visitor<node_t>{}, idx - tail_off, fn);
             return {size, shift, root->inc(), new_tail};
         } else {
             auto new_root = visit_maybe_relaxed_sub(
                 root, shift, tail_off, update_visitor<node_t>{}, idx, fn);
             return {size, shift, new_root, tail->inc()};
         }
     }
 
     void assoc_mut(edit_t e, size_t idx, T value)
     {
         update_mut(e, idx, [&](auto&&) { return std::move(value); });
     }
 
     rrbtree assoc(size_t idx, T value) const
     {
         return update(idx, [&](auto&&) { return std::move(value); });
     }
 
     void take_mut(edit_t e, size_t new_size)
     {
         auto tail_off = tail_offset();
         if (new_size == 0) {
             *this = empty();
         } else if (new_size >= size) {
             return;
         } else if (new_size > tail_off) {
             auto ts    = size - tail_off;
             auto newts = new_size - tail_off;
             if (tail->can_mutate(e)) {
                 destroy_n(tail->leaf() + newts, ts - newts);
             } else {
                 auto new_tail = node_t::copy_leaf_e(e, tail, newts);
                 dec_leaf(tail, ts);
                 tail = new_tail;
             }
             size = new_size;
             return;
         } else {
             using std::get;
             auto l = new_size - 1;
             auto v = slice_right_mut_visitor<node_t>();
             auto r = visit_maybe_relaxed_sub(root, shift, tail_off, v, l, e);
             auto new_shift = get<0>(r);
             auto new_root  = get<1>(r);
             auto new_tail  = get<3>(r);
             if (new_root) {
                 root  = new_root;
                 shift = new_shift;
             } else {
                 root  = empty().root->inc();
                 shift = BL;
             }
             dec_leaf(tail, size - tail_off);
             size = new_size;
             tail = new_tail;
             return;
         }
     }
 
     rrbtree take(size_t new_size) const
     {
         auto tail_off = tail_offset();
         if (new_size == 0) {
             return empty();
         } else if (new_size >= size) {
             return *this;
         } else if (new_size > tail_off) {
             auto new_tail = node_t::copy_leaf(tail, new_size - tail_off);
             return {new_size, shift, root->inc(), new_tail};
         } else {
             using std::get;
             auto l = new_size - 1;
             auto v = slice_right_visitor<node_t>();
             auto r = visit_maybe_relaxed_sub(root, shift, tail_off, v, l);
             auto new_shift = get<0>(r);
             auto new_root  = get<1>(r);
             auto new_tail  = get<3>(r);
             if (new_root) {
                 IMMER_ASSERT_TAGGED(new_root->compute_shift() == get<0>(r));
                 assert(new_root->check(new_shift, new_size - get<2>(r)));
                 return {new_size, new_shift, new_root, new_tail};
             } else {
                 return {new_size, BL, empty().root->inc(), new_tail};
             }
         }
     }
 
     void drop_mut(edit_t e, size_t elems)
     {
         using std::get;
         auto tail_off = tail_offset();
         if (elems == 0) {
             return;
         } else if (elems >= size) {
             *this = empty();
         } else if (elems == tail_off) {
             dec_inner(root, shift, tail_off);
             shift = BL;
             root  = empty().root->inc();
             size -= elems;
             return;
         } else if (elems > tail_off) {
             auto v = slice_left_mut_visitor<node_t>();
             tail   = get<1>(make_leaf_sub_pos(tail, size - tail_off)
                               .visit(v, elems - tail_off, e));
             if (root != empty().root) {
                 dec_inner(root, shift, tail_off);
                 shift = BL;
                 root  = empty().root->inc();
             }
             size -= elems;
             return;
         } else {
             auto v = slice_left_mut_visitor<node_t>();
             auto r =
                 visit_maybe_relaxed_sub(root, shift, tail_off, v, elems, e);
             shift = get<0>(r);
             root  = get<1>(r);
             size -= elems;
             return;
         }
     }
 
     rrbtree drop(size_t elems) const
     {
         if (elems == 0) {
             return *this;
         } else if (elems >= size) {
             return empty();
         } else if (elems == tail_offset()) {
             return {size - elems, BL, empty().root->inc(), tail->inc()};
         } else if (elems > tail_offset()) {
             auto tail_off = tail_offset();
             auto new_tail =
                 node_t::copy_leaf(tail, elems - tail_off, size - tail_off);
             return {size - elems, BL, empty().root->inc(), new_tail};
         } else {
             using std::get;
             auto v = slice_left_visitor<node_t>();
             auto r =
                 visit_maybe_relaxed_sub(root, shift, tail_offset(), v, elems);
             auto new_root  = get<1>(r);
             auto new_shift = get<0>(r);
             return {size - elems, new_shift, new_root, tail->inc()};
         }
         return *this;
     }
 
     rrbtree concat(const rrbtree& r) const
     {
-        assert(r.size < (std::numeric_limits<size_t>::max() - size));
+        assert(r.size + size <= max_size());
         using std::get;
         if (size == 0)
             return r;
         else if (r.size == 0)
             return *this;
         else if (r.tail_offset() == 0) {
             // just concat the tail, similar to push_back
             auto tail_offst = tail_offset();
             auto tail_size  = size - tail_offst;
             if (tail_size == branches<BL>) {
                 auto new_root =
                     push_tail(root, shift, tail_offst, tail, tail_size);
                 tail->inc();
                 return {size + r.size,
                         get<0>(new_root),
                         get<1>(new_root),
                         r.tail->inc()};
             } else if (tail_size + r.size <= branches<BL>) {
                 auto new_tail =
                     node_t::copy_leaf(tail, tail_size, r.tail, r.size);
                 return {size + r.size, shift, root->inc(), new_tail};
             } else {
                 auto remaining = branches<BL> - tail_size;
                 auto add_tail =
                     node_t::copy_leaf(tail, tail_size, r.tail, remaining);
                 try {
                     auto new_tail =
                         node_t::copy_leaf(r.tail, remaining, r.size);
                     try {
                         auto new_root = push_tail(
                             root, shift, tail_offst, add_tail, branches<BL>);
                         return {size + r.size,
                                 get<0>(new_root),
                                 get<1>(new_root),
                                 new_tail};
                     } catch (...) {
                         node_t::delete_leaf(new_tail, r.size - remaining);
                         throw;
                     }
                 } catch (...) {
                     node_t::delete_leaf(add_tail, branches<BL>);
                     throw;
                 }
             }
         } else if (tail_offset() == 0) {
             auto tail_offst = tail_offset();
             auto tail_size  = size - tail_offst;
             auto concated =
                 concat_trees(tail, tail_size, r.root, r.shift, r.tail_offset());
             auto new_shift = concated.shift();
             auto new_root  = concated.node();
             IMMER_ASSERT_TAGGED(new_shift == new_root->compute_shift());
             assert(new_root->check(new_shift, size + r.tail_offset()));
             return {size + r.size, new_shift, new_root, r.tail->inc()};
         } else {
             auto tail_offst = tail_offset();
             auto tail_size  = size - tail_offst;
             auto concated   = concat_trees(root,
                                          shift,
                                          tail_offst,
                                          tail,
                                          tail_size,
                                          r.root,
                                          r.shift,
                                          r.tail_offset());
             auto new_shift  = concated.shift();
             auto new_root   = concated.node();
             IMMER_ASSERT_TAGGED(new_shift == new_root->compute_shift());
             assert(new_root->check(new_shift, size + r.tail_offset()));
             return {size + r.size, new_shift, new_root, r.tail->inc()};
         }
     }
 
     constexpr static bool supports_transient_concat =
         !std::is_empty<edit_t>::value;
 
     friend void concat_mut_l(rrbtree& l, edit_t el, const rrbtree& r)
     {
         assert(&l != &r);
         assert(r.size < (std::numeric_limits<size_t>::max() - l.size));
         using std::get;
         if (l.size == 0)
             l = r;
         else if (r.size == 0)
             return;
         else if (r.tail_offset() == 0) {
             // just concat the tail, similar to push_back
             auto tail_offst = l.tail_offset();
             auto tail_size  = l.size - tail_offst;
             if (tail_size == branches<BL>) {
                 l.push_tail_mut(el, tail_offst, l.tail, tail_size);
                 l.tail = r.tail->inc();
                 l.size += r.size;
                 return;
             } else if (tail_size + r.size <= branches<BL>) {
                 l.ensure_mutable_tail(el, tail_size);
                 std::uninitialized_copy(r.tail->leaf(),
                                         r.tail->leaf() + r.size,
                                         l.tail->leaf() + tail_size);
                 l.size += r.size;
                 return;
             } else {
                 auto remaining = branches<BL> - tail_size;
                 l.ensure_mutable_tail(el, tail_size);
                 std::uninitialized_copy(r.tail->leaf(),
                                         r.tail->leaf() + remaining,
                                         l.tail->leaf() + tail_size);
                 try {
                     auto new_tail =
                         node_t::copy_leaf_e(el, r.tail, remaining, r.size);
                     try {
                         l.push_tail_mut(el, tail_offst, l.tail, branches<BL>);
                         l.tail = new_tail;
                         l.size += r.size;
                         return;
                     } catch (...) {
                         node_t::delete_leaf(new_tail, r.size - remaining);
                         throw;
                     }
                 } catch (...) {
                     destroy_n(r.tail->leaf() + tail_size, remaining);
                     throw;
                 }
             }
         } else if (l.tail_offset() == 0) {
             if (supports_transient_concat) {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated =
                     concat_trees_mut(el,
                                      el,
                                      l.tail,
                                      tail_size,
                                      MemoryPolicy::transience_t::noone,
                                      r.root,
                                      r.shift,
                                      r.tail_offset());
                 IMMER_ASSERT_TAGGED(concated.shift() ==
                                     concated.node()->compute_shift());
                 assert(concated.node()->check(concated.shift(),
                                               l.size + r.tail_offset()));
                 l.size += r.size;
                 l.shift = concated.shift();
                 l.root  = concated.node();
                 l.tail  = r.tail;
+                assert(l.check_tree());
             } else {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees(
                     l.tail, tail_size, r.root, r.shift, r.tail_offset());
                 l = {l.size + r.size,
                      concated.shift(),
                      concated.node(),
                      r.tail->inc()};
+                assert(l.check_tree());
                 return;
             }
         } else {
             if (supports_transient_concat) {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated =
                     concat_trees_mut(el,
                                      el,
                                      l.root,
                                      l.shift,
                                      tail_offst,
                                      l.tail,
                                      tail_size,
                                      MemoryPolicy::transience_t::noone,
                                      r.root,
                                      r.shift,
                                      r.tail_offset());
                 IMMER_ASSERT_TAGGED(concated.shift() ==
                                     concated.node()->compute_shift());
                 assert(concated.node()->check(concated.shift(),
                                               l.size + r.tail_offset()));
                 l.size += r.size;
                 l.shift = concated.shift();
                 l.root  = concated.node();
                 l.tail  = r.tail;
+                assert(l.check_tree());
             } else {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees(l.root,
                                              l.shift,
                                              tail_offst,
                                              l.tail,
                                              tail_size,
                                              r.root,
                                              r.shift,
                                              r.tail_offset());
                 l               = {l.size + r.size,
                      concated.shift(),
                      concated.node(),
                      r.tail->inc()};
             }
         }
     }
 
     friend void concat_mut_r(const rrbtree& l, rrbtree& r, edit_t er)
     {
         assert(&l != &r);
         assert(r.size < (std::numeric_limits<size_t>::max() - l.size));
         using std::get;
         if (r.size == 0)
             r = std::move(l);
         else if (l.size == 0)
             return;
         else if (r.tail_offset() == 0) {
             // just concat the tail, similar to push_back
             auto tail_offst = l.tail_offset();
             auto tail_size  = l.size - tail_offst;
             if (tail_size == branches<BL>) {
                 // this could be improved by making sure that the
                 // newly created nodes as part of the `push_tail()`
                 // are tagged with `er`
                 auto res =
                     l.push_tail(l.root, l.shift, tail_offst, l.tail, tail_size);
                 l.tail->inc(); // note: leak if mutably concatenated
                                // with itself, but this is forbidden
                                // by the interface
                 r = {l.size + r.size, get<0>(res), get<1>(res), r.tail->inc()};
                 return;
             } else if (tail_size + r.size <= branches<BL>) {
                 // doing this in a exception way mutating way is very
                 // tricky while potential performance gains are
                 // minimal (we need to move every element of the right
                 // tail anyways to make space for the left tail)
                 //
                 // we could however improve this by at least moving the
                 // elements of the right tail...
                 auto new_tail =
                     node_t::copy_leaf(l.tail, tail_size, r.tail, r.size);
                 r = {l.size + r.size, l.shift, l.root->inc(), new_tail};
                 return;
             } else {
                 // like the immutable version
                 auto remaining = branches<BL> - tail_size;
                 auto add_tail  = node_t::copy_leaf_e(
                     er, l.tail, tail_size, r.tail, remaining);
                 try {
                     auto new_tail =
                         node_t::copy_leaf_e(er, r.tail, remaining, r.size);
                     try {
                         // this could be improved by making sure that the
                         // newly created nodes as part of the `push_tail()`
                         // are tagged with `er`
                         auto new_root = l.push_tail(l.root,
                                                     l.shift,
                                                     tail_offst,
                                                     add_tail,
                                                     branches<BL>);
                         r             = {l.size + r.size,
                              get<0>(new_root),
                              get<1>(new_root),
                              new_tail};
                         return;
                     } catch (...) {
                         node_t::delete_leaf(new_tail, r.size - remaining);
                         throw;
                     }
                 } catch (...) {
                     node_t::delete_leaf(add_tail, branches<BL>);
                     throw;
                 }
                 return;
             }
         } else if (l.tail_offset() == 0) {
             if (supports_transient_concat) {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated =
                     concat_trees_mut(er,
                                      MemoryPolicy::transience_t::noone,
                                      l.tail,
                                      tail_size,
                                      er,
                                      r.root,
                                      r.shift,
                                      r.tail_offset());
                 IMMER_ASSERT_TAGGED(concated.shift() ==
                                     concated.node()->compute_shift());
                 assert(concated.node()->check(concated.shift(),
                                               l.size + r.tail_offset()));
                 r.size += l.size;
                 r.shift = concated.shift();
                 r.root  = concated.node();
+                assert(r.check_tree());
             } else {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees(
                     l.tail, tail_size, r.root, r.shift, r.tail_offset());
                 r = {l.size + r.size,
                      concated.shift(),
                      concated.node(),
                      r.tail->inc()};
                 return;
             }
         } else {
             if (supports_transient_concat) {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated =
                     concat_trees_mut(er,
                                      MemoryPolicy::transience_t::noone,
                                      l.root,
                                      l.shift,
                                      tail_offst,
                                      l.tail,
                                      tail_size,
                                      er,
                                      r.root,
                                      r.shift,
                                      r.tail_offset());
                 IMMER_ASSERT_TAGGED(concated.shift() ==
                                     concated.node()->compute_shift());
                 assert(concated.node()->check(concated.shift(),
                                               l.size + r.tail_offset()));
                 r.size += l.size;
                 r.shift = concated.shift();
                 r.root  = concated.node();
+                assert(r.check_tree());
                 return;
             } else {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees(l.root,
                                              l.shift,
                                              tail_offst,
                                              l.tail,
                                              tail_size,
                                              r.root,
                                              r.shift,
                                              r.tail_offset());
                 r               = {l.size + r.size,
                      concated.shift(),
                      concated.node(),
                      r.tail->inc()};
                 return;
             }
         }
     }
 
     friend void concat_mut_lr_l(rrbtree& l, edit_t el, rrbtree& r, edit_t er)
     {
         assert(&l != &r);
         assert(r.size < (std::numeric_limits<size_t>::max() - l.size));
         using std::get;
         if (l.size == 0)
             l = r;
         else if (r.size == 0)
             return;
         else if (r.tail_offset() == 0) {
             // just concat the tail, similar to push_back
             auto tail_offst = l.tail_offset();
             auto tail_size  = l.size - tail_offst;
             if (tail_size == branches<BL>) {
                 l.push_tail_mut(el, tail_offst, l.tail, tail_size);
                 l.tail = r.tail->inc();
                 l.size += r.size;
                 return;
             } else if (tail_size + r.size <= branches<BL>) {
                 l.ensure_mutable_tail(el, tail_size);
                 if (r.tail->can_mutate(er))
                     detail::uninitialized_move(r.tail->leaf(),
                                                r.tail->leaf() + r.size,
                                                l.tail->leaf() + tail_size);
                 else
                     std::uninitialized_copy(r.tail->leaf(),
                                             r.tail->leaf() + r.size,
                                             l.tail->leaf() + tail_size);
                 l.size += r.size;
                 return;
             } else {
                 auto remaining = branches<BL> - tail_size;
                 l.ensure_mutable_tail(el, tail_size);
                 if (r.tail->can_mutate(er))
                     detail::uninitialized_move(r.tail->leaf(),
                                                r.tail->leaf() + remaining,
                                                l.tail->leaf() + tail_size);
                 else
                     std::uninitialized_copy(r.tail->leaf(),
                                             r.tail->leaf() + remaining,
                                             l.tail->leaf() + tail_size);
                 try {
                     auto new_tail =
                         node_t::copy_leaf_e(el, r.tail, remaining, r.size);
                     try {
                         l.push_tail_mut(el, tail_offst, l.tail, branches<BL>);
                         l.tail = new_tail;
                         l.size += r.size;
                         return;
                     } catch (...) {
                         node_t::delete_leaf(new_tail, r.size - remaining);
                         throw;
                     }
                 } catch (...) {
                     destroy_n(r.tail->leaf() + tail_size, remaining);
                     throw;
                 }
             }
         } else if (l.tail_offset() == 0) {
             if (supports_transient_concat) {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees_mut(el,
                                                  el,
                                                  l.tail,
                                                  tail_size,
                                                  er,
                                                  r.root,
                                                  r.shift,
                                                  r.tail_offset());
                 IMMER_ASSERT_TAGGED(concated.shift() ==
                                     concated.node()->compute_shift());
                 assert(concated.node()->check(concated.shift(),
                                               l.size + r.tail_offset()));
                 l.size += r.size;
                 l.shift = concated.shift();
                 l.root  = concated.node();
                 l.tail  = r.tail;
+                assert(l.check_tree());
                 r.hard_reset();
             } else {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees(
                     l.tail, tail_size, r.root, r.shift, r.tail_offset());
                 l = {l.size + r.size,
                      concated.shift(),
                      concated.node(),
                      r.tail->inc()};
                 return;
             }
         } else {
             if (supports_transient_concat) {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees_mut(el,
                                                  el,
                                                  l.root,
                                                  l.shift,
                                                  tail_offst,
                                                  l.tail,
                                                  tail_size,
                                                  er,
                                                  r.root,
                                                  r.shift,
                                                  r.tail_offset());
                 IMMER_ASSERT_TAGGED(concated.shift() ==
                                     concated.node()->compute_shift());
                 assert(concated.node()->check(concated.shift(),
                                               l.size + r.tail_offset()));
                 l.size += r.size;
                 l.shift = concated.shift();
                 l.root  = concated.node();
                 l.tail  = r.tail;
+                assert(l.check_tree());
                 r.hard_reset();
             } else {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees(l.root,
                                              l.shift,
                                              tail_offst,
                                              l.tail,
                                              tail_size,
                                              r.root,
                                              r.shift,
                                              r.tail_offset());
                 l               = {l.size + r.size,
                      concated.shift(),
                      concated.node(),
                      r.tail->inc()};
             }
         }
     }
 
     friend void concat_mut_lr_r(rrbtree& l, edit_t el, rrbtree& r, edit_t er)
     {
         assert(&l != &r);
         assert(r.size < (std::numeric_limits<size_t>::max() - l.size));
         using std::get;
         if (r.size == 0)
             r = l;
         else if (l.size == 0)
             return;
         else if (r.tail_offset() == 0) {
             // just concat the tail, similar to push_back
             auto tail_offst = l.tail_offset();
             auto tail_size  = l.size - tail_offst;
             if (tail_size == branches<BL>) {
                 // this could be improved by making sure that the
                 // newly created nodes as part of the `push_tail()`
                 // are tagged with `er`
                 auto res =
                     l.push_tail(l.root, l.shift, tail_offst, l.tail, tail_size);
                 r = {l.size + r.size, get<0>(res), get<1>(res), r.tail->inc()};
                 return;
             } else if (tail_size + r.size <= branches<BL>) {
                 // doing this in a exception way mutating way is very
                 // tricky while potential performance gains are
                 // minimal (we need to move every element of the right
                 // tail anyways to make space for the left tail)
                 //
                 // we could however improve this by at least moving the
                 // elements of the mutable tails...
                 auto new_tail =
                     node_t::copy_leaf(l.tail, tail_size, r.tail, r.size);
                 r = {l.size + r.size, l.shift, l.root->inc(), new_tail};
                 return;
             } else {
                 // like the immutable version.
                 // we could improve this also by moving elements
                 // instead of just copying them
                 auto remaining = branches<BL> - tail_size;
                 auto add_tail  = node_t::copy_leaf_e(
                     er, l.tail, tail_size, r.tail, remaining);
                 try {
                     auto new_tail =
                         node_t::copy_leaf_e(er, r.tail, remaining, r.size);
                     try {
                         // this could be improved by making sure that the
                         // newly created nodes as part of the `push_tail()`
                         // are tagged with `er`
                         auto new_root = l.push_tail(l.root,
                                                     l.shift,
                                                     tail_offst,
                                                     add_tail,
                                                     branches<BL>);
                         r             = {l.size + r.size,
                              get<0>(new_root),
                              get<1>(new_root),
                              new_tail};
                         return;
                     } catch (...) {
                         node_t::delete_leaf(new_tail, r.size - remaining);
                         throw;
                     }
                 } catch (...) {
                     node_t::delete_leaf(add_tail, branches<BL>);
                     throw;
                 }
                 return;
             }
         } else if (l.tail_offset() == 0) {
             if (supports_transient_concat) {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees_mut(er,
                                                  el,
                                                  l.tail,
                                                  tail_size,
                                                  er,
                                                  r.root,
                                                  r.shift,
                                                  r.tail_offset());
                 IMMER_ASSERT_TAGGED(concated.shift() ==
                                     concated.node()->compute_shift());
                 assert(concated.node()->check(concated.shift(),
                                               l.size + r.tail_offset()));
                 r.size += l.size;
                 r.shift = concated.shift();
                 r.root  = concated.node();
+                assert(r.check_tree());
                 l.hard_reset();
             } else {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees(
                     l.tail, tail_size, r.root, r.shift, r.tail_offset());
                 r = {l.size + r.size,
                      concated.shift(),
                      concated.node(),
                      r.tail->inc()};
                 return;
             }
         } else {
             if (supports_transient_concat) {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees_mut(er,
                                                  el,
                                                  l.root,
                                                  l.shift,
                                                  tail_offst,
                                                  l.tail,
                                                  tail_size,
                                                  er,
                                                  r.root,
                                                  r.shift,
                                                  r.tail_offset());
                 IMMER_ASSERT_TAGGED(concated.shift() ==
                                     concated.node()->compute_shift());
                 assert(concated.node()->check(concated.shift(),
                                               l.size + r.tail_offset()));
                 r.size += l.size;
                 r.shift = concated.shift();
                 r.root  = concated.node();
+                assert(r.check_tree());
                 l.hard_reset();
             } else {
                 auto tail_offst = l.tail_offset();
                 auto tail_size  = l.size - tail_offst;
                 auto concated   = concat_trees(l.root,
                                              l.shift,
                                              tail_offst,
                                              l.tail,
                                              tail_size,
                                              r.root,
                                              r.shift,
                                              r.tail_offset());
                 r               = {l.size + r.size,
                      concated.shift(),
                      concated.node(),
                      r.tail->inc()};
             }
         }
     }
 
     void hard_reset()
     {
         assert(supports_transient_concat);
         auto&& empty_ = empty();
         size          = empty_.size;
         shift         = empty_.shift;
         root          = empty_.root;
         tail          = empty_.tail;
     }
 
     bool check_tree() const
     {
         assert(shift <= sizeof(size_t) * 8 - BL);
         assert(shift >= BL);
         assert(tail_offset() <= size);
         assert(tail_size() <= branches<BL>);
 #if IMMER_DEBUG_DEEP_CHECK
         assert(check_root());
         assert(check_tail());
 #endif
         return true;
     }
 
     bool check_tail() const
     {
 #if IMMER_DEBUG_DEEP_CHECK
         if (tail_size() > 0)
             assert(tail->check(endshift<B, BL>, tail_size()));
 #endif
         return true;
     }
 
     bool check_root() const
     {
 #if IMMER_DEBUG_DEEP_CHECK
         if (tail_offset() > 0)
             assert(root->check(shift, tail_offset()));
         else {
             IMMER_ASSERT_TAGGED(root->kind() == node_t::kind_t::inner);
             assert(shift == BL);
         }
 #endif
         return true;
     }
 
 #if IMMER_DEBUG_PRINT
     void debug_print(std::ostream& out) const
     {
         out << "--" << std::endl
             << "{" << std::endl
             << "  size  = " << size << std::endl
             << "  shift = " << shift << std::endl
             << "  root  = " << std::endl;
         debug_print_node(out, root, shift, tail_offset());
         out << "  tail  = " << std::endl;
         debug_print_node(out, tail, endshift<B, BL>, tail_size());
         out << "}" << std::endl;
     }
 
     void debug_print_indent(std::ostream& out, unsigned indent) const
     {
         while (indent-- > 0)
             out << ' ';
     }
 
     void debug_print_node(std::ostream& out,
                           node_t* node,
                           shift_t shift,
                           size_t size,
                           unsigned indent = 8) const
     {
         const auto indent_step = 4;
 
         if (shift == endshift<B, BL>) {
             debug_print_indent(out, indent);
             out << "- {" << size << "} "
                 << pretty_print_array(node->leaf(), size) << std::endl;
         } else if (auto r = node->relaxed()) {
             auto count = r->d.count;
             debug_print_indent(out, indent);
             out << "# {" << size << "} "
                 << pretty_print_array(r->d.sizes, r->d.count) << std::endl;
             auto last_size = size_t{};
             for (auto i = count_t{}; i < count; ++i) {
                 debug_print_node(out,
                                  node->inner()[i],
                                  shift - B,
                                  r->d.sizes[i] - last_size,
                                  indent + indent_step);
                 last_size = r->d.sizes[i];
             }
         } else {
             debug_print_indent(out, indent);
             out << "+ {" << size << "}" << std::endl;
             auto count =
                 (size >> shift) + (size - ((size >> shift) << shift) > 0);
             if (count) {
                 for (auto i = count_t{}; i < count - 1; ++i)
                     debug_print_node(out,
                                      node->inner()[i],
                                      shift - B,
                                      1 << shift,
                                      indent + indent_step);
                 debug_print_node(out,
                                  node->inner()[count - 1],
                                  shift - B,
                                  size - ((count - 1) << shift),
                                  indent + indent_step);
             }
         }
     }
 #endif // IMMER_DEBUG_PRINT
 };
 
 } // namespace rbts
 } // namespace detail
 } // namespace immer
diff --git a/immer/detail/util.hpp b/immer/detail/util.hpp
index fb2a520..0c454ab 100644
--- a/immer/detail/util.hpp
+++ b/immer/detail/util.hpp
@@ -123,6 +123,12 @@ inline constexpr auto log2(T x)
     return log2_aux(x);
 }
 
+template <typename T>
+constexpr T ipow(T num, unsigned int pow)
+{
+    return pow == 0 ? 1 : num * ipow(num, pow - 1);
+}
+
 template <bool b, typename F>
 auto static_if(F&& f) -> std::enable_if_t<b>
 {
diff --git a/immer/flex_vector.hpp b/immer/flex_vector.hpp
index d03c3f7..0845e3c 100644
--- a/immer/flex_vector.hpp
+++ b/immer/flex_vector.hpp
@@ -69,446 +69,452 @@ class flex_vector
 public:
     static constexpr auto bits      = B;
     static constexpr auto bits_leaf = BL;
     using memory_policy             = MemoryPolicy;
 
     using value_type      = T;
     using reference       = const T&;
     using size_type       = detail::rbts::size_t;
     using difference_type = std::ptrdiff_t;
     using const_reference = const T&;
 
     using iterator = detail::rbts::rrbtree_iterator<T, MemoryPolicy, B, BL>;
     using const_iterator   = iterator;
     using reverse_iterator = std::reverse_iterator<iterator>;
 
     using transient_type = flex_vector_transient<T, MemoryPolicy, B, BL>;
 
+    /*!
+     * Returns the maximum theoretical size supported by the internal structure
+     * given the current B, BL.
+     */
+    constexpr static size_type max_size() { return impl_t::max_size(); }
+
     /*!
      * Default constructor.  It creates a flex_vector of `size() == 0`.
      * It does not allocate memory and its complexity is @f$ O(1) @f$.
      */
     flex_vector() = default;
 
     /*!
      * Constructs a flex_vector containing the elements in `values`.
      */
     flex_vector(std::initializer_list<T> values)
         : impl_{impl_t::from_initializer_list(values)}
     {}
 
     /*!
      * Constructs a flex_vector containing the elements in the range
      * defined by the input iterator `first` and range sentinel `last`.
      */
     template <typename Iter,
               typename Sent,
               std::enable_if_t<detail::compatible_sentinel_v<Iter, Sent>,
                                bool> = true>
     flex_vector(Iter first, Sent last)
         : impl_{impl_t::from_range(first, last)}
     {}
 
     /*!
      * Constructs a vector containing the element `val` repeated `n`
      * times.
      */
     flex_vector(size_type n, T v = {})
         : impl_{impl_t::from_fill(n, v)}
     {}
 
     /*!
      * Default constructor.  It creates a flex_vector with the same
      * contents as `v`.  It does not allocate memory and is
      * @f$ O(1) @f$.
      */
     flex_vector(vector<T, MemoryPolicy, B, BL> v)
         : impl_{v.impl_.size,
                 v.impl_.shift,
                 v.impl_.root->inc(),
                 v.impl_.tail->inc()}
     {}
 
     /*!
      * Returns an iterator pointing at the first element of the
      * collection. It does not allocate memory and its complexity is
      * @f$ O(1) @f$.
      */
     IMMER_NODISCARD iterator begin() const { return {impl_}; }
 
     /*!
      * Returns an iterator pointing just after the last element of the
      * collection. It does not allocate and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD iterator end() const
     {
         return {impl_, typename iterator::end_t{}};
     }
 
     /*!
      * Returns an iterator that traverses the collection backwards,
      * pointing at the first element of the reversed collection. It
      * does not allocate memory and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD reverse_iterator rbegin() const
     {
         return reverse_iterator{end()};
     }
 
     /*!
      * Returns an iterator that traverses the collection backwards,
      * pointing after the last element of the reversed collection. It
      * does not allocate memory and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD reverse_iterator rend() const
     {
         return reverse_iterator{begin()};
     }
 
     /*!
      * Returns the number of elements in the container.  It does
      * not allocate memory and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD size_type size() const { return impl_.size; }
 
     /*!
      * Returns `true` if there are no elements in the container.  It
      * does not allocate memory and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD bool empty() const { return impl_.size == 0; }
 
     /*!
      * Access the last element.
      */
     IMMER_NODISCARD const T& back() const { return impl_.back(); }
 
     /*!
      * Access the first element.
      */
     IMMER_NODISCARD const T& front() const { return impl_.front(); }
 
     /*!
      * Returns a `const` reference to the element at position `index`.
      * It is undefined when @f$ 0 index \geq size() @f$.  It does not
      * allocate memory and its complexity is *effectively* @f$ O(1)
      * @f$.
      */
     IMMER_NODISCARD reference operator[](size_type index) const
     {
         return impl_.get(index);
     }
 
     /*!
      * Returns a `const` reference to the element at position
      * `index`. It throws an `std::out_of_range` exception when @f$
      * index \geq size() @f$.  It does not allocate memory and its
      * complexity is *effectively* @f$ O(1) @f$.
      */
     reference at(size_type index) const { return impl_.get_check(index); }
 
     /*!
      * Returns whether the vectors are equal.
      */
     IMMER_NODISCARD bool operator==(const flex_vector& other) const
     {
         return impl_.equals(other.impl_);
     }
     IMMER_NODISCARD bool operator!=(const flex_vector& other) const
     {
         return !(*this == other);
     }
 
     /*!
      * Returns a flex_vector with `value` inserted at the end.  It may
      * allocate memory and its complexity is *effectively* @f$ O(1) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/flex-vector/flex-vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: push-back/start
      *      :end-before:  push-back/end
      *
      * @endrst
      */
     IMMER_NODISCARD flex_vector push_back(value_type value) const&
     {
         return impl_.push_back(std::move(value));
     }
 
     IMMER_NODISCARD decltype(auto) push_back(value_type value) &&
     {
         return push_back_move(move_t{}, std::move(value));
     }
 
     /*!
      * Returns a flex_vector with `value` inserted at the frony.  It may
      * allocate memory and its complexity is @f$ O(log(size)) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/flex-vector/flex-vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: push-front/start
      *      :end-before:  push-front/end
      *
      * @endrst
      */
     IMMER_NODISCARD flex_vector push_front(value_type value) const
     {
         return flex_vector{}.push_back(value) + *this;
     }
 
     /*!
      * Returns a flex_vector containing value `value` at position `index`.
      * Undefined for `index >= size()`.
      * It may allocate memory and its complexity is
      * *effectively* @f$ O(1) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/flex-vector/flex-vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: set/start
      *      :end-before:  set/end
      *
      * @endrst
      */
     IMMER_NODISCARD flex_vector set(size_type index, value_type value) const&
     {
         return impl_.assoc(index, std::move(value));
     }
 
     IMMER_NODISCARD decltype(auto) set(size_type index, value_type value) &&
     {
         return set_move(move_t{}, index, std::move(value));
     }
 
     /*!
      * Returns a vector containing the result of the expression
      * `fn((*this)[idx])` at position `idx`.
      * Undefined for `index >= size()`.
      * It may allocate memory and its complexity is
      * *effectively* @f$ O(1) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/flex-vector/flex-vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: update/start
      *      :end-before:  update/end
      *
      * @endrst
 
      */
     template <typename FnT>
     IMMER_NODISCARD flex_vector update(size_type index, FnT&& fn) const&
     {
         return impl_.update(index, std::forward<FnT>(fn));
     }
 
     template <typename FnT>
     IMMER_NODISCARD decltype(auto) update(size_type index, FnT&& fn) &&
     {
         return update_move(move_t{}, index, std::forward<FnT>(fn));
     }
 
     /*!
      * Returns a vector containing only the first `min(elems, size())`
      * elements. It may allocate memory and its complexity is
      * *effectively* @f$ O(1) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/flex-vector/flex-vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: take/start
      *      :end-before:  take/end
      *
      * @endrst
      */
     IMMER_NODISCARD flex_vector take(size_type elems) const&
     {
         return impl_.take(elems);
     }
 
     IMMER_NODISCARD decltype(auto) take(size_type elems) &&
     {
         return take_move(move_t{}, elems);
     }
 
     /*!
      * Returns a vector without the first `min(elems, size())`
      * elements. It may allocate memory and its complexity is
      * *effectively* @f$ O(1) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/flex-vector/flex-vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: drop/start
      *      :end-before:  drop/end
      *
      * @endrst
      */
     IMMER_NODISCARD flex_vector drop(size_type elems) const&
     {
         return impl_.drop(elems);
     }
 
     IMMER_NODISCARD decltype(auto) drop(size_type elems) &&
     {
         return drop_move(move_t{}, elems);
     }
 
     /*!
      * Concatenation operator. Returns a flex_vector with the contents
      * of `l` followed by those of `r`.  It may allocate memory
      * and its complexity is @f$ O(log(max(size_r, size_l))) @f$
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/flex-vector/flex-vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: concat/start
      *      :end-before:  concat/end
      *
      * @endrst
      */
     IMMER_NODISCARD friend flex_vector operator+(const flex_vector& l,
                                                  const flex_vector& r)
     {
         return l.impl_.concat(r.impl_);
     }
 
     IMMER_NODISCARD friend decltype(auto) operator+(flex_vector&& l,
                                                     const flex_vector& r)
     {
         return concat_move(move_t{}, std::move(l), r);
     }
 
     IMMER_NODISCARD friend decltype(auto) operator+(const flex_vector& l,
                                                     flex_vector&& r)
     {
         return concat_move(move_t{}, l, std::move(r));
     }
 
     IMMER_NODISCARD friend decltype(auto) operator+(flex_vector&& l,
                                                     flex_vector&& r)
     {
         return concat_move(move_t{}, std::move(l), std::move(r));
     }
 
     /*!
      * Returns a flex_vector with the `value` inserted at index
      * `pos`. It may allocate memory and its complexity is @f$
      * O(log(size)) @f$
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/flex-vector/flex-vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: insert/start
      *      :end-before:  insert/end
      *
      * @endrst
      */
     IMMER_NODISCARD flex_vector insert(size_type pos, T value) const&
     {
         return take(pos).push_back(std::move(value)) + drop(pos);
     }
     IMMER_NODISCARD decltype(auto) insert(size_type pos, T value) &&
     {
         using std::move;
         auto rs = drop(pos);
         return std::move(*this).take(pos).push_back(std::move(value)) +
                std::move(rs);
     }
 
     IMMER_NODISCARD flex_vector insert(size_type pos, flex_vector value) const&
     {
         return take(pos) + std::move(value) + drop(pos);
     }
     IMMER_NODISCARD decltype(auto) insert(size_type pos, flex_vector value) &&
     {
         using std::move;
         auto rs = drop(pos);
         return std::move(*this).take(pos) + std::move(value) + std::move(rs);
     }
 
     /*!
      * Returns a flex_vector without the element at index `pos`. It
      * may allocate memory and its complexity is @f$ O(log(size)) @f$
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/flex-vector/flex-vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: erase/start
      *      :end-before:  erase/end
      *
      * @endrst
      */
     IMMER_NODISCARD flex_vector erase(size_type pos) const&
     {
         return take(pos) + drop(pos + 1);
     }
     IMMER_NODISCARD decltype(auto) erase(size_type pos) &&
     {
         auto rs = drop(pos + 1);
         return std::move(*this).take(pos) + std::move(rs);
     }
 
     IMMER_NODISCARD flex_vector erase(size_type pos, size_type lpos) const&
     {
         return lpos > pos ? take(pos) + drop(lpos) : *this;
     }
     IMMER_NODISCARD decltype(auto) erase(size_type pos, size_type lpos) &&
     {
         if (lpos > pos) {
             auto rs = drop(lpos);
             return std::move(*this).take(pos) + std::move(rs);
         } else {
             return std::move(*this);
         }
     }
 
     /*!
      * Returns an @a transient form of this container, an
      * `immer::flex_vector_transient`.
      */
     IMMER_NODISCARD transient_type transient() const&
     {
         return transient_type{impl_};
     }
     IMMER_NODISCARD transient_type transient() &&
     {
         return transient_type{std::move(impl_)};
     }
 
     // Semi-private
     const impl_t& impl() const { return impl_; }
 
 #if IMMER_DEBUG_PRINT
     void debug_print(std::ostream& out = std::cerr) const
     {
         impl_.debug_print(out);
     }
 #endif
diff --git a/immer/vector.hpp b/immer/vector.hpp
index 4f1a148..0191d3c 100644
--- a/immer/vector.hpp
+++ b/immer/vector.hpp
@@ -83,269 +83,275 @@ class vector
 public:
     static constexpr auto bits      = B;
     static constexpr auto bits_leaf = BL;
     using memory_policy             = MemoryPolicy;
 
     using value_type      = T;
     using reference       = const T&;
     using size_type       = detail::rbts::size_t;
     using difference_type = std::ptrdiff_t;
     using const_reference = const T&;
 
     using iterator = detail::rbts::rbtree_iterator<T, MemoryPolicy, B, BL>;
     using const_iterator   = iterator;
     using reverse_iterator = std::reverse_iterator<iterator>;
 
     using transient_type = vector_transient<T, MemoryPolicy, B, BL>;
 
+    /*!
+     * Returns the maximum theoretical size supported by the internal structure
+     * given the current B, BL.
+     */
+    constexpr static size_type max_size() { return impl_t::max_size(); }
+
     /*!
      * Default constructor.  It creates a vector of `size() == 0`.  It
      * does not allocate memory and its complexity is @f$ O(1) @f$.
      */
     vector() = default;
 
     /*!
      * Constructs a vector containing the elements in `values`.
      */
     vector(std::initializer_list<T> values)
         : impl_{impl_t::from_initializer_list(values)}
     {}
 
     /*!
      * Constructs a vector containing the elements in the range
      * defined by the input iterator `first` and range sentinel `last`.
      */
     template <typename Iter,
               typename Sent,
               std::enable_if_t<detail::compatible_sentinel_v<Iter, Sent>,
                                bool> = true>
     vector(Iter first, Sent last)
         : impl_{impl_t::from_range(first, last)}
     {}
 
     /*!
      * Constructs a vector containing the element `val` repeated `n`
      * times.
      */
     vector(size_type n, T v = {})
         : impl_{impl_t::from_fill(n, v)}
     {}
 
     /*!
      * Returns an iterator pointing at the first element of the
      * collection. It does not allocate memory and its complexity is
      * @f$ O(1) @f$.
      */
     IMMER_NODISCARD iterator begin() const { return {impl_}; }
 
     /*!
      * Returns an iterator pointing just after the last element of the
      * collection. It does not allocate and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD iterator end() const
     {
         return {impl_, typename iterator::end_t{}};
     }
 
     /*!
      * Returns an iterator that traverses the collection backwards,
      * pointing at the first element of the reversed collection. It
      * does not allocate memory and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD reverse_iterator rbegin() const
     {
         return reverse_iterator{end()};
     }
 
     /*!
      * Returns an iterator that traverses the collection backwards,
      * pointing after the last element of the reversed collection. It
      * does not allocate memory and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD reverse_iterator rend() const
     {
         return reverse_iterator{begin()};
     }
 
     /*!
      * Returns the number of elements in the container.  It does
      * not allocate memory and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD size_type size() const { return impl_.size; }
 
     /*!
      * Returns `true` if there are no elements in the container.  It
      * does not allocate memory and its complexity is @f$ O(1) @f$.
      */
     IMMER_NODISCARD bool empty() const { return impl_.size == 0; }
 
     /*!
      * Access the last element.
      */
     IMMER_NODISCARD const T& back() const { return impl_.back(); }
 
     /*!
      * Access the first element.
      */
     IMMER_NODISCARD const T& front() const { return impl_.front(); }
 
     /*!
      * Returns a `const` reference to the element at position `index`.
      * It is undefined when @f$ 0 index \geq size() @f$.  It does not
      * allocate memory and its complexity is *effectively* @f$ O(1)
      * @f$.
      */
     IMMER_NODISCARD reference operator[](size_type index) const
     {
         return impl_.get(index);
     }
 
     /*!
      * Returns a `const` reference to the element at position
      * `index`. It throws an `std::out_of_range` exception when @f$
      * index \geq size() @f$.  It does not allocate memory and its
      * complexity is *effectively* @f$ O(1) @f$.
      */
     reference at(size_type index) const { return impl_.get_check(index); }
 
     /*!
      * Returns whether the vectors are equal.
      */
     IMMER_NODISCARD bool operator==(const vector& other) const
     {
         return impl_.equals(other.impl_);
     }
     IMMER_NODISCARD bool operator!=(const vector& other) const
     {
         return !(*this == other);
     }
 
     /*!
      * Returns a vector with `value` inserted at the end.  It may
      * allocate memory and its complexity is *effectively* @f$ O(1) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/vector/vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: push-back/start
      *      :end-before:  push-back/end
      *
      * @endrst
      */
     IMMER_NODISCARD vector push_back(value_type value) const&
     {
         return impl_.push_back(std::move(value));
     }
 
     IMMER_NODISCARD decltype(auto) push_back(value_type value) &&
     {
         return push_back_move(move_t{}, std::move(value));
     }
 
     /*!
      * Returns a vector containing value `value` at position `idx`.
      * Undefined for `index >= size()`.
      * It may allocate memory and its complexity is
      * *effectively* @f$ O(1) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/vector/vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: set/start
      *      :end-before:  set/end
      *
      * @endrst
      */
     IMMER_NODISCARD vector set(size_type index, value_type value) const&
     {
         return impl_.assoc(index, std::move(value));
     }
 
     IMMER_NODISCARD decltype(auto) set(size_type index, value_type value) &&
     {
         return set_move(move_t{}, index, std::move(value));
     }
 
     /*!
      * Returns a vector containing the result of the expression
      * `fn((*this)[idx])` at position `idx`.
      * Undefined for `0 >= size()`.
      * It may allocate memory and its complexity is
      * *effectively* @f$ O(1) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/vector/vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: update/start
      *      :end-before:  update/end
      *
      * @endrst
      */
     template <typename FnT>
     IMMER_NODISCARD vector update(size_type index, FnT&& fn) const&
     {
         return impl_.update(index, std::forward<FnT>(fn));
     }
 
     template <typename FnT>
     IMMER_NODISCARD decltype(auto) update(size_type index, FnT&& fn) &&
     {
         return update_move(move_t{}, index, std::forward<FnT>(fn));
     }
 
     /*!
      * Returns a vector containing only the first `min(elems, size())`
      * elements. It may allocate memory and its complexity is
      * *effectively* @f$ O(1) @f$.
      *
      * @rst
      *
      * **Example**
      *   .. literalinclude:: ../example/vector/vector.cpp
      *      :language: c++
      *      :dedent: 8
      *      :start-after: take/start
      *      :end-before:  take/end
      *
      * @endrst
      */
     IMMER_NODISCARD vector take(size_type elems) const&
     {
         return impl_.take(elems);
     }
 
     IMMER_NODISCARD decltype(auto) take(size_type elems) &&
     {
         return take_move(move_t{}, elems);
     }
 
     /*!
      * Returns an @a transient form of this container, an
      * `immer::vector_transient`.
      */
     IMMER_NODISCARD transient_type transient() const&
     {
         return transient_type{impl_};
     }
     IMMER_NODISCARD transient_type transient() &&
     {
         return transient_type{std::move(impl_)};
     }
 
     // Semi-private
     const impl_t& impl() const { return impl_; }
 
 #if IMMER_DEBUG_PRINT
     void debug_print(std::ostream& out = std::cerr) const
     {
         flex_t{*this}.debug_print(out);
     }
 #endif
diff --git a/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-4787718039797760 b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-4787718039797760
new file mode 100644
index 0000000..5f016b7
Binary files /dev/null and b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-4787718039797760 differ
diff --git a/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-4855756386729984 b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-4855756386729984
new file mode 100644
index 0000000..32e91d6
Binary files /dev/null and b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-4855756386729984 differ
diff --git a/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-4872518268354560 b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-4872518268354560
new file mode 100644
index 0000000..6fd4b40
Binary files /dev/null and b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-4872518268354560 differ
diff --git a/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-5194423089233920 b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-5194423089233920
new file mode 100644
index 0000000..e6a1593
Binary files /dev/null and b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-5194423089233920 differ
diff --git a/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-5635385259196416 b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-5635385259196416
new file mode 100644
index 0000000..c2ccf20
Binary files /dev/null and b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-5635385259196416 differ
diff --git a/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-5660697665732608 b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-5660697665732608
new file mode 100644
index 0000000..7779b93
Binary files /dev/null and b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-5660697665732608 differ
diff --git a/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-6017886557306880 b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-6017886557306880
new file mode 100644
index 0000000..6745fd2
Binary files /dev/null and b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-6017886557306880 differ
diff --git a/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-6265466893631488 b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-6265466893631488
new file mode 100644
index 0000000..788c4b4
Binary files /dev/null and b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-6265466893631488 differ
diff --git a/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-6595824679911424 b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-6595824679911424
new file mode 100644
index 0000000..ccd165b
Binary files /dev/null and b/test/oss-fuzz/data/clusterfuzz-testcase-minimized-flex-vector-gc-6595824679911424 differ
diff --git a/test/oss-fuzz/flex-vector-gc-0.cpp b/test/oss-fuzz/flex-vector-gc-0.cpp
index d9ab5b4..e44879d 100644
--- a/test/oss-fuzz/flex-vector-gc-0.cpp
+++ b/test/oss-fuzz/flex-vector-gc-0.cpp
@@ -33,179 +33,177 @@ namespace {
 int run_input(const std::uint8_t* data, std::size_t size)
 {
     constexpr std::size_t VarCount = 4;
     constexpr unsigned Bits        = 2;
 
     using vector_t    = immer::flex_vector<int, gc_memory, Bits, Bits>;
     using transient_t = typename vector_t::transient_type;
     using size_t      = std::uint8_t;
 
     auto vs = std::array<vector_t, VarCount>{};
     auto ts = std::array<transient_t, VarCount>{};
 
 #if IMMER_FUZZED_TRACE_ENABLE
     std::cout << "/// new test run" << std::endl;
     for (auto i = 0u; i < VarCount; ++i)
         std::cout << "auto v" << i << " = vector_t{};" << std::endl;
     for (auto i = 0u; i < VarCount; ++i)
         std::cout << "auto t" << i << " = transient_t{};" << std::endl;
 #endif
 
     auto is_valid_var = [&](auto idx) { return idx >= 0 && idx < VarCount; };
     auto is_valid_var_neq = [](auto other) {
         return [=](auto idx) {
             return idx >= 0 && idx < VarCount && idx != other;
         };
     };
     auto is_valid_index = [](auto& v) {
         return [&](auto idx) { return idx >= 0 && idx < v.size(); };
     };
     auto is_valid_size = [](auto& v) {
         return [&](auto idx) { return idx >= 0 && idx <= v.size(); };
     };
     auto can_concat = [](auto&& v1, auto&& v2) {
-        using size_type = decltype(v1.size());
-        auto max        = std::numeric_limits<size_type>::max() >> (Bits * 4);
-        return v1.size() < max && v2.size() < max;
+        return v1.size() + v2.size() < vector_t::max_size();
     };
 
     return fuzzer_input{data, size}.run([&](auto& in) {
         enum ops
         {
             op_transient,
             op_persistent,
             op_push_back,
             op_update,
             op_take,
             op_drop,
             op_concat,
             op_push_back_mut,
             op_update_mut,
             op_take_mut,
             op_drop_mut,
             op_prepend_mut,
             op_prepend_mut_move,
             op_append_mut,
             op_append_mut_move,
         };
         auto dst = read<std::uint8_t>(in, is_valid_var);
         switch (read<char>(in)) {
         case op_transient: {
             auto src = read<std::uint8_t>(in, is_valid_var);
             IMMER_FUZZED_TRACE("t" << +dst << " = v" << +src
                                    << ".transient();");
             ts[dst] = vs[src].transient();
             break;
         }
         case op_persistent: {
             auto src = read<std::uint8_t>(in, is_valid_var);
             IMMER_FUZZED_TRACE("v" << +dst << " = t" << +src
                                    << ".persistent();");
             vs[dst] = ts[src].persistent();
             break;
         }
         case op_push_back: {
             auto src = read<std::uint8_t>(in, is_valid_var);
             IMMER_FUZZED_TRACE("v" << +dst << " = v" << +src
                                    << ".push_back(42);");
             vs[dst] = vs[src].push_back(42);
             break;
         }
         case op_update: {
             auto src = read<std::uint8_t>(in, is_valid_var);
             auto idx = read<size_t>(in, is_valid_index(vs[src]));
             IMMER_FUZZED_TRACE("v" << +dst << " = v" << +src << ".update("
                                    << +idx
                                    << ", [] (auto x) { return x + 1; });");
             vs[dst] = vs[src].update(idx, [](auto x) { return x + 1; });
             break;
         }
         case op_take: {
             auto src = read<std::uint8_t>(in, is_valid_var);
             auto idx = read<size_t>(in, is_valid_size(vs[src]));
             IMMER_FUZZED_TRACE("v" << +dst << " = v" << +src << ".take(" << +idx
                                    << ");");
             vs[dst] = vs[src].take(idx);
             break;
         }
         case op_drop: {
             auto src = read<std::uint8_t>(in, is_valid_var);
             auto idx = read<size_t>(in, is_valid_size(vs[src]));
             IMMER_FUZZED_TRACE("v" << +dst << " = v" << +src << ".take(" << +idx
                                    << ");");
             vs[dst] = vs[src].drop(idx);
             break;
         }
         case op_concat: {
             auto src  = read<std::uint8_t>(in, is_valid_var);
             auto src2 = read<std::uint8_t>(in, is_valid_var);
             if (can_concat(vs[src], vs[src2])) {
                 IMMER_FUZZED_TRACE("v" << +dst << " = v" << +src << " + v"
                                        << +src2 << ";");
                 vs[dst] = vs[src] + vs[src2];
             }
             break;
         }
         case op_push_back_mut: {
             IMMER_FUZZED_TRACE("t" << +dst << ".push_back(13);");
             ts[dst].push_back(13);
             break;
         }
         case op_update_mut: {
             auto idx = read<size_t>(in, is_valid_index(ts[dst]));
             IMMER_FUZZED_TRACE("t" << +dst << ".update(" << +idx
                                    << ", [] (auto x) { return x + 1; });");
             ts[dst].update(idx, [](auto x) { return x + 1; });
             break;
         }
         case op_take_mut: {
             auto idx = read<size_t>(in, is_valid_size(ts[dst]));
             IMMER_FUZZED_TRACE("t" << +dst << ").take(" << +idx << ");");
             ts[dst].take(idx);
             break;
         }
         case op_prepend_mut: {
             auto src = read<std::uint8_t>(in, is_valid_var_neq(dst));
             if (can_concat(ts[dst], ts[src])) {
                 IMMER_FUZZED_TRACE("t" << +dst << ".prepend(t" << +src << ");");
                 ts[dst].prepend(ts[src]);
             }
             break;
         }
         case op_prepend_mut_move: {
             auto src = read<std::uint8_t>(in, is_valid_var_neq(dst));
             if (can_concat(ts[dst], ts[src])) {
                 IMMER_FUZZED_TRACE("t" << +dst << ".prepend(std::move(t" << +src
                                        << "));"
                                        << " t" << +src << " = {};");
                 ts[dst].prepend(std::move(ts[src]));
                 ts[src] = {};
             }
             break;
         }
         case op_append_mut: {
             auto src = read<std::uint8_t>(in, is_valid_var_neq(dst));
             if (can_concat(ts[dst], ts[src])) {
                 IMMER_FUZZED_TRACE("t" << +dst << ".append(t" << +src << ");");
                 ts[dst].append(ts[src]);
             }
             break;
         }
         case op_append_mut_move: {
             auto src = read<std::uint8_t>(in, is_valid_var_neq(dst));
             if (can_concat(ts[dst], ts[src])) {
                 IMMER_FUZZED_TRACE("t" << +dst << ".append(std::move(t" << +src
                                        << "));"
                                        << " t" << +src << " = {};");
                 ts[dst].append(std::move(ts[src]));
                 ts[src] = {};
             }
             break;
         }
         default:
             break;
         };
         return true;
     });
 }
 
 } // namespace
@@ -270,3 +268,92 @@ TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24162")
     }
 }
 
+TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24155")
+{
+    SECTION("fuzzer")
+    {
+        auto input = load_input(
+            "clusterfuzz-testcase-minimized-flex-vector-gc-5194423089233920");
+        CHECK(run_input(input.data(), input.size()) == 0);
+    }
+}
+
+TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24136")
+{
+    SECTION("fuzzer")
+    {
+        auto input = load_input(
+            "clusterfuzz-testcase-minimized-flex-vector-gc-5635385259196416");
+        CHECK(run_input(input.data(), input.size()) == 0);
+    }
+}
+
+TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24142")
+{
+    SECTION("fuzzer")
+    {
+        auto input = load_input(
+            "clusterfuzz-testcase-minimized-flex-vector-gc-4787718039797760");
+        CHECK(run_input(input.data(), input.size()) == 0);
+    }
+}
+
+TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24172")
+{
+    SECTION("fuzzer")
+    {
+        auto input = load_input(
+            "clusterfuzz-testcase-minimized-flex-vector-gc-6595824679911424");
+        CHECK(run_input(input.data(), input.size()) == 0);
+    }
+}
+
+TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24173")
+{
+    SECTION("fuzzer")
+    {
+        auto input = load_input(
+            "clusterfuzz-testcase-minimized-flex-vector-gc-4872518268354560");
+        CHECK(run_input(input.data(), input.size()) == 0);
+    }
+}
+
+TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24213")
+{
+    SECTION("fuzzer")
+    {
+        auto input = load_input(
+            "clusterfuzz-testcase-minimized-flex-vector-gc-6265466893631488");
+        CHECK(run_input(input.data(), input.size()) == 0);
+    }
+}
+
+TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24264")
+{
+    SECTION("fuzzer")
+    {
+        auto input = load_input(
+            "clusterfuzz-testcase-minimized-flex-vector-gc-4855756386729984");
+        CHECK(run_input(input.data(), input.size()) == 0);
+    }
+}
+
+TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24286")
+{
+    SECTION("fuzzer")
+    {
+        auto input = load_input(
+            "clusterfuzz-testcase-minimized-flex-vector-gc-6017886557306880");
+        CHECK(run_input(input.data(), input.size()) == 0);
+    }
+}
+
+TEST_CASE("https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=24287")
+{
+    SECTION("fuzzer")
+    {
+        auto input = load_input(
+            "clusterfuzz-testcase-minimized-flex-vector-gc-5660697665732608");
+        CHECK(run_input(input.data(), input.size()) == 0);
+    }
+}
