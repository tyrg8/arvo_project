commit 6f87de7c272d572e6420010bfb704bb2a15e8810
Author: Ethan Nicholas <ethannicholas@google.com>
Date:   Mon Oct 26 15:06:46 2020 -0400

    Made IRNode smaller
    
    This backs off a bit on the "stuff everything into IRNode" push, moving
    the data of the big nodes back into them and significantly cutting the
    size of IRNode. This isn't a complete revert of the changes to these
    nodes - now that all of the fields have been hidden behind accessor
    methods, it's merely an implementation detail where the data actually
    lives, so these changes are much smaller and more targeted.
    
    Change-Id: I84c770245f26dfe36651d0f482543505bd7f71ef
    Reviewed-on: https://skia-review.googlesource.com/c/skia/+/329629
    Reviewed-by: Brian Osman <brianosman@google.com>
    Commit-Queue: Ethan Nicholas <ethannicholas@google.com>

diff --git a/src/sksl/SkSLAnalysis.h b/src/sksl/SkSLAnalysis.h
index 900b3e5dcd..8e977b4449 100644
--- a/src/sksl/SkSLAnalysis.h
+++ b/src/sksl/SkSLAnalysis.h
@@ -18,7 +18,7 @@ namespace SkSL {
 class ErrorReporter;
 class Expression;
 class FunctionDeclaration;
-struct FunctionDefinition;
+class FunctionDefinition;
 struct Program;
 class ProgramElement;
 class ProgramUsage;
diff --git a/src/sksl/SkSLInliner.h b/src/sksl/SkSLInliner.h
index a98dbbb59b..ed6505e766 100644
--- a/src/sksl/SkSLInliner.h
+++ b/src/sksl/SkSLInliner.h
@@ -20,7 +20,7 @@ class Block;
 class Context;
 class Expression;
 class FunctionCall;
-struct FunctionDefinition;
+class FunctionDefinition;
 struct InlineCandidate;
 struct InlineCandidateList;
 class ModifiersPool;
diff --git a/src/sksl/ir/SkSLEnum.h b/src/sksl/ir/SkSLEnum.h
index 22a2a79097..b67730e6bf 100644
--- a/src/sksl/ir/SkSLEnum.h
+++ b/src/sksl/ir/SkSLEnum.h
@@ -24,50 +24,54 @@ class Enum : public ProgramElement {
 public:
     static constexpr Kind kProgramElementKind = Kind::kEnum;
 
     Enum(int offset, StringFragment typeName, std::shared_ptr<SymbolTable> symbols,
          bool isSharedWithCpp, bool isBuiltin = true)
-    : INHERITED(offset, EnumData{typeName, std::move(symbols), isSharedWithCpp, isBuiltin}) {}
+    : INHERITED(offset, kProgramElementKind)
+    , fTypeName(typeName)
+    , fSymbols(std::move(symbols))
+    , fIsSharedWithCpp(isSharedWithCpp)
+    , fIsBuiltin(isBuiltin) {}
 
     StringFragment typeName() const {
-        return this->enumData().fTypeName;
+        return fTypeName;
     }
 
     std::shared_ptr<SymbolTable> symbols() const {
-        return this->enumData().fSymbols;
+        return fSymbols;
     }
 
     bool isBuiltin() const {
-        return this->enumData().fIsBuiltin;
+        return fIsBuiltin;
     }
 
     bool isSharedWithCpp() const {
-        return this->enumData().fIsSharedWithCpp;
+        return fIsSharedWithCpp;
     }
 
     std::unique_ptr<ProgramElement> clone() const override {
         return std::make_unique<Enum>(fOffset, this->typeName(),
                                       SymbolTable::WrapIfBuiltin(this->symbols()),
                                       this->isSharedWithCpp(), /*isBuiltin=*/false);
     }
 
     String code() const {
         String result = "enum class " + this->typeName() + " {\n";
         String separator;
         std::vector<const Symbol*> sortedSymbols;
         sortedSymbols.reserve(symbols()->count());
         this->symbols()->foreach([&](StringFragment, const Symbol* symbol) {
             sortedSymbols.push_back(symbol);
         });
         std::sort(sortedSymbols.begin(), sortedSymbols.end(),
                   [](const Symbol* a, const Symbol* b) { return EnumValue(a) < EnumValue(b); });
         for (const Symbol* s : sortedSymbols) {
             result += separator + "    " + s->name() + " = " + to_string(EnumValue(s));
             separator = ",\n";
         }
         result += "\n};";
         return result;
     }
 
     String description() const override {
         return this->code();
     }
@@ -75,11 +79,16 @@ public:
 private:
     static int EnumValue(const Symbol* symbol) {
         return symbol->as<Variable>().initialValue()->as<IntLiteral>().value();
     }
 
+    StringFragment fTypeName;
+    std::shared_ptr<SymbolTable> fSymbols;
+    bool fIsSharedWithCpp;
+    bool fIsBuiltin;
+
     using INHERITED = ProgramElement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLField.h b/src/sksl/ir/SkSLField.h
index b98a2f0ccb..da1ba7346a 100644
--- a/src/sksl/ir/SkSLField.h
+++ b/src/sksl/ir/SkSLField.h
@@ -25,36 +25,31 @@ class Field : public Symbol {
 public:
     static constexpr Kind kSymbolKind = Kind::kField;
 
     Field(int offset, const Variable* owner, int fieldIndex)
-    : INHERITED(offset, FieldData{owner->type().fields()[fieldIndex].fName,
-                                  owner->type().fields()[fieldIndex].fType,
-                                  owner,
-                                  fieldIndex}) {}
-
-    const Type& type() const override {
-        return *this->fieldData().fType;
-    }
-
-    StringFragment name() const override {
-        return this->fieldData().fName;
-    }
+        : INHERITED(offset, kSymbolKind, owner->type().fields()[fieldIndex].fName,
+                    owner->type().fields()[fieldIndex].fType)
+        , fOwner(owner)
+        , fFieldIndex(fieldIndex) {}
 
     int fieldIndex() const {
-        return this->fieldData().fFieldIndex;
+        return fFieldIndex;
     }
 
     const Variable& owner() const {
-        return *this->fieldData().fOwner;
+        return *fOwner;
     }
 
     String description() const override {
         return this->owner().description() + "." + this->name();
     }
 
 private:
+    const Variable* fOwner;
+    int fFieldIndex;
+
     using INHERITED = Symbol;
 };
 
 } // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLFunctionDeclaration.h b/src/sksl/ir/SkSLFunctionDeclaration.h
index 206e30f293..13346d8e48 100644
--- a/src/sksl/ir/SkSLFunctionDeclaration.h
+++ b/src/sksl/ir/SkSLFunctionDeclaration.h
@@ -18,8 +18,8 @@
 
 namespace SkSL {
 
-struct FunctionDefinition;
+class FunctionDefinition;
 
 /**
  * A function declaration (not a definition -- does not contain a body).
  */
@@ -27,128 +27,134 @@ class FunctionDeclaration : public Symbol {
 public:
     static constexpr Kind kSymbolKind = Kind::kFunctionDeclaration;
 
     FunctionDeclaration(int offset, ModifiersPool::Handle modifiers, StringFragment name,
                         std::vector<const Variable*> parameters, const Type* returnType,
                         bool builtin)
-    : INHERITED(offset, FunctionDeclarationData{name, /*fDefiniition=*/nullptr, modifiers,
-                                                std::move(parameters), returnType, builtin}) {}
+    : INHERITED(offset, kSymbolKind, name, /*type=*/nullptr)
+    , fDefinition(nullptr)
+    , fModifiersHandle(modifiers)
+    , fParameters(std::move(parameters))
+    , fReturnType(returnType)
+    , fBuiltin(builtin) {}
 
     const Modifiers& modifiers() const {
-        return *this->functionDeclarationData().fModifiersHandle;
-    }
-
-    StringFragment name() const override {
-        return this->functionDeclarationData().fName;
+        return *fModifiersHandle;
     }
 
     const FunctionDefinition* definition() const {
-        return this->functionDeclarationData().fDefinition;
+        return fDefinition;
     }
 
     void setDefinition(const FunctionDefinition* definition) const {
-        this->functionDeclarationData().fDefinition = definition;
+        fDefinition = definition;
     }
 
     const std::vector<const Variable*>& parameters() const {
-        return this->functionDeclarationData().fParameters;
+        return fParameters;
     }
 
     const Type& returnType() const {
-        return *this->functionDeclarationData().fReturnType;
+        return *fReturnType;
     }
 
     bool isBuiltin() const {
-        return this->functionDeclarationData().fBuiltin;
+        return fBuiltin;
     }
 
     String description() const override {
         String result = this->returnType().displayName() + " " + this->name() + "(";
         String separator;
         for (auto p : this->parameters()) {
             result += separator;
             separator = ", ";
             result += p->type().displayName();
         }
         result += ")";
         return result;
     }
 
     bool matches(const FunctionDeclaration& f) const {
         if (this->name() != f.name()) {
             return false;
         }
         const std::vector<const Variable*>& parameters = this->parameters();
         const std::vector<const Variable*>& otherParameters = f.parameters();
         if (parameters.size() != otherParameters.size()) {
             return false;
         }
         for (size_t i = 0; i < parameters.size(); i++) {
             if (parameters[i]->type() != otherParameters[i]->type()) {
                 return false;
             }
         }
         return true;
     }
 
     /**
      * Determine the effective types of this function's parameters and return value when called with
      * the given arguments. This is relevant for functions with generic parameter types, where this
      * will collapse the generic types down into specific concrete types.
      *
      * Returns true if it was able to select a concrete set of types for the generic function, false
      * if there is no possible way this can match the argument types. Note that even a true return
      * does not guarantee that the function can be successfully called with those arguments, merely
      * indicates that an attempt should be made. If false is returned, the state of
      * outParameterTypes and outReturnType are undefined.
      *
      * This always assumes narrowing conversions are *allowed*. The calling code needs to verify
      * that each argument can actually be coerced to the final parameter type, respecting the
      * narrowing-conversions flag. This is handled in callCost(), or in convertCall() (via coerce).
      */
     using ParamTypes = SkSTArray<8, const Type*>;
     bool determineFinalTypes(const ExpressionArray& arguments,
                              ParamTypes* outParameterTypes, const Type** outReturnType) const {
         const std::vector<const Variable*>& parameters = this->parameters();
         SkASSERT(arguments.size() == parameters.size());
 
         outParameterTypes->reserve_back(arguments.size());
         int genericIndex = -1;
         for (size_t i = 0; i < arguments.size(); i++) {
             const Type& parameterType = parameters[i]->type();
             if (parameterType.typeKind() == Type::TypeKind::kGeneric) {
                 const std::vector<const Type*>& types = parameterType.coercibleTypes();
                 if (genericIndex == -1) {
                     for (size_t j = 0; j < types.size(); j++) {
                         if (arguments[i]->type().canCoerceTo(*types[j], /*allowNarrowing=*/true)) {
                             genericIndex = j;
                             break;
                         }
                     }
                     if (genericIndex == -1) {
                         return false;
                     }
                 }
                 outParameterTypes->push_back(types[genericIndex]);
             } else {
                 outParameterTypes->push_back(&parameterType);
             }
         }
         const Type& returnType = this->returnType();
         if (returnType.typeKind() == Type::TypeKind::kGeneric) {
             if (genericIndex == -1) {
                 return false;
             }
             *outReturnType = returnType.coercibleTypes()[genericIndex];
         } else {
             *outReturnType = &returnType;
         }
         return true;
     }
 
 private:
+    mutable const FunctionDefinition* fDefinition;
+    ModifiersPool::Handle fModifiersHandle;
+    std::vector<const Variable*> fParameters;
+    const Type* fReturnType;
+    bool fBuiltin;
+
     using INHERITED = Symbol;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLFunctionDefinition.h b/src/sksl/ir/SkSLFunctionDefinition.h
index 939a6a1a28..ff8c307cca 100644
--- a/src/sksl/ir/SkSLFunctionDefinition.h
+++ b/src/sksl/ir/SkSLFunctionDefinition.h
@@ -19,60 +19,75 @@ struct ASTNode;
 /**
  * A function definition (a declaration plus an associated block of code).
  */
-struct FunctionDefinition : public ProgramElement {
+class FunctionDefinition : public ProgramElement {
+public:
     static constexpr Kind kProgramElementKind = Kind::kFunction;
 
     FunctionDefinition(int offset,
                        const FunctionDeclaration* declaration, bool builtin,
                        std::unique_ptr<Statement> body,
                        std::unordered_set<const FunctionDeclaration*> referencedIntrinsics = {})
-        : INHERITED(offset,
-                    FunctionDefinitionData{declaration, builtin, std::move(referencedIntrinsics),
-                                           /*fSource=*/nullptr}) {
+        : INHERITED(offset, kProgramElementKind)
+        , fDeclaration(declaration)
+        , fBuiltin(builtin)
+        , fReferencedIntrinsics(std::move(referencedIntrinsics))
+        , fSource(nullptr) {
         fStatementChildren.push_back(std::move(body));
     }
 
     const FunctionDeclaration& declaration() const {
-        return *this->functionDefinitionData().fDeclaration;
+        return *fDeclaration;
     }
 
     bool isBuiltin() const {
-        return this->functionDefinitionData().fBuiltin;
+        return fBuiltin;
     }
 
     std::unique_ptr<Statement>& body() {
         return this->fStatementChildren[0];
     }
 
     const std::unique_ptr<Statement>& body() const {
         return this->fStatementChildren[0];
     }
 
     const std::unordered_set<const FunctionDeclaration*>& referencedIntrinsics() const {
-        return this->functionDefinitionData().fReferencedIntrinsics;
+        return fReferencedIntrinsics;
     }
 
     const ASTNode* source() const {
-        return this->functionDefinitionData().fSource;
+        return fSource;
     }
 
     void setSource(const ASTNode* source) {
-        this->functionDefinitionData().fSource = source;
+        fSource = source;
     }
 
     std::unique_ptr<ProgramElement> clone() const override {
         return std::make_unique<FunctionDefinition>(fOffset, &this->declaration(),
                                                     /*builtin=*/false, this->body()->clone(),
                                                     this->referencedIntrinsics());
     }
 
     String description() const override {
         return this->declaration().description() + " " + this->body()->description();
     }
 
+private:
+    const FunctionDeclaration* fDeclaration;
+    bool fBuiltin;
+    // We track intrinsic functions we reference so that we can ensure that all of them end up
+    // copied into the final output.
+    std::unordered_set<const FunctionDeclaration*> fReferencedIntrinsics;
+    // This pointer may be null, and even when non-null is not guaranteed to remain valid for
+    // the entire lifespan of this object. The parse tree's lifespan is normally controlled by
+    // IRGenerator, so the IRGenerator being destroyed or being used to compile another file
+    // will invalidate this pointer.
+    const ASTNode* fSource;
+
     using INHERITED = ProgramElement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLIRNode.cpp b/src/sksl/ir/SkSLIRNode.cpp
index f3d81e3d56..9b1817da41 100644
--- a/src/sksl/ir/SkSLIRNode.cpp
+++ b/src/sksl/ir/SkSLIRNode.cpp
@@ -22,21 +22,11 @@ IRNode::IRNode(int offset, int kind, const BoolLiteralData& data)
 , fKind(kind)
 , fData(data) {}
 
-IRNode::IRNode(int offset, int kind, const EnumData& data)
-: fOffset(offset)
-, fKind(kind)
-, fData(data) {}
-
 IRNode::IRNode(int offset, int kind, const ExternalValueData& data)
 : fOffset(offset)
 , fKind(kind)
 , fData(data) {}
 
-IRNode::IRNode(int offset, int kind, const FieldData& data)
-: fOffset(offset)
-, fKind(kind)
-, fData(data) {}
-
 IRNode::IRNode(int offset, int kind, const FieldAccessData& data)
 : fOffset(offset)
 , fKind(kind)
@@ -57,16 +47,6 @@ IRNode::IRNode(int offset, int kind, const FunctionCallData& data)
 , fKind(kind)
 , fData(data) {}
 
-IRNode::IRNode(int offset, int kind, const FunctionDeclarationData& data)
-: fOffset(offset)
-, fKind(kind)
-, fData(data) {}
-
-IRNode::IRNode(int offset, int kind, const FunctionDefinitionData& data)
-: fOffset(offset)
-, fKind(kind)
-, fData(data) {}
-
 IRNode::IRNode(int offset, int kind, const FunctionReferenceData& data)
 : fOffset(offset)
 , fKind(kind)
@@ -82,11 +62,6 @@ IRNode::IRNode(int offset, int kind, const InlineMarkerData& data)
 , fKind(kind)
 , fData(data) {}
 
-IRNode::IRNode(int offset, int kind, const InterfaceBlockData& data)
-: fOffset(offset)
-, fKind(kind)
-, fData(data) {}
-
 IRNode::IRNode(int offset, int kind, const IntLiteralData& data)
 : fOffset(offset)
 , fKind(kind)
@@ -97,11 +72,6 @@ IRNode::IRNode(int offset, int kind, const ModifiersDeclarationData& data)
 , fKind(kind)
 , fData(data) {}
 
-IRNode::IRNode(int offset, int kind, const SectionData& data)
-: fOffset(offset)
-, fKind(kind)
-, fData(data) {}
-
 IRNode::IRNode(int offset, int kind, const SettingData& data)
 : fOffset(offset)
 , fKind(kind)
@@ -157,11 +127,6 @@ IRNode::IRNode(int offset, int kind, const VarDeclarationData& data)
 , fKind(kind)
 , fData(data) {}
 
-IRNode::IRNode(int offset, int kind, const VariableData& data)
-: fOffset(offset)
-, fKind(kind)
-, fData(data) {}
-
 IRNode::IRNode(int offset, int kind, const VariableReferenceData& data)
 : fOffset(offset)
 , fKind(kind)
diff --git a/src/sksl/ir/SkSLIRNode.h b/src/sksl/ir/SkSLIRNode.h
index 990d4772f5..7a26e4cf9a 100644
--- a/src/sksl/ir/SkSLIRNode.h
+++ b/src/sksl/ir/SkSLIRNode.h
@@ -25,7 +25,7 @@ namespace SkSL {
 class Expression;
 class ExternalValue;
 class FunctionDeclaration;
-struct FunctionDefinition;
+class FunctionDefinition;
 class Statement;
 class Symbol;
 class SymbolTable;
@@ -47,34 +47,32 @@ class IRNode {
 public:
     virtual ~IRNode();
 
     IRNode& operator=(const IRNode& other) {
         // Need to have a copy assignment operator because Type requires it, but can't use the
         // default version until we finish migrating away from std::unique_ptr children. For now,
         // just assert that there are no children (we could theoretically clone them, but we never
         // actually copy nodes containing children).
         SkASSERT(other.fExpressionChildren.empty());
         fKind = other.fKind;
         fOffset = other.fOffset;
         fData = other.fData;
         return *this;
     }
 
     virtual String description() const = 0;
 
     // character offset of this element within the program being compiled, for error reporting
     // purposes
     int fOffset;
 
     // Override operator new and delete to allow us to control allocation behavior.
     static void* operator new(const size_t size) {
-        // TODO: once all IRNodes hold their data in fData, everything should come out of the pool,
-        // and this check should become an assertion.
         if (size == sizeof(IRNode)) {
             return Pool::AllocIRNode();
         }
         return ::operator new(size);
     }
 
     static void operator delete(void* ptr) {
         Pool::FreeIRNode(ptr);
     }
@@ -82,947 +80,716 @@ public:
 protected:
     struct BlockData {
         std::shared_ptr<SymbolTable> fSymbolTable;
         // if isScope is false, this is just a group of statements rather than an actual
         // language-level block. This allows us to pass around multiple statements as if they were a
         // single unit, with no semantic impact.
         bool fIsScope;
     };
 
     struct BoolLiteralData {
         const Type* fType;
         bool fValue;
     };
 
-    struct EnumData {
-        StringFragment fTypeName;
-        std::shared_ptr<SymbolTable> fSymbols;
-        bool fIsSharedWithCpp;
-        bool fIsBuiltin;
-    };
-
     struct ExternalValueData {
         const Type* fType;
         const ExternalValue* fValue;
     };
 
-    struct FieldData {
-        StringFragment fName;
-        const Type* fType;
-        const Variable* fOwner;
-        int fFieldIndex;
-    };
-
     struct FieldAccessData {
         const Type* fType;
         int fFieldIndex;
         FieldAccessOwnerKind fOwnerKind;
     };
 
     struct FloatLiteralData {
         const Type* fType;
         float fValue;
     };
 
     struct ForStatementData {
         std::shared_ptr<SymbolTable> fSymbolTable;
     };
 
     struct FunctionCallData {
         const Type* fType;
         const FunctionDeclaration* fFunction;
     };
 
-    struct FunctionDeclarationData {
-        StringFragment fName;
-        mutable const FunctionDefinition* fDefinition;
-        ModifiersPool::Handle fModifiersHandle;
-        // FIXME after killing fExpressionChildren / fStatementChildren in favor of just fChildren,
-        // the parameters should move into that vector
-        std::vector<const Variable*> fParameters;
-        const Type* fReturnType;
-        bool fBuiltin;
-
-        FunctionDeclarationData& operator=(const FunctionDeclarationData& other) {
-            fName = other.fName;
-            fDefinition = other.fDefinition;
-            fModifiersHandle = other.fModifiersHandle;
-            fParameters = other.fParameters;
-            fReturnType = other.fReturnType;
-            fBuiltin = other.fBuiltin;
-            return *this;
-        }
-    };
-
-    struct FunctionDefinitionData {
-        const FunctionDeclaration* fDeclaration;
-        bool fBuiltin;
-        // We track intrinsic functions we reference so that we can ensure that all of them end up
-        // copied into the final output.
-        std::unordered_set<const FunctionDeclaration*> fReferencedIntrinsics;
-        // This pointer may be null, and even when non-null is not guaranteed to remain valid for
-        // the entire lifespan of this object. The parse tree's lifespan is normally controlled by
-        // IRGenerator, so the IRGenerator being destroyed or being used to compile another file
-        // will invalidate this pointer.
-        const ASTNode* fSource;
-    };
-
     struct FunctionReferenceData {
         const Type* fType;
         std::vector<const FunctionDeclaration*> fFunctions;
      };
 
     struct IfStatementData {
         bool fIsStatic;
     };
 
-    struct InterfaceBlockData {
-        const Variable* fVariable;
-        String fTypeName;
-        String fInstanceName;
-        std::shared_ptr<SymbolTable> fTypeOwner;
-    };
-
     struct IntLiteralData {
         const Type* fType;
         int64_t fValue;
     };
 
     struct InlineMarkerData {
         const FunctionDeclaration* fFunction;
     };
 
     struct ModifiersDeclarationData {
         ModifiersPool::Handle fModifiersHandle;
     };
 
-    struct SectionData {
-        String fName;
-        String fArgument;
-        String fText;
-    };
-
     struct SettingData {
         String fName;
         const Type* fType;
     };
 
     struct SwitchStatementData {
         bool fIsStatic;
         std::shared_ptr<SymbolTable> fSymbols;
     };
 
     struct SwizzleData {
         const Type* fType;
         std::vector<int> fComponents;
     };
 
     struct SymbolData {
         StringFragment fName;
         const Type* fType;
     };
 
     struct SymbolAliasData {
         StringFragment fName;
         const Symbol* fOrigSymbol;
     };
 
     struct TypeReferenceData {
         const Type* fType;
         const Type* fValue;
      };
 
     struct TypeTokenData {
         const Type* fType;
         Token::Kind fToken;
     };
 
     struct UnresolvedFunctionData {
         // FIXME move this into the child vector after killing fExpressionChildren /
         // fStatementChildren
         std::vector<const FunctionDeclaration*> fFunctions;
     };
 
     struct VarDeclarationData {
         const Type* fBaseType;
         const Variable* fVar;
     };
 
-    struct VariableData {
-        StringFragment fName;
-        const Type* fType;
-        const Expression* fInitialValue = nullptr;
-        ModifiersPool::Handle fModifiersHandle;
-        VariableStorage fStorage;
-        bool fBuiltin;
-    };
-
     struct VariableReferenceData {
         const Variable* fVariable;
         VariableRefKind fRefKind;
     };
 
     struct NodeData {
         enum class Kind {
             kBlock,
             kBoolLiteral,
-            kEnum,
             kExternalValue,
-            kField,
             kFieldAccess,
             kFloatLiteral,
             kForStatement,
             kFunctionCall,
-            kFunctionDeclaration,
-            kFunctionDefinition,
             kFunctionReference,
             kIfStatement,
             kInlineMarker,
-            kInterfaceBlock,
             kIntLiteral,
             kModifiersDeclaration,
-            kSection,
             kSetting,
             kString,
             kSwitchStatement,
             kSwizzle,
             kSymbol,
             kSymbolAlias,
             kType,
             kTypeReference,
             kTypeToken,
             kUnresolvedFunction,
             kVarDeclaration,
-            kVariable,
             kVariableReference,
         } fKind = Kind::kType;
         // it doesn't really matter what kind we default to, as long as it's a POD type
 
         union Contents {
             BlockData fBlock;
             BoolLiteralData fBoolLiteral;
-            EnumData fEnum;
             ExternalValueData fExternalValue;
-            FieldData fField;
             FieldAccessData fFieldAccess;
             FloatLiteralData fFloatLiteral;
             ForStatementData fForStatement;
             FunctionCallData fFunctionCall;
-            FunctionDeclarationData fFunctionDeclaration;
-            FunctionDefinitionData fFunctionDefinition;
             FunctionReferenceData fFunctionReference;
             IfStatementData fIfStatement;
             InlineMarkerData fInlineMarker;
-            InterfaceBlockData fInterfaceBlock;
             IntLiteralData fIntLiteral;
             ModifiersDeclarationData fModifiersDeclaration;
-            SectionData fSection;
             SettingData fSetting;
             String fString;
             SwitchStatementData fSwitchStatement;
             SwizzleData fSwizzle;
             SymbolData fSymbol;
             SymbolAliasData fSymbolAlias;
             const Type* fType;
             TypeReferenceData fTypeReference;
             TypeTokenData fTypeToken;
             UnresolvedFunctionData fUnresolvedFunction;
             VarDeclarationData fVarDeclaration;
-            VariableData fVariable;
             VariableReferenceData fVariableReference;
 
             Contents() {}
 
             ~Contents() {}
         } fContents;
 
         NodeData(const BlockData& data)
             : fKind(Kind::kBlock) {
             *(new(&fContents) BlockData) = data;
         }
 
         NodeData(const BoolLiteralData& data)
             : fKind(Kind::kBoolLiteral) {
             *(new(&fContents) BoolLiteralData) = data;
         }
 
-        NodeData(const EnumData& data)
-            : fKind(Kind::kEnum) {
-            *(new(&fContents) EnumData) = data;
-        }
-
         NodeData(const ExternalValueData& data)
             : fKind(Kind::kExternalValue) {
             *(new(&fContents) ExternalValueData) = data;
         }
 
-        NodeData(const FieldData& data)
-            : fKind(Kind::kField) {
-            *(new(&fContents) FieldData) = data;
-        }
-
         NodeData(const FieldAccessData& data)
             : fKind(Kind::kFieldAccess) {
             *(new(&fContents) FieldAccessData) = data;
         }
 
         NodeData(const FloatLiteralData& data)
             : fKind(Kind::kFloatLiteral) {
             *(new(&fContents) FloatLiteralData) = data;
         }
 
         NodeData(const ForStatementData& data)
             : fKind(Kind::kForStatement) {
             *(new(&fContents) ForStatementData) = data;
         }
 
         NodeData(const FunctionCallData& data)
             : fKind(Kind::kFunctionCall) {
             *(new(&fContents) FunctionCallData) = data;
         }
 
-        NodeData(const FunctionDeclarationData& data)
-            : fKind(Kind::kFunctionDeclaration) {
-            *(new(&fContents) FunctionDeclarationData) = data;
-        }
-
-        NodeData(const FunctionDefinitionData& data)
-            : fKind(Kind::kFunctionDefinition) {
-            *(new(&fContents) FunctionDefinitionData) = data;
-        }
-
         NodeData(const FunctionReferenceData& data)
             : fKind(Kind::kFunctionReference) {
             *(new(&fContents) FunctionReferenceData) = data;
         }
 
         NodeData(IfStatementData data)
             : fKind(Kind::kIfStatement) {
             *(new(&fContents) IfStatementData) = data;
         }
 
         NodeData(InlineMarkerData data)
             : fKind(Kind::kInlineMarker) {
             *(new(&fContents) InlineMarkerData) = data;
         }
 
-        NodeData(InterfaceBlockData data)
-            : fKind(Kind::kInterfaceBlock) {
-            *(new(&fContents) InterfaceBlockData) = data;
-        }
-
         NodeData(IntLiteralData data)
             : fKind(Kind::kIntLiteral) {
             *(new(&fContents) IntLiteralData) = data;
         }
 
         NodeData(ModifiersDeclarationData data)
             : fKind(Kind::kModifiersDeclaration) {
             *(new(&fContents) ModifiersDeclarationData) = data;
         }
 
-        NodeData(const SectionData& data)
-            : fKind(Kind::kSection) {
-            *(new(&fContents) SectionData) = data;
-        }
-
         NodeData(const SettingData& data)
             : fKind(Kind::kSetting) {
             *(new(&fContents) SettingData) = data;
         }
 
         NodeData(const String& data)
             : fKind(Kind::kString) {
             *(new(&fContents) String) = data;
         }
 
         NodeData(const SwitchStatementData& data)
             : fKind(Kind::kSwitchStatement) {
             *(new(&fContents) SwitchStatementData) = data;
         }
 
         NodeData(const SwizzleData& data)
             : fKind(Kind::kSwizzle) {
             *(new(&fContents) SwizzleData) = data;
         }
 
         NodeData(const SymbolData& data)
             : fKind(Kind::kSymbol) {
             *(new(&fContents) SymbolData) = data;
         }
 
         NodeData(const SymbolAliasData& data)
             : fKind(Kind::kSymbolAlias) {
             *(new(&fContents) SymbolAliasData) = data;
         }
 
         NodeData(const Type* data)
             : fKind(Kind::kType) {
             *(new(&fContents) const Type*) = data;
         }
 
         NodeData(const TypeReferenceData& data)
             : fKind(Kind::kTypeReference) {
             *(new(&fContents) TypeReferenceData) = data;
         }
 
         NodeData(const TypeTokenData& data)
             : fKind(Kind::kTypeToken) {
             *(new(&fContents) TypeTokenData) = data;
         }
 
         NodeData(const UnresolvedFunctionData& data)
             : fKind(Kind::kUnresolvedFunction) {
             *(new(&fContents) UnresolvedFunctionData) = data;
         }
 
         NodeData(const VarDeclarationData& data)
             : fKind(Kind::kVarDeclaration) {
             *(new(&fContents) VarDeclarationData) = data;
         }
 
-        NodeData(const VariableData& data)
-            : fKind(Kind::kVariable) {
-            *(new(&fContents) VariableData) = data;
-        }
-
         NodeData(const VariableReferenceData& data)
             : fKind(Kind::kVariableReference) {
             *(new(&fContents) VariableReferenceData) = data;
         }
 
         NodeData(const NodeData& other) {
             *this = other;
         }
 
         NodeData& operator=(const NodeData& other) {
             this->cleanup();
             fKind = other.fKind;
             switch (fKind) {
                 case Kind::kBlock:
                     *(new(&fContents) BlockData) = other.fContents.fBlock;
                     break;
                 case Kind::kBoolLiteral:
                     *(new(&fContents) BoolLiteralData) = other.fContents.fBoolLiteral;
                     break;
-                case Kind::kEnum:
-                    *(new(&fContents) EnumData) = other.fContents.fEnum;
-                    break;
                 case Kind::kExternalValue:
                     *(new(&fContents) ExternalValueData) = other.fContents.fExternalValue;
                     break;
-                case Kind::kField:
-                    *(new(&fContents) FieldData) = other.fContents.fField;
-                    break;
                 case Kind::kFieldAccess:
                     *(new(&fContents) FieldAccessData) = other.fContents.fFieldAccess;
                     break;
                 case Kind::kFloatLiteral:
                     *(new(&fContents) FloatLiteralData) = other.fContents.fFloatLiteral;
                     break;
                 case Kind::kForStatement:
                     *(new(&fContents) ForStatementData) = other.fContents.fForStatement;
                     break;
                 case Kind::kFunctionCall:
                     *(new(&fContents) FunctionCallData) = other.fContents.fFunctionCall;
                     break;
-                case Kind::kFunctionDeclaration:
-                    *(new(&fContents) FunctionDeclarationData) =
-                                                               other.fContents.fFunctionDeclaration;
-                    break;
-                case Kind::kFunctionDefinition:
-                    *(new(&fContents) FunctionDefinitionData) = other.fContents.fFunctionDefinition;
-                    break;
                 case Kind::kFunctionReference:
                     *(new(&fContents) FunctionReferenceData) = other.fContents.fFunctionReference;
                     break;
                 case Kind::kIfStatement:
                     *(new(&fContents) IfStatementData) = other.fContents.fIfStatement;
                     break;
                 case Kind::kInlineMarker:
                     *(new(&fContents) InlineMarkerData) = other.fContents.fInlineMarker;
                     break;
-                case Kind::kInterfaceBlock:
-                    *(new(&fContents) InterfaceBlockData) = other.fContents.fInterfaceBlock;
-                    break;
                 case Kind::kIntLiteral:
                     *(new(&fContents) IntLiteralData) = other.fContents.fIntLiteral;
                     break;
                 case Kind::kModifiersDeclaration:
                     *(new(&fContents) ModifiersDeclarationData) =
                                                               other.fContents.fModifiersDeclaration;
                     break;
-                case Kind::kSection:
-                    *(new(&fContents) SectionData) = other.fContents.fSection;
-                    break;
                 case Kind::kSetting:
                     *(new(&fContents) SettingData) = other.fContents.fSetting;
                     break;
                 case Kind::kString:
                     *(new(&fContents) String) = other.fContents.fString;
                     break;
                 case Kind::kSwitchStatement:
                     *(new(&fContents) SwitchStatementData) = other.fContents.fSwitchStatement;
                     break;
                 case Kind::kSwizzle:
                     *(new(&fContents) SwizzleData) = other.fContents.fSwizzle;
                     break;
                 case Kind::kSymbol:
                     *(new(&fContents) SymbolData) = other.fContents.fSymbol;
                     break;
                 case Kind::kSymbolAlias:
                     *(new(&fContents) SymbolAliasData) = other.fContents.fSymbolAlias;
                     break;
                 case Kind::kType:
                     *(new(&fContents) const Type*) = other.fContents.fType;
                     break;
                 case Kind::kTypeReference:
                     *(new(&fContents) TypeReferenceData) = other.fContents.fTypeReference;
                     break;
                 case Kind::kTypeToken:
                     *(new(&fContents) TypeTokenData) = other.fContents.fTypeToken;
                     break;
                 case Kind::kUnresolvedFunction:
                     *(new(&fContents) UnresolvedFunctionData) = other.fContents.fUnresolvedFunction;
                     break;
                 case Kind::kVarDeclaration:
                     *(new(&fContents) VarDeclarationData) = other.fContents.fVarDeclaration;
                     break;
-                case Kind::kVariable:
-                    *(new(&fContents) VariableData) = other.fContents.fVariable;
-                    break;
                 case Kind::kVariableReference:
                     *(new(&fContents) VariableReferenceData) = other.fContents.fVariableReference;
                     break;
             }
             return *this;
         }
 
         ~NodeData() {
             this->cleanup();
         }
 
     private:
         void cleanup() {
             switch (fKind) {
                 case Kind::kBlock:
                     fContents.fBlock.~BlockData();
                     break;
                 case Kind::kBoolLiteral:
                     fContents.fBoolLiteral.~BoolLiteralData();
                     break;
-                case Kind::kEnum:
-                    fContents.fEnum.~EnumData();
-                    break;
                 case Kind::kExternalValue:
                     fContents.fExternalValue.~ExternalValueData();
                     break;
-                case Kind::kField:
-                    fContents.fField.~FieldData();
-                    break;
                 case Kind::kFieldAccess:
                     fContents.fFieldAccess.~FieldAccessData();
                     break;
                 case Kind::kFloatLiteral:
                     fContents.fFloatLiteral.~FloatLiteralData();
                     break;
                 case Kind::kForStatement:
                     fContents.fForStatement.~ForStatementData();
                     break;
                 case Kind::kFunctionCall:
                     fContents.fFunctionCall.~FunctionCallData();
                     break;
-                case Kind::kFunctionDeclaration:
-                    fContents.fFunctionDeclaration.~FunctionDeclarationData();
-                    break;
-                case Kind::kFunctionDefinition:
-                    fContents.fFunctionDefinition.~FunctionDefinitionData();
-                    break;
                 case Kind::kFunctionReference:
                     fContents.fFunctionReference.~FunctionReferenceData();
                     break;
                 case Kind::kIfStatement:
                     fContents.fIfStatement.~IfStatementData();
                     break;
                 case Kind::kInlineMarker:
                     fContents.fInlineMarker.~InlineMarkerData();
                     break;
-                case Kind::kInterfaceBlock:
-                    fContents.fInterfaceBlock.~InterfaceBlockData();
-                    break;
                 case Kind::kIntLiteral:
                     fContents.fIntLiteral.~IntLiteralData();
                     break;
                 case Kind::kModifiersDeclaration:
                     fContents.fModifiersDeclaration.~ModifiersDeclarationData();
                     break;
-                case Kind::kSection:
-                    fContents.fSection.~SectionData();
-                    break;
                 case Kind::kSetting:
                     fContents.fSetting.~SettingData();
                     break;
                 case Kind::kString:
                     fContents.fString.~String();
                     break;
                 case Kind::kSwitchStatement:
                     fContents.fSwitchStatement.~SwitchStatementData();
                     break;
                 case Kind::kSwizzle:
                     fContents.fSwizzle.~SwizzleData();
                     break;
                 case Kind::kSymbol:
                     fContents.fSymbol.~SymbolData();
                     break;
                 case Kind::kSymbolAlias:
                     fContents.fSymbolAlias.~SymbolAliasData();
                     break;
                 case Kind::kType:
                     break;
                 case Kind::kTypeReference:
                     fContents.fTypeReference.~TypeReferenceData();
                     break;
                 case Kind::kTypeToken:
                     fContents.fTypeToken.~TypeTokenData();
                     break;
                 case Kind::kUnresolvedFunction:
                     fContents.fUnresolvedFunction.~UnresolvedFunctionData();
                     break;
                 case Kind::kVarDeclaration:
                     fContents.fVarDeclaration.~VarDeclarationData();
                     break;
-                case Kind::kVariable:
-                    fContents.fVariable.~VariableData();
-                    break;
                 case Kind::kVariableReference:
                     fContents.fVariableReference.~VariableReferenceData();
                     break;
             }
         }
     };
 
     IRNode(int offset, int kind, const BlockData& data, StatementArray stmts);
 
     IRNode(int offset, int kind, const BoolLiteralData& data);
 
-    IRNode(int offset, int kind, const EnumData& data);
-
     IRNode(int offset, int kind, const ExternalValueData& data);
 
-    IRNode(int offset, int kind, const FieldData& data);
-
     IRNode(int offset, int kind, const FieldAccessData& data);
 
     IRNode(int offset, int kind, const FloatLiteralData& data);
 
     IRNode(int offset, int kind, const ForStatementData& data);
 
     IRNode(int offset, int kind, const FunctionCallData& data);
 
-    IRNode(int offset, int kind, const FunctionDeclarationData& data);
-
-    IRNode(int offset, int kind, const FunctionDefinitionData& data);
-
     IRNode(int offset, int kind, const FunctionReferenceData& data);
 
     IRNode(int offset, int kind, const IfStatementData& data);
 
     IRNode(int offset, int kind, const InlineMarkerData& data);
 
-    IRNode(int offset, int kind, const InterfaceBlockData& data);
-
     IRNode(int offset, int kind, const IntLiteralData& data);
 
     IRNode(int offset, int kind, const ModifiersDeclarationData& data);
 
-    IRNode(int offset, int kind, const SectionData& data);
-
     IRNode(int offset, int kind, const SettingData& data);
 
     IRNode(int offset, int kind, const String& data);
 
     IRNode(int offset, int kind, const SwitchStatementData& data);
 
     IRNode(int offset, int kind, const SwizzleData& data);
 
     IRNode(int offset, int kind, const SymbolData& data);
 
     IRNode(int offset, int kind, const SymbolAliasData& data);
 
     IRNode(int offset, int kind, const Type* data = nullptr);
 
     IRNode(int offset, int kind, const TypeReferenceData& data);
 
     IRNode(int offset, int kind, const TypeTokenData& data);
 
     IRNode(int offset, int kind, const UnresolvedFunctionData& data);
 
     IRNode(int offset, int kind, const VarDeclarationData& data);
 
-    IRNode(int offset, int kind, const VariableData& data);
-
     IRNode(int offset, int kind, const VariableReferenceData& data);
 
     Expression& expressionChild(int index) const {
         SkASSERT(index >= 0 && index < (int) fExpressionChildren.size());
         return *fExpressionChildren[index];
     }
 
     std::unique_ptr<Expression>& expressionPointer(int index) {
         SkASSERT(index >= 0 && index < (int) fExpressionChildren.size());
         return fExpressionChildren[index];
     }
 
     const std::unique_ptr<Expression>& expressionPointer(int index) const {
         SkASSERT(index >= 0 && index < (int) fExpressionChildren.size());
         return fExpressionChildren[index];
     }
 
     int expressionChildCount() const {
         return fExpressionChildren.size();
     }
 
 
     Statement& statementChild(int index) const {
         SkASSERT(index >= 0 && index < (int) fStatementChildren.size());
         return *fStatementChildren[index];
     }
 
     std::unique_ptr<Statement>& statementPointer(int index) {
         SkASSERT(index >= 0 && index < (int) fStatementChildren.size());
         return fStatementChildren[index];
     }
 
     const std::unique_ptr<Statement>& statementPointer(int index) const {
         SkASSERT(index >= 0 && index < (int) fStatementChildren.size());
         return fStatementChildren[index];
     }
 
     int statementChildCount() const {
         return fStatementChildren.size();
     }
 
     BlockData& blockData() {
         SkASSERT(fData.fKind == NodeData::Kind::kBlock);
         return fData.fContents.fBlock;
     }
 
     const BlockData& blockData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kBlock);
         return fData.fContents.fBlock;
     }
 
     const BoolLiteralData& boolLiteralData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kBoolLiteral);
         return fData.fContents.fBoolLiteral;
     }
 
-    const EnumData& enumData() const {
-        SkASSERT(fData.fKind == NodeData::Kind::kEnum);
-        return fData.fContents.fEnum;
-    }
-
     const ExternalValueData& externalValueData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kExternalValue);
         return fData.fContents.fExternalValue;
     }
 
-    const FieldData& fieldData() const {
-        SkASSERT(fData.fKind == NodeData::Kind::kField);
-        return fData.fContents.fField;
-    }
-
     const FieldAccessData& fieldAccessData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kFieldAccess);
         return fData.fContents.fFieldAccess;
     }
 
     const FloatLiteralData& floatLiteralData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kFloatLiteral);
         return fData.fContents.fFloatLiteral;
     }
 
     const ForStatementData& forStatementData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kForStatement);
         return fData.fContents.fForStatement;
     }
 
     const FunctionCallData& functionCallData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kFunctionCall);
         return fData.fContents.fFunctionCall;
     }
 
-    FunctionDeclarationData& functionDeclarationData() {
-        SkASSERT(fData.fKind == NodeData::Kind::kFunctionDeclaration);
-        return fData.fContents.fFunctionDeclaration;
-    }
-
-    const FunctionDeclarationData& functionDeclarationData() const {
-        SkASSERT(fData.fKind == NodeData::Kind::kFunctionDeclaration);
-        return fData.fContents.fFunctionDeclaration;
-    }
-
-    FunctionDefinitionData& functionDefinitionData() {
-        SkASSERT(fData.fKind == NodeData::Kind::kFunctionDefinition);
-        return fData.fContents.fFunctionDefinition;
-    }
-
-    const FunctionDefinitionData& functionDefinitionData() const {
-        SkASSERT(fData.fKind == NodeData::Kind::kFunctionDefinition);
-        return fData.fContents.fFunctionDefinition;
-    }
-
     const FunctionReferenceData& functionReferenceData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kFunctionReference);
         return fData.fContents.fFunctionReference;
     }
 
     const IfStatementData& ifStatementData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kIfStatement);
         return fData.fContents.fIfStatement;
     }
 
     const InlineMarkerData& inlineMarkerData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kInlineMarker);
         return fData.fContents.fInlineMarker;
     }
 
-    InterfaceBlockData& interfaceBlockData() {
-        SkASSERT(fData.fKind == NodeData::Kind::kInterfaceBlock);
-        return fData.fContents.fInterfaceBlock;
-    }
-
-    const InterfaceBlockData& interfaceBlockData() const {
-        SkASSERT(fData.fKind == NodeData::Kind::kInterfaceBlock);
-        return fData.fContents.fInterfaceBlock;
-    }
-
     const IntLiteralData& intLiteralData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kIntLiteral);
         return fData.fContents.fIntLiteral;
     }
 
     const ModifiersDeclarationData& modifiersDeclarationData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kModifiersDeclaration);
         return fData.fContents.fModifiersDeclaration;
     }
 
-    const SectionData& sectionData() const {
-        SkASSERT(fData.fKind == NodeData::Kind::kSection);
-        return fData.fContents.fSection;
-    }
-
     const SettingData& settingData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kSetting);
         return fData.fContents.fSetting;
     }
 
     const String& stringData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kString);
         return fData.fContents.fString;
     }
 
     SwitchStatementData& switchStatementData() {
         SkASSERT(fData.fKind == NodeData::Kind::kSwitchStatement);
         return fData.fContents.fSwitchStatement;
     }
 
     const SwitchStatementData& switchStatementData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kSwitchStatement);
         return fData.fContents.fSwitchStatement;
     }
 
     SwizzleData& swizzleData() {
         SkASSERT(fData.fKind == NodeData::Kind::kSwizzle);
         return fData.fContents.fSwizzle;
     }
 
     const SwizzleData& swizzleData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kSwizzle);
         return fData.fContents.fSwizzle;
     }
 
     SymbolData& symbolData() {
         SkASSERT(fData.fKind == NodeData::Kind::kSymbol);
         return fData.fContents.fSymbol;
     }
 
     const SymbolData& symbolData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kSymbol);
         return fData.fContents.fSymbol;
     }
 
     const SymbolAliasData& symbolAliasData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kSymbolAlias);
         return fData.fContents.fSymbolAlias;
     }
 
     const Type* typeData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kType);
         return fData.fContents.fType;
     }
 
     const TypeReferenceData& typeReferenceData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kTypeReference);
         return fData.fContents.fTypeReference;
     }
 
     const TypeTokenData& typeTokenData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kTypeToken);
         return fData.fContents.fTypeToken;
     }
 
     const UnresolvedFunctionData& unresolvedFunctionData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kUnresolvedFunction);
         return fData.fContents.fUnresolvedFunction;
     }
 
     VarDeclarationData& varDeclarationData() {
         SkASSERT(fData.fKind == NodeData::Kind::kVarDeclaration);
         return fData.fContents.fVarDeclaration;
     }
 
     const VarDeclarationData& varDeclarationData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kVarDeclaration);
         return fData.fContents.fVarDeclaration;
     }
 
-    VariableData& variableData() {
-        SkASSERT(fData.fKind == NodeData::Kind::kVariable);
-        return fData.fContents.fVariable;
-    }
-
-    const VariableData& variableData() const {
-        SkASSERT(fData.fKind == NodeData::Kind::kVariable);
-        return fData.fContents.fVariable;
-    }
-
     VariableReferenceData& variableReferenceData() {
         SkASSERT(fData.fKind == NodeData::Kind::kVariableReference);
         return fData.fContents.fVariableReference;
     }
 
     const VariableReferenceData& variableReferenceData() const {
         SkASSERT(fData.fKind == NodeData::Kind::kVariableReference);
         return fData.fContents.fVariableReference;
     }
 
     int fKind;
 
     NodeData fData;
 
     // Needing two separate vectors is a temporary issue. Ideally, we'd just be able to use a single
     // vector of nodes, but there are various spots where we take pointers to std::unique_ptr<>,
     // and it isn't safe to pun std::unique_ptr<IRNode> to std::unique_ptr<Statement / Expression>.
     // And we can't update the call sites to expect std::unique_ptr<IRNode> while there are still
     // old-style nodes around.
     // When the transition is finished, we'll be able to drop the unique_ptrs and just handle
     // <IRNode> directly.
     ExpressionArray fExpressionChildren;
     // it's important to keep the statement array defined after (and thus destroyed before) fData,
     // because destroying statements can modify reference counts in a SymbolTable contained in fData
     StatementArray fStatementChildren;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLInterfaceBlock.h b/src/sksl/ir/SkSLInterfaceBlock.h
index 672e3b3f9e..a5e387983b 100644
--- a/src/sksl/ir/SkSLInterfaceBlock.h
+++ b/src/sksl/ir/SkSLInterfaceBlock.h
@@ -17,88 +17,98 @@ namespace SkSL {
 /**
  * An interface block, as in:
  *
  * out sk_PerVertex {
  *   layout(builtin=0) float4 sk_Position;
  *   layout(builtin=1) float sk_PointSize;
  * };
  *
  * At the IR level, this is represented by a single variable of struct type.
  */
-struct InterfaceBlock : public ProgramElement {
+class InterfaceBlock : public ProgramElement {
+public:
     static constexpr Kind kProgramElementKind = Kind::kInterfaceBlock;
 
     InterfaceBlock(int offset, const Variable* var, String typeName, String instanceName,
                    ExpressionArray sizes, std::shared_ptr<SymbolTable> typeOwner)
-    : INHERITED(offset, InterfaceBlockData{var, std::move(typeName), std::move(instanceName),
-                                           std::move(typeOwner)}) {
+    : INHERITED(offset, kProgramElementKind)
+    , fVariable(var)
+    , fTypeName(std::move(typeName))
+    , fInstanceName(std::move(instanceName))
+    , fTypeOwner(std::move(typeOwner)) {
         fExpressionChildren.move_back_n(sizes.size(), sizes.data());
     }
 
     const Variable& variable() const {
-        return *this->interfaceBlockData().fVariable;
+        return *fVariable;
     }
 
     void setVariable(const Variable* var) {
-        this->interfaceBlockData().fVariable = var;
+        fVariable = var;
     }
 
     const String& typeName() const {
-        return this->interfaceBlockData().fTypeName;
+        return fTypeName;
     }
 
     const String& instanceName() const {
-        return this->interfaceBlockData().fInstanceName;
+        return fInstanceName;
     }
 
     const std::shared_ptr<SymbolTable>& typeOwner() const {
-        return this->interfaceBlockData().fTypeOwner;
+        return fTypeOwner;
     }
 
     ExpressionArray& sizes() {
         return fExpressionChildren;
     }
 
     const ExpressionArray& sizes() const {
         return fExpressionChildren;
     }
 
     std::unique_ptr<ProgramElement> clone() const override {
         ExpressionArray sizesClone;
         sizesClone.reserve_back(this->sizes().size());
         for (const auto& size : this->sizes()) {
             sizesClone.push_back(size ? size->clone() : nullptr);
         }
         return std::make_unique<InterfaceBlock>(fOffset, &this->variable(), this->typeName(),
                                                 this->instanceName(), std::move(sizesClone),
                                                 SymbolTable::WrapIfBuiltin(this->typeOwner()));
     }
 
     String description() const override {
         String result = this->variable().modifiers().description() + this->typeName() + " {\n";
         const Type* structType = &this->variable().type();
         while (structType->typeKind() == Type::TypeKind::kArray) {
             structType = &structType->componentType();
         }
         for (const auto& f : structType->fields()) {
             result += f.description() + "\n";
         }
         result += "}";
         if (this->instanceName().size()) {
             result += " " + this->instanceName();
             for (const auto& size : this->sizes()) {
                 result += "[";
                 if (size) {
                     result += size->description();
                 }
                 result += "]";
             }
         }
         return result + ";";
     }
 
+private:
+    const Variable* fVariable;
+    String fTypeName;
+    String fInstanceName;
+    std::shared_ptr<SymbolTable> fTypeOwner;
+
     using INHERITED = ProgramElement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLProgramElement.h b/src/sksl/ir/SkSLProgramElement.h
index 6dd4fcc26b..27997a2950 100644
--- a/src/sksl/ir/SkSLProgramElement.h
+++ b/src/sksl/ir/SkSLProgramElement.h
@@ -21,68 +21,56 @@ class ProgramElement : public IRNode {
 public:
     enum class Kind {
         kEnum = 0,
         kExtension,
         kFunction,
         kInterfaceBlock,
         kModifiers,
         kSection,
         kGlobalVar,
 
         kFirst = kEnum,
         kLast = kGlobalVar
     };
 
     ProgramElement(int offset, Kind kind)
     : INHERITED(offset, (int) kind) {
         SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
     }
 
-    ProgramElement(int offset, const EnumData& data)
-    : INHERITED(offset, (int) Kind::kEnum, data) {}
-
-    ProgramElement(int offset, const FunctionDefinitionData& data)
-    : INHERITED(offset, (int) Kind::kFunction, data) {}
-
-    ProgramElement(int offset, const InterfaceBlockData& data)
-    : INHERITED(offset, (int) Kind::kInterfaceBlock, data) {}
-
     ProgramElement(int offset, const ModifiersDeclarationData& data)
     : INHERITED(offset, (int) Kind::kModifiers, data) {}
 
     ProgramElement(int offset, Kind kind, const String& data)
     : INHERITED(offset, (int) kind, data) {
         SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
     }
 
-    ProgramElement(int offset, const SectionData& data)
-    : INHERITED(offset, (int) Kind::kSection, data) {}
-
     Kind kind() const {
         return (Kind) fKind;
     }
 
     /**
      *  Use is<T> to check the type of a program element.
      *  e.g. replace `el.kind() == ProgramElement::Kind::kEnum` with `el.is<Enum>()`.
      */
     template <typename T>
     bool is() const {
         return this->kind() == T::kProgramElementKind;
     }
 
     /**
      *  Use as<T> to downcast program elements. e.g. replace `(Enum&) el` with `el.as<Enum>()`.
      */
     template <typename T>
     const T& as() const {
         SkASSERT(this->is<T>());
         return static_cast<const T&>(*this);
     }
 
     template <typename T>
     T& as() {
         SkASSERT(this->is<T>());
         return static_cast<T&>(*this);
     }
 
     virtual std::unique_ptr<ProgramElement> clone() const = 0;
diff --git a/src/sksl/ir/SkSLSection.h b/src/sksl/ir/SkSLSection.h
index ee26f827b1..3080b0093b 100644
--- a/src/sksl/ir/SkSLSection.h
+++ b/src/sksl/ir/SkSLSection.h
@@ -15,41 +15,50 @@ namespace SkSL {
 /**
  * A section declaration (e.g. @body { body code here })..
  */
-struct Section : public ProgramElement {
+class Section : public ProgramElement {
+public:
     static constexpr Kind kProgramElementKind = Kind::kSection;
 
     Section(int offset, String name, String arg, String text)
-    : INHERITED(offset, SectionData{std::move(name), std::move(arg), std::move(text)}) {}
+    : INHERITED(offset, kProgramElementKind)
+    , fName(std::move(name))
+    , fArgument(std::move(arg))
+    , fText(std::move(text)) {}
 
     const String& name() const {
-        return this->sectionData().fName;
+        return fName;
     }
 
     const String& argument() const {
-        return this->sectionData().fArgument;
+        return fArgument;
     }
 
     const String& text() const {
-        return this->sectionData().fText;
+        return fText;
     }
 
     std::unique_ptr<ProgramElement> clone() const override {
         return std::unique_ptr<ProgramElement>(new Section(fOffset, this->name(), this->argument(),
                                                            this->text()));
     }
 
     String description() const override {
         String result = "@" + this->name();
         if (this->argument().size()) {
             result += "(" + this->argument() + ")";
         }
         result += " { " + this->text() + " }";
         return result;
     }
 
+private:
+    String fName;
+    String fArgument;
+    String fText;
+
     using INHERITED = ProgramElement;
 };
 
 }  // namespace SkSL
 
 #endif
diff --git a/src/sksl/ir/SkSLSymbol.h b/src/sksl/ir/SkSLSymbol.h
index f54e8f9c72..8ca599bbe1 100644
--- a/src/sksl/ir/SkSLSymbol.h
+++ b/src/sksl/ir/SkSLSymbol.h
@@ -20,73 +20,64 @@ class Symbol : public IRNode {
 public:
     enum class Kind {
         kExternal = (int) ProgramElement::Kind::kLast + 1,
         kField,
         kFunctionDeclaration,
         kSymbolAlias,
         kType,
         kUnresolvedFunction,
         kVariable,
 
         kFirst = kExternal,
         kLast = kVariable
     };
 
     Symbol(int offset, Kind kind, StringFragment name, const Type* type = nullptr)
     : INHERITED(offset, (int) kind, SymbolData{name, type}) {
         SkASSERT(kind >= Kind::kFirst && kind <= Kind::kLast);
     }
 
-    Symbol(int offset, const FieldData& data)
-    : INHERITED(offset, (int) Kind::kField, data) {}
-
-    Symbol(int offset, const FunctionDeclarationData& data)
-    : INHERITED(offset, (int) Kind::kFunctionDeclaration, data) {}
-
     Symbol(int offset, const SymbolAliasData& data)
     : INHERITED(offset, (int) Kind::kSymbolAlias, data) {}
 
     Symbol(int offset, const UnresolvedFunctionData& data)
     : INHERITED(offset, (int) Kind::kUnresolvedFunction, data) {}
 
-    Symbol(int offset, const VariableData& data)
-    : INHERITED(offset, (int) Kind::kVariable, data) {}
-
     Symbol& operator=(const Symbol&) = default;
 
     ~Symbol() override {}
 
     virtual const Type& type() const {
         return *this->symbolData().fType;
     }
 
     Kind kind() const {
         return (Kind) fKind;
     }
 
     virtual StringFragment name() const {
         return this->symbolData().fName;
     }
 
     /**
      *  Use is<T> to check the type of a symbol.
      *  e.g. replace `sym.kind() == Symbol::Kind::kVariable` with `sym.is<Variable>()`.
      */
     template <typename T>
     bool is() const {
         return this->kind() == T::kSymbolKind;
     }
 
     /**
      *  Use as<T> to downcast symbols. e.g. replace `(Variable&) sym` with `sym.as<Variable>()`.
      */
     template <typename T>
     const T& as() const {
         SkASSERT(this->is<T>());
         return static_cast<const T&>(*this);
     }
 
     template <typename T>
     T& as() {
         SkASSERT(this->is<T>());
         return static_cast<T&>(*this);
     }
diff --git a/src/sksl/ir/SkSLVariable.h b/src/sksl/ir/SkSLVariable.h
index a928142319..7e6d3e99cc 100644
--- a/src/sksl/ir/SkSLVariable.h
+++ b/src/sksl/ir/SkSLVariable.h
@@ -34,55 +34,56 @@ class Variable : public Symbol {
 public:
     using Storage = VariableStorage;
 
     static constexpr Kind kSymbolKind = Kind::kVariable;
 
     Variable(int offset, ModifiersPool::Handle modifiers, StringFragment name, const Type* type,
              bool builtin, Storage storage, const Expression* initialValue = nullptr)
-    : INHERITED(offset, VariableData{name, type, initialValue, modifiers, storage, builtin}) {}
-
-    const Type& type() const override {
-        return *this->variableData().fType;
-    }
+    : INHERITED(offset, kSymbolKind, name, type)
+    , fInitialValue(initialValue)
+    , fModifiersHandle(modifiers)
+    , fStorage(storage)
+    , fBuiltin(builtin) {}
 
     const Modifiers& modifiers() const {
-        return *this->variableData().fModifiersHandle;
+        return *fModifiersHandle;
     }
 
     const ModifiersPool::Handle& modifiersHandle() const {
-        return this->variableData().fModifiersHandle;
+        return fModifiersHandle;
     }
 
     bool isBuiltin() const {
-        return this->variableData().fBuiltin;
+        return fBuiltin;
     }
 
     Storage storage() const {
-        return (Storage) this->variableData().fStorage;
+        return (Storage) fStorage;
     }
 
     const Expression* initialValue() const {
-        return this->variableData().fInitialValue;
+        return fInitialValue;
     }
 
     void setInitialValue(const Expression* initialValue) {
         SkASSERT(!this->initialValue());
-        this->variableData().fInitialValue = initialValue;
-    }
-
-    StringFragment name() const override {
-        return this->variableData().fName;
+        fInitialValue = initialValue;
     }
 
     String description() const override {
         return this->modifiers().description() + this->type().name() + " " + this->name();
     }
 
 private:
+    const Expression* fInitialValue = nullptr;
+    ModifiersPool::Handle fModifiersHandle;
+    VariableStorage fStorage;
+    bool fBuiltin;
+
     using INHERITED = Symbol;
 
     friend class VariableReference;
 };
 
 } // namespace SkSL
 
 #endif
