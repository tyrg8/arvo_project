commit b70ad0e2f19aa1d6f4b3b64208e14c6e5839d60a
Author: Roberto AGOSTINO <roberto.agostino@sistemiditlc.it>
Date:   Wed Feb 3 10:28:51 2021 +0100

    fragments management added (#1122)
    
    Management of tcp segments managements.
    
    Co-authored-by: ragostino <ragostino73@gmail.com>
    Co-authored-by: Luca Deri <lucaderi@users.noreply.github.com>

diff --git a/configure.seed b/configure.seed
index 1e65e047..2533aa82 100644
--- a/configure.seed
+++ b/configure.seed
@@ -214,9 +214,12 @@ if test "${with_pcre+set}" = set; then :
   AC_CHECK_LIB(pcre, pcre_compile, AC_DEFINE_UNQUOTED(HAVE_PCRE, 1, [libpcre(-dev) is present]))
   if test "x$ac_cv_lib_pcre_pcre_compile" = xyes; then :
     ADDITIONAL_LIBS="${ADDITIONAL_LIBS} -lpcre"
   fi
 fi
 
+# TCP segments management (buffer, sort and reassembly the segments)
+FRAG_MAN_ENABLED=1
+AC_DEFINE_UNQUOTED(FRAG_MAN, ${FRAG_MAN_ENABLED}, [Enable the TCP segments fragmentation management])
 
 AC_CONFIG_FILES([Makefile example/Makefile example/Makefile.dpdk tests/Makefile tests/unit/Makefile tests/dga/Makefile libndpi.pc src/include/ndpi_define.h src/lib/Makefile python/Makefile fuzz/Makefile src/include/ndpi_api.h])
 AC_CONFIG_FILES([tests/do.sh], [chmod +x tests/do.sh])
@@ -241,4 +244,5 @@ AC_SUBST(JSONC_CFLAGS)
 AC_SUBST(JSONC_LIBS)
 AC_SUBST(GCRYPT_ENABLED)
 AC_SUBST(GNU_PREFIX)
+AC_SUBST(FRAG_MAN_ENABLED)
 AC_OUTPUT
diff --git a/src/include/ndpi_typedefs.h b/src/include/ndpi_typedefs.h
index 35811c63..79c8b6c7 100644
--- a/src/include/ndpi_typedefs.h
+++ b/src/include/ndpi_typedefs.h
@@ -1,32 +1,33 @@
 /*
  * ndpi_typedefs.h
  *
  * Copyright (C) 2011-21 - ntop.org
  *
  * This file is part of nDPI, an open source deep packet inspection
  * library based on the OpenDPI and PACE technology by ipoque GmbH
  *
  * nDPI is free software: you can redistribute it and/or modify
  * it under the terms of the GNU Lesser General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * nDPI is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with nDPI.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #ifndef __NDPI_TYPEDEFS_H__
 #define __NDPI_TYPEDEFS_H__
 
 #include "ndpi_define.h"
 #include "ndpi_protocol_ids.h"
 
+#include "ndpi_utils.h"
 /* NDPI_LOG_LEVEL */
 typedef enum {
 	      NDPI_LOG_ERROR,
@@ -423,13 +424,19 @@ PACK_ON
 struct ndpi_vxlanhdr {
   u_int16_t flags;
   u_int16_t groupPolicy;
   u_int32_t vni;
 } PACK_OFF;
 
 /* ************************************************************ */
 /* ******************* ********************* ****************** */
 /* ************************************************************ */
 
+typedef struct message {
+  u_int8_t *buffer;
+  u_int buffer_len, buffer_used, max_expected;
+  u_int32_t next_seq[2]; /* Directions */
+} message_t;
+
 /* NDPI_PROTOCOL_BITTORRENT */
 typedef struct spinlock {
   volatile int    val;
@@ -596,153 +603,151 @@ struct ndpi_id_struct {
 struct ndpi_flow_tcp_struct {
   /* NDPI_PROTOCOL_MAIL_SMTP */
   u_int16_t smtp_command_bitmask;
 
   /* NDPI_PROTOCOL_MAIL_POP */
   u_int16_t pop_command_bitmask;
 
   /* NDPI_PROTOCOL_QQ */
   u_int16_t qq_nxt_len;
 
   /* NDPI_PROTOCOL_WHATSAPP */
   u_int8_t wa_matched_so_far;
 
   /* NDPI_PROTOCOL_TDS */
   u_int8_t tds_login_version;
 
   /* NDPI_PROTOCOL_IRC */
   u_int8_t irc_stage;
   u_int8_t irc_port;
 
   /* NDPI_PROTOCOL_H323 */
   u_int8_t h323_valid_packets;
 
   /* NDPI_PROTOCOL_GNUTELLA */
   u_int8_t gnutella_msg_id[3];
 
   /* NDPI_PROTOCOL_IRC */
   u_int32_t irc_3a_counter:3;
   u_int32_t irc_stage2:5;
   u_int32_t irc_direction:2;
   u_int32_t irc_0x1000_full:1;
 
   /* NDPI_PROTOCOL_SOULSEEK */
   u_int32_t soulseek_stage:2;
 
   /* NDPI_PROTOCOL_TDS */
   u_int32_t tds_stage:3;
 
   /* NDPI_PROTOCOL_USENET */
   u_int32_t usenet_stage:2;
 
   /* NDPI_PROTOCOL_IMESH */
   u_int32_t imesh_stage:4;
 
   /* NDPI_PROTOCOL_HTTP */
   u_int32_t http_setup_dir:2;
   u_int32_t http_stage:2;
   u_int32_t http_empty_line_seen:1;
   u_int32_t http_wait_for_retransmission:1;
 
   /* NDPI_PROTOCOL_GNUTELLA */
   u_int32_t gnutella_stage:2;		       // 0 - 2
 
   /* NDPI_CONTENT_MMS */
   u_int32_t mms_stage:2;
 
   /* NDPI_PROTOCOL_YAHOO */
   u_int32_t yahoo_sip_comm:1;
   u_int32_t yahoo_http_proxy_stage:2;
 
   /* NDPI_PROTOCOL_MSN */
   u_int32_t msn_stage:3;
   u_int32_t msn_ssl_ft:2;
 
   /* NDPI_PROTOCOL_SSH */
   u_int32_t ssh_stage:3;
 
   /* NDPI_PROTOCOL_VNC */
   u_int32_t vnc_stage:2;			// 0 - 3
 
   /* NDPI_PROTOCOL_TELNET */
   u_int32_t telnet_stage:2;			// 0 - 2
 
   struct {
-    struct {
-      u_int8_t *buffer;
-      u_int buffer_len, buffer_used;
-      u_int32_t next_seq[2]; /* Directions */
-    } message;
+    message_t message;
+    
+    void* srv_cert_fingerprint_ctx; /* SHA-1 */
   
     /* NDPI_PROTOCOL_TLS */
     u_int8_t hello_processed:1, certificate_processed:1, subprotocol_detected:1,
 	fingerprint_set:1, _pad:4;
     u_int8_t num_tls_blocks;
     int16_t tls_application_blocks_len[NDPI_MAX_NUM_TLS_APPL_BLOCKS]; /* + = src->dst, - = dst->src */
   } tls;
   
   /* NDPI_PROTOCOL_POSTGRES */
   u_int32_t postgres_stage:3;
 
   /* NDPI_PROTOCOL_DIRECT_DOWNLOAD_LINK */
   u_int32_t ddlink_server_direction:1;
   u_int32_t seen_syn:1;
   u_int32_t seen_syn_ack:1;
   u_int32_t seen_ack:1;
 
   /* NDPI_PROTOCOL_ICECAST */
   u_int32_t icecast_stage:1;
 
   /* NDPI_PROTOCOL_DOFUS */
   u_int32_t dofus_stage:1;
 
   /* NDPI_PROTOCOL_FIESTA */
   u_int32_t fiesta_stage:2;
 
   /* NDPI_PROTOCOL_WORLDOFWARCRAFT */
   u_int32_t wow_stage:2;
 
   /* NDPI_PROTOCOL_HTTP_APPLICATION_VEOHTV */
   u_int32_t veoh_tv_stage:2;
 
   /* NDPI_PROTOCOL_SHOUTCAST */
   u_int32_t shoutcast_stage:2;
 
   /* NDPI_PROTOCOL_RTP */
   u_int32_t rtp_special_packets_seen:1;
 
   /* NDPI_PROTOCOL_MAIL_POP */
   u_int32_t mail_pop_stage:2;
 
   /* NDPI_PROTOCOL_MAIL_IMAP */
   u_int32_t mail_imap_stage:3, mail_imap_starttls:2;
 
   /* NDPI_PROTOCOL_SOAP */
   u_int32_t soap_stage:1;
 
   /* NDPI_PROTOCOL_SKYPE */
   u_int8_t skype_packet_id;
 
   /* NDPI_PROTOCOL_CITRIX */
   u_int8_t citrix_packet_id;
 
   /* NDPI_PROTOCOL_LOTUS_NOTES */
   u_int8_t lotus_notes_packet_id;
 
   /* NDPI_PROTOCOL_TEAMVIEWER */
   u_int8_t teamviewer_stage;
 
   /* NDPI_PROTOCOL_ZMQ */
   u_int8_t prev_zmq_pkt_len;
   u_char prev_zmq_pkt[10];
 
   /* NDPI_PROTOCOL_PPSTREAM */
   u_int32_t ppstream_stage:3;
 
   /* NDPI_PROTOCOL_MEMCACHED */
   u_int8_t memcached_matches;
 
   /* NDPI_PROTOCOL_NEST_LOG_SINK */
   u_int8_t nest_log_sink_matches;
 };
 
 /* ************************************************** */
@@ -1165,236 +1170,247 @@ typedef enum {
 /*
   NOTE
   When the struct below is modified don't forget to update
   - ndpi_flow_struct (in python/ndpi.py)
  */
 struct ndpi_flow_struct {
   u_int16_t detected_protocol_stack[NDPI_PROTOCOL_SIZE];
   u_int16_t protocol_stack_info;
 
   /* init parameter, internal used to set up timestamp,... */
   u_int16_t guessed_protocol_id, guessed_host_protocol_id, guessed_category, guessed_header_category;
   u_int8_t l4_proto, protocol_id_already_guessed:1, host_already_guessed:1, fail_with_unknown:1,
     init_finished:1, setup_packet_direction:1, packet_direction:1, check_extra_packets:1;
 
   /*
     if ndpi_struct->direction_detect_disable == 1
     tcp sequence number connection tracking
   */
   u_int32_t next_tcp_seq_nr[2];
 
+#ifdef FRAG_MAN
+  /* tcp_segments lists */
+  u_int8_t tcp_segments_management:1;
+  u_int8_t not_sorted[2],must_free[2];     // 0: client->server and 1: server->client
+  uint32_t trigger[2];                     // the seq waited number to start to reassembly
+  fragments_wrapper_t tcp_segments_list[2];
+#endif // FRAG_MAN
+
+  // -----------------------------------------
+
   u_int8_t max_extra_packets_to_check;
   u_int8_t num_extra_packets_checked;
-  u_int8_t num_processed_pkts; /* <= WARNING it can wrap but we do expect people to giveup earlier */
+  u_int16_t num_processed_pkts; /* <= WARNING it can wrap but we do expect people to giveup earlier */
 
   int (*extra_packets_func) (struct ndpi_detection_module_struct *, struct ndpi_flow_struct *flow);
 
   /*
     the tcp / udp / other l4 value union
     used to reduce the number of bytes for tcp or udp protocol states
   */
   union {
     struct ndpi_flow_tcp_struct tcp;
     struct ndpi_flow_udp_struct udp;
   } l4;
 
   /* Place textual flow info here */
   char flow_extra_info[16];
   
   /*
     Pointer to src or dst that identifies the
     server of this connection
   */
   struct ndpi_id_struct *server_id;
   /* HTTP host or DNS query */
   u_char host_server_name[240];
   u_int8_t initial_binary_bytes[8], initial_binary_bytes_len;
   u_int8_t risk_checked;
   ndpi_risk risk; /* Issues found with this flow [bitmask of ndpi_risk] */
   
   /*
     This structure below will not not stay inside the protos
     structure below as HTTP is used by many subprotocols
     such as FaceBook, Google... so it is hard to know
     when to use it or not. Thus we leave it outside for the
     time being.
   */
   struct {
     ndpi_http_method method;
     char *url, *content_type /* response */, *request_content_type /* e.g. for POST */, *user_agent;
     u_int8_t num_request_headers, num_response_headers;
     u_int8_t request_version; /* 0=1.0 and 1=1.1. Create an enum for this? */
     u_int16_t response_status_code; /* 200, 404, etc. */
   } http;
 
   /* 
      Put outside of the union to avoid issues in case the protocol
      is remapped to somethign pther than Kerberos due to a faulty
      dissector
   */
   struct {    
     char *pktbuf;
     u_int16_t pktbuf_maxlen, pktbuf_currlen;
   } kerberos_buf;
 
   union {
     /* the only fields useful for nDPI and ntopng */
     struct {
       u_int8_t num_queries, num_answers, reply_code, is_query;
       u_int16_t query_type, query_class, rsp_type;
       ndpi_ip_addr_t rsp_addr; /* The first address in a DNS response packet */
     } dns;
 
     struct {
       u_int8_t request_code;
       u_int8_t version;
     } ntp;
 
     struct {
       char hostname[48], domain[48], username[48];
     } kerberos;
 
     struct {
       struct {
         char ssl_version_str[12];
 	u_int16_t ssl_version, server_names_len;
 	char client_requested_server_name[256], /* SNI hostname length: RFC 4366 */
 	  *server_names, *alpn, *tls_supported_versions, *issuerDN, *subjectDN;
 	u_int32_t notBefore, notAfter;
 	char ja3_client[33], ja3_server[33];
 	u_int16_t server_cipher;
 	u_int8_t sha1_certificate_fingerprint[20];
 	
 	struct {
 	  u_int16_t cipher_suite;
 	  char *esni;
 	} encrypted_sni;
 	ndpi_cipher_weakness server_unsafe_cipher;
       } tls_quic;
 
       struct {
-	u_int8_t num_udp_pkts, num_processed_pkts, num_binding_requests;
+		    u_int8_t num_udp_pkts, num_binding_requests;
+        u_int16_t num_processed_pkts;
       } stun;
 
       /* We can have STUN over SSL/TLS thus they need to live together */
     } tls_quic_stun;
 
     struct {
       char client_signature[48], server_signature[48];
       char hassh_client[33], hassh_server[33];
     } ssh;
 
     struct {
       u_int8_t last_one_byte_pkt, last_byte;
     } imo;
     
     struct {
       u_int8_t username_detected:1, username_found:1,
 	password_detected:1, password_found:1,
 	_pad:4;
       u_int8_t character_id;
       char username[32], password[32];
     } telnet;
     
     struct {
       char version[32];
     } ubntac2;
 
     struct {
       /* Via HTTP User-Agent */
       u_char detected_os[32];
       /* Via HTTP X-Forwarded-For */
       u_char nat_ip[24];
     } http;
 
     struct {
       u_int8_t auth_found:1, auth_failed:1, _pad:5;
       char username[16], password[16];
     } ftp_imap_pop_smtp;
   
     struct {
       /* Bittorrent hash */
       u_char hash[20];
     } bittorrent;
 
     struct {
       char fingerprint[48];
       char class_ident[48];
     } dhcp;
   } protos;
 
   /*** ALL protocol specific 64 bit variables here ***/
 
   /* protocols which have marked a connection as this connection cannot be protocol XXX, multiple u_int64_t */
   NDPI_PROTOCOL_BITMASK excluded_protocol_bitmask;
 
   ndpi_protocol_category_t category;
 
   /* NDPI_PROTOCOL_REDIS */
   u_int8_t redis_s2d_first_char, redis_d2s_first_char;
 
   u_int16_t packet_counter;		      // can be 0 - 65000
   u_int16_t packet_direction_counter[2];
   u_int16_t byte_counter[2];
   /* NDPI_PROTOCOL_BITTORRENT */
   u_int8_t bittorrent_stage;		      // can be 0 - 255
 
   /* NDPI_PROTOCOL_DIRECTCONNECT */
   u_int8_t directconnect_stage:2;	      // 0 - 1
 
   /* NDPI_PROTOCOL_HTTP */
   u_int8_t http_detected:1;
 
   /* NDPI_PROTOCOL_RTSP */
   u_int8_t rtsprdt_stage:2, rtsp_control_flow:1;
 
   /* NDPI_PROTOCOL_YAHOO */
   u_int8_t yahoo_detection_finished:2;
 
   /* NDPI_PROTOCOL_ZATTOO */
   u_int8_t zattoo_stage:3;
 
   /* NDPI_PROTOCOL_QQ */
   u_int8_t qq_stage:3;
 
   /* NDPI_PROTOCOL_THUNDER */
   u_int8_t thunder_stage:2;		        // 0 - 3
 
   /* NDPI_PROTOCOL_FLORENSIA */
   u_int8_t florensia_stage:1;
 
   /* NDPI_PROTOCOL_SOCKS */
   u_int8_t socks5_stage:2, socks4_stage:2;      // 0 - 3
 
   /* NDPI_PROTOCOL_EDONKEY */
   u_int8_t edonkey_stage:2;	                // 0 - 3
 
   /* NDPI_PROTOCOL_FTP_CONTROL */
   u_int8_t ftp_control_stage:2;
 
   /* NDPI_PROTOCOL_RTMP */
   u_int8_t rtmp_stage:2;
 
   /* NDPI_PROTOCOL_STEAM */
   u_int16_t steam_stage:3, steam_stage1:3, steam_stage2:2, steam_stage3:2;
 
   /* NDPI_PROTOCOL_STARCRAFT */
   u_int8_t starcraft_udp_stage : 3;	// 0-7
 
   /* NDPI_PROTOCOL_OPENVPN */
   u_int8_t ovpn_session_id[8];
   u_int8_t ovpn_counter;
 
   /* NDPI_PROTOCOL_TINC */
   u_int8_t tinc_state;
   struct tinc_cache_entry tinc_cache_entry;
 
   /* NDPI_PROTOCOL_CSGO */
   u_int8_t csgo_strid[18],csgo_state,csgo_s2;
   u_int32_t csgo_id2;
   
   /* internal structures to save functions calls */
   struct ndpi_packet_struct packet;
   struct ndpi_flow_struct *flow;
   struct ndpi_id_struct *src;
   struct ndpi_id_struct *dst;
 };
diff --git a/src/include/ndpi_utils.h b/src/include/ndpi_utils.h
new file mode 100644
index 00000000..296bd625
--- /dev/null
+++ b/src/include/ndpi_utils.h
@@ -0,0 +1,74 @@
+
+
+#ifndef __NDPI_UTILS_H__
+#define __NDPI_UTILS_H__
+
+#include "ndpi_define.h"
+
+#define MYDBG(m, ...) \
+	printf(" DBG[%s:%s:%u]: \t" m "\n", __FILE__, __FUNCTION__, __LINE__, ##__VA_ARGS__);
+
+
+// #define NDPI_ENABLE_DEBUG_POINTER_MESSAGES
+// #define NDPI_ENABLE_DEBUG_INFO_MESSAGES
+// #define NDPI_ENABLE_DEBUG_TRACE_MESSAGES
+
+#ifdef NDPI_ENABLE_DEBUG_POINTER_MESSAGES
+#define DBGPOINTER(m, args...) MYDBG(m, ##args)
+#else
+#define DBGPOINTER(m, args...) 
+#endif
+
+#ifdef NDPI_ENABLE_DEBUG_INFO_MESSAGES
+#define DBGINFO(m, args...) MYDBG(m, ##args)
+#else
+#define DBGINFO(m, args...) 
+#endif
+
+#ifdef NDPI_ENABLE_DEBUG_TRACE_MESSAGES
+#define DBGTRACER(m, args...) MYDBG(m, ##args)
+#else
+#define DBGTRACER(m, args...) 
+#endif
+
+// FRAGMENTATION
+typedef struct {
+    uint32_t offset;
+    size_t len;
+    void *data;    
+} fragment_t;
+
+typedef struct fragment_wrapper {
+     uint16_t id;
+     uint8_t l4_protocol;
+     uint32_t initial_offset;
+     uint16_t ct_frag;
+#ifdef NDPI_DETECTION_SUPPORT_IPV6     
+     char   *flow_label;    // IP6
+#endif
+     char gap[200];
+     fragment_t **fragments_list;
+} fragments_wrapper_t;
+
+typedef struct fragments_buffer  {
+    u_int8_t *buffer;
+    u_int buffer_len, buffer_used;
+} fragments_buffer_t;
+
+// SORTING 
+typedef struct  {
+	int sort_value;
+	int item_index;
+} sorter_index_item_t;
+
+/* ***************************************************** */
+
+extern void ins_sort_array(sorter_index_item_t arr[], int len);
+extern void shell_sort_array(sorter_index_item_t arr[], int len);
+extern void free_fragment(fragments_wrapper_t *frag);
+
+extern void printRawData(const uint8_t *ptr, size_t len);
+//extern uint8_t add_segment_to_buffer( struct ndpi_flow_struct *flow, struct ndpi_tcphdr const * tcph, uint32_t waited);
+//extern uint8_t check_for_sequence( struct ndpi_flow_struct *flow, struct ndpi_tcphdr const * tcph);
+
+#endif
diff --git a/src/lib/ndpi_main.c b/src/lib/ndpi_main.c
index 4ca4bf41..eb883d67 100644
--- a/src/lib/ndpi_main.c
+++ b/src/lib/ndpi_main.c
@@ -66,6 +66,11 @@ static void (*_ndpi_flow_free)(void *ptr);
 static void *(*_ndpi_malloc)(size_t size);
 static void (*_ndpi_free)(void *ptr);
 
+#ifdef FRAG_MAN
+extern void add_segment_to_buffer( struct ndpi_flow_struct *flow, struct ndpi_tcphdr const * tcph);
+extern uint8_t check_for_sequence( struct ndpi_flow_struct *flow, struct ndpi_tcphdr const * tcph);
+#endif // FRAG_MAN
+
 /* ****************************************** */
 
 /* Forward */
@@ -3490,100 +3495,169 @@ int ndpi_handle_ipv6_extension_headers(struct ndpi_detection_module_struct *ndpi
 #endif /* NDPI_DETECTION_SUPPORT_IPV6 */
 
 static u_int8_t ndpi_iph_is_valid_and_not_fragmented(const struct ndpi_iphdr *iph, const u_int16_t ipsize) {
+
+  #ifdef FRAG_MAN
+  /*
+    the logic has been inverted!!! returned value:
+      0: not fragmented (instead of fragmented)
+      1: packet too small
+      2: fragmented and last, reassemble
+      3: fragmented but not the last, add to buffer
+  */
+  u_int16_t tot_len = ntohs(iph->tot_len);
+  if ( ipsize < iph->ihl * 4 || ipsize < tot_len || tot_len < iph->ihl * 4 ) 
+    // packet too small
+    return(1);
+  else if ((iph->frag_off & htons(0x2000)) != 0) {
+    // MF=1 : this is a fragment and not the last -> add to buffer
+    //printf("DBG(ndpi_iph_is_valid_and_not_fragmented): ipv4 fragment and not the last! (off=%u) \n", (htons(iph->frag_off) & 0x1FFF)<<3);
+    
+    // MUST add to buffer
+    return(3);
+  } else if ((iph->frag_off & htons(0x1FFF)) != 0) {
+    // MF=0, this is (a fragment, but) the last fragment!
+    //printf("DBG(ndpi_iph_is_valid_and_not_fragmented): ipv4 fragment and the last! (0ff=%u) \n", (htons(iph->frag_off) & 0x1FFF)<<3);
+
+    // MUST to reassemble the packet!
+    return(2);
+  }
+  return (0);
+
+#else // FRAG_MAN
+ /*
+    returned value:
+      0: fragmented 
+      1: not fragmented
+  */
   //#ifdef REQUIRE_FULL_PACKETS
   if(ipsize < iph->ihl * 4 || ipsize < ntohs(iph->tot_len) || ntohs(iph->tot_len) < iph->ihl * 4 ||
      (iph->frag_off & htons(0x1FFF)) != 0) {
     return(0);
   }
   //#endif
 
   return(1);
+  
+#endif // FRAG_MAN
 }
 
+/*
+extract the l4 payload, if available
+returned value:
+FRAG_MAN
+  0: ok, extracted
+  1: packet too small
+  2,3: fragmented, ....
+else
+  0: ok, extracted
+  1: error or not available
+*/
 static u_int8_t ndpi_detection_get_l4_internal(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t *l3,
                                                u_int16_t l3_len, const u_int8_t **l4_return, u_int16_t *l4_len_return,
                                                u_int8_t *l4_protocol_return, u_int32_t flags) {
   const struct ndpi_iphdr *iph = NULL;
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
   const struct ndpi_ipv6hdr *iph_v6 = NULL;
 #endif
   u_int16_t l4len = 0;
   const u_int8_t *l4ptr = NULL;
   u_int8_t l4protocol = 0;
 
   if(l3 == NULL || l3_len < sizeof(struct ndpi_iphdr))
     return(1);
 
   if((iph = (const struct ndpi_iphdr *) l3) == NULL)
     return(1);
 
   if(iph->version == IPVERSION && iph->ihl >= 5) {
     NDPI_LOG_DBG2(ndpi_str, "ipv4 header\n");
   }
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
   else if(iph->version == 6 && l3_len >= sizeof(struct ndpi_ipv6hdr)) {
     NDPI_LOG_DBG2(ndpi_str, "ipv6 header\n");
     iph_v6 = (const struct ndpi_ipv6hdr *) l3;
     iph = NULL;
   }
 #endif
   else {
     return(1);
   }
 
   if((flags & NDPI_DETECTION_ONLY_IPV6) && iph != NULL) {
     NDPI_LOG_DBG2(ndpi_str, "ipv4 header found but excluded by flag\n");
     return(1);
   }
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
   else if((flags & NDPI_DETECTION_ONLY_IPV4) && iph_v6 != NULL) {
     NDPI_LOG_DBG2(ndpi_str, "ipv6 header found but excluded by flag\n");
     return(1);
   }
 #endif
 
+#ifdef FRAG_MAN
+  if(iph != NULL) {
+    u_int8_t check4Frag = ndpi_iph_is_valid_and_not_fragmented(iph, l3_len);
+    /* 0: not fragmented; 1: too small; 2,3: fragmented */
+    if (!check4Frag) {
+      u_int16_t len = ntohs(iph->tot_len);
+      u_int16_t hlen = (iph->ihl * 4);
+
+      l4ptr = (((const u_int8_t *) iph) + hlen);
+
+      if(len == 0)
+        len = l3_len;
+
+      l4len = (len > hlen) ? (len - hlen) : 0;
+      l4protocol = iph->protocol;
+    } 
+    else 
+      return check4Frag; 
+  }
+#else //FRAGMAN
+  /* 0: fragmented; 1: not fragmented */
   if(iph != NULL && ndpi_iph_is_valid_and_not_fragmented(iph, l3_len)) {
     u_int16_t len = ntohs(iph->tot_len);
     u_int16_t hlen = (iph->ihl * 4);
 
     l4ptr = (((const u_int8_t *) iph) + iph->ihl * 4);
 
     if(len == 0)
       len = l3_len;
 
     l4len = (len > hlen) ? (len - hlen) : 0;
     l4protocol = iph->protocol;
   }
+#endif //FRAGMAN
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
   else if(iph_v6 != NULL && (l3_len - sizeof(struct ndpi_ipv6hdr)) >= ntohs(iph_v6->ip6_hdr.ip6_un1_plen)) {
     l4ptr = (((const u_int8_t *) iph_v6) + sizeof(struct ndpi_ipv6hdr));
     l4len = ntohs(iph_v6->ip6_hdr.ip6_un1_plen);
     l4protocol = iph_v6->ip6_hdr.ip6_un1_nxt;
 
     // we need to handle IPv6 extension headers if present
     if(ndpi_handle_ipv6_extension_headers(ndpi_str, &l4ptr, &l4len, &l4protocol) != 0) {
       return(1);
     }
 
   }
 #endif
   else {
     return(1);
   }
 
   if(l4_return != NULL) {
     *l4_return = l4ptr;
   }
 
   if(l4_len_return != NULL) {
     *l4_len_return = l4len;
   }
 
   if(l4_protocol_return != NULL) {
     *l4_protocol_return = l4protocol;
   }
 
   return(0);
 }
 
 /* ************************************************ */
@@ -3598,281 +3672,313 @@ void ndpi_apply_flow_protocol_to_packet(struct ndpi_flow_struct *flow, struct nd
 static int ndpi_init_packet_header(struct ndpi_detection_module_struct *ndpi_str,
 				   struct ndpi_flow_struct *flow,
                                    unsigned short packetlen) {
   const struct ndpi_iphdr *decaps_iph = NULL;
   u_int16_t l3len;
   u_int16_t l4len;
   const u_int8_t *l4ptr;
   u_int8_t l4protocol;
   u_int8_t l4_result;
 
   if(!flow)
     return(1);
 
   /* reset payload_packet_len, will be set if ipv4 tcp or udp */
   flow->packet.payload_packet_len = 0;
   flow->packet.l4_packet_len = 0;
   flow->packet.l3_packet_len = packetlen;
 
   flow->packet.tcp = NULL, flow->packet.udp = NULL;
   flow->packet.generic_l4_ptr = NULL;
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
   flow->packet.iphv6 = NULL;
 #endif /* NDPI_DETECTION_SUPPORT_IPV6 */
 
   ndpi_apply_flow_protocol_to_packet(flow, &flow->packet);
 
   l3len = flow->packet.l3_packet_len;
 
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
   if(flow->packet.iph != NULL) {
 #endif /* NDPI_DETECTION_SUPPORT_IPV6 */
 
     decaps_iph = flow->packet.iph;
 
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
   }
 #endif /* NDPI_DETECTION_SUPPORT_IPV6 */
 
   if(decaps_iph && decaps_iph->version == IPVERSION && decaps_iph->ihl >= 5) {
     NDPI_LOG_DBG2(ndpi_str, "ipv4 header\n");
   }
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
   else if(decaps_iph && decaps_iph->version == 6 && l3len >= sizeof(struct ndpi_ipv6hdr) &&
 	  (ndpi_str->ip_version_limit & NDPI_DETECTION_ONLY_IPV4) == 0) {
     NDPI_LOG_DBG2(ndpi_str, "ipv6 header\n");
     flow->packet.iphv6 = (struct ndpi_ipv6hdr *) flow->packet.iph;
     flow->packet.iph = NULL;
   }
 #endif
   else {
     flow->packet.iph = NULL;
     return(1);
   }
 
   /* needed:
    *  - unfragmented packets
    *  - ip header <= packet len
    *  - ip total length >= packet len
    */
 
   l4ptr = NULL;
   l4len = 0;
   l4protocol = 0;
 
   l4_result =
     ndpi_detection_get_l4_internal(ndpi_str, (const u_int8_t *) decaps_iph, l3len, &l4ptr, &l4len, &l4protocol, 0);
 
   if(l4_result != 0) {
     return(1);
   }
 
   flow->packet.l4_protocol = l4protocol;
   flow->packet.l4_packet_len = l4len;
   flow->l4_proto = l4protocol;
 
   /* tcp / udp detection */
   if(l4protocol == IPPROTO_TCP && flow->packet.l4_packet_len >= 20 /* min size of tcp */) {
     /* tcp */
     flow->packet.tcp = (struct ndpi_tcphdr *) l4ptr;
     if(flow->packet.l4_packet_len >= flow->packet.tcp->doff * 4) {
       flow->packet.payload_packet_len = flow->packet.l4_packet_len - flow->packet.tcp->doff * 4;
       flow->packet.actual_payload_len = flow->packet.payload_packet_len;
       flow->packet.payload = ((u_int8_t *) flow->packet.tcp) + (flow->packet.tcp->doff * 4);
 
       /* check for new tcp syn packets, here
        * idea: reset detection state if a connection is unknown
        */
       if(flow->packet.tcp->syn != 0 && flow->packet.tcp->ack == 0 && flow->init_finished != 0 &&
-	 flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {
-	u_int8_t backup;
-	u_int16_t backup1, backup2;
-
-	if(flow->http.url) {
-	  ndpi_free(flow->http.url);
-	  flow->http.url = NULL;
-	}
-
-	if(flow->http.content_type) {
-	  ndpi_free(flow->http.content_type);
-	  flow->http.content_type = NULL;
-	}
-
-	if(flow->http.request_content_type) {
-	  ndpi_free(flow->http.request_content_type);
-	  flow->http.request_content_type = NULL;
-	}
-
-	if(flow->http.user_agent) {
-	  ndpi_free(flow->http.user_agent);
-	  flow->http.user_agent = NULL;
-	}
-
-	if(flow->kerberos_buf.pktbuf) {
-	  ndpi_free(flow->kerberos_buf.pktbuf);
-	  flow->kerberos_buf.pktbuf = NULL;
-	}
-
-	if(flow->l4.tcp.tls.message.buffer) {
-	  ndpi_free(flow->l4.tcp.tls.message.buffer);
-	  flow->l4.tcp.tls.message.buffer = NULL;
-	  flow->l4.tcp.tls.message.buffer_len = flow->l4.tcp.tls.message.buffer_used = 0;
-	}
-
-	backup = flow->num_processed_pkts;
-	backup1 = flow->guessed_protocol_id;
-	backup2 = flow->guessed_host_protocol_id;
-	memset(flow, 0, sizeof(*(flow)));
-
-	/* Restore pointers */
-	flow->num_processed_pkts = backup;
-	flow->guessed_protocol_id = backup1;
-	flow->guessed_host_protocol_id = backup2;
-	flow->packet.tcp = (struct ndpi_tcphdr *) l4ptr;
-
-	NDPI_LOG_DBG(ndpi_str, "tcp syn packet for unknown protocol, reset detection state\n");
+	      flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {
+        
+        u_int8_t backup;
+	      u_int16_t backup1, backup2;
+
+#ifdef FRAG_MAN
+        /* initialize the buffer to manage segments for a new http/dns connection */
+        flow->tcp_segments_management=1;
+        for (int i=0; i<2; i++ ) {
+          // reset counter tcp segments management lists 
+          flow->tcp_segments_list[i].ct_frag=0;            
+        }
+#endif // FRAG_MAN
+
+        if(flow->http.url) {
+          ndpi_free(flow->http.url);
+          flow->http.url = NULL;
+        }
+
+        if(flow->http.content_type) {
+          ndpi_free(flow->http.content_type);
+          flow->http.content_type = NULL;
+        }
+
+        if(flow->http.request_content_type) {
+          ndpi_free(flow->http.request_content_type);
+          flow->http.request_content_type = NULL;
+        }
+
+        if(flow->http.user_agent) {
+          ndpi_free(flow->http.user_agent);
+          flow->http.user_agent = NULL;
+        }
+
+        if(flow->kerberos_buf.pktbuf) {
+          ndpi_free(flow->kerberos_buf.pktbuf);
+          flow->kerberos_buf.pktbuf = NULL;
+        }
+
+        if(flow->l4.tcp.tls.message.buffer) {
+          ndpi_free(flow->l4.tcp.tls.message.buffer);
+          flow->l4.tcp.tls.message.buffer = NULL;
+          flow->l4.tcp.tls.message.buffer_len = flow->l4.tcp.tls.message.buffer_used = 0;
+        }
+
+        backup = flow->num_processed_pkts;
+        backup1 = flow->guessed_protocol_id;
+        backup2 = flow->guessed_host_protocol_id;
+        memset(flow, 0, sizeof(*(flow)));
+
+        /* Restore pointers */
+        flow->num_processed_pkts = backup;
+        flow->guessed_protocol_id = backup1;
+        flow->guessed_host_protocol_id = backup2;
+        flow->packet.tcp = (struct ndpi_tcphdr *) l4ptr;
+
+        NDPI_LOG_DBG(ndpi_str, "tcp syn packet for unknown protocol, reset detection state\n");
       }
     } else {
       /* tcp header not complete */
       flow->packet.tcp = NULL;
     }
   } else if(l4protocol == IPPROTO_UDP && flow->packet.l4_packet_len >= 8 /* size of udp */) {
     flow->packet.udp = (struct ndpi_udphdr *) l4ptr;
     flow->packet.payload_packet_len = flow->packet.l4_packet_len - 8;
     flow->packet.payload = ((u_int8_t *) flow->packet.udp) + 8;
   } else if((l4protocol == IPPROTO_ICMP && flow->packet.l4_packet_len >= sizeof(struct ndpi_icmphdr))
 	    || (l4protocol == IPPROTO_ICMPV6 && flow->packet.l4_packet_len >= sizeof(struct ndpi_icmp6hdr))) {
     flow->packet.payload = ((u_int8_t *) l4ptr);
     flow->packet.payload_packet_len = flow->packet.l4_packet_len;
   } else {
     flow->packet.generic_l4_ptr = l4ptr;
   }
 
   return(0);
 }
 
 /* ************************************************ */
 
+#ifdef FRAG_MAN
+uint8_t ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,
+			      struct ndpi_flow_struct *flow) {
+#else // FRAG_MAN
 void ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,
 			      struct ndpi_flow_struct *flow) {
+#endif // FRAG_MAN
   if(!flow) {
+#ifdef FRAG_MAN
+  return 0;
+#else // FRAG_MAN      
     return;
+#endif // FRAG_MAN    
   } else {
     /* const for gcc code optimization and cleaner code */
     struct ndpi_packet_struct *packet = &flow->packet;
     const struct ndpi_iphdr *iph = packet->iph;
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
     const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;
 #endif
     const struct ndpi_tcphdr *tcph = packet->tcp;
-    const struct ndpi_udphdr *udph = flow->packet.udp;
+    const struct ndpi_udphdr *udph = packet->udp;
 
     packet->tcp_retransmission = 0, packet->packet_direction = 0;
 
     if(ndpi_str->direction_detect_disable) {
       packet->packet_direction = flow->packet_direction;
     } else {
       if(iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))
 	packet->packet_direction = 1;
 
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
       if(iphv6 != NULL && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)
 	packet->packet_direction = 1;
 #endif
     }
 
     packet->packet_lines_parsed_complete = 0;
 
     if(flow->init_finished == 0) {
       flow->init_finished = 1;
       flow->setup_packet_direction = packet->packet_direction;
     }
 
     if(tcph != NULL) {
       /* reset retried bytes here before setting it */
       packet->num_retried_bytes = 0;
 
       if(!ndpi_str->direction_detect_disable)
 	packet->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;
 
       if(tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&
 	 flow->l4.tcp.seen_ack == 0) {
 	flow->l4.tcp.seen_syn = 1;
-      }
+      } else 
       if(tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&
 	 flow->l4.tcp.seen_ack == 0) {
 	flow->l4.tcp.seen_syn_ack = 1;
-      }
+      } else
       if(tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&
 	 flow->l4.tcp.seen_ack == 0) {
 	flow->l4.tcp.seen_ack = 1;
       }
+
+#ifdef FRAG_MAN
+      // check sequence, if there is missing packet, add it to buffer
+      if ( check_for_sequence(flow, tcph) ) {
+        // if here added segment to list for next elaboration
+        // and skip extra processing for after...
+        return 0;
+      } 
+#endif //FRAG_MAN
+
       if((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||
 	 (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {
 	/* initialize tcp sequence counters */
 	/* the ack flag needs to be set to get valid sequence numbers from the other
 	 * direction. Usually it will catch the second packet syn+ack but it works
 	 * also for asymmetric traffic where it will use the first data packet
 	 *
 	 * if the syn flag is set add one to the sequence number,
 	 * otherwise use the payload length.
 	 */
 	if(tcph->ack != 0) {
 	  flow->next_tcp_seq_nr[flow->packet.packet_direction] =
 	    ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);
 
 	  flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);
 	}
       } else if(packet->payload_packet_len > 0) {
 	/* check tcp sequence counters */
 	if(((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >
 	   ndpi_str->tcp_max_retransmission_window_size) {
 	  packet->tcp_retransmission = 1;
 
 	  /* CHECK IF PARTIAL RETRY IS HAPPENING */
 	  if((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <
 	      packet->payload_packet_len)) {
 	    /* num_retried_bytes actual_payload_len hold info about the partial retry
 	       analyzer which require this info can make use of this info
 	       Other analyzer can use packet->payload_packet_len */
 	    packet->num_retried_bytes =
 	      (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));
 	    packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;
 	    flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;
 	  }
 	}
 
 	/* normal path
 	   actual_payload_len is initialized to payload_packet_len during tcp header parsing itself.
 	   It will be changed only in case of retransmission */
 	else {
 	  packet->num_retried_bytes = 0;
 	  flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;
 	}
       }
 
       if(tcph->rst) {
 	flow->next_tcp_seq_nr[0] = 0;
 	flow->next_tcp_seq_nr[1] = 0;
       }
     } else if(udph != NULL) {
       if(!ndpi_str->direction_detect_disable)
 	packet->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;
     }
 
     if(flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {
       flow->packet_counter++;
     }
 
     if(flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&
        packet->payload_packet_len) {
       flow->packet_direction_counter[packet->packet_direction]++;
     }
 
     if(flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >
        flow->byte_counter[packet->packet_direction]) {
       flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;
     }
   }
+#ifdef FRAG_MAN
+  return 1;
+#endif // FRAG_MAN
 }
 
 /* ************************************************ */
@@ -4233,41 +4339,51 @@ ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_st
 void ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,
                                const unsigned char *packet, const unsigned short packetlen,
                                const u_int64_t current_time_ms, struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {
   if(flow == NULL)
     return;
 
   if(flow->server_id == NULL)
     flow->server_id = dst; /* Default */
 
   /* need at least 20 bytes for ip header */
   if(packetlen < 20) {
     return;
   }
 
   flow->packet.current_time_ms = current_time_ms;
 
   /* parse packet */
   flow->packet.iph = (struct ndpi_iphdr *) packet;
   /* we are interested in ipv4 packet */
 
   /* set up the packet headers for the extra packet function to use if it wants */
   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)
     return;
 
   /* detect traffic for tcp or udp only */
   flow->src = src, flow->dst = dst;
+
+#ifdef FRAG_MAN
+  if ( ndpi_connection_tracking(ndpi_str, flow) ) {
+#else // FRAG_MAN
   ndpi_connection_tracking(ndpi_str, flow);
+#endif // FRAG_MAN
 
   /* call the extra packet function (which may add more data/info to flow) */
   if(flow->extra_packets_func) {
     if((flow->extra_packets_func(ndpi_str, flow)) == 0)
       flow->check_extra_packets = 0;
 
     if(++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)
       flow->extra_packets_func = NULL; /* Enough packets detected */
   }
+#ifdef FRAG_MAN
+  }
+#endif // FRAG_MAN
 }
 
+
+
 /* ********************************************************************************* */
 
 int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str, const char *ip_address_and_mask,
@@ -4600,310 +4716,323 @@ static void ndpi_reconcile_protocols(struct ndpi_detection_module_struct *ndpi_s
 ndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,
                                             struct ndpi_flow_struct *flow, const unsigned char *packet,
                                             const unsigned short packetlen, const u_int64_t current_time_ms,
                                             struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {
   NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;
   u_int32_t a, num_calls = 0;
   ndpi_protocol ret = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };
 
   if(ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)
     NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,
 	     "START packet processing\n");
 
   if(flow == NULL)
     return(ret);
   else
     ret.category = flow->category;
 
   if(flow->fail_with_unknown) {
     // printf("%s(): FAIL_WITH_UNKNOWN\n", __FUNCTION__);
     return(ret);
   }
 
   flow->num_processed_pkts++;
+#ifdef FRAG_MAN
+  flow->tcp_segments_management=1;
+#endif // FRAG_MAN
 
   /* Init default */
   ret.master_protocol = flow->detected_protocol_stack[1],
     ret.app_protocol = flow->detected_protocol_stack[0];
 
   if(flow->server_id == NULL)
     flow->server_id = dst; /* Default */
 
   if(flow->check_extra_packets) {
     ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_time_ms, src, dst);
     /* Update in case of new match */
     ret.master_protocol = flow->detected_protocol_stack[1],
     ret.app_protocol = flow->detected_protocol_stack[0],
     ret.category = flow->category;
     goto invalidate_ptr;
   } else if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)
     goto ret_protocols;
 
   /* need at least 20 bytes for ip header */
   if(packetlen < 20) {
     /* reset protocol which is normally done in init_packet_header */
     ndpi_int_reset_packet_protocol(&flow->packet);
     goto invalidate_ptr;
   }
 
   flow->packet.current_time_ms = current_time_ms;
 
   /* parse packet */
   flow->packet.iph = (struct ndpi_iphdr *) packet;
   /* we are interested in ipv4 packet */
 
   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)
     goto invalidate_ptr;
 
   /* detect traffic for tcp or udp only */
   flow->src = src, flow->dst = dst;
 
   ndpi_connection_tracking(ndpi_str, flow);
 
   /* build ndpi_selection packet bitmask */
   ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;
   if(flow->packet.iph != NULL)
     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;
 
   if(flow->packet.tcp != NULL)
     ndpi_selection_packet |=
       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);
 
   if(flow->packet.udp != NULL)
     ndpi_selection_packet |=
       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);
 
   if(flow->packet.payload_packet_len != 0)
     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;
 
   if(flow->packet.tcp_retransmission == 0)
     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;
 
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
   if(flow->packet.iphv6 != NULL)
     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;
 #endif /* NDPI_DETECTION_SUPPORT_IPV6 */
 
   if((!flow->protocol_id_already_guessed) && (
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
 					      flow->packet.iphv6 ||
 #endif
 					      flow->packet.iph)) {
     u_int16_t sport, dport;
     u_int8_t protocol;
     u_int8_t user_defined_proto;
 
     flow->protocol_id_already_guessed = 1;
 
 #ifdef NDPI_DETECTION_SUPPORT_IPV6
     if(flow->packet.iphv6 != NULL) {
       protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;
     } else
 #endif
       {
 	protocol = flow->packet.iph->protocol;
       }
 
     if(flow->packet.udp)
       sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);
     else if(flow->packet.tcp)
       sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);
     else
       sport = dport = 0;
 
     /* guess protocol */
     flow->guessed_protocol_id =
       (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);
     flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);
 
     if(ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {
       ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, &ret);
       flow->guessed_header_category = ret.category;
     } else
       flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;
 
     if(flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {
       /* This is a custom protocol and it has priority over everything else */
       ret.master_protocol = NDPI_PROTOCOL_UNKNOWN,
 	ret.app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;
       ndpi_fill_protocol_category(ndpi_str, flow, &ret);
       goto invalidate_ptr;
     }
 
     if(user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {
       if(flow->packet.iph) {
 	if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {
 	  u_int8_t protocol_was_guessed;
 
 	  /* ret.master_protocol = flow->guessed_protocol_id , ret.app_protocol = flow->guessed_host_protocol_id; /\* ****** *\/ */
 	  ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);
 	}
 
 	ndpi_fill_protocol_category(ndpi_str, flow, &ret);
 	goto invalidate_ptr;
       }
     } else {
       /* guess host protocol */
       if(flow->packet.iph) {
 
 	flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);
 
 	/*
 	  We could implement a shortcut here skipping dissectors for
 	  protocols we have identified by other means such as with the IP
 
 	  However we do NOT stop here and skip invoking the dissectors
 	  because we want to dissect the flow (e.g. dissect the TLS)
 	  and extract metadata.
 	*/
 #if SKIP_INVOKING_THE_DISSECTORS
 	if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {
 	  /*
 	    We have identified a protocol using the IP address so
 	    it is not worth to dissect the traffic as we already have
 	    the solution
 	  */
 	  ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;
 	}
 #endif
       }
     }
   }
 
   if(flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {
     /* This is a custom protocol and it has priority over everything else */
     ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;
 
     num_calls = ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);
     ndpi_fill_protocol_category(ndpi_str, flow, &ret);
     goto invalidate_ptr;
   }
 
   num_calls = ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);
 
   a = flow->packet.detected_protocol_stack[0];
   if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)
     a = NDPI_PROTOCOL_UNKNOWN;
 
   if(a != NDPI_PROTOCOL_UNKNOWN) {
     int i;
 
     for (i = 0; i < sizeof(flow->host_server_name); i++) {
       if(flow->host_server_name[i] != '\0')
 	flow->host_server_name[i] = tolower(flow->host_server_name[i]);
       else {
 	flow->host_server_name[i] = '\0';
 	break;
       }
     }
   }
 
  ret_protocols:
   if(flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {
     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];
 
     if(ret.app_protocol == ret.master_protocol)
       ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;
   } else
     ret.app_protocol = flow->detected_protocol_stack[0];
 
   /* Don't overwrite the category if already set */
   if((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))
     ndpi_fill_protocol_category(ndpi_str, flow, &ret);
   else
     ret.category = flow->category;
 
   if((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&
      (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&
      (flow->guessed_protocol_id == 0)) {
     u_int8_t protocol_was_guessed;
 
     /*
       This is a TCP flow
       - whose first packet is NOT a SYN
       - no protocol has been detected
 
       We don't see how future packets can match anything
       hence we giveup here
     */
     ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);
   }
 
   if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&
      (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {
     ret.master_protocol = ret.app_protocol;
     ret.app_protocol = flow->guessed_host_protocol_id;
   }
 
   if((!flow->risk_checked) && (ret.master_protocol != NDPI_PROTOCOL_UNKNOWN)) {
     ndpi_default_ports_tree_node_t *found;
     u_int16_t *default_ports, sport, dport;
 
     if(flow->packet.udp)
       found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_UDP,
 					   sport = ntohs(flow->packet.udp->source),
 					   dport = ntohs(flow->packet.udp->dest)),
 	default_ports = ndpi_str->proto_defaults[ret.master_protocol].udp_default_ports;
     else if(flow->packet.tcp)
       found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_TCP,
 					   sport = ntohs(flow->packet.tcp->source),
 					   dport = ntohs(flow->packet.tcp->dest)),
 	default_ports = ndpi_str->proto_defaults[ret.master_protocol].tcp_default_ports;
     else
       found = NULL, default_ports = NULL;
 
     if(found
        && (found->proto->protoId != NDPI_PROTOCOL_UNKNOWN)
        && (found->proto->protoId != ret.master_protocol)
        && (found->proto->protoId != ret.app_protocol)
        ) {
       // printf("******** %u / %u\n", found->proto->protoId, ret.master_protocol);
 
       if(!ndpi_check_protocol_port_mismatch_exceptions(ndpi_str, flow, found, &ret))
 	NDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);
     } else if((!ndpi_is_ntop_protocol(&ret)) && default_ports && (default_ports[0] != 0)) {
       u_int8_t found = 0, i, num_loops = 0;
 
     check_default_ports:
       for(i=0; (i<MAX_DEFAULT_PORTS) && (default_ports[i] != 0); i++) {
 	if((default_ports[i] == sport) || (default_ports[i] == dport)) {
 	  found = 1;
 	  break;
 	}
       } /* for */
 
       if((num_loops == 0) && (!found)) {
 	if(flow->packet.udp)
 	  default_ports = ndpi_str->proto_defaults[ret.app_protocol].udp_default_ports;
 	else
 	  default_ports = ndpi_str->proto_defaults[ret.app_protocol].tcp_default_ports;
 
 	num_loops = 1;
 	goto check_default_ports;
       }
 
       if(!found) {
 	// printf("******** Invalid default port\n");
 	NDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);
       }
     }
 
     flow->risk_checked = 1;
   }
 
   ndpi_reconcile_protocols(ndpi_str, flow, &ret);
 
   if(num_calls == 0)
     flow->fail_with_unknown = 1;
 
  invalidate_ptr:
+#ifdef FRAG_MAN
+if (flow->must_free[flow->packet.packet_direction] && 
+      flow->packet.payload_packet_len>0 && flow->packet.payload) {
+    // if the payload is allocated for segments reassembling, it must be free
+    ndpi_free((void*)flow->packet.payload);
+    // flow->packet.payload=NULL; done after
+    flow->packet.payload_packet_len=0;
+    flow->must_free[flow->packet.packet_direction]=0;
+  }  
+#endif // FRAG_MAN
   /*
     Invalidate packet memory to avoid accessing the pointers below
     when the packet is no longer accessible
   */
   flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;
   ndpi_reset_packet_line_info(&flow->packet);
 
   return(ret);
 }
 
 /* ********************************************************************************* */
diff --git a/src/lib/ndpi_utils.c b/src/lib/ndpi_utils.c
index 3b3e3151..0c7879f6 100644
--- a/src/lib/ndpi_utils.c
+++ b/src/lib/ndpi_utils.c
@@ -1769,34 +1769,410 @@ const char* ndpi_http_method2str(ndpi_http_method m) {
 ndpi_http_method ndpi_http_str2method(const char* method, u_int16_t method_len) {
   if(!method || method_len < 3)
     return(NDPI_HTTP_METHOD_UNKNOWN);
 
   switch(method[0]) {
   case 'O': return(NDPI_HTTP_METHOD_OPTIONS);
   case 'G': return(NDPI_HTTP_METHOD_GET);
   case 'H': return(NDPI_HTTP_METHOD_HEAD);
 
   case 'P':
     switch(method[1]) {
     case 'A':return(NDPI_HTTP_METHOD_PATCH);
     case 'O':return(NDPI_HTTP_METHOD_POST);
     case 'U':return(NDPI_HTTP_METHOD_PUT);
     }
     break;
     
   case 'D':  return(NDPI_HTTP_METHOD_DELETE);
   case 'T':  return(NDPI_HTTP_METHOD_TRACE);
   case 'C':  return(NDPI_HTTP_METHOD_CONNECT);
   }
 
   return(NDPI_HTTP_METHOD_UNKNOWN);
 }
 
+#define ARRAYSZ_255 255
+void printRawData(const uint8_t *ptr, size_t len) {		
+	uint8_t *p=(uint8_t*)ptr;
+	DBGINFO("ptr=%p, len=%llu", ptr, (unsigned long long)len)
+	if (p && len>0) {
+    size_t ctLines=0,i,j;
+    char line1[ARRAYSZ_255]={0}, line2[ARRAYSZ_255]={0}, temp[ARRAYSZ_255];
+    snprintf(line1,sizeof(line1),"\t%05X",(unsigned int)(16*ctLines));
+		for (i=0; i<len; i++) {
+			
+			if (i>0 && i%16==0) {		        
+				printf("%s\t%s\n", line1,line2);
+				ctLines++;
+        snprintf(line1,ARRAYSZ_255,"\t%05X",(unsigned int)(16*ctLines));
+				snprintf(line2,ARRAYSZ_255,"%s","");
+			}      
+      snprintf(temp,ARRAYSZ_255," %02X", (uint8_t)*p);
+      strncat(line1, temp, 3);
+      snprintf(temp,ARRAYSZ_255,"%c", (isprint(*p)? *(p):'.'));
+      strncat(line2, temp, 1);
+      p++;
+		}
+		uint8_t exv= i%16;
+		for(j=exv;exv>0 && j<16;j++) {
+      strncat(line1, "   ", 3);
+		}
+		printf("%s\t%s\n", line1,line2);
+	}
+	return;	
+}
+/* ******************************************************************** */
+
+// the struct is defined in ndpi_utils.h
+
+void ins_sort_array(sorter_index_item_t arr[], int len) {
+  DBGINFO("sorting  no. %u items", (unsigned)len)
+  for (int i=1; i<len; i++) {
+    for (int j=i; j>0 && arr[j].sort_value<arr[j-1].sort_value; j--) {
+      sorter_index_item_t temp = arr[j];
+      arr[j] = arr[j-1];
+      arr[j-1] = temp;
+    }
+  }
+}
+
+void shell_sort_array(sorter_index_item_t arr[], int n) {
+  // Rearrange elements at each n/2, n/4, n/8, ... intervals
+  DBGINFO("sorting  no. %u items", (unsigned)n)
+  for (int interval = n / 2; interval > 0; interval /= 2) {
+    for (int i = interval; i < n; i += 1) {
+      sorter_index_item_t temp = arr[i];
+      int j;
+      for (j = i; j >= interval && arr[j - interval].sort_value > temp.sort_value; j -= interval) {
+        arr[j] = arr[j - interval];
+        DBGTRACER("exchanged item no. %d (%d) with: %d (%d)", j, arr[j].sort_value, j-interval, temp.sort_value)
+      }
+      DBGTRACER("item no. %d value: %d", j, temp.sort_value)
+      arr[j] = temp;
+    }
+  }
+}
+
 /* ******************************************************************** */
+#ifdef FRAG_MAN
+
+void free_fragment(fragments_wrapper_t *frag)
+{  /*
+    *  
+    typedef struct fragment_wrapper {
+      uint16_t id;
+      uint8_t l4_protocol;
+      uint8_t ct_frag;
+    #ifdef NDPI_DETECTION_SUPPORT_IPV6     
+      char   *flow_label;    // IP6
+    #endif     
+      fragment_t **fragments_list;
+    } fragments_wrapper_t; 
+    *
+    * */
+    if (frag) {
+      DBGTRACER("(frag:%p) freeing fragments list -> %p",frag, frag->fragments_list)
+      if (frag->fragments_list) {
+        DBGTRACER("fragments are %u.",frag->ct_frag)
+        for ( int y=0;y<frag->ct_frag;y++) {
+          if (frag->fragments_list[y]) {
+            if (frag->fragments_list[y]->data) {
+              DBGPOINTER("freeing fragment item %d -> %p",y, frag->fragments_list[y])
+              ndpi_free(frag->fragments_list[y]->data);
+            }
+            ndpi_free(frag->fragments_list[y]);
+          }
+        }        
+        DBGPOINTER("freeing fragments list -> %p",frag->fragments_list)
+        ndpi_free(frag->fragments_list);
+        frag->fragments_list= NULL;
+      }
+      //reset counter and initial offset
+      frag->ct_frag=0;
+      frag->initial_offset=0;
+    }
+}
+
+uint8_t add_segment_to_buffer( struct ndpi_flow_struct *flow, struct ndpi_tcphdr const * tcph, uint32_t new_waited_seq) {
+
+  DBGINFO("[flow:%p], dir: %d, seq:%u, ack:%u, len: %ubytes",flow,flow->packet.packet_direction, ntohl(tcph->seq), ntohl(tcph->ack_seq), flow->packet.payload_packet_len)
+
+  if (flow->tcp_segments_management) {
+    fragments_wrapper_t *fragW= &flow->tcp_segments_list[flow->packet.packet_direction];
+    DBGTRACER("tcp segments management enabled (list container: %p)",fragW)
+
+    if ( fragW->ct_frag == 0 ) {
+      if (fragW->fragments_list) { free_fragment(fragW); }
+      // initialize the offset with the first fragment seq number
+      fragW->initial_offset= new_waited_seq;
+      DBGTRACER("initialized initial_offset: %u)",fragW->initial_offset)
+    }
+    
+    if ( flow->packet.payload_packet_len>0 ) {
+      // allocate memory for pointer
+      size_t new_len= (1+fragW->ct_frag) * sizeof(fragment_t*);
+      DBGTRACER("actual fragment list ct=%d, new size: %llu", fragW->ct_frag, (unsigned long long)new_len)
+      //fragW->fragments_list= realloc(fragW->fragments_list,new_len);
+      fragW->fragments_list= ndpi_realloc(fragW->fragments_list,(fragW->ct_frag * sizeof(fragment_t*)),new_len);
+      DBGPOINTER("fragments_list initialized for item no. %u, list->%p i-esimo->%p", fragW->ct_frag, fragW->fragments_list, fragW->fragments_list[fragW->ct_frag])
+      if ( !fragW->fragments_list ) {
+          flow->tcp_segments_management= 0; 
+          fprintf(stderr, "[%8u] Not enough memory for new fragment \n", flow->packet_counter);
+          return 0;
+      }
+
+      // allocate memory for item
+      fragment_t *new_frag= (fragment_t*)ndpi_calloc(1, sizeof(fragment_t));
+      DBGPOINTER("new_frag=> %p",new_frag)
+      if ( !new_frag ) {
+          flow->tcp_segments_management= 0; 
+          free_fragment(fragW);
+          fprintf(stderr, "[%8u] Not enough memory for new fragment \n", flow->packet_counter);
+          return 0;
+      }       
+
+      // fill item with offsetm len and data fragment/segment
+      new_frag->offset= ( 0xffffffff & ntohl(tcph->seq)) - fragW->initial_offset;
+      DBGTRACER("offset calculation: seq %u, init: %u, offset result: %u", ntohl(tcph->seq), fragW->initial_offset, new_frag->offset)
+      new_frag->len= flow->packet.payload_packet_len;      
+       
+      new_frag->data= (void*)ndpi_calloc(new_frag->len, sizeof(char));
+      DBGPOINTER("new_frag->data=> %p",new_frag->data)
+      if ( new_frag->data ) {
+        memcpy(new_frag->data,flow->packet.payload,new_frag->len);
+        fragW->fragments_list[fragW->ct_frag++]= new_frag; 
+      } else {
+        flow->tcp_segments_management= 0; 
+        ndpi_free(new_frag);
+        free_fragment(fragW);
+        fprintf(stderr, "[%8u] Not enough memory for new fragment data \n", flow->packet_counter);
+        return 0;
+      }
+
+      DBGINFO("item no. %u: %p->%p [off:%u, len:%u, data:%p]", fragW->ct_frag, fragW->fragments_list, *fragW->fragments_list, (unsigned int) new_frag->offset, (unsigned int)new_frag->len, new_frag->data)
+      return fragW->ct_frag;
+    }
+  }
+  return 0;
+}
+//TODO: manage partial retrasmission
+
+uint32_t reassembly_fragment(struct ndpi_flow_struct *const flow, struct ndpi_tcphdr const * tcph, uint8_t **ret_buffer, size_t *len_buffer)
+{
+  DBGTRACER("tcph:%p, ret_buffer:%p, len_buffer:%u",tcph,ret_buffer,len_buffer)
+
+  // reassemble the fragments...
+  uint32_t ret_value=0;
+  uint16_t last_item=0;
+  size_t length=0,tot_length=0; //, offset=0;
+  fragments_wrapper_t *fragW= &flow->tcp_segments_list[flow->packet.packet_direction];
+
+  // phase 1: calculate the size and fill the indexes array
+  DBGINFO("phase 1: init sorter, calculate the size of buffer to reassemble: %u items", fragW->ct_frag)
+  sorter_index_item_t *sorted_indexes= ndpi_calloc( fragW->ct_frag, sizeof(sorter_index_item_t) );
+  DBGPOINTER("sorted_indexes=> %p",sorted_indexes)
+  if ( !sorted_indexes ) {
+      fprintf(stderr, "[%8u] Not enough memory to sort the %u segments \n", 
+          flow->packet_counter, fragW->ct_frag); 
+      free_fragment(fragW);
+      return 0;
+  }
+  
+  for (int i=0; i<fragW->ct_frag; i++) {
+    fragment_t *item = (fragment_t*)fragW->fragments_list[i];
+  
+    sorted_indexes[i].sort_value= item->offset;
+    sorted_indexes[i].item_index= i;        
+    tot_length += item->len;
+    DBGTRACER("segment (%d): len:%lu, offset: %u => partial buffer len: %lu", i, (long unsigned int)item->len, (unsigned int)item->offset, (long unsigned int)tot_length)
+  }
+
+  // phase 2: sorts fragments and check fragments and sequences
+  DBGINFO(" phase 2 sorting %d segments and checking",fragW->ct_frag)
+  if (fragW->ct_frag>1) shell_sort_array(sorted_indexes, fragW->ct_frag);
+
+  // checks
+  for (uint i=0; i<fragW->ct_frag; i++) {
+    fragment_t *item = (fragment_t*)fragW->fragments_list[ sorted_indexes[i].item_index ];
+
+    // 1: no segment offset can be > tot_length
+    DBGTRACER("checking %d/%d element: offset=%lu vs t_length=%lu",i,sorted_indexes[i].item_index,(unsigned long)item->offset,(unsigned long)tot_length)
+    if ( (item->offset) > (uint32_t)tot_length ) {
+      // update the last index of elements to elaborate
+      DBGINFO("stop processing at %d/%d element: len= %u; offset= %u",i,sorted_indexes[i].item_index,(unsigned)length,(unsigned)item->offset)
+
+      tot_length= length;
+      ret_value= (fragW->initial_offset)+(item->offset);  // set the first offset to wait for the next segment
+      break;
+    }
+    // 2: for every len(buffer) must exists a offset fragment
+    else if ( (item->offset) != (uint32_t)length ) {
+      // update the last index of elements to elaborate
+      DBGINFO("checking %d/%d element: stop processing! len: %u; n_offset: %u", i,sorted_indexes[i].item_index,(unsigned)length,(unsigned)item->offset)
+
+      tot_length= length;
+      ret_value= (fragW->initial_offset)+(item->offset);  // set the first offset to wait for the next segment
+      break;
+    } else {
+      // continue to sum length data bytes
+      length+= item->len;
+      last_item= i;
+    }
+  }
+  last_item++;  // index to number aligment
+
+  // phase 3: allocate memory and fill the buffer
+  DBGINFO("phase 3: allocate memory for %u items and fill the buffer tot: %lu", last_item, (unsigned long int)tot_length)
+  uint8_t *buffer= ndpi_calloc(tot_length, sizeof(uint8_t));
+  DBGPOINTER("buffer (len:%lu)=> %p",(unsigned long)tot_length,buffer)
+  if ( !buffer ) {
+    fprintf(stderr, "[%8u] Not enough memory for buffer for %u segments \n", flow->packet_counter,last_item);
+    free_fragment(fragW);
+    ndpi_free(sorted_indexes);
+    return 0;
+  }  
+
+  for (uint i=0; i<last_item; i++) {
+      fragment_t *item = (fragment_t*)fragW->fragments_list[sorted_indexes[i].item_index];
+
+      //uint_t blk_sz= (tot_length - item->offset) > item->len ) ? item->len : tot_length-item->offset
+      DBGINFO("copying data item no:%u of len: %lu to buffer: %p (offset:%lu)", sorted_indexes[i].item_index, (unsigned long int)item->len, buffer, (unsigned long int)item->offset)
+      memcpy((void*)(buffer+item->offset),item->data, item->len);
+
+      // free memory item
+      ndpi_free(item->data);
+      item->data=NULL;
+      ndpi_free(item);
+      fragW->fragments_list[sorted_indexes[i].item_index]=NULL;
+  }
+
+  if ( last_item==fragW->ct_frag ) {
+    DBGTRACER("all processed: free all memory!")
+    free_fragment(fragW);
+  } else {
+    // phase 4: re-organize the other segments, updating the list    
+    fragment_t **fragW_old_list = fragW->fragments_list;
+    fragW->fragments_list= ndpi_calloc((fragW->ct_frag-last_item), sizeof(struct fragment_t*));
+    DBGPOINTER("old segments list: %p, new segments list: %p.",fragW_old_list,fragW->fragments_list)
+    if (!fragW->fragments_list) {
+      fprintf(stderr, "[%8u] Not enough memory for new segments list \n", flow->packet_counter);
+      free_fragment(fragW);
+      ndpi_free(buffer);
+      ndpi_free(sorted_indexes);
+      return 0;
+    }    
+
+    // re-fill the new segments list, updating the offsets
+    for (uint i=last_item; i<fragW->ct_frag; i++) {
+      fragW->fragments_list[i-last_item] = (fragment_t*)fragW_old_list[sorted_indexes[i].item_index];
+      fragW->fragments_list[i-last_item]->offset-= tot_length;
+      DBGTRACER("moving the item (%p), index %u - to position %u of new segments list; new offset: %u.", fragW->fragments_list[i-last_item], sorted_indexes[i].item_index, i-last_item, fragW->fragments_list[i-last_item]->offset )
+    }
+
+    // update the fragments countes
+    fragW->ct_frag-= last_item;
+    fragW->initial_offset+= tot_length;
+    DBGINFO("updated counter: %d and i_offset: %u.",(unsigned)fragW->ct_frag, (unsigned)fragW->initial_offset)
+    
+    DBGPOINTER("freeing old segments list: %p ",fragW_old_list)
+    ndpi_free(fragW_old_list);
+  }
+
+  if ( sorted_indexes) {
+    DBGPOINTER("freeing sorter indexes: %p ",sorted_indexes)
+    ndpi_free(sorted_indexes);
+  }
+
+  if(len_buffer != NULL) {
+      *len_buffer = tot_length;
+  }
+  if(ret_buffer != NULL) {
+      *ret_buffer = (u_int8_t *) buffer;
+      flow->must_free[flow->packet.packet_direction]=1;
+      DBGINFO("retrieved the buffer of segments (len:%lu) %p",*len_buffer,*ret_buffer)
+  } else {
+    DBGPOINTER("freeing buffer=> %p",buffer)
+    ndpi_free(buffer);
+  }
+  DBGINFO("returning: %d",ret_value)
+  return ret_value;
+}
+
+uint8_t check_for_sequence( struct ndpi_flow_struct *flow, struct ndpi_tcphdr const * tcph) 
+{
+  uint8_t *ret_buffer=NULL;
+  size_t len_buffer=0;
+
+  DBGINFO("## sorted flags: %d/%d ",flow->not_sorted[0],flow->not_sorted[1])
+  if ( flow->next_tcp_seq_nr[flow->packet.packet_direction] ) {
+    uint32_t *trigger;
+    uint8_t *not_sorted;
+
+    // use pointers to allow the modification
+    not_sorted = &flow->not_sorted[flow->packet.packet_direction];
+    trigger = &flow->trigger[flow->packet.packet_direction];
+
+    DBGTRACER("dir:%d, trg:%u, next:%u", flow->packet.packet_direction,*trigger, flow->next_tcp_seq_nr[flow->packet.packet_direction])
+
+    uint32_t waited= (*not_sorted && *trigger) ? ndpi_min(*trigger,flow->next_tcp_seq_nr[flow->packet.packet_direction]) : flow->next_tcp_seq_nr[flow->packet.packet_direction];
+    if ( waited<(0xffffffff & ntohl(tcph->seq))) {
+      // segment not in order... almost 1 has been skipped! add this fragment to buffer
+      DBGINFO("received a segment (seq:%u) over the waited (next:%u)", (0xffffffff & ntohl(tcph->seq)), waited)
+      
+      if ( add_segment_to_buffer(flow, tcph, waited) ) {
+        DBGTRACER("segment (seq:%u) bufferized, waiting for (next:%u)", (0xffffffff & ntohl(tcph->seq)), waited)
+
+        // set flag a save the waited sequence number
+        *not_sorted=1;
+        *trigger= *trigger ? ndpi_min(flow->next_tcp_seq_nr[flow->packet.packet_direction],*trigger):flow->next_tcp_seq_nr[flow->packet.packet_direction];
+        DBGINFO("set flag and trigger[%d]: %u",flow->packet.packet_direction,*trigger)
+      }
+      return 1;
+
+    } else if (waited>(0xffffffff & ntohl(tcph->seq))) {
+      DBGINFO("received a segment (seq:%u) minus than the waited (next:%u): retransmission!!", (0xffffffff & ntohl(tcph->seq)), flow->next_tcp_seq_nr[flow->packet.packet_direction])
+
+      flow->packet.tcp_retransmission = 1;
+
+      /* CHECK IF PARTIAL RETRY IS HAPPENING */
+      if((flow->next_tcp_seq_nr[flow->packet.packet_direction] - ntohl(tcph->seq) <
+          flow->packet.payload_packet_len)) {
+        /* num_retried_bytes actual_payload_len hold info about the partial retry
+          analyzer which require this info can make use of this info
+          Other analyzer can use packet->payload_packet_len */
+        flow->packet.num_retried_bytes = (u_int16_t)(flow->next_tcp_seq_nr[flow->packet.packet_direction] - ntohl(tcph->seq));
+        flow->packet.actual_payload_len = flow->packet.payload_packet_len - flow->packet.num_retried_bytes;
+        flow->next_tcp_seq_nr[flow->packet.packet_direction] = ntohl(tcph->seq) + flow->packet.payload_packet_len;
+        DBGINFO("partial_bytes:%u",flow->packet.num_retried_bytes)
+
+        //TODO: manage this!!
+      }
+
+    } else {
+      DBGTRACER("seq (%u) and waited (%u) matched! sorted flag: %d", (0xffffffff & ntohl(tcph->seq)), flow->next_tcp_seq_nr[flow->packet.packet_direction], *not_sorted)
+      if ( *not_sorted ) {
+        if ( add_segment_to_buffer(flow, tcph, 0) ) {
+          *trigger= reassembly_fragment(flow,tcph,&ret_buffer,&len_buffer);
+          *not_sorted=(*trigger>0);
+
+          if (len_buffer>0) {
+            // the previous pointers must not be free, because managed in other part
+            flow->packet.payload_packet_len= len_buffer;
+            flow->packet.payload= ret_buffer;
+          }
+        }
+      }
+    }
+  }
+  return 0;
+}
+#endif // FRAG_MAN
+
 
 #define ROR64(x,r) (((x)>>(r))|((x)<<(64-(r))))
 
 /*
   'in_16_bytes_long` points to some 16 byte memory data to be hashed;
   two independent 64-bit linear congruential generators are applied
   results are mixed, scrambled and cast to 32-bit
 */
