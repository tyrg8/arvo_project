commit 260621179f340cd8be4c0251004061c2e861d26f
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Wed Jan 19 19:04:09 2022 -0500

    https://github.com/ImageMagick/ImageMagick/discussions/4533#discussioncomment-2001819

diff --git a/MagickCore/fx.c b/MagickCore/fx.c
index 956378e05..dc5e0c91d 100644
--- a/MagickCore/fx.c
+++ b/MagickCore/fx.c
@@ -233,77 +233,79 @@ static const ConstantT Constants[] = {
 typedef enum {
   fAbs = oNull+1,
 #if defined(MAGICKCORE_HAVE_ACOSH)
   fAcosh,
 #endif
   fAcos,
+#if defined(MAGICKCORE_HAVE_J1)
   fAiry,
+#endif
   fAlt,
 #if defined(MAGICKCORE_HAVE_ASINH)
   fAsinh,
 #endif
   fAsin,
 #if defined(MAGICKCORE_HAVE_ATANH)
   fAtanh,
 #endif
   fAtan2,
   fAtan,
   fCeil,
   fChannel,
   fClamp,
   fCosh,
   fCos,
   fDebug,
   fDrc,
 #if defined(MAGICKCORE_HAVE_ERF)
   fErf,
 #endif
   fExp,
   fFloor,
   fGauss,
   fGcd,
   fHypot,
   fInt,
   fIsnan,
 #if defined(MAGICKCORE_HAVE_J0)
   fJ0,
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
   fJ1,
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
   fJinc,
 #endif
   fLn,
   fLogtwo,
   fLog,
   fMax,
   fMin,
   fMod,
   fNot,
   fPow,
   fRand,
   fRound,
   fSign,
   fSinc,
   fSinh,
   fSin,
   fSqrt,
   fSquish,
   fTanh,
   fTan,
   fTrunc,
   fDo,
   fFor,
   fIf,
   fWhile,
   fU,
   fU0,
   fUP,
   fS,
   fV,
   fP,
   fSP,
   fVP,
 
   fNull
 } FunctionE;
@@ -317,79 +319,81 @@ typedef struct {
 static const FunctionT Functions[] = {
   {fAbs,     "abs"   , 1},
 #if defined(MAGICKCORE_HAVE_ACOSH)
   {fAcosh,   "acosh" , 1},
 #endif
   {fAcos,    "acos"  , 1},
+#if defined(MAGICKCORE_HAVE_J1)
   {fAiry,    "airy"  , 1},
+#endif
   {fAlt,     "alt"   , 1},
 #if defined(MAGICKCORE_HAVE_ASINH)
   {fAsinh,   "asinh" , 1},
 #endif
   {fAsin,    "asin"  , 1},
 #if defined(MAGICKCORE_HAVE_ATANH)
   {fAtanh,   "atanh" , 1},
 #endif
   {fAtan2,   "atan2" , 2},
   {fAtan,    "atan"  , 1},
   {fCeil,    "ceil"  , 1},
   {fChannel, "channel"  , 5},
   {fClamp,   "clamp" , 1},
   {fCosh,    "cosh"  , 1},
   {fCos,     "cos"   , 1},
   {fDebug,   "debug" , 1},
   {fDrc,     "drc"   , 2},
 #if defined(MAGICKCORE_HAVE_ERF)
   {fErf,     "erf"   , 1},
 #endif
   {fExp,     "exp"   , 1},
   {fFloor,   "floor" , 1},
   {fGauss,   "gauss" , 2},
   {fGcd,     "gcd"   , 2},
   {fHypot,   "hypot" , 2},
   {fInt,     "int"   , 1},
   {fIsnan,   "isnan" , 1},
 #if defined(MAGICKCORE_HAVE_J0)
   {fJ0,      "j0"    , 1},
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
   {fJ1,      "j1"    , 1},
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
   {fJinc,    "jinc"  , 1},
 #endif
   {fLn,      "ln"    , 1},
   {fLogtwo,  "logtwo", 1},
   {fLog,     "log"   , 1},
   {fMax,     "max"   , 2},
   {fMin,     "min"   , 2},
   {fMod,     "mod"   , 2},
   {fNot,     "not"   , 1},
   {fPow,     "pow"   , 2},
   {fRand,    "rand"  , 0},
   {fRound,   "round" , 1},
   {fSign,    "sign"  , 1},
   {fSinc,    "sinc"  , 1},
   {fSinh,    "sinh"  , 1},
   {fSin,     "sin"   , 1},
   {fSqrt,    "sqrt"  , 1},
   {fSquish,  "squish", 1},
   {fTanh,    "tanh"  , 1},
   {fTan,     "tan"   , 1},
   {fTrunc,   "trunc" , 1},
   {fDo,      "do",     2},
   {fFor,     "for",    3},
   {fIf,      "if",     3},
   {fWhile,   "while",  2},
   {fU,       "u",      1},
   {fU0,      "u0",     0},
   {fUP,      "up",     3},
   {fS,       "s",      0},
   {fV,       "v",      0},
   {fP,       "p",      2},
   {fSP,      "sp",     2},
   {fVP,      "vp",     2},
 
   {fNull,    "fnull" , 0}
 };
 
 #define FirstImgAttr ((ImgAttrE) (fNull+1))
@@ -397,29 +401,29 @@ static const FunctionT Functions[] = {
 typedef enum {
   aDepth = fNull+1,
   aExtent,
   aKurtosis,
   aMaxima,
   aMean,
   aMedian,
   aMinima,
   aPage,
-  aPageWid,
-  aPageHt,
   aPageX,
   aPageY,
+  aPageWid,
+  aPageHt,
   aPrintsize,
   aPrintsizeX,
   aPrintsizeY,
   aQuality,
   aRes,
   aResX,
   aResY,
   aSkewness,
   aStdDev,
   aH,
   aN,
   aT,
   aW,
   aZ,
   aNull
 } ImgAttrE;
@@ -1246,40 +1250,41 @@ static MagickBooleanType ExpectChar (FxInfo * pfx, char c)
 static int MaybeXYWH (FxInfo * pfx, ImgAttrE * pop)
 /* If ".x" or ".y" or ".width" or ".height" increments *pop and returns 1 to 4 .
    Otherwise returns 0.
 */
 {
   int ret=0;
 
   if (*pop != aPage && *pop != aPrintsize && *pop != aRes) return 0;
 
   if (PeekChar (pfx) != '.') return 0;
 
   if (!ExpectChar (pfx, '.')) return 0;
 
   (void) GetToken (pfx);
   if (LocaleCompare ("x", pfx->token)==0) ret=1;
   else if (LocaleCompare ("y", pfx->token)==0) ret=2;
   else if (LocaleCompare ("width", pfx->token)==0) ret=3;
   else if (LocaleCompare ("height", pfx->token)==0) ret=4;
 
   if (!ret)
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "Invalid 'x' or 'y' or 'width' or 'height' token=", "'%s' at '%s'",
       pfx->token, SetShortExp(pfx));
 
   if (*pop == aPage) (*pop) = (ImgAttrE) (*pop + ret);
   else {
     if (ret > 2) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "Invalid 'width' or 'height' token=", "'%s' at '%s'",
         pfx->token, SetShortExp(pfx));
     } else {
       (*pop) = (ImgAttrE) (*pop + ret);
     }
   }
   pfx->pex+=pfx->lenToken;
+
   return ret;
 }
 
@@ -1448,73 +1453,74 @@ static MagickBooleanType IsQualifier (FxInfo * pfx)
 static ssize_t GetProperty (FxInfo * pfx, fxFltType *val)
 /* returns number of character to swallow.
    "-1" means invalid input
    "0" means no relevant input (don't swallow, but not an error)
 */
 {
 
   if (PeekStr (pfx, "%[")) {
     int level = 0;
     size_t len;
     char sProperty [MagickPathExtent];
     char * p = pfx->pex + 2;
 
     while (*p) {
 
       if (*p == '[') level++;
       else if (*p == ']') {
         if (level == 0) break;
         level--;
       }
       p++;
     }
     if (!*p || level != 0) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "After '%[' expected ']' at", "'%s'",
         SetShortExp(pfx));
       return -1;
     }
 
     len = (size_t) (p - pfx->pex + 1);
     if (len > MaxTokenLen) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "Too much text between '%[' and ']' at", "'%s'",
         SetShortExp(pfx));
       return -1;
     }
 
     (void) CopyMagickString (sProperty, pfx->pex, len+1);
     sProperty[len] = '\0';
 
     {
       char * tailptr;
       char * text;
       text = InterpretImageProperties (pfx->image->image_info, pfx->image,
          sProperty, pfx->exception);
 
       if (!text) {
         (void) ThrowMagickException (
           pfx->exception, GetMagickModule(), OptionError,
           "Unknown property", "'%s' at '%s'",
           sProperty, SetShortExp(pfx));
+        text = DestroyString(text);
         return -1;
       }
 
       *val = strtold (text, &tailptr);
       if (text == tailptr) {
         (void) ThrowMagickException (
           pfx->exception, GetMagickModule(), OptionError,
-          "Property", "'%s' is not a number at '%s'",
-          text, SetShortExp(pfx));
+          "Property", "'%s' text '%s' is not a number at '%s'",
+          sProperty, text, SetShortExp(pfx));
         text = DestroyString(text);
         return -1;
       }
 
       text = DestroyString(text);
     }
     return ((ssize_t) len);
   }
 
   return 0;
 }
@@ -1650,309 +1656,309 @@ static ssize_t inline GetHexColour (FxInfo * pfx, fxFltType *v0, fxFltType *v1,
 static MagickBooleanType GetFunction (FxInfo * pfx, FunctionE fe)
 {
   /* A function, so get open-parens, n args, close-parens
   */
   const char * funStr = Functions[fe-FirstFunc].str;
   int nArgs = Functions[fe-FirstFunc].nArgs;
   char chLimit = ')';
   char expChLimit = ')';
   const char *strLimit = ",)";
   OperatorE pushOp = oOpenParen;
 
   char * pExpStart;
 
   int lenExp = 0;
 
   int FndArgs = 0;
   int ndx0 = NULL_ADDRESS, ndx1 = NULL_ADDRESS, ndx2 = NULL_ADDRESS, ndx3 = NULL_ADDRESS;
 
   MagickBooleanType coordQual = MagickFalse;
   PixelChannel chQual = NO_CHAN_QUAL;
   ImgAttrE iaQual = aNull;
 
   pfx->pex += pfx->lenToken;
 
   if (fe == fP) {
     char p = PeekChar (pfx);
     if (p=='{') {
       (void) ExpectChar (pfx, '{');
       pushOp = oOpenBrace;
       strLimit = ",}";
       chLimit = '}';
       expChLimit = '}';
     } else if (p=='[') {
       (void) ExpectChar (pfx, '[');
       pushOp = oOpenBracket;
       strLimit = ",]";
       chLimit = ']';
       expChLimit = ']';
     } else {
       nArgs = 0;
       chLimit = ']';
       expChLimit = ']';
     }
   } else if (fe == fU) {
     char p = PeekChar (pfx);
     if (p=='[') {
       (void) ExpectChar (pfx, '[');
       pushOp = oOpenBracket;
       strLimit = ",]";
       chLimit = ']';
       expChLimit = ']';
     } else {
       nArgs = 0;
       chLimit = ']';
       expChLimit = ']';
     }
   } else if (fe == fV || fe == fS) {
       nArgs = 0;
       pushOp = oOpenBracket;
       chLimit = ']';
       expChLimit = ']';
   } else {
     if (!ExpectChar (pfx, '(')) return MagickFalse;
   }
   if (!PushOperatorStack (pfx, pushOp)) return MagickFalse;
 
   pExpStart = pfx->pex;
   ndx0 = pfx->usedElements;
   if (fe==fDo) {
     (void) AddAddressingElement (pfx, rGoto, NULL_ADDRESS); /* address will be ndx1+1 */
   }
   while (nArgs > 0) {
     int FndOne = 0;
     if (TranslateStatementList (pfx, strLimit, &chLimit)) {
       FndOne = 1;
     } else {
       /* Maybe don't break because other expressions may be not empty. */
       if (!chLimit) break;
       if (fe == fP || fe == fS|| fe == fIf) {
         (void) AddElement (pfx, (fxFltType) 0, oNull);
         FndOne = 1;
       } 
     }
 
     if (strchr (strLimit, chLimit)==NULL) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "For function", "'%s' expected one of '%s' after expression but found '%c' at '%s'",
         funStr, strLimit, chLimit ? chLimit : ' ', SetShortExp(pfx));
       return MagickFalse;
     }
     if (FndOne) {
       FndArgs++;
       nArgs--;
     }
     switch (FndArgs) {
       case 1:
         ndx1 = pfx->usedElements;
         if (fe==fWhile) {
           (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2+1 */
         } else if (fe==fDo) {
           (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2+1 */
         } else if (fe==fFor) {
           pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
         } else if (fe==fIf) {
           (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx2 + 1 */
           pfx->Elements[pfx->usedElements-1].DoPush = MagickTrue; /* we may need return from if() */
         }
         break;
       case 2:
         ndx2 = pfx->usedElements;
         if (fe==fWhile) {
           pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
           (void) AddAddressingElement (pfx, rGoto, ndx0);
         } else if (fe==fDo) {
           pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
           (void) AddAddressingElement (pfx, rGoto, ndx0 + 1);
         } else if (fe==fFor) {
           (void) AddAddressingElement (pfx, rIfZeroGoto, NULL_ADDRESS); /* address will be ndx3 */
           pfx->Elements[pfx->usedElements-1].DoPush = MagickTrue; /* we may need return from for() */
           (void) AddAddressingElement (pfx, rZerStk, NULL_ADDRESS);
         } else if (fe==fIf) {
           (void) AddAddressingElement (pfx, rGoto, NULL_ADDRESS); /* address will be ndx3 */
         }
         break;
       case 3:
         if (fe==fFor) {
           pfx->Elements[pfx->usedElements-1].DoPush = MagickFalse;
           (void) AddAddressingElement (pfx, rGoto, ndx1);
         }
         ndx3 = pfx->usedElements;
         break;
       default:
         break;
     }
     if (chLimit == expChLimit) {
       lenExp = pfx->pex - pExpStart - 1;
       break;
     }
   } /* end while args of a function */
   if (chLimit && chLimit != expChLimit && chLimit != ',' ) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "For function", "'%s' expected '%c', found '%c' at '%s'",
       funStr, expChLimit, chLimit ? chLimit : ' ', SetShortExp(pfx));
     return MagickFalse;
   }
 
   if (fe == fP || fe == fS || fe == fU) {
     while (FndArgs < Functions[fe-FirstFunc].nArgs) {
       (void) AddElement (pfx, (fxFltType) 0, oNull);
       FndArgs++;
     }
   }
 
   if (FndArgs > Functions[fe-FirstFunc].nArgs) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "For function", "'%s' expected %i arguments, found '%i' at '%s'",
       funStr, Functions[fe-FirstFunc].nArgs, FndArgs, SetShortExp(pfx));
     return MagickFalse;
   }
   if (FndArgs < Functions[fe-FirstFunc].nArgs) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "For function", "'%s' expected %i arguments, found too few (%i) at '%s'",
       funStr, Functions[fe-FirstFunc].nArgs, FndArgs, SetShortExp(pfx));
     return MagickFalse;
   }
   if (fe != fS && fe != fV && FndArgs == 0 && Functions[fe-FirstFunc].nArgs == 0) {
     /* This is for "rand()" and similar. */
     chLimit = expChLimit;
     if (!ExpectChar (pfx, ')')) return MagickFalse;
   }
 
   if (chLimit != expChLimit) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "For function", "'%s', arguments don't end with '%c' at '%s'",
       funStr, expChLimit, SetShortExp(pfx));
     return MagickFalse;
   }
   if (!PopOprOpenParen (pfx, pushOp)) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "Bug: For function", "'%s' tos not '%s' at '%s'",
       funStr, Operators[pushOp].str, SetShortExp(pfx));
     return MagickFalse;
   }
 
   if (IsQualifier (pfx)) {
 
     if (fe == fU || fe == fV || fe == fS) {
 
       coordQual = (GetCoordQualifier (pfx, fe) == 1) ? MagickTrue : MagickFalse;
 
       if (coordQual) {
 
         /* Remove last element, which should be fP */
         ElementT * pel = &pfx->Elements[pfx->usedElements-1];
         if (pel->oprNum != fP) {
           (void) ThrowMagickException (
             pfx->exception, GetMagickModule(), OptionError,
             "Bug: For function", "'%s' last element not 'p' at '%s'",
             funStr, SetShortExp(pfx));
           return MagickFalse;
         }
         chQual = pel->ChannelQual;
         expChLimit = (pel->IsRelative) ? ']' : '}';
         pfx->usedElements--;
         if (fe == fU) fe = fUP;
         else if (fe == fV) fe = fVP;
         else if (fe == fS) fe = fSP;
         funStr = Functions[fe-FirstFunc].str;
       }
     }
 
     if ( chQual == NO_CHAN_QUAL &&
          (fe == fP || fe == fS || fe == fSP || fe == fU || fe == fUP || fe == fV || fe == fVP)
        )
     {
       chQual = GetChannelQualifier (pfx, fe);
     }
 
     if (chQual == NO_CHAN_QUAL && (fe == fU || fe == fV || fe == fS)) {
       /* Note: we don't allow "p.mean" etc. */
       iaQual = GetImgAttrQualifier (pfx, fe);
     }
     if (IsQualifier (pfx) && chQual == NO_CHAN_QUAL && iaQual != aNull) {
       chQual = GetChannelQualifier (pfx, fe);
     }
     if (coordQual && iaQual != aNull) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "For function", "'%s', can't have qualifiers 'p' and image attribute '%s' at '%s'",
         funStr, pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
     if (!coordQual && chQual == NO_CHAN_QUAL && iaQual == aNull) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "For function", "'%s', bad qualifier '%s' at '%s'",
         funStr, pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
     if (!coordQual && chQual == CompositePixelChannel && iaQual == aNull) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
-        "For function", "'%s', bad compsite qualifier '%s' at '%s'",
+        "For function", "'%s', bad composite qualifier '%s' at '%s'",
         funStr, pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
 
     if (chQual == HUE_CHANNEL || chQual == SAT_CHANNEL || chQual == LIGHT_CHANNEL) {
       pfx->NeedHsl = MagickTrue;
 
       if (iaQual >= FirstImgAttr && iaQual < aNull) {
         (void) ThrowMagickException (
           pfx->exception, GetMagickModule(), OptionError,
           "Can't have image attribute with HLS qualifier at", "'%s'",
           SetShortExp(pfx));
         return MagickFalse;
       }
     }
   }
 
   if (fe==fWhile) {
     pfx->Elements[ndx1].EleNdx = ndx2+1;
   } else if (fe==fDo) {
     pfx->Elements[ndx0].EleNdx = ndx1+1;
     pfx->Elements[ndx1].EleNdx = ndx2+1;
   } else if (fe==fFor) {
     pfx->Elements[ndx2].EleNdx = ndx3;
   } else if (fe==fIf) {
     pfx->Elements[ndx1].EleNdx = ndx2 + 1;
     pfx->Elements[ndx2].EleNdx = ndx3;
   } else {
     if (fe == fU && iaQual == aNull) {
       ElementT * pel = &pfx->Elements[pfx->usedElements-1];
       if (pel->type == etConstant && pel->val == 0.0) {
         pfx->usedElements--;
         fe = fU0;
       }
     }
     (void) AddElement (pfx, (fxFltType) 0, fe);
     if (fe == fP || fe == fU  || fe == fU0 || fe == fUP ||
         fe == fV || fe == fVP || fe == fS || fe == fSP)
     {
       ElementT * pel = &pfx->Elements[pfx->usedElements-1];
       pel->IsRelative = (expChLimit == ']' ? MagickTrue : MagickFalse);
       if (chQual >= 0) pel->ChannelQual = chQual;
       if (iaQual != aNull && (fe == fU || fe == fV || fe == fS)) {
         /* Note: we don't allow "p[2,3].mean" or "p.mean" etc. */
         pel->ImgAttrQual = iaQual;
       }
     }
   }
 
   if (pExpStart && lenExp) {
     ElementT * pel = &pfx->Elements[pfx->usedElements-1];
     pel->pExpStart = pExpStart;
     pel->lenExp = lenExp;
   }
 
   if (fe == fDebug)
     pfx->ContainsDebug = MagickTrue;
 
   return MagickTrue;
 }
@@ -2428,189 +2434,192 @@ static MagickBooleanType ResolveTernaryAddresses (FxInfo * pfx, TernaryT * ptern
 static MagickBooleanType TranslateExpression (
   FxInfo * pfx, const char * strLimit, char * chLimit, MagickBooleanType * needPopAll)
 {
   /* There should be only one New per expression (oAssign), but can be many Old.
   */
   MagickBooleanType UserSymbol, NewUserSymbol;
   int UserSymNdx0, UserSymNdx1;
 
   MagickBooleanType
     Assign = MagickFalse,
     Update = MagickFalse,
     IncrDecr = MagickFalse;
 
   int StartEleNdx;
 
   TernaryT ternary;
   ternary.addrQuery = NULL_ADDRESS;
   ternary.addrColon = NULL_ADDRESS;
 
   pfx->teDepth++;
 
   *chLimit = '\0';
 
   StartEleNdx = pfx->usedElements-1;
   if (StartEleNdx < 0) StartEleNdx = 0;
 
   SkipSpaces (pfx);
 
   if (!*pfx->pex) {
     pfx->teDepth--;
     return MagickFalse;
   }
 
   if (strchr(strLimit,*pfx->pex)!=NULL) {
     *chLimit = *pfx->pex;
     pfx->pex++;
     pfx->teDepth--;
 
     return MagickFalse;
   }
 
   if (!GetOperand (pfx, &UserSymbol, &NewUserSymbol, &UserSymNdx0, needPopAll)) return MagickFalse;
   SkipSpaces (pfx);
 
   /* Loop through Operator, Operand, Operator, Operand, ...
   */
   while (*pfx->pex && (!*strLimit || (strchr(strLimit,*pfx->pex)==NULL))) {
     if (!GetOperator (pfx, &Assign, &Update, &IncrDecr)) return MagickFalse;
     SkipSpaces (pfx);
     if (NewUserSymbol && !Assign) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "Expected assignment after new UserSymbol", "'%s' at '%s'",
         pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
     if (!UserSymbol && Assign) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "Attempted assignment to non-UserSymbol", "'%s' at '%s'",
         pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
     if (!UserSymbol && Update) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "Attempted update to non-UserSymbol", "'%s' at '%s'",
         pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
     if (UserSymbol && (Assign || Update) && !IncrDecr) {
 
       if (!TranslateExpression (pfx, strLimit, chLimit, needPopAll)) return MagickFalse;
       if (!*pfx->pex) break;
       if (!*strLimit) break;
       if (strchr(strLimit,*chLimit)!=NULL) break;
     }
     if (UserSymbol && !Assign && !Update && UserSymNdx0 != NULL_ADDRESS) {
       ElementT * pel;
       (void) AddAddressingElement (pfx, rCopyFrom, UserSymNdx0);
       UserSymNdx0 = NULL_ADDRESS;
       pel = &pfx->Elements[pfx->usedElements-1];
       pel->DoPush = MagickTrue;
     }
 
     if (UserSymbol) {
       while (TopOprIsUnaryPrefix (pfx)) {
         OperatorE op = pfx->OperatorStack[pfx->usedOprStack-1];
         (void) AddElement (pfx, (fxFltType) 0, op);
         pfx->usedOprStack--;
       }
     }
 
     if (!ProcessTernaryOpr (pfx, &ternary)) return MagickFalse;
 
     if (ternary.addrColon != NULL_ADDRESS) {
       if (!TranslateExpression (pfx, ",);", chLimit, needPopAll)) return MagickFalse;
       break;
     }
 
     UserSymbol = NewUserSymbol = MagickFalse;
 
     if (!*pfx->pex) break;
     if (*strLimit && (strchr(strLimit,*pfx->pex)!=NULL) ) break;
 
     if (IncrDecr) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "'++' and '--' must be the final operators in an expression at", "'%s'",
         SetShortExp(pfx));
       return MagickFalse;
     }
 
     if (!GetOperand (pfx, &UserSymbol, &NewUserSymbol, &UserSymNdx1, needPopAll)) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "Expected operand at", "'%s'",
         SetShortExp(pfx));
       return MagickFalse;
     }
     SkipSpaces (pfx);
     if (NewUserSymbol && !Assign) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "NewUserSymbol", "'%s' after non-assignment operator at '%s'",
         pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
     if (UserSymbol && !NewUserSymbol) {
       (void) AddAddressingElement (pfx, rCopyFrom, UserSymNdx1);
       UserSymNdx1 = NULL_ADDRESS;
     }
     UserSymNdx0 = UserSymNdx1;
   }
 
   if (UserSymbol && !Assign && !Update && UserSymNdx0 != NULL_ADDRESS) {
     ElementT * pel;
     if (NewUserSymbol) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "NewUserSymbol", "'%s' needs assignment operator at '%s'",
         pfx->token, SetShortExp(pfx));
       return MagickFalse;
     }
     (void) AddAddressingElement (pfx, rCopyFrom, UserSymNdx0);
     pel = &pfx->Elements[pfx->usedElements-1];
     pel->DoPush = MagickTrue;
   }
 
   if (*pfx->pex && !*chLimit && (strchr(strLimit,*pfx->pex)!=NULL)) {
     *chLimit = *pfx->pex;
     pfx->pex++;
   }
   while (pfx->usedOprStack) {
     OperatorE op = pfx->OperatorStack[pfx->usedOprStack-1];
     if (op == oOpenParen || op == oOpenBracket || op == oOpenBrace) {
       break;
     }
     if ( (op==oAssign && !Assign) || (OprInPlace(op) && !Update) ) {
       break;
     }
     pfx->usedOprStack--;
     (void) AddElement (pfx, (fxFltType) 0, op);
     if (op == oAssign) {
       /* Adjust last element, by deletion and add.
       */
       pfx->usedElements--;
       (void) AddAddressingElement (pfx, rCopyTo, UserSymNdx0);
       break;
     } else if (OprInPlace (op)) {
       /* Modify latest element.
       */
       pfx->Elements[pfx->usedElements-1].EleNdx = UserSymNdx0;
       break;
     }
   }
 
   (void) ResolveTernaryAddresses (pfx, &ternary);
 
   pfx->teDepth--;
 
   if (!pfx->teDepth && *needPopAll) {
     (void) AddAddressingElement (pfx, rZerStk, NULL_ADDRESS);
     *needPopAll = MagickFalse;
   }
 
+  if (pfx->exception->severity != UndefinedException)
+    return MagickFalse;
+
   return MagickTrue;
 }
 
@@ -2618,23 +2627,22 @@ static MagickBooleanType TranslateExpression (
 static MagickBooleanType TranslateStatement (FxInfo * pfx, char * strLimit, char * chLimit)
 {
   MagickBooleanType NeedPopAll = MagickFalse;
 
   SkipSpaces (pfx);
 
   if (!*pfx->pex) return MagickFalse;
 
   if (!TranslateExpression (pfx, strLimit, chLimit, &NeedPopAll)) {
     return MagickFalse;
   }
-
   if (pfx->usedElements && *chLimit==';') {
     /* FIXME: not necessarily the last element,
        but the last _executed_ element, eg "goto" in a "for()"., 
        Pending a fix, we will use rZerStk.
     */
     ElementT * pel = &pfx->Elements[pfx->usedElements-1];
     if (pel->DoPush) pel->DoPush = MagickFalse;
   }
 
   return MagickTrue;
 }
@@ -2642,29 +2650,32 @@ static MagickBooleanType TranslateStatement (FxInfo * pfx, char * strLimit, char
 static MagickBooleanType TranslateStatementList (FxInfo * pfx, const char * strLimit, char * chLimit)
 {
 #define MAX_SLIMIT 10
   char sLimits[MAX_SLIMIT];
   SkipSpaces (pfx);
 
   if (!*pfx->pex) return MagickFalse;
 
   (void) CopyMagickString (sLimits, strLimit, MAX_SLIMIT-1);
 
   if (strchr(strLimit,';')==NULL)
     (void) ConcatenateMagickString (sLimits, ";", MAX_SLIMIT);
 
   for (;;) {
     if (!TranslateStatement (pfx, sLimits, chLimit)) return MagickFalse;
 
     if (!*pfx->pex) break;
 
     if (*chLimit != ';') {
       break;
     }
   }
 
+  if (pfx->exception->severity != UndefinedException)
+    return MagickFalse;
+
   return MagickTrue;
 }
 
 /*--------------------------------------------------------------------
    Run-time
 */
@@ -2736,81 +2747,81 @@ static inline fxFltType PopVal (FxInfo * pfx, fxRtT * pfxrt, int addr)
 static fxFltType inline ImageStat (
   FxInfo * pfx, ssize_t ImgNum, PixelChannel channel, ImgAttrE ia)
 {
   ChannelStatistics * cs = NULL;
 
   assert (channel >= 0 && channel <= MaxPixelChannels);
 
   if (pfx->NeedStats) cs = pfx->statistics[ImgNum];
 
   switch (ia) {
     case aDepth:
       return (fxFltType) GetImageDepth (pfx->Images[ImgNum], pfx->exception);
       break;
     case aExtent:
       return (fxFltType) GetBlobSize (pfx->image);
       break;
     case aKurtosis:
       return cs[channel].kurtosis;
       break;
     case aMaxima:
       return cs[channel].maxima;
       break;
     case aMean:
       return cs[channel].mean;
       break;
     case aMedian:
       return cs[channel].median;
       break;
     case aMinima:
       return cs[channel].minima;
       break;
     case aPage:
       /* Do nothing */
       break;
-    case aPageWid:
-      return (fxFltType) pfx->Images[ImgNum]->page.width;
-    case aPageHt:
-      return (fxFltType) pfx->Images[ImgNum]->page.height;
     case aPageX:
       return (fxFltType) pfx->Images[ImgNum]->page.x;
     case aPageY:
       return (fxFltType) pfx->Images[ImgNum]->page.y;
+    case aPageWid:
+      return (fxFltType) pfx->Images[ImgNum]->page.width;
+    case aPageHt:
+      return (fxFltType) pfx->Images[ImgNum]->page.height;
     case aPrintsize:
       /* Do nothing */
       break;
     case aPrintsizeX:
       return (fxFltType) PerceptibleReciprocal (pfx->Images[ImgNum]->resolution.x) * pfx->Images[ImgNum]->columns;
     case aPrintsizeY:
       return (fxFltType) PerceptibleReciprocal (pfx->Images[ImgNum]->resolution.y) * pfx->Images[ImgNum]->rows;
     case aQuality:
       return (fxFltType) pfx->Images[ImgNum]->quality;
     case aRes:
       /* Do nothing */
       break;
     case aResX:
       return pfx->Images[ImgNum]->resolution.x;
     case aResY:
       return pfx->Images[ImgNum]->resolution.y;
     case aSkewness:
       return cs[channel].skewness;
     case aStdDev:
       return cs[channel].standard_deviation;
     case aH:
       return (fxFltType) pfx->Images[ImgNum]->rows;
     case aN:
       return (fxFltType) pfx->ImgListLen;
     case aT: /* image index in list */
       return (fxFltType) ImgNum;
     case aW:
       return (fxFltType) pfx->Images[ImgNum]->columns;
     case aZ:
       return (fxFltType) GetImageDepth (pfx->Images[ImgNum], pfx->exception);
       break;
     default:
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "Unknown ia=", "%i",
         ia);
   }
   return -99.0;
 }
@@ -2933,804 +2944,806 @@ static fxFltType inline GetIntensity (FxInfo * pfx, ssize_t ImgNum, const fxFltT
 static MagickBooleanType ExecuteRPN (FxInfo * pfx, fxRtT * pfxrt, fxFltType *result,
   const PixelChannel channel, const ssize_t imgx, const ssize_t imgy)
 {
   const Quantum * p = pfxrt->thisPixel;
   fxFltType regA=0, regB=0, regC=0, regD=0, regE=0;
   Image * img = pfx->image;
   ChannelStatistics * cs = NULL;
   double hue=0, saturation=0, lightness=0;
   int i;
 
   /* For -fx, this sets p to ImgNum 0.
      for %[fx:...], this sets p to the currrent image.
      Similarly img.
   */
   if (!p) p = GetCacheViewVirtualPixels (
     pfx->Views[pfx->ImgNum], imgx, imgy, 1, 1, pfx->exception);
 
   if (pfx->NeedStats) {
     cs = pfx->statistics[pfx->ImgNum];
   }
 
   /*  Folllowing is only for expressions like "saturation", with no image specifier.
   */
   if (pfx->NeedHsl) {
     ConvertRGBToHSL (
       GetPixelRed (img, p), GetPixelGreen (img, p), GetPixelBlue (img, p),
       &hue, &saturation, &lightness);
   }
 
   for (i=0; i < pfx->usedElements; i++) {
     ElementT *pel = &pfx->Elements[i];
       switch (pel->nArgs) {
         case 0:
           break;
         case 1:
           regA = PopVal (pfx, pfxrt, i);
           break;
         case 2:
           regB = PopVal (pfx, pfxrt, i);
           regA = PopVal (pfx, pfxrt, i);
           break;
         case 3:
           regC = PopVal (pfx, pfxrt, i);
           regB = PopVal (pfx, pfxrt, i);
           regA = PopVal (pfx, pfxrt, i);
           break;
         case 4:
           regD = PopVal (pfx, pfxrt, i);
           regC = PopVal (pfx, pfxrt, i);
           regB = PopVal (pfx, pfxrt, i);
           regA = PopVal (pfx, pfxrt, i);
           break;
         case 5:
           regE = PopVal (pfx, pfxrt, i);
           regD = PopVal (pfx, pfxrt, i);
           regC = PopVal (pfx, pfxrt, i);
           regB = PopVal (pfx, pfxrt, i);
           regA = PopVal (pfx, pfxrt, i);
           break;
         default:
           (void) ThrowMagickException (
             pfx->exception, GetMagickModule(), OptionError,
             "Too many args:", "%i", pel->nArgs);
           break;
       }
 
       switch (pel->oprNum) {
         case oAddEq:
           regA = (pfxrt->UserSymVals[pel->EleNdx] += regA);
           break;
         case oSubtractEq:
           regA = (pfxrt->UserSymVals[pel->EleNdx] -= regA);
           break;
         case oMultiplyEq:
           regA = (pfxrt->UserSymVals[pel->EleNdx] *= regA);
           break;
         case oDivideEq:
-          regA = (pfxrt->UserSymVals[pel->EleNdx] *= PerceptibleReciprocal((double) regA));
+          regA = (pfxrt->UserSymVals[pel->EleNdx] *= PerceptibleReciprocal(regA));
           break;
         case oPlusPlus:
           regA = pfxrt->UserSymVals[pel->EleNdx]++;
           break;
         case oSubSub:
           regA = pfxrt->UserSymVals[pel->EleNdx]--;
           break;
         case oAdd:
           regA += regB;
           break;
         case oSubtract:
           regA -= regB;
           break;
         case oMultiply:
           regA *= regB;
           break;
         case oDivide:
-          regA *= PerceptibleReciprocal((double) regB);
+          regA *= PerceptibleReciprocal(regB);
           break;
         case oModulus:
           regA = fmod ((double) regA, fabs(floor((double) regB+0.5)));
           break;
         case oUnaryPlus:
           /* Do nothing. */
           break;
         case oUnaryMinus:
           regA = -regA;
           break;
         case oLshift:
           regA = (fxFltType) ((size_t)(regA+0.5) << (size_t)(regB+0.5));
           break;
         case oRshift:
           regA = (fxFltType) ((size_t)(regA+0.5) >> (size_t)(regB+0.5));
           break;
         case oEq:
           regA = fabs((double) (regA-regB)) < MagickEpsilon ? 1.0 : 0.0;
           break;
         case oNotEq:
           regA = fabs((double) (regA-regB)) >= MagickEpsilon ? 1.0 : 0.0;
           break;
         case oLtEq:
           regA = (regA <= regB) ? 1.0 : 0.0;
           break;
         case oGtEq:
           regA = (regA >= regB) ? 1.0 : 0.0;
           break;
         case oLt:
           regA = (regA < regB) ? 1.0 : 0.0;
           break;
         case oGt:
           regA = (regA > regB) ? 1.0 : 0.0;
           break;
         case oLogAnd:
           regA = (regA<=0) ? 0.0 : (regB > 0) ? 1.0 : 0.0;
           break;
         case oLogOr:
           regA = (regA>0) ? 1.0 : (regB > 0.0) ? 1.0 : 0.0;
           break;
         case oLogNot:
           regA = (regA==0) ? 1.0 : 0.0;
           break;
         case oBitAnd:
           regA = (fxFltType) ((size_t)(regA+0.5) & (size_t)(regB+0.5));
           break;
         case oBitOr:
           regA = (fxFltType) ((size_t)(regA+0.5) | (size_t)(regB+0.5));
           break;
         case oBitNot:
           /* Old fx doesn't add 0.5. */
           regA = (fxFltType) (~(size_t)(regA+0.5));
           break;
         case oPow:
           regA = pow ((double) regA, (double) regB);
           break;
         case oQuery:
         case oColon:
           break;
         case oOpenParen:
         case oCloseParen:
         case oOpenBracket:
         case oCloseBracket:
         case oOpenBrace:
         case oCloseBrace:
           break;
         case oAssign:
           pel->val = regA;
           break;
         case oNull: {
           if (pel->type == etColourConstant) {
             switch (channel) {
               default:
               case 0:
                 regA = pel->val;
                 break;
               case 1:
                 regA = pel->val1;
                 break;
               case 2:
                 regA = pel->val2;
                 break;
             }
           } else {
             regA = pel->val;
           }
           break;
         }
         case fAbs:
           regA = fabs ((double) regA);
           break;
 #if defined(MAGICKCORE_HAVE_ACOSH)
         case fAcosh:
           regA = acosh ((double) regA);
           break;
 #endif
         case fAcos:
           regA = acos ((double) regA);
           break;
 #if defined(MAGICKCORE_HAVE_J1)
         case fAiry:
           if (regA==0) regA = 1.0;
           else {
             fxFltType gamma = 2.0 * j1 ((MagickPI*regA)) / (MagickPI*regA);
             regA = gamma * gamma;
           }
           break;
 #endif
         case fAlt:
           regA = (fxFltType) (((ssize_t) regA) & 0x01 ? -1.0 : 1.0);
           break;
 #if defined(MAGICKCORE_HAVE_ASINH)
         case fAsinh:
           regA = asinh ((double) regA);
           break;
 #endif
         case fAsin:
           regA = asin ((double) regA);
           break;
 #if defined(MAGICKCORE_HAVE_ATANH)
         case fAtanh:
           regA = atanh ((double) regA);
           break;
 #endif
         case fAtan2:
           regA = atan2 ((double) regA, (double) regB);
           break;
         case fAtan:
           regA = atan ((double) regA);
           break;
         case fCeil:
           regA = ceil ((double) regA);
           break;
         case fChannel:
           switch (channel) {
             case 0: break;
             case 1: regA = regB; break;
             case 2: regA = regC; break;
             case 3: regA = regD; break;
             case 4: regA = regE; break;
             default: regA = 0.0;
           }
           break;
         case fClamp:
           if (regA < 0) regA = 0.0;
           else if (regA > 1.0) regA = 1.0;
           break;
         case fCosh:
           regA = cosh ((double) regA);
           break;
         case fCos:
           regA = cos ((double) regA);
           break;
         case fDebug:
           /* FIXME: debug() should give channel name. */
 
           fprintf (stderr, "%s[%g,%g].%i: %s=%.*Lg\n",
                    img->filename, (double) imgx, (double) imgy,
                    channel, SetPtrShortExp (pfx, pel->pExpStart, (size_t) (pel->lenExp+1)),
                    pfx->precision, regA);
           break;
         case fDrc:
           regA = regA / (regB*(regA-1.0) + 1.0);
           break;
 #if defined(MAGICKCORE_HAVE_ERF)
         case fErf:
           regA = erf ((double) regA);
           break;
 #endif
         case fExp:
           regA = exp ((double) regA);
           break;
         case fFloor:
           regA = floor ((double) regA);
           break;
         case fGauss:
           regA = exp((double) (-regA*regA/2.0))/sqrt(2.0*MagickPI);
           break;
         case fGcd:
           if (!IsNaN(regA)) 
             regA = FxGcd (regA, regB, 0);
           break;
         case fHypot:
           regA = hypot ((double) regA, (double) regB);
           break;
         case fInt:
           regA = floor ((double) regA);
           break;
         case fIsnan:
           regA = (fxFltType) (!!IsNaN (regA));
           break;
 #if defined(MAGICKCORE_HAVE_J0)
         case fJ0:
           regA = j0 ((double) regA);
           break;
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
         case fJ1:
           regA = j1 ((double) regA);
           break;
 #endif
 #if defined(MAGICKCORE_HAVE_J1)
         case fJinc:
           if (regA==0) regA = 1.0;
           else regA = 2.0 * j1 ((MagickPI*regA))/(MagickPI*regA);
           break;
 #endif
         case fLn:
           regA = log ((double) regA);
           break;
         case fLogtwo:
           regA = log10((double) regA) / log10(2.0);
           break;
         case fLog:
           regA = log10 ((double) regA);
           break;
         case fMax:
           regA = (regA > regB) ? regA : regB;
           break;
         case fMin:
           regA = (regA < regB) ? regA : regB;
           break;
         case fMod:
           regA = regA - floor((double) (regA*PerceptibleReciprocal((double) regB)))*regB;
           break;
         case fNot:
           regA = (fxFltType) (regA < MagickEpsilon);
           break;
         case fPow:
           regA = pow ((double) regA, (double) regB);
           break;
         case fRand: {
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
           #pragma omp critical (MagickCore_ExecuteRPN)
 #endif
           regA = GetPseudoRandomValue (pfxrt->random_info);
           break;
         }
         case fRound:
           regA = floor ((double) regA + 0.5);
           break;
         case fSign:
           regA = (regA < 0) ? -1.0 : 1.0;
           break;
         case fSinc:
           regA = sin ((double) (MagickPI*regA)) / (MagickPI*regA);
           break;
         case fSinh:
           regA = sinh ((double) regA);
           break;
         case fSin:
           regA = sin ((double) regA);
           break;
         case fSqrt:
           regA = sqrt ((double) regA);
           break;
         case fSquish:
           regA = 1.0 / (1.0 + exp ((double) -regA));
           break;
         case fTanh:
           regA = tanh ((double) regA);
           break;
         case fTan:
           regA = tan ((double) regA);
           break;
         case fTrunc:
           if (regA >= 0) regA = floor ((double) regA);
           else regA = ceil ((double) regA);
           break;
 
         case fDo:
         case fFor:
         case fIf:
         case fWhile:
           break;
         case fU: {
           /* Note: 1 value is available, index into image list.
              May have ImgAttr qualifier or channel qualifier or both.
           */
           ssize_t ImgNum = ChkImgNum (pfx, regA);
           regA = (fxFltType) 0;
           if (ImgNum == 0) {
             Image * pimg = pfx->Images[0];
             int pech = (int)pel->ChannelQual;
             if (pel->ImgAttrQual == aNull) {
               if (pech < 0) {
                 if (pech == NO_CHAN_QUAL || pech == THIS_CHANNEL) {
                   if (pfx->ImgNum==0) {
                     regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                   } else {
                     const Quantum * pv = GetCacheViewVirtualPixels (
                                    pfx->Views[0], imgx, imgy, 1,1, pfx->exception);
                     if (!pv) {
                       (void) ThrowMagickException (
                         pfx->exception, GetMagickModule(), OptionError,
                         "fU can't get cache", "%lu", ImgNum);
                       break;
                     }
                     regA = QuantumScale * pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                   }
                 } else if (pech == HUE_CHANNEL || pech == SAT_CHANNEL ||
                     pech == LIGHT_CHANNEL) {
                   regA = GetHslInt (pfx, ImgNum, imgx, imgy, pech);
                   break;
                 } else if (pech == INTENSITY_CHANNEL) {
                   regA = GetIntensity (pfx, 0, (double) imgx, (double) imgy);
                   break;
                 }
               } else {
                 if (pfx->ImgNum==0) {
                   regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                 } else {
                   const Quantum * pv = GetCacheViewVirtualPixels (
                                  pfx->Views[0], imgx, imgy, 1,1, pfx->exception);
                   if (!pv) {
                     (void) ThrowMagickException (
                       pfx->exception, GetMagickModule(), OptionError,
                       "fU can't get cache", "%lu", ImgNum);
                     break;
                   }
                   regA = QuantumScale * pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
                 }
               }
             } else {
               /* we have an image atttribute */
               regA = ImageStat (pfx, 0, WHICH_ATTR_CHAN, pel->ImgAttrQual);
             }
           } else {
             /* We have non-zero ImgNum. */
             if (pel->ImgAttrQual == aNull) {
               const Quantum * pv;
               if ((int)pel->ChannelQual < 0) {
                 if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                     pel->ChannelQual == LIGHT_CHANNEL)
                 {
                   regA = GetHslInt (pfx, ImgNum, imgx, imgy, pel->ChannelQual);
                   break;
                 } else if (pel->ChannelQual == INTENSITY_CHANNEL)
                 {
                   regA = GetIntensity (pfx, ImgNum, (fxFltType) imgx, (fxFltType) imgy);
                   break;
                 }
               }
 
               pv = GetCacheViewVirtualPixels (
                      pfx->Views[ImgNum], imgx, imgy, 1,1, pfx->exception);
               if (!pv) {
                 (void) ThrowMagickException (
                   pfx->exception, GetMagickModule(), OptionError,
                   "fU can't get cache", "%lu", ImgNum);
                 break;
               }
               regA = QuantumScale *
          pv[pfx->Images[ImgNum]->channel_map[WHICH_NON_ATTR_CHAN].offset];
             } else {
               regA = ImageStat (pfx, ImgNum, WHICH_ATTR_CHAN, pel->ImgAttrQual);
             }
           }
           break;
         }
         case fU0: {
           /* No args. No image attribute. We may have a ChannelQual.
              If called from %[fx:...], ChannelQual will be CompositePixelChannel.
           */
           Image * pimg = pfx->Images[0];
           int pech = (int)pel->ChannelQual;
           if (pech < 0) {
             if (pech == NO_CHAN_QUAL || pech == THIS_CHANNEL) {
 
               if (pfx->ImgNum==0) {
                 regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
               } else {
                 const Quantum * pv = GetCacheViewVirtualPixels (
                                pfx->Views[0], imgx, imgy, 1,1, pfx->exception);
                 if (!pv) {
                   (void) ThrowMagickException (
                     pfx->exception, GetMagickModule(), OptionError,
                     "fU0 can't get cache", "%i", 0);
                   break;
                 }
                 regA = QuantumScale * pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
               }
 
             } else if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                        pel->ChannelQual == LIGHT_CHANNEL) {
               regA = GetHslInt (pfx, 0, imgx, imgy, pel->ChannelQual);
               break;
             } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
               regA = GetIntensity (pfx, 0, (fxFltType) imgx, (fxFltType) imgy);
             }
           } else {
             if (pfx->ImgNum==0) {
               regA = QuantumScale * p[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
             } else {
               const Quantum * pv = GetCacheViewVirtualPixels (
                                    pfx->Views[0], imgx, imgy, 1,1, pfx->exception);
               if (!pv) {
                 (void) ThrowMagickException (
                   pfx->exception, GetMagickModule(), OptionError,
                   "fU0 can't get cache", "%i", 0);
                 break;
               }
               regA = QuantumScale * pv[pimg->channel_map[WHICH_NON_ATTR_CHAN].offset];
             }
           }
           break;
         }
         case fUP: {
           /* 3 args are: ImgNum, x, y */
           ssize_t ImgNum = ChkImgNum (pfx, regA);
 
           fxFltType fx, fy;
           if (pel->IsRelative) {
             fx = imgx + regB;
             fy = imgy + regC;
           } else {
             fx = regB;
             fy = regC;
           }
 
           if ((int)pel->ChannelQual < 0) {
             if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL
              || pel->ChannelQual == LIGHT_CHANNEL) {
               regA = GetHslFlt (pfx, ImgNum, fx, fy, pel->ChannelQual);
               break;
             } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
               regA = GetIntensity (pfx, ImgNum, fx, fy);
               break;
             }
           }
 
           {
             double v;
             Image * imUP = pfx->Images[ImgNum];
             if (! InterpolatePixelChannel (imUP, pfx->Views[ImgNum], WHICH_NON_ATTR_CHAN,
                     imUP->interpolate, (double) fx, (double) fy, &v, pfx->exception))
             {
               (void) ThrowMagickException (
                 pfx->exception, GetMagickModule(), OptionError,
                 "fUP can't get interpolate", "%lu", ImgNum);
               break;
             }
             regA = v * QuantumScale;
           }
 
           break;
         }
         case fS:
         case fV: {
           /* No args. */
           ssize_t ImgNum = 1;
           if (pel->oprNum == fS) ImgNum = pfx->ImgNum;
 
           if (pel->ImgAttrQual == aNull) {
             const Quantum * pv = GetCacheViewVirtualPixels (
                                    pfx->Views[ImgNum], imgx, imgy, 1,1, pfx->exception);
             if (!pv) {
               (void) ThrowMagickException (
                 pfx->exception, GetMagickModule(), OptionError,
                 "fV can't get cache", "%lu", ImgNum);
               break;
             }
 
             if ((int)pel->ChannelQual < 0) {
               if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                   pel->ChannelQual == LIGHT_CHANNEL) {
                 regA = GetHslInt (pfx, ImgNum, imgx, imgy, pel->ChannelQual);
                 break;
               } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
                 regA = GetIntensity (pfx, ImgNum, (double) imgx, (double) imgy);
                 break;
               }
             }
 
             regA = QuantumScale *
          pv[pfx->Images[ImgNum]->channel_map[WHICH_NON_ATTR_CHAN].offset];
           } else {
             regA = ImageStat (pfx, ImgNum, WHICH_ATTR_CHAN, pel->ImgAttrQual);
           }
 
           break;
         }
         case fP:
         case fSP:
         case fVP: {
           /* 2 args are: x, y */
           fxFltType fx, fy;
           ssize_t ImgNum = pfx->ImgNum;
           if (pel->oprNum == fVP) ImgNum = 1;
           if (pel->IsRelative) {
             fx = imgx + regA;
             fy = imgy + regB;
           } else {
             fx = regA;
             fy = regB;
           }
           if ((int)pel->ChannelQual < 0) {
             if (pel->ChannelQual == HUE_CHANNEL || pel->ChannelQual == SAT_CHANNEL ||
                 pel->ChannelQual == LIGHT_CHANNEL) {
               regA = GetHslFlt (pfx, ImgNum, fx, fy, pel->ChannelQual);
               break;
             } else if (pel->ChannelQual == INTENSITY_CHANNEL) {
               regA = GetIntensity (pfx, ImgNum, fx, fy);
             }
           }
 
           {
             double v;
 
             if (! InterpolatePixelChannel (pfx->Images[ImgNum], pfx->Views[ImgNum],
                                            WHICH_NON_ATTR_CHAN, pfx->Images[ImgNum]->interpolate,
                                            (double) fx, (double) fy, &v, pfx->exception)
                                           )
             {
               (void) ThrowMagickException (
                 pfx->exception, GetMagickModule(), OptionError,
                 "fSP or fVP can't get interp", "%lu", ImgNum);
               break;
             }
             regA = v * (fxFltType)QuantumScale;
           }
 
           break;
         }
         case fNull:
           break;
         case aDepth:
           regA = (fxFltType) GetImageDepth (img, pfx->exception) / QuantumRange;
           break;
         case aExtent:
           regA = (fxFltType) img->extent;
           break;
         case aKurtosis:
           regA = cs[WHICH_ATTR_CHAN].kurtosis;
           break;
         case aMaxima:
           regA = cs[WHICH_ATTR_CHAN].maxima;
           break;
         case aMean:
           regA = cs[WHICH_ATTR_CHAN].mean;
           break;
         case aMedian:
           regA = cs[WHICH_ATTR_CHAN].median;
           break;
         case aMinima:
           regA = cs[WHICH_ATTR_CHAN].minima;
           break;
         case aPage:
           break;
-        case aPageWid:
-          regA = (fxFltType) img->page.width;
-          break;
-        case aPageHt:
-          regA = (fxFltType) img->page.height;
-          break;
         case aPageX:
           regA = (fxFltType) img->page.x;
           break;
         case aPageY:
           regA = (fxFltType) img->page.y;
           break;
+        case aPageWid:
+          regA = (fxFltType) img->page.width;
+          break;
+        case aPageHt:
+          regA = (fxFltType) img->page.height;
+          break;
         case aPrintsize:
           break;
         case aPrintsizeX:
           regA = (fxFltType) PerceptibleReciprocal (img->resolution.x) * img->columns;
           break;
         case aPrintsizeY:
           regA = (fxFltType) PerceptibleReciprocal (img->resolution.y) * img->rows;
           break;
         case aQuality:
           regA = (fxFltType) img->quality;
           break;
         case aRes:
           break;
         case aResX:
           regA = (fxFltType) img->resolution.x;
           break;
         case aResY:
           regA = (fxFltType) img->resolution.y;
           break;
         case aSkewness:
           regA = cs[WHICH_ATTR_CHAN].skewness;
           break;
         case aStdDev:
           regA = cs[WHICH_ATTR_CHAN].standard_deviation;
           break;
         case aH: /* image->rows */
           regA = (fxFltType) img->rows;
           break;
         case aN: /* image list length */
           regA = (fxFltType) pfx->ImgListLen;
           break;
         case aT: /* image index in list */
           regA = (fxFltType) pfx->ImgNum;
           break;
         case aW: /* image->columns */
           regA = (fxFltType) img->columns;
           break;
         case aZ: /* image depth */
           regA = (fxFltType) GetImageDepth (img, pfx->exception);
           break;
         case aNull:
           break;
         case sHue: /* of conversion to HSL */
           regA = hue;
           break;
         case sIntensity:
           regA = GetIntensity (pfx, pfx->ImgNum, (double) imgx, (double) imgy);
           break;
         case sLightness: /* of conversion to HSL */
           regA = lightness;
           break;
         case sLuma: /* calculation */
         case sLuminance: /* as Luma */
           regA = QuantumScale * (0.212656 * GetPixelRed (img,p) +
                                  0.715158 * GetPixelGreen (img,p) +
                                  0.072186 * GetPixelBlue (img,p));
           break;
         case sSaturation: /* from conversion to HSL */
           regA = saturation;
           break;
         case sA: /* alpha */
           regA = QuantumScale * GetPixelAlpha (img, p);
           break;
         case sB: /* blue */
           regA = QuantumScale * GetPixelBlue (img, p);
           break;
         case sC: /* red (ie cyan) */
           regA = QuantumScale * GetPixelCyan (img, p);
           break;
         case sG: /* green */
           regA = QuantumScale * GetPixelGreen (img, p);
           break;
         case sI: /* current x-coordinate */
           regA = (fxFltType) imgx;
           break;
         case sJ: /* current y-coordinate */
           regA = (fxFltType) imgy;
           break;
         case sK: /* black of CMYK */
           regA = QuantumScale * GetPixelBlack (img, p);
           break;
         case sM: /* green (ie magenta) */
           regA = QuantumScale * GetPixelGreen (img, p);
           break;
         case sO: /* alpha */
           regA = QuantumScale * GetPixelAlpha (img, p);
           break;
         case sR:
           regA = QuantumScale * GetPixelRed (img, p);
           break;
         case sY:
           regA = QuantumScale * GetPixelYellow (img, p);
           break;
         case sNull:
           break;
 
         case rGoto:
           i = pel->EleNdx-1; /* -1 because 'for' loop will increment. */
           break;
         case rIfZeroGoto:
           if (fabs((double) regA) < MagickEpsilon) i = pel->EleNdx-1;
           break;
         case rIfNotZeroGoto:
           if (fabs((double) regA) > MagickEpsilon) i = pel->EleNdx-1;
           break;
         case rCopyFrom:
           regA = pfxrt->UserSymVals[pel->EleNdx];
           break;
         case rCopyTo:
           pfxrt->UserSymVals[pel->EleNdx] = regA;
           break;
         case rZerStk:
           pfxrt->usedValStack = 0;
           break;
         case rNull:
           break;
 
         default:
           (void) ThrowMagickException (
             pfx->exception, GetMagickModule(), OptionError,
             "pel->oprNum", "%i '%s' not yet implemented",
             (int)pel->oprNum, OprStr(pel->oprNum));
           break;
     }
     if (i < 0) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), OptionError,
         "Bad run-time address", "%i", i);
     }
     if (pel->DoPush) 
       if (!PushVal (pfx, pfxrt, regA, i)) break;
   }
 
   if (pfxrt->usedValStack > 0) regA = PopVal (pfx, pfxrt, 9999);
 
   *result = regA;
 
   if (pfxrt->usedValStack != 0) {
-    fprintf (stderr, "ValStack not empty (%i)\n", pfxrt->usedValStack);
+      (void) ThrowMagickException (
+        pfx->exception, GetMagickModule(), OptionError,
+        "ValStack not empty", "(%i)", pfxrt->usedValStack);
     return MagickFalse;
   }
 
   return MagickTrue;
 }
 
 /* Following is substitute for FxEvaluateChannelExpression().
 */
@@ -3767,77 +3780,105 @@ MagickPrivate MagickBooleanType FxEvaluateChannelExpression (
 FxInfo *AcquireFxInfo (const Image * images, const char * expression, ExceptionInfo *exception)
 {
   char chLimit;
 
   FxInfo * pfx = (FxInfo*) AcquireCriticalMemory (sizeof (*pfx));
 
   memset (pfx, 0, sizeof (*pfx));
 
-  if (!InitFx (pfx, images, exception)) return NULL;
-
-  if (!BuildRPN (pfx)) return NULL;
+  if (!InitFx (pfx, images, exception)) {
+    pfx = (FxInfo*) RelinquishMagickMemory(pfx);
+    return NULL;
+  }
 
-  pfx->pex = (char *)expression;
+  if (!BuildRPN (pfx)) {
+    (void) DeInitFx (pfx);
+    pfx = (FxInfo*) RelinquishMagickMemory(pfx);
+    return NULL;
+  }
 
   if (*expression == '@')
     pfx->expression = FileToString (expression+1, ~0UL, exception);
   else
     pfx->expression = ConstantString (expression);
 
-  pfx->pex = pfx->expression;
+  pfx->pex = (char *)pfx->expression;
 
   pfx->teDepth = 0;
   if (!TranslateStatementList (pfx, ";", &chLimit)) return NULL;
 
   if (pfx->teDepth) {
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
       "Translate expression depth", "(%i) not 0",
       pfx->teDepth);
+
+    (void) DestroyRPN (pfx);
+    (void) DeInitFx (pfx);
+    pfx = (FxInfo*) RelinquishMagickMemory(pfx);
     return NULL;
   }
 
   if (chLimit != '\0' && chLimit != ';') {
-    fprintf (stderr, "AcquireFxInfo: TranslateExpression did not exhaust input '%s' chLimit='%c'\n",
-             pfx->pex, chLimit ? chLimit : ' ');
-
     (void) ThrowMagickException (
       pfx->exception, GetMagickModule(), OptionError,
-      "AcquireFxInfo: TranslateExpression did not exhaust input at", "'%s'",
-      pfx->pex);
+      "AcquireFxInfo: TranslateExpression did not exhaust input", "(chLimit=%i) at'%s'",
+      (int)chLimit, pfx->pex);
+
+    (void) DestroyRPN (pfx);
+    (void) DeInitFx (pfx);
+    pfx = (FxInfo*) RelinquishMagickMemory(pfx);
     return NULL;
   }
 
   if (pfx->NeedStats && !pfx->statistics) {
-    if (!CollectStatistics (pfx)) return NULL;
+    if (!CollectStatistics (pfx)) {
+      (void) DestroyRPN (pfx);
+      (void) DeInitFx (pfx);
+      pfx = (FxInfo*) RelinquishMagickMemory(pfx);
+      return NULL;
+    }
   }
 
   if (pfx->DebugOpt) {
     DumpTables (stderr);
     DumpUserSymbols (pfx, stderr);
     (void) DumpRPN (pfx, stderr);
   }
 
   {
     size_t number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
     ssize_t t;
 
     pfx->fxrts = (fxRtT *)AcquireQuantumMemory (number_threads, sizeof(fxRtT));
     if (!pfx->fxrts) {
       (void) ThrowMagickException (
         pfx->exception, GetMagickModule(), ResourceLimitFatalError,
         "fxrts", "%lu",
         number_threads);
+      (void) DestroyRPN (pfx);
+      (void) DeInitFx (pfx);
+      pfx = (FxInfo*) RelinquishMagickMemory(pfx);
       return NULL;
     }
     for (t=0; t < (ssize_t) number_threads; t++) {
       if (!AllocFxRt (pfx, &pfx->fxrts[t])) {
         (void) ThrowMagickException (
           pfx->exception, GetMagickModule(), ResourceLimitFatalError,
           "AllocFxRt t=", "%g",
           (double) t);
+        {
+          ssize_t t2;
+          for (t2 = t-1; t2 >= 0; t2--) {
+            DestroyFxRt (&pfx->fxrts[t]);
+          }
+        }
+        pfx->fxrts = (fxRtT *) RelinquishMagickMemory (pfx->fxrts);
+        (void) DestroyRPN (pfx);
+        (void) DeInitFx (pfx);
+        pfx = (FxInfo*) RelinquishMagickMemory(pfx);
         return NULL;
       }
     }
   }
   return pfx;
 }
