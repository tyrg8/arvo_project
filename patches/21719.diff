commit 25cd2a23a6b7057af0e898c613e5f4acf168a11c
Author: Luca Deri <deri@ntop.org>
Date:   Mon Apr 20 15:08:51 2020 +0200

    Compilation fixes

diff --git a/example/reader_util.c b/example/reader_util.c
index dadffb8c..73d580cc 100644
--- a/example/reader_util.c
+++ b/example/reader_util.c
@@ -650,267 +650,267 @@ float ndpi_flow_get_byte_count_entropy(const uint32_t byte_count[256],
 static struct ndpi_flow_info *get_ndpi_flow_info(struct ndpi_workflow * workflow,
 						 const u_int8_t version,
 						 u_int16_t vlan_id,
 						 ndpi_packet_tunnel tunnel_type,
 						 const struct ndpi_iphdr *iph,
 						 const struct ndpi_ipv6hdr *iph6,
 						 u_int16_t ip_offset,
 						 u_int16_t ipsize,
 						 u_int16_t l4_packet_len,
 						 struct ndpi_tcphdr **tcph,
 						 struct ndpi_udphdr **udph,
 						 u_int16_t *sport, u_int16_t *dport,
 						 struct ndpi_id_struct **src,
 						 struct ndpi_id_struct **dst,
 						 u_int8_t *proto,
 						 u_int8_t **payload,
 						 u_int16_t *payload_len,
 						 u_int8_t *src_to_dst_direction,
                                                  struct timeval when) {
   u_int32_t idx, l4_offset, hashval;
   struct ndpi_flow_info flow;
   void *ret;
   const u_int8_t *l3, *l4;
   u_int32_t l4_data_len = 0XFEEDFACE;
 
   /*
     Note: to keep things simple (ndpiReader is just a demo app)
     we handle IPv6 a-la-IPv4.
   */
   if(version == IPVERSION) {
     if(ipsize < 20)
       return NULL;
 
     if((iph->ihl * 4) > ipsize || ipsize < ntohs(iph->tot_len)
        /* || (iph->frag_off & htons(0x1FFF)) != 0 */)
       return NULL;
 
     l4_offset = iph->ihl * 4;
     l3 = (const u_int8_t*)iph;
   } else {
     l4_offset = sizeof(struct ndpi_ipv6hdr);
     if(sizeof(struct ndpi_ipv6hdr) > ipsize)
       return NULL;
 
     l3 = (const u_int8_t*)iph6;
   }
-  if (ipsize < l4_offset + l4_packet_len)
+  if(ipsize < l4_offset + l4_packet_len)
     return NULL;
 
   *proto = iph->protocol;
 
   if(l4_packet_len < 64)
     workflow->stats.packet_len[0]++;
   else if(l4_packet_len >= 64 && l4_packet_len < 128)
     workflow->stats.packet_len[1]++;
   else if(l4_packet_len >= 128 && l4_packet_len < 256)
     workflow->stats.packet_len[2]++;
   else if(l4_packet_len >= 256 && l4_packet_len < 1024)
     workflow->stats.packet_len[3]++;
   else if(l4_packet_len >= 1024 && l4_packet_len < 1500)
     workflow->stats.packet_len[4]++;
   else if(l4_packet_len >= 1500)
     workflow->stats.packet_len[5]++;
 
   if(l4_packet_len > workflow->stats.max_packet_len)
     workflow->stats.max_packet_len = l4_packet_len;
 
   l4 =& ((const u_int8_t *) l3)[l4_offset];
 
   if(*proto == IPPROTO_TCP && l4_packet_len >= sizeof(struct ndpi_tcphdr)) {
     u_int tcp_len;
 
     // TCP
     workflow->stats.tcp_count++;
     *tcph = (struct ndpi_tcphdr *)l4;
     *sport = ntohs((*tcph)->source), *dport = ntohs((*tcph)->dest);
     tcp_len = ndpi_min(4*(*tcph)->doff, l4_packet_len);
     *payload = (u_int8_t*)&l4[tcp_len];
     *payload_len = ndpi_max(0, l4_packet_len-4*(*tcph)->doff);
     l4_data_len = l4_packet_len - sizeof(struct ndpi_tcphdr);
   } else if(*proto == IPPROTO_UDP && l4_packet_len >= sizeof(struct ndpi_udphdr)) {
     // UDP
     workflow->stats.udp_count++;
     *udph = (struct ndpi_udphdr *)l4;
     *sport = ntohs((*udph)->source), *dport = ntohs((*udph)->dest);
     *payload = (u_int8_t*)&l4[sizeof(struct ndpi_udphdr)];
     *payload_len = (l4_packet_len > sizeof(struct ndpi_udphdr)) ? l4_packet_len-sizeof(struct ndpi_udphdr) : 0;
     l4_data_len = l4_packet_len - sizeof(struct ndpi_udphdr);
   } else if(*proto == IPPROTO_ICMP) {
     *payload = (u_int8_t*)&l4[sizeof(struct ndpi_icmphdr )];
     *payload_len = (l4_packet_len > sizeof(struct ndpi_icmphdr)) ? l4_packet_len-sizeof(struct ndpi_icmphdr) : 0;
     l4_data_len = l4_packet_len - sizeof(struct ndpi_icmphdr);
     *sport = *dport = 0;
   } else if(*proto == IPPROTO_ICMPV6) {
     *payload = (u_int8_t*)&l4[sizeof(struct ndpi_icmp6hdr)];
     *payload_len = (l4_packet_len > sizeof(struct ndpi_icmp6hdr)) ? l4_packet_len-sizeof(struct ndpi_icmp6hdr) : 0;
     l4_data_len = l4_packet_len - sizeof(struct ndpi_icmp6hdr);
     *sport = *dport = 0;
   } else {
     // non tcp/udp protocols
     *sport = *dport = 0;
     l4_data_len = 0;
   }
 
   flow.protocol = iph->protocol, flow.vlan_id = vlan_id;
   flow.src_ip = iph->saddr, flow.dst_ip = iph->daddr;
   flow.src_port = htons(*sport), flow.dst_port = htons(*dport);
   flow.hashval = hashval = flow.protocol + flow.vlan_id + flow.src_ip + flow.dst_ip + flow.src_port + flow.dst_port;
 
 #if 0
   printf("hashval=%u [%u][%u][%u:%u][%u:%u]\n", hashval, flow.protocol, flow.vlan_id,
 	 flow.src_ip, flow.src_port, flow.dst_ip, flow.dst_port);
 #endif
 
   idx = hashval % workflow->prefs.num_roots;
   ret = ndpi_tfind(&flow, &workflow->ndpi_flows_root[idx], ndpi_workflow_node_cmp);
 
   /* to avoid two nodes in one binary tree for a flow */
   int is_changed = 0;
   if(ret == NULL) {
     u_int32_t orig_src_ip = flow.src_ip;
     u_int16_t orig_src_port = flow.src_port;
     u_int32_t orig_dst_ip = flow.dst_ip;
     u_int16_t orig_dst_port = flow.dst_port;
 
     flow.src_ip = orig_dst_ip;
     flow.src_port = orig_dst_port;
     flow.dst_ip = orig_src_ip;
     flow.dst_port = orig_src_port;
 
     is_changed = 1;
 
     ret = ndpi_tfind(&flow, &workflow->ndpi_flows_root[idx], ndpi_workflow_node_cmp);
   }
 
   if(ret == NULL) {
     if(workflow->stats.ndpi_flow_count == workflow->prefs.max_ndpi_flows) {
       NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_ERROR,
 	       "maximum flow count (%u) has been exceeded\n",
 	       workflow->prefs.max_ndpi_flows);
       exit(-1);
     } else {
       struct ndpi_flow_info *newflow = (struct ndpi_flow_info*)malloc(sizeof(struct ndpi_flow_info));
 
       if(newflow == NULL) {
 	NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_ERROR, "[NDPI] %s(1): not enough memory\n", __FUNCTION__);
 	return(NULL);
       } else
         workflow->num_allocated_flows++;
 
       memset(newflow, 0, sizeof(struct ndpi_flow_info));
       newflow->flow_id = flow_id++;
       newflow->hashval = hashval;
       newflow->tunnel_type = tunnel_type;
       newflow->protocol = iph->protocol, newflow->vlan_id = vlan_id;
       newflow->src_ip = iph->saddr, newflow->dst_ip = iph->daddr;
       newflow->src_port = htons(*sport), newflow->dst_port = htons(*dport);
       newflow->ip_version = version;
       newflow->iat_c_to_s = ndpi_alloc_data_analysis(DATA_ANALUYSIS_SLIDING_WINDOW),
 	newflow->iat_s_to_c =  ndpi_alloc_data_analysis(DATA_ANALUYSIS_SLIDING_WINDOW);
       newflow->pktlen_c_to_s = ndpi_alloc_data_analysis(DATA_ANALUYSIS_SLIDING_WINDOW),
 	newflow->pktlen_s_to_c =  ndpi_alloc_data_analysis(DATA_ANALUYSIS_SLIDING_WINDOW),
 	newflow->iat_flow = ndpi_alloc_data_analysis(DATA_ANALUYSIS_SLIDING_WINDOW);
 
       if(version == IPVERSION) {
 	inet_ntop(AF_INET, &newflow->src_ip, newflow->src_name, sizeof(newflow->src_name));
 	inet_ntop(AF_INET, &newflow->dst_ip, newflow->dst_name, sizeof(newflow->dst_name));
       } else {
 	inet_ntop(AF_INET6, &iph6->ip6_src, newflow->src_name, sizeof(newflow->src_name));
 	inet_ntop(AF_INET6, &iph6->ip6_dst, newflow->dst_name, sizeof(newflow->dst_name));
 	/* For consistency across platforms replace :0: with :: */
 	ndpi_patchIPv6Address(newflow->src_name), ndpi_patchIPv6Address(newflow->dst_name);
       }
 
       if((newflow->ndpi_flow = ndpi_flow_malloc(SIZEOF_FLOW_STRUCT)) == NULL) {
 	NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_ERROR, "[NDPI] %s(2): not enough memory\n", __FUNCTION__);
 	free(newflow);
 	return(NULL);
       } else
 	memset(newflow->ndpi_flow, 0, SIZEOF_FLOW_STRUCT);
 
       if((newflow->src_id = ndpi_malloc(SIZEOF_ID_STRUCT)) == NULL) {
 	NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_ERROR, "[NDPI] %s(3): not enough memory\n", __FUNCTION__);
 	free(newflow);
 	return(NULL);
       } else
 	memset(newflow->src_id, 0, SIZEOF_ID_STRUCT);
 
       if((newflow->dst_id = ndpi_malloc(SIZEOF_ID_STRUCT)) == NULL) {
 	NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_ERROR, "[NDPI] %s(4): not enough memory\n", __FUNCTION__);
 	free(newflow);
 	return(NULL);
       } else
 	memset(newflow->dst_id, 0, SIZEOF_ID_STRUCT);
 
       ndpi_tsearch(newflow, &workflow->ndpi_flows_root[idx], ndpi_workflow_node_cmp); /* Add */
       workflow->stats.ndpi_flow_count++;
 
       *src = newflow->src_id, *dst = newflow->dst_id;
       newflow->entropy.src2dst_pkt_len[newflow->entropy.src2dst_pkt_count] = l4_data_len;
       newflow->entropy.src2dst_pkt_time[newflow->entropy.src2dst_pkt_count] = when;
-      if (newflow->entropy.src2dst_pkt_count == 0) {
+      if(newflow->entropy.src2dst_pkt_count == 0) {
         newflow->entropy.src2dst_start = when;
       }
       newflow->entropy.src2dst_pkt_count++;
       // Non zero app data.
-      if (l4_data_len != 0XFEEDFACE && l4_data_len != 0) {
+      if(l4_data_len != 0XFEEDFACE && l4_data_len != 0) {
         newflow->entropy.src2dst_opackets++;
         newflow->entropy.src2dst_l4_bytes += l4_data_len;
       }
       return newflow;
     }
   } else {
     struct ndpi_flow_info *rflow = *(struct ndpi_flow_info**)ret;
 
     if(is_changed) {
       if(rflow->src_ip == iph->saddr
 	 && rflow->dst_ip == iph->daddr
 	 && rflow->src_port == htons(*sport)
 	 && rflow->dst_port == htons(*dport)
 	 )
 	*src = rflow->dst_id, *dst = rflow->src_id, *src_to_dst_direction = 0, rflow->bidirectional = 1;
       else
 	*src = rflow->src_id, *dst = rflow->dst_id, *src_to_dst_direction = 1;
     }
     else {
       if(rflow->src_ip == iph->saddr
 	 && rflow->dst_ip == iph->daddr
 	 && rflow->src_port == htons(*sport)
 	 && rflow->dst_port == htons(*dport)
 	 )
 	*src = rflow->src_id, *dst = rflow->dst_id, *src_to_dst_direction = 1;
       else
 	*src = rflow->dst_id, *dst = rflow->src_id, *src_to_dst_direction = 0, rflow->bidirectional = 1;
     }
-    if (src_to_dst_direction) {
-      if (rflow->entropy.src2dst_pkt_count < max_num_packets_per_flow) {
+    if(src_to_dst_direction) {
+      if(rflow->entropy.src2dst_pkt_count < max_num_packets_per_flow) {
         rflow->entropy.src2dst_pkt_len[rflow->entropy.src2dst_pkt_count] = l4_data_len;
         rflow->entropy.src2dst_pkt_time[rflow->entropy.src2dst_pkt_count] = when;
         rflow->entropy.src2dst_l4_bytes += l4_data_len;
         rflow->entropy.src2dst_pkt_count++;
       }
       // Non zero app data.
-      if (l4_data_len != 0XFEEDFACE && l4_data_len != 0) {
+      if(l4_data_len != 0XFEEDFACE && l4_data_len != 0) {
         rflow->entropy.src2dst_opackets++;
       }
     } else {
-      if (rflow->entropy.dst2src_pkt_count < max_num_packets_per_flow) {
+      if(rflow->entropy.dst2src_pkt_count < max_num_packets_per_flow) {
         rflow->entropy.dst2src_pkt_len[rflow->entropy.dst2src_pkt_count] = l4_data_len;
         rflow->entropy.dst2src_pkt_time[rflow->entropy.dst2src_pkt_count] = when;
-        if (rflow->entropy.dst2src_pkt_count == 0) {
+        if(rflow->entropy.dst2src_pkt_count == 0) {
           rflow->entropy.dst2src_start = when;
         }
         rflow->entropy.dst2src_l4_bytes += l4_data_len;
         rflow->entropy.dst2src_pkt_count++;
       }
       // Non zero app data.
-      if (l4_data_len != 0XFEEDFACE && l4_data_len != 0) {
+      if(l4_data_len != 0XFEEDFACE && l4_data_len != 0) {
         rflow->entropy.dst2src_opackets++;
       }
     }
 
     return(rflow);
   }
 }
 
 /* ****************************************************** */
@@ -961,7 +961,7 @@ static u_int8_t is_ndpi_proto(struct ndpi_flow_info *flow, u_int16_t id) {
 
 void correct_csv_data_field(char* data) {
   /* Replace , with ; to avoid issues with CSVs */
-	for(u_int i=0; data[i] != '\0'; i++) if(data[i] == ',') data[i] = ';';
+  for(u_int i=0; data[i] != '\0'; i++) if(data[i] == ',') data[i] = ';';
 }
 
 /* ****************************************************** */
@@ -969,172 +969,172 @@ void correct_csv_data_field(char* data) {
 void process_ndpi_collected_info(struct ndpi_workflow * workflow, struct ndpi_flow_info *flow) {
   u_int i;
 
   if(!flow->ndpi_flow) return;
 
   snprintf(flow->host_server_name, sizeof(flow->host_server_name), "%s",
 	   flow->ndpi_flow->host_server_name);
 
   snprintf(flow->flow_extra_info, sizeof(flow->flow_extra_info), "%s",
 	   flow->ndpi_flow->flow_extra_info);
 
   if(is_ndpi_proto(flow, NDPI_PROTOCOL_DHCP)) {
     snprintf(flow->dhcp_fingerprint, sizeof(flow->dhcp_fingerprint), "%s", flow->ndpi_flow->protos.dhcp.fingerprint);
   } else if(is_ndpi_proto(flow, NDPI_PROTOCOL_BITTORRENT)) {
     u_int j, n = 0;
 
     for(i=0, j = 0; j < sizeof(flow->bittorent_hash)-1; i++) {
       sprintf(&flow->bittorent_hash[j], "%02x",
 	      flow->ndpi_flow->protos.bittorrent.hash[i]);
 
       j += 2, n += flow->ndpi_flow->protos.bittorrent.hash[i];
     }
 
     if(n == 0) flow->bittorent_hash[0] = '\0';
   }
   /* DNS */
   else if(is_ndpi_proto(flow, NDPI_PROTOCOL_DNS)) {
     if(flow->ndpi_flow->protos.dns.rsp_type == 0x1)
       inet_ntop(AF_INET, &flow->ndpi_flow->protos.dns.rsp_addr.ipv4, flow->info, sizeof(flow->info));
     else {
       inet_ntop(AF_INET6, &flow->ndpi_flow->protos.dns.rsp_addr.ipv6, flow->info, sizeof(flow->info));
 
       /* For consistency across platforms replace :0: with :: */
       ndpi_patchIPv6Address(flow->info);
     }
   }
   /* MDNS */
   else if(is_ndpi_proto(flow, NDPI_PROTOCOL_MDNS)) {
     snprintf(flow->info, sizeof(flow->info), "%s", flow->ndpi_flow->protos.mdns.answer);
   }
   /* UBNTAC2 */
   else if(is_ndpi_proto(flow, NDPI_PROTOCOL_UBNTAC2)) {
     snprintf(flow->info, sizeof(flow->info), "%s", flow->ndpi_flow->protos.ubntac2.version);
   }
   /* FTP */
   else if((is_ndpi_proto(flow, NDPI_PROTOCOL_FTP_CONTROL))
 	  || /* IMAP */ is_ndpi_proto(flow, NDPI_PROTOCOL_MAIL_IMAP)
 	  || /* POP */  is_ndpi_proto(flow, NDPI_PROTOCOL_MAIL_POP)
 	  || /* SMTP */ is_ndpi_proto(flow, NDPI_PROTOCOL_MAIL_SMTP)) {
     if(flow->ndpi_flow->protos.ftp_imap_pop_smtp.username[0] != '\0')
       snprintf(flow->info, sizeof(flow->info), "User: %s][Pwd: %s%s",
 	       flow->ndpi_flow->protos.ftp_imap_pop_smtp.username,
 	       flow->ndpi_flow->protos.ftp_imap_pop_smtp.password,
 	       flow->ndpi_flow->protos.ftp_imap_pop_smtp.auth_failed ? "][Auth Failed" : "");
   }
   /* KERBEROS */
   else if(is_ndpi_proto(flow, NDPI_PROTOCOL_KERBEROS)) {
     if((flow->ndpi_flow->protos.kerberos.hostname[0] != '\0')
        || (flow->ndpi_flow->protos.kerberos.username[0] != '\0')) {
       snprintf(flow->info, sizeof(flow->info), "%s%s%s%s",
 	       flow->ndpi_flow->protos.kerberos.domain /* = realm */,
 	       flow->ndpi_flow->protos.kerberos.domain[0] != '\0' ? "\\" : "",
 	       flow->ndpi_flow->protos.kerberos.hostname,
 	       flow->ndpi_flow->protos.kerberos.username);
     } else if(flow->ndpi_flow->protos.kerberos.domain[0] != '\0')
       snprintf(flow->info, sizeof(flow->info), "%s",
 	       flow->ndpi_flow->protos.kerberos.domain);
 
 #if 0
     if(flow->info[0] != '\0')
       printf("->> (%d) [%s][%s][%s]<<--\n",
 	     htons(flow->src_port),
 	     flow->ndpi_flow->protos.kerberos.domain,
 	     flow->ndpi_flow->protos.kerberos.hostname,
 	     flow->ndpi_flow->protos.kerberos.username);
 #endif
   }
   /* HTTP */
   else if((flow->detected_protocol.master_protocol == NDPI_PROTOCOL_HTTP)
 	  || is_ndpi_proto(flow, NDPI_PROTOCOL_HTTP)) {
     if(flow->ndpi_flow->http.url != NULL) {
       snprintf(flow->http.url, sizeof(flow->http.url), "%s", flow->ndpi_flow->http.url);
       flow->http.response_status_code = flow->ndpi_flow->http.response_status_code;
       snprintf(flow->http.content_type, sizeof(flow->http.content_type), "%s", flow->ndpi_flow->http.content_type ? flow->ndpi_flow->http.content_type : "");
       snprintf(flow->http.user_agent, sizeof(flow->http.user_agent), "%s", flow->ndpi_flow->http.user_agent ? flow->ndpi_flow->http.user_agent : "");
     }
   } else if(is_ndpi_proto(flow, NDPI_PROTOCOL_TELNET)) {
     snprintf(flow->telnet.username, sizeof(flow->telnet.username), "%s", flow->ndpi_flow->protos.telnet.username);
     snprintf(flow->telnet.password, sizeof(flow->telnet.password), "%s", flow->ndpi_flow->protos.telnet.password);
   } else if(is_ndpi_proto(flow, NDPI_PROTOCOL_SSH)) {
     snprintf(flow->ssh_tls.client_requested_server_name,
 	     sizeof(flow->ssh_tls.client_requested_server_name), "%s",
 	     flow->ndpi_flow->protos.ssh.client_signature);
     snprintf(flow->ssh_tls.server_info, sizeof(flow->ssh_tls.server_info), "%s",
 	     flow->ndpi_flow->protos.ssh.server_signature);
     snprintf(flow->ssh_tls.client_hassh, sizeof(flow->ssh_tls.client_hassh), "%s",
 	     flow->ndpi_flow->protos.ssh.hassh_client);
     snprintf(flow->ssh_tls.server_hassh, sizeof(flow->ssh_tls.server_hassh), "%s",
 	     flow->ndpi_flow->protos.ssh.hassh_server);
   }
   /* TLS */
   else if((is_ndpi_proto(flow, NDPI_PROTOCOL_TLS))
 	  || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS)
 	  || (flow->ndpi_flow->protos.stun_ssl.ssl.ja3_client[0] != '\0')
-    ) {
+	  ) {
     flow->ssh_tls.ssl_version = flow->ndpi_flow->protos.stun_ssl.ssl.ssl_version;
     snprintf(flow->ssh_tls.client_requested_server_name,
 	     sizeof(flow->ssh_tls.client_requested_server_name), "%s",
 	     flow->ndpi_flow->protos.stun_ssl.ssl.client_requested_server_name);
 
     if(flow->ndpi_flow->protos.stun_ssl.ssl.server_names_len > 0)
       flow->ssh_tls.server_names = ndpi_strdup(flow->ndpi_flow->protos.stun_ssl.ssl.server_names);
     snprintf(flow->ssh_tls.server_organization, sizeof(flow->ssh_tls.server_organization), "%s",
 	     flow->ndpi_flow->protos.stun_ssl.ssl.server_organization);
     flow->ssh_tls.notBefore = flow->ndpi_flow->protos.stun_ssl.ssl.notBefore;
     flow->ssh_tls.notAfter = flow->ndpi_flow->protos.stun_ssl.ssl.notAfter;
     snprintf(flow->ssh_tls.ja3_client, sizeof(flow->ssh_tls.ja3_client), "%s",
 	     flow->ndpi_flow->protos.stun_ssl.ssl.ja3_client);
     snprintf(flow->ssh_tls.ja3_server, sizeof(flow->ssh_tls.ja3_server), "%s",
 	     flow->ndpi_flow->protos.stun_ssl.ssl.ja3_server);
     flow->ssh_tls.server_unsafe_cipher = flow->ndpi_flow->protos.stun_ssl.ssl.server_unsafe_cipher;
     flow->ssh_tls.server_cipher = flow->ndpi_flow->protos.stun_ssl.ssl.server_cipher;
 
     if(flow->ndpi_flow->l4.tcp.tls.fingerprint_set) {
       memcpy(flow->ssh_tls.sha1_cert_fingerprint,
-	   flow->ndpi_flow->l4.tcp.tls.sha1_certificate_fingerprint, 20);
+	     flow->ndpi_flow->l4.tcp.tls.sha1_certificate_fingerprint, 20);
       flow->ssh_tls.sha1_cert_fingerprint_set = 1;
     }
 
     if(flow->ndpi_flow->protos.stun_ssl.ssl.alpn) {
       if((flow->ssh_tls.tls_alpn = ndpi_strdup(flow->ndpi_flow->protos.stun_ssl.ssl.alpn)) != NULL)
         correct_csv_data_field(flow->ssh_tls.tls_alpn);
     }
 
     if(flow->ssh_tls.tls_supported_versions) {
       if((flow->ssh_tls.tls_supported_versions = ndpi_strdup(flow->ndpi_flow->protos.stun_ssl.ssl.tls_supported_versions)) != NULL)
-	      correct_csv_data_field(flow->ssh_tls.tls_supported_versions);
+	correct_csv_data_field(flow->ssh_tls.tls_supported_versions);
     }
 
     if(flow->ndpi_flow->protos.stun_ssl.ssl.alpn
        && flow->ndpi_flow->protos.stun_ssl.ssl.tls_supported_versions) {
-        correct_csv_data_field(flow->ndpi_flow->protos.stun_ssl.ssl.alpn);
-        correct_csv_data_field(flow->ndpi_flow->protos.stun_ssl.ssl.tls_supported_versions);
-        snprintf(flow->info, sizeof(flow->info), "ALPN: %s][TLS Supported Versions: %s",
-	        flow->ndpi_flow->protos.stun_ssl.ssl.alpn,
-	        flow->ndpi_flow->protos.stun_ssl.ssl.tls_supported_versions);
-       }
+      correct_csv_data_field(flow->ndpi_flow->protos.stun_ssl.ssl.alpn);
+      correct_csv_data_field(flow->ndpi_flow->protos.stun_ssl.ssl.tls_supported_versions);
+      snprintf(flow->info, sizeof(flow->info), "ALPN: %s][TLS Supported Versions: %s",
+	       flow->ndpi_flow->protos.stun_ssl.ssl.alpn,
+	       flow->ndpi_flow->protos.stun_ssl.ssl.tls_supported_versions);
+    }
     else if(flow->ndpi_flow->protos.stun_ssl.ssl.alpn) {
       correct_csv_data_field(flow->ndpi_flow->protos.stun_ssl.ssl.alpn);
       snprintf(flow->info, sizeof(flow->info), "ALPN: %s",
 	       flow->ndpi_flow->protos.stun_ssl.ssl.alpn);
     }
   }
 
   if(flow->detection_completed && (!flow->check_extra_packets)) {
     if(is_ndpi_proto(flow, NDPI_PROTOCOL_UNKNOWN)) {
       if(workflow->__flow_giveup_callback != NULL)
 	workflow->__flow_giveup_callback(workflow, flow, workflow->__flow_giveup_udata);
     } else {
       if(workflow->__flow_detected_callback != NULL)
 	workflow->__flow_detected_callback(workflow, flow, workflow->__flow_detected_udata);
     }
 
     ndpi_free_flow_info_half(flow);
   }
 }
 
 /* ****************************************************** */
 
 /**
  * @brief Clear entropy stats if it meets prereq.
  */
@@ -1147,266 +1147,266 @@ ndpi_clear_entropy_stats(struct ndpi_flow_info *flow) {
 }
 
 void update_tcp_flags_count(struct ndpi_flow_info* flow, struct ndpi_tcphdr* tcp, u_int8_t src_to_dst_direction){
-    if(tcp->cwr){
-        flow->cwr_count++;
-        src_to_dst_direction ? flow->src2dst_cwr_count++ : flow->dst2src_cwr_count++;
-    }
-    if(tcp->ece){
-        flow->ece_count++;
-        src_to_dst_direction ? flow->src2dst_ece_count++ : flow->dst2src_ece_count++;
-    }
-    if(tcp->rst){
-        flow->rst_count++;
-        src_to_dst_direction ? flow->src2dst_rst_count++ : flow->dst2src_rst_count++;
-    }
-    if(tcp->ack){
-        flow->ack_count++;
-        src_to_dst_direction ? flow->src2dst_ack_count++ : flow->dst2src_ack_count++;
-    }
-    if(tcp->fin){
-        flow->fin_count++;
-        src_to_dst_direction ? flow->src2dst_fin_count++ : flow->dst2src_fin_count++;
-    }
-    if(tcp->syn){
-        flow->syn_count++;
-        src_to_dst_direction ? flow->src2dst_syn_count++ : flow->dst2src_syn_count++;
-    }
-    if(tcp->psh){
-        flow->psh_count++;
-        src_to_dst_direction ? flow->src2dst_psh_count++ : flow->dst2src_psh_count++;
-    }
-    if(tcp->urg){
-        flow->urg_count++;
-        src_to_dst_direction ? flow->src2dst_urg_count++ : flow->dst2src_urg_count++;
-    }
+  if(tcp->cwr){
+    flow->cwr_count++;
+    src_to_dst_direction ? flow->src2dst_cwr_count++ : flow->dst2src_cwr_count++;
+  }
+  if(tcp->ece){
+    flow->ece_count++;
+    src_to_dst_direction ? flow->src2dst_ece_count++ : flow->dst2src_ece_count++;
+  }
+  if(tcp->rst){
+    flow->rst_count++;
+    src_to_dst_direction ? flow->src2dst_rst_count++ : flow->dst2src_rst_count++;
+  }
+  if(tcp->ack){
+    flow->ack_count++;
+    src_to_dst_direction ? flow->src2dst_ack_count++ : flow->dst2src_ack_count++;
+  }
+  if(tcp->fin){
+    flow->fin_count++;
+    src_to_dst_direction ? flow->src2dst_fin_count++ : flow->dst2src_fin_count++;
+  }
+  if(tcp->syn){
+    flow->syn_count++;
+    src_to_dst_direction ? flow->src2dst_syn_count++ : flow->dst2src_syn_count++;
+  }
+  if(tcp->psh){
+    flow->psh_count++;
+    src_to_dst_direction ? flow->src2dst_psh_count++ : flow->dst2src_psh_count++;
+  }
+  if(tcp->urg){
+    flow->urg_count++;
+    src_to_dst_direction ? flow->src2dst_urg_count++ : flow->dst2src_urg_count++;
+  }
 }
 
 /* ****************************************************** */
 /**
    Function to process the packet:
    determine the flow of a packet and try to decode it
    @return: 0 if success; else != 0
 
    @Note: ipsize = header->len - ip_offset ; rawsize = header->len
 */
 static struct ndpi_proto packet_processing(struct ndpi_workflow * workflow,
 					   const u_int64_t time,
 					   u_int16_t vlan_id,
 					   ndpi_packet_tunnel tunnel_type,
 					   const struct ndpi_iphdr *iph,
 					   struct ndpi_ipv6hdr *iph6,
 					   u_int16_t ip_offset,
 					   u_int16_t ipsize, u_int16_t rawsize,
 					   const struct pcap_pkthdr *header,
 					   const u_char *packet,
                                            struct timeval when) {
   struct ndpi_id_struct *src, *dst;
   struct ndpi_flow_info *flow = NULL;
   struct ndpi_flow_struct *ndpi_flow = NULL;
   u_int8_t proto;
   struct ndpi_tcphdr *tcph = NULL;
   struct ndpi_udphdr *udph = NULL;
   u_int16_t sport, dport, payload_len = 0;
   u_int8_t *payload;
   u_int8_t src_to_dst_direction = 1;
   u_int8_t begin_or_end_tcp = 0;
   struct ndpi_proto nproto = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN };
 
   if(iph)
     flow = get_ndpi_flow_info(workflow, IPVERSION, vlan_id,
 			      tunnel_type, iph, NULL,
 			      ip_offset, ipsize,
 			      ntohs(iph->tot_len) - (iph->ihl * 4),
 			      &tcph, &udph, &sport, &dport,
 			      &src, &dst, &proto,
 			      &payload, &payload_len, &src_to_dst_direction, when);
   else
     flow = get_ndpi_flow_info6(workflow, vlan_id,
 			       tunnel_type, iph6, ip_offset, ipsize,
 			       &tcph, &udph, &sport, &dport,
 			       &src, &dst, &proto,
 			       &payload, &payload_len, &src_to_dst_direction, when);
 
   if(flow != NULL) {
     struct timeval tdiff;
 
     workflow->stats.ip_packet_count++;
     workflow->stats.total_wire_bytes += rawsize + 24 /* CRC etc */,
       workflow->stats.total_ip_bytes += rawsize;
     ndpi_flow = flow->ndpi_flow;
 
     if(tcph != NULL){
-        update_tcp_flags_count(flow, tcph, src_to_dst_direction);
-        if(tcph->syn && !flow->src2dst_bytes){
-            flow->c_to_s_init_win = rawsize;
-        }else if(tcph->syn && tcph->ack && flow->src2dst_bytes == flow->c_to_s_init_win){
-            flow->s_to_c_init_win = rawsize;
-        }
+      update_tcp_flags_count(flow, tcph, src_to_dst_direction);
+      if(tcph->syn && !flow->src2dst_bytes){
+	flow->c_to_s_init_win = rawsize;
+      }else if(tcph->syn && tcph->ack && flow->src2dst_bytes == flow->c_to_s_init_win){
+	flow->s_to_c_init_win = rawsize;
+      }
     }
 
     if((tcph != NULL) && (tcph->fin || tcph->rst || tcph->syn))
       begin_or_end_tcp = 1;
 
     if(flow->entropy.flow_last_pkt_time.tv_sec) {
       ndpi_timer_sub(&when, &flow->entropy.flow_last_pkt_time, &tdiff);
 
       if(flow->iat_flow
 	 && (tdiff.tv_sec >= 0) /* Discard backward time */
 	 ) {
 	u_int32_t ms = ndpi_timeval_to_milliseconds(tdiff);
 
 	if(ms > 0)
 	  ndpi_data_add_value(flow->iat_flow, ms);
       }
     }
     memcpy(&flow->entropy.flow_last_pkt_time, &when, sizeof(when));
 
     if(src_to_dst_direction) {
       if(flow->entropy.src2dst_last_pkt_time.tv_sec) {
 	ndpi_timer_sub(&when, &flow->entropy.src2dst_last_pkt_time, &tdiff);
 
 	if(flow->iat_c_to_s
 	   && (tdiff.tv_sec >= 0) /* Discard backward time */
 	   ) {
 	  u_int32_t ms = ndpi_timeval_to_milliseconds(tdiff);
 
 	  ndpi_data_add_value(flow->iat_c_to_s, ms);
 	}
       }
 
       ndpi_data_add_value(flow->pktlen_c_to_s, rawsize);
       flow->src2dst_packets++, flow->src2dst_bytes += rawsize, flow->src2dst_goodput_bytes += payload_len;
       memcpy(&flow->entropy.src2dst_last_pkt_time, &when, sizeof(when));
     } else {
       if(flow->entropy.dst2src_last_pkt_time.tv_sec && (!begin_or_end_tcp)) {
 	ndpi_timer_sub(&when, &flow->entropy.dst2src_last_pkt_time, &tdiff);
 
 	if(flow->iat_s_to_c) {
 	  u_int32_t ms = ndpi_timeval_to_milliseconds(tdiff);
 
 	  ndpi_data_add_value(flow->iat_s_to_c, ms);
 	}
       }
       ndpi_data_add_value(flow->pktlen_s_to_c, rawsize);
       flow->dst2src_packets++, flow->dst2src_bytes += rawsize, flow->dst2src_goodput_bytes += payload_len;
       memcpy(&flow->entropy.dst2src_last_pkt_time, &when, sizeof(when));
     }
 
     if(enable_payload_analyzer && (payload_len > 0))
       ndpi_payload_analyzer(flow, src_to_dst_direction,
 			    payload, payload_len,
 			    workflow->stats.ip_packet_count);
 
     if(enable_joy_stats) {
       /* Update BD, distribution and mean. */
       ndpi_flow_update_byte_count(flow, payload, payload_len, src_to_dst_direction);
       ndpi_flow_update_byte_dist_mean_var(flow, payload, payload_len, src_to_dst_direction);
       /* Update SPLT scores for first 32 packets. */
       if((flow->entropy.src2dst_pkt_count+flow->entropy.dst2src_pkt_count) <= max_num_packets_per_flow) {
         if(flow->bidirectional)
           flow->entropy.score = ndpi_classify(flow->entropy.src2dst_pkt_len, flow->entropy.src2dst_pkt_time,
 					      flow->entropy.dst2src_pkt_len, flow->entropy.dst2src_pkt_time,
 					      flow->entropy.src2dst_start, flow->entropy.dst2src_start,
 					      max_num_packets_per_flow, flow->src_port, flow->dst_port,
 					      flow->src2dst_packets, flow->dst2src_packets,
 					      flow->entropy.src2dst_opackets, flow->entropy.dst2src_opackets,
 					      flow->entropy.src2dst_l4_bytes, flow->entropy.dst2src_l4_bytes, 1,
 					      flow->entropy.src2dst_byte_count, flow->entropy.dst2src_byte_count);
 	else
 	  flow->entropy.score = ndpi_classify(flow->entropy.src2dst_pkt_len, flow->entropy.src2dst_pkt_time,
 					      NULL, NULL, flow->entropy.src2dst_start, flow->entropy.src2dst_start,
 					      max_num_packets_per_flow, flow->src_port, flow->dst_port,
 					      flow->src2dst_packets, 0,
 					      flow->entropy.src2dst_opackets, 0,
 					      flow->entropy.src2dst_l4_bytes, 0, 1,
 					      flow->entropy.src2dst_byte_count, NULL);
       }
     }
 
     if(flow->first_seen == 0)
       flow->first_seen = time;
 
     flow->last_seen = time;
 
     /* Copy packets entropy if num packets count == 10 */
     ndpi_clear_entropy_stats(flow);
 
     if(!flow->has_human_readeable_strings) {
       u_int8_t skip = 0;
 
       if((proto == IPPROTO_TCP)
 	 && (
 	     is_ndpi_proto(flow, NDPI_PROTOCOL_TLS)
 	     || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS)
 	     || is_ndpi_proto(flow, NDPI_PROTOCOL_SSH)
 	     || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_SSH))
 	 ) {
 	if((flow->src2dst_packets+flow->dst2src_packets) < 10 /* MIN_NUM_ENCRYPT_SKIP_PACKETS */)
 	  skip = 1;
       }
 
       if(!skip) {
 	if(ndpi_has_human_readeable_string(workflow->ndpi_struct, (char*)packet, header->caplen,
 					   human_readeable_string_len,
 					   flow->human_readeable_string_buffer,
 					   sizeof(flow->human_readeable_string_buffer)) == 1)
 	  flow->has_human_readeable_strings = 1;
       }
     } else {
       if((proto == IPPROTO_TCP)
 	 && (
 	     is_ndpi_proto(flow, NDPI_PROTOCOL_TLS)
 	     || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_TLS)
 	     || is_ndpi_proto(flow, NDPI_PROTOCOL_SSH)
 	     || (flow->detected_protocol.master_protocol == NDPI_PROTOCOL_SSH))
 	 )
 	flow->has_human_readeable_strings = 0;
     }
   } else { // flow is NULL
     workflow->stats.total_discarded_bytes++;
     return(nproto);
   }
 
   if(!flow->detection_completed) {
     u_int enough_packets =
       (((proto == IPPROTO_UDP) && ((flow->src2dst_packets + flow->dst2src_packets) > max_num_udp_dissected_pkts))
        || ((proto == IPPROTO_TCP) && ((flow->src2dst_packets + flow->dst2src_packets) > max_num_tcp_dissected_pkts))) ? 1 : 0;
 
 #if 0
     printf("%s()\n", __FUNCTION__);
 #endif
 
     flow->detected_protocol = ndpi_detection_process_packet(workflow->ndpi_struct, ndpi_flow,
 							    iph ? (uint8_t *)iph : (uint8_t *)iph6,
 							    ipsize, time, src, dst);
     
     if(enough_packets || (flow->detected_protocol.app_protocol != NDPI_PROTOCOL_UNKNOWN)) {
       if((!enough_packets)
 	 && ndpi_extra_dissection_possible(workflow->ndpi_struct, ndpi_flow))
 	; /* Wait for certificate fingerprint */
       else {
 	/* New protocol detected or give up */
 	flow->detection_completed = 1;
 
 #if 0
 	/* Check if we should keep checking extra packets */
 	if(ndpi_flow && ndpi_flow->check_extra_packets)
 	  flow->check_extra_packets = 1;
 #endif
 
 	if(flow->detected_protocol.app_protocol == NDPI_PROTOCOL_UNKNOWN) {
 	  u_int8_t proto_guessed;
 
 	  flow->detected_protocol = ndpi_detection_giveup(workflow->ndpi_struct, flow->ndpi_flow,
 							  enable_protocol_guess, &proto_guessed);
 	}
 
 	process_ndpi_collected_info(workflow, flow);
       }
     }
   }
 
   return(flow->detected_protocol);
 }
 
 /* ****************************************************** */
@@ -1590,238 +1590,238 @@ struct ndpi_proto ndpi_workflow_process_packet(struct ndpi_workflow * workflow,
     return(nproto);
   }
 
-ether_type_check:
+ ether_type_check:
   recheck_type = 0;
 
   /* check ether type */
   switch(type) {
   case VLAN:
     vlan_id = ((packet[ip_offset] << 8) + packet[ip_offset+1]) & 0xFFF;
     type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];
     ip_offset += 4;
     vlan_packet = 1;
 
     // double tagging for 802.1Q
     while((type == 0x8100) && (((bpf_u_int32)ip_offset) < header->caplen)) {
       vlan_id = ((packet[ip_offset] << 8) + packet[ip_offset+1]) & 0xFFF;
       type = (packet[ip_offset+2] << 8) + packet[ip_offset+3];
       ip_offset += 4;
     }
     recheck_type = 1;
     break;
 
   case MPLS_UNI:
   case MPLS_MULTI:
     mpls.u32 = *((uint32_t *) &packet[ip_offset]);
     mpls.u32 = ntohl(mpls.u32);
     workflow->stats.mpls_count++;
     type = ETH_P_IP, ip_offset += 4;
 
     while(!mpls.mpls.s) {
       mpls.u32 = *((uint32_t *) &packet[ip_offset]);
       mpls.u32 = ntohl(mpls.u32);
       ip_offset += 4;
     }
     recheck_type = 1;
     break;
 
   case PPPoE:
     workflow->stats.pppoe_count++;
     type = ETH_P_IP;
     ip_offset += 8;
     recheck_type = 1;
     break;
 
   default:
     break;
   }
 
   if(recheck_type)
     goto ether_type_check;
 
   workflow->stats.vlan_count += vlan_packet;
 
  iph_check:
   /* Check and set IP header size and total packet length */
-  if (header->caplen < ip_offset + sizeof(struct ndpi_iphdr))
+  if(header->caplen < ip_offset + sizeof(struct ndpi_iphdr))
     return(nproto); /* Too short for next IP header*/
 
   iph = (struct ndpi_iphdr *) &packet[ip_offset];
 
   /* just work on Ethernet packets that contain IP */
   if(type == ETH_P_IP && header->caplen >= ip_offset) {
     frag_off = ntohs(iph->frag_off);
 
     proto = iph->protocol;
     if(header->caplen < header->len) {
       static u_int8_t cap_warning_used = 0;
 
       if(cap_warning_used == 0) {
 	if(!workflow->prefs.quiet_mode)
 	  NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
 		   "\n\nWARNING: packet capture size is smaller than packet size, DETECTION MIGHT NOT WORK CORRECTLY\n\n");
 	cap_warning_used = 1;
       }
     }
   }
 
   if(iph->version == IPVERSION) {
     ip_len = ((u_int16_t)iph->ihl * 4);
     iph6 = NULL;
 
     if(iph->protocol == IPPROTO_IPV6) {
       ip_offset += ip_len;
-      if (ip_len > 0)
+      if(ip_len > 0)
         goto iph_check;
     }
 
     if((frag_off & 0x1FFF) != 0) {
       static u_int8_t ipv4_frags_warning_used = 0;
       workflow->stats.fragmented_count++;
 
       if(ipv4_frags_warning_used == 0) {
 	if(!workflow->prefs.quiet_mode)
 	  NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG, "\n\nWARNING: IPv4 fragments are not handled by this demo (nDPI supports them)\n");
 	ipv4_frags_warning_used = 1;
       }
 
       workflow->stats.total_discarded_bytes +=  header->len;
       return(nproto);
     }
   } else if(iph->version == 6) {
-    if (header->caplen < ip_offset + sizeof(struct ndpi_ipv6hdr))
+    if(header->caplen < ip_offset + sizeof(struct ndpi_ipv6hdr))
       return(nproto); /* Too short for IPv6 header*/
     iph6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
     proto = iph6->ip6_hdr.ip6_un1_nxt;
     ip_len = ntohs(iph6->ip6_hdr.ip6_un1_plen);
-    if (header->caplen < ip_offset + sizeof(struct ndpi_ipv6hdr + ntohs(iph_v6->ip6_hdr.ip6_un1_plen))
+    if(header->caplen < (ip_offset + sizeof(struct ndpi_ipv6hdr) + ntohs(iph6->ip6_hdr.ip6_un1_plen)))
       return(nproto); /* Too short for IPv6 payload*/
 
-
     const u_int8_t *l4ptr = (((const u_int8_t *) iph6) + sizeof(struct ndpi_ipv6hdr));
     if(ndpi_handle_ipv6_extension_headers(NULL, &l4ptr, &ip_len, &proto) != 0) {
       return(nproto);
     }
-    iph6->ip6_hdr.ip6_un1_nxt = proto;
 
     iph = NULL;
   } else {
     static u_int8_t ipv4_warning_used = 0;
 
   v4_warning:
     if(ipv4_warning_used == 0) {
       if(!workflow->prefs.quiet_mode)
         NDPI_LOG(0, workflow->ndpi_struct, NDPI_LOG_DEBUG,
 		 "\n\nWARNING: only IPv4/IPv6 packets are supported in this demo (nDPI supports both IPv4 and IPv6), all other packets will be discarded\n\n");
       ipv4_warning_used = 1;
     }
     workflow->stats.total_discarded_bytes +=  header->len;
     return(nproto);
   }
 
   if(workflow->prefs.decode_tunnels && (proto == IPPROTO_UDP)) {
-    if (header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr))
+    if(header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr))
       return(nproto); /* Too short for UDP header*/
-    struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];
-    u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);
+    else {
+      struct ndpi_udphdr *udp = (struct ndpi_udphdr *)&packet[ip_offset+ip_len];
+      u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);
 
-    if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
-      /* Check if it's GTPv1 */
-      u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
-      u_int8_t flags = packet[offset];
-      u_int8_t message_type = packet[offset+1];
+      if((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
+	/* Check if it's GTPv1 */
+	u_int offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
+	u_int8_t flags = packet[offset];
+	u_int8_t message_type = packet[offset+1];
 
-      tunnel_type = ndpi_gtp_tunnel;
+	tunnel_type = ndpi_gtp_tunnel;
 
-      if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) &&
-	 (message_type == 0xFF /* T-PDU */)) {
+	if((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) &&
+	   (message_type == 0xFF /* T-PDU */)) {
 
-	ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr)+8; /* GTPv1 header len */
-	if(flags & 0x04) ip_offset += 1; /* next_ext_header is present */
-	if(flags & 0x02) ip_offset += 4; /* sequence_number is present (it also includes next_ext_header and pdu_number) */
-	if(flags & 0x01) ip_offset += 1; /* pdu_number is present */
+	  ip_offset = ip_offset+ip_len+sizeof(struct ndpi_udphdr)+8; /* GTPv1 header len */
+	  if(flags & 0x04) ip_offset += 1; /* next_ext_header is present */
+	  if(flags & 0x02) ip_offset += 4; /* sequence_number is present (it also includes next_ext_header and pdu_number) */
+	  if(flags & 0x01) ip_offset += 1; /* pdu_number is present */
 
-	iph = (struct ndpi_iphdr *) &packet[ip_offset];
+	  iph = (struct ndpi_iphdr *) &packet[ip_offset];
 
-	if(iph->version != IPVERSION) {
-	  // printf("WARNING: not good (packet_id=%u)!\n", (unsigned int)workflow->stats.raw_packet_count);
-	  goto v4_warning;
-	}
-      }
-    } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
-      /* https://en.wikipedia.org/wiki/TZSP */
-      if (header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4)
-        return(nproto); /* Too short for TZSP*/
-
-      u_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
-      u_int8_t version       = packet[offset];
-      u_int8_t ts_type       = packet[offset+1];
-      u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));
-
-      tunnel_type = ndpi_tzsp_tunnel;
-
-      if((version == 1) && (ts_type == 0) && (encapsulates == 1)) {
-	u_int8_t stop = 0;
-
-	offset += 4;
-
-	while((!stop) && (offset < header->caplen)) {
-	  u_int8_t tag_type = packet[offset];
-	  u_int8_t tag_len;
-
-	  switch(tag_type) {
-	  case 0: /* PADDING Tag */
-	    tag_len = 1;
-	    break;
-	  case 1: /* END Tag */
-	    tag_len = 1, stop = 1;
-	    break;
-	  default:
-	    tag_len = packet[offset+1];
-	    break;
+	  if(iph->version != IPVERSION) {
+	    // printf("WARNING: not good (packet_id=%u)!\n", (unsigned int)workflow->stats.raw_packet_count);
+	    goto v4_warning;
 	  }
-
-	  offset += tag_len;
-
-	  if(offset >= header->caplen)
-	    return(nproto); /* Invalid packet */
-	  else {
-	    eth_offset = offset;
-	    goto datalink_check;
+	}
+      } else if((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
+	/* https://en.wikipedia.org/wiki/TZSP */
+	if(header->caplen < ip_offset + ip_len + sizeof(struct ndpi_udphdr) + 4)
+	  return(nproto); /* Too short for TZSP*/
+
+	u_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
+	u_int8_t version       = packet[offset];
+	u_int8_t ts_type       = packet[offset+1];
+	u_int16_t encapsulates = ntohs(*((u_int16_t*)&packet[offset+2]));
+
+	tunnel_type = ndpi_tzsp_tunnel;
+
+	if((version == 1) && (ts_type == 0) && (encapsulates == 1)) {
+	  u_int8_t stop = 0;
+
+	  offset += 4;
+
+	  while((!stop) && (offset < header->caplen)) {
+	    u_int8_t tag_type = packet[offset];
+	    u_int8_t tag_len;
+
+	    switch(tag_type) {
+	    case 0: /* PADDING Tag */
+	      tag_len = 1;
+	      break;
+	    case 1: /* END Tag */
+	      tag_len = 1, stop = 1;
+	      break;
+	    default:
+	      tag_len = packet[offset+1];
+	      break;
+	    }
+
+	    offset += tag_len;
+
+	    if(offset >= header->caplen)
+	      return(nproto); /* Invalid packet */
+	    else {
+	      eth_offset = offset;
+	      goto datalink_check;
+	    }
 	  }
 	}
-      }
-    } else if(sport == NDPI_CAPWAP_DATA_PORT) {
-      /* We dissect ONLY CAPWAP traffic */
-      u_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
+      } else if(sport == NDPI_CAPWAP_DATA_PORT) {
+	/* We dissect ONLY CAPWAP traffic */
+	u_int offset           = ip_offset+ip_len+sizeof(struct ndpi_udphdr);
 
-      if((offset+40) < header->caplen) {
-	u_int16_t msg_len = packet[offset+1] >> 1;
+	if((offset+40) < header->caplen) {
+	  u_int16_t msg_len = packet[offset+1] >> 1;
 
-	offset += msg_len;
+	  offset += msg_len;
 
-	if(packet[offset] == 0x02) {
-	  /* IEEE 802.11 Data */
+	  if(packet[offset] == 0x02) {
+	    /* IEEE 802.11 Data */
 
-	  offset += 24;
-	  /* LLC header is 8 bytes */
-	  type = ntohs((u_int16_t)*((u_int16_t*)&packet[offset+6]));
+	    offset += 24;
+	    /* LLC header is 8 bytes */
+	    type = ntohs((u_int16_t)*((u_int16_t*)&packet[offset+6]));
 
-	  ip_offset = offset + 8;
+	    ip_offset = offset + 8;
 
-	  tunnel_type = ndpi_capwap_tunnel;
-	  goto iph_check;
+	    tunnel_type = ndpi_capwap_tunnel;
+	    goto iph_check;
+	  }
 	}
       }
     }
   }
 
   /* process the packet */
   return(packet_processing(workflow, time, vlan_id, tunnel_type, iph, iph6,
 			   ip_offset, header->caplen - ip_offset,
 			   header->caplen, header, packet, header->ts));
 }
 
 /* ********************************************************** */
 /*       http://home.thep.lu.se/~bjorn/crc/crc32_fast.c       */
 /* ********************************************************** */
@@ -1879,11 +1879,11 @@ u_int32_t ethernet_crc32(const void* data, size_t n_bytes) {
 #include <rte_ether.h>
 
 static const struct rte_eth_conf port_conf_default = {
-#if (RTE_VERSION < RTE_VERSION_NUM(19, 8, 0, 0))
+#if(RTE_VERSION < RTE_VERSION_NUM(19, 8, 0, 0))
 						      .rxmode = { .max_rx_pkt_len = ETHER_MAX_LEN }
 #else
 						      .rxmode = { .max_rx_pkt_len = RTE_ETHER_MAX_LEN }
 #endif
 };
 
 /* ************************************ */
