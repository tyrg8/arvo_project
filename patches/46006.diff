commit da37a0d5ece632080351c529ac87f00495eddbfa
Author: Veronika Hanulikova <vhanulik@redhat.com>
Date:   Mon Mar 28 15:54:15 2022 +0200

    Check length of path
    
    Thanks oss-fuzz
    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=46006

diff --git a/src/libopensc/card-epass2003.c b/src/libopensc/card-epass2003.c
index 7efa3397..47a1c100 100644
--- a/src/libopensc/card-epass2003.c
+++ b/src/libopensc/card-epass2003.c
@@ -1287,40 +1287,52 @@ epass2003_finish(sc_card_t *card)
 static int
 epass2003_hook_path(struct sc_path *path, int inc)
 {
-	u8 fid_h = path->value[path->len - 2];
-	u8 fid_l = path->value[path->len - 1];
+	u8 fid_h = 0;
+	u8 fid_l = 0;
+
+	if (!path || path->len < 2)
+		return -1;
+	fid_h = path->value[path->len - 2];
+	fid_l = path->value[path->len - 1];
 
 	switch (fid_h) {
 	case 0x29:
 	case 0x30:
 	case 0x31:
 	case 0x32:
 	case 0x33:
 	case 0x34:
 		if (inc)
 			fid_l = fid_l * FID_STEP;
 		else
 			fid_l = fid_l / FID_STEP;
 		path->value[path->len - 1] = fid_l;
 		return 1;
 	default:
 		break;
 	}
 	return 0;
 }
 
 
-static void
+static int
 epass2003_hook_file(struct sc_file *file, int inc)
 {
 	int fidl = file->id & 0xff;
 	int fidh = file->id & 0xff00;
-	if (epass2003_hook_path(&file->path, inc)) {
+	int rv = 0;
+
+	rv = epass2003_hook_path(&file->path, inc);
+
+	if (rv > 0) {
 		if (inc)
 			file->id = fidh + fidl * FID_STEP;
 		else
 			file->id = fidh + fidl / FID_STEP;
 	}
+	if (rv < 0)
+		return rv;
+	return SC_SUCCESS;
 }
 
 
@@ -1328,89 +1340,91 @@ static int
 epass2003_select_fid_(struct sc_card *card, sc_path_t * in_path, sc_file_t ** file_out)
 {
 	struct sc_apdu apdu;
 	u8 buf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };
 	u8 pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;
 	int r, pathlen;
 	sc_file_t *file = NULL;
 
-	epass2003_hook_path(in_path, 1);
+	r = epass2003_hook_path(in_path, 1);
+	LOG_TEST_RET(card->ctx, r, "Can not hook path");
+
 	memcpy(path, in_path->value, in_path->len);
 	pathlen = in_path->len;
 
 	sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00);
 
 	switch (in_path->type) {
 	case SC_PATH_TYPE_FILE_ID:
 		apdu.p1 = 0;
 		if (pathlen != 2)
 			return SC_ERROR_INVALID_ARGUMENTS;
 		break;
 	default:
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);
 	}
 	apdu.p2 = 0;		/* first record, return FCI */
 	apdu.lc = pathlen;
 	apdu.data = path;
 	apdu.datalen = pathlen;
 
 	if (file_out != NULL) {
 		apdu.resp = buf;
 		apdu.resplen = sizeof(buf);
 		apdu.le = 0;
 	}
 	else   {
 		apdu.cse = (apdu.lc == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;
 	}
 
 	if (path[0] == 0x29) {	/* TODO:0x29 accords with FID prefix in profile  */
 		/* Not allowed to select private key file, so fake fci. */
 		/* 62 16 82 02 11 00 83 02 29 00 85 02 08 00 86 08 FF 90 90 90 FF FF FF FF */
 		apdu.resplen = 0x18;
 		memcpy(apdu.resp,
 		       "\x6f\x16\x82\x02\x11\x00\x83\x02\x29\x00\x85\x02\x08\x00\x86\x08\xff\x90\x90\x90\xff\xff\xff\xff",
 		       apdu.resplen);
 		apdu.resp[9] = path[1];
 		apdu.sw1 = 0x90;
 		apdu.sw2 = 0x00;
 	}
 	else {
 		r = sc_transmit_apdu_t(card, &apdu);
 		LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
 	}
 
 	if (file_out == NULL) {
 		if (apdu.sw1 == 0x61)
 			LOG_FUNC_RETURN(card->ctx, 0);
 		LOG_FUNC_RETURN(card->ctx, sc_check_sw(card, apdu.sw1, apdu.sw2));
 	}
 
 	r = sc_check_sw(card, apdu.sw1, apdu.sw2);
 	if (r)
 		LOG_FUNC_RETURN(card->ctx, r);
 	if (apdu.resplen < 2)
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);
 
 	switch (apdu.resp[0]) {
 	case 0x6F:
 		file = sc_file_new();
 		if (file == NULL)
 			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);
 		file->path = *in_path;
 		if (card->ops->process_fci == NULL) {
 			sc_file_free(file);
 			LOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);
 		}
 
 		if ((size_t) apdu.resp[1] + 2 <= apdu.resplen)
 			card->ops->process_fci(card, file, apdu.resp + 2, apdu.resp[1]);
 		epass2003_hook_file(file, 0);
 		*file_out = file;
 		break;
 	case 0x00:		/* proprietary coding */
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);
 		break;
 	default:
 		LOG_FUNC_RETURN(card->ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED);
 	}
 	return 0;
 }
@@ -2260,29 +2274,27 @@ static int
 epass2003_delete_file(struct sc_card *card, const sc_path_t * path)
 {
 	int r;
 	u8 sbuf[2];
 	struct sc_apdu apdu;
 
 	LOG_FUNC_CALLED(card->ctx);
 
 	r = sc_select_file(card, path, NULL);
-	epass2003_hook_path((struct sc_path *)path, 1);
-	if (r == SC_SUCCESS) {
-		sbuf[0] = path->value[path->len - 2];
-		sbuf[1] = path->value[path->len - 1];
-		sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE4, 0x00, 0x00);
-		apdu.lc = 2;
-		apdu.datalen = 2;
-		apdu.data = sbuf;
-	}
-	else   {
-		LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);
-	}
+	LOG_TEST_RET(card->ctx, r, "Can not select file");
+	r = epass2003_hook_path((struct sc_path *)path, 1);
+	LOG_TEST_RET(card->ctx, r, "Can not hook path");
+
+	sbuf[0] = path->value[path->len - 2];
+	sbuf[1] = path->value[path->len - 1];
+	sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE4, 0x00, 0x00);
+	apdu.lc = 2;
+	apdu.datalen = 2;
+	apdu.data = sbuf;
 
 	r = sc_transmit_apdu_t(card, &apdu);
 	LOG_TEST_RET(card->ctx, r, "APDU transmit failed");
 	r = sc_check_sw(card, apdu.sw1, apdu.sw2);
 	LOG_TEST_RET(card->ctx, r, "Delete file failed");
 
 	LOG_FUNC_RETURN(card->ctx, r);
 }
