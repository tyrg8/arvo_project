commit 7a1831b94a73f2cd665bd48f65c8516509d0740e
Author: tbeu <tbeu@users.noreply.github.com>
Date:   Sat May 30 22:45:28 2020 +0200

    Check read success and refactor inflate.c
    
    As reported by https://sourceforge.net/p/matio/discussion/609376/thread/75fd85fa8b/ and https://github.com/tbeu/matio/issues/120

diff --git a/src/inflate.c b/src/inflate.c
index bdfa47a..a49fa4d 100644
--- a/src/inflate.c
+++ b/src/inflate.c
@@ -1,621 +1,375 @@
 /** @file inflate.c
  * @brief Functions to inflate data/tags
  * @ingroup MAT
  */
 /*
  * Copyright (c) 2005-2020, Christopher C. Hulbert
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * 1. Redistributions of source code must retain the above copyright notice, this
  *    list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright notice,
  *    this list of conditions and the following disclaimer in the documentation
  *    and/or other materials provided with the distribution.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include <stdlib.h>
 #include "matio_private.h"
 
 #if HAVE_ZLIB
 
 /** @cond mat_devman */
 
-/** @brief Inflate the data until @c nbytes of uncompressed data has been
+/** @brief Inflate the data until @c nBytes of uncompressed data has been
  *         inflated
  *
  * @ingroup mat_internal
  * @param mat Pointer to the MAT file
  * @param z zlib compression stream
- * @param nbytes Number of uncompressed bytes to skip
- * @return Number of bytes read from the file
+ * @param nBytes Number of uncompressed bytes to skip
+ * @param[out] bytesread Number of bytes read from the file
+ * @retval 0 on success
+
  */
-size_t
-InflateSkip(mat_t *mat, z_streamp z, int nbytes)
+int
+InflateSkip(mat_t *mat, z_streamp z, int nBytes, size_t* bytesread)
 {
     mat_uint8_t comp_buf[READ_BLOCK_SIZE], uncomp_buf[READ_BLOCK_SIZE];
-    int    n, err, cnt = 0;
-    size_t bytesread = 0;
+    int n, err = 0, cnt = 0;
 
-    if ( nbytes < 1 )
+    if ( nBytes < 1 )
         return 0;
 
-    n = nbytes < READ_BLOCK_SIZE ? nbytes : READ_BLOCK_SIZE;
+    n = nBytes < READ_BLOCK_SIZE ? nBytes : READ_BLOCK_SIZE;
     if ( !z->avail_in ) {
+        size_t nbytes = fread(comp_buf, 1, n, (FILE*)mat->fp);
+        if ( 0 == nbytes ) {
+            return err;
+        }
+        if ( NULL != bytesread ) {
+            *bytesread += nbytes;
+        }
+        z->avail_in = (uInt)nbytes;
         z->next_in = comp_buf;
-        z->avail_in += fread(comp_buf,1,n,(FILE*)mat->fp);
-        bytesread   += z->avail_in;
     }
     z->avail_out = n;
     z->next_out  = uncomp_buf;
     err = inflate(z,Z_FULL_FLUSH);
     if ( err == Z_STREAM_END ) {
-        return bytesread;
+        return err;
     } else if ( err != Z_OK ) {
         Mat_Critical("InflateSkip: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-        return bytesread;
+        return err;
     }
     if ( !z->avail_out ) {
         cnt += n;
-        n = nbytes - cnt < READ_BLOCK_SIZE ? nbytes - cnt : READ_BLOCK_SIZE;
+        n = nBytes - cnt < READ_BLOCK_SIZE ? nBytes - cnt : READ_BLOCK_SIZE;
         z->avail_out = n;
         z->next_out  = uncomp_buf;
     }
-    while ( cnt < nbytes ) {
+    while ( cnt < nBytes ) {
         if ( !z->avail_in ) {
-            z->next_in   = comp_buf;
-            z->avail_in += fread(comp_buf,1,n,(FILE*)mat->fp);
-            bytesread   += z->avail_in;
+            size_t nbytes = fread(comp_buf, 1, n, (FILE*)mat->fp);
+            if ( 0 == nbytes ) {
+                break;
+            }
+            if ( NULL != bytesread ) {
+                *bytesread += nbytes;
+            }
+            z->avail_in = (uInt)nbytes;
+            z->next_in = comp_buf;
         }
         err = inflate(z,Z_FULL_FLUSH);
         if ( err == Z_STREAM_END ) {
             break;
         } else if ( err != Z_OK ) {
             Mat_Critical("InflateSkip: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
             break;
         }
         if ( !z->avail_out ) {
             cnt += n;
-            n = nbytes - cnt < READ_BLOCK_SIZE ? nbytes - cnt : READ_BLOCK_SIZE;
+            n = nBytes - cnt < READ_BLOCK_SIZE ? nBytes - cnt : READ_BLOCK_SIZE;
             z->avail_out = n;
             z->next_out  = uncomp_buf;
         }
     }
 
     if ( z->avail_in ) {
-        long offset = -(long)z->avail_in;
-        (void)fseek((FILE*)mat->fp,offset,SEEK_CUR);
-        bytesread -= z->avail_in;
-        z->avail_in = 0;
-    }
-
-    return bytesread;
-}
-
-/** @brief Inflate the data until @c nbytes of compressed data has been
- *         inflated
- *
- * @ingroup mat_internal
- * @param mat Pointer to the MAT file
- * @param z zlib compression stream
- * @param nbytes Number of uncompressed bytes to skip
- * @return Number of bytes read from the file
- */
-size_t
-InflateSkip2(mat_t *mat, matvar_t *matvar, int nbytes)
-{
-    mat_uint8_t comp_buf[32],uncomp_buf[32];
-    int    err, cnt = 0;
-    size_t bytesread = 0;
-
-    if ( !matvar->internal->z->avail_in ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
-    }
-    matvar->internal->z->avail_out = 1;
-    matvar->internal->z->next_out = uncomp_buf;
-    err = inflate(matvar->internal->z,Z_NO_FLUSH);
-    if ( err != Z_OK ) {
-        Mat_Critical("InflateSkip2: %s - inflate returned %s",matvar->name,zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-        return bytesread;
-    }
-    if ( !matvar->internal->z->avail_out ) {
-        matvar->internal->z->avail_out = 1;
-        matvar->internal->z->next_out = uncomp_buf;
-    }
-    while ( cnt < nbytes ) {
-        if ( !matvar->internal->z->avail_in ) {
-            matvar->internal->z->avail_in = 1;
-            matvar->internal->z->next_in = comp_buf;
-            bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
-            cnt++;
+        const long offset = -(long)z->avail_in;
+        (void)fseek((FILE*)mat->fp, offset, SEEK_CUR);
+        if ( NULL != bytesread ) {
+            *bytesread -= z->avail_in;
         }
-        err = inflate(matvar->internal->z,Z_NO_FLUSH);
-        if ( err != Z_OK ) {
-            Mat_Critical("InflateSkip2: %s - inflate returned %s",matvar->name,zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-            return bytesread;
-        }
-        if ( !matvar->internal->z->avail_out ) {
-            matvar->internal->z->avail_out = 1;
-            matvar->internal->z->next_out = uncomp_buf;
-        }
-    }
-
-    if ( matvar->internal->z->avail_in ) {
-        (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
-        bytesread -= matvar->internal->z->avail_in;
-        matvar->internal->z->avail_in = 0;
+        z->avail_in = 0;
     }
 
-    return bytesread;
+    return err;
 }
 
 /** @brief Inflate the data until @c len elements of compressed data with data
  *         type @c data_type has been inflated
  *
  * @ingroup mat_internal
  * @param mat Pointer to the MAT file
  * @param z zlib compression stream
  * @param data_type Data type (matio_types enumerations)
  * @param len Number of elements of datatype @c data_type to skip
- * @return Number of bytes read from the file
+ * @param[out] bytesread Number of bytes read from the file
+ * @retval 0 on success
+
  */
-size_t
-InflateSkipData(mat_t *mat,z_streamp z,enum matio_types data_type,int len)
+int
+InflateSkipData(mat_t *mat, z_streamp z, enum matio_types data_type, int len)
 {
-    int data_size = 0;
-
-    if ( (mat == NULL) || (z == NULL) )
-        return 0;
-    else if ( len < 1 )
-        return 0;
+    if ( mat == NULL || z == NULL || len < 1 )
+        return 1;
 
     switch ( data_type ) {
-        case MAT_T_DOUBLE:
-            data_size = sizeof(double);
-            break;
-        case MAT_T_SINGLE:
-            data_size = sizeof(float);
-            break;
-#ifdef HAVE_MAT_INT64_T
-        case MAT_T_INT64:
-            data_size = sizeof(mat_int64_t);
-            break;
-#endif /* HAVE_MAT_INT64_T */
-#ifdef HAVE_MAT_UINT64_T
-        case MAT_T_UINT64:
-            data_size = sizeof(mat_uint64_t);
-            break;
-#endif /* HAVE_MAT_UINT64_T */
-        case MAT_T_INT32:
-            data_size = sizeof(mat_int32_t);
-            break;
-        case MAT_T_UINT32:
-            data_size = sizeof(mat_uint32_t);
-            break;
-        case MAT_T_INT16:
-            data_size = sizeof(mat_int16_t);
-            break;
-        case MAT_T_UINT16:
-            data_size = sizeof(mat_uint16_t);
-            break;
-        case MAT_T_UINT8:
-            data_size = sizeof(mat_uint8_t);
-            break;
-        case MAT_T_INT8:
-            data_size = sizeof(mat_int8_t);
-            break;
+        case MAT_T_UTF8:
+        case MAT_T_UTF16:
+        case MAT_T_UTF32:
+            return 1;
         default:
-            return 0;
-    }
-    InflateSkip(mat,z,len*data_size);
-    return len;
-}
-
-/** @brief Inflates the variable's tag.
- *
- * @c buf must hold at least 8 bytes
- * @ingroup mat_internal
- * @param mat Pointer to the MAT file
- * @param matvar Pointer to the MAT variable
- * @param buf Pointer to store the 8-byte variable tag
- * @return Number of bytes read from the file
- */
-size_t
-InflateVarTag(mat_t *mat, matvar_t *matvar, void *buf)
-{
-    mat_uint8_t comp_buf[32];
-    int    err;
-    size_t bytesread = 0, readresult = 1;
-
-    if ( buf == NULL )
-        return 0;
-
-    if ( !matvar->internal->z->avail_in ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
-    }
-    matvar->internal->z->avail_out = 8;
-    matvar->internal->z->next_out = ZLIB_BYTE_PTR(buf);
-    err = inflate(matvar->internal->z,Z_NO_FLUSH);
-    if ( err != Z_OK ) {
-        Mat_Critical("InflateVarTag: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-        return bytesread;
-    }
-    while ( matvar->internal->z->avail_out && !matvar->internal->z->avail_in && 1 == readresult ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        readresult = fread(comp_buf,1,1,(FILE*)mat->fp);
-        bytesread += readresult;
-        err = inflate(matvar->internal->z,Z_NO_FLUSH);
-        if ( err != Z_OK ) {
-            Mat_Critical("InflateVarTag: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-            return bytesread;
-        }
-    }
-
-    if ( matvar->internal->z->avail_in ) {
-        (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
-        bytesread -= matvar->internal->z->avail_in;
-        matvar->internal->z->avail_in = 0;
-    }
-
-    return bytesread;
-}
-
-/** @brief Inflates the Array Flags Tag and the Array Flags data.
- *
- * @c buf must hold at least 16 bytes
- * @ingroup mat_internal
- * @param mat Pointer to the MAT file
- * @param matvar Pointer to the MAT variable
- * @param buf Pointer to store the 16-byte array flags tag and data
- * @return Number of bytes read from the file
- */
-size_t
-InflateArrayFlags(mat_t *mat, matvar_t *matvar, void *buf)
-{
-    mat_uint8_t comp_buf[32];
-    int    err;
-    size_t bytesread = 0, readresult = 1;
-
-    if ( buf == NULL )
-        return 0;
-
-    if ( !matvar->internal->z->avail_in ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
-    }
-    matvar->internal->z->avail_out = 16;
-    matvar->internal->z->next_out = ZLIB_BYTE_PTR(buf);
-    err = inflate(matvar->internal->z,Z_NO_FLUSH);
-    if ( err != Z_OK ) {
-        Mat_Critical("InflateArrayFlags: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-        return bytesread;
-    }
-    while ( matvar->internal->z->avail_out && !matvar->internal->z->avail_in && 1 == readresult ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        readresult = fread(comp_buf,1,1,(FILE*)mat->fp);
-        bytesread += readresult;
-        err = inflate(matvar->internal->z,Z_NO_FLUSH);
-        if ( err != Z_OK ) {
-            Mat_Critical("InflateArrayFlags: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-            return bytesread;
-        }
-    }
-
-    if ( matvar->internal->z->avail_in ) {
-        (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
-        bytesread -= matvar->internal->z->avail_in;
-        matvar->internal->z->avail_in = 0;
+            break;
     }
 
-    return bytesread;
+    return InflateSkip(mat, z, (unsigned int)Mat_SizeOf(data_type)*len, NULL);
 }
 
 /** @brief Inflates the dimensions tag and the dimensions data
  *
  * @c buf must hold at least (8+4*rank) bytes where rank is the number of
  * dimensions. If the end of the dimensions data is not aligned on an 8-byte
  * boundary, this function eats up those bytes and stores then in @c buf.
  * @ingroup mat_internal
  * @param mat Pointer to the MAT file
- * @param matvar Pointer to the MAT variable
+ * @param z zlib compression stream
  * @param buf Pointer to store the dimensions flag and data
- * @param nbytes Size of buf in bytes
- * @param dims Output buffer to be allocated if (8+4*rank) > nbytes
- * @return Number of bytes read from the file
+ * @param nBytes Size of buf in bytes
+ * @param dims Output buffer to be allocated if (8+4*rank) > nBytes
+ * @param[out] bytesread Number of bytes read from the file
+ * @retval 0 on success
+
  */
-size_t
-InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint32_t** dims)
+int
+InflateRankDims(mat_t *mat, z_streamp z, void *buf, size_t nBytes, mat_uint32_t** dims, size_t* bytesread)
 {
-    mat_uint8_t comp_buf[32];
     mat_int32_t tag[2];
-    int    err, rank, i;
-    size_t bytesread = 0, readresult = 1;
+    int rank, i, err;
 
     if ( buf == NULL )
-        return 0;
+        return 1;
 
-    if ( !matvar->internal->z->avail_in ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
-    }
-    matvar->internal->z->avail_out = 8;
-    matvar->internal->z->next_out = ZLIB_BYTE_PTR(buf);
-    err = inflate(matvar->internal->z,Z_NO_FLUSH);
-    if ( err != Z_OK ) {
-        Mat_Critical("InflateRankDims: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-        return bytesread;
-    }
-    while ( matvar->internal->z->avail_out && !matvar->internal->z->avail_in && 1 == readresult ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        readresult = fread(comp_buf,1,1,(FILE*)mat->fp);
-        bytesread += readresult;
-        err = inflate(matvar->internal->z,Z_NO_FLUSH);
-        if ( err != Z_OK ) {
-            Mat_Critical("InflateRankDims: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-            return bytesread;
-        }
+    err = Inflate(mat, z, buf, 8, bytesread);
+    if ( 0 != err ) {
+        return err;
     }
     tag[0] = *(int *)buf;
     tag[1] = *((int *)buf+1);
     if ( mat->byteswap ) {
         Mat_int32Swap(tag);
         Mat_int32Swap(tag+1);
     }
     if ( (tag[0] & 0x0000ffff) != MAT_T_INT32 ) {
         Mat_Critical("InflateRankDims: Reading dimensions expected type MAT_T_INT32");
-        return bytesread;
+        return 1;
     }
     rank = tag[1];
     if ( rank % 8 != 0 )
         i = 8-(rank %8);
     else
         i = 0;
-    rank+=i;
+    rank += i;
 
-    if ( !matvar->internal->z->avail_in ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
-    }
-
-    matvar->internal->z->avail_out = rank;
-    if ( sizeof(mat_uint32_t)*(rank + 2) <= nbytes ) {
-        matvar->internal->z->next_out = ZLIB_BYTE_PTR((mat_int32_t *)buf+2);
+    if ( sizeof(mat_uint32_t)*(rank + 2) <= nBytes ) {
+        err = Inflate(mat, z, (mat_int32_t *)buf+2, (unsigned int)rank, bytesread);
     } else {
         /* Cannot use too small buf, but can allocate output buffer dims */
         *dims = (mat_uint32_t*)calloc(rank, sizeof(mat_uint32_t));
         if ( NULL != *dims ) {
-            matvar->internal->z->next_out = ZLIB_BYTE_PTR(*dims);
+            err = Inflate(mat, z, *dims, (unsigned int)rank, bytesread);
         } else {
             *((mat_int32_t *)buf+1) = 0;
             Mat_Critical("Error allocating memory for dims");
-            return bytesread;
+            return 1;
         }
     }
-    err = inflate(matvar->internal->z,Z_NO_FLUSH);
-    if ( err != Z_OK ) {
-        Mat_Critical("InflateRankDims: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-        return bytesread;
-    }
-    readresult = 1;
-    while ( matvar->internal->z->avail_out && !matvar->internal->z->avail_in && 1 == readresult ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        readresult = fread(comp_buf,1,1,(FILE*)mat->fp);
-        bytesread += readresult;
-        err = inflate(matvar->internal->z,Z_NO_FLUSH);
-        if ( err != Z_OK ) {
-            Mat_Critical("InflateRankDims: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-            return bytesread;
-        }
-    }
-
-    if ( matvar->internal->z->avail_in ) {
-        (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
-        bytesread -= matvar->internal->z->avail_in;
-        matvar->internal->z->avail_in = 0;
-    }
 
-    return bytesread;
+    return err;
 }
 
-/** @brief Inflates the variable name
+/** @brief Inflates the data
  *
+ * buf must hold at least @c nBytes bytes
  * @ingroup mat_internal
  * @param mat Pointer to the MAT file
- * @param matvar Pointer to the MAT variable
- * @param buf Pointer to store the variables name
- * @param N Number of characters in the name
- * @return Number of bytes read from the file
- */
-size_t
-InflateVarName(mat_t *mat, matvar_t *matvar, void *buf, int N)
-{
-    mat_uint8_t comp_buf[32];
-    int    err;
-    size_t bytesread = 0, readresult = 1;
-
-    if ( buf == NULL )
-        return 0;
-
-    if ( !matvar->internal->z->avail_in ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
-    }
-    matvar->internal->z->avail_out = N;
-    matvar->internal->z->next_out = ZLIB_BYTE_PTR(buf);
-    err = inflate(matvar->internal->z,Z_NO_FLUSH);
-    if ( err != Z_OK ) {
-        Mat_Critical("InflateVarName: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-        return bytesread;
-    }
-    while ( matvar->internal->z->avail_out && !matvar->internal->z->avail_in && 1 == readresult ) {
-        matvar->internal->z->avail_in = 1;
-        matvar->internal->z->next_in = comp_buf;
-        readresult = fread(comp_buf,1,1,(FILE*)mat->fp);
-        bytesread += readresult;
-        err = inflate(matvar->internal->z,Z_NO_FLUSH);
-        if ( err != Z_OK ) {
-            Mat_Critical("InflateVarName: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-            return bytesread;
-        }
-    }
-
-    if ( matvar->internal->z->avail_in ) {
-        (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
-        bytesread -= matvar->internal->z->avail_in;
-        matvar->internal->z->avail_in = 0;
-    }
-
-    return bytesread;
-}
+ * @param z zlib compression stream
+ * @param buf Pointer to store the uncompressed data
+ * @param nBytes Number of uncompressed bytes to inflate
+ * @param[out] bytesread Number of bytes read from the file
+ * @retval 0 on success
 
-/** @brief Inflates the data's type
- *
- * buf must hold at least 4 bytes
- * @ingroup mat_internal
- * @param mat Pointer to the MAT file
- * @param matvar Pointer to the MAT variable
- * @param buf Pointer to store the data type
- * @return Number of bytes read from the file
  */
-size_t
-InflateDataType(mat_t *mat, z_streamp z, void *buf)
+int
+Inflate(mat_t *mat, z_streamp z, void *buf, unsigned int nBytes, size_t* bytesread)
 {
-    mat_uint8_t comp_buf[32];
-    int    err;
-    size_t bytesread = 0, readresult = 1;
+    mat_uint8_t comp_buf[4];
+    int err = 0;
 
     if ( buf == NULL )
-        return 0;
+        return 1;
 
     if ( !z->avail_in ) {
-        z->avail_in = 1;
+        size_t nbytes = fread(comp_buf, 1, 1, (FILE*)mat->fp);
+        if ( 0 == nbytes ) {
+            return err;
+        }
+        if ( NULL != bytesread ) {
+            *bytesread += nbytes;
+        }
+        z->avail_in = (uInt)nbytes;
         z->next_in = comp_buf;
-        bytesread += fread(comp_buf,1,1,(FILE*)mat->fp);
     }
-    z->avail_out = 4;
+    z->avail_out = nBytes;
     z->next_out = ZLIB_BYTE_PTR(buf);
     err = inflate(z,Z_NO_FLUSH);
     if ( err != Z_OK ) {
-        Mat_Critical("InflateDataType: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-        return bytesread;
+        Mat_Critical("Inflate: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
+        return err;
     }
-    while ( z->avail_out && !z->avail_in && 1 == readresult ) {
-        z->avail_in = 1;
+    while ( z->avail_out && !z->avail_in ) {
+        size_t nbytes = fread(comp_buf, 1, 1, (FILE*)mat->fp);
+        if ( 0 == nbytes ) {
+            break;
+        }
+        if ( NULL != bytesread ) {
+            *bytesread += nbytes;
+        }
+        z->avail_in = (uInt)nbytes;
         z->next_in = comp_buf;
-        readresult = fread(comp_buf,1,1,(FILE*)mat->fp);
-        bytesread += readresult;
         err = inflate(z,Z_NO_FLUSH);
         if ( err != Z_OK ) {
-            Mat_Critical("InflateDataType: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
-            return bytesread;
+            Mat_Critical("Inflate: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
+            return err;
         }
     }
 
     if ( z->avail_in ) {
-        (void)fseek((FILE*)mat->fp,-(int)z->avail_in,SEEK_CUR);
-        bytesread -= z->avail_in;
+        const long offset = -(long)z->avail_in;
+        (void)fseek((FILE*)mat->fp, offset, SEEK_CUR);
+        if ( NULL != bytesread ) {
+            *bytesread -= z->avail_in;
+        }
         z->avail_in = 0;
     }
 
-    return bytesread;
+    if ( z->avail_out && feof((FILE*)mat->fp) ) {
+        Mat_DebugMessage(1, "Inflate: Read beyond EOF error: Read %u bytes, expected %u bytes",
+            nBytes - z->avail_out, nBytes);
+    }
+
+    return err;
 }
 
-/** @brief Inflates the data
+/** @brief Inflates the data in blocks
  *
  * buf must hold at least @c nBytes bytes
  * @ingroup mat_internal
  * @param mat Pointer to the MAT file
  * @param z zlib compression stream
- * @param buf Pointer to store the data type
- * @param nBytes Number of bytes to inflate
- * @return Number of bytes read from the file
+ * @param buf Pointer to store the uncompressed data
+ * @param nBytes Number of uncompressed bytes to inflate
+ * @param[out] bytesread Number of bytes read from the file
+ * @retval 0 on success
+
  */
-size_t
+int
 InflateData(mat_t *mat, z_streamp z, void *buf, unsigned int nBytes)
 {
     mat_uint8_t comp_buf[READ_BLOCK_SIZE];
-    int    err;
-    unsigned int bytesread = 0;
+    int err = 0;
+    unsigned int n;
+    size_t bytesread = 0;
 
     if ( buf == NULL )
-        return 0;
+        return 1;
     if ( nBytes == 0 ) {
-        return bytesread;
+        return 0;
     }
 
+    n = nBytes < READ_BLOCK_SIZE ? nBytes : READ_BLOCK_SIZE;
     if ( !z->avail_in ) {
-        if ( nBytes > READ_BLOCK_SIZE ) {
-            z->avail_in = fread(comp_buf,1,READ_BLOCK_SIZE,(FILE*)mat->fp);
-        } else {
-            z->avail_in = fread(comp_buf,1,nBytes,(FILE*)mat->fp);
+        size_t nbytes = fread(comp_buf, 1, n, (FILE*)mat->fp);
+        if ( 0 == nbytes ) {
+            return err;
         }
-        bytesread += z->avail_in;
+        bytesread += nbytes;
+        z->avail_in = (uInt)nbytes;
         z->next_in = comp_buf;
     }
     z->avail_out = nBytes;
     z->next_out = ZLIB_BYTE_PTR(buf);
     err = inflate(z,Z_FULL_FLUSH);
     if ( err == Z_STREAM_END ) {
-        return bytesread;
+        return err;
     } else if ( err != Z_OK ) {
         Mat_Critical("InflateData: inflate returned %s",zError( err == Z_NEED_DICT ? Z_DATA_ERROR : err ));
-        return bytesread;
+        return err;
     }
     while ( z->avail_out && !z->avail_in ) {
+        size_t nbytes;
         if ( nBytes > READ_BLOCK_SIZE + bytesread ) {
-            z->avail_in = fread(comp_buf,1,READ_BLOCK_SIZE,(FILE*)mat->fp);
+            nbytes = fread(comp_buf, 1, READ_BLOCK_SIZE, (FILE*)mat->fp);
         } else if ( nBytes < 1 + bytesread ) { /* Read a byte at a time */
-            z->avail_in = fread(comp_buf,1,1,(FILE*)mat->fp);
+            nbytes = fread(comp_buf, 1, 1, (FILE*)mat->fp);
         } else {
-            z->avail_in = fread(comp_buf,1,nBytes-bytesread,(FILE*)mat->fp);
+            nbytes = fread(comp_buf, 1, nBytes - bytesread, (FILE*)mat->fp);
         }
-        bytesread += z->avail_in;
+        if ( 0 == nbytes ) {
+            break;
+        }
+        bytesread += nbytes;
+        z->avail_in = (uInt)nbytes;
         z->next_in = comp_buf;
         err = inflate(z,Z_FULL_FLUSH);
         if ( err == Z_STREAM_END ) {
             break;
-        } else if ( err != Z_OK && err != Z_BUF_ERROR ) {
+        } else if ( err != Z_OK ) {
             Mat_Critical("InflateData: inflate returned %s",zError(err == Z_NEED_DICT ? Z_DATA_ERROR : err));
             break;
         }
     }
 
     if ( z->avail_in ) {
-        long offset = -(long)z->avail_in;
-        (void)fseek((FILE*)mat->fp,offset,SEEK_CUR);
+        const long offset = -(long)z->avail_in;
+        (void)fseek((FILE*)mat->fp, offset, SEEK_CUR);
         bytesread -= z->avail_in;
         z->avail_in = 0;
     }
 
-    return bytesread;
+    if ( z->avail_out && feof((FILE*)mat->fp) ) {
+        Mat_DebugMessage(1, "InflateData: Read beyond EOF error: Read %u bytes, expected %u bytes",
+            nBytes - z->avail_out, nBytes);
+    }
+
+    return err;
 }
 
 /** @endcond */
 
 #endif
diff --git a/src/mat.c b/src/mat.c
index be3f517..dd0ca63 100644
--- a/src/mat.c
+++ b/src/mat.c
@@ -244,75 +244,102 @@ ClassType2DataType(enum matio_classes class_type)
 /** @brief Gets number of elements from a variable
  *
  * Gets number of elements from a variable by overflow-safe
  * multiplication
  * @ingroup MAT
  * @param matvar MAT variable information
  * @param nelems Number of elements
  * @retval 0 on success
  */
-int SafeMulDims(const matvar_t *matvar, size_t* nelems)
+int MulDims(const matvar_t *matvar, size_t* nelems)
 {
     int i;
 
     if ( matvar->rank == 0 ) {
         *nelems = 0;
         return 0;
     }
 
     for ( i = 0; i < matvar->rank; i++ ) {
         if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {
             *nelems = 0;
             return 1;
         }
     }
 
     return 0;
 }
 
 /** @brief Multiplies two unsigned integers
  *
  * @param res Result
  * @param a First operand
  * @param b Second operand
  * @retval 0 on success
  */
-int SafeMul(size_t* res, size_t a, size_t b)
+int Mul(size_t* res, size_t a, size_t b)
 {
     if ( !psnip_safe_size_mul(res, a, b) ) {
         *res = 0;
         return 1;
     }
 
     return 0;
 }
 
 /** @brief Adds two unsigned integers
  *
  * @param res Result
  * @param a First operand
  * @param b Second operand
  * @retval 0 on success
  */
-int SafeAdd(size_t* res, size_t a, size_t b)
+int Add(size_t* res, size_t a, size_t b)
 {
     if ( !psnip_safe_size_add(res, a, b) ) {
         *res = 0;
         return 1;
     }
 
     return 0;
 }
 
+/** @brief Read from file and check success
+ *
+ * @param buf Buffer for reading
+ * @param size Element size in bytes
+ * @param count Element count
+ * @param fp File pointer
+ * @param[out] bytesread Number of bytes read from the file
+ * @retval 0 on success
+ */
+int
+Read(void* buf, size_t size, size_t count, FILE* fp, size_t* bytesread) {
+    const size_t readcount = fread(buf, size, count, fp);
+    int err = readcount != count;
+    if ( NULL != bytesread ) {
+        *bytesread += readcount*size;
+    }
+    if ( err && feof(fp) && 0 == readcount) {
+        err = 0;
+    }
+    if ( err ) {
+        Mat_DebugMessage(1, "Read beyond EOF error: Read %"
+            SIZE_T_FMTSTR " bytes, expected %"
+            SIZE_T_FMTSTR " bytes", readcount*size, count*size);
+    }
+    return err;
+}
+
 /*
  *===================================================================
  *                 Public Functions
  *===================================================================
  */
 
 /** @brief Get the version of the library
  *
  * Gets the version number of the library
  * @param major Pointer to store the library major version number
  * @param minor Pointer to store the library minor version number
  * @param release Pointer to store the library release version number
  */
@@ -382,186 +409,186 @@ mat_t *
 Mat_Open(const char *matname,int mode)
 {
     FILE *fp = NULL;
     mat_int16_t tmp, tmp2;
     mat_t *mat = NULL;
     size_t bytesread = 0;
 
     if ( (mode & 0x01) == MAT_ACC_RDONLY ) {
 #if defined(_WIN32) && defined(_MSC_VER)
         wchar_t* wname = utf82u(matname);
         if ( NULL != wname ) {
             fp = _wfopen(wname, L"rb");
             free(wname);
         }
 #else
         fp = fopen(matname, "rb");
 #endif
         if ( !fp )
             return NULL;
     } else if ( (mode & 0x01) == MAT_ACC_RDWR ) {
 #if defined(_WIN32) && defined(_MSC_VER)
         wchar_t* wname = utf82u(matname);
         if ( NULL != wname ) {
             fp = _wfopen(wname, L"r+b");
             free(wname);
         }
 #else
         fp = fopen(matname, "r+b");
 #endif
         if ( !fp ) {
             mat = Mat_CreateVer(matname,NULL,(enum mat_ft)(mode&0xfffffffe));
             return mat;
         }
     } else {
         Mat_Critical("Invalid file open mode");
         return NULL;
     }
 
     mat = (mat_t*)malloc(sizeof(*mat));
     if ( NULL == mat ) {
         fclose(fp);
         Mat_Critical("Couldn't allocate memory for the MAT file");
         return NULL;
     }
 
     mat->fp = fp;
-    mat->header        = (char*)calloc(128,sizeof(char));
+    mat->header = (char*)calloc(128,sizeof(char));
     if ( NULL == mat->header ) {
         free(mat);
         fclose(fp);
         Mat_Critical("Couldn't allocate memory for the MAT file header");
         return NULL;
     }
     mat->subsys_offset = (char*)calloc(8,sizeof(char));
     if ( NULL == mat->subsys_offset ) {
         free(mat->header);
         free(mat);
         fclose(fp);
         Mat_Critical("Couldn't allocate memory for the MAT file subsys offset");
         return NULL;
     }
     mat->filename      = NULL;
     mat->version       = 0;
     mat->byteswap      = 0;
     mat->num_datasets  = 0;
 #if defined(MAT73) && MAT73
     mat->refs_id       = -1;
 #endif
     mat->dir           = NULL;
 
     bytesread += fread(mat->header,1,116,fp);
     mat->header[116] = '\0';
     bytesread += fread(mat->subsys_offset,1,8,fp);
     bytesread += 2*fread(&tmp2,2,1,fp);
     bytesread += fread(&tmp,1,2,fp);
 
     if ( 128 == bytesread ) {
         /* v5 and v7.3 files have at least 128 byte header */
         mat->byteswap = -1;
         if ( tmp == 0x4d49 )
             mat->byteswap = 0;
         else if ( tmp == 0x494d ) {
             mat->byteswap = 1;
             Mat_int16Swap(&tmp2);
         }
 
         mat->version = (int)tmp2;
         if ( (mat->version == 0x0100 || mat->version == 0x0200) &&
              -1 != mat->byteswap ) {
             mat->bof = ftell((FILE*)mat->fp);
             if ( mat->bof == -1L ) {
                 free(mat->header);
                 free(mat->subsys_offset);
                 free(mat);
                 fclose(fp);
                 Mat_Critical("Couldn't determine file position");
                 return NULL;
             }
             mat->next_index = 0;
         } else {
             mat->version = 0;
         }
     }
 
     if ( 0 == mat->version ) {
         /* Maybe a V4 MAT file */
         matvar_t *var;
 
         free(mat->header);
         free(mat->subsys_offset);
 
         mat->header        = NULL;
         mat->subsys_offset = NULL;
         mat->fp            = fp;
         mat->version       = MAT_FT_MAT4;
         mat->byteswap      = 0;
         mat->mode          = mode;
         mat->bof           = 0;
         mat->next_index    = 0;
 #if defined(MAT73) && MAT73
         mat->refs_id       = -1;
 #endif
 
         Mat_Rewind(mat);
         var = Mat_VarReadNextInfo4(mat);
         if ( NULL == var &&
              bytesread != 0 ) { /* Accept 0 bytes files as a valid V4 file */
             /* Does not seem to be a valid V4 file */
             Mat_Close(mat);
             mat = NULL;
             Mat_Critical("\"%s\" does not seem to be a valid MAT file",matname);
         } else {
             Mat_VarFree(var);
             Mat_Rewind(mat);
         }
     }
 
     if ( NULL == mat )
         return mat;
 
     mat->filename = strdup(matname);
     mat->mode = mode;
 
     if ( mat->version == 0x0200 ) {
         fclose((FILE*)mat->fp);
 #if defined(MAT73) && MAT73
         mat->fp = malloc(sizeof(hid_t));
 
         if ( (mode & 0x01) == MAT_ACC_RDONLY )
             *(hid_t*)mat->fp=H5Fopen(matname,H5F_ACC_RDONLY,H5P_DEFAULT);
         else if ( (mode & 0x01) == MAT_ACC_RDWR ) {
             hid_t plist_ap;
             plist_ap = H5Pcreate(H5P_FILE_ACCESS);
 #if H5_VERSION_GE(1,10,2)
             H5Pset_libver_bounds(plist_ap,H5F_LIBVER_EARLIEST,H5F_LIBVER_V18);
 #endif
             *(hid_t*)mat->fp=H5Fopen(matname,H5F_ACC_RDWR,plist_ap);
             H5Pclose(plist_ap);
         }
 
         if ( -1 < *(hid_t*)mat->fp ) {
             H5G_info_t group_info;
             memset(&group_info, 0, sizeof(group_info));
             H5Gget_info(*(hid_t*)mat->fp, &group_info);
             mat->num_datasets = (size_t)group_info.nlinks;
             mat->refs_id      = -1;
         }
 #else
         mat->fp = NULL;
         Mat_Close(mat);
         mat = NULL;
         Mat_Critical("No HDF5 support which is required to read the v7.3 "
                      "MAT file \"%s\"",matname);
 #endif
     }
 
     return mat;
 }
 
 /** @brief Closes an open Matlab MAT file
  *
  * Closes the given Matlab MAT file and frees any memory with it.
  * @ingroup MAT
  * @param mat Pointer to the MAT file
  * @retval 0 on success
  */
@@ -940,195 +967,195 @@ matvar_t *
 Mat_VarCreate(const char *name,enum matio_classes class_type,
     enum matio_types data_type,int rank,size_t *dims,void *data,int opt)
 {
     size_t nelems = 1, data_size;
     matvar_t *matvar = NULL;
     int j, err;
 
     if ( dims == NULL )
         return NULL;
 
     matvar = Mat_VarCalloc();
     if ( NULL == matvar )
         return NULL;
 
     matvar->compression = MAT_COMPRESSION_NONE;
     matvar->isComplex   = opt & MAT_F_COMPLEX;
     matvar->isGlobal    = opt & MAT_F_GLOBAL;
     matvar->isLogical   = opt & MAT_F_LOGICAL;
     if ( name )
         matvar->name = strdup(name);
     matvar->rank = rank;
     matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
     for ( j = 0; j < matvar->rank; j++ ) {
         matvar->dims[j] = dims[j];
         nelems *= dims[j];
     }
     matvar->class_type = class_type;
     matvar->data_type  = data_type;
     switch ( data_type ) {
         case MAT_T_INT8:
             data_size = 1;
             break;
         case MAT_T_UINT8:
             data_size = 1;
             break;
         case MAT_T_INT16:
             data_size = 2;
             break;
         case MAT_T_UINT16:
             data_size = 2;
             break;
         case MAT_T_INT64:
             data_size = 8;
             break;
         case MAT_T_UINT64:
             data_size = 8;
             break;
         case MAT_T_INT32:
             data_size = 4;
             break;
         case MAT_T_UINT32:
             data_size = 4;
             break;
         case MAT_T_SINGLE:
             data_size = sizeof(float);
             break;
         case MAT_T_DOUBLE:
             data_size = sizeof(double);
             break;
         case MAT_T_UTF8:
             data_size = 1;
             break;
         case MAT_T_UTF16:
             data_size = 2;
             break;
         case MAT_T_UTF32:
             data_size = 4;
             break;
         case MAT_T_CELL:
             data_size = sizeof(matvar_t **);
             break;
         case MAT_T_STRUCT:
         {
             data_size = sizeof(matvar_t **);
             if ( data != NULL ) {
                 matvar_t **fields = (matvar_t**)data;
                 size_t nfields = 0;
                 while ( fields[nfields] != NULL )
                     nfields++;
                 if ( nelems )
                     nfields /= nelems;
                 matvar->internal->num_fields = nfields;
                 if ( nfields ) {
                     size_t i;
                     matvar->internal->fieldnames =
                         (char**)calloc(nfields,sizeof(*matvar->internal->fieldnames));
                     for ( i = 0; i < nfields; i++ )
                         matvar->internal->fieldnames[i] = strdup(fields[i]->name);
-                    err = SafeMul(&nelems, nelems, nfields);
+                    err = Mul(&nelems, nelems, nfields);
                     if ( err ) {
                         Mat_VarFree(matvar);
                         Mat_Critical("Integer multiplication overflow");
                         return NULL;
                     }
                 }
             }
             break;
         }
         default:
             Mat_VarFree(matvar);
             Mat_Critical("Unrecognized data_type");
             return NULL;
     }
     if ( matvar->class_type == MAT_C_SPARSE ) {
         matvar->data_size = sizeof(mat_sparse_t);
         matvar->nbytes    = matvar->data_size;
     } else {
         matvar->data_size = data_size;
-        err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+        err = Mul(&matvar->nbytes, nelems, matvar->data_size);
         if ( err ) {
             Mat_VarFree(matvar);
             Mat_Critical("Integer multiplication overflow");
             return NULL;
         }
     }
     if ( data == NULL ) {
         if ( MAT_C_CELL == matvar->class_type && nelems > 0 )
             matvar->data = calloc(nelems,sizeof(matvar_t*));
         else
             matvar->data = NULL;
     } else if ( opt & MAT_F_DONT_COPY_DATA ) {
         matvar->data         = data;
         matvar->mem_conserve = 1;
     } else if ( MAT_C_SPARSE == matvar->class_type ) {
         mat_sparse_t *sparse_data, *sparse_data_in;
 
         sparse_data_in = (mat_sparse_t*)data;
         sparse_data    = (mat_sparse_t*)malloc(sizeof(mat_sparse_t));
         if ( NULL != sparse_data ) {
             sparse_data->nzmax = sparse_data_in->nzmax;
             sparse_data->nir   = sparse_data_in->nir;
             sparse_data->njc   = sparse_data_in->njc;
             sparse_data->ndata = sparse_data_in->ndata;
             sparse_data->ir = (mat_uint32_t*)malloc(sparse_data->nir*sizeof(*sparse_data->ir));
             if ( NULL != sparse_data->ir )
                 memcpy(sparse_data->ir,sparse_data_in->ir,
                        sparse_data->nir*sizeof(*sparse_data->ir));
             sparse_data->jc = (mat_uint32_t*)malloc(sparse_data->njc*sizeof(*sparse_data->jc));
             if ( NULL != sparse_data->jc )
                 memcpy(sparse_data->jc,sparse_data_in->jc,
                        sparse_data->njc*sizeof(*sparse_data->jc));
             if ( matvar->isComplex ) {
                 sparse_data->data = malloc(sizeof(mat_complex_split_t));
                 if ( NULL != sparse_data->data ) {
                     mat_complex_split_t *complex_data,*complex_data_in;
                     complex_data     = (mat_complex_split_t*)sparse_data->data;
                     complex_data_in  = (mat_complex_split_t*)sparse_data_in->data;
                     complex_data->Re = malloc(sparse_data->ndata*data_size);
                     complex_data->Im = malloc(sparse_data->ndata*data_size);
                     if ( NULL != complex_data->Re )
                         memcpy(complex_data->Re,complex_data_in->Re,
                                sparse_data->ndata*data_size);
                     if ( NULL != complex_data->Im )
                         memcpy(complex_data->Im,complex_data_in->Im,
                                sparse_data->ndata*data_size);
                 }
             } else {
                 sparse_data->data = malloc(sparse_data->ndata*data_size);
                 if ( NULL != sparse_data->data )
                     memcpy(sparse_data->data,sparse_data_in->data,
                            sparse_data->ndata*data_size);
             }
         }
         matvar->data = sparse_data;
     } else {
         if ( matvar->isComplex ) {
             matvar->data   = malloc(sizeof(mat_complex_split_t));
             if ( NULL != matvar->data && matvar->nbytes > 0 ) {
                 mat_complex_split_t *complex_data    = (mat_complex_split_t*)matvar->data;
                 mat_complex_split_t *complex_data_in = (mat_complex_split_t*)data;
 
                 complex_data->Re = malloc(matvar->nbytes);
                 complex_data->Im = malloc(matvar->nbytes);
                 if ( NULL != complex_data->Re )
                     memcpy(complex_data->Re,complex_data_in->Re,matvar->nbytes);
                 if ( NULL != complex_data->Im )
                     memcpy(complex_data->Im,complex_data_in->Im,matvar->nbytes);
             }
         } else if ( matvar->nbytes > 0 ) {
             matvar->data   = malloc(matvar->nbytes);
             if ( NULL != matvar->data )
                 memcpy(matvar->data,data,matvar->nbytes);
         }
         matvar->mem_conserve = 0;
     }
 
     return matvar;
 }
 
 /** @brief Copies a file
  *
  * @param src source file path
  * @param dst destination file path
  * @retval 0 on success
  */
@@ -1550,174 +1577,174 @@ void
 Mat_VarFree(matvar_t *matvar)
 {
     size_t nelems = 0;
 
     if ( NULL == matvar )
         return;
     if ( NULL != matvar->dims ) {
         nelems = 1;
-        SafeMulDims(matvar, &nelems);
+        MulDims(matvar, &nelems);
         free(matvar->dims);
     }
     if ( NULL != matvar->data ) {
         switch (matvar->class_type ) {
             case MAT_C_STRUCT:
                 if ( !matvar->mem_conserve ) {
                     matvar_t **fields = (matvar_t**)matvar->data;
                     size_t nelems_x_nfields, i;
-                    SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
+                    Mul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
                     for ( i = 0; i < nelems_x_nfields; i++ )
                         Mat_VarFree(fields[i]);
 
                     free(matvar->data);
                 }
                 break;
             case MAT_C_CELL:
                 if ( !matvar->mem_conserve ) {
                     matvar_t **cells = (matvar_t**)matvar->data;
                     size_t i;
                     for ( i = 0; i < nelems; i++ )
                         Mat_VarFree(cells[i]);
 
                     free(matvar->data);
                 }
                 break;
             case MAT_C_SPARSE:
                 if ( !matvar->mem_conserve ) {
                     mat_sparse_t *sparse;
                     sparse = (mat_sparse_t*)matvar->data;
                     if ( sparse->ir != NULL )
                         free(sparse->ir);
                     if ( sparse->jc != NULL )
                         free(sparse->jc);
                     if ( matvar->isComplex && NULL != sparse->data ) {
                         ComplexFree((mat_complex_split_t*)sparse->data);
                     } else if ( sparse->data != NULL ) {
                         free(sparse->data);
                     }
                     free(sparse);
                 }
                 break;
             case MAT_C_DOUBLE:
             case MAT_C_SINGLE:
             case MAT_C_INT64:
             case MAT_C_UINT64:
             case MAT_C_INT32:
             case MAT_C_UINT32:
             case MAT_C_INT16:
             case MAT_C_UINT16:
             case MAT_C_INT8:
             case MAT_C_UINT8:
             case MAT_C_CHAR:
                 if ( !matvar->mem_conserve ) {
                     if ( matvar->isComplex ) {
                         ComplexFree((mat_complex_split_t*)matvar->data);
                     } else {
                         free(matvar->data);
                     }
                 }
                 break;
             case MAT_C_FUNCTION:
                 if ( !matvar->mem_conserve ) {
                     free(matvar->data);
                 }
                 break;
             case MAT_C_EMPTY:
             case MAT_C_OBJECT:
             case MAT_C_OPAQUE:
                 break;
         }
     }
 
     if ( NULL != matvar->internal ) {
 #if HAVE_ZLIB
         if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
             inflateEnd(matvar->internal->z);
             free(matvar->internal->z);
             if ( matvar->class_type == MAT_C_SPARSE && NULL != matvar->internal->data ) {
                 mat_sparse_t *sparse;
                 sparse = (mat_sparse_t*)matvar->internal->data;
                 if ( sparse->ir != NULL )
                     free(sparse->ir);
                 if ( sparse->jc != NULL )
                     free(sparse->jc);
                 if ( matvar->isComplex && NULL != sparse->data ) {
                     ComplexFree((mat_complex_split_t*)sparse->data);
                 } else if ( sparse->data != NULL ) {
                     free(sparse->data);
                 }
                 free(sparse);
             }
             else if ( matvar->isComplex && NULL != matvar->internal->data ) {
                 ComplexFree((mat_complex_split_t*)matvar->internal->data);
             } else if ( NULL != matvar->internal->data ) {
                 free(matvar->internal->data);
             }
         }
 #endif
 #if defined(MAT73) && MAT73
         if ( -1 < matvar->internal->id ) {
             switch ( H5Iget_type(matvar->internal->id) ) {
                 case H5I_GROUP:
                     H5Gclose(matvar->internal->id);
                     matvar->internal->id = -1;
                     break;
                 case H5I_DATASET:
                     H5Dclose(matvar->internal->id);
                     matvar->internal->id = -1;
                     break;
                 default:
                     break;
             }
         }
         if ( 0 < matvar->internal->hdf5_ref ) {
             switch ( H5Iget_type(matvar->internal->id) ) {
                 case H5I_GROUP:
                     H5Gclose(matvar->internal->id);
                     matvar->internal->hdf5_ref = -1;
                     break;
                 case H5I_DATASET:
                     H5Dclose(matvar->internal->id);
                     matvar->internal->hdf5_ref = -1;
                     break;
                 default:
                     break;
             }
         }
         if ( NULL != matvar->internal->hdf5_name ) {
             free(matvar->internal->hdf5_name);
             matvar->internal->hdf5_name = NULL;
         }
 #endif
         if ( NULL != matvar->internal->fieldnames &&
             matvar->internal->num_fields > 0 ) {
             size_t i;
             for ( i = 0; i < matvar->internal->num_fields; i++ ) {
                 if ( NULL != matvar->internal->fieldnames[i] )
                     free(matvar->internal->fieldnames[i]);
             }
             free(matvar->internal->fieldnames);
         }
         free(matvar->internal);
         matvar->internal = NULL;
     }
     if ( NULL != matvar->name )
         free(matvar->name);
     free(matvar);
 }
 
 /** @brief Calculate a single subscript from a set of subscript values
  *
  * Calculates a single linear subscript (0-relative) given a 1-relative
  * subscript for each dimension.  The calculation uses the formula below where
  * index is the linear index, s is an array of length RANK where each element
  * is the subscript for the corresponding dimension, D is an array whose
  * elements are the dimensions of the variable.
  * \f[
  *   index = \sum\limits_{k=0}^{RANK-1} [(s_k - 1) \prod\limits_{l=0}^{k} D_l ]
  * \f]
  * @ingroup MAT
  * @param rank Rank of the variable
  * @param dims Dimensions of the variable
  * @param subs Array of dimension subscripts
  * @return Single (linear) subscript
  */
@@ -1877,120 +1904,120 @@ size_t
 Mat_VarGetSize(matvar_t *matvar)
 {
     int err;
     size_t i;
     size_t bytes = 0, overhead = 0, ptr = 0;
 
 #if defined(_WIN64) || (defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ == 8)) || (defined(SIZEOF_VOID_P) && (SIZEOF_VOID_P == 8))
     /* 112 bytes cell/struct overhead for 64-bit system */
     overhead = 112;
     ptr = 8;
 #elif defined(_WIN32) || (defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ == 4)) || (defined(SIZEOF_VOID_P) && (SIZEOF_VOID_P == 4))
     /* 60 bytes cell/struct overhead for 32-bit system */
     overhead = 60;
     ptr = 4;
 #endif
 
     if ( matvar->class_type == MAT_C_STRUCT ) {
         matvar_t **fields = (matvar_t**)matvar->data;
         size_t field_name_length;
         if ( NULL != fields ) {
             size_t nelems_x_nfields = matvar->internal->num_fields;
-            err = SafeMulDims(matvar, &nelems_x_nfields);
-            err |= SafeMul(&bytes, nelems_x_nfields, overhead);
+            err = MulDims(matvar, &nelems_x_nfields);
+            err |= Mul(&bytes, nelems_x_nfields, overhead);
             if ( err )
                 return 0;
 
             for ( i = 0; i < nelems_x_nfields; i++ ) {
                 if ( NULL != fields[i] ) {
                     if ( MAT_C_EMPTY != fields[i]->class_type ) {
-                        err = SafeAdd(&bytes, bytes, Mat_VarGetSize(fields[i]));
+                        err = Add(&bytes, bytes, Mat_VarGetSize(fields[i]));
                         if ( err )
                             return 0;
                     } else {
                         bytes -= overhead;
                         bytes += ptr;
                     }
                 }
             }
         }
-        err = SafeMul(&field_name_length, 64 /* max field name length */, matvar->internal->num_fields);
-        err |= SafeAdd(&bytes, bytes, field_name_length);
+        err = Mul(&field_name_length, 64 /* max field name length */, matvar->internal->num_fields);
+        err |= Add(&bytes, bytes, field_name_length);
         if ( err )
             return 0;
     } else if ( matvar->class_type == MAT_C_CELL ) {
         matvar_t **cells = (matvar_t**)matvar->data;
         if ( NULL != cells ) {
             size_t nelems = matvar->nbytes / matvar->data_size;
-            err = SafeMul(&bytes, nelems, overhead);
+            err = Mul(&bytes, nelems, overhead);
             if ( err )
                 return 0;
 
             for ( i = 0; i < nelems; i++ ) {
                 if ( NULL != cells[i] ) {
                     if ( MAT_C_EMPTY != cells[i]->class_type ) {
-                        err = SafeAdd(&bytes, bytes, Mat_VarGetSize(cells[i]));
+                        err = Add(&bytes, bytes, Mat_VarGetSize(cells[i]));
                         if ( err )
                             return 0;
                     } else {
                         bytes -= overhead;
                         bytes += ptr;
                     }
                 }
             }
         }
     } else if ( matvar->class_type == MAT_C_SPARSE ) {
         mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;
         if ( NULL != sparse ) {
             size_t sparse_size = 0;
-            err = SafeMul(&bytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
+            err = Mul(&bytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
             if ( err )
                 return 0;
 
             if ( matvar->isComplex ) {
-                err = SafeMul(&bytes, bytes, 2);
+                err = Mul(&bytes, bytes, 2);
                 if ( err )
                     return 0;
             }
 
 #if defined(_WIN64) || (defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ == 8)) || (defined(SIZEOF_VOID_P) && (SIZEOF_VOID_P == 8))
             /* 8 byte integers for 64-bit system (as displayed in MATLAB (x64) whos) */
-            err = SafeMul(&sparse_size, sparse->nir + sparse->njc, 8);
+            err = Mul(&sparse_size, sparse->nir + sparse->njc, 8);
 #elif defined(_WIN32) || (defined(__SIZEOF_POINTER__) && (__SIZEOF_POINTER__ == 4)) || (defined(SIZEOF_VOID_P) && (SIZEOF_VOID_P == 4))
             /* 4 byte integers for 32-bit system (as defined by mat_sparse_t) */
-            err = SafeMul(&sparse_size, sparse->nir + sparse->njc, 4);
+            err = Mul(&sparse_size, sparse->nir + sparse->njc, 4);
 #endif
-            err |= SafeAdd(&bytes, bytes, sparse_size);
+            err |= Add(&bytes, bytes, sparse_size);
             if ( err )
                 return 0;
 
             if ( sparse->ndata == 0 || sparse->nir == 0 || sparse->njc == 0 ) {
-                err = SafeAdd(&bytes, bytes, matvar->isLogical ? 1 : 8);
+                err = Add(&bytes, bytes, matvar->isLogical ? 1 : 8);
                 if ( err )
                     return 0;
             }
         }
     } else {
         if ( matvar->rank > 0 ) {
             bytes = Mat_SizeOfClass(matvar->class_type);
-            err = SafeMulDims(matvar, &bytes);
+            err = MulDims(matvar, &bytes);
             if ( err )
                 return 0;
 
             if ( matvar->isComplex ) {
-                err = SafeMul(&bytes, bytes, 2);
+                err = Mul(&bytes, bytes, 2);
                 if (err)
                     return 0;
             }
         }
     }
 
     return bytes;
 }
 
 /** @brief Prints the variable information
  *
  * Prints to stdout the values of the @ref matvar_t structure
  * @ingroup MAT
  * @param matvar Pointer to the matvar_t structure
  * @param printdata set to 1 if the Variables data should be printed, else 0
  */
@@ -1998,252 +2025,252 @@ void
 Mat_VarPrint( matvar_t *matvar, int printdata )
 {
     size_t nelems = 0, i, j;
     const char *class_type_desc[18] = {"Undefined","Cell Array","Structure",
        "Object","Character Array","Sparse Array","Double Precision Array",
        "Single Precision Array", "8-bit, signed integer array",
        "8-bit, unsigned integer array","16-bit, signed integer array",
        "16-bit, unsigned integer array","32-bit, signed integer array",
        "32-bit, unsigned integer array","64-bit, signed integer array",
        "64-bit, unsigned integer array","Function","Opaque"};
 
     if ( matvar == NULL )
         return;
     if ( NULL != matvar->name )
         printf("      Name: %s\n", matvar->name);
     printf("      Rank: %d\n", matvar->rank);
     if ( matvar->rank <= 0 )
         return;
     if ( NULL != matvar->dims ) {
         int k;
         nelems = 1;
-        SafeMulDims(matvar, &nelems);
+        MulDims(matvar, &nelems);
         printf("Dimensions: %" SIZE_T_FMTSTR,matvar->dims[0]);
         for ( k = 1; k < matvar->rank; k++ ) {
             printf(" x %" SIZE_T_FMTSTR,matvar->dims[k]);
         }
         printf("\n");
     }
     printf("Class Type: %s",class_type_desc[matvar->class_type]);
     if ( matvar->isComplex )
         printf(" (complex)");
     else if ( matvar->isLogical )
         printf(" (logical)");
     printf("\n");
     if ( matvar->data_type ) {
         const char *data_type_desc[25] = {"Unknown","8-bit, signed integer",
            "8-bit, unsigned integer","16-bit, signed integer",
            "16-bit, unsigned integer","32-bit, signed integer",
            "32-bit, unsigned integer","IEEE 754 single-precision","RESERVED",
            "IEEE 754 double-precision","RESERVED","RESERVED",
            "64-bit, signed integer","64-bit, unsigned integer", "Matlab Array",
            "Compressed Data","Unicode UTF-8 Encoded Character Data",
            "Unicode UTF-16 Encoded Character Data",
            "Unicode UTF-32 Encoded Character Data","RESERVED","String","Cell Array",
            "Structure","Array","Function"};
         printf(" Data Type: %s\n", data_type_desc[matvar->data_type]);
     }
 
     if ( MAT_C_STRUCT == matvar->class_type ) {
         matvar_t **fields = (matvar_t **)matvar->data;
         size_t nfields = matvar->internal->num_fields;
         size_t nelems_x_nfields = 1;
-        SafeMul(&nelems_x_nfields, nelems, nfields);
+        Mul(&nelems_x_nfields, nelems, nfields);
         if ( nelems_x_nfields > 0 ) {
             printf("Fields[%" SIZE_T_FMTSTR "] {\n", nelems_x_nfields);
             for ( i = 0; i < nelems_x_nfields; i++ ) {
                 if ( NULL == fields[i] ) {
                     printf("      Name: %s\n      Rank: %d\n",
                            matvar->internal->fieldnames[i%nfields],0);
                 } else {
                     Mat_VarPrint(fields[i],printdata);
                 }
             }
             printf("}\n");
         } else {
             printf("Fields[%" SIZE_T_FMTSTR "] {\n", nfields);
             for ( i = 0; i < nfields; i++ )
                 printf("      Name: %s\n      Rank: %d\n",
                        matvar->internal->fieldnames[i],0);
             printf("}\n");
         }
         return;
     } else if ( matvar->data == NULL || matvar->data_size < 1 ) {
         if ( printdata )
             printf("{\n}\n");
         return;
     } else if ( MAT_C_CELL == matvar->class_type ) {
         matvar_t **cells = (matvar_t **)matvar->data;
         nelems = matvar->nbytes / matvar->data_size;
         printf("{\n");
         for ( i = 0; i < nelems; i++ )
             Mat_VarPrint(cells[i],printdata);
         printf("}\n");
         return;
     } else if ( !printdata ) {
         return;
     }
 
     printf("{\n");
 
     if ( matvar->rank > 2 ) {
         printf("I can't print more than 2 dimensions\n");
     } else if ( matvar->rank == 1 && NULL != matvar->dims && matvar->dims[0] > 15 ) {
         printf("I won't print more than 15 elements in a vector\n");
     } else if ( matvar->rank == 2 && NULL != matvar->dims ) {
         switch( matvar->class_type ) {
             case MAT_C_DOUBLE:
             case MAT_C_SINGLE:
 #ifdef HAVE_MAT_INT64_T
             case MAT_C_INT64:
 #endif
 #ifdef HAVE_MAT_UINT64_T
             case MAT_C_UINT64:
 #endif
             case MAT_C_INT32:
             case MAT_C_UINT32:
             case MAT_C_INT16:
             case MAT_C_UINT16:
             case MAT_C_INT8:
             case MAT_C_UINT8:
             {
                 size_t stride = Mat_SizeOf(matvar->data_type);
                 if ( matvar->isComplex ) {
                     mat_complex_split_t *complex_data = (mat_complex_split_t*)matvar->data;
                     char *rp = (char*)complex_data->Re;
                     char *ip = (char*)complex_data->Im;
                     for ( i = 0; i < matvar->dims[0] && i < 15; i++ ) {
                         for ( j = 0; j < matvar->dims[1] && j < 15; j++ ) {
                             size_t idx = matvar->dims[0]*j+i;
                             Mat_PrintNumber(matvar->data_type,rp+idx*stride);
                             printf(" + ");
                             Mat_PrintNumber(matvar->data_type,ip+idx*stride);
                             printf("i ");
                         }
                         if ( j < matvar->dims[1] )
                             printf("...");
                         printf("\n");
                     }
                     if ( i < matvar->dims[0] )
                         printf(".\n.\n.\n");
                } else {
                    char *data = (char*)matvar->data;
                    for ( i = 0; i < matvar->dims[0] && i < 15; i++ ) {
                         for ( j = 0; j < matvar->dims[1] && j < 15; j++ ) {
                             size_t idx = matvar->dims[0]*j+i;
                             Mat_PrintNumber(matvar->data_type,
                                             data+idx*stride);
                             printf(" ");
                         }
                         if ( j < matvar->dims[1] )
                             printf("...");
                         printf("\n");
                     }
                     if ( i < matvar->dims[0] )
                         printf(".\n.\n.\n");
                 }
                 break;
             }
             case MAT_C_CHAR:
             {
                 switch ( matvar->data_type ) {
                     case MAT_T_UINT16:
                     case MAT_T_UTF16:
                     {
                         const mat_uint16_t *data = (const mat_uint16_t*)matvar->data;
                         for ( i = 0; i < matvar->dims[0]; i++ ) {
                             for ( j = 0; j < matvar->dims[1]; j++ ) {
                                 const mat_uint16_t c = data[j*matvar->dims[0]+i];
 #if defined VARPRINT_UTF16
                                 printf("%c%c", c & 0xFF, (c>>8) & 0xFF);
 #elif defined VARPRINT_UTF16_DECIMAL
                                 Mat_PrintNumber(MAT_T_UINT16, &c);
                                 printf(" ");
 #else
                                 /* Convert to UTF-8 */
                                 if (c <= 0x7F) {
                                     printf("%c", c);
                                 }
                                 else if (c <= 0x7FF) {
                                     printf("%c%c", 0xC0 | (c>>6), 0x80 | (c & 0x3F));
                                 }
                                 else /* if (c <= 0xFFFF) */ {
                                     printf("%c%c%c", 0xE0 | (c>>12), 0x80 | ((c>>6) & 0x3F), 0x80 | (c & 0x3F));
                                 }
 #endif
                             }
                             printf("\n");
                         }
                         break;
                     }
                     default:
                     {
                         const char *data = (const char*)matvar->data;
                         for ( i = 0; i < matvar->dims[0]; i++ ) {
                             for ( j = 0; j < matvar->dims[1]; j++ )
                                 printf("%c",data[j*matvar->dims[0]+i]);
                             printf("\n");
                         }
                         break;
                     }
                 }
                 break;
             }
             case MAT_C_SPARSE:
             {
                 mat_sparse_t *sparse;
                 size_t stride = Mat_SizeOf(matvar->data_type);
 #if !defined(EXTENDED_SPARSE)
                 if ( MAT_T_DOUBLE != matvar->data_type )
                     break;
 #endif
                 sparse = (mat_sparse_t*)matvar->data;
                 if ( matvar->isComplex ) {
                     mat_complex_split_t *complex_data = (mat_complex_split_t*)sparse->data;
                     char *re = (char*)complex_data->Re;
                     char *im = (char*)complex_data->Im;
                     for ( i = 0; i < (size_t)sparse->njc-1; i++ ) {
                         for ( j = sparse->jc[i];
                               j < (size_t)sparse->jc[i+1] && j < (size_t)sparse->ndata; j++ ) {
                             printf("    (%d,%" SIZE_T_FMTSTR ")  ",sparse->ir[j]+1,i+1);
                             Mat_PrintNumber(matvar->data_type,re+j*stride);
                             printf(" + ");
                             Mat_PrintNumber(matvar->data_type,im+j*stride);
                             printf("i\n");
                         }
                     }
                 } else {
                     char *data = (char*)sparse->data;
                     for ( i = 0; i < (size_t)sparse->njc-1; i++ ) {
                         for ( j = sparse->jc[i];
                               j < (size_t)sparse->jc[i+1] && j < (size_t)sparse->ndata; j++ ) {
                             printf("    (%d,%" SIZE_T_FMTSTR ")  ",sparse->ir[j]+1,i+1);
                             Mat_PrintNumber(matvar->data_type,data+j*stride);
                             printf("\n");
                         }
                     }
                 }
                 break;
             } /* case MAT_C_SPARSE: */
             default:
                 break;
         } /* switch( matvar->class_type ) */
     }
 
     printf("}\n");
 
     return;
 }
 
 /** @brief Reads MAT variable data from a file
  *
  * Reads data from a MAT variable.  The variable must have been read by
  * Mat_VarReadInfo.
  * @ingroup MAT
  * @param mat MAT file to read data from
  * @param matvar MAT variable information
  * @param data pointer to store data in (must be pre-allocated)
  * @param start array of starting indices
  * @param stride stride of data
  * @param edge array specifying the number to read in each direction
  * @retval 0 on success
  */
diff --git a/src/mat4.c b/src/mat4.c
index 6172eb2..fee2d80 100644
--- a/src/mat4.c
+++ b/src/mat4.c
@@ -110,187 +110,187 @@ int
 Mat_VarWrite4(mat_t *mat,matvar_t *matvar)
 {
     typedef struct {
         mat_int32_t type;
         mat_int32_t mrows;
         mat_int32_t ncols;
         mat_int32_t imagf;
         mat_int32_t namelen;
     } Fmatrix;
 
     mat_uint32_t i;
     Fmatrix x;
 
     if ( NULL == mat || NULL == matvar || NULL == matvar->name || matvar->rank != 2 )
         return -1;
 
     switch ( matvar->data_type ) {
         case MAT_T_DOUBLE:
             x.type = 0;
             break;
         case MAT_T_SINGLE:
             x.type = 10;
             break;
         case MAT_T_INT32:
             x.type = 20;
             break;
         case MAT_T_INT16:
             x.type = 30;
             break;
         case MAT_T_UINT16:
             x.type = 40;
             break;
         case MAT_T_UINT8:
             x.type = 50;
             break;
         default:
             return 2;
     }
 
 #if defined(__GLIBC__)
 #if (__BYTE_ORDER == __LITTLE_ENDIAN)
 #elif (__BYTE_ORDER == __BIG_ENDIAN)
     x.type += 1000;
 #else
     return -1;
 #endif
 #elif defined(_BIG_ENDIAN) && !defined(_LITTLE_ENDIAN)
     x.type += 1000;
 #elif defined(_LITTLE_ENDIAN) && !defined(_BIG_ENDIAN)
 #elif defined(__sparc) || defined(__sparc__) || defined(_POWER) || defined(__powerpc__) || \
       defined(__ppc__) || defined(__hpux) || defined(_MIPSEB) || defined(_POWER) || defined(__s390__)
     x.type += 1000;
 #elif defined(__i386__) || defined(__alpha__) || defined(__ia64) || defined(__ia64__) || \
       defined(_M_IX86) || defined(_M_IA64) || defined(_M_ALPHA) || defined(__amd64) || \
       defined(__amd64__) || defined(_M_AMD64) || defined(__x86_64) || defined(__x86_64__) || \
       defined(_M_X64) || defined(__bfin__)
 #else
     return -1;
 #endif
 
     x.namelen = (mat_int32_t)strlen(matvar->name) + 1;
 
     /* FIXME: SEEK_END is not Guaranteed by the C standard */
     (void)fseek((FILE*)mat->fp,0,SEEK_END);         /* Always write at end of file */
 
     switch ( matvar->class_type ) {
         case MAT_C_CHAR:
             x.type++;
             /* Fall through */
         case MAT_C_DOUBLE:
         case MAT_C_SINGLE:
         case MAT_C_INT32:
         case MAT_C_INT16:
         case MAT_C_UINT16:
         case MAT_C_UINT8:
         {
             size_t nelems = 1;
-            int err = SafeMulDims(matvar, &nelems);
+            int err = MulDims(matvar, &nelems);
             if ( err ) {
                 Mat_Critical("Integer multiplication overflow");
                 return -1;
             }
 
             x.mrows = (mat_int32_t)matvar->dims[0];
             x.ncols = (mat_int32_t)matvar->dims[1];
             x.imagf = matvar->isComplex ? 1 : 0;
             fwrite(&x, sizeof(Fmatrix), 1, (FILE*)mat->fp);
             fwrite(matvar->name, sizeof(char), x.namelen, (FILE*)mat->fp);
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data;
 
                 complex_data = (mat_complex_split_t*)matvar->data;
                 fwrite(complex_data->Re, matvar->data_size, nelems, (FILE*)mat->fp);
                 fwrite(complex_data->Im, matvar->data_size, nelems, (FILE*)mat->fp);
             }
             else {
                 fwrite(matvar->data, matvar->data_size, nelems, (FILE*)mat->fp);
             }
             break;
         }
         case MAT_C_SPARSE:
         {
             mat_sparse_t* sparse;
             double tmp;
             mat_uint32_t j;
             size_t stride = Mat_SizeOf(matvar->data_type);
 #if !defined(EXTENDED_SPARSE)
             if ( MAT_T_DOUBLE != matvar->data_type )
                 break;
 #endif
 
             sparse = (mat_sparse_t*)matvar->data;
             x.type += 2;
             x.mrows = sparse->njc > 0 ? sparse->jc[sparse->njc - 1] + 1 : 1;
             x.ncols = matvar->isComplex ? 4 : 3;
             x.imagf = 0;
 
             fwrite(&x, sizeof(Fmatrix), 1, (FILE*)mat->fp);
             fwrite(matvar->name, sizeof(char), x.namelen, (FILE*)mat->fp);
 
             for ( i = 0; i < sparse->njc - 1; i++ ) {
                 for ( j = sparse->jc[i];
                       j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {
                     tmp = sparse->ir[j] + 1;
                     fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);
                 }
             }
             tmp = (double)matvar->dims[0];
             fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);
             for ( i = 0; i < sparse->njc - 1; i++ ) {
                 for ( j = sparse->jc[i];
                       j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {
                     tmp = i + 1;
                     fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);
                 }
             }
             tmp = (double)matvar->dims[1];
             fwrite(&tmp, sizeof(double), 1, (FILE*)mat->fp);
             tmp = 0.;
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data;
                 char* re, *im;
 
                 complex_data = (mat_complex_split_t*)sparse->data;
                 re = (char*)complex_data->Re;
                 im = (char*)complex_data->Im;
                 for ( i = 0; i < sparse->njc - 1; i++ ) {
                     for ( j = sparse->jc[i];
                           j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {
                         fwrite(re + j*stride, stride, 1, (FILE*)mat->fp);
                     }
                 }
                 fwrite(&tmp, stride, 1, (FILE*)mat->fp);
                 for ( i = 0; i < sparse->njc - 1; i++ ) {
                     for ( j = sparse->jc[i];
                           j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {
                         fwrite(im + j*stride, stride, 1, (FILE*)mat->fp);
                     }
                 }
             } else {
                 char *data = (char*)sparse->data;
                 for ( i = 0; i < sparse->njc - 1; i++ ) {
                     for ( j = sparse->jc[i];
                           j < sparse->jc[i + 1] && j < sparse->ndata; j++ ) {
                         fwrite(data + j*stride, stride, 1, (FILE*)mat->fp);
                     }
                 }
             }
             fwrite(&tmp, stride, 1, (FILE*)mat->fp);
             break;
         }
         default:
             break;
     }
 
     return 0;
 }
 
 /** @if mat_devman
  * @brief Reads the data of a version 4 MAT file variable
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar MAT variable pointer to read the data
  * @retval 0 on success
  * @endif
  */
@@ -298,481 +298,481 @@ int
 Mat_VarRead4(mat_t *mat,matvar_t *matvar)
 {
     int err;
     size_t nelems = 1;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return err;
     }
 
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
 
     switch ( matvar->class_type ) {
         case MAT_C_DOUBLE:
             matvar->data_size = sizeof(double);
-            err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+            err = Mul(&matvar->nbytes, nelems, matvar->data_size);
             if ( err ) {
                 Mat_Critical("Integer multiplication overflow");
                 return err;
             }
 
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL != complex_data ) {
                     size_t readcount;
                     readcount = ReadDoubleData(mat, (double*)complex_data->Re, matvar->data_type, nelems);
                     err = readcount != nelems;
                     readcount = ReadDoubleData(mat, (double*)complex_data->Im, matvar->data_type, nelems);
                     err |= readcount != nelems;
                     if ( 0 == err ) {
                        matvar->data = complex_data;
                     } else {
                         ComplexFree(complex_data);
                         return err;
                     }
                 }
                 else {
                     Mat_Critical("Couldn't allocate memory for the complex data");
                     return 1;
                 }
             } else {
                 matvar->data = malloc(matvar->nbytes);
                 if ( NULL != matvar->data ) {
                     const size_t readcount = ReadDoubleData(mat, (double*)matvar->data, matvar->data_type, nelems);
                     if ( readcount != nelems ) {
                         free(matvar->data);
                         matvar->data = NULL;
                         return 1;
                     }
                 }
                 else {
                     Mat_Critical("Couldn't allocate memory for the data");
                     return 1;
                 }
             }
             /* Update data type to match format of matvar->data */
             matvar->data_type = MAT_T_DOUBLE;
             break;
         case MAT_C_CHAR:
             matvar->data_size = 1;
             matvar->nbytes = nelems;
             matvar->data = malloc(matvar->nbytes);
             if ( NULL != matvar->data ) {
                 const size_t readcount = ReadUInt8Data(mat, (mat_uint8_t*)matvar->data, matvar->data_type, nelems);
                 if ( readcount != nelems ) {
                     free(matvar->data);
                     matvar->data = NULL;
                     return 1;
                 }
             }
             else {
                 Mat_Critical("Couldn't allocate memory for the data");
                 return 1;
             }
             matvar->data_type = MAT_T_UINT8;
             break;
         case MAT_C_SPARSE:
             matvar->data_size = sizeof(mat_sparse_t);
             matvar->data      = calloc(1, matvar->data_size);
             if ( NULL != matvar->data ) {
                 double tmp;
                 mat_uint32_t i;
                 mat_sparse_t* sparse;
                 long fpos;
                 enum matio_types data_type = MAT_T_DOUBLE;
                 size_t readcount;
 
                 /* matvar->dims[1] either is 3 for real or 4 for complex sparse */
                 matvar->isComplex = matvar->dims[1] == 4 ? 1 : 0;
                 if ( matvar->dims[0] < 2 ) {
                     return 1;
                 }
                 sparse = (mat_sparse_t*)matvar->data;
                 sparse->nir = matvar->dims[0] - 1;
                 sparse->nzmax = sparse->nir;
-                err = SafeMul(&readcount, sparse->nir, sizeof(mat_uint32_t));
+                err = Mul(&readcount, sparse->nir, sizeof(mat_uint32_t));
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     return err;
                 }
                 sparse->ir = (mat_uint32_t*)malloc(readcount);
                 if ( sparse->ir != NULL ) {
                     readcount = ReadUInt32Data(mat, sparse->ir, data_type, sparse->nir);
                     if ( readcount != sparse->nir ) {
                         free(sparse->ir);
                         free(matvar->data);
                         matvar->data = NULL;
                         return 1;
                     }
                     for ( i = 0; i < sparse->nir; i++ ) {
                         if ( 0 == sparse->ir[i] ) {
                             err = 1;
                             break;
                         }
                         sparse->ir[i] = sparse->ir[i] - 1;
                     }
                     if ( err ) {
                         free(sparse->ir);
                         free(matvar->data);
                         matvar->data = NULL;
                         return err;
                     }
                 } else {
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Couldn't allocate memory for the sparse row array");
                     return 1;
                 }
                 readcount = ReadDoubleData(mat, &tmp, data_type, 1);
                 if ( readcount != 1 || tmp > UINT_MAX - 1 || tmp < 0 ) {
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Invalid row dimension for sparse matrix");
                     return 1;
                 }
                 matvar->dims[0] = (size_t)tmp;
 
                 fpos = ftell((FILE*)mat->fp);
                 if ( fpos == -1L ) {
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Couldn't determine file position");
                     return 1;
                 }
                 (void)fseek((FILE*)mat->fp,sparse->nir*Mat_SizeOf(data_type),SEEK_CUR);
                 readcount = ReadDoubleData(mat, &tmp, data_type, 1);
                 if ( readcount != 1 || tmp > UINT_MAX - 1 || tmp < 0 ) {
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Invalid column dimension for sparse matrix");
                     return 1;
                 }
                 matvar->dims[1] = (size_t)tmp;
                 (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);
                 if ( matvar->dims[1] > UINT_MAX - 1 ) {
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Invalid column dimension for sparse matrix");
                     return 1;
                 }
                 sparse->njc = (mat_uint32_t)matvar->dims[1] + 1;
-                err = SafeMul(&readcount, sparse->njc, sizeof(mat_uint32_t));
+                err = Mul(&readcount, sparse->njc, sizeof(mat_uint32_t));
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     return err;
                 }
                 sparse->jc = (mat_uint32_t*)malloc(readcount);
                 if ( sparse->jc != NULL ) {
                     mat_uint32_t *jc;
-                    err = SafeMul(&readcount, sparse->nir, sizeof(mat_uint32_t));
+                    err = Mul(&readcount, sparse->nir, sizeof(mat_uint32_t));
                     if ( err ) {
                         Mat_Critical("Integer multiplication overflow");
                         return err;
                     }
                     jc = (mat_uint32_t*)malloc(readcount);
                     if ( jc != NULL ) {
                         mat_uint32_t j = 0;
                         sparse->jc[0] = 0;
                         readcount = ReadUInt32Data(mat, jc, data_type, sparse->nir);
                         if ( readcount != sparse->nir ) {
                             free(jc);
                             free(sparse->jc);
                             free(sparse->ir);
                             free(matvar->data);
                             matvar->data = NULL;
                             return 1;
                         }
                         for ( i = 1; i < sparse->njc - 1; i++ ) {
                             while ( j < sparse->nir && jc[j] <= i )
                                 j++;
                             sparse->jc[i] = j;
                         }
                         free(jc);
                         /* terminating nnz */
                         sparse->jc[sparse->njc - 1] = sparse->nir;
                     } else {
                         free(sparse->jc);
                         free(sparse->ir);
                         free(matvar->data);
                         matvar->data = NULL;
                         Mat_Critical("Couldn't allocate memory for the sparse index array");
                         return 1;
                     }
                 } else {
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     Mat_Critical("Couldn't allocate memory for the sparse index array");
                     return 1;
                 }
                 readcount = ReadDoubleData(mat, &tmp, data_type, 1);
                 if ( readcount != 1 ) {
                     free(sparse->jc);
                     free(sparse->ir);
                     free(matvar->data);
                     matvar->data = NULL;
                     return 1;
                 }
                 sparse->ndata = sparse->nir;
                 data_type = matvar->data_type;
                 if ( matvar->isComplex ) {
                     mat_complex_split_t *complex_data =
                         ComplexMalloc(sparse->ndata*Mat_SizeOf(data_type));
                     if ( NULL != complex_data ) {
                         sparse->data = complex_data;
 #if defined(EXTENDED_SPARSE)
                         switch ( data_type ) {
                             case MAT_T_DOUBLE:
                                 readcount = ReadDoubleData(mat, (double*)complex_data->Re,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadDoubleData(mat, &tmp, data_type, 1);
                                 err |= readcount != 1;
                                 readcount = ReadDoubleData(mat, (double*)complex_data->Im,
                                     data_type, sparse->ndata);
                                 err |= readcount != sparse->ndata;
                                 readcount = ReadDoubleData(mat, &tmp, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             case MAT_T_SINGLE:
                             {
                                 float tmp2;
                                 readcount = ReadSingleData(mat, (float*)complex_data->Re,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadSingleData(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 readcount = ReadSingleData(mat, (float*)complex_data->Im,
                                     data_type, sparse->ndata);
                                 err |= readcount != sparse->ndata;
                                 readcount = ReadSingleData(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_INT32:
                             {
                                 mat_int32_t tmp2;
                                 readcount = ReadInt32Data(mat, (mat_int32_t*)complex_data->Re,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadInt32Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 readcount = ReadInt32Data(mat, (mat_int32_t*)complex_data->Im,
                                     data_type, sparse->ndata);
                                 err |= readcount != sparse->ndata;
                                 readcount = ReadInt32Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_INT16:
                             {
                                 mat_int16_t tmp2;
                                 readcount = ReadInt16Data(mat, (mat_int16_t*)complex_data->Re,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadInt16Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 readcount = ReadInt16Data(mat, (mat_int16_t*)complex_data->Im,
                                     data_type, sparse->ndata);
                                 err |= readcount != sparse->ndata;
                                 readcount = ReadInt16Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_UINT16:
                             {
                                 mat_uint16_t tmp2;
                                 readcount = ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Re,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadUInt16Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 readcount = ReadUInt16Data(mat, (mat_uint16_t*)complex_data->Im,
                                     data_type, sparse->ndata);
                                 err |= readcount != sparse->ndata;
                                 readcount = ReadUInt16Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_UINT8:
                             {
                                 mat_uint8_t tmp2;
                                 readcount = ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Re,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadUInt8Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 readcount = ReadUInt8Data(mat, (mat_uint8_t*)complex_data->Im,
                                     data_type, sparse->ndata);
                                 err |= readcount != sparse->ndata;
                                 readcount = ReadUInt8Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             default:
                                 ComplexFree(complex_data);
                                 free(sparse->jc);
                                 free(sparse->ir);
                                 free(matvar->data);
                                 matvar->data = NULL;
                                 Mat_Critical("Mat_VarRead4: %d is not a supported data type for "
                                     "extended sparse", data_type);
                                 return 1;
                         }
 #else
                         readcount = ReadDoubleData(mat, (double*)complex_data->Re,
                             data_type, sparse->ndata);
                         err = readcount != sparse->ndata;
                         readcount = ReadDoubleData(mat, &tmp, data_type, 1);
                         err |= readcount != 1;
                         readcount = ReadDoubleData(mat, (double*)complex_data->Im,
                             data_type, sparse->ndata);
                         err |= readcount != sparse->ndata;
                         readcount = ReadDoubleData(mat, &tmp, data_type, 1);
                         err |= readcount != 1;
 #endif
                         if ( err ) {
                             ComplexFree(complex_data);
                             free(sparse->jc);
                             free(sparse->ir);
                             free(matvar->data);
                             matvar->data = NULL;
                             return err;
                         }
                     }
                     else {
                         free(sparse->jc);
                         free(sparse->ir);
                         free(matvar->data);
                         matvar->data = NULL;
                         Mat_Critical("Couldn't allocate memory for the complex sparse data");
                         return 1;
                     }
                 } else {
                     sparse->data = malloc(sparse->ndata*Mat_SizeOf(data_type));
                     if ( sparse->data != NULL ) {
 #if defined(EXTENDED_SPARSE)
                         switch ( data_type ) {
                             case MAT_T_DOUBLE:
                                 readcount = ReadDoubleData(mat, (double*)sparse->data,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadDoubleData(mat, &tmp, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             case MAT_T_SINGLE:
                             {
                                 float tmp2;
                                 readcount = ReadSingleData(mat, (float*)sparse->data,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadSingleData(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_INT32:
                             {
                                 mat_int32_t tmp2;
                                 readcount = ReadInt32Data(mat, (mat_int32_t*)sparse->data,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadInt32Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_INT16:
                             {
                                 mat_int16_t tmp2;
                                 readcount = ReadInt16Data(mat, (mat_int16_t*)sparse->data,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadInt16Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_UINT16:
                             {
                                 mat_uint16_t tmp2;
                                 readcount = ReadUInt16Data(mat, (mat_uint16_t*)sparse->data,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadUInt16Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             case MAT_T_UINT8:
                             {
                                 mat_uint8_t tmp2;
                                 readcount = ReadUInt8Data(mat, (mat_uint8_t*)sparse->data,
                                     data_type, sparse->ndata);
                                 err = readcount != sparse->ndata;
                                 readcount = ReadUInt8Data(mat, &tmp2, data_type, 1);
                                 err |= readcount != 1;
                                 break;
                             }
                             default:
                                 free(sparse->data);
                                 free(sparse->jc);
                                 free(sparse->ir);
                                 free(matvar->data);
                                 matvar->data = NULL;
                                 Mat_Critical("Mat_VarRead4: %d is not a supported data type for "
                                     "extended sparse", data_type);
                                 return 1;
                         }
 #else
                         readcount = ReadDoubleData(mat, (double*)sparse->data, data_type, sparse->ndata);
                         err = readcount != sparse->ndata;
                         readcount = ReadDoubleData(mat, &tmp, data_type, 1);
                         err |= readcount != 1;
 #endif
                         if ( err ) {
                             free(sparse->data);
                             free(sparse->jc);
                             free(sparse->ir);
                             free(matvar->data);
                             matvar->data = NULL;
                             return err;
                         }
                     } else {
                         free(sparse->jc);
                         free(sparse->ir);
                         free(matvar->data);
                         matvar->data = NULL;
                         Mat_Critical("Couldn't allocate memory for the sparse data");
                         return 1;
                     }
                 }
                 break;
             }
             else {
                 Mat_Critical("Couldn't allocate memory for the data");
                 return 1;
             }
         default:
             Mat_Critical("MAT V4 data type error");
             return 1;
     }
 
     return err;
 }
 
 /** @if mat_devman
  * @brief Reads a slab of data from a version 4 MAT file for the @c matvar variable
  *
  * @ingroup mat_internal
  * @param mat Version 4 MAT file pointer
  * @param matvar pointer to the mat variable
  * @param data pointer to store the read data in (must be of size
  *             edge[0]*...edge[rank-1]*Mat_SizeOfClass(matvar->class_type))
  * @param start index to start reading data in each dimension
  * @param stride write data every @c stride elements in each dimension
  * @param edge number of elements to read in each dimension
  * @retval 0 on success
  * @endif
  */
@@ -780,77 +780,77 @@ int
 Mat_VarReadData4(mat_t *mat,matvar_t *matvar,void *data,
       int *start,int *stride,int *edge)
 {
     int err = 0;
 
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
 
     switch( matvar->data_type ) {
         case MAT_T_DOUBLE:
         case MAT_T_SINGLE:
         case MAT_T_INT32:
         case MAT_T_INT16:
         case MAT_T_UINT16:
         case MAT_T_UINT8:
             break;
         default:
             return 1;
     }
 
     if ( matvar->rank == 2 ) {
         if ( (size_t)stride[0]*(edge[0]-1)+start[0]+1 > matvar->dims[0] )
             err = 1;
         else if ( (size_t)stride[1]*(edge[1]-1)+start[1]+1 > matvar->dims[1] )
             err = 1;
         if ( matvar->isComplex ) {
             mat_complex_split_t *cdata = (mat_complex_split_t*)data;
             size_t nbytes = Mat_SizeOf(matvar->data_type);
-            err = SafeMulDims(matvar, &nbytes);
+            err = MulDims(matvar, &nbytes);
             if ( err ) {
                 Mat_Critical("Integer multiplication overflow");
                 return err;
             }
 
             ReadDataSlab2(mat,cdata->Re,matvar->class_type,matvar->data_type,
                 matvar->dims,start,stride,edge);
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nbytes,SEEK_SET);
             ReadDataSlab2(mat,cdata->Im,matvar->class_type,
                 matvar->data_type,matvar->dims,start,stride,edge);
         } else {
             ReadDataSlab2(mat,data,matvar->class_type,matvar->data_type,
                 matvar->dims,start,stride,edge);
         }
     } else if ( matvar->isComplex ) {
         mat_complex_split_t *cdata = (mat_complex_split_t*)data;
         size_t nbytes = Mat_SizeOf(matvar->data_type);
-        err = SafeMulDims(matvar, &nbytes);
+        err = MulDims(matvar, &nbytes);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return err;
         }
 
         ReadDataSlabN(mat,cdata->Re,matvar->class_type,matvar->data_type,
             matvar->rank,matvar->dims,start,stride,edge);
         (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nbytes,SEEK_SET);
         ReadDataSlabN(mat,cdata->Im,matvar->class_type,matvar->data_type,
             matvar->rank,matvar->dims,start,stride,edge);
     } else {
         ReadDataSlabN(mat,data,matvar->class_type,matvar->data_type,
             matvar->rank,matvar->dims,start,stride,edge);
     }
 
     return err;
 }
 
 /** @brief Reads a subset of a MAT variable using a 1-D indexing
  *
  * Reads data from a MAT variable using a linear (1-D) indexing mode. The
  * variable must have been read by Mat_VarReadInfo.
  * @ingroup MAT
  * @param mat MAT file to read data from
  * @param matvar MAT variable information
  * @param data pointer to store data in (must be pre-allocated)
  * @param start starting index
  * @param stride stride of data
  * @param edge number of elements to read
  * @retval 0 on success
  */
@@ -858,48 +858,48 @@ int
 Mat_VarReadDataLinear4(mat_t *mat,matvar_t *matvar,void *data,int start,
                        int stride,int edge)
 {
     int err;
     size_t nelems = 1;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return err;
     }
 
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
 
     matvar->data_size = Mat_SizeOf(matvar->data_type);
 
     if ( (size_t)stride*(edge-1)+start+1 > nelems ) {
         return 1;
     }
     if ( matvar->isComplex ) {
         mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
-        err = SafeMul(&nelems, nelems, matvar->data_size);
+        err = Mul(&nelems, nelems, matvar->data_size);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return err;
         }
 
         ReadDataSlab1(mat,complex_data->Re,matvar->class_type,
                       matvar->data_type,start,stride,edge);
         (void)fseek((FILE*)mat->fp,matvar->internal->datapos+nelems,SEEK_SET);
         ReadDataSlab1(mat,complex_data->Im,matvar->class_type,
                       matvar->data_type,start,stride,edge);
     } else {
         ReadDataSlab1(mat,data,matvar->class_type,matvar->data_type,start,
                       stride,edge);
     }
 
     return err;
 }
 
 /** @if mat_devman
  * @brief Reads the header information for the next MAT variable in a version 4 MAT file
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @return pointer to the MAT variable or NULL
  * @endif
  */
@@ -907,182 +907,176 @@ matvar_t *
 Mat_VarReadNextInfo4(mat_t *mat)
 {
     int       M,O,data_type,class_type;
     mat_int32_t tmp;
     long      nBytes;
-    size_t    readresult;
     matvar_t *matvar = NULL;
     union {
         mat_uint32_t u;
         mat_uint8_t  c[4];
     } endian;
 
     if ( mat == NULL || mat->fp == NULL )
         return NULL;
     else if ( NULL == (matvar = Mat_VarCalloc()) )
         return NULL;
 
-    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);
-    if ( 1 != readresult ) {
+    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL) ) {
         Mat_VarFree(matvar);
         return NULL;
     }
 
     endian.u = 0x01020304;
 
     /* See if MOPT may need byteswapping */
     if ( tmp < 0 || tmp > 4052 ) {
         if ( Mat_int32Swap(&tmp) > 4052 ) {
             Mat_VarFree(matvar);
             return NULL;
         }
     }
 
     M = (int)floor(tmp / 1000.0);
     switch ( M ) {
         case 0:
             /* IEEE little endian */
             mat->byteswap = endian.c[0] != 4;
             break;
         case 1:
             /* IEEE big endian */
             mat->byteswap = endian.c[0] != 1;
             break;
         default:
             /* VAX, Cray, or bogus */
             Mat_VarFree(matvar);
             return NULL;
     }
 
     tmp -= M*1000;
     O = (int)floor(tmp / 100.0);
     /* O must be zero */
     if ( 0 != O ) {
         Mat_VarFree(matvar);
         return NULL;
     }
 
     tmp -= O*100;
     data_type = (int)floor(tmp / 10.0);
     /* Convert the V4 data type */
     switch ( data_type ) {
         case 0:
             matvar->data_type = MAT_T_DOUBLE;
             break;
         case 1:
             matvar->data_type = MAT_T_SINGLE;
             break;
         case 2:
             matvar->data_type = MAT_T_INT32;
             break;
         case 3:
             matvar->data_type = MAT_T_INT16;
             break;
         case 4:
             matvar->data_type = MAT_T_UINT16;
             break;
         case 5:
             matvar->data_type = MAT_T_UINT8;
             break;
         default:
             Mat_VarFree(matvar);
             return NULL;
     }
 
     tmp -= data_type*10;
     class_type = (int)floor(tmp / 1.0);
     switch ( class_type ) {
         case 0:
             matvar->class_type = MAT_C_DOUBLE;
             break;
         case 1:
             matvar->class_type = MAT_C_CHAR;
             break;
         case 2:
             matvar->class_type = MAT_C_SPARSE;
             break;
         default:
             Mat_VarFree(matvar);
             return NULL;
     }
 
     matvar->rank = 2;
     matvar->dims = (size_t*)calloc(2, sizeof(*matvar->dims));
     if ( NULL == matvar->dims ) {
         Mat_VarFree(matvar);
         return NULL;
     }
-    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);
+    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL) ) {
+        Mat_VarFree(matvar);
+        return NULL;
+    }
     if ( mat->byteswap )
         Mat_int32Swap(&tmp);
     matvar->dims[0] = tmp;
-    if ( 1 != readresult ) {
+
+    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL) ) {
         Mat_VarFree(matvar);
         return NULL;
     }
-    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);
     if ( mat->byteswap )
         Mat_int32Swap(&tmp);
     matvar->dims[1] = tmp;
-    if ( 1 != readresult ) {
-        Mat_VarFree(matvar);
-        return NULL;
-    }
 
-    readresult = fread(&(matvar->isComplex),sizeof(int),1,(FILE*)mat->fp);
-    if ( 1 != readresult ) {
+    if ( 0 != Read(&(matvar->isComplex), sizeof(int), 1, (FILE*)mat->fp, NULL) ) {
         Mat_VarFree(matvar);
         return NULL;
     }
     if ( matvar->isComplex && MAT_C_CHAR == matvar->class_type ) {
         Mat_VarFree(matvar);
         return NULL;
     }
-    readresult = fread(&tmp,sizeof(int),1,(FILE*)mat->fp);
-    if ( 1 != readresult ) {
+    if ( 0 != Read(&tmp, sizeof(int), 1, (FILE*)mat->fp, NULL) ) {
         Mat_VarFree(matvar);
         return NULL;
     }
     if ( mat->byteswap )
         Mat_int32Swap(&tmp);
     /* Check that the length of the variable name is at least 1 */
     if ( tmp < 1 ) {
         Mat_VarFree(matvar);
         return NULL;
     }
     matvar->name = (char*)malloc(tmp);
     if ( NULL == matvar->name ) {
         Mat_VarFree(matvar);
         return NULL;
     }
-    readresult = fread(matvar->name,1,tmp,(FILE*)mat->fp);
-    if ( tmp != readresult ) {
+    if ( 0 != Read(matvar->name, sizeof(char), tmp, (FILE*)mat->fp, NULL) ) {
         Mat_VarFree(matvar);
         return NULL;
     } else {
         matvar->name[tmp - 1] = '\0';
     }
 
     matvar->internal->datapos = ftell((FILE*)mat->fp);
     if ( matvar->internal->datapos == -1L ) {
         Mat_VarFree(matvar);
         Mat_Critical("Couldn't determine file position");
         return NULL;
     }
     {
         int err;
         size_t tmp2 = Mat_SizeOf(matvar->data_type);
         if ( matvar->isComplex )
             tmp2 *= 2;
-        err = SafeMulDims(matvar, &tmp2);
+        err = MulDims(matvar, &tmp2);
         if ( err ) {
             Mat_VarFree(matvar);
             Mat_Critical("Integer multiplication overflow");
             return NULL;
         }
 
         nBytes = (long)tmp2;
     }
     (void)fseek((FILE*)mat->fp,nBytes,SEEK_CUR);
 
     return matvar;
 }
diff --git a/src/mat5.c b/src/mat5.c
index 0795794..536b80c 100644
--- a/src/mat5.c
+++ b/src/mat5.c
@@ -71,8 +71,8 @@ static size_t WriteCharData(mat_t *mat, void *data, int N,enum matio_types data_
 static size_t ReadNextCell( mat_t *mat, matvar_t *matvar );
 static size_t ReadNextStructField( mat_t *mat, matvar_t *matvar );
 static size_t ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar);
-static size_t ReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type,
-                  mat_uint32_t nbytes);
+static int    ReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type,
+                  mat_uint32_t nbytes, size_t *read_bytes);
 static int    WriteType(mat_t *mat,matvar_t *matvar);
 static int    WriteCellArrayField(mat_t *mat,matvar_t *matvar );
 static int    WriteStructField(mat_t *mat,matvar_t *matvar);
@@ -107,168 +107,168 @@ static int
 GetTypeBufSize(matvar_t *matvar, size_t *size)
 {
     int err;
     size_t nBytes, data_bytes;
     size_t tag_size = 8;
     size_t nelems = 1;
     size_t rank_size;
 
     *size = 0;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err )
         return 1;
 
     /* Add rank and dimensions, padded to an 8 byte block */
-    err = SafeMul(&rank_size, matvar->rank, 4);
+    err = Mul(&rank_size, matvar->rank, 4);
     if ( err )
         return 1;
 
     if ( matvar->rank % 2 )
         nBytes = tag_size + 4;
     else
         nBytes = tag_size;
 
-    err = SafeAdd(&nBytes, nBytes, rank_size);
+    err = Add(&nBytes, nBytes, rank_size);
     if ( err )
         return 1;
 
     switch ( matvar->class_type ) {
         case MAT_C_STRUCT:
         {
             matvar_t **fields = (matvar_t**)matvar->data;
             size_t nfields = matvar->internal->num_fields;
             size_t maxlen = 0, i, field_buf_size;
 
             for ( i = 0; i < nfields; i++ ) {
                 char *fieldname = matvar->internal->fieldnames[i];
                 if ( NULL != fieldname && strlen(fieldname) > maxlen )
                     maxlen = strlen(fieldname);
             }
             maxlen++;
             while ( nfields*maxlen % 8 != 0 )
                 maxlen++;
 
-            err = SafeMul(&field_buf_size, maxlen, nfields);
-            err |= SafeAdd(&nBytes, nBytes, tag_size + tag_size);
-            err |= SafeAdd(&nBytes, nBytes, field_buf_size);
+            err = Mul(&field_buf_size, maxlen, nfields);
+            err |= Add(&nBytes, nBytes, tag_size + tag_size);
+            err |= Add(&nBytes, nBytes, field_buf_size);
             if ( err )
                 return 1;
 
             /* FIXME: Add bytes for the fieldnames */
             if ( NULL != fields && nfields > 0 ) {
                 size_t nelems_x_nfields = 1;
-                err = SafeMul(&nelems_x_nfields, nelems, nfields);
+                err = Mul(&nelems_x_nfields, nelems, nfields);
                 if ( err )
                     return 1;
 
                 for ( i = 0; i < nelems_x_nfields; i++ ) {
                     err = GetStructFieldBufSize(fields[i], &field_buf_size);
-                    err |= SafeAdd(&nBytes, nBytes, tag_size);
-                    err |= SafeAdd(&nBytes, nBytes, field_buf_size);
+                    err |= Add(&nBytes, nBytes, tag_size);
+                    err |= Add(&nBytes, nBytes, field_buf_size);
                     if ( err )
                         return 1;
                 }
             }
             break;
         }
         case MAT_C_CELL:
         {
             matvar_t **cells = (matvar_t**)matvar->data;
 
             if ( matvar->nbytes == 0 || matvar->data_size == 0 )
                 break;
 
             nelems = matvar->nbytes / matvar->data_size;
             if ( NULL != cells && nelems > 0 ) {
                 size_t i, field_buf_size;
                 for ( i = 0; i < nelems; i++ ) {
                     err = GetCellArrayFieldBufSize(cells[i], &field_buf_size);
-                    err |= SafeAdd(&nBytes, nBytes, tag_size);
-                    err |= SafeAdd(&nBytes, nBytes, field_buf_size);
+                    err |= Add(&nBytes, nBytes, tag_size);
+                    err |= Add(&nBytes, nBytes, field_buf_size);
                     if ( err )
                         return 1;
                 }
             }
             break;
         }
         case MAT_C_SPARSE:
         {
             mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;
 
-            err = SafeMul(&data_bytes, sparse->nir, sizeof(mat_uint32_t));
+            err = Mul(&data_bytes, sparse->nir, sizeof(mat_uint32_t));
             if ( data_bytes % 8 )
-                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);
-            err |= SafeAdd(&nBytes, nBytes, tag_size);
-            err |= SafeAdd(&nBytes, nBytes, data_bytes);
+                err |= Add(&data_bytes, data_bytes, 8 - data_bytes % 8);
+            err |= Add(&nBytes, nBytes, tag_size);
+            err |= Add(&nBytes, nBytes, data_bytes);
 
-            err |= SafeMul(&data_bytes, sparse->njc, sizeof(mat_uint32_t));
+            err |= Mul(&data_bytes, sparse->njc, sizeof(mat_uint32_t));
             if ( data_bytes % 8 )
-                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);
-            err |= SafeAdd(&nBytes, nBytes, tag_size);
-            err |= SafeAdd(&nBytes, nBytes, data_bytes);
+                err |= Add(&data_bytes, data_bytes, 8 - data_bytes % 8);
+            err |= Add(&nBytes, nBytes, tag_size);
+            err |= Add(&nBytes, nBytes, data_bytes);
 
-            err |= SafeMul(&data_bytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
+            err |= Mul(&data_bytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
             if ( data_bytes % 8 )
-                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);
-            err |= SafeAdd(&nBytes, nBytes, tag_size);
-            err |= SafeAdd(&nBytes, nBytes, data_bytes);
+                err |= Add(&data_bytes, data_bytes, 8 - data_bytes % 8);
+            err |= Add(&nBytes, nBytes, tag_size);
+            err |= Add(&nBytes, nBytes, data_bytes);
 
             if ( matvar->isComplex ) {
-                err |= SafeAdd(&nBytes, nBytes, tag_size);
-                err |= SafeAdd(&nBytes, nBytes, data_bytes);
+                err |= Add(&nBytes, nBytes, tag_size);
+                err |= Add(&nBytes, nBytes, data_bytes);
             }
 
             if ( err )
                 return 1;
 
             break;
         }
         case MAT_C_CHAR:
             if ( MAT_T_UINT8 == matvar->data_type ||
                  MAT_T_INT8 == matvar->data_type )
-                err = SafeMul(&data_bytes, nelems, Mat_SizeOf(MAT_T_UINT16));
+                err = Mul(&data_bytes, nelems, Mat_SizeOf(MAT_T_UINT16));
             else
-                err = SafeMul(&data_bytes, nelems, Mat_SizeOf(matvar->data_type));
+                err = Mul(&data_bytes, nelems, Mat_SizeOf(matvar->data_type));
             if ( data_bytes % 8 )
-                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);
+                err |= Add(&data_bytes, data_bytes, 8 - data_bytes % 8);
 
-            err |= SafeAdd(&nBytes, nBytes, tag_size);
-            err |= SafeAdd(&nBytes, nBytes, data_bytes);
+            err |= Add(&nBytes, nBytes, tag_size);
+            err |= Add(&nBytes, nBytes, data_bytes);
 
             if ( matvar->isComplex ) {
-                err |= SafeAdd(&nBytes, nBytes, tag_size);
-                err |= SafeAdd(&nBytes, nBytes, data_bytes);
+                err |= Add(&nBytes, nBytes, tag_size);
+                err |= Add(&nBytes, nBytes, data_bytes);
             }
 
             if ( err )
                 return 1;
 
             break;
         default:
-            err = SafeMul(&data_bytes, nelems, Mat_SizeOf(matvar->data_type));
+            err = Mul(&data_bytes, nelems, Mat_SizeOf(matvar->data_type));
             if ( data_bytes % 8 )
-                err |= SafeAdd(&data_bytes, data_bytes, 8 - data_bytes % 8);
+                err |= Add(&data_bytes, data_bytes, 8 - data_bytes % 8);
 
-            err |= SafeAdd(&nBytes, nBytes, tag_size);
-            err |= SafeAdd(&nBytes, nBytes, data_bytes);
+            err |= Add(&nBytes, nBytes, tag_size);
+            err |= Add(&nBytes, nBytes, data_bytes);
 
             if ( matvar->isComplex ) {
-                err |= SafeAdd(&nBytes, nBytes, tag_size);
-                err |= SafeAdd(&nBytes, nBytes, data_bytes);
+                err |= Add(&nBytes, nBytes, tag_size);
+                err |= Add(&nBytes, nBytes, data_bytes);
             }
 
             if ( err )
                 return 1;
     } /* switch ( matvar->class_type ) */
 
     *size = nBytes;
     return 0;
 }
 
 /** @brief determines the number of bytes needed to store the given struct field
  *
  * @ingroup mat_internal
  * @param matvar field of a structure
  * @param size the number of bytes needed to store the struct field
  * @return 0 on success
  */
@@ -276,33 +276,33 @@ static int
 GetStructFieldBufSize(matvar_t *matvar, size_t *size)
 {
     int err;
     size_t nBytes = 0, type_buf_size;
     size_t tag_size = 8, array_flags_size = 8;
 
     *size = 0;
 
     if ( matvar == NULL )
         return GetEmptyMatrixMaxBufSize(NULL, 2, size);
 
     /* Add the Array Flags tag and space to the number of bytes */
     nBytes += tag_size + array_flags_size;
 
     /* In a struct field, the name is just a tag with 0 bytes */
     nBytes += tag_size;
 
     err = GetTypeBufSize(matvar, &type_buf_size);
-    err |= SafeAdd(&nBytes, nBytes, type_buf_size);
+    err |= Add(&nBytes, nBytes, type_buf_size);
     if ( err )
         return 1;
 
     *size = nBytes;
     return 0;
 }
 
 /** @brief determines the number of bytes needed to store the cell array element
  *
  * @ingroup mat_internal
  * @param matvar MAT variable
  * @param size the number of bytes needed to store the variable
  * @return 0 on success
  */
@@ -310,34 +310,34 @@ static int
 GetCellArrayFieldBufSize(matvar_t *matvar, size_t *size)
 {
     int err;
     size_t nBytes = 0, type_buf_size;
     size_t tag_size = 8, array_flags_size = 8;
 
     *size = 0;
 
     if ( matvar == NULL )
         return 1;
 
     /* Add the Array Flags tag and space to the number of bytes */
     nBytes += tag_size + array_flags_size;
 
     /* In an element of a cell array, the name is just a tag with 0 bytes */
     nBytes += tag_size;
 
     err = GetTypeBufSize(matvar, &type_buf_size);
-    err |= SafeAdd(&nBytes, nBytes, type_buf_size);
+    err |= Add(&nBytes, nBytes, type_buf_size);
     if ( err )
         return 1;
 
     *size = nBytes;
     return 0;
 }
 
 /** @brief determines the number of bytes needed to store the given variable
  *
  * @ingroup mat_internal
  * @param matvar MAT variable
  * @param rank rank of the variable
  * @param size the number of bytes needed to store the variable
  * @return 0 on success
  */
@@ -345,42 +345,42 @@ static int
 GetEmptyMatrixMaxBufSize(const char *name, int rank, size_t *size)
 {
     int err = 0;
     size_t nBytes = 0, len, rank_size;
     size_t tag_size = 8, array_flags_size = 8;
 
     /* Add the Array Flags tag and space to the number of bytes */
     nBytes += tag_size + array_flags_size;
 
     /* Get size of variable name, pad it to an 8 byte block, and add it to nBytes */
     if ( NULL != name )
         len = strlen(name);
     else
         len = 4;
 
     if ( len <= 4 ) {
         nBytes += tag_size;
     } else {
         nBytes += tag_size;
         if ( len % 8 )
-            err |= SafeAdd(&len, len, 8 - len % 8);
+            err |= Add(&len, len, 8 - len % 8);
 
-        err |= SafeAdd(&nBytes, nBytes, len);
+        err |= Add(&nBytes, nBytes, len);
     }
 
     /* Add rank and dimensions, padded to an 8 byte block */
-    err |= SafeMul(&rank_size, rank, 4);
+    err |= Mul(&rank_size, rank, 4);
     if ( rank % 2 )
-        err |= SafeAdd(&nBytes, nBytes, tag_size + 4);
+        err |= Add(&nBytes, nBytes, tag_size + 4);
     else
-        err |= SafeAdd(&nBytes, nBytes, tag_size);
+        err |= Add(&nBytes, nBytes, tag_size);
 
-    err |= SafeAdd(&nBytes, nBytes, rank_size);
+    err |= Add(&nBytes, nBytes, rank_size);
     /* Data tag */
-    err |= SafeAdd(&nBytes, nBytes, tag_size);
+    err |= Add(&nBytes, nBytes, tag_size);
 
     if ( err )
         return 1;
 
     *size = nBytes;
     return 0;
 }
@@ -407,83 +407,89 @@ static size_t
 ReadSparse(mat_t *mat, matvar_t *matvar, mat_uint32_t *n, mat_uint32_t **v)
 {
     int data_in_tag = 0;
     enum matio_types packed_type;
     mat_uint32_t tag[2];
     size_t bytesread = 0;
     mat_uint32_t N = 0;
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
         matvar->internal->z->avail_in = 0;
-        InflateDataType(mat,matvar->internal->z,tag);
+        if ( 0 != Inflate(mat, matvar->internal->z, tag, 4, &bytesread) ) {
+            return bytesread;
+        }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             N = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
             (void)ReadCompressedUInt32Data(mat,matvar->internal->z,
                         &N,MAT_T_UINT32,1);
         }
 #endif
     } else {
-        bytesread += fread(tag,4,1,(FILE*)mat->fp);
+        if ( 0 != Read(tag, 4, 1, (FILE*)mat->fp, &bytesread) ) {
+            return bytesread;
+        }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             N = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
-            bytesread += fread(&N,4,1,(FILE*)mat->fp);
+            if ( 0 != Read(&N, 4, 1, (FILE*)mat->fp, &bytesread) ) {
+                return bytesread;
+            }
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(&N);
         }
     }
     *n = N / 4;
     *v = (mat_uint32_t*)malloc(N);
     if ( NULL != *v ) {
         int nBytes;
         if ( matvar->compression == MAT_COMPRESSION_NONE ) {
             nBytes = ReadUInt32Data(mat,*v,packed_type,*n);
             /*
                 * If the data was in the tag we started on a 4-byte
                 * boundary so add 4 to make it an 8-byte
                 */
             nBytes *= Mat_SizeOf(packed_type);
             if ( data_in_tag )
                 nBytes+=4;
             if ( (nBytes % 8) != 0 )
                 (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
         } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                             *v,packed_type,*n);
             /*
                 * If the data was in the tag we started on a 4-byte
                 * boundary so add 4 to make it an 8-byte
                 */
             if ( data_in_tag )
                 nBytes+=4;
             if ( (nBytes % 8) != 0 )
-                InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
+                InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif
         }
     } else {
         Mat_Critical("Couldn't allocate memory");
     }
 
     return bytesread;
 }
 
 #if HAVE_ZLIB
 /** @brief determines the number of bytes needed to store the given variable
  *
  * @ingroup mat_internal
  * @param matvar MAT variable
  * @param size the number of bytes needed to store the variable
  * @return 0 on success
  */
@@ -491,55 +497,55 @@ static int
 GetMatrixMaxBufSize(matvar_t *matvar, size_t *size)
 {
     int err = 0;
     size_t nBytes = 0, len, type_buf_size;
     size_t tag_size = 8, array_flags_size = 8;
 
     if ( matvar == NULL )
         return 1;
 
     /* Add the Array Flags tag and space to the number of bytes */
     nBytes += tag_size + array_flags_size;
 
     /* Get size of variable name, pad it to an 8 byte block, and add it to nBytes */
     if ( NULL != matvar->name )
         len = strlen(matvar->name);
     else
         len = 4;
 
     if ( len <= 4 ) {
         nBytes += tag_size;
     } else {
         nBytes += tag_size;
         if ( len % 8 )
-            err |= SafeAdd(&len, len, 8 - len % 8);
+            err |= Add(&len, len, 8 - len % 8);
 
-        err |= SafeAdd(&nBytes, nBytes, len);
+        err |= Add(&nBytes, nBytes, len);
     }
 
     err |= GetTypeBufSize(matvar, &type_buf_size);
-    err |= SafeAdd(&nBytes, nBytes, type_buf_size);
+    err |= Add(&nBytes, nBytes, type_buf_size);
 
     if ( err )
         return 1;
 
     *size = nBytes;
     return 0;
 }
 #endif
 
 /** @if mat_devman
  * @brief Creates a new Matlab MAT version 5 file
  *
  * Tries to create a new Matlab MAT file with the given name and optional
  * header string.  If no header string is given, the default string
  * is used containing the software, version, and date in it.  If a header
  * string is given, at most the first 116 characters is written to the file.
  * The given header string need not be the full 116 characters, but MUST be
  * NULL terminated.
  * @ingroup MAT
  * @param matname Name of MAT file to create
  * @param hdr_str Optional header string, NULL to use default
  * @return A pointer to the MAT file or NULL if it failed.  This is not a
  * simple FILE * and should not be used as one.
  * @endif
  */
@@ -891,352 +897,385 @@ static size_t
 ReadNextCell( mat_t *mat, matvar_t *matvar )
 {
     size_t bytesread = 0, i;
     int err;
     matvar_t **cells = NULL;
     size_t nelems = 1;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return bytesread;
     }
     matvar->data_size = sizeof(matvar_t *);
-    err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+    err = Mul(&matvar->nbytes, nelems, matvar->data_size);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return bytesread;
     }
 
     matvar->data = calloc(nelems, matvar->data_size);
     if ( NULL == matvar->data ) {
         if ( NULL != matvar->name )
             Mat_Critical("Couldn't allocate memory for %s->data", matvar->name);
         return bytesread;
     }
     cells = (matvar_t **)matvar->data;
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
         mat_uint32_t uncomp_buf[16] = {0,};
-        int nbytes;
+        mat_uint32_t nBytes;
         mat_uint32_t array_flags;
 
         for ( i = 0; i < nelems; i++ ) {
             cells[i] = Mat_VarCalloc();
             if ( NULL == cells[i] ) {
                 Mat_Critical("Couldn't allocate memory for cell %" SIZE_T_FMTSTR, i);
                 continue;
             }
 
             /* Read variable tag for cell */
             uncomp_buf[0] = 0;
             uncomp_buf[1] = 0;
-            bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+            err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
+            if ( 0 != err ) {
+                Mat_VarFree(cells[i]);
+                cells[i] = NULL;
+                break;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
             }
-            nbytes = uncomp_buf[1];
-            if ( 0 == nbytes ) {
+            nBytes = uncomp_buf[1];
+            if ( 0 == nBytes ) {
                 /* Empty cell: Memory optimization */
                 free(cells[i]->internal);
                 cells[i]->internal = NULL;
                 continue;
             } else if ( uncomp_buf[0] != MAT_T_MATRIX ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 Mat_Critical("cells[%" SIZE_T_FMTSTR "], Uncompressed type not MAT_T_MATRIX", i);
                 break;
             }
             cells[i]->compression = MAT_COMPRESSION_ZLIB;
-            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);
-            nbytes -= 16;
+            err = Inflate(mat, matvar->internal->z, uncomp_buf, 16, &bytesread);
+            if ( 0 != err ) {
+                Mat_VarFree(cells[i]);
+                cells[i] = NULL;
+                break;
+            }
+            nBytes -= 16;
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
                 (void)Mat_uint32Swap(uncomp_buf+2);
                 (void)Mat_uint32Swap(uncomp_buf+3);
             }
             /* Array Flags */
             if ( uncomp_buf[0] == MAT_T_UINT32 ) {
-               array_flags = uncomp_buf[2];
-               cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
-               cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
-               cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
-               cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
-               if ( cells[i]->class_type == MAT_C_SPARSE ) {
-                   /* Need to find a more appropriate place to store nzmax */
-                   cells[i]->nbytes = uncomp_buf[3];
-               }
+                array_flags = uncomp_buf[2];
+                cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
+                cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
+                cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
+                cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
+                if ( cells[i]->class_type == MAT_C_SPARSE ) {
+                    /* Need to find a more appropriate place to store nzmax */
+                    cells[i]->nbytes = uncomp_buf[3];
+                }
             } else {
-                Mat_Critical("Expected MAT_T_UINT32 for array tags, got %d",
-                               uncomp_buf[0]);
-                bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
+                Mat_Critical("Expected MAT_T_UINT32 for array tags, got %d", uncomp_buf[0]);
+                InflateSkip(mat, matvar->internal->z, nBytes, &bytesread);
             }
             if ( cells[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
-                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
-                if ( NULL == dims )
+                err = InflateRankDims(mat, matvar->internal->z, uncomp_buf, sizeof(uncomp_buf), &dims, &bytesread);
+                if ( NULL == dims ) {
                     dims = uncomp_buf + 2;
-                else
+                } else {
                     do_clean = 1;
-                nbytes -= 8;
+                }
+                if ( 0 != err ) {
+                    if ( do_clean ) {
+                        free(dims);
+                    }
+                    Mat_VarFree(cells[i]);
+                    cells[i] = NULL;
+                    break;
+                }
+                nBytes -= 8;
                 if ( mat->byteswap ) {
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
                 /* Rank and Dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
                     size_t size;
                     cells[i]->rank = uncomp_buf[1];
-                    nbytes -= cells[i]->rank;
+                    nBytes -= cells[i]->rank;
                     cells[i]->rank /= 4;
                     if ( 0 == do_clean && cells[i]->rank > 13 ) {
                         int rank = cells[i]->rank;
                         cells[i]->rank = 0;
                         Mat_Critical("%d is not a valid rank", rank);
                         continue;
                     }
-                    err = SafeMul(&size, cells[i]->rank, sizeof(*cells[i]->dims));
+                    err = Mul(&size, cells[i]->rank, sizeof(*cells[i]->dims));
                     if ( err ) {
-                        if ( do_clean )
+                        if ( do_clean ) {
                             free(dims);
+                        }
                         Mat_VarFree(cells[i]);
                         cells[i] = NULL;
                         Mat_Critical("Integer multiplication overflow");
                         continue;
                     }
                     cells[i]->dims = (size_t*)malloc(size);
                     if ( mat->byteswap ) {
                         for ( j = 0; j < cells[i]->rank; j++ )
                             cells[i]->dims[j] = Mat_uint32Swap(dims + j);
                     } else {
                         for ( j = 0; j < cells[i]->rank; j++ )
                             cells[i]->dims[j] = dims[j];
                     }
                     if ( cells[i]->rank % 2 != 0 )
-                        nbytes -= 4;
+                        nBytes -= 4;
                 }
-                if ( do_clean )
+                if ( do_clean ){
                     free(dims);
+                }
                 /* Variable name tag */
-                bytesread += InflateVarTag(mat,matvar,uncomp_buf);
-                nbytes -= 8;
+                err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
+                if ( 0 != err ) {
+                    Mat_VarFree(cells[i]);
+                    cells[i] = NULL;
+                    break;
+                }
+                nBytes -= 8;
                 if ( mat->byteswap ) {
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
                 /* Handle cell elements written with a variable name */
                 if ( uncomp_buf[1] > 0 ) {
                     /* Name of variable */
                     if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
                         mat_uint32_t len = uncomp_buf[1];
 
                         if ( len % 8 > 0 ) {
                             if ( len < UINT32_MAX - 8 + (len % 8) )
                               len = len + 8 - (len % 8);
                             else {
                                 Mat_VarFree(cells[i]);
                                 cells[i] = NULL;
                                 break;
                             }
                         }
                         cells[i]->name = (char*)malloc(len + 1);
-                        nbytes -= len;
+                        nBytes -= len;
                         if ( NULL != cells[i]->name ) {
                             /* Variable name */
-                            bytesread += InflateVarName(mat,matvar,cells[i]->name,len);
+                            err = Inflate(mat, matvar->internal->z, cells[i]->name, len, &bytesread);
+                            if ( 0 != err ) {
+                                Mat_VarFree(cells[i]);
+                                cells[i] = NULL;
+                                break;
+                            }
                             cells[i]->name[len] = '\0';
                         }
                     } else {
                         mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;
                         if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                             /* Name packed in tag */
                             cells[i]->name = (char*)malloc(len+1);
                             if ( NULL != cells[i]->name ) {
                                 memcpy(cells[i]->name,uncomp_buf+1,len);
                                 cells[i]->name[len] = '\0';
                             }
                         }
                     }
                 }
                 cells[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
                 if ( cells[i]->internal->z != NULL ) {
                     err = inflateCopy(cells[i]->internal->z,matvar->internal->z);
                     if ( err == Z_OK ) {
                         cells[i]->internal->datapos = ftell((FILE*)mat->fp);
                         if ( cells[i]->internal->datapos != -1L ) {
                             cells[i]->internal->datapos -= matvar->internal->z->avail_in;
                             if ( cells[i]->class_type == MAT_C_STRUCT )
-                                bytesread+=ReadNextStructField(mat,cells[i]);
+                                bytesread += ReadNextStructField(mat, cells[i]);
                             else if ( cells[i]->class_type == MAT_C_CELL )
-                                bytesread+=ReadNextCell(mat,cells[i]);
-                            else if ( nbytes <= (1 << MAX_WBITS) ) {
+                                bytesread += ReadNextCell(mat, cells[i]);
+                            else if ( nBytes <= (1 << MAX_WBITS) ) {
                                 /* Memory optimization: Read data if less in size
                                    than the zlib inflate state (approximately) */
-                                err = Mat_VarRead5(mat,cells[i]);
+                                err = Mat_VarRead5(mat, cells[i]);
                                 cells[i]->internal->data = cells[i]->data;
                                 cells[i]->data = NULL;
                             }
                             (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos,SEEK_SET);
                         } else {
                             Mat_Critical("Couldn't determine file position");
                         }
                         if ( cells[i]->internal->data != NULL ||
                              cells[i]->class_type == MAT_C_STRUCT ||
                              cells[i]->class_type == MAT_C_CELL ) {
                             /* Memory optimization: Free inflate state */
                             inflateEnd(cells[i]->internal->z);
                             free(cells[i]->internal->z);
                             cells[i]->internal->z = NULL;
                         }
                     } else {
                         Mat_Critical("inflateCopy returned error %s",zError(err));
                     }
                 } else {
                     Mat_Critical("Couldn't allocate memory");
                 }
             }
-            bytesread+=InflateSkip(mat,matvar->internal->z,nbytes);
+            InflateSkip(mat, matvar->internal->z, nBytes, &bytesread);
         }
 #else
         Mat_Critical("Not compiled with zlib support");
 #endif
 
     } else {
         mat_uint32_t buf[6] = {0,};
         mat_uint32_t nBytes;
         mat_uint32_t array_flags;
 
         for ( i = 0; i < nelems; i++ ) {
-            size_t readresult;
+            size_t nbytes = 0;
             mat_uint32_t name_len;
             cells[i] = Mat_VarCalloc();
-            if ( !cells[i] ) {
+            if ( NULL == cells[i] ) {
                 Mat_Critical("Couldn't allocate memory for cell %" SIZE_T_FMTSTR, i);
                 continue;
             }
 
             /* Read variable tag for cell */
-            readresult = fread(buf,4,2,(FILE*)mat->fp);
+            err = Read(buf, 4, 2, (FILE*)mat->fp, &nbytes);
 
             /* Empty cells at the end of a file may cause an EOF */
-            if ( 0 == readresult )
+            if ( 0 == err && 0 == nbytes )
                 continue;
-            bytesread += readresult;
-            if ( 1 == readresult ) {
+            bytesread += nbytes;
+            if ( 0 != err ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
             }
             nBytes = buf[1];
             if ( 0 == nBytes ) {
                 /* Empty cell: Memory optimization */
                 free(cells[i]->internal);
                 cells[i]->internal = NULL;
                 continue;
             } else if ( buf[0] != MAT_T_MATRIX ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 Mat_Critical("cells[%" SIZE_T_FMTSTR "] not MAT_T_MATRIX, fpos = %ld", i,
                     ftell((FILE*)mat->fp));
                 break;
             }
 
             /* Read array flags and the dimensions tag */
-            readresult = fread(buf,4,6,(FILE*)mat->fp);
-            bytesread += readresult;
-            if ( 6 != readresult ) {
+            err = Read(buf, 4, 6, (FILE*)mat->fp, &bytesread);
+            if ( 0 != err ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
                 (void)Mat_uint32Swap(buf+2);
                 (void)Mat_uint32Swap(buf+3);
                 (void)Mat_uint32Swap(buf+4);
                 (void)Mat_uint32Swap(buf+5);
             }
             nBytes-=24;
             /* Array flags */
             if ( buf[0] == MAT_T_UINT32 ) {
                array_flags = buf[2];
                cells[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                cells[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
                cells[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
                cells[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( cells[i]->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
                    cells[i]->nbytes = buf[3];
                }
             }
             /* Rank and dimension */
             {
-                size_t nbytes = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5]);
+                size_t nbytes = 0;
+                err = ReadRankDims(mat, cells[i], (enum matio_types)buf[4], buf[5], &nbytes);
                 bytesread += nbytes;
                 nBytes -= nbytes;
+                if ( 0 != err ) {
+                    Mat_VarFree(cells[i]);
+                    cells[i] = NULL;
+                    break;
+                }
             }
             /* Variable name tag */
-            readresult = fread(buf,1,8,(FILE*)mat->fp);
-            bytesread += readresult;
-            if ( 8 != readresult ) {
+            if ( 0 != Read(buf, 1, 8, (FILE*)mat->fp, &bytesread) ) {
                 Mat_VarFree(cells[i]);
                 cells[i] = NULL;
                 break;
             }
             nBytes -= 8;
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
             }
             name_len = 0;
             if ( buf[1] > 0 ) {
                 /* Name of variable */
                 if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
                     name_len = buf[1];
                     if ( name_len % 8 > 0 ) {
                         if ( name_len < UINT32_MAX - 8 + (name_len % 8) ) {
                             name_len = name_len + 8 - (name_len % 8);
                         } else {
                             Mat_VarFree(cells[i]);
                             cells[i] = NULL;
                             break;
                         }
                     }
                     nBytes -= name_len;
                     (void)fseek((FILE*)mat->fp,name_len,SEEK_CUR);
                 }
             }
             cells[i]->internal->datapos = ftell((FILE*)mat->fp);
             if ( cells[i]->internal->datapos != -1L ) {
                 if ( cells[i]->class_type == MAT_C_STRUCT )
                     bytesread+=ReadNextStructField(mat,cells[i]);
                 if ( cells[i]->class_type == MAT_C_CELL )
                     bytesread+=ReadNextCell(mat,cells[i]);
                 (void)fseek((FILE*)mat->fp,cells[i]->internal->datapos+nBytes,SEEK_SET);
             } else {
                 Mat_Critical("Couldn't determine file position");
             }
         }
     }
 
     return bytesread;
 }
 
 /** @brief Reads the next struct field of the structure in @c matvar
  *
  * Reads the next struct fields (fieldname length,names,data headers for all
  * the fields
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar MAT variable pointer
  * @return Number of bytes read
  */
@@ -1244,424 +1283,487 @@ static size_t
 ReadNextStructField( mat_t *mat, matvar_t *matvar )
 {
     mat_uint32_t fieldname_size;
     int err;
     size_t bytesread = 0, nfields, i;
     matvar_t **fields = NULL;
     size_t nelems = 1, nelems_x_nfields;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return bytesread;
     }
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
         mat_uint32_t uncomp_buf[16] = {0,};
         mat_uint32_t array_flags, len;
 
         /* Field name length */
-        bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+        err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
+        if ( 0 != err ) {
+            return bytesread;
+        }
         if ( mat->byteswap ) {
             (void)Mat_uint32Swap(uncomp_buf);
             (void)Mat_uint32Swap(uncomp_buf+1);
         }
         if ( (uncomp_buf[0] & 0x0000ffff) == MAT_T_INT32 && uncomp_buf[1] > 0 ) {
             fieldname_size = uncomp_buf[1];
         } else {
             Mat_Critical("Error getting fieldname size");
             return bytesread;
         }
 
         /* Field name tag */
-        bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+        err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
+        if ( 0 != err ) {
+            return bytesread;
+        }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(uncomp_buf);
         /* Name of field */
         if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
             if ( mat->byteswap )
                 len = Mat_uint32Swap(uncomp_buf+1);
             else
                 len = uncomp_buf[1];
             nfields = len / fieldname_size;
             if ( nfields*fieldname_size % 8 != 0 )
                 i = 8-(nfields*fieldname_size % 8);
             else
                 i = 0;
             if ( nfields ) {
                 char *ptr = (char*)malloc(nfields*fieldname_size+i);
                 if ( NULL != ptr ) {
-                    bytesread += InflateVarName(mat,matvar,ptr,nfields*fieldname_size+i);
-                    SetFieldNames(matvar, ptr, nfields, fieldname_size);
+                    err = Inflate(mat, matvar->internal->z, ptr, (unsigned int)(nfields*fieldname_size+i), &bytesread);
+                    if ( 0 == err ) {
+                        SetFieldNames(matvar, ptr, nfields, fieldname_size);
+                    } else {
+                        matvar->internal->fieldnames = NULL;
+                    }
                     free(ptr);
                 }
             } else {
                 matvar->internal->num_fields = 0;
                 matvar->internal->fieldnames = NULL;
             }
         } else {
             len = (uncomp_buf[0] & 0xffff0000) >> 16;
             if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                 /* Name packed in tag */
                 nfields = len / fieldname_size;
                 if ( nfields ) {
                     SetFieldNames(matvar, (char*)(uncomp_buf + 1), nfields, fieldname_size);
                 } else {
                     matvar->internal->num_fields = 0;
                     matvar->internal->fieldnames = NULL;
                 }
             } else {
                 nfields = 0;
             }
         }
 
         matvar->data_size = sizeof(matvar_t *);
-        err = SafeMul(&nelems_x_nfields, nelems, nfields);
+        err = Mul(&nelems_x_nfields, nelems, nfields);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return bytesread;
         }
-        err = SafeMul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
+        err = Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return bytesread;
         }
         if ( !matvar->nbytes )
             return bytesread;
 
         matvar->data = calloc(nelems_x_nfields, matvar->data_size);
         if ( NULL == matvar->data ) {
             Mat_Critical("Couldn't allocate memory for the data");
             return bytesread;
         }
 
         fields = (matvar_t**)matvar->data;
         for ( i = 0; i < nelems; i++ ) {
             size_t k;
             for ( k = 0; k < nfields; k++ ) {
                 fields[i*nfields+k] = Mat_VarCalloc();
             }
         }
         if ( NULL != matvar->internal->fieldnames ) {
             for ( i = 0; i < nelems; i++ ) {
                 size_t k;
                 for ( k = 0; k < nfields; k++ ) {
                     if ( NULL != matvar->internal->fieldnames[k] ) {
                         fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);
                     }
                 }
             }
         }
 
         for ( i = 0; i < nelems_x_nfields; i++ ) {
             mat_uint32_t nBytes;
             /* Read variable tag for struct field */
-            bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+            err = Inflate(mat, matvar->internal->z,uncomp_buf, 8, &bytesread);
+            if ( 0 != err ) {
+                Mat_VarFree(fields[i]);
+                fields[i] = NULL;
+                break;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
             }
             nBytes = uncomp_buf[1];
             if ( uncomp_buf[0] != MAT_T_MATRIX ) {
                 Mat_VarFree(fields[i]);
                 fields[i] = NULL;
                 Mat_Critical("fields[%" SIZE_T_FMTSTR "], Uncompressed type not MAT_T_MATRIX", i);
-                continue;
+                break;
             } else if ( 0 == nBytes ) {
                 /* Empty field: Memory optimization */
                 free(fields[i]->internal);
                 fields[i]->internal = NULL;
                 continue;
             }
             fields[i]->compression = MAT_COMPRESSION_ZLIB;
-            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);
-            nBytes -= 16;
+            err = Inflate(mat, matvar->internal->z, uncomp_buf, 16, &bytesread);
+            if ( 0 != err ) {
+                Mat_VarFree(fields[i]);
+                fields[i] = NULL;
+                break;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
                 (void)Mat_uint32Swap(uncomp_buf+2);
                 (void)Mat_uint32Swap(uncomp_buf+3);
             }
+            nBytes -= 16;
             /* Array flags */
             if ( uncomp_buf[0] == MAT_T_UINT32 ) {
                array_flags = uncomp_buf[2];
                fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
                fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
                fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( fields[i]->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
                    fields[i]->nbytes = uncomp_buf[3];
                }
             } else {
-                Mat_Critical("Expected MAT_T_UINT32 for array tags, got %d",
-                    uncomp_buf[0]);
-                bytesread+=InflateSkip(mat,matvar->internal->z,nBytes);
+                Mat_Critical("Expected MAT_T_UINT32 for array tags, got %d", uncomp_buf[0]);
+                InflateSkip(mat, matvar->internal->z, nBytes, &bytesread);
             }
             if ( fields[i]->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
-                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
-                if ( NULL == dims )
+                err = InflateRankDims(mat, matvar->internal->z, uncomp_buf, sizeof(uncomp_buf), &dims, &bytesread);
+                if ( NULL == dims ) {
                     dims = uncomp_buf + 2;
-                else
+                } else {
                     do_clean = 1;
+                }
+                if ( 0 != err ) {
+                    if ( do_clean ) {
+                        free(dims);
+                    }
+                    Mat_VarFree(fields[i]);
+                    fields[i] = NULL;
+                    break;
+                }
                 nBytes -= 8;
                 if ( mat->byteswap ) {
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
                     size_t size;
                     fields[i]->rank = uncomp_buf[1];
                     nBytes -= fields[i]->rank;
                     fields[i]->rank /= 4;
                     if ( 0 == do_clean && fields[i]->rank > 13 ) {
                         int rank = fields[i]->rank;
                         fields[i]->rank = 0;
                         Mat_Critical("%d is not a valid rank", rank);
                         continue;
                     }
-                    err = SafeMul(&size, fields[i]->rank, sizeof(*fields[i]->dims));
+                    err = Mul(&size, fields[i]->rank, sizeof(*fields[i]->dims));
                     if ( err ) {
-                        if ( do_clean )
+                        if ( do_clean ) {
                             free(dims);
+                        }
                         Mat_VarFree(fields[i]);
                         fields[i] = NULL;
                         Mat_Critical("Integer multiplication overflow");
                         continue;
                     }
                     fields[i]->dims = (size_t*)malloc(size);
                     if ( mat->byteswap ) {
                         for ( j = 0; j < fields[i]->rank; j++ )
                             fields[i]->dims[j] = Mat_uint32Swap(dims+j);
                     } else {
                         for ( j = 0; j < fields[i]->rank; j++ )
                             fields[i]->dims[j] = dims[j];
                     }
                     if ( fields[i]->rank % 2 != 0 )
                         nBytes -= 4;
                 }
-                if ( do_clean )
+                if ( do_clean ) {
                     free(dims);
+                }
                 /* Variable name tag */
-                bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+                err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
+                if ( 0 != err ) {
+                    Mat_VarFree(fields[i]);
+                    fields[i] = NULL;
+                    break;
+                }
                 nBytes -= 8;
-                fields[i]->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
+                fields[i]->internal->z = (z_streamp)calloc(1, sizeof(z_stream));
                 if ( fields[i]->internal->z != NULL ) {
                     err = inflateCopy(fields[i]->internal->z,matvar->internal->z);
                     if ( err == Z_OK ) {
                         fields[i]->internal->datapos = ftell((FILE*)mat->fp);
                         if ( fields[i]->internal->datapos != -1L ) {
                             fields[i]->internal->datapos -= matvar->internal->z->avail_in;
                             if ( fields[i]->class_type == MAT_C_STRUCT )
-                                bytesread+=ReadNextStructField(mat,fields[i]);
+                                bytesread += ReadNextStructField(mat, fields[i]);
                             else if ( fields[i]->class_type == MAT_C_CELL )
-                                bytesread+=ReadNextCell(mat,fields[i]);
+                                bytesread += ReadNextCell(mat, fields[i]);
                             else if ( nBytes <= (1 << MAX_WBITS) ) {
                                 /* Memory optimization: Read data if less in size
                                    than the zlib inflate state (approximately) */
                                 err = Mat_VarRead5(mat,fields[i]);
                                 fields[i]->internal->data = fields[i]->data;
                                 fields[i]->data = NULL;
                             }
                             (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos,SEEK_SET);
                         } else {
                             Mat_Critical("Couldn't determine file position");
                         }
                         if ( fields[i]->internal->data != NULL ||
                              fields[i]->class_type == MAT_C_STRUCT ||
                              fields[i]->class_type == MAT_C_CELL ) {
                             /* Memory optimization: Free inflate state */
                             inflateEnd(fields[i]->internal->z);
                             free(fields[i]->internal->z);
                             fields[i]->internal->z = NULL;
                         }
                     } else {
                         Mat_Critical("inflateCopy returned error %s",zError(err));
                     }
                 } else {
                     Mat_Critical("Couldn't allocate memory");
                 }
             }
-            bytesread+=InflateSkip(mat,matvar->internal->z,nBytes);
+            InflateSkip(mat, matvar->internal->z, nBytes, &bytesread);
         }
 #else
         Mat_Critical("Not compiled with zlib support");
 #endif
     } else {
         mat_uint32_t buf[6] = {0,};
         mat_uint32_t array_flags, len;
 
-        bytesread+=fread(buf,4,2,(FILE*)mat->fp);
+        err = Read(buf, 4, 2, (FILE*)mat->fp, &bytesread);
+        if ( 0 != err ) {
+            return bytesread;
+        }
         if ( mat->byteswap ) {
             (void)Mat_uint32Swap(buf);
             (void)Mat_uint32Swap(buf+1);
         }
         if ( (buf[0] & 0x0000ffff) == MAT_T_INT32 && buf[1] > 0 ) {
             fieldname_size = buf[1];
         } else {
             Mat_Critical("Error getting fieldname size");
             return bytesread;
         }
 
         /* Field name tag */
-        bytesread+=fread(buf,4,2,(FILE*)mat->fp);
+        err = Read(buf, 4, 2, (FILE*)mat->fp, &bytesread);
+        if ( 0 != err ) {
+            return bytesread;
+        }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(buf);
         /* Name of field */
         if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
             if ( mat->byteswap )
                 len = Mat_uint32Swap(buf+1);
             else
                 len = buf[1];
             nfields = len / fieldname_size;
             if ( nfields ) {
                 char *ptr = (char*)malloc(nfields*fieldname_size);
                 if ( NULL != ptr ) {
-                    size_t readresult = fread(ptr, 1, nfields*fieldname_size, (FILE*)mat->fp);
-                    bytesread += readresult;
-                    if ( nfields*fieldname_size == readresult )
+                    err = Read(ptr, 1, nfields*fieldname_size, (FILE*)mat->fp, &bytesread);
+                    if ( 0 == err ) {
                         SetFieldNames(matvar, ptr, nfields, fieldname_size);
-                    else
+                    } else {
                         matvar->internal->fieldnames = NULL;
+                    }
                     free(ptr);
                 }
                 if ( (nfields*fieldname_size) % 8 ) {
                     (void)fseek((FILE*)mat->fp,8-((nfields*fieldname_size) % 8),SEEK_CUR);
                     bytesread+=8-((nfields*fieldname_size) % 8);
                 }
             } else {
                 matvar->internal->num_fields = 0;
                 matvar->internal->fieldnames = NULL;
             }
        } else {
             len = (buf[0] & 0xffff0000) >> 16;
             if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                 /* Name packed in tag */
                 nfields = len / fieldname_size;
                 if ( nfields ) {
                     SetFieldNames(matvar, (char*)(buf + 1), nfields, fieldname_size);
                 } else {
                     matvar->internal->num_fields = 0;
                     matvar->internal->fieldnames = NULL;
                 }
             } else {
                 nfields = 0;
             }
         }
 
         matvar->data_size = sizeof(matvar_t *);
-        err = SafeMul(&nelems_x_nfields, nelems, nfields);
+        err = Mul(&nelems_x_nfields, nelems, nfields);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return bytesread;
         }
-        err = SafeMul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
+        err = Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return bytesread;
         }
         if ( !matvar->nbytes )
             return bytesread;
 
-        matvar->data = malloc(matvar->nbytes);
+        matvar->data = calloc(nelems_x_nfields, matvar->data_size);
         if ( NULL == matvar->data )
             return bytesread;
 
         fields = (matvar_t**)matvar->data;
-        for ( i = 0; i < nelems; i++ ) {
-            size_t k;
-            for ( k = 0; k < nfields; k++ ) {
-                fields[i*nfields+k] = Mat_VarCalloc();
-            }
-        }
-        if ( NULL != matvar->internal->fieldnames ) {
-            for ( i = 0; i < nelems; i++ ) {
-                size_t k;
-                for ( k = 0; k < nfields; k++ ) {
-                    if ( NULL != matvar->internal->fieldnames[k] ) {
-                        fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);
-                    }
-                }
-            }
-        }
-
         for ( i = 0; i < nelems_x_nfields; i++ ) {
             mat_uint32_t nBytes;
+
+            fields[i] = Mat_VarCalloc();
+            if ( NULL == fields[i] ) {
+                Mat_Critical("Couldn't allocate memory for field %" SIZE_T_FMTSTR, i);
+                continue;
+            }
+
             /* Read variable tag for struct field */
-            bytesread += fread(buf,4,2,(FILE*)mat->fp);
+            err = Read(buf, 4, 2, (FILE*)mat->fp, &bytesread);
+            if ( 0 != err ) {
+                Mat_VarFree(fields[i]);
+                fields[i] = NULL;
+                break;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
             }
             nBytes = buf[1];
             if ( buf[0] != MAT_T_MATRIX ) {
                 Mat_VarFree(fields[i]);
                 fields[i] = NULL;
                 Mat_Critical("fields[%" SIZE_T_FMTSTR "] not MAT_T_MATRIX, fpos = %ld", i,
                     ftell((FILE*)mat->fp));
-                return bytesread;
+                break;
             } else if ( 0 == nBytes ) {
                 /* Empty field: Memory optimization */
                 free(fields[i]->internal);
                 fields[i]->internal = NULL;
                 continue;
             }
 
             /* Read array flags and the dimensions tag */
-            bytesread += fread(buf,4,6,(FILE*)mat->fp);
+            err = Read(buf, 4, 6, (FILE*)mat->fp, &bytesread);
+            if ( 0 != err ) {
+                Mat_VarFree(fields[i]);
+                fields[i] = NULL;
+                break;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
                 (void)Mat_uint32Swap(buf+2);
                 (void)Mat_uint32Swap(buf+3);
                 (void)Mat_uint32Swap(buf+4);
                 (void)Mat_uint32Swap(buf+5);
             }
             nBytes-=24;
             /* Array flags */
             if ( buf[0] == MAT_T_UINT32 ) {
                 array_flags = buf[2];
                 fields[i]->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                 fields[i]->isComplex  = (array_flags & MAT_F_COMPLEX);
                 fields[i]->isGlobal   = (array_flags & MAT_F_GLOBAL);
                 fields[i]->isLogical  = (array_flags & MAT_F_LOGICAL);
                 if ( fields[i]->class_type == MAT_C_SPARSE ) {
                     /* Need to find a more appropriate place to store nzmax */
                     fields[i]->nbytes = buf[3];
                 }
             }
             /* Rank and dimension */
             {
-                size_t nbytes = ReadRankDims(mat, fields[i], (enum matio_types)buf[4], buf[5]);
+                size_t nbytes = 0;
+                err = ReadRankDims(mat, fields[i], (enum matio_types)buf[4], buf[5], &nbytes);
                 bytesread += nbytes;
                 nBytes -= nbytes;
+                if ( 0 != err ) {
+                    Mat_VarFree(fields[i]);
+                    fields[i] = NULL;
+                    break;
+                }
             }
             /* Variable name tag */
-            bytesread+=fread(buf,1,8,(FILE*)mat->fp);
+            err = Read(buf, 1, 8, (FILE*)mat->fp, &bytesread);
+            if ( 0 != err ) {
+                Mat_VarFree(fields[i]);
+                fields[i] = NULL;
+                break;
+            }
             nBytes-=8;
             fields[i]->internal->datapos = ftell((FILE*)mat->fp);
             if ( fields[i]->internal->datapos != -1L ) {
                 if ( fields[i]->class_type == MAT_C_STRUCT )
                     bytesread+=ReadNextStructField(mat,fields[i]);
                 else if ( fields[i]->class_type == MAT_C_CELL )
                     bytesread+=ReadNextCell(mat,fields[i]);
                 (void)fseek((FILE*)mat->fp,fields[i]->internal->datapos+nBytes,SEEK_SET);
             } else {
                 Mat_Critical("Couldn't determine file position");
             }
         }
+
+        if ( NULL != matvar->internal->fieldnames ) {
+            for ( i = 0; i < nelems; i++ ) {
+                size_t k;
+                for ( k = 0; k < nfields; k++ ) {
+                    if ( NULL != matvar->internal->fieldnames[k] && NULL != fields[i*nfields+k] ) {
+                        fields[i*nfields+k]->name = strdup(matvar->internal->fieldnames[k]);
+                    }
+                }
+            }
+        }
     }
 
     return bytesread;
 }
 
 /** @brief Reads the function handle data of the function handle in @c matvar
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar MAT variable pointer
  * @return Number of bytes read
  */
@@ -1669,99 +1771,98 @@ static size_t
 ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)
 {
     int err;
     size_t nelems = 1;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     matvar->data_size = sizeof(matvar_t *);
-    err |= SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+    err |= Mul(&matvar->nbytes, nelems, matvar->data_size);
     if ( err )
         return 0;
 
     matvar->data = malloc(matvar->nbytes);
     if ( matvar->data != NULL ) {
         size_t i;
         matvar_t **functions = (matvar_t**)matvar->data;
         for ( i = 0; i < nelems; i++ ) {
             functions[i] = Mat_VarReadNextInfo(mat);
             err = NULL == functions[i];
             if ( err )
                 break;
         }
         if ( err ) {
             free(matvar->data);
             matvar->data = NULL;
             matvar->data_size = 0;
             matvar->nbytes    = 0;
         }
     } else {
         matvar->data_size = 0;
         matvar->nbytes    = 0;
     }
 
     return 0;
 }
 
 /** @brief Reads the rank and dimensions in @c matvar
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar MAT variable pointer
  * @param data_type data type of dimension array
  * @param nbytes len of dimension array in bytes
- * @return Number of bytes read
+ * @param[out] read_bytes Read bytes
+ * @retval 0 on success
  */
-static size_t
-ReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type, mat_uint32_t nbytes)
+static int
+ReadRankDims(mat_t *mat, matvar_t *matvar, enum matio_types data_type, mat_uint32_t nbytes, size_t* read_bytes)
 {
-    size_t bytesread = 0;
+    int err = 0;
     /* Rank and dimension */
     if ( data_type == MAT_T_INT32 ) {
         matvar->rank = nbytes / sizeof(mat_uint32_t);
         matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
         if ( NULL != matvar->dims ) {
             int i;
             mat_uint32_t buf;
 
             for ( i = 0; i < matvar->rank; i++) {
-                size_t readresult = fread(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp);
-                if ( 1 == readresult ) {
-                    bytesread += sizeof(mat_uint32_t);
+                err = Read(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, read_bytes);
+                if ( 0 == err ) {
                     if ( mat->byteswap ) {
                         matvar->dims[i] = Mat_uint32Swap(&buf);
                     } else {
                         matvar->dims[i] = buf;
                     }
                 } else {
                     free(matvar->dims);
                     matvar->dims = NULL;
                     matvar->rank = 0;
-                    return 0;
+                    return err;
                 }
             }
 
             if ( matvar->rank % 2 != 0 ) {
-                size_t readresult = fread(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp);
-                if ( 1 == readresult ) {
-                    bytesread += sizeof(mat_uint32_t);
-                } else {
+                err = Read(&buf, sizeof(mat_uint32_t), 1, (FILE*)mat->fp, read_bytes);
+                if ( 0 != err ) {
                     free(matvar->dims);
                     matvar->dims = NULL;
                     matvar->rank = 0;
-                    return 0;
+                    return err;
                 }
             }
         } else {
             matvar->rank = 0;
+            err = 1;
             Mat_Critical("Error allocating memory for dims");
         }
     }
-    return bytesread;
+    return err;
 }
 
 /** @brief Writes the header and data for a given type
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar pointer to the mat variable
  * @retval 0 on success
  */
@@ -1769,169 +1870,169 @@ static int
 WriteType(mat_t *mat,matvar_t *matvar)
 {
     int err;
     const mat_uint8_t pad1 = 0;
     int nBytes, j;
     size_t nelems = 1;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err )
         return err;
 
     switch ( matvar->class_type ) {
         case MAT_C_DOUBLE:
         case MAT_C_SINGLE:
         case MAT_C_INT64:
         case MAT_C_UINT64:
         case MAT_C_INT32:
         case MAT_C_UINT32:
         case MAT_C_INT16:
         case MAT_C_UINT16:
         case MAT_C_INT8:
         case MAT_C_UINT8:
         {
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)matvar->data;
 
                 if ( NULL == matvar->data )
                     complex_data = &null_complex_data;
 
                 nBytes=WriteData(mat,complex_data->Re,nelems,matvar->data_type);
                 if ( nBytes % 8 )
                     for ( j = nBytes % 8; j < 8; j++ )
                         fwrite(&pad1,1,1,(FILE*)mat->fp);
                 nBytes=WriteData(mat,complex_data->Im,nelems,matvar->data_type);
                 if ( nBytes % 8 )
                     for ( j = nBytes % 8; j < 8; j++ )
                         fwrite(&pad1,1,1,(FILE*)mat->fp);
             } else {
                 nBytes=WriteData(mat,matvar->data,nelems,matvar->data_type);
                 if ( nBytes % 8 )
                     for ( j = nBytes % 8; j < 8; j++ )
                         fwrite(&pad1,1,1,(FILE*)mat->fp);
             }
             break;
         }
         case MAT_C_CHAR:
             nBytes=WriteCharData(mat,matvar->data,nelems,matvar->data_type);
             break;
         case MAT_C_CELL:
         {
             size_t i;
             matvar_t **cells = (matvar_t **)matvar->data;
 
             /* Check for an empty cell array */
             if ( matvar->nbytes == 0 || matvar->data_size == 0 ||
                  matvar->data   == NULL )
                 break;
             nelems = matvar->nbytes / matvar->data_size;
             for ( i = 0; i < nelems; i++ )
                 WriteCellArrayField(mat,cells[i]);
             break;
         }
         case MAT_C_STRUCT:
         {
             const mat_uint32_t array_name_type = MAT_T_INT8;
             const mat_uint32_t fieldname_type = MAT_T_INT32;
             const mat_uint32_t fieldname_data_size = 4;
             char *padzero;
             mat_uint32_t fieldname_size;
             size_t maxlen = 0, nfields, i, nelems_x_nfields;
             matvar_t **fields = (matvar_t **)matvar->data;
             mat_uint32_t fieldname;
 
             /* nelems*matvar->data_size can be zero when saving a struct that
              * contains an empty struct in one of its fields
              * (e.g. x.y = struct('z', {})). If it's zero, we would divide
              * by zero.
              */
             nfields = matvar->internal->num_fields;
             /* Check for a structure with no fields */
             if ( nfields < 1 ) {
                 fieldname = (fieldname_data_size << 16) | fieldname_type;
                 fwrite(&fieldname,4,1,(FILE*)mat->fp);
                 fieldname_size = 1;
                 fwrite(&fieldname_size,4,1,(FILE*)mat->fp);
                 fwrite(&array_name_type,4,1,(FILE*)mat->fp);
                 nBytes = 0;
                 fwrite(&nBytes,4,1,(FILE*)mat->fp);
                 break;
             }
 
             for ( i = 0; i < nfields; i++ ) {
                 size_t len = strlen(matvar->internal->fieldnames[i]);
                 if ( len > maxlen )
                     maxlen = len;
             }
             maxlen++;
             fieldname_size = maxlen;
             while ( nfields*fieldname_size % 8 != 0 )
                 fieldname_size++;
             fieldname = (fieldname_data_size << 16) | fieldname_type;
             fwrite(&fieldname,4,1,(FILE*)mat->fp);
             fwrite(&fieldname_size,4,1,(FILE*)mat->fp);
             fwrite(&array_name_type,4,1,(FILE*)mat->fp);
             nBytes = nfields*fieldname_size;
             fwrite(&nBytes,4,1,(FILE*)mat->fp);
             padzero = (char*)calloc(fieldname_size,1);
             for ( i = 0; i < nfields; i++ ) {
                 size_t len = strlen(matvar->internal->fieldnames[i]);
                 fwrite(matvar->internal->fieldnames[i],1,len,(FILE*)mat->fp);
                 fwrite(padzero,1,fieldname_size-len,(FILE*)mat->fp);
             }
             free(padzero);
-            err = SafeMul(&nelems_x_nfields, nelems, nfields);
+            err = Mul(&nelems_x_nfields, nelems, nfields);
             if ( err )
                 break;
             for ( i = 0; i < nelems_x_nfields; i++ )
                 WriteStructField(mat,fields[i]);
             break;
         }
         case MAT_C_SPARSE:
         {
             mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;
 
             nBytes = WriteData(mat,sparse->ir,sparse->nir,MAT_T_UINT32);
             if ( nBytes % 8 )
                 for ( j = nBytes % 8; j < 8; j++ )
                     fwrite(&pad1,1,1,(FILE*)mat->fp);
             nBytes = WriteData(mat,sparse->jc,sparse->njc,MAT_T_UINT32);
             if ( nBytes % 8 )
                 for ( j = nBytes % 8; j < 8; j++ )
                     fwrite(&pad1,1,1,(FILE*)mat->fp);
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)sparse->data;
                 nBytes = WriteData(mat,complex_data->Re,sparse->ndata,
                                    matvar->data_type);
                 if ( nBytes % 8 )
                     for ( j = nBytes % 8; j < 8; j++ )
                         fwrite(&pad1,1,1,(FILE*)mat->fp);
                 nBytes = WriteData(mat,complex_data->Im,sparse->ndata,
                                    matvar->data_type);
                 if ( nBytes % 8 )
                     for ( j = nBytes % 8; j < 8; j++ )
                         fwrite(&pad1,1,1,(FILE*)mat->fp);
             } else {
                 nBytes = WriteData(mat,sparse->data,sparse->ndata,
                                    matvar->data_type);
                 if ( nBytes % 8 )
                     for ( j = nBytes % 8; j < 8; j++ )
                         fwrite(&pad1,1,1,(FILE*)mat->fp);
             }
         }
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
         case MAT_C_EMPTY:
         case MAT_C_OPAQUE:
             break;
     }
 
     return err;
 }
 
 /** @brief Writes the header and data for an element of a cell array
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar pointer to the mat variable
  * @retval 0 on success
  */
@@ -2121,184 +2222,184 @@ static size_t
 WriteCompressedType(mat_t *mat,matvar_t *matvar,z_streamp z)
 {
     int err;
     mat_uint32_t comp_buf[512];
     mat_uint32_t uncomp_buf[512] = {0,};
     size_t byteswritten = 0, nelems = 1;
 
     if ( MAT_C_EMPTY == matvar->class_type ) {
         /* exit early if this is an empty data */
         return byteswritten;
     }
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return byteswritten;
     }
 
     switch ( matvar->class_type ) {
         case MAT_C_DOUBLE:
         case MAT_C_SINGLE:
         case MAT_C_INT64:
         case MAT_C_UINT64:
         case MAT_C_INT32:
         case MAT_C_UINT32:
         case MAT_C_INT16:
         case MAT_C_UINT16:
         case MAT_C_INT8:
         case MAT_C_UINT8:
         {
             /* WriteCompressedData makes sure uncompressed data is aligned
              * on an 8-byte boundary */
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)matvar->data;
 
                 if ( NULL == matvar->data )
                     complex_data = &null_complex_data;
 
                 byteswritten += WriteCompressedData(mat,z,
                     complex_data->Re,nelems,matvar->data_type);
                 byteswritten += WriteCompressedData(mat,z,
                     complex_data->Im,nelems,matvar->data_type);
             } else {
                 byteswritten += WriteCompressedData(mat,z,
                     matvar->data,nelems,matvar->data_type);
             }
             break;
         }
         case MAT_C_CHAR:
         {
             byteswritten += WriteCompressedCharData(mat,z,matvar->data,
                 nelems,matvar->data_type);
             break;
         }
         case MAT_C_CELL:
         {
             size_t i;
             matvar_t **cells = (matvar_t **)matvar->data;
 
             /* Check for an empty cell array */
             if ( matvar->nbytes == 0 || matvar->data_size == 0 ||
                  matvar->data   == NULL )
                 break;
             nelems = matvar->nbytes / matvar->data_size;
             for ( i = 0; i < nelems; i++ )
                 WriteCompressedCellArrayField(mat,cells[i],z);
             break;
         }
         case MAT_C_STRUCT:
         {
             int buf_size = 512;
             const mat_uint32_t fieldname_type = MAT_T_INT32;
             const mat_uint32_t fieldname_data_size = 4;
             unsigned char *padzero;
             int fieldname_size;
             size_t maxlen = 0, nfields, i, nelems_x_nfields;
             const mat_uint32_t array_name_type = MAT_T_INT8;
             matvar_t **fields = (matvar_t **)matvar->data;
 
             nfields = matvar->internal->num_fields;
             /* Check for a structure with no fields */
             if ( nfields < 1 ) {
                 fieldname_size = 1;
                 uncomp_buf[0] = (fieldname_data_size << 16) | fieldname_type;
                 uncomp_buf[1] = fieldname_size;
                 uncomp_buf[2] = array_name_type;
                 uncomp_buf[3] = 0;
                 z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);
                 z->avail_in = 16;
                 do {
                     z->next_out  = ZLIB_BYTE_PTR(comp_buf);
                     z->avail_out = buf_size*sizeof(*comp_buf);
                     deflate(z,Z_NO_FLUSH);
                     byteswritten += fwrite(comp_buf,1,buf_size*
                         sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);
                 } while ( z->avail_out == 0 );
                 break;
             }
 
             for ( i = 0; i < nfields; i++ ) {
                 size_t len = strlen(matvar->internal->fieldnames[i]);
                 if ( len > maxlen )
                     maxlen = len;
             }
             maxlen++;
             fieldname_size = maxlen;
             while ( nfields*fieldname_size % 8 != 0 )
                 fieldname_size++;
             uncomp_buf[0] = (fieldname_data_size << 16) | fieldname_type;
             uncomp_buf[1] = fieldname_size;
             uncomp_buf[2] = array_name_type;
             uncomp_buf[3] = nfields*fieldname_size;
 
             padzero = (unsigned char*)calloc(fieldname_size,1);
             z->next_in  = ZLIB_BYTE_PTR(uncomp_buf);
             z->avail_in = 16;
             do {
                 z->next_out  = ZLIB_BYTE_PTR(comp_buf);
                 z->avail_out = buf_size*sizeof(*comp_buf);
                 deflate(z,Z_NO_FLUSH);
                 byteswritten += fwrite(comp_buf,1,
                     buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);
             } while ( z->avail_out == 0 );
             for ( i = 0; i < nfields; i++ ) {
                 size_t len = strlen(matvar->internal->fieldnames[i]);
                 memset(padzero,'\0',fieldname_size);
                 memcpy(padzero,matvar->internal->fieldnames[i],len);
                 z->next_in  = ZLIB_BYTE_PTR(padzero);
                 z->avail_in = fieldname_size;
                 do {
                     z->next_out  = ZLIB_BYTE_PTR(comp_buf);
                     z->avail_out = buf_size*sizeof(*comp_buf);
                     deflate(z,Z_NO_FLUSH);
                     byteswritten += fwrite(comp_buf,1,
                         buf_size*sizeof(*comp_buf)-z->avail_out,(FILE*)mat->fp);
                 } while ( z->avail_out == 0 );
             }
             free(padzero);
-            err = SafeMul(&nelems_x_nfields, nelems, nfields);
+            err = Mul(&nelems_x_nfields, nelems, nfields);
             if ( err ) {
                 Mat_Critical("Integer multiplication overflow");
                 return byteswritten;
             }
             for ( i = 0; i < nelems_x_nfields; i++ )
                 byteswritten += WriteCompressedStructField(mat,fields[i],z);
             break;
         }
         case MAT_C_SPARSE:
         {
             mat_sparse_t *sparse = (mat_sparse_t*)matvar->data;
 
             byteswritten += WriteCompressedData(mat,z,sparse->ir,
                 sparse->nir,MAT_T_UINT32);
             byteswritten += WriteCompressedData(mat,z,sparse->jc,
                 sparse->njc,MAT_T_UINT32);
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)sparse->data;
                 byteswritten += WriteCompressedData(mat,z,
                     complex_data->Re,sparse->ndata,matvar->data_type);
                 byteswritten += WriteCompressedData(mat,z,
                     complex_data->Im,sparse->ndata,matvar->data_type);
             } else {
                 byteswritten += WriteCompressedData(mat,z,
                     sparse->data,sparse->ndata,matvar->data_type);
             }
             break;
         }
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
         case MAT_C_EMPTY:
         case MAT_C_OPAQUE:
             break;
     }
 
     return byteswritten;
 }
 
 /** @brief Writes the header and data for a field of a compressed cell array
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar pointer to the mat variable
  * @return number of bytes written to the MAT file
  */
@@ -2686,165 +2787,173 @@ static void
 Mat_VarReadNumeric5(mat_t *mat,matvar_t *matvar,void *data,size_t N)
 {
     int nBytes = 0, data_in_tag = 0;
     enum matio_types packed_type = MAT_T_UNKNOWN;
     mat_uint32_t tag[2];
 
     if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
         matvar->internal->z->avail_in = 0;
-        InflateDataType(mat,matvar->internal->z,tag);
+        if (0 != Inflate(mat, matvar->internal->z, tag, 4, NULL) ) {
+            return;
+        }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
 
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             nBytes = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
-            InflateDataType(mat,matvar->internal->z,tag+1);
+            if ( 0 != Inflate(mat, matvar->internal->z, tag+1, 4, NULL) ) {
+                return;
+            }
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(tag+1);
             nBytes = tag[1];
         }
 #endif
     } else {
-        size_t bytesread = fread(tag,4,1,(FILE*)mat->fp);
+        if ( 0 != Read(tag, 4, 1, (FILE*)mat->fp, NULL) ) {
+            return;
+        }
         if ( mat->byteswap )
             (void)Mat_uint32Swap(tag);
         packed_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
             data_in_tag = 1;
             nBytes = (tag[0] & 0xffff0000) >> 16;
         } else {
             data_in_tag = 0;
-            bytesread += fread(tag+1,4,1,(FILE*)mat->fp);
+            if ( 0 != Read(tag+1, 4, 1, (FILE*)mat->fp, NULL) ) {
+                return;
+            }
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(tag+1);
             nBytes = tag[1];
         }
     }
     if ( nBytes == 0 ) {
         matvar->nbytes = 0;
         return;
     }
 
     if ( matvar->compression == MAT_COMPRESSION_NONE ) {
         switch ( matvar->class_type ) {
             case MAT_C_DOUBLE:
                 nBytes = ReadDoubleData(mat,(double*)data,packed_type,N);
                 break;
             case MAT_C_SINGLE:
                 nBytes = ReadSingleData(mat,(float*)data,packed_type,N);
                 break;
             case MAT_C_INT64:
 #ifdef HAVE_MAT_INT64_T
                 nBytes = ReadInt64Data(mat,(mat_int64_t*)data,packed_type,N);
 #endif
                 break;
             case MAT_C_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                 nBytes = ReadUInt64Data(mat,(mat_uint64_t*)data,packed_type,N);
 #endif
                 break;
             case MAT_C_INT32:
                 nBytes = ReadInt32Data(mat,(mat_int32_t*)data,packed_type,N);
                 break;
             case MAT_C_UINT32:
                 nBytes = ReadUInt32Data(mat,(mat_uint32_t*)data,packed_type,N);
                 break;
             case MAT_C_INT16:
                 nBytes = ReadInt16Data(mat,(mat_int16_t*)data,packed_type,N);
                 break;
             case MAT_C_UINT16:
                 nBytes = ReadUInt16Data(mat,(mat_uint16_t*)data,packed_type,N);
                 break;
             case MAT_C_INT8:
                 nBytes = ReadInt8Data(mat,(mat_int8_t*)data,packed_type,N);
                 break;
             case MAT_C_UINT8:
                 nBytes = ReadUInt8Data(mat,(mat_uint8_t*)data,packed_type,N);
                 break;
             default:
                 break;
         }
         nBytes *= Mat_SizeOf(packed_type);
         /*
          * If the data was in the tag we started on a 4-byte
          * boundary so add 4 to make it an 8-byte
          */
         if ( data_in_tag )
             nBytes+=4;
         if ( (nBytes % 8) != 0 )
             (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
     } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
         switch ( matvar->class_type ) {
             case MAT_C_DOUBLE:
                 nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,(double*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_SINGLE:
                 nBytes = ReadCompressedSingleData(mat,matvar->internal->z,(float*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_INT64:
 #ifdef HAVE_MAT_INT64_T
                 nBytes = ReadCompressedInt64Data(mat,matvar->internal->z,(mat_int64_t*)data,
                                                  packed_type,N);
 #endif
                 break;
             case MAT_C_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                 nBytes = ReadCompressedUInt64Data(mat,matvar->internal->z,(mat_uint64_t*)data,
                                                   packed_type,N);
 #endif
                 break;
             case MAT_C_INT32:
                 nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,(mat_int32_t*)data,
                                                  packed_type,N);
                 break;
             case MAT_C_UINT32:
                 nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,(mat_uint32_t*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_INT16:
                 nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,(mat_int16_t*)data,
                                                  packed_type,N);
                 break;
             case MAT_C_UINT16:
                 nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,(mat_uint16_t*)data,
                                                   packed_type,N);
                 break;
             case MAT_C_INT8:
                 nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,(mat_int8_t*)data,
                                                 packed_type,N);
                 break;
             case MAT_C_UINT8:
                 nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,(mat_uint8_t*)data,
                                                  packed_type,N);
                 break;
             default:
                 break;
         }
         /*
          * If the data was in the tag we started on a 4-byte
          * boundary so add 4 to make it an 8-byte
          */
         if ( data_in_tag )
             nBytes+=4;
         if ( (nBytes % 8) != 0 )
-            InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
+            InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif
     }
 }
 
 /** @if mat_devman
  * @brief Reads the data of a version 5 MAT variable
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar MAT variable pointer to read the data
  * @retval 0 on success
  * @endif
  */
@@ -2852,1049 +2961,1082 @@ int
 Mat_VarRead5(mat_t *mat, matvar_t *matvar)
 {
     int nBytes = 0, byteswap, data_in_tag = 0, err;
     size_t nelems = 1;
     enum matio_types packed_type = MAT_T_UNKNOWN;
     long fpos;
     mat_uint32_t tag[2];
     size_t bytesread = 0;
 
     if ( matvar == NULL )
         return 1;
     else if ( matvar->rank == 0 )        /* An empty data set */
         return 0;
 #if HAVE_ZLIB
     else if ( NULL != matvar->internal->data ) {
         /* Data already read in ReadNextStructField or ReadNextCell */
         matvar->data = matvar->internal->data;
         matvar->internal->data = NULL;
         return 0;
     }
 #endif
     fpos = ftell((FILE*)mat->fp);
     if ( fpos == -1L ) {
         Mat_Critical("Couldn't determine file position");
         return 1;
     }
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return err;
     }
     byteswap = mat->byteswap;
     switch ( matvar->class_type ) {
         case MAT_C_EMPTY:
             matvar->nbytes = 0;
             matvar->data_size = sizeof(double);
             matvar->data_type = MAT_T_DOUBLE;
             matvar->rank = 2;
             if ( NULL != matvar->dims ) {
                 free(matvar->dims);
             }
             matvar->dims = (size_t*)calloc(matvar->rank, sizeof(*(matvar->dims)));
             break;
         case MAT_C_DOUBLE:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(double);
             matvar->data_type = MAT_T_DOUBLE;
             break;
         case MAT_C_SINGLE:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(float);
             matvar->data_type = MAT_T_SINGLE;
             break;
         case MAT_C_INT64:
 #ifdef HAVE_MAT_INT64_T
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int64_t);
             matvar->data_type = MAT_T_INT64;
 #endif
             break;
         case MAT_C_UINT64:
 #ifdef HAVE_MAT_UINT64_T
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint64_t);
             matvar->data_type = MAT_T_UINT64;
 #endif
             break;
         case MAT_C_INT32:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int32_t);
             matvar->data_type = MAT_T_INT32;
             break;
         case MAT_C_UINT32:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint32_t);
             matvar->data_type = MAT_T_UINT32;
             break;
         case MAT_C_INT16:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int16_t);
             matvar->data_type = MAT_T_INT16;
             break;
         case MAT_C_UINT16:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint16_t);
             matvar->data_type = MAT_T_UINT16;
             break;
         case MAT_C_INT8:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_int8_t);
             matvar->data_type = MAT_T_INT8;
             break;
         case MAT_C_UINT8:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             matvar->data_size = sizeof(mat_uint8_t);
             matvar->data_type = MAT_T_UINT8;
             break;
         case MAT_C_CHAR:
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
                 matvar->internal->z->avail_in = 0;
-                InflateDataType(mat,matvar->internal->z,tag);
+                err = Inflate(mat, matvar->internal->z, tag, 4, &bytesread);
+                if ( 0 != err ) {
+                    break;
+                }
                 if ( byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     nBytes = (tag[0] & 0xffff0000) >> 16;
                 } else {
                     data_in_tag = 0;
-                    InflateDataType(mat,matvar->internal->z,tag+1);
+                    err = Inflate(mat, matvar->internal->z, tag+1, 4, &bytesread);
+                    if ( 0 != err ) {
+                        break;
+                    }
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag+1);
                     nBytes = tag[1];
                 }
 #endif
                 matvar->data_type = packed_type;
                 matvar->data_size = Mat_SizeOf(matvar->data_type);
                 matvar->nbytes = nBytes;
             } else {
-                bytesread += fread(tag,4,1,(FILE*)mat->fp);
+                err = Read(tag, 4, 1, (FILE*)mat->fp, &bytesread);
+                if ( 0 != err ) {
+                    break;
+                }
                 if ( byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     /* nBytes = (tag[0] & 0xffff0000) >> 16; */
                 } else {
                     data_in_tag = 0;
-                    bytesread += fread(tag+1,4,1,(FILE*)mat->fp);
+                    err = Read(tag+1, 4, 1, (FILE*)mat->fp, &bytesread);
+                    if ( 0 != err ) {
+                        break;
+                    }
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag+1);
                     /* nBytes = tag[1]; */
                 }
                 matvar->data_type = MAT_T_UINT8;
                 matvar->data_size = Mat_SizeOf(MAT_T_UINT8);
-                err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+                err = Mul(&matvar->nbytes, nelems, matvar->data_size);
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
             }
             if ( matvar->isComplex ) {
                 break;
             }
             matvar->data = calloc(matvar->nbytes+1, 1);
             if ( NULL == matvar->data ) {
                 Mat_Critical("Couldn't allocate memory for the data");
                 err = 1;
                 break;
             }
             if ( 0 == matvar->nbytes ) {
                 break;
             }
             {
                 size_t nbytes;
-                err = SafeMul(&nbytes, nelems, matvar->data_size);
+                err = Mul(&nbytes, nelems, matvar->data_size);
                 if ( err || nbytes > matvar->nbytes ) {
                     break;
                 }
             }
             if ( matvar->compression == MAT_COMPRESSION_NONE ) {
                 nBytes = ReadCharData(mat,(char*)matvar->data,packed_type,nelems);
                 /*
                  * If the data was in the tag we started on a 4-byte
                  * boundary so add 4 to make it an 8-byte
                  */
                 if ( data_in_tag )
                     nBytes+=4;
                 if ( (nBytes % 8) != 0 )
                     (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
             } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
                 nBytes = ReadCompressedCharData(mat,matvar->internal->z,
                              (char*)matvar->data,packed_type,(int)nelems);
                 /*
                  * If the data was in the tag we started on a 4-byte
                  * boundary so add 4 to make it an 8-byte
                  */
                 if ( data_in_tag )
                     nBytes+=4;
                 if ( (nBytes % 8) != 0 )
-                    InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
+                    InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif
             }
             break;
         case MAT_C_STRUCT:
         {
             matvar_t **fields;
             size_t i, nelems_x_nfields;
 
             matvar->data_type = MAT_T_STRUCT;
-            err = SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
+            err = Mul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
             if ( err || !matvar->nbytes || !matvar->data_size || NULL == matvar->data )
                 break;
             fields = (matvar_t **)matvar->data;
             for ( i = 0; i < nelems_x_nfields; i++ ) {
                 if ( NULL != fields[i] ) {
                     err |= Mat_VarRead5(mat,fields[i]);
                 }
             }
             break;
         }
         case MAT_C_CELL:
         {
             matvar_t **cells;
             size_t i;
 
             if ( NULL == matvar->data ) {
                 Mat_Critical("Data is NULL for cell array %s",matvar->name);
                 err = 1;
                 break;
             }
             cells = (matvar_t **)matvar->data;
             for ( i = 0; i < nelems; i++ ) {
                 if ( NULL != cells[i] ) {
                     err |= Mat_VarRead5(mat, cells[i]);
                 }
             }
             /* FIXME: */
             matvar->data_type = MAT_T_CELL;
             break;
         }
         case MAT_C_SPARSE:
         {
             mat_uint32_t N = 0;
             mat_sparse_t *sparse;
 
             matvar->data_size = sizeof(mat_sparse_t);
             matvar->data      = calloc(1, matvar->data_size);
             if ( matvar->data == NULL ) {
                 Mat_Critical("Mat_VarRead5: Allocation of data pointer failed");
                 err = 1;
                 break;
             }
             sparse = (mat_sparse_t*)matvar->data;
             sparse->nzmax  = matvar->nbytes;
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
             /*  Read ir    */
             bytesread += ReadSparse(mat, matvar, &sparse->nir, &sparse->ir);
             /*  Read jc    */
             bytesread += ReadSparse(mat, matvar, &sparse->njc, &sparse->jc);
             /*  Read data  */
             if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if HAVE_ZLIB
                 matvar->internal->z->avail_in = 0;
-                InflateDataType(mat,matvar->internal->z,tag);
+                err = Inflate(mat, matvar->internal->z, tag, 4, &bytesread);
+                if ( 0 != err ) {
+                    break;
+                }
                 if ( mat->byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     N = (tag[0] & 0xffff0000) >> 16;
                 } else {
                     data_in_tag = 0;
                     (void)ReadCompressedUInt32Data(mat,matvar->internal->z,
                              &N,MAT_T_UINT32,1);
                 }
 #endif
             } else {
-                bytesread += fread(tag,4,1,(FILE*)mat->fp);
+                err = Read(tag, 4, 1, (FILE*)mat->fp, &bytesread);
+                if ( 0 != err ) {
+                    break;
+                }
                 if ( mat->byteswap )
                     (void)Mat_uint32Swap(tag);
                 packed_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                     data_in_tag = 1;
                     N = (tag[0] & 0xffff0000) >> 16;
                 } else {
                     data_in_tag = 0;
-                    bytesread += fread(&N,4,1,(FILE*)mat->fp);
+                    err = Read(&N, 4, 1, (FILE*)mat->fp, &bytesread);
+                    if ( 0 != err ) {
+                        break;
+                    }
                     if ( mat->byteswap )
                         (void)Mat_uint32Swap(&N);
                 }
             }
             if ( matvar->isLogical && packed_type == MAT_T_DOUBLE ) {
                 /* For some reason, MAT says the data type is a double,
                  * but it appears to be written as 8-bit unsigned integer.
                  */
                 packed_type = MAT_T_UINT8;
             }
 #if defined(EXTENDED_SPARSE)
             matvar->data_type = packed_type;
 #else
             matvar->data_type = MAT_T_DOUBLE;
 #endif
             {
                 size_t s_type = Mat_SizeOf(packed_type);
                 if ( s_type == 0 )
                     break;
                 sparse->ndata = N / s_type;
             }
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data;
                 size_t nbytes;
-                err = SafeMul(&nbytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
+                err = Mul(&nbytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
                 complex_data = ComplexMalloc(nbytes);
                 if ( NULL == complex_data ) {
                     Mat_Critical("Couldn't allocate memory for the complex sparse data");
                     err = 1;
                     break;
                 }
                 if ( matvar->compression == MAT_COMPRESSION_NONE ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadDoubleData(mat,(double*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadSingleData(mat,(float*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else
                     nBytes = ReadDoubleData(mat,(double*)complex_data->Re,
                                  packed_type,sparse->ndata);
 #endif
                     nBytes *= Mat_SizeOf(packed_type);
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 
                     /* Complex Data Tag */
-                    bytesread += fread(tag,4,1,(FILE*)mat->fp);
+                    err = Read(tag, 4, 1, (FILE*)mat->fp, &bytesread);
+                    if ( 0 != err ) {
+                        break;
+                    }
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag);
                     packed_type = TYPE_FROM_TAG(tag[0]);
                     if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                         data_in_tag = 1;
                         nBytes = (tag[0] & 0xffff0000) >> 16;
                     } else {
                         data_in_tag = 0;
-                        bytesread += fread(tag+1,4,1,(FILE*)mat->fp);
+                        err = Read(tag+1, 4, 1, (FILE*)mat->fp, &bytesread);
+                        if ( 0 != err ) {
+                            break;
+                        }
                         if ( byteswap )
                             (void)Mat_uint32Swap(tag+1);
                         nBytes = tag[1];
                     }
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadDoubleData(mat,(double*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadSingleData(mat,(float*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadInt64Data(mat,(mat_int64_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadUInt64Data(mat,(mat_uint64_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadInt32Data(mat,(mat_int32_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadUInt32Data(mat,(mat_uint32_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadInt16Data(mat,(mat_int16_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadUInt16Data(mat,(mat_uint16_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadInt8Data(mat,(mat_int8_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadUInt8Data(mat,(mat_uint8_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else /* EXTENDED_SPARSE */
                     nBytes = ReadDoubleData(mat,(double*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif /* EXTENDED_SPARSE */
                     nBytes *= Mat_SizeOf(packed_type);
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
                 } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadCompressedSingleData(mat,matvar->internal->z,
                                  (float*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadCompressedInt64Data(mat,
                                 matvar->internal->z,(mat_int64_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadCompressedUInt64Data(mat,
                                 matvar->internal->z,(mat_uint64_t*)complex_data->Re,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                                  (mat_int32_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                                  (mat_uint32_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,
                                  (mat_int16_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,
                                  (mat_uint16_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,
                                  (mat_int8_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,
                                  (mat_uint8_t*)complex_data->Re,packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else    /* EXTENDED_SPARSE */
                     nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Re,packed_type,sparse->ndata);
 #endif    /* EXTENDED_SPARSE */
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
-                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
+                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8), NULL);
 
                     /* Complex Data Tag */
-                    InflateDataType(mat,matvar->internal->z,tag);
+                    err = Inflate(mat, matvar->internal->z, tag, 4, NULL);
+                    if ( 0 != err ) {
+                        break;
+                    }
                     if ( byteswap )
                         (void)Mat_uint32Swap(tag);
 
                     packed_type = TYPE_FROM_TAG(tag[0]);
                     if ( tag[0] & 0xffff0000 ) { /* Data is in the tag */
                         data_in_tag = 1;
                         nBytes = (tag[0] & 0xffff0000) >> 16;
                     } else {
                         data_in_tag = 0;
-                        InflateDataType(mat,matvar->internal->z,tag+1);
+                        err = Inflate(mat, matvar->internal->z, tag+1, 4, NULL);
+                        if ( 0 != err ) {
+                            break;
+                        }
                         if ( byteswap )
                             (void)Mat_uint32Swap(tag+1);
                         nBytes = tag[1];
                     }
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadCompressedSingleData(mat,matvar->internal->z,
                                  (float*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadCompressedInt64Data(mat,
                                 matvar->internal->z,(mat_int64_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadCompressedUInt64Data(mat,
                                 matvar->internal->z,(mat_uint64_t*)complex_data->Im,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                                  (mat_int32_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                                  (mat_uint32_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,
                                  (mat_int16_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,
                                  (mat_uint16_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,
                                  (mat_int8_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,
                                  (mat_uint8_t*)complex_data->Im,packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else    /* EXTENDED_SPARSE */
                     nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)complex_data->Im,packed_type,sparse->ndata);
 #endif    /* EXTENDED_SPARSE */
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
-                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
+                        InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif    /* HAVE_ZLIB */
                 }
                 sparse->data = complex_data;
             } else { /* isComplex */
                 size_t nbytes;
-                err = SafeMul(&nbytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
+                err = Mul(&nbytes, sparse->ndata, Mat_SizeOf(matvar->data_type));
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
                 sparse->data = malloc(nbytes);
                 if ( sparse->data == NULL ) {
                     Mat_Critical("Couldn't allocate memory for the sparse data");
                     err = 1;
                     break;
                 }
                 if ( matvar->compression == MAT_COMPRESSION_NONE ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadDoubleData(mat,(double*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadSingleData(mat,(float*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadInt64Data(mat,(mat_int64_t*)sparse->data,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadUInt64Data(mat,(mat_uint64_t*)sparse->data,
                                 packed_type,sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadInt32Data(mat,(mat_int32_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadUInt32Data(mat,(mat_uint32_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadInt16Data(mat,(mat_int16_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadUInt16Data(mat,(mat_uint16_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadInt8Data(mat,(mat_int8_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadUInt8Data(mat,(mat_uint8_t*)sparse->data,
                                 packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else
                     nBytes = ReadDoubleData(mat,(double*)sparse->data,packed_type,
                                  sparse->ndata);
 #endif
                     nBytes *= Mat_SizeOf(packed_type);
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
                         (void)fseek((FILE*)mat->fp,8-(nBytes % 8),SEEK_CUR);
 #if HAVE_ZLIB
                 } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
 #if defined(EXTENDED_SPARSE)
                     switch ( matvar->data_type ) {
                         case MAT_T_DOUBLE:
                             nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_SINGLE:
                             nBytes = ReadCompressedSingleData(mat,matvar->internal->z,
                                  (float*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT64:
 #ifdef HAVE_MAT_INT64_T
                             nBytes = ReadCompressedInt64Data(mat,
                                 matvar->internal->z,(mat_int64_t*)sparse->data,packed_type,
                                 sparse->ndata);
 #endif
                             break;
                         case MAT_T_UINT64:
 #ifdef HAVE_MAT_UINT64_T
                             nBytes = ReadCompressedUInt64Data(mat,
                                 matvar->internal->z,(mat_uint64_t*)sparse->data,packed_type,
                                 sparse->ndata);
 #endif
                             break;
                         case MAT_T_INT32:
                             nBytes = ReadCompressedInt32Data(mat,matvar->internal->z,
                                  (mat_int32_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT32:
                             nBytes = ReadCompressedUInt32Data(mat,matvar->internal->z,
                                  (mat_uint32_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT16:
                             nBytes = ReadCompressedInt16Data(mat,matvar->internal->z,
                                  (mat_int16_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT16:
                             nBytes = ReadCompressedUInt16Data(mat,matvar->internal->z,
                                  (mat_uint16_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_INT8:
                             nBytes = ReadCompressedInt8Data(mat,matvar->internal->z,
                                  (mat_int8_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         case MAT_T_UINT8:
                             nBytes = ReadCompressedUInt8Data(mat,matvar->internal->z,
                                  (mat_uint8_t*)sparse->data,packed_type,sparse->ndata);
                             break;
                         default:
                             break;
                     }
 #else   /* EXTENDED_SPARSE */
                     nBytes = ReadCompressedDoubleData(mat,matvar->internal->z,
                                  (double*)sparse->data,packed_type,sparse->ndata);
 #endif   /* EXTENDED_SPARSE */
                     if ( data_in_tag )
                         nBytes+=4;
                     if ( (nBytes % 8) != 0 )
-                        InflateSkip(mat,matvar->internal->z,8-(nBytes % 8));
+                        InflateSkip(mat, matvar->internal->z, 8-(nBytes % 8), NULL);
 #endif   /* HAVE_ZLIB */
                 }
             }
             break;
         }
         case MAT_C_FUNCTION:
         {
             matvar_t **functions;
             size_t nfunctions = 0;
 
             if ( !matvar->nbytes || !matvar->data_size )
                 break;
             nfunctions = matvar->nbytes / matvar->data_size;
             functions = (matvar_t **)matvar->data;
             if ( NULL != functions ) {
                 size_t i;
                 for ( i = 0; i < nfunctions; i++ ) {
                     Mat_VarRead5(mat,functions[i]);
                 }
             }
             /* FIXME: */
             matvar->data_type = MAT_T_FUNCTION;
             break;
         }
         default:
             Mat_Critical("Mat_VarRead5: %d is not a supported class", matvar->class_type);
             err = 1;
     }
     switch ( matvar->class_type ) {
         case MAT_C_DOUBLE:
         case MAT_C_SINGLE:
 #ifdef HAVE_MAT_INT64_T
         case MAT_C_INT64:
 #endif
 #ifdef HAVE_MAT_UINT64_T
         case MAT_C_UINT64:
 #endif
         case MAT_C_INT32:
         case MAT_C_UINT32:
         case MAT_C_INT16:
         case MAT_C_UINT16:
         case MAT_C_INT8:
         case MAT_C_UINT8:
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data;
 
-                err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+                err = Mul(&matvar->nbytes, nelems, matvar->data_size);
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
 
                 complex_data = ComplexMalloc(matvar->nbytes);
                 if ( NULL == complex_data ) {
                     Mat_Critical("Couldn't allocate memory for the complex data");
                     err = 1;
                     break;
                 }
 
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Re,nelems);
                 Mat_VarReadNumeric5(mat,matvar,complex_data->Im,nelems);
                 matvar->data = complex_data;
             } else {
-                err = SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+                err = Mul(&matvar->nbytes, nelems, matvar->data_size);
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     break;
                 }
 
                 matvar->data = malloc(matvar->nbytes);
                 if ( NULL == matvar->data ) {
                     Mat_Critical("Couldn't allocate memory for the data");
                     err = 1;
                     break;
                 }
                 Mat_VarReadNumeric5(mat,matvar,matvar->data,nelems);
             }
         default:
             break;
     }
     (void)fseek((FILE*)mat->fp,fpos,SEEK_SET);
 
     return err;
 }
 
 #if HAVE_ZLIB
 #define GET_DATA_SLABN_RANK_LOOP \
     do { \
         for ( j = 1; j < rank; j++ ) { \
             cnt[j]++; \
             if ( (cnt[j] % edge[j]) == 0 ) { \
                 cnt[j] = 0; \
                 if ( (I % dimp[j]) != 0 ) { \
                     ptr_in += dimp[j]-(I % dimp[j])+dimp[j-1]*start[j]; \
                     I += dimp[j]-(I % dimp[j]) + dimp[j-1]*start[j]; \
                 } else if ( start[j] ) { \
                     ptr_in += dimp[j-1]*start[j]; \
                     I += dimp[j-1]*start[j]; \
                 } \
             } else { \
                 I += inc[j]; \
                 ptr_in += inc[j]; \
                 break; \
             } \
         } \
     } while (0)
 
 #define GET_DATA_SLAB2(T) \
     do { \
         ptr_in += start[1]*dims[0] + start[0]; \
         for ( i = 0; i < edge[1]; i++ ) { \
             for ( j = 0; j < edge[0]; j++ ) { \
                 *ptr = (T)(*(ptr_in+j*stride[0])); \
                 ptr++; \
             } \
             ptr_in += stride[1]*dims[0]; \
         } \
     } while (0)
 
 #define GET_DATA_SLABN(T) \
     do { \
         inc[0]  = stride[0]-1; \
         dimp[0] = dims[0]; \
         N       = edge[0]; \
         I       = 0; /* start[0]; */ \
         for ( i = 1; i < rank; i++ ) { \
             inc[i]  = stride[i]-1; \
             dimp[i] = dims[i-1]; \
             for ( j = i; j--; ) { \
                 inc[i]  *= dims[j]; \
                 dimp[i] *= dims[j+1]; \
             } \
             N *= edge[i]; \
             I += dimp[i-1]*start[i]; \
         } \
         ptr_in += I; \
         if ( stride[0] == 1 ) { \
             for ( i = 0; i < N; i+=edge[0] ) { \
                 int k; \
                 if ( start[0] ) { \
                     ptr_in += start[0]; \
                     I += start[0]; \
                 } \
                 for ( k = 0; k < edge[0]; k++ ) { \
                     *(ptr+i+k) = (T)(*(ptr_in+k)); \
                 } \
                 I += dims[0]-start[0]; \
                 ptr_in += dims[0]-start[0]; \
                 GET_DATA_SLABN_RANK_LOOP; \
             } \
         } else { \
             for ( i = 0; i < N; i+=edge[0] ) { \
                 if ( start[0] ) { \
                     ptr_in += start[0]; \
                     I += start[0]; \
                 } \
                 for ( j = 0; j < edge[0]; j++ ) { \
                     *(ptr+i+j) = (T)(*ptr_in); \
                     ptr_in += stride[0]; \
                     I += stride[0]; \
                 } \
                 I += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \
                 ptr_in += dims[0]-(ptrdiff_t)edge[0]*stride[0]-start[0]; \
                 GET_DATA_SLABN_RANK_LOOP; \
             } \
         } \
     } while (0)
 
 #ifdef HAVE_MAT_INT64_T
 #define GET_DATA_SLAB2_INT64(T) \
     do { \
         if ( MAT_T_INT64 == data_type ) { \
             mat_int64_t *ptr_in = (mat_int64_t *)data_in; \
             GET_DATA_SLAB2(T); \
             err = 0; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLAB2_INT64(T)
 #endif /* HAVE_MAT_INT64_T */
 
 #ifdef HAVE_MAT_UINT64_T
 #define GET_DATA_SLAB2_UINT64(T) \
     do { \
         if ( MAT_T_UINT64 == data_type ) { \
             mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \
             GET_DATA_SLAB2(T); \
             err = 0; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLAB2_UINT64(T)
 #endif /* HAVE_MAT_UINT64_T */
 
 #define GET_DATA_SLAB2_TYPE(T) \
     do { \
         switch ( data_type ) { \
             case MAT_T_DOUBLE: \
             { \
                 double *ptr_in = (double *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_SINGLE: \
             { \
                 float *ptr_in = (float *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_INT32: \
             { \
                 mat_int32_t *ptr_in = (mat_int32_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_UINT32: \
             { \
                 mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_INT16: \
             { \
                 mat_int16_t *ptr_in = (mat_int16_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_UINT16: \
             { \
                 mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_INT8: \
             { \
                 mat_int8_t *ptr_in = (mat_int8_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             case MAT_T_UINT8: \
             { \
                 mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \
                 GET_DATA_SLAB2(T); \
                 break; \
             } \
             default: \
                 err = 1; \
                 GET_DATA_SLAB2_INT64(T); \
                 GET_DATA_SLAB2_UINT64(T); \
                 break; \
         } \
     } while (0)
 
 #ifdef HAVE_MAT_INT64_T
 #define GET_DATA_SLABN_INT64(T) \
     do { \
         if ( MAT_T_INT64 == data_type ) { \
             mat_int64_t *ptr_in = (mat_int64_t *)data_in; \
             GET_DATA_SLABN(T); \
             err = 0; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLABN_INT64(T)
 #endif /* HAVE_MAT_INT64_T */
 
 #ifdef HAVE_MAT_UINT64_T
 #define GET_DATA_SLABN_UINT64(T) \
     do { \
         if ( MAT_T_UINT64 == data_type ) { \
             mat_uint64_t *ptr_in = (mat_uint64_t *)data_in; \
             GET_DATA_SLABN(T); \
             err = 0; \
         } \
     } while (0)
 #else
 #define GET_DATA_SLABN_UINT64(T)
 #endif /* HAVE_MAT_UINT64_T */
 
 #define GET_DATA_SLABN_TYPE(T) \
     do { \
         switch ( data_type ) { \
             case MAT_T_DOUBLE: \
             { \
                 double *ptr_in = (double *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_SINGLE: \
             { \
                 float *ptr_in = (float *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_INT32: \
             { \
                 mat_int32_t *ptr_in = (mat_int32_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_UINT32: \
             { \
                 mat_uint32_t *ptr_in = (mat_uint32_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_INT16: \
             { \
                 mat_int16_t *ptr_in = (mat_int16_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_UINT16: \
             { \
                 mat_uint16_t *ptr_in = (mat_uint16_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_INT8: \
             { \
                 mat_int8_t *ptr_in = (mat_int8_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             case MAT_T_UINT8: \
             { \
                 mat_uint8_t *ptr_in = (mat_uint8_t *)data_in; \
                 GET_DATA_SLABN(T); \
                 break; \
             } \
             default: \
                 err = 1; \
                 GET_DATA_SLABN_INT64(T); \
                 GET_DATA_SLABN_UINT64(T); \
                 break; \
         } \
     } while (0)
@@ -4210,224 +4352,246 @@ int
 Mat_VarReadData5(mat_t *mat,matvar_t *matvar,void *data,
     int *start,int *stride,int *edge)
 {
     int err = 0,real_bytes = 0;
     mat_int32_t tag[2];
 #if HAVE_ZLIB
     z_stream z;
 #endif
     size_t bytesread = 0;
 
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
     if ( matvar->compression == MAT_COMPRESSION_NONE ) {
-        bytesread += fread(tag,4,2,(FILE*)mat->fp);
+        err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+        if ( 0 != err ) {
+            return err;
+        }
         if ( mat->byteswap ) {
             (void)Mat_int32Swap(tag);
             (void)Mat_int32Swap(tag+1);
         }
         matvar->data_type = TYPE_FROM_TAG(tag[0]);
         if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
             (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
             real_bytes = 4+(tag[0] >> 16);
         } else {
             real_bytes = 8+tag[1];
         }
 #if HAVE_ZLIB
     } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
         if ( NULL != matvar->internal->data ) {
             /* Data already read in ReadNextStructField or ReadNextCell */
             if ( matvar->isComplex ) {
                 mat_complex_split_t *ci, *co;
 
                 co = (mat_complex_split_t*)data;
                 ci = (mat_complex_split_t*)matvar->internal->data;
                 err = GetDataSlab(ci->Re, co->Re, matvar->class_type,
                     matvar->data_type, matvar->dims, start, stride, edge,
                     matvar->rank, matvar->nbytes);
                 if ( err == 0 )
                     err = GetDataSlab(ci->Im, co->Im, matvar->class_type,
                         matvar->data_type, matvar->dims, start, stride, edge,
                         matvar->rank, matvar->nbytes);
                 return err;
             } else {
                 return GetDataSlab(matvar->internal->data, data, matvar->class_type,
                     matvar->data_type, matvar->dims, start, stride, edge,
                     matvar->rank, matvar->nbytes);
             }
         }
 
         err = inflateCopy(&z,matvar->internal->z);
         if ( err != Z_OK ) {
             Mat_Critical("inflateCopy returned error %s",zError(err));
             return -1;
         }
         z.avail_in = 0;
-        InflateDataType(mat,&z,tag);
+        err = Inflate(mat, &z, tag, 4, NULL);
+        if ( 0 != err ) {
+            return err;
+        }
         if ( mat->byteswap ) {
             (void)Mat_int32Swap(tag);
         }
         matvar->data_type = TYPE_FROM_TAG(tag[0]);
         if ( !(tag[0] & 0xffff0000) ) {/* Data is NOT packed in the tag */
-            /* We're cheating, but InflateDataType just inflates 4 bytes */
-            InflateDataType(mat,&z,tag+1);
+            err = Inflate(mat, &z, tag+1, 4, NULL);
+            if ( 0 != err ) {
+                return err;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_int32Swap(tag+1);
             }
             real_bytes = 8+tag[1];
         } else {
             real_bytes = 4+(tag[0] >> 16);
         }
 #endif
     }
     if ( real_bytes % 8 )
         real_bytes += (8-(real_bytes % 8));
 
     if ( matvar->rank == 2 ) {
         if ( (size_t)stride[0]*(edge[0]-1)+start[0]+1 > matvar->dims[0] )
             err = 1;
         else if ( (size_t)stride[1]*(edge[1]-1)+start[1]+1 > matvar->dims[1] )
             err = 1;
         else if ( matvar->compression == MAT_COMPRESSION_NONE ) {
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
                 ReadDataSlab2(mat,complex_data->Re,matvar->class_type,
                     matvar->data_type,matvar->dims,start,stride,edge);
                 (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);
-                bytesread += fread(tag,4,2,(FILE*)mat->fp);
+                err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+                if ( 0 != err ) {
+                    return err;
+                }
                 if ( mat->byteswap ) {
                     (void)Mat_int32Swap(tag);
                     (void)Mat_int32Swap(tag+1);
                 }
                 matvar->data_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
                     (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
                 }
                 ReadDataSlab2(mat,complex_data->Im,matvar->class_type,
                               matvar->data_type,matvar->dims,start,stride,edge);
             } else {
                 ReadDataSlab2(mat,data,matvar->class_type,
                     matvar->data_type,matvar->dims,start,stride,edge);
             }
         }
 #if HAVE_ZLIB
         else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
                 ReadCompressedDataSlab2(mat,&z,complex_data->Re,
                     matvar->class_type,matvar->data_type,matvar->dims,
                     start,stride,edge);
 
                 (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
 
                 /* Reset zlib knowledge to before reading real tag */
                 inflateEnd(&z);
                 err = inflateCopy(&z,matvar->internal->z);
                 if ( err != Z_OK ) {
                     Mat_Critical("inflateCopy returned error %s",zError(err));
+                    return err;
                 }
-                InflateSkip(mat,&z,real_bytes);
+                InflateSkip(mat, &z, real_bytes, NULL);
                 z.avail_in = 0;
-                InflateDataType(mat,&z,tag);
+                err = Inflate(mat, &z, tag, 4, NULL);
+                if ( 0 != err ) {
+                    return err;
+                }
                 if ( mat->byteswap ) {
                     (void)Mat_int32Swap(tag);
                 }
                 matvar->data_type = TYPE_FROM_TAG(tag[0]);
                 if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/
-                    InflateSkip(mat,&z,4);
+                    InflateSkip(mat, &z, 4, NULL);
                 }
                 ReadCompressedDataSlab2(mat,&z,complex_data->Im,
                     matvar->class_type,matvar->data_type,matvar->dims,
                     start,stride,edge);
             } else {
                 ReadCompressedDataSlab2(mat,&z,data,matvar->class_type,
                     matvar->data_type,matvar->dims,start,stride,edge);
             }
             inflateEnd(&z);
         }
 #endif
     } else {
         if ( matvar->compression == MAT_COMPRESSION_NONE ) {
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
                 ReadDataSlabN(mat,complex_data->Re,matvar->class_type,
                     matvar->data_type,matvar->rank,matvar->dims,
                     start,stride,edge);
 
                 (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);
-                bytesread += fread(tag,4,2,(FILE*)mat->fp);
+                err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+                if ( 0 != err ) {
+                    return err;
+                }
                 if ( mat->byteswap ) {
                     (void)Mat_int32Swap(tag);
                     (void)Mat_int32Swap(tag+1);
                 }
                 matvar->data_type = TYPE_FROM_TAG(tag[0]);
                 if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
                     (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
                 }
                 ReadDataSlabN(mat,complex_data->Im,matvar->class_type,
                     matvar->data_type,matvar->rank,matvar->dims,
                     start,stride,edge);
             } else {
                 ReadDataSlabN(mat,data,matvar->class_type,matvar->data_type,
                     matvar->rank,matvar->dims,start,stride,edge);
             }
         }
 #if HAVE_ZLIB
         else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
             if ( matvar->isComplex ) {
                 mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
                 ReadCompressedDataSlabN(mat,&z,complex_data->Re,
                     matvar->class_type,matvar->data_type,matvar->rank,
                     matvar->dims,start,stride,edge);
 
                 (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
                 /* Reset zlib knowledge to before reading real tag */
                 inflateEnd(&z);
                 err = inflateCopy(&z,matvar->internal->z);
                 if ( err != Z_OK ) {
                     Mat_Critical("inflateCopy returned error %s",zError(err));
+                    return err;
                 }
-                InflateSkip(mat,&z,real_bytes);
+                InflateSkip(mat, &z, real_bytes, NULL);
                 z.avail_in = 0;
-                InflateDataType(mat,&z,tag);
+                err = Inflate(mat, &z, tag, 4, NULL);
+                if ( 0 != err ) {
+                    return err;
+                }
                 if ( mat->byteswap ) {
                     (void)Mat_int32Swap(tag);
                 }
                 matvar->data_type = TYPE_FROM_TAG(tag[0]);
                 if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/
-                    InflateSkip(mat,&z,4);
+                    InflateSkip(mat, &z, 4, NULL);
                 }
                 ReadCompressedDataSlabN(mat,&z,complex_data->Im,
                     matvar->class_type,matvar->data_type,matvar->rank,
                     matvar->dims,start,stride,edge);
             } else {
                 ReadCompressedDataSlabN(mat,&z,data,matvar->class_type,
                     matvar->data_type,matvar->rank,matvar->dims,
                     start,stride,edge);
             }
             inflateEnd(&z);
         }
 #endif
     }
     if ( err == 0 ) {
         matvar->data_type = ClassType2DataType(matvar->class_type);
         matvar->data_size = Mat_SizeOfClass(matvar->class_type);
     }
     return err;
 }
 
 /** @brief Reads a subset of a MAT variable using a 1-D indexing
  *
  * Reads data from a MAT variable using a linear (1-D) indexing mode. The
  * variable must have been read by Mat_VarReadInfo.
  * @ingroup MAT
  * @param mat MAT file to read data from
  * @param matvar MAT variable information
  * @param data pointer to store data in (must be pre-allocated)
  * @param start starting index
  * @param stride stride of data
  * @param edge number of elements to read
  * @retval 0 on success
  */
@@ -4435,157 +4599,172 @@ int
 Mat_VarReadDataLinear5(mat_t *mat,matvar_t *matvar,void *data,int start,
                       int stride,int edge)
 {
     int err = 0, real_bytes = 0;
     mat_int32_t tag[2];
 #if HAVE_ZLIB
     z_stream z;
 #endif
     size_t bytesread = 0, nelems = 1;
 
     if ( mat->version == MAT_FT_MAT4 )
         return -1;
     (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
     if ( matvar->compression == MAT_COMPRESSION_NONE ) {
-        bytesread += fread(tag,4,2,(FILE*)mat->fp);
+        err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+        if ( 0 != err ) {
+            return err;
+        }
         if ( mat->byteswap ) {
             (void)Mat_int32Swap(tag);
             (void)Mat_int32Swap(tag+1);
         }
         matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);
         if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
             (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
             real_bytes = 4+(tag[0] >> 16);
         } else {
             real_bytes = 8+tag[1];
         }
 #if HAVE_ZLIB
     } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
         if ( NULL != matvar->internal->data ) {
             /* Data already read in ReadNextStructField or ReadNextCell */
             if ( matvar->isComplex ) {
                 mat_complex_split_t *ci, *co;
 
                 co = (mat_complex_split_t*)data;
                 ci = (mat_complex_split_t*)matvar->internal->data;
                 err = GetDataLinear(ci->Re, co->Re, matvar->class_type,
                     matvar->data_type, start, stride, edge);
                 if ( err == 0 )
                     err = GetDataLinear(ci->Im, co->Im, matvar->class_type,
                         matvar->data_type, start, stride, edge);
                 return err;
             } else {
                 return GetDataLinear(matvar->internal->data, data, matvar->class_type,
                     matvar->data_type, start, stride, edge);
             }
         }
 
         matvar->internal->z->avail_in = 0;
         err = inflateCopy(&z,matvar->internal->z);
         if ( err != Z_OK ) {
             Mat_Critical("inflateCopy returned error %s",zError(err));
-            return -1;
+            return err;
+        }
+        err = Inflate(mat, &z, tag, 4, NULL);
+        if ( 0 != err ) {
+            return err;
         }
-        InflateDataType(mat,&z,tag);
         if ( mat->byteswap ) {
             (void)Mat_int32Swap(tag);
             (void)Mat_int32Swap(tag+1);
         }
         matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);
         if ( !(tag[0] & 0xffff0000) ) {/* Data is NOT packed in the tag */
-            /* We're cheating, but InflateDataType just inflates 4 bytes */
-            InflateDataType(mat,&z,tag+1);
+            err = Inflate(mat, &z, tag+1, 4, NULL);
+            if ( 0 != err ) {
+                return err;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_int32Swap(tag+1);
             }
             real_bytes = 8+tag[1];
         } else {
             real_bytes = 4+(tag[0] >> 16);
         }
 #endif
     }
     if ( real_bytes % 8 )
         real_bytes += (8-(real_bytes % 8));
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err ) {
         Mat_Critical("Integer multiplication overflow");
         return -1;
     }
 
     if ( (size_t)stride*(edge-1)+start+1 > nelems ) {
         err = 1;
     } else if ( matvar->compression == MAT_COMPRESSION_NONE ) {
         if ( matvar->isComplex ) {
             mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
             ReadDataSlab1(mat,complex_data->Re,matvar->class_type,
                           matvar->data_type,start,stride,edge);
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos+real_bytes,SEEK_SET);
-            bytesread += fread(tag,4,2,(FILE*)mat->fp);
+            err = Read(tag, 4, 2, (FILE*)mat->fp, NULL);
+            if ( 0 != err ) {
+                return err;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_int32Swap(tag);
                 (void)Mat_int32Swap(tag+1);
             }
             matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);
             if ( tag[0] & 0xffff0000 ) { /* Data is packed in the tag */
                 (void)fseek((FILE*)mat->fp,-4,SEEK_CUR);
             }
             ReadDataSlab1(mat,complex_data->Im,matvar->class_type,
                           matvar->data_type,start,stride,edge);
         } else {
             ReadDataSlab1(mat,data,matvar->class_type,
                           matvar->data_type,start,stride,edge);
         }
 #if HAVE_ZLIB
     } else if ( matvar->compression == MAT_COMPRESSION_ZLIB ) {
         if ( matvar->isComplex ) {
             mat_complex_split_t *complex_data = (mat_complex_split_t*)data;
 
             ReadCompressedDataSlab1(mat,&z,complex_data->Re,
                 matvar->class_type,matvar->data_type,start,stride,edge);
 
             (void)fseek((FILE*)mat->fp,matvar->internal->datapos,SEEK_SET);
 
             /* Reset zlib knowledge to before reading real tag */
             inflateEnd(&z);
-            err = inflateCopy(&z,matvar->internal->z);
+            err = inflateCopy(&z, matvar->internal->z);
             if ( err != Z_OK ) {
                 Mat_Critical("inflateCopy returned error %s",zError(err));
+                return err;
             }
-            InflateSkip(mat,&z,real_bytes);
+            InflateSkip(mat, &z, real_bytes, NULL);
             z.avail_in = 0;
-            InflateDataType(mat,&z,tag);
+            err = Inflate(mat, &z, tag, 4, NULL);
+            if ( 0 != err ) {
+                return err;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_int32Swap(tag);
             }
             matvar->data_type = (enum matio_types)(tag[0] & 0x000000ff);
             if ( !(tag[0] & 0xffff0000) ) {/*Data is NOT packed in the tag*/
-                InflateSkip(mat,&z,4);
+                InflateSkip(mat, &z, 4, NULL);
             }
             ReadCompressedDataSlab1(mat,&z,complex_data->Im,
                 matvar->class_type,matvar->data_type,start,stride,edge);
         } else {
             ReadCompressedDataSlab1(mat,&z,data,matvar->class_type,
                 matvar->data_type,start,stride,edge);
         }
         inflateEnd(&z);
 #endif
     }
 
     matvar->data_type = ClassType2DataType(matvar->class_type);
     matvar->data_size = Mat_SizeOfClass(matvar->class_type);
 
     return err;
 }
 
 /** @if mat_devman
  * @brief Writes a matlab variable to a version 5 matlab file
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar pointer to the mat variable
  * @param compress option to compress the variable
  *                 (only works for numeric types)
  * @retval 0 on success
  * @endif
  */
@@ -4846,312 +5025,344 @@ matvar_t *
 Mat_VarReadNextInfo5( mat_t *mat )
 {
     int err;
     mat_int32_t data_type, nBytes;
     long fpos;
     matvar_t *matvar = NULL;
     mat_uint32_t array_flags;
 
     if ( mat == NULL )
         return NULL;
 
     fpos = ftell((FILE*)mat->fp);
     if ( fpos == -1L ) {
         Mat_Critical("Couldn't determine file position");
         return NULL;
     }
-    err = fread(&data_type,4,1,(FILE*)mat->fp);
-    if ( err == 0 )
-        return NULL;
-    err = fread(&nBytes,4,1,(FILE*)mat->fp);
-    if ( err == 0 )
+    {
+        size_t nbytes = 0;
+        err = Read(&data_type, 4, 1, (FILE*)mat->fp, &nbytes);
+        if ( 0 != err || 0 == nbytes )
+            return NULL;
+    }
+    err = Read(&nBytes, 4, 1, (FILE*)mat->fp, NULL);
+    if ( 0 != err )
         return NULL;
     if ( mat->byteswap ) {
         (void)Mat_int32Swap(&data_type);
         (void)Mat_int32Swap(&nBytes);
     }
     if ( nBytes > INT32_MAX - 8 - fpos )
         return NULL;
     switch ( data_type ) {
         case MAT_T_COMPRESSED:
         {
 #if HAVE_ZLIB
             mat_uint32_t uncomp_buf[16] = {0,};
-            int      nbytes;
-            long     bytesread = 0;
+            int nbytes;
+            size_t bytesread = 0;
 
             matvar = Mat_VarCalloc();
             if ( NULL == matvar ) {
                 Mat_Critical("Couldn't allocate memory");
                 break;
             }
 
             matvar->compression = MAT_COMPRESSION_ZLIB;
             matvar->internal->z = (z_streamp)calloc(1,sizeof(z_stream));
             err = inflateInit(matvar->internal->z);
             if ( err != Z_OK ) {
                 Mat_VarFree(matvar);
                 matvar = NULL;
                 Mat_Critical("inflateInit returned %s",zError(err));
                 break;
             }
 
             /* Read variable tag */
-            bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+            err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+1);
             }
             nbytes = uncomp_buf[1];
             if ( uncomp_buf[0] != MAT_T_MATRIX ) {
                 (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);
                 Mat_VarFree(matvar);
                 matvar = NULL;
                 Mat_Critical("Uncompressed type not MAT_T_MATRIX");
                 break;
             }
             /* Array flags */
-            bytesread += InflateArrayFlags(mat,matvar,uncomp_buf);
+            err = Inflate(mat, matvar->internal->z, uncomp_buf, 16, &bytesread);
+            if ( 0 != err ) {
+                Mat_VarFree(matvar);
+                matvar = NULL;
+                break;
+            }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(uncomp_buf);
                 (void)Mat_uint32Swap(uncomp_buf+2);
                 (void)Mat_uint32Swap(uncomp_buf+3);
             }
             /* Array flags */
             if ( uncomp_buf[0] == MAT_T_UINT32 ) {
                 array_flags = uncomp_buf[2];
                 matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                 matvar->isComplex  = (array_flags & MAT_F_COMPLEX);
                 matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);
                 matvar->isLogical  = (array_flags & MAT_F_LOGICAL);
                 if ( matvar->class_type == MAT_C_SPARSE ) {
                     /* Need to find a more appropriate place to store nzmax */
                     matvar->nbytes = uncomp_buf[3];
                 }
             }
             if ( matvar->class_type != MAT_C_OPAQUE ) {
                 mat_uint32_t* dims = NULL;
                 int do_clean = 0;
-                bytesread += InflateRankDims(mat,matvar,uncomp_buf,sizeof(uncomp_buf),&dims);
-                if ( NULL == dims )
+                err = InflateRankDims(mat, matvar->internal->z, uncomp_buf, sizeof(uncomp_buf), &dims, &bytesread);
+                if ( NULL == dims ) {
                     dims = uncomp_buf + 2;
-                else
+                } else {
                     do_clean = 1;
+                }
+                if ( 0 != err ) {
+                    if ( do_clean ) {
+                        free(dims);
+                    }
+                    Mat_VarFree(matvar);
+                    matvar = NULL;
+                    break;
+                }
                 if ( mat->byteswap ) {
                     (void)Mat_uint32Swap(uncomp_buf);
                     (void)Mat_uint32Swap(uncomp_buf+1);
                 }
                 /* Rank and dimension */
                 if ( uncomp_buf[0] == MAT_T_INT32 ) {
                     int j;
                     size_t size;
                     nbytes = uncomp_buf[1];
                     matvar->rank = nbytes / 4;
                     if ( 0 == do_clean && matvar->rank > 13 ) {
                         int rank = matvar->rank;
                         matvar->rank = 0;
                         Mat_Critical("%d is not a valid rank", rank);
                         break;
                     }
-                    err = SafeMul(&size, matvar->rank, sizeof(*matvar->dims));
+                    err = Mul(&size, matvar->rank, sizeof(*matvar->dims));
                     if ( err ) {
-                        if ( do_clean )
+                        if ( do_clean ) {
                             free(dims);
+                        }
                         (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);
                         Mat_VarFree(matvar);
                         matvar = NULL;
                         Mat_Critical("Integer multiplication overflow");
                         break;
                     }
                     matvar->dims = (size_t*)malloc(size);
                     if ( NULL == matvar->dims ) {
                         if ( do_clean )
                             free(dims);
                         (void)fseek((FILE*)mat->fp,nBytes-bytesread,SEEK_CUR);
                         Mat_VarFree(matvar);
                         matvar = NULL;
                         Mat_Critical("Couldn't allocate memory");
                         break;
                     }
                     if ( mat->byteswap ) {
                         for ( j = 0; j < matvar->rank; j++ )
                             matvar->dims[j] = Mat_uint32Swap(dims + j);
                     } else {
                         for ( j = 0; j < matvar->rank; j++ )
                             matvar->dims[j] = dims[j];
                     }
                 }
-                if ( do_clean )
+                if ( do_clean ) {
                     free(dims);
+                }
                 /* Variable name tag */
-                bytesread += InflateVarTag(mat,matvar,uncomp_buf);
+                err = Inflate(mat, matvar->internal->z, uncomp_buf, 8, &bytesread);
+                if ( 0 != err ) {
+                    Mat_VarFree(matvar);
+                    matvar = NULL;
+                    break;
+                }
                 if ( mat->byteswap )
                     (void)Mat_uint32Swap(uncomp_buf);
                 /* Name of variable */
                 if ( uncomp_buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
                     mat_uint32_t len, len_pad;
                     if ( mat->byteswap )
                         len = Mat_uint32Swap(uncomp_buf+1);
                     else
                         len = uncomp_buf[1];
 
                     if ( len % 8 == 0 )
                         len_pad = len;
                     else if ( len < UINT32_MAX - 8 + (len % 8) )
                         len_pad = len + 8 - (len % 8);
                     else {
                         Mat_VarFree(matvar);
                         matvar = NULL;
                         break;
                     }
                     matvar->name = (char*)malloc(len_pad + 1);
                     if ( NULL != matvar->name ) {
                         /* Variable name */
-                        bytesread += InflateVarName(mat,matvar,matvar->name,len_pad);
+                        err = Inflate(mat, matvar->internal->z, matvar->name, len_pad, &bytesread);
+                        if ( 0 != err )  {
+                            Mat_VarFree(matvar);
+                            matvar = NULL;
+                            break;
+                        }
                         matvar->name[len] = '\0';
                     }
                 } else {
                     mat_uint32_t len = (uncomp_buf[0] & 0xffff0000) >> 16;
                     if ( ((uncomp_buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                         /* Name packed in tag */
                         matvar->name = (char*)malloc(len+1);
                         if ( NULL != matvar->name ) {
                             memcpy(matvar->name,uncomp_buf+1,len);
                             matvar->name[len] = '\0';
                         }
                     }
                 }
                 if ( matvar->class_type == MAT_C_STRUCT )
                     (void)ReadNextStructField(mat,matvar);
                 else if ( matvar->class_type == MAT_C_CELL )
                     (void)ReadNextCell(mat,matvar);
                 (void)fseek((FILE*)mat->fp,-(int)matvar->internal->z->avail_in,SEEK_CUR);
                 matvar->internal->datapos = ftell((FILE*)mat->fp);
                 if ( matvar->internal->datapos == -1L ) {
                     Mat_Critical("Couldn't determine file position");
                 }
             }
             (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
             break;
 #else
             Mat_Critical("Compressed variable found in \"%s\", but matio was "
                          "built without zlib support",mat->filename);
             (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
             return NULL;
 #endif
         }
         case MAT_T_MATRIX:
         {
             mat_uint32_t buf[6];
-            size_t readresult;
 
             /* Read array flags and the dimensions tag */
-            readresult = fread(buf, 4, 6, (FILE*)mat->fp);
-            if ( 6 != readresult ) {
+            err = Read(buf, 4, 6, (FILE*)mat->fp, NULL);
+            if ( 0 != err ) {
                 (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                 break;
             }
             if ( mat->byteswap ) {
                 (void)Mat_uint32Swap(buf);
                 (void)Mat_uint32Swap(buf+1);
                 (void)Mat_uint32Swap(buf+2);
                 (void)Mat_uint32Swap(buf+3);
                 (void)Mat_uint32Swap(buf+4);
                 (void)Mat_uint32Swap(buf+5);
             }
 
             matvar = Mat_VarCalloc();
             if ( NULL == matvar ) {
                 Mat_Critical("Couldn't allocate memory");
                 break;
             }
 
             /* Array flags */
             if ( buf[0] == MAT_T_UINT32 ) {
                array_flags = buf[2];
                matvar->class_type = CLASS_FROM_ARRAY_FLAGS(array_flags);
                matvar->isComplex  = (array_flags & MAT_F_COMPLEX);
                matvar->isGlobal   = (array_flags & MAT_F_GLOBAL);
                matvar->isLogical  = (array_flags & MAT_F_LOGICAL);
                if ( matvar->class_type == MAT_C_SPARSE ) {
                    /* Need to find a more appropriate place to store nzmax */
                    matvar->nbytes = buf[3];
                }
             }
-            readresult = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5]);
-            if ( 0 == readresult && 0 < matvar->rank ) {
-                Mat_VarFree(matvar);
-                matvar = NULL;
-                (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
-                break;
+            /* Rank and dimension */
+            {
+                size_t nbytes = 0;
+                err = ReadRankDims(mat, matvar, (enum matio_types)buf[4], buf[5], &nbytes);
+                if ( 0 == nbytes && 0 < matvar->rank ) {
+                    Mat_VarFree(matvar);
+                    matvar = NULL;
+                    (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
+                    break;
+                }
             }
             /* Variable name tag */
-            readresult = fread(buf, 4, 2, (FILE*)mat->fp);
-            if ( 2 != readresult ) {
+            err = Read(buf, 4, 2, (FILE*)mat->fp, NULL);
+            if ( 0 != err ) {
                 Mat_VarFree(matvar);
                 matvar = NULL;
                 (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                 break;
             }
             if ( mat->byteswap )
                 (void)Mat_uint32Swap(buf);
             /* Name of variable */
             if ( buf[0] == MAT_T_INT8 ) {    /* Name not in tag */
                 mat_uint32_t len, len_pad;
                 if ( mat->byteswap )
                     len = Mat_uint32Swap(buf+1);
                 else
                     len = buf[1];
                 if ( len % 8 == 0 )
                     len_pad = len;
                 else if ( len < UINT32_MAX - 8 + (len % 8) )
                     len_pad = len + 8 - (len % 8);
                 else {
                     Mat_VarFree(matvar);
                     matvar = NULL;
                     (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                     break;
                 }
                 matvar->name = (char*)malloc(len_pad + 1);
                 if ( NULL != matvar->name ) {
-                    readresult = fread(matvar->name, 1, len_pad, (FILE*)mat->fp);
-                    if ( readresult == len_pad ) {
+                    err = Read(matvar->name, 1, len_pad, (FILE*)mat->fp, NULL);
+                    if ( 0 == err ) {
                         matvar->name[len] = '\0';
                     } else {
                         Mat_VarFree(matvar);
                         matvar = NULL;
                         (void)fseek((FILE*)mat->fp, fpos, SEEK_SET);
                         break;
                     }
                 }
             } else {
                 mat_uint32_t len = (buf[0] & 0xffff0000) >> 16;
                 if ( ((buf[0] & 0x0000ffff) == MAT_T_INT8) && len > 0 && len <= 4 ) {
                     /* Name packed in tag */
                     matvar->name = (char*)malloc(len+1);
                     if ( NULL != matvar->name ) {
                         memcpy(matvar->name, buf+1, len);
                         matvar->name[len] = '\0';
                     }
                 }
             }
             if ( matvar->class_type == MAT_C_STRUCT )
                 (void)ReadNextStructField(mat,matvar);
             else if ( matvar->class_type == MAT_C_CELL )
                 (void)ReadNextCell(mat,matvar);
             else if ( matvar->class_type == MAT_C_FUNCTION )
                 (void)ReadNextFunctionHandle(mat,matvar);
             matvar->internal->datapos = ftell((FILE*)mat->fp);
             if ( matvar->internal->datapos == -1L ) {
                 Mat_Critical("Couldn't determine file position");
             }
             (void)fseek((FILE*)mat->fp,nBytes+8+fpos,SEEK_SET);
             break;
         }
         default:
             Mat_Critical("%d is not valid (MAT_T_MATRIX or MAT_T_COMPRESSED)",
                          data_type);
             return NULL;
     }
 
     return matvar;
 }
diff --git a/src/mat73.c b/src/mat73.c
index c67f9b6..981cce4 100644
--- a/src/mat73.c
+++ b/src/mat73.c
@@ -542,70 +542,70 @@ static size_t*
 Mat_H5ReadDims(hid_t dset_id, hsize_t *nelems, int *rank)
 {
     hid_t space_id;
     size_t* perm_dims;
 
     *nelems = 0;
     space_id = H5Dget_space(dset_id);
     *rank = H5Sget_simple_extent_ndims(space_id);
     if ( 0 > *rank ) {
         *rank = 0;
         H5Sclose(space_id);
         return NULL;
     }
     perm_dims = (size_t*)malloc(*rank*sizeof(*perm_dims));
     if ( NULL != perm_dims ) {
         int err = 0;
         if ( MAX_RANK >= *rank ) {
             hsize_t dims[MAX_RANK];
             int k;
             size_t tmp = 1;
             (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
             /* Permute dimensions */
             for ( k = 0; k < *rank; k++ ) {
                 perm_dims[k] = (size_t)dims[*rank - k - 1];
-                err |= SafeMul(&tmp, tmp, perm_dims[k]);
+                err |= Mul(&tmp, tmp, perm_dims[k]);
             }
             if ( err ) {
                 Mat_Critical("Integer multiplication overflow");
                 free(perm_dims);
                 perm_dims = NULL;
                 *rank = 0;
             }
             *nelems = (hsize_t)tmp;
             H5Sclose(space_id);
         } else {
             hsize_t* dims = (hsize_t*)malloc(*rank*sizeof(hsize_t));
             if ( NULL != dims ) {
                 int k;
                 size_t tmp = 1;
                 (void)H5Sget_simple_extent_dims(space_id,dims,NULL);
                 /* Permute dimensions */
                 for ( k = 0; k < *rank; k++ ) {
                     perm_dims[k] = (size_t)dims[*rank - k - 1];
-                    err |= SafeMul(&tmp, tmp, perm_dims[k]);
+                    err |= Mul(&tmp, tmp, perm_dims[k]);
                 }
                 if ( err ) {
                     Mat_Critical("Integer multiplication overflow");
                     free(perm_dims);
                     perm_dims = NULL;
                     *rank = 0;
                 }
                 *nelems = (hsize_t)tmp;
                 free(dims);
                 H5Sclose(space_id);
             } else {
                 free(perm_dims);
                 perm_dims = NULL;
                 *rank = 0;
                 H5Sclose(space_id);
                 Mat_Critical("Error allocating memory for dims");
             }
         }
     } else {
         *rank = 0;
         H5Sclose(space_id);
         Mat_Critical("Error allocating memory for matvar->dims");
     }
 
     return perm_dims;
 }
@@ -649,84 +649,84 @@ static void
 Mat_H5ReadDatasetInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)
 {
     int err = 0;
     hid_t   attr_id,type_id;
     hsize_t nelems;
 
     Mat_H5ReadVarInfo(matvar, dset_id);
 
     matvar->dims = Mat_H5ReadDims(dset_id, &nelems, &matvar->rank);
     if ( NULL == matvar->dims ) {
         return;
     }
 
     /* Check for attribute that indicates an empty array */
     if ( H5Aexists_by_name(dset_id,".","MATLAB_empty",H5P_DEFAULT) ) {
         int empty = 0;
         attr_id = H5Aopen_by_name(dset_id,".","MATLAB_empty",H5P_DEFAULT,H5P_DEFAULT);
         /* FIXME: Check that dataspace is scalar */
         H5Aread(attr_id,H5T_NATIVE_INT,&empty);
         H5Aclose(attr_id);
         if ( empty ) {
             matvar->rank = matvar->dims[0];
             free(matvar->dims);
             matvar->dims = (size_t*)calloc(matvar->rank,sizeof(*matvar->dims));
             H5Dread(dset_id,SizeType2H5T(),H5S_ALL,H5S_ALL,H5P_DEFAULT,matvar->dims);
             {
                 size_t tmp = 1;
-                err = SafeMulDims(matvar, &tmp);
+                err = MulDims(matvar, &tmp);
                 nelems = (hsize_t)tmp;
             }
         }
     }
 
     /* Test if dataset type is compound and if so if it's complex */
     type_id = H5Dget_type(dset_id);
     if ( H5T_COMPOUND == H5Tget_class(type_id) ) {
         /* FIXME: Any more checks? */
         matvar->isComplex = MAT_F_COMPLEX;
     }
     H5Tclose(type_id);
 
     /* If the dataset is a cell array read the info of the cells */
     if ( MAT_C_CELL == matvar->class_type ) {
         matvar_t **cells;
         hobj_ref_t *ref_ids;
 
         matvar->data_size = sizeof(matvar_t**);
-        err |= SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+        err |= Mul(&matvar->nbytes, nelems, matvar->data_size);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             return;
         }
         matvar->data = malloc(matvar->nbytes);
         if ( NULL == matvar->data ) {
             Mat_Critical("Couldn't allocate memory for the data");
             return;
         }
         cells = (matvar_t**)matvar->data;
 
         if ( nelems ) {
             size_t i;
             ref_ids = (hobj_ref_t*)malloc(nelems*sizeof(*ref_ids));
             H5Dread(dset_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,H5P_DEFAULT,ref_ids);
             for ( i = 0; i < nelems; i++ ) {
                 hid_t ref_id;
                 cells[i] = Mat_VarCalloc();
                 cells[i]->internal->hdf5_ref = ref_ids[i];
                 /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
                 ref_id = H5RDEREFERENCE(dset_id,H5R_OBJECT,ref_ids+i);
                 cells[i]->internal->id = ref_id;
                 Mat_H5ReadNextReferenceInfo(ref_id,cells[i],mat);
             }
             free(ref_ids);
         }
     } else if ( MAT_C_STRUCT == matvar->class_type ) {
         /* Empty structures can be a dataset */
 
         /* Check if the structure defines its fields in MATLAB_fields */
         if ( H5Aexists_by_name(dset_id,".","MATLAB_fields",H5P_DEFAULT) ) {
             hsize_t nfields;
             Mat_H5ReadFieldNames(matvar, dset_id, &nfields);
         }
     }
 }
@@ -735,219 +735,219 @@ static void
 Mat_H5ReadGroupInfo(mat_t *mat,matvar_t *matvar,hid_t dset_id)
 {
     int      fields_are_variables = 1;
     hsize_t  nfields=0,nelems;
     hid_t    attr_id,field_id;
     matvar_t **fields;
     H5O_type_t obj_type;
 
     Mat_H5ReadVarInfo(matvar,dset_id);
 
     /* Check if the variable is sparse */
     if ( H5Aexists_by_name(dset_id,".","MATLAB_sparse",H5P_DEFAULT) ) {
         hid_t sparse_dset_id;
         unsigned nrows = 0;
 
         attr_id = H5Aopen_by_name(dset_id,".","MATLAB_sparse",H5P_DEFAULT,H5P_DEFAULT);
         H5Aread(attr_id,H5T_NATIVE_UINT,&nrows);
         H5Aclose(attr_id);
 
         matvar->class_type = MAT_C_SPARSE;
 
         sparse_dset_id = H5Dopen(dset_id,"jc",H5P_DEFAULT);
         matvar->dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &matvar->rank);
         H5Dclose(sparse_dset_id);
         if ( NULL != matvar->dims ) {
             if ( 1 == matvar->rank ) {
                 size_t* dims = (size_t*)realloc(matvar->dims, 2*sizeof(*matvar->dims));
                 if ( NULL != dims ) {
                     matvar->rank = 2;
                     matvar->dims = dims;
                 }
             }
             if ( 2 == matvar->rank ) {
                 matvar->dims[1] = matvar->dims[0] - 1;
                 matvar->dims[0] = nrows;
             }
         } else {
             return;
         }
 
         /* Test if dataset type is compound and if so if it's complex */
         if ( H5Lexists(dset_id,"data",H5P_DEFAULT) ) {
             hid_t type_id;
             sparse_dset_id = H5Dopen(dset_id,"data",H5P_DEFAULT);
             type_id = H5Dget_type(sparse_dset_id);
             if ( H5T_COMPOUND == H5Tget_class(type_id) ) {
                 /* FIXME: Any more checks? */
                 matvar->isComplex = MAT_F_COMPLEX;
             }
             H5Tclose(type_id);
             H5Dclose(sparse_dset_id);
         }
         return;
     }
 
     /* Check if the structure defines its fields in MATLAB_fields */
     if ( H5Aexists_by_name(dset_id,".","MATLAB_fields",H5P_DEFAULT) ) {
         Mat_H5ReadFieldNames(matvar, dset_id, &nfields);
     } else {
         H5G_info_t group_info;
         matvar->internal->num_fields = 0;
         H5Gget_info(dset_id, &group_info);
         if ( group_info.nlinks > 0 ) {
             struct ReadGroupInfoIterData group_data = {0, NULL};
             herr_t herr;
 
             /* First iteration to retrieve number of relevant links */
             herr = H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,
                 H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,
                 (void *)&group_data, H5P_DEFAULT);
             if ( herr > 0 && group_data.nfields > 0 ) {
                 matvar->internal->fieldnames =
                     (char**)calloc((size_t)(group_data.nfields),sizeof(*matvar->internal->fieldnames));
                 group_data.nfields = 0;
                 group_data.matvar = matvar;
                 if ( matvar->internal->fieldnames != NULL ) {
                     /* Second iteration to fill fieldnames */
                     H5Literate_by_name(dset_id, matvar->internal->hdf5_name, H5_INDEX_NAME,
                         H5_ITER_NATIVE, NULL, Mat_H5ReadGroupInfoIterate,
                         (void *)&group_data, H5P_DEFAULT);
                 }
                 matvar->internal->num_fields = (unsigned)group_data.nfields;
                 nfields = group_data.nfields;
             }
         }
     }
 
     if ( nfields > 0 ) {
         H5O_INFO_T object_info;
         H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[0], &object_info, H5P_DEFAULT);
         obj_type = object_info.type;
     } else {
         obj_type = H5O_TYPE_UNKNOWN;
     }
     if ( obj_type == H5O_TYPE_DATASET ) {
         hid_t field_type_id;
         field_id = H5Dopen(dset_id,matvar->internal->fieldnames[0],H5P_DEFAULT);
         field_type_id = H5Dget_type(field_id);
         if ( H5T_REFERENCE == H5Tget_class(field_type_id) ) {
             /* Check if the field has the MATLAB_class attribute. If so, it
              * means the structure is a scalar. Otherwise, the dimensions of
              * the field dataset is the dimensions of the structure
              */
             if ( H5Aexists_by_name(field_id,".","MATLAB_class",H5P_DEFAULT) ) {
                 matvar->rank = 2;
                 matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));
                 if ( NULL != matvar->dims ) {
                     matvar->dims[0] = 1;
                     matvar->dims[1] = 1;
                     nelems = 1;
                 } else {
                     H5Tclose(field_type_id);
                     H5Dclose(field_id);
                     Mat_Critical("Error allocating memory for matvar->dims");
                     return;
                 }
             } else {
                 matvar->dims = Mat_H5ReadDims(field_id, &nelems, &matvar->rank);
                 if ( NULL != matvar->dims ) {
                     fields_are_variables = 0;
                 } else {
                     H5Tclose(field_type_id);
                     H5Dclose(field_id);
                     return;
                 }
             }
         } else {
             /* Structure should be a scalar */
             matvar->rank = 2;
             matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));
             if ( NULL != matvar->dims ) {
                 matvar->dims[0] = 1;
                 matvar->dims[1] = 1;
                 nelems = 1;
             } else {
                 H5Tclose(field_type_id);
                 H5Dclose(field_id);
                 Mat_Critical("Error allocating memory for matvar->dims");
                 return;
             }
         }
         H5Tclose(field_type_id);
         H5Dclose(field_id);
     } else {
         /* Structure should be a scalar */
         matvar->rank = 2;
         matvar->dims = (size_t*)malloc(2*sizeof(*matvar->dims));
         if ( NULL != matvar->dims ) {
             matvar->dims[0] = 1;
             matvar->dims[1] = 1;
             nelems = 1;
         } else {
             Mat_Critical("Error allocating memory for matvar->dims");
             return;
         }
     }
 
     if ( nelems < 1 || nfields < 1 )
         return;
 
     matvar->data_size = sizeof(*fields);
     {
         int err;
         size_t nelems_x_nfields;
-        err = SafeMul(&nelems_x_nfields, nelems, nfields);
-        err |= SafeMul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
+        err = Mul(&nelems_x_nfields, nelems, nfields);
+        err |= Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
         if ( err ) {
             Mat_Critical("Integer multiplication overflow");
             matvar->nbytes = 0;
             return;
         }
     }
     fields = (matvar_t**)malloc(matvar->nbytes);
     matvar->data = fields;
     if ( NULL != fields ) {
         int k;
         for ( k = 0; k < nfields; k++ ) {
             H5O_INFO_T object_info;
             fields[k] = NULL;
             H5OGET_INFO_BY_NAME(dset_id, matvar->internal->fieldnames[k], &object_info, H5P_DEFAULT);
             if ( object_info.type == H5O_TYPE_DATASET ) {
                 field_id = H5Dopen(dset_id,matvar->internal->fieldnames[k],
                                    H5P_DEFAULT);
                 if ( !fields_are_variables ) {
                     int l;
                     hobj_ref_t *ref_ids = (hobj_ref_t*)malloc((size_t)nelems*sizeof(*ref_ids));
                     H5Dread(field_id,H5T_STD_REF_OBJ,H5S_ALL,H5S_ALL,
                             H5P_DEFAULT,ref_ids);
                     for ( l = 0; l < nelems; l++ ) {
                         hid_t ref_id;
                         fields[l*nfields+k] = Mat_VarCalloc();
                         fields[l*nfields+k]->name =
                             strdup(matvar->internal->fieldnames[k]);
                         fields[l*nfields+k]->internal->hdf5_ref=ref_ids[l];
                         /* Closing of ref_id is done in Mat_H5ReadNextReferenceInfo */
                         ref_id = H5RDEREFERENCE(field_id,H5R_OBJECT,ref_ids+l);
                         fields[l*nfields+k]->internal->id = ref_id;
                         Mat_H5ReadNextReferenceInfo(ref_id,fields[l*nfields+k],mat);
                     }
                     free(ref_ids);
                 } else {
                     fields[k] = Mat_VarCalloc();
                     fields[k]->name = strdup(matvar->internal->fieldnames[k]);
                     Mat_H5ReadDatasetInfo(mat,fields[k],field_id);
                 }
                 H5Dclose(field_id);
             } else if ( object_info.type == H5O_TYPE_GROUP ) {
                 field_id = H5Gopen(dset_id,matvar->internal->fieldnames[k],
                                    H5P_DEFAULT);
                 if ( -1 < field_id ) {
                     fields[k] = Mat_VarCalloc();
                     fields[k]->name = strdup(matvar->internal->fieldnames[k]);
                     Mat_H5ReadGroupInfo(mat,fields[k],field_id);
                     H5Gclose(field_id);
                 }
             }
         }
     }
 }
@@ -1046,89 +1046,89 @@ static void
 Mat_H5ReadNextReferenceData(hid_t ref_id,matvar_t *matvar,mat_t *mat)
 {
     size_t nelems = 1;
 
     if ( ref_id < 0 || matvar == NULL )
         return;
 
     /* If the datatype with references is a cell, we've already read info into
      * the variable data, so just loop over each cell element and call
      * Mat_H5ReadNextReferenceData on it.
      */
     if ( MAT_C_CELL == matvar->class_type ) {
         size_t i;
         matvar_t **cells = (matvar_t**)matvar->data;
-        SafeMulDims(matvar, &nelems);
+        MulDims(matvar, &nelems);
         for ( i = 0; i < nelems; i++ )
             Mat_H5ReadNextReferenceData(cells[i]->internal->id,cells[i],mat);
         return;
     }
 
     switch ( H5Iget_type(ref_id) ) {
         case H5I_DATASET:
         {
             int err;
             hid_t data_type_id, dset_id;
             if ( MAT_C_CHAR == matvar->class_type ) {
                 matvar->data_type = MAT_T_UINT8;
                 matvar->data_size = Mat_SizeOf(MAT_T_UINT8);
                 data_type_id      = DataType2H5T(MAT_T_UINT8);
             } else if ( MAT_C_STRUCT == matvar->class_type ) {
                 /* Empty structure array */
                 break;
             } else {
                 matvar->data_size = Mat_SizeOfClass(matvar->class_type);
                 data_type_id      = ClassType2H5T(matvar->class_type);
             }
 
-            err = SafeMulDims(matvar, &nelems);
-            err |= SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+            err = MulDims(matvar, &nelems);
+            err |= Mul(&matvar->nbytes, nelems, matvar->data_size);
             if ( err || matvar->nbytes < 1 ) {
                 H5Dclose(ref_id);
                 break;
             }
 
             dset_id = ref_id;
 
             if ( !matvar->isComplex ) {
                 matvar->data = malloc(matvar->nbytes);
             } else {
                 matvar->data = ComplexMalloc(matvar->nbytes);
             }
             if ( NULL != matvar->data ) {
                 Mat_H5ReadData(dset_id, data_type_id,
                     H5S_ALL, H5S_ALL, matvar->isComplex, matvar->data);
             }
             H5Dclose(dset_id);
             break;
         }
         case H5I_GROUP:
         {
             if ( MAT_C_SPARSE == matvar->class_type ) {
                 Mat_VarRead73(mat,matvar);
             } else {
                 matvar_t **fields;
                 size_t i;
 
                 if ( !matvar->nbytes || !matvar->data_size || NULL == matvar->data )
                     break;
                 nelems = matvar->nbytes / matvar->data_size;
                 fields  = (matvar_t**)matvar->data;
                 for ( i = 0; i < nelems; i++ ) {
                     if ( NULL != fields[i] &&
                           0 < fields[i]->internal->hdf5_ref &&
                          -1 < fields[i]->internal->id ) {
                         /* Dataset of references */
                         Mat_H5ReadNextReferenceData(fields[i]->internal->id,fields[i],mat);
                     } else {
                         Mat_VarRead73(mat,fields[i]);
                     }
                 }
             }
             break;
         }
         default:
             break;
     }
 
     return;
 }
@@ -1858,140 +1858,140 @@ static int
 Mat_VarWriteStruct73(hid_t id,matvar_t *matvar,const char *name,hid_t *refs_id,hsize_t *dims,hsize_t* max_dims)
 {
     int     err;
     hsize_t nelems;
 
     {
         size_t tmp = 1;
-        err = SafeMulDims(matvar, &tmp);
+        err = MulDims(matvar, &tmp);
         nelems = (hsize_t)tmp;
     }
 
     if ( err || 0 == nelems || NULL == matvar->data ) {
         err = Mat_VarWriteEmpty(id, matvar, name, ClassNames[matvar->class_type]);
     } else {
         hid_t struct_id = H5Gcreate(id,name,H5P_DEFAULT,H5P_DEFAULT,H5P_DEFAULT);
         if ( struct_id < 0 ) {
             Mat_Critical("Error creating group for struct %s",name);
             err = -1;
         } else {
             hid_t attr_id,aspace_id;
             hid_t str_type_id,fieldnames_id;
             matvar_t **fields = (matvar_t**)matvar->data;
             hvl_t     *fieldnames;
             hsize_t    nfields = matvar->internal->num_fields, k;
 
             str_type_id = H5Tcopy(H5T_C_S1);
             H5Tset_size(str_type_id,6);
             aspace_id = H5Screate(H5S_SCALAR);
             attr_id = H5Acreate(struct_id,"MATLAB_class",str_type_id,
                                 aspace_id,H5P_DEFAULT,H5P_DEFAULT);
             if ( 0 > H5Awrite(attr_id,str_type_id,"struct") )
                 err = 5;
             H5Aclose(attr_id);
             H5Sclose(aspace_id);
 
             /* Structure with no fields */
             if ( nfields == 0 ) {
                 H5Gclose(struct_id);
                 H5Tclose(str_type_id);
                 return err;
             }
 
             fieldnames = (hvl_t*)malloc((size_t)nfields*sizeof(*fieldnames));
             for ( k = 0; k < nfields; k++ ) {
                 fieldnames[k].len =
                     strlen(matvar->internal->fieldnames[k]);
                 fieldnames[k].p   = matvar->internal->fieldnames[k];
             }
             H5Tset_size(str_type_id,1);
             fieldnames_id = H5Tvlen_create(str_type_id);
             aspace_id     = H5Screate_simple(1,&nfields,NULL);
             attr_id = H5Acreate(struct_id,"MATLAB_fields",fieldnames_id,
                                 aspace_id,H5P_DEFAULT,H5P_DEFAULT);
             if ( 0 > H5Awrite(attr_id,fieldnames_id,fieldnames) )
                 err += 5;
             H5Aclose(attr_id);
             H5Sclose(aspace_id);
             H5Tclose(fieldnames_id);
             H5Tclose(str_type_id);
             free(fieldnames);
 
             if ( 1 == nelems && NULL == max_dims ) {
                 for ( k = 0; k < nfields; k++ ) {
                     if ( NULL != fields[k] )
                         fields[k]->compression = matvar->compression;
                     if ( 0 != Mat_VarWriteNext73(struct_id,fields[k],
                         matvar->internal->fieldnames[k],refs_id) )
                         err += 5;
                 }
             } else {
                 if ( *refs_id < 0 ) {
                     if ( H5Lexists(id,"/#refs#",H5P_DEFAULT) ) {
                         *refs_id = H5Gopen(id,"/#refs#",H5P_DEFAULT);
                     } else {
                         *refs_id = H5Gcreate(id,"/#refs#",H5P_DEFAULT,
                                              H5P_DEFAULT,H5P_DEFAULT);
                     }
                 }
                 if ( *refs_id > -1 ) {
                     hobj_ref_t **refs;
                     int l;
                     hid_t plist,mspace_id,dset_id;
 
                     refs = (hobj_ref_t**)malloc((size_t)nfields*sizeof(*refs));
                     for ( l = 0; l < nfields; l++ )
                         refs[l] = (hobj_ref_t*)malloc((size_t)nelems*sizeof(*refs[l]));
 
                     for ( k = 0; k < nelems; k++ ) {
                         for ( l = 0; l < nfields; l++ ) {
                             err += Mat_VarWriteRef(id, fields[k*nfields+l], matvar->compression,
                                                    refs_id, refs[l]+k);
                         }
                     }
 
                     if ( NULL != max_dims ) {
                         plist = H5Pcreate(H5P_DATASET_CREATE);
                         if ( MAX_RANK >= matvar->rank ) {
                             hsize_t chunk_dims[MAX_RANK];
                             Mat_H5GetChunkSize(matvar->rank, dims, chunk_dims);
                             H5Pset_chunk(plist, matvar->rank, chunk_dims);
                         } else {
                             hsize_t *chunk_dims = (hsize_t*)malloc(matvar->rank*sizeof(hsize_t));
                             if ( NULL != chunk_dims ) {
                                 Mat_H5GetChunkSize(matvar->rank, dims, chunk_dims);
                                 H5Pset_chunk(plist, matvar->rank, chunk_dims);
                                 free(chunk_dims);
                             } else {
                                 H5Pclose(plist);
                                 plist = H5P_DEFAULT;
                             }
                         }
                     } else {
                         plist = H5P_DEFAULT;
                     }
 
                     mspace_id = H5Screate_simple(matvar->rank,dims,max_dims);
                     for ( l = 0; l < nfields; l++ ) {
                         dset_id = H5Dcreate(struct_id,
                                             matvar->internal->fieldnames[l],
                                             H5T_STD_REF_OBJ,mspace_id,
                                             H5P_DEFAULT,plist,H5P_DEFAULT);
                         err += Mat_H5WriteData(dset_id, H5T_STD_REF_OBJ, H5S_ALL,
                                                H5S_ALL, 0, refs[l]);
                         H5Dclose(dset_id);
                         free(refs[l]);
                     }
                     free(refs);
                     H5Sclose(mspace_id);
                     if ( H5P_DEFAULT != plist )
                         H5Pclose(plist);
                 } else {
                     err = -1;
                 }
             }
             H5Gclose(struct_id);
         }
     }
 
     return err;
 }
@@ -2324,262 +2324,262 @@ int
 Mat_VarRead73(mat_t *mat,matvar_t *matvar)
 {
     int err = 0;
     hid_t fid,dset_id,ref_id;
 
     if ( NULL == mat || NULL == matvar )
         return 1;
     else if ( NULL == matvar->internal->hdf5_name && 0 > matvar->internal->id )
         return 1;
 
     fid = *(hid_t*)mat->fp;
 
     switch ( matvar->class_type ) {
         case MAT_C_DOUBLE:
         case MAT_C_SINGLE:
         case MAT_C_INT64:
         case MAT_C_UINT64:
         case MAT_C_INT32:
         case MAT_C_UINT32:
         case MAT_C_INT16:
         case MAT_C_UINT16:
         case MAT_C_INT8:
         case MAT_C_UINT8:
         {
             size_t nelems = 1;
             matvar->data_size = Mat_SizeOfClass(matvar->class_type);
-            err = SafeMulDims(matvar, &nelems);
-            err |= SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+            err = MulDims(matvar, &nelems);
+            err |= Mul(&matvar->nbytes, nelems, matvar->data_size);
             if ( err ) {
                 Mat_Critical("Integer multiplication overflow");
                 return err;
             }
 
             if ( nelems < 1 )
                 break;
 
             if ( NULL != matvar->internal->hdf5_name ) {
                 ref_id = H5Dopen(fid,matvar->internal->hdf5_name,H5P_DEFAULT);
             } else {
                 ref_id = matvar->internal->id;
                 H5Iinc_ref(ref_id);
             }
             if ( 0 < matvar->internal->hdf5_ref ) {
                 dset_id = H5RDEREFERENCE(ref_id,H5R_OBJECT,&matvar->internal->hdf5_ref);
             } else {
                 dset_id = ref_id;
                 H5Iinc_ref(dset_id);
             }
 
             if ( !matvar->isComplex ) {
                 matvar->data = malloc(matvar->nbytes);
             } else {
                 matvar->data = ComplexMalloc(matvar->nbytes);
             }
             if ( NULL != matvar->data ) {
                 Mat_H5ReadData(dset_id, ClassType2H5T(matvar->class_type),
                     H5S_ALL, H5S_ALL, matvar->isComplex, matvar->data);
             }
             H5Dclose(dset_id);
             H5Dclose(ref_id);
             break;
         }
         case MAT_C_CHAR:
         {
             size_t nelems = 1;
             matvar->data_size = Mat_SizeOf(matvar->data_type);
-            err = SafeMulDims(matvar, &nelems);
-            err |= SafeMul(&matvar->nbytes, nelems, matvar->data_size);
+            err = MulDims(matvar, &nelems);
+            err |= Mul(&matvar->nbytes, nelems, matvar->data_size);
             if ( err ) {
                 Mat_Critical("Integer multiplication overflow");
                 return err;
             }
 
             if ( NULL != matvar->internal->hdf5_name ) {
                 dset_id = H5Dopen(fid,matvar->internal->hdf5_name,H5P_DEFAULT);
             } else {
                 dset_id = matvar->internal->id;
                 H5Iinc_ref(dset_id);
             }
             if ( matvar->nbytes > 0 ) {
                 matvar->data = malloc(matvar->nbytes);
                 if ( NULL != matvar->data ) {
                     H5Dread(dset_id,DataType2H5T(matvar->data_type),
                             H5S_ALL,H5S_ALL,H5P_DEFAULT,matvar->data);
                 }
             }
             H5Dclose(dset_id);
             break;
         }
         case MAT_C_STRUCT:
         {
             matvar_t **fields;
             size_t i, nelems_x_nfields, nelems = 1;
 
             if ( !matvar->internal->num_fields || NULL == matvar->data )
                 break;
 
-            err = SafeMulDims(matvar, &nelems);
-            err |= SafeMul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
+            err = MulDims(matvar, &nelems);
+            err |= Mul(&nelems_x_nfields, nelems, matvar->internal->num_fields);
             if ( err ) {
                 Mat_Critical("Integer multiplication overflow");
                 return err;
             }
 
             fields = (matvar_t**)matvar->data;
             for ( i = 0; i < nelems_x_nfields; i++ ) {
                 if ( NULL != fields[i] &&
                       0 < fields[i]->internal->hdf5_ref &&
                      -1 < fields[i]->internal->id ) {
                     /* Dataset of references */
                     Mat_H5ReadNextReferenceData(fields[i]->internal->id,fields[i],mat);
                 } else {
                     err |= Mat_VarRead73(mat,fields[i]);
                 }
             }
             break;
         }
         case MAT_C_CELL:
         {
             matvar_t **cells;
             size_t i, nelems;
 
             if ( NULL == matvar->data ) {
                 Mat_Critical("Data is NULL for cell array %s", matvar->name);
                 err = 1;
                 break;
             }
             nelems = matvar->nbytes / matvar->data_size;
             cells  = (matvar_t**)matvar->data;
             for ( i = 0; i < nelems; i++ ) {
                 if ( NULL != cells[i] ) {
                     Mat_H5ReadNextReferenceData(cells[i]->internal->id,cells[i],mat);
                 }
             }
             break;
         }
         case MAT_C_SPARSE:
         {
             hid_t sparse_dset_id;
             mat_sparse_t *sparse_data = (mat_sparse_t *)calloc(1,
                 sizeof(*sparse_data));
 
             if ( NULL != matvar->internal->hdf5_name ) {
                 dset_id = H5Gopen(fid,matvar->internal->hdf5_name,H5P_DEFAULT);
             } else {
                 dset_id = matvar->internal->id;
                 H5Iinc_ref(dset_id);
             }
 
             if ( H5Lexists(dset_id,"ir",H5P_DEFAULT) ) {
                 size_t *dims;
                 hsize_t nelems;
                 int rank;
 
                 sparse_dset_id = H5Dopen(dset_id,"ir",H5P_DEFAULT);
                 dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &rank);
                 if ( NULL != dims ) {
                     size_t nbytes;
                     sparse_data->nir = dims[0];
                     free(dims);
-                    err = SafeMul(&nbytes, sparse_data->nir, sizeof(mat_uint32_t));
+                    err = Mul(&nbytes, sparse_data->nir, sizeof(mat_uint32_t));
                     if ( err ) {
                         H5Dclose(sparse_dset_id);
                         H5Gclose(dset_id);
                         free(sparse_data);
                         Mat_Critical("Integer multiplication overflow");
                         return err;
                     }
                     sparse_data->ir = (mat_uint32_t*)malloc(nbytes);
                     H5Dread(sparse_dset_id,H5T_NATIVE_UINT,
                             H5S_ALL,H5S_ALL,H5P_DEFAULT,sparse_data->ir);
                 }
                 H5Dclose(sparse_dset_id);
             }
 
             if ( H5Lexists(dset_id,"jc",H5P_DEFAULT) ) {
                 size_t *dims;
                 hsize_t nelems;
                 int rank;
 
                 sparse_dset_id = H5Dopen(dset_id,"jc",H5P_DEFAULT);
                 dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &rank);
                 if ( NULL != dims ) {
                     size_t nbytes;
                     sparse_data->njc = dims[0];
                     free(dims);
-                    err = SafeMul(&nbytes, sparse_data->njc, sizeof(mat_uint32_t));
+                    err = Mul(&nbytes, sparse_data->njc, sizeof(mat_uint32_t));
                     if ( err ) {
                         H5Dclose(sparse_dset_id);
                         H5Gclose(dset_id);
                         free(sparse_data);
                         Mat_Critical("Integer multiplication overflow");
                         return err;
                     }
                     sparse_data->jc = (mat_uint32_t*)malloc(nbytes);
                     H5Dread(sparse_dset_id,H5T_NATIVE_UINT,
                             H5S_ALL,H5S_ALL,H5P_DEFAULT,sparse_data->jc);
                 }
                 H5Dclose(sparse_dset_id);
             }
 
             if ( H5Lexists(dset_id,"data",H5P_DEFAULT) ) {
                 size_t *dims;
                 hsize_t nelems;
                 int rank;
 
                 sparse_dset_id = H5Dopen(dset_id,"data",H5P_DEFAULT);
                 dims = Mat_H5ReadDims(sparse_dset_id, &nelems, &rank);
                 if ( NULL != dims ) {
                     size_t ndata_bytes;
                     sparse_data->nzmax = dims[0];
                     sparse_data->ndata = dims[0];
                     free(dims);
-                    err = SafeMul(&ndata_bytes, sparse_data->nzmax, Mat_SizeOf(matvar->data_type));
+                    err = Mul(&ndata_bytes, sparse_data->nzmax, Mat_SizeOf(matvar->data_type));
                     if ( err ) {
                         H5Dclose(sparse_dset_id);
                         H5Gclose(dset_id);
                         free(sparse_data);
                         Mat_Critical("Integer multiplication overflow");
                         return err;
                     }
                     matvar->data_size = sizeof(mat_sparse_t);
                     matvar->nbytes    = matvar->data_size;
                     if ( !matvar->isComplex ) {
                         sparse_data->data = malloc(ndata_bytes);
                     } else {
                         sparse_data->data = ComplexMalloc(ndata_bytes);
                     }
                     if ( NULL != sparse_data->data ) {
                         Mat_H5ReadData(sparse_dset_id, DataType2H5T(matvar->data_type),
                             H5S_ALL, H5S_ALL, matvar->isComplex, sparse_data->data);
                     }
                 }
                 H5Dclose(sparse_dset_id);
             }
             H5Gclose(dset_id);
             matvar->data = sparse_data;
             break;
         }
         case MAT_C_EMPTY:
         case MAT_C_FUNCTION:
         case MAT_C_OBJECT:
         case MAT_C_OPAQUE:
             break;
     }
     return err;
 }
 
 /** @if mat_devman
  * @brief Reads a slab of data from the mat variable @c matvar
  *
  * @ingroup mat_internal
  * @param mat MAT file pointer
  * @param matvar pointer to the mat variable
  * @param data pointer to store the read data in (must be of size
  *        edge[0]*...edge[rank-1]*Mat_SizeOfClass(matvar->class_type))
  * @param start index to start reading data in each dimension
  * @param stride write data every @c stride elements in each dimension
  * @param edge number of elements to read in each dimension
  * @retval 0 on success
  * @endif
  */
diff --git a/src/matio_private.h b/src/matio_private.h
index b9a0639..29998d4 100644
--- a/src/matio_private.h
+++ b/src/matio_private.h
@@ -212,24 +212,21 @@ EXTERN int ReadCompressedDataSlabN(mat_t *mat,z_streamp z,void *data,
                int rank,size_t *dims,int *start,int *stride,int *edge);
 
 /* inflate.c */
-EXTERN size_t InflateSkip(mat_t *mat, z_streamp z, int nbytes);
-EXTERN size_t InflateSkip2(mat_t *mat, matvar_t *matvar, int nbytes);
-EXTERN size_t InflateSkipData(mat_t *mat,z_streamp z,enum matio_types data_type,int len);
-EXTERN size_t InflateVarTag(mat_t *mat, matvar_t *matvar, void *buf);
-EXTERN size_t InflateArrayFlags(mat_t *mat, matvar_t *matvar, void *buf);
-EXTERN size_t InflateRankDims(mat_t *mat, matvar_t *matvar, void *buf, size_t nbytes, mat_uint32_t** dims);
-EXTERN size_t InflateVarName(mat_t *mat,matvar_t *matvar,void *buf,int N);
-EXTERN size_t InflateDataType(mat_t *mat, z_stream *z, void *buf);
-EXTERN size_t InflateData(mat_t *mat, z_streamp z, void *buf, unsigned int nBytes);
+EXTERN int InflateSkip(mat_t *mat, z_streamp z, int nBytes, size_t* bytesread);
+EXTERN int InflateSkipData(mat_t *mat, z_streamp z, enum matio_types data_type, int len);
+EXTERN int InflateRankDims(mat_t *mat, z_streamp z, void *buf, size_t nBytes, mat_uint32_t** dims, size_t* bytesread);
+EXTERN int Inflate(mat_t *mat, z_streamp z, void *buf, unsigned int nBytes, size_t* bytesread);
+EXTERN int InflateData(mat_t *mat, z_streamp z, void *buf, unsigned int nBytes);
 #endif
 
 /* mat.c */
 EXTERN mat_complex_split_t *ComplexMalloc(size_t nbytes);
 EXTERN void ComplexFree(mat_complex_split_t* complex_data);
 EXTERN enum matio_types ClassType2DataType(enum matio_classes class_type);
-EXTERN int SafeMulDims(const matvar_t *matvar, size_t* nelems);
-EXTERN int SafeMul(size_t* res, size_t a, size_t b);
-EXTERN int SafeAdd(size_t* res, size_t a, size_t b);
+EXTERN int Add(size_t* res, size_t a, size_t b);
+EXTERN int Mul(size_t* res, size_t a, size_t b);
+EXTERN int MulDims(const matvar_t *matvar, size_t* nelems);
+EXTERN int Read(void* buf, size_t size, size_t count, FILE* fp, size_t* bytesread);
 
 /* io.c */
 #if defined(_WIN32) && defined(_MSC_VER)
diff --git a/src/matvar_cell.c b/src/matvar_cell.c
index dc45735..8a2ba20 100644
--- a/src/matvar_cell.c
+++ b/src/matvar_cell.c
@@ -41,35 +41,35 @@ matvar_t *
 Mat_VarGetCell(matvar_t *matvar,int index)
 {
     size_t nelems = 1;
     matvar_t *cell = NULL;
 
     if ( matvar == NULL )
         return NULL;
 
-    SafeMulDims(matvar, &nelems);
+    MulDims(matvar, &nelems);
 
     if ( 0 <= index && (size_t)index < nelems )
         cell = *((matvar_t **)matvar->data + index);
 
     return cell;
 }
 
 /** @brief Indexes a cell array
  *
  * Finds cells of a cell array given a start, stride, and edge for each.
  * dimension.  The cells are placed in a pointer array.  The cells should not
  * be freed, but the array of pointers should be.  If copies are needed,
  * use Mat_VarDuplicate on each cell.
  *
  * Note that this function is limited to structure arrays with a rank less than
  * 10.
  *
  * @ingroup MAT
  * @param matvar Cell Array matlab variable
  * @param start vector of length rank with 0-relative starting coordinates for
  *              each dimension.
  * @param stride vector of length rank with strides for each dimension.
  * @param edge vector of length rank with the number of elements to read in
  *              each dimension.
  * @returns an array of pointers to the cells
  */
@@ -167,17 +167,17 @@ matvar_t *
 Mat_VarSetCell(matvar_t *matvar,int index,matvar_t *cell)
 {
     size_t nelems = 1;
     matvar_t **cells, *old_cell = NULL;
 
     if ( matvar == NULL || matvar->rank < 1 )
         return NULL;
 
-    SafeMulDims(matvar, &nelems);
+    MulDims(matvar, &nelems);
     cells = (matvar_t**)matvar->data;
     if ( 0 <= index && (size_t)index < nelems ) {
         old_cell = cells[index];
         cells[index] = cell;
     }
 
     return old_cell;
 }
diff --git a/src/matvar_struct.c b/src/matvar_struct.c
index a0d90d1..3c5d286 100644
--- a/src/matvar_struct.c
+++ b/src/matvar_struct.c
@@ -45,72 +45,72 @@ matvar_t *
 Mat_VarCreateStruct(const char *name,int rank,size_t *dims,const char **fields,
     unsigned nfields)
 {
     size_t nelems = 1;
     int j;
     matvar_t *matvar;
 
     if ( NULL == dims )
         return NULL;
 
     matvar = Mat_VarCalloc();
     if ( NULL == matvar )
         return NULL;
 
     matvar->compression = MAT_COMPRESSION_NONE;
     if ( NULL != name )
         matvar->name = strdup(name);
     matvar->rank = rank;
     matvar->dims = (size_t*)malloc(matvar->rank*sizeof(*matvar->dims));
     for ( j = 0; j < matvar->rank; j++ ) {
         matvar->dims[j] = dims[j];
         nelems *= dims[j];
     }
     matvar->class_type = MAT_C_STRUCT;
     matvar->data_type  = MAT_T_STRUCT;
 
     matvar->data_size = sizeof(matvar_t *);
 
     if ( nfields ) {
         matvar->internal->num_fields = nfields;
         matvar->internal->fieldnames =
             (char**)malloc(nfields*sizeof(*matvar->internal->fieldnames));
         if ( NULL == matvar->internal->fieldnames ) {
             Mat_VarFree(matvar);
             matvar = NULL;
         } else {
             size_t i;
             for ( i = 0; i < nfields; i++ ) {
                 if ( NULL == fields[i] ) {
                     Mat_VarFree(matvar);
                     matvar = NULL;
                     break;
                 } else {
                     matvar->internal->fieldnames[i] = strdup(fields[i]);
                 }
             }
         }
         if ( NULL != matvar && nelems > 0 ) {
             size_t nelems_x_nfields;
-            int err = SafeMul(&nelems_x_nfields, nelems, nfields);
-            err |= SafeMul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
+            int err = Mul(&nelems_x_nfields, nelems, nfields);
+            err |= Mul(&matvar->nbytes, nelems_x_nfields, matvar->data_size);
             if ( err ) {
                 Mat_VarFree(matvar);
                 return NULL;
             }
             matvar->data = calloc(nelems_x_nfields, matvar->data_size);
         }
     }
 
     return matvar;
 }
 
 /** @brief Adds a field to a structure
  *
  * Adds the given field to the structure. fields should be an array of matvar_t
  * pointers of the same size as the structure (i.e. 1 field per structure
  * element).
  * @ingroup MAT
  * @param matvar Pointer to the Structure MAT variable
  * @param fieldname Name of field to be added
  * @retval 0 on success
  */
@@ -118,60 +118,60 @@ int
 Mat_VarAddStructField(matvar_t *matvar,const char *fieldname)
 {
     int err;
     int cnt = 0;
     size_t i, nfields, nelems = 1;
     matvar_t **new_data, **old_data;
     char     **fieldnames;
 
     if ( matvar == NULL || fieldname == NULL )
         return -1;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err )
         return -1;
 
     nfields = matvar->internal->num_fields+1;
     matvar->internal->num_fields = nfields;
     fieldnames = (char**)realloc(matvar->internal->fieldnames,
         nfields*sizeof(*matvar->internal->fieldnames));
     if ( NULL == fieldnames )
         return -1;
     matvar->internal->fieldnames = fieldnames;
     matvar->internal->fieldnames[nfields-1] = strdup(fieldname);
 
     {
         size_t nelems_x_nfields;
-        err = SafeMul(&nelems_x_nfields, nelems, nfields);
-        err |= SafeMul(&matvar->nbytes, nelems_x_nfields, sizeof(*new_data));
+        err = Mul(&nelems_x_nfields, nelems, nfields);
+        err |= Mul(&matvar->nbytes, nelems_x_nfields, sizeof(*new_data));
         if ( err ) {
             matvar->nbytes = 0;
             return -1;
         }
     }
     new_data = (matvar_t**)malloc(matvar->nbytes);
     if ( new_data == NULL ) {
         matvar->nbytes = 0;
         return -1;
     }
 
     old_data = (matvar_t**)matvar->data;
     for ( i = 0; i < nelems; i++ ) {
         size_t f;
         for ( f = 0; f < nfields-1; f++ )
             new_data[cnt++] = old_data[i*(nfields-1)+f];
         new_data[cnt++] = NULL;
     }
 
     free(matvar->data);
     matvar->data = new_data;
 
     return 0;
 }
 
 /** @brief Returns the number of fields in a structure variable
  *
  * Returns the number of fields in the given structure.
  * @ingroup MAT
  * @param matvar Structure matlab variable
  * @returns Number of fields
  */
@@ -220,38 +220,38 @@ matvar_t *
 Mat_VarGetStructFieldByIndex(matvar_t *matvar,size_t field_index,size_t index)
 {
     int err;
     matvar_t *field = NULL;
     size_t nelems = 1, nfields;
 
     if ( matvar == NULL || matvar->class_type != MAT_C_STRUCT ||
         matvar->data_size == 0 )
         return NULL;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err )
         return NULL;
 
     nfields = matvar->internal->num_fields;
 
     if ( nelems > 0 && index >= nelems ) {
         Mat_Critical("Mat_VarGetStructField: structure index out of bounds");
     } else if ( nfields > 0 ) {
         if ( field_index > nfields ) {
             Mat_Critical("Mat_VarGetStructField: field index out of bounds");
         } else {
             field = *((matvar_t **)matvar->data+index*nfields+field_index);
         }
     }
 
     return field;
 }
 
 /** @brief Finds a field of a structure by the field's name
  *
  * Returns a pointer to the structure field at the given 0-relative index.
  * @ingroup MAT
  * @param matvar Pointer to the Structure MAT variable
  * @param field_name Name of the structure field
  * @param index linear index of the structure array
  * @return Pointer to the structure field on success, NULL on error
  */
@@ -259,46 +259,46 @@ matvar_t *
 Mat_VarGetStructFieldByName(matvar_t *matvar,const char *field_name,
                             size_t index)
 {
     int i, nfields, field_index, err;
     matvar_t *field = NULL;
     size_t nelems = 1;
 
     if ( matvar == NULL || matvar->class_type != MAT_C_STRUCT   ||
         matvar->data_size == 0 )
         return NULL;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err )
         return NULL;
 
     nfields = matvar->internal->num_fields;
     field_index = -1;
     for ( i = 0; i < nfields; i++ ) {
         if ( !strcmp(matvar->internal->fieldnames[i],field_name) ) {
             field_index = i;
             break;
         }
     }
 
     if ( index >= nelems ) {
         Mat_Critical("Mat_VarGetStructField: structure index out of bounds");
     } else if ( field_index >= 0 ) {
         field = *((matvar_t **)matvar->data+index*nfields+field_index);
     }
 
     return field;
 }
 
 /** @brief Finds a field of a structure
  *
  * Returns a pointer to the structure field at the given 0-relative index.
  * @ingroup MAT
  * @param matvar Pointer to the Structure MAT variable
  * @param name_or_index Name of the field, or the 1-relative index of the field
  * If the index is used, it should be the address of an integer variable whose
  * value is the index number.
  * @param opt MAT_BY_NAME if the name_or_index is the name or MAT_BY_INDEX if
  *            the index was passed.
  * @param index linear index of the structure to find the field of
  * @return Pointer to the Structure Field on success, NULL on error
  */
@@ -306,46 +306,46 @@ matvar_t *
 Mat_VarGetStructField(matvar_t *matvar,void *name_or_index,int opt,int index)
 {
     int err, nfields;
     matvar_t *field = NULL;
     size_t nelems = 1;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     nfields = matvar->internal->num_fields;
     if ( index < 0 || (nelems > 0 && (size_t)index >= nelems ))
         err = 1;
     else if ( nfields < 1 )
         err = 1;
 
     if ( !err && (opt == MAT_BY_INDEX) ) {
         size_t field_index = *(int *)name_or_index;
         if ( field_index > 0 )
             field = Mat_VarGetStructFieldByIndex(matvar,field_index-1,index);
     } else if ( !err && (opt == MAT_BY_NAME) ) {
         field = Mat_VarGetStructFieldByName(matvar,(const char*)name_or_index,index);
     }
 
     return field;
 }
 
 /** @brief Indexes a structure
  *
  * Finds structures of a structure array given a start, stride, and edge for
  * each dimension.  The structures are placed in a new structure array.  If
  * copy_fields is non-zero, the indexed structures are copied and should be
  * freed, but if copy_fields is zero, the indexed structures are pointers to
  * the original, but should still be freed. The structures have a flag set
  * so that the structure fields are not freed.
  *
  * Note that this function is limited to structure arrays with a rank less than
  * 10.
  *
  * @ingroup MAT
  * @param matvar Structure matlab variable
  * @param start vector of length rank with 0-relative starting coordinates for
  *              each dimension.
  * @param stride vector of length rank with strides for each dimension.
  * @param edge vector of length rank with the number of elements to read in
  *              each dimension.
  * @param copy_fields 1 to copy the fields, 0 to just set pointers to them.
  * @returns A new structure array with fields indexed from @c matvar.
  */
@@ -505,41 +505,41 @@ matvar_t *
 Mat_VarSetStructFieldByIndex(matvar_t *matvar,size_t field_index,size_t index,
     matvar_t *field)
 {
     int err;
     matvar_t *old_field = NULL;
     size_t nelems = 1, nfields;
 
     if ( matvar == NULL || matvar->class_type != MAT_C_STRUCT ||
         matvar->data == NULL )
         return NULL;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err )
         return NULL;
 
     nfields = matvar->internal->num_fields;
 
     if ( index < nelems && field_index < nfields ) {
         matvar_t **fields = (matvar_t**)matvar->data;
         old_field = fields[index*nfields+field_index];
         fields[index*nfields+field_index] = field;
         if ( NULL != field->name ) {
             free(field->name);
         }
         field->name = strdup(matvar->internal->fieldnames[field_index]);
     }
 
     return old_field;
 }
 
 /** @brief Sets the structure field to the given variable
  *
  * Sets the specified structure fieldname at the given 0-relative @c index to
  * @c field.
  * @ingroup MAT
  * @param matvar Pointer to the Structure MAT variable
  * @param field_name Name of the structure field
  * @param index linear index of the structure array
  * @param field New field variable
  * @return Pointer to the previous field (NULL if no previous field)
  */
@@ -547,36 +547,36 @@ matvar_t *
 Mat_VarSetStructFieldByName(matvar_t *matvar,const char *field_name,
     size_t index,matvar_t *field)
 {
     int err, i, nfields, field_index;
     matvar_t *old_field = NULL;
     size_t nelems = 1;
 
     if ( matvar == NULL || matvar->class_type != MAT_C_STRUCT ||
          matvar->data == NULL )
         return NULL;
 
-    err = SafeMulDims(matvar, &nelems);
+    err = MulDims(matvar, &nelems);
     if ( err )
         return NULL;
 
     nfields = matvar->internal->num_fields;
     field_index = -1;
     for ( i = 0; i < nfields; i++ ) {
         if ( !strcmp(matvar->internal->fieldnames[i],field_name) ) {
             field_index = i;
             break;
         }
     }
 
     if ( index < nelems && field_index >= 0 ) {
         matvar_t **fields = (matvar_t**)matvar->data;
         old_field = fields[index*nfields+field_index];
         fields[index*nfields+field_index] = field;
         if ( NULL != field->name ) {
             free(field->name);
         }
         field->name = strdup(matvar->internal->fieldnames[field_index]);
     }
 
     return old_field;
 }
diff --git a/test/test_mat.c b/test/test_mat.c
index 87abfc9..0ea55ea 100644
--- a/test/test_mat.c
+++ b/test/test_mat.c
@@ -3758,391 +3758,392 @@ test_directory(char *file)
 int main (int argc, char *argv[])
 {
     const char *prog_name = "test_mat";
     int   c, k, err = 0, ntests = 0, dim_append = 0;
     mat_t *mat, *mat2;
     matvar_t *matvar;
     enum matio_classes matvar_class = MAT_C_DOUBLE;
     const char *output_name = NULL;
     int version[3];
 
     Mat_GetLibraryVersion(version, version+1, version+2);
     if ( MATIO_MAJOR_VERSION != version[0] ||
          MATIO_MINOR_VERSION != version[1] ||
          MATIO_RELEASE_LEVEL != version[2] ) {
         fprintf(stderr,"matio version in header does not match runtime "
                 "version\n");
         return EXIT_FAILURE;
     }
 
     Mat_LogInit(prog_name);
+    Mat_SetDebug(1);
 
     while ( (c = getopt_long(argc,argv,optstring,options,NULL)) != EOF ) {
         switch ( c ) {
             case 'a':
                 if ( 1 != sscanf(optarg, "%d", &dim_append) )
                     exit(EXIT_FAILURE);
                 break;
             case 'c':
                 if ( !strcmp(optarg,"double") )
                     matvar_class = MAT_C_DOUBLE;
                 else if ( !strcmp(optarg,"single") )
                     matvar_class = MAT_C_SINGLE;
                 else if ( !strcmp(optarg,"int64") )
                     matvar_class = MAT_C_INT64;
                 else if ( !strcmp(optarg,"uint64") )
                     matvar_class = MAT_C_UINT64;
                 else if ( !strcmp(optarg,"int32") )
                     matvar_class = MAT_C_INT32;
                 else if ( !strcmp(optarg,"uint32") )
                     matvar_class = MAT_C_UINT32;
                 else if ( !strcmp(optarg,"int16") )
                     matvar_class = MAT_C_INT16;
                 else if ( !strcmp(optarg,"uint16") )
                     matvar_class = MAT_C_UINT16;
                 else if ( !strcmp(optarg,"int8") )
                     matvar_class = MAT_C_INT8;
                 else if ( !strcmp(optarg,"uint8") )
                     matvar_class = MAT_C_UINT8;
                 else {
                     fprintf(stderr,"Unrecognized MAT variable class '%s'",
                             optarg);
                     exit(EXIT_FAILURE);
                 }
                 break;
             case 'o':
                 output_name = optarg;
                 break;
             case 'v':
                 if ( !strcmp(optarg,"5") ) {
                     mat_file_ver = MAT_FT_MAT5;
                 } else if ( !strcmp(optarg,"7.3") ) {
                     mat_file_ver = MAT_FT_MAT73;
                 } else if ( !strcmp(optarg,"4") ) {
                     mat_file_ver = MAT_FT_MAT4;
                 } else {
                     fprintf(stderr,"Unrecognized MAT file version %s",argv[2]);
                     exit(EXIT_FAILURE);
                 }
                 break;
             case 'H':
                 Mat_Help(helpstr);
                 exit(EXIT_SUCCESS);
             case 'L':
                 Mat_Help(helptestsstr);
                 exit(EXIT_SUCCESS);
             case 'T':
                 help_test(optarg);
                 exit(EXIT_SUCCESS);
             case 'V':
                 printf("%s %s\nWritten by Christopher Hulbert\n\n"
                        "Copyright(C) 2006-2020, Christopher C. Hulbert\n",
                        prog_name,PACKAGE_VERSION);
                 exit(EXIT_SUCCESS);
             case 'z':
                 compression = MAT_COMPRESSION_ZLIB;
                 break;
             case '?':
                 exit(EXIT_FAILURE);
             default:
                 printf("%c not a valid option\n", c);
                 break;
         }
     }
 
     for ( k = optind; k < argc; ) {
         if ( !strcasecmp(argv[k],"copy") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_mat_copy.mat";
             mat = Mat_CreateVer(output_name,NULL,mat_file_ver);
             mat2 = Mat_Open(argv[k++],MAT_ACC_RDONLY);
             if ( mat && mat2 ) {
                 while ( NULL != (matvar = Mat_VarReadNext(mat2)) ) {
                     matvar_t* copy = Mat_VarDuplicate(matvar, 1);
                     Mat_VarFree(matvar);
                     if ( NULL != copy ) {
                         Mat_VarWrite(mat,copy,compression);
                         Mat_VarFree(copy);
                     } else {
                         err++;
                     }
                 }
                 Mat_Close(mat);
                 Mat_Close(mat2);
             }
             ntests++;
         } else if ( !strcasecmp(argv[k],"delete") ) {
             k++;
             err += test_delete(argv[k],argv[k+1]);
             k+= 2;
             ntests++;
         } else if ( !strcasecmp(argv[k],"directory") ) {
             k++;
             err += test_directory(argv[k++]);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_2d_logical") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_2d_logical.mat";
             err += test_write_2d_logical(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_2d_numeric") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_2d_numeric.mat";
             err += test_write_2d_numeric(matvar_class,output_name,dim_append);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_complex_2d_numeric") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_complex_2d_numeric.mat";
             err += test_write_complex_2d_numeric(matvar_class,output_name,dim_append);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_empty_2d_numeric") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_empty_2d_numeric.mat";
             err += test_write_empty_2d_numeric(matvar_class,output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_char") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_char.mat";
             err += test_write_char(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_char_unicode") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_char_unicode.mat";
             err += test_write_char_unicode(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"writenull") ) {
             k++;
             if ( NULL == output_name)
                 output_name = "test_write_null.mat";
             err += test_write_null(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"writenan") ) {
             k++;
             err += test_writenan();
             ntests++;
         } else if ( !strcasecmp(argv[k],"writeinf") ) {
             k++;
             if ( NULL == output_name)
                 output_name = "test_writeinf.mat";
             err += test_writeinf(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"readvar") ) {
             k++;
             if ( argc < 4 ) {
                 Mat_Critical("Must specify the input file and variable respectively");
                 err++;
             } else {
                 err += test_readvar(argv[k],argv[k+1],output_name);
                 k+=2;
             }
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_struct_2d_logical") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_struct_2d_logical.mat";
             err += test_write_struct_2d_logical(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_struct_char") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_struct_char.mat";
             err += test_write_struct_char(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_struct_2d_numeric") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_struct_2d_numeric.mat";
             err += test_write_struct_2d_numeric(matvar_class,output_name,dim_append);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_struct_complex_2d_numeric") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_struct_complex_2d_numeric.mat";
             err += test_write_struct_complex_2d_numeric(matvar_class,
                                                         output_name,dim_append);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_empty_struct") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_empty_struct.mat";
             err += test_write_empty_struct(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_cell_2d_logical") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_cell_2d_logical.mat";
             err += test_write_cell_2d_logical(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_cell_2d_numeric") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_cell_2d_numeric.mat";
             err += test_write_cell_2d_numeric(matvar_class,output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_cell_complex_2d_numeric") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_cell_complex_2d_numeric.mat";
             err += test_write_cell_complex_2d_numeric(matvar_class,
                                                         output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_empty_cell") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_empty_cell.mat";
             err += test_write_empty_cell(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_cell_empty_struct") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_cell_empty_struct.mat";
             err += test_write_cell_empty_struct(output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"struct_api_create") ) {
             k++;
             redirect_output(output_name);
             err += test_struct_api_create();
             ntests++;
         } else if ( !strcasecmp(argv[k],"struct_api_setfield") ) {
             k++;
             redirect_output(output_name);
             err += test_struct_api_setfield();
             ntests++;
         } else if ( !strcasecmp(argv[k],"struct_api_getfieldnames") ) {
             k++;
             redirect_output(output_name);
             err += test_struct_api_getfieldnames();
             ntests++;
         } else if ( !strcasecmp(argv[k],"struct_api_addfield") ) {
             k++;
             redirect_output(output_name);
             err += test_struct_api_addfield();
             ntests++;
         } else if ( !strcasecmp(argv[k],"struct_api_getlinear") ) {
             k++;
             redirect_output(output_name);
             err += test_struct_api_getlinear();
             ntests++;
         } else if ( !strcasecmp(argv[k],"struct_api_get") ) {
             k++;
             redirect_output(output_name);
             err += test_struct_api_get();
             ntests++;
         } else if ( !strcasecmp(argv[k],"cell_api_set") ) {
             k++;
             redirect_output(output_name);
             err += test_cell_api_set();
             ntests++;
         } else if ( !strcasecmp(argv[k],"cell_api_getlinear") ) {
             k++;
             redirect_output(output_name);
             err += test_cell_api_getlinear();
             ntests++;
         } else if ( !strcasecmp(argv[k],"cell_api_getcells") ) {
             k++;
             redirect_output(output_name);
             err += test_cell_api_getcells();
             ntests++;
         } else if ( !strcasecmp(argv[k],"getstructfield") ) {
             k++;
             if ( argc-k < 3 ) {
                 Mat_Critical("Must specify the input file, structure name, "
                              "and field name/index");
                 err++;
             } else {
                 redirect_output(output_name);
                 err += test_get_struct_field(argv[k],argv[k+1],argv[k+2]);
                 k += 3;
             }
             ntests++;
         } else if ( !strcasecmp(argv[k],"readvarinfo") ) {
             k++;
             mat = Mat_Open(argv[k++],MAT_ACC_RDONLY);
             if ( mat ) {
                 matvar = Mat_VarReadInfo(mat,argv[k++]);
                 if ( matvar ) {
                     Mat_VarPrint( matvar, 0);
                     Mat_VarFree(matvar);
                 }
                 Mat_Close(mat);
             } else {
                 k++;
                 err ++;
             }
             ntests++;
         } else if ( !strcasecmp(argv[k],"readslab") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "XXX.mat";
             test_readslab(argv[k],argv[k+1],matvar_class);
             k+=2;
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_sparse") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_sparse.mat";
             err += test_write_sparse(matvar_class,output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"write_complex_sparse") ) {
             k++;
             if ( NULL == output_name )
                 output_name = "test_write_sparse_complex.mat";
             err += test_write_complex_sparse(matvar_class,output_name);
             ntests++;
         } else if ( !strcasecmp(argv[k],"ind2sub") ) {
             size_t *subs, dims[3] = {256,256,124};
             redirect_output(output_name);
             subs = Mat_CalcSubscripts2(3,dims,18921-1);
             Mat_Message("(%" SIZE_T_FMTSTR ",%" SIZE_T_FMTSTR ",%" SIZE_T_FMTSTR ")",subs[0],subs[1],subs[2]);
             free(subs);
             k++;
             ntests++;
         } else if ( !strcasecmp(argv[k],"sub2ind") ) {
             size_t dims[3] = {256,256,124}, index[3] = {233,74,1};
             size_t linear_index = 0;
             redirect_output(output_name);
             err += Mat_CalcSingleSubscript2(3,dims,index,&linear_index);
             Mat_Message("%" SIZE_T_FMTSTR,linear_index);
             k++;
             ntests++;
         } else if ( !strcasecmp(argv[k],"reshape32x32x32") ) {
             k++;
             mat = Mat_Open(argv[k++],MAT_ACC_RDONLY);
             if ( NULL != mat ) {
                 matvar = Mat_VarRead(mat,argv[k++]);
                 if ( matvar ) {
                     if ( matvar->rank == 3 && matvar->dims[0] == 32 &&
                         matvar->dims[1] == 32 && matvar->dims[2] == 32 ) {
                         mat_t* mat2;
                         matvar->rank = 2;
                         matvar->dims[0] = 128;
                         matvar->dims[1] = 256;
                         matvar->dims[2] = 1;
                         if ( NULL == output_name )
                             output_name = "test_write_reshape32x32x32.mat";
                         mat2 = Mat_CreateVer(output_name,NULL,mat_file_ver);
                         if ( NULL != mat2 ) {
                             Mat_VarWrite(mat2, matvar, compression);
                             Mat_Close(mat2);
                         }
                     }
                     Mat_VarFree(matvar);
                 }
                 Mat_Close(mat);
             }
             ntests++;
         } else {
             Mat_Critical("Unrecognized test %s", argv[k]);
             k++;
             break;
         }
     }
 
     return err;
 }
