commit 8c8145a43ee4815b8851f8da7091c04f551dff6e
Author: Alan Modra <amodra@gmail.com>
Date:   Tue Aug 22 21:13:41 2023 +0930

    bfd_get_symbol_leading_char vs. ""
    
    Some places matching the first char of a string against
    bfd_get_symbol_leading_char, which may be zero, didn't check for the
    string being "".  This patch adds the check to stop accesses past the
    end of the string and potential buffer overruns.
    The dlltool one was found by oss-fuzz quite a while ago.
    
    bfd/
            * cofflink.c (_bfd_coff_link_input_bfd): Ensure a zero
            bfd_get_symbol_leading_char doesn't lead to accessing past the
            zero string terminator.
            * linker.c (bfd_wrapped_link_hash_lookup): Likewise.
            (unwrap_hash_lookup): Likewise.
    binutils/
            * dlltool.c (scan_filtered_symbols): Ensure a zero
            bfd_get_symbol_leading_char doesn't lead to accessing past the
            zero string terminator.

diff --git a/bfd/cofflink.c b/bfd/cofflink.c
index aea5c4c38a5..221f6e8183a 100644
--- a/bfd/cofflink.c
+++ b/bfd/cofflink.c
@@ -1382,1147 +1382,1148 @@ bool
 _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
 {
   unsigned int n_tmask = coff_data (input_bfd)->local_n_tmask;
   unsigned int n_btshft = coff_data (input_bfd)->local_n_btshft;
   bool (*adjust_symndx)
     (bfd *, struct bfd_link_info *, bfd *, asection *,
      struct internal_reloc *, bool *);
   bfd *output_bfd;
   const char *strings;
   bfd_size_type syment_base;
   bool copy, hash;
   bfd_size_type isymesz;
   bfd_size_type osymesz;
   bfd_size_type linesz;
   bfd_byte *esym;
   bfd_byte *esym_end;
   struct internal_syment *isymp;
   asection **secpp;
   long *indexp;
   unsigned long output_index;
   bfd_byte *outsym;
   struct coff_link_hash_entry **sym_hash;
   asection *o;
 
   /* Move all the symbols to the output file.  */
 
   output_bfd = flaginfo->output_bfd;
   strings = NULL;
   syment_base = obj_raw_syment_count (output_bfd);
   isymesz = bfd_coff_symesz (input_bfd);
   osymesz = bfd_coff_symesz (output_bfd);
   linesz = bfd_coff_linesz (input_bfd);
   BFD_ASSERT (linesz == bfd_coff_linesz (output_bfd));
 
   copy = false;
   if (! flaginfo->info->keep_memory)
     copy = true;
   hash = true;
   if (flaginfo->info->traditional_format)
     hash = false;
 
   if (! _bfd_coff_get_external_symbols (input_bfd))
     return false;
 
   esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
   esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
   isymp = flaginfo->internal_syms;
   secpp = flaginfo->sec_ptrs;
   indexp = flaginfo->sym_indices;
   output_index = syment_base;
   outsym = flaginfo->outsyms;
 
   if (obj_pe (output_bfd)
       && ! process_embedded_commands (output_bfd, flaginfo->info, input_bfd))
     return false;
 
   /* If we are going to perform relocations and also strip/discard some
      symbols then we must make sure that we do not strip/discard those
      symbols that are going to be involved in the relocations.  */
   if ((   flaginfo->info->strip   != strip_none
        || flaginfo->info->discard != discard_none)
       && bfd_link_relocatable (flaginfo->info))
     {
       /* Mark the symbol array as 'not-used'.  */
       memset (indexp, 0, obj_raw_syment_count (input_bfd) * sizeof * indexp);
 
       mark_relocs (flaginfo, input_bfd);
     }
 
   while (esym < esym_end)
     {
       struct internal_syment isym;
       enum coff_symbol_classification classification;
       bool skip;
       bool global;
       bool dont_skip_symbol;
       int add;
 
       bfd_coff_swap_sym_in (input_bfd, esym, isymp);
 
       /* Make a copy of *isymp so that the relocate_section function
 	 always sees the original values.  This is more reliable than
 	 always recomputing the symbol value even if we are stripping
 	 the symbol.  */
       isym = *isymp;
 
       classification = bfd_coff_classify_symbol (input_bfd, &isym);
       switch (classification)
 	{
 	default:
 	  abort ();
 	case COFF_SYMBOL_GLOBAL:
 	case COFF_SYMBOL_PE_SECTION:
 	case COFF_SYMBOL_LOCAL:
 	  *secpp = coff_section_from_bfd_index (input_bfd, isym.n_scnum);
 	  break;
 	case COFF_SYMBOL_COMMON:
 	  *secpp = bfd_com_section_ptr;
 	  break;
 	case COFF_SYMBOL_UNDEFINED:
 	  *secpp = bfd_und_section_ptr;
 	  break;
 	}
 
       /* Extract the flag indicating if this symbol is used by a
 	 relocation.  */
       if ((flaginfo->info->strip != strip_none
 	   || flaginfo->info->discard != discard_none)
 	  && bfd_link_relocatable (flaginfo->info))
 	dont_skip_symbol = *indexp;
       else
 	dont_skip_symbol = false;
 
       *indexp = -1;
 
       skip = false;
       global = false;
       add = 1 + isym.n_numaux;
 
       /* If we are stripping all symbols, we want to skip this one.  */
       if (flaginfo->info->strip == strip_all && ! dont_skip_symbol)
 	skip = true;
 
       if (! skip)
 	{
 	  switch (classification)
 	    {
 	    default:
 	      abort ();
 	    case COFF_SYMBOL_GLOBAL:
 	    case COFF_SYMBOL_COMMON:
 	    case COFF_SYMBOL_PE_SECTION:
 	      /* This is a global symbol.  Global symbols come at the
 		 end of the symbol table, so skip them for now.
 		 Locally defined function symbols, however, are an
 		 exception, and are not moved to the end.  */
 	      global = true;
 	      if (! ISFCN (isym.n_type))
 		skip = true;
 	      break;
 
 	    case COFF_SYMBOL_UNDEFINED:
 	      /* Undefined symbols are left for the end.  */
 	      global = true;
 	      skip = true;
 	      break;
 
 	    case COFF_SYMBOL_LOCAL:
 	      /* This is a local symbol.  Skip it if we are discarding
 		 local symbols.  */
 	      if (flaginfo->info->discard == discard_all && ! dont_skip_symbol)
 		skip = true;
 	      break;
 	    }
 	}
 
 #ifndef COFF_WITH_PE
       /* Skip section symbols for sections which are not going to be
 	 emitted.  */
       if (!skip
 	  && !dont_skip_symbol
 	  && isym.n_sclass == C_STAT
 	  && isym.n_type == T_NULL
 	  && isym.n_numaux > 0
 	  && ((*secpp)->output_section == bfd_abs_section_ptr
 	      || bfd_section_removed_from_list (output_bfd,
 						(*secpp)->output_section)))
 	skip = true;
 #endif
 
       /* If we stripping debugging symbols, and this is a debugging
 	 symbol, then skip it.  FIXME: gas sets the section to N_ABS
 	 for some types of debugging symbols; I don't know if this is
 	 a bug or not.  In any case, we handle it here.  */
       if (! skip
 	  && flaginfo->info->strip == strip_debugger
 	  && ! dont_skip_symbol
 	  && (isym.n_scnum == N_DEBUG
 	      || (isym.n_scnum == N_ABS
 		  && (isym.n_sclass == C_AUTO
 		      || isym.n_sclass == C_REG
 		      || isym.n_sclass == C_MOS
 		      || isym.n_sclass == C_MOE
 		      || isym.n_sclass == C_MOU
 		      || isym.n_sclass == C_ARG
 		      || isym.n_sclass == C_REGPARM
 		      || isym.n_sclass == C_FIELD
 		      || isym.n_sclass == C_EOS))))
 	skip = true;
 
       /* If some symbols are stripped based on the name, work out the
 	 name and decide whether to skip this symbol.  */
       if (! skip
 	  && (flaginfo->info->strip == strip_some
 	      || flaginfo->info->discard == discard_l))
 	{
 	  const char *name;
 	  char buf[SYMNMLEN + 1];
 
 	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
 	  if (name == NULL)
 	    return false;
 
 	  if (! dont_skip_symbol
 	      && ((flaginfo->info->strip == strip_some
 		   && (bfd_hash_lookup (flaginfo->info->keep_hash, name, false,
 				    false) == NULL))
 		   || (! global
 		       && flaginfo->info->discard == discard_l
 		       && bfd_is_local_label_name (input_bfd, name))))
 	    skip = true;
 	}
 
       /* If this is an enum, struct, or union tag, see if we have
 	 already output an identical type.  */
       if (! skip
 	  && !flaginfo->info->traditional_format
 	  && (isym.n_sclass == C_ENTAG
 	      || isym.n_sclass == C_STRTAG
 	      || isym.n_sclass == C_UNTAG)
 	  && isym.n_numaux == 1)
 	{
 	  const char *name;
 	  char buf[SYMNMLEN + 1];
 	  struct coff_debug_merge_hash_entry *mh;
 	  struct coff_debug_merge_type *mt;
 	  union internal_auxent aux;
 	  struct coff_debug_merge_element **epp;
 	  bfd_byte *esl, *eslend;
 	  struct internal_syment *islp;
 	  size_t amt;
 
 	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
 	  if (name == NULL)
 	    return false;
 
 	  /* Ignore fake names invented by compiler; treat them all as
 	     the same name.  */
 	  if (*name == '~' || *name == '.' || *name == '$'
-	      || (*name == bfd_get_symbol_leading_char (input_bfd)
+	      || (*name
+		  && *name == bfd_get_symbol_leading_char (input_bfd)
 		  && (name[1] == '~' || name[1] == '.' || name[1] == '$')))
 	    name = "";
 
 	  mh = coff_debug_merge_hash_lookup (&flaginfo->debug_merge, name,
 					     true, true);
 	  if (mh == NULL)
 	    return false;
 
 	  /* Allocate memory to hold type information.  If this turns
 	     out to be a duplicate, we pass this address to
 	     bfd_release.  */
 	  amt = sizeof (struct coff_debug_merge_type);
 	  mt = (struct coff_debug_merge_type *) bfd_alloc (input_bfd, amt);
 	  if (mt == NULL)
 	    return false;
 	  mt->type_class = isym.n_sclass;
 
 	  /* Pick up the aux entry, which points to the end of the tag
 	     entries.  */
 	  bfd_coff_swap_aux_in (input_bfd, (esym + isymesz),
 				isym.n_type, isym.n_sclass, 0, isym.n_numaux,
 				&aux);
 
 	  /* Gather the elements.  */
 	  epp = &mt->elements;
 	  mt->elements = NULL;
 	  islp = isymp + 2;
 	  esl = esym + 2 * isymesz;
 	  eslend = ((bfd_byte *) obj_coff_external_syms (input_bfd)
 		    + aux.x_sym.x_fcnary.x_fcn.x_endndx.u32 * isymesz);
 	  while (esl < eslend)
 	    {
 	      const char *elename;
 	      char elebuf[SYMNMLEN + 1];
 	      char *name_copy;
 
 	      bfd_coff_swap_sym_in (input_bfd, esl, islp);
 
 	      amt = sizeof (struct coff_debug_merge_element);
 	      *epp = (struct coff_debug_merge_element *)
 		  bfd_alloc (input_bfd, amt);
 	      if (*epp == NULL)
 		return false;
 
 	      elename = _bfd_coff_internal_syment_name (input_bfd, islp,
 							elebuf);
 	      if (elename == NULL)
 		return false;
 
 	      amt = strlen (elename) + 1;
 	      name_copy = (char *) bfd_alloc (input_bfd, amt);
 	      if (name_copy == NULL)
 		return false;
 	      strcpy (name_copy, elename);
 
 	      (*epp)->name = name_copy;
 	      (*epp)->type = islp->n_type;
 	      (*epp)->tagndx = 0;
 	      if (islp->n_numaux >= 1
 		  && islp->n_type != T_NULL
 		  && islp->n_sclass != C_EOS)
 		{
 		  union internal_auxent eleaux;
 		  long indx;
 
 		  bfd_coff_swap_aux_in (input_bfd, (esl + isymesz),
 					islp->n_type, islp->n_sclass, 0,
 					islp->n_numaux, &eleaux);
 		  indx = eleaux.x_sym.x_tagndx.u32;
 
 		  /* FIXME: If this tagndx entry refers to a symbol
 		     defined later in this file, we just ignore it.
 		     Handling this correctly would be tedious, and may
 		     not be required.  */
 		  if (indx > 0
 		      && (indx
 			  < ((esym -
 			      (bfd_byte *) obj_coff_external_syms (input_bfd))
 			     / (long) isymesz)))
 		    {
 		      (*epp)->tagndx = flaginfo->sym_indices[indx];
 		      if ((*epp)->tagndx < 0)
 			(*epp)->tagndx = 0;
 		    }
 		}
 	      epp = &(*epp)->next;
 	      *epp = NULL;
 
 	      esl += (islp->n_numaux + 1) * isymesz;
 	      islp += islp->n_numaux + 1;
 	    }
 
 	  /* See if we already have a definition which matches this
 	     type.  We always output the type if it has no elements,
 	     for simplicity.  */
 	  if (mt->elements == NULL)
 	    bfd_release (input_bfd, mt);
 	  else
 	    {
 	      struct coff_debug_merge_type *mtl;
 
 	      for (mtl = mh->types; mtl != NULL; mtl = mtl->next)
 		{
 		  struct coff_debug_merge_element *me, *mel;
 
 		  if (mtl->type_class != mt->type_class)
 		    continue;
 
 		  for (me = mt->elements, mel = mtl->elements;
 		       me != NULL && mel != NULL;
 		       me = me->next, mel = mel->next)
 		    {
 		      if (strcmp (me->name, mel->name) != 0
 			  || me->type != mel->type
 			  || me->tagndx != mel->tagndx)
 			break;
 		    }
 
 		  if (me == NULL && mel == NULL)
 		    break;
 		}
 
 	      if (mtl == NULL || (bfd_size_type) mtl->indx >= syment_base)
 		{
 		  /* This is the first definition of this type.  */
 		  mt->indx = output_index;
 		  mt->next = mh->types;
 		  mh->types = mt;
 		}
 	      else
 		{
 		  /* This is a redefinition which can be merged.  */
 		  bfd_release (input_bfd, mt);
 		  *indexp = mtl->indx;
 		  add = (eslend - esym) / isymesz;
 		  skip = true;
 		}
 	    }
 	}
 
       /* We now know whether we are to skip this symbol or not.  */
       if (! skip)
 	{
 	  /* Adjust the symbol in order to output it.  */
 
 	  if (isym._n._n_n._n_zeroes == 0
 	      && isym._n._n_n._n_offset != 0)
 	    {
 	      const char *name;
 	      bfd_size_type indx;
 
 	      /* This symbol has a long name.  Enter it in the string
 		 table we are building.  Note that we do not check
 		 bfd_coff_symname_in_debug.  That is only true for
 		 XCOFF, and XCOFF requires different linking code
 		 anyhow.  */
 	      name = _bfd_coff_internal_syment_name (input_bfd, &isym, NULL);
 	      if (name == NULL)
 		return false;
 	      indx = _bfd_stringtab_add (flaginfo->strtab, name, hash, copy);
 	      if (indx == (bfd_size_type) -1)
 		return false;
 	      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
 	    }
 
 	  switch (isym.n_sclass)
 	    {
 	    case C_AUTO:
 	    case C_MOS:
 	    case C_EOS:
 	    case C_MOE:
 	    case C_MOU:
 	    case C_UNTAG:
 	    case C_STRTAG:
 	    case C_ENTAG:
 	    case C_TPDEF:
 	    case C_ARG:
 	    case C_USTATIC:
 	    case C_REG:
 	    case C_REGPARM:
 	    case C_FIELD:
 	      /* The symbol value should not be modified.  */
 	      break;
 
 	    case C_FCN:
 	      if (obj_pe (input_bfd)
 		  && memcmp (isym.n_name, ".bf", sizeof ".bf") != 0
 		  && isym.n_scnum > 0)
 		{
 		  /* For PE, .lf and .ef get their value left alone,
 		     while .bf gets relocated.  However, they all have
 		     "real" section numbers, and need to be moved into
 		     the new section.  */
 		  isym.n_scnum = (*secpp)->output_section->target_index;
 		  break;
 		}
 	      /* Fall through.  */
 	    default:
 	    case C_LABEL:  /* Not completely sure about these 2 */
 	    case C_EXTDEF:
 	    case C_BLOCK:
 	    case C_EFCN:
 	    case C_NULL:
 	    case C_EXT:
 	    case C_STAT:
 	    case C_SECTION:
 	    case C_NT_WEAK:
 	      /* Compute new symbol location.  */
 	    if (isym.n_scnum > 0)
 	      {
 		isym.n_scnum = (*secpp)->output_section->target_index;
 		isym.n_value += (*secpp)->output_offset;
 		if (! obj_pe (input_bfd))
 		  isym.n_value -= (*secpp)->vma;
 		if (! obj_pe (flaginfo->output_bfd))
 		  isym.n_value += (*secpp)->output_section->vma;
 	      }
 	    break;
 
 	    case C_FILE:
 	      /* The value of a C_FILE symbol is the symbol index of
 		 the next C_FILE symbol.  The value of the last C_FILE
 		 symbol is the symbol index to the first external
 		 symbol (actually, coff_renumber_symbols does not get
 		 this right--it just sets the value of the last C_FILE
 		 symbol to zero--and nobody has ever complained about
 		 it).  We try to get this right, below, just before we
 		 write the symbols out, but in the general case we may
 		 have to write the symbol out twice.  */
 	      if (flaginfo->last_file_index != -1
 		  && flaginfo->last_file.n_value != (bfd_vma) output_index)
 		{
 		  /* We must correct the value of the last C_FILE
 		     entry.  */
 		  flaginfo->last_file.n_value = output_index;
 		  if ((bfd_size_type) flaginfo->last_file_index >= syment_base)
 		    {
 		      /* The last C_FILE symbol is in this input file.  */
 		      bfd_coff_swap_sym_out (output_bfd,
 					     &flaginfo->last_file,
 					     (flaginfo->outsyms
 					      + ((flaginfo->last_file_index
 						  - syment_base)
 						 * osymesz)));
 		    }
 		  else
 		    {
 		      file_ptr pos;
 
 		      /* We have already written out the last C_FILE
 			 symbol.  We need to write it out again.  We
 			 borrow *outsym temporarily.  */
 		      bfd_coff_swap_sym_out (output_bfd,
 					     &flaginfo->last_file, outsym);
 		      pos = obj_sym_filepos (output_bfd);
 		      pos += flaginfo->last_file_index * osymesz;
 		      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
 			  || bfd_write (outsym, osymesz, output_bfd) != osymesz)
 			return false;
 		    }
 		}
 
 	      flaginfo->last_file_index = output_index;
 	      flaginfo->last_file = isym;
 	      break;
 	    }
 
 	  /* If doing task linking, convert normal global function symbols to
 	     static functions.  */
 	  if (flaginfo->info->task_link && IS_EXTERNAL (input_bfd, isym))
 	    isym.n_sclass = C_STAT;
 
 	  /* Output the symbol.  */
 	  bfd_coff_swap_sym_out (output_bfd, &isym, outsym);
 
 	  *indexp = output_index;
 
 	  if (global)
 	    {
 	      long indx;
 	      struct coff_link_hash_entry *h;
 
 	      indx = ((esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
 		      / isymesz);
 	      h = obj_coff_sym_hashes (input_bfd)[indx];
 	      if (h == NULL)
 		{
 		  /* This can happen if there were errors earlier in
 		     the link.  */
 		  bfd_set_error (bfd_error_bad_value);
 		  return false;
 		}
 	      h->indx = output_index;
 	    }
 
 	  output_index += add;
 	  outsym += add * osymesz;
 	}
 
       esym += add * isymesz;
       isymp += add;
       ++secpp;
       ++indexp;
       for (--add; add > 0; --add)
 	{
 	  *secpp++ = NULL;
 	  *indexp++ = -1;
 	}
     }
 
   /* Fix up the aux entries.  This must be done in a separate pass,
      because we don't know the correct symbol indices until we have
      already decided which symbols we are going to keep.  */
   esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
   esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
   isymp = flaginfo->internal_syms;
   indexp = flaginfo->sym_indices;
   sym_hash = obj_coff_sym_hashes (input_bfd);
   outsym = flaginfo->outsyms;
 
   while (esym < esym_end)
     {
       int add;
 
       add = 1 + isymp->n_numaux;
 
       if ((*indexp < 0
 	   || (bfd_size_type) *indexp < syment_base)
 	  && (*sym_hash == NULL
 	      || (*sym_hash)->auxbfd != input_bfd))
 	esym += add * isymesz;
       else
 	{
 	  struct coff_link_hash_entry *h;
 	  int i;
 
 	  h = NULL;
 	  if (*indexp < 0)
 	    {
 	      h = *sym_hash;
 
 	      /* The m68k-motorola-sysv assembler will sometimes
 		 generate two symbols with the same name, but only one
 		 will have aux entries.  */
 	      BFD_ASSERT (isymp->n_numaux == 0
 			  || h->numaux == 0
 			  || h->numaux == isymp->n_numaux);
 	    }
 
 	  esym += isymesz;
 
 	  if (h == NULL)
 	    outsym += osymesz;
 
 	  /* Handle the aux entries.  This handling is based on
 	     coff_pointerize_aux.  I don't know if it always correct.  */
 	  for (i = 0; i < isymp->n_numaux && esym < esym_end; i++)
 	    {
 	      union internal_auxent aux;
 	      union internal_auxent *auxp;
 
 	      if (h != NULL && h->aux != NULL && (h->numaux > i))
 		auxp = h->aux + i;
 	      else
 		{
 		  bfd_coff_swap_aux_in (input_bfd, esym, isymp->n_type,
 					isymp->n_sclass, i, isymp->n_numaux, &aux);
 		  auxp = &aux;
 		}
 
 	      if (isymp->n_sclass == C_FILE)
 		{
 		  /* If this is a long filename, we must put it in the
 		     string table.  */
 		  if (auxp->x_file.x_n.x_n.x_zeroes == 0
 		      && auxp->x_file.x_n.x_n.x_offset != 0)
 		    {
 		      const char *filename;
 		      bfd_size_type indx;
 
 		      BFD_ASSERT (auxp->x_file.x_n.x_n.x_offset
 				  >= STRING_SIZE_SIZE);
 		      if (strings == NULL)
 			{
 			  strings = _bfd_coff_read_string_table (input_bfd);
 			  if (strings == NULL)
 			    return false;
 			}
 		      if ((bfd_size_type) auxp->x_file.x_n.x_n.x_offset >= obj_coff_strings_len (input_bfd))
 			filename = _("<corrupt>");
 		      else
 			filename = strings + auxp->x_file.x_n.x_n.x_offset;
 		      indx = _bfd_stringtab_add (flaginfo->strtab, filename,
 						 hash, copy);
 		      if (indx == (bfd_size_type) -1)
 			return false;
 		      auxp->x_file.x_n.x_n.x_offset = STRING_SIZE_SIZE + indx;
 		    }
 		}
 	      else if ((isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
 		       && isymp->n_sclass != C_NT_WEAK)
 		{
 		  unsigned long indx;
 
 		  if (ISFCN (isymp->n_type)
 		      || ISTAG (isymp->n_sclass)
 		      || isymp->n_sclass == C_BLOCK
 		      || isymp->n_sclass == C_FCN)
 		    {
 		      indx = auxp->x_sym.x_fcnary.x_fcn.x_endndx.u32;
 		      if (indx > 0
 			  && indx < obj_raw_syment_count (input_bfd))
 			{
 			  /* We look forward through the symbol for
 			     the index of the next symbol we are going
 			     to include.  I don't know if this is
 			     entirely right.  */
 			  while ((flaginfo->sym_indices[indx] < 0
 				  || ((bfd_size_type) flaginfo->sym_indices[indx]
 				      < syment_base))
 				 && indx < obj_raw_syment_count (input_bfd))
 			    ++indx;
 			  if (indx >= obj_raw_syment_count (input_bfd))
 			    indx = output_index;
 			  else
 			    indx = flaginfo->sym_indices[indx];
 			  auxp->x_sym.x_fcnary.x_fcn.x_endndx.u32 = indx;
 			}
 		    }
 
 		  indx = auxp->x_sym.x_tagndx.u32;
 		  if (indx > 0 && indx < obj_raw_syment_count (input_bfd))
 		    {
 		      long symindx;
 
 		      symindx = flaginfo->sym_indices[indx];
 		      if (symindx < 0)
 			auxp->x_sym.x_tagndx.u32 = 0;
 		      else
 			auxp->x_sym.x_tagndx.u32 = symindx;
 		    }
 
 		  /* The .bf symbols are supposed to be linked through
 		     the endndx field.  We need to carry this list
 		     across object files.  */
 		  if (i == 0
 		      && h == NULL
 		      && isymp->n_sclass == C_FCN
 		      && (isymp->_n._n_n._n_zeroes != 0
 			  || isymp->_n._n_n._n_offset == 0)
 		      && isymp->_n._n_name[0] == '.'
 		      && isymp->_n._n_name[1] == 'b'
 		      && isymp->_n._n_name[2] == 'f'
 		      && isymp->_n._n_name[3] == '\0')
 		    {
 		      if (flaginfo->last_bf_index != -1)
 			{
 			  flaginfo->last_bf.x_sym.x_fcnary.x_fcn.x_endndx.u32 =
 			    *indexp;
 
 			  if ((bfd_size_type) flaginfo->last_bf_index
 			      >= syment_base)
 			    {
 			      void *auxout;
 
 			      /* The last .bf symbol is in this input
 				 file.  This will only happen if the
 				 assembler did not set up the .bf
 				 endndx symbols correctly.  */
 			      auxout = (flaginfo->outsyms
 					+ ((flaginfo->last_bf_index
 					    - syment_base)
 					   * osymesz));
 
 			      bfd_coff_swap_aux_out (output_bfd,
 						     &flaginfo->last_bf,
 						     isymp->n_type,
 						     isymp->n_sclass,
 						     0, isymp->n_numaux,
 						     auxout);
 			    }
 			  else
 			    {
 			      file_ptr pos;
 
 			      /* We have already written out the last
 				 .bf aux entry.  We need to write it
 				 out again.  We borrow *outsym
 				 temporarily.  FIXME: This case should
 				 be made faster.  */
 			      bfd_coff_swap_aux_out (output_bfd,
 						     &flaginfo->last_bf,
 						     isymp->n_type,
 						     isymp->n_sclass,
 						     0, isymp->n_numaux,
 						     outsym);
 			      pos = obj_sym_filepos (output_bfd);
 			      pos += flaginfo->last_bf_index * osymesz;
 			      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
 				  || (bfd_write (outsym, osymesz, output_bfd)
 				      != osymesz))
 				return false;
 			    }
 			}
 
 		      if (auxp->x_sym.x_fcnary.x_fcn.x_endndx.u32 != 0)
 			flaginfo->last_bf_index = -1;
 		      else
 			{
 			  /* The endndx field of this aux entry must
 			     be updated with the symbol number of the
 			     next .bf symbol.  */
 			  flaginfo->last_bf = *auxp;
 			  flaginfo->last_bf_index = (((outsym - flaginfo->outsyms)
 						   / osymesz)
 						  + syment_base);
 			}
 		    }
 		}
 
 	      if (h == NULL)
 		{
 		  bfd_coff_swap_aux_out (output_bfd, auxp, isymp->n_type,
 					 isymp->n_sclass, i, isymp->n_numaux,
 					 outsym);
 		  outsym += osymesz;
 		}
 
 	      esym += isymesz;
 	    }
 	}
 
       indexp += add;
       isymp += add;
       sym_hash += add;
     }
 
   /* Relocate the line numbers, unless we are stripping them.  */
   if (flaginfo->info->strip == strip_none
       || flaginfo->info->strip == strip_some)
     {
       for (o = input_bfd->sections; o != NULL; o = o->next)
 	{
 	  bfd_vma offset;
 	  bfd_byte *eline;
 	  bfd_byte *elineend;
 	  bfd_byte *oeline;
 	  bool skipping;
 	  file_ptr pos;
 	  bfd_size_type amt;
 
 	  /* FIXME: If SEC_HAS_CONTENTS is not for the section, then
 	     build_link_order in ldwrite.c will not have created a
 	     link order, which means that we will not have seen this
 	     input section in _bfd_coff_final_link, which means that
 	     we will not have allocated space for the line numbers of
 	     this section.  I don't think line numbers can be
 	     meaningful for a section which does not have
 	     SEC_HAS_CONTENTS set, but, if they do, this must be
 	     changed.  */
 	  if (o->lineno_count == 0
 	      || (o->output_section->flags & SEC_HAS_CONTENTS) == 0)
 	    continue;
 
 	  if (bfd_seek (input_bfd, o->line_filepos, SEEK_SET) != 0
 	      || bfd_read (flaginfo->linenos, linesz * o->lineno_count,
 			   input_bfd) != linesz * o->lineno_count)
 	    return false;
 
 	  offset = o->output_section->vma + o->output_offset - o->vma;
 	  eline = flaginfo->linenos;
 	  oeline = flaginfo->linenos;
 	  elineend = eline + linesz * o->lineno_count;
 	  skipping = false;
 	  for (; eline < elineend; eline += linesz)
 	    {
 	      struct internal_lineno iline;
 
 	      bfd_coff_swap_lineno_in (input_bfd, eline, &iline);
 
 	      if (iline.l_lnno != 0)
 		iline.l_addr.l_paddr += offset;
 	      else if (iline.l_addr.l_symndx >= 0
 		       && ((unsigned long) iline.l_addr.l_symndx
 			   < obj_raw_syment_count (input_bfd)))
 		{
 		  long indx;
 
 		  indx = flaginfo->sym_indices[iline.l_addr.l_symndx];
 
 		  if (indx < 0)
 		    {
 		      /* These line numbers are attached to a symbol
 			 which we are stripping.  We must discard the
 			 line numbers because reading them back with
 			 no associated symbol (or associating them all
 			 with symbol #0) will fail.  We can't regain
 			 the space in the output file, but at least
 			 they're dense.  */
 		      skipping = true;
 		    }
 		  else
 		    {
 		      struct internal_syment is;
 		      union internal_auxent ia;
 
 		      /* Fix up the lnnoptr field in the aux entry of
 			 the symbol.  It turns out that we can't do
 			 this when we modify the symbol aux entries,
 			 because gas sometimes screws up the lnnoptr
 			 field and makes it an offset from the start
 			 of the line numbers rather than an absolute
 			 file index.  */
 		      bfd_coff_swap_sym_in (output_bfd,
 					    (flaginfo->outsyms
 					     + ((indx - syment_base)
 						* osymesz)), &is);
 		      if ((ISFCN (is.n_type)
 			   || is.n_sclass == C_BLOCK)
 			  && is.n_numaux >= 1)
 			{
 			  void *auxptr;
 
 			  auxptr = (flaginfo->outsyms
 				    + ((indx - syment_base + 1)
 				       * osymesz));
 			  bfd_coff_swap_aux_in (output_bfd, auxptr,
 						is.n_type, is.n_sclass,
 						0, is.n_numaux, &ia);
 			  ia.x_sym.x_fcnary.x_fcn.x_lnnoptr =
 			    (o->output_section->line_filepos
 			     + o->output_section->lineno_count * linesz
 			     + eline - flaginfo->linenos);
 			  bfd_coff_swap_aux_out (output_bfd, &ia,
 						 is.n_type, is.n_sclass, 0,
 						 is.n_numaux, auxptr);
 			}
 
 		      skipping = false;
 		    }
 
 		  iline.l_addr.l_symndx = indx;
 		}
 
 	      if (!skipping)
 		{
 		  bfd_coff_swap_lineno_out (output_bfd, &iline, oeline);
 		  oeline += linesz;
 		}
 	    }
 
 	  pos = o->output_section->line_filepos;
 	  pos += o->output_section->lineno_count * linesz;
 	  amt = oeline - flaginfo->linenos;
 	  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
 	      || bfd_write (flaginfo->linenos, amt, output_bfd) != amt)
 	    return false;
 
 	  o->output_section->lineno_count += amt / linesz;
 	}
     }
 
   /* If we swapped out a C_FILE symbol, guess that the next C_FILE
      symbol will be the first symbol in the next input file.  In the
      normal case, this will save us from writing out the C_FILE symbol
      again.  */
   if (flaginfo->last_file_index != -1
       && (bfd_size_type) flaginfo->last_file_index >= syment_base)
     {
       flaginfo->last_file.n_value = output_index;
       bfd_coff_swap_sym_out (output_bfd, &flaginfo->last_file,
 			     (flaginfo->outsyms
 			      + ((flaginfo->last_file_index - syment_base)
 				 * osymesz)));
     }
 
   /* Write the modified symbols to the output file.  */
   if (outsym > flaginfo->outsyms)
     {
       file_ptr pos;
       bfd_size_type amt;
 
       pos = obj_sym_filepos (output_bfd) + syment_base * osymesz;
       amt = outsym - flaginfo->outsyms;
       if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
 	  || bfd_write (flaginfo->outsyms, amt, output_bfd) != amt)
 	return false;
 
       BFD_ASSERT ((obj_raw_syment_count (output_bfd)
 		   + (outsym - flaginfo->outsyms) / osymesz)
 		  == output_index);
 
       obj_raw_syment_count (output_bfd) = output_index;
     }
 
   /* Relocate the contents of each section.  */
   adjust_symndx = coff_backend_info (input_bfd)->_bfd_coff_adjust_symndx;
   for (o = input_bfd->sections; o != NULL; o = o->next)
     {
       bfd_byte *contents;
       struct coff_section_tdata *secdata;
 
       if (! o->linker_mark)
 	/* This section was omitted from the link.  */
 	continue;
 
       if ((o->flags & SEC_LINKER_CREATED) != 0)
 	continue;
 
       if ((o->flags & SEC_HAS_CONTENTS) == 0
 	  || (o->size == 0 && (o->flags & SEC_RELOC) == 0))
 	{
 	  if ((o->flags & SEC_RELOC) != 0
 	      && o->reloc_count != 0)
 	    {
 	      _bfd_error_handler
 		/* xgettext: c-format */
 		(_("%pB: relocs in section `%pA', but it has no contents"),
 		 input_bfd, o);
 	      bfd_set_error (bfd_error_no_contents);
 	      return false;
 	    }
 
 	  continue;
 	}
 
       secdata = coff_section_data (input_bfd, o);
       if (secdata != NULL && secdata->contents != NULL)
 	contents = secdata->contents;
       else
 	{
 	  contents = flaginfo->contents;
 	  if (! bfd_get_full_section_contents (input_bfd, o, &contents))
 	    return false;
 	}
 
       if ((o->flags & SEC_RELOC) != 0)
 	{
 	  int target_index;
 	  struct internal_reloc *internal_relocs;
 	  struct internal_reloc *irel;
 
 	  /* Read in the relocs.  */
 	  target_index = o->output_section->target_index;
 	  internal_relocs = (_bfd_coff_read_internal_relocs
 			     (input_bfd, o, false, flaginfo->external_relocs,
 			      bfd_link_relocatable (flaginfo->info),
 			      (bfd_link_relocatable (flaginfo->info)
 			       ? (flaginfo->section_info[target_index].relocs
 				  + o->output_section->reloc_count)
 			       : flaginfo->internal_relocs)));
 	  if (internal_relocs == NULL
 	      && o->reloc_count > 0)
 	    return false;
 
 	  /* Run through the relocs looking for relocs against symbols
 	     coming from discarded sections and complain about them.  */
 	  irel = internal_relocs;
 	  for (; irel < &internal_relocs[o->reloc_count]; irel++)
 	    {
 	      struct coff_link_hash_entry *h;
 	      asection *ps = NULL;
 	      long symndx = irel->r_symndx;
 	      if (symndx < 0)
 		continue;
 	      h = obj_coff_sym_hashes (input_bfd)[symndx];
 	      if (h == NULL)
 		continue;
 	      while (h->root.type == bfd_link_hash_indirect
 		     || h->root.type == bfd_link_hash_warning)
 		h = (struct coff_link_hash_entry *) h->root.u.i.link;
 	      if (h->root.type == bfd_link_hash_defined
 		  || h->root.type == bfd_link_hash_defweak)
 		ps = h->root.u.def.section;
 	      if (ps == NULL)
 		continue;
 	      /* Complain if definition comes from an excluded section.  */
 	      if (ps->flags & SEC_EXCLUDE)
 		(*flaginfo->info->callbacks->einfo)
 		  /* xgettext: c-format */
 		  (_("%X`%s' referenced in section `%pA' of %pB: "
 		     "defined in discarded section `%pA' of %pB\n"),
 		   h->root.root.string, o, input_bfd, ps, ps->owner);
 	    }
 
 	  /* Call processor specific code to relocate the section
 	     contents.  */
 	  if (! bfd_coff_relocate_section (output_bfd, flaginfo->info,
 					   input_bfd, o,
 					   contents,
 					   internal_relocs,
 					   flaginfo->internal_syms,
 					   flaginfo->sec_ptrs))
 	    return false;
 
 	  if (bfd_link_relocatable (flaginfo->info))
 	    {
 	      bfd_vma offset;
 	      struct internal_reloc *irelend;
 	      struct coff_link_hash_entry **rel_hash;
 
 	      offset = o->output_section->vma + o->output_offset - o->vma;
 	      irel = internal_relocs;
 	      irelend = irel + o->reloc_count;
 	      rel_hash = (flaginfo->section_info[target_index].rel_hashes
 			  + o->output_section->reloc_count);
 	      for (; irel < irelend; irel++, rel_hash++)
 		{
 		  struct coff_link_hash_entry *h;
 		  bool adjusted;
 
 		  *rel_hash = NULL;
 
 		  /* Adjust the reloc address and symbol index.  */
 		  irel->r_vaddr += offset;
 
 		  if (irel->r_symndx == -1)
 		    continue;
 
 		  if (adjust_symndx)
 		    {
 		      if (! (*adjust_symndx) (output_bfd, flaginfo->info,
 					      input_bfd, o, irel,
 					      &adjusted))
 			return false;
 		      if (adjusted)
 			continue;
 		    }
 
 		  h = obj_coff_sym_hashes (input_bfd)[irel->r_symndx];
 		  if (h != NULL)
 		    {
 		      /* This is a global symbol.  */
 		      if (h->indx >= 0)
 			irel->r_symndx = h->indx;
 		      else
 			{
 			  /* This symbol is being written at the end
 			     of the file, and we do not yet know the
 			     symbol index.  We save the pointer to the
 			     hash table entry in the rel_hash list.
 			     We set the indx field to -2 to indicate
 			     that this symbol must not be stripped.  */
 			  *rel_hash = h;
 			  h->indx = -2;
 			}
 		    }
 		  else
 		    {
 		      long indx;
 
 		      indx = flaginfo->sym_indices[irel->r_symndx];
 		      if (indx != -1)
 			irel->r_symndx = indx;
 		      else
 			{
 			  struct internal_syment *is;
 			  const char *name;
 			  char buf[SYMNMLEN + 1];
 
 			  /* This reloc is against a symbol we are
 			     stripping.  This should have been handled
 			     by the 'dont_skip_symbol' code in the while
 			     loop at the top of this function.  */
 			  is = flaginfo->internal_syms + irel->r_symndx;
 
 			  name = (_bfd_coff_internal_syment_name
 				  (input_bfd, is, buf));
 			  if (name == NULL)
 			    return false;
 
 			  (*flaginfo->info->callbacks->unattached_reloc)
 			    (flaginfo->info, name, input_bfd, o, irel->r_vaddr);
 			}
 		    }
 		}
 
 	      o->output_section->reloc_count += o->reloc_count;
 	    }
 	}
 
       /* Write out the modified section contents.  */
       if (secdata == NULL || secdata->stab_info == NULL)
 	{
 	  file_ptr loc = (o->output_offset
 			  * bfd_octets_per_byte (output_bfd, o));
 	  if (! bfd_set_section_contents (output_bfd, o->output_section,
 					  contents, loc, o->size))
 	    return false;
 	}
       else
 	{
 	  if (! (_bfd_write_section_stabs
 		 (output_bfd, &coff_hash_table (flaginfo->info)->stab_info,
 		  o, &secdata->stab_info, contents)))
 	    return false;
 	}
     }
 
   if (! flaginfo->info->keep_memory
       && ! _bfd_coff_free_symbols (input_bfd))
     return false;
 
   return true;
 }
 
 /* Write out a global symbol.  Called via bfd_hash_traverse.  */
diff --git a/bfd/linker.c b/bfd/linker.c
index 0f4f9a1776c..28fffc3ad63 100644
--- a/bfd/linker.c
+++ b/bfd/linker.c
@@ -532,84 +532,86 @@ struct bfd_link_hash_entry *
 bfd_wrapped_link_hash_lookup (bfd *abfd,
 			      struct bfd_link_info *info,
 			      const char *string,
 			      bool create,
 			      bool copy,
 			      bool follow)
 {
   size_t amt;
 
   if (info->wrap_hash != NULL)
     {
       const char *l;
       char prefix = '\0';
 
       l = string;
-      if (*l == bfd_get_symbol_leading_char (abfd) || *l == info->wrap_char)
+      if (*l
+	  && (*l == bfd_get_symbol_leading_char (abfd)
+	      || *l == info->wrap_char))
 	{
 	  prefix = *l;
 	  ++l;
 	}
 
 #undef WRAP
 #define WRAP "__wrap_"
 
       if (bfd_hash_lookup (info->wrap_hash, l, false, false) != NULL)
 	{
 	  char *n;
 	  struct bfd_link_hash_entry *h;
 
 	  /* This symbol is being wrapped.  We want to replace all
 	     references to SYM with references to __wrap_SYM.  */
 
 	  amt = strlen (l) + sizeof WRAP + 1;
 	  n = (char *) bfd_malloc (amt);
 	  if (n == NULL)
 	    return NULL;
 
 	  n[0] = prefix;
 	  n[1] = '\0';
 	  strcat (n, WRAP);
 	  strcat (n, l);
 	  h = bfd_link_hash_lookup (info->hash, n, create, true, follow);
 	  free (n);
 	  return h;
 	}
 
 #undef  REAL
 #define REAL "__real_"
 
       if (*l == '_'
 	  && startswith (l, REAL)
 	  && bfd_hash_lookup (info->wrap_hash, l + sizeof REAL - 1,
 			      false, false) != NULL)
 	{
 	  char *n;
 	  struct bfd_link_hash_entry *h;
 
 	  /* This is a reference to __real_SYM, where SYM is being
 	     wrapped.  We want to replace all references to __real_SYM
 	     with references to SYM.  */
 
 	  amt = strlen (l + sizeof REAL - 1) + 2;
 	  n = (char *) bfd_malloc (amt);
 	  if (n == NULL)
 	    return NULL;
 
 	  n[0] = prefix;
 	  n[1] = '\0';
 	  strcat (n, l + sizeof REAL - 1);
 	  h = bfd_link_hash_lookup (info->hash, n, create, true, follow);
 	  if (h != NULL)
 	    h->ref_real = 1;
 	  free (n);
 	  return h;
 	}
 
 #undef REAL
     }
 
   return bfd_link_hash_lookup (info->hash, string, create, copy, follow);
 }
 
 /* If H is a wrapped symbol, ie. the symbol name starts with "__wrap_"
    and the remainder is found in wrap_hash, return the real symbol.  */
@@ -618,37 +620,38 @@ struct bfd_link_hash_entry *
 unwrap_hash_lookup (struct bfd_link_info *info,
 		    bfd *input_bfd,
 		    struct bfd_link_hash_entry *h)
 {
   const char *l = h->root.string;
 
-  if (*l == bfd_get_symbol_leading_char (input_bfd)
-      || *l == info->wrap_char)
+  if (*l
+      && (*l == bfd_get_symbol_leading_char (input_bfd)
+	  || *l == info->wrap_char))
     ++l;
 
   if (startswith (l, WRAP))
     {
       l += sizeof WRAP - 1;
 
       if (bfd_hash_lookup (info->wrap_hash, l, false, false) != NULL)
 	{
 	  char save = 0;
 	  if (l - (sizeof WRAP - 1) != h->root.string)
 	    {
 	      --l;
 	      save = *l;
 	      *(char *) l = *h->root.string;
 	    }
 	  h = bfd_link_hash_lookup (info->hash, l, false, false, false);
 	  if (save)
 	    *(char *) l = save;
 	}
     }
   return h;
 }
 #undef WRAP
 
 /* Traverse a generic link hash table.  Differs from bfd_hash_traverse
    in the treatment of warning symbols.  When warning symbols are
    created they replace the real symbol, so you don't get to see the
    real symbol in a bfd_hash_traverse.  This traversal calls func with
    the real symbol.  */
diff --git a/binutils/dlltool.c b/binutils/dlltool.c
index 085d4c2ce41..6d63e11e084 100644
--- a/binutils/dlltool.c
+++ b/binutils/dlltool.c
@@ -1481,41 +1481,42 @@ static void
 scan_filtered_symbols (bfd *abfd, void *minisyms, long symcount,
 		       unsigned int size)
 {
   asymbol *store;
   bfd_byte *from, *fromend;
 
   store = bfd_make_empty_symbol (abfd);
   if (store == NULL)
     bfd_fatal (bfd_get_filename (abfd));
 
   from = (bfd_byte *) minisyms;
   fromend = from + symcount * size;
   for (; from < fromend; from += size)
     {
       asymbol *sym;
       const char *symbol_name;
 
       sym = bfd_minisymbol_to_symbol (abfd, false, from, store);
       if (sym == NULL)
 	bfd_fatal (bfd_get_filename (abfd));
 
       symbol_name = bfd_asymbol_name (sym);
-      if (bfd_get_symbol_leading_char (abfd) == symbol_name[0])
+      if (*symbol_name
+	  && *symbol_name == bfd_get_symbol_leading_char (abfd))
 	++symbol_name;
 
       def_exports (xstrdup (symbol_name) , 0, -1, 0, 0,
 		   ! (sym->flags & BSF_FUNCTION), 0, NULL);
 
       if (add_stdcall_alias && strchr (symbol_name, '@'))
         {
 	  int lead_at = (*symbol_name == '@');
 	  char *exported_name = xstrdup (symbol_name + lead_at);
 	  char *atsym = strchr (exported_name, '@');
 	  *atsym = '\0';
 	  /* Note: stdcall alias symbols can never be data.  */
 	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0, 0, NULL);
 	}
     }
 }
 
 /* Add a list of symbols to exclude.  */
