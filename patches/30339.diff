commit 7986b37aa5c991d6210ef8d430b3ef532abcb7f2
Author: Sean Parkinson <sean@wolfssl.com>
Date:   Mon Feb 8 12:24:28 2021 +1000

    SP int: fixes for 8-bit digits
    
    Fix mask type in mp_cond_copy to be at least 16 bits to handle 'used'
    being larger than 8-bit but mp_digit being 8-bit.
    When large numbers are used with 8-bit words, mul/sqr partial sums will
    overflow a word. Fix implementations to handle this.

diff --git a/wolfcrypt/src/sp_int.c b/wolfcrypt/src/sp_int.c
index 30d3d01a8..adc968c93 100644
--- a/wolfcrypt/src/sp_int.c
+++ b/wolfcrypt/src/sp_int.c
@@ -4497,3081 +4497,3097 @@ int sp_div(sp_int* a, sp_int* d, sp_int* r, sp_int* rem)
 #if defined(WOLFSSL_SP_MATH_ALL) || !defined(NO_DH) || defined(HAVE_ECC) || \
     (!defined(NO_RSA) && !defined(WOLFSSL_RSA_VERIFY_ONLY))
 #ifndef FREESCALE_LTC_TFM
 /* Calculate the remainder of dividing a by m: r = a mod m.
  *
  * @param  [in]   a  SP integer to reduce.
  * @param  [in]   m  SP integer that is the modulus.
  * @param  [out]  r  SP integer to store result in.
  *
  * @return  MP_OKAY on success.
  * @return  MP_VAL when a, m or r is NULL or m is 0.
  */
 int sp_mod(sp_int* a, sp_int* m, sp_int* r)
 {
     int err = MP_OKAY;
 #ifdef WOLFSSL_SP_INT_NEGATIVE
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif /* WOLFSSL_SMALL_STACK */
 #endif /* WOLFSSL_SP_INT_NEGATIVE */
 
     if ((a == NULL) || (m == NULL) || (r == NULL)) {
         err = MP_VAL;
     }
 
 #ifndef WOLFSSL_SP_INT_NEGATIVE
     if (err == MP_OKAY) {
         err = sp_div(a, m, NULL, r);
     }
 #else
     if (err == MP_OKAY) {
     #ifdef WOLFSSL_SMALL_STACK
         t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
         if (t == NULL) {
             err = MP_MEM;
         }
     #endif /* WOLFSSL_SMALL_STACK */
     }
     if (err == MP_OKAY) {
         sp_init(t);
         err = sp_div(a, m, NULL, t);
     }
     if (err == MP_OKAY) {
         if (t->sign != m->sign) {
             err = sp_add(t, m, r);
         }
         else {
             err = sp_copy(t, r);
         }
     }
 
 #ifdef WOLFSSL_SMALL_STACK
     if (t != NULL) {
         XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
     }
 #endif /* WOLFSSL_SMALL_STACK */
 #endif /* WOLFSSL_SP_INT_NEGATIVE */
 
     return err;
 }
 #endif /* !FREESCALE_LTC_TFM */
 #endif /* WOLFSSL_SP_MATH_ALL || !NO_DH || HAVE_ECC || \
         * (!NO_RSA && !WOLFSSL_RSA_VERIFY_ONLY) */
 
 /* START SP_MUL implementations. */
 /* This code is generated.
  * To generate:
  *   cd scripts/sp/sp_int
  *   ./gen.sh
  * File sp_mul.c contains code.
  */
 
 #ifdef SQR_MUL_ASM
     /* Multiply a by b into r where a and b have same no. digits. r = a * b
      *
      * Optimised code for when number of digits in a and b are the same.
      *
      * @param  [in]   a    SP integer to mulitply.
      * @param  [in]   b    SP integer to mulitply by.
      * @param  [out]  r    SP integer to hod reult.
      *
      * @return  MP_OKAY otherwise.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_nxn(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         int j;
         int k;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             sp_int_digit l, h, o;
             sp_int_digit* dp;
 
             h = 0;
             l = 0;
             SP_ASM_MUL(h, l, a->dp[0], b->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             for (k = 1; k <= a->used - 1; k++) {
                 j = k;
                 dp = a->dp;
                 for (; j >= 0; dp++, j--) {
                     SP_ASM_MUL_ADD(l, h, o, dp[0], b->dp[j]);
                 }
                 t->dp[k] = l;
                 l = h;
                 h = o;
                 o = 0;
             }
             for (; k <= (a->used - 1) * 2; k++) {
                 i = k - (b->used - 1);
                 dp = &b->dp[b->used - 1];
                 for (; i < a->used; i++, dp--) {
                     SP_ASM_MUL_ADD(l, h, o, a->dp[i], dp[0]);
                 }
                 t->dp[k] = l;
                 l = h;
                 h = o;
                 o = 0;
             }
             t->dp[k] = l;
             t->dp[k+1] = h;
             t->used = k + 2;
 
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 
     /* Multiply a by b into r. r = a * b
      *
      * @param  [in]   a    SP integer to mulitply.
      * @param  [in]   b    SP integer to mulitply by.
      * @param  [out]  r    SP integer to hod reult.
      *
      * @return  MP_OKAY otherwise.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         int j;
         int k;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             sp_int_digit l;
             sp_int_digit h;
             sp_int_digit o;
 
             h = 0;
             l = 0;
             SP_ASM_MUL(h, l, a->dp[0], b->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             for (k = 1; k <= b->used - 1; k++) {
                 i = 0;
                 j = k;
                 for (; (i < a->used) && (j >= 0); i++, j--) {
                     SP_ASM_MUL_ADD(l, h, o, a->dp[i], b->dp[j]);
                 }
                 t->dp[k] = l;
                 l = h;
                 h = o;
                 o = 0;
             }
             for (; k <= (a->used - 1) + (b->used - 1); k++) {
                 j = b->used - 1;
                 i = k - j;
                 for (; (i < a->used) && (j >= 0); i++, j--) {
                     SP_ASM_MUL_ADD(l, h, o, a->dp[i], b->dp[j]);
                 }
                 t->dp[k] = l;
                 l = h;
                 h = o;
                 o = 0;
             }
             t->dp[k] = l;
             t->dp[k+1] = h;
             t->used = k + 2;
 
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #else
     /* Multiply a by b into r. r = a * b
      *
      * @param  [in]   a    SP integer to mulitply.
      * @param  [in]   b    SP integer to mulitply by.
      * @param  [out]  r    SP integer to hod reult.
      *
      * @return  MP_OKAY otherwise.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         int j;
         int k;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             sp_int_word w;
             sp_int_word l;
             sp_int_word h;
+        #ifdef SP_WORD_OVERFLOW
+            sp_int_word o;
+        #endif
 
             w = (sp_int_word)a->dp[0] * b->dp[0];
             t->dp[0] = (sp_int_digit)w;
             l = (sp_int_digit)(w >> SP_WORD_SIZE);
             h = 0;
+        #ifdef SP_WORD_OVERFLOW
+            o = 0;
+        #endif
             for (k = 1; k <= (a->used - 1) + (b->used - 1); k++) {
                 i = k - (b->used - 1);
                 i &= ~(i >> (sizeof(i) * 8 - 1));
                 j = k - i;
                 for (; (i < a->used) && (j >= 0); i++, j--) {
                     w = (sp_int_word)a->dp[i] * b->dp[j];
                     l += (sp_int_digit)w;
                     h += (sp_int_digit)(w >> SP_WORD_SIZE);
+                #ifdef SP_WORD_OVERFLOW
+                    h += (sp_int_digit)(l >> SP_WORD_SIZE);
+                    l &= SP_MASK;
+                    o += (sp_int_digit)(h >> SP_WORD_SIZE);
+                    h &= SP_MASK;
+                #endif
                 }
                 t->dp[k] = (sp_int_digit)l;
                 l >>= SP_WORD_SIZE;
                 l += (sp_int_digit)h;
                 h >>= SP_WORD_SIZE;
+            #ifdef SP_WORD_OVERFLOW
+                h += o & SP_MASK;
+                o >>= SP_WORD_SIZE;
+            #endif
             }
             t->dp[k] = (sp_int_digit)l;
             t->dp[k+1] = (sp_int_digit)h;
             t->used = k + 2;
 
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #endif
 
 #ifndef WOLFSSL_SP_SMALL
 #if !defined(WOLFSSL_HAVE_SP_ECC) && defined(HAVE_ECC)
 #if SP_WORD_SIZE == 64
 #ifndef SQR_MUL_ASM
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_4(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int_word* w = NULL;
     #else
         sp_int_word w[16];
     #endif
         sp_int_digit* da = a->dp;
         sp_int_digit* db = b->dp;
 
     #ifdef WOLFSSL_SMALL_STACK
          w = (sp_int_word*)XMALLOC(sizeof(sp_int_word) * 16, NULL,
                                    DYNAMIC_TYPE_BIGINT);
          if (w == NULL) {
              err = MP_MEM;
          }
     #endif
 
         if (err == MP_OKAY) {
             w[0] = (sp_int_word)da[0] * db[0];
             w[1] = (sp_int_word)da[0] * db[1];
             w[2] = (sp_int_word)da[1] * db[0];
             w[3] = (sp_int_word)da[0] * db[2];
             w[4] = (sp_int_word)da[1] * db[1];
             w[5] = (sp_int_word)da[2] * db[0];
             w[6] = (sp_int_word)da[0] * db[3];
             w[7] = (sp_int_word)da[1] * db[2];
             w[8] = (sp_int_word)da[2] * db[1];
             w[9] = (sp_int_word)da[3] * db[0];
             w[10] = (sp_int_word)da[1] * db[3];
             w[11] = (sp_int_word)da[2] * db[2];
             w[12] = (sp_int_word)da[3] * db[1];
             w[13] = (sp_int_word)da[2] * db[3];
             w[14] = (sp_int_word)da[3] * db[2];
             w[15] = (sp_int_word)da[3] * db[3];
 
             r->dp[0] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[1];
             w[0] += (sp_int_digit)w[2];
             r->dp[1] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[1] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[1];
             w[2] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[2];
             w[0] += (sp_int_digit)w[3];
             w[0] += (sp_int_digit)w[4];
             w[0] += (sp_int_digit)w[5];
             r->dp[2] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[3] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[3];
             w[4] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[4];
             w[5] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[5];
             w[0] += (sp_int_digit)w[6];
             w[0] += (sp_int_digit)w[7];
             w[0] += (sp_int_digit)w[8];
             w[0] += (sp_int_digit)w[9];
             r->dp[3] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[6] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[6];
             w[7] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[7];
             w[8] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[8];
             w[9] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[9];
             w[0] += (sp_int_digit)w[10];
             w[0] += (sp_int_digit)w[11];
             w[0] += (sp_int_digit)w[12];
             r->dp[4] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[10] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[10];
             w[11] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[11];
             w[12] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[12];
             w[0] += (sp_int_digit)w[13];
             w[0] += (sp_int_digit)w[14];
             r->dp[5] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[13] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[13];
             w[14] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[14];
             w[0] += (sp_int_digit)w[15];
             r->dp[6] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[15] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[15];
             r->dp[7] = w[0];
 
             r->used = 8;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (w != NULL) {
             XFREE(w, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
         return err;
     }
 #else /* SQR_MUL_ASM */
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_4(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_MUL(h, l, a->dp[0], b->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[0]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[0]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[0]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[1]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[2]);
             t->dp[5] = l;
             l = h;
             h = o;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[3], b->dp[3]);
             t->dp[6] = l;
             t->dp[7] = h;
             t->used = 8;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #endif /* SQR_MUL_ASM */
 #endif /* SP_WORD_SIZE == 64 */
 #if SP_WORD_SIZE == 64
 #ifdef SQR_MUL_ASM
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_6(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_MUL(h, l, a->dp[0], b->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[0]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[0]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[0]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[0]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[0]);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[1]);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[2]);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[3]);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[4]);
             t->dp[9] = l;
             l = h;
             h = o;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[5], b->dp[5]);
             t->dp[10] = l;
             t->dp[11] = h;
             t->used = 12;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #endif /* SQR_MUL_ASM */
 #endif /* SP_WORD_SIZE == 64 */
 #if SP_WORD_SIZE == 32
 #ifdef SQR_MUL_ASM
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_8(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_MUL(h, l, a->dp[0], b->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[0]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[0]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[0]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[0]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[0]);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[0]);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[0]);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[1]);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[2]);
             t->dp[9] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[3]);
             t->dp[10] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[4]);
             t->dp[11] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[5]);
             t->dp[12] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[6]);
             t->dp[13] = l;
             l = h;
             h = o;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[7], b->dp[7]);
             t->dp[14] = l;
             t->dp[15] = h;
             t->used = 16;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #endif /* SQR_MUL_ASM */
 #endif /* SP_WORD_SIZE == 32 */
 #if SP_WORD_SIZE == 32
 #ifdef SQR_MUL_ASM
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_12(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_MUL(h, l, a->dp[0], b->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[0]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[0]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[0]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[0]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[0]);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[0]);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[0]);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[0]);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[0]);
             t->dp[9] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[0]);
             t->dp[10] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[0]);
             t->dp[11] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[1]);
             t->dp[12] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[2]);
             t->dp[13] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[3]);
             t->dp[14] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[4]);
             t->dp[15] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[5]);
             t->dp[16] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[6]);
             t->dp[17] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[7]);
             t->dp[18] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[8]);
             t->dp[19] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[9]);
             t->dp[20] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[10]);
             t->dp[21] = l;
             l = h;
             h = o;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[11], b->dp[11]);
             t->dp[22] = l;
             t->dp[23] = h;
             t->used = 24;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #endif /* SQR_MUL_ASM */
 #endif /* SP_WORD_SIZE == 32 */
 #endif /* !WOLFSSL_HAVE_SP_ECC && HAVE_ECC */
 
 #if defined(SQR_MUL_ASM) && defined(WOLFSSL_SP_INT_LARGE_COMBA)
     #if SP_INT_DIGITS >= 32
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_16(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_MUL(h, l, a->dp[0], b->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[0]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[0]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[0]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[0]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[0]);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[0]);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[0]);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[0]);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[0]);
             t->dp[9] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[0]);
             t->dp[10] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[0]);
             t->dp[11] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[0]);
             t->dp[12] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[0]);
             t->dp[13] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[0]);
             t->dp[14] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[0]);
             t->dp[15] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[1]);
             t->dp[16] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[2]);
             t->dp[17] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[3]);
             t->dp[18] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[4]);
             t->dp[19] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[5]);
             t->dp[20] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[6]);
             t->dp[21] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[7]);
             t->dp[22] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[8]);
             t->dp[23] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[9]);
             t->dp[24] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[10]);
             t->dp[25] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[11]);
             t->dp[26] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[12]);
             t->dp[27] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[13]);
             t->dp[28] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[14]);
             t->dp[29] = l;
             l = h;
             h = o;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[15], b->dp[15]);
             t->dp[30] = l;
             t->dp[31] = h;
             t->used = 32;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 32 */
 
     #if SP_INT_DIGITS >= 48
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_24(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_MUL(h, l, a->dp[0], b->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[0]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[0], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[0]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[0]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[0]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[0]);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[0]);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[0]);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[0]);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[0]);
             t->dp[9] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[0]);
             t->dp[10] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[0]);
             t->dp[11] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[0]);
             t->dp[12] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[0]);
             t->dp[13] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[0]);
             t->dp[14] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[0]);
             t->dp[15] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[0]);
             t->dp[16] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[0]);
             t->dp[17] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[0]);
             t->dp[18] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[0]);
             t->dp[19] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[0]);
             t->dp[20] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[0]);
             t->dp[21] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[0]);
             t->dp[22] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[0], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[1]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[0]);
             t->dp[23] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[1], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[2]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[1]);
             t->dp[24] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[2], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[3]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[2]);
             t->dp[25] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[3], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[4]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[3]);
             t->dp[26] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[4], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[5]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[4]);
             t->dp[27] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[5], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[6]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[5]);
             t->dp[28] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[6], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[7]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[6]);
             t->dp[29] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[7], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[8]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[7]);
             t->dp[30] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[8], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[9]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[8]);
             t->dp[31] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[9], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[10]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[9]);
             t->dp[32] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[10], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[11]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[10]);
             t->dp[33] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[11], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[12]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[11]);
             t->dp[34] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[12], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[13]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[12]);
             t->dp[35] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[13], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[14]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[13]);
             t->dp[36] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[14], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[15]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[14]);
             t->dp[37] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[15], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[16]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[15]);
             t->dp[38] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[16], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[17]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[16]);
             t->dp[39] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[17], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[18]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[17]);
             t->dp[40] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[18], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[19]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[18]);
             t->dp[41] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[19], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[20]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[19]);
             t->dp[42] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[20], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[21]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[20]);
             t->dp[43] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[21], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[22]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[21]);
             t->dp[44] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD(l, h, o, a->dp[22], b->dp[23]);
             SP_ASM_MUL_ADD(l, h, o, a->dp[23], b->dp[22]);
             t->dp[45] = l;
             l = h;
             h = o;
             SP_ASM_MUL_ADD_NO(l, h, a->dp[23], b->dp[23]);
             t->dp[46] = l;
             t->dp[47] = h;
             t->used = 48;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 48 */
 
     #if SP_INT_DIGITS >= 64
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_32(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         sp_int_digit l;
         sp_int_digit h;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[4];
     #endif
         sp_int* a1;
         sp_int* b1;
         sp_int* z0;
         sp_int* z1;
         sp_int* z2;
         sp_int_digit ca;
         sp_int_digit cb;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int) * 4, NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             a1 = &t[0];
             b1 = &t[1];
             z0 = r;
             z1 = &t[2];
             z2 = &t[3];
 
             XMEMCPY(a1->dp, &a->dp[16], sizeof(sp_int_digit) * 16);
             a1->used = 16;
             XMEMCPY(b1->dp, &b->dp[16], sizeof(sp_int_digit) * 16);
             b1->used = 16;
 
             /* z2 = a1 * b1 */
             err = _sp_mul_16(a1, b1, z2);
         }
         if (err == MP_OKAY) {
             l = a1->dp[0];
             h = 0;
             SP_ASM_ADDC(l, h, a->dp[0]);
             a1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 16; i++) {
                 SP_ASM_ADDC(l, h, a1->dp[i]);
                 SP_ASM_ADDC(l, h, a->dp[i]);
                 a1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             ca = l;
             /* b01 = b0 + b1 */
             l = b1->dp[0];
             h = 0;
             SP_ASM_ADDC(l, h, b->dp[0]);
             b1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 16; i++) {
                 SP_ASM_ADDC(l, h, b1->dp[i]);
                 SP_ASM_ADDC(l, h, b->dp[i]);
                 b1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             cb = l;
 
             /* z0 = a0 * b0 */
             err = _sp_mul_16(a, b, z0);
         }
         if (err == MP_OKAY) {
             /* z1 = (a0 + a1) * (b0 + b1) */
             err = _sp_mul_16(a1, b1, z1);
         }
         if (err == MP_OKAY) {
             /* r = (z2 << 32) + (z1 - z0 - z2) << 16) + z0 */
             /* r = z0 */
             /* r += (z1 - z0 - z2) << 16 */
             z1->dp[32] = ca & cb;
             z1->used = 33;
             if (ca) {
                 l = 0;
                 h = 0;
                 for (i = 0; i < 16; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 16]);
                     SP_ASM_ADDC(l, h, b1->dp[i]);
                     z1->dp[i + 16] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[32] += l;
             }
             if (cb) {
                 l = 0;
                 h = 0;
                 for (i = 0; i < 16; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 16]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     z1->dp[i + 16] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[32] += l;
             }
             /* z1 = z1 - z0 - z1 */
             l = 0;
             h = 0;
             for (i = 0; i < 32; i++) {
                 l += z1->dp[i];
                 SP_ASM_SUBC(l, h, z0->dp[i]);
                 SP_ASM_SUBC(l, h, z2->dp[i]);
                 z1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             z1->dp[i] += l;
             /* r += z1 << 16 */
             l = 0;
             h = 0;
             for (i = 0; i < 16; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 16]);
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 16] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 33; i++) {
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 16] = l;
                 l = h;
                 h = 0;
             }
             /* r += z2 << 32  */
             l = 0;
             h = 0;
             for (i = 0; i < 17; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 32]);
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 32] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 32; i++) {
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 32] = l;
                 l = h;
                 h = 0;
             }
             r->used = 64;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 64 */
 
     #if SP_INT_DIGITS >= 96
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_48(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         sp_int_digit l;
         sp_int_digit h;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[4];
     #endif
         sp_int* a1;
         sp_int* b1;
         sp_int* z0;
         sp_int* z1;
         sp_int* z2;
         sp_int_digit ca;
         sp_int_digit cb;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int) * 4, NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             a1 = &t[0];
             b1 = &t[1];
             z0 = r;
             z1 = &t[2];
             z2 = &t[3];
 
             XMEMCPY(a1->dp, &a->dp[24], sizeof(sp_int_digit) * 24);
             a1->used = 24;
             XMEMCPY(b1->dp, &b->dp[24], sizeof(sp_int_digit) * 24);
             b1->used = 24;
 
             /* z2 = a1 * b1 */
             err = _sp_mul_24(a1, b1, z2);
         }
         if (err == MP_OKAY) {
             l = a1->dp[0];
             h = 0;
             SP_ASM_ADDC(l, h, a->dp[0]);
             a1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 24; i++) {
                 SP_ASM_ADDC(l, h, a1->dp[i]);
                 SP_ASM_ADDC(l, h, a->dp[i]);
                 a1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             ca = l;
             /* b01 = b0 + b1 */
             l = b1->dp[0];
             h = 0;
             SP_ASM_ADDC(l, h, b->dp[0]);
             b1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 24; i++) {
                 SP_ASM_ADDC(l, h, b1->dp[i]);
                 SP_ASM_ADDC(l, h, b->dp[i]);
                 b1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             cb = l;
 
             /* z0 = a0 * b0 */
             err = _sp_mul_24(a, b, z0);
         }
         if (err == MP_OKAY) {
             /* z1 = (a0 + a1) * (b0 + b1) */
             err = _sp_mul_24(a1, b1, z1);
         }
         if (err == MP_OKAY) {
             /* r = (z2 << 48) + (z1 - z0 - z2) << 24) + z0 */
             /* r = z0 */
             /* r += (z1 - z0 - z2) << 24 */
             z1->dp[48] = ca & cb;
             z1->used = 49;
             if (ca) {
                 l = 0;
                 h = 0;
                 for (i = 0; i < 24; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 24]);
                     SP_ASM_ADDC(l, h, b1->dp[i]);
                     z1->dp[i + 24] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[48] += l;
             }
             if (cb) {
                 l = 0;
                 h = 0;
                 for (i = 0; i < 24; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 24]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     z1->dp[i + 24] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[48] += l;
             }
             /* z1 = z1 - z0 - z1 */
             l = 0;
             h = 0;
             for (i = 0; i < 48; i++) {
                 l += z1->dp[i];
                 SP_ASM_SUBC(l, h, z0->dp[i]);
                 SP_ASM_SUBC(l, h, z2->dp[i]);
                 z1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             z1->dp[i] += l;
             /* r += z1 << 16 */
             l = 0;
             h = 0;
             for (i = 0; i < 24; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 24]);
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 24] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 49; i++) {
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 24] = l;
                 l = h;
                 h = 0;
             }
             /* r += z2 << 48  */
             l = 0;
             h = 0;
             for (i = 0; i < 25; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 48]);
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 48] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 48; i++) {
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 48] = l;
                 l = h;
                 h = 0;
             }
             r->used = 96;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 96 */
 
     #if SP_INT_DIGITS >= 128
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_64(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         sp_int_digit l;
         sp_int_digit h;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[4];
     #endif
         sp_int* a1;
         sp_int* b1;
         sp_int* z0;
         sp_int* z1;
         sp_int* z2;
         sp_int_digit ca;
         sp_int_digit cb;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int) * 4, NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             a1 = &t[0];
             b1 = &t[1];
             z0 = r;
             z1 = &t[2];
             z2 = &t[3];
 
             XMEMCPY(a1->dp, &a->dp[32], sizeof(sp_int_digit) * 32);
             a1->used = 32;
             XMEMCPY(b1->dp, &b->dp[32], sizeof(sp_int_digit) * 32);
             b1->used = 32;
 
             /* z2 = a1 * b1 */
             err = _sp_mul_32(a1, b1, z2);
         }
         if (err == MP_OKAY) {
             l = a1->dp[0];
             h = 0;
             SP_ASM_ADDC(l, h, a->dp[0]);
             a1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 32; i++) {
                 SP_ASM_ADDC(l, h, a1->dp[i]);
                 SP_ASM_ADDC(l, h, a->dp[i]);
                 a1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             ca = l;
             /* b01 = b0 + b1 */
             l = b1->dp[0];
             h = 0;
             SP_ASM_ADDC(l, h, b->dp[0]);
             b1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 32; i++) {
                 SP_ASM_ADDC(l, h, b1->dp[i]);
                 SP_ASM_ADDC(l, h, b->dp[i]);
                 b1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             cb = l;
 
             /* z0 = a0 * b0 */
             err = _sp_mul_32(a, b, z0);
         }
         if (err == MP_OKAY) {
             /* z1 = (a0 + a1) * (b0 + b1) */
             err = _sp_mul_32(a1, b1, z1);
         }
         if (err == MP_OKAY) {
             /* r = (z2 << 64) + (z1 - z0 - z2) << 32) + z0 */
             /* r = z0 */
             /* r += (z1 - z0 - z2) << 32 */
             z1->dp[64] = ca & cb;
             z1->used = 65;
             if (ca) {
                 l = 0;
                 h = 0;
                 for (i = 0; i < 32; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 32]);
                     SP_ASM_ADDC(l, h, b1->dp[i]);
                     z1->dp[i + 32] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[64] += l;
             }
             if (cb) {
                 l = 0;
                 h = 0;
                 for (i = 0; i < 32; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 32]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     z1->dp[i + 32] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[64] += l;
             }
             /* z1 = z1 - z0 - z1 */
             l = 0;
             h = 0;
             for (i = 0; i < 64; i++) {
                 l += z1->dp[i];
                 SP_ASM_SUBC(l, h, z0->dp[i]);
                 SP_ASM_SUBC(l, h, z2->dp[i]);
                 z1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             z1->dp[i] += l;
             /* r += z1 << 16 */
             l = 0;
             h = 0;
             for (i = 0; i < 32; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 32]);
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 32] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 65; i++) {
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 32] = l;
                 l = h;
                 h = 0;
             }
             /* r += z2 << 64  */
             l = 0;
             h = 0;
             for (i = 0; i < 33; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 64]);
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 64] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 64; i++) {
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 64] = l;
                 l = h;
                 h = 0;
             }
             r->used = 128;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 128 */
 
     #if SP_INT_DIGITS >= 192
     /* Multiply a by b and store in r: r = a * b
      *
      * @param  [in]   a  SP integer to multiply.
      * @param  [in]   b  SP integer to multiply.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_mul_96(sp_int* a, sp_int* b, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         sp_int_digit l;
         sp_int_digit h;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[4];
     #endif
         sp_int* a1;
         sp_int* b1;
         sp_int* z0;
         sp_int* z1;
         sp_int* z2;
         sp_int_digit ca;
         sp_int_digit cb;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int) * 4, NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             a1 = &t[0];
             b1 = &t[1];
             z0 = r;
             z1 = &t[2];
             z2 = &t[3];
 
             XMEMCPY(a1->dp, &a->dp[48], sizeof(sp_int_digit) * 48);
             a1->used = 48;
             XMEMCPY(b1->dp, &b->dp[48], sizeof(sp_int_digit) * 48);
             b1->used = 48;
 
             /* z2 = a1 * b1 */
             err = _sp_mul_48(a1, b1, z2);
         }
         if (err == MP_OKAY) {
             l = a1->dp[0];
             h = 0;
             SP_ASM_ADDC(l, h, a->dp[0]);
             a1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 48; i++) {
                 SP_ASM_ADDC(l, h, a1->dp[i]);
                 SP_ASM_ADDC(l, h, a->dp[i]);
                 a1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             ca = l;
             /* b01 = b0 + b1 */
             l = b1->dp[0];
             h = 0;
             SP_ASM_ADDC(l, h, b->dp[0]);
             b1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 48; i++) {
                 SP_ASM_ADDC(l, h, b1->dp[i]);
                 SP_ASM_ADDC(l, h, b->dp[i]);
                 b1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             cb = l;
 
             /* z0 = a0 * b0 */
             err = _sp_mul_48(a, b, z0);
         }
         if (err == MP_OKAY) {
             /* z1 = (a0 + a1) * (b0 + b1) */
             err = _sp_mul_48(a1, b1, z1);
         }
         if (err == MP_OKAY) {
             /* r = (z2 << 96) + (z1 - z0 - z2) << 48) + z0 */
             /* r = z0 */
             /* r += (z1 - z0 - z2) << 48 */
             z1->dp[96] = ca & cb;
             z1->used = 97;
             if (ca) {
                 l = 0;
                 h = 0;
                 for (i = 0; i < 48; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 48]);
                     SP_ASM_ADDC(l, h, b1->dp[i]);
                     z1->dp[i + 48] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[96] += l;
             }
             if (cb) {
                 l = 0;
                 h = 0;
                 for (i = 0; i < 48; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 48]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     z1->dp[i + 48] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[96] += l;
             }
             /* z1 = z1 - z0 - z1 */
             l = 0;
             h = 0;
             for (i = 0; i < 96; i++) {
                 l += z1->dp[i];
                 SP_ASM_SUBC(l, h, z0->dp[i]);
                 SP_ASM_SUBC(l, h, z2->dp[i]);
                 z1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             z1->dp[i] += l;
             /* r += z1 << 16 */
             l = 0;
             h = 0;
             for (i = 0; i < 48; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 48]);
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 48] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 97; i++) {
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 48] = l;
                 l = h;
                 h = 0;
             }
             /* r += z2 << 96  */
             l = 0;
             h = 0;
             for (i = 0; i < 49; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 96]);
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 96] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 96; i++) {
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 96] = l;
                 l = h;
                 h = 0;
             }
             r->used = 192;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 192 */
 
 #endif /* SQR_MUL_ASM && WOLFSSL_SP_INT_LARGE_COMBA */
 #endif /* !WOLFSSL_SP_SMALL */
 
 /* Multiply a by b and store in r: r = a * b
  *
  * @param  [in]   a  SP integer to multiply.
  * @param  [in]   b  SP integer to multiply.
  * @param  [out]  r  SP integer result.
  *
  * @return  MP_OKAY on success.
  * @return  MP_VAL when a, b or is NULL; or the result will be too big for fixed
  *          data length.
  * @return  MP_MEM when dynamic memory allocation fails.
  */
@@ -9316,2475 +9332,2505 @@ int sp_mod_2d(sp_int* a, int e, sp_int* r)
 #ifdef WOLFSSL_SP_MATH_ALL
 /* Multiply by 2^e: r = a << e
  *
  * @param  [in]   a  SP integer to multiply.
  * @param  [in]   e  Multiplier bits (multiplier equals 2^e).
  * @param  [out]  r  SP integer to hold result.
  *
  * @return  MP_OKAY on success.
  * @return  MP_VAL when a or r is NULL, or result is too big for fixed data
  *          length.
  */
 int sp_mul_2d(sp_int* a, int e, sp_int* r)
 {
     int err = MP_OKAY;
 
     if ((a == NULL) || (r == NULL)) {
         err = MP_VAL;
     }
 
     if ((err == MP_OKAY) && (sp_count_bits(a) + e > r->size * SP_WORD_SIZE)) {
         err = MP_VAL;
     }
 
     if (err == MP_OKAY) {
         /* Copy a into r as left shift function works on the number. */
         if (a != r) {
             err = sp_copy(a, r);
         }
     }
 
     if (err == MP_OKAY) {
         if (0) {
             sp_print(a, "a");
             sp_print_int(e, "n");
         }
         err = sp_lshb(r, e);
         if (0) {
             sp_print(r, "rsl");
         }
     }
 
     return err;
 }
 #endif /* WOLFSSL_SP_MATH_ALL */
 
 #if defined(WOLFSSL_SP_MATH_ALL) || defined(WOLFSSL_HAVE_SP_DH) || \
     defined(HAVE_ECC) || (!defined(NO_RSA) && !defined(WOLFSSL_RSA_VERIFY_ONLY))
 
 /* START SP_SQR implementations */
 /* This code is generated.
  * To generate:
  *   cd scripts/sp/sp_int
  *   ./gen.sh
  * File sp_sqr.c contains code.
  */
 
 #if !defined(WOLFSSL_SP_MATH) || !defined(WOLFSSL_SP_SMALL)
 #ifdef SQR_MUL_ASM
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         int j;
         int k;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
         if ((err == MP_OKAY) && (a->used <= 1)) {
             sp_int_digit l, h;
 
             h = 0;
             l = 0;
             SP_ASM_SQR(h, l, a->dp[0]);
             t->dp[0] = h;
             t->dp[1] = l;
             t->used = a->used * 2;
         }
         else if (err == MP_OKAY) {
             sp_int_digit l, h, o;
 
             h = 0;
             l = 0;
             SP_ASM_SQR(h, l, a->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             for (k = 1; k < (a->used + 1) / 2; k++) {
                 i = k;
                 j = k - 1;
                 for (; (j >= 0); i++, j--) {
                     SP_ASM_MUL_ADD2(l, h, o, a->dp[i], a->dp[j]);
                 }
                 t->dp[k * 2 - 1] = l;
                 l = h;
                 h = o;
                 o = 0;
 
                 SP_ASM_SQR_ADD(l, h, o, a->dp[k]);
                 i = k + 1;
                 j = k - 1;
                 for (; (j >= 0); i++, j--) {
                     SP_ASM_MUL_ADD2(l, h, o, a->dp[i], a->dp[j]);
                 }
                 t->dp[k * 2] = l;
                 l = h;
                 h = o;
                 o = 0;
             }
             for (; k < a->used; k++) {
                 i = k;
                 j = k - 1;
                 for (; (i < a->used); i++, j--) {
                     SP_ASM_MUL_ADD2(l, h, o, a->dp[i], a->dp[j]);
                 }
                 t->dp[k * 2 - 1] = l;
                 l = h;
                 h = o;
                 o = 0;
 
                 SP_ASM_SQR_ADD(l, h, o, a->dp[k]);
                 i = k + 1;
                 j = k - 1;
                 for (; (i < a->used); i++, j--) {
                     SP_ASM_MUL_ADD2(l, h, o, a->dp[i], a->dp[j]);
                 }
                 t->dp[k * 2] = l;
                 l = h;
                 h = o;
                 o = 0;
             }
             t->dp[k * 2 - 1] = l;
             t->dp[k * 2] = h;
             t->used = a->used * 2;
         }
 
         if (err == MP_OKAY) {
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL)
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
     #endif
 
         return err;
     }
 #else /* !SQR_MUL_ASM */
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         int j;
         int k;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
-            sp_int_word w, l, h;
+            sp_int_word w;
+            sp_int_word l;
+            sp_int_word h;
+        #ifdef SP_WORD_OVERFLOW
+            sp_int_word o;
+        #endif
 
             w = (sp_int_word)a->dp[0] * a->dp[0];
             t->dp[0] = (sp_int_digit)w;
             l = (sp_int_digit)(w >> SP_WORD_SIZE);
             h = 0;
+        #ifdef SP_WORD_OVERFLOW
+            o = 0;
+        #endif
             for (k = 1; k <= (a->used - 1) * 2; k++) {
                 i = k / 2;
                 j = k - i;
                 if (i == j) {
                     w = (sp_int_word)a->dp[i] * a->dp[j];
                     l += (sp_int_digit)w;
                     h += (sp_int_digit)(w >> SP_WORD_SIZE);
+                #ifdef SP_WORD_OVERFLOW
+                    h += (sp_int_digit)(l >> SP_WORD_SIZE);
+                    l &= SP_MASK;
+                    o += (sp_int_digit)(h >> SP_WORD_SIZE);
+                    h &= SP_MASK;
+                #endif
                 }
                 for (++i, --j; (i < a->used) && (j >= 0); i++, j--) {
                     w = (sp_int_word)a->dp[i] * a->dp[j];
                     l += (sp_int_digit)w;
                     h += (sp_int_digit)(w >> SP_WORD_SIZE);
+                #ifdef SP_WORD_OVERFLOW
+                    h += (sp_int_digit)(l >> SP_WORD_SIZE);
+                    l &= SP_MASK;
+                    o += (sp_int_digit)(h >> SP_WORD_SIZE);
+                    h &= SP_MASK;
+                #endif
                     l += (sp_int_digit)w;
                     h += (sp_int_digit)(w >> SP_WORD_SIZE);
+                #ifdef SP_WORD_OVERFLOW
+                    h += (sp_int_digit)(l >> SP_WORD_SIZE);
+                    l &= SP_MASK;
+                    o += (sp_int_digit)(h >> SP_WORD_SIZE);
+                    h &= SP_MASK;
+                #endif
                 }
                 t->dp[k] = (sp_int_digit)l;
                 l >>= SP_WORD_SIZE;
                 l += (sp_int_digit)h;
                 h >>= SP_WORD_SIZE;
+            #ifdef SP_WORD_OVERFLOW
+                h += o & SP_MASK;
+                o >>= SP_WORD_SIZE;
+            #endif
             }
             t->dp[k] = (sp_int_digit)l;
             t->dp[k+1] = (sp_int_digit)h;
             t->used = k + 2;
 
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
         return err;
     }
 #endif /* SQR_MUL_ASM */
 #endif /* !WOLFSSL_SP_MATH || !WOLFSSL_SP_SMALL */
 
 #ifndef WOLFSSL_SP_SMALL
 #if !defined(WOLFSSL_HAVE_SP_ECC) && defined(HAVE_ECC)
 #if SP_WORD_SIZE == 64
 #ifndef SQR_MUL_ASM
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_4(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int_word* w = NULL;
     #else
         sp_int_word w[10];
     #endif
         sp_int_digit* da = a->dp;
 
     #ifdef WOLFSSL_SMALL_STACK
          w = (sp_int_word*)XMALLOC(sizeof(sp_int_word) * 10, NULL,
                                    DYNAMIC_TYPE_BIGINT);
          if (w == NULL) {
              err = MP_MEM;
          }
     #endif
 
 
         if (err == MP_OKAY) {
             w[0] = (sp_int_word)da[0] * da[0];
             w[1] = (sp_int_word)da[0] * da[1];
             w[2] = (sp_int_word)da[0] * da[2];
             w[3] = (sp_int_word)da[1] * da[1];
             w[4] = (sp_int_word)da[0] * da[3];
             w[5] = (sp_int_word)da[1] * da[2];
             w[6] = (sp_int_word)da[1] * da[3];
             w[7] = (sp_int_word)da[2] * da[2];
             w[8] = (sp_int_word)da[2] * da[3];
             w[9] = (sp_int_word)da[3] * da[3];
 
             r->dp[0] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[1];
             w[0] += (sp_int_digit)w[1];
             r->dp[1] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[1] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[1];
             w[0] += (sp_int_digit)w[1];
             w[0] += (sp_int_digit)w[2];
             w[0] += (sp_int_digit)w[2];
             w[0] += (sp_int_digit)w[3];
             r->dp[2] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[2] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[2];
             w[0] += (sp_int_digit)w[2];
             w[3] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[3];
             w[0] += (sp_int_digit)w[4];
             w[0] += (sp_int_digit)w[4];
             w[0] += (sp_int_digit)w[5];
             w[0] += (sp_int_digit)w[5];
             r->dp[3] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[4] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[4];
             w[0] += (sp_int_digit)w[4];
             w[5] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[5];
             w[0] += (sp_int_digit)w[5];
             w[0] += (sp_int_digit)w[6];
             w[0] += (sp_int_digit)w[6];
             w[0] += (sp_int_digit)w[7];
             r->dp[4] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[6] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[6];
             w[0] += (sp_int_digit)w[6];
             w[7] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[7];
             w[0] += (sp_int_digit)w[8];
             w[0] += (sp_int_digit)w[8];
             r->dp[5] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[8] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[8];
             w[0] += (sp_int_digit)w[8];
             w[0] += (sp_int_digit)w[9];
             r->dp[6] = w[0];
             w[0] >>= SP_WORD_SIZE;
             w[9] >>= SP_WORD_SIZE;
             w[0] += (sp_int_digit)w[9];
             r->dp[7] = w[0];
 
             r->used = 8;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (w != NULL) {
             XFREE(w, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
         return err;
     }
 #else /* SQR_MUL_ASM */
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_4(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_SQR(h, l, a->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[1]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[2]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[1]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[3]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[2]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[3]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[2]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[2], a->dp[3]);
             t->dp[5] = l;
             l = h;
             h = o;
             SP_ASM_SQR_ADD_NO(l, h, a->dp[3]);
             t->dp[6] = l;
             t->dp[7] = h;
             t->used = 8;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #endif /* SQR_MUL_ASM */
 #endif /* SP_WORD_SIZE == 64 */
 #if SP_WORD_SIZE == 64
 #ifdef SQR_MUL_ASM
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_6(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
         sp_int_digit tl;
         sp_int_digit th;
         sp_int_digit to;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
         tl = 0;
         th = 0;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_SQR(h, l, a->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[1]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[2]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[1]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[3]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[2]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[4]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[3]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[2]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[4]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[3]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[5]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[2], a->dp[4]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[3]);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[2], a->dp[5]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[3], a->dp[4]);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[3], a->dp[5]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[4]);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[4], a->dp[5]);
             t->dp[9] = l;
             l = h;
             h = o;
             SP_ASM_SQR_ADD_NO(l, h, a->dp[5]);
             t->dp[10] = l;
             t->dp[11] = h;
             t->used = 12;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #endif /* SQR_MUL_ASM */
 #endif /* SP_WORD_SIZE == 64 */
 #if SP_WORD_SIZE == 32
 #ifdef SQR_MUL_ASM
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_8(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
         sp_int_digit tl;
         sp_int_digit th;
         sp_int_digit to;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
         tl = 0;
         th = 0;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_SQR(h, l, a->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[1]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[2]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[1]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[3]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[2]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[4]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[3]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[2]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[4]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[3]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[4]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[3]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[4]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[1], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[5]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[4]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[2], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[5]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[9] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[3], a->dp[7]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[4], a->dp[6]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[5]);
             t->dp[10] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[4], a->dp[7]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[5], a->dp[6]);
             t->dp[11] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[5], a->dp[7]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[6]);
             t->dp[12] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[6], a->dp[7]);
             t->dp[13] = l;
             l = h;
             h = o;
             SP_ASM_SQR_ADD_NO(l, h, a->dp[7]);
             t->dp[14] = l;
             t->dp[15] = h;
             t->used = 16;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #endif /* SQR_MUL_ASM */
 #endif /* SP_WORD_SIZE == 32 */
 #if SP_WORD_SIZE == 32
 #ifdef SQR_MUL_ASM
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_12(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
         sp_int_digit tl;
         sp_int_digit th;
         sp_int_digit to;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
         tl = 0;
         th = 0;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_SQR(h, l, a->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[1]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[2]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[1]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[3]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[2]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[4]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[3]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[2]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[4]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[3]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[4]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[3]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[4]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[5]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[4]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[5]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[9] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[6]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[5]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[10] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[6]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[11] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[1], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[7]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[6]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[12] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[2], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[7]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[13] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[3], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[8]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[7]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[14] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[4], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[8]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[15] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[5], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[9]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[8]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[16] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[6], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[9]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[17] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[7], a->dp[11]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[8], a->dp[10]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[9]);
             t->dp[18] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[8], a->dp[11]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[9], a->dp[10]);
             t->dp[19] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[9], a->dp[11]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[10]);
             t->dp[20] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[10], a->dp[11]);
             t->dp[21] = l;
             l = h;
             h = o;
             SP_ASM_SQR_ADD_NO(l, h, a->dp[11]);
             t->dp[22] = l;
             t->dp[23] = h;
             t->used = 24;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
 #endif /* SQR_MUL_ASM */
 #endif /* SP_WORD_SIZE == 32 */
 #endif /* !WOLFSSL_HAVE_SP_ECC && HAVE_ECC */
 
 #if defined(SQR_MUL_ASM) && defined(WOLFSSL_SP_INT_LARGE_COMBA)
     #if SP_INT_DIGITS >= 32
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_16(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
         sp_int_digit tl;
         sp_int_digit th;
         sp_int_digit to;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
         tl = 0;
         th = 0;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_SQR(h, l, a->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[1]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[2]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[1]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[3]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[2]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[4]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[3]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[2]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[4]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[3]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[4]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[3]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[4]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[5]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[4]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[5]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[9] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[6]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[5]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[10] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[6]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[11] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[7]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[6]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[12] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[7]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[13] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[8]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[7]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[14] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[8]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[15] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[1], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[9]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[8]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[16] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[2], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[9]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[17] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[3], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[10]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[9]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[18] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[4], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[10]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[19] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[5], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[11]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[10]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[20] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[6], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[11]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[21] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[7], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[12]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[11]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[22] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[8], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[12]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[23] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[9], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[13]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[12]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[24] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[10], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[13]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[25] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[11], a->dp[15]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[12], a->dp[14]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[13]);
             t->dp[26] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[12], a->dp[15]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[13], a->dp[14]);
             t->dp[27] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[13], a->dp[15]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[14]);
             t->dp[28] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[14], a->dp[15]);
             t->dp[29] = l;
             l = h;
             h = o;
             SP_ASM_SQR_ADD_NO(l, h, a->dp[15]);
             t->dp[30] = l;
             t->dp[31] = h;
             t->used = 32;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 32 */
 
     #if SP_INT_DIGITS >= 48
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_24(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         sp_int_digit l;
         sp_int_digit h;
         sp_int_digit o;
         sp_int_digit tl;
         sp_int_digit th;
         sp_int_digit to;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[1];
     #endif
         tl = 0;
         th = 0;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int), NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             h = 0;
             l = 0;
             SP_ASM_SQR(h, l, a->dp[0]);
             t->dp[0] = h;
             h = 0;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[1]);
             t->dp[1] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2_NO(l, h, o, a->dp[0], a->dp[2]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[1]);
             t->dp[2] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[3]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[2]);
             t->dp[3] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[0], a->dp[4]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[1], a->dp[3]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[2]);
             t->dp[4] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[4]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[3]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[5] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[4]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[3]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[6] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[5]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[4]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[7] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[5]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[4]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[8] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[6]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[5]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[9] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[6]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[5]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[10] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[7]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[6]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[11] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[7]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[6]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[12] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[8]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[7]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[13] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[8]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[7]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[14] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[9]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[8]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[15] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[9]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[8]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[16] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[10]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[9]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[17] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[10]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[9]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[18] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[11]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[10]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[19] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[11]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[10]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[20] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[12]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[11]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[21] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[12]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[11]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[22] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[0], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[1], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[13]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[12]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[23] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[1], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[2], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[13]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[12]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[24] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[2], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[3], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[14]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[13]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[25] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[3], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[4], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[14]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[13]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[26] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[4], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[5], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[15]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[13], a->dp[14]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[27] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[5], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[6], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[13], a->dp[15]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[14]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[28] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[6], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[7], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[13], a->dp[16]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[14], a->dp[15]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[29] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[7], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[8], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[13], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[14], a->dp[16]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[15]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[30] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[8], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[9], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[13], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[14], a->dp[17]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[15], a->dp[16]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[31] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[9], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[10], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[13], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[14], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[15], a->dp[17]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[16]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[32] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[10], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[11], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[13], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[14], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[15], a->dp[18]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[16], a->dp[17]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[33] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[11], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[12], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[13], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[14], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[15], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[16], a->dp[18]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[17]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[34] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[12], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[13], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[14], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[15], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[16], a->dp[19]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[17], a->dp[18]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[35] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[13], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[14], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[15], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[16], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[17], a->dp[19]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[18]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[36] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[14], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[15], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[16], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[17], a->dp[20]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[18], a->dp[19]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[37] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[15], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[16], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[17], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[18], a->dp[20]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[19]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[38] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[16], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[17], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[18], a->dp[21]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[19], a->dp[20]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[39] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[17], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[18], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[19], a->dp[21]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[20]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[40] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_SET(tl, th, to, a->dp[18], a->dp[23]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[19], a->dp[22]);
             SP_ASM_MUL_ADD(tl, th, to, a->dp[20], a->dp[21]);
             SP_ASM_ADD_DBL_3(l, h, o, tl, th, to);
             t->dp[41] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[19], a->dp[23]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[20], a->dp[22]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[21]);
             t->dp[42] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[20], a->dp[23]);
             SP_ASM_MUL_ADD2(l, h, o, a->dp[21], a->dp[22]);
             t->dp[43] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[21], a->dp[23]);
             SP_ASM_SQR_ADD(l, h, o, a->dp[22]);
             t->dp[44] = l;
             l = h;
             h = o;
             o = 0;
             SP_ASM_MUL_ADD2(l, h, o, a->dp[22], a->dp[23]);
             t->dp[45] = l;
             l = h;
             h = o;
             SP_ASM_SQR_ADD_NO(l, h, a->dp[23]);
             t->dp[46] = l;
             t->dp[47] = h;
             t->used = 48;
             err = sp_copy(t, r);
         }
         if (err == MP_OKAY) {
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 48 */
 
     #if SP_INT_DIGITS >= 64
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_32(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         sp_int_digit l;
         sp_int_digit h;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[3];
     #endif
         sp_int* a1;
         sp_int* z0;
         sp_int* z1;
         sp_int* z2;
         sp_int_digit ca;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int) * 3, NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             a1 = &t[0];
             z0 = r;
             z1 = &t[1];
             z2 = &t[2];
 
             XMEMCPY(a1->dp, &a->dp[16], sizeof(sp_int_digit) * 16);
             a1->used = 16;
 
             /* z2 = a1 ^ 2 */
             err = _sp_sqr_16(a1, z2);
         }
         if (err == MP_OKAY) {
             l = 0;
             h = 0;
             for (i = 0; i < 16; i++) {
                 SP_ASM_ADDC(l, h, a1->dp[i]);
                 SP_ASM_ADDC(l, h, a->dp[i]);
                 a1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             ca = l;
 
             /* z0 = a0 ^ 2 */
             err = _sp_sqr_16(a, z0);
         }
         if (err == MP_OKAY) {
             /* z1 = (a0 + a1) ^ 2 */
             err = _sp_sqr_16(a1, z1);
         }
         if (err == MP_OKAY) {
             /* r = (z2 << 32) + (z1 - z0 - z2) << 16) + z0 */
             /* r = z0 */
             /* r += (z1 - z0 - z2) << 16 */
             z1->dp[32] = ca;
             if (ca) {
                 l = z1->dp[0 + 16];
                 h = 0;
                 SP_ASM_ADDC(l, h, a1->dp[0]);
                 SP_ASM_ADDC(l, h, a1->dp[0]);
                 z1->dp[0 + 16] = l;
                 l = h;
                 h = 0;
                 for (i = 1; i < 16; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 16]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     z1->dp[i + 16] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[32] += l;
             }
             /* z1 = z1 - z0 - z1 */
             l = z1->dp[0];
             h = 0;
             SP_ASM_SUBC(l, h, z0->dp[0]);
             SP_ASM_SUBC(l, h, z2->dp[0]);
             z1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 32; i++) {
                 l += z1->dp[i];
                 SP_ASM_SUBC(l, h, z0->dp[i]);
                 SP_ASM_SUBC(l, h, z2->dp[i]);
                 z1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             z1->dp[i] += l;
             /* r += z1 << 16 */
             l = 0;
             h = 0;
             for (i = 0; i < 16; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 16]);
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 16] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 33; i++) {
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 16] = l;
                 l = h;
                 h = 0;
             }
             /* r += z2 << 32  */
             l = 0;
             h = 0;
             for (i = 0; i < 17; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 32]);
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 32] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 32; i++) {
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 32] = l;
                 l = h;
                 h = 0;
             }
             r->used = 64;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 64 */
 
     #if SP_INT_DIGITS >= 96
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_48(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         sp_int_digit l;
         sp_int_digit h;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[3];
     #endif
         sp_int* a1;
         sp_int* z0;
         sp_int* z1;
         sp_int* z2;
         sp_int_digit ca;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int) * 3, NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             a1 = &t[0];
             z0 = r;
             z1 = &t[1];
             z2 = &t[2];
 
             XMEMCPY(a1->dp, &a->dp[24], sizeof(sp_int_digit) * 24);
             a1->used = 24;
 
             /* z2 = a1 ^ 2 */
             err = _sp_sqr_24(a1, z2);
         }
         if (err == MP_OKAY) {
             l = 0;
             h = 0;
             for (i = 0; i < 24; i++) {
                 SP_ASM_ADDC(l, h, a1->dp[i]);
                 SP_ASM_ADDC(l, h, a->dp[i]);
                 a1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             ca = l;
 
             /* z0 = a0 ^ 2 */
             err = _sp_sqr_24(a, z0);
         }
         if (err == MP_OKAY) {
             /* z1 = (a0 + a1) ^ 2 */
             err = _sp_sqr_24(a1, z1);
         }
         if (err == MP_OKAY) {
             /* r = (z2 << 48) + (z1 - z0 - z2) << 24) + z0 */
             /* r = z0 */
             /* r += (z1 - z0 - z2) << 24 */
             z1->dp[48] = ca;
             if (ca) {
                 l = z1->dp[0 + 24];
                 h = 0;
                 SP_ASM_ADDC(l, h, a1->dp[0]);
                 SP_ASM_ADDC(l, h, a1->dp[0]);
                 z1->dp[0 + 24] = l;
                 l = h;
                 h = 0;
                 for (i = 1; i < 24; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 24]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     z1->dp[i + 24] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[48] += l;
             }
             /* z1 = z1 - z0 - z1 */
             l = z1->dp[0];
             h = 0;
             SP_ASM_SUBC(l, h, z0->dp[0]);
             SP_ASM_SUBC(l, h, z2->dp[0]);
             z1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 48; i++) {
                 l += z1->dp[i];
                 SP_ASM_SUBC(l, h, z0->dp[i]);
                 SP_ASM_SUBC(l, h, z2->dp[i]);
                 z1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             z1->dp[i] += l;
             /* r += z1 << 16 */
             l = 0;
             h = 0;
             for (i = 0; i < 24; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 24]);
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 24] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 49; i++) {
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 24] = l;
                 l = h;
                 h = 0;
             }
             /* r += z2 << 48  */
             l = 0;
             h = 0;
             for (i = 0; i < 25; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 48]);
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 48] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 48; i++) {
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 48] = l;
                 l = h;
                 h = 0;
             }
             r->used = 96;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 96 */
 
     #if SP_INT_DIGITS >= 128
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_64(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         sp_int_digit l;
         sp_int_digit h;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[3];
     #endif
         sp_int* a1;
         sp_int* z0;
         sp_int* z1;
         sp_int* z2;
         sp_int_digit ca;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int) * 3, NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             a1 = &t[0];
             z0 = r;
             z1 = &t[1];
             z2 = &t[2];
 
             XMEMCPY(a1->dp, &a->dp[32], sizeof(sp_int_digit) * 32);
             a1->used = 32;
 
             /* z2 = a1 ^ 2 */
             err = _sp_sqr_32(a1, z2);
         }
         if (err == MP_OKAY) {
             l = 0;
             h = 0;
             for (i = 0; i < 32; i++) {
                 SP_ASM_ADDC(l, h, a1->dp[i]);
                 SP_ASM_ADDC(l, h, a->dp[i]);
                 a1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             ca = l;
 
             /* z0 = a0 ^ 2 */
             err = _sp_sqr_32(a, z0);
         }
         if (err == MP_OKAY) {
             /* z1 = (a0 + a1) ^ 2 */
             err = _sp_sqr_32(a1, z1);
         }
         if (err == MP_OKAY) {
             /* r = (z2 << 64) + (z1 - z0 - z2) << 32) + z0 */
             /* r = z0 */
             /* r += (z1 - z0 - z2) << 32 */
             z1->dp[64] = ca;
             if (ca) {
                 l = z1->dp[0 + 32];
                 h = 0;
                 SP_ASM_ADDC(l, h, a1->dp[0]);
                 SP_ASM_ADDC(l, h, a1->dp[0]);
                 z1->dp[0 + 32] = l;
                 l = h;
                 h = 0;
                 for (i = 1; i < 32; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 32]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     z1->dp[i + 32] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[64] += l;
             }
             /* z1 = z1 - z0 - z1 */
             l = z1->dp[0];
             h = 0;
             SP_ASM_SUBC(l, h, z0->dp[0]);
             SP_ASM_SUBC(l, h, z2->dp[0]);
             z1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 64; i++) {
                 l += z1->dp[i];
                 SP_ASM_SUBC(l, h, z0->dp[i]);
                 SP_ASM_SUBC(l, h, z2->dp[i]);
                 z1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             z1->dp[i] += l;
             /* r += z1 << 16 */
             l = 0;
             h = 0;
             for (i = 0; i < 32; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 32]);
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 32] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 65; i++) {
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 32] = l;
                 l = h;
                 h = 0;
             }
             /* r += z2 << 64  */
             l = 0;
             h = 0;
             for (i = 0; i < 33; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 64]);
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 64] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 64; i++) {
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 64] = l;
                 l = h;
                 h = 0;
             }
             r->used = 128;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 128 */
 
     #if SP_INT_DIGITS >= 192
     /* Square a and store in r. r = a * a
      *
      * @param  [in]   a  SP integer to square.
      * @param  [out]  r  SP integer result.
      *
      * @return  MP_OKAY on success.
      * @return  MP_MEM when dynamic memory allocation fails.
      */
     static int _sp_sqr_96(sp_int* a, sp_int* r)
     {
         int err = MP_OKAY;
         int i;
         sp_int_digit l;
         sp_int_digit h;
     #ifdef WOLFSSL_SMALL_STACK
         sp_int* t = NULL;
     #else
         sp_int t[3];
     #endif
         sp_int* a1;
         sp_int* z0;
         sp_int* z1;
         sp_int* z2;
         sp_int_digit ca;
 
     #ifdef WOLFSSL_SMALL_STACK
         if (err == MP_OKAY) {
             t = (sp_int*)XMALLOC(sizeof(sp_int) * 3, NULL, DYNAMIC_TYPE_BIGINT);
             if (t == NULL) {
                 err = MP_MEM;
             }
         }
     #endif
 
         if (err == MP_OKAY) {
             a1 = &t[0];
             z0 = r;
             z1 = &t[1];
             z2 = &t[2];
 
             XMEMCPY(a1->dp, &a->dp[48], sizeof(sp_int_digit) * 48);
             a1->used = 48;
 
             /* z2 = a1 ^ 2 */
             err = _sp_sqr_48(a1, z2);
         }
         if (err == MP_OKAY) {
             l = 0;
             h = 0;
             for (i = 0; i < 48; i++) {
                 SP_ASM_ADDC(l, h, a1->dp[i]);
                 SP_ASM_ADDC(l, h, a->dp[i]);
                 a1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             ca = l;
 
             /* z0 = a0 ^ 2 */
             err = _sp_sqr_48(a, z0);
         }
         if (err == MP_OKAY) {
             /* z1 = (a0 + a1) ^ 2 */
             err = _sp_sqr_48(a1, z1);
         }
         if (err == MP_OKAY) {
             /* r = (z2 << 96) + (z1 - z0 - z2) << 48) + z0 */
             /* r = z0 */
             /* r += (z1 - z0 - z2) << 48 */
             z1->dp[96] = ca;
             if (ca) {
                 l = z1->dp[0 + 48];
                 h = 0;
                 SP_ASM_ADDC(l, h, a1->dp[0]);
                 SP_ASM_ADDC(l, h, a1->dp[0]);
                 z1->dp[0 + 48] = l;
                 l = h;
                 h = 0;
                 for (i = 1; i < 48; i++) {
                     SP_ASM_ADDC(l, h, z1->dp[i + 48]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     SP_ASM_ADDC(l, h, a1->dp[i]);
                     z1->dp[i + 48] = l;
                     l = h;
                     h = 0;
                 }
                 z1->dp[96] += l;
             }
             /* z1 = z1 - z0 - z1 */
             l = z1->dp[0];
             h = 0;
             SP_ASM_SUBC(l, h, z0->dp[0]);
             SP_ASM_SUBC(l, h, z2->dp[0]);
             z1->dp[0] = l;
             l = h;
             h = 0;
             for (i = 1; i < 96; i++) {
                 l += z1->dp[i];
                 SP_ASM_SUBC(l, h, z0->dp[i]);
                 SP_ASM_SUBC(l, h, z2->dp[i]);
                 z1->dp[i] = l;
                 l = h;
                 h = 0;
             }
             z1->dp[i] += l;
             /* r += z1 << 16 */
             l = 0;
             h = 0;
             for (i = 0; i < 48; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 48]);
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 48] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 97; i++) {
                 SP_ASM_ADDC(l, h, z1->dp[i]);
                 r->dp[i + 48] = l;
                 l = h;
                 h = 0;
             }
             /* r += z2 << 96  */
             l = 0;
             h = 0;
             for (i = 0; i < 49; i++) {
                 SP_ASM_ADDC(l, h, r->dp[i + 96]);
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 96] = l;
                 l = h;
                 h = 0;
             }
             for (; i < 96; i++) {
                 SP_ASM_ADDC(l, h, z2->dp[i]);
                 r->dp[i + 96] = l;
                 l = h;
                 h = 0;
             }
             r->used = 192;
             sp_clamp(r);
         }
 
     #ifdef WOLFSSL_SMALL_STACK
         if (t != NULL) {
             XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
         }
     #endif
 
         return err;
     }
     #endif /* SP_INT_DIGITS >= 192 */
 
 #endif /* SQR_MUL_ASM && WOLFSSL_SP_INT_LARGE_COMBA */
 #endif /* !WOLFSSL_SP_SMALL */
 
 /* Square a and store in r. r = a * a
  *
  * @param  [in]   a  SP integer to square.
  * @param  [out]  r  SP integer result.
  *
  * @return  MP_OKAY on success.
  * @return  MP_VAL when a or r is NULL, or the result will be too big for fixed
  *          data length.
  * @return  MP_MEM when dynamic memory allocation fails.
  */
diff --git a/wolfcrypt/src/wolfmath.c b/wolfcrypt/src/wolfmath.c
index 40245ffd7..79a992d2b 100644
--- a/wolfcrypt/src/wolfmath.c
+++ b/wolfcrypt/src/wolfmath.c
@@ -90,40 +90,44 @@ mp_digit get_digit(mp_int* a, int n)
 /* Conditionally copy a into b. Performed in constant time.
  *
  * a     MP integer to copy.
  * copy  On 1, copy a into b. on 0 leave b unchanged.
  * b     MP integer to copy into.
  * returns BAD_FUNC_ARG when a or b is NULL, MEMORY_E when growing b fails and
  *         MP_OKAY otherwise.
  */
 int mp_cond_copy(mp_int* a, int copy, mp_int* b)
 {
     int err = MP_OKAY;
     int i;
+#if defined(SP_WORD_SIZE) && SP_WORD_SIZE == 8
+    unsigned int mask = (unsigned int)0 - copy;
+#else
     mp_digit mask = (mp_digit)0 - copy;
+#endif
 
     if (a == NULL || b == NULL)
         err = BAD_FUNC_ARG;
 
     /* Ensure b has enough space to copy a into */
     if (err == MP_OKAY)
         err = mp_grow(b, a->used + 1);
     if (err == MP_OKAY) {
         /* When mask 0, b is unchanged2
          * When mask all set, b ^ b ^ a = a
          */
         /* Conditionaly copy all digits and then number of used diigits.
          * get_digit() returns 0 when index greater than available digit.
          */
         for (i = 0; i < a->used; i++) {
             b->dp[i] ^= (get_digit(a, i) ^ get_digit(b, i)) & mask;
         }
         for (; i < b->used; i++) {
             b->dp[i] ^= (get_digit(a, i) ^ get_digit(b, i)) & mask;
         }
         b->used ^= (a->used ^ b->used) & (int)mask;
     }
 
     return err;
 }
 
 #ifndef WC_NO_RNG
diff --git a/wolfssl/wolfcrypt/sp_int.h b/wolfssl/wolfcrypt/sp_int.h
index 96133133b..ccb52af78 100644
--- a/wolfssl/wolfcrypt/sp_int.h
+++ b/wolfssl/wolfcrypt/sp_int.h
@@ -304,363 +304,382 @@ extern "C" {
 #if defined(WOLFSSL_HAVE_SP_ECC) && defined(WOLFSSL_SP_NONBLOCK)
 /* Non-blocking ECC operation context. */
 typedef struct sp_ecc_ctx {
     #ifdef WOLFSSL_SP_384
     byte data[48*80]; /* stack data */
     #else
     byte data[32*80]; /* stack data */
     #endif
 } sp_ecc_ctx_t;
 #endif
 
 #if defined(WOLFSSL_SP_MATH) || defined(WOLFSSL_SP_MATH_ALL)
 #include <wolfssl/wolfcrypt/random.h>
 
 #ifdef SP_INT_BITS
     /* Calculate number of digits to have in an sp_int based maximum size of
      * numbers in bits that will be used.
      * Double the size to hold multiplication result.
      * Add one to accommodate extra digit used by sp_mul(), sp_mulmod(), sp_sqr(), and sp_sqrmod().
      */
     #define SP_INT_DIGITS                                                      \
         ((((SP_INT_BITS + (SP_WORD_SIZE - 1)) * 2 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
 #endif
 
 #ifndef SP_INT_DIGITS
     /* Calculate number of digits to have in an sp_int based on features
      * compiled in.
      */
     #if !defined(WOLFSSL_HAVE_SP_RSA) && !defined(WOLFSSL_HAVE_SP_DH) && \
         !defined(WOLFSSL_HAVE_SP_ECC)
         #if !defined(NO_RSA) || !defined(NO_DH) || !defined(NO_DSA)
             #define SP_INT_DIGITS        (((6144 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #elif defined(HAVE_ECC)
             #define SP_INT_DIGITS   \
                     (((2 * ( 521 + SP_WORD_SIZE) + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #elif !defined(NO_PWDBASED) && defined(WOLFSSL_SHA512)
             #define SP_INT_DIGITS        ((( 512 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #else
             #define SP_INT_DIGITS        ((( 256 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #endif
     #elif !defined(WOLFSSL_HAVE_SP_RSA) && !defined(WOLFSSL_HAVE_SP_DH)
         #ifdef WOLFSSL_SP_MATH_ALL
             #define SP_INT_DIGITS   \
                     (((2 * ( 521 + SP_WORD_SIZE) + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #elif defined(WOLFSSL_SP_384)
             #define SP_INT_DIGITS        ((( 768 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #else
             #define SP_INT_DIGITS        ((( 512 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #endif
     #elif defined(WOLFSSL_SP_4096)
         #if defined(WOLFSSL_HAVE_SP_DH)
             #define SP_INT_DIGITS        (((8192 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #else
             #define SP_INT_DIGITS        (((4096 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #endif
     #elif !defined(WOLFSSL_SP_NO_3072)
         #if defined(WOLFSSL_HAVE_SP_DH)
             #define SP_INT_DIGITS        (((6144 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #else
             #define SP_INT_DIGITS        (((3072 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #endif
     #else
         #if defined(WOLFSSL_HAVE_SP_DH)
             #define SP_INT_DIGITS        (((4096 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #else
             #define SP_INT_DIGITS        (((2048 + SP_WORD_SIZE) / SP_WORD_SIZE) + 1)
         #endif
     #endif
 #endif
 
 #ifndef SP_INT_MAX_BITS
     /* Convert number digits to number of bits. */
     #define SP_INT_MAX_BITS     (SP_INT_DIGITS * SP_WORD_SIZE)
 #endif
 
+#if SP_WORD_SIZE < 32
+    /* Maximum number of digits in a number to mul or sqr. */
+    #define SP_MUL_SQR_DIGITS       (SP_INT_MAX_BITS / 2 / SP_WORD_SIZE)
+    /* Maximum value of partial in mul/sqr. */
+    #define SP_MUL_SQR_MAX_PARTIAL  \
+                                 (SP_MUL_SQR_DIGITS * ((1 << SP_WORD_SIZE) - 1))
+    /* Maximim value in an sp_int_word. */
+    #define SP_INT_WORD_MAX         ((1 << (SP_WORD_SIZE * 2)) - 1)
+
+    #if SP_MUL_SQR_MAX_PARTIAL > SP_INT_WORD_MAX
+        /* The sum of the partials in the multiplicaiton/square can exceed the
+         * size of a word. This will overflow the word and loose data.
+         * Use an implementation that handles carry after every add and uses an
+         * extra temporary word for overflowing high word.
+         */
+        #define SP_WORD_OVERFLOW
+    #endif
+#endif
+
 
 /* For debugging only - format string for different digit sizes. */
 #if SP_WORD_SIZE == 64
     #if SP_ULONG_BITS == 64
         #define SP_PRINT_FMT       "%016lx"
     #else
         #define SP_PRINT_FMT       "%016llx"
     #endif
 #elif SP_WORD_SIZE == 32
     #if SP_UINT_BITS == 32
         #define SP_PRINT_FMT       "%08x"
     #else
         #define SP_PRINT_FMT       "%08lx"
     #endif
 #elif SP_WORD_SIZE == 16
     #define SP_PRINT_FMT       "%04x"
 #elif SP_WORD_SIZE == 8
     #define SP_PRINT_FMT       "%02x"
 #endif
 
 #ifndef NO_FILESYSTEM
 /* Output is formatted to be used with script that checks calculations. */
 
 /* Print out a number in big endian. */
 #ifndef WOLFSSL_SP_INT_NEGATIVE
 /* Print out a positive multi-precision number.
  *
  * @param  [in]  a  SP integer to print.
  * @param  [in]  s  String that describes the use of the number.
  */
 #define sp_print(a, s)                                  \
     do {                                                \
         int ii;                                         \
         fprintf(stderr, "%s=0x0", s);                   \
         for (ii = (a)->used-1; ii >= 0; ii--) {         \
             fprintf(stderr, SP_PRINT_FMT, (a)->dp[ii]); \
         }                                               \
         fprintf(stderr, "\n");                          \
     }                                                   \
     while (0)
 #else
 /* Print out a multi-precision number.
  *
  * @param  [in]  a  SP integer to print.
  * @param  [in]  s  String that describes the use of the number.
  */
 #define sp_print(a, s)                                  \
     do {                                                \
         int ii;                                         \
         fprintf(stderr, "%s=0x", s);                    \
         if ((a)->sign == MP_NEG) {                      \
             fprintf(stderr, "-");                       \
         }                                               \
         fprintf(stderr, "0");                           \
         for (ii = (a)->used-1; ii >= 0; ii--) {         \
             fprintf(stderr, SP_PRINT_FMT, (a)->dp[ii]); \
         }                                               \
         fprintf(stderr, "\n");                          \
     }                                                   \
     while (0)
 #endif
 
 /* Print out a single multi-precision digit.
  *
  * @param  [in]  a  SP integer digit to print.
  * @param  [in]  s  String that describes the use of the number.
  */
 #define sp_print_digit(a, s)                            \
     do {                                                \
         fprintf(stderr, "%s=0x0", s);                   \
         fprintf(stderr, SP_PRINT_FMT, a);               \
         fprintf(stderr, "\n");                          \
     }                                                   \
     while (0)
 
 /* Print out an integer.
  *
  * @param  [in]  a  Number to print.
  * @param  [in]  s  String that describes the use of the number.
  */
 #define sp_print_int(a, s)                              \
     do {                                                \
         fprintf(stderr, "%s=0x0%x\n", s, a);            \
     }                                                   \
     while (0)
 
 #else
 
     /* No filesystem, no output
      * TODO: Use logging API?
      */
     #define sp_print(a, s)
     #define sp_print_digit(a, s)
     #define sp_print_int(a, s)
 
 #endif
 
 /* Returns whether multi-precision number is odd
  *
  * Assumes a is not NULL.
  *
  * @param  [in]  a  SP integer to check.
  * @return 1 when odd.
  * @return 0 when even.
  */
 #define sp_isodd(a)      (((a)->used != 0) && ((a)->dp[0] & 1))
 /* Returns whether multi-precision number is even
  *
  * Assumes a is not NULL.
  *
  * @param  [in]  a  SP integer to check.
  * @return 1 when even.
  * @return 0 when odd.
  */
 #define sp_iseven(a)     (((a)->used != 0) && (((a)->dp[0] & 1) == 0))
 /* Returns whether multi-precision number has the value zero.
  *
  * Assumes a is not NULL.
  *
  * @param  [in]  a  SP integer to check.
  * @return 1 when zero.
  * @return 0 when not zero.
  */
 #define sp_iszero(a)     ((a)->used == 0)
 /* Returns whether multi-precision number has the value one.
  *
  * Assumes a is not NULL.
  *
  * @param  [in]  a  SP integer to check.
  * @return 1 when one.
  * @return 0 when not one.
  */
 #define sp_isone(a)      (((a)->used == 1) && ((a)->dp[0] == 1))
 /* Returns whether multi-precision number has the value 'd'.
  *
  * Assumes a is not NULL.
  *
  * @param  [in]  a  SP integer to check.
  * @param  [in]  d  SP integer digit.
  * @return 1 when one.
  * @return 0 when not one.
  */
 #define sp_isword(a, d)  (((a)->used == 1) && ((a)->dp[0] == d))
 #ifndef WOLFSSL_SP_INT_NEGATIVE
 /* Calculate the absolute value of the multi-precision number.
  *
  * Negative support not compiled in so just copies.
  *
  * @param  [in]   a  SP integer to calculate absolute value of.
  * @param  [out]  r  SP integer to hold result.
  *
  * @return  MP_OKAY on success.
  * @return  MP_VAL when a or r is NULL.
  */
 #define sp_abs(a, b)     sp_copy(a, b)
 /* Returns whether multi-precision number is negative.
  *
  * Negative support not compiled in so always returns 0 (false).
  *
  * @param  [in]  a  SP integer to check.
  * @param  [in]  d  SP integer digit.
  * @return 0 indicating not negative always.
  */
 #define sp_isneg(a)      (0)
 #else
 /* Returns whether multi-precision number is negative.
  *
  * Assumes a is not NULL.
  *
  * @param  [in]  a  SP integer to check.
  * @param  [in]  d  SP integer digit.
  * @return 1 when negative.
  * @return 0 when not negative.
  */
 #define sp_isneg(a)      ((a)->sign == MP_NEG)
 #endif
 /* Updates the used count to exclude leading zeros.
  *
  * Assumes a is not NULL.
  *
  * @param  [in]  a  SP integer to update.
  */
 #define sp_clamp(a)                                               \
     do {                                                          \
         int ii;                                                   \
         for (ii = a->used - 1; ii >= 0 && a->dp[ii] == 0; ii--) { \
         }                                                         \
         a->used = ii + 1;                                         \
     } while (0)
 
 /* Check the compiled and linked math implementation are the same.
  * Use the number of bits in a digit as indication of how code was compiled.
  *
  * @return  1 when the number of bits are the same.
  * @return  0 when the number of bits are differnt.
  */
 #define CheckFastMathSettings()   (SP_WORD_SIZE == CheckRunTimeFastMath())
 
 
 #ifdef WOLFSSL_SP_INT_NEGATIVE
     #ifdef HAVE_WOLF_BIGINT
         #define SP_INT_EXTRA_OVERHEAD    sizeof(int) + sizeof(struct WC_BIGINT)
     #else
         #define SP_INT_EXTRA_OVERHEAD    sizeof(int)
     #endif
 #elif defined(HAVE_WOLF_BIGINT)
     #define SP_INT_EXTRA_OVERHEAD    sizeof(struct WC_BIGINT)
 #else
     #define SP_INT_EXTRA_OVERHEAD    0
 #endif
 #define WOLFSSL_SP_INT_OVERHEAD \
     (sizeof(int) + sizeof(int) + SP_INT_EXTRA_OVERHEAD)
 
 #define MP_INT_SIZEOF(cnt) \
     (WOLFSSL_SP_INT_OVERHEAD + ((cnt) * SP_WORD_SIZEOF))
 
 
 /**
  * A reuslt of NO.
  * e.g. Is prime? NO.
  */
 #define MP_NO      0
 /**
  * A reuslt of YES.
  * e.g. Is prime? YES.
  */
 #define MP_YES     1
 
 #ifdef WOLFSSL_SP_INT_NEGATIVE
 /** Number is 0/positive. */
 #define MP_ZPOS    0
 /** Number is negative. */
 #define MP_NEG     1
 #endif
 
 /** Radix is base 10 or decimal. */
 #define MP_RADIX_DEC     10
 /** Radix is base 16 or hexadecimal. */
 #define MP_RADIX_HEX     16
 
 /** Result of comparison is that the first number is greater than second. */
 #define MP_GT    1
 /** Result of comparison is they are equal. */
 #define MP_EQ    0
 /** Result of comparison is that the first number is less than second. */
 #define MP_LT    -1
 
 /** Error value on success. */
 #define MP_OKAY   0
 /** Error value when dynamic memory allocation fails. */
 #define MP_MEM   -2
 /** Error value when value passed is not able to be used. */
 #define MP_VAL   -3
 /** Error value when non-blocking operation is returning after partial
  * completion.
  */
 #define FP_WOULDBLOCK -4
 
 /* Number of bits in each word/digit. */
 #define DIGIT_BIT  SP_WORD_SIZE
 /* Mask of all used bits in word/digit. */
 #define MP_MASK    SP_MASK
 
 
 #ifdef HAVE_WOLF_BIGINT
     /* Raw big integer as a big-endian byte array.
      *
      * Useful for when using hardware - canonical format.
      */
     typedef struct WC_BIGINT {
         /* Dynamically allocated buffer that is big-endian byte array. */
         byte*   buf;
         /* Length of buffer in bytes. */
         word32  len;
         /* Hint for heap used to allocate buffer. */
         void*   heap;
     } WC_BIGINT;
 
     /* Ensure WC_BIGINT defined once. */
     #define WOLF_BIGINT_DEFINED
 #endif
 
 
 /**
  * SP integer.
  *
  * dp at end so user can allocate a smaller amount and set size.
  */
