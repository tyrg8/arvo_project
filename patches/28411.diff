commit da2551f3d191c1f0a32a3c9e3a26d2a236825871
Author: Nico Weber <thakis@chromium.org>
Date:   Mon Dec 14 22:12:15 2020 -0500

    Revert "[Debugify] Support checking Machine IR debug info"
    
    This reverts commit c4d2d4337d50bed3cafd564daece1a197005b22b.
    Necessary to revert 2a5675f11d3bc803a245c0e.

diff --git a/llvm/docs/HowToUpdateDebugInfo.rst b/llvm/docs/HowToUpdateDebugInfo.rst
index fff0cdbe59c8..7df2a8a25827 100644
--- a/llvm/docs/HowToUpdateDebugInfo.rst
+++ b/llvm/docs/HowToUpdateDebugInfo.rst
@@ -342,8 +342,8 @@ A variant of the ``debugify`` utility described in
 :ref:`Mutation testing for IR-level transformations<IRDebugify>` can be used
 for MIR-level transformations as well: much like the IR-level pass,
 ``mir-debugify`` inserts sequentially increasing line locations to each
-``MachineInstr`` in a ``Module``. And the MIR-level ``mir-check-debugify`` is
-similar to IR-level ``check-debugify`` pass.
+``MachineInstr`` in a ``Module`` (although there is no equivalent MIR-level
+``check-debugify`` pass).
 
 For example, here is a snippet before:
 
@@ -403,33 +403,17 @@ and ``-start-after``. For example:
   $ llc -debugify-and-strip-all-safe -run-pass=... <other llc args>
   $ llc -debugify-and-strip-all-safe -O1 <other llc args>
 
-If you want to check it after each pass in a pipeline, use
-``-debugify-check-and-strip-all-safe``. This can also be combined with
-``-start-before`` and ``-start-after``. For example:
-
-.. code-block:: bash
-
-  $ llc -debugify-check-and-strip-all-safe -run-pass=... <other llc args>
-  $ llc -debugify-check-and-strip-all-safe -O1 <other llc args>
-
-To check all debug info from a test, use ``mir-check-debugify``, like:
-
-.. code-block:: bash
-
-  $ llc -run-pass=mir-debugify,other-pass,mir-check-debugify
-
 To strip out all debug info from a test, use ``mir-strip-debug``, like:
 
 .. code-block:: bash
 
   $ llc -run-pass=mir-debugify,other-pass,mir-strip-debug
 
-It can be useful to combine ``mir-debugify``, ``mir-check-debugify`` and/or
-``mir-strip-debug`` to identify backend transformations which break in
-the presence of debug info. For example, to run the AArch64 backend tests
-with all normal passes "sandwiched" in between MIRDebugify and
-MIRStripDebugify mutation passes, run:
+It can be useful to combine ``mir-debugify`` and ``mir-strip-debug`` to
+identify backend transformations which break in the presence of debug info.
+For example, to run the AArch64 backend tests with all normal passes
+"sandwiched" in between MIRDebugify and MIRStripDebugify mutation passes, run:
 
 .. code-block:: bash
 
   $ llvm-lit test/CodeGen/AArch64 -Dllc="llc -debugify-and-strip-all-safe"
diff --git a/llvm/include/llvm/CodeGen/Passes.h b/llvm/include/llvm/CodeGen/Passes.h
index 676ed2c65eb1..47037bac6270 100644
--- a/llvm/include/llvm/CodeGen/Passes.h
+++ b/llvm/include/llvm/CodeGen/Passes.h
@@ -35,463 +35,460 @@ class raw_ostream;
 /// List of target independent CodeGen pass IDs.
 namespace llvm {
   FunctionPass *createAtomicExpandPass();
 
   /// createUnreachableBlockEliminationPass - The LLVM code generator does not
   /// work well with unreachable basic blocks (what live ranges make sense for a
   /// block that cannot be reached?).  As such, a code generator should either
   /// not instruction select unreachable blocks, or run this pass as its
   /// last LLVM modifying pass to clean up blocks that are not reachable from
   /// the entry block.
   FunctionPass *createUnreachableBlockEliminationPass();
 
   /// createBasicBlockSections Pass - This pass assigns sections to machine
   /// basic blocks and is enabled with -fbasic-block-sections. Buf is a memory
   /// buffer that contains the list of functions and basic block ids to
   /// selectively enable basic block sections.
   MachineFunctionPass *createBasicBlockSectionsPass(const MemoryBuffer *Buf);
 
   /// createMachineFunctionSplitterPass - This pass splits machine functions
   /// using profile information.
   MachineFunctionPass *createMachineFunctionSplitterPass();
 
   /// MachineFunctionPrinter pass - This pass prints out the machine function to
   /// the given stream as a debugging tool.
   MachineFunctionPass *
   createMachineFunctionPrinterPass(raw_ostream &OS,
                                    const std::string &Banner ="");
 
   /// MIRPrinting pass - this pass prints out the LLVM IR into the given stream
   /// using the MIR serialization format.
   MachineFunctionPass *createPrintMIRPass(raw_ostream &OS);
 
   /// This pass resets a MachineFunction when it has the FailedISel property
   /// as if it was just created.
   /// If EmitFallbackDiag is true, the pass will emit a
   /// DiagnosticInfoISelFallback for every MachineFunction it resets.
   /// If AbortOnFailedISel is true, abort compilation instead of resetting.
   MachineFunctionPass *createResetMachineFunctionPass(bool EmitFallbackDiag,
                                                       bool AbortOnFailedISel);
 
   /// createCodeGenPreparePass - Transform the code to expose more pattern
   /// matching during instruction selection.
   FunctionPass *createCodeGenPreparePass();
 
   /// AtomicExpandID -- Lowers atomic operations in terms of either cmpxchg
   /// load-linked/store-conditional loops.
   extern char &AtomicExpandID;
 
   /// MachineLoopInfo - This pass is a loop analysis pass.
   extern char &MachineLoopInfoID;
 
   /// MachineDominators - This pass is a machine dominators analysis pass.
   extern char &MachineDominatorsID;
 
 /// MachineDominanaceFrontier - This pass is a machine dominators analysis pass.
   extern char &MachineDominanceFrontierID;
 
   /// MachineRegionInfo - This pass computes SESE regions for machine functions.
   extern char &MachineRegionInfoPassID;
 
   /// EdgeBundles analysis - Bundle machine CFG edges.
   extern char &EdgeBundlesID;
 
   /// LiveVariables pass - This pass computes the set of blocks in which each
   /// variable is life and sets machine operand kill flags.
   extern char &LiveVariablesID;
 
   /// PHIElimination - This pass eliminates machine instruction PHI nodes
   /// by inserting copy instructions.  This destroys SSA information, but is the
   /// desired input for some register allocators.  This pass is "required" by
   /// these register allocator like this: AU.addRequiredID(PHIEliminationID);
   extern char &PHIEliminationID;
 
   /// LiveIntervals - This analysis keeps track of the live ranges of virtual
   /// and physical registers.
   extern char &LiveIntervalsID;
 
   /// LiveStacks pass. An analysis keeping track of the liveness of stack slots.
   extern char &LiveStacksID;
 
   /// TwoAddressInstruction - This pass reduces two-address instructions to
   /// use two operands. This destroys SSA information but it is desired by
   /// register allocators.
   extern char &TwoAddressInstructionPassID;
 
   /// ProcessImpicitDefs pass - This pass removes IMPLICIT_DEFs.
   extern char &ProcessImplicitDefsID;
 
   /// RegisterCoalescer - This pass merges live ranges to eliminate copies.
   extern char &RegisterCoalescerID;
 
   /// MachineScheduler - This pass schedules machine instructions.
   extern char &MachineSchedulerID;
 
   /// PostMachineScheduler - This pass schedules machine instructions postRA.
   extern char &PostMachineSchedulerID;
 
   /// SpillPlacement analysis. Suggest optimal placement of spill code between
   /// basic blocks.
   extern char &SpillPlacementID;
 
   /// ShrinkWrap pass. Look for the best place to insert save and restore
   // instruction and update the MachineFunctionInfo with that information.
   extern char &ShrinkWrapID;
 
   /// LiveRangeShrink pass. Move instruction close to its definition to shrink
   /// the definition's live range.
   extern char &LiveRangeShrinkID;
 
   /// Greedy register allocator.
   extern char &RAGreedyID;
 
   /// Basic register allocator.
   extern char &RABasicID;
 
   /// VirtRegRewriter pass. Rewrite virtual registers to physical registers as
   /// assigned in VirtRegMap.
   extern char &VirtRegRewriterID;
 
   /// UnreachableMachineBlockElimination - This pass removes unreachable
   /// machine basic blocks.
   extern char &UnreachableMachineBlockElimID;
 
   /// DeadMachineInstructionElim - This pass removes dead machine instructions.
   extern char &DeadMachineInstructionElimID;
 
   /// This pass adds dead/undef flags after analyzing subregister lanes.
   extern char &DetectDeadLanesID;
 
   /// This pass perform post-ra machine sink for COPY instructions.
   extern char &PostRAMachineSinkingID;
 
   /// FastRegisterAllocation Pass - This pass register allocates as fast as
   /// possible. It is best suited for debug code where live ranges are short.
   ///
   FunctionPass *createFastRegisterAllocator();
 
   /// BasicRegisterAllocation Pass - This pass implements a degenerate global
   /// register allocator using the basic regalloc framework.
   ///
   FunctionPass *createBasicRegisterAllocator();
 
   /// Greedy register allocation pass - This pass implements a global register
   /// allocator for optimized builds.
   ///
   FunctionPass *createGreedyRegisterAllocator();
 
   /// PBQPRegisterAllocation Pass - This pass implements the Partitioned Boolean
   /// Quadratic Prograaming (PBQP) based register allocator.
   ///
   FunctionPass *createDefaultPBQPRegisterAllocator();
 
   /// PrologEpilogCodeInserter - This pass inserts prolog and epilog code,
   /// and eliminates abstract frame references.
   extern char &PrologEpilogCodeInserterID;
   MachineFunctionPass *createPrologEpilogInserterPass();
 
   /// ExpandPostRAPseudos - This pass expands pseudo instructions after
   /// register allocation.
   extern char &ExpandPostRAPseudosID;
 
   /// PostRAHazardRecognizer - This pass runs the post-ra hazard
   /// recognizer.
   extern char &PostRAHazardRecognizerID;
 
   /// PostRAScheduler - This pass performs post register allocation
   /// scheduling.
   extern char &PostRASchedulerID;
 
   /// BranchFolding - This pass performs machine code CFG based
   /// optimizations to delete branches to branches, eliminate branches to
   /// successor blocks (creating fall throughs), and eliminating branches over
   /// branches.
   extern char &BranchFolderPassID;
 
   /// BranchRelaxation - This pass replaces branches that need to jump further
   /// than is supported by a branch instruction.
   extern char &BranchRelaxationPassID;
 
   /// MachineFunctionPrinterPass - This pass prints out MachineInstr's.
   extern char &MachineFunctionPrinterPassID;
 
   /// MIRPrintingPass - this pass prints out the LLVM IR using the MIR
   /// serialization format.
   extern char &MIRPrintingPassID;
 
   /// TailDuplicate - Duplicate blocks with unconditional branches
   /// into tails of their predecessors.
   extern char &TailDuplicateID;
 
   /// Duplicate blocks with unconditional branches into tails of their
   /// predecessors. Variant that works before register allocation.
   extern char &EarlyTailDuplicateID;
 
   /// MachineTraceMetrics - This pass computes critical path and CPU resource
   /// usage in an ensemble of traces.
   extern char &MachineTraceMetricsID;
 
   /// EarlyIfConverter - This pass performs if-conversion on SSA form by
   /// inserting cmov instructions.
   extern char &EarlyIfConverterID;
 
   /// EarlyIfPredicator - This pass performs if-conversion on SSA form by
   /// predicating if/else block and insert select at the join point.
   extern char &EarlyIfPredicatorID;
 
   /// This pass performs instruction combining using trace metrics to estimate
   /// critical-path and resource depth.
   extern char &MachineCombinerID;
 
   /// StackSlotColoring - This pass performs stack coloring and merging.
   /// It merges disjoint allocas to reduce the stack size.
   extern char &StackColoringID;
 
   /// IfConverter - This pass performs machine code if conversion.
   extern char &IfConverterID;
 
   FunctionPass *createIfConverter(
       std::function<bool(const MachineFunction &)> Ftor);
 
   /// MachineBlockPlacement - This pass places basic blocks based on branch
   /// probabilities.
   extern char &MachineBlockPlacementID;
 
   /// MachineBlockPlacementStats - This pass collects statistics about the
   /// basic block placement using branch probabilities and block frequency
   /// information.
   extern char &MachineBlockPlacementStatsID;
 
   /// GCLowering Pass - Used by gc.root to perform its default lowering
   /// operations.
   FunctionPass *createGCLoweringPass();
 
   /// ShadowStackGCLowering - Implements the custom lowering mechanism
   /// used by the shadow stack GC.  Only runs on functions which opt in to
   /// the shadow stack collector.
   FunctionPass *createShadowStackGCLoweringPass();
 
   /// GCMachineCodeAnalysis - Target-independent pass to mark safe points
   /// in machine code. Must be added very late during code generation, just
   /// prior to output, and importantly after all CFG transformations (such as
   /// branch folding).
   extern char &GCMachineCodeAnalysisID;
 
   /// Creates a pass to print GC metadata.
   ///
   FunctionPass *createGCInfoPrinter(raw_ostream &OS);
 
   /// MachineCSE - This pass performs global CSE on machine instructions.
   extern char &MachineCSEID;
 
   /// MIRCanonicalizer - This pass canonicalizes MIR by renaming vregs
   /// according to the semantics of the instruction as well as hoists
   /// code.
   extern char &MIRCanonicalizerID;
 
   /// ImplicitNullChecks - This pass folds null pointer checks into nearby
   /// memory operations.
   extern char &ImplicitNullChecksID;
 
   /// This pass performs loop invariant code motion on machine instructions.
   extern char &MachineLICMID;
 
   /// This pass performs loop invariant code motion on machine instructions.
   /// This variant works before register allocation. \see MachineLICMID.
   extern char &EarlyMachineLICMID;
 
   /// MachineSinking - This pass performs sinking on machine instructions.
   extern char &MachineSinkingID;
 
   /// MachineCopyPropagation - This pass performs copy propagation on
   /// machine instructions.
   extern char &MachineCopyPropagationID;
 
   /// PeepholeOptimizer - This pass performs peephole optimizations -
   /// like extension and comparison eliminations.
   extern char &PeepholeOptimizerID;
 
   /// OptimizePHIs - This pass optimizes machine instruction PHIs
   /// to take advantage of opportunities created during DAG legalization.
   extern char &OptimizePHIsID;
 
   /// StackSlotColoring - This pass performs stack slot coloring.
   extern char &StackSlotColoringID;
 
   /// This pass lays out funclets contiguously.
   extern char &FuncletLayoutID;
 
   /// This pass inserts the XRay instrumentation sleds if they are supported by
   /// the target platform.
   extern char &XRayInstrumentationID;
 
   /// This pass inserts FEntry calls
   extern char &FEntryInserterID;
 
   /// This pass implements the "patchable-function" attribute.
   extern char &PatchableFunctionID;
 
   /// createStackProtectorPass - This pass adds stack protectors to functions.
   ///
   FunctionPass *createStackProtectorPass();
 
   /// createMachineVerifierPass - This pass verifies cenerated machine code
   /// instructions for correctness.
   ///
   FunctionPass *createMachineVerifierPass(const std::string& Banner);
 
   /// createDwarfEHPass - This pass mulches exception handling code into a form
   /// adapted to code generation.  Required if using dwarf exception handling.
   FunctionPass *createDwarfEHPass(CodeGenOpt::Level OptLevel);
 
   /// createWinEHPass - Prepares personality functions used by MSVC on Windows,
   /// in addition to the Itanium LSDA based personalities.
   FunctionPass *createWinEHPass(bool DemoteCatchSwitchPHIOnly = false);
 
   /// createSjLjEHPreparePass - This pass adapts exception handling code to use
   /// the GCC-style builtin setjmp/longjmp (sjlj) to handling EH control flow.
   ///
   FunctionPass *createSjLjEHPreparePass(const TargetMachine *TM);
 
   /// createWasmEHPass - This pass adapts exception handling code to use
   /// WebAssembly's exception handling scheme.
   FunctionPass *createWasmEHPass();
 
   /// LocalStackSlotAllocation - This pass assigns local frame indices to stack
   /// slots relative to one another and allocates base registers to access them
   /// when it is estimated by the target to be out of range of normal frame
   /// pointer or stack pointer index addressing.
   extern char &LocalStackSlotAllocationID;
 
   /// This pass expands pseudo-instructions, reserves registers and adjusts
   /// machine frame information.
   extern char &FinalizeISelID;
 
   /// UnpackMachineBundles - This pass unpack machine instruction bundles.
   extern char &UnpackMachineBundlesID;
 
   FunctionPass *
   createUnpackMachineBundles(std::function<bool(const MachineFunction &)> Ftor);
 
   /// FinalizeMachineBundles - This pass finalize machine instruction
   /// bundles (created earlier, e.g. during pre-RA scheduling).
   extern char &FinalizeMachineBundlesID;
 
   /// StackMapLiveness - This pass analyses the register live-out set of
   /// stackmap/patchpoint intrinsics and attaches the calculated information to
   /// the intrinsic for later emission to the StackMap.
   extern char &StackMapLivenessID;
 
   /// LiveDebugValues pass
   extern char &LiveDebugValuesID;
 
   /// createJumpInstrTables - This pass creates jump-instruction tables.
   ModulePass *createJumpInstrTablesPass();
 
   /// InterleavedAccess Pass - This pass identifies and matches interleaved
   /// memory accesses to target specific intrinsics.
   ///
   FunctionPass *createInterleavedAccessPass();
 
   /// InterleavedLoadCombines Pass - This pass identifies interleaved loads and
   /// combines them into wide loads detectable by InterleavedAccessPass
   ///
   FunctionPass *createInterleavedLoadCombinePass();
 
   /// LowerEmuTLS - This pass generates __emutls_[vt].xyz variables for all
   /// TLS variables for the emulated TLS model.
   ///
   ModulePass *createLowerEmuTLSPass();
 
   /// This pass lowers the \@llvm.load.relative and \@llvm.objc.* intrinsics to
   /// instructions.  This is unsafe to do earlier because a pass may combine the
   /// constant initializer into the load, which may result in an overflowing
   /// evaluation.
   ModulePass *createPreISelIntrinsicLoweringPass();
 
   /// GlobalMerge - This pass merges internal (by default) globals into structs
   /// to enable reuse of a base pointer by indexed addressing modes.
   /// It can also be configured to focus on size optimizations only.
   ///
   Pass *createGlobalMergePass(const TargetMachine *TM, unsigned MaximalOffset,
                               bool OnlyOptimizeForSize = false,
                               bool MergeExternalByDefault = false);
 
   /// This pass splits the stack into a safe stack and an unsafe stack to
   /// protect against stack-based overflow vulnerabilities.
   FunctionPass *createSafeStackPass();
 
   /// This pass detects subregister lanes in a virtual register that are used
   /// independently of other lanes and splits them into separate virtual
   /// registers.
   extern char &RenameIndependentSubregsID;
 
   /// This pass is executed POST-RA to collect which physical registers are
   /// preserved by given machine function.
   FunctionPass *createRegUsageInfoCollector();
 
   /// Return a MachineFunction pass that identifies call sites
   /// and propagates register usage information of callee to caller
   /// if available with PysicalRegisterUsageInfo pass.
   FunctionPass *createRegUsageInfoPropPass();
 
   /// This pass performs software pipelining on machine instructions.
   extern char &MachinePipelinerID;
 
   /// This pass frees the memory occupied by the MachineFunction.
   FunctionPass *createFreeMachineFunctionPass();
 
   /// This pass performs outlining on machine instructions directly before
   /// printing assembly.
   ModulePass *createMachineOutlinerPass(bool RunOnAllFunctions = true);
 
   /// This pass expands the experimental reduction intrinsics into sequences of
   /// shuffles.
   FunctionPass *createExpandReductionsPass();
 
   // This pass expands memcmp() to load/stores.
   FunctionPass *createExpandMemCmpPass();
 
   /// Creates Break False Dependencies pass. \see BreakFalseDeps.cpp
   FunctionPass *createBreakFalseDeps();
 
   // This pass expands indirectbr instructions.
   FunctionPass *createIndirectBrExpandPass();
 
   /// Creates CFI Instruction Inserter pass. \see CFIInstrInserter.cpp
   FunctionPass *createCFIInstrInserter();
 
   /// Creates CFGuard longjmp target identification pass.
   /// \see CFGuardLongjmp.cpp
   FunctionPass *createCFGuardLongjmpPass();
 
   /// Create Hardware Loop pass. \see HardwareLoops.cpp
   FunctionPass *createHardwareLoopsPass();
 
   /// This pass inserts pseudo probe annotation for callsite profiling.
   FunctionPass *createPseudoProbeInserter();
 
   /// Create IR Type Promotion pass. \see TypePromotion.cpp
   FunctionPass *createTypePromotionPass();
 
   /// Creates MIR Debugify pass. \see MachineDebugify.cpp
   ModulePass *createDebugifyMachineModulePass();
 
   /// Creates MIR Strip Debug pass. \see MachineStripDebug.cpp
   /// If OnlyDebugified is true then it will only strip debug info if it was
   /// added by a Debugify pass. The module will be left unchanged if the debug
   /// info was generated by another source such as clang.
   ModulePass *createStripDebugMachineModulePass(bool OnlyDebugified);
 
-  /// Creates MIR Check Debug pass. \see MachineCheckDebugify.cpp
-  ModulePass *createCheckDebugMachineModulePass();
-
   /// The pass fixups statepoint machine instruction to replace usage of
   /// caller saved registers with stack slots.
   extern char &FixupStatepointCallerSavedID;
 
   /// The pass transform load/store <256 x i32> to AMX load/store intrinsics
   /// or split the data to two <128 x i32>.
   FunctionPass *createX86LowerAMXTypePass();
 } // End llvm namespace
 
 #endif
diff --git a/llvm/include/llvm/CodeGen/TargetPassConfig.h b/llvm/include/llvm/CodeGen/TargetPassConfig.h
index 9b42b0756d41..fc5245216941 100644
--- a/llvm/include/llvm/CodeGen/TargetPassConfig.h
+++ b/llvm/include/llvm/CodeGen/TargetPassConfig.h
@@ -140,204 +140,201 @@ protected:
 public:
   TargetPassConfig(LLVMTargetMachine &TM, PassManagerBase &pm);
   // Dummy constructor.
   TargetPassConfig();
 
   ~TargetPassConfig() override;
 
   static char ID;
 
   /// Get the right type of TargetMachine for this target.
   template<typename TMC> TMC &getTM() const {
     return *static_cast<TMC*>(TM);
   }
 
   //
   void setInitialized() { Initialized = true; }
 
   CodeGenOpt::Level getOptLevel() const;
 
   /// Returns true if one of the `-start-after`, `-start-before`, `-stop-after`
   /// or `-stop-before` options is set.
   static bool hasLimitedCodeGenPipeline();
 
   /// Returns true if none of the `-stop-before` and `-stop-after` options is
   /// set.
   static bool willCompleteCodeGenPipeline();
 
   /// If hasLimitedCodeGenPipeline is true, this method
   /// returns a string with the name of the options, separated
   /// by \p Separator that caused this pipeline to be limited.
   static std::string
   getLimitedCodeGenPipelineReason(const char *Separator = "/");
 
   void setDisableVerify(bool Disable) { setOpt(DisableVerify, Disable); }
 
   bool getEnableTailMerge() const { return EnableTailMerge; }
   void setEnableTailMerge(bool Enable) { setOpt(EnableTailMerge, Enable); }
 
   bool requiresCodeGenSCCOrder() const { return RequireCodeGenSCCOrder; }
   void setRequiresCodeGenSCCOrder(bool Enable = true) {
     setOpt(RequireCodeGenSCCOrder, Enable);
   }
 
   /// Allow the target to override a specific pass without overriding the pass
   /// pipeline. When passes are added to the standard pipeline at the
   /// point where StandardID is expected, add TargetID in its place.
   void substitutePass(AnalysisID StandardID, IdentifyingPassPtr TargetID);
 
   /// Insert InsertedPassID pass after TargetPassID pass.
   void insertPass(AnalysisID TargetPassID, IdentifyingPassPtr InsertedPassID,
                   bool VerifyAfter = true);
 
   /// Allow the target to enable a specific standard pass by default.
   void enablePass(AnalysisID PassID) { substitutePass(PassID, PassID); }
 
   /// Allow the target to disable a specific standard pass by default.
   void disablePass(AnalysisID PassID) {
     substitutePass(PassID, IdentifyingPassPtr());
   }
 
   /// Return the pass substituted for StandardID by the target.
   /// If no substitution exists, return StandardID.
   IdentifyingPassPtr getPassSubstitution(AnalysisID StandardID) const;
 
   /// Return true if the pass has been substituted by the target or
   /// overridden on the command line.
   bool isPassSubstitutedOrOverridden(AnalysisID ID) const;
 
   /// Return true if the optimized regalloc pipeline is enabled.
   bool getOptimizeRegAlloc() const;
 
   /// Return true if the default global register allocator is in use and
   /// has not be overriden on the command line with '-regalloc=...'
   bool usingDefaultRegAlloc() const;
 
   /// High level function that adds all passes necessary to go from llvm IR
   /// representation to the MI representation.
   /// Adds IR based lowering and target specific optimization passes and finally
   /// the core instruction selection passes.
   /// \returns true if an error occurred, false otherwise.
   bool addISelPasses();
 
   /// Add common target configurable passes that perform LLVM IR to IR
   /// transforms following machine independent optimization.
   virtual void addIRPasses();
 
   /// Add passes to lower exception handling for the code generator.
   void addPassesToHandleExceptions();
 
   /// Add pass to prepare the LLVM IR for code generation. This should be done
   /// before exception handling preparation passes.
   virtual void addCodeGenPrepare();
 
   /// Add common passes that perform LLVM IR to IR transforms in preparation for
   /// instruction selection.
   virtual void addISelPrepare();
 
   /// addInstSelector - This method should install an instruction selector pass,
   /// which converts from LLVM code to machine instructions.
   virtual bool addInstSelector() {
     return true;
   }
 
   /// This method should install an IR translator pass, which converts from
   /// LLVM code to machine instructions with possibly generic opcodes.
   virtual bool addIRTranslator() { return true; }
 
   /// This method may be implemented by targets that want to run passes
   /// immediately before legalization.
   virtual void addPreLegalizeMachineIR() {}
 
   /// This method should install a legalize pass, which converts the instruction
   /// sequence into one that can be selected by the target.
   virtual bool addLegalizeMachineIR() { return true; }
 
   /// This method may be implemented by targets that want to run passes
   /// immediately before the register bank selection.
   virtual void addPreRegBankSelect() {}
 
   /// This method should install a register bank selector pass, which
   /// assigns register banks to virtual registers without a register
   /// class or register banks.
   virtual bool addRegBankSelect() { return true; }
 
   /// This method may be implemented by targets that want to run passes
   /// immediately before the (global) instruction selection.
   virtual void addPreGlobalInstructionSelect() {}
 
   /// This method should install a (global) instruction selector pass, which
   /// converts possibly generic instructions to fully target-specific
   /// instructions, thereby constraining all generic virtual registers to
   /// register classes.
   virtual bool addGlobalInstructionSelect() { return true; }
 
   /// Add the complete, standard set of LLVM CodeGen passes.
   /// Fully developed targets will not generally override this.
   virtual void addMachinePasses();
 
   /// Create an instance of ScheduleDAGInstrs to be run within the standard
   /// MachineScheduler pass for this function and target at the current
   /// optimization level.
   ///
   /// This can also be used to plug a new MachineSchedStrategy into an instance
   /// of the standard ScheduleDAGMI:
   ///   return new ScheduleDAGMI(C, std::make_unique<MyStrategy>(C), /*RemoveKillFlags=*/false)
   ///
   /// Return NULL to select the default (generic) machine scheduler.
   virtual ScheduleDAGInstrs *
   createMachineScheduler(MachineSchedContext *C) const {
     return nullptr;
   }
 
   /// Similar to createMachineScheduler but used when postRA machine scheduling
   /// is enabled.
   virtual ScheduleDAGInstrs *
   createPostMachineScheduler(MachineSchedContext *C) const {
     return nullptr;
   }
 
   /// printAndVerify - Add a pass to dump then verify the machine function, if
   /// those steps are enabled.
   void printAndVerify(const std::string &Banner);
 
   /// Add a pass to print the machine function if printing is enabled.
   void addPrintPass(const std::string &Banner);
 
   /// Add a pass to perform basic verification of the machine function if
   /// verification is enabled.
   void addVerifyPass(const std::string &Banner);
 
   /// Add a pass to add synthesized debug info to the MIR.
   void addDebugifyPass();
 
   /// Add a pass to remove debug info from the MIR.
   void addStripDebugPass();
 
-  /// Add a pass to check synthesized debug info for MIR.
-  void addCheckDebugPass();
-
   /// Add standard passes before a pass that's about to be added. For example,
   /// the DebugifyMachineModulePass if it is enabled.
   void addMachinePrePasses(bool AllowDebugify = true);
 
   /// Add standard passes after a pass that has just been added. For example,
   /// the MachineVerifier if it is enabled.
   void addMachinePostPasses(const std::string &Banner, bool AllowVerify = true,
                             bool AllowStrip = true);
 
   /// Check whether or not GlobalISel should abort on error.
   /// When this is disabled, GlobalISel will fall back on SDISel instead of
   /// erroring out.
   bool isGlobalISelAbortEnabled() const;
 
   /// Check whether or not a diagnostic should be emitted when GlobalISel
   /// uses the fallback path. In other words, it will emit a diagnostic
   /// when GlobalISel failed and isGlobalISelAbortEnabled is false.
   virtual bool reportDiagnosticWhenGlobalISelFallback() const;
 
   /// Check whether continuous CSE should be enabled in GISel passes.
   /// By default, it's enabled for non O0 levels.
   virtual bool isGISelCSEEnabled() const;
 
   /// Returns the CSEConfig object to use for the current optimization level.
   virtual std::unique_ptr<CSEConfigBase> getCSEConfig() const;
diff --git a/llvm/include/llvm/InitializePasses.h b/llvm/include/llvm/InitializePasses.h
index e1b3a8dd3f3a..b8420ade06a7 100644
--- a/llvm/include/llvm/InitializePasses.h
+++ b/llvm/include/llvm/InitializePasses.h
@@ -112,7 +112,6 @@ void initializeCallGraphViewerPass(PassRegistry&);
 void initializeCallGraphWrapperPassPass(PassRegistry&);
 void initializeCallSiteSplittingLegacyPassPass(PassRegistry&);
 void initializeCalledValuePropagationLegacyPassPass(PassRegistry &);
-void initializeCheckDebugMachineModulePass(PassRegistry &);
 void initializeCodeGenPreparePass(PassRegistry&);
 void initializeConstantHoistingLegacyPassPass(PassRegistry&);
 void initializeConstantMergeLegacyPassPass(PassRegistry&);
diff --git a/llvm/lib/CodeGen/CMakeLists.txt b/llvm/lib/CodeGen/CMakeLists.txt
index d50349c514a3..7dc854cbbf20 100644
--- a/llvm/lib/CodeGen/CMakeLists.txt
+++ b/llvm/lib/CodeGen/CMakeLists.txt
@@ -1,213 +1,212 @@
 add_llvm_component_library(LLVMCodeGen
   AggressiveAntiDepBreaker.cpp
   AllocationOrder.cpp
   Analysis.cpp
   AtomicExpandPass.cpp
   BasicTargetTransformInfo.cpp
   BranchFolding.cpp
   BranchRelaxation.cpp
   BreakFalseDeps.cpp
   BuiltinGCs.cpp
   BasicBlockSections.cpp
   CalcSpillWeights.cpp
   CallingConvLower.cpp
   CFGuardLongjmp.cpp
   CFIInstrInserter.cpp
   CodeGen.cpp
   CodeGenPrepare.cpp
   CommandFlags.cpp
   CriticalAntiDepBreaker.cpp
   DeadMachineInstructionElim.cpp
   DetectDeadLanes.cpp
   DFAPacketizer.cpp
   DwarfEHPrepare.cpp
   EarlyIfConversion.cpp
   EdgeBundles.cpp
   ExecutionDomainFix.cpp
   ExpandMemCmp.cpp
   ExpandPostRAPseudos.cpp
   ExpandReductions.cpp
   FaultMaps.cpp
   FEntryInserter.cpp
   FinalizeISel.cpp
   FixupStatepointCallerSaved.cpp
   FuncletLayout.cpp
   GCMetadata.cpp
   GCMetadataPrinter.cpp
   GCRootLowering.cpp
   GCStrategy.cpp
   GlobalMerge.cpp
   HardwareLoops.cpp
   IfConversion.cpp
   ImplicitNullChecks.cpp
   IndirectBrExpandPass.cpp
   InlineSpiller.cpp
   InterferenceCache.cpp
   InterleavedAccessPass.cpp
   InterleavedLoadCombinePass.cpp
   IntrinsicLowering.cpp
   LatencyPriorityQueue.cpp
   LazyMachineBlockFrequencyInfo.cpp
   LexicalScopes.cpp
   LiveDebugVariables.cpp
   LiveIntervals.cpp
   LiveInterval.cpp
   LiveIntervalUnion.cpp
   LivePhysRegs.cpp
   LiveRangeCalc.cpp
   LiveIntervalCalc.cpp
   LiveRangeEdit.cpp
   LiveRangeShrink.cpp
   LiveRegMatrix.cpp
   LiveRegUnits.cpp
   LiveStacks.cpp
   LiveVariables.cpp
   LLVMTargetMachine.cpp
   LocalStackSlotAllocation.cpp
   LoopTraversal.cpp
   LowLevelType.cpp
   LowerEmuTLS.cpp
   MachineBasicBlock.cpp
   MachineBlockFrequencyInfo.cpp
   MachineBlockPlacement.cpp
   MachineBranchProbabilityInfo.cpp
   MachineCombiner.cpp
   MachineCopyPropagation.cpp
   MachineCSE.cpp
-  MachineCheckDebugify.cpp
   MachineDebugify.cpp
   MachineDominanceFrontier.cpp
   MachineDominators.cpp
   MachineFrameInfo.cpp
   MachineFunction.cpp
   MachineFunctionPass.cpp
   MachineFunctionPrinterPass.cpp
   MachineFunctionSplitter.cpp
   MachineInstrBundle.cpp
   MachineInstr.cpp
   MachineLICM.cpp
   MachineLoopInfo.cpp
   MachineLoopUtils.cpp
   MachineModuleInfo.cpp
   MachineModuleInfoImpls.cpp
   MachineOperand.cpp
   MachineOptimizationRemarkEmitter.cpp
   MachineOutliner.cpp
   MachinePassManager.cpp
   MachinePipeliner.cpp
   MachinePostDominators.cpp
   MachineRegionInfo.cpp
   MachineRegisterInfo.cpp
   MachineScheduler.cpp
   MachineSink.cpp
   MachineSizeOpts.cpp
   MachineSSAUpdater.cpp
   MachineStripDebug.cpp
   MachineTraceMetrics.cpp
   MachineVerifier.cpp
   ModuloSchedule.cpp
   MultiHazardRecognizer.cpp
   PatchableFunction.cpp
   MBFIWrapper.cpp
   MIRPrinter.cpp
   MIRPrintingPass.cpp
   MacroFusion.cpp
   NonRelocatableStringpool.cpp
   OptimizePHIs.cpp
   ParallelCG.cpp
   PeepholeOptimizer.cpp
   PHIElimination.cpp
   PHIEliminationUtils.cpp
   PostRAHazardRecognizer.cpp
   PostRASchedulerList.cpp
   PreISelIntrinsicLowering.cpp
   ProcessImplicitDefs.cpp
   PrologEpilogInserter.cpp
   PseudoProbeInserter.cpp
   PseudoSourceValue.cpp
   RDFGraph.cpp
   RDFLiveness.cpp
   RDFRegisters.cpp
   ReachingDefAnalysis.cpp
   RegAllocBase.cpp
   RegAllocBasic.cpp
   RegAllocFast.cpp
   RegAllocGreedy.cpp
   RegAllocPBQP.cpp
   RegisterClassInfo.cpp
   RegisterCoalescer.cpp
   RegisterPressure.cpp
   RegisterScavenging.cpp
   RenameIndependentSubregs.cpp
   MachineStableHash.cpp
   MIRVRegNamerUtils.cpp
   MIRNamerPass.cpp
   MIRCanonicalizerPass.cpp
   RegisterUsageInfo.cpp
   RegUsageInfoCollector.cpp
   RegUsageInfoPropagate.cpp
   ResetMachineFunctionPass.cpp
   SafeStack.cpp
   SafeStackLayout.cpp
   ScheduleDAG.cpp
   ScheduleDAGInstrs.cpp
   ScheduleDAGPrinter.cpp
   ScoreboardHazardRecognizer.cpp
   ShadowStackGCLowering.cpp
   ShrinkWrap.cpp
   SjLjEHPrepare.cpp
   SlotIndexes.cpp
   SpillPlacement.cpp
   SplitKit.cpp
   StackColoring.cpp
   StackMapLivenessAnalysis.cpp
   StackMaps.cpp
   StackProtector.cpp
   StackSlotColoring.cpp
   SwiftErrorValueTracking.cpp
   SwitchLoweringUtils.cpp
   TailDuplication.cpp
   TailDuplicator.cpp
   TargetFrameLoweringImpl.cpp
   TargetInstrInfo.cpp
   TargetLoweringBase.cpp
   TargetLoweringObjectFileImpl.cpp
   TargetOptionsImpl.cpp
   TargetPassConfig.cpp
   TargetRegisterInfo.cpp
   TargetSchedule.cpp
   TargetSubtargetInfo.cpp
   TypePromotion.cpp
   TwoAddressInstructionPass.cpp
   UnreachableBlockElim.cpp
   ValueTypes.cpp
   VirtRegMap.cpp
   WasmEHPrepare.cpp
   WinEHPrepare.cpp
   XRayInstrumentation.cpp
 
   LiveDebugValues/LiveDebugValues.cpp
   LiveDebugValues/VarLocBasedImpl.cpp
   LiveDebugValues/InstrRefBasedImpl.cpp
 
   ADDITIONAL_HEADER_DIRS
   ${LLVM_MAIN_INCLUDE_DIR}/llvm/CodeGen
   ${LLVM_MAIN_INCLUDE_DIR}/llvm/CodeGen/PBQP
 
   LINK_LIBS ${LLVM_PTHREAD_LIB}
 
   DEPENDS
   intrinsics_gen
 
   LINK_COMPONENTS
   Analysis
   BitReader
   BitWriter
   Core
   MC
   ProfileData
   Scalar
   Support
   Target
   TransformUtils
   )
diff --git a/llvm/lib/CodeGen/CodeGen.cpp b/llvm/lib/CodeGen/CodeGen.cpp
index 94925498b01c..92a2b73f52e3 100644
--- a/llvm/lib/CodeGen/CodeGen.cpp
+++ b/llvm/lib/CodeGen/CodeGen.cpp
@@ -20,103 +20,102 @@ using namespace llvm;
 /// initializeCodeGen - Initialize all passes linked into the CodeGen library.
 void llvm::initializeCodeGen(PassRegistry &Registry) {
   initializeAtomicExpandPass(Registry);
   initializeBasicBlockSectionsPass(Registry);
   initializeBranchFolderPassPass(Registry);
   initializeBranchRelaxationPass(Registry);
   initializeCFGuardLongjmpPass(Registry);
   initializeCFIInstrInserterPass(Registry);
-  initializeCheckDebugMachineModulePass(Registry);
   initializeCodeGenPreparePass(Registry);
   initializeDeadMachineInstructionElimPass(Registry);
   initializeDebugifyMachineModulePass(Registry);
   initializeDetectDeadLanesPass(Registry);
   initializeDwarfEHPreparePass(Registry);
   initializeEarlyIfConverterPass(Registry);
   initializeEarlyIfPredicatorPass(Registry);
   initializeEarlyMachineLICMPass(Registry);
   initializeEarlyTailDuplicatePass(Registry);
   initializeExpandMemCmpPassPass(Registry);
   initializeExpandPostRAPass(Registry);
   initializeFEntryInserterPass(Registry);
   initializeFinalizeISelPass(Registry);
   initializeFinalizeMachineBundlesPass(Registry);
   initializeFixupStatepointCallerSavedPass(Registry);
   initializeFuncletLayoutPass(Registry);
   initializeGCMachineCodeAnalysisPass(Registry);
   initializeGCModuleInfoPass(Registry);
   initializeHardwareLoopsPass(Registry);
   initializeIfConverterPass(Registry);
   initializeImplicitNullChecksPass(Registry);
   initializeIndirectBrExpandPassPass(Registry);
   initializeInterleavedLoadCombinePass(Registry);
   initializeInterleavedAccessPass(Registry);
   initializeLiveDebugValuesPass(Registry);
   initializeLiveDebugVariablesPass(Registry);
   initializeLiveIntervalsPass(Registry);
   initializeLiveRangeShrinkPass(Registry);
   initializeLiveStacksPass(Registry);
   initializeLiveVariablesPass(Registry);
   initializeLocalStackSlotPassPass(Registry);
   initializeLowerIntrinsicsPass(Registry);
   initializeMIRCanonicalizerPass(Registry);
   initializeMIRNamerPass(Registry);
   initializeMachineBlockFrequencyInfoPass(Registry);
   initializeMachineBlockPlacementPass(Registry);
   initializeMachineBlockPlacementStatsPass(Registry);
   initializeMachineCSEPass(Registry);
   initializeMachineCombinerPass(Registry);
   initializeMachineCopyPropagationPass(Registry);
   initializeMachineDominatorTreePass(Registry);
   initializeMachineFunctionPrinterPassPass(Registry);
   initializeMachineLICMPass(Registry);
   initializeMachineLoopInfoPass(Registry);
   initializeMachineModuleInfoWrapperPassPass(Registry);
   initializeMachineOptimizationRemarkEmitterPassPass(Registry);
   initializeMachineOutlinerPass(Registry);
   initializeMachinePipelinerPass(Registry);
   initializeModuloScheduleTestPass(Registry);
   initializeMachinePostDominatorTreePass(Registry);
   initializeMachineRegionInfoPassPass(Registry);
   initializeMachineSchedulerPass(Registry);
   initializeMachineSinkingPass(Registry);
   initializeMachineVerifierPassPass(Registry);
   initializeOptimizePHIsPass(Registry);
   initializePEIPass(Registry);
   initializePHIEliminationPass(Registry);
   initializePatchableFunctionPass(Registry);
   initializePeepholeOptimizerPass(Registry);
   initializePostMachineSchedulerPass(Registry);
   initializePostRAHazardRecognizerPass(Registry);
   initializePostRAMachineSinkingPass(Registry);
   initializePostRASchedulerPass(Registry);
   initializePreISelIntrinsicLoweringLegacyPassPass(Registry);
   initializeProcessImplicitDefsPass(Registry);
   initializeRABasicPass(Registry);
   initializeRAGreedyPass(Registry);
   initializeRegAllocFastPass(Registry);
   initializeRegUsageInfoCollectorPass(Registry);
   initializeRegUsageInfoPropagationPass(Registry);
   initializeRegisterCoalescerPass(Registry);
   initializeRenameIndependentSubregsPass(Registry);
   initializeSafeStackLegacyPassPass(Registry);
   initializeShrinkWrapPass(Registry);
   initializeSjLjEHPreparePass(Registry);
   initializeSlotIndexesPass(Registry);
   initializeStackColoringPass(Registry);
   initializeStackMapLivenessPass(Registry);
   initializeStackProtectorPass(Registry);
   initializeStackSlotColoringPass(Registry);
   initializeStripDebugMachineModulePass(Registry);
   initializeTailDuplicatePass(Registry);
   initializeTargetPassConfigPass(Registry);
   initializeTwoAddressInstructionPassPass(Registry);
   initializeTypePromotionPass(Registry);
   initializeUnpackMachineBundlesPass(Registry);
   initializeUnreachableBlockElimLegacyPassPass(Registry);
   initializeUnreachableMachineBlockElimPass(Registry);
   initializeVirtRegMapPass(Registry);
   initializeVirtRegRewriterPass(Registry);
   initializeWasmEHPreparePass(Registry);
   initializeWinEHPreparePass(Registry);
   initializeXRayInstrumentationPass(Registry);
 }
diff --git a/llvm/lib/CodeGen/MachineCheckDebugify.cpp b/llvm/lib/CodeGen/MachineCheckDebugify.cpp
deleted file mode 100644
index bd7f0f862947..000000000000
--- a/llvm/lib/CodeGen/MachineCheckDebugify.cpp
+++ /dev/null
@@ -1,126 +0,0 @@
-//===- MachineCheckDebugify.cpp - Check debug info ------------------------===//
-//
-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
-// See https://llvm.org/LICENSE.txt for license information.
-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
-//
-//===----------------------------------------------------------------------===//
-///
-/// \file This checks debug info after mir-debugify (+ pass-to-test). Currently
-/// it simply checks the integrity of line info in DILocation and
-/// DILocalVariable which mir-debugifiy generated before.
-//===----------------------------------------------------------------------===//
-
-#include "llvm/CodeGen/MachineFunctionPass.h"
-#include "llvm/CodeGen/MachineModuleInfo.h"
-#include "llvm/CodeGen/Passes.h"
-#include "llvm/IR/DebugInfo.h"
-#include "llvm/InitializePasses.h"
-#include "llvm/Support/CommandLine.h"
-#include "llvm/Transforms/Utils/Debugify.h"
-
-#define DEBUG_TYPE "mir-check-debugify"
-
-using namespace llvm;
-
-namespace {
-
-struct CheckDebugMachineModule : public ModulePass {
-  bool runOnModule(Module &M) override {
-    MachineModuleInfo &MMI =
-        getAnalysis<MachineModuleInfoWrapperPass>().getMMI();
-
-    NamedMDNode *NMD = M.getNamedMetadata("llvm.mir.debugify");
-    if (!NMD) {
-      errs() << "WARNING: Please run mir-debugify to generate "
-                "llvm.mir.debugify metadata first.\n";
-      return false;
-    }
-
-    auto getDebugifyOperand = [&](unsigned Idx) -> unsigned {
-      return mdconst::extract<ConstantInt>(NMD->getOperand(Idx)->getOperand(0))
-          ->getZExtValue();
-    };
-    assert(NMD->getNumOperands() == 2 &&
-           "llvm.mir.debugify should have exactly 2 operands!");
-    unsigned NumLines = getDebugifyOperand(0);
-    unsigned NumVars = getDebugifyOperand(1);
-    BitVector MissingLines{NumLines, true};
-    BitVector MissingVars{NumVars, true};
-
-    for (Function &F : M.functions()) {
-      MachineFunction *MF = MMI.getMachineFunction(F);
-      if (!MF)
-        continue;
-      for (MachineBasicBlock &MBB : *MF) {
-        // Find missing lines.
-        // TODO: Avoid meta instructions other than dbg_val.
-        for (MachineInstr &MI : MBB) {
-          if (MI.isDebugValue())
-            continue;
-          const DebugLoc DL = MI.getDebugLoc();
-          if (DL && DL.getLine() != 0) {
-            MissingLines.reset(DL.getLine() - 1);
-            continue;
-          }
-
-          if (!DL) {
-            errs() << "WARNING: Instruction with empty DebugLoc in function ";
-            errs() << F.getName() << " --";
-            MI.print(errs());
-          }
-        }
-
-        // Find missing variables.
-        // TODO: Handle DBG_INSTR_REF which is under an experimental option now.
-        for (MachineInstr &MI : MBB) {
-          if (!MI.isDebugValue())
-            continue;
-          const DILocalVariable *LocalVar = MI.getDebugVariable();
-          unsigned Var = ~0U;
-
-          (void)to_integer(LocalVar->getName(), Var, 10);
-          assert(Var <= NumVars && "Unexpected name for DILocalVariable");
-          MissingVars.reset(Var - 1);
-        }
-      }
-    }
-
-    bool Fail = false;
-    for (unsigned Idx : MissingLines.set_bits()) {
-      errs() << "WARNING: Missing line " << Idx + 1 << "\n";
-      Fail = true;
-    }
-
-    for (unsigned Idx : MissingVars.set_bits()) {
-      errs() << "WARNING: Missing variable " << Idx + 1 << "\n";
-      Fail = true;
-    }
-    errs() << "Machine IR debug info check: ";
-    errs() << (Fail ? "FAIL" : "PASS") << "\n";
-
-    return false;
-  }
-
-  CheckDebugMachineModule() : ModulePass(ID) {}
-
-  void getAnalysisUsage(AnalysisUsage &AU) const override {
-    AU.addRequired<MachineModuleInfoWrapperPass>();
-    AU.addPreserved<MachineModuleInfoWrapperPass>();
-    AU.setPreservesCFG();
-  }
-
-  static char ID; // Pass identification.
-};
-char CheckDebugMachineModule::ID = 0;
-
-} // end anonymous namespace
-
-INITIALIZE_PASS_BEGIN(CheckDebugMachineModule, DEBUG_TYPE,
-                      "Machine Check Debug Module", false, false)
-INITIALIZE_PASS_END(CheckDebugMachineModule, DEBUG_TYPE,
-                    "Machine Check Debug Module", false, false)
-
-ModulePass *llvm::createCheckDebugMachineModulePass() {
-  return new CheckDebugMachineModule();
-}
diff --git a/llvm/lib/CodeGen/MachineDebugify.cpp b/llvm/lib/CodeGen/MachineDebugify.cpp
index 599a81847592..bf57ec0e8c28 100644
--- a/llvm/lib/CodeGen/MachineDebugify.cpp
+++ b/llvm/lib/CodeGen/MachineDebugify.cpp
@@ -1,31 +1,30 @@
 //===- MachineDebugify.cpp - Attach synthetic debug info to everything ----===//
 //
 // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 // See https://llvm.org/LICENSE.txt for license information.
 // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 //
 //===----------------------------------------------------------------------===//
 ///
 /// \file This pass attaches synthetic debug info to everything. It can be used
 /// to create targeted tests for debug info preservation, or test for CodeGen
 /// differences with vs. without debug info.
 ///
 /// This isn't intended to have feature parity with Debugify.
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/DenseMap.h"
-#include "llvm/ADT/SmallSet.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/CodeGen/MachineFunctionPass.h"
 #include "llvm/CodeGen/MachineInstrBuilder.h"
 #include "llvm/CodeGen/MachineModuleInfo.h"
 #include "llvm/CodeGen/Passes.h"
 #include "llvm/CodeGen/TargetInstrInfo.h"
 #include "llvm/CodeGen/TargetSubtargetInfo.h"
 #include "llvm/IR/DIBuilder.h"
 #include "llvm/IR/DebugInfo.h"
 #include "llvm/IR/IntrinsicInst.h"
 #include "llvm/InitializePasses.h"
 #include "llvm/Transforms/Utils/Debugify.h"
 
 #define DEBUG_TYPE "mir-debugify"
@@ -36,134 +35,105 @@ namespace {
 bool applyDebugifyMetadataToMachineFunction(MachineModuleInfo &MMI,
                                             DIBuilder &DIB, Function &F) {
   MachineFunction *MaybeMF = MMI.getMachineFunction(F);
   if (!MaybeMF)
     return false;
   MachineFunction &MF = *MaybeMF;
   const TargetInstrInfo &TII = *MF.getSubtarget().getInstrInfo();
 
   DISubprogram *SP = F.getSubprogram();
   assert(SP && "IR Debugify just created it?");
 
   Module &M = *F.getParent();
   LLVMContext &Ctx = M.getContext();
 
   unsigned NextLine = SP->getLine();
   for (MachineBasicBlock &MBB : MF) {
     for (MachineInstr &MI : MBB) {
       // This will likely emit line numbers beyond the end of the imagined
       // source function and into subsequent ones. We don't do anything about
       // that as it doesn't really matter to the compiler where the line is in
       // the imaginary source code.
       MI.setDebugLoc(DILocation::get(Ctx, NextLine++, 1, SP));
     }
   }
 
   // Find local variables defined by debugify. No attempt is made to match up
   // MIR-level regs to the 'correct' IR-level variables: there isn't a simple
   // way to do that, and it isn't necessary to find interesting CodeGen bugs.
   // Instead, simply keep track of one variable per line. Later, we can insert
   // DBG_VALUE insts that point to these local variables. Emitting DBG_VALUEs
   // which cover a wide range of lines can help stress the debug info passes:
   // if we can't do that, fall back to using the local variable which precedes
   // all the others.
   Function *DbgValF = M.getFunction("llvm.dbg.value");
   DbgValueInst *EarliestDVI = nullptr;
   DenseMap<unsigned, DILocalVariable *> Line2Var;
   DIExpression *Expr = nullptr;
   if (DbgValF) {
     for (const Use &U : DbgValF->uses()) {
       auto *DVI = dyn_cast<DbgValueInst>(U.getUser());
       if (!DVI || DVI->getFunction() != &F)
         continue;
       unsigned Line = DVI->getDebugLoc().getLine();
       assert(Line != 0 && "debugify should not insert line 0 locations");
       Line2Var[Line] = DVI->getVariable();
       if (!EarliestDVI || Line < EarliestDVI->getDebugLoc().getLine())
         EarliestDVI = DVI;
       Expr = DVI->getExpression();
     }
   }
   if (Line2Var.empty())
     return true;
 
   // Now, try to insert a DBG_VALUE instruction after each real instruction.
   // Do this by introducing debug uses of each register definition. If that is
   // not possible (e.g. we have a phi or a meta instruction), emit a constant.
   uint64_t NextImm = 0;
-  SmallSet<DILocalVariable *, 16> VarSet;
   const MCInstrDesc &DbgValDesc = TII.get(TargetOpcode::DBG_VALUE);
   for (MachineBasicBlock &MBB : MF) {
     MachineBasicBlock::iterator FirstNonPHIIt = MBB.getFirstNonPHI();
-    for (auto I = MBB.begin(), E = MBB.end(); I != E;) {
+    for (auto I = MBB.begin(), E = MBB.end(); I != E; ) {
       MachineInstr &MI = *I;
       ++I;
 
       // `I` may point to a DBG_VALUE created in the previous loop iteration.
       if (MI.isDebugInstr())
         continue;
 
       // It's not allowed to insert DBG_VALUEs after a terminator.
       if (MI.isTerminator())
         continue;
 
       // Find a suitable insertion point for the DBG_VALUE.
       auto InsertBeforeIt = MI.isPHI() ? FirstNonPHIIt : I;
 
       // Find a suitable local variable for the DBG_VALUE.
       unsigned Line = MI.getDebugLoc().getLine();
       if (!Line2Var.count(Line))
         Line = EarliestDVI->getDebugLoc().getLine();
       DILocalVariable *LocalVar = Line2Var[Line];
       assert(LocalVar && "No variable for current line?");
-      VarSet.insert(LocalVar);
 
       // Emit DBG_VALUEs for register definitions.
       SmallVector<MachineOperand *, 4> RegDefs;
       for (MachineOperand &MO : MI.operands())
         if (MO.isReg() && MO.isDef() && MO.getReg())
           RegDefs.push_back(&MO);
       for (MachineOperand *MO : RegDefs)
         BuildMI(MBB, InsertBeforeIt, MI.getDebugLoc(), DbgValDesc,
                 /*IsIndirect=*/false, *MO, LocalVar, Expr);
 
       // OK, failing that, emit a constant DBG_VALUE.
       if (RegDefs.empty()) {
         auto ImmOp = MachineOperand::CreateImm(NextImm++);
         BuildMI(MBB, InsertBeforeIt, MI.getDebugLoc(), DbgValDesc,
                 /*IsIndirect=*/false, ImmOp, LocalVar, Expr);
       }
     }
   }
 
-  // Here we save the number of lines and variables into "llvm.mir.debugify".
-  // It is useful for mir-check-debugify.
-  NamedMDNode *NMD = M.getNamedMetadata("llvm.mir.debugify");
-  IntegerType *Int32Ty = Type::getInt32Ty(Ctx);
-  if (!NMD) {
-    NMD = M.getOrInsertNamedMetadata("llvm.mir.debugify");
-    auto addDebugifyOperand = [&](unsigned N) {
-      NMD->addOperand(MDNode::get(
-          Ctx, ValueAsMetadata::getConstant(ConstantInt::get(Int32Ty, N))));
-    };
-    // Add number of lines.
-    addDebugifyOperand(NextLine - 1);
-    // Add number of variables.
-    addDebugifyOperand(VarSet.size());
-  } else {
-    assert(NMD->getNumOperands() == 2 &&
-           "llvm.mir.debugify should have exactly 2 operands!");
-    auto setDebugifyOperand = [&](unsigned Idx, unsigned N) {
-      NMD->setOperand(Idx, MDNode::get(Ctx, ValueAsMetadata::getConstant(
-                                                ConstantInt::get(Int32Ty, N))));
-    };
-    // Set number of lines.
-    setDebugifyOperand(0, NextLine - 1);
-    // Set number of variables.
-    setDebugifyOperand(1, VarSet.size());
-  }
-
   return true;
 }
 
 /// ModulePass for attaching synthetic debug info to everything, used with the
 /// legacy module pass manager.
diff --git a/llvm/lib/CodeGen/TargetPassConfig.cpp b/llvm/lib/CodeGen/TargetPassConfig.cpp
index 10c1ff988ac5..48686b9e04f8 100644
--- a/llvm/lib/CodeGen/TargetPassConfig.cpp
+++ b/llvm/lib/CodeGen/TargetPassConfig.cpp
@@ -118,14 +118,8 @@ static cl::opt<cl::boolOrDefault> DebugifyAndStripAll(
     "debugify-and-strip-all-safe", cl::Hidden,
     cl::desc(
         "Debugify MIR before and Strip debug after "
         "each pass except those known to be unsafe when debug info is present"),
     cl::ZeroOrMore);
-static cl::opt<cl::boolOrDefault> DebugifyCheckAndStripAll(
-    "debugify-check-and-strip-all-safe", cl::Hidden,
-    cl::desc(
-        "Debugify MIR before, by checking and stripping the debug info after, "
-        "each pass except those known to be unsafe when debug info is present"),
-    cl::ZeroOrMore);
 enum RunOutliner { AlwaysOutline, NeverOutline, TargetDefault };
 // Enable or disable the MachineOutliner.
 static cl::opt<RunOutliner> EnableMachineOutliner(
@@ -631,29 +625,18 @@ void TargetPassConfig::addStripDebugPass() {
   PM->add(createStripDebugMachineModulePass(/*OnlyDebugified=*/true));
 }
 
-void TargetPassConfig::addCheckDebugPass() {
-  PM->add(createCheckDebugMachineModulePass());
-}
-
 void TargetPassConfig::addMachinePrePasses(bool AllowDebugify) {
-  if (AllowDebugify && DebugifyIsSafe &&
-      (DebugifyAndStripAll == cl::BOU_TRUE ||
-       DebugifyCheckAndStripAll == cl::BOU_TRUE))
+  if (AllowDebugify && DebugifyAndStripAll == cl::BOU_TRUE && DebugifyIsSafe)
     addDebugifyPass();
 }
 
 void TargetPassConfig::addMachinePostPasses(const std::string &Banner,
                                             bool AllowVerify, bool AllowStrip) {
-  if (DebugifyIsSafe) {
-    if (DebugifyCheckAndStripAll == cl::BOU_TRUE) {
-      addCheckDebugPass();
-      addStripDebugPass();
-    } else if (DebugifyAndStripAll == cl::BOU_TRUE)
-      addStripDebugPass();
-  }
+  if (DebugifyAndStripAll == cl::BOU_TRUE && DebugifyIsSafe)
+    addStripDebugPass();
   if (AllowVerify)
     addVerifyPass(Banner);
 }
 
 /// Add common target configurable passes that perform LLVM IR to IR transforms
 /// following machine independent optimization.
diff --git a/llvm/test/CodeGen/Generic/MIRDebugify/check-line-and-variables-x.mir b/llvm/test/CodeGen/Generic/MIRDebugify/check-line-and-variables-x.mir
deleted file mode 100644
index 47e78bc8a3f0..000000000000
--- a/llvm/test/CodeGen/Generic/MIRDebugify/check-line-and-variables-x.mir
+++ /dev/null
@@ -1,79 +0,0 @@
-# RUN: llc -mtriple=x86_64-unknown-linux-gnu -run-pass=mir-check-debugify -o - %s 2>&1 | FileCheck %s
---- |
-  ; ModuleID = 'check-line-and-variables.mir'
-  source_filename = "check-line-and-variables.c"
-
-  @ga = dso_local local_unnamed_addr global i32 2, align 4
-
-  ; Function Attrs: nofree norecurse nounwind uwtable writeonly
-  define dso_local i32 @foo(i32 %a, i32 %b) local_unnamed_addr #0 !dbg !9 {
-  entry:
-    %add = add nsw i32 %b, %a, !dbg !15
-    call void @llvm.dbg.value(metadata i32 %add, metadata !12, metadata !DIExpression()), !dbg !15
-    %mul = shl nsw i32 %add, 1, !dbg !16
-    call void @llvm.dbg.value(metadata i32 %mul, metadata !14, metadata !DIExpression()), !dbg !16
-    store i32 %mul, i32* @ga, align 4, !dbg !17
-    ret i32 %add, !dbg !18
-  }
-
-  declare void @llvm.dbg.value(metadata, metadata, metadata) #1
-
-  !llvm.module.flags = !{!0, !1}
-  !llvm.ident = !{!2}
-  !llvm.dbg.cu = !{!3}
-  !llvm.mir.debugify = !{!6, !7}
-  !llvm.debugify = !{!8, !7}
-
-  !0 = !{i32 1, !"wchar_size", i32 4}
-  !1 = !{i32 2, !"Debug Info Version", i32 3}
-  !2 = !{!"clang version 12.0.0 (https://github.com/llvm/llvm-project.git c0a922b3db2d39f36c0c01776cce90cc160a7d62)"}
-  !3 = distinct !DICompileUnit(language: DW_LANG_C, file: !4, producer: "debugify", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, enums: !5)
-  !4 = !DIFile(filename: "main.mir", directory: "/")
-  !5 = !{}
-  !6 = !{i32 6}
-  !7 = !{i32 2}
-  !8 = !{i32 4}
-  !9 = distinct !DISubprogram(name: "foo", linkageName: "foo", scope: null, file: !4, line: 1, type: !10, scopeLine: 1, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !3, retainedNodes: !11)
-  !10 = !DISubroutineType(types: !5)
-  !11 = !{!12, !14}
-  !12 = !DILocalVariable(name: "1", scope: !9, file: !4, line: 1, type: !13)
-  !13 = !DIBasicType(name: "ty32", size: 32, encoding: DW_ATE_unsigned)
-  !14 = !DILocalVariable(name: "2", scope: !9, file: !4, line: 2, type: !13)
-  !15 = !DILocation(line: 1, column: 1, scope: !9)
-  !16 = !DILocation(line: 2, column: 1, scope: !9)
-  !17 = !DILocation(line: 3, column: 1, scope: !9)
-  !18 = !DILocation(line: 4, column: 1, scope: !9)
-
-...
----
-name:            foo
-body:             |
-  bb.0.entry:
-    liveins: $edi, $esi
-
-    %1:gr32 = COPY $esi, debug-location !15
-    DBG_VALUE %1, $noreg, !12, !DIExpression(), debug-location !15
-    ; Let it missing !14 and debug-location !16
-    ; %0:gr32 = COPY $edi, debug-location !16
-    ; DBG_VALUE %0, $noreg, !14, !DIExpression(), debug-location !16
-    %0:gr32 = COPY $edi
-    %2:gr32 = nsw ADD32rr %1, %0, implicit-def dead $eflags, debug-location !17
-    DBG_VALUE %2, $noreg, !12, !DIExpression(), debug-location !17
-    DBG_VALUE $eflags, $noreg, !12, !DIExpression(), debug-location !17
-    %3:gr32 = nsw ADD32rr %2, %2, implicit-def dead $eflags, debug-location !18
-    DBG_VALUE %3, $noreg, !12, !DIExpression(), debug-location !18
-    DBG_VALUE $eflags, $noreg, !12, !DIExpression(), debug-location !18
-    MOV32mr $rip, 1, $noreg, @ga, $noreg, killed %3, debug-location !DILocation(line: 5, column: 1, scope: !9) :: (store 4 into @ga, !tbaa !18)
-    DBG_VALUE 0, $noreg, !12, !DIExpression(), debug-location !DILocation(line: 5, column: 1, scope: !9)
-    ; Let it miss Line 6: Change "!DILocation(line: 6, ..." to "!DILocation(line: 5, ..."
-    $eax = COPY %2, debug-location !DILocation(line: 5, column: 1, scope: !9)
-    DBG_VALUE $eax, $noreg, !12, !DIExpression(), debug-location !DILocation(line: 6, column: 1, scope: !9)
-    RET 0, $eax, debug-location !DILocation(line: 7, column: 1, scope: !9)
-
-    ;CHECK:      WARNING: Instruction with empty DebugLoc in function foo --%1:gr32 = COPY $edi
-    ;CHECK-NEXT: WARNING: Missing line 2
-    ;CHECK-NEXT: WARNING: Missing line 6
-    ;CHECK-NEXT: WARNING: Missing variable 2
-    ;CHECK-NEXT: Machine IR debug info check: FAIL
-
-...
diff --git a/llvm/test/CodeGen/Generic/MIRDebugify/check-line-and-variables.ll b/llvm/test/CodeGen/Generic/MIRDebugify/check-line-and-variables.ll
deleted file mode 100644
index 1b859907db0e..000000000000
--- a/llvm/test/CodeGen/Generic/MIRDebugify/check-line-and-variables.ll
+++ /dev/null
@@ -1,29 +0,0 @@
-; RUN: llc -debugify-check-and-strip-all-safe -o - %s 2>&1 | FileCheck %s
-
-; ModuleID = 'main.c'
-source_filename = "main.c"
-
-@ga = dso_local global i32 2, align 4
-
-define dso_local i32 @foo(i32 %a, i32 %b) {
-entry:
-  %a.addr = alloca i32, align 4
-  %b.addr = alloca i32, align 4
-  %c = alloca i32, align 4
-  store i32 %a, i32* %a.addr, align 4
-  store i32 %b, i32* %b.addr, align 4
-  %0 = load i32, i32* %a.addr, align 4
-  %1 = load i32, i32* %b.addr, align 4
-  %add = add nsw i32 %0, %1
-  store i32 %add, i32* %c, align 4
-  %2 = load i32, i32* %c, align 4
-  %mul = mul nsw i32 %2, 2
-  store i32 %mul, i32* @ga, align 4
-  %3 = load i32, i32* %c, align 4
-  ret i32 %3
-}
-
-; Different Back-Ends may have different number of passes, here we only
-; check two of them to make sure -debugify-check-and-strip-all-safe works.
-;CHECK: Machine IR debug info check: PASS
-;CHECK: Machine IR debug info check: PASS
diff --git a/llvm/test/CodeGen/Generic/MIRDebugify/check-line-and-variables.mir b/llvm/test/CodeGen/Generic/MIRDebugify/check-line-and-variables.mir
deleted file mode 100644
index 1deb4fe5db09..000000000000
--- a/llvm/test/CodeGen/Generic/MIRDebugify/check-line-and-variables.mir
+++ /dev/null
@@ -1,69 +0,0 @@
-# RUN: llc -mtriple=x86_64-unknown-linux-gnu -run-pass=mir-debugify,dead-mi-elimination,mir-check-debugify -o - %s 2>&1 | FileCheck %s
-# RUN: llc -mtriple=x86_64-unknown-linux-gnu -run-pass=mir-debugify,mir-check-debugify -o - %s 2>&1 | FileCheck %s --check-prefix=CHECK-PASS
---- |
-  ; ModuleID = 'check-line-and-variables.mir'
-  source_filename = "check-line-and-variables.ll"
-
-  @ga = dso_local global i32 2, align 4
-
-  ; Function Attrs: noinline nounwind optnone uwtable
-  define dso_local i32 @foo(i32 %a, i32 %b) {
-  entry:
-    %a.addr = alloca i32, align 4
-    %b.addr = alloca i32, align 4
-    %c = alloca i32, align 4
-    store i32 %a, i32* %a.addr, align 4
-    store i32 %b, i32* %b.addr, align 4
-    %0 = load i32, i32* %a.addr, align 4
-    %1 = load i32, i32* %b.addr, align 4
-    %add = add nsw i32 %0, %1
-    store i32 %add, i32* %c, align 4
-    %2 = load i32, i32* %c, align 4
-    %mul = mul nsw i32 %2, 2
-    store i32 %mul, i32* @ga, align 4
-    %3 = load i32, i32* %c, align 4
-    ; dead-mi-elimination will remove %4 = ...
-    %4 = load i32, i32* %a.addr, align 4
-    ret i32 %3
-  }
-
-...
----
-name:            foo
-alignment:       16
-stack:
-  - { id: 0, name: a.addr, type: default, offset: 0, size: 4, alignment: 4,
-      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
-      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
-  - { id: 1, name: b.addr, type: default, offset: 0, size: 4, alignment: 4,
-      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
-      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
-  - { id: 2, name: c, type: default, offset: 0, size: 4, alignment: 4,
-      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
-      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
-body:             |
-  bb.0.entry:
-    liveins: $edi, $esi
-
-    %2:gr32 = COPY $esi
-    %0:gr32 = COPY $edi
-    %1:gr32 = COPY killed %0
-    %3:gr32 = COPY killed %2
-    MOV32mr %stack.0.a.addr, 1, $noreg, 0, $noreg, %1 :: (store 4 into %ir.a.addr)
-    MOV32mr %stack.1.b.addr, 1, $noreg, 0, $noreg, %3 :: (store 4 into %ir.b.addr)
-    %14:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (load 4 from %ir.a.addr)
-    %13:gr32 = ADD32rm killed %14, %stack.1.b.addr, 1, $noreg, 0, $noreg, implicit-def $eflags :: (load 4 from %ir.b.addr)
-    ; dead-mi-elimination will remove %15:gr32 = ...
-    %15:gr32 = MOV32rm %stack.0.a.addr, 1, $noreg, 0, $noreg :: (load 4 from %ir.a.addr)
-    MOV32mr %stack.2.c, 1, $noreg, 0, $noreg, killed %13 :: (store 4 into %ir.c)
-    %9:gr32 = MOV32rm %stack.2.c, 1, $noreg, 0, $noreg :: (load 4 from %ir.c)
-    %8:gr32 = SHL32ri killed %9, 1, implicit-def $eflags
-    MOV32mr $noreg, 1, $noreg, @ga, $noreg, killed %8 :: (store 4 into @ga)
-    %5:gr32 = MOV32rm %stack.2.c, 1, $noreg, 0, $noreg :: (load 4 from %ir.c)
-    $eax = COPY %5
-    RETQ implicit $eax
-
-    ;CHECK:      WARNING: Missing line 9
-    ;CHECK-NEXT: Machine IR debug info check: FAIL
-    ;CHECK-PASS: Machine IR debug info check: PASS
-...
diff --git a/llvm/test/CodeGen/Generic/MIRDebugify/locations-and-values.mir b/llvm/test/CodeGen/Generic/MIRDebugify/locations-and-values.mir
index 79dc90f017c1..84e93f9474b8 100644
--- a/llvm/test/CodeGen/Generic/MIRDebugify/locations-and-values.mir
+++ b/llvm/test/CodeGen/Generic/MIRDebugify/locations-and-values.mir
@@ -1,29 +1,29 @@
 # RUN: llc -run-pass=mir-debugify -o - %s | FileCheck --check-prefixes=ALL,VALUE %s
 # RUN: llc -run-pass=mir-debugify -debugify-level=locations -o - %s | FileCheck --check-prefixes=ALL --implicit-check-not=dbg.value %s
 # RUN: llc -run-pass=mir-debugify,mir-strip-debug,mir-debugify -o - %s | FileCheck --check-prefixes=ALL,VALUE %s
 --- |
   ; ModuleID = 'loc-only.ll'
   source_filename = "loc-only.ll"
   
   ; ALL-LABEL: @test
   define i32 @test(i32 %a, i32 %b) {
     %add = add i32 %a, 2
   ; ALL-NEXT:  %add = add i32 %a, 2, !dbg [[L1:![0-9]+]]
   ; VALUE-NEXT: call void @llvm.dbg.value(metadata i32 %add, metadata [[add:![0-9]+]], metadata !DIExpression()), !dbg [[L1]]
     %sub = sub i32 %add, %b
   ; ALL-NEXT: %sub = sub i32 %add, %b, !dbg [[L2:![0-9]+]]
   ; VALUE-NEXT: call void @llvm.dbg.value(metadata i32 %sub, metadata [[sub:![0-9]+]], metadata !DIExpression()), !dbg [[L2]]
   ; ALL-NEXT: ret i32 %sub, !dbg [[L3:![0-9]+]]
     ret i32 %sub
   }
 
-  ; ALL: !llvm.dbg.cu = !{![[CU:[0-9]+]]}
+  ; ALL: !llvm.dbg.cu = !{!0}
   ; ALL: !llvm.debugify =
   ; ALL: !llvm.module.flags = !{![[VERSION:[0-9]+]]}
-  ; ALL: ![[CU]] = distinct !DICompileUnit(
+  ; ALL: !0 = distinct !DICompileUnit(
   ; ALL: ![[VERSION]] = !{i32 2, !"Debug Info Version", i32 3}
   ; VALUE: [[VAR1:![0-9]+]] = !DILocalVariable(name: "1"
   ; VALUE: [[VAR2:![0-9]+]] = !DILocalVariable(name: "2"
 
 ...
 ---
@@ -31,21 +31,21 @@ name:            test
 body:             |
   bb.1 (%ir-block.0):
     %0:_(s32) = IMPLICIT_DEF
     %1:_(s32) = IMPLICIT_DEF
     %2:_(s32) = G_CONSTANT i32 2
     %3:_(s32) = G_ADD %0, %2
     %4:_(s32) = G_SUB %3, %1
     ; There's no attempt to have the locations make sense as it's an imaginary
     ; source file anyway. These first three coincide with IR-level information
     ; and therefore use metadata references.
     ; ALL: %0:_(s32) = IMPLICIT_DEF debug-location [[L1]]
     ; VALUE: DBG_VALUE %0(s32), $noreg, [[VAR1]], !DIExpression(), debug-location [[L1]]
     ; ALL: %1:_(s32) = IMPLICIT_DEF debug-location [[L2]]
     ; VALUE: DBG_VALUE %1(s32), $noreg, [[VAR2]], !DIExpression(), debug-location [[L2]]
     ; ALL: %2:_(s32) = G_CONSTANT i32 2, debug-location [[L3]]
     ; VALUE: DBG_VALUE %2(s32), $noreg, [[VAR1]], !DIExpression(), debug-location [[L3]]
-    ; ALL: %3:_(s32) = G_ADD %0, %2, debug-location !DILocation(line: 4, column: 1, scope: [[SP:![0-9]+]])
+    ; ALL: %3:_(s32) = G_ADD %0, %2, debug-location !DILocation(line: 4, column: 1, scope: !6)
     ; VALUE: DBG_VALUE %3(s32), $noreg, [[VAR1]], !DIExpression(), debug-location !DILocation(line: 4
-    ; ALL: %4:_(s32) = G_SUB %3, %1, debug-location !DILocation(line: 5, column: 1, scope: [[SP]])
+    ; ALL: %4:_(s32) = G_SUB %3, %1, debug-location !DILocation(line: 5, column: 1, scope: !6)
     ; VALUE: DBG_VALUE %4(s32), $noreg, [[VAR1]], !DIExpression(), debug-location !DILocation(line: 5
 ...
diff --git a/llvm/utils/gn/secondary/llvm/lib/CodeGen/BUILD.gn b/llvm/utils/gn/secondary/llvm/lib/CodeGen/BUILD.gn
index 961cb0b0bc46..a1e117bb716e 100644
--- a/llvm/utils/gn/secondary/llvm/lib/CodeGen/BUILD.gn
+++ b/llvm/utils/gn/secondary/llvm/lib/CodeGen/BUILD.gn
@@ -1,210 +1,209 @@
 static_library("CodeGen") {
   output_name = "LLVMCodeGen"
   public_deps = [
     # Must be a public_dep because CodeGen's headers include llvm-config.h.
     "//llvm/include/llvm/Config:llvm-config",
   ]
   deps = [
     "//llvm/lib/Analysis",
     "//llvm/lib/Bitcode/Reader",
     "//llvm/lib/Bitcode/Writer",
     "//llvm/lib/IR",
     "//llvm/lib/MC",
     "//llvm/lib/ProfileData",
     "//llvm/lib/Support",
     "//llvm/lib/Target",
     "//llvm/lib/Transforms/Scalar",
     "//llvm/lib/Transforms/Utils",
   ]
   sources = [
     "AggressiveAntiDepBreaker.cpp",
     "AllocationOrder.cpp",
     "Analysis.cpp",
     "AtomicExpandPass.cpp",
     "BasicBlockSections.cpp",
     "BasicTargetTransformInfo.cpp",
     "BranchFolding.cpp",
     "BranchRelaxation.cpp",
     "BreakFalseDeps.cpp",
     "BuiltinGCs.cpp",
     "CFGuardLongjmp.cpp",
     "CFIInstrInserter.cpp",
     "CalcSpillWeights.cpp",
     "CallingConvLower.cpp",
     "CodeGen.cpp",
     "CodeGenPrepare.cpp",
     "CommandFlags.cpp",
     "CriticalAntiDepBreaker.cpp",
     "DFAPacketizer.cpp",
     "DeadMachineInstructionElim.cpp",
     "DetectDeadLanes.cpp",
     "DwarfEHPrepare.cpp",
     "EarlyIfConversion.cpp",
     "EdgeBundles.cpp",
     "ExecutionDomainFix.cpp",
     "ExpandMemCmp.cpp",
     "ExpandPostRAPseudos.cpp",
     "ExpandReductions.cpp",
     "FEntryInserter.cpp",
     "FaultMaps.cpp",
     "FinalizeISel.cpp",
     "FixupStatepointCallerSaved.cpp",
     "FuncletLayout.cpp",
     "GCMetadata.cpp",
     "GCMetadataPrinter.cpp",
     "GCRootLowering.cpp",
     "GCStrategy.cpp",
     "GlobalMerge.cpp",
     "HardwareLoops.cpp",
     "IfConversion.cpp",
     "ImplicitNullChecks.cpp",
     "IndirectBrExpandPass.cpp",
     "InlineSpiller.cpp",
     "InterferenceCache.cpp",
     "InterleavedAccessPass.cpp",
     "InterleavedLoadCombinePass.cpp",
     "IntrinsicLowering.cpp",
     "LLVMTargetMachine.cpp",
     "LatencyPriorityQueue.cpp",
     "LazyMachineBlockFrequencyInfo.cpp",
     "LexicalScopes.cpp",
     "LiveDebugValues/InstrRefBasedImpl.cpp",
     "LiveDebugValues/LiveDebugValues.cpp",
     "LiveDebugValues/VarLocBasedImpl.cpp",
     "LiveDebugVariables.cpp",
     "LiveInterval.cpp",
     "LiveIntervalCalc.cpp",
     "LiveIntervalUnion.cpp",
     "LiveIntervals.cpp",
     "LivePhysRegs.cpp",
     "LiveRangeCalc.cpp",
     "LiveRangeEdit.cpp",
     "LiveRangeShrink.cpp",
     "LiveRegMatrix.cpp",
     "LiveRegUnits.cpp",
     "LiveStacks.cpp",
     "LiveVariables.cpp",
     "LocalStackSlotAllocation.cpp",
     "LoopTraversal.cpp",
     "LowLevelType.cpp",
     "LowerEmuTLS.cpp",
     "MBFIWrapper.cpp",
     "MIRCanonicalizerPass.cpp",
     "MIRNamerPass.cpp",
     "MIRPrinter.cpp",
     "MIRPrintingPass.cpp",
     "MIRVRegNamerUtils.cpp",
     "MachineBasicBlock.cpp",
     "MachineBlockFrequencyInfo.cpp",
     "MachineBlockPlacement.cpp",
     "MachineBranchProbabilityInfo.cpp",
     "MachineCSE.cpp",
-    "MachineCheckDebugify.cpp",
     "MachineCombiner.cpp",
     "MachineCopyPropagation.cpp",
     "MachineDebugify.cpp",
     "MachineDominanceFrontier.cpp",
     "MachineDominators.cpp",
     "MachineFrameInfo.cpp",
     "MachineFunction.cpp",
     "MachineFunctionPass.cpp",
     "MachineFunctionPrinterPass.cpp",
     "MachineFunctionSplitter.cpp",
     "MachineInstr.cpp",
     "MachineInstrBundle.cpp",
     "MachineLICM.cpp",
     "MachineLoopInfo.cpp",
     "MachineLoopUtils.cpp",
     "MachineModuleInfo.cpp",
     "MachineModuleInfoImpls.cpp",
     "MachineOperand.cpp",
     "MachineOptimizationRemarkEmitter.cpp",
     "MachineOutliner.cpp",
     "MachinePassManager.cpp",
     "MachinePipeliner.cpp",
     "MachinePostDominators.cpp",
     "MachineRegionInfo.cpp",
     "MachineRegisterInfo.cpp",
     "MachineSSAUpdater.cpp",
     "MachineScheduler.cpp",
     "MachineSink.cpp",
     "MachineSizeOpts.cpp",
     "MachineStableHash.cpp",
     "MachineStripDebug.cpp",
     "MachineTraceMetrics.cpp",
     "MachineVerifier.cpp",
     "MacroFusion.cpp",
     "ModuloSchedule.cpp",
     "MultiHazardRecognizer.cpp",
     "NonRelocatableStringpool.cpp",
     "OptimizePHIs.cpp",
     "PHIElimination.cpp",
     "PHIEliminationUtils.cpp",
     "ParallelCG.cpp",
     "PatchableFunction.cpp",
     "PeepholeOptimizer.cpp",
     "PostRAHazardRecognizer.cpp",
     "PostRASchedulerList.cpp",
     "PreISelIntrinsicLowering.cpp",
     "ProcessImplicitDefs.cpp",
     "PrologEpilogInserter.cpp",
     "PseudoProbeInserter.cpp",
     "PseudoSourceValue.cpp",
     "RDFGraph.cpp",
     "RDFLiveness.cpp",
     "RDFRegisters.cpp",
     "ReachingDefAnalysis.cpp",
     "RegAllocBase.cpp",
     "RegAllocBasic.cpp",
     "RegAllocFast.cpp",
     "RegAllocGreedy.cpp",
     "RegAllocPBQP.cpp",
     "RegUsageInfoCollector.cpp",
     "RegUsageInfoPropagate.cpp",
     "RegisterClassInfo.cpp",
     "RegisterCoalescer.cpp",
     "RegisterPressure.cpp",
     "RegisterScavenging.cpp",
     "RegisterUsageInfo.cpp",
     "RenameIndependentSubregs.cpp",
     "ResetMachineFunctionPass.cpp",
     "SafeStack.cpp",
     "SafeStackLayout.cpp",
     "ScheduleDAG.cpp",
     "ScheduleDAGInstrs.cpp",
     "ScheduleDAGPrinter.cpp",
     "ScoreboardHazardRecognizer.cpp",
     "ShadowStackGCLowering.cpp",
     "ShrinkWrap.cpp",
     "SjLjEHPrepare.cpp",
     "SlotIndexes.cpp",
     "SpillPlacement.cpp",
     "SplitKit.cpp",
     "StackColoring.cpp",
     "StackMapLivenessAnalysis.cpp",
     "StackMaps.cpp",
     "StackProtector.cpp",
     "StackSlotColoring.cpp",
     "SwiftErrorValueTracking.cpp",
     "SwitchLoweringUtils.cpp",
     "TailDuplication.cpp",
     "TailDuplicator.cpp",
     "TargetFrameLoweringImpl.cpp",
     "TargetInstrInfo.cpp",
     "TargetLoweringBase.cpp",
     "TargetLoweringObjectFileImpl.cpp",
     "TargetOptionsImpl.cpp",
     "TargetPassConfig.cpp",
     "TargetRegisterInfo.cpp",
     "TargetSchedule.cpp",
     "TargetSubtargetInfo.cpp",
     "TwoAddressInstructionPass.cpp",
     "TypePromotion.cpp",
     "UnreachableBlockElim.cpp",
     "ValueTypes.cpp",
     "VirtRegMap.cpp",
     "WasmEHPrepare.cpp",
     "WinEHPrepare.cpp",
     "XRayInstrumentation.cpp",
   ]
 }
