commit cb56694d290530ac308f44b453c18120b1c1109d
Author: Bogdan-Andrei Iancu <bogdan@opensips.org>
Date:   Fri Nov 12 14:14:23 2021 +0200

    [sipmsgops] fix parse_to_param() parsing
    
    Issue discovered during OpenSIPS Security Audit 2021,
            by Alfred Farrugia & Sandro Gauci (Enable Security)
    
    https://github.com/OpenSIPS/opensips/security/advisories/GHSA-qvj2-vqrg-f5jx

diff --git a/parser/parse_to.c b/parser/parse_to.c
index f8ac0b14f..ba71a3cfe 100644
--- a/parser/parse_to.c
+++ b/parser/parse_to.c
@@ -92,380 +92,387 @@ void free_to(struct to_body* tb)
 static inline char* parse_to_param(char *buffer, char *end,
 					struct to_body *to_b,
 					int *returned_status,
 					int multi)
 {
 	struct to_param *param;
 	int status;
 	int saved_status;
 	char  *tmp;
 
 	param=0;
 	status=E_PARA_VALUE;
 	saved_status=E_PARA_VALUE;
 	for( tmp=buffer; tmp<end; tmp++)
 	{
 		switch(*tmp)
 		{
 			case ' ':
 			case '\t':
 				switch (status)
 				{
 					case TAG3:
 						param->type=TAG_PARAM;
 					case PARA_NAME:
 					case TAG1:
 					case TAG2:
 						param->name.len = tmp-param->name.s;
 						status = S_EQUAL;
 						break;
 					case PARA_VALUE_TOKEN:
 						param->value.len = tmp-param->value.s;
 						status = E_PARA_VALUE;
 						add_param( param , to_b );
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now =' '*/
 						status=saved_status;
 						break;
 				}
 				break;
 			case '\n':
 				switch (status)
 				{
 					case S_PARA_NAME:
 					case S_EQUAL:
 					case S_PARA_VALUE:
 					case E_PARA_VALUE:
 						saved_status=status;
 						status=F_LF;
 						break;
 					case TAG3:
 						param->type=TAG_PARAM;
 					case PARA_NAME:
 					case TAG1:
 					case TAG2:
 						param->name.len = tmp-param->name.s;
 						saved_status = S_EQUAL;
 						status = F_LF;
 						break;
 					case PARA_VALUE_TOKEN:
 						param->value.len = tmp-param->value.s;
 						saved_status = E_PARA_VALUE;
 						status = F_LF;
 						add_param( param , to_b );
 						break;
 					case F_CR:
 						status=F_CRLF;
 						break;
 					case F_CRLF:
 					case F_LF:
 						status=saved_status;
 						goto endofheader;
 					default:
 						goto parse_error;
 				}
 				break;
 			case '\r':
 				switch (status)
 				{
 					case S_PARA_NAME:
 					case S_EQUAL:
 					case S_PARA_VALUE:
 					case E_PARA_VALUE:
 						saved_status=status;
 						status=F_CR;
 						break;
 					case TAG3:
 						param->type=TAG_PARAM;
 					case PARA_NAME:
 					case TAG1:
 					case TAG2:
 						param->name.len = tmp-param->name.s;
 						saved_status = S_EQUAL;
 						status = F_CR;
 						break;
 					case PARA_VALUE_TOKEN:
 						param->value.len = tmp-param->value.s;
 						saved_status = E_PARA_VALUE;
 						status = F_CR;
 						add_param( param , to_b );
 						break;
 					case F_CRLF:
 					case F_CR:
 					case F_LF:
 						status=saved_status;
 						goto endofheader;
 					default:
 						goto parse_error;
 				}
 				break;
 			case  0:
 			case ',':
 				switch (status)
 				{
 					case PARA_VALUE_QUOTED:
 						break;
 					case PARA_NAME:
 						param->name.len = tmp-param->name.s;
 					case S_EQUAL:
 					case S_PARA_VALUE:
 						if (param->type==TAG_PARAM)
 							goto parse_error;
 						param->value.s = tmp;
 					case PARA_VALUE_TOKEN:
 						status = E_PARA_VALUE;
 						param->value.len = tmp-param->value.s;
 						add_param( param , to_b );
 					case E_PARA_VALUE:
 						saved_status = status;
 						if ( !multi && *tmp==',')
 							goto parse_error;
 						goto endofheader;
 						break;
 					default:
 						goto parse_error;
 				}
 				break;
 			case '\\':
 				switch (status)
 				{
 					case PARA_VALUE_QUOTED:
+						if (tmp+1==end)
+							goto parse_error;
 						switch (*(tmp+1))
 						{
 							case '\r':
 							case '\n':
 								break;
 							default:
 								tmp++;
 								break;
 						}
 						break;
 					default:
 						goto parse_error;
 				}
 				break;
 			case '"':
 				switch (status)
 				{
 					case S_PARA_VALUE:
 						param->value.s = tmp+1;
 						status = PARA_VALUE_QUOTED;
 						break;
 					case PARA_VALUE_QUOTED:
 						param->value.len=tmp-param->value.s ;
 						add_param( param , to_b );
 						status = E_PARA_VALUE;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						goto parse_error;
 				}
 				break;
 			case ';' :
 				switch (status)
 				{
 					case PARA_VALUE_QUOTED:
 						break;
 					case PARA_NAME:
 						param->name.len = tmp-param->name.s;
 					case S_EQUAL:
 					case S_PARA_VALUE:
 						if (param->type==TAG_PARAM)
 							goto parse_error;
 						param->value.s = tmp;
 					case PARA_VALUE_TOKEN:
 						param->value.len=tmp-param->value.s;
 						add_param(param,to_b);
 					case E_PARA_VALUE:
 						param = (struct to_param*)
 							pkg_malloc(sizeof(struct to_param));
 						if (!param){
 							LM_ERR("out of pkg memory\n" );
 							goto error;
 						}
 						memset(param,0,sizeof(struct to_param));
 						param->type=GENERAL_PARAM;
 						status = S_PARA_NAME;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						goto parse_error;
 				}
 				break;
 			case 'T':
 			case 't' :
 				switch (status)
 				{
 					case PARA_VALUE_QUOTED:
 					case PARA_VALUE_TOKEN:
 					case PARA_NAME:
 						break;
 					case S_PARA_NAME:
 						param->name.s = tmp;
 						status = TAG1;
 						break;
 					case S_PARA_VALUE:
 						param->value.s = tmp;
 						status = PARA_VALUE_TOKEN;
 						break;
 					case TAG1:
 					case TAG2:
 					case TAG3:
 						status = PARA_NAME;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						goto parse_error;
 				}
 				break;
 			case 'A':
 			case 'a' :
 				switch (status)
 				{
 					case PARA_VALUE_QUOTED:
 					case PARA_VALUE_TOKEN:
 					case PARA_NAME:
 						break;
 					case S_PARA_NAME:
 						param->name.s = tmp;
 						status = PARA_NAME;
 						break;
 					case S_PARA_VALUE:
 						param->value.s = tmp;
 						status = PARA_VALUE_TOKEN;
 						break;
 					case TAG1:
 						status = TAG2;
 						break;
 					case TAG2:
 					case TAG3:
 						status = PARA_NAME;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						goto parse_error;
 				}
 				break;
 			case 'G':
 			case 'g' :
 				switch (status)
 				{
 					case PARA_VALUE_QUOTED:
 					case PARA_VALUE_TOKEN:
 					case PARA_NAME:
 						break;
 					case S_PARA_NAME:
 						param->name.s = tmp;
 						status = PARA_NAME;
 						break;
 					case S_PARA_VALUE:
 						param->value.s = tmp;
 						status = PARA_VALUE_TOKEN;
 						break;
 					case TAG1:
 					case TAG3:
 						status = PARA_NAME;
 						break;
 					case TAG2:
 						status = TAG3;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						goto parse_error;
 				}
 				break;
 			case '=':
 				switch (status)
 				{
 					case PARA_VALUE_QUOTED:
 						break;
 					case TAG3:
 						param->type=TAG_PARAM;
 					case PARA_NAME:
 					case TAG1:
 					case TAG2:
 						param->name.len = tmp-param->name.s;
 						status = S_PARA_VALUE;
 						break;
 					case S_EQUAL:
 						status = S_PARA_VALUE;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						goto parse_error;
 				}
 				break;
 			default:
 				switch (status)
 				{
 					case TAG1:
 					case TAG2:
 					case TAG3:
 						status = PARA_NAME;
 						break;
 					case PARA_VALUE_TOKEN:
 					case PARA_NAME:
 					case PARA_VALUE_QUOTED:
 						break;
 					case S_PARA_NAME:
 						param->name.s = tmp;
 						status = PARA_NAME;
 						break;
 					case S_PARA_VALUE:
 						param->value.s = tmp;
 						status = PARA_VALUE_TOKEN;
 						break;
 					case F_CRLF:
 					case F_LF:
 					case F_CR:
 						/*previous=crlf and now !=' '*/
 						goto endofheader;
 					default:
 						LM_ERR("spitting out [%c] in status %d\n",*tmp,status );
 						goto error;
 				}
 		}/*switch*/
 	}/*for*/
 
+	if (status==PARA_VALUE_QUOTED) {
+			LM_ERR("unexpected end of header in state %d\n", status);
+			goto parse_error;
+	}
 
 endofheader:
+	LM_DBG("end of header reached, state=%d\n", status);
 	if (param) {
 		if (saved_status==S_EQUAL||saved_status==S_PARA_VALUE) {
 			saved_status = E_PARA_VALUE;
 			param->value.s= 0;
 			param->value.len=0;
 			if (param->type==TAG_PARAM)
 				goto parse_error;
 			add_param(param, to_b);
 		} else {
 			pkg_free(param);
 		}
 	}
 	*returned_status=saved_status;
 	return tmp;
