commit 54bfa28536d5c05deec675cc0a85a6e1fd4a51bf
Author: Zoltan Fridrich <zfridric@redhat.com>
Date:   Thu Mar 16 10:12:13 2023 +0100

    Add PKCS#11 3.0 support to mock module
    
    Signed-off-by: Zoltan Fridrich <zfridric@redhat.com>

diff --git a/common/mock.c b/common/mock.c
index 4bcc6b9..53259ba 100644
--- a/common/mock.c
+++ b/common/mock.c
@@ -1,64 +1,64 @@
 /*
  * Copyright (c) 2011, Collabora Ltd.
- * Copyright (c) 2021, Red Hat, Inc.
+ * Copyright (c) 2021-2023, Red Hat, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  *     * Redistributions of source code must retain the above
  *       copyright notice, this list of conditions and the
  *       following disclaimer.
  *     * Redistributions in binary form must reproduce the
  *       above copyright notice, this list of conditions and
  *       the following disclaimer in the documentation and/or
  *       other materials provided with the distribution.
  *     * The names of contributors to this software may not be
  *       used to endorse or promote products derived from this
  *       software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
  * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  * DAMAGE.
  *
  * Author: Stef Walter <stefw@collabora.co.uk>
  */
 
 #include "config.h"
 
 #include "debug.h"
 #define CRYPTOKI_EXPORTS
 #include "pkcs11.h"
 #include "message.h"
 
 #include "mock.h"
 
 #include "attrs.h"
 #define P11_DEBUG_FLAG P11_DEBUG_LIB
 #include "debug.h"
 #include "dict.h"
 #include "array.h"
 #include "library.h"
 
 #include <assert.h>
 #include <ctype.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 
 /* -------------------------------------------------------------------
  * GLOBALS and SUPPORT STUFF
  */
 
 /* Various mutexes */
@@ -71,37 +71,44 @@ static pid_t pkcs11_initialized_pid = 0;
 static CK_UTF8CHAR *the_pin = NULL;
 static CK_ULONG n_the_pin = 0;
 
+static CK_UTF8CHAR *the_username = NULL;
+static CK_ULONG n_the_username = 0;
+
 static bool logged_in = false;
 static CK_USER_TYPE the_user_type = 0;
 
 typedef struct _Session {
 	CK_SESSION_HANDLE handle;
 	p11_dict *objects;
 	CK_SESSION_INFO info;
 
 	/* For find operations */
 	bool finding;
 	p11_array *matches;
 
 	bool want_context_login;
 
 	/* For encrypt, decrypt operations */
 	CK_OBJECT_HANDLE crypto_key;
 	CK_FLAGS crypto_method;
 	CK_MECHANISM_TYPE crypto_mechanism;
 	CK_BBOOL crypto_final;
+	CK_MECHANISM_TYPE message_method;
+	CK_MECHANISM message_mechanism;
+	CK_OBJECT_HANDLE message_key;
+	bool message_progress;
 
 	/* For sign, verify, digest, CKM_MOCK_COUNT */
 	CK_MECHANISM_TYPE hash_mechanism;
 	CK_FLAGS hash_method;
 	CK_OBJECT_HANDLE hash_key;
 	CK_ULONG hash_count;
 
 	/* For 'signing' with CKM_MOCK_PREFIX */
 	CK_BYTE sign_prefix[128];
 	CK_ULONG n_sign_prefix;
 
 	/* The random seed */
 	CK_BYTE random_seed[128];
 	CK_ULONG random_seed_len;
 } Session;
@@ -122,9 +129,10 @@ static void
 free_session (void *data)
 {
 	Session *sess = (Session *)data;
 	if (sess) {
 		p11_dict_free (sess->objects);
 		p11_array_free (sess->matches);
+		free (sess->message_mechanism.pParameter);
 	}
 	free (sess);
 }
@@ -301,25 +309,29 @@ static void
 module_finalize (void)
 {
 	p11_mutex_lock (&init_mutex);
 
 		/* This should stop all other calls in */
 		pkcs11_initialized = false;
 		pkcs11_initialized_pid = 0;
 
 		if (the_objects)
 			p11_dict_free (the_objects);
 		the_objects = NULL;
 
 		if (the_sessions)
 			p11_dict_free (the_sessions);
 		the_sessions = NULL;
 		logged_in = false;
 		the_user_type = 0;
 
 		free (the_pin);
 		the_pin = NULL;
 		n_the_pin = 0;
 
+		free (the_username);
+		the_username = NULL;
+		n_the_username = 0;
+
 	p11_mutex_unlock (&init_mutex);
 }
 
@@ -377,65 +389,69 @@ CK_RV
 mock_C_Initialize (CK_VOID_PTR init_args)
 {
 	CK_C_INITIALIZE_ARGS_PTR args = NULL;
 	CK_RV ret = CKR_OK;
 	pid_t pid;
 
 	p11_mutex_lock (&init_mutex);
 
 		if (init_args != NULL) {
 			int supplied_ok;
 
 			/* pReserved must be NULL */
 			args = init_args;
 
 			/* ALL supplied function pointers need to have the value either NULL or non-NULL. */
 			supplied_ok = (args->CreateMutex == NULL && args->DestroyMutex == NULL &&
 			               args->LockMutex == NULL && args->UnlockMutex == NULL) ||
 			              (args->CreateMutex != NULL && args->DestroyMutex != NULL &&
 			               args->LockMutex != NULL && args->UnlockMutex != NULL);
 			if (!supplied_ok) {
 				p11_debug_precond ("invalid set of mutex calls supplied\n");
 				ret = CKR_ARGUMENTS_BAD;
 				goto done;
 			}
 
 			/*
 			 * When the CKF_OS_LOCKING_OK flag isn't set return an error.
 			 * We must be able to use our pthread functionality.
 			 */
 			if (!(args->flags & CKF_OS_LOCKING_OK)) {
 				p11_debug_precond ("can't do without os locking\n");
 				ret = CKR_CANT_LOCK;
 				goto done;
 			}
 		}
 
 		pid = getpid ();
 		if (pkcs11_initialized) {
 
 			/* This process has called C_Initialize already */
 			if (pid == pkcs11_initialized_pid) {
 				p11_debug_precond ("p11-kit: C_Initialize called twice for same process\n");
 				ret = CKR_CRYPTOKI_ALREADY_INITIALIZED;
 				goto done;
 			}
 		}
 
 		/* We store CK_ULONG as pointers here, so verify that they fit */
 		assert (sizeof (CK_ULONG) <= sizeof (void *));
 
 		free (the_pin);
 		the_pin = (CK_UTF8CHAR_PTR)strdup ("booo");
 		n_the_pin = 4;
 
+		free (the_username);
+		the_username = (CK_UTF8CHAR_PTR)strdup ("yeah");
+		n_the_username = 4;
+
 		if (the_sessions)
 			p11_dict_free (the_sessions);
 		the_sessions = p11_dict_new (p11_dict_direct_hash,
 		                             p11_dict_direct_equal,
 		                             NULL, free_session);
 		if (!the_sessions) {
 			ret = CKR_HOST_MEMORY;
 			goto done;
 		}
 
 		module_reset_objects (MOCK_SLOT_ONE_ID);
@@ -852,6 +868,8 @@ mock_C_InitToken__specific_args (CK_SLOT_ID slot_id,
 	return CKR_OK;
 }
 
+/* TODO specific flags username */
+
 CK_RV
 mock_C_InitToken__invalid_slotid (CK_SLOT_ID slot_id,
                                   CK_UTF8CHAR_PTR pin,
@@ -3874,218 +3892,1378 @@ mock_X_GenerateRandom__invalid_handle (CK_X_FUNCTION_LIST *self,
 	return CKR_SESSION_HANDLE_INVALID;
 }
 
-CK_FUNCTION_LIST mock_module_no_slots = {
-	{ CRYPTOKI_VERSION_MAJOR, CRYPTOKI_VERSION_MINOR },  /* version */
-	mock_C_Initialize,
-	mock_C_Finalize,
-	mock_C_GetInfo,
-	mock_C_GetFunctionList_not_supported,
-	mock_C_GetSlotList__no_tokens,
-	mock_C_GetSlotInfo__invalid_slotid,
-	mock_C_GetTokenInfo__invalid_slotid,
-	mock_C_GetMechanismList__invalid_slotid,
-	mock_C_GetMechanismInfo__invalid_slotid,
-	mock_C_InitToken__invalid_slotid,
-	mock_C_InitPIN__invalid_handle,
-	mock_C_SetPIN__invalid_handle,
-	mock_C_OpenSession__invalid_slotid,
-	mock_C_CloseSession__invalid_handle,
-	mock_C_CloseAllSessions__invalid_slotid,
-	mock_C_GetSessionInfo__invalid_handle,
-	mock_C_GetOperationState__invalid_handle,
-	mock_C_SetOperationState__invalid_handle,
-	mock_C_Login__invalid_handle,
-	mock_C_Logout__invalid_handle,
-	mock_C_CreateObject__invalid_handle,
-	mock_C_CopyObject__invalid_handle,
-	mock_C_DestroyObject__invalid_handle,
-	mock_C_GetObjectSize__invalid_handle,
-	mock_C_GetAttributeValue__invalid_handle,
-	mock_C_SetAttributeValue__invalid_handle,
-	mock_C_FindObjectsInit__invalid_handle,
-	mock_C_FindObjects__invalid_handle,
-	mock_C_FindObjectsFinal__invalid_handle,
-	mock_C_EncryptInit__invalid_handle,
-	mock_C_Encrypt__invalid_handle,
-	mock_C_EncryptUpdate__invalid_handle,
-	mock_C_EncryptFinal__invalid_handle,
-	mock_C_DecryptInit__invalid_handle,
-	mock_C_Decrypt__invalid_handle,
-	mock_C_DecryptUpdate__invalid_handle,
-	mock_C_DecryptFinal__invalid_handle,
-	mock_C_DigestInit__invalid_handle,
-	mock_C_Digest__invalid_handle,
-	mock_C_DigestUpdate__invalid_handle,
-	mock_C_DigestKey__invalid_handle,
-	mock_C_DigestFinal__invalid_handle,
-	mock_C_SignInit__invalid_handle,
-	mock_C_Sign__invalid_handle,
-	mock_C_SignUpdate__invalid_handle,
-	mock_C_SignFinal__invalid_handle,
-	mock_C_SignRecoverInit__invalid_handle,
-	mock_C_SignRecover__invalid_handle,
-	mock_C_VerifyInit__invalid_handle,
-	mock_C_Verify__invalid_handle,
-	mock_C_VerifyUpdate__invalid_handle,
-	mock_C_VerifyFinal__invalid_handle,
-	mock_C_VerifyRecoverInit__invalid_handle,
-	mock_C_VerifyRecover__invalid_handle,
-	mock_C_DigestEncryptUpdate__invalid_handle,
-	mock_C_DecryptDigestUpdate__invalid_handle,
-	mock_C_SignEncryptUpdate__invalid_handle,
-	mock_C_DecryptVerifyUpdate__invalid_handle,
-	mock_C_GenerateKey__invalid_handle,
-	mock_C_GenerateKeyPair__invalid_handle,
-	mock_C_WrapKey__invalid_handle,
-	mock_C_UnwrapKey__invalid_handle,
-	mock_C_DeriveKey__invalid_handle,
-	mock_C_SeedRandom__invalid_handle,
-	mock_C_GenerateRandom__invalid_handle,
-	mock_C_GetFunctionStatus__not_parallel,
-	mock_C_CancelFunction__not_parallel,
-	mock_C_WaitForSlotEvent__no_event,
-};
+CK_RV
+mock_C_GetInterfaceList_not_supported (CK_INTERFACE_PTR interfaces_list,
+                                       CK_ULONG_PTR count)
+{
+	/* This would be a strange call to receive, should be overridden  */
+	return_val_if_reached (CKR_FUNCTION_NOT_SUPPORTED);
+}
 
-CK_X_FUNCTION_LIST mock_x_module_no_slots = {
-	{ CRYPTOKI_VERSION_MAJOR, CRYPTOKI_VERSION_MINOR },  /* version */
-	mock_X_Initialize,
-	mock_X_Finalize,
-	mock_X_GetInfo,
-	mock_X_GetSlotList__no_tokens,
-	mock_X_GetSlotInfo__invalid_slotid,
-	mock_X_GetTokenInfo__invalid_slotid,
-	mock_X_GetMechanismList__invalid_slotid,
-	mock_X_GetMechanismInfo__invalid_slotid,
-	mock_X_InitToken__invalid_slotid,
-	mock_X_InitPIN__invalid_handle,
-	mock_X_SetPIN__invalid_handle,
-	mock_X_OpenSession__invalid_slotid,
-	mock_X_CloseSession__invalid_handle,
-	mock_X_CloseAllSessions__invalid_slotid,
-	mock_X_GetSessionInfo__invalid_handle,
-	mock_X_GetOperationState__invalid_handle,
-	mock_X_SetOperationState__invalid_handle,
-	mock_X_Login__invalid_handle,
-	mock_X_Logout__invalid_handle,
-	mock_X_CreateObject__invalid_handle,
-	mock_X_CopyObject__invalid_handle,
-	mock_X_DestroyObject__invalid_handle,
-	mock_X_GetObjectSize__invalid_handle,
-	mock_X_GetAttributeValue__invalid_handle,
-	mock_X_SetAttributeValue__invalid_handle,
-	mock_X_FindObjectsInit__invalid_handle,
-	mock_X_FindObjects__invalid_handle,
-	mock_X_FindObjectsFinal__invalid_handle,
-	mock_X_EncryptInit__invalid_handle,
-	mock_X_Encrypt__invalid_handle,
-	mock_X_EncryptUpdate__invalid_handle,
-	mock_X_EncryptFinal__invalid_handle,
-	mock_X_DecryptInit__invalid_handle,
-	mock_X_Decrypt__invalid_handle,
-	mock_X_DecryptUpdate__invalid_handle,
-	mock_X_DecryptFinal__invalid_handle,
-	mock_X_DigestInit__invalid_handle,
-	mock_X_Digest__invalid_handle,
-	mock_X_DigestUpdate__invalid_handle,
-	mock_X_DigestKey__invalid_handle,
-	mock_X_DigestFinal__invalid_handle,
-	mock_X_SignInit__invalid_handle,
-	mock_X_Sign__invalid_handle,
-	mock_X_SignUpdate__invalid_handle,
-	mock_X_SignFinal__invalid_handle,
-	mock_X_SignRecoverInit__invalid_handle,
-	mock_X_SignRecover__invalid_handle,
-	mock_X_VerifyInit__invalid_handle,
-	mock_X_Verify__invalid_handle,
-	mock_X_VerifyUpdate__invalid_handle,
-	mock_X_VerifyFinal__invalid_handle,
-	mock_X_VerifyRecoverInit__invalid_handle,
-	mock_X_VerifyRecover__invalid_handle,
-	mock_X_DigestEncryptUpdate__invalid_handle,
-	mock_X_DecryptDigestUpdate__invalid_handle,
-	mock_X_SignEncryptUpdate__invalid_handle,
-	mock_X_DecryptVerifyUpdate__invalid_handle,
-	mock_X_GenerateKey__invalid_handle,
-	mock_X_GenerateKeyPair__invalid_handle,
-	mock_X_WrapKey__invalid_handle,
-	mock_X_UnwrapKey__invalid_handle,
-	mock_X_DeriveKey__invalid_handle,
-	mock_X_SeedRandom__invalid_handle,
-	mock_X_GenerateRandom__invalid_handle,
-	mock_X_WaitForSlotEvent__no_event,
-};
+CK_RV
+mock_X_GetInterfaceList_not_supported (CK_X_FUNCTION_LIST *self,
+                                       CK_INTERFACE_PTR interfaces_list,
+                                       CK_ULONG_PTR count)
+{
+	/* This would be a strange call to receive, should be overridden  */
+	return_val_if_reached (CKR_FUNCTION_NOT_SUPPORTED);
+}
+
+CK_RV
+mock_C_GetInterface_not_supported (CK_UTF8CHAR_PTR interface_name,
+                                   CK_VERSION_PTR version,
+                                   CK_INTERFACE_PTR_PTR interface,
+                                   CK_FLAGS flags)
+{
+	/* This would be a strange call to receive, should be overridden  */
+	return_val_if_reached (CKR_FUNCTION_NOT_SUPPORTED);
+}
+
+CK_RV
+mock_X_GetInterface_not_supported (CK_X_FUNCTION_LIST *self,
+                                   CK_UTF8CHAR_PTR interface_name,
+                                   CK_VERSION_PTR version,
+                                   CK_INTERFACE_PTR_PTR interface,
+                                   CK_FLAGS flags)
+{
+	/* This would be a strange call to receive, should be overridden  */
+	return_val_if_reached (CKR_FUNCTION_NOT_SUPPORTED);
+}
+
+CK_RV
+mock_C_LoginUser (CK_SESSION_HANDLE session,
+                  CK_USER_TYPE user_type,
+                  CK_UTF8CHAR_PTR pin,
+                  CK_ULONG pin_len,
+                  CK_UTF8CHAR_PTR username,
+                  CK_ULONG username_len)
+{
+	Session *sess;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (sess == NULL)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (!username)
+		return CKR_PIN_INCORRECT;
+
+	if (username_len != n_the_username)
+		return CKR_PIN_INCORRECT;
+	if (strncmp ((char *)username, (char *)the_username, username_len) != 0)
+		return CKR_PIN_INCORRECT;
+
+	return mock_C_Login (session, user_type, pin, pin_len);
+}
+
+CK_RV
+mock_C_LoginUser__invalid_handle (CK_SESSION_HANDLE session,
+                                  CK_USER_TYPE user_type,
+                                  CK_UTF8CHAR_PTR pin,
+                                  CK_ULONG pin_len,
+                                  CK_UTF8CHAR_PTR username,
+                                  CK_ULONG username_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_LoginUser__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                  CK_SESSION_HANDLE session,
+                                  CK_USER_TYPE user_type,
+                                  CK_UTF8CHAR_PTR pin,
+                                  CK_ULONG pin_len,
+                                  CK_UTF8CHAR_PTR username,
+                                  CK_ULONG username_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_SessionCancel (CK_SESSION_HANDLE session,
+                      CK_FLAGS flags)
+{
+	Session *sess;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (flags & CKF_FIND_OBJECTS)
+		sess->finding = CK_FALSE;
+	sess->hash_method &= ~flags;
+	sess->crypto_method &= ~flags;
+	sess->message_method &= ~flags;
+	sess->message_progress = false;
+	sess->crypto_mechanism = 0;
+	sess->crypto_key = 0;
+
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_SessionCancel__invalid_handle (CK_SESSION_HANDLE session,
+                                      CK_FLAGS flags)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_SessionCancel__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                      CK_SESSION_HANDLE session,
+                                      CK_FLAGS flags)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_MessageEncryptInit (CK_SESSION_HANDLE session,
+                           CK_MECHANISM_PTR mechanism,
+                           CK_OBJECT_HANDLE key)
+{
+	Session *sess;
+	CK_RV rv;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+	if (mechanism == NULL && sess->message_method == CKF_MESSAGE_ENCRYPT) {
+		sess->message_method = 0;
+		return CKR_OK;
+	}
+	if (sess->message_method != 0)
+		return CKR_OPERATION_ACTIVE;
+
+	rv = mock_C_EncryptInit (session, mechanism, key);
+	if (rv != CKR_OK)
+		return rv;
+
+	sess->message_method = CKF_MESSAGE_ENCRYPT;
+
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_MessageEncryptInit__invalid_handle (CK_SESSION_HANDLE session,
+                                           CK_MECHANISM_PTR mechanism,
+                                           CK_OBJECT_HANDLE key)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_MessageEncryptInit__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                           CK_SESSION_HANDLE session,
+                                           CK_MECHANISM_PTR mechanism,
+                                           CK_OBJECT_HANDLE key)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_EncryptMessage (CK_SESSION_HANDLE session,
+                       CK_VOID_PTR parameter,
+                       CK_ULONG parameter_len,
+                       CK_BYTE_PTR associated_data,
+                       CK_ULONG associated_data_len,
+                       CK_BYTE_PTR plaintext,
+                       CK_ULONG plaintext_len,
+                       CK_BYTE_PTR ciphertext,
+                       CK_ULONG_PTR ciphertext_len)
+{
+	CK_RV rv;
+
+	rv = mock_C_EncryptMessageBegin (session, parameter, parameter_len,
+	                                 associated_data, associated_data_len);
+	if (rv != CKR_OK)
+		return rv;
+
+	return mock_C_EncryptMessageNext (session, parameter, parameter_len, plaintext, plaintext_len,
+	                                  ciphertext, ciphertext_len, CKF_END_OF_MESSAGE);
+}
+
+CK_RV
+mock_C_EncryptMessage__invalid_handle (CK_SESSION_HANDLE session,
+                                       CK_VOID_PTR parameter,
+                                       CK_ULONG parameter_len,
+                                       CK_BYTE_PTR associated_data,
+                                       CK_ULONG associated_data_len,
+                                       CK_BYTE_PTR plaintext,
+                                       CK_ULONG plaintext_len,
+                                       CK_BYTE_PTR ciphertext,
+                                       CK_ULONG_PTR ciphertext_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_EncryptMessage__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                       CK_SESSION_HANDLE session,
+                                       CK_VOID_PTR parameter,
+                                       CK_ULONG parameter_len,
+                                       CK_BYTE_PTR associated_data,
+                                       CK_ULONG associated_data_len,
+                                       CK_BYTE_PTR plaintext,
+                                       CK_ULONG plaintext_len,
+                                       CK_BYTE_PTR ciphertext,
+                                       CK_ULONG_PTR ciphertext_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_EncryptMessageBegin (CK_SESSION_HANDLE session,
+                            CK_VOID_PTR parameter,
+                            CK_ULONG parameter_len,
+                            CK_BYTE_PTR associated_data,
+                            CK_ULONG associated_data_len)
+{
+	Session *sess;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_ENCRYPT)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	if (parameter_len != 13 || memcmp (parameter, "encrypt-param", 13))
+		return CKR_ARGUMENTS_BAD;
+
+	/* no AEAD */
+	if (associated_data != NULL || associated_data_len != 0)
+		return CKR_ARGUMENTS_BAD;
+
+	sess->message_progress = true;
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_EncryptMessageBegin__invalid_handle (CK_SESSION_HANDLE session,
+                                            CK_VOID_PTR parameter,
+                                            CK_ULONG parameter_len,
+                                            CK_BYTE_PTR associated_data,
+                                            CK_ULONG associated_data_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_EncryptMessageBegin__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                            CK_SESSION_HANDLE session,
+                                            CK_VOID_PTR parameter,
+                                            CK_ULONG parameter_len,
+                                            CK_BYTE_PTR associated_data,
+                                            CK_ULONG associated_data_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_EncryptMessageNext (CK_SESSION_HANDLE session,
+                           CK_VOID_PTR parameter,
+                           CK_ULONG parameter_len,
+                           CK_BYTE_PTR plaintext_part,
+                           CK_ULONG plaintext_part_len,
+                           CK_BYTE_PTR ciphertext_part,
+                           CK_ULONG_PTR ciphertext_part_len,
+                           CK_FLAGS flags)
+{
+	Session *sess;
+	CK_RV rv;
+
+	if (parameter_len != 13 || memcmp (parameter, "encrypt-param", 13))
+		return CKR_ARGUMENTS_BAD;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_ENCRYPT || !sess->message_progress)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	rv = mock_C_EncryptUpdate (session, plaintext_part, plaintext_part_len,
+	                           ciphertext_part, ciphertext_part_len);
+	if (rv == CKR_OK && flags & CKF_END_OF_MESSAGE)
+		sess->message_progress = false;
+
+	return rv;
+}
+
+CK_RV
+mock_C_EncryptMessageNext__invalid_handle (CK_SESSION_HANDLE session,
+                                           CK_VOID_PTR parameter,
+                                           CK_ULONG parameter_len,
+                                           CK_BYTE_PTR plaintext_part,
+                                           CK_ULONG plaintext_part_len,
+                                           CK_BYTE_PTR ciphertext_part,
+                                           CK_ULONG_PTR ciphertext_part_len,
+                                           CK_FLAGS flags)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_EncryptMessageNext__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                           CK_SESSION_HANDLE session,
+                                           CK_VOID_PTR parameter,
+                                           CK_ULONG parameter_len,
+                                           CK_BYTE_PTR plaintext_part,
+                                           CK_ULONG plaintext_part_len,
+                                           CK_BYTE_PTR ciphertext_part,
+                                           CK_ULONG_PTR ciphertext_part_len,
+                                           CK_FLAGS flags)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_MessageEncryptFinal (CK_SESSION_HANDLE session)
+{
+	Session *sess;
+	unsigned long len = 0;
+	int rv;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_ENCRYPT)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	sess->message_method = 0;
+	sess->message_progress = false;
+
+	rv = mock_C_EncryptFinal (session, NULL, &len);
+	assert (len == 0);
+	return rv;
+}
+
+CK_RV
+mock_C_MessageEncryptFinal__invalid_handle (CK_SESSION_HANDLE session)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_MessageEncryptFinal__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                            CK_SESSION_HANDLE session)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_MessageDecryptInit (CK_SESSION_HANDLE session,
+                           CK_MECHANISM_PTR mechanism,
+                           CK_OBJECT_HANDLE key)
+{
+	CK_RV rv;
+	Session *sess;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+	if (mechanism == NULL && sess->message_method == CKF_MESSAGE_DECRYPT) {
+		sess->message_method = 0;
+		return CKR_OK;
+	}
+	if (sess->message_method != 0)
+		return CKR_OPERATION_ACTIVE;
+
+	rv = mock_C_DecryptInit (session, mechanism, key);
+	if (rv != CKR_OK)
+		return rv;
+
+	sess->message_method = CKF_MESSAGE_DECRYPT;
+
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_MessageDecryptInit__invalid_handle (CK_SESSION_HANDLE session,
+                                           CK_MECHANISM_PTR mechanism,
+                                           CK_OBJECT_HANDLE key)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_MessageDecryptInit__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                           CK_SESSION_HANDLE session,
+                                           CK_MECHANISM_PTR mechanism,
+                                           CK_OBJECT_HANDLE key)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_DecryptMessage (CK_SESSION_HANDLE session,
+                       CK_VOID_PTR parameter,
+                       CK_ULONG parameter_len,
+                       CK_BYTE_PTR associated_data,
+                       CK_ULONG associated_data_len,
+                       CK_BYTE_PTR ciphertext,
+                       CK_ULONG ciphertext_len,
+                       CK_BYTE_PTR plaintext,
+                       CK_ULONG_PTR plaintext_len)
+{
+	CK_RV rv;
+
+	rv = mock_C_DecryptMessageBegin (session, parameter, parameter_len,
+	                                 associated_data, associated_data_len);
+	if (rv != CKR_OK)
+		return rv;
+
+	return mock_C_DecryptMessageNext (session, parameter, parameter_len, ciphertext, ciphertext_len,
+	                                  plaintext, plaintext_len, CKF_END_OF_MESSAGE);
+}
+
+CK_RV
+mock_C_DecryptMessage__invalid_handle (CK_SESSION_HANDLE session,
+                                       CK_VOID_PTR parameter,
+                                       CK_ULONG parameter_len,
+                                       CK_BYTE_PTR associated_data,
+                                       CK_ULONG associated_data_len,
+                                       CK_BYTE_PTR ciphertext,
+                                       CK_ULONG ciphertext_len,
+                                       CK_BYTE_PTR plaintext,
+                                       CK_ULONG_PTR plaintext_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_DecryptMessage__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                       CK_SESSION_HANDLE session,
+                                       CK_VOID_PTR parameter,
+                                       CK_ULONG parameter_len,
+                                       CK_BYTE_PTR associated_data,
+                                       CK_ULONG associated_data_len,
+                                       CK_BYTE_PTR ciphertext,
+                                       CK_ULONG ciphertext_len,
+                                       CK_BYTE_PTR plaintext,
+                                       CK_ULONG_PTR plaintext_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_DecryptMessageBegin (CK_SESSION_HANDLE session,
+                            CK_VOID_PTR parameter,
+                            CK_ULONG parameter_len,
+                            CK_BYTE_PTR associated_data,
+                            CK_ULONG associated_data_len)
+{
+	Session *sess;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_DECRYPT)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	if (parameter_len != 13 || memcmp (parameter, "decrypt-param", 13))
+		return CKR_ARGUMENTS_BAD;
+
+	/* no AEAD */
+	if (associated_data != NULL || associated_data_len != 0)
+		return CKR_ARGUMENTS_BAD;
+
+	sess->message_progress = true;
+
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_DecryptMessageBegin__invalid_handle (CK_SESSION_HANDLE session,
+                                            CK_VOID_PTR parameter,
+                                            CK_ULONG parameter_len,
+                                            CK_BYTE_PTR associated_data,
+                                            CK_ULONG associated_data_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_DecryptMessageBegin__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                            CK_SESSION_HANDLE session,
+                                            CK_VOID_PTR parameter,
+                                            CK_ULONG parameter_len,
+                                            CK_BYTE_PTR associated_data,
+                                            CK_ULONG associated_data_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_DecryptMessageNext (CK_SESSION_HANDLE session,
+                           CK_VOID_PTR parameter,
+                           CK_ULONG parameter_len,
+                           CK_BYTE_PTR ciphertext_part,
+                           CK_ULONG ciphertext_part_len,
+                           CK_BYTE_PTR plaintext_part,
+                           CK_ULONG_PTR plaintext_part_len,
+                           CK_FLAGS flags)
+{
+	Session *sess;
+	CK_RV rv;
+
+	if (parameter_len != 13 || memcmp (parameter, "decrypt-param", 13))
+		return CKR_ARGUMENTS_BAD;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_DECRYPT || !sess->message_progress)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	rv = mock_C_DecryptUpdate (session, ciphertext_part, ciphertext_part_len,
+	                           plaintext_part, plaintext_part_len);
+	if (rv == CKR_OK && flags & CKF_END_OF_MESSAGE)
+		sess->message_progress = false;
+
+	return rv;
+}
+
+CK_RV
+mock_C_DecryptMessageNext__invalid_handle (CK_SESSION_HANDLE session,
+                                           CK_VOID_PTR parameter,
+                                           CK_ULONG parameter_len,
+                                           CK_BYTE_PTR ciphertext_part,
+                                           CK_ULONG ciphertext_part_len,
+                                           CK_BYTE_PTR plaintext_part,
+                                           CK_ULONG_PTR plaintext_part_len,
+                                           CK_FLAGS flags)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_DecryptMessageNext__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                           CK_SESSION_HANDLE session,
+                                           CK_VOID_PTR parameter,
+                                           CK_ULONG parameter_len,
+                                           CK_BYTE_PTR ciphertext_part,
+                                           CK_ULONG ciphertext_part_len,
+                                           CK_BYTE_PTR plaintext_part,
+                                           CK_ULONG_PTR plaintext_part_len,
+                                           CK_FLAGS flags)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_MessageDecryptFinal (CK_SESSION_HANDLE session)
+{
+	Session *sess;
+	unsigned long len = 0;
+	int rv;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_DECRYPT)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	sess->message_method = 0;
+	sess->message_progress = false;
+
+	rv = mock_C_DecryptFinal (session, NULL, &len);
+	assert (len == 0);
+	return rv;
+}
+
+CK_RV
+mock_C_MessageDecryptFinal__invalid_handle (CK_SESSION_HANDLE session)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_MessageDecryptFinal__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                            CK_SESSION_HANDLE session)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_MessageSignInit (CK_SESSION_HANDLE session,
+                        CK_MECHANISM_PTR mechanism,
+                        CK_OBJECT_HANDLE key)
+{
+	Session *sess;
+	CK_RV rv;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+	if (mechanism == NULL && sess->message_method == CKF_MESSAGE_SIGN) {
+		sess->message_method = 0;
+		return CKR_OK;
+	}
+	if (sess->message_method != 0)
+		return CKR_OPERATION_ACTIVE;
+
+	rv = mock_C_SignInit (session, mechanism, key);
+	if (rv != CKR_OK)
+		return rv;
+
+	sess->message_method = CKF_MESSAGE_SIGN;
+	free (sess->message_mechanism.pParameter);
+	sess->message_mechanism = *mechanism;
+	if (mechanism->pParameter != NULL) {
+		sess->message_mechanism.pParameter = memdup (mechanism->pParameter, mechanism->ulParameterLen);
+		sess->message_mechanism.ulParameterLen = mechanism->ulParameterLen;
+	}
+	sess->message_key = key;
+
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_MessageSignInit__invalid_handle (CK_SESSION_HANDLE session,
+                                        CK_MECHANISM_PTR mechanism,
+                                        CK_OBJECT_HANDLE key)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_MessageSignInit__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                        CK_SESSION_HANDLE session,
+                                        CK_MECHANISM_PTR mechanism,
+                                        CK_OBJECT_HANDLE key)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_SignMessage (CK_SESSION_HANDLE session,
+                    CK_VOID_PTR parameter,
+                    CK_ULONG parameter_len,
+                    CK_BYTE_PTR data,
+                    CK_ULONG data_len,
+                    CK_BYTE_PTR signature,
+                    CK_ULONG_PTR signature_len)
+{
+	CK_RV rv;
+
+	rv = mock_C_SignMessageBegin (session, parameter, parameter_len);
+	if (rv == CKR_OK) {
+		rv = mock_C_SignMessageNext (session, parameter, parameter_len, data, data_len,
+		                             signature, signature_len);
+	}
+
+	return rv;
+}
+
+CK_RV
+mock_C_SignMessage__invalid_handle (CK_SESSION_HANDLE session,
+                                    CK_VOID_PTR parameter,
+                                    CK_ULONG parameter_len,
+                                    CK_BYTE_PTR data,
+                                    CK_ULONG data_len,
+                                    CK_BYTE_PTR signature,
+                                    CK_ULONG_PTR signature_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_SignMessage__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                    CK_SESSION_HANDLE session,
+                                    CK_VOID_PTR parameter,
+                                    CK_ULONG parameter_len,
+                                    CK_BYTE_PTR data,
+                                    CK_ULONG data_len,
+                                    CK_BYTE_PTR signature,
+                                    CK_ULONG_PTR signature_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_SignMessageBegin (CK_SESSION_HANDLE session,
+                         CK_VOID_PTR parameter,
+                         CK_ULONG parameter_len)
+{
+	Session *sess;
+	CK_RV rv;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_SIGN)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	if (parameter_len != 10 || memcmp (parameter, "sign-param", 10))
+		return CKR_ARGUMENTS_BAD;
+
+	if (sess->hash_method != CKF_SIGN) {
+		/* The Final already terminates this mechanism */
+		rv = prefix_mechanism_init (session, CKF_SIGN, &sess->message_mechanism, sess->message_key);
+		if (rv != CKR_OK)
+			return rv;
+	}
+
+	sess->message_progress = true;
+
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_SignMessageBegin__invalid_handle (CK_SESSION_HANDLE session,
+                                         CK_VOID_PTR parameter,
+                                         CK_ULONG parameter_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_SignMessageBegin__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                         CK_SESSION_HANDLE session,
+                                         CK_VOID_PTR parameter,
+                                         CK_ULONG parameter_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_SignMessageNext (CK_SESSION_HANDLE session,
+                        CK_VOID_PTR parameter,
+                        CK_ULONG parameter_len,
+                        CK_BYTE_PTR data,
+                        CK_ULONG data_len,
+                        CK_BYTE_PTR signature,
+                        CK_ULONG_PTR signature_len)
+{
+	Session *sess;
+	CK_RV rv;
+
+	if (parameter_len != 10 || memcmp (parameter, "sign-param", 10))
+		return CKR_ARGUMENTS_BAD;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_SIGN || !sess->message_progress)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	rv = mock_C_SignUpdate (session, data, data_len);
+	if (rv != CKR_OK) {
+		return rv;
+	}
+
+	if (signature_len != NULL) {
+		rv = mock_C_SignFinal (session, signature, signature_len);
+		if (rv != CKR_BUFFER_TOO_SMALL && rv != CKR_OK)
+			sess->message_progress = false;
+	}
+
+	return rv;
+}
+
+CK_RV
+mock_C_SignMessageNext__invalid_handle (CK_SESSION_HANDLE session,
+                                        CK_VOID_PTR parameter,
+                                        CK_ULONG parameter_len,
+                                        CK_BYTE_PTR data,
+                                        CK_ULONG data_len,
+                                        CK_BYTE_PTR signature,
+                                        CK_ULONG_PTR signature_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_SignMessageNext__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                        CK_SESSION_HANDLE session,
+                                        CK_VOID_PTR parameter,
+                                        CK_ULONG parameter_len,
+                                        CK_BYTE_PTR data,
+                                        CK_ULONG data_len,
+                                        CK_BYTE_PTR signature,
+                                        CK_ULONG_PTR signature_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_MessageSignFinal (CK_SESSION_HANDLE session)
+{
+	Session *sess;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_SIGN)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	sess->message_method = 0;
+	sess->message_progress = false;
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_MessageSignFinal__invalid_handle (CK_SESSION_HANDLE session)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_MessageSignFinal__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                         CK_SESSION_HANDLE session)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_MessageVerifyInit (CK_SESSION_HANDLE session,
+                          CK_MECHANISM_PTR mechanism,
+                          CK_OBJECT_HANDLE key)
+{
+	Session *sess;
+	CK_RV rv;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+	if (mechanism == NULL && sess->message_method == CKF_MESSAGE_VERIFY) {
+		sess->message_method = 0;
+		return CKR_OK;
+	}
+	if (sess->message_method != 0)
+		return CKR_OPERATION_ACTIVE;
+
+	rv = mock_C_VerifyInit (session, mechanism, key);
+	if (rv != CKR_OK)
+		return rv;
+
+	sess->message_method = CKF_MESSAGE_VERIFY;
+	free (sess->message_mechanism.pParameter);
+	sess->message_mechanism = *mechanism;
+	if (mechanism->pParameter != NULL) {
+		sess->message_mechanism.pParameter = memdup (mechanism->pParameter, mechanism->ulParameterLen);
+		assert (sess->message_mechanism.pParameter != NULL);
+		sess->message_mechanism.ulParameterLen = mechanism->ulParameterLen;
+	}
+	sess->message_key = key;
+
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_MessageVerifyInit__invalid_handle (CK_SESSION_HANDLE session,
+                                          CK_MECHANISM_PTR mechanism,
+                                          CK_OBJECT_HANDLE key)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_MessageVerifyInit__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                          CK_SESSION_HANDLE session,
+                                          CK_MECHANISM_PTR mechanism,
+                                          CK_OBJECT_HANDLE key)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_VerifyMessage (CK_SESSION_HANDLE session,
+                      CK_VOID_PTR parameter,
+                      CK_ULONG parameter_len,
+                      CK_BYTE_PTR data,
+                      CK_ULONG data_len,
+                      CK_BYTE_PTR signature,
+                      CK_ULONG signature_len)
+{
+	CK_RV rv;
+
+	rv = mock_C_VerifyMessageBegin (session, parameter, parameter_len);
+	if (rv == CKR_OK) {
+		rv = mock_C_VerifyMessageNext (session, parameter, parameter_len, data, data_len,
+		                               signature, signature_len);
+	}
+
+	return rv;
+}
+
+CK_RV
+mock_C_VerifyMessage__invalid_handle (CK_SESSION_HANDLE session,
+                                      CK_VOID_PTR parameter,
+                                      CK_ULONG parameter_len,
+                                      CK_BYTE_PTR data,
+                                      CK_ULONG data_len,
+                                      CK_BYTE_PTR signature,
+                                      CK_ULONG signature_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_VerifyMessage__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                      CK_SESSION_HANDLE session,
+                                      CK_VOID_PTR parameter,
+                                      CK_ULONG parameter_len,
+                                      CK_BYTE_PTR data,
+                                      CK_ULONG data_len,
+                                      CK_BYTE_PTR signature,
+                                      CK_ULONG signature_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_VerifyMessageBegin (CK_SESSION_HANDLE session,
+			   CK_VOID_PTR parameter,
+			   CK_ULONG parameter_len)
+{
+	Session *sess;
+	CK_RV rv;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_VERIFY)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	if (parameter_len != 12 || memcmp (parameter, "verify-param", 12))
+		return CKR_ARGUMENTS_BAD;
+
+	if (sess->hash_method != CKF_VERIFY) {
+		/* The Final already terminates this mechanism */
+		rv = prefix_mechanism_init (session, CKF_VERIFY, &sess->message_mechanism, sess->message_key);
+		if (rv != CKR_OK)
+			return rv;
+	}
+
+	sess->message_progress = true;
+
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_VerifyMessageBegin__invalid_handle (CK_SESSION_HANDLE session,
+                                           CK_VOID_PTR parameter,
+                                           CK_ULONG parameter_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_VerifyMessageBegin__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                           CK_SESSION_HANDLE session,
+                                           CK_VOID_PTR parameter,
+                                           CK_ULONG parameter_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_VerifyMessageNext (CK_SESSION_HANDLE session,
+                          CK_VOID_PTR parameter,
+                          CK_ULONG parameter_len,
+                          CK_BYTE_PTR data,
+                          CK_ULONG data_len,
+                          CK_BYTE_PTR signature,
+                          CK_ULONG signature_len)
+{
+	Session *sess;
+	CK_RV rv;
+
+	if (parameter_len != 12 || memcmp (parameter, "verify-param", 12))
+		return CKR_ARGUMENTS_BAD;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_VERIFY || !sess->message_progress)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	rv = mock_C_VerifyUpdate (session, data, data_len);
+	if (rv != CKR_OK) {
+		return rv;
+	}
+
+	if (signature != NULL) {
+		rv = mock_C_VerifyFinal (session, signature, signature_len);
+		if (rv != CKR_BUFFER_TOO_SMALL)
+			sess->message_progress = false;
+	}
+
+	return rv;
+}
+
+CK_RV
+mock_C_VerifyMessageNext__invalid_handle (CK_SESSION_HANDLE session,
+                                          CK_VOID_PTR parameter,
+                                          CK_ULONG parameter_len,
+                                          CK_BYTE_PTR data,
+                                          CK_ULONG data_len,
+                                          CK_BYTE_PTR signature,
+                                          CK_ULONG signature_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_VerifyMessageNext__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                          CK_SESSION_HANDLE session,
+                                          CK_VOID_PTR parameter,
+                                          CK_ULONG parameter_len,
+                                          CK_BYTE_PTR data,
+                                          CK_ULONG data_len,
+                                          CK_BYTE_PTR signature,
+                                          CK_ULONG signature_len)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_C_MessageVerifyFinal (CK_SESSION_HANDLE session)
+{
+	Session *sess;
+
+	sess = p11_dict_get (the_sessions, handle_to_pointer (session));
+	if (!sess)
+		return CKR_SESSION_HANDLE_INVALID;
+
+	if (sess->message_method != CKF_MESSAGE_VERIFY)
+		return CKR_OPERATION_NOT_INITIALIZED;
+
+	sess->message_method = 0;
+	sess->message_progress = false;
+	return CKR_OK;
+}
+
+CK_RV
+mock_C_MessageVerifyFinal__invalid_handle (CK_SESSION_HANDLE session)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+CK_RV
+mock_X_MessageVerifyFinal__invalid_handle (CK_X_FUNCTION_LIST *self,
+                                           CK_SESSION_HANDLE session)
+{
+	return CKR_SESSION_HANDLE_INVALID;
+}
+
+#define MOCK_MODULE_NO_SLOTS_FUNCTIONS \
+	mock_C_Initialize, \
+	mock_C_Finalize, \
+	mock_C_GetInfo, \
+	mock_C_GetFunctionList_not_supported, \
+	mock_C_GetSlotList__no_tokens, \
+	mock_C_GetSlotInfo__invalid_slotid, \
+	mock_C_GetTokenInfo__invalid_slotid, \
+	mock_C_GetMechanismList__invalid_slotid, \
+	mock_C_GetMechanismInfo__invalid_slotid, \
+	mock_C_InitToken__invalid_slotid, \
+	mock_C_InitPIN__invalid_handle, \
+	mock_C_SetPIN__invalid_handle, \
+	mock_C_OpenSession__invalid_slotid, \
+	mock_C_CloseSession__invalid_handle, \
+	mock_C_CloseAllSessions__invalid_slotid, \
+	mock_C_GetSessionInfo__invalid_handle, \
+	mock_C_GetOperationState__invalid_handle, \
+	mock_C_SetOperationState__invalid_handle, \
+	mock_C_Login__invalid_handle, \
+	mock_C_Logout__invalid_handle, \
+	mock_C_CreateObject__invalid_handle, \
+	mock_C_CopyObject__invalid_handle, \
+	mock_C_DestroyObject__invalid_handle, \
+	mock_C_GetObjectSize__invalid_handle, \
+	mock_C_GetAttributeValue__invalid_handle, \
+	mock_C_SetAttributeValue__invalid_handle, \
+	mock_C_FindObjectsInit__invalid_handle, \
+	mock_C_FindObjects__invalid_handle, \
+	mock_C_FindObjectsFinal__invalid_handle, \
+	mock_C_EncryptInit__invalid_handle, \
+	mock_C_Encrypt__invalid_handle, \
+	mock_C_EncryptUpdate__invalid_handle, \
+	mock_C_EncryptFinal__invalid_handle, \
+	mock_C_DecryptInit__invalid_handle, \
+	mock_C_Decrypt__invalid_handle, \
+	mock_C_DecryptUpdate__invalid_handle, \
+	mock_C_DecryptFinal__invalid_handle, \
+	mock_C_DigestInit__invalid_handle, \
+	mock_C_Digest__invalid_handle, \
+	mock_C_DigestUpdate__invalid_handle, \
+	mock_C_DigestKey__invalid_handle, \
+	mock_C_DigestFinal__invalid_handle, \
+	mock_C_SignInit__invalid_handle, \
+	mock_C_Sign__invalid_handle, \
+	mock_C_SignUpdate__invalid_handle, \
+	mock_C_SignFinal__invalid_handle, \
+	mock_C_SignRecoverInit__invalid_handle, \
+	mock_C_SignRecover__invalid_handle, \
+	mock_C_VerifyInit__invalid_handle, \
+	mock_C_Verify__invalid_handle, \
+	mock_C_VerifyUpdate__invalid_handle, \
+	mock_C_VerifyFinal__invalid_handle, \
+	mock_C_VerifyRecoverInit__invalid_handle, \
+	mock_C_VerifyRecover__invalid_handle, \
+	mock_C_DigestEncryptUpdate__invalid_handle, \
+	mock_C_DecryptDigestUpdate__invalid_handle, \
+	mock_C_SignEncryptUpdate__invalid_handle, \
+	mock_C_DecryptVerifyUpdate__invalid_handle, \
+	mock_C_GenerateKey__invalid_handle, \
+	mock_C_GenerateKeyPair__invalid_handle, \
+	mock_C_WrapKey__invalid_handle, \
+	mock_C_UnwrapKey__invalid_handle, \
+	mock_C_DeriveKey__invalid_handle, \
+	mock_C_SeedRandom__invalid_handle, \
+	mock_C_GenerateRandom__invalid_handle, \
+	mock_C_GetFunctionStatus__not_parallel, \
+	mock_C_CancelFunction__not_parallel, \
+	mock_C_WaitForSlotEvent__no_event, \
+
+CK_FUNCTION_LIST mock_module_no_slots = {
+	{ CRYPTOKI_LEGACY_VERSION_MAJOR, CRYPTOKI_LEGACY_VERSION_MINOR },  /* version */
+	MOCK_MODULE_NO_SLOTS_FUNCTIONS
+};
+
+CK_FUNCTION_LIST_3_0 mock_module_v3_no_slots = {
+	{ CRYPTOKI_VERSION_MAJOR, CRYPTOKI_VERSION_MINOR },  /* version */
+	MOCK_MODULE_NO_SLOTS_FUNCTIONS
+	/* PKCS #11 3.0 */
+	mock_C_GetInterfaceList_not_supported,
+	mock_C_GetInterface_not_supported,
+	mock_C_LoginUser__invalid_handle,
+	mock_C_SessionCancel__invalid_handle,
+	mock_C_MessageEncryptInit__invalid_handle,
+	mock_C_EncryptMessage__invalid_handle,
+	mock_C_EncryptMessageBegin__invalid_handle,
+	mock_C_EncryptMessageNext__invalid_handle,
+	mock_C_MessageEncryptFinal__invalid_handle,
+	mock_C_MessageDecryptInit__invalid_handle,
+	mock_C_DecryptMessage__invalid_handle,
+	mock_C_DecryptMessageBegin__invalid_handle,
+	mock_C_DecryptMessageNext__invalid_handle,
+	mock_C_MessageDecryptFinal__invalid_handle,
+	mock_C_MessageSignInit__invalid_handle,
+	mock_C_SignMessage__invalid_handle,
+	mock_C_SignMessageBegin__invalid_handle,
+	mock_C_SignMessageNext__invalid_handle,
+	mock_C_MessageSignFinal__invalid_handle,
+	mock_C_MessageVerifyInit__invalid_handle,
+	mock_C_VerifyMessage__invalid_handle,
+	mock_C_VerifyMessageBegin__invalid_handle,
+	mock_C_VerifyMessageNext__invalid_handle,
+	mock_C_MessageVerifyFinal__invalid_handle
+};
+
+CK_X_FUNCTION_LIST mock_x_module_no_slots = {
+	{ CRYPTOKI_VERSION_MAJOR, CRYPTOKI_VERSION_MINOR },  /* version */
+	mock_X_Initialize,
+	mock_X_Finalize,
+	mock_X_GetInfo,
+	mock_X_GetSlotList__no_tokens,
+	mock_X_GetSlotInfo__invalid_slotid,
+	mock_X_GetTokenInfo__invalid_slotid,
+	mock_X_GetMechanismList__invalid_slotid,
+	mock_X_GetMechanismInfo__invalid_slotid,
+	mock_X_InitToken__invalid_slotid,
+	mock_X_InitPIN__invalid_handle,
+	mock_X_SetPIN__invalid_handle,
+	mock_X_OpenSession__invalid_slotid,
+	mock_X_CloseSession__invalid_handle,
+	mock_X_CloseAllSessions__invalid_slotid,
+	mock_X_GetSessionInfo__invalid_handle,
+	mock_X_GetOperationState__invalid_handle,
+	mock_X_SetOperationState__invalid_handle,
+	mock_X_Login__invalid_handle,
+	mock_X_Logout__invalid_handle,
+	mock_X_CreateObject__invalid_handle,
+	mock_X_CopyObject__invalid_handle,
+	mock_X_DestroyObject__invalid_handle,
+	mock_X_GetObjectSize__invalid_handle,
+	mock_X_GetAttributeValue__invalid_handle,
+	mock_X_SetAttributeValue__invalid_handle,
+	mock_X_FindObjectsInit__invalid_handle,
+	mock_X_FindObjects__invalid_handle,
+	mock_X_FindObjectsFinal__invalid_handle,
+	mock_X_EncryptInit__invalid_handle,
+	mock_X_Encrypt__invalid_handle,
+	mock_X_EncryptUpdate__invalid_handle,
+	mock_X_EncryptFinal__invalid_handle,
+	mock_X_DecryptInit__invalid_handle,
+	mock_X_Decrypt__invalid_handle,
+	mock_X_DecryptUpdate__invalid_handle,
+	mock_X_DecryptFinal__invalid_handle,
+	mock_X_DigestInit__invalid_handle,
+	mock_X_Digest__invalid_handle,
+	mock_X_DigestUpdate__invalid_handle,
+	mock_X_DigestKey__invalid_handle,
+	mock_X_DigestFinal__invalid_handle,
+	mock_X_SignInit__invalid_handle,
+	mock_X_Sign__invalid_handle,
+	mock_X_SignUpdate__invalid_handle,
+	mock_X_SignFinal__invalid_handle,
+	mock_X_SignRecoverInit__invalid_handle,
+	mock_X_SignRecover__invalid_handle,
+	mock_X_VerifyInit__invalid_handle,
+	mock_X_Verify__invalid_handle,
+	mock_X_VerifyUpdate__invalid_handle,
+	mock_X_VerifyFinal__invalid_handle,
+	mock_X_VerifyRecoverInit__invalid_handle,
+	mock_X_VerifyRecover__invalid_handle,
+	mock_X_DigestEncryptUpdate__invalid_handle,
+	mock_X_DecryptDigestUpdate__invalid_handle,
+	mock_X_SignEncryptUpdate__invalid_handle,
+	mock_X_DecryptVerifyUpdate__invalid_handle,
+	mock_X_GenerateKey__invalid_handle,
+	mock_X_GenerateKeyPair__invalid_handle,
+	mock_X_WrapKey__invalid_handle,
+	mock_X_UnwrapKey__invalid_handle,
+	mock_X_DeriveKey__invalid_handle,
+	mock_X_SeedRandom__invalid_handle,
+	mock_X_GenerateRandom__invalid_handle,
+	mock_X_WaitForSlotEvent__no_event,
+	/* PKCS #11 3.0 */
+	mock_X_LoginUser__invalid_handle,
+	mock_X_SessionCancel__invalid_handle,
+	mock_X_MessageEncryptInit__invalid_handle,
+	mock_X_EncryptMessage__invalid_handle,
+	mock_X_EncryptMessageBegin__invalid_handle,
+	mock_X_EncryptMessageNext__invalid_handle,
+	mock_X_MessageEncryptFinal__invalid_handle,
+	mock_X_MessageDecryptInit__invalid_handle,
+	mock_X_DecryptMessage__invalid_handle,
+	mock_X_DecryptMessageBegin__invalid_handle,
+	mock_X_DecryptMessageNext__invalid_handle,
+	mock_X_MessageDecryptFinal__invalid_handle,
+	mock_X_MessageSignInit__invalid_handle,
+	mock_X_SignMessage__invalid_handle,
+	mock_X_SignMessageBegin__invalid_handle,
+	mock_X_SignMessageNext__invalid_handle,
+	mock_X_MessageSignFinal__invalid_handle,
+	mock_X_MessageVerifyInit__invalid_handle,
+	mock_X_VerifyMessage__invalid_handle,
+	mock_X_VerifyMessageBegin__invalid_handle,
+	mock_X_VerifyMessageNext__invalid_handle,
+	mock_X_MessageVerifyFinal__invalid_handle
+};
+
+#define MOCK_MODULE_FUNCTIONS \
+	mock_C_Initialize, \
+	mock_C_Finalize, \
+	mock_C_GetInfo, \
+	mock_C_GetFunctionList_not_supported, \
+	mock_C_GetSlotList, \
+	mock_C_GetSlotInfo, \
+	mock_C_GetTokenInfo, \
+	mock_C_GetMechanismList, \
+	mock_C_GetMechanismInfo, \
+	mock_C_InitToken__specific_args, \
+	mock_C_InitPIN__specific_args, \
+	mock_C_SetPIN__specific_args, \
+	mock_C_OpenSession, \
+	mock_C_CloseSession, \
+	mock_C_CloseAllSessions, \
+	mock_C_GetSessionInfo, \
+	mock_C_GetOperationState, \
+	mock_C_SetOperationState, \
+	mock_C_Login, \
+	mock_C_Logout, \
+	mock_C_CreateObject, \
+	mock_C_CopyObject, \
+	mock_C_DestroyObject, \
+	mock_C_GetObjectSize, \
+	mock_C_GetAttributeValue, \
+	mock_C_SetAttributeValue, \
+	mock_C_FindObjectsInit, \
+	mock_C_FindObjects, \
+	mock_C_FindObjectsFinal, \
+	mock_C_EncryptInit, \
+	mock_C_Encrypt, \
+	mock_C_EncryptUpdate, \
+	mock_C_EncryptFinal, \
+	mock_C_DecryptInit, \
+	mock_C_Decrypt, \
+	mock_C_DecryptUpdate, \
+	mock_C_DecryptFinal, \
+	mock_C_DigestInit, \
+	mock_C_Digest, \
+	mock_C_DigestUpdate, \
+	mock_C_DigestKey, \
+	mock_C_DigestFinal, \
+	mock_C_SignInit, \
+	mock_C_Sign, \
+	mock_C_SignUpdate, \
+	mock_C_SignFinal, \
+	mock_C_SignRecoverInit, \
+	mock_C_SignRecover, \
+	mock_C_VerifyInit, \
+	mock_C_Verify, \
+	mock_C_VerifyUpdate, \
+	mock_C_VerifyFinal, \
+	mock_C_VerifyRecoverInit, \
+	mock_C_VerifyRecover, \
+	mock_C_DigestEncryptUpdate, \
+	mock_C_DecryptDigestUpdate, \
+	mock_C_SignEncryptUpdate, \
+	mock_C_DecryptVerifyUpdate, \
+	mock_C_GenerateKey, \
+	mock_C_GenerateKeyPair, \
+	mock_C_WrapKey, \
+	mock_C_UnwrapKey, \
+	mock_C_DeriveKey, \
+	mock_C_SeedRandom, \
+	mock_C_GenerateRandom, \
+	mock_C_GetFunctionStatus, \
+	mock_C_CancelFunction, \
+	mock_C_WaitForSlotEvent, \
+
+
+CK_FUNCTION_LIST mock_module = {
+	{ CRYPTOKI_LEGACY_VERSION_MAJOR, CRYPTOKI_LEGACY_VERSION_MINOR },  /* version */
+	MOCK_MODULE_FUNCTIONS
+};
+
+CK_FUNCTION_LIST_3_0 mock_module_v3 = {
+	{ CRYPTOKI_VERSION_MAJOR, CRYPTOKI_VERSION_MINOR },  /* version */
+	MOCK_MODULE_FUNCTIONS
+	/* PKCS #11 3.0 */
+	mock_C_GetInterfaceList_not_supported,
+	mock_C_GetInterface_not_supported,
+	mock_C_LoginUser,
+	mock_C_SessionCancel,
+	mock_C_MessageEncryptInit,
+	mock_C_EncryptMessage,
+	mock_C_EncryptMessageBegin,
+	mock_C_EncryptMessageNext,
+	mock_C_MessageEncryptFinal,
+	mock_C_MessageDecryptInit,
+	mock_C_DecryptMessage,
+	mock_C_DecryptMessageBegin,
+	mock_C_DecryptMessageNext,
+	mock_C_MessageDecryptFinal,
+	mock_C_MessageSignInit,
+	mock_C_SignMessage,
+	mock_C_SignMessageBegin,
+	mock_C_SignMessageNext,
+	mock_C_MessageSignFinal,
+	mock_C_MessageVerifyInit,
+	mock_C_VerifyMessage,
+	mock_C_VerifyMessageBegin,
+	mock_C_VerifyMessageNext,
+	mock_C_MessageVerifyFinal
+};
+
+CK_INTERFACE mock_interfaces[MOCK_INTERFACES] = {
+        {"PKCS 11", &mock_module_v3, 0}, /* 3.0 */
+};
 
-CK_FUNCTION_LIST mock_module = {
-	{ CRYPTOKI_VERSION_MAJOR, CRYPTOKI_VERSION_MINOR },  /* version */
-	mock_C_Initialize,
-	mock_C_Finalize,
-	mock_C_GetInfo,
-	mock_C_GetFunctionList_not_supported,
-	mock_C_GetSlotList,
-	mock_C_GetSlotInfo,
-	mock_C_GetTokenInfo,
-	mock_C_GetMechanismList,
-	mock_C_GetMechanismInfo,
-	mock_C_InitToken__specific_args,
-	mock_C_InitPIN__specific_args,
-	mock_C_SetPIN__specific_args,
-	mock_C_OpenSession,
-	mock_C_CloseSession,
-	mock_C_CloseAllSessions,
-	mock_C_GetSessionInfo,
-	mock_C_GetOperationState,
-	mock_C_SetOperationState,
-	mock_C_Login,
-	mock_C_Logout,
-	mock_C_CreateObject,
-	mock_C_CopyObject,
-	mock_C_DestroyObject,
-	mock_C_GetObjectSize,
-	mock_C_GetAttributeValue,
-	mock_C_SetAttributeValue,
-	mock_C_FindObjectsInit,
-	mock_C_FindObjects,
-	mock_C_FindObjectsFinal,
-	mock_C_EncryptInit,
-	mock_C_Encrypt,
-	mock_C_EncryptUpdate,
-	mock_C_EncryptFinal,
-	mock_C_DecryptInit,
-	mock_C_Decrypt,
-	mock_C_DecryptUpdate,
-	mock_C_DecryptFinal,
-	mock_C_DigestInit,
-	mock_C_Digest,
-	mock_C_DigestUpdate,
-	mock_C_DigestKey,
-	mock_C_DigestFinal,
-	mock_C_SignInit,
-	mock_C_Sign,
-	mock_C_SignUpdate,
-	mock_C_SignFinal,
-	mock_C_SignRecoverInit,
-	mock_C_SignRecover,
-	mock_C_VerifyInit,
-	mock_C_Verify,
-	mock_C_VerifyUpdate,
-	mock_C_VerifyFinal,
-	mock_C_VerifyRecoverInit,
-	mock_C_VerifyRecover,
-	mock_C_DigestEncryptUpdate,
-	mock_C_DecryptDigestUpdate,
-	mock_C_SignEncryptUpdate,
-	mock_C_DecryptVerifyUpdate,
-	mock_C_GenerateKey,
-	mock_C_GenerateKeyPair,
-	mock_C_WrapKey,
-	mock_C_UnwrapKey,
-	mock_C_DeriveKey,
-	mock_C_SeedRandom,
-	mock_C_GenerateRandom,
-	mock_C_GetFunctionStatus,
-	mock_C_CancelFunction,
-	mock_C_WaitForSlotEvent,
-};
 
 void
 mock_module_init (void)
diff --git a/common/mock.h b/common/mock.h
index 243e6e0..9bb03de 100644
--- a/common/mock.h
+++ b/common/mock.h
@@ -1,40 +1,40 @@
 /*
- * Copyright (c) 2013, Red Hat Inc.
+ * Copyright (c) 2013-2023, Red Hat Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
  *     * Redistributions of source code must retain the above
  *       copyright notice, this list of conditions and the
  *       following disclaimer.
  *     * Redistributions in binary form must reproduce the
  *       above copyright notice, this list of conditions and
  *       the following disclaimer in the documentation and/or
  *       other materials provided with the distribution.
  *     * The names of contributors to this software may not be
  *       used to endorse or promote products derived from this
  *       software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
  * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  * DAMAGE.
  *
  * Author: Stef Walter <stefw@redhat.com>
  */
 
 #ifndef __MOCK_H__
 #define __MOCK_H__
 
 #include "compat.h"
 #include "pkcs11.h"
 #include "pkcs11i.h"
@@ -42,52 +42,53 @@
 enum {
 	MOCK_DATA_OBJECT = 2,
 	MOCK_PRIVATE_KEY_CAPITALIZE = 3,
 	MOCK_PUBLIC_KEY_CAPITALIZE = 4,
 	MOCK_PRIVATE_KEY_PREFIX = 5,
 	MOCK_PUBLIC_KEY_PREFIX = 6,
+	MOCK_PROFILE_OBJECT = 7,
 
 	/*
 	 * CKM_MOCK_CAPITALIZE (encrypt/decrypt)
 	 * - Capitalizes to encrypt
 	 * - Lowercase to decrypt
 	 */
 	CKM_MOCK_CAPITALIZE = (CKM_VENDOR_DEFINED | 1),
 
 	/*
 	 * CKM_MOCK_PREFIX (sign/verify)
 	 * - Sign prefixes the data with a key label
 	 * - Verify unprefixes data using key label
 	 */
 	CKM_MOCK_PREFIX = (CKM_VENDOR_DEFINED | 2),
 
 	/*
 	 * CKM_MOCK_GENERATE (generate-pair)
 	 * - Generates a pair of keys, mechanism parameter should be 'generate'
 	 */
 	CKM_MOCK_GENERATE = (CKM_VENDOR_DEFINED | 3),
 
 	/*
 	 * CKM_MOCK_WRAP (wrap key)
 	 * - Wraps key by returning value, mechanism parameter should be 'wrap'
 	 */
 	CKM_MOCK_WRAP = (CKM_VENDOR_DEFINED | 4),
 
 	/*
 	 * CKM_MOCK_DERIVE (derive-key)
 	 * - Derives key by setting value to 'derived'
 	 * - Mechanism param should be 'derive'
 	 */
 	CKM_MOCK_DERIVE = (CKM_VENDOR_DEFINED | 5),
 
 	/*
 	 * CKM_MOCK_COUNT (digest)
 	 * - Counts the number of bytes, and returns a CK_ULONG 'hash' value
 	 */
 	CKM_MOCK_COUNT = (CKM_VENDOR_DEFINED | 6),
 
 	MOCK_SLOT_ONE_ID = 52,
 	MOCK_SLOT_TWO_ID = 134,
 
 	MOCK_SLOTS_PRESENT = 1,
 	MOCK_SLOTS_ALL = 2,
 };
@@ -101,11 +102,17 @@ static const CK_INFO MOCK_INFO = {
 };
 
 extern       CK_FUNCTION_LIST                            mock_module;
+extern       CK_FUNCTION_LIST_3_0                        mock_module_v3;
 
 extern       CK_FUNCTION_LIST                            mock_module_no_slots;
+extern       CK_FUNCTION_LIST_3_0                        mock_module_v3_no_slots;
 
 extern       CK_X_FUNCTION_LIST                          mock_x_module_no_slots;
 
+#define MOCK_INTERFACES 1
+extern       CK_INTERFACE                                mock_interfaces[MOCK_INTERFACES];
+
+
 void         mock_module_init                            (void);
 
 typedef bool (* mock_enumerator)                         (CK_OBJECT_HANDLE handle,
@@ -1129,6 +1136,418 @@ CK_RV        mock_C_GenerateRandom__invalid_handle       (CK_SESSION_HANDLE sess
 CK_RV        mock_X_GenerateRandom__invalid_handle       (CK_X_FUNCTION_LIST *self,
                                                           CK_SESSION_HANDLE session,
                                                           CK_BYTE_PTR random_data,
                                                           CK_ULONG random_len);
 
+CK_RV        mock_C_GetInterfaceList_not_supported       (CK_INTERFACE_PTR interfaces_list,
+                                                          CK_ULONG_PTR count);
+
+CK_RV        mock_X_GetInterfaceList_not_supported       (CK_X_FUNCTION_LIST *self,
+                                                          CK_INTERFACE_PTR interfaces_list,
+                                                          CK_ULONG_PTR count);
+
+CK_RV        mock_C_GetInterface_not_supported           (CK_UTF8CHAR_PTR interface_name,
+                                                          CK_VERSION_PTR version,
+                                                          CK_INTERFACE_PTR_PTR interface,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_X_GetInterface_not_supported           (CK_X_FUNCTION_LIST *self,
+                                                          CK_UTF8CHAR_PTR interface_name,
+                                                          CK_VERSION_PTR version,
+                                                          CK_INTERFACE_PTR_PTR interface,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_C_LoginUser                            (CK_SESSION_HANDLE session,
+                                                          CK_USER_TYPE user_type,
+                                                          CK_UTF8CHAR_PTR pin,
+                                                          CK_ULONG pin_len,
+                                                          CK_UTF8CHAR_PTR username,
+                                                          CK_ULONG username_len);
+
+CK_RV        mock_C_LoginUser__invalid_handle            (CK_SESSION_HANDLE session,
+                                                          CK_USER_TYPE user_type,
+                                                          CK_UTF8CHAR_PTR pin,
+                                                          CK_ULONG pin_len,
+                                                          CK_UTF8CHAR_PTR username,
+                                                          CK_ULONG username_len);
+
+CK_RV        mock_X_LoginUser__invalid_handle            (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_USER_TYPE user_type,
+                                                          CK_UTF8CHAR_PTR pin,
+                                                          CK_ULONG pin_len,
+                                                          CK_UTF8CHAR_PTR username,
+                                                          CK_ULONG username_len);
+
+CK_RV        mock_C_SessionCancel                        (CK_SESSION_HANDLE session,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_C_SessionCancel__invalid_handle        (CK_SESSION_HANDLE session,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_X_SessionCancel__invalid_handle        (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_C_MessageEncryptInit                   (CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_C_MessageEncryptInit__invalid_handle   (CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_X_MessageEncryptInit__invalid_handle   (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_C_EncryptMessage                       (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len,
+                                                          CK_BYTE_PTR plaintext,
+                                                          CK_ULONG plaintext_len,
+                                                          CK_BYTE_PTR ciphertext,
+                                                          CK_ULONG_PTR ciphertext_len);
+
+CK_RV        mock_C_EncryptMessage__invalid_handle       (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len,
+                                                          CK_BYTE_PTR plaintext,
+                                                          CK_ULONG plaintext_len,
+                                                          CK_BYTE_PTR ciphertext,
+                                                          CK_ULONG_PTR ciphertext_len);
+
+CK_RV        mock_X_EncryptMessage__invalid_handle       (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len,
+                                                          CK_BYTE_PTR plaintext,
+                                                          CK_ULONG plaintext_len,
+                                                          CK_BYTE_PTR ciphertext,
+                                                          CK_ULONG_PTR ciphertext_len);
+
+CK_RV        mock_C_EncryptMessageBegin                  (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len);
+
+CK_RV        mock_C_EncryptMessageBegin__invalid_handle  (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len);
+
+CK_RV        mock_X_EncryptMessageBegin__invalid_handle  (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len);
+
+CK_RV        mock_C_EncryptMessageNext                   (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR plaintext_part,
+                                                          CK_ULONG plaintext_part_len,
+                                                          CK_BYTE_PTR ciphertext_part,
+                                                          CK_ULONG_PTR ciphertext_part_len,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_C_EncryptMessageNext__invalid_handle   (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR plaintext_part,
+                                                          CK_ULONG plaintext_part_len,
+                                                          CK_BYTE_PTR ciphertext_part,
+                                                          CK_ULONG_PTR ciphertext_part_len,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_X_EncryptMessageNext__invalid_handle   (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR plaintext_part,
+                                                          CK_ULONG plaintext_part_len,
+                                                          CK_BYTE_PTR ciphertext_part,
+                                                          CK_ULONG_PTR ciphertext_part_len,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_C_MessageEncryptFinal                  (CK_SESSION_HANDLE session);
+
+CK_RV        mock_C_MessageEncryptFinal__invalid_handle  (CK_SESSION_HANDLE session);
+
+CK_RV        mock_X_MessageEncryptFinal__invalid_handle  (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session);
+
+CK_RV        mock_C_MessageDecryptInit                   (CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_C_MessageDecryptInit__invalid_handle   (CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_X_MessageDecryptInit__invalid_handle   (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_C_DecryptMessage                       (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len,
+                                                          CK_BYTE_PTR ciphertext,
+                                                          CK_ULONG ciphertext_len,
+                                                          CK_BYTE_PTR plaintext,
+                                                          CK_ULONG_PTR plaintext_len);
+
+CK_RV        mock_C_DecryptMessage__invalid_handle       (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len,
+                                                          CK_BYTE_PTR ciphertext,
+                                                          CK_ULONG ciphertext_len,
+                                                          CK_BYTE_PTR plaintext,
+                                                          CK_ULONG_PTR plaintext_len);
+
+CK_RV        mock_X_DecryptMessage__invalid_handle       (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len,
+                                                          CK_BYTE_PTR ciphertext,
+                                                          CK_ULONG ciphertext_len,
+                                                          CK_BYTE_PTR plaintext,
+                                                          CK_ULONG_PTR plaintext_len);
+
+CK_RV        mock_C_DecryptMessageBegin                  (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len);
+
+CK_RV        mock_C_DecryptMessageBegin__invalid_handle  (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len);
+
+CK_RV        mock_X_DecryptMessageBegin__invalid_handle  (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR associated_data,
+                                                          CK_ULONG associated_data_len);
+
+CK_RV        mock_C_DecryptMessageNext                   (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR ciphertext_part,
+                                                          CK_ULONG ciphertext_part_len,
+                                                          CK_BYTE_PTR plaintext_part,
+                                                          CK_ULONG_PTR plaintext_part_len,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_C_DecryptMessageNext__invalid_handle   (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR ciphertext_part,
+                                                          CK_ULONG ciphertext_part_len,
+                                                          CK_BYTE_PTR plaintext_part,
+                                                          CK_ULONG_PTR plaintext_part_len,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_X_DecryptMessageNext__invalid_handle   (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR ciphertext_part,
+                                                          CK_ULONG ciphertext_part_len,
+                                                          CK_BYTE_PTR plaintext_part,
+                                                          CK_ULONG_PTR plaintext_part_len,
+                                                          CK_FLAGS flags);
+
+CK_RV        mock_C_MessageDecryptFinal                  (CK_SESSION_HANDLE session);
+
+CK_RV        mock_C_MessageDecryptFinal__invalid_handle  (CK_SESSION_HANDLE session);
+
+CK_RV        mock_X_MessageDecryptFinal__invalid_handle  (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session);
+
+CK_RV        mock_C_MessageSignInit                       (CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_C_MessageSignInit__invalid_handle       (CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_X_MessageSignInit__invalid_handle       (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_C_SignMessage                          (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG_PTR signature_len);
+
+CK_RV        mock_C_SignMessage__invalid_handle          (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG_PTR signature_len);
+
+CK_RV        mock_X_SignMessage__invalid_handle          (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG_PTR signature_len);
+
+CK_RV        mock_C_SignMessageBegin                     (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len);
+
+CK_RV        mock_C_SignMessageBegin__invalid_handle     (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len);
+
+CK_RV        mock_X_SignMessageBegin__invalid_handle     (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len);
+
+CK_RV        mock_C_SignMessageNext                      (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG_PTR signature_len);
+
+CK_RV        mock_C_SignMessageNext__invalid_handle      (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG_PTR signature_len);
+
+CK_RV        mock_X_SignMessageNext__invalid_handle      (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG_PTR signature_len);
+
+CK_RV        mock_C_MessageSignFinal                     (CK_SESSION_HANDLE session);
+
+CK_RV        mock_C_MessageSignFinal__invalid_handle     (CK_SESSION_HANDLE session);
+
+CK_RV        mock_X_MessageSignFinal__invalid_handle     (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session);
+
+CK_RV        mock_C_MessageVerifyInit                    (CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_C_MessageVerifyInit__invalid_handle    (CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_X_MessageVerifyInit__invalid_handle    (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_MECHANISM_PTR mechanism,
+                                                          CK_OBJECT_HANDLE key);
+
+CK_RV        mock_C_VerifyMessage                        (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG signature_len);
+
+CK_RV        mock_C_VerifyMessage__invalid_handle        (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG signature_len);
+
+CK_RV        mock_X_VerifyMessage__invalid_handle        (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG signature_len);
+
+CK_RV        mock_C_VerifyMessageBegin                   (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len);
+
+CK_RV        mock_C_VerifyMessageBegin__invalid_handle   (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len);
+
+CK_RV        mock_X_VerifyMessageBegin__invalid_handle   (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len);
+
+CK_RV        mock_C_VerifyMessageNext                    (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG signature_len);
+
+CK_RV        mock_C_VerifyMessageNext__invalid_handle    (CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG signature_len);
+
+CK_RV        mock_X_VerifyMessageNext__invalid_handle    (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session,
+                                                          CK_VOID_PTR parameter,
+                                                          CK_ULONG parameter_len,
+                                                          CK_BYTE_PTR data,
+                                                          CK_ULONG data_len,
+                                                          CK_BYTE_PTR signature,
+                                                          CK_ULONG signature_len);
+
+CK_RV        mock_C_MessageVerifyFinal                   (CK_SESSION_HANDLE session);
+
+CK_RV        mock_C_MessageVerifyFinal__invalid_handle   (CK_SESSION_HANDLE session);
+
+CK_RV        mock_X_MessageVerifyFinal__invalid_handle   (CK_X_FUNCTION_LIST *self,
+                                                          CK_SESSION_HANDLE session);
+
 #endif /* __MOCK_H__ */
