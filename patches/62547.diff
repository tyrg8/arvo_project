commit cd741379bd0203a0875b413542d5f982606ae637
Author: David Anderson <davea42@linuxmail.org>
Date:   Sat Sep 23 09:39:12 2023 -0700

    Fixing DW202309-001 ossfuzz 62547, a bug
    which has been in the code for many years.
    
    The symptom was use-after-free in calling
    dwarf_finish(), but provoked by code
    in dwarf_get_fde_for_die().
        modified:   src/lib/libdwarf/dwarf_alloc.c
            modified:   src/lib/libdwarf/dwarf_frame.c
            modified:   src/lib/libdwarf/dwarf_frame2.c
            modified:   src/lib/libdwarf/dwarf_opaque.h

diff --git a/src/lib/libdwarf/dwarf_alloc.c b/src/lib/libdwarf/dwarf_alloc.c
index 6bb4c1e7..cb5642f2 100644
--- a/src/lib/libdwarf/dwarf_alloc.c
+++ b/src/lib/libdwarf/dwarf_alloc.c
@@ -1068,110 +1068,112 @@ int
 _dwarf_free_all_of_one_debug(Dwarf_Debug dbg)
 {
     unsigned g = 0;
 
     if (dbg == NULL) {
         _dwarf_free_static_errlist();
         return DW_DLV_NO_ENTRY;
     }
     if (dbg->de_magic != DBG_IS_VALID) {
         _dwarf_free_static_errlist();
         return DW_DLV_NO_ENTRY;
     }
     /*  To do complete validation that we have no surprising
         missing or erroneous deallocs it is advisable to do
         the dwarf_deallocs here
         that are not things the user can otherwise request.
         Housecleaning.  */
     if (dbg->de_cu_hashindex_data) {
         dwarf_dealloc_xu_header(dbg->de_cu_hashindex_data);
         dbg->de_cu_hashindex_data = 0;
     }
     if (dbg->de_tu_hashindex_data) {
         dwarf_dealloc_xu_header(dbg->de_tu_hashindex_data);
         dbg->de_tu_hashindex_data = 0;
     }
     if (dbg->de_printf_callback_null_device_handle) {
         fclose(dbg->de_printf_callback_null_device_handle);
         dbg->de_printf_callback_null_device_handle = 0;
     }
     freecontextlist(dbg,&dbg->de_info_reading);
     freecontextlist(dbg,&dbg->de_types_reading);
     /* Housecleaning done. Now really free all the space. */
     malloc_section_free(&dbg->de_debug_info);
     malloc_section_free(&dbg->de_debug_types);
     malloc_section_free(&dbg->de_debug_abbrev);
     malloc_section_free(&dbg->de_debug_line);
     malloc_section_free(&dbg->de_debug_line_str);
     malloc_section_free(&dbg->de_debug_loc);
     malloc_section_free(&dbg->de_debug_aranges);
     malloc_section_free(&dbg->de_debug_macinfo);
     malloc_section_free(&dbg->de_debug_macro);
     malloc_section_free(&dbg->de_debug_names);
     malloc_section_free(&dbg->de_debug_pubnames);
     malloc_section_free(&dbg->de_debug_str);
     malloc_section_free(&dbg->de_debug_sup);
     malloc_section_free(&dbg->de_debug_frame);
     malloc_section_free(&dbg->de_debug_frame_eh_gnu);
     malloc_section_free(&dbg->de_debug_pubtypes);
     malloc_section_free(&dbg->de_debug_funcnames);
     malloc_section_free(&dbg->de_debug_typenames);
     malloc_section_free(&dbg->de_debug_varnames);
     malloc_section_free(&dbg->de_debug_weaknames);
     malloc_section_free(&dbg->de_debug_ranges);
     malloc_section_free(&dbg->de_debug_str_offsets);
     malloc_section_free(&dbg->de_debug_addr);
     malloc_section_free(&dbg->de_debug_gdbindex);
     malloc_section_free(&dbg->de_debug_cu_index);
     malloc_section_free(&dbg->de_debug_tu_index);
     malloc_section_free(&dbg->de_debug_loclists);
     malloc_section_free(&dbg->de_debug_rnglists);
     malloc_section_free(&dbg->de_gnu_debuglink);
     malloc_section_free(&dbg->de_note_gnu_buildid);
     _dwarf_harmless_cleanout(&dbg->de_harmless_errors);
 
     _dwarf_dealloc_rnglists_context(dbg);
     _dwarf_dealloc_loclists_context(dbg);
     if (dbg->de_printf_callback.dp_buffer &&
         !dbg->de_printf_callback.dp_buffer_user_provided ) {
         free(dbg->de_printf_callback.dp_buffer);
     }
 
     _dwarf_destroy_group_map(dbg);
     /*  de_alloc_tree might be NULL if
         global_de_alloc_tree_on is zero. */
     if (dbg->de_alloc_tree) {
+        dbg->de_in_tdestroy = TRUE;
         dwarf_tdestroy(dbg->de_alloc_tree,tdestroy_free_node);
+        dbg->de_in_tdestroy = FALSE;
         dbg->de_alloc_tree = 0;
     }
     _dwarf_free_static_errlist();
     /*  first, walk the search and free()
         contents. */
     /*  Now  do the search tree itself */
     if (dbg->de_tied_data.td_tied_search) {
         dwarf_tdestroy(dbg->de_tied_data.td_tied_search,
             _dwarf_tied_destroy_free_node);
         dbg->de_tied_data.td_tied_search = 0;
     }
     free((void *)dbg->de_path);
     dbg->de_path = 0;
     for (g = 0; g < dbg->de_gnu_global_path_count; ++g) {
         free((char *)dbg->de_gnu_global_paths[g]);
         dbg->de_gnu_global_paths[g] = 0;
     }
     free((void*)dbg->de_gnu_global_paths);
     dbg->de_gnu_global_paths = 0;
     dbg->de_gnu_global_path_count = 0;
     memset(dbg, 0, sizeof(*dbg)); /* Prevent accidental use later. */
     free(dbg);
     return DW_DLV_OK;
 }
 /*  A special case: we have no dbg, no alloc header etc.
     So create something out of thin air that we can recognize
     in dwarf_dealloc.
     Something with the prefix (prefix space hidden from caller).
 
     Only applies to DW_DLA_ERROR, and  making up an error record.
 
     dwarf_error.c calls this and it adds to the staticerrlist
     all of which is freed by free_static_errlist();
 */
diff --git a/src/lib/libdwarf/dwarf_frame.c b/src/lib/libdwarf/dwarf_frame.c
index 0cf00cd6..5d5311cc 100644
--- a/src/lib/libdwarf/dwarf_frame.c
+++ b/src/lib/libdwarf/dwarf_frame.c
@@ -2054,182 +2054,184 @@ int
 dwarf_get_fde_for_die(Dwarf_Debug dbg,
     Dwarf_Die die,
     Dwarf_Fde * ret_fde, Dwarf_Error * error)
 {
     Dwarf_Attribute attr;
     Dwarf_Unsigned fde_offset = 0;
     Dwarf_Signed signdval = 0;
     Dwarf_Fde new_fde = 0;
     unsigned char *fde_ptr = 0;
     unsigned char *fde_start_ptr = 0;
     unsigned char *fde_end_ptr = 0;
     unsigned char *cie_ptr = 0;
     Dwarf_Unsigned cie_id = 0;
     Dwarf_Half     address_size = 0;
 
     /* Fields for the current Cie being read. */
     int res = 0;
     int resattr = 0;
     int sdatares = 0;
 
     struct cie_fde_prefix_s prefix;
     struct cie_fde_prefix_s prefix_c;
 
     if (!dbg || dbg->de_magic != DBG_IS_VALID) {
         _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,
             "DW_DLE_DBG_NULL: in dwarf_get_fde_for_die(): "
             "Either null or it contains"
             "a stale Dwarf_Debug pointer");
         return DW_DLV_ERROR;
     }
     if (!die ) {
         _dwarf_error_string(NULL, error, DW_DLE_DIE_NULL,
             "DW_DLE_DIE_NUL: in dwarf_get_fde_for_die(): "
             "Called with Dwarf_Die argument null");
         return DW_DLV_ERROR;
     }
     resattr = dwarf_attr(die, DW_AT_MIPS_fde, &attr, error);
     if (resattr != DW_DLV_OK) {
         return resattr;
     }
     /* why is this formsdata? FIX */
     sdatares = dwarf_formsdata(attr, &signdval, error);
     if (sdatares != DW_DLV_OK) {
         dwarf_dealloc_attribute(attr);
         return sdatares;
     }
     res = dwarf_get_die_address_size(die,&address_size,error);
     if (res != DW_DLV_OK) {
         dwarf_dealloc_attribute(attr);
         return res;
     }
     dwarf_dealloc_attribute(attr);
     res = _dwarf_load_section(dbg, &dbg->de_debug_frame,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     fde_offset = signdval;
     fde_start_ptr = dbg->de_debug_frame.dss_data;
     fde_ptr = fde_start_ptr + fde_offset;
     fde_end_ptr = fde_start_ptr + dbg->de_debug_frame.dss_size;
     res = _dwarf_validate_register_numbers(dbg,error);
     if (res == DW_DLV_ERROR) {
         return res;
     }
 
     /*  First read in the 'common prefix' to figure out
         what we are to do with this entry. */
     memset(&prefix_c, 0, sizeof(prefix_c));
     memset(&prefix, 0, sizeof(prefix));
     res = _dwarf_read_cie_fde_prefix(dbg, fde_ptr,
         dbg->de_debug_frame.dss_data,
         dbg->de_debug_frame.dss_index,
         dbg->de_debug_frame.dss_size,
         &prefix,
         error);
     if (res == DW_DLV_ERROR) {
         return res;
     }
     if (res == DW_DLV_NO_ENTRY) {
         return res;
     }
     fde_ptr = prefix.cf_addr_after_prefix;
     cie_id = prefix.cf_cie_id;
     if (cie_id  >=  dbg->de_debug_frame.dss_size ) {
         _dwarf_error_string(dbg, error, DW_DLE_NO_CIE_FOR_FDE,
             "DW_DLE_NO_CIE_FOR_FDE: "
             "dwarf_get_fde_for_die fails as the CIE id "
             "offset is impossibly large");
         return DW_DLV_ERROR;
     }
     /*  Pass NULL, not section pointer, for 3rd argument.
         de_debug_frame.dss_data has no eh_frame relevance. */
     res = _dwarf_create_fde_from_after_start(dbg, &prefix,
         fde_start_ptr,
         dbg->de_debug_frame.dss_size,
         fde_ptr,
         fde_end_ptr,
         /* use_gnu_cie_calc= */ 0,
         /* Dwarf_Cie = */ 0,
         address_size,
         &new_fde, error);
     if (res == DW_DLV_ERROR) {
         return res;
     }
     if (res == DW_DLV_NO_ENTRY) {
         return res;
     }
     /* DW_DLV_OK */
 
-    /*  This is the only situation this is set. */
+    /*  This is the only situation this is set. 
+        and is really dangerous. as fde and cie
+        are set for dealloc by dwarf_finish(). */
     new_fde->fd_fde_owns_cie = TRUE;
     /*  Now read the cie corresponding to the fde,
         _dwarf_read_cie_fde_prefix checks
         cie_ptr for being within the section. */
     if (cie_id  >=  dbg->de_debug_frame.dss_size ) {
         _dwarf_error_string(dbg, error, DW_DLE_NO_CIE_FOR_FDE,
             "DW_DLE_NO_CIE_FOR_FDE: "
             "dwarf_get_fde_for_die fails as the CIE id "
             "offset is impossibly large");
         return DW_DLV_ERROR;
     }
     cie_ptr = new_fde->fd_section_ptr + cie_id;
     if ((Dwarf_Unsigned)cie_ptr  <
         (Dwarf_Unsigned) new_fde->fd_section_ptr ||
         (Dwarf_Unsigned)cie_ptr <  cie_id) {
         dwarf_dealloc(dbg,new_fde,DW_DLA_FDE);
         new_fde = 0;
         _dwarf_error_string(dbg, error, DW_DLE_NO_CIE_FOR_FDE,
             "DW_DLE_NO_CIE_FOR_FDE: "
             "dwarf_get_fde_for_die fails as the CIE id "
             "offset is impossibly large");
         return DW_DLV_ERROR;
     }
     res = _dwarf_read_cie_fde_prefix(dbg, cie_ptr,
         dbg->de_debug_frame.dss_data,
         dbg->de_debug_frame.dss_index,
         dbg->de_debug_frame.dss_size,
         &prefix_c, error);
     if (res == DW_DLV_ERROR) {
         dwarf_dealloc(dbg,new_fde,DW_DLA_FDE);
         new_fde = 0;
         return res;
     }
     if (res == DW_DLV_NO_ENTRY) {
         dwarf_dealloc(dbg,new_fde,DW_DLA_FDE);
         new_fde = 0;
         return res;
     }
 
     cie_ptr = prefix_c.cf_addr_after_prefix;
     cie_id = prefix_c.cf_cie_id;
 
     if (cie_id == (Dwarf_Unsigned)DW_CIE_ID) {
         int res2 = 0;
         Dwarf_Cie new_cie = 0;
 
         /*  Pass NULL, not section pointer, for 3rd argument.
             de_debug_frame.dss_data has no eh_frame relevance. */
         res2 = _dwarf_create_cie_from_after_start(dbg,
             &prefix_c,
             fde_start_ptr,
             cie_ptr,
             fde_end_ptr,
             /* cie_count= */ 0,
             /* use_gnu_cie_calc= */
             0, &new_cie, error);
         if (res2 != DW_DLV_OK) {
             dwarf_dealloc(dbg, new_fde, DW_DLA_FDE);
             return res;
         }
         new_fde->fd_cie = new_cie;
     } else {
         dwarf_dealloc(dbg,new_fde,DW_DLA_FDE);
         new_fde = 0;
         _dwarf_error_string(dbg, error, DW_DLE_NO_CIE_FOR_FDE,
             "DW_DLE_NO_CIE_FOR_FDE: "
             "The CIE id is not a true cid id. Corrupt DWARF.");
         return DW_DLV_ERROR;
     }
     *ret_fde = new_fde;
     return DW_DLV_OK;
 }
@@ -3415,18 +3417,25 @@ _dwarf_frame_destructor(void *frame)
 {
     struct Dwarf_Frame_s *fp = frame;
     _dwarf_free_fde_table(fp);
 }
+
 void
 _dwarf_fde_destructor(void *f)
 {
     struct Dwarf_Fde_s *fde = f;
+
     if (fde->fd_fde_owns_cie) {
-        /*  This is just for dwarf_get_fde_for_die() */
-        dwarf_dealloc(fde->fd_dbg,fde->fd_cie,DW_DLA_CIE);
-        fde->fd_cie = 0;
+        Dwarf_Debug dbg = fde->fd_dbg;
+
+        if (!dbg->de_in_tdestroy) {
+            /*  This is just for dwarf_get_fde_for_die() and
+                must not be applied in alloc tree destruction. */
+            dwarf_dealloc(fde->fd_dbg,fde->fd_cie,DW_DLA_CIE);
+            fde->fd_cie = 0;
+        }
     }
     if (fde->fd_have_fde_tab) {
         _dwarf_free_fde_table(&fde->fd_fde_table);
         fde->fd_have_fde_tab = false;
     }
 }
diff --git a/src/lib/libdwarf/dwarf_frame2.c b/src/lib/libdwarf/dwarf_frame2.c
index 97cc9556..83342ec0 100644
--- a/src/lib/libdwarf/dwarf_frame2.c
+++ b/src/lib/libdwarf/dwarf_frame2.c
@@ -674,405 +674,407 @@ int
 _dwarf_create_cie_from_after_start(Dwarf_Debug dbg,
     struct cie_fde_prefix_s *prefix,
     Dwarf_Small * section_pointer,
     Dwarf_Small * frame_ptr,
     Dwarf_Small * section_ptr_end,
     Dwarf_Unsigned cie_count,
     int use_gnu_cie_calc,
     Dwarf_Cie * cie_ptr_out,
     Dwarf_Error * error)
 {
     Dwarf_Cie new_cie = 0;
 
     /*  egcs-1.1.2 .eh_frame uses 0 as the distinguishing
         id. sgi uses
         -1 (in .debug_frame). .eh_frame not quite identical to
         .debug_frame */
     /*  We here default the address size as it is not present
         in DWARF2 or DWARF3 cie data, below we set it right if
         it is present. */
     Dwarf_Half address_size = dbg->de_pointer_size;
     Dwarf_Small *augmentation = 0;
     Dwarf_Half segment_size = 0;
     Dwarf_Signed data_alignment_factor = -1;
     Dwarf_Unsigned code_alignment_factor = 4;
     Dwarf_Unsigned return_address_register = 31;
     int local_length_size = 0;
     Dwarf_Unsigned leb128_length = 0;
     Dwarf_Unsigned cie_aug_data_len = 0;
     Dwarf_Small *cie_aug_data = 0;
     Dwarf_Addr gnu_personality_handler_addr = 0;
     unsigned char gnu_personality_handler_encoding = 0;
     unsigned char gnu_lsda_encoding = 0;
     unsigned char gnu_fde_begin_encoding = 0;
     int res = 0;
     Dwarf_Small version = 0;
 
     enum Dwarf_augmentation_type augt = aug_unknown;
 
     /*  This is a CIE, Common Information Entry: See the dwarf spec,
         section 6.4.1 */
     if (frame_ptr >= section_ptr_end) {
         _dwarf_error_string(dbg, error,
             DW_DLE_DEBUG_FRAME_LENGTH_BAD,
             "DW_DLE_DEBUG_FRAME_LENGTH_BAD: reading a cie"
             " version byte we have run off"
             " the end of the section.  Corrupt Dwarf");
         return DW_DLV_ERROR;
     }
     version = *(Dwarf_Small *) frame_ptr;
 
     if ((frame_ptr+2) >= section_ptr_end) {
         _dwarf_error_string(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD,
             "DW_DLE_DEBUG_FRAME_LENGTH_BAD: reading an augmentation"
             " would run off"
             " the end of the section.  Corrupt Dwarf");
         return DW_DLV_ERROR;
     }
     if (version != DW_CIE_VERSION && version != DW_CIE_VERSION3 &&
         version != DW_CIE_VERSION4 && version != DW_CIE_VERSION5) {
         dwarfstring m;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_FRAME_VERSION_BAD: cie version %u unknown",
             version);
         _dwarf_error_string(dbg, error,
             DW_DLE_FRAME_VERSION_BAD,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     frame_ptr++;
     augmentation = frame_ptr;
     res = _dwarf_check_string_valid(dbg,section_pointer,
         frame_ptr,section_ptr_end,
         DW_DLE_AUGMENTATION_STRING_OFF_END,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     frame_ptr = frame_ptr + strlen((char *) frame_ptr) + 1;
     if (frame_ptr  >= section_ptr_end) {
         _dwarf_error_string(dbg, error,
             DW_DLE_DEBUG_FRAME_LENGTH_BAD,
             "DW_DLE_DEBUG_FRAME_LENGTH_BAD: following any "
             "augmentation field we have run off "
             "the end of the section "
             "with the CIE incomplete.  Corrupt Dwarf");
         return DW_DLV_ERROR;
     }
     augt = _dwarf_get_augmentation_type(dbg,
         augmentation, use_gnu_cie_calc);
     if (augt == aug_eh) {
         if ((frame_ptr+local_length_size)  >= section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: following "
                 "type field we have run off the end of the section "
                 "with the CIE incomplete.  Corrupt Dwarf");
             return DW_DLV_ERROR;
         }
 #if 0
         /* REFERENCED *//* Not used in this instance */
         Dwarf_Unsigned exception_table_addr = 0;
         /* this is per egcs-1.1.2 as on RH 6.0 */
         READ_UNALIGNED_CK(dbg, exception_table_addr,
             Dwarf_Unsigned, frame_ptr, local_length_size,
             error,section_ptr_end);
 #endif
         frame_ptr += local_length_size;
     }
     {
         Dwarf_Unsigned lreg = 0;
         unsigned long size = 0;
 
         if (version == DW_CIE_VERSION4) {
             if ((frame_ptr+2)  >= section_ptr_end) {
                 _dwarf_error_string(dbg, error,
                     DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                     "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
                     "We would run off the end of the section "
                     "in a DWARF4 cie header.  Corrupt Dwarf");
                 return DW_DLV_ERROR;
             }
             address_size = *((unsigned char *)frame_ptr);
             if (address_size  <  1) {
                 _dwarf_error_string(dbg, error,
                     DW_DLE_ADDRESS_SIZE_ZERO,
                     "DW_DLE_ADDRESS_SIZE_ZERO: bad address size "
                     "for a DWARF4 cie header");
                 return DW_DLV_ERROR;
             }
             if (address_size  > sizeof(Dwarf_Addr)) {
                 _dwarf_create_address_size_dwarf_error(dbg,
                     error,address_size,
                     DW_DLE_ADDRESS_SIZE_ERROR,
                     "DW_DLE_ADDRESS_SIZE_ERROR..:");
                 return DW_DLV_ERROR;
             }
             if ((frame_ptr+2)  >= section_ptr_end) {
                 _dwarf_error_string(dbg, error,
                     DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                     "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
                     "Running off the end "
                     " of a CIE header. Corrupt DWARF4");
                 return DW_DLV_ERROR;
             }
             ++frame_ptr;
             segment_size = *((unsigned char *)frame_ptr);
             ++frame_ptr;
             if (segment_size  > sizeof(Dwarf_Addr)) {
                 _dwarf_error(dbg, error, DW_DLE_SEGMENT_SIZE_BAD);
                 return DW_DLV_ERROR;
             }
         }
 
         /* Not a great test. But the DECODE* do checking so ok.  */
         if ((frame_ptr+2)  >= section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: Running off the end "
                 " of a CIE header before the code alignment value "
                 "read. Corrupt DWARF");
             return DW_DLV_ERROR;
         }
         DECODE_LEB128_UWORD_CK(frame_ptr, lreg,dbg,error,
             section_ptr_end);
         code_alignment_factor = (Dwarf_Unsigned) lreg;
         res = dwarf_decode_signed_leb128(
             (char *)frame_ptr,
             &leb128_length,&data_alignment_factor,
             (char *)section_ptr_end);
         if (res != DW_DLV_OK) {
             return res;
         }
         frame_ptr = frame_ptr + leb128_length;
         if ((frame_ptr+1)  >= section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: Running off the end "
                 "of a CIE header before the return address register "
                 "number read. Corrupt DWARF");
 
             return DW_DLV_ERROR;
         }
         res = _dwarf_get_return_address_reg(frame_ptr, version,
             dbg,section_ptr_end, &size,
             &return_address_register,error);
         if (res != DW_DLV_OK) {
             return res;
         }
         if (return_address_register >
             dbg->de_frame_reg_rules_entry_count) {
             _dwarf_error(dbg, error, DW_DLE_CIE_RET_ADDR_REG_ERROR);
             return DW_DLV_ERROR;
         }
         frame_ptr += size;
         if ((frame_ptr)  > section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: Past the end "
                 "of a CIE header before reading "
                 "the augmentation string."
                 " Corrupt DWARF");
             return DW_DLV_ERROR;
         }
     }
     switch (augt) {
     case aug_empty_string:
         break;
     case aug_irix_mti_v1:
         break;
     case aug_irix_exception_table:{
         Dwarf_Unsigned lreg = 0;
         Dwarf_Unsigned length_of_augmented_fields;
 
         /* Decode the length of augmented fields. */
         DECODE_LEB128_UWORD_CK(frame_ptr, lreg,
             dbg,error,section_ptr_end);
         length_of_augmented_fields = (Dwarf_Unsigned) lreg;
         if (length_of_augmented_fields >= dbg->de_filesize) {
             _dwarf_error_string(dbg,error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
                 "The irix exception table length is too large "
                 "to be real");
             return DW_DLV_ERROR;
         }
         /* set the frame_ptr to point at the instruction start. */
         frame_ptr += length_of_augmented_fields;
         }
         break;
 
     case aug_eh:{
         int err = 0;
         unsigned long increment = 0;
 
         if (!use_gnu_cie_calc) {
             /* This should be impossible. */
             _dwarf_error(dbg, error,
                 DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
             return DW_DLV_ERROR;
         }
 
         err = _dwarf_get_gcc_eh_augmentation(dbg, frame_ptr,
             &increment,
             augt,
             section_ptr_end,
             (char *) augmentation,error);
         if (err == DW_DLV_ERROR) {
             _dwarf_error(dbg, error,
                 DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
             return DW_DLV_ERROR;
         }
         frame_ptr += increment;
         }
         break;
     case aug_gcc_eh_z:{
         /*  Here we have Augmentation Data Length (uleb128) followed
             by Augmentation Data bytes (not a string). */
         int resz = DW_DLV_ERROR;
         Dwarf_Unsigned adlen = 0;
 
         if ((frame_ptr+1)  > section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_AUG_DATA_LENGTH_BAD: The "
                 "gcc .eh_frame augmentation data "
                 "cannot be read. Out of room in the section."
                 " Corrupt DWARF.");
             return DW_DLV_ERROR;
         }
         DECODE_LEB128_UWORD_CK(frame_ptr, adlen,
             dbg,error,section_ptr_end);
         cie_aug_data_len = adlen;
         cie_aug_data = frame_ptr;
         if (adlen) {
             Dwarf_Small *cie_aug_data_end = cie_aug_data+adlen;
             if (cie_aug_data_end < cie_aug_data ||
                 cie_aug_data_end > section_ptr_end) {
                 dwarfstring m;
 
                 dwarfstring_constructor(&m);
                 dwarfstring_append_printf_u(&m,
                     "DW_DLE_AUG_DATA_LENGTH_BAD: The "
                     "gcc .eh_frame augmentation data "
                     "length of %" DW_PR_DUu " is too long to"
                     " fit in the section.",adlen);
                 _dwarf_error_string(dbg, error,
                     DW_DLE_AUG_DATA_LENGTH_BAD,
                     dwarfstring_string(&m));
                 dwarfstring_destructor(&m);
                 return DW_DLV_ERROR;
             }
         }
         resz = _dwarf_gnu_aug_encodings(dbg,
             (char *) augmentation,
             cie_aug_data,
             cie_aug_data_len,
             address_size,
             &gnu_personality_handler_encoding,
             &gnu_lsda_encoding,
             &gnu_fde_begin_encoding,
             &gnu_personality_handler_addr,
             error);
         if (resz != DW_DLV_OK) {
-            _dwarf_error_string(dbg, error,
-                DW_DLE_FRAME_AUGMENTATION_UNKNOWN,
-                "DW_DLE_FRAME_AUGMENTATION_UNKNOWN "
-                " Reading gnu aug encodings failed");
+            if (resz == DW_DLV_ERROR) {
+                _dwarf_error_string(dbg, error,
+                    DW_DLE_FRAME_AUGMENTATION_UNKNOWN,
+                    "DW_DLE_FRAME_AUGMENTATION_UNKNOWN "
+                    " Reading gnu aug encodings failed");
+            } /* DW_DLV_NO_ENTRY seems impossible. */
             return resz;
         }
         frame_ptr += adlen;
         }
         break;
     case aug_armcc:
         break;
     default:{
         /*  We do not understand the augmentation string. No
             assumption can be made about any fields other than what
             we have already read. */
         frame_ptr = prefix->cf_start_addr +
             prefix->cf_length + prefix->cf_local_length_size
             + prefix->cf_local_extension_size;
         /*  FIX -- What are the values of data_alignment_factor,
             code_alignment_factor, return_address_register and
             instruction start? They were clearly uninitialized in the
             previous version and I am leaving them the same way. */
         }
         if ((frame_ptr)  > section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
                 "Reading an unknown type of augmentation string "
                 "run off the end of the section. Corrupt DWARF.");
             return DW_DLV_ERROR;
         }
         break;
     }   /* End switch on augmentation type. */
 
     new_cie = (Dwarf_Cie) _dwarf_get_alloc(dbg, DW_DLA_CIE, 1);
     if (new_cie == NULL) {
         _dwarf_error_string(dbg, error,
             DW_DLE_ALLOC_FAIL,
             "DW_DLE_ALLOC_FAIL "
             "attempting to allocate a Dwarf_Cie");
         return DW_DLV_ERROR;
     }
 
     new_cie->ci_cie_version_number = version;
     new_cie->ci_initial_table = NULL;
     new_cie->ci_length = (Dwarf_Unsigned) prefix->cf_length;
     new_cie->ci_length_size =
         (Dwarf_Small)prefix->cf_local_length_size;
     new_cie->ci_extension_size =
         (Dwarf_Small)prefix->cf_local_extension_size;
     new_cie->ci_augmentation = (char *) augmentation;
 
     new_cie->ci_data_alignment_factor =
         (Dwarf_Sbyte) data_alignment_factor;
     new_cie->ci_code_alignment_factor =
         (Dwarf_Small) code_alignment_factor;
     new_cie->ci_return_address_register = return_address_register;
     new_cie->ci_cie_start = prefix->cf_start_addr;
 
     if ( frame_ptr > section_ptr_end) {
         _dwarf_error(dbg, error, DW_DLE_DF_FRAME_DECODING_ERROR);
         return DW_DLV_ERROR;
     }
     new_cie->ci_cie_instr_start = frame_ptr;
     new_cie->ci_dbg = dbg;
     new_cie->ci_augmentation_type = augt;
     new_cie->ci_gnu_eh_augmentation_len = cie_aug_data_len;
     new_cie->ci_gnu_eh_augmentation_bytes = cie_aug_data;
     new_cie->ci_gnu_personality_handler_encoding =
         gnu_personality_handler_encoding;
     new_cie->ci_gnu_personality_handler_addr =
         gnu_personality_handler_addr;
     new_cie->ci_gnu_lsda_encoding = gnu_lsda_encoding;
     new_cie->ci_gnu_fde_begin_encoding = gnu_fde_begin_encoding;
 
     new_cie->ci_index = cie_count;
     new_cie->ci_section_ptr = prefix->cf_section_ptr;
     new_cie->ci_section_end = section_ptr_end;
     new_cie->ci_cie_end = new_cie->ci_cie_start + new_cie->ci_length +
         new_cie->ci_length_size+ new_cie->ci_extension_size;
     if ( new_cie->ci_cie_end > section_ptr_end) {
         dwarf_dealloc(dbg,new_cie,DW_DLA_CIE);
         _dwarf_error(dbg, error, DW_DLE_DF_FRAME_DECODING_ERROR);
         return DW_DLV_ERROR;
     }
 
     /* The Following new in DWARF4 */
     new_cie->ci_address_size = address_size;
     new_cie->ci_segment_size = segment_size;
     validate_length(dbg,new_cie,new_cie->ci_length,
         new_cie->ci_length_size, new_cie->ci_extension_size,
         new_cie->ci_section_ptr,
         new_cie->ci_cie_start,"cie");
     *cie_ptr_out = new_cie;
     return DW_DLV_OK;
 }
 
 /*  Internal function, not called by consumer code.
     'prefix' has accumulated the info up thru the cie-id
     and now we consume the rest and build a Dwarf_Fde_s structure.
     Can be called with cie_ptr_in NULL from dwarf_frame.c  */
@@ -1081,310 +1083,319 @@ int
 _dwarf_create_fde_from_after_start(Dwarf_Debug dbg,
     struct cie_fde_prefix_s *prefix,
     Dwarf_Small *section_pointer,
     Dwarf_Unsigned section_length,
     Dwarf_Small *frame_ptr,
     Dwarf_Small *section_ptr_end,
     int          use_gnu_cie_calc,
     Dwarf_Cie    cie_ptr_in,
     Dwarf_Small  address_size,
     Dwarf_Fde   *fde_ptr_out,
     Dwarf_Error *error)
 {
     Dwarf_Fde new_fde = 0;
     Dwarf_Cie cieptr = 0;
     Dwarf_Small *saved_frame_ptr = 0;
 
     Dwarf_Small *initloc = frame_ptr;
     Dwarf_Signed offset_into_exception_tables
         = (Dwarf_Signed) DW_DLX_NO_EH_OFFSET;
     Dwarf_Small *fde_aug_data = 0;
     Dwarf_Unsigned fde_aug_data_len = 0;
     Dwarf_Addr cie_base_offset = prefix->cf_cie_id;
     Dwarf_Addr initial_location = 0;    /* must be min de_pointer_size
         bytes in size */
     Dwarf_Addr address_range = 0;       /* must be min de_pointer_size
         bytes in size */
     Dwarf_Unsigned eh_table_value = 0;
     Dwarf_Bool eh_table_value_set = FALSE;
     /* Temporary assumption.  */
     enum Dwarf_augmentation_type augt = aug_empty_string;
 
     if (cie_ptr_in) {
         cieptr = cie_ptr_in;
         augt = cieptr->ci_augmentation_type;
     }
     if (augt == aug_gcc_eh_z) {
         /*  If z augmentation this is eh_frame,
             and initial_location and
             address_range in the FDE are read according to the CIE
             augmentation string instructions.  */
 
-        {
+        if (cieptr) {
             Dwarf_Small *fp_updated = 0;
             int res = _dwarf_read_encoded_ptr(dbg,
                 section_pointer,
                 frame_ptr,
                 cieptr-> ci_gnu_fde_begin_encoding,
                 section_ptr_end,
                 address_size,
                 &initial_location,
                 &fp_updated,error);
             if (res != DW_DLV_OK) {
                 return res;
             }
             frame_ptr = fp_updated;
             /*  For the address-range it makes no sense to be
                 pc-relative, so we turn it off
                 with a section_pointer of
                 NULL. Masking off DW_EH_PE_pcrel from the
                 ci_gnu_fde_begin_encoding in this
                 call would also work
                 to turn off DW_EH_PE_pcrel. */
             res = _dwarf_read_encoded_ptr(dbg, (Dwarf_Small *) NULL,
                 frame_ptr,
                 cieptr->ci_gnu_fde_begin_encoding,
                 section_ptr_end,
                 address_size,
                 &address_range, &fp_updated,error);
             if (res != DW_DLV_OK) {
                 return res;
             }
             frame_ptr = fp_updated;
+        } else {
+            _dwarf_error_string(dbg, error,
+                    DW_DLE_AUG_DATA_LENGTH_BAD,
+                    "DW_DLE_AUG_DATA_LENGTH_BAD: The "
+                    "gcc augmentation cannot be read, "
+                    "as no cie pointer is available "
+                    "to get critical data, "
+                    "Corrupt DWARF");
+            return DW_DLV_ERROR;
         }
         {
             Dwarf_Unsigned adlen = 0;
 
             DECODE_LEB128_UWORD_CK(frame_ptr, adlen,
                 dbg,error,section_ptr_end);
             fde_aug_data_len = adlen;
             fde_aug_data = frame_ptr;
             if (frame_ptr < section_ptr_end) {
                 Dwarf_Unsigned remaininglen = 0;
                 remaininglen = (Dwarf_Unsigned)
                     (section_ptr_end - frame_ptr);
                 if (remaininglen <= adlen) {
                     _dwarf_error_string(dbg, error,
                         DW_DLE_AUG_DATA_LENGTH_BAD,
                         "DW_DLE_AUG_DATA_LENGTH_BAD: The "
                         "augmentation length is too large for "
                         "the frame section, corrupt DWARF");
                     return DW_DLV_ERROR;
                 }
             } else {
                 _dwarf_error_string(dbg, error,
                     DW_DLE_AUG_DATA_LENGTH_BAD,
                     "DW_DLE_AUG_DATA_LENGTH_BAD: The "
                     "frame pointer has stepped off the end "
                     "of the frame section on reading augmentation "
                     "length. Corrupt DWARF");
                 return DW_DLV_ERROR;
             }
             if ( adlen >= section_length) {
                 dwarfstring m;
 
                 dwarfstring_constructor(&m);
                 dwarfstring_append_printf_u(&m,
                     "DW_DLE_AUG_DATA_LENGTH_BAD: The "
                     "gcc .eh_frame augmentation data "
                     "length of %" DW_PR_DUu " is too long to"
                     " fit in the section.",adlen);
                 _dwarf_error_string(dbg, error,
                     DW_DLE_AUG_DATA_LENGTH_BAD,
                     dwarfstring_string(&m));
                 dwarfstring_destructor(&m);
                 return DW_DLV_ERROR;
             }
             frame_ptr += adlen;
             if (adlen) {
                 if (frame_ptr < fde_aug_data ||
                     frame_ptr >= section_ptr_end ) {
                     dwarfstring m;
 
                     dwarfstring_constructor(&m);
                     dwarfstring_append_printf_u(&m,
                         "DW_DLE_AUG_DATA_LENGTH_BAD: The "
                         "gcc .eh_frame augmentation data "
                         "length of %" DW_PR_DUu " is too long to"
                         " fit in the section.",adlen);
                     _dwarf_error_string(dbg, error,
                         DW_DLE_AUG_DATA_LENGTH_BAD,
                         dwarfstring_string(&m));
                     dwarfstring_destructor(&m);
                     return DW_DLV_ERROR;
                 }
             }
         }
     } else {
         if ((frame_ptr + 2*address_size) > section_ptr_end) {
             _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
             return DW_DLV_ERROR;
         }
         READ_UNALIGNED_CK(dbg, initial_location, Dwarf_Addr,
             frame_ptr, address_size,
             error,section_ptr_end);
         frame_ptr += address_size;
         READ_UNALIGNED_CK(dbg, address_range, Dwarf_Addr,
             frame_ptr, address_size,
             error,section_ptr_end);
         frame_ptr += address_size;
     }
     switch (augt) {
     case aug_irix_mti_v1:
     case aug_empty_string:
         break;
     case aug_irix_exception_table:{
         Dwarf_Unsigned lreg = 0;
         Dwarf_Unsigned length_of_augmented_fields = 0;
 
         DECODE_LEB128_UWORD_CK(frame_ptr, lreg,
             dbg,error,section_ptr_end);
         length_of_augmented_fields = (Dwarf_Unsigned) lreg;
 
         if (length_of_augmented_fields >= dbg->de_filesize) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD "
                 "in irix exception table length of augmented "
                 "fields is too large to be real");
             return DW_DLV_ERROR;
         }
         saved_frame_ptr = frame_ptr;
         /*  The first word is an offset into exception tables.
             Defined as a 32bit offset even for CC -64. */
         if ((frame_ptr + DWARF_32BIT_SIZE) > section_ptr_end) {
             _dwarf_error_string(dbg,error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD "
                 "irix:frame does not fit in the DWARF section");
             return DW_DLV_ERROR;
         }
         READ_UNALIGNED_CK(dbg, offset_into_exception_tables,
             Dwarf_Addr, frame_ptr, DWARF_32BIT_SIZE,
             error,section_ptr_end);
         SIGN_EXTEND(offset_into_exception_tables,
             DWARF_32BIT_SIZE);
         if (offset_into_exception_tables > 0) {
             if ((Dwarf_Unsigned)offset_into_exception_tables >=
                 dbg->de_filesize) {
                 _dwarf_error_string(dbg,error,
                     DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                     "DW_DLE_DEBUG_FRAME_LENGTH_BAD "
                     "Irix offset into exception tables");
                 return DW_DLV_ERROR;
             }
         } /* nobody uses irix anyway now */
         frame_ptr = saved_frame_ptr + length_of_augmented_fields;
         }
         break;
     case aug_eh:{
 
         if (!use_gnu_cie_calc) {
             /* This should be impossible. */
             _dwarf_error(dbg, error,
                 DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
             return DW_DLV_ERROR;
         }
 
         /* gnu eh fde case. we do not need to do anything */
         /*REFERENCED*/ /* Not used in this instance of the macro */
         if ((frame_ptr + address_size) > section_ptr_end) {
             _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
             return DW_DLV_ERROR;
         }
         READ_UNALIGNED_CK(dbg, eh_table_value,
             Dwarf_Unsigned, frame_ptr,
             address_size,
             error,section_ptr_end);
         eh_table_value_set = TRUE;
         frame_ptr += address_size;
         }
         break;
 
     case aug_gcc_eh_z:{
         /*  The Augmentation Data Length is here, followed by the
             Augmentation Data bytes themselves. */
         }
         break;
     case aug_armcc:
         break;
     case aug_past_last:
         break;
 
     case aug_metaware: /* No special fields. See dwarf_util.h */
         break;
 
     case aug_unknown:
         _dwarf_error(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
         return DW_DLV_ERROR;
     default: break;
     }                           /* End switch on augmentation type */
     if ( frame_ptr > section_ptr_end) {
         _dwarf_error(dbg, error, DW_DLE_DF_FRAME_DECODING_ERROR);
         return DW_DLV_ERROR;
     }
     if ( frame_ptr < initloc) {
         _dwarf_error_string(dbg, error,
             DW_DLE_DF_FRAME_DECODING_ERROR,
             "DW_DLE_DF_FRAME_DECODING_ERROR "
             "frame pointer decreased.Impossible. "
             "arithmetic overflow");
         return DW_DLV_ERROR;
     }
 
     new_fde = (Dwarf_Fde) _dwarf_get_alloc(dbg, DW_DLA_FDE, 1);
     if (new_fde == NULL) {
         _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
         return DW_DLV_ERROR;
     }
 
     new_fde->fd_length = prefix->cf_length;
     new_fde->fd_length_size =
         (Dwarf_Small)prefix->cf_local_length_size;
     new_fde->fd_extension_size =
         (Dwarf_Small)prefix->cf_local_extension_size;
     new_fde->fd_is_eh = (Dwarf_Small)use_gnu_cie_calc;
     new_fde->fd_cie_offset = cie_base_offset;
     if (cieptr) {
         new_fde->fd_cie_index = cieptr->ci_index;
     }
     new_fde->fd_cie = cieptr;
     new_fde->fd_initial_location = initial_location;
     new_fde->fd_initial_loc_pos = initloc;
     new_fde->fd_address_range = address_range;
     new_fde->fd_fde_start = prefix->cf_start_addr;
 
     new_fde->fd_fde_instr_start = frame_ptr;
     new_fde->fd_fde_end = prefix->cf_start_addr +
         prefix->cf_length +  prefix->cf_local_length_size  +
         prefix->cf_local_extension_size;
     if ( new_fde->fd_fde_end > section_ptr_end) {
         _dwarf_error(dbg, error, DW_DLE_DF_FRAME_DECODING_ERROR);
         dwarf_dealloc(dbg,new_fde,DW_DLA_FDE);
         return DW_DLV_ERROR;
     }
 
     new_fde->fd_dbg = dbg;
     new_fde->fd_offset_into_exception_tables =
         offset_into_exception_tables;
     new_fde->fd_eh_table_value = eh_table_value;
     new_fde->fd_eh_table_value_set = eh_table_value_set;
 
     new_fde->fd_section_ptr = prefix->cf_section_ptr;
     new_fde->fd_section_index = prefix->cf_section_index;
     new_fde->fd_section_length = prefix->cf_section_length;
     new_fde->fd_section_end = section_ptr_end;
 
     if (augt == aug_gcc_eh_z) {
         new_fde->fd_gnu_eh_aug_present = TRUE;
     }
     new_fde->fd_gnu_eh_augmentation_bytes = fde_aug_data;
     new_fde->fd_gnu_eh_augmentation_len = fde_aug_data_len;
     validate_length(dbg,cieptr,new_fde->fd_length,
         new_fde->fd_length_size, new_fde->fd_extension_size,
         new_fde->fd_section_ptr,new_fde->fd_fde_start,"fde");
     *fde_ptr_out = new_fde;
     return DW_DLV_OK;
 }
 
 /*  Read in the common cie/fde prefix, including reading
     the cie-value which shows which this is: cie or fde.  */
diff --git a/src/lib/libdwarf/dwarf_opaque.h b/src/lib/libdwarf/dwarf_opaque.h
index 9e6dc062..721cb982 100644
--- a/src/lib/libdwarf/dwarf_opaque.h
+++ b/src/lib/libdwarf/dwarf_opaque.h
@@ -578,219 +578,220 @@ struct Dwarf_Group_Data_s {
 struct Dwarf_Debug_s {
     Dwarf_Unsigned de_magic;
     /*  All file access methods and support data
         are hidden in this structure.
         We get a pointer, callers control the lifetime of the
         structure and contents. */
     struct Dwarf_Obj_Access_Interface_a_s *de_obj_file;
 
     Dwarf_Handler de_errhand;
     Dwarf_Ptr de_errarg;
 
     /*  Enabling us to close an fd if we own it,
         as in the case of dwarf_init_path().
         de_fd is only meaningful
         if de_owns_fd is set.  Each object
         file type has any necessary fd recorded
         under de_obj_file. */
     int  de_fd;
     char de_owns_fd;
+    char de_in_tdestroy; /* for de_alloc_tree  DW202309-001 */
     /* DW_PATHSOURCE_BASIC or MACOS or DEBUGLINK */
     unsigned char de_path_source;
     /*  de_path is only set automatically if dwarf_init_path()
         was used to initialize things.
         Used with the .gnu_debuglink section. */
     const char *de_path;
 
     const char ** de_gnu_global_paths;
     unsigned      de_gnu_global_path_count;
 
     struct Dwarf_Debug_InfoTypes_s de_info_reading;
     struct Dwarf_Debug_InfoTypes_s de_types_reading;
 
     /*  DW_GROUPNUMBER_ANY, DW_GROUPNUMBER_BASE, DW_GROUPNUMBER_DWO,
         or a comdat group number > 2
         Selected at init time of this dbg based on
         user request and on data in the object. */
     unsigned de_groupnumber;
 
     /* Supporting data for groupnumbers. */
     struct Dwarf_Group_Data_s de_groupnumbers;
 
     /*  Number of bytes in the length, and offset field in various
         .debu* sections.  It's not very meaningful, and is
         only used in one 'approximate' calculation.
         de_offset_size would be a more apropos name. */
     Dwarf_Small de_length_size;
 
     /*  Size of the object file in bytes. If Unknown
         leave this zero. */
     Dwarf_Unsigned de_filesize;
 
     /*  number of bytes in a pointer of the target in various .debug_
         sections. 4 in 32bit, 8 in MIPS 64, ia64. */
     Dwarf_Small de_pointer_size;
 
     /*  set at creation of a Dwarf_Debug to say if form_string
         should be checked for valid length at every call.
         0 means do the check.
         non-zero means do not do the check. */
     Dwarf_Small de_assume_string_in_bounds;
 
     /*  Keep track of allocations so a dwarf_finish call can clean up.
         Null till a tree is created */
     void * de_alloc_tree;
 
     /*  These fields are used to process debug_frame section.
         Updated
         by dwarf_get_fde_list in dwarf_frame.h */
     /*  Points to contiguous block of pointers to
         Dwarf_Cie_s structs. */
     Dwarf_Cie *de_cie_data;
     /*  Count of number of Dwarf_Cie_s structs. */
     Dwarf_Signed de_cie_count;
     /*  Keep eh (GNU) separate!. */
     Dwarf_Cie *de_cie_data_eh;
     Dwarf_Signed de_cie_count_eh;
     /*  Points to contiguous block of pointers to
         Dwarf_Fde_s structs. */
     Dwarf_Fde *de_fde_data;
     /*  Count of number of Dwarf_Fde_s structs. */
     Dwarf_Unsigned de_fde_count;
     /*  Keep eh (GNU) separate!. */
     Dwarf_Fde *de_fde_data_eh;
     Dwarf_Unsigned de_fde_count_eh;
 
     struct Dwarf_Section_s de_debug_info;
     struct Dwarf_Section_s de_debug_types;
     struct Dwarf_Section_s de_debug_abbrev;
     struct Dwarf_Section_s de_debug_line;
     struct Dwarf_Section_s de_debug_line_str; /* New in DWARF5 */
     struct Dwarf_Section_s de_debug_loc;
     struct Dwarf_Section_s de_debug_aranges;
     struct Dwarf_Section_s de_debug_macinfo;
     struct Dwarf_Section_s de_debug_macro;    /* New in DWARF5 */
     struct Dwarf_Section_s de_debug_names;    /* New in DWARF5 */
     struct Dwarf_Section_s de_debug_pubnames;
     struct Dwarf_Section_s de_debug_str;
     struct Dwarf_Section_s de_debug_sup;      /* New in DWARF5 */
     struct Dwarf_Section_s de_debug_loclists; /* New in DWARF5 */
     struct Dwarf_Section_s de_debug_rnglists; /* New in DWARF5 */
     struct Dwarf_Section_s de_debug_frame;
     struct Dwarf_Section_s de_gnu_debuglink;  /* New Sept. 2019 */
     struct Dwarf_Section_s de_note_gnu_buildid; /* New Sept. 2019 */
 
     /* gnu: the g++ eh_frame section */
     struct Dwarf_Section_s de_debug_frame_eh_gnu;
 
     /* DWARF3 .debug_pubtypes */
     struct Dwarf_Section_s de_debug_pubtypes;
 
     /*  Four SGI IRIX extensions essentially
         identical to DWARF3 .debug_pubtypes.
         Only on SGI IRIX. */
     struct Dwarf_Section_s de_debug_funcnames;
     struct Dwarf_Section_s de_debug_typenames;
     struct Dwarf_Section_s de_debug_varnames;
     struct Dwarf_Section_s de_debug_weaknames;
 
     struct Dwarf_Section_s de_debug_ranges;
     /*  Following two part of DebugFission and DWARF5 */
     struct Dwarf_Section_s de_debug_str_offsets;
     struct Dwarf_Section_s de_debug_addr;
 
     /*  For the .debug_rnglists[.dwo] section */
     Dwarf_Unsigned de_rnglists_context_count;
     /*  pointer to array of pointers to
         rnglists context instances */
     Dwarf_Rnglists_Context *  de_rnglists_context;
 
     /*  For the .debug_loclists[.dwo] section */
     Dwarf_Unsigned de_loclists_context_count;
     /*  pointer to array of pointers to
         loclists context instances */
     Dwarf_Loclists_Context *  de_loclists_context;
 
     /* Following for the .gdb_index section.  */
     struct Dwarf_Section_s de_debug_gdbindex;
 
     /*  Types in DWARF5 are in .debug_info
         and in DWARF4 are in .debug_types.
         These indexes first standardized in DWARF5,
         DWARF4 can have them as an extension.
         The next to refer to the DWP index sections and the
         tu and cu indexes sections are distinct in DWARF4 & 5. */
     struct Dwarf_Section_s de_debug_cu_index;
     struct Dwarf_Section_s de_debug_tu_index;
     struct Dwarf_Section_s de_debug_gnu_pubnames;
     struct Dwarf_Section_s de_debug_gnu_pubtypes;
 
     /*  For non-elf, simply leave the following two structs
         zeroed and they will be ignored. */
     struct Dwarf_Section_s de_elf_symtab;
     struct Dwarf_Section_s de_elf_strtab;
 
     /*  For a .dwp object file .
         For DWARF4, type units are in .debug_types
             (DWP is a GNU extension in DW4)..
         For DWARF5, type units are in .debug_info.
     */
     Dwarf_Xu_Index_Header  de_cu_hashindex_data;
     Dwarf_Xu_Index_Header  de_tu_hashindex_data;
 
     void (*de_copy_word) (void *, const void *, unsigned long);
     unsigned char de_same_endian;
     unsigned char de_elf_must_close; /* If non-zero, then
         it was dwarf_init (not dwarf_elf_init)
         so must elf_end() */
 
     /* Default is DW_FRAME_INITIAL_VALUE from header. */
     Dwarf_Unsigned de_frame_rule_initial_value;
 
     /* Default is   DW_FRAME_LAST_REG_NUM. */
     Dwarf_Unsigned de_frame_reg_rules_entry_count;
 
     Dwarf_Unsigned de_frame_cfa_col_number;
     Dwarf_Unsigned de_frame_same_value_number;
     Dwarf_Unsigned de_frame_undefined_value_number;
 
     unsigned char de_big_endian_object; /* Non-zero if
         object being read is big-endian. */
 
     /*  Non-zero if dwarf_get_globals(), dwarf_get_funcs,
         dwarf_get_types,dwarf_get_pubtypes,
         dwarf_get_vars,dwarf_get_weaks should create
         and return a special zero-die-offset for the
         corresponding pubnames-style section CU header with
         zero pubnames-style named DIEs.  In that case the
         list returned will have an entry with a zero for
         the die-offset (which is an impossible debug_info
         die_offset). New March 2019.
         See dwarf_return_empty_pubnames() */
     unsigned char de_return_empty_pubnames;
 
     struct Dwarf_dbg_sect_s de_debug_sections[
         DWARF_MAX_DEBUG_SECTIONS];
 
     /* Number actually used. */
     unsigned de_debug_sections_total_entries;
 
     struct Dwarf_Harmless_s de_harmless_errors;
 
     struct Dwarf_Printf_Callback_Info_s  de_printf_callback;
     void *   de_printf_callback_null_device_handle;
 
     /*  Used in a tied dbg  to hold global info
         on the tied object (DW_AT_dwo_id).
         And for Type Unit signatures whether tied
         or not. It is not defined whether
         the main object is executable and
         the tied file is a dwo/dwp or the
         reverse. The focus of reporting
         is on the main file, but the tied
         file is sometimes needed
         and referenced.*/
     struct Dwarf_Tied_Data_s de_tied_data;
 };
 
 /* New style. takes advantage of dwarfstrings capability.
     This not a public function. */
