commit 98c7ca653ad749c281ef32fbf3258274ff81f13a
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Sat Feb 17 09:36:05 2018 -0500

    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=6430

diff --git a/MagickCore/draw.c b/MagickCore/draw.c
index 99495b701..3b1fa0ee6 100644
--- a/MagickCore/draw.c
+++ b/MagickCore/draw.c
@@ -1,98 +1,103 @@
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %                        DDDD   RRRR    AAA   W   W                           %
 %                        D   D  R   R  A   A  W   W                           %
 %                        D   D  RRRR   AAAAA  W W W                           %
 %                        D   D  R RN   A   A  WW WW                           %
 %                        DDDD   R  R   A   A  W   W                           %
 %                                                                             %
 %                                                                             %
 %                     MagickCore Image Drawing Methods                        %
 %                                                                             %
 %                                                                             %
 %                              Software Design                                %
 %                                   Cristy                                    %
 %                                 July 1998                                   %
 %                                                                             %
 %                                                                             %
 %  Copyright 1999-2018 ImageMagick Studio LLC, a non-profit organization      %
 %  dedicated to making software imaging solutions freely available.           %
 %                                                                             %
 %  You may not use this file except in compliance with the License.  You may  %
 %  obtain a copy of the License at                                            %
 %                                                                             %
 %    https://www.imagemagick.org/script/license.php                           %
 %                                                                             %
 %  Unless required by applicable law or agreed to in writing, software        %
 %  distributed under the License is distributed on an "AS IS" BASIS,          %
 %  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %
 %  See the License for the specific language governing permissions and        %
 %  limitations under the License.                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Bill Radcliffe of Corbis (www.corbis.com) contributed the polygon
 % rendering code based on Paul Heckbert's "Concave Polygon Scan Conversion",
 % Graphics Gems, 1990.  Leonard Rosenthal and David Harr of Appligent
 % (www.appligent.com) contributed the dash pattern, linecap stroking
 % algorithm, and minor rendering improvements.
 %
 */
 
 /*
   Include declarations.
 */
 #include "MagickCore/studio.h"
 #include "MagickCore/annotate.h"
 #include "MagickCore/artifact.h"
 #include "MagickCore/blob.h"
 #include "MagickCore/cache.h"
 #include "MagickCore/cache-private.h"
 #include "MagickCore/cache-view.h"
 #include "MagickCore/channel.h"
 #include "MagickCore/color.h"
 #include "MagickCore/colorspace-private.h"
 #include "MagickCore/composite.h"
 #include "MagickCore/composite-private.h"
 #include "MagickCore/constitute.h"
 #include "MagickCore/draw.h"
 #include "MagickCore/draw-private.h"
 #include "MagickCore/enhance.h"
 #include "MagickCore/exception.h"
 #include "MagickCore/exception-private.h"
 #include "MagickCore/gem.h"
 #include "MagickCore/geometry.h"
 #include "MagickCore/image-private.h"
 #include "MagickCore/list.h"
 #include "MagickCore/log.h"
 #include "MagickCore/memory-private.h"
 #include "MagickCore/monitor.h"
 #include "MagickCore/monitor-private.h"
 #include "MagickCore/option.h"
 #include "MagickCore/paint.h"
 #include "MagickCore/pixel-accessor.h"
 #include "MagickCore/pixel-private.h"
 #include "MagickCore/property.h"
 #include "MagickCore/resample.h"
 #include "MagickCore/resample-private.h"
 #include "MagickCore/resource_.h"
 #include "MagickCore/string_.h"
 #include "MagickCore/string-private.h"
 #include "MagickCore/thread-private.h"
 #include "MagickCore/token.h"
 #include "MagickCore/transform-private.h"
 #include "MagickCore/utility.h"
 
 /*
   Define declarations.
 */
 #define BezierQuantum  200
 #define DrawEpsilon  (1.0e-10)
-
+#define ThrowPointExpectedException(token,exception) \
+{ \
+  (void) ThrowMagickException(exception,GetMagickModule(),DrawError, \
+    "NonconformingDrawingPrimitiveDefinition","`%s'",token); \
+  status=MagickFalse; \
+}
 
 /*
   Typedef declarations.
 */
@@ -168,7 +173,7 @@ static PrimitiveInfo
   *TraceStrokePolygon(const DrawInfo *,const PrimitiveInfo *);
 
 static size_t
-  TracePath(PrimitiveInfo *,const char *);
+  TracePath(PrimitiveInfo *,const char *,ExceptionInfo *);
 
 static void
   TraceArc(PrimitiveInfo *,const PointInfo,const PointInfo,const PointInfo),
@@ -1670,1662 +1675,1662 @@ static inline void TracePoint(PrimitiveInfo *primitive_info,
 MagickExport MagickBooleanType DrawImage(Image *image,const DrawInfo *draw_info,
   ExceptionInfo *exception)
 {
 #define RenderImageTag  "Render/Image"
 
   AffineMatrix
     affine,
     current;
 
   char
     keyword[MagickPathExtent],
     geometry[MagickPathExtent],
     *next_token,
     pattern[MagickPathExtent],
     *primitive,
     *token;
 
   const char
     *q;
 
   double
     angle,
     factor,
     points_extent,
     primitive_extent;
 
   DrawInfo
     **graphic_context;
 
   MagickBooleanType
     proceed;
 
   MagickSizeType
     number_points;
 
   MagickStatusType
     status;
 
   PointInfo
     point;
 
   PrimitiveInfo
     *primitive_info;
 
   PrimitiveType
     primitive_type;
 
   register const char
     *p;
 
   register ssize_t
     i,
     x;
 
   SegmentInfo
     bounds;
 
   size_t
     extent,
     number_stops;
 
   ssize_t
     j,
     k,
     n;
 
   StopInfo
     *stops;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(draw_info != (DrawInfo *) NULL);
   assert(draw_info->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   if ((draw_info->primitive == (char *) NULL) ||
       (*draw_info->primitive == '\0'))
     return(MagickFalse);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"begin draw-image");
   primitive=(char *) NULL;
   if (*draw_info->primitive != '@')
     primitive=AcquireString(draw_info->primitive);
   else
     if (*(draw_info->primitive+1) != '-')
       primitive=FileToString(draw_info->primitive+1,~0UL,exception);
   if (primitive == (char *) NULL)
     return(MagickFalse);
   primitive_extent=(double) strlen(primitive);
   (void) SetImageArtifact(image,"MVG",primitive);
   n=0;
   number_stops=0;
   stops=(StopInfo *) NULL;
   /*
     Allocate primitive info memory.
   */
   graphic_context=(DrawInfo **) AcquireMagickMemory(sizeof(*graphic_context));
   if (graphic_context == (DrawInfo **) NULL)
     {
       primitive=DestroyString(primitive);
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
-  number_points=6553;
+  number_points=6613;
   primitive_info=(PrimitiveInfo *) AcquireQuantumMemory((size_t) number_points,
     sizeof(*primitive_info));
   if (primitive_info == (PrimitiveInfo *) NULL)
     {
       primitive=DestroyString(primitive);
       for ( ; n >= 0; n--)
         graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
       graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
       ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
         image->filename);
     }
   graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,draw_info);
   graphic_context[n]->viewbox=image->page;
   if ((image->page.width == 0) || (image->page.height == 0))
     {
       graphic_context[n]->viewbox.width=image->columns;
       graphic_context[n]->viewbox.height=image->rows;
     }
   token=AcquireString(primitive);
   extent=strlen(token)+MagickPathExtent;
   if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
     return(MagickFalse);
   status=MagickTrue;
   for (q=primitive; *q != '\0'; )
   {
     /*
       Interpret graphic primitive.
     */
     GetNextToken(q,&q,MagickPathExtent,keyword);
     if (*keyword == '\0')
       break;
     if (*keyword == '#')
       {
         /*
           Comment.
         */
         while ((*q != '\n') && (*q != '\0'))
           q++;
         continue;
       }
     p=q-strlen(keyword)-1;
     primitive_type=UndefinedPrimitive;
     current=graphic_context[n]->affine;
     GetAffineMatrix(&affine);
     switch (*keyword)
     {
       case ';':
         break;
       case 'a':
       case 'A':
       {
         if (LocaleCompare("affine",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.sx=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.rx=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ry=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.sy=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.tx=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ty=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("alpha",keyword) == 0)
           {
             primitive_type=AlphaPrimitive;
             break;
           }
         if (LocaleCompare("arc",keyword) == 0)
           {
             primitive_type=ArcPrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'b':
       case 'B':
       {
         if (LocaleCompare("bezier",keyword) == 0)
           {
             primitive_type=BezierPrimitive;
             break;
           }
         if (LocaleCompare("border-color",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) QueryColorCompliance(token,AllCompliance,
               &graphic_context[n]->border_color,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'c':
       case 'C':
       {
         if (LocaleCompare("clip-path",keyword) == 0)
           {
             /*
               Create clip mask.
             */
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->clip_mask,token);
             (void) DrawClipPath(image,graphic_context[n],
               graphic_context[n]->clip_mask,exception);
             break;
           }
         if (LocaleCompare("clip-rule",keyword) == 0)
           {
             ssize_t
               fill_rule;
 
             GetNextToken(q,&q,extent,token);
             fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
               token);
             if (fill_rule == -1)
               status=MagickFalse;
             else
               graphic_context[n]->fill_rule=(FillRule) fill_rule;
             break;
           }
         if (LocaleCompare("clip-units",keyword) == 0)
           {
             ssize_t
               clip_units;
 
             GetNextToken(q,&q,extent,token);
             clip_units=ParseCommandOption(MagickClipPathOptions,MagickFalse,
               token);
             if (clip_units == -1)
               {
                 status=MagickFalse;
                 break;
               }
             graphic_context[n]->clip_units=(ClipPathUnits) clip_units;
             if (clip_units == ObjectBoundingBox)
               {
                 GetAffineMatrix(&current);
                 affine.sx=draw_info->bounds.x2;
                 affine.sy=draw_info->bounds.y2;
                 affine.tx=draw_info->bounds.x1;
                 affine.ty=draw_info->bounds.y1;
                 break;
               }
             break;
           }
         if (LocaleCompare("circle",keyword) == 0)
           {
             primitive_type=CirclePrimitive;
             break;
           }
         if (LocaleCompare("color",keyword) == 0)
           {
             primitive_type=ColorPrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'd':
       case 'D':
       {
         if (LocaleCompare("decorate",keyword) == 0)
           {
             ssize_t
               decorate;
 
             GetNextToken(q,&q,extent,token);
             decorate=ParseCommandOption(MagickDecorateOptions,MagickFalse,
               token);
             if (decorate == -1)
               status=MagickFalse;
             else
               graphic_context[n]->decorate=(DecorationType) decorate;
             break;
           }
         if (LocaleCompare("density",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->density,token);
             break;
           }
         if (LocaleCompare("direction",keyword) == 0)
           {
             ssize_t
               direction;
 
             GetNextToken(q,&q,extent,token);
             direction=ParseCommandOption(MagickDirectionOptions,MagickFalse,
               token);
             if (direction == -1)
               status=MagickFalse;
             else
               graphic_context[n]->direction=(DirectionType) direction;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'e':
       case 'E':
       {
         if (LocaleCompare("ellipse",keyword) == 0)
           {
             primitive_type=EllipsePrimitive;
             break;
           }
         if (LocaleCompare("encoding",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->encoding,token);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'f':
       case 'F':
       {
         if (LocaleCompare("fill",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) FormatLocaleString(pattern,MagickPathExtent,"%s",token);
             if (GetImageArtifact(image,pattern) != (const char *) NULL)
               (void) DrawPatternPath(image,draw_info,token,
                 &graphic_context[n]->fill_pattern,exception);
             else
               {
                 status&=QueryColorCompliance(token,AllCompliance,
                   &graphic_context[n]->fill,exception);
                 if (graphic_context[n]->fill_alpha != OpaqueAlpha)
                   graphic_context[n]->fill.alpha=graphic_context[n]->fill_alpha;
                 if (status == MagickFalse)
                   {
                     ImageInfo
                       *pattern_info;
 
                     pattern_info=AcquireImageInfo();
                     (void) CopyMagickString(pattern_info->filename,token,
                       MagickPathExtent);
                     graphic_context[n]->fill_pattern=ReadImage(pattern_info,
                       exception);
                     CatchException(exception);
                     pattern_info=DestroyImageInfo(pattern_info);
                   }
               }
             break;
           }
         if (LocaleCompare("fill-opacity",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             graphic_context[n]->fill_alpha=(MagickRealType) (QuantumRange-
               ClampToQuantum((MagickRealType) QuantumRange*(1.0-factor*
               StringToDouble(token,&next_token))));
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("fill-rule",keyword) == 0)
           {
             ssize_t
               fill_rule;
 
             GetNextToken(q,&q,extent,token);
             fill_rule=ParseCommandOption(MagickFillRuleOptions,MagickFalse,
               token);
             if (fill_rule == -1)
               status=MagickFalse;
             else
               graphic_context[n]->fill_rule=(FillRule) fill_rule;
             break;
           }
         if (LocaleCompare("font",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->font,token);
             if (LocaleCompare("none",token) == 0)
               graphic_context[n]->font=(char *) RelinquishMagickMemory(
                 graphic_context[n]->font);
             break;
           }
         if (LocaleCompare("font-family",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) CloneString(&graphic_context[n]->family,token);
             break;
           }
         if (LocaleCompare("font-size",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->pointsize=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("font-stretch",keyword) == 0)
           {
             ssize_t
               stretch;
 
             GetNextToken(q,&q,extent,token);
             stretch=ParseCommandOption(MagickStretchOptions,MagickFalse,token);
             if (stretch == -1)
               status=MagickFalse;
             else
               graphic_context[n]->stretch=(StretchType) stretch;
             break;
           }
         if (LocaleCompare("font-style",keyword) == 0)
           {
             ssize_t
               style;
 
             GetNextToken(q,&q,extent,token);
             style=ParseCommandOption(MagickStyleOptions,MagickFalse,token);
             if (style == -1)
               status=MagickFalse;
             else
               graphic_context[n]->style=(StyleType) style;
             break;
           }
         if (LocaleCompare("font-weight",keyword) == 0)
           {
             ssize_t
               weight;
 
             GetNextToken(q,&q,extent,token);
             weight=ParseCommandOption(MagickWeightOptions,MagickFalse,token);
             if (weight == -1)
               weight=(ssize_t) StringToUnsignedLong(token);
             graphic_context[n]->weight=(size_t) weight;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'g':
       case 'G':
       {
         if (LocaleCompare("gradient-units",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("gravity",keyword) == 0)
           {
             ssize_t
               gravity;
 
             GetNextToken(q,&q,extent,token);
             gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,token);
             if (gravity == -1)
               status=MagickFalse;
             else
               graphic_context[n]->gravity=(GravityType) gravity;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'i':
       case 'I':
       {
         if (LocaleCompare("image",keyword) == 0)
           {
             ssize_t
               compose;
 
             primitive_type=ImagePrimitive;
             GetNextToken(q,&q,extent,token);
             compose=ParseCommandOption(MagickComposeOptions,MagickFalse,token);
             if (compose == -1)
               status=MagickFalse;
             else
               graphic_context[n]->compose=(CompositeOperator) compose;
             break;
           }
         if (LocaleCompare("interline-spacing",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->interline_spacing=StringToDouble(token,
               &next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("interword-spacing",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->interword_spacing=StringToDouble(token,
               &next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'k':
       case 'K':
       {
         if (LocaleCompare("kerning",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->kerning=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'l':
       case 'L':
       {
         if (LocaleCompare("line",keyword) == 0)
           primitive_type=LinePrimitive;
         else
           status=MagickFalse;
         break;
       }
       case 'o':
       case 'O':
       {
         if (LocaleCompare("offset",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("opacity",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             graphic_context[n]->alpha=(Quantum) (QuantumRange*(1.0-
               (QuantumScale*graphic_context[n]->alpha*(1.0-factor*
               StringToDouble(token,&next_token)))));
             graphic_context[n]->fill_alpha=QuantumRange*(1.0-(QuantumScale*
               graphic_context[n]->fill_alpha*(1.0-factor*StringToDouble(token,
               &next_token))));
             graphic_context[n]->stroke_alpha=QuantumRange*(1.0-(QuantumScale*
               graphic_context[n]->stroke_alpha*(1.0-factor*StringToDouble(token,
               &next_token))));
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'p':
       case 'P':
       {
         if (LocaleCompare("path",keyword) == 0)
           {
             primitive_type=PathPrimitive;
             break;
           }
         if (LocaleCompare("point",keyword) == 0)
           {
             primitive_type=PointPrimitive;
             break;
           }
         if (LocaleCompare("polyline",keyword) == 0)
           {
             primitive_type=PolylinePrimitive;
             break;
           }
         if (LocaleCompare("polygon",keyword) == 0)
           {
             primitive_type=PolygonPrimitive;
             break;
           }
         if (LocaleCompare("pop",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (LocaleCompare("clip-path",token) == 0)
               break;
             if (LocaleCompare("defs",token) == 0)
               break;
             if (LocaleCompare("gradient",token) == 0)
               break;
             if (LocaleCompare("graphic-context",token) == 0)
               {
                 if (n <= 0)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       DrawError,"UnbalancedGraphicContextPushPop","`%s'",token);
                     status=MagickFalse;
                     n=0;
                     break;
                   }
                 if (graphic_context[n]->clip_mask != (char *) NULL)
                   if (LocaleCompare(graphic_context[n]->clip_mask,
                       graphic_context[n-1]->clip_mask) != 0)
                     (void) SetImageMask(image,ReadPixelMask,(Image *) NULL,
                       exception);
                 graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
                 n--;
                 break;
               }
             if (LocaleCompare("pattern",token) == 0)
               break;
             status=MagickFalse;
             break;
           }
         if (LocaleCompare("push",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             if (LocaleCompare("clip-path",token) == 0)
               {
                 char
                   name[MagickPathExtent];
 
                 GetNextToken(q,&q,extent,token);
                 (void) FormatLocaleString(name,MagickPathExtent,"%s",token);
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"clip-path") != 0)
                     continue;
                   break;
                 }
                 if ((size_t) (q-p-4+1) > 0)
                   {
                     (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
                     (void) SetImageArtifact(image,name,token);
                   }
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("gradient",token) == 0)
               {
                 char
                   key[2*MagickPathExtent],
                   name[MagickPathExtent],
                   type[MagickPathExtent];
 
                 SegmentInfo
                   segment;
 
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(type,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 segment.x1=StringToDouble(token,&next_token);
                 if (token == next_token)
-                  status=MagickFalse;
+                  ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.y1=StringToDouble(token,&next_token);
                 if (token == next_token)
-                  status=MagickFalse;
+                  ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.x2=StringToDouble(token,&next_token);
                 if (token == next_token)
-                  status=MagickFalse;
+                  ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 segment.y2=StringToDouble(token,&next_token);
                 if (token == next_token)
-                  status=MagickFalse;
+                  ThrowPointExpectedException(token,exception);
                 if (LocaleCompare(type,"radial") == 0)
                   {
                     GetNextToken(q,&q,extent,token);
                     if (*token == ',')
                       GetNextToken(q,&q,extent,token);
                   }
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"gradient") != 0)
                     continue;
                   break;
                 }
                 if ((size_t) (q-p-4+1) > 0)
                   {
                     (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
                     bounds.x1=graphic_context[n]->affine.sx*segment.x1+
                       graphic_context[n]->affine.ry*segment.y1+
                       graphic_context[n]->affine.tx;
                     bounds.y1=graphic_context[n]->affine.rx*segment.x1+
                       graphic_context[n]->affine.sy*segment.y1+
                       graphic_context[n]->affine.ty;
                     bounds.x2=graphic_context[n]->affine.sx*segment.x2+
                       graphic_context[n]->affine.ry*segment.y2+
                       graphic_context[n]->affine.tx;
                     bounds.y2=graphic_context[n]->affine.rx*segment.x2+
                       graphic_context[n]->affine.sy*segment.y2+
                       graphic_context[n]->affine.ty;
                     (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
                     (void) SetImageArtifact(image,key,token);
                     (void) FormatLocaleString(key,MagickPathExtent,"%s-type",
                       name);
                     (void) SetImageArtifact(image,key,type);
                     (void) FormatLocaleString(key,MagickPathExtent,
                       "%s-geometry",name);
                     (void) FormatLocaleString(geometry,MagickPathExtent,
                       "%gx%g%+.15g%+.15g",
                       MagickMax(fabs(bounds.x2-bounds.x1+1.0),1.0),
                       MagickMax(fabs(bounds.y2-bounds.y1+1.0),1.0),
                       bounds.x1,bounds.y1);
                     (void) SetImageArtifact(image,key,geometry);
                   }
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("pattern",token) == 0)
               {
                 char
                   key[2*MagickPathExtent],
                   name[MagickPathExtent];
 
                 RectangleInfo
                   pattern_bounds;
 
                 GetNextToken(q,&q,extent,token);
                 (void) CopyMagickString(name,token,MagickPathExtent);
                 GetNextToken(q,&q,extent,token);
                 pattern_bounds.x=(ssize_t) ceil(StringToDouble(token,
                   &next_token)-0.5);
                 if (token == next_token)
-                  status=MagickFalse;
+                  ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 pattern_bounds.y=(ssize_t) ceil(StringToDouble(token,
                   &next_token)-0.5);
                 if (token == next_token)
-                  status=MagickFalse;
+                  ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 pattern_bounds.width=(size_t) floor(StringToDouble(token,
                   &next_token)+0.5);
                 if (token == next_token)
-                  status=MagickFalse;
+                  ThrowPointExpectedException(token,exception);
                 GetNextToken(q,&q,extent,token);
                 if (*token == ',')
                   GetNextToken(q,&q,extent,token);
                 pattern_bounds.height=(size_t) floor(StringToDouble(token,
                   &next_token)+0.5);
                 if (token == next_token)
-                  status=MagickFalse;
+                  ThrowPointExpectedException(token,exception);
                 for (p=q; *q != '\0'; )
                 {
                   GetNextToken(q,&q,extent,token);
                   if (LocaleCompare(token,"pop") != 0)
                     continue;
                   GetNextToken(q,(const char **) NULL,extent,token);
                   if (LocaleCompare(token,"pattern") != 0)
                     continue;
                   break;
                 }
                 if ((size_t) (q-p-4+1) > 0)
                   {
                     (void) CopyMagickString(token,p,(size_t) (q-p-4+1));
                     (void) FormatLocaleString(key,MagickPathExtent,"%s",name);
                     (void) SetImageArtifact(image,key,token);
                     (void) FormatLocaleString(key,MagickPathExtent,
                       "%s-geometry",name);
                     (void) FormatLocaleString(geometry,MagickPathExtent,
                       "%.20gx%.20g%+.20g%+.20g",(double)pattern_bounds.width,
                       (double)pattern_bounds.height,(double)pattern_bounds.x,
                       (double)pattern_bounds.y);
                     (void) SetImageArtifact(image,key,geometry);
                   }
                 GetNextToken(q,&q,extent,token);
                 break;
               }
             if (LocaleCompare("graphic-context",token) == 0)
               {
                 n++;
                 graphic_context=(DrawInfo **) ResizeQuantumMemory(
                   graphic_context,(size_t) (n+1),sizeof(*graphic_context));
                 if (graphic_context == (DrawInfo **) NULL)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       ResourceLimitError,"MemoryAllocationFailed","`%s'",
                       image->filename);
                     break;
                   }
                 graphic_context[n]=CloneDrawInfo((ImageInfo *) NULL,
                   graphic_context[n-1]);
                 break;
               }
             if (LocaleCompare("defs",token) == 0)
               break;
             status=MagickFalse;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'r':
       case 'R':
       {
         if (LocaleCompare("rectangle",keyword) == 0)
           {
             primitive_type=RectanglePrimitive;
             break;
           }
         if (LocaleCompare("rotate",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             affine.sx=cos(DegreesToRadians(fmod((double) angle,360.0)));
             affine.rx=sin(DegreesToRadians(fmod((double) angle,360.0)));
             affine.ry=(-sin(DegreesToRadians(fmod((double) angle,360.0))));
             affine.sy=cos(DegreesToRadians(fmod((double) angle,360.0)));
             break;
           }
         if (LocaleCompare("roundRectangle",keyword) == 0)
           {
             primitive_type=RoundRectanglePrimitive;
             break;
           }
         status=MagickFalse;
         break;
       }
       case 's':
       case 'S':
       {
         if (LocaleCompare("scale",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.sx=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.sy=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("skewX",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             affine.ry=sin(DegreesToRadians(angle));
             break;
           }
         if (LocaleCompare("skewY",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             angle=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             affine.rx=(-tan(DegreesToRadians(angle)/2.0));
             break;
           }
         if (LocaleCompare("stop-color",keyword) == 0)
           {
             PixelInfo
               stop_color;
 
             number_stops++;
             if (number_stops == 1)
               stops=(StopInfo *) AcquireQuantumMemory(2,sizeof(*stops));
             else if (number_stops > 2)
               stops=(StopInfo *) ResizeQuantumMemory(stops,number_stops,
                 sizeof(*stops));
             if (stops == (StopInfo *) NULL)
               {
                 (void) ThrowMagickException(exception,GetMagickModule(),
                   ResourceLimitError,"MemoryAllocationFailed","`%s'",
                   image->filename);
                 break;
               }
             GetNextToken(q,&q,extent,token);
             (void) QueryColorCompliance(token,AllCompliance,&stop_color,
               exception);
             stops[number_stops-1].color=stop_color;
             GetNextToken(q,&q,extent,token);
             stops[number_stops-1].offset=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("stroke",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) FormatLocaleString(pattern,MagickPathExtent,"%s",token);
             if (GetImageArtifact(image,pattern) != (const char *) NULL)
               (void) DrawPatternPath(image,draw_info,token,
                 &graphic_context[n]->stroke_pattern,exception);
             else
               {
                 status&=QueryColorCompliance(token,AllCompliance,
                   &graphic_context[n]->stroke,exception);
                 if (graphic_context[n]->stroke_alpha != OpaqueAlpha)
                   graphic_context[n]->stroke.alpha=
                     graphic_context[n]->stroke_alpha;
                 if (status == MagickFalse)
                   {
                     ImageInfo
                       *pattern_info;
 
                     pattern_info=AcquireImageInfo();
                     (void) CopyMagickString(pattern_info->filename,token,
                       MagickPathExtent);
                     graphic_context[n]->stroke_pattern=ReadImage(pattern_info,
                       exception);
                     CatchException(exception);
                     pattern_info=DestroyImageInfo(pattern_info);
                   }
               }
             break;
           }
         if (LocaleCompare("stroke-antialias",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->stroke_antialias=
               StringToLong(token) != 0 ? MagickTrue : MagickFalse;
             break;
           }
         if (LocaleCompare("stroke-dasharray",keyword) == 0)
           {
             if (graphic_context[n]->dash_pattern != (double *) NULL)
               graphic_context[n]->dash_pattern=(double *)
                 RelinquishMagickMemory(graphic_context[n]->dash_pattern);
             if (IsPoint(q) != MagickFalse)
               {
                 const char
                   *r;
 
                 r=q;
                 GetNextToken(r,&r,extent,token);
                 if (*token == ',')
                   GetNextToken(r,&r,extent,token);
                 for (x=0; IsPoint(token) != MagickFalse; x++)
                 {
                   GetNextToken(r,&r,extent,token);
                   if (*token == ',')
                     GetNextToken(r,&r,extent,token);
                 }
                 graphic_context[n]->dash_pattern=(double *)
                   AcquireQuantumMemory((size_t) (2UL*x+2UL),
                   sizeof(*graphic_context[n]->dash_pattern));
                 if (graphic_context[n]->dash_pattern == (double *) NULL)
                   {
                     (void) ThrowMagickException(exception,GetMagickModule(),
                       ResourceLimitError,"MemoryAllocationFailed","`%s'",
                       image->filename);
                     status=MagickFalse;
                     break;
                   }
                 for (j=0; j < x; j++)
                 {
                   GetNextToken(q,&q,extent,token);
                   if (*token == ',')
                     GetNextToken(q,&q,extent,token);
                   graphic_context[n]->dash_pattern[j]=StringToDouble(token,
                     &next_token);
                   if (token == next_token)
-                    status=MagickFalse;
+                    ThrowPointExpectedException(token,exception);
                   if (graphic_context[n]->dash_pattern[j] < 0.0)
                     status=MagickFalse;
                 }
                 if ((x & 0x01) != 0)
                   for ( ; j < (2*x); j++)
                     graphic_context[n]->dash_pattern[j]=
                       graphic_context[n]->dash_pattern[j-x];
                 graphic_context[n]->dash_pattern[j]=0.0;
                 break;
               }
             GetNextToken(q,&q,extent,token);
             break;
           }
         if (LocaleCompare("stroke-dashoffset",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->dash_offset=StringToDouble(token,
               &next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("stroke-linecap",keyword) == 0)
           {
             ssize_t
               linecap;
 
             GetNextToken(q,&q,extent,token);
             linecap=ParseCommandOption(MagickLineCapOptions,MagickFalse,token);
             if (linecap == -1)
               status=MagickFalse;
             else
               graphic_context[n]->linecap=(LineCap) linecap;
             break;
           }
         if (LocaleCompare("stroke-linejoin",keyword) == 0)
           {
             ssize_t
               linejoin;
 
             GetNextToken(q,&q,extent,token);
             linejoin=ParseCommandOption(MagickLineJoinOptions,MagickFalse,
               token);
             if (linejoin == -1)
               status=MagickFalse;
             else
               graphic_context[n]->linejoin=(LineJoin) linejoin;
             break;
           }
         if (LocaleCompare("stroke-miterlimit",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->miterlimit=StringToUnsignedLong(token);
             break;
           }
         if (LocaleCompare("stroke-opacity",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             factor=strchr(token,'%') != (char *) NULL ? 0.01 : 1.0;
             graphic_context[n]->stroke_alpha=(MagickRealType) (QuantumRange-
               ClampToQuantum((MagickRealType) QuantumRange*(1.0-factor*
               StringToDouble(token,&next_token))));
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         if (LocaleCompare("stroke-width",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->stroke_width=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 't':
       case 'T':
       {
         if (LocaleCompare("text",keyword) == 0)
           {
             primitive_type=TextPrimitive;
             break;
           }
         if (LocaleCompare("text-align",keyword) == 0)
           {
             ssize_t
               align;
 
             GetNextToken(q,&q,extent,token);
             align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);
             if (align == -1)
               status=MagickFalse;
             else
               graphic_context[n]->align=(AlignType) align;
             break;
           }
         if (LocaleCompare("text-anchor",keyword) == 0)
           {
             ssize_t
               align;
 
             GetNextToken(q,&q,extent,token);
             align=ParseCommandOption(MagickAlignOptions,MagickFalse,token);
             if (align == -1)
               status=MagickFalse;
             else
               graphic_context[n]->align=(AlignType) align;
             break;
           }
         if (LocaleCompare("text-antialias",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->text_antialias=StringToLong(token) != 0 ?
               MagickTrue : MagickFalse;
             break;
           }
         if (LocaleCompare("text-undercolor",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             (void) QueryColorCompliance(token,AllCompliance,
               &graphic_context[n]->undercolor,exception);
             break;
           }
         if (LocaleCompare("translate",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             affine.tx=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             affine.ty=StringToDouble(token,&next_token);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       case 'v':
       case 'V':
       {
         if (LocaleCompare("viewbox",keyword) == 0)
           {
             GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.x=(ssize_t) ceil(StringToDouble(token,
               &next_token)-0.5);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.y=(ssize_t) ceil(StringToDouble(token,
               &next_token)-0.5);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.width=(size_t) floor(StringToDouble(
               token,&next_token)+0.5);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             GetNextToken(q,&q,extent,token);
             if (*token == ',')
               GetNextToken(q,&q,extent,token);
             graphic_context[n]->viewbox.height=(size_t) floor(StringToDouble(
               token,&next_token)+0.5);
             if (token == next_token)
-              status=MagickFalse;
+              ThrowPointExpectedException(token,exception);
             break;
           }
         status=MagickFalse;
         break;
       }
       default:
       {
         status=MagickFalse;
         break;
       }
     }
     if (status == MagickFalse)
       break;
     if ((fabs(affine.sx-1.0) >= DrawEpsilon) ||
         (fabs(affine.rx) >= DrawEpsilon) || (fabs(affine.ry) >= DrawEpsilon) ||
         (fabs(affine.sy-1.0) >= DrawEpsilon) ||
         (fabs(affine.tx) >= DrawEpsilon) || (fabs(affine.ty) >= DrawEpsilon))
       {
         graphic_context[n]->affine.sx=current.sx*affine.sx+current.ry*affine.rx;
         graphic_context[n]->affine.rx=current.rx*affine.sx+current.sy*affine.rx;
         graphic_context[n]->affine.ry=current.sx*affine.ry+current.ry*affine.sy;
         graphic_context[n]->affine.sy=current.rx*affine.ry+current.sy*affine.sy;
         graphic_context[n]->affine.tx=current.sx*affine.tx+current.ry*affine.ty+
           current.tx;
         graphic_context[n]->affine.ty=current.rx*affine.tx+current.sy*affine.ty+
           current.ty;
       }
     if (primitive_type == UndefinedPrimitive)
       {
         if (*q == '\0')
           {
             if (number_stops > 1)
               {
                 GradientType
                   type;
 
               type=LinearGradient;
               if (draw_info->gradient.type == RadialGradient)
                 type=RadialGradient;
               (void) GradientImage(image,type,PadSpread,stops,number_stops,
                 exception);
              }
            if (number_stops > 0)
              stops=(StopInfo *) RelinquishMagickMemory(stops);
           }
         if (image->debug != MagickFalse)
           (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  %.*s",(int)
             (q-p),p);
         continue;
       }
     /*
       Parse the primitive attributes.
     */
     i=0;
     j=0;
     primitive_info[0].point.x=0.0;
     primitive_info[0].point.y=0.0;
     for (x=0; *q != '\0'; x++)
     {
       /*
         Define points.
       */
       if (IsPoint(q) == MagickFalse)
         break;
       GetNextToken(q,&q,extent,token);
       point.x=StringToDouble(token,&next_token);
       if (token == next_token)
-        status=MagickFalse;
+        ThrowPointExpectedException(token,exception);
       GetNextToken(q,&q,extent,token);
       if (*token == ',')
         GetNextToken(q,&q,extent,token);
       point.y=StringToDouble(token,&next_token);
       if (token == next_token)
-        status=MagickFalse;
+        ThrowPointExpectedException(token,exception);
       GetNextToken(q,(const char **) NULL,extent,token);
       if (*token == ',')
         GetNextToken(q,&q,extent,token);
       primitive_info[i].primitive=primitive_type;
       primitive_info[i].point=point;
       primitive_info[i].coordinates=0;
       primitive_info[i].method=FloodfillMethod;
       i++;
       if (i < (ssize_t) number_points)
         continue;
       number_points<<=1;
       primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
         (size_t) number_points,sizeof(*primitive_info));
       if ((primitive_info == (PrimitiveInfo *) NULL) ||
           (number_points != (MagickSizeType) ((size_t) number_points)))
         ThrowBinaryException(ResourceLimitError,"MemoryAllocationFailed",
           image->filename);
     }
     primitive_info[j].primitive=primitive_type;
     primitive_info[j].coordinates=(size_t) x;
     primitive_info[j].method=FloodfillMethod;
     primitive_info[j].text=(char *) NULL;
     /*
       Circumscribe primitive within a circle.
     */
     bounds.x1=primitive_info[j].point.x;
     bounds.y1=primitive_info[j].point.y;
     bounds.x2=primitive_info[j].point.x;
     bounds.y2=primitive_info[j].point.y;
     for (k=1; k < (ssize_t) primitive_info[j].coordinates; k++)
     {
       point=primitive_info[j+k].point;
       if (point.x < bounds.x1)
         bounds.x1=point.x;
       if (point.y < bounds.y1)
         bounds.y1=point.y;
       if (point.x > bounds.x2)
         bounds.x2=point.x;
       if (point.y > bounds.y2)
         bounds.y2=point.y;
     }
     /*
       Speculate how many points our primitive might consume.
     */
     points_extent=(double) primitive_info[j].coordinates;
     switch (primitive_type)
     {
       case RectanglePrimitive:
       {
         points_extent*=5;
         break;
       }
       case RoundRectanglePrimitive:
       {
         double
           alpha,
           beta,
           radius;
 
         alpha=bounds.x2-bounds.x1;
         beta=bounds.y2-bounds.y1;
         radius=hypot((double) alpha,(double) beta);
         points_extent*=5;
         points_extent+=2*ceil((double) MagickPI*radius)+6*BezierQuantum+360;
         break;
       }
       case BezierPrimitive:
       {
         if (primitive_info[j].coordinates > 107)
           {
             (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
               "TooManyBezierCoordinates","`%s'",token);
             status=MagickFalse;
             break;
           }
         points_extent=(double) (BezierQuantum*primitive_info[j].coordinates);
         break;
       }
       case PathPrimitive:
       {
         char
           *s,
           *t;
 
         GetNextToken(q,&q,extent,token);
         points_extent=1;
         t=token;
         for (s=token; *s != '\0'; s=t)
         {
           double
             value;
 
           value=StringToDouble(s,&t);
           (void) value;
           if (s == t)
             {
               t++;
               continue;
             }
           points_extent++;
         }
         points_extent=points_extent*BezierQuantum;
         break;
       }
       case CirclePrimitive:
       case ArcPrimitive:
       case EllipsePrimitive:
       {
         double
           alpha,
           beta,
           coordinates,
           radius;
 
         alpha=bounds.x2-bounds.x1;
         beta=bounds.y2-bounds.y1;
         radius=hypot(alpha,beta);
         coordinates=ceil(MagickPI*MagickPI*radius)+6*BezierQuantum+360;
         if (coordinates > 21400)
           {
             (void) ThrowMagickException(exception,GetMagickModule(),DrawError,
               "TooManyBezierCoordinates","`%s'",token);
             status=MagickFalse;
             break;
           }
         points_extent=coordinates;
         break;
       }
       default:
         break;
     }
     if (status == MagickFalse)
       break;
     if (((double) ((size_t) points_extent)) < points_extent)
       {
         (void) ThrowMagickException(exception,GetMagickModule(),
           ResourceLimitError,"MemoryAllocationFailed","`%s'",image->filename);
         break;
       }
     if (((MagickSizeType) (i+points_extent)) >= number_points)
       {
         /*
           Resize based on speculative points required by primitive.
         */
         number_points+=points_extent+1;
         primitive_info=(PrimitiveInfo *) ResizeQuantumMemory(primitive_info,
           (size_t) number_points,sizeof(*primitive_info));
         if ((primitive_info == (PrimitiveInfo *) NULL) ||
             (number_points != (MagickSizeType) ((size_t) number_points)))
           {
             (void) ThrowMagickException(exception,GetMagickModule(),
               ResourceLimitError,"MemoryAllocationFailed","`%s'",
               image->filename);
             break;
           }
       }
     switch (primitive_type)
     {
       case PointPrimitive:
       default:
       {
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         TracePoint(primitive_info+j,primitive_info[j].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case LinePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceLine(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case RectanglePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceRectangle(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case RoundRectanglePrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             status=MagickFalse;
             break;
           }
         TraceRoundRectangle(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case ArcPrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             primitive_type=UndefinedPrimitive;
             break;
           }
         TraceArc(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case EllipsePrimitive:
       {
         if (primitive_info[j].coordinates != 3)
           {
             status=MagickFalse;
             break;
           }
         TraceEllipse(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point,primitive_info[j+2].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case CirclePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         TraceCircle(primitive_info+j,primitive_info[j].point,
           primitive_info[j+1].point);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case PolylinePrimitive:
         break;
       case PolygonPrimitive:
       {
         primitive_info[i]=primitive_info[j];
         primitive_info[i].coordinates=0;
         primitive_info[j].coordinates++;
         i++;
         break;
       }
       case BezierPrimitive:
       {
         if (primitive_info[j].coordinates < 3)
           {
             status=MagickFalse;
             break;
           }
         TraceBezier(primitive_info+j,primitive_info[j].coordinates);
         i=(ssize_t) (j+primitive_info[j].coordinates);
         break;
       }
       case PathPrimitive:
       {
-        i=(ssize_t) (j+TracePath(primitive_info+j,token));
+        i=(ssize_t) (j+TracePath(primitive_info+j,token,exception));
         break;
       }
       case AlphaPrimitive:
       case ColorPrimitive:
       {
         ssize_t
           method;
 
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         GetNextToken(q,&q,extent,token);
         method=ParseCommandOption(MagickMethodOptions,MagickFalse,token);
         if (method == -1)
           status=MagickFalse;
         else
           primitive_info[j].method=(PaintMethod) method;
         break;
       }
       case TextPrimitive:
       {
         if (primitive_info[j].coordinates != 1)
           {
             status=MagickFalse;
             break;
           }
         if (*token != ',')
           GetNextToken(q,&q,extent,token);
         primitive_info[j].text=AcquireString(token);
         break;
       }
       case ImagePrimitive:
       {
         if (primitive_info[j].coordinates != 2)
           {
             status=MagickFalse;
             break;
           }
         GetNextToken(q,&q,extent,token);
         primitive_info[j].text=AcquireString(token);
         break;
       }
     }
     if (primitive_info == (PrimitiveInfo *) NULL)
       break;
     if (image->debug != MagickFalse)
       (void) LogMagickEvent(DrawEvent,GetMagickModule(),"  %.*s",(int) (q-p),p);
     if (status == MagickFalse)
       break;
     primitive_info[i].primitive=UndefinedPrimitive;
     if (i == 0)
       continue;
     /*
       Transform points.
     */
     for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++)
     {
       point=primitive_info[i].point;
       primitive_info[i].point.x=graphic_context[n]->affine.sx*point.x+
         graphic_context[n]->affine.ry*point.y+graphic_context[n]->affine.tx;
       primitive_info[i].point.y=graphic_context[n]->affine.rx*point.x+
         graphic_context[n]->affine.sy*point.y+graphic_context[n]->affine.ty;
       point=primitive_info[i].point;
       if (point.x < graphic_context[n]->bounds.x1)
         graphic_context[n]->bounds.x1=point.x;
       if (point.y < graphic_context[n]->bounds.y1)
         graphic_context[n]->bounds.y1=point.y;
       if (point.x > graphic_context[n]->bounds.x2)
         graphic_context[n]->bounds.x2=point.x;
       if (point.y > graphic_context[n]->bounds.y2)
         graphic_context[n]->bounds.y2=point.y;
       if (primitive_info[i].primitive == ImagePrimitive)
         break;
       if (i >= (ssize_t) number_points)
         ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
     }
     if (graphic_context[n]->render != MagickFalse)
       {
         if ((n != 0) && (graphic_context[n]->clip_mask != (char *) NULL) &&
             (LocaleCompare(graphic_context[n]->clip_mask,
              graphic_context[n-1]->clip_mask) != 0))
           status&=DrawClipPath(image,graphic_context[n],
             graphic_context[n]->clip_mask,exception);
         status&=DrawPrimitive(image,graphic_context[n],primitive_info,
           exception);
       }
     if (primitive_info->text != (char *) NULL)
       primitive_info->text=(char *) RelinquishMagickMemory(
         primitive_info->text);
     proceed=SetImageProgress(image,RenderImageTag,q-primitive,(MagickSizeType)
       primitive_extent);
     if (proceed == MagickFalse)
       break;
     if (status == 0)
       break;
   }
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(DrawEvent,GetMagickModule(),"end draw-image");
   /*
     Relinquish resources.
   */
   token=DestroyString(token);
   if (primitive_info != (PrimitiveInfo *) NULL)
     primitive_info=(PrimitiveInfo *) RelinquishMagickMemory(primitive_info);
   primitive=DestroyString(primitive);
   for ( ; n >= 0; n--)
     graphic_context[n]=DestroyDrawInfo(graphic_context[n]);
   graphic_context=(DrawInfo **) RelinquishMagickMemory(graphic_context);
   if (status == MagickFalse)
     ThrowBinaryException(DrawError,"NonconformingDrawingPrimitiveDefinition",
       keyword);
   return(status != 0 ? MagickTrue : MagickFalse);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %     D r a w G r a d i e n t I m a g e                                       %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  DrawGradientImage() draws a linear gradient on the image.
 %
 %  The format of the DrawGradientImage method is:
 %
 %      MagickBooleanType DrawGradientImage(Image *image,
 %        const DrawInfo *draw_info,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o draw_info: the draw info.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
@@ -5484,418 +5489,463 @@ static void TraceLine(PrimitiveInfo *primitive_info,const PointInfo start,
   primitive_info->coordinates=2;
 }
 
-static size_t TracePath(PrimitiveInfo *primitive_info,const char *path)
+static size_t TracePath(PrimitiveInfo *primitive_info,const char *path,
+  ExceptionInfo *exception)
 {
   char
     *next_token,
     token[MagickPathExtent];
 
   const char
     *p;
 
   double
     x,
     y;
 
   int
     attribute,
     last_attribute;
 
+  MagickBooleanType
+    status;
+
   PointInfo
     end = {0.0, 0.0},
     points[4] = { {0.0,0.0}, {0.0,0.0}, {0.0,0.0}, {0.0,0.0} },
     point = {0.0, 0.0},
     start = {0.0, 0.0};
 
   PrimitiveType
     primitive_type;
 
   register PrimitiveInfo
     *q;
 
   register ssize_t
     i;
 
   size_t
     number_coordinates,
     z_count;
 
   attribute=0;
   number_coordinates=0;
   z_count=0;
   primitive_type=primitive_info->primitive;
   q=primitive_info;
+  status=MagickTrue;
   for (p=path; *p != '\0'; )
   {
+    if (status == MagickFalse)
+      break;
     while (isspace((int) ((unsigned char) *p)) != 0)
       p++;
     if (*p == '\0')
       break;
     last_attribute=attribute;
     attribute=(int) (*p++);
     switch (attribute)
     {
       case 'a':
       case 'A':
       {
         double
           angle;
 
         MagickBooleanType
           large_arc,
           sweep;
 
         PointInfo
           arc;
 
         /*
           Elliptical arc.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           arc.x=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           arc.y=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           angle=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           large_arc=StringToLong(token) != 0 ? MagickTrue : MagickFalse;
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           sweep=StringToLong(token) != 0 ? MagickTrue : MagickFalse;
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           end.x=(double) (attribute == (int) 'A' ? x : point.x+x);
           end.y=(double) (attribute == (int) 'A' ? y : point.y+y);
           TraceArcPath(q,point,end,arc,angle,large_arc,sweep);
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'c':
       case 'C':
       {
         /*
           Cubic Bézier curve.
         */
         do
         {
           points[0]=point;
           for (i=1; i < 4; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
+            if (token == next_token)
+              ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
+            if (token == next_token)
+              ThrowPointExpectedException(token,exception);
             end.x=(double) (attribute == (int) 'C' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'C' ? y : point.y+y);
             points[i]=end;
           }
           for (i=0; i < 4; i++)
             (q+i)->point=points[i];
           TraceBezier(q,4);
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'H':
       case 'h':
       {
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'H' ? x: point.x+x);
           TracePoint(q,point);
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'l':
       case 'L':
       {
         /*
           Line to.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'L' ? x : point.x+x);
           point.y=(double) (attribute == (int) 'L' ? y : point.y+y);
           TracePoint(q,point);
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'M':
       case 'm':
       {
         /*
           Move to;
         */
         if (q != primitive_info)
           {
             primitive_info->coordinates=(size_t) (q-primitive_info);
             number_coordinates+=primitive_info->coordinates;
             primitive_info=q;
           }
         i=0;
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'M' ? x : point.x+x);
           point.y=(double) (attribute == (int) 'M' ? y : point.y+y);
           if (i == 0)
             start=point;
           i++;
           TracePoint(q,point);
           q+=q->coordinates;
           if ((i != 0) && (attribute == (int) 'M'))
             {
               TracePoint(q,point);
               q+=q->coordinates;
             }
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'q':
       case 'Q':
       {
         /*
           Quadratic Bézier curve.
         */
         do
         {
           points[0]=point;
           for (i=1; i < 3; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
+            if (token == next_token)
+              ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
+            if (token == next_token)
+              ThrowPointExpectedException(token,exception);
             if (*p == ',')
               p++;
             end.x=(double) (attribute == (int) 'Q' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'Q' ? y : point.y+y);
             points[i]=end;
           }
           for (i=0; i < 3; i++)
             (q+i)->point=points[i];
           TraceBezier(q,3);
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 's':
       case 'S':
       {
         /*
           Cubic Bézier curve.
         */
         do
         {
           points[0]=points[3];
           points[1].x=2.0*points[3].x-points[2].x;
           points[1].y=2.0*points[3].y-points[2].y;
           for (i=2; i < 4; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
+            if (token == next_token)
+              ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
+            if (token == next_token)
+              ThrowPointExpectedException(token,exception);
             if (*p == ',')
               p++;
             end.x=(double) (attribute == (int) 'S' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'S' ? y : point.y+y);
             points[i]=end;
           }
           if (strchr("CcSs",last_attribute) == (char *) NULL)
             {
               points[0]=point;
               points[1]=point;
             }
           for (i=0; i < 4; i++)
             (q+i)->point=points[i];
           TraceBezier(q,4);
           q+=q->coordinates;
           point=end;
           last_attribute=attribute;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 't':
       case 'T':
       {
         /*
           Quadratic Bézier curve.
         */
         do
         {
           points[0]=points[2];
           points[1].x=2.0*points[2].x-points[1].x;
           points[1].y=2.0*points[2].y-points[1].y;
           for (i=2; i < 3; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
+            if (token == next_token)
+              ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
+            if (token == next_token)
+              ThrowPointExpectedException(token,exception);
             end.x=(double) (attribute == (int) 'T' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'T' ? y : point.y+y);
             points[i]=end;
           }
           if (strchr("QqTt",last_attribute) == (char *) NULL)
             {
               points[0]=point;
               points[1]=point;
             }
           for (i=0; i < 3; i++)
             (q+i)->point=points[i];
           TraceBezier(q,3);
           q+=q->coordinates;
           point=end;
           last_attribute=attribute;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'v':
       case 'V':
       {
         /*
           Line to.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
+          if (token == next_token)
+            ThrowPointExpectedException(token,exception);
           point.y=(double) (attribute == (int) 'V' ? y : point.y+y);
           TracePoint(q,point);
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'z':
       case 'Z':
       {
         /*
           Close path.
         */
         point=start;
         TracePoint(q,point);
         q+=q->coordinates;
         primitive_info->coordinates=(size_t) (q-primitive_info);
         number_coordinates+=primitive_info->coordinates;
         primitive_info=q;
         z_count++;
         break;
       }
       default:
       {
         if (isalpha((int) ((unsigned char) attribute)) != 0)
           (void) FormatLocaleFile(stderr,"attribute not recognized: %c\n",
             attribute);
         break;
       }
     }
   }
   primitive_info->coordinates=(size_t) (q-primitive_info);
   number_coordinates+=primitive_info->coordinates;
   for (i=0; i < (ssize_t) number_coordinates; i++)
   {
     q--;
     q->primitive=primitive_type;
     if (z_count > 1)
       q->method=FillToBorderMethod;
   }
   q=primitive_info;
   return(number_coordinates);
 }
