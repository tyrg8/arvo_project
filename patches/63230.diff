commit e8d026548e88221580cbaeb7a8906bced0295402
Author: Akshay Ragir <akshay.ragir@ittiam.com>
Date:   Thu Oct 12 12:41:06 2023 +0530

    Fix for the Index-out-of-bounds in iusace_quantize_lines
    
    These changes handle the index-out-of-bounds runtime error
    reported when the bit consumption exceeds the bit reservoir
    and global gain reaches the maximum value. The issue is
    reported with USAC and the same changes are extended to AAC.
    
    Bug: ossFuzz: 63019
    Test: poc in bug

diff --git a/encoder/iusace_enc_main.c b/encoder/iusace_enc_main.c
index 503f9c9..b24e9c8 100644
--- a/encoder/iusace_enc_main.c
+++ b/encoder/iusace_enc_main.c
@@ -937,408 +937,408 @@ static IA_ERRORCODE iusace_enc_ext_elemts(UWORD32 usac_ext_ele_type,
 IA_ERRORCODE ixheaace_usac_encode(FLOAT32 **ptr_input,
                                   ia_usac_encoder_config_struct *ptr_usac_config,
                                   ia_usac_data_struct *pstr_state,
                                   ixheaace_audio_specific_config_struct *pstr_asc,
                                   ia_bit_buf_struct *pstr_it_bit_buff,
                                   ixheaace_pstr_sbr_enc ptr_env_encoder, FLOAT32 **pp_drc_inp,
-                                  WORD32 *is_quant_spec_zero) {
+                                  WORD32 *is_quant_spec_zero, WORD32 *is_gain_limited) {
   IA_ERRORCODE err = IA_NO_ERROR;
   WORD32 i_ch, i, k;
   ia_usac_data_struct *ptr_usac_data = pstr_state;
   iusace_scratch_mem *pstr_scratch = &ptr_usac_data->str_scratch;
   WORD32 bits_written = 0;
 
   WORD32 *next_window_sequence = pstr_scratch->ptr_next_win_scratch;
   WORD32 *new_win_seq = pstr_scratch->ptr_next_win_scratch + MAX_TIME_CHANNELS;
   memset(next_window_sequence, 0, MAX_TIME_CHANNELS * sizeof(next_window_sequence));
   memset(new_win_seq, 0, MAX_TIME_CHANNELS * sizeof(new_win_seq));
   ia_sfb_params_struct *pstr_sfb_prms = &ptr_usac_config->str_sfb_prms;
   memset(pstr_sfb_prms, 0, sizeof(ia_sfb_params_struct));
 
   WORD32 *num_window_groups = pstr_sfb_prms->num_window_groups;
   WORD32 average_bits_total;
   WORD32 num_bits;
   WORD32 padding_bits;
   WORD32 *common_win = pstr_sfb_prms->common_win;
   WORD32 usac_independency_flg;
   WORD32 mod[NUM_FRAMES] = {0};
   WORD32 len_frame;
   WORD32 len_lpc0;
   WORD32 len_next_high_rate;
   WORD8 elem_idx, nr_core_coder_channels = 0, chn = 0;
   WORD32 ch_offset = 0;
   WORD32 elem_idx_max = ptr_usac_config->num_elements;
   WORD32 td_buffer_offset = (TD_BUFFER_OFFSET * ptr_usac_config->ccfl) / FRAME_LEN_LONG;
   usac_independency_flg = ptr_usac_data->usac_independency_flag;
 
   len_frame = ptr_usac_config->ccfl;
   len_lpc0 = (LEN_LPC0 * len_frame) / FRAME_LEN_LONG;
   len_next_high_rate = (LEN_NEXT_HIGH_RATE * len_frame) / FRAME_LEN_LONG;
 
   average_bits_total =
       (ptr_usac_config->bit_rate * ptr_usac_config->ccfl) / ptr_usac_config->core_sample_rate;
 
   ptr_usac_data->min_bits_needed =
       (long)(ptr_usac_data->available_bitreservoir_bits + 2 * average_bits_total -
              ptr_usac_data->max_bitreservoir_bits);
   if (ptr_usac_data->min_bits_needed < 0) {
     ptr_usac_data->min_bits_needed = 0;
   }
 
   if (ptr_usac_config->use_drc_element == 1) {
     elem_idx_max -= 1;
   }
 
   num_bits = 0;
 
   iusace_write_bits_buf(pstr_it_bit_buff, usac_independency_flg, 1);
   num_bits++;
 
   for (elem_idx = 0; elem_idx < elem_idx_max; elem_idx++) {
     switch (ptr_usac_data->channel_elem_type[elem_idx]) {
       case USAC_ELEMENT_TYPE_SCE:
         nr_core_coder_channels = 1;
         break;
       case USAC_ELEMENT_TYPE_CPE:
         nr_core_coder_channels = 2;
         break;
     }
 
     if (ptr_usac_data->core_mode[0] == CORE_MODE_FD) {
       for (chn = 0, i_ch = ch_offset; chn < nr_core_coder_channels; chn++, i_ch++) {
         iusace_block_switching(&ptr_usac_data->block_switch_ctrl[i_ch], ptr_input[i_ch],
                                ptr_usac_config->ccfl);
       }
     }
 
     i_ch = ch_offset;
     if (nr_core_coder_channels == 2) {
       iusace_sync_block_switching(&ptr_usac_data->block_switch_ctrl[i_ch],
                                   &ptr_usac_data->block_switch_ctrl[i_ch + 1]);
     }
 
     for (chn = 0, i_ch = ch_offset; chn < nr_core_coder_channels; chn++, i_ch++) {
       switch (ptr_usac_config->codec_mode) {
         case USAC_SWITCHED:
           if (ptr_usac_data->str_sig_class_data.coding_mode == 2) {
             ptr_usac_data->core_mode_next[i_ch] = CORE_MODE_FD;
           } else {
             ptr_usac_data->core_mode_next[i_ch] = CORE_MODE_TD;
           }
           break;
         case USAC_ONLY_FD:
           ptr_usac_data->core_mode_next[i_ch] = CORE_MODE_FD;
           break;
         case USAC_ONLY_TD:
           ptr_usac_data->core_mode_next[i_ch] = CORE_MODE_TD;
           break;
         default:
           return (-1);
       }
       if (ptr_usac_data->core_mode[i_ch] == CORE_MODE_TD) {
         for (i = 0; i < ptr_usac_config->ccfl; i++) {
           ptr_usac_data->ptr_2frame_time_data[i_ch][i] = ptr_usac_data->ptr_time_data[i_ch][i];
           ptr_usac_data->ptr_2frame_time_data[i_ch][ptr_usac_config->ccfl + i] =
               ptr_usac_data->ptr_look_ahead_time_data[i_ch][i];
           ptr_usac_data->ptr_time_data[i_ch][i] =
               ptr_usac_data->ptr_look_ahead_time_data[i_ch][i];
           ptr_usac_data->ptr_look_ahead_time_data[i_ch][i] = (FLOAT64)ptr_input[i_ch][i];
         }
       } else {
         for (i = 0; i < ptr_usac_config->ccfl; i++) {
           ptr_usac_data->ptr_2frame_time_data[i_ch][i] = ptr_usac_data->ptr_time_data[i_ch][i];
           ptr_usac_data->ptr_2frame_time_data[i_ch][ptr_usac_config->ccfl + i] =
               ptr_usac_data->ptr_look_ahead_time_data[i_ch][i];
           ptr_usac_data->ptr_time_data[i_ch][i] = ptr_input[i_ch][i];
           ptr_usac_data->ptr_look_ahead_time_data[i_ch][i] = (FLOAT64)ptr_input[i_ch][i];
         }
       }
 
       for (i = 0; i < len_frame + len_next_high_rate; i++) {
         ptr_usac_data->td_in_buf[i_ch][i] =
             (FLOAT32)(ptr_usac_data->ptr_2frame_time_data[i_ch][i + td_buffer_offset]);
       }
       for (i = 0; i < len_frame + len_next_high_rate + len_lpc0; i++) {
         ptr_usac_data->td_in_prev_buf[i_ch][i] =
             (FLOAT32)(ptr_usac_data->ptr_2frame_time_data[i_ch][i + td_buffer_offset - len_lpc0]);
       }
 
       if (ptr_usac_data->core_mode[i_ch] == CORE_MODE_FD) {
         ptr_usac_data->window_size_samples[i_ch] = ptr_usac_config->ccfl;
         pstr_sfb_prms->window_sequence[i_ch] = ptr_usac_data->block_switch_ctrl[i_ch].window_seq;
         ptr_usac_config->window_sequence[i_ch] = pstr_sfb_prms->window_sequence[i_ch];
         new_win_seq[i_ch] = ptr_usac_data->block_switch_ctrl[i_ch].next_win_seq;
       }
 
       err = iusace_sfb_params_init(ptr_usac_config->core_sample_rate, ptr_usac_config->ccfl,
                                    pstr_sfb_prms->sfb_width_table[i_ch],
                                    &pstr_sfb_prms->num_sfb[i_ch],
                                    pstr_sfb_prms->window_sequence[i_ch]);
 
       if (err) {
         return err;
       }
 
       pstr_sfb_prms->sfb_offset[i_ch][0] = 0;
       k = 0;
       for (i = 0; i < pstr_sfb_prms->num_sfb[i_ch]; i++) {
         pstr_sfb_prms->sfb_offset[i_ch][i] = k;
         k += pstr_sfb_prms->sfb_width_table[i_ch][i];
       }
       pstr_sfb_prms->sfb_offset[i_ch][i] = k;
 
       if (ptr_usac_data->core_mode[i_ch] != CORE_MODE_TD) {
         next_window_sequence[i_ch] = new_win_seq[i_ch];
         if (ptr_usac_data->core_mode_next[i_ch] == CORE_MODE_TD) {
           next_window_sequence[i_ch] = EIGHT_SHORT_SEQUENCE;
         }
 
         if (ptr_usac_data->core_mode[i_ch] == CORE_MODE_TD &&
             ptr_usac_data->core_mode_next[i_ch] != CORE_MODE_TD) {
           next_window_sequence[i_ch] = LONG_STOP_SEQUENCE;
         }
 
         if (next_window_sequence[i_ch] == EIGHT_SHORT_SEQUENCE) {
           if (pstr_sfb_prms->window_sequence[i_ch] == ONLY_LONG_SEQUENCE) {
             pstr_sfb_prms->window_sequence[i_ch] = LONG_START_SEQUENCE;
           }
           if (pstr_sfb_prms->window_sequence[i_ch] == LONG_STOP_SEQUENCE) {
             pstr_sfb_prms->window_sequence[i_ch] = STOP_START_SEQUENCE;
           }
         }
 
         if (next_window_sequence[i_ch] == ONLY_LONG_SEQUENCE) {
           if (pstr_sfb_prms->window_sequence[i_ch] == EIGHT_SHORT_SEQUENCE) {
             next_window_sequence[i_ch] = LONG_STOP_SEQUENCE;
           }
         }
 
         if (pstr_sfb_prms->window_sequence[i_ch] == EIGHT_SHORT_SEQUENCE) {
           num_window_groups[i_ch] = ptr_usac_data->block_switch_ctrl[i_ch].tot_grps_cnt;
           for (i = 0; i < 8; i++) {
             pstr_sfb_prms->window_group_length[i_ch][i] =
                 ptr_usac_data->block_switch_ctrl[i_ch].group_len[i];
           }
         } else {
           num_window_groups[i_ch] = 1;
           pstr_sfb_prms->window_group_length[i_ch][0] = 1;
         }
 
         pstr_sfb_prms->window_shape[i_ch] = ptr_usac_config->window_shape_prev[i_ch];
 
         err = iusace_fd_mdct(ptr_usac_data, ptr_usac_config, i_ch);
 
         if (err) {
           return err;
         }
 
         if (pstr_sfb_prms->window_sequence[i_ch] != EIGHT_SHORT_SEQUENCE) {
           iusace_psy_mod_lb(&ptr_usac_data->str_psy_mod, pstr_sfb_prms,
                             ptr_usac_data->spectral_line_vector[i_ch],
                             ptr_usac_data->pstr_tns_info, ptr_usac_config->tns_select, i_ch, chn,
                             ptr_usac_data->channel_elem_type[elem_idx],
                             pstr_scratch->p_tns_filter, elem_idx, pstr_scratch->ptr_tns_scratch,
                             ptr_usac_config->ccfl);
         } else {
           iusace_psy_mod_sb(&(ptr_usac_data->str_psy_mod), pstr_sfb_prms,
                             ptr_usac_data->spectral_line_vector[i_ch],
                             ptr_usac_data->pstr_tns_info, ptr_usac_config->tns_select, i_ch, chn,
                             ptr_usac_data->channel_elem_type[elem_idx],
                             pstr_scratch->p_tns_filter, elem_idx, pstr_scratch->ptr_tns_scratch,
                             ptr_usac_config->ccfl);
         }
 
         pstr_sfb_prms->max_sfb[i_ch] =
             ptr_usac_data->str_psy_mod.str_psy_out_data[i_ch].max_sfb_per_grp;
       }
     }
     for (chn = 0, i_ch = ch_offset; chn < nr_core_coder_channels; chn++, i_ch++) {
       if (nr_core_coder_channels == 2) {
         if ((pstr_sfb_prms->window_shape[i_ch] == pstr_sfb_prms->window_shape[i_ch + 1]) &&
             (pstr_sfb_prms->window_sequence[i_ch] == pstr_sfb_prms->window_sequence[i_ch + 1]) &&
             (ptr_usac_data->core_mode[i_ch] == ptr_usac_data->core_mode[i_ch + 1])) {
           common_win[i_ch] = common_win[i_ch + 1] = 1;
         } else {
           common_win[i_ch] = 0;
         }
         chn++;
       } else {
         common_win[i_ch] = 0;
       }
     }
     if (nr_core_coder_channels == 2) {
       if (i_ch == (ch_offset + 1)) {
         if (pstr_sfb_prms->window_sequence[i_ch] != EIGHT_SHORT_SEQUENCE) {
           iusace_calc_ms_band_energy(
               ptr_usac_data->spectral_line_vector[ch_offset],
               ptr_usac_data->spectral_line_vector[ch_offset + 1],
               ptr_usac_data->str_psy_mod.str_psy_long_config[elem_idx].sfb_offset,
               ptr_usac_data->str_psy_mod.str_psy_long_config[elem_idx].sfb_active,
               ptr_usac_data->str_psy_mod.str_psy_data[ch_offset].ptr_sfb_energy_long_ms,
               ptr_usac_data->str_psy_mod.str_psy_data[ch_offset + 1].ptr_sfb_energy_long_ms);
         } else {
           WORD32 frame_len_short = (ptr_usac_config->ccfl * FRAME_LEN_SHORT_128) / FRAME_LEN_LONG;
           for (WORD32 w = 0; w < MAX_SHORT_WINDOWS; w++) {
             WORD32 w_offset = w * frame_len_short;
 
             iusace_calc_ms_band_energy(
                 ptr_usac_data->spectral_line_vector[ch_offset] + w_offset,
                 ptr_usac_data->spectral_line_vector[ch_offset + 1] + w_offset,
                 ptr_usac_data->str_psy_mod.str_psy_short_config[elem_idx].sfb_offset,
                 ptr_usac_data->str_psy_mod.str_psy_short_config[elem_idx].sfb_active,
                 ptr_usac_data->str_psy_mod.str_psy_data[ch_offset].ptr_sfb_energy_short_ms[w],
                 ptr_usac_data->str_psy_mod.str_psy_data[ch_offset + 1]
                     .ptr_sfb_energy_short_ms[w]);
           }
         }
       }
     }
     if ((nr_core_coder_channels == 2)
             ? ((ptr_usac_data->core_mode[ch_offset] == CORE_MODE_FD) &&
                (ptr_usac_data->core_mode[ch_offset + 1] == CORE_MODE_FD))
             : ((ptr_usac_data->core_mode[ch_offset] == CORE_MODE_FD))) {
       iusace_grouping(pstr_sfb_prms, nr_core_coder_channels, ptr_usac_data, ptr_usac_config,
                       ch_offset, elem_idx);
 
       if (nr_core_coder_channels == 2) {
         err = iusace_stereo_proc(pstr_sfb_prms, usac_independency_flg, ptr_usac_data,
                                  ptr_usac_config, ch_offset);
         if (err != IA_NO_ERROR) {
           return err;
         }
       }
     }
 
     if (ptr_usac_config->use_drc_element) {
       WORD32 num_bits_ext_elem = 0;
       err = iusace_enc_ext_elemts(ID_EXT_ELE_UNI_DRC, ptr_usac_config, pstr_state, pstr_asc,
                                   pp_drc_inp, pstr_it_bit_buff, &num_bits_ext_elem);
       if (err & IA_FATAL_ERROR) {
         return err;
       }
       num_bits += num_bits_ext_elem;
 #ifdef DRC_BITRATE_CONSIDERATION
       ptr_usac_data->drc_data_bit_cnt = num_bits_ext_elem;
 #endif
     }
 
     for (chn = 0, i_ch = ch_offset; chn < nr_core_coder_channels; chn++, i_ch++) {
       iusace_write_bits_buf(pstr_it_bit_buff, ptr_usac_data->core_mode[i_ch], 1);
       num_bits++;
     }
 
     for (chn = 0, i_ch = ch_offset; chn < nr_core_coder_channels; chn++, i_ch++) {
       if (ptr_usac_data->core_mode[i_ch] == CORE_MODE_FD) {
         ptr_usac_data->window_size_samples[i_ch] = ptr_usac_config->ccfl;
         pstr_sfb_prms->window_sequence[i_ch] = ptr_usac_data->block_switch_ctrl[i_ch].window_seq;
         ptr_usac_config->window_sequence[i_ch] = pstr_sfb_prms->window_sequence[i_ch];
         new_win_seq[i_ch] = ptr_usac_data->block_switch_ctrl[i_ch].next_win_seq;
       }
 
       if (ptr_usac_data->core_mode[i_ch] == CORE_MODE_TD) {
         WORD32 error;
 
         error = iusace_lpd_frm_enc(ptr_usac_data, mod, usac_independency_flg, len_frame, i_ch,
                                    pstr_it_bit_buff);
         if (error) return error;
 
         num_bits = pstr_it_bit_buff->cnt_bits;
 
         if ((ptr_usac_data->core_mode_prev[i_ch] == CORE_MODE_FD) && (mod[0] == 0)) {
           for (i = 0; i < ptr_usac_data->num_td_fac_bits[i_ch]; i++) {
             iusace_write_bits_buf(pstr_it_bit_buff, ptr_usac_data->fac_out_stream[i_ch][i], 1);
             num_bits++;
           }
         }
       } else {
         next_window_sequence[i_ch] = new_win_seq[i_ch];
         if (ptr_usac_data->core_mode_next[i_ch] == CORE_MODE_TD) {
           next_window_sequence[i_ch] = EIGHT_SHORT_SEQUENCE;
         }
 
         if (ptr_usac_data->core_mode[i_ch] == CORE_MODE_TD &&
             ptr_usac_data->core_mode_next[i_ch] != CORE_MODE_TD) {
           next_window_sequence[i_ch] = LONG_STOP_SEQUENCE;
         }
 
         if (next_window_sequence[i_ch] == EIGHT_SHORT_SEQUENCE) {
           if (pstr_sfb_prms->window_sequence[i_ch] == ONLY_LONG_SEQUENCE) {
             pstr_sfb_prms->window_sequence[i_ch] = LONG_START_SEQUENCE;
           }
           if (pstr_sfb_prms->window_sequence[i_ch] == LONG_STOP_SEQUENCE) {
             pstr_sfb_prms->window_sequence[i_ch] = STOP_START_SEQUENCE;
           }
         }
         if (next_window_sequence[i_ch] == ONLY_LONG_SEQUENCE) {
           if (pstr_sfb_prms->window_sequence[i_ch] == EIGHT_SHORT_SEQUENCE) {
             next_window_sequence[i_ch] = LONG_STOP_SEQUENCE;
           }
         }
         if (pstr_sfb_prms->window_sequence[i_ch] == EIGHT_SHORT_SEQUENCE) {
           num_window_groups[i_ch] = ptr_usac_data->block_switch_ctrl[i_ch].tot_grps_cnt;
           for (i = 0; i < 8; i++) {
             pstr_sfb_prms->window_group_length[i_ch][i] =
                 ptr_usac_data->block_switch_ctrl[i_ch].group_len[i];
           }
         } else {
           num_window_groups[i_ch] = 1;
           pstr_sfb_prms->window_group_length[i_ch][0] = 1;
         }
         pstr_sfb_prms->window_shape[i_ch] = ptr_usac_config->window_shape_prev[i_ch];
       }
     }
 
     if ((nr_core_coder_channels == 2)
             ? ((ptr_usac_data->core_mode[ch_offset] == CORE_MODE_FD) &&
                (ptr_usac_data->core_mode[ch_offset + 1] == CORE_MODE_FD))
             : ((ptr_usac_data->core_mode[ch_offset] == CORE_MODE_FD))) {
       err = iusace_fd_encode(pstr_sfb_prms, usac_independency_flg, ptr_usac_data, ptr_usac_config,
                              pstr_it_bit_buff, nr_core_coder_channels, ch_offset, elem_idx,
-                             &bits_written, is_quant_spec_zero);
+                             &bits_written, is_quant_spec_zero, is_gain_limited);
 
       if (err) {
         return err;
       }
 
       num_bits += bits_written;
     }
 
     for (chn = 0, i_ch = ch_offset; chn < nr_core_coder_channels; chn++, i_ch++) {
       ptr_usac_config->window_shape_prev[i_ch] = pstr_sfb_prms->window_shape[i_ch];
       ptr_usac_config->window_sequence_prev[i_ch] = ptr_usac_config->window_sequence[i_ch];
       ptr_usac_config->window_sequence[i_ch] = next_window_sequence[i_ch];
       ptr_usac_data->core_mode_prev[i_ch] = ptr_usac_data->core_mode[i_ch];
       ptr_usac_data->core_mode[i_ch] = ptr_usac_data->core_mode_next[i_ch];
     }
     ch_offset += nr_core_coder_channels;
   }
 
   if (1 == ptr_usac_config->sbr_enable) {
     // Append SBR bits
     ixheaace_bit_buf_handle pstr_it_bit_buff_temp =
         &ptr_env_encoder->str_cmon_data.str_sbr_bit_buf;
     WORD32 check_num_bits = ia_enhaacplus_enc_get_bits_available(pstr_it_bit_buff_temp);
 
     num_bits += iexheaax_append_bitstream((ixheaace_bit_buf_handle)pstr_it_bit_buff,
                                           pstr_it_bit_buff_temp, check_num_bits);
   }
 
   if (ptr_usac_config->use_fill_element) {
     WORD32 full_elem_num_bits = 0;
     padding_bits = ptr_usac_data->min_bits_needed - num_bits;
     full_elem_num_bits = iusace_write_fill_ele(pstr_it_bit_buff, padding_bits);
     num_bits += full_elem_num_bits;
   }
 
   ptr_usac_data->available_bitreservoir_bits -= num_bits;
 
   if (num_bits % 8) {
     ptr_usac_data->available_bitreservoir_bits -= 8 - (num_bits % 8);
   }
   ptr_usac_data->available_bitreservoir_bits += average_bits_total;
 
   if (ptr_usac_data->available_bitreservoir_bits > ptr_usac_data->max_bitreservoir_bits) {
     ptr_usac_data->available_bitreservoir_bits = ptr_usac_data->max_bitreservoir_bits;
   }
 
   return 0;
 }
diff --git a/encoder/iusace_fd_enc.h b/encoder/iusace_fd_enc.h
index 2fa8b8d..9f8b00d 100644
--- a/encoder/iusace_fd_enc.h
+++ b/encoder/iusace_fd_enc.h
@@ -21,7 +21,7 @@
 #pragma once
 IA_ERRORCODE iusace_fd_encode(ia_sfb_params_struct *pstr_sfb_prms, WORD32 usac_independancy_flag,
                               ia_usac_data_struct *pstr_usac_data,
                               ia_usac_encoder_config_struct *pstr_usac_config,
                               ia_bit_buf_struct *pstr_it_bit_buff, WORD32 nr_core_coder_ch,
                               WORD32 chn, WORD32 ele_id, WORD32 *bit_written,
-                              WORD32 *is_quant_spec_zero);
+                              WORD32 *is_quant_spec_zero, WORD32* is_gain_limited);
diff --git a/encoder/iusace_main.h b/encoder/iusace_main.h
index f869ccb..dcacb14 100644
--- a/encoder/iusace_main.h
+++ b/encoder/iusace_main.h
@@ -110,8 +110,9 @@ IA_ERRORCODE iusace_enc_init(ia_usac_encoder_config_struct *ptr_usac_config,
 IA_ERRORCODE iusace_quantize_spec(ia_sfb_params_struct *pstr_sfb_prms,
                                   WORD32 usac_independancy_flag, WORD32 num_chans,
                                   ia_usac_data_struct *ptr_usac_data,
                                   ia_usac_encoder_config_struct *ptr_usac_config, WORD32 chn,
-                                  WORD32 ele_id, WORD32 *is_quant_spec_zero);
+                                  WORD32 ele_id, WORD32 *is_quant_spec_zero,
+                                  WORD32 *is_gain_limited);
 
 IA_ERRORCODE iusace_grouping(ia_sfb_params_struct *pstr_sfb_prms, WORD32 num_chans,
                              ia_usac_data_struct *ptr_usac_data,
diff --git a/encoder/ixheaace_aac_constants.h b/encoder/ixheaace_aac_constants.h
index 40e779a..8c96a2f 100644
--- a/encoder/ixheaace_aac_constants.h
+++ b/encoder/ixheaace_aac_constants.h
@@ -74,48 +74,49 @@ typedef struct {
 typedef struct {
   UWORD8 *data;       /* data bits */
   WORD32 num_bit;     /* number of bits in buffer */
   WORD32 size;        /* buffer size in bytes */
   WORD32 current_bit; /* current bit position in bit stream */
 } ixheaace_bitstream_params;
 
 /* bits in byte (char) */
 #define BYTE_NUMBIT 8
 #define BYTE_ALIGN_8 (8)
 #define EIGHT_BYTE_SIZE (8)
 #define IXHEAACE_GET_SIZE_ALIGNED(size, alignment) ((size + (alignment - 1)) & ~(alignment - 1))
 
 /* here we distinguish between stereo and the mono only encoder */
 #define IXHEAACE_MAX_CH_IN_BS_ELE (2)
 
 #define MAXIMUM_BS_ELE \
   8 /* 1 <SCE> 2 <CPE> 3<CPE> 4<CPE> 5<LFE> 6<SCE> - 8.1 channel + 2 cc channels*/
 
 #define FRAME_LEN_1024 1024
 #define FRAME_LEN_512 512
 #define FRAME_LEN_480 480
 #define FRAME_LEN_960 960
 
 #define AACENC_TRANS_FAC 8   /* encoder WORD16 long ratio */
 #define AACENC_PCM_LEVEL 1.0 /* encoder pcm 0db refernence */
 
 #define MAX_INPUT_CHAN (IXHEAACE_MAX_CH_IN_BS_ELE)
 
 #define MAX_FRAME_LEN (1024)
 
 /* channel masking*/
 #define CH_MASK_CENTER_FRONT (0x4)
 #define CH_MASK_LEFT_RIGHT_FRONT (0x3)
 #define CH_MASK_REAR_CENTER (0x100)
 #define CH_MASK_LEFT_RIGHT_BACK (0X30)
 #define CH_MASK_LFE (0x08)
 
 // Change to accommodate 4:1 resampler - input = 4096 samples per channel
 #define MAX_INPUT_SAMPLES (MAX_FRAME_LEN * MAX_INPUT_CHAN * 4)
 
 #define NUM_CHANS_MONO (1)
 #define NUM_CHANS_STEREO (2)
 #define MAX_NUM_CORE_CODER_CHANNELS (6)
 #define MIN_NUM_CORE_CODER_CHANNELS (1)
 /*-------------------------- defines --------------------------------------*/
 
-#define BUFFERSIZE 1024 /* anc data */
\ No newline at end of file
+#define BUFFERSIZE 1024 /* anc data */
+#define MAX_GAIN_INDEX (128)
\ No newline at end of file
diff --git a/encoder/ixheaace_api.c b/encoder/ixheaace_api.c
index 67088a9..cde050a 100644
--- a/encoder/ixheaace_api.c
+++ b/encoder/ixheaace_api.c
@@ -2409,909 +2409,911 @@ static IA_ERRORCODE ia_enhaacplus_enc_init(ixheaace_api_struct *pstr_api_struct,
 static IA_ERRORCODE ia_enhaacplus_enc_execute(ixheaace_api_struct *pstr_api_struct,
                                               WORD32 ele_idx) {
   IA_ERRORCODE error = IA_NO_ERROR;
   WORD32 downsample;
   WORD32 aot;
   WORD32 idx;
   WORD32 header_bytes = 0;
   WORD32 num_samples_read;
   WORD32 env_read_offset = 0;
   WORD32 write_off_set = 0;
   WORD32 aacenc_blocksize;
   WORD32 ch, out_samples;
   WORD32 total_channels = 0, ele, slot;
   WORD32 time_in_stride;
   WORD32 num_bs_elements;
   FLAG flag_last_element;
   WORD32 i_num_coup_channels;
   WORD32 i_channels_mask;
   ixheaace_pstr_sbr_enc pstr_sbr_encoder = NULL;
   iexheaac_encoder_str **pstr_aac_enc;
   iaace_config *pstr_aac_config;
   pWORD16 pw_inp_buf = NULL;
   pUWORD8 pub_out_buf = NULL;
   FLOAT32 *ptr_input_buffer = NULL;
   FLOAT32 *ptr_input_buffer_mps = NULL;
   FLOAT32 *shared_buf1_ring, *shared_buf2_ring;
   WORD32 out_stride = IXHEAACE_MAX_CH_IN_BS_ELE;
   WORD32 *pstr_aac_scratch = (pWORD32)pstr_api_struct->pp_mem[IA_ENHAACPLUSENC_SCRATCH_IDX];
   WORD8 *ptr_spectral_band_replication_scratch =
       ((pWORD8)pstr_aac_scratch) + ia_enhaacplus_enc_aac_enc_scr_size();
   WORD32 *total_fill_bits = &(pstr_api_struct->pstr_state->total_fill_bits);
   WORD32 *write_program_config_element =
       &(pstr_api_struct->config[0].write_program_config_element);
 
   aot = pstr_api_struct->pstr_state->aot;
   num_bs_elements = pstr_api_struct->config[0].num_bs_elements;
   flag_last_element = (ele_idx == (num_bs_elements - 1));
   i_num_coup_channels = pstr_api_struct->config[0].i_num_coupling_chan;
   i_channels_mask = pstr_api_struct->config[0].i_channels_mask;
   aacenc_blocksize = pstr_api_struct->config[0].frame_length;
   downsample = pstr_api_struct->pstr_state->downsample[ele_idx];
   num_samples_read =
       aacenc_blocksize * pstr_api_struct->config[ele_idx].i_native_channels * (1 << downsample);
   for (ele = 0; ele < num_bs_elements; ele++) {
     total_channels += pstr_api_struct->config[ele].i_native_channels;
   }
   pstr_aac_config = &(pstr_api_struct->config[ele_idx].aac_config);
   if ((pstr_api_struct->config[ele_idx].aac_classic == 0) &&
       pstr_api_struct->config[ele_idx].use_parametric_stereo) {
     time_in_stride = 1;
   } else if ((pstr_api_struct->config[ele_idx].aac_classic == 1) &&
              (pstr_api_struct->config[ele_idx].num_bs_elements == 1)) {
     time_in_stride = pstr_aac_config->num_out_channels;
   } else {
     time_in_stride = IXHEAACE_MAX_CH_IN_BS_ELE;
   }
   pstr_aac_enc = pstr_api_struct->pstr_state->aac_enc_pers_mem;
 
   pw_inp_buf = (pWORD16)pstr_api_struct->pp_mem[IA_ENHAACPLUSENC_INPUT_IDX];
   if (ele_idx == 0) {
     pstr_api_struct->pstr_state->i_out_bytes = 0;
     pub_out_buf = ((pUWORD8)pstr_api_struct->pp_mem[IA_ENHAACPLUSENC_OUTPUT_IDX]);
     *total_fill_bits = 0;
   }
 
   if (pstr_api_struct->config->adts_flag) {
     pub_out_buf = (pUWORD8)(pub_out_buf + 7);
   }
 
   for (ch = 0; ch < IXHEAACE_MAX_CH_IN_BS_ELE; ch++)
     pstr_api_struct->pstr_state->num_anc_data_bytes[ele_idx][ch] = 0;
 
   if (aot == AOT_SBR || aot == AOT_PS) {
     write_off_set = INPUT_DELAY_LC * IXHEAACE_MAX_CH_IN_BS_ELE;
   } else if (aot == AOT_AAC_ELD && pstr_api_struct->pstr_state->mps_enable != 1) {
     if (pstr_api_struct->config[0].aac_config.flag_framelength_small)
       write_off_set = INPUT_DELAY_ELD_480 * IXHEAACE_MAX_CH_IN_BS_ELE;
     else
       write_off_set = INPUT_DELAY_ELD_512 * IXHEAACE_MAX_CH_IN_BS_ELE;
   } else if (aot == AOT_AAC_ELD && pstr_api_struct->pstr_state->mps_enable == 1 &&
              pstr_api_struct->pstr_state->mps_tree_config == TREE_212) {
     if (pstr_api_struct->config[0].aac_config.flag_framelength_small)
       write_off_set = INPUT_DELAY_ELDV2_480 * IXHEAACE_MAX_CH_IN_BS_ELE;
     else
       write_off_set = INPUT_DELAY_ELDV2_512 * IXHEAACE_MAX_CH_IN_BS_ELE;
   } else if (aot == AOT_AAC_ELD && pstr_api_struct->pstr_state->mps_enable == 1 &&
              pstr_api_struct->pstr_state->mps_tree_config != TREE_212) {
     write_off_set = INPUT_DELAY_ELD_512_MPS * IXHEAACE_MAX_CH_IN_BS_ELE;
   }
   if (pstr_api_struct->config[ele_idx].aac_classic == 1) {
     write_off_set = 0;
   }
   if (aot == AOT_AAC_ELD && pstr_api_struct->pstr_state->mps_enable == 1) {
     if (pstr_api_struct->pstr_state->mps_tree_config == TREE_212) {
       env_read_offset = INPUT_DELAY_ELD_512_MPS;
     } else {
       env_read_offset = write_off_set;
     }
   }
   if (pstr_api_struct->pstr_state->downsample[ele_idx]) {
     if (!pstr_api_struct->config[ele_idx].use_parametric_stereo) {
       if (aot == AOT_AAC_ELD && pstr_api_struct->pstr_state->mps_enable != 1) {
         write_off_set +=
             4 * IXHEAACE_MAX_CH_IN_BS_ELE;  // Downsampler delay = 4 samples per channel @input SR
       } else {
         write_off_set += (pstr_api_struct->pstr_state->down_sampler[ele_idx][0].delay) *
                          IXHEAACE_MAX_CH_IN_BS_ELE;
       }
     }
     if (pstr_api_struct->config[ele_idx].use_parametric_stereo) {
       env_read_offset = (MAXIMUM_DS_2_1_FILTER_DELAY + INPUT_DELAY) * IXHEAACE_MAX_CH_IN_BS_ELE;
       write_off_set = env_read_offset;
     }
   }
 
   if (aot == AOT_AAC_LC || aot == AOT_SBR || aot == AOT_PS) {
     ptr_input_buffer = pstr_api_struct->pstr_state->inp_delay +
                        (aacenc_blocksize * 2 + MAXIMUM_DS_2_1_FILTER_DELAY + INPUT_DELAY_LC) *
                            IXHEAACE_MAX_CH_IN_BS_ELE * ele_idx;
   } else if (aot == AOT_AAC_LD) {
     if (pstr_api_struct->config[0].aac_config.flag_framelength_small) {
       ptr_input_buffer = pstr_api_struct->pstr_state->inp_delay +
                          (FRAME_LEN_480 * 2 + MAXIMUM_DS_2_1_FILTER_DELAY + INPUT_DELAY_LD_480) *
                              IXHEAACE_MAX_CH_IN_BS_ELE * ele_idx;
     } else {
       ptr_input_buffer = pstr_api_struct->pstr_state->inp_delay +
                          (FRAME_LEN_512 * 2 + MAXIMUM_DS_2_1_FILTER_DELAY + INPUT_DELAY_LD_512) *
                              IXHEAACE_MAX_CH_IN_BS_ELE * ele_idx;
     }
   } else if (aot == AOT_AAC_ELD) {
     if (pstr_api_struct->config[0].aac_config.flag_framelength_small) {
       if (pstr_api_struct->pstr_state->mps_enable == 1) {
         ptr_input_buffer =
             pstr_api_struct->pstr_state->inp_delay +
             (FRAME_LEN_480 * 2 + MAXIMUM_DS_2_1_FILTER_DELAY + INPUT_DELAY_ELDV2_480) *
                 IXHEAACE_MAX_CH_IN_BS_ELE * ele_idx;
       } else {
         ptr_input_buffer =
             pstr_api_struct->pstr_state->inp_delay +
             (FRAME_LEN_480 * 2 + MAXIMUM_DS_2_1_FILTER_DELAY + INPUT_DELAY_ELD_480) *
                 IXHEAACE_MAX_CH_IN_BS_ELE * ele_idx;
       }
     } else {
       if (pstr_api_struct->pstr_state->mps_enable == 1) {
         ptr_input_buffer =
             pstr_api_struct->pstr_state->inp_delay +
             (FRAME_LEN_512 * 2 + MAXIMUM_DS_2_1_FILTER_DELAY + INPUT_DELAY_ELDV2_512) *
                 IXHEAACE_MAX_CH_IN_BS_ELE * ele_idx;
       } else {
         ptr_input_buffer =
             pstr_api_struct->pstr_state->inp_delay +
             (FRAME_LEN_512 * 2 + MAXIMUM_DS_2_1_FILTER_DELAY + INPUT_DELAY_ELD_512) *
                 IXHEAACE_MAX_CH_IN_BS_ELE * ele_idx;
       }
     }
   } else {
     return IA_EXHEAACE_EXE_FATAL_UNSUPPORTED_AOT;
   }
 
   if (aot != AOT_AAC_LD && aot != AOT_AAC_LC) {
     pstr_sbr_encoder =
         pstr_api_struct->pstr_state->spectral_band_replication_enc_pers_mem[ele_idx];
     if (pstr_api_struct->config[ele_idx].element_type != ID_LFE) {
       ixheaace_sbr_set_scratch_ptr(pstr_sbr_encoder, ptr_spectral_band_replication_scratch);
     }
   }
 
   {
     ixheaace_mps_enc_ext_payload mps_extension_payload;
     UWORD8 *mps_bs = pstr_api_struct->pstr_state->mps_bs;
     memset(&mps_extension_payload, 0, sizeof(ixheaace_mps_enc_ext_payload));
     mps_extension_payload.p_data = mps_bs;
 
     if ((pstr_api_struct->config[ele_idx].num_bs_elements == 1) &&
         (pstr_api_struct->config[ele_idx].i_channels <= 2)) {
       if (pstr_api_struct->config[ele_idx].aac_classic != 1) {
         if ((pstr_api_struct->config[ele_idx].i_channels == 2 &&
              pstr_api_struct->config[ele_idx].chmode_nchannels == 2) &&
             (!((pstr_api_struct->pstr_mps_212_enc != NULL) &&
                pstr_api_struct->pstr_state->mps_enable))) {
           for (idx = 0; idx < (num_samples_read); idx++) {
             ptr_input_buffer[write_off_set + idx] = (FLOAT32)pw_inp_buf[idx];
           }
         } else if (pstr_api_struct->config[ele_idx].i_channels == 1) {
           for (idx = 0; idx < num_samples_read; idx++) {
             ptr_input_buffer[write_off_set + (IXHEAACE_MAX_CH_IN_BS_ELE * idx)] =
                 (FLOAT32)pw_inp_buf[idx];
           }
         } else if ((pstr_api_struct->pstr_mps_212_enc != NULL) &&
                    pstr_api_struct->pstr_state->mps_enable) {
           ptr_input_buffer_mps = pstr_api_struct->pstr_state->time_signal_mps;
           for (idx = 0; idx < (num_samples_read / 2); idx++) {
             ptr_input_buffer_mps[idx] = (FLOAT32)pw_inp_buf[2 * idx];
             ptr_input_buffer_mps[(num_samples_read / 2) + idx] =
                 (FLOAT32)pw_inp_buf[(2 * idx) + 1];
           }
         }
       } else {
         for (idx = 0; idx < (num_samples_read + write_off_set); idx++) {
           ptr_input_buffer[idx] = (FLOAT32)pw_inp_buf[idx];
         }
       }
     } else {
       if (pstr_api_struct->config[ele_idx].i_channels == 2) {
         slot = pstr_api_struct->config[ele_idx].element_slot;
         for (idx = 0; idx < num_samples_read / 2; idx++) {
           ptr_input_buffer[2 * idx + write_off_set] =
               (FLOAT32)pw_inp_buf[total_channels * idx + slot];
           ptr_input_buffer[2 * idx + write_off_set + 1] =
               (FLOAT32)pw_inp_buf[total_channels * idx + slot + 1];
         }
       }
 
       if (pstr_api_struct->config[ele_idx].i_channels == 1) {
         slot = pstr_api_struct->config[ele_idx].element_slot;
         for (idx = 0; idx < num_samples_read; idx++) {
           ptr_input_buffer[write_off_set + (IXHEAACE_MAX_CH_IN_BS_ELE * idx)] =
               (FLOAT32)pw_inp_buf[total_channels * idx + slot];
         }
       }
 
       if (pstr_api_struct->config[ele_idx].i_channels == 6) {
         ptr_input_buffer_mps = pstr_api_struct->pstr_state->time_signal_mps;
         for (idx = 0; idx < num_samples_read; idx++) {
           ptr_input_buffer_mps[idx] = (FLOAT32)pw_inp_buf[idx];
         }
       }
     }
 
     if ((pstr_api_struct->pstr_mps_212_enc != NULL) && pstr_api_struct->pstr_state->mps_enable) {
       ptr_input_buffer_mps = pstr_api_struct->pstr_state->time_signal_mps;
       error = ixheaace_mps_212_process(pstr_api_struct->pstr_mps_212_enc, ptr_input_buffer_mps,
                                        num_samples_read, &mps_extension_payload);
       if (error) {
         return error;
       }
       num_samples_read /= 2;
       for (idx = 0; idx < num_samples_read; idx++) {
         ptr_input_buffer[2 * idx + write_off_set] = (FLOAT32)ptr_input_buffer_mps[idx];
       }
       env_read_offset = write_off_set;
     }
     if ((pstr_api_struct->pstr_mps_515_enc != NULL) && pstr_api_struct->pstr_state->mps_enable) {
       ixheaace_bit_buf bit_buf;
       ixheaace_bit_buf_handle ptr_bit_buf = NULL;
       FLOAT32 *ptr_downmix_buffer_mps = pstr_api_struct->pstr_state->mps_scratch;
       VOID *ptr_scratch_515_mps = (VOID *)(pstr_api_struct->pstr_state->mps_scratch +
                                            (MAX_INPUT_CHANNELS * MAX_BUFFER_SIZE) +
                                            (MAX_OUTPUT_CHANNELS * MAX_BUFFER_SIZE));
       ptr_bit_buf = ia_enhaacplus_enc_create_bitbuffer(&bit_buf, mps_bs, MAX_MPS_BS_PAYLOAD_SIZE);
 
       error =
           ixheaace_mps_515_apply(pstr_api_struct->pstr_mps_515_enc, &ptr_input_buffer_mps[0],
                                  &ptr_downmix_buffer_mps[0], ptr_bit_buf, ptr_scratch_515_mps);
       if (error) {
         return error;
       }
       mps_extension_payload.data_size = ptr_bit_buf->cnt_bits;
       mps_extension_payload.data_type = IXHEAACE_MPS_EXT_LDSAC_DATA;
       mps_extension_payload.associated_ch_element = -1;
 
       if (pstr_api_struct->pstr_state->mps_tree_config == TREE_5151 ||
           pstr_api_struct->pstr_state->mps_tree_config == TREE_5152) {
         num_samples_read /= 6;
         for (idx = 0; idx < num_samples_read; idx++) {
           ptr_input_buffer[2 * idx + write_off_set] = (FLOAT32)ptr_downmix_buffer_mps[idx];
         }
       } else {
         num_samples_read /= 3;
         for (idx = 0; idx < num_samples_read; idx++) {
           ptr_input_buffer[idx + write_off_set] = (FLOAT32)ptr_downmix_buffer_mps[idx];
         }
       }
       env_read_offset = write_off_set;
     }
 
     if (pstr_api_struct->pstr_state->downsample[ele_idx]) {
       ixheaace_resampler_scratch *pstr_scratch_resampler =
           (ixheaace_resampler_scratch *)pstr_api_struct->pstr_state->ptr_temp_buff_resamp;
 
       if (pstr_api_struct->config[ele_idx].element_type != ID_LFE) {
         error = ixheaace_env_encode_frame(
             pstr_sbr_encoder, ptr_input_buffer + env_read_offset, ptr_input_buffer,
             IXHEAACE_MAX_CH_IN_BS_ELE,
             &(pstr_api_struct->pstr_state->num_anc_data_bytes[ele_idx][0]),
             pstr_api_struct->pstr_state->anc_data_bytes[ele_idx],
             &(pstr_api_struct->spectral_band_replication_tabs), &(pstr_api_struct->common_tabs),
             &(mps_extension_payload.p_data[0]), mps_extension_payload.data_size,
             pstr_api_struct->config[0].aac_config.flag_framelength_small, NULL);
 
         if (error != IA_NO_ERROR) {
           return error;
         }
       }
 
       if (!pstr_api_struct->config[ele_idx].use_parametric_stereo) {
         for (ch = 0; ch < pstr_aac_config->num_out_channels; ch++) {
           ia_enhaacplus_enc_get_scratch_bufs(pstr_api_struct->pstr_state->temp_buff_sbr,
                                              &shared_buf1_ring, &shared_buf2_ring);
           {
             ia_enhaacplus_enc_iir_downsampler(
                 &(pstr_api_struct->pstr_state->down_sampler[ele_idx][ch]),
                 ptr_input_buffer + write_off_set + ch,
                 num_samples_read / pstr_aac_config->num_out_channels, IXHEAACE_MAX_CH_IN_BS_ELE,
                 ptr_input_buffer + ch, &out_samples, out_stride, shared_buf1_ring,
                 shared_buf2_ring, pstr_scratch_resampler);
           }
         }
       }
     }
 
     error = ia_enhaacplus_enc_aac_core_encode(
         pstr_aac_enc, ptr_input_buffer, time_in_stride,
         pstr_api_struct->pstr_state->anc_data_bytes[ele_idx],
         pstr_api_struct->pstr_state->num_anc_data_bytes[ele_idx], pub_out_buf,
         &(pstr_api_struct->pstr_state->i_out_bytes), &(pstr_api_struct->pstr_aac_tabs),
         pstr_api_struct->pstr_state->pstr_bit_stream_handle,
         &(pstr_api_struct->pstr_state->bit_stream), flag_last_element,
         write_program_config_element, i_num_coup_channels, i_channels_mask, ele_idx,
         total_fill_bits, total_channels, aot, pstr_api_struct->config->adts_flag,
-        num_bs_elements, &pstr_api_struct->pstr_state->is_quant_spec_zero);
+        num_bs_elements, &pstr_api_struct->pstr_state->is_quant_spec_zero,
+        &pstr_api_struct->pstr_state->is_gain_limited);
     if (error != IA_NO_ERROR) {
       return error;
     }
     if (pstr_sbr_encoder && !(pstr_api_struct->config[ele_idx].use_parametric_stereo)) {
       if (pstr_sbr_encoder && (ptr_input_buffer != NULL)) {
         memmove(ptr_input_buffer,
                 ptr_input_buffer + aacenc_blocksize * 2 * IXHEAACE_MAX_CH_IN_BS_ELE,
                 write_off_set * sizeof(ptr_input_buffer[0]));
       }
     }
   }
   {}
   /*ADTS Header Write*/
   if (pstr_api_struct->config->adts_flag) {
     pub_out_buf = ((pUWORD8)pstr_api_struct->pp_mem[IA_ENHAACPLUSENC_OUTPUT_IDX]);
     {
       WORD32 num_channels = 0;
 
       for (ele = 0; ele < pstr_api_struct->config[0].num_bs_elements; ele++) {
         num_channels += pstr_api_struct->config[ele].i_channels;
       }
       {
         header_bytes = ia_enhaacplus_enc_write_ADTS_header(
             pub_out_buf, pstr_api_struct->pstr_state->i_out_bytes,
             pstr_api_struct->config->aac_config.core_sample_rate,
             (pstr_api_struct->config[0].num_bs_elements > 1)
                 ? num_channels
                 : pstr_api_struct->config[0].aac_config.num_out_channels);
       }
     }
 
     pstr_api_struct->pstr_state->i_out_bytes += header_bytes;
   }
 
   return IA_NO_ERROR;
 }
 static IA_ERRORCODE iusace_process(ixheaace_api_struct *pstr_api_struct) {
   IA_ERRORCODE error = IA_NO_ERROR;
   WORD32 idx;
 #ifdef ENABLE_SET_JUMP
   jmp_buf api_execute_jmp_buf;
   error = setjmp(api_execute_jmp_buf);
   if (error != IA_NO_ERROR) {
     return IA_EXHEAACE_EXE_NONFATAL_USAC_INSUFFICIENT_WRITE_BUFFER_SIZE;
   }
 #endif  // ENABLE_SET_JUMP
 
   WORD32 write_off_set = 0;
   WORD32 core_coder_frame_length;
   WORD32 usac_independency_flg;
   UWORD32 padding_bits = 0;
   WORD32 core_sample;
   WORD32 drc_sample;
   WORD32 i4_inp_data;
   WORD32 ptr_inp_buf_offset = 0;
   WORD32 num_ch;
   WORD16 *ps_inp_buf = NULL;
   WORD8 *pi1_inp_buf = NULL;
   WORD8 *ps_out_buf = NULL;
   WORD32 *pi4_inp_buf = NULL;
   FLOAT32 *ptr_input_buffer = NULL;
   FLOAT32 *ptr_inp_buf[MAX_TIME_CHANNELS];
   FLOAT32 *ptr_drc_inp_buf[MAX_TIME_CHANNELS];
   ixheaace_state_struct *pstr_state = pstr_api_struct->pstr_state;
   ia_bit_buf_struct *pstr_it_bit_buff = &pstr_state->str_bit_buf;
   ia_usac_encoder_config_struct *pstr_config = &pstr_api_struct->config[0].usac_config;
   ia_usac_data_struct *pstr_usac_data = &pstr_api_struct->pstr_state->str_usac_enc_data;
   iusace_scratch_mem *pstr_scratch = &pstr_usac_data->str_scratch;
   ia_classification_struct *pstr_sig_class_data =
       &pstr_state->str_usac_enc_data.str_sig_class_data;
   core_sample = (pstr_config->ccfl * pstr_config->channels);
   drc_sample = pstr_config->drc_frame_size * pstr_config->channels;
   core_coder_frame_length = pstr_config->ccfl;
   num_ch = pstr_config->channels;
   usac_independency_flg = !(pstr_usac_data->usac_independency_flag_count %
                             pstr_usac_data->usac_independency_flag_interval);
   pstr_usac_data->usac_independency_flag = usac_independency_flg;
   ps_inp_buf = (WORD16 *)pstr_api_struct->pp_mem[IA_MEMTYPE_INPUT];
   pi1_inp_buf = (WORD8 *)pstr_api_struct->pp_mem[IA_MEMTYPE_INPUT];
   ps_out_buf = (WORD8 *)pstr_api_struct->pp_mem[IA_MEMTYPE_OUTPUT];
 
   if (pstr_config->use_drc_element) {
     for (idx = 0; idx < core_sample; idx++) {
       pstr_api_struct->pstr_state->pp_drc_in_buf[idx % num_ch][idx / num_ch] =
           pstr_api_struct->pstr_state
               ->pp_drc_in_buf[idx % num_ch][idx / num_ch + pstr_config->drc_frame_size];
     }
     ptr_inp_buf_offset = pstr_config->drc_frame_size;
     for (idx = 0; idx < num_ch; idx++) {
       ptr_drc_inp_buf[idx] = pstr_api_struct->pstr_state->pp_drc_in_buf[idx];
     }
   }
 
   ixheaace_pstr_sbr_enc pstr_sbr_encoder =
       pstr_api_struct->pstr_state->spectral_band_replication_enc_pers_mem[0];
   if (pstr_config->sbr_enable) {
     ixheaace_mps_enc_ext_payload mps_extension_payload;
     UWORD8 *mps_bs = pstr_api_struct->pstr_state->mps_bs;
     FLOAT32 *time_signal_mps = pstr_api_struct->pstr_state->time_signal_mps;
     WORD32 sbr_pvc_mode = 0;
     WORD32 sbr_patching_mode = 1;
     WORD32 ccfl_size;
     WORD32 num_samples_read;
     WORD32 out_samples, ch;
     WORD32 resamp_ratio =
         ia_enhaacplus_enc_compute_resampling_ratio(pstr_api_struct->config[0].ccfl_idx);
     switch (pstr_config->codec_mode) {
       case USAC_SWITCHED:
         if (pstr_usac_data->str_sig_class_data.coding_mode == 2) {
           sbr_pvc_mode = 0;
         } else {
           sbr_pvc_mode = 2;
         }
         sbr_patching_mode = 1;
         break;
       case USAC_ONLY_FD:
         sbr_pvc_mode = 0;
         sbr_patching_mode = 0;
         break;
       case USAC_ONLY_TD:
         sbr_pvc_mode = 2;
         sbr_patching_mode = 1;
         break;
     }
 
     write_off_set = INPUT_DELAY_LC * IXHEAACE_MAX_CH_IN_BS_ELE;
     if (pstr_api_struct->pstr_state->downsample[0]) {
       if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {
         write_off_set +=
             (pstr_api_struct->pstr_state->down_samp_sos[0][0].delay) * IXHEAACE_MAX_CH_IN_BS_ELE;
 
         write_off_set +=
             (pstr_api_struct->pstr_state->up_sampler[0][0].delay) * IXHEAACE_MAX_CH_IN_BS_ELE;
       } else if (pstr_api_struct->config[0].ccfl_idx == SBR_2_1 ||
                  pstr_api_struct->config[0].ccfl_idx == SBR_4_1) {
         write_off_set +=
             (pstr_api_struct->pstr_state->down_sampler[0][0].delay) * IXHEAACE_MAX_CH_IN_BS_ELE;
       }
     }
 
     ptr_input_buffer = pstr_api_struct->pstr_state->inp_delay;
     ccfl_size = pstr_api_struct->config[0].usac_config.ccfl;
     num_samples_read = ccfl_size * pstr_api_struct->config[0].i_channels;
     switch (pstr_api_struct->config[0].ccfl_idx) {
       case SBR_8_3:
         num_samples_read *= 8;
         num_samples_read /= 3;
         break;
 
       case SBR_2_1:
         num_samples_read *= 2;
         break;
 
       case SBR_4_1:
         num_samples_read *= 4;
         break;
     }
 
     mps_extension_payload.p_data = mps_bs;
     memset(&mps_extension_payload, 0, sizeof(ixheaace_mps_enc_ext_payload));
 
     if ((pstr_api_struct->pstr_mps_212_enc != NULL) && pstr_api_struct->pstr_state->mps_enable) {
       for (idx = 0; idx < num_samples_read / 2; idx++) {
         time_signal_mps[idx] = (FLOAT32)ps_inp_buf[2 * idx];
         time_signal_mps[num_samples_read / 2 + idx] = (FLOAT32)ps_inp_buf[2 * idx + 1];
       }
       error = ixheaace_mps_212_process(pstr_api_struct->pstr_mps_212_enc, time_signal_mps,
                                        num_samples_read, &mps_extension_payload);
       if (error) {
         return error;
       }
       if (pstr_api_struct->pstr_state->mps_enable == 1) {
         for (idx = 0; idx < num_samples_read / 2; idx++) {
           ptr_input_buffer[write_off_set + 2 * idx] = time_signal_mps[idx];
           ptr_input_buffer[write_off_set + 2 * idx + 1] =
               time_signal_mps[num_samples_read / 2 + idx];
         }
       }
     } else if (pstr_api_struct->config[0].i_channels == 2 &&
                pstr_api_struct->config[0].chmode_nchannels == 2) {
       for (idx = 0; idx < (num_samples_read); idx++) {
         ptr_input_buffer[write_off_set + idx] = (FLOAT32)ps_inp_buf[idx];
       }
     } else if (pstr_api_struct->config[0].i_channels == 1) {
       for (idx = 0; idx < num_samples_read; idx++) {
         ptr_input_buffer[write_off_set + (IXHEAACE_MAX_CH_IN_BS_ELE * idx)] =
             (FLOAT32)ps_inp_buf[idx];
       }
     }
 
     if (num_ch == 2) {
       if (1 == pstr_config->use_drc_element) {
         if (16 == pstr_config->ui_pcm_wd_sz) {
           for (idx = 0; idx < drc_sample; idx++) {
             ptr_drc_inp_buf[idx % num_ch][idx / num_ch + ptr_inp_buf_offset] =
                 ptr_input_buffer[idx];
           }
         } else if (24 == pstr_config->ui_pcm_wd_sz) {
           for (idx = 0; idx < drc_sample; idx++) {
             i4_inp_data = ((WORD32)(*pi1_inp_buf)) & 0xFF;
             pi1_inp_buf++;
             i4_inp_data += ((WORD32)(*pi1_inp_buf) << 8) & 0xFFFF;
             pi1_inp_buf++;
             i4_inp_data += ((WORD32)(*pi1_inp_buf) << 16) & 0xFFFFFF;
             pi1_inp_buf++;
             i4_inp_data = i4_inp_data - (i4_inp_data >> 23 << 24);
             ptr_drc_inp_buf[idx % num_ch][idx / num_ch + ptr_inp_buf_offset] =
                 (FLOAT32)i4_inp_data / DIV_FAC_24_BIT_PCM;
           }
         } else if (32 == pstr_config->ui_pcm_wd_sz) {
           pi4_inp_buf = (WORD32 *)pi1_inp_buf;
           for (idx = 0; idx < drc_sample; idx++) {
             i4_inp_data = *pi4_inp_buf++;
             ptr_drc_inp_buf[idx % num_ch][idx / num_ch + ptr_inp_buf_offset] =
                 (FLOAT32)i4_inp_data / DIV_FAC_32_BIT_PCM;
           }
         }
       }
 
       // update Header and bit-stream parameters
       if (0 == pstr_config->sbr_pvc_active) {
         sbr_pvc_mode = 0;
       }
 
       ixheaace_set_usac_sbr_params(
           pstr_sbr_encoder, usac_independency_flg, 0, pstr_config->sbr_pvc_active, sbr_pvc_mode,
           pstr_config->sbr_inter_tes_active, pstr_config->sbr_harmonic, sbr_patching_mode);
 
       // Downsample SBR input buffer for Harmonic SBR
       if (pstr_config->sbr_harmonic) {
         FLOAT32 *in_buffer_temp;
         ixheaace_get_input_scratch_buf(pstr_api_struct->pstr_state->ptr_temp_buff_resamp,
                                        &in_buffer_temp);
         FLOAT32 *outbuf = ixheaace_get_hbe_resample_buffer(pstr_sbr_encoder);
         if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {
           WORD32 input_tot = num_samples_read / pstr_api_struct->config[0].i_channels;
           ixheaace_upsampling_inp_buf_generation(ptr_input_buffer, in_buffer_temp, input_tot,
                                                  UPSAMPLE_FAC, 0);
         }
 
         // Resampler
         for (ch = 0; ch < num_ch; ch++) {
           FLOAT32 *shared_buf1_ring, *shared_buf2_ring;
           ixheaace_resampler_scratch *pstr_scratch_resampler =
               (ixheaace_resampler_scratch *)(ixheaace_resampler_scratch *)
                   pstr_api_struct->pstr_state->ptr_temp_buff_resamp;
 
           ia_enhaacplus_enc_get_scratch_bufs(pstr_api_struct->pstr_state->temp_buff_sbr,
                                              &shared_buf1_ring, &shared_buf2_ring);
 
           if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {
             // Upsampling by factor 3 - SOS implementation
             ia_enhaacplus_enc_iir_sos_upsampler(
                 &(pstr_api_struct->pstr_state->hbe_up_sampler[0][ch]), in_buffer_temp + ch,
                 num_samples_read / pstr_api_struct->config[0].i_channels,
                 IXHEAACE_MAX_CH_IN_BS_ELE, in_buffer_temp + ch, &out_samples, shared_buf1_ring,
                 shared_buf2_ring, pstr_scratch_resampler);
 
             // Downsampling by factor 8
             ia_enhaacplus_enc_iir_sos_downsampler(
                 &(pstr_api_struct->pstr_state->hbe_down_samp_sos[0][ch]), in_buffer_temp + ch,
                 out_samples, IXHEAACE_MAX_CH_IN_BS_ELE, outbuf + ch, &out_samples,
                 shared_buf1_ring, shared_buf2_ring, pstr_scratch_resampler);
           } else {
             WORD32 out_stride = IXHEAACE_MAX_CH_IN_BS_ELE * resamp_ratio;
 
             ia_enhaacplus_enc_iir_downsampler(
                 &(pstr_api_struct->pstr_state->hbe_down_sampler[0][ch]), ptr_input_buffer + ch,
                 num_samples_read / pstr_api_struct->config[0].i_channels,
                 IXHEAACE_MAX_CH_IN_BS_ELE, outbuf + ch, &out_samples, out_stride,
                 shared_buf1_ring, shared_buf2_ring, pstr_scratch_resampler);
           }
         }
       }
 
       // SBR Encode
       error = ixheaace_env_encode_frame(
           pstr_sbr_encoder, ptr_input_buffer, ptr_input_buffer,
           pstr_api_struct->config[0].i_channels,
           &(pstr_api_struct->pstr_state->num_anc_data_bytes[0][0]),
           pstr_api_struct->pstr_state->anc_data_bytes[0],
           &(pstr_api_struct->spectral_band_replication_tabs), &(pstr_api_struct->common_tabs),
           &(mps_extension_payload.p_data[0]), mps_extension_payload.data_size, 0,
           &pstr_api_struct->pstr_state->str_usac_enc_data.num_sbr_bits);
       if (error != IA_NO_ERROR) {
         return error;
       }
     } else {
       if (0 == pstr_config->sbr_pvc_active) {
         sbr_pvc_mode = 0;
       }
 
       ixheaace_set_usac_sbr_params(
           pstr_sbr_encoder, usac_independency_flg, 0, pstr_config->sbr_pvc_active, sbr_pvc_mode,
           pstr_config->sbr_inter_tes_active, pstr_config->sbr_harmonic, sbr_patching_mode);
       if (pstr_config->sbr_harmonic) {
         FLOAT32 *in_buffer_temp;
         ixheaace_get_input_scratch_buf(pstr_api_struct->pstr_state->ptr_temp_buff_resamp,
                                        &in_buffer_temp);
         FLOAT32 *outbuf = ixheaace_get_hbe_resample_buffer(pstr_sbr_encoder);
         if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {
           WORD32 input_tot = num_samples_read / pstr_api_struct->config[0].i_channels;
           ixheaace_upsampling_inp_buf_generation(ptr_input_buffer, in_buffer_temp, input_tot,
                                                  UPSAMPLE_FAC, 0);
         }
 
         // Resampler
         for (ch = 0; ch < num_ch; ch++) {
           FLOAT32 *shared_buf1_ring, *shared_buf2_ring;
           ixheaace_resampler_scratch *pstr_scratch_resampler =
               (ixheaace_resampler_scratch *)(ixheaace_resampler_scratch *)
                   pstr_api_struct->pstr_state->ptr_temp_buff_resamp;
 
           ia_enhaacplus_enc_get_scratch_bufs(pstr_api_struct->pstr_state->temp_buff_sbr,
                                              &shared_buf1_ring, &shared_buf2_ring);
 
           if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {
             // Upsampling by factor 3 - SOS implementation
             ia_enhaacplus_enc_iir_sos_upsampler(
                 &(pstr_api_struct->pstr_state->hbe_up_sampler[0][ch]), in_buffer_temp + ch,
                 num_samples_read / pstr_api_struct->config[0].i_channels,
                 IXHEAACE_MAX_CH_IN_BS_ELE, in_buffer_temp + ch, &out_samples, shared_buf1_ring,
                 shared_buf2_ring, pstr_scratch_resampler);
 
             // Downsampling by factor 8
             ia_enhaacplus_enc_iir_sos_downsampler(
                 &(pstr_api_struct->pstr_state->hbe_down_samp_sos[0][ch]), in_buffer_temp + ch,
                 out_samples, IXHEAACE_MAX_CH_IN_BS_ELE, outbuf + ch, &out_samples,
                 shared_buf1_ring, shared_buf2_ring, pstr_scratch_resampler);
           } else {
             WORD32 out_stride = IXHEAACE_MAX_CH_IN_BS_ELE * resamp_ratio;
 
             ia_enhaacplus_enc_iir_downsampler(
                 &(pstr_api_struct->pstr_state->hbe_down_sampler[0][ch]),
                 ptr_input_buffer /*input_buffer_fix + write_off_set*/ + ch,
                 num_samples_read / pstr_api_struct->config[0].i_channels,
                 IXHEAACE_MAX_CH_IN_BS_ELE, outbuf + ch, &out_samples, out_stride,
                 shared_buf1_ring, shared_buf2_ring, pstr_scratch_resampler);
           }
         }
       }
 
       FLOAT32 *time_signal = pstr_api_struct->pstr_state->time_signal;
       for (idx = 0; idx < num_samples_read; idx++) {
         time_signal[idx] = (FLOAT32)ptr_input_buffer[2 * idx];
       }
 
       if (1 == pstr_config->use_drc_element) {
         if (16 == pstr_config->ui_pcm_wd_sz) {
           for (idx = 0; idx < drc_sample; idx++) {
             ptr_drc_inp_buf[idx % num_ch][idx / num_ch + ptr_inp_buf_offset] = time_signal[idx];
           }
         } else if (24 == pstr_config->ui_pcm_wd_sz) {
           for (idx = 0; idx < drc_sample; idx++) {
             i4_inp_data = ((WORD32)(*pi1_inp_buf)) & 0xFF;
             pi1_inp_buf++;
             i4_inp_data += ((WORD32)(*pi1_inp_buf) << 8) & 0xFFFF;
             pi1_inp_buf++;
             i4_inp_data += ((WORD32)(*pi1_inp_buf) << 16) & 0xFFFFFF;
             pi1_inp_buf++;
             i4_inp_data = i4_inp_data - (i4_inp_data >> 23 << 24);
             ptr_drc_inp_buf[idx % num_ch][idx / num_ch + ptr_inp_buf_offset] =
                 (FLOAT32)i4_inp_data / DIV_FAC_24_BIT_PCM;
           }
         } else if (32 == pstr_config->ui_pcm_wd_sz) {
           pi4_inp_buf = (WORD32 *)pi1_inp_buf;
           for (idx = 0; idx < drc_sample; idx++) {
             i4_inp_data = *pi4_inp_buf++;
             ptr_drc_inp_buf[idx % num_ch][idx / num_ch + ptr_inp_buf_offset] =
                 (FLOAT32)i4_inp_data / DIV_FAC_32_BIT_PCM;
           }
         }
       }
 
       // SBR Encode
       error = ixheaace_env_encode_frame(
           pstr_sbr_encoder, time_signal, time_signal, pstr_api_struct->config[0].i_channels,
           &(pstr_api_struct->pstr_state->num_anc_data_bytes[0][0]),
           pstr_api_struct->pstr_state->anc_data_bytes[0],
           &(pstr_api_struct->spectral_band_replication_tabs), &(pstr_api_struct->common_tabs),
           &(mps_extension_payload.p_data[0]), mps_extension_payload.data_size, 0,
           &pstr_api_struct->pstr_state->str_usac_enc_data.num_sbr_bits);
       if (error != IA_NO_ERROR) {
         return error;
       }
     }
 
     /* Resampling for USAC core */
     {
       FLOAT32 *in_buffer_temp;
       ixheaace_get_input_scratch_buf(pstr_api_struct->pstr_state->ptr_temp_buff_resamp,
                                      &in_buffer_temp);
       if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {
         WORD32 input_tot = num_samples_read / pstr_api_struct->config[0].i_channels;
         ixheaace_upsampling_inp_buf_generation(ptr_input_buffer, in_buffer_temp, input_tot,
                                                UPSAMPLE_FAC, write_off_set);
       }
 
       for (ch = 0; ch < num_ch; ch++) {
         FLOAT32 *shared_buf1_ring, *shared_buf2_ring;
         ixheaace_resampler_scratch *pstr_scratch_resampler =
             (ixheaace_resampler_scratch *)pstr_api_struct->pstr_state->ptr_temp_buff_resamp;
 
         ia_enhaacplus_enc_get_scratch_bufs(pstr_api_struct->pstr_state->temp_buff_sbr,
                                            &shared_buf1_ring, &shared_buf2_ring);
 
         if (pstr_api_struct->config[0].ccfl_idx == SBR_8_3) {
           // Upsampling by factor 3 - SOS implementation
           ia_enhaacplus_enc_iir_sos_upsampler(
               &(pstr_api_struct->pstr_state->up_sampler[0][ch]), in_buffer_temp + ch,
               num_samples_read / pstr_api_struct->config[0].i_channels, IXHEAACE_MAX_CH_IN_BS_ELE,
               in_buffer_temp + ch, &out_samples, shared_buf1_ring, shared_buf2_ring,
               pstr_scratch_resampler);
 
           // Downsampling by factor 8
           ia_enhaacplus_enc_iir_sos_downsampler(
               &(pstr_api_struct->pstr_state->down_samp_sos[0][ch]), in_buffer_temp + ch,
               out_samples, IXHEAACE_MAX_CH_IN_BS_ELE, ptr_input_buffer + ch, &out_samples,
               shared_buf1_ring, shared_buf2_ring, pstr_scratch_resampler);
         } else {
           WORD32 out_stride = IXHEAACE_MAX_CH_IN_BS_ELE * resamp_ratio;
 
           ia_enhaacplus_enc_iir_downsampler(
               &(pstr_api_struct->pstr_state->down_sampler[0][ch]),
               ptr_input_buffer + write_off_set + ch,
               num_samples_read / pstr_api_struct->config[0].i_channels, IXHEAACE_MAX_CH_IN_BS_ELE,
               ptr_input_buffer + ch, &out_samples, out_stride, shared_buf1_ring, shared_buf2_ring,
               pstr_scratch_resampler);
         }
       }
     }
 
     if (num_ch != 0) {
       for (idx = 0; idx < num_ch; idx++) {
         ptr_inp_buf[idx] = pstr_api_struct->pstr_state->ptr_in_buf[idx];
       }
 
       if (16 == pstr_config->ui_pcm_wd_sz) {
         if (num_ch == 1) {
           for (idx = 0; idx < core_sample; idx++) {
             ptr_inp_buf[idx % num_ch][idx / num_ch] = ptr_input_buffer[2 * idx];
           }
         } else {
           for (idx = 0; idx < core_sample; idx++) {
             ptr_inp_buf[idx % num_ch][idx / num_ch] = ptr_input_buffer[idx];
           }
         }
       } else if (24 == pstr_config->ui_pcm_wd_sz) {
         for (idx = 0; idx < core_sample; idx++) {
           i4_inp_data = ((WORD32)(*pi1_inp_buf)) & 0xFF;
           pi1_inp_buf++;
           i4_inp_data += ((WORD32)(*pi1_inp_buf) << 8) & 0xFFFF;
           pi1_inp_buf++;
           i4_inp_data += ((WORD32)(*pi1_inp_buf) << 16) & 0xFFFFFF;
           pi1_inp_buf++;
           i4_inp_data = i4_inp_data - (i4_inp_data >> 23 << 24);
           ptr_inp_buf[idx % num_ch][idx / num_ch] = (FLOAT32)i4_inp_data / DIV_FAC_24_BIT_PCM;
         }
       } else if (32 == pstr_config->ui_pcm_wd_sz) {
         pi4_inp_buf = (WORD32 *)pi1_inp_buf;
         for (idx = 0; idx < core_sample; idx++) {
           i4_inp_data = *pi4_inp_buf++;
           ptr_inp_buf[idx % num_ch][idx / num_ch] = (FLOAT32)i4_inp_data / DIV_FAC_32_BIT_PCM;
         }
       }
     }
   } else {
     if (num_ch != 0) {
       for (idx = 0; idx < num_ch; idx++) {
         ptr_inp_buf[idx] = pstr_api_struct->pstr_state->ptr_in_buf[idx];
       }
 
       if (16 == pstr_config->ui_pcm_wd_sz) {
         for (idx = 0; idx < core_sample; idx++) {
           ptr_inp_buf[idx % num_ch][idx / num_ch] = ps_inp_buf[idx];
         }
       } else if (24 == pstr_config->ui_pcm_wd_sz) {
         for (idx = 0; idx < core_sample; idx++) {
           i4_inp_data = ((WORD32)(*pi1_inp_buf)) & 0xFF;
           pi1_inp_buf++;
           i4_inp_data += ((WORD32)(*pi1_inp_buf) << 8) & 0xFFFF;
           pi1_inp_buf++;
           i4_inp_data += ((WORD32)(*pi1_inp_buf) << 16) & 0xFFFFFF;
           pi1_inp_buf++;
           i4_inp_data = i4_inp_data - (i4_inp_data >> 23 << 24);
           ptr_inp_buf[idx % num_ch][idx / num_ch] = (FLOAT32)i4_inp_data / DIV_FAC_24_BIT_PCM;
         }
       } else if (32 == pstr_config->ui_pcm_wd_sz) {
         pi4_inp_buf = (WORD32 *)pi1_inp_buf;
         for (idx = 0; idx < core_sample; idx++) {
           i4_inp_data = *pi4_inp_buf++;
           ptr_inp_buf[idx % num_ch][idx / num_ch] = (FLOAT32)i4_inp_data / DIV_FAC_32_BIT_PCM;
         }
       }
       if (1 == pstr_config->use_drc_element) {
         if (16 == pstr_config->ui_pcm_wd_sz) {
           for (idx = 0; idx < drc_sample; idx++) {
             ptr_drc_inp_buf[idx % num_ch][idx / num_ch + ptr_inp_buf_offset] = ps_inp_buf[idx];
           }
         } else if (24 == pstr_config->ui_pcm_wd_sz) {
           for (idx = 0; idx < drc_sample; idx++) {
             i4_inp_data = ((WORD32)(*pi1_inp_buf)) & 0xFF;
             pi1_inp_buf++;
             i4_inp_data += ((WORD32)(*pi1_inp_buf) << 8) & 0xFFFF;
             pi1_inp_buf++;
             i4_inp_data += ((WORD32)(*pi1_inp_buf) << 16) & 0xFFFFFF;
             pi1_inp_buf++;
             i4_inp_data = i4_inp_data - (i4_inp_data >> 23 << 24);
             ptr_drc_inp_buf[idx % num_ch][idx / num_ch + ptr_inp_buf_offset] =
                 (FLOAT32)i4_inp_data / DIV_FAC_24_BIT_PCM;
           }
         } else if (32 == pstr_config->ui_pcm_wd_sz) {
           pi4_inp_buf = (WORD32 *)pi1_inp_buf;
           for (idx = 0; idx < drc_sample; idx++) {
             i4_inp_data = *pi4_inp_buf++;
             ptr_drc_inp_buf[idx % num_ch][idx / num_ch + ptr_inp_buf_offset] =
                 (FLOAT32)i4_inp_data / DIV_FAC_32_BIT_PCM;
           }
         }
       }
     }
   }
 
   if (pstr_sig_class_data->is_switch_mode) {
     for (idx = 0; idx < core_coder_frame_length; idx++) {
       pstr_sig_class_data->input_samples[pstr_sig_class_data->n_buffer_samples + idx] =
           pstr_api_struct->pstr_state->ptr_in_buf[0][idx];
     }
     pstr_sig_class_data->n_buffer_samples += core_coder_frame_length;
     iusace_classification(pstr_sig_class_data, pstr_scratch, core_coder_frame_length);
   }
 
   pstr_it_bit_buff =
       iusace_create_bit_buffer(pstr_it_bit_buff, pstr_api_struct->pp_mem[IA_MEMTYPE_OUTPUT],
                                pstr_api_struct->pstr_mem_info[IA_MEMTYPE_OUTPUT].ui_size, 1);
   if (pstr_it_bit_buff == NULL) {
     return -1;
   }
 #ifdef ENABLE_SET_JUMP
   pstr_it_bit_buff->iusace_jmp_buf = &api_execute_jmp_buf;
 #endif
   error =
       ixheaace_usac_encode(pstr_api_struct->pstr_state->ptr_in_buf, pstr_config,
                            &pstr_api_struct->pstr_state->str_usac_enc_data,
                            &pstr_api_struct->pstr_state->audio_specific_config, pstr_it_bit_buff,
                            pstr_sbr_encoder, pstr_api_struct->pstr_state->pp_drc_in_buf,
-                           &pstr_api_struct->pstr_state->is_quant_spec_zero);
+                           &pstr_api_struct->pstr_state->is_quant_spec_zero,
+                           &pstr_api_struct->pstr_state->is_gain_limited);
   if (error) return error;
 
   padding_bits = 8 - (pstr_it_bit_buff->cnt_bits & 7);
   if (padding_bits > 0 && padding_bits < 8) {
     ps_out_buf[pstr_it_bit_buff->cnt_bits >> 3] =
         (WORD8)((UWORD32)ps_out_buf[pstr_it_bit_buff->cnt_bits >> 3]) & (0xFF << padding_bits);
   }
   pstr_api_struct->pstr_state->i_out_bytes =
       (padding_bits > 0 && padding_bits < 8) ? (pstr_it_bit_buff->cnt_bits + padding_bits) >> 3
                                              : pstr_it_bit_buff->cnt_bits >> 3;
 
   pstr_state->str_usac_enc_data.frame_count++;
   pstr_usac_data->usac_independency_flag_count =
       (pstr_usac_data->usac_independency_flag_count + 1) %
       pstr_usac_data->usac_independency_flag_interval;
 
   if (pstr_config->sbr_enable) {
     WORD32 num_samples = pstr_api_struct->config[0].usac_config.ccfl * IXHEAACE_MAX_CH_IN_BS_ELE;
     switch (pstr_api_struct->config[0].ccfl_idx) {
       case SBR_8_3:
         num_samples *= 8;
         num_samples /= 3;
         break;
 
       case SBR_2_1:
         num_samples *= 2;
         break;
 
       case SBR_4_1:
         num_samples *= 4;
         break;
     }
 
     if (ptr_input_buffer != NULL) {
       memmove(ptr_input_buffer, ptr_input_buffer + num_samples,
               write_off_set * sizeof(ptr_input_buffer[0]));
     }
   }
 
   return IA_NO_ERROR;
 }
@@ -3606,23 +3608,30 @@ IA_ERRORCODE ixheaace_create(pVOID pv_input, pVOID pv_output) {
 IA_ERRORCODE ixheaace_process(pVOID pstr_obj_ixheaace, pVOID pv_input, pVOID pv_output) {
   IA_ERRORCODE error = IA_NO_ERROR;
   WORD32 ele_idx;
   (VOID) pv_input;
   ixheaace_api_struct *pstr_api_struct = (ixheaace_api_struct *)pstr_obj_ixheaace;
   ixheaace_output_config *pstr_output_config = (ixheaace_output_config *)pv_output;
   pstr_api_struct->pstr_state->is_quant_spec_zero = 0;
+  pstr_api_struct->pstr_state->is_gain_limited = 0;
   if (!pstr_api_struct->usac_en) {
     for (ele_idx = 0; ele_idx < pstr_api_struct->config[0].num_bs_elements; ele_idx++) {
       error = ia_enhaacplus_enc_execute(pstr_api_struct, ele_idx);
     }
     if ((error == IA_NO_ERROR) && (pstr_api_struct->pstr_state->is_quant_spec_zero)) {
       error = IA_EXHEAACE_EXE_NONFATAL_QUANTIZATION_SPECTRUM_ZERO;
     }
+    if ((error == IA_NO_ERROR) && (pstr_api_struct->pstr_state->is_gain_limited)) {
+      error = IA_EXHEAACE_EXE_NONFATAL_QUANTIZATION_INSUFFICIENT_BITRES;
+    }
   } else {
     error = iusace_process(pstr_api_struct);
     if ((error == IA_NO_ERROR) && (pstr_api_struct->pstr_state->is_quant_spec_zero)) {
       error = IA_EXHEAACE_EXE_NONFATAL_USAC_QUANTIZATION_SPECTRUM_ZERO;
     }
+    if ((error == IA_NO_ERROR) && (pstr_api_struct->pstr_state->is_gain_limited)) {
+      error = IA_EXHEAACE_EXE_NONFATAL_USAC_QUANTIZATION_INSUFFICIENT_BITRES;
+    }
   }
   pstr_output_config->i_out_bytes = pstr_api_struct->pstr_state->i_out_bytes;
   return error;
 }
diff --git a/encoder/ixheaace_api_defs.h b/encoder/ixheaace_api_defs.h
index 99dbdba..3c2164d 100644
--- a/encoder/ixheaace_api_defs.h
+++ b/encoder/ixheaace_api_defs.h
@@ -41,7 +41,7 @@
 IA_ERRORCODE ixheaace_usac_encode(FLOAT32 **ptr_input,
                                   ia_usac_encoder_config_struct *ptr_usac_config,
                                   ia_usac_data_struct *pstr_state,
                                   ixheaace_audio_specific_config_struct *pstr_asc,
                                   ia_bit_buf_struct *pstr_it_bit_buff,
                                   ixheaace_pstr_sbr_enc ptr_env_encoder, FLOAT32 **ptr_drc_inp,
-                                  WORD32 *is_quant_spec_zero);
+                                  WORD32 *is_quant_spec_zero, WORD32 *is_gain_restricted);
diff --git a/encoder/ixheaace_enc_main.c b/encoder/ixheaace_enc_main.c
index 048f63f..1c25924 100644
--- a/encoder/ixheaace_enc_main.c
+++ b/encoder/ixheaace_enc_main.c
@@ -62,177 +62,178 @@
 IA_ERRORCODE ia_enhaacplus_enc_aac_core_encode(
     iexheaac_encoder_str **pstr_aac_enc, FLOAT32 *ptr_time_signal, UWORD32 time_sn_stride,
     const UWORD8 *ptr_anc_bytes, UWORD8 *num_anc_bytes, UWORD8 *ptr_out_bytes,
     WORD32 *num_out_bytes, ixheaace_aac_tables *pstr_aac_tabs, VOID *ptr_bit_stream_handle,
     VOID *ptr_bit_stream, FLAG flag_last_element, WORD32 *write_program_config_element,
     WORD32 i_num_coup_channels, WORD32 i_channels_mask, WORD32 ele_idx, WORD32 *total_fill_bits,
     WORD32 total_channels, WORD32 aot, WORD32 adts_flag, WORD32 num_bs_elements,
-    WORD32 *is_quant_spec_zero) {
+    WORD32 *is_quant_spec_zero, WORD32 *is_gain_limited) {
   IA_ERRORCODE err_code = IA_NO_ERROR;
   iexheaac_encoder_str *pstr_aac_encoder = pstr_aac_enc[ele_idx];
   ixheaace_element_info *pstr_element_info = &pstr_aac_encoder->element_info;
   WORD32 glob_used_bits;
   WORD32 anc_data_bytes, anc_data_bytes_left;
   WORD32 stat_bits_flag = 0;
   WORD32 frame_len_long = FRAME_LEN_1024;
   WORD32 ch;
 
   if (aot == AOT_AAC_LC || aot == AOT_SBR || aot == AOT_PS) {
     frame_len_long =
         (pstr_aac_encoder->config.flag_framelength_small == 1) ? FRAME_LEN_960 : FRAME_LEN_1024;
   } else if (aot == AOT_AAC_LD || aot == AOT_AAC_ELD) {
     frame_len_long =
         (pstr_aac_encoder->config.flag_framelength_small == 1) ? FRAME_LEN_480 : FRAME_LEN_512;
   }
 
   if (ele_idx == 0) {
     if (aot == AOT_AAC_LC || aot == AOT_SBR || aot == AOT_PS) {
       ptr_bit_stream_handle = ia_enhaacplus_enc_create_bitbuffer(
           ptr_bit_stream, (UWORD8 *)ptr_out_bytes,
           (((pstr_aac_encoder->config.flag_framelength_small == 1) ? MAXIMUM_CHANNEL_BITS_960
                                                                    : MAXIMUM_CHANNEL_BITS_1024) /
            8) *
               total_channels);
     } else if (aot == AOT_AAC_LD || aot == AOT_AAC_ELD) {
       if (pstr_aac_encoder->config.bitreservoir_size != -1) {
         WORD32 avg_byte_perframe = (pstr_aac_encoder->config.bit_rate * frame_len_long /
                                     (pstr_aac_encoder->config.core_sample_rate * 8));
 
         if ((pstr_aac_encoder->config.bitreservoir_size * total_channels) > avg_byte_perframe) {
           ptr_bit_stream_handle = ia_enhaacplus_enc_create_bitbuffer(
               ptr_bit_stream, (UWORD8 *)ptr_out_bytes,
               pstr_aac_encoder->config.bitreservoir_size * total_channels);
         } else {
           ptr_bit_stream_handle = ia_enhaacplus_enc_create_bitbuffer(
               ptr_bit_stream, (UWORD8 *)ptr_out_bytes,
               (pstr_aac_encoder->config.bit_rate * frame_len_long /
                (pstr_aac_encoder->config.core_sample_rate * 8)));
         }
       } else {
         ptr_bit_stream_handle = ia_enhaacplus_enc_create_bitbuffer(
             ptr_bit_stream, (UWORD8 *)ptr_out_bytes,
             (pstr_aac_encoder->config.bit_rate * frame_len_long /
              (pstr_aac_encoder->config.core_sample_rate * 8)));
       }
     }
   } else {
     ptr_bit_stream_handle = ptr_bit_stream;
   }
 
   if (adts_flag) {
     stat_bits_flag = 0; /* fix for low bit-rate */
     if ((pstr_aac_encoder->config.core_sample_rate * 3) <= (pstr_aac_encoder->config.bit_rate)) {
       stat_bits_flag = 7; /* fix for low bit-rate */
     }
   }
 
   anc_data_bytes = anc_data_bytes_left = *num_anc_bytes;
 
   if (pstr_element_info->el_type == ID_CPE) {
     if (!pstr_aac_encoder->config.num_stereo_preprocessing) {
       iaace_apply_stereo_preproc(&pstr_aac_encoder->str_stereo_pre_pro, time_sn_stride,
                                  pstr_element_info, ptr_time_signal, frame_len_long);
     }
   }
 
   err_code = ia_enhaacplus_enc_psy_main(
       time_sn_stride, pstr_element_info, ptr_time_signal, aot,
       pstr_aac_encoder->psy_kernel.psy_data[pstr_element_info->channel_index[0]],
       pstr_aac_encoder->psy_kernel
           .temporal_noise_shaping_data[pstr_element_info->channel_index[0]],
       &pstr_aac_encoder->psy_kernel.psy_conf_long, &pstr_aac_encoder->psy_kernel.psy_conf_short,
       pstr_aac_encoder->psy_out.psy_out_ch[pstr_element_info->channel_index[0]],
       &pstr_aac_encoder->psy_out.psy_out_element,
       pstr_aac_encoder->psy_kernel.p_scratch_tns_float,
       (FLOAT32 *)pstr_aac_encoder->pstr_aac_scratch->shared_buffer1,
       pstr_aac_encoder->pstr_aac_scratch->shared_buffer5, pstr_aac_tabs, frame_len_long);
 
   if (err_code != IA_NO_ERROR) {
     return err_code;
   }
 
   ia_enhaacplus_enc_adjust_bitrate(
       &pstr_aac_encoder->qc_kernel, pstr_aac_encoder->config.bit_rate,
       pstr_aac_encoder->config.core_sample_rate, flag_last_element, frame_len_long);
 
   for (ch = 0; ch < pstr_element_info->n_channels_in_el; ch++) {
     pstr_aac_encoder->psy_out.psy_out_ch[pstr_element_info->channel_index[0]][ch].ms_digest =
         pstr_aac_encoder->psy_out.psy_out_element.tools_info.ms_digest;
 
     memcpy(
         &pstr_aac_encoder->psy_out.psy_out_ch[pstr_element_info->channel_index[0]][ch].ms_used[0],
         &pstr_aac_encoder->psy_out.psy_out_element.tools_info.ms_mask[0],
         MAXIMUM_GROUPED_SCALE_FACTOR_BAND *
             sizeof(pstr_aac_encoder->psy_out.psy_out_ch[pstr_element_info->channel_index[0]][ch]
                        .ms_used[0]));
   }
 
   err_code = ia_enhaacplus_enc_qc_main(
       &pstr_aac_encoder->qc_kernel, pstr_element_info->n_channels_in_el,
       &pstr_aac_encoder->qc_kernel.element_bits,
       pstr_aac_encoder->psy_out.psy_out_ch[pstr_element_info->channel_index[0]],
       &pstr_aac_encoder->psy_out.psy_out_element,
       pstr_aac_encoder->qc_out.qc_channel[pstr_element_info->channel_index[0]],
       &pstr_aac_encoder->qc_out.qc_element, MIN(anc_data_bytes_left, anc_data_bytes),
       pstr_aac_tabs, adts_flag, aot, stat_bits_flag, flag_last_element, frame_len_long,
-      pstr_aac_encoder->pstr_aac_scratch->shared_buffer5, is_quant_spec_zero);
+      pstr_aac_encoder->pstr_aac_scratch->shared_buffer5, is_quant_spec_zero,
+      is_gain_limited);
 
   if (err_code != IA_NO_ERROR) {
     return err_code;
   }
 
   if (pstr_element_info->el_type == ID_CPE) {
     if (!pstr_aac_encoder->config.num_stereo_preprocessing) {
       iaace_update_stereo_pre_process(
           pstr_aac_encoder->psy_out.psy_out_ch[pstr_element_info->channel_index[0]],
           &pstr_aac_encoder->qc_out.qc_element, &pstr_aac_encoder->str_stereo_pre_pro,
           pstr_aac_encoder->psy_out.psy_out_element.weight_ms_lr_pe_ratio);
     }
   }
 
   /* Update bit reservoir levels */
   ia_enhaacplus_enc_update_bit_reservoir(&pstr_aac_encoder->qc_kernel, &pstr_aac_encoder->qc_out);
 
   err_code = ia_enhaacplus_enc_finalize_bit_consumption(
       &pstr_aac_encoder->qc_kernel, &pstr_aac_encoder->qc_out, flag_last_element,
       ((ixheaace_bit_buf_handle)ptr_bit_stream_handle)->cnt_bits, total_fill_bits, pstr_aac_enc,
       num_bs_elements, aot);
 
   if (err_code != IA_NO_ERROR) {
     return err_code;
   }
 
   err_code = ia_enhaacplus_enc_write_bitstream(
       ptr_bit_stream_handle, *pstr_element_info, &pstr_aac_encoder->qc_out,
       &pstr_aac_encoder->psy_out, &glob_used_bits, ptr_anc_bytes, pstr_aac_tabs,
       flag_last_element, write_program_config_element, i_num_coup_channels, i_channels_mask,
       pstr_aac_encoder->config.core_sample_rate, ele_idx, aot, total_fill_bits);
   if (err_code != IA_NO_ERROR) {
     return err_code;
   }
   /* write out the bitstream */
   *num_out_bytes = ia_enhaacplus_enc_get_bits_available(ptr_bit_stream_handle) / 8;
 
   /* Validate that this frame is not too large */
   if (pstr_aac_encoder->config.bitreservoir_size != -1) {
     WORD32 avg_bytes_perframe = (pstr_aac_encoder->config.bit_rate * frame_len_long /
                                  (pstr_aac_encoder->config.core_sample_rate * 8));
 
     if (pstr_aac_encoder->config.bitreservoir_size * total_channels > avg_bytes_perframe) {
       if (*num_out_bytes > (pstr_aac_encoder->config.bitreservoir_size * total_channels)) {
         err_code = IA_EXHEAACE_EXE_FATAL_INVALID_OUT_BYTES;
       }
     } else {
       if (*num_out_bytes > avg_bytes_perframe) {
         err_code = IA_EXHEAACE_EXE_FATAL_INVALID_OUT_BYTES;
       }
     }
   } else {
     WORD32 avg_bytes_perframe = (pstr_aac_encoder->config.bit_rate * frame_len_long /
                                  (pstr_aac_encoder->config.core_sample_rate * 8));
     if (*num_out_bytes > avg_bytes_perframe) {
       err_code = IA_EXHEAACE_EXE_FATAL_INVALID_OUT_BYTES;
     }
   }
 
   return err_code;
 }
diff --git a/encoder/ixheaace_enc_main.h b/encoder/ixheaace_enc_main.h
index e3c34ca..3dd377e 100644
--- a/encoder/ixheaace_enc_main.h
+++ b/encoder/ixheaace_enc_main.h
@@ -105,11 +105,11 @@ IA_ERRORCODE ia_enhaacplus_enc_aac_enc_open(iexheaac_encoder_str **ppstr_exheaac
 IA_ERRORCODE ia_enhaacplus_enc_aac_core_encode(
     iexheaac_encoder_str **pstr_aac_enc, FLOAT32 *ptr_time_signal, UWORD32 time_sn_stride,
     const UWORD8 *ptr_anc_bytes, UWORD8 *num_anc_bytes, UWORD8 *ptr_out_bytes,
     WORD32 *num_out_bytes, ixheaace_aac_tables *pstr_aac_tables, VOID *ptr_bit_stream_handle,
     VOID *ptr_bit_stream, FLAG flag_last_element, WORD32 *write_program_config_element,
     WORD32 i_num_coup_channels, WORD32 i_channels_mask, WORD32 ele_idx, WORD32 *total_fill_bits,
     WORD32 total_channels, WORD32 aot, WORD32 adts_flag, WORD32 num_bs_elements,
-    WORD32 *is_quant_spec_zero);
+    WORD32 *is_quant_spec_zero, WORD32 *is_gain_limited);
 
 VOID ia_enhaacplus_enc_set_shared_bufs(iaace_scratch *scr, WORD32 **shared_buf1,
                                        WORD32 **shared_buf2, WORD32 **shared_buf3,
diff --git a/encoder/ixheaace_error_codes.h b/encoder/ixheaace_error_codes.h
index c791c27..a0fe36f 100644
--- a/encoder/ixheaace_error_codes.h
+++ b/encoder/ixheaace_error_codes.h
@@ -30,179 +30,181 @@
 typedef enum {
   /*****************************************************************************/
   /* Class 0: API Errors                                                       */
   /*****************************************************************************/
   /* Non Fatal Errors */
 
   // AAC Profiles
 
   // MPS
 
   // USAC
 
   // DRC
 
   /* Fatal Errors */
 
   // AAC Profiles
   IA_EXHEAACE_API_FATAL_MEM_ALLOC = 0xFFFF8000,
   IA_EXHEAACE_API_FATAL_UNSUPPORTED_AOT,
 
   // MPS
 
   // USAC
 
   // DRC
 
   /*****************************************************************************/
   /* Class 1: Configuration Errors                                             */
   /*****************************************************************************/
   /* Non Fatal Errors */
 
   // AAC profiles
   IA_EXHEAACE_CONFIG_NONFATAL_INVALID_CONFIG = 0x00000800,
   IA_EXHEAACE_CONFIG_NONFATAL_BITRES_SIZE_TOO_SMALL,
 
   // MPS
   IA_EXHEAACE_CONFIG_NONFATAL_MPS_INVALID_CONFIG = 0x00000900,
   IA_EXHEAACE_CONFIG_NONFATAL_MPS_PARAM_ERROR,
 
   // USAC
 
   // DRC
   IA_EXHEAACE_CONFIG_NONFATAL_DRC_MISSING_CONFIG = 0x00000B00,
   /* Fatal Errors */
 
   // AAC profiles
   IA_EXHEAACE_CONFIG_FATAL_SAMP_FREQ = 0xFFFF8800,
   IA_EXHEAACE_CONFIG_FATAL_NUM_CHANNELS,
   IA_EXHEAACE_CONFIG_FATAL_USE_STEREO_PRE_PROC,
   IA_EXHEAACE_CONFIG_FATAL_QUALITY_LEVEL,
   IA_EXHEAACE_CONFIG_FATAL_PCM_WDSZ,
   IA_EXHEAACE_CONFIG_FATAL_AAC_CLASSIC_WITH_PS,
   IA_EXHEAACE_CONFIG_FATAL_USE_TNS,
   IA_EXHEAACE_CONFIG_FATAL_CHANNELS_MASK,
   IA_EXHEAACE_CONFIG_FATAL_WRITE_PCE,
   IA_EXHEAACE_CONFIG_FATAL_USE_FULL_BANDWIDTH,
   // MPS
 
   // USAC
   IA_EXHEAACE_CONFIG_FATAL_USAC_SAMP_FREQ = 0xFFFF8A00,
   IA_EXHEAACE_CONFIG_FATAL_USAC_RESAMPLER_RATIO,
 
   // DRC
   IA_EXHEAACE_CONFIG_FATAL_DRC_INVALID_CONFIG = 0xFFFF8B00,
   IA_EXHEAACE_CONFIG_FATAL_DRC_UNSUPPORTED_CONFIG,
   IA_EXHEAACE_CONFIG_FATAL_DRC_PARAM_OUT_OF_RANGE,
   IA_EXHEAACE_CONFIG_FATAL_DRC_COMPAND_FAILED,
   /*****************************************************************************/
   /* Class 2: Initialization Errors                                             */
   /*****************************************************************************/
   /* Non Fatal Errors */
 
   //DRC
   IA_EXHEAACE_EXE_NONFATAL_USAC_INVALID_GAIN_POINTS = 0x00001300,
   IA_EXHEAACE_EXE_NONFATAL_USAC_INVALID_SUBBAND_INDEX,
   /* Fatal Errors */
 
   // AAC Profiles
   IA_EXHEAACE_INIT_FATAL_RESAMPLER_INIT_FAILED = 0xFFFF9000,
   IA_EXHEAACE_INIT_FATAL_AAC_INIT_FAILED,
   IA_EXHEAACE_INIT_FATAL_AACPLUS_NOT_AVAIL,
   IA_EXHEAACE_INIT_FATAL_BITRATE_NOT_SUPPORTED,
   IA_EXHEAACE_INIT_FATAL_INVALID_TNS_PARAM,
   IA_EXHEAACE_INIT_FATAL_SCALE_FACTOR_BAND_NOT_SUPPORTED,
   IA_EXHEAACE_INIT_FATAL_INVALID_CORE_SAMPLE_RATE,
   IA_EXHEAACE_INIT_FATAL_INVALID_ELEMENT_TYPE,
   IA_EXHEAACE_INIT_FATAL_NUM_CHANNELS_NOT_SUPPORTED,
   IA_EXHEAACE_INIT_FATAL_INVALID_NUM_CHANNELS_IN_ELE,
   IA_EXHEAACE_INIT_FATAL_SFB_TABLE_INIT_FAILED,
 
   // MPS
   IA_EXHEAACE_INIT_FATAL_MPS_INIT_FAILED = 0xFFFF9100,
 
   // USAC
   IA_EXHEAACE_INIT_FATAL_USAC_RESAMPLER_INIT_FAILED = 0xFFFF9200,
   IA_EXHEAACE_INIT_FATAL_USAC_BITRES_SIZE_TOO_SMALL,
 
   // DRC
   IA_EXHEAACE_INIT_FATAL_DRC_INVALID_CHANNEL_INDEX = 0xFFFF9300,
 
   // SBR
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_NUM_CHANNELS = 0xFFFF9400,
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_SAMPLERATE_MODE,
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_FREQ_COEFFS,
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_NUM_BANDS,
   IA_EXHEAACE_INIT_FATAL_SBR_INVALID_BUFFER_LENGTH,
   IA_EXEHAACE_INIT_FATAL_SBR_NOISE_BAND_NOT_SUPPORTED,
 
   /*****************************************************************************/
   /* Class 3: Execution Errors                                                 */
   /*****************************************************************************/
   /* Non Fatal Errors */
 
   // AAC Profiles
   IA_EXHEAACE_EXE_NONFATAL_QUANTIZATION_SPECTRUM_ZERO = 0x00001800,
+  IA_EXHEAACE_EXE_NONFATAL_QUANTIZATION_INSUFFICIENT_BITRES,
   // MPS
   IA_EXHEAACE_EXE_NONFATAL_MPS_ENCODE_ERROR = 0x00001900,
   IA_EXHEAACE_EXE_NONFATAL_MPS_INVALID_DATA_BANDS,
 
   // USAC
   IA_EXHEAACE_EXE_NONFATAL_USAC_QUANTIZATION_SPECTRUM_ZERO = 0x00001A00,
+  IA_EXHEAACE_EXE_NONFATAL_USAC_QUANTIZATION_INSUFFICIENT_BITRES,
   // DRC
 
   // ESBR
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_BANDWIDTH_INDEX = 0x00001C00,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_NUM_PATCH,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_VOCOD_BUF,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_PVC_MODE,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_FFT,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_START_BAND,
   IA_EXHEAACE_EXE_NONFATAL_ESBR_INVALID_VALUE,
 
   /* Fatal Errors */
 
   // AAC Profiles
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_TIME_SLOTS = 0xFFFF9800,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_IN_CHANNELS,
   IA_EXHEAACE_EXE_FATAL_PS_INVALID_HYBRID_RES_VAL,
   IA_EXHEAACE_EXE_FATAL_UNSUPPORTED_AOT,
   IA_EXHEAACE_EXE_FATAL_INVALID_BLOCK_TYPE,
   IA_EXHEAACE_EXE_FATAL_INVALID_SBR_FRAME_TYPE,
   IA_EXHEAACE_EXE_FATAL_INVALID_SBR_NUM_ENVELOPES,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_BS,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_CODEBOOK,
   IA_EXHEAACE_EXE_FATAL_INVALID_SCALE_FACTOR_GAIN,
   IA_EXHEAACE_EXE_FATAL_INVALID_BIT_RES_LEVEL,
   IA_EXHEAACE_EXE_FATAL_INVALID_BIT_CONSUMPTION,
   IA_EXHEAACE_EXE_FATAL_INVALID_SIDE_INFO_BITS,
   IA_EXHEAACE_EXE_FATAL_INVALID_HUFFMAN_BITS,
   IA_EXHEAACE_EXE_FATAL_INVALID_SCALE_FACTOR_BITS,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_AMP_RES,
   IA_EXHEAACE_EXE_FATAL_INVALID_OUT_BYTES,
   IA_EXHEAACE_EXE_FATAL_INVALID_TNS_FILT_ORDER,
   IA_EXHEAACE_EXE_FATAL_SBR_INVALID_SAMP_FREQ,
 
   // MPS
   IA_EXHEAACE_EXE_FATAL_MPS_NULL_DATA_HANDLE = 0xFFFF9900,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_HUFF_DATA_TYPE,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_NUM_PARAM_SETS,
   IA_EXHEAACE_EXE_FATAL_MPS_UNSUPPORTED_GUIDED_ENV_SHAPE,
   IA_EXHEAACE_EXE_FATAL_MPS_3D_STEREO_MODE_NOT_SUPPORTED,
   IA_EXHEAACE_EXE_FATAL_MPS_UNSUPPORTED_RESIDUAL_CODING,
   IA_EXHEAACE_EXE_FATAL_MPS_UNSUPPORTED_ARBITARY_DOWNMIX_CODING,
   IA_EXHEAACE_EXE_FATAL_MPS_ARBITARY_TREE_NOT_SUPPORTED,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_QUANT_COARSE,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_RES_STRIDE,
   IA_EXHEAACE_EXE_FATAL_MPS_INVALID_LEVELS,
   IA_EXHEAACE_EXE_FATAL_MPS_CFFT_PROCESS,
 
   // USAC
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_FAC_LEN = 0xFFFF9A00,
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_NUM_SBK,
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_NUM_CHANNEL,
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_BIT_RSVR_LVL,
   IA_EXHEAACE_EXE_FATAL_USAC_INVALID_MAPPING,
 
   // DRC
 
 } ixheaace_error_codes;
diff --git a/encoder/ixheaace_fd_enc.c b/encoder/ixheaace_fd_enc.c
index 5c55594..264460c 100644
--- a/encoder/ixheaace_fd_enc.c
+++ b/encoder/ixheaace_fd_enc.c
@@ -55,73 +55,73 @@
 IA_ERRORCODE iusace_fd_encode(ia_sfb_params_struct *pstr_sfb_prms, WORD32 usac_independancy_flag,
                               ia_usac_data_struct *pstr_usac_data,
                               ia_usac_encoder_config_struct *pstr_usac_config,
                               ia_bit_buf_struct *pstr_it_bit_buff, WORD32 nr_core_coder_ch,
                               WORD32 chn, WORD32 ele_id, WORD32 *bit_written,
-                              WORD32 *is_quant_spec_zero) {
+                              WORD32 *is_quant_spec_zero, WORD32 *is_gain_limited) {
   iusace_scratch_mem *pstr_scratch = &pstr_usac_data->str_scratch;
   IA_ERRORCODE err_code = 0;
   WORD32 i_ch, idx = 0;
   WORD32 *ptr_num_fac_bits = pstr_scratch->ptr_num_fac_bits;
   WORD32 tns_data_present[2] = {0};
   WORD32 *ptr_core_mode_next = pstr_usac_data->core_mode_next;
   WORD32 *ptr_core_mode_prev = pstr_usac_data->core_mode_prev;
   *bit_written = 0;
   memset(pstr_scratch->ptr_num_fac_bits, 0,
          MAX_TIME_CHANNELS * sizeof(pstr_scratch->ptr_num_fac_bits[0]));
   for (i_ch = chn; i_ch < chn + nr_core_coder_ch; i_ch++) {
     tns_data_present[idx] = pstr_usac_data->pstr_tns_info[i_ch] != NULL;
 
     if (tns_data_present[idx]) {
       tns_data_present[idx] = pstr_usac_data->pstr_tns_info[i_ch]->tns_data_present;
     }
     idx++;
   }
 
   idx = 0;
   for (i_ch = chn; i_ch < chn + nr_core_coder_ch; i_ch++) {
     memset(pstr_scratch->p_reconstructed_time_signal[idx], 0, 4096 * sizeof(FLOAT64));
     err_code = iusace_fd_fac(
         pstr_sfb_prms->grouped_sfb_offset[i_ch], pstr_sfb_prms->max_sfb[i_ch],
         pstr_usac_data->ptr_2frame_time_data[i_ch], pstr_sfb_prms->window_sequence[i_ch],
         pstr_scratch->p_reconstructed_time_signal[idx], pstr_usac_data->td_encoder[i_ch],
         ((pstr_usac_data->td_encoder[i_ch]->prev_mode == 0) && ptr_core_mode_prev[i_ch]) ==
             CORE_MODE_TD,
         ptr_core_mode_next[i_ch] == CORE_MODE_TD, pstr_usac_data->fac_out_stream[i_ch],
         &ptr_num_fac_bits[i_ch], pstr_scratch);
     if (err_code) {
       return err_code;
     }
     idx++;
   }
 
   err_code = iusace_quantize_spec(pstr_sfb_prms, usac_independancy_flag, nr_core_coder_ch,
                                   pstr_usac_data, pstr_usac_config, chn, ele_id,
-                                  is_quant_spec_zero);
+                                  is_quant_spec_zero, is_gain_limited);
   if (err_code) return err_code;
 
   for (i_ch = chn; i_ch < chn + nr_core_coder_ch; i_ch++) {
     pstr_sfb_prms->window_shape[i_ch] =
         pstr_usac_data->str_psy_mod.str_psy_out_data[i_ch].window_shape;
   }
 
   if (nr_core_coder_ch == 1) {
     iusace_write_bits_buf(pstr_it_bit_buff, tns_data_present[0], 1);
     *bit_written = *bit_written + 1;
   }
   if (nr_core_coder_ch == 2) {
     *bit_written = *bit_written + iusace_write_cpe(pstr_sfb_prms, pstr_it_bit_buff,
                                                    tns_data_present, usac_independancy_flag,
                                                    pstr_usac_config, pstr_usac_data, chn);
   }
 
   idx = 0;
   for (i_ch = chn; i_ch < chn + nr_core_coder_ch; i_ch++) {
     *bit_written =
         *bit_written + iusace_write_fd_data(pstr_it_bit_buff, pstr_sfb_prms,
                                             ptr_num_fac_bits[i_ch], usac_independancy_flag,
                                             pstr_usac_data, pstr_usac_config, i_ch, ele_id, idx);
     idx++;
   }
 
   return err_code;
 }
diff --git a/encoder/ixheaace_fd_quant.c b/encoder/ixheaace_fd_quant.c
index bcaf31d..69f0a9f 100644
--- a/encoder/ixheaace_fd_quant.c
+++ b/encoder/ixheaace_fd_quant.c
@@ -1,61 +1,62 @@
 /******************************************************************************
  *                                                                            *
  * Copyright (C) 2023 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
  */
 
 #include <string.h>
 #include <math.h>
 #include "iusace_type_def.h"
 #include "ixheaac_error_standards.h"
 #include "ixheaace_error_codes.h"
 #include "ixheaace_mps_common_define.h"
 #include "iusace_cnst.h"
 #include "iusace_block_switch_const.h"
 #include "iusace_bitbuffer.h"
 #include "impd_drc_common_enc.h"
 #include "impd_drc_uni_drc.h"
 #include "impd_drc_api.h"
 #include "impd_drc_uni_drc_eq.h"
 #include "impd_drc_uni_drc_filter_bank.h"
 #include "impd_drc_gain_enc.h"
 #include "impd_drc_struct_def.h"
 
 #include "ixheaace_memory_standards.h"
 #include "iusace_tns_usac.h"
 #include "iusace_psy_mod.h"
 #include "iusace_config.h"
 #include "iusace_ms.h"
 #include "ixheaace_adjust_threshold_data.h"
 #include "iusace_fd_qc_util.h"
 #include "iusace_arith_enc.h"
 #include "iusace_fd_quant.h"
 #include "iusace_signal_classifier.h"
 #include "iusace_block_switch_struct_def.h"
 #include "ixheaace_sbr_header.h"
 #include "ixheaace_config.h"
 #include "ixheaace_asc_write.h"
 #include "iusace_main.h"
 #include "iusace_write_bitstream.h"
 #include "ixheaace_nf.h"
 #include "iusace_fd_qc_adjthr.h"
 #include "iusace_block_switch_const.h"
 #include "iusace_rom.h"
 #include "ixheaace_cplx_pred.h"
+#include "ixheaace_aac_constants.h"
 
 static WORD32 iusace_window_shape[5] = {WIN_SEL_1, WIN_SEL_0, WIN_SEL_0, WIN_SEL_1, WIN_SEL_0};
 
@@ -443,225 +444,236 @@ IA_ERRORCODE iusace_grouping(ia_sfb_params_struct *pstr_sfb_prms, WORD32 num_cha
 IA_ERRORCODE iusace_quantize_spec(ia_sfb_params_struct *pstr_sfb_prms,
                                   WORD32 usac_independancy_flag, WORD32 num_chans,
                                   ia_usac_data_struct *ptr_usac_data,
                                   ia_usac_encoder_config_struct *ptr_usac_config, WORD32 chn,
-                                  WORD32 ele_id, WORD32 *is_quant_spec_zero) {
+                                  WORD32 ele_id, WORD32 *is_quant_spec_zero,
+                                  WORD32 *is_gain_limited) {
   IA_ERRORCODE err_code;
   WORD32 i = 0, sfb;
   WORD32 j = 0;
   WORD32 k;
   WORD32 max_bits;
   WORD32 ch;
   iusace_scratch_mem *pstr_scratch = &ptr_usac_data->str_scratch;
   WORD32 num_scfs[2];
   FLOAT32 **sfb_form_fac = &pstr_scratch->ptr_sfb_form_fac[0];
   WORD32 max_ch_dyn_bits[2] = {0};
   FLOAT32 ch_bit_dist[2];
   WORD32 constraints_fulfilled;
   WORD32 iterations = 0;
   WORD32 max_val;
   WORD32 kk, idx = 0;
 
   FLOAT32 *ptr_exp_spec = pstr_scratch->p_exp_spec;
   FLOAT32 *ptr_mdct_spec_float = pstr_scratch->p_mdct_spec_float;
   ia_psy_mod_data_struct *pstr_psy_data = ptr_usac_data->str_psy_mod.str_psy_data;
   ia_qc_out_data_struct *pstr_qc_out = &ptr_usac_data->str_qc_main.str_qc_out;
   ia_psy_mod_out_data_struct *pstr_psy_out = ptr_usac_data->str_psy_mod.str_psy_out_data;
   ia_qc_data_struct *pstr_qc_data = &ptr_usac_data->str_qc_main.str_qc_data[ele_id];
   ia_adj_thr_elem_struct *pstr_adj_thr_elem = &pstr_qc_data->str_adj_thr_ele;
   WORD32 *ptr_window_sequence = pstr_sfb_prms->window_sequence;
   WORD32 *ptr_max_sfb = pstr_sfb_prms->max_sfb;
   WORD32 *ptr_num_sfb = pstr_sfb_prms->num_sfb;
   WORD32 *ptr_num_window_groups = pstr_sfb_prms->num_window_groups;
   WORD32 bitres_bits, bitres_diff;
+  WORD32 gain;
 
   memset(num_scfs, 0, 2 * sizeof(num_scfs[0]));
 
   for (ch = chn; ch < chn + num_chans; ch++) {
     num_scfs[idx] = ptr_num_sfb[ch] * ptr_num_window_groups[ch];
 
     pstr_psy_out[ch].sfb_count = num_scfs[idx];
     pstr_psy_out[ch].sfb_per_group = num_scfs[idx] / ptr_num_window_groups[ch];
     pstr_psy_out[ch].window_sequence = pstr_psy_data[ch].window_sequence;
     pstr_psy_out[ch].window_shape = iusace_window_shape[pstr_psy_data[ch].window_sequence];
     pstr_psy_out[ch].ptr_spec_coeffs = ptr_usac_data->spectral_line_vector[ch];
     pstr_psy_out[ch].ptr_sfb_energy = pstr_psy_data[ch].ptr_sfb_energy_long;
     pstr_psy_out[ch].ptr_sfb_thr = pstr_psy_data[ch].ptr_sfb_thr_long;
     pstr_psy_out[ch].ptr_sfb_spread_energy = pstr_psy_data[ch].ptr_sfb_spreaded_energy_long;
 
     for (j = 0; j < num_scfs[idx]; j++) {
       pstr_psy_out[ch].sfb_offsets[j] = pstr_sfb_prms->grouped_sfb_offset[ch][j];
     }
     pstr_psy_out[ch].sfb_offsets[num_scfs[idx]] =
         pstr_sfb_prms->grouped_sfb_offset[ch][num_scfs[idx]];
 
     for (j = 0; j < MAX_NUM_GROUPED_SFB; j++) {
       sfb_form_fac[idx][j] = MIN_FLT_VAL;
     }
 
     iusace_calc_form_fac_per_chan(&pstr_psy_out[ch], pstr_scratch, idx);
     idx++;
   }
 
   pstr_qc_out->static_bits =
       iusace_count_static_bits(ptr_usac_data, ptr_usac_config, pstr_sfb_prms, pstr_psy_out,
                                num_chans, chn, usac_independancy_flag, ele_id);
 
   iusace_adj_bitrate(pstr_qc_data, pstr_qc_data->ch_bitrate, ptr_usac_config->core_sample_rate,
                      ptr_usac_config->ccfl);
   err_code =
       iusace_adj_thr(pstr_adj_thr_elem, pstr_psy_out, ch_bit_dist, pstr_qc_out,
                      pstr_qc_data->avg_bits - pstr_qc_out->static_bits, pstr_qc_data->bit_res_lvl,
                      pstr_qc_data->max_bitres_bits, pstr_qc_out->static_bits,
                      &pstr_qc_data->max_bit_fac, num_chans, chn, pstr_scratch);
   if (err_code != IA_NO_ERROR) {
     return err_code;
   }
 
   iusace_estimate_scfs_chan(pstr_psy_out, pstr_qc_out->str_qc_out_chan, num_chans, chn,
                             pstr_scratch);
   idx = 0;
   for (ch = 0; ch < num_chans; ch++) {
     max_ch_dyn_bits[ch] = (WORD32)floor(
         ch_bit_dist[ch] * (FLOAT32)(pstr_qc_data->avg_bits + pstr_qc_data->bit_res_lvl - 7 -
                                     pstr_qc_out->static_bits));
     idx++;
   }
 
   pstr_qc_out->dyn_bits = 0;
   idx = 0;
   for (ch = chn; ch < chn + num_chans; ch++) {
     iterations = 0;
-
+    gain = 0;
     for (kk = 0; kk < ptr_usac_config->ccfl; kk++) {
       ptr_exp_spec[kk] = (FLOAT32)pstr_psy_out[ch].ptr_spec_coeffs[kk];
       ptr_mdct_spec_float[kk] = (FLOAT32)pstr_psy_out[ch].ptr_spec_coeffs[kk];
     }
     do {
       constraints_fulfilled = 1;
       WORD32 quant_spec_is_zero = 1;
       if (iterations > 0) {
         for (WORD32 sfb_offs = 0; sfb_offs < pstr_psy_out[ch].sfb_count;
              sfb_offs += pstr_psy_out[ch].sfb_per_group) {
           for (sfb = 0; sfb < pstr_psy_out[ch].max_sfb_per_grp; sfb++) {
             WORD32 scalefactor = pstr_qc_out->str_qc_out_chan[idx].scalefactor[sfb + sfb_offs];
+            gain = MAX(gain, pstr_qc_out->str_qc_out_chan[idx].global_gain - scalefactor);
             iusace_quantize_lines(
                 pstr_qc_out->str_qc_out_chan[idx].global_gain - scalefactor,
                 pstr_psy_out[ch].sfb_offsets[sfb_offs + sfb + 1] -
                     pstr_psy_out[ch].sfb_offsets[sfb_offs + sfb],
                 ptr_exp_spec + pstr_psy_out[ch].sfb_offsets[sfb_offs + sfb],
                 pstr_qc_out->str_qc_out_chan[idx].quant_spec +
                     pstr_psy_out[ch].sfb_offsets[sfb_offs + sfb],
                 ptr_mdct_spec_float + pstr_psy_out[ch].sfb_offsets[sfb_offs + sfb]);
           }
         }
       }
       max_val =
           iusace_calc_max_val_in_sfb(pstr_psy_out[ch].sfb_count, pstr_psy_out[ch].max_sfb_per_grp,
                                      pstr_psy_out[ch].sfb_per_group, pstr_psy_out[ch].sfb_offsets,
                                      pstr_qc_out->str_qc_out_chan[idx].quant_spec);
       if (max_val > MAX_QUANT) {
         constraints_fulfilled = 0;
       }
 
       for (k = 0; k < num_scfs[idx]; k++) {
         for (i = pstr_sfb_prms->grouped_sfb_offset[ch][k];
              i < pstr_sfb_prms->grouped_sfb_offset[ch][k + 1]; i++) {
           ptr_usac_data->str_quant_info[idx].quant_degroup[i] =
               (WORD32)pstr_qc_out->str_qc_out_chan[idx].quant_spec[i];
           if (ptr_usac_data->str_quant_info[idx].quant_degroup[i] != 0) {
             quant_spec_is_zero = 0;
           }
         }
       }
 
       if (ptr_window_sequence[ch] == EIGHT_SHORT_SEQUENCE) {
         iusace_degroup_int(pstr_sfb_prms->grouped_sfb_offset[ch], ptr_num_sfb[ch],
                            ptr_usac_data->str_scratch.p_degroup_scratch,
                            ptr_usac_data->str_quant_info[idx].quant_degroup,
                            ptr_num_window_groups[ch], pstr_sfb_prms->window_group_length[ch],
                            ptr_usac_config->ccfl);
       }
 
       ptr_usac_data->str_quant_info[idx].max_spec_coeffs = 0;
       for (k = 0; k < ptr_max_sfb[ch]; k++) {
         ptr_usac_data->str_quant_info[idx].max_spec_coeffs +=
             pstr_sfb_prms->sfb_width_table[ch][k];
       }
 
       for (i = 0; i < num_scfs[idx]; i++) {
         ptr_usac_data->str_quant_info[idx].scale_factor[i] =
             pstr_qc_out->str_qc_out_chan[idx].global_gain -
             pstr_qc_out->str_qc_out_chan[idx].scalefactor[i] + SF_OFFSET;
       }
 
       max_bits = iusace_count_fd_bits(pstr_sfb_prms, ptr_usac_data, usac_independancy_flag,
                                       ptr_usac_config, ch, idx);
 
       if (max_bits > max_ch_dyn_bits[idx]) {
         constraints_fulfilled = 0;
       }
-      if (!constraints_fulfilled) {
-        pstr_qc_out->str_qc_out_chan[idx].global_gain++;
-      }
       if (quant_spec_is_zero == 1) {
         constraints_fulfilled = 1;
-        /*Bit consuption is exceding bit reserviour, there is no scope left for bit consumption
+        /*Bit consuption is exceding bit reservoir, there is no scope left for bit consumption
           reduction, as spectrum is zero. Hence breaking the quantization loop. */
         if (iterations > 0) {
           *is_quant_spec_zero = 1;
           max_bits = max_ch_dyn_bits[idx];
         }
       }
+      if ((gain == MAX_GAIN_INDEX) && (constraints_fulfilled == 0)) {
+        /* Bit consuption is exceding bit reservoir, there is no scope left for bit consumption
+           reduction, as gain has reached the maximum value. Hence breaking the quantization
+           loop. */
+        constraints_fulfilled = 1;
+        *is_gain_limited = 1;
+        max_bits = max_ch_dyn_bits[idx];
+      }
+      if (!constraints_fulfilled) {
+        pstr_qc_out->str_qc_out_chan[idx].global_gain++;
+      }
       iterations++;
     } while (!constraints_fulfilled);
 
     pstr_qc_out->dyn_bits += max_bits;
 
     if (ptr_usac_data->noise_filling[ele_id]) {
       WORD32 max_nf_sfb = ptr_max_sfb[ch];
 
       if (ptr_window_sequence[ch] != EIGHT_SHORT_SEQUENCE) {
         iusace_noise_filling(
             &ptr_usac_data->noise_level[idx], &ptr_usac_data->noise_offset[idx],
             ptr_usac_data->spectral_line_vector[ch], &ptr_usac_data->str_quant_info[idx],
             pstr_sfb_prms->grouped_sfb_offset[ch], max_nf_sfb, ptr_usac_config->ccfl,
             ptr_num_window_groups[ch], pstr_sfb_prms->window_group_length[ch], 160,
             ptr_usac_data->str_scratch.p_noise_filling_highest_tone);
       } else {
         iusace_noise_filling(
             &ptr_usac_data->noise_level[idx], &ptr_usac_data->noise_offset[idx],
             ptr_usac_data->spectral_line_vector[ch], &ptr_usac_data->str_quant_info[idx],
             pstr_sfb_prms->grouped_sfb_offset[ch], max_nf_sfb, ptr_usac_config->ccfl >> 3,
             ptr_num_window_groups[ch], pstr_sfb_prms->window_group_length[ch], 20,
             (FLOAT64 *)ptr_usac_data->str_scratch.p_noise_filling_highest_tone);
       }
 
       if (ptr_usac_data->noise_level[idx] == 0 && ptr_usac_data->noise_offset[idx] != 0 &&
           pstr_sfb_prms->common_win[ch]) {
         ptr_usac_data->complex_coef[ch] = 0;
       }
     }
     idx++;
   }
 
   pstr_adj_thr_elem->dyn_bits_last = pstr_qc_out->dyn_bits;
 
   bitres_bits = pstr_qc_data->max_bitres_bits - pstr_qc_data->bit_res_lvl;
   bitres_diff = pstr_qc_data->avg_bits - (pstr_qc_out->static_bits + pstr_qc_out->dyn_bits);
   pstr_qc_out->fill_bits = MAX(0, (bitres_diff - bitres_bits));
 
   if (pstr_qc_data->avg_bits > 0) {
     pstr_qc_data->bit_res_lvl +=
         pstr_qc_data->avg_bits -
         (pstr_qc_out->static_bits + pstr_qc_out->dyn_bits + pstr_qc_out->fill_bits);
   } else {
     pstr_qc_data->bit_res_lvl = pstr_qc_data->max_bits;
   }
 
   if (pstr_qc_data->bit_res_lvl < 0 ||
       pstr_qc_data->bit_res_lvl > pstr_qc_data->max_bitres_bits) {
     return IA_EXHEAACE_EXE_FATAL_USAC_INVALID_BIT_RSVR_LVL;
   }
 
   return IA_NO_ERROR;
 }
diff --git a/encoder/ixheaace_qc_main_hp.c b/encoder/ixheaace_qc_main_hp.c
index 1a039ea..0eae6e6 100644
--- a/encoder/ixheaace_qc_main_hp.c
+++ b/encoder/ixheaace_qc_main_hp.c
@@ -69,173 +69,183 @@
 #define OPT_QC_STACK
 IA_ERRORCODE ia_enhaacplus_enc_qc_main(
     ixheaace_qc_state *pstr_qc_state, WORD32 num_channels, ixheaace_element_bits *pstr_el_bits,
     ixheaace_psy_out_channel psy_out_ch[IXHEAACE_MAX_CH_IN_BS_ELE],
     ixheaace_psy_out_element *pstr_psy_out_element,
     ixheaace_qc_out_channel pstr_qc_out_ch[IXHEAACE_MAX_CH_IN_BS_ELE],
     ixheaace_qc_out_element *pstr_qc_out_element, WORD32 ancillary_data_bytes,
     ixheaace_aac_tables *pstr_aac_tables, WORD32 adts_flag, WORD32 aot, WORD32 stat_bits_flag,
     WORD32 flag_last_element, WORD32 frame_len_long, WORD8 *ptr_scratch,
-    WORD32 *is_quant_spec_zero) {
+    WORD32 *is_quant_spec_zero, WORD32 *is_gain_limited) {
   IA_ERRORCODE err_code;
   WORD32 ch;
   WORD32 i = 0;
   WORD32 k = 0;
   WORD32 j = 0;
   WORD32 iterations = 0;
   WORD32 constraints_fulfilled;
   WORD32 ch_dyn_bits;
   WORD32 max_ch_dyn_bits[IXHEAACE_MAX_CH_IN_BS_ELE];
   FLOAT32 ch_bit_dist[IXHEAACE_MAX_CH_IN_BS_ELE];
   ixheaace_qc_stack *ptr_stack = (ixheaace_qc_stack *)ptr_scratch;
   ptr_scratch += sizeof(ixheaace_qc_stack);
 
   ia_adj_thr_elem_struct *pstr_adj_thr_elem = &pstr_qc_state->str_adj_thr.str_adj_thr_ele;
+  WORD32 gain;
 
   if (pstr_el_bits->bit_res_level < 0) {
     return IA_EXHEAACE_EXE_FATAL_INVALID_BIT_RES_LEVEL;
   }
 
   if (pstr_el_bits->bit_res_level > pstr_el_bits->max_bit_res_bits) {
     return IA_EXHEAACE_EXE_FATAL_INVALID_BIT_RES_LEVEL;
   }
   pstr_qc_out_element->static_bits_used =
       ia_enhaacplus_enc_count_static_bitdemand(psy_out_ch, pstr_psy_out_element, num_channels,
                                                aot, adts_flag, stat_bits_flag, flag_last_element);
 
   if (ancillary_data_bytes) {
     pstr_qc_out_element->anc_bits_used =
         7 + 8 * (ancillary_data_bytes + (ancillary_data_bytes >= 15));
   } else {
     pstr_qc_out_element->anc_bits_used = 0;
   }
 
   for (ch = 0; ch < num_channels; ch++) {
     iaace_calc_form_fac_per_chan(ptr_stack->sfb_form_fac[ch],
                                  ptr_stack->sfb_num_relevant_lines[ch], &psy_out_ch[ch],
                                  ptr_stack->sfb_ld_energy[ch]);
   }
 
   iaace_adjust_threshold(
       &pstr_qc_state->str_adj_thr, pstr_adj_thr_elem, psy_out_ch, ch_bit_dist,
       pstr_qc_out_element,
       pstr_el_bits->average_bits - pstr_qc_out_element->static_bits_used -
           pstr_qc_out_element->anc_bits_used,
       pstr_el_bits->bit_res_level, pstr_el_bits->max_bit_res_bits,
       pstr_qc_out_element->static_bits_used + pstr_qc_out_element->anc_bits_used,
       &pstr_qc_state->max_bit_fac, ptr_stack->sfb_num_relevant_lines[0],
       ptr_stack->sfb_ld_energy[0], num_channels, 0, aot, ptr_scratch);
 
   iaace_estimate_scfs_chan(psy_out_ch, pstr_qc_out_ch, ptr_stack->sfb_form_fac,
                            ptr_stack->sfb_num_relevant_lines, num_channels, 0, frame_len_long);
 
   for (ch = 0; ch < num_channels; ch++) {
     max_ch_dyn_bits[ch] =
         (pstr_el_bits->average_bits + pstr_el_bits->bit_res_level - 7 -
          pstr_qc_out_element->static_bits_used - pstr_qc_out_element->anc_bits_used);
 
     max_ch_dyn_bits[ch] = (WORD32)floor(ch_bit_dist[ch] * (FLOAT32)(max_ch_dyn_bits[ch]));
   }
 
   pstr_qc_out_element->dyn_bits_used = 0;
 
   for (ch = 0; ch < num_channels; ch++) {
     /* now loop until bitstream constraints (ch_dyn_bits < maxChDynBits)
        are fulfilled */
     WORD32 spec_idx, sfb_offs, sfb;
     iterations = 0;
+    gain = 0;
     for (spec_idx = 0; spec_idx < frame_len_long; spec_idx++) {
       ptr_stack->exp_spec[spec_idx] = (FLOAT32)psy_out_ch[ch].ptr_spec_coeffs[spec_idx];
       ptr_stack->mdct_spec_float[spec_idx] = (FLOAT32)psy_out_ch[ch].ptr_spec_coeffs[spec_idx];
     }
     do {
       WORD32 max_val;
       constraints_fulfilled = 1;
       WORD32 quant_spec_is_zero = 1;
       if (iterations > 0) {
         for (sfb_offs = 0; sfb_offs < psy_out_ch[ch].sfb_count;
              sfb_offs += psy_out_ch[ch].sfb_per_group) {
           for (sfb = 0; sfb < psy_out_ch[ch].max_sfb_per_grp; sfb++) {
             WORD32 scalefactor = pstr_qc_out_ch[ch].scalefactor[sfb + sfb_offs];
+            gain = MAX(gain, pstr_qc_out_ch[ch].global_gain - scalefactor);
             iaace_quantize_lines(
                 pstr_qc_out_ch[ch].global_gain - scalefactor,
                 psy_out_ch[ch].sfb_offsets[sfb_offs + sfb + 1] -
                     psy_out_ch[ch].sfb_offsets[sfb_offs + sfb],
                 ptr_stack->exp_spec + psy_out_ch[ch].sfb_offsets[sfb_offs + sfb],
                 pstr_qc_out_ch[ch].quant_spec + psy_out_ch[ch].sfb_offsets[sfb_offs + sfb],
                 ptr_stack->mdct_spec_float + psy_out_ch[ch].sfb_offsets[sfb_offs + sfb]);
           }
         }
       }
 
       max_val = iaace_calc_max_val_in_sfb(
           psy_out_ch[ch].sfb_count, psy_out_ch[ch].max_sfb_per_grp, psy_out_ch[ch].sfb_per_group,
           psy_out_ch[ch].sfb_offsets, pstr_qc_out_ch[ch].quant_spec,
           pstr_qc_out_ch[ch].max_val_in_sfb);
 
       if (max_val > MAXIMUM_QUANT) {
         constraints_fulfilled = 0;
       }
 
       for (k = 0; ((k < psy_out_ch[ch].sfb_count) && (quant_spec_is_zero));
            k += psy_out_ch[ch].sfb_per_group) {
         for (i = 0; ((i < psy_out_ch[ch].max_sfb_per_grp) && (quant_spec_is_zero)); i++) {
           for (j = psy_out_ch[ch].sfb_offsets[i+k]; j < psy_out_ch[ch].sfb_offsets[i+k+1]; j++) {
             if (pstr_qc_out_ch[ch].quant_spec[j] != 0) {
               quant_spec_is_zero = 0;
               break;
             }
           }
         }
       }
       err_code = ia_enhaacplus_enc_dyn_bitcount(
           pstr_qc_out_ch[ch].quant_spec, pstr_qc_out_ch[ch].max_val_in_sfb,
           pstr_qc_out_ch[ch].scalefactor, psy_out_ch[ch].window_sequence,
           psy_out_ch[ch].sfb_count, psy_out_ch[ch].max_sfb_per_grp, psy_out_ch[ch].sfb_per_group,
           psy_out_ch[ch].sfb_offsets, &pstr_qc_out_ch[ch].section_data,
           pstr_qc_state->side_info_tab_long, pstr_qc_state->side_info_tab_short,
           pstr_aac_tables->pstr_huff_tab, pstr_qc_state->qc_scr.shared_buffer_2, aot,
           &ch_dyn_bits);
 
       if (err_code != IA_NO_ERROR) {
         return err_code;
       }
 
       if (ch_dyn_bits >= max_ch_dyn_bits[ch]) {
         constraints_fulfilled = 0;
       }
 
-      if (!constraints_fulfilled) {
-        pstr_qc_out_ch[ch].global_gain++;
-      }
-
       if (quant_spec_is_zero == 1) {
         constraints_fulfilled = 1;
-        /*Bit consuption is exceding bit reserviour, there is no scope left for bit consumption
+        /*Bit consuption is exceding bit reservoir, there is no scope left for bit consumption
           reduction, as spectrum is zero. Hence breaking the quantization loop. */
         if (iterations > 0) {
           *is_quant_spec_zero = 1;
           ch_dyn_bits = max_ch_dyn_bits[ch];
         }
       }
+      if ((gain == MAX_GAIN_INDEX) && (constraints_fulfilled == 0)) {
+        /* Bit consuption is exceding bit reservoir, there is no scope left for bit consumption
+           reduction, as gain has reached the maximum value. Hence breaking the quantization
+           loop. */
+        constraints_fulfilled = 1;
+        *is_gain_limited = 1;
+        ch_dyn_bits = max_ch_dyn_bits[ch];
+      }
+      if (!constraints_fulfilled) {
+        pstr_qc_out_ch[ch].global_gain++;
+      }
       iterations++;
 
     } while (!constraints_fulfilled);
 
     pstr_qc_out_element->dyn_bits_used += ch_dyn_bits;
 
     pstr_qc_out_ch[ch].grouping_mask = psy_out_ch[ch].grouping_mask;
     pstr_qc_out_ch[ch].win_shape = psy_out_ch[ch].window_shape;
   }
 
   pstr_adj_thr_elem->dyn_bits_last = pstr_qc_out_element->dyn_bits_used;
   {
     WORD32 bit_res_space = pstr_el_bits->max_bit_res_bits - pstr_el_bits->bit_res_level;
     WORD32 delta_bit_res = pstr_el_bits->average_bits - (pstr_qc_out_element->static_bits_used +
                                                          pstr_qc_out_element->dyn_bits_used +
                                                          pstr_qc_out_element->anc_bits_used);
 
     pstr_qc_out_element->fill_bits = MAX(0, (delta_bit_res - bit_res_space));
   }
 
   return IA_NO_ERROR;
 }
diff --git a/encoder/ixheaace_qc_util.h b/encoder/ixheaace_qc_util.h
index 3c9b025..3886472 100644
--- a/encoder/ixheaace_qc_util.h
+++ b/encoder/ixheaace_qc_util.h
@@ -33,12 +33,12 @@ IA_ERRORCODE ia_enhaacplus_enc_qc_init(ixheaace_qc_state *pstr_qc_state, WORD32
 IA_ERRORCODE ia_enhaacplus_enc_qc_main(
     ixheaace_qc_state *pstr_qc_state, WORD32 num_channels, ixheaace_element_bits *pstr_el_bits,
     ixheaace_psy_out_channel psy_out_ch[IXHEAACE_MAX_CH_IN_BS_ELE],
     ixheaace_psy_out_element *pstr_psy_out_element,
     ixheaace_qc_out_channel pstr_qc_out_ch[IXHEAACE_MAX_CH_IN_BS_ELE],
     ixheaace_qc_out_element *pstr_qc_out_element, WORD32 ancillary_data_bytes,
     ixheaace_aac_tables *pstr_aac_tables, WORD32 adts_flag, WORD32 aot, WORD32 stat_bits_flag,
     WORD32 flag_last_element, WORD32 frame_len_long, WORD8 *ptr_scratch,
-    WORD32 *is_quant_spec_zero);
+    WORD32 *is_quant_spec_zero, WORD32 *is_gain_limited);
 
 VOID ia_enhaacplus_enc_update_bit_reservoir(ixheaace_qc_state *pstr_qc_kernel,
                                             ixheaace_qc_out *pstr_qc_out);
diff --git a/encoder/ixheaace_struct_def.h b/encoder/ixheaace_struct_def.h
index 23ad23d..4f0c3c7 100644
--- a/encoder/ixheaace_struct_def.h
+++ b/encoder/ixheaace_struct_def.h
@@ -63,48 +63,49 @@ typedef struct {
 typedef struct ixheaace_state_struct {
   // The first AACENC_BLOCKSIZE*2 elements are the same as that of the encoder i/p buffer.
   // The usage of input buffer as scratch is avoided here
   FLOAT32 *inp_delay;
   FLOAT32 *time_signal_mps;
   FLOAT32 *time_signal;
   UWORD8 *mps_bs;
   ixheaace_config_struct *pstr_config[MAXIMUM_BS_ELE];
   WORD32 aot;
   WORD32 mps_enable;
   WORD32 mps_tree_config;
   WORD32 i_out_bytes;
   UWORD32 ui_in_bytes;
   UWORD32 ui_input_over;
   UWORD32 ui_init_done;
   /* other state structure variables */
   WORD32 downsample[MAXIMUM_BS_ELE];
   WORD32 buffer_offset;
   iexheaac_encoder_str *aac_enc_pers_mem[MAXIMUM_BS_ELE];
   VOID *temp_buff_aac;
   ixheaace_bit_buf bit_stream;
   ixheaace_bit_buf_handle pstr_bit_stream_handle;
   struct ixheaace_str_sbr_enc *spectral_band_replication_enc_pers_mem[MAXIMUM_BS_ELE];
   VOID *temp_buff_sbr;
   VOID *ptr_temp_buff_resamp;
   ixheaace_iir21_resampler down_sampler[MAXIMUM_BS_ELE][IXHEAACE_MAX_CH_IN_BS_ELE];
   ixheaace_iir_sos_resampler down_samp_sos[MAXIMUM_BS_ELE][IXHEAACE_MAX_CH_IN_BS_ELE];
   ixheaace_iir_sos_resampler up_sampler[MAXIMUM_BS_ELE][IXHEAACE_MAX_CH_IN_BS_ELE];
   ixheaace_iir21_resampler hbe_down_sampler[MAXIMUM_BS_ELE][IXHEAACE_MAX_CH_IN_BS_ELE];
   ixheaace_iir_sos_resampler hbe_down_samp_sos[MAXIMUM_BS_ELE][IXHEAACE_MAX_CH_IN_BS_ELE];
   ixheaace_iir_sos_resampler hbe_up_sampler[MAXIMUM_BS_ELE][IXHEAACE_MAX_CH_IN_BS_ELE];
   UWORD8 num_anc_data_bytes[MAXIMUM_BS_ELE][IXHEAACE_MAX_CH_IN_BS_ELE];
   UWORD8 anc_data_bytes[MAXIMUM_BS_ELE][IXHEAACE_MAX_PAYLOAD_SIZE];
   WORD32 total_fill_bits;
   int *scratch_addr;
   char flag_error;
   FLOAT32 **ptr_in_buf;
   FLOAT32 **pp_drc_in_buf;
   FLOAT32 *mps_scratch;
   ixheaace_audio_specific_config_struct audio_specific_config;
   ia_usac_data_struct str_usac_enc_data;
   ia_bit_buf_struct str_bit_buf;
   ixheaace_mps_212_memory_struct *mps_pers_mem;
   ixheaace_mps_515_memory_struct *mps_515_pers_mem;
   WORD32 is_quant_spec_zero;
+  WORD32 is_gain_limited;
 } ixheaace_state_struct;
 
 typedef struct ixheaace_api_struct {
diff --git a/test/encoder/ixheaace_error.c b/test/encoder/ixheaace_error.c
index ababe4e..eccb2f7 100644
--- a/test/encoder/ixheaace_error.c
+++ b/test/encoder/ixheaace_error.c
@@ -117,15 +117,17 @@ pWORD8 ppb_ia_enhaacplus_enc_sbr_init_fatal[IA_MAX_ERROR_SUB_CODE] = {
 /*****************************************************************************/
 /* Class 2: Execution Errors
 *****************************************************************************/
 /* Non Fatal Errors */
 pWORD8 ppb_ia_enhaacplus_enc_aac_exe_non_fatal[IA_MAX_ERROR_SUB_CODE] = {
-    (pWORD8) "Quantization zero spectrum detected"};
+    (pWORD8) "Quantization zero spectrum detected",
+    (pWORD8) "Insufficient bit reservoir for non zero spectrum"};
 
 pWORD8 ppb_ia_enhaacplus_enc_mps_exe_non_fatal[IA_MAX_ERROR_SUB_CODE] = {
     (pWORD8) "Encoding Failed", (pWORD8) "Invalid MPS data bands"};
 
 pWORD8 ppb_ia_enhaacplus_enc_usac_exe_non_fatal[IA_MAX_ERROR_SUB_CODE] = {
-    (pWORD8) "Quantization zero spectrum detected"};
+    (pWORD8) "Quantization zero spectrum detected",
+    (pWORD8) "Insufficient bit reservoir for non zero spectrum"};
 
 pWORD8 ppb_ia_enhaacplus_enc_esbr_exe_non_fatal[IA_MAX_ERROR_SUB_CODE] = {
     (pWORD8) "Invalid bandwidth index encountered",
