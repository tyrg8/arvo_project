commit 6f7a57eaa0ef872af87ee3333a4a0fa1bfb607ce
Author: Todd Hansen <32498632+thansen24@users.noreply.github.com>
Date:   Wed Sep 15 16:57:29 2021 -0500

    [C#] Using 'global::' as qualifying_start_ within BaseGenerator (#6767)
    
    * Update idl_gen_csharp.cpp
    
    Change csharp generator to use "global::" for it's qualifying_start_ to disambiguate namespaces
    
    * regenerate testing files
    
    regenerate testing files
    
    * Missed TableInC.cs
    
    updated with global prefix
    
    * Remove "global::" from qualifying_start_ for csharp generator
    
    * C# global alias
    
    * Tests and docs for --cs-global-alias
    
    Add tests for --cs-global-alias to demonstrate use case for why it's needed.
    
    Add documentation to Compiler.md
    
    * Add also to help text
    
    Add also to help text

diff --git a/docs/source/Compiler.md b/docs/source/Compiler.md
index 0d2d51ff..249ecdde 100644
--- a/docs/source/Compiler.md
+++ b/docs/source/Compiler.md
@@ -61,162 +61,164 @@ For any data input files:
 Additional options:
 
 -   `-o PATH` : Output all generated files to PATH (either absolute, or
     relative to the current directory). If omitted, PATH will be the
     current directory. PATH should end in your systems path separator,
     e.g. `/` or `\`.
 
 -   `-I PATH` : when encountering `include` statements, attempt to load the
     files from this path. Paths will be tried in the order given, and if all
     fail (or none are specified) it will try to load relative to the path of
     the schema file being parsed.
 
 -   `-M` : Print make rules for generated files.
 
 -   `--strict-json` : Require & generate strict JSON (field names are enclosed
     in quotes, no trailing commas in tables/vectors). By default, no quotes are
     required/generated, and trailing commas are allowed.
 
 -   `--allow-non-utf8` : Pass non-UTF-8 input through parser and emit nonstandard
     \x escapes in JSON. (Default is to raise parse error on non-UTF-8 input.)
 
--  `--natural-utf8` : Output strings with UTF-8 as human-readable strings.
+-   `--natural-utf8` : Output strings with UTF-8 as human-readable strings.
      By default, UTF-8 characters are printed as \uXXXX escapes."
 
 -   `--defaults-json` : Output fields whose value is equal to the default value
     when writing JSON text.
 
 -   `--no-prefix` : Don't prefix enum values in generated C++ by their enum
     type.
 
 -   `--scoped-enums` : Use C++11 style scoped and strongly typed enums in
     generated C++. This also implies `--no-prefix`.
 
 -   `--gen-includes` : (deprecated), this is the default behavior.
                        If the original behavior is required (no include
 	                   statements) use `--no-includes.`
 
 -   `--no-includes` : Don't generate include statements for included schemas the
     generated file depends on (C++ / Python).
 
 -   `--gen-mutable` : Generate additional non-const accessors for mutating
     FlatBuffers in-place.
 
 -   `--gen-onefile` : Generate single output file for C# and Go.
 
 -   `--gen-name-strings` : Generate type name functions for C++.
 
 -   `--gen-object-api` : Generate an additional object-based API. This API is
     more convenient for object construction and mutation than the base API,
     at the cost of efficiency (object allocation). Recommended only to be used
     if other options are insufficient.
 
 -   `--gen-compare`  :  Generate operator== for object-based API types.
 
 -   `--gen-nullable` : Add Clang _Nullable for C++ pointer. or @Nullable for Java.
 
 -   `--gen-generated` : Add @Generated annotation for Java.
 
 -   `--gen-jvmstatic` : Add @JvmStatic annotation for Kotlin methods
     in companion object for interop from Java to Kotlin.
 
 -   `--gen-all` : Generate not just code for the current schema files, but
     for all files it includes as well. If the language uses a single file for
     output (by default the case for C++ and JS), all code will end up in
     this one file.
 
 -   `--cpp-include` : Adds an #include in generated file
 
 -   `--cpp-ptr-type T` : Set object API pointer type (default std::unique_ptr)
 
 -   `--cpp-str-type T` : Set object API string type (default std::string)
     T::c_str(), T::length() and T::empty() must be supported.
     The custom type also needs to be constructible from std::string (see the
 	--cpp-str-flex-ctor option to change this behavior).
 
 -   `--cpp-str-flex-ctor` : Don't construct custom string types by passing
     std::string from Flatbuffers, but (char* + length). This allows efficient
 	construction of custom string types, including zero-copy construction.
 
 -   `--no-cpp-direct-copy` : Don't generate direct copy methods for C++
     object-based API.
 
 -   `--cpp-std CPP_STD` : Generate a C++ code using features of selected C++ standard.
      Supported `CPP_STD` values:
     * `c++0x` - generate code compatible with old compilers (VS2010),
     * `c++11` - use C++11 code generator (default),
     * `c++17` - use C++17 features in generated code (experimental).
 
 -   `--object-prefix` : Customise class prefix for C++ object-based API.
 
 -   `--object-suffix` : Customise class suffix for C++ object-based API.
 
 -   `--go-namespace` : Generate the overrided namespace in Golang.
 
 -   `--go-import` : Generate the overrided import for flatbuffers in Golang.
      (default is "github.com/google/flatbuffers/go").
 
 -   `--raw-binary` : Allow binaries without a file_indentifier to be read.
     This may crash flatc given a mismatched schema.
 
 -   `--size-prefixed` : Input binaries are size prefixed buffers.
 
 -   `--proto`: Expect input files to be .proto files (protocol buffers).
     Output the corresponding .fbs file.
     Currently supports: `package`, `message`, `enum`, nested declarations,
     `import` (use `-I` for paths), `extend`, `oneof`, `group`.
     Does not support, but will skip without error: `option`, `service`,
     `extensions`, and most everything else.
 
 -   `--oneof-union` : Translate .proto oneofs to flatbuffer unions.
 
 -   `--grpc` : Generate GRPC interfaces for the specified languages.
 
 -   `--schema`: Serialize schemas instead of JSON (use with -b). This will
     output a binary version of the specified schema that itself corresponds
     to the reflection/reflection.fbs schema. Loading this binary file is the
     basis for reflection functionality.
 
 -   `--bfbs-comments`: Add doc comments to the binary schema files.
 
 -   `--conform FILE` : Specify a schema the following schemas should be
     an evolution of. Gives errors if not. Useful to check if schema
     modifications don't break schema evolution rules.
 
 -   `--conform-includes PATH` : Include path for the schema given with
     `--conform PATH`.
 
 -   `--filename-suffix SUFFIX` : The suffix appended to the generated
     file names. Default is '_generated'.
 
 -   `--filename-ext EXTENSION` : The extension appended to the generated
     file names. Default is language-specific (e.g. "h" for C++). This
     should not be used when multiple languages are specified.
 
 -   `--include-prefix PATH` : Prefix this path to any generated include
     statements.
 
 -   `--keep-prefix` : Keep original prefix of schema include statement.
 
 -   `--reflect-types` : Add minimal type reflection to code generation.
 
 -   `--reflect-names` : Add minimal type/name reflection.
 
 -   `--root-type T` : Select or override the default root_type.
 
 -   `--require-explicit-ids` : When parsing schemas, require explicit ids (id: x).
 
 -   `--force-defaults` : Emit default values in binary output from JSON.
 
 -   `--force-empty` : When serializing from object API representation, force
      strings and vectors to empty rather than null.
 
 -   `--force-empty-vectors` : When serializing from object API representation, force
      vectors to empty rather than null.
 
 -   `--flexbuffers` : Used with "binary" and "json" options, it generates
      data using schema-less FlexBuffers.
 
--    `--no-warnings` : Inhibit all warning messages.
+-   `--no-warnings` : Inhibit all warning messages.
+
+-   `--cs-global-alias` : Prepend `global::` to all user generated csharp classes and structs.
 
 NOTE: short-form options for generators are deprecated, use the long form
 whenever possible.
diff --git a/include/flatbuffers/idl.h b/include/flatbuffers/idl.h
index 9224a90a..48280493 100644
--- a/include/flatbuffers/idl.h
+++ b/include/flatbuffers/idl.h
@@ -539,151 +539,153 @@ struct ServiceDef : public Definition {
 // Container of options that may apply to any of the source/text generators.
 struct IDLOptions {
   // field case style options for C++
   enum CaseStyle { CaseStyle_Unchanged = 0, CaseStyle_Upper, CaseStyle_Lower };
 
   bool gen_jvmstatic;
   // Use flexbuffers instead for binary and text generation
   bool use_flexbuffers;
   bool strict_json;
   bool output_default_scalars_in_json;
   int indent_step;
   bool output_enum_identifiers;
   bool prefixed_enums;
   bool scoped_enums;
   bool include_dependence_headers;
   bool mutable_buffer;
   bool one_file;
   bool proto_mode;
   bool proto_oneof_union;
   bool generate_all;
   bool skip_unexpected_fields_in_json;
   bool generate_name_strings;
   bool generate_object_based_api;
   bool gen_compare;
   std::string cpp_object_api_pointer_type;
   std::string cpp_object_api_string_type;
   bool cpp_object_api_string_flexible_constructor;
   CaseStyle cpp_object_api_field_case_style;
   bool cpp_direct_copy;
   bool gen_nullable;
   bool java_checkerframework;
   bool gen_generated;
   std::string object_prefix;
   std::string object_suffix;
   bool union_value_namespacing;
   bool allow_non_utf8;
   bool natural_utf8;
   std::string include_prefix;
   bool keep_include_path;
   bool binary_schema_comments;
   bool binary_schema_builtins;
   bool binary_schema_gen_embed;
   std::string go_import;
   std::string go_namespace;
   bool protobuf_ascii_alike;
   bool size_prefixed;
   std::string root_type;
   bool force_defaults;
   bool java_primitive_has_method;
   bool cs_gen_json_serializer;
   std::vector<std::string> cpp_includes;
   std::string cpp_std;
   bool cpp_static_reflection;
   std::string proto_namespace_suffix;
   std::string filename_suffix;
   std::string filename_extension;
   bool no_warnings;
   std::string project_root;
+  bool cs_global_alias;
 
   // Possible options for the more general generator below.
   enum Language {
     kJava = 1 << 0,
     kCSharp = 1 << 1,
     kGo = 1 << 2,
     kCpp = 1 << 3,
     kPython = 1 << 5,
     kPhp = 1 << 6,
     kJson = 1 << 7,
     kBinary = 1 << 8,
     kTs = 1 << 9,
     kJsonSchema = 1 << 10,
     kDart = 1 << 11,
     kLua = 1 << 12,
     kLobster = 1 << 13,
     kRust = 1 << 14,
     kKotlin = 1 << 15,
     kSwift = 1 << 16,
     kMAX
   };
 
   enum MiniReflect { kNone, kTypes, kTypesAndNames };
 
   MiniReflect mini_reflect;
 
   // If set, require all fields in a table to be explicitly numbered.
   bool require_explicit_ids;
 
   // The corresponding language bit will be set if a language is included
   // for code generation.
   unsigned long lang_to_generate;
 
   // If set (default behavior), empty string fields will be set to nullptr to
   // make the flatbuffer more compact.
   bool set_empty_strings_to_null;
 
   // If set (default behavior), empty vector fields will be set to nullptr to
   // make the flatbuffer more compact.
   bool set_empty_vectors_to_null;
 
   IDLOptions()
       : gen_jvmstatic(false),
         use_flexbuffers(false),
         strict_json(false),
         output_default_scalars_in_json(false),
         indent_step(2),
         output_enum_identifiers(true),
         prefixed_enums(true),
         scoped_enums(false),
         include_dependence_headers(true),
         mutable_buffer(false),
         one_file(false),
         proto_mode(false),
         proto_oneof_union(false),
         generate_all(false),
         skip_unexpected_fields_in_json(false),
         generate_name_strings(false),
         generate_object_based_api(false),
         gen_compare(false),
         cpp_object_api_pointer_type("std::unique_ptr"),
         cpp_object_api_string_flexible_constructor(false),
         cpp_object_api_field_case_style(CaseStyle_Unchanged),
         cpp_direct_copy(true),
         gen_nullable(false),
         java_checkerframework(false),
         gen_generated(false),
         object_suffix("T"),
         union_value_namespacing(true),
         allow_non_utf8(false),
         natural_utf8(false),
         keep_include_path(false),
         binary_schema_comments(false),
         binary_schema_builtins(false),
         binary_schema_gen_embed(false),
         protobuf_ascii_alike(false),
         size_prefixed(false),
         force_defaults(false),
         java_primitive_has_method(false),
         cs_gen_json_serializer(false),
         cpp_static_reflection(false),
         filename_suffix("_generated"),
         filename_extension(),
         no_warnings(false),
         project_root(""),
+        cs_global_alias(false),
         mini_reflect(IDLOptions::kNone),
         require_explicit_ids(false),
         lang_to_generate(0),
         set_empty_strings_to_null(true),
         set_empty_vectors_to_null(true) {}
 };
 
 // This encapsulates where the parser is in the current source file.
diff --git a/src/flatc.cpp b/src/flatc.cpp
index 3016abec..1505783c 100644
--- a/src/flatc.cpp
+++ b/src/flatc.cpp
@@ -59,133 +59,134 @@ void FlatCompiler::Error(const std::string &err, bool usage,
 std::string FlatCompiler::GetUsageString(const char *program_name) const {
   std::stringstream ss;
   ss << "Usage: " << program_name << " [OPTION]... FILE... [-- FILE...]\n";
   for (size_t i = 0; i < params_.num_generators; ++i) {
     const Generator &g = params_.generators[i];
 
     std::stringstream full_name;
     full_name << std::setw(16) << std::left << g.generator_opt_long;
     const char *name = g.generator_opt_short ? g.generator_opt_short : "  ";
     const char *help = g.generator_help;
 
     ss << "  " << full_name.str() << " " << name << "    " << help << ".\n";
   }
   // clang-format off
 
   // Output width
   // 12345678901234567890123456789012345678901234567890123456789012345678901234567890
   ss <<
     "  -o PATH                Prefix PATH to all generated files.\n"
     "  -I PATH                Search for includes in the specified path.\n"
     "  -M                     Print make rules for generated files.\n"
     "  --version              Print the version number of flatc and exit.\n"
     "  --strict-json          Strict JSON: field names must be / will be quoted,\n"
     "                         no trailing commas in tables/vectors.\n"
     "  --allow-non-utf8       Pass non-UTF-8 input through parser and emit nonstandard\n"
     "                         \\x escapes in JSON. (Default is to raise parse error on\n"
     "                         non-UTF-8 input.)\n"
     "  --natural-utf8         Output strings with UTF-8 as human-readable strings.\n"
     "                         By default, UTF-8 characters are printed as \\uXXXX escapes.\n"
     "  --defaults-json        Output fields whose value is the default when\n"
     "                         writing JSON\n"
     "  --unknown-json         Allow fields in JSON that are not defined in the\n"
     "                         schema. These fields will be discared when generating\n"
     "                         binaries.\n"
     "  --no-prefix            Don\'t prefix enum values with the enum type in C++.\n"
     "  --scoped-enums         Use C++11 style scoped and strongly typed enums.\n"
     "                         also implies --no-prefix.\n"
     "  --gen-includes         (deprecated), this is the default behavior.\n"
     "                         If the original behavior is required (no include\n"
     "                         statements) use --no-includes.\n"
     "  --no-includes          Don\'t generate include statements for included\n"
     "                         schemas the generated file depends on (C++ / Python).\n"
     "  --gen-mutable          Generate accessors that can mutate buffers in-place.\n"
     "  --gen-onefile          Generate single output file for C# and Go.\n"
     "  --gen-name-strings     Generate type name functions for C++ and Rust.\n"
     "  --gen-object-api       Generate an additional object-based API.\n"
     "  --gen-compare          Generate operator== for object-based API types.\n"
     "  --gen-nullable         Add Clang _Nullable for C++ pointer. or @Nullable for Java\n"
     "  --java-checkerframe    work Add @Pure for Java.\n"
     "  --gen-generated        Add @Generated annotation for Java\n"
     "  --gen-jvmstatic        Add @JvmStatic annotation for Kotlin methods\n"
     "                         in companion object for interop from Java to Kotlin.\n"
     "  --gen-all              Generate not just code for the current schema files,\n"
     "                         but for all files it includes as well.\n"
     "                         If the language uses a single file for output (by default\n"
     "                         the case for C++ and JS), all code will end up in this one\n"
     "                         file.\n"
     "  --cpp-include          Adds an #include in generated file.\n"
     "  --cpp-ptr-type T       Set object API pointer type (default std::unique_ptr).\n"
     "  --cpp-str-type T       Set object API string type (default std::string).\n"
     "                         T::c_str(), T::length() and T::empty() must be supported.\n"
     "                         The custom type also needs to be constructible from std::string\n"
     "                         (see the --cpp-str-flex-ctor option to change this behavior).\n"
     "  --cpp-str-flex-ctor    Don't construct custom string types by passing std::string\n"
     "                         from Flatbuffers, but (char* + length).\n"
     "  --cpp-field-case-style STYLE Generate C++ fields using selected case style.\n"
     "                         Supported STYLE values:\n"
     "                          * 'unchanged' - leave unchanged (default);\n"
     "                          * 'upper' - schema snake_case emits UpperCamel;\n"
     "                          * 'lower' - schema snake_case emits lowerCamel.\n"
     "  --cpp-std CPP_STD      Generate a C++ code using features of selected C++ standard.\n"
     "                         Supported CPP_STD values:\n"
     "                          * 'c++0x' - generate code compatible with old compilers;\n"
     "                          * 'c++11' - use C++11 code generator (default);\n"
     "                          * 'c++17' - use C++17 features in generated code (experimental).\n"
     "  --cpp-static-reflection When using C++17, generate extra code to provide compile-time\n"
     "                          (static) reflection of Flatbuffers types.  Requires --cpp-std\n"
     "                          to be \"c++17\" or higher.\n"
     "  --object-prefix        Customise class prefix for C++ object-based API.\n"
     "  --object-suffix        Customise class suffix for C++ object-based API.\n"
     "                         Default value is \"T\".\n"
     "  --go-namespace         Generate the overriding namespace in Golang.\n"
     "  --go-import            Generate the overriding import for flatbuffers in Golang\n"
     "                         (default is \"github.com/google/flatbuffers/go\").\n"
     "  --raw-binary           Allow binaries without file_identifier to be read.\n"
     "                         This may crash flatc given a mismatched schema.\n"
     "  --size-prefixed        Input binaries are size prefixed buffers.\n"
     "  --proto                Input is a .proto, translate to .fbs.\n"
     "  --proto-namespace-suffix Add this namespace to any flatbuffers generated\n"
     "    SUFFIX                 from protobufs.\n"
     "  --oneof-union          Translate .proto oneofs to flatbuffer unions.\n"
     "  --grpc                 Generate GRPC interfaces for the specified languages.\n"
     "  --schema               Serialize schemas instead of JSON (use with -b).\n"
     "  --bfbs-filenames PATH  Sets the root path where reflection filenames in \n"
     "                         reflection.fbs are relative to. The 'root' is denoted with \n"
     "                         `//`. E.g. if PATH=/a/b/c \n then /a/d/e.fbs will be serialized\n"
     "                         as //../d/e.fbs. (PATH defaults to the directory of the first\n"
     "                         provided schema file.)\n"
     "  --bfbs-comments        Add doc comments to the binary schema files.\n"
     "  --bfbs-builtins        Add builtin attributes to the binary schema files.\n"
     "  --bfbs-gen-embed       Generate code to embed the bfbs schema to the source.\n"
     "  --conform FILE         Specify a schema the following schemas should be\n"
     "                         an evolution of. Gives errors if not.\n"
     "  --conform-includes     Include path for the schema given with --conform PATH\n"
     "  --filename-suffix      The suffix appended to the generated file names.\n"
     "                         Default is '_generated'.\n"
     "  --filename-ext         The extension appended to the generated file names.\n"
     "                         Default is language-specific (e.g., '.h' for C++)\n"
     "  --include-prefix       Prefix this path to any generated include statements.\n"
     "    PATH\n"
     "  --keep-prefix          Keep original prefix of schema include statement.\n"
     "  --reflect-types        Add minimal type reflection to code generation.\n"
     "  --reflect-names        Add minimal type/name reflection.\n"
     "  --root-type T          Select or override the default root_type\n"
     "  --require-explicit-ids When parsing schemas, require explicit ids (id: x).\n"
     "  --force-defaults       Emit default values in binary output from JSON\n"
     "  --force-empty          When serializing from object API representation,\n"
     "                         force strings and vectors to empty rather than null.\n"
     "  --force-empty-vectors  When serializing from object API representation,\n"
     "                         force vectors to empty rather than null.\n"
     "  --flexbuffers          Used with \"binary\" and \"json\" options, it generates\n"
     "                         data using schema-less FlexBuffers.\n"
     "  --no-warnings          Inhibit all warning messages.\n"
+    "  --cs-global-alias      Prepend \"global::\" to all user generated csharp classes and structs.\n"
     "FILEs may be schemas (must end in .fbs), binary schemas (must end in .bfbs),\n"
     "or JSON files (conforming to preceding schema). FILEs after the -- must be\n"
     "binary flatbuffer format files.\n"
     "Output files are named using the base file name of the input,\n"
     "and written to the current directory or the path given by -o.\n"
     "example: " << program_name << " -c -b schema1.fbs schema2.fbs data.json\n";
   // 12345678901234567890123456789012345678901234567890123456789012345678901234567890
   // clang-format on
   return ss.str();
 }
@@ -193,394 +194,396 @@ std::string FlatCompiler::GetUsageString(const char *program_name) const {
 int FlatCompiler::Compile(int argc, const char **argv) {
   if (params_.generators == nullptr || params_.num_generators == 0) {
     return 0;
   }
 
   flatbuffers::IDLOptions opts;
   std::string output_path;
 
   bool any_generator = false;
   bool print_make_rules = false;
   bool raw_binary = false;
   bool schema_binary = false;
   bool grpc_enabled = false;
   std::vector<std::string> filenames;
   std::list<std::string> include_directories_storage;
   std::vector<const char *> include_directories;
   std::vector<const char *> conform_include_directories;
   std::vector<bool> generator_enabled(params_.num_generators, false);
   size_t binary_files_from = std::numeric_limits<size_t>::max();
   std::string conform_to_schema;
 
   for (int argi = 0; argi < argc; argi++) {
     std::string arg = argv[argi];
     if (arg[0] == '-') {
       if (filenames.size() && arg[1] != '-')
         Error("invalid option location: " + arg, true);
       if (arg == "-o") {
         if (++argi >= argc) Error("missing path following: " + arg, true);
         output_path = flatbuffers::ConCatPathFileName(
             flatbuffers::PosixPath(argv[argi]), "");
       } else if (arg == "-I") {
         if (++argi >= argc) Error("missing path following: " + arg, true);
         include_directories_storage.push_back(
             flatbuffers::PosixPath(argv[argi]));
         include_directories.push_back(
             include_directories_storage.back().c_str());
       } else if (arg == "--bfbs-filenames") {
         if (++argi > argc) Error("missing path following: " + arg, true);
         opts.project_root = argv[argi];
         if (!DirExists(opts.project_root.c_str()))
           Error(arg + " is not a directory: " + opts.project_root);
       } else if (arg == "--conform") {
         if (++argi >= argc) Error("missing path following: " + arg, true);
         conform_to_schema = flatbuffers::PosixPath(argv[argi]);
       } else if (arg == "--conform-includes") {
         if (++argi >= argc) Error("missing path following: " + arg, true);
         include_directories_storage.push_back(
             flatbuffers::PosixPath(argv[argi]));
         conform_include_directories.push_back(
             include_directories_storage.back().c_str());
       } else if (arg == "--include-prefix") {
         if (++argi >= argc) Error("missing path following: " + arg, true);
         opts.include_prefix = flatbuffers::ConCatPathFileName(
             flatbuffers::PosixPath(argv[argi]), "");
       } else if (arg == "--keep-prefix") {
         opts.keep_include_path = true;
       } else if (arg == "--strict-json") {
         opts.strict_json = true;
       } else if (arg == "--allow-non-utf8") {
         opts.allow_non_utf8 = true;
       } else if (arg == "--natural-utf8") {
         opts.natural_utf8 = true;
       } else if (arg == "--go-namespace") {
         if (++argi >= argc) Error("missing golang namespace" + arg, true);
         opts.go_namespace = argv[argi];
       } else if (arg == "--go-import") {
         if (++argi >= argc) Error("missing golang import" + arg, true);
         opts.go_import = argv[argi];
       } else if (arg == "--defaults-json") {
         opts.output_default_scalars_in_json = true;
       } else if (arg == "--unknown-json") {
         opts.skip_unexpected_fields_in_json = true;
       } else if (arg == "--no-prefix") {
         opts.prefixed_enums = false;
       } else if (arg == "--scoped-enums") {
         opts.prefixed_enums = false;
         opts.scoped_enums = true;
       } else if (arg == "--no-union-value-namespacing") {
         opts.union_value_namespacing = false;
       } else if (arg == "--gen-mutable") {
         opts.mutable_buffer = true;
       } else if (arg == "--gen-name-strings") {
         opts.generate_name_strings = true;
       } else if (arg == "--gen-object-api") {
         opts.generate_object_based_api = true;
       } else if (arg == "--gen-compare") {
         opts.gen_compare = true;
       } else if (arg == "--cpp-include") {
         if (++argi >= argc) Error("missing include following: " + arg, true);
         opts.cpp_includes.push_back(argv[argi]);
       } else if (arg == "--cpp-ptr-type") {
         if (++argi >= argc) Error("missing type following: " + arg, true);
         opts.cpp_object_api_pointer_type = argv[argi];
       } else if (arg == "--cpp-str-type") {
         if (++argi >= argc) Error("missing type following: " + arg, true);
         opts.cpp_object_api_string_type = argv[argi];
       } else if (arg == "--cpp-str-flex-ctor") {
         opts.cpp_object_api_string_flexible_constructor = true;
       } else if (arg == "--no-cpp-direct-copy") {
         opts.cpp_direct_copy = false;
       } else if (arg == "--cpp-field-case-style") {
         if (++argi >= argc) Error("missing case style following: " + arg, true);
         if (!strcmp(argv[argi], "unchanged"))
           opts.cpp_object_api_field_case_style =
               IDLOptions::CaseStyle_Unchanged;
         else if (!strcmp(argv[argi], "upper"))
           opts.cpp_object_api_field_case_style = IDLOptions::CaseStyle_Upper;
         else if (!strcmp(argv[argi], "lower"))
           opts.cpp_object_api_field_case_style = IDLOptions::CaseStyle_Lower;
         else
           Error("unknown case style: " + std::string(argv[argi]), true);
       } else if (arg == "--gen-nullable") {
         opts.gen_nullable = true;
       } else if (arg == "--java-checkerframework") {
         opts.java_checkerframework = true;
       } else if (arg == "--gen-generated") {
         opts.gen_generated = true;
       } else if (arg == "--object-prefix") {
         if (++argi >= argc) Error("missing prefix following: " + arg, true);
         opts.object_prefix = argv[argi];
       } else if (arg == "--object-suffix") {
         if (++argi >= argc) Error("missing suffix following: " + arg, true);
         opts.object_suffix = argv[argi];
       } else if (arg == "--gen-all") {
         opts.generate_all = true;
         opts.include_dependence_headers = false;
       } else if (arg == "--gen-includes") {
         // Deprecated, remove this option some time in the future.
         Warn("warning: --gen-includes is deprecated (it is now default)\n");
       } else if (arg == "--no-includes") {
         opts.include_dependence_headers = false;
       } else if (arg == "--gen-onefile") {
         opts.one_file = true;
       } else if (arg == "--raw-binary") {
         raw_binary = true;
       } else if (arg == "--size-prefixed") {
         opts.size_prefixed = true;
       } else if (arg == "--") {  // Separator between text and binary inputs.
         binary_files_from = filenames.size();
       } else if (arg == "--proto") {
         opts.proto_mode = true;
       } else if (arg == "--proto-namespace-suffix") {
         if (++argi >= argc) Error("missing namespace suffix" + arg, true);
         opts.proto_namespace_suffix = argv[argi];
       } else if (arg == "--oneof-union") {
         opts.proto_oneof_union = true;
       } else if (arg == "--schema") {
         schema_binary = true;
       } else if (arg == "-M") {
         print_make_rules = true;
       } else if (arg == "--version") {
         printf("flatc version %s\n", FLATC_VERSION());
         exit(0);
       } else if (arg == "--grpc") {
         grpc_enabled = true;
       } else if (arg == "--bfbs-comments") {
         opts.binary_schema_comments = true;
       } else if (arg == "--bfbs-builtins") {
         opts.binary_schema_builtins = true;
       } else if (arg == "--bfbs-gen-embed") {
         opts.binary_schema_gen_embed = true;
       } else if (arg == "--reflect-types") {
         opts.mini_reflect = IDLOptions::kTypes;
       } else if (arg == "--reflect-names") {
         opts.mini_reflect = IDLOptions::kTypesAndNames;
       } else if (arg == "--require-explicit-ids") {
         opts.require_explicit_ids = true;
       } else if (arg == "--root-type") {
         if (++argi >= argc) Error("missing type following: " + arg, true);
         opts.root_type = argv[argi];
       } else if (arg == "--filename-suffix") {
         if (++argi >= argc) Error("missing filename suffix: " + arg, true);
         opts.filename_suffix = argv[argi];
       } else if (arg == "--filename-ext") {
         if (++argi >= argc) Error("missing filename extension: " + arg, true);
         opts.filename_extension = argv[argi];
       } else if (arg == "--force-defaults") {
         opts.force_defaults = true;
       } else if (arg == "--force-empty") {
         opts.set_empty_strings_to_null = false;
         opts.set_empty_vectors_to_null = false;
       } else if (arg == "--force-empty-vectors") {
         opts.set_empty_vectors_to_null = false;
       } else if (arg == "--java-primitive-has-method") {
         opts.java_primitive_has_method = true;
       } else if (arg == "--cs-gen-json-serializer") {
         opts.cs_gen_json_serializer = true;
       } else if (arg == "--flexbuffers") {
         opts.use_flexbuffers = true;
       } else if (arg == "--gen-jvmstatic") {
         opts.gen_jvmstatic = true;
       } else if (arg == "--no-warnings") {
         opts.no_warnings = true;
       } else if (arg == "--cpp-std") {
         if (++argi >= argc)
           Error("missing C++ standard specification" + arg, true);
         opts.cpp_std = argv[argi];
       } else if (arg.rfind("--cpp-std=", 0) == 0) {
         opts.cpp_std = arg.substr(std::string("--cpp-std=").size());
       } else if (arg == "--cpp-static-reflection") {
         opts.cpp_static_reflection = true;
+      } else if (arg == "--cs-global-alias") {
+        opts.cs_global_alias = true;
       } else {
         for (size_t i = 0; i < params_.num_generators; ++i) {
           if (arg == params_.generators[i].generator_opt_long ||
               (params_.generators[i].generator_opt_short &&
                arg == params_.generators[i].generator_opt_short)) {
             generator_enabled[i] = true;
             any_generator = true;
             opts.lang_to_generate |= params_.generators[i].lang;
             goto found;
           }
         }
         Error("unknown commandline argument: " + arg, true);
       found:;
       }
     } else {
       filenames.push_back(flatbuffers::PosixPath(argv[argi]));
     }
   }
 
   if (!filenames.size()) Error("missing input files", false, true);
 
   if (opts.proto_mode) {
     if (any_generator)
       Error("cannot generate code directly from .proto files", true);
   } else if (!any_generator && conform_to_schema.empty()) {
     Error("no options: specify at least one generator.", true);
   }
 
   flatbuffers::Parser conform_parser;
   if (!conform_to_schema.empty()) {
     std::string contents;
     if (!flatbuffers::LoadFile(conform_to_schema.c_str(), true, &contents))
       Error("unable to load schema: " + conform_to_schema);
 
     if (flatbuffers::GetExtension(conform_to_schema) ==
         reflection::SchemaExtension()) {
       LoadBinarySchema(conform_parser, conform_to_schema, contents);
     } else {
       ParseFile(conform_parser, conform_to_schema, contents,
                 conform_include_directories);
     }
   }
 
   std::unique_ptr<flatbuffers::Parser> parser(new flatbuffers::Parser(opts));
 
   for (auto file_it = filenames.begin(); file_it != filenames.end();
        ++file_it) {
     auto &filename = *file_it;
     std::string contents;
     if (!flatbuffers::LoadFile(filename.c_str(), true, &contents))
       Error("unable to load file: " + filename);
 
     bool is_binary =
         static_cast<size_t>(file_it - filenames.begin()) >= binary_files_from;
     auto ext = flatbuffers::GetExtension(filename);
     const bool is_schema = ext == "fbs" || ext == "proto";
     if (is_schema && opts.project_root.empty()) {
       opts.project_root = StripFileName(filename);
     }
     const bool is_binary_schema = ext == reflection::SchemaExtension();
     if (is_binary) {
       parser->builder_.Clear();
       parser->builder_.PushFlatBuffer(
           reinterpret_cast<const uint8_t *>(contents.c_str()),
           contents.length());
       if (!raw_binary) {
         // Generally reading binaries that do not correspond to the schema
         // will crash, and sadly there's no way around that when the binary
         // does not contain a file identifier.
         // We'd expect that typically any binary used as a file would have
         // such an identifier, so by default we require them to match.
         if (!parser->file_identifier_.length()) {
           Error("current schema has no file_identifier: cannot test if \"" +
                 filename +
                 "\" matches the schema, use --raw-binary to read this file"
                 " anyway.");
         } else if (!flatbuffers::BufferHasIdentifier(
                        contents.c_str(), parser->file_identifier_.c_str(),
                        opts.size_prefixed)) {
           Error("binary \"" + filename +
                 "\" does not have expected file_identifier \"" +
                 parser->file_identifier_ +
                 "\", use --raw-binary to read this file anyway.");
         }
       }
     } else {
       // Check if file contains 0 bytes.
       if (!opts.use_flexbuffers && !is_binary_schema &&
           contents.length() != strlen(contents.c_str())) {
         Error("input file appears to be binary: " + filename, true);
       }
       if (is_schema || is_binary_schema) {
         // If we're processing multiple schemas, make sure to start each
         // one from scratch. If it depends on previous schemas it must do
         // so explicitly using an include.
         parser.reset(new flatbuffers::Parser(opts));
       }
       // Try to parse the file contents (binary schema/flexbuffer/textual
       // schema)
       if (is_binary_schema) {
         LoadBinarySchema(*parser.get(), filename, contents);
       } else if (opts.use_flexbuffers) {
         if (opts.lang_to_generate == IDLOptions::kJson) {
           parser->flex_root_ = flexbuffers::GetRoot(
               reinterpret_cast<const uint8_t *>(contents.c_str()),
               contents.size());
         } else {
           parser->flex_builder_.Clear();
           ParseFile(*parser.get(), filename, contents, include_directories);
         }
       } else {
         ParseFile(*parser.get(), filename, contents, include_directories);
         if (!is_schema && !parser->builder_.GetSize()) {
           // If a file doesn't end in .fbs, it must be json/binary. Ensure we
           // didn't just parse a schema with a different extension.
           Error("input file is neither json nor a .fbs (schema) file: " +
                     filename,
                 true);
         }
       }
       if ((is_schema || is_binary_schema) && !conform_to_schema.empty()) {
         auto err = parser->ConformTo(conform_parser);
         if (!err.empty()) Error("schemas don\'t conform: " + err);
       }
       if (schema_binary || opts.binary_schema_gen_embed) {
         parser->Serialize();
       }
       if (schema_binary) {
         parser->file_extension_ = reflection::SchemaExtension();
       }
     }
 
     std::string filebase =
         flatbuffers::StripPath(flatbuffers::StripExtension(filename));
 
     for (size_t i = 0; i < params_.num_generators; ++i) {
       if (generator_enabled[i]) {
         if (!print_make_rules) {
           flatbuffers::EnsureDirExists(output_path);
           if ((!params_.generators[i].schema_only ||
                (is_schema || is_binary_schema)) &&
               !params_.generators[i].generate(*parser.get(), output_path,
                                               filebase)) {
             Error(std::string("Unable to generate ") +
                   params_.generators[i].lang_name + " for " + filebase);
           }
         } else {
           if (params_.generators[i].make_rule == nullptr) {
             Error(std::string("Cannot generate make rule for ") +
                   params_.generators[i].lang_name);
           } else {
             std::string make_rule = params_.generators[i].make_rule(
                 *parser.get(), output_path, filename);
             if (!make_rule.empty())
               printf("%s\n",
                      flatbuffers::WordWrap(make_rule, 80, " ", " \\").c_str());
           }
         }
         if (grpc_enabled) {
           if (params_.generators[i].generateGRPC != nullptr) {
             if (!params_.generators[i].generateGRPC(*parser.get(), output_path,
                                                     filebase)) {
               Error(std::string("Unable to generate GRPC interface for") +
                     params_.generators[i].lang_name);
             }
           } else {
             Warn(std::string("GRPC interface generator not implemented for ") +
                  params_.generators[i].lang_name);
           }
         }
       }
     }
 
     if (!opts.root_type.empty()) {
       if (!parser->SetRootType(opts.root_type.c_str()))
         Error("unknown root type: " + opts.root_type);
       else if (parser->root_struct_def_->fixed)
         Error("root type must be a table");
     }
 
     if (opts.proto_mode) GenerateFBS(*parser.get(), output_path, filebase);
 
     // We do not want to generate code for the definitions in this file
     // in any files coming up next.
     parser->MarkGenerated();
   }
   if (opts.lang_to_generate & IDLOptions::kRust && !parser->opts.one_file) {
     GenerateRustModuleRootFile(*parser, output_path);
   }
   return 0;
 }
 
 }  // namespace flatbuffers
diff --git a/src/idl_gen_csharp.cpp b/src/idl_gen_csharp.cpp
index f23d9f07..d481a192 100644
--- a/src/idl_gen_csharp.cpp
+++ b/src/idl_gen_csharp.cpp
@@ -42,2181 +42,2181 @@ namespace csharp {
 class CSharpGenerator : public BaseGenerator {
   struct FieldArrayLength {
     std::string name;
     int length;
   };
 
  public:
   CSharpGenerator(const Parser &parser, const std::string &path,
                   const std::string &file_name)
-      : BaseGenerator(parser, path, file_name, "", ".", "cs"),
+      : BaseGenerator(parser, path, file_name, parser.opts.cs_global_alias ? "global::" : "", ".", "cs"),
         cur_name_space_(nullptr) {
     // clang-format off
 
     // List of keywords retrieved from here:
     // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
 
     // One per line to ease comparisons to that list are easier
 
     static const char *const keywords[] = {
       "abstract",
       "as",
       "base",
       "bool",
       "break",
       "byte",
       "case",
       "catch",
       "char",
       "checked",
       "class",
       "const",
       "continue",
       "decimal",
       "default",
       "delegate",
       "do",
       "double",
       "else",
       "enum",
       "event",
       "explicit",
       "extern",
       "false",
       "finally",
       "fixed",
       "float",
       "for",
       "foreach",
       "goto",
       "if",
       "implicit",
       "in",
       "int",
       "interface",
       "internal",
       "is",
       "lock",
       "long",
       "namespace",
       "new",
       "null",
       "object",
       "operator",
       "out",
       "override",
       "params",
       "private",
       "protected",
       "public",
       "readonly",
       "ref",
       "return",
       "sbyte",
       "sealed",
       "short",
       "sizeof",
       "stackalloc",
       "static",
       "string",
       "struct",
       "switch",
       "this",
       "throw",
       "true",
       "try",
       "typeof",
       "uint",
       "ulong",
       "unchecked",
       "unsafe",
       "ushort",
       "using",
       "virtual",
       "void",
       "volatile",
       "while",
       nullptr,
       // clang-format on
     };
 
     for (auto kw = keywords; *kw; kw++) keywords_.insert(*kw);
   }
 
   CSharpGenerator &operator=(const CSharpGenerator &);
 
   bool generate() {
     std::string one_file_code;
     cur_name_space_ = parser_.current_namespace_;
 
     for (auto it = parser_.enums_.vec.begin(); it != parser_.enums_.vec.end();
          ++it) {
       std::string enumcode;
       auto &enum_def = **it;
       if (!parser_.opts.one_file) cur_name_space_ = enum_def.defined_namespace;
       GenEnum(enum_def, &enumcode, parser_.opts);
       if (parser_.opts.one_file) {
         one_file_code += enumcode;
       } else {
         if (!SaveType(enum_def.name, *enum_def.defined_namespace, enumcode,
                       false, parser_.opts))
           return false;
       }
     }
 
     for (auto it = parser_.structs_.vec.begin();
          it != parser_.structs_.vec.end(); ++it) {
       std::string declcode;
       auto &struct_def = **it;
       if (!parser_.opts.one_file)
         cur_name_space_ = struct_def.defined_namespace;
       GenStruct(struct_def, &declcode, parser_.opts);
       if (parser_.opts.one_file) {
         one_file_code += declcode;
       } else {
         if (!SaveType(struct_def.name, *struct_def.defined_namespace, declcode,
                       true, parser_.opts))
           return false;
       }
     }
 
     if (parser_.opts.one_file) {
       return SaveType(file_name_, *parser_.current_namespace_, one_file_code,
                       true, parser_.opts);
     }
     return true;
   }
 
  private:
   std::unordered_set<std::string> keywords_;
 
   std::string EscapeKeyword(const std::string &name) const {
     return keywords_.find(name) == keywords_.end() ? name : "@" + name;
   }
 
   std::string Name(const FieldDef &field) const {
     std::string name = MakeCamel(field.name, true);
     return EscapeKeyword(name);
   }
 
   std::string Name(const Definition &def) const {
     return EscapeKeyword(def.name);
   }
 
   std::string NamespacedName(const Definition &def) const {
     return WrapInNameSpace(def.defined_namespace, Name(def));
   }
 
   std::string Name(const EnumVal &ev) const { return EscapeKeyword(ev.name); }
 
   // Save out the generated code for a single class while adding
   // declaration boilerplate.
   bool SaveType(const std::string &defname, const Namespace &ns,
                 const std::string &classcode, bool needs_includes,
                 const IDLOptions &options) const {
     if (!classcode.length()) return true;
 
     std::string code =
         "// <auto-generated>\n"
         "//  " +
         std::string(FlatBuffersGeneratedWarning()) +
         "\n"
         "// </auto-generated>\n\n";
 
     std::string namespace_name = FullNamespace(".", ns);
     if (!namespace_name.empty()) {
       code += "namespace " + namespace_name + "\n{\n\n";
     }
     if (needs_includes) {
       code += "using global::System;\n";
       code += "using global::System.Collections.Generic;\n";
       code += "using global::FlatBuffers;\n\n";
     }
     code += classcode;
     if (!namespace_name.empty()) { code += "\n}\n"; }
     auto filename = NamespaceDir(ns) + defname;
     if (options.one_file) { filename += options.filename_suffix; }
     filename +=
         options.filename_extension.empty() ? ".cs" : options.filename_extension;
     return SaveFile(filename.c_str(), code, false);
   }
 
   const Namespace *CurrentNameSpace() const { return cur_name_space_; }
 
   std::string GenTypeBasic(const Type &type, bool enableLangOverrides) const {
     // clang-format off
     static const char * const csharp_typename[] = {
       #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, JTYPE, GTYPE, NTYPE, ...) \
         #NTYPE,
         FLATBUFFERS_GEN_TYPES(FLATBUFFERS_TD)
       #undef FLATBUFFERS_TD
     };
     // clang-format on
 
     if (enableLangOverrides) {
       if (IsEnum(type)) return NamespacedName(*type.enum_def);
       if (type.base_type == BASE_TYPE_STRUCT) {
         return "Offset<" + NamespacedName(*type.struct_def) + ">";
       }
     }
 
     return csharp_typename[type.base_type];
   }
 
   inline std::string GenTypeBasic(const Type &type) const {
     return GenTypeBasic(type, true);
   }
 
   std::string GenTypePointer(const Type &type) const {
     switch (type.base_type) {
       case BASE_TYPE_STRING: return "string";
       case BASE_TYPE_VECTOR: return GenTypeGet(type.VectorType());
       case BASE_TYPE_STRUCT: return NamespacedName(*type.struct_def);
       case BASE_TYPE_UNION: return "TTable";
       default: return "Table";
     }
   }
 
   std::string GenTypeGet(const Type &type) const {
     return IsScalar(type.base_type)
                ? GenTypeBasic(type)
                : (IsArray(type) ? GenTypeGet(type.VectorType())
                                 : GenTypePointer(type));
   }
 
   std::string GenOffsetType(const StructDef &struct_def) const {
     return "Offset<" + NamespacedName(struct_def) + ">";
   }
 
   std::string GenOffsetConstruct(const StructDef &struct_def,
                                  const std::string &variable_name) const {
     return "new Offset<" + NamespacedName(struct_def) + ">(" + variable_name +
            ")";
   }
 
   // Casts necessary to correctly read serialized data
   std::string DestinationCast(const Type &type) const {
     if (IsSeries(type)) {
       return DestinationCast(type.VectorType());
     } else {
       if (IsEnum(type)) return "(" + NamespacedName(*type.enum_def) + ")";
     }
     return "";
   }
 
   // Cast statements for mutator method parameters.
   // In Java, parameters representing unsigned numbers need to be cast down to
   // their respective type. For example, a long holding an unsigned int value
   // would be cast down to int before being put onto the buffer. In C#, one cast
   // directly cast an Enum to its underlying type, which is essential before
   // putting it onto the buffer.
   std::string SourceCast(const Type &type, const bool isOptional=false) const {
     if (IsSeries(type)) {
       return SourceCast(type.VectorType());
     } else {
       if (IsEnum(type)) return "(" + GenTypeBasic(type, false) + (isOptional ? "?": "") + ")";
     }
     return "";
   }
 
   std::string SourceCastBasic(const Type &type, const bool isOptional) const {
     return IsScalar(type.base_type) ? SourceCast(type, isOptional) : "";
   }
 
   std::string GenEnumDefaultValue(const FieldDef &field) const {
     auto &value = field.value;
     FLATBUFFERS_ASSERT(value.type.enum_def);
     auto &enum_def = *value.type.enum_def;
     auto enum_val = enum_def.FindByValue(value.constant);
     return enum_val ? (NamespacedName(enum_def) + "." + Name(*enum_val))
                     : value.constant;
   }
 
   std::string GenDefaultValue(const FieldDef &field,
                               bool enableLangOverrides) const {
     // If it is an optional scalar field, the default is null
     if (field.IsScalarOptional()) { return "null"; }
 
     auto &value = field.value;
     if (enableLangOverrides) {
       // handles both enum case and vector of enum case
       if (value.type.enum_def != nullptr &&
           value.type.base_type != BASE_TYPE_UNION) {
         return GenEnumDefaultValue(field);
       }
     }
 
     auto longSuffix = "";
     switch (value.type.base_type) {
       case BASE_TYPE_BOOL: return value.constant == "0" ? "false" : "true";
       case BASE_TYPE_ULONG: return value.constant;
       case BASE_TYPE_UINT:
       case BASE_TYPE_LONG: return value.constant + longSuffix;
       default:
         if (IsFloat(value.type.base_type))
           return CSharpFloatGen.GenFloatConstant(field);
         else
           return value.constant;
     }
   }
 
   std::string GenDefaultValue(const FieldDef &field) const {
     return GenDefaultValue(field, true);
   }
 
   std::string GenDefaultValueBasic(const FieldDef &field,
                                    bool enableLangOverrides) const {
     auto &value = field.value;
     if (!IsScalar(value.type.base_type)) {
       if (enableLangOverrides) {
         switch (value.type.base_type) {
           case BASE_TYPE_STRING: return "default(StringOffset)";
           case BASE_TYPE_STRUCT:
             return "default(Offset<" + NamespacedName(*value.type.struct_def) +
                    ">)";
           case BASE_TYPE_VECTOR: return "default(VectorOffset)";
           default: break;
         }
       }
       return "0";
     }
     return GenDefaultValue(field, enableLangOverrides);
   }
 
   std::string GenDefaultValueBasic(const FieldDef &field) const {
     return GenDefaultValueBasic(field, true);
   }
 
   void GenEnum(EnumDef &enum_def, std::string *code_ptr,
                const IDLOptions &opts) const {
     std::string &code = *code_ptr;
     if (enum_def.generated) return;
 
     // Generate enum definitions of the form:
     // public static (final) int name = value;
     // In Java, we use ints rather than the Enum feature, because we want them
     // to map directly to how they're used in C/C++ and file formats.
     // That, and Java Enums are expensive, and not universally liked.
     GenComment(enum_def.doc_comment, code_ptr, &comment_config);
 
     if (opts.cs_gen_json_serializer && opts.generate_object_based_api) {
       code +=
           "[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters."
           "StringEnumConverter))]\n";
     }
     // In C# this indicates enumeration values can be treated as bit flags.
     if (enum_def.attributes.Lookup("bit_flags")) {
       code += "[System.FlagsAttribute]\n";
     }
     if (enum_def.attributes.Lookup("private")) {
       code += "internal ";
     } else {
       code += "public ";
     }
     code += "enum " + Name(enum_def);
     code += " : " + GenTypeBasic(enum_def.underlying_type, false);
     code += "\n{\n";
     for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
       auto &ev = **it;
       GenComment(ev.doc_comment, code_ptr, &comment_config, "  ");
       code += "  ";
       code += Name(ev) + " = ";
       code += enum_def.ToString(ev);
       code += ",\n";
     }
     // Close the class
     code += "};\n\n";
 
     if (opts.generate_object_based_api) {
       GenEnum_ObjectAPI(enum_def, code_ptr, opts);
     }
   }
 
   bool HasUnionStringValue(const EnumDef &enum_def) const {
     if (!enum_def.is_union) return false;
     for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
       auto &val = **it;
       if (IsString(val.union_type)) { return true; }
     }
     return false;
   }
 
   // Returns the function name that is able to read a value of the given type.
   std::string GenGetter(const Type &type) const {
     switch (type.base_type) {
       case BASE_TYPE_STRING: return "__p.__string";
       case BASE_TYPE_STRUCT: return "__p.__struct";
       case BASE_TYPE_UNION: return "__p.__union";
       case BASE_TYPE_VECTOR: return GenGetter(type.VectorType());
       case BASE_TYPE_ARRAY: return GenGetter(type.VectorType());
       default: {
         std::string getter = "__p.bb.Get";
         if (type.base_type == BASE_TYPE_BOOL) {
           getter = "0!=" + getter;
         } else if (GenTypeBasic(type, false) != "byte") {
           getter += MakeCamel(GenTypeBasic(type, false));
         }
         return getter;
       }
     }
   }
 
   // Returns the function name that is able to read a value of the given type.
   std::string GenGetterForLookupByKey(flatbuffers::FieldDef *key_field,
                                       const std::string &data_buffer,
                                       const char *num = nullptr) const {
     auto type = key_field->value.type;
     auto dest_mask = "";
     auto dest_cast = DestinationCast(type);
     auto getter = data_buffer + ".Get";
     if (GenTypeBasic(type, false) != "byte") {
       getter += MakeCamel(GenTypeBasic(type, false));
     }
     getter = dest_cast + getter + "(" + GenOffsetGetter(key_field, num) + ")" +
              dest_mask;
     return getter;
   }
 
   // Direct mutation is only allowed for scalar fields.
   // Hence a setter method will only be generated for such fields.
   std::string GenSetter(const Type &type) const {
     if (IsScalar(type.base_type)) {
       std::string setter = "__p.bb.Put";
       if (GenTypeBasic(type, false) != "byte" &&
           type.base_type != BASE_TYPE_BOOL) {
         setter += MakeCamel(GenTypeBasic(type, false));
       }
       return setter;
     } else {
       return "";
     }
   }
 
   // Returns the method name for use with add/put calls.
   std::string GenMethod(const Type &type) const {
     return IsScalar(type.base_type) ? MakeCamel(GenTypeBasic(type, false))
                                     : (IsStruct(type) ? "Struct" : "Offset");
   }
 
   // Recursively generate arguments for a constructor, to deal with nested
   // structs.
   void GenStructArgs(const StructDef &struct_def, std::string *code_ptr,
                      const char *nameprefix, size_t array_count = 0) const {
     std::string &code = *code_ptr;
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       const auto &field_type = field.value.type;
       const auto array_field = IsArray(field_type);
       const auto &type = array_field ? field_type.VectorType() : field_type;
       const auto array_cnt = array_field ? (array_count + 1) : array_count;
       if (IsStruct(type)) {
         // Generate arguments for a struct inside a struct. To ensure names
         // don't clash, and to make it obvious these arguments are constructing
         // a nested struct, prefix the name with the field name.
         GenStructArgs(*field_type.struct_def, code_ptr,
                       (nameprefix + (EscapeKeyword(field.name) + "_")).c_str(),
                       array_cnt);
       } else {
         code += ", ";
         code += GenTypeBasic(type);
         if (field.IsScalarOptional()) { code += "?"; }
         if (array_cnt > 0) {
           code += "[";
           for (size_t i = 1; i < array_cnt; i++) code += ",";
           code += "]";
         }
         code += " ";
         code += nameprefix;
         code += Name(field);
       }
     }
   }
 
   // Recusively generate struct construction statements of the form:
   // builder.putType(name);
   // and insert manual padding.
   void GenStructBody(const StructDef &struct_def, std::string *code_ptr,
                      const char *nameprefix, size_t index = 0,
                      bool in_array = false) const {
     std::string &code = *code_ptr;
     std::string indent((index + 1) * 2, ' ');
     code += indent + "  builder.Prep(";
     code += NumToString(struct_def.minalign) + ", ";
     code += NumToString(struct_def.bytesize) + ");\n";
     for (auto it = struct_def.fields.vec.rbegin();
          it != struct_def.fields.vec.rend(); ++it) {
       auto &field = **it;
       const auto &field_type = field.value.type;
       if (field.padding) {
         code += indent + "  builder.Pad(";
         code += NumToString(field.padding) + ");\n";
       }
       if (IsStruct(field_type)) {
         GenStructBody(*field_type.struct_def, code_ptr,
                       (nameprefix + (field.name + "_")).c_str(), index,
                       in_array);
       } else {
         const auto &type =
             IsArray(field_type) ? field_type.VectorType() : field_type;
         const auto index_var = "_idx" + NumToString(index);
         if (IsArray(field_type)) {
           code += indent + "  for (int " + index_var + " = ";
           code += NumToString(field_type.fixed_length);
           code += "; " + index_var + " > 0; " + index_var + "--) {\n";
           in_array = true;
         }
         if (IsStruct(type)) {
           GenStructBody(*field_type.struct_def, code_ptr,
                         (nameprefix + (field.name + "_")).c_str(), index + 1,
                         in_array);
         } else {
           code += IsArray(field_type) ? "  " : "";
           code += indent + "  builder.Put";
           code += GenMethod(type) + "(";
           code += SourceCast(type);
           auto argname = nameprefix + Name(field);
           code += argname;
           size_t array_cnt = index + (IsArray(field_type) ? 1 : 0);
           if (array_cnt > 0) {
             code += "[";
             for (size_t i = 0; in_array && i < array_cnt; i++) {
               code += "_idx" + NumToString(i) + "-1";
               if (i != (array_cnt - 1)) code += ",";
             }
             code += "]";
           }
           code += ");\n";
         }
         if (IsArray(field_type)) { code += indent + "  }\n"; }
       }
     }
   }
   std::string GenOffsetGetter(flatbuffers::FieldDef *key_field,
                               const char *num = nullptr) const {
     std::string key_offset =
         "Table.__offset(" + NumToString(key_field->value.offset) + ", ";
     if (num) {
       key_offset += num;
       key_offset += ".Value, builder.DataBuffer)";
     } else {
       key_offset += "bb.Length";
       key_offset += " - tableOffset, bb)";
     }
     return key_offset;
   }
 
   std::string GenLookupKeyGetter(flatbuffers::FieldDef *key_field) const {
     std::string key_getter = "      ";
     key_getter += "int tableOffset = Table.";
     key_getter += "__indirect(vectorLocation + 4 * (start + middle)";
     key_getter += ", bb);\n      ";
     if (IsString(key_field->value.type)) {
       key_getter += "int comp = Table.";
       key_getter += "CompareStrings(";
       key_getter += GenOffsetGetter(key_field);
       key_getter += ", byteKey, bb);\n";
     } else {
       auto get_val = GenGetterForLookupByKey(key_field, "bb");
       key_getter += "int comp = " + get_val + ".CompareTo(key);\n";
     }
     return key_getter;
   }
 
   std::string GenKeyGetter(flatbuffers::FieldDef *key_field) const {
     std::string key_getter = "";
     auto data_buffer = "builder.DataBuffer";
     if (IsString(key_field->value.type)) {
       key_getter += "Table.CompareStrings(";
       key_getter += GenOffsetGetter(key_field, "o1") + ", ";
       key_getter += GenOffsetGetter(key_field, "o2") + ", " + data_buffer + ")";
     } else {
       auto field_getter = GenGetterForLookupByKey(key_field, data_buffer, "o1");
       key_getter += field_getter;
       field_getter = GenGetterForLookupByKey(key_field, data_buffer, "o2");
       key_getter += ".CompareTo(" + field_getter + ")";
     }
     return key_getter;
   }
 
   void GenStruct(StructDef &struct_def, std::string *code_ptr,
                  const IDLOptions &opts) const {
     if (struct_def.generated) return;
     std::string &code = *code_ptr;
 
     // Generate a struct accessor class, with methods of the form:
     // public type name() { return bb.getType(i + offset); }
     // or for tables of the form:
     // public type name() {
     //   int o = __offset(offset); return o != 0 ? bb.getType(o + i) : default;
     // }
     GenComment(struct_def.doc_comment, code_ptr, &comment_config);
     if (struct_def.attributes.Lookup("private")) {
       code += "internal ";
     } else {
       code += "public ";
     }
     if (struct_def.attributes.Lookup("csharp_partial")) {
       // generate a partial class for this C# struct/table
       code += "partial ";
     }
     code += "struct " + struct_def.name;
     code += " : IFlatbufferObject";
     code += "\n{\n";
     code += "  private ";
     code += struct_def.fixed ? "Struct" : "Table";
     code += " __p;\n";
 
     code += "  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n";
 
     if (!struct_def.fixed) {
       // Generate verson check method.
       // Force compile time error if not using the same version runtime.
       code += "  public static void ValidateVersion() {";
       code += " FlatBufferConstants.";
       code += "FLATBUFFERS_2_0_0(); ";
       code += "}\n";
 
       // Generate a special accessor for the table that when used as the root
       // of a FlatBuffer
       std::string method_name = "GetRootAs" + struct_def.name;
       std::string method_signature =
           "  public static " + struct_def.name + " " + method_name;
 
       // create convenience method that doesn't require an existing object
       code += method_signature + "(ByteBuffer _bb) ";
       code += "{ return " + method_name + "(_bb, new " + struct_def.name +
               "()); }\n";
 
       // create method that allows object reuse
       code +=
           method_signature + "(ByteBuffer _bb, " + struct_def.name + " obj) { ";
       code += "return (obj.__assign(_bb.GetInt(_bb.Position";
       code += ") + _bb.Position";
       code += ", _bb)); }\n";
       if (parser_.root_struct_def_ == &struct_def) {
         if (parser_.file_identifier_.length()) {
           // Check if a buffer has the identifier.
           code += "  public static ";
           code += "bool " + struct_def.name;
           code += "BufferHasIdentifier(ByteBuffer _bb) { return ";
           code += "Table.__has_identifier(_bb, \"";
           code += parser_.file_identifier_;
           code += "\"); }\n";
         }
       }
     }
     // Generate the __init method that sets the field in a pre-existing
     // accessor object. This is to allow object reuse.
     code += "  public void __init(int _i, ByteBuffer _bb) ";
     code += "{ ";
     code += "__p = new ";
     code += struct_def.fixed ? "Struct" : "Table";
     code += "(_i, _bb); ";
     code += "}\n";
     code +=
         "  public " + struct_def.name + " __assign(int _i, ByteBuffer _bb) ";
     code += "{ __init(_i, _bb); return this; }\n\n";
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       if (field.deprecated) continue;
       GenComment(field.doc_comment, code_ptr, &comment_config, "  ");
       std::string type_name = GenTypeGet(field.value.type);
       std::string type_name_dest = GenTypeGet(field.value.type);
       std::string conditional_cast = "";
       std::string optional = "";
       if (!struct_def.fixed &&
           (field.value.type.base_type == BASE_TYPE_STRUCT ||
            field.value.type.base_type == BASE_TYPE_UNION ||
            (IsVector(field.value.type) &&
             (field.value.type.element == BASE_TYPE_STRUCT ||
              field.value.type.element == BASE_TYPE_UNION)))) {
         optional = "?";
         conditional_cast = "(" + type_name_dest + optional + ")";
       }
       if (field.IsScalarOptional()) { optional = "?"; }
       std::string dest_mask = "";
       std::string dest_cast = DestinationCast(field.value.type);
       std::string src_cast = SourceCast(field.value.type);
       std::string field_name_camel = Name(field);
       if (field_name_camel == struct_def.name) { field_name_camel += "_"; }
       std::string method_start =
           "  public " + type_name_dest + optional + " " + field_name_camel;
       std::string obj = "(new " + type_name + "())";
 
       // Most field accessors need to retrieve and test the field offset first,
       // this is the prefix code for that:
       auto offset_prefix =
           IsArray(field.value.type)
               ? " { return "
               : (" { int o = __p.__offset(" + NumToString(field.value.offset) +
                  "); return o != 0 ? ");
       // Generate the accessors that don't do object reuse.
       if (field.value.type.base_type == BASE_TYPE_STRUCT) {
       } else if (IsVector(field.value.type) &&
                  field.value.type.element == BASE_TYPE_STRUCT) {
       } else if (field.value.type.base_type == BASE_TYPE_UNION ||
                  (IsVector(field.value.type) &&
                   field.value.type.VectorType().base_type == BASE_TYPE_UNION)) {
         method_start += "<TTable>";
         type_name = type_name_dest;
       }
       std::string getter = dest_cast + GenGetter(field.value.type);
       code += method_start;
       std::string default_cast = "";
       // only create default casts for c# scalars or vectors of scalars
       if ((IsScalar(field.value.type.base_type) ||
            (IsVector(field.value.type) &&
             IsScalar(field.value.type.element)))) {
         // For scalars, default value will be returned by GetDefaultValue().
         // If the scalar is an enum, GetDefaultValue() returns an actual c# enum
         // that doesn't need to be casted. However, default values for enum
         // elements of vectors are integer literals ("0") and are still casted
         // for clarity.
         // If the scalar is optional and enum, we still need the cast.
         if ((field.value.type.enum_def == nullptr ||
              IsVector(field.value.type)) ||
             (IsEnum(field.value.type) && field.IsScalarOptional())) {
           default_cast = "(" + type_name_dest + optional + ")";
         }
       }
       std::string member_suffix = "; ";
       if (IsScalar(field.value.type.base_type)) {
         code += " { get";
         member_suffix += "} ";
         if (struct_def.fixed) {
           code += " { return " + getter;
           code += "(__p.bb_pos + ";
           code += NumToString(field.value.offset) + ")";
           code += dest_mask;
         } else {
           code += offset_prefix + getter;
           code += "(o + __p.bb_pos)" + dest_mask;
           code += " : " + default_cast;
           code += GenDefaultValue(field);
         }
       } else {
         switch (field.value.type.base_type) {
           case BASE_TYPE_STRUCT:
             code += " { get";
             member_suffix += "} ";
             if (struct_def.fixed) {
               code += " { return " + obj + ".__assign(" + "__p.";
               code += "bb_pos + " + NumToString(field.value.offset) + ", ";
               code += "__p.bb)";
             } else {
               code += offset_prefix + conditional_cast;
               code += obj + ".__assign(";
               code += field.value.type.struct_def->fixed
                           ? "o + __p.bb_pos"
                           : "__p.__indirect(o + __p.bb_pos)";
               code += ", __p.bb) : null";
             }
             break;
           case BASE_TYPE_STRING:
             code += " { get";
             member_suffix += "} ";
             code += offset_prefix + getter + "(o + " + "__p.";
             code += "bb_pos) : null";
             break;
           case BASE_TYPE_ARRAY: FLATBUFFERS_FALLTHROUGH();  // fall thru
           case BASE_TYPE_VECTOR: {
             auto vectortype = field.value.type.VectorType();
             if (vectortype.base_type == BASE_TYPE_UNION) {
               conditional_cast = "(TTable?)";
               getter += "<TTable>";
             }
             code += "(";
             if (vectortype.base_type == BASE_TYPE_STRUCT) {
               getter = obj + ".__assign";
             } else if (vectortype.base_type == BASE_TYPE_UNION) {
             }
             code += "int j)";
             const auto body = offset_prefix + conditional_cast + getter + "(";
             if (vectortype.base_type == BASE_TYPE_UNION) {
               code += " where TTable : struct, IFlatbufferObject" + body;
             } else {
               code += body;
             }
             std::string index = "__p.";
             if (IsArray(field.value.type)) {
               index += "bb_pos + " + NumToString(field.value.offset) + " + ";
             } else {
               index += "__vector(o) + ";
             }
             index += "j * " + NumToString(InlineSize(vectortype));
             if (vectortype.base_type == BASE_TYPE_STRUCT) {
               code += vectortype.struct_def->fixed
                           ? index
                           : "__p.__indirect(" + index + ")";
               code += ", __p.bb";
             } else {
               code += index;
             }
             code += ")" + dest_mask;
             if (!IsArray(field.value.type)) {
               code += " : ";
               code +=
                   field.value.type.element == BASE_TYPE_BOOL
                       ? "false"
                       : (IsScalar(field.value.type.element) ? default_cast + "0"
                                                             : "null");
             }
             if (vectortype.base_type == BASE_TYPE_UNION &&
                 HasUnionStringValue(*vectortype.enum_def)) {
               code += member_suffix;
               code += "}\n";
               code += "  public string " + Name(field) + "AsString(int j)";
               code += offset_prefix + GenGetter(Type(BASE_TYPE_STRING));
               code += "(" + index + ") : null";
             }
             break;
           }
           case BASE_TYPE_UNION:
             code += "() where TTable : struct, IFlatbufferObject";
             code += offset_prefix + "(TTable?)" + getter;
             code += "<TTable>(o + __p.bb_pos) : null";
             if (HasUnionStringValue(*field.value.type.enum_def)) {
               code += member_suffix;
               code += "}\n";
               code += "  public string " + Name(field) + "AsString()";
               code += offset_prefix + GenGetter(Type(BASE_TYPE_STRING));
               code += "(o + __p.bb_pos) : null";
             }
             // As<> accesors for Unions
             // Loop through all the possible union types and generate an As
             // accessor that casts to the correct type.
             for (auto uit = field.value.type.enum_def->Vals().begin();
                  uit != field.value.type.enum_def->Vals().end(); ++uit) {
               auto val = *uit;
               if (val->union_type.base_type == BASE_TYPE_NONE) { continue; }
               auto union_field_type_name = GenTypeGet(val->union_type);
               code += member_suffix + "}\n";
               if (val->union_type.base_type == BASE_TYPE_STRUCT &&
                   val->union_type.struct_def->attributes.Lookup("private")) {
                 code += "  internal ";
               } else {
                 code += "  public ";
               }
               code += union_field_type_name + " ";
               code += field_name_camel + "As" + val->name + "() { return ";
               code += field_name_camel;
               if (IsString(val->union_type)) {
                 code += "AsString()";
               } else {
                 code += "<" + union_field_type_name + ">().Value";
               }
             }
             break;
           default: FLATBUFFERS_ASSERT(0);
         }
       }
       code += member_suffix;
       code += "}\n";
       if (IsVector(field.value.type)) {
         code += "  public int " + Name(field);
         code += "Length";
         code += " { get";
         code += offset_prefix;
         code += "__p.__vector_len(o) : 0; ";
         code += "} ";
         code += "}\n";
         // See if we should generate a by-key accessor.
         if (field.value.type.element == BASE_TYPE_STRUCT &&
             !field.value.type.struct_def->fixed) {
           auto &sd = *field.value.type.struct_def;
           auto &fields = sd.fields.vec;
           for (auto kit = fields.begin(); kit != fields.end(); ++kit) {
             auto &key_field = **kit;
             if (key_field.key) {
               auto qualified_name = NamespacedName(sd);
               code += "  public " + qualified_name + "? ";
               code += Name(field) + "ByKey(";
               code += GenTypeGet(key_field.value.type) + " key)";
               code += offset_prefix;
               code += qualified_name + ".__lookup_by_key(";
               code += "__p.__vector(o), key, ";
               code += "__p.bb) : null; ";
               code += "}\n";
               break;
             }
           }
         }
       }
       // Generate a ByteBuffer accessor for strings & vectors of scalars.
       if ((IsVector(field.value.type) &&
            IsScalar(field.value.type.VectorType().base_type)) ||
           IsString(field.value.type)) {
         code += "#if ENABLE_SPAN_T\n";
         code += "  public Span<" + GenTypeBasic(field.value.type.VectorType()) +
                 "> Get";
         code += Name(field);
         code += "Bytes() { return ";
         code += "__p.__vector_as_span<" +
                 GenTypeBasic(field.value.type.VectorType()) + ">(";
         code += NumToString(field.value.offset);
         code +=
             ", " + NumToString(SizeOf(field.value.type.VectorType().base_type));
         code += "); }\n";
         code += "#else\n";
         code += "  public ArraySegment<byte>? Get";
         code += Name(field);
         code += "Bytes() { return ";
         code += "__p.__vector_as_arraysegment(";
         code += NumToString(field.value.offset);
         code += "); }\n";
         code += "#endif\n";
 
         // For direct blockcopying the data into a typed array
         code += "  public ";
         code += GenTypeBasic(field.value.type.VectorType());
         code += "[] Get";
         code += Name(field);
         code += "Array() { ";
         if (IsEnum(field.value.type.VectorType())) {
           // Since __vector_as_array does not work for enum types,
           // fill array using an explicit loop.
           code += "int o = __p.__offset(";
           code += NumToString(field.value.offset);
           code += "); if (o == 0) return null; int p = ";
           code += "__p.__vector(o); int l = ";
           code += "__p.__vector_len(o); ";
           code += GenTypeBasic(field.value.type.VectorType());
           code += "[] a = new ";
           code += GenTypeBasic(field.value.type.VectorType());
           code += "[l]; for (int i = 0; i < l; i++) { a[i] = " + getter;
           code += "(p + i * ";
           code += NumToString(InlineSize(field.value.type.VectorType()));
           code += "); } return a;";
         } else {
           code += "return ";
           code += "__p.__vector_as_array<";
           code += GenTypeBasic(field.value.type.VectorType());
           code += ">(";
           code += NumToString(field.value.offset);
           code += ");";
         }
         code += " }\n";
       }
       // generate object accessors if is nested_flatbuffer
       if (field.nested_flatbuffer) {
         auto nested_type_name = NamespacedName(*field.nested_flatbuffer);
         auto nested_method_name =
             Name(field) + "As" + field.nested_flatbuffer->name;
         auto get_nested_method_name = nested_method_name;
         get_nested_method_name = "Get" + nested_method_name;
         conditional_cast = "(" + nested_type_name + "?)";
         obj = "(new " + nested_type_name + "())";
         code += "  public " + nested_type_name + "? ";
         code += get_nested_method_name + "(";
         code += ") { int o = __p.__offset(";
         code += NumToString(field.value.offset) + "); ";
         code += "return o != 0 ? " + conditional_cast + obj + ".__assign(";
         code += "__p.";
         code += "__indirect(__p.__vector(o)), ";
         code += "__p.bb) : null; }\n";
       }
       // Generate mutators for scalar fields or vectors of scalars.
       if (parser_.opts.mutable_buffer) {
         auto is_series = (IsSeries(field.value.type));
         const auto &underlying_type =
             is_series ? field.value.type.VectorType() : field.value.type;
         // Boolean parameters have to be explicitly converted to byte
         // representation.
         auto setter_parameter =
             underlying_type.base_type == BASE_TYPE_BOOL
                 ? "(byte)(" + EscapeKeyword(field.name) + " ? 1 : 0)"
                 : EscapeKeyword(field.name);
         auto mutator_prefix = MakeCamel("mutate", true);
         // A vector mutator also needs the index of the vector element it should
         // mutate.
         auto mutator_params = (is_series ? "(int j, " : "(") +
                               GenTypeGet(underlying_type) + " " +
                               EscapeKeyword(field.name) + ") { ";
         auto setter_index =
             is_series
                 ? "__p." +
                       (IsArray(field.value.type)
                            ? "bb_pos + " + NumToString(field.value.offset)
                            : "__vector(o)") +
                       +" + j * " + NumToString(InlineSize(underlying_type))
                 : (struct_def.fixed
                        ? "__p.bb_pos + " + NumToString(field.value.offset)
                        : "o + __p.bb_pos");
         if (IsScalar(underlying_type.base_type) && !IsUnion(field.value.type)) {
           code += "  public ";
           code += struct_def.fixed ? "void " : "bool ";
           code += mutator_prefix + Name(field);
           code += mutator_params;
           if (struct_def.fixed) {
             code += GenSetter(underlying_type) + "(" + setter_index + ", ";
             code += src_cast + setter_parameter + "); }\n";
           } else {
             code += "int o = __p.__offset(";
             code += NumToString(field.value.offset) + ");";
             code += " if (o != 0) { " + GenSetter(underlying_type);
             code += "(" + setter_index + ", " + src_cast + setter_parameter +
                     "); return true; } else { return false; } }\n";
           }
         }
       }
       if (parser_.opts.java_primitive_has_method &&
           IsScalar(field.value.type.base_type) && !struct_def.fixed) {
         auto vt_offset_constant = "  public static final int VT_" +
                                   MakeScreamingCamel(field.name) + " = " +
                                   NumToString(field.value.offset) + ";";
 
         code += vt_offset_constant;
         code += "\n";
       }
     }
     code += "\n";
     auto struct_has_create = false;
     std::set<flatbuffers::FieldDef *> field_has_create_set;
     flatbuffers::FieldDef *key_field = nullptr;
     if (struct_def.fixed) {
       struct_has_create = true;
       // create a struct constructor function
       code += "  public static " + GenOffsetType(struct_def) + " ";
       code += "Create";
       code += struct_def.name + "(FlatBufferBuilder builder";
       GenStructArgs(struct_def, code_ptr, "");
       code += ") {\n";
       GenStructBody(struct_def, code_ptr, "");
       code += "    return ";
       code += GenOffsetConstruct(struct_def, "builder.Offset");
       code += ";\n  }\n";
     } else {
       // Generate a method that creates a table in one go. This is only possible
       // when the table has no struct fields, since those have to be created
       // inline, and there's no way to do so in Java.
       bool has_no_struct_fields = true;
       int num_fields = 0;
       for (auto it = struct_def.fields.vec.begin();
            it != struct_def.fields.vec.end(); ++it) {
         auto &field = **it;
         if (field.deprecated) continue;
         if (IsStruct(field.value.type)) {
           has_no_struct_fields = false;
         } else {
           num_fields++;
         }
       }
       // JVM specifications restrict default constructor params to be < 255.
       // Longs and doubles take up 2 units, so we set the limit to be < 127.
       if ((has_no_struct_fields || opts.generate_object_based_api) &&
           num_fields && num_fields < 127) {
         struct_has_create = true;
         // Generate a table constructor of the form:
         // public static int createName(FlatBufferBuilder builder, args...)
         code += "  public static " + GenOffsetType(struct_def) + " ";
         code += "Create" + struct_def.name;
         code += "(FlatBufferBuilder builder";
         for (auto it = struct_def.fields.vec.begin();
              it != struct_def.fields.vec.end(); ++it) {
           auto &field = **it;
           if (field.deprecated) continue;
           code += ",\n      ";
           if (IsStruct(field.value.type) && opts.generate_object_based_api) {
             code += WrapInNameSpace(
                 field.value.type.struct_def->defined_namespace,
                 GenTypeName_ObjectAPI(field.value.type.struct_def->name, opts));
             code += " ";
             code += EscapeKeyword(field.name);
             code += " = null";
           } else {
             code += GenTypeBasic(field.value.type);
             if (field.IsScalarOptional()) { code += "?"; }
             code += " ";
             code += EscapeKeyword(field.name);
             if (!IsScalar(field.value.type.base_type)) code += "Offset";
 
             code += " = ";
             code += GenDefaultValueBasic(field);
           }
         }
         code += ") {\n    builder.";
         code += "StartTable(";
         code += NumToString(struct_def.fields.vec.size()) + ");\n";
         for (size_t size = struct_def.sortbysize ? sizeof(largest_scalar_t) : 1;
              size; size /= 2) {
           for (auto it = struct_def.fields.vec.rbegin();
                it != struct_def.fields.vec.rend(); ++it) {
             auto &field = **it;
             if (!field.deprecated &&
                 (!struct_def.sortbysize ||
                  size == SizeOf(field.value.type.base_type))) {
               code += "    " + struct_def.name + ".";
               code += "Add";
               code += Name(field) + "(builder, ";
               if (IsStruct(field.value.type) &&
                   opts.generate_object_based_api) {
                 code += GenTypePointer(field.value.type) + ".Pack(builder, " +
                         EscapeKeyword(field.name) + ")";
               } else {
                 code += EscapeKeyword(field.name);
                 if (!IsScalar(field.value.type.base_type)) code += "Offset";
               }
 
               code += ");\n";
             }
           }
         }
         code += "    return " + struct_def.name + ".";
         code += "End" + struct_def.name;
         code += "(builder);\n  }\n\n";
       }
       // Generate a set of static methods that allow table construction,
       // of the form:
       // public static void addName(FlatBufferBuilder builder, short name)
       // { builder.addShort(id, name, default); }
       // Unlike the Create function, these always work.
       code += "  public static void Start";
       code += struct_def.name;
       code += "(FlatBufferBuilder builder) { builder.";
       code += "StartTable(";
       code += NumToString(struct_def.fields.vec.size()) + "); }\n";
       for (auto it = struct_def.fields.vec.begin();
            it != struct_def.fields.vec.end(); ++it) {
         auto &field = **it;
         if (field.deprecated) continue;
         if (field.key) key_field = &field;
         code += "  public static void Add";
         code += Name(field);
         code += "(FlatBufferBuilder builder, ";
         code += GenTypeBasic(field.value.type);
         auto argname = MakeCamel(field.name, false);
         if (!IsScalar(field.value.type.base_type)) argname += "Offset";
         if (field.IsScalarOptional()) { code += "?"; }
         code += " " + EscapeKeyword(argname) + ") { builder.Add";
         code += GenMethod(field.value.type) + "(";
         code += NumToString(it - struct_def.fields.vec.begin()) + ", ";
         code += SourceCastBasic(field.value.type, field.IsScalarOptional());
         code += EscapeKeyword(argname);
         if (!IsScalar(field.value.type.base_type) &&
             field.value.type.base_type != BASE_TYPE_UNION) {
           code += ".Value";
         }
         if (!field.IsScalarOptional()) {
           // When the scalar is optional, use the builder method that doesn't
           // supply a default value. Otherwise, we to continue to use the
           // default value method.
           code += ", ";
           code += GenDefaultValue(field, false);
         }
         code += "); }\n";
         if (IsVector(field.value.type)) {
           auto vector_type = field.value.type.VectorType();
           auto alignment = InlineAlignment(vector_type);
           auto elem_size = InlineSize(vector_type);
           if (!IsStruct(vector_type)) {
             field_has_create_set.insert(&field);
             code += "  public static VectorOffset ";
             code += "Create";
             code += Name(field);
             code += "Vector(FlatBufferBuilder builder, ";
             code += GenTypeBasic(vector_type) + "[] data) ";
             code += "{ builder.StartVector(";
             code += NumToString(elem_size);
             code += ", data.Length, ";
             code += NumToString(alignment);
             code += "); for (int i = data.";
             code += "Length - 1; i >= 0; i--) builder.";
             code += "Add";
             code += GenMethod(vector_type);
             code += "(";
             // At the moment there is no support of the type Vector with optional enum, 
             // e.g. if we have enum type SomeEnum there is no way to define `SomeEmum?[] enums` in FlatBuffer schema, so isOptional = false
             code += SourceCastBasic(vector_type, false);
             code += "data[i]";
             if (vector_type.base_type == BASE_TYPE_STRUCT ||
                 IsString(vector_type))
               code += ".Value";
             code += "); return ";
             code += "builder.EndVector(); }\n";
 
             code += "  public static VectorOffset ";
             code += "Create";
             code += Name(field);
             code += "VectorBlock(FlatBufferBuilder builder, ";
             code += GenTypeBasic(vector_type) + "[] data) ";
             code += "{ builder.StartVector(";
             code += NumToString(elem_size);
             code += ", data.Length, ";
             code += NumToString(alignment);
             code += "); builder.Add(data); return builder.EndVector(); }\n";
           }
           // Generate a method to start a vector, data to be added manually
           // after.
           code += "  public static void Start";
           code += Name(field);
           code += "Vector(FlatBufferBuilder builder, int numElems) ";
           code += "{ builder.StartVector(";
           code += NumToString(elem_size);
           code += ", numElems, " + NumToString(alignment);
           code += "); }\n";
         }
       }
       code += "  public static " + GenOffsetType(struct_def) + " ";
       code += "End" + struct_def.name;
       code += "(FlatBufferBuilder builder) {\n    int o = builder.";
       code += "EndTable();\n";
       for (auto it = struct_def.fields.vec.begin();
            it != struct_def.fields.vec.end(); ++it) {
         auto &field = **it;
         if (!field.deprecated && field.IsRequired()) {
           code += "    builder.Required(o, ";
           code += NumToString(field.value.offset);
           code += ");  // " + field.name + "\n";
         }
       }
       code += "    return " + GenOffsetConstruct(struct_def, "o") + ";\n  }\n";
       if (parser_.root_struct_def_ == &struct_def) {
         std::string size_prefix[] = { "", "SizePrefixed" };
         for (int i = 0; i < 2; ++i) {
           code += "  public static void ";
           code += "Finish" + size_prefix[i] + struct_def.name;
           code +=
               "Buffer(FlatBufferBuilder builder, " + GenOffsetType(struct_def);
           code += " offset) {";
           code += " builder.Finish" + size_prefix[i] + "(offset";
           code += ".Value";
 
           if (parser_.file_identifier_.length())
             code += ", \"" + parser_.file_identifier_ + "\"";
           code += "); }\n";
         }
       }
     }
     // Only generate key compare function for table,
     // because `key_field` is not set for struct
     if (struct_def.has_key && !struct_def.fixed) {
       FLATBUFFERS_ASSERT(key_field);
       code += "\n  public static VectorOffset ";
       code += "CreateSortedVectorOf" + struct_def.name;
       code += "(FlatBufferBuilder builder, ";
       code += "Offset<" + struct_def.name + ">";
       code += "[] offsets) {\n";
       code += "    Array.Sort(offsets, (Offset<" + struct_def.name +
               "> o1, Offset<" + struct_def.name + "> o2) => " +
               GenKeyGetter(key_field);
       code += ");\n";
       code += "    return builder.CreateVectorOfTables(offsets);\n  }\n";
 
       code += "\n  public static " + struct_def.name + "?";
       code += " __lookup_by_key(";
       code += "int vectorLocation, ";
       code += GenTypeGet(key_field->value.type);
       code += " key, ByteBuffer bb) {\n";
       if (IsString(key_field->value.type)) {
         code += "    byte[] byteKey = ";
         code += "System.Text.Encoding.UTF8.GetBytes(key);\n";
       }
       code += "    int span = ";
       code += "bb.GetInt(vectorLocation - 4);\n";
       code += "    int start = 0;\n";
       code += "    while (span != 0) {\n";
       code += "      int middle = span / 2;\n";
       code += GenLookupKeyGetter(key_field);
       code += "      if (comp > 0) {\n";
       code += "        span = middle;\n";
       code += "      } else if (comp < 0) {\n";
       code += "        middle++;\n";
       code += "        start += middle;\n";
       code += "        span -= middle;\n";
       code += "      } else {\n";
       code += "        return ";
       code += "new " + struct_def.name + "()";
       code += ".__assign(tableOffset, bb);\n";
       code += "      }\n    }\n";
       code += "    return null;\n";
       code += "  }\n";
     }
 
     if (opts.generate_object_based_api) {
       GenPackUnPack_ObjectAPI(struct_def, code_ptr, opts, struct_has_create,
                               field_has_create_set);
     }
     code += "}\n\n";
 
     if (opts.generate_object_based_api) {
       GenStruct_ObjectAPI(struct_def, code_ptr, opts);
     }
   }
 
   void GenVectorAccessObject(StructDef &struct_def,
                              std::string *code_ptr) const {
     auto &code = *code_ptr;
     // Generate a vector of structs accessor class.
     code += "\n";
     code += "  ";
     if (!struct_def.attributes.Lookup("private")) code += "public ";
     code += "static struct Vector : BaseVector\n{\n";
 
     // Generate the __assign method that sets the field in a pre-existing
     // accessor object. This is to allow object reuse.
     std::string method_indent = "    ";
     code += method_indent + "public Vector ";
     code += "__assign(int _vector, int _element_size, ByteBuffer _bb) { ";
     code += "__reset(_vector, _element_size, _bb); return this; }\n\n";
 
     auto type_name = struct_def.name;
     auto method_start = method_indent + "public " + type_name + " Get";
     // Generate the accessors that don't do object reuse.
     code += method_start + "(int j) { return Get";
     code += "(new " + type_name + "(), j); }\n";
     code += method_start + "(" + type_name + " obj, int j) { ";
     code += " return obj.__assign(";
     code += struct_def.fixed ? "__p.__element(j)"
                              : "__p.__indirect(__p.__element(j), bb)";
     code += ", __p.bb); }\n";
     // See if we should generate a by-key accessor.
     if (!struct_def.fixed) {
       auto &fields = struct_def.fields.vec;
       for (auto kit = fields.begin(); kit != fields.end(); ++kit) {
         auto &key_field = **kit;
         if (key_field.key) {
           auto nullable_annotation =
               parser_.opts.gen_nullable ? "@Nullable " : "";
           code += method_indent + nullable_annotation;
           code += "public " + type_name + "? ";
           code += "GetByKey(";
           code += GenTypeGet(key_field.value.type) + " key) { ";
           code += " return __lookup_by_key(null, ";
           code += "__p.__vector(), key, ";
           code += "__p.bb); ";
           code += "}\n";
           code += method_indent + nullable_annotation;
           code += "public " + type_name + "?" + " ";
           code += "GetByKey(";
           code += type_name + "? obj, ";
           code += GenTypeGet(key_field.value.type) + " key) { ";
           code += " return __lookup_by_key(obj, ";
           code += "__p.__vector(), key, ";
           code += "__p.bb); ";
           code += "}\n";
           break;
         }
       }
     }
     code += "  }\n";
   }
 
   void GenEnum_ObjectAPI(EnumDef &enum_def, std::string *code_ptr,
                          const IDLOptions &opts) const {
     auto &code = *code_ptr;
     if (enum_def.generated) return;
     if (!enum_def.is_union) return;
     if (enum_def.attributes.Lookup("private")) {
       code += "internal ";
     } else {
       code += "public ";
     }
     auto union_name = enum_def.name + "Union";
     code += "class " + union_name + " {\n";
     // Type
     code += "  public " + enum_def.name + " Type { get; set; }\n";
     // Value
     code += "  public object Value { get; set; }\n";
     code += "\n";
     // Constructor
     code += "  public " + union_name + "() {\n";
     code += "    this.Type = " + enum_def.name + "." +
             enum_def.Vals()[0]->name + ";\n";
     code += "    this.Value = null;\n";
     code += "  }\n\n";
     // As<T>
     code += "  public T As<T>() where T : class { return this.Value as T; }\n";
     // As, From
     for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
       auto &ev = **it;
       if (ev.union_type.base_type == BASE_TYPE_NONE) continue;
       auto type_name = GenTypeGet_ObjectAPI(ev.union_type, opts);
       std::string accessibility =
           (ev.union_type.base_type == BASE_TYPE_STRUCT &&
            ev.union_type.struct_def->attributes.Lookup("private"))
               ? "internal"
               : "public";
       // As
       code += "  " + accessibility + " " + type_name + " As" + ev.name +
               "() { return this.As<" + type_name + ">(); }\n";
       // From
       auto lower_ev_name = ev.name;
       std::transform(lower_ev_name.begin(), lower_ev_name.end(),
                      lower_ev_name.begin(), CharToLower);
       code += "  " + accessibility + " static " + union_name + " From" +
               ev.name + "(" + type_name + " _" + lower_ev_name +
               ") { return new " + union_name + "{ Type = " + Name(enum_def) +
               "." + Name(ev) + ", Value = _" + lower_ev_name + " }; }\n";
     }
     code += "\n";
     // Pack()
     code += "  public static int Pack(FlatBuffers.FlatBufferBuilder builder, " +
             union_name + " _o) {\n";
     code += "    switch (_o.Type) {\n";
     for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
       auto &ev = **it;
       if (ev.union_type.base_type == BASE_TYPE_NONE) {
         code += "      default: return 0;\n";
       } else {
         code += "      case " + Name(enum_def) + "." + Name(ev) + ": return ";
         if (IsString(ev.union_type)) {
           code += "builder.CreateString(_o.As" + ev.name + "()).Value;\n";
         } else {
           code += GenTypeGet(ev.union_type) + ".Pack(builder, _o.As" + ev.name +
                   "()).Value;\n";
         }
       }
     }
     code += "    }\n";
     code += "  }\n";
     code += "}\n\n";
     // JsonConverter
     if (opts.cs_gen_json_serializer) {
       if (enum_def.attributes.Lookup("private")) {
         code += "internal ";
       } else {
         code += "public ";
       }
       code += "class " + union_name +
               "_JsonConverter : Newtonsoft.Json.JsonConverter {\n";
       code += "  public override bool CanConvert(System.Type objectType) {\n";
       code += "    return objectType == typeof(" + union_name +
               ") || objectType == typeof(System.Collections.Generic.List<" +
               union_name + ">);\n";
       code += "  }\n";
       code +=
           "  public override void WriteJson(Newtonsoft.Json.JsonWriter writer, "
           "object value, "
           "Newtonsoft.Json.JsonSerializer serializer) {\n";
       code += "    var _olist = value as System.Collections.Generic.List<" +
               union_name + ">;\n";
       code += "    if (_olist != null) {\n";
       code += "      writer.WriteStartArray();\n";
       code +=
           "      foreach (var _o in _olist) { this.WriteJson(writer, _o, "
           "serializer); }\n";
       code += "      writer.WriteEndArray();\n";
       code += "    } else {\n";
       code += "      this.WriteJson(writer, value as " + union_name +
               ", serializer);\n";
       code += "    }\n";
       code += "  }\n";
       code += "  public void WriteJson(Newtonsoft.Json.JsonWriter writer, " +
               union_name +
               " _o, "
               "Newtonsoft.Json.JsonSerializer serializer) {\n";
       code += "    if (_o == null) return;\n";
       code += "    serializer.Serialize(writer, _o.Value);\n";
       code += "  }\n";
       code +=
           "  public override object ReadJson(Newtonsoft.Json.JsonReader "
           "reader, "
           "System.Type objectType, "
           "object existingValue, Newtonsoft.Json.JsonSerializer serializer) "
           "{\n";
       code +=
           "    var _olist = existingValue as System.Collections.Generic.List<" +
           union_name + ">;\n";
       code += "    if (_olist != null) {\n";
       code += "      for (var _j = 0; _j < _olist.Count; ++_j) {\n";
       code += "        reader.Read();\n";
       code +=
           "        _olist[_j] = this.ReadJson(reader, _olist[_j], "
           "serializer);\n";
       code += "      }\n";
       code += "      reader.Read();\n";
       code += "      return _olist;\n";
       code += "    } else {\n";
       code += "      return this.ReadJson(reader, existingValue as " +
               union_name + ", serializer);\n";
       code += "    }\n";
       code += "  }\n";
       code += "  public " + union_name +
               " ReadJson(Newtonsoft.Json.JsonReader reader, " + union_name +
               " _o, Newtonsoft.Json.JsonSerializer serializer) {\n";
       code += "    if (_o == null) return null;\n";
       code += "    switch (_o.Type) {\n";
       for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end();
            ++it) {
         auto &ev = **it;
         if (ev.union_type.base_type == BASE_TYPE_NONE) {
           code += "      default: break;\n";
         } else {
           auto type_name = GenTypeGet_ObjectAPI(ev.union_type, opts);
           code += "      case " + Name(enum_def) + "." + Name(ev) +
                   ": _o.Value = serializer.Deserialize<" + type_name +
                   ">(reader); break;\n";
         }
       }
       code += "    }\n";
       code += "    return _o;\n";
       code += "  }\n";
       code += "}\n\n";
     }
   }
 
   std::string GenTypeName_ObjectAPI(const std::string &name,
                                     const IDLOptions &opts) const {
     return opts.object_prefix + name + opts.object_suffix;
   }
 
   void GenUnionUnPack_ObjectAPI(const EnumDef &enum_def, std::string *code_ptr,
                                 const std::string &camel_name,
                                 bool is_vector) const {
     auto &code = *code_ptr;
     std::string varialbe_name = "_o." + camel_name;
     std::string type_suffix = "";
     std::string func_suffix = "()";
     std::string indent = "    ";
     if (is_vector) {
       varialbe_name = "_o_" + camel_name;
       type_suffix = "(_j)";
       func_suffix = "(_j)";
       indent = "      ";
     }
     if (is_vector) {
       code += indent + "var " + varialbe_name + " = new ";
     } else {
       code += indent + varialbe_name + " = new ";
     }
     code += NamespacedName(enum_def) + "Union();\n";
     code += indent + varialbe_name + ".Type = this." + camel_name + "Type" +
             type_suffix + ";\n";
     code +=
         indent + "switch (this." + camel_name + "Type" + type_suffix + ") {\n";
     for (auto eit = enum_def.Vals().begin(); eit != enum_def.Vals().end();
          ++eit) {
       auto &ev = **eit;
       if (ev.union_type.base_type == BASE_TYPE_NONE) {
         code += indent + "  default: break;\n";
       } else {
         code += indent + "  case " + NamespacedName(enum_def) + "." + ev.name +
                 ":\n";
         code += indent + "    " + varialbe_name + ".Value = this." + camel_name;
         if (IsString(ev.union_type)) {
           code += "AsString" + func_suffix + ";\n";
         } else {
           code += "<" + GenTypeGet(ev.union_type) + ">" + func_suffix;
           code += ".HasValue ? this." + camel_name;
           code += "<" + GenTypeGet(ev.union_type) + ">" + func_suffix +
                   ".Value.UnPack() : null;\n";
         }
         code += indent + "    break;\n";
       }
     }
     code += indent + "}\n";
     if (is_vector) {
       code += indent + "_o." + camel_name + ".Add(" + varialbe_name + ");\n";
     }
   }
 
   void GenPackUnPack_ObjectAPI(
       StructDef &struct_def, std::string *code_ptr, const IDLOptions &opts,
       bool struct_has_create,
       const std::set<FieldDef *> &field_has_create) const {
     auto &code = *code_ptr;
     auto struct_name = GenTypeName_ObjectAPI(struct_def.name, opts);
     // UnPack()
     code += "  public " + struct_name + " UnPack() {\n";
     code += "    var _o = new " + struct_name + "();\n";
     code += "    this.UnPackTo(_o);\n";
     code += "    return _o;\n";
     code += "  }\n";
     // UnPackTo()
     code += "  public void UnPackTo(" + struct_name + " _o) {\n";
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       if (field.deprecated) continue;
       auto camel_name = Name(field);
       auto start = "    _o." + camel_name + " = ";
       switch (field.value.type.base_type) {
         case BASE_TYPE_STRUCT: {
           auto fixed = struct_def.fixed && field.value.type.struct_def->fixed;
           if (fixed) {
             code += start + "this." + camel_name + ".UnPack();\n";
           } else {
             code += start + "this." + camel_name + ".HasValue ? this." +
                     camel_name + ".Value.UnPack() : null;\n";
           }
           break;
         }
         case BASE_TYPE_ARRAY: {
           auto type_name = GenTypeGet_ObjectAPI(field.value.type, opts);
           auto length_str = NumToString(field.value.type.fixed_length);
           auto unpack_method = field.value.type.struct_def == nullptr
                                    ? ""
                                    : field.value.type.struct_def->fixed
                                          ? ".UnPack()"
                                          : "?.UnPack()";
           code += start + "new " + type_name.substr(0, type_name.length() - 1) +
                   length_str + "];\n";
           code += "    for (var _j = 0; _j < " + length_str + "; ++_j) { _o." +
                   camel_name + "[_j] = this." + camel_name + "(_j)" +
                   unpack_method + "; }\n";
           break;
         }
         case BASE_TYPE_VECTOR:
           if (field.value.type.element == BASE_TYPE_UNION) {
             code += start + "new " +
                     GenTypeGet_ObjectAPI(field.value.type, opts) + "();\n";
             code += "    for (var _j = 0; _j < this." + camel_name +
                     "Length; ++_j) {\n";
             GenUnionUnPack_ObjectAPI(*field.value.type.enum_def, code_ptr,
                                      camel_name, true);
             code += "    }\n";
           } else if (field.value.type.element != BASE_TYPE_UTYPE) {
             auto fixed = field.value.type.struct_def == nullptr;
             code += start + "new " +
                     GenTypeGet_ObjectAPI(field.value.type, opts) + "();\n";
             code += "    for (var _j = 0; _j < this." + camel_name +
                     "Length; ++_j) {";
             code += "_o." + camel_name + ".Add(";
             if (fixed) {
               code += "this." + camel_name + "(_j)";
             } else {
               code += "this." + camel_name + "(_j).HasValue ? this." +
                       camel_name + "(_j).Value.UnPack() : null";
             }
             code += ");}\n";
           }
           break;
         case BASE_TYPE_UTYPE: break;
         case BASE_TYPE_UNION: {
           GenUnionUnPack_ObjectAPI(*field.value.type.enum_def, code_ptr,
                                    camel_name, false);
           break;
         }
         default: {
           code += start + "this." + camel_name + ";\n";
           break;
         }
       }
     }
     code += "  }\n";
     // Pack()
     code += "  public static " + GenOffsetType(struct_def) +
             " Pack(FlatBufferBuilder builder, " + struct_name + " _o) {\n";
     code += "    if (_o == null) return default(" + GenOffsetType(struct_def) +
             ");\n";
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       if (field.deprecated) continue;
       auto camel_name = Name(field);
       // pre
       switch (field.value.type.base_type) {
         case BASE_TYPE_STRUCT: {
           if (!field.value.type.struct_def->fixed) {
             code += "    var _" + field.name + " = _o." + camel_name +
                     " == null ? default(" +
                     GenOffsetType(*field.value.type.struct_def) +
                     ") : " + GenTypeGet(field.value.type) +
                     ".Pack(builder, _o." + camel_name + ");\n";
           } else if (struct_def.fixed && struct_has_create) {
             std::vector<FieldArrayLength> array_lengths;
             FieldArrayLength tmp_array_length = {
               field.name,
               field.value.type.fixed_length,
             };
             array_lengths.push_back(tmp_array_length);
             GenStructPackDecl_ObjectAPI(*field.value.type.struct_def, code_ptr,
                                         array_lengths);
           }
           break;
         }
         case BASE_TYPE_STRING: {
           std::string create_string =
               field.shared ? "CreateSharedString" : "CreateString";
           code += "    var _" + field.name + " = _o." + camel_name +
                   " == null ? default(StringOffset) : "
                   "builder." +
                   create_string + "(_o." + camel_name + ");\n";
           break;
         }
         case BASE_TYPE_VECTOR: {
           if (field_has_create.find(&field) != field_has_create.end()) {
             auto property_name = camel_name;
             auto gen_for_loop = true;
             std::string array_name = "__" + field.name;
             std::string array_type = "";
             std::string to_array = "";
             switch (field.value.type.element) {
               case BASE_TYPE_STRING: {
                 std::string create_string =
                     field.shared ? "CreateSharedString" : "CreateString";
                 array_type = "StringOffset";
                 to_array += "builder." + create_string + "(_o." +
                             property_name + "[_j])";
                 break;
               }
               case BASE_TYPE_STRUCT:
                 array_type = "Offset<" + GenTypeGet(field.value.type) + ">";
                 to_array = GenTypeGet(field.value.type) + ".Pack(builder, _o." +
                            property_name + "[_j])";
                 break;
               case BASE_TYPE_UTYPE:
                 property_name = camel_name.substr(0, camel_name.size() - 4);
                 array_type = NamespacedName(*field.value.type.enum_def);
                 to_array = "_o." + property_name + "[_j].Type";
                 break;
               case BASE_TYPE_UNION:
                 array_type = "int";
                 to_array = NamespacedName(*field.value.type.enum_def) +
                            "Union.Pack(builder,  _o." + property_name + "[_j])";
                 break;
               default: gen_for_loop = false; break;
             }
             code += "    var _" + field.name + " = default(VectorOffset);\n";
             code += "    if (_o." + property_name + " != null) {\n";
             if (gen_for_loop) {
               code += "      var " + array_name + " = new " + array_type +
                       "[_o." + property_name + ".Count];\n";
               code += "      for (var _j = 0; _j < " + array_name +
                       ".Length; ++_j) { ";
               code += array_name + "[_j] = " + to_array + "; }\n";
             } else {
               code += "      var " + array_name + " = _o." + property_name +
                       ".ToArray();\n";
             }
             code += "      _" + field.name + " = Create" + camel_name +
                     "Vector(builder, " + array_name + ");\n";
             code += "    }\n";
           } else {
             auto pack_method =
                 field.value.type.struct_def == nullptr
                     ? "builder.Add" + GenMethod(field.value.type.VectorType()) +
                           "(_o." + camel_name + "[_j]);"
                     : GenTypeGet(field.value.type) + ".Pack(builder, _o." +
                           camel_name + "[_j]);";
             code += "    var _" + field.name + " = default(VectorOffset);\n";
             code += "    if (_o." + camel_name + " != null) {\n";
             code += "      Start" + camel_name + "Vector(builder, _o." +
                     camel_name + ".Count);\n";
             code += "      for (var _j = _o." + camel_name +
                     ".Count - 1; _j >= 0; --_j) { " + pack_method + " }\n";
             code += "      _" + field.name + " = builder.EndVector();\n";
             code += "    }\n";
           }
           break;
         }
         case BASE_TYPE_ARRAY: {
           if (field.value.type.struct_def != nullptr) {
             std::vector<FieldArrayLength> array_lengths;
             FieldArrayLength tmp_array_length = {
               field.name,
               field.value.type.fixed_length,
             };
             array_lengths.push_back(tmp_array_length);
             GenStructPackDecl_ObjectAPI(*field.value.type.struct_def, code_ptr,
                                         array_lengths);
           } else {
             code += "    var _" + field.name + " = _o." + camel_name + ";\n";
           }
           break;
         }
         case BASE_TYPE_UNION: {
           code += "    var _" + field.name + "_type = _o." + camel_name +
                   " == null ? " + NamespacedName(*field.value.type.enum_def) +
                   ".NONE : " + "_o." + camel_name + ".Type;\n";
           code +=
               "    var _" + field.name + " = _o." + camel_name +
               " == null ? 0 : " + GenTypeGet_ObjectAPI(field.value.type, opts) +
               ".Pack(builder, _o." + camel_name + ");\n";
           break;
         }
         default: break;
       }
     }
     if (struct_has_create) {
       // Create
       code += "    return Create" + struct_def.name + "(\n";
       code += "      builder";
       for (auto it = struct_def.fields.vec.begin();
            it != struct_def.fields.vec.end(); ++it) {
         auto &field = **it;
         if (field.deprecated) continue;
         auto camel_name = Name(field);
         switch (field.value.type.base_type) {
           case BASE_TYPE_STRUCT: {
             if (struct_def.fixed) {
               GenStructPackCall_ObjectAPI(*field.value.type.struct_def,
                                           code_ptr,
                                           "      _" + field.name + "_");
             } else {
               code += ",\n";
               if (field.value.type.struct_def->fixed) {
                 if (opts.generate_object_based_api)
                   code += "      _o." + camel_name;
                 else
                   code += "      " + GenTypeGet(field.value.type) +
                           ".Pack(builder, _o." + camel_name + ")";
               } else {
                 code += "      _" + field.name;
               }
             }
             break;
           }
           case BASE_TYPE_ARRAY: {
             if (field.value.type.struct_def != nullptr) {
               GenStructPackCall_ObjectAPI(*field.value.type.struct_def,
                                           code_ptr,
                                           "      _" + field.name + "_");
             } else {
               code += ",\n";
               code += "      _" + field.name;
             }
             break;
           }
           case BASE_TYPE_UNION: FLATBUFFERS_FALLTHROUGH();   // fall thru
           case BASE_TYPE_UTYPE: FLATBUFFERS_FALLTHROUGH();   // fall thru
           case BASE_TYPE_STRING: FLATBUFFERS_FALLTHROUGH();  // fall thru
           case BASE_TYPE_VECTOR: {
             code += ",\n";
             code += "      _" + field.name;
             break;
           }
           default:  // scalar
             code += ",\n";
             code += "      _o." + camel_name;
             break;
         }
       }
       code += ");\n";
     } else {
       // Start, End
       code += "    Start" + struct_def.name + "(builder);\n";
       for (auto it = struct_def.fields.vec.begin();
            it != struct_def.fields.vec.end(); ++it) {
         auto &field = **it;
         if (field.deprecated) continue;
         auto camel_name = Name(field);
         switch (field.value.type.base_type) {
           case BASE_TYPE_STRUCT: {
             if (field.value.type.struct_def->fixed) {
               code += "    Add" + camel_name + "(builder, " +
                       GenTypeGet(field.value.type) + ".Pack(builder, _o." +
                       camel_name + "));\n";
             } else {
               code +=
                   "    Add" + camel_name + "(builder, _" + field.name + ");\n";
             }
             break;
           }
           case BASE_TYPE_STRING: FLATBUFFERS_FALLTHROUGH();  // fall thru
           case BASE_TYPE_ARRAY: FLATBUFFERS_FALLTHROUGH();   // fall thru
           case BASE_TYPE_VECTOR: {
             code +=
                 "    Add" + camel_name + "(builder, _" + field.name + ");\n";
             break;
           }
           case BASE_TYPE_UTYPE: break;
           case BASE_TYPE_UNION: {
             code += "    Add" + camel_name + "Type(builder, _" + field.name +
                     "_type);\n";
             code +=
                 "    Add" + camel_name + "(builder, _" + field.name + ");\n";
             break;
           }
           // scalar
           default: {
             code +=
                 "    Add" + camel_name + "(builder, _o." + camel_name + ");\n";
             break;
           }
         }
       }
       code += "    return End" + struct_def.name + "(builder);\n";
     }
     code += "  }\n";
   }
 
   void GenStructPackDecl_ObjectAPI(
       const StructDef &struct_def, std::string *code_ptr,
       std::vector<FieldArrayLength> &array_lengths) const {
     auto &code = *code_ptr;
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       auto is_array = IsArray(field.value.type);
       const auto &field_type =
           is_array ? field.value.type.VectorType() : field.value.type;
       FieldArrayLength tmp_array_length = {
         field.name,
         field_type.fixed_length,
       };
       array_lengths.push_back(tmp_array_length);
       if (field_type.struct_def != nullptr) {
         GenStructPackDecl_ObjectAPI(*field_type.struct_def, code_ptr,
                                     array_lengths);
       } else {
         std::vector<FieldArrayLength> array_only_lengths;
         for (size_t i = 0; i < array_lengths.size(); ++i) {
           if (array_lengths[i].length > 0) {
             array_only_lengths.push_back(array_lengths[i]);
           }
         }
         std::string name;
         for (size_t i = 0; i < array_lengths.size(); ++i) {
           name += "_" + array_lengths[i].name;
         }
         code += "    var " + name + " = ";
         if (array_only_lengths.size() > 0) {
           code += "new " + GenTypeBasic(field_type) + "[";
           for (size_t i = 0; i < array_only_lengths.size(); ++i) {
             if (i != 0) { code += ","; }
             code += NumToString(array_only_lengths[i].length);
           }
           code += "];\n";
           code += "    ";
           // initialize array
           for (size_t i = 0; i < array_only_lengths.size(); ++i) {
             auto idx = "idx" + NumToString(i);
             code += "for (var " + idx + " = 0; " + idx + " < " +
                     NumToString(array_only_lengths[i].length) + "; ++" + idx +
                     ") {";
           }
           for (size_t i = 0; i < array_only_lengths.size(); ++i) {
             auto idx = "idx" + NumToString(i);
             if (i == 0) {
               code += name + "[" + idx;
             } else {
               code += "," + idx;
             }
           }
           code += "] = _o";
           for (size_t i = 0, j = 0; i < array_lengths.size(); ++i) {
             code += "." + MakeCamel(array_lengths[i].name, true);
             if (array_lengths[i].length <= 0) continue;
             code += "[idx" + NumToString(j++) + "]";
           }
           code += ";";
           for (size_t i = 0; i < array_only_lengths.size(); ++i) {
             code += "}";
           }
         } else {
           code += "_o";
           for (size_t i = 0; i < array_lengths.size(); ++i) {
             code += "." + MakeCamel(array_lengths[i].name, true);
           }
           code += ";";
         }
         code += "\n";
       }
       array_lengths.pop_back();
     }
   }
 
   void GenStructPackCall_ObjectAPI(const StructDef &struct_def,
                                    std::string *code_ptr,
                                    std::string prefix) const {
     auto &code = *code_ptr;
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       const auto &field_type = field.value.type;
       if (field_type.struct_def != nullptr) {
         GenStructPackCall_ObjectAPI(*field_type.struct_def, code_ptr,
                                     prefix + field.name + "_");
       } else {
         code += ",\n";
         code += prefix + field.name;
       }
     }
   }
 
   std::string GenTypeGet_ObjectAPI(flatbuffers::Type type,
                                    const IDLOptions &opts) const {
     auto type_name = GenTypeGet(type);
     // Replace to ObjectBaseAPI Type Name
     switch (type.base_type) {
       case BASE_TYPE_STRUCT: FLATBUFFERS_FALLTHROUGH();  // fall thru
       case BASE_TYPE_ARRAY: FLATBUFFERS_FALLTHROUGH();   // fall thru
       case BASE_TYPE_VECTOR: {
         if (type.struct_def != nullptr) {
           auto type_name_length = type.struct_def->name.length();
           auto new_type_name =
               GenTypeName_ObjectAPI(type.struct_def->name, opts);
           type_name.replace(type_name.length() - type_name_length,
                             type_name_length, new_type_name);
         } else if (type.element == BASE_TYPE_UNION) {
           type_name = NamespacedName(*type.enum_def) + "Union";
         }
         break;
       }
 
       case BASE_TYPE_UNION: {
         type_name = NamespacedName(*type.enum_def) + "Union";
         break;
       }
       default: break;
     }
 
     switch (type.base_type) {
       case BASE_TYPE_ARRAY: {
         type_name = type_name + "[]";
         break;
       }
       case BASE_TYPE_VECTOR: {
         type_name = "List<" + type_name + ">";
         break;
       }
       default: break;
     }
     return type_name;
   }
 
   void GenStruct_ObjectAPI(StructDef &struct_def, std::string *code_ptr,
                            const IDLOptions &opts) const {
     auto &code = *code_ptr;
     if (struct_def.attributes.Lookup("private")) {
       code += "internal ";
     } else {
       code += "public ";
     }
     if (struct_def.attributes.Lookup("csharp_partial")) {
       // generate a partial class for this C# struct/table
       code += "partial ";
     }
     auto class_name = GenTypeName_ObjectAPI(struct_def.name, opts);
     code += "class " + class_name;
     code += "\n{\n";
     // Generate Properties
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       if (field.deprecated) continue;
       if (field.value.type.base_type == BASE_TYPE_UTYPE) continue;
       if (field.value.type.element == BASE_TYPE_UTYPE) continue;
       auto type_name = GenTypeGet_ObjectAPI(field.value.type, opts);
       if (field.IsScalarOptional()) type_name += "?";
       auto camel_name = Name(field);
       if (opts.cs_gen_json_serializer) {
         if (IsUnion(field.value.type)) {
           auto utype_name = NamespacedName(*field.value.type.enum_def);
           code +=
               "  [Newtonsoft.Json.JsonProperty(\"" + field.name + "_type\")]\n";
           if (IsVector(field.value.type)) {
             code += "  private " + utype_name + "[] " + camel_name + "Type {\n";
             code += "    get {\n";
             code += "      if (this." + camel_name + " == null) return null;\n";
             code += "      var _o = new " + utype_name + "[this." + camel_name +
                     ".Count];\n";
             code +=
                 "      for (var _j = 0; _j < _o.Length; ++_j) { _o[_j] = "
                 "this." +
                 camel_name + "[_j].Type; }\n";
             code += "      return _o;\n";
             code += "    }\n";
             code += "    set {\n";
             code += "      this." + camel_name + " = new List<" + utype_name +
                     "Union>();\n";
             code += "      for (var _j = 0; _j < value.Length; ++_j) {\n";
             code += "        var _o = new " + utype_name + "Union();\n";
             code += "        _o.Type = value[_j];\n";
             code += "        this." + camel_name + ".Add(_o);\n";
             code += "      }\n";
             code += "    }\n";
             code += "  }\n";
           } else {
             code += "  private " + utype_name + " " + camel_name + "Type {\n";
             code += "    get {\n";
             code += "      return this." + camel_name + " != null ? this." +
                     camel_name + ".Type : " + utype_name + ".NONE;\n";
             code += "    }\n";
             code += "    set {\n";
             code += "      this." + camel_name + " = new " + utype_name +
                     "Union();\n";
             code += "      this." + camel_name + ".Type = value;\n";
             code += "    }\n";
             code += "  }\n";
           }
         }
         code += "  [Newtonsoft.Json.JsonProperty(\"" + field.name + "\")]\n";
         if (IsUnion(field.value.type)) {
           auto union_name =
               (IsVector(field.value.type))
                   ? GenTypeGet_ObjectAPI(field.value.type.VectorType(), opts)
                   : type_name;
           code += "  [Newtonsoft.Json.JsonConverter(typeof(" + union_name +
                   "_JsonConverter))]\n";
         }
         if (field.attributes.Lookup("hash")) {
           code += "  [Newtonsoft.Json.JsonIgnore()]\n";
         }
       }
       code += "  public " + type_name + " " + camel_name + " { get; set; }\n";
     }
     // Generate Constructor
     code += "\n";
     code += "  public " + class_name + "() {\n";
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       if (field.deprecated) continue;
       if (field.value.type.base_type == BASE_TYPE_UTYPE) continue;
       if (field.value.type.element == BASE_TYPE_UTYPE) continue;
       code += "    this." + Name(field) + " = ";
       auto type_name = GenTypeGet_ObjectAPI(field.value.type, opts);
       if (IsScalar(field.value.type.base_type)) {
         code += GenDefaultValue(field) + ";\n";
       } else {
         switch (field.value.type.base_type) {
           case BASE_TYPE_STRUCT: {
             if (IsStruct(field.value.type)) {
               code += "new " + type_name + "();\n";
             } else {
               code += "null;\n";
             }
             break;
           }
           case BASE_TYPE_ARRAY: {
             code += "new " + type_name.substr(0, type_name.length() - 1) +
                     NumToString(field.value.type.fixed_length) + "];\n";
             break;
           }
           default: {
             code += "null;\n";
             break;
           }
         }
       }
     }
     code += "  }\n";
     // Generate Serialization
     if (opts.cs_gen_json_serializer &&
         parser_.root_struct_def_ == &struct_def) {
       code += "\n";
       code += "  public static " + class_name +
               " DeserializeFromJson(string jsonText) {\n";
       code += "    return Newtonsoft.Json.JsonConvert.DeserializeObject<" +
               class_name + ">(jsonText);\n";
       code += "  }\n";
       code += "  public string SerializeToJson() {\n";
       code +=
           "    return Newtonsoft.Json.JsonConvert.SerializeObject(this, "
           "Newtonsoft.Json.Formatting.Indented);\n";
       code += "  }\n";
     }
     if (parser_.root_struct_def_ == &struct_def) {
       code += "  public static " + class_name +
               " DeserializeFromBinary(byte[] fbBuffer) {\n";
       code += "    return " + struct_def.name + ".GetRootAs" + struct_def.name +
               "(new ByteBuffer(fbBuffer)).UnPack();\n";
       code += "  }\n";
       code += "  public byte[] SerializeToBinary() {\n";
       code += "    var fbb = new FlatBufferBuilder(0x10000);\n";
       code += "    " + struct_def.name + ".Finish" + struct_def.name +
               "Buffer(fbb, " + struct_def.name + ".Pack(fbb, this));\n";
       code += "    return fbb.DataBuffer.ToSizedArray();\n";
       code += "  }\n";
     }
     code += "}\n\n";
   }
 
   // This tracks the current namespace used to determine if a type need to be
   // prefixed by its namespace
   const Namespace *cur_name_space_;
 };
 }  // namespace csharp
diff --git a/tests/FlatBuffers.Test/FlatBuffers.Core.Test.csproj b/tests/FlatBuffers.Test/FlatBuffers.Core.Test.csproj
index d22adf7b..813616e9 100644
--- a/tests/FlatBuffers.Test/FlatBuffers.Core.Test.csproj
+++ b/tests/FlatBuffers.Test/FlatBuffers.Core.Test.csproj
@@ -1,177 +1,186 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <PropertyGroup>
     <OutputType>Exe</OutputType>
     <TargetFramework>netcoreapp3.1</TargetFramework>
   </PropertyGroup>
 
   <ItemGroup>
     <Compile Remove="Properties\AssemblyInfo.cs" />
   </ItemGroup>
 
   <PropertyGroup Condition="'$(UnsafeByteBuffer)' == 'true'">
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <DefineConstants>$(DefineConstants);UNSAFE_BYTEBUFFER</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(EnableSpanT)' == 'true'">
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <DefineConstants>$(DefineConstants);ENABLE_SPAN_T</DefineConstants>
   </PropertyGroup>
 
   <ItemGroup>
     <Compile Include="..\..\net\FlatBuffers\ByteBuffer.cs">
       <Link>FlatBuffers\ByteBuffer.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\ByteBufferUtil.cs">
       <Link>FlatBuffers\ByteBufferUtil.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\IFlatbufferObject.cs">
       <Link>FlatBuffers\IFlatbufferObject.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\Offset.cs">
       <Link>FlatBuffers\Offset.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\FlatBufferBuilder.cs">
       <Link>FlatBuffers\FlatBufferBuilder.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\FlatBufferConstants.cs">
       <Link>FlatBuffers\FlatBufferConstants.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\Struct.cs">
       <Link>FlatBuffers\Struct.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\Table.cs">
       <Link>FlatBuffers\Table.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example2\Monster.cs">
       <Link>MyGame\Example2\Monster.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Any.cs">
       <Link>MyGame\Example\Any.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\AnyAmbiguousAliases.cs">
       <Link>MyGame\Example\AnyAmbiguousAliases.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\AnyUniqueAliases.cs">
       <Link>MyGame\Example\AnyUniqueAliases.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Color.cs">
       <Link>MyGame\Example\Color.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Race.cs">
       <Link>MyGame\Example\Race.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Monster.cs">
       <Link>MyGame\Example\Monster.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Referrable.cs">
       <Link>MyGame\Example\Referrable.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Stat.cs">
       <Link>MyGame\Example\Stat.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Test.cs">
       <Link>MyGame\Example\Test.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\TestSimpleTableWithEnum.cs">
       <Link>MyGame\Example\TestSimpleTableWithEnum.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\TypeAliases.cs">
       <Link>MyGame\Example\TypeAliases.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Vec3.cs">
       <Link>MyGame\Example\Vec3.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Ability.cs">
       <Link>MyGame\Example\Ability.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\ArrayTable.cs">
       <Link>MyGame\Example\ArrayTable.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\ArrayStruct.cs">
       <Link>MyGame\Example\ArrayStruct.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\NestedStruct.cs">
       <Link>MyGame\Example\NestedStruct.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\TestEnum.cs">
       <Link>MyGame\Example\TestEnum.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\InParentNamespace.cs">
       <Link>MyGame\InParentNamespace.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\NamespaceB\EnumInNestedNS.cs">
       <Link>NamespaceA\NamespaceB\EnumInNestedNS.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\NamespaceB\StructInNestedNS.cs">
       <Link>NamespaceA\NamespaceB\StructInNestedNS.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\NamespaceB\TableInNestedNS.cs">
       <Link>NamespaceA\NamespaceB\TableInNestedNS.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\NamespaceB\UnionInNestedNS.cs">
       <Link>NamespaceA\NamespaceB\UnionInNestedNS.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\TableInFirstNS.cs">
       <Link>NamespaceA\TableInFirstNS.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\Attacker.cs">
       <Link>union_vector\Attacker.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\BookReader.cs">
       <Link>union_vector\BookReader.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\Character.cs">
       <Link>union_vector\Character.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\Movie.cs">
       <Link>union_vector\Movie.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\Rapunzel.cs">
       <Link>union_vector\Rapunzel.cs</Link>
     </Compile>
     <Compile Include="..\optional_scalars\OptionalByte.cs">
       <Link>optional_scalars\OptionalByte.cs</Link>
     </Compile>
     <Compile Include="..\optional_scalars\ScalarStuff.cs">
       <Link>optional_scalars\ScalarStuff.cs</Link>
     </Compile>
     <Compile Include="..\KeywordTest\ABC.cs">
       <Link>KeywordTest\ABC.cs</Link>
     </Compile>
     <Compile Include="..\KeywordTest\public.cs">
       <Link>KeywordTest\public.cs</Link>
     </Compile>
     <Compile Include="..\KeywordTest\KeywordsInTable.cs">
       <Link>KeywordTest\KeywordsInTable.cs</Link>
     </Compile>
     <Compile Include="..\KeywordTest\KeywordsInUnion.cs">
       <Link>KeywordTest\KeywordsInUnion.cs</Link>
     </Compile>
+    <Compile Include="..\nested_namespace_test\nested_namespace_test1_generated.cs">
+      <Link>nested_namespace_test\nested_namespace_test1_generated.cs</Link>
+    </Compile>
+    <Compile Include="..\nested_namespace_test\nested_namespace_test2_generated.cs">
+      <Link>nested_namespace_test\nested_namespace_test2_generated.cs</Link>
+    </Compile>
+    <Compile Include="..\nested_namespace_test\nested_namespace_test3_generated.cs">
+      <Link>nested_namespace_test\nested_namespace_test3_generated.cs</Link>
+    </Compile>
   </ItemGroup>
 
   <ItemGroup>
     <None Remove=".gitignore" />
     <None Remove="clean.sh" />
     <None Remove="NetTest.sh" />
     <None Remove="packages.config" />
     <None Remove="README.md" />
   </ItemGroup>
 
   <ItemGroup>
     <Content Include="..\monsterdata_test.mon">
       <Link>Resources\monsterdata_test.mon</Link>
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
     <Content Include="..\monsterdata_test.json">
       <Link>Resources\monsterdata_test.json</Link>
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
   </ItemGroup>
 
   <ItemGroup>
     <PackageReference Include="Newtonsoft.Json" Version="12.0.3" />
   </ItemGroup>
 
 </Project>
diff --git a/tests/FlatBuffers.Test/FlatBuffers.Test.csproj b/tests/FlatBuffers.Test/FlatBuffers.Test.csproj
index c5e3ea0f..73afe023 100644
--- a/tests/FlatBuffers.Test/FlatBuffers.Test.csproj
+++ b/tests/FlatBuffers.Test/FlatBuffers.Test.csproj
@@ -1,217 +1,227 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <Project ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
     <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
     <ProjectGuid>{9DB0B5E7-757E-4BD1-A5F6-279390331254}</ProjectGuid>
     <OutputType>Exe</OutputType>
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>FlatBuffers.Test</RootNamespace>
     <AssemblyName>FlatBuffers.Test</AssemblyName>
     <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
     <RuntimeIdentifier>win</RuntimeIdentifier>
     <LangVersion>4</LangVersion>
     <FileAlignment>512</FileAlignment>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
     <OutputPath>bin\Debug\</OutputPath>
     <DefineConstants>TRACE;DEBUG</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
     <OutputPath>bin\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <PropertyGroup>
     <StartupObject />
   </PropertyGroup>
   <PropertyGroup Condition="'$(UnsafeByteBuffer)' == 'true'">
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <DefineConstants>$(DefineConstants);UNSAFE_BYTEBUFFER</DefineConstants>
   </PropertyGroup>
   <ItemGroup>
     <PackageReference Include="Newtonsoft.Json">
       <Version>12.0.3</Version>
     </PackageReference>
   </ItemGroup>
   <ItemGroup>
     <Reference Include="Newtonsoft.Json, Version=12.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
       <HintPath>packages\Newtonsoft.Json.12.0.3\lib\net35\Newtonsoft.Json.dll</HintPath>
     </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
     </Reference>
   </ItemGroup>
   <ItemGroup>
     <Compile Include="..\..\net\FlatBuffers\ByteBuffer.cs">
       <Link>FlatBuffers\ByteBuffer.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\ByteBufferUtil.cs">
       <Link>FlatBuffers\ByteBufferUtil.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\IFlatbufferObject.cs">
       <Link>FlatBuffers\IFlatbufferObject.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\Offset.cs">
       <Link>FlatBuffers\Offset.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\FlatBufferBuilder.cs">
       <Link>FlatBuffers\FlatBufferBuilder.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\FlatBufferConstants.cs">
       <Link>FlatBuffers\FlatBufferConstants.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\Struct.cs">
       <Link>FlatBuffers\Struct.cs</Link>
     </Compile>
     <Compile Include="..\..\net\FlatBuffers\Table.cs">
       <Link>FlatBuffers\Table.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example2\Monster.cs">
       <Link>MyGame\Example2\Monster.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Any.cs">
       <Link>MyGame\Example\Any.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\AnyAmbiguousAliases.cs">
       <Link>MyGame\Example\AnyAmbiguousAliases.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\AnyUniqueAliases.cs">
       <Link>MyGame\Example\AnyUniqueAliases.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Color.cs">
       <Link>MyGame\Example\Color.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Race.cs">
       <Link>MyGame\Example\Race.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Monster.cs">
       <Link>MyGame\Example\Monster.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Referrable.cs">
       <Link>MyGame\Example\Referrable.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Stat.cs">
       <Link>MyGame\Example\Stat.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Test.cs">
       <Link>MyGame\Example\Test.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\TestSimpleTableWithEnum.cs">
       <Link>MyGame\Example\TestSimpleTableWithEnum.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\TypeAliases.cs">
       <Link>MyGame\Example\TypeAliases.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Vec3.cs">
       <Link>MyGame\Example\Vec3.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\Ability.cs">
       <Link>MyGame\Example\Ability.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\ArrayTable.cs">
       <Link>MyGame\Example\ArrayTable.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\ArrayStruct.cs">
       <Link>MyGame\Example\ArrayStruct.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\NestedStruct.cs">
       <Link>MyGame\Example\NestedStruct.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\Example\TestEnum.cs">
       <Link>MyGame\Example\TestEnum.cs</Link>
     </Compile>
     <Compile Include="..\MyGame\InParentNamespace.cs">
       <Link>MyGame\InParentNamespace.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\NamespaceB\EnumInNestedNS.cs">
       <Link>NamespaceA\NamespaceB\EnumInNestedNS.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\NamespaceB\StructInNestedNS.cs">
       <Link>NamespaceA\NamespaceB\StructInNestedNS.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\NamespaceB\TableInNestedNS.cs">
       <Link>NamespaceA\NamespaceB\TableInNestedNS.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\NamespaceB\UnionInNestedNS.cs">
       <Link>NamespaceA\NamespaceB\UnionInNestedNS.cs</Link>
     </Compile>
     <Compile Include="..\namespace_test\NamespaceA\TableInFirstNS.cs">
       <Link>NamespaceA\TableInFirstNS.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\Attacker.cs">
       <Link>union_vector\Attacker.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\BookReader.cs">
       <Link>union_vector\BookReader.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\Character.cs">
       <Link>union_vector\Character.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\Movie.cs">
       <Link>union_vector\Movie.cs</Link>
     </Compile>
     <Compile Include="..\union_vector\Rapunzel.cs">
       <Link>union_vector\Rapunzel.cs</Link>
     </Compile>
     <Compile Include="..\optional_scalars\OptionalByte.cs">
       <Link>optional_scalars\OptionalByte.cs</Link>
     </Compile>
     <Compile Include="..\optional_scalars\ScalarStuff.cs">
       <Link>optional_scalars\ScalarStuff.cs</Link>
     </Compile>
     <Compile Include="..\KeywordTest\ABC.cs">
       <Link>KeywordTest\ABC.cs</Link>
     </Compile>
     <Compile Include="..\KeywordTest\public.cs">
       <Link>KeywordTest\public.cs</Link>
     </Compile>
     <Compile Include="..\KeywordTest\KeywordsInTable.cs">
       <Link>KeywordTest\KeywordsInTable.cs</Link>
     </Compile>
     <Compile Include="..\KeywordTest\KeywordsInUnion.cs">
       <Link>KeywordTest\KeywordsInUnion.cs</Link>
     </Compile>
+    <Compile Include="..\nested_namespace_test\nested_namespace_test1_generated.cs">
+      <Link>nested_namespace_test\nested_namespace_test1_generated.cs</Link>
+    </Compile>
+    <Compile Include="..\nested_namespace_test\nested_namespace_test2_generated.cs">
+      <Link>nested_namespace_test\nested_namespace_test2_generated.cs</Link>
+    </Compile>
+    <Compile Include="..\nested_namespace_test\nested_namespace_test3_generated.cs">
+      <Link>nested_namespace_test\nested_namespace_test3_generated.cs</Link>
+    </Compile>
+  </ItemGroup>
     <Compile Include="Assert.cs" />
     <Compile Include="ByteBufferTests.cs" />
     <Compile Include="FlatBufferBuilderTests.cs" />
     <Compile Include="FlatBuffersFuzzTests.cs" />
     <Compile Include="FlatBuffersTestClassAttribute.cs" />
     <Compile Include="FlatBuffersTestMethodAttribute.cs" />
     <Compile Include="FuzzTestData.cs" />
     <Compile Include="Lcg.cs" />
     <Compile Include="Program.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="FlatBuffersExampleTests.cs" />
     <Compile Include="TestTable.cs" />
   </ItemGroup>
   <ItemGroup>
     <Content Include="..\monsterdata_test.mon">
       <Link>Resources\monsterdata_test.mon</Link>
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
     <Content Include="..\monsterdata_test.json">
       <Link>Resources\monsterdata_test.json</Link>
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </Content>
   </ItemGroup>
   <ItemGroup>
     <None Include="packages.config" />
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it.
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
   </Target>
   <Target Name="AfterBuild">
   </Target>
   -->
 </Project>
\ No newline at end of file
diff --git a/tests/generate_code.bat b/tests/generate_code.bat
index bee552bb..10cce2e0 100644
--- a/tests/generate_code.bat
+++ b/tests/generate_code.bat
@@ -74,6 +74,9 @@ set TEST_NOINCL_FLAGS=%TEST_BASE_FLAGS% --no-includes
 @rem Generate the keywords tests
 ..\%buildtype%\flatc.exe --csharp --scoped-enums %TEST_BASE_FLAGS% %TEST_CS_FLAGS% keyword_test.fbs || goto FAIL
 
+@rem Generate the nested namespace tests
+..\%buildtype%\flatc.exe --csharp --cs-global-alias --gen-onefile %TEST_BASE_FLAGS% %TEST_CS_FLAGS% -o nested_namespace_test nested_namespace_test/nested_namespace_test1.fbs nested_namespace_test/nested_namespace_test2.fbs nested_namespace_test/nested_namespace_test3.fbs || goto FAIL
+
 if NOT "%MONSTER_EXTRA%"=="skip" (
   @echo Generate MosterExtra
   ..\%buildtype%\flatc.exe --cpp --java --csharp %TEST_NOINCL_FLAGS% %TEST_CPP_FLAGS% %TEST_CS_FLAGS% monster_extra.fbs monsterdata_extra.json || goto FAIL
diff --git a/tests/generate_code.sh b/tests/generate_code.sh
index b7a442b7..ccb262bb 100755
--- a/tests/generate_code.sh
+++ b/tests/generate_code.sh
@@ -77,6 +77,9 @@ $TEST_NOINCL_FLAGS $TEST_CPP_FLAGS $TEST_CS_FLAGS $TEST_TS_FLAGS -o namespace_te
 ../flatc --csharp $TEST_BASE_FLAGS $TEST_CS_FLAGS ./keyword_test.fbs
 ../flatc --rust $TEST_RUST_FLAGS -o keyword_test ./keyword_test.fbs
 
+# Generate the keywords tests
+../flatc --csharp --cs-global-alias --gen-onefile $TEST_BASE_FLAGS $TEST_CS_FLAGS -o nested_namespace_test nested_namespace_test/nested_namespace_test1.fbs nested_namespace_test/nested_namespace_test2.fbs nested_namespace_test/nested_namespace_test3.fbs
+
 working_dir=`pwd`
 cd FlatBuffers.Test.Swift/Tests/FlatBuffers.Test.SwiftTests
 $working_dir/../flatc --bfbs-filenames $working_dir --swift --grpc $TEST_NOINCL_FLAGS $TEST_CPP_FLAGS $TEST_CS_FLAGS -I ${working_dir}/include_test ${working_dir}/monster_test.fbs
diff --git a/tests/nested_namespace_test/nested_namespace_test1.fbs b/tests/nested_namespace_test/nested_namespace_test1.fbs
new file mode 100644
index 00000000..1b438473
--- /dev/null
+++ b/tests/nested_namespace_test/nested_namespace_test1.fbs
@@ -0,0 +1,3 @@
+namespace NamespaceB;
+
+enum Color:byte { Red, Green, Blue }
diff --git a/tests/nested_namespace_test/nested_namespace_test1_generated.cs b/tests/nested_namespace_test/nested_namespace_test1_generated.cs
new file mode 100644
index 00000000..e42e96a9
--- /dev/null
+++ b/tests/nested_namespace_test/nested_namespace_test1_generated.cs
@@ -0,0 +1,21 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace NamespaceB
+{
+
+using global::System;
+using global::System.Collections.Generic;
+using global::FlatBuffers;
+
+[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
+public enum Color : sbyte
+{
+  Red = 0,
+  Green = 1,
+  Blue = 2,
+};
+
+
+}
diff --git a/tests/nested_namespace_test/nested_namespace_test2.fbs b/tests/nested_namespace_test/nested_namespace_test2.fbs
new file mode 100644
index 00000000..f2e04c3f
--- /dev/null
+++ b/tests/nested_namespace_test/nested_namespace_test2.fbs
@@ -0,0 +1,3 @@
+namespace NamespaceA.NamespaceB;
+
+enum Color:byte { Purple }
diff --git a/tests/nested_namespace_test/nested_namespace_test2_generated.cs b/tests/nested_namespace_test/nested_namespace_test2_generated.cs
new file mode 100644
index 00000000..cdc1b09f
--- /dev/null
+++ b/tests/nested_namespace_test/nested_namespace_test2_generated.cs
@@ -0,0 +1,19 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace NamespaceA.NamespaceB
+{
+
+using global::System;
+using global::System.Collections.Generic;
+using global::FlatBuffers;
+
+[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
+public enum Color : sbyte
+{
+  Purple = 0,
+};
+
+
+}
diff --git a/tests/nested_namespace_test/nested_namespace_test3.fbs b/tests/nested_namespace_test/nested_namespace_test3.fbs
new file mode 100644
index 00000000..2672ace7
--- /dev/null
+++ b/tests/nested_namespace_test/nested_namespace_test3.fbs
@@ -0,0 +1,7 @@
+include "nested_namespace_test1.fbs";
+
+namespace NamespaceA.NamespaceB;
+
+table ColorTestTable {
+  color:NamespaceB.Color = Blue;
+}
diff --git a/tests/nested_namespace_test/nested_namespace_test3_generated.cs b/tests/nested_namespace_test/nested_namespace_test3_generated.cs
new file mode 100644
index 00000000..f2f37789
--- /dev/null
+++ b/tests/nested_namespace_test/nested_namespace_test3_generated.cs
@@ -0,0 +1,65 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace NamespaceA.NamespaceB
+{
+
+using global::System;
+using global::System.Collections.Generic;
+using global::FlatBuffers;
+
+public struct ColorTestTable : IFlatbufferObject
+{
+  private Table __p;
+  public ByteBuffer ByteBuffer { get { return __p.bb; } }
+  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
+  public static ColorTestTable GetRootAsColorTestTable(ByteBuffer _bb) { return GetRootAsColorTestTable(_bb, new ColorTestTable()); }
+  public static ColorTestTable GetRootAsColorTestTable(ByteBuffer _bb, ColorTestTable obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
+  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
+  public ColorTestTable __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }
+
+  public global::NamespaceB.Color Color { get { int o = __p.__offset(4); return o != 0 ? (global::NamespaceB.Color)__p.bb.GetSbyte(o + __p.bb_pos) : global::NamespaceB.Color.Blue; } }
+  public bool MutateColor(global::NamespaceB.Color color) { int o = __p.__offset(4); if (o != 0) { __p.bb.PutSbyte(o + __p.bb_pos, (sbyte)color); return true; } else { return false; } }
+
+  public static Offset<global::NamespaceA.NamespaceB.ColorTestTable> CreateColorTestTable(FlatBufferBuilder builder,
+      global::NamespaceB.Color color = global::NamespaceB.Color.Blue) {
+    builder.StartTable(1);
+    ColorTestTable.AddColor(builder, color);
+    return ColorTestTable.EndColorTestTable(builder);
+  }
+
+  public static void StartColorTestTable(FlatBufferBuilder builder) { builder.StartTable(1); }
+  public static void AddColor(FlatBufferBuilder builder, global::NamespaceB.Color color) { builder.AddSbyte(0, (sbyte)color, 2); }
+  public static Offset<global::NamespaceA.NamespaceB.ColorTestTable> EndColorTestTable(FlatBufferBuilder builder) {
+    int o = builder.EndTable();
+    return new Offset<global::NamespaceA.NamespaceB.ColorTestTable>(o);
+  }
+  public ColorTestTableT UnPack() {
+    var _o = new ColorTestTableT();
+    this.UnPackTo(_o);
+    return _o;
+  }
+  public void UnPackTo(ColorTestTableT _o) {
+    _o.Color = this.Color;
+  }
+  public static Offset<global::NamespaceA.NamespaceB.ColorTestTable> Pack(FlatBufferBuilder builder, ColorTestTableT _o) {
+    if (_o == null) return default(Offset<global::NamespaceA.NamespaceB.ColorTestTable>);
+    return CreateColorTestTable(
+      builder,
+      _o.Color);
+  }
+}
+
+public class ColorTestTableT
+{
+  [Newtonsoft.Json.JsonProperty("color")]
+  public global::NamespaceB.Color Color { get; set; }
+
+  public ColorTestTableT() {
+    this.Color = global::NamespaceB.Color.Blue;
+  }
+}
+
+
+}
