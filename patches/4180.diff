commit b7a55ecd54b4d7f7b74a04a7c46065a1d25ea26b
Author: Even Rouault <even.rouault@mines-paris.org>
Date:   Sat Nov 11 17:38:32 2017 +0000

    netCDF: support UTF-8 filenames on Windows (refs https://trac.osgeo.org/gdal/ticket/7065)
    
    git-svn-id: https://svn.osgeo.org/gdal/trunk@40692 f0d54148-0727-0410-94bb-9a71ac55c965

diff --git a/autotest/gdrivers/netcdf.py b/autotest/gdrivers/netcdf.py
index ffe59d8e7d..e2cda9627a 100755
--- a/autotest/gdrivers/netcdf.py
+++ b/autotest/gdrivers/netcdf.py
@@ -3044,22 +3044,32 @@ def netcdf_78():
 def netcdf_79():
 
     if gdaltest.netcdf_drv is None:
         return 'skip'
 
     ds = gdal.Open('data/byte_with_neg_fillvalue_and_unsigned_hint.nc')
     if ds.GetRasterBand(1).GetNoDataValue() != 240:
         gdaltest.post_reason('fail')
         return 'fail'
     data = ds.GetRasterBand(1).ReadRaster()
     data = struct.unpack('B' * 4, data)
     if data != (128, 129, 126, 127):
         gdaltest.post_reason('fail')
         print(data)
         return 'fail'
 
     return 'success'
 
+###############################################################################
+# Test creating and opening with accent
+def netcdf_80():
+
+    if gdaltest.netcdf_drv is None:
+        return 'skip'
+
+    test = gdaltest.GDALTest( 'NETCDF', '../data/byte.tif', 1, 4672 )
+    return test.testCreateCopy(new_filename = 'test\xc3\xa9.nc', check_gt=0, check_srs=0, check_minmax = 0)
+    
 ###############################################################################
 
 ###############################################################################
 # main tests list
@@ -3067,89 +3077,90 @@ def netcdf_79():
 gdaltest_list = [
     netcdf_1,
     netcdf_2,
     netcdf_3,
     netcdf_4,
     netcdf_5,
     netcdf_6,
     netcdf_7,
     netcdf_8,
     netcdf_9,
     netcdf_10,
     netcdf_11,
     netcdf_12,
     netcdf_13,
     netcdf_14,
     netcdf_15,
     netcdf_16,
     netcdf_17,
     netcdf_18,
     netcdf_19,
     netcdf_20,
     netcdf_21,
     netcdf_22,
     netcdf_23,
     netcdf_24,
     netcdf_25,
     netcdf_26,
     netcdf_27,
     netcdf_28,
     netcdf_29,
     netcdf_30,
     netcdf_31,
     netcdf_32,
     netcdf_33,
     netcdf_34,
     netcdf_35,
     netcdf_36,
     netcdf_37,
     netcdf_38,
     netcdf_39,
     netcdf_40,
     netcdf_41,
     netcdf_42,
     netcdf_43,
     netcdf_44,
     netcdf_45,
     netcdf_46,
     netcdf_47,
     netcdf_48,
     netcdf_49,
     netcdf_50,
     netcdf_51,
     netcdf_51_no_gdal_tags,
     netcdf_52,
     netcdf_53,
     netcdf_54,
     netcdf_55,
     netcdf_56,
     netcdf_57,
     netcdf_58,
     netcdf_59,
     netcdf_60,
     netcdf_61,
     netcdf_62,
     netcdf_62_ncdump_check,
     netcdf_62_cf_check,
     netcdf_63,
     netcdf_63_ncdump_check,
     netcdf_64,
     netcdf_65,
     netcdf_66,
     netcdf_66_ncdump_check,
     netcdf_67,
     netcdf_68,
     netcdf_69,
     netcdf_70,
     netcdf_71,
     netcdf_72,
     netcdf_73,
     netcdf_74,
     netcdf_75,
     netcdf_76,
     netcdf_77,
     netcdf_78,
-    netcdf_79
+    netcdf_79,
+    netcdf_80
 ]
 
 ###############################################################################
 #  basic file creation tests
diff --git a/gdal/frmts/netcdf/netcdfdataset.cpp b/gdal/frmts/netcdf/netcdfdataset.cpp
index 735196ca1a..539c61c882 100644
--- a/gdal/frmts/netcdf/netcdfdataset.cpp
+++ b/gdal/frmts/netcdf/netcdfdataset.cpp
@@ -5557,133 +5557,151 @@ bool netCDFDataset::CloneGrp(int nOldGrpId, int nNewGrpId,
 bool netCDFDataset::GrowDim(int nLayerId, int nDimIdToGrow, size_t nNewSize)
 {
     int nCreationMode;
     // Set nCreationMode based on eFormat.
     switch( eFormat )
     {
 #ifdef NETCDF_HAS_NC2
     case NCDF_FORMAT_NC2:
         nCreationMode = NC_CLOBBER | NC_64BIT_OFFSET;
         break;
 #endif
 #ifdef NETCDF_HAS_NC4
     case NCDF_FORMAT_NC4:
         nCreationMode = NC_CLOBBER | NC_NETCDF4;
         break;
     case NCDF_FORMAT_NC4C:
         nCreationMode = NC_CLOBBER | NC_NETCDF4 | NC_CLASSIC_MODEL;
         break;
 #endif
     case NCDF_FORMAT_NC:
     default:
         nCreationMode = NC_CLOBBER;
         break;
     }
 
     int new_cdfid = -1;
     CPLString osTmpFilename(osFilename + ".tmp");
-    int status = nc_create(osTmpFilename, nCreationMode, &new_cdfid);
+    CPLString osFilenameForNCCreate(osTmpFilename);
+#ifdef WIN32
+    if( CPLTestBool(CPLGetConfigOption( "GDAL_FILENAME_IS_UTF8", "YES" ) ) )
+    {
+        char* pszTemp = CPLRecode( osFilenameForNCCreate, CPL_ENC_UTF8, "CP_ACP" );
+        osFilenameForNCCreate = pszTemp;
+        CPLFree(pszTemp);
+    }
+#endif
+    int status = nc_create(osFilenameForNCCreate, nCreationMode, &new_cdfid);
     NCDF_ERR(status)
     if( status != NC_NOERR )
         return false;
 
     if( !CloneGrp(cdfid, new_cdfid,
                   eFormat == NCDF_FORMAT_NC4,
                   nLayerId, nDimIdToGrow, nNewSize) )
     {
         nc_close(new_cdfid);
         return false;
     }
 
 #ifdef NETCDF_HAS_NC4
     int nGroupCount = 0;
     std::vector<CPLString> oListGrpName;
     if( eFormat == NCDF_FORMAT_NC4 &&
         nc_inq_grps(cdfid, &nGroupCount, NULL) == NC_NOERR &&
         nGroupCount > 0 )
     {
         int *panGroupIds =
             static_cast<int *>(CPLMalloc(sizeof(int) * nGroupCount));
         status = nc_inq_grps(cdfid, NULL, panGroupIds);
         NCDF_ERR(status)
         for(int i = 0; i < nGroupCount; i++)
         {
             char szGroupName[NC_MAX_NAME + 1];
             szGroupName[0] = 0;
             nc_inq_grpname(panGroupIds[i], szGroupName);
             int nNewGrpId = -1;
             status = nc_def_grp(new_cdfid, szGroupName, &nNewGrpId);
             NCDF_ERR(status)
             if( status != NC_NOERR )
             {
                 CPLFree(panGroupIds);
                 nc_close(new_cdfid);
                 return false;
             }
             if( !CloneGrp(panGroupIds[i], nNewGrpId,
                           eFormat == NCDF_FORMAT_NC4,
                           nLayerId, nDimIdToGrow, nNewSize) )
             {
                 CPLFree(panGroupIds);
                 nc_close(new_cdfid);
                 return false;
             }
         }
         CPLFree(panGroupIds);
 
         for(int i = 0; i < nLayers; i++)
         {
             char szGroupName[NC_MAX_NAME + 1];
             szGroupName[0] = 0;
             status = nc_inq_grpname(papoLayers[i]->GetCDFID(), szGroupName);
             NCDF_ERR(status)
             oListGrpName.push_back(szGroupName);
         }
     }
 #endif
 
     nc_close(cdfid);
     cdfid = -1;
     nc_close(new_cdfid);
 
     CPLString osOriFilename(osFilename + ".ori");
     if( VSIRename(osFilename, osOriFilename) != 0 ||
         VSIRename(osTmpFilename, osFilename) != 0 )
     {
         CPLError(CE_Failure, CPLE_FileIO, "Renaming of files failed");
         return false;
     }
     VSIUnlink(osOriFilename);
 
+    CPLString osFilenameForNCOpen(osFilename);
+#ifdef WIN32
+    if( CPLTestBool(CPLGetConfigOption( "GDAL_FILENAME_IS_UTF8", "YES" ) ) )
+    {
+        char* pszTemp = CPLRecode( osFilenameForNCOpen, CPL_ENC_UTF8, "CP_ACP" );
+        osFilenameForNCOpen = pszTemp;
+        CPLFree(pszTemp);
+    }
+#endif
     status = nc_open(osFilename, NC_WRITE, &cdfid);
     NCDF_ERR(status);
     if( status != NC_NOERR )
         return false;
     bDefineMode = false;
 
 #ifdef NETCDF_HAS_NC4
     if( !oListGrpName.empty() )
     {
         for(int i = 0; i < nLayers; i++)
         {
             int nNewLayerCDFID = -1;
             status =
                 nc_inq_ncid(cdfid, oListGrpName[i].c_str(), &nNewLayerCDFID);
             NCDF_ERR(status);
             papoLayers[i]->SetCDFID(nNewLayerCDFID);
         }
     }
     else
 #endif
     {
         for(int i = 0; i < nLayers; i++)
         {
             papoLayers[i]->SetCDFID(cdfid);
         }
     }
 
     return true;
 }
 
 /************************************************************************/
 /*                              Identify()                              */
 /************************************************************************/
@@ -6398,1199 +6416,1208 @@ static bool netCDFDatasetCreateTempFile( NetCDFFormatEnum eFormat,
 GDALDataset *netCDFDataset::Open( GDALOpenInfo *poOpenInfo )
 
 {
 #ifdef NCDF_DEBUG
     CPLDebug("GDAL_netCDF", "\n=====\nOpen(), filename=[%s]",
              poOpenInfo->pszFilename);
 #endif
 
     // Does this appear to be a netcdf file?
     NetCDFFormatEnum eTmpFormat = NCDF_FORMAT_NONE;
     if( !STARTS_WITH_CI(poOpenInfo->pszFilename, "NETCDF:") )
     {
         eTmpFormat = IdentifyFormat(poOpenInfo);
 #ifdef NCDF_DEBUG
         CPLDebug("GDAL_netCDF", "identified format %d", eTmpFormat);
 #endif
         // Note: not calling Identify() directly, because we want the file type.
         // Only support NCDF_FORMAT* formats.
         if( !(NCDF_FORMAT_NC == eTmpFormat ||
               NCDF_FORMAT_NC2 == eTmpFormat ||
               NCDF_FORMAT_NC4 == eTmpFormat ||
               NCDF_FORMAT_NC4C == eTmpFormat) )
             return NULL;
     }
     else
     {
 #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
         // We don't necessarily want to catch bugs in libnetcdf ...
         if( CPLGetConfigOption("DISABLE_OPEN_REAL_NETCDF_FILES", NULL) )
         {
             return NULL;
         }
 #endif
     }
 
     CPLMutexHolderD(&hNCMutex);
 
     CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock with
                                 // GDALDataset own mutex.
     netCDFDataset *poDS = new netCDFDataset();
     poDS->papszOpenOptions = CSLDuplicate(poOpenInfo->papszOpenOptions);
     CPLAcquireMutex(hNCMutex, 1000.0);
 
     poDS->SetDescription(poOpenInfo->pszFilename);
 
     // Check if filename start with NETCDF: tag.
     bool bTreatAsSubdataset = false;
     CPLString osSubdatasetName;
 
 #ifdef ENABLE_NCDUMP
     const char* pszHeader =
                 reinterpret_cast<const char*>(poOpenInfo->pabyHeader);
     if( poOpenInfo->fpL != NULL &&
         STARTS_WITH(pszHeader, "netcdf ") &&
         strstr(pszHeader, "dimensions:") &&
         strstr(pszHeader, "variables:") )
     {
         // By default create a temporary file that will be destroyed,
         // unless NETCDF_TMP_FILE is defined. Can be useful to see which
         // netCDF file has been generated from a potential fuzzed input.
         poDS->osFilename = CPLGetConfigOption("NETCDF_TMP_FILE", "");
         if( poDS->osFilename.empty() )
         {
             poDS->bFileToDestroyAtClosing = true;
             poDS->osFilename = CPLGenerateTempFilename("netcdf_tmp");
         }
         if( !netCDFDatasetCreateTempFile( eTmpFormat,
                                           poDS->osFilename,
                                           poOpenInfo->fpL ) )
         {
             CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                         // with GDALDataset own mutex.
             delete poDS;
             CPLAcquireMutex(hNCMutex, 1000.0);
             return NULL;
         }
         bTreatAsSubdataset = false;
         poDS->eFormat = eTmpFormat;
     }
     else
 #endif
 
     if( STARTS_WITH_CI(poOpenInfo->pszFilename, "NETCDF:") )
     {
         char **papszName =
             CSLTokenizeString2(poOpenInfo->pszFilename,
                                ":", CSLT_HONOURSTRINGS|CSLT_PRESERVEESCAPES);
 
         // Check for drive name in windows NETCDF:"D:\...
         if( CSLCount(papszName) == 4 &&
             strlen(papszName[1]) == 1 &&
             (papszName[2][0] == '/' || papszName[2][0] == '\\') )
         {
             poDS->osFilename = papszName[1];
             poDS->osFilename += ':';
             poDS->osFilename += papszName[2];
             osSubdatasetName = papszName[3];
             bTreatAsSubdataset = true;
             CSLDestroy(papszName);
         }
         else if( CSLCount(papszName) == 3 )
         {
             poDS->osFilename = papszName[1];
             osSubdatasetName = papszName[2];
             bTreatAsSubdataset = true;
             CSLDestroy(papszName);
         }
         else if( CSLCount(papszName) == 2 )
         {
             poDS->osFilename = papszName[1];
             osSubdatasetName = "";
             bTreatAsSubdataset = false;
             CSLDestroy(papszName);
         }
         else
         {
             CSLDestroy(papszName);
             CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll
                                         // deadlock with GDALDataset own mutex.
             delete poDS;
             CPLAcquireMutex(hNCMutex, 1000.0);
             CPLError(CE_Failure, CPLE_AppDefined,
                      "Failed to parse NETCDF: prefix string into expected 2, 3 or 4 fields.");
             return NULL;
         }
         // Identify Format from real file, with bCheckExt=FALSE.
         GDALOpenInfo *poOpenInfo2 =
             new GDALOpenInfo(poDS->osFilename.c_str(), GA_ReadOnly);
         poDS->eFormat = IdentifyFormat(poOpenInfo2, FALSE);
         delete poOpenInfo2;
         if( NCDF_FORMAT_NONE == poDS->eFormat ||
             NCDF_FORMAT_UNKNOWN == poDS->eFormat )
         {
             CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll
                                         // deadlock with GDALDataset own mutex.
             delete poDS;
             CPLAcquireMutex(hNCMutex, 1000.0);
             return NULL;
         }
     }
     else
     {
         poDS->osFilename = poOpenInfo->pszFilename;
         bTreatAsSubdataset = false;
         poDS->eFormat = eTmpFormat;
     }
 
     // Try opening the dataset.
 #ifdef NCDF_DEBUG
     CPLDebug("GDAL_netCDF", "calling nc_open(%s)", poDS->osFilename.c_str());
 #endif
     int cdfid;
     const int nMode = ((poOpenInfo->nOpenFlags & (GDAL_OF_UPDATE | GDAL_OF_VECTOR)) ==
                 (GDAL_OF_UPDATE | GDAL_OF_VECTOR)) ? NC_WRITE : NC_NOWRITE;
-    if( nc_open(poDS->osFilename, nMode, &cdfid) != NC_NOERR )
+    CPLString osFilenameForNCOpen(poDS->osFilename);
+#ifdef WIN32
+    if( CPLTestBool(CPLGetConfigOption( "GDAL_FILENAME_IS_UTF8", "YES" ) ) )
+    {
+        char* pszTemp = CPLRecode( osFilenameForNCOpen, CPL_ENC_UTF8, "CP_ACP" );
+        osFilenameForNCOpen = pszTemp;
+        CPLFree(pszTemp);
+    }
+#endif
+    if( nc_open(osFilenameForNCOpen, nMode, &cdfid) != NC_NOERR )
     {
 #ifdef NCDF_DEBUG
         CPLDebug("GDAL_netCDF", "error opening");
 #endif
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         delete poDS;
         CPLAcquireMutex(hNCMutex, 1000.0);
         return NULL;
     }
 #ifdef NCDF_DEBUG
     CPLDebug("GDAL_netCDF", "got cdfid=%d", cdfid);
 #endif
 
 #if defined(ENABLE_NCDUMP) && !defined(WIN32)
     // Try to destroy the temporary file right now on Unix
     if( poDS->bFileToDestroyAtClosing )
     {
         if( VSIUnlink( poDS->osFilename ) == 0 )
         {
             poDS->bFileToDestroyAtClosing = false;
         }
     }
 #endif
 
     // Is this a real netCDF file?
     int ndims;
     int ngatts;
     int nvars;
     int unlimdimid;
     int status = nc_inq(cdfid, &ndims, &nvars, &ngatts, &unlimdimid);
     if( status != NC_NOERR )
     {
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         delete poDS;
         CPLAcquireMutex(hNCMutex, 1000.0);
         return NULL;
     }
 
     // Get file type from netcdf.
     int nTmpFormat = NCDF_FORMAT_NONE;
     status = nc_inq_format(cdfid, &nTmpFormat);
     if( status != NC_NOERR )
     {
         NCDF_ERR(status);
     }
     else
     {
         CPLDebug("GDAL_netCDF",
                  "driver detected file type=%d, libnetcdf detected type=%d",
                  poDS->eFormat, nTmpFormat);
         if( static_cast<NetCDFFormatEnum>(nTmpFormat) != poDS->eFormat )
         {
             // Warn if file detection conflicts with that from libnetcdf
             // except for NC4C, which we have no way of detecting initially.
             if( nTmpFormat != NCDF_FORMAT_NC4C )
             {
                 CPLError(CE_Warning, CPLE_AppDefined,
                          "NetCDF driver detected file type=%d, but libnetcdf detected type=%d",
                          poDS->eFormat, nTmpFormat);
             }
             CPLDebug("GDAL_netCDF", "setting file type to %d, was %d",
                      nTmpFormat, poDS->eFormat);
             poDS->eFormat = static_cast<NetCDFFormatEnum>(nTmpFormat);
         }
     }
 
     // Confirm the requested access is supported.
     if( poOpenInfo->eAccess == GA_Update &&
         (poOpenInfo->nOpenFlags & GDAL_OF_VECTOR) == 0 )
     {
         CPLError(CE_Failure, CPLE_NotSupported,
                  "The NETCDF driver does not support update access to existing"
                  " datasets.");
         nc_close(cdfid);
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         delete poDS;
         CPLAcquireMutex(hNCMutex, 1000.0);
         return NULL;
     }
 
     // Does the request variable exist?
     if( bTreatAsSubdataset )
     {
         int var;
         status = nc_inq_varid(cdfid, osSubdatasetName, &var);
         if( status != NC_NOERR )
         {
             CPLError(CE_Warning, CPLE_AppDefined,
                      "%s is a netCDF file, but %s is not a variable.",
                      poOpenInfo->pszFilename, osSubdatasetName.c_str());
 
             nc_close(cdfid);
             CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll
                                         // deadlock with GDALDataset own mutex.
             delete poDS;
             CPLAcquireMutex(hNCMutex, 1000.0);
             return NULL;
         }
     }
 
     if( ndims < 2 && (poOpenInfo->nOpenFlags & GDAL_OF_VECTOR) == 0 )
     {
         CPLError(CE_Warning, CPLE_AppDefined,
                  "%s is a netCDF file, but without any dimensions >= 2.",
                  poOpenInfo->pszFilename);
 
         nc_close(cdfid);
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         delete poDS;
         CPLAcquireMutex(hNCMutex, 1000.0);
         return NULL;
     }
 
     CPLDebug("GDAL_netCDF", "dim_count = %d", ndims);
 
     char szConventions[NC_MAX_NAME + 1];
     szConventions[0] = '\0';
     nc_type nAttype = NC_NAT;
     size_t nAttlen = 0;
     nc_inq_att(cdfid, NC_GLOBAL, "Conventions", &nAttype, &nAttlen);
     if( nAttlen >= sizeof(szConventions) ||
         (status = nc_get_att_text(cdfid, NC_GLOBAL, "Conventions",
                                   szConventions)) != NC_NOERR )
     {
         CPLError(CE_Warning, CPLE_AppDefined,
                  "No UNIDATA NC_GLOBAL:Conventions attribute");
         // Note that 'Conventions' is always capital 'C' in CF spec.
     }
     else
     {
         szConventions[nAttlen] = '\0';
     }
 
     // Create band information objects.
     CPLDebug("GDAL_netCDF", "var_count = %d", nvars);
 
     // Create a corresponding GDALDataset.
     // Create Netcdf Subdataset if filename as NETCDF tag.
     poDS->cdfid = cdfid;
     poDS->eAccess = poOpenInfo->eAccess;
     poDS->bDefineMode = false;
 
     poDS->ReadAttributes(cdfid, NC_GLOBAL);
 
     int nCount = 0;
     int nVarID = -1;
     int nIgnoredVars = 0;
     char *pszTemp = NULL;
 
     // In vector only mode, if the file is NC4, if the main group has no
     // variables but there are sub-groups, then iterate over the subgroups to
     // check if there are vector layers.
 #ifdef NETCDF_HAS_NC4
     int nGroupCount = 0;
     int *panGroupIds = NULL;
     if( nvars == 0 &&
         poDS->eFormat == NCDF_FORMAT_NC4 &&
         (poOpenInfo->nOpenFlags & GDAL_OF_RASTER) == 0 &&
         (poOpenInfo->nOpenFlags & GDAL_OF_VECTOR) != 0 )
     {
         nc_inq_grps(cdfid, &nGroupCount, NULL);
     }
     if( nGroupCount > 0 )
     {
         panGroupIds = static_cast<int *>(CPLMalloc(sizeof(int) * nGroupCount));
         nc_inq_grps(cdfid, NULL, panGroupIds);
     }
     for( int iGrp = 0; iGrp < ((nGroupCount) ? nGroupCount : 1); iGrp ++ )
     {
         char szGroupName[NC_MAX_NAME + 1];
         szGroupName[0] = 0;
         int iGrpId = (nGroupCount) ? panGroupIds[iGrp] : cdfid;
         if( nGroupCount )
         {
             nc_inq_grpname(iGrpId, szGroupName);
             ndims = 0;
             ngatts = 0;
             nvars = 0;
             unlimdimid = -1;
             status = nc_inq(iGrpId, &ndims, &nvars, &ngatts, &unlimdimid);
             NCDF_ERR(status);
 
             CSLDestroy(poDS->papszMetadata);
             poDS->papszMetadata = NULL;
             poDS->ReadAttributes(cdfid, NC_GLOBAL);
             poDS->ReadAttributes(iGrpId, NC_GLOBAL);
         }
         else
         {
             snprintf(szGroupName, sizeof(szGroupName), "%s",
                      CPLGetBasename(poDS->osFilename));
         }
         poDS->cdfid = iGrpId;
 #else
     char szGroupName[NC_MAX_NAME + 1];
     snprintf(szGroupName, sizeof(szGroupName),
              "%s", CPLGetBasename(poDS->osFilename));
 #endif
 
     // Identify variables that we should ignore as Raster Bands.
     // Variables that are identified in other variable's "coordinate" and
     // "bounds" attribute should not be treated as Raster Bands.
     // See CF sections 5.2, 5.6 and 7.1.
     char **papszIgnoreVars = NULL;
 
         for( int j = 0; j < nvars; j++ )
         {
             if( NCDFGetAttr(poDS->cdfid, j, "coordinates", &pszTemp) == CE_None )
             {
                 char **papszTokens = CSLTokenizeString2(pszTemp, " ", 0);
                 for( int i = 0; i<CSLCount(papszTokens); i++ )
                 {
                     papszIgnoreVars =
                         CSLAddString(papszIgnoreVars, papszTokens[i]);
                 }
                 if( papszTokens ) CSLDestroy(papszTokens);
                 CPLFree(pszTemp);
              }
             if( NCDFGetAttr(poDS->cdfid, j, "bounds", &pszTemp) == CE_None &&
                 pszTemp != NULL )
             {
                 if( !EQUAL(pszTemp, "") )
                     papszIgnoreVars = CSLAddString(papszIgnoreVars, pszTemp);
                 CPLFree(pszTemp);
             }
         }
 
         // Filter variables (valid 2D raster bands and vector fields).
         nIgnoredVars = 0;
         std::vector<int> anPotentialVectorVarID;
         // oMapDimIdToCount[x] = number of times dim x is the first dimension of
         // potential vector variables
         std::map<int, int> oMapDimIdToCount;
         int nVarXId = -1;
         int nVarYId = -1;
         int nVarZId = -1;
         bool bIsVectorOnly = true;
         int nProfileDimId = -1;
         int nParentIndexVarID = -1;
 
         for( int j = 0; j < nvars; j++ )
         {
             int ndimsForVar = -1;
             char szTemp[NC_MAX_NAME + 1];
             nc_inq_varndims(poDS->cdfid, j, &ndimsForVar);
             // Should we ignore this variable?
             szTemp[0] = '\0';
             status = nc_inq_varname(poDS->cdfid, j, szTemp);
             if( status != NC_NOERR )
                 continue;
 
             nc_type atttype = NC_NAT;
             size_t attlen = 0;
 
             if( ndimsForVar == 1 &&
                 (NCDFIsVarLongitude(poDS->cdfid, -1, szTemp) ||
                 NCDFIsVarProjectionX(poDS->cdfid, -1, szTemp)) )
             {
                 nVarXId = j;
             }
             else if( ndimsForVar == 1 &&
                      (NCDFIsVarLatitude(poDS->cdfid, -1, szTemp) ||
                       NCDFIsVarProjectionY(poDS->cdfid, -1, szTemp)) )
             {
                 nVarYId = j;
             }
             else if( ndimsForVar == 1 &&
                      NCDFIsVarVerticalCoord(poDS->cdfid, -1, szTemp) )
             {
                 nVarZId = j;
             }
             else if( CSLFindString(papszIgnoreVars, szTemp) != -1 )
             {
                 nIgnoredVars++;
                 CPLDebug("GDAL_netCDF", "variable #%d [%s] was ignored", j,
                          szTemp);
             }
             // Only accept 2+D vars.
             else if( ndimsForVar >= 2 )
             {
 
                 // Identify variables that might be vector variables
                 if( ndimsForVar == 2 )
                 {
                     int anDimIds[2] = { -1, -1 };
                     nc_inq_vardimid(poDS->cdfid, j, anDimIds);
 
                     nc_type vartype = NC_NAT;
                     nc_inq_vartype(poDS->cdfid, j, &vartype);
 
                     char szDimNameX[NC_MAX_NAME + 1];
                     char szDimNameY[NC_MAX_NAME + 1];
                     szDimNameX[0] = '\0';
                     szDimNameY[0] = '\0';
                     if( vartype == NC_CHAR &&
                         nc_inq_dimname(poDS->cdfid, anDimIds[0], szDimNameY) ==
                            NC_NOERR &&
                        nc_inq_dimname(poDS->cdfid, anDimIds[1], szDimNameX) ==
                            NC_NOERR &&
                        NCDFIsVarLongitude(poDS->cdfid, -1, szDimNameX) ==
                            false &&
                        NCDFIsVarProjectionX(poDS->cdfid, -1, szDimNameX) ==
                            false &&
                        NCDFIsVarLatitude(poDS->cdfid, -1, szDimNameY) ==
                            false &&
                        NCDFIsVarProjectionY(poDS->cdfid, -1, szDimNameY) ==
                            false )
                     {
                         anPotentialVectorVarID.push_back(j);
                         oMapDimIdToCount[anDimIds[0]]++;
                     }
                     else
                     {
                         bIsVectorOnly = false;
                     }
                 }
                 else
                 {
                     bIsVectorOnly = false;
                 }
                 if( (poOpenInfo->nOpenFlags & GDAL_OF_RASTER) != 0 )
                 {
                     nVarID = j;
                     nCount++;
                 }
             }
             else if( ndimsForVar == 1 )
             {
                 if( nc_inq_att(poDS->cdfid, j, "instance_dimension", &atttype,
                                &attlen) == NC_NOERR &&
                     atttype == NC_CHAR && attlen < NC_MAX_NAME )
                 {
                     char szInstanceDimension[NC_MAX_NAME + 1];
                     if( nc_get_att_text(poDS->cdfid, j, "instance_dimension",
                                         szInstanceDimension) == NC_NOERR )
                     {
                         szInstanceDimension[attlen] = 0;
                         for(int idim = 0; idim < ndims; idim++)
                         {
                             char szDimName[NC_MAX_NAME + 1];
                             szDimName[0] = 0;
                             status =
                                 nc_inq_dimname(poDS->cdfid, idim, szDimName);
                             NCDF_ERR(status);
                         if( strcmp(szInstanceDimension, szDimName) == 0 )
                             {
                                 nParentIndexVarID = j;
                                 nProfileDimId = idim;
                                 break;
                             }
                         }
                         if( nProfileDimId < 0 )
                         {
                             CPLError(CE_Warning, CPLE_AppDefined,
                                      "Attribute instance_dimension='%s' refers "
                                      "to a non existing dimension",
                                      szInstanceDimension);
                         }
                     }
                 }
                 if( j != nParentIndexVarID )
                 {
                     anPotentialVectorVarID.push_back(j);
                     int nDimId = -1;
                     nc_inq_vardimid(poDS->cdfid, j, &nDimId);
                     oMapDimIdToCount[nDimId]++;
                 }
             }
         }
 
         CSLDestroy(papszIgnoreVars);
 
         CPLString osFeatureType(CSLFetchNameValueDef(
             poDS->papszMetadata, "NC_GLOBAL#featureType", ""));
 
         // If we are opened in raster-only mode and that there are only 1D or 2D
         // variables and that the 2D variables have no X/Y dim, and all
         // variables refer to the same main dimension (or 2 dimensions for
         // featureType=profile), then it is a pure vector dataset
         if( (poOpenInfo->nOpenFlags & GDAL_OF_RASTER) != 0 &&
             (poOpenInfo->nOpenFlags & GDAL_OF_VECTOR) == 0 &&
             bIsVectorOnly && nCount > 0 &&
             !anPotentialVectorVarID.empty() &&
             (oMapDimIdToCount.size() == 1 ||
              (EQUAL(osFeatureType, "profile") && oMapDimIdToCount.size() == 2 &&
               nProfileDimId >= 0)) )
         {
             anPotentialVectorVarID.resize(0);
             nCount = 0;
         }
 
         if( !anPotentialVectorVarID.empty() &&
             (poOpenInfo->nOpenFlags & GDAL_OF_VECTOR) != 0 )
         {
             // Take the dimension that is referenced the most times
             if( !(oMapDimIdToCount.size() == 1 ||
               (EQUAL(osFeatureType, "profile") && oMapDimIdToCount.size() == 2 && nProfileDimId >= 0)) )
             {
                 CPLError(CE_Warning, CPLE_AppDefined,
                          "The dataset has several variables that could be identified "
                          "as vector fields, but not all share the same primary dimension. "
                          "Consequently they will be ignored.");
             }
             else
             {
                 OGRwkbGeometryType eGType = wkbUnknown;
                 CPLString osLayerName = CSLFetchNameValueDef(
                 poDS->papszMetadata, "NC_GLOBAL#ogr_layer_name", szGroupName);
                 poDS->papszMetadata = CSLSetNameValue(
                     poDS->papszMetadata, "NC_GLOBAL#ogr_layer_name", NULL);
 
                 if( EQUAL(osFeatureType, "point") ||
                     EQUAL(osFeatureType, "profile") )
                 {
                     poDS->papszMetadata = CSLSetNameValue(
                         poDS->papszMetadata, "NC_GLOBAL#featureType", NULL);
                     eGType = wkbPoint;
                 }
 
                 const char *pszLayerType = CSLFetchNameValue(
                     poDS->papszMetadata, "NC_GLOBAL#ogr_layer_type");
                 if( pszLayerType != NULL )
                 {
                     eGType = OGRFromOGCGeomType(pszLayerType);
                     poDS->papszMetadata = CSLSetNameValue(
                         poDS->papszMetadata, "NC_GLOBAL#ogr_layer_type", NULL);
                 }
 
                 CPLString osGeometryField = CSLFetchNameValueDef(
                     poDS->papszMetadata, "NC_GLOBAL#ogr_geometry_field", "");
                 poDS->papszMetadata = CSLSetNameValue(
                     poDS->papszMetadata, "NC_GLOBAL#ogr_geometry_field", NULL);
 
                 int nFirstVarId = -1;
                 int nVectorDim = oMapDimIdToCount.rbegin()->first;
                 if( EQUAL(osFeatureType, "profile") &&
                     oMapDimIdToCount.size() == 2 )
                 {
                     if( nVectorDim == nProfileDimId )
                         nVectorDim = oMapDimIdToCount.begin()->first;
                 }
                 else
                 {
                     nProfileDimId = -1;
                 }
                 for( size_t j = 0; j < anPotentialVectorVarID.size(); j++ )
                 {
                     int anDimIds[2] = { -1, -1 };
                     nc_inq_vardimid(poDS->cdfid, anPotentialVectorVarID[j],
                                     anDimIds);
                     if( nVectorDim == anDimIds[0] )
                     {
                         nFirstVarId = anPotentialVectorVarID[j];
                         break;
                     }
                 }
 
                 // In case where coordinates are explicitly specified for one of
                 // the field/variable,
                 // use them in priority over the ones that might have been
                 // identified above.
                 char *pszCoordinates = NULL;
                 if( NCDFGetAttr(poDS->cdfid, nFirstVarId, "coordinates",
                                 &pszCoordinates) == CE_None )
                 {
                     char **papszTokens =
                         CSLTokenizeString2(pszCoordinates, " ", 0);
                     for(int i = 0;
                         papszTokens != NULL && papszTokens[i] != NULL; i++)
                     {
                         if( NCDFIsVarLongitude(poDS->cdfid, -1,
                                                papszTokens[i]) ||
                             NCDFIsVarProjectionX(poDS->cdfid, -1,
                                                  papszTokens[i]) )
                         {
                             nVarXId = -1;
                             CPL_IGNORE_RET_VAL(nc_inq_varid(
                                 poDS->cdfid, papszTokens[i], &nVarXId));
                         }
                         else if( NCDFIsVarLatitude(poDS->cdfid, -1,
                                                    papszTokens[i]) ||
                                  NCDFIsVarProjectionY(poDS->cdfid, -1,
                                                       papszTokens[i]) )
                         {
                             nVarYId = -1;
                             CPL_IGNORE_RET_VAL(nc_inq_varid(
                                 poDS->cdfid, papszTokens[i], &nVarYId));
                         }
                         else if( NCDFIsVarVerticalCoord(poDS->cdfid, -1,
                                                        papszTokens[i]))
                         {
                             nVarZId = -1;
                             CPL_IGNORE_RET_VAL(nc_inq_varid(
                                 poDS->cdfid, papszTokens[i], &nVarZId));
                         }
                     }
                     CSLDestroy(papszTokens);
                 }
                 CPLFree(pszCoordinates);
 
                 // Check that the X,Y,Z vars share 1D and share the same
                 // dimension as attribute variables.
                 if( nVarXId >= 0 && nVarYId >= 0 )
                 {
                     int nVarDimCount = -1;
                     int nVarDimId = -1;
                     if( nc_inq_varndims(poDS->cdfid, nVarXId, &nVarDimCount) != NC_NOERR ||
                         nVarDimCount != 1 ||
                         nc_inq_vardimid(poDS->cdfid, nVarXId, &nVarDimId) != NC_NOERR ||
                         nVarDimId != ((nProfileDimId >= 0) ? nProfileDimId : nVectorDim) ||
                         nc_inq_varndims(poDS->cdfid, nVarYId, &nVarDimCount) != NC_NOERR ||
                         nVarDimCount != 1 ||
                     nc_inq_vardimid(poDS->cdfid, nVarYId, &nVarDimId) != NC_NOERR ||
                     nVarDimId != ((nProfileDimId >= 0) ? nProfileDimId : nVectorDim) )
                     {
                         nVarXId = nVarYId = -1;
                     }
                     else if( nVarZId >= 0 &&
                              (nc_inq_varndims(poDS->cdfid, nVarZId,
                                               &nVarDimCount) != NC_NOERR ||
                               nVarDimCount != 1 ||
                               nc_inq_vardimid(poDS->cdfid, nVarZId,
                                               &nVarDimId) != NC_NOERR ||
                               nVarDimId != nVectorDim) )
                     {
                         nVarZId = -1;
                     }
                 }
 
                 if( eGType == wkbUnknown && nVarXId >= 0 && nVarYId >= 0 )
                 {
                     eGType = wkbPoint;
                 }
                 if( eGType == wkbPoint && nVarXId >= 0 && nVarYId >= 0 &&
                     nVarZId >= 0 )
                 {
                     eGType = wkbPoint25D;
                 }
                 if( eGType == wkbUnknown && osGeometryField.empty() )
                 {
                     eGType = wkbNone;
                 }
 
                 // Read projection info
                 char **papszMetadataBackup = CSLDuplicate(poDS->papszMetadata);
                 poDS->ReadAttributes(poDS->cdfid, nFirstVarId);
                 poDS->SetProjectionFromVar(nFirstVarId, true);
 
                 char szVarName[NC_MAX_NAME + 1];
                 szVarName[0] = '\0';
                 CPL_IGNORE_RET_VAL(
                     nc_inq_varname(poDS->cdfid, nFirstVarId, szVarName));
                 char szTemp[NC_MAX_NAME + 1];
                 snprintf(szTemp, sizeof(szTemp),
                          "%s#%s", szVarName, CF_GRD_MAPPING);
                 CPLString osGridMapping =
                     CSLFetchNameValueDef(poDS->papszMetadata, szTemp, "");
 
                 CSLDestroy(poDS->papszMetadata);
                 poDS->papszMetadata = papszMetadataBackup;
 
                 OGRSpatialReference *poSRS = NULL;
                 if( poDS->pszProjection != NULL )
                 {
                     poSRS = new OGRSpatialReference();
                     char *pszWKT = poDS->pszProjection;
                     if( poSRS->importFromWkt(&pszWKT) != OGRERR_NONE )
                     {
                         delete poSRS;
                         poSRS = NULL;
                     }
                     CPLFree(poDS->pszProjection);
                     poDS->pszProjection = NULL;
                 }
                 // Reset if there's a 2D raster
                 poDS->bSetProjection = false;
                 poDS->bSetGeoTransform = false;
 
                 if( (poOpenInfo->nOpenFlags & GDAL_OF_RASTER) == 0 )
                 {
                     // Strip out uninteresting metadata.
                     poDS->papszMetadata = CSLSetNameValue(
                         poDS->papszMetadata, "NC_GLOBAL#Conventions", NULL);
                     poDS->papszMetadata = CSLSetNameValue(
                         poDS->papszMetadata, "NC_GLOBAL#GDAL", NULL);
                     poDS->papszMetadata = CSLSetNameValue(
                         poDS->papszMetadata, "NC_GLOBAL#history", NULL);
                 }
 
                 netCDFLayer *poLayer = new netCDFLayer(
                     poDS, poDS->cdfid, osLayerName, eGType, poSRS);
                 if( poSRS != NULL )
                     poSRS->Release();
                 poLayer->SetRecordDimID(nVectorDim);
                 if( wkbFlatten(eGType) == wkbPoint && nVarXId >= 0 &&
                     nVarYId >= 0 )
                 {
                     poLayer->SetXYZVars(nVarXId, nVarYId, nVarZId);
                 }
                 else if( !osGeometryField.empty() )
                 {
                     poLayer->SetWKTGeometryField(osGeometryField);
                 }
                 if( !osGridMapping.empty() )
                 {
                     poLayer->SetGridMapping(osGridMapping);
                 }
                 poLayer->SetProfile(nProfileDimId, nParentIndexVarID);
 
                 for( size_t j = 0; j < anPotentialVectorVarID.size(); j++ )
                 {
                     int anDimIds[2] = { -1, -1 };
                     nc_inq_vardimid(poDS->cdfid, anPotentialVectorVarID[j],
                                     anDimIds);
                     if( anDimIds[0] == nVectorDim ||
                         (nProfileDimId >= 0 && anDimIds[0] == nProfileDimId) )
                     {
 #ifdef NCDF_DEBUG
                         char szTemp2[NC_MAX_NAME + 1] = {};
                         CPL_IGNORE_RET_VAL(nc_inq_varname(
                             poDS->cdfid, anPotentialVectorVarID[j], szTemp2));
                         CPLDebug("GDAL_netCDF", "Variable %s is a vector field",
                                  szTemp2);
 #endif
                         poLayer->AddField(anPotentialVectorVarID[j]);
                     }
                 }
 
                 if( poLayer->GetLayerDefn()->GetFieldCount() != 0 ||
                     poLayer->GetGeomType() != wkbNone )
                 {
                     poDS->papoLayers = static_cast<netCDFLayer **>(
                         CPLRealloc(poDS->papoLayers,
                                 (poDS->nLayers + 1) * sizeof(netCDFLayer *)));
                     poDS->papoLayers[poDS->nLayers++] = poLayer;
                 }
                 else
                 {
                     delete poLayer;
                 }
 
             }
         }
 
 #ifdef NETCDF_HAS_NC4
     }  // End for group.
     CPLFree(panGroupIds);
     poDS->cdfid = cdfid;
 #endif
 
     // Case where there is no raster variable
     if( nCount == 0 && !bTreatAsSubdataset )
     {
         poDS->SetMetadata(poDS->papszMetadata);
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         poDS->TryLoadXML();
         // If the dataset has been opened in raster mode only, exit
         if( (poOpenInfo->nOpenFlags & GDAL_OF_RASTER) != 0 &&
             (poOpenInfo->nOpenFlags & GDAL_OF_VECTOR) == 0 )
         {
             delete poDS;
             poDS = NULL;
         }
         // Otherwise if the dataset is opened in vector mode, that there is
         // no vector layer and we are in read-only, exit too.
         else if( poDS->nLayers == 0 &&
                  (poOpenInfo->nOpenFlags & GDAL_OF_VECTOR) != 0 &&
                  poOpenInfo->eAccess == GA_ReadOnly )
         {
             delete poDS;
             poDS = NULL;
         }
         CPLAcquireMutex(hNCMutex, 1000.0);
         return poDS;
     }
 
     // We have more than one variable with 2 dimensions in the
     // file, then treat this as a subdataset container dataset.
     if( (nCount > 1) && !bTreatAsSubdataset )
     {
         poDS->CreateSubDatasetList();
         poDS->SetMetadata(poDS->papszMetadata);
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         poDS->TryLoadXML();
         CPLAcquireMutex(hNCMutex, 1000.0);
         return poDS;
     }
 
     // If we are not treating things as a subdataset, then capture
     // the name of the single available variable as the subdataset.
     if( !bTreatAsSubdataset )
     {
         char szVarName[NC_MAX_NAME + 1];
         szVarName[0] = '\0';
         status = nc_inq_varname(cdfid, nVarID, szVarName);
         NCDF_ERR(status);
         osSubdatasetName = szVarName;
     }
 
     // We have ignored at least one variable, so we should report them
     // as subdatasets for reference.
     if( nIgnoredVars > 0 && !bTreatAsSubdataset )
     {
         CPLDebug("GDAL_netCDF",
                  "As %d variables were ignored, creating subdataset list "
                  "for reference. Variable #%d [%s] is the main variable",
                  nIgnoredVars, nVarID, osSubdatasetName.c_str());
         poDS->CreateSubDatasetList();
     }
 
     // Open the NETCDF subdataset NETCDF:"filename":subdataset.
     int var = -1;
     nc_inq_varid(cdfid, osSubdatasetName, &var);
     int nd = 0;
     nc_inq_varndims(cdfid, var, &nd);
 
     int *paDimIds = static_cast<int *>(CPLCalloc(nd, sizeof(int)));
 
     // X, Y, Z position in array
     int *panBandDimPos = static_cast<int *>(CPLCalloc(nd, sizeof(int)));
 
     nc_inq_vardimid(cdfid, var, paDimIds);
 
     // Check if somebody tried to pass a variable with less than 2D.
     if( nd < 2 )
     {
         CPLError(CE_Warning, CPLE_AppDefined,
                  "Variable has %d dimension(s) - not supported.", nd);
         CPLFree(paDimIds);
         CPLFree(panBandDimPos);
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         delete poDS;
         CPLAcquireMutex(hNCMutex, 1000.0);
         return NULL;
     }
 
     // CF-1 Convention
     //
     // Dimensions to appear in the relative order T, then Z, then Y,
     // then X  to the file. All other dimensions should, whenever
     // possible, be placed to the left of the spatiotemporal
     // dimensions.
 
     // Verify that dimensions are in the {T,Z,Y,X} or {T,Z,Y,X} order
     // Ideally we should detect for other ordering and act accordingly
     // Only done if file has Conventions=CF-* and only prints warning
     // To disable set GDAL_NETCDF_VERIFY_DIMS=NO and to use only
     // attributes (not varnames) set GDAL_NETCDF_VERIFY_DIMS=STRICT
     const bool bCheckDims =
         CPLTestBool(CPLGetConfigOption("GDAL_NETCDF_VERIFY_DIMS", "YES")) &&
         STARTS_WITH_CI(szConventions, "CF");
 
     if( bCheckDims )
     {
         char szDimName1[NC_MAX_NAME + 1] = {};
         char szDimName2[NC_MAX_NAME + 1] = {};
         status = nc_inq_dimname(cdfid, paDimIds[nd - 1], szDimName1);
         NCDF_ERR(status);
         status = nc_inq_dimname(cdfid, paDimIds[nd - 2], szDimName2);
         NCDF_ERR(status);
         if( NCDFIsVarLongitude(cdfid, -1, szDimName1) == false &&
             NCDFIsVarProjectionX(cdfid, -1, szDimName1) == false )
         {
             CPLError(CE_Warning, CPLE_AppDefined,
                      "dimension #%d (%s) is not a Longitude/X dimension.",
                      nd - 1, szDimName1);
         }
         if( NCDFIsVarLatitude(cdfid, -1, szDimName2) == false &&
             NCDFIsVarProjectionY(cdfid, -1, szDimName2) == false )
         {
             CPLError(CE_Warning, CPLE_AppDefined,
                      "dimension #%d (%s) is not a Latitude/Y dimension.",
                      nd - 2, szDimName2);
         }
         if( nd >= 3 )
         {
             char szDimName3[NC_MAX_NAME + 1] = {};
             status = nc_inq_dimname(cdfid, paDimIds[nd - 3], szDimName3);
             NCDF_ERR(status);
             if( nd >= 4 )
             {
                 char szDimName4[NC_MAX_NAME + 1] = {};
                 status = nc_inq_dimname(cdfid, paDimIds[nd - 4], szDimName4);
                 NCDF_ERR(status);
                 if( NCDFIsVarVerticalCoord( cdfid, -1, szDimName3) == false )
                 {
                     CPLError(CE_Warning, CPLE_AppDefined,
                              "dimension #%d (%s) is not a Time dimension.",
                              nd - 3, szDimName3);
                 }
                 if( NCDFIsVarTimeCoord(cdfid, -1, szDimName4) == false )
                 {
                     CPLError(CE_Warning, CPLE_AppDefined,
                              "dimension #%d (%s) is not a Time dimension.",
                              nd - 4, szDimName4);
                 }
             }
             else
             {
                 if( NCDFIsVarVerticalCoord(cdfid, -1, szDimName3) == false &&
                     NCDFIsVarTimeCoord(cdfid, -1, szDimName3) == false )
                 {
                     CPLError(CE_Warning, CPLE_AppDefined,
                              "dimension #%d (%s) is not a "
                              "Time or Vertical dimension.",
                              nd - 3, szDimName3);
                 }
             }
         }
     }
 
     // Get X dimensions information.
     size_t xdim;
     poDS->nXDimID = paDimIds[nd - 1];
     nc_inq_dimlen(cdfid, poDS->nXDimID, &xdim);
 
     // Get Y dimension information.
     size_t ydim;
     poDS->nYDimID = paDimIds[nd - 2];
     nc_inq_dimlen(cdfid, poDS->nYDimID, &ydim);
 
     if( xdim > INT_MAX || ydim > INT_MAX )
     {
         CPLError(CE_Failure, CPLE_AppDefined,
                  "Invalid raster dimensions: " CPL_FRMT_GUIB "x" CPL_FRMT_GUIB,
                  static_cast<GUIntBig>(xdim),
                  static_cast<GUIntBig>(ydim));
         CPLFree(paDimIds);
         CPLFree(panBandDimPos);
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         delete poDS;
         CPLAcquireMutex(hNCMutex, 1000.0);
         return NULL;
     }
 
     poDS->nRasterXSize = static_cast<int>(xdim);
     poDS->nRasterYSize = static_cast<int>(ydim);
 
     unsigned int k = 0;
     for( int j = 0; j < nd; j++ )
     {
         if( paDimIds[j] == poDS->nXDimID )
         {
             panBandDimPos[0] = j;  // Save Position of XDim
             k++;
         }
         if( paDimIds[j] == poDS->nYDimID )
         {
             panBandDimPos[1] = j;  // Save Position of YDim
             k++;
         }
     }
     // X and Y Dimension Ids were not found!
     if( k != 2 )
     {
         CPLFree(paDimIds);
         CPLFree(panBandDimPos);
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         delete poDS;
         CPLAcquireMutex(hNCMutex, 1000.0);
         return NULL;
     }
 
     // Read Metadata for this variable.
 
     // Should disable as is also done at band level, except driver needs the
     // variables as metadata (e.g. projection).
     poDS->ReadAttributes(cdfid, var);
 
     // Read Metadata for each dimension.
     for( int j = 0; j < ndims; j++ )
     {
         char szTemp[NC_MAX_NAME + 1];
         status = nc_inq_dimname(cdfid, j, szTemp);
         NCDF_ERR(status);
         poDS->papszDimName.AddString(szTemp);
         int nDimID;
         status = nc_inq_varid(cdfid, poDS->papszDimName[j], &nDimID);
         if( status == NC_NOERR )
         {
             poDS->ReadAttributes(cdfid, nDimID);
         }
     }
 
     // Set projection info.
     poDS->SetProjectionFromVar(var, false);
 
     // Override bottom-up with GDAL_NETCDF_BOTTOMUP config option.
     const char *pszValue = CPLGetConfigOption("GDAL_NETCDF_BOTTOMUP", NULL);
     if( pszValue )
     {
         poDS->bBottomUp = CPLTestBool(pszValue);
         CPLDebug("GDAL_netCDF",
                  "set bBottomUp=%d because GDAL_NETCDF_BOTTOMUP=%s",
                  static_cast<int>(poDS->bBottomUp), pszValue);
     }
 
     // Save non-spatial dimension info.
 
     int *panBandZLev = NULL;
     int nDim = 2;
     size_t lev_count;
     size_t nTotLevCount = 1;
     nc_type nType = NC_NAT;
 
     CPLString osExtraDimNames;
 
     if( nd > 2 )
     {
         nDim = 2;
         panBandZLev = static_cast<int *>(CPLCalloc(nd - 2, sizeof(int)));
 
         osExtraDimNames = "{";
 
         char szDimName[NC_MAX_NAME + 1] = {};
 
         for( int j = 0; j < nd; j++ )
         {
             if( (paDimIds[j] != poDS->nXDimID) &&
                 (paDimIds[j] != poDS->nYDimID) )
             {
                 nc_inq_dimlen(cdfid, paDimIds[j], &lev_count);
                 nTotLevCount *= lev_count;
                 panBandZLev[nDim - 2] = static_cast<int>(lev_count);
                 panBandDimPos[nDim++] = j;  // Save Position of ZDim
                 // Save non-spatial dimension names.
                 if( nc_inq_dimname(cdfid, paDimIds[j], szDimName)
                     == NC_NOERR )
                 {
                     osExtraDimNames += szDimName;
                     if( j < nd-3 )
                     {
                         osExtraDimNames += ",";
                     }
                     nc_inq_varid(cdfid, szDimName, &nVarID);
                     nc_inq_vartype(cdfid, nVarID, &nType);
                     char szExtraDimDef[NC_MAX_NAME + 1];
                     snprintf(szExtraDimDef, sizeof(szExtraDimDef), "{%ld,%d}",
                              (long)lev_count, nType);
                     char szTemp[NC_MAX_NAME + 32 + 1];
                     snprintf(szTemp, sizeof(szTemp), "NETCDF_DIM_%s_DEF",
                              szDimName);
                     poDS->papszMetadata = CSLSetNameValue(
                         poDS->papszMetadata, szTemp, szExtraDimDef);
                     if( NCDFGet1DVar(cdfid, nVarID, &pszTemp) == CE_None )
                     {
                         snprintf(szTemp, sizeof(szTemp), "NETCDF_DIM_%s_VALUES",
                                  szDimName);
                         poDS->papszMetadata = CSLSetNameValue(
                             poDS->papszMetadata, szTemp, pszTemp);
                         CPLFree(pszTemp);
                     }
                 }
             }
         }
         osExtraDimNames += "}";
         poDS->papszMetadata = CSLSetNameValue(
             poDS->papszMetadata, "NETCDF_DIM_EXTRA", osExtraDimNames);
     }
 
     // Store Metadata.
     poDS->SetMetadata(poDS->papszMetadata);
 
     // Create bands.
 
     // Arbitrary threshold.
     int nMaxBandCount =
         atoi(CPLGetConfigOption("GDAL_MAX_BAND_COUNT", "32768"));
     if( nMaxBandCount <= 0 )
         nMaxBandCount = 32768;
     if( nTotLevCount > static_cast<unsigned int>(nMaxBandCount) )
     {
         CPLError(CE_Warning, CPLE_AppDefined,
                  "Limiting number of bands to %d instead of %u",
                  nMaxBandCount,
                  static_cast<unsigned int>(nTotLevCount));
         nTotLevCount = static_cast<unsigned int>(nMaxBandCount);
     }
     if( poDS->nRasterXSize == 0 || poDS->nRasterYSize == 0 )
     {
         poDS->nRasterXSize = 0;
         poDS->nRasterYSize = 0;
         nTotLevCount = 0;
         if( poDS->nLayers == 0 )
         {
             CPLFree(paDimIds);
             CPLFree(panBandDimPos);
             CPLFree(panBandZLev);
             CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                         // with GDALDataset own mutex.
             delete poDS;
             CPLAcquireMutex(hNCMutex, 1000.0);
             return NULL;
         }
     }
     for( unsigned int lev = 0; lev < nTotLevCount ; lev++ )
     {
         netCDFRasterBand *poBand =
             new netCDFRasterBand(poDS, var, nDim, lev, panBandZLev,
                                  panBandDimPos, paDimIds, lev + 1);
         poDS->SetBand(lev + 1, poBand);
     }
 
     CPLFree(paDimIds);
     CPLFree(panBandDimPos);
     if( panBandZLev )
         CPLFree(panBandZLev);
     // Handle angular geographic coordinates here
 
     // Initialize any PAM information.
     if( bTreatAsSubdataset )
     {
         poDS->SetPhysicalFilename(poDS->osFilename);
         poDS->SetSubdatasetName(osSubdatasetName);
     }
 
     CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock with
                                 // GDALDataset own mutex.
     poDS->TryLoadXML();
 
     if( bTreatAsSubdataset )
         poDS->oOvManager.Initialize(poDS, ":::VIRTUAL:::");
     else
         poDS->oOvManager.Initialize(poDS, poDS->osFilename);
 
     CPLAcquireMutex(hNCMutex, 1000.0);
 
     return poDS;
 }
 
 /************************************************************************/
 /*                            CopyMetadata()                            */
 /*                                                                      */
 /*      Create a copy of metadata for NC_GLOBAL or a variable           */
 /************************************************************************/
@@ -7746,107 +7773,116 @@ netCDFDataset *
 netCDFDataset::CreateLL( const char *pszFilename,
                          int nXSize, int nYSize, int nBands,
                          char **papszOptions )
 {
     if( !((nXSize == 0 && nYSize == 0 && nBands == 0) ||
           (nXSize > 0 && nYSize > 0 && nBands > 0)) )
     {
         return NULL;
     }
 
     CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock with
                                 // GDALDataset own mutex.
     netCDFDataset *poDS = new netCDFDataset();
     CPLAcquireMutex(hNCMutex, 1000.0);
 
     poDS->nRasterXSize = nXSize;
     poDS->nRasterYSize = nYSize;
     poDS->eAccess = GA_Update;
     poDS->osFilename = pszFilename;
 
     // From gtiff driver, is this ok?
     /*
     poDS->nBlockXSize = nXSize;
     poDS->nBlockYSize = 1;
     poDS->nBlocksPerBand =
         ((nYSize + poDS->nBlockYSize - 1) / poDS->nBlockYSize)
         * ((nXSize + poDS->nBlockXSize - 1) / poDS->nBlockXSize);
         */
 
     // process options.
     poDS->papszCreationOptions = CSLDuplicate(papszOptions);
     poDS->ProcessCreationOptions();
 
     if( poDS->eMultipleLayerBehaviour == SEPARATE_FILES )
     {
         VSIStatBuf sStat;
         if( VSIStat(pszFilename, &sStat) == 0 )
         {
             if( !VSI_ISDIR(sStat.st_mode) )
             {
                 CPLError(CE_Failure, CPLE_FileIO,
                          "%s is an existing file, but not a directory",
                          pszFilename);
                 CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll
                                             // deadlock with GDALDataset own
                                             // mutex.
                 delete poDS;
                 CPLAcquireMutex(hNCMutex, 1000.0);
                 return NULL;
             }
         }
         else if( VSIMkdir(pszFilename, 0755) != 0 )
         {
             CPLError(CE_Failure, CPLE_FileIO, "Cannot create %s directory",
                      pszFilename);
             CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll
                                         // deadlock with GDALDataset own mutex.
             delete poDS;
             CPLAcquireMutex(hNCMutex, 1000.0);
             return NULL;
         }
 
         return poDS;
     }
 
     // Create the dataset.
-    int status = nc_create(pszFilename, poDS->nCreateMode, &(poDS->cdfid));
+    CPLString osFilenameForNCCreate(pszFilename);
+#ifdef WIN32
+    if( CPLTestBool(CPLGetConfigOption( "GDAL_FILENAME_IS_UTF8", "YES" ) ) )
+    {
+        char* pszTemp = CPLRecode( osFilenameForNCCreate, CPL_ENC_UTF8, "CP_ACP" );
+        osFilenameForNCCreate = pszTemp;
+        CPLFree(pszTemp);
+    }
+#endif
+    int status = nc_create(osFilenameForNCCreate, poDS->nCreateMode, &(poDS->cdfid));
 
     // Put into define mode.
     poDS->SetDefineMode(true);
 
     if( status != NC_NOERR )
     {
         CPLError(CE_Failure, CPLE_OpenFailed,
                  "Unable to create netCDF file %s (Error code %d): %s .",
                  pszFilename, status, nc_strerror(status));
         CPLReleaseMutex(hNCMutex);  // Release mutex otherwise we'll deadlock
                                     // with GDALDataset own mutex.
         delete poDS;
         CPLAcquireMutex(hNCMutex, 1000.0);
         return NULL;
     }
 
     // Define dimensions.
     if( nXSize > 0 && nYSize > 0 )
     {
         poDS->papszDimName.AddString(NCDF_DIMNAME_X);
         status =
             nc_def_dim(poDS->cdfid, NCDF_DIMNAME_X, nXSize, &(poDS->nXDimID));
         NCDF_ERR(status);
         CPLDebug("GDAL_netCDF", "status nc_def_dim(%d, %s, %d, -) got id %d",
                  poDS->cdfid, NCDF_DIMNAME_X, nXSize, poDS->nXDimID);
 
         poDS->papszDimName.AddString(NCDF_DIMNAME_Y);
         status =
             nc_def_dim(poDS->cdfid, NCDF_DIMNAME_Y, nYSize, &(poDS->nYDimID));
         NCDF_ERR(status);
         CPLDebug("GDAL_netCDF", "status nc_def_dim(%d, %s, %d, -) got id %d",
                  poDS->cdfid, NCDF_DIMNAME_Y, nYSize, poDS->nYDimID);
     }
 
     return poDS;
 }
 
 /************************************************************************/
 /*                            Create()                                  */
 /************************************************************************/
diff --git a/gdal/port/cpl_recode_stub.cpp b/gdal/port/cpl_recode_stub.cpp
index cc59533a45..68f4812ef0 100644
--- a/gdal/port/cpl_recode_stub.cpp
+++ b/gdal/port/cpl_recode_stub.cpp
@@ -127,180 +127,186 @@ void CPLClearRecodeStubWarningFlags()
 char *CPLRecodeStub( const char *pszSource,
                      const char *pszSrcEncoding,
                      const char *pszDstEncoding )
 
 {
 /* -------------------------------------------------------------------- */
 /*      If the source or destination is current locale(), we change     */
 /*      it to ISO8859-1 since our stub implementation does not          */
 /*      attempt to address locales properly.                            */
 /* -------------------------------------------------------------------- */
 
     if( pszSrcEncoding[0] == '\0' )
         pszSrcEncoding = CPL_ENC_ISO8859_1;
 
     if( pszDstEncoding[0] == '\0' )
         pszDstEncoding = CPL_ENC_ISO8859_1;
 
 /* -------------------------------------------------------------------- */
 /*      ISO8859 to UTF8                                                 */
 /* -------------------------------------------------------------------- */
     if( strcmp(pszSrcEncoding, CPL_ENC_ISO8859_1) == 0
         && strcmp(pszDstEncoding, CPL_ENC_UTF8) == 0 )
     {
         const int nCharCount = static_cast<int>(strlen(pszSource));
         char *pszResult = static_cast<char *>(CPLCalloc(1, nCharCount * 2 + 1));
 
         utf8froma(pszResult, nCharCount * 2 + 1, pszSource, nCharCount);
 
         return pszResult;
     }
 
 /* -------------------------------------------------------------------- */
 /*      UTF8 to ISO8859                                                 */
 /* -------------------------------------------------------------------- */
     if( strcmp(pszSrcEncoding, CPL_ENC_UTF8) == 0
         && strcmp(pszDstEncoding, CPL_ENC_ISO8859_1) == 0 )
     {
         int nCharCount = static_cast<int>(strlen(pszSource));
         char *pszResult = static_cast<char *>(CPLCalloc(1, nCharCount + 1));
 
         utf8toa(pszSource, nCharCount, pszResult, nCharCount + 1);
 
         return pszResult;
     }
 
 #ifdef _WIN32
 /* ---------------------------------------------------------------------*/
 /*      CPXXX to UTF8                                                   */
 /* ---------------------------------------------------------------------*/
     if( STARTS_WITH(pszSrcEncoding, "CP")
         && strcmp(pszDstEncoding, CPL_ENC_UTF8) == 0 )
     {
         int nCode = atoi( pszSrcEncoding + 2 );
         if( nCode > 0 ) {
            return CPLWin32Recode( pszSource, nCode, CP_UTF8 );
         }
         else if( EQUAL(pszSrcEncoding, "CP_OEMCP") )
             return CPLWin32Recode( pszSource, CP_OEMCP, CP_UTF8 );
+        else if( EQUAL(pszSrcEncoding, "CP_ACP") )
+            return CPLWin32Recode( pszSource, CP_ACP, CP_UTF8 );
     }
 
 /* ---------------------------------------------------------------------*/
 /*      UTF8 to CPXXX                                                   */
 /* ---------------------------------------------------------------------*/
     if( strcmp(pszSrcEncoding, CPL_ENC_UTF8) == 0
         && STARTS_WITH(pszDstEncoding, "CP") )
     {
          int nCode = atoi( pszDstEncoding + 2 );
          if( nCode > 0 ) {
              return CPLWin32Recode( pszSource, CP_UTF8, nCode );
          }
+         else if( EQUAL(pszDstEncoding, "CP_OEMCP") )
+            return CPLWin32Recode( pszSource, CP_UTF8, CP_OEMCP );
+         else if( EQUAL(pszDstEncoding, "CP_ACP") )
+            return CPLWin32Recode( pszSource, CP_UTF8, CP_ACP );
     }
 #endif
 
 /* -------------------------------------------------------------------- */
 /*      Anything else to UTF-8 is treated as ISO8859-1 to UTF-8 with    */
 /*      a one-time warning.                                             */
 /* -------------------------------------------------------------------- */
     if( strcmp(pszDstEncoding, CPL_ENC_UTF8) == 0 )
     {
         int nCharCount = static_cast<int>(strlen(pszSource));
         char *pszResult = static_cast<char *>(CPLCalloc(1, nCharCount * 2 + 1));
 
         if( EQUAL( pszSrcEncoding, "CP437") ) // For ZIP file handling.
         {
             bool bIsAllPrintableASCII = true;
             for( int i = 0; i <nCharCount; i++ )
             {
                 if( pszSource[i] < 32 || pszSource[i] > 126 )
                 {
                     bIsAllPrintableASCII = false;
                     break;
                 }
             }
             if( bIsAllPrintableASCII )
             {
                 if( nCharCount )
                     memcpy( pszResult, pszSource, nCharCount );
                 return pszResult;
             }
         }
 
         if( !bHaveWarned1 )
         {
             bHaveWarned1 = true;
             CPLError( CE_Warning, CPLE_AppDefined,
                       "Recode from %s to UTF-8 not supported, "
                       "treated as ISO8859-1 to UTF-8.",
                       pszSrcEncoding );
         }
 
         utf8froma( pszResult, nCharCount*2+1, pszSource, nCharCount );
 
         return pszResult;
     }
 
 /* -------------------------------------------------------------------- */
 /*      UTF-8 to anything else is treated as UTF-8 to ISO-8859-1        */
 /*      with a warning.                                                 */
 /* -------------------------------------------------------------------- */
     if( strcmp(pszSrcEncoding, CPL_ENC_UTF8) == 0
         && strcmp(pszDstEncoding, CPL_ENC_ISO8859_1) == 0 )
     {
         int nCharCount = static_cast<int>(strlen(pszSource));
         char *pszResult = static_cast<char *>(CPLCalloc(1, nCharCount + 1));
 
         if( !bHaveWarned2 )
         {
             bHaveWarned2 = true;
             CPLError( CE_Warning, CPLE_AppDefined,
                       "Recode from UTF-8 to %s not supported, "
                       "treated as UTF-8 to ISO8859-1.",
                       pszDstEncoding );
         }
 
         utf8toa(pszSource, nCharCount, pszResult, nCharCount + 1);
 
         return pszResult;
     }
 
 /* -------------------------------------------------------------------- */
 /*      Everything else is treated as a no-op with a warning.           */
 /* -------------------------------------------------------------------- */
     {
         if( !bHaveWarned3 )
         {
             bHaveWarned3 = true;
             CPLError( CE_Warning, CPLE_AppDefined,
                       "Recode from %s to %s not supported, no change applied.",
                       pszSrcEncoding, pszDstEncoding );
         }
 
         return CPLStrdup(pszSource);
     }
 }
 
 /************************************************************************/
 /*                       CPLRecodeFromWCharStub()                       */
 /************************************************************************/
 
 /**
  * Convert wchar_t string to UTF-8.
  *
  * Convert a wchar_t string into a multibyte utf-8 string.  The only
  * guaranteed supported source encoding is CPL_ENC_UCS2, and the only
  * guaranteed supported destination encodings are CPL_ENC_UTF8, CPL_ENC_ASCII
  * and CPL_ENC_ISO8859_1.  In some cases (i.e. using iconv()) other encodings
  * may also be supported.
  *
  * Note that the wchar_t type varies in size on different systems. On
  * win32 it is normally 2 bytes, and on unix 4 bytes.
  *
  * If an error occurs an error may, or may not be posted with CPLError().
  *
  * @param pwszSource the source wchar_t string, terminated with a 0 wchar_t.
  * @param pszSrcEncoding the source encoding, typically CPL_ENC_UCS2.
  * @param pszDstEncoding the destination encoding, typically CPL_ENC_UTF8.
  *
  * @return a zero terminated multi-byte string which should be freed with
  * CPLFree(), or NULL if an error occurs.
  */
