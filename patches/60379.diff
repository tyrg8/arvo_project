commit bf9f319cb4b86b130bee16af19fee95a1cdb5ef2
Author: DRC <information@libjpeg-turbo.org>
Date:   Thu Jun 29 16:07:42 2023 -0400

    Disallow color quantization with lossless decomp
    
    Color quantization is a legacy feature that serves little or no purpose
    with lossless JPEG images.  9f756bc67a84d4566bf74a0c2432aa55da404021
    eliminated interaction issues between the lossless decompressor and the
    color quantizers related to out-of-range 12-bit samples, but referring
    to #701, other interaction issues apparently still exist.  Such issues
    are likely, given the fact that the color quantizers were not designed
    with lossless decompression in mind.
    
    This commit reverts 9f756bc67a84d4566bf74a0c2432aa55da404021, since the
    issues it fixed are no longer relevant because of this commit and
    2192560d74e6e6cf99dd05928885573be00a8208.
    
    Fixed #672
    Fixes #673
    Fixes #674
    Fixes #676
    Fixes #677
    Fixes #678
    Fixes #679
    Fixes #681
    Fixes #683
    Fixes #701

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 83b4103d..efd101a0 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -564,10 +564,10 @@ message(STATUS "CMAKE_EXECUTABLE_SUFFIX = ${CMAKE_EXECUTABLE_SUFFIX}")
 
 set(JPEG16_SOURCES jcapistd.c jccolor.c jcdiffct.c jclossls.c jcmainct.c
   jcprepct.c jcsample.c jdapistd.c jdcolor.c jddiffct.c jdlossls.c jdmainct.c
-  jdpostct.c jdsample.c jquant1.c jquant2.c jutils.c)
+  jdpostct.c jdsample.c jutils.c)
 set(JPEG12_SOURCES ${JPEG16_SOURCES} jccoefct.c jcdctmgr.c jdcoefct.c
-  jddctmgr.c jdmerge.c jdpostct.c jfdctfst.c jfdctint.c jidctflt.c jidctfst.c
-  jidctint.c jidctred.c)
+  jddctmgr.c jdmerge.c jfdctfst.c jfdctint.c jidctflt.c jidctfst.c jidctint.c
+  jidctred.c jquant1.c jquant2.c)
 set(JPEG_SOURCES ${JPEG12_SOURCES} jcapimin.c jchuff.c jcicc.c jcinit.c
   jclhuff.c jcmarker.c jcmaster.c jcomapi.c jcparam.c jcphuff.c jctrans.c
   jdapimin.c jdatadst.c jdatasrc.c jdhuff.c jdicc.c jdinput.c jdlhuff.c
@@ -742,37 +742,37 @@ set(CDJPEG_COMPILE_FLAGS
 if(ENABLE_STATIC)
   # Compile a separate version of these source files with 12-bit and 16-bit
   # data precision.
   add_library(cjpeg12-static OBJECT rdgif.c rdppm.c)
   set_property(TARGET cjpeg12-static PROPERTY COMPILE_FLAGS
     "-DBITS_IN_JSAMPLE=12 -DGIF_SUPPORTED -DPPM_SUPPORTED")
   add_library(cjpeg16-static OBJECT rdgif.c rdppm.c)
   set_property(TARGET cjpeg16-static PROPERTY COMPILE_FLAGS
     "-DBITS_IN_JSAMPLE=16 -DGIF_SUPPORTED -DPPM_SUPPORTED")
   add_executable(cjpeg-static cjpeg.c cdjpeg.c rdbmp.c rdgif.c rdppm.c
     rdswitch.c rdtarga.c $<TARGET_OBJECTS:cjpeg12-static>
     $<TARGET_OBJECTS:cjpeg16-static>)
   set_property(TARGET cjpeg-static PROPERTY COMPILE_FLAGS
     ${CDJPEG_COMPILE_FLAGS})
   target_link_libraries(cjpeg-static jpeg-static)
 
   # Compile a separate version of these source files with 12-bit and 16-bit
   # data precision.
   add_library(djpeg12-static OBJECT rdcolmap.c wrgif.c wrppm.c)
   set_property(TARGET djpeg12-static PROPERTY COMPILE_FLAGS
     "-DBITS_IN_JSAMPLE=12 -DGIF_SUPPORTED -DPPM_SUPPORTED")
-  add_library(djpeg16-static OBJECT rdcolmap.c wrgif.c wrppm.c)
+  add_library(djpeg16-static OBJECT wrppm.c)
   set_property(TARGET djpeg16-static PROPERTY COMPILE_FLAGS
-    "-DBITS_IN_JSAMPLE=16 -DGIF_SUPPORTED -DPPM_SUPPORTED")
+    "-DBITS_IN_JSAMPLE=16 -DPPM_SUPPORTED")
   add_executable(djpeg-static djpeg.c cdjpeg.c rdcolmap.c rdswitch.c wrbmp.c
     wrgif.c wrppm.c wrtarga.c $<TARGET_OBJECTS:djpeg12-static>
     $<TARGET_OBJECTS:djpeg16-static>)
   set_property(TARGET djpeg-static PROPERTY COMPILE_FLAGS
     ${CDJPEG_COMPILE_FLAGS})
   target_link_libraries(djpeg-static jpeg-static)
 
   add_executable(jpegtran-static jpegtran.c cdjpeg.c rdswitch.c transupp.c)
   target_link_libraries(jpegtran-static jpeg-static)
   set_property(TARGET jpegtran-static PROPERTY COMPILE_FLAGS "${USE_SETMODE}")
 
   add_executable(example-static example.c)
   target_link_libraries(example-static jpeg-static)
diff --git a/ChangeLog.md b/ChangeLog.md
index c61565be..aadd7907 100644
--- a/ChangeLog.md
+++ b/ChangeLog.md
@@ -10,11 +10,17 @@ images.
 
 2. Fixed various segfaults and buffer overruns (CVE-2023-2804) that occurred
 when attempting to decompress various specially-crafted malformed
-12-bit-per-component lossless JPEG images.  These issues were caused by
-out-of-range sample values that were not range-limited before being used as
-array indices.  The issues were specific to 12-bit data precision, since that
-is the only data precision for which the range of the sample data type exceeds
-the valid sample range.
+12-bit-per-component and 16-bit-per-component lossless JPEG images using color
+quantization or merged chroma upsampling/color conversion.  The underlying
+cause of these issues was that the color quantization and merged chroma
+upsampling/color conversion algorithms were not designed with lossless
+decompression in mind.  Since libjpeg-turbo explicitly does not support color
+conversion when compressing or decompressing lossless JPEG images, merged
+chroma upsampling/color conversion never should have been enabled for such
+images.  Color quantization is a legacy feature that serves little or no
+purpose with lossless JPEG images, so it is also now disabled when
+decompressing such images.  (As a result, djpeg can no longer decompress a
+lossless JPEG image into a GIF image.)
 
 3. Fixed an oversight in 1.4 beta1[8] that caused various segfaults and buffer
 overruns when attempting to decompress various specially-crafted malformed
diff --git a/cdjpeg.h b/cdjpeg.h
index 13609f66..471b9a3f 100644
--- a/cdjpeg.h
+++ b/cdjpeg.h
@@ -123,10 +123,6 @@ EXTERN(cjpeg_source_ptr) j16init_read_gif(j_compress_ptr cinfo);
 EXTERN(djpeg_dest_ptr) jinit_write_gif(j_decompress_ptr cinfo, boolean is_lzw);
 EXTERN(djpeg_dest_ptr) j12init_write_gif(j_decompress_ptr cinfo,
                                          boolean is_lzw);
-#ifdef D_LOSSLESS_SUPPORTED
-EXTERN(djpeg_dest_ptr) j16init_write_gif(j_decompress_ptr cinfo,
-                                         boolean is_lzw);
-#endif
 EXTERN(cjpeg_source_ptr) jinit_read_ppm(j_compress_ptr cinfo);
 EXTERN(cjpeg_source_ptr) j12init_read_ppm(j_compress_ptr cinfo);
 #ifdef C_LOSSLESS_SUPPORTED
@@ -154,9 +150,6 @@ EXTERN(boolean) set_sample_factors(j_compress_ptr cinfo, char *arg);
 
 EXTERN(void) read_color_map(j_decompress_ptr cinfo, FILE *infile);
 EXTERN(void) read_color_map_12(j_decompress_ptr cinfo, FILE *infile);
-#ifdef D_LOSSLESS_SUPPORTED
-EXTERN(void) read_color_map_16(j_decompress_ptr cinfo, FILE *infile);
-#endif
 
 /* common support routines (in cdjpeg.c) */
 
diff --git a/cjpeg.1 b/cjpeg.1
index 7ddce3c0..0815ca0c 100644
--- a/cjpeg.1
+++ b/cjpeg.1
@@ -1,4 +1,4 @@
-.TH CJPEG 1 "30 November 2022"
+.TH CJPEG 1 "29 June 2023"
 .SH NAME
 cjpeg \- compress an image file to a JPEG file
 .SH SYNOPSIS
@@ -179,19 +179,21 @@ unavailable when compressing or decompressing a lossless JPEG file:
 .IP
 - Quality/quantization table selection
 .IP
 - Color space conversion (the JPEG image will use the same color space as the
 input image)
 .IP
+- Color quantization
+.IP
 - DCT/IDCT algorithm selection
 .IP
 - Smoothing
 .IP
 - Downsampling/upsampling
 .IP
 - IDCT scaling
 .IP
 - Partial image decompression
 .IP
 - Transformations using
 .B jpegtran
 .IP
diff --git a/djpeg.c b/djpeg.c
index 1f715316..f42d3543 100644
--- a/djpeg.c
+++ b/djpeg.c
@@ -522,413 +522,407 @@ int
 main(int argc, char **argv)
 {
   struct jpeg_decompress_struct cinfo;
   struct jpeg_error_mgr jerr;
   struct cdjpeg_progress_mgr progress;
   int file_index;
   djpeg_dest_ptr dest_mgr = NULL;
   FILE *input_file;
   FILE *output_file;
   unsigned char *inbuffer = NULL;
   unsigned long insize = 0;
   JDIMENSION num_scanlines;
 
   progname = argv[0];
   if (progname == NULL || progname[0] == 0)
     progname = "djpeg";         /* in case C library doesn't provide it */
 
   /* Initialize the JPEG decompression object with default error handling. */
   cinfo.err = jpeg_std_error(&jerr);
   jpeg_create_decompress(&cinfo);
   /* Add some application-specific error messages (from cderror.h) */
   jerr.addon_message_table = cdjpeg_message_table;
   jerr.first_addon_message = JMSG_FIRSTADDONCODE;
   jerr.last_addon_message = JMSG_LASTADDONCODE;
 
   /* Insert custom marker processor for COM and APP12.
    * APP12 is used by some digital camera makers for textual info,
    * so we provide the ability to display it as text.
    * If you like, additional APPn marker types can be selected for display,
    * but don't try to override APP0 or APP14 this way (see libjpeg.txt).
    */
   jpeg_set_marker_processor(&cinfo, JPEG_COM, print_text_marker);
   jpeg_set_marker_processor(&cinfo, JPEG_APP0 + 12, print_text_marker);
 
   /* Scan command line to find file names. */
   /* It is convenient to use just one switch-parsing routine, but the switch
    * values read here are ignored; we will rescan the switches after opening
    * the input file.
    * (Exception: tracing level set here controls verbosity for COM markers
    * found during jpeg_read_header...)
    */
 
   file_index = parse_switches(&cinfo, argc, argv, 0, FALSE);
 
   if (strict)
     jerr.emit_message = my_emit_message;
 
 #ifdef TWO_FILE_COMMANDLINE
   /* Must have either -outfile switch or explicit output file name */
   if (outfilename == NULL) {
     if (file_index != argc - 2) {
       fprintf(stderr, "%s: must name one input and one output file\n",
               progname);
       usage();
     }
     outfilename = argv[file_index + 1];
   } else {
     if (file_index != argc - 1) {
       fprintf(stderr, "%s: must name one input and one output file\n",
               progname);
       usage();
     }
   }
 #else
   /* Unix style: expect zero or one file name */
   if (file_index < argc - 1) {
     fprintf(stderr, "%s: only one input file\n", progname);
     usage();
   }
 #endif /* TWO_FILE_COMMANDLINE */
 
   /* Open the input file. */
   if (file_index < argc) {
     if ((input_file = fopen(argv[file_index], READ_BINARY)) == NULL) {
       fprintf(stderr, "%s: can't open %s\n", progname, argv[file_index]);
       exit(EXIT_FAILURE);
     }
   } else {
     /* default input file is stdin */
     input_file = read_stdin();
   }
 
   /* Open the output file. */
   if (outfilename != NULL) {
     if ((output_file = fopen(outfilename, WRITE_BINARY)) == NULL) {
       fprintf(stderr, "%s: can't open %s\n", progname, outfilename);
       exit(EXIT_FAILURE);
     }
   } else {
     /* default output file is stdout */
     output_file = write_stdout();
   }
 
   if (report || max_scans != 0) {
     start_progress_monitor((j_common_ptr)&cinfo, &progress);
     progress.report = report;
     progress.max_scans = max_scans;
   }
 
   /* Specify data source for decompression */
   if (memsrc) {
     size_t nbytes;
     do {
       inbuffer = (unsigned char *)realloc(inbuffer, insize + INPUT_BUF_SIZE);
       if (inbuffer == NULL) {
         fprintf(stderr, "%s: memory allocation failure\n", progname);
         exit(EXIT_FAILURE);
       }
       nbytes = fread(&inbuffer[insize], 1, INPUT_BUF_SIZE, input_file);
       if (nbytes < INPUT_BUF_SIZE && ferror(input_file)) {
         if (file_index < argc)
           fprintf(stderr, "%s: can't read from %s\n", progname,
                   argv[file_index]);
         else
           fprintf(stderr, "%s: can't read from stdin\n", progname);
       }
       insize += (unsigned long)nbytes;
     } while (nbytes == INPUT_BUF_SIZE);
     fprintf(stderr, "Compressed size:  %lu bytes\n", insize);
     jpeg_mem_src(&cinfo, inbuffer, insize);
   } else
     jpeg_stdio_src(&cinfo, input_file);
 
   /* Read file header, set default decompression parameters */
   (void)jpeg_read_header(&cinfo, TRUE);
 
   /* Adjust default decompression parameters by re-parsing the options */
   file_index = parse_switches(&cinfo, argc, argv, 0, TRUE);
 
   /* Initialize the output module now to let it override any crucial
    * option settings (for instance, GIF wants to force color quantization).
    */
   switch (requested_fmt) {
 #ifdef BMP_SUPPORTED
   case FMT_BMP:
     dest_mgr = jinit_write_bmp(&cinfo, FALSE, TRUE);
     break;
   case FMT_OS2:
     dest_mgr = jinit_write_bmp(&cinfo, TRUE, TRUE);
     break;
 #endif
 #ifdef GIF_SUPPORTED
   case FMT_GIF:
-    if (cinfo.data_precision == 16) {
-#ifdef D_LOSSLESS_SUPPORTED
-      dest_mgr = j16init_write_gif(&cinfo, TRUE);
-#else
+    if (cinfo.data_precision == 16)
       ERREXIT1(&cinfo, JERR_BAD_PRECISION, cinfo.data_precision);
-      break;
-#endif
-    } else if (cinfo.data_precision == 12)
+    else if (cinfo.data_precision == 12)
       dest_mgr = j12init_write_gif(&cinfo, TRUE);
     else
       dest_mgr = jinit_write_gif(&cinfo, TRUE);
     break;
   case FMT_GIF0:
     dest_mgr = jinit_write_gif(&cinfo, FALSE);
     break;
 #endif
 #ifdef PPM_SUPPORTED
   case FMT_PPM:
-    if (cinfo.data_precision == 16) {
+    if (cinfo.data_precision == 16)
 #ifdef D_LOSSLESS_SUPPORTED
       dest_mgr = j16init_write_ppm(&cinfo);
 #else
       ERREXIT1(&cinfo, JERR_BAD_PRECISION, cinfo.data_precision);
-      break;
 #endif
-    } else if (cinfo.data_precision == 12)
+    else if (cinfo.data_precision == 12)
       dest_mgr = j12init_write_ppm(&cinfo);
     else
       dest_mgr = jinit_write_ppm(&cinfo);
     break;
 #endif
 #ifdef TARGA_SUPPORTED
   case FMT_TARGA:
     dest_mgr = jinit_write_targa(&cinfo);
     break;
 #endif
   default:
     ERREXIT(&cinfo, JERR_UNSUPPORTED_FORMAT);
     break;
   }
   dest_mgr->output_file = output_file;
 
   /* Start decompressor */
   (void)jpeg_start_decompress(&cinfo);
 
   /* Skip rows */
   if (skip) {
     JDIMENSION tmp;
 
     /* Check for valid skip_end.  We cannot check this value until after
      * jpeg_start_decompress() is called.  Note that we have already verified
      * that skip_start <= skip_end.
      */
     if (skip_end > cinfo.output_height - 1) {
       fprintf(stderr, "%s: skip region exceeds image height %u\n", progname,
               cinfo.output_height);
       exit(EXIT_FAILURE);
     }
 
     /* Write output file header.  This is a hack to ensure that the destination
      * manager creates an output image of the proper size.
      */
     tmp = cinfo.output_height;
     cinfo.output_height -= (skip_end - skip_start + 1);
     (*dest_mgr->start_output) (&cinfo, dest_mgr);
     cinfo.output_height = tmp;
 
     if (cinfo.data_precision == 16)
       ERREXIT(&cinfo, JERR_NOTIMPL);
     else if (cinfo.data_precision == 12) {
       /* Process data */
       while (cinfo.output_scanline < skip_start) {
         num_scanlines = jpeg12_read_scanlines(&cinfo, dest_mgr->buffer12,
                                               dest_mgr->buffer_height);
         (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
       }
       if ((tmp = jpeg12_skip_scanlines(&cinfo, skip_end - skip_start + 1)) !=
           skip_end - skip_start + 1) {
         fprintf(stderr, "%s: jpeg12_skip_scanlines() returned %u rather than %u\n",
                 progname, tmp, skip_end - skip_start + 1);
         exit(EXIT_FAILURE);
       }
       while (cinfo.output_scanline < cinfo.output_height) {
         num_scanlines = jpeg12_read_scanlines(&cinfo, dest_mgr->buffer12,
                                               dest_mgr->buffer_height);
         (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
       }
     } else {
       /* Process data */
       while (cinfo.output_scanline < skip_start) {
         num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,
                                             dest_mgr->buffer_height);
         (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
       }
       if ((tmp = jpeg_skip_scanlines(&cinfo, skip_end - skip_start + 1)) !=
           skip_end - skip_start + 1) {
         fprintf(stderr, "%s: jpeg_skip_scanlines() returned %u rather than %u\n",
                 progname, tmp, skip_end - skip_start + 1);
         exit(EXIT_FAILURE);
       }
       while (cinfo.output_scanline < cinfo.output_height) {
         num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,
                                             dest_mgr->buffer_height);
         (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
       }
     }
 
   /* Decompress a subregion */
   } else if (crop) {
     JDIMENSION tmp;
 
     /* Check for valid crop dimensions.  We cannot check these values until
      * after jpeg_start_decompress() is called.
      */
     if (crop_x + crop_width > cinfo.output_width ||
         crop_y + crop_height > cinfo.output_height) {
       fprintf(stderr, "%s: crop dimensions exceed image dimensions %u x %u\n",
               progname, cinfo.output_width, cinfo.output_height);
       exit(EXIT_FAILURE);
     }
 
     if (cinfo.data_precision == 16)
       ERREXIT(&cinfo, JERR_NOTIMPL);
     else if (cinfo.data_precision == 12)
       jpeg12_crop_scanline(&cinfo, &crop_x, &crop_width);
     else
       jpeg_crop_scanline(&cinfo, &crop_x, &crop_width);
     if (dest_mgr->calc_buffer_dimensions)
       (*dest_mgr->calc_buffer_dimensions) (&cinfo, dest_mgr);
     else
       ERREXIT(&cinfo, JERR_UNSUPPORTED_FORMAT);
 
     /* Write output file header.  This is a hack to ensure that the destination
      * manager creates an output image of the proper size.
      */
     tmp = cinfo.output_height;
     cinfo.output_height = crop_height;
     (*dest_mgr->start_output) (&cinfo, dest_mgr);
     cinfo.output_height = tmp;
 
     if (cinfo.data_precision == 16)
       ERREXIT(&cinfo, JERR_NOTIMPL);
     else if (cinfo.data_precision == 12) {
       /* Process data */
       if ((tmp = jpeg12_skip_scanlines(&cinfo, crop_y)) != crop_y) {
         fprintf(stderr, "%s: jpeg12_skip_scanlines() returned %u rather than %u\n",
                 progname, tmp, crop_y);
         exit(EXIT_FAILURE);
       }
       while (cinfo.output_scanline < crop_y + crop_height) {
         num_scanlines = jpeg12_read_scanlines(&cinfo, dest_mgr->buffer12,
                                               dest_mgr->buffer_height);
         (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
       }
       if ((tmp =
            jpeg12_skip_scanlines(&cinfo, cinfo.output_height - crop_y -
                                          crop_height)) !=
           cinfo.output_height - crop_y - crop_height) {
         fprintf(stderr, "%s: jpeg12_skip_scanlines() returned %u rather than %u\n",
                 progname, tmp, cinfo.output_height - crop_y - crop_height);
         exit(EXIT_FAILURE);
       }
     } else {
       /* Process data */
       if ((tmp = jpeg_skip_scanlines(&cinfo, crop_y)) != crop_y) {
         fprintf(stderr, "%s: jpeg_skip_scanlines() returned %u rather than %u\n",
                 progname, tmp, crop_y);
         exit(EXIT_FAILURE);
       }
       while (cinfo.output_scanline < crop_y + crop_height) {
         num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,
                                             dest_mgr->buffer_height);
         (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
       }
       if ((tmp =
            jpeg_skip_scanlines(&cinfo,
                                cinfo.output_height - crop_y - crop_height)) !=
           cinfo.output_height - crop_y - crop_height) {
         fprintf(stderr, "%s: jpeg_skip_scanlines() returned %u rather than %u\n",
                 progname, tmp, cinfo.output_height - crop_y - crop_height);
         exit(EXIT_FAILURE);
       }
     }
 
   /* Normal full-image decompress */
   } else {
     /* Write output file header */
     (*dest_mgr->start_output) (&cinfo, dest_mgr);
 
     if (cinfo.data_precision == 16) {
 #ifdef D_LOSSLESS_SUPPORTED
       /* Process data */
       while (cinfo.output_scanline < cinfo.output_height) {
         num_scanlines = jpeg16_read_scanlines(&cinfo, dest_mgr->buffer16,
                                               dest_mgr->buffer_height);
         (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
       }
 #else
       ERREXIT1(&cinfo, JERR_BAD_PRECISION, cinfo.data_precision);
 #endif
     } else if (cinfo.data_precision == 12) {
       /* Process data */
       while (cinfo.output_scanline < cinfo.output_height) {
         num_scanlines = jpeg12_read_scanlines(&cinfo, dest_mgr->buffer12,
                                               dest_mgr->buffer_height);
         (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
       }
     } else {
       /* Process data */
       while (cinfo.output_scanline < cinfo.output_height) {
         num_scanlines = jpeg_read_scanlines(&cinfo, dest_mgr->buffer,
                                             dest_mgr->buffer_height);
         (*dest_mgr->put_pixel_rows) (&cinfo, dest_mgr, num_scanlines);
       }
     }
   }
 
   /* Hack: count final pass as done in case finish_output does an extra pass.
    * The library won't have updated completed_passes.
    */
   if (report || max_scans != 0)
     progress.pub.completed_passes = progress.pub.total_passes;
 
   if (icc_filename != NULL) {
     FILE *icc_file;
     JOCTET *icc_profile;
     unsigned int icc_len;
 
     if ((icc_file = fopen(icc_filename, WRITE_BINARY)) == NULL) {
       fprintf(stderr, "%s: can't open %s\n", progname, icc_filename);
       exit(EXIT_FAILURE);
     }
     if (jpeg_read_icc_profile(&cinfo, &icc_profile, &icc_len)) {
       if (fwrite(icc_profile, icc_len, 1, icc_file) < 1) {
         fprintf(stderr, "%s: can't read ICC profile from %s\n", progname,
                 icc_filename);
         free(icc_profile);
         fclose(icc_file);
         exit(EXIT_FAILURE);
       }
       free(icc_profile);
       fclose(icc_file);
     } else if (cinfo.err->msg_code != JWRN_BOGUS_ICC)
       fprintf(stderr, "%s: no ICC profile data in JPEG file\n", progname);
   }
 
   /* Finish decompression and release memory.
    * I must do it in this order because output module has allocated memory
    * of lifespan JPOOL_IMAGE; it needs to finish before releasing memory.
    */
   (*dest_mgr->finish_output) (&cinfo, dest_mgr);
   (void)jpeg_finish_decompress(&cinfo);
   jpeg_destroy_decompress(&cinfo);
 
   /* Close files, if we opened them */
   if (input_file != stdin)
     fclose(input_file);
   if (output_file != stdout)
     fclose(output_file);
 
   if (report || max_scans != 0)
     end_progress_monitor((j_common_ptr)&cinfo);
 
   if (memsrc)
     free(inbuffer);
 
   /* All done. */
   exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);
   return 0;                     /* suppress no-return-value warnings */
 }
diff --git a/jdlossls.c b/jdlossls.c
index cfdca7e3..4d15e6bb 100644
--- a/jdlossls.c
+++ b/jdlossls.c
@@ -1,105 +1,105 @@
 /*
  * jdlossls.c
  *
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1998, Thomas G. Lane.
  * Lossless JPEG Modifications:
  * Copyright (C) 1999, Ken Murchison.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2022-2023, D. R. Commander.
+ * Copyright (C) 2022, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
  * This file contains prediction, sample undifferencing, point transform, and
  * sample scaling routines for the lossless JPEG decompressor.
  */
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jlossls.h"
 
 #ifdef D_LOSSLESS_SUPPORTED
 
 
 /**************** Sample undifferencing (reconstruction) *****************/
 
 /*
  * In order to avoid a performance penalty for checking which predictor is
  * being used and which row is being processed for each call of the
  * undifferencer, and to promote optimization, we have separate undifferencing
  * functions for each predictor selection value.
  *
  * We are able to avoid duplicating source code by implementing the predictors
  * and undifferencers as macros.  Each of the undifferencing functions is
  * simply a wrapper around an UNDIFFERENCE macro with the appropriate PREDICTOR
  * macro passed as an argument.
  */
 
 /* Predictor for the first column of the first row: 2^(P-Pt-1) */
 #define INITIAL_PREDICTORx  (1 << (cinfo->data_precision - cinfo->Al - 1))
 
 /* Predictor for the first column of the remaining rows: Rb */
 #define INITIAL_PREDICTOR2  prev_row[0]
 
 
 /*
  * 1-Dimensional undifferencer routine.
  *
  * This macro implements the 1-D horizontal predictor (1).  INITIAL_PREDICTOR
  * is used as the special case predictor for the first column, which must be
  * either INITIAL_PREDICTOR2 or INITIAL_PREDICTORx.  The remaining samples
  * use PREDICTOR1.
  *
  * The reconstructed sample is supposed to be calculated modulo 2^16, so we
  * logically AND the result with 0xFFFF.
  */
 
 #define UNDIFFERENCE_1D(INITIAL_PREDICTOR) \
   int Ra; \
   \
   Ra = (*diff_buf++ + INITIAL_PREDICTOR) & 0xFFFF; \
   *undiff_buf++ = Ra; \
   \
   while (--width) { \
     Ra = (*diff_buf++ + PREDICTOR1) & 0xFFFF; \
     *undiff_buf++ = Ra; \
   }
 
 
 /*
  * 2-Dimensional undifferencer routine.
  *
  * This macro implements the 2-D horizontal predictors (#2-7).  PREDICTOR2 is
  * used as the special case predictor for the first column.  The remaining
  * samples use PREDICTOR, which is a function of Ra, Rb, and Rc.
  *
  * Because prev_row and output_buf may point to the same storage area (in an
  * interleaved image with Vi=1, for example), we must take care to buffer Rb/Rc
  * before writing the current reconstructed sample value into output_buf.
  *
  * The reconstructed sample is supposed to be calculated modulo 2^16, so we
  * logically AND the result with 0xFFFF.
  */
 
 #define UNDIFFERENCE_2D(PREDICTOR) \
   int Ra, Rb, Rc; \
   \
   Rb = *prev_row++; \
   Ra = (*diff_buf++ + PREDICTOR2) & 0xFFFF; \
   *undiff_buf++ = Ra; \
   \
   while (--width) { \
     Rc = Rb; \
     Rb = *prev_row++; \
     Ra = (*diff_buf++ + PREDICTOR) & 0xFFFF; \
     *undiff_buf++ = Ra; \
   }
 
 
 /*
  * Undifferencers for the second and subsequent rows in a scan or restart
  * interval.  The first sample in the row is undifferenced using the vertical
  * predictor (2).  The rest of the samples are undifferenced using the
  * predictor specified in the scan header.
  */
@@ -216,16 +216,8 @@ METHODDEF(void)
 simple_upscale(j_decompress_ptr cinfo,
                JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)
 {
   do {
-#if BITS_IN_JSAMPLE == 12
-    /* 12-bit is the only data precision for which the range of the sample data
-     * type exceeds the valid sample range.  Thus, we need to range-limit the
-     * samples, because other algorithms may try to use them as array indices.
-     */
-    *output_buf++ = (_JSAMPLE)((*diff_buf++ << cinfo->Al) & 0xFFF);
-#else
     *output_buf++ = (_JSAMPLE)(*diff_buf++ << cinfo->Al);
-#endif
   } while (--width);
 }
 
@@ -233,16 +225,12 @@ METHODDEF(void)
 noscale(j_decompress_ptr cinfo,
         JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)
 {
   do {
-#if BITS_IN_JSAMPLE == 12
-    *output_buf++ = (_JSAMPLE)((*diff_buf++) & 0xFFF);
-#else
     *output_buf++ = (_JSAMPLE)(*diff_buf++);
-#endif
   } while (--width);
 }
 
 
 /*
  * Initialize for an input processing pass.
  */
diff --git a/jdmaster.c b/jdmaster.c
index 4b3852d9..80a4842a 100644
--- a/jdmaster.c
+++ b/jdmaster.c
@@ -511,270 +511,262 @@ LOCAL(void)
 master_selection(j_decompress_ptr cinfo)
 {
   my_master_ptr master = (my_master_ptr)cinfo->master;
   boolean use_c_buffer;
   long samplesperrow;
   JDIMENSION jd_samplesperrow;
 
   /* Disable IDCT scaling and raw (downsampled) data output in lossless mode.
    * IDCT scaling is not useful in lossless mode, and it must be disabled in
    * order to properly calculate the output dimensions.  Raw data output isn't
    * particularly useful without subsampling and has not been tested in
    * lossless mode.
    */
   if (cinfo->master->lossless) {
     cinfo->raw_data_out = FALSE;
     cinfo->scale_num = cinfo->scale_denom = 1;
   }
 
   /* Initialize dimensions and other stuff */
   jpeg_calc_output_dimensions(cinfo);
   prepare_range_limit_table(cinfo);
 
   /* Width of an output scanline must be representable as JDIMENSION. */
   samplesperrow = (long)cinfo->output_width *
                   (long)cinfo->out_color_components;
   jd_samplesperrow = (JDIMENSION)samplesperrow;
   if ((long)jd_samplesperrow != samplesperrow)
     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 
   /* Initialize my private state */
   master->pass_number = 0;
   master->using_merged_upsample = use_merged_upsample(cinfo);
 
   /* Color quantizer selection */
   master->quantizer_1pass = NULL;
   master->quantizer_2pass = NULL;
   /* No mode changes if not using buffered-image mode. */
   if (!cinfo->quantize_colors || !cinfo->buffered_image) {
     cinfo->enable_1pass_quant = FALSE;
     cinfo->enable_external_quant = FALSE;
     cinfo->enable_2pass_quant = FALSE;
   }
   if (cinfo->quantize_colors) {
     if (cinfo->raw_data_out)
       ERREXIT(cinfo, JERR_NOTIMPL);
     /* 2-pass quantizer only works in 3-component color space. */
     if (cinfo->out_color_components != 3 ||
         cinfo->out_color_space == JCS_RGB565) {
       cinfo->enable_1pass_quant = TRUE;
       cinfo->enable_external_quant = FALSE;
       cinfo->enable_2pass_quant = FALSE;
       cinfo->colormap = NULL;
     } else if (cinfo->colormap != NULL) {
       cinfo->enable_external_quant = TRUE;
     } else if (cinfo->two_pass_quantize) {
       cinfo->enable_2pass_quant = TRUE;
     } else {
       cinfo->enable_1pass_quant = TRUE;
     }
 
     if (cinfo->enable_1pass_quant) {
 #ifdef QUANT_1PASS_SUPPORTED
       if (cinfo->data_precision == 16)
-#ifdef D_LOSSLESS_SUPPORTED
-        j16init_1pass_quantizer(cinfo);
-#else
         ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
-#endif
       else if (cinfo->data_precision == 12)
         j12init_1pass_quantizer(cinfo);
       else
         jinit_1pass_quantizer(cinfo);
       master->quantizer_1pass = cinfo->cquantize;
 #else
       ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
     }
 
     /* We use the 2-pass code to map to external colormaps. */
     if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
 #ifdef QUANT_2PASS_SUPPORTED
       if (cinfo->data_precision == 16)
-#ifdef D_LOSSLESS_SUPPORTED
-        j16init_2pass_quantizer(cinfo);
-#else
         ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
-#endif
       else if (cinfo->data_precision == 12)
         j12init_2pass_quantizer(cinfo);
       else
         jinit_2pass_quantizer(cinfo);
       master->quantizer_2pass = cinfo->cquantize;
 #else
       ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
     }
     /* If both quantizers are initialized, the 2-pass one is left active;
      * this is necessary for starting with quantization to an external map.
      */
   }
 
   /* Post-processing: in particular, color conversion first */
   if (!cinfo->raw_data_out) {
     if (master->using_merged_upsample) {
 #ifdef UPSAMPLE_MERGING_SUPPORTED
       if (cinfo->data_precision == 16)
         ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
       else if (cinfo->data_precision == 12)
         j12init_merged_upsampler(cinfo); /* does color conversion too */
       else
         jinit_merged_upsampler(cinfo); /* does color conversion too */
 #else
       ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
     } else {
       if (cinfo->data_precision == 16) {
 #ifdef D_LOSSLESS_SUPPORTED
         j16init_color_deconverter(cinfo);
         j16init_upsampler(cinfo);
 #else
         ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 #endif
       } else if (cinfo->data_precision == 12) {
         j12init_color_deconverter(cinfo);
         j12init_upsampler(cinfo);
       } else {
         jinit_color_deconverter(cinfo);
         jinit_upsampler(cinfo);
       }
     }
     if (cinfo->data_precision == 16)
 #ifdef D_LOSSLESS_SUPPORTED
       j16init_d_post_controller(cinfo, cinfo->enable_2pass_quant);
 #else
       ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 #endif
     else if (cinfo->data_precision == 12)
       j12init_d_post_controller(cinfo, cinfo->enable_2pass_quant);
     else
       jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
   }
 
   if (cinfo->master->lossless) {
 #ifdef D_LOSSLESS_SUPPORTED
     /* Prediction, sample undifferencing, point transform, and sample size
      * scaling
      */
     if (cinfo->data_precision == 16)
       j16init_lossless_decompressor(cinfo);
     else if (cinfo->data_precision == 12)
       j12init_lossless_decompressor(cinfo);
     else
       jinit_lossless_decompressor(cinfo);
     /* Entropy decoding: either Huffman or arithmetic coding. */
     if (cinfo->arith_code) {
       ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
     } else {
       jinit_lhuff_decoder(cinfo);
     }
 
     /* Initialize principal buffer controllers. */
     use_c_buffer = cinfo->inputctl->has_multiple_scans ||
                    cinfo->buffered_image;
     if (cinfo->data_precision == 16)
       j16init_d_diff_controller(cinfo, use_c_buffer);
     else if (cinfo->data_precision == 12)
       j12init_d_diff_controller(cinfo, use_c_buffer);
     else
       jinit_d_diff_controller(cinfo, use_c_buffer);
 #else
     ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
   } else {
     if (cinfo->data_precision == 16)
       ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
     /* Inverse DCT */
     if (cinfo->data_precision == 12)
       j12init_inverse_dct(cinfo);
     else
       jinit_inverse_dct(cinfo);
     /* Entropy decoding: either Huffman or arithmetic coding. */
     if (cinfo->arith_code) {
 #ifdef D_ARITH_CODING_SUPPORTED
       jinit_arith_decoder(cinfo);
 #else
       ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
 #endif
     } else {
       if (cinfo->progressive_mode) {
 #ifdef D_PROGRESSIVE_SUPPORTED
         jinit_phuff_decoder(cinfo);
 #else
         ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
       } else
         jinit_huff_decoder(cinfo);
     }
 
     /* Initialize principal buffer controllers. */
     use_c_buffer = cinfo->inputctl->has_multiple_scans ||
                    cinfo->buffered_image;
     if (cinfo->data_precision == 12)
       j12init_d_coef_controller(cinfo, use_c_buffer);
     else
       jinit_d_coef_controller(cinfo, use_c_buffer);
   }
 
   if (!cinfo->raw_data_out) {
     if (cinfo->data_precision == 16)
 #ifdef D_LOSSLESS_SUPPORTED
       j16init_d_main_controller(cinfo,
                                 FALSE /* never need full buffer here */);
 #else
       ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 #endif
     else if (cinfo->data_precision == 12)
       j12init_d_main_controller(cinfo,
                                 FALSE /* never need full buffer here */);
     else
       jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
   }
 
   /* We can now tell the memory manager to allocate virtual arrays. */
   (*cinfo->mem->realize_virt_arrays) ((j_common_ptr)cinfo);
 
   /* Initialize input side of decompressor to consume first scan. */
   (*cinfo->inputctl->start_input_pass) (cinfo);
 
   /* Set the first and last iMCU columns to decompress from single-scan images.
    * By default, decompress all of the iMCU columns.
    */
   cinfo->master->first_iMCU_col = 0;
   cinfo->master->last_iMCU_col = cinfo->MCUs_per_row - 1;
   cinfo->master->last_good_iMCU_row = 0;
 
 #ifdef D_MULTISCAN_FILES_SUPPORTED
   /* If jpeg_start_decompress will read the whole file, initialize
    * progress monitoring appropriately.  The input step is counted
    * as one pass.
    */
   if (cinfo->progress != NULL && !cinfo->buffered_image &&
       cinfo->inputctl->has_multiple_scans) {
     int nscans;
     /* Estimate number of scans to set pass_limit. */
     if (cinfo->progressive_mode) {
       /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
       nscans = 2 + 3 * cinfo->num_components;
     } else {
       /* For a nonprogressive multiscan file, estimate 1 scan per component. */
       nscans = cinfo->num_components;
     }
     cinfo->progress->pass_counter = 0L;
     cinfo->progress->pass_limit = (long)cinfo->total_iMCU_rows * nscans;
     cinfo->progress->completed_passes = 0;
     cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
     /* Count the input pass as done */
     master->pass_number++;
   }
 #endif /* D_MULTISCAN_FILES_SUPPORTED */
 }
 
 
 /*
  * Per-pass setup.
  * This is called at the beginning of each output pass.  We determine which
  * modules will be active during this pass and give them appropriate
  * start_pass calls.  We also set is_dummy_pass to indicate whether this
  * is a "real" output pass or a dummy pass for color quantization.
  * (In the latter case, jdapistd.c will crank the pass to completion.)
  */
diff --git a/jdpostct.c b/jdpostct.c
index e8500748..d38495f5 100644
--- a/jdpostct.c
+++ b/jdpostct.c
@@ -1,30 +1,30 @@
 /*
  * jdpostct.c
  *
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2022, D. R. Commander.
+ * Copyright (C) 2022-2023, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
  * This file contains the decompression postprocessing controller.
  * This controller manages the upsampling, color conversion, and color
  * quantization/reduction steps; specifically, it controls the buffering
  * between upsample/color conversion and color quantization/reduction.
  *
  * If no color quantization/reduction is required, then this module has no
  * work to do, and it just hands off to the upsample/color conversion code.
  * An integrated upsample/convert/quantize process would replace this module
  * entirely.
  */
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jsamplecomp.h"
 
 
 #if BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)
 
 /* Private buffer controller object */
@@ -49,14 +49,16 @@ typedef my_post_controller *my_post_ptr;
 
 
 /* Forward declarations */
+#if BITS_IN_JSAMPLE != 16
 METHODDEF(void) post_process_1pass(j_decompress_ptr cinfo,
                                    _JSAMPIMAGE input_buf,
                                    JDIMENSION *in_row_group_ctr,
                                    JDIMENSION in_row_groups_avail,
                                    _JSAMPARRAY output_buf,
                                    JDIMENSION *out_row_ctr,
                                    JDIMENSION out_rows_avail);
-#ifdef QUANT_2PASS_SUPPORTED
+#endif
+#if defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16
 METHODDEF(void) post_process_prepass(j_decompress_ptr cinfo,
                                      _JSAMPIMAGE input_buf,
                                      JDIMENSION *in_row_group_ctr,
@@ -82,83 +84,90 @@ METHODDEF(void)
 start_pass_dpost(j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
 {
   my_post_ptr post = (my_post_ptr)cinfo->post;
 
   switch (pass_mode) {
   case JBUF_PASS_THRU:
+#if BITS_IN_JSAMPLE != 16
     if (cinfo->quantize_colors) {
       /* Single-pass processing with color quantization. */
       post->pub._post_process_data = post_process_1pass;
       /* We could be doing buffered-image output before starting a 2-pass
        * color quantization; in that case, jinit_d_post_controller did not
        * allocate a strip buffer.  Use the virtual-array buffer as workspace.
        */
       if (post->buffer == NULL) {
         post->buffer = (_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)
           ((j_common_ptr)cinfo, post->whole_image,
            (JDIMENSION)0, post->strip_height, TRUE);
       }
-    } else {
+    } else
+#endif
+    {
       /* For single-pass processing without color quantization,
        * I have no work to do; just call the upsampler directly.
        */
       post->pub._post_process_data = cinfo->upsample->_upsample;
     }
     break;
-#ifdef QUANT_2PASS_SUPPORTED
+#if defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16
   case JBUF_SAVE_AND_PASS:
     /* First pass of 2-pass quantization */
     if (post->whole_image == NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
     post->pub._post_process_data = post_process_prepass;
     break;
   case JBUF_CRANK_DEST:
     /* Second pass of 2-pass quantization */
     if (post->whole_image == NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
     post->pub._post_process_data = post_process_2pass;
     break;
-#endif /* QUANT_2PASS_SUPPORTED */
+#endif /* defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16 */
   default:
     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
     break;
   }
   post->starting_row = post->next_row = 0;
 }
 
 
 /*
  * Process some data in the one-pass (strip buffer) case.
  * This is used for color precision reduction as well as one-pass quantization.
  */
 
+#if BITS_IN_JSAMPLE != 16
+
 METHODDEF(void)
 post_process_1pass(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,
                    JDIMENSION *in_row_group_ctr,
                    JDIMENSION in_row_groups_avail, _JSAMPARRAY output_buf,
                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
 {
   my_post_ptr post = (my_post_ptr)cinfo->post;
   JDIMENSION num_rows, max_rows;
 
   /* Fill the buffer, but not more than what we can dump out in one go. */
   /* Note we rely on the upsampler to detect bottom of image. */
   max_rows = out_rows_avail - *out_row_ctr;
   if (max_rows > post->strip_height)
     max_rows = post->strip_height;
   num_rows = 0;
   (*cinfo->upsample->_upsample) (cinfo, input_buf, in_row_group_ctr,
                                  in_row_groups_avail, post->buffer, &num_rows,
                                  max_rows);
   /* Quantize and emit data. */
   (*cinfo->cquantize->_color_quantize) (cinfo, post->buffer,
                                         output_buf + *out_row_ctr,
                                         (int)num_rows);
   *out_row_ctr += num_rows;
 }
 
+#endif
 
-#ifdef QUANT_2PASS_SUPPORTED
+
+#if defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16
 
 /*
  * Process some data in the first pass of 2-pass quantization.
  */
@@ -210,45 +219,45 @@ METHODDEF(void)
 post_process_2pass(j_decompress_ptr cinfo, _JSAMPIMAGE input_buf,
                    JDIMENSION *in_row_group_ctr,
                    JDIMENSION in_row_groups_avail, _JSAMPARRAY output_buf,
                    JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)
 {
   my_post_ptr post = (my_post_ptr)cinfo->post;
   JDIMENSION num_rows, max_rows;
 
   /* Reposition virtual buffer if at start of strip. */
   if (post->next_row == 0) {
     post->buffer = (_JSAMPARRAY)(*cinfo->mem->access_virt_sarray)
         ((j_common_ptr)cinfo, post->whole_image,
          post->starting_row, post->strip_height, FALSE);
   }
 
   /* Determine number of rows to emit. */
   num_rows = post->strip_height - post->next_row; /* available in strip */
   max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
   if (num_rows > max_rows)
     num_rows = max_rows;
   /* We have to check bottom of image here, can't depend on upsampler. */
   max_rows = cinfo->output_height - post->starting_row;
   if (num_rows > max_rows)
     num_rows = max_rows;
 
   /* Quantize and emit data. */
   (*cinfo->cquantize->_color_quantize) (cinfo, post->buffer + post->next_row,
                                         output_buf + *out_row_ctr,
                                         (int)num_rows);
   *out_row_ctr += num_rows;
 
   /* Advance if we filled the strip. */
   post->next_row += num_rows;
   if (post->next_row >= post->strip_height) {
     post->starting_row += post->strip_height;
     post->next_row = 0;
   }
 }
 
-#endif /* QUANT_2PASS_SUPPORTED */
+#endif /* defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16 */
 
 
 /*
  * Initialize postprocessing controller.
  */
@@ -257,46 +266,50 @@ GLOBAL(void)
 _jinit_d_post_controller(j_decompress_ptr cinfo, boolean need_full_buffer)
 {
   my_post_ptr post;
 
   if (cinfo->data_precision != BITS_IN_JSAMPLE)
     ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 
   post = (my_post_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                 sizeof(my_post_controller));
   cinfo->post = (struct jpeg_d_post_controller *)post;
   post->pub.start_pass = start_pass_dpost;
   post->whole_image = NULL;     /* flag for no virtual arrays */
   post->buffer = NULL;          /* flag for no strip buffer */
 
   /* Create the quantization buffer, if needed */
   if (cinfo->quantize_colors) {
+#if BITS_IN_JSAMPLE != 16
     /* The buffer strip height is max_v_samp_factor, which is typically
      * an efficient number of rows for upsampling to return.
      * (In the presence of output rescaling, we might want to be smarter?)
      */
     post->strip_height = (JDIMENSION)cinfo->max_v_samp_factor;
     if (need_full_buffer) {
       /* Two-pass color quantization: need full-image storage. */
       /* We round up the number of rows to a multiple of the strip height. */
 #ifdef QUANT_2PASS_SUPPORTED
       post->whole_image = (*cinfo->mem->request_virt_sarray)
         ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,
          cinfo->output_width * cinfo->out_color_components,
          (JDIMENSION)jround_up((long)cinfo->output_height,
                                (long)post->strip_height),
          post->strip_height);
 #else
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 #endif /* QUANT_2PASS_SUPPORTED */
     } else {
       /* One-pass color quantization: just make a strip buffer. */
       post->buffer = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)
         ((j_common_ptr)cinfo, JPOOL_IMAGE,
          cinfo->output_width * cinfo->out_color_components,
          post->strip_height);
     }
+#else
+    ERREXIT(cinfo, JERR_NOTIMPL);
+#endif
   }
 }
 
 #endif /* BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED) */
diff --git a/jpegint.h b/jpegint.h
index 747b5464..65414201 100644
--- a/jpegint.h
+++ b/jpegint.h
@@ -427,47 +427,43 @@ struct jpeg_color_deconverter {
 /* Color quantization or color precision reduction */
 struct jpeg_color_quantizer {
   void (*start_pass) (j_decompress_ptr cinfo, boolean is_pre_scan);
   void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
                           JSAMPARRAY output_buf, int num_rows);
   void (*color_quantize_12) (j_decompress_ptr cinfo, J12SAMPARRAY input_buf,
                              J12SAMPARRAY output_buf, int num_rows);
-#ifdef D_LOSSLESS_SUPPORTED
-  void (*color_quantize_16) (j_decompress_ptr cinfo, J16SAMPARRAY input_buf,
-                             J16SAMPARRAY output_buf, int num_rows);
-#endif
   void (*finish_pass) (j_decompress_ptr cinfo);
   void (*new_color_map) (j_decompress_ptr cinfo);
 };
 
 
 /* Miscellaneous useful macros */
 
 #undef MAX
 #define MAX(a, b)       ((a) > (b) ? (a) : (b))
 #undef MIN
 #define MIN(a, b)       ((a) < (b) ? (a) : (b))
 
 
 /* We assume that right shift corresponds to signed division by 2 with
  * rounding towards minus infinity.  This is correct for typical "arithmetic
  * shift" instructions that shift in copies of the sign bit.  But some
  * C compilers implement >> with an unsigned shift.  For these machines you
  * must define RIGHT_SHIFT_IS_UNSIGNED.
  * RIGHT_SHIFT provides a proper signed right shift of a JLONG quantity.
  * It is only applied with constant shift counts.  SHIFT_TEMPS must be
  * included in the variables of any routine using RIGHT_SHIFT.
  */
 
 #ifdef RIGHT_SHIFT_IS_UNSIGNED
 #define SHIFT_TEMPS     JLONG shift_temp;
 #define RIGHT_SHIFT(x, shft) \
   ((shift_temp = (x)) < 0 ? \
    (shift_temp >> (shft)) | ((~((JLONG)0)) << (32 - (shft))) : \
    (shift_temp >> (shft)))
 #else
 #define SHIFT_TEMPS
 #define RIGHT_SHIFT(x, shft)    ((x) >> (shft))
 #endif
 
 
 /* Compression module initialization routines */
@@ -553,8 +549,6 @@ EXTERN(void) j16init_d_post_controller(j_decompress_ptr cinfo,
                                        boolean need_full_buffer);
 EXTERN(void) j16init_upsampler(j_decompress_ptr cinfo);
 EXTERN(void) j16init_color_deconverter(j_decompress_ptr cinfo);
-EXTERN(void) j16init_1pass_quantizer(j_decompress_ptr cinfo);
-EXTERN(void) j16init_2pass_quantizer(j_decompress_ptr cinfo);
 EXTERN(void) jinit_d_diff_controller(j_decompress_ptr cinfo,
                                      boolean need_full_buffer);
 EXTERN(void) j12init_d_diff_controller(j_decompress_ptr cinfo,
diff --git a/jquant1.c b/jquant1.c
index 67c1ae36..2e914b91 100644
--- a/jquant1.c
+++ b/jquant1.c
@@ -1,80 +1,79 @@
 /*
  * jquant1.c
  *
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2009, 2015, 2022, D. R. Commander.
+ * Copyright (C) 2009, 2015, 2022-2023, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
  * This file contains 1-pass color quantization (color mapping) routines.
  * These routines provide mapping to a fixed color map using equally spaced
  * color values.  Optional Floyd-Steinberg or ordered dithering is available.
  */
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jsamplecomp.h"
 
-#if defined(QUANT_1PASS_SUPPORTED) && \
-    (BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED))
+#if defined(QUANT_1PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16
 
 
 /*
  * The main purpose of 1-pass quantization is to provide a fast, if not very
  * high quality, colormapped output capability.  A 2-pass quantizer usually
  * gives better visual quality; however, for quantized grayscale output this
  * quantizer is perfectly adequate.  Dithering is highly recommended with this
  * quantizer, though you can turn it off if you really want to.
  *
  * In 1-pass quantization the colormap must be chosen in advance of seeing the
  * image.  We use a map consisting of all combinations of Ncolors[i] color
  * values for the i'th component.  The Ncolors[] values are chosen so that
  * their product, the total number of colors, is no more than that requested.
  * (In most cases, the product will be somewhat less.)
  *
  * Since the colormap is orthogonal, the representative value for each color
  * component can be determined without considering the other components;
  * then these indexes can be combined into a colormap index by a standard
  * N-dimensional-array-subscript calculation.  Most of the arithmetic involved
  * can be precalculated and stored in the lookup table colorindex[].
  * colorindex[i][j] maps pixel value j in component i to the nearest
  * representative value (grid plane) for that component; this index is
  * multiplied by the array stride for component i, so that the
  * index of the colormap entry closest to a given pixel value is just
  *    sum( colorindex[component-number][pixel-component-value] )
  * Aside from being fast, this scheme allows for variable spacing between
  * representative values with no additional lookup cost.
  *
  * If gamma correction has been applied in color conversion, it might be wise
  * to adjust the color grid spacing so that the representative colors are
  * equidistant in linear space.  At this writing, gamma correction is not
  * implemented by jdcolor, so nothing is done here.
  */
 
 
 /* Declarations for ordered dithering.
  *
  * We use a standard 16x16 ordered dither array.  The basic concept of ordered
  * dithering is described in many references, for instance Dale Schumacher's
  * chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
  * In place of Schumacher's comparisons against a "threshold" value, we add a
  * "dither" value to the input pixel and then round the result to the nearest
  * output value.  The dither value is equivalent to (0.5 - threshold) times
  * the distance between output values.  For ordered dithering, we assume that
  * the output colors are equally spaced; if not, results will probably be
  * worse, since the dither may be too much or too little at a given point.
  *
  * The normal calculation would be to form pixel value + dither, range-limit
  * this to 0.._MAXJSAMPLE, and then index into the colorindex table as usual.
  * We can skip the separate range-limiting step by extending the colorindex
  * table in both directions.
  */
 
 #define ODITHER_SIZE  16        /* dimension of dither matrix */
 /* NB: if ODITHER_SIZE is not a power of 2, ODITHER_MASK uses will break */
 #define ODITHER_CELLS  (ODITHER_SIZE * ODITHER_SIZE) /* # cells in matrix */
 #define ODITHER_MASK  (ODITHER_SIZE - 1) /* mask for wrapping around
                                             counters */
@@ -823,40 +822,43 @@ GLOBAL(void)
 _jinit_1pass_quantizer(j_decompress_ptr cinfo)
 {
   my_cquantize_ptr cquantize;
 
   if (cinfo->data_precision != BITS_IN_JSAMPLE)
     ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 
+  /* Color quantization is not supported with lossless JPEG images */
+  if (cinfo->master->lossless)
+    ERREXIT(cinfo, JERR_NOTIMPL);
+
   cquantize = (my_cquantize_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                 sizeof(my_cquantizer));
   cinfo->cquantize = (struct jpeg_color_quantizer *)cquantize;
   cquantize->pub.start_pass = start_pass_1_quant;
   cquantize->pub.finish_pass = finish_pass_1_quant;
   cquantize->pub.new_color_map = new_color_map_1_quant;
   cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
   cquantize->odither[0] = NULL; /* Also flag odither arrays not allocated */
 
   /* Make sure my internal arrays won't overflow */
   if (cinfo->out_color_components > MAX_Q_COMPS)
     ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
   /* Make sure colormap indexes can be represented by _JSAMPLEs */
   if (cinfo->desired_number_of_colors > (_MAXJSAMPLE + 1))
     ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, _MAXJSAMPLE + 1);
 
   /* Create the colormap and color index table. */
   create_colormap(cinfo);
   create_colorindex(cinfo);
 
   /* Allocate Floyd-Steinberg workspace now if requested.
    * We do this now since it may affect the memory manager's space
    * calculations.  If the user changes to FS dither mode in a later pass, we
    * will allocate the space then, and will possibly overrun the
    * max_memory_to_use setting.
    */
   if (cinfo->dither_mode == JDITHER_FS)
     alloc_fs_workspace(cinfo);
 }
 
-#endif /* defined(QUANT_1PASS_SUPPORTED) &&
-          (BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)) */
+#endif /* defined(QUANT_1PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16 */
diff --git a/jquant2.c b/jquant2.c
index 5984ed8c..9ba51fa8 100644
--- a/jquant2.c
+++ b/jquant2.c
@@ -1,80 +1,79 @@
 /*
  * jquant2.c
  *
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * libjpeg-turbo Modifications:
  * Copyright (C) 2009, 2014-2015, 2020, 2022-2023, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
  * This file contains 2-pass color quantization (color mapping) routines.
  * These routines provide selection of a custom color map for an image,
  * followed by mapping of the image to that color map, with optional
  * Floyd-Steinberg dithering.
  * It is also possible to use just the second pass to map to an arbitrary
  * externally-given color map.
  *
  * Note: ordered dithering is not supported, since there isn't any fast
  * way to compute intercolor distances; it's unclear that ordered dither's
  * fundamental assumptions even hold with an irregularly spaced color map.
  */
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
 #include "jpeglib.h"
 #include "jsamplecomp.h"
 
-#if defined(QUANT_2PASS_SUPPORTED) && \
-    (BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED))
+#if defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16
 
 
 /*
  * This module implements the well-known Heckbert paradigm for color
  * quantization.  Most of the ideas used here can be traced back to
  * Heckbert's seminal paper
  *   Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",
  *   Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
  *
  * In the first pass over the image, we accumulate a histogram showing the
  * usage count of each possible color.  To keep the histogram to a reasonable
  * size, we reduce the precision of the input; typical practice is to retain
  * 5 or 6 bits per color, so that 8 or 4 different input values are counted
  * in the same histogram cell.
  *
  * Next, the color-selection step begins with a box representing the whole
  * color space, and repeatedly splits the "largest" remaining box until we
  * have as many boxes as desired colors.  Then the mean color in each
  * remaining box becomes one of the possible output colors.
  *
  * The second pass over the image maps each input pixel to the closest output
  * color (optionally after applying a Floyd-Steinberg dithering correction).
  * This mapping is logically trivial, but making it go fast enough requires
  * considerable care.
  *
  * Heckbert-style quantizers vary a good deal in their policies for choosing
  * the "largest" box and deciding where to cut it.  The particular policies
  * used here have proved out well in experimental comparisons, but better ones
  * may yet be found.
  *
  * In earlier versions of the IJG code, this module quantized in YCbCr color
  * space, processing the raw upsampled data without a color conversion step.
  * This allowed the color conversion math to be done only once per colormap
  * entry, not once per pixel.  However, that optimization precluded other
  * useful optimizations (such as merging color conversion with upsampling)
  * and it also interfered with desired capabilities such as quantizing to an
  * externally-supplied colormap.  We have therefore abandoned that approach.
  * The present code works in the post-conversion color space, typically RGB.
  *
  * To improve the visual quality of the results, we actually work in scaled
  * RGB space, giving G distances more weight than R, and R in turn more than
  * B.  To do everything in integer math, we must use integer scale factors.
  * The 2/3/1 scale factors used here correspond loosely to the relative
  * weights of the colors in the NTSC grayscale equation.
  * If you want to use this code to quantize a non-RGB color space, you'll
  * probably need to change these scale factors.
  */
 
 #define R_SCALE  2              /* scale R distances by this much */
 #define G_SCALE  3              /* scale G distances by this much */
 #define B_SCALE  1              /* and B by this much */
@@ -1223,73 +1222,72 @@ GLOBAL(void)
 _jinit_2pass_quantizer(j_decompress_ptr cinfo)
 {
   my_cquantize_ptr cquantize;
   int i;
 
   if (cinfo->data_precision != BITS_IN_JSAMPLE)
     ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 
   cquantize = (my_cquantize_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                 sizeof(my_cquantizer));
   cinfo->cquantize = (struct jpeg_color_quantizer *)cquantize;
   cquantize->pub.start_pass = start_pass_2_quant;
   cquantize->pub.new_color_map = new_color_map_2_quant;
   cquantize->fserrors = NULL;   /* flag optional arrays not allocated */
   cquantize->error_limiter = NULL;
 
   /* Make sure jdmaster didn't give me a case I can't handle */
   if (cinfo->out_color_components != 3 ||
-      cinfo->out_color_space == JCS_RGB565)
+      cinfo->out_color_space == JCS_RGB565 || cinfo->master->lossless)
     ERREXIT(cinfo, JERR_NOTIMPL);
 
   /* Allocate the histogram/inverse colormap storage */
   cquantize->histogram = (hist3d)(*cinfo->mem->alloc_small)
     ((j_common_ptr)cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * sizeof(hist2d));
   for (i = 0; i < HIST_C0_ELEMS; i++) {
     cquantize->histogram[i] = (hist2d)(*cinfo->mem->alloc_large)
       ((j_common_ptr)cinfo, JPOOL_IMAGE,
        HIST_C1_ELEMS * HIST_C2_ELEMS * sizeof(histcell));
   }
   cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
 
   /* Allocate storage for the completed colormap, if required.
    * We do this now since it may affect the memory manager's space
    * calculations.
    */
   if (cinfo->enable_2pass_quant) {
     /* Make sure color count is acceptable */
     int desired = cinfo->desired_number_of_colors;
     /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
     if (desired < 8)
       ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
     /* Make sure colormap indexes can be represented by _JSAMPLEs */
     if (desired > MAXNUMCOLORS)
       ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
     cquantize->sv_colormap = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)
       ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)desired, (JDIMENSION)3);
     cquantize->desired = desired;
   } else
     cquantize->sv_colormap = NULL;
 
   /* Only F-S dithering or no dithering is supported. */
   /* If user asks for ordered dither, give them F-S. */
   if (cinfo->dither_mode != JDITHER_NONE)
     cinfo->dither_mode = JDITHER_FS;
 
   /* Allocate Floyd-Steinberg workspace if necessary.
    * This isn't really needed until pass 2, but again it may affect the memory
    * manager's space calculations.  Although we will cope with a later change
    * in dither_mode, we do not promise to honor max_memory_to_use if
    * dither_mode changes.
    */
   if (cinfo->dither_mode == JDITHER_FS) {
     cquantize->fserrors = (FSERRPTR)(*cinfo->mem->alloc_large)
       ((j_common_ptr)cinfo, JPOOL_IMAGE,
        (size_t)((cinfo->output_width + 2) * (3 * sizeof(FSERROR))));
     /* Might as well create the error-limiting table too. */
     init_error_limit(cinfo);
   }
 }
 
-#endif /* defined(QUANT_2PASS_SUPPORTED) &&
-          (BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)) */
+#endif /* defined(QUANT_2PASS_SUPPORTED) && BITS_IN_JSAMPLE != 16 */
diff --git a/jsamplecomp.h b/jsamplecomp.h
index 6594480f..f3f275e6 100644
--- a/jsamplecomp.h
+++ b/jsamplecomp.h
@@ -1,343 +1,336 @@
 /*
  * jsamplecomp.h
  *
  * Copyright (C) 2022, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  */
 
 /* In source files that must be compiled for multiple data precisions, we
  * prefix all precision-dependent data types, macros, methods, fields, and
  * function names with an underscore.  Including this file replaces those
  * precision-independent tokens with their precision-dependent equivalents,
  * based on the value of BITS_IN_JSAMPLE.
  */
 
 #ifndef JSAMPLECOMP_H
 #define JSAMPLECOMP_H
 
 #if BITS_IN_JSAMPLE == 16
 
 /* Sample data types and macros (jmorecfg.h) */
 #define _JSAMPLE  J16SAMPLE
 
 #define _MAXJSAMPLE  MAXJ16SAMPLE
 #define _CENTERJSAMPLE   CENTERJ16SAMPLE
 
 #define _JSAMPROW  J16SAMPROW
 #define _JSAMPARRAY  J16SAMPARRAY
 #define _JSAMPIMAGE  J16SAMPIMAGE
 
 /* External functions (jpeglib.h) */
 #define _jpeg_write_scanlines  jpeg16_write_scanlines
 #define _jpeg_read_scanlines  jpeg16_read_scanlines
 
 /* Internal methods (jpegint.h) */
 
 #ifdef C_LOSSLESS_SUPPORTED
 /* Use the 16-bit method in the jpeg_c_main_controller structure. */
 #define _process_data  process_data_16
 /* Use the 16-bit method in the jpeg_c_prep_controller structure. */
 #define _pre_process_data  pre_process_data_16
 /* Use the 16-bit method in the jpeg_c_coef_controller structure. */
 #define _compress_data  compress_data_16
 /* Use the 16-bit method in the jpeg_color_converter structure. */
 #define _color_convert  color_convert_16
 /* Use the 16-bit method in the jpeg_downsampler structure. */
 #define _downsample  downsample_16
 #endif
 #ifdef D_LOSSLESS_SUPPORTED
 /* Use the 16-bit method in the jpeg_d_main_controller structure. */
 #define _process_data  process_data_16
 /* Use the 16-bit method in the jpeg_d_coef_controller structure. */
 #define _decompress_data  decompress_data_16
 /* Use the 16-bit method in the jpeg_d_post_controller structure. */
 #define _post_process_data  post_process_data_16
 /* Use the 16-bit method in the jpeg_upsampler structure. */
 #define _upsample  upsample_16
 /* Use the 16-bit method in the jpeg_color_converter structure. */
 #define _color_convert  color_convert_16
-/* Use the 16-bit method in the jpeg_color_quantizer structure. */
-#define _color_quantize  color_quantize_16
 #endif
 
 /* Global internal functions (jpegint.h) */
 #ifdef C_LOSSLESS_SUPPORTED
 #define _jinit_c_main_controller  j16init_c_main_controller
 #define _jinit_c_prep_controller  j16init_c_prep_controller
 #define _jinit_color_converter  j16init_color_converter
 #define _jinit_downsampler  j16init_downsampler
 #define _jinit_c_diff_controller  j16init_c_diff_controller
 #define _jinit_lossless_compressor  j16init_lossless_compressor
 #endif
 
 #ifdef D_LOSSLESS_SUPPORTED
 #define _jinit_d_main_controller  j16init_d_main_controller
 #define _jinit_d_post_controller  j16init_d_post_controller
 #define _jinit_upsampler  j16init_upsampler
 #define _jinit_color_deconverter  j16init_color_deconverter
-#define _jinit_1pass_quantizer  j16init_1pass_quantizer
-#define _jinit_2pass_quantizer  j16init_2pass_quantizer
 #define _jinit_merged_upsampler  j16init_merged_upsampler
 #define _jinit_d_diff_controller  j16init_d_diff_controller
 #define _jinit_lossless_decompressor  j16init_lossless_decompressor
 #endif
 
 #if defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)
 #define _jcopy_sample_rows  j16copy_sample_rows
 #endif
 
 /* Internal fields (cdjpeg.h) */
 
 #if defined(C_LOSSLESS_SUPPORTED) || defined(D_LOSSLESS_SUPPORTED)
 /* Use the 16-bit buffer in the cjpeg_source_struct and djpeg_dest_struct
    structures. */
 #define _buffer  buffer16
 #endif
 
 /* Image I/O functions (cdjpeg.h) */
 #ifdef C_LOSSLESS_SUPPORTED
 #define _jinit_read_gif  j16init_read_gif
 #define _jinit_read_ppm  j16init_read_ppm
 #endif
 
 #ifdef D_LOSSLESS_SUPPORTED
-#define _jinit_write_gif  j16init_write_gif
 #define _jinit_write_ppm  j16init_write_ppm
-
-#define _read_color_map  read_color_map_16
 #endif
 
 #elif BITS_IN_JSAMPLE == 12
 
 /* Sample data types and macros (jmorecfg.h) */
 #define _JSAMPLE  J12SAMPLE
 
 #define _MAXJSAMPLE  MAXJ12SAMPLE
 #define _CENTERJSAMPLE   CENTERJ12SAMPLE
 
 #define _JSAMPROW  J12SAMPROW
 #define _JSAMPARRAY  J12SAMPARRAY
 #define _JSAMPIMAGE  J12SAMPIMAGE
 
 /* External functions (jpeglib.h) */
 #define _jpeg_write_scanlines  jpeg12_write_scanlines
 #define _jpeg_write_raw_data  jpeg12_write_raw_data
 #define _jpeg_read_scanlines  jpeg12_read_scanlines
 #define _jpeg_skip_scanlines  jpeg12_skip_scanlines
 #define _jpeg_crop_scanline  jpeg12_crop_scanline
 #define _jpeg_read_raw_data  jpeg12_read_raw_data
 
 /* Internal methods (jpegint.h) */
 
 /* Use the 12-bit method in the jpeg_c_main_controller structure. */
 #define _process_data  process_data_12
 /* Use the 12-bit method in the jpeg_c_prep_controller structure. */
 #define _pre_process_data  pre_process_data_12
 /* Use the 12-bit method in the jpeg_c_coef_controller structure. */
 #define _compress_data  compress_data_12
 /* Use the 12-bit method in the jpeg_color_converter structure. */
 #define _color_convert  color_convert_12
 /* Use the 12-bit method in the jpeg_downsampler structure. */
 #define _downsample  downsample_12
 /* Use the 12-bit method in the jpeg_forward_dct structure. */
 #define _forward_DCT  forward_DCT_12
 /* Use the 12-bit method in the jpeg_d_main_controller structure. */
 #define _process_data  process_data_12
 /* Use the 12-bit method in the jpeg_d_coef_controller structure. */
 #define _decompress_data  decompress_data_12
 /* Use the 12-bit method in the jpeg_d_post_controller structure. */
 #define _post_process_data  post_process_data_12
 /* Use the 12-bit method in the jpeg_inverse_dct structure. */
 #define _inverse_DCT_method_ptr  inverse_DCT_12_method_ptr
 #define _inverse_DCT  inverse_DCT_12
 /* Use the 12-bit method in the jpeg_upsampler structure. */
 #define _upsample  upsample_12
 /* Use the 12-bit method in the jpeg_color_converter structure. */
 #define _color_convert  color_convert_12
 /* Use the 12-bit method in the jpeg_color_quantizer structure. */
 #define _color_quantize  color_quantize_12
 
 /* Global internal functions (jpegint.h) */
 #define _jinit_c_main_controller  j12init_c_main_controller
 #define _jinit_c_prep_controller  j12init_c_prep_controller
 #define _jinit_c_coef_controller  j12init_c_coef_controller
 #define _jinit_color_converter  j12init_color_converter
 #define _jinit_downsampler  j12init_downsampler
 #define _jinit_forward_dct  j12init_forward_dct
 #ifdef C_LOSSLESS_SUPPORTED
 #define _jinit_c_diff_controller  j12init_c_diff_controller
 #define _jinit_lossless_compressor  j12init_lossless_compressor
 #endif
 
 #define _jinit_d_main_controller  j12init_d_main_controller
 #define _jinit_d_coef_controller  j12init_d_coef_controller
 #define _jinit_d_post_controller  j12init_d_post_controller
 #define _jinit_inverse_dct  j12init_inverse_dct
 #define _jinit_upsampler  j12init_upsampler
 #define _jinit_color_deconverter  j12init_color_deconverter
 #define _jinit_1pass_quantizer  j12init_1pass_quantizer
 #define _jinit_2pass_quantizer  j12init_2pass_quantizer
 #define _jinit_merged_upsampler  j12init_merged_upsampler
 #ifdef D_LOSSLESS_SUPPORTED
 #define _jinit_d_diff_controller  j12init_d_diff_controller
 #define _jinit_lossless_decompressor  j12init_lossless_decompressor
 #endif
 
 #define _jcopy_sample_rows  j12copy_sample_rows
 
 /* Global internal functions (jdct.h) */
 #define _jpeg_fdct_islow  jpeg12_fdct_islow
 #define _jpeg_fdct_ifast  jpeg12_fdct_ifast
 
 #define _jpeg_idct_islow  jpeg12_idct_islow
 #define _jpeg_idct_ifast  jpeg12_idct_ifast
 #define _jpeg_idct_float  jpeg12_idct_float
 #define _jpeg_idct_7x7  jpeg12_idct_7x7
 #define _jpeg_idct_6x6  jpeg12_idct_6x6
 #define _jpeg_idct_5x5  jpeg12_idct_5x5
 #define _jpeg_idct_4x4  jpeg12_idct_4x4
 #define _jpeg_idct_3x3  jpeg12_idct_3x3
 #define _jpeg_idct_2x2  jpeg12_idct_2x2
 #define _jpeg_idct_1x1  jpeg12_idct_1x1
 #define _jpeg_idct_9x9  jpeg12_idct_9x9
 #define _jpeg_idct_10x10  jpeg12_idct_10x10
 #define _jpeg_idct_11x11  jpeg12_idct_11x11
 #define _jpeg_idct_12x12  jpeg12_idct_12x12
 #define _jpeg_idct_13x13  jpeg12_idct_13x13
 #define _jpeg_idct_14x14  jpeg12_idct_14x14
 #define _jpeg_idct_15x15  jpeg12_idct_15x15
 #define _jpeg_idct_16x16  jpeg12_idct_16x16
 
 /* Internal fields (cdjpeg.h) */
 
 /* Use the 12-bit buffer in the cjpeg_source_struct and djpeg_dest_struct
    structures. */
 #define _buffer  buffer12
 
 /* Image I/O functions (cdjpeg.h) */
 #define _jinit_read_gif  j12init_read_gif
 #define _jinit_write_gif  j12init_write_gif
 #define _jinit_read_ppm  j12init_read_ppm
 #define _jinit_write_ppm  j12init_write_ppm
 
 #define _read_color_map  read_color_map_12
 
 #else /* BITS_IN_JSAMPLE */
 
 /* Sample data types and macros (jmorecfg.h) */
 #define _JSAMPLE  JSAMPLE
 
 #define _MAXJSAMPLE  MAXJSAMPLE
 #define _CENTERJSAMPLE   CENTERJSAMPLE
 
 #define _JSAMPROW  JSAMPROW
 #define _JSAMPARRAY  JSAMPARRAY
 #define _JSAMPIMAGE  JSAMPIMAGE
 
 /* External functions (jpeglib.h) */
 #define _jpeg_write_scanlines  jpeg_write_scanlines
 #define _jpeg_write_raw_data  jpeg_write_raw_data
 #define _jpeg_read_scanlines  jpeg_read_scanlines
 #define _jpeg_skip_scanlines  jpeg_skip_scanlines
 #define _jpeg_crop_scanline  jpeg_crop_scanline
 #define _jpeg_read_raw_data  jpeg_read_raw_data
 
 /* Internal methods (jpegint.h) */
 
 /* Use the 8-bit method in the jpeg_c_main_controller structure. */
 #define _process_data  process_data
 /* Use the 8-bit method in the jpeg_c_prep_controller structure. */
 #define _pre_process_data  pre_process_data
 /* Use the 8-bit method in the jpeg_c_coef_controller structure. */
 #define _compress_data  compress_data
 /* Use the 8-bit method in the jpeg_color_converter structure. */
 #define _color_convert  color_convert
 /* Use the 8-bit method in the jpeg_downsampler structure. */
 #define _downsample  downsample
 /* Use the 8-bit method in the jpeg_forward_dct structure. */
 #define _forward_DCT  forward_DCT
 /* Use the 8-bit method in the jpeg_d_main_controller structure. */
 #define _process_data  process_data
 /* Use the 8-bit method in the jpeg_d_coef_controller structure. */
 #define _decompress_data  decompress_data
 /* Use the 8-bit method in the jpeg_d_post_controller structure. */
 #define _post_process_data  post_process_data
 /* Use the 8-bit method in the jpeg_inverse_dct structure. */
 #define _inverse_DCT_method_ptr  inverse_DCT_method_ptr
 #define _inverse_DCT  inverse_DCT
 /* Use the 8-bit method in the jpeg_upsampler structure. */
 #define _upsample  upsample
 /* Use the 8-bit method in the jpeg_color_converter structure. */
 #define _color_convert  color_convert
 /* Use the 8-bit method in the jpeg_color_quantizer structure. */
 #define _color_quantize  color_quantize
 
 /* Global internal functions (jpegint.h) */
 #define _jinit_c_main_controller  jinit_c_main_controller
 #define _jinit_c_prep_controller  jinit_c_prep_controller
 #define _jinit_c_coef_controller  jinit_c_coef_controller
 #define _jinit_color_converter  jinit_color_converter
 #define _jinit_downsampler  jinit_downsampler
 #define _jinit_forward_dct  jinit_forward_dct
 #ifdef C_LOSSLESS_SUPPORTED
 #define _jinit_c_diff_controller  jinit_c_diff_controller
 #define _jinit_lossless_compressor  jinit_lossless_compressor
 #endif
 
 #define _jinit_d_main_controller  jinit_d_main_controller
 #define _jinit_d_coef_controller  jinit_d_coef_controller
 #define _jinit_d_post_controller  jinit_d_post_controller
 #define _jinit_inverse_dct  jinit_inverse_dct
 #define _jinit_upsampler  jinit_upsampler
 #define _jinit_color_deconverter  jinit_color_deconverter
 #define _jinit_1pass_quantizer  jinit_1pass_quantizer
 #define _jinit_2pass_quantizer  jinit_2pass_quantizer
 #define _jinit_merged_upsampler  jinit_merged_upsampler
 #ifdef D_LOSSLESS_SUPPORTED
 #define _jinit_d_diff_controller  jinit_d_diff_controller
 #define _jinit_lossless_decompressor  jinit_lossless_decompressor
 #endif
 
 #define _jcopy_sample_rows  jcopy_sample_rows
 
 /* Global internal functions (jdct.h) */
 #define _jpeg_fdct_islow  jpeg_fdct_islow
 #define _jpeg_fdct_ifast  jpeg_fdct_ifast
 
 #define _jpeg_idct_islow  jpeg_idct_islow
 #define _jpeg_idct_ifast  jpeg_idct_ifast
 #define _jpeg_idct_float  jpeg_idct_float
 #define _jpeg_idct_7x7  jpeg_idct_7x7
 #define _jpeg_idct_6x6  jpeg_idct_6x6
 #define _jpeg_idct_5x5  jpeg_idct_5x5
 #define _jpeg_idct_4x4  jpeg_idct_4x4
 #define _jpeg_idct_3x3  jpeg_idct_3x3
 #define _jpeg_idct_2x2  jpeg_idct_2x2
 #define _jpeg_idct_1x1  jpeg_idct_1x1
 #define _jpeg_idct_9x9  jpeg_idct_9x9
 #define _jpeg_idct_10x10  jpeg_idct_10x10
 #define _jpeg_idct_11x11  jpeg_idct_11x11
 #define _jpeg_idct_12x12  jpeg_idct_12x12
 #define _jpeg_idct_13x13  jpeg_idct_13x13
 #define _jpeg_idct_14x14  jpeg_idct_14x14
 #define _jpeg_idct_15x15  jpeg_idct_15x15
 #define _jpeg_idct_16x16  jpeg_idct_16x16
 
 /* Internal fields (cdjpeg.h) */
 
 /* Use the 8-bit buffer in the cjpeg_source_struct and djpeg_dest_struct
    structures. */
 #define _buffer  buffer
 
 /* Image I/O functions (cdjpeg.h) */
 #define _jinit_read_gif  jinit_read_gif
 #define _jinit_write_gif  jinit_write_gif
 #define _jinit_read_ppm  jinit_read_ppm
 #define _jinit_write_ppm  jinit_write_ppm
 
 #define _read_color_map  read_color_map
 
 #endif /* BITS_IN_JSAMPLE */
 
 #endif /* JSAMPLECOMP_H */
diff --git a/libjpeg.txt b/libjpeg.txt
index a695f6d0..2dae2d20 100644
--- a/libjpeg.txt
+++ b/libjpeg.txt
@@ -5,7 +5,7 @@ Copyright (C) 1994-2013, Thomas G. Lane, Guido Vollbeding.
 Lossless JPEG Modifications:
 Copyright (C) 1999, Ken Murchison.
 libjpeg-turbo Modifications:
-Copyright (C) 2010, 2014-2018, 2020, 2022, D. R. Commander.
+Copyright (C) 2010, 2014-2018, 2020, 2022-2023, D. R. Commander.
 Copyright (C) 2015, Google, Inc.
 For conditions of distribution and use, see the accompanying README.ijg file.
 
@@ -120,8 +120,8 @@ supports 12-bit-per-component lossy or lossless JPEG if you set
 cinfo->data_precision to 12 and 16-bit-per-component lossless JPEG if you set
 cinfo->data_precision to 16.  Note that this causes the sample size to be
 larger than a char, so it affects the surrounding application's image data.
-The sample applications cjpeg and djpeg can support 12-bit and 16-bit mode only
-for PPM and GIF file formats.
+The sample applications cjpeg and djpeg can support 12-bit mode only for PPM,
+PGM, and GIF file formats and 16-bit mode only for PPM and PGM file formats.
 
 Note that, when 12-bit data precision is enabled, the library always compresses
 in Huffman optimization mode, in order to generate valid Huffman tables.  This
@@ -1023,22 +1023,23 @@ jpeg_simple_progression (j_compress_ptr cinfo)
 jpeg_enable_lossless (j_compress_ptr cinfo, int predictor_selection_value,
                       int point_transform)
         Enables lossless mode with the specified predictor selection value
         (1 - 7) and optional point transform (0 - {precision}-1, where
         {precision} is the JPEG data precision).  A point transform value of 0
         is necessary in order to create a fully lossless JPEG image.  (A
         non-zero point transform value right-shifts the input samples by the
         specified number of bits, which is effectively a form of lossy color
         quantization.)  Note that the following features will be unavailable
         when compressing or decompressing lossless JPEG images:
           * Partial image decompression
           * Quality/quantization table selection
           * DCT/IDCT algorithm selection
           * Smoothing
           * Downsampling/upsampling
           * Color space conversion (the JPEG image will use the same color
             space as the input image)
+          * Color quantization
           * IDCT scaling
           * Raw (downsampled) data input/output
           * Transcoding of DCT coefficients
         Any parameters used to enable or configure those features will be
         ignored.
diff --git a/sharedlib/CMakeLists.txt b/sharedlib/CMakeLists.txt
index 58923057..8e942569 100644
--- a/sharedlib/CMakeLists.txt
+++ b/sharedlib/CMakeLists.txt
@@ -87,9 +87,9 @@ target_link_libraries(cjpeg jpeg)
 add_library(djpeg12 OBJECT ../rdcolmap.c ../wrgif.c ../wrppm.c)
 set_property(TARGET djpeg12 PROPERTY COMPILE_FLAGS
   "-DBITS_IN_JSAMPLE=12 -DGIF_SUPPORTED -DPPM_SUPPORTED")
-add_library(djpeg16 OBJECT ../rdcolmap.c ../wrgif.c ../wrppm.c)
+add_library(djpeg16 OBJECT ../wrppm.c)
 set_property(TARGET djpeg16 PROPERTY COMPILE_FLAGS
-  "-DBITS_IN_JSAMPLE=16 -DGIF_SUPPORTED -DPPM_SUPPORTED")
+  "-DBITS_IN_JSAMPLE=16 -DPPM_SUPPORTED")
 add_executable(djpeg ../djpeg.c ../cdjpeg.c ../rdcolmap.c ../rdswitch.c
   ../wrbmp.c ../wrgif.c ../wrppm.c ../wrtarga.c $<TARGET_OBJECTS:djpeg12>
   $<TARGET_OBJECTS:djpeg16>)
diff --git a/structure.txt b/structure.txt
index c0c6d8e4..030b8e88 100644
--- a/structure.txt
+++ b/structure.txt
@@ -5,7 +5,7 @@ Copyright (C) 1991-2012, Thomas G. Lane, Guido Vollbeding.
 Lossless JPEG Modifications:
 Copyright (C) 1999, Ken Murchison.
 libjpeg-turbo Modifications:
-Copyright (C) 2022, D. R. Commander.
+Copyright (C) 2022-2023, D. R. Commander.
 For conditions of distribution and use, see the accompanying README.ijg file.
 
 
@@ -437,14 +437,13 @@ Main controller --|
                                               |-- Lossless mode entropy
                                               |   decoding
                                               |
                   |-- Difference controller --|-- Prediction, undifferencing
                   |                           |
                   |                           |-- Point transform, sample size
                   |                               scaling
 Main controller --|
                   |                               |-- Upsampling
-                  |-- Postprocessing controller --|   |-- Colorspace conversion
-                                                  |-- Color quantization
+                  |-- Postprocessing controller --|
                                                   |-- Color precision reduction
 
 As before, this diagram also represents typical control flow.  The objects
diff --git a/usage.txt b/usage.txt
index ddd0d1f5..c1bba4ae 100644
--- a/usage.txt
+++ b/usage.txt
@@ -161,94 +161,95 @@ file size is about the same --- often a little smaller.
 Switches for advanced users:
 
         -precision N   Create JPEG file with N-bit data precision.
                        N is 8, 12, or 16; default is 8.  If N is 16, then
                        -lossless must also be specified.  CAUTION: 12-bit and
                        16-bit JPEG is not yet widely implemented, so many
                        decoders will be unable to view a 12-bit or 16-bit JPEG
                        file at all.
 
         -lossless psv[,Pt] Create a lossless JPEG file using the specified
                         predictor selection value (1 - 7) and optional point
                         transform (0 - {precision}-1, where {precision} is the
                         JPEG data precision in bits).  A point transform value
                         of 0 (the default) is necessary in order to create a
                         fully lossless JPEG file.  (A non-zero point transform
                         value right-shifts the input samples by the specified
                         number of bits, which is effectively a form of lossy
                         color quantization.)  CAUTION: lossless JPEG is not yet
                         widely implemented, so many decoders will be unable to
                         view a lossless JPEG file at all.  Note that the
                         following features will be unavailable when compressing
                         or decompressing a lossless JPEG file:
                           * Quality/quantization table selection
                           * Color space conversion (the JPEG image will use the
                             same color space as the input image)
+                          * Color quantization
                           * DCT/IDCT algorithm selection
                           * Smoothing
                           * Downsampling/upsampling
                           * IDCT scaling
                           * Partial image decompression
                           * Transformations using jpegtran
                         Any switches used to enable or configure those features
                         will be ignored.
 
         -arithmetic     Use arithmetic coding.  CAUTION: arithmetic coded JPEG
                         is not yet widely implemented, so many decoders will
                         be unable to view an arithmetic coded JPEG file at
                         all.
 
         -dct int        Use accurate integer DCT method (default).
         -dct fast       Use less accurate integer DCT method [legacy feature].
                         When the Independent JPEG Group's software was first
                         released in 1991, the compression time for a
                         1-megapixel JPEG image on a mainstream PC was measured
                         in minutes.  Thus, the fast integer DCT algorithm
                         provided noticeable performance benefits.  On modern
                         CPUs running libjpeg-turbo, however, the compression
                         time for a 1-megapixel JPEG image is measured in
                         milliseconds, and thus the performance benefits of the
                         fast algorithm are much less noticeable.  On modern
                         x86/x86-64 CPUs that support AVX2 instructions, the
                         fast and int methods have similar performance.  On
                         other types of CPUs, the fast method is generally about
                         5-15% faster than the int method.
 
                         For quality levels of 90 and below, there should be
                         little or no perceptible quality difference between the
                         two algorithms.  For quality levels above 90, however,
                         the difference between the fast and int methods becomes
                         more pronounced.  With quality=97, for instance, the
                         fast method incurs generally about a 1-3 dB loss in
                         PSNR relative to the int method, but this can be larger
                         for some images.  Do not use the fast method with
                         quality levels above 97.  The algorithm often
                         degenerates at quality=98 and above and can actually
                         produce a more lossy image than if lower quality levels
                         had been used.  Also, in libjpeg-turbo, the fast method
                         is not fully accelerated for quality levels above 97,
                         so it will be slower than the int method.
         -dct float      Use floating-point DCT method [legacy feature].
                         The float method does not produce significantly more
                         accurate results than the int method, and it is much
                         slower.  The float method may also give different
                         results on different machines due to varying roundoff
                         behavior, whereas the integer methods should give the
                         same results on all machines.
 
         -restart N      Emit a JPEG restart marker every N MCU rows, or every
                         N MCU blocks (samples in lossless mode) if "B" is
                         attached to the number.  -restart 0 (the default) means
                         no restart markers.
 
         -smooth N       Smooth the input image to eliminate dithering noise.
                         N, ranging from 1 to 100, indicates the strength of
                         smoothing.  0 (the default) means no smoothing.
 
         -maxmemory N    Set limit for amount of memory to use in processing
                         large images.  Value is in thousands of bytes, or
                         millions of bytes if "M" is attached to the number.
                         For example, -max 4m selects 4000000 bytes.  If more
                         space is needed, an error will occur.
 
         -verbose        Enable debug printout.  More -v's give more printout.
         or -debug       Also, version information is printed at startup.
diff --git a/wrgif.c b/wrgif.c
index c0fb10c1..23773573 100644
--- a/wrgif.c
+++ b/wrgif.c
@@ -1,40 +1,39 @@
 /*
  * wrgif.c
  *
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * Modified 2015-2019 by Guido Vollbeding.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2015, 2017, 2022, D. R. Commander.
+ * Copyright (C) 2015, 2017, 2022-2023, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
  * This file contains routines to write output images in GIF format.
  *
  * These routines may need modification for non-Unix environments or
  * specialized applications.  As they stand, they assume output to
  * an ordinary stdio stream.
  */
 
 /*
  * This code is loosely based on ppmtogif from the PBMPLUS distribution
  * of Feb. 1991.  That file contains the following copyright notice:
  *    Based on GIFENCODE by David Rowley <mgardi@watdscu.waterloo.edu>.
  *    Lempel-Ziv compression based on "compress" by Spencer W. Thomas et al.
  *    Copyright (C) 1989 by Jef Poskanzer.
  *    Permission to use, copy, modify, and distribute this software and its
  *    documentation for any purpose and without fee is hereby granted, provided
  *    that the above copyright notice appear in all copies and that both that
  *    copyright notice and this permission notice appear in supporting
  *    documentation.  This software is provided "as is" without express or
  *    implied warranty.
  */
 
 #include "cdjpeg.h"             /* Common decls for cjpeg/djpeg applications */
 #include "jsamplecomp.h"
 
-#if defined(GIF_SUPPORTED) && \
-    (BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED))
+#if defined(GIF_SUPPORTED) && BITS_IN_JSAMPLE != 16
 
 
 #define MAX_LZW_BITS     12     /* maximum LZW code size (4096 symbols) */
@@ -528,60 +527,59 @@ GLOBAL(djpeg_dest_ptr)
 _jinit_write_gif(j_decompress_ptr cinfo, boolean is_lzw)
 {
   gif_dest_ptr dest;
 
   if (cinfo->data_precision != BITS_IN_JSAMPLE)
     ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 
   /* Create module interface object, fill in method pointers */
   dest = (gif_dest_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                 sizeof(gif_dest_struct));
   dest->cinfo = cinfo;          /* make back link for subroutines */
   dest->pub.start_output = start_output_gif;
   dest->pub.finish_output = finish_output_gif;
   dest->pub.calc_buffer_dimensions = calc_buffer_dimensions_gif;
 
   if (cinfo->out_color_space != JCS_GRAYSCALE &&
       cinfo->out_color_space != JCS_RGB)
     ERREXIT(cinfo, JERR_GIF_COLORSPACE);
 
   /* Force quantization if color or if > 8 bits input */
   if (cinfo->out_color_space != JCS_GRAYSCALE || cinfo->data_precision > 8) {
     /* Force quantization to at most 256 colors */
     cinfo->quantize_colors = TRUE;
     if (cinfo->desired_number_of_colors > 256)
       cinfo->desired_number_of_colors = 256;
   }
 
   /* Calculate output image dimensions so we can allocate space */
   jpeg_calc_output_dimensions(cinfo);
 
   if (cinfo->output_components != 1) /* safety check: just one component? */
     ERREXIT(cinfo, JERR_GIF_BUG);
 
   /* Create decompressor output buffer. */
   dest->pub._buffer = (_JSAMPARRAY)(*cinfo->mem->alloc_sarray)
     ((j_common_ptr)cinfo, JPOOL_IMAGE, cinfo->output_width, (JDIMENSION)1);
   dest->pub.buffer_height = 1;
 
   if (is_lzw) {
     dest->pub.put_pixel_rows = put_LZW_pixel_rows;
     /* Allocate space for hash table */
     dest->hash_code = (code_int *)
       (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                   HSIZE * sizeof(code_int));
     dest->hash_value = (hash_entry *)
       (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                   HSIZE * sizeof(hash_entry));
   } else {
     dest->pub.put_pixel_rows = put_raw_pixel_rows;
     /* Mark tables unused */
     dest->hash_code = NULL;
     dest->hash_value = NULL;
   }
 
   return (djpeg_dest_ptr)dest;
 }
 
-#endif /* defined(GIF_SUPPORTED) &&
-          (BITS_IN_JSAMPLE != 16 || defined(D_LOSSLESS_SUPPORTED)) */
+#endif /* defined(GIF_SUPPORTED) && BITS_IN_JSAMPLE != 16 */
