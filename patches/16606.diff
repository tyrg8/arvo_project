commit 2caf20ff25c090341965cc88b7f31f129e806a3a
Merge: 4f5c8fc dbfc601
Author: Xin Li <delphij@google.com>
Date:   Wed Sep 4 13:33:45 2019 -0700

    DO NOT MERGE - Merge Android 10 into master
    
    Bug: 139893257
    Change-Id: Ia2e8a99a24165a08d0c608efcb02c144ff3d909b

diff --git a/Android.bp b/Android.bp
index 51cfd80..afbb2bb 100644
--- a/Android.bp
+++ b/Android.bp
@@ -1,216 +1,223 @@
 cc_library_static {
     name: "libmpeg2dec",
     vendor_available: true,
     host_supported:true,
     shared_libs: ["liblog", "libcutils"],
 
     cflags: [
         "-D_LIB",
         "-DMULTICORE",
         "-fPIC",
 
         "-O3",
         "-DANDROID",
         "-Werror",
     ],
 
     export_include_dirs: [
         "decoder",
         "common",
     ],
 
     srcs: [
         "common/impeg2_buf_mgr.c",
         "common/impeg2_disp_mgr.c",
         "common/impeg2_format_conv.c",
         "common/impeg2_globals.c",
         "common/impeg2_idct.c",
         "common/impeg2_inter_pred.c",
         "common/impeg2_job_queue.c",
         "common/impeg2_mem_func.c",
         "common/ithread.c",
         "decoder/impeg2d_api_main.c",
         "decoder/impeg2d_bitstream.c",
         "decoder/impeg2d_debug.c",
         "decoder/impeg2d_dec_hdr.c",
         "decoder/impeg2d_decoder.c",
         "decoder/impeg2d_d_pic.c",
         "decoder/impeg2d_function_selector_generic.c",
         "decoder/impeg2d_globals.c",
         "decoder/impeg2d_i_pic.c",
         "decoder/impeg2d_mc.c",
         "decoder/impeg2d_mv_dec.c",
         "decoder/impeg2d_pic_proc.c",
         "decoder/impeg2d_pnb_pic.c",
         "decoder/impeg2d_vld.c",
         "decoder/impeg2d_vld_tables.c",
         "decoder/impeg2d_deinterlace.c",
         "common/icv_sad.c",
         "common/icv_variance.c",
         "common/ideint.c",
         "common/ideint_cac.c",
         "common/ideint_debug.c",
         "common/ideint_function_selector_generic.c",
         "common/ideint_utils.c",
     ],
 
     arch: {
         arm: {
             local_include_dirs: [
                 "decoder/arm",
                 "common/arm",
             ],
 
             srcs: [
                 "decoder/arm/impeg2d_function_selector.c",
                 "common/arm/ideint_function_selector.c",
             ],
 
             neon: {
                 srcs: [
                     "decoder/arm/impeg2d_function_selector_a9q.c",
                     "common/arm/ideint_function_selector_a9.c",
                     "common/arm/icv_sad_a9.s",
                     "common/arm/icv_variance_a9.s",
                     "common/arm/ideint_spatial_filter_a9.s",
                     "common/arm/ideint_cac_a9.s",
                     "common/arm/impeg2_format_conv.s",
                     "common/arm/impeg2_idct.s",
                     "common/arm/impeg2_inter_pred.s",
                     "common/arm/impeg2_mem_func.s",
                 ],
                 cflags: [
                     "-UDISABLE_NEON",
                     "-UDEFAULT_ARCH",
                     "-DDEFAULT_ARCH=D_ARCH_ARM_A9Q",
                 ],
             },
 
             cflags: [
                 "-DDISABLE_NEONINTR",
                 "-DARM",
                 "-DARMGCC",
 
                 // These are overriden by armv7_a_neon
                 "-DDISABLE_NEON",
                 "-DDEFAULT_ARCH=D_ARCH_ARM_NONEON",
             ],
             instruction_set: "arm",
         },
 
         arm64: {
             cflags: [
                 "-DARMV8",
                 "-DDISABLE_NEONINTR",
                 "-DARM",
                 "-DARMGCC",
 
                 "-DDEFAULT_ARCH=D_ARCH_ARMV8_GENERIC",
             ],
             local_include_dirs: [
                 "decoder/arm",
                 "common/armv8",
             ],
 
             srcs: [
                 "decoder/arm/impeg2d_function_selector.c",
                 "decoder/arm/impeg2d_function_selector_av8.c",
                 "common/arm/ideint_function_selector.c",
                 "common/arm/ideint_function_selector_av8.c",
                 "common/armv8/icv_sad_av8.s",
                 "common/armv8/icv_variance_av8.s",
                 "common/armv8/ideint_spatial_filter_av8.s",
                 "common/armv8/ideint_cac_av8.s",
                 "common/armv8/impeg2_neon_macros.s",
                 "common/armv8/impeg2_format_conv.s",
                 "common/armv8/impeg2_idct.s",
                 "common/armv8/impeg2_inter_pred.s",
                 "common/armv8/impeg2_mem_func.s",
             ],
         },
 
         mips: {
             local_include_dirs: ["common/mips"],
 
             srcs: [
                 "decoder/mips/impeg2d_function_selector.c",
                 "common/mips/ideint_function_selector.c",
             ],
         },
 
         mips64: {
             local_include_dirs: ["common/mips"],
 
             srcs: [
                 "decoder/mips/impeg2d_function_selector.c",
                 "common/mips/ideint_function_selector.c",
             ],
         },
 
         x86: {
             cflags: [
                 "-DX86",
                 "-DDISABLE_AVX2",
                 "-msse4.2",
                 "-mno-avx",
                 "-DDEFAULT_ARCH=D_ARCH_X86_SSE42",
             ],
 
             local_include_dirs: [
                 "decoder/x86",
                 "common/x86",
             ],
 
             srcs: [
                 "decoder/x86/impeg2d_function_selector.c",
                 "decoder/x86/impeg2d_function_selector_avx2.c",
                 "decoder/x86/impeg2d_function_selector_ssse3.c",
                 "decoder/x86/impeg2d_function_selector_sse42.c",
                 "common/x86/ideint_function_selector.c",
                 "common/x86/ideint_function_selector_ssse3.c",
                 "common/x86/ideint_function_selector_sse42.c",
                 "common/x86/icv_variance_ssse3.c",
                 "common/x86/icv_sad_ssse3.c",
                 "common/x86/ideint_cac_ssse3.c",
                 "common/x86/ideint_spatial_filter_ssse3.c",
                 "common/x86/impeg2_idct_recon_sse42_intr.c",
                 "common/x86/impeg2_inter_pred_sse42_intr.c",
                 "common/x86/impeg2_mem_func_sse42_intr.c",
             ],
         },
 
         x86_64: {
             cflags: [
                 "-DX86",
                 "-DDISABLE_AVX2",
                 "-msse4.2",
                 "-mno-avx",
                 "-DDEFAULT_ARCH=D_ARCH_X86_SSE42",
             ],
 
             local_include_dirs: [
                 "decoder/x86",
                 "common/x86",
             ],
 
             srcs: [
                 "decoder/x86/impeg2d_function_selector.c",
                 "decoder/x86/impeg2d_function_selector_avx2.c",
                 "decoder/x86/impeg2d_function_selector_ssse3.c",
                 "decoder/x86/impeg2d_function_selector_sse42.c",
                 "common/x86/ideint_function_selector.c",
                 "common/x86/ideint_function_selector_ssse3.c",
                 "common/x86/ideint_function_selector_sse42.c",
                 "common/x86/icv_variance_ssse3.c",
                 "common/x86/icv_sad_ssse3.c",
                 "common/x86/ideint_cac_ssse3.c",
                 "common/x86/ideint_spatial_filter_ssse3.c",
                 "common/x86/impeg2_idct_recon_sse42_intr.c",
                 "common/x86/impeg2_inter_pred_sse42_intr.c",
                 "common/x86/impeg2_mem_func_sse42_intr.c",
             ],
         },
     },
+    sanitize: {
+        integer_overflow: true,
+        misc_undefined: ["bounds"],
+        // Enable CFI if this becomes a shared library.
+        // cfi: true,
+        blacklist: "libmpeg2dec_blacklist.txt",
+    },
 }
 
 subdirs = ["test"]
diff --git a/common/impeg2_buf_mgr.c b/common/impeg2_buf_mgr.c
index c4aca4a..498259f 100644
--- a/common/impeg2_buf_mgr.c
+++ b/common/impeg2_buf_mgr.c
@@ -76,39 +76,72 @@
 void impeg2_buf_mgr_init(
                 buf_mgr_t *ps_buf_mgr)
 {
     WORD32 id;
 
     ps_buf_mgr->u4_max_buf_cnt = BUF_MGR_MAX_CNT;
     ps_buf_mgr->u4_active_buf_cnt = 0;
 
     for(id = 0; id < BUF_MGR_MAX_CNT; id++)
     {
         ps_buf_mgr->au4_status[id] = 0;
         ps_buf_mgr->apv_ptr[id] = NULL;
     }
 }
 
+/**
+*******************************************************************************
+*
+* @brief
+*      Buffer manager reset function.
+*
+* @par Description:
+*    Resets the buffer manager structure
+*
+* @param[in] ps_buf_mgr
+*  Pointer to the buffer manager
+*
+* @returns
+*
+* @remarks
+*  None
+*
+*******************************************************************************
+*/
+
+void impeg2_buf_mgr_reset(
+                buf_mgr_t *ps_buf_mgr)
+{
+    WORD32 id;
+
+    ps_buf_mgr->u4_max_buf_cnt = BUF_MGR_MAX_CNT;
+    ps_buf_mgr->u4_active_buf_cnt = 0;
+
+    for(id = 0; id < BUF_MGR_MAX_CNT; id++)
+    {
+        ps_buf_mgr->au4_status[id] = 0;
+    }
+}
 
 /**
 *******************************************************************************
 *
 * @brief
 *       Adds and increments the buffer and buffer count.
 *
 * @par Description:
 *     Adds a buffer to the buffer manager if it is not already  present and
 *   increments the  active buffer count
 *
 * @param[in] ps_buf_mgr
 *  Pointer to the buffer manager
 *
 * @param[in] pv_ptr
 *  Pointer to the buffer to be added
 *
 * @returns  Returns 0 on success, -1 otherwise
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */
diff --git a/common/impeg2_buf_mgr.h b/common/impeg2_buf_mgr.h
index 6b1cbef..aed157a 100644
--- a/common/impeg2_buf_mgr.h
+++ b/common/impeg2_buf_mgr.h
@@ -68,7 +68,11 @@ typedef struct
 // intializes the buffer API structure
 void impeg2_buf_mgr_init(
                 buf_mgr_t *ps_buf_mgr);
 
+// resets the buffer API structure
+void impeg2_buf_mgr_reset(
+                buf_mgr_t *ps_buf_mgr);
+
 // Add buffer to buffer manager. 0: success, -1: fail (u4_active_buf_cnt has reached u4_max_buf_cnt)
 WORD32 impeg2_buf_mgr_add(
                 buf_mgr_t *ps_buf_mgr,
diff --git a/decoder/impeg2d_api_main.c b/decoder/impeg2d_api_main.c
index 5201608..e0b67cb 100644
--- a/decoder/impeg2d_api_main.c
+++ b/decoder/impeg2d_api_main.c
@@ -960,202 +960,176 @@ IV_API_CALL_STATUS_T impeg2d_api_set_default(iv_obj_t *ps_dechdl,
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :  impeg2d_api_reset                                       */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :                                                          */
 /*  Globals       : <Does it use any global variables?>                      */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         08 06 2009    100356         RAVI                                 */
 /*                                                                           */
 /*****************************************************************************/
 IV_API_CALL_STATUS_T impeg2d_api_reset(iv_obj_t *ps_dechdl,
                                        void *pv_api_ip,
                                        void *pv_api_op)
 {
     dec_state_t *ps_dec_state;
     dec_state_multi_core_t *ps_dec_state_multi_core;
     UNUSED(pv_api_ip);
     impeg2d_ctl_reset_op_t *s_ctl_reset_op = (impeg2d_ctl_reset_op_t *)pv_api_op;
 
     WORD32 i4_num_threads;
 
     ps_dec_state_multi_core = (dec_state_multi_core_t *) (ps_dechdl->pv_codec_handle);
     ps_dec_state = ps_dec_state_multi_core->ps_dec_state[0];
 
     if(ps_dec_state_multi_core != NULL)
     {
-        if(ps_dec_state->aps_ref_pics[1] != NULL)
-            impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[1]->i4_buf_id, BUF_MGR_REF);
-        if(ps_dec_state->aps_ref_pics[0] != NULL)
-            impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[0]->i4_buf_id, BUF_MGR_REF);
-        while(1)
-        {
-            pic_buf_t *ps_disp_pic = impeg2_disp_mgr_get(&ps_dec_state->s_disp_mgr, &ps_dec_state->i4_disp_buf_id);
-            if(NULL == ps_disp_pic)
-                break;
-            if(0 == ps_dec_state->u4_share_disp_buf)
-                impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_disp_pic->i4_buf_id, BUF_MGR_DISP);
-
-        }
-
-        if((ps_dec_state->u4_deinterlace) && (NULL != ps_dec_state->ps_deint_pic))
-        {
-            impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg,
-                                   ps_dec_state->ps_deint_pic->i4_buf_id,
-                                   MPEG2_BUF_MGR_DEINT);
-        }
+        impeg2_buf_mgr_reset(ps_dec_state->pv_pic_buf_mg);
+        /* Display buffer manager init behaves like a reset
+         * as it doesn't need to preserve picture buffer addresses
+         * like buffer manager */
+        impeg2_disp_mgr_init(&ps_dec_state->s_disp_mgr);
 
         for(i4_num_threads = 0; i4_num_threads < MAX_THREADS; i4_num_threads++)
         {
             ps_dec_state = ps_dec_state_multi_core->ps_dec_state[i4_num_threads];
 
 
             /* --------------------------------------------------------------------- */
             /* Initializations */
 
             ps_dec_state->u2_header_done    = 0;  /* Header decoding not done */
             ps_dec_state->u4_frm_buf_stride = 0;
             ps_dec_state->i4_pic_count      = 0;
             ps_dec_state->u2_is_mpeg2       = 0;
             ps_dec_state->aps_ref_pics[0] = NULL;
             ps_dec_state->aps_ref_pics[1] = NULL;
             ps_dec_state->ps_deint_pic = NULL;
         }
     }
     else
     {
         s_ctl_reset_op->s_ivd_ctl_reset_op_t.u4_error_code =
                         IMPEG2D_INIT_NOT_DONE;
     }
 
     return(IV_SUCCESS);
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :  impeg2d_api_set_params                                  */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :                                                          */
 /*  Globals       : <Does it use any global variables?>                      */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         08 06 2009    100356         RAVI                                 */
 /*                                                                           */
 /*****************************************************************************/
 IV_API_CALL_STATUS_T impeg2d_api_set_params(iv_obj_t *ps_dechdl,void *pv_api_ip,void *pv_api_op)
 {
     dec_state_t *ps_dec_state;
     dec_state_multi_core_t *ps_dec_state_multi_core;
     impeg2d_ctl_set_config_ip_t  *ps_ctl_dec_ip = (impeg2d_ctl_set_config_ip_t  *)pv_api_ip;
     impeg2d_ctl_set_config_op_t  *ps_ctl_dec_op = (impeg2d_ctl_set_config_op_t  *)pv_api_op;
 
     ps_dec_state_multi_core = (dec_state_multi_core_t *) (ps_dechdl->pv_codec_handle);
     ps_dec_state = ps_dec_state_multi_core->ps_dec_state[0];
 
     if((ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.e_vid_dec_mode != IVD_DECODE_HEADER) && (ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.e_vid_dec_mode != IVD_DECODE_FRAME))
     {
         ps_ctl_dec_op->s_ivd_ctl_set_config_op_t.u4_error_code = IV_FAIL;
         return(IV_FAIL);
     }
 
     if((ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.e_frm_out_mode != IVD_DISPLAY_FRAME_OUT) && (ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.e_frm_out_mode != IVD_DECODE_FRAME_OUT))
     {
         ps_ctl_dec_op->s_ivd_ctl_set_config_op_t.u4_error_code = IV_FAIL;
         return(IV_FAIL);
     }
 
     if( (WORD32) ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.e_frm_skip_mode < IVD_SKIP_NONE)
     {
         ps_ctl_dec_op->s_ivd_ctl_set_config_op_t.u4_error_code = IV_FAIL;
         return(IV_FAIL);
     }
 
     if(ps_dec_state->u2_header_done == 1)
     {
         if(((WORD32)ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.u4_disp_wd < 0) ||
             ((ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.u4_disp_wd != 0) && (ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.u4_disp_wd < ps_dec_state->u2_frame_width)))
         {
             ps_ctl_dec_op->s_ivd_ctl_set_config_op_t.u4_error_code = IV_FAIL;
             return(IV_FAIL);
         }
 
     }
 
 
     ps_dec_state->u2_decode_header    = (UWORD8)ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.e_vid_dec_mode;
 
     if(ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.u4_disp_wd != 0)
     {
-        if(ps_dec_state->u2_header_done == 1)
-        {
-            if (ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.u4_disp_wd > ps_dec_state->u2_frame_width)
-            {
-                ps_dec_state->u4_frm_buf_stride = ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.u4_disp_wd;
-            }
-        }
-        else
-        {
-            ps_dec_state->u4_frm_buf_stride = ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.u4_disp_wd;
-        }
-
+        ps_dec_state->u4_frm_buf_stride = ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.u4_disp_wd;
     }
     else
     {
 
             if(ps_dec_state->u2_header_done == 1)
             {
                 ps_dec_state->u4_frm_buf_stride = ps_dec_state->u2_frame_width;
             }
             else
             {
                 ps_dec_state->u4_frm_buf_stride = 0;
             }
     }
 
 
         if(ps_ctl_dec_ip->s_ivd_ctl_set_config_ip_t.e_vid_dec_mode  == IVD_DECODE_FRAME)
         {
             ps_dec_state->u1_flushfrm = 0;
         }
 
 
     ps_ctl_dec_op->s_ivd_ctl_set_config_op_t.u4_error_code = IV_SUCCESS;
     return(IV_SUCCESS);
 
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :  impeg2d_api_get_status                                  */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :                                                          */
 /*  Globals       : <Does it use any global variables?>                      */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         08 06 2009    100356         RAVI                                 */
 /*                                                                           */
 /*****************************************************************************/
@@ -3168,416 +3142,417 @@ IV_API_CALL_STATUS_T impeg2d_api_check_struct_sanity(iv_obj_t *ps_handle,
 IV_API_CALL_STATUS_T impeg2d_api_entity(iv_obj_t *ps_dechdl,
                                         void *pv_api_ip,
                                         void *pv_api_op)
 {
     iv_obj_t *ps_dec_handle;
     dec_state_t *ps_dec_state;
     dec_state_multi_core_t *ps_dec_state_multi_core;
 
     impeg2d_video_decode_ip_t    *ps_dec_ip;
 
     impeg2d_video_decode_op_t    *ps_dec_op;
     WORD32 bytes_remaining;
     pic_buf_t *ps_disp_pic;
 
 
 
     ps_dec_ip = (impeg2d_video_decode_ip_t    *)pv_api_ip;
     ps_dec_op = (impeg2d_video_decode_op_t    *)pv_api_op;
 
     memset(ps_dec_op,0,sizeof(impeg2d_video_decode_op_t));
 
     ps_dec_op->s_ivd_video_decode_op_t.u4_size = sizeof(impeg2d_video_decode_op_t);
     ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 0;
     bytes_remaining = ps_dec_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;
 
     ps_dec_handle = (iv_obj_t *)ps_dechdl;
 
     if(ps_dechdl == NULL)
     {
         return(IV_FAIL);
     }
 
 
 
     ps_dec_state_multi_core  = ps_dec_handle->pv_codec_handle;
     ps_dec_state = ps_dec_state_multi_core->ps_dec_state[0];
 
     ps_dec_state->ps_disp_frm_buf = &(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);
     if(0 == ps_dec_state->u4_share_disp_buf)
     {
         ps_dec_state->ps_disp_frm_buf->pv_y_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0];
         ps_dec_state->ps_disp_frm_buf->pv_u_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1];
         ps_dec_state->ps_disp_frm_buf->pv_v_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2];
     }
 
     ps_dec_state->ps_disp_pic = NULL;
     ps_dec_state->i4_frame_decoded = 0;
     /*rest bytes consumed */
     ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = 0;
 
     ps_dec_op->s_ivd_video_decode_op_t.u4_error_code           = IV_SUCCESS;
 
     if((ps_dec_ip->s_ivd_video_decode_ip_t.pv_stream_buffer == NULL)&&(ps_dec_state->u1_flushfrm==0))
     {
         ps_dec_op->s_ivd_video_decode_op_t.u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
         ps_dec_op->s_ivd_video_decode_op_t.u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
         return IV_FAIL;
     }
 
 
     if (ps_dec_state->u4_num_frames_decoded > NUM_FRAMES_LIMIT)
     {
         ps_dec_op->s_ivd_video_decode_op_t.u4_error_code       = IMPEG2D_SAMPLE_VERSION_LIMIT_ERR;
         return(IV_FAIL);
     }
 
     if(((0 == ps_dec_state->u2_header_done) || (ps_dec_state->u2_decode_header == 1)) && (ps_dec_state->u1_flushfrm == 0))
     {
         impeg2d_dec_hdr(ps_dec_state,ps_dec_ip ,ps_dec_op);
         bytes_remaining -= ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed;
     }
 
     if((1 != ps_dec_state->u2_decode_header) &&
         (((bytes_remaining > 0) && (1 == ps_dec_state->u2_header_done)) || ps_dec_state->u1_flushfrm))
     {
         if(ps_dec_state->u1_flushfrm)
         {
             if(ps_dec_state->aps_ref_pics[1] != NULL)
             {
                 impeg2_disp_mgr_add(&ps_dec_state->s_disp_mgr, ps_dec_state->aps_ref_pics[1], ps_dec_state->aps_ref_pics[1]->i4_buf_id);
                 impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[1]->i4_buf_id, BUF_MGR_REF);
                 impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[0]->i4_buf_id, BUF_MGR_REF);
 
                 ps_dec_state->aps_ref_pics[1] = NULL;
                 ps_dec_state->aps_ref_pics[0] = NULL;
 
             }
             else if(ps_dec_state->aps_ref_pics[0] != NULL)
             {
                 impeg2_disp_mgr_add(&ps_dec_state->s_disp_mgr, ps_dec_state->aps_ref_pics[0], ps_dec_state->aps_ref_pics[0]->i4_buf_id);
                 impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->aps_ref_pics[0]->i4_buf_id, BUF_MGR_REF);
 
                 ps_dec_state->aps_ref_pics[0] = NULL;
             }
             ps_dec_ip->s_ivd_video_decode_ip_t.u4_size                 = sizeof(impeg2d_video_decode_ip_t);
             ps_dec_op->s_ivd_video_decode_op_t.u4_size                 = sizeof(impeg2d_video_decode_op_t);
 
             ps_disp_pic = impeg2_disp_mgr_get(&ps_dec_state->s_disp_mgr, &ps_dec_state->i4_disp_buf_id);
 
             ps_dec_state->ps_disp_pic = ps_disp_pic;
             if(ps_disp_pic == NULL)
             {
                 ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 0;
             }
             else
             {
                 WORD32 fmt_conv;
                 if(0 == ps_dec_state->u4_share_disp_buf)
                 {
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_y_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0];
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_u_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1];
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_v_buf  = ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2];
                     fmt_conv = 1;
                 }
                 else
                 {
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_y_buf  = ps_disp_pic->pu1_y;
                     if(IV_YUV_420P == ps_dec_state->i4_chromaFormat)
                     {
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_u_buf  = ps_disp_pic->pu1_u;
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_v_buf  = ps_disp_pic->pu1_v;
                         fmt_conv = 0;
                     }
                     else
                     {
                         UWORD8 *pu1_buf;
 
                         pu1_buf = ps_dec_state->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[1];
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_u_buf  = pu1_buf;
 
                         pu1_buf = ps_dec_state->as_disp_buffers[ps_disp_pic->i4_buf_id].pu1_bufs[2];
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.pv_v_buf  = pu1_buf;
                         fmt_conv = 1;
                     }
                 }
 
                 if(fmt_conv == 1)
                 {
                     iv_yuv_buf_t *ps_dst;
 
 
                     ps_dst = &(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);
                     if(ps_dec_state->u4_deinterlace && (0 == ps_dec_state->u2_progressive_frame))
                     {
                         impeg2d_deinterlace(ps_dec_state,
                                             ps_disp_pic,
                                             ps_dst,
                                             0,
                                             ps_dec_state->u2_vertical_size);
 
                     }
                     else
                     {
                         impeg2d_format_convert(ps_dec_state,
                                                ps_disp_pic,
                                                ps_dst,
                                                0,
                                                ps_dec_state->u2_vertical_size);
                     }
                 }
 
                 if(ps_dec_state->u4_deinterlace)
                 {
                     if(ps_dec_state->ps_deint_pic)
                     {
                         impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg,
                                                ps_dec_state->ps_deint_pic->i4_buf_id,
                                                MPEG2_BUF_MGR_DEINT);
                     }
                     ps_dec_state->ps_deint_pic = ps_disp_pic;
                 }
                 if(0 == ps_dec_state->u4_share_disp_buf)
                     impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_disp_pic->i4_buf_id, BUF_MGR_DISP);
 
                 ps_dec_op->s_ivd_video_decode_op_t.u4_pic_ht = ps_dec_state->u2_vertical_size;
                 ps_dec_op->s_ivd_video_decode_op_t.u4_pic_wd = ps_dec_state->u2_horizontal_size;
                 ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 1;
 
                 ps_dec_op->s_ivd_video_decode_op_t.u4_disp_buf_id = ps_disp_pic->i4_buf_id;
                 ps_dec_op->s_ivd_video_decode_op_t.u4_ts = ps_disp_pic->u4_ts;
 
                 ps_dec_op->s_ivd_video_decode_op_t.e_output_format = (IV_COLOR_FORMAT_T)ps_dec_state->i4_chromaFormat;
 
                 ps_dec_op->s_ivd_video_decode_op_t.u4_is_ref_flag = (B_PIC != ps_dec_state->e_pic_type);
 
                 ps_dec_op->s_ivd_video_decode_op_t.u4_progressive_frame_flag           = IV_PROGRESSIVE;
 
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_wd = ps_dec_state->u2_horizontal_size;
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_strd = ps_dec_state->u4_frm_buf_stride;
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_ht = ps_dec_state->u2_vertical_size;
 
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size >> 1;
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride >> 1;
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = ps_dec_state->u2_vertical_size >> 1;
 
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = ps_dec_state->u2_horizontal_size >> 1;
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_strd = ps_dec_state->u4_frm_buf_stride >> 1;
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = ps_dec_state->u2_vertical_size >> 1;
                 ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_size = sizeof(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);
 
                 switch(ps_dec_state->i4_chromaFormat)
                 {
                     case IV_YUV_420SP_UV:
                     case IV_YUV_420SP_VU:
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size;
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride;
                     break;
                     case IV_YUV_422ILE:
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = 0;
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = 0;
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = 0;
                         ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = 0;
                     break;
                     default:
                     break;
                 }
 
 
             }
             if(ps_dec_op->s_ivd_video_decode_op_t.u4_output_present)
             {
                 if(1 == ps_dec_op->s_ivd_video_decode_op_t.u4_output_present)
                 {
                     INSERT_LOGO(ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0],
                                 ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1],
                                 ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2],
                                 ps_dec_state->u4_frm_buf_stride,
                                 ps_dec_state->u2_horizontal_size,
                                 ps_dec_state->u2_vertical_size,
                                 ps_dec_state->i4_chromaFormat,
                                 ps_dec_state->u2_horizontal_size,
                                 ps_dec_state->u2_vertical_size);
                 }
                 return(IV_SUCCESS);
             }
             else
             {
                 ps_dec_state->u1_flushfrm = 0;
 
                 return(IV_FAIL);
             }
 
         }
         else if(ps_dec_state->u1_flushfrm==0)
         {
             ps_dec_ip->s_ivd_video_decode_ip_t.u4_size                 = sizeof(impeg2d_video_decode_ip_t);
             ps_dec_op->s_ivd_video_decode_op_t.u4_size                 = sizeof(impeg2d_video_decode_op_t);
             if(ps_dec_ip->s_ivd_video_decode_ip_t.u4_num_Bytes < 4)
             {
                 ps_dec_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_dec_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;
                 return(IV_FAIL);
             }
 
             if(1 == ps_dec_state->u4_share_disp_buf)
             {
                 if(0 == impeg2_buf_mgr_check_free(ps_dec_state->pv_pic_buf_mg))
                 {
                     ps_dec_op->s_ivd_video_decode_op_t.u4_error_code =
                                     (IMPEG2D_ERROR_CODES_T)IVD_DEC_REF_BUF_NULL;
                     return IV_FAIL;
                 }
             }
 
 
             ps_dec_op->s_ivd_video_decode_op_t.e_output_format = (IV_COLOR_FORMAT_T)ps_dec_state->i4_chromaFormat;
 
             ps_dec_op->s_ivd_video_decode_op_t.u4_is_ref_flag = (B_PIC != ps_dec_state->e_pic_type);
 
             ps_dec_op->s_ivd_video_decode_op_t.u4_progressive_frame_flag           = IV_PROGRESSIVE;
 
             if (0 == ps_dec_state->u4_frm_buf_stride)
             {
                 ps_dec_state->u4_frm_buf_stride = (ps_dec_state->u2_horizontal_size);
             }
 
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_wd = ps_dec_state->u2_horizontal_size;
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_strd = ps_dec_state->u4_frm_buf_stride;
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_y_ht = ps_dec_state->u2_vertical_size;
 
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size >> 1;
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride >> 1;
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = ps_dec_state->u2_vertical_size >> 1;
 
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = ps_dec_state->u2_horizontal_size >> 1;
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_strd = ps_dec_state->u4_frm_buf_stride >> 1;
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = ps_dec_state->u2_vertical_size >> 1;
             ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_size = sizeof(ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf);
 
             switch(ps_dec_state->i4_chromaFormat)
             {
                 case IV_YUV_420SP_UV:
                 case IV_YUV_420SP_VU:
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = ps_dec_state->u2_horizontal_size;
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_strd = ps_dec_state->u4_frm_buf_stride;
                 break;
                 case IV_YUV_422ILE:
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_wd = 0;
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_u_ht = 0;
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_wd = 0;
                     ps_dec_op->s_ivd_video_decode_op_t.s_disp_frm_buf.u4_v_ht = 0;
                 break;
                 default:
                 break;
             }
 
             if( ps_dec_state->u1_flushfrm == 0)
             {
                 ps_dec_state->u1_flushcnt    = 0;
 
                 ps_dec_state->ps_out_buf = &ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer;
                 if (IV_SUCCESS != check_app_out_buf_size(ps_dec_state))
                 {
                     ps_dec_op->s_ivd_video_decode_op_t.u4_error_code = IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                     return IV_FAIL;
                 }
 
                 /*************************************************************************/
                 /*                              Frame Decode                             */
                 /*************************************************************************/
+                ps_dec_state->u4_inp_ts = ps_dec_ip->s_ivd_video_decode_ip_t.u4_ts;
 
                 impeg2d_dec_frm(ps_dec_state,ps_dec_ip,ps_dec_op);
 
                 if (IVD_ERROR_NONE ==
                         ps_dec_op->s_ivd_video_decode_op_t.u4_error_code)
                 {
                     if(ps_dec_state->u1_first_frame_done == 0)
                     {
                         ps_dec_state->u1_first_frame_done = 1;
                     }
 
                     if(ps_dec_state->ps_disp_pic)
                     {
                         ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 1;
                         switch(ps_dec_state->ps_disp_pic->e_pic_type)
                         {
                             case I_PIC :
                             ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_I_FRAME;
                             break;
 
                             case P_PIC:
                             ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_P_FRAME;
                             break;
 
                             case B_PIC:
                             ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_B_FRAME;
                             break;
 
                             case D_PIC:
                             ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_I_FRAME;
                             break;
 
                             default :
                             ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_FRAMETYPE_DEFAULT;
                             break;
                         }
                     }
                     else
                     {
                         ps_dec_op->s_ivd_video_decode_op_t.u4_output_present = 0;
                         ps_dec_op->s_ivd_video_decode_op_t.e_pic_type = IV_NA_FRAME;
                     }
 
                     ps_dec_state->u4_num_frames_decoded++;
                 }
             }
             else
             {
                 ps_dec_state->u1_flushcnt++;
             }
         }
         if(ps_dec_state->ps_disp_pic)
         {
             ps_dec_op->s_ivd_video_decode_op_t.u4_disp_buf_id = ps_dec_state->ps_disp_pic->i4_buf_id;
             ps_dec_op->s_ivd_video_decode_op_t.u4_ts = ps_dec_state->ps_disp_pic->u4_ts;
 
             if(0 == ps_dec_state->u4_share_disp_buf)
             {
                 impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg, ps_dec_state->ps_disp_pic->i4_buf_id, BUF_MGR_DISP);
             }
         }
 
         if(ps_dec_state->u4_deinterlace)
         {
             if(ps_dec_state->ps_deint_pic)
             {
                 impeg2_buf_mgr_release(ps_dec_state->pv_pic_buf_mg,
                                        ps_dec_state->ps_deint_pic->i4_buf_id,
                                        MPEG2_BUF_MGR_DEINT);
             }
             ps_dec_state->ps_deint_pic = ps_dec_state->ps_disp_pic;
         }
 
         if(1 == ps_dec_op->s_ivd_video_decode_op_t.u4_output_present)
         {
             INSERT_LOGO(ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[0],
                         ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[1],
                         ps_dec_ip->s_ivd_video_decode_ip_t.s_out_buffer.pu1_bufs[2],
                         ps_dec_state->u4_frm_buf_stride,
                         ps_dec_state->u2_horizontal_size,
                         ps_dec_state->u2_vertical_size,
                         ps_dec_state->i4_chromaFormat,
                         ps_dec_state->u2_horizontal_size,
                         ps_dec_state->u2_vertical_size);
         }
 
     }
 
     ps_dec_op->s_ivd_video_decode_op_t.u4_progressive_frame_flag = 1;
     ps_dec_op->s_ivd_video_decode_op_t.e4_fld_type     = ps_dec_state->s_disp_op.e4_fld_type;
 
 
     if(ps_dec_op->s_ivd_video_decode_op_t.u4_error_code)
         return IV_FAIL;
     else
         return IV_SUCCESS;
 }
diff --git a/decoder/impeg2d_dec_hdr.c b/decoder/impeg2d_dec_hdr.c
index 987eb66..b60f488 100644
--- a/decoder/impeg2d_dec_hdr.c
+++ b/decoder/impeg2d_dec_hdr.c
@@ -752,74 +752,92 @@ IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
 /*******************************************************************************
 *
 *  Function Name   : impeg2d_dec_pic_coding_ext
 *
 *  Description     : Reads more picture level parameters
 *
 *  Arguments       :
 *  dec             : Decoder context
 *
 *  Values Returned : Error
 *******************************************************************************/
 IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_coding_ext(dec_state_t *ps_dec)
 {
+
+    UWORD32 u4_val;
     stream_t *ps_stream;
     IMPEG2D_ERROR_CODES_T e_error = (IMPEG2D_ERROR_CODES_T) IV_SUCCESS;
 
     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
     /* extension code identifier */
     impeg2d_bit_stream_get(ps_stream,4);
 
-    ps_dec->au2_f_code[0][0]             = impeg2d_bit_stream_get(ps_stream,4);
-    ps_dec->au2_f_code[0][1]             = impeg2d_bit_stream_get(ps_stream,4);
-    ps_dec->au2_f_code[1][0]             = impeg2d_bit_stream_get(ps_stream,4);
-    ps_dec->au2_f_code[1][1]             = impeg2d_bit_stream_get(ps_stream,4);
+    u4_val = impeg2d_bit_stream_get(ps_stream,4);
+    if(u4_val == 0)
+        return IMPEG2D_UNKNOWN_ERROR;
+    ps_dec->au2_f_code[0][0]             = u4_val;
+
+    u4_val = impeg2d_bit_stream_get(ps_stream,4);
+    if(u4_val == 0)
+        return IMPEG2D_UNKNOWN_ERROR;
+    ps_dec->au2_f_code[0][1]             = u4_val;
+
+    u4_val = impeg2d_bit_stream_get(ps_stream,4);
+    if(u4_val == 0)
+        return IMPEG2D_UNKNOWN_ERROR;
+    ps_dec->au2_f_code[1][0]             = u4_val;
+
+    u4_val = impeg2d_bit_stream_get(ps_stream,4);
+    if(u4_val == 0)
+        return IMPEG2D_UNKNOWN_ERROR;
+    ps_dec->au2_f_code[1][1]             = u4_val;
+
     ps_dec->u2_intra_dc_precision        = impeg2d_bit_stream_get(ps_stream,2);
     ps_dec->u2_picture_structure            = impeg2d_bit_stream_get(ps_stream,2);
     if (ps_dec->u2_picture_structure < TOP_FIELD ||
                     ps_dec->u2_picture_structure > FRAME_PICTURE)
     {
         return IMPEG2D_FRM_HDR_DECODE_ERR;
     }
     ps_dec->u2_top_field_first              = impeg2d_bit_stream_get_bit(ps_stream);
     ps_dec->u2_frame_pred_frame_dct         = impeg2d_bit_stream_get_bit(ps_stream);
     ps_dec->u2_concealment_motion_vectors   = impeg2d_bit_stream_get_bit(ps_stream);
     ps_dec->u2_q_scale_type                 = impeg2d_bit_stream_get_bit(ps_stream);
     ps_dec->u2_intra_vlc_format             = impeg2d_bit_stream_get_bit(ps_stream);
     ps_dec->u2_alternate_scan               = impeg2d_bit_stream_get_bit(ps_stream);
     ps_dec->u2_repeat_first_field           = impeg2d_bit_stream_get_bit(ps_stream);
     /* Flush chroma_420_type */
     impeg2d_bit_stream_get_bit(ps_stream);
 
     ps_dec->u2_progressive_frame            = impeg2d_bit_stream_get_bit(ps_stream);
     if (impeg2d_bit_stream_get_bit(ps_stream))
     {
         /* Flush v_axis, field_sequence, burst_amplitude, sub_carrier_phase */
         impeg2d_bit_stream_flush(ps_stream,20);
     }
     impeg2d_next_start_code(ps_dec);
 
 
     if(VERTICAL_SCAN == ps_dec->u2_alternate_scan)
     {
         ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_vertical;
     }
     else
     {
         ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_zig_zag;
     }
     return e_error;
 }
 
 /*******************************************************************************
 *
 *  Function Name   : impeg2d_dec_slice
 *
 *  Description     : Reads Slice level parameters and calls functions that
 *                    decode individual MBs of slice
 *
 *  Arguments       :
 *  dec             : Decoder context
 *
 *  Values Returned : None
 *******************************************************************************/
diff --git a/decoder/impeg2d_mv_dec.c b/decoder/impeg2d_mv_dec.c
index 1a30146..190726a 100644
--- a/decoder/impeg2d_mv_dec.c
+++ b/decoder/impeg2d_mv_dec.c
@@ -47,130 +47,130 @@
 /*******************************************************************************
 * Function name : impeg2d_dec_1mv
 *
 * Description   : Decodes a motion vector and updates the predictors
 *
 * Arguments     :
 * stream        : Bitstream
 * predMv        : Prediction for the motion vectors
 * mv            : Motion vectors
 * fCode         : fcode to the used for the decoding
 * shift         : Shift value to be used. This will be equal to
 *                 (mv_format == "field") && (picture_structure == "Frame picture")
 * i             : 0 - MV_X and 1 - MV_Y
 *
 * Value Returned: None
 *******************************************************************************/
 INLINE void impeg2d_dec_1mv(stream_t *ps_stream, WORD16 ai2_pred_mv[], WORD16 ai2_mv[],UWORD16 au2_fCode[],
            UWORD16 u2_mv_y_shift, WORD16 ai2_dmv[])
 {
     WORD16  i2_f;
     WORD16  i2_r_size;
     WORD16  i2_high,i2_low,i2_range;
     UWORD32  u4_mv_code;
     WORD16  i2_delta;
     UWORD16 u2_first_bit;
     WORD32 i;
     WORD32 ai2_shifts[2];
     UWORD32 u4_buf;
     UWORD32 u4_buf_nxt;
     UWORD32 u4_offset;
     UWORD32 *pu4_buf_aligned;
 
     ai2_shifts[0] = 0;
     ai2_shifts[1] = u2_mv_y_shift;
 
 
     GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
     for(i = 0; i < 2; i++)
     {
         WORD32 i4_shift = ai2_shifts[i];
         /* Decode the motion_code */
         IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_mv_code, MV_CODE_LEN)
         u2_first_bit    = (u4_mv_code >> (MV_CODE_LEN - 1)) & 0x01;
         if(u2_first_bit == 1) /* mvCode == 0 */
         {
             i2_delta = 0;
             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1,pu4_buf_aligned)
 
             ai2_mv[i] = (ai2_pred_mv[i] >> i4_shift);
 
             ai2_pred_mv[i] = (ai2_mv[i] << i4_shift);
 
         }
         else
         {
             UWORD16 u2_index;
             UWORD16 u2_value;
             UWORD16 u2_mv_len;
             UWORD16 u2_abs_mvcode_minus1;
             UWORD16 u2_sign_bit;
 
             i2_r_size   = au2_fCode[i] - 1;
             i2_f       = 1 << i2_r_size;
             i2_high    = (16 * i2_f) - 1;
             i2_low     = ((-16) * i2_f);
             i2_range   = (32 * i2_f);
 
             u2_index               = (u4_mv_code >> 1) & 0x1FF;
             u2_value               = gau2_impeg2d_mv_code[u2_index];
             u2_mv_len               = (u2_value & 0x0F);
             u2_abs_mvcode_minus1   = (u2_value >> 8) & 0x0FF;
             u4_mv_code            >>= (MV_CODE_LEN - u2_mv_len - 1);
             u2_sign_bit             = u4_mv_code & 0x1;
 
             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(u2_mv_len + 1),pu4_buf_aligned)
             i2_delta = u2_abs_mvcode_minus1 * i2_f + 1;
             if(i2_r_size)
             {
                 UWORD32 val;
                 IBITS_GET(u4_buf, u4_buf_nxt, u4_offset, val, pu4_buf_aligned, i2_r_size)
-                i2_delta += val;
+                i2_delta += (WORD16)val;
             }
 
             if(u2_sign_bit)
                 i2_delta = -i2_delta;
 
             ai2_mv[i] = (ai2_pred_mv[i] >> i4_shift) + i2_delta;
 
             if(ai2_mv[i] < i2_low)
             {
                 ai2_mv[i] += i2_range;
             }
 
             if(ai2_mv[i] > i2_high)
             {
                 ai2_mv[i] -= i2_range;
             }
             ai2_pred_mv[i] = (ai2_mv[i] << i4_shift);
 
         }
         if(ai2_dmv)
         {
             UWORD32 u4_val;
             ai2_dmv[i] = 0;
             IBITS_GET(u4_buf, u4_buf_nxt, u4_offset, u4_val, pu4_buf_aligned, 1)
             if(u4_val)
             {
                 IBITS_GET(u4_buf, u4_buf_nxt, u4_offset, u4_val, pu4_buf_aligned, 1)
                 ai2_dmv[i] = gai2_impeg2d_dec_mv[u4_val];
             }
         }
     }
     PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
 
 }
 /*******************************************************************************
 * Function name : impeg2d_dec_mv
 *
 * Description   : Decodes a motion vector and updates the predictors
 *
 * Arguments     :
 * stream        : Bitstream
 * predMv        : Prediction for the motion vectors
 * mv            : Motion vectors
 * fCode         : fcode to the used for the decoding
 * shift         : Shift value to be used. This will be equal to
 *                 (mv_format == "field") && (picture_structure == "Frame picture")
 *
 * Value Returned: None
 *******************************************************************************/
diff --git a/decoder/impeg2d_structs.h b/decoder/impeg2d_structs.h
index 48fdd13..57182c1 100644
--- a/decoder/impeg2d_structs.h
+++ b/decoder/impeg2d_structs.h
@@ -107,13 +107,13 @@ typedef struct
 
 struct _dec_mb_params_t;
 
-typedef UWORD8 pf_inv_quant_t (WORD16 *blk,
+typedef WORD32 pf_inv_quant_t (WORD16 *blk,
                                 UWORD8 *weighting_matrix,
                                 UWORD8 quant_scale,
                                 WORD32 intra_flag,
                                 WORD32 i4_num_coeffs,
                                 WORD16 *pi2_coeffs,
                                 UWORD8 *pu1_pos,
                                 const UWORD8   *scan,
                                 UWORD16 *u2_def_dc_pred,
                                 UWORD16 u2_intra_dc_precision);
diff --git a/decoder/impeg2d_vld.c b/decoder/impeg2d_vld.c
index 80ee403..30d7047 100644
--- a/decoder/impeg2d_vld.c
+++ b/decoder/impeg2d_vld.c
@@ -355,870 +355,870 @@ IMPEG2D_ERROR_CODES_T impeg2d_vld_inv_quant_mpeg1(
 /******************************************************************************
   *
   *  Function Name   : impeg2d_vld_inv_quant_mpeg2
   *
   *  Description     : Performs VLD operation for MPEG1/2
   *
   *  Arguments       :
   *  state           : VLCD state parameter
   *  regs            : Registers of VLCD
   *
   *  Values Returned : None
   ******************************************************************************/
 IMPEG2D_ERROR_CODES_T impeg2d_vld_inv_quant_mpeg2(
                              void  *pv_dec,           /* Decoder State */
                              WORD16       *pi2_out_addr,       /*!< Address where decoded symbols will be stored */
                              const UWORD8 *pu1_scan,          /*!< Scan table to be used */
                              UWORD16      u2_intra_flag,      /*!< Intra Macroblock or not */
                              UWORD16      u2_colr_comp,      /*!< 0 - Luma,1 - U comp, 2 - V comp */
                              UWORD16      u2_d_picture        /*!< D Picture or not */
                              )
 {
     UWORD8  *pu1_weighting_matrix;
-    WORD32 u4_sum_is_even;
+    WORD32 i4_sum;
     dec_state_t *ps_dec = (dec_state_t *)pv_dec;
     IMPEG2D_ERROR_CODES_T e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
 
     WORD16  pi2_coeffs[NUM_COEFFS];
     UWORD8  pi4_pos[NUM_COEFFS];
     WORD32  i4_num_coeffs;
 
     /* Perform VLD on the stream to get the coefficients and their positions */
     e_error = impeg2d_vld_decode(ps_dec, pi2_coeffs, pu1_scan, pi4_pos, u2_intra_flag,
                                  u2_colr_comp, u2_d_picture, ps_dec->u2_intra_vlc_format,
                                  ps_dec->u2_is_mpeg2, &i4_num_coeffs);
     if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)
     {
         return e_error;
     }
 
     /* For YUV420 format,Select the weighting matrix according to Table 7.5 */
     pu1_weighting_matrix = (u2_intra_flag == 1) ? ps_dec->au1_intra_quant_matrix:
                     ps_dec->au1_inter_quant_matrix;
 
     /*mismatch control for mpeg2*/
     /* Check if the block has only one non-zero coeff which is DC  */
     ps_dec->i4_last_value_one = 0;
 
     IMPEG2D_IQNT_INP_STATISTICS(pi2_out_addr, ps_dec->u4_non_zero_cols, ps_dec->u4_non_zero_rows);
 
     /* Inverse Quantize the Output of VLD */
     PROFILE_DISABLE_INVQUANT_IF0
 
     {
         /* Clear output matrix */
         PROFILE_DISABLE_MEMSET_RESBUF_IF0
         if (1 != (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))
         {
             ps_dec->pf_memset_16bit_8x8_linear_block (pi2_out_addr);
         }
 
-        u4_sum_is_even  = impeg2d_inv_quant_mpeg2(pi2_out_addr, pu1_weighting_matrix,
+        i4_sum  = impeg2d_inv_quant_mpeg2(pi2_out_addr, pu1_weighting_matrix,
                                                  ps_dec->u1_quant_scale, u2_intra_flag,
                                                  i4_num_coeffs, pi2_coeffs,
                                                  pi4_pos, pu1_scan,
                                                  &ps_dec->u2_def_dc_pred[u2_colr_comp],
                                                  ps_dec->u2_intra_dc_precision);
 
         if (0 != pi2_out_addr[0])
         {
             /* The first coeff might've become non-zero due to intra_dc_decision
              * value. So, check here after inverse quantization.
              */
             ps_dec->u4_non_zero_cols  |= 0x1;
             ps_dec->u4_non_zero_rows  |= 0x1;
         }
 
         if (1 == (ps_dec->u4_non_zero_cols | ps_dec->u4_non_zero_rows))
         {
             ps_dec->i4_last_value_one = 1 - (pi2_out_addr[0] & 1);
         }
         else
         {
             /*toggle last bit if sum is even ,else retain it as it is*/
-            pi2_out_addr[63]        ^= (u4_sum_is_even & 1);
+            pi2_out_addr[63]        ^= (i4_sum & 1);
 
             if (0 != pi2_out_addr[63])
             {
                 ps_dec->u4_non_zero_cols  |= 0x80;
                 ps_dec->u4_non_zero_rows  |= 0x80;
             }
         }
     }
 
     return e_error;
 }
 
 
 /******************************************************************************
 *
 *  Function Name   : impeg2d_vld_decode
 *
 *  Description     : Performs VLD operation for MPEG1/2
 *
 *  Arguments       :
 *  state           : VLCD state parameter
 *  regs            : Registers of VLCD
 *
 *  Values Returned : None
 ******************************************************************************/
 IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
     dec_state_t *ps_dec,
     WORD16      *pi2_outAddr,       /*!< Address where decoded symbols will be stored */
     const UWORD8 *pu1_scan,         /*!< Scan table to be used */
     UWORD8      *pu1_pos,       /*!< Scan table to be used */
     UWORD16     u2_intra_flag,      /*!< Intra Macroblock or not */
     UWORD16     u2_chroma_flag,     /*!< Chroma Block or not */
     UWORD16     u2_d_picture,       /*!< D Picture or not */
     UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */
     UWORD16     u2_mpeg2,          /*!< MPEG-2 or not */
     WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */
     )
 {
 
     UWORD32 u4_sym_len;
 
     UWORD32 u4_decoded_value;
-    UWORD32 u4_level_first_byte;
-    WORD32  u4_level;
+    WORD32 i4_level_first_byte;
+    WORD32  i4_level;
     UWORD32 u4_run, u4_numCoeffs;
     UWORD32 u4_buf;
     UWORD32 u4_buf_nxt;
     UWORD32 u4_offset;
     UWORD32 *pu4_buf_aligned;
     UWORD32 u4_bits;
     stream_t *ps_stream = &ps_dec->s_bit_stream;
     WORD32  u4_pos;
     UWORD32 u4_nz_cols;
     UWORD32 u4_nz_rows;
 
     *pi4_num_coeffs = 0;
 
     ps_dec->u4_non_zero_cols = 0;
     ps_dec->u4_non_zero_rows = 0;
     u4_nz_cols = ps_dec->u4_non_zero_cols;
     u4_nz_rows = ps_dec->u4_non_zero_rows;
 
     GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
     /**************************************************************************/
     /* Decode the DC coefficient in case of Intra block                       */
     /**************************************************************************/
     if(u2_intra_flag)
     {
         WORD32 dc_size;
         WORD32 dc_diff;
         WORD32 maxLen;
         WORD32 idx;
 
 
         maxLen = MPEG2_DCT_DC_SIZE_LEN;
         idx = 0;
         if(u2_chroma_flag != 0)
         {
             maxLen += 1;
             idx++;
         }
 
 
         {
             WORD16  end = 0;
             UWORD32 maxLen_tmp = maxLen;
             UWORD16 m_iBit;
 
 
             /* Get the maximum number of bits needed to decode a symbol */
             IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)
             do
             {
                 maxLen_tmp--;
                 /* Read one bit at a time from the variable to decode the huffman code */
                 m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);
 
                 /* Get the next node pointer or the symbol from the tree */
                 end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];
             }while(end > 0);
             dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;
 
             /* Flush the appropriate number of bits from the stream */
             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)
 
         }
 
 
 
         if (dc_size != 0)
         {
             UWORD32 u4_bits;
 
             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)
             dc_diff = u4_bits;
 
             if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?
                 dc_diff -= (1 << dc_size) - 1;
         }
         else
         {
             dc_diff = 0;
         }
 
 
         pi2_outAddr[*pi4_num_coeffs]    = dc_diff;
         /* This indicates the position of the coefficient. Since this is the DC
          * coefficient, we put the position as 0.
          */
         pu1_pos[*pi4_num_coeffs]    = pu1_scan[0];
         (*pi4_num_coeffs)++;
 
         if (0 != dc_diff)
         {
             u4_nz_cols |= 0x01;
             u4_nz_rows |= 0x01;
         }
 
         u4_numCoeffs = 1;
     }
     /**************************************************************************/
     /* Decoding of first AC coefficient in case of non Intra block            */
     /**************************************************************************/
     else
     {
         /* First symbol can be 1s */
         UWORD32 u4_bits;
 
         IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)
 
         if(u4_bits == 1)
         {
 
             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)
             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)
             if(u4_bits == 1)
             {
                 pi2_outAddr[*pi4_num_coeffs] = -1;
             }
             else
             {
                 pi2_outAddr[*pi4_num_coeffs] = 1;
             }
 
             /* This indicates the position of the coefficient. Since this is the DC
              * coefficient, we put the position as 0.
              */
             pu1_pos[*pi4_num_coeffs]    = pu1_scan[0];
             (*pi4_num_coeffs)++;
             u4_numCoeffs = 1;
 
             u4_nz_cols |= 0x01;
             u4_nz_rows |= 0x01;
         }
         else
         {
             u4_numCoeffs = 0;
         }
     }
     if (1 == u2_d_picture)
     {
         PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
         ps_dec->u4_non_zero_cols  = u4_nz_cols;
         ps_dec->u4_non_zero_rows  = u4_nz_rows;
         return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);
     }
 
 
 
         if (1 == u2_intra_vlc_format && u2_intra_flag)
         {
 
             while(1)
             {
                 //Putting the impeg2d_dec_ac_coeff_one function inline.
 
                 UWORD32 lead_zeros;
                 WORD16 DecodedValue;
 
                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)
 
                 /* There cannot be more than 11 leading zeros in the decoded
                  * symbol. The symbol is only 17 bits long, so we subtract 15.
                  */
                 lead_zeros = CLZ(u4_bits) - 15;
                 if (lead_zeros > 11)
                 {
                     return IMPEG2D_MB_DATA_DECODE_ERR;
                 }
 
                 DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
                 u4_sym_len = (DecodedValue & 0xf);
-                u4_level = DecodedValue >> 9;
+                i4_level = DecodedValue >> 9;
                 /* One table lookup */
-                if(0 != u4_level)
+                if(0 != i4_level)
                 {
                     u4_run = ((DecodedValue >> 4) & 0x1f);
                     u4_numCoeffs       += u4_run;
                     if (u4_numCoeffs >= NUM_COEFFS)
                     {
                         return IMPEG2D_MB_TEX_DECODE_ERR;
                     }
                     u4_pos             = pu1_scan[u4_numCoeffs++];
                     pu1_pos[*pi4_num_coeffs]    = u4_pos;
 
                     FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
-                    pi2_outAddr[*pi4_num_coeffs]    = u4_level;
+                    pi2_outAddr[*pi4_num_coeffs]    = i4_level;
 
                     (*pi4_num_coeffs)++;
                 }
                 else
                 {
                     if (DecodedValue == END_OF_BLOCK_ONE)
                     {
                         u4_sym_len = 4;
 
                         break;
                     }
                     else
                     {
                         /*Second table lookup*/
                         lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */
                         if (0 != lead_zeros)
                         {
 
                             u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;
 
                             /* Flush the number of bits */
                             if (1 == lead_zeros)
                             {
                                 u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;
                             }
                             else
                             {
                                 u4_sym_len         = 11 + lead_zeros;
                             }
                             /* flushing */
                             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
 
                             /* Calculate the address */
                             u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;
 
                             DecodedValue    = gau2_impeg2d_tab_one_10_16[u4_bits];
 
                             u4_run = BITS(DecodedValue, 8,4);
-                            u4_level = ((WORD16) DecodedValue) >> 9;
+                            i4_level = ((WORD16) DecodedValue) >> 9;
 
                             u4_numCoeffs       += u4_run;
                             if (u4_numCoeffs >= NUM_COEFFS)
                             {
                                 return IMPEG2D_MB_TEX_DECODE_ERR;
                             }
                             u4_pos             = pu1_scan[u4_numCoeffs++];
                             pu1_pos[*pi4_num_coeffs]    = u4_pos;
-                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;
+                            pi2_outAddr[*pi4_num_coeffs]    = i4_level;
                             (*pi4_num_coeffs)++;
                         }
                         /*********************************************************************/
                         /* MPEG2 Escape Code                                                 */
                         /*********************************************************************/
                         else if(u2_mpeg2 == 1)
                         {
                             u4_sym_len         = 6;
                             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                 IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                                 u4_decoded_value    = u4_bits;
                             u4_run             = (u4_decoded_value >> 12);
-                            u4_level           = (u4_decoded_value & 0x0FFF);
+                            i4_level           = (u4_decoded_value & 0x0FFF);
 
-                            if (u4_level)
-                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));
+                            if (i4_level)
+                                i4_level = (i4_level - ((i4_level & 0x0800) << 1));
 
                             u4_numCoeffs       += u4_run;
                             if (u4_numCoeffs >= NUM_COEFFS)
                             {
                                 return IMPEG2D_MB_TEX_DECODE_ERR;
                             }
                             u4_pos             = pu1_scan[u4_numCoeffs++];
                             pu1_pos[*pi4_num_coeffs]    = u4_pos;
-                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;
+                            pi2_outAddr[*pi4_num_coeffs]    = i4_level;
                             (*pi4_num_coeffs)++;
                         }
                         /*********************************************************************/
                         /* MPEG1 Escape Code                                                 */
                         /*********************************************************************/
                         else
                         {
                             /*-----------------------------------------------------------
                             * MPEG-1 Stream
                             *
                             * <See D.9.3 of MPEG-2> Run-level escape syntax
                             * Run-level values that cannot be coded with a VLC are coded
                             * by the escape code '0000 01' followed by
                             * either a 14-bit FLC (127 <= level <= 127),
                             * or a 22-bit FLC (255 <= level <= 255).
                             * This is described in Annex B,B.5f of MPEG-1.standard
                             *-----------------------------------------------------------*/
 
                             /*-----------------------------------------------------------
                             * First 6 bits are the value of the Run. Next is First 8 bits
                             * of Level. These bits decide whether it is 14 bit FLC or
                             * 22-bit FLC.
                             *
                             * If( first 8 bits of Level == '1000000' or '00000000')
                             *      then its is 22-bit FLC.
                             * else
                             *      it is 14-bit FLC.
                             *-----------------------------------------------------------*/
                             u4_sym_len         = 6;
                             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                                 IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                                 u4_decoded_value     = u4_bits;
                             u4_run              = (u4_decoded_value >> 8);
-                            u4_level_first_byte = (u4_decoded_value & 0x0FF);
-                            if(u4_level_first_byte & 0x7F)
+                            i4_level_first_byte = (u4_decoded_value & 0x0FF);
+                            if(i4_level_first_byte & 0x7F)
                             {
                                 /*-------------------------------------------------------
                                 * First 8 bits of level are neither 1000000 nor 00000000
                                 * Hence 14-bit FLC (Last 8 bits are used to get level)
                                 *
                                 *  Level = (msb of Level_First_Byte is 1)?
                                 *          Level_First_Byte - 256 : Level_First_Byte
                                 *-------------------------------------------------------*/
-                                u4_level = (u4_level_first_byte -
-                                    ((u4_level_first_byte & 0x80) << 1));
+                                i4_level = (i4_level_first_byte -
+                                    ((i4_level_first_byte & 0x80) << 1));
                             }
                             else
                             {
                                 /*-------------------------------------------------------
                                 * Next 8 bits are either 1000000 or 00000000
                                 * Hence 22-bit FLC (Last 16 bits are used to get level)
                                 *
                                 *  Level = (msb of Level_First_Byte is 1)?
                                 *          Level_Second_Byte - 256 : Level_Second_Byte
                                 *-------------------------------------------------------*/
                                 IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
-                                    u4_level = u4_bits;
-                                u4_level = (u4_level - (u4_level_first_byte << 1));
+                                    i4_level = u4_bits;
+                                i4_level = (i4_level - (i4_level_first_byte << 1));
                             }
                             u4_numCoeffs += u4_run;
                             if (u4_numCoeffs >= NUM_COEFFS)
                             {
                                 return IMPEG2D_MB_TEX_DECODE_ERR;
                             }
 
                             u4_pos = pu1_scan[u4_numCoeffs++];
 
                             pu1_pos[*pi4_num_coeffs]    = u4_pos;
-                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;
+                            pi2_outAddr[*pi4_num_coeffs]    = i4_level;
                             (*pi4_num_coeffs)++;
                         }
                     }
                 }
 
                 u4_nz_cols |= 1 << (u4_pos & 0x7);
                 u4_nz_rows |= 1 << (u4_pos >> 0x3);
 
             }
             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
         }
         else
         {
             // Inline
             while(1)
             {
 
                 UWORD32 lead_zeros;
                 UWORD16 DecodedValue;
 
                 u4_sym_len = 17;
                 IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)
 
                 /* There cannot be more than 11 leading zeros in the decoded
                  * symbol. The symbol is only 17 bits long, so we subtract 15.
                  */
                 lead_zeros = CLZ(u4_bits) - 15;
                 if (lead_zeros > 11)
                 {
                     return IMPEG2D_MB_DATA_DECODE_ERR;
                 }
 
                 DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
                 u4_sym_len = BITS(DecodedValue, 3, 0);
-                u4_level = ((WORD16) DecodedValue) >> 9;
+                i4_level = ((WORD16) DecodedValue) >> 9;
 
-                if (0 != u4_level)
+                if (0 != i4_level)
                 {
                     u4_run = BITS(DecodedValue, 8,4);
 
                     u4_numCoeffs       += u4_run;
                     if (u4_numCoeffs >= NUM_COEFFS)
                     {
                         return IMPEG2D_MB_TEX_DECODE_ERR;
                     }
 
                     u4_pos                 = pu1_scan[u4_numCoeffs++];
                     pu1_pos[*pi4_num_coeffs]    = u4_pos;
 
                     FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
-                    pi2_outAddr[*pi4_num_coeffs]    = u4_level;
+                    pi2_outAddr[*pi4_num_coeffs]    = i4_level;
                     (*pi4_num_coeffs)++;
                 }
                 else
                 {
                     if(DecodedValue == END_OF_BLOCK_ZERO)
                     {
                         u4_sym_len = 2;
 
                         break;
                     }
                     else
                     {
                         lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */
                         /*Second table lookup*/
                         if (0 != lead_zeros)
                         {
                             u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;
 
                             /* Flush the number of bits */
                             u4_sym_len         = 11 + lead_zeros;
 
                             /* Calculate the address */
                             u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;
 
                             DecodedValue    = gau2_impeg2d_tab_zero_10_16[u4_bits];
 
                             u4_run = BITS(DecodedValue, 8,4);
-                            u4_level = ((WORD16) DecodedValue) >> 9;
+                            i4_level = ((WORD16) DecodedValue) >> 9;
 
                             u4_numCoeffs       += u4_run;
                             if (u4_numCoeffs >= NUM_COEFFS)
                             {
                                 return IMPEG2D_MB_TEX_DECODE_ERR;
                             }
 
                             u4_pos                 = pu1_scan[u4_numCoeffs++];
                             pu1_pos[*pi4_num_coeffs]    = u4_pos;
                             if (1 == lead_zeros)
                                 u4_sym_len--;
                             /* flushing */
                             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
-                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;
+                            pi2_outAddr[*pi4_num_coeffs]    = i4_level;
 
                             (*pi4_num_coeffs)++;
                         }
                         /*Escape Sequence*/
                         else if(u2_mpeg2 == 1)
                         {
                             u4_sym_len         = 6;
                             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
                             u4_decoded_value    = u4_bits;
                             u4_run             = (u4_decoded_value >> 12);
-                            u4_level           = (u4_decoded_value & 0x0FFF);
+                            i4_level           = (u4_decoded_value & 0x0FFF);
 
-                            if (u4_level)
-                                u4_level = (u4_level - ((u4_level & 0x0800) << 1));
+                            if (i4_level)
+                                i4_level = (i4_level - ((i4_level & 0x0800) << 1));
 
                             u4_numCoeffs           += u4_run;
                             if (u4_numCoeffs >= NUM_COEFFS)
                             {
                                 return IMPEG2D_MB_TEX_DECODE_ERR;
                             }
 
                             u4_pos                 = pu1_scan[u4_numCoeffs++];
                             pu1_pos[*pi4_num_coeffs]    = u4_pos;
-                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;
+                            pi2_outAddr[*pi4_num_coeffs]    = i4_level;
 
                             (*pi4_num_coeffs)++;
                         }
                         /*********************************************************************/
                         /* MPEG1 Escape Code                                                 */
                         /*********************************************************************/
                         else
                         {
                             /*-----------------------------------------------------------
                             * MPEG-1 Stream
                             *
                             * <See D.9.3 of MPEG-2> Run-level escape syntax
                             * Run-level values that cannot be coded with a VLC are coded
                             * by the escape code '0000 01' followed by
                             * either a 14-bit FLC (127 <= level <= 127),
                             * or a 22-bit FLC (255 <= level <= 255).
                             * This is described in Annex B,B.5f of MPEG-1.standard
                             *-----------------------------------------------------------*/
 
                             /*-----------------------------------------------------------
                             * First 6 bits are the value of the Run. Next is First 8 bits
                             * of Level. These bits decide whether it is 14 bit FLC or
                             * 22-bit FLC.
                             *
                             * If( first 8 bits of Level == '1000000' or '00000000')
                             *      then its is 22-bit FLC.
                             * else
                             *      it is 14-bit FLC.
                             *-----------------------------------------------------------*/
                             u4_sym_len             = 6;
                             FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
                             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
                             u4_decoded_value        = u4_bits;
                             u4_run                 = (u4_decoded_value >> 8);
-                            u4_level_first_byte    = (u4_decoded_value & 0x0FF);
-                            if(u4_level_first_byte & 0x7F)
+                            i4_level_first_byte    = (u4_decoded_value & 0x0FF);
+                            if(i4_level_first_byte & 0x7F)
                             {
                                 /*-------------------------------------------------------
                                 * First 8 bits of level are neither 1000000 nor 00000000
                                 * Hence 14-bit FLC (Last 8 bits are used to get level)
                                 *
                                 *  Level = (msb of Level_First_Byte is 1)?
                                 *          Level_First_Byte - 256 : Level_First_Byte
                                 *-------------------------------------------------------*/
-                                u4_level = (u4_level_first_byte -
-                                    ((u4_level_first_byte & 0x80) << 1));
+                                i4_level = (i4_level_first_byte -
+                                    ((i4_level_first_byte & 0x80) << 1));
                             }
                             else
                             {
                                 /*-------------------------------------------------------
                                 * Next 8 bits are either 1000000 or 00000000
                                 * Hence 22-bit FLC (Last 16 bits are used to get level)
                                 *
                                 *  Level = (msb of Level_First_Byte is 1)?
                                 *          Level_Second_Byte - 256 : Level_Second_Byte
                                 *-------------------------------------------------------*/
                                 IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
-                                u4_level = u4_bits;
-                                u4_level = (u4_level - (u4_level_first_byte << 1));
+                                i4_level = u4_bits;
+                                i4_level = (i4_level - (i4_level_first_byte << 1));
                             }
                             u4_numCoeffs           += u4_run;
                             if (u4_numCoeffs >= NUM_COEFFS)
                             {
                                 return IMPEG2D_MB_TEX_DECODE_ERR;
                             }
 
                             u4_pos                 = pu1_scan[u4_numCoeffs++];
                             pu1_pos[*pi4_num_coeffs]    = u4_pos;
-                            pi2_outAddr[*pi4_num_coeffs]    = u4_level;
+                            pi2_outAddr[*pi4_num_coeffs]    = i4_level;
 
                             (*pi4_num_coeffs)++;
                         }
                     }
                 }
 
                 u4_nz_cols |= 1 << (u4_pos & 0x7);
                 u4_nz_rows |= 1 << (u4_pos >> 0x3);
 
             }
 
             IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
 
         }
 
         PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
 
         ps_dec->u4_non_zero_cols  = u4_nz_cols;
         ps_dec->u4_non_zero_rows  = u4_nz_rows;
 
             return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
 }
 
 
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : impeg2d_inv_quant_mpeg1                                   */
 /*                                                                           */
 /*  Description   : Inverse quantizes the output of VLD                      */
 /*                                                                           */
 /*  Inputs        :                                                          */
 /*  blk,              - Block to be inverse quantized                        */
 /*  weighting_matrix  - Matrix to be used in inverse quant                   */
 /*  intra_dc_precision- Precision reqd to scale intra DC value               */
 /*  quant_scale       - Quanization scale for inverse quant                  */
 /*  intra_flag        - Intra or Not                                         */
 /*                                                                           */
 /*  Globals       : None                                                     */
 /*                                                                           */
 /*  Processing    : Implements the inverse quantize equation                 */
 /*                                                                           */
 /*  Outputs       : Inverse quantized values in the block                    */
 /*                                                                           */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : None                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes                              */
 /*         05 09 2005   Harish M        First Version                        */
 /*                                                                           */
 /*****************************************************************************/
-UWORD8 impeg2d_inv_quant_mpeg1(WORD16 *pi2_blk,
+WORD32 impeg2d_inv_quant_mpeg1(WORD16 *pi2_blk,
                               UWORD8 *pu1_weighting_matrix,
                               UWORD8 u1_quant_scale,
                               WORD32 u4_intra_flag,
                               WORD32 i4_num_coeffs,
                               WORD16 *pi2_coeffs,
                               UWORD8 *pu1_pos,
                               const UWORD8 *pu1_scan,
                               UWORD16 *pu2_def_dc_pred,
                               UWORD16 u2_intra_dc_precision)
 {
     UWORD16 i4_pos;
 
     WORD32  i4_iter;
 
     /* Inverse Quantize the predicted DC value for intra MB*/
     if(u4_intra_flag == 1)
     {
         /**************************************************************************/
         /* Decode the DC coefficient in case of Intra block and also update       */
         /* DC predictor value of the corresponding color component                */
         /**************************************************************************/
         {
             pi2_coeffs[0]   += *pu2_def_dc_pred;
             *pu2_def_dc_pred      = pi2_coeffs[0];
             pi2_coeffs[0]   <<= (3 - u2_intra_dc_precision);
             pi2_coeffs[0]   = CLIP_S12(pi2_coeffs[0]);
         }
 
         pi2_blk[pu1_scan[0]]  = pi2_coeffs[0];
     }
     /************************************************************************/
     /* Inverse quantization of other DCT coefficients                       */
     /************************************************************************/
     for(i4_iter = u4_intra_flag; i4_iter < i4_num_coeffs; i4_iter++)
     {
 
         WORD16 sign;
         WORD32 temp, temp1;
 
         /* Position is the inverse scan of the index stored */
         i4_pos      = pu1_pos[i4_iter];
         pi2_blk[i4_pos] = pi2_coeffs[i4_iter];
 
         sign = SIGN(pi2_blk[i4_pos]);
         temp = ABS(pi2_blk[i4_pos] << 1);
 
         /* pi2_coeffs has only non-zero elements. So no need to check
          * if the coeff is non-zero.
          */
         temp = temp + (1 * !u4_intra_flag);
 
         temp = temp * pu1_weighting_matrix[i4_pos] * u1_quant_scale;
 
         temp = temp >> 5;
 
         temp1 = temp | 1;
 
         temp1 = (temp1 > temp) ? (temp1 - temp) : (temp - temp1);
 
         temp = temp - temp1;
 
         if(temp < 0)
         {
             temp = 0;
         }
 
         temp = temp * sign;
 
         temp = CLIP_S12(temp);
 
         pi2_blk[i4_pos] = temp;
     }
 
     /*return value is used in the case of mpeg2 for mismatch control*/
     return  (0);
 } /* End of inv_quant() */
 
 
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : impeg2d_inv_quant_mpeg2                                   */
 /*                                                                           */
 /*  Description   : Inverse quantizes the output of VLD                      */
 /*                                                                           */
 /*  Inputs        :                                                          */
 /*  blk,              - Block to be inverse quantized                        */
 /*  weighting_matrix  - Matrix to be used in inverse quant                   */
 /*  intra_dc_precision- Precision reqd to scale intra DC value               */
 /*  quant_scale       - Quanization scale for inverse quant                  */
 /*  intra_flag        - Intra or Not                                         */
 /*                                                                           */
 /*  Globals       : None                                                     */
 /*                                                                           */
 /*  Processing    : Implements the inverse quantize equation                 */
 /*                                                                           */
 /*  Outputs       : Inverse quantized values in the block                    */
 /*                                                                           */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : None                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes                              */
 /*         05 09 2005   Harish M        First Version                        */
 /*                                                                           */
 /*****************************************************************************/
-UWORD8 impeg2d_inv_quant_mpeg2(WORD16 *pi2_blk,
+WORD32 impeg2d_inv_quant_mpeg2(WORD16 *pi2_blk,
                               UWORD8 *pu1_weighting_matrix,
                               UWORD8 u1_quant_scale,
                               WORD32 u4_intra_flag,
                               WORD32 i4_num_coeffs,
                               WORD16 *pi2_coeffs,
                               UWORD8 *pu1_pos,
                               const UWORD8 *pu1_scan,
                               UWORD16 *pu2_def_dc_pred,
                               UWORD16 u2_intra_dc_precision)
 {
 
     WORD32  i4_pos;
     /* Used for Mismatch control */
-    UWORD32 sum;
+    WORD32 sum;
 
     WORD32  i4_iter;
 
     sum = 0;
 
     /* Inverse Quantize the predicted DC value for intra MB*/
     if(u4_intra_flag == 1)
     {
         /**************************************************************************/
         /* Decode the DC coefficient in case of Intra block and also update       */
         /* DC predictor value of the corresponding color component                */
         /**************************************************************************/
         {
             pi2_coeffs[0]   += *pu2_def_dc_pred;
             *pu2_def_dc_pred      = pi2_coeffs[0];
             pi2_coeffs[0]   <<= (3 - u2_intra_dc_precision);
             pi2_coeffs[0]   = CLIP_S12(pi2_coeffs[0]);
         }
 
         pi2_blk[pu1_scan[0]]  = pi2_coeffs[0];
         sum = pi2_blk[0];
     }
 
     /************************************************************************/
     /* Inverse quantization of other DCT coefficients                       */
     /************************************************************************/
     for(i4_iter = u4_intra_flag; i4_iter < i4_num_coeffs; i4_iter++)
     {
         WORD16 sign;
         WORD32 temp;
         /* Position is the inverse scan of the index stored */
         i4_pos      = pu1_pos[i4_iter];
         pi2_blk[i4_pos] = pi2_coeffs[i4_iter];
 
         sign = SIGN(pi2_blk[i4_pos]);
         temp = ABS(pi2_blk[i4_pos] << 1);
         temp = temp + (1 * !u4_intra_flag);
         temp = temp * pu1_weighting_matrix[i4_pos] * u1_quant_scale;
 
         temp = temp >> 5;
 
         temp = temp * sign;
 
         temp = CLIP_S12(temp);
 
         pi2_blk[i4_pos] = temp;
 
         sum += temp;
     }
     return (sum ^ 1);
 } /* End of inv_quant() */
diff --git a/libmpeg2dec_blacklist.txt b/libmpeg2dec_blacklist.txt
new file mode 100644
index 0000000..0c5246b
--- /dev/null
+++ b/libmpeg2dec_blacklist.txt
@@ -0,0 +1,82 @@
+[integer]
+fun:impeg2d_dec_pic_disp_ext
+# decoder/impeg2d_vld.c:1221:13: runtime error: unsigned integer overflow: 248 + 4294967284 cannot be represented in type 'unsigned int'
+fun:impeg2d_inv_quant_mpeg2
+
+# Performance related
+fun:impeg2d_set_mc_params
+
+[cfi]
+# CFI blacklist for external/libmpeg2
+# assembly functions where CFI has issues
+fun:impeg2_idct_recon_dc_a9q
+fun:impeg2_idct_recon_dc_mismatch_a9q
+fun:impeg2_idct_recon_a9q
+fun:impeg2_idct_recon_a9q
+fun:impeg2_interpolate_a9q
+fun:impeg2_copy_mb_a9q
+fun:impeg2_mc_fullx_halfy_8x8_a9q
+fun:impeg2_mc_halfx_fully_8x8_a9q
+fun:impeg2_mc_halfx_halfy_8x8_a9q
+fun:impeg2_mc_fullx_fully_8x8_a9q
+fun:impeg2_memset_8bit_8x8_block_a9q
+fun:impeg2_memset0_16bit_8x8_linear_block_a9q
+fun:impeg2_fmt_conv_yuv420p_to_yuv420sp_uv_a9q
+fun:impeg2_fmt_conv_yuv420p_to_yuv420sp_vu_a9q
+fun:impeg2_idct_recon_dc_av8
+fun:impeg2_idct_recon_dc_mismatch_av8
+fun:impeg2_idct_recon_av8
+fun:impeg2_idct_recon_av8
+fun:impeg2_interpolate_av8
+fun:impeg2_copy_mb_av8
+fun:impeg2_mc_fullx_halfy_8x8_av8
+fun:impeg2_mc_halfx_fully_8x8_av8
+fun:impeg2_mc_halfx_halfy_8x8_av8
+fun:impeg2_mc_fullx_fully_8x8_av8
+fun:impeg2_memset_8bit_8x8_block_av8
+fun:impeg2_memset0_16bit_8x8_linear_block_av8
+fun:impeg2_fmt_conv_yuv420p_to_yuv420sp_uv_av8
+fun:impeg2_fmt_conv_yuv420p_to_yuv420sp_vu_av8
+fun:impeg2_idct_recon_dc_sse42
+fun:impeg2_idct_recon_dc_mismatch_sse42
+fun:impeg2_idct_recon_sse42
+fun:impeg2_idct_recon_sse42
+fun:impeg2_copy_mb_sse42
+fun:impeg2_interpolate_sse42
+fun:impeg2_mc_halfx_halfy_8x8_sse42
+fun:impeg2_mc_halfx_fully_8x8_sse42
+fun:impeg2_mc_fullx_halfy_8x8_sse42
+fun:impeg2_mc_fullx_fully_8x8_sse42
+fun:impeg2_memset_8bit_8x8_block_sse42
+fun:impeg2_memset0_16bit_8x8_linear_block_sse42
+fun:icv_sad_8x4_ssse3
+fun:icv_variance_8x4_ssse3
+fun:ideint_spatial_filter_ssse3
+fun:ideint_cac_8x8_ssse3
+fun:icv_sad_8x4_a9
+fun:icv_variance_8x4_a9
+fun:ideint_spatial_filter_a9
+fun:ideint_cac_8x8_a9
+fun:icv_sad_8x4_av8
+fun:icv_variance_8x4_av8
+fun:ideint_spatial_filter_av8
+fun:ideint_cac_8x8_av8
+fun:impeg2d_mc_fullx_halfy
+fun:impeg2d_mc_halfx_halfy
+fun:impeg2d_mc_fullx_fully
+fun:impeg2d_mc_halfx_fully
+fun:impeg2d_dec_p_b_slice
+fun:impeg2d_dec_d_slice
+fun:impeg2d_dec_i_slice
+fun:impeg2d_motion_comp
+fun:impeg2d_motion_comp_recon_buf
+fun:impeg2d_mc_frm_dual_prime
+fun:impeg2d_mc_fld_dual_prime
+fun:impeg2d_mc_4mv
+fun:impeg2d_mc_2mv
+fun:impeg2d_dec_skip_b_mb
+fun:impeg2d_vld_inv_quant_mpeg1
+fun:impeg2d_vld_inv_quant_mpeg2
+fun:impeg2d_format_convert
+fun:ideint_process
+fun:impeg2d_dec_skip_p_mb
