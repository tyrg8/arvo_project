commit 418ff172c11c5f99fc15af376fb6cd5c9ac14946
Author: Abtin Keshavarzian <abtink@google.com>
Date:   Mon Aug 21 13:19:18 2017 -0700

    Managing off-mesh-routes and their mapping to interface routes
    
    This commit adds support for managing off-mesh-routes from Thread
    network. All off-mesh routes (aka external routes) from NCP or user-
    added (e.g, using `add_external_route()`) are stored in a
    `std::multimap` list `mOffMeshRoutes`. Property "Thread:OffMeshRoutes"
    can be used to get the full list which contains information about the
    origin of each entry along with preference level.
    
    This commit also adds logic to manage the routes on wpan network
    interface corresponding to the off-mesh routes from the network: A
    route is added on wpan network interface if there is an off-mesh route
    on at least one other device within network AND either the same route
    is not added by the device itself, or if it is added, it has a lower
    preference level.
    
    The change in this commit ensures that user-added off-mesh routes are
    restored on NCP in case of an NCP reset.

diff --git a/src/ncp-dummy/DummyNCPInstance.cpp b/src/ncp-dummy/DummyNCPInstance.cpp
index 5522fea..031450d 100644
--- a/src/ncp-dummy/DummyNCPInstance.cpp
+++ b/src/ncp-dummy/DummyNCPInstance.cpp
@@ -128,3 +128,17 @@ DummyNCPInstance::remove_on_mesh_prefix_on_ncp(const struct in6_addr &addr, uint
 {
 	return;
 }
+
+void
+DummyNCPInstance::add_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+	bool stable, CallbackWithStatus cb)
+{
+	return;
+}
+
+void
+DummyNCPInstance::remove_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+	bool stable, CallbackWithStatus cb)
+{
+	return;
+}
diff --git a/src/ncp-dummy/DummyNCPInstance.h b/src/ncp-dummy/DummyNCPInstance.h
index f9d4cc7..e3c311d 100644
--- a/src/ncp-dummy/DummyNCPInstance.h
+++ b/src/ncp-dummy/DummyNCPInstance.h
@@ -66,6 +66,11 @@ protected:
 	virtual void remove_on_mesh_prefix_on_ncp(const struct in6_addr &addr, uint8_t prefix_len, uint8_t flags, bool stable,
 					CallbackWithStatus cb);
 
+	virtual void add_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+					bool stable, CallbackWithStatus cb);
+	virtual void remove_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+					bool stable, CallbackWithStatus cb);
+
 public:
 	static bool setup_property_supported_by_class(const std::string& prop_name);
 
diff --git a/src/ncp-spinel/SpinelNCPControlInterface.cpp b/src/ncp-spinel/SpinelNCPControlInterface.cpp
index b3915af..24b9c3c 100644
--- a/src/ncp-spinel/SpinelNCPControlInterface.cpp
+++ b/src/ncp-spinel/SpinelNCPControlInterface.cpp
@@ -249,34 +249,52 @@ bail:
 
 void
 SpinelNCPControlInterface::add_external_route(
-	const struct in6_addr *prefix,
-	int prefix_len_in_bits,
+	const struct in6_addr *route,
+	int prefix_len,
 	int domain_id,
 	ExternalRoutePriority priority,
 	CallbackWithStatus cb
 ) {
-	require_action(prefix != NULL, bail, cb(kWPANTUNDStatus_InvalidArgument));
-	require_action(prefix_len_in_bits >= 0, bail, cb(kWPANTUNDStatus_InvalidArgument));
-	require_action(prefix_len_in_bits <= IPV6_MAX_PREFIX_LENGTH, bail, cb(kWPANTUNDStatus_InvalidArgument));
+	require_action(route != NULL, bail, cb(kWPANTUNDStatus_InvalidArgument));
+	require_action(prefix_len >= 0, bail, cb(kWPANTUNDStatus_InvalidArgument));
+	require_action(prefix_len <= IPV6_MAX_PREFIX_LENGTH, bail, cb(kWPANTUNDStatus_InvalidArgument));
 	require_action(mNCPInstance->mEnabled, bail, cb(kWPANTUNDStatus_InvalidWhenDisabled));
 
-	mNCPInstance->start_new_task(SpinelNCPTaskSendCommand::Factory(mNCPInstance)
-		.set_callback(cb)
-		.add_command(SpinelPackData(
-			SPINEL_FRAME_PACK_CMD_PROP_VALUE_INSERT(
-				SPINEL_DATATYPE_IPv6ADDR_S
-				SPINEL_DATATYPE_UINT8_S
-				SPINEL_DATATYPE_BOOL_S
-				SPINEL_DATATYPE_UINT8_S
-			),
-			SPINEL_PROP_THREAD_OFF_MESH_ROUTES,
-			prefix,
-			prefix_len_in_bits,
-			true,
-			convert_external_route_priority_to_flags(priority)
-		))
-		.set_lock_property(SPINEL_PROP_THREAD_ALLOW_LOCAL_NET_DATA_CHANGE)
-		.finish()
+	mNCPInstance->route_was_added(
+		SpinelNCPInstance::kOriginUser,
+		*route,
+		prefix_len,
+		priority,
+		true,     // stable
+		0,        // rlco16 (ignored for user added routes)
+		true,     // next_hop_is_host
+		cb
+	);
+
+bail:
+	return;
+}
+
+void
+SpinelNCPControlInterface::remove_external_route(
+	const struct in6_addr *route,
+	int prefix_len,
+	int domain_id,
+	CallbackWithStatus cb
+) {
+	require_action(route != NULL, bail, cb(kWPANTUNDStatus_InvalidArgument));
+	require_action(prefix_len >= 0, bail, cb(kWPANTUNDStatus_InvalidArgument));
+	require_action(prefix_len <= IPV6_MAX_PREFIX_LENGTH, bail, cb(kWPANTUNDStatus_InvalidArgument));
+	require_action(mNCPInstance->mEnabled, bail, cb(kWPANTUNDStatus_InvalidWhenDisabled));
+
+	mNCPInstance->route_was_removed(
+		SpinelNCPInstance::kOriginUser,
+		*route,
+		prefix_len,
+		NCPControlInterface::ROUTE_MEDIUM_PREFERENCE, // (value is ignored when removing user-added routes)
+		true,                                         // stable
+		0,                                            // rlco16 (value is ignored for user-added routes)
+		cb
 	);
 
 bail:
@@ -333,41 +351,6 @@ bail:
 	return;
 }
 
-void
-SpinelNCPControlInterface::remove_external_route(
-	const struct in6_addr *prefix,
-	int prefix_len_in_bits,
-	int domain_id,
-	CallbackWithStatus cb
-) {
-	require_action(prefix != NULL, bail, cb(kWPANTUNDStatus_InvalidArgument));
-	require_action(prefix_len_in_bits >= 0, bail, cb(kWPANTUNDStatus_InvalidArgument));
-	require_action(prefix_len_in_bits <= IPV6_MAX_PREFIX_LENGTH, bail, cb(kWPANTUNDStatus_InvalidArgument));
-	require_action(mNCPInstance->mEnabled, bail, cb(kWPANTUNDStatus_InvalidWhenDisabled));
-
-	mNCPInstance->start_new_task(SpinelNCPTaskSendCommand::Factory(mNCPInstance)
-		.set_callback(cb)
-		.add_command(SpinelPackData(
-			SPINEL_FRAME_PACK_CMD_PROP_VALUE_REMOVE(
-				SPINEL_DATATYPE_IPv6ADDR_S
-				SPINEL_DATATYPE_UINT8_S
-				SPINEL_DATATYPE_BOOL_S
-				SPINEL_DATATYPE_UINT8_S
-			),
-			SPINEL_PROP_THREAD_OFF_MESH_ROUTES,
-			prefix,
-			prefix_len_in_bits,
-			true,
-			0
-		))
-		.set_lock_property(SPINEL_PROP_THREAD_ALLOW_LOCAL_NET_DATA_CHANGE)
-		.finish()
-	);
-
-bail:
-	return;
-}
-
 void
 SpinelNCPControlInterface::handle_permit_join_timeout(Timer *timer, int seconds)
 {
@@ -665,53 +648,6 @@ SpinelNCPControlInterface::property_remove_value(
 // ----------------------------------------------------------------------------
 // MARK: -
 
-SpinelNCPControlInterface::ExternalRoutePriority
-SpinelNCPControlInterface::convert_flags_to_external_route_priority(uint8_t flags)
-{
-	ExternalRoutePriority priority = ROUTE_MEDIUM_PREFERENCE;
-
-	switch ((flags & SPINEL_NET_FLAG_PREFERENCE_MASK) >> SPINEL_NET_FLAG_PREFERENCE_OFFSET) {
-		case 1:
-			priority = ROUTE_HIGH_PREFERENCE;
-			break;
-
-		case 3:
-			priority = ROUTE_LOW_PREFRENCE;
-			break;
-
-		case 0:
-			priority = ROUTE_MEDIUM_PREFERENCE;
-			break;
-	}
-
-	return priority;
-}
-
-uint8_t
-SpinelNCPControlInterface::convert_external_route_priority_to_flags(ExternalRoutePriority priority)
-{
-	uint8_t flags;
-
-	switch (priority) {
-	case ROUTE_HIGH_PREFERENCE:
-		flags = (1 << SPINEL_NET_FLAG_PREFERENCE_OFFSET);
-		break;
-
-	case ROUTE_MEDIUM_PREFERENCE:
-		flags = (0 << SPINEL_NET_FLAG_PREFERENCE_OFFSET);
-		break;
-
-	case ROUTE_LOW_PREFRENCE:
-		flags = (3 << SPINEL_NET_FLAG_PREFERENCE_OFFSET);
-		break;
-	}
-
-	return flags;
-}
-
-// ----------------------------------------------------------------------------
-// MARK: -
-
 void
 SpinelNCPControlInterface::peek(uint32_t address, uint16_t count, CallbackWithStatusArg1 cb)
 {
diff --git a/src/ncp-spinel/SpinelNCPControlInterface.h b/src/ncp-spinel/SpinelNCPControlInterface.h
index 9cbe45c..6105a8c 100644
--- a/src/ncp-spinel/SpinelNCPControlInterface.h
+++ b/src/ncp-spinel/SpinelNCPControlInterface.h
@@ -42,165 +42,162 @@ class SpinelNCPControlInterface : public NCPControlInterface, public NCPMfgInter
 public:
 	friend class SpinelNCPInstance;
 
 	SpinelNCPControlInterface(SpinelNCPInstance* instance_pointer);
 	virtual ~SpinelNCPControlInterface() { }
 
 	virtual const WPAN::NetworkInstance& get_current_network_instance(void)const;
 
 	virtual void join(
 		const ValueMap& options,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void form(
 		const ValueMap& options,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void leave(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void attach(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void begin_low_power(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void netscan_start(
 		const ValueMap& options,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void netscan_stop(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void energyscan_start(
 		const ValueMap& options,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void energyscan_stop(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void begin_net_wake(
 		uint8_t data,
 		uint32_t flags,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void reset(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void permit_join(
 		int seconds = 15 * 60,
 		uint8_t commissioning_traffic_type = 0xFF,
 		in_port_t commissioning_traffic_port = 0,
 		bool network_wide = false,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void refresh_state(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void property_get_value(
 		const std::string& key,
 		CallbackWithStatusArg1 cb
 	);
 
 	virtual void property_set_value(
 		const std::string& key,
 		const boost::any& value,
 		CallbackWithStatus cb
 	);
 
 	virtual void property_insert_value(
 		const std::string& key,
 		const boost::any& value,
 		CallbackWithStatus cb
 	);
 
 	virtual void property_remove_value(
 		const std::string& key,
 		const boost::any& value,
 		CallbackWithStatus cb
 	);
 
 	virtual void add_on_mesh_prefix(
 		const struct in6_addr *prefix,
 		bool defaultRoute,
 		bool preferred,
 		bool slaac,
 		bool onMesh,
 		OnMeshPrefixPriority priority,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void remove_on_mesh_prefix(
 		const struct in6_addr *prefix,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void add_external_route(
 		const struct in6_addr *prefix,
-		int prefix_len_in_bits,
+		int prefix_len,
 		int domain_id,
 		ExternalRoutePriority priority,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void remove_external_route(
 		const struct in6_addr *prefix,
-		int prefix_len_in_bits,
+		int prefix_len,
 		int domain_id,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void joiner_add(
 		const char *psk,
 		uint32_t joiner_timeout,
 		const uint8_t *addr,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void data_poll(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void host_did_wake(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void peek(uint32_t address, uint16_t count, CallbackWithStatusArg1 cb = NilReturn());
 	virtual void poke(uint32_t address, Data bytes, CallbackWithStatus cb = NilReturn());
 
 	virtual std::string get_name(void);
 
 	virtual NCPInstance& get_ncp_instance(void);
 
 	virtual void pcap_to_fd(int fd,
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	virtual void pcap_terminate(
 		CallbackWithStatus cb = NilReturn()
 	);
 
 	/******************* NCPMfgInterface_v1 ********************/
 	virtual void mfg(
 		const std::string& mfg_command,
 		CallbackWithStatusArg1 cb = NilReturn()
 	);
 
-	static ExternalRoutePriority convert_flags_to_external_route_priority(uint8_t flags);
-	static uint8_t convert_external_route_priority_to_flags(ExternalRoutePriority priority);
-
 private:
 	void handle_permit_join_timeout(Timer *timer, int seconds);
 
diff --git a/src/ncp-spinel/SpinelNCPInstance-Protothreads.cpp b/src/ncp-spinel/SpinelNCPInstance-Protothreads.cpp
index 6aaab98..41ee029 100644
--- a/src/ncp-spinel/SpinelNCPInstance-Protothreads.cpp
+++ b/src/ncp-spinel/SpinelNCPInstance-Protothreads.cpp
@@ -291,231 +291,231 @@ int
 SpinelNCPInstance::vprocess_init(int event, va_list args)
 {
 	int status = 0;
 
 	if (event == EVENT_NCP_RESET) {
 		if (mDriverState == INITIALIZING) {
 			syslog(LOG_ERR, "Unexpected reset during NCP initialization.");
 			mFailureCount++;
 			PT_INIT(&mSubPT);
 		} else if (mDriverState == INITIALIZING_WAITING_FOR_RESET) {
 			mDriverState = INITIALIZING;
 		}
 	}
 
 	EH_BEGIN_SUB(&mSubPT);
 
 	if (get_ncp_state() == UPGRADING) {
 		EH_WAIT_UNTIL(get_upgrade_status() != EINPROGRESS);
 
 		status = get_upgrade_status();
 
 		if (status == 0) {
 			syslog(LOG_INFO, "Firmware Update Complete.");
 		} else {
 			syslog(LOG_ERR, "Firmware Update Failed with Error %d", status);
 			mFailureCount++;
 
 			if (mFailureCount > mFailureThreshold) {
 				change_ncp_state(FAULT);
 			}
 		}
 	}
 
 	if (get_ncp_state() == FAULT) {
 		EH_EXIT();
 	}
 
 	syslog(LOG_INFO, "Initializing NCP");
 
 	set_initializing_ncp(true);
 
 	change_ncp_state(UNINITIALIZED);
 
 	set_ncp_power(true);
 
-	remove_ncp_originated_addresses();
+	remove_ncp_originated_address_prefix_route_entries();
 
 	mNCPVersionString = "";
 
 	mDriverState = INITIALIZING_WAITING_FOR_RESET;
 
 	if (mResetIsExpected) {
 		EH_WAIT_UNTIL_WITH_TIMEOUT(NCP_DEFAULT_COMMAND_RESPONSE_TIMEOUT, mResetIsExpected == false);
 
 		if (eh_did_timeout) {
 			// mResetIsExpected has been set for too long and we
 			// haven't gotten a reset yet. This can prevent us from sleeping.
 			// by incrementing the failure count here we will cause
 			// another reset to occur in the code below.
 			mFailureCount++;
 			mResetIsExpected = false;
 			syslog(LOG_ERR, "Was waiting for a reset, but we never got one.");
 		}
 	} else {
 		// Backoff delay. Normaly zero. May increase if we are in a reset loop.
 		EH_SLEEP_FOR(mRunawayResetBackoffManager.delay_for_unexpected_reset());
 	}
 
 	do {
 		EH_SLEEP_FOR(0.1);
 
 		if (mFailureCount > mFailureThreshold) {
 			syslog(LOG_ALERT, "The NCP is misbehaving: Repeatedly unable to initialize NCP. Entering fault state.");
 			change_ncp_state(FAULT);
 			EH_EXIT();
 		}
 
 		if ( mAutoUpdateFirmware
 		  && (mFailureCount > (mFailureThreshold - 1))
 		  && can_upgrade_firmware()
 		) {
 			syslog(LOG_ALERT, "The NCP is misbehaving: Attempting a firmware update");
 			upgrade_firmware();
 			EH_RESTART();
 		}
 
 		if ((event != EVENT_NCP_RESET) && (mFailureCount > 0)) {
 			syslog(LOG_ERR, "Resetting and trying again... (retry %d)", mFailureCount);
 
 			change_ncp_state(UNINITIALIZED);
 
 			mNetworkKey = Data();
 			mNetworkKeyIndex = 0;
 
 			reset_tasks(kWPANTUNDStatus_Canceled);
 
 			// Do a hard reset only on even attempts.
 			if ((mFailureCount & 1) == 0) {
 				hard_reset_ncp();
 			} else {
 				CONTROL_REQUIRE_PREP_TO_SEND_COMMAND_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 				mOutboundBufferLen = spinel_datatype_pack(GetInstance(this)->mOutboundBuffer, sizeof(GetInstance(this)->mOutboundBuffer), "Ci", 0, SPINEL_CMD_RESET);
 				CONTROL_REQUIRE_OUTBOUND_BUFFER_FLUSHED_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 			}
 
 			mDriverState = INITIALIZING_WAITING_FOR_RESET;
 
 			EH_REQUIRE_WITHIN(
 				NCP_DEFAULT_COMMAND_RESPONSE_TIMEOUT,
 				event == EVENT_NCP_RESET,
 				on_error
 			);
 
 			mDriverState = INITIALIZING;
 		}
 
 		// Get the protocol version
 		CONTROL_REQUIRE_PREP_TO_SEND_COMMAND_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 		GetInstance(this)->mOutboundBufferLen = spinel_cmd_prop_value_get(GetInstance(this)->mOutboundBuffer, sizeof(GetInstance(this)->mOutboundBuffer), SPINEL_PROP_PROTOCOL_VERSION);
 		CONTROL_REQUIRE_OUTBOUND_BUFFER_FLUSHED_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 
 		CONTROL_REQUIRE_COMMAND_RESPONSE_WITHIN(NCP_DEFAULT_COMMAND_RESPONSE_TIMEOUT, on_error);
 
 		status = peek_ncp_callback_status(event, args);
 		require_noerr(status, on_error);
 
 		if (get_ncp_state() == UNINITIALIZED) {
 			// Get the thread state
 			CONTROL_REQUIRE_PREP_TO_SEND_COMMAND_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 			GetInstance(this)->mOutboundBufferLen = spinel_cmd_prop_value_get(GetInstance(this)->mOutboundBuffer, sizeof(GetInstance(this)->mOutboundBuffer), SPINEL_PROP_NET_STACK_UP);
 			CONTROL_REQUIRE_OUTBOUND_BUFFER_FLUSHED_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 
 			CONTROL_REQUIRE_COMMAND_RESPONSE_WITHIN(NCP_DEFAULT_COMMAND_RESPONSE_TIMEOUT, on_error);
 
 			require(get_ncp_state() != UNINITIALIZED, on_error);
 		}
 
 		// If we are "joining" at this point, then we must start over.
 		// This will cause a reset to occur.
 		require(!ncp_state_is_joining(get_ncp_state()), on_error);
 
 		// This next line causes any resets received after this
 		// point to cause the control protothread to be restarted.
 		mDriverState = INITIALIZING;
 
 		if (mIsPcapInProgress) {
 			CONTROL_REQUIRE_PREP_TO_SEND_COMMAND_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 			GetInstance(this)->mOutboundBufferLen = spinel_cmd_prop_value_set_uint(GetInstance(this)->mOutboundBuffer, sizeof(GetInstance(this)->mOutboundBuffer), SPINEL_PROP_MAC_RAW_STREAM_ENABLED, 1);
 			CONTROL_REQUIRE_OUTBOUND_BUFFER_FLUSHED_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 
 			CONTROL_REQUIRE_COMMAND_RESPONSE_WITHIN(NCP_DEFAULT_COMMAND_RESPONSE_TIMEOUT, on_error);
 		}
 
 		if (mEnabled) {
 			// Refresh our internal copies of the following radio parameters:
 			static const spinel_prop_key_t keys_to_fetch[] = {
 				SPINEL_PROP_NCP_VERSION,
 				SPINEL_PROP_INTERFACE_TYPE,
 				SPINEL_PROP_VENDOR_ID,
 				SPINEL_PROP_CAPS,
 				SPINEL_PROP_HWADDR,
 				SPINEL_PROP_PHY_CHAN,
 				SPINEL_PROP_PHY_CHAN_SUPPORTED,
 				SPINEL_PROP_MAC_15_4_PANID,
 				SPINEL_PROP_MAC_15_4_LADDR,
 				SPINEL_PROP_NET_MASTER_KEY,
 				SPINEL_PROP_NET_KEY_SEQUENCE_COUNTER,
 				SPINEL_PROP_NET_NETWORK_NAME,
 				SPINEL_PROP_NET_XPANID,
 				SPINEL_PROP_IPV6_LL_ADDR,
 				SPINEL_PROP_IPV6_ML_ADDR,
 				SPINEL_PROP_THREAD_ASSISTING_PORTS,
 				SPINEL_PROP_THREAD_MODE,
 				SPINEL_PROP_NET_SAVED,
 				SPINEL_PROP_NET_IF_UP,
 				SPINEL_PROP_NET_STACK_UP,
 				SPINEL_PROP_NET_ROLE,
 			};
 
 			for (mSubPTIndex = 0; mSubPTIndex < sizeof(keys_to_fetch)/sizeof(keys_to_fetch[0]); mSubPTIndex++) {
 				CONTROL_REQUIRE_PREP_TO_SEND_COMMAND_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 				GetInstance(this)->mOutboundBufferLen = spinel_cmd_prop_value_get(GetInstance(this)->mOutboundBuffer, sizeof(GetInstance(this)->mOutboundBuffer), keys_to_fetch[mSubPTIndex]);
 				CONTROL_REQUIRE_OUTBOUND_BUFFER_FLUSHED_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 				CONTROL_REQUIRE_COMMAND_RESPONSE_WITHIN(NCP_DEFAULT_COMMAND_RESPONSE_TIMEOUT, on_error);
 
 				status = peek_ncp_callback_status(event, args);
 
 				if (status != 0) {
 					syslog(LOG_WARNING, "Unsuccessful fetching property \"%s\" from NCP: \"%s\" (%d)", spinel_prop_key_to_cstr(keys_to_fetch[mSubPTIndex]), spinel_status_to_cstr(static_cast<spinel_status_t>(status)), status);
 				}
 			}
 
 			// Restore all the saved settings
 			for (mSettingsIter = mSettings.begin(); mSettingsIter != mSettings.end(); mSettingsIter++) {
 
 				syslog(LOG_INFO, "Restoring property \"%s\" on NCP", mSettingsIter->first.c_str());
 
 				// Skip the settings if capability is not present.
 				if ((mSettingsIter->second.mCapability != 0) &&!mCapabilities.count(mSettingsIter->second.mCapability)) {
 					continue;
 				}
 
 				CONTROL_REQUIRE_PREP_TO_SEND_COMMAND_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 
 				if (mSettingsIter->second.mSpinelCommand.size() > sizeof(GetInstance(this)->mOutboundBuffer))
 				{
 					syslog(LOG_WARNING,
 						"Spinel command for restoring property \"%s\" does not fit in outbound buffer (require %d bytes but only %u bytes available)",
 						mSettingsIter->first.c_str(),
 						(int)mSettingsIter->second.mSpinelCommand.size(),
 						(unsigned int)sizeof(GetInstance(this)->mOutboundBuffer)
 					);
 
 					continue;
 				}
 
 				GetInstance(this)->mOutboundBufferLen = (spinel_ssize_t)mSettingsIter->second.mSpinelCommand.size();
 				memcpy(GetInstance(this)->mOutboundBuffer, mSettingsIter->second.mSpinelCommand.data(), mSettingsIter->second.mSpinelCommand.size());
 
 				CONTROL_REQUIRE_OUTBOUND_BUFFER_FLUSHED_WITHIN(NCP_DEFAULT_COMMAND_SEND_TIMEOUT, on_error);
 				CONTROL_REQUIRE_COMMAND_RESPONSE_WITHIN(NCP_DEFAULT_COMMAND_RESPONSE_TIMEOUT, on_error);
 
 				status = peek_ncp_callback_status(event, args);
 
 				if (status != 0) {
 					syslog(LOG_WARNING, "Unsuccessful in restoring property \"%s\" on NCP: \"%s\" (%d)", mSettingsIter->first.c_str(), spinel_status_to_cstr(static_cast<spinel_status_t>(status)), status);
 				}
 			}
 		}
 
 		break;
diff --git a/src/ncp-spinel/SpinelNCPInstance.cpp b/src/ncp-spinel/SpinelNCPInstance.cpp
index c5dab96..2105dad 100644
--- a/src/ncp-spinel/SpinelNCPInstance.cpp
+++ b/src/ncp-spinel/SpinelNCPInstance.cpp
@@ -574,77 +574,6 @@ unpack_jam_detect_history_bitmap(const uint8_t *data_in, spinel_size_t data_len,
 	return ret;
 }
 
-static int
-unpack_thread_off_mesh_routes(const uint8_t *data_in, spinel_size_t data_len, boost::any& value)
-{
-
-	int ret = kWPANTUNDStatus_Ok;
-	std::list<std::string> result;
-
-	while (data_len > 0)
-	{
-		spinel_ssize_t len;
-		struct in6_addr *route_prefix = NULL;
-		uint8_t prefix_len;
-		bool is_stable;
-		uint8_t flags;
-		bool is_local;
-		bool next_hop_is_this_device;
-
-
-		len = spinel_datatype_unpack(
-			data_in,
-			data_len,
-			SPINEL_DATATYPE_STRUCT_S(
-				SPINEL_DATATYPE_IPv6ADDR_S      // Route Prefix
-				SPINEL_DATATYPE_UINT8_S         // Prefix Length (in bits)
-				SPINEL_DATATYPE_BOOL_S          // isStable
-				SPINEL_DATATYPE_UINT8_S         // Flags
-				SPINEL_DATATYPE_BOOL_S          // IsLocal
-				SPINEL_DATATYPE_BOOL_S          // NextHopIsThisDevice
-			),
-			&route_prefix,
-			&prefix_len,
-			&is_stable,
-			&flags,
-			&is_local,
-			&next_hop_is_this_device
-		);
-
-		if (len <= 0) {
-			ret = kWPANTUNDStatus_Failure;
-			break;
-		} else {
-			char c_string[200];
-			NCPControlInterface::ExternalRoutePriority priority;
-
-			priority = SpinelNCPControlInterface::convert_flags_to_external_route_priority(flags);
-
-			snprintf(c_string, sizeof(c_string),
-				"%s/%d, stable:%s, local:%s, next_hop:%s, priority:%s (flags:0x%02x)",
-				in6_addr_to_string(*route_prefix).c_str(),
-				prefix_len,
-				is_stable ? "yes" : "no",
-				is_local ? "yes" : "no",
-				next_hop_is_this_device ? "this_device" : "off-mesh",
-				SpinelNCPControlInterface::external_route_priority_to_string(priority).c_str(),
-				flags
-			);
-
-			result.push_back(c_string);
-		}
-
-		data_in += len;
-		data_len -= len;
-	}
-
-	if (ret == kWPANTUNDStatus_Ok) {
-		value = result;
-	}
-
-	return ret;
-}
-
 void
 SpinelNCPInstance::update_node_type(NodeType new_node_type)
 {
@@ -713,423 +642,413 @@ void
 SpinelNCPInstance::property_get_value(
 	const std::string& key,
 	CallbackWithStatusArg1 cb
 ) {
 	if (!is_initializing_ncp()) {
 		syslog(LOG_INFO, "property_get_value: key: \"%s\"", key.c_str());
 	}
 
 #define SIMPLE_SPINEL_GET(prop__, type__)                                \
 	start_new_task(SpinelNCPTaskSendCommand::Factory(this)               \
 		.set_callback(cb)                                                \
 		.add_command(                                                    \
 			SpinelPackData(SPINEL_FRAME_PACK_CMD_PROP_VALUE_GET, prop__) \
 		)                                                                \
 		.set_reply_format(type__)                                        \
 		.finish()                                                        \
 	)
 
 	if (strcaseequal(key.c_str(), kWPANTUNDProperty_ConfigNCPDriverName)) {
 		cb(0, boost::any(std::string("spinel")));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPChannelMask)) {
 		cb(0, boost::any(get_default_channel_mask()));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPCCAThreshold)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_PHY_CCA_THRESHOLD, SPINEL_DATATYPE_INT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPTXPower)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_PHY_TX_POWER, SPINEL_DATATYPE_INT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPFrequency)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_PHY_FREQ, SPINEL_DATATYPE_INT32_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkKey)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_NET_MASTER_KEY, SPINEL_DATATYPE_DATA_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkPSKc)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_NET_PSKC, SPINEL_DATATYPE_DATA_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPExtendedAddress)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_MAC_EXTENDED_ADDR, SPINEL_DATATYPE_EUI64_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPSleepyPollInterval)) {
 		if (!mCapabilities.count(SPINEL_CAP_ROLE_SLEEPY)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("Sleepy role is not supported by NCP")));
 		} else {
 			SIMPLE_SPINEL_GET(SPINEL_PROP_MAC_DATA_POLL_PERIOD, SPINEL_DATATYPE_UINT32_S);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkKeyIndex)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_NET_KEY_SEQUENCE_COUNTER, SPINEL_DATATYPE_UINT32_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkIsCommissioned)) {
 		cb(kWPANTUNDStatus_Ok, boost::any(mIsCommissioned));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkRole)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_NET_ROLE, SPINEL_DATATYPE_UINT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkPartitionId)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_NET_PARTITION_ID, SPINEL_DATATYPE_UINT32_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPRSSI)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_PHY_RSSI, SPINEL_DATATYPE_INT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadRLOC16)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_RLOC16, SPINEL_DATATYPE_UINT16_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadRouterID)) {
 		cb = boost::bind(convert_rloc16_to_router_id, cb, _1, _2);
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_RLOC16, SPINEL_DATATYPE_UINT16_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadLeaderAddress)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_LEADER_ADDR, SPINEL_DATATYPE_IPv6ADDR_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadLeaderRouterID)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_LEADER_RID, SPINEL_DATATYPE_UINT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadLeaderWeight)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_LEADER_WEIGHT, SPINEL_DATATYPE_UINT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadLeaderLocalWeight)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_LOCAL_LEADER_WEIGHT, SPINEL_DATATYPE_UINT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadNetworkData)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_NETWORK_DATA, SPINEL_DATATYPE_DATA_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadNetworkDataVersion)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_NETWORK_DATA_VERSION, SPINEL_DATATYPE_UINT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadStableNetworkData)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_STABLE_NETWORK_DATA, SPINEL_DATATYPE_DATA_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadLeaderNetworkData)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_LEADER_NETWORK_DATA, SPINEL_DATATYPE_DATA_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadStableLeaderNetworkData)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_STABLE_LEADER_NETWORK_DATA, SPINEL_DATATYPE_DATA_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadStableNetworkDataVersion)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_STABLE_NETWORK_DATA_VERSION, SPINEL_DATATYPE_UINT8_S);
 
-	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadOffMeshRoutes)) {
-		start_new_task(SpinelNCPTaskSendCommand::Factory(this)
-			.set_callback(cb)
-			.add_command(
-				SpinelPackData(SPINEL_FRAME_PACK_CMD_PROP_VALUE_GET, SPINEL_PROP_THREAD_OFF_MESH_ROUTES)
-			)
-			.set_reply_unpacker(unpack_thread_off_mesh_routes)
-			.finish()
-		);
-
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadCommissionerEnabled)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_COMMISSIONER_ENABLED, SPINEL_DATATYPE_BOOL_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadRouterRoleEnabled)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_ROUTER_ROLE_ENABLED, SPINEL_DATATYPE_BOOL_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadDeviceMode)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_MODE, SPINEL_DATATYPE_UINT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadConfigFilterRLOCAddresses)) {
 		cb(kWPANTUNDStatus_Ok, boost::any(mFilterRLOCAddresses));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6MeshLocalPrefix) && !buffer_is_nonzero(mNCPV6Prefix, sizeof(mNCPV6Prefix))) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_IPV6_ML_PREFIX, SPINEL_DATATYPE_IPv6ADDR_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6MeshLocalAddress) && !buffer_is_nonzero(mNCPV6Prefix, sizeof(mNCPV6Prefix))) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_IPV6_ML_ADDR, SPINEL_DATATYPE_IPv6ADDR_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6LinkLocalAddress) && !IN6_IS_ADDR_LINKLOCAL(&mNCPLinkLocalAddress)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_IPV6_LL_ADDR, SPINEL_DATATYPE_IPv6ADDR_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_OpenThreadDebugTestAssert)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_DEBUG_TEST_ASSERT, SPINEL_DATATYPE_BOOL_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_MACWhitelistEnabled)) {
 		if (!mCapabilities.count(SPINEL_CAP_MAC_WHITELIST)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("MAC whitelist feature not supported by NCP")));
 		} else {
 			SIMPLE_SPINEL_GET(SPINEL_PROP_MAC_WHITELIST_ENABLED, SPINEL_DATATYPE_BOOL_S);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_MACWhitelistEntries)) {
 		if (!mCapabilities.count(SPINEL_CAP_MAC_WHITELIST)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("MAC whitelist feature not supported by NCP")));
 		} else {
 			start_new_task(SpinelNCPTaskSendCommand::Factory(this)
 				.set_callback(cb)
 				.add_command(
 					SpinelPackData(SPINEL_FRAME_PACK_CMD_PROP_VALUE_GET, SPINEL_PROP_MAC_WHITELIST)
 				)
 				.set_reply_unpacker(boost::bind(unpack_mac_whitelist_entries, _1, _2, _3, false))
 				.finish()
 			);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_MACWhitelistEntriesAsValMap)) {
 		if (!mCapabilities.count(SPINEL_CAP_MAC_WHITELIST)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("MAC whitelist feature not supported by NCP")));
 		} else {
 			start_new_task(SpinelNCPTaskSendCommand::Factory(this)
 				.set_callback(cb)
 				.add_command(
 					SpinelPackData(SPINEL_FRAME_PACK_CMD_PROP_VALUE_GET, SPINEL_PROP_MAC_WHITELIST)
 				)
 				.set_reply_unpacker(boost::bind(unpack_mac_whitelist_entries, _1, _2, _3, true))
 				.finish()
 			);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_MACBlacklistEntries)) {
 		if (!mCapabilities.count(SPINEL_CAP_MAC_WHITELIST)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("MAC blacklist feature not supported by NCP")));
 		} else {
 			start_new_task(SpinelNCPTaskSendCommand::Factory(this)
 				.set_callback(cb)
 				.add_command(
 					SpinelPackData(SPINEL_FRAME_PACK_CMD_PROP_VALUE_GET, SPINEL_PROP_MAC_BLACKLIST)
 				)
 				.set_reply_unpacker(boost::bind(unpack_mac_blacklist_entries, _1, _2, _3, false))
 				.finish()
 			);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_MACBlacklistEntriesAsValMap)) {
 		if (!mCapabilities.count(SPINEL_CAP_MAC_WHITELIST)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("MAC blacklist feature not supported by NCP")));
 		} else {
 			start_new_task(SpinelNCPTaskSendCommand::Factory(this)
 				.set_callback(cb)
 				.add_command(
 					SpinelPackData(SPINEL_FRAME_PACK_CMD_PROP_VALUE_GET, SPINEL_PROP_MAC_BLACKLIST)
 				)
 				.set_reply_unpacker(boost::bind(unpack_mac_blacklist_entries, _1, _2, _3, true))
 				.finish()
 			);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_MACBlacklistEnabled)) {
 		if (!mCapabilities.count(SPINEL_CAP_MAC_WHITELIST)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("MAC Blacklist feature not supported by NCP")));
 		} else {
 			SIMPLE_SPINEL_GET(SPINEL_PROP_MAC_BLACKLIST_ENABLED, SPINEL_DATATYPE_BOOL_S);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_JamDetectionStatus)) {
 		if (!mCapabilities.count(SPINEL_CAP_JAM_DETECT)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("Jam Detection Feature Not Supported")));
 		} else {
 			SIMPLE_SPINEL_GET(SPINEL_PROP_JAM_DETECTED, SPINEL_DATATYPE_BOOL_S);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_TmfProxyEnabled)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_THREAD_TMF_PROXY_ENABLED, SPINEL_DATATYPE_BOOL_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_JamDetectionEnable)) {
 		if (!mCapabilities.count(SPINEL_CAP_JAM_DETECT)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("Jam Detection Feature Not Supported")));
 		} else {
 			SIMPLE_SPINEL_GET(SPINEL_PROP_JAM_DETECT_ENABLE, SPINEL_DATATYPE_BOOL_S);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_JamDetectionRssiThreshold)) {
 		if (!mCapabilities.count(SPINEL_CAP_JAM_DETECT)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("Jam Detection Feature Not Supported")));
 		} else {
 			SIMPLE_SPINEL_GET(SPINEL_PROP_JAM_DETECT_RSSI_THRESHOLD, SPINEL_DATATYPE_INT8_S);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_JamDetectionWindow)) {
 		if (!mCapabilities.count(SPINEL_CAP_JAM_DETECT)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("Jam Detection Feature Not Supported")));
 		} else {
 			SIMPLE_SPINEL_GET(SPINEL_PROP_JAM_DETECT_WINDOW, SPINEL_DATATYPE_UINT8_S);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_JamDetectionBusyPeriod)) {
 		if (!mCapabilities.count(SPINEL_CAP_JAM_DETECT)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("Jam Detection Feature Not Supported")));
 		} else {
 			SIMPLE_SPINEL_GET(SPINEL_PROP_JAM_DETECT_BUSY, SPINEL_DATATYPE_UINT8_S);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_JamDetectionDebugHistoryBitmap)) {
 		if (!mCapabilities.count(SPINEL_CAP_JAM_DETECT)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("Jam Detection Feature Not Supported")));
 		} else {
 			start_new_task(SpinelNCPTaskSendCommand::Factory(this)
 				.set_callback(cb)
 				.add_command(
 					SpinelPackData(SPINEL_FRAME_PACK_CMD_PROP_VALUE_GET, SPINEL_PROP_JAM_DETECT_HISTORY_BITMAP)
 				)
 				.set_reply_unpacker(unpack_jam_detect_history_bitmap)
 				.finish()
 			);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NestLabs_LegacyMeshLocalPrefix)) {
 		if (!mCapabilities.count(SPINEL_CAP_NEST_LEGACY_INTERFACE)) {
 			cb(kWPANTUNDStatus_FeatureNotSupported, boost::any(std::string("Legacy Capability Not Supported by NCP")));
 		} else {
 			SIMPLE_SPINEL_GET(SPINEL_PROP_NEST_LEGACY_ULA_PREFIX, SPINEL_DATATYPE_DATA_S);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadChildTable)) {
 		start_new_task(boost::shared_ptr<SpinelNCPTask>(
 			new SpinelNCPTaskGetNetworkTopology(
 				this,
 				cb,
 				SpinelNCPTaskGetNetworkTopology::kChildTable,
 				SpinelNCPTaskGetNetworkTopology::kResultFormat_StringArray
 			)
 		));
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadChildTableAsValMap)) {
 		start_new_task(boost::shared_ptr<SpinelNCPTask>(
 			new SpinelNCPTaskGetNetworkTopology(
 				this,
 				cb,
 				SpinelNCPTaskGetNetworkTopology::kChildTable,
 				SpinelNCPTaskGetNetworkTopology::kResultFormat_ValueMapArray
 			)
 		));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadNeighborTable)) {
 		start_new_task(boost::shared_ptr<SpinelNCPTask>(
 			new SpinelNCPTaskGetNetworkTopology(
 				this,
 				cb,
 				SpinelNCPTaskGetNetworkTopology::kNeighborTable,
 				SpinelNCPTaskGetNetworkTopology::kResultFormat_StringArray
 			)
 		));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadNeighborTableAsValMap)) {
 		start_new_task(boost::shared_ptr<SpinelNCPTask>(
 			new SpinelNCPTaskGetNetworkTopology(
 				this,
 				cb,
 				SpinelNCPTaskGetNetworkTopology::kNeighborTable,
 				SpinelNCPTaskGetNetworkTopology::kResultFormat_ValueMapArray
 			)
 		));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadRouterTable)) {
 		start_new_task(boost::shared_ptr<SpinelNCPTask>(
 			new SpinelNCPTaskGetNetworkTopology(
 				this,
 				cb,
 				SpinelNCPTaskGetNetworkTopology::kRouterTable,
 				SpinelNCPTaskGetNetworkTopology::kResultFormat_StringArray
 			)
 		));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadRouterTableAsValMap)) {
 		start_new_task(boost::shared_ptr<SpinelNCPTask>(
 			new SpinelNCPTaskGetNetworkTopology(
 				this,
 				cb,
 				SpinelNCPTaskGetNetworkTopology::kRouterTable,
 				SpinelNCPTaskGetNetworkTopology::kResultFormat_ValueMapArray
 			)
 		));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_OpenThreadMsgBufferCounters)) {
 		start_new_task(boost::shared_ptr<SpinelNCPTask>(
 			new SpinelNCPTaskGetMsgBufferCounters(
 				this,
 				cb,
 				SpinelNCPTaskGetMsgBufferCounters::kResultFormat_StringArray
 			)
 		));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_OpenThreadMsgBufferCountersAsString)) {
 		start_new_task(boost::shared_ptr<SpinelNCPTask>(
 			new SpinelNCPTaskGetMsgBufferCounters(
 				this,
 				cb,
 				SpinelNCPTaskGetMsgBufferCounters::kResultFormat_String
 			)
 		));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_OpenThreadLogLevel)) {
 		SIMPLE_SPINEL_GET(SPINEL_PROP_DEBUG_NCP_LOG_LEVEL, SPINEL_DATATYPE_UINT8_S);
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_OpenThreadSteeringDataSetWhenJoinable)) {
 		cb(0, boost::any(mSetSteeringDataWhenJoinable));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_OpenThreadSteeringDataAddress)) {
 		cb(0, boost::any(nl::Data(mSteeringDataAddress, sizeof(mSteeringDataAddress))));
 
 	} else if (strncaseequal(key.c_str(), kWPANTUNDProperty_Spinel_CounterPrefix, sizeof(kWPANTUNDProperty_Spinel_CounterPrefix)-1)) {
 		int cntr_key = 0;
 
 #define CNTR_KEY(x)	\
 	else if (strcaseequal(key.c_str()+sizeof(kWPANTUNDProperty_Spinel_CounterPrefix)-1, # x)) { \
 		cntr_key = SPINEL_PROP_CNTR_ ## x; \
 	}
 
 		// Check to see if the counter name is an integer.
 		cntr_key = (int)strtol(key.c_str()+(int)sizeof(kWPANTUNDProperty_Spinel_CounterPrefix)-1, NULL, 0);
 
 		if ( (cntr_key > 0)
 		  && (cntr_key < SPINEL_PROP_CNTR__END-SPINEL_PROP_CNTR__BEGIN)
 		) {
 			// Counter name was a valid integer. Let's use it.
 			cntr_key += SPINEL_PROP_CNTR__BEGIN;
 		}
 
 		CNTR_KEY(TX_PKT_TOTAL)
 		CNTR_KEY(TX_PKT_UNICAST)
 		CNTR_KEY(TX_PKT_BROADCAST)
 		CNTR_KEY(TX_PKT_ACK_REQ)
 		CNTR_KEY(TX_PKT_ACKED)
 		CNTR_KEY(TX_PKT_NO_ACK_REQ)
 		CNTR_KEY(TX_PKT_DATA)
 		CNTR_KEY(TX_PKT_DATA_POLL)
 		CNTR_KEY(TX_PKT_BEACON)
 		CNTR_KEY(TX_PKT_BEACON_REQ)
 		CNTR_KEY(TX_PKT_OTHER)
 		CNTR_KEY(TX_PKT_RETRY)
 		CNTR_KEY(TX_ERR_CCA)
 		CNTR_KEY(TX_ERR_ABORT)
 		CNTR_KEY(RX_PKT_TOTAL)
 		CNTR_KEY(RX_PKT_UNICAST)
 		CNTR_KEY(RX_PKT_BROADCAST)
 		CNTR_KEY(RX_PKT_DATA)
 		CNTR_KEY(RX_PKT_DATA_POLL)
 		CNTR_KEY(RX_PKT_BEACON)
 		CNTR_KEY(RX_PKT_BEACON_REQ)
 		CNTR_KEY(RX_PKT_OTHER)
 		CNTR_KEY(RX_PKT_FILT_WL)
 		CNTR_KEY(RX_PKT_FILT_DA)
 		CNTR_KEY(RX_ERR_EMPTY)
 		CNTR_KEY(RX_ERR_UKWN_NBR)
 		CNTR_KEY(RX_ERR_NVLD_SADDR)
 		CNTR_KEY(RX_ERR_SECURITY)
 		CNTR_KEY(RX_ERR_BAD_FCS)
 		CNTR_KEY(RX_ERR_OTHER)
 		CNTR_KEY(TX_IP_SEC_TOTAL)
 		CNTR_KEY(TX_IP_INSEC_TOTAL)
 		CNTR_KEY(TX_IP_DROPPED)
 		CNTR_KEY(RX_IP_SEC_TOTAL)
 		CNTR_KEY(RX_IP_INSEC_TOTAL)
 		CNTR_KEY(RX_IP_DROPPED)
 		CNTR_KEY(TX_SPINEL_TOTAL)
 		CNTR_KEY(RX_SPINEL_TOTAL)
 		CNTR_KEY(RX_SPINEL_ERR)
 		CNTR_KEY(IP_TX_SUCCESS)
 		CNTR_KEY(IP_RX_SUCCESS)
 		CNTR_KEY(IP_TX_FAILURE)
 		CNTR_KEY(IP_RX_FAILURE)
 
 #undef CNTR_KEY
 
 		if (cntr_key != 0) {
 			SIMPLE_SPINEL_GET(cntr_key, SPINEL_DATATYPE_UINT32_S);
 		} else {
 			NCPInstanceBase::property_get_value(key, cb);
 		}
 	} else {
 		NCPInstanceBase::property_get_value(key, cb);
 	}
 }
@@ -1805,635 +1724,730 @@ SpinelNCPInstance::reset_tasks(wpantund_status_t status)
 	}
 }
 
+void
+SpinelNCPInstance::handle_ncp_spinel_value_is_OFF_MESH_ROUTE(const uint8_t* value_data_ptr, spinel_size_t value_data_len)
+{
+	std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator iter;
+	std::multimap<IPv6Prefix, OffMeshRouteEntry> off_mesh_routes(mOffMeshRoutes);
+	int num_routes = 0;
+
+	while (value_data_len > 0) {
+		spinel_ssize_t len;
+		struct in6_addr *route_prefix = NULL;
+		uint8_t prefix_len;
+		bool is_stable;
+		uint8_t flags;
+		bool is_local;
+		bool next_hop_is_this_device;
+		uint16_t rloc16;
+		RoutePreference preference;
+
+		len = spinel_datatype_unpack(
+			value_data_ptr,
+			value_data_len,
+			SPINEL_DATATYPE_STRUCT_S(
+				SPINEL_DATATYPE_IPv6ADDR_S      // Route Prefix
+				SPINEL_DATATYPE_UINT8_S         // Prefix Length (in bits)
+				SPINEL_DATATYPE_BOOL_S          // isStable
+				SPINEL_DATATYPE_UINT8_S         // Flags
+				SPINEL_DATATYPE_BOOL_S          // IsLocal
+				SPINEL_DATATYPE_BOOL_S          // NextHopIsThisDevice
+				SPINEL_DATATYPE_UINT16_S        // RLOC16
+			),
+			&route_prefix,
+			&prefix_len,
+			&is_stable,
+			&flags,
+			&is_local,
+			&next_hop_is_this_device,
+			&rloc16
+		);
+
+		if (len <= 0) {
+			break;
+		}
+
+		preference = convert_flags_to_route_preference(flags);
+
+		syslog(LOG_INFO, "[-NCP-]: Off-mesh route [%d] \"%s/%d\" stable:%s local:%s preference:%s, next_hop_is_this_device:%s, rloc16:0x%0x",
+			num_routes, in6_addr_to_string(*route_prefix).c_str(), prefix_len, is_stable ? "yes" : "no",
+			is_local ? "yes" : "no", NCPControlInterface::external_route_priority_to_string(preference).c_str(),
+			next_hop_is_this_device ? "yes" : "no", rloc16);
+
+		num_routes++;
+
+		if (!is_local) {
+
+			// Go through the `off_mesh_routes` list (which is the copy of mOffMeshRoutes)
+			// and check if this entry is already on the list, if so remove it.
+
+			IPv6Prefix route(*route_prefix, prefix_len);
+			OffMeshRouteEntry entry(kOriginThreadNCP, preference, is_stable, rloc16, next_hop_is_this_device);
+			iter = off_mesh_routes.lower_bound(route);
+
+			if (iter != off_mesh_routes.end()) {
+				std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator upper_iter = off_mesh_routes.upper_bound(route);
+
+				for (; iter != upper_iter; ++iter) {
+					if (iter->second == entry) {
+						off_mesh_routes.erase(iter);
+						break;
+					}
+				}
+			}
+
+			route_was_added(kOriginThreadNCP, *route_prefix, prefix_len, preference, is_stable, rloc16,
+				next_hop_is_this_device);
+		}
+
+		value_data_ptr += len;
+		value_data_len -= len;
+	}
+
+	// Since this was the whole list, we need to remove any routes
+	// which originated from NCP that that weren't in the new list.
+
+	for (iter = off_mesh_routes.begin(); iter != off_mesh_routes.end(); ++iter) {
+		if (iter->second.is_from_ncp()) {
+			route_was_removed(kOriginThreadNCP, iter->first.get_prefix(), iter->first.get_length(),
+				iter->second.get_preference(), iter->second.is_stable(), iter->second.get_rloc());
+		}
+	}
+}
+
+
 void
 SpinelNCPInstance::handle_ncp_spinel_value_is(spinel_prop_key_t key, const uint8_t* value_data_ptr, spinel_size_t value_data_len)
 {
 	const uint8_t *original_value_data_ptr = value_data_ptr;
 	spinel_size_t original_value_data_len = value_data_len;
 
 	if (key == SPINEL_PROP_LAST_STATUS) {
 		spinel_status_t status = SPINEL_STATUS_OK;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, "i", &status);
 		syslog(LOG_INFO, "[-NCP-]: Last status (%s, %d)", spinel_status_to_cstr(status), status);
 		if ((status >= SPINEL_STATUS_RESET__BEGIN) && (status <= SPINEL_STATUS_RESET__END)) {
 			syslog(LOG_NOTICE, "[-NCP-]: NCP was reset (%s, %d)", spinel_status_to_cstr(status), status);
 			process_event(EVENT_NCP_RESET, status);
 			if (!mResetIsExpected && (mDriverState == NORMAL_OPERATION)) {
 				wpantund_status_t wstatus = kWPANTUNDStatus_NCP_Reset;
 				switch(status) {
 				case SPINEL_STATUS_RESET_CRASH:
 				case SPINEL_STATUS_RESET_FAULT:
 				case SPINEL_STATUS_RESET_ASSERT:
 				case SPINEL_STATUS_RESET_WATCHDOG:
 				case SPINEL_STATUS_RESET_OTHER:
 					wstatus = kWPANTUNDStatus_NCP_Crashed;
 					break;
 				default:
 					break;
 				}
 				reset_tasks(wstatus);
 			}
 
 			if (mDriverState == NORMAL_OPERATION) {
 				reinitialize_ncp();
 			}
 			mResetIsExpected = false;
 			return;
 		} else if (status == SPINEL_STATUS_INVALID_COMMAND) {
 			syslog(LOG_NOTICE, "[-NCP-]: COMMAND NOT RECOGNIZED");
 		}
 	} else if (key == SPINEL_PROP_NCP_VERSION) {
 		const char* ncp_version = NULL;
 		spinel_ssize_t len = spinel_datatype_unpack(value_data_ptr, value_data_len, "U", &ncp_version);
 		if ((len <= 0) || (ncp_version == NULL)) {
 			syslog(LOG_CRIT, "[-NCP-]: Got a corrupted NCP version");
 			// TODO: Properly handle NCP Misbehavior
 			change_ncp_state(FAULT);
 		} else {
 			set_ncp_version_string(ncp_version);
 		}
 
 	} else if (key == SPINEL_PROP_INTERFACE_TYPE) {
 		unsigned int interface_type = 0;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, "i", &interface_type);
 
 		if (interface_type != SPINEL_PROTOCOL_TYPE_THREAD) {
 			syslog(LOG_CRIT, "[-NCP-]: NCP is using unsupported protocol type (%d)", interface_type);
 			change_ncp_state(FAULT);
 		}
 
 	} else if (key == SPINEL_PROP_PROTOCOL_VERSION) {
 		unsigned int protocol_version_major = 0;
 		unsigned int protocol_version_minor = 0;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, "ii", &protocol_version_major, &protocol_version_minor);
 
 		if (protocol_version_major != SPINEL_PROTOCOL_VERSION_THREAD_MAJOR) {
 			syslog(LOG_CRIT, "[-NCP-]: NCP is using unsupported protocol version (NCP:%d, wpantund:%d)", protocol_version_major, SPINEL_PROTOCOL_VERSION_THREAD_MAJOR);
 			change_ncp_state(FAULT);
 		}
 
 		if (protocol_version_minor != SPINEL_PROTOCOL_VERSION_THREAD_MINOR) {
 			syslog(LOG_WARNING, "[-NCP-]: NCP is using different protocol minor version (NCP:%d, wpantund:%d)", protocol_version_minor, SPINEL_PROTOCOL_VERSION_THREAD_MINOR);
 		}
 
 	} else if (key == SPINEL_PROP_CAPS) {
 		const uint8_t* data_ptr = value_data_ptr;
 		spinel_size_t data_len = value_data_len;
 		std::set<unsigned int> capabilities;
 
 		while(data_len != 0) {
 			unsigned int value = 0;
 			spinel_ssize_t parse_len = spinel_datatype_unpack(data_ptr, data_len, SPINEL_DATATYPE_UINT_PACKED_S, &value);
 			if (parse_len <= 0) {
 				syslog(LOG_WARNING, "[-NCP-]: Capability Parse failure");
 				break;
 			}
 			capabilities.insert(value);
 			syslog(LOG_INFO, "[-NCP-]: Capability (%s, %d)", spinel_capability_to_cstr(value), value);
 
 			data_ptr += parse_len;
 			data_len -= parse_len;
 		}
 
 		if (capabilities != mCapabilities) {
 			mCapabilities = capabilities;
 		}
 
 	} else if (key == SPINEL_PROP_NET_NETWORK_NAME) {
 		const char* value = NULL;
 		spinel_ssize_t len = spinel_datatype_unpack(value_data_ptr, value_data_len, "U", &value);
 
 		if ((len <= 0) || (value == NULL)) {
 			syslog(LOG_CRIT, "[-NCP-]: Got a corrupted NCP version");
 			// TODO: Properly handle NCP Misbehavior
 			change_ncp_state(FAULT);
 		} else {
 			syslog(LOG_INFO, "[-NCP-]: Network name \"%s\"", value);
 			if (mCurrentNetworkInstance.name != value) {
 				mCurrentNetworkInstance.name = value;
 				signal_property_changed(kWPANTUNDProperty_NetworkName, mCurrentNetworkInstance.name);
 			}
 		}
 
 	} else if (key == SPINEL_PROP_IPV6_LL_ADDR) {
 		struct in6_addr *addr = NULL;
 
 		spinel_datatype_unpack(value_data_ptr, value_data_len, "6", &addr);
 		if (addr != NULL) {
 			syslog(LOG_INFO, "[-NCP-]: Link-local IPv6 address \"%s\"", in6_addr_to_string(*addr).c_str());
 		}
 		update_link_local_address(addr);
 
 	} else if (key == SPINEL_PROP_IPV6_ML_ADDR) {
 		struct in6_addr *addr = NULL;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, "6", &addr);
 		if (addr != NULL) {
 			syslog(LOG_INFO, "[-NCP-]: Mesh-local IPv6 address \"%s\"", in6_addr_to_string(*addr).c_str());
 		}
 		update_mesh_local_address(addr);
 
 	} else if (key == SPINEL_PROP_IPV6_ML_PREFIX) {
 		struct in6_addr *addr = NULL;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, "6", &addr);
 		if (addr != NULL) {
 			syslog(LOG_INFO, "[-NCP-]: Mesh-local prefix \"%s\"", (in6_addr_to_string(*addr) + "/64").c_str());
 		}
 		update_mesh_local_prefix(addr);
 
 	} else if (key == SPINEL_PROP_IPV6_ADDRESS_TABLE) {
 		std::map<struct in6_addr, UnicastAddressEntry>::const_iterator iter;
 		std::map<struct in6_addr, UnicastAddressEntry> unicast_addresses(mUnicastAddresses);
 		const struct in6_addr *addr = NULL;
 		int num_address = 0;
 
 		while (value_data_len > 0) {
 			const uint8_t *entry_ptr = NULL;
 			spinel_size_t entry_len = 0;
 			spinel_ssize_t len = 0;
 			len = spinel_datatype_unpack(value_data_ptr, value_data_len, "D.", &entry_ptr, &entry_len);
 			if (len < 1) {
 				break;
 			}
 
 			addr = reinterpret_cast<const struct in6_addr*>(entry_ptr);
 			syslog(LOG_INFO, "[-NCP-]: IPv6 address [%d] \"%s\"", num_address, in6_addr_to_string(*addr).c_str());
 			num_address++;
 			unicast_addresses.erase(*addr);
 			handle_ncp_spinel_value_inserted(key, entry_ptr, entry_len);
 
 			value_data_ptr += len;
 			value_data_len -= len;
 		}
 
 		syslog(LOG_INFO, "[-NCP-]: IPv6 address: Total %d address%s", num_address, (num_address > 1) ? "es" : "");
 
 		// Since this was the whole list, we need to remove the addresses
 		// which originated from NCP that that weren't in the list.
 		for (iter = unicast_addresses.begin(); iter != unicast_addresses.end(); ++iter) {
 			if (iter->second.is_from_ncp()) {
 				unicast_address_was_removed(kOriginThreadNCP, iter->first);
 			}
 		}
 
 	} else if (key == SPINEL_PROP_IPV6_MULTICAST_ADDRESS_TABLE) {
 		std::map<struct in6_addr, MulticastAddressEntry>::const_iterator iter;
 		std::map<struct in6_addr, MulticastAddressEntry> multicast_addresses(mMulticastAddresses);
 		const struct in6_addr *addr = NULL;
 		int num_address = 0;
 
 		while (value_data_len > 0) {
 			const uint8_t *entry_ptr = NULL;
 			spinel_size_t entry_len = 0;
 			spinel_ssize_t len = 0;
 			len = spinel_datatype_unpack(value_data_ptr, value_data_len, "D.", &entry_ptr, &entry_len);
 			if (len < 1) {
 				break;
 			}
 
 			addr = reinterpret_cast<const struct in6_addr*>(entry_ptr);
 			syslog(LOG_INFO, "[-NCP-]: Multicast IPv6 address [%d] \"%s\"", num_address, in6_addr_to_string(*addr).c_str());
 			num_address++;
 			multicast_addresses.erase(*addr);
 			handle_ncp_spinel_value_inserted(key, entry_ptr, entry_len);
 
 			value_data_ptr += len;
 			value_data_len -= len;
 		}
 
 		// Since this was the whole list, we need to remove the addresses
 		// which originated from NCP that that weren't in the list.
 		for (iter = multicast_addresses.begin(); iter != multicast_addresses.end(); ++iter) {
 			if (iter->second.is_from_ncp()) {
 				multicast_address_was_left(kOriginThreadNCP, iter->first);
 			}
 		}
 
 	} else if (key == SPINEL_PROP_HWADDR) {
 		nl::Data hwaddr(value_data_ptr, value_data_len);
 		if (value_data_len == sizeof(mMACHardwareAddress)) {
 			set_mac_hardware_address(value_data_ptr);
 		}
 
 	} else if (key == SPINEL_PROP_MAC_15_4_LADDR) {
 		nl::Data hwaddr(value_data_ptr, value_data_len);
 		if (value_data_len == sizeof(mMACAddress)) {
 			set_mac_address(value_data_ptr);
 		}
 
 	} else if (key == SPINEL_PROP_MAC_15_4_PANID) {
 		uint16_t panid;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT16_S, &panid);
 		syslog(LOG_INFO, "[-NCP-]: PANID 0x%04X", panid);
 		if (panid != mCurrentNetworkInstance.panid) {
 			mCurrentNetworkInstance.panid = panid;
 			signal_property_changed(kWPANTUNDProperty_NetworkPANID, panid);
 		}
 
 	} else if (key == SPINEL_PROP_NET_XPANID) {
 		nl::Data xpanid(value_data_ptr, value_data_len);
 		char cstr_buf[200];
 		encode_data_into_string(value_data_ptr, value_data_len, cstr_buf, sizeof(cstr_buf), 0);
 		syslog(LOG_INFO, "[-NCP-] XPANID 0x%s", cstr_buf);
 
 		if ((value_data_len == 8) && 0 != memcmp(xpanid.data(), mCurrentNetworkInstance.xpanid, 8)) {
 			memcpy(mCurrentNetworkInstance.xpanid, xpanid.data(), 8);
 			signal_property_changed(kWPANTUNDProperty_NetworkXPANID, xpanid);
 		}
 
 	} else if (key == SPINEL_PROP_NET_PSKC) {
 		nl::Data network_pskc(value_data_ptr, value_data_len);
 		if (network_pskc != mNetworkPSKc) {
 			mNetworkPSKc = network_pskc;
 			signal_property_changed(kWPANTUNDProperty_NetworkPSKc, mNetworkPSKc);
 		}
 
 	} else if (key == SPINEL_PROP_NET_MASTER_KEY) {
 		nl::Data network_key(value_data_ptr, value_data_len);
 		if (ncp_state_is_joining_or_joined(get_ncp_state())) {
 			if (network_key != mNetworkKey) {
 				mNetworkKey = network_key;
 				signal_property_changed(kWPANTUNDProperty_NetworkKey, mNetworkKey);
 			}
 		}
 
 	} else if (key == SPINEL_PROP_NET_KEY_SEQUENCE_COUNTER) {
 		uint32_t network_key_index;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT32_S, &network_key_index);
 		if (network_key_index != mNetworkKeyIndex) {
 			mNetworkKeyIndex = network_key_index;
 			signal_property_changed(kWPANTUNDProperty_NetworkKeyIndex, mNetworkKeyIndex);
 		}
 
 	} else if (key == SPINEL_PROP_PHY_CHAN) {
 		unsigned int value;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT_PACKED_S, &value);
 		syslog(LOG_INFO, "[-NCP-]: Channel %d", value);
 		if (value != mCurrentNetworkInstance.channel) {
 			mCurrentNetworkInstance.channel = value;
 			signal_property_changed(kWPANTUNDProperty_NCPChannel, mCurrentNetworkInstance.channel);
 		}
 
 	} else if (key == SPINEL_PROP_PHY_CHAN_SUPPORTED) {
 
 		uint8_t channel;
 		spinel_ssize_t len = 0;
 
 		mSupprotedChannels.clear();
 
 		while (value_data_len > 0)
 		{
 			len = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT8_S, &channel);
 			mSupprotedChannels.insert(channel);
 
 			value_data_ptr += len;
 			value_data_len -= len;
 		}
 
 	} else if (key == SPINEL_PROP_PHY_TX_POWER) {
 		int8_t value;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_INT8_S, &value);
 		syslog(LOG_INFO, "[-NCP-]: Tx power %d", value);
 		if (value != mTXPower) {
 			mTXPower = value;
 			signal_property_changed(kWPANTUNDProperty_NCPTXPower, mTXPower);
 		}
 
 	} else if (key == SPINEL_PROP_STREAM_DEBUG) {
 		handle_ncp_log(value_data_ptr, value_data_len);
 
 	} else if (key == SPINEL_PROP_NET_ROLE) {
 		uint8_t value;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT8_S, &value);
 		syslog(LOG_INFO, "[-NCP-]: Net Role \"%s\" (%d)", spinel_net_role_to_cstr(value), value);
 
 		if (ncp_state_is_joining_or_joined(get_ncp_state())
 		  && (value != SPINEL_NET_ROLE_DETACHED)
 		) {
 			change_ncp_state(ASSOCIATED);
 		}
 
 		if (value == SPINEL_NET_ROLE_CHILD) {
 			if ((mThreadMode & SPINEL_THREAD_MODE_RX_ON_WHEN_IDLE) != 0) {
 				update_node_type(END_DEVICE);
 			} else {
 				update_node_type(SLEEPY_END_DEVICE);
 			}
 
 		} else if (value == SPINEL_NET_ROLE_ROUTER) {
 			update_node_type(ROUTER);
 
 		} else if (value == SPINEL_NET_ROLE_LEADER) {
 			update_node_type(LEADER);
 
 		} else if (value == SPINEL_NET_ROLE_DETACHED) {
 			update_node_type(UNKNOWN);
 			if (ncp_state_is_associated(get_ncp_state())) {
 				change_ncp_state(ISOLATED);
 			}
 		}
 
 	} else if (key == SPINEL_PROP_THREAD_MODE) {
 		uint8_t value;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT8_S, &value);
 		syslog(LOG_INFO, "[-NCP-]: Thread Mode \"%s\" (0x%02x)", thread_mode_to_string(value).c_str(), value);
 		mThreadMode = value;
 
 		switch (mNodeType)
 		{
 		case END_DEVICE:
 		case SLEEPY_END_DEVICE:
 			if ((mThreadMode & SPINEL_THREAD_MODE_RX_ON_WHEN_IDLE) != 0) {
 				update_node_type(END_DEVICE);
 			} else {
 				update_node_type(SLEEPY_END_DEVICE);
 			}
 			break;
 
 		default:
 			break;
 		}
 
 	} else if (key == SPINEL_PROP_NET_SAVED) {
 		bool is_commissioned;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_BOOL_S, &is_commissioned);
 		syslog(LOG_INFO, "[-NCP-]: NetSaved (NCP is commissioned?) \"%s\" ", is_commissioned ? "yes" : "no");
 		mIsCommissioned = is_commissioned;
 		if (mIsCommissioned && (get_ncp_state() == OFFLINE)) {
 			change_ncp_state(COMMISSIONED);
 		} else if (!mIsCommissioned && (get_ncp_state() == COMMISSIONED)) {
 			change_ncp_state(OFFLINE);
 		}
 
 	} else if (key == SPINEL_PROP_NET_STACK_UP) {
 		bool is_stack_up;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_BOOL_S, &is_stack_up);
 		syslog(LOG_INFO, "[-NCP-]: Stack is %sup", is_stack_up ? "" : "not ");
 
 		if (is_stack_up) {
 			if (!ncp_state_is_joining_or_joined(get_ncp_state())) {
 				change_ncp_state(ASSOCIATING);
 			}
 		} else {
 			if (!ncp_state_is_joining(get_ncp_state())) {
 				change_ncp_state(mIsCommissioned ? COMMISSIONED : OFFLINE);
 			}
 		}
 
 	} else if (key == SPINEL_PROP_NET_IF_UP) {
 		bool is_if_up;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_BOOL_S, &is_if_up);
 		syslog(LOG_INFO, "[-NCP-]: Interface is %sup", is_if_up ? "" : "not ");
 
 		if (ncp_state_is_interface_up(get_ncp_state()) && !is_if_up) {
 			change_ncp_state(mIsCommissioned ? COMMISSIONED : OFFLINE);
 		}
 
 	} else if (key == SPINEL_PROP_THREAD_ON_MESH_NETS) {
 		std::map<struct in6_addr, OnMeshPrefixEntry>::const_iterator iter;
 		std::map<struct in6_addr, OnMeshPrefixEntry> on_mesh_prefixes(mOnMeshPrefixes);
 		int num_prefix = 0;
 
 		while (value_data_len > 0) {
 			spinel_ssize_t len = 0;
 			struct in6_addr *prefix = NULL;
 			uint8_t prefix_len = 0;
 			bool stable;
 			uint8_t flags = 0;
 			bool is_local;
 
 			len = spinel_datatype_unpack(value_data_ptr, value_data_len, "t(6CbCb)",
 						&prefix, &prefix_len, &stable, &flags, &is_local);
 
 			if (len < 1) {
 				break;
 			}
 
 			syslog(LOG_INFO, "[-NCP-]: On-mesh net [%d] \"%s/%d\" stable:%s local:%s flags:%s",
 				num_prefix,	in6_addr_to_string(*prefix).c_str(), prefix_len, stable ? "yes" : "no",
 				is_local ? "yes" : "no", on_mesh_prefix_flags_to_string(flags).c_str());
 
 			num_prefix++;
-			on_mesh_prefixes.erase(*prefix);
 
 			if (!is_local) {
+				on_mesh_prefixes.erase(*prefix);
 				on_mesh_prefix_was_added(kOriginThreadNCP, *prefix, prefix_len, flags, stable);
 			}
 
 			value_data_ptr += len;
 			value_data_len -= len;
 		}
 
 		// Since this was the whole list, we need to remove any prefixes
 		// which originated from NCP that that weren't in the new list.
 		for (iter = on_mesh_prefixes.begin(); iter != on_mesh_prefixes.end(); ++iter) {
 			if (iter->second.is_from_ncp()) {
 				on_mesh_prefix_was_removed(kOriginThreadNCP, iter->first, iter->second.get_prefix_len());
 			}
 		}
 
+	} else if (key == SPINEL_PROP_THREAD_OFF_MESH_ROUTES) {
+		handle_ncp_spinel_value_is_OFF_MESH_ROUTE(value_data_ptr, value_data_len);
+
 	} else if (key == SPINEL_PROP_THREAD_ASSISTING_PORTS) {
 		bool is_assisting = (value_data_len != 0);
 		uint16_t assisting_port(0);
 
 		if (is_assisting != get_current_network_instance().joinable) {
 			mCurrentNetworkInstance.joinable = is_assisting;
 			signal_property_changed(kWPANTUNDProperty_NestLabs_NetworkAllowingJoin, is_assisting);
 		}
 
 		if (is_assisting) {
 			int i;
 			syslog(LOG_NOTICE, "Network is joinable");
 			while (value_data_len > 0) {
 				i = spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT16_S, &assisting_port);
 				if (i <= 0) {
 					break;
 				}
 				syslog(LOG_NOTICE, "Assisting on port %d", assisting_port);
 				value_data_ptr += i;
 				value_data_len -= i;
 			}
 		} else {
 			syslog(LOG_NOTICE, "Network is not joinable");
 		}
 
 	} else if (key == SPINEL_PROP_JAM_DETECTED) {
 		bool jamDetected = false;
 
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_BOOL_S, &jamDetected);
 		signal_property_changed(kWPANTUNDProperty_JamDetectionStatus, jamDetected);
 
 		if (jamDetected) {
 			syslog(LOG_NOTICE, "Signal jamming is detected");
 		} else {
 			syslog(LOG_NOTICE, "Signal jamming cleared");
 		}
 
 	} else if (key == SPINEL_PROP_STREAM_RAW) {
 		if (mPcapManager.is_enabled()) {
 			const uint8_t* frame_ptr(NULL);
 			unsigned int frame_len(0);
 			const uint8_t* meta_ptr(NULL);
 			unsigned int meta_len(0);
 			spinel_ssize_t ret;
 			PcapPacket packet;
 			uint16_t flags = 0;
 
 			packet.set_timestamp().set_dlt(PCAP_DLT_IEEE802_15_4);
 
 			// Unpack the packet.
 			ret = spinel_datatype_unpack(
 				value_data_ptr,
 				value_data_len,
 				SPINEL_DATATYPE_DATA_WLEN_S SPINEL_DATATYPE_DATA_S,
 				&frame_ptr,
 				&frame_len,
 				&meta_ptr,
 				&meta_len
 			);
 
 			require(ret > 0, bail);
 
 			// Unpack the metadata.
 			ret = spinel_datatype_unpack(
 				meta_ptr,
 				meta_len,
 				SPINEL_DATATYPE_INT8_S     // RSSI/TXPower
 				SPINEL_DATATYPE_INT8_S     // Noise Floor
 				SPINEL_DATATYPE_UINT16_S,  // Flags
 				NULL,   // Ignore RSSI/TXPower
 				NULL,	// Ignore Noise Floor
 				&flags
 			);
 
 			__ASSERT_MACROS_check(ret > 0);
 
 			if ((flags & SPINEL_MD_FLAG_TX) == SPINEL_MD_FLAG_TX)
 			{
 				// Ignore FCS for transmitted packets
 				frame_len -= 2;
 				packet.set_dlt(PCAP_DLT_IEEE802_15_4_NOFCS);
 			}
 
 			mPcapManager.push_packet(
 				packet
 					.append_ppi_field(PCAP_PPI_TYPE_SPINEL, meta_ptr, meta_len)
 					.append_payload(frame_ptr, frame_len)
 			);
 		}
 
 	} else if (key == SPINEL_PROP_THREAD_TMF_PROXY_STREAM) {
 		const uint8_t* frame_ptr(NULL);
 		unsigned int frame_len(0);
 		uint16_t locator;
 		uint16_t port;
 		spinel_ssize_t ret;
 		Data data;
 
 		ret = spinel_datatype_unpack(
 			value_data_ptr,
 			value_data_len,
 			SPINEL_DATATYPE_DATA_S SPINEL_DATATYPE_UINT16_S SPINEL_DATATYPE_UINT16_S,
 			&frame_ptr,
 			&frame_len,
 			&locator,
 			&port
 		);
 
 		__ASSERT_MACROS_check(ret > 0);
 
 		// Analyze the packet to determine if it should be dropped.
 		if ((ret > 0)) {
 			// append frame
 			data.append(frame_ptr, frame_len);
 			// pack the locator in big endian.
 			data.push_back(locator >> 8);
 			data.push_back(locator & 0xff);
 			// pack the port in big endian.
 			data.push_back(port >> 8);
 			data.push_back(port & 0xff);
 			signal_property_changed(kWPANTUNDProperty_TmfProxyStream, data);
 		}
 
 	} else if ((key == SPINEL_PROP_STREAM_NET) || (key == SPINEL_PROP_STREAM_NET_INSECURE)) {
 		const uint8_t* frame_ptr(NULL);
 		unsigned int frame_len(0);
 		spinel_ssize_t ret;
 		uint8_t frame_data_type = FRAME_TYPE_DATA;
 
 		if (SPINEL_PROP_STREAM_NET_INSECURE == key) {
 			frame_data_type = FRAME_TYPE_INSECURE_DATA;
 		}
 
 		ret = spinel_datatype_unpack(
 			value_data_ptr,
 			value_data_len,
 			SPINEL_DATATYPE_DATA_S SPINEL_DATATYPE_DATA_S,
 			&frame_ptr,
 			&frame_len,
 			NULL,
 			NULL
 		);
 
 		__ASSERT_MACROS_check(ret > 0);
 
 		// Analyze the packet to determine if it should be dropped.
 		if ((ret > 0) && should_forward_hostbound_frame(&frame_data_type, frame_ptr, frame_len)) {
 			if (static_cast<bool>(mLegacyInterface) && (frame_data_type == FRAME_TYPE_LEGACY_DATA)) {
 				handle_alt_ipv6_from_ncp(frame_ptr, frame_len);
 			} else {
 				handle_normal_ipv6_from_ncp(frame_ptr, frame_len);
 			}
 		}
 	} else if (key == SPINEL_PROP_THREAD_CHILD_TABLE) {
 		SpinelNCPTaskGetNetworkTopology::Table child_table;
 		SpinelNCPTaskGetNetworkTopology::Table::iterator it;
 		int num_children = 0;
 
 		SpinelNCPTaskGetNetworkTopology::parse_child_table(value_data_ptr, value_data_len, child_table);
 
 		for (it = child_table.begin(); it != child_table.end(); it++)
 		{
 			num_children++;
 			syslog(LOG_INFO, "[-NCP-] Child: %02d %s", num_children, it->get_as_string().c_str());
 		}
 		syslog(LOG_INFO, "[-NCP-] Child: Total %d child%s", num_children, (num_children > 1) ? "ren" : "");
 
 	} else if (key == SPINEL_PROP_THREAD_NEIGHBOR_TABLE) {
 		SpinelNCPTaskGetNetworkTopology::Table neigh_table;
 		SpinelNCPTaskGetNetworkTopology::Table::iterator it;
 		int num_neighbor = 0;
 
 		SpinelNCPTaskGetNetworkTopology::parse_neighbor_table(value_data_ptr, value_data_len, neigh_table);
 
 		for (it = neigh_table.begin(); it != neigh_table.end(); it++)
 		{
 			num_neighbor++;
 			syslog(LOG_INFO, "[-NCP-] Neighbor: %02d %s", num_neighbor, it->get_as_string().c_str());
 		}
 		syslog(LOG_INFO, "[-NCP-] Neighbor: Total %d neighbor%s", num_neighbor, (num_neighbor > 1) ? "s" : "");
 
 	} else if (key == SPINEL_PROP_THREAD_ROUTER_TABLE) {
 		SpinelNCPTaskGetNetworkTopology::Table router_table;
 		SpinelNCPTaskGetNetworkTopology::Table::iterator it;
 		int num_router = 0;
 
 		SpinelNCPTaskGetNetworkTopology::parse_router_table(value_data_ptr, value_data_len, router_table);
 
 		for (it = router_table.begin(); it != router_table.end(); it++)
 		{
 			num_router++;
 			syslog(LOG_INFO, "[-NCP-] Router: %02d %s", num_router, it->get_as_string().c_str());
 		}
 		syslog(LOG_INFO, "[-NCP-] Router: Total %d router%s", num_router, (num_router > 1) ? "es" : "");
 
 
 	} else if (key == SPINEL_PROP_NET_PARTITION_ID) {
 		uint32_t paritition_id = 0;
 		spinel_datatype_unpack(value_data_ptr, value_data_len, SPINEL_DATATYPE_UINT32_S, &paritition_id);
 		syslog(LOG_INFO, "[-NCP-] Partition id: %u (0x%x)", paritition_id, paritition_id);
 
 	} else if (key == SPINEL_PROP_THREAD_LEADER_NETWORK_DATA) {
 		char net_data_cstr_buf[540];
 		encode_data_into_string(value_data_ptr, value_data_len, net_data_cstr_buf, sizeof(net_data_cstr_buf), 0);
 		syslog(LOG_INFO, "[-NCP-] Leader network data: [%s]", net_data_cstr_buf);
 	}
@@ -2758,21 +2772,21 @@ void
 SpinelNCPInstance::add_multicast_address_on_ncp(const struct in6_addr &addr, CallbackWithStatus cb)
 {
 	SpinelNCPTaskSendCommand::Factory factory(this);
 
-	syslog(LOG_NOTICE, "Adding multicast address \"%s\" on NCP", in6_addr_to_string(addr).c_str());
+	syslog(LOG_NOTICE, "Adding multicast address \"%s\" to NCP", in6_addr_to_string(addr).c_str());
 
 	factory.set_lock_property(SPINEL_PROP_THREAD_ALLOW_LOCAL_NET_DATA_CHANGE);
 	factory.set_callback(cb);
 
 	factory.add_command(
 		SpinelPackData(
 			SPINEL_FRAME_PACK_CMD_PROP_VALUE_INSERT(
 				SPINEL_DATATYPE_IPv6ADDR_S   // Address
 			),
 			SPINEL_PROP_IPV6_MULTICAST_ADDRESS_TABLE,
 			&addr
 		)
 	);
 
 	start_new_task(factory.finish());
 }
@@ -2832,38 +2846,143 @@ void
 SpinelNCPInstance::remove_on_mesh_prefix_on_ncp(const struct in6_addr &prefix, uint8_t prefix_len, uint8_t flags,
 	bool stable, CallbackWithStatus cb)
 {
 	SpinelNCPTaskSendCommand::Factory factory(this);
 
-	syslog(LOG_NOTICE, "Removing on-mesh prefix \"%s/%d\" to NCP", in6_addr_to_string(prefix).c_str(), prefix_len);
+	syslog(LOG_NOTICE, "Removing on-mesh prefix \"%s/%d\" from NCP", in6_addr_to_string(prefix).c_str(), prefix_len);
 
 	factory.set_lock_property(SPINEL_PROP_THREAD_ALLOW_LOCAL_NET_DATA_CHANGE);
 	factory.set_callback(cb);
 
 	factory.add_command(SpinelPackData(
 		SPINEL_FRAME_PACK_CMD_PROP_VALUE_REMOVE(
 			SPINEL_DATATYPE_IPv6ADDR_S
 			SPINEL_DATATYPE_UINT8_S
 			SPINEL_DATATYPE_BOOL_S
 			SPINEL_DATATYPE_UINT8_S
 		),
 		SPINEL_PROP_THREAD_ON_MESH_NETS,
 		&prefix,
 		prefix_len,
 		stable,
 		flags
 	));
 
 	start_new_task(factory.finish());
 }
 
+void
+SpinelNCPInstance::add_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+	bool stable, CallbackWithStatus cb)
+{
+	SpinelNCPTaskSendCommand::Factory factory(this);
+
+	syslog(LOG_NOTICE, "Adding off-mesh route \"%s/%d\" with preference %s to NCP", in6_addr_to_string(route).c_str(),
+		prefix_len, NCPControlInterface::external_route_priority_to_string(preference).c_str());
+
+	factory.set_lock_property(SPINEL_PROP_THREAD_ALLOW_LOCAL_NET_DATA_CHANGE);
+	factory.set_callback(cb);
+
+	factory.add_command(SpinelPackData(
+		SPINEL_FRAME_PACK_CMD_PROP_VALUE_INSERT(
+			SPINEL_DATATYPE_IPv6ADDR_S
+			SPINEL_DATATYPE_UINT8_S
+			SPINEL_DATATYPE_BOOL_S
+			SPINEL_DATATYPE_UINT8_S
+		),
+		SPINEL_PROP_THREAD_OFF_MESH_ROUTES,
+		&route,
+		prefix_len,
+		stable,
+		convert_route_preference_to_flags(preference)
+	));
+
+	start_new_task(factory.finish());
+}
+
+void
+SpinelNCPInstance::remove_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+	bool stable, CallbackWithStatus cb)
+{
+	SpinelNCPTaskSendCommand::Factory factory(this);
+
+	syslog(LOG_NOTICE, "Removing off-mesh route \"%s/%d\" with preference %s from NCP", in6_addr_to_string(route).c_str(),
+		prefix_len, NCPControlInterface::external_route_priority_to_string(preference).c_str());
+
+	factory.set_lock_property(SPINEL_PROP_THREAD_ALLOW_LOCAL_NET_DATA_CHANGE);
+	factory.set_callback(cb);
+
+	factory.add_command(SpinelPackData(
+		SPINEL_FRAME_PACK_CMD_PROP_VALUE_REMOVE(
+			SPINEL_DATATYPE_IPv6ADDR_S
+			SPINEL_DATATYPE_UINT8_S
+			SPINEL_DATATYPE_BOOL_S
+			SPINEL_DATATYPE_UINT8_S
+		),
+		SPINEL_PROP_THREAD_OFF_MESH_ROUTES,
+		&route,
+		prefix_len,
+		stable,
+		convert_route_preference_to_flags(preference)
+	));
+
+	start_new_task(factory.finish());
+}
+
+SpinelNCPInstance::RoutePreference
+SpinelNCPInstance::convert_flags_to_route_preference(uint8_t flags)
+{
+	RoutePreference preference = NCPControlInterface::ROUTE_MEDIUM_PREFERENCE;
+
+	switch (flags & SPINEL_NET_FLAG_PREFERENCE_MASK) {
+	case SPINEL_ROUTE_PREFERENCE_HIGH:
+		preference = NCPControlInterface::ROUTE_HIGH_PREFERENCE;
+		break;
+
+	case SPINEL_ROUTE_PREFERENCE_MEDIUM:
+		preference = NCPControlInterface::ROUTE_MEDIUM_PREFERENCE;
+		break;
+
+	case SPINEL_ROUTE_PREFERENCE_LOW:
+		preference = NCPControlInterface::ROUTE_LOW_PREFRENCE;
+		break;
+
+	default:
+		syslog(LOG_WARNING, "Invalid RoutePreference flag 0x%02x (using MEDIUM instead)", flags);
+		break;
+	}
+
+	return preference;
+}
+
+uint8_t
+SpinelNCPInstance::convert_route_preference_to_flags(RoutePreference preference)
+{
+	uint8_t flags = SPINEL_ROUTE_PREFERENCE_MEDIUM;
+
+	switch (preference) {
+	case NCPControlInterface::ROUTE_HIGH_PREFERENCE:
+		flags = SPINEL_ROUTE_PREFERENCE_HIGH;
+		break;
+
+	case NCPControlInterface::ROUTE_MEDIUM_PREFERENCE:
+		flags = SPINEL_ROUTE_PREFERENCE_MEDIUM;
+		break;
+
+	case NCPControlInterface::ROUTE_LOW_PREFRENCE:
+		flags = SPINEL_ROUTE_PREFERENCE_LOW;
+		break;
+	}
+
+	return flags;
+}
+
 bool
 SpinelNCPInstance::is_busy(void)
 {
 	return NCPInstanceBase::is_busy()
 		|| !mTaskQueue.empty();
 }
 
-
 void
 SpinelNCPInstance::process(void)
 {
diff --git a/src/ncp-spinel/SpinelNCPInstance.h b/src/ncp-spinel/SpinelNCPInstance.h
index 9de91ea..0061d52 100644
--- a/src/ncp-spinel/SpinelNCPInstance.h
+++ b/src/ncp-spinel/SpinelNCPInstance.h
@@ -129,32 +129,42 @@ protected:
 protected:
 
 	int vprocess_init(int event, va_list args);
 	int vprocess_disabled(int event, va_list args);
 	int vprocess_associated(int event, va_list args);
 	int vprocess_resume(int event, va_list args);
 	int vprocess_offline(int event, va_list args);
 
 	void handle_ncp_spinel_callback(unsigned int command, const uint8_t* cmd_data_ptr, spinel_size_t cmd_data_len);
 	void handle_ncp_spinel_value_is(spinel_prop_key_t key, const uint8_t* value_data_ptr, spinel_size_t value_data_len);
 	void handle_ncp_spinel_value_inserted(spinel_prop_key_t key, const uint8_t* value_data_ptr, spinel_size_t value_data_len);
 	void handle_ncp_spinel_value_removed(spinel_prop_key_t key, const uint8_t* value_data_ptr, spinel_size_t value_data_len);
 	void handle_ncp_state_change(NCPState new_ncp_state, NCPState old_ncp_state);
 
+	void handle_ncp_spinel_value_is_OFF_MESH_ROUTE(const uint8_t* value_data_ptr, spinel_size_t value_data_len);
+
 	bool should_filter_address(const struct in6_addr &address, uint8_t prefix_len);
 	void filter_addresses(void);
 
 	virtual void add_unicast_address_on_ncp(const struct in6_addr &addr, uint8_t prefix_len,
-					CallbackWithStatus cb = NilReturn());
+					CallbackWithStatus cb);
 	virtual void remove_unicast_address_on_ncp(const struct in6_addr& addr, uint8_t prefix_len,
-					CallbackWithStatus cb = NilReturn());
+					CallbackWithStatus cb);
 
-	virtual void add_multicast_address_on_ncp(const struct in6_addr &addr, CallbackWithStatus cb = NilReturn());
-	virtual void remove_multicast_address_on_ncp(const struct in6_addr &addr, CallbackWithStatus cb = NilReturn());
+	virtual void add_multicast_address_on_ncp(const struct in6_addr &addr, CallbackWithStatus cb);
+	virtual void remove_multicast_address_on_ncp(const struct in6_addr &addr, CallbackWithStatus cb);
 
 	virtual void add_on_mesh_prefix_on_ncp(const struct in6_addr &addr, uint8_t prefix_len, uint8_t flags, bool stable,
-					CallbackWithStatus cb = NilReturn());
+					CallbackWithStatus cb);
 	virtual void remove_on_mesh_prefix_on_ncp(const struct in6_addr &addr, uint8_t prefix_len, uint8_t flags,
-					bool stable, CallbackWithStatus cb = NilReturn());
+					bool stable, CallbackWithStatus cb);
+
+	virtual void add_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+					bool stable, CallbackWithStatus cb);
+	virtual void remove_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+					bool stable, CallbackWithStatus cb);
+
+	static RoutePreference convert_flags_to_route_preference(uint8_t flags);
+	static uint8_t convert_route_preference_to_flags(RoutePreference priority);
 
 	uint32_t get_default_channel_mask(void);
 
diff --git a/src/util/TunnelIPv6Interface.cpp b/src/util/TunnelIPv6Interface.cpp
index d8016ac..4601e82 100644
--- a/src/util/TunnelIPv6Interface.cpp
+++ b/src/util/TunnelIPv6Interface.cpp
@@ -518,15 +518,15 @@ bail:
 
 
 bool
-TunnelIPv6Interface::add_route(const struct in6_addr *route, int prefixlen)
+TunnelIPv6Interface::add_route(const struct in6_addr *route, int prefixlen, uint32_t metric)
 {
 	bool ret = false;
 
-	if (netif_mgmt_add_ipv6_route(mNetifMgmtFD, mInterfaceName.c_str(), route->s6_addr, prefixlen) != 0) {
+	if (netif_mgmt_add_ipv6_route(mNetifMgmtFD, mInterfaceName.c_str(), route->s6_addr, prefixlen, metric) != 0) {
 		mLastError = errno;
 		goto bail;
 	}
-	syslog(LOG_INFO, "Adding route prefix \"%s/%d\" -> \"%s\".",
+	syslog(LOG_INFO, "Adding route prefix \"%s/%d\" on interface \"%s\".",
 	       in6_addr_to_string(*route).c_str(), prefixlen, mInterfaceName.c_str());
 
 	ret = true;
@@ -536,16 +536,16 @@ bail:
 }
 
 bool
-TunnelIPv6Interface::remove_route(const struct in6_addr *route, int prefixlen)
+TunnelIPv6Interface::remove_route(const struct in6_addr *route, int prefixlen, uint32_t metric)
 {
 	bool ret = false;
 
-	if (netif_mgmt_remove_ipv6_route(mNetifMgmtFD, mInterfaceName.c_str(), route->s6_addr, prefixlen) != 0) {
+	if (netif_mgmt_remove_ipv6_route(mNetifMgmtFD, mInterfaceName.c_str(), route->s6_addr, prefixlen, metric) != 0) {
 		mLastError = errno;
 		goto bail;
 	}
 
-	syslog(LOG_INFO, "Removing route prefix \"%s/%d\" -> \"%s\".",
+	syslog(LOG_INFO, "Removing route prefix \"%s/%d\" on interface \"%s\".",
 	       in6_addr_to_string(*route).c_str(), prefixlen, mInterfaceName.c_str());
 
 	ret = true;
diff --git a/src/util/TunnelIPv6Interface.h b/src/util/TunnelIPv6Interface.h
index 4a425db..346ff4a 100644
--- a/src/util/TunnelIPv6Interface.h
+++ b/src/util/TunnelIPv6Interface.h
@@ -42,37 +42,37 @@ class TunnelIPv6Interface : public nl::UnixSocket
 public:
 	TunnelIPv6Interface(const std::string& interface_name = "", int mtu = 1280);
 
 	virtual ~TunnelIPv6Interface();
 
 	const std::string& get_interface_name(void);
 
 	int get_last_error(void);
 
 	bool is_up(void);
 	int set_up(bool isUp);
 
 	bool is_running(void);
 	int set_running(bool isRunning);
 
 	// This "online" is a bit of a mashup of "up" and "running".
 	// This is going to be phased out.
 	bool is_online(void);
 	int set_online(bool isOnline);
 
 	const struct in6_addr& get_realm_local_address()const;
 
 	bool add_address(const struct in6_addr *addr, int prefixlen = 64);
 	bool remove_address(const struct in6_addr *addr, int prefixlen = 64);
 
-	bool add_route(const struct in6_addr *route, int prefixlen = 64);
-	bool remove_route(const struct in6_addr *route, int prefixlen = 64);
+	bool add_route(const struct in6_addr *route, int prefixlen, uint32_t metric);
+	bool remove_route(const struct in6_addr *route, int prefixlen, uint32_t metric);
 
 	bool join_multicast_address(const struct in6_addr *addr);
 	bool leave_multicast_address(const struct in6_addr *addr);
 
 	virtual void reset(void);
 	virtual ssize_t write(const void* data, size_t len);
 	virtual ssize_t read(void* data, size_t len);
 
 	virtual int process(void);
 	virtual int update_fd_set(fd_set *read_fd_set, fd_set *write_fd_set, fd_set *error_fd_set, int *max_fd, cms_t *timeout);
diff --git a/src/util/netif-mgmt.c b/src/util/netif-mgmt.c
index 9f55066..cb5baeb 100644
--- a/src/util/netif-mgmt.c
+++ b/src/util/netif-mgmt.c
@@ -364,43 +364,43 @@ bail:
 }
 
 int
-netif_mgmt_add_ipv6_route(int reqfd, const char* if_name, const uint8_t route[16], int prefixlen)
+netif_mgmt_add_ipv6_route(int reqfd, const char* if_name, const uint8_t route[16], int prefixlen, uint32_t metric)
 {
 	int ret = -1;
 
 
 #ifdef __APPLE__
 
 	/************* Add ROUTE TODO *************/
 
 #else
 	/* Linux */
 
 	struct ifreq ifr;
 	struct in6_rtmsg rt;
 
 	memset(&ifr, 0, sizeof(struct ifreq));
 
 	strlcpy(ifr.ifr_name, if_name, sizeof(ifr.ifr_name));
 
 	memset(&rt, 0, sizeof(struct in6_rtmsg));
 	memcpy(rt.rtmsg_dst.s6_addr, route, sizeof(struct in6_addr));
 	rt.rtmsg_dst_len = prefixlen;
 	rt.rtmsg_flags = RTF_UP;
 	if (prefixlen == 128) {
 		rt.rtmsg_flags |= RTF_HOST;
 	}
-	rt.rtmsg_metric = 512;
+	rt.rtmsg_metric = metric;
 
 	ret = ioctl(reqfd, SIOGIFINDEX, &ifr);
 
 	require_string(ret >= 0, bail, strerror(errno));
 
 	rt.rtmsg_ifindex = ifr.ifr_ifindex;
 
 	ret = ioctl(reqfd, SIOCADDRT, &rt);
 
 	require_quiet(ret == 0 || errno == EALREADY || errno == EEXIST, bail);
 #endif
 
 	ret = 0;
@@ -410,42 +410,42 @@ bail:
 }
 
 int
-netif_mgmt_remove_ipv6_route(int reqfd, const char* if_name, const uint8_t route[16], int prefixlen)
+netif_mgmt_remove_ipv6_route(int reqfd, const char* if_name, const uint8_t route[16], int prefixlen, uint32_t metric)
 {
 	int ret = -1;
 
 
 #ifdef __APPLE__
 
 	/************* Remove ROUTE TODO *************/
 
 #else
 	/* Linux */
 
 	struct in6_rtmsg rt;
 
 	memset(&rt, 0, sizeof(struct in6_rtmsg));
 
 	memcpy(rt.rtmsg_dst.s6_addr, route, sizeof(struct in6_addr));
 
 	rt.rtmsg_dst_len = prefixlen;
 	rt.rtmsg_flags = RTF_UP;
-	rt.rtmsg_metric = 512;
+	rt.rtmsg_metric = metric;
 
 	if (prefixlen == 128) {
 		rt.rtmsg_flags |= RTF_HOST;
 	}
 
 	ret = netif_mgmt_get_ifindex(reqfd, if_name);
 
 	require_string(ret >= 0, bail, strerror(errno));
 
 	rt.rtmsg_ifindex = ret;
 
 	ret = ioctl(reqfd, SIOCDELRT, &rt);
 
 	require_quiet(ret == 0 || errno == EALREADY || errno == EEXIST, bail);
 
 #endif
 
 	ret = 0;
diff --git a/src/util/netif-mgmt.h b/src/util/netif-mgmt.h
index 5d2d16b..cdb2890 100644
--- a/src/util/netif-mgmt.h
+++ b/src/util/netif-mgmt.h
@@ -47,8 +47,8 @@ extern int netif_mgmt_set_running(int fd, const char* if_name, bool value);
 extern int netif_mgmt_add_ipv6_address(int fd, const char* if_name, const uint8_t addr[16], int prefixlen);
 extern int netif_mgmt_remove_ipv6_address(int fd, const char* if_name, const uint8_t addr[16]);
 
-extern int netif_mgmt_add_ipv6_route(int fd, const char* if_name, const uint8_t route[16], int prefixlen);
-extern int netif_mgmt_remove_ipv6_route(int fd, const char* if_name, const uint8_t route[16], int prefixlen);
+extern int netif_mgmt_add_ipv6_route(int fd, const char* if_name, const uint8_t route[16], int prefixlen, uint32_t metric);
+extern int netif_mgmt_remove_ipv6_route(int fd, const char* if_name, const uint8_t route[16], int prefixlen, uint32_t metric);
 
 extern int netif_mgmt_join_ipv6_multicast_address(int reqfd, const char* if_name, const uint8_t addr[16]);
 extern int netif_mgmt_leave_ipv6_multicast_address(int reqfd, const char* if_name, const uint8_t addr[16]);
diff --git a/src/wpantund/NCPControlInterface.cpp b/src/wpantund/NCPControlInterface.cpp
index 7db8216..59a95b1 100644
--- a/src/wpantund/NCPControlInterface.cpp
+++ b/src/wpantund/NCPControlInterface.cpp
@@ -47,20 +47,20 @@ std::string
 NCPControlInterface::external_route_priority_to_string(ExternalRoutePriority route_priority)
 {
 	const char *ret = "unknown";
 
 	switch(route_priority) {
 		case ROUTE_LOW_PREFRENCE:
 			ret = "low";
 			break;
 
 		case ROUTE_MEDIUM_PREFERENCE:
-			ret = "medium(normal)";
+			ret = "medium";
 			break;
 
 		case ROUTE_HIGH_PREFERENCE:
 			ret = "high";
 			break;
 	}
 
 	return ret;
 }
diff --git a/src/wpantund/NCPInstanceBase-Addresses.cpp b/src/wpantund/NCPInstanceBase-Addresses.cpp
index c6f690e..48d0864 100644
--- a/src/wpantund/NCPInstanceBase-Addresses.cpp
+++ b/src/wpantund/NCPInstanceBase-Addresses.cpp
@@ -1,33 +1,34 @@
 /*
  *
  * Copyright (c) 2016 Nest Labs, Inc.
  * All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  */
 
 #if HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <utility>
 #include "assert-macros.h"
 #include "NCPInstanceBase.h"
 #include "tunnel.h"
 #include <syslog.h>
 #include <errno.h>
 #include "nlpt.h"
 #include <algorithm>
 #include "socket-utils.h"
 #include "SuperSocket.h"
 #include "IPv6Helpers.h"
@@ -35,6 +36,40 @@
 using namespace nl;
 using namespace wpantund;
 
+NCPInstanceBase::IPv6Prefix::IPv6Prefix(const in6_addr &prefix, uint8_t len):
+	mPrefix(prefix), mLength(len)
+{
+	in6_addr_apply_mask(mPrefix, mLength);
+}
+
+bool
+NCPInstanceBase::IPv6Prefix::operator==(const IPv6Prefix &another_prefix) const
+{
+	return (mPrefix == another_prefix.mPrefix) && (mLength == another_prefix.mLength);
+}
+
+bool
+NCPInstanceBase::IPv6Prefix::operator<(const IPv6Prefix &another_prefix) const
+{
+	bool is_less = false;
+
+	if (mLength < another_prefix.mLength) {
+		is_less = true;
+	} else if (mLength == another_prefix.mLength) {
+		is_less = (memcmp(&mPrefix, &another_prefix.mPrefix, sizeof(mPrefix)) < 0);
+	}
+
+	return is_less;
+}
+
+std::string
+NCPInstanceBase::IPv6Prefix::to_string(void) const
+{
+	char c_string[100];
+	snprintf(c_string, sizeof(c_string), "%s/%d", in6_addr_to_string(mPrefix).c_str(), mLength);
+	return std::string(c_string);
+}
+
 std::string
 NCPInstanceBase::EntryBase::get_origin_as_string(void) const
 {
@@ -161,161 +196,273 @@ std::string
 NCPInstanceBase::OnMeshPrefixEntry::get_description(const struct in6_addr &address, bool align) const
 {
 	char c_string[300];
 
 	if (align) {
 		snprintf(c_string, sizeof(c_string), "%-22s prefix_len:%-4d origin:%-8s stable:%s %s",
 			in6_addr_to_string(address).c_str(), get_prefix_len(), get_origin_as_string().c_str(),
 			is_stable() ? "yes" : "no ", on_mesh_prefix_flags_to_string(get_flags(), true).c_str());
 
 	} else {
-		snprintf(c_string, sizeof(c_string), "\"%s/%d\", origin:%s, stable:%s, flags:%s, ",
+		snprintf(c_string, sizeof(c_string), "\"%s/%d\", origin:%s, stable:%s, flags:%s",
 			in6_addr_to_string(address).c_str(), get_prefix_len(), get_origin_as_string().c_str(),
 			is_stable() ? "yes" : "no", on_mesh_prefix_flags_to_string(get_flags()).c_str());
 	}
 
 	return std::string(c_string);
 }
 
+bool
+NCPInstanceBase::OffMeshRouteEntry::operator==(const OffMeshRouteEntry &entry)
+{
+	bool retval = true;
+
+	// Check the originator first.
+	if (get_origin() != entry.get_origin()) {
+		retval = false;
+		goto bail;
+	}
+
+	// If the entry is from NCP then ensure other fields also match.
+	if (is_from_ncp()) {
+
+		// Note that we intentionally don't check `mNextHopIsHost` as the RLOC16 value
+		// assigned to the node can be changed (e.g., after a re-attach) causing the
+		// `mNextHopIsHost` value to also change.
+
+		if ((mPreference != entry.mPreference) || (mStable != entry.mStable) || (mRloc != entry.mRloc)) {
+			retval = false;
+			goto bail;
+		}
+	}
+
+bail:
+	return retval;
+}
+
+std::string
+NCPInstanceBase::OffMeshRouteEntry::get_description(const IPv6Prefix &route, bool align) const
+{
+	char c_string[300];
+
+	if (align) {
+		snprintf(c_string, sizeof(c_string), "%-26s origin:%-8s stable:%s preference:%-7s rloc:0x%04x next_hop_is_host:%s",
+			route.to_string().c_str(), get_origin_as_string().c_str(), is_stable() ? "yes" : "no ",
+			NCPControlInterface::external_route_priority_to_string(get_preference()).c_str(), get_rloc(),
+			is_next_hop_host() ? "yes" : "no ");
+
+	} else {
+		snprintf(c_string, sizeof(c_string), "\"%s\", origin:%s, stable:%s, preference:%s, rloc:0x%04x, next_hop_is_host:%s",
+			route.to_string().c_str(), get_origin_as_string().c_str(), is_stable() ? "yes" : "no",
+			NCPControlInterface::external_route_priority_to_string(get_preference()).c_str(), get_rloc(),
+			is_next_hop_host() ? "yes" : "no");
+	}
+
+	return std::string(c_string);
+}
+
+std::string
+NCPInstanceBase::InterfaceRouteEntry::get_description(const IPv6Prefix &route, bool align) const
+{
+	char c_string[300];
+
+	if (align) {
+		snprintf(c_string, sizeof(c_string), "%-26s metric:%-6d", route.to_string().c_str(), mMetric);
+	} else {
+		snprintf(c_string, sizeof(c_string), "\"%s\", metric:%d", route.to_string().c_str(), mMetric);
+	}
+
+	return std::string(c_string);
+}
+
 // ========================================================================
 // MARK: Global Entries Management
 
 void
-NCPInstanceBase::refresh_address_entries(void)
+NCPInstanceBase::refresh_address_route_prefix_entries(void)
 {
-	// Here is where we would do any periodic global address bookkeeping,
-	// which doesn't appear to be necessary yet but may become necessary
-	// in the future.
+	if (mRequestRouteRefresh) {
+		mRequestRouteRefresh = false;
+		refresh_routes_on_interface();
+	}
 }
 
 void
-NCPInstanceBase::remove_all_address_prefix_entries(void)
+NCPInstanceBase::remove_all_address_prefix_route_entries(void)
 {
-	syslog(LOG_INFO, "Removing all address/prefix entries");
+	syslog(LOG_INFO, "Removing all address/prefix/route entries");
 
+	// Unicast addresses
 	for (
 		std::map<struct in6_addr, UnicastAddressEntry>::iterator iter = mUnicastAddresses.begin();
 		iter != mUnicastAddresses.end();
 		++iter
 	) {
 		mPrimaryInterface->remove_address(&iter->first, iter->second.get_prefix_len());
 	}
 
+	// Multicast addresses
 	for (
 		std::map<struct in6_addr, MulticastAddressEntry>::iterator iter = mMulticastAddresses.begin();
 		iter != mMulticastAddresses.end();
 		++iter
 	) {
 		mPrimaryInterface->leave_multicast_address(&iter->first);
 	}
 
+	// Routes
+	for (
+		std::map<IPv6Prefix, InterfaceRouteEntry>::iterator iter = mInterfaceRoutes.begin();
+		iter != mInterfaceRoutes.end();
+		++iter
+	) {
+		mPrimaryInterface->remove_route(&iter->first.get_prefix(), iter->first.get_length(), iter->second.get_metric());
+	}
+
 	memset(&mNCPLinkLocalAddress, 0, sizeof(mNCPLinkLocalAddress));
 	memset(&mNCPMeshLocalAddress, 0, sizeof(mNCPMeshLocalAddress));
 
 	mUnicastAddresses.clear();
 	mMulticastAddresses.clear();
 	mOnMeshPrefixes.clear();
+	mOffMeshRoutes.clear();
+	mInterfaceRoutes.clear();
 }
 
 void
-NCPInstanceBase::remove_ncp_originated_addresses(void)
+NCPInstanceBase::remove_ncp_originated_address_prefix_route_entries(void)
 {
 	bool did_remove = false;
 
-	// We remove all of the addresses/prefixes that originated
-	// from the NCP.
+	// We remove all of the addresses/prefixes/routes that originated from the NCP.
 
 	syslog(LOG_INFO, "Removing all NCP originated addresses");
 
 	// Unicast addresses
 	do {
 		std::map<struct in6_addr, UnicastAddressEntry>::iterator iter;
 
 		did_remove = false;
 
 		for (iter = mUnicastAddresses.begin(); iter != mUnicastAddresses.end(); iter++) {
 			if (!iter->second.is_from_ncp()) {
 				continue;
 			}
 
 			syslog(LOG_INFO, "UnicastAddresses: Removing %s", iter->second.get_description(iter->first).c_str());
 			mPrimaryInterface->remove_address(&iter->first, iter->second.get_prefix_len());
 
 			mUnicastAddresses.erase(iter);
 			did_remove = true;
 			break;
 		}
 	} while (did_remove);
 
 	// Multicast addresses
 	do {
 		std::map<struct in6_addr, MulticastAddressEntry>::iterator iter;
 
 		did_remove = false;
 
 		for (iter = mMulticastAddresses.begin(); iter != mMulticastAddresses.end(); iter++) {
 			if (!iter->second.is_from_ncp()) {
 				continue;
 			}
 
 			syslog(LOG_INFO, "MulticastAddresses: Removing %s", iter->second.get_description(iter->first).c_str());
 			mPrimaryInterface->leave_multicast_address(&iter->first);
 			mMulticastAddresses.erase(iter);
 			did_remove = true;
 			break;
 		}
 	} while (did_remove);
 
 	// On-Mesh Prefixes
 	do {
 		std::map<struct in6_addr, OnMeshPrefixEntry>::iterator iter;
 
 		did_remove = false;
 
 		for (iter = mOnMeshPrefixes.begin(); iter != mOnMeshPrefixes.end(); iter++) {
 			if (!iter->second.is_from_ncp()) {
 				continue;
 			}
 
 			syslog(LOG_INFO, "OnMeshPrefixes: Removing %s", iter->second.get_description(iter->first).c_str());
 			mOnMeshPrefixes.erase(iter);
 			did_remove = true;
 			break;
 		}
 	} while (did_remove);
+
+	// Off-Mesh Routes
+	do {
+		std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator iter;
+
+		did_remove = false;
+
+		for (iter = mOffMeshRoutes.begin(); iter != mOffMeshRoutes.end(); iter++) {
+			if (!iter->second.is_from_ncp()) {
+				continue;
+			}
+
+			syslog(LOG_INFO, "OffMeshRoutes: Removing %s", iter->second.get_description(iter->first).c_str());
+			mOffMeshRoutes.erase(iter);
+			did_remove = true;
+			mRequestRouteRefresh = true;
+			break;
+		}
+	} while (did_remove);
 }
 
 void
-NCPInstanceBase::restore_address_prefix_entries_on_ncp(void)
+NCPInstanceBase::restore_address_prefix_route_entries_on_ncp(void)
 {
-	syslog(LOG_INFO, "Restoring interface/user originated address/prefix entries on NCP");
+	syslog(LOG_INFO, "Restoring interface/user originated address/prefix/route entries on NCP");
 
+	// Unicast addresses
 	for (
 		std::map<struct in6_addr, UnicastAddressEntry>::iterator iter = mUnicastAddresses.begin();
 		iter != mUnicastAddresses.end();
 		++iter
 	) {
 		if (iter->second.is_from_interface() || iter->second.is_from_user()) {
 			add_address_on_ncp_and_update_prefixes(iter->first, iter->second);
 		}
 	}
 
+	// Multicast addresses
 	for (
 		std::map<struct in6_addr, MulticastAddressEntry>::iterator iter = mMulticastAddresses.begin();
 		iter != mMulticastAddresses.end();
 		++iter
 	) {
 		if (iter->second.is_from_interface() || iter->second.is_from_user()) {
-			add_multicast_address_on_ncp(iter->first);
+			add_multicast_address_on_ncp(iter->first,
+				boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "restoring multicast address", NilReturn()));
 		}
 	}
 
+	// On-mesh prefixes
 	for (
 		std::map<struct in6_addr, OnMeshPrefixEntry>::iterator iter = mOnMeshPrefixes.begin();
 		iter != mOnMeshPrefixes.end();
 		++iter
 	) {
 		if (iter->second.is_from_interface() || iter->second.is_from_user()) {
-			add_on_mesh_prefix_on_ncp(iter->first, iter->second.get_prefix_len(), iter->second.get_flags(), iter->second.is_stable());
+			add_on_mesh_prefix_on_ncp(iter->first, iter->second.get_prefix_len(), iter->second.get_flags(), iter->second.is_stable(),
+				boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "restoring on-mesh prefix", NilReturn()));
+		}
+	}
+
+	// Off-mesh-routes
+	for (
+		std::map<IPv6Prefix, OffMeshRouteEntry>::iterator iter = mOffMeshRoutes.begin();
+		iter != mOffMeshRoutes.end();
+		++iter
+	) {
+		if (iter->second.is_from_interface() || iter->second.is_from_user()) {
+			add_route_on_ncp(iter->first.get_prefix(), iter->first.get_length(), iter->second.get_preference(), iter->second.is_stable(),
+				boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "restoring off-mesh route", NilReturn()));
 		}
 	}
 }
@@ -323,14 +470,16 @@ NCPInstanceBase::restore_address_prefix_entries_on_ncp(void)
 void
 NCPInstanceBase::check_ncp_entry_update_status(int status, std::string operation, CallbackWithStatus cb)
 {
-	if (status == kWPANTUNDStatus_Timeout)
+	if (status != kWPANTUNDStatus_Ok)
 	{
-		syslog(LOG_ERR, "Timed out while performing \"%s\" on NCP - Resetting NCP.", operation.c_str());
+		syslog(LOG_ERR, "Error %s (%d) while performing \"%s\" on NCP - Resetting NCP.", wpantund_status_to_cstr(status),
+			status, operation.c_str());
+
 		ncp_is_misbehaving();
 	}
 
 	cb(status);
 }
 
 // ========================================================================
 // MARK: Unicast IPv6 Address Management
@@ -415,17 +564,18 @@ NCPInstanceBase::add_address_on_ncp_and_update_prefixes(const in6_addr &address,
 void
 NCPInstanceBase::remove_address_on_ncp_and_update_prefixes(const in6_addr &address, const UnicastAddressEntry &entry)
 {
-	remove_unicast_address_on_ncp(address, entry.get_prefix_len());
+	remove_unicast_address_on_ncp(address, entry.get_prefix_len(),
+		boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "removing unicast address", NilReturn()));
 
 	if (!entry.is_from_ncp()
 	   && !IN6_IS_ADDR_LINKLOCAL(&address)
 	   && (!buffer_is_nonzero(mNCPV6Prefix, sizeof(mNCPV6Prefix)) || (0 != memcmp(mNCPV6Prefix, &address, sizeof(mNCPV6Prefix))))
 	) {
 		struct in6_addr prefix = address;
 		in6_addr_apply_mask(prefix, entry.get_prefix_len());
 		on_mesh_prefix_was_removed(entry.get_origin(), address, entry.get_prefix_len());
 	}
 }
 
 // ========================================================================
 // MARK: Multicast IPv6 Address Management
@@ -434,16 +584,17 @@ void
 NCPInstanceBase::multicast_address_was_joined(Origin origin, const struct in6_addr &address)
 {
 	if (!mMulticastAddresses.count(address)) {
 		MulticastAddressEntry entry(origin);
 		mMulticastAddresses[address] = entry;
 		syslog(LOG_INFO, "MulticastAddresses: Adding %s", entry.get_description(address).c_str());
 
 		if ((origin == kOriginThreadNCP) || (origin == kOriginUser)) {
 			mPrimaryInterface->join_multicast_address(&address);
 		}
 
 		if ((origin == kOriginPrimaryInterface) || (origin == kOriginUser)) {
-			add_multicast_address_on_ncp(address);
+			add_multicast_address_on_ncp(address,
+				boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "adding multicast address", NilReturn()));
 		}
 	}
 }
@@ -452,25 +603,26 @@ void
 NCPInstanceBase::multicast_address_was_left(Origin origin, const struct in6_addr &address)
 {
 	if (mMulticastAddresses.count(address)) {
 		MulticastAddressEntry entry = mMulticastAddresses[address];
 
 		// Allow remove if origin is user, or if it matches the
 		// originator of the entry (when it was previously added).
 
 		if ((origin == kOriginUser) || (origin == entry.get_origin())) {
 			syslog(LOG_INFO, "MulticastAddresses: Removing %s", entry.get_description(address).c_str());
 			mMulticastAddresses.erase(address);
 
 			if ((origin == kOriginThreadNCP) || (origin == kOriginUser)) {
 				mPrimaryInterface->leave_multicast_address(&address);
 			}
 
 			if ((origin == kOriginPrimaryInterface) || (origin == kOriginUser)) {
-				remove_multicast_address_on_ncp(address);
+				remove_multicast_address_on_ncp(address,
+					boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "removing multicast address", NilReturn()));
 			}
 		}
 	}
 }
 
 // ========================================================================
 // MARK: On-Mesh Prefix Management
@@ -501,35 +653,35 @@ void
 NCPInstanceBase::on_mesh_prefix_was_added(Origin origin, const struct in6_addr &prefix_address, uint8_t prefix_len,
 	uint8_t flags, bool stable, CallbackWithStatus cb)
 {
 	struct in6_addr prefix(prefix_address);
 	OnMeshPrefixEntry entry;
 
 	in6_addr_apply_mask(prefix, prefix_len);
 
 	if (!mOnMeshPrefixes.count(prefix)) {
 		entry = OnMeshPrefixEntry(origin, flags, prefix_len, stable);
 
 		mOnMeshPrefixes[prefix] = entry;
 		syslog(LOG_INFO, "OnMeshPrefixes: Adding %s", entry.get_description(prefix).c_str());
 
 		if ((origin == kOriginPrimaryInterface) || (origin == kOriginUser)) {
 			add_on_mesh_prefix_on_ncp(prefix, prefix_len, flags, stable,
 				boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "adding on-mesh prefix", cb));
 		} else {
 			cb(kWPANTUNDStatus_Ok);
 		}
 	} else {
 		entry = mOnMeshPrefixes[prefix];
-		cb(kWPANTUNDStatus_Already);
+		cb(kWPANTUNDStatus_Ok);
 	}
 
 	if (entry.is_on_mesh() && entry.is_slaac()
 		&& !lookup_address_for_prefix(NULL, prefix, prefix_len)
 	) {
 		struct in6_addr address = make_slaac_addr_from_eui64(prefix.s6_addr, mMACAddress);
 		syslog(LOG_NOTICE, "Pushing a new SLAAC address %s/%d to NCP", in6_addr_to_string(address).c_str(), prefix_len);
 		add_unicast_address_on_ncp(address, prefix_len,
 			boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "adding SLAAC address", NilReturn()));
 		unicast_address_was_added(kOriginThreadNCP, address, prefix_len);
 	}
 }
@@ -538,39 +690,255 @@ void
 NCPInstanceBase::on_mesh_prefix_was_removed(Origin origin, const struct in6_addr &prefix_address, uint8_t prefix_len,
 	CallbackWithStatus cb)
 {
 	struct in6_addr prefix(prefix_address);
 	in6_addr_apply_mask(prefix, prefix_len);
 
 	if (mOnMeshPrefixes.count(prefix)) {
 		OnMeshPrefixEntry entry = mOnMeshPrefixes[prefix];
 		uint8_t prefix_len = entry.get_prefix_len();
 
 		// Allow remove if request is coming from the originator of the prefix, or if
 		// the prefix was added from an added IPv6 address on interface and now
 		// user is removing it.
 
 		if ((entry.get_origin() == origin) || (entry.is_from_interface() && (origin == kOriginUser))) {
 			struct in6_addr address;
 
 			syslog(LOG_INFO, "OnMeshPrefixes: Removing %s", entry.get_description(prefix).c_str());
 			mOnMeshPrefixes.erase(prefix);
 
 			if ((origin == kOriginPrimaryInterface) || (origin == kOriginUser)) {
-				remove_on_mesh_prefix_on_ncp(prefix, entry.get_prefix_len(), entry.get_flags(), entry.is_stable(), cb);
+				remove_on_mesh_prefix_on_ncp(prefix, entry.get_prefix_len(), entry.get_flags(), entry.is_stable(),
+					boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "removing on-mesh prefix", cb));
 			} else {
 				cb(kWPANTUNDStatus_Ok);
 			}
 
 			if (lookup_address_for_prefix(&address, prefix, prefix_len)
 				&& entry.is_slaac() && entry.is_on_mesh()
 			) {
 				syslog(LOG_NOTICE, "Removing SLAAC address %s/%d from NCP", in6_addr_to_string(address).c_str(), prefix_len);
-				remove_unicast_address_on_ncp(address, prefix_len);
+				remove_unicast_address_on_ncp(address, prefix_len,
+					boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "removing SLAAC address", NilReturn()));
 			}
 		} else {
 			cb(kWPANTUNDStatus_InvalidForCurrentState);
 		}
 	} else {
-		cb(kWPANTUNDStatus_Already);
+		cb(kWPANTUNDStatus_Ok);
+	}
+}
+
+// ========================================================================
+// MARK: Route Management
+
+// Searches for a given route entry in the `mOffMeshRoutes` multimap.
+std::multimap<NCPInstanceBase::IPv6Prefix, NCPInstanceBase::OffMeshRouteEntry>::iterator
+NCPInstanceBase::find_route_entry(const IPv6Prefix &route, const OffMeshRouteEntry &entry)
+{
+	std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator iter;
+
+	iter = mOffMeshRoutes.lower_bound(route);
+
+	if (iter != mOffMeshRoutes.end()) {
+		std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator upper_iter = mOffMeshRoutes.upper_bound(route);
+
+		for (; iter != upper_iter; iter++) {
+			if (iter->second == entry) {
+				break;
+			}
+		}
+
+		if (iter == upper_iter) {
+			iter = mOffMeshRoutes.end();
+		}
+	}
+
+	return iter;
+}
+
+void
+NCPInstanceBase::route_was_added(Origin origin, const struct in6_addr &route_prefix, uint8_t prefix_len, RoutePreference preference,
+	bool stable, uint16_t rloc16, bool next_hop_is_host, CallbackWithStatus cb)
+{
+	OffMeshRouteEntry entry(origin, preference, stable, rloc16, next_hop_is_host);
+	IPv6Prefix route(route_prefix, prefix_len);
+	std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator iter;
+
+	iter = find_route_entry(route, entry);
+
+	if (iter == mOffMeshRoutes.end()) {
+		mOffMeshRoutes.insert(std::make_pair(route, entry));
+		mRequestRouteRefresh = true;
+		syslog(LOG_INFO, "OffMeshRoutes: Adding %s", entry.get_description(route).c_str());
+
+		if (origin != kOriginThreadNCP) {
+			add_route_on_ncp(route.get_prefix(), prefix_len, preference, stable,
+				boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "adding off-mesh route", cb));
+
+		} else {
+			cb(kWPANTUNDStatus_Ok);
+		}
+	} else {
+		cb(kWPANTUNDStatus_Ok);
+	}
+}
+
+void
+NCPInstanceBase::route_was_removed(Origin origin, const struct in6_addr &route_prefix, uint8_t prefix_len,
+	RoutePreference preference, bool stable, uint16_t rloc16, CallbackWithStatus cb)
+{
+	OffMeshRouteEntry entry(origin, preference, stable, rloc16);
+	std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator iter;
+	IPv6Prefix route(route_prefix, prefix_len);
+
+	iter = find_route_entry(route, entry);
+
+	if (iter != mOffMeshRoutes.end()) {
+		syslog(LOG_INFO, "OffMeshRoutes: Removing %s", iter->second.get_description(route).c_str());
+		mOffMeshRoutes.erase(iter);
+		mRequestRouteRefresh = true;
+
+		if (origin != kOriginThreadNCP) {
+			remove_route_on_ncp(route.get_prefix(), prefix_len, preference, stable,
+				boost::bind(&NCPInstanceBase::check_ncp_entry_update_status, this, _1, "removing off-mesh route", cb));
+
+		} else {
+			cb(kWPANTUNDStatus_Ok);
+		}
+	} else {
+		cb(kWPANTUNDStatus_Ok);
+	}
+}
+
+// Decides if the given route should be added on the primary interface, if we need to add the route `metric` is also
+// updated.
+bool
+NCPInstanceBase::should_add_route_on_interface(const IPv6Prefix &route, uint32_t &metric)
+{
+	bool should_add = false;
+	bool route_added_by_device = false;
+	bool route_added_by_others = false;
+	RoutePreference preference_device = NCPControlInterface::ROUTE_LOW_PREFRENCE;
+	RoutePreference preference_others = NCPControlInterface::ROUTE_LOW_PREFRENCE;
+
+	std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator iter, sub_iter, upper_iter;
+
+	for (iter = mOffMeshRoutes.begin(); iter != mOffMeshRoutes.end(); iter = upper_iter) {
+
+		// Get the iterator pointing to the first element that is greater than current key/route.
+		upper_iter = mOffMeshRoutes.upper_bound(iter->first);
+
+		// Skip all elements for which the multimap key does not match the route.
+		if (iter->first != route) {
+			continue;
+		}
+
+		// Iterate through all multimap elements with same key (i.e., same route).
+		for (sub_iter = iter; sub_iter != upper_iter; ++sub_iter) {
+
+			if ((sub_iter->second.get_origin() != kOriginThreadNCP) || sub_iter->second.is_next_hop_host()) {
+				route_added_by_device = true;
+				if (preference_device < sub_iter->second.get_preference()) {
+					preference_device = sub_iter->second.get_preference();
+				}
+			} else {
+				route_added_by_others = true;
+				if (preference_others < sub_iter->second.get_preference()) {
+					preference_others = sub_iter->second.get_preference();
+				}
+			}
+		}
+	}
+
+	// The route should be added on host primary interface, if it
+	// is added by at least one other device within the network and,
+	// either it is not added by host/this-device or added but with
+	// a lower preference level.
+
+	if (route_added_by_others) {
+		if (!route_added_by_device || (preference_others > preference_device)) {
+			should_add = true;
+		}
+	}
+
+	// If the route should be added, map the preference level to route metric.
+
+	if (should_add) {
+		switch (preference_others) {
+		case NCPControlInterface::ROUTE_LOW_PREFRENCE:
+			metric = InterfaceRouteEntry::kRouteMetricLow;
+			break;
+
+		case NCPControlInterface::ROUTE_MEDIUM_PREFERENCE:
+			metric = InterfaceRouteEntry::kRouteMetricMedium;
+			break;
+
+		case NCPControlInterface::ROUTE_HIGH_PREFERENCE:
+			metric = InterfaceRouteEntry::kRouteMetricHigh;
+			break;
+		}
+	}
+
+	return should_add;
+}
+
+void
+NCPInstanceBase::refresh_routes_on_interface(void)
+{
+	bool did_remove = false;
+	uint32_t metric;
+
+	syslog(LOG_INFO, "Refreshing routes on primary interface");
+
+	// First, check all currently added routes on primary interface and remove any one that is no longer valid.
+
+	do {
+		std::map<IPv6Prefix, InterfaceRouteEntry>::iterator iter;
+
+		did_remove = false;
+
+		for (iter = mInterfaceRoutes.begin(); iter != mInterfaceRoutes.end(); iter++) {
+
+			// If the route should not be added on interface or it has been added with
+			// incorrect metric value, remove it from the `mInterfaceRoute` list (note
+			// that it will be re-added if route metric is changed).
+
+			if (!should_add_route_on_interface(iter->first, metric)
+				|| (metric != iter->second.get_metric())
+			) {
+				syslog(LOG_INFO, "InterfaceRoutes: Removing %s", iter->second.get_description(iter->first).c_str());
+				mPrimaryInterface->remove_route(&iter->first.get_prefix(), iter->first.get_length(),
+					iter->second.get_metric());
+				mInterfaceRoutes.erase(iter);
+
+				// We removed an element from `mInterfaceRoutes` while iterating over it,
+				// so we break from the `for` loop and start the iteration over again on the
+				// new updated `mInterfaceRoutes` list.
+
+				did_remove = true;
+				break;
+			}
+		}
+	} while (did_remove);
+
+	// Iterate through all off-mesh route entries to check if there is a new route that should be added on interface.
+
+	{
+		std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator iter, upper_iter;
+
+		for (iter = mOffMeshRoutes.begin(); iter != mOffMeshRoutes.end(); iter = upper_iter) {
+
+			// Get the iterator pointing to the first element that is greater than current key/route.
+			upper_iter = mOffMeshRoutes.upper_bound(iter->first);
+
+			if (should_add_route_on_interface(iter->first, metric)
+				&& (mInterfaceRoutes.count(iter->first) == 0)
+			) {
+				syslog(LOG_INFO, "InterfaceRoutes: Adding %s", iter->second.get_description(iter->first).c_str());
+				mPrimaryInterface->add_route(&iter->first.get_prefix(), iter->first.get_length(), metric);
+				mInterfaceRoutes[iter->first] = InterfaceRouteEntry(metric);
+			}
+		}
 	}
 }
diff --git a/src/wpantund/NCPInstanceBase-AsyncIO.cpp b/src/wpantund/NCPInstanceBase-AsyncIO.cpp
index 3bba304..0513035 100644
--- a/src/wpantund/NCPInstanceBase-AsyncIO.cpp
+++ b/src/wpantund/NCPInstanceBase-AsyncIO.cpp
@@ -137,25 +137,29 @@ cms_t
 NCPInstanceBase::get_ms_to_next_event(void)
 {
 	cms_t ret(EventHandler::get_ms_to_next_event());
 
 	mSerialAdapter->update_fd_set(NULL, NULL, NULL, NULL, &ret);
 	mPrimaryInterface->update_fd_set(NULL, NULL, NULL, NULL, &ret);
 	mFirmwareUpgrade.update_fd_set(NULL, NULL, NULL, NULL, &ret);
 
 	if (mWasBusy && (mLastChangedBusy != 0)) {
 		cms_t temp_cms(MAX_INSOMNIA_TIME_IN_MS - (time_ms() - mLastChangedBusy));
 		if (temp_cms < ret) {
 			ret = temp_cms;
 		}
 
 		if (ret > BUSY_DEBOUNCE_TIME_IN_MS && !is_busy()) {
 			ret = BUSY_DEBOUNCE_TIME_IN_MS;
 		}
 	}
 
+	if (mRequestRouteRefresh) {
+		ret = 0;
+	}
+
 	if (ret < 0) {
 		ret = 0;
 	}
 
 	return ret;
 }
@@ -201,33 +205,33 @@ void
 NCPInstanceBase::process(void)
 {
 	int ret = 0;
 
 	mRunawayResetBackoffManager.update();
 
 	mFirmwareUpgrade.process();
 
 	mPcapManager.process();
 
 	if (get_upgrade_status() != EINPROGRESS) {
-		refresh_address_entries();
+		refresh_address_route_prefix_entries();
 
 		require_noerr(ret = mPrimaryInterface->process(), socket_failure);
 
 		if (is_legacy_interface_enabled()) {
 			mLegacyInterface->process();
 		}
 
 		require_noerr(ret = mSerialAdapter->process(), socket_failure);
 
 		ncp_to_driver_pump();
 	}
 
 	EventHandler::process_event(EVENT_IDLE);
 
 	if (get_upgrade_status() != EINPROGRESS) {
 		driver_to_ncp_pump();
 	}
 
     update_busy_indication();
 
 	return;
diff --git a/src/wpantund/NCPInstanceBase-NetInterface.cpp b/src/wpantund/NCPInstanceBase-NetInterface.cpp
index fe9d948..1718e05 100644
--- a/src/wpantund/NCPInstanceBase-NetInterface.cpp
+++ b/src/wpantund/NCPInstanceBase-NetInterface.cpp
@@ -70,28 +70,28 @@ int
 NCPInstanceBase::set_online(bool is_online)
 {
 	int ret = 0;
 
 	if (mIsInterfaceOnline != is_online) {
 		mIsInterfaceOnline = is_online;
 
 		ret = mPrimaryInterface->set_online(is_online);
 
 		if (is_online) {
-			restore_address_prefix_entries_on_ncp();
+			restore_address_prefix_route_entries_on_ncp();
 		}
 
 		if ((ret == 0) && static_cast<bool>(mLegacyInterface)) {
 			if (is_online && mNodeTypeSupportsLegacy) {
 				ret = mLegacyInterface->set_online(true);
 
 				if (IN6_IS_ADDR_LINKLOCAL(&mNCPLinkLocalAddress)) {
 					mLegacyInterface->add_address(&mNCPLinkLocalAddress);
 				}
 			} else {
 				ret = mLegacyInterface->set_online(false);
 			}
 		}
 	}
 
 	return ret;
 }
@@ -148,17 +148,17 @@ void
 NCPInstanceBase::reset_interface(void)
 {
 	syslog(LOG_NOTICE, "Resetting interface(s). . .");
 
 	mCurrentNetworkInstance.joinable = false;
 
 	set_commissioniner(0, 0, 0);
 
 	mPrimaryInterface->reset();
 
-	// The global entries table (addresses, prefixes) must be cleared upon reset
-	remove_all_address_prefix_entries();
+	// All IPv6 address (unicast/multicast), on-mesh-prefixes, routes (off-mesh/interface) must be cleared upon reset.
+	remove_all_address_prefix_route_entries();
 
 	if (static_cast<bool>(mLegacyInterface)) {
 		mLegacyInterface->reset();
 	}
 }
diff --git a/src/wpantund/NCPInstanceBase.cpp b/src/wpantund/NCPInstanceBase.cpp
index 8be7b74..f55fc97 100644
--- a/src/wpantund/NCPInstanceBase.cpp
+++ b/src/wpantund/NCPInstanceBase.cpp
@@ -44,137 +44,138 @@ using namespace wpantund;
 NCPInstanceBase::NCPInstanceBase(const Settings& settings):
 	mCommissioningRule(),
 	mCommissioningExpiration(0)
 {
 	std::string wpan_interface_name = "wpan0";
 
 	mResetFD = -1;
 	mResetFD_BeginReset = '0';
 	mResetFD_EndReset = '1';
 
 	mPowerFD = -1;
 	mPowerFD_PowerOff = '0';
 	mPowerFD_PowerOn = '1';
 
 	NLPT_INIT(&mNCPToDriverPumpPT);
 	NLPT_INIT(&mDriverToNCPPumpPT);
 
 	mAutoDeepSleep = false;
 	mAutoDeepSleepTimeout = 10;
 	mAutoResume = true;
 	mAutoUpdateFirmware = false;
 	mCommissionerPort = 5684;
 	mCommissioningExpiration = 0;
 	mEnabled = true;
 	mFailureCount = 0;
 	mFailureThreshold = 3;
 	mIsInitializingNCP = false;
 	mIsInterfaceOnline = false;
 	mLastChangedBusy = 0;
 	mLegacyInterfaceEnabled = false;
 	mNCPState = UNINITIALIZED;
+	mRequestRouteRefresh = false;
 	mNodeType = UNKNOWN;
 	mNodeTypeSupportsLegacy = false;
 	mSetDefaultRouteForAutoAddedPrefix = false;
 	mSetSLAACForAutoAddedPrefix = false;
 	mTerminateOnFault = false;
 	mWasBusy = false;
 
 	memset(mNCPMeshLocalAddress.s6_addr, 0, sizeof(mNCPMeshLocalAddress));
 	memset(mNCPLinkLocalAddress.s6_addr, 0, sizeof(mNCPLinkLocalAddress));
 	memset(mNCPV6LegacyPrefix, 0, sizeof(mNCPV6LegacyPrefix));
 	memset(mMACAddress, 0, sizeof(mMACAddress));
 	memset(mMACHardwareAddress, 0, sizeof(mMACHardwareAddress));
 
 	if (!settings.empty()) {
 		Settings::const_iterator iter;
 
 		for(iter = settings.begin(); iter != settings.end(); iter++) {
 			if (strcaseequal(iter->first.c_str(), kWPANTUNDProperty_ConfigNCPHardResetPath)) {
 				mResetFD = open_super_socket(iter->second.c_str());
 
 			} else if (strcaseequal(iter->first.c_str(), kWPANTUNDProperty_ConfigNCPPowerPath)) {
 				mPowerFD = open_super_socket(iter->second.c_str());
 
 			} else if (strcaseequal(iter->first.c_str(), kWPANTUNDProperty_ConfigNCPSocketPath)) {
 				mRawSerialAdapter = SuperSocket::create(iter->second);
 
 			} else if (strcaseequal(iter->first.c_str(), kWPANTUNDProperty_ConfigTUNInterfaceName)) {
 				wpan_interface_name = iter->second;
 
 			} else if (strcaseequal(iter->first.c_str(), kWPANTUNDProperty_ConfigNCPFirmwareCheckCommand)) {
 				mFirmwareUpgrade.set_firmware_check_command(iter->second);
 
 			} else if (strcaseequal(iter->first.c_str(), kWPANTUNDProperty_ConfigNCPFirmwareUpgradeCommand)) {
 				mFirmwareUpgrade.set_firmware_upgrade_command(iter->second);
 
 			} else if (strcaseequal(iter->first.c_str(), kWPANTUNDProperty_DaemonAutoFirmwareUpdate)) {
 				mAutoUpdateFirmware = any_to_bool(boost::any(iter->second));
 
 			} else if (strcaseequal(iter->first.c_str(), kWPANTUNDProperty_ConfigDaemonNetworkRetainCommand)) {
 				mNetworkRetain.set_network_retain_command(iter->second);
 			}
 		}
 	}
 
 	if (!mRawSerialAdapter) {
 		syslog(LOG_WARNING, kWPANTUNDProperty_ConfigNCPSocketPath" was not specified. Using \"/dev/null\" instead.");
 		mRawSerialAdapter = SuperSocket::create("/dev/null");
 	}
 
 	if (mRawSerialAdapter) {
 		mRawSerialAdapter->set_log_level(LOG_DEBUG);
 	}
 
 	mSerialAdapter = mRawSerialAdapter;
 
 	mPrimaryInterface = boost::shared_ptr<TunnelIPv6Interface>(new TunnelIPv6Interface(wpan_interface_name));
 	mPrimaryInterface->mAddressWasAdded.connect(boost::bind(&NCPInstanceBase::unicast_address_was_added, this, kOriginPrimaryInterface, _1, _2, UINT32_MAX, UINT32_MAX));
 	mPrimaryInterface->mAddressWasRemoved.connect(boost::bind(&NCPInstanceBase::unicast_address_was_removed, this, kOriginPrimaryInterface, _1));
 	mPrimaryInterface->mLinkStateChanged.connect(boost::bind(&NCPInstanceBase::link_state_changed, this, _1, _2));
 
 	set_ncp_power(true);
 
 	// Go ahead and start listening on ff03::1
 	join_multicast_group("ff03::1");
 
 	{
 		IPv6PacketMatcherRule rule;
 
 		// --------------------------------------------------------------------
 		// Packet Drop rules
 
 		rule.clear();
 		// OS X seems to generate these packets when bringing up the interface.
 		// Honey badger don't care.
 		rule.type = IPv6PacketMatcherRule::TYPE_HOP_BY_HOP;
 		rule.remote_address.s6_addr[0x0] = 0xFF;
 		rule.remote_address.s6_addr[0x1] = 0x02;
 		rule.remote_address.s6_addr[0xF] = 0x16;
 		rule.remote_match_mask = 128;
 		mDropFirewall.insert(rule);
 
 		rule.clear();
 		// Don't forward router advertisement or router solicitation
 		// traffic.
 		rule.type = IPv6PacketMatcherRule::TYPE_ICMP;
 		rule.remote_address.s6_addr[0x0] = 0xFF;
 		rule.remote_address.s6_addr[0x1] = 0x02;
 		rule.remote_address.s6_addr[0xF] = 0x02;
 		rule.remote_match_mask = 128;
 		rule.subtype = IPv6PacketMatcherRule::SUBTYPE_ICMP_ROUTER_ADV;
 		mDropFirewall.insert(rule);
 		rule.subtype = IPv6PacketMatcherRule::SUBTYPE_ICMP_ROUTER_SOL;
 		mDropFirewall.insert(rule);
 
 		rule.clear();
 		// Don't forward neighbor advertisement or neighbor solicitation
 		// or redirect traffic.
 		rule.type = IPv6PacketMatcherRule::TYPE_ICMP;
 		rule.subtype = IPv6PacketMatcherRule::SUBTYPE_ICMP_NEIGHBOR_ADV;
 		mDropFirewall.insert(rule);
 		rule.subtype = IPv6PacketMatcherRule::SUBTYPE_ICMP_NEIGHBOR_SOL;
 		mDropFirewall.insert(rule);
 		rule.subtype = IPv6PacketMatcherRule::SUBTYPE_ICMP_REDIRECT;
 		mDropFirewall.insert(rule);
 	}
 }
@@ -251,59 +252,61 @@ std::set<std::string>
 NCPInstanceBase::get_supported_property_keys(void) const
 {
 	std::set<std::string> properties;
 
 	properties.insert(kWPANTUNDProperty_DaemonEnabled);
 	properties.insert(kWPANTUNDProperty_NetworkIsCommissioned);
 	properties.insert(kWPANTUNDProperty_InterfaceUp);
 	properties.insert(kWPANTUNDProperty_NetworkName);
 	properties.insert(kWPANTUNDProperty_NetworkPANID);
 	properties.insert(kWPANTUNDProperty_NetworkXPANID);
 	properties.insert(kWPANTUNDProperty_NetworkKey);
 	properties.insert(kWPANTUNDProperty_NetworkPSKc);
 	properties.insert(kWPANTUNDProperty_NetworkKeyIndex);
 	properties.insert(kWPANTUNDProperty_NetworkNodeType);
 	properties.insert(kWPANTUNDProperty_NCPState);
 	properties.insert(kWPANTUNDProperty_NCPChannel);
 	properties.insert(kWPANTUNDProperty_NCPTXPower);
 
 	properties.insert(kWPANTUNDProperty_IPv6MeshLocalPrefix);
 	properties.insert(kWPANTUNDProperty_IPv6MeshLocalAddress);
 	properties.insert(kWPANTUNDProperty_IPv6LinkLocalAddress);
 	properties.insert(kWPANTUNDProperty_IPv6AllAddresses);
 	properties.insert(kWPANTUNDProperty_IPv6MulticastAddresses);
 	properties.insert(kWPANTUNDProperty_IPv6SetSLAACForAutoAddedPrefix);
+	properties.insert(kWPANTUNDProperty_IPv6InterfaceRoutes);
 
 	properties.insert(kWPANTUNDProperty_ThreadOnMeshPrefixes);
+	properties.insert(kWPANTUNDProperty_ThreadOffMeshRoutes);
 
 	properties.insert(kWPANTUNDProperty_DaemonAutoAssociateAfterReset);
 	properties.insert(kWPANTUNDProperty_DaemonAutoDeepSleep);
 	properties.insert(kWPANTUNDProperty_DaemonReadyForHostSleep);
 	properties.insert(kWPANTUNDProperty_DaemonTerminateOnFault);
 	properties.insert(kWPANTUNDProperty_DaemonSetDefRouteForAutoAddedPrefix);
 
 	properties.insert(kWPANTUNDProperty_NestLabs_NetworkAllowingJoin);
 
 	properties.insert(kWPANTUNDProperty_DaemonVersion);
 	properties.insert(kWPANTUNDProperty_DaemonTerminateOnFault);
 
 	properties.insert(kWPANTUNDProperty_NCPVersion);
 	properties.insert(kWPANTUNDProperty_NCPHardwareAddress);
 	properties.insert(kWPANTUNDProperty_NCPCCAThreshold);
 
 	properties.insert(kWPANTUNDProperty_NCPMACAddress);
 
 
 	properties.insert(kWPANTUNDProperty_ConfigTUNInterfaceName);
 
 	if (mLegacyInterfaceEnabled
 		|| mNodeTypeSupportsLegacy
 		|| buffer_is_nonzero(mNCPV6LegacyPrefix, sizeof(mNCPV6LegacyPrefix))
 	) {
 		properties.insert(kWPANTUNDProperty_NestLabs_LegacyMeshLocalAddress);
 		properties.insert(kWPANTUNDProperty_NestLabs_LegacyMeshLocalPrefix);
 	}
 
 	properties.insert(kWPANTUNDProperty_NestLabs_NetworkPassthruPort);
 
 	return properties;
 }
@@ -312,217 +315,233 @@ void
 NCPInstanceBase::property_get_value(
 	const std::string& in_key,
 	CallbackWithStatusArg1 cb
 ) {
 	std::string key = in_key;
 
 	if (key.empty()) {
 		/* This key is used to get the list of available properties */
 		cb(0, get_supported_property_keys());
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ConfigTUNInterfaceName)) {
 		cb(0, get_name());
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_DaemonEnabled)) {
 		cb(0, boost::any(mEnabled));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_InterfaceUp)) {
 		cb(0, boost::any(mPrimaryInterface->is_online()));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_DaemonReadyForHostSleep)) {
 		cb(0, boost::any(!is_busy()));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ConfigTUNInterfaceName)) {
 		cb(0, get_name());
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPVersion)) {
 		cb(0, boost::any(mNCPVersionString));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkName)) {
 		cb(0, boost::any(get_current_network_instance().name));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkIsCommissioned)) {
 		NCPState ncp_state = get_ncp_state();
 		if (ncp_state_is_commissioned(ncp_state)) {
 			cb(0, boost::any(true));
 		} else  if (ncp_state == OFFLINE || ncp_state == DEEP_SLEEP) {
 			cb(0, boost::any(false));
 		} else {
 			cb(kWPANTUNDStatus_TryAgainLater,
 			   boost::any(std::string("Unable to determine association state at this time"))
 			);
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NestLabs_LegacyEnabled)) {
 		cb(0, boost::any(mLegacyInterfaceEnabled));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NestLabs_NetworkAllowingJoin)) {
 		cb(0, boost::any(get_current_network_instance().joinable));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkPANID)) {
 		cb(0, boost::any(get_current_network_instance().panid));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkXPANID)) {
 		cb(0, boost::any(get_current_network_instance().get_xpanid_as_uint64()));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPChannel)) {
 		cb(0, boost::any((int)get_current_network_instance().channel));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_DaemonVersion)) {
 		cb(0, boost::any(nl::wpantund::get_wpantund_version_string()));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_DaemonAutoAssociateAfterReset)) {
 		cb(0, boost::any(static_cast<bool>(mAutoResume)));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_DaemonAutoDeepSleep)) {
 		cb(0, boost::any(mAutoDeepSleep));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_DaemonAutoFirmwareUpdate)) {
 		cb(0, boost::any(mAutoUpdateFirmware));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_DaemonTerminateOnFault)) {
 		cb(0, boost::any(mTerminateOnFault));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_DaemonSetDefRouteForAutoAddedPrefix)) {
 		cb(0, boost::any(mSetDefaultRouteForAutoAddedPrefix));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NestLabs_NetworkPassthruPort)) {
 		cb(0, boost::any(mCommissionerPort));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPMACAddress)) {
 		cb(0, boost::any(nl::Data(mMACAddress, sizeof(mMACAddress))));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPHardwareAddress)) {
 		cb(0, boost::any(nl::Data(mMACHardwareAddress, sizeof(mMACHardwareAddress))));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6SetSLAACForAutoAddedPrefix)) {
 		cb(0, boost::any(mSetSLAACForAutoAddedPrefix));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6MeshLocalPrefix)) {
 		if (buffer_is_nonzero(mNCPV6Prefix, sizeof(mNCPV6Prefix))) {
 			struct in6_addr addr (mNCPMeshLocalAddress);
 			// Zero out the lower 64 bits.
 			memset(addr.s6_addr+8, 0, 8);
 			cb(0, boost::any(in6_addr_to_string(addr)+"/64"));
 		} else {
 			cb(kWPANTUNDStatus_FeatureNotSupported, std::string("Property is unavailable"));
 		}
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6MeshLocalAddress)) {
 		if (buffer_is_nonzero(mNCPMeshLocalAddress.s6_addr, sizeof(mNCPMeshLocalAddress))) {
 			cb(0, boost::any(in6_addr_to_string(mNCPMeshLocalAddress)));
 		} else {
 			cb(kWPANTUNDStatus_FeatureNotSupported, std::string("Property is unavailable"));
 		}
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6LinkLocalAddress)) {
 		if (buffer_is_nonzero(mNCPLinkLocalAddress.s6_addr, sizeof(mNCPLinkLocalAddress))) {
 			cb(0, boost::any(in6_addr_to_string(mNCPLinkLocalAddress)));
 		} else {
 			cb(kWPANTUNDStatus_FeatureNotSupported, std::string("Property is unavailable"));
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NestLabs_LegacyMeshLocalPrefix)) {
 		if (mLegacyInterfaceEnabled
 			|| mNodeTypeSupportsLegacy
 			|| buffer_is_nonzero(mNCPV6LegacyPrefix, sizeof(mNCPV6LegacyPrefix))
 		) {
 			cb(0, boost::any(nl::Data(mNCPV6LegacyPrefix, sizeof(mNCPV6LegacyPrefix))));
 		} else {
 			cb(kWPANTUNDStatus_FeatureNotSupported, std::string("Property is unavailable"));
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NestLabs_LegacyMeshLocalAddress)) {
 		struct in6_addr legacy_addr;
 
 		if ( (mLegacyInterfaceEnabled || mNodeTypeSupportsLegacy)
 		  && buffer_is_nonzero(mNCPV6LegacyPrefix, sizeof(mNCPV6LegacyPrefix))
 		) {
 			legacy_addr = make_slaac_addr_from_eui64(mNCPV6LegacyPrefix, mMACAddress);
 			cb(0, boost::any(in6_addr_to_string(legacy_addr)));
 		} else {
 			cb(kWPANTUNDStatus_FeatureNotSupported, std::string("Property is unavailable"));
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NCPState)) {
 		if ( is_initializing_ncp()
 		  && !ncp_state_is_detached_from_ncp(get_ncp_state())
 		) {
 			cb(0, boost::any(std::string(kWPANTUNDStateUninitialized)));
 		} else {
 			cb(0, boost::any(ncp_state_to_string(get_ncp_state())));
 		}
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_NetworkNodeType)) {
 		cb(0, boost::any(node_type_to_string(mNodeType)));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadOnMeshPrefixes)) {
 		std::list<std::string> result;
 		std::map<struct in6_addr, OnMeshPrefixEntry>::const_iterator iter;
 		for (iter = mOnMeshPrefixes.begin(); iter != mOnMeshPrefixes.end(); iter++ ) {
 			result.push_back(iter->second.get_description(iter->first, true));
 		}
 		cb(0, boost::any(result));
 
+	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_ThreadOffMeshRoutes)) {
+		std::list<std::string> result;
+		std::multimap<IPv6Prefix, OffMeshRouteEntry>::const_iterator iter;
+		for (iter = mOffMeshRoutes.begin(); iter != mOffMeshRoutes.end(); iter++ ) {
+			result.push_back(iter->second.get_description(iter->first, true));
+		}
+		cb(0, boost::any(result));
+
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6AllAddresses)
 		|| strcaseequal(key.c_str(), kWPANTUNDProperty_DebugIPv6GlobalIPAddressList)
 	) {
 		std::list<std::string> result;
 		std::map<struct in6_addr, UnicastAddressEntry>::const_iterator iter;
 		for (iter = mUnicastAddresses.begin(); iter != mUnicastAddresses.end(); iter++ ) {
 			result.push_back(iter->second.get_description(iter->first, true));
 		}
 		cb(0, boost::any(result));
 
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6MulticastAddresses)) {
 		std::list<std::string> result;
 		std::map<struct in6_addr, MulticastAddressEntry>::const_iterator iter;
 		for (iter = mMulticastAddresses.begin(); iter != mMulticastAddresses.end(); iter++ ) {
 			result.push_back(iter->second.get_description(iter->first, true));
 		}
 		cb(0, boost::any(result));
 
+	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_IPv6InterfaceRoutes)) {
+		std::list<std::string> result;
+		std::map<IPv6Prefix, InterfaceRouteEntry>::const_iterator iter;
+		for (iter = mInterfaceRoutes.begin(); iter != mInterfaceRoutes.end(); iter++ ) {
+			result.push_back(iter->second.get_description(iter->first, true));
+		}
+		cb(0, boost::any(result));
+
 	} else if (strcaseequal(key.c_str(), kWPANTUNDProperty_DaemonSyslogMask)) {
 		std::string mask_string;
 		int logmask;
 
 		setlogmask(logmask = setlogmask(0));
 
 		if (LOG_FAC(logmask) == LOG_DAEMON) {
 			mask_string += "daemon ";
 		}
 		if (LOG_FAC(logmask) == LOG_USER) {
 			mask_string += "user ";
 		}
 		if (logmask & LOG_MASK(LOG_EMERG)) {
 			mask_string += "emerg ";
 		}
 		if (logmask & LOG_MASK(LOG_ALERT)) {
 			mask_string += "alert ";
 		}
 		if (logmask & LOG_MASK(LOG_CRIT)) {
 			mask_string += "crit ";
 		}
 		if (logmask & LOG_MASK(LOG_ERR)) {
 			mask_string += "err ";
 		}
 		if (logmask & LOG_MASK(LOG_WARNING)) {
 			mask_string += "warning ";
 		}
 		if (logmask & LOG_MASK(LOG_NOTICE)) {
 			mask_string += "notice ";
 		}
 		if (logmask & LOG_MASK(LOG_INFO)) {
 			mask_string += "info ";
 		}
 		if (logmask & LOG_MASK(LOG_DEBUG)) {
 			mask_string += "debug ";
 		}
 
 		cb(0, mask_string);
 
 	} else if (StatCollector::is_a_stat_property(key)) {
 		get_stat_collector().property_get_value(key, cb);
 
 	} else {
 		syslog(LOG_ERR, "property_get_value: Unsupported property \"%s\"", key.c_str());
 		cb(kWPANTUNDStatus_PropertyNotFound, boost::any(std::string("Property Not Found")));
 	}
 }
diff --git a/src/wpantund/NCPInstanceBase.h b/src/wpantund/NCPInstanceBase.h
index 791d832..500c04e 100644
--- a/src/wpantund/NCPInstanceBase.h
+++ b/src/wpantund/NCPInstanceBase.h
@@ -137,62 +137,77 @@ public:
 public:
 	// ========================================================================
 	// MARK: Global address/prefix/route management
 
 	enum Origin {
 		kOriginThreadNCP,
 		kOriginPrimaryInterface,
 		kOriginUser,
 	};
 
+	typedef NCPControlInterface::ExternalRoutePriority  RoutePreference;
+
 	void unicast_address_was_added(Origin origin, const struct in6_addr &address,
 			uint8_t prefix_len = 64, uint32_t valid_lifetime = UINT32_MAX, uint32_t preferred_lifetime = UINT32_MAX);
 
 	void unicast_address_was_removed(Origin origin, const struct in6_addr &address);
 
 	void multicast_address_was_joined(Origin origin, const struct in6_addr &address);
 
 	void multicast_address_was_left(Origin origin, const struct in6_addr &address);
 
 	int join_multicast_group(const std::string &group_name);
 
 	void on_mesh_prefix_was_added(Origin origin, const struct in6_addr &prefix, uint8_t prefix_len = 64,
 			uint8_t flags = 0, bool stable = true, CallbackWithStatus cb = NilReturn());
 
 	void on_mesh_prefix_was_removed(Origin origin, const struct in6_addr &prefix, uint8_t prefix_len = 64,
 			CallbackWithStatus cb = NilReturn());
 
+	void route_was_added(Origin origin, const struct in6_addr &route, uint8_t prefix_len = 64,
+			RoutePreference preference = NCPControlInterface::ROUTE_MEDIUM_PREFERENCE,  bool stable = true,
+			uint16_t rloc16 = 0, bool next_hop_is_host = true, CallbackWithStatus cb = NilReturn());
+
+	void route_was_removed(Origin origin, const struct in6_addr &route, uint8_t prefix_len = 64,
+			RoutePreference preference = NCPControlInterface::ROUTE_MEDIUM_PREFERENCE,  bool stable = true,
+			uint16_t rloc16 = 0, CallbackWithStatus cb = NilReturn());
+
 	bool lookup_address_for_prefix(struct in6_addr *address, const struct in6_addr &prefix, int prefix_len = 64);
 
 	static std::string on_mesh_prefix_flags_to_string(uint8_t flags, bool detailed = false);
 
 protected:
-	void refresh_address_entries(void);
+	void refresh_address_route_prefix_entries(void);
 
-	void remove_all_address_prefix_entries(void);
+	void remove_all_address_prefix_route_entries(void);
 
-	void remove_ncp_originated_addresses(void);
+	void remove_ncp_originated_address_prefix_route_entries(void);
 
-	void restore_address_prefix_entries_on_ncp(void);
+	void restore_address_prefix_route_entries_on_ncp(void);
 
 protected:
 	// ========================================================================
-	// MARK: Subclass hooks related to address/prefix
+	// MARK: Subclass hooks related to address/prefix/route management
 
-	virtual void add_unicast_address_on_ncp(const struct in6_addr &addr, uint8_t prefix_len,
-					CallbackWithStatus cb = NilReturn()) = 0;
+	virtual void add_unicast_address_on_ncp(const struct in6_addr &addr, uint8_t prefix_len, CallbackWithStatus cb) = 0;
 
 	virtual void remove_unicast_address_on_ncp(const struct in6_addr &addr, uint8_t prefix_len,
-					CallbackWithStatus cb = NilReturn()) = 0;
+					CallbackWithStatus cb) = 0;
 
-	virtual void add_multicast_address_on_ncp(const struct in6_addr &addr, CallbackWithStatus cb = NilReturn()) = 0;
+	virtual void add_multicast_address_on_ncp(const struct in6_addr &addr, CallbackWithStatus cb) = 0;
 
-	virtual void remove_multicast_address_on_ncp(const struct in6_addr &addr, CallbackWithStatus cb = NilReturn()) = 0;
+	virtual void remove_multicast_address_on_ncp(const struct in6_addr &addr, CallbackWithStatus cb) = 0;
 
 	virtual void add_on_mesh_prefix_on_ncp(const struct in6_addr &addr, uint8_t prefix_len, uint8_t flags, bool stable,
-					CallbackWithStatus cb = NilReturn()) = 0;
+					CallbackWithStatus cb) = 0;
 
 	virtual void remove_on_mesh_prefix_on_ncp(const struct in6_addr &addr, uint8_t prefix_len, uint8_t flags,
-					bool stable, CallbackWithStatus cb = NilReturn()) = 0;
+					bool stable, CallbackWithStatus cb) = 0;
+
+	virtual void add_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+					bool stable, CallbackWithStatus cb) = 0;
+
+	virtual void remove_route_on_ncp(const struct in6_addr &route, uint8_t prefix_len, RoutePreference preference,
+					bool stable, CallbackWithStatus cb) = 0;
 
 protected:
 	//========================================================================
@@ -275,96 +290,160 @@ protected:
 protected:
 	//==========================================================================
 	// MARK: Global entries: Unicast IPv6 addresses, multicast IPv6 addresses,
-	// on-mesh prefixes.
+	// on-mesh prefixes, routes.
+
+	class IPv6Prefix {
+	public:
+		IPv6Prefix(const in6_addr &prefix, uint8_t prefix_len);
+
+		const struct in6_addr &get_prefix(void) const { return mPrefix; }
+		uint8_t get_length(void) const { return mLength; }
+
+		bool operator==(const IPv6Prefix &another_prefix) const;
+		bool operator!=(const IPv6Prefix &another_prefix) const { return !(*this == another_prefix); }
+		bool operator<(const IPv6Prefix &another_prefix) const;
+
+		std::string to_string(void) const;
+
+	private:
+		struct in6_addr mPrefix;
+		uint8_t mLength;
+	};
 
 	class EntryBase {
 	public:
 		EntryBase(Origin origin = kOriginThreadNCP) : mOrigin(origin) { }
 
 		Origin get_origin(void) const { return mOrigin; }
 		bool is_from_interface(void) const { return (mOrigin == kOriginPrimaryInterface); }
 		bool is_from_ncp(void) const { return (mOrigin == kOriginThreadNCP); }
 		bool is_from_user(void) const { return (mOrigin == kOriginUser); }
 
 	protected:
 		std::string get_origin_as_string(void) const;
 
 	private:
 		Origin mOrigin;
 	};
 
 	class UnicastAddressEntry : public EntryBase {
 	public:
 		UnicastAddressEntry(
 			Origin origin = kOriginThreadNCP,
 			uint8_t prefix_len = 64,
 			uint32_t valid_lifetime = UINT32_MAX,
 			uint32_t preferred_lifetime = UINT32_MAX
 		);
 
 		uint8_t get_prefix_len(void) const { return mPrefixLen; }
 		uint32_t get_valid_lifetime(void) const { return mValidLifetime; }
 		uint32_t get_preferred_lifetime(void) const { return mPreferredLifetime; }
 		void set_valid_lifetime(uint32_t valid_lifetime) { mValidLifetime = valid_lifetime; }
 		void set_preferred_lifetime(uint32_t preferred_lifetime) { mPreferredLifetime = preferred_lifetime; }
 
 		std::string get_description(const struct in6_addr &address, bool align = false) const;
 
 	private:
 		uint8_t mPrefixLen;
 		uint32_t mValidLifetime;
 		uint32_t mPreferredLifetime;
 	};
 
 	class MulticastAddressEntry : public EntryBase {
 	public:
 		MulticastAddressEntry(Origin origin = kOriginThreadNCP) : EntryBase(origin) { }
 		std::string get_description(const struct in6_addr &address, bool align = false) const;
 	};
 
 	class OnMeshPrefixEntry : public EntryBase {
 	public:
 
 		enum {
 			kFlagOnMesh              = (1 << 0),
 			kFlagDefaultRoute        = (1 << 1),
 			kFlagConfigure           = (1 << 2),
 			kFlagDHCP                = (1 << 3),
 			kFlagSLAAC               = (1 << 4),
 			kFlagPreferred           = (1 << 5),
 
 			kPreferenceOffset        = 6,
 			kPreferenceMask          = (3 << kPreferenceOffset),
 
 			kPreferenceHigh          = (1 << kPreferenceOffset),
 			kPreferenceMedium        = (0 << kPreferenceOffset),
 			kPreferenceLow           = (3 << kPreferenceOffset),
 		};
 
 		OnMeshPrefixEntry(Origin origin = kOriginThreadNCP, uint8_t flags = 0, uint8_t prefix_len = 64, bool stable = true)
 			: EntryBase(origin), mFlags(flags), mPrefixLen(prefix_len), mStable(stable) { }
 
 		uint8_t get_prefix_len(void) const { return mPrefixLen; }
 		uint8_t is_stable(void) const { return mStable; }
 
 		uint8_t get_flags(void) const { return mFlags; }
 		void set_flags(uint8_t flags) { mFlags = flags; }
 
 		bool is_on_mesh(void) const { return (mFlags & kFlagOnMesh) == kFlagOnMesh; }
 		bool is_slaac(void) const { return (mFlags & kFlagSLAAC) == kFlagSLAAC; }
 
 		std::string get_description(const struct in6_addr &preifx, bool align = false) const;
 
 	private:
 		uint8_t mFlags;
 		uint8_t mPrefixLen;
 		bool mStable;
 	};
 
+	class OffMeshRouteEntry : public EntryBase {
+	public:
+		OffMeshRouteEntry(Origin origin, RoutePreference preference = NCPControlInterface::ROUTE_MEDIUM_PREFERENCE,
+			bool stable = true, uint16_t rloc16 = 0, bool next_hop_is_host = false)
+			: EntryBase(origin), mPreference(preference), mStable(stable), mRloc(rloc16)
+			, mNextHopIsHost(next_hop_is_host) { }
+
+		uint8_t is_stable(void) const { return mStable; }
+		RoutePreference get_preference(void) const { return mPreference; }
+		uint16_t get_rloc(void) const { return mRloc; }
+		bool is_next_hop_host(void) const { return mNextHopIsHost; }
+
+		bool operator==(const OffMeshRouteEntry &entry);
+
+		std::string get_description(const IPv6Prefix &route, bool align = false) const;
+
+	private:
+		RoutePreference mPreference;
+		bool mStable;
+		uint16_t mRloc;
+		bool mNextHopIsHost;
+	};
+
+	class InterfaceRouteEntry
+	{
+	public:
+		// Mapping the 3 route preference values to Linux route metric (note that larger metric means lower priority)
+		enum {
+			kRouteMetricHigh     = 1,
+			kRouteMetricMedium   = 256,
+			kRouteMetricLow      = 512,
+		};
+
+		InterfaceRouteEntry(uint32_t metric = 512)
+			: mMetric(metric) { }
+
+		uint32_t get_metric(void) const { return mMetric; }
+
+		std::string get_description(const IPv6Prefix &route, bool align = false) const;
+
+	private:
+		uint32_t mMetric;
+	};
+
 private:
 	void add_address_on_ncp_and_update_prefixes(const in6_addr &address, const UnicastAddressEntry &entry);
 	void remove_address_on_ncp_and_update_prefixes(const in6_addr &address, const UnicastAddressEntry &entry);
-
+	std::multimap<IPv6Prefix, OffMeshRouteEntry>::iterator find_route_entry(const IPv6Prefix &route, const OffMeshRouteEntry &entry);
+	void refresh_routes_on_interface(void);
+	bool should_add_route_on_interface(const IPv6Prefix &route, uint32_t &metric);
 	void check_ncp_entry_update_status(int status, std::string operation, CallbackWithStatus cb);
 
 protected:
@@ -373,26 +452,29 @@ protected:
 	std::map<struct in6_addr, MulticastAddressEntry> mMulticastAddresses;
 	std::map<struct in6_addr, OnMeshPrefixEntry> mOnMeshPrefixes;
 
+	std::multimap<IPv6Prefix, OffMeshRouteEntry> mOffMeshRoutes;
+	std::map<IPv6Prefix, InterfaceRouteEntry> mInterfaceRoutes;
+
 protected:
 
 	IPv6PacketMatcherRule mCommissioningRule;
 	IPv6PacketMatcher mInsecureFirewall;
 	IPv6PacketMatcher mDropFirewall;
 
 	time_t mCommissioningExpiration;
 
 	std::string mNCPVersionString;
 
 	bool mEnabled;
 	bool mTerminateOnFault;
 	bool mAutoUpdateFirmware;
 	bool mAutoResume;
 	bool mAutoDeepSleep;
 	int mAutoDeepSleepTimeout; // In seconds
 	uint16_t mCommissionerPort;
 
 	// When an unicast address is added on interface, the related on-mesh prefix
-	//  is updated on NCP if `mDefaultRouteForAutoAddedPrefix` is true the prefix
+	// is updated on NCP if `mDefaultRouteForAutoAddedPrefix` is true the prefix
 	// is added with flag "DefaultRoute" set.
 	bool mSetDefaultRouteForAutoAddedPrefix;
 	bool mSetSLAACForAutoAddedPrefix;
@@ -400,7 +482,8 @@ protected:
 private:
 	NCPState mNCPState;
 	bool mIsInitializingNCP;
 	bool mIsInterfaceOnline;
+	bool mRequestRouteRefresh;
 
 protected:
 	//! This is set to the currently used MAC address (EUI64).
diff --git a/src/wpantund/wpan-properties.h b/src/wpantund/wpan-properties.h
index a023b95..3895a61 100644
--- a/src/wpantund/wpan-properties.h
+++ b/src/wpantund/wpan-properties.h
@@ -1,242 +1,243 @@
 /*
  *
  * Copyright (c) 2016 Nest Labs, Inc.
  * All rights reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *    Description:
  *      This file contains the enumeration of the properties that can be
  *      gotten or set via the "get_prop()" and "set_prop()" methods.
  *
  */
 
 #ifndef wpantund_wpan_properties_h
 #define wpantund_wpan_properties_h
 
 #define kWPANTUNDProperty_ConfigNCPSocketPath                   "Config:NCP:SocketPath"
 #define kWPANTUNDProperty_ConfigNCPSocketBaud                   "Config:NCP:SocketBaud"
 #define kWPANTUNDProperty_ConfigNCPDriverName                   "Config:NCP:DriverName"
 #define kWPANTUNDProperty_ConfigNCPHardResetPath                "Config:NCP:HardResetPath"
 #define kWPANTUNDProperty_ConfigNCPPowerPath                    "Config:NCP:PowerPath"
 #define kWPANTUNDProperty_ConfigNCPReliabilityLayer             "Config:NCP:ReliabilityLayer"
 #define kWPANTUNDProperty_ConfigNCPFirmwareCheckCommand         "Config:NCP:FirmwareCheckCommand"
 #define kWPANTUNDProperty_ConfigNCPFirmwareUpgradeCommand       "Config:NCP:FirmwareUpgradeCommand"
 #define kWPANTUNDProperty_ConfigTUNInterfaceName                "Config:TUN:InterfaceName"
 #define kWPANTUNDProperty_ConfigDaemonPIDFile                   "Config:Daemon:PIDFile"
 #define kWPANTUNDProperty_ConfigDaemonPrivDropToUser            "Config:Daemon:PrivDropToUser"
 #define kWPANTUNDProperty_ConfigDaemonChroot                    "Config:Daemon:Chroot"
 #define kWPANTUNDProperty_ConfigDaemonNetworkRetainCommand      "Config:Daemon:NetworkRetainCommand"
 
 #define kWPANTUNDProperty_DaemonVersion                         "Daemon:Version"
 #define kWPANTUNDProperty_DaemonEnabled                         "Daemon:Enabled"
 #define kWPANTUNDProperty_DaemonSyslogMask                      "Daemon:SyslogMask"
 #define kWPANTUNDProperty_DaemonTerminateOnFault                "Daemon:TerminateOnFault"
 #define kWPANTUNDProperty_DaemonReadyForHostSleep               "Daemon:ReadyForHostSleep"
 #define kWPANTUNDProperty_DaemonAutoAssociateAfterReset         "Daemon:AutoAssociateAfterReset"
 #define kWPANTUNDProperty_DaemonAutoFirmwareUpdate              "Daemon:AutoFirmwareUpdate"
 #define kWPANTUNDProperty_DaemonAutoDeepSleep                   "Daemon:AutoDeepSleep"
 #define kWPANTUNDProperty_DaemonFaultReason                     "Daemon:FaultReason"
 #define kWPANTUNDProperty_DaemonSetDefRouteForAutoAddedPrefix   "Daemon:SetDefaultRouteForAutoAddedPrefix"
 
 #define kWPANTUNDProperty_NCPVersion                            "NCP:Version"
 #define kWPANTUNDProperty_NCPState                              "NCP:State"
 #define kWPANTUNDProperty_NCPHardwareAddress                    "NCP:HardwareAddress"
 #define kWPANTUNDProperty_NCPExtendedAddress                    "NCP:ExtendedAddress"
 #define kWPANTUNDProperty_NCPMACAddress                         "NCP:MACAddress"
 #define kWPANTUNDProperty_NCPChannel                            "NCP:Channel"
 #define kWPANTUNDProperty_NCPFrequency                          "NCP:Frequency"
 #define kWPANTUNDProperty_NCPTXPower                            "NCP:TXPower"
 #define kWPANTUNDProperty_NCPTXPowerLimit                       "NCP:TXPowerLimit"
 #define kWPANTUNDProperty_NCPCCAThreshold                       "NCP:CCAThreshold"
 #define kWPANTUNDProperty_NCPChannelMask                        "NCP:ChannelMask"
 #define kWPANTUNDProperty_NCPSleepyPollInterval                 "NCP:SleepyPollInterval"
 #define kWPANTUNDProperty_NCPRSSI                               "NCP:RSSI"
 
 #define kWPANTUNDProperty_InterfaceUp                           "Interface:Up"
 
 #define kWPANTUNDProperty_NetworkName                           "Network:Name"
 #define kWPANTUNDProperty_NetworkXPANID                         "Network:XPANID"
 #define kWPANTUNDProperty_NetworkPANID                          "Network:PANID"
 #define kWPANTUNDProperty_NetworkNodeType                       "Network:NodeType"
 #define kWPANTUNDProperty_NetworkKey                            "Network:Key"
 #define kWPANTUNDProperty_NetworkKeyIndex                       "Network:KeyIndex"
 #define kWPANTUNDProperty_NetworkIsCommissioned                 "Network:IsCommissioned"
 #define kWPANTUNDProperty_NetworkIsConnected                    "Network:IsConnected"
 #define kWPANTUNDProperty_NetworkPSKc                           "Network:PSKc"
 #define kWPANTUNDProperty_NetworkRole                           "Network:Role"
 #define kWPANTUNDProperty_NetworkPartitionId                    "Network:PartitionId"
 
 #define kWPANTUNDProperty_IPv6LinkLocalAddress                  "IPv6:LinkLocalAddress"
 #define kWPANTUNDProperty_IPv6MeshLocalAddress                  "IPv6:MeshLocalAddress"
 #define kWPANTUNDProperty_IPv6MeshLocalPrefix                   "IPv6:MeshLocalPrefix"
 #define kWPANTUNDProperty_IPv6AllAddresses                      "IPv6:AllAddresses"
 #define kWPANTUNDProperty_IPv6MulticastAddresses                "IPv6:MulticastAddresses"
+#define kWPANTUNDProperty_IPv6InterfaceRoutes                   "IPv6:Routes"
 #define kWPANTUNDProperty_IPv6SetSLAACForAutoAddedPrefix        "IPv6:SetSLAACForAutoAddedPrefix"
 
 #define kWPANTUNDProperty_ThreadRLOC16                          "Thread:RLOC16"
 #define kWPANTUNDProperty_ThreadRouterID                        "Thread:RouterID"
 #define kWPANTUNDProperty_ThreadLeaderAddress                   "Thread:Leader:Address"
 #define kWPANTUNDProperty_ThreadLeaderRouterID                  "Thread:Leader:RouterID"
 #define kWPANTUNDProperty_ThreadLeaderWeight                    "Thread:Leader:Weight"
 #define kWPANTUNDProperty_ThreadLeaderLocalWeight               "Thread:Leader:LocalWeight"
 #define kWPANTUNDProperty_ThreadLeaderNetworkData               "Thread:Leader:NetworkData"
 #define kWPANTUNDProperty_ThreadStableLeaderNetworkData         "Thread:Leader:StableNetworkData"
 #define kWPANTUNDProperty_ThreadNetworkData                     "Thread:NetworkData"
 #define kWPANTUNDProperty_ThreadChildTable                      "Thread:ChildTable"
 #define kWPANTUNDProperty_ThreadChildTableAsValMap              "Thread:ChildTable:AsValMap"
 #define kWPANTUNDProperty_ThreadNeighborTable                   "Thread:NeighborTable"
 #define kWPANTUNDProperty_ThreadNeighborTableAsValMap           "Thread:NeighborTable:AsValMap"
 #define kWPANTUNDProperty_ThreadRouterTable                     "Thread:RouterTable"
 #define kWPANTUNDProperty_ThreadRouterTableAsValMap             "Thread:RouterTable:AsValMap"
 #define kWPANTUNDProperty_ThreadNetworkDataVersion              "Thread:NetworkDataVersion"
 #define kWPANTUNDProperty_ThreadStableNetworkData               "Thread:StableNetworkData"
 #define kWPANTUNDProperty_ThreadStableNetworkDataVersion        "Thread:StableNetworkDataVersion"
 #define kWPANTUNDProperty_ThreadPreferredRouterID               "Thread:PreferredRouterID"
 #define kWPANTUNDProperty_ThreadCommissionerEnabled             "Thread:Commissioner:Enabled"
 #define kWPANTUNDProperty_ThreadDeviceMode                      "Thread:DeviceMode"
 #define kWPANTUNDProperty_ThreadOffMeshRoutes                   "Thread:OffMeshRoutes"
 #define kWPANTUNDProperty_ThreadOnMeshPrefixes                  "Thread:OnMeshPrefixes"
 #define kWPANTUNDProperty_ThreadRouterRoleEnabled               "Thread:RouterRole:Enabled"
 #define kWPANTUNDProperty_ThreadConfigFilterRLOCAddresses       "Thread:Config:FilterRLOCAddresses"
 
 #define kWPANTUNDProperty_OpenThreadLogLevel                    "OpenThread:LogLevel"
 #define kWPANTUNDProperty_OpenThreadSteeringDataAddress         "OpenThread:SteeringData:Address"
 #define kWPANTUNDProperty_OpenThreadSteeringDataSetWhenJoinable "OpenThread:SteeringData:SetWhenJoinable"
 #define kWPANTUNDProperty_OpenThreadMsgBufferCounters           "OpenThread:MsgBufferCounters"
 #define kWPANTUNDProperty_OpenThreadMsgBufferCountersAsString   "OpenThread:MsgBufferCounters:AsString"
 #define kWPANTUNDProperty_OpenThreadDebugTestAssert             "OpenThread:Debug:TestAssert"
 
 #define kWPANTUNDProperty_DebugIPv6GlobalIPAddressList          "Debug:IPv6:GlobalIPAddressList"
 
 #define kWPANTUNDProperty_MACWhitelistEnabled                   "MAC:Whitelist:Enabled"
 #define kWPANTUNDProperty_MACWhitelistEntries                   "MAC:Whitelist:Entries"
 #define kWPANTUNDProperty_MACWhitelistEntriesAsValMap           "MAC:Whitelist:Entries:AsValMap"
 
 #define kWPANTUNDProperty_MACBlacklistEnabled                   "MAC:Blacklist:Enabled"
 #define kWPANTUNDProperty_MACBlacklistEntries                   "MAC:Blacklist:Entries"
 #define kWPANTUNDProperty_MACBlacklistEntriesAsValMap           "MAC:Blacklist:Entries:AsValMap"
 
 #define kWPANTUNDProperty_JamDetectionStatus                    "JamDetection:Status"
 #define kWPANTUNDProperty_JamDetectionEnable                    "JamDetection:Enable"
 #define kWPANTUNDProperty_JamDetectionRssiThreshold             "JamDetection:RssiThreshold"
 #define kWPANTUNDProperty_JamDetectionWindow                    "JamDetection:Window"
 #define kWPANTUNDProperty_JamDetectionBusyPeriod                "JamDetection:BusyPeriod"
 #define kWPANTUNDProperty_JamDetectionDebugHistoryBitmap        "JamDetection:Debug:HistoryBitmap"
 
 #define kWPANTUNDProperty_TmfProxyEnabled                       "TmfProxy:Enabled"
 #define kWPANTUNDProperty_TmfProxyStream                        "TmfProxy:Stream"
 
 #define kWPANTUNDProperty_NestLabs_NetworkAllowingJoin          "com.nestlabs.internal:Network:AllowingJoin"
 #define kWPANTUNDProperty_NestLabs_NetworkPassthruPort          "com.nestlabs.internal:Network:PassthruPort"
 #define kWPANTUNDProperty_NestLabs_NCPTransmitHookActive        "com.nestlabs.internal:NCP:TransmitHookActive"
 #define kWPANTUNDProperty_NestLabs_LegacyPreferInterface        "com.nestlabs.internal:Legacy:PreferInterface"
 #define kWPANTUNDProperty_NestLabs_LegacyMeshLocalAddress       "com.nestlabs.internal:Legacy:MeshLocalAddress"
 #define kWPANTUNDProperty_NestLabs_LegacyMeshLocalPrefix        "com.nestlabs.internal:Legacy:MeshLocalPrefix"
 #define kWPANTUNDProperty_NestLabs_LegacyEnabled                "com.nestlabs.internal:Legacy:Enabled"
 #define kWPANTUNDProperty_NestLabs_NetworkWakeData              "com.nestlabs.internal:NetworkWake:Data"
 #define kWPANTUNDProperty_NestLabs_NetworkWakeRemaining         "com.nestlabs.internal:NetworkWake:Remaining"
 #define kWPANTUNDProperty_NestLabs_NetworkWakeBlacklist         "com.nestlabs.internal:NetworkWake:Blacklist"
 #define kWPANTUNDProperty_NestLabs_HackUseDeepSleepOnLowPower   "com.nestlabs.internal:Hack:UseDeepSleepOnLowPower"
 #define kWPANTUNDProperty_NestLabs_HackAlwaysResetToWake        "com.nestlabs.internal:Hack:AlwaysResetToWake"
 
 #define kWPANTUNDProperty_Stat_Prefix                           "Stat:"
 #define kWPANTUNDProperty_StatRX                                "Stat:RX"
 #define kWPANTUNDProperty_StatTX                                "Stat:TX"
 #define kWPANTUNDProperty_StatRXHistory                         "Stat:RX:History"
 #define kWPANTUNDProperty_StatTXHistory                         "Stat:TX:History"
 #define kWPANTUNDProperty_StatHistory                           "Stat:History"
 #define kWPANTUNDProperty_StatNCP                               "Stat:NCP"
 #define kWPANTUNDProperty_StatBlockingHostSleep                 "Stat:BlockingHostSleep"
 #define kWPANTUNDProperty_StatNode                              "Stat:Node"
 #define kWPANTUNDProperty_StatNodeHistory                       "Stat:Node:History"
 #define kWPANTUNDProperty_StatNodeHistoryID                     "Stat:Node:History:"
 #define kWPANTUNDProperty_StatShort                             "Stat:Short"
 #define kWPANTUNDProperty_StatLong                              "Stat:Long"
 #define kWPANTUNDProperty_StatAutoLog                           "Stat:AutoLog"
 #define kWPANTUNDProperty_StatAutoLogState                      "Stat:AutoLog:State"
 #define kWPANTUNDProperty_StatAutoLogPeriod                     "Stat:AutoLog:Period"
 #define kWPANTUNDProperty_StatAutoLogLogLevel                   "Stat:AutoLog:LogLevel"
 #define kWPANTUNDProperty_StatUserLogRequestLogLevel            "Stat:UserRequest:LogLevel"
 #define kWPANTUNDProperty_StatLinkQuality                       "Stat:LinkQuality"
 #define kWPANTUNDProperty_StatLinkQualityLong                   "Stat:LinkQuality:Long"
 #define kWPANTUNDProperty_StatLinkQualityShort                  "Stat:LinkQuality:Short"
 #define kWPANTUNDProperty_StatLinkQualityPeriod                 "Stat:LinkQuality:Period"
 #define kWPANTUNDProperty_StatHelp                              "Stat:Help"
 
 // ----------------------------------------------------------------------------
 
 #define kWPANTUNDNodeType_Unknown                               "unknown"
 #define kWPANTUNDNodeType_Router                                "router"
 #define kWPANTUNDNodeType_EndDevice                             "end-device"
 #define kWPANTUNDNodeType_SleepyEndDevice                       "sleepy-end-device"
 #define kWPANTUNDNodeType_NestLurker                            "nl-lurker"
 #define kWPANTUNDNodeType_Commissioner                          "commissioner"
 #define kWPANTUNDNodeType_Leader                                "leader"
 
 // ----------------------------------------------------------------------------
 
 // When querying the value of the association state property,
 // the returned value will be a human-readable string. Compare
 // it with one of the constants below to get the exact meaning.
 #define kWPANTUNDStateUninitialized                             "uninitialized"
 #define kWPANTUNDStateFault                                     "uninitialized:fault"
 #define kWPANTUNDStateUpgrading                                 "uninitialized:upgrading"
 #define kWPANTUNDStateDeepSleep                                 "offline:deep-sleep"
 #define kWPANTUNDStateOffline                                   "offline"
 #define kWPANTUNDStateCommissioned                              "offline:commissioned"
 #define kWPANTUNDStateAssociating                               "associating"
 #define kWPANTUNDStateCredentialsNeeded                         "associating:credentials-needed"
 #define kWPANTUNDStateAssociated                                "associated"
 #define kWPANTUNDStateIsolated                                  "associated:no-parent"
 #define kWPANTUNDStateNetWake_Asleep                            "associated:netwake-asleep"
 #define kWPANTUNDStateNetWake_Waking                            "associated:netwake-waking"
 
 // ----------------------------------------------------------------------------
 
 // Values of  the property kWPANTUNDProperty_StatAutoLogState
 #define kWPANTUNDStatAutoLogState_Disabled                      "disabled"
 #define kWPANTUNDStatAutoLogState_Long                          "long"
 #define kWPANTUNDStatAutoLogState_Short                         "short"
 
 // ----------------------------------------------------------------------------
 
 // Values for value map keys
 
 #define kWPANTUNDValueMapKey_Whitelist_ExtAddress               "ExtAddress"
 #define kWPANTUNDValueMapKey_Whitelist_Rssi                     "FixedRssi"
 
 #define kWPANTUNDValueMapKey_NetworkTopology_ExtAddress         "ExtAddress"
 #define kWPANTUNDValueMapKey_NetworkTopology_RLOC16             "RLOC16"
 #define kWPANTUNDValueMapKey_NetworkTopology_LinkQualityIn      "LinkQualityIn"
 #define kWPANTUNDValueMapKey_NetworkTopology_AverageRssi        "AverageRssi"
 #define kWPANTUNDValueMapKey_NetworkTopology_LastRssi           "LastRssi"
 #define kWPANTUNDValueMapKey_NetworkTopology_Age                "Age"
 #define kWPANTUNDValueMapKey_NetworkTopology_RxOnWhenIdle       "RxOnWhenIdle"
 #define kWPANTUNDValueMapKey_NetworkTopology_FullFunction       "FullFunction"
 #define kWPANTUNDValueMapKey_NetworkTopology_SecureDataRequest  "SecureDataRequest"
 #define kWPANTUNDValueMapKey_NetworkTopology_FullNetworkData    "FullNetworkData"
 #define kWPANTUNDValueMapKey_NetworkTopology_Timeout            "Timeout"
 #define kWPANTUNDValueMapKey_NetworkTopology_NetworkDataVersion "NetworkDataVersion"
 #define kWPANTUNDValueMapKey_NetworkTopology_LinkFrameCounter   "LinkFrameCounter"
 #define kWPANTUNDValueMapKey_NetworkTopology_MleFrameCounter    "MleFrameCounter"
 #define kWPANTUNDValueMapKey_NetworkTopology_IsChild            "IsChild"
 
 #define kWPANTUNDValueMapKey_Scan_Period                        "Scan:Period"
 #define kWPANTUNDValueMapKey_Scan_ChannelMask                   "Scan:ChannelMask"
 #define kWPANTUNDValueMapKey_Scan_Discover                      "Scan:Discover"
 #define kWPANTUNDValueMapKey_Scan_JoinerFalg                    "Scan:JoinerFlag"
 #define kWPANTUNDValueMapKey_Scan_EnableFiltering               "Scan:EnableFiltering"
 #define kWPANTUNDValueMapKey_Scan_PANIDFilter                   "Scan:PANID"
 
 #endif
