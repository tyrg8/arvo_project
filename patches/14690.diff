commit a875795bb5d8c216fa17d685b49784c4d5c93f87
Author: radare <pancake@nopcode.org>
Date:   Mon May 27 18:18:01 2019 +0200

    Completely eliminate the bytes apis in RBin ##bin
    
    * Huge bytes->buffer on almost all the plugins, break API and ABI \o/
    * Changed the way RBinFiles are created
    * Changed the structure of the Sdb instance
    * Improve ELF and MZ detection mechanisms to reduce false positives
    * Change all the free/destroy methods to return void
    * Fix "ks" shell
    * Simplify and change the way RBinWrite apis work

diff --git a/libr/bin/bfile.c b/libr/bin/bfile.c
index 60d2a59fb7..bb628350c6 100644
--- a/libr/bin/bfile.c
+++ b/libr/bin/bfile.c
@@ -325,124 +325,84 @@ static void get_strings_range(RBinFile *bf, RList *list, int min, int raw, ut64
 	string_scan_range (list, bf, min, from, to, -1, raw, section);
 }
 
-R_IPI RBinFile *r_bin_file_new(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, int fd, const char *xtrname, Sdb *sdb, bool steal_ptr) {
-	RBinFile *binfile = R_NEW0 (RBinFile);
-	if (!binfile) {
+R_IPI RBinFile *r_bin_file_new(RBin *bin, const char *file, ut64 file_sz, int rawstr, int fd, const char *xtrname, Sdb *sdb, bool steal_ptr) {
+	ut32 bf_id;
+	if (!r_id_pool_grab_id (bin->ids->pool, &bf_id)) {
 		return NULL;
 	}
-	// TODO: use r_id_storage api
-	if (!r_id_pool_grab_id (bin->ids->pool, &binfile->id)) {
-		if (steal_ptr) { // we own the ptr, free on error
-			free ((void*) bytes);
-		}
-		free (binfile);		//no id means no binfile
+	RBinFile *bf = R_NEW0 (RBinFile);
+	if (!bf) {
 		return NULL;
 	}
-	int res = r_bin_file_set_bytes (binfile, bytes, sz, steal_ptr);
-	if (!res && steal_ptr) { // we own the ptr, free on error
-		free ((void *)bytes);
-	}
-	binfile->rbin = bin;
-	binfile->file = file ? strdup (file) : NULL;
-	binfile->rawstr = rawstr;
-	binfile->fd = fd;
-	binfile->curxtr = xtrname ? r_bin_get_xtrplugin_by_name (bin, xtrname) : NULL;
-	binfile->sdb = sdb;
-	binfile->size = file_sz;
-	binfile->xtr_data = r_list_newf ((RListFree)r_bin_xtrdata_free);
-	binfile->objs = r_list_newf ((RListFree)r_bin_object_free);
-	binfile->xtr_obj = NULL;
-
-	if (!binfile->buf) {
-		binfile->buf = r_buf_new ();
-	}
-
-	if (sdb) {
-		binfile->sdb = sdb_ns (sdb, sdb_fmt ("fd.%d", fd), 1);
-		sdb_set (binfile->sdb, "archs", "0:0:x86:32", 0); // x86??
-		/* NOTE */
-		/* Those refs++ are necessary because sdb_ns() doesnt rerefs all
-		 * sub-namespaces */
-		/* And if any namespace is referenced backwards it gets
-		 * double-freed */
-		binfile->sdb_addrinfo = sdb_ns (binfile->sdb, "addrinfo", 1);
-		binfile->sdb_addrinfo->refs++;
-		sdb_ns_set (sdb, "cur", binfile->sdb);
-		binfile->sdb->refs++;
-	}
-	return binfile;
+	bf->id = bf_id;
+	bf->rbin = bin;
+	bf->file = file ? strdup (file) : NULL;
+	bf->rawstr = rawstr;
+	bf->fd = fd;
+	bf->curxtr = xtrname ? r_bin_get_xtrplugin_by_name (bin, xtrname) : NULL;
+	bf->sdb = sdb;
+	bf->size = file_sz;
+	bf->xtr_data = r_list_newf ((RListFree)r_bin_xtrdata_free);
+	bf->objs = r_list_newf ((RListFree)r_bin_object_free);
+	bf->xtr_obj = NULL;
+	bf->sdb = sdb_new0 ();
+	bf->sdb_addrinfo = sdb_new0 (); //ns (bf->sdb, "addrinfo", 1);
+	// bf->sdb_addrinfo->refs++;
+	return bf;
 }
 
-static RBinPlugin *get_plugin(RBin *bin, const char *pluginname, const ut8 *bytes, ut64 sz) {
+static RBinPlugin *get_plugin_from_buffer(RBin *bin, const char *pluginname, RBuffer *buf) {
 	RBinPlugin *plugin = bin->force? r_bin_get_binplugin_by_name (bin, bin->force): NULL;
 	if (plugin) {
 		return plugin;
 	}
-
 	plugin = pluginname? r_bin_get_binplugin_by_name (bin, pluginname): NULL;
 	if (plugin) {
 		return plugin;
 	}
-
-	plugin = r_bin_get_binplugin_by_bytes (bin, bytes, sz);
+	plugin = r_bin_get_binplugin_by_buffer (bin, buf);
 	if (plugin) {
 		return plugin;
 	}
-
 	return r_bin_get_binplugin_any (bin);
 }
 
-static RBinPlugin * get_plugin_with_buffer (RBin *bin, RBuffer *buf) {
-	ut8 bytes[4096];
-	// XXX this must be removed to make get_plugin work with RBuffer instead of char*+sz
-	r_buf_read_at (buf, 0, bytes, sizeof (bytes));
-	return get_plugin (bin, NULL, (const ut8 *)bytes, sizeof (bytes));
-}
-
 R_API bool r_bin_file_object_new_from_xtr_data(RBin *bin, RBinFile *bf, ut64 baseaddr, ut64 loadaddr, RBinXtrData *data) {
 	r_return_val_if_fail (bin && bf && data, false);
 
 	ut64 offset = data->offset;
 	ut64 sz = data->size;
 
-	RBinPlugin *plugin = get_plugin_with_buffer (bin, data->buf);
+	RBinPlugin *plugin = get_plugin_from_buffer (bin, NULL, data->buf);
 	bf->buf = r_buf_ref (data->buf);
 
 	RBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, offset, sz);
 	if (!o) {
 		return false;
 	}
 	// size is set here because the reported size of the object depends on
 	// if loaded from xtr plugin or partially read
 	if (!o->size) {
 		o->size = sz;
 	}
 	bf->narch = data->file_count;
 	if (!o->info) {
 		o->info = R_NEW0 (RBinInfo);
 	}
 	free (o->info->file);
 	free (o->info->arch);
 	free (o->info->machine);
 	free (o->info->type);
 	o->info->file = strdup (bf->file);
 	o->info->arch = strdup (data->metadata->arch);
 	o->info->machine = strdup (data->metadata->machine);
 	o->info->type = strdup (data->metadata->type);
 	o->info->bits = data->metadata->bits;
 	o->info->has_crypto = bf->o->info->has_crypto;
 	data->loaded = true;
 	return true;
 }
 
-static RBinFile *file_create_append(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, int fd, const char *xtrname, bool steal_ptr) {
-	RBinFile *bf = r_bin_file_new (bin, file, bytes, sz, file_sz, rawstr, fd, xtrname, bin->sdb, steal_ptr);
-	if (bf) {
-		r_list_append (bin->binfiles, bf);
-	}
-	return bf;
-}
-
 static bool xtr_metadata_match(RBinXtrData *xtr_data, const char *arch, int bits) {
 	if (!xtr_data->metadata || !xtr_data->metadata->arch) {
 		return false;
@@ -453,29 +413,23 @@ static bool xtr_metadata_match(RBinXtrData *xtr_data, const char *arch, int bits
 }
 
 R_IPI RBinFile *r_bin_file_new_from_buffer(RBin *bin, const char *file, RBuffer *buf, ut64 file_sz, int rawstr, ut64 baseaddr, ut64 loadaddr, int fd, const char *pluginname, ut64 offset) {
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (buf, &sz);
-	return r_bin_file_new_from_bytes (bin, file, bytes, sz, file_sz, rawstr, baseaddr, loadaddr, fd, pluginname, offset);
-}
-
-R_IPI RBinFile *r_bin_file_new_from_bytes(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, ut64 baseaddr, ut64 loadaddr, int fd, const char *pluginname, ut64 offset) {
-	r_return_val_if_fail (sz != UT64_MAX, NULL);
+	r_return_val_if_fail (file_sz != UT64_MAX, NULL);
 
-	RBinPlugin *plugin = get_plugin (bin, pluginname, bytes, sz);
-	RBinFile *bf = file_create_append (bin, file, bytes, sz, file_sz, rawstr, fd, NULL, true);
-	if (!bf) {
-		return NULL;
-	}
-
-	RBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));
-	if (!o) {
-		r_list_delete_data (bin->binfiles, bf);
-		return NULL;
-	}
-	// size is set here because the reported size of the object depends on
-	// if loaded from xtr plugin or partially read
-	if (!o->size) {
-		o->size = file_sz;
+	RBinFile *bf = r_bin_file_new (bin, file, file_sz, rawstr, fd, pluginname, NULL, false);
+	if (bf) {
+		bf->buf = r_buf_ref (buf);
+		RBinPlugin *plugin = get_plugin_from_buffer (bin, pluginname, bf->buf);
+		RBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));
+		if (!o) {
+			r_bin_file_free (bf);
+			return NULL;
+		}
+		// size is set here because the reported size of the object depends on
+		// if loaded from xtr plugin or partially read
+		if (!o->size) {
+			o->size = file_sz;
+		}
+		r_list_append (bin->binfiles, bf);
 	}
 	return bf;
 }
@@ -669,94 +623,85 @@ R_API bool r_bin_file_deref(RBin *bin, RBinFile *a) {
 	return res;
 }
 
-R_API void r_bin_file_free(void /*RBinFile*/ *bf_) {
-	RBinFile *a = bf_;
-	RBinPlugin *plugin = r_bin_file_cur_plugin (a);
-	if (!a) {
+R_API void r_bin_file_free(void /*RBinFile*/ *_bf) {
+	if (!_bf) {
 		return;
 	}
+	RBinFile *bf = _bf;
+	RBinPlugin *plugin = r_bin_file_cur_plugin (bf);
 	// Binary format objects are connected to the
 	// RBinObject, so the plugin must destroy the
 	// format data first
 	if (plugin && plugin->destroy) {
-		plugin->destroy (a);
+		plugin->destroy (bf);
 	}
-	r_buf_free (a->buf);
-	if (a->curxtr && a->curxtr->destroy && a->xtr_obj) {
-		a->curxtr->free_xtr ((void *)(a->xtr_obj));
+	r_buf_free (bf->buf);
+	if (bf->curxtr && bf->curxtr->destroy && bf->xtr_obj) {
+		bf->curxtr->free_xtr ((void *)(bf->xtr_obj));
 	}
 	// TODO: unset related sdb namespaces
-	if (a && a->sdb_addrinfo) {
-		sdb_free (a->sdb_addrinfo);
-		a->sdb_addrinfo = NULL;
-	}
-	free (a->file);
-	a->o = NULL;
-	r_list_free (a->objs);
-	r_list_free (a->xtr_data);
-	if (a->id != -1) {
+	if (bf->sdb_addrinfo) {
+		sdb_free (bf->sdb_addrinfo);
+		bf->sdb_addrinfo = NULL;
+	}
+	free (bf->file);
+	bf->o = NULL;
+	r_list_free (bf->objs);
+	r_list_free (bf->xtr_data);
+	if (bf->id != -1) {
 		// TODO: use r_storage api
-		r_id_pool_kick_id (a->rbin->ids->pool, a->id);
+		r_id_pool_kick_id (bf->rbin->ids->pool, bf->id);
 	}
-	free (a);
+	free (bf);
 }
 
 R_IPI RBinFile *r_bin_file_xtr_load_buffer(RBin *bin, RBinXtrPlugin *xtr, const char *filename, RBuffer *buf, ut64 file_sz, ut64 baseaddr, ut64 loadaddr, int idx, int fd, int rawstr) {
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (buf, &sz);
-	return r_bin_file_xtr_load_bytes (bin, xtr, filename, bytes, sz, file_sz, baseaddr, loadaddr, idx, fd, rawstr);
-}
-
-// This function populate RBinFile->xtr_data, that information is enough to
-// create RBinObject when needed using r_bin_file_object_new_from_xtr_data
-R_IPI RBinFile *r_bin_file_xtr_load_bytes(RBin *bin, RBinXtrPlugin *xtr, const char *filename, const ut8 *bytes, ut64 sz, ut64 file_sz, ut64 baseaddr, ut64 loadaddr, int idx, int fd, int rawstr) {
-	r_return_val_if_fail (bin && xtr && bytes, NULL);
+	r_return_val_if_fail (bin && xtr && buf, NULL);
 
 	RBinFile *bf = r_bin_file_find_by_name (bin, filename);
 	if (!bf) {
-		bf = file_create_append (bin, filename, bytes, sz,
-			file_sz, rawstr, fd, xtr->name, false);
+		bf = r_bin_file_new (bin, filename, file_sz, rawstr, fd, xtr->name, bin->sdb, false);
 		if (!bf) {
 			return NULL;
 		}
+		r_list_append (bin->binfiles, bf);
 		if (!bin->cur) {
 			bin->cur = bf;
 		}
 	}
 	r_list_free (bf->xtr_data);
-	bf->xtr_data = xtr->extractall_from_bytes (bin, bytes, sz);
+	bf->xtr_data = NULL;
+	if (xtr->extractall_from_buffer) {
+		bf->xtr_data = xtr->extractall_from_buffer (bin, buf);
+	} else if (xtr->extractall_from_bytes) {
+		ut64 sz = 0;
+		const ut8 *bytes = r_buf_data (buf, &sz);
+		eprintf ("TODO: Implement extractall_from_buffer in '%s' xtr.bin plugin\n", xtr->name);
+		bf->xtr_data = xtr->extractall_from_bytes (bin, bytes, sz);
+	}
 	if (bf->xtr_data) {
 		RListIter *iter;
-		RBinXtrData *xtr;
+		RBinXtrData *x;
 		//populate xtr_data with baddr and laddr that will be used later on
 		//r_bin_file_object_new_from_xtr_data
-		r_list_foreach (bf->xtr_data, iter, xtr) {
-			xtr->baddr = baseaddr? baseaddr : UT64_MAX;
-			xtr->laddr = loadaddr? loadaddr : UT64_MAX;
+		r_list_foreach (bf->xtr_data, iter, x) {
+			x->baddr = baseaddr? baseaddr : UT64_MAX;
+			x->laddr = loadaddr? loadaddr : UT64_MAX;
 		}
 	}
 	bf->loadaddr = loadaddr;
 	return bf;
 }
 
-#define LIMIT_SIZE 0
+// XXX deprecate this function imho.. wee can just access bf->buf directly
 R_IPI bool r_bin_file_set_bytes(RBinFile *bf, const ut8 *bytes, ut64 sz, bool steal_ptr) {
 	r_return_val_if_fail (bf && bytes, false);
-
 	r_buf_free (bf->buf);
-#if LIMIT_SIZE
-	if (sz > 1024 * 1024) {
-		eprintf ("Too big\n");
-		// TODO: use r_buf_io instead of setbytes all the time to save memory
-		return NULL;
-	}
-#else
 	if (steal_ptr) {
 		bf->buf = r_buf_new_with_pointers (bytes, sz, true);
 	} else {
 		bf->buf = r_buf_new_with_bytes (bytes, sz);
 	}
-#endif
 	return bf->buf != NULL;
 }
 
@@ -767,72 +712,63 @@ R_API RBinPlugin *r_bin_file_cur_plugin(RBinFile *binfile) {
 R_IPI RList *r_bin_file_get_strings(RBinFile *a, int min, int dump, int raw) {
 	r_return_val_if_fail (a, NULL);
 	RListIter *iter;
 	RBinSection *section;
-	RList *ret;
+	RList *ret = dump? NULL: r_list_newf (r_bin_string_free);
 
-	if (dump) {
-		/* dump to stdout, not stored in list */
-		ret = NULL;
-	} else {
-		ret = r_list_newf (r_bin_string_free);
-		if (!ret) {
-			return NULL;
-		}
-	}
 	if (!raw && a->o && a->o && a->o->sections && !r_list_empty (a->o->sections)) {
 		RBinObject *o = a->o;
 		r_list_foreach (o->sections, iter, section) {
 			if (is_data_section (a, section)) {
 				get_strings_range (a, ret, min, raw, section->paddr,
 						section->paddr + section->size, section);
 			}
 		}
 		r_list_foreach (o->sections, iter, section) {
 			/* load objc/swift strings */
 			const int bits = (a->o && a->o->info) ? a->o->info->bits : 32;
 			const int cfstr_size = (bits == 64) ? 32 : 16;
 			const int cfstr_offs = (bits == 64) ? 16 :  8;
 			if (strstr (section->name, "__cfstring")) {
 				int i;
-// XXX do not walk if bin.strings == 0
+				// XXX do not walk if bin.strings == 0
 				ut8 *p;
 				if (section->size > a->size) {
 					continue;
 				}
 				ut8 *sbuf = malloc (section->size);
 				if (!sbuf) {
 					continue;
 				}
 				r_buf_read_at (a->buf, section->paddr + cfstr_offs, sbuf, section->size);
 				for (i = 0; i < section->size; i += cfstr_size) {
 					ut8 *buf = sbuf;
 					p = buf + i;
 					if ((i + ((bits==64)? 8:4)) >= section->size) {
 						break;
 					}
 					ut64 cfstr_vaddr = section->vaddr + i;
 					ut64 cstr_vaddr = (bits == 64) ? r_read_le64 (p) : r_read_le32 (p);
 					RBinString *s = find_string_at (a, ret, cstr_vaddr);
 					if (s) {
 						RBinString *bs = R_NEW0 (RBinString);
 						if (bs) {
 							bs->type = s->type;
 							bs->length = s->length;
 							bs->size = s->size;
 							bs->ordinal = s->ordinal;
 							bs->vaddr = cfstr_vaddr;
 							bs->paddr = cfstr_vaddr; // XXX should be paddr instead
 							bs->string = r_str_newf ("cstr.%s", s->string);
 							r_list_append (ret, bs);
 							ht_up_insert (o->strings_db, bs->vaddr, bs);
 						}
 					}
 				}
 				free (sbuf);
 			}
 		}
 	} else {
 		get_strings_range (a, ret, min, raw, 0, a->size, NULL);
 	}
 	return ret;
 }
diff --git a/libr/bin/bin.c b/libr/bin/bin.c
index 618f4bc840..cf650b8adf 100644
--- a/libr/bin/bin.c
+++ b/libr/bin/bin.c
@@ -58,17 +58,15 @@ static ut64 binobj_a2b(RBinObject *o, ut64 addr) {
 // TODO: move these two function do a different file
 R_API RBinXtrData *r_bin_xtrdata_new(RBuffer *buf, ut64 offset, ut64 size, ut32 file_count, RBinXtrMetadata *metadata) {
 	RBinXtrData *data = R_NEW0 (RBinXtrData);
-	if (!data) {
-		return NULL;
+	if (data) {
+		data->offset = offset;
+		data->size = size;
+		data->file_count = file_count;
+		data->metadata = metadata;
+		data->loaded = 0;
+// dont slice twice TODO. review this
+		data->buf = r_buf_ref (buf); // r_buf_new_slice (buf, offset, size);
 	}
-	data->offset = offset;
-	data->size = size;
-	data->file_count = file_count;
-	data->metadata = metadata;
-	data->loaded = 0;
-	// TODO: USE RBuffer *buf inside RBinXtrData*
-	data->buf = r_buf_ref (buf);
-	// TODO. subbuffer?
 	return data;
 }
 
@@ -121,13 +119,11 @@ R_API void r_bin_arch_options_init(RBinArchOptions *opt, const char *arch, int b
 }
 
 R_API void r_bin_file_hash_free(RBinFileHash *fhash) {
-	if (!fhash) {
-		return;
+	if (fhash) {
+		R_FREE (fhash->type);
+		R_FREE (fhash->hex);
+		free (fhash);
 	}
-
-	R_FREE (fhash->type);
-	R_FREE (fhash->hex);
-	free (fhash);
 }
 
 R_API void r_bin_info_free(RBinInfo *rb) {
@@ -317,95 +313,97 @@ error:
 R_API bool r_bin_open_io(RBin *bin, RBinOptions *opt) {
 	r_return_val_if_fail (bin && opt && bin->iob.io, false);
 	r_return_val_if_fail (opt->fd >= 0 && (st64)opt->sz >= 0, false);
 
 	RIOBind *iob = &(bin->iob);
 	RIO *io = iob? iob->io: NULL;
 	RListIter *it;
 	RBinXtrPlugin *xtr;
-	RBinFile *binfile = NULL;
 	int tfd = opt->fd;
 
 	bool is_debugger = iob->fd_is_dbg (io, opt->fd);
 	const char *fname = iob->fd_get_name (io, opt->fd);
 
 	bin->rawstr = opt->rawstr;
 	if (opt->loadaddr == UT64_MAX) {
 		opt->loadaddr = 0;
 	}
 	ut64 file_sz = iob->fd_size (io, opt->fd);
 	// file_sz = UT64_MAX happens when attaching to frida:// and other non-debugger io plugins which results in double opening
 	if (is_debugger && file_sz == UT64_MAX) {
 		tfd = iob->fd_open (io, fname, R_PERM_R, 0644);
 		if (tfd >= 1) {
 			file_sz = iob->fd_size (io, tfd);
 		}
 	}
 	if (!opt->sz) {
 		opt->sz = file_sz;
 	}
 	// check if blockdevice?
 	if (opt->sz >= UT32_MAX) {
 		opt->sz = 1024 * 32;
 	}
 	RBuffer *buf = r_buf_new_with_io (&bin->iob, tfd);
 	if (!buf) {
 		return false;
 	}
 	bin->file = fname;
 	opt->sz = R_MIN (file_sz, opt->sz);
 	ut64 seekaddr = opt->loadaddr;
 
 	if (!is_debugger && seekaddr > 0 && seekaddr != UT64_MAX) {
 		// slice buffer if necessary
 		RBuffer *nb = r_buf_new_slice (buf, seekaddr, opt->sz);
 		if (nb) {
 			r_buf_free (buf);
 			buf = nb;
 		}
 	}
 
+	RBinFile *bf = NULL;
 	if (bin->use_xtr && !opt->pluginname && (st64)opt->sz > 0) {
 		// XXX - for the time being this is fine, but we may want to
 		// change the name to something like
 		// <xtr_name>:<bin_type_name>
 		r_list_foreach (bin->binxtrs, it, xtr) {
 			if (!xtr->check_buffer) {
 				eprintf ("Missing check_buffer callback for '%s'\n", xtr->name);
 				continue;
 			}
 			if (xtr->check_buffer (buf)) {
-				if (xtr->extract_from_bytes || xtr->extractall_from_bytes) {
+				if (xtr->extract_from_buffer || xtr->extractall_from_buffer ||
+				    xtr->extract_from_bytes || xtr->extractall_from_bytes) {
 					if (is_debugger && opt->sz != file_sz) {
 						if (tfd < 0) {
 							tfd = iob->fd_open (io, fname, R_PERM_R, 0);
 						}
 						opt->sz = iob->fd_size (io, tfd);
 						if (opt->sz != UT64_MAX) {
 							r_buf_seek (buf, 0, R_BUF_SET);
 							//buf->base_priv = 0;
 						}
 						// DOUBLECLOSE UAF : iob->fd_close (io, tfd);
 						tfd = -1; // marking it closed
 					}
-					binfile = r_bin_file_xtr_load_buffer (bin, xtr,
+					bf = r_bin_file_xtr_load_buffer (bin, xtr,
 						fname, buf, file_sz,
 						opt->baseaddr, opt->loadaddr, opt->xtr_idx,
 						opt->fd, bin->rawstr);
 				}
 			}
 		}
 	}
-	if (!binfile) {
-		binfile = r_bin_file_new_from_buffer (
+	if (!bf) {
+		bf = r_bin_file_new_from_buffer (
 			bin, fname, buf, file_sz, bin->rawstr,
 			opt->baseaddr, opt->loadaddr, opt->fd, opt->pluginname, opt->offset);
+		if (!bf) {
+			return false;
+		}
 	}
-
-	if (!binfile || !r_bin_file_set_cur_binfile (bin, binfile)) {
+	if (!r_bin_file_set_cur_binfile (bin, bf)) {
 		return false;
 	}
-
-	r_id_storage_set (bin->ids, bin->cur, binfile->id);
+	r_id_storage_set (bin->ids, bin->cur, bf->id);
 	return true;
 }
 
@@ -426,27 +424,51 @@ R_IPI RBinPlugin *r_bin_get_binplugin_by_name(RBin *bin, const char *name) {
 // XXX this api must die. See #11920
 R_API RBinPlugin *r_bin_get_binplugin_by_bytes(RBin *bin, const ut8 *bytes, ut64 sz) {
 	RBinPlugin *plugin;
 	RListIter *it;
 
+eprintf ("r_bin_get_binplugin_by_bytes is deprecated. Use r_bin_get_binplugin_by_buffer instead\n");
 	r_return_val_if_fail (bin && bytes, NULL);
 
 	r_list_foreach (bin->plugins, it, plugin) {
 		if (plugin->check_buffer) {
 			RBuffer *b = r_buf_new_with_pointers (bytes, sz, false);
 			if (b) {
 				bool ok = plugin->check_buffer (b);
 				r_buf_free (b);
 				if (ok) {
 					return plugin;
 				}
 			}
 		} else if (plugin->check_bytes && plugin->check_bytes (bytes, sz)) {
 			return plugin;
 		}
 	}
 	return NULL;
 }
 
+R_API RBinPlugin *r_bin_get_binplugin_by_buffer(RBin *bin, RBuffer *buf) {
+	RBinPlugin *plugin;
+	RListIter *it;
+
+	r_return_val_if_fail (bin && buf, NULL);
+
+	r_list_foreach (bin->plugins, it, plugin) {
+		if (plugin->check_buffer) {
+			if (plugin->check_buffer (buf)) {
+				return plugin;
+			}
+		} else if (plugin->check_bytes) {
+			eprintf ("Deprecate plugin->check_bytes for '%s' please\n", plugin->name);
+			ut64 sz;
+			const ut8 *bytes = r_buf_data (buf, &sz);
+			if (plugin->check_bytes (bytes, sz)) {
+				return plugin;
+			}
+		}
+	}
+	return NULL;
+}
+
 R_IPI RBinXtrPlugin *r_bin_get_xtrplugin_by_name(RBin *bin, const char *name) {
 	RBinXtrPlugin *xtr;
 	RListIter *it;
@@ -1067,118 +1089,119 @@ static void list_xtr_archs(RBin *bin, int mode) {
 R_API void r_bin_list_archs(RBin *bin, int mode) {
 	r_return_if_fail (bin);
 
 	RListIter *iter;
 	int i = 0;
 	char unk[128];
 	char archline[128];
 	RBinFile *binfile = r_bin_cur (bin);
 	RBinObject *obj = NULL;
 	const char *name = binfile? binfile->file: NULL;
 	int narch = binfile? binfile->narch: 0;
 
 	//are we with xtr format?
 	if (binfile && binfile->curxtr) {
 		list_xtr_archs (bin, mode);
 		return;
 	}
 	Sdb *binfile_sdb = binfile? binfile->sdb: NULL;
 	if (!binfile_sdb) {
 		eprintf ("Cannot find SDB!\n");
 		return;
-	} else if (!binfile) {
+	}
+	if (!binfile) {
 		eprintf ("Binary format not currently loaded!\n");
 		return;
 	}
 	sdb_unset (binfile_sdb, ARCHS_KEY, 0);
 	if (mode == 'j') {
 		bin->cb_printf ("\"bins\":[");
 	}
 	RBinFile *nbinfile = r_bin_file_find_by_name_n (bin, name, i);
 	if (!nbinfile) {
 		return;
 	}
 	i = -1;
 	r_list_foreach (nbinfile->objs, iter, obj) {
 		RBinInfo *info = obj->info;
 		char bits = info? info->bits: 0;
 		ut64 boffset = obj->boffset;
 		ut32 obj_size = obj->obj_size;
 		const char *arch = info? info->arch: NULL;
 		const char *machine = info? info->machine: "unknown_machine";
 
 		i++;
 		if (!arch) {
 			snprintf (unk, sizeof (unk), "unk_%d", i);
 			arch = unk;
 		}
 
 		if (info && narch > 1) {
 			switch (mode) {
 			case 'q':
 				bin->cb_printf ("%s\n", arch);
 				break;
 			case 'j':
 				bin->cb_printf ("%s{\"arch\":\"%s\",\"bits\":%d,"
 						"\"offset\":%" PFMT64d ",\"size\":%d,"
 						"\"machine\":\"%s\"}",
 						i? ",": "", arch, bits,
 						boffset, obj_size, machine);
 				break;
 			default:
 				bin->cb_printf ("%03i 0x%08" PFMT64x " %d %s_%i %s\n", i,
 						boffset, obj_size, arch, bits, machine);
 			}
 			snprintf (archline, sizeof (archline) - 1,
 				"0x%08" PFMT64x ":%d:%s:%d:%s",
 				boffset, obj_size, arch, bits, machine);
 			/// xxx machine not exported?
 			//sdb_array_push (binfile_sdb, ARCHS_KEY, archline, 0);
 		} else {
 			if (info) {
 				switch (mode) {
 				case 'q':
 					bin->cb_printf ("%s\n", arch);
 					break;
 				case 'j':
 					bin->cb_printf ("%s{\"arch\":\"%s\",\"bits\":%d,"
 							"\"offset\":%" PFMT64d ",\"size\":%d,"
 							"\"machine\":\"%s\"}",
 							i? ",": "", arch, bits,
 							boffset, obj_size, machine);
 					break;
 				default:
 					bin->cb_printf ("%03i 0x%08" PFMT64x " %d %s_%d\n", i,
 							boffset, obj_size, arch, bits);
 				}
 				snprintf (archline, sizeof (archline),
 					"0x%08" PFMT64x ":%d:%s:%d",
 					boffset, obj_size, arch, bits);
 			} else if (nbinfile && mode) {
 				switch (mode) {
 				case 'q':
 					bin->cb_printf ("%s\n", arch);
 					break;
 				case 'j':
 					bin->cb_printf ("%s{\"arch\":\"unk_%d\",\"bits\":%d,"
 							"\"offset\":%" PFMT64d ",\"size\":%d,"
 							"\"machine\":\"%s\"}",
 							i? ",": "", i, bits,
 							boffset, obj_size, machine);
 					break;
 				default:
 					bin->cb_printf ("%03i 0x%08" PFMT64x " %d unk_0\n", i,
 							boffset, obj_size);
 				}
 				snprintf (archline, sizeof (archline),
 					"0x%08" PFMT64x ":%d:%s:%d",
 					boffset, obj_size, "unk", 0);
 			} else {
 				eprintf ("Error: Invalid RBinFile.\n");
 			}
 			//sdb_array_push (binfile_sdb, ARCHS_KEY, archline, 0);
 		}
 	}
 	if (mode == 'j') {
 		bin->cb_printf ("]");
 	}
 }
diff --git a/libr/bin/bin_write.c b/libr/bin/bin_write.c
index f0a5e05c47..3c0060b618 100644
--- a/libr/bin/bin_write.c
+++ b/libr/bin/bin_write.c
@@ -1,61 +1,62 @@
-/* radare - LGPL - Copyright 2009-2015 - pancake, nibble */
+/* radare2 - LGPL - Copyright 2009-2019 - pancake, nibble */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_bin.h>
 
 /* XXX Implement r__bin_wr_scn_{   set, del   } instead */
 R_API ut64 r_bin_wr_scn_resize(RBin *bin, const char *name, ut64 size) {
-	RBinFile *binfile = r_bin_cur (bin);
-	RBinPlugin *plugin = r_bin_file_cur_plugin (binfile);
+	RBinFile *bf = r_bin_cur (bin);
+	RBinPlugin *plugin = r_bin_file_cur_plugin (bf);
 	if (plugin && plugin->write && plugin->write->scn_resize) {
-		return plugin->write->scn_resize (bin->cur, name, size);
+		return plugin->write->scn_resize (bf, name, size);
 	}
 	return false;
 }
 
 R_API bool r_bin_wr_scn_perms(RBin *bin, const char *name, int perms) {
-	RBinFile *binfile = r_bin_cur (bin);
-	RBinPlugin *plugin = r_bin_file_cur_plugin (binfile);
+	RBinFile *bf = r_bin_cur (bin);
+	RBinPlugin *plugin = r_bin_file_cur_plugin (bf);
 	if (plugin && plugin->write && plugin->write->scn_perms) {
-		return plugin->write->scn_perms (bin->cur, name, perms);
+		return plugin->write->scn_perms (bf, name, perms);
 	}
 	return false;
 }
 
 R_API bool r_bin_wr_rpath_del(RBin *bin) {
-	RBinFile *binfile = r_bin_cur (bin);
-	RBinPlugin *plugin = r_bin_file_cur_plugin (binfile);
+	RBinFile *bf = r_bin_cur (bin);
+	RBinPlugin *plugin = r_bin_file_cur_plugin (bf);
 	if (plugin && plugin->write && plugin->write->rpath_del) {
-		return plugin->write->rpath_del (bin->cur);
+		return plugin->write->rpath_del (bf);
 	}
 	return false;
 }
 
 R_API bool r_bin_wr_output(RBin *bin, const char *filename) {
-	RBinFile *binfile = r_bin_cur (bin);
-	if (!filename || !binfile || !binfile->buf) {
+	r_return_val_if_fail (bin && filename, false);
+	RBinFile *bf = r_bin_cur (bin);
+	if (!bf || !bf->buf) {
 		return false;
 	}
 	ut64 tmpsz;
-	const ut8 *tmp = r_buf_data (binfile->buf, &tmpsz);
+	const ut8 *tmp = r_buf_data (bf->buf, &tmpsz);
 	return r_file_dump (filename, tmp, tmpsz, 0);
 }
 
 R_API bool r_bin_wr_entry(RBin *bin, ut64 addr) {
-	RBinFile *binfile = r_bin_cur (bin);
-	RBinPlugin *plugin = r_bin_file_cur_plugin (binfile);
+	RBinFile *bf = r_bin_cur (bin);
+	RBinPlugin *plugin = r_bin_file_cur_plugin (bf);
 	if (plugin && plugin->write && plugin->write->entry) {
-		return plugin->write->entry (bin->cur, addr);
+		return plugin->write->entry (bf, addr);
 	}
 	return false;
 }
 
 R_API bool r_bin_wr_addlib(RBin *bin, const char *lib) {
-	RBinFile *binfile = r_bin_cur (bin);
-	RBinPlugin *plugin = r_bin_file_cur_plugin (binfile);
+	RBinFile *bf = r_bin_cur (bin);
+	RBinPlugin *plugin = r_bin_file_cur_plugin (bf);
 	if (plugin && plugin->write && plugin->write->addlib) {
 		return plugin->write->addlib (bin->cur, lib);
 	}
 	return false;
 }
diff --git a/libr/bin/format/elf/elf.c b/libr/bin/format/elf/elf.c
index 4bd0cb3ddc..e02f27adee 100644
--- a/libr/bin/format/elf/elf.c
+++ b/libr/bin/format/elf/elf.c
@@ -100,107 +100,111 @@ static bool is_bin_etrel(ELFOBJ *bin) {
 	return bin->ehdr.e_type == ET_REL;
 }
 
-static int handle_e_ident(ELFOBJ *bin) {
+static bool __is_valid_ident(ELFOBJ *bin) {
 	return !strncmp ((char *)bin->ehdr.e_ident, ELFMAG, SELFMAG) ||
 		!strncmp ((char *)bin->ehdr.e_ident, CGCMAG, SCGCMAG);
 }
 
-static int init_ehdr(ELFOBJ *bin) {
+static bool init_ehdr(ELFOBJ *bin) {
 	ut8 e_ident[EI_NIDENT];
 	ut8 ehdr[sizeof (Elf_(Ehdr))] = { 0 };
 	int i, len;
 	if (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {
 		bprintf ("read (magic)\n");
 		return false;
 	}
 	sdb_set (bin->kv, "elf_type.cparse", "enum elf_type { ET_NONE=0, ET_REL=1,"
 			" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,"
 			" ET_LOPROC=0xff00, ET_HIPROC=0xffff };", 0);
 	sdb_set (bin->kv, "elf_machine.cparse", "enum elf_machine {EM_NONE=0, EM_M32=1,"
 			" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,"
 			" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,"
 			" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,"
 			" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,"
 			" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,"
 			" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,"
 			" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,"
 			" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,"
 			" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,"
 			" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,"
 			" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,"
 			" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,"
 			" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,"
 			" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,"
 			" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,"
 			" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,"
 			" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,"
 			" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,"
 			" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,"
 			" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,"
 			" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,"
 			" EM_TI_ARP32=143, EM_TI_PRU=144,"
 			" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,"
 			" EM_HEXAGON=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,"
 			" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,"
 			" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,"
 			" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,"
 			" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,"
 			" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,"
 			" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,"
 			" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,"
 			" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,"
 			" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,"
 			" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,"
 			" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,"
 			" EM_CSKY=252}", 0);
 	sdb_set (bin->kv, "elf_class.cparse", "enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};", 0);
 	sdb_set (bin->kv, "elf_data.cparse", "enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};", 0);
 	sdb_set (bin->kv, "elf_hdr_version.cparse", "enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};", 0);
 	sdb_set (bin->kv, "elf_obj_version.cparse", "enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};", 0);
 	sdb_num_set (bin->kv, "elf_header.offset", 0, 0);
 	sdb_num_set (bin->kv, "elf_header.size", sizeof (Elf_(Ehdr)), 0);
 	sdb_set (bin->kv, "elf_ident.format", "[4]z[1]E[1]E[1]E.::"
 	         " magic (elf_class)class (elf_data)data (elf_hdr_version)version", 0);
 #if R_BIN_ELF64
 	sdb_set (bin->kv, "elf_header.format", "?[2]E[2]E[4]Eqqqxwwwwww"
 		" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version"
 		" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx", 0);
 #else
 	sdb_set (bin->kv, "elf_header.format", "?[2]E[2]E[4]Exxxxwwwwww"
 		" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version"
 		" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx", 0);
 #endif
 	bin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;
 	memset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));
-
-	len = r_buf_read_at (bin->b, 0, ehdr, sizeof (Elf_(Ehdr)));
-	if (len < 1) {
+	len = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));
+	if (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {
 		bprintf ("read (ehdr)\n");
 		return false;
 	}
+	// XXX no need to check twice
 	memcpy (&bin->ehdr.e_ident, ehdr, 16);
+	if (!__is_valid_ident (bin)) {
+		return false;
+	}
 	i = 16;
+	// TODO: use r_read or r_buf_read_ apis instead
 	bin->ehdr.e_type = READ16 (ehdr, i);
 	bin->ehdr.e_machine = READ16 (ehdr, i);
 	bin->ehdr.e_version = READ32 (ehdr, i);
 #if R_BIN_ELF64
 	bin->ehdr.e_entry = READ64 (ehdr, i);
 	bin->ehdr.e_phoff = READ64 (ehdr, i);
 	bin->ehdr.e_shoff = READ64 (ehdr, i);
 #else
 	bin->ehdr.e_entry = READ32 (ehdr, i);
 	bin->ehdr.e_phoff = READ32 (ehdr, i);
 	bin->ehdr.e_shoff = READ32 (ehdr, i);
 #endif
 	bin->ehdr.e_flags = READ32 (ehdr, i);
 	bin->ehdr.e_ehsize = READ16 (ehdr, i);
 	bin->ehdr.e_phentsize = READ16 (ehdr, i);
 	bin->ehdr.e_phnum = READ16 (ehdr, i);
 	bin->ehdr.e_shentsize = READ16 (ehdr, i);
 	bin->ehdr.e_shnum = READ16 (ehdr, i);
 	bin->ehdr.e_shstrndx = READ16 (ehdr, i);
-	return handle_e_ident (bin);
+	return true;
 	// [Outdated] Usage example:
 	// > td `k bin/cur/info/elf_type.cparse`; td `k bin/cur/info/elf_machine.cparse`
 	// > pf `k bin/cur/info/elf_header.format` @ `k bin/cur/info/elf_header.offset`
 }
@@ -1200,51 +1204,37 @@ static bool init_dynstr(ELFOBJ *bin) {
 	return false;
 }
 
-static int elf_init(ELFOBJ *bin) {
-	bin->phdr = NULL;
-	bin->shdr = NULL;
-	bin->strtab = NULL;
-	bin->shstrtab = NULL;
-	bin->strtab_size = 0;
-	bin->strtab_section = NULL;
-	bin->dyn_buf = NULL;
-	bin->dynstr = NULL;
-	ZERO_FILL (bin->version_info);
-
-	bin->g_sections = NULL;
-	bin->g_symbols = NULL;
-	bin->g_imports = NULL;
+static bool elf_init(ELFOBJ *bin) {
 	/* bin is not an ELF */
 	if (!init_ehdr (bin)) {
 		return false;
 	}
 	if (!init_phdr (bin) && !is_bin_etrel (bin)) {
 		bprintf ("Cannot initialize program headers\n");
 	}
 	if (bin->ehdr.e_type != ET_CORE) {
 		if (!init_shdr (bin)) {
 			bprintf ("Cannot initialize section headers\n");
 		}
 		if (!init_strtab (bin)) {
 			bprintf ("Cannot initialize strings table\n");
 		}
 		if (!init_dynstr (bin) && !is_bin_etrel (bin)) {
 			bprintf ("Cannot initialize dynamic strings\n");
 		}
 		bin->baddr = Elf_(r_bin_elf_get_baddr) (bin);
 		if (!init_dynamic_section (bin) && !Elf_(r_bin_elf_is_static) (bin) && !is_bin_etrel (bin)) {
 			bprintf ("Cannot initialize dynamic section\n");
 		}
 	}
 
 	bin->imports_by_ord_size = 0;
 	bin->imports_by_ord = NULL;
 	bin->symbols_by_ord_size = 0;
 	bin->symbols_by_ord = NULL;
 	bin->g_sections = Elf_(r_bin_elf_get_sections) (bin);
 	bin->boffset = Elf_(r_bin_elf_get_boffset) (bin);
 	sdb_ns_set (bin->kv, "versioninfo", store_versioninfo (bin));
-
 	return true;
 }
 
@@ -1876,158 +1866,159 @@ static ut64 getmainsymbol(ELFOBJ *bin) {
 
 ut64 Elf_(r_bin_elf_get_main_offset)(ELFOBJ *bin) {
 	ut64 entry = Elf_(r_bin_elf_get_entry_offset) (bin);
-	ut8 buf[512];
+	ut8 buf[256];
 	if (!bin || entry == UT64_MAX) {
 		return UT64_MAX;
 	}
 	if (entry > bin->size || (entry + sizeof (buf)) > bin->size) {
 		return UT64_MAX;
 	}
+	// unnecessary to read 512 bytes imho
 	if (r_buf_read_at (bin->b, entry, buf, sizeof (buf)) < 1) {
 		bprintf ("read (main)\n");
 		return UT64_MAX;
 	}
 	// ARM64
 	if (buf[0x18+3] == 0x58 && buf[0x2f] == 0x00) {
 		ut32 entry_vaddr = Elf_(r_bin_elf_p2v) (bin, entry);
 		ut32 main_addr = r_read_le32 (&buf[0x30]);
 		if ((main_addr >> 16) == (entry_vaddr >> 16)) {
 			return Elf_(r_bin_elf_v2p) (bin, main_addr);
 		}
 	}
 
 	// TODO: Use arch to identify arch before memcmp's
 
 	// ARM Glibc
 	if (entry & 1) {
 		int delta = 0;
 		/* thumb entry points */
 		if (!memcmp (buf, "\xf0\x00\x0b\x4f\xf0\x00\x0e\x02\xbc\x6a\x46", 11)) {
 			/* newer versions of gcc use push/pop */
 			delta = 0x28;
 		} else if (!memcmp (buf, "\xf0\x00\x0b\x4f\xf0\x00\x0e\x5d\xf8\x04\x1b", 11)) {
 			/* older versions of gcc (4.5.x) use ldr/str */
 			delta = 0x30;
 		}
 		if (delta) {
 			ut64 pa = Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[delta-1]) & ~1);
 			if (pa < r_buf_size (bin->b)) {
 				return pa;
 			}
 		}
 	} else {
 		/* non-thumb entry points */
 		if (!memcmp (buf, "\x00\xb0\xa0\xe3\x00\xe0\xa0\xe3", 8)) {
 			return Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0x34]) & ~1);
 		} else if (!memcmp (buf, "\x24\xc0\x9f\xe5\x00\xb0\xa0\xe3", 8)) {
 			return Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0x30]) & ~1);
 		}
 	}
 
 	// MIPS
 	/* get .got, calculate offset of main symbol */
 	if (!memcmp (buf, "\x21\x00\xe0\x03\x01\x00\x11\x04", 8)) {
 
 		/*
 		    assuming the startup code looks like
 		        got = gp-0x7ff0
 		        got[index__libc_start_main] ( got[index_main] );
 
 		    looking for the instruction generating the first argument to find main
 		        lw a0, offset(gp)
 		*/
 
 		ut64 got_offset;
 		if ((got_offset = Elf_(r_bin_elf_get_section_offset) (bin, ".got")) != -1 ||
 		    (got_offset = Elf_(r_bin_elf_get_section_offset) (bin, ".got.plt")) != -1)
 		{
 			const ut64 gp = got_offset + 0x7ff0;
 			unsigned i;
 			for (i = 0; i < sizeof(buf) / sizeof(buf[0]); i += 4) {
 				const ut32 instr = r_read_le32 (&buf[i]);
 				if ((instr & 0xffff0000) == 0x8f840000) { // lw a0, offset(gp)
 					const short delta = instr & 0x0000ffff;
 					r_buf_read_at (bin->b, /* got_entry_offset = */ gp + delta, buf, 4);
 					return Elf_(r_bin_elf_v2p) (bin, r_read_le32 (&buf[0]));
 				}
 			}
 		}
 
 		return 0;
 	}
 	// X86-CGC
 	if (buf[0] == 0xe8 && !memcmp (buf + 5, "\x50\xe8\x00\x00\x00\x00\xb8\x01\x00\x00\x00\x53", 12)) {
 		size_t SIZEOF_CALL = 5;
 		ut64 rel_addr = (ut64)((int)(buf[1] + (buf[2] << 8) + (buf[3] << 16) + (buf[4] << 24)));
 		ut64 addr = Elf_(r_bin_elf_p2v)(bin, entry + SIZEOF_CALL);
 		addr += rel_addr;
 		return Elf_(r_bin_elf_v2p) (bin, addr);
 	}
 	// X86-PIE
 	if (buf[0x00] == 0x48 && buf[0x1e] == 0x8d && buf[0x11] == 0xe8) {
 		ut32 *pmain = (ut32*)(buf + 0x30);
 		ut64 vmain = Elf_(r_bin_elf_p2v) (bin, (ut64)*pmain);
 		ut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);
 		if (vmain >> 16 == ventry >> 16) {
 			return (ut64)vmain;
 		}
 	}
 	// X86-PIE
 	if (buf[0x1d] == 0x48 && buf[0x1e] == 0x8b) {
 		if (!memcmp (buf, "\x31\xed\x49\x89", 4)) {// linux
 			ut64 maddr, baddr;
 			ut8 n32s[sizeof (ut32)] = {0};
 			maddr = entry + 0x24 + r_read_le32 (buf + 0x20);
 			if (r_buf_read_at (bin->b, maddr, n32s, sizeof (ut32)) == -1) {
 				bprintf ("read (maddr) 2\n");
 				return 0;
 			}
 			maddr = (ut64)r_read_le32 (&n32s[0]);
 			baddr = (bin->ehdr.e_entry >> 16) << 16;
 			if (bin->phdr) {
 				baddr = Elf_(r_bin_elf_get_baddr) (bin);
 			}
 			maddr += baddr;
 			return maddr;
 		}
 	}
 	// X86-NONPIE
 #if R_BIN_ELF64
 	if (!memcmp (buf, "\x49\x89\xd9", 3) && buf[156] == 0xe8) { // openbsd
 		return r_read_le32 (&buf[157]) + entry + 156 + 5;
 	}
 	if (!memcmp (buf+29, "\x48\xc7\xc7", 3)) { // linux
 		ut64 addr = (ut64)r_read_le32 (&buf[29 + 3]);
 		return Elf_(r_bin_elf_v2p) (bin, addr);
 	}
 #else
 	if (buf[23] == '\x68') {
 		ut64 addr = (ut64)r_read_le32 (&buf[23 + 1]);
 		return Elf_(r_bin_elf_v2p) (bin, addr);
 	}
 #endif
 	/* linux64 pie main -- probably buggy in some cases */
 	int bo = 29; // Begin offset may vary depending on the entry prelude 
 	if (buf[0] == 0xf3 && buf[1] == 0x0f && buf[2] == 0x1e && buf[3] == 0xfa) {
 		// Change begin offset if binary starts with 'endbr64'
 		bo = 33;
 	}
 	if (buf[bo] == 0x48 && buf[bo + 1] == 0x8d) { // lea rdi, qword [rip-0x21c4]
 		ut8 *p = buf + bo + 3;
 		st32 maindelta = (st32)r_read_le32 (p);
 		ut64 vmain = (ut64)(entry + bo + maindelta) + 7;
 		ut64 ventry = Elf_(r_bin_elf_p2v) (bin, entry);
 		if (vmain>>16 == ventry>>16) {
 			return (ut64)vmain;
 		}
 	}
 
 	/* find sym.main if possible */
 	{
 		ut64 m = getmainsymbol (bin);
 		if (m != UT64_MAX) {
 			return m;
 		}
 	}
 	return UT64_MAX;
 }
@@ -3271,253 +3262,252 @@ RBinSymbol *Elf_(_r_bin_elf_convert_symbol)(struct Elf_(r_bin_elf_obj_t) *bin,
 // TODO: return RList<RBinSymbol*> .. or run a callback with that symbol constructed, so we dont have to do it twice
 static RBinElfSymbol* Elf_(_r_bin_elf_get_symbols_imports)(ELFOBJ *bin, int type) {
 	ut32 shdr_size;
 	int tsize, nsym, ret_ctr = 0, i, j, r, k, newsize;
 	ut64 toffset;
 	ut32 size = 0;
 	RBinElfSymbol *ret = NULL, *import_ret = NULL;
 	RBinSymbol *import_sym_ptr = NULL;
 	size_t ret_size = 0, prev_ret_size = 0, import_ret_ctr = 0;
 	Elf_(Shdr) *strtab_section = NULL;
 	Elf_(Sym) *sym = NULL;
 	ut8 s[sizeof (Elf_(Sym))] = { 0 };
 	char *strtab = NULL;
 
 	if (!bin || !bin->shdr || !bin->ehdr.e_shnum || bin->ehdr.e_shnum == 0xffff) {
 		return Elf_(get_phdr_symbols) (bin, type);
 	}
 	if (!UT32_MUL (&shdr_size, bin->ehdr.e_shnum, sizeof (Elf_(Shdr)))) {
 		return false;
 	}
 	if (shdr_size + 8 > bin->size) {
 		return false;
 	}
 	for (i = 0; i < bin->ehdr.e_shnum; i++) {
 		if (((type & R_BIN_ELF_SYMTAB_SYMBOLS) && bin->shdr[i].sh_type == SHT_SYMTAB) ||
 				((type & R_BIN_ELF_DYNSYM_SYMBOLS) && bin->shdr[i].sh_type == SHT_DYNSYM)) {
 			if (bin->shdr[i].sh_link < 1) {
 				/* oops. fix out of range pointers */
 				continue;
 			}
 			// hack to avoid asan cry
 			if ((bin->shdr[i].sh_link * sizeof(Elf_(Shdr))) >= shdr_size) {
 				/* oops. fix out of range pointers */
 				continue;
 			}
 			strtab_section = &bin->shdr[bin->shdr[i].sh_link];
 			if (strtab_section->sh_size > ST32_MAX || strtab_section->sh_size+8 > bin->size) {
 				bprintf ("size (syms strtab)");
 				free (ret);
 				free (strtab);
 				return NULL;
 			}
 			if (!strtab) {
 				if (!(strtab = (char *)calloc (1, 8 + strtab_section->sh_size))) {
 					bprintf ("malloc (syms strtab)");
 					goto beach;
 				}
 				if (strtab_section->sh_offset > bin->size ||
 						strtab_section->sh_offset + strtab_section->sh_size > bin->size) {
 					goto beach;
 				}
 				if (r_buf_read_at (bin->b, strtab_section->sh_offset,
 							(ut8*)strtab, strtab_section->sh_size) == -1) {
 					bprintf ("read (syms strtab)\n");
 					goto beach;
 				}
 			}
 
 			newsize = 1 + bin->shdr[i].sh_size;
 			if (newsize < 0 || newsize > bin->size) {
 				bprintf ("invalid shdr %d size\n", i);
 				goto beach;
 			}
 			nsym = (int)(bin->shdr[i].sh_size / sizeof (Elf_(Sym)));
 			if (nsym < 0) {
 				goto beach;
 			}
 			{
 				ut64 sh_begin = bin->shdr[i].sh_offset;
 				ut64 sh_end = sh_begin + bin->shdr[i].sh_size;
 				if (sh_begin > bin->size) {
 					goto beach;
 				}
 				if (sh_end > bin->size) {
 					st64 newshsize = bin->size - sh_begin;
 					nsym = (int)(newshsize / sizeof (Elf_(Sym)));
 				}
 			}
 			if (!(sym = (Elf_(Sym) *)calloc (nsym, sizeof (Elf_(Sym))))) {
 				bprintf ("calloc (syms)");
 				goto beach;
 			}
 			if (!UT32_MUL (&size, nsym, sizeof (Elf_(Sym)))) {
 				goto beach;
 			}
 			if (size < 1 || size > bin->size) {
 				goto beach;
 			}
 			if (bin->shdr[i].sh_offset > bin->size) {
 				goto beach;
 			}
 			if (bin->shdr[i].sh_offset + size > bin->size) {
 				goto beach;
 			}
 			for (j = 0; j < nsym; j++) {
 				int k = 0;
 				r = r_buf_read_at (bin->b, bin->shdr[i].sh_offset + j * sizeof (Elf_(Sym)), s, sizeof (Elf_(Sym)));
 				if (r < 1) {
 					bprintf ("read (sym)\n");
 					goto beach;
 				}
 #if R_BIN_ELF64
 				sym[j].st_name = READ32 (s, k);
 				sym[j].st_info = READ8 (s, k);
 				sym[j].st_other = READ8 (s, k);
 				sym[j].st_shndx = READ16 (s, k);
 				sym[j].st_value = READ64 (s, k);
 				sym[j].st_size = READ64 (s, k);
 #else
 				sym[j].st_name = READ32 (s, k);
 				sym[j].st_value = READ32 (s, k);
 				sym[j].st_size = READ32 (s, k);
 				sym[j].st_info = READ8 (s, k);
 				sym[j].st_other = READ8 (s, k);
 				sym[j].st_shndx = READ16 (s, k);
 #endif
 			}
 			ret = realloc (ret, (ret_size + nsym) * sizeof (RBinElfSymbol));
 			if (!ret) {
 				bprintf ("Cannot allocate %d symbols\n", nsym);
 				goto beach;
 			}
 			memset (ret + ret_size, 0, nsym * sizeof (RBinElfSymbol));
 			prev_ret_size = ret_size;
 			ret_size += nsym;
 			for (k = 1; k < nsym; k++) {
 				bool is_sht_null = false;
 				bool is_vaddr = false;
 				bool is_imported = false;
 				if (type == R_BIN_ELF_IMPORT_SYMBOLS)  {
 					if (sym[k].st_value) {
 						toffset = sym[k].st_value;
 					} else if ((toffset = get_import_addr (bin, k)) == -1){
 						toffset = 0;
 					}
 					tsize = 16;
 					is_imported = sym[k].st_shndx == STN_UNDEF;
 				} else {
 					tsize = sym[k].st_size;
 					toffset = (ut64)sym[k].st_value;
 					is_sht_null = sym[k].st_shndx == SHT_NULL;
 				}
 				if (is_bin_etrel (bin)) {
 					if (sym[k].st_shndx < bin->ehdr.e_shnum) {
 						ret[ret_ctr].offset = sym[k].st_value + bin->shdr[sym[k].st_shndx].sh_offset;
 					}
 				} else {
 					ret[ret_ctr].offset = Elf_(r_bin_elf_v2p_new) (bin, toffset);
 					if (ret[ret_ctr].offset == UT64_MAX) {
 						ret[ret_ctr].offset = toffset;
 						is_vaddr = true;
 					}
 				}
 				ret[ret_ctr].size = tsize;
 				if (sym[k].st_name + 2 > strtab_section->sh_size) {
 					bprintf ("index out of strtab range\n");
 					goto beach;
 				}
 				{
 					int rest = ELF_STRING_LENGTH - 1;
 					int st_name = sym[k].st_name;
 					int maxsize = R_MIN (r_buf_size (bin->b), strtab_section->sh_size);
 					if (is_section_local_sym (bin, &sym[k])) {
 						const char *shname = &bin->shstrtab[bin->shdr[sym[k].st_shndx].sh_name];
 						r_str_ncpy (ret[ret_ctr].name, shname, ELF_STRING_LENGTH);
 					} else if (st_name <= 0 || st_name >= maxsize) {
 						ret[ret_ctr].name[0] = 0;
 					} else {
 						bool found = false;
 						j = -1;
 						while (!ret[++j].last && j < prev_ret_size) {
 							if (ret[j].offset == ret[ret_ctr].offset &&
 									strcmp (ret[j].name, "") != 0 && strcmp (ret[j].name, &strtab[st_name]) == 0
 									&& strcmp (ret[j].type, type2str (NULL, NULL, &sym[k])) == 0) {
 								found = true;
 								break;
 							}
 						}
 						if (found) {
 							memset (ret + ret_ctr, 0, sizeof (RBinElfSymbol));
 							continue;
 						}
 						const size_t len = __strnlen (strtab + sym[k].st_name, rest);
 						memcpy (ret[ret_ctr].name, &strtab[sym[k].st_name], len);
 					}
 				}
 				ret[ret_ctr].ordinal = k;
 				ret[ret_ctr].name[ELF_STRING_LENGTH - 2] = '\0';
 				fill_symbol_bind_and_type (bin, &ret[ret_ctr], &sym[k]);
 				ret[ret_ctr].is_sht_null = is_sht_null;
 				ret[ret_ctr].is_vaddr = is_vaddr;
 				ret[ret_ctr].last = 0;
 				ret[ret_ctr].is_imported = is_imported;
 				ret_ctr++;
 				if (type == R_BIN_ELF_IMPORT_SYMBOLS && is_imported) {
 					import_ret_ctr++;
 				}
 			}
 			R_FREE (strtab);
 			R_FREE (sym);
 			if (type == R_BIN_ELF_IMPORT_SYMBOLS) {
 				break;
 			}
 		}
 	}
 	if (!ret) {
 		return Elf_(get_phdr_symbols) (bin, type);
-	} else {
-		ret[ret_ctr].last = 1; // ugly dirty hack :D
 	}
+	ret[ret_ctr].last = 1; // ugly dirty hack :D
 	int max = -1;
 	RBinElfSymbol *aux = NULL;
 	nsym = Elf_(fix_symbols) (bin, ret_ctr, type, &ret);
 	if (nsym == -1) {
 		goto beach;
 	}
 	aux = ret;
 	while (!aux->last) {
 		if ((int)aux->ordinal > max) {
 			max = aux->ordinal;
 		}
 		aux++;
 	}
 	nsym = max;
 	if (type == R_BIN_ELF_IMPORT_SYMBOLS) {
 		R_FREE (bin->imports_by_ord);
 		bin->imports_by_ord_size = nsym + 1;
 		bin->imports_by_ord = (RBinImport**)calloc (R_MAX (1, nsym + 1), sizeof (RBinImport*));
 		R_FREE (bin->symbols_by_ord);
 		bin->symbols_by_ord_size = nsym + 1;
 		bin->symbols_by_ord = (RBinSymbol**)calloc (R_MAX (1, nsym + 1), sizeof (RBinSymbol*));
 		import_ret = calloc (import_ret_ctr + 1, sizeof (RBinElfSymbol));
 		if (!import_ret) {
 			bprintf ("Cannot allocate %d symbols\n", nsym);
 			goto beach;
 		}
 		import_ret_ctr = 0;
 		i = -1;
 		while (!ret[++i].last) {
 			if (!(import_sym_ptr = Elf_(_r_bin_elf_convert_symbol) (bin, &ret[i], "%s"))) {
 				continue;
 			}
 			setsymord (bin, import_sym_ptr->ordinal, import_sym_ptr);
 			if (ret[i].is_imported) {
 				memcpy (&import_ret[import_ret_ctr], &ret[i], sizeof (RBinElfSymbol));
 				++import_ret_ctr;
 			}
 		}
 		import_ret[import_ret_ctr].last = 1;
 		R_FREE (ret);
 		return import_ret;
 	}
 	return ret;
@@ -3566,81 +3556,56 @@ RBinElfField* Elf_(r_bin_elf_get_fields)(ELFOBJ *bin) {
 	return ret;
 }
 
-void* Elf_(r_bin_elf_free)(ELFOBJ* bin) {
+void Elf_(r_bin_elf_free)(ELFOBJ* bin) {
 	int i;
 	if (!bin) {
-		return NULL;
+		return;
 	}
 	free (bin->phdr);
 	free (bin->shdr);
 	free (bin->strtab);
 	free (bin->dyn_buf);
 	free (bin->shstrtab);
 	free (bin->dynstr);
 	//free (bin->strtab_section);
 	if (bin->imports_by_ord) {
 		for (i = 0; i<bin->imports_by_ord_size; i++) {
 			free (bin->imports_by_ord[i]);
 		}
 		free (bin->imports_by_ord);
 	}
 	if (bin->symbols_by_ord) {
 		for (i = 0; i<bin->symbols_by_ord_size; i++) {
 			r_bin_symbol_free (bin->symbols_by_ord[i]);
 		}
 		free (bin->symbols_by_ord);
 	}
 	r_buf_free (bin->b);
 	if (bin->g_symbols != bin->phdr_symbols) {
 		R_FREE (bin->phdr_symbols);
 	}
 	if (bin->g_imports != bin->phdr_imports) {
 		R_FREE (bin->phdr_imports);
 	}
 	R_FREE (bin->g_sections);
 	R_FREE (bin->g_symbols);
 	R_FREE (bin->g_imports);
 	ht_up_free (bin->rel_cache);
 	bin->rel_cache = NULL;
 	free (bin);
-	return NULL;
-}
-
-ELFOBJ* Elf_(r_bin_elf_new)(const char* file, bool verbose) {
-	ut8 *buf;
-	int size;
-	ELFOBJ *bin = R_NEW0 (ELFOBJ);
-	if (!bin) {
-		return NULL;
-	}
-	memset (bin, 0, sizeof (ELFOBJ));
-	bin->file = file;
-	if (!(buf = (ut8*)r_file_slurp (file, &size))) {
-		return Elf_(r_bin_elf_free) (bin);
-	}
-	bin->size = size;
-	bin->verbose = verbose;
-	bin->b = r_buf_new ();
-	if (!r_buf_set_bytes (bin->b, buf, bin->size)) {
-		free (buf);
-		return Elf_(r_bin_elf_free) (bin);
-	}
-	if (!elf_init (bin)) {
-		free (buf);
-		return Elf_(r_bin_elf_free) (bin);
-	}
-	free (buf);
-	return bin;
 }
 
 ELFOBJ* Elf_(r_bin_elf_new_buf)(RBuffer *buf, bool verbose) {
 	ELFOBJ *bin = R_NEW0 (ELFOBJ);
-	bin->kv = sdb_new0 ();
-	bin->size = (ut32)r_buf_size (buf);
-	bin->verbose = verbose;
-	bin->b = r_buf_ref (buf);
-	if (!elf_init (bin)) {
-		return Elf_(r_bin_elf_free) (bin);
+	if (bin) {
+		bin->kv = sdb_new0 ();
+		bin->size = (ut32)r_buf_size (buf);
+		bin->verbose = verbose;
+		bin->b = r_buf_ref (buf);
+		if (!elf_init (bin)) {
+			Elf_(r_bin_elf_free) (bin);
+			return NULL;
+		}
 	}
 	return bin;
 }
diff --git a/libr/bin/format/elf/elf.h b/libr/bin/format/elf/elf.h
index 42832b3c70..c6562400f8 100644
--- a/libr/bin/format/elf/elf.h
+++ b/libr/bin/format/elf/elf.h
@@ -154,13 +154,16 @@ RBinElfSymbol* Elf_(r_bin_elf_get_symbols)(struct Elf_(r_bin_elf_obj_t) *bin);
 RBinElfSymbol* Elf_(r_bin_elf_get_imports)(struct Elf_(r_bin_elf_obj_t) *bin);
 struct r_bin_elf_field_t* Elf_(r_bin_elf_get_fields)(struct Elf_(r_bin_elf_obj_t) *bin);
 char *Elf_(r_bin_elf_get_rpath)(struct Elf_(r_bin_elf_obj_t) *bin);
-void* Elf_(r_bin_elf_free)(struct Elf_(r_bin_elf_obj_t)* bin);
+
 struct Elf_(r_bin_elf_obj_t)* Elf_(r_bin_elf_new)(const char* file, bool verbose);
 struct Elf_(r_bin_elf_obj_t)* Elf_(r_bin_elf_new_buf)(RBuffer *buf, bool verbose);
-ut64 Elf_(r_bin_elf_resize_section)(struct Elf_(r_bin_elf_obj_t) *bin, const char *name, ut64 size);
-bool Elf_(r_bin_elf_section_perms)(struct Elf_(r_bin_elf_obj_t) *bin, const char *name, int perms);
-bool Elf_(r_bin_elf_entry_write)(struct Elf_(r_bin_elf_obj_t) *bin, ut64 addr);
-bool Elf_(r_bin_elf_del_rpath)(struct Elf_(r_bin_elf_obj_t) *bin);
+void Elf_(r_bin_elf_free)(struct Elf_(r_bin_elf_obj_t)* bin);
+
+ut64 Elf_(r_bin_elf_resize_section)(RBinFile *bf, const char *name, ut64 size);
+bool Elf_(r_bin_elf_section_perms)(RBinFile *bf, const char *name, int perms);
+bool Elf_(r_bin_elf_entry_write)(RBinFile *bf, ut64 addr);
+bool Elf_(r_bin_elf_del_rpath)(RBinFile *bf);
+
 int Elf_(r_bin_elf_has_relro)(struct Elf_(r_bin_elf_obj_t) *bin);
 int Elf_(r_bin_elf_has_nx)(struct Elf_(r_bin_elf_obj_t) *bin);
 ut8 *Elf_(r_bin_elf_grab_regstate)(struct Elf_(r_bin_elf_obj_t) *bin, int *len);
@@ -168,5 +171,4 @@ RList *Elf_(r_bin_elf_get_maps)(ELFOBJ *bin);
 RBinSymbol *Elf_(_r_bin_elf_convert_symbol)(struct Elf_(r_bin_elf_obj_t) *bin,
 					  struct r_bin_elf_symbol_t *symbol,
 					  const char *namefmt);
-
 #endif
diff --git a/libr/bin/format/elf/elf_write.c b/libr/bin/format/elf/elf_write.c
index 5b8ae33484..606b9c02ee 100644
--- a/libr/bin/format/elf/elf_write.c
+++ b/libr/bin/format/elf/elf_write.c
@@ -1,279 +1,283 @@
-/* radare - LGPL - Copyright 2010-2018 pancake, nibble */
+/* radare - LGPL - Copyright 2010-2019 pancake, nibble */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <r_types.h>
 #include <r_util.h>
 #include "elf.h"
 
 // XXX UGLY CODE
 /* TODO: Take care of endianess */
 /* TODO: Real error handling */
 /* TODO: Resize sections before .init */
-ut64 Elf_(r_bin_elf_resize_section)(struct Elf_(r_bin_elf_obj_t) *bin, const char *name, ut64 size) {
+// ut64 Elf_(r_bin_elf_resize_section)(struct Elf_(r_bin_elf_obj_t) *bin, const char *name, ut64 size) {
+ut64 Elf_(r_bin_elf_resize_section)(RBinFile *bf, const char *name, ut64 size) {
+	struct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj; // , const char *name, ut64 size) {
 	Elf_(Ehdr) *ehdr = &bin->ehdr;
 	Elf_(Phdr) *phdr = bin->phdr, *phdrp;
 	Elf_(Shdr) *shdr = bin->shdr, *shdrp;
 	const char *strtab = bin->shstrtab;
 	ut8 *buf;
 	ut64 off, got_offset = 0, got_addr = 0, rsz_offset = 0, delta = 0;
 	ut64 rsz_osize = 0, rsz_size = size, rest_size = 0;
 	int i, j, done = 0;
 
 	if (size == 0) {
 		eprintf ("0 size section?\n");
 		return 0;
 	}
 
 	/* calculate delta */
 	for (i = 0, shdrp = shdr; i < ehdr->e_shnum; i++, shdrp++) {
 		int idx = shdrp->sh_name;
 		if (idx < 0 || idx >= bin->shstrtab_size) {
 			continue;
 		}
 		const char *sh_name = &strtab[shdrp->sh_name];
 		if (sh_name && !strncmp (name, sh_name, ELF_STRING_LENGTH)) {
 			delta =  rsz_size - shdrp->sh_size;
 			rsz_offset = (ut64)shdrp->sh_offset;
 			rsz_osize = (ut64)shdrp->sh_size;
 		}
 	}
 
 	if (delta == 0) {
 		eprintf ("Cannot find section\n");
 		return 0;
 	}
  
 	eprintf ("delta: %"PFMT64d"\n", delta);
 	
 	/* rewrite rel's (imports) */
 	for (i = 0, shdrp = shdr; i < ehdr->e_shnum; i++, shdrp++) {
 		if (!strcmp(&strtab[shdrp->sh_name], ".got")) {
 			got_addr = (ut64)shdrp->sh_addr;
 			got_offset = (ut64)shdrp->sh_offset;
 		}
 	}
 	if (got_addr == 0 || got_offset == 0) {
 		/* TODO: Unknown GOT address */
 	}
 
 	for (i = 0, shdrp = shdr; i < ehdr->e_shnum; i++, shdrp++) {
 		if (!strcmp (&strtab[shdrp->sh_name], ".rel.plt")) {
 			Elf_(Rel) *rel, *relp;
 			rel = (Elf_(Rel) *)malloc (1+shdrp->sh_size);
 			if (!rel) {
 				perror ("malloc");
 				return 0;
 			}
 			if (r_buf_read_at (bin->b, shdrp->sh_offset, (ut8*)rel, shdrp->sh_size) == -1) {
 				perror("read (rel)");
 			}
 			for (j = 0, relp = rel; j < shdrp->sh_size; j += sizeof(Elf_(Rel)), relp++) {
 				/* rewrite relp->r_offset */
 				if (relp->r_offset - got_addr + got_offset >= rsz_offset + rsz_osize) {
 					relp->r_offset+=delta;
 					off = shdrp->sh_offset + j;
 					if (r_buf_write_at (bin->b, off, (ut8*)relp, sizeof (Elf_(Rel))) == -1) {
 						perror("write (imports)");
 					}
 				}
 			}
 			free(rel);
 			break;
 		} else if (!strcmp (&strtab[shdrp->sh_name], ".rela.plt")) {
 			Elf_(Rela) *rel, *relp;
 			rel = (Elf_(Rela) *)malloc (shdrp->sh_size + 1);
 			if (!rel) {
 				perror("malloc");
 				return 0;
 			}
 			if (r_buf_read_at (bin->b, shdrp->sh_offset, (ut8*)rel, shdrp->sh_size) == -1) {
 				perror("read (rel)");
 			}
 			for (j = 0, relp = rel; j < shdrp->sh_size; j += sizeof(Elf_(Rela)), relp++) {
 				/* rewrite relp->r_offset */
 				if (relp->r_offset - got_addr + got_offset >= rsz_offset + rsz_osize) {
 					relp->r_offset+=delta;
 					off = shdrp->sh_offset + j;
 					if (r_buf_write_at (bin->b, off, (ut8*)relp, sizeof (Elf_(Rela))) == -1) {
 						perror("write (imports)");
 					}
 				}
 			}
 			free(rel);
 			break;
 		}
 	}
 
 	/* rewrite section headers */
 	for (i = 0, shdrp = shdr; i < ehdr->e_shnum; i++, shdrp++) {
 		if (!done && !strncmp (name, &strtab[shdrp->sh_name], ELF_STRING_LENGTH)) {
 			shdrp->sh_size = rsz_size;
 			done = 1;
 		} else if (shdrp->sh_offset >= rsz_offset + rsz_osize) {
 			shdrp->sh_offset += delta;
 			if (shdrp->sh_addr) {
 				shdrp->sh_addr += delta;
 			}
 		}
 		off = ehdr->e_shoff + i * sizeof (Elf_(Shdr));
 		if (r_buf_write_at (bin->b, off, (ut8*)shdrp, sizeof (Elf_(Shdr))) == -1) {
 			perror ("write (shdr)");
 		}
 		printf ("-> elf section (%s)\n", &strtab[shdrp->sh_name]);
 	}
 
 	/* rewrite program headers */
 	for (i = 0, phdrp = phdr; i < ehdr->e_phnum; i++, phdrp++) {
 #if 0 
 		if (phdrp->p_offset < rsz_offset && phdrp->p_offset + phdrp->p_filesz > rsz_offset) {
 			phdrp->p_filesz += delta;
 			phdrp->p_memsz += delta;
 		}
 #endif 
 		if (phdrp->p_offset >= rsz_offset + rsz_osize) {
 			phdrp->p_offset += delta;
 			if (phdrp->p_vaddr) {
 				phdrp->p_vaddr += delta;
 			}
 			if (phdrp->p_paddr) {
 				phdrp->p_paddr += delta;
 			}
 		} else if (phdrp->p_offset + phdrp->p_filesz >= rsz_offset + rsz_osize) {
 			phdrp->p_filesz += delta;
 			phdrp->p_memsz += delta;
 		} 
 		off = ehdr->e_phoff + i * sizeof (Elf_(Phdr));
 		if (r_buf_write_at (bin->b, off, (ut8 *)phdrp, sizeof (Elf_ (Phdr))) == -1) {
 			perror ("write (phdr)");
 		}
 		printf ("-> program header (0x%08"PFMT64x")\n", (ut64) phdrp->p_offset);
 	}
 
 	/* rewrite other elf pointers (entrypoint, phoff, shoff) */
 	if (ehdr->e_entry - bin->baddr >= rsz_offset + rsz_osize) {
 		ehdr->e_entry += delta;
 	}
 	if (ehdr->e_phoff >= rsz_offset + rsz_osize) {
 		ehdr->e_phoff += delta;
 	}
 	if (ehdr->e_shoff >= rsz_offset + rsz_osize) {
 		ehdr->e_shoff += delta;
 	}
 	if (r_buf_write_at (bin->b, 0, (ut8*)ehdr, sizeof (Elf_(Ehdr))) == -1) {
 		perror ("write (ehdr)");
 	}
 
 	/* inverse order to write bodies .. avoid overlapping here */
 	/* XXX Check when delta is negative */
 	rest_size = bin->size - (rsz_offset + rsz_osize);
 
 	buf = (ut8 *)malloc (1+bin->size);
 	r_buf_read_at (bin->b, 0, (ut8*)buf, bin->size);
 	r_buf_set_bytes (bin->b, (ut8*)buf, (int)(rsz_offset+rsz_size+rest_size));
 
 	printf ("COPY FROM 0x%08"PFMT64x"\n", (ut64)(rsz_offset+rsz_osize));
 	r_buf_read_at (bin->b, rsz_offset + rsz_osize, (ut8*)buf, rest_size);
 	printf ("COPY TO 0x%08"PFMT64x"\n", (ut64)(rsz_offset+rsz_size));
 	r_buf_write_at (bin->b, rsz_offset + rsz_size, (ut8*)buf, rest_size);
 	printf ("Shifted %d byte(s)\n", (int)delta);
 	free (buf);
 	bin->size = r_buf_size (bin->b);
 
 	return delta;
 }
 
 /* XXX Endianness? */
-bool Elf_(r_bin_elf_del_rpath)(struct Elf_(r_bin_elf_obj_t) *bin) {
+bool Elf_(r_bin_elf_del_rpath)(RBinFile *bf) {
+	struct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;
 	Elf_(Dyn) *dyn = NULL;
 	ut64 stroff = 0LL;
 	int ndyn, i, j;
 
 	if (!bin->phdr) {
 		return false;
 	}
 	for (i = 0; i < bin->ehdr.e_phnum; i++) {
 		if (bin->phdr[i].p_type != PT_DYNAMIC) {
 			continue;
 		}
 		if (!(dyn = malloc (bin->phdr[i].p_filesz + 1))) {
 			perror ("malloc (dyn)");
 			return false;
 		}
 		if (r_buf_read_at (bin->b, bin->phdr[i].p_offset, (ut8*)dyn, bin->phdr[i].p_filesz) == -1) {
 			eprintf ("Error: read (dyn)\n");
 			free (dyn);
 			return false;
 		}
 		if ((ndyn = (int)(bin->phdr[i].p_filesz / sizeof (Elf_(Dyn)))) > 0) {
 			for (j = 0; j < ndyn; j++) {
 				if (dyn[j].d_tag == DT_STRTAB) {
 					stroff = (ut64)(dyn[j].d_un.d_ptr - bin->baddr);
 					break;
 				}
 			}
 			for (j = 0; j < ndyn; j++) {
 				if (dyn[j].d_tag == DT_RPATH || dyn[j].d_tag == DT_RUNPATH) {
 					if (r_buf_write_at (bin->b, stroff + dyn[j].d_un.d_val,
 								(ut8*)"", 1) == -1) {
 						eprintf ("Error: write (rpath)\n");
 						free (dyn);
 						return false;
 					}
 				}
 			}
 		}
 		free (dyn);
 		break;
 	}
 	return true;
 }
 
-bool Elf_(r_bin_elf_section_perms)(struct Elf_(r_bin_elf_obj_t) *bin, const char *name, int perms) {
+bool Elf_(r_bin_elf_section_perms)(RBinFile *bf, const char *name, int perms) {
+	struct Elf_(r_bin_elf_obj_t) *bin = bf->o->bin_obj;
 	Elf_(Ehdr) *ehdr = &bin->ehdr;
 	Elf_(Shdr) *shdr = bin->shdr, *shdrp;
 	const char *strtab = bin->shstrtab;
 	int i, patchoff;
 
 	/* calculate delta */
 	for (i = 0, shdrp = shdr; i < ehdr->e_shnum; i++, shdrp++) {
 		const char *shname = &strtab[shdrp->sh_name];
 		int operms = shdrp->sh_flags;
 		if (!strncmp (name, shname, ELF_STRING_LENGTH)) {
 			ut8 newperms = (ut8)operms;
 			// SHF_EXECINSTR
 			if (perms & 1) {
 				R_BIT_SET (&newperms, 2);
 			} else {
 				R_BIT_UNSET (&newperms, 2);
 			}
 			// SHF_WRITE
 			if (perms & 2) {
 				R_BIT_SET (&newperms, 0);
 			} else {
 				R_BIT_UNSET (&newperms, 0);
 			}
 			patchoff = bin->ehdr.e_shoff;
 			patchoff += ((const ut8*)shdrp - (const ut8*)bin->shdr);
 			patchoff += r_offsetof (Elf_(Shdr), sh_flags);
 			printf ("wx %02x @ 0x%x\n", newperms, patchoff);
-			r_buf_write_at (bin->b, patchoff, (ut8*)&newperms, 1);
+			r_buf_write_at (bf->buf, patchoff, (ut8*)&newperms, 1);
 			return true;
 		}
 	}
 	return false;
 }
 
-bool Elf_(r_bin_elf_entry_write)(struct Elf_(r_bin_elf_obj_t) *bin, ut64 addr) {
-	int patchoff = 0x18;
+bool Elf_(r_bin_elf_entry_write)(RBinFile *bf, ut64 addr) {
+	const int patchoff = 0x18;
 #if R_BIN_ELF64
 	printf ("wv8 0x%"PFMT64x" @ 0x%x\n", addr, patchoff);
-	eprintf ("%d\n", r_buf_write_at (bin->b, patchoff, (ut8*)&addr, sizeof (addr)));
+	eprintf ("%d\n", r_buf_write_at (bf->buf, patchoff, (ut8*)&addr, sizeof (addr)));
 #else
 	ut32 addr32 = (ut32)addr;
 	printf ("wv4 0x%x @ 0x%x\n", addr32, patchoff);
-	r_buf_write_at (bin->b, patchoff, (ut8*)&addr32, sizeof (addr32));
+	r_buf_write_at (bf->buf, patchoff, (ut8*)&addr32, sizeof (addr32));
 #endif
 	return true;
 }
diff --git a/libr/bin/format/mach0/fatmach0.c b/libr/bin/format/mach0/fatmach0.c
index 70706d9757..136da3baeb 100644
--- a/libr/bin/format/mach0/fatmach0.c
+++ b/libr/bin/format/mach0/fatmach0.c
@@ -51,54 +51,27 @@ static int r_bin_fatmach0_init(struct r_bin_fatmach0_obj_t* bin) {
 }
 
 struct r_bin_fatmach0_arch_t *r_bin_fatmach0_extract(struct r_bin_fatmach0_obj_t* bin, int idx, int *narch) {
-	struct r_bin_fatmach0_arch_t *ret;
-	ut8 *buf = NULL;
-
 	if (!bin || (idx < 0) || (idx > bin->nfat_arch)) {
 		return NULL;
 	}
 	if (bin->archs[idx].offset > bin->size ||
 		bin->archs[idx].offset + bin->archs[idx].size > bin->size) {
 		return NULL;
 	}
-
 	if (narch) {
 		*narch = bin->nfat_arch;
 	}
-	if (!(ret = R_NEW0 (struct r_bin_fatmach0_arch_t))) {
-		perror ("malloc (ret)");
-		return NULL;
-	}
-	if (!bin->archs[idx].size || bin->archs[idx].size > bin->size) {
-		eprintf ("Skipping corrupted sub-bin %d arch %d\n", idx, bin->archs[idx].size);
-		free (ret);
-		return NULL;
-	}
-	if (!(buf = malloc (1 + bin->archs[idx].size))) {
-		perror ("malloc (buf)");
-		free (ret);
-		return NULL;
-	}
-	if (r_buf_read_at (bin->b, bin->archs[idx].offset, buf, bin->archs[idx].size) != bin->archs[idx].size) {
-		perror ("read (buf)");
-		free (buf);
-		free (ret);
-		return NULL;
-	}
-	if (!(ret->b = r_buf_new ())) {
-		free (buf);
-		free (ret);
-		return NULL;
-	}
-	if (!r_buf_set_bytes (ret->b, buf, bin->archs[idx].size)) {
-		free (buf);
-		r_buf_free (ret->b);
-		free (ret);
-		return NULL;
+	struct r_bin_fatmach0_arch_t *ret = R_NEW0 (struct r_bin_fatmach0_arch_t);
+	if (ret) {
+		ret->size = bin->archs[idx].size;
+		if (!ret->size || ret->size > bin->size) {
+			eprintf ("Skipping corrupted sub-bin %d arch %d\n", idx, bin->archs[idx].size);
+			free (ret);
+			return NULL;
+		}
+		ret->offset = bin->archs[idx].offset;
+		ret->b = r_buf_new_slice (bin->b, ret->offset, ret->size);
 	}
-	free (buf);
-	ret->offset = bin->archs[idx].offset;
-	ret->size = bin->archs[idx].size;
 	return ret;
 }
 
@@ -134,6 +107,19 @@ struct r_bin_fatmach0_obj_t* r_bin_fatmach0_new(const char* file) {
 	return bin;
 }
 
+struct r_bin_fatmach0_obj_t* r_bin_fatmach0_from_buffer_new(RBuffer *b) {
+	r_return_val_if_fail (b, NULL);
+	struct r_bin_fatmach0_obj_t *bo = R_NEW0 (struct r_bin_fatmach0_obj_t);
+	if (bo) {
+		bo->b = r_buf_ref (b);
+		bo->size = r_buf_size (bo->b); // XXX implicit in bo->b
+		if (!r_bin_fatmach0_init (bo)) {
+			return r_bin_fatmach0_free (bo);
+		}
+	}
+	return bo;
+}
+
 struct r_bin_fatmach0_obj_t* r_bin_fatmach0_from_bytes_new(const ut8* buf, ut64 size) {
 	struct r_bin_fatmach0_obj_t *bin = R_NEW0 (struct r_bin_fatmach0_obj_t);
 	if (!bin) {
diff --git a/libr/bin/format/mach0/fatmach0.h b/libr/bin/format/mach0/fatmach0.h
index 829b1230a6..4fda39ec3e 100644
--- a/libr/bin/format/mach0/fatmach0.h
+++ b/libr/bin/format/mach0/fatmach0.h
@@ -1,7 +1,5 @@
-/* radare - LGPL - Copyright 2009-2011 nibble<.ds@gmail.com> */
-
 #include <r_types.h>
 #include "mach0_specs.h"
 
 #ifndef _INCLUDE_R_BIN_FATMACH0_H_
 #define _INCLUDE_R_BIN_FATMACH0_H_
@@ -26,4 +24,5 @@ struct r_bin_fatmach0_arch_t *r_bin_fatmach0_extract(struct r_bin_fatmach0_obj_t
 void* r_bin_fatmach0_free(struct r_bin_fatmach0_obj_t* bin);
 struct r_bin_fatmach0_obj_t* r_bin_fatmach0_new(const char* file);
 struct r_bin_fatmach0_obj_t* r_bin_fatmach0_from_bytes_new(const ut8* buf, ut64 size);
+struct r_bin_fatmach0_obj_t* r_bin_fatmach0_from_buffer_new(RBuffer *b);
 #endif
diff --git a/libr/bin/format/mach0/mach0.c b/libr/bin/format/mach0/mach0.c
index fc744b1da5..bad519bb3f 100644
--- a/libr/bin/format/mach0/mach0.c
+++ b/libr/bin/format/mach0/mach0.c
@@ -2694,213 +2694,224 @@ ut64 MACH0_(get_main)(struct MACH0_(obj_t) *bin) {
 	return addr;
 }
 
-void MACH0_(mach_headerfields)(RBinFile *file) {
-	PrintfCallback cb_printf = file->rbin->cb_printf;
+void MACH0_(mach_headerfields)(RBinFile *bf) {
+	PrintfCallback cb_printf = bf->rbin->cb_printf;
 	if (!cb_printf) {
 		cb_printf = printf;
 	}
-	RBuffer *buf = file->buf;
+	RBuffer *buf = bf->buf;
+	ut64 length = r_buf_size (buf);
 	int n = 0;
-	struct MACH0_(mach_header) *mh = MACH0_(get_hdr_from_bytes)(buf);
+	struct MACH0_(mach_header) *mh = MACH0_(get_hdr_from_buffer)(buf);
 	if (!mh) {
 		return;
 	}
 	cb_printf ("0x00000000  Magic       0x%x\n", mh->magic);
 	cb_printf ("0x00000004  CpuType     0x%x\n", mh->cputype);
 	cb_printf ("0x00000008  CpuSubType  0x%x\n", mh->cpusubtype);
 	cb_printf ("0x0000000c  FileType    0x%x\n", mh->filetype);
 	cb_printf ("0x00000010  nCmds       %d\n", mh->ncmds);
 	cb_printf ("0x00000014  sizeOfCmds  %d\n", mh->sizeofcmds);
 	cb_printf ("0x00000018  Flags       0x%x\n", mh->flags);
 	bool is64 = mh->cputype >> 16;
 
 	ut64 addr = 0x20 - 4;
 	ut32 word = 0;
 	ut8 wordbuf[sizeof (word)];
+	bool isBe = false;
+	switch (mh->cputype) {
+	case CPU_TYPE_POWERPC:
+	case CPU_TYPE_POWERPC64:
+		isBe = true;
+		break;
+	}
 #define READWORD() \
-		if (!r_buf_read_at (buf, addr, (ut8*)wordbuf, 4)) { \
+		if (r_buf_read_at (buf, addr, (ut8*)wordbuf, 4) != 4) { \
 			eprintf ("Invalid address in buffer."); \
 			break; \
 		} \
 		addr += 4; \
-		word = r_read_le32 (wordbuf);
+		word = isBe? r_read_be32 (wordbuf): r_read_le32 (wordbuf);
 	if (is64) {
 		addr += 4;
 	}
 	for (n = 0; n < mh->ncmds; n++) {
 		READWORD ();
 		int lcType = word;
 		cb_printf ("0x%08"PFMT64x"  cmd %7d 0x%x %s\n",
 			addr, n, lcType, cmd_to_string (lcType));
 		READWORD ();
+		if (addr > length) {
+			break;
+		}
 		int lcSize = word;
 		word &= 0xFFFFFF;
 		cb_printf ("0x%08"PFMT64x"  cmdsize     %d\n", addr, word);
 		if (lcSize < 1) {
 			eprintf ("Invalid size for a load command\n");
 			break;
 		}
 		switch (lcType) {
 		case LC_MAIN:
 			{
 				ut8 data[64];
 				r_buf_read_at (buf, addr, data, sizeof (data));
 #if R_BIN_MACH064
 				ut64 ep = r_read_ble64 (&data, false); //  bin->big_endian);
 				cb_printf ("0x%08"PFMT64x"  entry0      0x%" PFMT64x "\n", addr, ep);
 				ut64 ss = r_read_ble64 (&data[8], false); //  bin->big_endian);
 				cb_printf ("0x%08"PFMT64x"  stacksize   0x%" PFMT64x "\n", addr +  8, ss);
 #else
 				ut32 ep = r_read_ble32 (&data, false); //  bin->big_endian);
 				cb_printf ("0x%08"PFMT32x"  entry0      0x%" PFMT32x "\n", (ut32)addr, ep);
 				ut32 ss = r_read_ble32 (&data[4], false); //  bin->big_endian);
 				cb_printf ("0x%08"PFMT32x"  stacksize   0x%" PFMT32x "\n", (ut32)addr +  4, ss);
 #endif
 			}
 			break;
 		case LC_SYMTAB:
 #if 0
 			{
 			char *id = r_buf_get_string (buf, addr + 20);
 			cb_printf ("0x%08"PFMT64x"  id         0x%x\n", addr + 20, id? id: "");
 			cb_printf ("0x%08"PFMT64x"  symooff    0x%x\n", addr + 20, id? id: "");
 			cb_printf ("0x%08"PFMT64x"  nsyms      %d\n", addr + 20, id? id: "");
 			cb_printf ("0x%08"PFMT64x"  stroff     0x%x\n", addr + 20, id? id: "");
 			cb_printf ("0x%08"PFMT64x"  strsize    0x%x\n", addr + 20, id? id: "");
 			free (id);
 			}
 #endif
 			break;
 		case LC_ID_DYLIB: { // install_name_tool
 			char *id = r_buf_get_string (buf, addr + 20);
 			cb_printf ("0x%08"PFMT64x"  id           %s\n",
 				addr + 20, id? id: "");
 			free (id);
 			break;
 		}
 		case LC_UUID:
 			{
 				ut8 i, uuid[16];
 				r_buf_read_at (buf, addr, uuid, sizeof (uuid));
 				cb_printf ("0x%08"PFMT64x"  uuid        ", addr);
 				for (i = 0; i < sizeof (uuid); i++) {
 					cb_printf ("%02x", uuid[i]);
 				}
 				cb_printf ("\n");
 			}
 			break;
 		case LC_SEGMENT:
 		case LC_SEGMENT_64:
 			cb_printf ("pf.mach0_segment @ 0x%08"PFMT64x"\n", addr - 8);
 			{
 				ut8 name[17] = {0};
 				r_buf_read_at (buf, addr, name, sizeof (name) - 1);
 				cb_printf ("0x%08"PFMT64x"  name        %s\n", addr, name);
 			}
 			break;
 		case LC_LOAD_DYLIB:
 		case LC_LOAD_WEAK_DYLIB: {
 			char *load_dylib = r_buf_get_string (buf, addr + 16);
 			cb_printf ("0x%08"PFMT64x"  load_dylib  %s\n",
 				addr + 16, load_dylib? load_dylib: "");
 			free (load_dylib);
 			break;
 		}
 		case LC_RPATH: {
 			char *rpath = r_buf_get_string (buf, addr + 4);
 			cb_printf ("0x%08" PFMT64x "  rpath       %s\n",
 				addr + 4, rpath ? rpath : "");
 			free (rpath);
 			break;
 		}
 		case LC_CODE_SIGNATURE:
 			{
 			ut32 words[2];
 			r_buf_read_at (buf, addr, (ut8 *)words, sizeof (words));
 			cb_printf ("0x%08"PFMT64x"  dataoff     0x%08x\n", addr, words[0]);
 			cb_printf ("0x%08"PFMT64x"  datasize    %d\n", addr + 4, words[1]);
 			cb_printf ("# wtf mach0.sign %d @ 0x%x\n", words[1], words[0]);
 			}
 			break;
 		}
 		addr += word - 8;
 	}
 	free (mh);
 }
 
 RList *MACH0_(mach_fields)(RBinFile *bf) {
-	struct MACH0_(mach_header) *mh = MACH0_(get_hdr_from_bytes)(bf->buf);
+	struct MACH0_(mach_header) *mh = MACH0_(get_hdr_from_buffer)(bf->buf);
 	if (!mh) {
 		return NULL;
 	}
 	RList *ret = r_list_new ();
 	if (!ret) {
 		free (mh);
 		return NULL;
 	}
 	ret->free = free;
 	ut64 addr = 0;
 
 #define ROW(nam,siz,val,fmt) \
 	r_list_append (ret, r_bin_field_new (addr, addr, siz, nam, sdb_fmt ("0x%08x", val), fmt)); \
 	addr += 4;
 	ROW ("macho_magic", 4, mh->magic, "x");
 	ROW ("macho_cputype", 4, mh->cputype, "x");
 	ROW ("macho_cpusubtype", 4, mh->cpusubtype, "x");
 	ROW ("macho_filetype", 4, mh->filetype, "x");
 	ROW ("macho_nbcmds", 4, mh->ncmds, "x");
 	ROW ("macho_sizeofcmds", 4, mh->sizeofcmds, "x");
 	free (mh);
 	return ret;
 }
 
-struct MACH0_(mach_header) *MACH0_(get_hdr_from_bytes)(RBuffer *buf) {
+struct MACH0_(mach_header) *MACH0_(get_hdr_from_buffer)(RBuffer *buf) {
 	ut8 magicbytes[sizeof (ut32)] = {0};
 	ut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};
 	int len;
 	struct MACH0_(mach_header) *macho_hdr = R_NEW0 (struct MACH0_(mach_header));
 	bool big_endian = false;
 	if (!macho_hdr) {
 		return NULL;
 	}
 	if (r_buf_read_at (buf, 0, magicbytes, 4) < 1) {
 		free (macho_hdr);
 		return false;
 	}
 
 	if (r_read_le32 (magicbytes) == 0xfeedface) {
 		big_endian = false;
 	} else if (r_read_be32 (magicbytes) == 0xfeedface) {
 		big_endian = true;
 	} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {
 		big_endian = false;
 	} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {
 		big_endian = true;
 	} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {
 		big_endian = false;
 	} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {
 		big_endian = true;
 	} else {
 		/* also extract non-mach0s */
 #if 0
 		free (macho_hdr);
 		return NULL;
 #endif
 	}
 	len = r_buf_read_at (buf, 0, machohdrbytes, sizeof (machohdrbytes));
 	if (len != sizeof (struct MACH0_(mach_header))) {
 		free (macho_hdr);
 		return NULL;
 	}
 	macho_hdr->magic = r_read_ble (&machohdrbytes[0], big_endian, 32);
 	macho_hdr->cputype = r_read_ble (&machohdrbytes[4], big_endian, 32);
 	macho_hdr->cpusubtype = r_read_ble (&machohdrbytes[8], big_endian, 32);
 	macho_hdr->filetype = r_read_ble (&machohdrbytes[12], big_endian, 32);
 	macho_hdr->ncmds = r_read_ble (&machohdrbytes[16], big_endian, 32);
 	macho_hdr->sizeofcmds = r_read_ble (&machohdrbytes[20], big_endian, 32);
 	macho_hdr->flags = r_read_ble (&machohdrbytes[24], big_endian, 32);
 #if R_BIN_MACH064
 	macho_hdr->reserved = r_read_ble (&machohdrbytes[28], big_endian, 32);
 #endif
 	return macho_hdr;
 }
diff --git a/libr/bin/format/mach0/mach0.h b/libr/bin/format/mach0/mach0.h
index 487234a0f0..a08b4a3229 100644
--- a/libr/bin/format/mach0/mach0.h
+++ b/libr/bin/format/mach0/mach0.h
@@ -194,7 +194,7 @@ char *MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr);
 ut64 MACH0_(get_main)(struct MACH0_(obj_t) *bin);
 const char *MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) *hdr);
 int MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header) *hdr);
-struct MACH0_(mach_header) *MACH0_(get_hdr_from_bytes)(RBuffer *buf);
+struct MACH0_(mach_header) *MACH0_(get_hdr_from_buffer)(RBuffer *buf);
 void MACH0_(mach_headerfields)(RBinFile *bf);
 RList *MACH0_(mach_fields)(RBinFile *bf);
 #endif
diff --git a/libr/bin/format/mach0/mach064_is_kernelcache.c b/libr/bin/format/mach0/mach064_is_kernelcache.c
index 324dccb1e1..e74dfcb39b 100644
--- a/libr/bin/format/mach0/mach064_is_kernelcache.c
+++ b/libr/bin/format/mach0/mach064_is_kernelcache.c
@@ -1,49 +1,97 @@
 static bool is_kernelcache(const ut8 *buf, ut64 length) {
+	// XXX deprecate this method
 	if (length < sizeof (struct MACH0_(mach_header))) {
 		return false;
 	}
 	ut32 cputype = r_read_le32 (buf + 4);
 	if (cputype != CPU_TYPE_ARM64) {
 		return false;
 	}
 
 	const ut8 *end = buf + length;
 	const ut8 *cursor = buf + sizeof (struct MACH0_(mach_header));
 	int i, ncmds = r_read_le32 (buf + 16);
 	bool has_unixthread = false;
 	bool has_negative_vaddr = false;
 
 	for (i = 0; i < ncmds; i++) {
 		if (cursor >= end) {
 			return false;
 		}
 
 		ut32 cmdtype = r_read_le32 (cursor);
 		ut32 cmdsize = r_read_le32 (cursor + 4);
 
 		switch (cmdtype) {
 		case LC_UNIXTHREAD:
 			has_unixthread = true;
 			break;
 		case LC_LOAD_DYLIB:
 		case LC_LOAD_WEAK_DYLIB:
 		case LC_LAZY_LOAD_DYLIB:
 			return false;
 		case LC_SEGMENT_64:
 			{
 				if (has_negative_vaddr) {
 					break;
 				}
 				st64 vmaddr = r_read_le64 (cursor + 24);
 				if (vmaddr < 0) {
 					has_negative_vaddr = true;
 				}
 			}
 			break;
 		}
 
 		cursor += cmdsize;
 	}
 
 	return has_unixthread && has_negative_vaddr;
 }
+
+static bool is_kernelcache_buffer(RBuffer *b) {
+	ut64 length = r_buf_size (b);
+	if (length < sizeof (struct MACH0_(mach_header))) {
+		return false;
+	}
+	ut32 cputype = r_buf_read_le32_at (b, 4);
+	if (cputype != CPU_TYPE_ARM64) {
+		return false;
+	}
+
+	int i, ncmds = r_buf_read_le32_at (b, 16);
+	bool has_unixthread = false;
+	bool has_negative_vaddr = false;
+
+	ut32 cursor = sizeof (struct MACH0_(mach_header));
+	for (i = 0; i < ncmds && cursor < length; i++) {
+
+		ut32 cmdtype = r_buf_read_le32_at (b, cursor);
+		ut32 cmdsize = r_buf_read_le32_at (b, cursor + 4);
+
+		switch (cmdtype) {
+		case LC_UNIXTHREAD:
+			has_unixthread = true;
+			break;
+		case LC_LOAD_DYLIB:
+		case LC_LOAD_WEAK_DYLIB:
+		case LC_LAZY_LOAD_DYLIB:
+			return false;
+		case LC_SEGMENT_64:
+			{
+				if (has_negative_vaddr) {
+					break;
+				}
+				st64 vmaddr = r_buf_read_le64_at (b, cursor + 24);
+				if (vmaddr < 0) {
+					has_negative_vaddr = true;
+				}
+			}
+			break;
+		}
+
+		cursor += cmdsize;
+	}
+
+	return has_unixthread && has_negative_vaddr;
+}
diff --git a/libr/bin/format/mz/mz.c b/libr/bin/format/mz/mz.c
index 134bb2b4b6..913e024993 100644
--- a/libr/bin/format/mz/mz.c
+++ b/libr/bin/format/mz/mz.c
@@ -268,14 +268,14 @@ static int r_bin_mz_init_hdr(struct r_bin_mz_obj_t *bin) {
 	return true;
 }
 
-static int r_bin_mz_init(struct r_bin_mz_obj_t *bin) {
+static bool r_bin_mz_init(struct r_bin_mz_obj_t *bin) {
 	bin->dos_header = NULL;
 	bin->dos_extended_header = NULL;
 	bin->relocation_entries = NULL;
 	bin->kv = sdb_new0 ();
 	if (!r_bin_mz_init_hdr (bin)) {
 		eprintf ("Warning: File is not MZ\n");
 		return false;
 	}
 	return true;
 }
diff --git a/libr/bin/format/pe/pe.h b/libr/bin/format/pe/pe.h
index 6b9cbdaedb..3ee1589ff5 100644
--- a/libr/bin/format/pe/pe.h
+++ b/libr/bin/format/pe/pe.h
@@ -159,5 +159,5 @@ void PE_(r_bin_pe_check_sections)(struct PE_(r_bin_pe_obj_t)* bin, struct r_bin_
 struct r_bin_pe_addr_t *PE_(check_unknow) (struct PE_(r_bin_pe_obj_t) *bin);
 struct r_bin_pe_addr_t *PE_(check_msvcseh) (struct PE_(r_bin_pe_obj_t) *bin);
 struct r_bin_pe_addr_t *PE_(check_mingw) (struct PE_(r_bin_pe_obj_t) *bin);
-bool PE_(r_bin_pe_section_perms)(struct PE_(r_bin_pe_obj_t) *bin, const char *name, int perms);
+bool PE_(r_bin_pe_section_perms)(RBinFile *bf, const char *name, int perms);
 R_API void PE_(bin_pe_parse_resource) (struct PE_(r_bin_pe_obj_t) *bin);
diff --git a/libr/bin/format/pe/pe_write.c b/libr/bin/format/pe/pe_write.c
index b15c45eae0..40d054f2a4 100644
--- a/libr/bin/format/pe/pe_write.c
+++ b/libr/bin/format/pe/pe_write.c
@@ -1,54 +1,58 @@
-/* radare - LGPL - Copyright 2010-2018 pancake, nibble */
+/* radare - LGPL - Copyright 2010-2019 pancake, nibble */
 
 #include <r_types.h>
 #include <r_util.h>
 #include "pe.h"
 
-bool PE_(r_bin_pe_section_perms)(struct PE_(r_bin_pe_obj_t) *bin, const char *name, int perms) {
-	PE_(image_section_header) *shdr = bin->section_header;
+// bool PE_(r_bin_pe_section_perms)(struct PE_(r_bin_pe_obj_t) *bin, const char *name, int perms) {
+bool PE_(r_bin_pe_section_perms)(RBinFile *bf, const char *name, int perms) {
+	struct PE_(r_bin_pe_obj_t) *pe = bf->o->bin_obj;
+	PE_(image_section_header) *shdr = pe->section_header;
 	int i;
 
 	if (!shdr) {
 		return false;
 	}
 
-	for (i = 0; i < bin->num_sections; i++) {
+	for (i = 0; i < pe->num_sections; i++) {
 		const char *sname = (const char*) shdr[i].Name;
 		if (!strncmp (name, sname, PE_IMAGE_SIZEOF_SHORT_NAME)) {
-			int patchoff;
 			ut32 newperms = shdr[i].Characteristics;
 			ut32 newperms_le;
 
 			/* Apply permission flags */
 			if (perms & R_PERM_X) {
 				newperms |=  PE_IMAGE_SCN_MEM_EXECUTE;
 			} else {
 				newperms &= ~PE_IMAGE_SCN_MEM_EXECUTE;
 			}
 			if (perms & R_PERM_W) {
 				newperms |=  PE_IMAGE_SCN_MEM_WRITE;
 			} else {
 				newperms &= ~PE_IMAGE_SCN_MEM_WRITE;
 			}
 			if (perms & R_PERM_R) {
 				newperms |=  PE_IMAGE_SCN_MEM_READ;
 			} else {
 				newperms &= ~PE_IMAGE_SCN_MEM_READ;
 			}
 			if (perms & R_PERM_SHAR) {
 				newperms |=  PE_IMAGE_SCN_MEM_SHARED;
 			} else {
 				newperms &= ~PE_IMAGE_SCN_MEM_SHARED;
 			}
 
-			patchoff = bin->section_header_offset;
+			int patchoff = pe->section_header_offset;
 			patchoff += i * sizeof (PE_(image_section_header));
 			patchoff += r_offsetof (PE_(image_section_header), Characteristics);
 			r_write_le32 (&newperms_le, newperms);
 			printf ("wx %02x @ 0x%x\n", newperms_le, patchoff);
-			r_buf_write_at (bin->b, patchoff, (ut8*)&newperms_le, sizeof (newperms_le));
+			int res = r_buf_write_at (bf->buf, patchoff, (ut8*)&newperms_le, sizeof (newperms_le));
+			if (res != sizeof (newperms_le)) {
+				return false;
+			}
 			return true;
 		}
 	}
 	return false;
 }
diff --git a/libr/bin/i/private.h b/libr/bin/i/private.h
index ac28c5c11d..a49de8aa1c 100644
--- a/libr/bin/i/private.h
+++ b/libr/bin/i/private.h
@@ -5,8 +5,7 @@
 #include <r_util.h>
 #include <r_types.h>
 
-R_IPI RBinFile *r_bin_file_new(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, int fd, const char *xtrname, Sdb *sdb, bool steal_ptr);
-R_IPI RBinFile *r_bin_file_new_from_bytes(RBin *bin, const char *file, const ut8 *bytes, ut64 sz, ut64 file_sz, int rawstr, ut64 baseaddr, ut64 loadaddr, int fd, const char *pluginname, ut64 offset);
+R_IPI RBinFile *r_bin_file_new(RBin *bin, const char *file, ut64 file_sz, int rawstr, int fd, const char *xtrname, Sdb *sdb, bool steal_ptr);
 R_IPI RBinObject *r_bin_file_object_find_by_id(RBinFile *binfile, ut32 binobj_id);
 R_IPI RList *r_bin_file_get_strings(RBinFile *a, int min, int dump, int raw);
 R_IPI RBinFile *r_bin_file_find_by_object_id(RBin *bin, ut32 binobj_id);
diff --git a/libr/bin/obj.c b/libr/bin/obj.c
index 0a90b552b3..bc91a7cc41 100644
--- a/libr/bin/obj.c
+++ b/libr/bin/obj.c
@@ -1,13 +1,9 @@
-/* radare2 - LGPL - Copyright 2009-2018 - pancake, nibble, dso */
+/* radare2 - LGPL - Copyright 2009-2019 - pancake, nibble, dso */
 
 #include <r_bin.h>
 #include <r_util.h>
 #include "i/private.h"
 
-#define bprintf                     \
-	if (binfile->rbin->verbose) \
-	eprintf
-
 static void mem_free(void *data) {
 	RBinMem *mem = (RBinMem *)data;
 	if (mem && mem->mirrors) {
@@ -100,146 +96,169 @@ static char *swiftField(const char *dn, const char *cn) {
 static RList *classes_from_symbols(RBinFile *bf) {
 	RBinObject *o = bf->o;
 	RBinSymbol *sym;
 	RListIter *iter;
 	RList *symbols = o->symbols;
 	RList *classes = o->classes;
 	if (!classes) {
 		classes = r_list_newf ((RListFree)r_bin_class_free);
 	}
 	r_list_foreach (symbols, iter, sym) {
 		if (sym->name[0] != '_') {
 			continue;
 		}
 		const char *cn = sym->classname;
 		if (cn) {
 			RBinClass *c = r_bin_class_new (bf, sym->classname, NULL, 0);
 			if (!c) {
 				continue;
 			}
 			// swift specific
 			char *dn = sym->dname;
 			char *fn = swiftField (dn, cn);
 			if (fn) {
 				// eprintf ("FIELD %s  %s\n", cn, fn);
 				RBinField *f = r_bin_field_new (sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL);
 				r_list_append (c->fields, f);
 				free (fn);
 			} else {
 				char *mn = strstr (dn, "..");
-				if (mn) {
-					// eprintf ("META %s  %s\n", sym->classname, mn);
-				} else {
-					char *mn = strstr (dn, cn);
+				if (!mn) {
+					mn = strstr (dn, cn);
 					if (mn && mn[strlen (cn)] == '.') {
 						mn += strlen (cn) + 1;
 						// eprintf ("METHOD %s  %s\n", sym->classname, mn);
 						r_list_append (c->methods, sym);
 					}
 				}
 			}
 		}
 	}
 	if (r_list_empty (classes)) {
 		r_list_free (classes);
 		return NULL;
 	}
 	return classes;
 }
 
-static bool file_object_add(RBinFile *binfile, RBinObject *o) {
-	r_return_val_if_fail (binfile && o, false);
-	r_list_append (binfile->objs, o);
-	r_bin_file_set_cur_binfile_obj (binfile->rbin, binfile, o);
-	return true;
-}
-
-R_IPI RBinObject *r_bin_object_new(RBinFile *binfile, RBinPlugin *plugin, ut64 baseaddr, ut64 loadaddr, ut64 offset, ut64 sz) {
-	r_return_val_if_fail (binfile && plugin, NULL);
-
-	ut64 bytes_sz = r_buf_size (binfile->buf);
-	Sdb *sdb = binfile->sdb;
+// TODO: kill offset and sz, because those should be infered from binfile->buf
+R_IPI RBinObject *r_bin_object_new(RBinFile *bf, RBinPlugin *plugin, ut64 baseaddr, ut64 loadaddr, ut64 offset, ut64 sz) {
+	r_return_val_if_fail (bf && plugin, NULL);
+	ut64 bytes_sz = r_buf_size (bf->buf);
+	Sdb *sdb = bf->sdb;
 	RBinObject *o = R_NEW0 (RBinObject);
 	if (!o) {
 		return NULL;
 	}
 	o->obj_size = (bytes_sz >= sz + offset)? sz: 0;
 	o->boffset = offset;
 	o->strings_db = ht_up_new0 ();
 	o->regstate = NULL;
-	if (!r_id_pool_grab_id (binfile->rbin->ids->pool, &o->id)) {
+	if (!r_id_pool_grab_id (bf->rbin->ids->pool, &o->id)) {
 		free (o);
 		eprintf ("Cannot grab an id\n");
 		return NULL;
 	}
 	o->kv = sdb_new0 ();
 	o->baddr = baseaddr;
 	o->baddr_shift = 0;
 	o->plugin = plugin;
 	o->loadaddr = loadaddr != UT64_MAX ? loadaddr : 0;
 
 	if (plugin && plugin->load_buffer) {
-		o->bin_obj = plugin->load_buffer (binfile, binfile->buf, loadaddr, sdb); // bytes + offset, sz, loadaddr, sdb);
-		if (!o->bin_obj) {
-			bprintf ("Error in r_bin_object_new: load_bytes failed for %s plugin\n", plugin->name);
+		if (!plugin->load_buffer (bf, &o->bin_obj, bf->buf, loadaddr, sdb)) {
+			if (bf->rbin->verbose) {
+				eprintf ("Error in r_bin_object_new: load_buffer failed for %s plugin\n", plugin->name);
+			}
 			sdb_free (o->kv);
 			free (o);
 			return NULL;
 		}
 	} else if (plugin && plugin->load_bytes && (bytes_sz >= sz + offset)) {
+		// DEPRECATE
 		R_LOG_WARN ("Plugin %s should implement load_buffer method instead of load_bytes.\n", plugin->name);
 		// XXX more checking will be needed here
 		// only use LoadBytes if buffer offset != 0
 		// if (offset != 0 && bytes && plugin && plugin->load_bytes && (bytes_sz
 		// >= sz + offset) ) {
 		ut64 bsz = bytes_sz - offset;
 		if (sz < bsz) {
 			bsz = sz;
 		}
 		ut8 *bytes = malloc (sz);
 		if (!bytes) {
 			eprintf ("Cannot allocate %" PFMT64u " bytes\n", sz);
 			free (o);
 			return NULL;
 		}
-		r_buf_read_at (binfile->buf, offset, bytes, sz);
-		if (!plugin->load_bytes (binfile, &o->bin_obj, bytes, sz,
-					 loadaddr, sdb)) {
-			bprintf ("Error in r_bin_object_new: load_bytes failed for %s plugin\n", plugin->name);
+		r_buf_read_at (bf->buf, offset, bytes, sz);
+		// TODO: use r_buf_data meanwhile.. meh just kill it with fire
+		if (!plugin->load_bytes (bf, &o->bin_obj, bytes, sz, loadaddr, sdb)) {
+			if (bf->rbin->verbose) {
+				eprintf ("Error in r_bin_object_new: load_bytes failed for %s plugin\n", plugin->name);
+			}
 			sdb_free (o->kv);
 			free (bytes);
 			free (o);
 			return NULL;
 		}
 		free (bytes);
 	} else if (plugin->load) {
+		// DEPRECATE
 		R_LOG_WARN ("Plugin %s should implement load_buffer method instead of load.\n", plugin->name);
 		// XXX - haha, this is a hack.
 		// switching out the current object for the new
 		// one to be processed
-		RBinObject *old_o = binfile->o;
-		binfile->o = o;
-		if (plugin->load (binfile)) {
-			binfile->sdb_info = o->kv;
+		RBinObject *old_o = bf->o;
+		bf->o = o;
+		if (plugin->load (bf)) {
+			//bf->sdb_info = o->kv;
 			// mark as do not walk
-			sdb_ns_set (binfile->sdb, "info", o->kv);
+			//sdb_ns_set (bf->sdb, "info", o->kv);
 		} else {
-			binfile->o = old_o;
+			bf->o = old_o;
 		}
 		o->obj_size = sz;
 	} else {
 		R_LOG_WARN ("Plugin %s should implement load_buffer method.\n", plugin->name);
 		sdb_free (o->kv);
 		free (o);
 		return NULL;
 	}
 
 	// XXX - object size cant be set here and needs to be set where where
 	// the object is created from. The reason for this is to prevent
 	// mis-reporting when the file is loaded from impartial bytes or is
 	// extracted from a set of bytes in the file
-	r_bin_object_set_items (binfile, o);
-	file_object_add (binfile, o);
-
+	r_bin_object_set_items (bf, o);
+	r_list_append (bf->objs, o);
+	r_bin_file_set_cur_binfile_obj (bf->rbin, bf, o);
+
+	bf->sdb_info = o->kv;
+	sdb = bf->rbin->sdb;
+	if (sdb) {
+		Sdb *okv = o->kv;
+		Sdb *bdb = bf->sdb; // sdb_new0 ();
+		sdb_ns_set (bdb, "info", o->kv);
+		sdb_ns_set (bdb, "addrinfo", bf->sdb_addrinfo);
+		o->kv = bdb;
+		// bf->sdb = o->kv;
+		// bf->sdb_info = o->kv;
+		// sdb_ns_set (bf->sdb, "info", o->kv);
+		//sdb_ns (sdb, sdb_fmt ("fd.%d", bf->fd), 1);
+		sdb_set (bf->sdb, "archs", "0:0:x86:32", 0); // x86??
+		/* NOTE */
+		/* Those refs++ are necessary because sdb_ns() doesnt rerefs all
+		 * sub-namespaces */
+		/* And if any namespace is referenced backwards it gets
+		 * double-freed */
+		// bf->sdb_info = sdb_ns (bf->sdb, "info", 1);
+	//	bf->sdb_addrinfo = sdb_ns (bf->sdb, "addrinfo", 1);
+	//	bf->sdb_addrinfo->refs++;
+		sdb_ns_set (sdb, "cur", bdb); // bf->sdb);
+		const char *fdns = sdb_fmt ("fd.%d", bf->fd);
+		sdb_ns_set (sdb, fdns, bdb); // bf->sdb);
+		bf->sdb->refs++;
+	}
 	return o;
 }
 
diff --git a/libr/bin/p/bin_any.c b/libr/bin/p/bin_any.c
index 640563f778..0b1d2ae8a3 100644
--- a/libr/bin/p/bin_any.c
+++ b/libr/bin/p/bin_any.c
@@ -1,64 +1,61 @@
-/* radare - LGPL - Copyright 2009-2017 - pancake, nibble */
+/* radare - LGPL - Copyright 2009-2019 - pancake, nibble */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include <r_magic.h>
 
-static char *get_filetype(RBuffer *obj) {
+static char *get_filetype(RBuffer *b) {
 	ut8 buf[4096] = { 0 };
 	char *res = NULL;
 	RMagic *ck = r_magic_new (0);
 	if (!ck) {
 		return NULL;
 	}
-
 	const char *tmp = NULL;
 	// TODO: dir.magic not honored here
 	r_magic_load (ck, R2_SDB_MAGIC);
-	r_buf_read_at (obj, 0, buf, sizeof (buf));
+	r_buf_read_at (b, 0, buf, sizeof (buf));
 	tmp = r_magic_buffer (ck, buf, sizeof (buf));
 	if (tmp) {
 		res = strdup (tmp);
 	}
 	r_magic_free (ck);
 	return res;
 }
 
 static RBinInfo *info(RBinFile *bf) {
-	RBuffer *any_obj = bf->o->bin_obj;
 	RBinInfo *ret = R_NEW0 (RBinInfo);
 	if (!ret) {
 		return NULL;
 	}
 	ret->lang = "";
 	ret->file = bf->file? strdup (bf->file): NULL;
-	ret->type = get_filetype (any_obj);
+	ret->type = get_filetype (bf->buf);
 	ret->has_pi = 0;
 	ret->has_canary = 0;
 	ret->has_retguard = -1;
 	if (R_SYS_BITS & R_SYS_BITS_64) {
 		ret->bits = 64;
 	} else {
 		ret->bits = 32;
 	}
 	ret->big_endian = 0;
 	ret->has_va = 0;
 	ret->has_nx = 0;
 	ret->dbg_info = 0;
 	ret->dbg_info = 0;
 	ret->dbg_info = 0;
 	return ret;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	return r_buf_ref (buf);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	return true;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_buf_free (bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
diff --git a/libr/bin/p/bin_art.c b/libr/bin/p/bin_art.c
index e6a17f363e..cf7462770e 100644
--- a/libr/bin/p/bin_art.c
+++ b/libr/bin/p/bin_art.c
@@ -65,27 +65,25 @@ static Sdb *get_sdb(RBinFile *bf) {
 	return ao? ao->kv: NULL;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	ArtObj *ao = R_NEW0 (ArtObj);
-	if (!ao) {
-		return NULL;
-	}
-	ao->kv = sdb_new0 ();
-	if (!ao->kv) {
-		free (ao);
-		return NULL;
+	if (ao) {
+		ao->kv = sdb_new0 ();
+		if (ao->kv) {
+			ao->buf = r_buf_ref (buf);
+			art_header_load (ao, ao->kv);
+			sdb_ns_set (sdb, "info", ao->kv);
+			*bin_obj = ao;
+			return true;
+		}
 	}
-	ao->buf = r_buf_ref (buf);
-	art_header_load (ao, ao->kv);
-	sdb_ns_set (sdb, "info", ao->kv);
-	return ao;
+	return false;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	ArtObj *obj = bf->o->bin_obj;
 	r_buf_free (obj->buf);
 	free (obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -98,34 +96,30 @@ static RList *strings(RBinFile *bf) {
 }
 
 static RBinInfo *info(RBinFile *bf) {
-	ArtObj *ao;
-	RBinInfo *ret;
-	if (!bf || !bf->o || !bf->o->bin_obj) {
-		return NULL;
-	}
-	ret = R_NEW0 (RBinInfo);
+	r_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);
+	RBinInfo *ret = R_NEW0 (RBinInfo);
 	if (!ret) {
 		return NULL;
 	}
-	ao = bf->o->bin_obj;
+	ArtObj *ao = bf->o->bin_obj;
 	ret->lang = NULL;
 	ret->file = bf->file? strdup (bf->file): NULL;
 	ret->type = strdup ("ART");
 
 	ret->bclass = malloc (5);
 	memcpy (ret->bclass, &ao->art.version, 4);
 	ret->bclass[3] = 0;
 
 	ret->rclass = strdup ("program");
 	ret->os = strdup ("android");
 	ret->subsystem = strdup ("unknown");
 	ret->machine = strdup ("arm");
 	ret->arch = strdup ("arm");
 	ret->has_va = 1;
 	ret->has_lit = true;
 	ret->has_pi = ao->art.compile_pic;
 	ret->bits = 16; // 32? 64?
 	ret->big_endian = 0;
 	ret->dbg_info = 0;
 	return ret;
 }
diff --git a/libr/bin/p/bin_avr.c b/libr/bin/p/bin_avr.c
index 3cb78d8cba..a77fa84b0d 100644
--- a/libr/bin/p/bin_avr.c
+++ b/libr/bin/p/bin_avr.c
@@ -76,17 +76,12 @@ static bool check_bytes(const ut8 *b, ut64 length) {
 	return res;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	RBuffer *obj = r_buf_ref (buf);
-	if (!check_buffer (obj)) {
-		return NULL;
-	}
-	return obj;
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	return check_buffer (buf);
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_buf_free (bf->o->bin_obj);
-	return true;
 }
 
 static RBinInfo* info(RBinFile *bf) {
diff --git a/libr/bin/p/bin_bf.c b/libr/bin/p/bin_bf.c
index b109cdd29c..b7567f1cda 100644
--- a/libr/bin/p/bin_bf.c
+++ b/libr/bin/p/bin_bf.c
@@ -1,17 +1,16 @@
-/* radare - LGPL - Copyright 2013-2018 - pancake */
+/* radare - LGPL - Copyright 2013-2019 - pancake */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	return r_buf_ref (buf);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	return true;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_buf_free (bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -93,13 +92,6 @@ static bool check_buffer(RBuffer *buf) {
 	return true;
 }
 
-static bool check_bytes(const ut8 *b, ut64 length) {
-	RBuffer *buf = r_buf_new_with_bytes (b, length);
-	bool res = check_buffer (buf);
-	r_buf_free (buf);
-	return res;
-}
-
 static RList *entries(RBinFile *bf) {
 	RList *ret;
 	RBinAddr *ptr = NULL;
@@ -118,15 +110,14 @@ static RList *entries(RBinFile *bf) {
 RBinPlugin r_bin_plugin_bf = {
 	.name = "bf",
 	.desc = "brainfuck",
 	.license = "LGPL3",
 	.load_buffer = &load_buffer,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
 	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.entries = entries,
 	.strings = &strings,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_bflt.c b/libr/bin/p/bin_bflt.c
index 69628d1f76..4831f1a3dc 100644
--- a/libr/bin/p/bin_bflt.c
+++ b/libr/bin/p/bin_bflt.c
@@ -1,14 +1,15 @@
-/* radare - LGPL - Copyright 2016-2017 - Oscar Salvador */
+/* radare - LGPL - Copyright 2016-2019 - Oscar Salvador */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include <r_io.h>
 #include "bflt/bflt.h"
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	return r_bin_bflt_new_buf (buf);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	*bin_obj = r_bin_bflt_new_buf (buf);
+	return *bin_obj;
 }
 
 static RList *entries(RBinFile *bf) {
@@ -296,9 +297,8 @@ static bool check_bytes(const ut8 *buf, ut64 length) {
 	return res;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_bin_bflt_free (bf->o->bin_obj);
-	return true;
 }
 
 RBinPlugin r_bin_plugin_bflt = {
diff --git a/libr/bin/p/bin_bios.c b/libr/bin/p/bin_bios.c
index 095bf1d013..ff94782bbe 100644
--- a/libr/bin/p/bin_bios.c
+++ b/libr/bin/p/bin_bios.c
@@ -1,7 +1,7 @@
-/* radare - LGPL - Copyright 2013-2018 - pancake */
+/* radare - LGPL - Copyright 2013-2019 - pancake */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include "../i/private.h"
@@ -33,25 +33,12 @@ static bool check_buffer(RBuffer *buf) {
 	return bep == 0xea || bep == 0xe9;
 }
 
-static bool check_bytes(const ut8 *b, ut64 length) {
-	RBuffer *buf = r_buf_new_with_bytes (b, length);
-	bool res = check_buffer (buf);
-	r_buf_free (buf);
-	return res;
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	return check_buffer (buf);
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	RBuffer *obj = r_buf_ref (buf);
-	if (!check_buffer (obj)) {
-		r_buf_free (obj);
-		return NULL;
-	}
-	return obj;
-}
-
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_buf_free (bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -87,34 +74,34 @@ static RBinInfo *info(RBinFile *bf) {
 static RList *sections(RBinFile *bf) {
 	RList *ret = NULL;
 	RBinSection *ptr = NULL;
 	RBuffer *obj = bf->o->bin_obj;
 
 	if (!(ret = r_list_newf ((RListFree) r_bin_section_free))) {
 		return NULL;
 	}
 	// program headers is another section
 	if (!(ptr = R_NEW0 (RBinSection))) {
 		return ret;
 	}
 	ptr->name = strdup ("bootblk"); // Maps to 0xF000:0000 segment
 	ptr->vsize = ptr->size = 0x10000;
-	ptr->paddr = r_buf_size (obj) - ptr->size;
+	ptr->paddr = r_buf_size (bf->buf) - ptr->size;
 	ptr->vaddr = 0xf0000;
 	ptr->perm = R_PERM_RWX;
 	ptr->add = true;
 	r_list_append (ret, ptr);
 	// If image bigger than 128K - add one more section
 	if (bf->size >= 0x20000) {
 		if (!(ptr = R_NEW0 (RBinSection))) {
 			return ret;
 		}
 		ptr->name = strdup ("_e000"); // Maps to 0xE000:0000 segment
 		ptr->vsize = ptr->size = 0x10000;
 		ptr->paddr = r_buf_size (obj) - 2 * ptr->size;
 		ptr->vaddr = 0xe0000;
 		ptr->perm = R_PERM_RWX;
 		ptr->add = true;
 		r_list_append (ret, ptr);
 	}
 	return ret;
 }
@@ -138,16 +125,15 @@ static RList *entries(RBinFile *bf) {
 RBinPlugin r_bin_plugin_bios = {
 	.name = "bios",
 	.desc = "BIOS bin plugin",
 	.license = "LGPL",
 	.load_buffer = &load_buffer,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
 	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.entries = entries,
 	.sections = sections,
 	.strings = &strings,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_bootimg.c b/libr/bin/p/bin_bootimg.c
index 10be1b3fbc..1c3e7e2b9e 100644
--- a/libr/bin/p/bin_bootimg.c
+++ b/libr/bin/p/bin_bootimg.c
@@ -84,30 +84,30 @@ static Sdb *get_sdb(RBinFile *bf) {
 	return ao? ao->kv: NULL;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	BootImageObj *bio = R_NEW0 (BootImageObj);
 	if (!bio) {
-		return NULL;
+		return false;
 	}
 	bio->kv = sdb_new0 ();
 	if (!bio->kv) {
 		free (bio);
 		return false;
 	}
 	bio->buf = r_buf_ref (buf);
 	if (!bootimg_header_load (bio, bio->kv)) {
 		free (bio);
 		return false;
 	}
 	sdb_ns_set (sdb, "info", bio->kv);
-	return bio;
+	*bin_obj = bio;
+	return true;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	BootImageObj *bio = bf->o->bin_obj;
 	r_buf_free (bio->buf);
 	R_FREE (bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
diff --git a/libr/bin/p/bin_coff.c b/libr/bin/p/bin_coff.c
index 477d12819a..62d988ee31 100644
--- a/libr/bin/p/bin_coff.c
+++ b/libr/bin/p/bin_coff.c
@@ -1,8 +1,8 @@
-/* radare - LGPL - Copyright 2014-2017 - Fedor Sakharov */
+/* radare - LGPL - Copyright 2014-2019 - Fedor Sakharov */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 
 #include "coff/coff.h"
@@ -24,13 +24,13 @@ static bool r_coff_is_stripped(struct r_bin_coff_obj *obj) {
 		COFF_FLAGS_TI_F_LNNO | COFF_FLAGS_TI_F_LSYMS));
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	return r_bin_coff_new_buf (buf, bf->rbin->verbose);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	*bin_obj = r_bin_coff_new_buf (buf, bf->rbin->verbose);
+	return *bin_obj != NULL;
 }
 
-static int destroy(RBinFile *bf) {
-	r_bin_coff_free((struct r_bin_coff_obj*)bf->o->bin_obj);
-	return true;
+static void destroy(RBinFile *bf) {
+	r_bin_coff_free ((struct r_bin_coff_obj*)bf->o->bin_obj);
 }
 
 static ut64 baddr(RBinFile *bf) {
diff --git a/libr/bin/p/bin_dex.c b/libr/bin/p/bin_dex.c
index fb0d400bb3..7e6b16163e 100644
--- a/libr/bin/p/bin_dex.c
+++ b/libr/bin/p/bin_dex.c
@@ -742,8 +742,9 @@ static Sdb *get_sdb (RBinFile *bf) {
 	return bin->kv;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	return r_bin_dex_new_buf (buf);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	*bin_obj = r_bin_dex_new_buf (buf);
+	return *bin_obj != NULL;
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -2103,36 +2104,28 @@ static RList *dex_fields(RBinFile *bf) {
 	return ret;
 }
 
-static bool check_bytes(const ut8 *bytes, ut64 length) {
-	RBuffer *buf = r_buf_new_with_bytes (bytes, length);
-	bool res = check_buffer (buf);
-	r_buf_free (buf);
-	return res;
-}
-
 RBinPlugin r_bin_plugin_dex = {
 	.name = "dex",
 	.desc = "dex format bin plugin",
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
 	.load_buffer = &load_buffer,
-	.check_bytes = check_bytes,
 	.check_buffer = check_buffer,
 	.baddr = baddr,
 	.entries = entries,
 	.classes = classes,
 	.sections = sections,
 	.symbols = methods,
 	.imports = imports,
 	.strings = strings,
 	.info = &info,
 	.header = dex_header,
 	.fields = dex_fields,
 	.size = &size,
 	.get_offset = &getoffset,
 	.get_name = &getname,
 	.dbginfo = &r_bin_dbginfo_dex,
 	.lines = &lines,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_dol.c b/libr/bin/p/bin_dol.c
index bbc0f9e767..d587245c13 100644
--- a/libr/bin/p/bin_dol.c
+++ b/libr/bin/p/bin_dol.c
@@ -51,34 +51,35 @@ static bool check_bytes(const ut8 *b, ut64 length) {
 	return res;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	DolHeader *dol = NULL;
 	char *lowername = NULL, *ext;
 	if (r_buf_size (buf) < sizeof (DolHeader)) {
-		return NULL;
+		return false;
 	}
 	dol = R_NEW0 (DolHeader);
 	if (!dol) {
-		return NULL;
+		return false;
 	}
 	lowername = strdup (bf->file);
 	if (!lowername) {
 		goto dol_err;
 	}
 	r_str_case (lowername, 0);
 	ext = strstr (lowername, ".dol");
 	if (!ext || ext[4] != 0) {
 		goto lowername_err;
 	}
 	free (lowername);
 	r_buf_fread_at (bf->buf, 0, (void *) dol, "67I", 1);
-	return dol;
+	*bin_obj = dol;
+	return true;
 
 lowername_err:
 	free (lowername);
 dol_err:
 	free (dol);
-	return NULL;
+	return false;
 }
 
 static RList *sections(RBinFile *bf) {
diff --git a/libr/bin/p/bin_dyldcache.c b/libr/bin/p/bin_dyldcache.c
index 145443f99d..7fb1c7a10b 100644
--- a/libr/bin/p/bin_dyldcache.c
+++ b/libr/bin/p/bin_dyldcache.c
@@ -1096,48 +1096,44 @@ static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cac
 	return accel;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	RDyldCache *cache = R_NEW0 (RDyldCache);
 	memcpy (cache->magic, "dyldcac", 7);
 	cache->buf = r_buf_new_with_io (&bf->rbin->iob, bf->fd);
 	if (!cache->buf) {
 		r_dyldcache_free (cache);
-		return NULL;
+		return false;
 	}
 	cache->hdr = read_cache_header (cache->buf);
 	if (!cache->hdr) {
 		r_dyldcache_free (cache);
-		return NULL;
+		return false;
 	}
-
 	cache->maps = read_cache_maps (cache->buf, cache->hdr);
 	if (!cache->maps) {
 		r_dyldcache_free (cache);
-		return NULL;
+		return false;
 	}
-
 	cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);
 	if (!cache->accel) {
 		r_dyldcache_free (cache);
-		return NULL;
+		return false;
 	}
-
 	cache->bins = create_cache_bins (bf, cache->buf, cache->hdr, cache->maps, cache->accel);
 	if (!cache->bins) {
 		r_dyldcache_free (cache);
-		return NULL;
+		return false;
 	}
-
 	cache->rebase_info = get_rebase_info (bf, cache);
 	if (!cache->rebase_info) {
 		r_dyldcache_free (cache);
-		return NULL;
+		return false;
 	}
-
 	if (!cache->rebase_info->slide) {
 		swizzle_io_read (cache, bf->rbin->iob.io);
 	}
-	return cache;
+	*bin_obj = cache;
+	return true;
 }
 
 static RList *entries(RBinFile *bf) {
@@ -1387,11 +1383,10 @@ static RList *symbols(RBinFile *bf) {
 	cache->original_io_read = NULL;
 } */
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	RDyldCache *cache = (RDyldCache*) bf->o->bin_obj;
 	// unswizzle_io_read (cache, bf->rbin->iob.io); // XXX io may be dead here
 	r_dyldcache_free (cache);
-	return true;
 }
 
 static RList *classes(RBinFile *bf) {
diff --git a/libr/bin/p/bin_elf.c b/libr/bin/p/bin_elf.c
index 61c38a8731..4858f6dce6 100644
--- a/libr/bin/p/bin_elf.c
+++ b/libr/bin/p/bin_elf.c
@@ -1,3 +1,5 @@
+/* radare2 - LGPL - Copyright 2009-2019 - pancake, nibble, dso */
+
 #include "bin_elf.inc"
 
 static void headers32(RBinFile *bf) {
@@ -11,105 +13,106 @@ static void headers32(RBinFile *bf) {
 	p ("0x00000020  ShOff       0x%08x\n", r_buf_read_le32_at (bf->buf, 0x20));
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	return buf && length > 4 && memcmp (buf, ELFMAG, SELFMAG) == 0
-		&& buf[4] != 2;
+static bool check_buffer(RBuffer *buf) {
+	ut8 b[5] = {0};
+	r_buf_read_at (buf, 0, b, sizeof (b));
+	return !memcmp (b, ELFMAG, SELFMAG) && b[4] != 2;
 }
 
 extern struct r_bin_dbginfo_t r_bin_dbginfo_elf;
 extern struct r_bin_write_t r_bin_write_elf;
 
 static RBuffer* create(RBin* bin, const ut8 *code, int codelen, const ut8 *data, int datalen, RBinArchOptions *opt) {
+	r_return_val_if_fail (bin && opt && opt->arch, NULL);
+
 	ut32 filesize, code_va, code_pa, phoff;
 	ut32 p_start, p_phoff, p_phdr;
 	ut32 p_ehdrsz, p_phdrsz;
 	ut16 ehdrsz, phdrsz;
 	ut32 p_vaddr, p_paddr, p_fs, p_fs2;
 	ut32 baddr;
-	int is_arm = 0;
 	RBuffer *buf = r_buf_new ();
 
-	r_return_val_if_fail (bin && opt && opt->arch, NULL);
-	is_arm = !strcmp (opt->arch, "arm");
+	bool is_arm = !strcmp (opt->arch, "arm");
 	// XXX: hardcoded
 	if (is_arm) {
 		baddr = 0x40000;
 	} else {
 		baddr = 0x8048000;
 	}
 
 #define B(x,y) r_buf_append_bytes(buf,(const ut8*)(x),y)
 #define D(x) r_buf_append_ut32(buf,x)
 #define H(x) r_buf_append_ut16(buf,x)
 #define Z(x) r_buf_append_nbytes(buf,x)
 #define W(x,y,z) r_buf_write_at(buf,x,(const ut8*)(y),z)
 #define WZ(x,y) p_tmp=r_buf_size (buf);Z(x);W(p_tmp,y,strlen(y))
 
 	B ("\x7F" "ELF" "\x01\x01\x01\x00", 8);
 	Z (8);
 	H (2); // ET_EXEC
 	if (is_arm) {
 		H (40); // e_machne = EM_ARM
 	} else {
 		H (3); // e_machne = EM_I386
 	}
 
 	D (1);
 	p_start = r_buf_size (buf);
 	D (-1); // _start
 	p_phoff = r_buf_size (buf);
 	D (-1); // phoff -- program headers offset
 	D (0);  // shoff -- section headers offset
 	D (0); // flags
 	p_ehdrsz = r_buf_size (buf);
 	H (-1); // ehdrsz
 	p_phdrsz = r_buf_size (buf);
 	H (-1); // phdrsz
 	H (1);
 	H (0);
 	H (0);
 	H (0);
 	// phdr:
 	p_phdr = r_buf_size (buf);
 	D (1);
 	D (0);
 	p_vaddr = r_buf_size (buf);
 	D (-1); // vaddr = $$
 	p_paddr = r_buf_size (buf);
 	D (-1); // paddr = $$
 	p_fs = r_buf_size (buf);
 	D (-1); // filesize
 	p_fs2 = r_buf_size (buf);
 	D (-1); // filesize
 	D (5); // flags
 	D (0x1000); // align
 
 	ehdrsz = p_phdr;
 	phdrsz = r_buf_size (buf) - p_phdr;
 	code_pa = r_buf_size (buf);
 	code_va = code_pa + baddr;
 	phoff = 0x34;//p_phdr ;
 	filesize = code_pa + codelen + datalen;
 
 	W (p_start, &code_va, 4);
 	W (p_phoff, &phoff, 4);
 	W (p_ehdrsz, &ehdrsz, 2);
 	W (p_phdrsz, &phdrsz, 2);
 
 	code_va = baddr; // hack
 	W (p_vaddr, &code_va, 4);
 	code_pa = baddr; // hack
 	W (p_paddr, &code_pa, 4);
 
 	W (p_fs, &filesize, 4);
 	W (p_fs2, &filesize, 4);
 
 	B (code, codelen);
 
 	if (data && datalen > 0) {
 		//ut32 data_section = buf->length;
 		eprintf ("Warning: DATA section not support for ELF yet\n");
 		B (data, datalen);
 	}
 	return buf;
 }
@@ -117,32 +120,32 @@ static RBuffer* create(RBin* bin, const ut8 *code, int codelen, const ut8 *data,
 RBinPlugin r_bin_plugin_elf = {
 	.name = "elf",
 	.desc = "ELF format r2 plugin",
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
 	.load_buffer = &load_buffer,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.boffset = &boffset,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.minstrlen = 4,
 	.imports = &imports,
 	.info = &info,
 	.fields = &fields,
 	.header = &headers32,
 	.size = &size,
 	.libs = &libs,
 	.relocs = &relocs,
 	.patch_relocs = &patch_relocs,
 	.dbginfo = &r_bin_dbginfo_elf,
 	.create = &create,
 	.write = &r_bin_write_elf,
 	.file_type = &get_file_type,
 	.regstate = &regstate,
 	.maps = &maps,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_elf.inc b/libr/bin/p/bin_elf.inc
index ee349ead54..d38d9d6bea 100644
--- a/libr/bin/p/bin_elf.inc
+++ b/libr/bin/p/bin_elf.inc
@@ -81,30 +81,31 @@ static Sdb* get_sdb(RBinFile *bf) {
 	return NULL;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	struct Elf_(r_bin_elf_obj_t) *res = Elf_(r_bin_elf_new_buf) (buf, bf->rbin->verbose);
 	if (res) {
-		sdb_ns_set (sdb, "info", res->kv);
+	//	sdb_ns_set (sdb, "info", res->kv);
+		*bin_obj = res;
+		return true;
 	}
-	return res;
+	return false;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	int i;
 	ELFOBJ* eobj = bf->o->bin_obj;
 	if (eobj && eobj->imports_by_ord) {
 		for (i = 0; i < eobj->imports_by_ord_size; i++) {
 			RBinImport *imp = eobj->imports_by_ord[i];
 			if (imp) {
 				free (imp->name);
 				free (imp);
 				eobj->imports_by_ord[i] = NULL;
 			}
 		}
 		R_FREE (eobj->imports_by_ord);
 	}
 	Elf_(r_bin_elf_free) ((struct Elf_(r_bin_elf_obj_t)*)bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
diff --git a/libr/bin/p/bin_elf64.c b/libr/bin/p/bin_elf64.c
index d174fe47e4..e2e1512a87 100644
--- a/libr/bin/p/bin_elf64.c
+++ b/libr/bin/p/bin_elf64.c
@@ -1,13 +1,16 @@
-/* radare - LGPL - Copyright 2009-2017 - pancake, nibble */
+/* radare - LGPL - Copyright 2009-2019 - pancake, nibble */
 
 #define R_BIN_ELF64 1
 #include "bin_elf.inc"
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (buf && length >= 5) {
+
+static bool check_buffer(RBuffer *b) {
+	ut8 buf[5] = {0};
+	if (r_buf_size (b) > 4) {
+		r_buf_read_at (b, 0, buf, sizeof (buf));
 		if (!memcmp (buf, "\x7F\x45\x4c\x46\x02", 5)) {
 			return true;
 		}
 	}
 	return false;
 }
@@ -116,33 +119,33 @@ static RBuffer* create(RBin* bin, const ut8 *code, int codelen, const ut8 *data,
 RBinPlugin r_bin_plugin_elf64 = {
 	.name = "elf64",
 	.desc = "elf64 bin plugin",
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
+	.check_buffer = &check_buffer,
 	.load_buffer= &load_buffer,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
 	.baddr = &baddr,
 	.boffset = &boffset,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.imports = &imports,
 	.minstrlen = 4,
 	.info = &info,
 	.fields = &fields,
 	.header = &headers64,
 	.size = &size,
 	.libs = &libs,
 	.relocs = &relocs,
 	.patch_relocs = &patch_relocs,
 	.dbginfo = &r_bin_dbginfo_elf64,
 	.create = &create,
 	.write = &r_bin_write_elf64,
 	.get_vaddr = &get_elf_vaddr64,
 	.file_type = &get_file_type,
 	.regstate = &regstate,
 	.maps = &maps,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_fs.c b/libr/bin/p/bin_fs.c
index c2451c5634..e04cdb67a6 100644
--- a/libr/bin/p/bin_fs.c
+++ b/libr/bin/p/bin_fs.c
@@ -1,75 +1,64 @@
-/* radare - LGPL - Copyright 2011-2017 - pancake */
+/* radare - LGPL - Copyright 2011-2019 - pancake */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include "../../fs/types.h"
 
-static char *fsname(const ut8* buf, ut64 length) {
-	ut8 fs_lbuf[1024];
-	int i, j, len, ret = false;
+static char *fsname(RBuffer *b) {
+	ut8 buf[1024];
+	int i, j;
 
 	for (i = 0; fstypes[i].name; i++) {
 		RFSType *f = &fstypes[i];
 
-		len = R_MIN (f->buflen, sizeof (fs_lbuf));
-		memset (fs_lbuf, 0, sizeof (fs_lbuf));
-		if (f->bufoff + len > length) {
+		if (r_buf_read_at (b, f->bufoff, buf, sizeof (buf)) != sizeof (buf)) {
 			break;
 		}
-		memcpy (fs_lbuf, buf + f->bufoff, len);
-		if ((f->buflen > 0) && len >= f->buflen) {
-			int min = R_MIN (f->buflen, sizeof (fs_lbuf));
-			if (!memcmp (fs_lbuf, f->buf, min)) {
-				ret = true;
-				len = R_MIN (f->bytelen, sizeof (fs_lbuf));
-				if (f->byteoff + len > length) {
+		if (f->buflen > 0) {
+			size_t min = R_MIN (f->buflen, sizeof (buf));
+			if (!memcmp (buf, f->buf, min)) {
+				bool ret = true;
+				min = R_MIN (f->bytelen, sizeof (buf));
+				if (r_buf_read_at (b, f->byteoff, buf, min) != min) {
 					break;
 				}
-				memcpy (fs_lbuf, buf + f->byteoff, len);
-				// for (j = 0; j < f->bytelen; j++) {
-				for (j = 0; j < len; j++) {
-					if (fs_lbuf[j] != f->byte) {
+				for (j = 0; j < min; j++) {
+					if (buf[j] != f->byte) {
 						ret = false;
 						break;
 					}
 				}
 				if (ret) {
 					return strdup (f->name);
 				}
 			}
 		}
 	}
 	return NULL;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (!buf || (st64)length < 1) {
-		return false;
-	}
-	char *p = fsname (buf, length);
+static bool check_buffer(RBuffer *b) {
+	r_return_val_if_fail (b, false);
+	char *p = fsname (b);
+	bool hasFs = p != NULL;
 	free (p);
-	return p != NULL;
+	return hasFs;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	return check_bytes (buf, sz);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	return check_buffer (buf);
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
+	r_return_val_if_fail (bf && bf->o, false);
 	ut64 la = bf->o->loadaddr;
-	return load_bytes (bf, &bf->o->bin_obj, bytes, sz, la, bf->sdb);
+	return load_buffer (bf, &bf->o->bin_obj, bf->buf, la, bf->sdb);
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	//r_bin_fs_free ((struct r_bin_fs_obj_t*)bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -83,30 +72,23 @@ static RList *strings(RBinFile *bf) {
 
 static RBinInfo* info(RBinFile *bf) {
 	RBinInfo *ret = NULL;
-	const ut8 *bytes;
-	ut64 sz;
-
 	if (!bf) {
 		return NULL;
 	}
-	bytes = r_buf_data (bf->buf, &sz);
-	if (!bytes) {
-		return NULL;
-	}
 	if (!(ret = R_NEW0 (RBinInfo))) {
 		return NULL;
 	}
 	ret->file = bf->file? strdup (bf->file): NULL;
 	ret->type = strdup ("fs");
-	ret->bclass = fsname (bytes, sz);
+	ret->bclass = fsname (bf->buf);
 	ret->rclass = strdup ("fs");
 	ret->os = strdup ("any");
 	ret->subsystem = strdup ("unknown");
 	ret->machine = strdup ("any");
 	// ret->arch = strdup ("any");
 	ret->has_va = 0;
 	ret->bits = 32;
 	ret->big_endian = 0;
 	ret->dbg_info = 0;
 	return ret;
 }
@@ -114,16 +96,16 @@ static RBinInfo* info(RBinFile *bf) {
 RBinPlugin r_bin_plugin_fs = {
 	.name = "fs",
 	.desc = "filesystem bin plugin",
 	.author = "pancake",
 	.version = "1.0",
 	.license = "LGPL3",
 	.load = &load,
-	.load_bytes = &load_bytes,
+	.load_buffer = &load_buffer,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.strings = &strings,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_java.c b/libr/bin/p/bin_java.c
index 6221a18691..9b3d9a4bdc 100644
--- a/libr/bin/p/bin_java.c
+++ b/libr/bin/p/bin_java.c
@@ -135,11 +135,10 @@ static bool load(RBinFile *bf) {
 	return result;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_bin_java_free ((struct r_bin_java_obj_t *) bf->o->bin_obj);
 	sdb_free (DB);
 	DB = NULL;
-	return true;
 }
 
 static RList *entries(RBinFile *bf) {
@@ -185,6 +184,21 @@ static RBinInfo *info(RBinFile *bf) {
 	return ret;
 }
 
+static bool check_buffer(RBuffer *b) {
+	if (r_buf_size (b) > 32) {
+		ut8 buf[4];
+		r_buf_read_at (b, 0, buf, sizeof (buf));
+		if (!memcmp (buf, "\xca\xfe\xba\xbe", 4)) {
+			int off = r_buf_read_be32_at (b, 4 * sizeof (int));
+			int version = r_buf_read_be16_at (b, 6);
+			if (off > 0 && version < 1024) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
 static bool check_bytes(const ut8 *buf, ut64 length) {
 	bool ret = false;
 	int off, version = 0;
@@ -248,28 +262,29 @@ static RList *libs(RBinFile *bf) {
 RBinPlugin r_bin_plugin_java = {
 	.name = "java",
 	.desc = "java bin plugin",
 	.license = "LGPL3",
 	.init = init,
 	.fini = fini,
 	.get_sdb = &get_sdb,
 	.load = &load,
 	.load_bytes = &load_bytes,
 	.destroy = &destroy,
 	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = binsym,
 	.entries = &entries,
 	.sections = sections,
 	.symbols = symbols,
 	.imports = &imports,
 	.strings = &strings,
 	.info = &info,
 	.fields = fields,
 	.libs = libs,
 	.lines = &lines,
 	.classes = classes,
 	.demangle_type = retdemangle,
 	.minstrlen = 3,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_mach0.c b/libr/bin/p/bin_mach0.c
index 9db0169d21..21911f051c 100644
--- a/libr/bin/p/bin_mach0.c
+++ b/libr/bin/p/bin_mach0.c
@@ -28,31 +28,26 @@ static char *entitlements(RBinFile *bf, bool json) {
 }
 
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb){
-	struct MACH0_(obj_t) *res = NULL;
-	if (!buf) {
-		return NULL;
-	}
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb){
+	r_return_val_if_fail (bf && bin_obj && buf, false);
 	struct MACH0_(opts_t) opts;
 	MACH0_(opts_set_default) (&opts, bf);
-	res = MACH0_(new_buf) (buf, &opts);
+	struct MACH0_(obj_t) *res = MACH0_(new_buf) (buf, &opts);
 	if (res) {
 		sdb_ns_set (sdb, "info", res->kv);
+		*bin_obj = res;
+		return true;
 	}
-	return res;
+	return false;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	MACH0_(mach0_free) (bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
-	struct MACH0_(obj_t) *bin;
-	if (!bf || !bf->o || !bf->o->bin_obj) {
-		return 0LL;
-	}
-	bin = bf->o->bin_obj;
+	r_return_val_if_fail (bf && bf->o && bf->o->bin_obj, UT64_MAX);
+	struct MACH0_(obj_t) *bin = bf->o->bin_obj;
 	return MACH0_(get_baddr)(bin);
 }
 
@@ -557,16 +552,19 @@ static RBinInfo *info(RBinFile *bf) {
 }
 
 #if !R_BIN_MACH064
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (buf && length >= 4) {
-		if (!memcmp (buf, "\xce\xfa\xed\xfe", 4) ||
-			!memcmp (buf, "\xfe\xed\xfa\xce", 4)) {
-			return true;
+
+static bool check_buffer(RBuffer *b) {
+	if (r_buf_size (b) >= 4) {
+		ut8 buf[4] = {0};
+		if (r_buf_read_at (b, 0, buf, 4)) {
+			if (!memcmp (buf, "\xce\xfa\xed\xfe", 4) ||
+				!memcmp (buf, "\xfe\xed\xfa\xce", 4)) {
+				return true;
+			}
 		}
 	}
 	return false;
 }
-
 static RBuffer *create(RBin *bin, const ut8 *code, int clen, const ut8 *data, int dlen, RBinArchOptions *opt) {
 	const bool use_pagezero = true;
 	const bool use_main = true;
@@ -872,27 +870,27 @@ static ut64 size(RBinFile *bf) {
 RBinPlugin r_bin_plugin_mach0 = {
 	.name = "mach0",
 	.desc = "mach0 bin plugin",
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
 	.load_buffer = &load_buffer,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.signature = &entitlements,
 	.sections = &sections,
 	.symbols = &symbols,
 	.imports = &imports,
 	.size = &size,
 	.info = &info,
 	.header = MACH0_(mach_headerfields),
 	.fields = MACH0_(mach_fields),
 	.libs = &libs,
 	.relocs = &relocs,
 	.create = &create,
 	.classes = &MACH0_(parse_classes),
 	.write = &r_bin_write_mach0,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_mach064.c b/libr/bin/p/bin_mach064.c
index 735604af9f..e66f7f8822 100644
--- a/libr/bin/p/bin_mach064.c
+++ b/libr/bin/p/bin_mach064.c
@@ -1,11 +1,25 @@
-/* radare - LGPL - Copyright 2009-2015 - nibble, pancake, alvaro_fe */
+/* radare - LGPL - Copyright 2009-2019 - nibble, pancake, alvaro_fe */
 
 #define R_BIN_MACH064 1
 #include "bin_mach0.c"
 
 #include "objc/mach064_classes.h"
 #include "../format/mach0/mach064_is_kernelcache.c"
 
+static bool check_buffer(RBuffer *b) {
+	ut8 buf[4] = {0};
+	if (r_buf_size (b) > 4) {
+		r_buf_read_at (b, 0, buf, sizeof (buf));
+		if (!memcmp (buf, "\xfe\xed\xfa\xcf", 4)) {
+			return true;
+		}
+		if (!memcmp (buf, "\xcf\xfa\xed\xfe", 4)) {
+			return !is_kernelcache_buffer (b);
+		}
+	}
+	return false;
+}
+
 static bool check_bytes(const ut8 *buf, ut64 length) {
 	if (buf && length > 4) {
 		if (!memcmp (buf, "\xfe\xed\xfa\xcf", 4)) {
@@ -280,26 +294,27 @@ static RBinAddr* binsym(RBinFile *bf, int sym) {
 RBinPlugin r_bin_plugin_mach064 = {
 	.name = "mach064",
 	.desc = "mach064 bin plugin",
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
 	.load_buffer = &load_buffer,
 	.destroy = &destroy,
 	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.signature = &entitlements,
 	.symbols = &symbols,
 	.imports = &imports,
 	.info = &info,
 	.libs = &libs,
 	.header = &MACH0_(mach_headerfields),
 	.relocs = &relocs,
 	.fields = &MACH0_(mach_fields),
 	.create = &create,
 	.classes = &MACH0_(parse_classes),
 	.write = &r_bin_write_mach0,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_mbn.c b/libr/bin/p/bin_mbn.c
index 7378d1906f..eb6aba8193 100644
--- a/libr/bin/p/bin_mbn.c
+++ b/libr/bin/p/bin_mbn.c
@@ -1,6 +1,9 @@
-/* radare2 - LGPL - Copyright 2015-2017 - pancake */
+/* radare2 - LGPL - Copyright 2015-2019 - pancake */
+
+// XXX: this plugin have 0 tests and no binaries
+//
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
@@ -8,102 +11,93 @@
 typedef struct sbl_header {
 	ut32 load_index;
 	ut32 version;    // (flash_partition_version) 3 = nand
 	ut32 paddr;      // This + 40 is the start of the code in the file
 	ut32 vaddr;	 // Where it's loaded in memory
 	ut32 psize;      // code_size + signature_size + cert_chain_size
 	ut32 code_pa;    // Only what's loaded to memory
 	ut32 sign_va;
 	ut32 sign_sz;
 	ut32 cert_va;    // Max of 3 certs?
 	ut32 cert_sz;
-} SBLHDR;
+} SblHeader;
 
 // TODO avoid globals
-static SBLHDR sb = {0};
+static SblHeader sb = {0};
 
-static bool check_bytes(const ut8 *buf, ut64 bufsz) {
-	if (buf && bufsz >= sizeof (SBLHDR)) {
-		RBuffer *b = r_buf_new_with_pointers (buf, bufsz, false);
+static bool check_buffer(RBuffer *b) {
+	r_return_val_if_fail (b, false);
+	ut64 bufsz = r_buf_size (b);
+	if (sizeof (SblHeader) < bufsz) {
 		int ret = r_buf_fread_at (b, 0, (ut8*)&sb, "10i", 1);
-		r_buf_free (b);
 		if (!ret) {
 			return false;
 		}
+#if 0
+		eprintf ("V=%d\n", sb.version);
+		eprintf ("PA=0x%08x sz=0x%x\n", sb.paddr, sb.psize);
+		eprintf ("VA=0x%08x sz=0x%x\n", sb.vaddr, sb.psize);
+		eprintf ("CODE=0x%08x\n", sb.code_pa + sb.vaddr + 40);
+		eprintf ("SIGN=0x%08x sz=0x%x\n", sb.sign_va, sb.sign_sz);
+		if (sb.cert_sz > 0) {
+			eprintf ("CERT=0x%08x sz=0x%x\n", sb.cert_va, sb.cert_sz);
+		} else {
+			eprintf ("No certificate found.\n");
+		}
+#endif
 		if (sb.version != 3) { // NAND
 			return false;
 		}
-		if (sb.paddr + sizeof (SBLHDR) > bufsz) { // NAND
+		if (sb.paddr + sizeof (SblHeader) > bufsz) { // NAND
 			return false;
 		}
 		if (sb.vaddr < 0x100 || sb.psize > bufsz) { // NAND
 			return false;
 		}
 		if (sb.cert_va < sb.vaddr) {
 			return false;
 		}
 		if (sb.cert_sz >= 0xf0000) {
 			return false;
 		}
 		if (sb.sign_va < sb.vaddr) {
 			return false;
 		}
 		if (sb.sign_sz >= 0xf0000) {
 			return false;
 		}
 		if (sb.load_index < 1 || sb.load_index > 0x40) {
 			return false; // should be 0x19 ?
 		}
-#if 0
-		eprintf ("V=%d\n", sb.version);
-		eprintf ("PA=0x%08x sz=0x%x\n", sb.paddr, sb.psize);
-		eprintf ("VA=0x%08x sz=0x%x\n", sb.vaddr, sb.psize);
-		eprintf ("CODE=0x%08x\n", sb.code_pa + sb.vaddr+40);
-		eprintf ("SIGN=0x%08x sz=0x%x\n", sb.sign_va, sb.sign_sz);
-		if (sb.cert_sz > 0) {
-			eprintf ("CERT=0x%08x sz=0x%x\n", sb.cert_va, sb.cert_sz);
-		} else {
-			eprintf ("No certificate found.\n");
-		}
-#endif
 // TODO: Add more checks here
 		return true;
 	}
 	return false;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	return check_bytes (buf, sz);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb){
+	return check_buffer (b);
 }
 
 static bool load(RBinFile *bf) {
 	if (bf && bf->buf) {
-		ut64 sz;
-		const ut8 *bytes = r_buf_data (bf->buf, &sz);
-		return load_bytes (bf, &bf->o->bin_obj, bytes, sz, bf->o->loadaddr, bf->sdb);
+		return load_buffer (bf, &bf->o->bin_obj, bf->buf, bf->o->loadaddr, bf->sdb);
 	}
 	return false;
 }
 
-static int destroy(RBinFile *bf) {
-	return true;
-}
-
 static ut64 baddr(RBinFile *bf) {
 	return sb.vaddr; // XXX
 }
 
 static RList* entries(RBinFile *bf) {
-	RList* ret;
-	RBinAddr *ptr = NULL;
-
-	if (!(ret = r_list_new ())) {
-		return NULL;
-	}
-	ret->free = free;
-	if ((ptr = R_NEW0 (RBinAddr))) {
-		ptr->paddr = 40 + sb.code_pa;
-		ptr->vaddr = 40 + sb.code_pa + sb.vaddr;
-		r_list_append (ret, ptr);
+	RList* ret = r_list_newf (free);;
+	if (ret) {
+		RBinAddr *ptr = R_NEW0 (RBinAddr);
+		if (ptr) {
+			ptr->paddr = 40 + sb.code_pa;
+			ptr->vaddr = 40 + sb.code_pa + sb.vaddr;
+			r_list_append (ret, ptr);
+		}
 	}
 	return ret;
 }
@@ -192,23 +186,23 @@ static RBinInfo* info(RBinFile *bf) {
 }
 
 static ut64 size(RBinFile *bf) {
-	return sizeof (SBLHDR) + sb.psize;
+	return sizeof (SblHeader) + sb.psize;
 }
 
 RBinPlugin r_bin_plugin_mbn = {
 	.name = "mbn",
 	.desc = "MBN/SBL bootloader things",
 	.license = "LGPL3",
 	.minstrlen = 10,
 	.load = &load,
-	.load_bytes = &load_bytes,
+	// .load_bytes = &load_bytes,
+	.load_buffer = &load_buffer,
 	.size = &size,
-	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.entries = &entries,
 	.sections = &sections,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_mdmp.c b/libr/bin/p/bin_mdmp.c
index b82a7e57fc..71693c3478 100644
--- a/libr/bin/p/bin_mdmp.c
+++ b/libr/bin/p/bin_mdmp.c
@@ -31,9 +31,8 @@ static Sdb *get_sdb(RBinFile *bf) {
 	return (obj && obj->kv) ? obj->kv: NULL;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_bin_mdmp_free ((struct r_bin_mdmp_obj*)bf->o->bin_obj);
-	return true;
 }
 
 static RList* entries(RBinFile *bf) {
@@ -184,50 +183,20 @@ static RList* libs(RBinFile *bf) {
 	return ret;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
-	RBuffer *tbuf;
-	struct r_bin_mdmp_obj *res;
-
-	if (!buf || !sz || sz == UT64_MAX) {
-		return false;
-	}
-
-	tbuf = r_buf_new_with_bytes (buf, sz);
-	if (!tbuf) {
-		return false;
-	}
-
-	if ((res = r_bin_mdmp_new_buf (tbuf))) {
-		sdb_ns_set (sdb, "info", res->kv);
-	}
-	r_buf_free (tbuf);
-
-	if (res) {
-		*bin_obj = res;
-		return true;
-	} else {
-		return false;
-	}
-}
-
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	r_return_val_if_fail (buf, NULL);
-
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	r_return_val_if_fail (buf, false);
 	struct r_bin_mdmp_obj *res = r_bin_mdmp_new_buf (buf);
 	if (res) {
 		sdb_ns_set (sdb, "info", res->kv);
+		*bin_obj = res;
+		return true;
 	}
-	return res;
+	return false;
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	return load_bytes (bf, &bf->o->bin_obj, bytes, sz, bf->o->loadaddr, bf->sdb);
+	r_return_val_if_fail (bf && bf->o, false);
+	return load_buffer (bf, &bf->o->bin_obj, bf->buf, bf->o->loadaddr, bf->sdb);
 }
 
 static RList *sections(RBinFile *bf) {
@@ -505,30 +474,32 @@ static RList* symbols(RBinFile *bf) {
 	return ret;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	return buf && (length > sizeof (struct minidump_header))
-		&& (!memcmp (buf, MDMP_MAGIC, 6));
+static bool check_buffer(RBuffer *b) {
+	ut8 magic[6];
+	if (r_buf_read_at (b, 0, magic, sizeof (magic)) == 6) {
+		return !memcmp (magic, MDMP_MAGIC, 6);
+	}
+	return false;
 }
 
 RBinPlugin r_bin_plugin_mdmp = {
 	.name = "mdmp",
 	.desc = "Minidump format r_bin plugin",
 	.license = "LGPL3",
 	.baddr = &baddr,
-	.check_bytes = &check_bytes,
 	.destroy = &destroy,
 	.entries = entries,
 	.get_sdb = &get_sdb,
 	.imports = &imports,
 	.info = &info,
 	.libs = &libs,
 	.load = &load,
-	.load_bytes = &load_bytes,
 	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.mem = &mem,
 	.relocs = &relocs,
 	.sections = &sections,
 	.symbols = &symbols,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_menuet.c b/libr/bin/p/bin_menuet.c
index 6dfa5f2f1f..4dc99325d2 100644
--- a/libr/bin/p/bin_menuet.c
+++ b/libr/bin/p/bin_menuet.c
@@ -1,76 +1,78 @@
-/* radare2 - LGPL - Copyright 2016-2018 - pancake */
+/* radare2 - LGPL - Copyright 2016-2019 - pancake */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 
 #define MENUET_VERSION(x) x[7]
 
 #if 0
         db      'MENUET00'           ; 8 byte id
         dd      38                   ; required os
         dd      START                ; program start
         dd      I_END                ; image size
         dd      0x100000             ; reguired amount of memory
         dd      0x00000000           ; reserved=no extended header
 
         org     0x0
         db      'MENUET01'              ; 8 byte id
         dd      1                       ; header version
         dd      START                   ; program start
         dd      I_END                   ; program image size
         dd      0x1000                  ; required amount of memory
         dd      0x1000                  ; esp
         dd      0, 0                    ; no parameters, no path
 
          0 db 'MENUET02'
          8 dd 0x01
         12 dd __start
         16 dd __iend
         20 dd __bssend
         24 dd __stack
         28 dd __cmdline
         32 dd __pgmname
         36 dd 0x0; tls map
         40 dd __idata_start; секция .import
         44 dd __idata_end
         48 dd main
 
         db 'MENUET02'
         dd 1
         dd start
         dd i_end
         dd mem
         dd mem
         dd cmdline
         dd path
         dd 0
 
 #endif
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (buf && length >= 32 && !memcmp (buf, "MENUET0", 7)) {
+static bool check_buffer(RBuffer *b) {
+	ut8 buf[8];
+	if (r_buf_read_at (b, 0, buf, sizeof (buf)) != sizeof (buf)) {
+		return false;
+	}
+	if (r_buf_size (b) >= 32 && !memcmp (buf, "MENUET0", 7)) {
 		switch (buf[7]) {
 		case '0':
 		case '1':
 		case '2':
 			return true;
 		}
 		eprintf ("Unsupported MENUET version header\n");
 	}
 	return false;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	return check_bytes (buf, sz);
+static bool load_buffer (RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb){
+	return check_buffer (b);
 }
 
 static bool load(RBinFile *bf) {
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
 	ut64 la = (bf && bf->o)? bf->o->loadaddr: 0;
-	return load_bytes (bf, bf? &bf->o->bin_obj: NULL, bytes, sz, la, bf? bf->sdb: NULL);
+	return load_buffer (bf, bf->o->bin_obj, bf->buf, la, bf->sdb);
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -209,16 +211,16 @@ static RBuffer* create(RBin* bin, const ut8 *code, int codelen, const ut8 *data,
 RBinPlugin r_bin_plugin_menuet = {
 	.name = "menuet",
 	.desc = "Menuet/KolibriOS bin plugin",
 	.license = "LGPL3",
 	.load = &load,
-	.load_bytes = &load_bytes,
+	.load_buffer = &load_buffer,
 	.size = &size,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.entries = &entries,
 	.sections = &sections,
 	.info = &info,
 	.create = &create,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_mz.c b/libr/bin/p/bin_mz.c
index 4ed9b7185c..b372ad57cf 100644
--- a/libr/bin/p/bin_mz.c
+++ b/libr/bin/p/bin_mz.c
@@ -1,10 +1,14 @@
-/* radare - LGPL - Copyright 2015-2018 nodepad */
+/* radare - LGPL - Copyright 2015-2019 nodepad */
 
 #include <r_types.h>
 #include <r_bin.h>
 #include <r_lib.h>
 #include "mz/mz.h"
 
+
+/* half-magic */
+#define HM(x) (int)((int)(x[0]<<8)|(int)(x[1]))
+
 static Sdb *get_sdb(RBinFile *bf) {
 	const struct r_bin_mz_obj_t *bin;
 	if (bf && bf->o && bf->o->bin_obj) {
@@ -16,84 +20,101 @@ static Sdb *get_sdb(RBinFile *bf) {
 	return NULL;
 }
 
-static bool knownHeader(const ut8 *buf,ut16 offset,ut64 length){
-	// check for PE
-	if (!memcmp (buf + offset, "PE", 2) &&
-		(length > offset + 0x20) &&
-		!memcmp (buf + offset + 0x18, "\x0b\x01", 2)) {
+static bool knownHeaderBuffer(RBuffer *b, ut16 offset) {
+	ut8 h[2];
+	if (r_buf_read_at (b, 0, h, sizeof (h)) != sizeof (h)) {
 		return false;
 	}
-	// Check for New Executable, LE/LX or Phar Lap executable
-	if (!memcmp (buf + offset, "NE", 2) ||
-		!memcmp (buf + offset, "LE", 2) ||
-		!memcmp (buf + offset, "LX", 2) ||
-		!memcmp (buf + offset, "PL", 2)) {
-		return false;
+	if (!memcmp (h, "PE", 2)) {
+		if (offset + 0x20 < r_buf_size (b)) {
+			if (r_buf_read_at (b, offset + 0x18, h, sizeof (h)) != 2) {
+				return false;
+			}
+			if (!memcmp (h, "\x0b\x01", 2)) {
+				return true;
+			}
+		}
+	} else {
+		if (!memcmp (h, "NE", 2)
+		 || !memcmp (h, "LE", 2)
+		 || !memcmp (h, "LX", 2)
+		 || !memcmp (h, "PL", 2)) {
+			return true;
+		}
 	}
-	return true;
+	return false;
 }
 
-static bool checkEntrypoint(const ut8 *buf, ut64 length) {
-	st16 cs = r_read_ble16 (buf + 0x16, false);
-	ut16 ip = r_read_ble16 (buf + 0x14, false);
-	ut32 pa = ((r_read_ble16 (buf + 8, false) + cs) << 4) + ip;
+static bool checkEntrypointBuffer(RBuffer *b) {
+	st16 cs = r_buf_read_le16_at (b, 0x16);
+	ut16 ip = r_buf_read_le16_at (b, 0x14);
+	ut32 pa = ((r_buf_read_le16_at (b, 0x08) + cs) << 4) + ip;
 
 	/* A minimal MZ header is 0x1B bytes.  Header length is measured in
 	 * 16-byte paragraphs so the minimum header must occupy 2 paragraphs.
 	 * This means that the entrypoint should be at least 0x20 unless someone
 	 * cleverly fit a few instructions inside the header.
 	 */
 	pa &= 0xffff;
+	ut64 length = r_buf_size (b);
 	if (pa >= 0x20 && pa + 1 < length) {
-		ut16 pe = r_read_ble16 (buf + 0x3c, false);
-		if (pe + 2 < length && length > 0x104 && !memcmp (buf + pe, "PE", 2)) {
-			return false;
+		ut16 pe = r_buf_read_le16_at (b,  0x3c);
+		if (pe + 2 < length && length > 0x104) {
+			ut8 h[2];
+			if (r_buf_read_at (b, pe, h, 2) == 2) {
+				if (!memcmp (h, "PE", 2)) {
+					return false;
+				}
+			}
 		}
 		return true;
 	}
 	return false;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	ut16 new_exe_header_offset;
-	if (!buf || length <= 0x3d) {
+static bool check_buffer(RBuffer *b) {
+	r_return_val_if_fail (b, false);
+	ut64 b_size = r_buf_size (b);
+	if (b_size <= 0x3d) {
 		return false;
 	}
 
 	// Check for MZ magic.
-	if (memcmp (buf, "MZ", 2) && memcmp (buf, "ZM", 2)) {
+	ut8 h[2];
+	if (r_buf_read_at (b, 0, h, 2) != 2) {
+		return false;
+	}
+	if (memcmp (h, "MZ", 2)) {
 		return false;
 	}
 
 	// See if there is a new exe header.
-	new_exe_header_offset = r_read_ble16 (buf + 0x3c, false);
-	if (length > new_exe_header_offset + 2) {
-		if (!knownHeader (buf,new_exe_header_offset, length)) {
+	ut16 new_exe_header_offset = r_buf_read_le16_at (b, 0x3c);
+	if (b_size > new_exe_header_offset + 2) {
+		if (knownHeaderBuffer (b, new_exe_header_offset)) {
 			return false;
 		}
 	}
 
 	// Raw plain MZ executable (watcom)
-	if (!checkEntrypoint (buf, length)) {
+	if (!checkEntrypointBuffer (b)) {
 		return false;
 	}
-
 	return true;
 }
 
-static void *load(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	struct r_bin_mz_obj_t *mz_obj;
-
-	mz_obj = r_bin_mz_new_buf (buf);
+static bool load(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	struct r_bin_mz_obj_t *mz_obj = r_bin_mz_new_buf (buf);
 	if (mz_obj) {
 		sdb_ns_set (sdb, "info", mz_obj->kv);
+		*bin_obj = mz_obj;
+		return true;
 	}
-	return mz_obj;
+	return false;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_bin_mz_free ((struct r_bin_mz_obj_t *)bf->o->bin_obj);
-	return true;
 }
 
 static RBinAddr *binsym(RBinFile *bf, int type) {
@@ -216,18 +237,18 @@ static RList *relocs(RBinFile *bf) {
 RBinPlugin r_bin_plugin_mz = {
 	.name = "mz",
 	.desc = "MZ bin plugin",
 	.license = "MIT",
 	.get_sdb = &get_sdb,
 	.load_buffer = &load,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.info = &info,
 	.header = &header,
 	.relocs = &relocs,
 	.minstrlen = 4,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_nes.c b/libr/bin/p/bin_nes.c
index 86dbd377da..09014b3f4a 100644
--- a/libr/bin/p/bin_nes.c
+++ b/libr/bin/p/bin_nes.c
@@ -1,27 +1,21 @@
-/* radare - LGPL3 - 2015-2016 - maijin */
+/* radare - LGPL3 - 2015-2019 - maijin */
 
 #include <r_bin.h>
 #include <r_lib.h>
 #include "nes/nes_specs.h"
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (!buf || length < 4) {
-		return false;
-	}
-	return (!memcmp (buf, INES_MAGIC, 4));
-}
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	return check_bytes (buf, sz);
+static bool check_buffer(RBuffer *b) {
+	if (r_buf_size (b) > 4) {
+		ut8 buf[4];
+		r_buf_read_at (b, 0, buf, sizeof (buf));
+		return (!memcmp (buf, INES_MAGIC, sizeof (buf)));
+	}
+	return false;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	ut64 tmpsz;
-	const ut8 *tmp = r_buf_data (buf, &tmpsz);
-	if (!check_bytes (tmp, tmpsz)) {
-		return NULL;
-	}
-	return r_buf_new ();
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	return check_buffer (buf);
 }
 
 static RBinInfo *info(RBinFile *bf) {
@@ -217,16 +211,15 @@ static ut64 baddr(RBinFile *bf) {
 RBinPlugin r_bin_plugin_nes = {
 	.name = "nes",
 	.desc = "NES",
-	.license = "LGPL3",
-	.load_bytes = &load_bytes,
+	.license = "MIT",
 	.load_buffer = &load_buffer,
 	.baddr = &baddr,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.entries = &entries,
 	.sections = sections,
 	.symbols = &symbols,
 	.info = &info,
 	.mem = &mem,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_nin3ds.c b/libr/bin/p/bin_nin3ds.c
index 414e630060..cccd4f0943 100644
--- a/libr/bin/p/bin_nin3ds.c
+++ b/libr/bin/p/bin_nin3ds.c
@@ -1,40 +1,33 @@
-/* radare - LGPL - 2018 - a0rtega */
+/* radare - LGPL - 2018-2019 - a0rtega */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include <string.h>
 
 #include "nin/n3ds.h"
 
 static struct n3ds_firm_hdr loaded_header;
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (!buf || length < sizeof (struct n3ds_firm_hdr)) {
-		return false;
-	}
-	return (!memcmp (buf, "FIRM", 4));
-}
-
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
-	return memcpy (&loaded_header, buf, sizeof (struct n3ds_firm_hdr));
+static bool check_buffer(RBuffer *b) {
+	ut8 magic[4];
+	r_buf_read_at (b, 0, magic, sizeof (magic));
+	return (!memcmp (magic, "FIRM", 4));
 }
 
-static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {
+	if (r_buf_read_at (b, 0, (ut8*)&loaded_header, sizeof (loaded_header)) == sizeof (loaded_header)) {
+		*bin_obj = &loaded_header;
+		return true;
 	}
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	load_bytes (bf, &bf->o->bin_obj, bytes, sz, bf->o->loadaddr, bf->sdb);
-	return check_bytes (bytes, sz);
+	return false;
 }
 
-static int destroy(RBinFile *bf) {
-	r_buf_free (bf->buf);
-	bf->buf = NULL;
-	return true;
+static bool load(RBinFile *bf) {
+	r_return_val_if_fail (bf && bf->o, false);
+	load_buffer (bf, &bf->o->bin_obj, bf->buf, bf->o->loadaddr, bf->sdb);
+	return check_buffer (bf->buf);
 }
 
 static RList *sections(RBinFile *bf) {
@@ -143,14 +136,13 @@ static RBinInfo *info(RBinFile *bf) {
 RBinPlugin r_bin_plugin_nin3ds = {
 	.name = "nin3ds",
 	.desc = "Nintendo 3DS FIRM format r_bin plugin",
 	.license = "LGPL3",
 	.load = &load,
-	.load_bytes = &load_bytes,
-	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.entries = &entries,
 	.sections = &sections,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_ninds.c b/libr/bin/p/bin_ninds.c
index 4ded93d907..5a10c8e7e6 100644
--- a/libr/bin/p/bin_ninds.c
+++ b/libr/bin/p/bin_ninds.c
@@ -1,51 +1,39 @@
-/* radare - LGPL - 2015-2018 - a0rtega */
+/* radare - LGPL - 2015-2019 - a0rtega */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include <string.h>
 
 #include "../format/nin/nds.h"
 
 static struct nds_hdr loaded_header;
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
+static bool check_buffer(RBuffer *b) {
 	ut8 ninlogohead[6];
-	if (!buf || length < sizeof(struct nds_hdr)) { /* header size */
-		return false;
-	}
-	memcpy (ninlogohead, buf + 0xc0, 6);
-	/* begin of nintendo logo =    \x24\xff\xae\x51\x69\x9a */
-	if (!memcmp (ninlogohead, "\x24\xff\xae\x51\x69\x9a", 6)){
-		return true;
-	/* begin of Homebrew magic */
-	} else if (!memcmp (ninlogohead, "\xC8\x60\x4F\xE2\x01\x70", 6)){
-		return true;
-	} else {
-		return false;
+	if (r_buf_read_at (b, 0xc0, ninlogohead, sizeof (ninlogohead)) == 6) {
+		/* begin of nintendo logo =    \x24\xff\xae\x51\x69\x9a */
+		if (!memcmp (ninlogohead, "\x24\xff\xae\x51\x69\x9a", 6)) {
+			return true;
+		}
+		/* begin of Homebrew magic */
+		if (!memcmp (ninlogohead, "\xC8\x60\x4F\xE2\x01\x70", 6)){
+			return true;
+		}
 	}
+	return false;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
-	*bin_obj = memcpy (&loaded_header, buf, sizeof(struct nds_hdr));
+static bool load_buffer (RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {
+	r_buf_read_at (b, 0, (ut8*)&loaded_header, sizeof (loaded_header));
+	*bin_obj = &loaded_header;
 	return (*bin_obj != NULL);
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	load_bytes (bf, &bf->o->bin_obj, bytes, sz, bf->o->loadaddr, bf->sdb);
-	return check_bytes (bytes, sz);
-}
-
-static int destroy(RBinFile *bf) {
-	r_buf_free (bf->buf);
-	bf->buf = NULL;
-	return true;
+	r_return_val_if_fail (bf && bf->o, false);
+	return load_buffer (bf, &bf->o->bin_obj, bf->buf, bf->o->loadaddr, bf->sdb);
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -127,40 +115,34 @@ static RList *entries(RBinFile *bf) {
 }
 
 static RBinInfo *info(RBinFile *bf) {
+	r_return_val_if_fail (bf && bf->buf, NULL);
 	RBinInfo *ret = R_NEW0 (RBinInfo);
-	if (!ret) {
-		return NULL;
-	}
-
-	if (!bf || !bf->buf) {
-		free (ret);
-		return NULL;
+	if (ret) {
+		char *filepath = r_str_newf ("%.12s - %.4s",
+			loaded_header.title, loaded_header.gamecode);
+		ret->file = filepath;
+		ret->type = strdup ("ROM");
+		ret->machine = strdup ("Nintendo DS");
+		ret->os = strdup ("nds");
+		ret->arch = strdup ("arm");
+		ret->has_va = true;
+		ret->bits = 32;
 	}
-	char *filepath = r_str_newf ("%.12s - %.4s",
-		loaded_header.title, loaded_header.gamecode);
-	ret->file = filepath;
-	ret->type = strdup ("ROM");
-	ret->machine = strdup ("Nintendo DS");
-	ret->os = strdup ("nds");
-	ret->arch = strdup ("arm");
-	ret->has_va = true;
-	ret->bits = 32;
 	return ret;
 }
 
 RBinPlugin r_bin_plugin_ninds = {
 	.name = "ninds",
 	.desc = "Nintendo DS format r_bin plugin",
 	.license = "LGPL3",
 	.load = &load,
-	.load_bytes = &load_bytes,
-	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.boffset = &boffset,
 	.entries = &entries,
 	.sections = &sections,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_ningb.c b/libr/bin/p/bin_ningb.c
index 876e008921..805609e46d 100644
--- a/libr/bin/p/bin_ningb.c
+++ b/libr/bin/p/bin_ningb.c
@@ -7,34 +7,17 @@
 #include <string.h>
 #include "../format/nin/nin.h"
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	return true;
-}
-
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	ut8 lict[48];
-	if (!buf || length < (0x104 + 48)) {
-		return 0;
+static bool check_buffer(RBuffer *b) {
+	ut8 lict[sizeof (lic)];
+	if (r_buf_read_at (b, 0x104, lict, sizeof (lict)) == sizeof (lict)) {
+		return !memcmp (lict, lic, sizeof (lict));
 	}
-	memcpy (lict, buf + 0x104, 48);
-	return (!memcmp (lict, lic, 48))? 1: 0;
+	return false;
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	ut64 la = bf->o->loadaddr;
-	load_bytes (bf, &bf->o->bin_obj, bytes, sz, la, bf->sdb);
-	return check_bytes (bytes, sz);
-}
-
-static int destroy(RBinFile *bf) {
-	r_buf_free (bf->buf);
-	bf->buf = NULL;
-	return true;
+	r_return_val_if_fail (bf && bf->o, false);
+	return check_buffer (bf->buf);
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -304,18 +287,16 @@ RList *mem (RBinFile *bf) {
 RBinPlugin r_bin_plugin_ningb = {
 	.name = "ningb",
 	.desc = "Gameboy format r_bin plugin",
 	.license = "LGPL3",
 	.load = &load,
-	.load_bytes = &load_bytes,
-	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.info = &info,
 	.mem = &mem,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_ningba.c b/libr/bin/p/bin_ningba.c
index f4f6200e0d..f721f0419b 100644
--- a/libr/bin/p/bin_ningba.c
+++ b/libr/bin/p/bin_ningba.c
@@ -1,35 +1,22 @@
-/* radare - LGPL - 2014-2015 - condret@runas-racer.com */
+/* radare - LGPL - 2014-2019 - condret@runas-racer.com */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include <string.h>
 #include "../format/nin/gba.h"
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
+static bool check_buffer(RBuffer *b) {
 	ut8 lict[156];
-	if (!buf || length < 160) {
-		return 0;
-	}
-	memcpy (lict, buf + 0x4, 156);
-	return (!memcmp (lict, lic_gba, 156))? 1: 0;
+	r_return_val_if_fail (b, false);
+	r_buf_read_at (b, 4, (ut8*)lict, sizeof (lict));
+	return !memcmp (lict, lic_gba, 156);
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	bf->rbin->maxstrbuf = 0x20000000;
-	return check_bytes (bytes, sz);
-}
-
-static int destroy(RBinFile *bf) {
-	r_buf_free (bf->buf);
-	bf->buf = NULL;
-	return true;
+	r_return_val_if_fail (bf && bf->o, false);
+	return check_buffer (bf->buf);
 }
 
 static RList *entries(RBinFile *bf) {
@@ -99,13 +86,12 @@ static RList *sections(RBinFile *bf) {
 RBinPlugin r_bin_plugin_ningba = {
 	.name = "ningba",
 	.desc = "Game Boy Advance format r_bin plugin",
 	.license = "LGPL3",
 	.load = &load,
-	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.entries = &entries,
 	.info = &info,
 	.sections = &sections,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_nro.c b/libr/bin/p/bin_nro.c
index e634821a7c..2ccc70c229 100644
--- a/libr/bin/p/bin_nro.c
+++ b/libr/bin/p/bin_nro.c
@@ -1,13 +1,13 @@
-/* radare2 - LGPL - Copyright 2017-2018 - pancake */
+/* radare2 - LGPL - Copyright 2017-2019 - pancake */
 
 // TODO: Support NRR and MODF
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include "nxo/nxo.h"
 
 #define NRO_OFF(x) (sizeof (NXOStart) + r_offsetof (NROHeader, x))
 #define NRO_OFFSET_MODMEMOFF r_offsetof (NXOStart, mod_memoffset)
 
 // starting at 0x10 (16th byte)
@@ -30,41 +30,33 @@ static ut64 baddr(RBinFile *bf) {
 	return bf? readLE32 (bf->buf, NRO_OFFSET_MODMEMOFF): 0;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (buf && length >= 0x20) {
-		return fileType (buf + NRO_OFF (magic)) != NULL;
+static bool check_buffer(RBuffer *b) {
+	ut8 magic[4];
+	if (r_buf_read_at (b, NRO_OFF (magic), magic, sizeof (magic)) == 4) {
+		return fileType (magic) != NULL;
 	}
 	return false;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {
+	// XX bf->buf vs b :D this load_b
 	RBinNXOObj *bin = R_NEW0 (RBinNXOObj);
-	if (!bin) {
-		return false;
+	if (bin) {
+		ut64 ba = baddr (bf);
+		bin->methods_list = r_list_newf ((RListFree)free);
+		bin->imports_list = r_list_newf ((RListFree)free);
+		bin->classes_list = r_list_newf ((RListFree)free);
+		ut32 mod0 = readLE32 (b, NRO_OFFSET_MODMEMOFF);
+		parseMod (b, bin, mod0, ba);
+		*bin_obj = bin;
 	}
-	ut64 ba = baddr (bf);
-	bin->methods_list = r_list_newf ((RListFree)free);
-	bin->imports_list = r_list_newf ((RListFree)free);
-	bin->classes_list = r_list_newf ((RListFree)free);
-	ut32 mod0 = readLE32 (bf->buf, NRO_OFFSET_MODMEMOFF);
-	parseMod (bf->buf, bin, mod0, ba);
-	*bin_obj = bin;
 	return true;
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->buf || !bf->o) {
-		return false;
-	}
-	ut64 sz;
+	r_return_val_if_fail (bf && bf->buf && bf->o, false);
 	const ut64 la = bf->o->loadaddr;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	load_bytes (bf, &bf->o->bin_obj, bytes, sz, la, bf->sdb);
-	return bf->o->bin_obj != NULL;
-}
-
-static int destroy(RBinFile *bf) {
-	return true;
+	return load_buffer (bf, &bf->o->bin_obj, bf->buf, la, bf->sdb);
 }
 
 static RBinAddr *binsym(RBinFile *bf, int type) {
@@ -269,20 +261,19 @@ static RBinInfo *info(RBinFile *bf) {
 RBinPlugin r_bin_plugin_nro = {
 	.name = "nro",
 	.desc = "Nintendo Switch NRO0 binaries",
 	.license = "MIT",
 	.load = &load,
-	.load_bytes = &load_bytes,
-	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.get_sdb = &get_sdb,
 	.symbols = &symbols,
 	.imports = &imports,
 	.info = &info,
 	.libs = &libs,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_nso.c b/libr/bin/p/bin_nso.c
index b8c0ae0a03..50780d934b 100644
--- a/libr/bin/p/bin_nso.c
+++ b/libr/bin/p/bin_nso.c
@@ -47,9 +47,13 @@ static ut64 baddr(RBinFile *bf) {
 	return 0x8000000;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (buf && length >= 0x20) {
-		return fileType (buf + NSO_OFF (magic)) != NULL;
+static bool check_buffer(RBuffer *b) {
+	if (r_buf_size (b) >= 0x20) {
+		ut8 magic[4];
+		if (r_buf_read_at (b, 0, magic, sizeof (magic)) != 4) {
+			return false;
+		}
+		return fileType (magic) != NULL;
 	}
 	return false;
 }
@@ -63,63 +67,64 @@ static RBinNXOObj *nso_new () {
 }
 
 static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
+	eprintf ("load_bytes in bin.nso must die\n");
 	RBin *rbin = bf->rbin;
 	ut32 toff = readLE32 (bf->buf, NSO_OFF (text_memoffset));
 	ut32 tsize = readLE32 (bf->buf, NSO_OFF (text_size));
 	ut32 rooff = readLE32 (bf->buf, NSO_OFF (ro_memoffset));
 	ut32 rosize = readLE32 (bf->buf, NSO_OFF (ro_size));
 	ut32 doff = readLE32 (bf->buf, NSO_OFF (data_memoffset));
 	ut32 dsize = readLE32 (bf->buf, NSO_OFF (data_size));
 	ut64 total_size = tsize + rosize + dsize;
 	RBuffer *newbuf = r_buf_new_empty (total_size);
 	ut64 ba = baddr (bf);
 	ut8 *tmp = NULL;
 
 	if (rbin->iob.io && !(rbin->iob.io->cached & R_PERM_W)) {
 		eprintf ("Please add \'-e io.cache=true\' option to r2 command. This is required to decompress the code.\n");
 		goto fail;
 	}
 	/* Decompress each sections */
 	tmp = R_NEWS (ut8, tsize);
 	if (!tmp) {
 		goto fail;
 	}
 	if (decompress (buf + toff, tmp, rooff - toff, tsize) != tsize) {
 		eprintf ("decompression failure\n");
 		goto fail;
 	}
 	r_buf_write_at (newbuf, 0, tmp, tsize);
 	R_FREE (tmp);
 
 	tmp = R_NEWS (ut8, rosize);
 	if (!tmp) {
 		goto fail;
 	}
 	if (decompress (buf + rooff, tmp, doff - rooff, rosize) != rosize) {
 		eprintf ("decompression2 failure\n");
 		goto fail;
 	}
 	r_buf_write_at (newbuf, tsize, tmp, rosize);
 	R_FREE (tmp);
 
 	tmp = R_NEWS (ut8, dsize);
 	if (!tmp) {
 		goto fail;
 	}
 	if (decompress (buf + doff, tmp, r_buf_size (bf->buf) - doff, dsize) != dsize) {
 		eprintf ("decompression3 failure\n");
 		goto fail;
 	}
 	r_buf_write_at (newbuf, tsize + rosize, tmp, dsize);
 	R_FREE (tmp);
 
 	/* Load unpacked binary */
 	const ut8 *tmpbuf = r_buf_data (newbuf, &total_size);
 	r_io_write_at (rbin->iob.io, ba, tmpbuf, total_size);
 	ut32 modoff = readLE32 (newbuf, NSO_OFFSET_MODMEMOFF);
 	RBinNXOObj *bin = nso_new ();
 	eprintf ("MOD Offset = 0x%"PFMT64x"\n", (ut64)modoff);
 	parseMod (newbuf, bin, modoff, ba);
 	r_buf_free (newbuf);
 	*bin_obj = bin;
 	return true;
@@ -130,23 +135,13 @@ fail:
 	return false;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	r_return_val_if_fail (bf && buf, NULL);
-	const ut64 sz = r_buf_size (buf);
-	ut8 *bytes = malloc (sz);
-	if (!bytes) {
-		return NULL;
-	}
-	r_buf_read_at (buf, 0, bytes, sz);
-	void *ptr = NULL;
 	const ut64 la = bf->loadaddr;
-	(void)load_bytes (bf, &ptr, bytes, sz, la, bf->sdb);
-	free (bytes);
-	return ptr;
-}
-
-static int destroy(RBinFile *bf) {
-	return true;
+	ut64 sz = 0;
+	const ut8 *bytes = r_buf_data (buf, &sz);
+	bool res = load_bytes (bf, bin_obj, bytes, sz, la, bf->sdb);
+	return res;
 }
 
 static RBinAddr *binsym(RBinFile *bf, int type) {
@@ -286,16 +281,15 @@ static RBinInfo *info(RBinFile *bf) {
 RBinPlugin r_bin_plugin_nso = {
 	.name = "nso",
 	.desc = "Nintendo Switch NSO0 binaries",
 	.license = "MIT",
 	.load_buffer = &load_buffer,
-	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.get_sdb = &get_sdb,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_omf.c b/libr/bin/p/bin_omf.c
index d4baa9918e..1c51c330fe 100644
--- a/libr/bin/p/bin_omf.c
+++ b/libr/bin/p/bin_omf.c
@@ -1,34 +1,52 @@
-/* radare - LGPL - Copyright 2015-2018 - ampotos, pancake */
+/* radare - LGPL - Copyright 2015-2019 - ampotos, pancake */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include "omf/omf.h"
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 size, ut64 loadaddrn, Sdb *sdb) {
-	if (!buf || !size || size == UT64_MAX) {
-		return false;
-	}
+static bool load_buffer (RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {
+	ut64 size;
+	const ut8 *buf = r_buf_data (b, &size);
 	*bin_obj = r_bin_internal_omf_load (buf, size);
-	return true;
+	return *bin_obj != NULL;
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-	ut64 size;
-	const ut8 *byte = r_buf_data (bf->buf, &size);
-	return load_bytes (bf, &bf->o->bin_obj, byte, size, bf->o->loadaddr, bf->sdb);
+	r_return_val_if_fail (bf && bf->o, false);
+	return load_buffer (bf, &bf->o->bin_obj, bf->buf, bf->o->loadaddr, bf->sdb);
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_bin_free_all_omf_obj (bf->o->bin_obj);
 	bf->o->bin_obj = NULL;
-	return true;
 }
 
+static bool check_buffer(RBuffer *b) {
+	int i;
+	ut8 ch;
+	if (r_buf_read_at (b, 0, &ch, 1) != 1) {
+		return false;
+	}
+	if (ch != 0x80 && ch != 0x82) {
+		return false;
+	}
+	ut64 length = 0;
+	const ut8 *buf = r_buf_data (b, &length);
+	ut16 rec_size = ut8p_bw (buf + 1);
+	ut8 str_size = *(buf + 3);
+	if (str_size + 2 != rec_size || length < rec_size + 3) {
+		return false;
+	}
+	// check that the string is ASCII
+	for (i = 4; i < str_size + 4; ++i) {
+		if (buf[i] > 0x7f) {
+			return false;
+		}
+	}
+	return r_bin_checksum_omf_ok (buf, length);
+}
 static bool check_bytes(const ut8 *buf, ut64 length) {
 	int i;
 	if (!buf || length < 4) {
@@ -156,17 +174,17 @@ static ut64 get_vaddr(RBinFile *bf, ut64 baddr, ut64 paddr, ut64 vaddr) {
 RBinPlugin r_bin_plugin_omf = {
 	.name = "omf",
 	.desc = "omf bin plugin",
 	.license = "LGPL3",
 	.load = &load,
-	.load_bytes = &load_bytes,
+	.load_buffer = &load_buffer,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.info = &info,
 	.get_vaddr = &get_vaddr,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_p9.c b/libr/bin/p/bin_p9.c
index 6051365390..8f982a1583 100644
--- a/libr/bin/p/bin_p9.c
+++ b/libr/bin/p/bin_p9.c
@@ -1,7 +1,7 @@
-/* radare2 - LGPL - Copyright 2009-2017 - nibble, pancake */
+/* radare2 - LGPL - Copyright 2009-2019 - nibble, pancake */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include "../format/p9/p9bin.h"
@@ -17,16 +17,12 @@ static bool check_bytes(const ut8 *b, ut64 length) {
 	return res;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb){
-	if (!check_buffer (buf)) {
-		return NULL;
-	}
-	return r_buf_new ();
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb){
+	return check_buffer (b);
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_buf_free (bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
diff --git a/libr/bin/p/bin_pe.c b/libr/bin/p/bin_pe.c
index c348ad2c59..3e1a24b31f 100644
--- a/libr/bin/p/bin_pe.c
+++ b/libr/bin/p/bin_pe.c
@@ -2,28 +2,31 @@
 
 #include "bin_pe.inc"
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	unsigned int idx;
-	if (!buf || length <= 0x3d) {
+static bool check_buffer(RBuffer *b) {
+	ut64 length = r_buf_size (b);
+	if (length <= 0x3d) {
 		return false;
 	}
-	idx = (buf[0x3c] | (buf[0x3d]<<8));
-	if (length > idx + 0x18 + 2) {
+	ut16 idx = r_buf_read_le16_at (b, 0x3c);
+	if (idx + 26 < length) {
 		/* Here PE signature for usual PE files
 		 * and PL signature for Phar Lap TNT DOS extender 32bit executables
 		 */
+		ut8 buf[2];
+		r_buf_read_at (b, 0, buf, sizeof (buf));
 		if (!memcmp (buf, "MZ", 2)) {
-			if (!memcmp (buf+idx, "PE", 2) &&
-				!memcmp (buf + idx + 0x18, "\x0b\x01", 2)) {
-				return true;
-			}
+			r_buf_read_at (b, idx, buf, sizeof (buf));
 			// TODO: Add one more indicator, to prevent false positives
-			if (!memcmp (buf+idx, "PL", 2)) {
+			if (!memcmp (buf, "PL", 2)) {
 				return true;
 			}
+			if (!memcmp (buf, "PE", 2)) {
+				r_buf_read_at (b, idx + 0x18, buf, sizeof (buf));
+				return !memcmp (buf, "\x0b\x01", 2);
+			}
 		}
 	}
 	return false;
 }
 
 /* inspired in http://www.phreedom.org/solar/code/tinype/tiny.97/tiny.asm */
@@ -390,29 +393,28 @@ extern struct r_bin_write_t r_bin_write_pe;
 RBinPlugin r_bin_plugin_pe = {
 	.name = "pe",
 	.desc = "PE bin plugin",
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
 	.load = &load,
 	.load_buffer = &load_buffer,
-	.load_bytes = &load_bytes,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.signature = &signature,
 	.symbols = &symbols,
 	.imports = &imports,
 	.info = &info,
 	.header = &header,
 	.fields = &fields,
 	.libs = &libs,
 	.relocs = &relocs,
 	.minstrlen = 4,
 	.create = &create,
 	.get_vaddr = &get_vaddr,
 	.write = &r_bin_write_pe
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_pe.inc b/libr/bin/p/bin_pe.inc
index 5fbf088c5f..4c2e8ef687 100644
--- a/libr/bin/p/bin_pe.inc
+++ b/libr/bin/p/bin_pe.inc
@@ -17,49 +17,24 @@ static Sdb* get_sdb (RBinFile *bf) {
 	return bin? bin->kv: NULL;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
-	struct PE_(r_bin_pe_obj_t) *res = NULL;
-	RBuffer *tbuf = NULL;
-	if (!buf || !sz || sz == UT64_MAX) {
-		return false;
-	}
-	tbuf = r_buf_new ();
-	r_buf_set_bytes (tbuf, buf, sz);
-	res = PE_(r_bin_pe_new_buf) (tbuf, bf->rbin->verbose);
-	if (res) {
-		sdb_ns_set (sdb, "info", res->kv);
-	}
-	r_buf_free (tbuf);
-	*bin_obj = res;
-	return true;
-}
-
-static void * load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
-	struct PE_(r_bin_pe_obj_t) *res;
-	if (!buf) {
-		return NULL;
-	}
-	res = PE_(r_bin_pe_new_buf) (buf, bf->rbin->verbose);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+	r_return_val_if_fail (bf && bin_obj && buf, false);
+	struct PE_(r_bin_pe_obj_t) *res = PE_(r_bin_pe_new_buf) (buf, bf->rbin->verbose);
 	if (res) {
 		sdb_ns_set (sdb, "info", res->kv);
+		*bin_obj = res;
+		return true;
 	}
-	return res;
+	return false;
 }
 
 static bool load(RBinFile *bf) {
-	const ut8 *bytes;
-	ut64 sz;
-
-	if (!bf || !bf->o) {
-		return false;
-	}
-	bytes = r_buf_data (bf->buf, &sz);
-	return load_bytes (bf, &bf->o->bin_obj, bytes, sz, bf->o->loadaddr, bf->sdb);
+	r_return_val_if_fail (bf && bf->o, false);
+	return load_buffer (bf, &bf->o->bin_obj, bf->buf, bf->o->loadaddr, bf->sdb);
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	PE_(r_bin_pe_free) ((struct PE_(r_bin_pe_obj_t)*)bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -462,85 +437,85 @@ static int haschr(const RBinFile* bf, ut16 dllCharacteristic) {
 static RBinInfo* info(RBinFile *bf) {
 	struct PE_ (r_bin_pe_obj_t) *bin;
 	SDebugInfo di = {{0}};
 	RBinInfo *ret = R_NEW0 (RBinInfo);
 	ut32 claimed_checksum, actual_checksum, pe_overlay;
 
 	if (!ret) {
 		return NULL;
 	}
 	bin = bf->o->bin_obj;
 	ret->file = strdup (bf->file);
 	ret->bclass = PE_(r_bin_pe_get_class) (bf->o->bin_obj);
 	ret->rclass = strdup ("pe");
 	ret->os = PE_(r_bin_pe_get_os) (bf->o->bin_obj);
 	ret->arch = PE_(r_bin_pe_get_arch) (bf->o->bin_obj);
 	ret->machine = PE_(r_bin_pe_get_machine) (bf->o->bin_obj);
 	ret->subsystem = PE_(r_bin_pe_get_subsystem) (bf->o->bin_obj);
 	if (is_dot_net (bf)) {
 		ret->lang = "cil";
 	}
 	if (is_vb6 (bf)) {
 		ret->lang = "vb";
 	}
 	if (PE_(r_bin_pe_is_dll) (bf->o->bin_obj)) {
 		ret->type = strdup ("DLL (Dynamic Link Library)");
 	} else {
 		ret->type = strdup ("EXEC (Executable file)");
 	}
 	claimed_checksum = PE_(bin_pe_get_claimed_checksum) (bf->o->bin_obj);
 	actual_checksum  = PE_(bin_pe_get_actual_checksum) (bf->o->bin_obj);
 	pe_overlay = sdb_num_get (bf->sdb, "pe_overlay.size", 0);
 	ret->bits = PE_(r_bin_pe_get_bits) (bf->o->bin_obj);
 	ret->big_endian = PE_(r_bin_pe_is_big_endian) (bf->o->bin_obj);
 	ret->dbg_info = 0;
 	ret->has_lit = true;
 	ret->has_canary = has_canary (bf);
 	ret->has_nx = haschr (bf, IMAGE_DLL_CHARACTERISTICS_NX_COMPAT);
 	ret->has_pi = haschr (bf, IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE);
 	ret->claimed_checksum = strdup (sdb_fmt ("0x%08x", claimed_checksum));
 	ret->actual_checksum  = strdup (sdb_fmt ("0x%08x", actual_checksum));
 	ret->pe_overlay = pe_overlay > 0;
 	ret->signature = bin ? bin->is_signed : false;
-
-	sdb_bool_set (bf->sdb, "pe.canary", has_canary(bf), 0);
-	sdb_bool_set (bf->sdb, "pe.highva", haschr(bf, IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA), 0);
-	sdb_bool_set (bf->sdb, "pe.aslr", haschr(bf, IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE), 0);
-	sdb_bool_set (bf->sdb, "pe.forceintegrity", haschr(bf, IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY), 0);
-	sdb_bool_set (bf->sdb, "pe.nx", haschr(bf, IMAGE_DLL_CHARACTERISTICS_NX_COMPAT), 0);
-	sdb_bool_set (bf->sdb, "pe.isolation", !haschr(bf, IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY), 0);
-	sdb_bool_set (bf->sdb, "pe.seh", !haschr(bf, IMAGE_DLLCHARACTERISTICS_NO_SEH), 0);
-	sdb_bool_set (bf->sdb, "pe.bind", !haschr(bf, IMAGE_DLLCHARACTERISTICS_NO_BIND), 0);
-	sdb_bool_set (bf->sdb, "pe.appcontainer", haschr(bf, IMAGE_DLLCHARACTERISTICS_APPCONTAINER), 0);
-	sdb_bool_set (bf->sdb, "pe.wdmdriver", haschr(bf, IMAGE_DLLCHARACTERISTICS_WDM_DRIVER), 0);
-	sdb_bool_set (bf->sdb, "pe.guardcf", haschr(bf, IMAGE_DLLCHARACTERISTICS_GUARD_CF), 0);
-	sdb_bool_set (bf->sdb, "pe.terminalserveraware", haschr(bf, IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE), 0);
-	sdb_num_set (bf->sdb, "pe.bits", ret->bits, 0);
-	sdb_set (bf->sdb, "pe.claimed_checksum", ret->claimed_checksum, 0);
-	sdb_set (bf->sdb, "pe.actual_checksum", ret->actual_checksum, 0);
+	Sdb *db = sdb_ns (bf->sdb, "pe", true);
+	sdb_bool_set (db, "canary", has_canary (bf), 0);
+	sdb_bool_set (db, "highva", haschr (bf, IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA), 0);
+	sdb_bool_set (db, "aslr", haschr (bf, IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE), 0);
+	sdb_bool_set (db, "forceintegrity", haschr (bf, IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY), 0);
+	sdb_bool_set (db, "nx", haschr (bf, IMAGE_DLL_CHARACTERISTICS_NX_COMPAT), 0);
+	sdb_bool_set (db, "isolation", !haschr (bf, IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY), 0);
+	sdb_bool_set (db, "seh", !haschr (bf, IMAGE_DLLCHARACTERISTICS_NO_SEH), 0);
+	sdb_bool_set (db, "bind", !haschr (bf, IMAGE_DLLCHARACTERISTICS_NO_BIND), 0);
+	sdb_bool_set (db, "appcontainer", haschr (bf, IMAGE_DLLCHARACTERISTICS_APPCONTAINER), 0);
+	sdb_bool_set (db, "wdmdriver", haschr (bf, IMAGE_DLLCHARACTERISTICS_WDM_DRIVER), 0);
+	sdb_bool_set (db, "guardcf", haschr (bf, IMAGE_DLLCHARACTERISTICS_GUARD_CF), 0);
+	sdb_bool_set (db, "terminalserveraware", haschr (bf, IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE), 0);
+	sdb_num_set (db, "bits", ret->bits, 0);
+	sdb_set (db, "claimed_checksum", ret->claimed_checksum, 0);
+	sdb_set (db, "actual_checksum", ret->actual_checksum, 0);
 
 	ret->has_va = true;
 
 	if (PE_(r_bin_pe_is_stripped_debug) (bf->o->bin_obj)) {
 		ret->dbg_info |= R_BIN_DBG_STRIPPED;
 	}
 	if (PE_(r_bin_pe_is_stripped_line_nums) (bf->o->bin_obj)) {
 		ret->dbg_info |= R_BIN_DBG_LINENUMS;
 	}
 	if (PE_(r_bin_pe_is_stripped_local_syms) (bf->o->bin_obj)) {
 		ret->dbg_info |= R_BIN_DBG_SYMS;
 	}
 	if (PE_(r_bin_pe_is_stripped_relocs) (bf->o->bin_obj)) {
 		ret->dbg_info |= R_BIN_DBG_RELOCS;
 	}
 	if (PE_(r_bin_pe_get_debug_data)(bf->o->bin_obj, &di)) {
 		ret->guid = r_str_ndup (di.guidstr, GUIDSTR_LEN);
 		if (ret->guid) {
 			ret->debug_file_name = r_str_ndup (di.file_name, DBG_FILE_NAME_LEN);
 			if (!ret->debug_file_name) {
 				R_FREE (ret->guid);
 			}
 		}
 	}
 
 	return ret;
 }
diff --git a/libr/bin/p/bin_pe64.c b/libr/bin/p/bin_pe64.c
index 97699bf710..8f3002a02b 100644
--- a/libr/bin/p/bin_pe64.c
+++ b/libr/bin/p/bin_pe64.c
@@ -1,20 +1,30 @@
-/* radare - LGPL - Copyright 2009-2015 - nibble, pancake */
+/* radare - LGPL - Copyright 2009-2019 - nibble, pancake */
 #define R_BIN_PE64 1
 #include "bin_pe.inc"
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	int idx, ret = false;
-	if (!buf || length <= 0x3d) {
+static bool check_buffer(RBuffer *b) {
+	ut64 length = r_buf_size (b);
+	if (length <= 0x3d) {
 		return false;
 	}
-	idx = buf[0x3c] | (buf[0x3d] << 8);
-	if (length >= idx + 0x20) {
-		if (!memcmp (buf, "MZ", 2) && !memcmp (buf + idx, "PE", 2) &&
-			!memcmp (buf + idx + 0x18, "\x0b\x02", 2)) {
-			ret = true;
+	ut16 idx = r_buf_read_le16_at (b, 0x3c);
+	if (idx + 26 < length) {
+		/* Here PE signature for usual PE files
+		 * and PL signature for Phar Lap TNT DOS extender 32bit executables
+		 */
+		ut8 buf[2];
+		r_buf_read_at (b, 0, buf, sizeof (buf));
+		if (!memcmp (buf, "MZ", 2)) {
+			r_buf_read_at (b, idx, buf, sizeof (buf));
+			// TODO: Add one more indicator, to prevent false positives
+			// if (!memcmp (buf, "PL", 2)) { return true; }
+			if (!memcmp (buf, "PE", 2)) {
+				r_buf_read_at (b, idx + 0x18, buf, sizeof (buf));
+				return !memcmp (buf, "\x0b\x02", 2);
+			}
 		}
 	}
-	return ret;
+	return false;
 }
 
 static void header(RBinFile *bf) {
@@ -123,25 +133,24 @@ extern struct r_bin_write_t r_bin_write_pe64;
 RBinPlugin r_bin_plugin_pe64 = {
 	.name = "pe64",
 	.desc = "PE64 (PE32+) bin plugin",
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
 	.load = &load,
 	.load_buffer = &load_buffer,
-	.load_bytes = &load_bytes,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.imports = &imports,
 	.info = &info,
 	.header = &header,
 	.libs = &libs,
 	.relocs = &relocs,
 	.get_vaddr = &get_vaddr,
 	.write = &r_bin_write_pe64
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_pebble.c b/libr/bin/p/bin_pebble.c
index e1029e50bb..d466a1915e 100644
--- a/libr/bin/p/bin_pebble.c
+++ b/libr/bin/p/bin_pebble.c
@@ -1,11 +1,11 @@
-/* radare - LGPL - Copyright 2014-2015 - pancake */
+/* radare - LGPL - Copyright 2014-2019 - pancake */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 
 // Taken from https://pebbledev.org/wiki/Applications
 
 #define APP_NAME_BYTES 32
 #define COMPANY_NAME_BYTES 32
@@ -18,40 +18,37 @@ typedef struct  {
 
 R_PACKED (
 typedef struct  {
-	char header[8];                   //!< Sentinal value, should always be 'PBLAPP\0\0'
-	Version struct_version;           //!< version of this structure's format
-	Version sdk_version;              //!< version of the SDK used to build this app
-	Version app_version;              //!< version of the app
+	char header[8];               //!< Sentinal value, should always be 'PBLAPP\0\0'
+	Version struct_version;       //!< version of this structure's format
+	Version sdk_version;          //!< version of the SDK used to build this app
+	Version app_version;          //!< version of the app
 	ut16 size;                    //!< size of the app binary, including this metadata but not the reloc table
 	ut32 offset;                  //!< The entry point of this executable
 	ut32 crc;                     //!< CRC of the app data only, ie, not including this struct or the reloc table at the end
 	char name[APP_NAME_BYTES];        //!< Name to display on the menu
 	char company[COMPANY_NAME_BYTES]; //!< Name of the maker of this app
 	ut32 icon_resource_id;        //!< Resource ID within this app's bank to use as a 32x32 icon
 	ut32 sym_table_addr;          //!< The system will poke the sdk's symbol table address into this field on load
 	ut32 flags;                   //!< Bitwise OR of PebbleAppFlags
 	ut32 reloc_list_start;        //!< The offset of the address relocation list
 	ut32 num_reloc_entries;       //!< The number of entries in the address relocation list
 	ut8 uuid[16];
 }) PebbleAppInfo;
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	return (length > 7 && !memcmp (buf, "PBLAPP\x00\x00", 8));
+static bool check_buffer(RBuffer *b) {
+	ut8 magic[8];
+	if (r_buf_read_at (b, 0, magic, sizeof (magic)) != sizeof (magic)) {
+		return false;
+	}
+	return !memcmp (magic, "PBLAPP\x00\x00", 8);
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	return check_bytes (buf, sz);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb){
+	return check_buffer (b);
 }
 
 static bool load(RBinFile *bf) {
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	return check_bytes (bytes, sz);
-}
-
-static int destroy(RBinFile *bf) {
-	//r_bin_pebble_free ((struct r_bin_pebble_obj_t*)bf->o->bin_obj);
-	return true;
+	return check_buffer (bf->buf);
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -193,17 +190,16 @@ static RList* entries(RBinFile *bf) {
 RBinPlugin r_bin_plugin_pebble = {
 	.name = "pebble",
 	.desc = "Pebble Watch App",
 	.license = "LGPL",
 	.load = &load,
-	.load_bytes = &load_bytes,
-	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.entries = entries,
 	.sections = sections,
 	.strings = &strings,
 	.info = &info,
 	//.relocs = &relocs
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_psxexe.c b/libr/bin/p/bin_psxexe.c
index 82f724d3f9..20d9328b2e 100644
--- a/libr/bin/p/bin_psxexe.c
+++ b/libr/bin/p/bin_psxexe.c
@@ -7,15 +7,16 @@
 #include "../i/private.h"
 #include "psxexe/psxexe.h"
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (!buf || (length < PSXEXE_ID_LEN)) {
-		return false;
+static bool check_buffer(RBuffer *b) {
+	ut8 magic[PSXEXE_ID_LEN];
+	if (r_buf_read_at (b, 0, magic, sizeof (magic)) == PSXEXE_ID_LEN) {
+		return !memcmp (magic, PSXEXE_ID, PSXEXE_ID_LEN);
 	}
-	return !memcmp (buf, PSXEXE_ID, PSXEXE_ID_LEN);
+	return false;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
-	return check_bytes (buf, sz);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {
+	return check_buffer (b);
 }
 
 static RBinInfo* info(RBinFile* bf) {
@@ -114,13 +115,13 @@ static RList* strings(RBinFile* bf) {
 RBinPlugin r_bin_plugin_psxexe = {
 	.name = "psxexe",
 	.desc = "Sony PlayStation 1 Executable",
 	.license = "LGPL3",
-	.load_bytes = &load_bytes,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.info = &info,
 	.sections = &sections,
 	.entries = &entries,
 	.strings = &strings,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_qnx.c b/libr/bin/p/bin_qnx.c
index b0a984a064..e540abebb6 100644
--- a/libr/bin/p/bin_qnx.c
+++ b/libr/bin/p/bin_qnx.c
@@ -31,119 +31,115 @@ static bool check_buffer(RBuffer *buf) {
 	return r == sizeof (tmp) && !memcmp (tmp, QNX_MAGIC, sizeof (tmp));
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	RBuffer *b = r_buf_new_with_bytes (buf, length);
-	bool res = check_buffer (b);
-	r_buf_free (b);
-	return res;
-}
-
 // Frees the bin_obj of the binary file
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	QnxObj *qo = bf->o->bin_obj;
 	r_list_free (qo->sections);
 	r_list_free (qo->fixups);
 	bf->o->bin_obj = NULL;
 	free (qo);
-	return true;
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	QnxObj *qo = R_NEW0 (QnxObj);
+	if (!qo) {
+		return false;
+	}
 	lmf_record lrec;
 	lmf_resource lres;
 	lmf_data ldata;
 	ut64 offset = QNX_RECORD_SIZE;
 	RList *sections = NULL;
 	RList *fixups = NULL;
 
 	if (!qo) {
 		goto beach;
 	}
 	if (!(sections = r_list_newf ((RListFree)r_bin_section_free)) || !(fixups = r_list_new ())) {
 		goto beach;
 	}
 	qo->kv = sdb_new0 ();
 	if (!qo->kv) {
 		free (qo);
 		goto beach;
 	}
 	// Read the first record
 	if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, "ccss", 1) < QNX_RECORD_SIZE) {
 		goto beach;
 	}
 	// Load the header
 	lmf_header_load (&qo->lmfh, bf->buf, qo->kv);
 	offset += lrec.data_nbytes;
 
 	for (;;) {
 		if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, "ccss", 1) < QNX_RECORD_SIZE) {
 			goto beach;
 		}
 		offset += sizeof (lmf_record);
 
 		if (lrec.rec_type == LMF_IMAGE_END_REC) {
 			break;
 		} else if (lrec.rec_type == LMF_RESOURCE_REC) {
 			RBinSection *ptr = R_NEW0 (RBinSection);
 			if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, "ssss", 1) < sizeof (lmf_resource)) {
 				goto beach;
 			}
 			if (!ptr) {
 				goto beach;
 			}
 			ptr->name = strdup ("LMF_RESOURCE");
 			ptr->paddr = offset;
 			ptr->vsize = lrec.data_nbytes - sizeof (lmf_resource);
 			ptr->size = ptr->vsize;
 			ptr->add = true;
 		 	r_list_append (sections, ptr);
 		} else if (lrec.rec_type == LMF_LOAD_REC) {
 			RBinSection *ptr = R_NEW0 (RBinSection);
 			if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, "si", 1) < sizeof (lmf_data)) {
 				goto beach;
 			}
 			if (!ptr) {
 				goto beach;
 			}
 			ptr->name = strdup ("LMF_LOAD");
 			ptr->paddr = offset;
 			ptr->vaddr = ldata.offset;
 			ptr->vsize = lrec.data_nbytes - sizeof (lmf_data);
 			ptr->size = ptr->vsize;
 			ptr->add = true;
 		 	r_list_append (sections, ptr);
 		} else if (lrec.rec_type == LMF_FIXUP_REC) {
 			RBinReloc *ptr = R_NEW0 (RBinReloc);
 			if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, "si", 1) < sizeof (lmf_data)) {
 				goto beach;
 			}
 			ptr->vaddr = ptr->paddr = ldata.offset;
 			ptr->type = 'f'; // "LMF_FIXUP";
 			r_list_append (fixups, ptr);
 		} else if (lrec.rec_type == LMF_8087_FIXUP_REC) {
 			RBinReloc *ptr = R_NEW0 (RBinReloc);
 			if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, "si", 1) < sizeof (lmf_data)) {
 				goto beach;
 			}
 			ptr->vaddr = ptr->paddr = ldata.offset;
 			ptr->type = 'F'; // "LMF_8087_FIXUP";
 			r_list_append (fixups, ptr);
 		} else if (lrec.rec_type == LMF_RW_END_REC) {
 			r_buf_fread_at (bf->buf, offset, (ut8 *)&qo->rwend, "si", 1);
 		}
 		offset += lrec.data_nbytes;
 	}
 	sdb_ns_set (sdb, "info", qo->kv);
 	qo->sections = sections;
 	qo->fixups = fixups;
-	return qo;
+	*bin_obj = qo;
+	return true;
 beach:
-	return NULL;
+	return false;
 }
 
 /*
  * Provides the info about the binary file
  * @param RBinFile to extract the data from
  * @return RBinInfo file with the info
  */
@@ -272,23 +268,22 @@ static ut64 get_vaddr(RBinFile *bf, ut64 baddr, ut64 paddr, ut64 vaddr) {
 // Declaration of the plugin
 RBinPlugin r_bin_plugin_qnx = {
 	.name = "qnx",
 	.desc = "QNX executable file support",
 	.license = "LGPL3",
 	.load_buffer = &load_buffer,
 	.destroy = &destroy,
 	.relocs = &relocs,
 	.baddr = &baddr,
 	.author = "deepakchethan",
 	.check_buffer = &check_buffer,
-	.check_bytes  = &check_bytes,
 	.header = &header,
 	.get_sdb = &get_sdb,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.signature = &signature,
 	.get_vaddr = &get_vaddr,
 	.info = &info
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_sfc.c b/libr/bin/p/bin_sfc.c
index 77cd2d8e56..ded939eca7 100644
--- a/libr/bin/p/bin_sfc.c
+++ b/libr/bin/p/bin_sfc.c
@@ -1,40 +1,38 @@
-/* radare - LGPL3 - 2017 - usrshare */
+/* radare - LGPL3 - 2017-2019 - usrshare */
 
 #include <r_bin.h>
 #include <r_lib.h>
 #include "sfc/sfc_specs.h"
 #include <r_endian.h>
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	const ut8 *buf_hdr = buf;
+static bool check_buffer(RBuffer *b) {
 	ut16 cksum1, cksum2;
-
+	ut64 length = r_buf_size (b);
 	// FIXME: this was commented out because it always evaluates to false.
 	//        Need to be fixed by someone with SFC knowledge
 	// if ((length & 0x8000) == 0x200) {
 	// 	buf_hdr += 0x200;
 	// }
 	if (length < 0x8000) {
 		return false;
 	}
 	//determine if ROM is headered, and add a 0x200 gap if so.
-	cksum1 = r_read_le16 (buf_hdr + 0x7FDC);
-	cksum2 = r_read_le16 (buf_hdr + 0x7FDE);
+	cksum1 = r_buf_read_le16_at (b, 0x7fdc);
+	cksum2 = r_buf_read_le16_at (b, 0x7fde);
 
 	if (cksum1 == (ut16)~cksum2) {
 		return true;
 	}
-
 	if (length < 0xffee) {
 		return false;
 	}
-	cksum1 = r_read_le16(buf_hdr + 0xFFDC);
-	cksum2 = r_read_le16(buf_hdr + 0xFFDE);
+	cksum1 = r_buf_read_le16_at (b, 0xffdc);
+	cksum2 = r_buf_read_le16_at (b, 0xffde);
 	return (cksum1 == (ut16)~cksum2);
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	return check_bytes (buf, sz);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb){
+	return check_buffer (b);
 }
 
 static RBinInfo* info(RBinFile *bf) {
@@ -277,14 +275,14 @@ static RList* entries(RBinFile *bf) { //Should be 3 offsets pointed by NMI, RESE
 RBinPlugin r_bin_plugin_sfc = {
 	.name = "sfc",
 	.desc = "Super NES / Super Famicom ROM file",
 	.license = "LGPL3",
-	.load_bytes = &load_bytes,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.entries = &entries,
 	.sections = sections,
 	.symbols = &symbols,
 	.info = &info,
 	.mem = &mem,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_smd.c b/libr/bin/p/bin_smd.c
index 5a4d10a019..014ed3443a 100644
--- a/libr/bin/p/bin_smd.c
+++ b/libr/bin/p/bin_smd.c
@@ -95,15 +95,17 @@ static ut64 baddr(RBinFile *bf) {
 	return 0;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (length > 0x190 && !memcmp (buf + 0x100, "SEGA", 4)) {
-		return true;
+static bool check_buffer(RBuffer *b) {
+	if (r_buf_size (b) > 0x190) {
+		ut8 buf[4];
+		r_buf_read_at (b, 0x100, buf, sizeof (buf));
+		return !memcmp (buf, "SEGA", 4);
 	}
 	return false;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	return check_bytes (buf, sz);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb){
+	return check_buffer (b);
 }
 
 static RBinInfo *info(RBinFile *bf) {
@@ -318,16 +320,16 @@ static RList *entries(RBinFile *bf) { // Should be 3 offsets pointed by NMI, RES
 RBinPlugin r_bin_plugin_smd = {
 	.name = "smd",
 	.desc = "SEGA Genesis/Megadrive",
 	.license = "LGPL3",
-	.load_bytes = &load_bytes,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.info = &info,
 	.minstrlen = 10,
 	.strfilter = 'U'
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_spc700.c b/libr/bin/p/bin_spc700.c
index df19420206..bb071a885e 100644
--- a/libr/bin/p/bin_spc700.c
+++ b/libr/bin/p/bin_spc700.c
@@ -1,19 +1,19 @@
-/* radare - LGPL - 2015-2016 - maijin */
+/* radare - LGPL - 2015-2019 - maijin */
 
 #include <r_bin.h>
 #include <r_lib.h>
 #include "../format/spc700/spc_specs.h"
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (!buf || length < 27) {
-		return false;
+static bool check_buffer(RBuffer *b) {
+	ut8 buf[27];
+	if (r_buf_read_at (b, 0, buf, sizeof (buf)) == 27) {
+		return !memcmp (buf, SPC_MAGIC, 27);
 	}
-	return !memcmp (buf, SPC_MAGIC, 27);
+	return false;
 }
 
-
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	return check_bytes (buf, sz);
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb){
+	return check_buffer (b);
 }
 
 static RBinInfo* info(RBinFile *bf) {
@@ -67,29 +67,27 @@ static RList* sections(RBinFile *bf) {
 }
 
 static RList* entries(RBinFile *bf) {
-	RList *ret;
-	RBinAddr *ptr = NULL;
-	if (!(ret = r_list_new ())) {
-		return NULL;
+	RList *ret = r_list_newf (free);
+	if (ret) {
+		RBinAddr *ptr = R_NEW0 (RBinAddr);
+		if (ptr) {
+			ptr->paddr = RAM_START_ADDRESS;
+			ptr->vaddr = 0;
+			r_list_append (ret, ptr);
+		}
 	}
-	if (!(ptr = R_NEW0 (RBinAddr))) {
-		return ret;
-	}
-	ptr->paddr = RAM_START_ADDRESS;
-	ptr->vaddr = 0;
-	r_list_append (ret, ptr);
 	return ret;
 }
 
 RBinPlugin r_bin_plugin_spc700 = {
 	.name = "spc700",
 	.desc = "SNES-SPC700 Sound File Data",
 	.license = "LGPL3",
-	.load_bytes = &load_bytes,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.entries = &entries,
 	.sections = &sections,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_symbols.c b/libr/bin/p/bin_symbols.c
index ee23d41446..5e01bc8401 100644
--- a/libr/bin/p/bin_symbols.c
+++ b/libr/bin/p/bin_symbols.c
@@ -476,83 +476,81 @@ static void parseTable3(RBuffer *buf, int x) {
 	free (b);
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 #if 0
 	SYMBOLS HEADER
 
  0	MAGIC	02ff01ff
  4	VERSION 1 (little endian)
  8      ffffffff
 16      002b0000 01000000 { 0x2b00, 0x0000 }
 24	UUID    16 bytes
 40	2621 d85b 2100 2000 0000 0000 0000 0000
 56	ffff ffff ffff ff7f 0c00 0000 0900 0000
 72	0400 0000 6800 0000 2f76 6172 2f66 6f6c .... 4, 104 /// 104 length string
 184	
 0x000000b8  5f5f 5445 5854 0000 0000 0000 0000 0000 0000 0000 0000 0000 0080 0000 0000 0000  __TEXT..........................
 0x000000d8  5f5f 4441 5441 0000 0000 0000 0000 0000 0080 0000 0000 0000 0040 0000 0000 0000  __DATA...................@......
 0x000000f8  5f5f 4c4c 564d 0000 0000 0000 0000 0000 00c0 0000 0000 0000 0000 0100 0000 0000  __LLVM..........................
 0x00000118  5f5f 4c49 4e4b 4544 4954 0000 0000 0000 00c0 0100 0000 0000 00c0 0000 0000 0000  __LINKEDIT......................
 
 #endif
 	// 0 - magic check, version ...
 	SymbolsHeader sh = parseHeader (buf);
 	if (!sh.valid) {
 		eprintf ("Invalid headers\n");
-		return NULL;
+		return false;
 	}
 	printSymbolsHeader (sh);
 
 	// 0x40 - contain list of segments
 	SymbolsMetadata sm = parseMetadata (buf, 0x40);
 
 	// 0x138 - 0x220        // unknown information + duplicated list of segments
 	SymbolsDragons sd = parseDragons (buf, sm.addr + sm.size, sm.bits);
 	// eprintf ("sections: %d\n", sd.n_sections);
 	// 0x220 - 0x3a0        // table of sections
 
 	// 0x3a0 - 0x1648       // table of dwords with -1
 	// XXX this is hacky, do not hardcode
 	symbolsBeginAt = sd.addr + sd.size; // is64? 0x458: 0x3a0;
 	D eprintf ("Symbols at 0x%08x\n", (ut32)symbolsBeginAt);
 	RList *symbols = parseSymbols (buf, symbolsBeginAt, &dwordsBeginAt, sd.n_symbols);
 	D eprintf ("Dwords at 0x%08x\n", (ut32)dwordsBeginAt);
 	stringsBeginAt = dwordsBeginAt + (sd.n_symbols * 8);
 	D eprintf ("Strings at 0x%08x\n", (ut32)stringsBeginAt);
 
 	// 0x1648 - 0x1c80      // table of dword pairs (unknown data)
 	parseTable3 (buf, dwordsBeginAt);
 
 	// 0x1c80 - EOF         // strings
 	RList *strings = parseStrings (buf, stringsBeginAt, stringsBeginAt + r_buf_size (buf));
 	// RList *secs = parseSections (buf, SECTIONS_BEGIN, sd.n_sections, strings);
 	// r_list_free (secs);
 	if (strings) {
 		RList *symbolStrings = filterSymbolStrings (strings, sd.n_sections);
 		//	eprintf ("Count strings: %d\n", r_list_length (strings));
 		//	eprintf ("Symbol strings: %d\n", r_list_length (symbolStrings));
 		// name the symbols
 		RListIter *iter;
 		RBinSymbol *sym;
 		int n = 0; // sections count
 		r_list_foreach (symbols, iter, sym) {
 			int m = n + sd.n_sections;
 			RBinString *bs = r_list_get_n (symbolStrings, m);
 			if (bs) {
 				sym->name = strdup (bs->string);
 			} else {
 				sym->name = r_str_newf ("__unnamed_%d", n);
 			}
 			sym->ordinal = n;
 			n++;
 		}
 		r_list_free (strings);
 		r_list_free (symbolStrings);
 		globalSymbols = symbols;
 	}
-
-	// :D we must hold our priv obj to avoid multiple parsings. it leaks
-	return malloc (32);
+	return true;
 }
 
 static RList *sections(RBinFile *bf) {
@@ -594,13 +592,10 @@ static RBinInfo *info(RBinFile *bf) {
 	return ret;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (buf && length >= 4) {
-		if (!memcmp (buf, "\x02\xff\x01\xff", 4)) {
-			return true;
-		}
-	}
-	return false;
+static bool check_buffer(RBuffer *b) {
+	ut8 buf[4];
+	r_buf_read_at (b, 0, buf, sizeof (buf));
+	return !memcmp (buf, "\x02\xff\x01\xff", 4);
 }
 
 static RList *strings(RBinFile *bf) {
@@ -628,15 +623,15 @@ static ut64 size(RBinFile *bf) {
 RBinPlugin r_bin_plugin_symbols = {
 	.name = "symbols",
 	.desc = "Apple Symbols file",
 	.license = "MIT",
 	.load_buffer = &load_buffer,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.symbols = &symbols,
 	.sections = &sections,
 	.strings = strings,
 	.size = &size,
 	.baddr = &baddr,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_te.c b/libr/bin/p/bin_te.c
index a78e99d846..5f291e5c40 100644
--- a/libr/bin/p/bin_te.c
+++ b/libr/bin/p/bin_te.c
@@ -1,8 +1,8 @@
-/* radare - LGPL - Copyright 2013-2015 - xvilka */
+/* radare - LGPL - Copyright 2013-2019 - xvilka */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include "te/te_specs.h"
 #include "te/te.h"
@@ -16,38 +16,27 @@ static Sdb *get_sdb(RBinFile *bf) {
 	return bin? bin->kv: NULL;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){
-	struct r_bin_te_obj_t *res = NULL;
-	RBuffer *tbuf = NULL;
-
-	if (!buf || sz == 0 || sz == UT64_MAX) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {
+	r_return_val_if_fail (bf && bin_obj && b, false);
+	ut64 sz = r_buf_size (b);
+	if (sz == 0 || sz == UT64_MAX) {
 		return false;
 	}
-	tbuf = r_buf_new ();
-	r_buf_set_bytes (tbuf, buf, sz);
-	res = r_bin_te_new_buf (tbuf);
+	struct r_bin_te_obj_t *res = r_bin_te_new_buf (b);
 	if (res) {
 		sdb_ns_set (sdb, "info", res->kv);
 	}
-	r_buf_free (tbuf);
 	*bin_obj = res;
 	return true;
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	load_bytes (bf, &bf->o->bin_obj, bytes, sz, bf->o->loadaddr, bf->sdb);
-	return bf->o->bin_obj? true: false;
+	r_return_val_if_fail (bf && bf->o, false);
+	return load_buffer (bf, &bf->o->bin_obj, bf->buf, bf->o->loadaddr, bf->sdb);
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_bin_te_free ((struct r_bin_te_obj_t *) bf->o->bin_obj);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -68,23 +57,19 @@ static RBinAddr *binsym(RBinFile *bf, int type) {
 }
 
 static RList *entries(RBinFile *bf) {
-	RList *ret;
-	RBinAddr *ptr = NULL;
-	RBinAddr *entry = NULL;
-
-	if (!(ret = r_list_new ())) {
-		return NULL;
-	}
-	ret->free = free;
-	if (!(entry = r_bin_te_get_entrypoint (bf->o->bin_obj))) {
-		return ret;
-	}
-	if ((ptr = R_NEW (RBinAddr))) {
-		ptr->paddr = entry->paddr;
-		ptr->vaddr = entry->vaddr;
-		r_list_append (ret, ptr);
+	RList *ret = r_list_newf (free);
+	if (ret) {
+		RBinAddr *entry = r_bin_te_get_entrypoint (bf->o->bin_obj);
+		if (entry) {
+			RBinAddr *ptr = R_NEW0 (RBinAddr);
+			if (ptr) {
+				ptr->paddr = entry->paddr;
+				ptr->vaddr = entry->vaddr;
+				r_list_append (ret, ptr);
+			}
+			free (entry);
+		}
 	}
-	free (entry);
 	return ret;
 }
 
@@ -159,25 +144,29 @@ static RBinInfo *info(RBinFile *bf) {
 	return ret;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	return (buf && length > 2 && !memcmp (buf, "\x56\x5a", 2));
+static bool check_buffer(RBuffer *b) {
+	ut8 buf[2];
+	if (r_buf_read_at (b, 0, buf, 2) == 2) {
+		return !memcmp (buf, "\x56\x5a", 2);
+	}
+	return false;
 }
 
 RBinPlugin r_bin_plugin_te = {
 	.name = "te",
 	.desc = "TE bin plugin", // Terse Executable format
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
 	.load = &load,
-	.load_bytes = &load_bytes,
+	.load_buffer = &load_buffer,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.info = &info,
 	.minstrlen = 4,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_vsf.c b/libr/bin/p/bin_vsf.c
index 693b160108..3ebf370054 100644
--- a/libr/bin/p/bin_vsf.c
+++ b/libr/bin/p/bin_vsf.c
@@ -1,12 +1,12 @@
-/* radare - LGPL3 - 2015 - riq */
+/* radare - LGPL3 - 2015-2019 - riq */
 
 /* VICE Snapshot File loader: http://vice-emu.sourceforge.net/ */
 
 #include <r_bin.h>
 #include "vsf/vsf_specs.h"
 
 static const char VICE_MAGIC[] = "VICE Snapshot File\032";
-static const int VICE_MAGIC_LEN = sizeof(VICE_MAGIC)-1;
+static const int VICE_MAGIC_LEN = sizeof (VICE_MAGIC) - 1;
 static const char VICE_MAINCPU[] = "MAINCPU";
 static const char VICE_C64MEM[] = "C64MEM";
 static const char VICE_C64ROM[] = "C64ROM";
@@ -25,89 +25,90 @@ static const struct {
 static const int MACHINES_MAX = sizeof(_machines) / sizeof(_machines[0]);
 
 static Sdb* get_sdb (RBinFile *bf) {
-	if (!bf || !bf->o || !bf->o->bin_obj) {
-		return NULL;
-	}
+	r_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);
 	struct r_bin_vsf_obj* bin = (struct r_bin_vsf_obj*) bf->o->bin_obj;
 	return bin->kv;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (!buf || length < VICE_MAGIC_LEN) {
-		return false;
+static bool check_buffer(RBuffer *b) {
+	ut8 magic[VICE_MAGIC_LEN];
+	if (r_buf_read_at (b, 0, magic, VICE_MAGIC_LEN) == VICE_MAGIC_LEN) {
+		return !memcmp (magic, VICE_MAGIC, VICE_MAGIC_LEN);
 	}
-	return (!memcmp (buf, VICE_MAGIC, VICE_MAGIC_LEN));
+	return false;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
+// XXX b vs bf->buf
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {
 	ut64 offset = 0;
 	struct r_bin_vsf_obj* res = NULL;
-	if (check_bytes (buf, sz)) {
+	if (check_buffer (bf->buf)) {
 		int i = 0;
 		if (!(res = R_NEW0 (struct r_bin_vsf_obj))) {
 		    return false;
 		}
 		offset = r_offsetof(struct vsf_hdr, machine);
 		if (offset > bf->size) {
 			free (res);
 			return false;
 		}
 		char machine[20];
 		int l = r_buf_read_at (bf->buf, offset, (ut8 *)machine, sizeof (machine));
 		if (l < 0) {
 			free (res);
 			return false;
 		}
 		for (; i < MACHINES_MAX; i++) {
 			if (offset + strlen (_machines[i].name) > bf->size) {
 				free (res);
 				return false;
 			}
 			if (!strncmp (machine, _machines[i].name, strlen (_machines[i].name))) {
 				res->machine_idx = i;
 				break;
 			}
 		}
 		if (i >= MACHINES_MAX) {
 			eprintf ("Unsupported machine type\n");
 			free (res);
 			return false;
 		}
 		// read all VSF modules
 		offset = sizeof (struct vsf_hdr);
+		ut64 sz = r_buf_size (bf->buf);
 		while (offset < sz) {
 			struct vsf_module module;
 			int read = r_buf_fread_at (bf->buf, offset, (ut8*)&module, "16ccci", 1);
 			if (read != sizeof(module)) {
 				eprintf ("Truncated Header\n");
 				free (res);
 				return false;
 			}
 #define CMP_MODULE(x) memcmp (module.module_name, x, sizeof (x) - 1)
 			if (!CMP_MODULE (VICE_C64MEM) && !module.major) {
 				res->mem = offset + read;
 			} else if (!CMP_MODULE (VICE_C64ROM) && !module.major) {
 				res->rom = offset + read;
 			} else if (!CMP_MODULE (VICE_C128MEM) && !module.major) {
 				res->mem = offset + read;
 			} else if (!CMP_MODULE (VICE_C128ROM) && !module.major) {
 				res->rom = offset + read;
 			} else if (!CMP_MODULE (VICE_MAINCPU) && module.major == 1) {
 				res->maincpu = R_NEW (struct vsf_maincpu);
 				r_buf_read_at (bf->buf, offset + read, (ut8 *)res->maincpu, sizeof (*res->maincpu));
 			}
 #undef CMP_MODULE
 			offset += module.length;
 			if (module.length == 0) {
 				eprintf ("Malformed VSF module with length 0\n");
 				break;
 			}
 		}
 	}
 	if (res) {
 		res->kv = sdb_new0 ();
 		sdb_ns_set (sdb, "info", res->kv);
 	}
 	*bin_obj = res;
 	return true;
 }
@@ -504,11 +505,10 @@ static RList* symbols(RBinFile *bf) {
 	return ret;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	struct r_bin_vsf_obj *obj = (struct r_bin_vsf_obj *)bf->o->bin_obj;
 	free (obj->maincpu);
 	free (obj);
-	return true;
 }
 
 static RList* entries(RBinFile *bf) {
@@ -545,16 +545,16 @@ static RList* entries(RBinFile *bf) {
 RBinPlugin r_bin_plugin_vsf = {
 	.name = "vsf",
 	.desc = "VICE Snapshot File",
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
-	.load_bytes = &load_bytes,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.entries = &entries,
 	.sections = sections,
 	.symbols = &symbols,
 	.info = &info,
 	.destroy = &destroy,
 	.mem = &mem,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_wasm.c b/libr/bin/p/bin_wasm.c
index d307e5e862..248ff3de3d 100644
--- a/libr/bin/p/bin_wasm.c
+++ b/libr/bin/p/bin_wasm.c
@@ -1,21 +1,17 @@
-/* radare2 - LGPL - Copyright 2017 - pancake, cgvwzq */
+/* radare2 - LGPL - Copyright 2017-2019 - pancake, cgvwzq */
 
 // http://webassembly.org/docs/binary-encoding/#module-structure
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 
 #include "wasm/wasm.h"
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	return (buf && length >= 4 && !memcmp (buf, R_BIN_WASM_MAGIC_BYTES, 4));
-}
-
-static bool check_bytes_buf(RBuffer* rbuf) {
+static bool check_buffer(RBuffer* rbuf) {
 	ut8 buf[4] = {0};
-	return rbuf && r_buf_read (rbuf, buf, 4) == 4 && !memcmp (buf, R_BIN_WASM_MAGIC_BYTES, 4);
+	return rbuf && r_buf_read_at (rbuf, 0, buf, 4) == 4 && !memcmp (buf, R_BIN_WASM_MAGIC_BYTES, 4);
 }
 
 static bool find_symbol(const ut32 *p, const RBinWasmSymbol* q) {
@@ -29,25 +25,23 @@ static bool find_export(const ut32 *p, const RBinWasmExportEntry* q) {
 	return q->index != (*p);
 }
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	r_return_val_if_fail (bf && buf && r_buf_size (buf) != UT64_MAX, NULL);
 
-	if (!check_bytes_buf (buf)) {
-		return NULL;
+	if (check_buffer (buf)) {
+		*bin_obj = r_bin_wasm_init (bf, buf);
+		return true;
 	}
-	return r_bin_wasm_init (bf, buf);
+	return false;
 }
 
 static bool load(RBinFile *bf) {
 	r_return_val_if_fail (bf && bf->o, false);
-
-	bf->o->bin_obj = load_buffer (bf, bf->buf, bf->o->loadaddr, bf->sdb);
-	return bf->o->bin_obj != NULL;
+	return load_buffer (bf, &bf->o->bin_obj, bf->buf, bf->o->loadaddr, bf->sdb);
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_bin_wasm_destroy (bf);
-	return true;
 }
 
 static ut64 baddr(RBinFile *bf) {
@@ -328,21 +322,21 @@ static RBuffer *create(RBin *bin, const ut8 *code, int codelen, const ut8 *data,
 RBinPlugin r_bin_plugin_wasm = {
 	.name = "wasm",
 	.desc = "WebAssembly bin plugin",
 	.license = "MIT",
 	.load = &load,
 	.load_buffer = &load_buffer,
 	.size = &size,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.imports = &imports,
 	.info = &info,
 	.libs = &libs,
 	.create = &create,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_write_elf.c b/libr/bin/p/bin_write_elf.c
index 2a657957c3..92e8f90099 100644
--- a/libr/bin/p/bin_write_elf.c
+++ b/libr/bin/p/bin_write_elf.c
@@ -1,4 +1,5 @@
-/* radare - LGPL - Copyright 2009-2018 - pancake, nibble */
+/* radare - LGPL - Copyright 2009-2019 - pancake, nibble */
+
 #include "bin_write_elf.inc"
 
 RBinWrite r_bin_write_elf = {
diff --git a/libr/bin/p/bin_write_elf.inc b/libr/bin/p/bin_write_elf.inc
index 2a40173e01..a6f0027c0b 100644
--- a/libr/bin/p/bin_write_elf.inc
+++ b/libr/bin/p/bin_write_elf.inc
@@ -1,41 +1,21 @@
-/* radare - LGPL - Copyright 2009-2018 - pancake, nibble */
+/* radare - LGPL - Copyright 2009-2019 - pancake */
 
 #include <r_types.h>
 #include <r_bin.h>
 #include "elf/elf.h"
 
 static ut64 scn_resize(RBinFile *bf, const char *name, ut64 size) {
-	struct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;
-	int ret = Elf_(r_bin_elf_resize_section) (bf->o->bin_obj, name, size);
-	r_buf_free (bf->buf);
-	bf->buf = obj->b;
-	obj->b = NULL;
-	return ret;
+	return Elf_(r_bin_elf_resize_section) (bf, name, size);
 }
 
 static bool scn_perms(RBinFile *bf, const char *name, int perms) {
-	struct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;
-	int ret = Elf_(r_bin_elf_section_perms) (bf->o->bin_obj, name, perms);
-	r_buf_free (bf->buf);
-	bf->buf = obj->b;
-	obj->b = NULL;
-	return ret;
+	return Elf_(r_bin_elf_section_perms) (bf->o->bin_obj, name, perms);
 }
 
 static int rpath_del(RBinFile *bf) {
-	struct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;
-	int ret = Elf_(r_bin_elf_del_rpath) (bf->o->bin_obj);
-	r_buf_free (bf->buf);
-	bf->buf = obj->b;
-	obj->b = NULL;
-	return ret;
+	return Elf_(r_bin_elf_del_rpath) (bf->o->bin_obj);
 }
 
 static bool chentry(RBinFile *bf, ut64 addr) {
-	struct Elf_(r_bin_elf_obj_t) *obj = bf->o->bin_obj;
-	int ret = Elf_(r_bin_elf_entry_write) (bf->o->bin_obj, addr);
-	r_buf_free (bf->buf);
-	bf->buf = obj->b;
-	obj->b = NULL;
-	return ret;
+	return Elf_(r_bin_elf_entry_write) (bf->o->bin_obj, addr);
 }
diff --git a/libr/bin/p/bin_write_pe.c b/libr/bin/p/bin_write_pe.c
index e4f67b375a..aab5fc35e0 100644
--- a/libr/bin/p/bin_write_pe.c
+++ b/libr/bin/p/bin_write_pe.c
@@ -1,16 +1,11 @@
-/* radare - LGPL - Copyright 2009-2017 - pancake, nibble */
+/* radare - LGPL - Copyright 2009-2019 - pancake, nibble */
 
 #include <r_types.h>
 #include <r_bin.h>
 #include "pe/pe.h"
 
 static bool scn_perms(RBinFile *bf, const char *name, int perms) {
-	struct PE_(r_bin_pe_obj_t) *obj = bf->o->bin_obj;
-	bool ret = PE_(r_bin_pe_section_perms) (bf->o->bin_obj, name, perms);
-	r_buf_free (bf->buf);
-	bf->buf = obj->b;
-	obj->b = NULL;
-	return ret;
+	return PE_(r_bin_pe_section_perms) (bf, name, perms);
 }
 
 #if !R_BIN_PE64
diff --git a/libr/bin/p/bin_xbe.c b/libr/bin/p/bin_xbe.c
index 15c16f7cc3..5422967435 100644
--- a/libr/bin/p/bin_xbe.c
+++ b/libr/bin/p/bin_xbe.c
@@ -1,8 +1,8 @@
-/* radare - LGPL - 2014-2017 - thatlemon@gmail.com, pancake */
+/* radare - LGPL - 2014-2019 - thatlemon@gmail.com, pancake */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include <string.h>
 #include "../format/xbe/xbe.h"
@@ -11,58 +11,56 @@ static const char *kt_name[] = {
 #include "../format/xbe/kernel.h"
 };
 
-static bool check_bytes(const ut8 *buf, ut64 size) {
-	xbe_header *header = (xbe_header *) buf;
-	return (size > sizeof (xbe_header) && header->magic == XBE_MAGIC);
+static bool check_buffer(RBuffer *b) {
+	ut8 magic[4];
+	if (r_buf_read_at (b, 0, magic, sizeof (magic)) == 4) {
+		return !memcmp (magic, "XBEH", 4);
+	}
+	return false;
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
+	r_return_val_if_fail (bf && bf->o, false);
 	r_bin_xbe_obj_t *obj = NULL;
 	const ut8 *bytes = r_buf_data (bf->buf, NULL);
 	bf->o->bin_obj = malloc (sizeof (r_bin_plugin_xbe));
 	obj = bf->o->bin_obj;
 	if (obj) {
 		obj->header = (xbe_header *) bytes;
 		if ((obj->header->ep & 0xf0000000) == 0x40000000) {
 			// Sega Chihiro xbe
 			obj->ep_key = XBE_EP_CHIHIRO;
 			obj->kt_key = XBE_KP_CHIHIRO;
 		} else if ((obj->header->ep ^ XBE_EP_RETAIL) > 0x1000000) {
 			// Debug xbe
 			obj->ep_key = XBE_EP_DEBUG;
 			obj->kt_key = XBE_KP_DEBUG;
 		} else {
 			// Retail xbe
 			obj->ep_key = XBE_EP_RETAIL;
 			obj->kt_key = XBE_KP_RETAIL;
 		}
 		return true;
 	}
 	return false;
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	R_FREE (bf->o->bin_obj);
 	r_buf_free (bf->buf);
 	bf->buf = NULL;
-	return true;
 }
 
 static RBinAddr *binsym(RBinFile *bf, int type) {
-	RBinAddr *ret;
-	r_bin_xbe_obj_t *obj;
 	if (!bf || !bf->buf || type != R_BIN_SYM_MAIN) {
 		return NULL;
 	}
-	obj = bf->o->bin_obj;
-	ret = R_NEW0 (RBinAddr);
+	r_bin_xbe_obj_t *obj = bf->o->bin_obj;
+	RBinAddr *ret = R_NEW0 (RBinAddr);
 	if (!ret) {
 		return NULL;
 	}
 	ret->vaddr = obj->header->ep ^ obj->ep_key;
 	ret->paddr = ret->vaddr - obj->header->base;
 	return ret;
 }
@@ -359,17 +357,17 @@ static ut64 baddr(RBinFile *bf) {
 RBinPlugin r_bin_plugin_xbe = {
 	.name = "xbe",
 	.desc = "Microsoft Xbox xbe format r_bin plugin",
 	.license = "LGPL3",
 	.load = &load,
 	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.binsym = &binsym,
 	.entries = &entries,
 	.sections = &sections,
 	.symbols = &symbols,
 	.info = &info,
 	.libs = &libs,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_xnu_kernelcache.c b/libr/bin/p/bin_xnu_kernelcache.c
index fac964edeb..bc4b4732ef 100644
--- a/libr/bin/p/bin_xnu_kernelcache.c
+++ b/libr/bin/p/bin_xnu_kernelcache.c
@@ -164,65 +164,65 @@ static RBinAddr *newEntry(ut64 haddr, ut64 vaddr, int type);
 
 static void r_kernel_cache_free(RKernelCacheObj *obj);
 
-static void *load_buffer(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {
 	RBuffer *fbuf = r_buf_ref (buf);
 	struct MACH0_(opts_t) opts;
 	MACH0_(opts_set_default) (&opts, bf);
 	struct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);
 	if (!main_mach0) {
-		return NULL;
+		return false;
 	}
 
 	RRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);
 
 	RPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);
 	if (!prelink_range) {
 		goto beach;
 	}
 
 	RKernelCacheObj *obj = R_NEW0 (RKernelCacheObj);
 	if (!obj) {
 		goto beach;
 	}
 
 	RCFValueDict *prelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,
 		prelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);
 	if (!prelink_info) {
 		R_FREE (obj);
 		goto beach;
 	}
 
 	obj->mach0 = main_mach0;
 	obj->rebase_info = rebase_info;
 	obj->prelink_info = prelink_info;
 	obj->cache_buf = fbuf;
 	obj->pa2va_exec = prelink_range->pa2va_exec;
 	obj->pa2va_data = prelink_range->pa2va_data;
 
 	if (rebase_info) {
 		RIO *io = bf->rbin->iob.io;
 		swizzle_io_read (obj, io);
 	}
 
 	RList *kexts = filter_kexts (obj);
 
 	if (kexts && !r_list_length (kexts)) {
 		r_list_free (kexts);
 		kexts = NULL;
 	}
 
 	if (!kexts) {
 		kexts = carve_kexts (obj);
 	}
 
 	obj->kexts = r_kext_index_new (kexts);
-
-	return obj;
+	*bin_obj = obj;
+	return true;
 
 beach:
 	r_buf_free (fbuf);
 	MACH0_(mach0_free) (main_mach0);
-	return NULL;
+	return false;
 }
 
 static RPrelinkRange *get_prelink_info_range_from_mach0(struct MACH0_(obj_t) *mach0) {
@@ -860,20 +860,17 @@ static RBinAddr *newEntry(ut64 haddr, ut64 vaddr, int type) {
 	return ptr;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (buf && length > 4) {
-		if (memcmp (buf, "\xcf\xfa\xed\xfe", 4)) {
-			return false;
+static bool check_buffer(RBuffer *b) {
+	if (r_buf_size (b) > 4) {
+		ut8 buf[4];
+		r_buf_read_at (b, 0, buf, sizeof (buf));
+		if (!memcmp (buf, "\xcf\xfa\xed\xfe", 4)) {
+			return is_kernelcache_buffer (b);
 		}
-		return is_kernelcache (buf, length);
 	}
 	return false;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
-	return (bool) check_bytes (buf, sz);
-}
-
 static RList *sections(RBinFile *bf) {
 	RList *ret = NULL;
 	RBinObject *obj = bf ? bf->o : NULL;
@@ -1622,9 +1619,8 @@ static ut64 baddr(RBinFile *bf) {
 	return MACH0_(get_baddr)(obj->mach0);
 }
 
-static int destroy(RBinFile *bf) {
+static void destroy(RBinFile *bf) {
 	r_kernel_cache_free ((RKernelCacheObj*) bf->o->bin_obj);
-	return true;
 }
 
 static void r_kernel_cache_free(RKernelCacheObj *obj) {
@@ -1942,16 +1938,15 @@ static bool r_parse_pointer(RParsedPointer *ptr, ut64 decorated_addr, RKernelCac
 RBinPlugin r_bin_plugin_xnu_kernelcache = {
 	.name = "kernelcache",
 	.desc = "kernelcache bin plugin",
 	.license = "LGPL3",
 	.destroy = &destroy,
-	.load_bytes = &load_bytes,
 	.load_buffer = &load_buffer,
 	.entries = &entries,
 	.baddr = &baddr,
 	.symbols = &symbols,
 	.sections = &sections,
-	.check_bytes = &check_bytes,
+	.check_buffer = &check_buffer,
 	.info = &info
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_xtr_dyldcache.c b/libr/bin/p/bin_xtr_dyldcache.c
index 74ee9acc83..eee035e1d2 100644
--- a/libr/bin/p/bin_xtr_dyldcache.c
+++ b/libr/bin/p/bin_xtr_dyldcache.c
@@ -11,22 +11,19 @@ static RBinXtrData * extract(RBin *bin, int idx);
 static RList * extractall(RBin *bin);
 static RBinXtrData * oneshot(RBin *bin, const ut8 *buf, ut64 size, int idx);
 static RList * oneshotall(RBin *bin, const ut8 *buf, ut64 size);
-static int free_xtr (void *xtr_obj);
 
 static bool check_buffer(RBuffer *buf) {
 	ut8 b[4] = {0};
 	r_buf_read_at (buf, 0, b, sizeof (b));
 	return !memcmp (buf, "dyld", 4);
 }
 
-// TODO: destroy must be void?
-static int destroy(RBin *bin) {
-	return free_xtr (bin->cur->xtr_obj);
+static void free_xtr(void *xtr_obj) {
+	r_bin_dyldcache_free ((struct r_bin_dyldcache_obj_t*)xtr_obj);
 }
 
-static int free_xtr(void *xtr_obj) {
-	r_bin_dyldcache_free ((struct r_bin_dyldcache_obj_t*)xtr_obj);
-	return true;
+static void destroy(RBin *bin) {
+	free_xtr (bin->cur->xtr_obj);
 }
 
 static bool load(RBin *bin) {
@@ -74,32 +71,32 @@ static inline void fill_metadata_info_from_hdr(RBinXtrMetadata *meta, struct MAC
 static RBinXtrData *extract(RBin *bin, int idx) {
 	int nlib = 0;
 	RBinXtrData *res = NULL;
 	char *libname;
 	struct MACH0_(mach_header) *hdr;
 	struct r_bin_dyldcache_lib_t *lib = r_bin_dyldcache_extract (
 		(struct r_bin_dyldcache_obj_t*)bin->cur->xtr_obj, idx, &nlib);
 
 	if (lib) {
 		RBinXtrMetadata *metadata = R_NEW0(RBinXtrMetadata);
 		if (!metadata) {
 			free (lib);
 			return NULL;
 		}
-		hdr = MACH0_(get_hdr_from_bytes) (lib->b);
+		hdr = MACH0_(get_hdr_from_buffer) (lib->b);
 		if (!hdr) {
 			free (lib);
 			R_FREE (metadata);
 			free (hdr);
 			return NULL;
 		}
 		fill_metadata_info_from_hdr (metadata, hdr);
 		r_bin_dydlcache_get_libname (lib, &libname);
 		metadata->libname = strdup (libname);
 
 		res = r_bin_xtrdata_new (lib->b, lib->offset, lib->size, nlib, metadata);
 		r_buf_free (lib->b);
 		free (lib);
 		free (hdr);
 	}
 	return res;
 }
@@ -107,40 +104,40 @@ static RBinXtrData *extract(RBin *bin, int idx) {
 static RBinXtrData *oneshot(RBin *bin, const ut8* buf, ut64 size, int idx) {
 	RBinXtrData *res = NULL;
 	struct r_bin_dyldcache_obj_t *xtr_obj;
 	struct r_bin_dyldcache_lib_t *lib;
 	int nlib = 0;
 	char *libname;
 	struct MACH0_(mach_header) *hdr;
 
 	if (!load (bin)) {
 		return NULL;
 	}
 
 	xtr_obj = bin->cur->xtr_obj;
 	lib = r_bin_dyldcache_extract (xtr_obj, idx, &nlib);
 	if (!lib) {
 		free_xtr (xtr_obj);
 		bin->cur->xtr_obj = NULL;
 		return NULL;
 	}
 	RBinXtrMetadata *metadata = R_NEW0 (RBinXtrMetadata);
 	if (!metadata) {
 		free (lib);
 		return NULL;
 	}
-	hdr = MACH0_(get_hdr_from_bytes) (lib->b);
+	hdr = MACH0_(get_hdr_from_buffer) (lib->b);
 	if (!hdr) {
 		free (lib);
 		free (metadata);
 		return NULL;
 	}
 	fill_metadata_info_from_hdr (metadata, hdr);
 	r_bin_dydlcache_get_libname (lib, &libname);
 	metadata->libname = strdup (libname);
 
 	res = r_bin_xtrdata_new (lib->b, lib->offset, r_buf_size (lib->b), nlib, metadata);
 	r_buf_free (lib->b);
 	free (hdr);
 	free (lib);
 	return res;
 }
diff --git a/libr/bin/p/bin_xtr_fatmach0.c b/libr/bin/p/bin_xtr_fatmach0.c
index eda0ceaaf5..baa00c8e19 100644
--- a/libr/bin/p/bin_xtr_fatmach0.c
+++ b/libr/bin/p/bin_xtr_fatmach0.c
@@ -9,9 +9,6 @@
 
 static RBinXtrData * extract(RBin *bin, int idx);
 static RList * extractall(RBin *bin);
-static RBinXtrData * oneshot(RBin *bin, const ut8 *buf, ut64 size, int idx);
-static RList * oneshotall(RBin *bin, const ut8 *buf, ut64 size );
-static int free_xtr (void *xtr_obj) ;
 
 static bool checkHeader(RBuffer *b) {
 	ut8 buf[4];
@@ -37,16 +34,14 @@ static bool checkHeader(RBuffer *b) {
 static bool check_buffer (RBuffer *buf) {
 	r_return_val_if_fail (buf, false);
 	return checkHeader (buf);
 }
 
-// TODO: destroy must be void?
-static int destroy(RBin *bin) {
-	return free_xtr (bin->cur->xtr_obj);
+static void free_xtr (void *xtr_obj) {
+	r_bin_fatmach0_free ((struct r_bin_fatmach0_obj_t*)xtr_obj);
 }
 
-static int free_xtr (void *xtr_obj) {
-	r_bin_fatmach0_free ((struct r_bin_fatmach0_obj_t*)xtr_obj);
-	return true;
+static void destroy(RBin *bin) {
+	free_xtr (bin->cur->xtr_obj);
 }
 
 static bool load(RBin *bin) {
@@ -67,139 +62,97 @@ static inline void fill_metadata_info_from_hdr(RBinXtrMetadata *meta, struct MAC
 	meta->xtr_type = "fat";
 }
 
-static RBinXtrData * extract(RBin* bin, int idx) {
+// XXX deprecate
+static RBinXtrData *extract(RBin* bin, int idx) {
 	int narch;
-	RBinXtrData * res = NULL;
 	struct r_bin_fatmach0_obj_t *fb = bin->cur->xtr_obj;
-	struct r_bin_fatmach0_arch_t *arch;
-	struct MACH0_(mach_header) *hdr = NULL;
-
-	arch = r_bin_fatmach0_extract (fb, idx, &narch);
+	struct r_bin_fatmach0_arch_t *arch = r_bin_fatmach0_extract (fb, idx, &narch);
 	if (!arch) {
-		return res;
+		return NULL;
 	}
 	RBinXtrMetadata *metadata = R_NEW0 (RBinXtrMetadata);
 	if (!metadata) {
 		r_buf_free (arch->b);
 		free (arch);
 		return NULL;
 	}
-	hdr = MACH0_(get_hdr_from_bytes) (arch->b);
+	struct MACH0_(mach_header) *hdr = MACH0_(get_hdr_from_buffer) (arch->b);
 	if (!hdr) {
 		free (metadata);
 		free (arch);
 		free (hdr);
 		return NULL;
 	}
 	fill_metadata_info_from_hdr (metadata, hdr);
-	res = r_bin_xtrdata_new (arch->b, arch->offset, arch->size,
-		narch, metadata);
+	RBinXtrData * res = r_bin_xtrdata_new (arch->b, arch->offset, arch->size, narch, metadata);
 	r_buf_free (arch->b);
 	free (arch);
 	free (hdr);
 	return res;
 }
 
-static RBinXtrData * oneshot(RBin *bin, const ut8 *buf, ut64 size, int idx) {
-	struct r_bin_fatmach0_obj_t *fb;
-	struct r_bin_fatmach0_arch_t *arch;
-	RBinXtrData *res = NULL;
-	int narch;
-	struct MACH0_(mach_header) *hdr;
-
+static RBinXtrData *oneshot_buffer(RBin *bin, RBuffer *b, int idx) {
 	r_return_val_if_fail (bin && bin->cur, NULL);
 
 	if (!bin->cur->xtr_obj) {
-		bin->cur->xtr_obj = r_bin_fatmach0_from_bytes_new (buf, size);
-	}
-
-	fb = bin->cur->xtr_obj;
-	arch = r_bin_fatmach0_extract (fb, idx, &narch);
-	if (!arch) {
-		return res;
-	}
-
-	RBinXtrMetadata *metadata = R_NEW0 (RBinXtrMetadata);
-	if (!metadata) {
-		free (arch);
-		return NULL;
+		bin->cur->xtr_obj = r_bin_fatmach0_from_buffer_new (b);
 	}
-	hdr = MACH0_(get_hdr_from_bytes) (arch->b);
-	if (!hdr) {
+	int narch;
+	struct r_bin_fatmach0_obj_t *fb = bin->cur->xtr_obj;
+	struct r_bin_fatmach0_arch_t *arch = r_bin_fatmach0_extract (fb, idx, &narch);
+	if (arch) {
+		RBinXtrMetadata *metadata = R_NEW0 (RBinXtrMetadata);
+		if (metadata) {
+			struct MACH0_(mach_header) *hdr = MACH0_(get_hdr_from_buffer) (arch->b);
+			if (hdr) {
+				fill_metadata_info_from_hdr (metadata, hdr);
+				RBinXtrData *res = r_bin_xtrdata_new (arch->b, arch->offset, arch->size, narch, metadata);
+				r_buf_free (arch->b);
+				free (arch);
+				free (hdr);
+				return res;
+			}
+			free (metadata);
+		}
 		free (arch);
-		free (metadata);
-		return NULL;
 	}
-	fill_metadata_info_from_hdr (metadata, hdr);
-	res = r_bin_xtrdata_new (arch->b, arch->offset, arch->size, narch, metadata);
-	r_buf_free (arch->b);
-	free (arch);
-	free (hdr);
-	return res;
+	return NULL;
 }
 
-static RList * extractall(RBin *bin) {
-	RList *res = NULL;
-	int narch, i = 0;
-	RBinXtrData *data = NULL;
-
-	data = extract (bin, i);
-	if (!data) {
-		return res;
-	}
-
-	// XXX - how do we validate a valid narch?
-	narch = data->file_count;
-	res = r_list_newf (r_bin_xtrdata_free);
-	if (!res) {
-		r_bin_xtrdata_free (data);
-		return NULL;
-	}
-	r_list_append (res, data);
-	for (i = 1; data && i < narch; i++) {
-		data = extract (bin, i);
+static RList * oneshotall_buffer(RBin *bin, RBuffer *b) {
+	RBinXtrData *data = oneshot_buffer (bin, b, 0);
+	if (data) {
+		// XXX - how do we validate a valid narch?
+		int  narch = data->file_count;
+		RList *res = r_list_newf (r_bin_xtrdata_free);
+		if (!res) {
+			r_bin_xtrdata_free (data);
+			return NULL;
+		}
 		r_list_append (res, data);
-	}
-	return res;
-}
-
-static RList * oneshotall(RBin *bin, const ut8 *buf, ut64 size) {
-	RList *res = NULL;
-	int narch, i = 0;
-	RBinXtrData *data = oneshot (bin, buf, size, i);
-
-	if (!data) {
+		int i = 0;
+		for (i = 1; data && i < narch; i++) {
+			data = oneshot_buffer (bin, b, i);
+			r_list_append (res, data);
+		}
 		return res;
 	}
-	// XXX - how do we validate a valid narch?
-	narch = data->file_count;
-	res = r_list_newf (r_bin_xtrdata_free);
-	if (!res) {
-		r_bin_xtrdata_free (data);
-		return NULL;
-	}
-	r_list_append (res, data);
-	for (i = 1; data && i < narch; i++) {
-		data = oneshot (bin, buf, size, i);
-		r_list_append (res, data);
-	}
-
-	return res;
+	return NULL;
 }
 
 RBinXtrPlugin r_bin_xtr_plugin_xtr_fatmach0 = {
 	.name = "xtr.fatmach0",
 	.desc = "fat mach0 bin extractor plugin",
 	.license = "LGPL3",
 	.load = &load,
 	.size = &size,
 	.extract = &extract,
-	.extractall = &extractall,
+	// DEPRECATE .extractall = &extractall,
 	.destroy = &destroy,
-	.extract_from_bytes = &oneshot,
-	.extractall_from_bytes = &oneshotall,
+	.extract_from_buffer = &oneshot_buffer,
+	.extractall_from_buffer = &oneshotall_buffer,
 	.free_xtr = &free_xtr,
 	.check_buffer = check_buffer,
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_xtr_pemixed.c b/libr/bin/p/bin_xtr_pemixed.c
index c7d0128b44..8b341da1b0 100644
--- a/libr/bin/p/bin_xtr_pemixed.c
+++ b/libr/bin/p/bin_xtr_pemixed.c
@@ -1,55 +1,52 @@
-/* radare - LGPL - Copyright 2018 - JohnPeng47 */
+/* radare - LGPL - Copyright 2018-2019 - JohnPeng47 */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include "pe/pemixed.h"
 
 static RList * oneshotall(RBin *bin, const ut8 *buf, ut64 size);
-static bool check_bytes(const ut8 *bytes, ut64 sz);
 static RBinXtrData * oneshot(RBin *bin, const ut8 *buf, ut64 size, int subbin_type);
-static int destroy(RBin *bin);
-static int free_xtr (void *xtr_obj);
 
-static bool check_buffer(RBuffer *b) {
-	return false;
+static void free_xtr (void *xtr_obj) {
+	r_bin_pemixed_free ((struct r_bin_pemixed_obj_t*) xtr_obj);
+}
+
+static void destroy(RBin *bin) {
+	free_xtr (bin->cur->xtr_obj);
 }
 
-//copied from bin_pe
-//another check is used later to check for .NET only code
-static bool check_bytes(const ut8 *bytes, ut64 sz) {
-	// XXX pemixed is always loaded because it uses
-	// XXX the same signature for fat and non-fat
-	// XXX so we need to make that action implicit
+static bool check_buffer(RBuffer *b) {
 	return false;
 #if 0
 	if (!bytes) {
 		return false;
 	}
 	if (sz <= 0x3d) { //less than size of MS-DOS header which is 64bytes
 		return false;
 	}
 	ut32 idx = (bytes[0x3c] | (bytes[0x3d]<<8));
 	if (sz > idx + 0x18 + 2) {
 		/* Here PE signature for usual PE files
 		 * and PL signature for Phar Lap TNT DOS extender 32bit executables
 		 */
 		if (!memcmp (bytes, "MZ", 2)) {
 			if (!memcmp (bytes+idx, "PE", 2) &&
 				!memcmp (bytes+idx+0x18, "\x0b\x01", 2)) {
 				return true;
 			}
 			// TODO: Add one more indicator, to prevent false positives
 			if (!memcmp (bytes+idx, "PL", 2)) {
 				return true;
 			}
 		}
 	}
 	return false;
 #endif
 }
 
+// TODO RBufferify
 static RList * oneshotall(RBin *bin, const ut8 *buf, ut64 size) {
 	//extract dos componenent first
 	RBinXtrData *data = oneshot (bin, buf, size, SUB_BIN_DOS);
@@ -83,45 +80,28 @@ static void fill_metadata_info_from_hdr(RBinXtrMetadata *meta, void *foo) {// st
 	//strcpy (meta->xtr_type, "net");
 }
 
+// XXX: ut8* should be RBuffer *
 static RBinXtrData * oneshot(RBin *bin, const ut8 *buf, ut64 size, int sub_bin_type) {
-	struct r_bin_pemixed_obj_t* fb;
-	struct PE_(r_bin_pe_obj_t)* pe;
-
-	if (!bin || !bin->cur) {
-		return NULL;
-	}
+	r_return_val_if_fail (bin && bin->cur && buf, false);
 
-	if (!bin->cur->xtr_obj){
-		bin->cur->xtr_obj = r_bin_pemixed_from_bytes_new(buf, size);
+	if (!bin->cur->xtr_obj) {
+		bin->cur->xtr_obj = r_bin_pemixed_from_bytes_new (buf, size);
 	}
 
-	fb = bin->cur->xtr_obj;
-
-	//this function is prolly not nessescary
-	pe = r_bin_pemixed_extract (fb, sub_bin_type);
-
-	if (!pe){
+	struct r_bin_pemixed_obj_t* fb = bin->cur->xtr_obj;
+	// this function is prolly not nessescary
+	struct PE_(r_bin_pe_obj_t)* pe = r_bin_pemixed_extract (fb, sub_bin_type);
+	if (!pe) {
 		return NULL;
 	}
-
 	RBinXtrMetadata *metadata = R_NEW0 (RBinXtrMetadata);
 	if (!metadata) {
 		return NULL;
 	}
-
 	fill_metadata_info_from_hdr (metadata, pe);
 	return r_bin_xtrdata_new (pe->b, 0, pe->size, 3, metadata);
 }
 
-static int destroy(RBin *bin) {
-	return free_xtr (bin->cur->xtr_obj);
-}
-
-static int free_xtr (void *xtr_obj) {
-	r_bin_pemixed_free ((struct r_bin_pemixed_obj_t*) xtr_obj);
-	return true;
-}
-
 RBinXtrPlugin r_bin_xtr_plugin_xtr_pemixed = {
 	.name = "xtr.pemixed",
 	.desc = "Extract sub-binaries in PE files",
diff --git a/libr/bin/p/bin_z64.c b/libr/bin/p/bin_z64.c
index cbca3c52db..a8198e7265 100644
--- a/libr/bin/p/bin_z64.c
+++ b/libr/bin/p/bin_z64.c
@@ -1,43 +1,43 @@
-/* radare2 - LGPL 3 - Copyright 2018 - lowlyw */
+/* radare2 - LGPL 3 - Copyright 2018-2019 - lowlyw */
 
 /*
  * info comes from here.
  * https://github.com/mikeryan/n64dev
  * http://en64.shoutwiki.com/wiki/N64_Memory
  */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include <r_io.h>
 #include <r_cons.h>
 
 #define N64_ROM_START 0x1000
 
 // starting at 0
 /*
 0000h              (1 byte): initial PI_BSB_DOM1_LAT_REG value (0x80)
 0001h              (1 byte): initial PI_BSB_DOM1_PGS_REG value (0x37)
 0002h              (1 byte): initial PI_BSB_DOM1_PWD_REG value (0x12)
 0003h              (1 byte): initial PI_BSB_DOM1_PGS_REG value (0x40)
 0004h - 0007h     (1 dword): ClockRate
 0008h - 000Bh     (1 dword): Program Counter (PC)
 000Ch - 000Fh     (1 dword): Release
 0010h - 0013h     (1 dword): CRC1
 0014h - 0017h     (1 dword): CRC2
 0018h - 001Fh    (2 dwords): Unknown (0x0000000000000000)
 0020h - 0033h    (20 bytes): Image name
                              Padded with 0x00 or spaces (0x20)
 0034h - 0037h     (1 dword): Unknown (0x00000000)
 0038h - 003Bh     (1 dword): Manufacturer ID
                              0x0000004E = Nintendo ('N')
 003Ch - 003Dh      (1 word): Cartridge ID
 003Eh - 003Fh      (1 word): Country code
                              0x4400 = Germany ('D')
                              0x4500 = USA ('E')
                              0x4A00 = Japan ('J')
                              0x5000 = Europe ('P')
                              0x5500 = Australia ('U')
 0040h - 0FFFh (1008 dwords): Boot code
 */
@@ -69,34 +69,28 @@ static ut64 baddr(RBinFile *bf) {
 	return (ut64) r_read_be32(&n64_header.BootAddress);
 }
 
-static bool check_bytes (const ut8 *buf, ut64 length) {
-	ut32 magic = 0x80371240;
-	if (length < N64_ROM_START) {
+static bool check_buffer(RBuffer *b) {
+	ut8 magic[4];
+	if (r_buf_size (b) < N64_ROM_START) {
 		return false;
 	}
-	return magic == r_read_be32 (buf);
+	(void)r_buf_read_at (b, 0, magic, sizeof (magic));
+	return !memcmp (magic, "\x80\x37\x12\x40", 4);
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb) {
-	if (check_bytes (buf, sz)) {
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb) {
+	if (check_buffer (b)) {
+		ut8 buf[sizeof (N64Header)] = {0};
+		r_buf_read_at (b, 0, buf, sizeof (buf));
 		*bin_obj = memcpy (&n64_header, buf, sizeof (N64Header));
 		return true;
 	}
 	return false;
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-	ut64 sz;
-	const ut8 *bytes = r_buf_data (bf->buf, &sz);
-	load_bytes (bf, &bf->o->bin_obj, bytes, sz, bf->o->loadaddr, bf->sdb);
-	return check_bytes (bytes, sz);
-}
-
-static int destroy(RBinFile *bf) {
-	return true;
+	r_return_val_if_fail (bf && bf->o, false);
+	return check_buffer (bf->buf);
 }
 
 static RList *entries(RBinFile *bf) {
@@ -161,16 +155,15 @@ static RBinInfo *info(RBinFile *bf) {
 RBinPlugin r_bin_plugin_z64 = {
 	.name = "z64",
 	.desc = "Nintendo 64 binaries big endian r_bin plugin",
 	.license = "LGPL3",
 	.load = &load,
-	.load_bytes = &load_bytes,
-	.destroy = &destroy,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.baddr = baddr,
 	.boffset = &boffset,
 	.entries = &entries,
 	.sections = &sections,
 	.info = &info
 };
 
 #ifndef CORELIB
diff --git a/libr/bin/p/bin_zimg.c b/libr/bin/p/bin_zimg.c
index bcb302eec3..0e7711d93a 100644
--- a/libr/bin/p/bin_zimg.c
+++ b/libr/bin/p/bin_zimg.c
@@ -1,56 +1,39 @@
-/* radare - LGPL - Copyright 2011-2017 - ninjahacker */
+/* radare - LGPL - Copyright 2011-2019 - ninjahacker */
 
 #include <r_types.h>
 #include <r_util.h>
 #include <r_lib.h>
 #include <r_bin.h>
 #include "zimg/zimg.h"
 
 static Sdb *get_sdb(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return NULL;
-	}
+	r_return_val_if_fail (bf && bf->o, false);
 	struct r_bin_zimg_obj_t *bin = (struct r_bin_zimg_obj_t *) bf->o->bin_obj;
 	return bin? bin->kv: NULL;
 }
 
-static bool load_bytes(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 size, ut64 loadaddr, Sdb *sdb){
-	void *res = NULL;
-	RBuffer *tbuf = NULL;
-	if (!buf || size == 0 || size == UT64_MAX) {
-		return false;
-	}
-	tbuf = r_buf_new_with_bytes (buf, size);
-	if (!tbuf) {
-		return false;
-	}
-	res = r_bin_zimg_new_buf (tbuf);
-	r_buf_free (tbuf);
-	*bin_obj = res;
-	return true;
+static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *b, ut64 loadaddr, Sdb *sdb){
+	*bin_obj = r_bin_zimg_new_buf (b);
+	return *bin_obj != NULL;
 }
 
 static bool load(RBinFile *bf) {
-	if (!bf || !bf->o) {
-		return false;
-	}
-	ut64 size;
-	const ut8 *bytes = r_buf_data (bf->buf, &size);
-	return load_bytes (bf, &bf->o->bin_obj, bytes, size, bf->o->loadaddr, bf->sdb);
+	r_return_val_if_fail (bf && bf->o, false);
+	return load_buffer (bf, &bf->o->bin_obj, bf->buf, bf->o->loadaddr, bf->sdb);
 }
 
 static ut64 baddr(RBinFile *bf) {
 	return 0;
 }
 
-static bool check_bytes(const ut8 *buf, ut64 length) {
-	if (buf && length >= 8) {
+static bool check_buffer(RBuffer *b) {
+	ut8 zimghdr[8];
+	if (r_buf_read_at (b, 0, zimghdr, sizeof (zimghdr))) {
 		// Checking ARM zImage kernel
-		if (!memcmp (buf, "\x00\x00\xa0\xe1\x00\x00\xa0\xe1", 8)) {
+		if (!memcmp (zimghdr, "\x00\x00\xa0\xe1\x00\x00\xa0\xe1", 8)) {
 			return true;
 		}
 	}
-	// TODO: Add other architectures
 	return false;
 }
 
@@ -78,13 +61,13 @@ static RBinInfo *info(RBinFile *bf) {
 RBinPlugin r_bin_plugin_zimg = {
 	.name = "zimg",
 	.desc = "zimg format bin plugin",
 	.license = "LGPL3",
 	.get_sdb = &get_sdb,
 	.load = &load,
-	.load_bytes = &load_bytes,
-	.check_bytes = &check_bytes,
+	.load_buffer = &load_buffer,
+	.check_buffer = &check_buffer,
 	.baddr = &baddr,
 	.info = &info,
 };
 
 #ifndef CORELIB
diff --git a/libr/core/cbin.c b/libr/core/cbin.c
index 66a69eb3c7..c7ca93cb67 100644
--- a/libr/core/cbin.c
+++ b/libr/core/cbin.c
@@ -583,251 +583,252 @@ R_API void r_core_anal_cc_init(RCore *core) {
 static int bin_info(RCore *r, int mode, ut64 laddr) {
 	int i, j, v;
 	char str[R_FLAG_NAME_SIZE];
 	RBinInfo *info = r_bin_get_info (r->bin);
 	RBinFile *binfile = r_core_bin_cur (r);
 	RBinObject *obj = r_bin_cur_object (r->bin);
 	const char *compiled = NULL;
 	bool havecode;
 
 	if (!binfile || !info || !obj) {
 		if (mode & R_MODE_JSON) {
 			r_cons_printf ("{}");
 		}
 		return false;
 	}
 	havecode = is_executable (obj) | (obj->entries != NULL);
 	compiled = get_compile_time (binfile->sdb);
 
 	if (IS_MODE_SET (mode)) {
 		r_config_set (r->config, "file.type", info->rclass);
 		r_config_set (r->config, "cfg.bigendian",
 			      info->big_endian ? "true" : "false");
 		if (info->rclass && !strcmp (info->rclass, "fs")) {
 			// r_config_set (r->config, "asm.arch", info->arch);
 			// r_core_seek (r, 0, 1);
 			// eprintf ("m /root %s 0", info->arch);
 	//		r_core_cmdf (r, "m /root hfs @ 0", info->arch);
 		} else {
 			if (info->lang) {
 				r_config_set (r->config, "bin.lang", info->lang);
 			}
 			r_config_set (r->config, "asm.os", info->os);
 			if (info->rclass && !strcmp (info->rclass, "pe")) {
 				r_config_set (r->config, "anal.cpp.abi", "msvc");
 			} else {
 				r_config_set (r->config, "anal.cpp.abi", "itanium");
 			}
 			r_config_set (r->config, "asm.arch", info->arch);
 			if (info->cpu && *info->cpu) {
 				r_config_set (r->config, "asm.cpu", info->cpu);
 			}
 			r_config_set (r->config, "anal.arch", info->arch);
 			snprintf (str, R_FLAG_NAME_SIZE, "%i", info->bits);
 			r_config_set (r->config, "asm.bits", str);
 			r_config_set (r->config, "asm.dwarf",
 				(R_BIN_DBG_STRIPPED & info->dbg_info) ? "false" : "true");
 			v = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);
 			if (v != -1) {
 				r_config_set_i (r->config, "asm.pcalign", v);
 			}
 		}
 		r_core_anal_type_init (r);
 		r_core_anal_cc_init (r);
 	} else if (IS_MODE_SIMPLE (mode)) {
 		r_cons_printf ("arch %s\n", info->arch);
 		if (info->cpu && *info->cpu) {
 			r_cons_printf ("cpu %s\n", info->cpu);
 		}
 		r_cons_printf ("bits %d\n", info->bits);
 		r_cons_printf ("os %s\n", info->os);
 		r_cons_printf ("endian %s\n", info->big_endian? "big": "little");
 		v = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);
 		if (v != -1) {
 			r_cons_printf ("minopsz %d\n", v);
 		}
 		v = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);
 		if (v != -1) {
 			r_cons_printf ("maxopsz %d\n", v);
 		}
 		v = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);
 		if (v != -1) {
 			r_cons_printf ("pcalign %d\n", v);
 		}
 	} else if (IS_MODE_RAD (mode)) {
 		if (info->type && !strcmp (info->type, "fs")) {
 			r_cons_printf ("e file.type=fs\n");
 			r_cons_printf ("m /root %s 0\n", info->arch);
 		} else {
 			r_cons_printf ("e cfg.bigendian=%s\n"
 				"e asm.bits=%i\n"
 				"e asm.dwarf=%s\n",
 				r_str_bool (info->big_endian),
 				info->bits,
 				r_str_bool (R_BIN_DBG_STRIPPED &info->dbg_info));
 			if (info->lang && *info->lang) {
 				r_cons_printf ("e bin.lang=%s\n", info->lang);
 			}
 			if (info->rclass && *info->rclass) {
 				r_cons_printf ("e file.type=%s\n",
 					info->rclass);
 			}
 			if (info->os) {
 				r_cons_printf ("e asm.os=%s\n", info->os);
 			}
 			if (info->arch) {
 				r_cons_printf ("e asm.arch=%s\n", info->arch);
 			}
 			if (info->cpu && *info->cpu) {
 				r_cons_printf ("e asm.cpu=%s\n", info->cpu);
 			}
 			v = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);
 			if (v != -1) {
 				r_cons_printf ("e asm.pcalign=%d\n", v);
 			}
 		}
 	} else {
 		// XXX: if type is 'fs' show something different?
 		char *tmp_buf;
 		if (IS_MODE_JSON (mode)) {
 			r_cons_printf ("{");
 		}
 		pair_str ("arch", info->arch, mode, false);
 		if (info->cpu && *info->cpu) {
 			pair_str ("cpu", info->cpu, mode, false);
 		}
 		pair_ut64x ("baddr", r_bin_get_baddr (r->bin), mode, false);
 		pair_ut64 ("binsz", r_bin_get_size (r->bin), mode, false);
 		pair_str ("bintype", info->rclass, mode, false);
 		pair_int ("bits", info->bits, mode, false);
 		pair_bool ("canary", info->has_canary, mode, false);
 		if (info->has_retguard != -1) {
 			pair_bool ("retguard", info->has_retguard, mode, false);
 		}
 		pair_str ("class", info->bclass, mode, false);
 		if (info->actual_checksum) {
 			/* computed checksum */
 			pair_str ("cmp.csum", info->actual_checksum, mode, false);
 		}
 		pair_str ("compiled", compiled, mode, false);
 		pair_str ("compiler", info->compiler, mode, false);
 		pair_bool ("crypto", info->has_crypto, mode, false);
 		pair_str ("dbg_file", info->debug_file_name, mode, false);
 		pair_str ("endian", info->big_endian ? "big" : "little", mode, false);
 		if (info->rclass && !strcmp (info->rclass, "mdmp")) {
 			tmp_buf = sdb_get (binfile->sdb, "mdmp.flags", 0);
 			if (tmp_buf) {
 				pair_str ("flags", tmp_buf, mode, false);
 				free (tmp_buf);
 			}
 		}
 		pair_bool ("havecode", havecode, mode, false);
 		if (info->claimed_checksum) {
 			/* checksum specified in header */
 			pair_str ("hdr.csum", info->claimed_checksum, mode, false);
 		}
 		pair_str ("guid", info->guid, mode, false);
 		pair_str ("intrp", info->intrp, mode, false);
 		pair_ut64x ("laddr", laddr, mode, false);
 		pair_str ("lang", info->lang, mode, false);
 		pair_bool ("linenum", R_BIN_DBG_LINENUMS & info->dbg_info, mode, false);
 		pair_bool ("lsyms", R_BIN_DBG_SYMS & info->dbg_info, mode, false);
 		pair_str ("machine", info->machine, mode, false);
 		v = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);
 		if (v != -1) {
 			pair_int ("maxopsz", v, mode, false);
 		}
 		v = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);
 		if (v != -1) {
 			pair_int ("minopsz", v, mode, false);
 		}
 		pair_bool ("nx", info->has_nx, mode, false);
 		pair_str ("os", info->os, mode, false);
 		if (info->rclass && !strcmp (info->rclass, "pe")) {
 			pair_bool ("overlay", info->pe_overlay, mode, false);
 		}
 		v = r_anal_archinfo (r->anal, R_ANAL_ARCHINFO_ALIGN);
 		if (v != -1) {
 			pair_int ("pcalign", v, mode, false);
 		}
 		pair_bool ("pic", info->has_pi, mode, false);
 		pair_bool ("relocs", R_BIN_DBG_RELOCS & info->dbg_info, mode, false);
-		tmp_buf = sdb_get (obj->kv, "elf.relro", 0);
+		Sdb *sdb_info = sdb_ns (obj->kv, "info", false);
+		tmp_buf = sdb_get (sdb_info, "elf.relro", 0);
 		if (tmp_buf) {
 			pair_str ("relro", tmp_buf, mode, false);
 			free (tmp_buf);
 		}
 		pair_str ("rpath", info->rpath, mode, false);
 		if (info->rclass && !strcmp (info->rclass, "pe")) {
 			//this should be moved if added to mach0 (or others)
 			pair_bool ("signed", info->signature, mode, false);
 		}
 		pair_bool ("sanitiz", info->has_sanitizers, mode, false);
 		pair_bool ("static", r_bin_is_static (r->bin), mode, false);
 		if (info->rclass && !strcmp (info->rclass, "mdmp")) {
 			v = sdb_num_get (binfile->sdb, "mdmp.streams", 0);
 			if (v != -1) {
 				pair_int ("streams", v, mode, false);
 			}
 		}
 		pair_bool ("stripped", R_BIN_DBG_STRIPPED & info->dbg_info, mode, false);
 		pair_str ("subsys", info->subsystem, mode, false);
 		pair_bool ("va", info->has_va, mode, true);
 		if (IS_MODE_JSON (mode)) {
 			r_cons_printf (",\"checksums\":{");
 			for (i = 0; info->sum[i].type; i++) {
 				RBinHash *h = &info->sum[i];
 				ut64 hash = r_hash_name_to_bits (h->type);
 				RHash *rh = r_hash_new (true, hash);
 				ut8 *tmp = R_NEWS (ut8, h->to);
 				if (!tmp) {
 					return false;
 				}
 				r_buf_read_at (binfile->buf, h->from, tmp, h->to);
 				int len = r_hash_calculate (rh, hash, tmp, h->to);
 				free (tmp);
 				if (len < 1) {
 					eprintf ("Invaild checksum length\n");
 				}
 				r_hash_free (rh);
 				r_cons_printf ("%s\"%s\":{\"hex\":\"", i?",": "", h->type);
 				// r_cons_printf ("%s\t%d-%dc\t", h->type, h->from, h->to+h->from);
 				for (j = 0; j < h->len; j++) {
 					r_cons_printf ("%02x", h->buf[j]);
 				}
 				r_cons_printf ("\"}");
 			}
 			r_cons_printf ("}");
 		} else {
 			for (i = 0; info->sum[i].type; i++) {
 				RBinHash *h = &info->sum[i];
 				ut64 hash = r_hash_name_to_bits (h->type);
 				RHash *rh = r_hash_new (true, hash);
 				ut8 *tmp = R_NEWS (ut8, h->to);
 				if (!tmp) {
 					return false;
 				}
 				r_buf_read_at (binfile->buf, h->from, tmp, h->to);
 				int len = r_hash_calculate (rh, hash, tmp, h->to);
 				free (tmp);
 				if (len < 1) {
 					eprintf ("Invalid wtf\n");
 				}
 				r_hash_free (rh);
 				r_cons_printf ("%s  %d-%dc  ", h->type, h->from, h->to+h->from);
 				for (j = 0; j < h->len; j++) {
 					r_cons_printf ("%02x", h->buf[j]);
 				}
 				r_cons_newline ();
 			}
 		}
 		if (IS_MODE_JSON (mode)) {
 			r_cons_printf ("}");
 		}
 	}
 	const char *dir_prefix = r_config_get (r->config, "dir.prefix");
 	char *spath = sdb_fmt ("%s/"R2_SDB_FCNSIGN"/spec.sdb", dir_prefix);
 	if (r_file_exists (spath)) {
 		sdb_concat_by_path (r->anal->sdb_fmts, spath);
 	}
 	return true;
 }
diff --git a/libr/core/cmd.c b/libr/core/cmd.c
index e52577509c..cdf6943b54 100644
--- a/libr/core/cmd.c
+++ b/libr/core/cmd.c
@@ -1101,211 +1101,212 @@ R_API int r_line_hist_sdb_down(RLine *line) {
 static int cmd_kuery(void *data, const char *input) {
 	char buf[1024], *out;
 	RCore *core = (RCore*)data;
 	const char *sp, *p = "[sdb]> ";
 	const int buflen = sizeof (buf) - 1;
 	Sdb *s = core->sdb;
 	
 	char *cur_pos, *cur_cmd, *next_cmd = NULL;
 	char *temp_pos, *temp_cmd, *temp_storage = NULL;
 
 	switch (input[0]) {
 
 	case 'j':
 		out = sdb_querys (s, NULL, 0, "anal/**");
 		if (!out) {
 			r_cons_println ("No Output from sdb");
 			break;
 		}
 
 		r_cons_printf ("{\"anal\":{");
 
 		while (*out) {
 			cur_pos = strchr (out, '\n');
 			if (!cur_pos) {
 					break;
 			}
 			cur_cmd = r_str_ndup (out, cur_pos - out);
 
 			r_cons_printf ("\n\n\"%s\" : [", cur_cmd);
 
 			next_cmd = r_str_newf ("anal/%s/*", cur_cmd);
 			temp_storage = sdb_querys (s, NULL, 0, next_cmd);
 
 			if (!temp_storage) {
 				r_cons_println ("\nEMPTY\n");
 				r_cons_printf ("],\n\n");
 				out += cur_pos - out + 1;
 				continue;
 			}
 
 			while (*temp_storage) {
 				temp_pos = strchr (temp_storage, '\n');
 				if (!temp_pos) {
 					break;
 				}
 				
 				temp_cmd = r_str_ndup (temp_storage, temp_pos - temp_storage);
 				r_cons_printf ("\"%s\",", temp_cmd);
 				temp_storage += temp_pos - temp_storage + 1;
 			}
 
 			r_cons_printf ("],\n\n");
 			out += cur_pos - out + 1;
 		}
 
 		r_cons_printf ("}}");
 		free (next_cmd);
 		free (temp_storage);
 		break;
 
 	case ' ':
 		out = sdb_querys (s, NULL, 0, input + 1);
 		if (out) {
 			r_cons_println (out);
 		}
 		free (out);
 		break;
 	//case 's': r_pair_save (s, input + 3); break;
 	//case 'l': r_pair_load (sdb, input + 3); break;
 	case '\0':
 		sdb_foreach (s, callback_foreach_kv, NULL);
 		break;
 	// TODO: add command to list all namespaces // sdb_ns_foreach ?
-	case 's':
+	case 's': // "ks"
 		if (core->http_up) {
 			return false;
 		}
 		if (!r_cons_is_interactive ()) {
 			return false;
 		}
 		if (input[1] == ' ') {
 			char *n, *o, *p = strdup (input + 2);
 			// TODO: slash split here? or inside sdb_ns ?
 			for (n = o = p; n; o = n) {
 				n = strchr (o, '/'); // SDB_NS_SEPARATOR NAMESPACE
 				if (n) {
 					*n++ = 0;
 				}
 				s = sdb_ns (s, o, 1);
 			}
 			free (p);
 		}
 		if (!s) {
 			s = core->sdb;
 		}
 		RLine *line = core->cons->line;
 		if (!line->sdbshell_hist) {
 			line->sdbshell_hist = r_list_newf (free);
 			r_list_append (line->sdbshell_hist, r_str_new ("\0"));
 		}
 		RList *sdb_hist = line->sdbshell_hist;
 		r_line_set_hist_callback (line, &r_line_hist_sdb_up, &r_line_hist_sdb_down);
 		for (;;) {
 			r_line_set_prompt (p);
 			if (r_cons_fgets (buf, buflen, 0, NULL) < 1) {
 				break;
 			}
 			if (!*buf) {
 				break;
 			}
 			if (sdb_hist) {
 				if ((r_list_length (sdb_hist) == 1) || (r_list_length (sdb_hist) > 1 && strcmp (r_list_get_n (sdb_hist, 1), buf))) {
 					r_list_insert (sdb_hist, 1, strdup (buf));
 				}
 				line->sdbshell_hist_iter = sdb_hist->head;
 			}
 			out = sdb_querys (s, NULL, 0, buf);
 			if (out) {
 				r_cons_println (out);
+				r_cons_flush ();
 			}
 		}
 		r_line_set_hist_callback (core->cons->line, &r_line_hist_cmd_up, &r_line_hist_cmd_down);
 		break;
 	case 'o':
 		if (r_sandbox_enable (0)) {
 			eprintf ("This command is disabled in sandbox mode\n");
 			return 0;
 		}
 		if (input[1] == ' ') {
 			char *fn = strdup (input + 2);
 			if (!fn) {
 				eprintf("Unable to allocate memory\n");
 				return 0;
 			}
 			char *ns = strchr (fn, ' ');
 			if (ns) {
 				Sdb *db;
 				*ns++ = 0;
 				if (r_file_exists (fn)) {
 					db = sdb_ns_path (core->sdb, ns, 1);
 					if (db) {
 						Sdb *newdb = sdb_new (NULL, fn, 0);
 						if (newdb) {
 							sdb_drain  (db, newdb);
 						} else {
 							eprintf ("Cannot open sdb '%s'\n", fn);
 						}
 					} else {
 						eprintf ("Cannot find sdb '%s'\n", ns);
 					}
 				} else {
 					eprintf ("Cannot open file\n");
 				}
 			} else {
 				eprintf ("Missing sdb namespace\n");
 			}
 			free (fn);
 		} else {
 			eprintf ("Usage: ko [file] [namespace]\n");
 		}
 		break;
 	case 'd':
 		if (r_sandbox_enable (0)) {
 			eprintf ("This command is disabled in sandbox mode\n");
 			return 0;
 		}
 		if (input[1] == ' ') {
 			char *fn = strdup (input + 2);
 			char *ns = strchr (fn, ' ');
 			if (ns) {
 				*ns++ = 0;
 				Sdb *db = sdb_ns_path (core->sdb, ns, 0);
 				if (db) {
 					sdb_file (db, fn);
 					sdb_sync (db);
 				} else {
 					eprintf ("Cannot find sdb '%s'\n", ns);
 				}
 			} else {
 				eprintf ("Missing sdb namespace\n");
 			}
 			free (fn);
 		} else {
 			eprintf ("Usage: kd [file] [namespace]\n");
 		}
 		break;
 	case '?':
 		r_core_cmd_help (core, help_msg_k);
 		break;
 	}
 
 	if (input[0] == '\0') {
 		/* nothing more to do, the command has been parsed. */
 		return 0;
 	}
 
 	sp = strchr (input + 1, ' ');
 	if (sp) {
 		char *inp = strdup (input);
 		inp [(size_t)(sp - input)] = 0;
 		s = sdb_ns (core->sdb, inp + 1, 1);
 		out = sdb_querys (s, NULL, 0, sp + 1);
 		if (out) {
 			r_cons_println (out);
 			free (out);
 		}
 		free (inp);
 		return 0;
 	}
 	return 0;
 }
diff --git a/libr/core/cmd_info.c b/libr/core/cmd_info.c
index 7ead22d2c8..98f100887e 100644
--- a/libr/core/cmd_info.c
+++ b/libr/core/cmd_info.c
@@ -336,730 +336,729 @@ static bool is_equal_file_hashes(RList *lfile_hashes, RList *rfile_hashes, bool
 static int cmd_info(void *data, const char *input) {
 	RCore *core = (RCore *) data;
 	bool newline = r_cons_is_interactive ();
 	int fd = r_io_fd_get_current (core->io);
 	RIODesc *desc = r_io_desc_get (core->io, fd);
 	int i, va = core->io->va || core->io->debug;
 	int mode = 0; //R_MODE_SIMPLE;
 	bool rdump = false;
 	int is_array = 0;
 	Sdb *db;
 
 	for (i = 0; input[i] && input[i] != ' '; i++)
 		;
 	if (i > 0) {
 		switch (input[i - 1]) {
 		case '*': mode = R_MODE_RADARE; break;
 		case 'j': mode = R_MODE_JSON; break;
 		case 'q': mode = R_MODE_SIMPLE; break;
 		}
 	}
 	if (mode == R_MODE_JSON) {
 		int suffix_shift = 0;
 		if (!strncmp (input, "SS", 2) || !strncmp (input, "ee", 2)
 			|| !strncmp (input, "zz", 2)) {
 			suffix_shift = 1;
 		}
 		if (strlen (input + 1 + suffix_shift) > 1) {
 			is_array = 1;
 		}
 	}
 	if (is_array) {
 		r_cons_printf ("{");
 	}
 	if (!*input) {
 		cmd_info_bin (core, va, mode);
 	}
 	/* i* is an alias for iI* */
 	if (!strcmp (input, "*")) {
 		input = "I*";
 	}
 	char *question = strchr (input, '?');
 	if (question > input) {
 		question--;
 		r_core_cmdf (core, "i?~ i%c", *question);
 		goto done;
 	}
 	while (*input) {
 		switch (*input) {
 		case 'b': // "ib"
 		{
 			ut64 baddr = r_config_get_i (core->config, "bin.baddr");
 			if (input[1] == ' ') {
 				baddr = r_num_math (core->num, input + 1);
 			}
 			// XXX: this will reload the bin using the buffer.
 			// An assumption is made that assumes there is an underlying
 			// plugin that will be used to load the bin (e.g. malloc://)
 			// TODO: Might be nice to reload a bin at a specified offset?
 			r_core_bin_reload (core, NULL, baddr);
 			r_core_block_read (core);
 			newline = false;
 		}
 		break;
 		case 'k': // "ik"
 		{
 			RBinObject *o = r_bin_cur_object (core->bin);
 			db = o? o->kv: NULL;
 			//:eprintf ("db = %p\n", db);
 			switch (input[1]) {
 			case 'v':
 				if (db) {
 					char *o = sdb_querys (db, NULL, 0, input + 3);
 					if (o && *o) {
 						r_cons_print (o);
 					}
 					free (o);
 				}
 				break;
 			case '*':
 				r_core_bin_export_info_rad (core);
 				break;
 			case '.':
 			case ' ':
 				if (db) {
 					char *o = sdb_querys (db, NULL, 0, input + 2);
 					if (o && *o) {
 						r_cons_print (o);
 					}
 					free (o);
 				}
 				break;
 			case '\0':
 				if (db) {
 					char *o = sdb_querys (db, NULL, 0, "*");
 					if (o && *o) {
 						r_cons_print (o);
 					}
 					free (o);
 				}
 				break;
 			case '?':
 			default:
 				eprintf ("Usage: ik [sdb-query]\n");
 				eprintf ("Usage: ik*    # load all header information\n");
 			}
 			goto done;
 		}
 		break;
 		case 'o': // "io"
 		{
 			if (!desc) {
 				eprintf ("Core file not open\n");
 				return 0;
 			}
 			const char *fn = input[1] == ' '? input + 2: desc->name;
 			ut64 baddr = r_config_get_i (core->config, "bin.baddr");
 			r_core_bin_load (core, fn, baddr);
 		}
 		break;
 			#define RBININFO(n,x,y,z)\
 				if (is_array) {\
 					if (is_array == 1) { is_array++;\
 					} else { r_cons_printf (",");}\
 					r_cons_printf ("\"%s\":",n);\
 				}\
 				if (z) { playMsg (core, n, z);}\
 				r_core_bin_info (core, x, mode, va, NULL, y);
 		case 'A': // "iA"
 			newline = false;
 			if (input[1] == 'j') {
 				r_cons_printf ("{");
 				r_bin_list_archs (core->bin, 'j');
 				r_cons_printf ("}\n");
 			} else {
 				r_bin_list_archs (core->bin, 1);
 			}
 			break;
 		case 'E': // "iE"
 		{
 			if (input[1] == 'j' && input[2] == '.') {
 				mode = R_MODE_JSON;
 				RBININFO ("exports", R_CORE_BIN_ACC_EXPORTS, input + 2, 0);
 			} else {
 				RBININFO ("exports", R_CORE_BIN_ACC_EXPORTS, input + 1, 0);
 			}
 			while (*(++input)) ;
 			input--;
 			break;
 		}
 		case 't': // "it"
 			{
 				ut64 limit = r_config_get_i (core->config, "bin.hashlimit");
 				const char *fileName;
 				RBinInfo *info = r_bin_get_info (core->bin);
 				if (info) {
 					fileName = info->file;
 				} else {
 					int fd = r_io_fd_get_current (core->io);
 					RIODesc *desc = r_io_desc_get (core->io, fd);
 					fileName = desc? desc->name: NULL;
 				}
 				const bool is_json = input[1] == 'j'; // "itj"
 				RList *old_file_hashes = NULL;
 				if (!r_bin_file_hash (core->bin, limit, fileName, &old_file_hashes)) {
 					eprintf ("r_bin_file_hash: Cannot get file hashes");
 					r_list_free (old_file_hashes);
 					return 0;
 				}
 
 				if (old_file_hashes && r_list_empty (old_file_hashes)) {
 					// clean the old hashes list to reduce comparison operations in case it is allocated but empty
 					r_list_free (old_file_hashes);
 					old_file_hashes = NULL;
 				}
 				if (!info) {
 					info = r_bin_get_info (core->bin);
 				}
 				if (!info) {
 					eprintf ("r_bin_get_info: Cannot get bin info");
 					r_list_free (old_file_hashes);
 					return 0;
 				}
 
 				bool equal = true;
 				// check are hashes changed
 				if (!r_list_empty (old_file_hashes) && !r_list_empty (info->file_hashes)) {
 					if (!is_equal_file_hashes (old_file_hashes, info->file_hashes, &equal)) {
 						eprintf ("is_equal_file_hashes: Cannot compare file hashes");
 						r_list_free (old_file_hashes);
 						return 0;
 					}
 				}
 
 				RBinFileHash *fh_old, *fh_new;
 				RListIter *hiter_old, *hiter_new;
 
 				if (is_json) { // "itj"
 					PJ *pj = pj_new ();
 					if (!pj) {
 						eprintf ("JSON mode failed\n");
 						r_list_free (old_file_hashes);
 						return 0;
 					}
 					pj_o (pj);
 					r_list_foreach (info->file_hashes, hiter_new, fh_new) {
 						pj_ks (pj, fh_new->type ? fh_new->type : "", fh_new->hex ? fh_new->hex : "");
 					}
 					if (!equal) {
 						// print old hashes prefixed with `o` character like `omd5` and `osha1`
 						r_list_foreach (old_file_hashes, hiter_old, fh_old) {
 							char *key = r_str_newf ("o%s", fh_old->type ? fh_old->type : "");
 							pj_ks (pj, key, fh_old->hex ? fh_old->hex : "");
 							free (key);
 						}
 					}
 					pj_end (pj);
 					r_cons_printf ("%s", pj_string (pj));
 					pj_free (pj);
 				} else { // "it"
 					if (!equal) {
 						eprintf ("File has been modified.\n");
 						hiter_new = r_list_iterator (info->file_hashes);
 						hiter_old = r_list_iterator (old_file_hashes);
 						while (r_list_iter_next(hiter_new) && r_list_iter_next (hiter_old)) {
 							fh_new = (RBinFileHash*)r_list_iter_get (hiter_new);
 							fh_old = (RBinFileHash*)r_list_iter_get (hiter_old);
 							if (strcmp (fh_new->type, fh_old->type)) {
 								eprintf ("Wrong file hashes structure");
 								break;
 							}
 							if (!strcmp (fh_new->hex, fh_old->hex)) {
 								eprintf ("= %s %s\n", fh_new->type, fh_new->hex);  // output one line because hash remains same `= hashtype hashval`
 							} else {
 								// output diff-like two lines, one with old hash val `- hashtype hashval` and one with new `+ hashtype hashval`
 								eprintf ("- %s %s\n"
 									"+ %s %s\n",
 									fh_old->type, fh_old->hex,
 									fh_new->type, fh_new->hex);
 							}
 						}
 					} else { // hashes are equal
 						r_list_foreach (info->file_hashes, hiter_new, fh_new) {
 							r_cons_printf ("%s %s\n", fh_new->type ? fh_new->type : "", fh_new->hex ? fh_new->hex : "");
 						}
 					}
 				}
 
 				if (!r_list_empty (old_file_hashes)) {
 					r_list_free (old_file_hashes);
 				}
 			}
 			break;
 		case 'Z': // "iZ"
 			RBININFO ("size", R_CORE_BIN_ACC_SIZE, NULL, 0);
 			break;
 		case 'O': // "iO"
 			switch (input[1]) {
 			case ' ':
 			        r_sys_cmdf ("rabin2 -O \"%s\" \"%s\"", r_str_trim_ro (input + 1), desc->name);
 			        break;
 			default:
 			        r_sys_cmdf ("rabin2 -O help");
 			        break;
 			}
 			return 0;
 		case 'S': // "iS"
 			//we comes from ia or iS
 			if ((input[1] == 'm' && input[2] == 'z') || !input[1]) {
 				RBININFO ("sections", R_CORE_BIN_ACC_SECTIONS, NULL, 0);
 			} else if (input[1] == 'S' && !input[2]) {  // "iSS"
 				RBININFO ("segments", R_CORE_BIN_ACC_SEGMENTS, NULL, 0);
 			} else {  //iS/iSS entropy,sha1
 				const char *name = "sections";
 				int action = R_CORE_BIN_ACC_SECTIONS;
 				int param_shift = 0;
 				if (input[1] == 'S') {
 					name = "segments";
 					action = R_CORE_BIN_ACC_SEGMENTS;
 					param_shift = 1;
 				}
 				// case for iS=
 				if (input[1] == '=') {
 					mode = R_MODE_EQUAL;
 				} else if (input[1] == 'q' && input[2] == '.') {
 					mode = R_MODE_SIMPLE;
 				} else if (input[1] == 'j' && input[2] == '.') {
 					mode = R_MODE_JSON;
 				}
 				RBinObject *obj = r_bin_cur_object (core->bin);
 				if (mode == R_MODE_RADARE || mode == R_MODE_JSON || mode == R_MODE_SIMPLE) {
 					RBININFO (name, action, input + 2 + param_shift,
 						(obj && obj->sections)? r_list_length (obj->sections): 0);
 				} else {
 					RBININFO (name, action, input + 1 + param_shift,
 						(obj && obj->sections)? r_list_length (obj->sections): 0);
 				}
 			}
 			//we move input until get '\0'
 			while (*(++input)) ;
 			//input-- because we are inside a while that does input++
 			// oob read if not input--
 			input--;
 			break;
 		case 'H': // "iH"
 			if (input[1] == 'H') { // "iHH"
 				RBININFO ("header", R_CORE_BIN_ACC_HEADER, NULL, -1);
 				break;
 			}
 		case 'h': // "ih"
 			RBININFO ("fields", R_CORE_BIN_ACC_FIELDS, NULL, 0);
 			break;
 		case 'l': { // "il"
 			RBinObject *obj = r_bin_cur_object (core->bin);
 			RBININFO ("libs", R_CORE_BIN_ACC_LIBS, NULL, (obj && obj->libs)? r_list_length (obj->libs): 0);
 			break;
 		}
 		case 'L': { // "iL"
 			char *ptr = strchr (input, ' ');
 			int json = input[1] == 'j'? 'j': 0;
 
 			if (ptr && ptr[1]) {
 				const char *plugin_name = ptr + 1;
 				if (is_array) {
 					r_cons_printf ("\"plugin\": ");
 				}
 				r_bin_list_plugin (core->bin, plugin_name, json);
 			} else {
 				r_bin_list (core->bin, json);
 			}
 			newline = false;
 			goto done;
 		}
 		case 's': { // "is"
 			RBinObject *obj = r_bin_cur_object (core->bin);
 			// Case for isj.
 			if (input[1] == 'j' && input[2] == '.') {
 				mode = R_MODE_JSON;
 				RBININFO ("symbols", R_CORE_BIN_ACC_SYMBOLS, input + 2, (obj && obj->symbols)? r_list_length (obj->symbols): 0);
 			} else if (input[1] == 'q' && input[2] == 'q') {
 				mode = R_MODE_SIMPLEST;
 				RBININFO ("symbols", R_CORE_BIN_ACC_SYMBOLS, input + 1, (obj && obj->symbols)? r_list_length (obj->symbols): 0);
 			} else {
 				RBININFO ("symbols", R_CORE_BIN_ACC_SYMBOLS, input + 1, (obj && obj->symbols)? r_list_length (obj->symbols): 0);
 			}
 			while (*(++input)) ;
 			input--;
 			break;
 		}
 		case 'R': // "iR"
 			if  (input[1] == '*') {
 				mode = R_MODE_RADARE;
 			} else if (input[1] == 'j') {
 				mode = R_MODE_JSON;
 			}
 			RBININFO ("resources", R_CORE_BIN_ACC_RESOURCES, NULL, 0);
 			break;
 		case 'r': // "ir"
 			RBININFO ("relocs", R_CORE_BIN_ACC_RELOCS, NULL, 0);
 			break;
 		case 'X': // "iX"
 			RBININFO ("source", R_CORE_BIN_ACC_SOURCE, NULL, 0);
 			break;
 		case 'd': // "id"
 			if (input[1] == 'p') { // "idp"
 				SPDBOptions pdbopts;
 				RBinInfo *info;
 				bool file_found;
 				char *filename;
 
 				switch (input[2]) {
 				case ' ':
 					r_core_cmdf (core, ".idpi* %s", input + 3);
 					while (input[2]) input++;
 					break;
 				case '\0':
 					r_core_cmd0 (core, ".idpi*");
 					break;
 				case 'd':
 					pdbopts.user_agent = (char*) r_config_get (core->config, "pdb.useragent");
 					pdbopts.symbol_server = (char*) r_config_get (core->config, "pdb.server");
 					pdbopts.extract = r_config_get_i (core->config, "pdb.extract");
 					pdbopts.symbol_store_path = (char*) r_config_get (core->config, "pdb.symstore");
 					int r = r_bin_pdb_download (core, 0, NULL, &pdbopts);
 					if (r > 0) {
 						eprintf ("Error while downloading pdb file");
 					}
 					input++;
 					break;
 				case 'i':
 					info = r_bin_get_info (core->bin);
 					filename = strchr (input, ' ');
 					while (input[2]) input++;
 					if (filename) {
 						*filename++ = '\0';
 						filename = strdup (filename);
 						file_found = r_file_exists (filename);
 					} else {
 						/* Autodetect local file */
 						if (!info || !info->debug_file_name) {
 							eprintf ("Cannot get file's debug information");
 							break;
 						}
 						// Check raw path for debug filename
 						file_found = r_file_exists (r_file_basename (info->debug_file_name));
 						if (file_found) {
 							filename = strdup (r_file_basename (info->debug_file_name));
 						} else {
 							// Check debug filename basename in current directory
 							char* basename = (char*) r_file_basename (info->debug_file_name);
 							file_found = r_file_exists (basename);
 							if (!file_found) {
 								// Check if debug file is in file directory
 								char* dir = r_file_dirname (core->bin->cur->file);
 								filename = r_str_newf ("%s/%s", dir, basename);
 								file_found = r_file_exists (filename);
 							} else {
 								filename = strdup (basename);
 							}
 						}
 
 						// Last chance: Check if file is in downstream symbol store
 						if (!file_found) {
 							const char* symstore_path = r_config_get (core->config, "pdb.symstore");
 							char* pdb_path = r_str_newf ("%s" R_SYS_DIR "%s" R_SYS_DIR "%s" R_SYS_DIR "%s",
 										     symstore_path, r_file_basename (info->debug_file_name),
 										     info->guid, r_file_basename (info->debug_file_name));
 							file_found = r_file_exists (pdb_path);
 							if (file_found) {
 								filename = pdb_path;
 							} else {
 								R_FREE(pdb_path);
 							}
 						}
 					}
 
 					if (!file_found) {
 						eprintf ("File '%s' not found in file directory or symbol store", r_file_basename (info->debug_file_name));
 						free (filename);
 						break;
 					}
 					ut64 baddr = 0;
 					if (core->bin->cur && core->bin->cur->o) {
 						baddr = core->bin->cur->o->baddr;
 					} else {
 						eprintf ("Warning: Cannot find base address, flags will probably be misplaced\n");
 					}
 					r_core_pdb_info (core, filename, baddr, mode);
 					free (filename);
 					break;
 				case '?':
 				default:
 					r_core_cmd_help (core, help_msg_id);
 					input++;
 					break;
 				}
 				input++;
 			} else if (input[1] == '?') { // "id?"
 				r_core_cmd_help (core, help_msg_id);
 				input++;
 			} else { // "id"
 				RBININFO ("dwarf", R_CORE_BIN_ACC_DWARF, NULL, -1);
 			}
 			break;
 		case 'i': { // "ii"
 			RBinObject *obj = r_bin_cur_object (core->bin);
 			RBININFO ("imports", R_CORE_BIN_ACC_IMPORTS, NULL,
 				(obj && obj->imports)? r_list_length (obj->imports): 0);
 			break;
 		}
 		case 'I': // "iI"
 			RBININFO ("info", R_CORE_BIN_ACC_INFO, NULL, 0);
 			break;
 		case 'e': // "ie"
 			if (input[1] == 'e') {
 				RBININFO ("initfini", R_CORE_BIN_ACC_INITFINI, NULL, 0);
 				input++;
 			} else {
 				RBININFO ("entries", R_CORE_BIN_ACC_ENTRIES, NULL, 0);
 			}
 			break;
 		case 'M': // "iM"
 			RBININFO ("main", R_CORE_BIN_ACC_MAIN, NULL, 0);
 			break;
 		case 'm': // "im"
 			RBININFO ("memory", R_CORE_BIN_ACC_MEM, NULL, 0);
 			break;
 		case 'V': // "iV"
 			RBININFO ("versioninfo", R_CORE_BIN_ACC_VERSIONINFO, NULL, 0);
 			break;
 		case 'C': // "iC"
 			RBININFO ("signature", R_CORE_BIN_ACC_SIGNATURE, NULL, 0);
 			break;
 		case 'z': // "iz"
 			if (input[1] == '-') { //iz-
 				char *strpurge = core->bin->strpurge;
 				ut64 addr = core->offset;
 				bool old_tmpseek = core->tmpseek;
 				input++;
 				if (input[1] == ' ') {
 					const char *argstr = r_str_trim_ro (input + 2);
 					ut64 arg = r_num_get (NULL, argstr);
 					input++;
 					if (arg != 0 || *argstr == '0') {
 						addr = arg;
 					}
 				}
 				core->tmpseek = false;
 				r_core_cmdf (core, "e bin.str.purge=%s%s0x%" PFMT64x,
 				             strpurge ? strpurge : "",
 				             strpurge && *strpurge ? "," : "",
 				             addr);
 				core->tmpseek = old_tmpseek;
 				newline = false;
 			} else if (input[1] == 'z') { //izz
 				switch (input[2]) {
 				case 'z'://izzz
 					rdump = true;
 					break;
 				case '*':
 					mode = R_MODE_RADARE;
 					break;
 				case 'j':
 					mode = R_MODE_JSON;
 					break;
 				case 'q': //izzq
 					if (input[3] == 'q') { //izzqq
 						mode = R_MODE_SIMPLEST;
 						input++;
 					} else {
 						mode = R_MODE_SIMPLE;
 					}
 					break;
 				default:
 					mode = R_MODE_PRINT;
 					break;
 				}
 				input++;
 				if (rdump) {
 					RBinFile *bf = r_core_bin_cur (core);
 					int min = r_config_get_i (core->config, "bin.minstr");
 					if (bf) {
 						bf->strmode = mode;
 						r_bin_dump_strings (bf, min, 2);
 					}
 					goto done;
 				}
 				RBININFO ("strings", R_CORE_BIN_ACC_RAW_STRINGS, NULL, 0);
 			} else {
 				RBinObject *obj = r_bin_cur_object (core->bin);
 				if (input[1] == 'q') {
 					mode = (input[2] == 'q')
 					? R_MODE_SIMPLEST
 					: R_MODE_SIMPLE;
 					input++;
 				}
 				if (obj) {
 					RBININFO ("strings", R_CORE_BIN_ACC_STRINGS, NULL,
 						(obj && obj->strings)? r_list_length (obj->strings): 0);
 				}
 			}
 			break;
 		case 'c': // "ic"
 		// XXX this is dupe of cbin.c:bin_classes()
 			if (input[1] == '?') {
 				eprintf ("Usage: ic[ljqc**] [class-index or name]\n");
 			} else if (input[1] == ' ' || input[1] == 'q' || input[1] == 'j' || input[1] == 'l' || input[1] == 'c' || input[1] == '*') {
 				RBinClass *cls;
 				RBinSymbol *sym;
 				RListIter *iter, *iter2;
 				RBinObject *obj = r_bin_cur_object (core->bin);
 				if (obj) {
 					if (input[2]) {
 						bool radare2 = strstr (input, "**") != NULL;
 						int idx = -1;
 						const char * cls_name = NULL;
 						if (radare2) {
 							input ++;
 						}
 						if (r_num_is_valid_input (core->num, input + 2)) {
 							idx = r_num_math (core->num, input + 2);
 						} else {
 							const char * first_char = input + ((input[1] == ' ') ? 1 : 2);
 							int not_space = strspn (first_char, " ");
 							if (first_char[not_space]) {
 								cls_name = first_char + not_space;
 							}
 						}
 						if (radare2) {
 							input++;
 						}
 						int count = 0;
 						r_list_foreach (obj->classes, iter, cls) {
 							if (radare2) {
 								r_cons_printf ("ac %s\n", cls->name);
 								r_list_foreach (cls->methods, iter2, sym) {
-									const char *comma = iter2->p? " ": "";
 									r_cons_printf ("ac %s %s 0x%08"PFMT64x"\n", cls->name, sym->name, sym->vaddr);
 								}
 								continue;
 							}
 							if ((idx >= 0 && idx != count++) ||
 							   (cls_name && *cls_name && strcmp (cls_name, cls->name) != 0)) {
 								continue;
 							}
 							switch (input[1]) {
 							case '*':
 								r_list_foreach (cls->methods, iter2, sym) {
 									r_cons_printf ("f sym.%s @ 0x%"PFMT64x "\n",
 										sym->name, sym->vaddr);
 								}
 								input++;
 								break;
 							case 'l':
 								r_list_foreach (cls->methods, iter2, sym) {
 									const char *comma = iter2->p? " ": "";
 									r_cons_printf ("%s0x%"PFMT64d, comma, sym->vaddr);
 								}
 								r_cons_newline ();
 								input++;
 								break;
 							case 'j':
 								input++;
 								r_cons_printf ("\"class\":\"%s\"", cls->name);
 								r_cons_printf (",\"methods\":[");
 								r_list_foreach (cls->methods, iter2, sym) {
 									const char *comma = iter2->p? ",": "";
 
 									if (sym->method_flags) {
 										char *flags = r_core_bin_method_flags_str (sym->method_flags, R_MODE_JSON);
 										r_cons_printf ("%s{\"name\":\"%s\",\"flags\":%s,\"vaddr\":%"PFMT64d "}",
 											comma, sym->name, flags, sym->vaddr);
 										R_FREE (flags);
 									} else {
 										r_cons_printf ("%s{\"name\":\"%s\",\"vaddr\":%"PFMT64d "}",
 											comma, sym->name, sym->vaddr);
 									}
 								}
 								r_cons_printf ("]");
 								break;
 							default:
 								r_cons_printf ("class %s\n", cls->name);
 								r_list_foreach (cls->methods, iter2, sym) {
 									char *flags = r_core_bin_method_flags_str (sym->method_flags, 0);
 									r_cons_printf ("0x%08"PFMT64x " method %s %s %s\n",
 										sym->vaddr, cls->name, flags, sym->name);
 									R_FREE (flags);
 								}
 								break;
 							}
 							goto done;
 						}
 						goto done;
 					} else if (obj->classes) {
 						playMsg (core, "classes", r_list_length (obj->classes));
 						if (input[1] == 'l' && obj) { // "icl"
 							r_list_foreach (obj->classes, iter, cls) {
 								r_list_foreach (cls->methods, iter2, sym) {
 									const char *comma = iter2->p? " ": "";
 									r_cons_printf ("%s0x%"PFMT64d, comma, sym->vaddr);
 								}
 								if (!r_list_empty (cls->methods)) {
 									r_cons_newline ();
 								}
 							}
 						} else if (input[1] == 'c' && obj) { // "icc"
 							mode = R_MODE_CLASSDUMP;
 							RBININFO ("classes", R_CORE_BIN_ACC_CLASSES, NULL, r_list_length (obj->classes));
 							input = " ";
 						} else {
 							RBININFO ("classes", R_CORE_BIN_ACC_CLASSES, NULL, r_list_length (obj->classes));
 						}
 					}
         			}
 			} else {
 				RBinObject *obj = r_bin_cur_object (core->bin);
 				if (obj && obj->classes) {
 					int len = r_list_length (obj->classes);
 					RBININFO ("classes", R_CORE_BIN_ACC_CLASSES, NULL, len);
 				}
 			}
 			break;
 		case 'D': // "iD"
 			if (input[1] != ' ' || !demangle (core, input + 2)) {
 				eprintf ("|Usage: iD lang symbolname\n");
 			}
 			return 0;
 		case 'a': // "ia"
 			switch (mode) {
 			case R_MODE_RADARE: cmd_info (core, "IieEcsSmz*"); break;
 			case R_MODE_JSON: cmd_info (core, "IieEcsSmzj"); break;
 			case R_MODE_SIMPLE: cmd_info (core, "IieEcsSmzq"); break;
 			default: cmd_info (core, "IiEecsSmz"); break;
 			}
 			break;
 		case '?': // "i?"
 			r_core_cmd_help (core, help_msg_i);
 			goto redone;
 		case '*': // "i*"
 			if (mode == R_MODE_RADARE) {
 				// TODO:handle ** submodes
 				mode = R_MODE_RADARE;
 			} else {
 				mode = R_MODE_RADARE;
 			}
 			goto done;
 		case 'q': // "iq"
 			mode = R_MODE_SIMPLE;
 			cmd_info_bin (core, va, mode);
 			goto done;
 		case 'j': // "ij"
 			mode = R_MODE_JSON;
 			if (is_array > 1) {
 				mode |= R_MODE_ARRAY;
 			}
 			cmd_info_bin (core, va, mode);
 			goto done;
 		default:
 			cmd_info_bin (core, va, mode);
 			break;
 		}
 		// input can be overwritten like the 'input = " ";' a few lines above
 		if (input[0] != ' ') {
 			input++;
 			if ((*input == 'j' || *input == 'q') && (input[0] && !input[1])) {
 				break;
 			}
 		} else {
 			break;
 		}
 	}
diff --git a/libr/debug/debug.c b/libr/debug/debug.c
index 5045d4eec4..9de67abfba 100644
--- a/libr/debug/debug.c
+++ b/libr/debug/debug.c
@@ -915,69 +915,69 @@ R_API int r_debug_step(RDebug *dbg, int steps) {
 R_API int r_debug_step_over(RDebug *dbg, int steps) {
 	RAnalOp op;
 	ut64 buf_pc, pc, ins_size;
 	ut8 buf[DBG_BUF_SIZE];
 	int steps_taken = 0;
 
 	if (r_debug_is_dead (dbg)) {
 		return steps_taken;
 	}
 
 	if (steps < 1) {
 		steps = 1;
 	}
 
 	if (dbg->h && dbg->h->step_over) {
 		for (; steps_taken < steps; steps_taken++) {
 			if (!dbg->h->step_over (dbg)) {
 				return steps_taken;
 			}
 		}
 		return steps_taken;
 	}
 
 	if (!dbg->anal || !dbg->reg) {
 		return steps_taken;
 	}
 
 	// Initial refill
 	buf_pc = r_debug_reg_get (dbg, dbg->reg->name[R_REG_NAME_PC]);
 	dbg->iob.read_at (dbg->iob.io, buf_pc, buf, sizeof (buf));
 
 	for (; steps_taken < steps; steps_taken++) {
 		pc = r_debug_reg_get (dbg, dbg->reg->name[R_REG_NAME_PC]);
 		// Try to keep the buffer full
 		if (pc - buf_pc > sizeof (buf)) {
 			buf_pc = pc;
 			dbg->iob.read_at (dbg->iob.io, buf_pc, buf, sizeof (buf));
 		}
 		// Analyze the opcode
 		if (!r_anal_op (dbg->anal, &op, pc, buf + (pc - buf_pc), sizeof (buf) - (pc - buf_pc), R_ANAL_OP_MASK_BASIC)) {
-			eprintf ("Decode error at %"PFMT64x"\n", pc);
+			eprintf ("debug-step-over: Decode error at %"PFMT64x"\n", pc);
 			return steps_taken;
 		}
 		if (op.fail == -1) {
 			ins_size = pc + op.size;
 		} else {
 			// Use op.fail here instead of pc+op.size to enforce anal backends to fill in this field
 			ins_size = op.fail;
 		}
 		// Skip over all the subroutine calls
 		if ((op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_CALL ||
 			(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL) {
 			if (!r_debug_continue_until (dbg, ins_size)) {
 				eprintf ("Could not step over call @ 0x%"PFMT64x"\n", pc);
 				return steps_taken;
 			}
 		} else if ((op.prefix & (R_ANAL_OP_PREFIX_REP | R_ANAL_OP_PREFIX_REPNE | R_ANAL_OP_PREFIX_LOCK))) {
 			//eprintf ("REP: skip to next instruction...\n");
 			if (!r_debug_continue_until (dbg, ins_size)) {
 				eprintf ("step over failed over rep\n");
 				return steps_taken;
 			}
 		} else {
 			r_debug_step (dbg, 1);
 		}
 	}
 
 	return steps_taken;
 }
diff --git a/libr/include/r_bin.h b/libr/include/r_bin.h
index 33efa3d9f5..d6852c2b64 100644
--- a/libr/include/r_bin.h
+++ b/libr/include/r_bin.h
@@ -297,35 +297,35 @@ typedef struct r_bin_file_options_t {
 
 typedef struct r_bin_t {
 	const char *file;
-	RBinFile *cur;
+	RBinFile *cur; // TODO: deprecate
 	int narch;
 	void *user;
 	/* preconfigured values */
 	int debase64;
 	int minstrlen;
 	int maxstrlen;
 	ut64 maxstrbuf;
 	int rawstr;
 	Sdb *sdb;
 	RIDStorage *ids;
 	RList/*<RBinPlugin>*/ *plugins;
 	RList/*<RBinXtrPlugin>*/ *binxtrs;
 	RList/*<RBinLdrPlugin>*/ *binldrs;
 	RList/*<RBinFile>*/ *binfiles;
 	PrintfCallback cb_printf;
 	int loadany;
 	RIOBind iob;
 	char *force;
 	int is_debugger;
 	bool want_dbginfo;
 	int filter; // symbol filtering
 	char strfilter; // string filtering
 	char *strpurge; // purge false positive strings
 	char *srcdir; // dir.source
 	char *prefix; // bin.prefix
 	ut64 filter_rules;
 	bool demanglercmd;
 	bool verbose;
 	bool use_xtr; // use extract plugins when loading a file?
 	bool use_ldr; // use loader plugins when loading a file?
 } RBin;
@@ -363,20 +363,22 @@ R_API void r_bin_string_free(void *_str);
 typedef struct r_bin_xtr_plugin_t {
 	char *name;
 	char *desc;
 	char *license;
 	int (*init)(void *user);
 	int (*fini)(void *user);
 	bool (*check_buffer)(RBuffer *b);
 
 	RBinXtrData * (*extract_from_bytes)(RBin *bin, const ut8 *buf, ut64 size, int idx);
+	RBinXtrData * (*extract_from_buffer)(RBin *bin, RBuffer *buf, int idx);
 	RList * (*extractall_from_bytes)(RBin *bin, const ut8 *buf, ut64 size);
+	RList * (*extractall_from_buffer)(RBin *bin, RBuffer *buf);
 	RBinXtrData * (*extract)(RBin *bin, int idx);
 	RList * (*extractall)(RBin *bin);
 
 	bool (*load)(RBin *bin);
 	int (*size)(RBin *bin);
-	int (*destroy)(RBin *bin);
-	int (*free_xtr)(void *xtr_obj);
+	void (*destroy)(RBin *bin);
+	void (*free_xtr)(void *xtr_obj);
 } RBinXtrPlugin;
 
 typedef struct r_bin_ldr_plugin_t {
@@ -396,50 +398,50 @@ typedef struct r_bin_arch_options_t {
 typedef struct r_bin_plugin_t {
 	char *name;
 	char *desc;
 	char *author;
 	char *version;
 	char *license;
 	int (*init)(void *user);
 	int (*fini)(void *user);
 	Sdb * (*get_sdb)(RBinFile *obj);
 	bool (*load)(RBinFile *arch);
 	bool (*load_bytes)(RBinFile *bf, void **bin_obj, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb);
-	void *(*load_buffer)(RBinFile *bf, RBuffer *buf, ut64 loadaddr, Sdb *sdb);
+	bool (*load_buffer)(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb);
 	ut64 (*size)(RBinFile *bin); // return ut64 maybe? meh
-	int (*destroy)(RBinFile *arch);
+	void (*destroy)(RBinFile *arch);
 	bool (*check_bytes)(const ut8 *buf, ut64 length);
 	bool (*check_buffer)(RBuffer *buf);
 	ut64 (*baddr)(RBinFile *arch);
 	ut64 (*boffset)(RBinFile *arch);
 	RBinAddr* (*binsym)(RBinFile *arch, int num);
 	RList/*<RBinAddr>*/* (*entries)(RBinFile *arch);
 	RList/*<RBinSection>*/* (*sections)(RBinFile *arch);
 	RList/*<RBinDwarfRow>*/* (*lines)(RBinFile *arch);
 	RList/*<RBinSymbol>*/* (*symbols)(RBinFile *arch);
 	RList/*<RBinImport>*/* (*imports)(RBinFile *arch);
 	RList/*<RBinString>*/* (*strings)(RBinFile *arch);
 	RBinInfo/*<RBinInfo>*/* (*info)(RBinFile *arch);
 	RList/*<RBinField>*/* (*fields)(RBinFile *arch);
 	RList/*<char *>*/* (*libs)(RBinFile *arch);
 	RList/*<RBinReloc>*/* (*relocs)(RBinFile *arch);
 	RList/*<RBinClass>*/* (*classes)(RBinFile *arch);
 	RList/*<RBinMem>*/* (*mem)(RBinFile *arch);
 	RList/*<RBinReloc>*/* (*patch_relocs)(RBin *bin);
 	RList/*<RBinMap>*/* (*maps)(RBinFile *arch);
 	void (*header)(RBinFile *arch);
 	char* (*signature)(RBinFile *arch, bool json);
 	int (*demangle_type)(const char *str);
 	struct r_bin_dbginfo_t *dbginfo;
 	struct r_bin_write_t *write;
 	int (*get_offset)(RBinFile *arch, int type, int idx);
 	char* (*get_name)(RBinFile *arch, int type, int idx);
 	ut64 (*get_vaddr)(RBinFile *arch, ut64 baddr, ut64 paddr, ut64 vaddr);
 	RBuffer* (*create)(RBin *bin, const ut8 *code, int codelen, const ut8 *data, int datalen, RBinArchOptions *opt);
 	char* (*demangle)(const char *str);
 	char* (*regstate)(RBinFile *arch);
 	int (*file_type)(RBinFile *arch);
 	/* default value if not specified by user */
 	int minstrlen;
 	char strfilter;
 	void *user;
 } RBinPlugin;
@@ -588,12 +590,12 @@ typedef struct r_bin_dbginfo_t {
 } RBinDbgInfo;
 
 typedef struct r_bin_write_t {
-	ut64 (*scn_resize)(RBinFile *arch, const char *name, ut64 size);
-	bool (*scn_perms)(RBinFile *arch, const char *name, int perms);
-	int (*rpath_del)(RBinFile *arch);
-	bool (*entry)(RBinFile *arch, ut64 addr);
-	bool (*addlib)(RBinFile *arch, const char *lib);
+	ut64 (*scn_resize)(RBinFile *bf, const char *name, ut64 size);
+	bool (*scn_perms)(RBinFile *bf, const char *name, int perms);
+	int (*rpath_del)(RBinFile *bf);
+	bool (*entry)(RBinFile *bf, ut64 addr);
+	bool (*addlib)(RBinFile *bf, const char *lib);
 } RBinWrite;
 
 // TODO: deprecate r_bin_is_big_endian
 // TODO: has_dbg_syms... maybe flags?
@@ -650,6 +652,7 @@ R_API int r_bin_list_plugin(RBin *bin, const char *name, int json);
 R_API RBinPlugin *r_bin_file_cur_plugin(RBinFile *binfile);
 R_API RBinFile *r_bin_file_find_by_object_id(RBin *bin, ut32 binobj_id);
 R_API RBinPlugin *r_bin_get_binplugin_by_bytes(RBin *bin, const ut8 *bytes, ut64 sz);
+R_API RBinPlugin *r_bin_get_binplugin_by_buffer(RBin *bin, RBuffer *buf);
 R_API void r_bin_force_plugin(RBin *bin, const char *pname);
 
 // get/set various bin information
diff --git a/libr/main/rabin2.c b/libr/main/rabin2.c
index d349150684..f6fd9a7db0 100644
--- a/libr/main/rabin2.c
+++ b/libr/main/rabin2.c
@@ -338,124 +338,129 @@ static int rabin_dump_sections(char *scnname) {
 static int rabin_do_operation(const char *op) {
 	char *arg = NULL, *ptr = NULL, *ptr2 = NULL;
 	bool rc = true;
 
 	/* Implement alloca with fixed-size buffer? */
 	if (!(arg = strdup (op))) {
 		return false;
 	}
-
 	if ((ptr = strchr (arg, '/'))) {
 		*ptr++ = 0;
 		if ((ptr2 = strchr (ptr, '/'))) {
 			ptr2[0] = '\0';
 			ptr2++;
 		}
 	}
 	if (!output) {
 		output = file;
 	}
+	RBinFile *bf = r_bin_cur (bin);
+	if (bf) {
+		RBuffer *nb = r_buf_new_with_buf (bf->buf);
+		r_buf_free (bf->buf);
+		bf->buf = nb;
+	}
 
 	switch (arg[0]) {
 	case 'e':
 		rc = r_bin_wr_entry (bin, r_num_math (NULL, ptr));
 		if (rc) {
 			rc = r_bin_wr_output (bin, output);
 		}
 		break;
 	case 'd':
 		if (!ptr) {
 			goto _rabin_do_operation_error;
 		}
 		switch (*ptr) {
 		case 's':
 			if (ptr2) {
 				if (!rabin_dump_symbols (r_num_math (NULL, ptr2))) {
 					goto error;
 				}
 			} else if (!rabin_dump_symbols (0)) {
 				goto error;
 			}
 			break;
 		case 'S':
 			if (!ptr2) {
 				goto _rabin_do_operation_error;
 			}
 			if (!rabin_dump_sections (ptr2)) {
 				goto error;
 			}
 			break;
 		default:
 			goto _rabin_do_operation_error;
 		}
 		break;
 	case 'a':
 		if (!ptr) {
 			goto _rabin_do_operation_error;
 		}
 		switch (*ptr) {
 		case 'l':
 			if (!ptr2 || !r_bin_wr_addlib (bin, ptr2)) {
 				goto error;
 			}
 			break;
 		default:
 			goto _rabin_do_operation_error;
 		}
 		break;
 	case 'R':
 		r_bin_wr_rpath_del (bin);
 		rc = r_bin_wr_output (bin, output);
 		break;
 	case 'C':
 		{
 		RBinFile *cur = r_bin_cur (bin);
 		RBinPlugin *plg = r_bin_file_cur_plugin (cur);
 		if (!plg && cur) {
 			// are we in xtr?
 			if (cur->xtr_data) {
 				// load the first one
 				RBinXtrData *xtr_data = r_list_get_n (cur->xtr_data, 0);
 				if (xtr_data && !xtr_data->loaded && !r_bin_file_object_new_from_xtr_data (bin, cur,
 					UT64_MAX, r_bin_get_laddr (bin), xtr_data)) {
 					break;
 				}
 			}
 			plg = r_bin_file_cur_plugin (cur);
 			if (!plg) {
 				break;
 			}
 		}
 		if (plg && plg->signature) {
 			char *sign = plg->signature (cur, rad == R_MODE_JSON);
 			if (sign) {
 				r_cons_println (sign);
 				r_cons_flush ();
 				free (sign);
 			}
 		}
 		}
 		break;
 	case 'r':
 		r_bin_wr_scn_resize (bin, ptr, r_num_math (NULL, ptr2));
 		rc = r_bin_wr_output (bin, output);
 		break;
 	case 'p':
 		{
 			int perms = (int)r_num_math (NULL, ptr2);
 			if (!perms) {
 				perms = r_str_rwx (ptr2);
 			}
 			r_bin_wr_scn_perms (bin, ptr, perms);
 			rc = r_bin_wr_output (bin, output);
 		}
 		break;
 	default:
 	_rabin_do_operation_error:
 		eprintf ("Unknown operation. use -O help\n");
 		goto error;
 	}
 	if (!rc) {
 		eprintf ("Cannot dump :(\n");
 	}
 	free (arg);
 	return true;
@@ -546,607 +551,606 @@ static int rabin_list_plugins(const char* plugin_name) {
 R_API int r_main_rabin2(int argc, char **argv) {
 	const char *query = NULL;
 	int c, bits = 0, actions_done = 0, actions = 0;
 	ut64 action = R_BIN_REQ_UNK;
 	char *tmp, *ptr, *arch = NULL, *arch_name = NULL;
 	const char *forcebin = NULL;
 	const char *chksum = NULL;
 	const char *op = NULL;
 	RCoreFile *fh = NULL;
 	RCoreBinFilter filter;
 	int xtr_idx = 0; // load all files if extraction is necessary.
 	int rawstr = 0;
 	int fd = -1;
 	RCore core = {0};
 
 	r_core_init (&core);
 	bin = core.bin;
 
 	if (!(tmp = r_sys_getenv ("RABIN2_NOPLUGINS"))) {
 		char *homeplugindir = r_str_home (R2_HOME_PLUGINS);
 		char *plugindir = r_str_r2_prefix (R2_PLUGINS);
 		char *extrasdir = r_str_r2_prefix (R2_EXTRAS);
 		char *bindingsdir = r_str_r2_prefix (R2_BINDINGS);
 		l = r_lib_new ("radare_plugin");
 		r_lib_add_handler (l, R_LIB_TYPE_BIN, "bin plugins",
 			&__lib_bin_cb, &__lib_bin_dt, NULL);
 		r_lib_add_handler (l, R_LIB_TYPE_BIN_XTR, "bin xtr plugins",
 			&__lib_bin_xtr_cb, &__lib_bin_xtr_dt, NULL);
 		r_lib_add_handler (l, R_LIB_TYPE_BIN_LDR, "bin ldr plugins",
 			&__lib_bin_ldr_cb, &__lib_bin_ldr_dt, NULL);
 		/* load plugins everywhere */
 		char *path = r_sys_getenv (R_LIB_ENV);
 		if (path && *path) {
 			r_lib_opendir (l, path);
 		}
 		r_lib_opendir (l, homeplugindir);
 		r_lib_opendir (l, plugindir);
 		r_lib_opendir (l, extrasdir);
 		r_lib_opendir (l, bindingsdir);
 		free (homeplugindir);
 		free (plugindir);
 		free (extrasdir);
 		free (bindingsdir);
 		free (path);
 	}
 	free (tmp);
 
 	if ((tmp = r_sys_getenv ("RABIN2_DMNGLRCMD"))) {
 		r_config_set (core.config, "bin.demanglecmd", tmp);
 		free (tmp);
 	}
 	if ((tmp = r_sys_getenv ("RABIN2_LANG"))) {
 		r_config_set (core.config, "bin.lang", tmp);
 		free (tmp);
 	}
 	if ((tmp = r_sys_getenv ("RABIN2_DEMANGLE"))) {
 		r_config_set (core.config, "bin.demangle", tmp);
 		free (tmp);
 	}
 	if ((tmp = r_sys_getenv ("RABIN2_MAXSTRBUF"))) {
 		r_config_set (core.config, "bin.maxstrbuf", tmp);
 		free (tmp);
 	}
 	if ((tmp = r_sys_getenv ("RABIN2_STRFILTER"))) {
 		r_config_set (core.config, "bin.str.filter", tmp);
 		free (tmp);
 	}
 	if ((tmp = r_sys_getenv ("RABIN2_STRPURGE"))) {
 		r_config_set (core.config, "bin.str.purge", tmp);
 		free (tmp);
 	}
 	if ((tmp = r_sys_getenv ("RABIN2_DEBASE64"))) {
 		r_config_set (core.config, "bin.debase64", tmp);
 		free (tmp);
 	}
 	if ((tmp = r_sys_getenv ("RABIN2_PDBSERVER"))) {
 		r_config_set (core.config, "pdb.server", tmp);
 		free (tmp);
 	}
 
 #define is_active(x) (action & (x))
 #define set_action(x) { actions++; action |= (x); }
 #define unset_action(x) action &= ~x
 	while ((c = r_getopt (argc, argv, "DjgAf:F:a:B:G:b:cC:k:K:dD:Mm:n:N:@:isSVIHeEUlRwO:o:pPqQrTtvLhuxXzZ")) != -1) {
 		switch (c) {
 		case 'g':
 			set_action (R_BIN_REQ_CLASSES);
 			set_action (R_BIN_REQ_IMPORTS);
 			set_action (R_BIN_REQ_SYMBOLS);
 			set_action (R_BIN_REQ_SECTIONS);
 			set_action (R_BIN_REQ_SEGMENTS);
 			set_action (R_BIN_REQ_STRINGS);
 			set_action (R_BIN_REQ_SIZE);
 			set_action (R_BIN_REQ_INFO);
 			set_action (R_BIN_REQ_FIELDS);
 			set_action (R_BIN_REQ_DWARF);
 			set_action (R_BIN_REQ_ENTRIES);
 			set_action (R_BIN_REQ_INITFINI);
 			set_action (R_BIN_REQ_MAIN);
 			set_action (R_BIN_REQ_LIBS);
 			set_action (R_BIN_REQ_RELOCS);
 			set_action (R_BIN_REQ_VERSIONINFO);
 			break;
 		case 'V': set_action (R_BIN_REQ_VERSIONINFO); break;
 		case 'T': set_action (R_BIN_REQ_SIGNATURE); break;
 		case 't': set_action (R_BIN_REQ_HASHES); break;
 		case 'q':
 			rad = (rad & R_MODE_SIMPLE ?
 				R_MODE_SIMPLEST : R_MODE_SIMPLE);
 			break;
 		case 'j': rad = R_MODE_JSON; break;
 		case 'A': set_action (R_BIN_REQ_LISTARCHS); break;
 		case 'a': arch = r_optarg; break;
 		case 'C':
 			set_action (R_BIN_REQ_CREATE);
 			create = strdup (r_optarg);
 			break;
 		case 'u': bin->filter = 0; break;
 		case 'k': query = r_optarg; break;
 		case 'K': chksum = r_optarg; break;
 		case 'c':
 			if (is_active (R_BIN_REQ_CLASSES)) {
 				rad = R_MODE_CLASSDUMP;
 			} else {
 			  	set_action (R_BIN_REQ_CLASSES);
 			}
 			break;
 		case 'f': arch_name = strdup (r_optarg); break;
 		case 'F': forcebin = r_optarg; break;
 		case 'b': bits = r_num_math (NULL, r_optarg); break;
 		case 'm':
 			at = r_num_math (NULL, r_optarg);
 			set_action (R_BIN_REQ_SRCLINE);
 			break;
 		case 'i': set_action (R_BIN_REQ_IMPORTS); break;
 		case 's': set_action (R_BIN_REQ_SYMBOLS); break;
 		case 'S':
 			if (is_active (R_BIN_REQ_SECTIONS)) {
 				action &= ~R_BIN_REQ_SECTIONS;
 				action |= R_BIN_REQ_SEGMENTS;
 			} else {
 				set_action (R_BIN_REQ_SECTIONS);
 			}
 			break;
 		case 'z':
 			if (is_active (R_BIN_REQ_STRINGS)) {
 				if (rawstr) {
 					/* rawstr mode 2 means that we are not going */
 					/* to store them just dump'm all to stdout */
 					rawstr = 2;
 				} else {
 					rawstr = 1;
 				}
 			} else {
 				set_action (R_BIN_REQ_STRINGS);
 			}
 			break;
 		case 'Z': set_action (R_BIN_REQ_SIZE); break;
 		case 'I': set_action (R_BIN_REQ_INFO); break;
 		case 'H':
 			set_action (R_BIN_REQ_FIELDS);
 			break;
 		case 'd': set_action (R_BIN_REQ_DWARF); break;
 		case 'P':
 			if (is_active (R_BIN_REQ_PDB)) {
 				set_action (R_BIN_REQ_PDB_DWNLD);
 			} else {
 				set_action (R_BIN_REQ_PDB);
 			}
 			break;
 		case 'D':
 			if (argv[r_optind] && argv[r_optind+1] && \
 				(!argv[r_optind+1][0] || !strcmp (argv[r_optind+1], "all"))) {
 				r_config_set (core.config, "bin.lang", argv[r_optind]);
 				r_config_set (core.config, "bin.demangle", "true");
 				r_optind += 2;
 			} else {
 				do_demangle = argv[r_optind];
 			}
 			break;
 		case 'e':
 			if (action & R_BIN_REQ_ENTRIES) {
 				action &= ~R_BIN_REQ_ENTRIES;
 				action |= R_BIN_REQ_INITFINI;
 			} else {
 				set_action (R_BIN_REQ_ENTRIES);
 			}
 			break;
 		case 'E': set_action (R_BIN_REQ_EXPORTS); break;
 		case 'U': set_action (R_BIN_REQ_RESOURCES); break;
 		case 'Q': set_action (R_BIN_REQ_DLOPEN); break;
 		case 'M': set_action (R_BIN_REQ_MAIN); break;
 		case 'l': set_action (R_BIN_REQ_LIBS); break;
 		case 'R': set_action (R_BIN_REQ_RELOCS); break;
 		case 'x': set_action (R_BIN_REQ_EXTRACT); break;
 		case 'X': set_action (R_BIN_REQ_PACKAGE); break;
 		case 'w': rw = true; break;
 		case 'O':
 			op = r_optarg;
 			set_action (R_BIN_REQ_OPERATION);
 			r_sys_setenv ("RABIN2_CODESIGN_VERBOSE", "1");
 			if (isBinopHelp (op)) {
 				printf ("Usage: iO [expression]:\n"
 					" e/0x8048000       change entrypoint\n"
 					" d/s/1024          dump symbols\n"
 					" d/S/.text         dump section\n"
 					" r/.data/1024      resize section\n"
 					" R                 remove RPATH\n"
 					" a/l/libfoo.dylib  add library\n"
 					" p/.data/rwx       change section permissions\n"
 					" C                 show LDID entitlements\n");
 				r_core_fini (&core);
 				return 0;
 			}
 			if (r_optind == argc) {
 				eprintf ("Missing filename\n");
 				r_core_fini (&core);
 				return 1;
 			}
 			break;
 		case 'o': output = r_optarg; break;
 		case 'p': va = false; break;
 		case 'r': rad = true; break;
 		case 'v': 
 			  r_core_fini (&core);
 			  return r_main_version_print ("rabin2");
 		case 'L':
 			set_action (R_BIN_REQ_LISTPLUGINS);
 			break;
 		case 'G':
 			laddr = r_num_math (NULL, r_optarg);
 			if (laddr == UT64_MAX) {
 				va = false;
 			}
 			break;
 		case 'B':
 			baddr = r_num_math (NULL, r_optarg);
 			break;
 		case '@':
 			at = r_num_math (NULL, r_optarg);
 			break;
 		case 'n':
 			name = r_optarg;
 			break;
 		case 'N':
 			tmp = strchr (r_optarg, ':');
 			r_config_set (core.config, "bin.minstr", r_optarg);
 			if (tmp) {
 				r_config_set (core.config, "bin.maxstr", tmp + 1);
 			}
 			break;
 		case 'h':
 			r_core_fini (&core);
 			return rabin_show_help (1);
 		default:
 			action |= R_BIN_REQ_HELP;
 			break;
 		}
 	}
 
 	if (is_active (R_BIN_REQ_LISTPLUGINS)) {
 		const char* plugin_name = NULL;
 		if (r_optind < argc) {
 			plugin_name = argv[r_optind];
 		}
 		rabin_list_plugins (plugin_name);
 		r_core_fini (&core);
 		return 0;
 	}
 
 	if (do_demangle) {
 		char *res = NULL;
 		int type;
 		if ((argc - r_optind) < 2) {
 			r_core_fini (&core);
 			return rabin_show_help (0);
 		}
 		type = r_bin_demangle_type (do_demangle);
 		file = argv[r_optind + 1];
 		if (!strcmp (file, "-")) {
 			for (;;) {
 				file = stdin_gets();
 				if (!file || !*file) {
 					break;
 				}
 				res = demangleAs (type);
 				if (!res) {
 					eprintf ("Unknown lang to demangle. Use: cxx, java, objc, swift\n");
 					r_core_fini (&core);
 					return 1;
 				}
 				if (res && *res) {
 					printf ("%s\n", res);
 				} else if (file && *file) {
 					printf ("%s\n", file);
 				}
 				R_FREE (res);
 				R_FREE (file);
 			}
 		} else {
 			res = demangleAs (type);
 			if (res && *res) {
 				printf ("%s\n", res);
 				free(res);
 				r_core_fini (&core);
 				return 0;
 			} else {
 				printf ("%s\n", file);
 			}
 		}
 		free (res);
 		//eprintf ("%s\n", file);
 		r_core_fini (&core);
 		return 1;
 	}
 	file = argv[r_optind];
 	if (!query) {
 		if (action & R_BIN_REQ_HELP || action == R_BIN_REQ_UNK || !file) {
 			r_core_fini (&core);
 			return rabin_show_help (0);
 		}
 	}
 	if (arch) {
 		ptr = strchr (arch, '_');
 		if (ptr) {
 			*ptr = '\0';
 			bits = r_num_math (NULL, ptr+1);
 		}
 	}
 	if (action & R_BIN_REQ_CREATE) {
 		// TODO: move in a function outside
 		RBuffer *b;
 		int datalen, codelen;
 		ut8 *data = NULL, *code = NULL;
 		char *p2, *p = strchr (create, ':');
 		if (!p) {
 			eprintf ("Invalid format for -C flag. Use 'format:codehexpair:datahexpair'\n");
 			r_core_fini (&core);
 			return 1;
 		}
 		*p++ = 0;
 		p2 = strchr (p, ':');
 		if (p2) {
 			// has data
 			*p2++ = 0;
 			data = malloc (strlen (p2)+1);
 			datalen = r_hex_str2bin (p2, data);
 			if (datalen < 0) {
 				datalen = -datalen;
 			}
 		} else {
 			data = NULL;
 			datalen = 0;
 		}
 		code = malloc (strlen (p) + 1);
 		if (!code) {
 			r_core_fini (&core);
 			return 1;
 		}
 		codelen = r_hex_str2bin (p, code);
 		RBinArchOptions opts;
 		r_bin_arch_options_init (&opts, arch, bits);
 		b = r_bin_create (bin, create, code, codelen, data, datalen, &opts);
 		if (b) {
 			ut64 tmpsz;
 			const ut8 *tmp = r_buf_data (b, &tmpsz);
 			if (r_file_dump (file, tmp, tmpsz, 0)) {
 				eprintf ("Dumped %" PFMT64d " bytes in '%s'\n",
 					tmpsz, file);
 				r_file_chmod (file, "+x", 0);
 			} else {
 				eprintf ("Error dumping into a.out\n");
 			}
 			r_buf_free (b);
 		} else {
 			eprintf ("Cannot create binary for this format '%s'.\n", create);
 		}
 		r_core_fini (&core);
 		return 0;
 	}
 	if (rawstr == 2) {
 		unset_action (R_BIN_REQ_STRINGS);
 	}
 	r_config_set_i (core.config, "bin.rawstr", rawstr);
 
 	if (!file) {
 		eprintf ("Missing file.\n");
 		r_core_fini (&core);
 		return 1;
 	}
 
 	if (file && *file && action & R_BIN_REQ_DLOPEN) {
 #if __UNIX__
 		int child = r_sys_fork ();
 		if (child == -1) {
 			r_core_fini (&core);
 			return 1;
 		}
 		if (child == 0) {
 			return waitpid (child, NULL, 0);
 		}
 #endif
 		void *addr = r_lib_dl_open (file);
 		if (addr) {
 			eprintf ("%s is loaded at 0x%"PFMT64x"\n", file, (ut64)(size_t)(addr));
 			r_lib_dl_close (addr);
 			r_core_fini (&core);
 			return 0;
 		}
 		eprintf ("Cannot open the '%s' library\n", file);
 		r_core_fini (&core);
 		return 0;
 	}
 	if (action & R_BIN_REQ_PACKAGE) {
 		RList *files = r_list_newf (NULL);
 		const char *format = argv[r_optind];
 		const char *file = argv[r_optind + 1];
 		int i, rc = 0;
 
 		if (r_optind + 3 > argc) {
 			eprintf ("Usage: rabin2 -X [fat|zip] foo.zip a b c\n");
 			r_core_fini (&core);
 			return 1;
 		}
 		eprintf ("FMT %s\n", format);
 		eprintf ("PKG %s\n", file);
 		for (i = r_optind + 2; i < argc; i++) {
 			eprintf ("ADD %s\n", argv[i]);
 			r_list_append (files, argv[i]);
 		}
 		RBuffer *buf = r_bin_package (core.bin, format, file, files);
 		/* TODO: return bool or something to catch errors\n") */
 		if (buf) {
 			bool ret = r_buf_dump (buf, file);
 			r_buf_free (buf);
 			if (!ret) {
 				rc = 1;
 			}
 		}
 		r_core_fini (&core);
 		return rc;
 	}
 
 	if (file && *file) {
 		if ((fh = r_core_file_open (&core, file, R_PERM_R, 0))) {
 			fd = r_io_fd_get_current (core.io);
 			if (fd == -1) {
 				eprintf ("r_core: Cannot open file '%s'\n", file);
 				r_core_file_free (fh);
 				r_core_fini (&core);
 				return 1;
 			}
 		} else {
 			eprintf ("r_core: Cannot open file '%s'\n", file);
 			r_core_fini (&core);
 			return 1;
 		}
 	}
 	bin->minstrlen = r_config_get_i (core.config, "bin.minstr");
 	bin->maxstrbuf = r_config_get_i (core.config, "bin.maxstrbuf");
 
 	r_bin_force_plugin (bin, forcebin);
 	r_bin_load_filter (bin, action);
 
 	RBinOptions opt;
 	r_bin_options_init (&opt, fd, baddr, laddr, rawstr);
 	opt.xtr_idx = xtr_idx;
 
 	if (!r_bin_open (bin, file, &opt)) {
 		//if this return false means that we did not return a valid bin object
 		//but we have yet the chance that this file is a fat binary
 		if (!bin->cur || !bin->cur->xtr_data) {
 			eprintf ("r_bin: Cannot open file\n");
 			r_core_file_free (fh);
 			r_core_fini (&core);
 			return 1;
 		}
 	}
 	/* required to automatically select a sub-bin when not specified */
 	(void)r_core_bin_update_arch_bits (&core);
 
 	if (baddr != UT64_MAX) {
 		r_bin_set_baddr (bin, baddr);
 	}
 	if (rawstr == 2) {
 		RBinFile *bf = r_core_bin_cur (&core);
 		if (bf) {
 			bf->strmode = rad;
 			r_bin_dump_strings (bf, bin->minstrlen, bf->rawstr);
 		}
 	}
 	if (query) {
 		if (rad) {
 			r_core_bin_export_info_rad (&core);
 			r_cons_flush ();
 		} else {
 			if (!strcmp (query, "-")) {
 				__sdb_prompt (bin->cur->sdb);
 			} else {
 				sdb_query (bin->cur->sdb, query);
 			}
 		}
 		r_core_file_free (fh);
 		r_core_fini (&core);
 		return 0;
 	}
 #define isradjson (rad==R_MODE_JSON&&actions>0)
 #define run_action(n,x,y) {\
 	if (action&(x)) {\
 		if (isradjson) r_cons_printf ("%s\"%s\":",actions_done?",":"",n);\
 		if (!r_core_bin_info (&core, y, rad, va, &filter, chksum)) {\
 			if (isradjson) r_cons_print ("false");\
 		};\
 		actions_done++;\
 	}\
 }
 	core.bin = bin;
 	bin->cb_printf = r_cons_printf;
 	filter.offset = at;
 	filter.name = name;
 	r_cons_new ()->context->is_interactive = false;
 
 	if (isradjson) {
 		r_cons_print ("{");
 	}
 	// List fatmach0 sub-binaries, etc
 	if (action & R_BIN_REQ_LISTARCHS || ((arch || bits || arch_name) &&
 		!r_bin_select (bin, arch, bits, arch_name))) {
 		if (rad == R_MODE_SIMPLEST || rad == R_MODE_SIMPLE) {
 			r_bin_list_archs (bin, 'q');
 		} else {
 			r_bin_list_archs (bin, (rad == R_MODE_JSON)? 'j': 1);
 		}
 		actions_done++;
 		free (arch_name);
 	}
 	if (action & R_BIN_REQ_PDB_DWNLD) {
 		SPDBOptions pdbopts;
 		pdbopts.user_agent = (char*) r_config_get (core.config, "pdb.useragent");
 		pdbopts.symbol_server = (char*) r_config_get (core.config, "pdb.server");
 		pdbopts.extract = r_config_get_i (core.config, "pdb.extract");
 
 		if ((tmp = r_sys_getenv ("RABIN2_SYMSTORE"))) {
 			r_config_set (core.config, "pdb.symstore", tmp);
 			R_FREE (tmp);
 		}
 		pdbopts.symbol_store_path = (char *)r_config_get (core.config, "pdb.symstore");
 		int r = r_bin_pdb_download (&core, isradjson, &actions_done, &pdbopts);
 		r_core_file_free (fh);
 		r_core_fini (&core);
 		return r;
 	}
 
 	if ((tmp = r_sys_getenv ("RABIN2_PREFIX"))) {
 		r_config_set (core.config, "bin.prefix", tmp);
 		free (tmp);
 	}
 
 	run_action ("sections", R_BIN_REQ_SECTIONS, R_CORE_BIN_ACC_SECTIONS);
 	run_action ("segments", R_BIN_REQ_SEGMENTS, R_CORE_BIN_ACC_SEGMENTS);
 	run_action ("entries", R_BIN_REQ_ENTRIES, R_CORE_BIN_ACC_ENTRIES);
 	run_action ("initfini", R_BIN_REQ_INITFINI, R_CORE_BIN_ACC_INITFINI);
 	run_action ("main", R_BIN_REQ_MAIN, R_CORE_BIN_ACC_MAIN);
 	run_action ("imports", R_BIN_REQ_IMPORTS, R_CORE_BIN_ACC_IMPORTS);
 	run_action ("classes", R_BIN_REQ_CLASSES, R_CORE_BIN_ACC_CLASSES);
 	run_action ("symbols", R_BIN_REQ_SYMBOLS, R_CORE_BIN_ACC_SYMBOLS);
 	run_action ("exports", R_BIN_REQ_EXPORTS, R_CORE_BIN_ACC_EXPORTS);
 	run_action ("resources", R_BIN_REQ_RESOURCES, R_CORE_BIN_ACC_RESOURCES);
 	run_action ("strings", R_BIN_REQ_STRINGS, R_CORE_BIN_ACC_STRINGS);
 	run_action ("info", R_BIN_REQ_INFO, R_CORE_BIN_ACC_INFO);
 	run_action ("fields", R_BIN_REQ_FIELDS, R_CORE_BIN_ACC_FIELDS);
 	run_action ("header", R_BIN_REQ_HEADER, R_CORE_BIN_ACC_HEADER);
 	run_action ("libs", R_BIN_REQ_LIBS, R_CORE_BIN_ACC_LIBS);
 	run_action ("relocs", R_BIN_REQ_RELOCS, R_CORE_BIN_ACC_RELOCS);
 	run_action ("dwarf", R_BIN_REQ_DWARF, R_CORE_BIN_ACC_DWARF);
 	run_action ("pdb", R_BIN_REQ_PDB, R_CORE_BIN_ACC_PDB);
 	run_action ("size", R_BIN_REQ_SIZE, R_CORE_BIN_ACC_SIZE);
 	run_action ("versioninfo", R_BIN_REQ_VERSIONINFO, R_CORE_BIN_ACC_VERSIONINFO);
 	run_action ("sections", R_BIN_REQ_SIGNATURE, R_CORE_BIN_ACC_SIGNATURE);
 	run_action ("hashes", R_BIN_REQ_HASHES, R_CORE_BIN_ACC_HASHES);
 	if (action & R_BIN_REQ_SRCLINE) {
 		rabin_show_srcline (at);
 	}
 	if (action & R_BIN_REQ_EXTRACT) {
 		RBinFile *bf = r_bin_cur (bin);
 		if (bf && bf->xtr_data) {
 			rabin_extract ((!arch && !arch_name && !bits));
 		} else {
 			eprintf (
 				"Cannot extract bins from '%s'. No supported "
-				"plugins found!\n",
-				bin->file);
+				"plugins found!\n", bin->file);
 		}
 	}
 	if (op && action & R_BIN_REQ_OPERATION) {
 		rabin_do_operation (op);
 	}
 	if (isradjson) {
 		r_cons_print ("}");
 	}
 	r_cons_flush ();
 	r_core_file_free (fh);
 	r_core_fini (&core);
 	free (stdin_buf);
 
 	return 0;
 }
