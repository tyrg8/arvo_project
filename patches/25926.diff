commit 4f6c1db9a2ae47cfe488e7443ce54b7e2a815261
Merge: 270da3c33 1c492dc0b
Author: Sean Parkinson <sean@wolfssl.com>
Date:   Thu Oct 8 09:52:56 2020 +1000

    Merge pull request #3355 from douzzer/enable-more-all
    
    --enable-all coverage update, plus --enable-all-crypto and --enable-linuxkm-defaults

diff --git a/configure.ac b/configure.ac
index 6c7c01025..941fb24b3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -148,6 +148,17 @@ AC_ARG_ENABLE([linuxkm],
     [ENABLED_LINUXKM=no]
     )
 
+AC_ARG_ENABLE([linuxkm-defaults],
+    [AS_HELP_STRING([--enable-linuxkm-defaults],[Enable feature defaults for Linux Kernel Module (default: disabled)])],
+    [ENABLED_LINUXKM_DEFAULTS=$enableval],
+    [ENABLED_LINUXKM_DEFAULTS=$ENABLED_LINUXKM]
+    )
+
+if test "$ENABLED_LINUXKM_DEFAULTS" = "yes"
+then
+    AM_CFLAGS="$AM_CFLAGS -DWOLFSSL_DH_CONST -DWOLFSSL_SP_MOD_WORD_RP -DWOLFSSL_OLD_PRIME_CHECK -DWOLFSSL_SP_DIV_64 -DWOLFSSL_SP_DIV_WORD_HALF -DSP_HALF_SIZE=32 -DSP_HALF_MAX=4294967295U"
+fi
+
 AC_ARG_WITH([linux-source],
     [AS_HELP_STRING([--with-linux-source=PATH],[PATH to root of Linux kernel build tree])],
     [KERNEL_ROOT=$withval],
@@ -185,7 +196,35 @@ then
     AM_CFLAGS="$AM_CFLAGS -DNO_DEV_RANDOM -DNO_WRITEV -DNO_STDIO_FILESYSTEM -DWOLFSSL_NO_SOCK -DWOLFSSL_USER_IO"
 fi
 
 
+# Single Precision maths implementation
+if test "$ENABLED_LINUXKM_DEFAULTS" = "yes"
+then
+    ENABLED_SP_DEFAULT=small
+else
+    ENABLED_SP_DEFAULT=no
+fi
+AC_ARG_ENABLE([sp],
+    [AS_HELP_STRING([--enable-sp],[Enable Single Precision maths implementation (default: disabled)])],
+    [ ENABLED_SP=$enableval ],
+    [ ENABLED_SP=$ENABLED_SP_DEFAULT ],
+    )
+
+
+# Single Precision maths exclusively (no fastmath)
+if test "$ENABLED_LINUXKM_DEFAULTS" = "yes" && test "$ENABLED_SP" != "no"
+then
+    ENABLED_SP_MATH_DEFAULT=yes
+else
+    ENABLED_SP_MATH_DEFAULT=no
+fi
+AC_ARG_ENABLE([sp-math],
+    [AS_HELP_STRING([--enable-sp-math],[Enable Single Precision math implementation only (default: disabled)])],
+    [ ENABLED_SP_MATH=$enableval ],
+    [ ENABLED_SP_MATH=$ENABLED_SP_MATH_DEFAULT ],
+    )
+
+
 # ALL FEATURES
 AC_ARG_ENABLE([all],
     [AS_HELP_STRING([--enable-all],[Enable all wolfSSL features, except SSLv3 (default: disabled)])],
@@ -196,97 +235,237 @@ if test "$ENABLED_ALL" = "yes"
 then
     enable_dtls=yes
     if test "x$FIPS_VERSION" != "xv1"
     then
         enable_tls13=yes
         enable_rsapss=yes
     fi
     enable_openssh=yes
     enable_opensslextra=yes
     enable_opensslall=yes
     enable_savesession=yes
     enable_savecert=yes
     enable_atomicuser=yes
     enable_pkcallbacks=yes
     enable_aesgcm=yes
     enable_aesccm=yes
     enable_aesctr=yes
     enable_aesofb=yes
     enable_aescfb=yes
     enable_camellia=yes
     enable_ripemd=yes
     enable_sha512=yes
     enable_sha224=yes
     enable_sha3=yes
     enable_sessioncerts=yes
     enable_keygen=yes
     enable_certgen=yes
     enable_certreq=yes
     enable_certext=yes
     enable_sep=yes
     enable_hkdf=yes
     enable_dsa=yes
     enable_ecccustcurves=yes
     enable_compkey=yes
     enable_curve25519=yes
     enable_curve448=yes
     enable_ed448=yes
     enable_ed25519=yes
     enable_fpecc=yes
     enable_eccencrypt=yes
     enable_psk=yes
     enable_idea=yes
     enable_cmac=yes
     enable_xts=yes
     enable_webserver=yes
     enable_hc128=yes
     enable_rabbit=yes
     enable_ocsp=yes
     enable_ocspstapling=yes
     enable_ocspstapling2=yes
     enable_crl=yes
     enable_crl_monitor=yes
     enable_sni=yes
     enable_maxfragment=yes
     enable_alpn=yes
     enable_truncatedhmac=yes
     enable_trusted_ca=yes
     enable_supportedcurves=yes
     enable_session_ticket=yes
     enable_tlsx=yes
     enable_pkcs7=yes
     enable_ssh=yes
     enable_scep=yes
     enable_srp=yes
     enable_certservice=yes
     enable_jni=yes
     enable_lighty=yes
     enable_haproxy=yes
     enable_stunnel=yes
     enable_nginx=yes
     enable_openvpn=yes
     enable_asio=yes
     enable_libwebsockets=yes
     enable_qt=yes
     enable_pwdbased=yes
     enable_aeskeywrap=yes
     enable_x963kdf=yes
     enable_scrypt=yes
     enable_indef=yes
     enable_enckeys=yes
     enable_hashflags=yes
-    enable_dhdefaultparams=yes
+    enable_defaultdhparams=yes
+    enable_arc4=yes
+    enable_des3=yes
+    enable_nullcipher=yes
+    enable_blake2=yes
+    enable_blake2s=yes
+    enable_md4=yes
+    enable_postauth=yes
+    enable_hrrcookie=yes
+    enable_cryptocb=yes
+    enable_fallback_scsv=yes
+    enable_anon=yes
+    enable_mcast=yes
+
+    # Enable DH const table speedups (eliminates `-lm` math lib dependency)
+    AM_CFLAGS="$AM_CFLAGS -DHAVE_FFDHE_2048 -DHAVE_FFDHE_3072 -DFP_MAX_BITS=8192"
+
+    # Enable multiple attribute additions such as DC
+    AM_CFLAGS="-DWOLFSSL_MULTI_ATTRIB $AM_CFLAGS"
 
     # Enable AES Decrypt, AES ECB, Alt Names, DER Load, Keep Certs, CRL IO with Timeout
-    AM_CFLAGS="$AM_CFLAGS -DHAVE_AES_DECRYPT -DHAVE_AES_ECB -DWOLFSSL_ALT_NAMES -DWOLFSSL_DER_LOAD -DKEEP_OUR_CERT -DKEEP_PEER_CERT -DHAVE_CRL_IO -DHAVE_IO_TIMEOUT"
+    AM_CFLAGS="$AM_CFLAGS -DHAVE_AES_DECRYPT -DHAVE_AES_ECB -DWOLFSSL_ALT_NAMES -DWOLFSSL_DER_LOAD -DKEEP_OUR_CERT -DKEEP_PEER_CERT"
+
+    # Enable ECC Key Gen checks
+    AM_CFLAGS="$AM_CFLAGS -DWOLFSSL_VALIDATE_ECC_KEYGEN"
+
+    if test "$ENABLED_LINUXKM_DEFAULTS" != "yes"
+    then
+        AM_CFLAGS="$AM_CFLAGS -DHAVE_CRL_IO -DHAVE_IO_TIMEOUT"
+    fi
+
+    if test "$ENABLED_SP_MATH" = "no"
+    then
+        # Enable ECC Import checks
+        AM_CFLAGS="$AM_CFLAGS -DWOLFSSL_VALIDATE_ECC_IMPORT"
+    else
+        # sp-math is incompatible with opensslextra, ECC custom curves, and DSA:
+
+        enable_openssh=no
+        enable_opensslextra=no
+        enable_opensslall=no
+        enable_dsa=no
+        enable_ecccustcurves=no
+        enable_srp=no
+        enable_certservice=no
+        enable_jni=no
+        enable_lighty=no
+        enable_haproxy=no
+        enable_stunnel=no
+        enable_nginx=no
+        enable_apachehttpd=no
+        enable_openvpn=no
+        enable_asio=no
+        enable_libwebsockets=no
+        enable_qt=no
+    fi
+
+    if test "$ENABLED_LINUXKM_DEFAULTS" = "yes"
+    then
+        enable_compkey=no
+    fi
+fi
+
+
+# ALL CRYPTO FEATURES
+AC_ARG_ENABLE([all-crypto],
+    [AS_HELP_STRING([--enable-all-crypto],[Enable all wolfcrypt algorithms (default: disabled)])],
+    [ ENABLED_ALL_CRYPT=$enableval ],
+    [ ENABLED_ALL_CRYPT=no ]
+    )
+if test "$ENABLED_ALL_CRYPT" = "yes"
+then
+    enable_atomicuser=yes
+    enable_pkcallbacks=yes
+    enable_aesgcm=yes
+    enable_aesccm=yes
+    enable_aesctr=yes
+    enable_aesofb=yes
+    enable_aescfb=yes
+    enable_camellia=yes
+    enable_ripemd=yes
+    enable_sha512=yes
+    enable_sha224=yes
+    enable_sha3=yes
+    enable_sessioncerts=yes
+    enable_keygen=yes
+    enable_certgen=yes
+    enable_certreq=yes
+    enable_certext=yes
+    enable_sep=yes
+    enable_hkdf=yes
+    enable_curve25519=yes
+    enable_curve448=yes
+    enable_ed448=yes
+    enable_ed25519=yes
+    enable_fpecc=yes
+    enable_eccencrypt=yes
+    enable_psk=yes
+    enable_idea=yes
+    enable_cmac=yes
+    enable_xts=yes
+    enable_hc128=yes
+    enable_rabbit=yes
+    enable_xchacha=yes
+    enable_ocsp=yes
+    enable_ocspstapling=yes
+    enable_ocspstapling2=yes
+    enable_crl=yes
+    enable_supportedcurves=yes
+    enable_tlsx=yes
+    enable_pkcs7=yes
+    enable_pwdbased=yes
+    enable_aeskeywrap=yes
+    enable_x963kdf=yes
+    enable_scrypt=yes
+    enable_indef=yes
+    enable_enckeys=yes
+    enable_hashflags=yes
+    enable_defaultdhparams=yes
+    enable_arc4=yes
+    enable_des3=yes
+    enable_nullcipher=yes
+    enable_blake2=yes
+    enable_blake2s=yes
+    enable_md4=yes
+    enable_cryptocb=yes
+    enable_anon=yes
+
+    if test "$ENABLED_LINUXKM_DEFAULTS" != "yes"
+    then
+        enable_compkey=yes
+    fi
+
+    # Enable AES Decrypt, AES ECB, Alt Names, DER Load
+    AM_CFLAGS="$AM_CFLAGS -DHAVE_AES_DECRYPT -DHAVE_AES_ECB -DWOLFSSL_ALT_NAMES -DWOLFSSL_DER_LOAD"
 
     # Enable DH const table speedups (eliminates `-lm` math lib dependency)
     AM_CFLAGS="$AM_CFLAGS -DHAVE_FFDHE_2048 -DHAVE_FFDHE_3072 -DFP_MAX_BITS=8192"
 
-    # Enable ECC Key Gen / Import checks
-    AM_CFLAGS="$AM_CFLAGS -DWOLFSSL_VALIDATE_ECC_IMPORT -DWOLFSSL_VALIDATE_ECC_KEYGEN"
-
     # Enable multiple attribute additions such as DC
     AM_CFLAGS="-DWOLFSSL_MULTI_ATTRIB $AM_CFLAGS"
+
+    # Enable ECC Key Gen checks
+    AM_CFLAGS="$AM_CFLAGS -DWOLFSSL_VALIDATE_ECC_KEYGEN"
+
+    if test "$ENABLED_SP_MATH" = "no"
+    then
+        enable_dsa=yes
+        enable_ecccustcurves=yes
+
+        # Enable ECC Import checks
+        AM_CFLAGS="$AM_CFLAGS -DWOLFSSL_VALIDATE_ECC_IMPORT"
+    fi
 fi
 
 
@@ -3415,7 +3594,7 @@ fi
 
 
 # Small Stack - Cache on object
-if test "$ENABLED_LINUXKM" = "yes"
+if test "$ENABLED_LINUXKM_DEFAULTS" = "yes"
 then
     ENABLED_SMALL_STACK_CACHE_DEFAULT=yes
 else
@@ -3433,7 +3612,7 @@ then
 fi
 
 # Small Stack
-if test "$ENABLED_LINUXKM" = "yes"
+if test "$ENABLED_LINUXKM_DEFAULTS" = "yes"
 then
     ENABLED_SMALL_STACK_DEFAULT=yes
 else
@@ -4073,7 +4252,7 @@ if test "$host_cpu" = "x86_64" || test "$host_cpu" = "aarch64"
 then
     FASTMATH_DEFAULT=yes
 fi
-if test "$ENABLED_LINUXKM" = "yes"
+if test "$ENABLED_LINUXKM_DEFAULTS" = "yes"
 then
     FASTMATH_DEFAULT=no
 fi
@@ -4359,55 +4538,42 @@ AS_IF([test "x$ENABLED_INTEL_QA" = "xyes" && test "x$ENABLED_INTEL_QA_SYNC" = "x
 AS_IF([test "x$ENABLED_INTEL_QA" = "xyes" || test "x$ENABLED_INTEL_QA_SYNC" = "xyes"],
     [AC_MSG_CHECKING([for intelqa])
      AS_IF([test "x$ENABLED_INTEL_QA" = "xyes"],
            [AM_CPPFLAGS="$AM_CPPFLAGS -DHAVE_INTEL_QA -DDO_CRYPTO -DUSER_SPACE"; intelqa_opt=""],
            [AM_CPPFLAGS="$AM_CPPFLAGS -DHAVE_INTEL_QA_SYNC -DQAT_USE_POLLING_THREAD -DO_CRYPTO -DUSER_SPACE"; intelqa_opt="-sync"])
      OLD_LIBS="$LIBS"
      OLD_CPPFLAGS="$CPPFLAGS"
 
      AS_IF([test "x$QAT_DIR" = "xyes"],[AC_MSG_ERROR([need a PATH for --with-intelqa$intelqa_opt])])
 
      AM_CPPFLAGS="$AM_CPPFLAGS -I$QAT_DIR/quickassist/include -I$QAT_DIR/quickassist/include/lac -I$QAT_DIR/quickassist/utilities/osal/include \
          -I$QAT_DIR/quickassist/utilities/osal/src/linux/user_space/include -I$QAT_DIR/quickassist/lookaside/access_layer/include \
          -I$QAT_DIR/quickassist/lookaside/access_layer/src/common/include -I$srcdir/wolfssl -I$srcdir/wolfssl/wolfcrypt/port/intel \
          -I$QAT_DIR/quickassist/utilities/libusdm_drv"
      CPPFLAGS="$AM_CPPFLAGS"
 
      LDFLAGS="$LDFLAGS -L$QAT_DIR/build"
      LIBS="$LIBS -lqat_s -lusdm_drv_s"
 
      AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include "cpa_cy_common.h"]],[[Cpa16U count = 0; cpaCyGetNumInstances(&count);]])],[intelqa_linked=yes],[intelqa_linked=no])
 
      AS_IF([test "x$intelqa_linked" = "xno"],
            [# Try old QAT driver libraries
             LIBS="$OLD_LIBS -licp_qa_al_s"
             AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include "cpa_cy_common.h"]],[[Cpa16U count = 0; cpaCyGetNumInstances(&count);]])],[intelqa_linked=yes],[intelqa_linked=no])
             AS_IF([test "x$intelqa_linked" = "xno"],
                 [AC_MSG_ERROR([Intel QuickAssist not found. If it's already installed, specify its path using --with-intelqa$intelqa_opt=/dir/])],
                 [BUILD_INTEL_QAT_VERSION=1])
            ])
 
      AC_MSG_RESULT([yes])
 
      AS_IF([test "x$BUILD_INTEL_QAT_VERSION" = "x1"],
         [LIB_ADD="-ladf_proxy -losal -lrt $LIB_ADD"],
         [LIB_ADD="-losal -lrt $LIB_ADD"])
      CPPFLAGS="$OLD_CPPFLAGS"
 ])
 
 
-# Single Precision maths implementation
-if test "$ENABLED_LINUXKM" = "yes"
-then
-    ENABLED_SP_DEFAULT=small
-else
-    ENABLED_SP_DEFAULT=no
-fi
-AC_ARG_ENABLE([sp],
-    [AS_HELP_STRING([--enable-sp],[Enable Single Precision maths implementation (default: disabled)])],
-    [ ENABLED_SP=$enableval ],
-    [ ENABLED_SP=$ENABLED_SP_DEFAULT ],
-    )
-
 ENABLED_SP_RSA=no
 ENABLED_SP_DH=no
 ENABLED_SP_FF_2048=no
@@ -4654,17 +4820,6 @@ if test "$ENABLED_SP_ASM" = "yes"; then
   esac
 fi
 
-if test "$ENABLED_LINUXKM" = "yes" && test "$ENABLED_SP" != "no"
-then
-    ENABLED_SP_MATH_DEFAULT=yes
-else
-    ENABLED_SP_MATH_DEFAULT=no
-fi
-AC_ARG_ENABLE([sp-math],
-    [AS_HELP_STRING([--enable-sp-math],[Enable Single Precision math implementation only (default: disabled)])],
-    [ ENABLED_SP_MATH=$enableval ],
-    [ ENABLED_SP_MATH=$ENABLED_SP_MATH_DEFAULT ],
-    )
 if test "$ENABLED_SP_MATH" = "yes"; then
     if test "$ENABLED_SP" = "no"; then
         AC_MSG_ERROR([Must have SP enabled: --enable-sp])
@@ -5373,71 +5528,71 @@ esac
 if test "x$ENABLED_LINUXKM" = "xyes"; then
     AX_SIMD_CC_COMPILER_FLAGS
     AC_SUBST([CFLAGS_FPU_DISABLE])
     AC_SUBST([CFLAGS_FPU_ENABLE])
     AC_SUBST([CFLAGS_SIMD_DISABLE])
     AC_SUBST([CFLAGS_SIMD_ENABLE])
     AC_SUBST([CFLAGS_AUTO_VECTORIZE_DISABLE])
     AC_SUBST([CFLAGS_AUTO_VECTORIZE_ENABLE])
     AC_SUBST([ASFLAGS_FPU_DISABLE_SIMD_ENABLE])
     AC_SUBST([ASFLAGS_FPU_ENABLE_SIMD_DISABLE])
     AC_SUBST([ASFLAGS_FPUSIMD_DISABLE])
     AC_SUBST([ASFLAGS_FPUSIMD_ENABLE])
 
     if test "$ENABLED_FILESYSTEM" = "yes"; then
         AC_MSG_ERROR([--enable-filesystem is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_AFALG" = "yes"; then
         AC_MSG_ERROR([--enable-afalg is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_DEVCRYPTO" = "yes"; then
         AC_MSG_ERROR([--enable-devcrypto is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_PKCS11" = "yes"; then
         AC_MSG_ERROR([--enable-pkcs11 is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_JNI" = "yes"; then
         AC_MSG_ERROR([--enable-jni is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_16BIT" = "yes"; then
         AC_MSG_ERROR([--enable-16bit is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_SINGLETHREADED" = "yes"; then
         AC_MSG_ERROR([--enable-singlethreaded is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_VALGRIND" = "yes"; then
         AC_MSG_ERROR([--enable-valgrind is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_FASTMATH" = "yes"; then
         AC_MSG_ERROR([--enable-fastmath is incompatible with --enable-linuxkm (exceeds stack limit).])
     fi
     if test "$ENABLED_FAST_RSA" = "yes"; then
         AC_MSG_ERROR([--enable-fastrsa is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_LIBZ_RSA" = "yes"; then
         AC_MSG_ERROR([--with-libz is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_IOPOOL" = "yes"; then
         AC_MSG_ERROR([--enable-iopool is incompatible with --enable-linuxkm.])
     fi
     #FIPS currently depends on thread-local storage
     if test "$ENABLED_FIPS" = "yes"; then
         AC_MSG_ERROR([--enable-fips is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_EXAMPLES" = "yes"; then
         AC_MSG_ERROR([--enable-examples is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_SMALL_STACK" != "yes"; then
         AC_MSG_ERROR([--enable-smallstack is required for --enable-linuxkm.])
     fi
-    if test "$ENABLED_SMALL_STACK_CACHE" != "yes"; then
-        AC_MSG_ERROR([--enable-smallstackcache is required for --enable-linuxkm.])
+    if test "$ENABLED_SP_MATH" = "no"; then
+        AC_MSG_ERROR([--enable-sp-math is required for --enable-linuxkm.])
     fi
     if test "$ENABLED_STACKSIZE" = "yes"; then
         AC_MSG_ERROR([--enable-stacksize is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_STACKLOG" = "yes"; then
         AC_MSG_ERROR([--enable-stacklog is incompatible with --enable-linuxkm.])
     fi
     if test "$ENABLED_COMPKEY" = "yes"; then
         AC_MSG_ERROR([--enable-compkey is incompatible with --enable-linuxkm.])
     fi
diff --git a/src/internal.c b/src/internal.c
index 7fefaed5b..39e80d94b 100644
--- a/src/internal.c
+++ b/src/internal.c
@@ -10493,1171 +10493,1174 @@ static int ProcessPeerCertCheckKey(WOLFSSL* ssl, ProcPeerCertArgs* args)
 int ProcessPeerCerts(WOLFSSL* ssl, byte* input, word32* inOutIdx,
                      word32 totalSz)
 {
     int ret = 0;
 #ifdef WOLFSSL_ASYNC_CRYPT
     ProcPeerCertArgs* args = (ProcPeerCertArgs*)ssl->async.args;
     typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
     (void)sizeof(args_test);
 #elif defined(WOLFSSL_NONBLOCK_OCSP)
     ProcPeerCertArgs* args = ssl->nonblockarg;
 #elif defined(WOLFSSL_SMALL_STACK)
     ProcPeerCertArgs* args = NULL;
 #else
     ProcPeerCertArgs  args[1];
 #endif
     byte* subjectHash = NULL;
     int alreadySigner = 0;
 
     WOLFSSL_ENTER("ProcessPeerCerts");
 
 #ifdef WOLFSSL_ASYNC_CRYPT
     ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
     if (ret != WC_NOT_PENDING_E) {
         /* Check for error */
         if (ret < 0)
             goto exit_ppc;
     }
     else
 #elif defined(WOLFSSL_NONBLOCK_OCSP)
     if (args == NULL) {
         args = (ProcPeerCertArgs*)XMALLOC(
             sizeof(ProcPeerCertArgs), ssl->heap, DYNAMIC_TYPE_TMP_BUFFER);
         if (args == NULL) {
             ERROR_OUT(MEMORY_E, exit_ppc);
         }
     }
     if (ssl->nonblockarg == NULL) /* new args */
 #elif defined(WOLFSSL_SMALL_STACK)
     args = (ProcPeerCertArgs*)XMALLOC(
         sizeof(ProcPeerCertArgs), ssl->heap, DYNAMIC_TYPE_TMP_BUFFER);
     if (args == NULL) {
         ERROR_OUT(MEMORY_E, exit_ppc);
     }
 #endif
     {
         /* Reset state */
         ret = 0;
         ssl->options.asyncState = TLS_ASYNC_BEGIN;
         XMEMSET(args, 0, sizeof(ProcPeerCertArgs));
         args->idx = *inOutIdx;
         args->begin = *inOutIdx;
     #ifdef WOLFSSL_ASYNC_CRYPT
         ssl->async.freeArgs = FreeProcPeerCertArgs;
     #elif defined(WOLFSSL_NONBLOCK_OCSP)
         ssl->nonblockarg = args;
     #endif
     }
 
     switch (ssl->options.asyncState)
     {
         case TLS_ASYNC_BEGIN:
         {
             word32 listSz;
 
         #ifdef WOLFSSL_CALLBACKS
             if (ssl->hsInfoOn)
                 AddPacketName(ssl, "Certificate");
             if (ssl->toInfoOn)
                 AddLateName("Certificate", &ssl->timeoutInfo);
         #endif
 
         #ifdef WOLFSSL_TLS13
             if (ssl->options.tls1_3) {
                 byte ctxSz;
 
                 /* Certificate Request Context */
                 if ((args->idx - args->begin) + OPAQUE8_LEN > totalSz)
                     ERROR_OUT(BUFFER_ERROR, exit_ppc);
                 ctxSz = *(input + args->idx);
                 args->idx++;
                 if ((args->idx - args->begin) + ctxSz > totalSz)
                     ERROR_OUT(BUFFER_ERROR, exit_ppc);
             #ifndef NO_WOLFSSL_CLIENT
                 /* Must be empty when received from server. */
                 if (ssl->options.side == WOLFSSL_CLIENT_END) {
                     if (ctxSz != 0) {
                         ERROR_OUT(INVALID_CERT_CTX_E, exit_ppc);
                     }
                 }
             #endif
             #ifndef NO_WOLFSSL_SERVER
                 /* Must contain value sent in request. */
                 if (ssl->options.side == WOLFSSL_SERVER_END) {
                     if (ssl->options.handShakeState != HANDSHAKE_DONE &&
                                                                    ctxSz != 0) {
                         ERROR_OUT(INVALID_CERT_CTX_E, exit_ppc);
                     }
                     else if (ssl->options.handShakeState == HANDSHAKE_DONE) {
                 #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
                          CertReqCtx* curr = ssl->certReqCtx;
                          CertReqCtx* prev = NULL;
                          while (curr != NULL) {
                              if ((ctxSz == curr->len) &&
                                  XMEMCMP(&curr->ctx, input + args->idx, ctxSz)
                                                                          == 0) {
                                      if (prev != NULL)
                                          prev->next = curr->next;
                                      else
                                          ssl->certReqCtx = curr->next;
                                      XFREE(curr, ssl->heap,
                                            DYNAMIC_TYPE_TMP_BUFFER);
                                      break;
                              }
                              prev = curr;
                              curr = curr->next;
                         }
                         if (curr == NULL)
                 #endif
                             ERROR_OUT(INVALID_CERT_CTX_E, exit_ppc);
                     }
                 }
             #endif
                 args->idx += ctxSz;
 
             #ifdef OPENSSL_EXTRA
                 /* allocate buffer for cert extensions */
                 args->exts = (buffer*)XMALLOC(sizeof(buffer) *
                      (ssl->verifyDepth + 1), ssl->heap, DYNAMIC_TYPE_CERT_EXT);
                 if (args->exts == NULL) {
                     ERROR_OUT(MEMORY_E, exit_ppc);
                 }
             #else
                 /* allocate buffer for cert extensions */
                 args->exts = (buffer*)XMALLOC(sizeof(buffer) * MAX_CHAIN_DEPTH,
                                             ssl->heap, DYNAMIC_TYPE_CERT_EXT);
                 if (args->exts == NULL) {
                     ERROR_OUT(MEMORY_E, exit_ppc);
                 }
             #endif
             }
         #endif
 
             /* allocate buffer for certs */
         #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
             args->certs = (buffer*)XMALLOC(sizeof(buffer) *
                     (ssl->verifyDepth + 1), ssl->heap, DYNAMIC_TYPE_DER);
             if (args->certs == NULL) {
                 ERROR_OUT(MEMORY_E, exit_ppc);
             }
             XMEMSET(args->certs, 0, sizeof(buffer) * (ssl->verifyDepth + 1));
         #else
             args->certs = (buffer*)XMALLOC(sizeof(buffer) * MAX_CHAIN_DEPTH,
                                             ssl->heap, DYNAMIC_TYPE_DER);
             if (args->certs == NULL) {
                 ERROR_OUT(MEMORY_E, exit_ppc);
             }
             XMEMSET(args->certs, 0, sizeof(buffer) * MAX_CHAIN_DEPTH);
         #endif /* OPENSSL_EXTRA */
 
             /* Certificate List */
             if ((args->idx - args->begin) + OPAQUE24_LEN > totalSz) {
                 ERROR_OUT(BUFFER_ERROR, exit_ppc);
             }
             c24to32(input + args->idx, &listSz);
             args->idx += OPAQUE24_LEN;
             if (listSz > MAX_CERTIFICATE_SZ) {
                 ERROR_OUT(BUFFER_ERROR, exit_ppc);
             }
             if ((args->idx - args->begin) + listSz != totalSz) {
                 ERROR_OUT(BUFFER_ERROR, exit_ppc);
             }
 
             WOLFSSL_MSG("Loading peer's cert chain");
             /* first put cert chain into buffer so can verify top down
                we're sent bottom up */
             while (listSz) {
                 word32 certSz;
 
             #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                 if (args->totalCerts > ssl->verifyDepth) {
                     ssl->peerVerifyRet = X509_V_ERR_CERT_CHAIN_TOO_LONG;
                     ERROR_OUT(MAX_CHAIN_ERROR, exit_ppc);
                 }
             #else
                 if (args->totalCerts >= ssl->verifyDepth ||
                         args->totalCerts >= MAX_CHAIN_DEPTH) {
                     ERROR_OUT(MAX_CHAIN_ERROR, exit_ppc);
                 }
             #endif
 
                 if ((args->idx - args->begin) + OPAQUE24_LEN > totalSz) {
                     ERROR_OUT(BUFFER_ERROR, exit_ppc);
                 }
 
                 c24to32(input + args->idx, &certSz);
                 args->idx += OPAQUE24_LEN;
 
                 if ((args->idx - args->begin) + certSz > totalSz) {
                     ERROR_OUT(BUFFER_ERROR, exit_ppc);
                 }
 
                 args->certs[args->totalCerts].length = certSz;
                 args->certs[args->totalCerts].buffer = input + args->idx;
 
             #ifdef SESSION_CERTS
                 AddSessionCertToChain(&ssl->session.chain,
                     input + args->idx, certSz);
             #endif /* SESSION_CERTS */
 
                 args->idx += certSz;
                 listSz -= certSz + CERT_HEADER_SZ;
 
             #ifdef WOLFSSL_TLS13
                 /* Extensions */
                 if (ssl->options.tls1_3) {
                     word16 extSz;
 
                     if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {
                         ERROR_OUT(BUFFER_ERROR, exit_ppc);
                     }
                     ato16(input + args->idx, &extSz);
                     args->idx += OPAQUE16_LEN;
                     if ((args->idx - args->begin) + extSz > totalSz) {
                         ERROR_OUT(BUFFER_ERROR, exit_ppc);
                     }
                     /* Store extension data info for later processing. */
                     args->exts[args->totalCerts].length = extSz;
                     args->exts[args->totalCerts].buffer = input + args->idx;
                     args->idx += extSz;
                     listSz -= extSz + OPAQUE16_LEN;
                     ret = TLSX_Parse(ssl, args->exts[args->totalCerts].buffer,
                         args->exts[args->totalCerts].length, certificate, NULL);
                     if (ret < 0) {
                         ERROR_OUT(ret, exit_ppc);
                     }
                 }
             #endif
 
                 args->totalCerts++;
                 WOLFSSL_MSG("\tPut another cert into chain");
             } /* while (listSz) */
 
             args->count = args->totalCerts;
             args->certIdx = 0; /* select peer cert (first one) */
 
             if (args->count == 0 && (ssl->options.mutualAuth ||
                  (ssl->options.failNoCert && IsAtLeastTLSv1_3(ssl->version))) &&
                                       ssl->options.side == WOLFSSL_SERVER_END) {
                 ret = NO_PEER_CERT;
                 DoCertFatalAlert(ssl, ret);
             }
 
             args->dCertInit = 0;
         #ifndef WOLFSSL_SMALL_CERT_VERIFY
             args->dCert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), ssl->heap,
                                                        DYNAMIC_TYPE_DCERT);
             if (args->dCert == NULL) {
                 ERROR_OUT(MEMORY_E, exit_ppc);
             }
             XMEMSET(args->dCert, 0, sizeof(DecodedCert));
         #endif
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_BUILD;
         } /* case TLS_ASYNC_BEGIN */
         FALL_THROUGH;
 
         case TLS_ASYNC_BUILD:
         {
             if (args->count > 0) {
 
                 /* check for trusted peer and get untrustedDepth */
             #if defined(WOLFSSL_TRUST_PEER_CERT) || defined(OPENSSL_EXTRA)
                 if (args->certIdx == 0) {
                 #ifdef WOLFSSL_TRUST_PEER_CERT
                     TrustedPeerCert* tp;
                     int matchType = WC_MATCH_NAME;
                 #endif
 
                     ret = ProcessPeerCertParse(ssl, args, CERT_TYPE, NO_VERIFY,
                         &subjectHash, &alreadySigner);
                     if (ret != 0)
                         goto exit_ppc;
 
                 #ifdef OPENSSL_EXTRA
                     /* Determine untrusted depth */
                     if (!alreadySigner && (!args->dCert ||
                             !args->dCertInit || !args->dCert->selfSigned)) {
                         args->untrustedDepth = 1;
                     }
                 #endif
 
                 #ifdef WOLFSSL_TRUST_PEER_CERT
                     #ifndef NO_SKID
                     if (args->dCert->extAuthKeyIdSet)
                         matchType = WC_MATCH_SKID;
                     #endif
                     tp = GetTrustedPeer(ssl->ctx->cm, subjectHash, matchType);
                     WOLFSSL_MSG("Checking for trusted peer cert");
 
                     if (tp && MatchTrustedPeer(tp, args->dCert)) {
                         WOLFSSL_MSG("Found matching trusted peer cert");
                         args->haveTrustPeer = 1;
                     }
                     else if (tp == NULL) {
                         /* no trusted peer cert */
                         WOLFSSL_MSG("No matching trusted peer cert. Checking CAs");
                     }
                     else {
                         WOLFSSL_MSG("Trusted peer cert did not match!");
                     }
                     if (!args->haveTrustPeer)
                 #endif
                     {
                         /* free cert if not trusted peer */
                         FreeDecodedCert(args->dCert);
                         args->dCertInit = 0;
                     }
                 }
             #endif /* WOLFSSL_TRUST_PEER_CERT || OPENSSL_EXTRA */
 
                 /* check certificate up to peer's first */
                 /* do not verify chain if trusted peer cert found */
                 while (args->count > 1
                 #ifdef WOLFSSL_TRUST_PEER_CERT
                     && !args->haveTrustPeer
                 #endif /* WOLFSSL_TRUST_PEER_CERT */
                 ) {
                     int skipAddCA = 0;
 
                     /* select last certificate */
                     args->certIdx = args->count - 1;
 
                     ret = ProcessPeerCertParse(ssl, args, CERT_TYPE,
                         !ssl->options.verifyNone ? VERIFY : NO_VERIFY,
                         &subjectHash, &alreadySigner);
                 #ifdef WOLFSSL_ASYNC_CRYPT
                     if (ret == WC_PENDING_E)
                         goto exit_ppc;
                 #endif
                     if (ret == 0) {
                         ret = ProcessPeerCertCheckKey(ssl, args);
                     }
 
                     if (ret == 0 && args->dCert->isCA == 0) {
                         WOLFSSL_MSG("Chain cert is not a CA, not adding as one");
                     }
                     else if (ret == 0 && ssl->options.verifyNone) {
                         WOLFSSL_MSG("Chain cert not verified by option, "
                             "not adding as CA");
                     }
                     else if (ret == 0) {
                     #ifdef OPENSSL_EXTRA
                         if (args->certIdx > args->untrustedDepth) {
                             args->untrustedDepth = (char)args->certIdx + 1;
                         }
                     #endif
 
                         if (alreadySigner) {
                             WOLFSSL_MSG("Verified CA from chain and already had it");
                         }
                     }
                     else {
                         WOLFSSL_MSG("Failed to verify CA from chain");
                     #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                         ssl->peerVerifyRet = X509_V_ERR_INVALID_CA;
                     #endif
                     }
 
             #if defined(HAVE_OCSP) || defined(HAVE_CRL)
                     if (ret == 0) {
                         int doCrlLookup = 1;
                 #ifdef HAVE_OCSP
                     #ifdef HAVE_CERTIFICATE_STATUS_REQUEST_V2
                         if (ssl->status_request_v2) {
                             ret = TLSX_CSR2_InitRequests(ssl->extensions,
                                                     args->dCert, 0, ssl->heap);
                         }
                         else /* skips OCSP and force CRL check */
                     #endif /* HAVE_CERTIFICATE_STATUS_REQUEST_V2 */
                         if (ssl->ctx->cm->ocspEnabled &&
                                             ssl->ctx->cm->ocspCheckAll) {
                             WOLFSSL_MSG("Doing Non Leaf OCSP check");
                             ret = CheckCertOCSP_ex(ssl->ctx->cm->ocsp,
                                                     args->dCert, NULL, ssl);
                         #ifdef WOLFSSL_NONBLOCK_OCSP
                             if (ret == OCSP_WANT_READ) {
                                 args->lastErr = ret;
                                 goto exit_ppc;
                             }
                         #endif
                             doCrlLookup = (ret == OCSP_CERT_UNKNOWN);
                             if (ret != 0) {
                                 doCrlLookup = 0;
                                 WOLFSSL_MSG("\tOCSP Lookup not ok");
                             }
                         }
                 #endif /* HAVE_OCSP */
 
                 #ifdef HAVE_CRL
                         if (ret == 0 && doCrlLookup &&
                                     ssl->ctx->cm->crlEnabled &&
                                                 ssl->ctx->cm->crlCheckAll) {
                             WOLFSSL_MSG("Doing Non Leaf CRL check");
                             ret = CheckCertCRL(ssl->ctx->cm->crl, args->dCert);
                         #ifdef WOLFSSL_NONBLOCK_OCSP
                             if (ret == OCSP_WANT_READ) {
                                 args->lastErr = ret;
                                 goto exit_ppc;
                             }
                         #endif
                             if (ret != 0) {
                                 WOLFSSL_MSG("\tCRL check not ok");
                             }
                         }
                 #endif /* HAVE_CRL */
                         (void)doCrlLookup;
                     }
             #endif /* HAVE_OCSP || HAVE_CRL */
 
                     /* Do verify callback */
                     ret = DoVerifyCallback(ssl->ctx->cm, ssl, ret, args);
                     if (ssl->options.verifyNone &&
                               (ret == CRL_MISSING || ret == CRL_CERT_REVOKED)) {
                         WOLFSSL_MSG("Ignoring CRL problem based on verify setting");
                         ret = ssl->error = 0;
                     }
 
                 #ifdef WOLFSSL_ALT_CERT_CHAINS
                     /* For alternate cert chain, its okay for a CA cert to fail
                         with ASN_NO_SIGNER_E here. The "alternate" certificate
                         chain mode only requires that the peer certificate
                         validate to a trusted CA */
                     if (ret != 0 && args->dCert->isCA) {
                         if (ret == ASN_NO_SIGNER_E) {
                             if (!ssl->options.usingAltCertChain) {
                                 WOLFSSL_MSG("Trying alternate cert chain");
                                 ssl->options.usingAltCertChain = 1;
                             }
 
                             ret = 0; /* clear errors and continue */
                             args->verifyErr = 0;
                         }
 
                         /* do not add to certificate manager */
                         skipAddCA = 1;
                     }
                 #endif /* WOLFSSL_ALT_CERT_CHAINS */
 
                     /* If valid CA then add to Certificate Manager */
                     if (ret == 0 && args->dCert->isCA &&
                             !ssl->options.verifyNone && !skipAddCA) {
                         buffer* cert = &args->certs[args->certIdx];
 
                         /* Is valid CA */
                     #if defined(SESSION_CERTS) && defined(WOLFSSL_ALT_CERT_CHAINS)
                         /* if using alternate chain, store the cert used */
                         if (ssl->options.usingAltCertChain) {
                             AddSessionCertToChain(&ssl->session.altChain,
                                 cert->buffer, cert->length);
                         }
                     #endif /* SESSION_CERTS && WOLFSSL_ALT_CERT_CHAINS */
                         if (!alreadySigner) {
                             DerBuffer* add = NULL;
                             ret = AllocDer(&add, cert->length, CA_TYPE, ssl->heap);
                             if (ret < 0)
                                 goto exit_ppc;
 
                             XMEMCPY(add->buffer, cert->buffer, cert->length);
 
                             /* CA already verified above in ParseCertRelative */
                             WOLFSSL_MSG("Adding CA from chain");
                             ret = AddCA(ssl->ctx->cm, &add, WOLFSSL_CHAIN_CA,
                                 NO_VERIFY);
                             if (ret == WOLFSSL_SUCCESS) {
                                 ret = 0;
                             }
                         }
                     }
 
                     /* Handle error codes */
                     if (ret != 0) {
                         if (!ssl->options.verifyNone) {
                             DoCertFatalAlert(ssl, ret);
                         }
                         ssl->error = ret; /* Report SSL error */
 
                         if (args->lastErr == 0) {
                             args->lastErr = ret; /* save error from last time */
                             ret = 0; /* reset error */
                         }
                     }
 
                     FreeDecodedCert(args->dCert);
                     args->dCertInit = 0;
                     args->count--;
                 } /* while (count > 0 && !args->haveTrustPeer) */
             } /* if (count > 0) */
 
             /* Check for error */
             if (ret != 0) {
                 goto exit_ppc;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_DO;
         } /* case TLS_ASYNC_BUILD */
         FALL_THROUGH;
 
         case TLS_ASYNC_DO:
         {
             /* peer's, may not have one if blank client cert sent by TLSv1.2 */
             if (args->count > 0) {
                 WOLFSSL_MSG("Verifying Peer's cert");
 
                 /* select peer cert (first one) */
                 args->certIdx = 0;
 
                 ret = ProcessPeerCertParse(ssl, args, CERT_TYPE,
                         !ssl->options.verifyNone ? VERIFY : NO_VERIFY,
                         &subjectHash, &alreadySigner);
             #ifdef WOLFSSL_ASYNC_CRYPT
                 if (ret == WC_PENDING_E)
                     goto exit_ppc;
             #endif
                 if (ret == 0) {
                     WOLFSSL_MSG("Verified Peer's cert");
                 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                     ssl->peerVerifyRet = X509_V_OK;
                 #endif
                 #if defined(SESSION_CERTS) && defined(WOLFSSL_ALT_CERT_CHAINS)
                     /* if using alternate chain, store the cert used */
                     if (ssl->options.usingAltCertChain) {
                         buffer* cert = &args->certs[args->certIdx];
                         AddSessionCertToChain(&ssl->session.altChain,
                             cert->buffer, cert->length);
                     }
                 #endif /* SESSION_CERTS && WOLFSSL_ALT_CERT_CHAINS */
 
                     /* check if fatal error */
                     if (args->verifyErr) {
                         args->fatal = 1;
                         if (ret == 0) {
                             ret = args->lastErr;
                         }
                     }
                     else {
                         args->fatal = 0;
                     }
                 }
                 else if (ret == ASN_PARSE_E || ret == BUFFER_E) {
                     WOLFSSL_MSG("Got Peer cert ASN PARSE or BUFFER ERROR");
                 #if defined(WOLFSSL_EXTRA_ALERTS) || defined(OPENSSL_EXTRA) || \
                                                defined(OPENSSL_EXTRA_X509_SMALL)
                     DoCertFatalAlert(ssl, ret);
                 #endif
                 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                     ssl->peerVerifyRet = X509_V_ERR_CERT_REJECTED;
                 #endif
                     args->fatal = 1;
                 }
                 else {
                     WOLFSSL_MSG("Failed to verify Peer's cert");
                 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                     ssl->peerVerifyRet = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;
                 #endif
                     if (ssl->verifyCallback) {
                         WOLFSSL_MSG(
                             "\tCallback override available, will continue");
                         /* check if fatal error */
                         args->fatal = (args->verifyErr) ? 1 : 0;
                     #if defined(WOLFSSL_EXTRA_ALERTS) || \
                                                      defined(OPENSSL_EXTRA) || \
                                                defined(OPENSSL_EXTRA_X509_SMALL)
                         if (args->fatal)
                             DoCertFatalAlert(ssl, ret);
                     #endif
                     }
                     else {
                         WOLFSSL_MSG("\tNo callback override available, fatal");
                         args->fatal = 1;
                     #if defined(WOLFSSL_EXTRA_ALERTS) || \
                                                      defined(OPENSSL_EXTRA) || \
                                                defined(OPENSSL_EXTRA_X509_SMALL)
                         DoCertFatalAlert(ssl, ret);
                     #endif
                     }
                 }
 
             #ifdef HAVE_SECURE_RENEGOTIATION
                 if (args->fatal == 0 && !IsAtLeastTLSv1_3(ssl->version)
                                      && ssl->secure_renegotiation
                                      && ssl->secure_renegotiation->enabled) {
 
                     if (IsEncryptionOn(ssl, 0)) {
                         /* compare against previous time */
                         if (ssl->secure_renegotiation->subject_hash_set) {
                             if (XMEMCMP(args->dCert->subjectHash,
                                         ssl->secure_renegotiation->subject_hash,
                                         KEYID_SIZE) != 0) {
                                 WOLFSSL_MSG(
                                   "Peer sent different cert during scr, fatal");
                                 args->fatal = 1;
                                 ret = SCR_DIFFERENT_CERT_E;
                             }
                         }
                     }
 
                     /* cache peer's hash */
                     if (args->fatal == 0) {
                         XMEMCPY(ssl->secure_renegotiation->subject_hash,
                                 args->dCert->subjectHash, KEYID_SIZE);
                         ssl->secure_renegotiation->subject_hash_set = 1;
                     }
                 }
             #endif /* HAVE_SECURE_RENEGOTIATION */
             } /* if (count > 0) */
 
             /* Check for error */
             if (args->fatal && ret != 0) {
                 goto exit_ppc;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_VERIFY;
         } /* case TLS_ASYNC_DO */
         FALL_THROUGH;
 
         case TLS_ASYNC_VERIFY:
         {
             if (args->count > 0) {
             #if defined(HAVE_OCSP) || defined(HAVE_CRL)
                 if (args->fatal == 0) {
                     int doLookup = 1;
 
                     if (ssl->options.side == WOLFSSL_CLIENT_END) {
                 #ifdef HAVE_CERTIFICATE_STATUS_REQUEST
                         if (ssl->status_request) {
                             args->fatal = TLSX_CSR_InitRequest(ssl->extensions,
                                                     args->dCert, ssl->heap);
                             doLookup = 0;
                         #if defined(WOLFSSL_TLS13) && !defined(NO_WOLFSSL_SERVER)
                             if (ssl->options.tls1_3) {
                                 TLSX* ext = TLSX_Find(ssl->extensions,
                                                            TLSX_STATUS_REQUEST);
                                 if (ext != NULL) {
                                     word32 idx = 0;
                                     CertificateStatusRequest* csr =
                                            (CertificateStatusRequest*)ext->data;
                                     ret = ProcessCSR(ssl, csr->response.buffer,
                                                     &idx, csr->response.length);
                                     if (ret < 0)
                                         goto exit_ppc;
                                 }
                             }
                         #endif
                         }
                 #endif /* HAVE_CERTIFICATE_STATUS_REQUEST */
                 #ifdef HAVE_CERTIFICATE_STATUS_REQUEST_V2
                         if (ssl->status_request_v2) {
                             args->fatal = TLSX_CSR2_InitRequests(ssl->extensions,
                                                     args->dCert, 1, ssl->heap);
                             doLookup = 0;
                         }
                 #endif /* HAVE_CERTIFICATE_STATUS_REQUEST_V2 */
                     }
 
                 #ifdef HAVE_OCSP
                     if (doLookup && ssl->ctx->cm->ocspEnabled) {
                         WOLFSSL_MSG("Doing Leaf OCSP check");
                         ret = CheckCertOCSP_ex(ssl->ctx->cm->ocsp,
                                                     args->dCert, NULL, ssl);
                     #ifdef WOLFSSL_NONBLOCK_OCSP
                         if (ret == OCSP_WANT_READ) {
                             goto exit_ppc;
                         }
                     #endif
                         doLookup = (ret == OCSP_CERT_UNKNOWN);
                         if (ret != 0) {
                             WOLFSSL_MSG("\tOCSP Lookup not ok");
                             args->fatal = 0;
                         #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                             ssl->peerVerifyRet = X509_V_ERR_CERT_REJECTED;
                         #endif
                         }
                     }
                 #endif /* HAVE_OCSP */
 
                 #ifdef HAVE_CRL
                     if (doLookup && ssl->ctx->cm->crlEnabled) {
                         WOLFSSL_MSG("Doing Leaf CRL check");
                         ret = CheckCertCRL(ssl->ctx->cm->crl, args->dCert);
                     #ifdef WOLFSSL_NONBLOCK_OCSP
                         if (ret == OCSP_WANT_READ) {
                             goto exit_ppc;
                         }
                     #endif
                         if (ret != 0) {
                             WOLFSSL_MSG("\tCRL check not ok");
                             args->fatal = 0;
                         #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                             ssl->peerVerifyRet = X509_V_ERR_CERT_REJECTED;
                         #endif
                         }
                     }
                 #endif /* HAVE_CRL */
                     (void)doLookup;
                 }
             #endif /* HAVE_OCSP || HAVE_CRL */
 
             #ifdef KEEP_PEER_CERT
                 if (args->fatal == 0) {
                     int copyRet = 0;
 
                     #ifdef WOLFSSL_POST_HANDSHAKE_AUTH
                         if (ssl->options.handShakeDone) {
                             FreeX509(&ssl->peerCert);
                             InitX509(&ssl->peerCert, 0, ssl->heap);
                         }
                         else
                     #endif
                     #ifdef HAVE_SECURE_RENEGOTIATION
                         if (ssl->secure_renegotiation &&
                                            ssl->secure_renegotiation->enabled) {
                             /* free old peer cert */
                             FreeX509(&ssl->peerCert);
                             InitX509(&ssl->peerCert, 0, ssl->heap);
                         }
                         else
                     #endif
                         {
                         }
 
                     /* set X509 format for peer cert */
                     copyRet = CopyDecodedToX509(&ssl->peerCert, args->dCert);
                     if (copyRet == MEMORY_E) {
                         args->fatal = 1;
                     }
                 }
             #endif /* KEEP_PEER_CERT */
 
             #ifndef IGNORE_KEY_EXTENSIONS
                 #if defined(OPENSSL_EXTRA)
                   /* when compatibility layer is turned on and no verify is
                    * set then ignore the certificate key extension */
                     if (args->dCert->extKeyUsageSet &&
                           args->dCert->extKeyUsageCrit == 0 &&
                           ssl->options.verifyNone) {
                         WOLFSSL_MSG("Not verifying certificate key usage");
                     }
                     else
                 #endif
                 if (args->dCert->extKeyUsageSet) {
                     if ((ssl->specs.kea == rsa_kea) &&
                         (ssl->options.side == WOLFSSL_CLIENT_END) &&
                         (args->dCert->extKeyUsage & KEYUSE_KEY_ENCIPHER) == 0) {
                         ret = KEYUSE_ENCIPHER_E;
                     }
                     if ((ssl->specs.sig_algo == rsa_sa_algo ||
                             (ssl->specs.sig_algo == ecc_dsa_sa_algo &&
                                  !ssl->specs.static_ecdh)) &&
                         (args->dCert->extKeyUsage & KEYUSE_DIGITAL_SIG) == 0) {
                         WOLFSSL_MSG("KeyUse Digital Sig not set");
                         ret = KEYUSE_SIGNATURE_E;
                     }
                 }
 
                 #if defined(OPENSSL_EXTRA)
                     /* when compatibility layer is turned on and no verify is
                      * set then ignore the certificate key extension */
                     if (args->dCert->extExtKeyUsageSet &&
                             args->dCert->extExtKeyUsageCrit == 0 &&
                           ssl->options.verifyNone) {
                                 WOLFSSL_MSG("Not verifying certificate ext key usage");
                     }
                     else
                 #endif
                 if (args->dCert->extExtKeyUsageSet) {
                     if (ssl->options.side == WOLFSSL_CLIENT_END) {
                         if ((args->dCert->extExtKeyUsage &
                                 (EXTKEYUSE_ANY | EXTKEYUSE_SERVER_AUTH)) == 0) {
                             WOLFSSL_MSG("ExtKeyUse Server Auth not set");
                             ret = EXTKEYUSE_AUTH_E;
                         }
                     }
                     else {
                         if ((args->dCert->extExtKeyUsage &
                                 (EXTKEYUSE_ANY | EXTKEYUSE_CLIENT_AUTH)) == 0) {
                             WOLFSSL_MSG("ExtKeyUse Client Auth not set");
                             ret = EXTKEYUSE_AUTH_E;
                         }
                     }
                 }
             #endif /* IGNORE_KEY_EXTENSIONS */
 
                 if (args->fatal) {
                     ssl->error = ret;
                 #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
                     SendAlert(ssl, alert_fatal, bad_certificate);
                     ssl->peerVerifyRet = X509_V_ERR_CERT_REJECTED;
                 #endif
                     goto exit_ppc;
                 }
 
                 ssl->options.havePeerCert = 1;
 
                 if (!ssl->options.verifyNone && ssl->buffers.domainName.buffer) {
                 #ifndef WOLFSSL_ALLOW_NO_CN_IN_SAN
                     /* Per RFC 5280 section 4.2.1.6, "Whenever such identities
                      * are to be bound into a certificate, the subject
                      * alternative name extension MUST be used." */
                     if (args->dCert->altNames) {
                         if (CheckForAltNames(args->dCert,
                                 (char*)ssl->buffers.domainName.buffer,
                                 NULL) != 1) {
                             WOLFSSL_MSG("DomainName match on alt names failed");
                             /* try to get peer key still */
                             ret = DOMAIN_NAME_MISMATCH;
                         }
                     }
                     else {
                         if (MatchDomainName(
                                  args->dCert->subjectCN,
                                  args->dCert->subjectCNLen,
                                  (char*)ssl->buffers.domainName.buffer) == 0) {
                             WOLFSSL_MSG("DomainName match on common name failed");
                             ret = DOMAIN_NAME_MISMATCH;
                         }
                     }
                 #else /* WOLFSSL_ALL_NO_CN_IN_SAN */
                     /* Old behavior. */
                     if (MatchDomainName(args->dCert->subjectCN,
                                 args->dCert->subjectCNLen,
                                 (char*)ssl->buffers.domainName.buffer) == 0) {
                         WOLFSSL_MSG("DomainName match on common name failed");
                         if (CheckForAltNames(args->dCert,
                                  (char*)ssl->buffers.domainName.buffer,
                                  NULL) != 1) {
                             WOLFSSL_MSG(
                                 "DomainName match on alt names failed too");
                             /* try to get peer key still */
                             ret = DOMAIN_NAME_MISMATCH;
                         }
                     }
                 #endif /* WOLFSSL_ALL_NO_CN_IN_SAN */
                 }
 
                 /* decode peer key */
                 switch (args->dCert->keyOID) {
                 #ifndef NO_RSA
                     case RSAk:
                     {
                         word32 keyIdx = 0;
                         int keyRet = 0;
 
                         if (ssl->peerRsaKey == NULL) {
                             keyRet = AllocKey(ssl, DYNAMIC_TYPE_RSA,
                                                 (void**)&ssl->peerRsaKey);
                         } else if (ssl->peerRsaKeyPresent) {
                             keyRet = ReuseKey(ssl, DYNAMIC_TYPE_RSA,
                                               ssl->peerRsaKey);
                             ssl->peerRsaKeyPresent = 0;
                         }
 
                         if (keyRet != 0 || wc_RsaPublicKeyDecode(
                                args->dCert->publicKey, &keyIdx, ssl->peerRsaKey,
                                                 args->dCert->pubKeySize) != 0) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             ssl->peerRsaKeyPresent = 1;
                     #ifdef WOLFSSL_RENESAS_TSIP_TLS
                         /* copy encrypted tsip key index into ssl object */
                         if (args->dCert->tsip_encRsaKeyIdx) {
                             if (!ssl->peerTsipEncRsaKeyIndex) {
                                 ssl->peerTsipEncRsaKeyIndex = (byte*)XMALLOC(
                                     TSIP_TLS_ENCPUBKEY_SZ_BY_CERTVRFY,
                                     ssl->heap, DYNAMIC_TYPE_RSA);
                                 if (!ssl->peerTsipEncRsaKeyIndex) {
                                     args->lastErr = MEMORY_E;
                                     goto exit_ppc;
                                 }
                             }
 
                             XMEMCPY(ssl->peerTsipEncRsaKeyIndex,
                                         args->dCert->tsip_encRsaKeyIdx,
                                         TSIP_TLS_ENCPUBKEY_SZ_BY_CERTVRFY);
                          }
                     #endif
                     #ifdef HAVE_PK_CALLBACKS
                         #ifndef NO_RSA
                             #if defined(HAVE_SECURE_RENEGOTIATION) || \
                                             defined(WOLFSSL_POST_HANDSHAKE_AUTH)
                             if (ssl->buffers.peerRsaKey.buffer) {
                                 XFREE(ssl->buffers.peerRsaKey.buffer,
                                         ssl->heap, DYNAMIC_TYPE_RSA);
                                 ssl->buffers.peerRsaKey.buffer = NULL;
                             }
                             #endif
 
 
                             ssl->buffers.peerRsaKey.buffer =
                                    (byte*)XMALLOC(args->dCert->pubKeySize,
                                                 ssl->heap, DYNAMIC_TYPE_RSA);
                             if (ssl->buffers.peerRsaKey.buffer == NULL) {
                                 ret = MEMORY_ERROR;
                             }
                             else {
                                 XMEMCPY(ssl->buffers.peerRsaKey.buffer,
                                         args->dCert->publicKey,
                                         args->dCert->pubKeySize);
                                 ssl->buffers.peerRsaKey.length =
                                     args->dCert->pubKeySize;
                             }
                         #endif /* NO_RSA */
                     #endif /* HAVE_PK_CALLBACKS */
                         }
 
                         /* check size of peer RSA key */
                         if (ret == 0 && ssl->peerRsaKeyPresent &&
                                           !ssl->options.verifyNone &&
                                           wc_RsaEncryptSize(ssl->peerRsaKey)
                                               < ssl->options.minRsaKeySz) {
                             ret = RSA_KEY_SIZE_E;
                             WOLFSSL_MSG("Peer RSA key is too small");
                         }
                         break;
                     }
                 #endif /* NO_RSA */
                 #ifdef HAVE_NTRU
                     case NTRUk:
                     {
                         if (args->dCert->pubKeySize > sizeof(ssl->peerNtruKey)) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             XMEMCPY(ssl->peerNtruKey, args->dCert->publicKey,
                                                       args->dCert->pubKeySize);
                             ssl->peerNtruKeyLen =
                                 (word16)args->dCert->pubKeySize;
                             ssl->peerNtruKeyPresent = 1;
                         }
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #ifdef HAVE_ECC
                     case ECDSAk:
                     {
                         int keyRet = 0;
                         word32 idx = 0;
 
                         if (ssl->peerEccDsaKey == NULL) {
                             /* alloc/init on demand */
                             keyRet = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                     (void**)&ssl->peerEccDsaKey);
                         } else if (ssl->peerEccDsaKeyPresent) {
                             keyRet = ReuseKey(ssl, DYNAMIC_TYPE_ECC,
                                               ssl->peerEccDsaKey);
                             ssl->peerEccDsaKeyPresent = 0;
                         }
 
                         if (keyRet != 0 ||
                             wc_EccPublicKeyDecode(args->dCert->publicKey, &idx,
                                                 ssl->peerEccDsaKey,
                                                 args->dCert->pubKeySize) != 0) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             ssl->peerEccDsaKeyPresent = 1;
                     #ifdef HAVE_PK_CALLBACKS
+                            if (ssl->buffers.peerEccDsaKey.buffer)
+                                XFREE(ssl->buffers.peerEccDsaKey.buffer,
+                                      ssl->heap, DYNAMIC_TYPE_ECC);
                             ssl->buffers.peerEccDsaKey.buffer =
                                    (byte*)XMALLOC(args->dCert->pubKeySize,
                                            ssl->heap, DYNAMIC_TYPE_ECC);
                             if (ssl->buffers.peerEccDsaKey.buffer == NULL) {
                                 ERROR_OUT(MEMORY_ERROR, exit_ppc);
                             }
                             else {
                                 XMEMCPY(ssl->buffers.peerEccDsaKey.buffer,
                                         args->dCert->publicKey,
                                         args->dCert->pubKeySize);
                                 ssl->buffers.peerEccDsaKey.length =
                                         args->dCert->pubKeySize;
                             }
                     #endif /* HAVE_PK_CALLBACKS */
                         }
 
                         /* check size of peer ECC key */
                         if (ret == 0 && ssl->peerEccDsaKeyPresent &&
                                               !ssl->options.verifyNone &&
                                               wc_ecc_size(ssl->peerEccDsaKey)
                                               < ssl->options.minEccKeySz) {
                             ret = ECC_KEY_SIZE_E;
                             WOLFSSL_MSG("Peer ECC key is too small");
                         }
                         break;
                     }
                 #endif /* HAVE_ECC */
                 #ifdef HAVE_ED25519
                     case ED25519k:
                     {
                         int keyRet = 0;
                         if (ssl->peerEd25519Key == NULL) {
                             /* alloc/init on demand */
                             keyRet = AllocKey(ssl, DYNAMIC_TYPE_ED25519,
                                     (void**)&ssl->peerEd25519Key);
                         } else if (ssl->peerEd25519KeyPresent) {
                             keyRet = ReuseKey(ssl, DYNAMIC_TYPE_ED25519,
                                               ssl->peerEd25519Key);
                             ssl->peerEd25519KeyPresent = 0;
                         }
 
                         if (keyRet != 0 ||
                             wc_ed25519_import_public(args->dCert->publicKey,
                                                      args->dCert->pubKeySize,
                                                      ssl->peerEd25519Key)
                                                                          != 0) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             ssl->peerEd25519KeyPresent = 1;
                     #ifdef HAVE_PK_CALLBACKS
                             ssl->buffers.peerEd25519Key.buffer =
                                    (byte*)XMALLOC(args->dCert->pubKeySize,
                                            ssl->heap, DYNAMIC_TYPE_ED25519);
                             if (ssl->buffers.peerEd25519Key.buffer == NULL) {
                                 ERROR_OUT(MEMORY_ERROR, exit_ppc);
                             }
                             else {
                                 XMEMCPY(ssl->buffers.peerEd25519Key.buffer,
                                         args->dCert->publicKey,
                                         args->dCert->pubKeySize);
                                 ssl->buffers.peerEd25519Key.length =
                                         args->dCert->pubKeySize;
                             }
                     #endif /*HAVE_PK_CALLBACKS */
                         }
 
                         /* check size of peer ECC key */
                         if (ret == 0 && ssl->peerEd25519KeyPresent &&
                                   !ssl->options.verifyNone &&
                                   ED25519_KEY_SIZE < ssl->options.minEccKeySz) {
                             ret = ECC_KEY_SIZE_E;
                             WOLFSSL_MSG("Peer ECC key is too small");
                         }
                         break;
                     }
                 #endif /* HAVE_ED25519 */
                 #ifdef HAVE_ED448
                     case ED448k:
                     {
                         int keyRet = 0;
                         if (ssl->peerEd448Key == NULL) {
                             /* alloc/init on demand */
                             keyRet = AllocKey(ssl, DYNAMIC_TYPE_ED448,
                                     (void**)&ssl->peerEd448Key);
                         } else if (ssl->peerEd448KeyPresent) {
                             keyRet = ReuseKey(ssl, DYNAMIC_TYPE_ED448,
                                     ssl->peerEd448Key);
                             ssl->peerEd448KeyPresent = 0;
                         }
 
                         if (keyRet != 0 ||
                             wc_ed448_import_public(args->dCert->publicKey,
                                     args->dCert->pubKeySize,
                                     ssl->peerEd448Key) != 0) {
                             ret = PEER_KEY_ERROR;
                         }
                         else {
                             ssl->peerEd448KeyPresent = 1;
                     #ifdef HAVE_PK_CALLBACKS
                             ssl->buffers.peerEd448Key.buffer =
                                    (byte*)XMALLOC(args->dCert->pubKeySize,
                                            ssl->heap, DYNAMIC_TYPE_ED448);
                             if (ssl->buffers.peerEd448Key.buffer == NULL) {
                                 ERROR_OUT(MEMORY_ERROR, exit_ppc);
                             }
                             else {
                                 XMEMCPY(ssl->buffers.peerEd448Key.buffer,
                                         args->dCert->publicKey,
                                         args->dCert->pubKeySize);
                                 ssl->buffers.peerEd448Key.length =
                                         args->dCert->pubKeySize;
                             }
                     #endif /*HAVE_PK_CALLBACKS */
                         }
 
                         /* check size of peer ECC key */
                         if (ret == 0 && ssl->peerEd448KeyPresent &&
                                !ssl->options.verifyNone &&
                                ED448_KEY_SIZE < ssl->options.minEccKeySz) {
                             ret = ECC_KEY_SIZE_E;
                             WOLFSSL_MSG("Peer ECC key is too small");
                         }
                         break;
                     }
                 #endif /* HAVE_ED448 */
                     default:
                         break;
                 }
 
                 /* args->dCert free'd in function cleanup after callback */
             } /* if (count > 0) */
 
             /* Check for error */
             if (args->fatal && ret != 0) {
                 goto exit_ppc;
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_FINALIZE;
         } /* case TLS_ASYNC_VERIFY */
         FALL_THROUGH;
 
         case TLS_ASYNC_FINALIZE:
         {
             /* load last error */
             if (args->lastErr != 0 && ret == 0) {
                 ret = args->lastErr;
             }
 
         #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
             if (args->untrustedDepth > ssl->options.verifyDepth) {
                 ssl->peerVerifyRet = X509_V_ERR_CERT_CHAIN_TOO_LONG;
                 ret = MAX_CHAIN_ERROR;
             }
         #endif
 
             /* Do verify callback */
             ret = DoVerifyCallback(ssl->ctx->cm, ssl, ret, args);
 
             if (ssl->options.verifyNone &&
                               (ret == CRL_MISSING || ret == CRL_CERT_REVOKED)) {
                 WOLFSSL_MSG("Ignoring CRL problem based on verify setting");
                 ret = ssl->error = 0;
             }
 
             if (ret != 0) {
                 if (!ssl->options.verifyNone) {
                     DoCertFatalAlert(ssl, ret);
                 }
                 ssl->error = ret; /* Report SSL error */
             }
 
             if (ret == 0 && ssl->options.side == WOLFSSL_CLIENT_END) {
                 ssl->options.serverState = SERVER_CERT_COMPLETE;
             }
 
             if (IsEncryptionOn(ssl, 0)) {
                 args->idx += ssl->keys.padSz;
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                 if (ssl->options.startedETMRead)
                     args->idx += MacSize(ssl);
             #endif
             }
 
             /* Advance state and proceed */
             ssl->options.asyncState = TLS_ASYNC_END;
         } /* case TLS_ASYNC_FINALIZE */
         FALL_THROUGH;
 
         case TLS_ASYNC_END:
         {
             /* Set final index */
             *inOutIdx = args->idx;
 
             break;
         }
         default:
             ret = INPUT_CASE_ERROR;
             break;
     } /* switch(ssl->options.asyncState) */
@@ -21122,160 +21125,171 @@ static void FreeDskeArgs(WOLFSSL* ssl, void* pArgs)
 #ifndef NO_DH
 static int GetDhPublicKey(WOLFSSL* ssl, const byte* input, word32 size,
                           DskeArgs* args)
 {
     int             ret = 0;
     word16          length;
 #ifdef HAVE_FFDHE
     const DhParams* params = NULL;
     int             group = 0;
 #endif
 
     ssl->buffers.weOwnDH = 1;
 
-    ssl->buffers.serverDH_P.buffer = NULL;
-    ssl->buffers.serverDH_G.buffer = NULL;
-    ssl->buffers.serverDH_Pub.buffer = NULL;
+    if (ssl->buffers.serverDH_P.buffer) {
+        XFREE(ssl->buffers.serverDH_P.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
+        ssl->buffers.serverDH_P.buffer = NULL;
+    }
+
+    if (ssl->buffers.serverDH_G.buffer) {
+        XFREE(ssl->buffers.serverDH_G.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
+        ssl->buffers.serverDH_G.buffer = NULL;
+    }
+
+    if (ssl->buffers.serverDH_Pub.buffer) {
+        XFREE(ssl->buffers.serverDH_Pub.buffer, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
+        ssl->buffers.serverDH_Pub.buffer = NULL;
+    }
 
     /* p */
     if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ato16(input + args->idx, &length);
     args->idx += OPAQUE16_LEN;
 
     if ((args->idx - args->begin) + length > size) {
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     if (length < ssl->options.minDhKeySz) {
         WOLFSSL_MSG("Server using a DH key that is too small");
         SendAlert(ssl, alert_fatal, handshake_failure);
         ERROR_OUT(DH_KEY_SIZE_E, exit_gdpk);
     }
     if (length > ssl->options.maxDhKeySz) {
         WOLFSSL_MSG("Server using a DH key that is too big");
         SendAlert(ssl, alert_fatal, handshake_failure);
         ERROR_OUT(DH_KEY_SIZE_E, exit_gdpk);
     }
 
     ssl->buffers.serverDH_P.buffer =
         (byte*)XMALLOC(length, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
     if (ssl->buffers.serverDH_P.buffer) {
         ssl->buffers.serverDH_P.length = length;
     }
     else {
         ERROR_OUT(MEMORY_ERROR, exit_gdpk);
     }
 
     XMEMCPY(ssl->buffers.serverDH_P.buffer, input + args->idx,
                                                         length);
     args->idx += length;
 
     ssl->options.dhKeySz = length;
 
     /* g */
     if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ato16(input + args->idx, &length);
     args->idx += OPAQUE16_LEN;
 
     if ((args->idx - args->begin) + length > size) {
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ssl->buffers.serverDH_G.buffer =
         (byte*)XMALLOC(length, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
     if (ssl->buffers.serverDH_G.buffer) {
         ssl->buffers.serverDH_G.length = length;
     }
     else {
         ERROR_OUT(MEMORY_ERROR, exit_gdpk);
     }
 
     XMEMCPY(ssl->buffers.serverDH_G.buffer, input + args->idx,
                                                         length);
     args->idx += length;
 
     /* pub */
     if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ato16(input + args->idx, &length);
     args->idx += OPAQUE16_LEN;
 
     if ((args->idx - args->begin) + length > size) {
         ERROR_OUT(BUFFER_ERROR, exit_gdpk);
     }
 
     ssl->buffers.serverDH_Pub.buffer =
         (byte*)XMALLOC(length, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
     if (ssl->buffers.serverDH_Pub.buffer) {
         ssl->buffers.serverDH_Pub.length = length;
     }
     else {
         ERROR_OUT(MEMORY_ERROR, exit_gdpk);
     }
 
     XMEMCPY(ssl->buffers.serverDH_Pub.buffer, input + args->idx,
                                                         length);
     args->idx += length;
 
 #ifdef HAVE_FFDHE
     switch (ssl->options.dhKeySz) {
     #ifdef HAVE_FFDHE_2048
         case 2048/8:
             params = wc_Dh_ffdhe2048_Get();
             group = WOLFSSL_FFDHE_2048;
             break;
     #endif
     #ifdef HAVE_FFDHE_3072
         case 3072/8:
             params = wc_Dh_ffdhe3072_Get();
             group = WOLFSSL_FFDHE_3072;
             break;
     #endif
     #ifdef HAVE_FFDHE_4096
         case 4096/8:
             params = wc_Dh_ffdhe4096_Get();
             group = WOLFSSL_FFDHE_4096;
             break;
     #endif
     #ifdef HAVE_FFDHE_6144
         case 6144/8:
             params = wc_Dh_ffdhe6144_Get();
             group = WOLFSSL_FFDHE_6144;
             break;
     #endif
     #ifdef HAVE_FFDHE_8192
         case 8192/8:
             params = wc_Dh_ffdhe8192_Get();
             group = WOLFSSL_FFDHE_8192;
             break;
     #endif
         default:
             break;
     }
 
     if (params == NULL || params->g_len != ssl->buffers.serverDH_G.length ||
             (XMEMCMP(ssl->buffers.serverDH_G.buffer, params->g,
                     params->g_len) != 0) ||
             (XMEMCMP(ssl->buffers.serverDH_P.buffer, params->p,
                     params->p_len) != 0)) {
         WOLFSSL_MSG("Server not using FFDHE parameters");
     #ifdef WOLFSSL_REQUIRE_FFDHE
         SendAlert(ssl, alert_fatal, handshake_failure);
         ERROR_OUT(DH_PARAMS_NOT_FFDHE_E, exit_gdpk);
     #endif
     }
     else {
         ssl->namedGroup = group;
     #if !defined(WOLFSSL_OLD_PRIME_CHECK) && !defined(HAVE_FIPS) && \
         !defined(HAVE_SELFTEST)
         ssl->options.dhDoKeyTest = 0;
     #endif
     }
 #endif /* HAVE_FFDHE */
@@ -24493,5473 +24507,5515 @@ int SetTicket(WOLFSSL* ssl, const byte* ticket, word32 length)
 /* handle processing of session_ticket (4) */
 static int DoSessionTicket(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
     word32 size)
 {
     word32 begin = *inOutIdx;
     word32 lifetime;
     word16 length;
     int    ret;
 
     if (ssl->expect_session_ticket == 0) {
         WOLFSSL_MSG("Unexpected session ticket");
         return SESSION_TICKET_EXPECT_E;
     }
 
     if (OPAQUE32_LEN > size)
         return BUFFER_ERROR;
 
     ato32(input + *inOutIdx, &lifetime);
     *inOutIdx += OPAQUE32_LEN;
 
     if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
         return BUFFER_ERROR;
 
     ato16(input + *inOutIdx, &length);
     *inOutIdx += OPAQUE16_LEN;
 
     if ((*inOutIdx - begin) + length > size)
         return BUFFER_ERROR;
 
     if ((ret = SetTicket(ssl, input + *inOutIdx, length)) != 0)
         return ret;
     *inOutIdx += length;
     if (length > 0) {
         ssl->timeout = lifetime;
 #ifndef NO_SESSION_CACHE
         AddSession(ssl);
 #endif
     }
 
     if (IsEncryptionOn(ssl, 0)) {
         *inOutIdx += ssl->keys.padSz;
     #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
         if (ssl->options.startedETMRead)
             *inOutIdx += MacSize(ssl);
     #endif
     }
 
     ssl->expect_session_ticket = 0;
 
     return 0;
 }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #endif /* HAVE_SESSION_TICKET */
 
 #endif /* NO_WOLFSSL_CLIENT */
 
 #ifndef NO_CERTS
 
 #ifdef HAVE_PK_CALLBACKS
     int GetPrivateKeySigSize(WOLFSSL* ssl)
     {
         int sigSz = 0;
 
         if (ssl == NULL)
             return 0;
 
         switch (ssl->buffers.keyType) {
         #ifndef NO_RSA
         #ifdef WC_RSA_PSS
             case rsa_pss_sa_algo:
         #endif
             case rsa_sa_algo:
                 sigSz = ssl->buffers.keySz;
                 ssl->hsType = DYNAMIC_TYPE_RSA;
                 break;
         #endif
         #ifdef HAVE_ECC
             case ecc_dsa_sa_algo:
                 sigSz = wc_ecc_sig_size_calc(ssl->buffers.keySz);
                 ssl->hsType = DYNAMIC_TYPE_ECC;
                 break;
         #endif
         #ifdef HAVE_ED25519
             case ed25519_sa_algo:
                 sigSz = ED25519_SIG_SIZE; /* fixed known value */
                 ssl->hsType = DYNAMIC_TYPE_ED25519;
                 break;
         #endif
         #ifdef HAVE_ED448
             case ed448_sa_algo:
                 sigSz = ED448_SIG_SIZE; /* fixed known value */
                 ssl->hsType = DYNAMIC_TYPE_ED448;
                 break;
         #endif
             default:
                 break;
         }
         return sigSz;
     }
 #endif /* HAVE_PK_CALLBACKS */
 
 #endif /* NO_CERTS */
 
 #ifdef HAVE_ECC
     /* returns the WOLFSSL_* version of the curve from the OID sum */
     word16 GetCurveByOID(int oidSum) {
         switch(oidSum) {
     #if defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP160R1_OID:
                 return WOLFSSL_ECC_SECP160R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_SECPR2
             case ECC_SECP160R2_OID:
                 return WOLFSSL_ECC_SECP160R2;
         #endif /* HAVE_ECC_SECPR2 */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP160K1_OID:
                 return WOLFSSL_ECC_SECP160K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP192R1_OID:
                 return WOLFSSL_ECC_SECP192R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP192K1_OID:
                 return WOLFSSL_ECC_SECP192K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP224R1_OID:
                 return WOLFSSL_ECC_SECP224R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP224K1_OID:
                 return WOLFSSL_ECC_SECP224K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if !defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP256R1_OID:
                 return WOLFSSL_ECC_SECP256R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP256K1_OID:
                 return WOLFSSL_ECC_SECP256K1;
         #endif /* HAVE_ECC_KOBLITZ */
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP256R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP256R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP384R1_OID:
                 return WOLFSSL_ECC_SECP384R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP384R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP384R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP512R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP512R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)
         #ifndef NO_ECC_SECP
             case ECC_SECP521R1_OID:
                 return WOLFSSL_ECC_SECP521R1;
         #endif /* !NO_ECC_SECP */
     #endif
             default:
                 WOLFSSL_MSG("Curve OID not compiled in or implemented");
                 return 0;
         }
     }
 #endif /* HAVE_ECC */
 
 
 #ifndef NO_WOLFSSL_SERVER
 
 #ifndef WOLFSSL_NO_TLS12
 
     /* handle generation of server_hello (2) */
     int SendServerHello(WOLFSSL* ssl)
     {
         int    ret;
         byte   *output;
         word16 length;
         word32 idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int    sendSz;
         byte   sessIdSz = ID_LEN;
         byte   echoId   = 0;  /* ticket echo id flag */
         byte   cacheOff = 0;  /* session cache off flag */
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_SEND);
         WOLFSSL_ENTER("SendServerHello");
 
         length = VERSION_SZ + RAN_LEN
                + ID_LEN + ENUM_LEN
                + SUITE_LEN
                + ENUM_LEN;
 
 #ifdef HAVE_TLS_EXTENSIONS
         ret = TLSX_GetResponseSize(ssl, server_hello, &length);
         if (ret != 0)
             return ret;
     #ifdef HAVE_SESSION_TICKET
         if (ssl->options.useTicket) {
             /* echo session id sz can be 0,32 or bogus len in between */
             sessIdSz = ssl->arrays->sessionIDSz;
             if (sessIdSz > ID_LEN) {
                 WOLFSSL_MSG("Bad bogus session id len");
                 return BUFFER_ERROR;
             }
             if (!IsAtLeastTLSv1_3(ssl->version))
                 length -= (ID_LEN - sessIdSz);  /* adjust ID_LEN assumption */
             echoId = 1;
         }
     #endif /* HAVE_SESSION_TICKET */
 #else
         if (ssl->options.haveEMS) {
             length += HELLO_EXT_SZ_SZ + HELLO_EXT_SZ;
         }
 #endif
 
         /* is the session cache off at build or runtime */
 #ifdef NO_SESSION_CACHE
         cacheOff = 1;
 #else
         if (ssl->options.sessionCacheOff == 1) {
             cacheOff = 1;
         }
 #endif
 
         /* if no session cache don't send a session ID unless we're echoing
          * an ID as part of session tickets */
         if (echoId == 0 && cacheOff == 1) {
             length -= ID_LEN;    /* adjust ID_LEN assumption */
             sessIdSz = 0;
         }
 
         sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
         #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             /* Server Hello should use the same sequence number as the
              * Client Hello. */
             ssl->keys.dtls_sequence_number_hi = ssl->keys.curSeq_hi;
             ssl->keys.dtls_sequence_number_lo = ssl->keys.curSeq_lo;
             idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
         }
         #endif /* WOLFSSL_DTLS */
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, length, server_hello, ssl);
 
         /* now write to output */
         /* first version */
         output[idx++] = (byte)ssl->version.major;
         output[idx++] = (byte)ssl->version.minor;
 
         /* then random and session id */
         if (!ssl->options.resuming) {
             /* generate random part and session id */
             ret = wc_RNG_GenerateBlock(ssl->rng, output + idx,
                 RAN_LEN + sizeof(sessIdSz) + sessIdSz);
             if (ret != 0)
                 return ret;
 
 #ifdef WOLFSSL_TLS13
             if (TLSv1_3_Capable(ssl)) {
                 /* TLS v1.3 capable server downgraded. */
                 XMEMCPY(output + idx + RAN_LEN - (TLS13_DOWNGRADE_SZ + 1),
                         tls13Downgrade, TLS13_DOWNGRADE_SZ);
                 output[idx + RAN_LEN - 1] = (byte)IsAtLeastTLSv1_2(ssl);
             }
             else
 #endif
             if (ssl->ctx->method->version.major == SSLv3_MAJOR &&
                           ssl->ctx->method->version.minor == TLSv1_2_MINOR &&
 #ifdef OPENSSL_EXTRA
                           (wolfSSL_get_options(ssl) & SSL_OP_NO_TLSv1_2) == 0 &&
 #endif
                                                        !IsAtLeastTLSv1_2(ssl)) {
                 /* TLS v1.2 capable server downgraded. */
                 XMEMCPY(output + idx + RAN_LEN - (TLS13_DOWNGRADE_SZ + 1),
                         tls13Downgrade, TLS13_DOWNGRADE_SZ);
                 output[idx + RAN_LEN - 1] = 0;
             }
 
             /* store info in SSL for later */
             XMEMCPY(ssl->arrays->serverRandom, output + idx, RAN_LEN);
             idx += RAN_LEN;
             output[idx++] = sessIdSz;
             XMEMCPY(ssl->arrays->sessionID, output + idx, sessIdSz);
             ssl->arrays->sessionIDSz = sessIdSz;
         }
         else {
             /* If resuming, use info from SSL */
             XMEMCPY(output + idx, ssl->arrays->serverRandom, RAN_LEN);
             idx += RAN_LEN;
             output[idx++] = sessIdSz;
             XMEMCPY(output + idx, ssl->arrays->sessionID, sessIdSz);
         }
         idx += sessIdSz;
 
 #ifdef SHOW_SECRETS
         {
             int j;
             printf("server random: ");
             for (j = 0; j < RAN_LEN; j++)
                 printf("%02x", ssl->arrays->serverRandom[j]);
             printf("\n");
         }
 #endif
 
         /* then cipher suite */
         output[idx++] = ssl->options.cipherSuite0;
         output[idx++] = ssl->options.cipherSuite;
 
         /* then compression */
         if (ssl->options.usingCompression)
             output[idx++] = ZLIB_COMPRESSION;
         else
             output[idx++] = NO_COMPRESSION;
 
         /* last, extensions */
 #ifdef HAVE_TLS_EXTENSIONS
         {
             word16 offset = 0;
             ret = TLSX_WriteResponse(ssl, output + idx, server_hello, &offset);
             if (ret != 0)
                 return ret;
             idx += offset;
         }
 #else
 #ifdef HAVE_EXTENDED_MASTER
         if (ssl->options.haveEMS) {
             c16toa(HELLO_EXT_SZ, output + idx);
             idx += HELLO_EXT_SZ_SZ;
 
             c16toa(HELLO_EXT_EXTMS, output + idx);
             idx += HELLO_EXT_TYPE_SZ;
             c16toa(0, output + idx);
             /*idx += HELLO_EXT_SZ_SZ;*/
             /* idx is not used after this point. uncomment the line above
              * if adding any more extensions in the future. */
         }
 #endif
 #endif
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, server_hello)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, server_hello)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ServerHello");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "ServerHello", handshake, output, sendSz,
                           WRITE_PROTO, ssl->heap);
     #endif
 
         ssl->options.serverState = SERVER_HELLO_COMPLETE;
         ssl->buffers.outputBuffer.length += sendSz;
 
         if (ssl->options.groupMessages)
             ret = 0;
         else
             ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendServerHello", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_SEND);
 
         return ret;
     }
 
 
 #if defined(HAVE_ECC)
 
     static byte SetCurveId(ecc_key* key)
     {
         if (key == NULL || key->dp == NULL) {
             WOLFSSL_MSG("SetCurveId: Invalid key!");
             return 0;
         }
 
         return (byte)GetCurveByOID(key->dp->oidSum);
     }
 
 #endif /* HAVE_ECC */
 
     typedef struct SskeArgs {
         byte*  output; /* not allocated */
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                                                 !defined(NO_RSA)
         byte*  sigDataBuf;
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         byte*  exportBuf;
     #endif
     #ifndef NO_RSA
         byte*  verifySig;
     #endif
         byte*  input;
         word32 idx;
         word32 tmpSigSz;
         word32 length;
         word32 sigSz;
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                                                 !defined(NO_RSA)
         word32 sigDataSz;
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         word32 exportSz;
     #endif
     #ifdef HAVE_QSH
         word32 qshSz;
     #endif
         int    sendSz;
         int    inputSz;
     } SskeArgs;
 
     static void FreeSskeArgs(WOLFSSL* ssl, void* pArgs)
     {
         SskeArgs* args = (SskeArgs*)pArgs;
 
         (void)ssl;
 
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         if (args->exportBuf) {
             XFREE(args->exportBuf, ssl->heap, DYNAMIC_TYPE_DER);
             args->exportBuf = NULL;
         }
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                            (!defined(NO_DH) && !defined(NO_RSA))
         if (args->sigDataBuf) {
             XFREE(args->sigDataBuf, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
             args->sigDataBuf = NULL;
         }
     #endif
     #ifndef NO_RSA
         if (args->verifySig) {
             XFREE(args->verifySig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
             args->verifySig = NULL;
         }
     #endif
         (void)args;
     }
 
     /* handle generation of server_key_exchange (12) */
     int SendServerKeyExchange(WOLFSSL* ssl)
     {
         int ret;
     #ifdef WOLFSSL_ASYNC_CRYPT
         SskeArgs* args = (SskeArgs*)ssl->async.args;
         typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
         (void)sizeof(args_test);
     #else
         SskeArgs  args[1];
     #endif
 
         WOLFSSL_START(WC_FUNC_SERVER_KEY_EXCHANGE_SEND);
         WOLFSSL_ENTER("SendServerKeyExchange");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NOT_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_sske;
         }
         else
     #endif
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(SskeArgs));
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async.freeArgs = FreeSskeArgs;
         #endif
         }
 
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
             #ifdef HAVE_QSH
                 if (ssl->peerQSHKeyPresent && ssl->options.haveQSH) {
                     args->qshSz = QSH_KeyGetSize(ssl);
                 }
             #endif
 
                 /* Do some checks / debug msgs */
                 switch(ssl->specs.kea)
                 {
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         WOLFSSL_MSG("Using ephemeral ECDH PSK");
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC)
                     case ecc_diffie_hellman_kea:
                     {
                         if (ssl->specs.static_ecdh) {
                             WOLFSSL_MSG("Using Static ECDH, not sending "
                                         "ServerKeyExchange");
                             ERROR_OUT(0, exit_sske);
                         }
 
                         WOLFSSL_MSG("Using ephemeral ECDH");
                         break;
                     }
                 #endif /* HAVE_ECC */
                 }
 
                 /* Preparing keys */
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && (!defined(NO_PSK) || !defined(NO_RSA))
                 #if !defined(NO_PSK)
                     case dhe_psk_kea:
                 #endif
                 #if !defined(NO_RSA)
                     case diffie_hellman_kea:
                 #endif
                     {
                         /* Allocate DH key buffers and generate key */
                         if (ssl->buffers.serverDH_P.buffer == NULL ||
                             ssl->buffers.serverDH_G.buffer == NULL) {
                             ERROR_OUT(NO_DH_PARAMS, exit_sske);
                         }
 
                         if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and FreeHandshakeResources */
                             ssl->buffers.serverDH_Pub.buffer = (byte*)XMALLOC(
                                     ssl->buffers.serverDH_P.length + OPAQUE16_LEN,
                                     ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
                             if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
                         }
 
                         if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and FreeHandshakeResources */
                             ssl->buffers.serverDH_Priv.buffer = (byte*)XMALLOC(
                                     ssl->buffers.serverDH_P.length + OPAQUE16_LEN,
                                     ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
                             if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
                         }
 
                         ssl->options.dhKeySz =
                                 (word16)ssl->buffers.serverDH_P.length;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_sske;
                         }
 
                         #if !defined(WOLFSSL_OLD_PRIME_CHECK) && \
                             !defined(HAVE_FIPS) && \
                             !defined(HAVE_SELFTEST)
                         if (ssl->options.dhDoKeyTest &&
                             !ssl->options.dhKeyTested)
                         {
                             ret = wc_DhSetCheckKey(
                                 ssl->buffers.serverDH_Key,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length,
                                 NULL, 0, 0, ssl->rng);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                             ssl->options.dhKeyTested = 1;
                         }
                         else
                         #endif
                         {
                             ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         ret = DhGenKeyPair(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             (word32*)&ssl->buffers.serverDH_Priv.length,
                             ssl->buffers.serverDH_Pub.buffer,
                             (word32*)&ssl->buffers.serverDH_Pub.length);
                         break;
                     }
                 #endif /* !NO_DH && (!NO_PSK || !NO_RSA) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                         /* Fall through to create temp ECC key */
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             /* need ephemeral key now, create it if missing */
                             if (ssl->eccTempKey == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->eccTempKey);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 ret = X25519MakeKey(ssl,
                                         (curve25519_key*)ssl->eccTempKey, NULL);
                                 if (ret == 0 || ret == WC_PENDING_E) {
                                     ssl->eccTempKeyPresent =
                                         DYNAMIC_TYPE_CURVE25519;
                                 }
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             /* need ephemeral key now, create it if missing */
                             if (ssl->eccTempKey == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->eccTempKey);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 ret = X448MakeKey(ssl,
                                           (curve448_key*)ssl->eccTempKey, NULL);
                                 if (ret == 0 || ret == WC_PENDING_E) {
                                     ssl->eccTempKeyPresent =
                                         DYNAMIC_TYPE_CURVE448;
                                 }
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_ECC
                         /* need ephemeral key now, create it if missing */
                         if (ssl->eccTempKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->eccTempKey);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         if (ssl->eccTempKeyPresent == 0) {
                             ret = EccMakeKey(ssl, ssl->eccTempKey, NULL);
                             if (ret == 0 || ret == WC_PENDING_E) {
                                 ssl->eccTempKeyPresent = DYNAMIC_TYPE_ECC;
                             }
                         }
                     #endif
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                     default:
                         /* Skip ServerKeyExchange */
                         goto exit_sske;
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* case TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
             #if (!defined(NO_DH) && !defined(NO_RSA)) || (defined(HAVE_ECC) || \
                              defined(HAVE_CURVE25519) || defined(HAVE_CURVE448))
                 word32 preSigSz, preSigIdx;
             #endif
 
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
 
                         if (ssl->arrays->server_hint[0] == 0) {
                             ERROR_OUT(0, exit_sske); /* don't send */
                         }
 
                         /* include size part */
                         args->length = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (args->length > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
 
                         args->length += HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
 
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* key data */
                     #ifdef HAVE_QSH
                         c16toa((word16)(args->length - args->qshSz -
                                         HINT_LEN_SZ), args->output + args->idx);
                     #else
                         c16toa((word16)(args->length - HINT_LEN_SZ),
                                                       args->output + args->idx);
                     #endif
 
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->arrays->server_hint,
                                 args->length - HINT_LEN_SZ);
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         word32 hintLen;
 
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = LENGTH_SZ * 3 + /* p, g, pub */
                                  ssl->buffers.serverDH_P.length +
                                  ssl->buffers.serverDH_G.length +
                                  ssl->buffers.serverDH_Pub.length;
 
                         /* include size part */
                         hintLen = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (hintLen > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
                         args->length += hintLen + HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* key data */
                         c16toa((word16)hintLen, args->output + args->idx);
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                             ssl->arrays->server_hint, hintLen);
                         args->idx += hintLen;
 
                         /* add p, g, pub */
                         c16toa((word16)ssl->buffers.serverDH_P.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length);
                         args->idx += ssl->buffers.serverDH_P.length;
 
                         /*  g */
                         c16toa((word16)ssl->buffers.serverDH_G.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length);
                         args->idx += ssl->buffers.serverDH_G.length;
 
                         /*  pub */
                         c16toa((word16)ssl->buffers.serverDH_Pub.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_Pub.buffer,
                                 ssl->buffers.serverDH_Pub.length);
                         /* No need to update idx, since sizes are already set */
                         /* args->idx += ssl->buffers.serverDH_Pub.length; */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         word32 hintLen;
 
                         /* curve type, named curve, length(1) */
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;
 
                         args->exportSz = MAX_EXPORT_ECC_SZ;
                         args->exportBuf = (byte*)XMALLOC(args->exportSz,
                                             ssl->heap, DYNAMIC_TYPE_DER);
                         if (args->exportBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             if (wc_curve25519_export_public_ex(
                                     (curve25519_key*)ssl->eccTempKey,
                                     args->exportBuf, &args->exportSz,
                                     EC25519_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             if (wc_curve448_export_public_ex(
                                     (curve448_key*)ssl->eccTempKey,
                                     args->exportBuf, &args->exportSz,
                                     EC448_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                         {
                             if (wc_ecc_export_x963(ssl->eccTempKey,
                                        args->exportBuf, &args->exportSz) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         args->length += args->exportSz;
 
                         /* include size part */
                         hintLen = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (hintLen > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
                         args->length += hintLen + HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         /* key data */
                         c16toa((word16)hintLen, args->output + args->idx);
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                             ssl->arrays->server_hint, hintLen);
                         args->idx += hintLen;
 
                         /* ECC key exchange data */
                         args->output[args->idx++] = named_curve;
                         args->output[args->idx++] = 0x00;          /* leading zero */
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X25519;
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X448;
                         else
                     #endif
                         {
                     #ifdef HAVE_ECC
                             args->output[args->idx++] =
                                                     SetCurveId(ssl->eccTempKey);
                     #endif
                         }
                         args->output[args->idx++] = (byte)args->exportSz;
                         XMEMCPY(args->output + args->idx, args->exportBuf,
                                                                 args->exportSz);
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         enum wc_HashType hashType;
 
                         /* curve type, named curve, length(1) */
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;
 
                         /* Export temp ECC key and add to length */
                         args->exportSz = MAX_EXPORT_ECC_SZ;
                         args->exportBuf = (byte*)XMALLOC(args->exportSz,
                                             ssl->heap, DYNAMIC_TYPE_DER);
                         if (args->exportBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             if (wc_curve25519_export_public_ex(
                                         (curve25519_key*)ssl->eccTempKey,
                                         args->exportBuf, &args->exportSz,
                                         EC25519_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             if (wc_curve448_export_public_ex(
                                         (curve448_key*)ssl->eccTempKey,
                                         args->exportBuf, &args->exportSz,
                                         EC448_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                         {
                     #if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)
                             if (wc_ecc_export_x963(ssl->eccTempKey,
                                        args->exportBuf, &args->exportSz) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                      #endif
                         }
                         args->length += args->exportSz;
 
                         preSigSz  = args->length;
                         preSigIdx = args->idx;
 
                         if (ssl->buffers.key == NULL) {
                         #ifdef HAVE_PK_CALLBACKS
                             if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)) {
                                 args->tmpSigSz = GetPrivateKeySigSize(ssl);
                                 if (args->tmpSigSz == 0) {
                                     ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                                 }
                             }
                             else
                         #endif
                                 ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                         }
                         else {
                             switch(ssl->suites->sigAlgo) {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = rsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 args->tmpSigSz = (word32)keySz;
                                 break;
                             }
                         #endif /* !NO_RSA */
                         #ifdef HAVE_ECC
                             case ecc_dsa_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ecc_dsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                                 /* worst case estimate */
                                 args->tmpSigSz = keySz;
                                 break;
                             }
                         #endif
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ed25519_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 /* worst case estimate */
                                 args->tmpSigSz = ED25519_SIG_SIZE;
                                 break;
                             }
                         #endif /* HAVE_ED25519 */
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ed448_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 /* worst case estimate */
                                 args->tmpSigSz = ED448_SIG_SIZE;
                                 break;
                             }
                         #endif /* HAVE_ED448 */
                             default:
                                 ERROR_OUT(ALGO_ID_E, exit_sske);  /* unsupported type */
                             } /* switch(ssl->specs.sig_algo) */
                         }
 
                         /* sig length */
                         args->length += LENGTH_SZ;
                         args->length += args->tmpSigSz;
 
                         if (IsAtLeastTLSv1_2(ssl)) {
                             args->length += HASH_SIG_SIZE;
                         }
 
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             preSigIdx = args->idx;
                         }
                     #endif
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         /* record and message headers will be added below, when we're sure
                            of the sig length */
 
                         /* key exchange data */
                         args->output[args->idx++] = named_curve;
                         args->output[args->idx++] = 0x00;          /* leading zero */
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X25519;
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X448;
                         else
                     #endif
                         {
                     #ifdef HAVE_ECC
                             args->output[args->idx++] =
                                                     SetCurveId(ssl->eccTempKey);
                     #endif
                         }
                         args->output[args->idx++] = (byte)args->exportSz;
                         XMEMCPY(args->output + args->idx, args->exportBuf, args->exportSz);
                         args->idx += args->exportSz;
 
                         /* Determine hash type */
                         if (IsAtLeastTLSv1_2(ssl)) {
                             EncodeSigAlg(ssl->suites->hashAlgo,
                                          ssl->suites->sigAlgo,
                                          &args->output[args->idx]);
                             args->idx += 2;
 
                             hashType = HashAlgoToType(ssl->suites->hashAlgo);
                             if (hashType == WC_HASH_TYPE_NONE) {
                                 ERROR_OUT(ALGO_ID_E, exit_sske);
                             }
 
                         } else {
                             /* only using sha and md5 for rsa */
                         #ifndef NO_OLD_TLS
                             hashType = WC_HASH_TYPE_SHA;
                             if (ssl->suites->sigAlgo == rsa_sa_algo) {
                                 hashType = WC_HASH_TYPE_MD5_SHA;
                             }
                         #else
                             ERROR_OUT(ALGO_ID_E, exit_sske);
                         #endif
                         }
 
                         /* Signature length will be written later, when we're sure what it is */
 
                     #ifdef HAVE_FUZZER
                         if (ssl->fuzzerCb) {
                             ssl->fuzzerCb(ssl, args->output + preSigIdx,
                                 preSigSz, FUZZ_SIGNATURE, ssl->fuzzerCtx);
                         }
                     #endif
 
                         /* Assemble buffer to hash for signature */
                         args->sigDataSz = RAN_LEN + RAN_LEN + preSigSz;
                         args->sigDataBuf = (byte*)XMALLOC(args->sigDataSz,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                         if (args->sigDataBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                         XMEMCPY(args->sigDataBuf, ssl->arrays->clientRandom,
                                                                        RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN,
                                             ssl->arrays->serverRandom, RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN+RAN_LEN,
                                 args->output + preSigIdx, preSigSz);
 
                         if (ssl->suites->sigAlgo != ed25519_sa_algo &&
                                         ssl->suites->sigAlgo != ed448_sa_algo) {
                             ssl->buffers.sig.length =
                                                  wc_HashGetDigestSize(hashType);
                             if ((int)ssl->buffers.sig.length < 0) {
                                 ERROR_OUT(HASH_TYPE_E, exit_sske);
                             }
                             ssl->buffers.sig.buffer = (byte*)XMALLOC(
                                             ssl->buffers.sig.length,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                             if (ssl->buffers.sig.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
 
                             /* Perform hash */
                             ret = wc_Hash(hashType, args->sigDataBuf,
                                                        args->sigDataSz,
                                                        ssl->buffers.sig.buffer,
                                                        ssl->buffers.sig.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         args->sigSz = args->tmpSigSz;
 
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                             case rsa_sa_algo:
                             {
                                 /* For TLS 1.2 re-encode signature */
                                 if (IsAtLeastTLSv1_2(ssl)) {
                                     byte* encodedSig = (byte*)XMALLOC(
                                                   MAX_ENCODED_SIG_SZ, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     if (encodedSig == NULL) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
 
                                     ssl->buffers.sig.length =
                                         wc_EncodeSignature(encodedSig,
                                             ssl->buffers.sig.buffer,
                                             ssl->buffers.sig.length,
                                             TypeHash(ssl->suites->hashAlgo));
 
                                     /* Replace sig buffer with new one */
                                     XFREE(ssl->buffers.sig.buffer, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     ssl->buffers.sig.buffer = encodedSig;
                                 }
 
                                 /* write sig size here */
                                 c16toa((word16)args->sigSz,
                                     args->output + args->idx);
                                 args->idx += LENGTH_SZ;
                                 break;
                             }
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                                 /* write sig size here */
                                 c16toa((word16)args->sigSz,
                                     args->output + args->idx);
                                 args->idx += LENGTH_SZ;
                                 break;
                         #endif
                         #endif /* !NO_RSA */
                             case ecc_dsa_sa_algo:
                             {
                                 break;
                             }
                         #ifdef  HAVE_ED25519
                             case ed25519_sa_algo:
                                 ret = Ed25519CheckPubKey(ssl);
                                 if (ret != 0)
                                     goto exit_sske;
                                 break;
                         #endif /* HAVE_ED25519 */
                         #ifdef  HAVE_ED448
                             case ed448_sa_algo:
                                 ret = Ed448CheckPubKey(ssl);
                                 if (ret != 0)
                                     goto exit_sske;
                                 break;
                         #endif /* HAVE_ED448 */
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         enum wc_HashType hashType;
 
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = LENGTH_SZ * 3;  /* p, g, pub */
                         args->length += ssl->buffers.serverDH_P.length +
                                         ssl->buffers.serverDH_G.length +
                                         ssl->buffers.serverDH_Pub.length;
 
                         preSigIdx = args->idx;
                         preSigSz  = args->length;
 
                         if (!ssl->options.usingAnon_cipher) {
                             word16 keySz;
 
                             /* sig length */
                             args->length += LENGTH_SZ;
 
                             if (ssl->buffers.key == NULL) {
                             #ifdef HAVE_PK_CALLBACKS
                                 if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx))
                                     keySz = (word32)GetPrivateKeySigSize(ssl);
                                 else
                             #endif
                                     ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                             }
                             else
                             {
                                 if (ssl->buffers.keyType == 0)
                                     ssl->buffers.keyType = rsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (keySz == 0) { /* test if keySz has error */
                                 ERROR_OUT(keySz, exit_sske);
                             }
 
                             args->tmpSigSz = (word32)keySz;
                             args->length += args->tmpSigSz;
 
                             if (IsAtLeastTLSv1_2(ssl)) {
                                 args->length += HASH_SIG_SIZE;
                             }
                         }
 
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef HAVE_QSH
                         args->length += args->qshSz;
                         args->sendSz += args->qshSz;
                     #endif
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             preSigIdx = args->idx;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* check for available size */
                         if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0) {
                             goto exit_sske;
                         }
 
                         /* get output buffer */
                         args->output = ssl->buffers.outputBuffer.buffer +
                                        ssl->buffers.outputBuffer.length;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* add p, g, pub */
                         c16toa((word16)ssl->buffers.serverDH_P.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_P.buffer,
                                               ssl->buffers.serverDH_P.length);
                         args->idx += ssl->buffers.serverDH_P.length;
 
                         /*  g */
                         c16toa((word16)ssl->buffers.serverDH_G.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_G.buffer,
                                               ssl->buffers.serverDH_G.length);
                         args->idx += ssl->buffers.serverDH_G.length;
 
                         /*  pub */
                         c16toa((word16)ssl->buffers.serverDH_Pub.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_Pub.buffer,
                                               ssl->buffers.serverDH_Pub.length);
                         args->idx += ssl->buffers.serverDH_Pub.length;
 
                     #ifdef HAVE_FUZZER
                         if (ssl->fuzzerCb) {
                             ssl->fuzzerCb(ssl, args->output + preSigIdx,
                                 preSigSz, FUZZ_SIGNATURE, ssl->fuzzerCtx);
                         }
                     #endif
 
                         if (ssl->options.usingAnon_cipher) {
                             break;
                         }
 
                         /* Determine hash type */
                         if (IsAtLeastTLSv1_2(ssl)) {
                             EncodeSigAlg(ssl->suites->hashAlgo,
                                          ssl->suites->sigAlgo,
                                          &args->output[args->idx]);
                             args->idx += 2;
 
                             hashType = HashAlgoToType(ssl->suites->hashAlgo);
                             if (hashType == WC_HASH_TYPE_NONE) {
                                 ERROR_OUT(ALGO_ID_E, exit_sske);
                             }
                         } else {
                             /* only using sha and md5 for rsa */
                         #ifndef NO_OLD_TLS
                             hashType = WC_HASH_TYPE_SHA;
                             if (ssl->suites->sigAlgo == rsa_sa_algo) {
                                 hashType = WC_HASH_TYPE_MD5_SHA;
                             }
                         #else
                             ERROR_OUT(ALGO_ID_E, exit_sske);
                         #endif
                         }
 
                         /* signature size */
                         c16toa((word16)args->tmpSigSz, args->output + args->idx);
                         args->idx += LENGTH_SZ;
 
                         /* Assemble buffer to hash for signature */
                         args->sigDataSz = RAN_LEN + RAN_LEN + preSigSz;
                         args->sigDataBuf = (byte*)XMALLOC(args->sigDataSz,
                                             ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                         if (args->sigDataBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                         XMEMCPY(args->sigDataBuf, ssl->arrays->clientRandom,
                                                                     RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN,
                                         ssl->arrays->serverRandom, RAN_LEN);
                         XMEMCPY(args->sigDataBuf+RAN_LEN+RAN_LEN,
                             args->output + preSigIdx, preSigSz);
 
                         if (ssl->suites->sigAlgo != ed25519_sa_algo &&
                                         ssl->suites->sigAlgo != ed448_sa_algo) {
                             ssl->buffers.sig.length =
                                                  wc_HashGetDigestSize(hashType);
                             ssl->buffers.sig.buffer = (byte*)XMALLOC(
                                              ssl->buffers.sig.length, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                             if (ssl->buffers.sig.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
 
                             /* Perform hash */
                             ret = wc_Hash(hashType, args->sigDataBuf,
                                                        args->sigDataSz,
                                                        ssl->buffers.sig.buffer,
                                                        ssl->buffers.sig.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         args->sigSz = args->tmpSigSz;
 
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                             case rsa_sa_algo:
                             {
                                 /* For TLS 1.2 re-encode signature */
                                 if (IsAtLeastTLSv1_2(ssl)) {
                                     byte* encodedSig = (byte*)XMALLOC(
                                                   MAX_ENCODED_SIG_SZ, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     if (encodedSig == NULL) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
 
                                     ssl->buffers.sig.length =
                                         wc_EncodeSignature(encodedSig,
                                             ssl->buffers.sig.buffer,
                                             ssl->buffers.sig.length,
                                             TypeHash(ssl->suites->hashAlgo));
 
                                     /* Replace sig buffer with new one */
                                     XFREE(ssl->buffers.sig.buffer, ssl->heap,
                                                        DYNAMIC_TYPE_SIGNATURE);
                                     ssl->buffers.sig.buffer = encodedSig;
                                 }
                                 break;
                             }
                         #endif /* NO_RSA */
                         } /* switch (ssl->suites->sigAlgo) */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* case TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC)  || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 ret = RsaSign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + args->idx,
                                     &args->sigSz,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key,
                                     ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif /* !NO_RSA */
                         #ifdef HAVE_ECC
                             case ecc_dsa_sa_algo:
                             {
                                 ecc_key* key = (ecc_key*)ssl->hsKey;
 
                                 ret = EccSign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif /* HAVE_ECC */
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                             {
                                 ed25519_key* key = (ed25519_key*)ssl->hsKey;
 
                                 ret = Ed25519Sign(ssl,
                                     args->sigDataBuf, args->sigDataSz,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                             {
                                 ed448_key* key = (ed448_key*)ssl->hsKey;
 
                                 ret = Ed448Sign(ssl,
                                     args->sigDataBuf, args->sigDataSz,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         /* Sign hash to create signature */
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (ssl->options.usingAnon_cipher) {
                                     break;
                                 }
 
                                 ret = RsaSign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + args->idx,
                                     &args->sigSz,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key,
                                     ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif /* NO_RSA */
                         } /* switch (ssl->suites->sigAlgo) */
 
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* case TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) ||  \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         switch(ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (args->verifySig == NULL) {
                                     if (args->sigSz == 0) {
                                         ERROR_OUT(BAD_COND_E, exit_sske);
                                     }
                                     args->verifySig = (byte*)XMALLOC(
                                                     args->sigSz, ssl->heap,
                                                     DYNAMIC_TYPE_SIGNATURE);
                                     if (!args->verifySig) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
                                     XMEMCPY(args->verifySig,
                                         args->output + args->idx, args->sigSz);
                                 }
 
                                 /* check for signature faults */
                                 ret = VerifyRsaSign(ssl,
                                     args->verifySig, args->sigSz,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key, ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif
                             case ecc_dsa_sa_algo:
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                         #endif
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                         #endif
                             {
                                 /* Now that we know the real sig size, write it. */
                                 c16toa((word16)args->sigSz,
                                                     args->output + args->idx);
 
                                 /* And adjust length and sendSz from estimates */
                                 args->length += args->sigSz - args->tmpSigSz;
                                 args->sendSz += args->sigSz - args->tmpSigSz;
                                 break;
                             }
                             default:
                                 ERROR_OUT(ALGO_ID_E, exit_sske);  /* unsupported type */
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         switch (ssl->suites->sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifndef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (ssl->options.usingAnon_cipher) {
                                     break;
                                 }
 
                                 if (args->verifySig == NULL) {
                                     if (args->sigSz == 0) {
                                         ERROR_OUT(BAD_COND_E, exit_sske);
                                     }
                                     args->verifySig = (byte*)XMALLOC(
                                                       args->sigSz, ssl->heap,
                                                       DYNAMIC_TYPE_SIGNATURE);
                                     if (!args->verifySig) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
                                     XMEMCPY(args->verifySig,
                                         args->output + args->idx, args->sigSz);
                                 }
 
                                 /* check for signature faults */
                                 ret = VerifyRsaSign(ssl,
                                     args->verifySig, args->sigSz,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     ssl->suites->sigAlgo, ssl->suites->hashAlgo,
                                     key, ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif
                         } /* switch (ssl->suites->sigAlgo) */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* case TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
             #ifdef HAVE_QSH
                 if (ssl->peerQSHKeyPresent) {
                     if (args->qshSz > 0) {
                         args->idx = args->sendSz - args->qshSz;
                         if (QSH_KeyExchangeWrite(ssl, 1) != 0) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
 
                         /* extension type */
                         c16toa(TLSX_QUANTUM_SAFE_HYBRID,
                                                     args->output + args->idx);
                         args->idx += OPAQUE16_LEN;
 
                         /* write to output and check amount written */
                         if (TLSX_QSHPK_Write(ssl->QSH_secret->list,
                             args->output + args->idx) >
                                                 args->qshSz - OPAQUE16_LEN) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     }
                 }
             #endif
 
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 if (ssl->specs.kea == ecdhe_psk_kea ||
                     ssl->specs.kea == ecc_diffie_hellman_kea) {
                     /* Check output to make sure it was set */
                     if (args->output) {
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
                     }
                     else {
                         ERROR_OUT(BUFFER_ERROR, exit_sske);
                     }
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 if (IsEncryptionOn(ssl, 1)) {
                     args->inputSz = args->length + HANDSHAKE_HEADER_SZ;
                     if (ssl->options.dtls)
                         args->inputSz += DTLS_HANDSHAKE_EXTRA;
                     args->input = (byte*)XMALLOC(args->inputSz, ssl->heap,
                                                         DYNAMIC_TYPE_IN_BUFFER);
                     if (args->input == NULL) {
                         ERROR_OUT(MEMORY_E, exit_sske);
                     }
 
                     if (args->output == NULL) {
                         ERROR_OUT(BUFFER_ERROR, exit_sske);
                     }
 
                     if (!ssl->options.dtls)
                         XMEMCPY(args->input, args->output + RECORD_HEADER_SZ,
                                                                  args->inputSz);
                     else
                         XMEMCPY(args->input, args->output + DTLS_RECORD_HEADER_SZ,
                                                                  args->inputSz);
 
                     #ifdef WOLFSSL_DTLS
                     if (IsDtlsNotSctpMode(ssl) &&
                         (ret = DtlsMsgPoolSave(ssl, args->input, args->inputSz, server_key_exchange))
                             != 0) {
                         goto exit_sske;
                     }
                     #endif
                     ret = BuildMessage(ssl, args->output, args->sendSz,
                                 args->input, args->inputSz, handshake, 1, 0, 0, CUR_ORDER);
                     XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                     args->input = NULL;
                         /* make sure its not double free'd on cleanup */
 
                     if (ret >= 0) {
                         args->sendSz = ret;
                         ret = 0;
                     }
                 }
                 else {
                 #ifdef WOLFSSL_DTLS
                     if (IsDtlsNotSctpMode(ssl)) {
                         if ((ret = DtlsMsgPoolSave(ssl,
                                             args->output, args->sendSz, server_key_exchange)) != 0) {
                             goto exit_sske;
                         }
                     }
 
                     if (ssl->options.dtls)
                         DtlsSEQIncrement(ssl, CUR_ORDER);
                 #endif
 
                     ret = HashOutput(ssl, args->output, args->sendSz, 0);
                     if (ret != 0) {
                         goto exit_sske;
                     }
                 }
 
             #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
                 if (ssl->hsInfoOn) {
                     AddPacketName(ssl, "ServerKeyExchange");
                 }
                 if (ssl->toInfoOn) {
                     AddPacketInfo(ssl, "ServerKeyExchange", handshake,
                         args->output, args->sendSz, WRITE_PROTO, ssl->heap);
                 }
             #endif
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* case TLS_ASYNC_FINALIZE */
             FALL_THROUGH;
 
             case TLS_ASYNC_END:
             {
                 ssl->buffers.outputBuffer.length += args->sendSz;
                 if (!ssl->options.groupMessages) {
                     ret = SendBuffered(ssl);
                 }
 
                 ssl->options.serverState = SERVER_KEYEXCHANGE_COMPLETE;
                 break;
             }
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_sske:
 
         WOLFSSL_LEAVE("SendServerKeyExchange", ret);
         WOLFSSL_END(WC_FUNC_SERVER_KEY_EXCHANGE_SEND);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E)
             return ret;
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
         /* Final cleanup */
         FreeSskeArgs(ssl, args);
         FreeKeyExchange(ssl);
 
         return ret;
     }
 
 #if defined(HAVE_SERVER_RENEGOTIATION_INFO) || defined(HAVE_FALLBACK_SCSV) || \
                                                             defined(OPENSSL_ALL)
 
     /* search suites for specific one, idx on success, negative on error */
 #ifndef WOLFSSL_TLS13
     static
 #endif
     int FindSuite(Suites* suites, byte first, byte second)
     {
         int i;
 
         if (suites == NULL || suites->suiteSz == 0) {
             WOLFSSL_MSG("Suites pointer error or suiteSz 0");
             return SUITES_ERROR;
         }
 
         for (i = 0; i < suites->suiteSz-1; i += SUITE_LEN) {
             if (suites->suites[i]   == first &&
                 suites->suites[i+1] == second )
                 return i;
         }
 
         return MATCH_SUITE_ERROR;
     }
 
 #endif
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
     /* Make sure server cert/key are valid for this suite, true on success */
     static int VerifyServerSuite(WOLFSSL* ssl, word16 idx)
     {
         int  haveRSA = !ssl->options.haveStaticECC;
         int  havePSK = 0;
         byte first;
         byte second;
 
         WOLFSSL_ENTER("VerifyServerSuite");
 
         if (ssl->suites == NULL) {
             WOLFSSL_MSG("Suites pointer error");
             return 0;
         }
 
         first   = ssl->suites->suites[idx];
         second  = ssl->suites->suites[idx+1];
 
         #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
         #endif
 
         if (ssl->options.haveNTRU)
             haveRSA = 0;
 
         if (CipherRequires(first, second, REQUIRES_RSA)) {
             WOLFSSL_MSG("Requires RSA");
             if (haveRSA == 0) {
                 WOLFSSL_MSG("Don't have RSA");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_DHE)) {
             WOLFSSL_MSG("Requires DHE");
             if (ssl->options.haveDH == 0) {
                 WOLFSSL_MSG("Don't have DHE");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_ECC)) {
             WOLFSSL_MSG("Requires ECC");
             if (ssl->options.haveECC == 0) {
                 WOLFSSL_MSG("Don't have ECC");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_ECC_STATIC)) {
             WOLFSSL_MSG("Requires static ECC");
             if (ssl->options.haveStaticECC == 0) {
                 WOLFSSL_MSG("Don't have static ECC");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_PSK)) {
             WOLFSSL_MSG("Requires PSK");
             if (havePSK == 0) {
                 WOLFSSL_MSG("Don't have PSK");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_NTRU)) {
             WOLFSSL_MSG("Requires NTRU");
             if (ssl->options.haveNTRU == 0) {
                 WOLFSSL_MSG("Don't have NTRU");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_RSA_SIG)) {
             WOLFSSL_MSG("Requires RSA Signature");
             if (ssl->options.side == WOLFSSL_SERVER_END &&
                                            ssl->options.haveECDSAsig == 1) {
                 WOLFSSL_MSG("Don't have RSA Signature");
                 return 0;
             }
         }
 
 #if !defined(WOLFSSL_OLDTLS_AEAD_CIPHERSUITES)
         if (CipherRequires(first, second, REQUIRES_AEAD)) {
             WOLFSSL_MSG("Requires AEAD");
             if (ssl->version.major == SSLv3_MAJOR &&
                                            ssl->version.minor < TLSv1_2_MINOR) {
                 WOLFSSL_MSG("Version of SSL does not support AEAD ciphers");
                 return 0;
             }
 
         }
 #endif
 
 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                        defined(HAVE_CURVE448)) && defined(HAVE_SUPPORTED_CURVES)
         if (!TLSX_ValidateSupportedCurves(ssl, first, second)) {
             WOLFSSL_MSG("Don't have matching curves");
             return 0;
         }
 #endif
 
         /* ECCDHE is always supported if ECC on */
 
 #ifdef HAVE_QSH
         /* need to negotiate a classic suite in addition to TLS_QSH */
         if (first == QSH_BYTE && second == TLS_QSH) {
             if (TLSX_SupportExtensions(ssl)) {
                 ssl->options.haveQSH = 1; /* matched TLS_QSH */
             }
             else {
                 WOLFSSL_MSG("Version of SSL connection does not support "
                             "TLS_QSH");
             }
             return 0;
         }
 #endif
 
 #ifdef WOLFSSL_TLS13
         if (IsAtLeastTLSv1_3(ssl->version) &&
             ssl->options.side == WOLFSSL_SERVER_END) {
             /* Try to establish a key share. */
             int ret = TLSX_KeyShare_Establish(ssl);
             if (ret == KEY_SHARE_ERROR)
                 ssl->options.serverState = SERVER_HELLO_RETRY_REQUEST_COMPLETE;
             else if (ret != 0)
                 return 0;
         }
         else if (first == TLS13_BYTE || (first == ECC_BYTE &&
                 (second == TLS_SHA256_SHA256 || second == TLS_SHA384_SHA384))) {
             /* Can't negotiate TLS 1.3 cipher suites with lower protocol
              * version. */
             return 0;
         }
 #endif
 
         return 1;
     }
 
 #ifndef NO_WOLFSSL_SERVER
     static int CompareSuites(WOLFSSL* ssl, Suites* peerSuites, word16 i,
                              word16 j)
     {
         if (ssl->suites->suites[i]   == peerSuites->suites[j] &&
             ssl->suites->suites[i+1] == peerSuites->suites[j+1] ) {
 
             if (VerifyServerSuite(ssl, i)) {
                 int result;
                 WOLFSSL_MSG("Verified suite validity");
                 ssl->options.cipherSuite0 = ssl->suites->suites[i];
                 ssl->options.cipherSuite  = ssl->suites->suites[i+1];
                 result = SetCipherSpecs(ssl);
                 if (result == 0) {
                     result = PickHashSigAlgo(ssl, peerSuites->hashSigAlgo,
                                                      peerSuites->hashSigAlgoSz);
                 }
                 return result;
             }
             else {
                 WOLFSSL_MSG("Could not verify suite validity, continue");
             }
         }
 
         return MATCH_SUITE_ERROR;
     }
 
     int MatchSuite(WOLFSSL* ssl, Suites* peerSuites)
     {
         int ret;
         word16 i, j;
 
         WOLFSSL_ENTER("MatchSuite");
 
         /* & 0x1 equivalent % 2 */
         if (peerSuites->suiteSz == 0 || peerSuites->suiteSz & 0x1)
             return BUFFER_ERROR;
 
         if (ssl->suites == NULL)
             return SUITES_ERROR;
 
         if (!ssl->options.useClientOrder) {
             /* Server order */
             for (i = 0; i < ssl->suites->suiteSz; i += 2) {
                 for (j = 0; j < peerSuites->suiteSz; j += 2) {
                     ret = CompareSuites(ssl, peerSuites, i, j);
                     if (ret != MATCH_SUITE_ERROR)
                         return ret;
                 }
             }
         }
         else {
             /* Client order */
             for (j = 0; j < peerSuites->suiteSz; j += 2) {
                 for (i = 0; i < ssl->suites->suiteSz; i += 2) {
                     ret = CompareSuites(ssl, peerSuites, i, j);
                     if (ret != MATCH_SUITE_ERROR)
                         return ret;
                 }
             }
         }
 
         return MATCH_SUITE_ERROR;
     }
 #endif
 
 #ifdef OLD_HELLO_ALLOWED
 
     /* process old style client hello, deprecate? */
     int ProcessOldClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                               word32 inSz, word16 sz)
     {
         word32          idx = *inOutIdx;
         word16          sessionSz;
         word16          randomSz;
         word16          i, j;
         ProtocolVersion pv;
         Suites          clSuites;
         int ret = -1;
 
         (void)inSz;
         WOLFSSL_MSG("Got old format client hello");
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn)
             AddLateName("ClientHello", &ssl->timeoutInfo);
 #endif
 
         /* manually hash input since different format */
 #ifndef NO_OLD_TLS
 #ifndef NO_MD5
         wc_Md5Update(&ssl->hsHashes->hashMd5, input + idx, sz);
 #endif
 #ifndef NO_SHA
         wc_ShaUpdate(&ssl->hsHashes->hashSha, input + idx, sz);
 #endif
 #endif
 #ifndef NO_SHA256
         if (IsAtLeastTLSv1_2(ssl)) {
             int shaRet = wc_Sha256Update(&ssl->hsHashes->hashSha256,
                                          input + idx, sz);
             if (shaRet != 0)
                 return shaRet;
         }
 #endif
 
         /* does this value mean client_hello? */
         idx++;
 
         /* version */
         pv.major = input[idx++];
         pv.minor = input[idx++];
         ssl->chVersion = pv;  /* store */
 
         if (ssl->version.minor > pv.minor) {
             byte haveRSA = 0;
             byte havePSK = 0;
             int  keySz   = 0;
 
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 return VERSION_ERROR;
             }
             if (pv.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 return VERSION_ERROR;
             }
             if (pv.minor == SSLv3_MINOR) {
                 /* turn off tls */
                 WOLFSSL_MSG("\tdowngrading to SSLv3");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = SSLv3_MINOR;
             }
             else if (pv.minor == TLSv1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1");
                 /* turn off tls 1.1+ */
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = TLSv1_MINOR;
             }
             else if (pv.minor == TLSv1_1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                 ssl->version.minor  = TLSv1_1_MINOR;
             }
             else if (pv.minor == TLSv1_2_MINOR) {
                 WOLFSSL_MSG("    downgrading to TLSv1.2");
                 ssl->version.minor  = TLSv1_2_MINOR;
             }
 #ifndef NO_RSA
             haveRSA = 1;
 #endif
 #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
 #endif
 #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
 #endif
 
             InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveNTRU,
                        ssl->options.haveECDSAsig, ssl->options.haveECC,
                        ssl->options.haveStaticECC, ssl->options.side);
         }
 
         /* suite size */
         ato16(&input[idx], &clSuites.suiteSz);
         idx += OPAQUE16_LEN;
 
         if (clSuites.suiteSz > WOLFSSL_MAX_SUITE_SZ)
             return BUFFER_ERROR;
         /* Make sure the suiteSz is a multiple of 3. (Old Client Hello) */
         if (clSuites.suiteSz % 3 != 0)
             return BUFFER_ERROR;
         clSuites.hashSigAlgoSz = 0;
 
         /* session size */
         ato16(&input[idx], &sessionSz);
         idx += OPAQUE16_LEN;
 
         if (sessionSz > ID_LEN)
             return BUFFER_ERROR;
 
         /* random size */
         ato16(&input[idx], &randomSz);
         idx += OPAQUE16_LEN;
 
         if (randomSz > RAN_LEN)
             return BUFFER_ERROR;
 
         /* suites */
         for (i = 0, j = 0; i < clSuites.suiteSz; i += 3) {
             byte first = input[idx++];
             if (!first) { /* implicit: skip sslv2 type */
                 XMEMCPY(&clSuites.suites[j], &input[idx], SUITE_LEN);
                 j += SUITE_LEN;
             }
             idx += SUITE_LEN;
         }
         clSuites.suiteSz = j;
 
         /* session id */
         if (sessionSz) {
             XMEMCPY(ssl->arrays->sessionID, input + idx, sessionSz);
             ssl->arrays->sessionIDSz = (byte)sessionSz;
             idx += sessionSz;
             ssl->options.resuming = 1;
         }
 
         /* random */
         if (randomSz < RAN_LEN)
             XMEMSET(ssl->arrays->clientRandom, 0, RAN_LEN - randomSz);
         XMEMCPY(&ssl->arrays->clientRandom[RAN_LEN - randomSz], input + idx,
                randomSz);
         idx += randomSz;
 
         if (ssl->options.usingCompression)
             ssl->options.usingCompression = 0;  /* turn off */
 
         ssl->options.clientState = CLIENT_HELLO_COMPLETE;
         ssl->cbmode = SSL_CB_MODE_WRITE;
         *inOutIdx = idx;
 
         ssl->options.haveSessionId = 1;
         /* DoClientHello uses same resume code */
         if (ssl->options.resuming) {  /* let's try */
             WOLFSSL_SESSION* session = GetSession(ssl,
                                                   ssl->arrays->masterSecret, 1);
             #ifdef HAVE_SESSION_TICKET
                 if (ssl->options.useTicket == 1) {
                     session = &ssl->session;
                 }
             #endif
 
             if (!session) {
                 WOLFSSL_MSG("Session lookup for resume failed");
                 ssl->options.resuming = 0;
             } else {
             #ifdef HAVE_EXT_CACHE
                 wolfSSL_SESSION_free(session);
             #endif
                 if (MatchSuite(ssl, &clSuites) < 0) {
                     WOLFSSL_MSG("Unsupported cipher suite, OldClientHello");
                     return UNSUPPORTED_SUITE;
                 }
 
                 ret = wc_RNG_GenerateBlock(ssl->rng, ssl->arrays->serverRandom,
                                                                        RAN_LEN);
                 if (ret != 0)
                     return ret;
 
                 #ifdef NO_OLD_TLS
                     ret = DeriveTlsKeys(ssl);
                 #else
                     #ifndef NO_TLS
                         if (ssl->options.tls)
                             ret = DeriveTlsKeys(ssl);
                     #endif
                         if (!ssl->options.tls)
                             ret = DeriveKeys(ssl);
                 #endif
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
 
                 return ret;
             }
         }
 
         ret = MatchSuite(ssl, &clSuites);
         if (ret != 0)return ret;
         return SanityCheckMsgReceived(ssl, client_hello);
     }
 
 #endif /* OLD_HELLO_ALLOWED */
 
 #ifndef WOLFSSL_NO_TLS12
 
     int HandleTlsResumption(WOLFSSL* ssl, int bogusID, Suites* clSuites)
     {
         int ret = 0;
         WOLFSSL_SESSION* session;
 
         (void)bogusID;
 
         session = GetSession(ssl, ssl->arrays->masterSecret, 1);
         #ifdef HAVE_SESSION_TICKET
             if (ssl->options.useTicket == 1) {
                 session = &ssl->session;
             } else if (bogusID == 1 && ssl->options.rejectTicket == 0) {
                 WOLFSSL_MSG("Bogus session ID without session ticket");
                 return BUFFER_ERROR;
             }
         #endif
 
         if (!session) {
             WOLFSSL_MSG("Session lookup for resume failed");
             ssl->options.resuming = 0;
         }
         else if (session->haveEMS != ssl->options.haveEMS) {
             /* RFC 7627, 5.3, server-side */
             /* if old sess didn't have EMS, but new does, full handshake */
             if (!session->haveEMS && ssl->options.haveEMS) {
                 WOLFSSL_MSG("Attempting to resume a session that didn't "
                             "use EMS with a new session with EMS. Do full "
                             "handshake.");
                 ssl->options.resuming = 0;
             }
             /* if old sess used EMS, but new doesn't, MUST abort */
             else if (session->haveEMS && !ssl->options.haveEMS) {
                 WOLFSSL_MSG("Trying to resume a session with EMS without "
                             "using EMS");
             #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, handshake_failure);
             #endif
                 #ifdef HAVE_EXT_CACHE
                     wolfSSL_SESSION_free(session);
                 #endif
                 return EXT_MASTER_SECRET_NEEDED_E;
             }
         #ifdef HAVE_EXT_CACHE
             wolfSSL_SESSION_free(session);
         #endif
         }
         else {
         #ifndef NO_RESUME_SUITE_CHECK
             int j;
 
             /* Check client suites include the one in session */
             for (j = 0; j < clSuites->suiteSz; j += 2) {
                 if (clSuites->suites[j] == session->cipherSuite0 &&
                                 clSuites->suites[j+1] == session->cipherSuite) {
                     break;
                 }
             }
             if (j == clSuites->suiteSz) {
                 WOLFSSL_MSG("Prev session's cipher suite not in ClientHello");
             #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, illegal_parameter);
             #endif
                 return UNSUPPORTED_SUITE;
             }
         #endif
 
         #ifdef HAVE_EXT_CACHE
             wolfSSL_SESSION_free(session);
         #endif
             if (MatchSuite(ssl, clSuites) < 0) {
                 WOLFSSL_MSG("Unsupported cipher suite, ClientHello");
                 return UNSUPPORTED_SUITE;
             }
 
             ret = wc_RNG_GenerateBlock(ssl->rng, ssl->arrays->serverRandom,
                                                                        RAN_LEN);
             if (ret != 0)
                 return ret;
 
             #ifdef NO_OLD_TLS
                 ret = DeriveTlsKeys(ssl);
             #else
                 #ifndef NO_TLS
                     if (ssl->options.tls)
                         ret = DeriveTlsKeys(ssl);
                 #endif
                     if (!ssl->options.tls)
                         ret = DeriveKeys(ssl);
             #endif
             ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
         }
 
         return ret;
     }
 
 
     /* handle processing of client_hello (1) */
     int DoClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                              word32 helloSz)
     {
         byte            b;
         byte            bogusID = 0;   /* flag for a bogus session id */
         ProtocolVersion pv;
         Suites          clSuites;
         word32          i = *inOutIdx;
         word32          begin = i;
         int             ret = 0;
 #ifdef WOLFSSL_DTLS
         Hmac            cookieHmac;
         byte            peerCookie[MAX_COOKIE_LEN];
         byte            peerCookieSz = 0;
         byte            cookieType;
         byte            cookieSz = 0;
 
         XMEMSET(&cookieHmac, 0, sizeof(Hmac));
 #endif /* WOLFSSL_DTLS */
 
         WOLFSSL_START(WC_FUNC_CLIENT_HELLO_DO);
         WOLFSSL_ENTER("DoClientHello");
 
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn) AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn) AddLateName("ClientHello", &ssl->timeoutInfo);
 #endif
         /* protocol version, random and session id length check */
         if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
             return BUFFER_ERROR;
 
         /* protocol version */
         XMEMCPY(&pv, input + i, OPAQUE16_LEN);
         ssl->chVersion = pv;   /* store */
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) && !ssl->options.resuming) {
             #if defined(NO_SHA) && defined(NO_SHA256)
                 #error "DTLS needs either SHA or SHA-256"
             #endif /* NO_SHA && NO_SHA256 */
 
             #if !defined(NO_SHA) && defined(NO_SHA256)
                 cookieType = WC_SHA;
                 cookieSz = WC_SHA_DIGEST_SIZE;
             #endif /* NO_SHA */
             #ifndef NO_SHA256
                 cookieType = WC_SHA256;
                 cookieSz = WC_SHA256_DIGEST_SIZE;
             #endif /* NO_SHA256 */
             ret = wc_HmacSetKey(&cookieHmac, cookieType,
                                 ssl->buffers.dtlsCookieSecret.buffer,
                                 ssl->buffers.dtlsCookieSecret.length);
-            if (ret != 0) return ret;
+            if (ret != 0) goto out;
             ret = wc_HmacUpdate(&cookieHmac,
                                 (const byte*)ssl->buffers.dtlsCtx.peer.sa,
                                 ssl->buffers.dtlsCtx.peer.sz);
-            if (ret != 0) return ret;
+            if (ret != 0) goto out;
             ret = wc_HmacUpdate(&cookieHmac, input + i, OPAQUE16_LEN);
-            if (ret != 0) return ret;
+            if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
         i += OPAQUE16_LEN;
 
         /* Legacy protocol version cannot negotiate TLS 1.3 or higher. */
         if (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR)
             pv.minor = TLSv1_2_MINOR;
 
         if ((!ssl->options.dtls && ssl->version.minor > pv.minor) ||
             (ssl->options.dtls && ssl->version.minor != DTLS_MINOR
              && ssl->version.minor != DTLSv1_2_MINOR && pv.minor != DTLS_MINOR
              && pv.minor != DTLSv1_2_MINOR)) {
 
             word16 haveRSA = 0;
             word16 havePSK = 0;
             int    keySz   = 0;
 
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
-                return VERSION_ERROR;
+                ret = VERSION_ERROR;
+                goto out;
             }
             if (pv.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
-                return VERSION_ERROR;
+                ret = VERSION_ERROR;
+                goto out;
             }
 
             if (pv.minor == SSLv3_MINOR) {
                 /* turn off tls */
                 WOLFSSL_MSG("\tdowngrading to SSLv3");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = SSLv3_MINOR;
             }
             else if (pv.minor == TLSv1_MINOR) {
                 /* turn off tls 1.1+ */
                 WOLFSSL_MSG("\tdowngrading to TLSv1");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = TLSv1_MINOR;
             }
             else if (pv.minor == TLSv1_1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                 ssl->version.minor  = TLSv1_1_MINOR;
             }
             else if (pv.minor == TLSv1_2_MINOR) {
                 WOLFSSL_MSG("    downgrading to TLSv1.2");
                 ssl->version.minor  = TLSv1_2_MINOR;
             }
 #ifndef NO_RSA
             haveRSA = 1;
 #endif
 #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
 #endif
 #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
 #endif
             InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveNTRU,
                        ssl->options.haveECDSAsig, ssl->options.haveECC,
                        ssl->options.haveStaticECC, ssl->options.side);
         }
 
 #ifdef OPENSSL_EXTRA
         /* check if option is set to not allow the current version
          * set from either wolfSSL_set_options or wolfSSL_CTX_set_options */
         if (!ssl->options.dtls && ssl->options.downgrade &&
                 ssl->options.mask > 0) {
             int reset = 0;
             if (ssl->version.minor == TLSv1_2_MINOR &&
              (ssl->options.mask & SSL_OP_NO_TLSv1_2) == SSL_OP_NO_TLSv1_2) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.2, Downgrading");
                 ssl->version.minor = TLSv1_1_MINOR;
                 reset = 1;
             }
             if (ssl->version.minor == TLSv1_1_MINOR &&
              (ssl->options.mask & SSL_OP_NO_TLSv1_1) == SSL_OP_NO_TLSv1_1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.1, Downgrading");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = TLSv1_MINOR;
                 reset = 1;
             }
             if (ssl->version.minor == TLSv1_MINOR &&
                 (ssl->options.mask & SSL_OP_NO_TLSv1) == SSL_OP_NO_TLSv1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1, Downgrading");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = SSLv3_MINOR;
                 reset = 1;
             }
             if (ssl->version.minor == SSLv3_MINOR &&
                 (ssl->options.mask & SSL_OP_NO_SSLv3) == SSL_OP_NO_SSLv3) {
                 WOLFSSL_MSG("\tError, option set to not allow SSLv3");
-                return VERSION_ERROR;
+                ret = VERSION_ERROR;
+                goto out;
             }
 
             if (ssl->version.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
-                return VERSION_ERROR;
+                ret = VERSION_ERROR;
+                goto out;
             }
 
             if (reset) {
                 word16 haveRSA = 0;
                 word16 havePSK = 0;
                 int    keySz   = 0;
 
             #ifndef NO_RSA
                 haveRSA = 1;
             #endif
             #ifndef NO_PSK
                 havePSK = ssl->options.havePSK;
             #endif
             #ifndef NO_CERTS
                 keySz = ssl->buffers.keySz;
             #endif
 
                 /* reset cipher suites to account for TLS version change */
                 InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveNTRU,
                        ssl->options.haveECDSAsig, ssl->options.haveECC,
                        ssl->options.haveStaticECC, ssl->options.side);
             }
         }
 #endif
 
         /* random */
         XMEMCPY(ssl->arrays->clientRandom, input + i, RAN_LEN);
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) && !ssl->options.resuming) {
             ret = wc_HmacUpdate(&cookieHmac, input + i, RAN_LEN);
-            if (ret != 0) return ret;
+            if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
         i += RAN_LEN;
 
 #ifdef SHOW_SECRETS
         {
             int j;
             printf("client random: ");
             for (j = 0; j < RAN_LEN; j++)
                 printf("%02x", ssl->arrays->clientRandom[j]);
             printf("\n");
         }
 #endif
 
         /* session id */
         b = input[i++];
 
 #ifdef HAVE_SESSION_TICKET
         if (b > 0 && b < ID_LEN) {
             bogusID = 1;
             WOLFSSL_MSG("Client sent bogus session id, let's allow for echo");
         }
 #endif
 
         if (b == ID_LEN || bogusID) {
-            if ((i - begin) + b > helloSz)
-                return BUFFER_ERROR;
+            if ((i - begin) + b > helloSz) {
+                ret = BUFFER_ERROR;
+                goto out;
+            }
 
             XMEMCPY(ssl->arrays->sessionID, input + i, b);
 #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) &&
                     !ssl->options.resuming) {
                 ret = wc_HmacUpdate(&cookieHmac, input + i - 1, b + 1);
-                if (ret != 0) return ret;
+                if (ret != 0) goto out;
             }
 #endif /* WOLFSSL_DTLS */
             ssl->arrays->sessionIDSz = b;
             i += b;
             ssl->options.resuming = 1; /* client wants to resume */
             WOLFSSL_MSG("Client wants to resume session");
         }
         else if (b) {
             WOLFSSL_MSG("Invalid session ID size");
-            return BUFFER_ERROR; /* session ID nor 0 neither 32 bytes long */
+            ret = BUFFER_ERROR; /* session ID nor 0 neither 32 bytes long */
+            goto out;
         }
 
         #ifdef WOLFSSL_DTLS
             /* cookie */
             if (ssl->options.dtls) {
 
-                if ((i - begin) + OPAQUE8_LEN > helloSz)
-                    return BUFFER_ERROR;
+                if ((i - begin) + OPAQUE8_LEN > helloSz) {
+                    ret = BUFFER_ERROR;
+                    goto out;
+                }
 
                 peerCookieSz = input[i++];
 
                 if (peerCookieSz) {
-                    if (peerCookieSz > MAX_COOKIE_LEN)
-                        return BUFFER_ERROR;
+                    if (peerCookieSz > MAX_COOKIE_LEN) {
+                        ret = BUFFER_ERROR;
+                        goto out;
+                    }
 
-                    if ((i - begin) + peerCookieSz > helloSz)
-                        return BUFFER_ERROR;
+                    if ((i - begin) + peerCookieSz > helloSz) {
+                        ret = BUFFER_ERROR;
+                        goto out;
+                    }
 
                     XMEMCPY(peerCookie, input + i, peerCookieSz);
 
                     i += peerCookieSz;
                 }
             }
         #endif
 
         /* suites */
-        if ((i - begin) + OPAQUE16_LEN > helloSz)
-            return BUFFER_ERROR;
+        if ((i - begin) + OPAQUE16_LEN > helloSz) {
+            ret = BUFFER_ERROR;
+            goto out;
+        }
 
         ato16(&input[i], &clSuites.suiteSz);
         i += OPAQUE16_LEN;
 
         /* Cipher suite lists are always multiples of two in length. */
-        if (clSuites.suiteSz % 2 != 0)
-            return BUFFER_ERROR;
+        if (clSuites.suiteSz % 2 != 0) {
+            ret = BUFFER_ERROR;
+            goto out;
+        }
 
         /* suites and compression length check */
-        if ((i - begin) + clSuites.suiteSz + OPAQUE8_LEN > helloSz)
-            return BUFFER_ERROR;
+        if ((i - begin) + clSuites.suiteSz + OPAQUE8_LEN > helloSz) {
+            ret = BUFFER_ERROR;
+            goto out;
+        }
 
-        if (clSuites.suiteSz > WOLFSSL_MAX_SUITE_SZ)
-            return BUFFER_ERROR;
+        if (clSuites.suiteSz > WOLFSSL_MAX_SUITE_SZ) {
+            ret = BUFFER_ERROR;
+            goto out;
+        }
 
         XMEMCPY(clSuites.suites, input + i, clSuites.suiteSz);
 
 #ifdef HAVE_SERVER_RENEGOTIATION_INFO
         /* check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV suite */
         if (FindSuite(&clSuites, 0, TLS_EMPTY_RENEGOTIATION_INFO_SCSV) >= 0) {
             TLSX* extension;
 
             /* check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV suite */
             ret = TLSX_AddEmptyRenegotiationInfo(&ssl->extensions, ssl->heap);
             if (ret != WOLFSSL_SUCCESS)
-                return ret;
+                goto out;
 
             extension = TLSX_Find(ssl->extensions, TLSX_RENEGOTIATION_INFO);
             if (extension) {
                 ssl->secure_renegotiation =
                                           (SecureRenegotiation*)extension->data;
                 ssl->secure_renegotiation->enabled = 1;
             }
         }
 #endif /* HAVE_SERVER_RENEGOTIATION_INFO */
 #if defined(HAVE_FALLBACK_SCSV) || defined(OPENSSL_ALL)
         /* check for TLS_FALLBACK_SCSV suite */
         if (FindSuite(&clSuites, TLS_FALLBACK_SCSV, 0) >= 0) {
             WOLFSSL_MSG("Found Fallback SCSV");
             if (ssl->ctx->method->version.minor > pv.minor) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 SendAlert(ssl, alert_fatal, inappropriate_fallback);
-                return VERSION_ERROR;
+                ret = VERSION_ERROR;
+                goto out;
             }
         }
 #endif
 
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl) && !IsSCR(ssl) && !ssl->options.resuming) {
             ret = wc_HmacUpdate(&cookieHmac,
                                     input + i - OPAQUE16_LEN,
                                     clSuites.suiteSz + OPAQUE16_LEN);
-            if (ret != 0) return ret;
+            if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
         i += clSuites.suiteSz;
         clSuites.hashSigAlgoSz = 0;
 
         /* compression length */
         b = input[i++];
 
-        if ((i - begin) + b > helloSz)
-            return BUFFER_ERROR;
+        if ((i - begin) + b > helloSz) {
+            ret = BUFFER_ERROR;
+            goto out;
+        }
 
         if (b == 0) {
             WOLFSSL_MSG("No compression types in list");
 #ifdef WOLFSSL_EXTRA_ALERTS
             SendAlert(ssl, alert_fatal, decode_error);
 #endif
-            return COMPRESSION_ERROR;
+            ret = COMPRESSION_ERROR;
+            goto out;
         }
 
 #ifdef WOLFSSL_DTLS
         if (IsDtlsNotSctpMode(ssl)) {
             if (!IsSCR(ssl) && !ssl->options.resuming) {
                 byte newCookie[MAX_COOKIE_LEN];
 
                 ret = wc_HmacUpdate(&cookieHmac, input + i - 1, b + 1);
-                if (ret != 0) return ret;
+                if (ret != 0) goto out;
                 ret = wc_HmacFinal(&cookieHmac, newCookie);
-                if (ret != 0) return ret;
+                if (ret != 0) goto out;
 
                 /* If a cookie callback is set, call it to overwrite the cookie.
                  * This should be deprecated. The code now calculates the cookie
                  * using an HMAC as expected. */
                 if (ssl->ctx->CBIOCookie != NULL &&
                     ssl->ctx->CBIOCookie(ssl, newCookie, cookieSz,
                                                  ssl->IOCB_CookieCtx) != cookieSz) {
-                    return COOKIE_ERROR;
+                    ret = COOKIE_ERROR;
+                    goto out;
                 }
 
                 /* Check the cookie, see if we progress the state machine. */
                 if (peerCookieSz != cookieSz ||
                     XMEMCMP(peerCookie, newCookie, cookieSz) != 0) {
 
                     /* Send newCookie to client in a HelloVerifyRequest message
                      * and let the state machine alone. */
                     ssl->msgsReceived.got_client_hello = 0;
                     ssl->keys.dtls_handshake_number = 0;
                     ssl->keys.dtls_expected_peer_handshake_number = 0;
                     *inOutIdx += helloSz;
-                    return SendHelloVerifyRequest(ssl, newCookie, cookieSz);
+                    ret = SendHelloVerifyRequest(ssl, newCookie, cookieSz);
+                    goto out;
                 }
             }
 
             /* This was skipped in the DTLS case so we could handle the hello
              * verify request. */
             ret = HashInput(ssl, input + *inOutIdx, helloSz);
-            if (ret != 0) return ret;
+            if (ret != 0) goto out;
         }
 #endif /* WOLFSSL_DTLS */
 
         {
             /* compression match types */
             int matchNo = 0;
             int matchZlib = 0;
 
             while (b--) {
                 byte comp = input[i++];
 
                 if (comp == NO_COMPRESSION) {
                     matchNo = 1;
                 }
                 if (comp == ZLIB_COMPRESSION) {
                     matchZlib = 1;
                 }
             }
 
             if (ssl->options.usingCompression == 0 && matchNo) {
                 WOLFSSL_MSG("Matched No Compression");
             } else if (ssl->options.usingCompression && matchZlib) {
                 WOLFSSL_MSG("Matched zlib Compression");
             } else if (ssl->options.usingCompression && matchNo) {
                 WOLFSSL_MSG("Could only match no compression, turning off");
                 ssl->options.usingCompression = 0;  /* turn off */
             } else {
                 WOLFSSL_MSG("Could not match compression");
 #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, illegal_parameter);
 #endif
-                return COMPRESSION_ERROR;
+                ret = COMPRESSION_ERROR;
+                goto out;
             }
         }
 
         *inOutIdx = i;
 
         /* tls extensions */
         if ((i - begin) < helloSz) {
 #ifdef HAVE_TLS_EXTENSIONS
         #ifdef HAVE_QSH
             QSH_Init(ssl);
         #endif
             if (TLSX_SupportExtensions(ssl))
 #else
             if (IsAtLeastTLSv1_2(ssl))
 #endif
             {
                 /* Process the hello extension. Skip unsupported. */
                 word16 totalExtSz;
 
 #ifdef HAVE_TLS_EXTENSIONS
                 /* auto populate extensions supported unless user defined */
                 if ((ret = TLSX_PopulateExtensions(ssl, 1)) != 0)
-                    return ret;
+                    goto out;
 #endif
 
-                if ((i - begin) + OPAQUE16_LEN > helloSz)
-                    return BUFFER_ERROR;
+                if ((i - begin) + OPAQUE16_LEN > helloSz) {
+                    ret = BUFFER_ERROR;
+                    goto out;
+                }
 
                 ato16(&input[i], &totalExtSz);
                 i += OPAQUE16_LEN;
 
-                if ((i - begin) + totalExtSz > helloSz)
-                    return BUFFER_ERROR;
+                if ((i - begin) + totalExtSz > helloSz) {
+                    ret = BUFFER_ERROR;
+                    goto out;
+                }
 
 #ifdef HAVE_TLS_EXTENSIONS
                 /* tls extensions */
                 if ((ret = TLSX_Parse(ssl, (byte *) input + i, totalExtSz,
                                       client_hello, &clSuites)))
-                    return ret;
+                    goto out;
     #ifdef WOLFSSL_TLS13
                 if (TLSX_Find(ssl->extensions,
                                              TLSX_SUPPORTED_VERSIONS) != NULL) {
                     WOLFSSL_MSG(
                             "Client attempting to connect with higher version");
-                    return VERSION_ERROR;
+                    ret = VERSION_ERROR;
+                    goto out;
                 }
     #endif
     #if defined(OPENSSL_ALL) || defined(HAVE_STUNNEL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)
                 if((ret=SNI_Callback(ssl)))
-                    return ret;
+                    goto out;
                 ssl->options.side = WOLFSSL_SERVER_END;
     #endif
 
                 i += totalExtSz;
 #else
                 while (totalExtSz) {
                     word16 extId, extSz;
 
-                    if (OPAQUE16_LEN + OPAQUE16_LEN > totalExtSz)
-                        return BUFFER_ERROR;
+                    if (OPAQUE16_LEN + OPAQUE16_LEN > totalExtSz) {
+                        ret = BUFFER_ERROR;
+                        goto out;
+                    }
 
                     ato16(&input[i], &extId);
                     i += OPAQUE16_LEN;
                     ato16(&input[i], &extSz);
                     i += OPAQUE16_LEN;
 
-                    if (OPAQUE16_LEN + OPAQUE16_LEN + extSz > totalExtSz)
-                        return BUFFER_ERROR;
+                    if (OPAQUE16_LEN + OPAQUE16_LEN + extSz > totalExtSz) {
+                        ret = BUFFER_ERROR;
+                        goto out;
+                    }
 
                     if (extId == HELLO_EXT_SIG_ALGO) {
                         word16 hashSigAlgoSz;
 
                         ato16(&input[i], &hashSigAlgoSz);
                         i += OPAQUE16_LEN;
 
-                        if (OPAQUE16_LEN + hashSigAlgoSz > extSz)
-                            return BUFFER_ERROR;
+                        if (OPAQUE16_LEN + hashSigAlgoSz > extSz) {
+                            ret = BUFFER_ERROR;
+                            goto out;
+                        }
 
-                        if (hashSigAlgoSz % 2 != 0)
-                            return BUFFER_ERROR;
+                        if (hashSigAlgoSz % 2 != 0) {
+                            ret = BUFFER_ERROR;
+                            goto out;
+                        }
 
                         clSuites.hashSigAlgoSz = hashSigAlgoSz;
                         if (clSuites.hashSigAlgoSz > WOLFSSL_MAX_SIGALGO) {
                             WOLFSSL_MSG("ClientHello SigAlgo list exceeds max, "
                                                                   "truncating");
                             clSuites.hashSigAlgoSz = WOLFSSL_MAX_SIGALGO;
                         }
 
                         XMEMCPY(clSuites.hashSigAlgo, &input[i],
                                                       clSuites.hashSigAlgoSz);
 
                         i += hashSigAlgoSz;
                     }
 #ifdef HAVE_EXTENDED_MASTER
                     else if (extId == HELLO_EXT_EXTMS)
                         ssl->options.haveEMS = 1;
 #endif
                     else
                         i += extSz;
 
                     totalExtSz -= OPAQUE16_LEN + OPAQUE16_LEN + extSz;
                 }
 #endif
                 *inOutIdx = i;
             }
             else
                 *inOutIdx = begin + helloSz; /* skip extensions */
         }
 
         ssl->options.clientState   = CLIENT_HELLO_COMPLETE;
         ssl->options.haveSessionId = 1;
 
         /* ProcessOld uses same resume code */
         if (ssl->options.resuming) {
             ret = HandleTlsResumption(ssl, bogusID, &clSuites);
             if (ret != 0)
-                return ret;
+                goto out;
 
             #ifdef HAVE_SECURE_RENEGOTIATION
             if (ssl->secure_renegotiation &&
                     ssl->secure_renegotiation->enabled &&
                     IsEncryptionOn(ssl, 0))
                 ssl->secure_renegotiation->startScr = 1;
             #endif
 
             if (ssl->options.clientState == CLIENT_KEYEXCHANGE_COMPLETE) {
-            #ifdef WOLFSSL_DTLS
-                wc_HmacFree(&cookieHmac);
-            #endif
                 WOLFSSL_LEAVE("DoClientHello", ret);
                 WOLFSSL_END(WC_FUNC_CLIENT_HELLO_DO);
 
-                return ret;
+                goto out;
             }
         }
 
 #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_DH_DEFAULT_PARAMS)
     #if defined(HAVE_FFDHE) && defined(HAVE_SUPPORTED_CURVES)
         if (TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS) != NULL) {
             /* Set FFDHE parameters or clear DHE parameters if FFDH parameters
              * present and no matches in the server's list. */
             ret = TLSX_SupportedFFDHE_Set(ssl);
             if (ret != 0)
-                return ret;
+                goto out;
         }
     #endif
 #endif
 
         ret = MatchSuite(ssl, &clSuites);
 #ifdef WOLFSSL_EXTRA_ALERTS
         if (ret == BUFFER_ERROR)
             SendAlert(ssl, alert_fatal, decode_error);
         else if (ret < 0)
             SendAlert(ssl, alert_fatal, handshake_failure);
 #endif
 
 #ifdef HAVE_SECURE_RENEGOTIATION
         if (ssl->secure_renegotiation && ssl->secure_renegotiation->enabled &&
                 IsEncryptionOn(ssl, 0)) {
             ssl->secure_renegotiation->startScr = 1;
         }
 #endif
 #ifdef WOLFSSL_DTLS
-        wc_HmacFree(&cookieHmac);
-
         if (ret == 0 && ssl->options.dtls)
             DtlsMsgPoolReset(ssl);
 #endif
         WOLFSSL_LEAVE("DoClientHello", ret);
         WOLFSSL_END(WC_FUNC_CLIENT_HELLO_DO);
 
+    out:
+
+#ifdef WOLFSSL_DTLS
+        wc_HmacFree(&cookieHmac);
+#endif
+
         return ret;
     }
 
 
 #if (!defined(NO_RSA) || defined(HAVE_ECC) || defined(HAVE_ED25519) || \
                         defined(HAVE_ED448)) && !defined(WOLFSSL_NO_CLIENT_AUTH)
 
     typedef struct DcvArgs {
         byte*  output; /* not allocated */
         word32 sendSz;
         word16 sz;
         word32 sigSz;
         word32 idx;
         word32 begin;
         byte   hashAlgo;
         byte   sigAlgo;
     } DcvArgs;
 
     static void FreeDcvArgs(WOLFSSL* ssl, void* pArgs)
     {
         DcvArgs* args = (DcvArgs*)pArgs;
 
         (void)ssl;
         (void)args;
     }
 
     /* handle processing of certificate_verify (15) */
     static int DoCertificateVerify(WOLFSSL* ssl, byte* input,
                                 word32* inOutIdx, word32 size)
     {
         int ret = 0;
     #ifdef WOLFSSL_ASYNC_CRYPT
         DcvArgs* args = (DcvArgs*)ssl->async.args;
         typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
         (void)sizeof(args_test);
     #else
         DcvArgs  args[1];
     #endif
 
         WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);
         WOLFSSL_ENTER("DoCertificateVerify");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NOT_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_dcv;
         }
         else
     #endif
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(DcvArgs));
             args->hashAlgo = sha_mac;
             args->sigAlgo = anonymous_sa_algo;
             args->idx = *inOutIdx;
             args->begin = *inOutIdx;
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async.freeArgs = FreeDcvArgs;
         #endif
         }
 
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
             #ifdef WOLFSSL_CALLBACKS
                 if (ssl->hsInfoOn)
                     AddPacketName(ssl, "CertificateVerify");
                 if (ssl->toInfoOn)
                     AddLateName("CertificateVerify", &ssl->timeoutInfo);
             #endif
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* case TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
                 if (IsAtLeastTLSv1_2(ssl)) {
                     if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > size) {
                         ERROR_OUT(BUFFER_ERROR, exit_dcv);
                     }
 
                     DecodeSigAlg(&input[args->idx], &args->hashAlgo,
                                  &args->sigAlgo);
                     args->idx += 2;
                 }
             #ifndef NO_RSA
                 else if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0)
                     args->sigAlgo = rsa_sa_algo;
             #endif
             #ifdef HAVE_ECC
                 else if (ssl->peerEccDsaKeyPresent)
                     args->sigAlgo = ecc_dsa_sa_algo;
             #endif
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 else if (ssl->peerEd25519KeyPresent)
                     args->sigAlgo = ed25519_sa_algo;
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 else if (ssl->peerEd448KeyPresent)
                     args->sigAlgo = ed448_sa_algo;
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
                 if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                     ERROR_OUT(BUFFER_ERROR, exit_dcv);
                 }
 
                 ato16(input + args->idx, &args->sz);
                 args->idx += OPAQUE16_LEN;
 
                 if ((args->idx - args->begin) + args->sz > size ||
                                                     args->sz > ENCRYPT_LEN) {
                     ERROR_OUT(BUFFER_ERROR, exit_dcv);
                 }
 
             #ifdef HAVE_ECC
                 if (ssl->peerEccDsaKeyPresent) {
 
                     WOLFSSL_MSG("Doing ECC peer cert verify");
 
                 /* make sure a default is defined */
                 #if !defined(NO_SHA)
                     SetDigest(ssl, sha_mac);
                 #elif !defined(NO_SHA256)
                     SetDigest(ssl, sha256_mac);
                 #elif defined(WOLFSSL_SHA384)
                     SetDigest(ssl, sha384_mac);
                 #elif defined(WOLFSSL_SHA512)
                     SetDigest(ssl, sha512_mac);
                 #else
                     #error No digest enabled for ECC sig verify
                 #endif
 
                     if (IsAtLeastTLSv1_2(ssl)) {
                         if (args->sigAlgo != ecc_dsa_sa_algo) {
                             WOLFSSL_MSG("Oops, peer sent ECC key but not in verify");
                         }
 
                         SetDigest(ssl, args->hashAlgo);
                     }
                 }
             #endif /* HAVE_ECC */
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 if (ssl->peerEd25519KeyPresent) {
                     WOLFSSL_MSG("Doing ED25519 peer cert verify");
                     if (IsAtLeastTLSv1_2(ssl) &&
                                              args->sigAlgo != ed25519_sa_algo) {
                         WOLFSSL_MSG(
                                "Oops, peer sent ED25519 key but not in verify");
                     }
                 }
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 if (ssl->peerEd448KeyPresent) {
                     WOLFSSL_MSG("Doing ED448 peer cert verify");
                     if (IsAtLeastTLSv1_2(ssl) &&
                                                args->sigAlgo != ed448_sa_algo) {
                         WOLFSSL_MSG(
                                  "Oops, peer sent ED448 key but not in verify");
                     }
                 }
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* case TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
             #ifndef NO_RSA
                 if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {
                     WOLFSSL_MSG("Doing RSA peer cert verify");
 
                     ret = RsaVerify(ssl,
                         input + args->idx,
                         args->sz,
                         &args->output,
                         args->sigAlgo, args->hashAlgo,
                         ssl->peerRsaKey,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerRsaKey
                     #else
                         NULL
                     #endif
                     );
                     if (ret >= 0) {
                         if (args->sigAlgo == rsa_sa_algo)
                             args->sendSz = ret;
                         else {
                             args->sigSz = ret;
                             args->sendSz = ssl->buffers.digest.length;
                         }
                         ret = 0;
                     }
                 }
             #endif /* !NO_RSA */
             #ifdef HAVE_ECC
                 if (ssl->peerEccDsaKeyPresent) {
                     WOLFSSL_MSG("Doing ECC peer cert verify");
 
                     ret = EccVerify(ssl,
                         input + args->idx, args->sz,
                         ssl->buffers.digest.buffer, ssl->buffers.digest.length,
                         ssl->peerEccDsaKey,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEccDsaKey
                     #else
                         NULL
                     #endif
                     );
                 }
             #endif /* HAVE_ECC */
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 if (ssl->peerEd25519KeyPresent) {
                     WOLFSSL_MSG("Doing Ed25519 peer cert verify");
 
                     ret = Ed25519Verify(ssl,
                         input + args->idx, args->sz,
                         ssl->hsHashes->messages, ssl->hsHashes->prevLen,
                         ssl->peerEd25519Key,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEd25519Key
                     #else
                         NULL
                     #endif
                     );
                 }
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 if (ssl->peerEd448KeyPresent) {
                     WOLFSSL_MSG("Doing Ed448 peer cert verify");
 
                     ret = Ed448Verify(ssl,
                         input + args->idx, args->sz,
                         ssl->hsHashes->messages, ssl->hsHashes->prevLen,
                         ssl->peerEd448Key,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEd448Key
                     #else
                         NULL
                     #endif
                     );
                 }
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
             #ifdef WOLFSSL_ASYNC_CRYPT
                 /* handle async pending */
                 if (ret == WC_PENDING_E)
                     goto exit_dcv;
             #endif
 
                 /* Check for error */
                 if (ret != 0) {
                     ret = SIG_VERIFY_E;
                     goto exit_dcv;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* case TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
             #ifndef NO_RSA
                 if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {
                     if (IsAtLeastTLSv1_2(ssl)) {
                     #ifdef WC_RSA_PSS
                         if (args->sigAlgo == rsa_pss_sa_algo) {
                             SetDigest(ssl, args->hashAlgo);
 
                         #ifdef HAVE_SELFTEST
                             ret = wc_RsaPSS_CheckPadding(
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             args->output, args->sigSz,
                                             HashAlgoToType(args->hashAlgo));
                         #else
                             ret = wc_RsaPSS_CheckPadding_ex(
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             args->output, args->sigSz,
                                             HashAlgoToType(args->hashAlgo), -1,
                                             mp_count_bits(&ssl->peerRsaKey->n));
                         #endif
                             if (ret != 0) {
                                 ret = SIG_VERIFY_E;
                                 goto exit_dcv;
                             }
                         }
                         else
                     #endif
                         {
                         #ifdef WOLFSSL_SMALL_STACK
                             byte* encodedSig;
                         #else
                             byte  encodedSig[MAX_ENCODED_SIG_SZ];
                         #endif
 
                         #ifdef WOLFSSL_SMALL_STACK
                             encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
                                              ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                             if (encodedSig == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_dcv);
                             }
                         #endif
 
                             if (args->sigAlgo != rsa_sa_algo) {
                                 WOLFSSL_MSG("Oops, peer sent RSA key but not "
                                             "in verify");
                             }
 
                             SetDigest(ssl, args->hashAlgo);
 
                             args->sigSz = wc_EncodeSignature(encodedSig,
                                 ssl->buffers.digest.buffer,
                                 ssl->buffers.digest.length,
                                 TypeHash(args->hashAlgo));
 
                             if (args->sendSz != args->sigSz || !args->output ||
                                 XMEMCMP(args->output, encodedSig,
                                     min(args->sigSz, MAX_ENCODED_SIG_SZ)) != 0) {
                                 ret = VERIFY_CERT_ERROR;
                             }
 
                         #ifdef WOLFSSL_SMALL_STACK
                             XFREE(encodedSig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                         #endif
                         }
                     }
                     else {
                         if (args->sendSz != FINISHED_SZ || !args->output ||
                             XMEMCMP(args->output,
                                 &ssl->hsHashes->certHashes, FINISHED_SZ) != 0) {
                             ret = VERIFY_CERT_ERROR;
                         }
                     }
                 }
             #endif /* !NO_RSA */
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* case TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
                 if (IsEncryptionOn(ssl, 0)) {
                     args->idx += ssl->keys.padSz;
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead)
                         args->idx += MacSize(ssl);
             #endif
                 }
 
                 ssl->options.havePeerVerify = 1;
 
                 /* Set final index */
                 args->idx += args->sz;
                 *inOutIdx = args->idx;
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* case TLS_ASYNC_FINALIZE */
 
             case TLS_ASYNC_END:
             {
                 break;
             }
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_dcv:
 
         WOLFSSL_LEAVE("DoCertificateVerify", ret);
         WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E) {
             /* Mark message as not received so it can process again */
             ssl->msgsReceived.got_certificate_verify = 0;
 
             return ret;
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
     #ifdef WOLFSSL_EXTRA_ALERTS
         if (ret == BUFFER_ERROR)
             SendAlert(ssl, alert_fatal, decode_error);
         else if (ret == SIG_VERIFY_E)
             SendAlert(ssl, alert_fatal, decrypt_error);
         else if (ret != 0)
             SendAlert(ssl, alert_fatal, bad_certificate);
     #endif
         /* Digest is not allocated, so do this to prevent free */
         ssl->buffers.digest.buffer = NULL;
         ssl->buffers.digest.length = 0;
 
         /* Final cleanup */
         FreeDcvArgs(ssl, args);
         FreeKeyExchange(ssl);
 
         return ret;
     }
 
 #endif /* (!NO_RSA || ECC || ED25519 || ED448) && !WOLFSSL_NO_CLIENT_AUTH */
 
     /* handle generation of server_hello_done (14) */
     int SendServerHelloDone(WOLFSSL* ssl)
     {
         byte* output;
         int   sendSz = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int   ret;
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_DONE_SEND);
         WOLFSSL_ENTER("SendServerHelloDone");
 
     #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls)
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
     #endif
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, 0, server_hello_done, ssl);
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, server_hello_done)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, server_hello_done)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ServerHelloDone");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "ServerHelloDone", handshake, output, sendSz,
                     WRITE_PROTO, ssl->heap);
     #endif
         ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendServerHelloDone", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_DONE_SEND);
 
         return ret;
     }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #ifdef HAVE_SESSION_TICKET
 
 #define WOLFSSL_TICKET_FIXED_SZ (WOLFSSL_TICKET_NAME_SZ + \
                 WOLFSSL_TICKET_IV_SZ + WOLFSSL_TICKET_MAC_SZ + LENGTH_SZ)
 #define WOLFSSL_TICKET_ENC_SZ (SESSION_TICKET_LEN - WOLFSSL_TICKET_FIXED_SZ)
 
     /* our ticket format */
     typedef struct InternalTicket {
         ProtocolVersion pv;                    /* version when ticket created */
         byte            suite[SUITE_LEN];      /* cipher suite when created */
         byte            msecret[SECRET_LEN];   /* master secret */
         word32          timestamp;             /* born on */
         word16          haveEMS;               /* have extended master secret */
 #ifdef WOLFSSL_TLS13
         word32          ageAdd;                /* Obfuscation of age */
         word16          namedGroup;            /* Named group used */
         TicketNonce     ticketNonce;           /* Ticket nonce */
     #ifdef WOLFSSL_EARLY_DATA
         word32          maxEarlyDataSz;        /* Max size of early data */
     #endif
 #endif
     } InternalTicket;
 
     /* RFC 5077 defines this for session tickets */
     /* fit within SESSION_TICKET_LEN */
     typedef struct ExternalTicket {
         byte key_name[WOLFSSL_TICKET_NAME_SZ];  /* key context name */
         byte iv[WOLFSSL_TICKET_IV_SZ];          /* this ticket's iv */
         byte enc_len[LENGTH_SZ];                /* encrypted length */
         byte enc_ticket[WOLFSSL_TICKET_ENC_SZ]; /* encrypted internal ticket */
         byte mac[WOLFSSL_TICKET_MAC_SZ];        /* total mac */
         /* !! if add to structure, add to TICKET_FIXED_SZ !! */
     } ExternalTicket;
 
     /* create a new session ticket, 0 on success */
     int CreateTicket(WOLFSSL* ssl)
     {
         InternalTicket  it;
         ExternalTicket* et = (ExternalTicket*)ssl->session.ticket;
         int encLen;
         int ret;
         byte zeros[WOLFSSL_TICKET_MAC_SZ];   /* biggest cmp size */
 
         XMEMSET(&it, 0, sizeof(it));
 
         /* build internal */
         it.pv.major = ssl->version.major;
         it.pv.minor = ssl->version.minor;
 
         it.suite[0] = ssl->options.cipherSuite0;
         it.suite[1] = ssl->options.cipherSuite;
 
     #ifdef WOLFSSL_EARLY_DATA
         it.maxEarlyDataSz = ssl->options.maxEarlyDataSz;
     #endif
 
         if (!ssl->options.tls1_3) {
             XMEMCPY(it.msecret, ssl->arrays->masterSecret, SECRET_LEN);
             c32toa(LowResTimer(), (byte*)&it.timestamp);
             it.haveEMS = ssl->options.haveEMS;
         }
         else {
 #ifdef WOLFSSL_TLS13
             /* Client adds to ticket age to obfuscate. */
             ret = wc_RNG_GenerateBlock(ssl->rng, (byte*)&it.ageAdd,
                                                              sizeof(it.ageAdd));
             if (ret != 0)
                 return BAD_TICKET_ENCRYPT;
             ssl->session.ticketAdd = it.ageAdd;
             it.namedGroup = ssl->session.namedGroup;
             it.timestamp = TimeNowInMilliseconds();
             /* Resumption master secret. */
             XMEMCPY(it.msecret, ssl->session.masterSecret, SECRET_LEN);
             XMEMCPY(&it.ticketNonce, &ssl->session.ticketNonce,
                                                            sizeof(TicketNonce));
 #endif
         }
 
         /* build external */
         XMEMCPY(et->enc_ticket, &it, sizeof(InternalTicket));
 
         /* encrypt */
         encLen = WOLFSSL_TICKET_ENC_SZ;  /* max size user can use */
         if (ssl->ctx->ticketEncCb == NULL) {
             ret = WOLFSSL_TICKET_RET_FATAL;
         }
         else {
             ret = ssl->ctx->ticketEncCb(ssl, et->key_name, et->iv, et->mac, 1,
                                     et->enc_ticket, sizeof(InternalTicket),
                                     &encLen, ssl->ctx->ticketEncCtx);
         }
         if (ret == WOLFSSL_TICKET_RET_OK) {
             if (encLen < (int)sizeof(InternalTicket) ||
                 encLen > WOLFSSL_TICKET_ENC_SZ) {
                 WOLFSSL_MSG("Bad user ticket encrypt size");
                 return BAD_TICKET_KEY_CB_SZ;
             }
 
             /* sanity checks on encrypt callback */
 
             /* internal ticket can't be the same if encrypted */
             if (XMEMCMP(et->enc_ticket, &it, sizeof(InternalTicket)) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't encrypt");
                 return BAD_TICKET_ENCRYPT;
             }
 
             XMEMSET(zeros, 0, sizeof(zeros));
 
             /* name */
             if (XMEMCMP(et->key_name, zeros, WOLFSSL_TICKET_NAME_SZ) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't set name");
                 return BAD_TICKET_ENCRYPT;
             }
 
             /* iv */
             if (XMEMCMP(et->iv, zeros, WOLFSSL_TICKET_IV_SZ) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't set iv");
                 return BAD_TICKET_ENCRYPT;
             }
 
             /* mac */
             if (XMEMCMP(et->mac, zeros, WOLFSSL_TICKET_MAC_SZ) == 0) {
                 WOLFSSL_MSG("User ticket encrypt didn't set mac");
                 return BAD_TICKET_ENCRYPT;
             }
 
             /* set size */
             c16toa((word16)encLen, et->enc_len);
             ssl->session.ticketLen = (word16)(encLen + WOLFSSL_TICKET_FIXED_SZ);
             if (encLen < WOLFSSL_TICKET_ENC_SZ) {
                 /* move mac up since whole enc buffer not used */
                 XMEMMOVE(et->enc_ticket +encLen, et->mac,WOLFSSL_TICKET_MAC_SZ);
             }
         }
 
         return ret;
     }
 
 
     /* Parse ticket sent by client, returns callback return value */
     int DoClientTicket(WOLFSSL* ssl, const byte* input, word32 len)
     {
         ExternalTicket* et;
         InternalTicket* it;
         int             ret;
         int             outLen;
         word16          inLen;
 
         WOLFSSL_START(WC_FUNC_TICKET_DO);
         WOLFSSL_ENTER("DoClientTicket");
 
         if (len > SESSION_TICKET_LEN ||
              len < (word32)(sizeof(InternalTicket) + WOLFSSL_TICKET_FIXED_SZ)) {
             return BAD_TICKET_MSG_SZ;
         }
 
         et = (ExternalTicket*)input;
         it = (InternalTicket*)et->enc_ticket;
 
         /* decrypt */
         ato16(et->enc_len, &inLen);
         if (inLen > (word16)(len - WOLFSSL_TICKET_FIXED_SZ)) {
             return BAD_TICKET_MSG_SZ;
         }
         outLen = inLen;   /* may be reduced by user padding */
 
         if (ssl->ctx->ticketEncCb == NULL) {
             ret = WOLFSSL_TICKET_RET_FATAL;
         }
         else {
             ret = ssl->ctx->ticketEncCb(ssl, et->key_name, et->iv,
                                     et->enc_ticket + inLen, 0,
                                     et->enc_ticket, inLen, &outLen,
                                     ssl->ctx->ticketEncCtx);
         }
         if (ret == WOLFSSL_TICKET_RET_FATAL || ret < 0) return ret;
         if (outLen > (int)inLen || outLen < (int)sizeof(InternalTicket)) {
             WOLFSSL_MSG("Bad user ticket decrypt len");
             return BAD_TICKET_KEY_CB_SZ;
         }
 
         /* get master secret */
         if (ret == WOLFSSL_TICKET_RET_OK || ret == WOLFSSL_TICKET_RET_CREATE) {
             if (ssl->version.minor < it->pv.minor) {
                 WOLFSSL_MSG("Ticket has greater version");
                 return VERSION_ERROR;
             }
             else if (ssl->version.minor > it->pv.minor) {
                 if (!ssl->options.downgrade) {
                     WOLFSSL_MSG("Ticket has lesser version");
                     return VERSION_ERROR;
                 }
 
                 WOLFSSL_MSG("Downgrading protocol due to ticket");
 
                 if (it->pv.minor < ssl->options.minDowngrade)
                     return VERSION_ERROR;
                 ssl->version.minor = it->pv.minor;
             }
 
 
             if (!IsAtLeastTLSv1_3(ssl->version)) {
                 XMEMCPY(ssl->arrays->masterSecret, it->msecret, SECRET_LEN);
                 /* Copy the haveExtendedMasterSecret property from the ticket to
                  * the saved session, so the property may be checked later. */
                 ssl->session.haveEMS = it->haveEMS;
             #ifndef NO_RESUME_SUITE_CHECK
                 ssl->session.cipherSuite0 = it->suite[0];
                 ssl->session.cipherSuite = it->suite[1];
             #endif
             }
             else {
 #ifdef WOLFSSL_TLS13
                 /* Restore information to renegotiate. */
                 ssl->session.ticketSeen = it->timestamp;
                 ssl->session.ticketAdd = it->ageAdd;
                 ssl->session.cipherSuite0 = it->suite[0];
                 ssl->session.cipherSuite = it->suite[1];
     #ifdef WOLFSSL_EARLY_DATA
                 ssl->session.maxEarlyDataSz = it->maxEarlyDataSz;
     #endif
                 /* Resumption master secret. */
                 XMEMCPY(ssl->session.masterSecret, it->msecret, SECRET_LEN);
                 XMEMCPY(&ssl->session.ticketNonce, &it->ticketNonce,
                                                            sizeof(TicketNonce));
                 ssl->session.namedGroup = it->namedGroup;
 #endif
             }
         }
 
         WOLFSSL_LEAVE("DoClientTicket", ret);
         WOLFSSL_END(WC_FUNC_TICKET_DO);
 
         return ret;
     }
 
 
     /* send Session Ticket */
     int SendTicket(WOLFSSL* ssl)
     {
         byte*              output;
         int                ret;
         int                sendSz;
         word32             length = SESSION_HINT_SZ + LENGTH_SZ;
         word32             idx    = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
 
         WOLFSSL_START(WC_FUNC_TICKET_SEND);
         WOLFSSL_ENTER("SendTicket");
 
         if (ssl->options.createTicket) {
             ret = CreateTicket(ssl);
             if (ret != 0) return ret;
         }
 
         length += ssl->session.ticketLen;
         sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
         if (!ssl->options.dtls) {
             if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone)
                 sendSz += MAX_MSG_EXTRA;
         }
         else {
         #ifdef WOLFSSL_DTLS
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
             idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
         #endif
         }
 
         if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone)
             sendSz += cipherExtraData(ssl);
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, length, session_ticket, ssl);
 
         /* hint */
         c32toa(ssl->ctx->ticketHint, output + idx);
         idx += SESSION_HINT_SZ;
 
         /* length */
         c16toa(ssl->session.ticketLen, output + idx);
         idx += LENGTH_SZ;
 
         /* ticket */
         XMEMCPY(output + idx, ssl->session.ticket, ssl->session.ticketLen);
         idx += ssl->session.ticketLen;
 
         if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         }
         else {
             #ifdef WOLFSSL_DTLS
             if (ssl->options.dtls) {
                 if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, session_ticket)) != 0)
                     return ret;
 
                 DtlsSEQIncrement(ssl, CUR_ORDER);
             }
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         if (!ssl->options.groupMessages)
             ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendTicket", ret);
         WOLFSSL_END(WC_FUNC_TICKET_SEND);
 
         return ret;
     }
 
 #endif /* HAVE_SESSION_TICKET */
 
 #ifndef WOLFSSL_NO_TLS12
 
 #if defined(HAVE_SECURE_RENEGOTIATION) && \
     defined(HAVE_SERVER_RENEGOTIATION_INFO) && \
     !defined(WOLFSSL_NO_SERVER)
 
     /* handle generation of server's hello_request (0) */
     int SendHelloRequest(WOLFSSL* ssl)
     {
         byte* output;
         int sendSz = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int ret;
 
         WOLFSSL_START(WC_FUNC_HELLO_REQUEST_SEND);
         WOLFSSL_ENTER("SendHelloRequest");
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         if (ssl->options.dtls)
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         AddHeaders(output, 0, hello_request, ssl);
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 0, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         }
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendHelloRequest", ret);
         WOLFSSL_END(WC_FUNC_HELLO_REQUEST_SEND);
 
         return ret;
     }
 
 #endif /* HAVE_SECURE_RENEGOTIATION && HAVE_SERVER_RENEGOTIATION_INFO */
 
 #ifdef WOLFSSL_DTLS
     /* handle generation of DTLS hello_verify_request (3) */
     static int SendHelloVerifyRequest(WOLFSSL* ssl,
                                       const byte* cookie, byte cookieSz)
     {
         byte* output;
         int   length = VERSION_SZ + ENUM_LEN + cookieSz;
         int   idx    = DTLS_RECORD_HEADER_SZ + DTLS_HANDSHAKE_HEADER_SZ;
         int   sendSz = length + idx;
         int   ret;
 
         /* are we in scr */
         if (IsEncryptionOn(ssl, 1)) {
             sendSz += MAX_MSG_EXTRA;
         }
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = ssl->buffers.outputBuffer.buffer +
                  ssl->buffers.outputBuffer.length;
 
         /* Hello Verify Request should use the same sequence number as the
          * Client Hello. */
         ssl->keys.dtls_sequence_number_hi = ssl->keys.curSeq_hi;
         ssl->keys.dtls_sequence_number_lo = ssl->keys.curSeq_lo;
         AddHeaders(output, length, hello_verify_request, ssl);
 
 #ifdef OPENSSL_EXTRA
         output[idx++] = DTLS_MAJOR;
         output[idx++] = DTLS_MINOR;
 #else
         output[idx++] = ssl->version.major;
         output[idx++] = ssl->version.minor;
 #endif
 
         output[idx++] = cookieSz;
         if (cookie == NULL || cookieSz == 0)
             return COOKIE_ERROR;
 
         XMEMCPY(output + idx, cookie, cookieSz);
 
 #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "HelloVerifyRequest");
         if (ssl->toInfoOn)
             AddPacketInfo(ssl, "HelloVerifyRequest", handshake, output,
                           sendSz, WRITE_PROTO, ssl->heap);
 #endif
 
         /* are we in scr */
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ + length; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 0, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         }
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         return SendBuffered(ssl);
     }
 #endif /* WOLFSSL_DTLS */
 
     typedef struct DckeArgs {
         byte*  output; /* not allocated */
         word32 length;
         word32 idx;
         word32 begin;
         word32 sigSz;
     #ifndef NO_RSA
         int    lastErr;
     #endif
     } DckeArgs;
 
     static void FreeDckeArgs(WOLFSSL* ssl, void* pArgs)
     {
         DckeArgs* args = (DckeArgs*)pArgs;
 
         (void)ssl;
         (void)args;
     }
 
     /* handle processing client_key_exchange (16) */
     static int DoClientKeyExchange(WOLFSSL* ssl, byte* input, word32* inOutIdx,
                                                                     word32 size)
     {
         int ret;
     #ifdef WOLFSSL_ASYNC_CRYPT
         DckeArgs* args = (DckeArgs*)ssl->async.args;
         typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];
         (void)sizeof(args_test);
     #else
         DckeArgs  args[1];
     #endif
 
         (void)size;
         (void)input;
 
         WOLFSSL_START(WC_FUNC_CLIENT_KEY_EXCHANGE_DO);
         WOLFSSL_ENTER("DoClientKeyExchange");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NOT_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_dcke;
         }
         else
     #endif /* WOLFSSL_ASYNC_CRYPT */
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(DckeArgs));
             args->idx = *inOutIdx;
             args->begin = *inOutIdx;
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async.freeArgs = FreeDckeArgs;
         #endif
         }
 
         /* Do Client Key Exchange State Machine */
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
                 /* Sanity checks */
                 if (ssl->options.side != WOLFSSL_SERVER_END) {
                     WOLFSSL_MSG("Client received client keyexchange, attack?");
                     WOLFSSL_ERROR(ssl->error = SIDE_ERROR);
                     ERROR_OUT(WOLFSSL_FATAL_ERROR, exit_dcke);
                 }
 
                 if (ssl->options.clientState < CLIENT_HELLO_COMPLETE) {
                     WOLFSSL_MSG("Client sending keyexchange at wrong time");
                     SendAlert(ssl, alert_fatal, unexpected_message);
                     ERROR_OUT(OUT_OF_ORDER_E, exit_dcke);
                 }
 
             #ifndef NO_CERTS
                 if (ssl->options.verifyPeer && ssl->options.failNoCert) {
                     if (!ssl->options.havePeerCert) {
                         WOLFSSL_MSG("client didn't present peer cert");
                         ERROR_OUT(NO_PEER_CERT, exit_dcke);
                     }
                 }
 
                 if (ssl->options.verifyPeer && ssl->options.failNoCertxPSK) {
                     if (!ssl->options.havePeerCert &&
                                              !ssl->options.usingPSK_cipher) {
                         WOLFSSL_MSG("client didn't present peer cert");
                         return NO_PEER_CERT;
                     }
                 }
             #endif /* !NO_CERTS */
 
             #if defined(WOLFSSL_CALLBACKS)
                 if (ssl->hsInfoOn) {
                     AddPacketName(ssl, "ClientKeyExchange");
                 }
                 if (ssl->toInfoOn) {
                     AddLateName("ClientKeyExchange", &ssl->timeoutInfo);
                 }
             #endif
 
                 if (ssl->arrays->preMasterSecret == NULL) {
                     ssl->arrays->preMasterSz = ENCRYPT_LEN;
                     ssl->arrays->preMasterSecret = (byte*)XMALLOC(ENCRYPT_LEN,
                                                 ssl->heap, DYNAMIC_TYPE_SECRET);
                     if (ssl->arrays->preMasterSecret == NULL) {
                         ERROR_OUT(MEMORY_E, exit_dcke);
                     }
                     XMEMSET(ssl->arrays->preMasterSecret, 0, ENCRYPT_LEN);
                 }
 
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* sanity check that PSK server callback has been set */
                         if (ssl->options.server_psk_cb == NULL) {
                            WOLFSSL_MSG("No server PSK callback set");
                            ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         /* make sure private key exists */
                         if (ssl->buffers.key == NULL ||
                                             ssl->buffers.key->buffer == NULL) {
                             ERROR_OUT(NO_PRIVATE_KEY, exit_dcke);
                         }
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         /* sanity check that PSK server callback has been set */
                         if (ssl->options.server_psk_cb == NULL) {
                             WOLFSSL_MSG("No server PSK callback set");
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         /* sanity check that PSK server callback has been set */
                         if (ssl->options.server_psk_cb == NULL) {
                             WOLFSSL_MSG("No server PSK callback set");
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         WOLFSSL_MSG("Bad kea type");
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         word16 keySz;
 
                         ssl->buffers.keyType = rsa_sa_algo;
                         ret = DecodePrivateKey(ssl, &keySz);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
                         args->length = (word32)keySz;
                         ssl->arrays->preMasterSz = SECRET_LEN;
 
                         if (ssl->options.tls) {
                             word16 check;
 
                             if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                                 ERROR_OUT(BUFFER_ERROR, exit_dcke);
                             }
 
                             ato16(input + args->idx, &check);
                             args->idx += OPAQUE16_LEN;
 
                             if ((word32)check != args->length) {
                                 WOLFSSL_MSG("RSA explicit size doesn't match");
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 SendAlert(ssl, alert_fatal, bad_record_mac);
                         #endif
                                 ERROR_OUT(RSA_PRIVATE_ERROR, exit_dcke);
                             }
                         }
 
                         if ((args->idx - args->begin) + args->length > size) {
                             WOLFSSL_MSG("RSA message too big");
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         /* pre-load PreMasterSecret with RNG data */
                         ret = wc_RNG_GenerateBlock(ssl->rng,
                             &ssl->arrays->preMasterSecret[VERSION_SZ],
                             SECRET_LEN - VERSION_SZ);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
 
                         args->output = NULL;
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         byte* pms = ssl->arrays->preMasterSecret;
                         word16 ci_sz;
 
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &ci_sz);
                         args->idx += OPAQUE16_LEN;
 
                         if (ci_sz > MAX_PSK_ID_LEN) {
                             ERROR_OUT(CLIENT_ID_ERROR, exit_dcke);
                         }
 
                         if ((args->idx - args->begin) + ci_sz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         XMEMCPY(ssl->arrays->client_identity,
                                                     input + args->idx, ci_sz);
                         args->idx += ci_sz;
 
                         ssl->arrays->client_identity[ci_sz] = '\0'; /* null term */
                         ssl->arrays->psk_keySz = ssl->options.server_psk_cb(ssl,
                             ssl->arrays->client_identity, ssl->arrays->psk_key,
                             MAX_PSK_KEY_LEN);
 
                         if (ssl->arrays->psk_keySz == 0 ||
                                 ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
 
                         /* make psk pre master secret */
                         /* length of key + length 0s + length of key + key */
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMSET(pms, 0, ssl->arrays->psk_keySz);
                         pms += ssl->arrays->psk_keySz;
 
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz =
                             (ssl->arrays->psk_keySz * 2) + (OPAQUE16_LEN * 2);
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         word16 cipherLen;
                         word16 plainLen = ENCRYPT_LEN;
 
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &cipherLen);
                         args->idx += OPAQUE16_LEN;
 
                         if (cipherLen > MAX_NTRU_ENCRYPT_SZ) {
                             ERROR_OUT(NTRU_KEY_ERROR, exit_dcke);
                         }
 
                         if ((args->idx - args->begin) + cipherLen > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         if (NTRU_OK != ntru_crypto_ntru_decrypt(
                                     (word16) ssl->buffers.key->length,
                                     ssl->buffers.key->buffer, cipherLen,
                                     input + args->idx, &plainLen,
                                     ssl->arrays->preMasterSecret)) {
                             ERROR_OUT(NTRU_DECRYPT_ERROR, exit_dcke);
                         }
 
                         if (plainLen != SECRET_LEN) {
                             ERROR_OUT(NTRU_DECRYPT_ERROR, exit_dcke);
                         }
 
                         args->idx += cipherLen;
                         ssl->arrays->preMasterSz = plainLen;
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                     #ifdef HAVE_ECC
                         ecc_key* private_key = ssl->eccTempKey;
 
                         /* handle static private key */
                         if (ssl->specs.static_ecdh &&
                                           ssl->ecdhCurveOID != ECC_X25519_OID &&
                                           ssl->ecdhCurveOID != ECC_X448_OID) {
                             word16 keySz;
 
                             ssl->buffers.keyType = ecc_dsa_sa_algo;
                             ret = DecodePrivateKey(ssl, &keySz);
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                             private_key = (ecc_key*)ssl->hsKey;
                         }
                     #endif
 
                         /* import peer ECC key */
                         if ((args->idx - args->begin) + OPAQUE8_LEN > size) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, decode_error);
                         #endif
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->length = input[args->idx++];
 
                         if ((args->idx - args->begin) + args->length > size) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, decode_error);
                         #endif
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X25519SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
                             if (ssl->peerX25519Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->peerX25519Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX25519KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                ssl->peerX25519Key);
                                 ssl->peerX25519KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve25519_check_public(
                                     input + args->idx, args->length,
                                     EC25519_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve25519_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX25519Key,
                                     EC25519_LITTLE_ENDIAN)) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 SendAlert(ssl, alert_fatal, illegal_parameter);
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->arrays->preMasterSz = CURVE25519_KEYSIZE;
 
                             ssl->peerX25519KeyPresent = 1;
 
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X448SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
                             if (ssl->peerX448Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->peerX448Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX448KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                ssl->peerX448Key);
                                 ssl->peerX448KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve448_check_public(
                                     input + args->idx, args->length,
                                     EC448_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve448_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX448Key,
                                     EC448_LITTLE_ENDIAN)) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 SendAlert(ssl, alert_fatal, illegal_parameter);
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->arrays->preMasterSz = CURVE448_KEY_SIZE;
 
                             ssl->peerX448KeyPresent = 1;
 
                             break;
                         }
                     #endif
                 #ifdef HAVE_ECC
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->EccSharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         if (!ssl->specs.static_ecdh &&
                             ssl->eccTempKeyPresent == 0) {
                             WOLFSSL_MSG("Ecc ephemeral key not made correctly");
                             ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                         }
 
                         if (ssl->peerEccKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->peerEccKey);
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         } else if (ssl->peerEccKeyPresent) {
                             ret = ReuseKey(ssl, DYNAMIC_TYPE_ECC,
                                            ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         }
 
                         if (wc_ecc_import_x963_ex(input + args->idx,
                                                   args->length, ssl->peerEccKey,
                                                   private_key->dp->id)) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, illegal_parameter);
                         #endif
                             ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                         }
 
                         ssl->arrays->preMasterSz = private_key->dp->size;
 
                         ssl->peerEccKeyPresent = 1;
                 #endif /* HAVE_ECC */
 
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         word16 clientPubSz;
 
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientPubSz);
                         args->idx += OPAQUE16_LEN;
 
                         if ((args->idx - args->begin) + clientPubSz > size) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                             SendAlert(ssl, alert_fatal, decode_error);
                         #endif
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->sigSz = clientPubSz;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
 
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
 
                         /* set the max agree result size */
                         ssl->arrays->preMasterSz = ENCRYPT_LEN;
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         word16 clientSz;
 
                         /* Read in the PSK hint */
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientSz);
                         args->idx += OPAQUE16_LEN;
                         if (clientSz > MAX_PSK_ID_LEN) {
                             ERROR_OUT(CLIENT_ID_ERROR, exit_dcke);
                         }
 
                         if ((args->idx - args->begin) + clientSz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         XMEMCPY(ssl->arrays->client_identity, input + args->idx,
                                                                     clientSz);
                         args->idx += clientSz;
                         ssl->arrays->client_identity[clientSz] = '\0'; /* null term */
 
                         /* Read in the DHE business */
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientSz);
                         args->idx += OPAQUE16_LEN;
 
                         if ((args->idx - args->begin) + clientSz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->sigSz = clientSz;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_dcke;
                         }
 
                         ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_P.buffer,
                             ssl->buffers.serverDH_P.length,
                             ssl->buffers.serverDH_G.buffer,
                             ssl->buffers.serverDH_G.length);
 
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         word16 clientSz;
 
                         /* Read in the PSK hint */
                         if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         ato16(input + args->idx, &clientSz);
                         args->idx += OPAQUE16_LEN;
                         if (clientSz > MAX_PSK_ID_LEN) {
                             ERROR_OUT(CLIENT_ID_ERROR, exit_dcke);
                         }
                         if ((args->idx - args->begin) + clientSz > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         XMEMCPY(ssl->arrays->client_identity,
                                                    input + args->idx, clientSz);
                         args->idx += clientSz;
                         ssl->arrays->client_identity[clientSz] = '\0'; /* null term */
 
                         /* import peer ECC key */
                         if ((args->idx - args->begin) + OPAQUE8_LEN > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->length = input[args->idx++];
 
                         if ((args->idx - args->begin) + args->length > size) {
                             ERROR_OUT(BUFFER_ERROR, exit_dcke);
                         }
 
                         args->sigSz = ENCRYPT_LEN - OPAQUE16_LEN;
 
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X25519SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 WOLFSSL_MSG(
                                      "X25519 ephemeral key not made correctly");
                                 ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                             }
 
                             if (ssl->peerX25519Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->peerX25519Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX25519KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                ssl->peerX25519Key);
                                 ssl->peerX25519KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve25519_check_public(
                                     input + args->idx, args->length,
                                     EC25519_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve25519_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX25519Key,
                                     EC25519_LITTLE_ENDIAN)) {
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->peerX25519KeyPresent = 1;
 
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                         #ifdef HAVE_PK_CALLBACKS
                             /* if callback then use it for shared secret */
                             if (ssl->ctx->X448SharedSecretCb != NULL) {
                                 break;
                             }
                         #endif
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 WOLFSSL_MSG(
                                        "X448 ephemeral key not made correctly");
                                 ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                             }
 
                             if (ssl->peerX448Key == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->peerX448Key);
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             } else if (ssl->peerX448KeyPresent) {
                                 ret = ReuseKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                ssl->peerX448Key);
                                 ssl->peerX448KeyPresent = 0;
                                 if (ret != 0) {
                                     goto exit_dcke;
                                 }
                             }
 
                             if ((ret = wc_curve448_check_public(
                                     input + args->idx, args->length,
                                     EC448_LITTLE_ENDIAN)) != 0) {
                         #ifdef WOLFSSL_EXTRA_ALERTS
                                 if (ret == BUFFER_E)
                                     SendAlert(ssl, alert_fatal, decode_error);
                                 else if (ret == ECC_OUT_OF_RANGE_E)
                                     SendAlert(ssl, alert_fatal, bad_record_mac);
                                 else {
                                     SendAlert(ssl, alert_fatal,
                                                              illegal_parameter);
                                 }
                         #endif
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             if (wc_curve448_import_public_ex(
                                     input + args->idx, args->length,
                                     ssl->peerX448Key,
                                     EC448_LITTLE_ENDIAN)) {
                                 ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                             }
 
                             ssl->peerX448KeyPresent = 1;
 
                             break;
                         }
                     #endif
                     #ifdef HAVE_PK_CALLBACKS
                         /* if callback then use it for shared secret */
                         if (ssl->ctx->EccSharedSecretCb != NULL) {
                             break;
                         }
                     #endif
 
                         if (ssl->eccTempKeyPresent == 0) {
                             WOLFSSL_MSG("Ecc ephemeral key not made correctly");
                             ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
                         }
 
                         if (ssl->peerEccKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->peerEccKey);
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         }
                         else if (ssl->peerEccKeyPresent) {
                             ret = ReuseKey(ssl, DYNAMIC_TYPE_ECC,
                                            ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                             if (ret != 0) {
                                 goto exit_dcke;
                             }
                         }
                         if (wc_ecc_import_x963_ex(input + args->idx,
                                  args->length, ssl->peerEccKey,
                                  ssl->eccTempKey->dp->id)) {
                             ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
                         }
 
                         ssl->peerEccKeyPresent = 1;
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         RsaKey* key = (RsaKey*)ssl->hsKey;
 
                         ret = RsaDec(ssl,
                             input + args->idx,
                             args->length,
                             &args->output,
                             &args->sigSz,
                             key,
                         #ifdef HAVE_PK_CALLBACKS
                             ssl->buffers.key
                         #else
                             NULL
                         #endif
                         );
 
                         /*  Errors that can occur here that should be
                          *  indistinguishable:
                          *       RSA_BUFFER_E, RSA_PAD_E and RSA_PRIVATE_ERROR
                          */
                     #ifdef WOLFSSL_ASYNC_CRYPT
                         if (ret == WC_PENDING_E)
                             goto exit_dcke;
                     #endif
                         if (ret == BAD_FUNC_ARG)
                             goto exit_dcke;
 
                         args->lastErr = ret - (SECRET_LEN - args->sigSz);
                         ret = 0;
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         void* private_key = ssl->eccTempKey;
                         (void)private_key;
 
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             ret = X25519SharedSecret(ssl,
                                 (curve25519_key*)private_key,
                                 ssl->peerX25519Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret,
                                 &ssl->arrays->preMasterSz,
                                 WOLFSSL_SERVER_END
                             );
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             ret = X448SharedSecret(ssl,
                                 (curve448_key*)private_key,
                                 ssl->peerX448Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret,
                                 &ssl->arrays->preMasterSz,
                                 WOLFSSL_SERVER_END
                             );
                             break;
                         }
                     #endif
                     #ifdef HAVE_ECC
                         if (ssl->specs.static_ecdh) {
                             private_key = ssl->hsKey;
                         }
 
                         /* Generate shared secret */
                         ret = EccSharedSecret(ssl,
                             (ecc_key*)private_key, ssl->peerEccKey,
                             input + args->idx, &args->length,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz,
                             WOLFSSL_SERVER_END
                         );
                     #ifdef WOLFSSL_ASYNC_CRYPT
                         if (ret != WC_PENDING_E)
                     #endif
                         {
                             FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                         }
                     #endif
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             ssl->buffers.serverDH_Priv.length,
                             input + args->idx,
                             (word16)args->sigSz,
                             ssl->arrays->preMasterSecret,
                             &ssl->arrays->preMasterSz);
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         ret = DhAgree(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             ssl->buffers.serverDH_Priv.length,
                             input + args->idx,
                             (word16)args->sigSz,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &ssl->arrays->preMasterSz);
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             ret = X25519SharedSecret(ssl,
                                 (curve25519_key*)ssl->eccTempKey,
                                 ssl->peerX25519Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                                 &args->sigSz,
                                 WOLFSSL_SERVER_END
                             );
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             if (ret != WC_PENDING_E)
                         #endif
                             {
                                 FreeKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                                    (void**)&ssl->peerX25519Key);
                                 ssl->peerX25519KeyPresent = 0;
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             ret = X448SharedSecret(ssl,
                                 (curve448_key*)ssl->eccTempKey,
                                 ssl->peerX448Key,
                                 input + args->idx, &args->length,
                                 ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                                 &args->sigSz,
                                 WOLFSSL_SERVER_END
                             );
                         #ifdef WOLFSSL_ASYNC_CRYPT
                             if (ret != WC_PENDING_E)
                         #endif
                             {
                                 FreeKey(ssl, DYNAMIC_TYPE_CURVE448,
                                                      (void**)&ssl->peerX448Key);
                                 ssl->peerX448KeyPresent = 0;
                             }
                             break;
                         }
                     #endif
                         /* Generate shared secret */
                         ret = EccSharedSecret(ssl,
                             ssl->eccTempKey, ssl->peerEccKey,
                             input + args->idx, &args->length,
                             ssl->arrays->preMasterSecret + OPAQUE16_LEN,
                             &args->sigSz,
                             WOLFSSL_SERVER_END
                         );
                         if (!ssl->specs.static_ecdh
                     #ifdef WOLFSSL_ASYNC_CRYPT
                             && ret != WC_PENDING_E
                     #endif
                         ) {
                             FreeKey(ssl, DYNAMIC_TYPE_ECC,
                                                       (void**)&ssl->peerEccKey);
                             ssl->peerEccKeyPresent = 0;
                         }
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
                 switch (ssl->specs.kea) {
                 #ifndef NO_RSA
                     case rsa_kea:
                     {
                         byte mask;
                         int i;
 
                         /* Add the signature length to idx */
                         args->idx += args->length;
 
                     #ifdef DEBUG_WOLFSSL
                         /* check version (debug warning message only) */
                         if (args->output != NULL) {
                             if (args->output[0] != ssl->chVersion.major ||
                                 args->output[1] != ssl->chVersion.minor) {
                                 WOLFSSL_MSG("preMasterSecret version mismatch");
                             }
                         }
                     #endif
 
                         /* RFC5246 7.4.7.1:
                          * Treat incorrectly formatted message blocks and/or
                          * mismatched version numbers in a manner
                          * indistinguishable from correctly formatted RSA blocks
                          */
 
                         ret = args->lastErr;
                         args->lastErr = 0; /* reset */
                         /* On error 'ret' will be negative - top bit set */
                         mask = ((unsigned int)ret >>
                                                    ((sizeof(ret) * 8) - 1)) - 1;
 
                         /* build PreMasterSecret */
                         ssl->arrays->preMasterSecret[0] = ssl->chVersion.major;
                         ssl->arrays->preMasterSecret[1] = ssl->chVersion.minor;
 
                         if (args->output != NULL) {
                             /* Use random secret on error */
                             for (i = VERSION_SZ; i < SECRET_LEN; i++) {
                                 ssl->arrays->preMasterSecret[i] =
                                      ctMaskSel(mask, args->output[i],
                                                ssl->arrays->preMasterSecret[i]);
                             }
                         }
                         /* preMasterSecret has RNG and version set
                          * return proper length and ignore error
                          * error will be caught as decryption error
                          */
                         args->sigSz = SECRET_LEN;
                         ret = 0;
                         break;
                     } /* rsa_kea */
                 #endif /* !NO_RSA */
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #ifdef HAVE_NTRU
                     case ntru_kea:
                     {
                         break;
                     }
                 #endif /* HAVE_NTRU */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         /* skip past the imported peer key */
                         args->idx += args->length;
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #ifndef NO_DH
                     case diffie_hellman_kea:
                     {
                         args->idx += (word16)args->sigSz;
                         break;
                     }
                 #endif /* !NO_DH */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         byte* pms = ssl->arrays->preMasterSecret;
                         word16 clientSz = (word16)args->sigSz;
 
                         args->idx += clientSz;
                         c16toa((word16)ssl->arrays->preMasterSz, pms);
                         ssl->arrays->preMasterSz += OPAQUE16_LEN;
                         pms += ssl->arrays->preMasterSz;
 
                         /* Use the PSK hint to look up the PSK and add it to the
                          * preMasterSecret here. */
                         ssl->arrays->psk_keySz = ssl->options.server_psk_cb(ssl,
                             ssl->arrays->client_identity, ssl->arrays->psk_key,
                             MAX_PSK_KEY_LEN);
 
                         if (ssl->arrays->psk_keySz == 0 ||
                                 ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
 
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMCPY(pms, ssl->arrays->psk_key,
                                                     ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz += ssl->arrays->psk_keySz +
                                                                 OPAQUE16_LEN;
                         break;
                     }
                 #endif /* !NO_DH && !NO_PSK */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         byte* pms = ssl->arrays->preMasterSecret;
                         word16 clientSz = (word16)args->sigSz;
 
                         /* skip past the imported peer key */
                         args->idx += args->length;
 
                         /* Add preMasterSecret */
                         c16toa(clientSz, pms);
                         ssl->arrays->preMasterSz = OPAQUE16_LEN + clientSz;
                         pms += ssl->arrays->preMasterSz;
 
                         /* Use the PSK hint to look up the PSK and add it to the
                          * preMasterSecret here. */
                         ssl->arrays->psk_keySz = ssl->options.server_psk_cb(ssl,
                             ssl->arrays->client_identity, ssl->arrays->psk_key,
                             MAX_PSK_KEY_LEN);
 
                         if (ssl->arrays->psk_keySz == 0 ||
                                    ssl->arrays->psk_keySz > MAX_PSK_KEY_LEN) {
                             ERROR_OUT(PSK_KEY_ERROR, exit_dcke);
                         }
 
                         c16toa((word16) ssl->arrays->psk_keySz, pms);
                         pms += OPAQUE16_LEN;
 
                         XMEMCPY(pms, ssl->arrays->psk_key, ssl->arrays->psk_keySz);
                         ssl->arrays->preMasterSz +=
                                       ssl->arrays->psk_keySz + OPAQUE16_LEN;
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                     default:
                         ret = BAD_KEA_TYPE_E;
                 } /* switch (ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
                 if (IsEncryptionOn(ssl, 0)) {
                     args->idx += ssl->keys.padSz;
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead)
                         args->idx += MacSize(ssl);
             #endif
                 }
 
             #ifdef HAVE_QSH
                 word16 name;
 
                 if (ssl->options.haveQSH) {
                     /* extension name */
                     ato16(input + args->idx, &name);
                     args->idx += OPAQUE16_LEN;
 
                     if (name == TLSX_QUANTUM_SAFE_HYBRID) {
                         int    qshSz;
                         /* if qshSz is larger than 0 it is the
                            length of buffer used */
                         if ((qshSz = TLSX_QSHCipher_Parse(ssl,
                                 input + args->idx,
                                 size - args->idx + args->begin, 1)) < 0) {
                             ERROR_OUT(qshSz, exit_dcke);
                         }
                         args->idx += qshSz;
                     }
                     else {
                         /* unknown extension sent client ignored handshake */
                         ERROR_OUT(BUFFER_ERROR, exit_dcke);
                     }
                 }
             #endif /* HAVE_QSH */
                 ret = MakeMasterSecret(ssl);
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_dcke;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* TLS_ASYNC_FINALIZE */
             FALL_THROUGH;
 
             case TLS_ASYNC_END:
             {
                 /* Set final index */
                 *inOutIdx = args->idx;
 
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
             #ifndef NO_CERTS
                 if (ssl->options.verifyPeer) {
                     ret = BuildCertHashes(ssl, &ssl->hsHashes->certHashes);
                 }
             #endif
                 break;
             } /* TLS_ASYNC_END */
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_dcke:
 
         WOLFSSL_LEAVE("DoClientKeyExchange", ret);
         WOLFSSL_END(WC_FUNC_CLIENT_KEY_EXCHANGE_DO);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E) {
             /* Mark message as not received so it can process again */
             ssl->msgsReceived.got_client_key_exchange = 0;
 
             return ret;
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
 
         /* Cleanup PMS */
         if (ssl->arrays->preMasterSecret != NULL) {
             ForceZero(ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz);
         }
         ssl->arrays->preMasterSz = 0;
 
         /* Final cleanup */
         FreeDckeArgs(ssl, args);
         FreeKeyExchange(ssl);
 
         return ret;
     }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #if defined(OPENSSL_ALL) || defined(HAVE_STUNNEL) || defined(WOLFSSL_NGINX) || \
     defined(WOLFSSL_HAPROXY)
     int SNI_Callback(WOLFSSL* ssl)
     {
         /* Stunnel supports a custom sni callback to switch an SSL's ctx
         * when SNI is received. Call it now if exists */
         if(ssl && ssl->ctx && ssl->ctx->sniRecvCb) {
             WOLFSSL_MSG("Calling custom sni callback");
             if(ssl->ctx->sniRecvCb(ssl, NULL, ssl->ctx->sniRecvCbArg)
                     == alert_fatal) {
                 WOLFSSL_MSG("Error in custom sni callback. Fatal alert");
                 SendAlert(ssl, alert_fatal, unrecognized_name);
                 return FATAL_ERROR;
             }
         }
         return 0;
     }
 #endif /* OPENSSL_ALL || HAVE_STUNNEL || WOLFSSL_NGINX || WOLFSSL_HAPROXY */
 
 #endif /* NO_WOLFSSL_SERVER */
 
 
 #ifdef WOLFSSL_ASYNC_CRYPT
diff --git a/tests/api.c b/tests/api.c
index ebdcd3276..866000ecb 100644
--- a/tests/api.c
+++ b/tests/api.c
@@ -13772,383 +13772,389 @@ static int test_wc_SetKeyUsage (void)
 } /* END  test_wc_SetKeyUsage */
 /*
  * Testing wc_CheckProbablePrime()
  */
 static int test_wc_CheckProbablePrime (void)
 {
     int ret = 0;
 #if !defined(NO_RSA) && defined(WOLFSSL_KEY_GEN) && !defined(HAVE_SELFTEST) && \
  !defined(HAVE_FIPS) && defined(WC_RSA_BLINDING)
+
+#define CHECK_PROBABLE_PRIME_KEY_BITS 2048
+
     RsaKey              key;
     WC_RNG              rng;
     byte                e[3];
     word32              eSz = (word32)sizeof(e);
-    byte                n[512]; /* size of RSA_TEST_BYTES */
+    byte                n[CHECK_PROBABLE_PRIME_KEY_BITS / 8];
     word32              nSz = (word32)sizeof(n);
-    byte                d[512];
+    byte                d[CHECK_PROBABLE_PRIME_KEY_BITS / 8];
     word32              dSz = (word32)sizeof(d);
-    byte                p[512/2];
+    byte                p[CHECK_PROBABLE_PRIME_KEY_BITS / 8 / 2];
     word32              pSz = (word32)sizeof(p);
-    byte                q[512/2];
+    byte                q[CHECK_PROBABLE_PRIME_KEY_BITS / 8 / 2];
     word32              qSz = (word32)sizeof(q);
-    int                 nlen = 1024;
+    int                 nlen = CHECK_PROBABLE_PRIME_KEY_BITS;
     int*                isPrime;
     int                 test[5];
     isPrime = test;
 
 
     printf(testingFmt, "wc_CheckProbablePrime()");
 
 
     ret = wc_InitRsaKey(&key, NULL);
     if (ret == 0) {
         ret = wc_InitRng(&rng);
     }
     if (ret == 0) {
         ret = wc_RsaSetRNG(&key, &rng);
     }
     if (ret == 0) {
-            ret = wc_MakeRsaKey(&key, 1024, WC_RSA_EXPONENT, &rng);
+        ret = wc_MakeRsaKey(&key, CHECK_PROBABLE_PRIME_KEY_BITS, WC_RSA_EXPONENT, &rng);
     }
     if (ret == 0) {
         ret = wc_RsaExportKey(&key, e, &eSz, n, &nSz, d, &dSz,
                                 p, &pSz, q, &qSz);
     }
     /* Bad cases */
     if (ret == 0) {
         ret = wc_CheckProbablePrime(NULL, pSz, q, qSz, e, eSz,
                                      nlen, isPrime);
         if (ret == BAD_FUNC_ARG) {
             ret = 0;
         }
     }
     if (ret == 0) {
         ret = wc_CheckProbablePrime(p, 0, q, qSz, e, eSz,
                                      nlen, isPrime);
         if (ret == BAD_FUNC_ARG) {
             ret = 0;
         }
     }
     if (ret == 0) {
         ret = wc_CheckProbablePrime(p, pSz, NULL, qSz, e, eSz,
                                      nlen, isPrime);
         if (ret == BAD_FUNC_ARG) {
             ret = 0;
         }
     }
     if (ret == 0) {
         ret = wc_CheckProbablePrime(p, pSz, q, 0, e, eSz,
                                      nlen, isPrime);
         if (ret == BAD_FUNC_ARG) {
             ret = 0;
         }
     }
     if (ret == 0) {
         ret = wc_CheckProbablePrime(p, pSz, q, qSz, NULL, eSz,
                                      nlen, isPrime);
         if (ret == BAD_FUNC_ARG) {
             ret = 0;
         }
     }
     if (ret == 0) {
         ret = wc_CheckProbablePrime(p, pSz, q, qSz, e, 0,
                                      nlen, isPrime);
         if (ret == BAD_FUNC_ARG) {
             ret = 0;
         }
     }
     if (ret == 0) {
         ret = wc_CheckProbablePrime(NULL, 0, NULL, 0, NULL, 0,
                                      nlen, isPrime);
         if (ret == BAD_FUNC_ARG) {
             ret = 0;
         }
     }
     
     /* Good case */
     if (ret == 0) {
         ret = wc_CheckProbablePrime(p, pSz, q, qSz, e, eSz,
                                      nlen, isPrime);
     }
     wc_FreeRsaKey(&key);
     wc_FreeRng(&rng);
 
     printf(resultFmt, ret == 0 ? passed : failed);
+
+#undef CHECK_PROBABLE_PRIME_KEY_BITS
+
 #endif
 
     return ret;
 } /* END  test_wc_CheckProbablePrime */
 /*
  * Testing wc_RsaPSS_Verify()
  */
 static int test_wc_RsaPSS_Verify (void)
 {
     int ret = 0;
 #if !defined(NO_RSA) && defined(WOLFSSL_KEY_GEN) && !defined(HAVE_SELFTEST) && \
  !defined(HAVE_FIPS) && defined(WC_RSA_BLINDING)
     RsaKey              key;
     WC_RNG              rng;
     int                 sz = 256;
     byte*               pt;
     const char*         szMessage = "This is the string to be signed";
     unsigned char       pSignature[2048/8]; /* 2048 is RSA_KEY_SIZE */
     unsigned char       pDecrypted[2048/8];
     word32              outLen = sizeof(pDecrypted);
     pt = pDecrypted;
 
     printf(testingFmt, "wc_RsaPSS_Verify()");
 
     ret = wc_InitRsaKey(&key, NULL);
 
     if (ret == 0) {
         ret = wc_InitRng(&rng);
     }
     if (ret == 0) {
         ret = wc_RsaSetRNG(&key, &rng);
     }
     if (ret == 0) {
-            ret = wc_MakeRsaKey(&key, 1024, WC_RSA_EXPONENT, &rng);
+            ret = wc_MakeRsaKey(&key, 2048, WC_RSA_EXPONENT, &rng);
     }
-    
+
     if (ret == 0) {
         ret = wc_RsaPSS_Sign((byte*)szMessage, (word32)XSTRLEN(szMessage)+1,
                 pSignature, sizeof(pSignature),
                 WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key, &rng);
         if (ret > 0 ){
             sz = ret;
             ret = 0;
         }
     }
     /* Bad cases */
     if (ret == 0) {
         ret = wc_RsaPSS_Verify(NULL, sz, pt, outLen,
                 WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     if (ret == 0) {
         ret = wc_RsaPSS_Verify(pSignature, 0, pt, outLen,
                 WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     if (ret == 0) {
         ret = wc_RsaPSS_Verify(pSignature, sz, NULL, outLen,
                 WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     if (ret == 0) {
         ret = wc_RsaPSS_Verify(NULL, 0, NULL, outLen,
                 WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     /* Good case */
     if (ret == 0) {
         ret = wc_RsaPSS_Verify(pSignature, sz, pt, outLen,
                 WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret > 0) {
                 ret = 0;
             }
     }
     wc_FreeRsaKey(&key);
     wc_FreeRng(&rng);
     printf(resultFmt, ret == 0 ? passed : failed);
 #endif
 
     return ret;
 } /* END  test_wc_RsaPSS_Verify */
 /*
  * Testing wc_RsaPSS_VerifyCheck()
  */
 static int test_wc_RsaPSS_VerifyCheck (void)
 {
     int ret = 0;
 #if !defined(NO_RSA) && defined(WOLFSSL_KEY_GEN) && !defined(HAVE_SELFTEST) && \
  !defined(HAVE_FIPS) && defined(WC_RSA_BLINDING)
     RsaKey              key;
     WC_RNG              rng;
-    int                 sz = 128; /* 1024/8 */
+    int                 sz = 256; /* 2048/8 */
     byte*               pt;
     byte                digest[32];
     word32              digestSz;
-    unsigned char       pSignature[1024/8]; /* 2048 is RSA_KEY_SIZE */
+    unsigned char       pSignature[2048/8]; /* 2048 is RSA_KEY_SIZE */
     word32              pSignatureSz = sizeof(pSignature);
-    unsigned char       pDecrypted[1024/8];
+    unsigned char       pDecrypted[2048/8];
     word32              outLen = sizeof(pDecrypted);
     pt = pDecrypted;
 
     printf(testingFmt, "wc_RsaPSS_VerifyCheck()");
 
     XMEMSET(digest, 0, sizeof(digest));
     XMEMSET(pSignature, 0, sizeof(pSignature));
 
     ret = wc_InitRsaKey(&key, NULL);
 
     if (ret == 0) {
         ret = wc_InitRng(&rng);
     }
     if (ret == 0) {
         ret = wc_RsaSetRNG(&key, &rng);
     }
     if (ret == 0) {
-            ret = wc_MakeRsaKey(&key, 1024, WC_RSA_EXPONENT, &rng);
+            ret = wc_MakeRsaKey(&key, 2048, WC_RSA_EXPONENT, &rng);
     }
     if (ret == 0) {
         digestSz = wc_HashGetDigestSize(WC_HASH_TYPE_SHA256);
         ret = wc_Hash(WC_HASH_TYPE_SHA256, pSignature, sz, digest, digestSz);
 
     }
     
     if (ret == 0) {
         ret = wc_RsaPSS_Sign(digest, digestSz, pSignature, pSignatureSz,
                 WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key, &rng);
         if (ret > 0 ){
             sz = ret;
             ret = 0;
         }
     }
     /* Bad cases */
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheck(NULL, sz, pt, outLen,
                 digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheck(pSignature, 0, pt, outLen,
                 digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheck(pSignature, sz, NULL, outLen,
                 digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheck(NULL, 0, NULL, outLen,
                 digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }   
     
     /* Good case */
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheck(pSignature, sz, pt, outLen,
                 digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret > 0) {
                 ret = 0;
             }
     }
     wc_FreeRsaKey(&key);
     wc_FreeRng(&rng);
     printf(resultFmt, ret == 0 ? passed : failed);
 #endif
 
     return ret;
 } /* END  test_wc_RsaPSS_VerifyCheck */
 /*
  * Testing wc_RsaPSS_VerifyCheckInline()
  */
 static int test_wc_RsaPSS_VerifyCheckInline (void)
 {
     int ret = 0;
 #if !defined(NO_RSA) && defined(WOLFSSL_KEY_GEN) && !defined(HAVE_SELFTEST) && \
  !defined(HAVE_FIPS) && defined(WC_RSA_BLINDING)
     RsaKey              key;
     WC_RNG              rng;
     int                 sz = 256;
     byte*               pt;
     byte                digest[32];
     word32              digestSz;
     unsigned char       pSignature[2048/8]; /* 2048 is RSA_KEY_SIZE */
     unsigned char       pDecrypted[2048/8];
     pt = pDecrypted; 
     
 
     printf(testingFmt, "wc_RsaPSS_VerifyCheckInline()");
 
     ret = wc_InitRsaKey(&key, NULL);
 
     XMEMSET(digest, 0, sizeof(digest));
     XMEMSET(pSignature, 0, sizeof(pSignature));
 
     if (ret == 0) {
         ret = wc_InitRng(&rng);
     }
     if (ret == 0) {
         ret = wc_RsaSetRNG(&key, &rng);
     }
     if (ret == 0) {
-            ret = wc_MakeRsaKey(&key, 1024, WC_RSA_EXPONENT, &rng);
+            ret = wc_MakeRsaKey(&key, 2048, WC_RSA_EXPONENT, &rng);
     }
     if (ret == 0) {
         digestSz = wc_HashGetDigestSize(WC_HASH_TYPE_SHA256);
         ret = wc_Hash(WC_HASH_TYPE_SHA256, pSignature, sz, digest, digestSz);
 
     }
     
     if (ret == 0) {
         ret = wc_RsaPSS_Sign(digest, digestSz, pSignature, sizeof(pSignature),
                 WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key, &rng);
         if (ret > 0 ){
             sz = ret;
             ret = 0;
         }
     }
     /* Bad Cases */
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheckInline(NULL, sz, &pt,
                 digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheckInline(pSignature, 0, NULL,
                 digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheckInline(NULL, 0, &pt,
                 digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheckInline(pSignature, sz, &pt,
                 digest, digestSz, WC_HASH_TYPE_SHA, WC_MGF1SHA256, &key);
             if (ret == BAD_FUNC_ARG) {
                 ret = 0;
             }
     }
     /* Good case */
     if (ret == 0) {
         ret = wc_RsaPSS_VerifyCheckInline(pSignature, sz, &pt,
                 digest, digestSz, WC_HASH_TYPE_SHA256, WC_MGF1SHA256, &key);
             if (ret > 0) {
                 ret = 0;
             }
     }
     wc_FreeRsaKey(&key);
     wc_FreeRng(&rng);
     printf(resultFmt, ret == 0 ? passed : failed);
 #endif
 
     return ret;
 } /* END  test_wc_RsaPSS_VerifyCheckInline */
 
 #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER)
@@ -31655,145 +31661,145 @@ static void test_wolfSSL_X509_check_ip_asc(void){
 static void test_wolfSSL_DC_cert(void)
 {
 #if defined(OPENSSL_EXTRA) && !defined(NO_RSA) && !defined(NO_FILESYSTEM) && \
     defined(WOLFSSL_CERT_GEN) && defined(WOLFSSL_KEY_GEN) && \
     defined(WOLFSSL_CERT_EXT)
     Cert    cert;
     RsaKey  key;
     WC_RNG  rng;
     byte    der[FOURK_BUF];
     int     certSz;
     int     ret, idx;
     const byte  mySerial[8] = {1,2,3,4,5,6,7,8};
     const unsigned char* pt;
 
     X509*   x509;
     X509_NAME* x509name;
     X509_NAME_ENTRY* entry;
     ASN1_STRING* entryValue;
 
     CertName name;
     printf(testingFmt, "wolfSSL Certs with DC");
 
     XMEMSET(&name, 0, sizeof(CertName));
 
     /* set up cert name */
     XMEMCPY(name.country, "US", sizeof("US"));
     name.countryEnc = CTC_PRINTABLE;
     XMEMCPY(name.state, "Oregon", sizeof("Oregon"));
     name.stateEnc = CTC_UTF8;
     XMEMCPY(name.locality, "Portland", sizeof("Portland"));
     name.localityEnc = CTC_UTF8;
     XMEMCPY(name.sur, "Test", sizeof("Test"));
     name.surEnc = CTC_UTF8;
     XMEMCPY(name.org, "wolfSSL", sizeof("wolfSSL"));
     name.orgEnc = CTC_UTF8;
     XMEMCPY(name.unit, "Development", sizeof("Development"));
     name.unitEnc = CTC_UTF8;
     XMEMCPY(name.commonName, "www.wolfssl.com", sizeof("www.wolfssl.com"));
     name.commonNameEnc = CTC_UTF8;
     XMEMCPY(name.serialDev, "wolfSSL12345", sizeof("wolfSSL12345"));
     name.serialDevEnc = CTC_PRINTABLE;
 #ifdef WOLFSSL_MULTI_ATTRIB
     #if CTC_MAX_ATTRIB > 2
     {
         NameAttrib* n;
         n = &name.name[0];
         n->id   = ASN_DOMAIN_COMPONENT;
         n->type = CTC_UTF8;
         n->sz   = sizeof("com");
         XMEMCPY(n->value, "com", sizeof("com"));
 
         n = &name.name[1];
         n->id   = ASN_DOMAIN_COMPONENT;
         n->type = CTC_UTF8;
         n->sz   = sizeof("wolfssl");
         XMEMCPY(n->value, "wolfssl", sizeof("wolfssl"));
     }
     #endif
 #endif /* WOLFSSL_MULTI_ATTRIB */
 
     AssertIntEQ(wc_InitRsaKey(&key, HEAP_HINT), 0);
 #ifndef HAVE_FIPS
     AssertIntEQ(wc_InitRng_ex(&rng, HEAP_HINT, devId), 0);
 #else
     AssertIntEQ(wc_InitRng(&rng), 0);
 #endif
-    AssertIntEQ(wc_MakeRsaKey(&key, 1024, 3, &rng), 0);
+    AssertIntEQ(wc_MakeRsaKey(&key, 2048, 3, &rng), 0);
 
 
     XMEMSET(&cert, 0 , sizeof(Cert));
     AssertIntEQ(wc_InitCert(&cert), 0);
 
     XMEMCPY(&cert.subject, &name, sizeof(CertName));
     XMEMCPY(cert.serial, mySerial, sizeof(mySerial));
     cert.serialSz = (int)sizeof(mySerial);
     cert.isCA     = 1;
 #ifndef NO_SHA256
     cert.sigType = CTC_SHA256wRSA;
 #else
     cert.sigType = CTC_SHAwRSA;
 #endif
 
     /* add SKID from the Public Key */
     AssertIntEQ(wc_SetSubjectKeyIdFromPublicKey(&cert, &key, NULL), 0);
 
     /* add AKID from the Public Key */
     AssertIntEQ(wc_SetAuthKeyIdFromPublicKey(&cert, &key, NULL), 0);
 
     ret = 0;
     do {
 #if defined(WOLFSSL_ASYNC_CRYPT)
         ret = wc_AsyncWait(ret, &key.asyncDev, WC_ASYNC_FLAG_CALL_AGAIN);
 #endif
         if (ret >= 0) {
             ret = wc_MakeSelfCert(&cert, der, FOURK_BUF, &key, &rng);
         }
     } while (ret == WC_PENDING_E);
     AssertIntGT(ret, 0);
     certSz = ret;
 
     /* der holds a certificate with DC's now check X509 parsing of it */
     pt = der;
     AssertNotNull(x509 = d2i_X509(NULL, &pt, certSz));
     AssertNotNull(x509name = X509_get_subject_name(x509));
 #ifdef WOLFSSL_MULTI_ATTRIB
     AssertIntEQ((idx = X509_NAME_get_index_by_NID(x509name, NID_domainComponent,
                     -1)), 5);
     AssertIntEQ((idx = X509_NAME_get_index_by_NID(x509name, NID_domainComponent,
                     idx)), 6);
     AssertIntEQ((idx = X509_NAME_get_index_by_NID(x509name, NID_domainComponent,
                     idx)), -1);
 #endif /* WOLFSSL_MULTI_ATTRIB */
 
     /* compare DN at index 0 */
     AssertNotNull(entry = X509_NAME_get_entry(x509name, 0));
     AssertNotNull(entryValue = X509_NAME_ENTRY_get_data(entry));
     AssertIntEQ(ASN1_STRING_length(entryValue), 2);
     AssertStrEQ((const char*)ASN1_STRING_data(entryValue), "US");
 
 #ifdef WOLFSSL_MULTI_ATTRIB
     /* get first and second DC and compare result */
     AssertIntEQ((idx = X509_NAME_get_index_by_NID(x509name, NID_domainComponent,
                     -1)), 5);
     AssertNotNull(entry = X509_NAME_get_entry(x509name, idx));
     AssertNotNull(entryValue = X509_NAME_ENTRY_get_data(entry));
     AssertStrEQ((const char *)ASN1_STRING_data(entryValue), "com");
 
     AssertIntEQ((idx = X509_NAME_get_index_by_NID(x509name, NID_domainComponent,
                    idx)), 6);
     AssertNotNull(entry = X509_NAME_get_entry(x509name, idx));
     AssertNotNull(entryValue = X509_NAME_ENTRY_get_data(entry));
     AssertStrEQ((const char *)ASN1_STRING_data(entryValue), "wolfssl");
 #endif /* WOLFSSL_MULTI_ATTRIB */
 
     /* try invalid index locations for regression test and sanity check */
     AssertNull(entry = X509_NAME_get_entry(x509name, 11));
     AssertNull(entry = X509_NAME_get_entry(x509name, 20));
 
     (void)idx;
     X509_free(x509);
     wc_FreeRsaKey(&key);
     wc_FreeRng(&rng);
     printf(resultFmt, passed);
 #endif
 }
diff --git a/testsuite/testsuite.c b/testsuite/testsuite.c
index 79e655aae..039ef9f72 100644
--- a/testsuite/testsuite.c
+++ b/testsuite/testsuite.c
@@ -396,46 +396,48 @@ void join_thread(THREAD_TYPE thread)
 #ifndef NO_SHA256
 void file_test(const char* file, byte* check)
 {
     FILE* f;
     int   i = 0, j, ret;
     wc_Sha256   sha256;
     byte  buf[1024];
     byte  shasum[WC_SHA256_DIGEST_SIZE];
 
     ret = wc_InitSha256(&sha256);
     if (ret != 0) {
         printf("Can't wc_InitSha256 %d\n", ret);
         return;
     }
     if( !( f = fopen( file, "rb" ) )) {
         printf("Can't open %s\n", file);
         return;
     }
     while( ( i = (int)fread(buf, 1, sizeof(buf), f )) > 0 ) {
         ret = wc_Sha256Update(&sha256, buf, i);
         if (ret != 0) {
             printf("Can't wc_Sha256Update %d\n", ret);
             fclose(f);
             return;
         }
     }
 
     ret = wc_Sha256Final(&sha256, shasum);
+    wc_Sha256Free(&sha256);
+
     if (ret != 0) {
         printf("Can't wc_Sha256Final %d\n", ret);
         fclose(f);
         return;
     }
 
     XMEMCPY(check, shasum, sizeof(shasum));
 
     for(j = 0; j < WC_SHA256_DIGEST_SIZE; ++j )
         printf( "%02x", shasum[j] );
 
     printf("  %s\n", file);
 
     fclose(f);
 }
 #endif
 
 #else /* SINGLE_THREADED */
diff --git a/wolfcrypt/src/ecc.c b/wolfcrypt/src/ecc.c
index 85a32ed1e..4c4017ae5 100644
--- a/wolfcrypt/src/ecc.c
+++ b/wolfcrypt/src/ecc.c
@@ -7295,51 +7295,53 @@ static int ecc_check_privkey_gen_helper(ecc_key* key)
 #if defined(WOLFSSL_VALIDATE_ECC_KEYGEN) || !defined(WOLFSSL_SP_MATH)
 /* validate order * pubkey = point at infinity, 0 on success */
 static int ecc_check_pubkey_order(ecc_key* key, ecc_point* pubkey, mp_int* a,
         mp_int* prime, mp_int* order)
 {
     ecc_point* inf = NULL;
     int        err;
 
     if (key == NULL)
         return BAD_FUNC_ARG;
 
     inf = wc_ecc_new_point_h(key->heap);
     if (inf == NULL)
         err = MEMORY_E;
     else {
 #ifdef WOLFSSL_HAVE_SP_ECC
 #ifndef WOLFSSL_SP_NO_256
         if (key->idx != ECC_CUSTOM_IDX &&
                                        ecc_sets[key->idx].id == ECC_SECP256R1) {
             err = sp_ecc_mulmod_256(order, pubkey, inf, 1, key->heap);
         }
         else
 #endif
 #ifdef WOLFSSL_SP_384
         if (key->idx != ECC_CUSTOM_IDX &&
                                        ecc_sets[key->idx].id == ECC_SECP384R1) {
             err = sp_ecc_mulmod_384(order, pubkey, inf, 1, key->heap);
         }
         else
 #endif
 #endif
 #ifndef WOLFSSL_SP_MATH
             err = wc_ecc_mulmod_ex(order, pubkey, inf, a, prime, 1, key->heap);
         if (err == MP_OKAY && !wc_ecc_point_is_at_infinity(inf))
             err = ECC_INF_E;
 #else
+        {
             (void)a;
             (void)prime;
 
             err = WC_KEY_SIZE_E;
+        }
 #endif
     }
 
     wc_ecc_del_point_h(inf, key->heap);
 
     return err;
 }
 #endif
 #endif /* !WOLFSSL_ATECC508A && !WOLFSSL_CRYPTOCELL*/
 
 #ifdef OPENSSL_EXTRA
diff --git a/wolfcrypt/src/sha.c b/wolfcrypt/src/sha.c
index a0747ae30..bd442bc39 100644
--- a/wolfcrypt/src/sha.c
+++ b/wolfcrypt/src/sha.c
@@ -669,105 +669,104 @@ int wc_ShaFinalRaw(wc_Sha* sha, byte* hash)
 int wc_ShaFinal(wc_Sha* sha, byte* hash)
 {
     int ret;
     byte* local;
 
     if (sha == NULL || hash == NULL) {
         return BAD_FUNC_ARG;
     }
 
     local = (byte*)sha->buffer;
 
 #ifdef WOLF_CRYPTO_CB
     if (sha->devId != INVALID_DEVID) {
         ret = wc_CryptoCb_ShaHash(sha, NULL, 0, hash);
         if (ret != CRYPTOCB_UNAVAILABLE)
             return ret;
-        ret = 0; /* reset ret */
         /* fall-through when unavailable */
     }
 #endif
 #if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_SHA)
     if (sha->asyncDev.marker == WOLFSSL_ASYNC_MARKER_SHA) {
     #if defined(HAVE_INTEL_QA)
         return IntelQaSymSha(&sha->asyncDev, hash, NULL, WC_SHA_DIGEST_SIZE);
     #endif
     }
 #endif /* WOLFSSL_ASYNC_CRYPT */
 
     local[sha->buffLen++] = 0x80;  /* add 1 */
 
     /* pad with zeros */
     if (sha->buffLen > WC_SHA_PAD_SIZE) {
         XMEMSET(&local[sha->buffLen], 0, WC_SHA_BLOCK_SIZE - sha->buffLen);
         sha->buffLen += WC_SHA_BLOCK_SIZE - sha->buffLen;
 
     #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
         ByteReverseWords(sha->buffer, sha->buffer, WC_SHA_BLOCK_SIZE);
     #endif
 
     #if defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
         !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
         if (sha->ctx.mode == ESP32_SHA_INIT) {
             esp_sha_try_hw_lock(&sha->ctx);
         }
         if (sha->ctx.mode == ESP32_SHA_SW) {
             ret = XTRANSFORM(sha, (const byte*)local);
         } else {
             ret = esp_sha_process(sha, (const byte*)local);
         }
     #else
         ret = XTRANSFORM(sha, (const byte*)local);
     #endif
         if (ret != 0)
             return ret;
 
         sha->buffLen = 0;
     }
     XMEMSET(&local[sha->buffLen], 0, WC_SHA_PAD_SIZE - sha->buffLen);
 
 #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
     ByteReverseWords(sha->buffer, sha->buffer, WC_SHA_BLOCK_SIZE);
 #endif
 
     /* store lengths */
     /* put lengths in bits */
     sha->hiLen = (sha->loLen >> (8*sizeof(sha->loLen) - 3)) + (sha->hiLen << 3);
     sha->loLen = sha->loLen << 3;
 
     /* ! length ordering dependent on digest endian type ! */
     XMEMCPY(&local[WC_SHA_PAD_SIZE], &sha->hiLen, sizeof(word32));
     XMEMCPY(&local[WC_SHA_PAD_SIZE + sizeof(word32)], &sha->loLen, sizeof(word32));
 
 #if defined(FREESCALE_MMCAU_SHA)
     /* Kinetis requires only these bytes reversed */
     ByteReverseWords(&sha->buffer[WC_SHA_PAD_SIZE/sizeof(word32)],
                      &sha->buffer[WC_SHA_PAD_SIZE/sizeof(word32)],
                      2 * sizeof(word32));
 #endif
 
 #if defined(WOLFSSL_ESP32WROOM32_CRYPT) && \
     !defined(NO_WOLFSSL_ESP32WROOM32_CRYPT_HASH)
     if (sha->ctx.mode == ESP32_SHA_INIT) {
         esp_sha_try_hw_lock(&sha->ctx);
     }
     if (sha->ctx.mode == ESP32_SHA_SW) {
         ret = XTRANSFORM(sha, (const byte*)local);
     } else {
         ret = esp_sha_digest_process(sha, 1);
     }
 #else
     ret = XTRANSFORM(sha, (const byte*)local);
 #endif
 
 #ifdef LITTLE_ENDIAN_ORDER
     ByteReverseWords(sha->digest, sha->digest, WC_SHA_DIGEST_SIZE);
 #endif
 
     XMEMCPY(hash, sha->digest, WC_SHA_DIGEST_SIZE);
 
     (void)InitSha(sha); /* reset state */
 
     return ret;
 }
 
 #endif /* USE_SHA_SOFTWARE_IMPL */
diff --git a/wolfssl/wolfcrypt/settings.h b/wolfssl/wolfcrypt/settings.h
index ff58cc4af..9c1b3b1cd 100644
--- a/wolfssl/wolfcrypt/settings.h
+++ b/wolfssl/wolfcrypt/settings.h
@@ -656,1693 +656,1701 @@ extern void *uITRON4_realloc(void *p, size_t sz) ;
 extern void uITRON4_free(void *p) ;
 
 #define XMALLOC(sz, heap, type)     uITRON4_malloc(sz)
 #define XREALLOC(p, sz, heap, type) uITRON4_realloc(p, sz)
 #define XFREE(p, heap, type)        uITRON4_free(p)
 #endif
 
 #if defined(WOLFSSL_uTKERNEL2)
   #ifndef NO_TKERNEL_MEM_POOL
     #define XMALLOC_OVERRIDE
     int   uTKernel_init_mpool(unsigned int sz); /* initializing malloc pool */
     void* uTKernel_malloc(unsigned int sz);
     void* uTKernel_realloc(void *p, unsigned int sz);
     void  uTKernel_free(void *p);
     #define XMALLOC(s, h, type)  uTKernel_malloc((s))
     #define XREALLOC(p, n, h, t) uTKernel_realloc((p), (n))
     #define XFREE(p, h, type)    uTKernel_free((p))
   #endif
 
   #ifndef NO_STDIO_FGETS_REMAP
     #include <stdio.h>
     #include "tm/tmonitor.h"
 
     /* static char* gets(char *buff); */
     static char* fgets(char *buff, int sz, XFILE fp) {
         char * p = buff;
         *p = '\0';
         while (1) {
             *p = tm_getchar(-1);
             tm_putchar(*p);
             if (*p == '\r') {
                 tm_putchar('\n');
                 *p = '\0';
                 break;
             }
             p++;
         }
         return buff;
     }
   #endif /* !NO_STDIO_FGETS_REMAP */
 #endif
 
 
 #if defined(WOLFSSL_LEANPSK) && !defined(XMALLOC_USER) && \
         !defined(NO_WOLFSSL_MEMORY)
     #include <stdlib.h>
     #define XMALLOC(s, h, type)  malloc((s))
     #define XFREE(p, h, type)    free((p))
     #define XREALLOC(p, n, h, t) realloc((p), (n))
 #endif
 
 #if defined(XMALLOC_USER) && defined(SSN_BUILDING_LIBYASSL)
     #undef  XMALLOC
     #define XMALLOC     yaXMALLOC
     #undef  XFREE
     #define XFREE       yaXFREE
     #undef  XREALLOC
     #define XREALLOC    yaXREALLOC
 #endif
 
 
 #ifdef FREERTOS
     #include "FreeRTOS.h"
 
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY) && \
         !defined(WOLFSSL_STATIC_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
     /* FreeRTOS pvPortRealloc() implementation can be found here:
         https://github.com/wolfSSL/wolfssl-freertos/pull/3/files */
     #if !defined(USE_FAST_MATH) || defined(HAVE_ED25519) || defined(HAVE_ED448)
         #if defined(WOLFSSL_ESPIDF)
             /*In IDF, realloc(p, n) is equivalent to
             heap_caps_realloc(p, s, MALLOC_CAP_8BIT) */
             #define XREALLOC(p, n, h, t) realloc((p), (n))
         #else
             #define XREALLOC(p, n, h, t) pvPortRealloc((p), (n))
         #endif
     #endif
     #ifndef NO_WRITEV
         #define NO_WRITEV
     #endif
     #ifndef HAVE_SHA512
         #ifndef NO_SHA512
             #define NO_SHA512
         #endif
     #endif
     #ifndef HAVE_DH
         #ifndef NO_DH
             #define NO_DH
         #endif
     #endif
     #ifndef NO_DSA
         #define NO_DSA
     #endif
     #ifndef NO_HC128
         #define NO_HC128
     #endif
 
     #ifndef SINGLE_THREADED
         #include "semphr.h"
     #endif
 #endif
 
 #ifdef FREERTOS_TCP
     #if !defined(NO_WOLFSSL_MEMORY) && !defined(XMALLOC_USER) && \
         !defined(WOLFSSL_STATIC_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
 
     #define WOLFSSL_GENSEED_FORTEST
 
     #define NO_WOLFSSL_DIR
     #define NO_WRITEV
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define NO_MAIN_DRIVER
 #endif
 
 #ifdef WOLFSSL_TIRTOS
     #define SIZEOF_LONG_LONG 8
     #define NO_WRITEV
     #define NO_WOLFSSL_DIR
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
     #define WC_RSA_BLINDING
     #define NO_DEV_RANDOM
     #define NO_FILESYSTEM
     #define USE_CERT_BUFFERS_2048
     #define NO_ERROR_STRINGS
     /* Uncomment this setting if your toolchain does not offer time.h header */
     /* #define USER_TIME */
     #define HAVE_ECC
     #define HAVE_ALPN
     #define USE_WOLF_STRTOK /* use with HAVE_ALPN */
     #define HAVE_TLS_EXTENSIONS
     #define HAVE_AESGCM
     #ifdef WOLFSSL_TI_CRYPT
         #define NO_GCM_ENCRYPT_EXTRA
         #define NO_PUBLIC_GCM_SET_IV
         #define NO_PUBLIC_CCM_SET_NONCE
     #endif
     #define HAVE_SUPPORTED_CURVES
     #define ALT_ECC_SIZE
 
     #ifdef __IAR_SYSTEMS_ICC__
         #pragma diag_suppress=Pa089
     #elif !defined(__GNUC__)
         /* Suppress the sslpro warning */
         #pragma diag_suppress=11
     #endif
 
     #include <ti/sysbios/hal/Seconds.h>
 #endif
 
 #ifdef EBSNET
     #include "rtip.h"
 
     /* #define DEBUG_WOLFSSL */
     #define NO_WOLFSSL_DIR  /* tbd */
 
     #if (POLLOS)
         #define SINGLE_THREADED
     #endif
 
     #if (RTPLATFORM)
         #if (!RTP_LITTLE_ENDIAN)
             #define BIG_ENDIAN_ORDER
         #endif
     #else
         #if (!KS_LITTLE_ENDIAN)
             #define BIG_ENDIAN_ORDER
         #endif
     #endif
 
     #if (WINMSP3)
         #undef SIZEOF_LONG
         #define SIZEOF_LONG_LONG 8
     #else
         #if !defined(SIZEOF_LONG) && !defined(SIZEOF_LONG_LONG)
             #error settings.h - please implement SIZEOF_LONG and SIZEOF_LONG_LONG
         #endif
     #endif
 
     #define XMALLOC(s, h, type) ((void *)rtp_malloc((s), SSL_PRO_MALLOC))
     #define XFREE(p, h, type) (rtp_free(p))
     #define XREALLOC(p, n, h, t) (rtp_realloc((p), (n)))
 
     #if (WINMSP3)
         #define XSTRNCASECMP(s1,s2,n)  _strnicmp((s1),(s2),(n))
     #else
         #ifndef XSTRNCASECMP
             #error settings.h - please implement XSTRNCASECMP - needed for HAVE_ECC
         #endif
     #endif
 
     #define WOLFSSL_HAVE_MAX
     #define WOLFSSL_HAVE_MIN
 
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define WC_RSA_BLINDING
     #define ECC_TIMING_RESISTANT
 
     #define HAVE_ECC
 
 #endif /* EBSNET */
 
 #ifdef WOLFSSL_GAME_BUILD
     #define SIZEOF_LONG_LONG 8
     #if defined(__PPU) || defined(__XENON)
         #define BIG_ENDIAN_ORDER
     #endif
 #endif
 
 #ifdef WOLFSSL_LSR
     #define HAVE_WEBSERVER
     #define SIZEOF_LONG_LONG 8
     #define WOLFSSL_LOW_MEMORY
     #define NO_WRITEV
     #define NO_SHA512
     #define NO_DH
     /* Allows use of DH with fixed points if uncommented and NO_DH is removed */
     /* WOLFSSL_DH_CONST */
     #define NO_DSA
     #define NO_HC128
     #define NO_DEV_RANDOM
     #define NO_WOLFSSL_DIR
     #define NO_RABBIT
     #ifndef NO_FILESYSTEM
         #define LSR_FS
         #include "inc/hw_types.h"
         #include "fs.h"
     #endif
     #define WOLFSSL_LWIP
     #include <errno.h>  /* for tcp errno */
     #define WOLFSSL_SAFERTOS
     #if defined(__IAR_SYSTEMS_ICC__)
         /* enum uses enum */
         #pragma diag_suppress=Pa089
     #endif
 #endif
 
 #ifdef WOLFSSL_SAFERTOS
     #ifndef SINGLE_THREADED
         #include "SafeRTOS/semphr.h"
     #endif
     #ifndef WOLFSSL_NO_MALLOC
         #include "SafeRTOS/heap.h"
     #endif
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY) && \
         !defined(WOLFSSL_STATIC_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
     /* FreeRTOS pvPortRealloc() implementation can be found here:
         https://github.com/wolfSSL/wolfssl-freertos/pull/3/files */
     #if !defined(USE_FAST_MATH) || defined(HAVE_ED25519) || defined(HAVE_ED448)
         #define XREALLOC(p, n, h, t) pvPortRealloc((p), (n))
     #endif
 #endif
 
 #ifdef WOLFSSL_LOW_MEMORY
     #undef  RSA_LOW_MEM
     #define RSA_LOW_MEM
     #undef  WOLFSSL_SMALL_STACK
     #define WOLFSSL_SMALL_STACK
     #undef  TFM_TIMING_RESISTANT
     #define TFM_TIMING_RESISTANT
 #endif
 
 /* To support storing some of the large constant tables in flash memory rather than SRAM.
    Useful for processors that have limited SRAM, such as the AVR family of microtrollers. */
 #ifdef WOLFSSL_USE_FLASHMEM
     /* This is supported on the avr-gcc compiler, for more information see:
          https://gcc.gnu.org/onlinedocs/gcc/Named-Address-Spaces.html */
     #define FLASH_QUALIFIER __flash
 
     /* Copy data out of flash memory and into SRAM */
     #define XMEMCPY_P(pdest, psrc, size) memcpy_P((pdest), (psrc), (size))
 #else
     #define FLASH_QUALIFIER
 #endif
 
 #ifdef FREESCALE_MQX_5_0
     /* use normal Freescale MQX port, but with minor changes for 5.0 */
     #define FREESCALE_MQX
 #endif
 
 #ifdef FREESCALE_MQX_4_0
     /* use normal Freescale MQX port, but with minor changes for 4.0 */
     #define FREESCALE_MQX
 #endif
 
 #ifdef FREESCALE_MQX
     #define FREESCALE_COMMON
     #include "mqx.h"
     #ifndef NO_FILESYSTEM
         #include "mfs.h"
         #if (defined(MQX_USE_IO_OLD) && MQX_USE_IO_OLD) || \
             defined(FREESCALE_MQX_5_0)
             #include "fio.h"
             #define NO_STDIO_FILESYSTEM
         #else
             #include "nio.h"
         #endif
     #endif
     #ifndef SINGLE_THREADED
         #include "mutex.h"
     #endif
 
     #if !defined(XMALLOC_OVERRIDE) && !defined(XMALLOC_USER)
         #define XMALLOC_OVERRIDE
         #define XMALLOC(s, h, t)    (void *)_mem_alloc_system((s))
         #define XFREE(p, h, t)      {void* xp = (p); if ((xp)) _mem_free((xp));}
         /* Note: MQX has no realloc, using fastmath above */
     #endif
     #ifdef USE_FAST_MATH
         /* Undef first to avoid re-definition if user_settings.h defines */
         #undef TFM_TIMING_RESISTANT
         #define TFM_TIMING_RESISTANT
         #undef ECC_TIMING_RESISTANT
         #define ECC_TIMING_RESISTANT
         #undef WC_RSA_BLINDING
         #define WC_RSA_BLINDING
     #endif
 #endif
 
 #ifdef FREESCALE_KSDK_MQX
     #define FREESCALE_COMMON
     #include <mqx.h>
     #ifndef NO_FILESYSTEM
         #if (defined(MQX_USE_IO_OLD) && MQX_USE_IO_OLD) || \
             defined(FREESCALE_MQX_5_0)
             #include <fio.h>
         #else
             #include <stdio.h>
             #include <nio.h>
         #endif
     #endif
     #ifndef SINGLE_THREADED
         #include <mutex.h>
     #endif
 
     #define XMALLOC(s, h, t)    (void *)_mem_alloc_system((s))
     #define XFREE(p, h, t)      {void* xp = (p); if ((xp)) _mem_free((xp));}
     #define XREALLOC(p, n, h, t) _mem_realloc((p), (n)) /* since MQX 4.1.2 */
 
     #define MQX_FILE_PTR FILE *
     #define IO_SEEK_SET  SEEK_SET
     #define IO_SEEK_END  SEEK_END
 #endif /* FREESCALE_KSDK_MQX */
 
 #if defined(FREESCALE_FREE_RTOS) || defined(FREESCALE_KSDK_FREERTOS)
     #define NO_FILESYSTEM
     #define WOLFSSL_CRYPT_HW_MUTEX 1
 
     #if !defined(XMALLOC_USER) && !defined(NO_WOLFSSL_MEMORY)
         #define XMALLOC(s, h, type)  pvPortMalloc((s))
         #define XFREE(p, h, type)    vPortFree((p))
     #endif
 
     //#define USER_TICKS
     /* Allows use of DH with fixed points if uncommented and NO_DH is removed */
     /* WOLFSSL_DH_CONST */
     #define WOLFSSL_LWIP
     #define FREERTOS_TCP
 
     #define FREESCALE_FREE_RTOS
     #define FREERTOS_SOCKET_ERROR ( -1 )
     #define FREERTOS_EWOULDBLOCK ( -2 )
     #define FREERTOS_EINVAL ( -4 )
     #define FREERTOS_EADDRNOTAVAIL ( -5 )
     #define FREERTOS_EADDRINUSE ( -6 )
     #define FREERTOS_ENOBUFS ( -7 )
     #define FREERTOS_ENOPROTOOPT ( -8 )
 #endif /* FREESCALE_FREE_RTOS || FREESCALE_KSDK_FREERTOS */
 
 #ifdef FREESCALE_KSDK_BM
     #define FREESCALE_COMMON
     #define WOLFSSL_USER_IO
     #define SINGLE_THREADED
     #define NO_FILESYSTEM
     #ifndef TIME_OVERRIDES
         #define USER_TICKS
     #endif
 #endif /* FREESCALE_KSDK_BM */
 
 #ifdef FREESCALE_COMMON
     #define SIZEOF_LONG_LONG 8
 
     /* disable features */
     #undef  NO_WRITEV
     #define NO_WRITEV
     #undef  NO_DEV_RANDOM
     #define NO_DEV_RANDOM
     #undef  NO_RABBIT
     #define NO_RABBIT
     #undef  NO_WOLFSSL_DIR
     #define NO_WOLFSSL_DIR
     #undef  NO_RC4
     #define NO_RC4
 
     /* enable features */
     #undef  USE_FAST_MATH
     #define USE_FAST_MATH
 
     #define USE_CERT_BUFFERS_2048
     #define BENCH_EMBEDDED
 
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
 
     #undef  HAVE_ECC
     #define HAVE_ECC
     #ifndef NO_AES
         #undef  HAVE_AESCCM
         #define HAVE_AESCCM
         #undef  HAVE_AESGCM
         #define HAVE_AESGCM
         #undef  WOLFSSL_AES_COUNTER
         #define WOLFSSL_AES_COUNTER
         #undef  WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
     #endif
 
     #ifdef FREESCALE_KSDK_1_3
         #include "fsl_device_registers.h"
     #elif !defined(FREESCALE_MQX)
         /* Classic MQX does not have fsl_common.h */
         #include "fsl_common.h"
     #endif
 
     /* random seed */
     #define NO_OLD_RNGNAME
     #if defined(FSL_FEATURE_SOC_TRNG_COUNT) && (FSL_FEATURE_SOC_TRNG_COUNT > 0)
         #define FREESCALE_KSDK_2_0_TRNG
     #elif defined(FSL_FEATURE_SOC_RNG_COUNT) && (FSL_FEATURE_SOC_RNG_COUNT > 0)
         #ifdef FREESCALE_KSDK_1_3
             #include "fsl_rnga_driver.h"
             #define FREESCALE_RNGA
             #define RNGA_INSTANCE (0)
         #else
             #define FREESCALE_KSDK_2_0_RNGA
         #endif
     #elif !defined(FREESCALE_KSDK_BM) && !defined(FREESCALE_FREE_RTOS) && !defined(FREESCALE_KSDK_FREERTOS)
         #define FREESCALE_RNGA
         #define RNGA_INSTANCE (0)
         /* defaulting to K70 RNGA, user should change if different */
         /* #define FREESCALE_K53_RNGB */
         #define FREESCALE_K70_RNGA
     #endif
 
     /* HW crypto */
     /* automatic enable based on Kinetis feature */
     /* if case manual selection is required, for example for benchmarking purposes,
      * just define FREESCALE_USE_MMCAU or FREESCALE_USE_LTC or none of these two macros (for software only)
      * both can be enabled simultaneously as LTC has priority over MMCAU in source code.
      */
     /* #define FSL_HW_CRYPTO_MANUAL_SELECTION */
     #ifndef FSL_HW_CRYPTO_MANUAL_SELECTION
         #if defined(FSL_FEATURE_SOC_MMCAU_COUNT) && FSL_FEATURE_SOC_MMCAU_COUNT
             #define FREESCALE_USE_MMCAU
         #endif
 
         #if defined(FSL_FEATURE_SOC_LTC_COUNT) && FSL_FEATURE_SOC_LTC_COUNT
             #define FREESCALE_USE_LTC
         #endif
     #else
         /* #define FREESCALE_USE_MMCAU */
         /* #define FREESCALE_USE_LTC */
     #endif
 #endif /* FREESCALE_COMMON */
 
 /* Classic pre-KSDK mmCAU library */
 #ifdef FREESCALE_USE_MMCAU_CLASSIC
     #define FREESCALE_USE_MMCAU
     #define FREESCALE_MMCAU_CLASSIC
     #define FREESCALE_MMCAU_CLASSIC_SHA
 #endif
 
 /* KSDK mmCAU library */
 #ifdef FREESCALE_USE_MMCAU
     /* AES and DES */
     #define FREESCALE_MMCAU
     /* MD5, SHA-1 and SHA-256 */
     #define FREESCALE_MMCAU_SHA
 #endif /* FREESCALE_USE_MMCAU */
 
 #ifdef FREESCALE_USE_LTC
     #if defined(FSL_FEATURE_SOC_LTC_COUNT) && FSL_FEATURE_SOC_LTC_COUNT
         #define FREESCALE_LTC
         #define LTC_BASE LTC0
 
         #if defined(FSL_FEATURE_LTC_HAS_DES) && FSL_FEATURE_LTC_HAS_DES
             #define FREESCALE_LTC_DES
         #endif
 
         #if defined(FSL_FEATURE_LTC_HAS_GCM) && FSL_FEATURE_LTC_HAS_GCM
             #define FREESCALE_LTC_AES_GCM
         #endif
 
         #if defined(FSL_FEATURE_LTC_HAS_SHA) && FSL_FEATURE_LTC_HAS_SHA
             #define FREESCALE_LTC_SHA
         #endif
 
         #if defined(FSL_FEATURE_LTC_HAS_PKHA) && FSL_FEATURE_LTC_HAS_PKHA
             #define FREESCALE_LTC_ECC
             #define FREESCALE_LTC_TFM
 
             /* the LTC PKHA hardware limit is 2048 bits (256 bytes) for integer arithmetic.
                the LTC_MAX_INT_BYTES defines the size of local variables that hold big integers. */
             #ifndef LTC_MAX_INT_BYTES
                 #define LTC_MAX_INT_BYTES (256)
             #endif
 
             /* This FREESCALE_LTC_TFM_RSA_4096_ENABLE macro can be defined.
              * In such a case both software and hardware algorithm
              * for TFM is linked in. The decision for which algorithm is used is determined at runtime
              * from size of inputs. If inputs and result can fit into LTC (see LTC_MAX_INT_BYTES)
              * then we call hardware algorithm, otherwise we call software algorithm.
              *
              * Chinese reminder theorem is used to break RSA 4096 exponentiations (both public and private key)
              * into several computations with 2048-bit modulus and exponents.
              */
             /* #define FREESCALE_LTC_TFM_RSA_4096_ENABLE */
 
             /* ECC-384, ECC-256, ECC-224 and ECC-192 have been enabled with LTC PKHA acceleration */
             #ifdef HAVE_ECC
                 #undef  ECC_TIMING_RESISTANT
                 #define ECC_TIMING_RESISTANT
 
                 /* the LTC PKHA hardware limit is 512 bits (64 bytes) for ECC.
                    the LTC_MAX_ECC_BITS defines the size of local variables that hold ECC parameters
                    and point coordinates */
                 #ifndef LTC_MAX_ECC_BITS
                     #define LTC_MAX_ECC_BITS (384)
                 #endif
 
                 /* Enable curves up to 384 bits */
                 #if !defined(ECC_USER_CURVES) && !defined(HAVE_ALL_CURVES)
                     #define ECC_USER_CURVES
                     #define HAVE_ECC192
                     #define HAVE_ECC224
                     #undef  NO_ECC256
                     #define HAVE_ECC384
                 #endif
             #endif
         #endif
     #endif
 #endif /* FREESCALE_USE_LTC */
 
 #ifdef FREESCALE_LTC_TFM_RSA_4096_ENABLE
     #undef  USE_CERT_BUFFERS_4096
     #define USE_CERT_BUFFERS_4096
     #undef  FP_MAX_BITS
     #define FP_MAX_BITS (8192)
 
     #undef  NO_DH
     #define NO_DH
     #undef  NO_DSA
     #define NO_DSA
 #endif /* FREESCALE_LTC_TFM_RSA_4096_ENABLE */
 
 /* if LTC has AES engine but doesn't have GCM, use software with LTC AES ECB mode */
 #if defined(FREESCALE_USE_LTC) && !defined(FREESCALE_LTC_AES_GCM)
     #define GCM_TABLE
 #endif
 
 #if defined(WOLFSSL_STM32F2) || defined(WOLFSSL_STM32F4) || \
     defined(WOLFSSL_STM32F7) || defined(WOLFSSL_STM32F1) || \
     defined(WOLFSSL_STM32L4) || defined(WOLFSSL_STM32L5) || \
     defined(WOLFSSL_STM32WB) || defined(WOLFSSL_STM32H7)
 
     #define SIZEOF_LONG_LONG 8
     #ifndef CHAR_BIT
       #define CHAR_BIT 8
     #endif
     #define NO_DEV_RANDOM
     #define NO_WOLFSSL_DIR
     #undef  NO_RABBIT
     #define NO_RABBIT
     #ifndef NO_STM32_RNG
         #undef  STM32_RNG
         #define STM32_RNG
         #ifdef WOLFSSL_STM32F427_RNG
             #include "stm32f427xx.h"
         #endif
     #endif
     #ifndef NO_STM32_CRYPTO
         #undef  STM32_CRYPTO
         #define STM32_CRYPTO
 
         #if defined(WOLFSSL_STM32L4) || defined(WOLFSSL_STM32L5) || \
             defined(WOLFSSL_STM32WB)
             #define NO_AES_192 /* hardware does not support 192-bit */
         #endif
     #endif
     #ifndef NO_STM32_HASH
         #undef  STM32_HASH
         #define STM32_HASH
     #endif
     #if !defined(__GNUC__) && !defined(__ICCARM__)
         #define KEIL_INTRINSICS
     #endif
     #define NO_OLD_RNGNAME
     #ifdef WOLFSSL_STM32_CUBEMX
         #if defined(WOLFSSL_STM32F1)
             #include "stm32f1xx_hal.h"
         #elif defined(WOLFSSL_STM32F2)
             #include "stm32f2xx_hal.h"
         #elif defined(WOLFSSL_STM32L5)
             #include "stm32l5xx_hal.h"
         #elif defined(WOLFSSL_STM32L4)
             #include "stm32l4xx_hal.h"
         #elif defined(WOLFSSL_STM32F4)
             #include "stm32f4xx_hal.h"
         #elif defined(WOLFSSL_STM32F7)
             #include "stm32f7xx_hal.h"
         #elif defined(WOLFSSL_STM32F1)
             #include "stm32f1xx_hal.h"
         #elif defined(WOLFSSL_STM32H7)
             #include "stm32h7xx_hal.h"
         #elif defined(WOLFSSL_STM32WB)
             #include "stm32wbxx_hal.h"
         #endif
         #if defined(WOLFSSL_CUBEMX_USE_LL) && defined(WOLFSSL_STM32L4)
             #include "stm32l4xx_ll_rng.h"
         #endif
 
         #ifndef STM32_HAL_TIMEOUT
             #define STM32_HAL_TIMEOUT   0xFF
         #endif
     #else
         #if defined(WOLFSSL_STM32F2)
             #include "stm32f2xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32f2xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32f2xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32F4)
             #include "stm32f4xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32f4xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32f4xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32L5)
             #include "stm32l5xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32l5xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32l5xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32L4)
             #include "stm32l4xx.h"
             #ifdef STM32_CRYPTO
                 #include "stm32l4xx_cryp.h"
             #endif
             #ifdef STM32_HASH
                 #include "stm32l4xx_hash.h"
             #endif
         #elif defined(WOLFSSL_STM32F7)
             #include "stm32f7xx.h"
         #elif defined(WOLFSSL_STM32H7)
             #include "stm32h7xx.h"
         #elif defined(WOLFSSL_STM32F1)
             #include "stm32f1xx.h"
         #endif
     #endif /* WOLFSSL_STM32_CUBEMX */
 #endif /* WOLFSSL_STM32F2 || WOLFSSL_STM32F4 || WOLFSSL_STM32L4 || 
           WOLFSSL_STM32L5 || WOLFSSL_STM32F7 || WOLFSSL_STMWB || WOLFSSL_STM32H7 */
 #ifdef WOLFSSL_DEOS
     #include <deos.h>
     #include <timeout.h>
     #include <socketapi.h>
     #include <lwip-socket.h>
     #include <mem.h>
     #include <string.h>
     #include <stdlib.h> /* for rand_r: pseudo-random number generator */
     #include <stdio.h>  /* for snprintf */
 
     /* use external memory XMALLOC, XFREE and XREALLOC functions */
     #define XMALLOC_USER
 
     /* disable fall-back case, malloc, realloc and free are unavailable */
     #define WOLFSSL_NO_MALLOC
 
     /* file system has not been ported since it is a separate product. */
 
     #define NO_FILESYSTEM
 
     #ifdef NO_FILESYSTEM
         #define NO_WOLFSSL_DIR
         #define NO_WRITEV
     #endif
 
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
     #define WC_RSA_BLINDING
 
     #define HAVE_ECC
     #define ALT_ECC_SIZE
     #define TFM_ECC192
     #define TFM_ECC224
     #define TFM_ECC256
     #define TFM_ECC384
     #define TFM_ECC521
 
     #define HAVE_TLS_EXTENSIONS
     #define HAVE_SUPPORTED_CURVES
     #define HAVE_EXTENDED_MASTER
 
     #if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
         #define BIG_ENDIAN_ORDER
     #else
         #undef  BIG_ENDIAN_ORDER
         #define LITTLE_ENDIAN_ORDER
     #endif
 #endif /* WOLFSSL_DEOS*/
 
 #ifdef MICRIUM
     #include <stdlib.h>
     #include <os.h>
     #include <net_cfg.h>
     #include <net_sock.h>
     #include <net_err.h>
     #include <lib_mem.h>
     #include <lib_math.h>
 
     #define USE_FAST_MATH
     #define TFM_TIMING_RESISTANT
     #define ECC_TIMING_RESISTANT
     #define WC_RSA_BLINDING
     #define HAVE_HASHDRBG
 
     #define HAVE_ECC
     #define ALT_ECC_SIZE
     #define TFM_ECC192
     #define TFM_ECC224
     #define TFM_ECC256
     #define TFM_ECC384
     #define TFM_ECC521
 
     #define NO_RC4
     #define HAVE_TLS_EXTENSIONS
     #define HAVE_SUPPORTED_CURVES
     #define HAVE_EXTENDED_MASTER
 
     #define NO_WOLFSSL_DIR
     #define NO_WRITEV
 
     #ifndef CUSTOM_RAND_GENERATE
         #define CUSTOM_RAND_TYPE     RAND_NBR
         #define CUSTOM_RAND_GENERATE Math_Rand
     #endif
     #define STRING_USER
     #define XSTRLEN(pstr) ((CPU_SIZE_T)Str_Len((CPU_CHAR *)(pstr)))
     #define XSTRNCPY(pstr_dest, pstr_src, len_max) \
                     ((CPU_CHAR *)Str_Copy_N((CPU_CHAR *)(pstr_dest), \
                      (CPU_CHAR *)(pstr_src), (CPU_SIZE_T)(len_max)))
     #define XSTRNCMP(pstr_1, pstr_2, len_max) \
                     ((CPU_INT16S)Str_Cmp_N((CPU_CHAR *)(pstr_1), \
                      (CPU_CHAR *)(pstr_2), (CPU_SIZE_T)(len_max)))
     #define XSTRNCASECMP(pstr_1, pstr_2, len_max) \
                     ((CPU_INT16S)Str_CmpIgnoreCase_N((CPU_CHAR *)(pstr_1), \
                      (CPU_CHAR *)(pstr_2), (CPU_SIZE_T)(len_max)))
     #define XSTRSTR(pstr, pstr_srch) \
                     ((CPU_CHAR *)Str_Str((CPU_CHAR *)(pstr), \
                      (CPU_CHAR *)(pstr_srch)))
     #define XSTRNSTR(pstr, pstr_srch, len_max) \
                     ((CPU_CHAR *)Str_Str_N((CPU_CHAR *)(pstr), \
                      (CPU_CHAR *)(pstr_srch),(CPU_SIZE_T)(len_max)))
     #define XSTRNCAT(pstr_dest, pstr_cat, len_max) \
                     ((CPU_CHAR *)Str_Cat_N((CPU_CHAR *)(pstr_dest), \
                      (const CPU_CHAR *)(pstr_cat),(CPU_SIZE_T)(len_max)))
     #define XMEMSET(pmem, data_val, size) \
                     ((void)Mem_Set((void *)(pmem), \
                     (CPU_INT08U) (data_val), \
                     (CPU_SIZE_T)(size)))
     #define XMEMCPY(pdest, psrc, size) ((void)Mem_Copy((void *)(pdest), \
                      (void *)(psrc), (CPU_SIZE_T)(size)))
     #define XMEMCMP(pmem_1, pmem_2, size) \
                    (((CPU_BOOLEAN)Mem_Cmp((void *)(pmem_1), \
                                           (void *)(pmem_2), \
                      (CPU_SIZE_T)(size))) ? DEF_NO : DEF_YES)
     #define XMEMMOVE XMEMCPY
 
     #if (OS_CFG_MUTEX_EN == DEF_DISABLED)
         #define SINGLE_THREADED
     #endif
 
     #if (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
         #define BIG_ENDIAN_ORDER
     #else
         #undef  BIG_ENDIAN_ORDER
         #define LITTLE_ENDIAN_ORDER
     #endif
 #endif /* MICRIUM */
 
 #if defined(sun) || defined(__sun)
 # if defined(__SVR4) || defined(__svr4__)
     /* Solaris */
     #ifndef WOLFSSL_SOLARIS
         #define WOLFSSL_SOLARIS
     #endif
 # else
     /* SunOS */
 # endif
 #endif
 
 #ifdef WOLFSSL_SOLARIS
     /* Avoid naming clash with fp_zero from math.h > ieefp.h */
     #define WOLFSSL_DH_CONST
 #endif
 
 #ifdef WOLFSSL_MCF5441X
     #define BIG_ENDIAN_ORDER
     #ifndef SIZEOF_LONG
         #define SIZEOF_LONG 4
     #endif
     #ifndef SIZEOF_LONG_LONG
         #define SIZEOF_LONG_LONG 8
     #endif
 #endif
 
 #ifdef WOLFSSL_QL
     #ifndef WOLFSSL_SEP
         #define WOLFSSL_SEP
     #endif
     #ifndef OPENSSL_EXTRA
         #define OPENSSL_EXTRA
     #endif
     #ifndef SESSION_CERTS
         #define SESSION_CERTS
     #endif
     #ifndef HAVE_AESCCM
         #define HAVE_AESCCM
     #endif
     #ifndef ATOMIC_USER
         #define ATOMIC_USER
     #endif
     #ifndef WOLFSSL_DER_LOAD
         #define WOLFSSL_DER_LOAD
     #endif
     #ifndef KEEP_PEER_CERT
         #define KEEP_PEER_CERT
     #endif
     #ifndef HAVE_ECC
         #define HAVE_ECC
     #endif
     #ifndef SESSION_INDEX
         #define SESSION_INDEX
     #endif
 #endif /* WOLFSSL_QL */
 
 
 #if defined(WOLFSSL_XILINX)
     #define NO_WOLFSSL_DIR
     #define NO_DEV_RANDOM
     #define HAVE_AESGCM
 #endif
 
 #if defined(WOLFSSL_XILINX_CRYPT) || defined(WOLFSSL_AFALG_XILINX)
     #if defined(WOLFSSL_ARMASM)
         #error can not use both ARMv8 instructions and XILINX hardened crypto
     #endif
     #if defined(WOLFSSL_SHA3)
         /* only SHA3-384 is supported */
         #undef WOLFSSL_NOSHA3_224
         #undef WOLFSSL_NOSHA3_256
         #undef WOLFSSL_NOSHA3_512
         #define WOLFSSL_NOSHA3_224
         #define WOLFSSL_NOSHA3_256
         #define WOLFSSL_NOSHA3_512
     #endif
     #ifdef WOLFSSL_AFALG_XILINX_AES
         #undef  WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
     #endif
 #endif /*(WOLFSSL_XILINX_CRYPT)*/
 
 #if defined(WOLFSSL_APACHE_MYNEWT)
     #include "os/os_malloc.h"
     #if !defined(WOLFSSL_LWIP)
         #include <mn_socket/mn_socket.h>
     #endif
 
     #if !defined(SIZEOF_LONG)
         #define SIZEOF_LONG 4
     #endif
     #if !defined(SIZEOF_LONG_LONG)
         #define SIZEOF_LONG_LONG 8
     #endif
     #if (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
         #define BIG_ENDIAN_ORDER
     #else
         #undef  BIG_ENDIAN_ORDER
         #define LITTLE_ENDIAN_ORDER
     #endif
     #define NO_WRITEV
     #define WOLFSSL_USER_IO
     #define SINGLE_THREADED
     #define NO_DEV_RANDOM
     #define NO_DH
     #define NO_WOLFSSL_DIR
     #define NO_ERROR_STRINGS
     #define HAVE_ECC
     #define NO_SESSION_CACHE
     #define NO_ERROR_STRINGS
     #define XMALLOC_USER
     #define XMALLOC(sz, heap, type)     os_malloc(sz)
     #define XREALLOC(p, sz, heap, type) os_realloc(p, sz)
     #define XFREE(p, heap, type)        os_free(p)
 
 #endif /*(WOLFSSL_APACHE_MYNEWT)*/
 
 #ifdef WOLFSSL_ZEPHYR
     #include <zephyr.h>
     #include <misc/printk.h>
     #include <misc/util.h>
     #include <stdlib.h>
 
     #define WOLFSSL_DH_CONST
     #define WOLFSSL_HAVE_MIN
     #define WOLFSSL_HAVE_MAX
     #define NO_WRITEV
 
     #define USE_FLAT_BENCHMARK_H
     #define USE_FLAT_TEST_H
     #define EXIT_FAILURE 1
     #define MAIN_NO_ARGS
 
     void *z_realloc(void *ptr, size_t size);
     #define realloc   z_realloc
 
     #define CONFIG_NET_SOCKETS_POSIX_NAMES
 #endif
 
 #ifdef WOLFSSL_IMX6
     #ifndef SIZEOF_LONG_LONG
         #define SIZEOF_LONG_LONG 8
     #endif
 #endif
 
 /* if defined turn on all CAAM support */
 #ifdef WOLFSSL_IMX6_CAAM
     #undef  WOLFSSL_IMX6_CAAM_RNG
     #define WOLFSSL_IMX6_CAAM_RNG
 
     #undef  WOLFSSL_IMX6_CAAM_BLOB
     #define WOLFSSL_IMX6_CAAM_BLOB
 
 #if defined(HAVE_AESGCM) || defined(WOLFSSL_AES_XTS)
     /* large performance gain with HAVE_AES_ECB defined */
     #undef HAVE_AES_ECB
     #define HAVE_AES_ECB
 #endif
 #endif
 
 /* If DCP is used without SINGLE_THREADED, enforce WOLFSSL_CRYPT_HW_MUTEX */
 #if defined(WOLFSSL_IMXRT_DCP) && !defined(SINGLE_THREADED)
     #undef WOLFSSL_CRYPT_HW_MUTEX
     #define WOLFSSL_CRYPT_HW_MUTEX 1
 #endif
 
 #if !defined(XMALLOC_USER) && !defined(MICRIUM_MALLOC) && \
     !defined(WOLFSSL_LEANPSK) && !defined(NO_WOLFSSL_MEMORY) && \
     !defined(XMALLOC_OVERRIDE)
     #define USE_WOLFSSL_MEMORY
 #endif
 
 
 #if defined(OPENSSL_EXTRA) && !defined(NO_CERTS)
     #undef  KEEP_PEER_CERT
     #define KEEP_PEER_CERT
 #endif
 
 
 /* stream ciphers except arc4 need 32bit alignment, intel ok without */
 #ifndef XSTREAM_ALIGN
     #if defined(__x86_64__) || defined(__ia64__) || defined(__i386__)
         #define NO_XSTREAM_ALIGN
     #else
         #define XSTREAM_ALIGN
     #endif
 #endif
 
 /* write dup cannot be used with secure renegotiation because write dup
  * make write side write only and read side read only */
 #if defined(HAVE_WRITE_DUP) && defined(HAVE_SECURE_RENEGOTIATION)
     #error "WRITE DUP and SECURE RENEGOTIATION cannot both be on"
 #endif
 
 #ifdef WOLFSSL_SGX
     #ifdef _MSC_VER
         #define NO_RC4
         #ifndef HAVE_FIPS
             #define WOLFCRYPT_ONLY
             #define NO_DES3
             #define NO_SHA
             #define NO_MD5
         #else
             #define TFM_TIMING_RESISTANT
             #define NO_WOLFSSL_DIR
             #define NO_WRITEV
             #define NO_MAIN_DRIVER
             #define WOLFSSL_LOG_PRINTF
             #define WOLFSSL_DH_CONST
         #endif
     #else
         #define HAVE_ECC
         #define NO_WRITEV
         #define NO_MAIN_DRIVER
         #define USER_TICKS
         #define WOLFSSL_LOG_PRINTF
         #define WOLFSSL_DH_CONST
     #endif /* _MSC_VER */
     #if !defined(HAVE_FIPS) && !defined(NO_RSA)
         #define WC_RSA_BLINDING
     #endif
 
     #define NO_FILESYSTEM
     #define ECC_TIMING_RESISTANT
     #define TFM_TIMING_RESISTANT
     #define SINGLE_THREADED
     #define NO_ASN_TIME /* can not use headers such as windows.h */
     #define HAVE_AESGCM
     #define USE_CERT_BUFFERS_2048
     #define USE_FAST_MATH
 #endif /* WOLFSSL_SGX */
 
 /* FreeScale MMCAU hardware crypto has 4 byte alignment.
    However, KSDK fsl_mmcau.h gives API with no alignment
    requirements (4 byte alignment is managed internally by fsl_mmcau.c) */
 #ifdef FREESCALE_MMCAU
     #ifdef FREESCALE_MMCAU_CLASSIC
         #define WOLFSSL_MMCAU_ALIGNMENT 4
     #else
         #define WOLFSSL_MMCAU_ALIGNMENT 0
     #endif
 #endif
 
 /* if using hardware crypto and have alignment requirements, specify the
    requirement here.  The record header of SSL/TLS will prevent easy alignment.
    This hint tries to help as much as possible.  */
 #ifndef WOLFSSL_GENERAL_ALIGNMENT
     #ifdef WOLFSSL_AESNI
         #define WOLFSSL_GENERAL_ALIGNMENT 16
     #elif defined(XSTREAM_ALIGN)
         #define WOLFSSL_GENERAL_ALIGNMENT  4
     #elif defined(FREESCALE_MMCAU) || defined(FREESCALE_MMCAU_CLASSIC)
         #define WOLFSSL_GENERAL_ALIGNMENT  WOLFSSL_MMCAU_ALIGNMENT
     #else
         #define WOLFSSL_GENERAL_ALIGNMENT  0
     #endif
 #endif
 
 #if defined(WOLFSSL_GENERAL_ALIGNMENT) && (WOLFSSL_GENERAL_ALIGNMENT > 0)
     #if defined(_MSC_VER)
         #define XGEN_ALIGN __declspec(align(WOLFSSL_GENERAL_ALIGNMENT))
     #elif defined(__GNUC__)
         #define XGEN_ALIGN __attribute__((aligned(WOLFSSL_GENERAL_ALIGNMENT)))
     #else
         #define XGEN_ALIGN
     #endif
 #else
     #define XGEN_ALIGN
 #endif
 
 
 #ifdef __INTEL_COMPILER
     #pragma warning(disable:2259) /* explicit casts to smaller sizes, disable */
 #endif
 
 /* user can specify what curves they want with ECC_USER_CURVES otherwise
  * all curves are on by default for now */
 #ifndef ECC_USER_CURVES
     #if !defined(WOLFSSL_SP_MATH) && !defined(HAVE_ALL_CURVES)
         #define HAVE_ALL_CURVES
     #endif
 #endif
 
 /* ECC Configs */
 #ifdef HAVE_ECC
     /* By default enable Sign, Verify, DHE, Key Import and Key Export unless explicitly disabled */
     #ifndef NO_ECC_SIGN
         #undef HAVE_ECC_SIGN
         #define HAVE_ECC_SIGN
     #endif
     #ifndef NO_ECC_VERIFY
         #undef HAVE_ECC_VERIFY
         #define HAVE_ECC_VERIFY
     #endif
     #ifndef NO_ECC_CHECK_KEY
         #undef HAVE_ECC_CHECK_KEY
         #define HAVE_ECC_CHECK_KEY
     #endif
     #ifndef NO_ECC_DHE
         #undef HAVE_ECC_DHE
         #define HAVE_ECC_DHE
     #endif
     #ifndef NO_ECC_KEY_IMPORT
         #undef HAVE_ECC_KEY_IMPORT
         #define HAVE_ECC_KEY_IMPORT
     #endif
     #ifndef NO_ECC_KEY_EXPORT
         #undef HAVE_ECC_KEY_EXPORT
         #define HAVE_ECC_KEY_EXPORT
     #endif
 #endif /* HAVE_ECC */
 
 /* Curve25519 Configs */
 #ifdef HAVE_CURVE25519
     /* By default enable shared secret, key export and import */
     #ifndef NO_CURVE25519_SHARED_SECRET
         #undef HAVE_CURVE25519_SHARED_SECRET
         #define HAVE_CURVE25519_SHARED_SECRET
     #endif
     #ifndef NO_CURVE25519_KEY_EXPORT
         #undef HAVE_CURVE25519_KEY_EXPORT
         #define HAVE_CURVE25519_KEY_EXPORT
     #endif
     #ifndef NO_CURVE25519_KEY_IMPORT
         #undef HAVE_CURVE25519_KEY_IMPORT
         #define HAVE_CURVE25519_KEY_IMPORT
     #endif
 #endif /* HAVE_CURVE25519 */
 
 /* Ed25519 Configs */
 #ifdef HAVE_ED25519
     /* By default enable sign, verify, key export and import */
     #ifndef NO_ED25519_SIGN
         #undef HAVE_ED25519_SIGN
         #define HAVE_ED25519_SIGN
     #endif
     #ifndef NO_ED25519_VERIFY
         #undef HAVE_ED25519_VERIFY
         #define HAVE_ED25519_VERIFY
     #endif
     #ifndef NO_ED25519_KEY_EXPORT
         #undef HAVE_ED25519_KEY_EXPORT
         #define HAVE_ED25519_KEY_EXPORT
     #endif
     #ifndef NO_ED25519_KEY_IMPORT
         #undef HAVE_ED25519_KEY_IMPORT
         #define HAVE_ED25519_KEY_IMPORT
     #endif
 #endif /* HAVE_ED25519 */
 
 /* Curve448 Configs */
 #ifdef HAVE_CURVE448
     /* By default enable shared secret, key export and import */
     #ifndef NO_CURVE448_SHARED_SECRET
         #undef HAVE_CURVE448_SHARED_SECRET
         #define HAVE_CURVE448_SHARED_SECRET
     #endif
     #ifndef NO_CURVE448_KEY_EXPORT
         #undef HAVE_CURVE448_KEY_EXPORT
         #define HAVE_CURVE448_KEY_EXPORT
     #endif
     #ifndef NO_CURVE448_KEY_IMPORT
         #undef HAVE_CURVE448_KEY_IMPORT
         #define HAVE_CURVE448_KEY_IMPORT
     #endif
 #endif /* HAVE_CURVE448 */
 
 /* Ed448 Configs */
 #ifdef HAVE_ED448
     /* By default enable sign, verify, key export and import */
     #ifndef NO_ED448_SIGN
         #undef HAVE_ED448_SIGN
         #define HAVE_ED448_SIGN
     #endif
     #ifndef NO_ED448_VERIFY
         #undef HAVE_ED448_VERIFY
         #define HAVE_ED448_VERIFY
     #endif
     #ifndef NO_ED448_KEY_EXPORT
         #undef HAVE_ED448_KEY_EXPORT
         #define HAVE_ED448_KEY_EXPORT
     #endif
     #ifndef NO_ED448_KEY_IMPORT
         #undef HAVE_ED448_KEY_IMPORT
         #define HAVE_ED448_KEY_IMPORT
     #endif
 #endif /* HAVE_ED448 */
 
 /* AES Config */
 #ifndef NO_AES
     /* By default enable all AES key sizes, decryption and CBC */
     #ifndef AES_MAX_KEY_SIZE
         #undef  AES_MAX_KEY_SIZE
         #define AES_MAX_KEY_SIZE    256
     #endif
 
     #ifndef NO_AES_128
         #undef  WOLFSSL_AES_128
         #define WOLFSSL_AES_128
     #endif
     #if !defined(NO_AES_192) && AES_MAX_KEY_SIZE >= 192
         #undef  WOLFSSL_AES_192
         #define WOLFSSL_AES_192
     #endif
     #if !defined(NO_AES_256) && AES_MAX_KEY_SIZE >= 256
         #undef  WOLFSSL_AES_256
         #define WOLFSSL_AES_256
     #endif
     #if !defined(WOLFSSL_AES_128) && defined(HAVE_ECC_ENCRYPT)
         #warning HAVE_ECC_ENCRYPT uses AES 128 bit keys
      #endif
 
     #ifndef NO_AES_DECRYPT
         #undef  HAVE_AES_DECRYPT
         #define HAVE_AES_DECRYPT
     #endif
     #ifndef NO_AES_CBC
         #undef  HAVE_AES_CBC
         #define HAVE_AES_CBC
     #endif
     #ifdef WOLFSSL_AES_XTS
         /* AES-XTS makes calls to AES direct functions */
         #ifndef WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
         #endif
     #endif
     #ifdef WOLFSSL_AES_CFB
         /* AES-CFB makes calls to AES direct functions */
         #ifndef WOLFSSL_AES_DIRECT
         #define WOLFSSL_AES_DIRECT
         #endif
     #endif
 #endif
 
 #if (defined(WOLFSSL_TLS13) && defined(WOLFSSL_NO_TLS12)) || \
     (!defined(HAVE_AES_CBC) && defined(NO_DES3) && defined(NO_RC4) && \
      !defined(HAVE_CAMELLIA) && !defined(HAVE_IDEA) && \
      !defined(HAVE_NULL_CIPHER) && !defined(HAVE_HC128))
     #define WOLFSSL_AEAD_ONLY
 #endif
 
 #if !defined(NO_DH) && !defined(HAVE_FFDHE)
     #if defined(HAVE_FFDHE_2048) || defined(HAVE_FFDHE_3072) || \
             defined(HAVE_FFDHE_4096) || defined(HAVE_FFDHE_6144) || \
             defined(HAVE_FFDHE_8192)
         #define HAVE_FFDHE
     #endif
 #endif
 #if defined(HAVE_FFDHE_8192)
     #define MIN_FFDHE_FP_MAX_BITS 16384
 #elif defined(HAVE_FFDHE_6144)
     #define MIN_FFDHE_FP_MAX_BITS 12288
 #elif defined(HAVE_FFDHE_4096)
     #define MIN_FFDHE_FP_MAX_BITS 8192
 #elif defined(HAVE_FFDHE_3072)
     #define MIN_FFDHE_FP_MAX_BITS 6144
 #elif defined(HAVE_FFDHE_2048)
     #define MIN_FFDHE_FP_MAX_BITS 4096
 #else
     #define MIN_FFDHE_FP_MAX_BITS 0
 #endif
 #if defined(HAVE_FFDHE) && defined(FP_MAX_BITS)
     #if MIN_FFDHE_FP_MAX_BITS > FP_MAX_BITS
         #error "FFDHE parameters are too large for FP_MAX_BIT as set"
     #endif
 #endif
 
 /* if desktop type system and fastmath increase default max bits */
 #ifdef WOLFSSL_X86_64_BUILD
     #if defined(USE_FAST_MATH) && !defined(FP_MAX_BITS)
         #if MIN_FFDHE_FP_MAX_BITS <= 8192
             #define FP_MAX_BITS 8192
         #else
             #define FP_MAX_BITS MIN_FFDHE_FP_MAX_BITS
         #endif
     #endif
 #endif
 
 /* If using the max strength build, ensure OLD TLS is disabled. */
 #ifdef WOLFSSL_MAX_STRENGTH
     #undef NO_OLD_TLS
     #define NO_OLD_TLS
 #endif
 
 
 /* Default AES minimum auth tag sz, allow user to override */
 #ifndef WOLFSSL_MIN_AUTH_TAG_SZ
     #define WOLFSSL_MIN_AUTH_TAG_SZ 12
 #endif
 
 
 /* sniffer requires:
  * static RSA cipher suites
  * session stats and peak stats
  */
 #ifdef WOLFSSL_SNIFFER
     #ifndef WOLFSSL_STATIC_RSA
         #define WOLFSSL_STATIC_RSA
     #endif
     #ifndef WOLFSSL_STATIC_DH
         #define WOLFSSL_STATIC_DH
     #endif
     /* Allow option to be disabled. */
     #ifndef WOLFSSL_NO_SESSION_STATS
         #ifndef WOLFSSL_SESSION_STATS
             #define WOLFSSL_SESSION_STATS
         #endif
         #ifndef WOLFSSL_PEAK_SESSIONS
             #define WOLFSSL_PEAK_SESSIONS
         #endif
     #endif
 #endif
 
 /* Decode Public Key extras on by default, user can turn off with
  * WOLFSSL_NO_DECODE_EXTRA */
 #ifndef WOLFSSL_NO_DECODE_EXTRA
     #ifndef RSA_DECODE_EXTRA
         #define RSA_DECODE_EXTRA
     #endif
     #ifndef ECC_DECODE_EXTRA
         #define ECC_DECODE_EXTRA
     #endif
 #endif
 
 /* C Sharp wrapper defines */
 #ifdef HAVE_CSHARP
     #ifndef WOLFSSL_DTLS
         #define WOLFSSL_DTLS
     #endif
     #undef NO_PSK
     #undef NO_SHA256
     #undef NO_DH
 #endif
 
 /* Asynchronous Crypto */
 #ifdef WOLFSSL_ASYNC_CRYPT
     /* Make sure wolf events are enabled */
     #undef HAVE_WOLF_EVENT
     #define HAVE_WOLF_EVENT
 
     #ifdef WOLFSSL_ASYNC_CRYPT_TEST
         #define WC_ASYNC_DEV_SIZE 168
     #else
         #define WC_ASYNC_DEV_SIZE 336
     #endif
 
     #if !defined(HAVE_CAVIUM) && !defined(HAVE_INTEL_QA) && \
         !defined(WOLFSSL_ASYNC_CRYPT_TEST)
         #error No async hardware defined with WOLFSSL_ASYNC_CRYPT!
     #endif
 
     /* Enable ECC_CACHE_CURVE for ASYNC */
     #if !defined(ECC_CACHE_CURVE)
         #define ECC_CACHE_CURVE
     #endif
 #endif /* WOLFSSL_ASYNC_CRYPT */
 #ifndef WC_ASYNC_DEV_SIZE
     #define WC_ASYNC_DEV_SIZE 0
 #endif
 
 /* leantls checks */
 #ifdef WOLFSSL_LEANTLS
     #ifndef HAVE_ECC
         #error leantls build needs ECC
     #endif
 #endif /* WOLFSSL_LEANTLS*/
 
 /* restriction with static memory */
 #ifdef WOLFSSL_STATIC_MEMORY
     #if defined(HAVE_IO_POOL) || defined(XMALLOC_USER) || defined(NO_WOLFSSL_MEMORY)
          #error static memory cannot be used with HAVE_IO_POOL, XMALLOC_USER or NO_WOLFSSL_MEMORY
     #endif
     #if !defined(USE_FAST_MATH) && !defined(NO_BIG_INT)
         #error static memory requires fast math please define USE_FAST_MATH
     #endif
     #ifdef WOLFSSL_SMALL_STACK
         #error static memory does not support small stack please undefine
     #endif
 #endif /* WOLFSSL_STATIC_MEMORY */
 
 #ifdef HAVE_AES_KEYWRAP
     #ifndef WOLFSSL_AES_DIRECT
         #error AES key wrap requires AES direct please define WOLFSSL_AES_DIRECT
     #endif
 #endif
 
 #ifdef HAVE_PKCS7
     #if defined(NO_AES) && defined(NO_DES3)
         #error PKCS7 needs either AES or 3DES enabled, please enable one
     #endif
     #ifndef HAVE_AES_KEYWRAP
         #error PKCS7 requires AES key wrap please define HAVE_AES_KEYWRAP
     #endif
     #if defined(HAVE_ECC) && !defined(HAVE_X963_KDF)
         #error PKCS7 requires X963 KDF please define HAVE_X963_KDF
     #endif
 #endif
 
 #ifndef NO_PKCS12
     #undef  HAVE_PKCS12
     #define HAVE_PKCS12
 #endif
 
 #ifndef NO_PKCS8
     #undef  HAVE_PKCS8
     #define HAVE_PKCS8
 #endif
 
 #if !defined(NO_PBKDF1) || defined(WOLFSSL_ENCRYPTED_KEYS) || defined(HAVE_PKCS8) || defined(HAVE_PKCS12)
     #undef  HAVE_PBKDF1
     #define HAVE_PBKDF1
 #endif
 
 #if !defined(NO_PBKDF2) || defined(HAVE_PKCS7) || defined(HAVE_SCRYPT)
     #undef  HAVE_PBKDF2
     #define HAVE_PBKDF2
 #endif
 
 
 #if !defined(WOLFCRYPT_ONLY) && !defined(NO_OLD_TLS) && \
         (defined(NO_SHA) || defined(NO_MD5))
     #error old TLS requires MD5 and SHA
 #endif
 
 /* for backwards compatibility */
 #if defined(TEST_IPV6) && !defined(WOLFSSL_IPV6)
     #define WOLFSSL_IPV6
 #endif
 
 
 #ifdef WOLFSSL_LINUXKM
     #ifndef NO_DEV_RANDOM
         #define NO_DEV_RANDOM
     #endif
     #ifndef NO_WRITEV
         #define NO_WRITEV
     #endif
     #ifndef NO_FILESYSTEM
         #define NO_FILESYSTEM
     #endif
     #ifndef NO_STDIO_FILESYSTEM
         #define NO_STDIO_FILESYSTEM
     #endif
     #ifndef WOLFSSL_NO_SOCK
         #define WOLFSSL_NO_SOCK
     #endif
     #ifndef WOLFSSL_DH_CONST
         #define WOLFSSL_DH_CONST
     #endif
     #ifndef WOLFSSL_USER_IO
         #define WOLFSSL_USER_IO
     #endif
     #ifndef USE_WOLF_STRTOK
         #define USE_WOLF_STRTOK
     #endif
     #ifndef WOLFSSL_SP_MOD_WORD_RP
         #define WOLFSSL_SP_MOD_WORD_RP
     #endif
     #ifndef WOLFSSL_OLD_PRIME_CHECK
         #define WOLFSSL_OLD_PRIME_CHECK
     #endif
     #undef HAVE_STRINGS_H
     #undef HAVE_ERRNO_H
     #undef HAVE_THREAD_LS
     #undef WOLFSSL_HAVE_MIN
     #undef WOLFSSL_HAVE_MAX
     #define SIZEOF_LONG         8
     #define SIZEOF_LONG_LONG    8
     #define CHAR_BIT            8
-    #define WOLFSSL_SP_DIV_64
-    #define WOLFSSL_SP_DIV_WORD_HALF
-    #define SP_HALF_SIZE        32
-    #define SP_HALF_MAX         4294967295U
+    #ifndef WOLFSSL_SP_DIV_64
+        #define WOLFSSL_SP_DIV_64
+    #endif
+    #ifndef WOLFSSL_SP_DIV_WORD_HALF
+        #define WOLFSSL_SP_DIV_WORD_HALF
+    #endif
+    #ifndef SP_HALF_SIZE
+        #define SP_HALF_SIZE        32
+    #endif
+    #ifndef SP_HALF_MAX
+        #define SP_HALF_MAX         4294967295U
+    #endif
 #endif
 
 
 /* Place any other flags or defines here */
 
 #if defined(WOLFSSL_MYSQL_COMPATIBLE) && defined(_WIN32) \
                                       && defined(HAVE_GMTIME_R)
     #undef HAVE_GMTIME_R /* don't trust macro with windows */
 #endif /* WOLFSSL_MYSQL_COMPATIBLE */
 
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)
     #define SSL_OP_NO_COMPRESSION    SSL_OP_NO_COMPRESSION
     #define OPENSSL_NO_ENGINE
     #define X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT
     #ifndef OPENSSL_EXTRA
         #define OPENSSL_EXTRA
     #endif
     #ifndef HAVE_SESSION_TICKET
         #define HAVE_SESSION_TICKET
     #endif
     #ifndef HAVE_OCSP
         #define HAVE_OCSP
     #endif
     #ifndef KEEP_OUR_CERT
         #define KEEP_OUR_CERT
     #endif
     #ifndef HAVE_SNI
         #define HAVE_SNI
     #endif
 #endif
 
 #if defined(WOLFSSL_NGINX) || defined(WOLFSSL_QT) || defined(OPENSSL_ALL)
     #define SSL_CTRL_SET_TLSEXT_HOSTNAME 55
 #endif
 
 
 /* both CURVE and ED small math should be enabled */
 #ifdef CURVED25519_SMALL
         #define CURVE25519_SMALL
         #define ED25519_SMALL
 #endif
 
 /* both CURVE and ED small math should be enabled */
 #ifdef CURVED448_SMALL
         #define CURVE448_SMALL
         #define ED448_SMALL
 #endif
 
 
 #ifndef WOLFSSL_ALERT_COUNT_MAX
     #define WOLFSSL_ALERT_COUNT_MAX 5
 #endif
 
 /* warning for not using harden build options (default with ./configure) */
 #ifndef WC_NO_HARDEN
     #if (defined(USE_FAST_MATH) && !defined(TFM_TIMING_RESISTANT)) || \
         (defined(HAVE_ECC) && !defined(ECC_TIMING_RESISTANT)) || \
         (!defined(NO_RSA) && !defined(WC_RSA_BLINDING) && !defined(HAVE_FIPS) && \
             !defined(WC_NO_RNG))
 
         #ifndef _MSC_VER
             #warning "For timing resistance / side-channel attack prevention consider using harden options"
         #else
             #pragma message("Warning: For timing resistance / side-channel attack prevention consider using harden options")
         #endif
     #endif
 #endif
 
 #if defined(NO_OLD_WC_NAMES) || defined(OPENSSL_EXTRA)
     /* added to have compatibility with SHA256() */
     #if !defined(NO_OLD_SHA_NAMES) && !defined(HAVE_FIPS)
         #define NO_OLD_SHA_NAMES
     #endif
 #endif
 
 /* switch for compatibility layer functionality. Has subparts i.e. BIO/X509
  * When opensslextra is enabled all subparts should be turned on. */
 #ifdef OPENSSL_EXTRA
     #undef  OPENSSL_EXTRA_X509_SMALL
     #define OPENSSL_EXTRA_X509_SMALL
 #endif /* OPENSSL_EXTRA */
 
 /* support for converting DER to PEM */
 #if (defined(WOLFSSL_KEY_GEN) && !defined(WOLFSSL_NO_DER_TO_PEM)) || \
     defined(WOLFSSL_CERT_GEN) || defined(OPENSSL_EXTRA)
     #undef  WOLFSSL_DER_TO_PEM
     #define WOLFSSL_DER_TO_PEM
 #endif
 
 /* keep backwards compatibility enabling encrypted private key */
 #ifndef WOLFSSL_ENCRYPTED_KEYS
     #if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL) || \
         defined(HAVE_WEBSERVER)
         #define WOLFSSL_ENCRYPTED_KEYS
     #endif
 #endif
 
 /* support for disabling PEM to DER */
 #if !defined(WOLFSSL_NO_PEM)
     #undef  WOLFSSL_PEM_TO_DER
     #define WOLFSSL_PEM_TO_DER
 #endif
 
 /* Parts of the openssl compatibility layer require peer certs */
 #if defined(OPENSSL_ALL) || defined(WOLFSSL_NGINX) || defined(WOLFSSL_HAPROXY)
     #undef  KEEP_PEER_CERT
     #define KEEP_PEER_CERT
 #endif
 
 /* RAW hash function APIs are not implemented with ARMv8 hardware acceleration*/
 #ifdef WOLFSSL_ARMASM
     #undef  WOLFSSL_NO_HASH_RAW
     #define WOLFSSL_NO_HASH_RAW
 #endif
 
 #if !defined(WOLFSSL_SHA384) && !defined(WOLFSSL_SHA512) && defined(NO_AES) && \
                                                           !defined(WOLFSSL_SHA3)
     #undef  WOLFSSL_NO_WORD64_OPS
     #define WOLFSSL_NO_WORD64_OPS
 #endif
 
 #if !defined(WOLFCRYPT_ONLY) && !defined(WOLFSSL_NO_TLS12)
     #undef  WOLFSSL_HAVE_PRF
     #define WOLFSSL_HAVE_PRF
 #endif
 
 #if defined(NO_AES) && defined(NO_DES3) && !defined(HAVE_CAMELLIA) && \
        !defined(WOLFSSL_HAVE_PRF) && defined(NO_PWDBASED) && !defined(HAVE_IDEA)
     #undef  WOLFSSL_NO_XOR_OPS
     #define WOLFSSL_NO_XOR_OPS
 #endif
 
 #if defined(NO_ASN) && defined(WOLFCRYPT_ONLY)
     #undef  WOLFSSL_NO_INT_ENCODE
     #define WOLFSSL_NO_INT_ENCODE
     #undef  WOLFSSL_NO_INT_DECODE
     #define WOLFSSL_NO_INT_DECODE
 #endif
 
 #if defined(WOLFCRYPT_ONLY) && defined(WOLFSSL_RSA_VERIFY_ONLY) && \
     defined(WC_NO_RSA_OAEP)
     #undef  WOLFSSL_NO_CT_OPS
     #define WOLFSSL_NO_CT_OPS
 #endif
 
 #if defined(WOLFCRYPT_ONLY) && defined(NO_AES) && !defined(HAVE_CURVE25519) && \
         !defined(HAVE_CURVE448) && defined(WC_NO_RNG) && defined(WC_NO_RSA_OAEP)
     #undef  WOLFSSL_NO_CONST_CMP
     #define WOLFSSL_NO_CONST_CMP
 #endif
 
 #if defined(WOLFCRYPT_ONLY) && defined(NO_AES) && !defined(WOLFSSL_SHA384) && \
     !defined(WOLFSSL_SHA512) && defined(WC_NO_RNG) && \
                     defined(WOLFSSL_SP_MATH) && defined(WOLFSSL_RSA_PUBLIC_ONLY)
     #undef  WOLFSSL_NO_FORCE_ZERO
     #define WOLFSSL_NO_FORCE_ZERO
 #endif
 
 /* Detect old cryptodev name */
 #if defined(WOLF_CRYPTO_DEV) && !defined(WOLF_CRYPTO_CB)
     #define WOLF_CRYPTO_CB
 #endif
 
 #if defined(WOLFSSL_TLS13) && defined(WOLFSSL_NO_SIGALG)
     #error TLS 1.3 requires the Signature Algorithms extension to be enabled
 #endif
 
 #ifndef NO_WOLFSSL_BASE64_DECODE
     #define WOLFSSL_BASE64_DECODE
 #endif
 
 #if defined(HAVE_EX_DATA) || defined(FORTRESS)
     #define MAX_EX_DATA 5  /* allow for five items of ex_data */
 #endif
 
 #ifdef NO_WOLFSSL_SMALL_STACK
     #undef WOLFSSL_SMALL_STACK
 #endif
 
 /* The client session cache requires time for timeout */
 #if defined(NO_ASN_TIME) && !defined(NO_SESSION_CACHE)
     #define NO_SESSION_CACHE
 #endif
 
 /* Use static ECC structs for Position Independant Code (PIC) */
 #if defined(__IAR_SYSTEMS_ICC__) && defined(__ROPI__)
     #define WOLFSSL_ECC_CURVE_STATIC
     #define WOLFSSL_NAMES_STATIC
     #define WOLFSSL_NO_CONSTCHARCONST
 #endif
 
 /* FIPS v1 does not support TLS v1.3 (requires RSA PSS and HKDF) */
 #if defined(HAVE_FIPS) && !defined(HAVE_FIPS_VERSION)
     #undef WC_RSA_PSS
     #undef WOLFSSL_TLS13
 #endif
 
 /* For FIPSv2 make sure the ECDSA encoding allows extra bytes
  * but make sure users consider enabling it */
 #if !defined(NO_STRICT_ECDSA_LEN) && defined(HAVE_FIPS) && \
         defined(HAVE_FIPS_VERSION) && (HAVE_FIPS_VERSION >= 2)
     /* ECDSA length checks off by default for CAVP testing
      * consider enabling strict checks in production */
     #define NO_STRICT_ECDSA_LEN
 #endif
 
 
 #ifdef __cplusplus
     }   /* extern "C" */
 #endif
 
 #endif
