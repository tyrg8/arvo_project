commit 8eeed3ef5e2bbd5b927bf1b72879c1fa9ab979cb
Author: Victor M. Alvarez <vmalvarez@virustotal.com>
Date:   Wed Dec 5 09:30:08 2018 +0100

    Fix use-after-free. Closes #996.

diff --git a/libyara/re.c b/libyara/re.c
index 6e37fbfd..c31d4f66 100644
--- a/libyara/re.c
+++ b/libyara/re.c
@@ -456,68 +456,67 @@ int yr_re_ast_contains_dot_star(
 int yr_re_ast_split_at_chaining_point(
     RE_AST* re_ast,
     RE_AST** result_re_ast,
     RE_AST** remainder_re_ast,
     int32_t* min_gap,
     int32_t* max_gap)
 {
   RE_NODE* child;
   RE_NODE* concat;
 
   int result;
 
   *result_re_ast = re_ast;
   *remainder_re_ast = NULL;
   *min_gap = 0;
   *max_gap = 0;
 
   if (re_ast->root_node->type != RE_NODE_CONCAT)
     return ERROR_SUCCESS;
 
   child = re_ast->root_node->children_head;
 
   while (child != NULL)
   {
     if (!child->greedy &&
          child->type == RE_NODE_RANGE_ANY &&
+         child->prev_sibling != NULL &&
+         child->next_sibling != NULL &&
         (child->start > YR_STRING_CHAINING_THRESHOLD ||
          child->end > YR_STRING_CHAINING_THRESHOLD))
     {
       result = yr_re_ast_create(remainder_re_ast);
 
       if (result != ERROR_SUCCESS)
         return result;
 
       concat = yr_re_node_create(RE_NODE_CONCAT);
 
       if (concat == NULL)
         return ERROR_INSUFFICIENT_MEMORY;
 
       concat->children_head = re_ast->root_node->children_head;
       concat->children_tail = child->prev_sibling;
 
       re_ast->root_node->children_head = child->next_sibling;
 
-      if (child->prev_sibling != NULL)
-        child->prev_sibling->next_sibling = NULL;
-
-      if (child->next_sibling != NULL)
-        child->next_sibling->prev_sibling = NULL;
+      child->prev_sibling->next_sibling = NULL;
+      child->next_sibling->prev_sibling = NULL;
 
       *min_gap = child->start;
       *max_gap = child->end;
 
       (*result_re_ast)->root_node = re_ast->root_node;
       (*result_re_ast)->flags = re_ast->flags;
       (*remainder_re_ast)->root_node = concat;
       (*remainder_re_ast)->flags = re_ast->flags;
 
       yr_re_node_destroy(child);
 
       return ERROR_SUCCESS;
     }
 
     child = child->next_sibling;
   }
 
   return ERROR_SUCCESS;
 }
diff --git a/tests/test-rules.c b/tests/test-rules.c
index a6b968d1..7ee59849 100644
--- a/tests/test-rules.c
+++ b/tests/test-rules.c
@@ -988,425 +988,430 @@ void test_for()
 void test_re()
 {
   assert_true_rule(
       "rule test { strings: $a = /ssi/ condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /ssi(s|p)/ condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /ssim*/ condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /ssa?/ condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /Miss/ nocase condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /(M|N)iss/ nocase condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /[M-N]iss/ nocase condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /(Mi|ssi)ssippi/ nocase condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /ppi\\tmi/ condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /ppi\\.mi/ condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /^mississippi/ fullword condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_true_rule(
       "rule test { strings: $a = /mississippi.*mississippi$/s condition: $a }",
       "mississippi\tmississippi.mississippi\nmississippi");
 
   assert_false_rule(
       "rule test { strings: $a = /^ssi/ condition: $a }",
       "mississippi");
 
   assert_false_rule(
       "rule test { strings: $a = /ssi$/ condition: $a }",
       "mississippi");
 
   assert_false_rule(
       "rule test { strings: $a = /ssissi/ fullword condition: $a }",
       "mississippi");
 
   assert_false_rule(
       "rule test { strings: $a = /^[isp]+/ condition: $a }",
       "mississippi");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 6 }",
       "a\0x\0b\0");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /a.{1,2}b/ wide condition: !a == 8 }",
       "a\0x\0x\0b\0");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /\\babc/ wide condition: $a }",
       "a\0b\0c\0");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /\\babc/ wide condition: $a }",
       "\0a\0b\0c\0");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /\\babc/ wide condition: $a }",
       "\ta\0b\0c\0");
 
   assert_false_rule_blob(
       "rule test { strings: $a = /\\babc/ wide condition: $a }",
       "x\0a\0b\0c\0");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /\\babc/ wide condition: $a }",
       "x\ta\0b\0c\0");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /abc\\b/ wide condition: $a }",
       "a\0b\0c\0");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /abc\\b/ wide condition: $a }",
       "a\0b\0c\0\0");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /abc\\b/ wide condition: $a }",
       "a\0b\0c\0\t");
 
   assert_false_rule_blob(
       "rule test { strings: $a = /abc\\b/ wide condition: $a }",
       "a\0b\0c\0x\0");
 
   assert_true_rule_blob(
       "rule test { strings: $a = /abc\\b/ wide condition: $a }",
       "a\0b\0c\0b\t");
 
   assert_false_rule_blob(
       "rule test { strings: $a = /\\b/ wide condition: $a }",
       "abc");
 
   assert_regexp_syntax_error(")");
   assert_true_regexp("abc", "abc", "abc");
   assert_false_regexp("abc", "xbc");
   assert_false_regexp("abc", "axc");
   assert_false_regexp("abc", "abx");
   assert_true_regexp("abc", "xabcx", "abc");
   assert_true_regexp("abc", "ababc", "abc");
   assert_true_regexp("a.c", "abc", "abc");
   assert_false_regexp("a.b", "a\nb");
   assert_false_regexp("a.*b", "acc\nccb");
   assert_false_regexp("a.{4,5}b", "acc\nccb");
   assert_true_regexp("a.b", "a\rb", "a\rb");
   assert_true_regexp("ab*c", "abc", "abc");
   assert_true_regexp("ab*c", "ac", "ac");
   assert_true_regexp("ab*bc", "abc", "abc");
   assert_true_regexp("ab*bc", "abbc", "abbc");
   assert_true_regexp("a.*bb", "abbbb", "abbbb");
   assert_true_regexp("a.*?bbb", "abbbbbb", "abbb");
   assert_true_regexp("a.*c", "ac", "ac");
   assert_true_regexp("a.*c", "axyzc", "axyzc");
   assert_true_regexp("ab+c", "abbc", "abbc");
   assert_false_regexp("ab+c", "ac");
   assert_true_regexp("ab+", "abbbb", "abbbb");
   assert_true_regexp("ab+?", "abbbb", "ab");
   assert_false_regexp("ab+bc", "abc");
   assert_false_regexp("ab+bc", "abq");
   assert_true_regexp("a+b+c", "aabbabc", "abc");
   assert_false_regexp("ab?bc", "abbbbc");
   assert_true_regexp("ab?c", "abc", "abc");
   assert_true_regexp("ab*?", "abbb", "a");
   assert_true_regexp("ab?c", "ac", "ac");
   assert_true_regexp("ab??", "ab", "a");
   assert_true_regexp("a(b|x)c", "abc", "abc");
   assert_true_regexp("a(b|x)c", "axc", "axc");
   assert_true_regexp("a(b|.)c", "axc", "axc");
   assert_true_regexp("a(b|x|y)c", "ayc", "ayc");
   assert_true_regexp("(a+|b)*", "ab", "ab");
   assert_true_regexp("a|b|c|d|e", "e", "e");
   assert_true_regexp("(a|b|c|d|e)f", "ef", "ef");
   assert_true_regexp("a|b", "a", "a");
   assert_true_regexp(".b{2}", "abb", "abb");
   assert_true_regexp(".b{2,3}", "abbb", "abbb");
   assert_true_regexp(".b{2,3}?", "abbb", "abb");
   assert_true_regexp("ab{2,3}c", "abbbc", "abbbc");
   assert_true_regexp("ab{2,3}?c", "abbbc", "abbbc");
   assert_true_regexp(".b{2,3}cccc", "abbbcccc", "abbbcccc");
   assert_true_regexp(".b{2,3}?cccc", "abbbcccc", "bbbcccc");
   assert_true_regexp("a.b{2,3}cccc", "aabbbcccc", "aabbbcccc");
   assert_true_regexp("ab{2,3}c", "abbbc", "abbbc");
   assert_true_regexp("ab{2,3}?c", "abbbc", "abbbc");
   assert_true_regexp("ab{0,1}?c", "abc", "abc");
   assert_true_regexp("a{0,1}?bc", "abc", "abc");
   assert_true_regexp("a{0,1}bc", "bbc", "bc");
   assert_true_regexp("a{0,1}?bc", "abc", "bc");
   assert_true_regexp("aa{0,1}?bc", "abc", "abc");
   assert_true_regexp("aa{0,1}?bc", "abc", "abc");
   assert_true_regexp("aa{0,1}bc", "abc", "abc");
   assert_true_regexp("ab{1}c", "abc", "abc");
   assert_true_regexp("ab{1,2}c", "abbc", "abbc");
   assert_false_regexp("ab{1,2}c", "abbbc");
   assert_true_regexp("ab{1,}c", "abbbc", "abbbc");
   assert_false_regexp("ab{1,}b", "ab");
   assert_false_regexp("ab{1}c", "abbc");
   assert_false_regexp("ab{1}c", "ac");
   assert_true_regexp("ab{0,}c", "ac", "ac");
   assert_true_regexp("ab{1,1}c", "abc", "abc");
   assert_true_regexp("ab{0,}c", "abbbc", "abbbc");
   assert_true_regexp("ab{,3}c", "abbbc", "abbbc");
   assert_false_regexp("ab{,2}c", "abbbc");
   assert_false_regexp("ab{4,5}bc", "abbbbc");
   assert_false_regexp("ab{3}c", "abbbbc");  // Issue #817
   assert_false_regexp("ab{4}c", "abbbbbc");
   assert_false_regexp("ab{5}c", "abbbbbbc");
   assert_true_regexp("ab{0,1}", "abbbbb", "ab");
   assert_true_regexp("ab{0,2}", "abbbbb", "abb");
   assert_true_regexp("ab{0,3}", "abbbbb", "abbb");
   assert_true_regexp("ab{0,4}", "abbbbb", "abbbb");
   assert_true_regexp("ab{1,1}", "abbbbb", "ab");
   assert_true_regexp("ab{1,2}", "abbbbb", "abb");
   assert_true_regexp("ab{1,3}", "abbbbb", "abbb");
   assert_true_regexp("ab{2,2}", "abbbbb", "abb");
   assert_true_regexp("ab{2,3}", "abbbbb", "abbb");
   assert_true_regexp("ab{2,4}", "abbbbc", "abbbb");
   assert_true_regexp("ab{3,4}", "abbb", "abbb");
   assert_true_regexp("ab{3,5}", "abbbbb", "abbbbb");
   assert_false_regexp("ab{3,4}c", "abbbbbc");
   assert_false_regexp("ab{3,4}c", "abbc");
   assert_false_regexp("ab{3,5}c", "abbbbbbc");
   assert_true_regexp("ab{1,3}?", "abbbbb", "ab");
   assert_true_regexp("ab{0,1}?", "abbbbb", "a");
   assert_true_regexp("ab{0,2}?", "abbbbb", "a");
   assert_true_regexp("ab{0,3}?", "abbbbb", "a");
   assert_true_regexp("ab{0,4}?", "abbbbb", "a");
   assert_true_regexp("ab{1,1}?", "abbbbb", "ab");
   assert_true_regexp("ab{1,2}?", "abbbbb", "ab");
   assert_true_regexp("ab{1,3}?", "abbbbb", "ab");
   assert_true_regexp("ab{2,2}?", "abbbbb", "abb");
   assert_true_regexp("ab{2,3}?", "abbbbb", "abb");
   assert_true_regexp(".(abc){0,1}", "xabcabcabcabc", "xabc");
   assert_true_regexp(".(abc){0,2}", "xabcabcabcabc", "xabcabc");
   assert_true_regexp("x{1,2}abcd", "xxxxabcd", "xxabcd");
   assert_true_regexp("x{1,2}abcd", "xxxxabcd", "xxabcd");
   assert_true_regexp("ab{.*}", "ab{c}", "ab{c}");
   assert_true_regexp(".(aa){1,2}", "aaaaaaaaaa", "aaaaa");
   assert_true_regexp("a.(bc.){2}", "aabcabca", "aabcabca");
   assert_true_regexp("(ab{1,2}c){1,3}", "abbcabc", "abbcabc");
   assert_true_regexp("ab(c|cc){1,3}d", "abccccccd", "abccccccd");
   assert_true_regexp("a[bx]c", "abc", "abc");
   assert_true_regexp("a[bx]c", "axc", "axc");
   assert_true_regexp("a[0-9]*b", "ab", "ab");
   assert_true_regexp("a[0-9]*b", "a0123456789b", "a0123456789b");
   assert_true_regexp("[0-9a-f]+", "0123456789abcdef", "0123456789abcdef");
   assert_true_regexp("[0-9a-f]+", "xyz0123456789xyz", "0123456789");
   assert_true_regexp("a[\\s\\S]b", "a b", "a b");
   assert_true_regexp("a[\\d\\D]b", "a1b", "a1b");
   assert_false_regexp("[x-z]+", "abc");
   assert_true_regexp("a[-]?c", "ac", "ac");
   assert_true_regexp("a[-b]", "a-", "a-");
   assert_true_regexp("a[-b]", "ab", "ab");
   assert_true_regexp("a[b-]", "a-", "a-");
   assert_true_regexp("a[b-]", "ab", "ab");
   assert_true_regexp("[a-c-e]", "b", "b");
   assert_true_regexp("[a-c-e]", "-", "-");
   assert_false_regexp("[a-c-e]", "d");
   assert_regexp_syntax_error("[b-a]");
   assert_regexp_syntax_error("(abc");
   assert_regexp_syntax_error("abc)");
   assert_regexp_syntax_error("a[]b");
   assert_true_regexp("a[\\-b]", "a-", "a-");
   assert_true_regexp("a[\\-b]", "ab", "ab");
   assert_true_regexp("a]", "a]", "a]");
   assert_true_regexp("a[]]b", "a]b", "a]b");
   assert_true_regexp("a[\\]]b", "a]b", "a]b");
   assert_true_regexp("a[^bc]d", "aed", "aed");
   assert_false_regexp("a[^bc]d", "abd");
   assert_true_regexp("a[^-b]c", "adc", "adc");
   assert_false_regexp("a[^-b]c", "a-c");
   assert_false_regexp("a[^]b]c", "a]c");
   assert_true_regexp("a[^]b]c", "adc", "adc");
   assert_true_regexp("[^ab]*", "cde", "cde");
   assert_regexp_syntax_error(")(");
   assert_true_regexp("a\\sb", "a b", "a b");
   assert_true_regexp("a\\sb", "a\tb", "a\tb");
   assert_true_regexp("a\\sb", "a\rb", "a\rb");
   assert_true_regexp("a\\sb", "a\nb", "a\nb");
   assert_true_regexp("a\\sb", "a\vb", "a\vb");
   assert_true_regexp("a\\sb", "a\fb", "a\fb");
   assert_false_regexp("a\\Sb", "a b");
   assert_false_regexp("a\\Sb", "a\tb");
   assert_false_regexp("a\\Sb", "a\rb");
   assert_false_regexp("a\\Sb", "a\nb");
   assert_false_regexp("a\\Sb", "a\vb");
   assert_false_regexp("a\\Sb", "a\fb");
   assert_true_regexp("\\n\\r\\t\\f\\a", "\n\r\t\f\a", "\n\r\t\f\a");
   assert_true_regexp("[\\n][\\r][\\t][\\f][\\a]", "\n\r\t\f\a", "\n\r\t\f\a");
   assert_true_regexp("\\x01\\x02\\x03", "\x01\x02\x03", "\x01\x02\x03");
   assert_true_regexp("[\\x01-\\x03]+", "\x01\x02\x03", "\x01\x02\x03");
   assert_false_regexp("[\\x00-\\x02]+", "\x03\x04\x05");
   assert_true_regexp("[\\x5D]", "]", "]");
   assert_true_regexp("[\\0x5A-\\x5D]", "\x5B", "\x5B");
   assert_true_regexp("[\\x5D-\\x5F]", "\x5E", "\x5E");
   assert_true_regexp("[\\x5C-\\x5F]", "\x5E", "\x5E");
   assert_true_regexp("[\\x5D-\\x5F]", "\x5E", "\x5E");
   assert_true_regexp("a\\wc", "abc", "abc");
   assert_true_regexp("a\\wc", "a_c", "a_c");
   assert_true_regexp("a\\wc", "a0c", "a0c");
   assert_false_regexp("a\\wc", "a*c");
   assert_true_regexp("\\w+", "--ab_cd0123--", "ab_cd0123");
   assert_true_regexp("[\\w]+", "--ab_cd0123--", "ab_cd0123");
   assert_true_regexp("\\D+", "1234abc5678", "abc");
   assert_true_regexp("[\\d]+", "0123456789", "0123456789");
   assert_true_regexp("[\\D]+", "1234abc5678", "abc");
   assert_true_regexp("[\\da-fA-F]+", "123abc", "123abc");
   assert_false_regexp("^(ab|cd)e", "abcde");
   assert_true_regexp("(abc|)ef", "abcdef", "ef");
   assert_true_regexp("(abc|)ef", "abcef", "abcef");
   assert_true_regexp("\\babc", "abc", "abc");
   assert_true_regexp("abc\\b", "abc", "abc");
   assert_false_regexp("\\babc", "1abc");
   assert_false_regexp("abc\\b", "abc1");
   assert_true_regexp("abc\\s\\b", "abc x", "abc ");
   assert_false_regexp("abc\\s\\b", "abc  ");
   assert_true_regexp("\\babc\\b", " abc ", "abc");
   assert_true_regexp("\\b\\w\\w\\w\\b", " abc ", "abc");
   assert_true_regexp("\\w\\w\\w\\b", "abcd", "bcd");
   assert_true_regexp("\\b\\w\\w\\w", "abcd", "abc");
   assert_false_regexp("\\b\\w\\w\\w\\b", "abcd");
   assert_false_regexp("\\Babc", "abc");
   assert_false_regexp("abc\\B", "abc");
   assert_true_regexp("\\Babc", "1abc", "abc");
   assert_true_regexp("abc\\B", "abc1", "abc");
   assert_false_regexp("abc\\s\\B", "abc x");
   assert_true_regexp("abc\\s\\B", "abc  ", "abc ");
   assert_true_regexp("\\w\\w\\w\\B", "abcd", "abc");
   assert_true_regexp("\\B\\w\\w\\w", "abcd", "bcd");
   assert_false_regexp("\\B\\w\\w\\w\\B", "abcd");
 
   // This is allowed in most regexp engines but in order to keep the
   // grammar free of shift/reduce conflicts I've decided not supporting
   // it. Users can use the (abc|) form instead.
   assert_regexp_syntax_error("(|abc)ef");
 
   assert_true_regexp("((a)(b)c)(d)", "abcd", "abcd");
   assert_true_regexp("(a|b)c*d", "abcd", "bcd");
   assert_true_regexp("(ab|ab*)bc", "abc", "abc");
   assert_true_regexp("a([bc]*)c*", "abc", "abc");
   assert_true_regexp("a([bc]*)c*", "ac", "ac");
   assert_true_regexp("a([bc]*)c*", "a", "a");
   assert_true_regexp("a([bc]*)(c*d)", "abcd", "abcd");
   assert_true_regexp("a([bc]+)(c*d)", "abcd", "abcd");
   assert_true_regexp("a([bc]*)(c+d)", "abcd", "abcd");
   assert_true_regexp("a[bcd]*dcdcde", "adcdcde", "adcdcde");
   assert_false_regexp("a[bcd]+dcdcde", "adcdcde");
   assert_true_regexp("\\((.*), (.*)\\)", "(a, b)", "(a, b)");
   assert_true_regexp("abc|123$", "abcx", "abc");
   assert_false_regexp("abc|123$", "123x");
   assert_true_regexp("abc|^123", "123", "123");
   assert_false_regexp("abc|^123", "x123");
   assert_true_regexp("^abc$", "abc", "abc");
   assert_false_regexp("^abc$", "abcc");
   assert_true_regexp("^abc", "abcc", "abc");
   assert_false_regexp("^abc$", "aabc");
   assert_false_regexp("abc^", "abc");
   assert_false_regexp("ab^c", "abc");
   assert_false_regexp("a^bcdef", "abcdef")
   assert_true_regexp("abc$", "aabc", "abc");
   assert_false_regexp("$abc", "abc");
   assert_true_regexp("(a|a$)bcd", "abcd", "abcd");
   assert_false_regexp("(a$|a$)bcd", "abcd");
   assert_false_regexp("(abc$|ab$)", "abcd");
   assert_true_regexp("^a(bc+|b[eh])g|.h$", "abhg", "abhg");
   assert_true_regexp("(bc+d$|ef*g.|h?i(j|k))", "effgz", "effgz");
   assert_true_regexp("(bc+d$|ef*g.|h?i(j|k))", "ij", "ij");
   assert_false_regexp("(bc+d$|ef*g.|h?i(j|k))", "effg");
   assert_false_regexp("(bc+d$|ef*g.|h?i(j|k))", "bcdd");
   assert_true_regexp("(bc+d$|ef*g.|h?i(j|k))", "reffgz", "effgz");
 
   // Test case for issue #324
   assert_true_regexp("whatever|   x.   x", "   xy   x", "   xy   x");
 
-  // test case for issue #503, \x without two following hex-digits
+  // Test case for issue #503, \x without two following hex-digits
   assert_regexp_syntax_error("\\x0");
   assert_regexp_syntax_error("\\x");
 
   assert_regexp_syntax_error("x{0,0}");
   assert_regexp_syntax_error("x{0}");
 
   assert_regexp_syntax_error("\\xxy");
 
   // Test case for issue #682
   assert_true_regexp("(a|\\b)[a]{1,}", "aaaa", "aaaa");
 
   // Test for integer overflow in repeat interval
   assert_regexp_syntax_error("a{2977952116}");
 
   assert_error(
       "rule test { strings: $a = /a\\/ condition: $a }",
       ERROR_SYNTAX_ERROR);
 
   assert_error(
       "rule test { strings: $a = /[a\\/ condition: $a }",
       ERROR_SYNTAX_ERROR);
 
+  // Test case for issue #996
+  assert_error(
+      "rule test {strings:$=/.{,}? /",
+      ERROR_SYNTAX_ERROR);
+
   assert_true_rule_blob(
       "rule test { \
         strings: $a = /MZ.{300,}t/ \
         condition: !a == 317 }",
       PE32_FILE);
 
   assert_true_rule_blob(
       "rule test { \
         strings: $a = /MZ.{300,}?t/ \
         condition: !a == 314 }",
       PE32_FILE);
 
   assert_false_rule(
       "rule test { strings: $a = /abc[^d]/ nocase condition: $a }",
       "abcd");
 
   assert_false_rule(
       "rule test { strings: $a = /abc[^d]/ condition: $a }",
       "abcd");
 
   assert_false_rule(
       "rule test { strings: $a = /abc[^D]/ nocase condition: $a }",
       "abcd");
 
   assert_true_rule(
       "rule test { strings: $a = /abc[^D]/ condition: $a }",
       "abcd");
 
   assert_true_rule(
       "rule test { strings: $a = /abc[^f]/ nocase condition: $a }",
       "abcd");
 
   assert_true_rule(
       "rule test { strings: $a = /abc[^f]/ condition: $a }",
       "abcd");
 
   assert_true_rule(
       "rule test { strings: $a = /abc[^F]/ nocase condition: $a }",
       "abcd");
 
   assert_true_rule(
        "rule test { strings: $a = /abc[^F]/ condition: $a }",
        "abcd");
 }
