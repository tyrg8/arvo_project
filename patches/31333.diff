commit f436c3029850c138e54a0de055d61db45130409e
Author: Thierry Coppey <tcknetwork@hotmail.com>
Date:   Thu Jan 6 16:21:51 2022 +0100

    Fix buffer overflows and other errors found with fuzzying. (#168)
    
    Fix multiple buffer overflow on input found with fuzzying.

diff --git a/src/md4c.c b/src/md4c.c
index 97200b2..48f0e44 100644
--- a/src/md4c.c
+++ b/src/md4c.c
@@ -2257,91 +2257,91 @@ static int
 md_is_inline_link_spec(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
                        OFF beg, OFF* p_end, MD_LINK_ATTR* attr)
 {
     int line_index = 0;
     int tmp_line_index;
     OFF title_contents_beg;
     OFF title_contents_end;
     int title_contents_line_index;
     int title_is_multiline;
     OFF off = beg;
     int ret = FALSE;
 
     while(off >= lines[line_index].end)
         line_index++;
 
     MD_ASSERT(CH(off) == _T('('));
     off++;
 
     /* Optional white space with up to one line break. */
     while(off < lines[line_index].end  &&  ISWHITESPACE(off))
         off++;
     if(off >= lines[line_index].end  &&  (off >= ctx->size  ||  ISNEWLINE(off))) {
         line_index++;
         if(line_index >= n_lines)
             return FALSE;
         off = lines[line_index].beg;
     }
 
     /* Link destination may be omitted, but only when not also having a title. */
     if(off < ctx->size  &&  CH(off) == _T(')')) {
         attr->dest_beg = off;
         attr->dest_end = off;
         attr->title = NULL;
         attr->title_size = 0;
         attr->title_needs_free = FALSE;
         off++;
         *p_end = off;
         return TRUE;
     }
 
     /* Link destination. */
     if(!md_is_link_destination(ctx, off, lines[line_index].end,
                         &off, &attr->dest_beg, &attr->dest_end))
         return FALSE;
 
     /* (Optional) title. */
     if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,
                 &off, &title_contents_line_index, &tmp_line_index,
                 &title_contents_beg, &title_contents_end))
     {
         title_is_multiline = (tmp_line_index != title_contents_line_index);
         title_contents_line_index += line_index;
         line_index += tmp_line_index;
     } else {
         /* Not a title. */
         title_is_multiline = FALSE;
         title_contents_beg = off;
         title_contents_end = off;
         title_contents_line_index = 0;
     }
 
     /* Optional whitespace followed with final ')'. */
     while(off < lines[line_index].end  &&  ISWHITESPACE(off))
         off++;
-    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {
+    if (off >= lines[line_index].end  &&  (off >= ctx->size || ISNEWLINE(off))) {
         line_index++;
         if(line_index >= n_lines)
             return FALSE;
         off = lines[line_index].beg;
     }
     if(CH(off) != _T(')'))
         goto abort;
     off++;
 
     if(title_contents_beg >= title_contents_end) {
         attr->title = NULL;
         attr->title_size = 0;
         attr->title_needs_free = FALSE;
     } else if(!title_is_multiline) {
         attr->title = (CHAR*) STR(title_contents_beg);
         attr->title_size = title_contents_end - title_contents_beg;
         attr->title_needs_free = FALSE;
     } else {
         MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,
                     lines + title_contents_line_index, n_lines - title_contents_line_index,
                     _T('\n'), &attr->title, &attr->title_size));
         attr->title_needs_free = TRUE;
     }
 
     *p_end = off;
     ret = TRUE;
@@ -2485,13 +2485,14 @@ static MD_MARKCHAIN*
 md_mark_chain(MD_CTX* ctx, int mark_index)
 {
     MD_MARK* mark = &ctx->marks[mark_index];
 
     switch(mark->ch) {
         case _T('*'):   return md_asterisk_chain(ctx, mark->flags);
         case _T('_'):   return &UNDERSCORE_OPENERS;
         case _T('~'):   return (mark->end - mark->beg == 1) ? &TILDE_OPENERS_1 : &TILDE_OPENERS_2;
+        case _T('!'):   MD_FALLTHROUGH();
         case _T('['):   return &BRACKET_OPENERS;
         case _T('|'):   return &TABLECELLBOUNDARIES;
         default:        return NULL;
     }
 }
@@ -2624,63 +2625,66 @@ static void
 md_rollback(MD_CTX* ctx, int opener_index, int closer_index, int how)
 {
     int i;
     int mark_index;
 
     /* Cut all unresolved openers at the mark index. */
     for(i = OPENERS_CHAIN_FIRST; i < OPENERS_CHAIN_LAST+1; i++) {
         MD_MARKCHAIN* chain = &ctx->mark_chains[i];
 
-        while(chain->tail >= opener_index)
+        while(chain->tail >= opener_index) {
+            int same = chain->tail == opener_index;
             chain->tail = ctx->marks[chain->tail].prev;
+            if (same) break;
+        }
 
         if(chain->tail >= 0)
             ctx->marks[chain->tail].next = -1;
         else
             chain->head = -1;
     }
 
     /* Go backwards so that unresolved openers are re-added into their
      * respective chains, in the right order. */
     mark_index = closer_index - 1;
     while(mark_index > opener_index) {
         MD_MARK* mark = &ctx->marks[mark_index];
         int mark_flags = mark->flags;
         int discard_flag = (how == MD_ROLLBACK_ALL);
 
         if(mark->flags & MD_MARK_CLOSER) {
             int mark_opener_index = mark->prev;
 
             /* Undo opener BEFORE the range. */
             if(mark_opener_index < opener_index) {
                 MD_MARK* mark_opener = &ctx->marks[mark_opener_index];
                 MD_MARKCHAIN* chain;
 
                 mark_opener->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);
                 chain = md_mark_chain(ctx, opener_index);
                 if(chain != NULL) {
                     md_mark_chain_append(ctx, chain, mark_opener_index);
                     discard_flag = 1;
                 }
             }
         }
 
         /* And reset our flags. */
         if(discard_flag)
             mark->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);
 
         /* Jump as far as we can over unresolved or non-interesting marks. */
         switch(how) {
             case MD_ROLLBACK_CROSSING:
                 if((mark_flags & MD_MARK_CLOSER)  &&  mark->prev > opener_index) {
                     /* If we are closer with opener INSIDE the range, there may
                      * not be any other crosser inside the subrange. */
                     mark_index = mark->prev;
                     break;
                 }
                 MD_FALLTHROUGH();
             default:
                 mark_index--;
                 break;
         }
     }
 }
@@ -3836,85 +3840,87 @@ static void
 md_analyze_permissive_url_autolink(MD_CTX* ctx, int mark_index)
 {
     MD_MARK* opener = &ctx->marks[mark_index];
     int closer_index = mark_index + 1;
     MD_MARK* closer = &ctx->marks[closer_index];
     MD_MARK* next_resolved_mark;
     OFF off = opener->end;
     int n_dots = FALSE;
     int has_underscore_in_last_seg = FALSE;
     int has_underscore_in_next_to_last_seg = FALSE;
     int n_opened_parenthesis = 0;
     int n_excess_parenthesis = 0;
 
     /* Check for domain. */
     while(off < ctx->size) {
         if(ISALNUM(off) || CH(off) == _T('-')) {
             off++;
         } else if(CH(off) == _T('.')) {
             /* We must see at least one period. */
             n_dots++;
             has_underscore_in_next_to_last_seg = has_underscore_in_last_seg;
             has_underscore_in_last_seg = FALSE;
             off++;
         } else if(CH(off) == _T('_')) {
             /* No underscore may be present in the last two domain segments. */
             has_underscore_in_last_seg = TRUE;
             off++;
         } else {
             break;
         }
     }
     if(off > opener->end  &&  CH(off-1) == _T('.')) {
         off--;
         n_dots--;
     }
     if(off <= opener->end || n_dots == 0 || has_underscore_in_next_to_last_seg || has_underscore_in_last_seg)
         return;
 
     /* Check for path. */
     next_resolved_mark = closer + 1;
     while(next_resolved_mark->ch == 'D' || !(next_resolved_mark->flags & MD_MARK_RESOLVED))
         next_resolved_mark++;
     while(off < next_resolved_mark->beg  &&  CH(off) != _T('<')  &&  !ISWHITESPACE(off)  &&  !ISNEWLINE(off)) {
         /* Parenthesis must be balanced. */
         if(CH(off) == _T('(')) {
             n_opened_parenthesis++;
         } else if(CH(off) == _T(')')) {
             if(n_opened_parenthesis > 0)
                 n_opened_parenthesis--;
             else
                 n_excess_parenthesis++;
         }
 
         off++;
     }
 
     /* Trim a trailing punctuation from the end. */
     while(TRUE) {
         if(ISANYOF(off-1, _T("?!.,:*_~"))) {
             off--;
         } else if(CH(off-1) == ')'  &&  n_excess_parenthesis > 0) {
             /* Unmatched ')' can be in an interior of the path but not at the
              * of it, so the auto-link may be safely nested in a parenthesis
              * pair. */
             off--;
             n_excess_parenthesis--;
         } else {
             break;
         }
     }
 
     /* Ok. Lets call it an auto-link. Adapt opener and create closer to zero
      * length so all the contents becomes the link text. */
-    MD_ASSERT(closer->ch == 'D');
+    MD_ASSERT(closer->ch == 'D' ||
+              (ctx->parser.flags & MD_FLAG_PERMISSIVEWWWAUTOLINKS &&
+               (closer->ch == '.' || closer->ch == ':' || closer->ch == '@')));
     opener->end = opener->beg;
     closer->ch = opener->ch;
     closer->beg = off;
     closer->end = off;
     md_resolve_range(ctx, NULL, mark_index, closer_index);
 }
 
 /* The permissive autolinks do not have to be enclosed in '<' '>' but we
  * instead impose stricter rules what is understood as an e-mail address
  * here. Actually any non-alphanumeric characters with exception of '.'
  * are prohibited both in username and after '@'. */
@@ -3922,43 +3928,43 @@ static void
 md_analyze_permissive_email_autolink(MD_CTX* ctx, int mark_index)
 {
     MD_MARK* opener = &ctx->marks[mark_index];
     int closer_index;
     MD_MARK* closer;
     OFF beg = opener->beg;
     OFF end = opener->end;
     int dot_count = 0;
 
-    MD_ASSERT(CH(beg) == _T('@'));
+    MD_ASSERT(opener->ch == _T('@'));
 
     /* Scan for name before '@'. */
     while(beg > 0  &&  (ISALNUM(beg-1) || ISANYOF(beg-1, _T(".-_+"))))
         beg--;
 
     /* Scan for domain after '@'. */
     while(end < ctx->size  &&  (ISALNUM(end) || ISANYOF(end, _T(".-_")))) {
         if(CH(end) == _T('.'))
             dot_count++;
         end++;
     }
     if(CH(end-1) == _T('.')) {  /* Final '.' not part of it. */
         dot_count--;
         end--;
     }
     else if(ISANYOF2(end-1, _T('-'), _T('_'))) /* These are forbidden at the end. */
         return;
     if(CH(end-1) == _T('@')  ||  dot_count == 0)
         return;
 
     /* Ok. Lets call it auto-link. Adapt opener and create closer to zero
      * length so all the contents becomes the link text. */
     closer_index = mark_index + 1;
     closer = &ctx->marks[closer_index];
-    MD_ASSERT(closer->ch == 'D');
+    if (closer->ch != 'D') return;
 
     opener->beg = beg;
     opener->end = beg;
     closer->ch = opener->ch;
     closer->beg = end;
     closer->end = end;
     md_resolve_range(ctx, NULL, mark_index, closer_index);
 }
@@ -4123,280 +4129,280 @@ static int
 md_process_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
 {
     MD_TEXTTYPE text_type;
     const MD_LINE* line = lines;
     MD_MARK* prev_mark = NULL;
     MD_MARK* mark;
     OFF off = lines[0].beg;
     OFF end = lines[n_lines-1].end;
     int enforce_hardbreak = 0;
     int ret = 0;
 
     /* Find first resolved mark. Note there is always at least one resolved
      * mark,  the dummy last one after the end of the latest line we actually
      * never really reach. This saves us of a lot of special checks and cases
      * in this function. */
     mark = ctx->marks;
     while(!(mark->flags & MD_MARK_RESOLVED))
         mark++;
 
     text_type = MD_TEXT_NORMAL;
 
     while(1) {
         /* Process the text up to the next mark or end-of-line. */
         OFF tmp = (line->end < mark->beg ? line->end : mark->beg);
         if(tmp > off) {
             MD_TEXT(text_type, STR(off), tmp - off);
             off = tmp;
         }
 
         /* If reached the mark, process it and move to next one. */
         if(off >= mark->beg) {
             switch(mark->ch) {
                 case '\\':      /* Backslash escape. */
                     if(ISNEWLINE(mark->beg+1))
                         enforce_hardbreak = 1;
                     else
                         MD_TEXT(text_type, STR(mark->beg+1), 1);
                     break;
 
                 case ' ':       /* Non-trivial space. */
                     MD_TEXT(text_type, _T(" "), 1);
                     break;
 
                 case '`':       /* Code span. */
                     if(mark->flags & MD_MARK_OPENER) {
                         MD_ENTER_SPAN(MD_SPAN_CODE, NULL);
                         text_type = MD_TEXT_CODE;
                     } else {
                         MD_LEAVE_SPAN(MD_SPAN_CODE, NULL);
                         text_type = MD_TEXT_NORMAL;
                     }
                     break;
 
                 case '_':       /* Underline (or emphasis if we fall through). */
                     if(ctx->parser.flags & MD_FLAG_UNDERLINE) {
                         if(mark->flags & MD_MARK_OPENER) {
                             while(off < mark->end) {
                                 MD_ENTER_SPAN(MD_SPAN_U, NULL);
                                 off++;
                             }
                         } else {
                             while(off < mark->end) {
                                 MD_LEAVE_SPAN(MD_SPAN_U, NULL);
                                 off++;
                             }
                         }
                         break;
                     }
                     MD_FALLTHROUGH();
 
                 case '*':       /* Emphasis, strong emphasis. */
                     if(mark->flags & MD_MARK_OPENER) {
                         if((mark->end - off) % 2) {
                             MD_ENTER_SPAN(MD_SPAN_EM, NULL);
                             off++;
                         }
                         while(off + 1 < mark->end) {
                             MD_ENTER_SPAN(MD_SPAN_STRONG, NULL);
                             off += 2;
                         }
                     } else {
                         while(off + 1 < mark->end) {
                             MD_LEAVE_SPAN(MD_SPAN_STRONG, NULL);
                             off += 2;
                         }
                         if((mark->end - off) % 2) {
                             MD_LEAVE_SPAN(MD_SPAN_EM, NULL);
                             off++;
                         }
                     }
                     break;
 
                 case '~':
                     if(mark->flags & MD_MARK_OPENER)
                         MD_ENTER_SPAN(MD_SPAN_DEL, NULL);
                     else
                         MD_LEAVE_SPAN(MD_SPAN_DEL, NULL);
                     break;
 
                 case '$':
                     if(mark->flags & MD_MARK_OPENER) {
                         MD_ENTER_SPAN((mark->end - off) % 2 ? MD_SPAN_LATEXMATH : MD_SPAN_LATEXMATH_DISPLAY, NULL);
                         text_type = MD_TEXT_LATEXMATH;
                     } else {
                         MD_LEAVE_SPAN((mark->end - off) % 2 ? MD_SPAN_LATEXMATH : MD_SPAN_LATEXMATH_DISPLAY, NULL);
                         text_type = MD_TEXT_NORMAL;
                     }
                     break;
 
                 case '[':       /* Link, wiki link, image. */
                 case '!':
                 case ']':
                 {
                     const MD_MARK* opener = (mark->ch != ']' ? mark : &ctx->marks[mark->prev]);
                     const MD_MARK* closer = &ctx->marks[opener->next];
                     const MD_MARK* dest_mark;
                     const MD_MARK* title_mark;
 
                     if ((opener->ch == '[' && closer->ch == ']') &&
                         opener->end - opener->beg >= 2 &&
                         closer->end - closer->beg >= 2)
                     {
                         int has_label = (opener->end - opener->beg > 2);
                         SZ target_sz;
 
                         if(has_label)
                             target_sz = opener->end - (opener->beg+2);
                         else
                             target_sz = closer->beg - opener->end;
 
                         MD_CHECK(md_enter_leave_span_wikilink(ctx, (mark->ch != ']'),
                                  has_label ? STR(opener->beg+2) : STR(opener->end),
                                  target_sz));
 
                         break;
                     }
 
                     dest_mark = opener+1;
                     MD_ASSERT(dest_mark->ch == 'D');
                     title_mark = opener+2;
-                    MD_ASSERT(title_mark->ch == 'D');
+                    if (title_mark->ch != 'D') break;
 
                     MD_CHECK(md_enter_leave_span_a(ctx, (mark->ch != ']'),
                                 (opener->ch == '!' ? MD_SPAN_IMG : MD_SPAN_A),
                                 STR(dest_mark->beg), dest_mark->end - dest_mark->beg, FALSE,
                                 md_mark_get_ptr(ctx, (int)(title_mark - ctx->marks)),
 								title_mark->prev));
 
                     /* link/image closer may span multiple lines. */
                     if(mark->ch == ']') {
                         while(mark->end > line->end)
                             line++;
                     }
 
                     break;
                 }
 
                 case '<':
                 case '>':       /* Autolink or raw HTML. */
                     if(!(mark->flags & MD_MARK_AUTOLINK)) {
                         /* Raw HTML. */
                         if(mark->flags & MD_MARK_OPENER)
                             text_type = MD_TEXT_HTML;
                         else
                             text_type = MD_TEXT_NORMAL;
                         break;
                     }
                     /* Pass through, if auto-link. */
                     MD_FALLTHROUGH();
 
                 case '@':       /* Permissive e-mail autolink. */
                 case ':':       /* Permissive URL autolink. */
                 case '.':       /* Permissive WWW autolink. */
                 {
                     MD_MARK* opener = ((mark->flags & MD_MARK_OPENER) ? mark : &ctx->marks[mark->prev]);
                     MD_MARK* closer = &ctx->marks[opener->next];
                     const CHAR* dest = STR(opener->end);
                     SZ dest_size = closer->beg - opener->end;
 
                     /* For permissive auto-links we do not know closer mark
                      * position at the time of md_collect_marks(), therefore
                      * it can be out-of-order in ctx->marks[].
                      *
                      * With this flag, we make sure that we output the closer
                      * only if we processed the opener. */
                     if(mark->flags & MD_MARK_OPENER)
                         closer->flags |= MD_MARK_VALIDPERMISSIVEAUTOLINK;
 
                     if(opener->ch == '@' || opener->ch == '.') {
                         dest_size += 7;
                         MD_TEMP_BUFFER(dest_size * sizeof(CHAR));
                         memcpy(ctx->buffer,
                                 (opener->ch == '@' ? _T("mailto:") : _T("http://")),
                                 7 * sizeof(CHAR));
                         memcpy(ctx->buffer + 7, dest, (dest_size-7) * sizeof(CHAR));
                         dest = ctx->buffer;
                     }
 
                     if(closer->flags & MD_MARK_VALIDPERMISSIVEAUTOLINK)
                         MD_CHECK(md_enter_leave_span_a(ctx, (mark->flags & MD_MARK_OPENER),
                                     MD_SPAN_A, dest, dest_size, TRUE, NULL, 0));
                     break;
                 }
 
                 case '&':       /* Entity. */
                     MD_TEXT(MD_TEXT_ENTITY, STR(mark->beg), mark->end - mark->beg);
                     break;
 
                 case '\0':
                     MD_TEXT(MD_TEXT_NULLCHAR, _T(""), 1);
                     break;
 
                 case 127:
                     goto abort;
             }
 
             off = mark->end;
 
             /* Move to next resolved mark. */
             prev_mark = mark;
             mark++;
             while(!(mark->flags & MD_MARK_RESOLVED)  ||  mark->beg < off)
                 mark++;
         }
 
         /* If reached end of line, move to next one. */
         if(off >= line->end) {
             /* If it is the last line, we are done. */
             if(off >= end)
                 break;
 
             if(text_type == MD_TEXT_CODE || text_type == MD_TEXT_LATEXMATH) {
                 OFF tmp;
 
                 MD_ASSERT(prev_mark != NULL);
                 MD_ASSERT(ISANYOF2_(prev_mark->ch, '`', '$')  &&  (prev_mark->flags & MD_MARK_OPENER));
                 MD_ASSERT(ISANYOF2_(mark->ch, '`', '$')  &&  (mark->flags & MD_MARK_CLOSER));
 
                 /* Inside a code span, trailing line whitespace has to be
                  * outputted. */
                 tmp = off;
                 while(off < ctx->size  &&  ISBLANK(off))
                     off++;
                 if(off > tmp)
                     MD_TEXT(text_type, STR(tmp), off-tmp);
 
                 /* and new lines are transformed into single spaces. */
                 if(prev_mark->end < off  &&  off < mark->beg)
                     MD_TEXT(text_type, _T(" "), 1);
             } else if(text_type == MD_TEXT_HTML) {
                 /* Inside raw HTML, we output the new line verbatim, including
                  * any trailing spaces. */
                 OFF tmp = off;
 
                 while(tmp < end  &&  ISBLANK(tmp))
                     tmp++;
                 if(tmp > off)
                     MD_TEXT(MD_TEXT_HTML, STR(off), tmp - off);
                 MD_TEXT(MD_TEXT_HTML, _T("\n"), 1);
             } else {
                 /* Output soft or hard line break. */
                 MD_TEXTTYPE break_type = MD_TEXT_SOFTBR;
 
                 if(text_type == MD_TEXT_NORMAL) {
                     if(enforce_hardbreak)
                         break_type = MD_TEXT_BR;
                     else if((CH(line->end) == _T(' ') && CH(line->end+1) == _T(' ')))
                         break_type = MD_TEXT_BR;
                 }
 
                 MD_TEXT(break_type, _T("\n"), 1);
             }
 
             /* Move to the next line. */
             line++;
             off = line->beg;
 
             enforce_hardbreak = 0;
         }
     }
@@ -5462,53 +5468,49 @@ static int
 md_is_html_block_end_condition(MD_CTX* ctx, OFF beg, OFF* p_end)
 {
     switch(ctx->html_block_type) {
         case 1:
         {
             OFF off = beg;
 
             while(off < ctx->size  &&  !ISNEWLINE(off)) {
                 if(CH(off) == _T('<')) {
-                    if(md_ascii_case_eq(STR(off), _T("</script>"), 9)) {
-                        *p_end = off + 9;
-                        return TRUE;
-                    }
-
-                    if(md_ascii_case_eq(STR(off), _T("</style>"), 8)) {
-                        *p_end = off + 8;
-                        return TRUE;
-                    }
-
-                    if(md_ascii_case_eq(STR(off), _T("</pre>"), 6)) {
-                        *p_end = off + 6;
-                        return TRUE;
+                  #define FIND_TAG_END(string, length) \
+                    if(off + length <= ctx->size && \
+                       md_ascii_case_eq(STR(off), _T(string), length)) { \
+                        *p_end = off + length; \
+                        return TRUE; \
                     }
+                  FIND_TAG_END("</script>", 9)
+                  FIND_TAG_END("</style>", 8)
+                  FIND_TAG_END("</pre>", 6)
+                  #undef FIND_TAG_END
                 }
 
                 off++;
             }
             *p_end = off;
             return FALSE;
         }
 
         case 2:
             return (md_line_contains(ctx, beg, _T("-->"), 3, p_end) ? 2 : FALSE);
 
         case 3:
             return (md_line_contains(ctx, beg, _T("?>"), 2, p_end) ? 3 : FALSE);
 
         case 4:
             return (md_line_contains(ctx, beg, _T(">"), 1, p_end) ? 4 : FALSE);
 
         case 5:
             return (md_line_contains(ctx, beg, _T("]]>"), 3, p_end) ? 5 : FALSE);
 
         case 6:     /* Pass through */
         case 7:
             *p_end = beg;
-            return (ISNEWLINE(beg) ? ctx->html_block_type : FALSE);
+            return (beg >= ctx->size || ISNEWLINE(beg) ? ctx->html_block_type : FALSE);
 
         default:
             MD_UNREACHABLE();
     }
     return FALSE;
 }
@@ -5725,475 +5727,476 @@ static int
 md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,
                 const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)
 {
     unsigned total_indent = 0;
     int n_parents = 0;
     int n_brothers = 0;
     int n_children = 0;
     MD_CONTAINER container = { 0 };
     int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;
     OFF off = beg;
     OFF hr_killer = 0;
     int ret = 0;
 
     line->indent = md_line_indentation(ctx, total_indent, off, &off);
     total_indent += line->indent;
     line->beg = off;
 
     /* Given the indentation and block quote marks '>', determine how many of
      * the current containers are our parents. */
     while(n_parents < ctx->n_containers) {
         MD_CONTAINER* c = &ctx->containers[n_parents];
 
         if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&
             off < ctx->size  &&  CH(off) == _T('>'))
         {
             /* Block quote mark. */
             off++;
             total_indent++;
             line->indent = md_line_indentation(ctx, total_indent, off, &off);
             total_indent += line->indent;
 
             /* The optional 1st space after '>' is part of the block quote mark. */
             if(line->indent > 0)
                 line->indent--;
 
             line->beg = off;
 
         } else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {
             /* List. */
             line->indent -= c->contents_indent;
         } else {
             break;
         }
 
         n_parents++;
     }
 
     if(off >= ctx->size  ||  ISNEWLINE(off)) {
         /* Blank line does not need any real indentation to be nested inside
          * a list. */
         if(n_brothers + n_children == 0) {
             while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))
                 n_parents++;
         }
     }
 
     while(TRUE) {
         /* Check whether we are fenced code continuation. */
         if(pivot_line->type == MD_LINE_FENCEDCODE) {
             line->beg = off;
 
             /* We are another MD_LINE_FENCEDCODE unless we are closing fence
              * which we transform into MD_LINE_BLANK. */
             if(line->indent < ctx->code_indent_offset) {
                 if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {
                     line->type = MD_LINE_BLANK;
                     ctx->last_line_has_list_loosening_effect = FALSE;
                     break;
                 }
             }
 
             /* Change indentation accordingly to the initial code fence. */
             if(n_parents == ctx->n_containers) {
                 if(line->indent > pivot_line->indent)
                     line->indent -= pivot_line->indent;
                 else
                     line->indent = 0;
 
                 line->type = MD_LINE_FENCEDCODE;
                 break;
             }
         }
 
         /* Check whether we are HTML block continuation. */
         if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {
             if(n_parents < ctx->n_containers) {
                 /* HTML block is implicitly ended if the enclosing container
                  * block ends. */
                 ctx->html_block_type = 0;
             } else {
                 int html_block_type;
 
                 html_block_type = md_is_html_block_end_condition(ctx, off, &off);
                 if(html_block_type > 0) {
                     MD_ASSERT(html_block_type == ctx->html_block_type);
 
                     /* Make sure this is the last line of the block. */
                     ctx->html_block_type = 0;
 
                     /* Some end conditions serve as blank lines at the same time. */
                     if(html_block_type == 6 || html_block_type == 7) {
                         line->type = MD_LINE_BLANK;
                         line->indent = 0;
                         break;
                     }
                 }
 
                 line->type = MD_LINE_HTML;
                 n_parents = ctx->n_containers;
                 break;
             }
         }
 
         /* Check for blank line. */
         if(off >= ctx->size  ||  ISNEWLINE(off)) {
             if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {
                 line->type = MD_LINE_INDENTEDCODE;
                 if(line->indent > ctx->code_indent_offset)
                     line->indent -= ctx->code_indent_offset;
                 else
                     line->indent = 0;
                 ctx->last_line_has_list_loosening_effect = FALSE;
             } else {
                 line->type = MD_LINE_BLANK;
                 ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&
                         n_brothers + n_children == 0  &&
                         ctx->containers[n_parents-1].ch != _T('>'));
 
     #if 1
                 /* See https://github.com/mity/md4c/issues/6
                  *
                  * This ugly checking tests we are in (yet empty) list item but
                  * not its very first line (i.e. not the line with the list
                  * item mark).
                  *
                  * If we are such a blank line, then any following non-blank
                  * line which would be part of the list item actually has to
                  * end the list because according to the specification, "a list
                  * item can begin with at most one blank line."
                  */
                 if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
                    n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
                    ctx->n_block_bytes > (int) sizeof(MD_BLOCK))
                 {
                     MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
                     if(top_block->type == MD_BLOCK_LI)
                         ctx->last_list_item_starts_with_two_blank_lines = TRUE;
                 }
     #endif
             }
             break;
         } else {
     #if 1
             /* This is the 2nd half of the hack. If the flag is set (i.e. there
              * was a 2nd blank line at the beginning of the list item) and if
              * we would otherwise still belong to the list item, we enforce
              * the end of the list. */
             ctx->last_line_has_list_loosening_effect = FALSE;
             if(ctx->last_list_item_starts_with_two_blank_lines) {
                 if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
                    n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
                    ctx->n_block_bytes > (int) sizeof(MD_BLOCK))
                 {
                     MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
                     if(top_block->type == MD_BLOCK_LI)
                         n_parents--;
                 }
 
                 ctx->last_list_item_starts_with_two_blank_lines = FALSE;
             }
     #endif
         }
 
         /* Check whether we are Setext underline. */
         if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT
             &&  off < ctx->size  &&  ISANYOF2(off, _T('='), _T('-'))
             &&  (n_parents == ctx->n_containers))
         {
             unsigned level;
 
             if(md_is_setext_underline(ctx, off, &off, &level)) {
                 line->type = MD_LINE_SETEXTUNDERLINE;
                 line->data = level;
                 break;
             }
         }
 
         /* Check for thematic break line. */
         if(line->indent < ctx->code_indent_offset
             &&  off < ctx->size  &&  off >= hr_killer
             &&  ISANYOF(off, _T("-_*")))
         {
             if(md_is_hr_line(ctx, off, &off, &hr_killer)) {
                 line->type = MD_LINE_HR;
                 break;
             }
         }
 
         /* Check for "brother" container. I.e. whether we are another list item
          * in already started list. */
         if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {
             OFF tmp;
 
             if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&
                md_is_container_compatible(&ctx->containers[n_parents], &container))
             {
                 pivot_line = &md_dummy_blank_line;
 
                 off = tmp;
 
                 total_indent += container.contents_indent - container.mark_indent;
                 line->indent = md_line_indentation(ctx, total_indent, off, &off);
                 total_indent += line->indent;
                 line->beg = off;
 
                 /* Some of the following whitespace actually still belongs to the mark. */
                 if(off >= ctx->size || ISNEWLINE(off)) {
                     container.contents_indent++;
                 } else if(line->indent <= ctx->code_indent_offset) {
                     container.contents_indent += line->indent;
                     line->indent = 0;
                 } else {
                     container.contents_indent += 1;
                     line->indent--;
                 }
 
                 ctx->containers[n_parents].mark_indent = container.mark_indent;
                 ctx->containers[n_parents].contents_indent = container.contents_indent;
 
                 n_brothers++;
                 continue;
             }
         }
 
         /* Check for indented code.
          * Note indented code block cannot interrupt a paragraph. */
         if(line->indent >= ctx->code_indent_offset  &&
             (pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))
         {
             line->type = MD_LINE_INDENTEDCODE;
             MD_ASSERT(line->indent >= ctx->code_indent_offset);
             line->indent -= ctx->code_indent_offset;
             line->data = 0;
             break;
         }
 
         /* Check for start of a new container block. */
         if(line->indent < ctx->code_indent_offset  &&
            md_is_container_mark(ctx, line->indent, off, &off, &container))
         {
             if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
                         (off >= ctx->size || ISNEWLINE(off))  &&  container.ch != _T('>'))
             {
                 /* Noop. List mark followed by a blank line cannot interrupt a paragraph. */
             } else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
                         ISANYOF2_(container.ch, _T('.'), _T(')'))  &&  container.start != 1)
             {
                 /* Noop. Ordered list cannot interrupt a paragraph unless the start index is 1. */
             } else {
                 total_indent += container.contents_indent - container.mark_indent;
                 line->indent = md_line_indentation(ctx, total_indent, off, &off);
                 total_indent += line->indent;
 
                 line->beg = off;
                 line->data = container.ch;
 
                 /* Some of the following whitespace actually still belongs to the mark. */
                 if(off >= ctx->size || ISNEWLINE(off)) {
                     container.contents_indent++;
                 } else if(line->indent <= ctx->code_indent_offset) {
                     container.contents_indent += line->indent;
                     line->indent = 0;
                 } else {
                     container.contents_indent += 1;
                     line->indent--;
                 }
 
                 if(n_brothers + n_children == 0)
                     pivot_line = &md_dummy_blank_line;
 
                 if(n_children == 0)
                     MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));
 
                 n_children++;
                 MD_CHECK(md_push_container(ctx, &container));
                 continue;
             }
         }
 
         /* Check whether we are table continuation. */
         if(pivot_line->type == MD_LINE_TABLE  &&  n_parents == ctx->n_containers) {
             line->type = MD_LINE_TABLE;
             break;
         }
 
         /* Check for ATX header. */
         if(line->indent < ctx->code_indent_offset  &&
                 off < ctx->size  &&  CH(off) == _T('#'))
         {
             unsigned level;
 
             if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {
                 line->type = MD_LINE_ATXHEADER;
                 line->data = level;
                 break;
             }
         }
 
         /* Check whether we are starting code fence. */
         if(off < ctx->size  &&  ISANYOF2(off, _T('`'), _T('~'))) {
             if(md_is_opening_code_fence(ctx, off, &off)) {
                 line->type = MD_LINE_FENCEDCODE;
                 line->data = 1;
                 break;
             }
         }
 
         /* Check for start of raw HTML block. */
         if(off < ctx->size  &&  CH(off) == _T('<')
             &&  !(ctx->parser.flags & MD_FLAG_NOHTMLBLOCKS))
         {
             ctx->html_block_type = md_is_html_block_start_condition(ctx, off);
 
             /* HTML block type 7 cannot interrupt paragraph. */
             if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)
                 ctx->html_block_type = 0;
 
             if(ctx->html_block_type > 0) {
                 /* The line itself also may immediately close the block. */
                 if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {
                     /* Make sure this is the last line of the block. */
                     ctx->html_block_type = 0;
                 }
 
                 line->type = MD_LINE_HTML;
                 break;
             }
         }
 
         /* Check for table underline. */
         if((ctx->parser.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT
             &&  off < ctx->size  &&  ISANYOF3(off, _T('|'), _T('-'), _T(':'))
             &&  n_parents == ctx->n_containers)
         {
             unsigned col_count;
 
             if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&
                 md_is_table_underline(ctx, off, &off, &col_count))
             {
                 line->data = col_count;
                 line->type = MD_LINE_TABLEUNDERLINE;
                 break;
             }
         }
 
         /* By default, we are normal text line. */
         line->type = MD_LINE_TEXT;
         if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {
             /* Lazy continuation. */
             n_parents = ctx->n_containers;
         }
 
         /* Check for task mark. */
         if((ctx->parser.flags & MD_FLAG_TASKLISTS)  &&  n_brothers + n_children > 0  &&
            ISANYOF_(ctx->containers[ctx->n_containers-1].ch, _T("-+*.)")))
         {
             OFF tmp = off;
 
             while(tmp < ctx->size  &&  tmp < off + 3  &&  ISBLANK(tmp))
                 tmp++;
             if(tmp + 2 < ctx->size  &&  CH(tmp) == _T('[')  &&
                ISANYOF(tmp+1, _T("xX "))  &&  CH(tmp+2) == _T(']')  &&
                (tmp + 3 == ctx->size  ||  ISBLANK(tmp+3)  ||  ISNEWLINE(tmp+3)))
             {
                 MD_CONTAINER* task_container = (n_children > 0 ? &ctx->containers[ctx->n_containers-1] : &container);
                 task_container->is_task = TRUE;
                 task_container->task_mark_off = tmp + 1;
                 off = tmp + 3;
-                while(ISWHITESPACE(off))
+                while(off < ctx->size && ISWHITESPACE(off))
                     off++;
+                if (off == ctx->size) break;
                 line->beg = off;
             }
         }
 
         break;
     }
 
     /* Scan for end of the line.
      *
      * Note this is quite a bottleneck of the parsing as we here iterate almost
      * over compete document.
      */
 #if defined __linux__ && !defined MD4C_USE_UTF16
     /* Recent glibc versions have superbly optimized strcspn(), even using
      * vectorization if available. */
     if(ctx->doc_ends_with_newline  &&  off < ctx->size) {
         while(TRUE) {
             off += (OFF) strcspn(STR(off), "\r\n");
 
             /* strcspn() can stop on zero terminator; but that can appear
              * anywhere in the Markfown input... */
             if(CH(off) == _T('\0'))
                 off++;
             else
                 break;
         }
     } else
 #endif
     {
         /* Optimization: Use some loop unrolling. */
         while(off + 3 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)
                                    &&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))
             off += 4;
         while(off < ctx->size  &&  !ISNEWLINE(off))
             off++;
     }
 
     /* Set end of the line. */
     line->end = off;
 
     /* But for ATX header, we should exclude the optional trailing mark. */
     if(line->type == MD_LINE_ATXHEADER) {
         OFF tmp = line->end;
         while(tmp > line->beg && CH(tmp-1) == _T(' '))
             tmp--;
         while(tmp > line->beg && CH(tmp-1) == _T('#'))
             tmp--;
         if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS))
             line->end = tmp;
     }
 
     /* Trim trailing spaces. */
     if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {
         while(line->end > line->beg && CH(line->end-1) == _T(' '))
             line->end--;
     }
 
     /* Eat also the new line. */
     if(off < ctx->size && CH(off) == _T('\r'))
         off++;
     if(off < ctx->size && CH(off) == _T('\n'))
         off++;
 
     *p_end = off;
 
     /* If we belong to a list after seeing a blank line, the list is loose. */
     if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {
         MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];
         if(c->ch != _T('>')) {
             MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);
             block->flags |= MD_BLOCK_LOOSE_LIST;
         }
     }
 
     /* Leave any containers we are not part of anymore. */
     if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)
         MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));
 
     /* Enter any container we found a mark for. */
     if(n_brothers > 0) {
         MD_ASSERT(n_brothers == 1);
         MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,
                     ctx->containers[n_parents].task_mark_off,
                     (ctx->containers[n_parents].is_task ? CH(ctx->containers[n_parents].task_mark_off) : 0),
                     MD_BLOCK_CONTAINER_CLOSER));
         MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,
                     container.task_mark_off,
                     (container.is_task ? CH(container.task_mark_off) : 0),
                     MD_BLOCK_CONTAINER_OPENER));
         ctx->containers[n_parents].is_task = container.is_task;
         ctx->containers[n_parents].task_mark_off = container.task_mark_off;
     }
 
     if(n_children > 0)
         MD_CHECK(md_enter_child_containers(ctx, n_children));
