commit afa70ddff5cbf887cee26264c00ce12d08553bca
Author: Harish Mahendrakar <harish.mahendrakar@ittiam.com>
Date:   Tue Nov 17 06:44:57 2020 +0530

    Validate input dimensions in process()
    
    Input dimensions are checked for supported range in set_dimensions
    control call. Encoder returns an error for unsupported values in
    this control call. But if the caller ignores this error and proceeds
    to call process(), encoder wasn't checking the dimensions again.
    
    Unsupported dimensions are now checked in process() call as well.
    
    Note: This is relanding previously reverted commit
    06c30b33c400afcf175916dea34f8b09599b58e5
    
    Bug: 172908358
    Test: Poc in bug
    Test: atest android.mediav2.cts
    Test: atest android.media.cts
    Change-Id: Icf3f296ab24432c680427a82da3505491acca3bd

diff --git a/encoder/ih264e_api.c b/encoder/ih264e_api.c
index 61ef6b5..53067e0 100644
--- a/encoder/ih264e_api.c
+++ b/encoder/ih264e_api.c
@@ -129,2115 +129,2220 @@
 /*****************************************************************************/
 /* Function Declarations                                                     */
 /*****************************************************************************/
 WORD32 ih264e_get_rate_control_mem_tab(void *pv_rate_control,
                                        iv_mem_rec_t *ps_mem,
                                        ITT_FUNC_TYPE_E e_func_type);
 
 
 /*****************************************************************************/
 /* Function Definitions                                                      */
 /*****************************************************************************/
 
+/**
+*******************************************************************************
+*
+* @brief
+*  Used to test validity of input dimensions
+*
+* @par Description:
+*  Dimensions of the input buffer passed to encode call are validated
+*
+* @param[in] ps_codec
+*  Codec context
+*
+* @param[in] ps_ip
+*  Pointer to input structure
+*
+* @param[out] ps_op
+*  Pointer to output structure
+*
+* @returns error status
+*
+* @remarks none
+*
+*******************************************************************************
+*/
+static IV_STATUS_T api_check_input_dimensions(codec_t *ps_codec,
+                                              ih264e_video_encode_ip_t *ps_ip,
+                                              ih264e_video_encode_op_t *ps_op)
+{
+    UWORD32 u4_wd, u4_ht;
+    cfg_params_t *ps_curr_cfg = &ps_codec->s_cfg;
+    iv_raw_buf_t *ps_inp_buf = &ps_ip->s_ive_ip.s_inp_buf;
+
+    u4_wd = ps_inp_buf->au4_wd[0];
+    u4_ht = ps_inp_buf->au4_ht[0];
+    switch (ps_inp_buf->e_color_fmt)
+    {
+        case IV_YUV_420P:
+            if (((ps_inp_buf->au4_wd[0] / 2) != ps_inp_buf->au4_wd[1]) ||
+                            ((ps_inp_buf->au4_wd[0] / 2) != ps_inp_buf->au4_wd[2]) ||
+                            (ps_inp_buf->au4_wd[1] != ps_inp_buf->au4_wd[2]))
+            {
+                ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                ps_op->s_ive_op.u4_error_code |= IH264E_WIDTH_NOT_SUPPORTED;
+                return (IV_FAIL);
+            }
+            if (((ps_inp_buf->au4_ht[0] / 2) != ps_inp_buf->au4_ht[1]) ||
+                            ((ps_inp_buf->au4_ht[0] / 2) != ps_inp_buf->au4_ht[2]) ||
+                            (ps_inp_buf->au4_ht[1] != ps_inp_buf->au4_ht[2]))
+            {
+                ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                ps_op->s_ive_op.u4_error_code |= IH264E_HEIGHT_NOT_SUPPORTED;
+                return (IV_FAIL);
+            }
+            break;
+        case IV_YUV_420SP_UV:
+        case IV_YUV_420SP_VU:
+            if ((ps_inp_buf->au4_wd[0] / 2) != ps_inp_buf->au4_wd[1])
+            {
+                ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                ps_op->s_ive_op.u4_error_code |= IH264E_WIDTH_NOT_SUPPORTED;
+                return (IV_FAIL);
+            }
+            if ((ps_inp_buf->au4_ht[0] / 2) != ps_inp_buf->au4_ht[1])
+            {
+                ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                ps_op->s_ive_op.u4_error_code |= IH264E_HEIGHT_NOT_SUPPORTED;
+                return (IV_FAIL);
+            }
+            break;
+        case IV_YUV_422ILE:
+            u4_wd = ps_inp_buf->au4_wd[0] / 2;
+            break;
+        default:
+            ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+            ps_op->s_ive_op.u4_error_code |= IH264E_INPUT_CHROMA_FORMAT_NOT_SUPPORTED;
+            return (IV_FAIL);
+    }
+
+    if (u4_wd != ps_curr_cfg->u4_disp_wd)
+    {
+        ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+        ps_op->s_ive_op.u4_error_code |= IH264E_WIDTH_NOT_SUPPORTED;
+        return (IV_FAIL);
+    }
+
+    if (u4_ht != ps_curr_cfg->u4_disp_ht)
+    {
+        ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+        ps_op->s_ive_op.u4_error_code |= IH264E_HEIGHT_NOT_SUPPORTED;
+        return (IV_FAIL);
+    }
+
+    return IV_SUCCESS;
+}
+
 /**
 *******************************************************************************
 *
 * @brief
 *  Used to test arguments for corresponding API call
 *
 * @par Description:
 *  For each command the arguments are validated
 *
 * @param[in] ps_handle
 *  Codec handle at API level
 *
 * @param[in] pv_api_ip
 *  Pointer to input structure
 *
 * @param[out] pv_api_op
 *  Pointer to output structure
 *
 * @returns error status
 *
 * @remarks none
 *
 *******************************************************************************
 */
 static IV_STATUS_T api_check_struct_sanity(iv_obj_t *ps_handle,
                                            void *pv_api_ip,
                                            void *pv_api_op)
 {
     /* api call */
     WORD32 command = IV_CMD_NA;
 
     /* input structure expected by the api call */
     UWORD32 *pu4_api_ip = pv_api_ip;
 
     /* output structure expected by the api call */
     UWORD32 *pu4_api_op = pv_api_op;
 
     /* temp var */
     WORD32 i, j;
 
     if (NULL == pv_api_op || NULL == pv_api_ip)
     {
         return (IV_FAIL);
     }
 
     /* get command */
     command = pu4_api_ip[1];
 
     /* set error code */
     pu4_api_op[1] = 0;
 
     /* error checks on handle */
     switch (command)
     {
         case IV_CMD_GET_NUM_MEM_REC:
         case IV_CMD_FILL_NUM_MEM_REC:
             break;
 
         case IV_CMD_INIT:
             if (ps_handle == NULL)
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_HANDLE_NULL;
                 return IV_FAIL;
             }
 
             if (ps_handle->u4_size != sizeof(iv_obj_t))
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_HANDLE_STRUCT_SIZE_INCORRECT;
                 return IV_FAIL;
             }
             break;
 
         case IVE_CMD_QUEUE_INPUT:
         case IVE_CMD_QUEUE_OUTPUT:
         case IVE_CMD_DEQUEUE_OUTPUT:
         case IVE_CMD_GET_RECON:
         case IV_CMD_RETRIEVE_MEMREC:
         case IVE_CMD_VIDEO_CTL:
         case IVE_CMD_VIDEO_ENCODE:
 
             if (ps_handle == NULL)
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_HANDLE_NULL;
                 return IV_FAIL;
             }
 
             if (ps_handle->u4_size != sizeof(iv_obj_t))
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_HANDLE_STRUCT_SIZE_INCORRECT;
                 return IV_FAIL;
             }
 
             if (ps_handle->pv_fxns != ih264e_api_function)
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_API_FUNCTION_PTR_NULL;
                 return IV_FAIL;
             }
 
             if (ps_handle->pv_codec_handle == NULL)
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_INVALID_CODEC_HANDLE;
                 return IV_FAIL;
             }
             break;
 
         default:
             *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
             *(pu4_api_op + 1) |= IVE_ERR_INVALID_API_CMD;
             return IV_FAIL;
     }
 
     /* error checks on input output structures */
     switch (command)
     {
         case IV_CMD_GET_NUM_MEM_REC:
         {
             ih264e_num_mem_rec_ip_t *ps_ip = pv_api_ip;
             ih264e_num_mem_rec_op_t *ps_op = pv_api_op;
 
             ps_op->s_ive_op.u4_error_code = 0;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_num_mem_rec_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_GET_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_num_mem_rec_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_GET_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
             break;
         }
 
         case IV_CMD_FILL_NUM_MEM_REC:
         {
             ih264e_fill_mem_rec_ip_t *ps_ip = pv_api_ip;
             ih264e_fill_mem_rec_op_t *ps_op = pv_api_op;
 
             iv_mem_rec_t *ps_mem_rec = NULL;
 
             WORD32 max_wd = ALIGN16(ps_ip->s_ive_ip.u4_max_wd);
             WORD32 max_ht = ALIGN16(ps_ip->s_ive_ip.u4_max_ht);
 
             ps_op->s_ive_op.u4_error_code = 0;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_fill_mem_rec_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_FILL_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_fill_mem_rec_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_FILL_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (max_wd < MIN_WD || max_wd > MAX_WD)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_WIDTH_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (max_ht < MIN_HT || max_ht > MAX_HT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_HEIGHT_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             /* verify number of mem rec ptr */
             if (NULL == ps_ip->s_ive_ip.ps_mem_rec)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_FILL_NUM_MEM_RECS_POINTER_NULL;
                 return (IV_FAIL);
             }
 
             /* verify number of mem records */
             if (ps_ip->s_ive_ip.u4_num_mem_rec != MEM_REC_CNT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_NUM_MEM_REC_NOT_SUFFICIENT;
                 return IV_FAIL;
             }
 
             /* check mem records sizes are correct */
             ps_mem_rec = ps_ip->s_ive_ip.ps_mem_rec;
             for (i = 0; i < MEM_REC_CNT; i++)
             {
                 if (ps_mem_rec[i].u4_size != sizeof(iv_mem_rec_t))
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IVE_ERR_MEM_REC_STRUCT_SIZE_INCORRECT;
                     return IV_FAIL;
                 }
             }
             break;
         }
 
         case IV_CMD_INIT:
         {
             ih264e_init_ip_t *ps_ip = pv_api_ip;
             ih264e_init_op_t *ps_op = pv_api_op;
 
             iv_mem_rec_t *ps_mem_rec = NULL;
 
             WORD32 max_wd = ALIGN16(ps_ip->s_ive_ip.u4_max_wd);
             WORD32 max_ht = ALIGN16(ps_ip->s_ive_ip.u4_max_ht);
 
             ps_op->s_ive_op.u4_error_code = 0;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_init_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_INIT_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_init_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_INIT_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (max_wd < MIN_WD || max_wd > MAX_WD)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_WIDTH_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (max_ht < MIN_HT || max_ht > MAX_HT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_HEIGHT_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_ref_cnt > MAX_REF_PIC_CNT ||
                            ps_ip->s_ive_ip.u4_max_ref_cnt < MIN_REF_PIC_CNT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_NUM_REF_UNSUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_reorder_cnt != 0)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_NUM_REORDER_UNSUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_10)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_1B)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_11)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_12)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_13)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_20)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_21)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_22)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_30)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_31)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_32)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_40)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_41)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_42)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_50)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_51))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_CODEC_LEVEL_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420P)
                             && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_422ILE)
                             && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420SP_UV)
                             && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420SP_VU))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_INPUT_CHROMA_FORMAT_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.e_recon_color_fmt != IV_YUV_420P)
                             && (ps_ip->s_ive_ip.e_recon_color_fmt != IV_YUV_420SP_UV)
                             && (ps_ip->s_ive_ip.e_recon_color_fmt != IV_YUV_420SP_VU))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_RECON_CHROMA_FORMAT_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.e_rc_mode != IVE_RC_NONE)
                             && (ps_ip->s_ive_ip.e_rc_mode != IVE_RC_STORAGE)
                             && (ps_ip->s_ive_ip.e_rc_mode != IVE_RC_CBR_NON_LOW_DELAY))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_RATE_CONTROL_MODE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_framerate > DEFAULT_MAX_FRAMERATE)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_FRAME_RATE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_bitrate > DEFAULT_MAX_BITRATE)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_BITRATE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_num_bframes > MAX_NUM_BFRAMES)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_BFRAMES_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_num_bframes
                             && (ps_ip->s_ive_ip.u4_max_ref_cnt < 2))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_BFRAMES_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.e_content_type != IV_PROGRESSIVE)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_CONTENT_TYPE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_srch_rng_x > DEFAULT_MAX_SRCH_RANGE_X)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_HORIZONTAL_SEARCH_RANGE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_srch_rng_y > DEFAULT_MAX_SRCH_RANGE_Y)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_VERTICAL_SEARCH_RANGE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.e_slice_mode != IVE_SLICE_MODE_NONE)
                             && (ps_ip->s_ive_ip.e_slice_mode != IVE_SLICE_MODE_BLOCKS))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_SLICE_TYPE_INPUT_INVALID;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.e_slice_mode == IVE_SLICE_MODE_BLOCKS)
             {
                 if (ps_ip->s_ive_ip.u4_slice_param == 0
                                 || ps_ip->s_ive_ip.u4_slice_param > ((UWORD32)max_ht >> 4))
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IH264E_SLICE_PARAM_INPUT_INVALID;
                     return (IV_FAIL);
                 }
             }
 
             if (NULL == ps_ip->s_ive_ip.ps_mem_rec)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_FILL_NUM_MEM_RECS_POINTER_NULL;
                 return (IV_FAIL);
             }
 
             /* verify number of mem records */
             if (ps_ip->s_ive_ip.u4_num_mem_rec != MEM_REC_CNT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_NUM_MEM_REC_NOT_SUFFICIENT;
                 return (IV_FAIL);
             }
 
             ps_mem_rec = ps_ip->s_ive_ip.ps_mem_rec;
 
             /* check memrecords sizes are correct */
             for (i = 0; i <((WORD32)ps_ip->s_ive_ip.u4_num_mem_rec); i++)
             {
                 if (ps_mem_rec[i].u4_size != sizeof(iv_mem_rec_t))
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IVE_ERR_MEM_REC_STRUCT_SIZE_INCORRECT;
                     return IV_FAIL;
                 }
 
                 /* check memrecords pointers are not NULL */
                 if (ps_mem_rec[i].pv_base == NULL)
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IVE_ERR_MEM_REC_BASE_POINTER_NULL;
                     return IV_FAIL;
                 }
             }
 
             /* verify memtabs for overlapping regions */
             {
                 void *start[MEM_REC_CNT];
                 void *end[MEM_REC_CNT];
 
                 start[0] = (ps_mem_rec[0].pv_base);
                 end[0] = ((UWORD8 *) ps_mem_rec[0].pv_base)
                                 + ps_mem_rec[0].u4_mem_size - 1;
 
                 for (i = 1; i < MEM_REC_CNT; i++)
                 {
                     /* This array is populated to check memtab overlap */
                     start[i] = (ps_mem_rec[i].pv_base);
                     end[i] = ((UWORD8 *) ps_mem_rec[i].pv_base)
                                     + ps_mem_rec[i].u4_mem_size - 1;
 
                     for (j = 0; j < i; j++)
                     {
                         if ((start[i] >= start[j]) && (start[i] <= end[j]))
                         {
                             ps_op->s_ive_op.u4_error_code |= 1
                                             << IVE_UNSUPPORTEDPARAM;
                             ps_op->s_ive_op.u4_error_code |=
                                             IVE_ERR_MEM_REC_OVERLAP_ERR;
                             return IV_FAIL;
                         }
 
                         if ((end[i] >= start[j]) && (end[i] <= end[j]))
                         {
                             ps_op->s_ive_op.u4_error_code |= 1
                                             << IVE_UNSUPPORTEDPARAM;
                             ps_op->s_ive_op.u4_error_code |=
                                             IVE_ERR_MEM_REC_OVERLAP_ERR;
                             return IV_FAIL;
                         }
 
                         if ((start[i] < start[j]) && (end[i] > end[j]))
                         {
                             ps_op->s_ive_op.u4_error_code |= 1
                                             << IVE_UNSUPPORTEDPARAM;
                             ps_op->s_ive_op.u4_error_code |=
                                             IVE_ERR_MEM_REC_OVERLAP_ERR;
                             return IV_FAIL;
                         }
                     }
                 }
             }
 
             /* re-validate mem records with init config */
             {
                 /* mem records */
                 iv_mem_rec_t s_mem_rec_ittiam_api[MEM_REC_CNT];
 
                 /* api interface structs */
                 ih264e_fill_mem_rec_ip_t s_ip;
                 ih264e_fill_mem_rec_op_t s_op;
 
                 /* error status */
                 IV_STATUS_T e_status;
 
                 /* temp var */
                 WORD32 i;
 
                 s_ip.s_ive_ip.u4_size = sizeof(ih264e_fill_mem_rec_ip_t);
                 s_op.s_ive_op.u4_size = sizeof(ih264e_fill_mem_rec_op_t);
 
                 s_ip.s_ive_ip.e_cmd = IV_CMD_FILL_NUM_MEM_REC;
                 s_ip.s_ive_ip.ps_mem_rec = s_mem_rec_ittiam_api;
                 s_ip.s_ive_ip.u4_max_wd = max_wd;
                 s_ip.s_ive_ip.u4_max_ht = max_ht;
                 s_ip.s_ive_ip.u4_num_mem_rec = ps_ip->s_ive_ip.u4_num_mem_rec;
                 s_ip.s_ive_ip.u4_max_level = ps_ip->s_ive_ip.u4_max_level;
                 s_ip.s_ive_ip.u4_max_ref_cnt = ps_ip->s_ive_ip.u4_max_ref_cnt;
                 s_ip.s_ive_ip.u4_max_reorder_cnt =
                                 ps_ip->s_ive_ip.u4_max_reorder_cnt;
                 s_ip.s_ive_ip.e_color_format = ps_ip->s_ive_ip.e_inp_color_fmt;
                 s_ip.s_ive_ip.u4_max_srch_rng_x =
                                 ps_ip->s_ive_ip.u4_max_srch_rng_x;
                 s_ip.s_ive_ip.u4_max_srch_rng_y =
                                 ps_ip->s_ive_ip.u4_max_srch_rng_y;
 
                 for (i = 0; i < MEM_REC_CNT; i++)
                 {
                     s_mem_rec_ittiam_api[i].u4_size = sizeof(iv_mem_rec_t);
                 }
 
                 /* fill mem records */
                 e_status = ih264e_api_function(NULL, (void *) &s_ip,
                                                (void *) &s_op);
 
                 if (IV_FAIL == e_status)
                 {
                     ps_op->s_ive_op.u4_error_code = s_op.s_ive_op.u4_error_code;
                     return (IV_FAIL);
                 }
 
                 /* verify mem records */
                 for (i = 0; i < MEM_REC_CNT; i++)
                 {
                     if (ps_mem_rec[i].u4_mem_size
                                     < s_mem_rec_ittiam_api[i].u4_mem_size)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_MEM_REC_INSUFFICIENT_SIZE;
 
                         return IV_FAIL;
                     }
 
                     if (ps_mem_rec[i].u4_mem_alignment
                                     != s_mem_rec_ittiam_api[i].u4_mem_alignment)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_MEM_REC_ALIGNMENT_ERR;
 
                         return IV_FAIL;
                     }
 
                     if (ps_mem_rec[i].e_mem_type
                                     != s_mem_rec_ittiam_api[i].e_mem_type)
                     {
                         UWORD32 check = IV_SUCCESS;
                         UWORD32 diff = s_mem_rec_ittiam_api[i].e_mem_type
                                         - ps_mem_rec[i].e_mem_type;
 
                         if ((ps_mem_rec[i].e_mem_type
                                         <= IV_EXTERNAL_CACHEABLE_SCRATCH_MEM)
                                         && (s_mem_rec_ittiam_api[i].e_mem_type
                                                         >= IV_INTERNAL_NONCACHEABLE_PERSISTENT_MEM))
                         {
                             check = IV_FAIL;
                         }
 
                         if (3 != (s_mem_rec_ittiam_api[i].e_mem_type % 4))
                         {
                             /* It is not IV_EXTERNAL_NONCACHEABLE_PERSISTENT_MEM or
                              * IV_EXTERNAL_CACHEABLE_PERSISTENT_MEM */
 
                             if ((diff < 1) || (diff > 3))
                             {
                                 /* Difference between 1 and 3 is okay for all cases other than the
                                  * two filtered with the MOD condition above */
                                 check = IV_FAIL;
                             }
                         }
                         else
                         {
                             if (diff == 1)
                             {
                                 /* This particular case is when codec asked for External Persistent,
                                  * but got Internal Scratch */
                                 check = IV_FAIL;
                             }
                             if ((diff != 2) && (diff != 3))
                             {
                                 check = IV_FAIL;
                             }
                         }
 
                         if (check == IV_FAIL)
                         {
                             ps_op->s_ive_op.u4_error_code |= 1
                                             << IVE_UNSUPPORTEDPARAM;
                             ps_op->s_ive_op.u4_error_code |=
                                             IVE_ERR_MEM_REC_INCORRECT_TYPE;
 
                             return IV_FAIL;
                         }
                     }
                 }
             }
             break;
         }
 
         case IVE_CMD_QUEUE_INPUT:
         case IVE_CMD_QUEUE_OUTPUT:
         case IVE_CMD_DEQUEUE_OUTPUT:
         case IVE_CMD_GET_RECON:
             break;
 
         case IV_CMD_RETRIEVE_MEMREC:
         {
             ih264e_retrieve_mem_rec_ip_t *ps_ip = pv_api_ip;
             ih264e_retrieve_mem_rec_op_t *ps_op = pv_api_op;
 
             iv_mem_rec_t *ps_mem_rec = NULL;
 
             ps_op->s_ive_op.u4_error_code = 0;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_retrieve_mem_rec_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_RETRIEVE_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_retrieve_mem_rec_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_RETRIEVE_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (NULL == ps_ip->s_ive_ip.ps_mem_rec)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_FILL_NUM_MEM_RECS_POINTER_NULL;
                 return (IV_FAIL);
             }
 
             ps_mem_rec = ps_ip->s_ive_ip.ps_mem_rec;
 
             /* check memrecords sizes are correct */
             for (i = 0; i < MEM_REC_CNT; i++)
             {
                 if (ps_mem_rec[i].u4_size != sizeof(iv_mem_rec_t))
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IVE_ERR_MEM_REC_STRUCT_SIZE_INCORRECT;
                     return IV_FAIL;
                 }
             }
             break;
         }
 
         case IVE_CMD_VIDEO_ENCODE:
         {
+            codec_t *ps_codec = (codec_t *) (ps_handle->pv_codec_handle);
             ih264e_video_encode_ip_t *ps_ip = pv_api_ip;
             ih264e_video_encode_op_t *ps_op = pv_api_op;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_video_encode_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_ENCODE_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_video_encode_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_ENCODE_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
+
+            if (NULL != ps_ip->s_ive_ip.s_inp_buf.apv_bufs[0] &&
+                            ps_codec->i4_header_mode != 1 &&
+                            IV_SUCCESS != api_check_input_dimensions(ps_codec, ps_ip, ps_op))
+            {
+                ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                ps_op->s_ive_op.u4_error_code |= IVE_ERR_OP_ENCODE_API_STRUCT_SIZE_INCORRECT;
+                return (IV_FAIL);
+            }
             break;
         }
 
         case IVE_CMD_VIDEO_CTL:
         {
             /* ptr to input structure */
             WORD32 *pu4_ptr_cmd = pv_api_ip;
 
             /* sub command */
             WORD32 sub_command = pu4_ptr_cmd[2];
 
             switch (sub_command)
             {
                 case IVE_CMD_CTL_SETDEFAULT:
                 {
                     ih264e_ctl_setdefault_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_setdefault_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_setdefault_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETDEF_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_setdefault_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETDEF_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_GETBUFINFO:
                 {
                     codec_t *ps_codec = (codec_t *) (ps_handle->pv_codec_handle);
 
                     ih264e_ctl_getbufinfo_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_getbufinfo_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_getbufinfo_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_GETBUFINFO_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_getbufinfo_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_GETBUFINFO_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_max_wd < MIN_WD)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_max_wd > ps_codec->s_cfg.u4_max_wd)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_max_ht < MIN_HT)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_max_ht > ps_codec->s_cfg.u4_max_ht)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if ((ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420P)
                                     && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_422ILE)
                                     && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420SP_UV)
                                     && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420SP_VU))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INPUT_CHROMA_FORMAT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_GETVERSION:
                 {
                     ih264e_ctl_getversioninfo_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_getversioninfo_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_getversioninfo_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_GETVERSION_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_getversioninfo_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_GETVERSION_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.pu1_version == NULL)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_CTL_GET_VERSION_BUFFER_IS_NULL;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_FLUSH:
                 {
                     ih264e_ctl_flush_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_flush_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_flush_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_FLUSH_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_flush_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_FLUSH_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_RESET:
                 {
                     ih264e_ctl_reset_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_reset_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_reset_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_RESET_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_reset_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_RESET_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_NUM_CORES:
                 {
                     ih264e_ctl_set_num_cores_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_num_cores_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_num_cores_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETCORES_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_num_cores_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETCORES_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_num_cores < 1)
                                     || (ps_ip->s_ive_ip.u4_num_cores > MAX_NUM_CORES))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_NUM_CORES;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_DIMENSIONS:
                 {
                     codec_t *ps_codec = (codec_t *) (ps_handle->pv_codec_handle);
 
                     ih264e_ctl_set_dimensions_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_dimensions_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_dimensions_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETDIM_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_dimensions_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETDIM_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_wd < MIN_WD)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_wd > ps_codec->s_cfg.u4_max_wd)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_ht < MIN_HT)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_ht > ps_codec->s_cfg.u4_max_ht)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if(ps_ip->s_ive_ip.u4_wd & 1)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if(ps_ip->s_ive_ip.u4_ht & 1)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_FRAMERATE:
                 {
                     ih264e_ctl_set_frame_rate_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_frame_rate_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_frame_rate_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETFRAMERATE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_frame_rate_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETFRAMERATE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (((ps_ip->s_ive_ip.u4_src_frame_rate * 1000) > DEFAULT_MAX_FRAMERATE)
                                     || ((ps_ip->s_ive_ip.u4_tgt_frame_rate * 1000) > DEFAULT_MAX_FRAMERATE))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_FRAME_RATE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if ((ps_ip->s_ive_ip.u4_src_frame_rate == 0)
                                     || (ps_ip->s_ive_ip.u4_tgt_frame_rate == 0))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_FRAME_RATE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_tgt_frame_rate
                                     > ps_ip->s_ive_ip.u4_src_frame_rate)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_TGT_FRAME_RATE_EXCEEDS_SRC_FRAME_RATE;
                         return (IV_FAIL);
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_BITRATE:
                 {
                     ih264e_ctl_set_bitrate_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_bitrate_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_bitrate_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETBITRATE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_bitrate_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETBITRATE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_target_bitrate > DEFAULT_MAX_BITRATE)
                                     || (ps_ip->s_ive_ip.u4_target_bitrate == 0))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_BITRATE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_FRAMETYPE:
                 {
                     ih264e_ctl_set_frame_type_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_frame_type_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_frame_type_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETFRAMETYPE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_frame_type_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETFRAMETYPE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.e_frame_type != IV_NA_FRAME)
                                     && (ps_ip->s_ive_ip.e_frame_type != IV_I_FRAME)
                                     && (ps_ip->s_ive_ip.e_frame_type != IV_P_FRAME)
                                     && (ps_ip->s_ive_ip.e_frame_type != IV_IDR_FRAME))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_FORCE_FRAME_INPUT;
                         return IV_FAIL;
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_ME_PARAMS:
                 {
                     codec_t *ps_codec = (codec_t *) (ps_handle->pv_codec_handle);
 
                     ih264e_ctl_set_me_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_me_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_me_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETMEPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_me_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETMEPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_me_speed_preset != FULL_SRCH)
                                     && (ps_ip->s_ive_ip.u4_me_speed_preset != DMND_SRCH)
                                     && (ps_ip->s_ive_ip.u4_me_speed_preset != HEX_SRCH))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ME_SPEED_PRESET;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enable_hpel != 0)
                                     && (ps_ip->s_ive_ip.u4_enable_hpel != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_HALFPEL_OPTION;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enable_qpel != 0)
                                     && (ps_ip->s_ive_ip.u4_enable_qpel != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_QPEL_OPTION;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enable_fast_sad != 0)
                                     && (ps_ip->s_ive_ip.u4_enable_fast_sad != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_FAST_SAD_OPTION;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_enable_alt_ref > 255)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ALT_REF_OPTION;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_srch_rng_x
                                     > ps_codec->s_cfg.u4_max_srch_rng_x)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HORIZONTAL_SEARCH_RANGE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_srch_rng_y
                                     > ps_codec->s_cfg.u4_max_srch_rng_y)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_VERTICAL_SEARCH_RANGE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_IPE_PARAMS:
                 {
                     ih264e_ctl_set_ipe_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_ipe_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_ipe_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETIPEPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_ipe_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETIPEPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enable_intra_4x4 != 0)
                                     && (ps_ip->s_ive_ip.u4_enable_intra_4x4 != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_INTRA4x4_OPTION;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_constrained_intra_pred != 0)
                                     && (ps_ip->s_ive_ip.u4_constrained_intra_pred != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_CONSTRAINED_INTRA_PREDICTION_MODE;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_CONFIG)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_SLOWEST)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_NORMAL)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_FAST)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_HIGH_SPEED)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_FASTEST))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ENC_SPEED_PRESET;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_GOP_PARAMS:
                 {
                     ih264e_ctl_set_gop_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_gop_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_gop_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETGOPPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_gop_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETGOPPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_i_frm_interval < DEFAULT_MIN_INTRA_FRAME_RATE)
                                     || (ps_ip->s_ive_ip.u4_i_frm_interval > DEFAULT_MAX_INTRA_FRAME_RATE))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_INTRA_FRAME_INTERVAL;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_idr_frm_interval < DEFAULT_MIN_INTRA_FRAME_RATE)
                                     || (ps_ip->s_ive_ip.u4_idr_frm_interval > DEFAULT_MAX_INTRA_FRAME_RATE))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_IDR_FRAME_INTERVAL;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_DEBLOCK_PARAMS:
                 {
                     ih264e_ctl_set_deblock_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_deblock_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_deblock_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETDEBLKPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_deblock_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETDEBLKPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_disable_deblock_level != DISABLE_DEBLK_LEVEL_0)
                                     && (ps_ip->s_ive_ip.u4_disable_deblock_level != DISABLE_DEBLK_LEVEL_2)
                                     && (ps_ip->s_ive_ip.u4_disable_deblock_level != DISABLE_DEBLK_LEVEL_3)
                                     && (ps_ip->s_ive_ip.u4_disable_deblock_level != DISABLE_DEBLK_LEVEL_4))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_DEBLOCKING_TYPE_INPUT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_QP:
                 {
                     ih264e_ctl_set_qp_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_qp_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_qp_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETQPPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_qp_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETQPPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_i_qp_max > MAX_H264_QP)
                                     || (ps_ip->s_ive_ip.u4_p_qp_max > MAX_H264_QP)
                                     || (ps_ip->s_ive_ip.u4_b_qp_max > MAX_H264_QP))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_MAX_FRAME_QP;
                         return IV_FAIL;
                     }
 
                     /* We donot support QP < 4 */
                     if ((ps_ip->s_ive_ip.u4_i_qp_min < 4)
                                     || (ps_ip->s_ive_ip.u4_p_qp_min < 4)
                                     || (ps_ip->s_ive_ip.u4_b_qp_min < 4)
                                     || (ps_ip->s_ive_ip.u4_i_qp_min > ps_ip->s_ive_ip.u4_i_qp_max)
                                     || (ps_ip->s_ive_ip.u4_p_qp_min > ps_ip->s_ive_ip.u4_p_qp_max)
                                     || (ps_ip->s_ive_ip.u4_b_qp_min > ps_ip->s_ive_ip.u4_b_qp_max))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_MIN_FRAME_QP;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_i_qp > ps_ip->s_ive_ip.u4_i_qp_max)
                                     || (ps_ip->s_ive_ip.u4_p_qp > ps_ip->s_ive_ip.u4_p_qp_max)
                                     || (ps_ip->s_ive_ip.u4_b_qp > ps_ip->s_ive_ip.u4_b_qp_max))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |= IH264E_INVALID_INIT_QP;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_i_qp < ps_ip->s_ive_ip.u4_i_qp_min)
                                     || (ps_ip->s_ive_ip.u4_p_qp < ps_ip->s_ive_ip.u4_p_qp_min)
                                     || (ps_ip->s_ive_ip.u4_b_qp < ps_ip->s_ive_ip.u4_b_qp_min))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |= IH264E_INVALID_INIT_QP;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_VUI_PARAMS:
                 {
                     ih264e_vui_ip_t *ps_ip = pv_api_ip;
                     ih264e_vui_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_vui_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVE_ERR_IP_CTL_SET_VUI_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_vui_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVE_ERR_OP_CTL_SET_VUI_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_SEI_MDCV_PARAMS:
                 {
                     ih264e_ctl_set_sei_mdcv_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_sei_mdcv_params_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_ctl_set_sei_mdcv_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_IP_CTL_SET_SEI_MDCV_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_ctl_set_sei_mdcv_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_OP_CTL_SET_SEI_MDCV_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->u1_sei_mdcv_params_present_flag != 0)
                             && (ps_ip->u1_sei_mdcv_params_present_flag) != 1)
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IH264E_INVALID_SEI_MDCV_PARAMS;
                         return IV_FAIL;
                     }
 
                     if(1 == ps_ip->u1_sei_mdcv_params_present_flag)
                     {
                         /* Check values for u2_display_primaries_x and u2_display_primaries_y */
                         for(i = 0; i < 3; i++)
                         {
                             if((ps_ip->au2_display_primaries_x[i] >
                                                     DISPLAY_PRIMARIES_X_UPPER_LIMIT) ||
                                (ps_ip->au2_display_primaries_x[i] <
                                                     DISPLAY_PRIMARIES_X_LOWER_LIMIT) ||
                                ((ps_ip->au2_display_primaries_x[i] %
                                                     DISPLAY_PRIMARIES_X_DIVISION_FACTOR) != 0))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_MDCV_PARAMS;
                                 return IV_FAIL;
                             }
 
                             if((ps_ip->au2_display_primaries_y[i] >
                                                     DISPLAY_PRIMARIES_Y_UPPER_LIMIT) ||
                                (ps_ip->au2_display_primaries_y[i] <
                                                     DISPLAY_PRIMARIES_Y_LOWER_LIMIT) ||
                                ((ps_ip->au2_display_primaries_y[i] %
                                                     DISPLAY_PRIMARIES_Y_DIVISION_FACTOR) != 0))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_MDCV_PARAMS;
                                 return IV_FAIL;
                             }
                         }
 
                         if((ps_ip->u2_white_point_x > WHITE_POINT_X_UPPER_LIMIT) ||
                            (ps_ip->u2_white_point_x < WHITE_POINT_X_LOWER_LIMIT) ||
                            ((ps_ip->u2_white_point_x % WHITE_POINT_X_DIVISION_FACTOR) != 0))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if((ps_ip->u2_white_point_y > WHITE_POINT_Y_UPPER_LIMIT) ||
                            (ps_ip->u2_white_point_y < WHITE_POINT_Y_LOWER_LIMIT) ||
                            ((ps_ip->u2_white_point_y % WHITE_POINT_Y_DIVISION_FACTOR) != 0))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if((ps_ip->u4_max_display_mastering_luminance >
                                         MAX_DISPLAY_MASTERING_LUMINANCE_UPPER_LIMIT) ||
                            (ps_ip->u4_max_display_mastering_luminance <
                                         MAX_DISPLAY_MASTERING_LUMINANCE_LOWER_LIMIT) ||
                            ((ps_ip->u4_max_display_mastering_luminance %
                                         MAX_DISPLAY_MASTERING_LUMINANCE_DIVISION_FACTOR) != 0))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if((ps_ip->u4_min_display_mastering_luminance >
                                         MIN_DISPLAY_MASTERING_LUMINANCE_UPPER_LIMIT ) ||
                            (ps_ip->u4_min_display_mastering_luminance <
                                         MIN_DISPLAY_MASTERING_LUMINANCE_LOWER_LIMIT))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if(ps_ip->u4_max_display_mastering_luminance <=
                                 ps_ip->u4_min_display_mastering_luminance)
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_SEI_CLL_PARAMS:
                 {
                     ih264e_ctl_set_sei_cll_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_sei_cll_params_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_ctl_set_sei_cll_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_IP_CTL_SET_SEI_CLL_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_ctl_set_sei_cll_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_OP_CTL_SET_SEI_CLL_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->u1_sei_cll_params_present_flag != 0)
                             && (ps_ip->u1_sei_cll_params_present_flag != 1))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IH264E_INVALID_SEI_CLL_PARAMS;
                         return IV_FAIL;
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_SEI_AVE_PARAMS:
                 {
                     ih264e_ctl_set_sei_ave_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_sei_ave_params_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_ctl_set_sei_ave_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_IP_CTL_SET_SEI_AVE_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_ctl_set_sei_ave_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_OP_CTL_SET_SEI_AVE_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->u1_sei_ave_params_present_flag != 0)
                             && (ps_ip->u1_sei_ave_params_present_flag != 1))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IH264E_INVALID_SEI_AVE_PARAMS;
                         return IV_FAIL;
                     }
 
                     if(1 == ps_ip->u1_sei_ave_params_present_flag)
                     {
                         if((0 == ps_ip->u4_ambient_illuminance))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_AVE_PARAMS;
                             return IV_FAIL;
                         }
 
                         if(ps_ip->u2_ambient_light_x > AMBIENT_LIGHT_X_UPPER_LIMIT)
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_AVE_PARAMS;
                             return IV_FAIL;
                         }
 
                         if(ps_ip->u2_ambient_light_y > AMBIENT_LIGHT_Y_UPPER_LIMIT)
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_AVE_PARAMS;
                             return IV_FAIL;
                         }
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_SEI_CCV_PARAMS:
                 {
                     ih264e_ctl_set_sei_ccv_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_sei_ccv_params_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_ctl_set_sei_ccv_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_IP_CTL_SET_SEI_CCV_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_ctl_set_sei_ccv_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_OP_CTL_SET_SEI_CCV_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->u1_sei_ccv_params_present_flag != 0)
                             && (ps_ip->u1_sei_ccv_params_present_flag != 1))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IH264E_INVALID_SEI_CCV_PARAMS;
                         return IV_FAIL;
                     }
 
 
                     if(1 == ps_ip->u1_sei_ccv_params_present_flag)
                     {
                         if((ps_ip->u1_ccv_cancel_flag != 0)
                                 && (ps_ip->u1_ccv_cancel_flag != 1))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_CCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if(0 == ps_ip->u1_ccv_cancel_flag)
                         {
                             if((ps_ip->u1_ccv_persistence_flag != 0)
                                     && (ps_ip->u1_ccv_persistence_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_primaries_present_flag != 0)
                                     && (ps_ip->u1_ccv_primaries_present_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_min_luminance_value_present_flag != 0)
                                     && (ps_ip->u1_ccv_min_luminance_value_present_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_max_luminance_value_present_flag != 0)
                                     && (ps_ip->u1_ccv_max_luminance_value_present_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_avg_luminance_value_present_flag != 0)
                                     && (ps_ip->u1_ccv_avg_luminance_value_present_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_primaries_present_flag == 0)
                                     && (ps_ip->u1_ccv_min_luminance_value_present_flag == 0)
                                     && (ps_ip->u1_ccv_max_luminance_value_present_flag == 0)
                                     && (ps_ip->u1_ccv_avg_luminance_value_present_flag == 0))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
 
                             if((ps_ip->u1_ccv_reserved_zero_2bits != 0))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
 
                             if(1 == ps_ip->u1_ccv_primaries_present_flag)
                             {
                                 for(i = 0; i < 3; i++)
                                 {
                                     if((ps_ip->ai4_ccv_primaries_x[i] >
                                                         CCV_PRIMARIES_X_UPPER_LIMIT) ||
                                        (ps_ip->ai4_ccv_primaries_x[i] <
                                                         CCV_PRIMARIES_X_LOWER_LIMIT))
                                     {
                                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                         ps_op->u4_error_code |=
                                                 IH264E_INVALID_SEI_CCV_PARAMS;
                                         return IV_FAIL;
                                     }
 
                                     if((ps_ip->ai4_ccv_primaries_y[i] >
                                                         CCV_PRIMARIES_Y_UPPER_LIMIT) ||
                                        (ps_ip->ai4_ccv_primaries_y[i] <
                                                         CCV_PRIMARIES_Y_LOWER_LIMIT))
                                     {
                                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                         ps_op->u4_error_code |=
                                                 IH264E_INVALID_SEI_CCV_PARAMS;
                                         return IV_FAIL;
                                     }
                                 }
                             }
 
                             if((1 == ps_ip->u1_ccv_min_luminance_value_present_flag) &&
                                     (1 == ps_ip->u1_ccv_avg_luminance_value_present_flag))
                             {
                                 if((ps_ip->u4_ccv_avg_luminance_value <
                                                     ps_ip->u4_ccv_min_luminance_value))
                                 {
                                     ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                     ps_op->u4_error_code |=
                                             IH264E_INVALID_SEI_CCV_PARAMS;
                                     return IV_FAIL;
                                 }
                             }
 
                             if((1 == ps_ip->u1_ccv_min_luminance_value_present_flag) &&
                                     (1 == ps_ip->u1_ccv_max_luminance_value_present_flag))
                             {
                                 if((ps_ip->u4_ccv_max_luminance_value <
                                                     ps_ip->u4_ccv_min_luminance_value))
                                 {
                                     ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                     ps_op->u4_error_code |=
                                             IH264E_INVALID_SEI_CCV_PARAMS;
                                     return IV_FAIL;
                                 }
                             }
                             if((1 == ps_ip->u1_ccv_avg_luminance_value_present_flag) &&
                                     (1 == ps_ip->u1_ccv_max_luminance_value_present_flag))
                             {
                                 if((ps_ip->u4_ccv_max_luminance_value <
                                                     ps_ip->u4_ccv_avg_luminance_value))
                                 {
                                     ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                     ps_op->u4_error_code |=
                                             IH264E_INVALID_SEI_CCV_PARAMS;
                                     return IV_FAIL;
                                 }
                             }
                         }
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_ENC_MODE:
                 {
                     ih264e_ctl_set_enc_mode_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_enc_mode_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_enc_mode_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETENCMODE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_enc_mode_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETENCMODE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.e_enc_mode != IVE_ENC_MODE_HEADER)
                                     && (ps_ip->s_ive_ip.e_enc_mode != IVE_ENC_MODE_PICTURE))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ENC_OPERATION_MODE;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_VBV_PARAMS:
                 {
                     ih264e_ctl_set_vbv_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_vbv_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_vbv_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETVBVPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_vbv_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETVBVPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_vbv_buffer_delay < DEFAULT_MIN_BUFFER_DELAY)
                                     || (ps_ip->s_ive_ip.u4_vbv_buffer_delay > DEFAULT_MAX_BUFFER_DELAY))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_BUFFER_DELAY;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_AIR_PARAMS:
                 {
                     ih264e_ctl_set_air_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_air_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_air_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETAIRPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_air_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETAIRPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.e_air_mode != IVE_AIR_MODE_NONE)
                                     && (ps_ip->s_ive_ip.e_air_mode != IVE_AIR_MODE_CYCLIC)
                                     && (ps_ip->s_ive_ip.e_air_mode != IVE_AIR_MODE_RANDOM))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_AIR_MODE;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_air_refresh_period == 0)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_AIR_REFRESH_PERIOD;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_PROFILE_PARAMS:
                 {
                     ih264e_ctl_set_profile_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_profile_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_profile_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETPROFILE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_profile_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETPROFILE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.e_profile != IV_PROFILE_BASE &&
                         ps_ip->s_ive_ip.e_profile != IV_PROFILE_MAIN)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_PROFILE_NOT_SUPPORTED;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_entropy_coding_mode > 1)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ENTROPY_CODING_MODE;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 default:
                     *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                     *(pu4_api_op + 1) |= IVE_ERR_INVALID_API_SUB_CMD;
                     return IV_FAIL;
             }
 
             break;
         }
 
         default:
             *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
             *(pu4_api_op + 1) |= IVE_ERR_INVALID_API_CMD;
             return IV_FAIL;
     }
 
     return IV_SUCCESS;
 }
 
 /**
 *******************************************************************************
 *
 * @brief update encoder configuration parameters
 *
 * @par Description:
 *  updates encoder configuration parameters from the given config set.
 *  Initialize/reinitialize codec parameters according to new configurations.
 *
 * @param[in] ps_codec
 *  Pointer to codec context
 *
 * @param[in] ps_cfg
 *  Pointer to config param set
 *
 * @remarks none
 *
 *******************************************************************************
 */
@@ -3971,942 +4076,947 @@ static WORD32 ih264e_fill_num_mem_rec(void *pv_api_ip, void *pv_api_op)
 /**
 *******************************************************************************
 *
 * @brief
 *  Initializes from mem records passed to the codec
 *
 * @par Description:
 *  Initializes pointers based on mem records passed
 *
 * @param[in] ps_codec_obj
 *  Pointer to codec object at API level
 *
 * @param[in] pv_api_ip
 *  Pointer to input argument structure
 *
 * @param[out] pv_api_op
 *  Pointer to output argument structure
 *
 * @returns error status
 *
 * @remarks none
 *
 *******************************************************************************
 */
 static WORD32 ih264e_init_mem_rec(iv_obj_t *ps_codec_obj,
                                   void *pv_api_ip,
                                   void *pv_api_op)
 {
     /* api call I/O structures */
     ih264e_init_ip_t *ps_ip = pv_api_ip;
     ih264e_init_op_t *ps_op = pv_api_op;
 
     /* mem records */
     iv_mem_rec_t *ps_mem_rec_base, *ps_mem_rec;
 
     /* codec variables */
     codec_t * ps_codec;
     cabac_ctxt_t *ps_cabac;
     mb_info_ctxt_t *ps_mb_map_ctxt_inc;
 
     cfg_params_t *ps_cfg;
 
     /* frame dimensions */
     WORD32 max_wd_luma, max_ht_luma;
     WORD32 max_mb_rows, max_mb_cols, max_mb_cnt;
 
     /* temp var */
     WORD32 i, j;
     WORD32 status = IV_SUCCESS;
 
     /* frame dimensions */
     max_ht_luma = ALIGN16(ps_ip->s_ive_ip.u4_max_ht);
     max_wd_luma = ALIGN16(ps_ip->s_ive_ip.u4_max_wd);
     max_mb_rows = max_ht_luma / MB_SIZE;
     max_mb_cols = max_wd_luma / MB_SIZE;
     max_mb_cnt = max_mb_rows * max_mb_cols;
 
     /* mem records */
     ps_mem_rec_base = ps_ip->s_ive_ip.ps_mem_rec;
 
     /* Init mem records */
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_CODEC];
     {
         ps_codec_obj->pv_codec_handle = ps_mem_rec->pv_base;
         ps_codec = (codec_t *) (ps_codec_obj->pv_codec_handle);
     }
     /* Init mem records_cabac ctxt */
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_CABAC];
     {
         ps_cabac = (cabac_ctxt_t *)(ps_mem_rec->pv_base);
     }
 
     /* Init mem records mb info array for CABAC */
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_CABAC_MB_INFO];
     {
         ps_mb_map_ctxt_inc = (mb_info_ctxt_t *)(ps_mem_rec->pv_base);
     }
 
     /* Note this memset can not be done in init() call, since init will called
      during reset as well. And calling this during reset will mean all pointers
      need to reinitialized */
     memset(ps_codec, 0, sizeof(codec_t));
     memset(ps_cabac, 0, sizeof(cabac_ctxt_t));
 
     /* Set default Config Params */
     ps_cfg = &ps_codec->s_cfg;
     ih264e_set_default_params(ps_cfg);
 
     /* Update config params as per input */
     ps_cfg->u4_max_wd = ALIGN16(ps_ip->s_ive_ip.u4_max_wd);
     ps_cfg->u4_max_ht = ALIGN16(ps_ip->s_ive_ip.u4_max_ht);
+
+    /* Initialize dimensions to max dimensions during init */
+    ps_cfg->u4_wd = ps_cfg->u4_disp_wd = ps_cfg->u4_max_wd;
+    ps_cfg->u4_ht = ps_cfg->u4_disp_ht = ps_cfg->u4_max_ht;
+
     ps_cfg->i4_wd_mbs = ps_cfg->u4_max_wd >> 4;
     ps_cfg->i4_ht_mbs = ps_cfg->u4_max_ht >> 4;
     ps_cfg->u4_max_ref_cnt = ps_ip->s_ive_ip.u4_max_ref_cnt;
     ps_cfg->u4_max_reorder_cnt = ps_ip->s_ive_ip.u4_max_reorder_cnt;
     ps_cfg->u4_max_level = ps_ip->s_ive_ip.u4_max_level;
     ps_cfg->e_inp_color_fmt = ps_ip->s_ive_ip.e_inp_color_fmt;
     ps_cfg->e_recon_color_fmt = ps_ip->s_ive_ip.e_recon_color_fmt;
     ps_cfg->u4_max_framerate = ps_ip->s_ive_ip.u4_max_framerate;
     ps_cfg->u4_max_bitrate = ps_ip->s_ive_ip.u4_max_bitrate;
     ps_cfg->u4_num_bframes = ps_ip->s_ive_ip.u4_num_bframes;
     ps_cfg->e_content_type = ps_ip->s_ive_ip.e_content_type;
     ps_cfg->u4_max_srch_rng_x = ps_ip->s_ive_ip.u4_max_srch_rng_x;
     ps_cfg->u4_max_srch_rng_y = ps_ip->s_ive_ip.u4_max_srch_rng_y;
     ps_cfg->e_slice_mode = ps_ip->s_ive_ip.e_slice_mode;
     ps_cfg->u4_slice_param = ps_ip->s_ive_ip.u4_slice_param;
     ps_cfg->e_arch = ps_ip->s_ive_ip.e_arch;
     ps_cfg->e_soc = ps_ip->s_ive_ip.e_soc;
     ps_cfg->u4_enable_recon = ps_ip->s_ive_ip.u4_enable_recon;
     ps_cfg->e_rc_mode = ps_ip->s_ive_ip.e_rc_mode;
 
     /* Validate params */
     if ((ps_ip->s_ive_ip.u4_max_level < MIN_LEVEL)
                     || (ps_ip->s_ive_ip.u4_max_level > MAX_LEVEL))
     {
         ps_op->s_ive_op.u4_error_code |= IH264E_CODEC_LEVEL_NOT_SUPPORTED;
         ps_cfg->u4_max_level = DEFAULT_MAX_LEVEL;
     }
 
     if (ps_ip->s_ive_ip.u4_max_ref_cnt > MAX_REF_CNT)
     {
         ps_op->s_ive_op.u4_error_code |= IH264E_NUM_REF_UNSUPPORTED;
         ps_cfg->u4_max_ref_cnt = MAX_REF_CNT;
     }
 
     if (ps_ip->s_ive_ip.u4_max_reorder_cnt > MAX_REF_CNT)
     {
         ps_op->s_ive_op.u4_error_code |= IH264E_NUM_REORDER_UNSUPPORTED;
         ps_cfg->u4_max_reorder_cnt = MAX_REF_CNT;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_BACKUP];
     {
         ps_codec->ps_mem_rec_backup = (iv_mem_rec_t *) ps_mem_rec->pv_base;
 
         memcpy(ps_codec->ps_mem_rec_backup, ps_mem_rec_base,
                MEM_REC_CNT * sizeof(iv_mem_rec_t));
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_ENTROPY];
     {
         /* temp var */
         WORD32 size = 0, offset;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 /* base ptr */
                 UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
                 /* reset size */
                 size = 0;
 
                 /* skip mb run */
                 ps_codec->as_process[i].s_entropy.pi4_mb_skip_run =
                                 (void *) (pu1_buf + size);
                 size += sizeof(WORD32);
                 size = ALIGN8(size);
 
                 /* entropy map */
                 ps_codec->as_process[i].s_entropy.pu1_entropy_map =
                                 (void *) (pu1_buf + size + max_mb_cols);
                 /* size in bytes to store entropy status of an entire frame */
                 size += (max_mb_cols * max_mb_rows);
                 /* add an additional 1 row of bytes to evade the special case of row 0 */
                 size += max_mb_cols;
                 size = ALIGN128(size);
 
                 /* bit stream ptr */
                 ps_codec->as_process[i].s_entropy.ps_bitstrm = (void *) (pu1_buf
                                 + size);
                 size += sizeof(bitstrm_t);
                 size = ALIGN128(size);
 
                 /* nnz luma */
                 ps_codec->as_process[i].s_entropy.pu1_top_nnz_luma =
                                 (void *) (pu1_buf + size);
                 size += (max_mb_cols * 4 * sizeof(UWORD8));
                 size = ALIGN128(size);
 
                 /* nnz chroma */
                 ps_codec->as_process[i].s_entropy.pu1_top_nnz_cbcr =
                                 (void *) (pu1_buf + size);
                 size += (max_mb_cols * 4 * sizeof(UWORD8));
                 size = ALIGN128(size);
                 offset = size;
                 /* cabac Context */
                 ps_codec->as_process[i].s_entropy.ps_cabac = ps_cabac;
             }
             else
             {
                 /* base ptr */
                 UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
                 /* reset size */
                 size = offset;
 
                 /* skip mb run */
                 ps_codec->as_process[i].s_entropy.pi4_mb_skip_run =
                                 (void *) (pu1_buf + size);
                 size += sizeof(WORD32);
                 size = ALIGN8(size);
 
                 /* entropy map */
                 ps_codec->as_process[i].s_entropy.pu1_entropy_map =
                                 (void *) (pu1_buf + size + max_mb_cols);
                 /* size in bytes to store entropy status of an entire frame */
                 size += (max_mb_cols * max_mb_rows);
                 /* add an additional 1 row of bytes to evade the special case of row 0 */
                 size += max_mb_cols;
                 size = ALIGN128(size);
 
                 /* bit stream ptr */
                 ps_codec->as_process[i].s_entropy.ps_bitstrm = (void *) (pu1_buf
                                 + size);
                 size += sizeof(bitstrm_t);
                 size = ALIGN128(size);
 
                 /* nnz luma */
                 ps_codec->as_process[i].s_entropy.pu1_top_nnz_luma =
                                 (void *) (pu1_buf + size);
                 size += (max_mb_cols * 4 * sizeof(UWORD8));
                 size = ALIGN128(size);
 
                 /* nnz chroma */
                 ps_codec->as_process[i].s_entropy.pu1_top_nnz_cbcr =
                                 (void *) (pu1_buf + size);
                 size += (max_mb_cols * 4 * sizeof(UWORD8));
                 size = ALIGN128(size);
                 /* cabac Context */
                 ps_codec->as_process[i].s_entropy.ps_cabac = ps_cabac;
            }
         }
         ps_codec->as_process[0].s_entropy.ps_cabac->ps_mb_map_ctxt_inc_base =
                         ps_mb_map_ctxt_inc;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_MB_COEFF_DATA];
     {
         /* temp var */
         WORD32 size = 0, size_of_row;
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         /* size of coeff data of 1 mb */
         size += sizeof(tu_sblk_coeff_data_t) * MAX_4x4_SUBBLKS;
 
         /* size of coeff data of 1 row of mb's */
         size *= max_mb_cols;
 
         /* align to avoid false sharing */
         size = ALIGN64(size);
         size_of_row = size;
 
         /* size for one full frame */
         size *= max_mb_rows;
 
         ps_codec->u4_size_coeff_data = size_of_row;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 ps_codec->as_process[i].pv_pic_mb_coeff_data = pu1_buf;
                 ps_codec->as_process[i].s_entropy.pv_pic_mb_coeff_data =
                                 pu1_buf;
             }
             else
             {
                 ps_codec->as_process[i].pv_pic_mb_coeff_data = pu1_buf + size;
                 ps_codec->as_process[i].s_entropy.pv_pic_mb_coeff_data = pu1_buf
                                 + size;
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_MB_HEADER_DATA];
     {
         /* temp var */
         WORD32 size, size_of_row;
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         /* size of header data of 1 mb */
         size = sizeof(mb_hdr_t);
 
         /* size for 1 row of mbs */
         size = size * max_mb_cols;
 
         /* align to avoid any false sharing across threads */
         size = ALIGN64(size);
         size_of_row = size;
 
         /* size for one full frame */
         size *= max_mb_rows;
 
         ps_codec->u4_size_header_data = size_of_row;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 ps_codec->as_process[i].pv_pic_mb_header_data = pu1_buf;
                 ps_codec->as_process[i].s_entropy.pv_pic_mb_header_data =
                                 pu1_buf;
             }
             else
             {
                 ps_codec->as_process[i].pv_pic_mb_header_data = pu1_buf + size;
                 ps_codec->as_process[i].s_entropy.pv_pic_mb_header_data =
                                 pu1_buf + size;
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_MVBANK];
     {
         /* size of buf mgr struct */
         WORD32 size = ih264_buf_mgr_size();
 
         /* temp var */
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         /* mv buffer mgr */
         ps_codec->pv_mv_buf_mgr_base = pu1_buf;
 
         /* mv bank */
         ps_codec->pv_mv_bank_buf_base = pu1_buf + size;
         ps_codec->i4_total_mv_bank_size = ps_mem_rec->u4_mem_size - size;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_MVBITS];
     {
         /* max srch range x */
         UWORD32 u4_srch_range_x = ps_ip->s_ive_ip.u4_max_srch_rng_x;
 
         /* max srch range y */
         UWORD32 u4_srch_range_y = ps_ip->s_ive_ip.u4_max_srch_rng_y;
 
         /* max srch range */
         UWORD32 u4_max_srch_range = MAX(u4_srch_range_x, u4_srch_range_y);
 
         /* temp var */
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         /* due to subpel */
         u4_max_srch_range <<= 2;
 
 //        /* due to mv on either direction */
 //        u4_max_srch_range = (u4_max_srch_range << 1);
 
         /* due to pred mv + zero */
         u4_max_srch_range = (u4_max_srch_range << 1) + 1;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             /* me ctxt */
             me_ctxt_t *ps_mem_ctxt = &(ps_codec->as_process[i].s_me_ctxt);
 
             /* init at zero mv */
             ps_mem_ctxt->pu1_mv_bits = pu1_buf + u4_max_srch_range;
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_SPS];
     {
         ps_codec->ps_sps_base = (sps_t *) ps_mem_rec->pv_base;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_PPS];
     {
         ps_codec->ps_pps_base = (pps_t *) ps_mem_rec->pv_base;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_SLICE_HDR];
     {
         ps_codec->ps_slice_hdr_base = ps_mem_rec->pv_base;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 ps_codec->as_process[i].ps_slice_hdr_base = ps_mem_rec->pv_base;
             }
             else
             {
                 /* temp var */
                 WORD32 size = MAX_SLICE_HDR_CNT * sizeof(slice_header_t);
                 void *pv_buf = (UWORD8 *) ps_mem_rec->pv_base + size;
 
                 ps_codec->as_process[i].ps_slice_hdr_base = pv_buf;
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_AIR_MAP];
     {
         /* temp var */
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 ps_codec->as_process[i].pu1_is_intra_coded = pu1_buf;
             }
             else
             {
                 ps_codec->as_process[i].pu1_is_intra_coded = pu1_buf
                                 + max_mb_cnt;
             }
         }
 
         ps_codec->pu2_intr_rfrsh_map = (UWORD16 *) (pu1_buf + max_mb_cnt * MAX_CTXT_SETS);
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_SLICE_MAP];
     {
         /* pointer to storage space */
         UWORD8 *pu1_buf_ping, *pu1_buf_pong;
 
         /* init pointer */
         pu1_buf_ping = ps_mem_rec->pv_base;
         pu1_buf_pong = pu1_buf_ping + ALIGN64(max_mb_cnt);
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 ps_codec->as_process[i].pu1_slice_idx = pu1_buf_ping;
             }
             else
             {
                 ps_codec->as_process[i].pu1_slice_idx = pu1_buf_pong;
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_THREAD_HANDLE];
     {
         WORD32 handle_size = ithread_get_handle_size();
 
         for (i = 0; i < MAX_PROCESS_THREADS; i++)
         {
             ps_codec->apv_proc_thread_handle[i] = (UWORD8 *) ps_mem_rec->pv_base
                             + (i * handle_size);
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_CTL_MUTEX];
     {
         ps_codec->pv_ctl_mutex = ps_mem_rec->pv_base;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_ENTROPY_MUTEX];
     {
         ps_codec->pv_entropy_mutex = ps_mem_rec->pv_base;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_PROC_JOBQ];
     {
         ps_codec->pv_proc_jobq_buf = ps_mem_rec->pv_base;
         ps_codec->i4_proc_jobq_buf_size = ps_mem_rec->u4_mem_size;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_ENTROPY_JOBQ];
     {
         ps_codec->pv_entropy_jobq_buf = ps_mem_rec->pv_base;
         ps_codec->i4_entropy_jobq_buf_size = ps_mem_rec->u4_mem_size;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_PROC_MAP];
     {
         /* pointer to storage space */
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         /* total size of the mem record */
         WORD32 total_size = 0;
 
         /* size in bytes to mb core coding status of an entire frame */
         total_size = max_mb_cnt;
 
         /* add an additional 1 row of bytes to evade the special case of row 0 */
         total_size += max_mb_cols;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 ps_codec->as_process[i].pu1_proc_map = pu1_buf + max_mb_cols;
             }
             else
             {
                 ps_codec->as_process[i].pu1_proc_map = pu1_buf + total_size
                                 + max_mb_cols;
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_DBLK_MAP];
     {
         /* pointer to storage space */
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         /* total size of the mem record */
         WORD32 total_size = 0;
 
         /* size in bytes to mb core coding status of an entire frame */
         total_size = max_mb_cnt;
 
         /* add an additional 1 row of bytes to evade the special case of row 0 */
         total_size += max_mb_cols;
 
         /*Align the memory offsets*/
         total_size = ALIGN64(total_size);
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 ps_codec->as_process[i].pu1_deblk_map = pu1_buf + max_mb_cols;
 
             }
             else
             {
                 ps_codec->as_process[i].pu1_deblk_map = pu1_buf + total_size
                                 + max_mb_cols;
 
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_ME_MAP];
     {
         /* pointer to storage space */
         UWORD8 *pu1_buf = (UWORD8 *) ps_mem_rec->pv_base;
 
         /* total size of the mem record */
         WORD32 total_size = 0;
 
         /* size in bytes to mb core coding status of an entire frame */
         total_size = max_mb_cnt;
 
         /* add an additional 1 row of bytes to evade the special case of row 0 */
         total_size += max_mb_cols;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 ps_codec->as_process[i].pu1_me_map = pu1_buf + max_mb_cols;
             }
             else
             {
                 ps_codec->as_process[i].pu1_me_map = pu1_buf + total_size
                                 + max_mb_cols;
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_DPB_MGR];
     {
         ps_codec->pv_dpb_mgr = ps_mem_rec->pv_base;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_PROC_SCRATCH];
     {
         /* pointer to storage space */
         UWORD8 *pu1_buf = (UWORD8 *) ps_mem_rec->pv_base;
 
         /* size of pred buffer, fwd transform output, temp buffer for inv tra */
         WORD32 size_pred_luma, size_pred_chroma, size_fwd, size_inv, size_hp;
 
         /* temp var */
         WORD32 size = 0;
 
         /* size to hold intra/inter prediction buffer */
         size_pred_luma = sizeof(UWORD8) * 16 * 16;
         size_pred_chroma = sizeof(UWORD8) * 8 * 16;
 
         /* size to hold fwd transform output */
         size_fwd = sizeof(WORD16) * SIZE_TRANS_BUFF;
 
         /* size to hold temporary data during inverse transform */
         size_inv = sizeof(WORD32) * SIZE_TMP_BUFF_ITRANS;
 
         /* size to hold half pel plane buffers */
         size_hp = sizeof(UWORD8) * (HP_BUFF_WD * HP_BUFF_HT);
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             /* prediction buffer */
             ps_codec->as_process[i].pu1_pred_mb = (void *) (pu1_buf + size);
             ps_codec->as_process[i].i4_pred_strd = 16;
             size += size_pred_luma;
             size = ALIGN64(size);
 
             /* prediction buffer */
             ps_codec->as_process[i].pu1_ref_mb_intra_4x4 = (void *) (pu1_buf
                             + size);
             size += size_pred_luma;
             size = ALIGN64(size);
 
             /* prediction buffer intra 16x16 */
             ps_codec->as_process[i].pu1_pred_mb_intra_16x16 = (void *) (pu1_buf
                             + size);
             size += size_pred_luma;
             size = ALIGN64(size);
 
             /* prediction buffer intra 16x16 plane*/
             ps_codec->as_process[i].pu1_pred_mb_intra_16x16_plane =
                             (void *) (pu1_buf + size);
             size += size_pred_luma;
             size = ALIGN64(size);
 
             /* prediction buffer intra chroma*/
             ps_codec->as_process[i].pu1_pred_mb_intra_chroma = (void *) (pu1_buf
                             + size);
             size += size_pred_chroma;
             size = ALIGN64(size);
 
             /* prediction buffer intra chroma plane*/
             ps_codec->as_process[i].pu1_pred_mb_intra_chroma_plane =
                             (void *) (pu1_buf + size);
             size += size_pred_chroma;
             size = ALIGN64(size);
 
             /* Fwd transform output */
             ps_codec->as_process[i].pi2_res_buf = (void *) (pu1_buf + size);
             ps_codec->as_process[i].i4_res_strd = 16;
             size += size_fwd;
             size = ALIGN64(size);
 
             /* Fwd transform output */
             ps_codec->as_process[i].pi2_res_buf_intra_4x4 = (void *) (pu1_buf
                             + size);
             size += size_fwd;
             size = ALIGN64(size);
 
             /* scratch buffer used during inverse transform */
             ps_codec->as_process[i].pv_scratch_buff = (void *) (pu1_buf + size);
             size += size_inv;
             size = ALIGN64(size);
 
             for (j = 0; j < SUBPEL_BUFF_CNT; j++)
             {
                 ps_codec->as_process[i].apu1_subpel_buffs[j] = (pu1_buf + size);
                 size += ALIGN64(size_hp);
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_QUANT_PARAM];
     {
         /* pointer to storage space */
         UWORD8 *pu1_buf = (UWORD8 *) ps_mem_rec->pv_base;
 
         /* size of qp, threshold matrix, fwd scaling list for one plane */
         WORD32 size_quant_param, size_thres_mat, size_fwd_weight_mat,
                         size_satqd_weight_mat;
 
         /* temp var */
         WORD32 total_size = 0;
 
         /* size of quantization parameter list of 1 plane */
         size_quant_param = ALIGN64(sizeof(quant_params_t));
 
         /* size of threshold matrix for quantization
          * (assuming the transform_8x8_flag is disabled).
          * for 1 plane */
         size_thres_mat = ALIGN64(sizeof(WORD16) * 4 * 4);
 
         /* size of forward weight matrix for quantization
          * (assuming the transform_8x8_flag is disabled).
          * for 1 plane */
         size_fwd_weight_mat = ALIGN64(sizeof(WORD16) * 4 * 4);
 
         /* size of SATQD matrix*/
         size_satqd_weight_mat = ALIGN64(sizeof(UWORD16) * 9);
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             quant_params_t **ps_qp_params = ps_codec->as_process[i].ps_qp_params;
 
             /* quantization param structure */
             ps_qp_params[0] = (quant_params_t *) (pu1_buf + total_size);
             total_size = total_size + size_quant_param;
             ps_qp_params[1] = (quant_params_t *) (pu1_buf + total_size);
             total_size = total_size + size_quant_param;
             ps_qp_params[2] = (quant_params_t *) (pu1_buf + total_size);
             total_size = total_size + size_quant_param;
 
             /* threshold matrix for quantization */
             ps_qp_params[0]->pu2_thres_mat = (void *) (pu1_buf + total_size);
             total_size = total_size + size_thres_mat;
             ps_qp_params[1]->pu2_thres_mat = (void *) (pu1_buf + total_size);
             total_size = total_size + size_thres_mat;
             ps_qp_params[2]->pu2_thres_mat = (void *) (pu1_buf + total_size);
             total_size = total_size + size_thres_mat;
 
             /* fwd weight matrix */
             ps_qp_params[0]->pu2_weigh_mat = (void *) (pu1_buf + total_size);
             total_size = total_size + size_fwd_weight_mat;
             ps_qp_params[1]->pu2_weigh_mat = (void *) (pu1_buf + total_size);
             total_size = total_size + size_fwd_weight_mat;
             ps_qp_params[2]->pu2_weigh_mat = (void *) (pu1_buf + total_size);
             total_size = total_size + size_fwd_weight_mat;
 
             /* threshold matrix for SATQD */
             ps_qp_params[0]->pu2_sad_thrsh = (void *) (pu1_buf + total_size);
             total_size = total_size + size_satqd_weight_mat;
             ps_qp_params[1]->pu2_sad_thrsh = (void *) (pu1_buf + total_size);
             total_size = total_size + size_satqd_weight_mat;
             ps_qp_params[2]->pu2_sad_thrsh = (void *) (pu1_buf + total_size);
             total_size = total_size + size_satqd_weight_mat;
 
             total_size = ALIGN128(total_size);
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_TOP_ROW_SYN_INFO];
     {
         /* total size of the mem record */
         WORD32 total_size = 0, size_csbp, size_intra_modes, size_mv;
 
         /* pointer to buffer */
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         /* size in bytes to store  1 row of mb_info_t */
         /* one additional mb, to avoid checking end of row condition */
         size_csbp = (max_mb_cols + 1) * sizeof(mb_info_t);
 
         /* size in bytes to store  1 row of intra macroblock sub modes */
         size_intra_modes = max_mb_cols * sizeof(UWORD8) * 16;
 
         /* size in bytes to store  1 row + 1 of enc_pu_t */
         /* one additional mb, to avoid checking end of row condition */
         size_mv = (max_mb_cols + 1) * sizeof(enc_pu_t);
 
         /* total size per proc ctxt */
         total_size = size_csbp + size_intra_modes + size_mv;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 ps_codec->as_process[i].ps_top_row_mb_syntax_ele_base =
                                 (mb_info_t *) pu1_buf;
                 ps_codec->as_process[i].pu1_top_mb_intra_modes_base = pu1_buf
                                 + size_csbp;
                 ps_codec->as_process[i].ps_top_row_pu_base =
                                 (enc_pu_t *) (pu1_buf + size_csbp
                                                 + size_intra_modes);
             }
             else
             {
                 ps_codec->as_process[i].ps_top_row_mb_syntax_ele_base =
                                 (mb_info_t *) (pu1_buf + total_size);
                 ps_codec->as_process[i].pu1_top_mb_intra_modes_base = pu1_buf
                                 + total_size + size_csbp;
                 ps_codec->as_process[i].ps_top_row_pu_base =
                                 (enc_pu_t *) (pu1_buf + total_size + size_csbp
                                                 + size_intra_modes);
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_BS_QP];
     {
         UWORD8 *pu1_buf_ping, *pu1_buf_pong;
 
         /* total size of the mem record */
         WORD32 total_size = 0;
 
         /* size in bytes to store vertical edge bs, horizontal edge bs and qp of every mb*/
         WORD32 vert_bs_size, horz_bs_size, qp_size;
 
         /* vertical edge bs = total number of vertical edges * number of bytes per each edge */
         /* total num of v edges = total mb * 4 (assuming transform_8x8_flag = 0),
          * each edge is formed by 4 pairs of subblks, requiring 4 bytes to storing bs */
         vert_bs_size = ALIGN64(max_mb_cnt * 4 * 4);
 
         /* horizontal edge bs = total number of horizontal edges * number of bytes per each edge */
         /* total num of h edges = total mb * 4 (assuming transform_8x8_flag = 0),
          * each edge is formed by 4 pairs of subblks, requiring 4 bytes to storing bs */
         horz_bs_size = ALIGN64(max_mb_cnt * 4 * 4);
 
         /* qp of each mb requires 1 byte */
         qp_size = ALIGN64(max_mb_cnt);
 
         /* total size */
         total_size = vert_bs_size + horz_bs_size + qp_size;
 
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             if (i < MAX_PROCESS_CTXT / MAX_CTXT_SETS)
             {
                 pu1_buf_ping = (UWORD8 *) ps_mem_rec->pv_base;
 
                 /* vertical edge bs storage space */
                 ps_codec->as_process[i].s_deblk_ctxt.s_bs_ctxt.pu4_pic_vert_bs =
                                 (UWORD32 *) pu1_buf_ping;
                 pu1_buf_ping += vert_bs_size;
 
                 /* horizontal edge bs storage space */
                 ps_codec->as_process[i].s_deblk_ctxt.s_bs_ctxt.pu4_pic_horz_bs =
                                 (UWORD32 *) pu1_buf_ping;
                 pu1_buf_ping += horz_bs_size;
 
                 /* qp */
                 ps_codec->as_process[i].s_deblk_ctxt.s_bs_ctxt.pu1_pic_qp =
                                 (UWORD8 *) pu1_buf_ping;
                 pu1_buf_ping += qp_size;
             }
             else
             {
                 pu1_buf_pong = (UWORD8 *) ps_mem_rec->pv_base;
                 pu1_buf_pong += total_size;
 
                 /* vertical edge bs storage space */
                 ps_codec->as_process[i].s_deblk_ctxt.s_bs_ctxt.pu4_pic_vert_bs =
                                 (UWORD32 *) pu1_buf_pong;
                 pu1_buf_pong += vert_bs_size;
 
                 /* horizontal edge bs storage space */
                 ps_codec->as_process[i].s_deblk_ctxt.s_bs_ctxt.pu4_pic_horz_bs =
                                 (UWORD32 *) pu1_buf_pong;
                 pu1_buf_pong += horz_bs_size;
 
                 /* qp */
                 ps_codec->as_process[i].s_deblk_ctxt.s_bs_ctxt.pu1_pic_qp =
                                 (UWORD8 *) pu1_buf_pong;
                 pu1_buf_pong += qp_size;
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_INP_PIC];
     {
         ps_codec->pv_inp_buf_mgr_base = ps_mem_rec->pv_base;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_OUT];
     {
         ps_codec->pv_out_buf_mgr_base = ps_mem_rec->pv_base;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_CSC];
     {
         ps_codec->pu1_y_csc_buf_base = ps_mem_rec->pv_base;
         ps_codec->pu1_uv_csc_buf_base = (UWORD8 *) ps_mem_rec->pv_base
                         + (max_ht_luma * max_wd_luma);
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_REF_PIC];
     {
         /* size of buf mgr struct */
         WORD32 size = ih264_buf_mgr_size();
 
         /* temp var */
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         /* pic buffer mgr */
         ps_codec->pv_ref_buf_mgr_base = pu1_buf;
 
         /* picture bank */
         ps_codec->pv_pic_buf_base = pu1_buf + size;
         ps_codec->i4_total_pic_buf_size = ps_mem_rec->u4_mem_size - size;
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_MB_INFO_NMB];
     {
         /* temp var */
         UWORD8 *pu1_buf = ps_mem_rec->pv_base;
 
         /* size of nmb ctxt */
         WORD32 size = max_mb_cols * sizeof(mb_info_nmb_t);
 
         WORD32 nmb_cntr, subpel_buf_size;
 
         /* init nmb info structure pointer in all proc ctxts */
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             ps_codec->as_process[i].ps_nmb_info = (mb_info_nmb_t *) (pu1_buf);
 
             pu1_buf += size;
         }
 
         subpel_buf_size = MB_SIZE * MB_SIZE * sizeof(UWORD8);
 
         /* adjusting pointers for nmb halfpel buffer */
         for (i = 0; i < MAX_PROCESS_CTXT; i++)
         {
             mb_info_nmb_t* ps_mb_info_nmb =
                             &ps_codec->as_process[i].ps_nmb_info[0];
 
             for (nmb_cntr = 0; nmb_cntr < max_mb_cols; nmb_cntr++)
             {
                 ps_mb_info_nmb[nmb_cntr].pu1_best_sub_pel_buf = pu1_buf;
 
                 pu1_buf = pu1_buf + subpel_buf_size;
 
                 ps_mb_info_nmb[nmb_cntr].u4_bst_spel_buf_strd = MB_SIZE;
             }
         }
     }
 
     ps_mem_rec = &ps_mem_rec_base[MEM_REC_RC];
     {
         ih264e_get_rate_control_mem_tab(&ps_codec->s_rate_control, ps_mem_rec,
                                         USE_BASE);
     }
 
     /* init codec ctxt */
     status = ih264e_init(ps_codec);
 
     return status;
 }
 
 /**
 *******************************************************************************
 *
 * @brief
 *  Retrieves mem records passed to the codec
 *
 * @par Description:
 *  Retrieves mem recs passed during init
 *
 * @param[in] ps_codec_obj
 *  Pointer to codec object at API level
 *
 * @param[in] pv_api_ip
 *  Pointer to input argument structure
 *
 * @param[out] pv_api_op
 *  Pointer to output argument structure
 *
 * @returns error status
 *
 * @remarks none
 *
 *******************************************************************************
 */
