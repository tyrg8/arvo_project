commit f402b48f6cb04be650846e84454d19b86be848c7
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Thu Jun 7 18:44:57 2018 -0400

    ...

diff --git a/MagickCore/draw.c b/MagickCore/draw.c
index 9ba669d6b..436a5afb3 100644
--- a/MagickCore/draw.c
+++ b/MagickCore/draw.c
@@ -6116,503 +6116,503 @@ static void TraceLine(PrimitiveInfo *primitive_info,const PointInfo start,
 static size_t TracePath(MVGInfo *mvg_info,const char *path,
   ExceptionInfo *exception)
 {
   char
     *next_token,
     token[MagickPathExtent];
 
   const char
     *p;
 
   double
     x,
     y;
 
   int
     attribute,
     last_attribute;
 
   MagickBooleanType
     status;
 
   PointInfo
     end = {0.0, 0.0},
     points[4] = { {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0}, {0.0, 0.0} },
     point = {0.0, 0.0},
     start = {0.0, 0.0};
 
   PrimitiveInfo
     *primitive_info;
 
   PrimitiveType
     primitive_type;
 
   register PrimitiveInfo
     *q;
 
   register ssize_t
     i;
 
   size_t
     number_coordinates,
     z_count;
 
   ssize_t
     subpath_offset;
 
   subpath_offset=mvg_info->offset;
   primitive_info=(*mvg_info->primitive_info)+mvg_info->offset;
   status=MagickTrue;
   attribute=0;
   number_coordinates=0;
   z_count=0;
   primitive_type=primitive_info->primitive;
   q=primitive_info;
   for (p=path; *p != '\0'; )
   {
     if (status == MagickFalse)
       break;
     while (isspace((int) ((unsigned char) *p)) != 0)
       p++;
     if (*p == '\0')
       break;
     last_attribute=attribute;
     attribute=(int) (*p++);
     switch (attribute)
     {
       case 'a':
       case 'A':
       {
         double
           angle = 0.0;
 
         MagickBooleanType
           large_arc = MagickFalse,
           sweep = MagickFalse;
 
         PointInfo
           arc = {0.0, 0.0};
 
         /*
           Elliptical arc.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           arc.x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           arc.y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           angle=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           large_arc=StringToLong(token) != 0 ? MagickTrue : MagickFalse;
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
-          sweep=fabs(StringToDouble(token&next_token)) < DrawEpsilon ?
+          sweep=fabs(StringToDouble(token,&next_token)) < DrawEpsilon ?
             MagickFalse : MagickTrue;
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           end.x=(double) (attribute == (int) 'A' ? x : point.x+x);
           end.y=(double) (attribute == (int) 'A' ? y : point.y+y);
           TraceArcPath(mvg_info,point,end,arc,angle,large_arc,sweep);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'c':
       case 'C':
       {
         /*
           Cubic Bézier curve.
         */
         do
         {
           points[0]=point;
           for (i=1; i < 4; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             end.x=(double) (attribute == (int) 'C' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'C' ? y : point.y+y);
             points[i]=end;
           }
           for (i=0; i < 4; i++)
             (q+i)->point=points[i];
           TraceBezier(mvg_info,4);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'H':
       case 'h':
       {
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'H' ? x: point.x+x);
           if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
               (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
             q=(*mvg_info->primitive_info)+mvg_info->offset;
           TracePoint(q,point);
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'l':
       case 'L':
       {
         /*
           Line to.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'L' ? x : point.x+x);
           point.y=(double) (attribute == (int) 'L' ? y : point.y+y);
           if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
               (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
             q=(*mvg_info->primitive_info)+mvg_info->offset;
           TracePoint(q,point);
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'M':
       case 'm':
       {
         /*
           Move to.
         */
         if (mvg_info->offset != subpath_offset)
           {
             primitive_info=(*mvg_info->primitive_info)+subpath_offset;
             primitive_info->coordinates=(size_t) (q-primitive_info);
             number_coordinates+=primitive_info->coordinates;
             primitive_info=q;
             subpath_offset=mvg_info->offset;
           }
         i=0;
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           x=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.x=(double) (attribute == (int) 'M' ? x : point.x+x);
           point.y=(double) (attribute == (int) 'M' ? y : point.y+y);
           if (i == 0)
             start=point;
           i++;
           if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
               (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
             q=(*mvg_info->primitive_info)+mvg_info->offset;
           TracePoint(q,point);
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'q':
       case 'Q':
       {
         /*
           Quadratic Bézier curve.
         */
         do
         {
           points[0]=point;
           for (i=1; i < 3; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             if (*p == ',')
               p++;
             end.x=(double) (attribute == (int) 'Q' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'Q' ? y : point.y+y);
             points[i]=end;
           }
           for (i=0; i < 3; i++)
             (q+i)->point=points[i];
           TraceBezier(mvg_info,3);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 's':
       case 'S':
       {
         /*
           Cubic Bézier curve.
         */
         do
         {
           points[0]=points[3];
           points[1].x=2.0*points[3].x-points[2].x;
           points[1].y=2.0*points[3].y-points[2].y;
           for (i=2; i < 4; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             if (*p == ',')
               p++;
             end.x=(double) (attribute == (int) 'S' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'S' ? y : point.y+y);
             points[i]=end;
           }
           if (strchr("CcSs",last_attribute) == (char *) NULL)
             {
               points[0]=point;
               points[1]=point;
             }
           for (i=0; i < 4; i++)
             (q+i)->point=points[i];
           TraceBezier(mvg_info,4);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           last_attribute=attribute;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 't':
       case 'T':
       {
         /*
           Quadratic Bézier curve.
         */
         do
         {
           points[0]=points[2];
           points[1].x=2.0*points[2].x-points[1].x;
           points[1].y=2.0*points[2].y-points[1].y;
           for (i=2; i < 3; i++)
           {
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             x=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             GetNextToken(p,&p,MagickPathExtent,token);
             if (*token == ',')
               GetNextToken(p,&p,MagickPathExtent,token);
             y=StringToDouble(token,&next_token);
             if (token == next_token)
               ThrowPointExpectedException(token,exception);
             end.x=(double) (attribute == (int) 'T' ? x : point.x+x);
             end.y=(double) (attribute == (int) 'T' ? y : point.y+y);
             points[i]=end;
           }
           if (status == MagickFalse)
             break;
           if (strchr("QqTt",last_attribute) == (char *) NULL)
             {
               points[0]=point;
               points[1]=point;
             }
           for (i=0; i < 3; i++)
             (q+i)->point=points[i];
           TraceBezier(mvg_info,3);
           q=(*mvg_info->primitive_info)+mvg_info->offset;
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           point=end;
           last_attribute=attribute;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'v':
       case 'V':
       {
         /*
           Line to.
         */
         do
         {
           GetNextToken(p,&p,MagickPathExtent,token);
           if (*token == ',')
             GetNextToken(p,&p,MagickPathExtent,token);
           y=StringToDouble(token,&next_token);
           if (token == next_token)
             ThrowPointExpectedException(token,exception);
           point.y=(double) (attribute == (int) 'V' ? y : point.y+y);
           if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
               (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
             q=(*mvg_info->primitive_info)+mvg_info->offset;
           TracePoint(q,point);
           mvg_info->offset+=q->coordinates;
           q+=q->coordinates;
           while (isspace((int) ((unsigned char) *p)) != 0)
             p++;
           if (*p == ',')
             p++;
         } while (IsPoint(p) != MagickFalse);
         break;
       }
       case 'z':
       case 'Z':
       {
         /*
           Close path.
         */
         point=start;
         if (((size_t) (mvg_info->offset+4096) > *mvg_info->extent) &&
             (CheckPrimitiveExtent(mvg_info,4096) != MagickFalse))
           q=(*mvg_info->primitive_info)+mvg_info->offset;
         TracePoint(q,point);
         mvg_info->offset+=q->coordinates;
         q+=q->coordinates;
         primitive_info->coordinates=(size_t) (q-primitive_info);
         primitive_info->closed_subpath=MagickTrue;
         number_coordinates+=primitive_info->coordinates;
         primitive_info=q;
         subpath_offset=mvg_info->offset;
         z_count++;
         break;
       }
       default:
       {
         ThrowPointExpectedException(token,exception);
         break;
       }
     }
   }
   if (status == MagickFalse)
     return(0);
   primitive_info=(*mvg_info->primitive_info)+subpath_offset;
   primitive_info->coordinates=(size_t) (q-primitive_info);
   number_coordinates+=primitive_info->coordinates;
   for (i=0; i < (ssize_t) number_coordinates; i++)
   {
     q--;
     q->primitive=primitive_type;
     if (z_count > 1)
       q->method=FillToBorderMethod;
   }
   q=primitive_info;
   return(number_coordinates);
 }
