commit 11c7f47df7cbe2e672c8a975aa1c003d92f4fdc9
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Mon Mar 5 06:50:45 2018 -0500

    https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=6747

diff --git a/coders/miff.c b/coders/miff.c
index c79e2b657..2107c769b 100644
--- a/coders/miff.c
+++ b/coders/miff.c
@@ -400,1320 +400,1321 @@ static void RelinquishZIPMemory(voidpf context,voidpf memory)
 static Image *ReadMIFFImage(const ImageInfo *image_info,
   ExceptionInfo *exception)
 {
 #define BZipMaxExtent(x)  ((x)+((x)/100)+600)
 #define LZMAMaxExtent(x)  ((x)+((x)/3)+128)
 #define ZipMaxExtent(x)  ((x)+(((x)+7) >> 3)+(((x)+63) >> 6)+11)
 
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
   bz_stream
     bzip_info;
 #endif
 
   char
     id[MagickPathExtent],
     keyword[MagickPathExtent],
     *options;
 
   const unsigned char
     *p;
 
   double
     version;
 
   GeometryInfo
     geometry_info;
 
   Image
     *image;
 
   int
     c;
 
   LinkedListInfo
     *profiles;
 
 #if defined(MAGICKCORE_LZMA_DELEGATE)
   lzma_stream
     initialize_lzma = LZMA_STREAM_INIT,
     lzma_info;
 
   lzma_allocator
     allocator;
 #endif
 
   MagickBooleanType
     status;
 
   PixelInfo
     pixel;
 
   MagickStatusType
     flags;
 
   QuantumFormatType
     quantum_format;
 
   QuantumInfo
     *quantum_info;
 
   QuantumType
     quantum_type;
 
   register ssize_t
     i;
 
   size_t
     compress_extent,
     length,
     packet_size;
 
   ssize_t
     count;
 
   unsigned char
     *compress_pixels,
     *pixels;
 
   size_t
     colors;
 
   ssize_t
     y;
 
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
   z_stream
     zip_info;
 #endif
 
   /*
     Open image file.
   */
   assert(image_info != (const ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
       image_info->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   image=AcquireImage(image_info,exception);
   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
   if (status == MagickFalse)
     {
       image=DestroyImageList(image);
       return((Image *) NULL);
     }
   /*
     Decode image header;  header terminates one character beyond a ':'.
   */
   c=ReadBlobByte(image);
   if (c == EOF)
     ThrowReaderException(CorruptImageError,"ImproperImageHeader");
   *id='\0';
   (void) ResetMagickMemory(keyword,0,sizeof(keyword));
   version=0.0;
   (void) version;
   do
   {
     /*
       Decode image header;  header terminates one character beyond a ':'.
     */
     SetGeometryInfo(&geometry_info);
     length=MagickPathExtent;
     options=AcquireString((char *) NULL);
     quantum_format=UndefinedQuantumFormat;
     profiles=(LinkedListInfo *) NULL;
     colors=0;
     image->depth=8UL;
     image->compression=NoCompression;
     while ((isgraph(c) != MagickFalse) && (c != (int) ':'))
     {
       register char
         *p;
 
       if (c == (int) '{')
         {
           char
             *comment;
 
           /*
             Read comment-- any text between { }.
           */
           length=MagickPathExtent;
           comment=AcquireString((char *) NULL);
           for (p=comment; comment != (char *) NULL; p++)
           {
             c=ReadBlobByte(image);
             if (c == (int) '\\')
               c=ReadBlobByte(image);
             else
               if ((c == EOF) || (c == (int) '}'))
                 break;
             if ((size_t) (p-comment+1) >= length)
               {
                 *p='\0';
                 length<<=1;
                 comment=(char *) ResizeQuantumMemory(comment,length+
                   MagickPathExtent,sizeof(*comment));
                 if (comment == (char *) NULL)
                   break;
                 p=comment+strlen(comment);
               }
             *p=(char) c;
           }
           if (comment == (char *) NULL)
             {
               options=DestroyString(options);
               ThrowReaderException(ResourceLimitError,
                 "MemoryAllocationFailed");
             }
           *p='\0';
           (void) SetImageProperty(image,"comment",comment,exception);
           comment=DestroyString(comment);
           c=ReadBlobByte(image);
         }
       else
         if (isalnum(c) != MagickFalse)
           {
             /*
               Get the keyword.
             */
             length=MagickPathExtent-1;
             p=keyword;
             do
             {
               if (c == (int) '=')
                 break;
               if ((size_t) (p-keyword) < (MagickPathExtent-1))
                 *p++=(char) c;
               c=ReadBlobByte(image);
             } while (c != EOF);
             *p='\0';
             p=options;
             while ((isspace((int) ((unsigned char) c)) != 0) && (c != EOF))
               c=ReadBlobByte(image);
             if (c == (int) '=')
               {
                 /*
                   Get the keyword value.
                 */
                 c=ReadBlobByte(image);
                 while ((c != (int) '}') && (c != EOF))
                 {
                   if ((size_t) (p-options+1) >= length)
                     {
                       *p='\0';
                       length<<=1;
                       options=(char *) ResizeQuantumMemory(options,length+
                         MagickPathExtent,sizeof(*options));
                       if (options == (char *) NULL)
                         break;
                       p=options+strlen(options);
                     }
                   *p++=(char) c;
                   c=ReadBlobByte(image);
                   if (c == '\\')
                     {
                       c=ReadBlobByte(image);
                       if (c == (int) '}')
                         {
                           *p++=(char) c;
                           c=ReadBlobByte(image);
                         }
                     }
                   if (*options != '{')
                     if (isspace((int) ((unsigned char) c)) != 0)
                       break;
                 }
                 if (options == (char *) NULL)
                   ThrowReaderException(ResourceLimitError,
                     "MemoryAllocationFailed");
               }
             *p='\0';
             if (*options == '{')
               (void) CopyMagickString(options,options+1,strlen(options));
             /*
               Assign a value to the specified keyword.
             */
             switch (*keyword)
             {
               case 'a':
               case 'A':
               {
                 if (LocaleCompare(keyword,"alpha-trait") == 0)
                   {
                     ssize_t
                       alpha_trait;
 
                     alpha_trait=ParseCommandOption(MagickPixelTraitOptions,
                       MagickFalse,options);
                     if (alpha_trait < 0)
                       break;
                     image->alpha_trait=(PixelTrait) alpha_trait;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'b':
               case 'B':
               {
                 if (LocaleCompare(keyword,"background-color") == 0)
                   {
                     (void) QueryColorCompliance(options,AllCompliance,
                       &image->background_color,exception);
                     break;
                   }
                 if (LocaleCompare(keyword,"blue-primary") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->chromaticity.blue_primary.x=geometry_info.rho;
                     image->chromaticity.blue_primary.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->chromaticity.blue_primary.y=
                         image->chromaticity.blue_primary.x;
                     break;
                   }
                 if (LocaleCompare(keyword,"border-color") == 0)
                   {
                     (void) QueryColorCompliance(options,AllCompliance,
                       &image->border_color,exception);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'c':
               case 'C':
               {
                 if (LocaleCompare(keyword,"class") == 0)
                   {
                     ssize_t
                       storage_class;
 
                     storage_class=ParseCommandOption(MagickClassOptions,
                       MagickFalse,options);
                     if (storage_class < 0)
                       break;
                     image->storage_class=(ClassType) storage_class;
                     break;
                   }
                 if (LocaleCompare(keyword,"colors") == 0)
                   {
                     colors=StringToUnsignedLong(options);
                     break;
                   }
                 if (LocaleCompare(keyword,"colorspace") == 0)
                   {
                     ssize_t
                       colorspace;
 
                     colorspace=ParseCommandOption(MagickColorspaceOptions,
                       MagickFalse,options);
                     if (colorspace < 0)
                       break;
                     image->colorspace=(ColorspaceType) colorspace;
                     break;
                   }
                 if (LocaleCompare(keyword,"compression") == 0)
                   {
                     ssize_t
                       compression;
 
                     compression=ParseCommandOption(MagickCompressOptions,
                       MagickFalse,options);
                     if (compression < 0)
                       break;
                     image->compression=(CompressionType) compression;
                     break;
                   }
                 if (LocaleCompare(keyword,"columns") == 0)
                   {
                     image->columns=StringToUnsignedLong(options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'd':
               case 'D':
               {
                 if (LocaleCompare(keyword,"delay") == 0)
                   {
                     image->delay=StringToUnsignedLong(options);
                     break;
                   }
                 if (LocaleCompare(keyword,"depth") == 0)
                   {
                     image->depth=StringToUnsignedLong(options);
                     break;
                   }
                 if (LocaleCompare(keyword,"dispose") == 0)
                   {
                     ssize_t
                       dispose;
 
                     dispose=ParseCommandOption(MagickDisposeOptions,MagickFalse,
                       options);
                     if (dispose < 0)
                       break;
                     image->dispose=(DisposeType) dispose;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'e':
               case 'E':
               {
                 if (LocaleCompare(keyword,"endian") == 0)
                   {
                     ssize_t
                       endian;
 
                     endian=ParseCommandOption(MagickEndianOptions,MagickFalse,
                       options);
                     if (endian < 0)
                       break;
                     image->endian=(EndianType) endian;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'g':
               case 'G':
               {
                 if (LocaleCompare(keyword,"gamma") == 0)
                   {
                     image->gamma=StringToDouble(options,(char **) NULL);
                     break;
                   }
                 if (LocaleCompare(keyword,"gravity") == 0)
                   {
                     ssize_t
                       gravity;
 
                     gravity=ParseCommandOption(MagickGravityOptions,MagickFalse,
                       options);
                     if (gravity < 0)
                       break;
                     image->gravity=(GravityType) gravity;
                     break;
                   }
                 if (LocaleCompare(keyword,"green-primary") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->chromaticity.green_primary.x=geometry_info.rho;
                     image->chromaticity.green_primary.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->chromaticity.green_primary.y=
                         image->chromaticity.green_primary.x;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'i':
               case 'I':
               {
                 if (LocaleCompare(keyword,"id") == 0)
                   {
                     (void) CopyMagickString(id,options,MagickPathExtent);
                     break;
                   }
                 if (LocaleCompare(keyword,"iterations") == 0)
                   {
                     image->iterations=StringToUnsignedLong(options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'm':
               case 'M':
               {
                 if (LocaleCompare(keyword,"matte") == 0)
                   {
                     ssize_t
                       matte;
 
                     matte=ParseCommandOption(MagickBooleanOptions,MagickFalse,
                       options);
                     if (matte < 0)
                       break;
                     image->alpha_trait=matte == 0 ? UndefinedPixelTrait :
                       BlendPixelTrait;
                     break;
                   }
                 if (LocaleCompare(keyword,"mattecolor") == 0)
                   {
                     (void) QueryColorCompliance(options,AllCompliance,
                       &image->matte_color,exception);
                     break;
                   }
                 if (LocaleCompare(keyword,"montage") == 0)
                   {
                     (void) CloneString(&image->montage,options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'o':
               case 'O':
               {
                 if (LocaleCompare(keyword,"orientation") == 0)
                   {
                     ssize_t
                       orientation;
 
                     orientation=ParseCommandOption(MagickOrientationOptions,
                       MagickFalse,options);
                     if (orientation < 0)
                       break;
                     image->orientation=(OrientationType) orientation;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'p':
               case 'P':
               {
                 if (LocaleCompare(keyword,"page") == 0)
                   {
                     char
                       *geometry;
 
                     geometry=GetPageGeometry(options);
                     (void) ParseAbsoluteGeometry(geometry,&image->page);
                     geometry=DestroyString(geometry);
                     break;
                   }
                 if (LocaleCompare(keyword,"pixel-intensity") == 0)
                   {
                     ssize_t
                       intensity;
 
                     intensity=ParseCommandOption(MagickPixelIntensityOptions,
                       MagickFalse,options);
                     if (intensity < 0)
                       break;
                     image->intensity=(PixelIntensityMethod) intensity;
                     break;
                   }
                 if (LocaleCompare(keyword,"profile") == 0)
                   {
                     if (profiles == (LinkedListInfo *) NULL)
                       profiles=NewLinkedList(0);
                     (void) AppendValueToLinkedList(profiles,
                       AcquireString(options));
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'q':
               case 'Q':
               {
                 if (LocaleCompare(keyword,"quality") == 0)
                   {
                     image->quality=StringToUnsignedLong(options);
                     break;
                   }
                 if ((LocaleCompare(keyword,"quantum-format") == 0) ||
                     (LocaleCompare(keyword,"quantum:format") == 0))
                   {
                     ssize_t
                       format;
 
                     format=ParseCommandOption(MagickQuantumFormatOptions,
                       MagickFalse,options);
                     if (format < 0)
                       break;
                     quantum_format=(QuantumFormatType) format;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'r':
               case 'R':
               {
                 if (LocaleCompare(keyword,"red-primary") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->chromaticity.red_primary.x=geometry_info.rho;
                     image->chromaticity.red_primary.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->chromaticity.red_primary.y=
                         image->chromaticity.red_primary.x;
                     break;
                   }
                 if (LocaleCompare(keyword,"rendering-intent") == 0)
                   {
                     ssize_t
                       rendering_intent;
 
                     rendering_intent=ParseCommandOption(MagickIntentOptions,
                       MagickFalse,options);
                     if (rendering_intent < 0)
                       break;
                     image->rendering_intent=(RenderingIntent) rendering_intent;
                     break;
                   }
                 if (LocaleCompare(keyword,"resolution") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->resolution.x=geometry_info.rho;
                     image->resolution.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->resolution.y=image->resolution.x;
                     break;
                   }
                 if (LocaleCompare(keyword,"rows") == 0)
                   {
                     image->rows=StringToUnsignedLong(options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 's':
               case 'S':
               {
                 if (LocaleCompare(keyword,"scene") == 0)
                   {
                     image->scene=StringToUnsignedLong(options);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 't':
               case 'T':
               {
                 if (LocaleCompare(keyword,"ticks-per-second") == 0)
                   {
                     image->ticks_per_second=(ssize_t) StringToLong(options);
                     break;
                   }
                 if (LocaleCompare(keyword,"tile-offset") == 0)
                   {
                     char
                       *geometry;
 
                     geometry=GetPageGeometry(options);
                     (void) ParseAbsoluteGeometry(geometry,&image->tile_offset);
                     geometry=DestroyString(geometry);
                     break;
                   }
                 if (LocaleCompare(keyword,"type") == 0)
                   {
                     ssize_t
                       type;
 
                     type=ParseCommandOption(MagickTypeOptions,MagickFalse,
                       options);
                     if (type < 0)
                       break;
                     image->type=(ImageType) type;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'u':
               case 'U':
               {
                 if (LocaleCompare(keyword,"units") == 0)
                   {
                     ssize_t
                       units;
 
                     units=ParseCommandOption(MagickResolutionOptions,
                       MagickFalse,options);
                     if (units < 0)
                       break;
                     image->units=(ResolutionType) units;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'v':
               case 'V':
               {
                 if (LocaleCompare(keyword,"version") == 0)
                   {
                     version=StringToDouble(options,(char **) NULL);
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               case 'w':
               case 'W':
               {
                 if (LocaleCompare(keyword,"white-point") == 0)
                   {
                     flags=ParseGeometry(options,&geometry_info);
                     image->chromaticity.white_point.x=geometry_info.rho;
                     image->chromaticity.white_point.y=geometry_info.sigma;
                     if ((flags & SigmaValue) == 0)
                       image->chromaticity.white_point.y=
                         image->chromaticity.white_point.x;
                     break;
                   }
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
               default:
               {
                 (void) SetImageProperty(image,keyword,options,exception);
                 break;
               }
             }
           }
         else
           c=ReadBlobByte(image);
       while (isspace((int) ((unsigned char) c)) != 0)
         c=ReadBlobByte(image);
     }
     options=DestroyString(options);
     (void) ReadBlobByte(image);
     /*
       Verify that required image information is defined.
     */
     if ((LocaleCompare(id,"ImageMagick") != 0) ||
         (image->storage_class == UndefinedClass) ||
         (image->compression == UndefinedCompression) ||
         (image->colorspace == UndefinedColorspace) ||
         (image->columns == 0) || (image->rows == 0))
       {
         if (profiles != (LinkedListInfo *) NULL)
           profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);
         if (image->previous == (Image *) NULL)
           ThrowReaderException(CorruptImageError,"ImproperImageHeader");
         DeleteImageFromList(&image);
         (void) ThrowMagickException(exception,GetMagickModule(),
           CorruptImageError,"ImproperImageHeader","`%s'",image->filename);
         break;
       }
     if (image->montage != (char *) NULL)
       {
         register char
           *p;
 
         /*
           Image directory.
         */
         length=MagickPathExtent;
         image->directory=AcquireString((char *) NULL);
         p=image->directory;
         do
         {
           *p='\0';
           if ((strlen(image->directory)+MagickPathExtent) >= length)
             {
               /*
                 Allocate more memory for the image directory.
               */
               length<<=1;
               image->directory=(char *) ResizeQuantumMemory(image->directory,
                 length+MagickPathExtent,sizeof(*image->directory));
               if (image->directory == (char *) NULL)
                 ThrowReaderException(CorruptImageError,"UnableToReadImageData");
               p=image->directory+strlen(image->directory);
             }
           c=ReadBlobByte(image);
           if (c == EOF)
             break;
           *p++=(char) c;
         } while (c != (int) '\0');
       }
     if (profiles != (LinkedListInfo *) NULL)
       {
         const char
           *name;
 
         StringInfo
           *profile;
 
         /*
           Read image profiles.
         */
         ResetLinkedListIterator(profiles);
         name=(const char *) GetNextValueInLinkedList(profiles);
         while (name != (const char *) NULL)
         {
           length=ReadBlobMSBLong(image);
           if ((MagickSizeType) length > GetBlobSize(image))
             break;
           profile=AcquireStringInfo(length);
           if (profile == (StringInfo *) NULL)
             break;
           count=ReadBlob(image,length,GetStringInfoDatum(profile));
           if (count != (ssize_t) length)
             {
               profile=DestroyStringInfo(profile);
               break;
             }
           status=SetImageProfile(image,name,profile,exception);
           profile=DestroyStringInfo(profile);
           if (status == MagickFalse)
             break;
           name=(const char *) GetNextValueInLinkedList(profiles);
         }
         profiles=DestroyLinkedList(profiles,RelinquishMagickMemory);
       }
     image->depth=GetImageQuantumDepth(image,MagickFalse);
     if (image->storage_class == PseudoClass)
       {
         size_t
           packet_size;
 
         unsigned char
           *colormap;
 
         /*
           Create image colormap.
         */
         packet_size=(size_t) (3UL*image->depth/8UL);
         if ((MagickSizeType) colors > GetBlobSize(image))
           ThrowReaderException(CorruptImageError,"InsufficientImageDataInFile");
         if (((MagickSizeType) packet_size*colors) > GetBlobSize(image))
           ThrowReaderException(CorruptImageError,"InsufficientImageDataInFile");
         status=AcquireImageColormap(image,colors != 0 ? colors : 256,exception);
         if (status == MagickFalse)
           ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
         if (colors != 0)
           {
             /*
               Read image colormap from file.
             */
             colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
               packet_size*sizeof(*colormap));
             if (colormap == (unsigned char *) NULL)
               ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
             count=ReadBlob(image,packet_size*image->colors,colormap);
             p=colormap;
             switch (image->depth)
             {
               default:
                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);
                 ThrowReaderException(CorruptImageError,
                   "ImageDepthNotSupported");
               case 8:
               {
                 unsigned char
                   pixel;
 
                 for (i=0; i < (ssize_t) image->colors; i++)
                 {
                   p=PushCharPixel(p,&pixel);
                   image->colormap[i].red=(MagickRealType)
                     ScaleCharToQuantum(pixel);
                   p=PushCharPixel(p,&pixel);
                   image->colormap[i].green=(MagickRealType)
                     ScaleCharToQuantum(pixel);
                   p=PushCharPixel(p,&pixel);
                   image->colormap[i].blue=(MagickRealType)
                     ScaleCharToQuantum(pixel);
                 }
                 break;
               }
               case 16:
               {
                 unsigned short
                   pixel;
 
                 for (i=0; i < (ssize_t) image->colors; i++)
                 {
                   p=PushShortPixel(MSBEndian,p,&pixel);
                   image->colormap[i].red=(MagickRealType)
                     ScaleShortToQuantum(pixel);
                   p=PushShortPixel(MSBEndian,p,&pixel);
                   image->colormap[i].green=(MagickRealType)
                     ScaleShortToQuantum(pixel);
                   p=PushShortPixel(MSBEndian,p,&pixel);
                   image->colormap[i].blue=(MagickRealType)
                     ScaleShortToQuantum(pixel);
                 }
                 break;
               }
               case 32:
               {
                 unsigned int
                   pixel;
 
                 for (i=0; i < (ssize_t) image->colors; i++)
                 {
                   p=PushLongPixel(MSBEndian,p,&pixel);
                   image->colormap[i].red=(MagickRealType)
                     ScaleLongToQuantum(pixel);
                   p=PushLongPixel(MSBEndian,p,&pixel);
                   image->colormap[i].green=(MagickRealType)
                     ScaleLongToQuantum(pixel);
                   p=PushLongPixel(MSBEndian,p,&pixel);
                   image->colormap[i].blue=(MagickRealType)
                     ScaleLongToQuantum(pixel);
                 }
                 break;
               }
             }
             colormap=(unsigned char *) RelinquishMagickMemory(colormap);
           }
       }
     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     status=SetImageExtent(image,image->columns,image->rows,exception);
     if (status == MagickFalse)
       return(DestroyImageList(image));
+    (void) SetImageBackgroundColor(image,exception);
     /*
       Allocate image pixels.
     */
     quantum_info=AcquireQuantumInfo(image_info,image);
     if (quantum_info == (QuantumInfo *) NULL)
       ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
     if (quantum_format != UndefinedQuantumFormat)
       {
         status=SetQuantumFormat(image,quantum_info,quantum_format);
         if (status == MagickFalse)
           {
             quantum_info=DestroyQuantumInfo(quantum_info);
             ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
           }
       }
     packet_size=(size_t) (quantum_info->depth/8);
     if (image->storage_class == DirectClass)
       packet_size=(size_t) (3*quantum_info->depth/8);
     if (IsGrayColorspace(image->colorspace) != MagickFalse)
       packet_size=quantum_info->depth/8;
     if (image->alpha_trait != UndefinedPixelTrait)
       packet_size+=quantum_info->depth/8;
     if (image->colorspace == CMYKColorspace)
       packet_size+=quantum_info->depth/8;
     if (image->compression == RLECompression)
       packet_size++;
     compress_extent=MagickMax(MagickMax(BZipMaxExtent(packet_size*
       image->columns),LZMAMaxExtent(packet_size*image->columns)),
       ZipMaxExtent(packet_size*image->columns));
     compress_pixels=(unsigned char *) AcquireQuantumMemory(compress_extent,
       sizeof(*compress_pixels));
     if (compress_pixels == (unsigned char *) NULL)
       {
         quantum_info=DestroyQuantumInfo(quantum_info);
         ThrowReaderException(ResourceLimitError,"MemoryAllocationFailed");
       }
     /*
       Read image pixels.
     */
     quantum_type=RGBQuantum;
     if (image->alpha_trait != UndefinedPixelTrait)
       quantum_type=RGBAQuantum;
     if (image->colorspace == CMYKColorspace)
       {
         quantum_type=CMYKQuantum;
         if (image->alpha_trait != UndefinedPixelTrait)
           quantum_type=CMYKAQuantum;
       }
     if (IsGrayColorspace(image->colorspace) != MagickFalse)
       {
         quantum_type=GrayQuantum;
         if (image->alpha_trait != UndefinedPixelTrait)
           quantum_type=GrayAlphaQuantum;
       }
     if (image->storage_class == PseudoClass)
       {
         quantum_type=IndexQuantum;
         if (image->alpha_trait != UndefinedPixelTrait)
           quantum_type=IndexAlphaQuantum;
       }
     status=MagickTrue;
     GetPixelInfo(image,&pixel);
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
    (void) ResetMagickMemory(&bzip_info,0,sizeof(bzip_info));
 #endif
 #if defined(MAGICKCORE_LZMA_DELEGATE)
     (void) ResetMagickMemory(&allocator,0,sizeof(allocator));
 #endif
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
     (void) ResetMagickMemory(&zip_info,0,sizeof(zip_info));
 #endif
     switch (image->compression)
     {
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
       case BZipCompression:
       {
         int
           code;
 
         bzip_info.bzalloc=AcquireBZIPMemory;
         bzip_info.bzfree=RelinquishBZIPMemory;
         bzip_info.opaque=(void *) NULL;
         code=BZ2_bzDecompressInit(&bzip_info,(int) image_info->verbose,
           MagickFalse);
         if (code != BZ_OK)
           status=MagickFalse;
         break;
       }
 #endif
 #if defined(MAGICKCORE_LZMA_DELEGATE)
       case LZMACompression:
       {
         int
           code;
 
         allocator.alloc=AcquireLZMAMemory;
         allocator.free=RelinquishLZMAMemory;
         lzma_info=initialize_lzma;
         lzma_info.allocator=(&allocator);
         code=lzma_auto_decoder(&lzma_info,-1,0);
         if (code != LZMA_OK)
           status=MagickFalse;
         break;
       }
 #endif
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
       case LZWCompression:
       case ZipCompression:
       {
         int
           code;
 
         zip_info.zalloc=AcquireZIPMemory;
         zip_info.zfree=RelinquishZIPMemory;
         zip_info.opaque=(voidpf) NULL;
         code=inflateInit(&zip_info);
         if (code != Z_OK)
           status=MagickFalse;
         break;
       }
 #endif
       case RLECompression:
         break;
       default:
         break;
     }
     pixels=(unsigned char *) GetQuantumPixels(quantum_info);
     length=0;
     for (y=0; y < (ssize_t) image->rows; y++)
     {
       register ssize_t
         x;
 
       register Quantum
         *magick_restrict q;
 
       if (status == MagickFalse)
         break;
       q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
       if (q == (Quantum *) NULL)
         break;
       switch (image->compression)
       {
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
         case BZipCompression:
         {
           bzip_info.next_out=(char *) pixels;
           bzip_info.avail_out=(unsigned int) (packet_size*image->columns);
           do
           {
             int
               code;
 
             if (bzip_info.avail_in == 0)
               {
                 bzip_info.next_in=(char *) compress_pixels;
                 length=(size_t) BZipMaxExtent(packet_size*image->columns);
                 if (version != 0.0)
                   length=(size_t) ReadBlobMSBLong(image);
                 if (length > compress_extent)
                   {
                     (void) BZ2_bzDecompressEnd(&bzip_info);
                     quantum_info=DestroyQuantumInfo(quantum_info);
                     compress_pixels=(unsigned char *) RelinquishMagickMemory(
                       compress_pixels);
                     ThrowReaderException(CorruptImageError,
                       "UnableToReadImageData");
                   }
                 bzip_info.avail_in=(unsigned int) ReadBlob(image,length,
                   (unsigned char *) bzip_info.next_in);
               }
             code=BZ2_bzDecompress(&bzip_info);
             if (code < 0)
               {
                 status=MagickFalse;
                 break;
               }
             if (code == BZ_STREAM_END)
               break;
           } while (bzip_info.avail_out != 0);
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           break;
         }
 #endif
 #if defined(MAGICKCORE_LZMA_DELEGATE)
         case LZMACompression:
         {
           lzma_info.next_out=pixels;
           lzma_info.avail_out=packet_size*image->columns;
           do
           {
             int
               code;
 
             if (lzma_info.avail_in == 0)
               {
                 lzma_info.next_in=compress_pixels;
                 length=(size_t) ReadBlobMSBLong(image);
                 if (length > compress_extent)
                   {
                     lzma_end(&lzma_info);
                     quantum_info=DestroyQuantumInfo(quantum_info);
                     compress_pixels=(unsigned char *) RelinquishMagickMemory(
                       compress_pixels);
                     ThrowReaderException(CorruptImageError,
                       "UnableToReadImageData");
                   }
                 lzma_info.avail_in=(unsigned int) ReadBlob(image,length,
                   (unsigned char *) lzma_info.next_in);
               }
             code=lzma_code(&lzma_info,LZMA_RUN);
             if (code < 0)
               {
                 status=MagickFalse;
                 break;
               }
             if (code == LZMA_STREAM_END)
               break;
           } while (lzma_info.avail_out != 0);
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           break;
         }
 #endif
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
         case LZWCompression:
         case ZipCompression:
         {
           zip_info.next_out=pixels;
           zip_info.avail_out=(uInt) (packet_size*image->columns);
           do
           {
             int
               code;
 
             if (zip_info.avail_in == 0)
               {
                 zip_info.next_in=compress_pixels;
                 length=(size_t) ZipMaxExtent(packet_size*image->columns);
                 if (version != 0.0)
                   length=(size_t) ReadBlobMSBLong(image);
                 if (length > compress_extent)
                   {
                     (void) inflateEnd(&zip_info);
                     quantum_info=DestroyQuantumInfo(quantum_info);
                     compress_pixels=(unsigned char *) RelinquishMagickMemory(
                       compress_pixels);
                     ThrowReaderException(CorruptImageError,
                       "UnableToReadImageData");
                   }
                 zip_info.avail_in=(unsigned int) ReadBlob(image,length,
                   zip_info.next_in);
               }
             code=inflate(&zip_info,Z_SYNC_FLUSH);
             if (code < 0)
               {
                 status=MagickFalse;
                 break;
               }
             if (code == Z_STREAM_END)
               break;
           } while (zip_info.avail_out != 0);
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           break;
         }
 #endif
         case RLECompression:
         {
           for (x=0; x < (ssize_t) image->columns; x++)
           {
             if (length == 0)
               {
                 count=ReadBlob(image,packet_size,pixels);
                 PushRunlengthPacket(image,pixels,&length,&pixel,exception);
               }
             length--;
             if (image->storage_class == PseudoClass)
               SetPixelIndex(image,ClampToQuantum(pixel.index),q);
             else
               {
                 SetPixelRed(image,ClampToQuantum(pixel.red),q);
                 SetPixelGreen(image,ClampToQuantum(pixel.green),q);
                 SetPixelBlue(image,ClampToQuantum(pixel.blue),q);
                 if (image->colorspace == CMYKColorspace)
                   SetPixelBlack(image,ClampToQuantum(pixel.black),q);
               }
             if (image->alpha_trait != UndefinedPixelTrait)
               SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);
             q+=GetPixelChannels(image);
           }
           break;
         }
         default:
         {
           count=ReadBlob(image,packet_size*image->columns,pixels);
           (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
             quantum_type,pixels,exception);
           break;
         }
       }
       if (SyncAuthenticPixels(image,exception) == MagickFalse)
         break;
     }
     SetQuantumImageType(image,quantum_type);
     switch (image->compression)
     {
 #if defined(MAGICKCORE_BZLIB_DELEGATE)
       case BZipCompression:
       {
         int
           code;
 
         if (version == 0.0)
           {
             MagickOffsetType
               offset;
 
             offset=SeekBlob(image,-((MagickOffsetType)
               bzip_info.avail_in),SEEK_CUR);
             if (offset < 0)
               {
                 quantum_info=DestroyQuantumInfo(quantum_info);
                 compress_pixels=(unsigned char *) RelinquishMagickMemory(
                   compress_pixels);
                 ThrowReaderException(CorruptImageError,"ImproperImageHeader");
               }
           }
         code=BZ2_bzDecompressEnd(&bzip_info);
         if (code != BZ_OK)
           status=MagickFalse;
         break;
       }
 #endif
 #if defined(MAGICKCORE_LZMA_DELEGATE)
       case LZMACompression:
       {
         int
           code;
 
         code=lzma_code(&lzma_info,LZMA_FINISH);
         if ((code != LZMA_STREAM_END) && (code != LZMA_OK))
           status=MagickFalse;
         lzma_end(&lzma_info);
         break;
       }
 #endif
 #if defined(MAGICKCORE_ZLIB_DELEGATE)
       case LZWCompression:
       case ZipCompression:
       {
         int
           code;
 
         if (version == 0.0)
           {
             MagickOffsetType
               offset;
 
             offset=SeekBlob(image,-((MagickOffsetType) zip_info.avail_in),
               SEEK_CUR);
             if (offset < 0)
               {
                 quantum_info=DestroyQuantumInfo(quantum_info);
                 compress_pixels=(unsigned char *) RelinquishMagickMemory(
                   compress_pixels);
                 ThrowReaderException(CorruptImageError,"ImproperImageHeader");
               }
           }
         code=inflateEnd(&zip_info);
         if (code != LZMA_OK)
           status=MagickFalse;
         break;
       }
 #endif
       default:
         break;
     }
     quantum_info=DestroyQuantumInfo(quantum_info);
     compress_pixels=(unsigned char *) RelinquishMagickMemory(compress_pixels);
     if (((y != (ssize_t) image->rows)) || (status == MagickFalse))
       {
         image=DestroyImageList(image);
         return((Image *) NULL);
       }
     if (EOFBlob(image) != MagickFalse)
       {
         ThrowFileException(exception,CorruptImageError,"UnexpectedEndOfFile",
           image->filename);
         break;
       }
     /*
       Proceed to next image.
     */
     if (image_info->number_scenes != 0)
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     do
     {
       c=ReadBlobByte(image);
     } while ((isgraph(c) == MagickFalse) && (c != EOF));
     if (c != EOF)
       {
         /*
           Allocate next image structure.
         */
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
             image=DestroyImageList(image);
             return((Image *) NULL);
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
           GetBlobSize(image));
         if (status == MagickFalse)
           break;
       }
   } while (c != EOF);
   (void) CloseBlob(image);
   return(GetFirstImageInList(image));
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   R e g i s t e r M I F F I m a g e                                         %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  RegisterMIFFImage() adds properties for the MIFF image format to the list of
 %  supported formats.  The properties include the image format tag, a method to
 %  read and/or write the format, whether the format supports the saving of more
 %  than one frame to the same file or blob, whether the format supports native
 %  in-memory I/O, and a brief description of the format.
 %
 %  The format of the RegisterMIFFImage method is:
 %
 %      size_t RegisterMIFFImage(void)
 %
 */
diff --git a/configure b/configure
index f9001bb37..20165c688 100755
--- a/configure
+++ b/configure
@@ -4550,7 +4550,7 @@ MAGICK_PATCHLEVEL_VERSION=26
 
 MAGICK_VERSION=7.0.7-26
 
-MAGICK_GIT_REVISION=23183:ce433f804:20180304
+MAGICK_GIT_REVISION=23204:cd80f0cb4:20180304
 
 
 # Substitute library versioning
