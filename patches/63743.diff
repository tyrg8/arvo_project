commit ce53bc020d37e10a06a59501c45f1ab82539f0c5
Author: jhendersonHDF <jhenderson@hdfgroup.org>
Date:   Sun Mar 31 22:44:18 2024 -0500

    Fixes for file format security issues (#4283)

diff --git a/src/H5Dchunk.c b/src/H5Dchunk.c
index 310f774e8d..4727cc5d12 100644
--- a/src/H5Dchunk.c
+++ b/src/H5Dchunk.c
@@ -7028,38 +7028,35 @@ H5D__chunk_copy(H5F_t *f_src, H5O_storage_chunk_t *storage_src, H5O_layout_chunk
     bkg = udata.bkg;
 
 done:
-    /* Caller expects that source datatype will be freed */
-    if (dt_src && (H5T_close(dt_src) < 0))
-        HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary datatype");
     if (dt_dst && (H5T_close(dt_dst) < 0))
         HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary datatype");
     if (dt_mem && (H5T_close(dt_mem) < 0))
         HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary datatype");
     if (buf_space && H5S_close(buf_space) < 0)
         HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary dataspace");
     if (buf)
         H5MM_xfree(buf);
     if (bkg)
         H5MM_xfree(bkg);
     if (reclaim_buf)
         H5MM_xfree(reclaim_buf);
 
     /* Clean up any index information */
     if (copy_setup_done)
         if (storage_src->ops->copy_shutdown &&
             (storage_src->ops->copy_shutdown)(storage_src, storage_dst) < 0)
             HDONE_ERROR(H5E_DATASET, H5E_CANTRELEASE, FAIL, "unable to shut down index copying info");
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__chunk_copy() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5D__chunk_bh_info
  *
  * Purpose:     Retrieve the amount of index storage for chunked dataset
  *
  * Return:      Success:        Non-negative
  *              Failure:        negative
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Dcompact.c b/src/H5Dcompact.c
index 864d4963a6..de84034f63 100644
--- a/src/H5Dcompact.c
+++ b/src/H5Dcompact.c
@@ -58,6 +58,7 @@ typedef struct H5D_compact_iovv_memmanage_ud_t {
 
 /* Layout operation callbacks */
 static herr_t  H5D__compact_construct(H5F_t *f, H5D_t *dset);
+static herr_t  H5D__compact_init(H5F_t *f, const H5D_t *dset, hid_t dapl_id);
 static bool    H5D__compact_is_space_alloc(const H5O_storage_t *storage);
 static herr_t  H5D__compact_io_init(H5D_io_info_t *io_info, H5D_dset_io_info_t *dinfo);
 static herr_t  H5D__compact_iovv_memmanage_cb(hsize_t dst_off, hsize_t src_off, size_t len, void *_udata);
@@ -79,22 +80,22 @@ static herr_t  H5D__compact_dest(H5D_t *dset);
 /* Compact storage layout I/O ops */
 const H5D_layout_ops_t H5D_LOPS_COMPACT[1] = {{
     H5D__compact_construct,      /* construct */
-    NULL,                        /* init */
+    H5D__compact_init,           /* init */
     H5D__compact_is_space_alloc, /* is_space_alloc */
     NULL,                        /* is_data_cached */
     H5D__compact_io_init,        /* io_init */
     NULL,                        /* mdio_init */
     H5D__contig_read,            /* ser_read */
     H5D__contig_write,           /* ser_write */
     H5D__compact_readvv,         /* readvv */
     H5D__compact_writevv,        /* writevv */
     H5D__compact_flush,          /* flush */
     NULL,                        /* io_term */
     H5D__compact_dest            /* dest */
 }};
 
 /*******************/
 /* Local Variables */
 /*******************/
 
 /* Declare extern the free list to manage blocks of type conversion data */
@@ -197,13 +198,70 @@ H5D__compact_construct(H5F_t *f, H5D_t *dset)
 done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__compact_construct() */
 
+/*-------------------------------------------------------------------------
+ * Function:	H5D__compact_init
+ *
+ * Purpose:	Initialize the info for a compact dataset.  This is
+ *		called when the dataset is initialized.
+ *
+ * Return:	Non-negative on success/Negative on failure
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+H5D__compact_init(H5F_t H5_ATTR_UNUSED *f, const H5D_t *dset, hid_t H5_ATTR_UNUSED dapl_id)
+{
+    hssize_t snelmts;             /* Temporary holder for number of elements in dataspace */
+    hsize_t  nelmts;              /* Number of elements in dataspace */
+    size_t   dt_size;             /* Size of datatype */
+    hsize_t  data_size;           /* Dataset size, in bytes */
+    herr_t   ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* Sanity check */
+    assert(dset);
+    assert(H5D_COMPACT == dset->shared->layout.storage.type);
+
+    /*
+     * Now that we've read the dataset's datatype, dataspace and
+     * layout information, perform a quick check for compact datasets
+     * to ensure that the size of the internal buffer that was
+     * allocated for the dataset's raw data matches the size of
+     * the data. A corrupted file can cause a mismatch between the
+     * two, which might result in buffer overflows during future
+     * I/O to the dataset.
+     */
+    if (0 == (dt_size = H5T_GET_SIZE(dset->shared->type)))
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get datatype size");
+    if ((snelmts = H5S_GET_EXTENT_NPOINTS(dset->shared->space)) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get number of elements in dataset's dataspace");
+    nelmts = (hsize_t)snelmts;
+
+    /* Compute the size of the dataset's contiguous storage */
+    data_size = nelmts * dt_size;
+
+    /* Check for overflow during multiplication */
+    if (nelmts != (data_size / dt_size))
+        HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "size of dataset's storage overflowed");
+
+    /* Check for mismatch */
+    if (dset->shared->layout.storage.u.compact.size != data_size)
+        HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL,
+                    "bad value from dataset header - size of compact dataset's data buffer doesn't match "
+                    "size of dataset data");
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5D__compact_init() */
+
 /*-------------------------------------------------------------------------
  * Function:	H5D__compact_is_space_alloc
  *
  * Purpose:	Query if space is allocated for layout
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
@@ -606,21 +664,18 @@ H5D__compact_copy(H5F_t *f_src, H5O_storage_compact_t *_storage_src, H5F_t *f_ds
     storage_dst->dirty = true;
 
 done:
-    /* Caller expects that source datatype will be freed */
-    if (dt_src && (H5T_close(dt_src) < 0))
-        HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary datatype");
     if (dt_dst && (H5T_close(dt_dst) < 0))
         HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary datatype");
     if (dt_mem && (H5T_close(dt_mem) < 0))
         HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary datatype");
     if (buf_space && H5S_close(buf_space) < 0)
         HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary dataspace");
     if (buf)
         buf = H5FL_BLK_FREE(type_conv, buf);
     if (reclaim_buf)
         reclaim_buf = H5FL_BLK_FREE(type_conv, reclaim_buf);
     if (bkg)
         bkg = H5FL_BLK_FREE(type_conv, bkg);
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__compact_copy() */
diff --git a/src/H5Dcontig.c b/src/H5Dcontig.c
index d9137b9479..11b0a8e4ef 100644
--- a/src/H5Dcontig.c
+++ b/src/H5Dcontig.c
@@ -355,13 +355,72 @@ H5D__contig_delete(H5F_t *f, const H5O_storage_t *storage)
 done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__contig_delete */
 
+/*-------------------------------------------------------------------------
+ * Function:	H5D__contig_check
+ *
+ * Purpose:	Sanity check the contiguous info for a dataset.
+ *
+ * Return:	Non-negative on success/Negative on failure
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5D__contig_check(const H5F_t *f, const H5O_layout_t *layout, const H5S_extent_t *extent, const H5T_t *dt)
+{
+    hsize_t nelmts;              /* Number of elements in dataspace */
+    size_t  dt_size;             /* Size of datatype */
+    hsize_t data_size;           /* Raw data size */
+    herr_t  ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* Sanity check */
+    assert(f);
+    assert(layout);
+    assert(extent);
+    assert(dt);
+
+    /* Retrieve the number of elements in the dataspace */
+    nelmts = H5S_extent_nelem(extent);
+
+    /* Get the datatype's size */
+    if (0 == (dt_size = H5T_GET_SIZE(dt)))
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve size of datatype");
+
+    /* Compute the size of the dataset's contiguous storage */
+    data_size = nelmts * dt_size;
+
+    /* Check for overflow during multiplication */
+    if (nelmts != (data_size / dt_size))
+        HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "size of dataset's storage overflowed");
+
+    /* Check for invalid (corrupted in the file, probably) dimensions */
+    if (H5_addr_defined(layout->storage.u.contig.addr)) {
+        haddr_t rel_eoa; /* Relative end of file address	*/
+
+        if (HADDR_UNDEF == (rel_eoa = H5F_get_eoa(f, H5FD_MEM_DRAW)))
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to determine file size");
+
+        /* Check for invalid dataset size (from bad dimensions) putting the
+         * dataset elements off the end of the file
+         */
+        if (H5_addr_le((layout->storage.u.contig.addr + data_size), layout->storage.u.contig.addr))
+            HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "invalid dataset size, likely file corruption");
+        if (H5_addr_gt((layout->storage.u.contig.addr + data_size), rel_eoa))
+            HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "invalid dataset size, likely file corruption");
+    }
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5D__contig_check() */
+
 /*-------------------------------------------------------------------------
  * Function:	H5D__contig_construct
  *
  * Purpose:	Constructs new contiguous layout information for dataset
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
@@ -438,56 +497,51 @@ done:
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5D__contig_init(H5F_t H5_ATTR_UNUSED *f, const H5D_t *dset, hid_t H5_ATTR_UNUSED dapl_id)
+H5D__contig_init(H5F_t *f, const H5D_t *dset, hid_t H5_ATTR_UNUSED dapl_id)
 {
-    hsize_t tmp_size;            /* Temporary holder for raw data size */
-    size_t  tmp_sieve_buf_size;  /* Temporary holder for sieve buffer size */
-    herr_t  ret_value = SUCCEED; /* Return value */
+    size_t tmp_sieve_buf_size;  /* Temporary holder for sieve buffer size */
+    herr_t ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Sanity check */
     assert(f);
     assert(dset);
 
+    /* Sanity check the dataset's info */
+    if (H5D__contig_check(f, &dset->shared->layout, H5S_GET_EXTENT(dset->shared->space), dset->shared->type) <
+        0)
+        HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL, "invalid dataset info");
+
     /* Compute the size of the contiguous storage for versions of the
      * layout message less than version 3 because versions 1 & 2 would
      * truncate the dimension sizes to 32-bits of information. - QAK 5/26/04
      */
     if (dset->shared->layout.version < 3) {
         hssize_t snelmts; /* Temporary holder for number of elements in dataspace */
         hsize_t  nelmts;  /* Number of elements in dataspace */
         size_t   dt_size; /* Size of datatype */
 
         /* Retrieve the number of elements in the dataspace */
         if ((snelmts = H5S_GET_EXTENT_NPOINTS(dset->shared->space)) < 0)
             HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve number of elements in dataspace");
         nelmts = (hsize_t)snelmts;
 
         /* Get the datatype's size */
         if (0 == (dt_size = H5T_GET_SIZE(dset->shared->type)))
             HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve size of datatype");
 
         /* Compute the size of the dataset's contiguous storage */
-        tmp_size = nelmts * dt_size;
-
-        /* Check for overflow during multiplication */
-        if (nelmts != (tmp_size / dt_size))
-            HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "size of dataset's storage overflowed");
-
-        /* Assign the dataset's contiguous storage size */
-        dset->shared->layout.storage.u.contig.size = tmp_size;
-    } /* end if */
-    else
-        tmp_size = dset->shared->layout.storage.u.contig.size;
+        dset->shared->layout.storage.u.contig.size = nelmts * dt_size;
+    }
 
     /* Get the sieve buffer size for the file */
     tmp_sieve_buf_size = H5F_SIEVE_BUF_SIZE(dset->oloc.file);
 
     /* Adjust the sieve buffer size to the smaller one between the dataset size and the buffer size
      * from the file access property.  (SLU - 2012/3/30) */
-    if (tmp_size < tmp_sieve_buf_size)
-        dset->shared->cache.contig.sieve_buf_size = tmp_size;
+    if (dset->shared->layout.storage.u.contig.size < tmp_sieve_buf_size)
+        dset->shared->cache.contig.sieve_buf_size = dset->shared->layout.storage.u.contig.size;
     else
         dset->shared->cache.contig.sieve_buf_size = tmp_sieve_buf_size;
 
@@ -1810,21 +1864,18 @@ H5D__contig_copy(H5F_t *f_src, const H5O_storage_contig_t *storage_src, H5F_t *f
     } /* end while */
 
 done:
-    /* Caller expects that source datatype will be freed */
-    if (dt_src && (H5T_close(dt_src) < 0))
-        HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary datatype");
     if (dt_dst && (H5T_close(dt_dst) < 0))
         HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary datatype");
     if (dt_mem && (H5T_close(dt_mem) < 0))
         HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary datatype");
     if (buf_space && H5S_close(buf_space) < 0)
         HDONE_ERROR(H5E_DATASET, H5E_CANTCLOSEOBJ, FAIL, "can't close temporary dataspace");
     if (buf)
         buf = H5FL_BLK_FREE(type_conv, buf);
     if (reclaim_buf)
         reclaim_buf = H5FL_BLK_FREE(type_conv, reclaim_buf);
     if (bkg)
         bkg = H5FL_BLK_FREE(type_conv, bkg);
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__contig_copy() */
diff --git a/src/H5Defl.c b/src/H5Defl.c
index 05ca107fae..22348e33fc 100644
--- a/src/H5Defl.c
+++ b/src/H5Defl.c
@@ -55,6 +55,7 @@ typedef struct H5D_efl_writevv_ud_t {
 
 /* Layout operation callbacks */
 static herr_t  H5D__efl_construct(H5F_t *f, H5D_t *dset);
+static herr_t  H5D__efl_init(H5F_t *f, const H5D_t *dset, hid_t dapl_id);
 static herr_t  H5D__efl_io_init(H5D_io_info_t *io_info, H5D_dset_io_info_t *dinfo);
 static ssize_t H5D__efl_readvv(const H5D_io_info_t *io_info, const H5D_dset_io_info_t *dset_info,
                                size_t dset_max_nseq, size_t *dset_curr_seq, size_t dset_len_arr[],
@@ -77,30 +78,30 @@ static herr_t H5D__efl_write(const H5O_efl_t *efl, const H5D_t *dset, haddr_t ad
 /* External File List (EFL) storage layout I/O ops */
 const H5D_layout_ops_t H5D_LOPS_EFL[1] = {{
     H5D__efl_construct,      /* construct */
-    NULL,                    /* init */
+    H5D__efl_init,           /* init */
     H5D__efl_is_space_alloc, /* is_space_alloc */
     NULL,                    /* is_data_cached */
     H5D__efl_io_init,        /* io_init */
     NULL,                    /* mdio_init */
     H5D__contig_read,        /* ser_read */
     H5D__contig_write,       /* ser_write */
     H5D__efl_readvv,         /* readvv */
     H5D__efl_writevv,        /* writevv */
     NULL,                    /* flush */
     NULL,                    /* io_term */
     NULL                     /* dest */
 }};
 
 /*******************/
 /* Local Variables */
 /*******************/
 
 /*-------------------------------------------------------------------------
  * Function:	H5D__efl_construct
  *
  * Purpose:	Constructs new EFL layout information for dataset
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
@@ -108,51 +109,52 @@ static herr_t
 H5D__efl_construct(H5F_t *f, H5D_t *dset)
 {
     size_t   dt_size;             /* Size of datatype */
     hssize_t stmp_size;           /* Temporary holder for raw data size */
     hsize_t  tmp_size;            /* Temporary holder for raw data size */
     hsize_t  max_points;          /* Maximum elements */
     hsize_t  max_storage;         /* Maximum storage size */
     unsigned u;                   /* Local index variable */
     herr_t   ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Sanity checks */
     assert(f);
     assert(dset);
 
     /*
      * The maximum size of the dataset cannot exceed the storage size.
      * Also, only the slowest varying dimension of a simple dataspace
      * can be extendible (currently only for external data storage).
      */
 
     /* Check for invalid dataset dimensions */
     for (u = 1; u < dset->shared->ndims; u++)
         if (dset->shared->max_dims[u] > dset->shared->curr_dims[u])
             HGOTO_ERROR(H5E_DATASET, H5E_UNSUPPORTED, FAIL, "only the first dimension can be extendible");
 
     /* Retrieve the size of the dataset's datatype */
     if (0 == (dt_size = H5T_get_size(dset->shared->type)))
         HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unable to determine datatype size");
 
     /* Check for storage overflows */
-    max_points  = H5S_get_npoints_max(dset->shared->space);
-    max_storage = H5O_efl_total_size(&dset->shared->dcpl_cache.efl);
+    max_points = H5S_get_npoints_max(dset->shared->space);
+    if (H5O_efl_total_size(&dset->shared->dcpl_cache.efl, &max_storage) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve size of external file");
     if (H5S_UNLIMITED == max_points) {
         if (H5O_EFL_UNLIMITED != max_storage)
             HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unlimited dataspace but finite storage");
     } /* end if */
     else if ((max_points * dt_size) < max_points)
         HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "dataspace * type size overflowed");
     else if ((max_points * dt_size) > max_storage)
         HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "dataspace size exceeds external storage size");
 
     /* Compute the total size of dataset */
-    stmp_size = H5S_GET_EXTENT_NPOINTS(dset->shared->space);
-    assert(stmp_size >= 0);
+    if ((stmp_size = H5S_GET_EXTENT_NPOINTS(dset->shared->space)) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve number of elements in dataspace");
     tmp_size = (hsize_t)stmp_size * dt_size;
     H5_CHECKED_ASSIGN(dset->shared->layout.storage.u.contig.size, hsize_t, tmp_size, hssize_t);
 
     /* Get the sieve buffer size for this dataset */
     dset->shared->cache.contig.sieve_buf_size = H5F_SIEVE_BUF_SIZE(f);
@@ -160,13 +162,64 @@ H5D__efl_construct(H5F_t *f, H5D_t *dset)
 done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5D__efl_construct() */
 
+/*-------------------------------------------------------------------------
+ * Function:	H5D__efl_init
+ *
+ * Purpose:	Initialize the info for a EFL dataset.  This is
+ *		called when the dataset is initialized.
+ *
+ * Return:	Non-negative on success/Negative on failure
+ *
+ *-------------------------------------------------------------------------
+ */
+static herr_t
+H5D__efl_init(H5F_t H5_ATTR_UNUSED *f, const H5D_t *dset, hid_t H5_ATTR_UNUSED dapl_id)
+{
+    size_t   dt_size;             /* Size of datatype */
+    hssize_t snelmts;             /* Temporary holder for number of elements in dataspace */
+    hsize_t  nelmts;              /* Number of elements in dataspace */
+    hsize_t  data_size;           /* Raw data size */
+    hsize_t  max_storage;         /* Maximum storage size */
+    herr_t   ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* Sanity check */
+    assert(dset);
+
+    /* Retrieve the size of the dataset's datatype */
+    if (0 == (dt_size = H5T_get_size(dset->shared->type)))
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unable to determine datatype size");
+
+    /* Retrieve the number of elements in the dataspace */
+    if ((snelmts = H5S_GET_EXTENT_NPOINTS(dset->shared->space)) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve number of elements in dataspace");
+    nelmts = (hsize_t)snelmts;
+
+    /* Compute the size of the dataset's contiguous storage */
+    data_size = nelmts * dt_size;
+
+    /* Check for overflow during multiplication */
+    if (nelmts != (data_size / dt_size))
+        HGOTO_ERROR(H5E_DATASET, H5E_OVERFLOW, FAIL, "size of dataset's storage overflowed");
+
+    /* Check for storage overflows */
+    if (H5O_efl_total_size(&dset->shared->dcpl_cache.efl, &max_storage) < 0)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "unable to retrieve size of external file");
+    if (H5O_EFL_UNLIMITED != max_storage && data_size > max_storage)
+        HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "dataspace size exceeds external storage size");
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5D__efl_init() */
+
 /*-------------------------------------------------------------------------
  * Function:	H5D__efl_is_space_alloc
  *
  * Purpose:	Query if space is allocated for layout
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Dint.c b/src/H5Dint.c
index 3b9d000f52..71ddda387c 100644
--- a/src/H5Dint.c
+++ b/src/H5Dint.c
@@ -1673,169 +1673,175 @@ static herr_t
 H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
 {
     H5P_genplist_t *plist;                     /* Property list */
-    H5O_fill_t     *fill_prop;                 /* Pointer to dataset's fill value info */
+    H5O_fill_t     *fill_prop = NULL;          /* Pointer to dataset's fill value info */
     unsigned        alloc_time_state;          /* Allocation time state */
     htri_t          msg_exists;                /* Whether a particular type of message exists */
     bool            layout_init       = false; /* Flag to indicate that chunk information was initialized */
     bool            must_init_storage = false;
+    bool            fill_init         = false;   /* Flag to indicate that fill information was initialized */
     herr_t          ret_value         = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE_TAG(dataset->oloc.addr)
 
     /* check args */
     assert(dataset);
 
     /* (Set the 'vl_type' parameter to false since it doesn't matter from here) */
     if (NULL == (dataset->shared = H5D__new(H5P_DATASET_CREATE_DEFAULT, dapl_id, false, false)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
 
     /* Open the dataset object */
     if (H5O_open(&(dataset->oloc)) < 0)
         HGOTO_ERROR(H5E_DATASET, H5E_CANTOPENOBJ, FAIL, "unable to open");
 
     /* Get the type and space */
     if (NULL == (dataset->shared->type = (H5T_t *)H5O_msg_read(&(dataset->oloc), H5O_DTYPE_ID, NULL)))
         HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unable to load type info from dataset header");
 
     if (H5T_set_loc(dataset->shared->type, H5F_VOL_OBJ(dataset->oloc.file), H5T_LOC_DISK) < 0)
         HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "invalid datatype location");
 
     if (NULL == (dataset->shared->space = H5S_read(&(dataset->oloc))))
         HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unable to load dataspace info from dataset header");
 
     /* Cache the dataset's dataspace info */
     if (H5D__cache_dataspace_info(dataset) < 0)
         HGOTO_ERROR(H5E_DATASET, H5E_CANTCOPY, FAIL, "can't cache dataspace info");
 
     /* Get a datatype ID for the dataset's datatype */
     if ((dataset->shared->type_id = H5I_register(H5I_DATATYPE, dataset->shared->type, false)) < 0)
         HGOTO_ERROR(H5E_DATASET, H5E_CANTREGISTER, FAIL, "unable to register type");
 
     /* Get dataset creation property list object */
     if (NULL == (plist = (H5P_genplist_t *)H5I_object(dataset->shared->dcpl_id)))
         HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "can't get dataset creation property list");
 
     /* Get the layout/pline/efl message information */
     if (H5D__layout_oh_read(dataset, dapl_id, plist) < 0)
         HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't get layout/pline/efl info");
 
     /* Indicate that the layout information was initialized */
     layout_init = true;
 
-    /*
-     * Now that we've read the dataset's datatype, dataspace and
-     * layout information, perform a quick check for compact datasets
-     * to ensure that the size of the internal buffer that was
-     * allocated for the dataset's raw data matches the size of
-     * the data. A corrupted file can cause a mismatch between the
-     * two, which might result in buffer overflows during future
-     * I/O to the dataset.
-     */
-    if (H5D_COMPACT == dataset->shared->layout.type) {
-        hssize_t dset_nelemts   = 0;
-        size_t   dset_type_size = H5T_GET_SIZE(dataset->shared->type);
-        size_t   dset_data_size = 0;
-
-        assert(H5D_COMPACT == dataset->shared->layout.storage.type);
-
-        if ((dset_nelemts = H5S_GET_EXTENT_NPOINTS(dataset->shared->space)) < 0)
-            HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL,
-                        "can't get number of elements in dataset's dataspace");
-
-        dset_data_size = (size_t)dset_nelemts * dset_type_size;
-
-        if (dataset->shared->layout.storage.u.compact.size != dset_data_size)
-            HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL,
-                        "bad value from dataset header - size of compact dataset's data buffer doesn't match "
-                        "size of dataset data");
-    }
-
     /* Set up flush append property */
     if (H5D__append_flush_setup(dataset, dapl_id))
         HGOTO_ERROR(H5E_DATASET, H5E_CANTSET, FAIL, "unable to set up flush append property");
 
     /* Point at dataset's copy, to cache it for later */
     fill_prop = &dataset->shared->dcpl_cache.fill;
 
     /* Try to get the new fill value message from the object header */
     if ((msg_exists = H5O_msg_exists(&(dataset->oloc), H5O_FILL_NEW_ID)) < 0)
         HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't check if message exists");
     if (msg_exists) {
         if (NULL == H5O_msg_read(&(dataset->oloc), H5O_FILL_NEW_ID, fill_prop))
             HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't retrieve message");
+
+        /* Indicate that the fill information was initialized */
+        fill_init = true;
     } /* end if */
     else {
         /* For backward compatibility, try to retrieve the old fill value message */
         if ((msg_exists = H5O_msg_exists(&(dataset->oloc), H5O_FILL_ID)) < 0)
             HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't check if message exists");
         if (msg_exists) {
             if (NULL == H5O_msg_read(&(dataset->oloc), H5O_FILL_ID, fill_prop))
                 HGOTO_ERROR(H5E_DATASET, H5E_CANTGET, FAIL, "can't retrieve message");
+
+            /* Indicate that the fill information was initialized */
+            fill_init = true;
         } /* end if */
         else {
             /* Set the space allocation time appropriately, based on the type of dataset storage */
             switch (dataset->shared->layout.type) {
                 case H5D_COMPACT:
                     fill_prop->alloc_time = H5D_ALLOC_TIME_EARLY;
                     break;
 
                 case H5D_CONTIGUOUS:
                     fill_prop->alloc_time = H5D_ALLOC_TIME_LATE;
                     break;
 
                 case H5D_CHUNKED:
                     fill_prop->alloc_time = H5D_ALLOC_TIME_INCR;
                     break;
 
                 case H5D_VIRTUAL:
                     fill_prop->alloc_time = H5D_ALLOC_TIME_INCR;
                     break;
 
                 case H5D_LAYOUT_ERROR:
                 case H5D_NLAYOUTS:
                 default:
                     HGOTO_ERROR(H5E_DATASET, H5E_UNSUPPORTED, FAIL, "not implemented yet");
             } /* end switch */
         }     /* end else */
 
         /* If "old" fill value size is 0 (undefined), map it to -1 */
         if (fill_prop->size == 0)
             fill_prop->size = (ssize_t)-1;
     } /* end if */
     alloc_time_state = 0;
     if ((dataset->shared->layout.type == H5D_COMPACT && fill_prop->alloc_time == H5D_ALLOC_TIME_EARLY) ||
         (dataset->shared->layout.type == H5D_CONTIGUOUS && fill_prop->alloc_time == H5D_ALLOC_TIME_LATE) ||
         (dataset->shared->layout.type == H5D_CHUNKED && fill_prop->alloc_time == H5D_ALLOC_TIME_INCR) ||
         (dataset->shared->layout.type == H5D_VIRTUAL && fill_prop->alloc_time == H5D_ALLOC_TIME_INCR))
         alloc_time_state = 1;
 
+    /* Check if there is a fill value, but no type yet */
+    if (fill_prop->buf != NULL && fill_prop->type == NULL) {
+        H5T_t *tmp_type; /* Temporary pointer to dataset's datatype */
+
+        /* Copy the dataset type into the fill value message */
+        if (NULL == (tmp_type = H5T_copy(dataset->shared->type, H5T_COPY_TRANSIENT)))
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTCOPY, FAIL, "unable to copy dataset datatype for fill value");
+
+        /* Check if conversion is necessary on fill buffer, and if fill-value
+         * buffer is too small to hold the result.
+         */
+        if (!H5T_noop_conv(dataset->shared->type, tmp_type)) {
+            size_t bkg_size = MAX(H5T_GET_SIZE(tmp_type), H5T_GET_SIZE(dataset->shared->type));
+
+            assert(fill_prop->size >= 0);
+            if ((size_t)fill_prop->size < bkg_size) {
+                if (H5T_close_real(tmp_type) < 0)
+                    HDONE_ERROR(H5E_DATASET, H5E_CANTFREE, FAIL, "Can't free temporary datatype");
+                HGOTO_ERROR(H5E_DATASET, H5E_BADVALUE, FAIL,
+                            "fill value size doesn't match dataset's datatype size");
+            }
+        }
+
+        if (H5T_close_real(tmp_type) < 0)
+            HGOTO_ERROR(H5E_DATASET, H5E_CANTFREE, FAIL, "Can't free temporary datatype");
+    }
+
     /* Set revised fill value properties, if they are different from the defaults */
     if (H5P_fill_value_cmp(&H5D_def_dset.dcpl_cache.fill, fill_prop, sizeof(H5O_fill_t))) {
         if (H5P_set(plist, H5D_CRT_FILL_VALUE_NAME, fill_prop) < 0)
             HGOTO_ERROR(H5E_DATASET, H5E_CANTSET, FAIL, "can't set fill value");
         if (H5P_set(plist, H5D_CRT_ALLOC_TIME_STATE_NAME, &alloc_time_state) < 0)
             HGOTO_ERROR(H5E_DATASET, H5E_CANTSET, FAIL, "can't set allocation time state");
     } /* end if */
 
     /*
      * Make sure all storage is properly initialized.
      * This is important only for parallel I/O where the space must
      * be fully allocated before I/O can happen.
      *
      * Storage will be initialized here if either the VFD being used
      * has set the H5FD_FEAT_ALLOCATE_EARLY flag to indicate that it
      * wishes to force early space allocation OR a parallel VFD is
      * being used and the dataset in question doesn't have any filters
      * applied to it. If filters are applied to the dataset, collective
      * I/O will be required when writing to the dataset, so we don't
      * need to initialize storage here, as the collective I/O process
      * will coordinate that.
      */
     must_init_storage = (H5F_INTENT(dataset->oloc.file) & H5F_ACC_RDWR) &&
                         !(*dataset->shared->layout.ops->is_space_alloc)(&dataset->shared->layout.storage);
     must_init_storage = must_init_storage && (H5F_HAS_FEATURE(dataset->oloc.file, H5FD_FEAT_ALLOCATE_EARLY) ||
                                               (H5F_HAS_FEATURE(dataset->oloc.file, H5FD_FEAT_HAS_MPI) &&
                                                dataset->shared->dcpl_cache.pline.nused == 0));
 
     if (must_init_storage && (H5D__alloc_storage(dataset, H5D_ALLOC_OPEN, false, NULL) < 0))
         HGOTO_ERROR(H5E_DATASET, H5E_CANTINIT, FAIL, "unable to initialize file storage");
@@ -1843,36 +1849,38 @@ H5D__open_oid(H5D_t *dataset, hid_t dapl_id)
 done:
     if (ret_value < 0) {
         if (H5_addr_defined(dataset->oloc.addr) && H5O_close(&(dataset->oloc), NULL) < 0)
             HDONE_ERROR(H5E_DATASET, H5E_CLOSEERROR, FAIL, "unable to release object header");
         if (dataset->shared) {
+            if (fill_init)
+                H5O_msg_reset(H5O_FILL_ID, fill_prop);
             if (layout_init)
                 if (dataset->shared->layout.ops->dest && (dataset->shared->layout.ops->dest)(dataset) < 0)
                     HDONE_ERROR(H5E_DATASET, H5E_CANTRELEASE, FAIL, "unable to destroy layout info");
             if (dataset->shared->space && H5S_close(dataset->shared->space) < 0)
                 HDONE_ERROR(H5E_DATASET, H5E_CLOSEERROR, FAIL, "unable to release dataspace");
             if (dataset->shared->type) {
                 if (dataset->shared->type_id > 0) {
                     if (H5I_dec_ref(dataset->shared->type_id) < 0)
                         HDONE_ERROR(H5E_DATASET, H5E_CLOSEERROR, FAIL, "unable to release datatype");
                 } /* end if */
                 else {
                     if (H5T_close_real(dataset->shared->type) < 0)
                         HDONE_ERROR(H5E_DATASET, H5E_CLOSEERROR, FAIL, "unable to release datatype");
                 } /* end else */
             }     /* end if */
         }         /* end if */
     }             /* end if */
 
     FUNC_LEAVE_NOAPI_TAG(ret_value)
 } /* end H5D__open_oid() */
 
 /*-------------------------------------------------------------------------
  * Function: H5D_close
  *
  * Purpose:  Insures that all data has been saved to the file, closes the
  *           dataset object header, and frees all resources used by the
  *           descriptor.
  *
  * Return:   Non-negative on success/Negative on failure
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Dpkg.h b/src/H5Dpkg.h
index 5a0b586594..4214341b43 100644
--- a/src/H5Dpkg.h
+++ b/src/H5Dpkg.h
@@ -712,6 +712,8 @@ H5_DLL herr_t H5D__contig_write(H5D_io_info_t *io_info, H5D_dset_io_info_t *dinf
 H5_DLL herr_t H5D__contig_copy(H5F_t *f_src, const H5O_storage_contig_t *storage_src, H5F_t *f_dst,
                                H5O_storage_contig_t *storage_dst, H5T_t *src_dtype, H5O_copy_t *cpy_info);
 H5_DLL herr_t H5D__contig_delete(H5F_t *f, const H5O_storage_t *store);
+H5_DLL herr_t H5D__contig_check(const H5F_t *f, const H5O_layout_t *layout, const H5S_extent_t *extent,
+                                const H5T_t *dt);
 
 /* Functions that operate on chunked dataset storage */
 H5_DLL htri_t H5D__chunk_cacheable(const H5D_io_info_t *io_info, H5D_dset_io_info_t *dset_info, haddr_t caddr,
diff --git a/src/H5Gent.c b/src/H5Gent.c
index 5b7c064ecf..40872a041c 100644
--- a/src/H5Gent.c
+++ b/src/H5Gent.c
@@ -330,158 +330,96 @@ void
 H5G__ent_reset(H5G_entry_t *ent)
 {
     FUNC_ENTER_PACKAGE_NOERR
 
     /* Check arguments */
     assert(ent);
 
     /* Clear the symbol table entry to an empty state */
     memset(ent, 0, sizeof(H5G_entry_t));
     ent->header = HADDR_UNDEF;
 
     FUNC_LEAVE_NOAPI_VOID
 } /* end H5G__ent_reset() */
 
 /*-------------------------------------------------------------------------
- * Function:    H5G__ent_convert
+ * Function:	H5G__ent_to_link
  *
- * Purpose:     Convert a link to a symbol table entry
+ * Purpose:     Convert a symbol table entry to a link
  *
- * Return:	Success:	Non-negative
- *		Failure:	Negative
+ * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
 herr_t
-H5G__ent_convert(H5F_t *f, H5HL_t *heap, const char *name, const H5O_link_t *lnk, H5O_type_t obj_type,
-                 const void *crt_info, H5G_entry_t *ent)
+H5G__ent_to_link(const H5G_entry_t *ent, const H5HL_t *heap, H5O_link_t *lnk)
 {
-    size_t name_offset;         /* Offset of name in heap */
-    herr_t ret_value = SUCCEED; /* Return value */
+    const char *name;                /* Pointer to link name in heap */
+    size_t      block_size;          /* Size of the heap block */
+    bool        dup_soft  = false;   /* xstrdup the symbolic link name or not */
+    herr_t      ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check arguments */
-    assert(f);
+    assert(ent);
     assert(heap);
-    assert(name);
     assert(lnk);
 
-    /* Reset the new entry */
-    H5G__ent_reset(ent);
-
-    /* Add the new name to the heap */
-    if (H5HL_insert(f, heap, strlen(name) + 1, name, &name_offset) < 0)
-        HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, FAIL, "unable to insert symbol name into heap");
-    ent->name_off = name_offset;
-
-    /* Build correct information for symbol table entry based on link type */
-    switch (lnk->type) {
-        case H5L_TYPE_HARD:
-            if (obj_type == H5O_TYPE_GROUP) {
-                const H5G_obj_create_t *gcrt_info = (const H5G_obj_create_t *)crt_info;
-
-                ent->type = gcrt_info->cache_type;
-                if (ent->type != H5G_NOTHING_CACHED)
-                    ent->cache = gcrt_info->cache;
-#ifndef NDEBUG
-                else {
-                    /* Make sure there is no stab message in the target object
-                     */
-                    H5O_loc_t targ_oloc;   /* Location of link target */
-                    htri_t    stab_exists; /* Whether the target symbol table exists */
-
-                    /* Build target object location */
-                    if (H5O_loc_reset(&targ_oloc) < 0)
-                        HGOTO_ERROR(H5E_SYM, H5E_CANTRESET, FAIL, "unable to initialize target location");
-                    targ_oloc.file = f;
-                    targ_oloc.addr = lnk->u.hard.addr;
-
-                    /* Check if a symbol table message exists */
-                    if ((stab_exists = H5O_msg_exists(&targ_oloc, H5O_STAB_ID)) < 0)
-                        HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, FAIL, "unable to check for STAB message");
-
-                    assert(!stab_exists);
-                } /* end else */
-#endif            /* NDEBUG */
-            }     /* end if */
-            else if (obj_type == H5O_TYPE_UNKNOWN) {
-                /* Try to retrieve symbol table information for caching */
-                H5O_loc_t  targ_oloc;   /* Location of link target */
-                H5O_t     *oh;          /* Link target object header */
-                H5O_stab_t stab;        /* Link target symbol table */
-                htri_t     stab_exists; /* Whether the target symbol table exists */
-
-                /* Build target object location */
-                if (H5O_loc_reset(&targ_oloc) < 0)
-                    HGOTO_ERROR(H5E_SYM, H5E_CANTRESET, FAIL, "unable to initialize target location");
-                targ_oloc.file = f;
-                targ_oloc.addr = lnk->u.hard.addr;
-
-                /* Get the object header */
-                if (NULL == (oh = H5O_protect(&targ_oloc, H5AC__READ_ONLY_FLAG, false)))
-                    HGOTO_ERROR(H5E_SYM, H5E_CANTPROTECT, FAIL, "unable to protect target object header");
-
-                /* Check if a symbol table message exists */
-                if ((stab_exists = H5O_msg_exists_oh(oh, H5O_STAB_ID)) < 0) {
-                    if (H5O_unprotect(&targ_oloc, oh, H5AC__NO_FLAGS_SET) < 0)
-                        HERROR(H5E_SYM, H5E_CANTUNPROTECT, "unable to release object header");
-                    HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, FAIL, "unable to check for STAB message");
-                } /* end if */
-
-                if (stab_exists) {
-                    /* Read symbol table message */
-                    if (NULL == H5O_msg_read_oh(f, oh, H5O_STAB_ID, &stab)) {
-                        if (H5O_unprotect(&targ_oloc, oh, H5AC__NO_FLAGS_SET) < 0)
-                            HERROR(H5E_SYM, H5E_CANTUNPROTECT, "unable to release object header");
-                        HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to read STAB message");
-                    } /* end if */
-
-                    /* Cache symbol table message */
-                    ent->type                  = H5G_CACHED_STAB;
-                    ent->cache.stab.btree_addr = stab.btree_addr;
-                    ent->cache.stab.heap_addr  = stab.heap_addr;
-                } /* end if */
-                else
-                    /* No symbol table message, don't cache anything */
-                    ent->type = H5G_NOTHING_CACHED;
-
-                if (H5O_unprotect(&targ_oloc, oh, H5AC__NO_FLAGS_SET) < 0)
-                    HGOTO_ERROR(H5E_SYM, H5E_CANTUNPROTECT, FAIL, "unable to release object header");
-            } /* end else */
-            else
-                ent->type = H5G_NOTHING_CACHED;
+    /* Get the size of the heap block */
+    block_size = H5HL_heap_get_size(heap);
 
-            ent->header = lnk->u.hard.addr;
-            break;
+    /* Get pointer to link's name in the heap */
+    if (NULL == (name = (const char *)H5HL_offset_into(heap, ent->name_off)))
+        HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get symbol table link name");
 
-        case H5L_TYPE_SOFT: {
-            size_t lnk_offset; /* Offset to sym-link value	*/
+    /* Set (default) common info for link */
+    lnk->cset         = H5F_DEFAULT_CSET;
+    lnk->corder       = 0;
+    lnk->corder_valid = false; /* Creation order not valid for this link */
+    if (NULL == (lnk->name = H5MM_strndup(name, (block_size - ent->name_off))))
+        HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to duplicate link name");
 
-            /* Insert link value into local heap */
-            if (H5HL_insert(f, heap, strlen(lnk->u.soft.name) + 1, lnk->u.soft.name, &lnk_offset) < 0)
-                HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "unable to write link value to local heap");
+    /* Object is a symbolic or hard link */
+    if (ent->type == H5G_CACHED_SLINK) {
+        const char *s; /* Pointer to link value */
 
-            ent->type                    = H5G_CACHED_SLINK;
-            ent->cache.slink.lval_offset = lnk_offset;
-        } break;
+        if (NULL == (s = (const char *)H5HL_offset_into(heap, ent->cache.slink.lval_offset)))
+            HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get symbolic link name");
 
-        case H5L_TYPE_ERROR:
-        case H5L_TYPE_EXTERNAL:
-        case H5L_TYPE_MAX:
-        default:
-            HGOTO_ERROR(H5E_SYM, H5E_BADVALUE, FAIL, "unrecognized link type");
-    } /* end switch */
+        /* Copy the link value */
+        if (NULL == (lnk->u.soft.name = H5MM_strndup(s, (block_size - ent->cache.slink.lval_offset))))
+            HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to duplicate symbolic link name");
+
+        dup_soft = true;
+
+        /* Set link type */
+        lnk->type = H5L_TYPE_SOFT;
+    } /* end if */
+    else {
+        /* Set address of object */
+        lnk->u.hard.addr = ent->header;
+
+        /* Set link type */
+        lnk->type = H5L_TYPE_HARD;
+    } /* end else */
 
 done:
+    if (ret_value < 0) {
+        if (lnk->name)
+            H5MM_xfree(lnk->name);
+        if (ent->type == H5G_CACHED_SLINK && dup_soft)
+            H5MM_xfree(lnk->u.soft.name);
+    }
+
     FUNC_LEAVE_NOAPI(ret_value)
-} /* end H5G__ent_convert() */
+} /* end H5G__ent_to_link() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5G__ent_debug
  *
  * Purpose:     Prints debugging information about a symbol table entry.
  *
  * Return:      Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Glink.c b/src/H5Glink.c
index b862947f19..1982f54984 100644
--- a/src/H5Glink.c
+++ b/src/H5Glink.c
@@ -162,89 +162,25 @@ static int
 H5G__link_cmp_corder_dec(const void *lnk1, const void *lnk2)
 {
     int ret_value = -1; /* Return value */
 
     FUNC_ENTER_PACKAGE_NOERR
 
     if (((const H5O_link_t *)lnk1)->corder < ((const H5O_link_t *)lnk2)->corder)
         ret_value = 1;
     else if (((const H5O_link_t *)lnk1)->corder > ((const H5O_link_t *)lnk2)->corder)
         ret_value = -1;
     else
         ret_value = 0;
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G__link_cmp_corder_dec() */
 
-/*-------------------------------------------------------------------------
- * Function:	H5G__ent_to_link
- *
- * Purpose:     Convert a symbol table entry to a link
- *
- * Return:	Non-negative on success/Negative on failure
- *
- *-------------------------------------------------------------------------
- */
-herr_t
-H5G__ent_to_link(H5O_link_t *lnk, const H5HL_t *heap, const H5G_entry_t *ent, const char *name)
-{
-    bool   dup_soft  = false;   /* xstrdup the symbolic link name or not */
-    herr_t ret_value = SUCCEED; /* Return value */
-
-    FUNC_ENTER_PACKAGE
-
-    /* check arguments */
-    assert(lnk);
-    assert(heap);
-    assert(ent);
-    assert(name);
-
-    /* Set (default) common info for link */
-    lnk->cset         = H5F_DEFAULT_CSET;
-    lnk->corder       = 0;
-    lnk->corder_valid = false; /* Creation order not valid for this link */
-    if ((lnk->name = H5MM_xstrdup(name)) == NULL)
-        HGOTO_ERROR(H5E_LINK, H5E_CANTGET, FAIL, "unable to duplicate link name");
-
-    /* Object is a symbolic or hard link */
-    if (ent->type == H5G_CACHED_SLINK) {
-        const char *s; /* Pointer to link value */
-
-        if ((s = (const char *)H5HL_offset_into(heap, ent->cache.slink.lval_offset)) == NULL)
-            HGOTO_ERROR(H5E_LINK, H5E_CANTGET, FAIL, "unable to get symbolic link name");
-
-        /* Copy the link value */
-        if ((lnk->u.soft.name = H5MM_xstrdup(s)) == NULL)
-            HGOTO_ERROR(H5E_LINK, H5E_CANTGET, FAIL, "unable to duplicate symbolic link name");
-
-        dup_soft = true;
-
-        /* Set link type */
-        lnk->type = H5L_TYPE_SOFT;
-    } /* end if */
-    else {
-        /* Set address of object */
-        lnk->u.hard.addr = ent->header;
-
-        /* Set link type */
-        lnk->type = H5L_TYPE_HARD;
-    } /* end else */
-
-done:
-    if (ret_value < 0) {
-        if (lnk->name)
-            H5MM_xfree(lnk->name);
-        if (ent->type == H5G_CACHED_SLINK && dup_soft)
-            H5MM_xfree(lnk->u.soft.name);
-    }
-    FUNC_LEAVE_NOAPI(ret_value)
-} /* end H5G__ent_to_link() */
-
 /*-------------------------------------------------------------------------
  * Function:	H5G_link_to_info
  *
  * Purpose:	Retrieve information from a link object
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
@@ -316,13 +252,147 @@ H5G_link_to_info(const H5O_loc_t *link_loc, const H5O_link_t *lnk, H5L_info2_t *
 done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G_link_to_info() */
 
+/*-------------------------------------------------------------------------
+ * Function:    H5G__link_to_ent
+ *
+ * Purpose:     Convert a link to a symbol table entry
+ *
+ * Return:	Success:	Non-negative
+ *		Failure:	Negative
+ *
+ *-------------------------------------------------------------------------
+ */
+herr_t
+H5G__link_to_ent(H5F_t *f, H5HL_t *heap, const H5O_link_t *lnk, H5O_type_t obj_type, const void *crt_info,
+                 H5G_entry_t *ent)
+{
+    size_t name_offset;         /* Offset of name in heap */
+    herr_t ret_value = SUCCEED; /* Return value */
+
+    FUNC_ENTER_PACKAGE
+
+    /* check arguments */
+    assert(f);
+    assert(heap);
+    assert(lnk && lnk->name);
+
+    /* Reset the new entry */
+    H5G__ent_reset(ent);
+
+    /* Add the new name to the heap */
+    if (H5HL_insert(f, heap, strlen(lnk->name) + 1, lnk->name, &name_offset) < 0)
+        HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, FAIL, "unable to insert symbol name into heap");
+    ent->name_off = name_offset;
+
+    /* Build correct information for symbol table entry based on link type */
+    switch (lnk->type) {
+        case H5L_TYPE_HARD:
+            if (obj_type == H5O_TYPE_GROUP) {
+                const H5G_obj_create_t *gcrt_info = (const H5G_obj_create_t *)crt_info;
+
+                ent->type = gcrt_info->cache_type;
+                if (ent->type != H5G_NOTHING_CACHED)
+                    ent->cache = gcrt_info->cache;
+#ifndef NDEBUG
+                else {
+                    /* Make sure there is no stab message in the target object
+                     */
+                    H5O_loc_t targ_oloc;   /* Location of link target */
+                    htri_t    stab_exists; /* Whether the target symbol table exists */
+
+                    /* Build target object location */
+                    if (H5O_loc_reset(&targ_oloc) < 0)
+                        HGOTO_ERROR(H5E_SYM, H5E_CANTRESET, FAIL, "unable to initialize target location");
+                    targ_oloc.file = f;
+                    targ_oloc.addr = lnk->u.hard.addr;
+
+                    /* Check if a symbol table message exists */
+                    if ((stab_exists = H5O_msg_exists(&targ_oloc, H5O_STAB_ID)) < 0)
+                        HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, FAIL, "unable to check for STAB message");
+
+                    assert(!stab_exists);
+                } /* end else */
+#endif            /* NDEBUG */
+            }     /* end if */
+            else if (obj_type == H5O_TYPE_UNKNOWN) {
+                /* Try to retrieve symbol table information for caching */
+                H5O_loc_t  targ_oloc;   /* Location of link target */
+                H5O_t     *oh;          /* Link target object header */
+                H5O_stab_t stab;        /* Link target symbol table */
+                htri_t     stab_exists; /* Whether the target symbol table exists */
+
+                /* Build target object location */
+                if (H5O_loc_reset(&targ_oloc) < 0)
+                    HGOTO_ERROR(H5E_SYM, H5E_CANTRESET, FAIL, "unable to initialize target location");
+                targ_oloc.file = f;
+                targ_oloc.addr = lnk->u.hard.addr;
+
+                /* Get the object header */
+                if (NULL == (oh = H5O_protect(&targ_oloc, H5AC__READ_ONLY_FLAG, false)))
+                    HGOTO_ERROR(H5E_SYM, H5E_CANTPROTECT, FAIL, "unable to protect target object header");
+
+                /* Check if a symbol table message exists */
+                if ((stab_exists = H5O_msg_exists_oh(oh, H5O_STAB_ID)) < 0) {
+                    if (H5O_unprotect(&targ_oloc, oh, H5AC__NO_FLAGS_SET) < 0)
+                        HERROR(H5E_SYM, H5E_CANTUNPROTECT, "unable to release object header");
+                    HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, FAIL, "unable to check for STAB message");
+                } /* end if */
+
+                if (stab_exists) {
+                    /* Read symbol table message */
+                    if (NULL == H5O_msg_read_oh(f, oh, H5O_STAB_ID, &stab)) {
+                        if (H5O_unprotect(&targ_oloc, oh, H5AC__NO_FLAGS_SET) < 0)
+                            HERROR(H5E_SYM, H5E_CANTUNPROTECT, "unable to release object header");
+                        HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to read STAB message");
+                    } /* end if */
+
+                    /* Cache symbol table message */
+                    ent->type                  = H5G_CACHED_STAB;
+                    ent->cache.stab.btree_addr = stab.btree_addr;
+                    ent->cache.stab.heap_addr  = stab.heap_addr;
+                } /* end if */
+                else
+                    /* No symbol table message, don't cache anything */
+                    ent->type = H5G_NOTHING_CACHED;
+
+                if (H5O_unprotect(&targ_oloc, oh, H5AC__NO_FLAGS_SET) < 0)
+                    HGOTO_ERROR(H5E_SYM, H5E_CANTUNPROTECT, FAIL, "unable to release object header");
+            } /* end else */
+            else
+                ent->type = H5G_NOTHING_CACHED;
+
+            ent->header = lnk->u.hard.addr;
+            break;
+
+        case H5L_TYPE_SOFT: {
+            size_t lnk_offset; /* Offset to sym-link value	*/
+
+            /* Insert link value into local heap */
+            if (H5HL_insert(f, heap, strlen(lnk->u.soft.name) + 1, lnk->u.soft.name, &lnk_offset) < 0)
+                HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "unable to write link value to local heap");
+
+            ent->type                    = H5G_CACHED_SLINK;
+            ent->cache.slink.lval_offset = lnk_offset;
+        } break;
+
+        case H5L_TYPE_ERROR:
+        case H5L_TYPE_EXTERNAL:
+        case H5L_TYPE_MAX:
+        default:
+            HGOTO_ERROR(H5E_SYM, H5E_BADVALUE, FAIL, "unrecognized link type");
+    } /* end switch */
+
+done:
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5G__link_to_ent() */
+
 /*-------------------------------------------------------------------------
  * Function:	H5G__link_to_loc
  *
  * Purpose:	Build group location from group and link object
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Gloc.c b/src/H5Gloc.c
index 1ba45dee22..d04c582d00 100644
--- a/src/H5Gloc.c
+++ b/src/H5Gloc.c
@@ -535,27 +535,27 @@ herr_t
 H5G__loc_insert(H5G_loc_t *grp_loc, char *name, H5G_loc_t *obj_loc, H5O_type_t obj_type, const void *crt_info)
 {
     H5O_link_t lnk;                 /* Link for object to insert */
     herr_t     ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Check args. */
     assert(grp_loc);
     assert(name && *name);
     assert(obj_loc);
 
     /* Create link object for the object location */
     lnk.type         = H5L_TYPE_HARD;
     lnk.cset         = H5F_DEFAULT_CSET;
     lnk.corder       = 0;     /* Will be reset if the group is tracking creation order */
     lnk.corder_valid = false; /* Indicate that the creation order isn't valid (yet) */
     lnk.name         = name;
     lnk.u.hard.addr  = obj_loc->oloc->addr;
 
     /* Insert new group into current group's symbol table */
-    if (H5G_obj_insert(grp_loc->oloc, name, &lnk, true, obj_type, crt_info) < 0)
+    if (H5G_obj_insert(grp_loc->oloc, &lnk, true, obj_type, crt_info) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, FAIL, "unable to insert object");
 
     /* Set the name of the object location */
     if (H5G_name_set(grp_loc->path, obj_loc->path, name) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "cannot set name");
@@ -643,34 +643,31 @@ static herr_t
 H5G__loc_addr_cb(H5G_loc_t H5_ATTR_UNUSED *grp_loc /*in*/, const char H5_ATTR_UNUSED *name,
                  const H5O_link_t H5_ATTR_UNUSED *lnk, H5G_loc_t *obj_loc, void *_udata /*in,out*/,
                  H5G_own_loc_t *own_loc /*out*/)
 {
-    haddr_t *udata     = (haddr_t *)_udata; /* User data passed in */
-    herr_t   ret_value = SUCCEED;           /* Return value */
+    haddr_t *udata = (haddr_t *)_udata; /* User data passed in */
 
-    FUNC_ENTER_PACKAGE
+    FUNC_ENTER_PACKAGE_NOERR
 
     /* Check if the name in this group resolved to a valid link */
     if (obj_loc == NULL)
-        HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, FAIL, "name doesn't exist");
-
-    /* Set address of object */
-    *udata = obj_loc->oloc->addr;
+        *udata = HADDR_UNDEF; /* No object found */
+    else
+        *udata = obj_loc->oloc->addr; /* Set address of object */
 
-done:
     /* Indicate that this callback didn't take ownership of the group *
      * location for the object */
     *own_loc = H5G_OWN_NONE;
 
-    FUNC_LEAVE_NOAPI(ret_value)
+    FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5G__loc_addr_cb() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5G__loc_addr
  *
  * Purpose:	Retrieve the information for an object from a group location
  *              and path to that object
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Gnode.c b/src/H5Gnode.c
index b4bd1214bf..f211e74e04 100644
--- a/src/H5Gnode.c
+++ b/src/H5Gnode.c
@@ -341,26 +341,33 @@ static herr_t
 H5G__node_cmp2(void *_lt_key, void *_udata, void *_rt_key)
 {
     H5G_bt_common_t *udata  = (H5G_bt_common_t *)_udata;
     H5G_node_key_t  *lt_key = (H5G_node_key_t *)_lt_key;
     H5G_node_key_t  *rt_key = (H5G_node_key_t *)_rt_key;
     const char      *s1, *s2;
+    size_t           max_len;
     int              ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Sanity checks */
     assert(udata && udata->heap);
     assert(lt_key);
     assert(rt_key);
 
     /* Get pointers to string names */
     if ((s1 = (const char *)H5HL_offset_into(udata->heap, lt_key->offset)) == NULL)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get key name");
     if ((s2 = (const char *)H5HL_offset_into(udata->heap, rt_key->offset)) == NULL)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get key name");
 
+    /* Compute maximum length of string to compare */
+    if (rt_key->offset > lt_key->offset)
+        max_len = udata->block_size - rt_key->offset;
+    else
+        max_len = udata->block_size - lt_key->offset;
+
     /* Set return value */
-    ret_value = strcmp(s1, s2);
+    ret_value = strncmp(s1, s2, max_len);
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
@@ -391,28 +398,28 @@ static herr_t
 H5G__node_cmp3(void *_lt_key, void *_udata, void *_rt_key)
 {
     H5G_bt_common_t *udata  = (H5G_bt_common_t *)_udata;
     H5G_node_key_t  *lt_key = (H5G_node_key_t *)_lt_key;
     H5G_node_key_t  *rt_key = (H5G_node_key_t *)_rt_key;
     const char      *s;
     herr_t           ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Sanity checks */
     assert(udata && udata->heap);
     assert(lt_key);
     assert(rt_key);
 
     /* left side */
     if ((s = (const char *)H5HL_offset_into(udata->heap, lt_key->offset)) == NULL)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get key name");
-    if (strcmp(udata->name, s) <= 0)
+    if (strncmp(udata->name, s, (udata->block_size - lt_key->offset)) <= 0)
         ret_value = (-1);
     else {
         /* right side */
         if ((s = (const char *)H5HL_offset_into(udata->heap, rt_key->offset)) == NULL)
             HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get key name");
-        if (strcmp(udata->name, s) > 0)
+        if (strncmp(udata->name, s, (udata->block_size - rt_key->offset)) > 0)
             ret_value = 1;
     } /* end else */
 
@@ -445,52 +452,52 @@ static herr_t
 H5G__node_found(H5F_t *f, haddr_t addr, const void H5_ATTR_UNUSED *_lt_key, bool *found, void *_udata)
 {
     H5G_bt_lkp_t *udata = (H5G_bt_lkp_t *)_udata;
     H5G_node_t   *sn    = NULL;
     unsigned      lt = 0, idx = 0, rt;
     int           cmp = 1;
     const char   *s;
     herr_t        ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /*
      * Check arguments.
      */
     assert(f);
     assert(H5_addr_defined(addr));
     assert(found);
     assert(udata && udata->common.heap);
 
     /*
      * Load the symbol table node for exclusive access.
      */
     if (NULL == (sn = (H5G_node_t *)H5AC_protect(f, H5AC_SNODE, addr, f, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, FAIL, "unable to protect symbol table node");
 
     /*
      * Binary search.
      */
     rt = sn->nsyms;
     while (lt < rt && cmp) {
         idx = (lt + rt) / 2;
 
         if ((s = (const char *)H5HL_offset_into(udata->common.heap, sn->entry[idx].name_off)) == NULL)
             HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get symbol table name");
-        cmp = strcmp(udata->common.name, s);
+        cmp = strncmp(udata->common.name, s, (udata->common.block_size - sn->entry[idx].name_off));
 
         if (cmp < 0)
             rt = idx;
         else
             lt = idx + 1;
     } /* end while */
 
     if (cmp)
         *found = false;
     else {
         /* Set the 'found it' flag */
         *found = true;
 
         /* Call user's callback operator */
         if ((udata->op)(&sn->entry[idx], udata->op_data) < 0)
             HGOTO_ERROR(H5E_SYM, H5E_BADITER, FAIL, "iterator callback failed");
     } /* end else */
@@ -534,122 +541,121 @@ static H5B_ins_t
 H5G__node_insert(H5F_t *f, haddr_t addr, void H5_ATTR_UNUSED *_lt_key, bool H5_ATTR_UNUSED *lt_key_changed,
                  void *_md_key, void *_udata, void *_rt_key, bool *rt_key_changed, haddr_t *new_node_p)
 {
     H5G_node_key_t *md_key = (H5G_node_key_t *)_md_key;
     H5G_node_key_t *rt_key = (H5G_node_key_t *)_rt_key;
     H5G_bt_ins_t   *udata  = (H5G_bt_ins_t *)_udata;
     H5G_node_t     *sn = NULL, *snrt = NULL;
     unsigned        sn_flags = H5AC__NO_FLAGS_SET, snrt_flags = H5AC__NO_FLAGS_SET;
     const char     *s;
     unsigned        lt  = 0, rt; /* Binary search cntrs	*/
     int             cmp = 1, idx = -1;
     H5G_node_t     *insert_into = NULL; /*node that gets new entry*/
     H5G_entry_t     ent;                /* Entry to insert in node */
     H5B_ins_t       ret_value = H5B_INS_ERROR;
 
     FUNC_ENTER_PACKAGE
 
     /*
      * Check arguments.
      */
     assert(f);
     assert(H5_addr_defined(addr));
     assert(md_key);
     assert(rt_key);
     assert(udata && udata->common.heap);
     assert(new_node_p);
 
     /*
      * Load the symbol node.
      */
     if (NULL == (sn = (H5G_node_t *)H5AC_protect(f, H5AC_SNODE, addr, f, H5AC__NO_FLAGS_SET)))
         HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5B_INS_ERROR, "unable to protect symbol table node");
 
     /*
      * Where does the new symbol get inserted?	We use a binary search.
      */
     rt = sn->nsyms;
     while (lt < rt) {
         idx = (int)((lt + rt) / 2);
         if ((s = (const char *)H5HL_offset_into(udata->common.heap, sn->entry[idx].name_off)) == NULL)
             HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5B_INS_ERROR, "unable to get symbol table name");
 
         /* Check if symbol is already present */
-        if (0 == (cmp = strcmp(udata->common.name, s)))
+        if (0 == (cmp = strncmp(udata->common.name, s, (udata->common.block_size - sn->entry[idx].name_off))))
             HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, H5B_INS_ERROR, "symbol is already present in symbol table");
 
         if (cmp < 0)
             rt = (unsigned)idx;
         else
             lt = (unsigned)(idx + 1);
     } /* end while */
     idx += cmp > 0 ? 1 : 0;
 
     /* Convert link information & name to symbol table entry */
-    if (H5G__ent_convert(f, udata->common.heap, udata->common.name, udata->lnk, udata->obj_type,
-                         udata->crt_info, &ent) < 0)
+    if (H5G__link_to_ent(f, udata->common.heap, udata->lnk, udata->obj_type, udata->crt_info, &ent) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTCONVERT, H5B_INS_ERROR, "unable to convert link");
 
     /* Determine where to place entry in node */
     if (sn->nsyms >= 2 * H5F_SYM_LEAF_K(f)) {
         /*
          * The node is full.  Split it into a left and right
          * node and return the address of the new right node (the
          * left node is at the same address as the original node).
          */
         ret_value = H5B_INS_RIGHT;
 
         /* The right node */
         if (H5G__node_create(f, H5B_INS_FIRST, NULL, NULL, NULL, new_node_p /*out*/) < 0)
             HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, H5B_INS_ERROR, "unable to split symbol table node");
 
         if (NULL == (snrt = (H5G_node_t *)H5AC_protect(f, H5AC_SNODE, *new_node_p, f, H5AC__NO_FLAGS_SET)))
             HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5B_INS_ERROR, "unable to split symbol table node");
 
         H5MM_memcpy(snrt->entry, sn->entry + H5F_SYM_LEAF_K(f), H5F_SYM_LEAF_K(f) * sizeof(H5G_entry_t));
         snrt->nsyms = H5F_SYM_LEAF_K(f);
         snrt_flags |= H5AC__DIRTIED_FLAG;
 
         /* The left node */
         memset(sn->entry + H5F_SYM_LEAF_K(f), 0, H5F_SYM_LEAF_K(f) * sizeof(H5G_entry_t));
         sn->nsyms = H5F_SYM_LEAF_K(f);
         sn_flags |= H5AC__DIRTIED_FLAG;
 
         /* The middle key */
         md_key->offset = sn->entry[sn->nsyms - 1].name_off;
 
         /* Where to insert the new entry? */
         if (idx <= (int)H5F_SYM_LEAF_K(f)) {
             insert_into = sn;
             if (idx == (int)H5F_SYM_LEAF_K(f))
                 md_key->offset = ent.name_off;
         } /* end if */
         else {
             idx -= (int)H5F_SYM_LEAF_K(f);
             insert_into = snrt;
             if (idx == (int)H5F_SYM_LEAF_K(f)) {
                 rt_key->offset  = ent.name_off;
                 *rt_key_changed = true;
             } /* end if */
         }     /* end else */
     }         /* end if */
     else {
         /* Where to insert the new entry? */
         ret_value = H5B_INS_NOOP;
         sn_flags |= H5AC__DIRTIED_FLAG;
         insert_into = sn;
         if (idx == (int)sn->nsyms) {
             rt_key->offset  = ent.name_off;
             *rt_key_changed = true;
         } /* end if */
     }     /* end else */
 
     /* Move entries down to make room for new entry */
     assert(idx >= 0);
     memmove(insert_into->entry + idx + 1, insert_into->entry + idx,
             (insert_into->nsyms - (unsigned)idx) * sizeof(H5G_entry_t));
 
     /* Copy new entry into table */
     H5G__ent_copy(&(insert_into->entry[idx]), &ent, H5_COPY_SHALLOW);
 
     /* Increment # of symbols in table */
     insert_into->nsyms += 1;
@@ -692,176 +698,186 @@ static H5B_ins_t
 H5G__node_remove(H5F_t *f, haddr_t addr, void H5_ATTR_NDEBUG_UNUSED *_lt_key /*in,out*/,
                  bool H5_ATTR_UNUSED *lt_key_changed /*out*/, void *_udata /*in,out*/,
                  void *_rt_key /*in,out*/, bool *rt_key_changed /*out*/)
 {
     H5G_node_key_t *rt_key   = (H5G_node_key_t *)_rt_key;
     H5G_bt_rm_t    *udata    = (H5G_bt_rm_t *)_udata;
     H5G_node_t     *sn       = NULL;
     unsigned        sn_flags = H5AC__NO_FLAGS_SET;
     unsigned        lt = 0, rt, idx = 0;
     int             cmp       = 1;
     H5B_ins_t       ret_value = H5B_INS_ERROR;
 
     FUNC_ENTER_PACKAGE
 
     /* Check arguments */
     assert(f);
     assert(H5_addr_defined(addr));
     assert((H5G_node_key_t *)_lt_key);
     assert(rt_key);
     assert(udata && udata->common.heap);
 
     /* Load the symbol table */
     if (NULL == (sn = (H5G_node_t *)H5AC_protect(f, H5AC_SNODE, addr, f, H5AC__NO_FLAGS_SET)))
         HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5B_INS_ERROR, "unable to protect symbol table node");
 
     /* "Normal" removal of a single entry from the symbol table node */
     if (udata->common.name != NULL) {
         H5O_link_t lnk;           /* Constructed link for replacement */
         size_t     link_name_len; /* Length of string in local heap */
 
         /* Find the name with a binary search */
         rt = sn->nsyms;
         while (lt < rt && cmp) {
             const char *s; /* Pointer to string in local heap */
 
             idx = (lt + rt) / 2;
             if ((s = (const char *)H5HL_offset_into(udata->common.heap, sn->entry[idx].name_off)) == NULL)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5B_INS_ERROR, "unable to get symbol table name");
-            cmp = strcmp(udata->common.name, s);
+            cmp = strncmp(udata->common.name, s, (udata->common.block_size - sn->entry[idx].name_off));
             if (cmp < 0)
                 rt = idx;
             else
                 lt = idx + 1;
         } /* end while */
 
         if (cmp)
             HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, H5B_INS_ERROR, "name not found");
 
         /* Get a pointer to the name of the link */
         if (NULL == (lnk.name = (char *)H5HL_offset_into(udata->common.heap, sn->entry[idx].name_off)))
             HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5B_INS_ERROR, "unable to get link name");
-        link_name_len = strlen(lnk.name) + 1;
+
+        /* Compute the size of the link name in the heap, being defensive about corrupted data */
+        link_name_len = strnlen(lnk.name, (udata->common.block_size - sn->entry[idx].name_off)) + 1;
+        if (link_name_len > (udata->common.block_size - sn->entry[idx].name_off))
+            link_name_len = (udata->common.block_size - sn->entry[idx].name_off);
 
         /* Set up rest of link structure */
         lnk.corder_valid = false;
         lnk.corder       = 0;
         lnk.cset         = H5T_CSET_ASCII;
         if (sn->entry[idx].type == H5G_CACHED_SLINK) {
             lnk.type = H5L_TYPE_SOFT;
             if (NULL == (lnk.u.soft.name = (char *)H5HL_offset_into(udata->common.heap,
                                                                     sn->entry[idx].cache.slink.lval_offset)))
                 HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5B_INS_ERROR, "unable to get link name");
         } /* end if */
         else {
             lnk.type = H5L_TYPE_HARD;
             assert(H5_addr_defined(sn->entry[idx].header));
             lnk.u.hard.addr = sn->entry[idx].header;
         } /* end else */
 
         /* Replace any object names */
         if (H5G__link_name_replace(f, udata->grp_full_path_r, &lnk) < 0)
             HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5B_INS_ERROR, "unable to get object type");
 
         /* Decrement the ref. count for hard links */
         if (lnk.type == H5L_TYPE_HARD) {
             H5O_loc_t tmp_oloc; /* Temporary object location */
 
             /* Build temporary object location */
             tmp_oloc.file = f;
             tmp_oloc.addr = lnk.u.hard.addr;
 
             if (H5O_link(&tmp_oloc, -1) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, H5B_INS_ERROR, "unable to decrement object link count");
         } /* end if */
         else {
             /* Remove the soft link's value from the local heap */
             if (lnk.u.soft.name) {
                 size_t soft_link_len; /* Length of string in local heap */
 
-                soft_link_len = strlen(lnk.u.soft.name) + 1;
+                /* Compute the size of the soft link name in the heap, being defensive about corrupted data */
+                soft_link_len = strnlen(lnk.u.soft.name,
+                                        (udata->common.block_size - sn->entry[idx].cache.slink.lval_offset)) +
+                                1;
+                if (soft_link_len > (udata->common.block_size - sn->entry[idx].cache.slink.lval_offset))
+                    soft_link_len = (udata->common.block_size - sn->entry[idx].cache.slink.lval_offset);
+
                 if (H5HL_remove(f, udata->common.heap, sn->entry[idx].cache.slink.lval_offset,
                                 soft_link_len) < 0)
                     HGOTO_ERROR(H5E_SYM, H5E_CANTDELETE, H5B_INS_ERROR,
                                 "unable to remove soft link from local heap");
             } /* end if */
         }     /* end else */
 
         /* Remove the link's name from the local heap */
         if (H5HL_remove(f, udata->common.heap, sn->entry[idx].name_off, link_name_len) < 0)
             HGOTO_ERROR(H5E_SYM, H5E_CANTDELETE, H5B_INS_ERROR, "unable to remove link name from local heap");
 
         /* Remove the entry from the symbol table node */
         if (1 == sn->nsyms) {
             /*
              * We are about to remove the only symbol in this node.  Free this
              * node and indicate that the pointer to this node in the B-tree
              * should be removed also.
              */
             assert(0 == idx);
             sn->nsyms = 0;
             sn_flags |= H5AC__DIRTIED_FLAG | H5AC__DELETED_FLAG | H5AC__FREE_FILE_SPACE_FLAG;
             ret_value = H5B_INS_REMOVE;
         }
         else if (0 == idx) {
             /*
              * We are about to remove the left-most entry from the symbol table
              * node but there are other entries to the right.  No key values
              * change.
              */
             sn->nsyms -= 1;
             sn_flags |= H5AC__DIRTIED_FLAG;
             memmove(sn->entry + idx, sn->entry + idx + 1, (sn->nsyms - idx) * sizeof(H5G_entry_t));
             ret_value = H5B_INS_NOOP;
         }
         else if (idx + 1 == sn->nsyms) {
             /*
              * We are about to remove the right-most entry from the symbol table
              * node but there are other entries to the left.  The right key
              * should be changed to reflect the new right-most entry.
              */
             sn->nsyms -= 1;
             sn_flags |= H5AC__DIRTIED_FLAG;
             rt_key->offset  = sn->entry[sn->nsyms - 1].name_off;
             *rt_key_changed = true;
             ret_value       = H5B_INS_NOOP;
         }
         else {
             /*
              * We are about to remove an entry from the middle of a symbol table
              * node.
              */
             sn->nsyms -= 1;
             sn_flags |= H5AC__DIRTIED_FLAG;
             memmove(sn->entry + idx, sn->entry + idx + 1, (sn->nsyms - idx) * sizeof(H5G_entry_t));
             ret_value = H5B_INS_NOOP;
         } /* end else */
     }     /* end if */
     /* Remove all entries from node, during B-tree deletion */
     else {
         H5O_loc_t tmp_oloc; /* Temporary object location */
 
         /* Build temporary object location */
         tmp_oloc.file = f;
 
         /* Reduce the link count for all entries in this node */
         for (idx = 0; idx < sn->nsyms; idx++) {
             if (!(H5G_CACHED_SLINK == sn->entry[idx].type)) {
                 /* Decrement the reference count */
                 assert(H5_addr_defined(sn->entry[idx].header));
                 tmp_oloc.addr = sn->entry[idx].header;
 
                 if (H5O_link(&tmp_oloc, -1) < 0)
                     HGOTO_ERROR(H5E_SYM, H5E_CANTDELETE, H5B_INS_ERROR,
                                 "unable to decrement object link count");
             } /* end if */
         }     /* end for */
 
         /*
          * We are about to remove all the symbols in this node.  Free this
          * node and indicate that the pointer to this node in the B-tree
          * should be removed also.
          */
         sn->nsyms = 0;
         sn_flags |= H5AC__DIRTIED_FLAG | H5AC__DELETED_FLAG | H5AC__FREE_FILE_SPACE_FLAG;
         ret_value = H5B_INS_REMOVE;
     } /* end else */
@@ -886,56 +902,51 @@ int
 H5G__node_iterate(H5F_t *f, const void H5_ATTR_UNUSED *_lt_key, haddr_t addr,
                   const void H5_ATTR_UNUSED *_rt_key, void *_udata)
 {
     H5G_bt_it_it_t *udata = (H5G_bt_it_it_t *)_udata;
     H5G_node_t     *sn    = NULL;
     H5G_entry_t    *ents; /* Pointer to entries in this node */
     unsigned        u;    /* Local index variable */
     int             ret_value = H5_ITER_CONT;
 
     FUNC_ENTER_PACKAGE
 
     /*
      * Check arguments.
      */
     assert(f);
     assert(H5_addr_defined(addr));
     assert(udata && udata->heap);
 
     /* Protect the symbol table node & local heap while we iterate over entries */
     if (NULL == (sn = (H5G_node_t *)H5AC_protect(f, H5AC_SNODE, addr, f, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5_ITER_ERROR, "unable to load symbol table node");
 
     /*
      * Iterate over the symbol table node entries.
      */
     for (u = 0, ents = sn->entry; u < sn->nsyms && ret_value == H5_ITER_CONT; u++) {
         if (udata->skip > 0)
             --udata->skip;
         else {
-            H5O_link_t  lnk;  /* Link for entry */
-            const char *name; /* Pointer to link name in heap */
-
-            /* Get the pointer to the name of the link in the heap */
-            if ((name = (const char *)H5HL_offset_into(udata->heap, ents[u].name_off)) == NULL)
-                HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5_ITER_ERROR, "unable to get symbol table node name");
+            H5O_link_t lnk; /* Link for entry */
 
             /* Convert the entry to a link */
-            if (H5G__ent_to_link(&lnk, udata->heap, &ents[u], name) < 0)
+            if (H5G__ent_to_link(&ents[u], udata->heap, &lnk) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTCONVERT, H5_ITER_ERROR,
                             "unable to convert symbol table entry to link");
 
             /* Make the callback */
             ret_value = (udata->op)(&lnk, udata->op_data);
 
             /* Release memory for link object */
             if (H5O_msg_reset(H5O_LINK_ID, &lnk) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTFREE, H5_ITER_ERROR, "unable to release link message");
         } /* end else */
 
         /* Increment the number of entries passed through */
         /* (whether we skipped them or not) */
         if (udata->final_ent)
             (*udata->final_ent)++;
     } /* end for */
     if (ret_value < 0)
         HERROR(H5E_SYM, H5E_CANTNEXT, "iteration operator failed");
@@ -1127,155 +1138,167 @@ int
 H5G__node_copy(H5F_t *f, const void H5_ATTR_UNUSED *_lt_key, haddr_t addr, const void H5_ATTR_UNUSED *_rt_key,
                void *_udata)
 {
     H5G_bt_it_cpy_t *udata    = (H5G_bt_it_cpy_t *)_udata;
     const H5O_loc_t *src_oloc = udata->src_oloc;
     H5O_copy_t      *cpy_info = udata->cpy_info;
-    H5HL_t          *heap     = NULL;
     H5G_node_t      *sn       = NULL;
     unsigned int     i; /* Local index variable */
     int              ret_value = H5_ITER_CONT;
 
     FUNC_ENTER_PACKAGE
 
     /* Check arguments. */
     assert(f);
     assert(H5_addr_defined(addr));
     assert(udata);
+    assert(udata->src_heap);
 
     /* load the symbol table into memory from the source file */
     if (NULL == (sn = (H5G_node_t *)H5AC_protect(f, H5AC_SNODE, addr, f, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5_ITER_ERROR, "unable to load symbol table node");
 
-    /* get the base address of the heap */
-    if (NULL == (heap = H5HL_protect(f, udata->src_heap_addr, H5AC__READ_ONLY_FLAG)))
-        HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, H5_ITER_ERROR, "unable to protect symbol name");
-
     /* copy object in this node one by one */
     for (i = 0; i < sn->nsyms; i++) {
         H5G_entry_t *src_ent =
             &(sn->entry[i]);             /* Convenience variable to refer to current source group entry */
         H5O_link_t          lnk;         /* Link to insert */
-        const char         *name;        /* Name of source object */
+        char               *name;        /* Name of source object */
         H5G_entry_t         tmp_src_ent; /* Temporary copy. Change will not affect the cache */
         H5O_type_t          obj_type = H5O_TYPE_UNKNOWN; /* Target object type */
         H5G_copy_file_ud_t *cpy_udata;                   /* Copy file udata */
         H5G_obj_create_t    gcrt_info;                   /* Group creation info */
+        size_t              max_link_len;                /* Max. length of string in local heap */
 
         /* expand soft link */
         if (H5G_CACHED_SLINK == src_ent->type && cpy_info->expand_soft_link) {
-            haddr_t    obj_addr;  /* Address of object pointed to by soft link */
-            H5G_loc_t  grp_loc;   /* Group location holding soft link */
-            H5G_name_t grp_path;  /* Path for group holding soft link */
-            char      *link_name; /* Pointer to value of soft link */
+            haddr_t    obj_addr = HADDR_UNDEF; /* Address of object pointed to by soft link */
+            H5G_loc_t  grp_loc;                /* Group location holding soft link */
+            H5G_name_t grp_path;               /* Path for group holding soft link */
+            char      *link_name;              /* Pointer to value of soft link */
 
             /* Make a temporary copy, so that it will not change the info in the cache */
             H5MM_memcpy(&tmp_src_ent, src_ent, sizeof(H5G_entry_t));
 
             /* Set up group location for soft link to start in */
             H5G_name_reset(&grp_path);
             grp_loc.path = &grp_path;
             H5_GCC_CLANG_DIAG_OFF("cast-qual")
             grp_loc.oloc = (H5O_loc_t *)src_oloc;
             H5_GCC_CLANG_DIAG_ON("cast-qual")
 
             /* Get pointer to link value in local heap */
-            if ((link_name = (char *)H5HL_offset_into(heap, tmp_src_ent.cache.slink.lval_offset)) == NULL)
-                HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, H5_ITER_ERROR, "unable to get link name");
+            if ((link_name =
+                     (char *)H5HL_offset_into(udata->src_heap, tmp_src_ent.cache.slink.lval_offset)) == NULL)
+                HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5_ITER_ERROR, "unable to get link name");
+
+            /* Sanity check soft link name, to detect running off the end of the heap block */
+            max_link_len = udata->src_block_size - tmp_src_ent.cache.slink.lval_offset;
+            if (strnlen(link_name, max_link_len) == max_link_len)
+                HGOTO_ERROR(H5E_SYM, H5E_BADVALUE, H5_ITER_ERROR, "invalid link name offset");
 
             /* Check if the object pointed by the soft link exists in the source file */
-            if (H5G__loc_addr(&grp_loc, link_name, &obj_addr) >= 0) {
+            if (H5G__loc_addr(&grp_loc, link_name, &obj_addr) < 0)
+                HGOTO_ERROR(H5E_SYM, H5E_CANTFIND, H5_ITER_ERROR,
+                            "unable to check if soft link resolves to an object");
+            if (H5_addr_defined(obj_addr)) {
                 tmp_src_ent.header = obj_addr;
                 src_ent            = &tmp_src_ent;
             } /* end if */
-            else
-                H5E_clear_stack(NULL); /* discard any errors from a dangling soft link */
-        }                              /* if ((H5G_CACHED_SLINK == src_ent->type)... */
+        }     /* if ((H5G_CACHED_SLINK == src_ent->type)... */
 
         /* Check if object in source group is a hard link */
         if (H5_addr_defined(src_ent->header)) {
             H5O_loc_t new_dst_oloc; /* Copied object location in destination */
             H5O_loc_t tmp_src_oloc; /* Temporary object location for source object */
 
             /* Set up copied object location to fill in */
             H5O_loc_reset(&new_dst_oloc);
             new_dst_oloc.file = udata->dst_file;
 
             /* Build temporary object location for source */
             H5O_loc_reset(&tmp_src_oloc);
             tmp_src_oloc.file = f;
             tmp_src_oloc.addr = src_ent->header;
 
             /* Copy the shared object from source to destination */
             if (H5O_copy_header_map(&tmp_src_oloc, &new_dst_oloc, cpy_info, true, &obj_type,
                                     (void **)&cpy_udata) < 0)
                 HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, H5_ITER_ERROR, "unable to copy object");
 
             /* Set up object creation info for symbol table insertion.  Only
              * case so far is for inserting old-style groups (for caching stab
              * info). */
             if (obj_type == H5O_TYPE_GROUP) {
                 gcrt_info.gcpl_id    = H5P_DEFAULT;
                 gcrt_info.cache_type = cpy_udata->cache_type;
                 gcrt_info.cache      = cpy_udata->cache;
             } /* end if */
 
             /* Construct link information for eventual insertion */
             lnk.type        = H5L_TYPE_HARD;
             lnk.u.hard.addr = new_dst_oloc.addr;
         } /* ( H5_addr_defined(src_ent->header)) */
         else if (H5G_CACHED_SLINK == src_ent->type) {
             /* it is a soft link */
             /* Set object type to unknown */
             obj_type = H5O_TYPE_UNKNOWN;
 
             /* Construct link information for eventual insertion */
             lnk.type = H5L_TYPE_SOFT;
-            if ((lnk.u.soft.name = (char *)H5HL_offset_into(heap, src_ent->cache.slink.lval_offset)) == NULL)
+            if ((lnk.u.soft.name =
+                     (char *)H5HL_offset_into(udata->src_heap, src_ent->cache.slink.lval_offset)) == NULL)
                 HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, H5_ITER_ERROR, "unable to get link name");
+
+            /* Sanity check soft link name, to detect running off the end of the heap block */
+            max_link_len = udata->src_block_size - src_ent->cache.slink.lval_offset;
+            if (strnlen(lnk.u.soft.name, max_link_len) == max_link_len)
+                HGOTO_ERROR(H5E_SYM, H5E_BADVALUE, H5_ITER_ERROR, "invalid link name offset");
         } /* else if */
         else
             assert(0 && "Unknown entry type");
 
+        /* Determine name of source object */
+        if ((name = (char *)H5HL_offset_into(udata->src_heap, src_ent->name_off)) == NULL)
+            HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5_ITER_ERROR, "unable to get source object name");
+
+        /* Sanity check soft link name, to detect running off the end of the heap block */
+        max_link_len = udata->src_block_size - src_ent->name_off;
+        if (strnlen(name, max_link_len) == max_link_len)
+            HGOTO_ERROR(H5E_SYM, H5E_BADVALUE, H5_ITER_ERROR, "invalid link name offset");
+
         /* Set up common link data */
         lnk.cset         = H5F_DEFAULT_CSET; /* XXX: Allow user to set this */
         lnk.corder       = 0;                /* Creation order is not tracked for old-style links */
         lnk.corder_valid = false;            /* Creation order is not valid */
-        /* lnk.name = name; */               /* This will be set in callback */
-
-        /* Determine name of source object */
-        if ((name = (const char *)H5HL_offset_into(heap, src_ent->name_off)) == NULL)
-            HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, H5_ITER_ERROR, "unable to get source object name");
+        lnk.name         = name;             /* Name of link */
 
         /* Set copied metadata tag */
         H5_BEGIN_TAG(H5AC__COPIED_TAG)
 
         /* Insert the new object in the destination file's group */
         /* (Don't increment the link count - that's already done above for hard links) */
-        if (H5G__stab_insert_real(udata->dst_file, udata->dst_stab, name, &lnk, obj_type,
+        if (H5G__stab_insert_real(udata->dst_file, udata->dst_stab, &lnk, obj_type,
                                   (obj_type == H5O_TYPE_GROUP ? &gcrt_info : NULL)) < 0)
             HGOTO_ERROR_TAG(H5E_DATATYPE, H5E_CANTINIT, H5_ITER_ERROR, "unable to insert the name");
 
         /* Reset metadata tag */
         H5_END_TAG
 
     } /* end of for (i=0; i<sn->nsyms; i++) */
 
 done:
-    if (heap && H5HL_unprotect(heap) < 0)
-        HDONE_ERROR(H5E_SYM, H5E_PROTECT, H5_ITER_ERROR, "unable to unprotect symbol name");
-
     if (sn && H5AC_unprotect(f, H5AC_SNODE, addr, sn, H5AC__NO_FLAGS_SET) < 0)
         HDONE_ERROR(H5E_SYM, H5E_PROTECT, H5_ITER_ERROR, "unable to release object header");
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G__node_copy() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5G__node_build_table
  *
  * Purpose:     B-link tree callback for building table of links
  *
  * Return:      Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
@@ -1283,53 +1306,48 @@ int
 H5G__node_build_table(H5F_t *f, const void H5_ATTR_UNUSED *_lt_key, haddr_t addr,
                       const void H5_ATTR_UNUSED *_rt_key, void *_udata)
 {
     H5G_bt_it_bt_t *udata = (H5G_bt_it_bt_t *)_udata;
     H5G_node_t     *sn    = NULL; /* Symbol table node */
     unsigned        u;            /* Local index variable */
     int             ret_value = H5_ITER_CONT;
 
     FUNC_ENTER_PACKAGE
 
     /*
      * Check arguments.
      */
     assert(f);
     assert(H5_addr_defined(addr));
     assert(udata && udata->heap);
 
     /*
      * Save information about the symbol table node since we can't lock it
      * because we're about to call an application function.
      */
     if (NULL == (sn = (H5G_node_t *)H5AC_protect(f, H5AC_SNODE, addr, f, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, H5_ITER_ERROR, "unable to load symbol table node");
 
     /* Check if the link table needs to be extended */
     if ((udata->ltable->nlinks + sn->nsyms) >= udata->alloc_nlinks) {
         size_t      na = MAX((udata->ltable->nlinks + sn->nsyms),
                              (udata->alloc_nlinks * 2)); /* Double # of links allocated */
         H5O_link_t *x;                                   /* Pointer to larger array of links */
 
         /* Re-allocate the link table */
         if (NULL == (x = (H5O_link_t *)H5MM_realloc(udata->ltable->lnks, sizeof(H5O_link_t) * na)))
             HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, H5_ITER_ERROR, "memory allocation failed");
         udata->ltable->lnks = x;
     } /* end if */
 
     /* Iterate over the symbol table node entries, adding to link table */
     for (u = 0; u < sn->nsyms; u++) {
-        const char *name;   /* Pointer to link name in heap */
-        size_t      linkno; /* Link allocated */
-
-        /* Get pointer to link's name in the heap */
-        if ((name = (const char *)H5HL_offset_into(udata->heap, sn->entry[u].name_off)) == NULL)
-            HGOTO_ERROR(H5E_SYM, H5E_CANTGET, H5_ITER_ERROR, "unable to get symbol table link name");
+        size_t linkno; /* Link allocated */
 
         /* Determine the link to operate on in the table */
         linkno = udata->ltable->nlinks++;
 
         /* Convert the entry to a link */
-        if (H5G__ent_to_link(&udata->ltable->lnks[linkno], udata->heap, &sn->entry[u], name) < 0)
+        if (H5G__ent_to_link(&sn->entry[u], udata->heap, &udata->ltable->lnks[linkno]) < 0)
             HGOTO_ERROR(H5E_SYM, H5E_CANTCONVERT, H5_ITER_ERROR,
                         "unable to convert symbol table entry to link");
     } /* end for */
@@ -1383,61 +1401,62 @@ herr_t
 H5G_node_debug(H5F_t *f, haddr_t addr, FILE *stream, int indent, int fwidth, haddr_t heap_addr)
 {
     H5G_node_t *sn   = NULL;
     H5HL_t     *heap = NULL;
     unsigned    u;                   /* Local index variable */
     herr_t      ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
     /*
      * Check arguments.
      */
     assert(f);
     assert(H5_addr_defined(addr));
     assert(stream);
     assert(indent >= 0);
     assert(fwidth >= 0);
 
     /* Pin the heap down in memory */
     if (heap_addr > 0 && H5_addr_defined(heap_addr))
         if (NULL == (heap = H5HL_protect(f, heap_addr, H5AC__READ_ONLY_FLAG)))
             HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, FAIL, "unable to protect symbol table heap");
 
     /*
      * If we couldn't load the symbol table node, then try loading the
      * B-tree node.
      */
     if (NULL == (sn = (H5G_node_t *)H5AC_protect(f, H5AC_SNODE, addr, f, H5AC__READ_ONLY_FLAG))) {
         H5G_bt_common_t udata; /*data to pass through B-tree	*/
 
         H5E_clear_stack(NULL); /* discard that error */
-        udata.heap = heap;
+        udata.heap       = heap;
+        udata.block_size = H5HL_heap_get_size(heap);
         if (H5B_debug(f, addr, stream, indent, fwidth, H5B_SNODE, &udata) < 0)
             HGOTO_ERROR(H5E_SYM, H5E_CANTLOAD, FAIL, "unable to debug B-tree node");
     } /* end if */
     else {
         fprintf(stream, "%*sSymbol Table Node...\n", indent, "");
         fprintf(stream, "%*s%-*s %s\n", indent, "", fwidth, "Dirty:", sn->cache_info.is_dirty ? "Yes" : "No");
         fprintf(stream, "%*s%-*s %u\n", indent, "", fwidth,
                 "Size of Node (in bytes):", (unsigned)sn->node_size);
         fprintf(stream, "%*s%-*s %u of %u\n", indent, "", fwidth, "Number of Symbols:", sn->nsyms,
                 (unsigned)(2 * H5F_SYM_LEAF_K(f)));
 
         indent += 3;
         fwidth = MAX(0, fwidth - 3);
         for (u = 0; u < sn->nsyms; u++) {
             fprintf(stream, "%*sSymbol %u:\n", indent - 3, "", u);
 
             if (heap) {
                 const char *s = (const char *)H5HL_offset_into(heap, sn->entry[u].name_off);
 
                 if (s)
                     fprintf(stream, "%*s%-*s `%s'\n", indent, "", fwidth, "Name:", s);
             } /* end if */
             else
                 fprintf(stream, "%*s%-*s\n", indent, "", fwidth,
                         "Warning: Invalid heap address given, name not displayed!");
 
             H5G__ent_debug(sn->entry + u, stream, indent, fwidth, heap);
         } /* end for */
     }     /* end if */
diff --git a/src/H5Gobj.c b/src/H5Gobj.c
index 2b73c2b5cd..51feeaad56 100644
--- a/src/H5Gobj.c
+++ b/src/H5Gobj.c
@@ -387,209 +387,208 @@ static herr_t
 H5G__obj_stab_to_new_cb(const H5O_link_t *lnk, void *_udata)
 {
     H5G_obj_stab_it_ud1_t *udata     = (H5G_obj_stab_it_ud1_t *)_udata; /* 'User data' passed in */
     herr_t                 ret_value = H5_ITER_CONT;                    /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check arguments */
     assert(lnk);
     assert(udata);
 
     /* Insert link into group */
     H5_GCC_CLANG_DIAG_OFF("cast-qual")
-    if (H5G_obj_insert(udata->grp_oloc, lnk->name, (H5O_link_t *)lnk, false, H5O_TYPE_UNKNOWN, NULL) < 0)
+    if (H5G_obj_insert(udata->grp_oloc, (H5O_link_t *)lnk, false, H5O_TYPE_UNKNOWN, NULL) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, H5_ITER_ERROR, "can't insert link into group");
     H5_GCC_CLANG_DIAG_ON("cast-qual")
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G__obj_stab_to_new_cb() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5G_obj_insert
  *
  * Purpose:	Insert a new symbol into the group described by GRP_OLOC.
- *		file F.	 The name of the new symbol is NAME and its symbol
- *		table entry is OBJ_LNK.  Increment the reference
+ *		file F.	 The name of the new symbol is OBJ_LNK->NAME and its
+ *		symbol table entry is OBJ_LNK.  Increment the reference
  *              count for the object the link points if OBJ_LNK is a hard link
  *              and ADJ_LINK is true.
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
 herr_t
-H5G_obj_insert(const H5O_loc_t *grp_oloc, const char *name, H5O_link_t *obj_lnk, bool adj_link,
-               H5O_type_t obj_type, const void *crt_info)
+H5G_obj_insert(const H5O_loc_t *grp_oloc, H5O_link_t *obj_lnk, bool adj_link, H5O_type_t obj_type,
+               const void *crt_info)
 {
     H5O_pline_t  tmp_pline;             /* Pipeline message */
     H5O_pline_t *pline = NULL;          /* Pointer to pipeline message */
     H5O_linfo_t  linfo;                 /* Link info message */
     htri_t       linfo_exists;          /* Whether the link info message exists */
     bool         use_old_format;        /* Whether to use 'old format' (symbol table) for insertions or not */
     bool         use_new_dense = false; /* Whether to use "dense" form of 'new format' group */
     herr_t       ret_value     = SUCCEED; /* Return value */
 
     FUNC_ENTER_NOAPI_TAG(grp_oloc->addr, FAIL)
 
     /* check arguments */
     assert(grp_oloc && grp_oloc->file);
-    assert(name && *name);
     assert(obj_lnk);
 
     /* Check if we have information about the number of objects in this group */
     /* (by attempting to get the link info message for this group) */
     if ((linfo_exists = H5G__obj_get_linfo(grp_oloc, &linfo)) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "can't check for link info message");
     if (linfo_exists) {
         H5O_ginfo_t ginfo;         /* Group info message */
         size_t      link_msg_size; /* Size of new link message in the file */
 
         /* Using the new format for groups */
         use_old_format = false;
 
         /* Check for tracking creation order on this group's links */
         if (linfo.track_corder) {
             /* Set the creation order for the new link & indicate that it's valid */
             obj_lnk->corder       = linfo.max_corder;
             obj_lnk->corder_valid = true;
 
             /* Increment the max. creation order used in the group */
             linfo.max_corder++;
         } /* end if */
 
         /* Get the link's message size */
         if ((link_msg_size = H5O_msg_raw_size(grp_oloc->file, H5O_LINK_ID, false, obj_lnk)) == 0)
             HGOTO_ERROR(H5E_SYM, H5E_CANTGETSIZE, FAIL, "can't get link size");
 
         /* Get the group info */
         if (NULL == H5O_msg_read(grp_oloc, H5O_GINFO_ID, &ginfo))
             HGOTO_ERROR(H5E_SYM, H5E_BADMESG, FAIL, "can't get group info");
 
         /* If there's still a small enough number of links, use the 'link' message */
         /* (If the encoded form of the link is too large to fit into an object
          *  header message, convert to using dense link storage instead of link messages)
          */
         if (H5_addr_defined(linfo.fheap_addr))
             use_new_dense = true;
         else if (linfo.nlinks < ginfo.max_compact && link_msg_size < H5O_MESG_MAX_SIZE)
             use_new_dense = false;
         else {
             htri_t              pline_exists; /* Whether the pipeline message exists */
             H5G_obj_oh_it_ud1_t udata;        /* User data for iteration */
             H5O_mesg_operator_t op;           /* Message operator */
 
             /* Get the pipeline message, if it exists */
             if ((pline_exists = H5O_msg_exists(grp_oloc, H5O_PLINE_ID)) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to read object header");
             if (pline_exists) {
                 if (NULL == H5O_msg_read(grp_oloc, H5O_PLINE_ID, &tmp_pline))
                     HGOTO_ERROR(H5E_SYM, H5E_BADMESG, FAIL, "can't get link pipeline");
                 pline = &tmp_pline;
             } /* end if */
 
             /* The group doesn't currently have "dense" storage for links */
             if (H5G__dense_create(grp_oloc->file, &linfo, pline) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "unable to create 'dense' form of new format group");
 
             /* Set up user data for object header message iteration */
             udata.f       = grp_oloc->file;
             udata.oh_addr = grp_oloc->addr;
             udata.linfo   = &linfo;
 
             /* Iterate over the 'link' messages, inserting them into the dense link storage  */
             op.op_type  = H5O_MESG_OP_APP;
             op.u.app_op = H5G__obj_compact_to_dense_cb;
             if (H5O_msg_iterate(grp_oloc, H5O_LINK_ID, &op, &udata) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, FAIL, "error iterating over links");
 
             /* Remove all the 'link' messages */
             if (H5O_msg_remove(grp_oloc, H5O_LINK_ID, H5O_ALL, false) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTDELETE, FAIL, "unable to delete link messages");
 
             use_new_dense = true;
         } /* end else */
     }     /* end if */
     else {
         /* Check for new-style link information */
         if (obj_lnk->cset != H5T_CSET_ASCII || obj_lnk->type > H5L_TYPE_BUILTIN_MAX) {
             H5O_linfo_t           new_linfo = H5G_CRT_LINK_INFO_DEF;  /* Link information */
             H5O_ginfo_t           new_ginfo = H5G_CRT_GROUP_INFO_DEF; /* Group information */
             H5G_obj_stab_it_ud1_t udata;                              /* User data for iteration */
 
             /* Convert group to "new format" group, in order to hold the information */
 
             /* Insert link info message */
             if (H5O_msg_create(grp_oloc, H5O_LINFO_ID, 0, 0, &new_linfo) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "can't create message");
 
             /* Insert group info message */
             if (H5O_msg_create(grp_oloc, H5O_GINFO_ID, H5O_MSG_FLAG_CONSTANT, H5O_UPDATE_TIME, &new_ginfo) <
                 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "can't create message");
 
             /* Set up user data for iteration */
             udata.grp_oloc = grp_oloc;
 
             /* Iterate through all links in "old format" group and insert them into new format */
             if (H5G__stab_iterate(grp_oloc, H5_ITER_NATIVE, (hsize_t)0, NULL, H5G__obj_stab_to_new_cb,
                                   &udata) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTNEXT, FAIL, "error iterating over old format links");
 
             /* Remove the symbol table message from the group */
             if (H5O_msg_remove(grp_oloc, H5O_STAB_ID, 0, false) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTDELETE, FAIL, "unable to delete old format link storage");
 
             /* Recursively call this routine to insert the new link, since the
              *  group is in the "new format" now and the link info should be
              *  set up, etc.
              */
-            if (H5G_obj_insert(grp_oloc, name, obj_lnk, adj_link, obj_type, crt_info) < 0)
+            if (H5G_obj_insert(grp_oloc, obj_lnk, adj_link, obj_type, crt_info) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, FAIL, "unable to insert link into group");
 
             /* Done with insertion now */
             HGOTO_DONE(SUCCEED);
         } /* end if */
         else
             use_old_format = true;
     } /* end if */
 
     /* Insert into symbol table or "dense" storage */
     if (use_old_format) {
         /* Insert into symbol table */
-        if (H5G__stab_insert(grp_oloc, name, obj_lnk, obj_type, crt_info) < 0)
+        if (H5G__stab_insert(grp_oloc, obj_lnk, obj_type, crt_info) < 0)
             HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, FAIL, "unable to insert entry into symbol table");
     } /* end if */
     else {
         if (use_new_dense) {
             /* Insert into dense link storage */
             if (H5G__dense_insert(grp_oloc->file, &linfo, obj_lnk) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, FAIL, "unable to insert link into dense storage");
         } /* end if */
         else {
             /* Insert with link message */
             if (H5G__compact_insert(grp_oloc, obj_lnk) < 0)
                 HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, FAIL, "unable to insert link as link message");
         } /* end else */
     }     /* end else */
 
     /* Increment the number of objects in this group */
     if (!use_old_format) {
         linfo.nlinks++;
         if (H5O_msg_write(grp_oloc, H5O_LINFO_ID, 0, H5O_UPDATE_TIME, &linfo) < 0)
             HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "can't update link info message");
     } /* end if */
 
     /* Increment link count on object, if requested and it's a hard link */
     if (adj_link && obj_lnk->type == H5L_TYPE_HARD) {
         H5O_loc_t obj_oloc; /* Object location */
         H5O_loc_reset(&obj_oloc);
 
         /* Create temporary object location */
         obj_oloc.file = grp_oloc->file;
         obj_oloc.addr = obj_lnk->u.hard.addr;
 
         /* Increment reference count for object */
         if (H5O_link(&obj_oloc, 1) < 0)
             HGOTO_ERROR(H5E_SYM, H5E_LINKCOUNT, FAIL, "unable to increment hard link count");
     } /* end if */
diff --git a/src/H5Gpkg.h b/src/H5Gpkg.h
index a90ada92ba..f4f1749dc8 100644
--- a/src/H5Gpkg.h
+++ b/src/H5Gpkg.h
@@ -144,18 +144,19 @@ typedef struct {
 /*
  * Common data exchange structure for symbol table nodes.  This structure is
  * passed through the B-link tree layer to the methods for the objects
  * to which the B-link tree points.
  *
  * It's also used for B-tree iterators which require no additional info.
  *
  */
 typedef struct H5G_bt_common_t {
     /* downward */
-    const char *name; /*points to temporary memory         */
-    H5HL_t     *heap; /*symbol table heap             */
+    const char *name;       /* Points to temporary memory */
+    H5HL_t     *heap;       /* Symbol table heap */
+    size_t      block_size; /* Size of the heap block */
 } H5G_bt_common_t;
 
 /*
  * Data exchange structure for symbol table nodes.  This structure is
  * passed through the B-link tree layer to the insert method for entries.
  */
@@ -210,11 +211,12 @@ typedef struct H5G_bt_it_it_t {
 
 /* Data passed through B-tree iteration for copying copy symbol table content */
 typedef struct H5G_bt_it_cpy_t {
-    const H5O_loc_t  *src_oloc;      /* Source object location */
-    haddr_t           src_heap_addr; /* Heap address of the source symbol table  */
-    H5F_t            *dst_file;      /* File of destination group */
-    const H5O_stab_t *dst_stab;      /* Symbol table message for destination group */
-    H5O_copy_t       *cpy_info;      /* Information for copy operation */
+    const H5O_loc_t  *src_oloc;       /* Source object location */
+    H5HL_t           *src_heap;       /* Heap for the source symbol table  */
+    size_t            src_block_size; /* Size of the heap block */
+    H5F_t            *dst_file;       /* File of destination group */
+    const H5O_stab_t *dst_stab;       /* Symbol table message for destination group */
+    H5O_copy_t       *cpy_info;       /* Information for copy operation */
 } H5G_bt_it_cpy_t;
 
 /* Common information for "by index" lookups in symbol tables */
@@ -345,9 +347,9 @@ H5_DLL const char *H5G__component(const char *name, size_t *size_p);
  */
 H5_DLL herr_t H5G__stab_create(H5O_loc_t *grp_oloc, const H5O_ginfo_t *ginfo, H5O_stab_t *stab);
 H5_DLL herr_t H5G__stab_create_components(H5F_t *f, H5O_stab_t *stab, size_t size_hint);
-H5_DLL herr_t H5G__stab_insert(const H5O_loc_t *grp_oloc, const char *name, H5O_link_t *obj_lnk,
-                               H5O_type_t obj_type, const void *crt_info);
-H5_DLL herr_t H5G__stab_insert_real(H5F_t *f, const H5O_stab_t *stab, const char *name, H5O_link_t *obj_lnk,
+H5_DLL herr_t H5G__stab_insert(const H5O_loc_t *grp_oloc, H5O_link_t *obj_lnk, H5O_type_t obj_type,
+                               const void *crt_info);
+H5_DLL herr_t H5G__stab_insert_real(H5F_t *f, const H5O_stab_t *stab, H5O_link_t *obj_lnk,
                                     H5O_type_t obj_type, const void *crt_info);
 H5_DLL herr_t H5G__stab_delete(H5F_t *f, const H5O_stab_t *stab);
 H5_DLL herr_t H5G__stab_iterate(const H5O_loc_t *oloc, H5_iter_order_t order, hsize_t skip, hsize_t *last_lnk,
@@ -374,8 +376,7 @@ H5_DLL void   H5G__ent_reset(H5G_entry_t *ent);
 H5_DLL herr_t H5G__ent_decode_vec(const H5F_t *f, const uint8_t **pp, const uint8_t *p_end, H5G_entry_t *ent,
                                   unsigned n);
 H5_DLL herr_t H5G__ent_encode_vec(const H5F_t *f, uint8_t **pp, const H5G_entry_t *ent, unsigned n);
-H5_DLL herr_t H5G__ent_convert(H5F_t *f, H5HL_t *heap, const char *name, const H5O_link_t *lnk,
-                               H5O_type_t obj_type, const void *crt_info, H5G_entry_t *ent);
+H5_DLL herr_t H5G__ent_to_link(const H5G_entry_t *ent, const H5HL_t *heap, H5O_link_t *lnk);
 H5_DLL herr_t H5G__ent_debug(const H5G_entry_t *ent, FILE *stream, int indent, int fwidth,
                              const H5HL_t *heap);
 
@@ -392,7 +393,8 @@ H5_DLL herr_t H5G__node_iterate_size(H5F_t *f, const void *_lt_key, haddr_t addr
 H5_DLL herr_t H5G__node_free(H5G_node_t *sym);
 
 /* Functions that understand links in groups */
-H5_DLL herr_t H5G__ent_to_link(H5O_link_t *lnk, const H5HL_t *heap, const H5G_entry_t *ent, const char *name);
+H5_DLL herr_t H5G__link_to_ent(H5F_t *f, H5HL_t *heap, const H5O_link_t *lnk, H5O_type_t obj_type,
+                               const void *crt_info, H5G_entry_t *ent);
 H5_DLL herr_t H5G__link_to_loc(const H5G_loc_t *grp_loc, const H5O_link_t *lnk, H5G_loc_t *obj_loc);
 H5_DLL herr_t H5G__link_sort_table(H5G_link_table_t *ltable, H5_index_t idx_type, H5_iter_order_t order);
 H5_DLL herr_t H5G__link_iterate_table(const H5G_link_table_t *ltable, hsize_t skip, hsize_t *last_lnk,
diff --git a/src/H5Gprivate.h b/src/H5Gprivate.h
index bb172eb2af..a756a1c324 100644
--- a/src/H5Gprivate.h
+++ b/src/H5Gprivate.h
@@ -228,8 +228,8 @@ H5_DLL herr_t H5G_link_to_info(const struct H5O_loc_t *link_loc, const struct H5
 /*
  * Functions that understand group objects
  */
-H5_DLL herr_t H5G_obj_insert(const struct H5O_loc_t *grp_oloc, const char *name, struct H5O_link_t *obj_lnk,
-                             bool adj_link, H5O_type_t obj_type, const void *crt_info);
+H5_DLL herr_t H5G_obj_insert(const struct H5O_loc_t *grp_oloc, struct H5O_link_t *obj_lnk, bool adj_link,
+                             H5O_type_t obj_type, const void *crt_info);
 H5_DLL herr_t H5G_obj_get_name_by_idx(const struct H5O_loc_t *oloc, H5_index_t idx_type,
                                       H5_iter_order_t order, hsize_t n, char *name, size_t name_size,
                                       size_t *name_len);
diff --git a/src/H5Gstab.c b/src/H5Gstab.c
index ef9773d745..1ebd13681b 100644
--- a/src/H5Gstab.c
+++ b/src/H5Gstab.c
@@ -227,32 +227,32 @@ done:
  *-------------------------------------------------------------------------
  */
 herr_t
-H5G__stab_insert_real(H5F_t *f, const H5O_stab_t *stab, const char *name, H5O_link_t *obj_lnk,
-                      H5O_type_t obj_type, const void *crt_info)
+H5G__stab_insert_real(H5F_t *f, const H5O_stab_t *stab, H5O_link_t *obj_lnk, H5O_type_t obj_type,
+                      const void *crt_info)
 {
     H5HL_t      *heap = NULL;         /* Pointer to local heap */
     H5G_bt_ins_t udata;               /* Data to pass through B-tree	*/
     herr_t       ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check arguments */
     assert(f);
     assert(stab);
-    assert(name && *name);
     assert(obj_lnk);
 
     /* Pin the heap down in memory */
     if (NULL == (heap = H5HL_protect(f, stab->heap_addr, H5AC__NO_FLAGS_SET)))
         HGOTO_ERROR(H5E_SYM, H5E_PROTECT, FAIL, "unable to protect symbol table heap");
 
     /* Initialize data to pass through B-tree */
-    udata.common.name = name;
-    udata.common.heap = heap;
-    udata.lnk         = obj_lnk;
-    udata.obj_type    = obj_type;
-    udata.crt_info    = crt_info;
+    udata.common.name       = obj_lnk->name;
+    udata.common.heap       = heap;
+    udata.common.block_size = H5HL_heap_get_size(heap);
+    udata.lnk               = obj_lnk;
+    udata.obj_type          = obj_type;
+    udata.crt_info          = crt_info;
 
     /* Insert into symbol table */
     if (H5B_insert(f, H5B_SNODE, stab->btree_addr, &udata) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTINSERT, FAIL, "unable to insert entry");
@@ -260,42 +260,38 @@ H5G__stab_insert_real(H5F_t *f, const H5O_stab_t *stab, const char *name, H5O_li
 done:
     /* Release resources */
     if (heap && H5HL_unprotect(heap) < 0)
         HDONE_ERROR(H5E_SYM, H5E_PROTECT, FAIL, "unable to unprotect symbol table heap");
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5G__stab_insert_real() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5G__stab_insert
  *
- * Purpose:	Insert a new symbol into the table described by GRP_ENT in
- *		file F.	 The name of the new symbol is NAME and its symbol
- *		table entry is OBJ_ENT.
+ * Purpose:	Insert a new link, OBJ_LNK, into the group, GRP_OLOC.
  *
  * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
 herr_t
-H5G__stab_insert(const H5O_loc_t *grp_oloc, const char *name, H5O_link_t *obj_lnk, H5O_type_t obj_type,
-                 const void *crt_info)
+H5G__stab_insert(const H5O_loc_t *grp_oloc, H5O_link_t *obj_lnk, H5O_type_t obj_type, const void *crt_info)
 {
     H5O_stab_t stab;                /* Symbol table message		*/
     herr_t     ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check arguments */
     assert(grp_oloc && grp_oloc->file);
-    assert(name && *name);
     assert(obj_lnk);
 
     /* Retrieve symbol table message */
     if (NULL == H5O_msg_read(grp_oloc, H5O_STAB_ID, &stab))
         HGOTO_ERROR(H5E_SYM, H5E_BADMESG, FAIL, "not a symbol table");
 
-    if (H5G__stab_insert_real(grp_oloc->file, &stab, name, obj_lnk, obj_type, crt_info) < 0)
-        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, H5_ITER_ERROR, "unable to insert the name");
+    if (H5G__stab_insert_real(grp_oloc->file, &stab, obj_lnk, obj_type, crt_info) < 0)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, H5_ITER_ERROR, "unable to insert the link");
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
@@ -314,28 +310,29 @@ herr_t
 H5G__stab_remove(const H5O_loc_t *loc, H5RS_str_t *grp_full_path_r, const char *name)
 {
     H5HL_t     *heap = NULL;         /* Pointer to local heap */
     H5O_stab_t  stab;                /*symbol table message		*/
     H5G_bt_rm_t udata;               /*data to pass through B-tree	*/
     herr_t      ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     assert(loc && loc->file);
     assert(name && *name);
 
     /* Read in symbol table message */
     if (NULL == H5O_msg_read(loc, H5O_STAB_ID, &stab))
         HGOTO_ERROR(H5E_SYM, H5E_BADMESG, FAIL, "not a symbol table");
 
     /* Pin the heap down in memory */
     if (NULL == (heap = H5HL_protect(loc->file, stab.heap_addr, H5AC__NO_FLAGS_SET)))
         HGOTO_ERROR(H5E_SYM, H5E_PROTECT, FAIL, "unable to protect symbol table heap");
 
     /* Initialize data to pass through B-tree */
-    udata.common.name     = name;
-    udata.common.heap     = heap;
-    udata.grp_full_path_r = grp_full_path_r;
+    udata.common.name       = name;
+    udata.common.heap       = heap;
+    udata.common.block_size = H5HL_heap_get_size(heap);
+    udata.grp_full_path_r   = grp_full_path_r;
 
     /* Remove from symbol table */
     if (H5B_remove(loc->file, H5B_SNODE, stab.btree_addr, &udata) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "unable to remove entry");
@@ -361,35 +358,36 @@ herr_t
 H5G__stab_remove_by_idx(const H5O_loc_t *grp_oloc, H5RS_str_t *grp_full_path_r, H5_iter_order_t order,
                         hsize_t n)
 {
     H5HL_t     *heap = NULL;          /* Pointer to local heap */
     H5O_stab_t  stab;                 /* Symbol table message		*/
     H5G_bt_rm_t udata;                /* Data to pass through B-tree	*/
     H5O_link_t  obj_lnk;              /* Object's link within group */
     bool        lnk_copied = false;   /* Whether the link was copied */
     herr_t      ret_value  = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     assert(grp_oloc && grp_oloc->file);
 
     /* Look up name of link to remove, by index */
     if (H5G__stab_lookup_by_idx(grp_oloc, order, n, &obj_lnk) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "can't get link information");
     lnk_copied = true;
 
     /* Read in symbol table message */
     if (NULL == H5O_msg_read(grp_oloc, H5O_STAB_ID, &stab))
         HGOTO_ERROR(H5E_SYM, H5E_BADMESG, FAIL, "not a symbol table");
 
     /* Pin the heap down in memory */
     if (NULL == (heap = H5HL_protect(grp_oloc->file, stab.heap_addr, H5AC__NO_FLAGS_SET)))
         HGOTO_ERROR(H5E_SYM, H5E_PROTECT, FAIL, "unable to protect symbol table heap");
 
     /* Initialize data to pass through B-tree */
-    udata.common.name     = obj_lnk.name;
-    udata.common.heap     = heap;
-    udata.grp_full_path_r = grp_full_path_r;
+    udata.common.name       = obj_lnk.name;
+    udata.common.heap       = heap;
+    udata.common.block_size = H5HL_heap_get_size(heap);
+    udata.grp_full_path_r   = grp_full_path_r;
 
     /* Remove link from symbol table */
     if (H5B_remove(grp_oloc->file, H5B_SNODE, stab.btree_addr, &udata) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "unable to remove entry");
@@ -638,23 +636,27 @@ static herr_t
 H5G__stab_get_name_by_idx_cb(const H5G_entry_t *ent, void *_udata)
 {
     H5G_bt_it_gnbi_t *udata = (H5G_bt_it_gnbi_t *)_udata;
     size_t            name_off;            /* Offset of name in heap */
     const char       *name;                /* Pointer to name string in heap */
+    size_t            block_size;          /* Size of the heap block */
     herr_t            ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Sanity check */
     assert(ent);
     assert(udata && udata->heap);
 
+    /* Get the size of the heap block */
+    block_size = H5HL_heap_get_size(udata->heap);
+
     /* Get name offset in heap */
     name_off = ent->name_off;
 
     if ((name = (const char *)H5HL_offset_into(udata->heap, name_off)) == NULL)
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get symbol table link name");
 
-    if ((udata->name = H5MM_strdup(name)) == NULL)
+    if (NULL == (udata->name = H5MM_strndup(name, (block_size - name_off))))
         HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to duplicate symbol table link name");
 
 done:
@@ -761,14 +763,14 @@ static herr_t
 H5G__stab_lookup_cb(const H5G_entry_t *ent, void *_udata)
 {
     H5G_stab_fnd_ud_t *udata     = (H5G_stab_fnd_ud_t *)_udata; /* 'User data' passed in */
     herr_t             ret_value = SUCCEED;                     /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Check for setting link info */
     if (udata->lnk)
         /* Convert the entry to a link */
-        if (H5G__ent_to_link(udata->lnk, udata->heap, ent, udata->name) < 0)
+        if (H5G__ent_to_link(ent, udata->heap, udata->lnk) < 0)
             HGOTO_ERROR(H5E_SYM, H5E_CANTCONVERT, FAIL, "unable to convert symbol table entry to link");
 
 done:
@@ -788,38 +790,39 @@ herr_t
 H5G__stab_lookup(const H5O_loc_t *grp_oloc, const char *name, bool *found, H5O_link_t *lnk)
 {
     H5HL_t           *heap = NULL;         /* Pointer to local heap */
     H5G_bt_lkp_t      bt_udata;            /* Data to pass through B-tree	*/
     H5G_stab_fnd_ud_t udata;               /* 'User data' to give to callback */
     H5O_stab_t        stab;                /* Symbol table message		*/
     herr_t            ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check arguments */
     assert(grp_oloc && grp_oloc->file);
     assert(name && *name);
     assert(found);
     assert(lnk);
 
     /* Retrieve the symbol table message for the group */
     if (NULL == H5O_msg_read(grp_oloc, H5O_STAB_ID, &stab))
         HGOTO_ERROR(H5E_SYM, H5E_BADMESG, FAIL, "can't read message");
 
     /* Pin the heap down in memory */
     if (NULL == (heap = H5HL_protect(grp_oloc->file, stab.heap_addr, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_SYM, H5E_PROTECT, FAIL, "unable to protect symbol table heap");
 
     /* Set up user data to pass to 'find' operation callback */
     udata.name = name;
     udata.lnk  = lnk;
     udata.heap = heap;
 
     /* Set up the user data for actual B-tree find operation */
-    bt_udata.common.name = name;
-    bt_udata.common.heap = heap;
-    bt_udata.op          = H5G__stab_lookup_cb;
-    bt_udata.op_data     = &udata;
+    bt_udata.common.name       = name;
+    bt_udata.common.heap       = heap;
+    bt_udata.common.block_size = H5HL_heap_get_size(heap);
+    bt_udata.op                = H5G__stab_lookup_cb;
+    bt_udata.op_data           = &udata;
 
     /* Search the B-tree */
     if (H5B_find(grp_oloc->file, H5B_SNODE, stab.btree_addr, found, &bt_udata) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_NOTFOUND, FAIL, "not found");
@@ -846,22 +849,17 @@ done:
 static herr_t
 H5G__stab_lookup_by_idx_cb(const H5G_entry_t *ent, void *_udata)
 {
-    H5G_bt_it_lbi_t *udata = (H5G_bt_it_lbi_t *)_udata;
-    const char      *name;                /* Pointer to name string in heap */
+    H5G_bt_it_lbi_t *udata     = (H5G_bt_it_lbi_t *)_udata;
     herr_t           ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Sanity check */
     assert(ent);
     assert(udata && udata->heap);
 
-    /* Get a pointer to the link name */
-    if ((name = (const char *)H5HL_offset_into(udata->heap, ent->name_off)) == NULL)
-        HGOTO_ERROR(H5E_SYM, H5E_CANTGET, FAIL, "unable to get symbol table link name");
-
     /* Convert the entry to a link */
-    if (H5G__ent_to_link(udata->lnk, udata->heap, ent, name) < 0)
+    if (H5G__ent_to_link(ent, udata->heap, udata->lnk) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTCONVERT, FAIL, "unable to convert symbol table entry to link");
     udata->found = true;
 
diff --git a/src/H5Gtest.c b/src/H5Gtest.c
index a6a6406797..0b0708119e 100644
--- a/src/H5Gtest.c
+++ b/src/H5Gtest.c
@@ -795,41 +795,41 @@ herr_t
 H5G__verify_cached_stabs_test(hid_t gid)
 {
     H5G_t          *grp = NULL; /* Group */
     htri_t          stab_exists;
-    H5O_stab_t      stab;                     /* Symbol table message */
-    H5G_bt_common_t udata     = {NULL, NULL}; /* Dummy udata so H5B_iterate doesn't freak out */
-    haddr_t         prev_tag  = HADDR_UNDEF;  /* Previous metadata tag */
-    herr_t          ret_value = SUCCEED;      /* Return value */
+    H5O_stab_t      stab;                        /* Symbol table message */
+    H5G_bt_common_t udata     = {NULL, NULL, 0}; /* Dummy udata so H5B_iterate doesn't freak out */
+    haddr_t         prev_tag  = HADDR_UNDEF;     /* Previous metadata tag */
+    herr_t          ret_value = SUCCEED;         /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check args */
     assert(gid >= 0);
 
     /* Check args */
     if (NULL == (grp = (H5G_t *)H5VL_object_verify(gid, H5I_GROUP)))
         HGOTO_ERROR(H5E_ARGS, H5E_BADTYPE, FAIL, "not a group");
 
     /* Set up metadata tagging */
     H5AC_tag(grp->oloc.addr, &prev_tag);
 
     /* Check for group having a symbol table message */
     /* Check for the group having a group info message */
     if ((stab_exists = H5O_msg_exists(&(grp->oloc), H5O_STAB_ID)) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "unable to read object header");
 
     /* No need to check anything if the symbol table doesn't exist */
     if (!stab_exists)
         HGOTO_DONE(SUCCEED);
 
     /* Read the stab */
     if (NULL == H5O_msg_read(&(grp->oloc), H5O_STAB_ID, &stab))
         HGOTO_ERROR(H5E_SYM, H5E_BADMESG, FAIL, "can't get symbol table info");
 
     /* Iterate over the b-tree, checking validity of cached information */
     if ((ret_value = H5B_iterate(grp->oloc.file, H5B_SNODE, stab.btree_addr, H5G__verify_cached_stabs_test_cb,
                                  &udata)) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTNEXT, FAIL, "iteration operator failed");
 
     /* Reset metadata tagging */
     H5AC_tag(prev_tag, NULL);
diff --git a/src/H5HG.c b/src/H5HG.c
index 3709c70556..a859b40f10 100644
--- a/src/H5HG.c
+++ b/src/H5HG.c
@@ -545,47 +545,52 @@ void *
 H5HG_read(H5F_t *f, H5HG_t *hobj, void *object /*out*/, size_t *buf_size)
 {
     H5HG_heap_t *heap = NULL;          /* Pointer to global heap object */
     size_t       size;                 /* Size of the heap object */
     uint8_t     *p;                    /* Pointer to object in heap buffer */
     void        *orig_object = object; /* Keep a copy of the original object pointer */
     void        *ret_value   = NULL;   /* Return value */
 
     FUNC_ENTER_NOAPI_TAG(H5AC__GLOBALHEAP_TAG, NULL)
 
     /* Check args */
     assert(f);
     assert(hobj);
 
+    /* Heap object idx 0 is the free space in the heap and should never be given out */
+    if (0 == hobj->idx)
+        HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, NULL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
+                    hobj->addr, hobj->idx);
+
     /* Load the heap */
     if (NULL == (heap = H5HG__protect(f, hobj->addr, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_HEAP, H5E_CANTPROTECT, NULL, "unable to protect global heap");
     if (hobj->idx >= heap->nused)
         HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, NULL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
                     hobj->addr, hobj->idx);
     if (NULL == heap->obj[hobj->idx].begin)
         HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, NULL, "bad heap pointer, heap object = {%" PRIxHADDR ", %zu}",
                     hobj->addr, hobj->idx);
 
     size = heap->obj[hobj->idx].size;
     p    = heap->obj[hobj->idx].begin + H5HG_SIZEOF_OBJHDR(f);
 
     /* Allocate a buffer for the object read in, if the user didn't give one */
     if (!object && NULL == (object = H5MM_malloc(size)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed");
     H5MM_memcpy(object, p, size);
 
     /*
      * Advance the heap in the CWFS list. We might have done this already
      * with the H5AC_protect(), but it won't hurt to do it twice.
      */
     if (heap->obj[0].begin) {
         if (H5F_cwfs_advance_heap(f, heap, false) < 0)
             HGOTO_ERROR(H5E_HEAP, H5E_CANTMODIFY, NULL, "can't adjust file's CWFS");
     } /* end if */
 
     /* If the caller would like to know the heap object's size, set that */
     if (buf_size)
         *buf_size = size;
 
     /* Set return value */
     ret_value = object;
@@ -619,35 +624,40 @@ int
 H5HG_link(H5F_t *f, const H5HG_t *hobj, int adjust)
 {
     H5HG_heap_t *heap       = NULL;
     unsigned     heap_flags = H5AC__NO_FLAGS_SET;
     int          ret_value  = -1; /* Return value */
 
     FUNC_ENTER_NOAPI_TAG(H5AC__GLOBALHEAP_TAG, FAIL)
 
     /* Check args */
     assert(f);
     assert(hobj);
     if (0 == (H5F_INTENT(f) & H5F_ACC_RDWR))
         HGOTO_ERROR(H5E_HEAP, H5E_WRITEERROR, FAIL, "no write intent on file");
 
+    /* Heap object idx 0 is the free space in the heap and should never be given out */
+    if (0 == hobj->idx)
+        HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
+                    hobj->addr, hobj->idx);
+
     /* Load the heap */
     if (NULL == (heap = H5HG__protect(f, hobj->addr, H5AC__NO_FLAGS_SET)))
         HGOTO_ERROR(H5E_HEAP, H5E_CANTPROTECT, FAIL, "unable to protect global heap");
 
     if (adjust != 0) {
         if (hobj->idx >= heap->nused)
             HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
                         hobj->addr, hobj->idx);
         if (NULL == heap->obj[hobj->idx].begin)
             HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "bad heap pointer, heap object = {%" PRIxHADDR ", %zu}",
                         hobj->addr, hobj->idx);
         if ((heap->obj[hobj->idx].nrefs + adjust) < 0)
             HGOTO_ERROR(H5E_HEAP, H5E_BADRANGE, FAIL, "new link count would be out of range");
         if ((heap->obj[hobj->idx].nrefs + adjust) > H5HG_MAXLINK)
             HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "new link count would be out of range");
         heap->obj[hobj->idx].nrefs += adjust;
         heap_flags |= H5AC__DIRTIED_FLAG;
     } /* end if */
 
     /* Set return value */
     ret_value = heap->obj[hobj->idx].nrefs;
@@ -673,26 +683,31 @@ herr_t
 H5HG_get_obj_size(H5F_t *f, H5HG_t *hobj, size_t *obj_size)
 {
     H5HG_heap_t *heap      = NULL;    /* Pointer to global heap object */
     herr_t       ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_NOAPI_TAG(H5AC__GLOBALHEAP_TAG, FAIL)
 
     /* Check args */
     assert(f);
     assert(hobj);
     assert(obj_size);
 
+    /* Heap object idx 0 is the free space in the heap and should never be given out */
+    if (0 == hobj->idx)
+        HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
+                    hobj->addr, hobj->idx);
+
     /* Load the heap */
     if (NULL == (heap = H5HG__protect(f, hobj->addr, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_HEAP, H5E_CANTPROTECT, FAIL, "unable to protect global heap");
 
     /* Sanity check the heap object */
     if (hobj->idx >= heap->nused)
         HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
                     hobj->addr, hobj->idx);
     if (NULL == heap->obj[hobj->idx].begin)
         HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "bad heap pointer, heap object = {%" PRIxHADDR ", %zu}",
                     hobj->addr, hobj->idx);
 
     /* Set object size */
     *obj_size = heap->obj[hobj->idx].size;
@@ -717,82 +732,87 @@ herr_t
 H5HG_remove(H5F_t *f, H5HG_t *hobj)
 {
     H5HG_heap_t *heap = NULL;
     uint8_t     *p = NULL, *obj_start = NULL;
     size_t       need;
     unsigned     u;
     unsigned     flags     = H5AC__NO_FLAGS_SET; /* Whether the heap gets deleted */
     herr_t       ret_value = SUCCEED;            /* Return value */
 
     FUNC_ENTER_NOAPI_TAG(H5AC__GLOBALHEAP_TAG, FAIL)
 
     /* Check args */
     assert(f);
     assert(hobj);
     if (0 == (H5F_INTENT(f) & H5F_ACC_RDWR))
         HGOTO_ERROR(H5E_HEAP, H5E_WRITEERROR, FAIL, "no write intent on file");
 
+    /* Heap object idx 0 is the free space in the heap and should never be given out */
+    if (0 == hobj->idx)
+        HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
+                    hobj->addr, hobj->idx);
+
     /* Load the heap */
     if (NULL == (heap = H5HG__protect(f, hobj->addr, H5AC__NO_FLAGS_SET)))
         HGOTO_ERROR(H5E_HEAP, H5E_CANTPROTECT, FAIL, "unable to protect global heap");
 
     /* Sanity check the heap object (split around bugfix below) */
     if (hobj->idx >= heap->nused)
         HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "bad heap index, heap object = {%" PRIxHADDR ", %zu}",
                     hobj->addr, hobj->idx);
 
     /* When the application selects the same location to rewrite the VL element by using H5Sselect_elements,
      * it can happen that the entry has been removed by first rewrite.  Here we simply skip the removal of
      * the entry and let the second rewrite happen (see HDFFV-10635).  In the future, it'd be nice to handle
      * this situation in H5T_conv_vlen in H5Tconv.c instead of this level (HDFFV-10648). */
     if (heap->obj[hobj->idx].nrefs == 0 && heap->obj[hobj->idx].size == 0 && !heap->obj[hobj->idx].begin)
         HGOTO_DONE(SUCCEED);
 
     /* Finish sanity checking the heap object */
     if (NULL == heap->obj[hobj->idx].begin)
         HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "bad heap pointer, heap object = {%" PRIxHADDR ", %zu}",
                     hobj->addr, hobj->idx);
 
     obj_start = heap->obj[hobj->idx].begin;
     /* Include object header size */
     need = H5HG_ALIGN(heap->obj[hobj->idx].size) + H5HG_SIZEOF_OBJHDR(f);
 
     /* Move the new free space to the end of the heap */
     for (u = 0; u < heap->nused; u++)
         if (heap->obj[u].begin > heap->obj[hobj->idx].begin)
             heap->obj[u].begin -= need;
     if (NULL == heap->obj[0].begin) {
         heap->obj[0].begin = heap->chunk + (heap->size - need);
         heap->obj[0].size  = need;
         heap->obj[0].nrefs = 0;
     } /* end if */
     else
         heap->obj[0].size += need;
     memmove(obj_start, obj_start + need, heap->size - (size_t)((obj_start + need) - heap->chunk));
     if (heap->obj[0].size >= H5HG_SIZEOF_OBJHDR(f)) {
         p = heap->obj[0].begin;
         UINT16ENCODE(p, 0); /*id*/
         UINT16ENCODE(p, 0); /*nrefs*/
         UINT32ENCODE(p, 0); /*reserved*/
         H5F_ENCODE_LENGTH(f, p, heap->obj[0].size);
     } /* end if */
     memset(heap->obj + hobj->idx, 0, sizeof(H5HG_obj_t));
     flags |= H5AC__DIRTIED_FLAG;
 
     if ((heap->obj[0].size + H5HG_SIZEOF_HDR(f)) == heap->size) {
         /*
          * The collection is empty. Remove it from the CWFS list and return it
          * to the file free list.
          */
         flags |=
             H5AC__DELETED_FLAG |
             H5AC__FREE_FILE_SPACE_FLAG; /* Indicate that the object was deleted, for the unprotect call */
     }                                   /* end if */
     else {
         /*
          * If the heap is in the CWFS list then advance it one position.  The
          * H5AC_protect() might have done that too, but that's okay.  If the
          * heap isn't on the CWFS list then add it to the end.
          */
         if (H5F_cwfs_advance_heap(f, heap, true) < 0)
             HGOTO_ERROR(H5E_HEAP, H5E_CANTMODIFY, FAIL, "can't adjust file's CWFS");
     } /* end else */
diff --git a/src/H5HL.c b/src/H5HL.c
index 680ef0a15d..f6e589b016 100644
--- a/src/H5HL.c
+++ b/src/H5HL.c
@@ -295,80 +295,84 @@ done:
 H5HL_t *
 H5HL_protect(H5F_t *f, haddr_t addr, unsigned flags)
 {
-    H5HL_cache_prfx_ud_t prfx_udata;                /* User data for protecting local heap prefix       */
-    H5HL_prfx_t         *prfx = NULL;               /* Local heap prefix                                */
-    H5HL_dblk_t         *dblk = NULL;               /* Local heap data block                            */
-    H5HL_t              *heap = NULL;               /* Heap data structure                              */
-    unsigned prfx_cache_flags = H5AC__NO_FLAGS_SET; /* Cache flags for unprotecting prefix entry        */
-    unsigned dblk_cache_flags = H5AC__NO_FLAGS_SET; /* Cache flags for unprotecting data block entry    */
-    H5HL_t  *ret_value        = NULL;
+    H5HL_cache_prfx_ud_t prfx_udata;       /* User data for protecting local heap prefix       */
+    H5HL_prfx_t         *prfx      = NULL; /* Local heap prefix                                */
+    H5HL_dblk_t         *dblk      = NULL; /* Local heap data block                            */
+    H5HL_t              *heap      = NULL; /* Heap data structure                              */
+    H5HL_t              *ret_value = NULL;
 
     FUNC_ENTER_NOAPI(NULL)
 
     /* Check arguments */
     assert(f);
     assert(H5_addr_defined(addr));
 
     /* Only the H5AC__READ_ONLY_FLAG may appear in flags */
     assert((flags & (unsigned)(~H5AC__READ_ONLY_FLAG)) == 0);
 
     /* Construct the user data for protect callback */
     prfx_udata.sizeof_size = H5F_SIZEOF_SIZE(f);
     prfx_udata.sizeof_addr = H5F_SIZEOF_ADDR(f);
     prfx_udata.prfx_addr   = addr;
     prfx_udata.sizeof_prfx = H5HL_SIZEOF_HDR(f);
 
     /* Protect the local heap prefix */
     if (NULL == (prfx = (H5HL_prfx_t *)H5AC_protect(f, H5AC_LHEAP_PRFX, addr, &prfx_udata, flags)))
         HGOTO_ERROR(H5E_HEAP, H5E_CANTPROTECT, NULL, "unable to load heap prefix");
 
     /* Get the pointer to the heap */
     heap = prfx->heap;
 
     /* Check if the heap is already pinned in memory */
     /* (for re-entrant situation) */
     if (heap->prots == 0) {
+        void *pin_obj; /* Pointer to local heap object to pin */
+
         /* Check if heap has separate data block */
         if (heap->single_cache_obj)
-            /* Set the flag for pinning the prefix when unprotecting it */
-            prfx_cache_flags |= H5AC__PIN_ENTRY_FLAG;
+            /* Pin prefix */
+            pin_obj = prfx;
         else {
             /* Protect the local heap data block */
             if (NULL ==
                 (dblk = (H5HL_dblk_t *)H5AC_protect(f, H5AC_LHEAP_DBLK, heap->dblk_addr, heap, flags)))
                 HGOTO_ERROR(H5E_HEAP, H5E_CANTPROTECT, NULL, "unable to load heap data block");
 
-            /* Set the flag for pinning the data block when unprotecting it */
-            dblk_cache_flags |= H5AC__PIN_ENTRY_FLAG;
+            /* Pin data block */
+            pin_obj = dblk;
         }
+
+        /* Pin local heap object */
+        if (H5AC_pin_protected_entry(pin_obj) < 0)
+            HGOTO_ERROR(H5E_HEAP, H5E_CANTPIN, NULL, "unable to pin local heap object");
     }
 
     /* Increment # of times heap is protected */
     heap->prots++;
 
     /* Set return value */
     ret_value = heap;
 
 done:
     /* Release the prefix from the cache, now pinned */
-    if (prfx && heap && H5AC_unprotect(f, H5AC_LHEAP_PRFX, heap->prfx_addr, prfx, prfx_cache_flags) < 0)
+    if (prfx && heap && H5AC_unprotect(f, H5AC_LHEAP_PRFX, heap->prfx_addr, prfx, H5AC__NO_FLAGS_SET) < 0)
         HDONE_ERROR(H5E_HEAP, H5E_CANTUNPROTECT, NULL, "unable to release local heap prefix");
 
     /* Release the data block from the cache, now pinned */
-    if (dblk && heap && H5AC_unprotect(f, H5AC_LHEAP_DBLK, heap->dblk_addr, dblk, dblk_cache_flags) < 0)
+    if (dblk && heap && H5AC_unprotect(f, H5AC_LHEAP_DBLK, heap->dblk_addr, dblk, H5AC__NO_FLAGS_SET) < 0)
         HDONE_ERROR(H5E_HEAP, H5E_CANTUNPROTECT, NULL, "unable to release local heap data block");
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5HL_protect() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5HL_offset_into
  *
  * Purpose:     Called directly after the call to H5HL_protect so that
  *              a pointer to the object in the heap can be obtained.
  *
  * Return:      Success:    Valid pointer
  *              Failure:    NULL
  *
  *-------------------------------------------------------------------------
  */
@@ -879,21 +883,41 @@ H5HL_delete(H5F_t *f, haddr_t addr)
 done:
     /* Release the data block from the cache, now deleted */
     if (dblk && heap && H5AC_unprotect(f, H5AC_LHEAP_DBLK, heap->dblk_addr, dblk, cache_flags) < 0)
         HDONE_ERROR(H5E_HEAP, H5E_CANTUNPROTECT, FAIL, "unable to release local heap data block");
 
     /* Release the prefix from the cache, now deleted */
     if (prfx && heap && H5AC_unprotect(f, H5AC_LHEAP_PRFX, heap->prfx_addr, prfx, cache_flags) < 0)
         HDONE_ERROR(H5E_HEAP, H5E_CANTUNPROTECT, FAIL, "unable to release local heap prefix");
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5HL_delete() */
 
+/*-------------------------------------------------------------------------
+ * Function:    H5HL_heap_get_size
+ *
+ * Purpose:     Retrieves the current size of a heap's block
+ *
+ * Return:      SUCCEED/FAIL
+ *
+ *-------------------------------------------------------------------------
+ */
+size_t
+H5HL_heap_get_size(const H5HL_t *heap)
+{
+    FUNC_ENTER_NOAPI_NOINIT_NOERR
+
+    /* Check arguments */
+    assert(heap);
+
+    FUNC_LEAVE_NOAPI(heap->dblk_size)
+} /* end H5HL_heap_get_size() */
+
 /*-------------------------------------------------------------------------
  * Function:    H5HL_get_size
  *
  * Purpose:     Retrieves the current size of a heap
  *
  * Return:      SUCCEED/FAIL
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5HLcache.c b/src/H5HLcache.c
index b38ff7c284..d0836fed4f 100644
--- a/src/H5HLcache.c
+++ b/src/H5HLcache.c
@@ -217,47 +217,47 @@ static herr_t
 H5HL__fl_deserialize(H5HL_t *heap)
 {
     H5HL_free_t *fl = NULL, *tail = NULL; /* Heap free block nodes */
     hsize_t      free_block;              /* Offset of free block */
     herr_t       ret_value = SUCCEED;     /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check arguments */
     assert(heap);
     assert(!heap->freelist);
 
     /* Build free list */
     free_block = heap->free_block;
     while (H5HL_FREE_NULL != free_block) {
         const uint8_t *image; /* Pointer into image buffer */
 
         /* Sanity check */
-        if (free_block >= heap->dblk_size)
+        if ((free_block + (2 * heap->sizeof_size)) > heap->dblk_size)
             HGOTO_ERROR(H5E_HEAP, H5E_BADRANGE, FAIL, "bad heap free list");
 
         /* Allocate & initialize free list node */
         if (NULL == (fl = H5FL_MALLOC(H5HL_free_t)))
             HGOTO_ERROR(H5E_HEAP, H5E_CANTALLOC, FAIL, "memory allocation failed");
         fl->offset = (size_t)free_block;
         fl->prev   = tail;
         fl->next   = NULL;
 
         /* Decode offset of next free block */
         image = heap->dblk_image + free_block;
         H5_DECODE_LENGTH_LEN(image, free_block, heap->sizeof_size);
         if (0 == free_block)
             HGOTO_ERROR(H5E_HEAP, H5E_BADVALUE, FAIL, "free block size is zero?");
 
         /* Decode length of this free block */
         H5_DECODE_LENGTH_LEN(image, fl->size, heap->sizeof_size);
         if ((fl->offset + fl->size) > heap->dblk_size)
             HGOTO_ERROR(H5E_HEAP, H5E_BADRANGE, FAIL, "bad heap free list");
 
         /* Append node onto list */
         if (tail)
             tail->next = fl;
         else
             heap->freelist = fl;
         tail = fl;
         fl   = NULL;
     }
diff --git a/src/H5HLprivate.h b/src/H5HLprivate.h
index 243d7653a8..045c5d7ac1 100644
--- a/src/H5HLprivate.h
+++ b/src/H5HLprivate.h
@@ -44,6 +44,7 @@ typedef struct H5HL_t H5HL_t;
  */
 H5_DLL herr_t  H5HL_create(H5F_t *f, size_t size_hint, haddr_t *addr /*out*/);
 H5_DLL herr_t  H5HL_delete(H5F_t *f, haddr_t addr);
+H5_DLL size_t  H5HL_heap_get_size(const H5HL_t *heap);
 H5_DLL herr_t  H5HL_get_size(H5F_t *f, haddr_t addr, size_t *size);
 H5_DLL herr_t  H5HL_heapsize(H5F_t *f, haddr_t addr, hsize_t *heap_size);
 H5_DLL herr_t  H5HL_insert(H5F_t *f, H5HL_t *heap, size_t size, const void *buf, size_t *offset);
diff --git a/src/H5Lint.c b/src/H5Lint.c
index d02e8c48a4..10b935ab09 100644
--- a/src/H5Lint.c
+++ b/src/H5Lint.c
@@ -508,112 +508,112 @@ static herr_t
 H5L__link_cb(H5G_loc_t *grp_loc /*in*/, const char *name, const H5O_link_t H5_ATTR_UNUSED *lnk,
              H5G_loc_t *obj_loc, void *_udata /*in,out*/, H5G_own_loc_t *own_loc /*out*/)
 {
     H5L_trav_cr_t *udata  = (H5L_trav_cr_t *)_udata; /* User data passed in */
     H5G_t         *grp    = NULL;   /* H5G_t for this group, opened to pass to user callback */
     hid_t          grp_id = FAIL;   /* Id for this group (passed to user callback */
     H5G_loc_t      temp_loc;        /* For UD callback */
     bool   temp_loc_init = false;   /* Temporary location for UD callback (temp_loc) has been initialized */
     bool   obj_created   = false;   /* Whether an object was created (through a hard link) */
     herr_t ret_value     = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Check if the name in this group resolved to a valid location */
     /* (which is not what we want) */
     if (obj_loc != NULL)
         HGOTO_ERROR(H5E_LINK, H5E_EXISTS, FAIL, "name already exists");
 
     /* Check for crossing file boundaries with a new hard link */
     if (udata->lnk->type == H5L_TYPE_HARD) {
         /* Check for creating an object */
         /* (only for hard links) */
         if (udata->ocrt_info) {
             H5G_loc_t new_loc; /* Group location for new object */
 
             /* Create new object at this location */
             if (NULL ==
                 (udata->ocrt_info->new_obj = H5O_obj_create(grp_loc->oloc->file, udata->ocrt_info->obj_type,
                                                             udata->ocrt_info->crt_info, &new_loc)))
                 HGOTO_ERROR(H5E_LINK, H5E_CANTINIT, FAIL, "unable to create object");
 
             /* Set address for hard link */
             udata->lnk->u.hard.addr = new_loc.oloc->addr;
 
             /* Set object path to use for setting object name (below) */
             udata->path = new_loc.path;
 
             /* Indicate that an object was created */
             obj_created = true;
         } /* end if */
         else {
             /* Check that both objects are in same file */
             if (!H5F_SAME_SHARED(grp_loc->oloc->file, udata->file))
                 HGOTO_ERROR(H5E_LINK, H5E_BADVALUE, FAIL, "interfile hard links are not allowed");
         } /* end else */
     }     /* end if */
 
     /* Set 'standard' aspects of link */
     udata->lnk->corder =
         0; /* Will be re-written during group insertion, if the group is tracking creation order */
     udata->lnk->corder_valid = false; /* Creation order not valid (yet) */
 
     /* Check for non-default link creation properties */
     if (udata->lc_plist) {
         /* Get character encoding property */
         if (H5CX_get_encoding(&udata->lnk->cset) < 0)
             HGOTO_ERROR(H5E_LINK, H5E_CANTGET, FAIL, "can't get 'character set' property");
     } /* end if */
     else
         udata->lnk->cset = H5F_DEFAULT_CSET; /* Default character encoding for link */
 
     /* Set the link's name correctly */
     H5_GCC_CLANG_DIAG_OFF("cast-qual")
     udata->lnk->name = (char *)name;
     H5_GCC_CLANG_DIAG_ON("cast-qual")
 
     /* Insert link into group */
-    if (H5G_obj_insert(grp_loc->oloc, name, udata->lnk, true,
+    if (H5G_obj_insert(grp_loc->oloc, udata->lnk, true,
                        udata->ocrt_info ? udata->ocrt_info->obj_type : H5O_TYPE_UNKNOWN,
                        udata->ocrt_info ? udata->ocrt_info->crt_info : NULL) < 0)
         HGOTO_ERROR(H5E_LINK, H5E_CANTINIT, FAIL, "unable to create new link for object");
 
     /* Set object's path if it has been passed in and is not set */
     if (udata->path != NULL && udata->path->user_path_r == NULL)
         if (H5G_name_set(grp_loc->path, udata->path, name) < 0)
             HGOTO_ERROR(H5E_LINK, H5E_CANTINIT, FAIL, "cannot set name");
 
     /* If link is a user-defined link, trigger its creation callback if it has one */
     if (udata->lnk->type >= H5L_TYPE_UD_MIN) {
         const H5L_class_t *link_class; /* User-defined link class */
 
         /* Get the link class for this type of link. */
         if (NULL == (link_class = H5L_find_class(udata->lnk->type)))
             HGOTO_ERROR(H5E_LINK, H5E_NOTREGISTERED, FAIL, "unable to get class of UD link");
 
         if (link_class->create_func != NULL) {
             H5O_loc_t  temp_oloc;
             H5G_name_t temp_path;
 
             /* Create a temporary location (or else H5G_open will do a shallow
              * copy and wipe out grp_loc)
              */
             H5G_name_reset(&temp_path);
             if (H5O_loc_copy_deep(&temp_oloc, grp_loc->oloc) < 0)
                 HGOTO_ERROR(H5E_LINK, H5E_CANTCOPY, FAIL, "unable to copy object location");
 
             temp_loc.oloc = &temp_oloc;
             temp_loc.path = &temp_path;
             temp_loc_init = true;
 
             /* Set up location for user-defined callback */
             if (NULL == (grp = H5G_open(&temp_loc)))
                 HGOTO_ERROR(H5E_LINK, H5E_CANTOPENOBJ, FAIL, "unable to open group");
             if ((grp_id = H5VL_wrap_register(H5I_GROUP, grp, true)) < 0)
                 HGOTO_ERROR(H5E_LINK, H5E_CANTREGISTER, FAIL, "unable to register ID for group");
 
             /* Make callback */
             if ((link_class->create_func)(name, grp_id, udata->lnk->u.ud.udata, udata->lnk->u.ud.size,
                                           H5P_DEFAULT) < 0)
                 HGOTO_ERROR(H5E_LINK, H5E_CALLBACK, FAIL, "link creation callback failed");
         } /* end if */
     }     /* end if */
@@ -1289,73 +1289,73 @@ static herr_t
 H5L__move_dest_cb(H5G_loc_t *grp_loc /*in*/, const char *name, const H5O_link_t H5_ATTR_UNUSED *lnk,
                   H5G_loc_t *obj_loc, void *_udata /*in,out*/, H5G_own_loc_t *own_loc /*out*/)
 {
     H5L_trav_mv2_t *udata  = (H5L_trav_mv2_t *)_udata; /* User data passed in */
     H5G_t          *grp    = NULL; /* H5G_t for this group, opened to pass to user callback */
     hid_t           grp_id = FAIL; /* ID for this group (passed to user callback */
     H5G_loc_t       temp_loc;      /* For UD callback */
     bool            temp_loc_init = false;
     herr_t          ret_value     = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Make sure an object with this name doesn't already exist */
     if (obj_loc != NULL)
         HGOTO_ERROR(H5E_LINK, H5E_NOTFOUND, FAIL, "an object with that name already exists");
 
     /* Check for crossing file boundaries with a new hard link */
     if (udata->lnk->type == H5L_TYPE_HARD)
         /* Check that both objects are in same file */
         if (!H5F_SAME_SHARED(grp_loc->oloc->file, udata->file))
             HGOTO_ERROR(H5E_LINK, H5E_CANTINIT, FAIL, "moving a link across files is not allowed");
 
     /* Give the object its new name */
     assert(udata->lnk->name == NULL);
     H5_GCC_CLANG_DIAG_OFF("cast-qual")
     udata->lnk->name = (char *)name;
     H5_GCC_CLANG_DIAG_ON("cast-qual")
 
     /* Insert the link into the group */
-    if (H5G_obj_insert(grp_loc->oloc, name, udata->lnk, true, H5O_TYPE_UNKNOWN, NULL) < 0)
+    if (H5G_obj_insert(grp_loc->oloc, udata->lnk, true, H5O_TYPE_UNKNOWN, NULL) < 0)
         HGOTO_ERROR(H5E_LINK, H5E_CANTINIT, FAIL, "unable to create new link to object");
 
     /* If the link was a user-defined link, call its move callback if it has one */
     if (udata->lnk->type >= H5L_TYPE_UD_MIN) {
         const H5L_class_t *link_class; /* User-defined link class */
 
         /* Get the link class for this type of link. */
         if (NULL == (link_class = H5L_find_class(udata->lnk->type)))
             HGOTO_ERROR(H5E_LINK, H5E_NOTREGISTERED, FAIL, "link class is not registered");
 
         if ((!udata->copy && link_class->move_func) || (udata->copy && link_class->copy_func)) {
             H5O_loc_t  temp_oloc;
             H5G_name_t temp_path;
 
             /* Create a temporary location (or else H5G_open will do a shallow
              * copy and wipe out grp_loc)
              */
             H5G_name_reset(&temp_path);
             if (H5O_loc_copy_deep(&temp_oloc, grp_loc->oloc) < 0)
                 HGOTO_ERROR(H5E_LINK, H5E_CANTCOPY, FAIL, "unable to copy object location");
 
             temp_loc.oloc = &temp_oloc;
             temp_loc.path = &temp_path;
             temp_loc_init = true;
 
             /* Set up location for user-defined callback */
             if (NULL == (grp = H5G_open(&temp_loc)))
                 HGOTO_ERROR(H5E_LINK, H5E_CANTOPENOBJ, FAIL, "unable to open group");
             if ((grp_id = H5VL_wrap_register(H5I_GROUP, grp, true)) < 0)
                 HGOTO_ERROR(H5E_LINK, H5E_CANTREGISTER, FAIL, "unable to register group ID");
 
             if (udata->copy) {
                 if ((link_class->copy_func)(udata->lnk->name, grp_id, udata->lnk->u.ud.udata,
                                             udata->lnk->u.ud.size) < 0)
                     HGOTO_ERROR(H5E_LINK, H5E_CALLBACK, FAIL, "UD copy callback returned error");
             } /* end if */
             else {
                 if ((link_class->move_func)(udata->lnk->name, grp_id, udata->lnk->u.ud.udata,
                                             udata->lnk->u.ud.size) < 0)
                     HGOTO_ERROR(H5E_LINK, H5E_CALLBACK, FAIL, "UD move callback returned error");
             } /* end else */
         }     /* end if */
     }         /* end if */
diff --git a/src/H5Ocache.c b/src/H5Ocache.c
index 53a7d0a7cf..6916a9044c 100644
--- a/src/H5Ocache.c
+++ b/src/H5Ocache.c
@@ -264,53 +264,57 @@ static void *
 H5O__cache_deserialize(const void *image, size_t len, void *_udata, bool *dirty)
 {
     H5O_t          *oh        = NULL;                     /* Object header read in */
     H5O_cache_ud_t *udata     = (H5O_cache_ud_t *)_udata; /* User data for callback */
     void           *ret_value = NULL;
 
     FUNC_ENTER_PACKAGE
 
     assert(image);
     assert(len > 0);
     assert(udata);
     assert(udata->common.f);
     assert(udata->common.cont_msg_info);
     assert(dirty);
 
     /* Check for partially deserialized object header
      *
      * The Object header prefix will be deserialized if the object header came
      * through the 'get_final_load_size' callback and not deserialized if
      * the object header is coming from a cache image.
      */
     if (NULL == udata->oh) {
         /* Deserialize the object header prefix */
         if (H5O__prefix_deserialize((const uint8_t *)image, len, udata) < 0)
             HGOTO_ERROR(H5E_OHDR, H5E_CANTDECODE, NULL, "can't deserialize object header prefix");
         assert(udata->oh);
     }
 
     /* Retrieve partially deserialized object header from user data */
     oh = udata->oh;
 
     /* Set SWMR flag, if appropriate */
     oh->swmr_write = !!(H5F_INTENT(udata->common.f) & H5F_ACC_SWMR_WRITE);
 
     /* Create object header proxy if doing SWMR writes */
     if (oh->swmr_write) {
         /* Create virtual entry, for use as proxy */
         if (NULL == (oh->proxy = H5AC_proxy_entry_create()))
             HGOTO_ERROR(H5E_OHDR, H5E_CANTCREATE, NULL, "can't create object header proxy");
     }
     else
         oh->proxy = NULL;
 
     /* Parse the first chunk */
     if (H5O__chunk_deserialize(oh, udata->common.addr, udata->chunk0_size, (const uint8_t *)image, len,
                                &(udata->common), dirty) < 0)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTINIT, NULL, "can't deserialize first object header chunk");
 
+    /* Check for corruption in object header # of messages */
+    if (oh->version == H5O_VERSION_1 && udata->v1_pfx_nmesgs < oh->nmesgs)
+        HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, NULL, "bad object header message count");
+
     /* Note that we've loaded the object header from the file */
     udata->made_attempt = true;
 
     /* Set return value */
     ret_value = oh;
diff --git a/src/H5Ocopy.c b/src/H5Ocopy.c
index f2f307e82d..d600204626 100644
--- a/src/H5Ocopy.c
+++ b/src/H5Ocopy.c
@@ -192,566 +192,572 @@ static herr_t
 H5O__copy_header_real(const H5O_loc_t *oloc_src, H5O_loc_t *oloc_dst /*out*/, H5O_copy_t *cpy_info,
                       H5O_type_t *obj_type, void **udata /*out*/)
 {
     H5O_addr_map_t *addr_map = NULL; /* Address mapping of object copied */
     H5O_t          *oh_src   = NULL; /* Object header for source object */
     H5O_t          *oh_dst   = NULL; /* Object header for destination object */
     unsigned        mesgno   = 0;
     haddr_t         addr_new = HADDR_UNDEF;
     bool           *deleted  = NULL; /* Array of flags indicating whether messages should be copied */
     bool        inserted = false; /* Whether the destination object header has been inserted into the cache */
     size_t      null_msgs;        /* Number of NULL messages found in each loop */
     size_t      orig_dst_msgs;    /* Original # of messages in dest. object */
     H5O_mesg_t *mesg_src;         /* Message in source object header */
     H5O_mesg_t *mesg_dst;         /* Message in destination object header */
     const H5O_msg_class_t *copy_type;        /* Type of message to use for copying */
     const H5O_obj_class_t *obj_class = NULL; /* Type of object we are copying */
     void                  *cpy_udata = NULL; /* User data for passing to message callbacks */
     uint64_t               dst_oh_size;      /* Total size of the destination OH */
     size_t                 dst_oh_null;      /* Size of the null message to add to destination OH */
     size_t                 dst_oh_gap;       /* Size of the gap in chunk #0 of destination OH */
     uint8_t               *current_pos;      /* Current position in destination image */
     size_t                 msghdr_size;
     herr_t                 ret_value = SUCCEED;
 
     FUNC_ENTER_PACKAGE_TAG(oloc_src->addr)
 
     assert(oloc_src);
     assert(oloc_src->file);
     assert(H5_addr_defined(oloc_src->addr));
     assert(oloc_dst->file);
     assert(cpy_info);
 
     /* Get pointer to object class for this object */
     if (NULL == (obj_class = H5O__obj_class(oloc_src)))
         HGOTO_ERROR(H5E_OHDR, H5E_CANTINIT, FAIL, "unable to determine object type");
 
     /* Set the pointer to the shared struct for the object if opened in the file */
     cpy_info->shared_fo = H5FO_opened(oloc_src->file, oloc_src->addr);
 
     /* Get source object header */
     if (NULL == (oh_src = H5O_protect(oloc_src, H5AC__READ_ONLY_FLAG, false)))
         HGOTO_ERROR(H5E_OHDR, H5E_CANTPROTECT, FAIL, "unable to load object header");
 
     /* Retrieve user data for particular type of object to copy */
     if (obj_class->get_copy_file_udata && (NULL == (cpy_udata = (obj_class->get_copy_file_udata)())))
         HGOTO_ERROR(H5E_OHDR, H5E_CANTINIT, FAIL, "unable to retrieve copy user data");
 
     /* If we are merging committed datatypes, check for a match in the destination
      * file now */
     if (cpy_info->merge_comm_dt && obj_class->type == H5O_TYPE_NAMED_DATATYPE) {
         unsigned long fileno_src; /* fileno for source file */
         unsigned long fileno_dst; /* fileno for destination file */
         htri_t        merge;      /* Whether we found a match in the destination file */
 
         /* Check if the source and dest file are the same.  If so, just return
          * the source object address */
         H5F_GET_FILENO(oloc_src->file, fileno_src);
         H5F_GET_FILENO(oloc_dst->file, fileno_dst);
         if (fileno_src == fileno_dst) {
             merge          = true;
             oloc_dst->addr = oloc_src->addr;
         } /* end if */
         else
             /* Search for a matching committed datatype, building the list if
              * necessary */
             if ((merge = H5O__copy_search_comm_dt(oloc_src->file, oh_src, oloc_dst, cpy_info)) < 0)
                 HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, FAIL, "can't search for matching committed datatype");
 
         if (merge) {
             /* Found a match, add to skip list and exit */
             /* Allocate space for the address mapping of the object copied */
             if (NULL == (addr_map = H5FL_MALLOC(H5O_addr_map_t)))
                 HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
 
             /* Insert the address mapping for the found object into the copied
              * list */
             addr_map->src_obj_pos.fileno = fileno_src;
             addr_map->src_obj_pos.addr   = oloc_src->addr;
             addr_map->dst_addr           = oloc_dst->addr;
             addr_map->is_locked          = true; /* We've locked the object currently */
             addr_map->inc_ref_count      = 0;    /* Start with no additional ref counts to add */
             addr_map->obj_class          = obj_class;
             addr_map->udata              = cpy_udata;
 
             /* Insert into skip list */
             if (H5SL_insert(cpy_info->map_list, addr_map, &(addr_map->src_obj_pos)) < 0) {
                 addr_map = H5FL_FREE(H5O_addr_map_t, addr_map);
                 HGOTO_ERROR(H5E_OHDR, H5E_CANTINSERT, FAIL, "can't insert object into skip list");
             } /* end if */
 
             HGOTO_DONE(SUCCEED);
         } /* end if */
     }     /* end if */
 
     /* Flush any dirty messages in source object header to update the header chunks */
     if (H5O__flush_msgs(oloc_src->file, oh_src) < 0)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTFLUSH, FAIL, "unable to flush object header messages");
 
     /* Allocate the destination object header and fill in header fields */
     if (NULL == (oh_dst = H5FL_CALLOC(H5O_t)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
 
     /* Initialize header information */
     oh_dst->version = oh_src->version;
 
     /* Version bounds check for destination object header */
     if (oh_dst->version > H5O_obj_ver_bounds[H5F_HIGH_BOUND(oloc_dst->file)])
         HGOTO_ERROR(H5E_OHDR, H5E_BADRANGE, FAIL, "destination object header version out of bounds");
 
     oh_dst->flags          = oh_src->flags;
     oh_dst->link_msgs_seen = oh_src->link_msgs_seen;
     oh_dst->attr_msgs_seen = oh_src->attr_msgs_seen;
     oh_dst->sizeof_size    = H5F_SIZEOF_SIZE(oloc_dst->file);
     oh_dst->sizeof_addr    = H5F_SIZEOF_ADDR(oloc_dst->file);
     oh_dst->swmr_write     = !!(H5F_INTENT(oloc_dst->file) & H5F_ACC_SWMR_WRITE);
 
     /* Copy time fields */
     oh_dst->atime = oh_src->atime;
     oh_dst->mtime = oh_src->mtime;
     oh_dst->ctime = oh_src->ctime;
     oh_dst->btime = oh_src->btime;
 
     /* Copy attribute storage information */
     oh_dst->max_compact = oh_src->max_compact;
     oh_dst->min_dense   = oh_src->min_dense;
 
     /* Create object header proxy if doing SWMR writes */
     if (oh_dst->swmr_write) {
         /* Create virtual entry, for use as proxy */
         if (NULL == (oh_dst->proxy = H5AC_proxy_entry_create()))
             HGOTO_ERROR(H5E_OHDR, H5E_CANTCREATE, FAIL, "can't create object header proxy");
     } /* end if */
     else
         oh_dst->proxy = NULL;
 
     /* Initialize size of chunk array.  Start off with zero chunks so this field
      * is consistent with the current state of the chunk array.  This is
      * important if an error occurs.
      */
     oh_dst->alloc_nchunks = oh_dst->nchunks = 0;
 
     /* Allocate memory for the chunk array - always start with 1 chunk */
     if (NULL == (oh_dst->chunk = H5FL_SEQ_MALLOC(H5O_chunk_t, (size_t)1)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
 
     /* Update number of allocated chunks.  There are still no chunks used. */
     oh_dst->alloc_nchunks = 1;
 
     /* Allocate memory for "deleted" array.  This array marks the message in
      * the source that shouldn't be copied to the destination.
      */
     if (NULL == (deleted = (bool *)H5MM_malloc(sizeof(bool) * oh_src->nmesgs)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
     memset(deleted, false, sizeof(bool) * oh_src->nmesgs);
 
     /* "pre copy" pass over messages, to gather information for actual message copy operation
      * (for messages which depend on information from other messages)
      * Keep track of how many NULL or deleted messages we find (or create)
      */
     null_msgs = 0;
     for (mesgno = 0; mesgno < oh_src->nmesgs; mesgno++) {
         /* Set up convenience variables */
         mesg_src = &(oh_src->mesg[mesgno]);
 
         /* Sanity check */
         assert(!mesg_src->dirty); /* Should be cleared by earlier call to flush messages */
 
         /* Get message class to operate on */
         copy_type = mesg_src->type;
 
+        /* Sanity check message for possible corruption */
+        if (H5O_UNKNOWN_ID != mesg_src->type->id && H5O_NULL_ID != mesg_src->type->id)
+            if (0 == mesg_src->raw_size)
+                HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, FAIL, "message of type '%s' has zero size",
+                            mesg_src->type->name);
+
         /* Check for continuation message; these are converted to NULL
          * messages because the destination OH will have only one chunk
          */
         if (H5O_CONT_ID == mesg_src->type->id || H5O_NULL_ID == mesg_src->type->id) {
             deleted[mesgno] = true;
             ++null_msgs;
             copy_type = H5O_MSG_NULL;
         } /* end if */
         assert(copy_type);
 
         if (copy_type->pre_copy_file) {
             /* Decode the message if necessary. */
             H5O_LOAD_NATIVE(oloc_src->file, 0, oh_src, mesg_src, FAIL)
 
             /* Save destination file pointer in cpy_info so that it can be used
                in the pre_copy_file callback to obtain the destination file's
                high bound.  The high bound is used to index into the corresponding
                message's array of versions for doing version bounds check. */
             cpy_info->file_dst = oloc_dst->file;
 
             /* Perform "pre copy" operation on message */
             if ((copy_type->pre_copy_file)(oloc_src->file, mesg_src->native, &(deleted[mesgno]), cpy_info,
                                            cpy_udata) < 0)
                 HGOTO_ERROR(H5E_OHDR, H5E_CANTINIT, FAIL,
                             "unable to perform 'pre copy' operation on message");
 
             /* Check if the message should be deleted in the destination */
             if (deleted[mesgno])
                 /* Mark message as deleted */
                 ++null_msgs;
         } /* end if(copy_type->pre_copy_file) */
     }     /* end for */
 
     /* Initialize size of message list.  It may or may not include the NULL messages
      * detected above.
      */
     if (cpy_info->preserve_null)
         oh_dst->alloc_nmesgs = oh_dst->nmesgs = oh_src->nmesgs;
     else
         oh_dst->alloc_nmesgs = oh_dst->nmesgs = (oh_src->nmesgs - null_msgs);
 
     /* Allocate memory for destination message array */
     if (oh_dst->alloc_nmesgs > 0)
         if (NULL == (oh_dst->mesg = H5FL_SEQ_CALLOC(H5O_mesg_t, oh_dst->alloc_nmesgs)))
             HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
 
     /* "copy" pass over messages, to perform main message copying */
     null_msgs = 0;
     for (mesgno = 0; mesgno < oh_dst->nmesgs; mesgno++) {
         /* Skip any deleted or NULL messages in the source unless the
          * preserve_null flag is set
          */
         if (false == cpy_info->preserve_null) {
             while (deleted[mesgno + null_msgs]) {
                 ++null_msgs;
                 assert(mesgno + null_msgs < oh_src->nmesgs);
             } /* end while */
         }     /* end if */
 
         /* Set up convenience variables */
         mesg_src = &(oh_src->mesg[mesgno + null_msgs]);
         mesg_dst = &(oh_dst->mesg[mesgno]);
 
         /* Initialize non-zero components of destination message */
         mesg_dst->crt_idx  = mesg_src->crt_idx;
         mesg_dst->flags    = mesg_src->flags;
         mesg_dst->raw_size = mesg_src->raw_size;
         mesg_dst->type     = mesg_src->type;
 
         /* If we're preserving deleted messages, set their types to 'NULL'
          * in the destination.
          */
         if (cpy_info->preserve_null && deleted[mesgno]) {
             mesg_dst->type  = H5O_MSG_NULL;
             mesg_dst->flags = 0;
             mesg_dst->dirty = true;
         } /* end if */
 
         /* Check for message class to operate on */
         /* (Use destination message, in case the message has been removed (i.e
          *      converted to a nil message) in the destination -QAK)
          */
         copy_type = mesg_dst->type;
         assert(copy_type);
 
         /* copy this message into destination file */
         if (copy_type->copy_file) {
             bool     recompute_size; /* Whether copy_file callback created a shared message */
             unsigned mesg_flags;     /* Message flags */
 
             /* Decode the message if necessary. */
             H5O_LOAD_NATIVE(oloc_src->file, 0, oh_src, mesg_src, FAIL)
 
             /* Get destination message flags, and unset shared and shareable
              * flags.  mesg_dst->flags will contain the original flags for now.
              */
             mesg_flags = (unsigned)mesg_dst->flags & ~H5O_MSG_FLAG_SHARED & ~H5O_MSG_FLAG_SHAREABLE;
 
             /* Copy the source message */
             recompute_size = false;
             if (NULL == (mesg_dst->native =
                              H5O__msg_copy_file(copy_type, oloc_src->file, mesg_src->native, oloc_dst->file,
                                                 &recompute_size, &mesg_flags, cpy_info, cpy_udata)))
                 HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, FAIL, "unable to copy object header message");
 
             /* Check if the sharing state changed, and recompute the size if so
              */
             if (!(mesg_flags & H5O_MSG_FLAG_SHARED) != !(mesg_dst->flags & H5O_MSG_FLAG_SHARED))
                 recompute_size = true;
 
             /* Set destination message flags */
             mesg_dst->flags = (uint8_t)mesg_flags;
 
             /* Recompute message's size */
             /* (its sharing status or one of its components (for attributes)
              *  could have changed)
              */
             if (recompute_size)
                 mesg_dst->raw_size = H5O_ALIGN_OH(
                     oh_dst, H5O_msg_raw_size(oloc_dst->file, mesg_dst->type->id, false, mesg_dst->native));
 
             /* Mark the message in the destination as dirty, so it'll get encoded when the object header is
              * flushed */
             mesg_dst->dirty = true;
         } /* end if (mesg_src->type->copy_file) */
     }     /* end of mesgno loop */
 
     /* Allocate the destination header and copy any messages that didn't have
      * copy callbacks.  They get copied directly from the source image to the
      * destination image.
      */
 
     /* Calculate how big the destination object header will be on disk.
      * This isn't necessarily the same size as the original.
      */
 
     /* Compute space for messages. */
     dst_oh_size = 0;
     for (mesgno = 0; mesgno < oh_dst->nmesgs; mesgno++) {
         dst_oh_size += (uint64_t)H5O_SIZEOF_MSGHDR_OH(oh_dst);
         dst_oh_size += oh_dst->mesg[mesgno].raw_size;
     } /* end for */
 
     /* Check if we need to determine correct value for chunk #0 size bits */
     if (oh_dst->version > H5O_VERSION_1) {
         /* Reset destination object header's "chunk 0 size" flags */
         oh_dst->flags = (uint8_t)(oh_dst->flags & ~H5O_HDR_CHUNK0_SIZE);
 
         /* Determine correct value for chunk #0 size bits */
         if (dst_oh_size > 4294967295)
             oh_dst->flags |= H5O_HDR_CHUNK0_8;
         else if (dst_oh_size > 65535)
             oh_dst->flags |= H5O_HDR_CHUNK0_4;
         else if (dst_oh_size > 255)
             oh_dst->flags |= H5O_HDR_CHUNK0_2;
     } /* end if */
 
     /* Check if the chunk's data portion is too small */
     dst_oh_gap = dst_oh_null = 0;
     if (dst_oh_size < H5O_MIN_SIZE) {
         size_t delta = (size_t)(H5O_MIN_SIZE - dst_oh_size); /* Delta in chunk size needed */
 
         /* Sanity check */
         assert((oh_dst->flags & H5O_HDR_CHUNK0_SIZE) == H5O_HDR_CHUNK0_1);
 
         /* Determine whether to create gap or NULL message */
         if ((oh_dst->version > H5O_VERSION_1) && (delta < H5O_SIZEOF_MSGHDR_OH(oh_dst)))
             dst_oh_gap = delta;
         else {
             /* NULL message must be at least size of message header */
             if (delta < H5O_SIZEOF_MSGHDR_OH(oh_dst))
                 delta = H5O_SIZEOF_MSGHDR_OH(oh_dst);
 
             dst_oh_null = delta;
         }
 
         /* Increase destination object header size */
         dst_oh_size += delta;
 
         /* Sanity check */
         assert(dst_oh_size <= 255);
     } /* end if */
 
     /* Add in destination's object header size now */
     dst_oh_size += (uint64_t)H5O_SIZEOF_HDR(oh_dst);
 
     /* Allocate space for chunk in destination file */
     if (HADDR_UNDEF ==
         (oh_dst->chunk[0].addr = H5MF_alloc(oloc_dst->file, H5FD_MEM_OHDR, (hsize_t)dst_oh_size)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "file allocation failed for object header");
     addr_new = oh_dst->chunk[0].addr;
 
     /* Create memory image for the new chunk */
     /* Note: we use calloc() instead of malloc() here because older versions of
      *  some messages don't initialize "unused" bytes and because we want to
      *  write out the same version of the object header and older versions of
      *  object headers aligned messages.  In both those situations, it's
      *  complex and error-prone to determine all the proper ways/places to
      *  clear to zero bytes, so we just set the buffer to zero's here.
      *  (QAK - 2010/08/17)
      */
     if (NULL == (oh_dst->chunk[0].image = H5FL_BLK_CALLOC(chunk_image, (size_t)dst_oh_size)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
 
     /* Set dest. chunk information */
     oh_dst->chunk[0].size = (size_t)dst_oh_size;
     oh_dst->chunk[0].gap  = dst_oh_gap;
 
     /* Update size of chunk array.  The destination now has one chunk. */
     oh_dst->nchunks = 1;
 
     /* Set up raw pointers and copy messages that didn't need special
      * treatment.  This has to happen after the destination header has been
      * allocated.
      */
     assert(H5O_SIZEOF_MSGHDR_OH(oh_src) == H5O_SIZEOF_MSGHDR_OH(oh_dst));
     msghdr_size = H5O_SIZEOF_MSGHDR_OH(oh_dst);
 
     current_pos = oh_dst->chunk[0].image;
 
     /* Write the magic number for versions > 1 and skip the rest of the
      * header.  This will be written when the header is flushed to disk.
      */
     if (oh_dst->version > H5O_VERSION_1)
         H5MM_memcpy(current_pos, H5O_HDR_MAGIC, (size_t)H5_SIZEOF_MAGIC);
     current_pos += H5O_SIZEOF_HDR(oh_dst) - H5O_SIZEOF_CHKSUM_OH(oh_dst);
 
     /* Loop through destination messages, updating their "raw" info */
     null_msgs = 0;
     for (mesgno = 0; mesgno < oh_dst->nmesgs; mesgno++) {
         /* Skip any deleted or NULL messages in the source unless the
          * preserve_null flag is set.
          */
         if (false == cpy_info->preserve_null) {
             while (deleted[mesgno + null_msgs]) {
                 ++null_msgs;
                 assert(mesgno + null_msgs < oh_src->nmesgs);
             } /* end while */
         }     /* end if */
 
         /* Set up convenience variables */
         mesg_src = &(oh_src->mesg[mesgno + null_msgs]);
         mesg_dst = &(oh_dst->mesg[mesgno]);
 
         /* Copy each message that wasn't dirtied above */
         if (!mesg_dst->dirty)
             /* Copy the message header plus the message's raw data. */
             H5MM_memcpy(current_pos, mesg_src->raw - msghdr_size, msghdr_size + mesg_src->raw_size);
 
         /* Set message's raw pointer to destination chunk's new "image" */
         mesg_dst->raw = current_pos + msghdr_size;
 
         /* Move to location where next message should go */
         current_pos += mesg_dst->raw_size + msghdr_size;
     } /* end for */
 
     /* Save this in case more messages are added during NULL message checking */
     orig_dst_msgs = oh_dst->nmesgs;
 
     /* Check if we need to add a NULL message to this header */
     if (dst_oh_null > 0) {
         size_t null_idx; /* Index of new NULL message */
 
         /* Make sure we have enough space for new NULL message */
         if (oh_dst->nmesgs + 1 > oh_dst->alloc_nmesgs)
             if (H5O__alloc_msgs(oh_dst, (size_t)1) < 0)
                 HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "can't allocate more space for messages");
 
         /* Create null message for [rest of] space in new chunk */
         /* (account for chunk's magic # & checksum) */
         null_idx                        = oh_dst->nmesgs++;
         oh_dst->mesg[null_idx].type     = H5O_MSG_NULL;
         oh_dst->mesg[null_idx].dirty    = true;
         oh_dst->mesg[null_idx].native   = NULL;
         oh_dst->mesg[null_idx].raw      = current_pos + msghdr_size;
         oh_dst->mesg[null_idx].raw_size = dst_oh_null - msghdr_size;
         oh_dst->mesg[null_idx].chunkno  = 0;
     } /* end if */
 
     /* Make sure we filled the chunk, except for room at the end for a checksum */
     assert(current_pos + dst_oh_gap + dst_oh_null + H5O_SIZEOF_CHKSUM_OH(oh_dst) ==
            (size_t)dst_oh_size + oh_dst->chunk[0].image);
 
     /* Set the dest. object location to the first chunk address */
     assert(H5_addr_defined(addr_new));
     oloc_dst->addr = addr_new;
 
     /* If we are merging committed datatypes and this is a committed datatype, insert
      * the copied datatype into the list of committed datatypes in the target file.
      */
     if (cpy_info->merge_comm_dt && obj_class->type == H5O_TYPE_NAMED_DATATYPE)
         if (H5O__copy_insert_comm_dt(oloc_src->file, oh_src, oloc_dst, cpy_info) < 0)
             HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, FAIL, "can't insert committed datatype into destination list");
 
     /* Allocate space for the address mapping of the object copied */
     if (NULL == (addr_map = H5FL_MALLOC(H5O_addr_map_t)))
         HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
 
     /* Insert the address mapping for the new object into the copied list */
     /* (Do this here, because "post copy" possibly checks it) */
     H5F_GET_FILENO(oloc_src->file, addr_map->src_obj_pos.fileno);
     addr_map->src_obj_pos.addr = oloc_src->addr;
     addr_map->dst_addr         = oloc_dst->addr;
     addr_map->is_locked        = true; /* We've locked the object currently */
     addr_map->inc_ref_count    = 0;    /* Start with no additional ref counts to add */
     addr_map->obj_class        = obj_class;
     addr_map->udata            = cpy_udata;
 
     /* Insert into skip list */
     if (H5SL_insert(cpy_info->map_list, addr_map, &(addr_map->src_obj_pos)) < 0) {
         addr_map = H5FL_FREE(H5O_addr_map_t, addr_map);
         HGOTO_ERROR(H5E_OHDR, H5E_CANTINSERT, FAIL, "can't insert object into skip list");
     } /* end if */
 
     /* "post copy" loop over messages, to fix up any messages which require a complete
      * object header for destination object
      */
     null_msgs = 0;
     for (mesgno = 0; mesgno < orig_dst_msgs; mesgno++) {
         /* Skip any deleted or NULL messages in the source unless the
          * preserve_null flag is set
          */
         if (false == cpy_info->preserve_null) {
             while (deleted[mesgno + null_msgs]) {
                 ++null_msgs;
                 assert(mesgno + null_msgs < oh_src->nmesgs);
             } /* end while */
         }     /* end if */
 
         /* Set up convenience variables */
         mesg_src = &(oh_src->mesg[mesgno + null_msgs]);
         mesg_dst = &(oh_dst->mesg[mesgno]);
 
         /* Check for message class to operate on */
         /* (Use destination message, in case the message has been removed (i.e
          *      converted to a nil message) in the destination -QAK)
          */
         copy_type = mesg_dst->type;
         assert(copy_type);
 
         if (copy_type->post_copy_file && mesg_src->native) {
             unsigned mesg_flags; /* Message flags */
 
             /* Sanity check destination message */
             assert(mesg_dst->type == mesg_src->type);
             assert(mesg_dst->native);
 
             /* Get destination message flags.   mesg_dst->flags will contain the
              * original flags for now. */
             mesg_flags = (unsigned)mesg_dst->flags;
 
             /* the object header is needed in the post copy for shared message */
             cpy_info->oh_dst = oh_dst;
 
             /* Perform "post copy" operation on message */
             if ((copy_type->post_copy_file)(oloc_src, mesg_src->native, oloc_dst, mesg_dst->native,
                                             &mesg_flags, cpy_info) < 0)
                 HGOTO_ERROR(H5E_OHDR, H5E_CANTINIT, FAIL,
                             "unable to perform 'post copy' operation on message");
 
             /* Verify that the flags did not change */
             assert(mesg_flags == (unsigned)mesg_dst->flags);
         } /* end if */
     }     /* end for */
 
     /* Indicate that the destination address will no longer be locked */
     addr_map->is_locked = false;
 
     /* Increment object header's reference count, if any descendents have created links to this object */
     if (addr_map->inc_ref_count) {
         H5_CHECK_OVERFLOW(addr_map->inc_ref_count, hsize_t, unsigned);
         oh_dst->nlink += (unsigned)addr_map->inc_ref_count;
     } /* end if */
 
     /* Retag all copied metadata to apply the destination object's tag */
     if (H5AC_retag_copied_metadata(oloc_dst->file, oloc_dst->addr) < 0)
         HGOTO_ERROR(H5E_CACHE, H5E_CANTTAG, FAIL, "unable to re-tag metadata entries");
 
     /* Set metadata tag for destination object's object header */
     H5_BEGIN_TAG(oloc_dst->addr)
 
     /* Insert destination object header in cache */
     if (H5AC_insert_entry(oloc_dst->file, H5AC_OHDR, oloc_dst->addr, oh_dst, H5AC__NO_FLAGS_SET) < 0)
         HGOTO_ERROR_TAG(H5E_OHDR, H5E_CANTINSERT, FAIL, "unable to cache object header");
     oh_dst   = NULL;
     inserted = true;
 
     /* Reset metadata tag */
     H5_END_TAG
 
     /* Set obj_type and udata, if requested */
     if (obj_type) {
         assert(udata);
         *obj_type = obj_class->type;
         *udata    = cpy_udata;
     } /* end if */
diff --git a/src/H5Odtype.c b/src/H5Odtype.c
index 674d8d4ea1..24671b0210 100644
--- a/src/H5Odtype.c
+++ b/src/H5Odtype.c
@@ -120,709 +120,731 @@ static htri_t
 H5O__dtype_decode_helper(unsigned *ioflags /*in,out*/, const uint8_t **pp, H5T_t *dt, bool skip,
                          const uint8_t *p_end)
 {
     unsigned flags;
     unsigned version;
     htri_t   ret_value = false;
 
     FUNC_ENTER_PACKAGE
 
     assert(pp && *pp);
     assert(dt && dt->shared);
 
     /* XXX NOTE!
      *
      * H5Tencode() does not take a buffer size, so normal bounds checking in
      * that case is impossible.
      *
      * Instead of using our normal H5_IS_BUFFER_OVERFLOW macro, use
      * H5_IS_KNOWN_BUFFER_OVERFLOW, which will skip the check when the
      * we're decoding a buffer from H5Tconvert().
      *
      * Even if this is fixed at some point in the future, as long as we
      * support the old, size-less API call, we will need to use the modified
      * macros.
      */
 
     /* Version, class & flags */
     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 4, p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
     UINT32DECODE(*pp, flags);
     version = (flags >> 4) & 0x0f;
     if (version < H5O_DTYPE_VERSION_1 || version > H5O_DTYPE_VERSION_LATEST)
         HGOTO_ERROR(H5E_DATATYPE, H5E_CANTLOAD, FAIL, "bad version number for datatype message");
     dt->shared->version = version;
     dt->shared->type    = (H5T_class_t)(flags & 0x0f);
     flags >>= 8;
 
     /* Size */
     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 4, p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
     UINT32DECODE(*pp, dt->shared->size);
 
     /* Check for invalid datatype size */
     if (dt->shared->size == 0)
         HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, FAIL, "invalid datatype size");
 
     switch (dt->shared->type) {
         case H5T_INTEGER:
             /*
              * Integer types...
              */
             dt->shared->u.atomic.order    = (flags & 0x1) ? H5T_ORDER_BE : H5T_ORDER_LE;
             dt->shared->u.atomic.lsb_pad  = (flags & 0x2) ? H5T_PAD_ONE : H5T_PAD_ZERO;
             dt->shared->u.atomic.msb_pad  = (flags & 0x4) ? H5T_PAD_ONE : H5T_PAD_ZERO;
             dt->shared->u.atomic.u.i.sign = (flags & 0x8) ? H5T_SGN_2 : H5T_SGN_NONE;
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 2 + 2, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             UINT16DECODE(*pp, dt->shared->u.atomic.offset);
             UINT16DECODE(*pp, dt->shared->u.atomic.prec);
 
             /* Sanity checks */
             if (dt->shared->u.atomic.offset >= (dt->shared->size * 8))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADRANGE, FAIL, "integer offset out of bounds");
             if (0 == dt->shared->u.atomic.prec)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL, "precision is zero");
             if (((dt->shared->u.atomic.offset + dt->shared->u.atomic.prec) - 1) >= (dt->shared->size * 8))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADRANGE, FAIL, "integer offset+precision out of bounds");
             break;
 
         case H5T_FLOAT:
             /*
              * Floating-point types...
              */
             dt->shared->u.atomic.order = (flags & 0x1) ? H5T_ORDER_BE : H5T_ORDER_LE;
             if (version >= H5O_DTYPE_VERSION_3) {
                 /* Unsupported byte order*/
                 if ((flags & 0x40) && !(flags & 0x1))
                     HGOTO_ERROR(H5E_DATATYPE, H5E_UNSUPPORTED, FAIL, "bad byte order for datatype message");
 
                 /* VAX order if both 1st and 6th bits are turned on*/
                 if (flags & 0x40)
                     dt->shared->u.atomic.order = H5T_ORDER_VAX;
             }
             dt->shared->u.atomic.lsb_pad = (flags & 0x2) ? H5T_PAD_ONE : H5T_PAD_ZERO;
             dt->shared->u.atomic.msb_pad = (flags & 0x4) ? H5T_PAD_ONE : H5T_PAD_ZERO;
             dt->shared->u.atomic.u.f.pad = (flags & 0x8) ? H5T_PAD_ONE : H5T_PAD_ZERO;
             switch ((flags >> 4) & 0x03) {
                 case 0:
                     dt->shared->u.atomic.u.f.norm = H5T_NORM_NONE;
                     break;
 
                 case 1:
                     dt->shared->u.atomic.u.f.norm = H5T_NORM_MSBSET;
                     break;
 
                 case 2:
                     dt->shared->u.atomic.u.f.norm = H5T_NORM_IMPLIED;
                     break;
 
                 default:
                     HGOTO_ERROR(H5E_DATATYPE, H5E_UNSUPPORTED, FAIL, "unknown floating-point normalization");
             }
             dt->shared->u.atomic.u.f.sign = (flags >> 8) & 0xff;
             if (dt->shared->u.atomic.u.f.sign >= (dt->shared->size * 8))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADRANGE, FAIL, "sign bit position out of bounds");
 
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 2 + 2, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             UINT16DECODE(*pp, dt->shared->u.atomic.offset);
             UINT16DECODE(*pp, dt->shared->u.atomic.prec);
 
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 1 + 1, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             dt->shared->u.atomic.u.f.epos  = *(*pp)++;
             dt->shared->u.atomic.u.f.esize = *(*pp)++;
             if (dt->shared->u.atomic.u.f.esize == 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL, "exponent size can't be zero");
             if (dt->shared->u.atomic.u.f.epos >= (dt->shared->size * 8))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADRANGE, FAIL, "exponent starting position out of bounds");
             if (((dt->shared->u.atomic.u.f.epos + dt->shared->u.atomic.u.f.esize) - 1) >=
                 (dt->shared->size * 8))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADRANGE, FAIL, "exponent range out of bounds");
 
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 1 + 1, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             dt->shared->u.atomic.u.f.mpos  = *(*pp)++;
             dt->shared->u.atomic.u.f.msize = *(*pp)++;
             if (dt->shared->u.atomic.u.f.msize == 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL, "mantissa size can't be zero");
             if (dt->shared->u.atomic.u.f.mpos >= (dt->shared->size * 8))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADRANGE, FAIL, "mantissa starting position out of bounds");
             if (((dt->shared->u.atomic.u.f.mpos + dt->shared->u.atomic.u.f.msize) - 1) >=
                 (dt->shared->size * 8))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADRANGE, FAIL, "mantissa range out of bounds");
 
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 4, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             UINT32DECODE(*pp, dt->shared->u.atomic.u.f.ebias);
 
             /* Sanity check bits don't overlap */
             if (H5_RANGE_OVERLAP(dt->shared->u.atomic.u.f.sign, dt->shared->u.atomic.u.f.sign,
                                  dt->shared->u.atomic.u.f.epos,
                                  ((dt->shared->u.atomic.u.f.epos + dt->shared->u.atomic.u.f.esize) - 1)))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL, "exponent and sign positions overlap");
             if (H5_RANGE_OVERLAP(dt->shared->u.atomic.u.f.sign, dt->shared->u.atomic.u.f.sign,
                                  dt->shared->u.atomic.u.f.mpos,
                                  ((dt->shared->u.atomic.u.f.mpos + dt->shared->u.atomic.u.f.msize) - 1)))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL, "mantissa and sign positions overlap");
             if (H5_RANGE_OVERLAP(dt->shared->u.atomic.u.f.epos,
                                  ((dt->shared->u.atomic.u.f.epos + dt->shared->u.atomic.u.f.esize) - 1),
                                  dt->shared->u.atomic.u.f.mpos,
                                  ((dt->shared->u.atomic.u.f.mpos + dt->shared->u.atomic.u.f.msize) - 1)))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL, "mantissa and exponent positions overlap");
             break;
 
         case H5T_TIME:
             /*
              * Time datatypes...
              */
             dt->shared->u.atomic.order = (flags & 0x1) ? H5T_ORDER_BE : H5T_ORDER_LE;
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 2, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             UINT16DECODE(*pp, dt->shared->u.atomic.prec);
             break;
 
         case H5T_STRING:
             /*
              * Character string types...
              */
             dt->shared->u.atomic.order   = H5T_ORDER_NONE;
             dt->shared->u.atomic.prec    = 8 * dt->shared->size;
             dt->shared->u.atomic.offset  = 0;
             dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
             dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
 
             dt->shared->u.atomic.u.s.pad  = (H5T_str_t)(flags & 0x0f);
             dt->shared->u.atomic.u.s.cset = (H5T_cset_t)((flags >> 4) & 0x0f);
             break;
 
         case H5T_BITFIELD:
             /*
              * Bit fields...
              */
             dt->shared->u.atomic.order   = (flags & 0x1) ? H5T_ORDER_BE : H5T_ORDER_LE;
             dt->shared->u.atomic.lsb_pad = (flags & 0x2) ? H5T_PAD_ONE : H5T_PAD_ZERO;
             dt->shared->u.atomic.msb_pad = (flags & 0x4) ? H5T_PAD_ONE : H5T_PAD_ZERO;
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 2 + 2, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             UINT16DECODE(*pp, dt->shared->u.atomic.offset);
             UINT16DECODE(*pp, dt->shared->u.atomic.prec);
             break;
 
         case H5T_OPAQUE: {
             size_t z;
 
             /*
              * Opaque types...
              */
 
             /* The opaque tag flag field must be aligned */
             z = flags & (H5T_OPAQUE_TAG_MAX - 1);
             if (0 != (z & 0x7))
                 HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, FAIL, "opaque flag field must be aligned");
 
             if (NULL == (dt->shared->u.opaque.tag = (char *)H5MM_malloc(z + 1)))
                 HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
 
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, z, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             H5MM_memcpy(dt->shared->u.opaque.tag, *pp, z);
             dt->shared->u.opaque.tag[z] = '\0';
 
             *pp += z;
             break;
         }
 
         case H5T_COMPOUND: {
             unsigned nmembs;           /* Number of compound members */
             unsigned offset_nbytes;    /* Size needed to encode member offsets */
             size_t   max_memb_pos = 0; /* Maximum member covered, so far */
             unsigned max_version  = 0; /* Maximum member version */
             unsigned upgrade_to   = 0; /* Version number we can "soft" upgrade to */
 
             /* Compute the # of bytes required to store a member offset */
             offset_nbytes = H5VM_limit_enc_size((uint64_t)dt->shared->size);
 
             /*
              * Compound datatypes...
              */
             nmembs = flags & 0xffff;
             if (nmembs == 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL, "invalid number of members: %u", nmembs);
             if (NULL ==
                 (dt->shared->u.compnd.memb = (H5T_cmemb_t *)H5MM_calloc(nmembs * sizeof(H5T_cmemb_t))))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_CANTALLOC, FAIL, "memory allocation failed");
             dt->shared->u.compnd.nalloc = nmembs;
 
             if (dt->shared->u.compnd.memb_size != 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL, "member size not initialized to zero");
 
             for (dt->shared->u.compnd.nmembs = 0; dt->shared->u.compnd.nmembs < nmembs;
                  dt->shared->u.compnd.nmembs++) {
 
                 size_t   actual_name_length = 0; /* Actual length of name */
                 unsigned ndims              = 0; /* Number of dimensions of the array field */
                 htri_t   can_upgrade;            /* Whether we can upgrade this type's version */
                 hsize_t  dim[H5O_LAYOUT_NDIMS];  /* Dimensions of the array */
                 H5T_t   *array_dt;               /* Temporary pointer to the array datatype */
                 H5T_t   *temp_type;              /* Temporary pointer to the field's datatype */
+                unsigned memb_idx;               /* Local index counter */
 
                 /* Get the length of the field name */
                 if (!skip) {
                     /* There is a realistic buffer end, so check bounds */
 
                     size_t max = (size_t)(p_end - *pp + 1); /* Max possible name length */
 
                     actual_name_length = strnlen((const char *)*pp, max);
                     if (actual_name_length == max)
                         HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, FAIL, "field name not null terminated");
                 }
                 else {
                     /* The buffer end can't be determined when it's an unbounded buffer
                      * passed via H5Tdecode(), so don't bounds check and hope for
                      * the best.
                      */
                     actual_name_length = strlen((const char *)*pp);
                 }
 
                 if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, actual_name_length, p_end))
                     HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
 
+                /* Check for duplicated field name */
+                for (memb_idx = 0; memb_idx < dt->shared->u.compnd.nmembs; memb_idx++)
+                    if (0 == strcmp((const char *)*pp, dt->shared->u.compnd.memb[memb_idx].name))
+                        HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, FAIL,
+                                    "duplicated compound field name '%s', for fields %u and %u",
+                                    (const char *)*pp, memb_idx, dt->shared->u.compnd.nmembs);
+
                 /* Decode the field name */
                 if (NULL == (dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =
                                  H5MM_xstrdup((const char *)*pp)))
                     HGOTO_ERROR(H5E_RESOURCE, H5E_CANTCOPY, FAIL,
                                 "can't duplicate compound member name string");
 
                 /* Version 3 of the datatype message eliminated the padding to multiple of 8 bytes */
                 if (version >= H5O_DTYPE_VERSION_3) {
                     /* Advance past name, including null terminator */
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, actual_name_length + 1, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     *pp += actual_name_length + 1;
                 }
                 else {
                     /* Advance multiple of 8 w/ null terminator */
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, ((actual_name_length + 8) / 8) * 8, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     *pp += ((actual_name_length + 8) / 8) * 8;
                 }
 
                 /* Decode the field offset */
                 /* (starting with version 3 of the datatype message, use the minimum # of bytes required) */
                 if (version >= H5O_DTYPE_VERSION_3) {
                     H5_GCC_CLANG_DIAG_OFF("type-limits")
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, offset_nbytes, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     H5_GCC_CLANG_DIAG_ON("type-limits")
                     UINT32DECODE_VAR(*pp, dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].offset,
                                      offset_nbytes);
                 }
                 else {
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 4, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     UINT32DECODE(*pp, dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].offset);
                 }
 
                 /* Older versions of the library allowed a field to have
                  * intrinsic 'arrayness'.  Newer versions of the library
                  * use the separate array datatypes. */
                 if (version == H5O_DTYPE_VERSION_1) {
                     /* Decode the number of dimensions */
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 1, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     ndims = *(*pp)++;
 
                     /* Check that ndims is valid */
                     if (ndims > 4) {
                         dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =
                             H5MM_xfree(dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name);
                         HGOTO_ERROR(H5E_DATATYPE, H5E_BADTYPE, FAIL,
                                     "invalid number of dimensions for array");
                     }
 
                     /* Skip reserved bytes */
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 3, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     *pp += 3;
 
                     /* Skip dimension permutation */
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 4, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     *pp += 4;
 
                     /* Skip reserved bytes */
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 4, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     *pp += 4;
 
                     /* Decode array dimension sizes */
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, (4 * 4), p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     for (int i = 0; i < 4; i++)
                         UINT32DECODE(*pp, dim[i]);
                 }
 
                 /* Allocate space for the field's datatype */
                 if (NULL == (temp_type = H5T__alloc())) {
                     dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =
                         H5MM_xfree(dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name);
                     HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed");
                 }
 
                 /* Decode the field's datatype information */
                 if ((can_upgrade = H5O__dtype_decode_helper(ioflags, pp, temp_type, skip, p_end)) < 0) {
                     dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =
                         H5MM_xfree(dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name);
                     if (H5T_close_real(temp_type) < 0)
                         HDONE_ERROR(H5E_DATATYPE, H5E_CANTRELEASE, FAIL, "can't release datatype info");
                     HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL, "unable to decode member type");
                 }
                 if (temp_type->shared->size == 0)
                     HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL, "type size can't be zero");
                 if ((dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].offset +
                      temp_type->shared->size) > dt->shared->size) {
                     if (H5T_close_real(temp_type) < 0)
                         HDONE_ERROR(H5E_DATATYPE, H5E_CANTRELEASE, FAIL, "can't release datatype info");
                     HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL,
                                 "member type extends outside its parent compound type");
                 }
 
                 /* Upgrade the version if we can and it is necessary */
                 if (can_upgrade && temp_type->shared->version > version) {
                     upgrade_to = temp_type->shared->version;
 
                     /* Pass "can_upgrade" flag down to parent type */
                     ret_value = true;
                 }
 
                 /* Go create the array datatype now, for older versions of the datatype message */
                 if (version == H5O_DTYPE_VERSION_1) {
                     /* Check if this member is an array field */
                     if (ndims > 0) {
+                        /* Validate decoded dims */
+                        for (unsigned u = 0; u < ndims; u++)
+                            if (!(dim[u] > 0)) {
+                                dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =
+                                    H5MM_xfree(dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name);
+                                if (H5T_close_real(temp_type) < 0)
+                                    HDONE_ERROR(H5E_DATATYPE, H5E_CANTRELEASE, FAIL,
+                                                "can't release datatype info");
+                                HGOTO_ERROR(H5E_DATATYPE, H5E_BADVALUE, FAIL,
+                                            "zero-sized dimension specified");
+                            }
+
                         /* Create the array datatype for the field */
                         if ((array_dt = H5T__array_create(temp_type, ndims, dim)) == NULL) {
                             dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =
                                 H5MM_xfree(dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name);
                             if (H5T_close_real(temp_type) < 0)
                                 HDONE_ERROR(H5E_DATATYPE, H5E_CANTRELEASE, FAIL,
                                             "can't release datatype info");
                             HGOTO_ERROR(H5E_DATATYPE, H5E_CANTREGISTER, FAIL,
                                         "unable to create array datatype");
                         }
 
                         /* Close the base type for the array */
                         if (H5T_close_real(temp_type) < 0) {
                             dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name =
                                 H5MM_xfree(dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].name);
                             HGOTO_ERROR(H5E_DATATYPE, H5E_CANTRELEASE, FAIL, "can't release datatype info");
                         }
 
                         /* Make the array type the type that is set for the field */
                         temp_type = array_dt;
 
                         /* Reset array version if NOCHANGE is specified (i.e. h5debug) */
                         if (*ioflags & H5O_DECODEIO_NOCHANGE)
                             temp_type->shared->version = H5O_DTYPE_VERSION_1;
                         else {
                             /* Otherwise upgrade the compound version */
                             if (upgrade_to < temp_type->shared->version)
                                 upgrade_to = temp_type->shared->version;
 
                             /* Set the return value to indicate that we should freely
                              * upgrade parent types */
                             ret_value = true;
                         }
                     }
                 }
 
                 /* Keep track of the maximum member version found */
                 if (temp_type->shared->version > max_version)
                     max_version = temp_type->shared->version;
 
                 /* Set the "force conversion" flag if VL datatype fields exist in this
                  * type or any component types
                  */
                 if (temp_type->shared->force_conv == true)
                     dt->shared->force_conv = true;
 
                 /* Member size */
                 dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].size = temp_type->shared->size;
                 dt->shared->u.compnd.memb_size += temp_type->shared->size;
 
                 /* Set the field datatype (finally :-) */
                 dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].type = temp_type;
 
                 /* Check if this field overlaps with a prior field
                  * (probably indicates that the file is corrupt)
                  */
                 if (dt->shared->u.compnd.nmembs > 0 &&
                     dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].offset < max_memb_pos) {
                     for (unsigned u = 0; u < dt->shared->u.compnd.nmembs; u++)
                         if ((dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].offset >=
                                  dt->shared->u.compnd.memb[u].offset &&
                              dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].offset <
                                  (dt->shared->u.compnd.memb[u].offset + dt->shared->u.compnd.memb[u].size)) ||
                             (dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].offset <
                                  dt->shared->u.compnd.memb[u].offset &&
                              (dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].offset +
                               dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].size) >
                                  dt->shared->u.compnd.memb[u].offset))
                             HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL,
                                         "member overlaps with previous member");
                 }
 
                 /* Update the maximum member position covered */
                 max_memb_pos =
                     MAX(max_memb_pos, (dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].offset +
                                        dt->shared->u.compnd.memb[dt->shared->u.compnd.nmembs].size));
             }
 
             /* Check if the compound type is packed */
             H5T__update_packed(dt);
 
             /* Upgrade the compound if requested */
             if (version < upgrade_to) {
                 version = upgrade_to;
                 if (H5T__upgrade_version(dt, upgrade_to) < 0)
                     HGOTO_ERROR(H5E_DATATYPE, H5E_CANTSET, FAIL, "can't upgrade compound encoding version");
                 /* We won't mark the message dirty since there were no
                  * errors in the file, simply type versions that we will no
                  * longer encode. */
             }
 
             /* Check that no member of this compound has a version greater
              * than the compound itself. */
             H5O_DTYPE_CHECK_VERSION(dt, version, max_version, ioflags, "compound", FAIL)
         } break;
 
         case H5T_REFERENCE:
             /*
              * Reference datatypes...
              */
             dt->shared->u.atomic.order   = H5T_ORDER_NONE;
             dt->shared->u.atomic.prec    = 8 * dt->shared->size;
             dt->shared->u.atomic.offset  = 0;
             dt->shared->u.atomic.lsb_pad = H5T_PAD_ZERO;
             dt->shared->u.atomic.msb_pad = H5T_PAD_ZERO;
 
             /* Set reference type */
             dt->shared->u.atomic.u.r.rtype = (H5R_type_t)(flags & 0x0f);
             if (dt->shared->u.atomic.u.r.rtype <= H5R_BADTYPE ||
                 dt->shared->u.atomic.u.r.rtype >= H5R_MAXTYPE)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL, "invalid reference type");
 
             /* Set generic flag */
             if (dt->shared->u.atomic.u.r.rtype == H5R_OBJECT2 ||
                 dt->shared->u.atomic.u.r.rtype == H5R_DATASET_REGION2 ||
                 dt->shared->u.atomic.u.r.rtype == H5R_ATTR) {
                 dt->shared->u.atomic.u.r.opaque  = true;
                 dt->shared->u.atomic.u.r.version = (unsigned)((flags >> 4) & 0x0f);
                 if (dt->shared->u.atomic.u.r.version != H5R_ENCODE_VERSION)
                     HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL, "reference version does not match");
             }
             else
                 dt->shared->u.atomic.u.r.opaque = false;
 
             /* This type needs conversion */
             dt->shared->force_conv = true;
 
             /* Mark location of this type as undefined for now.  The caller
              * function should decide the location. */
             if (H5T_set_loc(dt, NULL, H5T_LOC_BADLOC) < 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "invalid datatype location");
             break;
 
         case H5T_ENUM: {
             unsigned nmembs;
 
             /*
              * Enumeration datatypes...
              */
             nmembs = flags & 0xffff;
             if (NULL == (dt->shared->parent = H5T__alloc()))
                 HGOTO_ERROR(H5E_RESOURCE, H5E_CANTALLOC, FAIL, "can't allocate parent datatype");
             if (H5O__dtype_decode_helper(ioflags, pp, dt->shared->parent, skip, p_end) < 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL, "unable to decode parent datatype");
             if (dt->shared->parent->shared->size != dt->shared->size)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_BADSIZE, FAIL, "ENUM datatype size does not match parent");
 
             /* Check if the parent of this enum has a version greater than the
              * enum itself. */
             H5O_DTYPE_CHECK_VERSION(dt, version, dt->shared->parent->shared->version, ioflags, "enum", FAIL)
 
             /* Allocate name and value arrays */
             if (NULL == (dt->shared->u.enumer.name = (char **)H5MM_calloc(nmembs * sizeof(char *))) ||
                 NULL == (dt->shared->u.enumer.value =
                              (uint8_t *)H5MM_calloc(nmembs * dt->shared->parent->shared->size)))
                 HGOTO_ERROR(H5E_RESOURCE, H5E_CANTALLOC, FAIL, "memory allocation failed");
             dt->shared->u.enumer.nalloc = nmembs;
 
             /* Names */
             for (dt->shared->u.enumer.nmembs = 0; dt->shared->u.enumer.nmembs < nmembs;
                  dt->shared->u.enumer.nmembs++) {
 
                 size_t actual_name_length = 0; /* Actual length of name */
 
                 /* Get the length of the enum name */
                 if (!skip) {
                     /* There is a realistic buffer end, so check bounds */
 
                     size_t max = (size_t)(p_end - *pp + 1); /* Max possible name length */
 
                     actual_name_length = strnlen((const char *)*pp, max);
                     if (actual_name_length == max)
                         HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, FAIL, "enum name not null terminated");
                 }
                 else {
                     /* The buffer end can't be determined when it's an unbounded buffer
                      * passed via H5Tdecode(), so don't bounds check and hope for
                      * the best.
                      */
                     actual_name_length = strlen((const char *)*pp);
                 }
+                if (0 == actual_name_length)
+                    HGOTO_ERROR(H5E_OHDR, H5E_BADSIZE, FAIL, "0 length enum name");
 
                 if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, actual_name_length, p_end))
                     HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
                 if (NULL == (dt->shared->u.enumer.name[dt->shared->u.enumer.nmembs] =
                                  H5MM_xstrdup((const char *)*pp)))
                     HGOTO_ERROR(H5E_RESOURCE, H5E_CANTCOPY, FAIL, "can't duplicate enum name string");
 
                 /* Version 3 of the datatype message eliminated the padding to multiple of 8 bytes */
                 if (version >= H5O_DTYPE_VERSION_3) {
                     /* Advance past name, including null terminator */
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, actual_name_length + 1, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     *pp += actual_name_length + 1;
                 }
                 else {
                     /* Advance multiple of 8 w/ null terminator */
                     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, ((actual_name_length + 8) / 8) * 8, p_end))
                         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL,
                                     "ran off end of input buffer while decoding");
                     *pp += ((actual_name_length + 8) / 8) * 8;
                 }
             }
             if (dt->shared->u.enumer.nmembs != nmembs)
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "incorrect number of enum members decoded");
 
             /* Values */
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, nmembs * dt->shared->parent->shared->size, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             H5MM_memcpy(dt->shared->u.enumer.value, *pp, nmembs * dt->shared->parent->shared->size);
             *pp += nmembs * dt->shared->parent->shared->size;
         } break;
 
         case H5T_VLEN:
             /*
              * Variable length datatypes...
              */
             /* Set the type of VL information, either sequence or string */
             dt->shared->u.vlen.type = (H5T_vlen_type_t)(flags & 0x0f);
             if (dt->shared->u.vlen.type == H5T_VLEN_STRING) {
                 dt->shared->u.vlen.pad  = (H5T_str_t)((flags >> 4) & 0x0f);
                 dt->shared->u.vlen.cset = (H5T_cset_t)((flags >> 8) & 0x0f);
             }
 
             /* Decode base type of VL information */
             if (NULL == (dt->shared->parent = H5T__alloc()))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "memory allocation failed");
             if (H5O__dtype_decode_helper(ioflags, pp, dt->shared->parent, skip, p_end) < 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL, "unable to decode VL parent type");
 
             /* Check if the parent of this vlen has a version greater than the
              * vlen itself. */
             H5O_DTYPE_CHECK_VERSION(dt, version, dt->shared->parent->shared->version, ioflags, "vlen", FAIL)
 
             dt->shared->force_conv = true;
 
             /* Mark location this type as undefined for now.  The caller function should
              * decide the location. */
             if (H5T_set_loc(dt, NULL, H5T_LOC_BADLOC) < 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, FAIL, "invalid datatype location");
             break;
 
         case H5T_ARRAY:
             /*
              * Array datatypes...
              */
             /* Decode the number of dimensions */
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 1, p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             dt->shared->u.array.ndims = *(*pp)++;
 
             /* Double-check the number of dimensions */
             if (dt->shared->u.array.ndims > H5S_MAX_RANK)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_CANTLOAD, FAIL, "too many dimensions for array datatype");
 
             /* Skip reserved bytes, if version has them */
             if (version < H5O_DTYPE_VERSION_3) {
                 if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, 3, p_end))
                     HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
                 *pp += 3;
             }
 
             /* Decode array dimension sizes & compute number of elements */
             dt->shared->u.array.nelem = 1;
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, (dt->shared->u.array.ndims * 4), p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
             for (unsigned u = 0; u < dt->shared->u.array.ndims; u++) {
                 UINT32DECODE(*pp, dt->shared->u.array.dim[u]);
                 dt->shared->u.array.nelem *= dt->shared->u.array.dim[u];
             }
 
             /* Skip array dimension permutations, if version has them */
             if (version < H5O_DTYPE_VERSION_3) {
                 if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, *pp, (dt->shared->u.array.ndims * 4), p_end))
                     HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, FAIL, "ran off end of input buffer while decoding");
                 *pp += dt->shared->u.array.ndims * 4;
             }
 
             /* Decode base type of array */
             if (NULL == (dt->shared->parent = H5T__alloc()))
                 HGOTO_ERROR(H5E_DATATYPE, H5E_NOSPACE, FAIL, "memory allocation failed");
             if (H5O__dtype_decode_helper(ioflags, pp, dt->shared->parent, skip, p_end) < 0)
                 HGOTO_ERROR(H5E_DATATYPE, H5E_CANTDECODE, FAIL, "unable to decode array parent type");
 
             /* Check if the parent of this array has a version greater than the
              * array itself. */
             H5O_DTYPE_CHECK_VERSION(dt, version, dt->shared->parent->shared->version, ioflags, "array", FAIL)
 
             /* There should be no array datatypes with version < 2. */
             H5O_DTYPE_CHECK_VERSION(dt, version, H5O_DTYPE_VERSION_2, ioflags, "array", FAIL)
 
             /* Set the "force conversion" flag if a VL base datatype is used or
              * or if any components of the base datatype are VL types.
              */
             if (dt->shared->parent->shared->force_conv == true)
                 dt->shared->force_conv = true;
             break;
 
         case H5T_NO_CLASS:
         case H5T_NCLASSES:
         default:
             HGOTO_ERROR(H5E_DATATYPE, H5E_UNSUPPORTED, FAIL, "unknown datatype class found");
     }
 
     /* Check for numeric type w/unusual # of unused bits */
     if (H5T_is_numeric_with_unusual_unused_bits(dt))
         /* Throw an error if the object header is not checksummed, unless the
          * H5F_RFIC_UNUSUAL_NUM_UNUSED_NUMERIC_BITS flag is set with
          * H5Pset_relax_file_integrity_checks() to suppress it.
          */
         if (!(*ioflags & H5O_DECODEIO_RFIC_UNUBNT))
             HGOTO_ERROR(
                 H5E_DATATYPE, H5E_BADVALUE, FAIL,
                 "datatype has unusually large # of unused bits (prec = %zu bits, size = %zu bytes), possibly "
                 "corrupted file. See documentation for H5Pset_relax_file_integrity_checks for details.",
                 dt->shared->u.atomic.prec, dt->shared->size);
diff --git a/src/H5Oefl.c b/src/H5Oefl.c
index 57e5e6991d..351dbd3021 100644
--- a/src/H5Oefl.c
+++ b/src/H5Oefl.c
@@ -74,102 +74,106 @@ static void *
 H5O__efl_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh, unsigned H5_ATTR_UNUSED mesg_flags,
                 unsigned H5_ATTR_UNUSED *ioflags, size_t p_size, const uint8_t *p)
 {
     H5O_efl_t     *mesg = NULL;
     int            version;
-    const uint8_t *p_end     = p + p_size - 1; /* pointer to last byte in p */
-    const char    *s         = NULL;
-    H5HL_t        *heap      = NULL;
+    const uint8_t *p_end = p + p_size - 1; /* pointer to last byte in p */
+    const char    *s     = NULL;
+    H5HL_t        *heap  = NULL;
+    size_t         block_size;       /* Size of the heap block */
     void          *ret_value = NULL; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Check args */
     assert(f);
     assert(p);
 
     if (NULL == (mesg = (H5O_efl_t *)H5MM_calloc(sizeof(H5O_efl_t))))
         HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, NULL, "memory allocation failed");
 
     /* Version (1 byte) */
     if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     version = *p++;
     if (version != H5O_EFL_VERSION)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTLOAD, NULL, "bad version number for external file list message");
 
     /* Reserved (3 bytes) */
     if (H5_IS_BUFFER_OVERFLOW(p, 3, p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     p += 3;
 
     /* Number of slots (2x 2 bytes) */
     if (H5_IS_BUFFER_OVERFLOW(p, 2, p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     UINT16DECODE(p, mesg->nalloc);
     if (mesg->nalloc <= 0)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTLOAD, NULL, "bad number of allocated slots when parsing efl msg");
 
     if (H5_IS_BUFFER_OVERFLOW(p, 2, p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     UINT16DECODE(p, mesg->nused);
     if (mesg->nused > mesg->nalloc)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTLOAD, NULL, "bad number of in-use slots when parsing efl msg");
 
     /* Heap address */
     if (H5_IS_BUFFER_OVERFLOW(p, H5F_sizeof_addr(f), p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     H5F_addr_decode(f, &p, &(mesg->heap_addr));
     if (H5_addr_defined(mesg->heap_addr) == false)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTLOAD, NULL, "bad local heap address when parsing efl msg");
 
     /* Decode the file list */
     mesg->slot = (H5O_efl_entry_t *)H5MM_calloc(mesg->nalloc * sizeof(H5O_efl_entry_t));
     if (NULL == mesg->slot)
         HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, NULL, "memory allocation failed");
 
     if (NULL == (heap = H5HL_protect(f, mesg->heap_addr, H5AC__READ_ONLY_FLAG)))
         HGOTO_ERROR(H5E_OHDR, H5E_CANTPROTECT, NULL, "unable to protect local heap");
 
 #ifdef H5O_DEBUG
     /* Verify that the name at offset 0 in the local heap is the empty string */
     s = (const char *)H5HL_offset_into(heap, 0);
     if (s == NULL)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, NULL, "could not obtain pointer into local heap");
     if (*s != '\0')
         HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, NULL, "entry at offset 0 in local heap not an empty string");
 #endif
 
+    /* Get the size of the heap block */
+    block_size = H5HL_heap_get_size(heap);
+
     for (size_t u = 0; u < mesg->nused; u++) {
 
         hsize_t offset = 0;
 
         /* Name */
         if (H5_IS_BUFFER_OVERFLOW(p, H5F_sizeof_size(f), p_end))
             HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
         H5F_DECODE_LENGTH(f, p, mesg->slot[u].name_offset);
 
         if ((s = (const char *)H5HL_offset_into(heap, mesg->slot[u].name_offset)) == NULL)
             HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, NULL, "unable to get external file name");
         if (*s == '\0')
             HGOTO_ERROR(H5E_OHDR, H5E_CANTGET, NULL, "invalid external file name");
-        mesg->slot[u].name = H5MM_xstrdup(s);
+        mesg->slot[u].name = H5MM_strndup(s, (block_size - mesg->slot[u].name_offset));
         if (mesg->slot[u].name == NULL)
             HGOTO_ERROR(H5E_OHDR, H5E_NOSPACE, NULL, "string duplication failed");
 
         /* File offset */
         if (H5_IS_BUFFER_OVERFLOW(p, H5F_sizeof_size(f), p_end))
             HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
         H5F_DECODE_LENGTH(f, p, offset); /* Decode into an hsize_t to avoid sign warnings */
         mesg->slot[u].offset = (HDoff_t)offset;
 
         /* Size */
         if (H5_IS_BUFFER_OVERFLOW(p, H5F_sizeof_size(f), p_end))
             HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
         H5F_DECODE_LENGTH(f, p, mesg->slot[u].size);
     }
 
     if (H5HL_unprotect(heap) < 0)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTUNPROTECT, NULL, "unable to unprotect local heap");
 
     /* Set return value */
     ret_value = mesg;
@@ -362,57 +366,59 @@ static herr_t
 H5O__efl_reset(void *_mesg)
 {
     H5O_efl_t *mesg = (H5O_efl_t *)_mesg;
     size_t     u; /* Local index variable */
 
     FUNC_ENTER_PACKAGE_NOERR
 
     /* check args */
     assert(mesg);
 
     /* reset */
     if (mesg->slot) {
         for (u = 0; u < mesg->nused; u++) {
             mesg->slot[u].name        = (char *)H5MM_xfree(mesg->slot[u].name);
             mesg->slot[u].name_offset = 0;
         } /* end for */
         mesg->slot = (H5O_efl_entry_t *)H5MM_xfree(mesg->slot);
     } /* end if */
     mesg->heap_addr = HADDR_UNDEF;
     mesg->nused = mesg->nalloc = 0;
 
     FUNC_LEAVE_NOAPI(SUCCEED)
 } /* end H5O__efl_reset() */
 
 /*-------------------------------------------------------------------------
  * Function:	H5O_efl_total_size
  *
- * Purpose:	Return the total size of the external file list by summing
+ * Purpose:	Query the total size of the external file list by summing
  *		the sizes of all of the files.
  *
- * Return:	Success:	Total reserved size for external data.
- *
- *		Failure:	0
+ * Return:	Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
-hsize_t
-H5O_efl_total_size(H5O_efl_t *efl)
+herr_t
+H5O_efl_total_size(const H5O_efl_t *efl, hsize_t *size)
 {
-    hsize_t ret_value = 0, tmp;
+    hsize_t total_size = 0, tmp;
+    herr_t  ret_value  = SUCCEED; /* Return value */
 
-    FUNC_ENTER_NOAPI(0)
+    FUNC_ENTER_NOAPI(FAIL)
 
     if (efl->nused > 0 && H5O_EFL_UNLIMITED == efl->slot[efl->nused - 1].size)
-        ret_value = H5O_EFL_UNLIMITED;
+        *size = H5O_EFL_UNLIMITED;
     else {
         size_t u; /* Local index variable */
 
-        for (u = 0; u < efl->nused; u++, ret_value = tmp) {
-            tmp = ret_value + efl->slot[u].size;
-            if (tmp <= ret_value)
-                HGOTO_ERROR(H5E_EFL, H5E_OVERFLOW, 0, "total external storage size overflowed");
+        for (u = 0; u < efl->nused; u++, total_size = tmp) {
+            tmp = total_size + efl->slot[u].size;
+            if (tmp < total_size)
+                HGOTO_ERROR(H5E_EFL, H5E_OVERFLOW, FAIL, "total external storage size overflowed");
         } /* end for */
-    }     /* end else */
+
+        /* Set the size to return */
+        *size = total_size;
+    } /* end else */
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
diff --git a/src/H5Olayout.c b/src/H5Olayout.c
index d14e000995..e5ffc38247 100644
--- a/src/H5Olayout.c
+++ b/src/H5Olayout.c
@@ -1223,85 +1223,88 @@ static void *
 H5O__layout_copy_file(H5F_t *file_src, void *mesg_src, H5F_t *file_dst, bool H5_ATTR_UNUSED *recompute_size,
                       unsigned H5_ATTR_UNUSED *mesg_flags, H5O_copy_t *cpy_info, void *_udata)
 {
     H5D_copy_file_ud_t *udata      = (H5D_copy_file_ud_t *)_udata; /* Dataset copying user data */
     H5O_layout_t       *layout_src = (H5O_layout_t *)mesg_src;
     H5O_layout_t       *layout_dst = NULL;
-    bool                copied     = false; /* Whether the data was copied */
-    void               *ret_value  = NULL;  /* Return value */
+    void               *ret_value  = NULL; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check args */
     assert(file_src);
     assert(layout_src);
     assert(file_dst);
 
     /* Copy the layout information */
     if (NULL == (layout_dst = (H5O_layout_t *)H5O__layout_copy(layout_src, NULL)))
         HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, NULL, "unable to copy layout");
 
     /* Copy the layout type specific information */
     switch (layout_src->type) {
         case H5D_COMPACT:
             if (layout_src->storage.u.compact.buf) {
                 /* copy compact raw data */
                 if (H5D__compact_copy(file_src, &layout_src->storage.u.compact, file_dst,
                                       &layout_dst->storage.u.compact, udata->src_dtype, cpy_info) < 0)
                     HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, NULL, "unable to copy chunked storage");
-                copied = true;
             } /* end if */
             break;
 
-        case H5D_CONTIGUOUS:
+        case H5D_CONTIGUOUS: {
+            hsize_t nelmts;  /* Number of elements in dataset's extent */
+            size_t  dt_size; /* Size of dataset's datatype in bytes */
+            /* Sanity check the dataset's info */
+            if (H5D__contig_check(file_src, layout_src, udata->src_space_extent, udata->src_dtype) < 0)
+                HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, NULL, "invalid layout / dataspace / datatype info");
+
             /* Compute the size of the contiguous storage for versions of the
              * layout message less than version 3 because versions 1 & 2 would
              * truncate the dimension sizes to 32-bits of information. - QAK 5/26/04
              */
+            nelmts  = H5S_extent_nelem(udata->src_space_extent);
+            dt_size = H5T_get_size(udata->src_dtype);
             if (layout_src->version < H5O_LAYOUT_VERSION_3)
-                layout_dst->storage.u.contig.size =
-                    H5S_extent_nelem(udata->src_space_extent) * H5T_get_size(udata->src_dtype);
+                layout_dst->storage.u.contig.size = nelmts * dt_size;
+            else
+                /* Sanity check layout storage size */
+                if (layout_dst->storage.u.contig.size != (nelmts * dt_size))
+                    HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, NULL, "invalid layout storage size ");
 
             if (H5D__contig_is_space_alloc(&layout_src->storage) ||
                 (cpy_info->shared_fo &&
                  H5D__contig_is_data_cached((const H5D_shared_t *)cpy_info->shared_fo))) {
                 /* copy contiguous raw data */
                 if (H5D__contig_copy(file_src, &layout_src->storage.u.contig, file_dst,
                                      &layout_dst->storage.u.contig, udata->src_dtype, cpy_info) < 0)
                     HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, NULL, "unable to copy contiguous storage");
-                copied = true;
             } /* end if */
-            break;
+        } break;
 
         case H5D_CHUNKED:
             if (H5D__chunk_is_space_alloc(&layout_src->storage) ||
                 (cpy_info->shared_fo &&
                  H5D__chunk_is_data_cached((const H5D_shared_t *)cpy_info->shared_fo))) {
                 /* Create chunked layout */
                 if (H5D__chunk_copy(file_src, &layout_src->storage.u.chunk, &layout_src->u.chunk, file_dst,
                                     &layout_dst->storage.u.chunk, udata->src_space_extent, udata->src_dtype,
                                     udata->common.src_pline, cpy_info) < 0)
                     HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, NULL, "unable to copy chunked storage");
-                copied = true;
             } /* end if */
             break;
 
         case H5D_VIRTUAL:
             /* Copy virtual layout.  Always copy so the memory fields get copied
              * properly. */
             if (H5D__virtual_copy(file_dst, layout_dst) < 0)
                 HGOTO_ERROR(H5E_OHDR, H5E_CANTCOPY, NULL, "unable to copy virtual storage");
             break;
 
         case H5D_LAYOUT_ERROR:
         case H5D_NLAYOUTS:
         default:
             HGOTO_ERROR(H5E_OHDR, H5E_CANTLOAD, NULL, "Invalid layout class");
     } /* end switch */
 
-    /* Check if copy routine was invoked (which frees the source datatype) */
-    if (copied)
-        udata->src_dtype = NULL;
-
     /* Set return value */
     ret_value = layout_dst;
 
diff --git a/src/H5Opkg.h b/src/H5Opkg.h
index 8e32f3ae13..1803ae0daa 100644
--- a/src/H5Opkg.h
+++ b/src/H5Opkg.h
@@ -600,8 +600,8 @@ H5_DLL herr_t H5O__condense_header(H5F_t *f, H5O_t *oh);
 H5_DLL herr_t H5O__release_mesg(H5F_t *f, H5O_t *oh, H5O_mesg_t *mesg, bool adj_link);
 
 /* Shared object operators */
-H5_DLL void  *H5O__shared_decode(H5F_t *f, H5O_t *open_oh, unsigned *ioflags, const uint8_t *buf,
-                                 const H5O_msg_class_t *type);
+H5_DLL void  *H5O__shared_decode(H5F_t *f, H5O_t *open_oh, unsigned *ioflags, size_t buf_size,
+                                 const uint8_t *buf, const H5O_msg_class_t *type);
 H5_DLL herr_t H5O__shared_encode(const H5F_t *f, uint8_t *buf /*out*/, const H5O_shared_t *sh_mesg);
 H5_DLL size_t H5O__shared_size(const H5F_t *f, const H5O_shared_t *sh_mesg);
 H5_DLL herr_t H5O__shared_delete(H5F_t *f, H5O_t *open_oh, const H5O_msg_class_t *mesg_type,
diff --git a/src/H5Oprivate.h b/src/H5Oprivate.h
index 968a23caad..3f0ff07cd1 100644
--- a/src/H5Oprivate.h
+++ b/src/H5Oprivate.h
@@ -1004,7 +1004,7 @@ H5_DLL herr_t     H5O_loc_free(H5O_loc_t *loc);
 H5_DLL H5O_loc_t *H5O_get_loc(hid_t id);
 
 /* EFL operators */
-H5_DLL hsize_t H5O_efl_total_size(H5O_efl_t *efl);
+H5_DLL herr_t H5O_efl_total_size(const H5O_efl_t *efl, hsize_t *size);
 
 /* File space info routines */
 H5_DLL herr_t H5O_fsinfo_set_version(H5F_libver_t low, H5F_libver_t high, H5O_fsinfo_t *fsinfo);
diff --git a/src/H5Osdspace.c b/src/H5Osdspace.c
index 1658fa719f..365e351124 100644
--- a/src/H5Osdspace.c
+++ b/src/H5Osdspace.c
@@ -105,113 +105,115 @@ static void *
 H5O__sdspace_decode(H5F_t *f, H5O_t H5_ATTR_UNUSED *open_oh, unsigned H5_ATTR_UNUSED mesg_flags,
                     unsigned H5_ATTR_UNUSED *ioflags, size_t p_size, const uint8_t *p)
 {
     const uint8_t *p_end = p + p_size - 1; /* End of the p buffer */
     H5S_extent_t  *sdim  = NULL;           /* New extent dimensionality structure */
     unsigned       flags, version;
     unsigned       i;
     void          *ret_value = NULL; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     assert(f);
     assert(p);
 
     if (NULL == (sdim = H5FL_CALLOC(H5S_extent_t)))
         HGOTO_ERROR(H5E_DATASPACE, H5E_CANTALLOC, NULL, "dataspace structure allocation failed");
     sdim->type = H5S_NO_CLASS;
 
     /* Check version */
     if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     version = *p++;
 
     if (version < H5O_SDSPACE_VERSION_1 || version > H5O_SDSPACE_VERSION_2)
         HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, NULL, "wrong version number in dataspace message");
     sdim->version = version;
 
     /* Get rank */
     if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     sdim->rank = *p++;
 
     if (sdim->rank > H5S_MAX_RANK)
         HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, NULL, "simple dataspace dimensionality is too large");
 
     /* Get dataspace flags for later */
     if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
         HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     flags = *p++;
 
     /* Get or determine the type of the extent */
     if (version >= H5O_SDSPACE_VERSION_2) {
         if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
             HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
         sdim->type = (H5S_class_t)*p++;
 
         if (sdim->type != H5S_SIMPLE && sdim->rank > 0)
             HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, NULL, "invalid rank for scalar or NULL dataspace");
     }
     else {
         /* Set the dataspace type to be simple or scalar as appropriate
          * (version 1 does not allow H5S_NULL)
          */
         if (sdim->rank > 0)
             sdim->type = H5S_SIMPLE;
         else
             sdim->type = H5S_SCALAR;
 
         /* Increment past reserved byte */
         if (H5_IS_BUFFER_OVERFLOW(p, 1, p_end))
             HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
         p++;
     }
 
     /* Version 1 has 4 reserved bytes */
     if (version == H5O_SDSPACE_VERSION_1) {
         if (H5_IS_BUFFER_OVERFLOW(p, 4, p_end))
             HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
         p += 4;
     }
 
     /* Decode dimension sizes */
     if (sdim->rank > 0) {
-
-        /* Sizes */
-
         /* Check that we have space to decode sdim->rank values */
         if (H5_IS_BUFFER_OVERFLOW(p, (H5F_sizeof_size(f) * sdim->rank), p_end))
             HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
 
+        /* Sizes */
         if (NULL == (sdim->size = (hsize_t *)H5FL_ARR_MALLOC(hsize_t, (size_t)sdim->rank)))
             HGOTO_ERROR(H5E_RESOURCE, H5E_CANTALLOC, NULL, "memory allocation failed");
         for (i = 0; i < sdim->rank; i++)
             H5F_DECODE_LENGTH(f, p, sdim->size[i]);
 
-        /* Max sizes */
-
         if (flags & H5S_VALID_MAX) {
-            if (NULL == (sdim->max = (hsize_t *)H5FL_ARR_MALLOC(hsize_t, (size_t)sdim->rank)))
-                HGOTO_ERROR(H5E_RESOURCE, H5E_CANTALLOC, NULL, "memory allocation failed");
-
             /* Check that we have space to decode sdim->rank values */
             if (H5_IS_BUFFER_OVERFLOW(p, (H5F_sizeof_size(f) * sdim->rank), p_end))
                 HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
-            for (i = 0; i < sdim->rank; i++)
+
+            /* Max sizes */
+            if (NULL == (sdim->max = (hsize_t *)H5FL_ARR_MALLOC(hsize_t, (size_t)sdim->rank)))
+                HGOTO_ERROR(H5E_RESOURCE, H5E_CANTALLOC, NULL, "memory allocation failed");
+            for (i = 0; i < sdim->rank; i++) {
                 H5F_DECODE_LENGTH(f, p, sdim->max[i]);
+                if (sdim->size[i] > sdim->max[i])
+                    HGOTO_ERROR(H5E_OHDR, H5E_BADVALUE, NULL,
+                                "dataspace dim %u size of %llu is greater than maxdim size of %llu", i,
+                                (unsigned long long)sdim->size[i], (unsigned long long)sdim->max[i]);
+            }
         }
 
         /* NOTE: The version 1 permutation indexes were never implemented so
          *       there is nothing to decode.
          */
     }
 
     /* Compute the number of elements in the extent */
     if (sdim->type == H5S_NULL)
         sdim->nelem = 0;
     else {
         for (i = 0, sdim->nelem = 1; i < sdim->rank; i++)
             sdim->nelem *= sdim->size[i];
     }
 
     /* Set return value */
     ret_value = (void *)sdim;
diff --git a/src/H5Oshared.c b/src/H5Oshared.c
index 9c32caf426..d562d1764a 100644
--- a/src/H5Oshared.c
+++ b/src/H5Oshared.c
@@ -286,72 +286,88 @@ done:
  *-------------------------------------------------------------------------
  */
 void *
-H5O__shared_decode(H5F_t *f, H5O_t *open_oh, unsigned *ioflags, const uint8_t *buf,
+H5O__shared_decode(H5F_t *f, H5O_t *open_oh, unsigned *ioflags, size_t buf_size, const uint8_t *buf,
                    const H5O_msg_class_t *type)
 {
-    H5O_shared_t sh_mesg;          /* Shared message info */
-    unsigned     version;          /* Shared message version */
-    void        *ret_value = NULL; /* Return value */
+    const uint8_t *buf_end = buf + buf_size - 1; /* End of the buffer */
+    H5O_shared_t   sh_mesg;                      /* Shared message info */
+    unsigned       version;                      /* Shared message version */
+    void          *ret_value = NULL;             /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Check args */
     assert(f);
     assert(buf);
     assert(type);
 
     /* Version */
+    if (H5_IS_BUFFER_OVERFLOW(buf, 1, buf_end))
+        HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     version = *buf++;
     if (version < H5O_SHARED_VERSION_1 || version > H5O_SHARED_VERSION_LATEST)
         HGOTO_ERROR(H5E_OHDR, H5E_CANTLOAD, NULL, "bad version number for shared object message");
 
     /* Get the shared information type
      * Flags are unused before version 3.
      */
+    if (H5_IS_BUFFER_OVERFLOW(buf, 1, buf_end))
+        HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
     if (version >= H5O_SHARED_VERSION_2)
         sh_mesg.type = *buf++;
     else {
         sh_mesg.type = H5O_SHARE_TYPE_COMMITTED;
         buf++;
     } /* end else */
 
     /* Skip reserved bytes (for version 1) */
-    if (version == H5O_SHARED_VERSION_1)
+    if (version == H5O_SHARED_VERSION_1) {
+        if (H5_IS_BUFFER_OVERFLOW(buf, 6, buf_end))
+            HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
         buf += 6;
+    }
 
     /* Body */
     if (version == H5O_SHARED_VERSION_1) {
         /* Initialize other location fields */
         sh_mesg.u.loc.index = 0;
 
         /* Decode stored "symbol table entry" into message location */
+        if (H5_IS_BUFFER_OVERFLOW(buf, H5F_SIZEOF_SIZE(f), buf_end))
+            HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
         buf += H5F_SIZEOF_SIZE(f); /* Skip over local heap address */
+        if (H5_IS_BUFFER_OVERFLOW(buf, H5F_sizeof_addr(f), buf_end))
+            HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
         H5F_addr_decode(f, &buf, &(sh_mesg.u.loc.oh_addr));
     } /* end if */
     else if (version >= H5O_SHARED_VERSION_2) {
         /* If this message is in the heap, copy a heap ID.
          * Otherwise, it is a named datatype, so copy an H5O_loc_t.
          */
         if (sh_mesg.type == H5O_SHARE_TYPE_SOHM) {
             assert(version >= H5O_SHARED_VERSION_3);
+            if (H5_IS_BUFFER_OVERFLOW(buf, sizeof(sh_mesg.u.heap_id), buf_end))
+                HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
             H5MM_memcpy(&sh_mesg.u.heap_id, buf, sizeof(sh_mesg.u.heap_id));
         } /* end if */
         else {
             /* The H5O_COMMITTED_FLAG should be set if this message
              * is from an older version before the flag existed.
              */
             if (version < H5O_SHARED_VERSION_3)
                 sh_mesg.type = H5O_SHARE_TYPE_COMMITTED;
 
             sh_mesg.u.loc.index = 0;
+            if (H5_IS_BUFFER_OVERFLOW(buf, H5F_sizeof_addr(f), buf_end))
+                HGOTO_ERROR(H5E_OHDR, H5E_OVERFLOW, NULL, "ran off end of input buffer while decoding");
             H5F_addr_decode(f, &buf, &sh_mesg.u.loc.oh_addr);
         } /* end else */
     }     /* end else if */
 
     /* Set file pointer & message type for all types of shared messages */
     sh_mesg.file        = f;
     sh_mesg.msg_type_id = type->id;
 
     /* Retrieve actual message, through decoded shared message info */
     if (NULL == (ret_value = H5O__shared_read(f, open_oh, ioflags, &sh_mesg, type)))
         HGOTO_ERROR(H5E_OHDR, H5E_READERROR, NULL, "unable to retrieve native message");
diff --git a/src/H5Oshared.h b/src/H5Oshared.h
index 2813badd33..d22e2e1b14 100644
--- a/src/H5Oshared.h
+++ b/src/H5Oshared.h
@@ -40,36 +40,36 @@ static inline void *
 H5O_SHARED_DECODE(H5F_t *f, H5O_t *open_oh, unsigned mesg_flags, unsigned *ioflags, size_t p_size,
                   const uint8_t *p)
 {
     void *ret_value = NULL; /* Return value */
 
     FUNC_ENTER_NOAPI_NOINIT
 
 #ifndef H5O_SHARED_TYPE
 #error "Need to define H5O_SHARED_TYPE macro!"
 #endif /* H5O_SHARED_TYPE */
 #ifndef H5O_SHARED_DECODE
 #error "Need to define H5O_SHARED_DECODE macro!"
 #endif /* H5O_SHARED_DECODE */
 #ifndef H5O_SHARED_DECODE_REAL
 #error "Need to define H5O_SHARED_DECODE_REAL macro!"
 #endif /* H5O_SHARED_DECODE_REAL */
 
     /* Check for shared message */
     if (mesg_flags & H5O_MSG_FLAG_SHARED) {
         /* Retrieve native message info indirectly through shared message */
-        if (NULL == (ret_value = H5O__shared_decode(f, open_oh, ioflags, p, H5O_SHARED_TYPE)))
+        if (NULL == (ret_value = H5O__shared_decode(f, open_oh, ioflags, p_size, p, H5O_SHARED_TYPE)))
             HGOTO_ERROR(H5E_OHDR, H5E_CANTDECODE, NULL, "unable to decode shared message");
 
             /* We currently do not support automatically fixing shared messages */
 #ifdef H5_STRICT_FORMAT_CHECKS
         if (*ioflags & H5O_DECODEIO_DIRTY)
             HGOTO_ERROR(H5E_OHDR, H5E_UNSUPPORTED, NULL, "unable to mark shared message dirty");
 #else  /* H5_STRICT_FORMAT_CHECKS */
         *ioflags &= ~H5O_DECODEIO_DIRTY;
 #endif /* H5_STRICT_FORMAT_CHECKS */
     }  /* end if */
     else {
         /* Decode native message directly */
         if (NULL == (ret_value = H5O_SHARED_DECODE_REAL(f, open_oh, mesg_flags, ioflags, p_size, p)))
             HGOTO_ERROR(H5E_OHDR, H5E_CANTDECODE, NULL, "unable to decode native message");
     } /* end else */
diff --git a/src/H5Ostab.c b/src/H5Ostab.c
index 5000ca84d7..c87034dc13 100644
--- a/src/H5Ostab.c
+++ b/src/H5Ostab.c
@@ -328,45 +328,54 @@ static herr_t
 H5O__stab_post_copy_file(const H5O_loc_t *src_oloc, const void *mesg_src, H5O_loc_t *dst_oloc, void *mesg_dst,
                          unsigned H5_ATTR_UNUSED *mesg_flags, H5O_copy_t *cpy_info)
 {
     const H5O_stab_t *stab_src = (const H5O_stab_t *)mesg_src;
     H5O_stab_t       *stab_dst = (H5O_stab_t *)mesg_dst;
     H5G_bt_it_cpy_t   udata;               /* B-tree user data */
+    H5HL_t           *heap      = NULL;    /* Pointer to source group's heap */
     herr_t            ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check args */
     assert(stab_src);
     assert(H5_addr_defined(dst_oloc->addr));
     assert(dst_oloc->file);
     assert(stab_dst);
     assert(cpy_info);
 
     /* If we are performing a 'shallow hierarchy' copy, get out now */
     if (cpy_info->max_depth >= 0 && cpy_info->curr_depth >= cpy_info->max_depth)
         HGOTO_DONE(SUCCEED);
 
+    /* Get the heap for the copy*/
+    if (NULL == (heap = H5HL_protect(src_oloc->file, stab_src->heap_addr, H5AC__READ_ONLY_FLAG)))
+        HGOTO_ERROR(H5E_SYM, H5E_PROTECT, FAIL, "unable to protect local heap");
+
     /* Set up B-tree iteration user data */
-    udata.src_oloc      = src_oloc;
-    udata.src_heap_addr = stab_src->heap_addr;
-    udata.dst_file      = dst_oloc->file;
-    udata.dst_stab      = stab_dst;
-    udata.cpy_info      = cpy_info;
+    udata.src_oloc       = src_oloc;
+    udata.src_heap       = heap;
+    udata.src_block_size = H5HL_heap_get_size(heap);
+    udata.dst_file       = dst_oloc->file;
+    udata.dst_stab       = stab_dst;
+    udata.cpy_info       = cpy_info;
 
     /* Iterate over objects in group, copying them */
     if ((H5B_iterate(src_oloc->file, H5B_SNODE, stab_src->btree_addr, H5G__node_copy, &udata)) < 0)
         HGOTO_ERROR(H5E_SYM, H5E_CANTINIT, FAIL, "iteration operator failed");
 
 done:
+    if (heap && H5HL_unprotect(heap) < 0)
+        HDONE_ERROR(H5E_SYM, H5E_CANTUNPROTECT, FAIL, "unable to unprotect local heap");
+
     FUNC_LEAVE_NOAPI(ret_value)
 } /* H5O__stab_post_copy_file() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5O__stab_debug
  *
  * Purpose:     Prints debugging info for a symbol table message.
  *
  * Return:      Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5S.c b/src/H5S.c
index 722eac8b56..65d7c49b6a 100644
--- a/src/H5S.c
+++ b/src/H5S.c
@@ -1218,55 +1218,56 @@ herr_t
 H5S_set_extent_simple(H5S_t *space, unsigned rank, const hsize_t *dims, const hsize_t *max)
 {
     unsigned u;                   /* Local index variable */
     herr_t   ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_NOAPI(FAIL)
 
     /* Check args */
-    assert(rank <= H5S_MAX_RANK);
+    if (rank > H5S_MAX_RANK)
+        HGOTO_ERROR(H5E_DATASPACE, H5E_BADRANGE, FAIL, "dataspace rank too large: %u", rank);
 
     /* shift out of the previous state to a "simple" dataspace.  */
     if (H5S__extent_release(&space->extent) < 0)
         HGOTO_ERROR(H5E_RESOURCE, H5E_CANTFREE, FAIL, "failed to release previous dataspace extent");
 
     if (rank == 0) { /* scalar variable */
         space->extent.type  = H5S_SCALAR;
         space->extent.nelem = 1;
         space->extent.rank  = 0; /* set to scalar rank */
     }                            /* end if */
     else {
         hsize_t nelem; /* Number of elements in extent */
 
         space->extent.type = H5S_SIMPLE;
 
         /* Set the rank and allocate space for the dims */
         space->extent.rank = rank;
         space->extent.size = (hsize_t *)H5FL_ARR_MALLOC(hsize_t, (size_t)rank);
 
         /* Copy the dimensions & compute the number of elements in the extent */
         for (u = 0, nelem = 1; dims && (u < space->extent.rank); u++) {
             space->extent.size[u] = dims[u];
             nelem *= dims[u];
         } /* end for */
         space->extent.nelem = nelem;
 
         /* Copy the maximum dimensions if specified. Otherwise, the maximal dimensions are the
          * same as the dimension */
         space->extent.max = (hsize_t *)H5FL_ARR_MALLOC(hsize_t, (size_t)rank);
         if (max != NULL)
             H5MM_memcpy(space->extent.max, max, sizeof(hsize_t) * rank);
         else
             for (u = 0; dims && (u < space->extent.rank); u++)
                 space->extent.max[u] = dims[u];
     } /* end else */
 
     /* Selection related cleanup */
 
     /* Set offset to zeros */
     memset(space->select.offset, 0, sizeof(hsize_t) * space->extent.rank);
     space->select.offset_changed = false;
 
     /* If the selection is 'all', update the number of elements selected */
     if (H5S_GET_SELECT_TYPE(space) == H5S_SEL_ALL)
         if (H5S_select_all(space, false) < 0)
             HGOTO_ERROR(H5E_DATASPACE, H5E_CANTDELETE, FAIL, "can't change selection");
@@ -1590,23 +1591,47 @@ H5S_decode(const unsigned char **p)
 done:
     /* Release fake file structure */
     if (f && H5F_fake_free(f) < 0)
         HDONE_ERROR(H5E_DATASPACE, H5E_CANTRELEASE, NULL, "unable to release fake file struct");
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5S_decode() */
 
+/*-------------------------------------------------------------------------
+ * Function:    H5S_get_simple_extent
+ *
+ * Purpose:     Internal function for retrieving the extent for a dataspace object
+ *
+ * Return:      Success:    Pointer to the extent for a dataspace (not copied)
+ *              Failure:    NULL
+ *
+ * Note:        This routine participates in the "Inlining C function pointers"
+ *              pattern, don't call it directly, use the appropriate macro
+ *              defined in H5Sprivate.h.
+ *
+ *-------------------------------------------------------------------------
+ */
+const H5S_extent_t *
+H5S_get_simple_extent(const H5S_t *space)
+{
+    FUNC_ENTER_NOAPI_NOINIT_NOERR
+
+    assert(space);
+
+    FUNC_LEAVE_NOAPI(&space->extent)
+} /* end H5S_get_simple_extent() */
+
 /*-------------------------------------------------------------------------
  * Function:    H5S_get_simple_extent_type
  *
  * Purpose:     Internal function for retrieving the type of extent for a dataspace object
  *
  * Return:      Success:    The class of the dataspace object
  *
  *              Failure:    N5S_NO_CLASS
  *
  * Note:        This routine participates in the "Inlining C function pointers"
  *              pattern, don't call it directly, use the appropriate macro
  *              defined in H5Sprivate.h.
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Spoint.c b/src/H5Spoint.c
index 7e66a03a5f..690cb6592a 100644
--- a/src/H5Spoint.c
+++ b/src/H5Spoint.c
@@ -1352,163 +1352,171 @@ static herr_t
 H5S__point_deserialize(H5S_t **space, const uint8_t **p, const size_t p_size, bool skip)
 {
     H5S_t *tmp_space = NULL;                 /* Pointer to actual dataspace to use,
                                                 either *space or a newly allocated one */
     hsize_t        dims[H5S_MAX_RANK];       /* Dimension sizes */
     uint32_t       version;                  /* Version number */
     uint8_t        enc_size = 0;             /* Encoded size of selection info */
     hsize_t       *coord    = NULL, *tcoord; /* Pointer to array of elements */
     const uint8_t *pp;                       /* Local pointer for decoding */
     uint64_t       num_elem = 0;             /* Number of elements in selection */
     unsigned       rank;                     /* Rank of points */
     unsigned       i, j;                     /* local counting variables */
     size_t         enc_type_size;
     size_t         coordinate_buffer_requirement;
     herr_t         ret_value = SUCCEED;         /* Return value */
     const uint8_t *p_end     = *p + p_size - 1; /* Pointer to last valid byte in buffer */
     FUNC_ENTER_PACKAGE
 
     /* Check args */
     assert(p);
     pp = (*p);
     assert(pp);
 
     /* As part of the efforts to push all selection-type specific coding
        to the callbacks, the coding for the allocation of a null dataspace
        is moved from H5S_select_deserialize() in H5Sselect.c to here.
        This is needed for decoding virtual layout in H5O__layout_decode() */
     /* Allocate space if not provided */
     if (!*space) {
         if (NULL == (tmp_space = H5S_create(H5S_SIMPLE)))
             HGOTO_ERROR(H5E_DATASPACE, H5E_CANTCREATE, FAIL, "can't create dataspace");
     } /* end if */
     else
         tmp_space = *space;
 
     /* Decode version */
     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, pp, sizeof(uint32_t), p_end))
         HGOTO_ERROR(H5E_DATASPACE, H5E_OVERFLOW, FAIL, "buffer overflow while decoding selection version");
     UINT32DECODE(pp, version);
 
     if (version < H5S_POINT_VERSION_1 || version > H5S_POINT_VERSION_LATEST)
         HGOTO_ERROR(H5E_DATASPACE, H5E_BADVALUE, FAIL, "bad version number for point selection");
 
     if (version >= (uint32_t)H5S_POINT_VERSION_2) {
         /* Decode size of point info */
         if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, pp, 1, p_end))
             HGOTO_ERROR(H5E_DATASPACE, H5E_OVERFLOW, FAIL, "buffer overflow while decoding point info");
         enc_size = *(pp)++;
     }
     else {
         /* Skip over the remainder of the header */
         if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, pp, 8, p_end))
             HGOTO_ERROR(H5E_DATASPACE, H5E_OVERFLOW, FAIL,
                         "buffer overflow while decoding selection headers");
         pp += 8;
         enc_size = H5S_SELECT_INFO_ENC_SIZE_4;
     }
 
     /* Check encoded size */
     if (enc_size & ~H5S_SELECT_INFO_ENC_SIZE_BITS)
         HGOTO_ERROR(H5E_DATASPACE, H5E_CANTLOAD, FAIL, "unknown size of point/offset info for selection");
 
     /* Decode the rank of the point selection */
     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, pp, sizeof(uint32_t), p_end))
         HGOTO_ERROR(H5E_DATASPACE, H5E_OVERFLOW, FAIL, "buffer overflow while decoding selection rank");
     UINT32DECODE(pp, rank);
+    if (0 == rank || rank > H5S_MAX_RANK)
+        HGOTO_ERROR(H5E_DATASPACE, H5E_BADVALUE, FAIL, "invalid rank (%u) for serialized point selection",
+                    rank);
 
     if (!*space) {
         /* Patch the rank of the allocated dataspace */
         (void)memset(dims, 0, (size_t)rank * sizeof(dims[0]));
         if (H5S_set_extent_simple(tmp_space, rank, dims, NULL) < 0)
             HGOTO_ERROR(H5E_DATASPACE, H5E_CANTINIT, FAIL, "can't set dimensions");
     } /* end if */
     else
         /* Verify the rank of the provided dataspace */
         if (rank != tmp_space->extent.rank)
             HGOTO_ERROR(H5E_DATASPACE, H5E_BADRANGE, FAIL,
                         "rank of serialized selection does not match dataspace");
 
     /* decode the number of points */
     switch (enc_size) {
         case H5S_SELECT_INFO_ENC_SIZE_2:
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, pp, sizeof(uint16_t), p_end))
                 HGOTO_ERROR(H5E_DATASPACE, H5E_OVERFLOW, FAIL,
                             "buffer overflow while decoding number of points");
 
             UINT16DECODE(pp, num_elem);
             break;
         case H5S_SELECT_INFO_ENC_SIZE_4:
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, pp, sizeof(uint32_t), p_end))
                 HGOTO_ERROR(H5E_DATASPACE, H5E_OVERFLOW, FAIL,
                             "buffer overflow while decoding number of points");
 
             UINT32DECODE(pp, num_elem);
             break;
         case H5S_SELECT_INFO_ENC_SIZE_8:
             if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, pp, sizeof(uint64_t), p_end))
                 HGOTO_ERROR(H5E_DATASPACE, H5E_OVERFLOW, FAIL,
                             "buffer overflow while decoding number of points");
 
             UINT64DECODE(pp, num_elem);
             break;
         default:
             HGOTO_ERROR(H5E_DATASPACE, H5E_UNSUPPORTED, FAIL, "unknown point info size");
             break;
     } /* end switch */
 
-    /* Allocate space for the coordinates */
-    if (NULL == (coord = (hsize_t *)H5MM_malloc(num_elem * rank * sizeof(hsize_t))))
-        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "can't allocate coordinate information");
-
     /* Determine necessary size of buffer for coordinates */
     enc_type_size = 0;
 
     switch (enc_size) {
         case H5S_SELECT_INFO_ENC_SIZE_2:
             enc_type_size = sizeof(uint16_t);
             break;
         case H5S_SELECT_INFO_ENC_SIZE_4:
             enc_type_size = sizeof(uint32_t);
             break;
         case H5S_SELECT_INFO_ENC_SIZE_8:
             enc_type_size = sizeof(uint64_t);
             break;
         default:
             HGOTO_ERROR(H5E_DATASPACE, H5E_UNSUPPORTED, FAIL, "unknown point info size");
             break;
     }
 
     coordinate_buffer_requirement = num_elem * rank * enc_type_size;
 
+    /* Check for overflow during multiplication */
+    if (num_elem != (coordinate_buffer_requirement / (rank * enc_type_size)))
+        HGOTO_ERROR(H5E_DATASPACE, H5E_OVERFLOW, FAIL, "size of point selection buffer overflowed");
+
+    /* Check for possible buffer overrun */
     if (H5_IS_KNOWN_BUFFER_OVERFLOW(skip, pp, coordinate_buffer_requirement, p_end))
         HGOTO_ERROR(H5E_DATASPACE, H5E_OVERFLOW, FAIL,
                     "buffer overflow while decoding selection coordinates");
 
+    /* Allocate space for the coordinates */
+    if (NULL == (coord = (hsize_t *)H5MM_malloc(num_elem * rank * sizeof(hsize_t))))
+        HGOTO_ERROR(H5E_DATASPACE, H5E_CANTALLOC, FAIL, "can't allocate coordinate information");
+
     /* Retrieve the coordinates from the buffer */
     for (tcoord = coord, i = 0; i < num_elem; i++)
         for (j = 0; j < (unsigned)rank; j++, tcoord++)
             switch (enc_size) {
                 case H5S_SELECT_INFO_ENC_SIZE_2:
                     UINT16DECODE(pp, *tcoord);
                     break;
                 case H5S_SELECT_INFO_ENC_SIZE_4:
                     UINT32DECODE(pp, *tcoord);
                     break;
                 case H5S_SELECT_INFO_ENC_SIZE_8:
                     UINT64DECODE(pp, *tcoord);
                     break;
                 default:
                     HGOTO_ERROR(H5E_DATASPACE, H5E_UNSUPPORTED, FAIL, "unknown point info size");
                     break;
             } /* end switch */
 
     /* Select points */
     if (H5S_select_elements(tmp_space, H5S_SELECT_SET, num_elem, (const hsize_t *)coord) < 0)
         HGOTO_ERROR(H5E_DATASPACE, H5E_CANTDELETE, FAIL, "can't change selection");
 
     /* Update decoding pointer */
     *p = pp;
 
     /* Return space to the caller if allocated */
     if (!*space)
         *space = tmp_space;
diff --git a/src/H5Sprivate.h b/src/H5Sprivate.h
index 8fd73f5474..24a83353f7 100644
--- a/src/H5Sprivate.h
+++ b/src/H5Sprivate.h
@@ -123,73 +123,75 @@ typedef struct H5S_sel_iter_app_op_t {
 typedef struct H5S_sel_iter_op_t {
     H5S_sel_iter_op_type_t op_type;
     union {
         H5S_sel_iter_app_op_t app_op; /* Application callback */
         H5S_sel_iter_lib_op_t lib_op; /* Library internal callback */
     } u;
 } H5S_sel_iter_op_t;
 
 /* If the module using this macro is allowed access to the private variables, access them directly */
 #ifdef H5S_MODULE
+#define H5S_GET_EXTENT(S)                       (&(S)->extent)
 #define H5S_GET_EXTENT_TYPE(S)                  ((S)->extent.type)
 #define H5S_GET_EXTENT_NDIMS(S)                 ((S)->extent.rank)
 #define H5S_GET_EXTENT_NPOINTS(S)               ((S)->extent.nelem)
 #define H5S_GET_SELECT_NPOINTS(S)               ((S)->select.num_elem)
 #define H5S_GET_SELECT_TYPE(S)                  ((S)->select.type->type)
 #define H5S_SELECT_VALID(S)                     ((*(S)->select.type->is_valid)(S))
 #define H5S_SELECT_SERIAL_SIZE(S)               ((*(S)->select.type->serial_size)(S))
 #define H5S_SELECT_SERIALIZE(S, BUF)            ((*(S)->select.type->serialize)(S, BUF))
 #define H5S_SELECT_BOUNDS(S, START, END)        ((*(S)->select.type->bounds)(S, START, END))
 #define H5S_SELECT_OFFSET(S, OFFSET)            ((*(S)->select.type->offset)(S, OFFSET))
 #define H5S_SELECT_IS_CONTIGUOUS(S)             ((*(S)->select.type->is_contiguous)(S))
 #define H5S_SELECT_IS_SINGLE(S)                 ((*(S)->select.type->is_single)(S))
 #define H5S_SELECT_IS_REGULAR(S)                ((*(S)->select.type->is_regular)(S))
 #define H5S_SELECT_ADJUST_U(S, O)               ((*(S)->select.type->adjust_u)(S, O))
 #define H5S_SELECT_ADJUST_S(S, O)               ((*(S)->select.type->adjust_s)(S, O))
 #define H5S_SELECT_PROJECT_SCALAR(S, O)         ((*(S)->select.type->project_scalar)(S, O))
 #define H5S_SELECT_PROJECT_SIMPLE(S, NS, O)     ((*(S)->select.type->project_simple)(S, NS, O))
 #define H5S_SELECT_ITER_COORDS(ITER, COORDS)    ((*(ITER)->type->iter_coords)(ITER, COORDS))
 #define H5S_SELECT_ITER_BLOCK(ITER, START, END) ((*(ITER)->type->iter_block)(ITER, START, END))
 #define H5S_SELECT_ITER_NELMTS(ITER)            ((*(ITER)->type->iter_nelmts)(ITER))
 #define H5S_SELECT_ITER_HAS_NEXT_BLOCK(ITER)    ((*(ITER)->type->iter_has_next_block)(ITER))
 #define H5S_SELECT_ITER_NEXT(ITER, NELEM)       ((*(ITER)->type->iter_next)(ITER, NELEM))
 #define H5S_SELECT_ITER_NEXT_BLOCK(ITER)        ((*(ITER)->type->iter_next_block)(ITER))
 #define H5S_SELECT_ITER_GET_SEQ_LIST(ITER, MAXSEQ, MAXBYTES, NSEQ, NBYTES, OFF, LEN)                         \
     ((*(ITER)->type->iter_get_seq_list)(ITER, MAXSEQ, MAXBYTES, NSEQ, NBYTES, OFF, LEN))
 #define H5S_SELECT_ITER_RELEASE(ITER) ((*(ITER)->type->iter_release)(ITER))
 #else /* H5S_MODULE */
+#define H5S_GET_EXTENT(S)                       (H5S_get_simple_extent(S))
 #define H5S_GET_EXTENT_TYPE(S)                  (H5S_get_simple_extent_type(S))
 #define H5S_GET_EXTENT_NDIMS(S)                 (H5S_get_simple_extent_ndims(S))
 #define H5S_GET_EXTENT_NPOINTS(S)               (H5S_get_simple_extent_npoints(S))
 #define H5S_GET_SELECT_NPOINTS(S)               (H5S_get_select_npoints(S))
 #define H5S_GET_SELECT_TYPE(S)                  (H5S_get_select_type(S))
 #define H5S_SELECT_VALID(S)                     (H5S_select_valid(S))
 #define H5S_SELECT_SERIAL_SIZE(S)               (H5S_select_serial_size(S))
 #define H5S_SELECT_SERIALIZE(S, BUF)            (H5S_select_serialize(S, BUF))
 #define H5S_SELECT_BOUNDS(S, START, END)        (H5S_get_select_bounds(S, START, END))
 #define H5S_SELECT_OFFSET(S, OFFSET)            (H5S_get_select_offset(S, OFFSET))
 #define H5S_SELECT_IS_CONTIGUOUS(S)             (H5S_select_is_contiguous(S))
 #define H5S_SELECT_IS_SINGLE(S)                 (H5S_select_is_single(S))
 #define H5S_SELECT_IS_REGULAR(S)                (H5S_select_is_regular(S))
 #define H5S_SELECT_ADJUST_U(S, O)               (H5S_select_adjust_u(S, O))
 #define H5S_SELECT_ADJUST_S(S, O)               (H5S_select_adjust_s(S, O))
 #define H5S_SELECT_PROJECT_SCALAR(S, O)         (H5S_select_project_scalar(S, O))
 #define H5S_SELECT_PROJECT_SIMPLE(S, NS, O)     (H5S_select_project_simple(S, NS, O))
 #define H5S_SELECT_ITER_COORDS(ITER, COORDS)    (H5S_select_iter_coords(ITER, COORDS))
 #define H5S_SELECT_ITER_BLOCK(ITER, START, END) (H5S_select_iter_block(ITER, START, END))
 #define H5S_SELECT_ITER_NELMTS(ITER)            (H5S_select_iter_nelmts(ITER))
 #define H5S_SELECT_ITER_HAS_NEXT_BLOCK(ITER)    (H5S_select_iter_has_next_block(ITER))
 #define H5S_SELECT_ITER_NEXT(ITER, NELEM)       (H5S_select_iter_next(ITER, NELEM))
 #define H5S_SELECT_ITER_NEXT_BLOCK(ITER)        (H5S_select_iter_next_block(ITER))
 #define H5S_SELECT_ITER_GET_SEQ_LIST(ITER, MAXSEQ, MAXBYTES, NSEQ, NBYTES, OFF, LEN)                         \
     (H5S_select_iter_get_seq_list(ITER, MAXSEQ, MAXBYTES, NSEQ, NBYTES, OFF, LEN))
 #define H5S_SELECT_ITER_RELEASE(ITER) (H5S_select_iter_release(ITER))
 #endif /* H5S_MODULE */
 
 /* Handle these callbacks in a special way, since they have prologs that need to be executed */
 #define H5S_SELECT_COPY(DST, SRC, SHARE)          (H5S_select_copy(DST, SRC, SHARE))
 #define H5S_SELECT_SHAPE_SAME(S1, S2)             (H5S_select_shape_same(S1, S2))
 #define H5S_SELECT_INTERSECT_BLOCK(S, START, END) (H5S_select_intersect_block(S, START, END))
 #define H5S_SELECT_RELEASE(S)                     (H5S_select_release(S))
 #define H5S_SELECT_DESERIALIZE(S, BUF, BUF_SIZE)  (H5S_select_deserialize(S, BUF, BUF_SIZE))
 
 /* Forward declaration of structs used below */
@@ -200,14 +202,15 @@ struct H5O_loc_t;
 typedef struct H5S_t H5S_t;
 
 /* Operations on dataspaces */
-H5_DLL herr_t      H5S_init(void);
-H5_DLL H5S_t      *H5S_copy(const H5S_t *src, bool share_selection, bool copy_max);
-H5_DLL herr_t      H5S_close(H5S_t *ds);
-H5_DLL H5S_class_t H5S_get_simple_extent_type(const H5S_t *ds);
-H5_DLL hssize_t    H5S_get_simple_extent_npoints(const H5S_t *ds);
-H5_DLL hsize_t     H5S_get_npoints_max(const H5S_t *ds);
-H5_DLL bool        H5S_has_extent(const H5S_t *ds);
-H5_DLL int         H5S_get_simple_extent_ndims(const H5S_t *ds);
+H5_DLL herr_t              H5S_init(void);
+H5_DLL H5S_t              *H5S_copy(const H5S_t *src, bool share_selection, bool copy_max);
+H5_DLL herr_t              H5S_close(H5S_t *ds);
+H5_DLL const H5S_extent_t *H5S_get_simple_extent(const H5S_t *ds);
+H5_DLL H5S_class_t         H5S_get_simple_extent_type(const H5S_t *ds);
+H5_DLL hssize_t            H5S_get_simple_extent_npoints(const H5S_t *ds);
+H5_DLL hsize_t             H5S_get_npoints_max(const H5S_t *ds);
+H5_DLL bool                H5S_has_extent(const H5S_t *ds);
+H5_DLL int                 H5S_get_simple_extent_ndims(const H5S_t *ds);
 H5_DLL int    H5S_get_simple_extent_dims(const H5S_t *ds, hsize_t dims[] /*out*/, hsize_t max_dims[] /*out*/);
 H5_DLL herr_t H5S_write(H5F_t *f, struct H5O_t *oh, unsigned update_flags, H5S_t *ds);
 H5_DLL herr_t H5S_append(H5F_t *f, struct H5O_t *oh, H5S_t *ds);
diff --git a/src/H5T.c b/src/H5T.c
index ba93eefd1e..e3cf451d30 100644
--- a/src/H5T.c
+++ b/src/H5T.c
@@ -377,9 +377,10 @@ static herr_t H5T__register(H5T_pers_t pers, const char *name, H5T_t *src, H5T_t
 static htri_t H5T__compiler_conv(H5T_t *src, H5T_t *dst);
 static herr_t H5T__set_size(H5T_t *dt, size_t size);
 static herr_t H5T__close_cb(H5T_t *dt, void **request);
+static herr_t H5T__init_path_table(void);
+static bool   H5T__path_table_search(const H5T_t *src, const H5T_t *dst, int *idx, int *last_cmp);
 static H5T_path_t *H5T__path_find_real(const H5T_t *src, const H5T_t *dst, const char *name,
                                        H5T_conv_func_t *conv);
-static herr_t      H5T__path_find_init_path_table(void);
 static herr_t      H5T__path_find_init_new_path(H5T_path_t *path, const H5T_t *src, const H5T_t *dst,
                                                 H5T_conv_func_t *conv, H5T_conv_ctx_t *conv_ctx);
 static herr_t      H5T__path_free(H5T_path_t *path, H5T_conv_ctx_t *conv_ctx);
@@ -4975,80 +4976,95 @@ H5T_cmp(const H5T_t *dt1, const H5T_t *dt2, bool superset)
 done:
     if (NULL != idx1)
         H5MM_xfree(idx1);
     if (NULL != idx2)
         H5MM_xfree(idx2);
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5T_cmp() */
 
 /*-------------------------------------------------------------------------
- * Function:    H5T__bsearch_path_table
- *
- * Purpose:    Performs a binary search on the type conversion path table.
- *             If `last_cmp` is non-NULL, the value of the last comparison
- *             is returned through it. If `idx` is non-NULL, the idx into
- *             the path table where the matching path was found is returned
- *             through it. If no matching path is found, the value for
- *             `idx` will be the index into the path table where a path
- *             entry with source and destination datatypes matching src and
- *             dst should be inserted. In this case, the caller should be
- *             sure to increment the index value by 1 if the value of the
- *             last comparison is > 0.
- *
- * Return:    Success:    Pointer to the path in the path table
- *            Failure:    NULL if no matching path is found in the table
+ * Function:    H5T__path_table_search
+ *
+ * Purpose:     Searches the global datatype conversion path table for a
+ *              conversion path between two datatypes.
+ *
+ *              Sets `idx` to be the index of the last table entry compared
+ *              (which will be the index of the matching conversion path on
+ *              success). If no matching path is found, the value for `idx`
+ *              will be the index into the path table where a new path
+ *              entry with source and destination datatypes matching src
+ *              and dst should be inserted. In this case, the caller should
+ *              be sure to increment the index value by 1 if the value of
+ *              the last comparison is > 0.
+ *
+ *              If `last_cmp` is non-NULL, the value of the last comparison
+ *              (-1, 0, or 1) is returned through it.
+ *
+ * Return:    Success:    true (conversion path found, index in *idx)
+ *            Failure:    false (no conversion path between types)
  *
  *-------------------------------------------------------------------------
  */
-static void *
-H5T__bsearch_path_table(const H5T_t *src, const H5T_t *dst, int *last_cmp, int *idx)
+static bool
+H5T__path_table_search(const H5T_t *src, const H5T_t *dst, int *idx, int *last_cmp)
 {
-    int   cmp;
-    int   lt, rt, md;
-    void *ret_value = NULL;
+    int  lt, rt, md;        /* Left, middle, and right edges */
+    int  cmp;               /* Comparison result  */
+    bool ret_value = false; /* Return value */
 
     FUNC_ENTER_PACKAGE_NOERR
 
+    /* Sanity check */
+    assert(0 != H5T_g.npaths);
+    assert(src);
+    assert(src->shared);
+    assert(dst);
+    assert(dst->shared);
+    assert(idx);
+
+    /* Find the conversion path in the table, using a binary search */
+    /* NOTE: Doesn't match against entry 0, which is the no-op path */
     lt = md = 1;
     rt      = H5T_g.npaths;
     cmp     = -1;
 
     while (cmp && lt < rt) {
         md = (lt + rt) / 2;
         assert(H5T_g.path[md]);
         cmp = H5T_cmp(src, H5T_g.path[md]->src, false);
         if (0 == cmp)
             cmp = H5T_cmp(dst, H5T_g.path[md]->dst, false);
         if (cmp < 0)
             rt = md;
         else if (cmp > 0)
             lt = md + 1;
         else
-            ret_value = H5T_g.path[md];
+            /* Match found */
+            ret_value = true;
     }
 
+    /* Set middle index & comparison values */
+    *idx = md;
     if (last_cmp)
         *last_cmp = cmp;
-    if (idx)
-        *idx = md;
 
     FUNC_LEAVE_NOAPI(ret_value)
-} /* end H5T__bsearch_path_table() */
+} /* end H5T__path_table_search() */
 
 /*-------------------------------------------------------------------------
  * Function:    H5T_path_find
  *
  * Purpose:    Library-internal wrapper to find the path which converts
  *             type SRC to type DST.
  *
  *             If SRC and DST are both null pointers then the special no-op
  *             conversion path is used.
  *
  * Return:    Success:    Pointer to the path, valid until the path
  *                        database is modified.
  *
  *            Failure:    NULL if the path does not exist and no
  *                        function can be found to apply to the new path.
  *
  *-------------------------------------------------------------------------
  */
@@ -5109,134 +5125,138 @@ static H5T_path_t *
 H5T__path_find_real(const H5T_t *src, const H5T_t *dst, const char *name, H5T_conv_func_t *conv)
 {
     H5T_conv_ctx_t tmp_ctx      = {0};   /* Temporary conversion context object */
     H5T_path_t    *matched_path = NULL;  /* Path existing in the table */
     H5T_path_t    *path         = NULL;  /* Pointer to current path */
     bool           noop_conv    = false; /* Whether this is a no-op conversion */
     bool           new_path     = false; /* Whether we're creating a new path */
     bool new_api_func = false; /* If the caller is an API function specifying a new conversion function */
     bool new_lib_func = false; /* If the caller is a private function specifying a new conversion function */
     int  old_npaths;           /* Previous number of paths in table */
     int  last_cmp         = 0; /* Value of last comparison during binary search */
     int  path_idx         = 0; /* Index into path table for path */
     H5T_path_t *ret_value = NULL; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Sanity check */
     assert(src);
     assert(src->shared);
     assert(dst);
     assert(dst->shared);
 
     /*
      * Get the datatype conversion exception callback structure.
      * Note that we have to first check if an API context has been
      * pushed, since we could have arrived here during library
      * initialization of the H5T package.
      */
     if (H5CX_pushed() && (H5CX_get_dt_conv_cb(&tmp_ctx.u.init.cb_struct) < 0))
         HGOTO_ERROR(H5E_DATATYPE, H5E_CANTGET, NULL, "unable to get conversion exception callback");
 
     /* Make sure the path table is initialized */
-    if ((0 == H5T_g.npaths) && (H5T__path_find_init_path_table() < 0))
+    if ((0 == H5T_g.npaths) && (H5T__init_path_table() < 0))
         HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, NULL, "unable to initialize type conversion path table");
 
     /* Find the conversion path. If no "force conversion" flags are
      * set and the source and destination types are equal, then use
      * the no-op conversion path. Otherwise, do a binary search over
      * the remaining entries.
      */
     noop_conv =
         src->shared->force_conv == false && dst->shared->force_conv == false && 0 == H5T_cmp(src, dst, true);
     if (noop_conv)
         matched_path = H5T_g.path[0];
-    else
-        matched_path = H5T__bsearch_path_table(src, dst, &last_cmp, &path_idx);
+    else {
+        /* Search the table of conversion paths */
+        if (H5T__path_table_search(src, dst, &path_idx, &last_cmp))
+            matched_path = H5T_g.path[path_idx];
+    }
 
     /* Keep a record of the number of paths in the table, in case one of the
      * initialization calls below (hard or soft) causes more entries to be
      * added to the table - QAK, 1/26/02
      */
     old_npaths = H5T_g.npaths;
 
     /* Set a few convenience variables */
     new_api_func = (matched_path && conv->is_app && conv->u.app_func);
     new_lib_func = (matched_path && !conv->is_app && conv->u.lib_func);
 
     /* If we didn't find the path, if the caller is an API function specifying
      * a new hard conversion function, or if the caller is a private function
      * specifying a new hard conversion and the path is a soft conversion, then
      * create a new path and add the new function to the path.
      */
     new_path = !matched_path || new_api_func || (new_lib_func && !matched_path->is_hard);
 
     if (new_path) {
         if (NULL == (path = H5FL_CALLOC(H5T_path_t)))
             HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed for type conversion path");
         if (name && *name) {
             strncpy(path->name, name, (size_t)H5T_NAMELEN - 1);
             path->name[H5T_NAMELEN - 1] = '\0';
         } /* end if */
         else
             snprintf(path->name, sizeof(path->name), "NONAME");
         if (NULL == (path->src = H5T_copy(src, H5T_COPY_ALL)))
             HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, NULL, "unable to copy datatype for conversion path");
         if (NULL == (path->dst = H5T_copy(dst, H5T_COPY_ALL)))
             HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, NULL, "unable to copy datatype for conversion path");
     } /* end if */
     else
         path = matched_path;
 
     /* Initialize the path if it's a new path */
     if (new_path && H5T__path_find_init_new_path(path, src, dst, conv, &tmp_ctx) < 0)
         HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, NULL, "unable to initialize new conversion path");
 
     /* Fail if the path still doesn't have a conversion function at this point */
     if (!path->conv.u.app_func)
         HGOTO_ERROR(H5E_DATATYPE, H5E_CANTINIT, NULL, "no appropriate function for conversion path");
 
     /* Check if paths were inserted into the table through a recursive call
      * and re-compute the correct location for this path if so. - QAK, 1/26/02
      */
     if (old_npaths != H5T_g.npaths)
-        matched_path = H5T__bsearch_path_table(src, dst, &last_cmp, &path_idx);
+        if (H5T__path_table_search(src, dst, &path_idx, &last_cmp))
+            matched_path = H5T_g.path[path_idx];
 
     /* Replace an existing table entry or add a new entry */
     if (matched_path && new_path) {
         assert(matched_path == H5T_g.path[path_idx]);
 
         tmp_ctx.u.free.src_type_id = H5I_INVALID_HID;
         tmp_ctx.u.free.dst_type_id = H5I_INVALID_HID;
         if (H5T__path_free(matched_path, &tmp_ctx) < 0)
             HGOTO_ERROR(H5E_DATATYPE, H5E_CANTFREE, NULL, "unable to free datatype conversion path");
 
         H5T_g.path[path_idx] = path;
     }
     else if (new_path) {
         /* Make space in the table for the new path if necessary */
         if ((size_t)H5T_g.npaths >= H5T_g.apaths) {
             size_t       na = MAX(H5T_DEF_CONV_TABLE_SLOTS, 2 * H5T_g.apaths);
             H5T_path_t **x;
 
             if (NULL == (x = H5MM_realloc(H5T_g.path, na * sizeof(H5T_path_t *))))
                 HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, NULL, "memory allocation failed");
             H5T_g.apaths = na;
             H5T_g.path   = x;
         }
 
         /* Adjust final location in table for new path if the last comparison
          * of paths during binary search was > 0, then shift down all path
          * entries in the table starting at that location to make room for
          * the new path
          */
         assert(last_cmp != 0);
         if (last_cmp > 0)
             path_idx++;
         memmove(H5T_g.path + path_idx + 1, H5T_g.path + path_idx,
                 (size_t)(H5T_g.npaths - path_idx) * sizeof(H5T_path_t *));
 
         H5T_g.npaths++;
         H5T_g.path[path_idx] = path;
     }
 
     ret_value = path;
@@ -5244,84 +5264,88 @@ H5T__path_find_real(const H5T_t *src, const H5T_t *dst, const char *name, H5T_co
 done:
     if (!ret_value && path && new_path) {
         if (path->src && (H5T_close_real(path->src) < 0))
             HDONE_ERROR(H5E_DATATYPE, H5E_CANTCLOSEOBJ, NULL, "unable to close datatype");
         if (path->dst && (H5T_close_real(path->dst) < 0))
             HDONE_ERROR(H5E_DATATYPE, H5E_CANTCLOSEOBJ, NULL, "unable to close datatype");
         path = H5FL_FREE(H5T_path_t, path);
     }
 
     FUNC_LEAVE_NOAPI(ret_value)
 } /* end H5T__path_find_real() */
 
 /*-------------------------------------------------------------------------
- * Function:  H5T__path_find_init_path_table
+ * Function:  H5T__init_path_table
  *
  * Purpose:   Helper function to allocate and initialize the table holding
  *            pointers to datatype conversion paths. Sets the no-op
  *            conversion path as the first entry in the table.
  *
  * Return:    Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
 static herr_t
-H5T__path_find_init_path_table(void)
+H5T__init_path_table(void)
 {
     herr_t ret_value = SUCCEED;
 
     FUNC_ENTER_PACKAGE
 
-    assert(0 == H5T_g.npaths);
+    /* Sanity check */
+    if (0 != H5T_g.npaths)
+        HGOTO_ERROR(H5E_DATATYPE, H5E_ALREADYINIT, FAIL,
+                    "datatype conversion path table is already initialized");
 
-    if (NULL == (H5T_g.path = H5MM_malloc(H5T_DEF_CONV_TABLE_SLOTS * sizeof(H5T_path_t *))))
-        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL,
+    if (NULL == (H5T_g.path = H5MM_calloc(H5T_DEF_CONV_TABLE_SLOTS * sizeof(H5T_path_t *))))
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTALLOC, FAIL,
                     "memory allocation failed for type conversion path table");
-    H5T_g.apaths  = H5T_DEF_CONV_TABLE_SLOTS;
-    H5T_g.path[0] = NULL;
+    H5T_g.apaths = H5T_DEF_CONV_TABLE_SLOTS;
 
     /*
      * Allocate a path for the no-op conversion function
      * and set it as the first entry in the table
      */
     if (NULL == (H5T_g.path[0] = H5FL_CALLOC(H5T_path_t)))
-        HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, FAIL, "memory allocation failed for no-op conversion path");
+        HGOTO_ERROR(H5E_DATATYPE, H5E_CANTALLOC, FAIL, "memory allocation failed for no-op conversion path");
 
     /* Initialize the no-op path */
     snprintf(H5T_g.path[0]->name, sizeof(H5T_g.path[0]->name), "no-op");
     H5T_g.path[0]->conv.is_app     = false;
     H5T_g.path[0]->conv.u.lib_func = H5T__conv_noop;
     H5T_g.path[0]->cdata.command   = H5T_CONV_INIT;
 
     if (H5T__conv_noop(NULL, NULL, &(H5T_g.path[0]->cdata), NULL, 0, 0, 0, NULL, NULL) < 0) {
 #ifdef H5T_DEBUG
         if (H5DEBUG(T))
             fprintf(H5DEBUG(T), "H5T: unable to initialize no-op conversion function (ignored)\n");
 #endif
         /* Ignore any errors from the conversion function */
         if (H5E_clear_stack(NULL) < 0)
             HGOTO_ERROR(H5E_DATATYPE, H5E_CANTRESET, FAIL, "unable to clear current error stack");
     } /* end if */
 
     H5T_g.path[0]->is_noop = true;
-    H5T_g.npaths           = 1;
+
+    /* Set # of initial paths in the table */
+    H5T_g.npaths = 1;
 
 done:
     if (ret_value < 0) {
         if (H5T_g.path)
             H5FL_FREE(H5T_path_t, H5T_g.path[0]);
         H5MM_free(H5T_g.path);
     }
 
     FUNC_LEAVE_NOAPI(ret_value)
-}
+} /* end H5T__init_path_table() */
 
 /*-------------------------------------------------------------------------
  * Function:  H5T__path_find_init_new_path
  *
  * Purpose:   Helper function to initialize a new conversion path that's
  *            being added to the path conversion table.
  *
  * Return:    Non-negative on success/Negative on failure
  *
  *-------------------------------------------------------------------------
  */
@@ -5668,30 +5692,71 @@ bool
 H5T_path_noop(const H5T_path_t *p)
 {
     FUNC_ENTER_NOAPI_NOINIT_NOERR
 
     assert(p);
 
     FUNC_LEAVE_NOAPI(p->is_noop || (p->is_hard && 0 == H5T_cmp(p->src, p->dst, false)))
 } /* end H5T_path_noop() */
 
+/*-------------------------------------------------------------------------
+ * Function:    H5T_noop_conv
+ *
+ * Purpose:     Check if a conversion between two dataypes will be a no-op
+ *
+ * Return:      true / false (can't fail)
+ *
+ *-------------------------------------------------------------------------
+ */
+bool
+H5T_noop_conv(const H5T_t *src, const H5T_t *dst)
+{
+    bool ret_value = false; /* Return value */
+
+    FUNC_ENTER_NOAPI_NOINIT_NOERR
+
+    /* Sanity check */
+    assert(src);
+    assert(src->shared);
+    assert(dst);
+    assert(dst->shared);
+
+    /* Check the conversion path.  If source and destination types are equal
+     * then its a no-op conversion, as long as neither type has a "force conversion"
+     * flag.  Otherwise search over the conversion table entries.
+     */
+    if (src->shared->force_conv == false && dst->shared->force_conv == false &&
+        0 == H5T_cmp(src, dst, true)) {
+        ret_value = true;
+    } /* end if */
+    else {
+        int idx = 0; /* Matching entry */
+
+        /* Search the table of conversion paths */
+        if (H5T__path_table_search(src, dst, &idx, NULL))
+            ret_value = H5T_path_noop(H5T_g.path[idx]);
+    } /* end else */
+
+    FUNC_LEAVE_NOAPI(ret_value)
+} /* end H5T_noop_conv() */
+
 /*-------------------------------------------------------------------------
  * Function:  H5T_path_compound_subset
  *
  * Purpose:   Checks if the library's compound conversion function
  *            is in use. Tells whether whether the source members are
  *            a subset of destination, and the order is the same, and
  *            no conversion is needed.  For example:
  *                  struct source {            struct destination {
  *                      TYPE1 A;      -->          TYPE1 A;
  *                      TYPE2 B;      -->          TYPE2 B;
  *                      TYPE3 C;      -->          TYPE3 C;
  *                  };                             TYPE4 D;
  *                                                 TYPE5 E;
  *                                             };
  *
  * Return:    A pointer to the subset info struct in p, or NULL if the
  *            library's compound conversion function is not in use.
  *            Points directly into the H5T_path_t structure.
  *
  *-------------------------------------------------------------------------
  */
diff --git a/src/H5Tprivate.h b/src/H5Tprivate.h
index 46b2c92fa8..99ea256b27 100644
--- a/src/H5Tprivate.h
+++ b/src/H5Tprivate.h
@@ -131,6 +131,7 @@ H5_DLL herr_t             H5T_convert_committed_datatype(H5T_t *dt, H5F_t *f);
 H5_DLL htri_t             H5T_is_relocatable(const H5T_t *dt);
 H5_DLL H5T_path_t        *H5T_path_find(const H5T_t *src, const H5T_t *dst);
 H5_DLL bool               H5T_path_noop(const H5T_path_t *p);
+H5_DLL bool               H5T_noop_conv(const H5T_t *src, const H5T_t *dst);
 H5_DLL H5T_bkg_t          H5T_path_bkg(const H5T_path_t *p);
 H5_DLL H5T_subset_info_t *H5T_path_compound_subset(const H5T_path_t *p);
 H5_DLL herr_t             H5T_unregister(H5T_pers_t pers, const char *name, H5T_t *src, H5T_t *dst,
diff --git a/src/H5VLnative_blob.c b/src/H5VLnative_blob.c
index 718d548756..890e82dc1b 100644
--- a/src/H5VLnative_blob.c
+++ b/src/H5VLnative_blob.c
@@ -96,31 +96,34 @@ herr_t
 H5VL__native_blob_get(void *obj, const void *blob_id, void *buf, size_t size, void H5_ATTR_UNUSED *ctx)
 {
     H5F_t         *f  = (H5F_t *)obj;             /* Retrieve file pointer */
     const uint8_t *id = (const uint8_t *)blob_id; /* Pointer to the disk blob ID */
     H5HG_t         hobjid;                        /* Global heap ID for sequence */
     size_t         hobj_size = 0;                 /* Global heap object size returned from H5HG_read() */
     herr_t         ret_value = SUCCEED;           /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     /* Sanity check */
     assert(f);
     assert(id);
     assert(buf);
 
     /* Get the heap information */
     H5F_addr_decode(f, &id, &hobjid.addr);
     UINT32DECODE(id, hobjid.idx);
 
     /* Check if this sequence actually has any data */
-    if (hobjid.addr > 0)
+    if (hobjid.addr > 0) {
+        /* Verify the size is correct */
+        if (H5HG_get_obj_size(f, &hobjid, &hobj_size) < 0)
+            HGOTO_ERROR(H5E_VOL, H5E_CANTGETSIZE, FAIL, "can't get object size");
+        if (hobj_size != size)
+            HGOTO_ERROR(H5E_VOL, H5E_BADSIZE, FAIL, "Expected global heap object size does not match");
+
         /* Read the VL information from disk */
         if (NULL == H5HG_read(f, &hobjid, buf, &hobj_size))
             HGOTO_ERROR(H5E_VOL, H5E_READERROR, FAIL, "unable to read VL information");
-
-    /* Verify the size is correct */
-    if (hobj_size != size)
-        HGOTO_ERROR(H5E_VOL, H5E_CANTDECODE, FAIL, "Expected global heap object size does not match");
+    }
 
 done:
     FUNC_LEAVE_NOAPI(ret_value)
diff --git a/src/H5Znbit.c b/src/H5Znbit.c
index fb5c5c51f8..429394d56c 100644
--- a/src/H5Znbit.c
+++ b/src/H5Znbit.c
@@ -916,58 +916,60 @@ static size_t
 H5Z__filter_nbit(unsigned flags, size_t cd_nelmts, const unsigned cd_values[], size_t nbytes,
                  size_t *buf_size, void **buf)
 {
     unsigned char *outbuf;        /* pointer to new output buffer */
     size_t         size_out  = 0; /* size of output buffer */
     unsigned       d_nelmts  = 0; /* number of elements in the chunk */
     size_t         ret_value = 0; /* return value */
 
     FUNC_ENTER_PACKAGE
 
     /* check arguments
      * cd_values[0] stores actual number of parameters in cd_values[]
      */
     if (cd_nelmts != cd_values[0])
         HGOTO_ERROR(H5E_ARGS, H5E_BADVALUE, 0, "invalid nbit aggression level");
 
     /* check if need to do nbit compress or decompress
      * cd_values[1] stores the flag if true indicating no need to compress
      */
     if (cd_values[1])
         HGOTO_DONE(*buf_size);
 
     /* copy a filter parameter to d_nelmts */
     d_nelmts = cd_values[2];
 
     /* input; decompress */
     if (flags & H5Z_FLAG_REVERSE) {
         size_out = d_nelmts * (size_t)cd_values[4]; /* cd_values[4] stores datatype size */
 
         /* allocate memory space for decompressed buffer */
         if (NULL == (outbuf = (unsigned char *)H5MM_malloc(size_out)))
             HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, 0, "memory allocation failed for nbit decompression");
 
         /* decompress the buffer */
-        if (H5Z__nbit_decompress(outbuf, d_nelmts, (unsigned char *)*buf, cd_values) < 0)
+        if (H5Z__nbit_decompress(outbuf, d_nelmts, (unsigned char *)*buf, cd_values) < 0) {
+            H5MM_xfree(outbuf);
             HGOTO_ERROR(H5E_PLINE, H5E_CANTFILTER, 0, "can't decompress buffer");
+        }
     } /* end if */
     /* output; compress */
     else {
         assert(nbytes == d_nelmts * cd_values[4]);
 
         size_out = nbytes;
 
         /* allocate memory space for compressed buffer */
         if (NULL == (outbuf = (unsigned char *)H5MM_malloc(size_out)))
             HGOTO_ERROR(H5E_RESOURCE, H5E_NOSPACE, 0, "memory allocation failed for nbit compression");
 
         /* compress the buffer, size_out will be changed */
         H5Z__nbit_compress((unsigned char *)*buf, d_nelmts, outbuf, &size_out, cd_values);
     } /* end else */
 
     /* free the input buffer */
     H5MM_xfree(*buf);
 
     /* set return values */
     *buf      = outbuf;
     *buf_size = size_out;
     ret_value = size_out;
@@ -1180,60 +1182,65 @@ static herr_t
 H5Z__nbit_decompress_one_compound(unsigned char *data, size_t data_offset, unsigned char *buffer, size_t *j,
                                   size_t *buf_len, const unsigned parms[], unsigned *parms_index)
 {
-    unsigned     i, nmembers, member_offset, member_class, member_size, used_size = 0, size;
+    unsigned     i, nmembers, member_offset, member_class, member_size, used_size = 0, prev_used_size, size;
     parms_atomic p;
     herr_t       ret_value = SUCCEED; /* Return value */
 
     FUNC_ENTER_PACKAGE
 
     size     = parms[(*parms_index)++];
     nmembers = parms[(*parms_index)++];
 
     for (i = 0; i < nmembers; i++) {
         member_offset = parms[(*parms_index)++];
         member_class  = parms[(*parms_index)++];
 
         /* Check for overflow */
-        member_size = parms[*parms_index];
+        member_size    = parms[*parms_index];
+        prev_used_size = used_size;
         used_size += member_size;
         if (used_size > size)
-            HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "compound member offset overflowed compound size");
+            HGOTO_ERROR(H5E_PLINE, H5E_BADVALUE, FAIL, "compound member size overflowed compound size");
+        if (used_size <= prev_used_size)
+            HGOTO_ERROR(H5E_PLINE, H5E_BADVALUE, FAIL, "compound member size overflowed compound size");
+        if ((member_offset + member_size) > size)
+            HGOTO_ERROR(H5E_PLINE, H5E_BADRANGE, FAIL, "compound member offset overflowed compound size");
         switch (member_class) {
             case H5Z_NBIT_ATOMIC:
                 p.size = member_size;
                 /* Advance past member size */
                 (*parms_index)++;
                 p.order     = parms[(*parms_index)++];
                 p.precision = parms[(*parms_index)++];
                 p.offset    = parms[(*parms_index)++];
 
                 /* Check values of precision and offset */
                 if (p.precision > p.size * 8 || (p.precision + p.offset) > p.size * 8)
                     HGOTO_ERROR(H5E_PLINE, H5E_BADTYPE, FAIL, "invalid datatype precision/offset");
 
                 H5Z__nbit_decompress_one_atomic(data, data_offset + member_offset, buffer, j, buf_len, &p);
                 break;
 
             case H5Z_NBIT_ARRAY:
                 if (H5Z__nbit_decompress_one_array(data, data_offset + member_offset, buffer, j, buf_len,
                                                    parms, parms_index) < 0)
                     HGOTO_ERROR(H5E_PLINE, H5E_CANTFILTER, FAIL, "can't decompress array");
                 break;
 
             case H5Z_NBIT_COMPOUND:
                 if (H5Z__nbit_decompress_one_compound(data, data_offset + member_offset, buffer, j, buf_len,
                                                       parms, parms_index) < 0)
                     HGOTO_ERROR(H5E_PLINE, H5E_CANTFILTER, FAIL, "can't decompress compound");
                 break;
 
             case H5Z_NBIT_NOOPTYPE:
                 /* Advance past member size */
                 (*parms_index)++;
                 H5Z__nbit_decompress_one_nooptype(data, data_offset + member_offset, buffer, j, buf_len,
                                                   member_size);
                 break;
 
             default:
                 assert(0 && "This Should never be executed!");
         } /* end switch */
     }
diff --git a/tools/lib/h5tools_utils.c b/tools/lib/h5tools_utils.c
index dfffac6738..d7e7ff574a 100644
--- a/tools/lib/h5tools_utils.c
+++ b/tools/lib/h5tools_utils.c
@@ -585,24 +585,24 @@ static void
 dump_table(hid_t fid, char *tablename, table_t *table)
 {
     unsigned u;
     char    *obj_tok_str = NULL;
 
     PRINTSTREAM(rawoutstream, "%s: # of entries = %d\n", tablename, table->nobjs);
     for (u = 0; u < table->nobjs; u++) {
-        H5VLconnector_token_to_str(fid, table->objs[u].obj_token, &obj_tok_str);
+        H5Otoken_to_str(fid, &table->objs[u].obj_token, &obj_tok_str);
 
         PRINTSTREAM(rawoutstream, "%s %s %d %d\n", obj_tok_str, table->objs[u].objname,
                     table->objs[u].displayed, table->objs[u].recorded);
 
-        H5VLfree_token_str(fid, obj_tok_str);
+        H5free_memory(obj_tok_str);
     }
 }
 
 /*-------------------------------------------------------------------------
  * Function:    dump_tables
  *
  * Purpose:     display the contents of tables for debugging purposes
  *
  * Return:      void
  *-------------------------------------------------------------------------
  */
