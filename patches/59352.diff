commit f95b4cdd852fca7052fc7a2b115e4958499f1df9
Author: Luca Deri <deri@ntop.org>
Date:   Wed Jun 7 22:52:00 2023 +0200

    Compilation warnign fixes and various boundary checks

diff --git a/fuzz/onefile.cpp b/fuzz/onefile.cpp
index 7fa68f8c3..7f9a6c340 100644
--- a/fuzz/onefile.cpp
+++ b/fuzz/onefile.cpp
@@ -33,29 +33,29 @@ int main(int argc, char *argv[]) {
 int main(int argc, char *argv[]) {
     if (argc != 2) {
         printf("Error! Must specificy a input file\n");
         return 1;
     }
 
     if (LLVMFuzzerInitialize)
         LLVMFuzzerInitialize(&argc, &argv);
 
     FILE *f = fopen(argv[1], "r");
     if (!f) return 1;
 
     fseek(f, 0, SEEK_END);
     size_t fsize = ftell(f);
     fseek(f, 0, SEEK_SET); /* same as rewind(f); */
 
     uint8_t *string = (uint8_t *)malloc(fsize + 1);
-    fread(string, fsize, 1, f);
+    size_t l = fread(string, fsize, 1, f);
 
     fclose(f);
 
     LLVMFuzzerTestOneInput(string, fsize);
 
     free(string);
 
     return 0;
 }
 
-#endif
\ No newline at end of file
+#endif
diff --git a/fuzz/stub/RedisStub.cpp b/fuzz/stub/RedisStub.cpp
index 794930a5d..52abb7a45 100644
--- a/fuzz/stub/RedisStub.cpp
+++ b/fuzz/stub/RedisStub.cpp
@@ -59,11 +59,11 @@ void Redis::setInitializationComplete() {}
 int Redis::info(char *rsp, u_int rsp_len) {
     if (rsp_len == 0) return -1;
 
     stats.num_other++;
-    if (snprintf(rsp, rsp_len, "") < 0) {
-        rsp[0] = 0;
-        return -1;
-    }
+    if(rsp_len == 0)
+      return -1;
+    
+    rsp[0] = 0;
     return 0;
 }
 
@@ -360,21 +360,21 @@ int Redis::rpush(const char *queue_name, const char *msg,
 int Redis::lindex(const char *queue_name, int idx, char *buf, u_int buf_len) {
     if (buf_len == 0) return -1;
     stats.num_other++;
     std::string strKey(queue_name);
     if (this->listStore.find(strKey) == this->listStore.end()) {
         buf[0] = 0;
         return -1;
     }
 
     const auto &list = this->listStore[strKey];
 
-    if (idx < 0) idx += list.size();
-    if (idx < 0 || idx >= list.size()) {
+    if (idx < 0) idx += (int)list.size();
+    if (idx < 0 || idx >= (int)list.size()) {
         buf[0] = 0;
         return -1;
     }
 
     snprintf(buf, buf_len, "%s", list[idx].c_str());
 
     return 0;
 }
@@ -445,21 +445,21 @@ int Redis::lrem(const char *queue_name, const char *value) {
 int Redis::lrange(const char *list_name, char ***elements, int start_offset,
                   int end_offset) {
     stats.num_other++;
     std::string strKey(list_name);
     if (this->listStore.find(strKey) == this->listStore.end()) return 0;
 
     auto &list = this->listStore[strKey];
     if (start_offset < 0) start_offset += list.size();
     if (end_offset < 0) end_offset += list.size();
     int k = 0;
     vector<std::string> retList;
     for (auto it = list.begin(); it != list.end(); ++k, ++it) {
         if (k >= start_offset && k <= end_offset) retList.push_back(*it);
     }
 
     *elements = (char **)malloc(retList.size() * sizeof(char *));
-    for (int i = 0; i < retList.size(); ++i)
+    for (int i = 0; i < (int)retList.size(); ++i)
         (*elements)[i] = strdup(retList[i].c_str());
 
     return retList.size();
 }
@@ -567,4 +567,4 @@ char *Redis::dump(char *key) {
     return ret;
 }
 
-int Redis::restore(char *key, char *buf) { return 0; }
\ No newline at end of file
+int Redis::restore(char *key, char *buf) { return 0; }
diff --git a/src/HostPools.cpp b/src/HostPools.cpp
index 9453c40cf..695731b21 100644
--- a/src/HostPools.cpp
+++ b/src/HostPools.cpp
@@ -299,185 +299,196 @@ void HostPools::lua(lua_State *vm) {
 void HostPools::reloadPools() {
   char kname[CONST_MAX_LEN_REDIS_KEY];
   char **pools, **pool_members, *at, *member;
   int num_pools, num_members, actual_num_members;
   u_int16_t _pool_id;
   u_int16_t vlan_id;
   VLANAddressTree *new_tree;
   HostPoolStats **new_stats;
   Redis *redis = ntop->getRedis();
 
   if (!iface || (iface->get_id() == -1)) return;
 
   new_tree = new (std::nothrow) VLANAddressTree;
+  if(new_tree == NULL) {
+    return;
+  }
+  
   new_stats = new (std::nothrow) HostPoolStats *[MAX_NUM_HOST_POOLS];
+  if(new_stats == NULL) {
+    delete new_tree;
+    return;
+  }
+  
   for (u_int32_t i = 0; i < MAX_NUM_HOST_POOLS; i++) new_stats[i] = NULL;
 
   snprintf(kname, sizeof(kname), HOST_POOL_IDS_KEY);
 
   /* Always allocate default pool stats */
   if (stats && stats[0]) /* Duplicate existing statistics */
     new_stats[0] = new (std::nothrow) HostPoolStats(*stats[0]);
   else /* Brand new statistics */
     new_stats[0] = new (std::nothrow) HostPoolStats(iface);
 
   /* Set the default pool name into the stats */
   if (new_stats[0]) new_stats[0]->updateName(DEFAULT_POOL_NAME);
 
   /* Keys are pool ids */
-  if ((num_pools = redis->smembers(kname, &pools)) == -1)
+  if ((num_pools = redis->smembers(kname, &pools)) == -1) {
+    delete new_tree;
+    delete new_stats;
     return; /* Something went wrong with redis? */
-
+  }
+  
   for (int i = 0; i < num_pools; i++) {
     if (!pools[i]) continue;
 
     _pool_id = (u_int16_t)atoi(pools[i]);
     if (_pool_id >= MAX_NUM_HOST_POOLS) {
       ntop->getTrace()->traceEvent(
           TRACE_WARNING,
           "Ignoring pool [pool id: %2d]. "
           "Maximum number of host pools for this license is %u, inclusive of "
           "the Not Assigned pool.",
           _pool_id, MAX_NUM_HOST_POOLS);
 
       free(pools[i]);
       continue;
     }
 
     snprintf(kname, sizeof(kname), HOST_POOL_DETAILS_KEY, _pool_id);
 
     if (_pool_id != 0) {            /* Pool id 0 stats already updated */
       if (stats && stats[_pool_id]) /* Duplicate existing statistics */
-        new_stats[_pool_id] =
-            new (std::nothrow) HostPoolStats(*stats[_pool_id]);
+        new_stats[_pool_id] = new (std::nothrow) HostPoolStats(*stats[_pool_id]);
       else /* Brand new statistics */
         new_stats[_pool_id] = new (std::nothrow) HostPoolStats(iface);
     }
 
     /* Initialize the name */
     if (new_stats[_pool_id]) {
       char name_rsp[POOL_MAX_NAME_LEN];
       redis->hashGet(kname, (char *)"name", name_rsp, sizeof(name_rsp));
       new_stats[_pool_id]->updateName(name_rsp);
     }
 
 #ifdef NTOPNG_PRO
     char rsp[16] = {0};
 
     children_safe[_pool_id] =
         ((redis->hashGet(kname, (char *)CONST_CHILDREN_SAFE, rsp,
                          sizeof(rsp)) != -1) &&
          (!strcmp(rsp, "true")));
 
     forge_global_dns[_pool_id] =
         ((redis->hashGet(kname, (char *)CONST_FORGE_GLOBAL_DNS, rsp,
                          sizeof(rsp)) != -1) &&
          (!strcmp(rsp, "true")));
 
     routing_policy_id[_pool_id] =
         (redis->hashGet(kname, (char *)CONST_ROUTING_POLICY_ID, rsp,
                         sizeof(rsp)) != -1)
             ? atoi(rsp)
             : DEFAULT_ROUTING_TABLE_ID;
     pool_shaper[_pool_id] = (redis->hashGet(kname, (char *)CONST_POOL_SHAPER_ID,
                                             rsp, sizeof(rsp)) != -1)
                                 ? atoi(rsp)
                                 : DEFAULT_SHAPER_ID;
     schedule_bitmap[_pool_id] =
         (redis->hashGet(kname, (char *)CONST_SCHEDULE_BITMAP, rsp,
                         sizeof(rsp)) != -1)
             ? strtol(rsp, NULL, 16)
             : DEFAULT_TIME_SCHEDULE;
 
     enforce_quotas_per_pool_member[_pool_id] =
         ((redis->hashGet(kname, (char *)CONST_ENFORCE_QUOTAS_PER_POOL_MEMBER,
                          rsp, sizeof(rsp)) != -1) &&
          (!strcmp(rsp, "true")));
     ;
     enforce_shapers_per_pool_member[_pool_id] =
         ((redis->hashGet(kname, (char *)CONST_ENFORCE_SHAPERS_PER_POOL_MEMBER,
                          rsp, sizeof(rsp)) != -1) &&
          (!strcmp(rsp, "true")));
     ;
 
 #ifdef HOST_POOLS_DEBUG
     redis->hashGet(kname, (char *)"name", rsp, sizeof(rsp));
     ntop->getTrace()->traceEvent(
         TRACE_NORMAL,
         "Loading pool [%s][iteration: %u][pool_id: %u][name: %s]"
         "[children_safe: %i]"
         "[forge_global_dns: %i]"
         "[pool_shaper: %i]"
         "[schedule_bitmap: %i]"
         "[enforce_quotas_per_pool_member: %i]"
         "[enforce_shapers_per_pool_member: %i]",
         iface->get_name(), i, _pool_id, rsp, children_safe[_pool_id],
         forge_global_dns[_pool_id], pool_shaper[_pool_id],
         schedule_bitmap[_pool_id], enforce_quotas_per_pool_member[_pool_id],
         enforce_shapers_per_pool_member[_pool_id]);
 #endif
 
 #endif /* NTOPNG_PRO */
 
     snprintf(kname, sizeof(kname), HOST_POOL_MEMBERS_KEY, pools[i]);
 
     /* Pool members are the elements of the list */
     if ((num_members = redis->smembers(kname, &pool_members)) > 0) {
       // NOTE: the auto-assigned host_pool must not be limited as it receives
       // devices assigments automatically
       actual_num_members =
           min_val((u_int32_t)num_members,
                   ((_pool_id == ntop->getPrefs()->get_auto_assigned_pool_id())
                        ? MAX_NUM_INTERFACE_HOSTS
                        : MAX_NUM_POOL_MEMBERS));
 
       if (actual_num_members < num_members) {
         ntop->getTrace()->traceEvent(
             TRACE_WARNING,
             "Too many members [pool id: %2d][pool members: %d]. "
             "Maximum number of pool members for this license is %u, so %u pool "
             "members will be ignored.",
             _pool_id, num_members, actual_num_members,
             num_members - actual_num_members, actual_num_members);
       }
 
       for (int k = 0; k < actual_num_members; k++) {
         member = pool_members[k];
 
         if (!member) continue;
 
         if ((at = strchr(member, '@'))) {
           vlan_id = atoi(at + 1);
           *at = '\0';
         } else
           vlan_id = 0;
 
         bool rc;
 
         if (!(rc = new_tree->addAddress(vlan_id, member, _pool_id))
 #ifdef HOST_POOLS_DEBUG
             || true
 #endif
         )
 
           ntop->getTrace()->traceEvent(
               TRACE_NORMAL, "%s tree node for %s [vlan %i] [host pool: %s]",
               rc ? "Successfully added" : "Unable to add", member, vlan_id,
               pools[i]);
 
         free(member);
       }
 
       free(pool_members);
     }
 
     free(pools[i]);
   }
 
   if (pools) free(pools);
 
   swap(new_tree, new_stats);
 
   iface->refreshHostPools();
 }
 
 /* *************************************** */
diff --git a/src/IEC104Stats.cpp b/src/IEC104Stats.cpp
index 1c6740451..84990b816 100644
--- a/src/IEC104Stats.cpp
+++ b/src/IEC104Stats.cpp
@@ -53,356 +53,352 @@ IEC104Stats::~IEC104Stats() { ndpi_free_data_analysis(i_s_apdu, 0); }
 void IEC104Stats::processPacket(Flow *f, bool tx_direction,
                                 const u_char *payload, u_int16_t payload_len,
                                 struct timeval *packet_time) {
   if ((payload_len >= 6) && (payload[0] == 0x68 /* IEC magic byte */)) {
     u_int offset = 1 /* Skip magic byte */;
     u_int64_t *allowedTypeIDs = ntop->getPrefs()->getIEC104AllowedTypeIDs();
     std::unordered_map<u_int16_t, u_int32_t>::iterator it;
 
     lock.wrlock(__FILE__, __LINE__);
 
     if (tx_direction)
       stats.forward_msgs++;
     else
       stats.reverse_msgs++;
 
     while (offset /* Skip START byte */ < payload_len) {
       /* https://infosys.beckhoff.com/english.php?content=../content/1033/tcplclibiec870_5_104/html/tcplclibiec870_5_104_objref_overview.htm&id
        */
       u_int8_t len = payload[offset],
                pdu_type = ((payload[offset + 1] & 0x01) == 0)
                               ? 0
                               : (payload[offset + 1] & 0x03);
 
 #ifdef DEBUG_IEC60870
       ntop->getTrace()->traceEvent(TRACE_WARNING, "[%s] %02X %02X %02X %02X",
                                    __FUNCTION__, payload[offset - 1],
                                    payload[offset], payload[offset + 1],
                                    payload[offset + 2]);
 #endif
 
 #ifdef DEBUG_IEC60870
       ntop->getTrace()->traceEvent(
           TRACE_WARNING, "[%s] A-PDU Len %u/%u [pdu_type: %u][magic: %02X]",
           __FUNCTION__, len, payload_len, pdu_type, payload[offset - 1]);
 #endif
 
       if (len == 0) break; /* Something went wrong */
 
       switch (pdu_type) {
         case 0x03: /* U */
         {
           u_int8_t u_type = (payload[offset + 1] & 0xFC) >> 2;
           const char *u_type_str;
 
 #ifdef IEC60870_TRACE
           ntop->getTrace()->traceEvent(TRACE_NORMAL, "A-PDU U-%u",
                                        (payload[offset + 1] & 0xFC) >> 2);
 #endif
           /* No rx and tx to be updated */
           stats.type_u++;
 
           switch (u_type) {
             case 0x01:
               u_type_str = "STARTDT act";
               break;
 
             case 0x02:
               u_type_str = "STARTDT con";
               break;
 
             case 0x04:
               u_type_str = "STOPDT act";
               break;
 
             case 0x08:
               u_type_str = "STOPDT con";
               break;
 
             case 0x10:
               u_type_str = "TESTFR act";
               break;
 
             case 0x20:
               u_type_str = "TESTFR con";
               break;
 
             default:
               u_type_str = "???";
               break;
           }
 
           snprintf(infobuf, sizeof(infobuf) - 1, "%s U (%s)",
                    tx_direction ? "->" : "<-", u_type_str);
         } break;
 
         case 0x01: /* S */
           if (len >= 4) {
             u_int16_t rx = ((((u_int16_t)payload[offset + 4]) << 8) +
                             payload[offset + 3]) >>
                            1;
 
             if (last_i_apdu.tv_sec != 0) {
               float ms = Utils::msTimevalDiff(packet_time, &last_i_apdu);
 
 #ifdef IEC60870_TRACE
               ntop->getTrace()->traceEvent(
                   TRACE_NORMAL,
                   "A-PDU S [last I-TX: %u][S RX ack: %u][tdiff: %.2f msec]",
                   tx_seq_num, rx, ms);
 #endif
               /*
                 In theory if all is in good shape
                 (rx + 1) == tx_seq_num
               */
 
               ndpi_data_add_value(i_s_apdu, ms);
             }
 
             /* No rx and tx to be updated */
             snprintf(infobuf, sizeof(infobuf) - 1, "%s S, RX %u",
                      tx_direction ? "->" : "<-", rx);
           }
 
           stats.type_s++;
           break;
       }
 
       if (pdu_type != 0x0 /* Type I */) {
         offset += len + 2;
         stats.type_other++;
         continue;
       }
 
       /* From now on, only Type I packets are processed */
       memcpy(&last_i_apdu, packet_time, sizeof(struct timeval));
       stats.type_i++;
 
       if (len >= 6 /* Ignore 4 bytes APDUs */) {
         u_int16_t rx_value, tx_value;
         bool initial_run =
             ((rx_seq_num == 0) && (tx_seq_num == 0)) ? true : false;
 
-        tx_value =
-            ((((u_int16_t)payload[offset + 2]) << 8) + payload[offset + 1]) >>
-            1;
-        rx_value =
-            ((((u_int16_t)payload[offset + 4]) << 8) + payload[offset + 3]) >>
-            1;
+        tx_value = ((((u_int16_t)payload[offset + 2]) << 8) + payload[offset + 1]) >> 1;
+        rx_value = ((((u_int16_t)payload[offset + 4]) << 8) + payload[offset + 3]) >> 1;
 
         if (!tx_direction) {
           /* Counters are swapped */
           u_int16_t v = rx_value;
 
           rx_value = tx_value;
           tx_value = v;
         }
 
         if ((tx_value == tx_seq_num) && (rx_value == rx_seq_num)) {
           stats.retransmitted_msgs++;
           lock.unlock(__FILE__, __LINE__);
           return;
         }
 
         if (!initial_run) {
           u_int32_t diff = abs(tx_value - (tx_seq_num + 1));
 
           /* Check for id reset (16 bit only) */
           if (diff != 32768) pkt_lost.tx += diff;
         }
         tx_seq_num = tx_value;
 
         if (!tx_direction) {
           if (!initial_run) {
             u_int32_t diff = abs(rx_value - rx_seq_num);
 
             /* Check for id reset (16 bit only) */
             if (diff != 32768) pkt_lost.rx += diff;
           }
 
           rx_value++; /* The next RX will be increased by 1 */
         } else {
           if (!initial_run) {
             u_int32_t diff = abs(rx_value - rx_seq_num);
 
             /* Check for id reset (16 bit only) */
             if (diff != 32768) pkt_lost.rx += diff;
           }
         }
         rx_seq_num = rx_value;
 
         /* Skip magic(1), len(1), type/TX(2), RX(2) = 6 */
         len -= 6 /* Skip magic and len */,
-            offset += 5 /* magic already skept */;
+	  offset += 5 /* magic already skept */;
 
         if (payload_len >= (offset + len)) {
           u_int8_t type_id = payload[offset];
           u_int8_t cause_tx = payload[offset + 1] & 0x3F;
           u_int8_t negative =
               ((payload[offset + 1] & 0x40) == 0x40) ? true : false;
           u_int16_t asdu;
           u_int64_t bit;
           bool unexpected_typeid_alerted = false;
 
           offset += len + 2 /* magic and len */;
 
           if (len >= 6)
             asdu = /* ntohs */ (*((u_int16_t *)&payload[4 + offset]));
           else
             asdu = 0;
 
 #ifdef DEBUG_IEC60870
           ntop->getTrace()->traceEvent(
               TRACE_WARNING, "[%s] TypeId %u [offset %u/%u]", __FUNCTION__,
               type_id, offset, payload_len);
 #endif
 
 #ifdef IEC60870_TRACE
           ntop->getTrace()->traceEvent(
               TRACE_NORMAL,
               "[%s] A-PDU I-%-3u [rx: %u][tx: %u][lost rx/tx: %u/%u]",
               tx_direction ? "->" : "<-", type_id, rx_seq_num, tx_seq_num,
               pkt_lost.rx, pkt_lost.tx);
 #endif
 
           snprintf(infobuf, sizeof(infobuf) - 1, "%s I, RX %u, TX %u",
                    tx_direction ? "->" : "<-", rx_seq_num, tx_seq_num);
 
           if (!initial_run) {
             u_int32_t transition = (last_type_i << 8) + type_id;
 
             it = type_i_transitions.find(transition);
 
             if (it == type_i_transitions.end()) {
               if (f->get_duration() > ntop->getPrefs()->getIEC60870LearingPeriod()) {
                 FlowAlert *alert = NULL;
                 u_int16_t c_score = 50, s_score = 10;
 
 #ifdef IEC60870_TRACE
                 ntop->getTrace()->traceEvent(TRACE_NORMAL,
                                              "Found new transition %u -> %u",
                                              last_type_i, type_id);
 #endif
                 char key[128], rsp[64];
                 snprintf(key, sizeof(key), CHECKS_IEC_INVALID_TRANSITION);
 
                 if ((!ntop->getRedis()->get(key, rsp, sizeof(rsp))) &&
                     ((rsp[0] != '\0') && (!strcmp(rsp, "1"))))
                   alert = new IECInvalidTransitionAlert(NULL, f, packet_time,
                                                         last_type_i, type_id);
 
                 if (alert) {
                   f->setPredominantAlertInfo(alert);
                   f->triggerAlertSync(alert, c_score, s_score);
                 }
 
                 type_i_transitions[transition] = 2; /* Post Learning */
               } else
                 type_i_transitions[transition] = 1; /* During Learning */
             } else
               type_i_transitions[transition] = it->second + 1;
           }
 
           if (!initial_run) {
             if (isMonitoringTypeId(last_type_i) && isMonitoringTypeId(type_id))
               transitions.m_to_m++;
             else if (isMonitoringTypeId(last_type_i) &&
                      isCommandTypeId(type_id))
               transitions.m_to_c++;
             else if (isCommandTypeId(last_type_i) &&
                      isMonitoringTypeId(type_id))
               transitions.c_to_m++;
             else if (isCommandTypeId(last_type_i) && isCommandTypeId(type_id))
               transitions.c_to_c++;
 
             if ((invalid_command_transition_detected == false) &&
                 ((transitions.m_to_c > 20) || (transitions.c_to_m > 20) ||
                  (transitions.c_to_c > 5))) {
               /* https://github.com/ntop/ntopng/issues/6598 */
               FlowAlert *alert = NULL;
               u_int16_t c_score = CLIENT_ALERT_SCORE,
                         s_score = SERVER_ALERT_SCORE;
 
               char key[128], rsp[64];
               snprintf(key, sizeof(key), CHECKS_IEC_INVALID_COMMAND_TRANSITION);
 
               if ((!ntop->getRedis()->get(key, rsp, sizeof(rsp))) &&
                   ((rsp[0] != '\0') && (!strcmp(rsp, "1"))))
                 alert = new IECInvalidCommandTransitionAlert(
                     NULL, f, packet_time, transitions.m_to_c,
                     transitions.c_to_m, transitions.c_to_c);
 
               if (alert) {
                 f->setPredominantAlertInfo(alert);
                 f->triggerAlertSync(alert, c_score, s_score);
               }
 
               // ntop->getTrace()->traceEvent(TRACE_WARNING, "*** INVALID
               // TRANSITION %u -> %u", last_type_i, type_id);
 
               invalid_command_transition_detected = true;
             }
           }
 
           last_type_i = type_id;
 
           it = typeid_uses.find(type_id);
 
           if (it == typeid_uses.end())
             typeid_uses[type_id] = 1;
           else
             typeid_uses[type_id] = it->second + 1;
 
           if (type_id < 64) {
             bit = ((u_int64_t)1) << type_id;
             if ((allowedTypeIDs[0] & bit) == 0)
               unexpected_typeid_alerted = true;
           } else if (type_id < 128) {
             bit = ((u_int64_t)1) << (type_id - 64);
 
             if ((allowedTypeIDs[1] & bit) == 0)
               unexpected_typeid_alerted = true;
           }
 
           if (unexpected_typeid_alerted) {
             FlowAlert *alert = NULL;
             u_int16_t c_score = CLIENT_ALERT_SCORE,
                       s_score = SERVER_ALERT_SCORE;
 
             char key[128], rsp[64];
             snprintf(key, sizeof(key), CHECKS_IEC_UNEXPECTED_TYPE_ID);
 
             if ((!ntop->getRedis()->get(key, rsp, sizeof(rsp))) &&
                 ((rsp[0] != '\0') && (!strcmp(rsp, "1"))))
               alert = new IECUnexpectedTypeIdAlert(NULL, f, type_id, asdu,
                                                    cause_tx, negative);
 
             if (alert) {
               f->setPredominantAlertInfo(alert);
               f->triggerAlertSync(alert, c_score, s_score);
             }
           } /* unexpected_typeid_alerted */
           /* Discard typeIds 127..255 */
         } else /* payload_len < len */
           break;
       } else {
         // ntop->getTrace()->traceEvent(TRACE_WARNING, "*** short APDUs");
         break;
       }
-
-      if (payload[offset] == 0x68 /* IEC magic byte */)
+      
+      if((offset < payload_len) && (payload[offset] == 0x68 /* IEC magic byte */))
         offset += 1; /* We skip the initial magic byte */
       else {
 #ifdef DEBUG_IEC60870
         ntop->getTrace()->traceEvent(
             TRACE_WARNING, "Skipping IEC entry: no magic byte @ offset %u",
             offset);
 #endif
         break;
       }
     } /* while */
 
     lock.unlock(__FILE__, __LINE__);
   }
 }
 
 /* *************************************** */
diff --git a/src/LuaEngine.cpp b/src/LuaEngine.cpp
index 156ee8db3..9c2ead45c 100644
--- a/src/LuaEngine.cpp
+++ b/src/LuaEngine.cpp
@@ -965,442 +965,442 @@ void build_redirect(const char *url, const char *query_string, char *buf,
 int LuaEngine::handle_script_request(struct mg_connection *conn,
                                      const struct mg_request_info *request_info,
                                      char *script_path, bool *attack_attempt,
                                      const char *user, const char *group,
                                      const char *session_csrf, bool localuser) {
   NetworkInterface *iface = NULL;
   char key[64], ifname[MAX_INTERFACE_NAME_LEN];
   bool is_interface_allowed;
   AddressTree ptree;
-  int rc, post_data_len;
+  int rc, post_data_len = 0;
   const char *content_type;
   u_int8_t valid_csrf = 1;
   char *post_data = NULL;
   char csrf[64] = {'\0'};
   char switch_interface[2] = {'\0'};
   char addr_buf[64];
   char session_buf[64];
   char ifid_buf[32], obs_id_buf[16], session_key[32];
   const char *origin_header;
   bool send_redirect = false;
   IpAddress client_addr;
   int num_uploaded_files = 0;
 
   *attack_attempt = false;
 
   if (!L) return (-1);
 
   luaL_openlibs(L);              /* Load base libraries */
   lua_register_classes(L, true); /* Load custom classes */
 
   getLuaVMUservalue(L, conn) = conn;
 
   content_type = mg_get_header(conn, "Content-Type");
   Utils::make_session_key(session_key, sizeof(session_key));
   mg_get_cookie(conn, session_key, session_buf, sizeof(session_buf));
 
   /* Check for POST requests */
   if ((strcmp(request_info->request_method, "POST") == 0) &&
       (content_type != NULL)) {
     int content_len = mg_get_content_len(conn) + 1;
     bool is_file_upload =
         (strncmp(content_type, "multipart/form-data", 19) == 0) ? true : false;
 
     if ((!is_file_upload) && (content_len > HTTP_MAX_POST_DATA_LEN)) {
       ntop->getTrace()->traceEvent(TRACE_WARNING,
                                    "Too much data submitted with the form. "
                                    "[data len: %u][max len: %u][URI: %s]",
                                    content_len, HTTP_MAX_POST_DATA_LEN,
                                    request_info->uri);
       valid_csrf = 0;
     } else {
       if (is_file_upload) {
         if ((!is_file_upload) && (content_len > HTTP_MAX_UPLOAD_DATA_LEN)) {
           ntop->getTrace()->traceEvent(TRACE_WARNING,
                                        "You are uploading a file that is too "
                                        "big [len: %u][max len: %u][URI: %s]",
                                        content_len, HTTP_MAX_UPLOAD_DATA_LEN,
                                        request_info->uri);
           valid_csrf = 0;
         } else {
           char fname[1024], upload_dir[512];
 
           snprintf(upload_dir, sizeof(upload_dir), "%s/tmp/upload",
                    ntop->get_working_dir());
           ntop->fixPath(upload_dir);
 
           if (!Utils::mkdir_tree(upload_dir))
             ntop->getTrace()->traceEvent(
                 TRACE_WARNING, "Unable to create directory %s", upload_dir);
           else {
             /* NOTE: mongoose is currently unable to handle multiple fields in a
              * single upload */
             num_uploaded_files =
                 mg_upload(conn, upload_dir, fname, sizeof(fname));
 
             if (num_uploaded_files > 0) {
               char uploaded_file[2048];
 
               snprintf(uploaded_file, sizeof(uploaded_file), "%s/%s",
                        upload_dir, fname);
               ntop->fixPath(uploaded_file);
 
               lua_newtable(L);
               lua_push_str_table_entry(L, "uploaded_file", uploaded_file);
 
               if (request_info->query_string) {
                 char *d = strdup(request_info->query_string);
 
                 if (d != NULL) {
                   char *where;
                   char *tok = strtok_r(d, "&", &where);
 
                   while (tok != NULL) {
                     char *tok_where;
                     char *k = strtok_r(tok, "=", &tok_where);
 
                     if (k != NULL) {
                       char *v = strtok_r(NULL, "=", &tok_where);
 
                       if (v != NULL) lua_push_str_table_entry(L, k, v);
                     }
 
                     tok = strtok_r(NULL, "&", &where);
                   } /* while */
                 }
               }
 
               lua_setglobal(L, "_POST");
               valid_csrf = 1; /* Dummy */
             }
           }
         }
       } else if ((post_data = (char *)malloc(content_len * sizeof(char))) ==
                      NULL ||
                  (post_data_len = mg_read(conn, post_data, content_len)) == 0) {
         valid_csrf = 0;
       } else {
         post_data[post_data_len] = '\0';
 
         if (!strcmp(session_csrf, NTOP_CSRF_TOKEN_NO_SESSION)) {
           /* Authentication has taken place with direct username:password
              submission, without the use of a session, hence, this request
              cannot be the result of a CSRF attack which, by construction,
              relies on a valid session. */
           valid_csrf = 1;
         } else {
           /* If here, authentication has taken place using a session, thus CSRF
              is mandatory in POST request and must be checked for validity. Note
              that session_csrf is trusted, that it it comes from ntopng, whereas
              csrf read from the POST is untrusted. */
           if (strstr(content_type, "application/json") == content_type) {
             /*
               post_data is JSON which is only allowed when using the REST API
             */
             if ((strstr(request_info->uri, REST_API_PREFIX) ||
                  strstr(request_info->uri, REST_API_PRO_PREFIX)) &&
                 strstr(request_info->uri, "/get/")) {
               /*
                 REST API URI, GET, no CSRF required
               */
             } else {
               /*
                 REST API URIs not containing /get/, e.g., /set/, /add/,
                 /delete/, are assumed to change the status of ntopng and thus
                 CSRF checks MUST be enforced. In this case, post_data is decoded
                 as JSON to enforce the check.
               */
               json_object *o = NULL, *csrf_o;
 
               if (!(o = json_tokener_parse(post_data)) ||
                   !json_object_object_get_ex(o, "csrf", &csrf_o) ||
                   !strncpy(csrf, json_object_get_string(csrf_o),
                            sizeof(csrf) - 1) ||
                   strncmp(session_csrf, csrf, NTOP_CSRF_TOKEN_LENGTH)) {
                 /*
                   Either the CSRF token has not been submitted as part of the
                   JSON, or the submitted token is invalid.
                 */
                 valid_csrf = 0;
               }
 
               if (o) json_object_put(o);
             }
           } else {
             /*
               post_data is assumed to be application/x-www-form-urlencoded
               CSRF token is searched and validated using mg_get_var
             */
             mg_get_var(post_data, post_data_len, "csrf", csrf, sizeof(csrf));
 
             if (strncmp(session_csrf, csrf, NTOP_CSRF_TOKEN_LENGTH))
               valid_csrf = 0;
           }
         }
       }
     }
 
     if (num_uploaded_files == 0) {
       /* Empty CSRF only allowed for nologin user. Such user has no associated
        * session so it has an empty CSRF. */
       if (valid_csrf) {
         if (strstr(content_type, "application/x-www-form-urlencoded") ==
             content_type)
           *attack_attempt =
               setParamsTable(L, request_info, "_POST",
                              post_data); /* CSRF is valid here, now fill the
                                             _POST table with POST parameters */
         else {
           /* application/json */
 
           lua_newtable(L);
           lua_push_str_table_entry(
               L, "payload", post_data); /* This payload is NOT parsed, checked
                                            or verified against attacks */
           lua_setglobal(L, "_POST");
         }
 
         /* Check for interface switch requests */
         mg_get_var(post_data, post_data_len, "switch_interface",
                    switch_interface, sizeof(switch_interface));
         if (strlen(switch_interface) > 0 && request_info->query_string) {
           /* Read the interface id */
           mg_get_var(request_info->query_string,
                      strlen(request_info->query_string), "ifid", ifid_buf,
                      sizeof(ifid_buf));
           /* Read the observation point id */
           mg_get_var(request_info->query_string,
                      strlen(request_info->query_string), "observationPointId",
                      obs_id_buf, sizeof(obs_id_buf));
           if (strlen(ifid_buf) > 0) {
             switchInterface(L, ifid_buf, obs_id_buf, user, group, session_buf);
 
             /* Sending a redirect is needed to prevent the current lua script
              * from receiving the POST request, as it could exchange the request
              * as a configuration save request. */
             send_redirect = true;
           }
         }
       } else {
         *attack_attempt =
             setParamsTable(L, request_info, "_POST", NULL /* Empty */);
       }
 
       if (post_data) free(post_data);
     }
   } else
     *attack_attempt =
         setParamsTable(L, request_info, "_POST", NULL /* Empty */);
 
   if (send_redirect) {
     char buf[2048], uri[512];
 
     snprintf(uri, sizeof(uri), "%s%s", ntop->getPrefs()->get_http_prefix(),
              request_info->uri);
     build_redirect(uri, request_info->query_string, buf, sizeof(buf));
 
     /* Redirect the page and terminate this request */
     mg_printf(conn, "%s", buf);
     return (CONST_LUA_OK);
   }
 
   /* Put the GET params into the environment */
   if (request_info->query_string)
     *attack_attempt =
         setParamsTable(L, request_info, "_GET", request_info->query_string);
   else
     *attack_attempt = setParamsTable(L, request_info, "_GET", NULL /* Empty */);
 
   /* _SERVER */
   lua_newtable(L);
   lua_push_str_table_entry(L, "REQUEST_METHOD",
                            (char *)request_info->request_method);
   lua_push_str_table_entry(
       L, "URI",
       (char *)request_info->uri ? (char *)request_info->uri : (char *)"");
   lua_push_str_table_entry(L, "REFERER",
                            (char *)mg_get_header(conn, "Referer")
                                ? (char *)mg_get_header(conn, "Referer")
                                : (char *)"");
 
   const char *host = mg_get_header(conn, "Host");
 
   if (host) {
     lua_pushfstring(L, "%s://%s", (request_info->is_ssl) ? "https" : "http",
                     host);
     lua_pushstring(L, "HTTP_HOST");
     lua_insert(L, -2);
     lua_settable(L, -3);
   }
 
   if (request_info->remote_user)
     lua_push_str_table_entry(L, "REMOTE_USER",
                              (char *)request_info->remote_user);
   if (request_info->query_string)
     lua_push_str_table_entry(L, "QUERY_STRING",
                              (char *)request_info->query_string);
 
   /* Additional headers can be added eventually */
   origin_header = mg_get_header(conn, "Origin");
   if (origin_header) lua_push_str_table_entry(L, "Origin", origin_header);
 
   for (int i = 0; ((request_info->http_headers[i].name != NULL) &&
                    request_info->http_headers[i].name[0] != '\0');
        i++)
     lua_push_str_table_entry(L, request_info->http_headers[i].name,
                              (char *)request_info->http_headers[i].value);
 
   client_addr.set(mg_get_client_address(conn));
   lua_push_str_table_entry(
       L, "REMOTE_ADDR", (char *)client_addr.print(addr_buf, sizeof(addr_buf)));
 
   lua_setglobal(L, (char *)"_SERVER");
 
   /* NOTE: ntopng cannot rely on user provided cookies for security data (e.g.
    * user or group), use the session data instead! */
   char *_cookies;
 
   /* Cookies */
   lua_newtable(L);
   if ((_cookies = (char *)mg_get_header(conn, "Cookie")) != NULL) {
     char *cookies = strdup(_cookies);
     char *tok, *where;
 
     // ntop->getTrace()->traceEvent(TRACE_WARNING, "=> '%s'", cookies);
     tok = strtok_r(cookies, "=", &where);
     while (tok != NULL) {
       char *val;
 
       while (tok[0] == ' ') tok++;
 
       if ((val = strtok_r(NULL, ";", &where)) != NULL) {
         lua_push_str_table_entry(L, tok, val);
         // ntop->getTrace()->traceEvent(TRACE_WARNING, "'%s'='%s'", tok, val);
       } else
         break;
 
       tok = strtok_r(NULL, "=", &where);
     }
 
     free(cookies);
   }
   lua_setglobal(L, "_COOKIE"); /* Like in php */
 
   /*
     Read user capabilities
   */
   u_int64_t capabilities = 0;
   char allowed_nets[MAX_USER_NETS_VAL_LEN];
 
   if (strncmp(group, CONST_USER_GROUP_ADMIN, strlen(CONST_USER_GROUP_ADMIN)) ==
       0) {
     /*
       Administrators have all the possible capabilitites
     */
     capabilities = (u_int64_t)-1;
     snprintf(allowed_nets, sizeof(allowed_nets), CONST_DEFAULT_ALL_NETS);
   } else {
     /*
       Non-administrators only have a subset of capabilities - stored on redis
     */
     bool allow_pcap_download = false, allow_historical_flows = false,
          allow_alerts = false;
 
     char val[32];
     snprintf(key, sizeof(key), CONST_STR_USER_CAPABILITIES, user);
     if ((ntop->getRedis()->get(key, val, sizeof(val)) != -1) &&
         (val[0] != '\0')) {
       capabilities = strtol(val, NULL, 10);
     }
 
     /*
       Read user allowed networks - stored on redis
     */
     snprintf(key, sizeof(key), CONST_STR_USER_NETS, user);
     if (ntop->getRedis()->get(key, allowed_nets, sizeof(allowed_nets)) == -1) {
       /*
         Set the default (allow all), if no allowed networks are found
       */
       snprintf(allowed_nets, sizeof(allowed_nets), CONST_DEFAULT_ALL_NETS);
     }
 
     ntop->getUserCapabilities(user, &allow_pcap_download,
                               &allow_historical_flows, &allow_alerts);
 
     if (allow_historical_flows)
       capabilities |= (1 << capability_historical_flows);
 
     if (allow_alerts) capabilities |= (1 << capability_alerts);
 
     if (allow_pcap_download) capabilities |= (1 << capability_pcap_download);
   }
 
   /* Put the _SESSION params into the environment */
   lua_newtable(L);
 
   lua_push_str_table_entry(L, "session", session_buf);
   lua_push_str_table_entry(L, "user", (char *)user);
   lua_push_str_table_entry(L, "group", (char *)group);
   lua_push_bool_table_entry(L, "localuser", localuser);
   lua_push_uint64_table_entry(L, "capabilities", capabilities);
   lua_push_str_table_entry(L, "allowed_nets", (char *)allowed_nets);
 
   // now it's time to set the interface.
   setInterface(user, ifname, sizeof(ifname), &is_interface_allowed);
 
   if (!valid_csrf) lua_push_bool_table_entry(L, "INVALID_CSRF", true);
 
   lua_setglobal(L, "_SESSION"); /* Like in php */
 
   if (user[0] != '\0') {
     char val[16];
     getLuaVMUservalue(L, user) = (char *)user;
 
     /* Populate a patricia tree with the user allowed networks */
     ptree.addAddresses(allowed_nets);
 
     getLuaVMUservalue(L, allowedNets) = &ptree;
     // ntop->getTrace()->traceEvent(TRACE_WARNING, "SET [p: %p][val: %s][user:
     // %s]", &ptree, val, user);
 
     snprintf(key, sizeof(key), CONST_STR_USER_LANGUAGE, user);
     if ((ntop->getRedis()->get(key, val, sizeof(val)) != -1) &&
         (val[0] != '\0')) {
       lua_pushstring(L, val);
     } else
       lua_pushstring(L, NTOP_DEFAULT_USER_LANG);
 
     lua_setglobal(L, CONST_USER_LANGUAGE);
   }
 
   getLuaVMUservalue(L, group) = (char *)(group ? (group) : "");
   getLuaVMUservalue(L, localuser) = localuser;
   getLuaVMUservalue(L, csrf) = (char *)session_csrf;
   getLuaVMUservalue(L, capabilities) = capabilities;
 
   iface = ntop->getNetworkInterface(ifname); /* Can't be null */
   /* 'select' ther interface that has already been set into the _SESSION */
   getLuaVMUservalue(L, iface) = iface;
 
   if (is_interface_allowed)
     getLuaVMUservalue(L, allowed_ifname) = iface->get_name();
 
 #ifdef NTOPNG_PRO
   if (ntop->getPro()->has_valid_license())
     rc = __ntop_lua_handlefile(L, script_path, true);
   else
 #endif
     rc = luaL_dofile(L, script_path);
 
   if (rc != 0) {
     const char *err = lua_tostring(L, -1);
 
     ntop->getTrace()->traceEvent(TRACE_WARNING, "Script failure [%s][%s]",
                                  script_path, err);
     return (redirect_to_error_page(conn, request_info, "internal_error",
                                    script_path, (char *)err));
   }
 
   return (CONST_LUA_OK);
 }
 
 /* ****************************************** */
diff --git a/src/LuaEngineInterface.cpp b/src/LuaEngineInterface.cpp
index 8748932ab..6c93fe562 100644
--- a/src/LuaEngineInterface.cpp
+++ b/src/LuaEngineInterface.cpp
@@ -5115,31 +5115,31 @@ static int ntop_interface_is_syslog_interface(lua_State *vm) {
 /* ****************************************** */
 
 static int ntop_clickhouse_exec_csv_query(lua_State *vm) {
+#ifdef HAVE_CLICKHOUSE
   NetworkInterface *ntop_interface = getCurrentInterface(vm);
   const char *sql;
-  struct mg_connection *conn = getLuaVMUserdata(vm, conn);
   bool use_json = false;
+  struct mg_connection *conn = getLuaVMUserdata(vm, conn);
 
   ntop->getTrace()->traceEvent(TRACE_DEBUG, "%s() called", __FUNCTION__);
 
   if ((!ntop_interface) || (!conn))
     return (ntop_lua_return_value(vm, __FUNCTION__, CONST_LUA_ERROR));
 
   if (ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING) != CONST_LUA_OK)
     return (ntop_lua_return_value(vm, __FUNCTION__, CONST_LUA_PARAM_ERROR));
 
   sql = lua_tostring(vm, 1);
-
+  
   if (lua_type(vm, 2) == LUA_TBOOLEAN) /* optional */
     use_json = lua_toboolean(vm, 2) ? true : false;
 
-#ifdef HAVE_CLICKHOUSE
   ntop_interface->exec_csv_query(sql, use_json, conn);
 #endif
 
   lua_pushnil(vm); /* Data is pushed via the HTTP server */
 
   return (ntop_lua_return_value(vm, __FUNCTION__, CONST_LUA_OK));
 }
 
 /* ****************************************** */
diff --git a/src/NetworkInterface.cpp b/src/NetworkInterface.cpp
index f064c0123..2c6b77cee 100644
--- a/src/NetworkInterface.cpp
+++ b/src/NetworkInterface.cpp
@@ -2481,609 +2481,612 @@ bool NetworkInterface::dissectPacket(u_int32_t bridge_iface_idx,
 datalink_check:
   if (pcap_datalink_type == DLT_NULL) {
     if (h->caplen < sizeof(u_int32_t))
       return (false);
 
-    memcpy(&null_type, &packet[eth_offset], sizeof(u_int32_t));
-
+    if((eth_offset + sizeof(u_int32_t)) <= h->caplen)
+      memcpy(&null_type, &packet[eth_offset], sizeof(u_int32_t));
+    else
+      return (false);    
+    
     switch (null_type) {
       case BSD_AF_INET:
         eth_type = ETHERTYPE_IP;
         break;
       case BSD_AF_INET6_BSD:
       case BSD_AF_INET6_FREEBSD:
       case BSD_AF_INET6_DARWIN:
         eth_type = ETHERTYPE_IPV6;
         break;
       default:
         incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
                  NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
         goto dissect_packet_end; /* Any other non IP protocol */
     }
 
     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
     if (sender_mac) memcpy(&dummy_ethernet.h_source, sender_mac, 6);
     ip_offset = 4 + eth_offset;
   } else if (pcap_datalink_type == DLT_EN10MB) {
     if (h->caplen < sizeof(ndpi_ethhdr))
       return (false);
 
     ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];
     ip_offset = sizeof(struct ndpi_ethhdr) + eth_offset;
     eth_type = ntohs(ethernet->h_proto);
   } else if (pcap_datalink_type == 113 /* Linux Cooked Capture */) {
     if (h->caplen < 16)
       return (false);
 
     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
     if (sender_mac) memcpy(&dummy_ethernet.h_source, sender_mac, 6);
     eth_type = (packet[eth_offset + 14] << 8) + packet[eth_offset + 15];
     ip_offset = 16 + eth_offset;
 #ifdef DLT_RAW
   } else if (pcap_datalink_type == DLT_RAW /* Linux TUN/TAP device in TUN mode; Raw IP capture */
              || pcap_datalink_type == 14 /* raw IP DLT_RAW on OpenBSD captures */) {
     if (h->caplen < sizeof(u_int32_t))
       return (false);
 
     switch ((packet[eth_offset] & 0xf0) >> 4) {
       case 4:
         eth_type = ETHERTYPE_IP;
         break;
       case 6:
         eth_type = ETHERTYPE_IPV6;
         break;
       default:
         incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
                  NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
         goto dissect_packet_end; /* Unknown IP protocol version */
     }
 
     if (sender_mac) memcpy(&dummy_ethernet.h_source, sender_mac, 6);
     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
     ip_offset = eth_offset;
 #endif /* DLT_RAW */
   } else if (pcap_datalink_type == DLT_ENC) {
     if (packet[0] == 2 /* IPv4 */) {
       eth_type = ETHERTYPE_IP;
       ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
       ip_offset = 12;
     }
     /* TODO support IPv6 encapsulation one day */
   } else if (pcap_datalink_type == DLT_IPV4) {
     eth_type = ETHERTYPE_IP;
     if (sender_mac) memcpy(&dummy_ethernet.h_source, sender_mac, 6);
     ethernet = (struct ndpi_ethhdr *)&dummy_ethernet;
     ip_offset = 0;
   } else {
     incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
              NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
     goto dissect_packet_end;
   }
 
   /*
     Make sure this label is BEFORE detunneling of VLAN or MPLS traffic.
     Otherwise, VLAN or MPLS traffic carried inside other tunnels, i.e.,
     GRE or ERSPAN, won't be detunneled.
   */
 decode_packet_eth:
 
-  while (true) {
-    if (eth_type == 0x8100 /* VLAN */) {
+  while (ip_offset < h->caplen) {
+    if((eth_type == 0x8100 /* VLAN */) && ((ip_offset + sizeof(Ether80211q)) < h->caplen)) {
       Ether80211q *qType = (Ether80211q *)&packet[ip_offset];
 
       vlan_id = ntohs(qType->vlanId) & 0xFFF;
       eth_type = (packet[ip_offset + 2] << 8) + packet[ip_offset + 3];
       ip_offset += 4;
-    } else if (eth_type == 0x8847 /* MPLS */) {
+    } else if((eth_type == 0x8847 /* MPLS */) && ((unsigned int)(ip_offset + 2) <  h->caplen)) {
       u_int8_t bos; /* bottom_of_stack */
 
       bos = (((u_int8_t)packet[ip_offset + 2]) & 0x1), ip_offset += 4;
       if (bos) {
         u_int8_t is_ethernet;
 
         eth_type = guessEthType((const u_char *)&packet[ip_offset],
                                 h->caplen - ip_offset, &is_ethernet);
 
         if (is_ethernet) ip_offset += sizeof(struct ndpi_ethhdr);
         break;
       }
     } else
       break;
   }
 
   /* Setting traffic direction based on MAC */
   if (ethernet) {
     if (isTrafficMirrored()) {
       /* Mirror */
       if (isGwMac(ethernet->h_dest)) ingressPacket = false;
     } else if (!areTrafficDirectionsSupported()) {
       /* Interface with no direction info */
       if (isInterfaceMac(ethernet->h_source)) ingressPacket = false;
     }
   }
 
   switch (eth_type) {
     case ETHERTYPE_PPPoE:
       ip_offset += 6 /* PPPoE */;
       /* Now we need to skip the PPP header */
       if (packet[ip_offset] == 0x0)
         eth_type = packet[ip_offset + 1], ip_offset += 2; /* 2 Byte protocol */
       else
         eth_type = packet[ip_offset], ip_offset += 1; /* 1 Byte protocol */
 
       switch (eth_type) {
         case 0x21:
           eth_type = ETHERTYPE_IP;
           break;
 
         case 0x57:
           eth_type = ETHERTYPE_IPV6;
           break;
 
         default:
           incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IP,
                    NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0,
                    len_on_wire, 1);
           goto dissect_packet_end;
       }
       goto decode_packet_eth;
       break;
 
     case ETHERTYPE_IP:
       if (h->caplen >= ip_offset + sizeof(struct ndpi_iphdr)) {
         u_int16_t frag_off;
         struct ndpi_iphdr *iph = (struct ndpi_iphdr *)&packet[ip_offset];
         u_short ip_len = ((u_short)iph->ihl * 4);
         struct ndpi_ipv6hdr *ip6 = NULL;
 
         if (iph->version != 4) {
           /* This is not IPv4 */
           incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IP,
                    NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0,
                    len_on_wire, 1);
           goto dissect_packet_end;
         } else
           frag_off = ntohs(iph->frag_off);
 
         if (ntop->getGlobals()->decode_tunnels() &&
             (iph->protocol == IPPROTO_GRE) &&
             ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */) == 0) &&
             h->caplen >= ip_offset + ip_len + sizeof(struct grev1_header)) {
           struct grev1_header gre;
           u_int offset = ip_offset + ip_len + sizeof(struct grev1_header);
 
           memcpy(&gre, &packet[ip_offset + ip_len],
                  sizeof(struct grev1_header));
           gre.flags_and_version = ntohs(gre.flags_and_version);
           gre.proto = ntohs(gre.proto);
 
           if (gre.flags_and_version &
               (GRE_HEADER_CHECKSUM | GRE_HEADER_ROUTING))
             offset += 4;
           if (gre.flags_and_version & GRE_HEADER_KEY) offset += 4;
           if (gre.flags_and_version & GRE_HEADER_SEQ_NUM) offset += 4;
 
           if (h->caplen >= offset) {
             if (gre.proto == 0x6558 /* Transparent Ethernet Bridging */) {
               eth_offset = offset;
               goto datalink_check;
             } else if (gre.proto == ETHERTYPE_IP) {
               ip_offset = offset, encapsulation_overhead = offset;
               goto decode_packet_eth;
             } else if (gre.proto == ETHERTYPE_IPV6) {
               eth_type = ETHERTYPE_IPV6;
               ip_offset = offset, encapsulation_overhead = offset;
               goto decode_packet_eth;
             }
           }
 
           /* ERSPAN Type 2 has an 8-byte header
              https://tools.ietf.org/html/draft-foschiano-erspan-00 */
           if (h->caplen >= offset + sizeof(struct ndpi_ethhdr) + 8) {
             if (gre.proto == ETH_P_ERSPAN /* ERSPAN type II */) {
               offset += 8;
               eth_offset = offset, encapsulation_overhead = offset;
               ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];
               ip_offset = eth_offset + sizeof(struct ndpi_ethhdr);
               eth_type = ntohs(ethernet->h_proto);
               goto decode_packet_eth;
             } else if (gre.proto ==
                        ETH_P_ERSPAN2 /* ERSPAN version 2 (type III) */) {
               if (h->caplen >= offset + sizeof(struct ndpi_ethhdr) + 20) {
                 offset += 20;
                 eth_offset = offset, encapsulation_overhead = offset;
                 ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];
                 ip_offset = eth_offset + sizeof(struct ndpi_ethhdr);
                 eth_type = ntohs(ethernet->h_proto);
                 goto decode_packet_eth;
               }
             } else {
               /* Unknown encapsulation */
             }
           }
         } else if (ntop->getGlobals()->decode_tunnels() &&
                    iph->protocol == IPPROTO_IPV6 &&
                    h->caplen >=
                        ip_offset + ip_len + sizeof(struct ndpi_ipv6hdr)) {
           /* Detunnel 6in4 tunnel */
           ip_offset += ip_len;
           eth_type = ETHERTYPE_IPV6;
           encapsulation_overhead = ip_offset;
           goto decode_packet_eth;
         } else if (ntop->getGlobals()->decode_tunnels() &&
                    (iph->protocol == IPPROTO_UDP) &&
                    ((frag_off & 0x3FFF /* IP_MF | IP_OFFSET */) == 0)) {
           struct ndpi_udphdr *udp =
               (struct ndpi_udphdr *)&packet[ip_offset + ip_len];
           u_int16_t sport = ntohs(udp->source), dport = ntohs(udp->dest);
 
           if ((sport == GTP_U_V1_PORT) || (dport == GTP_U_V1_PORT)) {
             /* Check if it's GTPv1 */
             u_int offset =
                 (u_int)(ip_offset + ip_len + sizeof(struct ndpi_udphdr));
             u_int8_t flags = packet[offset];
             u_int8_t message_type = packet[offset + 1];
 
             if ((((flags & 0xE0) >> 5) == 1 /* GTPv1 */) &&
                 (message_type == 0xFF /* T-PDU */)) {
               ip_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr) +
                           8 /* GTPv1 header len */;
 
               if (flags & 0x04) ip_offset += 1; /* next_ext_header is present */
               if (flags & 0x02)
                 ip_offset += 4; /* sequence_number is present (it also includes
                                    next_ext_header and pdu_number) */
               if (flags & 0x01) ip_offset += 1; /* pdu_number is present */
 
               iph = (struct ndpi_iphdr *)&packet[ip_offset];
 
               if (iph->version != 4) {
                 /* FIX - Add IPv6 support */
                 incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IPV6,
                          NDPI_PROTOCOL_UNKNOWN,
                          NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
                 goto dissect_packet_end;
               }
             }
           } else if ((sport == TZSP_PORT) || (dport == TZSP_PORT)) {
             /* https://en.wikipedia.org/wiki/TZSP */
             u_int offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
             u_int8_t version = packet[offset];
             u_int8_t type = packet[offset + 1];
             u_int16_t encapsulates = ntohs(*((u_int16_t *)&packet[offset + 2]));
 
             if ((version == 1) && (type == 0) && (encapsulates == 1)) {
               u_int8_t stop = 0;
 
               offset += 4;
 
               while ((!stop) && (offset < h->caplen)) {
                 u_int8_t tag_type = packet[offset];
                 u_int8_t tag_len;
 
                 switch (tag_type) {
                   case 0: /* PADDING Tag */
                     tag_len = 1;
                     break;
                   case 1: /* END Tag */
                     tag_len = 1, stop = 1;
                     break;
                   default:
                     tag_len = packet[offset + 1];
                     break;
                 }
 
                 offset += tag_len;
 
                 if (offset >= h->caplen) {
                   incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IPV6,
                            NDPI_PROTOCOL_UNKNOWN,
                            NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire,
                            1);
                   goto dissect_packet_end;
                 } else {
                   eth_offset = offset;
                   goto datalink_check;
                 }
               }
             }
           } else if (dport == VXLAN_PORT) {
             eth_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr) +
                          sizeof(struct ndpi_vxlanhdr);
             goto datalink_check;
           }
 
           if ((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {
             /*
               Control And Provisioning of Wireless Access Points
 
               https://www.rfc-editor.org/rfc/rfc5415.txt
 
               CAPWAP Header          - variable length (5 MSB of byte 2 of
               header) IEEE 802.11 Data Flags - 24 bytes Logical-Link Control   -
               8  bytes
 
               Total = CAPWAP_header_length + 24 + 8
             */
             u_short eth_type;
             ip_offset = ip_offset + ip_len + sizeof(struct ndpi_udphdr);
             u_int8_t capwap_header_len =
                 ((*(u_int8_t *)&packet[ip_offset + 1]) >> 3) * 4;
             ip_offset = ip_offset + capwap_header_len + 24 + 8;
 
             if (ip_offset >= h->len) {
               incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
                        NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
               goto dissect_packet_end;
             }
             eth_type = ntohs(*(u_int16_t *)&packet[ip_offset - 2]);
 
             switch (eth_type) {
               case ETHERTYPE_IP:
                 iph = (struct ndpi_iphdr *)&packet[ip_offset];
                 break;
               case ETHERTYPE_IPV6:
                 iph = NULL;
                 ip6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
                 break;
               default:
                 incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
                          NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
                 goto dissect_packet_end;
             }
           }
         } else if (ntop->getGlobals()->decode_tunnels() &&
                    (iph->protocol == IPPROTO_IP_IN_IP)) {
           u_short ip_len = ((u_short)iph->ihl * 4);
 
           ip_offset += ip_len, eth_type = ETHERTYPE_IP;
 
           if (ip_offset > h->caplen)
             goto dissect_packet_end;
           else
             goto decode_packet_eth;
         }
 
         if (vlan_id && ntop->getPrefs()->do_ignore_vlans()) vlan_id = 0;
         if ((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())
           vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] +
                                ip6->ip6_dst.u6_addr.u6_addr8[15]
                          : iph->saddr + iph->daddr) &
                     0xFFF;
 
         if (ntop->getPrefs()->do_ignore_macs())
           ethernet = &dummy_ethernet;
         else if (unlikely(ntop->getPrefs()->do_simulate_macs())) {
           dummy_ethernet.h_source[0] = 0xb8, dummy_ethernet.h_source[1] = 0x27,
           dummy_ethernet.h_source[2] = 0xeb, dummy_ethernet.h_source[3] = 0xfd,
           dummy_ethernet.h_source[4] = 0x8e,
           dummy_ethernet.h_source[5] = rand() % 8;
           dummy_ethernet.h_dest[0] = 0xb8, dummy_ethernet.h_dest[1] = 0x27,
           dummy_ethernet.h_dest[2] = 0xeb, dummy_ethernet.h_dest[3] = 0xfd,
           dummy_ethernet.h_dest[4] = 0x8e,
           dummy_ethernet.h_dest[5] = rand() % 8;
           ethernet = &dummy_ethernet;
         }
 
         try {
           pass_verdict = processPacket(
               bridge_iface_idx, ingressPacket, &h->ts, time, ethernet, vlan_id,
               iph, ip6, ip_offset, encapsulation_overhead, len_on_wire, h,
               packet, ndpiProtocol, srcHost, dstHost, flow);
         } catch (std::bad_alloc &ba) {
           static bool oom_warning_sent = false;
 
           if (!oom_warning_sent) {
             ntop->getTrace()->traceEvent(TRACE_WARNING, "Not enough memory");
             oom_warning_sent = true;
           }
         }
       }
       break;
 
     case ETHERTYPE_IPV6:
       if (h->caplen >= ip_offset + sizeof(struct ndpi_ipv6hdr)) {
         struct ndpi_iphdr *iph = NULL;
         struct ndpi_ipv6hdr *ip6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
 
         if ((ntohl(ip6->ip6_hdr.ip6_un1_flow) & 0xF0000000) != 0x60000000) {
           /* This is not IPv6 */
           incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IPV6,
                    NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0,
                    len_on_wire, 1);
           goto dissect_packet_end;
         } else {
           u_int ipv6_shift = sizeof(const struct ndpi_ipv6hdr);
           u_int8_t l4_proto = ip6->ip6_hdr.ip6_un1_nxt;
 
           if (l4_proto == 0x3C /* IPv6 destination option */) {
             u_int8_t *options = (u_int8_t *)ip6 + ipv6_shift;
             l4_proto = options[0];
             ipv6_shift = 8 * (options[1] + 1);
           }
 
           if (ntop->getGlobals()->decode_tunnels() &&
               (l4_proto == IPPROTO_GRE) &&
               h->caplen >=
                   ip_offset + ipv6_shift + sizeof(struct grev1_header)) {
             struct grev1_header gre;
             u_int offset = ip_offset + ipv6_shift + sizeof(struct grev1_header);
 
             memcpy(&gre, &packet[ip_offset + ipv6_shift],
                    sizeof(struct grev1_header));
             gre.flags_and_version = ntohs(gre.flags_and_version);
             gre.proto = ntohs(gre.proto);
 
             if (gre.flags_and_version &
                 (GRE_HEADER_CHECKSUM | GRE_HEADER_ROUTING))
               offset += 4;
             if (gre.flags_and_version & GRE_HEADER_KEY) offset += 4;
             if (gre.flags_and_version & GRE_HEADER_SEQ_NUM) offset += 4;
 
             if (h->caplen >= offset) {
               if (gre.proto == ETHERTYPE_IP) {
                 eth_type = ETHERTYPE_IP;
                 ip_offset = offset, encapsulation_overhead = offset;
                 goto decode_packet_eth;
               } else if (gre.proto == ETHERTYPE_IPV6) {
                 ip_offset = offset, encapsulation_overhead = offset;
                 goto decode_packet_eth;
               }
             }
 
             if (h->caplen >= offset + sizeof(struct ndpi_ethhdr) +
                                  8 /* ERSPAN Type 2 header */) {
               if (gre.proto == ETH_P_ERSPAN) {
                 offset += 8;
                 eth_offset = offset, encapsulation_overhead = offset;
                 ethernet = (struct ndpi_ethhdr *)&packet[eth_offset];
                 ip_offset = eth_offset + sizeof(struct ndpi_ethhdr);
                 eth_type = ntohs(ethernet->h_proto);
                 goto decode_packet_eth;
               } else if (gre.proto == ETH_P_ERSPAN2) {
                 ; /* TODO: support ERSPAN Type 3 */
               } else {
                 /* Unknown encapsulation */
               }
             }
           } else if (ntop->getGlobals()->decode_tunnels() &&
                      (l4_proto == IPPROTO_UDP)) {
             // ip_offset += ipv6_shift;
             if ((ip_offset + ipv6_shift) >= h->len) {
               incStats(ingressPacket, h->ts.tv_sec, ETHERTYPE_IPV6,
                        NDPI_PROTOCOL_UNKNOWN,
                        NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
               goto dissect_packet_end;
             }
 
             struct ndpi_udphdr *udp =
                 (struct ndpi_udphdr *)&packet[ip_offset + ipv6_shift];
             u_int16_t sport = udp->source, dport = udp->dest;
 
             if ((sport == CAPWAP_DATA_PORT) || (dport == CAPWAP_DATA_PORT)) {
               /*
                 Control And Provisioning of Wireless Access Points
 
                 https://www.rfc-editor.org/rfc/rfc5415.txt
 
                 CAPWAP Header          - variable length (5 MSB of byte 2 of
                 header) IEEE 802.11 Data Flags - 24 bytes Logical-Link Control
                 - 8  bytes
 
                 Total = CAPWAP_header_length + 24 + 8
               */
 
               u_short eth_type;
               ip_offset = ip_offset + ipv6_shift + sizeof(struct ndpi_udphdr);
               u_int8_t capwap_header_len =
                   ((*(u_int8_t *)&packet[ip_offset + 1]) >> 3) * 4;
               ip_offset = ip_offset + capwap_header_len + 24 + 8;
 
               if (ip_offset >= h->len) {
                 incStats(ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
                          NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
                 goto dissect_packet_end;
               }
               eth_type = ntohs(*(u_int16_t *)&packet[ip_offset - 2]);
 
               switch (eth_type) {
                 case ETHERTYPE_IP:
                   iph = (struct ndpi_iphdr *)&packet[ip_offset];
                   ip6 = NULL;
                   break;
                 case ETHERTYPE_IPV6:
                   ip6 = (struct ndpi_ipv6hdr *)&packet[ip_offset];
                   break;
                 default:
                   incStats(
                       ingressPacket, h->ts.tv_sec, 0, NDPI_PROTOCOL_UNKNOWN,
                       NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
                   goto dissect_packet_end;
               }
             }
           } else if (ntop->getGlobals()->decode_tunnels() &&
                      (l4_proto == IPPROTO_IP_IN_IP)) {
             eth_type = ETHERTYPE_IP;
             ip_offset += sizeof(struct ndpi_ipv6hdr);
             encapsulation_overhead = ip_offset;
             goto decode_packet_eth;
           }
 
           if (vlan_id && ntop->getPrefs()->do_ignore_vlans()) vlan_id = 0;
           if ((vlan_id == 0) && ntop->getPrefs()->do_simulate_vlans())
             vlan_id = (ip6 ? ip6->ip6_src.u6_addr.u6_addr8[15] +
                                  ip6->ip6_dst.u6_addr.u6_addr8[15]
                            : iph->saddr + iph->daddr) %
                       0xFF;
 
           if (ntop->getPrefs()->do_ignore_macs()) ethernet = &dummy_ethernet;
 
           try {
             pass_verdict = processPacket(
                 bridge_iface_idx, ingressPacket, &h->ts, time, ethernet,
                 vlan_id, iph, ip6, ip_offset, encapsulation_overhead,
                 len_on_wire, h, packet, ndpiProtocol, srcHost, dstHost, flow);
           } catch (std::bad_alloc &ba) {
             static bool oom_warning_sent = false;
 
             if (!oom_warning_sent) {
               ntop->getTrace()->traceEvent(TRACE_WARNING, "Not enough memory");
               oom_warning_sent = true;
             }
           }
         }
       }
       break;
 
     default: /* No IPv4 nor IPv6 */
       if (ntop->getPrefs()->do_ignore_macs()) ethernet = &dummy_ethernet;
 
       if (ethernet == NULL) {
         incStats(ingressPacket, h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN,
                  NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
         goto dissect_packet_end;
       }
 
       Mac *srcMac = getMac(ethernet->h_source, true /* Create if missing */,
                            true /* Inline call */);
       Mac *dstMac = getMac(ethernet->h_dest, true /* Create if missing */,
                            true /* Inline call */);
 
       /* NOTE: in nEdge, stats are updated into Flow::update_hosts_stats */
 #ifndef HAVE_NEDGE
       if (srcMac) srcMac->incSentStats(h->ts.tv_sec, 1, len_on_wire);
       if (dstMac) dstMac->incRcvdStats(h->ts.tv_sec, 1, len_on_wire);
 #endif
 
       if ((eth_type == ETHERTYPE_ARP) &&
           (h->caplen >= (sizeof(arp_header) + sizeof(struct ndpi_ethhdr)))) {
         struct arp_header *arpp = (struct arp_header *)&packet[ip_offset];
         u_int16_t arp_opcode = ntohs(arpp->ar_op);
 
         /* Updates interface broadcast domains, according to what is seen in
          * this ARP that glues together L2 and L3 */
         updateBroadcastDomains(vlan_id, ethernet->h_source, ethernet->h_dest,
                                ntohl(arpp->arp_spa), ntohl(arpp->arp_tpa));
 
         if (srcMac && dstMac && (!srcMac->isNull() || !dstMac->isNull())) {
           setSeenMacAddresses();
           srcMac->setSourceMac();
 
           if (arp_opcode == 0x1 /* ARP request */) {
             arp_requests++;
             srcMac->incSentArpRequests();
             dstMac->incRcvdArpRequests();
           } else if (arp_opcode == 0x2 /* ARP reply */) {
             arp_replies++;
             srcMac->incSentArpReplies();
             dstMac->incRcvdArpReplies();
 
             checkMacIPAssociation(true, arpp->arp_sha, arpp->arp_spa, srcMac);
             checkMacIPAssociation(true, arpp->arp_tha, arpp->arp_tpa, dstMac);
           }
         }
       }
 
       incStats(ingressPacket, h->ts.tv_sec, eth_type, NDPI_PROTOCOL_UNKNOWN,
                NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, 0, len_on_wire, 1);
       break;
   }
diff --git a/src/flow_checks/CustomFlowLuaScript.cpp b/src/flow_checks/CustomFlowLuaScript.cpp
index c7f3f5256..98d0b9bf4 100644
--- a/src/flow_checks/CustomFlowLuaScript.cpp
+++ b/src/flow_checks/CustomFlowLuaScript.cpp
@@ -37,34 +37,34 @@ CustomFlowLuaScript::CustomFlowLuaScript()
 /* ***************************************************** */
 
 LuaEngine *CustomFlowLuaScript::initVM(const char *script_path) {
-  char where[256];
+  char where[512];
   struct stat s;
 
   snprintf(where, sizeof(where), "%s/%s", ntop->get_install_dir(), script_path);
 
   if (stat(where, &s) != 0) {
     ntop->getTrace()->traceEvent(
         TRACE_NORMAL,
         "Unable to find script %s: ignored `Flow User Check Script` flow check",
         where);
     return (NULL);
   } else {
     LuaEngine *lua;
 
     try {
       lua = new LuaEngine(NULL);
       lua->load_script(
           (char *)where,
           NULL /* NetworkInterface filled later via lua->setFlow(f); */);
       ntop->getTrace()->traceEvent(TRACE_NORMAL, "Loaded custom user script %s",
                                    where);
     } catch (std::bad_alloc &ba) {
       lua = NULL;
       ntop->getTrace()->traceEvent(TRACE_ERROR,
                                    "Unable to start Lua interpreter.");
     }
 
     return (lua);
   }
 }
 /* ***************************************************** */
diff --git a/src/host_checks/CustomHostLuaScript.cpp b/src/host_checks/CustomHostLuaScript.cpp
index f9c57d84d..44660606a 100644
--- a/src/host_checks/CustomHostLuaScript.cpp
+++ b/src/host_checks/CustomHostLuaScript.cpp
@@ -54,38 +54,38 @@ CustomHostLuaScript::~CustomHostLuaScript() {
 LuaEngine *CustomHostLuaScript::initVM() {
   const char *script_path =
       "scripts/callbacks/checks/hosts/custom_host_lua_script.lua";
-  char where[256];
+  char where[512];
   struct stat s;
 
   snprintf(where, sizeof(where), "%s/%s", ntop->get_install_dir(), script_path);
 
   if (stat(where, &s) != 0) {
     if (!disabled) {
       ntop->getTrace()->traceEvent(TRACE_NORMAL,
                                    "Unable to find script %s: ignored `Host "
                                    "User Check Script` host check",
                                    where);
       disabled = true;
     }
 
     return (NULL);
   } else {
     LuaEngine *lua;
 
     try {
       lua = new LuaEngine(NULL);
       lua->load_script((char *)where,
                        NULL /* NetworkInterface filled later below */);
       ntop->getTrace()->traceEvent(TRACE_NORMAL, "Loaded custom user script %s",
                                    where);
     } catch (std::bad_alloc &ba) {
       ntop->getTrace()->traceEvent(TRACE_ERROR,
                                    "Unable to start Lua interpreter.");
       lua = NULL;
     }
 
     return (lua);
   }
 }
 
 /* ***************************************************** */
