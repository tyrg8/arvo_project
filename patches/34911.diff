commit 6704961c8250b44dc622e95821fd7e2b6bed673a
Author: Idan Horowitz <idan.horowitz@gmail.com>
Date:   Sat Sep 11 02:15:44 2021 +0300

    AK: Replace the mutable String::replace API with an immutable version
    
    This removes the awkward String::replace API which was the only String
    API which mutated the String and replaces it with a new immutable
    version that returns a new String with the replacements applied. This
    also fixes a couple of UAFs that were caused by the use of this API.
    
    As an optimization an equivalent StringView::replace API was also added
    to remove an unnecessary String allocations in the format of:
    `String { view }.replace(...);`

diff --git a/AK/String.cpp b/AK/String.cpp
index 1d8a6e844a..df2d0730c6 100644
--- a/AK/String.cpp
+++ b/AK/String.cpp
@@ -352,36 +352,6 @@ bool String::equals_ignoring_case(const StringView& other) const
     return StringUtils::equals_ignoring_case(view(), other);
 }
 
-int String::replace(const String& needle, const String& replacement, bool all_occurrences)
-{
-    if (is_empty())
-        return 0;
-
-    Vector<size_t> positions;
-    if (all_occurrences) {
-        positions = find_all(needle);
-    } else {
-        auto pos = find(needle);
-        if (!pos.has_value())
-            return 0;
-        positions.append(pos.value());
-    }
-
-    if (!positions.size())
-        return 0;
-
-    StringBuilder b;
-    size_t lastpos = 0;
-    for (auto& pos : positions) {
-        b.append(substring_view(lastpos, pos - lastpos));
-        b.append(replacement);
-        lastpos = pos + needle.length();
-    }
-    b.append(substring_view(lastpos, length() - lastpos));
-    m_impl = StringImpl::create(b.build().characters());
-    return positions.size();
-}
-
 String String::reverse() const
 {
     StringBuilder reversed_string(length());
diff --git a/AK/String.h b/AK/String.h
index 623c23fbb4..d5c47e1dab 100644
--- a/AK/String.h
+++ b/AK/String.h
@@ -41,256 +41,256 @@ class String {
 public:
     ~String() = default;
 
     String() = default;
 
     String(const StringView& view)
     {
         m_impl = StringImpl::create(view.characters_without_null_termination(), view.length());
     }
 
     String(const String& other)
         : m_impl(const_cast<String&>(other).m_impl)
     {
     }
 
     String(String&& other)
         : m_impl(move(other.m_impl))
     {
     }
 
     String(const char* cstring, ShouldChomp shouldChomp = NoChomp)
         : m_impl(StringImpl::create(cstring, shouldChomp))
     {
     }
 
     String(const char* cstring, size_t length, ShouldChomp shouldChomp = NoChomp)
         : m_impl(StringImpl::create(cstring, length, shouldChomp))
     {
     }
 
     explicit String(ReadonlyBytes bytes, ShouldChomp shouldChomp = NoChomp)
         : m_impl(StringImpl::create(bytes, shouldChomp))
     {
     }
 
     String(const StringImpl& impl)
         : m_impl(const_cast<StringImpl&>(impl))
     {
     }
 
     String(const StringImpl* impl)
         : m_impl(const_cast<StringImpl*>(impl))
     {
     }
 
     String(RefPtr<StringImpl>&& impl)
         : m_impl(move(impl))
     {
     }
 
     String(NonnullRefPtr<StringImpl>&& impl)
         : m_impl(move(impl))
     {
     }
 
     String(const FlyString&);
 
     [[nodiscard]] static String repeated(char, size_t count);
     [[nodiscard]] static String repeated(const StringView&, size_t count);
 
     [[nodiscard]] static String bijective_base_from(size_t value, unsigned base = 26, StringView map = {});
     [[nodiscard]] static String roman_number_from(size_t value);
 
     template<class SeparatorType, class CollectionType>
     [[nodiscard]] static String join(const SeparatorType& separator, const CollectionType& collection)
     {
         StringBuilder builder;
         builder.join(separator, collection);
         return builder.build();
     }
 
     [[nodiscard]] bool matches(const StringView& mask, CaseSensitivity = CaseSensitivity::CaseInsensitive) const;
     [[nodiscard]] bool matches(const StringView& mask, Vector<MaskSpan>&, CaseSensitivity = CaseSensitivity::CaseInsensitive) const;
 
     template<typename T = int>
     [[nodiscard]] Optional<T> to_int(TrimWhitespace = TrimWhitespace::Yes) const;
     template<typename T = unsigned>
     [[nodiscard]] Optional<T> to_uint(TrimWhitespace = TrimWhitespace::Yes) const;
 
     [[nodiscard]] String to_lowercase() const;
     [[nodiscard]] String to_uppercase() const;
     [[nodiscard]] String to_snakecase() const;
     [[nodiscard]] String to_titlecase() const;
 
     [[nodiscard]] bool is_whitespace() const { return StringUtils::is_whitespace(*this); }
 
 #ifndef KERNEL
     [[nodiscard]] String trim(const StringView& characters, TrimMode mode = TrimMode::Both) const
     {
         return StringUtils::trim(view(), characters, mode);
     }
 
     [[nodiscard]] String trim_whitespace(TrimMode mode = TrimMode::Both) const
     {
         return StringUtils::trim_whitespace(view(), mode);
     }
 #endif
 
     [[nodiscard]] bool equals_ignoring_case(const StringView&) const;
 
     [[nodiscard]] bool contains(const StringView&, CaseSensitivity = CaseSensitivity::CaseSensitive) const;
     [[nodiscard]] bool contains(char, CaseSensitivity = CaseSensitivity::CaseSensitive) const;
 
     [[nodiscard]] Vector<String> split_limit(char separator, size_t limit, bool keep_empty = false) const;
     [[nodiscard]] Vector<String> split(char separator, bool keep_empty = false) const;
     [[nodiscard]] Vector<StringView> split_view(char separator, bool keep_empty = false) const;
 
     [[nodiscard]] Optional<size_t> find(char needle, size_t start = 0) const { return StringUtils::find(*this, needle, start); }
     [[nodiscard]] Optional<size_t> find(StringView const& needle, size_t start = 0) const { return StringUtils::find(*this, needle, start); }
     [[nodiscard]] Optional<size_t> find_last(char needle) const { return StringUtils::find_last(*this, needle); }
     // FIXME: Implement find_last(StringView const&) for API symmetry.
     [[nodiscard]] Vector<size_t> find_all(StringView const& needle) const { return StringUtils::find_all(*this, needle); }
     using SearchDirection = StringUtils::SearchDirection;
     [[nodiscard]] Optional<size_t> find_any_of(StringView const& needles, SearchDirection direction) const { return StringUtils::find_any_of(*this, needles, direction); }
 
     [[nodiscard]] String substring(size_t start, size_t length) const;
     [[nodiscard]] String substring(size_t start) const;
     [[nodiscard]] StringView substring_view(size_t start, size_t length) const;
     [[nodiscard]] StringView substring_view(size_t start) const;
 
     [[nodiscard]] bool is_null() const { return !m_impl; }
     [[nodiscard]] ALWAYS_INLINE bool is_empty() const { return length() == 0; }
     [[nodiscard]] ALWAYS_INLINE size_t length() const { return m_impl ? m_impl->length() : 0; }
     // Includes NUL-terminator, if non-nullptr.
     [[nodiscard]] ALWAYS_INLINE const char* characters() const { return m_impl ? m_impl->characters() : nullptr; }
 
     [[nodiscard]] bool copy_characters_to_buffer(char* buffer, size_t buffer_size) const;
 
     [[nodiscard]] ALWAYS_INLINE ReadonlyBytes bytes() const
     {
         if (m_impl) {
             return m_impl->bytes();
         }
         return {};
     }
 
     [[nodiscard]] ALWAYS_INLINE const char& operator[](size_t i) const
     {
         VERIFY(!is_null());
         return (*m_impl)[i];
     }
 
     using ConstIterator = SimpleIterator<const String, const char>;
 
     [[nodiscard]] constexpr ConstIterator begin() const { return ConstIterator::begin(*this); }
     [[nodiscard]] constexpr ConstIterator end() const { return ConstIterator::end(*this); }
 
     [[nodiscard]] bool starts_with(const StringView&, CaseSensitivity = CaseSensitivity::CaseSensitive) const;
     [[nodiscard]] bool ends_with(const StringView&, CaseSensitivity = CaseSensitivity::CaseSensitive) const;
     [[nodiscard]] bool starts_with(char) const;
     [[nodiscard]] bool ends_with(char) const;
 
     bool operator==(const String&) const;
     bool operator!=(const String& other) const { return !(*this == other); }
 
     bool operator==(const StringView&) const;
     bool operator!=(const StringView& other) const { return !(*this == other); }
 
     bool operator==(const FlyString&) const;
     bool operator!=(const FlyString& other) const { return !(*this == other); }
 
     bool operator<(const String&) const;
     bool operator<(const char*) const;
     bool operator>=(const String& other) const { return !(*this < other); }
     bool operator>=(const char* other) const { return !(*this < other); }
 
     bool operator>(const String&) const;
     bool operator>(const char*) const;
     bool operator<=(const String& other) const { return !(*this > other); }
     bool operator<=(const char* other) const { return !(*this > other); }
 
     bool operator==(const char* cstring) const;
     bool operator!=(const char* cstring) const { return !(*this == cstring); }
 
     [[nodiscard]] String isolated_copy() const;
 
     [[nodiscard]] static String empty()
     {
         return StringImpl::the_empty_stringimpl();
     }
 
     [[nodiscard]] StringImpl* impl() { return m_impl.ptr(); }
     [[nodiscard]] const StringImpl* impl() const { return m_impl.ptr(); }
 
     String& operator=(String&& other)
     {
         if (this != &other)
             m_impl = move(other.m_impl);
         return *this;
     }
 
     String& operator=(const String& other)
     {
         if (this != &other)
             m_impl = const_cast<String&>(other).m_impl;
         return *this;
     }
 
     String& operator=(std::nullptr_t)
     {
         m_impl = nullptr;
         return *this;
     }
 
     String& operator=(ReadonlyBytes bytes)
     {
         m_impl = StringImpl::create(bytes);
         return *this;
     }
 
     [[nodiscard]] u32 hash() const
     {
         if (!m_impl)
             return 0;
         return m_impl->hash();
     }
 
     [[nodiscard]] ByteBuffer to_byte_buffer() const;
 
     template<typename BufferType>
     [[nodiscard]] static String copy(const BufferType& buffer, ShouldChomp should_chomp = NoChomp)
     {
         if (buffer.is_empty())
             return empty();
         return String((const char*)buffer.data(), buffer.size(), should_chomp);
     }
 
     [[nodiscard]] static String vformatted(StringView fmtstr, TypeErasedFormatParams&);
 
     template<typename... Parameters>
     [[nodiscard]] static String formatted(CheckedFormatString<Parameters...>&& fmtstr, const Parameters&... parameters)
     {
         VariadicFormatParams variadic_format_parameters { parameters... };
         return vformatted(fmtstr.view(), variadic_format_parameters);
     }
 
     template<typename T>
     [[nodiscard]] static String number(T value) requires IsArithmetic<T>
     {
         return formatted("{}", value);
     }
 
     [[nodiscard]] StringView view() const
     {
         return { characters(), length() };
     }
 
-    int replace(const String& needle, const String& replacement, bool all_occurrences = false);
+    [[nodiscard]] String replace(const StringView& needle, const StringView& replacement, bool all_occurrences = false) const { return StringUtils::replace(*this, needle, replacement, all_occurrences); }
     [[nodiscard]] size_t count(StringView const& needle) const { return StringUtils::count(*this, needle); }
     [[nodiscard]] String reverse() const;
 
     template<typename... Ts>
     [[nodiscard]] ALWAYS_INLINE constexpr bool is_one_of(Ts&&... strings) const
     {
         return (... || this->operator==(forward<Ts>(strings)));
     }
diff --git a/AK/StringUtils.cpp b/AK/StringUtils.cpp
index ee0594e7e9..887620c663 100644
--- a/AK/StringUtils.cpp
+++ b/AK/StringUtils.cpp
@@ -414,19 +414,47 @@ String to_snakecase(const StringView& str)
 String to_titlecase(StringView const& str)
 {
     StringBuilder builder;
     bool next_is_upper = true;
 
     for (auto ch : str) {
         if (next_is_upper)
             builder.append_code_point(to_ascii_uppercase(ch));
         else
             builder.append_code_point(to_ascii_lowercase(ch));
         next_is_upper = ch == ' ';
     }
 
     return builder.to_string();
 }
 
+String replace(StringView const& str, StringView const& needle, StringView const& replacement, bool all_occurrences)
+{
+    if (str.is_empty())
+        return str;
+
+    Vector<size_t> positions;
+    if (all_occurrences) {
+        positions = str.find_all(needle);
+        if (!positions.size())
+            return str;
+    } else {
+        auto pos = str.find(needle);
+        if (!pos.has_value())
+            return str;
+        positions.append(pos.value());
+    }
+
+    StringBuilder replaced_string;
+    size_t last_position = 0;
+    for (auto& position : positions) {
+        replaced_string.append(str.substring_view(last_position, position - last_position));
+        replaced_string.append(replacement);
+        last_position = position + needle.length();
+    }
+    replaced_string.append(str.substring_view(last_position, str.length() - last_position));
+    return replaced_string.build();
+}
+
 // TODO: Benchmark against KMP (AK/MemMem.h) and switch over if it's faster for short strings too
 size_t count(StringView const& str, StringView const& needle)
 {
diff --git a/AK/StringUtils.h b/AK/StringUtils.h
index 661ce963db..dabf4a1fef 100644
--- a/AK/StringUtils.h
+++ b/AK/StringUtils.h
@@ -71,6 +71,7 @@ Optional<size_t> find_any_of(StringView const& haystack, StringView const& needl
 String to_snakecase(const StringView&);
 String to_titlecase(StringView const&);
 
+String replace(StringView const&, StringView const& needle, StringView const& replacement, bool all_occurrences = false);
 size_t count(StringView const&, StringView const& needle);
 
 }
diff --git a/AK/StringView.cpp b/AK/StringView.cpp
index 0aeb124676..83f90e2d3c 100644
--- a/AK/StringView.cpp
+++ b/AK/StringView.cpp
@@ -245,4 +245,9 @@ bool StringView::operator==(const String& string) const
 
 String StringView::to_string() const { return String { *this }; }
 
+String StringView::replace(const StringView& needle, const StringView& replacement, bool all_occurrences) const
+{
+    return StringUtils::replace(*this, needle, replacement, all_occurrences);
+}
+
 }
diff --git a/AK/StringView.h b/AK/StringView.h
index f6868d1b8a..fa1905d885 100644
--- a/AK/StringView.h
+++ b/AK/StringView.h
@@ -21,209 +21,210 @@ class StringView {
 public:
     ALWAYS_INLINE constexpr StringView() = default;
     ALWAYS_INLINE constexpr StringView(const char* characters, size_t length)
         : m_characters(characters)
         , m_length(length)
     {
         if (!is_constant_evaluated())
             VERIFY(!Checked<uintptr_t>::addition_would_overflow((uintptr_t)characters, length));
     }
     ALWAYS_INLINE StringView(const unsigned char* characters, size_t length)
         : m_characters((const char*)characters)
         , m_length(length)
     {
         VERIFY(!Checked<uintptr_t>::addition_would_overflow((uintptr_t)characters, length));
     }
     ALWAYS_INLINE constexpr StringView(const char* cstring)
         : m_characters(cstring)
         , m_length(cstring ? __builtin_strlen(cstring) : 0)
     {
     }
     ALWAYS_INLINE StringView(ReadonlyBytes bytes)
         : m_characters(reinterpret_cast<const char*>(bytes.data()))
         , m_length(bytes.size())
     {
     }
 
     StringView(const ByteBuffer&);
     StringView(const String&);
     StringView(const FlyString&);
 
     explicit StringView(ByteBuffer&&) = delete;
     explicit StringView(String&&) = delete;
     explicit StringView(FlyString&&) = delete;
 
     [[nodiscard]] constexpr bool is_null() const { return !m_characters; }
     [[nodiscard]] constexpr bool is_empty() const { return m_length == 0; }
 
     [[nodiscard]] constexpr char const* characters_without_null_termination() const { return m_characters; }
     [[nodiscard]] constexpr size_t length() const { return m_length; }
 
     [[nodiscard]] ReadonlyBytes bytes() const { return { m_characters, m_length }; }
 
     constexpr const char& operator[](size_t index) const { return m_characters[index]; }
 
     using ConstIterator = SimpleIterator<const StringView, const char>;
 
     [[nodiscard]] constexpr ConstIterator begin() const { return ConstIterator::begin(*this); }
     [[nodiscard]] constexpr ConstIterator end() const { return ConstIterator::end(*this); }
 
     [[nodiscard]] constexpr unsigned hash() const
     {
         if (is_empty())
             return 0;
         return string_hash(characters_without_null_termination(), length());
     }
 
     [[nodiscard]] bool starts_with(const StringView&, CaseSensitivity = CaseSensitivity::CaseSensitive) const;
     [[nodiscard]] bool ends_with(const StringView&, CaseSensitivity = CaseSensitivity::CaseSensitive) const;
     [[nodiscard]] bool starts_with(char) const;
     [[nodiscard]] bool ends_with(char) const;
     [[nodiscard]] bool matches(const StringView& mask, CaseSensitivity = CaseSensitivity::CaseInsensitive) const;
     [[nodiscard]] bool matches(const StringView& mask, Vector<MaskSpan>&, CaseSensitivity = CaseSensitivity::CaseInsensitive) const;
     [[nodiscard]] bool contains(char) const;
     [[nodiscard]] bool contains(const StringView&, CaseSensitivity = CaseSensitivity::CaseSensitive) const;
     [[nodiscard]] bool equals_ignoring_case(const StringView& other) const;
 
     [[nodiscard]] StringView trim(const StringView& characters, TrimMode mode = TrimMode::Both) const { return StringUtils::trim(*this, characters, mode); }
     [[nodiscard]] StringView trim_whitespace(TrimMode mode = TrimMode::Both) const { return StringUtils::trim_whitespace(*this, mode); }
 
     [[nodiscard]] String to_lowercase_string() const;
     [[nodiscard]] String to_uppercase_string() const;
     [[nodiscard]] String to_titlecase_string() const;
 
     [[nodiscard]] Optional<size_t> find(char needle, size_t start = 0) const { return StringUtils::find(*this, needle, start); }
     [[nodiscard]] Optional<size_t> find(StringView const& needle, size_t start = 0) const { return StringUtils::find(*this, needle, start); }
     [[nodiscard]] Optional<size_t> find_last(char needle) const { return StringUtils::find_last(*this, needle); }
     // FIXME: Implement find_last(StringView const&) for API symmetry.
 
     [[nodiscard]] Vector<size_t> find_all(StringView const& needle) const { return StringUtils::find_all(*this, needle); }
 
     using SearchDirection = StringUtils::SearchDirection;
     [[nodiscard]] Optional<size_t> find_any_of(StringView const& needles, SearchDirection direction = SearchDirection::Forward) { return StringUtils::find_any_of(*this, needles, direction); }
 
     [[nodiscard]] constexpr StringView substring_view(size_t start, size_t length) const
     {
         if (!is_constant_evaluated())
             VERIFY(start + length <= m_length);
         return { m_characters + start, length };
     }
 
     [[nodiscard]] constexpr StringView substring_view(size_t start) const
     {
         return substring_view(start, length() - start);
     }
 
     [[nodiscard]] Vector<StringView> split_view(char, bool keep_empty = false) const;
     [[nodiscard]] Vector<StringView> split_view(const StringView&, bool keep_empty = false) const;
 
     template<typename UnaryPredicate>
     [[nodiscard]] Vector<StringView> split_view_if(UnaryPredicate&& predicate, bool keep_empty = false) const
     {
         if (is_empty())
             return {};
 
         Vector<StringView> v;
         size_t substart = 0;
         for (size_t i = 0; i < length(); ++i) {
             char ch = characters_without_null_termination()[i];
             if (predicate(ch)) {
                 size_t sublen = i - substart;
                 if (sublen != 0 || keep_empty)
                     v.append(substring_view(substart, sublen));
                 substart = i + 1;
             }
         }
         size_t taillen = length() - substart;
         if (taillen != 0 || keep_empty)
             v.append(substring_view(substart, taillen));
         return v;
     }
 
     // Create a Vector of StringViews split by line endings. As of CommonMark
     // 0.29, the spec defines a line ending as "a newline (U+000A), a carriage
     // return (U+000D) not followed by a newline, or a carriage return and a
     // following newline.".
     [[nodiscard]] Vector<StringView> lines(bool consider_cr = true) const;
 
     template<typename T = int>
     Optional<T> to_int() const;
     template<typename T = unsigned>
     Optional<T> to_uint() const;
 
     // Create a new substring view of this string view, starting either at the beginning of
     // the given substring view, or after its end, and continuing until the end of this string
     // view (that is, for the remaining part of its length). For example,
     //
     //    StringView str { "foobar" };
     //    StringView substr = str.substring_view(1, 2);  // "oo"
     //    StringView substr_from = str.substring_view_starting_from_substring(subst);  // "oobar"
     //    StringView substr_after = str.substring_view_starting_after_substring(subst);  // "bar"
     //
     // Note that this only works if the string view passed as an argument is indeed a substring
     // view of this string view, such as one created by substring_view() and split_view(). It
     // does not work for arbitrary strings; for example declaring substr in the example above as
     //
     //     StringView substr { "oo" };
     //
     // would not work.
     [[nodiscard]] StringView substring_view_starting_from_substring(const StringView& substring) const;
     [[nodiscard]] StringView substring_view_starting_after_substring(const StringView& substring) const;
 
     constexpr bool operator==(const char* cstring) const
     {
         if (is_null())
             return !cstring;
         if (!cstring)
             return false;
         // NOTE: `m_characters` is not guaranteed to be null-terminated, but `cstring` is.
         const char* cp = cstring;
         for (size_t i = 0; i < m_length; ++i) {
             if (!*cp)
                 return false;
             if (m_characters[i] != *(cp++))
                 return false;
         }
         return !*cp;
     }
 
     constexpr bool operator!=(const char* cstring) const
     {
         return !(*this == cstring);
     }
 
     bool operator==(const String&) const;
 
     constexpr bool operator==(const StringView& other) const
     {
         if (is_null())
             return other.is_null();
         if (other.is_null())
             return false;
         if (length() != other.length())
             return false;
         return !__builtin_memcmp(m_characters, other.m_characters, m_length);
     }
 
     constexpr bool operator!=(const StringView& other) const
     {
         return !(*this == other);
     }
 
     bool operator<(const StringView& other) const
     {
         if (int c = __builtin_memcmp(m_characters, other.m_characters, min(m_length, other.m_length)))
             return c < 0;
         return m_length < other.m_length;
     }
 
     [[nodiscard]] String to_string() const;
 
     [[nodiscard]] bool is_whitespace() const { return StringUtils::is_whitespace(*this); }
 
+    [[nodiscard]] String replace(const StringView& needle, const StringView& replacement, bool all_occurrences = false) const;
     [[nodiscard]] size_t count(StringView const& needle) const { return StringUtils::count(*this, needle); }
 
     template<typename... Ts>
     [[nodiscard]] ALWAYS_INLINE constexpr bool is_one_of(Ts&&... strings) const
     {
         return (... || this->operator==(forward<Ts>(strings)));
     }
diff --git a/AK/URLParser.cpp b/AK/URLParser.cpp
index 7edf6c65c7..b8db96528f 100644
--- a/AK/URLParser.cpp
+++ b/AK/URLParser.cpp
@@ -154,530 +154,527 @@ Optional<URL> URLParser::parse_data_url(StringView const& raw_input)
 // https://url.spec.whatwg.org/#concept-basic-url-parser
 // NOTE: This parser assumes a UTF-8 encoding.
 // NOTE: Refrain from using the URL classes setters inside this algorithm. Rather, set the values directly. This bypasses the setters' built-in
 //       validation, which is strictly unnecessary since we set m_valid=true at the end anyways. Furthermore, this algorithm may be used in the
 //       future for validation of URLs, which would then lead to infinite recursion.
 //       The same goes for base_url, because e.g. the port() getter does not always return m_port, and we are interested in the underlying member
 //       variables' values here, not what the URL class presents to its users.
 // NOTE: Since the URL class's member variables contain percent decoded data, we have to deviate from the URL parser specification when setting
 //       some of those values. Because the specification leaves all values percent encoded in their URL data structure, we have to percent decode
 //       everything before setting the member variables.
 URL URLParser::parse(Badge<URL>, StringView const& raw_input, URL const* base_url)
 {
     dbgln_if(URL_PARSER_DEBUG, "URLParser::parse: Parsing '{}'", raw_input);
     if (raw_input.is_empty())
         return {};
 
     if (raw_input.starts_with("data:")) {
         auto maybe_url = parse_data_url(raw_input);
         if (!maybe_url.has_value())
             return {};
         return maybe_url.release_value();
     }
 
     URL url;
 
     // NOTE: This removes all leading and trailing C0 control or space characters.
     bool has_validation_error = false;
     size_t start_index = 0;
     size_t end_index = raw_input.length();
     for (size_t i = 0; i < raw_input.length(); ++i) {
         i8 ch = raw_input[i];
         if (0 <= ch && ch <= 0x20) {
             ++start_index;
             has_validation_error = true;
         } else {
             break;
         }
     }
     for (ssize_t i = raw_input.length() - 1; i >= 0; --i) {
         i8 ch = raw_input[i];
         if (0 <= ch && ch <= 0x20) {
             --end_index;
             has_validation_error = true;
         } else {
             break;
         }
     }
     if (has_validation_error)
         report_validation_error();
     if (start_index >= end_index)
         return {};
 
-    auto processed_input = raw_input.substring_view(start_index, end_index - start_index);
+    String processed_input = raw_input.substring_view(start_index, end_index - start_index);
 
     // NOTE: This replaces all tab and newline characters with nothing.
     if (processed_input.contains("\t") || processed_input.contains("\n")) {
         report_validation_error();
-        String processed_input_string(processed_input);
-        processed_input_string.replace("\t", "", true);
-        processed_input_string.replace("\n", "", true);
-        processed_input = processed_input_string;
+        processed_input = processed_input.replace("\t", "", true).replace("\n", "", true);
     }
 
     State state = State::SchemeStart;
     StringBuilder buffer;
     bool at_sign_seen = false;
     bool inside_brackets = false;
     bool password_token_seen = false;
 
     Utf8View input(processed_input);
     Utf8CodePointIterator iterator = input.begin();
 
     auto get_remaining = [&input, &iterator] {
         return input.substring_view(iterator - input.begin() + iterator.underlying_code_point_length_in_bytes()).as_string();
     };
 
     // NOTE: "continue" should only be used to prevent incrementing the iterator, as this is done at the end of the loop.
     //       ++iterator : "increase pointer by 1"
     //       continue   : "decrease pointer by 1"
     for (;;) {
         u32 code_point = end_of_file;
         if (!iterator.done())
             code_point = *iterator;
 
         if constexpr (URL_PARSER_DEBUG) {
             if (code_point == end_of_file)
                 dbgln("URLParser::parse: {} state with EOF.", state_name(state));
             else if (is_ascii_printable(code_point))
                 dbgln("URLParser::parse: {} state with code point U+{:04X} ({:c}).", state_name(state), code_point, code_point);
             else
                 dbgln("URLParser::parse: {} state with code point U+{:04X}.", state_name(state), code_point);
         }
 
         switch (state) {
         case State::SchemeStart:
             if (is_ascii_alpha(code_point)) {
                 buffer.append_as_lowercase(code_point);
                 state = State::Scheme;
             } else {
                 state = State::NoScheme;
                 continue;
             }
             break;
         case State::Scheme:
             if (is_ascii_alphanumeric(code_point) || code_point == '+' || code_point == '-' || code_point == '.') {
                 buffer.append_as_lowercase(code_point);
             } else if (code_point == ':') {
                 url.m_scheme = buffer.to_string();
                 buffer.clear();
                 if (url.scheme() == "file") {
                     if (!get_remaining().starts_with("//")) {
                         report_validation_error();
                     }
                     state = State::File;
                 } else if (url.is_special()) {
                     if (base_url && base_url->m_scheme == url.m_scheme)
                         state = State::SpecialRelativeOrAuthority;
                     else
                         state = State::SpecialAuthoritySlashes;
                 } else if (get_remaining().starts_with("/")) {
                     state = State::PathOrAuthority;
                     ++iterator;
                 } else {
                     url.m_cannot_be_a_base_url = true;
                     url.append_path("");
                     state = State::CannotBeABaseUrlPath;
                 }
             } else {
                 buffer.clear();
                 state = State::NoScheme;
                 iterator = input.begin();
                 continue;
             }
             break;
         case State::NoScheme:
             if (!base_url || (base_url->m_cannot_be_a_base_url && code_point != '#')) {
                 report_validation_error();
                 return {};
             } else if (base_url->m_cannot_be_a_base_url && code_point == '#') {
                 url.m_scheme = base_url->m_scheme;
                 url.m_paths = base_url->m_paths;
                 url.m_query = base_url->m_query;
                 url.m_fragment = "";
                 url.m_cannot_be_a_base_url = true;
                 state = State::Fragment;
             } else if (base_url->m_scheme != "file") {
                 state = State::Relative;
                 continue;
             } else {
                 state = State::File;
                 continue;
             }
             break;
         case State::SpecialRelativeOrAuthority:
             if (code_point == '/' && get_remaining().starts_with("/")) {
                 state = State::SpecialAuthorityIgnoreSlashes;
                 ++iterator;
             } else {
                 report_validation_error();
                 state = State::Relative;
                 continue;
             }
             break;
         case State::PathOrAuthority:
             if (code_point == '/') {
                 state = State::Authority;
             } else {
                 state = State::Path;
                 continue;
             }
             break;
         case State::Relative:
             url.m_scheme = base_url->m_scheme;
             if (code_point == '/') {
                 state = State::RelativeSlash;
             } else if (url.is_special() && code_point == '\\') {
                 report_validation_error();
                 state = State::RelativeSlash;
             } else {
                 url.m_username = base_url->m_username;
                 url.m_password = base_url->m_password;
                 url.m_host = base_url->m_host;
                 url.m_port = base_url->m_port;
                 url.m_paths = base_url->m_paths;
                 url.m_query = base_url->m_query;
 
                 if (code_point == '?') {
                     url.m_query = "";
                     state = State::Query;
                 } else if (code_point == '#') {
                     url.m_fragment = "";
                     state = State::Fragment;
                 } else if (code_point != end_of_file) {
                     url.m_query = {};
                     if (url.m_paths.size())
                         url.m_paths.remove(url.m_paths.size() - 1);
                     state = State::Path;
                     continue;
                 }
             }
             break;
         case State::RelativeSlash:
             if (url.is_special() && (code_point == '/' || code_point == '\\')) {
                 if (code_point == '\\')
                     report_validation_error();
                 state = State::SpecialAuthorityIgnoreSlashes;
             } else if (code_point == '/') {
                 state = State::Authority;
             } else {
                 url.m_username = base_url->m_username;
                 url.m_password = base_url->m_password;
                 url.m_host = base_url->m_host;
                 url.m_port = base_url->m_port;
                 state = State::Path;
                 continue;
             }
             break;
         case State::SpecialAuthoritySlashes:
             if (code_point == '/' && get_remaining().starts_with("/")) {
                 state = State::SpecialAuthorityIgnoreSlashes;
                 ++iterator;
             } else {
                 report_validation_error();
                 state = State::SpecialAuthorityIgnoreSlashes;
                 continue;
             }
             break;
         case State::SpecialAuthorityIgnoreSlashes:
             if (code_point != '/' && code_point != '\\') {
                 state = State::Authority;
                 continue;
             } else {
                 report_validation_error();
             }
             break;
         case State::Authority:
             if (code_point == '@') {
                 report_validation_error();
                 if (at_sign_seen) {
                     auto content = buffer.to_string();
                     buffer.clear();
                     buffer.append("%40");
                     buffer.append(content);
                 }
                 at_sign_seen = true;
                 StringBuilder builder;
                 for (auto c : Utf8View(builder.string_view())) {
                     if (c == ':' && !password_token_seen) {
                         password_token_seen = true;
                         continue;
                     }
                     builder.clear();
                     if (password_token_seen) {
                         builder.append(url.password());
                         URL::append_percent_encoded_if_necessary(builder, c, URL::PercentEncodeSet::Userinfo);
                         // NOTE: This is has to be encoded and then decoded because the original sequence could contain already percent-encoded sequences.
                         url.m_password = URL::percent_decode(builder.string_view());
                     } else {
                         builder.append(url.username());
                         URL::append_percent_encoded_if_necessary(builder, c, URL::PercentEncodeSet::Userinfo);
                         // NOTE: This is has to be encoded and then decoded because the original sequence could contain already percent-encoded sequences.
                         url.m_username = URL::percent_decode(builder.string_view());
                     }
                 }
                 buffer.clear();
             } else if (code_point == end_of_file || code_point == '/' || code_point == '?' || code_point == '#' || (url.is_special() && code_point == '\\')) {
                 if (at_sign_seen && buffer.is_empty()) {
                     report_validation_error();
                     return {};
                 }
                 // NOTE: This decreases the iterator by the number of code points in buffer plus one.
                 iterator = input.iterator_at_byte_offset(iterator - input.begin() - buffer.length() - 1);
                 buffer.clear();
                 state = State::Host;
             } else {
                 buffer.append_code_point(code_point);
             }
             break;
         case State::Host:
         case State::Hostname:
             if (code_point == ':' && !inside_brackets) {
                 if (buffer.is_empty()) {
                     report_validation_error();
                     return {};
                 }
                 auto host = parse_host(buffer.string_view(), !url.is_special());
                 if (!host.has_value())
                     return {};
                 url.m_host = host.release_value();
                 buffer.clear();
                 state = State::Port;
             } else if (code_point == end_of_file || code_point == '/' || code_point == '?' || code_point == '#' || (url.is_special() && code_point == '\\')) {
                 if (url.is_special() && buffer.is_empty()) {
                     report_validation_error();
                     return {};
                 }
                 auto host = parse_host(buffer.string_view(), !url.is_special());
                 if (!host.has_value())
                     return {};
                 url.m_host = host.value();
                 buffer.clear();
                 state = State::Port;
                 continue;
             } else if (code_point == '[') {
                 inside_brackets = true;
             } else if (code_point == ']') {
                 inside_brackets = false;
             } else {
                 buffer.append_code_point(code_point);
             }
             break;
         case State::Port:
             if (is_ascii_digit(code_point)) {
                 buffer.append_code_point(code_point);
             } else if (code_point == end_of_file || code_point == '/' || code_point == '?' || code_point == '#' || (url.is_special() && code_point == '\\')) {
                 if (!buffer.is_empty()) {
                     auto port = buffer.string_view().to_uint();
                     if (!port.has_value() || port.value() > 65535) {
                         report_validation_error();
                         return {};
                     }
                     if (port.value() == URL::default_port_for_scheme(url.scheme()))
                         url.m_port = 0;
                     else
                         url.m_port = port.value();
                     buffer.clear();
                 }
                 state = State::PathStart;
                 continue;
             } else {
                 report_validation_error();
                 return {};
             }
             break;
         case State::File:
             url.m_scheme = "file";
             url.m_host = "";
             if (code_point == '/' || code_point == '\\') {
                 if (code_point == '\\')
                     report_validation_error();
                 state = State::FileSlash;
             } else if (base_url && base_url->m_scheme == "file") {
                 url.m_host = base_url->m_host;
                 url.m_paths = base_url->m_paths;
                 url.m_query = base_url->m_query;
                 if (code_point == '?') {
                     url.m_query = "";
                     state = State::Query;
                 } else if (code_point == '#') {
                     url.m_fragment = "";
                     state = State::Fragment;
                 } else if (code_point != end_of_file) {
                     url.m_query = {};
                     auto substring_from_pointer = input.substring_view(iterator - input.begin()).as_string();
                     if (!starts_with_windows_drive_letter(substring_from_pointer)) {
                         if (!url.paths().is_empty() && !(url.scheme() == "file" && url.paths().size() == 1 && is_normalized_windows_drive_letter(url.paths()[0])))
                             url.m_paths.remove(url.m_paths.size() - 1);
                     } else {
                         report_validation_error();
                         url.m_paths.clear();
                     }
                     state = State::Path;
                     continue;
                 }
             }
             break;
         case State::FileSlash:
             if (code_point == '/' || code_point == '\\') {
                 if (code_point == '\\')
                     report_validation_error();
                 state = State::FileHost;
             } else if (base_url && base_url->m_scheme == "file") {
                 url.m_host = base_url->m_host;
                 auto substring_from_pointer = input.substring_view(iterator - input.begin()).as_string();
                 if (!starts_with_windows_drive_letter(substring_from_pointer) && is_normalized_windows_drive_letter(base_url->m_paths[0]))
                     url.append_path(base_url->m_paths[0]);
                 state = State::Path;
                 continue;
             }
             break;
         case State::FileHost:
             if (code_point == end_of_file || code_point == '/' || code_point == '\\' || code_point == '?' || code_point == '#') {
                 if (is_windows_drive_letter(buffer.string_view())) {
                     report_validation_error();
                     state = State::Path;
                 } else if (buffer.is_empty()) {
                     url.m_host = "";
                     state = State::PathStart;
                 } else {
                     auto host = parse_host(buffer.string_view(), true);
                     if (!host.has_value())
                         return {};
                     if (host.value() == "localhost")
                         host = "";
                     url.m_host = host.release_value();
                     buffer.clear();
                     state = State::PathStart;
                 }
                 continue;
             } else {
                 buffer.append_code_point(code_point);
             }
             break;
         case State::PathStart:
             if (url.is_special()) {
                 if (code_point == '\\')
                     report_validation_error();
                 state = State::Path;
                 if (code_point != '/' && code_point != '\\')
                     continue;
             } else if (code_point == '?') {
                 url.m_query = "";
                 state = State::Query;
             } else if (code_point == '#') {
                 url.m_fragment = "";
                 state = State::Fragment;
             } else if (code_point != end_of_file) {
                 state = State::Path;
                 if (code_point != '/')
                     continue;
             }
             break;
         case State::Path:
             if (code_point == end_of_file || code_point == '/' || (url.is_special() && code_point == '\\') || code_point == '?' || code_point == '#') {
                 if (url.is_special() && code_point == '\\')
                     report_validation_error();
                 if (is_double_dot_path_segment(buffer.string_view())) {
                     if (!url.m_paths.is_empty() && !(url.m_scheme == "file" && url.m_paths.size() == 1 && is_normalized_windows_drive_letter(url.m_paths[0])))
                         url.m_paths.remove(url.m_paths.size() - 1);
                     if (code_point != '/' && !(url.is_special() && code_point == '\\'))
                         url.append_path("");
                 } else if (is_single_dot_path_segment(buffer.string_view()) && code_point != '/' && !(url.is_special() && code_point == '\\')) {
                     url.append_path("");
                 } else if (!is_single_dot_path_segment(buffer.string_view())) {
                     if (url.m_scheme == "file" && url.m_paths.is_empty() && is_windows_drive_letter(buffer.string_view())) {
                         auto drive_letter = buffer.string_view()[0];
                         buffer.clear();
                         buffer.append(drive_letter);
                         buffer.append(':');
                     }
                     // NOTE: This needs to be percent decoded since the member variables contain decoded data.
                     url.append_path(URL::percent_decode(buffer.string_view()));
                 }
                 buffer.clear();
                 if (code_point == '?') {
                     url.m_query = "";
                     state = State::Query;
                 } else if (code_point == '#') {
                     url.m_fragment = "";
                     state = State::Fragment;
                 }
             } else {
                 if (!is_url_code_point(code_point) && code_point != '%')
                     report_validation_error();
                 // FIXME: If c is U+0025 (%) and remaining does not start with two ASCII hex digits, validation error.
                 URL::append_percent_encoded_if_necessary(buffer, code_point, URL::PercentEncodeSet::Path);
             }
             break;
         case State::CannotBeABaseUrlPath:
             // NOTE: This does not follow the spec exactly but rather uses the buffer and only sets the path on EOF.
             // NOTE: Verify that the assumptions required for this simplification are correct.
             VERIFY(url.m_paths.size() == 1 && url.m_paths[0].is_empty());
             if (code_point == '?') {
                 // NOTE: This needs to be percent decoded since the member variables contain decoded data.
                 url.m_paths[0] = URL::percent_decode(buffer.string_view());
                 url.m_query = "";
                 state = State::Query;
             } else if (code_point == '#') {
                 // NOTE: This needs to be percent decoded since the member variables contain decoded data.
                 url.m_paths[0] = URL::percent_decode(buffer.string_view());
                 url.m_fragment = "";
                 state = State::Fragment;
             } else {
                 if (code_point != end_of_file && !is_url_code_point(code_point) && code_point != '%')
                     report_validation_error();
                 // FIXME: If c is U+0025 (%) and remaining does not start with two ASCII hex digits, validation error.
                 if (code_point != end_of_file) {
                     URL::append_percent_encoded_if_necessary(buffer, code_point, URL::PercentEncodeSet::C0Control);
                 } else {
                     // NOTE: This needs to be percent decoded since the member variables contain decoded data.
                     url.m_paths[0] = URL::percent_decode(buffer.string_view());
                 }
             }
             break;
         case State::Query:
             if (code_point == end_of_file || code_point == '#') {
                 VERIFY(url.m_query == "");
                 auto query_percent_encode_set = url.is_special() ? URL::PercentEncodeSet::SpecialQuery : URL::PercentEncodeSet::Query;
                 // NOTE: This is has to be encoded and then decoded because the original sequence could contain already percent-encoded sequences.
                 url.m_query = URL::percent_decode(URL::percent_encode(buffer.string_view(), query_percent_encode_set));
                 buffer.clear();
                 if (code_point == '#') {
                     url.m_fragment = "";
                     state = State::Fragment;
                 }
             } else if (code_point != end_of_file) {
                 if (!is_url_code_point(code_point) && code_point != '%')
                     report_validation_error();
                 // FIXME: If c is U+0025 (%) and remaining does not start with two ASCII hex digits, validation error.
                 buffer.append_code_point(code_point);
             }
             break;
         case State::Fragment:
             // NOTE: This does not follow the spec exactly but rather uses the buffer and only sets the fragment on EOF.
             if (code_point != end_of_file) {
                 if (!is_url_code_point(code_point) && code_point != '%')
                     report_validation_error();
                 // FIXME: If c is U+0025 (%) and remaining does not start with two ASCII hex digits, validation error.
                 buffer.append_code_point(code_point);
             } else {
                 // NOTE: This needs to be percent decoded since the member variables contain decoded data.
                 url.m_fragment = URL::percent_decode(buffer.string_view());
                 buffer.clear();
             }
             break;
         default:
             VERIFY_NOT_REACHED();
         }
 
         if (iterator.done())
             break;
         ++iterator;
     }
 
     url.m_valid = true;
     dbgln_if(URL_PARSER_DEBUG, "URLParser::parse: Parsed URL to be '{}'.", url.serialize());
     return url;
 }
 
 }
diff --git a/Meta/Lagom/Tools/CodeGenerators/LibUnicode/GenerateUnicodeData.cpp b/Meta/Lagom/Tools/CodeGenerators/LibUnicode/GenerateUnicodeData.cpp
index 93647ea176..166da0820e 100644
--- a/Meta/Lagom/Tools/CodeGenerators/LibUnicode/GenerateUnicodeData.cpp
+++ b/Meta/Lagom/Tools/CodeGenerators/LibUnicode/GenerateUnicodeData.cpp
@@ -170,60 +170,60 @@ static CodePointRange parse_code_point_range(StringView const& list)
 static void parse_special_casing(Core::File& file, UnicodeData& unicode_data)
 {
     while (file.can_read_line()) {
         auto line = file.read_line();
         if (line.is_empty() || line.starts_with('#'))
             continue;
 
         if (auto index = line.find('#'); index.has_value())
             line = line.substring(0, *index);
 
         auto segments = line.split(';', true);
         VERIFY(segments.size() == 5 || segments.size() == 6);
 
         SpecialCasing casing {};
         casing.code_point = AK::StringUtils::convert_to_uint_from_hex<u32>(segments[0]).value();
         casing.lowercase_mapping = parse_code_point_list(segments[1]);
         casing.titlecase_mapping = parse_code_point_list(segments[2]);
         casing.uppercase_mapping = parse_code_point_list(segments[3]);
 
         if (auto condition = segments[4].trim_whitespace(); !condition.is_empty()) {
             auto conditions = condition.split(' ', true);
             VERIFY(conditions.size() == 1 || conditions.size() == 2);
 
             if (conditions.size() == 2) {
                 casing.locale = move(conditions[0]);
                 casing.condition = move(conditions[1]);
             } else if (all_of(conditions[0], is_ascii_lower_alpha)) {
                 casing.locale = move(conditions[0]);
             } else {
                 casing.condition = move(conditions[0]);
             }
 
             if (!casing.locale.is_empty())
                 casing.locale = String::formatted("{:c}{}", to_ascii_uppercase(casing.locale[0]), casing.locale.substring_view(1));
-            casing.condition.replace("_", "", true);
+            casing.condition = casing.condition.replace("_", "", true);
 
             if (!casing.condition.is_empty() && !unicode_data.conditions.contains_slow(casing.condition))
                 unicode_data.conditions.append(casing.condition);
         }
 
         unicode_data.largest_casing_transform_size = max(unicode_data.largest_casing_transform_size, casing.lowercase_mapping.size());
         unicode_data.largest_casing_transform_size = max(unicode_data.largest_casing_transform_size, casing.titlecase_mapping.size());
         unicode_data.largest_casing_transform_size = max(unicode_data.largest_casing_transform_size, casing.uppercase_mapping.size());
 
         unicode_data.special_casing.append(move(casing));
     }
 
     quick_sort(unicode_data.special_casing, [](auto const& lhs, auto const& rhs) {
         if (lhs.code_point != rhs.code_point)
             return lhs.code_point < rhs.code_point;
         if (lhs.locale.is_empty() && !rhs.locale.is_empty())
             return false;
         if (!lhs.locale.is_empty() && rhs.locale.is_empty())
             return true;
         return lhs.locale < rhs.locale;
     });
 
     for (u32 i = 0; i < unicode_data.special_casing.size(); ++i)
         unicode_data.special_casing[i].index = i;
 }
diff --git a/Meta/Lagom/Tools/CodeGenerators/LibUnicode/GenerateUnicodeLocale.cpp b/Meta/Lagom/Tools/CodeGenerators/LibUnicode/GenerateUnicodeLocale.cpp
index b5e2fb1c96..5ca7d38c81 100644
--- a/Meta/Lagom/Tools/CodeGenerators/LibUnicode/GenerateUnicodeLocale.cpp
+++ b/Meta/Lagom/Tools/CodeGenerators/LibUnicode/GenerateUnicodeLocale.cpp
@@ -507,9 +507,9 @@ static void parse_all_locales(String core_path, String locale_names_path, String
 
 static String format_identifier(StringView owner, String identifier)
 {
-    identifier.replace("-"sv, "_"sv, true);
+    identifier = identifier.replace("-"sv, "_"sv, true);
 
     if (all_of(identifier, is_ascii_digit))
         return String::formatted("{}_{}", owner[0], identifier);
     return identifier.to_titlecase();
 }
@@ -630,44 +630,43 @@ namespace Unicode {
 struct Patterns {
     ListPatternType type;
     ListPatternStyle style;
     StringView start;
     StringView middle;
     StringView end;
     StringView pair;
 };
 )~~~");
 
     auto format_mapping_name = [](StringView format, StringView name) {
-        auto mapping_name = name.to_lowercase_string();
-        mapping_name.replace("-"sv, "_"sv, true);
+        auto mapping_name = name.to_lowercase_string().replace("-"sv, "_"sv, true);
         return String::formatted(format, mapping_name);
     };
 
     auto append_string = [&](StringView value) {
         if (value.is_empty())
             generator.append(", {}"sv);
         else
             generator.append(String::formatted(", \"{}\"sv", value));
     };
 
     auto append_list_and_size = [&](auto const& list) {
         if (list.is_empty()) {
             generator.append(", {}, 0");
             return;
         }
 
         bool first = true;
         generator.append(", {");
         for (auto const& item : list) {
             generator.append(first ? " " : ", ");
             generator.append(String::formatted("\"{}\"sv", item));
             first = false;
         }
         generator.append(String::formatted(" }}, {}", list.size()));
     };
 
     auto append_string_list = [&](String name, auto const& keys, auto const& mappings) {
         generator.set("name", name);
         generator.set("size", String::number(keys.size()));
 
         generator.append(R"~~~(
diff --git a/Meta/Lagom/Tools/CodeGenerators/LibWeb/WrapperGenerator.cpp b/Meta/Lagom/Tools/CodeGenerators/LibWeb/WrapperGenerator.cpp
index 2d302aa4a9..2e68cf201a 100644
--- a/Meta/Lagom/Tools/CodeGenerators/LibWeb/WrapperGenerator.cpp
+++ b/Meta/Lagom/Tools/CodeGenerators/LibWeb/WrapperGenerator.cpp
@@ -21,16 +21,13 @@
 static String make_input_acceptable_cpp(String const& input)
 {
     if (input.is_one_of("class", "template", "for", "default", "char", "namespace")) {
         StringBuilder builder;
         builder.append(input);
         builder.append('_');
         return builder.to_string();
     }
 
-    String input_without_dashes = input;
-    input_without_dashes.replace("-", "_");
-
-    return input_without_dashes;
+    return input.replace("-", "_");
 }
 
 static void report_parsing_error(StringView message, StringView filename, StringView input, size_t offset)
diff --git a/Tests/AK/TestString.cpp b/Tests/AK/TestString.cpp
index d5e7c970bb..fc55df1a5a 100644
--- a/Tests/AK/TestString.cpp
+++ b/Tests/AK/TestString.cpp
@@ -146,25 +146,21 @@ TEST_CASE(flystring)
 TEST_CASE(replace)
 {
     String test_string = "Well, hello Friends!";
-    u32 replacements = test_string.replace("Friends", "Testers");
-    EXPECT(replacements == 1);
+
+    test_string = test_string.replace("Friends", "Testers");
     EXPECT(test_string == "Well, hello Testers!");
 
-    replacements = test_string.replace("ell", "e're", true);
-    EXPECT(replacements == 2);
+    test_string = test_string.replace("ell", "e're", true);
     EXPECT(test_string == "We're, he'reo Testers!");
 
-    replacements = test_string.replace("!", " :^)");
-    EXPECT(replacements == 1);
+    test_string = test_string.replace("!", " :^)");
     EXPECT(test_string == "We're, he'reo Testers :^)");
 
     test_string = String("111._.111._.111");
-    replacements = test_string.replace("111", "|||", true);
-    EXPECT(replacements == 3);
+    test_string = test_string.replace("111", "|||", true);
     EXPECT(test_string == "|||._.|||._.|||");
 
-    replacements = test_string.replace("|||", "111");
-    EXPECT(replacements == 1);
+    test_string = test_string.replace("|||", "111");
     EXPECT(test_string == "111._.|||._.|||");
 }
 
diff --git a/Userland/Applications/Browser/Tab.cpp b/Userland/Applications/Browser/Tab.cpp
index 0482b3a783..f043adb032 100644
--- a/Userland/Applications/Browser/Tab.cpp
+++ b/Userland/Applications/Browser/Tab.cpp
@@ -40,18 +40,15 @@ namespace Browser {
 
 URL url_from_user_input(const String& input)
 {
-    if (input.starts_with("?") && !g_search_engine.is_null()) {
-        auto url = g_search_engine;
-        url.replace("{}", URL::percent_encode(input.substring_view(1)));
-        return URL(url);
-    }
+    if (input.starts_with("?") && !g_search_engine.is_null())
+        return URL(g_search_engine.replace("{}", URL::percent_encode(input.substring_view(1))));
 
     auto url = URL(input);
     if (url.is_valid())
         return url;
 
     StringBuilder builder;
     builder.append("http://");
     builder.append(input);
     return URL(builder.build());
 }
diff --git a/Userland/Applications/HexEditor/FindDialog.cpp b/Userland/Applications/HexEditor/FindDialog.cpp
index 46cbcd8e88..c1cb3399bf 100644
--- a/Userland/Applications/HexEditor/FindDialog.cpp
+++ b/Userland/Applications/HexEditor/FindDialog.cpp
@@ -67,24 +67,23 @@ int FindDialog::show(GUI::Window* parent_window, String& out_text, ByteBuffer& o
 Result<ByteBuffer, String> FindDialog::process_input(String text_value, OptionId opt)
 {
     dbgln("process_input opt={}", (int)opt);
     switch (opt) {
     case OPTION_ASCII_STRING: {
         if (text_value.is_empty())
             return String("Input is empty");
 
         return text_value.to_byte_buffer();
     }
 
     case OPTION_HEX_VALUE: {
-        text_value.replace(" ", "", true);
-        auto decoded = decode_hex(text_value.substring_view(0, text_value.length()));
+        auto decoded = decode_hex(text_value.replace(" ", "", true));
         if (!decoded.has_value())
             return String("Input contains invalid hex values.");
 
         return decoded.value();
     }
 
     default:
         VERIFY_NOT_REACHED();
     }
 }
diff --git a/Userland/Applications/HexEditor/GoToOffsetDialog.cpp b/Userland/Applications/HexEditor/GoToOffsetDialog.cpp
index fb6a5990b5..9940b19169 100644
--- a/Userland/Applications/HexEditor/GoToOffsetDialog.cpp
+++ b/Userland/Applications/HexEditor/GoToOffsetDialog.cpp
@@ -91,59 +91,58 @@ void GoToOffsetDialog::update_statusbar()
 GoToOffsetDialog::GoToOffsetDialog()
     : Dialog(nullptr)
 {
     resize(300, 80);
     center_on_screen();
     set_resizable(false);
     set_title("Go to Offset");
 
     auto& main_widget = set_main_widget<GUI::Widget>();
     if (!main_widget.load_from_gml(go_to_offset_dialog_gml))
         VERIFY_NOT_REACHED();
 
     m_text_editor = *main_widget.find_descendant_of_type_named<GUI::TextBox>("text_editor");
     m_go_button = *main_widget.find_descendant_of_type_named<GUI::Button>("go_button");
     m_offset_type_box = *main_widget.find_descendant_of_type_named<GUI::ComboBox>("offset_type");
     m_offset_from_box = *main_widget.find_descendant_of_type_named<GUI::ComboBox>("offset_from");
     m_statusbar = *main_widget.find_descendant_of_type_named<GUI::Statusbar>("statusbar");
 
     m_offset_type.append("Decimal");
     m_offset_type.append("Hexadecimal");
     m_offset_type_box->set_model(GUI::ItemListModel<String>::create(m_offset_type));
     m_offset_type_box->set_selected_index(0);
     m_offset_type_box->set_only_allow_values_from_model(true);
 
     m_offset_from.append("Start");
     m_offset_from.append("Here");
     m_offset_from.append("End");
     m_offset_from_box->set_model(GUI::ItemListModel<String>::create(m_offset_from));
     m_offset_from_box->set_selected_index(0);
     m_offset_from_box->set_only_allow_values_from_model(true);
 
     m_text_editor->on_return_pressed = [this] {
         m_go_button->click();
     };
 
     m_go_button->on_click = [this](auto) {
         done(ExecResult::ExecOK);
     };
 
     m_text_editor->on_change = [this]() {
         auto text = m_text_editor->text();
         if (text.starts_with("0x")) {
-            text.replace("0x", "");
             m_offset_type_box->set_selected_index(1);
-            m_text_editor->set_text(text);
+            m_text_editor->set_text(text.replace("0x", ""));
         }
         update_statusbar();
     };
 
     m_offset_type_box->on_change = [this](auto&, auto&) {
         update_statusbar();
     };
 
     m_offset_from_box->on_change = [this](auto&, auto&) {
         update_statusbar();
     };
 
     update_statusbar();
 }
diff --git a/Userland/Applications/KeyboardSettings/main.cpp b/Userland/Applications/KeyboardSettings/main.cpp
index 43199b7e5d..858cdfa1cf 100644
--- a/Userland/Applications/KeyboardSettings/main.cpp
+++ b/Userland/Applications/KeyboardSettings/main.cpp
@@ -29,164 +29,163 @@
 int main(int argc, char** argv)
 {
     if (pledge("stdio rpath cpath wpath recvfd sendfd unix proc exec", nullptr) < 0) {
         perror("pledge");
         return 1;
     }
 
     auto app = GUI::Application::construct(argc, argv);
     Config::pledge_domains("KeyboardSettings");
 
     if (pledge("stdio rpath cpath wpath recvfd sendfd proc exec", nullptr) < 0) {
         perror("pledge");
         return 1;
     }
 
     if (unveil("/res", "r") < 0) {
         perror("unveil");
         return 1;
     }
 
     if (unveil("/bin/keymap", "x") < 0) {
         perror("unveil");
         return 1;
     }
 
     if (unveil("/proc/keymap", "r") < 0) {
         perror("unveil");
         return 1;
     }
 
     if (unveil(nullptr, nullptr)) {
         perror("unveil");
         return 1;
     }
 
     auto app_icon = GUI::Icon::default_icon("app-keyboard-settings");
 
     auto proc_keymap = Core::File::construct("/proc/keymap");
     if (!proc_keymap->open(Core::OpenMode::ReadOnly))
         VERIFY_NOT_REACHED();
 
     auto json = JsonValue::from_string(proc_keymap->read_all());
     VERIFY(json.has_value());
     JsonObject keymap_object = json.value().as_object();
     VERIFY(keymap_object.has("keymap"));
     String current_keymap = keymap_object.get("keymap").to_string();
     dbgln("KeyboardSettings thinks the current keymap is: {}", current_keymap);
 
     Vector<String> character_map_files;
     Core::DirIterator iterator("/res/keymaps/", Core::DirIterator::Flags::SkipDots);
     if (iterator.has_error()) {
         GUI::MessageBox::show(nullptr, String::formatted("Error on reading mapping file list: {}", iterator.error_string()), "Keyboard settings", GUI::MessageBox::Type::Error);
         return -1;
     }
 
     while (iterator.has_next()) {
         auto name = iterator.next_path();
-        name.replace(".json", "");
-        character_map_files.append(name);
+        character_map_files.append(name.replace(".json", ""));
     }
     quick_sort(character_map_files);
 
     size_t initial_keymap_index = SIZE_MAX;
     for (size_t i = 0; i < character_map_files.size(); ++i) {
         if (character_map_files[i].equals_ignoring_case(current_keymap))
             initial_keymap_index = i;
     }
     VERIFY(initial_keymap_index < character_map_files.size());
 
     auto window = GUI::Window::construct();
     window->set_title("Keyboard Settings");
     window->resize(300, 78);
     window->set_resizable(false);
     window->set_minimizable(false);
     window->set_icon(app_icon.bitmap_for_size(16));
 
     auto& root_widget = window->set_main_widget<GUI::Widget>();
     root_widget.set_layout<GUI::VerticalBoxLayout>();
     root_widget.set_fill_with_background_color(true);
     root_widget.layout()->set_spacing(0);
     root_widget.layout()->set_margins(4);
 
     auto& character_map_file_selection_container = root_widget.add<GUI::Widget>();
     character_map_file_selection_container.set_layout<GUI::HorizontalBoxLayout>();
     character_map_file_selection_container.set_fixed_height(22);
 
     auto& character_map_file_label = character_map_file_selection_container.add<GUI::Label>();
     character_map_file_label.set_text_alignment(Gfx::TextAlignment::CenterLeft);
     character_map_file_label.set_fixed_width(130);
     character_map_file_label.set_text("Character Mapping File:");
 
     auto& character_map_file_combo = character_map_file_selection_container.add<GUI::ComboBox>();
     character_map_file_combo.set_only_allow_values_from_model(true);
     character_map_file_combo.set_model(*GUI::ItemListModel<String>::create(character_map_files));
     character_map_file_combo.set_selected_index(initial_keymap_index);
 
     auto& num_lock_checkbox = root_widget.add<GUI::CheckBox>("Enable Num Lock on login");
     num_lock_checkbox.set_checked(Config::read_bool("KeyboardSettings", "StartupEnable", "NumLock", true));
 
     root_widget.layout()->add_spacer();
 
     auto apply_settings = [&](bool quit) {
         String character_map_file = character_map_file_combo.text();
         if (character_map_file.is_empty()) {
             GUI::MessageBox::show(window, "Please select character mapping file.", "Keyboard settings", GUI::MessageBox::Type::Error);
             return;
         }
         pid_t child_pid;
         const char* argv[] = { "/bin/keymap", character_map_file.characters(), nullptr };
         if ((errno = posix_spawn(&child_pid, "/bin/keymap", nullptr, nullptr, const_cast<char**>(argv), environ))) {
             perror("posix_spawn");
             exit(1);
         }
 
         Config::write_bool("KeyboardSettings", "StartupEnable", "NumLock", num_lock_checkbox.is_checked());
 
         if (quit)
             app->quit();
     };
 
     auto& bottom_widget = root_widget.add<GUI::Widget>();
     bottom_widget.set_layout<GUI::HorizontalBoxLayout>();
     bottom_widget.layout()->add_spacer();
     bottom_widget.set_fixed_height(30);
     bottom_widget.set_content_margins({ 4, 0 });
 
     auto& ok_button = bottom_widget.add<GUI::Button>();
     ok_button.set_text("OK");
     ok_button.set_fixed_width(60);
     ok_button.on_click = [&](auto) {
         apply_settings(true);
     };
 
     auto& cancel_button = bottom_widget.add<GUI::Button>();
     cancel_button.set_text("Cancel");
     cancel_button.set_fixed_width(60);
     cancel_button.on_click = [&](auto) {
         app->quit();
     };
 
     auto& apply_button = bottom_widget.add<GUI::Button>();
     apply_button.set_text("Apply");
     apply_button.set_fixed_width(60);
     apply_button.on_click = [&](auto) {
         apply_settings(false);
     };
 
     auto quit_action = GUI::CommonActions::make_quit_action(
         [&](auto&) {
             app->quit();
         });
 
     auto menubar = GUI::Menubar::construct();
 
     auto& file_menu = window->add_menu("&File");
     file_menu.add_action(quit_action);
 
     auto& help_menu = window->add_menu("&Help");
     help_menu.add_action(GUI::CommonActions::make_about_action("Keyboard Settings", app_icon, window));
 
     window->show();
 
     return app->exec();
 }
diff --git a/Userland/Applications/Terminal/main.cpp b/Userland/Applications/Terminal/main.cpp
index e59e3bf4ba..711c2c7999 100644
--- a/Userland/Applications/Terminal/main.cpp
+++ b/Userland/Applications/Terminal/main.cpp
@@ -107,72 +107,71 @@ static void run_command(String command, bool keep_open)
 static RefPtr<GUI::Window> create_settings_window(VT::TerminalWidget& terminal)
 {
     auto window = GUI::Window::construct();
     window->set_window_type(GUI::WindowType::ToolWindow);
     window->set_title("Terminal settings");
     window->set_resizable(false);
     window->resize(200, 240);
     window->center_within(*terminal.window());
 
     auto& settings = window->set_main_widget<GUI::Widget>();
     settings.load_from_gml(terminal_settings_window_gml);
 
     auto& beep_bell_radio = *settings.find_descendant_of_type_named<GUI::RadioButton>("beep_bell_radio");
     auto& visual_bell_radio = *settings.find_descendant_of_type_named<GUI::RadioButton>("visual_bell_radio");
     auto& no_bell_radio = *settings.find_descendant_of_type_named<GUI::RadioButton>("no_bell_radio");
 
     switch (terminal.bell_mode()) {
     case VT::TerminalWidget::BellMode::Visible:
         visual_bell_radio.set_checked(true);
         break;
     case VT::TerminalWidget::BellMode::AudibleBeep:
         beep_bell_radio.set_checked(true);
         break;
     case VT::TerminalWidget::BellMode::Disabled:
         no_bell_radio.set_checked(true);
         break;
     }
 
     beep_bell_radio.on_checked = [&terminal](bool) {
         terminal.set_bell_mode(VT::TerminalWidget::BellMode::AudibleBeep);
     };
     visual_bell_radio.on_checked = [&terminal](bool) {
         terminal.set_bell_mode(VT::TerminalWidget::BellMode::Visible);
     };
     no_bell_radio.on_checked = [&terminal](bool) {
         terminal.set_bell_mode(VT::TerminalWidget::BellMode::Disabled);
     };
 
     auto& slider = *settings.find_descendant_of_type_named<GUI::OpacitySlider>("background_opacity_slider");
     slider.on_change = [&terminal](int value) {
         terminal.set_opacity(value);
     };
     slider.set_value(terminal.opacity());
 
     auto& history_size_spinbox = *settings.find_descendant_of_type_named<GUI::SpinBox>("history_size_spinbox");
     history_size_spinbox.set_value(terminal.max_history_size());
     history_size_spinbox.on_change = [&terminal](int value) {
         terminal.set_max_history_size(value);
     };
 
     // The settings window takes a reference to this vector, so it needs to outlive this scope.
     // As long as we ensure that only one settings window may be open at a time (which we do),
     // this should cause no problems.
     static Vector<String> color_scheme_names;
     color_scheme_names.clear();
     Core::DirIterator iterator("/res/terminal-colors", Core::DirIterator::SkipParentAndBaseDir);
     while (iterator.has_next()) {
         auto path = iterator.next_path();
-        path.replace(".ini", "");
-        color_scheme_names.append(path);
+        color_scheme_names.append(path.replace(".ini", ""));
     }
     quick_sort(color_scheme_names);
     auto& color_scheme_combo = *settings.find_descendant_of_type_named<GUI::ComboBox>("color_scheme_combo");
     color_scheme_combo.set_only_allow_values_from_model(true);
     color_scheme_combo.set_model(*GUI::ItemListModel<String>::create(color_scheme_names));
     color_scheme_combo.set_selected_index(color_scheme_names.find_first_index(terminal.color_scheme_name()).value());
     color_scheme_combo.set_enabled(color_scheme_names.size() > 1);
     color_scheme_combo.on_change = [&](auto&, const GUI::ModelIndex& index) {
         terminal.set_color_scheme(index.data().as_string());
     };
     return window;
 }
@@ -180,74 +179,71 @@ static RefPtr<GUI::Window> create_settings_window(VT::TerminalWidget& terminal)
 static RefPtr<GUI::Window> create_find_window(VT::TerminalWidget& terminal)
 {
     auto window = GUI::Window::construct();
     window->set_window_type(GUI::WindowType::ToolWindow);
     window->set_title("Find in Terminal");
     window->set_resizable(false);
     window->resize(300, 90);
 
     auto& search = window->set_main_widget<GUI::Widget>();
     search.set_fill_with_background_color(true);
     search.set_background_role(ColorRole::Button);
     search.set_layout<GUI::VerticalBoxLayout>();
     search.layout()->set_margins(4);
 
     auto& find = search.add<GUI::Widget>();
     find.set_layout<GUI::HorizontalBoxLayout>();
     find.layout()->set_margins(4);
     find.set_fixed_height(30);
 
     auto& find_textbox = find.add<GUI::TextBox>();
     find_textbox.set_fixed_width(230);
     find_textbox.set_focus(true);
-    if (terminal.has_selection()) {
-        String selected_text = terminal.selected_text();
-        selected_text.replace("\n", " ", true);
-        find_textbox.set_text(selected_text);
-    }
+    if (terminal.has_selection())
+        find_textbox.set_text(terminal.selected_text().replace("\n", " ", true));
     auto& find_backwards = find.add<GUI::Button>();
     find_backwards.set_fixed_width(25);
     find_backwards.set_icon(Gfx::Bitmap::try_load_from_file("/res/icons/16x16/upward-triangle.png"));
     auto& find_forwards = find.add<GUI::Button>();
     find_forwards.set_fixed_width(25);
     find_forwards.set_icon(Gfx::Bitmap::try_load_from_file("/res/icons/16x16/downward-triangle.png"));
 
     find_textbox.on_return_pressed = [&]() {
         find_backwards.click();
     };
 
     find_textbox.on_shift_return_pressed = [&]() {
         find_forwards.click();
     };
 
     auto& match_case = search.add<GUI::CheckBox>("Case sensitive");
     auto& wrap_around = search.add<GUI::CheckBox>("Wrap around");
 
     find_backwards.on_click = [&](auto) {
         auto needle = find_textbox.text();
         if (needle.is_empty()) {
             return;
         }
 
         auto found_range = terminal.find_previous(needle, terminal.normalized_selection().start(), match_case.is_checked(), wrap_around.is_checked());
 
         if (found_range.is_valid()) {
             terminal.scroll_to_row(found_range.start().row());
             terminal.set_selection(found_range);
         }
     };
     find_forwards.on_click = [&](auto) {
         auto needle = find_textbox.text();
         if (needle.is_empty()) {
             return;
         }
 
         auto found_range = terminal.find_next(needle, terminal.normalized_selection().end(), match_case.is_checked(), wrap_around.is_checked());
 
         if (found_range.is_valid()) {
             terminal.scroll_to_row(found_range.start().row());
             terminal.set_selection(found_range);
         }
     };
 
     return window;
 }
diff --git a/Userland/DevTools/HackStudio/ProjectTemplate.cpp b/Userland/DevTools/HackStudio/ProjectTemplate.cpp
index 9cb202087e..619d042e5e 100644
--- a/Userland/DevTools/HackStudio/ProjectTemplate.cpp
+++ b/Userland/DevTools/HackStudio/ProjectTemplate.cpp
@@ -60,60 +60,59 @@ RefPtr<ProjectTemplate> ProjectTemplate::load_from_manifest(const String& manife
 Result<void, String> ProjectTemplate::create_project(const String& name, const String& path)
 {
     // Check if a file or directory already exists at the project path
     if (Core::File::exists(path))
         return String("File or directory already exists at specified location.");
 
     dbgln("Creating project at path '{}' with name '{}'", path, name);
 
     // Verify that the template content directory exists. If it does, copy it's contents.
     // Otherwise, create an empty directory at the project path.
     if (Core::File::is_directory(content_path())) {
         auto result = Core::File::copy_file_or_directory(path, content_path());
         dbgln("Copying {} -> {}", content_path(), path);
         if (result.is_error())
             return String::formatted("Failed to copy template contents. Error code: {}", result.error().error_code);
     } else {
         dbgln("No template content directory found for '{}', creating an empty directory for the project.", m_id);
         int rc;
         if ((rc = mkdir(path.characters(), 0755)) < 0) {
             return String::formatted("Failed to mkdir empty project directory, error: {}, rc: {}.", strerror(errno), rc);
         }
     }
 
     // Check for an executable post-create script in $TEMPLATES_DIR/$ID.postcreate,
     // and run it with the path and name
 
     auto postcreate_script_path = LexicalPath::canonicalized_path(String::formatted("{}/{}.postcreate", templates_path(), m_id));
     struct stat postcreate_st;
     int result = stat(postcreate_script_path.characters(), &postcreate_st);
     if (result == 0 && (postcreate_st.st_mode & S_IXOTH) == S_IXOTH) {
         dbgln("Running post-create script '{}'", postcreate_script_path);
 
         // Generate a namespace-safe project name (replace hyphens with underscores)
-        String namespace_safe(name.characters());
-        namespace_safe.replace("-", "_", true);
+        auto namespace_safe = name.replace("-", "_", true);
 
         pid_t child_pid;
         const char* argv[] = { postcreate_script_path.characters(), name.characters(), path.characters(), namespace_safe.characters(), nullptr };
 
         if ((errno = posix_spawn(&child_pid, postcreate_script_path.characters(), nullptr, nullptr, const_cast<char**>(argv), environ))) {
             perror("posix_spawn");
             return String("Failed to spawn project post-create script.");
         }
 
         // Command spawned, wait for exit.
         int status;
         if (waitpid(child_pid, &status, 0) < 0)
             return String("Failed to spawn project post-create script.");
 
         int child_error = WEXITSTATUS(status);
         dbgln("Post-create script exited with code {}", child_error);
 
         if (child_error != 0)
             return String("Project post-creation script exited with non-zero error code.");
     }
 
     return {};
 }
 
 }
diff --git a/Userland/Libraries/LibC/netdb.cpp b/Userland/Libraries/LibC/netdb.cpp
index 920c99ea45..7c0f973da3 100644
--- a/Userland/Libraries/LibC/netdb.cpp
+++ b/Userland/Libraries/LibC/netdb.cpp
@@ -422,54 +422,48 @@ void endservent()
 // Fill the service entry buffer with the information contained
 // in the currently read line, returns true if successful,
 // false if failure occurs.
 static bool fill_getserv_buffers(const char* line, ssize_t read)
 {
     // Splitting the line by tab delimiter and filling the servent buffers name, port, and protocol members.
-    String string_line = String(line, read);
-    string_line.replace(" ", "\t", true);
-    auto split_line = string_line.split('\t');
+    auto split_line = StringView(line, read).replace(" ", "\t", true).split('\t');
 
     // This indicates an incorrect file format.
     // Services file entries should always at least contain
     // name and port/protocol, separated by tabs.
     if (split_line.size() < 2) {
         warnln("getservent(): malformed services file");
         return false;
     }
     __getserv_name_buffer = split_line[0];
 
     auto port_protocol_split = String(split_line[1]).split('/');
     if (port_protocol_split.size() < 2) {
         warnln("getservent(): malformed services file");
         return false;
     }
     auto number = port_protocol_split[0].to_int();
     if (!number.has_value())
         return false;
 
     __getserv_port_buffer = number.value();
 
     // Remove any annoying whitespace at the end of the protocol.
-    port_protocol_split[1].replace(" ", "", true);
-    port_protocol_split[1].replace("\t", "", true);
-    port_protocol_split[1].replace("\n", "", true);
-
-    __getserv_protocol_buffer = port_protocol_split[1];
+    __getserv_protocol_buffer = port_protocol_split[1].replace(" ", "", true).replace("\t", "", true).replace("\n", "", true);
     __getserv_alias_list_buffer.clear();
 
     // If there are aliases for the service, we will fill the alias list buffer.
     if (split_line.size() > 2 && !split_line[2].starts_with('#')) {
 
         for (size_t i = 2; i < split_line.size(); i++) {
             if (split_line[i].starts_with('#')) {
                 break;
             }
             auto alias = split_line[i].to_byte_buffer();
             if (!alias.try_append("\0", sizeof(char)))
                 return false;
             __getserv_alias_list_buffer.append(move(alias));
         }
     }
 
     return true;
 }
@@ -610,37 +604,36 @@ void endprotoent()
 static bool fill_getproto_buffers(const char* line, ssize_t read)
 {
     String string_line = String(line, read);
-    string_line.replace(" ", "\t", true);
-    auto split_line = string_line.split('\t');
+    auto split_line = string_line.replace(" ", "\t", true).split('\t');
 
     // This indicates an incorrect file format. Protocols file entries should
     // always have at least a name and a protocol.
     if (split_line.size() < 2) {
         warnln("getprotoent(): malformed protocols file");
         return false;
     }
     __getproto_name_buffer = split_line[0];
 
     auto number = split_line[1].to_int();
     if (!number.has_value())
         return false;
 
     __getproto_protocol_buffer = number.value();
 
     __getproto_alias_list_buffer.clear();
 
     // If there are aliases for the protocol, we will fill the alias list buffer.
     if (split_line.size() > 2 && !split_line[2].starts_with('#')) {
 
         for (size_t i = 2; i < split_line.size(); i++) {
             if (split_line[i].starts_with('#'))
                 break;
             auto alias = split_line[i].to_byte_buffer();
             if (!alias.try_append("\0", sizeof(char)))
                 return false;
             __getproto_alias_list_buffer.append(move(alias));
         }
     }
 
     return true;
 }
diff --git a/Userland/Libraries/LibC/termcap.cpp b/Userland/Libraries/LibC/termcap.cpp
index 28a9c195cd..54b0216671 100644
--- a/Userland/Libraries/LibC/termcap.cpp
+++ b/Userland/Libraries/LibC/termcap.cpp
@@ -114,12 +114,10 @@ int tgetnum(const char* id)
 static Vector<char> s_tgoto_buffer;
 char* tgoto([[maybe_unused]] const char* cap, [[maybe_unused]] int col, [[maybe_unused]] int row)
 {
-    auto cap_str = String(cap);
-    cap_str.replace("%p1%d", String::number(col));
-    cap_str.replace("%p2%d", String::number(row));
+    auto cap_str = StringView(cap).replace("%p1%d", String::number(col)).replace("%p2%d", String::number(row));
 
     s_tgoto_buffer.clear_with_capacity();
     s_tgoto_buffer.ensure_capacity(cap_str.length());
     (void)cap_str.copy_characters_to_buffer(s_tgoto_buffer.data(), cap_str.length());
     return s_tgoto_buffer.data();
 }
diff --git a/Userland/Libraries/LibIMAP/Objects.cpp b/Userland/Libraries/LibIMAP/Objects.cpp
index c8f87857e9..21a9f6b222 100644
--- a/Userland/Libraries/LibIMAP/Objects.cpp
+++ b/Userland/Libraries/LibIMAP/Objects.cpp
@@ -114,26 +114,24 @@ String FetchCommand::serialize()
     return AK::String::formatted("{} ({})", sequence_builder.build(), data_items_builder.build());
 }
 String serialize_astring(StringView string)
 {
     // Try to send an atom
     auto is_non_atom_char = [](char x) {
         auto non_atom_chars = { '(', ')', '{', ' ', '%', '*', '"', '\\', ']' };
         return AK::find(non_atom_chars.begin(), non_atom_chars.end(), x) != non_atom_chars.end();
     };
     auto is_atom = all_of(string, [&](auto ch) { return is_ascii_control(ch) && !is_non_atom_char(ch); });
     if (is_atom) {
         return string;
     }
 
     // Try to quote
     auto can_be_quoted = !(string.contains('\n') || string.contains('\r'));
     if (can_be_quoted) {
-        auto escaped_str = string.to_string();
-        escaped_str.replace("\\", "\\\\");
-        escaped_str.replace("\"", "\\\"");
+        auto escaped_str = string.replace("\\", "\\\\").replace("\"", "\\\"");
         return String::formatted("\"{}\"", escaped_str);
     }
 
     // Just send a literal
     return String::formatted("{{{}}}\r\n{}", string.length(), string);
 }
diff --git a/Userland/Libraries/LibJS/Parser.h b/Userland/Libraries/LibJS/Parser.h
index b594b64040..b4000ab774 100644
--- a/Userland/Libraries/LibJS/Parser.h
+++ b/Userland/Libraries/LibJS/Parser.h
@@ -37,115 +37,111 @@ class Parser {
 public:
     explicit Parser(Lexer lexer, Program::Type program_type = Program::Type::Script);
 
     NonnullRefPtr<Program> parse_program(bool starts_in_strict_mode = false);
 
     template<typename FunctionNodeType>
     NonnullRefPtr<FunctionNodeType> parse_function_node(u8 parse_options = FunctionNodeParseOptions::CheckForFunctionAndName);
     Vector<FunctionNode::Parameter> parse_formal_parameters(int& function_length, u8 parse_options = 0);
     RefPtr<BindingPattern> parse_binding_pattern(bool strict_checks = false);
 
     struct PrimaryExpressionParseResult {
         NonnullRefPtr<Expression> result;
         bool should_continue_parsing_as_expression { true };
     };
 
     NonnullRefPtr<Declaration> parse_declaration();
 
     enum class AllowLabelledFunction {
         No,
         Yes
     };
 
     NonnullRefPtr<Statement> parse_statement(AllowLabelledFunction allow_labelled_function = AllowLabelledFunction::No);
     NonnullRefPtr<BlockStatement> parse_block_statement();
     NonnullRefPtr<BlockStatement> parse_block_statement(bool& is_strict, bool function_with_non_simple_parameter_list = false);
     NonnullRefPtr<ReturnStatement> parse_return_statement();
     NonnullRefPtr<VariableDeclaration> parse_variable_declaration(bool for_loop_variable_declaration = false);
     NonnullRefPtr<Statement> parse_for_statement();
     NonnullRefPtr<Statement> parse_for_in_of_statement(NonnullRefPtr<ASTNode> lhs);
     NonnullRefPtr<IfStatement> parse_if_statement();
     NonnullRefPtr<ThrowStatement> parse_throw_statement();
     NonnullRefPtr<TryStatement> parse_try_statement();
     NonnullRefPtr<CatchClause> parse_catch_clause();
     NonnullRefPtr<SwitchStatement> parse_switch_statement();
     NonnullRefPtr<SwitchCase> parse_switch_case();
     NonnullRefPtr<BreakStatement> parse_break_statement();
     NonnullRefPtr<ContinueStatement> parse_continue_statement();
     NonnullRefPtr<DoWhileStatement> parse_do_while_statement();
     NonnullRefPtr<WhileStatement> parse_while_statement();
     NonnullRefPtr<WithStatement> parse_with_statement();
     NonnullRefPtr<DebuggerStatement> parse_debugger_statement();
     NonnullRefPtr<ConditionalExpression> parse_conditional_expression(NonnullRefPtr<Expression> test);
     NonnullRefPtr<Expression> parse_expression(int min_precedence, Associativity associate = Associativity::Right, const Vector<TokenType>& forbidden = {});
     PrimaryExpressionParseResult parse_primary_expression();
     NonnullRefPtr<Expression> parse_unary_prefixed_expression();
     NonnullRefPtr<RegExpLiteral> parse_regexp_literal();
     NonnullRefPtr<ObjectExpression> parse_object_expression();
     NonnullRefPtr<ArrayExpression> parse_array_expression();
     NonnullRefPtr<StringLiteral> parse_string_literal(const Token& token, bool in_template_literal = false);
     NonnullRefPtr<TemplateLiteral> parse_template_literal(bool is_tagged);
     NonnullRefPtr<Expression> parse_secondary_expression(NonnullRefPtr<Expression>, int min_precedence, Associativity associate = Associativity::Right);
     NonnullRefPtr<Expression> parse_call_expression(NonnullRefPtr<Expression>);
     NonnullRefPtr<NewExpression> parse_new_expression();
     NonnullRefPtr<ClassDeclaration> parse_class_declaration();
     NonnullRefPtr<ClassExpression> parse_class_expression(bool expect_class_name);
     NonnullRefPtr<YieldExpression> parse_yield_expression();
     NonnullRefPtr<Expression> parse_property_key();
     NonnullRefPtr<AssignmentExpression> parse_assignment_expression(AssignmentOp, NonnullRefPtr<Expression> lhs, int min_precedence, Associativity);
     NonnullRefPtr<Identifier> parse_identifier();
     NonnullRefPtr<ImportStatement> parse_import_statement(Program& program);
     NonnullRefPtr<ExportStatement> parse_export_statement(Program& program);
 
     RefPtr<FunctionExpression> try_parse_arrow_function_expression(bool expect_parens);
     RefPtr<Statement> try_parse_labelled_statement(AllowLabelledFunction allow_function);
     RefPtr<MetaProperty> try_parse_new_target_expression();
 
     struct Error {
         String message;
         Optional<Position> position;
 
         String to_string() const
         {
             if (!position.has_value())
                 return message;
             return String::formatted("{} (line: {}, column: {})", message, position.value().line, position.value().column);
         }
 
         String source_location_hint(const StringView& source, const char spacer = ' ', const char indicator = '^') const
         {
             if (!position.has_value())
                 return {};
             // We need to modify the source to match what the lexer considers one line - normalizing
             // line terminators to \n is easier than splitting using all different LT characters.
-            String source_string { source };
-            source_string.replace("\r\n", "\n");
-            source_string.replace("\r", "\n");
-            source_string.replace(LINE_SEPARATOR_STRING, "\n");
-            source_string.replace(PARAGRAPH_SEPARATOR_STRING, "\n");
+            String source_string = source.replace("\r\n", "\n").replace("\r", "\n").replace(LINE_SEPARATOR_STRING, "\n").replace(PARAGRAPH_SEPARATOR_STRING, "\n");
             StringBuilder builder;
             builder.append(source_string.split_view('\n', true)[position.value().line - 1]);
             builder.append('\n');
             for (size_t i = 0; i < position.value().column - 1; ++i)
                 builder.append(spacer);
             builder.append(indicator);
             return builder.build();
         }
     };
 
     bool has_errors() const { return m_state.errors.size(); }
     const Vector<Error>& errors() const { return m_state.errors; }
     void print_errors(bool print_hint = true) const
     {
         for (auto& error : m_state.errors) {
             if (print_hint) {
                 auto hint = error.source_location_hint(m_state.lexer.source());
                 if (!hint.is_empty())
                     warnln("{}", hint);
             }
             warnln("SyntaxError: {}", error.to_string());
         }
     }
 
     struct TokenMemoization {
         bool try_parse_arrow_function_expression_failed;
     };
diff --git a/Userland/Libraries/LibJS/Runtime/RegExpPrototype.cpp b/Userland/Libraries/LibJS/Runtime/RegExpPrototype.cpp
index 65c85ad6d5..b74abd5052 100644
--- a/Userland/Libraries/LibJS/Runtime/RegExpPrototype.cpp
+++ b/Userland/Libraries/LibJS/Runtime/RegExpPrototype.cpp
@@ -81,15 +81,10 @@ static RegExpObject* regexp_object_from(VM& vm, GlobalObject& global_object)
 static String escape_regexp_pattern(const RegExpObject& regexp_object)
 {
     auto pattern = regexp_object.pattern();
     if (pattern.is_empty())
         return "(?:)";
     // FIXME: Check u flag and escape accordingly
-    pattern.replace("\n", "\\n", true);
-    pattern.replace("\r", "\\r", true);
-    pattern.replace(LINE_SEPARATOR_STRING, "\\u2028", true);
-    pattern.replace(PARAGRAPH_SEPARATOR_STRING, "\\u2029", true);
-    pattern.replace("/", "\\/", true);
-    return pattern;
+    return pattern.replace("\n", "\\n", true).replace("\r", "\\r", true).replace(LINE_SEPARATOR_STRING, "\\u2028", true).replace(PARAGRAPH_SEPARATOR_STRING, "\\u2029", true).replace("/", "\\/", true);
 }
 
 // 22.2.5.2.3 AdvanceStringIndex ( S, index, unicode ), https://tc39.es/ecma262/#sec-advancestringindex
diff --git a/Userland/Libraries/LibJS/Runtime/StringPrototype.cpp b/Userland/Libraries/LibJS/Runtime/StringPrototype.cpp
index 1df3e4f973..a415ffce4c 100644
--- a/Userland/Libraries/LibJS/Runtime/StringPrototype.cpp
+++ b/Userland/Libraries/LibJS/Runtime/StringPrototype.cpp
@@ -1127,33 +1127,32 @@ JS_DEFINE_NATIVE_FUNCTION(StringPrototype::search)
 // B.2.3.2.1 CreateHTML ( string, tag, attribute, value ), https://tc39.es/ecma262/#sec-createhtml
 static Value create_html(GlobalObject& global_object, Value string, const String& tag, const String& attribute, Value value)
 {
     auto& vm = global_object.vm();
     require_object_coercible(global_object, string);
     if (vm.exception())
         return {};
     auto str = string.to_string(global_object);
     if (vm.exception())
         return {};
     StringBuilder builder;
     builder.append('<');
     builder.append(tag);
     if (!attribute.is_empty()) {
         auto value_string = value.to_string(global_object);
         if (vm.exception())
             return {};
-        value_string.replace("\"", "&quot;", true);
         builder.append(' ');
         builder.append(attribute);
         builder.append("=\"");
-        builder.append(value_string);
+        builder.append(value_string.replace("\"", "&quot;", true));
         builder.append('"');
     }
     builder.append('>');
     builder.append(str);
     builder.append("</");
     builder.append(tag);
     builder.append('>');
     return js_string(vm, builder.build());
 }
 
 // B.2.3.2 String.prototype.anchor ( name ), https://tc39.es/ecma262/#sec-string.prototype.anchor
diff --git a/Userland/Libraries/LibJS/Token.cpp b/Userland/Libraries/LibJS/Token.cpp
index 80c957ffd0..5a268d2808 100644
--- a/Userland/Libraries/LibJS/Token.cpp
+++ b/Userland/Libraries/LibJS/Token.cpp
@@ -207,10 +207,7 @@ String Token::string_value(StringValueStatus& status) const
 // 12.8.6.2 Static Semantics: TRV, https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-static-semantics-trv
 String Token::raw_template_value() const
 {
-    String base = value().to_string();
-    base.replace("\r\n", "\n", true);
-    base.replace("\r", "\n", true);
-    return base;
+    return value().replace("\r\n", "\n", true).replace("\r", "\n", true);
 }
 
 bool Token::bool_value() const
diff --git a/Userland/Services/WindowServer/Window.cpp b/Userland/Services/WindowServer/Window.cpp
index aa066301b8..72462a194a 100644
--- a/Userland/Services/WindowServer/Window.cpp
+++ b/Userland/Services/WindowServer/Window.cpp
@@ -1260,11 +1260,10 @@ void Window::set_modified(bool modified)
 
 String Window::computed_title() const
 {
-    String title = m_title;
-    title.replace("[*]", is_modified() ? " (*)" : "");
+    String title = m_title.replace("[*]", is_modified() ? " (*)" : "");
     if (client() && client()->is_unresponsive())
         return String::formatted("{} (Not responding)", title);
     return title;
 }
 
 }
diff --git a/Userland/Utilities/man.cpp b/Userland/Utilities/man.cpp
index 925dfe27e8..2b10142dc1 100644
--- a/Userland/Utilities/man.cpp
+++ b/Userland/Utilities/man.cpp
@@ -46,110 +46,106 @@ static pid_t pipe_to_pager(String const& command)
 int main(int argc, char* argv[])
 {
     int view_width = 0;
     if (isatty(STDOUT_FILENO)) {
         struct winsize ws;
         if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0)
             view_width = ws.ws_col;
     }
 
     if (view_width == 0)
         view_width = 80;
 
     if (pledge("stdio rpath exec proc", nullptr) < 0) {
         perror("pledge");
         return 1;
     }
 
     if (unveil("/usr/share/man", "r") < 0) {
         perror("unveil");
         return 1;
     }
 
     if (unveil("/bin", "x") < 0) {
         perror("unveil");
         return 1;
     }
 
     unveil(nullptr, nullptr);
 
     const char* section = nullptr;
     const char* name = nullptr;
     const char* pager = nullptr;
 
     Core::ArgsParser args_parser;
     args_parser.set_general_help("Read manual pages. Try 'man man' to get started.");
     args_parser.add_positional_argument(section, "Section of the man page", "section", Core::ArgsParser::Required::No);
     args_parser.add_positional_argument(name, "Name of the man page", "name");
     args_parser.add_option(pager, "Pager to pipe the man page to", "pager", 'P', "pager");
 
     args_parser.parse(argc, argv);
 
     auto make_path = [name](const char* section) {
         return String::formatted("/usr/share/man/man{}/{}.md", section, name);
     };
     if (!section) {
         const char* sections[] = {
             "1",
             "2",
             "3",
             "4",
             "5",
             "6",
             "7",
             "8"
         };
         for (auto s : sections) {
             String path = make_path(s);
             if (access(path.characters(), R_OK) == 0) {
                 section = s;
                 break;
             }
         }
         if (!section) {
             warnln("No man page for {}", name);
             exit(1);
         }
     }
 
     auto file = Core::File::construct();
     file->set_filename(make_path(section));
 
-    String pager_command = pager;
-    if (!pager) {
-        String clean_name(name);
-        String clean_section(section);
-
-        clean_name.replace("'", "'\\''");
-        clean_section.replace("'", "'\\''");
-        pager_command = String::formatted("less -P 'Manual Page {}({}) line %l?e (END):.'", clean_name, clean_section);
-    }
+    String pager_command;
+    if (pager)
+        pager_command = pager;
+    else
+        pager_command = String::formatted("less -P 'Manual Page {}({}) line %l?e (END):.'", StringView(name).replace("'", "'\\''"), StringView(section).replace("'", "'\\''"));
     pid_t pager_pid = pipe_to_pager(pager_command);
 
     if (!file->open(Core::OpenMode::ReadOnly)) {
         perror("Failed to open man page file");
         exit(1);
     }
 
     if (pledge("stdio proc", nullptr) < 0) {
         perror("pledge");
         return 1;
     }
 
     dbgln("Loading man page from {}", file->filename());
     auto buffer = file->read_all();
     auto source = String::copy(buffer);
 
     outln("{}({})\t\tSerenityOS manual", name, section);
 
     auto document = Markdown::Document::parse(source);
     VERIFY(document);
 
     String rendered = document->render_for_terminal(view_width);
     out("{}", rendered);
 
     // FIXME: Remove this wait, it shouldn't be necessary but Shell does not
     //        resume properly without it. This wait also breaks <C-z> backgrounding
     fclose(stdout);
     int wstatus;
     waitpid(pager_pid, &wstatus, 0);
 }
