commit 3d139a4e02fde4a006176e19c34b379fab54d385
Author: Brian Osman <brianosman@google.com>
Date:   Mon Nov 19 10:42:10 2018 -0500

    Use half floats for non-normalized color in GrTextureOp
    
    Bug: skia:
    Change-Id: Ie681369ef4b1d3d43c326da684afde9ce6d08486
    Reviewed-on: https://skia-review.googlesource.com/c/171726
    Reviewed-by: Brian Salomon <bsalomon@google.com>
    Reviewed-by: Mike Klein <mtklein@google.com>
    Commit-Queue: Brian Osman <brianosman@google.com>

diff --git a/gm/clockwise.cpp b/gm/clockwise.cpp
index dacf03e45a..4461c778bc 100644
--- a/gm/clockwise.cpp
+++ b/gm/clockwise.cpp
@@ -142,48 +142,48 @@ private:
 void ClockwiseGM::onDraw(SkCanvas* canvas) {
     GrContext* ctx = canvas->getGrContext();
     GrRenderTargetContext* rtc = canvas->internal_private_accessTopLayerRenderTargetContext();
     if (!ctx || !rtc) {
         DrawGpuOnlyMessage(canvas);
         return;
     }
 
     rtc->clear(nullptr, { 0, 0, 0, 1 }, GrRenderTargetContext::CanClearFullscreen::kYes);
 
     // Draw the test directly to the frame buffer.
     rtc->priv().testingOnly_addDrawOp(ClockwiseTestOp::Make(ctx, false, 0));
     rtc->priv().testingOnly_addDrawOp(ClockwiseTestOp::Make(ctx, true, 100));
 
     // Draw the test to an off-screen, top-down render target.
     if (auto topLeftRTC = ctx->contextPriv().makeDeferredRenderTargetContext(
                     SkBackingFit::kExact, 100, 200, rtc->asSurfaceProxy()->config(),
                     nullptr, 1, GrMipMapped::kNo, kTopLeft_GrSurfaceOrigin, nullptr,
                     SkBudgeted::kYes)) {
         topLeftRTC->clear(nullptr, SK_PMColor4fTRANSPARENT,
                           GrRenderTargetContext::CanClearFullscreen::kYes);
         topLeftRTC->priv().testingOnly_addDrawOp(ClockwiseTestOp::Make(ctx, false, 0));
         topLeftRTC->priv().testingOnly_addDrawOp(ClockwiseTestOp::Make(ctx, true, 100));
         rtc->drawTexture(GrNoClip(), sk_ref_sp(topLeftRTC->asTextureProxy()),
-                         GrSamplerState::Filter::kNearest, 0xffffffff, {0, 0, 100, 200},
+                         GrSamplerState::Filter::kNearest, SK_PMColor4fWHITE, {0, 0, 100, 200},
                          {100, 0, 200, 200}, GrQuadAAFlags::kNone,
                          SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint, SkMatrix::I(),
-                         nullptr, nullptr);
+                         nullptr);
     }
 
     // Draw the test to an off-screen, bottom-up render target.
     if (auto topLeftRTC = ctx->contextPriv().makeDeferredRenderTargetContext(
                     SkBackingFit::kExact, 100, 200, rtc->asSurfaceProxy()->config(),
                     nullptr, 1, GrMipMapped::kNo, kBottomLeft_GrSurfaceOrigin, nullptr,
                     SkBudgeted::kYes)) {
         topLeftRTC->clear(nullptr, SK_PMColor4fTRANSPARENT,
                           GrRenderTargetContext::CanClearFullscreen::kYes);
         topLeftRTC->priv().testingOnly_addDrawOp(ClockwiseTestOp::Make(ctx, false, 0));
         topLeftRTC->priv().testingOnly_addDrawOp(ClockwiseTestOp::Make(ctx, true, 100));
         rtc->drawTexture(GrNoClip(), sk_ref_sp(topLeftRTC->asTextureProxy()),
-                         GrSamplerState::Filter::kNearest, 0xffffffff, {0, 0, 100, 200},
+                         GrSamplerState::Filter::kNearest, SK_PMColor4fWHITE, {0, 0, 100, 200},
                          {200, 0, 300, 200}, GrQuadAAFlags::kNone,
                          SkCanvas::SrcRectConstraint::kStrict_SrcRectConstraint, SkMatrix::I(),
-                         nullptr, nullptr);
+                         nullptr);
     }
 }
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////
diff --git a/include/private/GrColor.h b/include/private/GrColor.h
index 6b8c7430b3..61248643e4 100644
--- a/include/private/GrColor.h
+++ b/include/private/GrColor.h
@@ -41,41 +41,30 @@ typedef uint32_t GrColor;
 /**
  *  Pack 4 components (RGBA) into a GrColor int
  */
 static inline GrColor GrColorPackRGBA(unsigned r, unsigned g, unsigned b, unsigned a) {
     SkASSERT((uint8_t)r == r);
     SkASSERT((uint8_t)g == g);
     SkASSERT((uint8_t)b == b);
     SkASSERT((uint8_t)a == a);
     return  (r << GrColor_SHIFT_R) |
             (g << GrColor_SHIFT_G) |
             (b << GrColor_SHIFT_B) |
             (a << GrColor_SHIFT_A);
 }
 
-/**
- *  Packs a color with an alpha channel replicated across all four channels.
- */
-static inline GrColor GrColorPackA4(unsigned a) {
-    SkASSERT((uint8_t)a == a);
-    return  (a << GrColor_SHIFT_R) |
-            (a << GrColor_SHIFT_G) |
-            (a << GrColor_SHIFT_B) |
-            (a << GrColor_SHIFT_A);
-}
-
 // extract a component (byte) from a GrColor int
 
 #define GrColorUnpackR(color)   (((color) >> GrColor_SHIFT_R) & 0xFF)
 #define GrColorUnpackG(color)   (((color) >> GrColor_SHIFT_G) & 0xFF)
 #define GrColorUnpackB(color)   (((color) >> GrColor_SHIFT_B) & 0xFF)
 #define GrColorUnpackA(color)   (((color) >> GrColor_SHIFT_A) & 0xFF)
 
 /**
  *  Since premultiplied means that alpha >= color, we construct a color with
  *  each component==255 and alpha == 0 to be "illegal"
  */
 #define GrColor_ILLEGAL     (~(0xFF << GrColor_SHIFT_A))
 
 #define GrColor_WHITE 0xFFFFFFFF
 
 /** Normalizes and coverts an uint8_t to a float. [0, 255] -> [0.0, 1.0] */
diff --git a/src/gpu/GrRenderTargetContext.cpp b/src/gpu/GrRenderTargetContext.cpp
index 7873dd985f..9e857f3926 100644
--- a/src/gpu/GrRenderTargetContext.cpp
+++ b/src/gpu/GrRenderTargetContext.cpp
@@ -800,47 +800,45 @@ void GrRenderTargetContext::fillRectToRect(const GrClip& clip,
 }
 
 void GrRenderTargetContext::drawTexture(const GrClip& clip, sk_sp<GrTextureProxy> proxy,
-                                        GrSamplerState::Filter filter, GrColor color,
+                                        GrSamplerState::Filter filter, const SkPMColor4f& color,
                                         const SkRect& srcRect, const SkRect& dstRect,
                                         GrQuadAAFlags aaFlags,
                                         SkCanvas::SrcRectConstraint constraint,
                                         const SkMatrix& viewMatrix,
-                                        sk_sp<GrColorSpaceXform> textureColorSpaceXform,
-                                        sk_sp<GrColorSpaceXform> paintColorSpaceXform) {
+                                        sk_sp<GrColorSpaceXform> textureColorSpaceXform) {
     ASSERT_SINGLE_OWNER
     RETURN_IF_ABANDONED
     SkDEBUGCODE(this->validate();)
     GR_CREATE_TRACE_MARKER_CONTEXT("GrRenderTargetContext", "drawTexture", fContext);
     if (constraint == SkCanvas::kStrict_SrcRectConstraint &&
         srcRect.contains(proxy->getWorstCaseBoundsRect())) {
         constraint = SkCanvas::kFast_SrcRectConstraint;
     }
     GrAAType aaType =
             this->chooseAAType(GrAA(aaFlags != GrQuadAAFlags::kNone), GrAllowMixedSamples::kNo);
     SkRect clippedDstRect = dstRect;
     SkRect clippedSrcRect = srcRect;
     if (!crop_filled_rect(this->width(), this->height(), clip, viewMatrix, &clippedDstRect,
                           &clippedSrcRect)) {
         return;
     }
     auto op = GrTextureOp::Make(fContext, std::move(proxy), filter, color, clippedSrcRect,
                                 clippedDstRect, aaType, aaFlags, constraint, viewMatrix,
-                                std::move(textureColorSpaceXform), std::move(paintColorSpaceXform));
+                                std::move(textureColorSpaceXform));
     this->addDrawOp(clip, std::move(op));
 }
 
 void GrRenderTargetContext::drawTextureSet(const GrClip& clip, const TextureSetEntry set[], int cnt,
-                                           GrSamplerState::Filter filter, GrColor color,
+                                           GrSamplerState::Filter filter, const SkPMColor4f& color,
                                            const SkMatrix& viewMatrix,
-                                           sk_sp<GrColorSpaceXform> texXform,
-                                           sk_sp<GrColorSpaceXform> colorXform) {
+                                           sk_sp<GrColorSpaceXform> texXform) {
     ASSERT_SINGLE_OWNER
     RETURN_IF_ABANDONED
     SkDEBUGCODE(this->validate();)
     GR_CREATE_TRACE_MARKER_CONTEXT("GrRenderTargetContext", "drawTextureSet", fContext);
     GrAAType aaType = this->chooseAAType(GrAA::kYes, GrAllowMixedSamples::kNo);
     auto op = GrTextureOp::Make(fContext, set, cnt, filter, color, aaType, viewMatrix,
-                                std::move(texXform), std::move(colorXform));
+                                std::move(texXform));
     this->addDrawOp(clip, std::move(op));
 }
 
diff --git a/src/gpu/GrRenderTargetContext.h b/src/gpu/GrRenderTargetContext.h
index f099134d61..da34c124bc 100644
--- a/src/gpu/GrRenderTargetContext.h
+++ b/src/gpu/GrRenderTargetContext.h
@@ -1,23 +1,22 @@
 /*
  * Copyright 2015 Google Inc.
  *
  * Use of this source code is governed by a BSD-style license that can be
  * found in the LICENSE file.
  */
 
 #ifndef GrRenderTargetContext_DEFINED
 #define GrRenderTargetContext_DEFINED
 
 #include "../private/GrRenderTargetProxy.h"
-#include "GrColor.h"
 #include "GrContext.h"
 #include "GrContextPriv.h"
 #include "GrPaint.h"
 #include "GrSurfaceContext.h"
 #include "GrTypesPriv.h"
 #include "GrXferProcessor.h"
 #include "SkCanvas.h"
 #include "SkDrawable.h"
 #include "SkRefCnt.h"
 #include "SkSurfaceProps.h"
 #include "text/GrTextTarget.h"
@@ -59,346 +58,346 @@ class SK_API GrRenderTargetContext : public GrSurfaceContext {
 public:
     ~GrRenderTargetContext() override;
 
     virtual void drawGlyphRunList(const GrClip&, const SkMatrix& viewMatrix, const SkGlyphRunList&);
 
     /**
      * Provides a perfomance hint that the render target's contents are allowed
      * to become undefined.
      */
     void discard();
 
     enum class CanClearFullscreen : bool {
         kNo = false,
         kYes = true
     };
 
     /**
      * Clear the entire or rect of the render target, ignoring any clips.
      * @param rect  the rect to clear or the whole thing if rect is NULL.
      * @param color the color to clear to.
      * @param CanClearFullscreen allows partial clears to be converted to fullscreen clears on
      *                           tiling platforms where that is an optimization.
      */
     void clear(const SkIRect* rect, const SkPMColor4f& color, CanClearFullscreen);
 
     /**
      *  Draw everywhere (respecting the clip) with the paint.
      */
     void drawPaint(const GrClip&, GrPaint&&, const SkMatrix& viewMatrix);
 
     /**
      * Draw the rect using a paint.
      * @param paint        describes how to color pixels.
      * @param GrAA         Controls whether rect is antialiased
      * @param viewMatrix   transformation matrix
      * @param style        The style to apply. Null means fill. Currently path effects are not
      *                     allowed.
      * The rects coords are used to access the paint (through texture matrix)
      */
     void drawRect(const GrClip&,
                   GrPaint&& paint,
                   GrAA,
                   const SkMatrix& viewMatrix,
                   const SkRect&,
                   const GrStyle* style = nullptr);
 
     /**
      * Maps a rectangle of shader coordinates to a rectangle and fills that rectangle.
      *
      * @param paint        describes how to color pixels.
      * @param GrAA         Controls whether rect is antialiased
      * @param viewMatrix   transformation matrix which applies to rectToDraw
      * @param rectToDraw   the rectangle to draw
      * @param localRect    the rectangle of shader coordinates applied to rectToDraw
      */
     void fillRectToRect(const GrClip&,
                         GrPaint&& paint,
                         GrAA,
                         const SkMatrix& viewMatrix,
                         const SkRect& rectToDraw,
                         const SkRect& localRect);
 
     /**
      * Fills a rect with a paint and a localMatrix.
      */
     void fillRectWithLocalMatrix(const GrClip& clip,
                                  GrPaint&& paint,
                                  GrAA,
                                  const SkMatrix& viewMatrix,
                                  const SkRect& rect,
                                  const SkMatrix& localMatrix);
 
     /**
      * Creates an op that draws a subrectangle of a texture. The passed color is modulated by the
      * texture's color. 'srcRect' specifies the rectangle of the texture to draw. 'dstRect'
      * specifies the rectangle to draw in local coords which will be transformed by 'viewMatrix' to
      * device space.
      */
-    void drawTexture(const GrClip& clip, sk_sp<GrTextureProxy>, GrSamplerState::Filter, GrColor,
-                     const SkRect& srcRect, const SkRect& dstRect, GrQuadAAFlags,
-                     SkCanvas::SrcRectConstraint, const SkMatrix& viewMatrix,
-                     sk_sp<GrColorSpaceXform> texXform, sk_sp<GrColorSpaceXform> colorXform);
+    void drawTexture(const GrClip& clip, sk_sp<GrTextureProxy>, GrSamplerState::Filter,
+                     const SkPMColor4f&, const SkRect& srcRect, const SkRect& dstRect,
+                     GrQuadAAFlags, SkCanvas::SrcRectConstraint, const SkMatrix& viewMatrix,
+                     sk_sp<GrColorSpaceXform> texXform);
 
     /** Used with drawTextureSet */
     struct TextureSetEntry {
         sk_sp<GrTextureProxy> fProxy;
         SkRect fSrcRect;
         SkRect fDstRect;
         GrQuadAAFlags fAAFlags;
     };
     /**
      * Draws a set of textures with a shared filter, color, view matrix, color xform, and
      * texture color xform. The textures must all have the same GrTextureType and GrConfig.
      */
     void drawTextureSet(const GrClip&, const TextureSetEntry[], int cnt, GrSamplerState::Filter,
-                        GrColor, const SkMatrix& viewMatrix, sk_sp<GrColorSpaceXform> texXform,
-                        sk_sp<GrColorSpaceXform> colorXform);
+                        const SkPMColor4f&, const SkMatrix& viewMatrix,
+                        sk_sp<GrColorSpaceXform> texXform);
 
     /**
      * Draw a roundrect using a paint.
      *
      * @param paint       describes how to color pixels.
      * @param GrAA        Controls whether rrect is antialiased.
      * @param viewMatrix  transformation matrix
      * @param rrect       the roundrect to draw
      * @param style       style to apply to the rrect. Currently path effects are not allowed.
      */
     void drawRRect(const GrClip&,
                    GrPaint&&,
                    GrAA,
                    const SkMatrix& viewMatrix,
                    const SkRRect& rrect,
                    const GrStyle& style);
 
     /**
      * Use a fast method to render the ambient and spot shadows for a path.
      * Will return false if not possible for the given path.
      *
      * @param viewMatrix   transformation matrix
      * @param path         the path to shadow
      * @param rec          parameters for shadow rendering
      */
     bool drawFastShadow(const GrClip&,
                         const SkMatrix& viewMatrix,
                         const SkPath& path,
                         const SkDrawShadowRec& rec);
 
     /**
      * Shortcut for filling a SkPath consisting of nested rrects using a paint. The result is
      * undefined if outer does not contain inner.
      *
      * @param paint        describes how to color pixels.
      * @param GrAA         Controls whether rrects edges are antialiased
      * @param viewMatrix   transformation matrix
      * @param outer        the outer roundrect
      * @param inner        the inner roundrect
      */
     void drawDRRect(const GrClip&,
                     GrPaint&&,
                     GrAA,
                     const SkMatrix& viewMatrix,
                     const SkRRect& outer,
                     const SkRRect& inner);
 
     /**
      * Draws a path.
      *
      * @param paint         describes how to color pixels.
      * @param GrAA          Controls whether the path is antialiased.
      * @param viewMatrix    transformation matrix
      * @param path          the path to draw
      * @param style         style to apply to the path.
      */
     void drawPath(const GrClip&,
                   GrPaint&&,
                   GrAA,
                   const SkMatrix& viewMatrix,
                   const SkPath&,
                   const GrStyle&);
 
     /**
      * Draws a shape.
      *
      * @param paint         describes how to color pixels.
      * @param GrAA          Controls whether the path is antialiased.
      * @param viewMatrix    transformation matrix
      * @param shape         the shape to draw
      */
     void drawShape(const GrClip&,
                    GrPaint&&,
                    GrAA,
                    const SkMatrix& viewMatrix,
                    const GrShape&);
 
 
     /**
      * Draws vertices with a paint.
      *
      * @param   paint            describes how to color pixels.
      * @param   viewMatrix       transformation matrix
      * @param   vertices         specifies the mesh to draw.
      * @param   bones            bone deformation matrices.
      * @param   boneCount        number of bone matrices.
      * @param   overridePrimType primitive type to draw. If NULL, derive prim type from vertices.
      */
     void drawVertices(const GrClip&,
                       GrPaint&& paint,
                       const SkMatrix& viewMatrix,
                       sk_sp<SkVertices> vertices,
                       const SkVertices::Bone bones[],
                       int boneCount,
                       GrPrimitiveType* overridePrimType = nullptr);
 
     /**
      * Draws textured sprites from an atlas with a paint. This currently does not support AA for the
      * sprite rectangle edges.
      *
      * @param   paint           describes how to color pixels.
      * @param   viewMatrix      transformation matrix
      * @param   spriteCount     number of sprites.
      * @param   xform           array of compressed transformation data, required.
      * @param   texRect         array of texture rectangles used to access the paint.
      * @param   colors          optional array of per-sprite colors, supercedes
      *                          the paint's color field.
      */
     void drawAtlas(const GrClip&,
                    GrPaint&& paint,
                    const SkMatrix& viewMatrix,
                    int spriteCount,
                    const SkRSXform xform[],
                    const SkRect texRect[],
                    const SkColor colors[]);
 
     /**
      * Draws a region.
      *
      * @param paint         describes how to color pixels
      * @param viewMatrix    transformation matrix
      * @param aa            should the rects of the region be antialiased.
      * @param region        the region to be drawn
      * @param style         style to apply to the region
      */
     void drawRegion(const GrClip&,
                     GrPaint&& paint,
                     GrAA aa,
                     const SkMatrix& viewMatrix,
                     const SkRegion& region,
                     const GrStyle& style,
                     const GrUserStencilSettings* ss = nullptr);
 
     /**
      * Draws an oval.
      *
      * @param paint         describes how to color pixels.
      * @param GrAA          Controls whether the oval is antialiased.
      * @param viewMatrix    transformation matrix
      * @param oval          the bounding rect of the oval.
      * @param style         style to apply to the oval. Currently path effects are not allowed.
      */
     void drawOval(const GrClip&,
                   GrPaint&& paint,
                   GrAA,
                   const SkMatrix& viewMatrix,
                   const SkRect& oval,
                   const GrStyle& style);
     /**
      * Draws a partial arc of an oval.
      *
      * @param paint         describes how to color pixels.
      * @param GrGrAA        Controls whether the arc is antialiased.
      * @param viewMatrix    transformation matrix.
      * @param oval          the bounding rect of the oval.
      * @param startAngle    starting angle in degrees.
      * @param sweepAngle    angle to sweep in degrees. Must be in (-360, 360)
      * @param useCenter     true means that the implied path begins at the oval center, connects as
      *                      a line to the point indicated by the start contains the arc indicated by
      *                      the sweep angle. If false the line beginning at the center point is
      *                      omitted.
      * @param style         style to apply to the oval.
      */
     void drawArc(const GrClip&,
                  GrPaint&& paint,
                  GrAA,
                  const SkMatrix& viewMatrix,
                  const SkRect& oval,
                  SkScalar startAngle,
                  SkScalar sweepAngle,
                  bool useCenter,
                  const GrStyle& style);
 
     /**
      * Draw the image as a set of rects, specified by |iter|.
      */
     void drawImageLattice(const GrClip&,
                           GrPaint&&,
                           const SkMatrix& viewMatrix,
                           sk_sp<GrTextureProxy>,
                           sk_sp<GrColorSpaceXform>,
                           GrSamplerState::Filter,
                           std::unique_ptr<SkLatticeIter>,
                           const SkRect& dst);
 
     /**
      * Adds the necessary signal and wait semaphores and adds the passed in SkDrawable to the
      * command stream.
      */
     void drawDrawable(std::unique_ptr<SkDrawable::GpuDrawHandler>, const SkRect& bounds);
 
     /**
      * After this returns any pending surface IO will be issued to the backend 3D API and
      * if the surface has MSAA it will be resolved.
      */
     GrSemaphoresSubmitted prepareForExternalIO(int numSemaphores,
                                                GrBackendSemaphore backendSemaphores[]);
 
     /**
      *  The next time this GrRenderTargetContext is flushed, the gpu will wait on the passed in
      *  semaphores before executing any commands.
      */
     bool waitOnSemaphores(int numSemaphores, const GrBackendSemaphore* waitSemaphores);
 
     void insertEventMarker(const SkString&);
 
     GrFSAAType fsaaType() const { return fRenderTargetProxy->fsaaType(); }
     const GrCaps* caps() const { return fContext->contextPriv().caps(); }
     int width() const { return fRenderTargetProxy->width(); }
     int height() const { return fRenderTargetProxy->height(); }
     int numColorSamples() const { return fRenderTargetProxy->numColorSamples(); }
     int numStencilSamples() const { return fRenderTargetProxy->numStencilSamples(); }
     const SkSurfaceProps& surfaceProps() const { return fSurfaceProps; }
     GrSurfaceOrigin origin() const { return fRenderTargetProxy->origin(); }
     GrMipMapped mipMapped() const;
 
     bool wasAbandoned() const;
 
     void setNeedsStencil() { fRenderTargetProxy->setNeedsStencil(); }
 
     GrRenderTarget* accessRenderTarget() {
         // TODO: usage of this entry point needs to be reduced and potentially eliminated
         // since it ends the deferral of the GrRenderTarget's allocation
         if (!fRenderTargetProxy->instantiate(fContext->contextPriv().resourceProvider())) {
             return nullptr;
         }
         return fRenderTargetProxy->peekRenderTarget();
     }
 
     GrSurfaceProxy* asSurfaceProxy() override { return fRenderTargetProxy.get(); }
     const GrSurfaceProxy* asSurfaceProxy() const override { return fRenderTargetProxy.get(); }
     sk_sp<GrSurfaceProxy> asSurfaceProxyRef() override { return fRenderTargetProxy; }
 
     GrTextureProxy* asTextureProxy() override;
     const GrTextureProxy* asTextureProxy() const override;
     sk_sp<GrTextureProxy> asTextureProxyRef() override;
 
     GrRenderTargetProxy* asRenderTargetProxy() override { return fRenderTargetProxy.get(); }
     sk_sp<GrRenderTargetProxy> asRenderTargetProxyRef() override { return fRenderTargetProxy; }
 
     GrRenderTargetContext* asRenderTargetContext() override { return this; }
 
     // Provides access to functions that aren't part of the public API.
     GrRenderTargetContextPriv priv();
     const GrRenderTargetContextPriv priv() const;
 
     GrTextTarget* textTarget() { return fTextTarget.get(); }
 
     bool isWrapped_ForTesting() const;
diff --git a/src/gpu/SkGpuDevice.cpp b/src/gpu/SkGpuDevice.cpp
index daa86fc2d7..ff9e443215 100644
--- a/src/gpu/SkGpuDevice.cpp
+++ b/src/gpu/SkGpuDevice.cpp
@@ -1455,68 +1455,68 @@ void SkGpuDevice::drawBitmapLattice(const SkBitmap& bitmap,
 void SkGpuDevice::drawImageSet(const SkCanvas::ImageSetEntry set[], int count, float alpha,
                                SkFilterQuality filterQuality, SkBlendMode mode) {
     SkASSERT(count > 0);
     if (mode != SkBlendMode::kSrcOver ||
         !fContext->contextPriv().caps()->dynamicStateArrayGeometryProcessorTextureSupport()) {
         INHERITED::drawImageSet(set, count, alpha, filterQuality, mode);
         return;
     }
     GrSamplerState sampler;
     sampler.setFilterMode(kNone_SkFilterQuality == filterQuality ? GrSamplerState::Filter::kNearest
                                                                  : GrSamplerState::Filter::kBilerp);
     SkAutoTArray<GrRenderTargetContext::TextureSetEntry> textures(count);
-    GrColor color = GrColorPackA4(SkToUInt(SkTClamp(SkScalarRoundToInt(alpha * 255), 0, 255)));
+    SkPMColor4f color = { alpha, alpha, alpha, alpha };
     // We accumulate compatible proxies until we find an an incompatible one or reach the end and
     // issue the accumulated 'n' draws starting at 'base'.
     int base = 0, n = 0;
     auto draw = [&] {
         if (n > 0) {
             auto textureXform = GrColorSpaceXform::Make(
                     set[base].fImage->colorSpace(), set[base].fImage->alphaType(),
                     fRenderTargetContext->colorSpaceInfo().colorSpace(), kPremul_SkAlphaType);
             fRenderTargetContext->drawTextureSet(this->clip(), textures.get() + base, n,
                                                  sampler.filter(), color, this->ctm(),
-                                                 std::move(textureXform), nullptr);
+                                                 std::move(textureXform));
         }
     };
     for (int i = 0; i < count; ++i) {
         // The default SkBaseDevice implementation is based on drawImageRect which does not allow
         // non-sorted src rects. TODO: Decide this is OK or make sure we handle it.
         if (!set[i].fSrcRect.isSorted()) {
             draw();
             base = i + 1;
             n = 0;
             continue;
         }
         uint32_t uniqueID;
         textures[i].fProxy = as_IB(set[i].fImage.get())->refPinnedTextureProxy(&uniqueID);
         if (!textures[i].fProxy) {
             textures[i].fProxy =
                     as_IB(set[i].fImage.get())
                             ->asTextureProxyRef(fContext.get(), GrSamplerState::ClampBilerp(),
                                                 nullptr);
             // If we failed to make a proxy then flush the accumulated set and reset for the next
             // image.
             if (!textures[i].fProxy) {
                 draw();
                 base = i + 1;
                 n = 0;
                 continue;
             }
         }
         textures[i].fSrcRect = set[i].fSrcRect;
         textures[i].fDstRect = set[i].fDstRect;
         textures[i].fAAFlags = SkToGrQuadAAFlags(set[i].fAAFlags);
         if (n > 0 &&
             (textures[i].fProxy->textureType() != textures[base].fProxy->textureType() ||
              textures[i].fProxy->config() != textures[base].fProxy->config() ||
              set[i].fImage->alphaType() != set[base].fImage->alphaType() ||
              !SkColorSpace::Equals(set[i].fImage->colorSpace(), set[base].fImage->colorSpace()))) {
             draw();
             base = i;
             n = 1;
         } else {
             ++n;
         }
     }
     draw();
 }
diff --git a/src/gpu/SkGpuDevice_drawTexture.cpp b/src/gpu/SkGpuDevice_drawTexture.cpp
index 35dd64a38c..3867465d46 100644
--- a/src/gpu/SkGpuDevice_drawTexture.cpp
+++ b/src/gpu/SkGpuDevice_drawTexture.cpp
@@ -100,45 +100,43 @@ static bool can_use_draw_texture(const SkPaint& paint) {
 static void draw_texture(const SkPaint& paint, const SkMatrix& ctm, const SkRect* src,
                          const SkRect* dst, GrAA aa, SkCanvas::SrcRectConstraint constraint,
                          sk_sp<GrTextureProxy> proxy, SkAlphaType alphaType,
                          SkColorSpace* colorSpace, const GrClip& clip, GrRenderTargetContext* rtc) {
     SkASSERT(!(SkToBool(src) && !SkToBool(dst)));
     SkRect srcRect = src ? *src : SkRect::MakeWH(proxy->width(), proxy->height());
     SkRect dstRect = dst ? *dst : srcRect;
     if (src && !SkRect::MakeIWH(proxy->width(), proxy->height()).contains(srcRect)) {
         // Shrink the src rect to be within bounds and proportionately shrink the dst rect.
         SkMatrix srcToDst;
         srcToDst.setRectToRect(srcRect, dstRect, SkMatrix::kFill_ScaleToFit);
         SkAssertResult(srcRect.intersect(SkRect::MakeIWH(proxy->width(), proxy->height())));
         srcToDst.mapRect(&dstRect, srcRect);
     }
+    const GrColorSpaceInfo& dstInfo(rtc->colorSpaceInfo());
     auto textureXform =
-        GrColorSpaceXform::Make(colorSpace                        , alphaType,
-                                rtc->colorSpaceInfo().colorSpace(), kPremul_SkAlphaType);
+        GrColorSpaceXform::Make(colorSpace          , alphaType,
+                                dstInfo.colorSpace(), kPremul_SkAlphaType);
     GrSamplerState::Filter filter;
     switch (paint.getFilterQuality()) {
         case kNone_SkFilterQuality:
             filter = GrSamplerState::Filter::kNearest;
             break;
         case kLow_SkFilterQuality:
             filter = GrSamplerState::Filter::kBilerp;
             break;
         case kMedium_SkFilterQuality:
         case kHigh_SkFilterQuality:
             SK_ABORT("Quality level not allowed.");
     }
-    GrColor color;
-    sk_sp<GrColorSpaceXform> paintColorXform = nullptr;
+    SkPMColor4f color;
     if (GrPixelConfigIsAlphaOnly(proxy->config())) {
-        // Leave the color unpremul if we're going to transform it in the vertex shader
-        paintColorXform = rtc->colorSpaceInfo().refColorSpaceXformFromSRGB();
-        color = paintColorXform ? SkColorToUnpremulGrColor(paint.getColor())
-                                : SkColorToPremulGrColor(paint.getColor());
+        color = SkColor4fPrepForDst(paint.getColor4f(), dstInfo, *rtc->caps()).premul();
     } else {
-        color = GrColorPackA4(paint.getAlpha());
+        float paintAlpha = paint.getColor4f().fA;
+        color = { paintAlpha, paintAlpha, paintAlpha, paintAlpha };
     }
     GrQuadAAFlags aaFlags = aa == GrAA::kYes ? GrQuadAAFlags::kAll : GrQuadAAFlags::kNone;
     rtc->drawTexture(clip, std::move(proxy), filter, color, srcRect, dstRect, aaFlags, constraint,
-                     ctm, std::move(textureXform), std::move(paintColorXform));
+                     ctm, std::move(textureXform));
 }
 
 //////////////////////////////////////////////////////////////////////////////
diff --git a/src/gpu/ops/GrQuadPerEdgeAA.cpp b/src/gpu/ops/GrQuadPerEdgeAA.cpp
index d27a5039c8..995c0e5c50 100644
--- a/src/gpu/ops/GrQuadPerEdgeAA.cpp
+++ b/src/gpu/ops/GrQuadPerEdgeAA.cpp
@@ -242,97 +242,98 @@ namespace GrQuadPerEdgeAA {
 ////////////////// Tessellate Implementation
 
 void* Tessellate(void* vertices, const VertexSpec& spec, const GrPerspQuad& deviceQuad,
-                 const GrColor& color, const GrPerspQuad& localQuad, const SkRect& domain,
+                 const SkPMColor4f& color4f, const GrPerspQuad& localQuad, const SkRect& domain,
                  GrQuadAAFlags aaFlags) {
     bool deviceHasPerspective = spec.deviceQuadType() == GrQuadType::kPerspective;
     bool localHasPerspective = spec.localQuadType() == GrQuadType::kPerspective;
+    GrVertexColor color(color4f, GrQuadPerEdgeAA::ColorType::kHalf == spec.colorType());
 
     // Load position data into Sk4fs (always x, y and maybe w)
     Sk4f x = deviceQuad.x4f();
     Sk4f y = deviceQuad.y4f();
     Sk4f w;
     if (deviceHasPerspective) {
         w = deviceQuad.w4f();
     }
 
     // Load local position data into Sk4fs (either none, just u,v or all three)
     Sk4f u, v, r;
     if (spec.hasLocalCoords()) {
         u = localQuad.x4f();
         v = localQuad.y4f();
 
         if (localHasPerspective) {
             r = localQuad.w4f();
         }
     }
 
     Sk4f a, b, c;
     if (spec.usesCoverageAA()) {
         // Must calculate edges and possibly outside the positions
         if (aaFlags == GrQuadAAFlags::kNone) {
             // A non-AA quad that got batched into an AA group, so its edges will be the same for
             // all four vertices and it does not need to be outset
             SkPoint3 edgeCoeffs;
             if (deviceHasPerspective) {
                 edgeCoeffs = compute_non_aa_persp_edge_coeffs(w);
             } else {
                 edgeCoeffs = kNonAANoPerspEdgeCoeffs;
             }
 
             // Copy the coefficients into all four equations
             a = edgeCoeffs.fX;
             b = edgeCoeffs.fY;
             c = edgeCoeffs.fZ;
         } else if (deviceHasPerspective) {
             // For simplicity, pointers to u, v, and r are always provided, but the local dim param
             // ensures that only loaded Sk4fs are modified in the compute functions.
             compute_quad_edges_and_outset_persp_vertices(aaFlags, &x, &y, &w, &a, &b, &c,
                                                          &u, &v, &r, spec.localDimensionality());
         } else {
             compute_quad_edges_and_outset_vertices(aaFlags, &x, &y, &a, &b, &c, &u, &v, &r,
                                                    spec.localDimensionality(), /* outset */ true);
         }
     }
 
     // Now rearrange the Sk4fs into the interleaved vertex layout:
     //  i.e. x1x2x3x4 y1y2y3y4 -> x1y1 x2y2 x3y3 x4y
     GrVertexWriter vb{vertices};
     for (int i = 0; i < 4; ++i) {
         // save position
         if (deviceHasPerspective) {
             vb.write<SkPoint3>({x[i], y[i], w[i]});
         } else {
             vb.write<SkPoint>({x[i], y[i]});
         }
 
         // save color
         if (spec.hasVertexColors()) {
-            vb.write<GrColor>(color);
+            vb.write(color);
         }
 
         // save local position
         if (spec.hasLocalCoords()) {
             if (localHasPerspective) {
                 vb.write<SkPoint3>({u[i], v[i], r[i]});
             } else {
                 vb.write<SkPoint>({u[i], v[i]});
             }
         }
 
         // save the domain
         if (spec.hasDomain()) {
             vb.write<SkRect>(domain);
         }
 
         // save the edges
         if (spec.usesCoverageAA()) {
             for (int j = 0; j < 4; j++) {
                 vb.write<SkPoint3>({a[j], b[j], c[j]});
             }
         }
     }
 
     return vb.fPtr;
 }
 
 ////////////////// VertexSpec Implementation
@@ -350,29 +351,31 @@ int VertexSpec::localDimensionality() const {
 GPAttributes::GPAttributes(const VertexSpec& spec) {
     if (spec.deviceDimensionality() == 3) {
         fPositions = {"position", kFloat3_GrVertexAttribType, kFloat3_GrSLType};
     } else {
         fPositions = {"position", kFloat2_GrVertexAttribType, kFloat2_GrSLType};
     }
 
     int localDim = spec.localDimensionality();
     if (localDim == 3) {
         fLocalCoords = {"localCoord", kFloat3_GrVertexAttribType, kFloat3_GrSLType};
     } else if (localDim == 2) {
         fLocalCoords = {"localCoord", kFloat2_GrVertexAttribType, kFloat2_GrSLType};
     } // else localDim == 0 and attribute remains uninitialized
 
-    if (spec.hasVertexColors()) {
+    if (ColorType::kByte == spec.colorType()) {
         fColors = {"color", kUByte4_norm_GrVertexAttribType, kHalf4_GrSLType};
+    } else if (ColorType::kHalf == spec.colorType()) {
+        fColors = {"color", kHalf4_GrVertexAttribType, kHalf4_GrSLType};
     }
 
     if (spec.hasDomain()) {
         fDomain = {"domain", kFloat4_GrVertexAttribType, kFloat4_GrSLType};
     }
 
     if (spec.usesCoverageAA()) {
         fAAEdges[0] = {"aaEdge0", kFloat3_GrVertexAttribType, kFloat3_GrSLType};
         fAAEdges[1] = {"aaEdge1", kFloat3_GrVertexAttribType, kFloat3_GrSLType};
         fAAEdges[2] = {"aaEdge2", kFloat3_GrVertexAttribType, kFloat3_GrSLType};
         fAAEdges[3] = {"aaEdge3", kFloat3_GrVertexAttribType, kFloat3_GrSLType};
     }
 }
@@ -384,40 +387,28 @@ bool GPAttributes::needsPerspectiveInterpolation() const {
 }
 
 uint32_t GPAttributes::getKey() const {
-    // aa, color, domain are single bit flags
+    // aa, domain are single bit flags
     uint32_t x = this->usesCoverageAA() ? 0 : 1;
-    x |= this->hasVertexColors() ? 0 : 2;
-    x |= this->hasDomain() ? 0 : 4;
+    x |= this->hasDomain() ? 0 : 2;
     // regular position has two options as well
-    x |= kFloat3_GrVertexAttribType == fPositions.cpuType() ? 0 : 8;
+    x |= kFloat3_GrVertexAttribType == fPositions.cpuType() ? 0 : 4;
     // local coords require 2 bits (3 choices), 00 for none, 01 for 2d, 10 for 3d
     if (this->hasLocalCoords()) {
-        x |= kFloat3_GrVertexAttribType == fLocalCoords.cpuType() ? 16 : 32;
+        x |= kFloat3_GrVertexAttribType == fLocalCoords.cpuType() ? 8 : 16;
+    }
+    // similar for colors, 00 for none, 01 for bytes, 10 for half-floats
+    if (this->hasVertexColors()) {
+        x |= kUByte4_norm_GrVertexAttribType == fColors.cpuType() ? 32 : 64;
     }
     return x;
 }
 
 void GPAttributes::emitColor(GrGLSLPrimitiveProcessor::EmitArgs& args,
-                             GrGLSLColorSpaceXformHelper* csXformHelper,
                              const char* colorVarName) const {
     using Interpolation = GrGLSLVaryingHandler::Interpolation;
-
-    if (!fColors.isInitialized()) {
-        return;
-    }
-
-    if (csXformHelper == nullptr || csXformHelper->isNoop()) {
-        args.fVaryingHandler->addPassThroughAttribute(
-                fColors, args.fOutputColor, Interpolation::kCanBeFlat);
-    } else {
-        GrGLSLVarying varying(kHalf4_GrSLType);
-        args.fVaryingHandler->addVarying(colorVarName, &varying);
-        args.fVertBuilder->codeAppendf("half4 %s = ", colorVarName);
-        args.fVertBuilder->appendColorGamutXform(fColors.name(), csXformHelper);
-        args.fVertBuilder->codeAppend(";");
-        args.fVertBuilder->codeAppendf("%s = half4(%s.rgb * %s.a, %s.a);",
-                                       varying.vsOut(), colorVarName, colorVarName, colorVarName);
-        args.fFragBuilder->codeAppendf("%s = %s;", args.fOutputColor, varying.fsIn());
+    if (fColors.isInitialized()) {
+        args.fVaryingHandler->addPassThroughAttribute(fColors, args.fOutputColor,
+                                                      Interpolation::kCanBeFlat);
     }
 }
 
diff --git a/src/gpu/ops/GrQuadPerEdgeAA.h b/src/gpu/ops/GrQuadPerEdgeAA.h
index 578e431094..e8b96a072c 100644
--- a/src/gpu/ops/GrQuadPerEdgeAA.h
+++ b/src/gpu/ops/GrQuadPerEdgeAA.h
@@ -22,128 +22,130 @@ class GrGLSLColorSpaceXformHelper;
 namespace GrQuadPerEdgeAA {
 
     enum class Domain : bool { kNo = false, kYes = true };
+    enum class ColorType { kNone, kByte, kHalf, kLast = kHalf };
+    static const int kColorTypeCount = static_cast<int>(ColorType::kLast) + 1;
 
     // Specifies the vertex configuration for an op that renders per-edge AA quads. The vertex
     // order (when enabled) is device position, color, local position, domain, aa edge equations.
     // This order matches the constructor argument order of VertexSpec and is the order that
     // GPAttributes maintains. If hasLocalCoords is false, then the local quad type can be ignored.
     struct VertexSpec {
     public:
-        VertexSpec(GrQuadType deviceQuadType, bool hasColor, GrQuadType localQuadType,
+        VertexSpec(GrQuadType deviceQuadType, ColorType colorType, GrQuadType localQuadType,
                    bool hasLocalCoords, Domain domain, GrAAType aa)
                 : fDeviceQuadType(static_cast<unsigned>(deviceQuadType))
                 , fLocalQuadType(static_cast<unsigned>(localQuadType))
                 , fHasLocalCoords(hasLocalCoords)
-                , fHasColor(hasColor)
+                , fColorType(static_cast<unsigned>(colorType))
                 , fHasDomain(static_cast<unsigned>(domain))
                 , fUsesCoverageAA(aa == GrAAType::kCoverage) { }
 
         GrQuadType deviceQuadType() const { return static_cast<GrQuadType>(fDeviceQuadType); }
         GrQuadType localQuadType() const { return static_cast<GrQuadType>(fLocalQuadType); }
         bool hasLocalCoords() const { return fHasLocalCoords; }
-        bool hasVertexColors() const { return fHasColor; }
+        ColorType colorType() const { return static_cast<ColorType>(fColorType); }
+        bool hasVertexColors() const { return ColorType::kNone != this->colorType(); }
         bool hasDomain() const { return fHasDomain; }
         bool usesCoverageAA() const { return fUsesCoverageAA; }
 
         // Will always be 2 or 3
         int deviceDimensionality() const;
         // Will always be 0 if hasLocalCoords is false, otherwise will be 2 or 3
         int localDimensionality() const;
 
     private:
         static_assert(kGrQuadTypeCount <= 4, "GrQuadType doesn't fit in 2 bits");
+        static_assert(kColorTypeCount <= 4, "Color doesn't fit in 2 bits");
 
         unsigned fDeviceQuadType: 2;
         unsigned fLocalQuadType: 2;
         unsigned fHasLocalCoords: 1;
-        unsigned fHasColor: 1;
+        unsigned fColorType : 2;
         unsigned fHasDomain: 1;
         unsigned fUsesCoverageAA: 1;
     };
 
     // Utility class that manages the attribute state necessary to render a particular batch of
     // quads. It is similar to a geometry processor but is meant to be included in a has-a
     // relationship by specialized GP's that provide further functionality on top of the per-edge AA
     // coverage.
     //
     // For performance reasons, this uses fixed names for the attribute variables; since it defines
     // the majority of attributes a GP will likely need, this shouldn't be too limiting.
     //
     // In terms of responsibilities, the actual geometry processor must still call emitTransforms(),
     // using the localCoords() attribute as the 4th argument; it must set the transform data helper
     // to use the identity matrix; it must manage the color space transform for the quad's paint
     // color; it should include getKey() in the geometry processor's key builder; and it should
     // add these attributes at construction time.
     class GPAttributes {
     public:
         using Attribute = GrPrimitiveProcessor::Attribute;
 
         GPAttributes(const VertexSpec& vertexSpec);
 
         const Attribute& positions() const { return fPositions; }
         const Attribute& colors() const { return fColors; }
         const Attribute& localCoords() const { return fLocalCoords; }
         const Attribute& domain() const { return fDomain; }
         const Attribute& edges(int i) const { return fAAEdges[i]; }
 
         bool hasVertexColors() const { return fColors.isInitialized(); }
 
         bool usesCoverageAA() const { return fAAEdges[0].isInitialized(); }
 
         bool hasLocalCoords() const { return fLocalCoords.isInitialized(); }
 
         bool hasDomain() const { return fDomain.isInitialized(); }
 
         bool needsPerspectiveInterpolation() const;
 
         const Attribute* attributes() const { return &fPositions; }
         int attributeCount() const { return 8; }
 
         uint32_t getKey() const;
 
         // Functions to be called at appropriate times in a processor's onEmitCode() block. These
         // are separated into discrete pieces so that they can be interleaved with the rest of the
         // processor's shader code as needed. The functions take char* arguments for the names of
         // variables the emitted code must declare, so that the calling GP can ensure there's no
         // naming conflicts with their own code.
 
-        void emitColor(GrGLSLPrimitiveProcessor::EmitArgs& args,
-                       GrGLSLColorSpaceXformHelper* colorSpaceXformHelper,
-                       const char* colorVarName) const;
+        void emitColor(GrGLSLPrimitiveProcessor::EmitArgs& args, const char* colorVarName) const;
 
         // localCoordName will be declared as a float2, with any domain applied after any
         // perspective division is performed.
         //
         // Note: this should only be used if the local coordinates need to be passed separately
         // from the standard coord transform process that is used by FPs.
         // FIXME: This can go in two directions from here, if GrTextureOp stops needing per-quad
         // domains it can be removed and GrTextureOp rewritten to use coord transforms. Or
         // emitTransform() in the primitive builder can be updated to have a notion of domain for
         // local coords, and all domain-needing code (blurs, filters, etc.) can switch to that magic
         void emitExplicitLocalCoords(GrGLSLPrimitiveProcessor::EmitArgs& args,
                                      const char* localCoordName, const char* domainVarName) const;
 
         void emitCoverage(GrGLSLPrimitiveProcessor::EmitArgs& args, const char* edgeDistName) const;
     private:
         Attribute fPositions;   // named "position" in SkSL
         Attribute fColors;      // named "color" in SkSL
         Attribute fLocalCoords; // named "localCoord" in SkSL
         Attribute fDomain;      // named "domain" in SkSL
         Attribute fAAEdges[4];  // named "aaEdgeX" for X = 0,1,2,3
     };
 
 
     // Fill vertices with the vertex data needed to represent the given quad. The device position,
     // local coords, vertex color, domain, and edge coefficients will be written and/or computed
     // based on the configuration in the vertex spec; if that attribute is disabled in the spec,
     // then its corresponding function argument is ignored.
     //
     // Returns the advanced pointer in vertices.
     // TODO4F: Switch GrColor to GrVertexColor
     void* Tessellate(void* vertices, const VertexSpec& spec, const GrPerspQuad& deviceQuad,
-                     const GrColor& color, const GrPerspQuad& localQuad, const SkRect& domain,
+                     const SkPMColor4f& color, const GrPerspQuad& localQuad, const SkRect& domain,
                      GrQuadAAFlags aa);
 
 } // namespace GrQuadPerEdgeAA
 
 #endif // GrQuadPerEdgeAA_DEFINED
diff --git a/src/gpu/ops/GrTextureOp.cpp b/src/gpu/ops/GrTextureOp.cpp
index 7f92a1c119..dd03f9d014 100644
--- a/src/gpu/ops/GrTextureOp.cpp
+++ b/src/gpu/ops/GrTextureOp.cpp
@@ -38,9 +38,10 @@ namespace {
 
 using Domain = GrQuadPerEdgeAA::Domain;
 using VertexSpec = GrQuadPerEdgeAA::VertexSpec;
+using ColorType = GrQuadPerEdgeAA::ColorType;
 
 /**
  * Geometry Processor that draws a texture modulated by a vertex color (though, this is meant to be
  * the same value across all vertices of a quad and uses flat interpolation when available). This is
  * used by TextureOp below.
  */
@@ -48,67 +49,60 @@ class TextureGeometryProcessor : public GrGeometryProcessor {
 public:
 
     static sk_sp<GrGeometryProcessor> Make(GrTextureType textureType, GrPixelConfig textureConfig,
                                            const GrSamplerState::Filter filter,
                                            sk_sp<GrColorSpaceXform> textureColorSpaceXform,
-                                           sk_sp<GrColorSpaceXform> paintColorSpaceXform,
                                            const VertexSpec& vertexSpec, const GrShaderCaps& caps) {
         return sk_sp<TextureGeometryProcessor>(new TextureGeometryProcessor(
-                textureType, textureConfig, filter, std::move(textureColorSpaceXform),
-                std::move(paintColorSpaceXform), vertexSpec, caps));
+                textureType, textureConfig, filter, std::move(textureColorSpaceXform), vertexSpec,
+                caps));
     }
 
     const char* name() const override { return "TextureGeometryProcessor"; }
 
     void getGLSLProcessorKey(const GrShaderCaps&, GrProcessorKeyBuilder* b) const override {
         b->add32(GrColorSpaceXform::XformKey(fTextureColorSpaceXform.get()));
-        b->add32(GrColorSpaceXform::XformKey(fPaintColorSpaceXform.get()));
         b->add32(fAttrs.getKey());
     }
 
     GrGLSLPrimitiveProcessor* createGLSLInstance(const GrShaderCaps& caps) const override {
         class GLSLProcessor : public GrGLSLGeometryProcessor {
         public:
             void setData(const GrGLSLProgramDataManager& pdman, const GrPrimitiveProcessor& proc,
                          FPCoordTransformIter&& transformIter) override {
                 const auto& textureGP = proc.cast<TextureGeometryProcessor>();
                 this->setTransformDataHelper(SkMatrix::I(), pdman, &transformIter);
                 fTextureColorSpaceXformHelper.setData(
                         pdman, textureGP.fTextureColorSpaceXform.get());
-                fPaintColorSpaceXformHelper.setData(pdman, textureGP.fPaintColorSpaceXform.get());
             }
 
         private:
             void onEmitCode(EmitArgs& args, GrGPArgs* gpArgs) override {
                 const auto& textureGP = args.fGP.cast<TextureGeometryProcessor>();
                 fTextureColorSpaceXformHelper.emitCode(
                         args.fUniformHandler, textureGP.fTextureColorSpaceXform.get());
-                fPaintColorSpaceXformHelper.emitCode(
-                        args.fUniformHandler, textureGP.fPaintColorSpaceXform.get(),
-                        kVertex_GrShaderFlag);
                 if (!textureGP.fAttrs.needsPerspectiveInterpolation()) {
                     args.fVaryingHandler->setNoPerspective();
                 }
                 args.fVaryingHandler->emitAttributes(textureGP);
                 gpArgs->fPositionVar = textureGP.fAttrs.positions().asShaderVar();
 
                 this->emitTransforms(args.fVertBuilder,
                                      args.fVaryingHandler,
                                      args.fUniformHandler,
                                      textureGP.fAttrs.localCoords().asShaderVar(),
                                      args.fFPCoordTransformHandler);
-                textureGP.fAttrs.emitColor(args, &fPaintColorSpaceXformHelper, "paintColor");
+                textureGP.fAttrs.emitColor(args, "paintColor");
                 textureGP.fAttrs.emitExplicitLocalCoords(args, "texCoord", "domain");
 
                 args.fFragBuilder->codeAppendf("%s = ", args.fOutputColor);
                 args.fFragBuilder->appendTextureLookupAndModulate(
                         args.fOutputColor, args.fTexSamplers[0], "texCoord", kFloat2_GrSLType,
                         &fTextureColorSpaceXformHelper);
                 args.fFragBuilder->codeAppend(";");
 
                 textureGP.fAttrs.emitCoverage(args, "aaDist");
             }
             GrGLSLColorSpaceXformHelper fTextureColorSpaceXformHelper;
-            GrGLSLColorSpaceXformHelper fPaintColorSpaceXformHelper;
         };
         return new GLSLProcessor;
     }
@@ -116,25 +110,22 @@ public:
 private:
     TextureGeometryProcessor(GrTextureType textureType, GrPixelConfig textureConfig,
                              GrSamplerState::Filter filter,
                              sk_sp<GrColorSpaceXform> textureColorSpaceXform,
-                             sk_sp<GrColorSpaceXform> paintColorSpaceXform,
                              const VertexSpec& vertexSpec, const GrShaderCaps& caps)
             : INHERITED(kTextureGeometryProcessor_ClassID)
             , fAttrs(vertexSpec)
             , fTextureColorSpaceXform(std::move(textureColorSpaceXform))
-            , fPaintColorSpaceXform(std::move(paintColorSpaceXform))
             , fSampler(textureType, textureConfig, filter) {
         SkASSERT(vertexSpec.hasVertexColors() && vertexSpec.localDimensionality() == 2);
         this->setTextureSamplerCnt(1);
         this->setVertexAttributes(fAttrs.attributes(), fAttrs.attributeCount());
     }
 
     const TextureSampler& onTextureSampler(int) const override { return fSampler; }
 
     GrQuadPerEdgeAA::GPAttributes fAttrs;
     sk_sp<GrColorSpaceXform> fTextureColorSpaceXform;
-    sk_sp<GrColorSpaceXform> fPaintColorSpaceXform;
     TextureSampler fSampler;
 
     typedef GrGeometryProcessor INHERITED;
 };
@@ -207,95 +198,93 @@ class TextureOp final : public GrMeshDrawOp {
 public:
     static std::unique_ptr<GrDrawOp> Make(GrContext* context,
                                           sk_sp<GrTextureProxy> proxy,
                                           GrSamplerState::Filter filter,
-                                          GrColor color,
+                                          const SkPMColor4f& color,
                                           const SkRect& srcRect,
                                           const SkRect& dstRect,
                                           GrAAType aaType,
                                           GrQuadAAFlags aaFlags,
                                           SkCanvas::SrcRectConstraint constraint,
                                           const SkMatrix& viewMatrix,
-                                          sk_sp<GrColorSpaceXform> textureColorSpaceXform,
-                                          sk_sp<GrColorSpaceXform> paintColorSpaceXform) {
+                                          sk_sp<GrColorSpaceXform> textureColorSpaceXform) {
         GrOpMemoryPool* pool = context->contextPriv().opMemoryPool();
 
         return pool->allocate<TextureOp>(
                 std::move(proxy), filter, color, srcRect, dstRect, aaType, aaFlags, constraint,
-                viewMatrix, std::move(textureColorSpaceXform), std::move(paintColorSpaceXform));
+                viewMatrix, std::move(textureColorSpaceXform));
     }
     static std::unique_ptr<GrDrawOp> Make(GrContext* context,
                                           const GrRenderTargetContext::TextureSetEntry set[],
-                                          int cnt, GrSamplerState::Filter filter, GrColor color,
-                                          GrAAType aaType, const SkMatrix& viewMatrix,
-                                          sk_sp<GrColorSpaceXform> textureColorSpaceXform,
-                                          sk_sp<GrColorSpaceXform> paintColorSpaceXform) {
+                                          int cnt, GrSamplerState::Filter filter,
+                                          const SkPMColor4f& color, GrAAType aaType,
+                                          const SkMatrix& viewMatrix,
+                                          sk_sp<GrColorSpaceXform> textureColorSpaceXform) {
         size_t size = sizeof(TextureOp) + sizeof(Proxy) * (cnt - 1);
         GrOpMemoryPool* pool = context->contextPriv().opMemoryPool();
         void* mem = pool->allocate(size);
         return std::unique_ptr<GrDrawOp>(new (mem) TextureOp(
-                set, cnt, filter, color, aaType, viewMatrix, std::move(textureColorSpaceXform),
-                std::move(paintColorSpaceXform)));
+                set, cnt, filter, color, aaType, viewMatrix, std::move(textureColorSpaceXform)));
     }
 
     ~TextureOp() override {
         for (unsigned p = 0; p < fProxyCnt; ++p) {
             if (fFinalized) {
                 fProxies[p].fProxy->completedRead();
             } else {
                 fProxies[p].fProxy->unref();
             }
         }
     }
 
     const char* name() const override { return "TextureOp"; }
 
     void visitProxies(const VisitProxyFunc& func, VisitorType visitor) const override {
         if (visitor == VisitorType::kAllocatorGather && fCanSkipAllocatorGather) {
             return;
         }
         for (unsigned p = 0; p < fProxyCnt; ++p) {
             func(fProxies[p].fProxy);
         }
     }
 
 #ifdef SK_DEBUG
     SkString dumpInfo() const override {
         SkString str;
         str.appendf("# draws: %d\n", fQuads.count());
         int q = 0;
         for (unsigned p = 0; p < fProxyCnt; ++p) {
             str.appendf("Proxy ID: %d, Filter: %d\n", fProxies[p].fProxy->uniqueID().asUInt(),
                         static_cast<int>(fFilter));
             for (int i = 0; i < fProxies[p].fQuadCnt; ++i, ++q) {
                 const Quad& quad = fQuads[q];
                 str.appendf(
                         "%d: Color: 0x%08x, TexRect [L: %.2f, T: %.2f, R: %.2f, B: %.2f] "
                         "Quad [(%.2f, %.2f), (%.2f, %.2f), (%.2f, %.2f), (%.2f, %.2f)]\n",
-                        i, quad.color(), quad.srcRect().fLeft, quad.srcRect().fTop,
+                        i, quad.color().toBytes_RGBA(), quad.srcRect().fLeft, quad.srcRect().fTop,
                         quad.srcRect().fRight, quad.srcRect().fBottom, quad.quad().point(0).fX,
                         quad.quad().point(0).fY, quad.quad().point(1).fX, quad.quad().point(1).fY,
                         quad.quad().point(2).fX, quad.quad().point(2).fY, quad.quad().point(3).fX,
                         quad.quad().point(3).fY);
             }
         }
         str += INHERITED::dumpInfo();
         return str;
     }
 #endif
 
     RequiresDstTexture finalize(const GrCaps& caps, const GrAppliedClip* clip) override {
         SkASSERT(!fFinalized);
         fFinalized = true;
         for (unsigned p = 0; p < fProxyCnt; ++p) {
             fProxies[p].fProxy->addPendingRead();
             fProxies[p].fProxy->unref();
         }
         return RequiresDstTexture::kNo;
     }
 
     FixedFunctionFlags fixedFunctionFlags() const override {
         return this->aaType() == GrAAType::kMSAA ? FixedFunctionFlags::kUsesHWAA
                                                  : FixedFunctionFlags::kNone;
     }
 
     DEFINE_OP_CLASS_ID
@@ -303,334 +292,331 @@ public:
 private:
     friend class ::GrOpMemoryPool;
 
-    TextureOp(sk_sp<GrTextureProxy> proxy, GrSamplerState::Filter filter, GrColor color,
+    TextureOp(sk_sp<GrTextureProxy> proxy, GrSamplerState::Filter filter, const SkPMColor4f& color,
               const SkRect& srcRect, const SkRect& dstRect, GrAAType aaType, GrQuadAAFlags aaFlags,
               SkCanvas::SrcRectConstraint constraint, const SkMatrix& viewMatrix,
-              sk_sp<GrColorSpaceXform> textureColorSpaceXform,
-              sk_sp<GrColorSpaceXform> paintColorSpaceXform)
+              sk_sp<GrColorSpaceXform> textureColorSpaceXform)
             : INHERITED(ClassID())
             , fTextureColorSpaceXform(std::move(textureColorSpaceXform))
-            , fPaintColorSpaceXform(std::move(paintColorSpaceXform))
             , fFilter(static_cast<unsigned>(filter))
             , fFinalized(0) {
         GrQuadType quadType = GrQuadTypeForTransformedRect(viewMatrix);
         auto quad = GrPerspQuad(dstRect, viewMatrix);
 
         // Clean up disparities between the overall aa type and edge configuration and apply
         // optimizations based on the rect and matrix when appropriate
         GrResolveAATypeForQuad(aaType, aaFlags, quad, quadType, &aaType, &aaFlags);
         fAAType = static_cast<unsigned>(aaType);
 
         fPerspective = static_cast<unsigned>(quadType == GrQuadType::kPerspective);
         // We expect our caller to have already caught this optimization.
         SkASSERT(!srcRect.contains(proxy->getWorstCaseBoundsRect()) ||
                  constraint == SkCanvas::kFast_SrcRectConstraint);
         if (quadType == GrQuadType::kRect) {
             // Disable filtering if possible (note AA optimizations for rects are automatically
             // handled above in GrResolveAATypeForQuad).
             if (this->filter() != GrSamplerState::Filter::kNearest &&
                 !filter_has_effect_for_rect_stays_rect(quad, srcRect)) {
                 fFilter = static_cast<unsigned>(GrSamplerState::Filter::kNearest);
             }
         }
         // We may have had a strict constraint with nearest filter solely due to possible AA bloat.
         // If we don't have (or determined we don't need) coverage AA then we can skip using a
         // domain.
         if (constraint == SkCanvas::kStrict_SrcRectConstraint &&
             this->filter() == GrSamplerState::Filter::kNearest &&
             aaType != GrAAType::kCoverage) {
             constraint = SkCanvas::kFast_SrcRectConstraint;
         }
         const auto& draw = fQuads.emplace_back(srcRect, quad, aaFlags, constraint, color);
         fProxyCnt = 1;
         fProxies[0] = {proxy.release(), 1};
         auto bounds = quad.bounds();
         this->setBounds(bounds, HasAABloat(aaType == GrAAType::kCoverage), IsZeroArea::kNo);
         fDomain = static_cast<unsigned>(draw.domain());
+        fWideColor = !SkPMColor4fFitsInBytes(color);
         fCanSkipAllocatorGather =
                 static_cast<unsigned>(fProxies[0].fProxy->canSkipResourceAllocator());
     }
     TextureOp(const GrRenderTargetContext::TextureSetEntry set[], int cnt,
-              GrSamplerState::Filter filter, GrColor color, GrAAType aaType,
-              const SkMatrix& viewMatrix, sk_sp<GrColorSpaceXform> textureColorSpaceXform,
-              sk_sp<GrColorSpaceXform> paintColorSpaceXform)
+              GrSamplerState::Filter filter, const SkPMColor4f& color, GrAAType aaType,
+              const SkMatrix& viewMatrix, sk_sp<GrColorSpaceXform> textureColorSpaceXform)
             : INHERITED(ClassID())
             , fTextureColorSpaceXform(std::move(textureColorSpaceXform))
-            , fPaintColorSpaceXform(std::move(paintColorSpaceXform))
             , fFilter(static_cast<unsigned>(filter))
             , fFinalized(0) {
         fQuads.reserve(cnt);
         fProxyCnt = SkToUInt(cnt);
         SkRect bounds = SkRectPriv::MakeLargestInverted();
         GrAAType overallAAType = GrAAType::kNone; // aa type maximally compatible with all dst rects
         bool mustFilter = false;
         fCanSkipAllocatorGather = static_cast<unsigned>(true);
         // All dst rects are transformed by the same view matrix, so their quad types are identical
         GrQuadType quadType = GrQuadTypeForTransformedRect(viewMatrix);
         for (unsigned p = 0; p < fProxyCnt; ++p) {
             fProxies[p].fProxy = SkRef(set[p].fProxy.get());
             fProxies[p].fQuadCnt = 1;
             SkASSERT(fProxies[p].fProxy->textureType() == fProxies[0].fProxy->textureType());
             SkASSERT(fProxies[p].fProxy->config() == fProxies[0].fProxy->config());
             if (!fProxies[p].fProxy->canSkipResourceAllocator()) {
                 fCanSkipAllocatorGather = static_cast<unsigned>(false);
             }
             auto quad = GrPerspQuad(set[p].fDstRect, viewMatrix);
             bounds.joinPossiblyEmptyRect(quad.bounds());
             GrQuadAAFlags aaFlags;
             // Don't update the overall aaType, might be inappropriate for some of the quads
             GrAAType aaForQuad;
             GrResolveAATypeForQuad(aaType, set[p].fAAFlags, quad, quadType, &aaForQuad, &aaFlags);
             // Resolve sets aaForQuad to aaType or None, there is never a change between aa methods
             SkASSERT(aaForQuad == GrAAType::kNone || aaForQuad == aaType);
             if (overallAAType == GrAAType::kNone && aaForQuad != GrAAType::kNone) {
                 overallAAType = aaType;
             }
             if (!mustFilter && this->filter() != GrSamplerState::Filter::kNearest) {
                 mustFilter = quadType != GrQuadType::kRect ||
                              filter_has_effect_for_rect_stays_rect(quad, set[p].fSrcRect);
             }
             fQuads.emplace_back(set[p].fSrcRect, quad, aaFlags, SkCanvas::kFast_SrcRectConstraint,
                                 color);
         }
         fAAType = static_cast<unsigned>(overallAAType);
         if (!mustFilter) {
             fFilter = static_cast<unsigned>(GrSamplerState::Filter::kNearest);
         }
         this->setBounds(bounds, HasAABloat(this->aaType() == GrAAType::kCoverage), IsZeroArea::kNo);
         fPerspective = static_cast<unsigned>(viewMatrix.hasPerspective());
         fDomain = static_cast<unsigned>(false);
+        fWideColor = !SkPMColor4fFitsInBytes(color);
     }
 
     void tess(void* v, const VertexSpec& spec, const GrTextureProxy* proxy,
               int start, int cnt) const {
         TRACE_EVENT0("skia", TRACE_FUNC);
         auto origin = proxy->origin();
         const auto* texture = proxy->peekTexture();
         float iw = 1.f / texture->width();
         float ih = 1.f / texture->height();
 
         for (int i = start; i < start + cnt; ++i) {
             const auto q = fQuads[i];
             GrPerspQuad srcQuad = compute_src_quad(origin, q.srcRect(), iw, ih);
             SkRect domain = compute_domain(q.domain(), this->filter(), origin, q.srcRect(), iw, ih);
             v = GrQuadPerEdgeAA::Tessellate(v, spec, q.quad(), q.color(), srcQuad, domain,
                                             q.aaFlags());
         }
     }
 
     void onPrepareDraws(Target* target) override {
         TRACE_EVENT0("skia", TRACE_FUNC);
         bool hasPerspective = false;
         Domain domain = Domain::kNo;
+        bool wideColor = false;
         int numProxies = 0;
         int numTotalQuads = 0;
         auto textureType = fProxies[0].fProxy->textureType();
         auto config = fProxies[0].fProxy->config();
         GrAAType aaType = this->aaType();
         for (const auto& op : ChainRange<TextureOp>(this)) {
             hasPerspective |= op.fPerspective;
             if (op.fDomain) {
                 domain = Domain::kYes;
             }
+            wideColor |= op.fWideColor;
             numProxies += op.fProxyCnt;
             for (unsigned p = 0; p < op.fProxyCnt; ++p) {
                 numTotalQuads += op.fProxies[p].fQuadCnt;
                 auto* proxy = op.fProxies[p].fProxy;
                 if (!proxy->instantiate(target->resourceProvider())) {
                     return;
                 }
                 SkASSERT(proxy->config() == config);
                 SkASSERT(proxy->textureType() == textureType);
             }
             if (op.aaType() == GrAAType::kCoverage) {
                 SkASSERT(aaType == GrAAType::kCoverage || aaType == GrAAType::kNone);
                 aaType = GrAAType::kCoverage;
             }
         }
 
         VertexSpec vertexSpec(hasPerspective ? GrQuadType::kPerspective : GrQuadType::kStandard,
-                              /* hasColor */ true, GrQuadType::kRect, /* hasLocal */ true,
-                              domain, aaType);
+                              wideColor ? ColorType::kHalf : ColorType::kByte, GrQuadType::kRect,
+                              /* hasLocal */ true, domain, aaType);
 
         sk_sp<GrGeometryProcessor> gp = TextureGeometryProcessor::Make(
                 textureType, config, this->filter(), std::move(fTextureColorSpaceXform),
-                std::move(fPaintColorSpaceXform), vertexSpec, *target->caps().shaderCaps());
+                vertexSpec, *target->caps().shaderCaps());
         GrPipeline::InitArgs args;
         args.fProxy = target->proxy();
         args.fCaps = &target->caps();
         args.fResourceProvider = target->resourceProvider();
         args.fFlags = 0;
         if (aaType == GrAAType::kMSAA) {
             args.fFlags |= GrPipeline::kHWAntialias_Flag;
         }
 
         auto clip = target->detachAppliedClip();
         // We'll use a dynamic state array for the GP textures when there are multiple ops.
         // Otherwise, we use fixed dynamic state to specify the single op's proxy.
         GrPipeline::DynamicStateArrays* dynamicStateArrays = nullptr;
         GrPipeline::FixedDynamicState* fixedDynamicState;
         if (numProxies > 1) {
             dynamicStateArrays = target->allocDynamicStateArrays(numProxies, 1, false);
             fixedDynamicState = target->allocFixedDynamicState(clip.scissorState().rect(), 0);
         } else {
             fixedDynamicState = target->allocFixedDynamicState(clip.scissorState().rect(), 1);
             fixedDynamicState->fPrimitiveProcessorTextures[0] = fProxies[0].fProxy;
         }
         const auto* pipeline =
                 target->allocPipeline(args, GrProcessorSet::MakeEmptySet(), std::move(clip));
 
         size_t vertexSize = gp->vertexStride();
 
         GrMesh* meshes = target->allocMeshes(numProxies);
         const GrBuffer* vbuffer;
         int vertexOffsetInBuffer = 0;
         int numQuadVerticesLeft = numTotalQuads * 4;
         int numAllocatedVertices = 0;
         void* vdata = nullptr;
 
         int m = 0;
         for (const auto& op : ChainRange<TextureOp>(this)) {
             int q = 0;
             for (unsigned p = 0; p < op.fProxyCnt; ++p) {
                 int quadCnt = op.fProxies[p].fQuadCnt;
                 auto* proxy = op.fProxies[p].fProxy;
                 int meshVertexCnt = quadCnt * 4;
                 if (numAllocatedVertices < meshVertexCnt) {
                     vdata = target->makeVertexSpaceAtLeast(
                             vertexSize, meshVertexCnt, numQuadVerticesLeft, &vbuffer,
                             &vertexOffsetInBuffer, &numAllocatedVertices);
                     SkASSERT(numAllocatedVertices <= numQuadVerticesLeft);
                     if (!vdata) {
                         SkDebugf("Could not allocate vertices\n");
                         return;
                     }
                 }
                 SkASSERT(numAllocatedVertices >= meshVertexCnt);
 
                 op.tess(vdata, vertexSpec, proxy, q, quadCnt);
 
                 if (quadCnt > 1) {
                     meshes[m].setPrimitiveType(GrPrimitiveType::kTriangles);
                     sk_sp<const GrBuffer> ibuffer =
                             target->resourceProvider()->refQuadIndexBuffer();
                     if (!ibuffer) {
                         SkDebugf("Could not allocate quad indices\n");
                         return;
                     }
                     meshes[m].setIndexedPatterned(ibuffer.get(), 6, 4, quadCnt,
                                                   GrResourceProvider::QuadCountOfQuadBuffer());
                 } else {
                     meshes[m].setPrimitiveType(GrPrimitiveType::kTriangleStrip);
                     meshes[m].setNonIndexedNonInstanced(4);
                 }
                 meshes[m].setVertexData(vbuffer, vertexOffsetInBuffer);
                 if (dynamicStateArrays) {
                     dynamicStateArrays->fPrimitiveProcessorTextures[m] = proxy;
                 }
                 ++m;
                 numAllocatedVertices -= meshVertexCnt;
                 numQuadVerticesLeft -= meshVertexCnt;
                 vertexOffsetInBuffer += meshVertexCnt;
                 vdata = reinterpret_cast<char*>(vdata) + vertexSize * meshVertexCnt;
                 q += quadCnt;
             }
         }
         SkASSERT(!numQuadVerticesLeft);
         SkASSERT(!numAllocatedVertices);
         target->draw(std::move(gp), pipeline, fixedDynamicState, dynamicStateArrays, meshes,
                      numProxies);
     }
 
     CombineResult onCombineIfPossible(GrOp* t, const GrCaps& caps) override {
         TRACE_EVENT0("skia", TRACE_FUNC);
         const auto* that = t->cast<TextureOp>();
         if (!GrColorSpaceXform::Equals(fTextureColorSpaceXform.get(),
                                        that->fTextureColorSpaceXform.get())) {
             return CombineResult::kCannotCombine;
         }
-        if (!GrColorSpaceXform::Equals(fPaintColorSpaceXform.get(),
-                                       that->fPaintColorSpaceXform.get())) {
-            return CombineResult::kCannotCombine;
-        }
         bool upgradeToCoverageAAOnMerge = false;
         if (this->aaType() != that->aaType()) {
             if (!((this->aaType() == GrAAType::kCoverage && that->aaType() == GrAAType::kNone) ||
                   (that->aaType() == GrAAType::kCoverage && this->aaType() == GrAAType::kNone))) {
                 return CombineResult::kCannotCombine;
             }
             upgradeToCoverageAAOnMerge = true;
         }
         if (fFilter != that->fFilter) {
             return CombineResult::kCannotCombine;
         }
         auto thisProxy = fProxies[0].fProxy;
         auto thatProxy = that->fProxies[0].fProxy;
         if (fProxyCnt > 1 || that->fProxyCnt > 1 ||
             thisProxy->uniqueID() != thatProxy->uniqueID()) {
             // We can't merge across different proxies. Check if 'this' can be chained with 'that'.
             if (thisProxy->config() == thatProxy->config() &&
                 thisProxy->textureType() == thatProxy->textureType() &&
                 caps.dynamicStateArrayGeometryProcessorTextureSupport()) {
                 return CombineResult::kMayChain;
             }
             return CombineResult::kCannotCombine;
         }
         fProxies[0].fQuadCnt += that->fQuads.count();
         fQuads.push_back_n(that->fQuads.count(), that->fQuads.begin());
         fPerspective |= that->fPerspective;
         fDomain |= that->fDomain;
+        fWideColor |= that->fWideColor;
         if (upgradeToCoverageAAOnMerge) {
             fAAType = static_cast<unsigned>(GrAAType::kCoverage);
         }
         return CombineResult::kMerged;
     }
 
     GrAAType aaType() const { return static_cast<GrAAType>(fAAType); }
     GrSamplerState::Filter filter() const { return static_cast<GrSamplerState::Filter>(fFilter); }
 
     class Quad {
     public:
         Quad(const SkRect& srcRect, const GrPerspQuad& quad, GrQuadAAFlags aaFlags,
-             SkCanvas::SrcRectConstraint constraint, GrColor color)
+             SkCanvas::SrcRectConstraint constraint, const SkPMColor4f& color)
                 : fSrcRect(srcRect)
                 , fQuad(quad)
                 , fColor(color)
                 , fHasDomain(constraint == SkCanvas::kStrict_SrcRectConstraint)
                 , fAAFlags(static_cast<unsigned>(aaFlags)) {
             SkASSERT(fAAFlags == static_cast<unsigned>(aaFlags));
         }
         const GrPerspQuad& quad() const { return fQuad; }
         const SkRect& srcRect() const { return fSrcRect; }
-        GrColor color() const { return fColor; }
+        SkPMColor4f color() const { return fColor; }
         Domain domain() const { return Domain(fHasDomain); }
         GrQuadAAFlags aaFlags() const { return static_cast<GrQuadAAFlags>(fAAFlags); }
 
     private:
         SkRect fSrcRect;
         GrPerspQuad fQuad;
-        GrColor fColor;
+        SkPMColor4f fColor;
         unsigned fHasDomain : 1;
         unsigned fAAFlags : 4;
     };
     struct Proxy {
         GrTextureProxy* fProxy;
         int fQuadCnt;
     };
     SkSTArray<1, Quad, true> fQuads;
     sk_sp<GrColorSpaceXform> fTextureColorSpaceXform;
-    sk_sp<GrColorSpaceXform> fPaintColorSpaceXform;
     unsigned fFilter : 2;
     unsigned fAAType : 2;
     unsigned fPerspective : 1;
     unsigned fDomain : 1;
+    unsigned fWideColor : 1;
     // Used to track whether fProxy is ref'ed or has a pending IO after finalize() is called.
     unsigned fFinalized : 1;
     unsigned fCanSkipAllocatorGather : 1;
     unsigned fProxyCnt : 32 - 8;
     Proxy fProxies[1];
 
     typedef GrMeshDrawOp INHERITED;
 };
 
 }  // anonymous namespace
@@ -640,36 +626,33 @@ namespace GrTextureOp {
 std::unique_ptr<GrDrawOp> Make(GrContext* context,
                                sk_sp<GrTextureProxy> proxy,
                                GrSamplerState::Filter filter,
-                               GrColor color,
+                               const SkPMColor4f& color,
                                const SkRect& srcRect,
                                const SkRect& dstRect,
                                GrAAType aaType,
                                GrQuadAAFlags aaFlags,
                                SkCanvas::SrcRectConstraint constraint,
                                const SkMatrix& viewMatrix,
-                               sk_sp<GrColorSpaceXform> textureColorSpaceXform,
-                               sk_sp<GrColorSpaceXform> paintColorSpaceXform) {
+                               sk_sp<GrColorSpaceXform> textureColorSpaceXform) {
     return TextureOp::Make(context, std::move(proxy), filter, color, srcRect, dstRect, aaType,
-                           aaFlags, constraint, viewMatrix, std::move(textureColorSpaceXform),
-                           std::move(paintColorSpaceXform));
+                           aaFlags, constraint, viewMatrix, std::move(textureColorSpaceXform));
 }
 
 std::unique_ptr<GrDrawOp> Make(GrContext* context,
                                const GrRenderTargetContext::TextureSetEntry set[],
                                int cnt,
                                GrSamplerState::Filter filter,
-                               GrColor color,
+                               const SkPMColor4f& color,
                                GrAAType aaType,
                                const SkMatrix& viewMatrix,
-                               sk_sp<GrColorSpaceXform> textureColorSpaceXform,
-                               sk_sp<GrColorSpaceXform> paintColorSpaceXform) {
+                               sk_sp<GrColorSpaceXform> textureColorSpaceXform) {
     return TextureOp::Make(context, set, cnt, filter, color, aaType, viewMatrix,
-                           std::move(textureColorSpaceXform), std::move(paintColorSpaceXform));
+                           std::move(textureColorSpaceXform));
 }
 
 }  // namespace GrTextureOp
 
 #if GR_TEST_UTILS
 #include "GrContext.h"
 #include "GrContextPriv.h"
 #include "GrProxyProvider.h"
@@ -677,50 +660,48 @@ std::unique_ptr<GrDrawOp> Make(GrContext* context,
 GR_DRAW_OP_TEST_DEFINE(TextureOp) {
     GrSurfaceDesc desc;
     desc.fConfig = kRGBA_8888_GrPixelConfig;
     desc.fHeight = random->nextULessThan(90) + 10;
     desc.fWidth = random->nextULessThan(90) + 10;
     auto origin = random->nextBool() ? kTopLeft_GrSurfaceOrigin : kBottomLeft_GrSurfaceOrigin;
     GrMipMapped mipMapped = random->nextBool() ? GrMipMapped::kYes : GrMipMapped::kNo;
     SkBackingFit fit = SkBackingFit::kExact;
     if (mipMapped == GrMipMapped::kNo) {
         fit = random->nextBool() ? SkBackingFit::kApprox : SkBackingFit::kExact;
     }
 
     GrProxyProvider* proxyProvider = context->contextPriv().proxyProvider();
     sk_sp<GrTextureProxy> proxy = proxyProvider->createProxy(desc, origin, mipMapped, fit,
                                                              SkBudgeted::kNo,
                                                              GrInternalSurfaceFlags::kNone);
 
     SkRect rect = GrTest::TestRect(random);
     SkRect srcRect;
     srcRect.fLeft = random->nextRangeScalar(0.f, proxy->width() / 2.f);
     srcRect.fRight = random->nextRangeScalar(0.f, proxy->width()) + proxy->width() / 2.f;
     srcRect.fTop = random->nextRangeScalar(0.f, proxy->height() / 2.f);
     srcRect.fBottom = random->nextRangeScalar(0.f, proxy->height()) + proxy->height() / 2.f;
     SkMatrix viewMatrix = GrTest::TestMatrixPreservesRightAngles(random);
-    GrColor color = SkColorToPremulGrColor(random->nextU());
+    SkPMColor4f color = SkPMColor4f::FromBytes_RGBA(SkColorToPremulGrColor(random->nextU()));
     GrSamplerState::Filter filter = (GrSamplerState::Filter)random->nextULessThan(
             static_cast<uint32_t>(GrSamplerState::Filter::kMipMap) + 1);
     while (mipMapped == GrMipMapped::kNo && filter == GrSamplerState::Filter::kMipMap) {
         filter = (GrSamplerState::Filter)random->nextULessThan(
                 static_cast<uint32_t>(GrSamplerState::Filter::kMipMap) + 1);
     }
     auto texXform = GrTest::TestColorXform(random);
-    auto paintXform = GrTest::TestColorXform(random);
     GrAAType aaType = GrAAType::kNone;
     if (random->nextBool()) {
         aaType = (fsaaType == GrFSAAType::kUnifiedMSAA) ? GrAAType::kMSAA : GrAAType::kCoverage;
     }
     GrQuadAAFlags aaFlags = GrQuadAAFlags::kNone;
     aaFlags |= random->nextBool() ? GrQuadAAFlags::kLeft : GrQuadAAFlags::kNone;
     aaFlags |= random->nextBool() ? GrQuadAAFlags::kTop : GrQuadAAFlags::kNone;
     aaFlags |= random->nextBool() ? GrQuadAAFlags::kRight : GrQuadAAFlags::kNone;
     aaFlags |= random->nextBool() ? GrQuadAAFlags::kBottom : GrQuadAAFlags::kNone;
     auto constraint = random->nextBool() ? SkCanvas::kStrict_SrcRectConstraint
                                          : SkCanvas::kFast_SrcRectConstraint;
     return GrTextureOp::Make(context, std::move(proxy), filter, color, srcRect, rect, aaType,
-                             aaFlags, constraint, viewMatrix, std::move(texXform),
-                             std::move(paintXform));
+                             aaFlags, constraint, viewMatrix, std::move(texXform));
 }
 
 #endif
diff --git a/src/gpu/ops/GrTextureOp.h b/src/gpu/ops/GrTextureOp.h
index 2cf263b9c1..69cb2a7e09 100644
--- a/src/gpu/ops/GrTextureOp.h
+++ b/src/gpu/ops/GrTextureOp.h
@@ -23,30 +23,28 @@ namespace GrTextureOp {
 /**
  * Creates an op that draws a sub-rectangle of a texture. The passed color is modulated by the
  * texture's color. 'srcRect' specifies the rectangle of the texture to draw. 'dstRect' specifies
  * the rectangle to draw in local coords which will be transformed by 'viewMatrix' to be in device
  * space. 'viewMatrix' must be affine. If GrAAType is kCoverage then AA is applied to the edges
  * indicated by GrQuadAAFlags. Otherwise, GrQuadAAFlags is ignored.
  */
 std::unique_ptr<GrDrawOp> Make(GrContext*,
                                sk_sp<GrTextureProxy>,
                                GrSamplerState::Filter,
-                               GrColor,
+                               const SkPMColor4f&,
                                const SkRect& srcRect,
                                const SkRect& dstRect,
                                GrAAType,
                                GrQuadAAFlags,
                                SkCanvas::SrcRectConstraint,
                                const SkMatrix& viewMatrix,
-                               sk_sp<GrColorSpaceXform> textureXform,
-                               sk_sp<GrColorSpaceXform> paintXform);
+                               sk_sp<GrColorSpaceXform> textureXform);
 
 std::unique_ptr<GrDrawOp> Make(GrContext*,
                                const GrRenderTargetContext::TextureSetEntry[],
                                int cnt,
                                GrSamplerState::Filter,
-                               GrColor,
+                               const SkPMColor4f&,
                                GrAAType,
                                const SkMatrix& viewMatrix,
-                               sk_sp<GrColorSpaceXform> textureXform,
-                               sk_sp<GrColorSpaceXform> paintXform);
+                               sk_sp<GrColorSpaceXform> textureXform);
 }
