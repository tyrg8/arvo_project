commit 46aa7a548cc3245e8b27f5df548f6f2f77790518
Merge: 8abacebad 340d80073
Author: Kim Kulling <kimkulling@users.noreply.github.com>
Date:   Fri Jul 29 21:20:07 2022 +0200

    Merge pull request #4632 from enginmanap/master
    
    Fix warnings that are causing build fails with specific build flags

diff --git a/CMakeLists.txt b/CMakeLists.txt
index a4f711528..8a56f2250 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -289,21 +289,25 @@ ELSEIF (CMAKE_CXX_COMPILER_ID MATCHES "Clang" )
   IF(NOT ASSIMP_HUNTER_ENABLED)
     SET(CMAKE_CXX_STANDARD 11)
     SET(CMAKE_POSITION_INDEPENDENT_CODE ON)
   ENDIF()
   SET(CMAKE_CXX_FLAGS "-fvisibility=hidden -fno-strict-aliasing -Wall -Wno-long-long ${CMAKE_CXX_FLAGS}" )
   SET(CMAKE_C_FLAGS "-fno-strict-aliasing ${CMAKE_C_FLAGS}")
 ELSEIF( MINGW )
   IF (CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.0)
     message(FATAL_ERROR "MinGW is too old to be supported. Please update MinGW and try again.")
   ELSEIF(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 7.3)
     message(WARNING "MinGW is old, if you experience errors, update MinGW.")
   ENDIF()
   IF(NOT ASSIMP_HUNTER_ENABLED)
     SET(CMAKE_CXX_FLAGS "-std=gnu++11 ${CMAKE_CXX_FLAGS}")
     SET(CMAKE_C_FLAGS "-fPIC ${CMAKE_C_FLAGS}")
   ENDIF()
-  SET(CMAKE_CXX_FLAGS "-fvisibility=hidden -fno-strict-aliasing -Wall -Wno-long-long -Wa,-mbig-obj -O3 ${CMAKE_CXX_FLAGS}")
-  SET(CMAKE_C_FLAGS "-fno-strict-aliasing ${CMAKE_C_FLAGS}")
+    IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
+      SET(CMAKE_CXX_FLAGS "-fvisibility=hidden -fno-strict-aliasing -Wall -Wno-long-long -Wa,-mbig-obj -g ${CMAKE_CXX_FLAGS}")
+    ELSE()
+      SET(CMAKE_CXX_FLAGS "-fvisibility=hidden -fno-strict-aliasing -Wall -Wno-long-long -Wa,-mbig-obj -O3 ${CMAKE_CXX_FLAGS}")
+    ENDIF()
+    SET(CMAKE_C_FLAGS "-fno-strict-aliasing ${CMAKE_C_FLAGS}")
 ENDIF()
 
 IF ( IOS AND NOT ASSIMP_HUNTER_ENABLED)
diff --git a/code/AssetLib/3DS/3DSConverter.cpp b/code/AssetLib/3DS/3DSConverter.cpp
index 5a01429e4..2421d5460 100644
--- a/code/AssetLib/3DS/3DSConverter.cpp
+++ b/code/AssetLib/3DS/3DSConverter.cpp
@@ -198,129 +198,129 @@ void CopyTexture(aiMaterial &mat, D3DS::Texture &texture, aiTextureType type) {
 // ------------------------------------------------------------------------------------------------
 // Convert a 3DS material to an aiMaterial
 void Discreet3DSImporter::ConvertMaterial(D3DS::Material &oldMat,
         aiMaterial &mat) {
     // NOTE: Pass the background image to the viewer by bypassing the
     // material system. This is an evil hack, never do it again!
     if (0 != mBackgroundImage.length() && bHasBG) {
         aiString tex;
         tex.Set(mBackgroundImage);
         mat.AddProperty(&tex, AI_MATKEY_GLOBAL_BACKGROUND_IMAGE);
 
         // Be sure this is only done for the first material
         mBackgroundImage = std::string();
     }
 
     // At first add the base ambient color of the scene to the material
     oldMat.mAmbient.r += mClrAmbient.r;
     oldMat.mAmbient.g += mClrAmbient.g;
     oldMat.mAmbient.b += mClrAmbient.b;
 
     aiString name;
     name.Set(oldMat.mName);
     mat.AddProperty(&name, AI_MATKEY_NAME);
 
     // Material colors
     mat.AddProperty(&oldMat.mAmbient, 1, AI_MATKEY_COLOR_AMBIENT);
     mat.AddProperty(&oldMat.mDiffuse, 1, AI_MATKEY_COLOR_DIFFUSE);
     mat.AddProperty(&oldMat.mSpecular, 1, AI_MATKEY_COLOR_SPECULAR);
     mat.AddProperty(&oldMat.mEmissive, 1, AI_MATKEY_COLOR_EMISSIVE);
 
     // Phong shininess and shininess strength
     if (D3DS::Discreet3DS::Phong == oldMat.mShading ||
             D3DS::Discreet3DS::Metal == oldMat.mShading) {
         if (!oldMat.mSpecularExponent || !oldMat.mShininessStrength) {
             oldMat.mShading = D3DS::Discreet3DS::Gouraud;
         } else {
             mat.AddProperty(&oldMat.mSpecularExponent, 1, AI_MATKEY_SHININESS);
             mat.AddProperty(&oldMat.mShininessStrength, 1, AI_MATKEY_SHININESS_STRENGTH);
         }
     }
 
     // Opacity
     mat.AddProperty<ai_real>(&oldMat.mTransparency, 1, AI_MATKEY_OPACITY);
 
     // Bump height scaling
     mat.AddProperty<ai_real>(&oldMat.mBumpHeight, 1, AI_MATKEY_BUMPSCALING);
 
     // Two sided rendering?
     if (oldMat.mTwoSided) {
         int i = 1;
         mat.AddProperty<int>(&i, 1, AI_MATKEY_TWOSIDED);
     }
 
     // Shading mode
     aiShadingMode eShading = aiShadingMode_NoShading;
     switch (oldMat.mShading) {
     case D3DS::Discreet3DS::Flat:
         eShading = aiShadingMode_Flat;
         break;
 
     // I don't know what "Wire" shading should be,
     // assume it is simple lambertian diffuse shading
     case D3DS::Discreet3DS::Wire: {
         // Set the wireframe flag
         unsigned int iWire = 1;
         mat.AddProperty<int>((int *)&iWire, 1, AI_MATKEY_ENABLE_WIREFRAME);
     }
-
+// fallthrough
     case D3DS::Discreet3DS::Gouraud:
         eShading = aiShadingMode_Gouraud;
         break;
 
     // assume cook-torrance shading for metals.
     case D3DS::Discreet3DS::Phong:
         eShading = aiShadingMode_Phong;
         break;
 
     case D3DS::Discreet3DS::Metal:
         eShading = aiShadingMode_CookTorrance;
         break;
 
         // FIX to workaround a warning with GCC 4 who complained
         // about a missing case Blinn: here - Blinn isn't a valid
         // value in the 3DS Loader, it is just needed for ASE
     case D3DS::Discreet3DS::Blinn:
         eShading = aiShadingMode_Blinn;
         break;
     }
     int eShading_ = static_cast<int>(eShading);
     mat.AddProperty<int>(&eShading_, 1, AI_MATKEY_SHADING_MODEL);
 
     // DIFFUSE texture
     if (oldMat.sTexDiffuse.mMapName.length() > 0)
         CopyTexture(mat, oldMat.sTexDiffuse, aiTextureType_DIFFUSE);
 
     // SPECULAR texture
     if (oldMat.sTexSpecular.mMapName.length() > 0)
         CopyTexture(mat, oldMat.sTexSpecular, aiTextureType_SPECULAR);
 
     // OPACITY texture
     if (oldMat.sTexOpacity.mMapName.length() > 0)
         CopyTexture(mat, oldMat.sTexOpacity, aiTextureType_OPACITY);
 
     // EMISSIVE texture
     if (oldMat.sTexEmissive.mMapName.length() > 0)
         CopyTexture(mat, oldMat.sTexEmissive, aiTextureType_EMISSIVE);
 
     // BUMP texture
     if (oldMat.sTexBump.mMapName.length() > 0)
         CopyTexture(mat, oldMat.sTexBump, aiTextureType_HEIGHT);
 
     // SHININESS texture
     if (oldMat.sTexShininess.mMapName.length() > 0)
         CopyTexture(mat, oldMat.sTexShininess, aiTextureType_SHININESS);
 
     // REFLECTION texture
     if (oldMat.sTexReflective.mMapName.length() > 0)
         CopyTexture(mat, oldMat.sTexReflective, aiTextureType_REFLECTION);
 
     // Store the name of the material itself, too
     if (oldMat.mName.length()) {
         aiString tex;
         tex.Set(oldMat.mName);
         mat.AddProperty(&tex, AI_MATKEY_NAME);
     }
 }
 
 // ------------------------------------------------------------------------------------------------
 // Split meshes by their materials and generate output aiMesh'es
diff --git a/code/AssetLib/3DS/3DSLoader.cpp b/code/AssetLib/3DS/3DSLoader.cpp
index 0ec8b872a..b76640218 100644
--- a/code/AssetLib/3DS/3DSLoader.cpp
+++ b/code/AssetLib/3DS/3DSLoader.cpp
@@ -1268,69 +1268,70 @@ ai_real Discreet3DSImporter::ParsePercentageChunk() {
 // ------------------------------------------------------------------------------------------------
 // Read a color chunk. If a percentage chunk is found instead it is read as a grayscale color
 void Discreet3DSImporter::ParseColorChunk(aiColor3D *out, bool acceptPercent) {
     ai_assert(out != nullptr);
 
     // error return value
     const ai_real qnan = get_qnan();
     static const aiColor3D clrError = aiColor3D(qnan, qnan, qnan);
 
     Discreet3DS::Chunk chunk;
     ReadChunk(&chunk);
     const unsigned int diff = chunk.Size - sizeof(Discreet3DS::Chunk);
 
     bool bGamma = false;
 
     // Get the type of the chunk
     switch (chunk.Flag) {
     case Discreet3DS::CHUNK_LINRGBF:
         bGamma = true;
-
+    // fallthrough
     case Discreet3DS::CHUNK_RGBF:
         if (sizeof(float) * 3 > diff) {
             *out = clrError;
             return;
         }
         out->r = stream->GetF4();
         out->g = stream->GetF4();
         out->b = stream->GetF4();
         break;
 
     case Discreet3DS::CHUNK_LINRGBB:
         bGamma = true;
+            // fallthrough
     case Discreet3DS::CHUNK_RGBB: {
         if (sizeof(char) * 3 > diff) {
             *out = clrError;
             return;
         }
         const ai_real invVal = ai_real(1.0) / ai_real(255.0);
         out->r = (ai_real)(uint8_t)stream->GetI1() * invVal;
         out->g = (ai_real)(uint8_t)stream->GetI1() * invVal;
         out->b = (ai_real)(uint8_t)stream->GetI1() * invVal;
     } break;
 
     // Percentage chunks are accepted, too.
     case Discreet3DS::CHUNK_PERCENTF:
         if (acceptPercent && 4 <= diff) {
             out->g = out->b = out->r = stream->GetF4();
             break;
         }
         *out = clrError;
         return;
 
     case Discreet3DS::CHUNK_PERCENTW:
         if (acceptPercent && 1 <= diff) {
             out->g = out->b = out->r = (ai_real)(uint8_t)stream->GetI1() / ai_real(255.0);
             break;
         }
         *out = clrError;
         return;
 
     default:
         stream->IncPtr(diff);
         // Skip unknown chunks, hope this won't cause any problems.
         return ParseColorChunk(out, acceptPercent);
     };
     (void)bGamma;
 }
 
 #endif // !! ASSIMP_BUILD_NO_3DS_IMPORTER
diff --git a/code/AssetLib/ASE/ASELoader.cpp b/code/AssetLib/ASE/ASELoader.cpp
index caa708961..7caac24ce 100644
--- a/code/AssetLib/ASE/ASELoader.cpp
+++ b/code/AssetLib/ASE/ASELoader.cpp
@@ -808,113 +808,114 @@ void CopyASETexture(aiMaterial &mat, ASE::Texture &texture, aiTextureType type)
 // ------------------------------------------------------------------------------------------------
 // Convert from ASE material to output material
 void ASEImporter::ConvertMaterial(ASE::Material &mat) {
     // LARGE TODO: Much code her is copied from 3DS ... join them maybe?
 
     // Allocate the output material
     mat.pcInstance = new aiMaterial();
 
     // At first add the base ambient color of the
     // scene to the material
     mat.mAmbient.r += mParser->m_clrAmbient.r;
     mat.mAmbient.g += mParser->m_clrAmbient.g;
     mat.mAmbient.b += mParser->m_clrAmbient.b;
 
     aiString name;
     name.Set(mat.mName);
     mat.pcInstance->AddProperty(&name, AI_MATKEY_NAME);
 
     // material colors
     mat.pcInstance->AddProperty(&mat.mAmbient, 1, AI_MATKEY_COLOR_AMBIENT);
     mat.pcInstance->AddProperty(&mat.mDiffuse, 1, AI_MATKEY_COLOR_DIFFUSE);
     mat.pcInstance->AddProperty(&mat.mSpecular, 1, AI_MATKEY_COLOR_SPECULAR);
     mat.pcInstance->AddProperty(&mat.mEmissive, 1, AI_MATKEY_COLOR_EMISSIVE);
 
     // shininess
     if (0.0f != mat.mSpecularExponent && 0.0f != mat.mShininessStrength) {
         mat.pcInstance->AddProperty(&mat.mSpecularExponent, 1, AI_MATKEY_SHININESS);
         mat.pcInstance->AddProperty(&mat.mShininessStrength, 1, AI_MATKEY_SHININESS_STRENGTH);
     }
     // If there is no shininess, we can disable phong lighting
     else if (D3DS::Discreet3DS::Metal == mat.mShading ||
              D3DS::Discreet3DS::Phong == mat.mShading ||
              D3DS::Discreet3DS::Blinn == mat.mShading) {
         mat.mShading = D3DS::Discreet3DS::Gouraud;
     }
 
     // opacity
     mat.pcInstance->AddProperty<ai_real>(&mat.mTransparency, 1, AI_MATKEY_OPACITY);
 
     // Two sided rendering?
     if (mat.mTwoSided) {
         int i = 1;
         mat.pcInstance->AddProperty<int>(&i, 1, AI_MATKEY_TWOSIDED);
     }
 
     // shading mode
     aiShadingMode eShading = aiShadingMode_NoShading;
     switch (mat.mShading) {
     case D3DS::Discreet3DS::Flat:
         eShading = aiShadingMode_Flat;
         break;
     case D3DS::Discreet3DS::Phong:
         eShading = aiShadingMode_Phong;
         break;
     case D3DS::Discreet3DS::Blinn:
         eShading = aiShadingMode_Blinn;
         break;
 
         // I don't know what "Wire" shading should be,
         // assume it is simple lambertian diffuse (L dot N) shading
     case D3DS::Discreet3DS::Wire: {
         // set the wireframe flag
         unsigned int iWire = 1;
         mat.pcInstance->AddProperty<int>((int *)&iWire, 1, AI_MATKEY_ENABLE_WIREFRAME);
     }
+    // fallthrough
     case D3DS::Discreet3DS::Gouraud:
         eShading = aiShadingMode_Gouraud;
         break;
     case D3DS::Discreet3DS::Metal:
         eShading = aiShadingMode_CookTorrance;
         break;
     }
     mat.pcInstance->AddProperty<int>((int *)&eShading, 1, AI_MATKEY_SHADING_MODEL);
 
     // DIFFUSE texture
     if (mat.sTexDiffuse.mMapName.length() > 0)
         CopyASETexture(*mat.pcInstance, mat.sTexDiffuse, aiTextureType_DIFFUSE);
 
     // SPECULAR texture
     if (mat.sTexSpecular.mMapName.length() > 0)
         CopyASETexture(*mat.pcInstance, mat.sTexSpecular, aiTextureType_SPECULAR);
 
     // AMBIENT texture
     if (mat.sTexAmbient.mMapName.length() > 0)
         CopyASETexture(*mat.pcInstance, mat.sTexAmbient, aiTextureType_AMBIENT);
 
     // OPACITY texture
     if (mat.sTexOpacity.mMapName.length() > 0)
         CopyASETexture(*mat.pcInstance, mat.sTexOpacity, aiTextureType_OPACITY);
 
     // EMISSIVE texture
     if (mat.sTexEmissive.mMapName.length() > 0)
         CopyASETexture(*mat.pcInstance, mat.sTexEmissive, aiTextureType_EMISSIVE);
 
     // BUMP texture
     if (mat.sTexBump.mMapName.length() > 0)
         CopyASETexture(*mat.pcInstance, mat.sTexBump, aiTextureType_HEIGHT);
 
     // SHININESS texture
     if (mat.sTexShininess.mMapName.length() > 0)
         CopyASETexture(*mat.pcInstance, mat.sTexShininess, aiTextureType_SHININESS);
 
     // store the name of the material itself, too
     if (mat.mName.length() > 0) {
         aiString tex;
         tex.Set(mat.mName);
         mat.pcInstance->AddProperty(&tex, AI_MATKEY_NAME);
     }
     return;
 }
 
 // ------------------------------------------------------------------------------------------------
 // Build output meshes
diff --git a/code/AssetLib/Blender/BlenderDNA.cpp b/code/AssetLib/Blender/BlenderDNA.cpp
index 2910904ba..fbb61ab4f 100644
--- a/code/AssetLib/Blender/BlenderDNA.cpp
+++ b/code/AssetLib/Blender/BlenderDNA.cpp
@@ -323,29 +323,29 @@ void DNA ::AddPrimitiveStructures() {
 // ------------------------------------------------------------------------------------------------
 void SectionParser ::Next() {
     stream.SetCurrentPos(current.start + current.size);
 
     const char tmp[] = {
-        (const char)stream.GetI1(),
-        (const char)stream.GetI1(),
-        (const char)stream.GetI1(),
-        (const char)stream.GetI1()
+        (char)stream.GetI1(),
+        (char)stream.GetI1(),
+        (char)stream.GetI1(),
+        (char)stream.GetI1()
     };
     current.id = std::string(tmp, tmp[3] ? 4 : tmp[2] ? 3 : tmp[1] ? 2 : 1);
 
     current.size = stream.GetI4();
     current.address.val = ptr64 ? stream.GetU8() : stream.GetU4();
 
     current.dna_index = stream.GetI4();
     current.num = stream.GetI4();
 
     current.start = stream.GetCurrentPos();
     if (stream.GetRemainingSizeToLimit() < current.size) {
         throw DeadlyImportError("BLEND: invalid size of file block");
     }
 
 #ifdef ASSIMP_BUILD_BLENDER_DEBUG
     ASSIMP_LOG_VERBOSE_DEBUG(current.id);
 #endif
 }
 
 #endif
diff --git a/code/AssetLib/Blender/BlenderLoader.cpp b/code/AssetLib/Blender/BlenderLoader.cpp
index 2ed0d6b8a..9322369eb 100644
--- a/code/AssetLib/Blender/BlenderLoader.cpp
+++ b/code/AssetLib/Blender/BlenderLoader.cpp
@@ -759,398 +759,398 @@ void BlenderImporter::NotSupportedObjectType(const Object *obj, const char *type
 // ------------------------------------------------------------------------------------------------
 void BlenderImporter::ConvertMesh(const Scene & /*in*/, const Object * /*obj*/, const Mesh *mesh,
         ConversionData &conv_data, TempArray<std::vector, aiMesh> &temp) {
     // TODO: Resolve various problems with BMesh triangulation before re-enabling.
     //       See issues #400, #373, #318  #315 and #132.
 #if defined(TODO_FIX_BMESH_CONVERSION)
     BlenderBMeshConverter BMeshConverter(mesh);
     if (BMeshConverter.ContainsBMesh()) {
         mesh = BMeshConverter.TriangulateBMesh();
     }
 #endif
 
     typedef std::pair<const int, size_t> MyPair;
     if ((!mesh->totface && !mesh->totloop) || !mesh->totvert) {
         return;
     }
 
     // some sanity checks
     if (static_cast<size_t>(mesh->totface) > mesh->mface.size()) {
         ThrowException("Number of faces is larger than the corresponding array");
     }
 
     if (static_cast<size_t>(mesh->totvert) > mesh->mvert.size()) {
         ThrowException("Number of vertices is larger than the corresponding array");
     }
 
     if (static_cast<size_t>(mesh->totloop) > mesh->mloop.size()) {
         ThrowException("Number of vertices is larger than the corresponding array");
     }
 
     // collect per-submesh numbers
     std::map<int, size_t> per_mat;
     std::map<int, size_t> per_mat_verts;
     for (int i = 0; i < mesh->totface; ++i) {
 
         const MFace &mf = mesh->mface[i];
         per_mat[mf.mat_nr]++;
         per_mat_verts[mf.mat_nr] += mf.v4 ? 4 : 3;
     }
 
     for (int i = 0; i < mesh->totpoly; ++i) {
         const MPoly &mp = mesh->mpoly[i];
         per_mat[mp.mat_nr]++;
         per_mat_verts[mp.mat_nr] += mp.totloop;
     }
 
     // ... and allocate the corresponding meshes
     const size_t old = temp->size();
     temp->reserve(temp->size() + per_mat.size());
 
     std::map<size_t, size_t> mat_num_to_mesh_idx;
     for (MyPair &it : per_mat) {
 
         mat_num_to_mesh_idx[it.first] = temp->size();
         temp->push_back(new aiMesh());
 
         aiMesh *out = temp->back();
         out->mVertices = new aiVector3D[per_mat_verts[it.first]];
         out->mNormals = new aiVector3D[per_mat_verts[it.first]];
 
         //out->mNumFaces = 0
         //out->mNumVertices = 0
         out->mFaces = new aiFace[it.second]();
 
         // all sub-meshes created from this mesh are named equally. this allows
         // curious users to recover the original adjacency.
         out->mName = aiString(mesh->id.name + 2);
         // skip over the name prefix 'ME'
 
         // resolve the material reference and add this material to the set of
         // output materials. The (temporary) material index is the index
         // of the material entry within the list of resolved materials.
         if (mesh->mat) {
 
             if (static_cast<size_t>(it.first) >= mesh->mat.size()) {
                 ThrowException("Material index is out of range");
             }
 
             std::shared_ptr<Material> mat = mesh->mat[it.first];
             const std::deque<std::shared_ptr<Material>>::iterator has = std::find(
                     conv_data.materials_raw.begin(),
                     conv_data.materials_raw.end(), mat);
 
             if (has != conv_data.materials_raw.end()) {
                 out->mMaterialIndex = static_cast<unsigned int>(std::distance(conv_data.materials_raw.begin(), has));
             } else {
                 out->mMaterialIndex = static_cast<unsigned int>(conv_data.materials_raw.size());
                 conv_data.materials_raw.push_back(mat);
             }
         } else
             out->mMaterialIndex = static_cast<unsigned int>(-1);
     }
 
     for (int i = 0; i < mesh->totface; ++i) {
 
         const MFace &mf = mesh->mface[i];
 
         aiMesh *const out = temp[mat_num_to_mesh_idx[mf.mat_nr]];
         aiFace &f = out->mFaces[out->mNumFaces++];
 
         f.mIndices = new unsigned int[f.mNumIndices = mf.v4 ? 4 : 3];
         aiVector3D *vo = out->mVertices + out->mNumVertices;
         aiVector3D *vn = out->mNormals + out->mNumVertices;
 
         // XXX we can't fold this easily, because we are restricted
         // to the member names from the BLEND file (v1,v2,v3,v4)
         // which are assigned by the genblenddna.py script and
         // cannot be changed without breaking the entire
         // import process.
 
         if (mf.v1 >= mesh->totvert) {
             ThrowException("Vertex index v1 out of range");
         }
         const MVert *v = &mesh->mvert[mf.v1];
         vo->x = v->co[0];
         vo->y = v->co[1];
         vo->z = v->co[2];
         vn->x = v->no[0];
         vn->y = v->no[1];
         vn->z = v->no[2];
         f.mIndices[0] = out->mNumVertices++;
         ++vo;
         ++vn;
 
         //  if (f.mNumIndices >= 2) {
         if (mf.v2 >= mesh->totvert) {
             ThrowException("Vertex index v2 out of range");
         }
         v = &mesh->mvert[mf.v2];
         vo->x = v->co[0];
         vo->y = v->co[1];
         vo->z = v->co[2];
         vn->x = v->no[0];
         vn->y = v->no[1];
         vn->z = v->no[2];
         f.mIndices[1] = out->mNumVertices++;
         ++vo;
         ++vn;
 
         if (mf.v3 >= mesh->totvert) {
             ThrowException("Vertex index v3 out of range");
         }
         //  if (f.mNumIndices >= 3) {
         v = &mesh->mvert[mf.v3];
         vo->x = v->co[0];
         vo->y = v->co[1];
         vo->z = v->co[2];
         vn->x = v->no[0];
         vn->y = v->no[1];
         vn->z = v->no[2];
         f.mIndices[2] = out->mNumVertices++;
         ++vo;
         ++vn;
 
         if (mf.v4 >= mesh->totvert) {
             ThrowException("Vertex index v4 out of range");
         }
         //  if (f.mNumIndices >= 4) {
         if (mf.v4) {
             v = &mesh->mvert[mf.v4];
             vo->x = v->co[0];
             vo->y = v->co[1];
             vo->z = v->co[2];
             vn->x = v->no[0];
             vn->y = v->no[1];
             vn->z = v->no[2];
             f.mIndices[3] = out->mNumVertices++;
             ++vo;
             ++vn;
 
             out->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
         } else
             out->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
 
         //  }
         //  }
         //  }
     }
 
     for (int i = 0; i < mesh->totpoly; ++i) {
 
         const MPoly &mf = mesh->mpoly[i];
 
         aiMesh *const out = temp[mat_num_to_mesh_idx[mf.mat_nr]];
         aiFace &f = out->mFaces[out->mNumFaces++];
 
         f.mIndices = new unsigned int[f.mNumIndices = mf.totloop];
         aiVector3D *vo = out->mVertices + out->mNumVertices;
         aiVector3D *vn = out->mNormals + out->mNumVertices;
 
         // XXX we can't fold this easily, because we are restricted
         // to the member names from the BLEND file (v1,v2,v3,v4)
         // which are assigned by the genblenddna.py script and
         // cannot be changed without breaking the entire
         // import process.
         for (int j = 0; j < mf.totloop; ++j) {
             const MLoop &loop = mesh->mloop[mf.loopstart + j];
 
             if (loop.v >= mesh->totvert) {
                 ThrowException("Vertex index out of range");
             }
 
             const MVert &v = mesh->mvert[loop.v];
 
             vo->x = v.co[0];
             vo->y = v.co[1];
             vo->z = v.co[2];
             vn->x = v.no[0];
             vn->y = v.no[1];
             vn->z = v.no[2];
             f.mIndices[j] = out->mNumVertices++;
 
             ++vo;
             ++vn;
         }
         if (mf.totloop == 3) {
             out->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
         } else {
             out->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
         }
     }
 
     // TODO should we create the TextureUVMapping map in Convert<Material> to prevent redundant processing?
 
     // create texture <-> uvname mapping for all materials
     // key is texture number, value is data *
     typedef std::map<uint32_t, const MLoopUV *> TextureUVMapping;
     // key is material number, value is the TextureUVMapping for the material
     typedef std::map<uint32_t, TextureUVMapping> MaterialTextureUVMappings;
     MaterialTextureUVMappings matTexUvMappings;
-    const uint32_t maxMat = static_cast<const uint32_t>(mesh->mat.size());
+    const uint32_t maxMat = static_cast<uint32_t>(mesh->mat.size());
     for (uint32_t m = 0; m < maxMat; ++m) {
         // get material by index
         const std::shared_ptr<Material> pMat = mesh->mat[m];
         TextureUVMapping texuv;
         const uint32_t maxTex = sizeof(pMat->mtex) / sizeof(pMat->mtex[0]);
         for (uint32_t t = 0; t < maxTex; ++t) {
             if (pMat->mtex[t] && pMat->mtex[t]->uvname[0]) {
                 // get the CustomData layer for given uvname and correct type
                 const ElemBase *pLoop = getCustomDataLayerData(mesh->ldata, CD_MLOOPUV, pMat->mtex[t]->uvname);
                 if (pLoop) {
                     texuv.insert(std::make_pair(t, dynamic_cast<const MLoopUV *>(pLoop)));
                 }
             }
         }
         if (texuv.size()) {
             matTexUvMappings.insert(std::make_pair(m, texuv));
         }
     }
 
     // collect texture coordinates, they're stored in a separate per-face buffer
     if (mesh->mtface || mesh->mloopuv) {
         if (mesh->totface > static_cast<int>(mesh->mtface.size())) {
             ThrowException("Number of UV faces is larger than the corresponding UV face array (#1)");
         }
         for (std::vector<aiMesh *>::iterator it = temp->begin() + old; it != temp->end(); ++it) {
             ai_assert(0 != (*it)->mNumVertices);
             ai_assert(0 != (*it)->mNumFaces);
             const auto itMatTexUvMapping = matTexUvMappings.find((*it)->mMaterialIndex);
             if (itMatTexUvMapping == matTexUvMappings.end()) {
                 // default behaviour like before
                 (*it)->mTextureCoords[0] = new aiVector3D[(*it)->mNumVertices];
             } else {
                 // create texture coords for every mapped tex
                 for (uint32_t i = 0; i < itMatTexUvMapping->second.size(); ++i) {
                     (*it)->mTextureCoords[i] = new aiVector3D[(*it)->mNumVertices];
                 }
             }
             (*it)->mNumFaces = (*it)->mNumVertices = 0;
         }
 
         for (int i = 0; i < mesh->totface; ++i) {
             const MTFace *v = &mesh->mtface[i];
 
             aiMesh *const out = temp[mat_num_to_mesh_idx[mesh->mface[i].mat_nr]];
             const aiFace &f = out->mFaces[out->mNumFaces++];
 
             aiVector3D *vo = &out->mTextureCoords[0][out->mNumVertices];
             for (unsigned int j = 0; j < f.mNumIndices; ++j, ++vo, ++out->mNumVertices) {
                 vo->x = v->uv[j][0];
                 vo->y = v->uv[j][1];
             }
         }
 
         for (int i = 0; i < mesh->totpoly; ++i) {
             const MPoly &v = mesh->mpoly[i];
             aiMesh *const out = temp[mat_num_to_mesh_idx[v.mat_nr]];
             const aiFace &f = out->mFaces[out->mNumFaces++];
 
             const auto itMatTexUvMapping = matTexUvMappings.find(v.mat_nr);
             if (itMatTexUvMapping == matTexUvMappings.end()) {
                 // old behavior
                 aiVector3D *vo = &out->mTextureCoords[0][out->mNumVertices];
                 for (unsigned int j = 0; j < f.mNumIndices; ++j, ++vo, ++out->mNumVertices) {
                     const MLoopUV &uv = mesh->mloopuv[v.loopstart + j];
                     vo->x = uv.uv[0];
                     vo->y = uv.uv[1];
                 }
             } else {
                 // create textureCoords for every mapped tex
                 for (uint32_t m = 0; m < itMatTexUvMapping->second.size(); ++m) {
                     const MLoopUV *tm = itMatTexUvMapping->second[m];
                     aiVector3D *vo = &out->mTextureCoords[m][out->mNumVertices];
                     uint32_t j = 0;
                     for (; j < f.mNumIndices; ++j, ++vo) {
                         const MLoopUV &uv = tm[v.loopstart + j];
                         vo->x = uv.uv[0];
                         vo->y = uv.uv[1];
                     }
                     // only update written mNumVertices in last loop
                     // TODO why must the numVertices be incremented here?
                     if (m == itMatTexUvMapping->second.size() - 1) {
                         out->mNumVertices += j;
                     }
                 }
             }
         }
     }
 
     // collect texture coordinates, old-style (marked as deprecated in current blender sources)
     if (mesh->tface) {
         if (mesh->totface > static_cast<int>(mesh->tface.size())) {
             ThrowException("Number of faces is larger than the corresponding UV face array (#2)");
         }
         for (std::vector<aiMesh *>::iterator it = temp->begin() + old; it != temp->end(); ++it) {
             ai_assert(0 != (*it)->mNumVertices);
             ai_assert(0 != (*it)->mNumFaces);
 
             (*it)->mTextureCoords[0] = new aiVector3D[(*it)->mNumVertices];
             (*it)->mNumFaces = (*it)->mNumVertices = 0;
         }
 
         for (int i = 0; i < mesh->totface; ++i) {
             const TFace *v = &mesh->tface[i];
 
             aiMesh *const out = temp[mat_num_to_mesh_idx[mesh->mface[i].mat_nr]];
             const aiFace &f = out->mFaces[out->mNumFaces++];
 
             aiVector3D *vo = &out->mTextureCoords[0][out->mNumVertices];
             for (unsigned int j = 0; j < f.mNumIndices; ++j, ++vo, ++out->mNumVertices) {
                 vo->x = v->uv[j][0];
                 vo->y = v->uv[j][1];
             }
         }
     }
 
     // collect vertex colors, stored separately as well
     if (mesh->mcol || mesh->mloopcol) {
         if (mesh->totface > static_cast<int>((mesh->mcol.size() / 4))) {
             ThrowException("Number of faces is larger than the corresponding color face array");
         }
         for (std::vector<aiMesh *>::iterator it = temp->begin() + old; it != temp->end(); ++it) {
             ai_assert(0 != (*it)->mNumVertices);
             ai_assert(0 != (*it)->mNumFaces);
 
             (*it)->mColors[0] = new aiColor4D[(*it)->mNumVertices];
             (*it)->mNumFaces = (*it)->mNumVertices = 0;
         }
 
         for (int i = 0; i < mesh->totface; ++i) {
 
             aiMesh *const out = temp[mat_num_to_mesh_idx[mesh->mface[i].mat_nr]];
             const aiFace &f = out->mFaces[out->mNumFaces++];
 
             aiColor4D *vo = &out->mColors[0][out->mNumVertices];
             for (unsigned int n = 0; n < f.mNumIndices; ++n, ++vo, ++out->mNumVertices) {
                 const MCol *col = &mesh->mcol[(i << 2) + n];
 
                 vo->r = col->r;
                 vo->g = col->g;
                 vo->b = col->b;
                 vo->a = col->a;
             }
             for (unsigned int n = f.mNumIndices; n < 4; ++n)
                 ;
         }
 
         for (int i = 0; i < mesh->totpoly; ++i) {
             const MPoly &v = mesh->mpoly[i];
             aiMesh *const out = temp[mat_num_to_mesh_idx[v.mat_nr]];
             const aiFace &f = out->mFaces[out->mNumFaces++];
 
             aiColor4D *vo = &out->mColors[0][out->mNumVertices];
             const ai_real scaleZeroToOne = 1.f / 255.f;
             for (unsigned int j = 0; j < f.mNumIndices; ++j, ++vo, ++out->mNumVertices) {
                 const MLoopCol &col = mesh->mloopcol[v.loopstart + j];
                 vo->r = ai_real(col.r) * scaleZeroToOne;
                 vo->g = ai_real(col.g) * scaleZeroToOne;
                 vo->b = ai_real(col.b) * scaleZeroToOne;
                 vo->a = ai_real(col.a) * scaleZeroToOne;
             }
         }
     }
 
     return;
 }
 
 // ------------------------------------------------------------------------------------------------
diff --git a/code/AssetLib/Collada/ColladaParser.cpp b/code/AssetLib/Collada/ColladaParser.cpp
index 9b3af0848..52e9b4978 100644
--- a/code/AssetLib/Collada/ColladaParser.cpp
+++ b/code/AssetLib/Collada/ColladaParser.cpp
@@ -1564,94 +1564,95 @@ void ColladaParser::ReadVertexData(XmlNode &node, Mesh &pMesh) {
 // ------------------------------------------------------------------------------------------------
 // Reads input declarations of per-index mesh data into the given mesh
 void ColladaParser::ReadIndexData(XmlNode &node, Mesh &pMesh) {
     std::vector<size_t> vcount;
     std::vector<InputChannel> perIndexData;
 
     unsigned int numPrimitives = 0;
     XmlParser::getUIntAttribute(node, "count", numPrimitives);
     // read primitive count from the attribute
     //int attrCount = GetAttribute("count");
     //size_t numPrimitives = (size_t)mReader->getAttributeValueAsInt(attrCount);
     // some mesh types (e.g. tristrips) don't specify primitive count upfront,
     // so we need to sum up the actual number of primitives while we read the <p>-tags
     size_t actualPrimitives = 0;
     SubMesh subgroup;
     if (XmlParser::hasAttribute(node, "material")) {
         XmlParser::getStdStrAttribute(node, "material", subgroup.mMaterial);
     }
 
     // distinguish between polys and triangles
     std::string elementName = node.name();
     PrimitiveType primType = Prim_Invalid;
     if (elementName == "lines")
         primType = Prim_Lines;
     else if (elementName == "linestrips")
         primType = Prim_LineStrip;
     else if (elementName == "polygons")
         primType = Prim_Polygon;
     else if (elementName == "polylist")
         primType = Prim_Polylist;
     else if (elementName == "triangles")
         primType = Prim_Triangles;
     else if (elementName == "trifans")
         primType = Prim_TriFans;
     else if (elementName == "tristrips")
         primType = Prim_TriStrips;
 
     ai_assert(primType != Prim_Invalid);
 
     // also a number of <input> elements, but in addition a <p> primitive collection and probably index counts for all primitives
     XmlNodeIterator xmlIt(node, XmlNodeIterator::PreOrderMode);
     XmlNode currentNode;
     while (xmlIt.getNext(currentNode)) {
         const std::string &currentName = currentNode.name();
         if (currentName == "input") {
             ReadInputChannel(currentNode, perIndexData);
         } else if (currentName == "vcount") {
             if (!currentNode.empty()) {
                 if (numPrimitives) // It is possible to define a mesh without any primitives
                 {
                     // case <polylist> - specifies the number of indices for each polygon
                     std::string v;
                     XmlParser::getValueAsString(currentNode, v);
                     const char *content = v.c_str();
                     vcount.reserve(numPrimitives);
+                    SkipSpacesAndLineEnd(&content);
                     for (unsigned int a = 0; a < numPrimitives; a++) {
                         if (*content == 0) {
                             throw DeadlyImportError("Expected more values while reading <vcount> contents.");
                         }
                         // read a number
                         vcount.push_back((size_t)strtoul10(content, &content));
                         // skip whitespace after it
                         SkipSpacesAndLineEnd(&content);
                     }
                 }
             }
         } else if (currentName == "p") {
             if (!currentNode.empty()) {
                 // now here the actual fun starts - these are the indices to construct the mesh data from
                 actualPrimitives += ReadPrimitives(currentNode, pMesh, perIndexData, numPrimitives, vcount, primType);
             }
         } else if (currentName == "extra") {
             // skip
         } else if (currentName == "ph") {
             // skip
         } else {
             throw DeadlyImportError("Unexpected sub element <", currentName, "> in tag <", elementName, ">");
         }
     }
 
 #ifdef ASSIMP_BUILD_DEBUG
     if (primType != Prim_TriFans && primType != Prim_TriStrips && primType != Prim_LineStrip &&
             primType != Prim_Lines) { // this is ONLY to workaround a bug in SketchUp 15.3.331 where it writes the wrong 'count' when it writes out the 'lines'.
         ai_assert(actualPrimitives == numPrimitives);
     }
 #endif
 
     // only when we're done reading all <p> tags (and thus know the final vertex count) can we commit the submesh
     subgroup.mNumFaces = actualPrimitives;
     pMesh.mSubMeshes.push_back(subgroup);
 }
 
 // ------------------------------------------------------------------------------------------------
 // Reads a single input channel element and stores it in the given array, if valid
diff --git a/code/AssetLib/LWO/LWOLoader.cpp b/code/AssetLib/LWO/LWOLoader.cpp
index 44517a1a6..77589d63c 100644
--- a/code/AssetLib/LWO/LWOLoader.cpp
+++ b/code/AssetLib/LWO/LWOLoader.cpp
@@ -1445,173 +1445,174 @@ void LWOImporter::LoadLWO3Envelope(unsigned int length) {
 // ------------------------------------------------------------------------------------------------
 // Load file - master function
 void LWOImporter::LoadLWO2File() {
     bool skip = false;
 
     LE_NCONST uint8_t *const end = mFileBuffer + fileSize;
     unsigned int iUnnamed = 0;
 
     while (true) {
         if (mFileBuffer + sizeof(IFF::ChunkHeader) > end) break;
 
         IFF::ChunkHeader head = IFF::LoadChunk(mFileBuffer);
 
         int bufOffset = 0;
         if( head.type == AI_IFF_FOURCC_FORM ) { // not chunk, it's a form
             mFileBuffer -= 8;
             head = IFF::LoadForm(mFileBuffer);
             bufOffset = 4;
         }
 
         if (mFileBuffer + head.length > end) {
             throw DeadlyImportError("LWO2: Chunk length points behind the file");
             break;
         }
         uint8_t *const next = mFileBuffer + head.length;
         mFileBuffer += bufOffset;
         if (!head.length) {
             mFileBuffer = next;
             continue;
         }
 
         switch (head.type) {
                 // new layer
             case AI_LWO_LAYR: {
                 // add a new layer to the list ....
                 mLayers->push_back(LWO::Layer());
                 LWO::Layer &layer = mLayers->back();
                 mCurLayer = &layer;
 
                 AI_LWO_VALIDATE_CHUNK_LENGTH(head.length, LAYR, 16);
 
                 // layer index.
                 layer.mIndex = GetU2();
 
                 // Continue loading this layer or ignore it? Check the layer index property
                 if (UINT_MAX != configLayerIndex && (configLayerIndex - 1) != layer.mIndex) {
                     skip = true;
                 } else
                     skip = false;
 
                 // pivot point
                 mFileBuffer += 2; /* unknown */
                 mCurLayer->mPivot.x = GetF4();
                 mCurLayer->mPivot.y = GetF4();
                 mCurLayer->mPivot.z = GetF4();
                 GetS0(layer.mName, head.length - 16);
 
                 // if the name is empty, generate a default name
                 if (layer.mName.empty()) {
                     char buffer[128]; // should be sufficiently large
                     ::ai_snprintf(buffer, 128, "Layer_%i", iUnnamed++);
                     layer.mName = buffer;
                 }
 
                 // load this layer or ignore it? Check the layer name property
                 if (configLayerName.length() && configLayerName != layer.mName) {
                     skip = true;
                 } else
                     hasNamedLayer = true;
 
                 // optional: parent of this layer
                 if (mFileBuffer + 2 <= next)
                     layer.mParent = GetU2();
                 else
                     layer.mParent = (uint16_t) -1;
 
                 // Set layer skip parameter
                 layer.skip = skip;
 
                 break;
             }
                 // vertex list
             case AI_LWO_PNTS: {
                 if (skip)
                     break;
 
                 unsigned int old = (unsigned int)mCurLayer->mTempPoints.size();
                 LoadLWOPoints(head.length);
                 mCurLayer->mPointIDXOfs = old;
                 break;
             }
                 // vertex tags
             case AI_LWO_VMAD:
                 if (mCurLayer->mFaces.empty()) {
                     ASSIMP_LOG_WARN("LWO2: Unexpected VMAD chunk");
                     break;
                 }
                 // --- intentionally no break here
+                // fallthrough
             case AI_LWO_VMAP: {
                 if (skip)
                     break;
 
                 if (mCurLayer->mTempPoints.empty())
                     ASSIMP_LOG_WARN("LWO2: Unexpected VMAP chunk");
                 else
                     LoadLWO2VertexMap(head.length, head.type == AI_LWO_VMAD);
                 break;
             }
                 // face list
             case AI_LWO_POLS: {
                 if (skip)
                     break;
 
                 unsigned int old = (unsigned int)mCurLayer->mFaces.size();
                 LoadLWO2Polygons(head.length);
                 mCurLayer->mFaceIDXOfs = old;
                 break;
             }
                 // polygon tags
             case AI_LWO_PTAG: {
                 if (skip)
                     break;
 
                 if (mCurLayer->mFaces.empty()) {
                     ASSIMP_LOG_WARN("LWO2: Unexpected PTAG");
                 } else {
                     LoadLWO2PolygonTags(head.length);
                 }
                 break;
             }
                 // list of tags
             case AI_LWO_TAGS: {
                 if (!mTags->empty()) {
                     ASSIMP_LOG_WARN("LWO2: SRFS chunk encountered twice");
                 } else {
                     LoadLWOTags(head.length);
                 }
                 break;
             }
 
                 // surface chunk
             case AI_LWO_SURF: {
                 if( mIsLWO3 )
                     LoadLWO3Surface(head.length);
                 else
                     LoadLWO2Surface(head.length);
 
                 break;
             }
 
                 // clip chunk
             case AI_LWO_CLIP: {
                 if( mIsLWO3 )
                     LoadLWO3Clip(head.length);
                 else
                     LoadLWO2Clip(head.length);
                 break;
             }
 
                 // envelope chunk
             case AI_LWO_ENVL: {
                 if( mIsLWO3 )
                     LoadLWO3Envelope(head.length);
                 else
                     LoadLWO2Envelope(head.length);
                 break;
             }
         }
         mFileBuffer = next;
     }
 }
 
 #endif // !! ASSIMP_BUILD_NO_LWO_IMPORTER
diff --git a/code/AssetLib/MMD/MMDPmxParser.h b/code/AssetLib/MMD/MMDPmxParser.h
index 08f57f6f0..c9df37c68 100644
--- a/code/AssetLib/MMD/MMDPmxParser.h
+++ b/code/AssetLib/MMD/MMDPmxParser.h
@@ -51,732 +51,734 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 namespace pmx
 {
 	class PmxSetting
 	{
 	public:
 		PmxSetting()
 			: encoding(0)
 			, uv(0)
 			, vertex_index_size(0)
 			, texture_index_size(0)
 			, material_index_size(0)
 			, bone_index_size(0)
 			, morph_index_size(0)
 			, rigidbody_index_size(0)
 		{}
 
 		uint8_t encoding;
 		uint8_t uv;
 		uint8_t vertex_index_size;
 		uint8_t texture_index_size;
 		uint8_t material_index_size;
 		uint8_t bone_index_size;
 		uint8_t morph_index_size;
 		uint8_t rigidbody_index_size;
 		void Read(std::istream *stream);
 	};
 
 	enum class PmxVertexSkinningType : uint8_t
 	{
 		BDEF1 = 0,
 		BDEF2 = 1,
 		BDEF4 = 2,
 		SDEF = 3,
 		QDEF = 4,
 	};
 
 	class PmxVertexSkinning
 	{
 	public:
 		virtual void Read(std::istream *stream, PmxSetting *setting) = 0;
 		virtual ~PmxVertexSkinning() {}
 	};
 
 	class PmxVertexSkinningBDEF1 : public PmxVertexSkinning
 	{
 	public:
 		PmxVertexSkinningBDEF1()
 			: bone_index(0)
 		{}
 
 		int bone_index;
 		void Read(std::istream *stresam, PmxSetting *setting);
 	};
 
 	class PmxVertexSkinningBDEF2 : public PmxVertexSkinning
 	{
 	public:
 		PmxVertexSkinningBDEF2()
 			: bone_index1(0)
 			, bone_index2(0)
 			, bone_weight(0.0f)
 		{}
 
 		int bone_index1;
 		int bone_index2;
 		float bone_weight;
 		void Read(std::istream *stresam, PmxSetting *setting);
 	};
 
 	class PmxVertexSkinningBDEF4 : public PmxVertexSkinning
 	{
 	public:
 		PmxVertexSkinningBDEF4()
 			: bone_index1(0)
 			, bone_index2(0)
 			, bone_index3(0)
 			, bone_index4(0)
 			, bone_weight1(0.0f)
 			, bone_weight2(0.0f)
 			, bone_weight3(0.0f)
 			, bone_weight4(0.0f)
 		{}
 
 		int bone_index1;
 		int bone_index2;
 		int bone_index3;
 		int bone_index4;
 		float bone_weight1;
 		float bone_weight2;
 		float bone_weight3;
 		float bone_weight4;
 		void Read(std::istream *stresam, PmxSetting *setting);
 	};
 
 	class PmxVertexSkinningSDEF : public PmxVertexSkinning
 	{
 	public:
 		PmxVertexSkinningSDEF()
 			: bone_index1(0)
 			, bone_index2(0)
 			, bone_weight(0.0f)
 		{
 			for (int i = 0; i < 3; ++i) {
 				sdef_c[i] = 0.0f;
 				sdef_r0[i] = 0.0f;
 				sdef_r1[i] = 0.0f;
 			}
 		}
 
 		int bone_index1;
 		int bone_index2;
 		float bone_weight;
 		float sdef_c[3];
 		float sdef_r0[3];
 		float sdef_r1[3];
 		void Read(std::istream *stresam, PmxSetting *setting);
 	};
 
 	class PmxVertexSkinningQDEF : public PmxVertexSkinning
 	{
 	public:
 		PmxVertexSkinningQDEF()
 			: bone_index1(0)
 			, bone_index2(0)
 			, bone_index3(0)
 			, bone_index4(0)
 			, bone_weight1(0.0f)
 			, bone_weight2(0.0f)
 			, bone_weight3(0.0f)
 			, bone_weight4(0.0f)
 		{}
 
 		int bone_index1;
 		int bone_index2;
 		int bone_index3;
 		int bone_index4;
 		float bone_weight1;
 		float bone_weight2;
 		float bone_weight3;
 		float bone_weight4;
 		void Read(std::istream *stresam, PmxSetting *setting);
 	};
 
 	class PmxVertex
 	{
 	public:
 		PmxVertex()
 			: edge(0.0f)
 		{
 			uv[0] = uv[1] = 0.0f;
 			for (int i = 0; i < 3; ++i) {
 				position[i] = 0.0f;
 				normal[i] = 0.0f;
 			}
 			for (int i = 0; i < 4; ++i) {
 				for (int k = 0; k < 4; ++k) {
 					uva[i][k] = 0.0f;
 				}
 			}
 		}
 
 		float position[3];
 		float normal[3];
 		float uv[2];
 		float uva[4][4];
 		PmxVertexSkinningType skinning_type;
 		std::unique_ptr<PmxVertexSkinning> skinning;
 		float edge;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	class PmxMaterial
 	{
 	public:
 		PmxMaterial()
 			: specularlity(0.0f)
 			, flag(0)
 			, edge_size(0.0f)
 			, diffuse_texture_index(0)
 			, sphere_texture_index(0)
 			, sphere_op_mode(0)
 			, common_toon_flag(0)
 			, toon_texture_index(0)
 			, index_count(0)
 		{
 			for (int i = 0; i < 3; ++i) {
 				specular[i] = 0.0f;
 				ambient[i] = 0.0f;
 				edge_color[i] = 0.0f;
 			}
 			for (int i = 0; i < 4; ++i) {
 				diffuse[i] = 0.0f;
 			}
 		}
 
 		std::string material_name;
 		std::string material_english_name;
 		float diffuse[4];
 		float specular[3];
 		float specularlity;
 		float ambient[3];
 		uint8_t flag;
 		float edge_color[4];
 		float edge_size;
 		int diffuse_texture_index;
 		int sphere_texture_index;
 		uint8_t sphere_op_mode;
 		uint8_t common_toon_flag;
 		int toon_texture_index;
 		std::string memo;
 		int index_count;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	class PmxIkLink
 	{
 	public:
 		PmxIkLink()
 			: link_target(0)
 			, angle_lock(0)
 		{
 			for (int i = 0; i < 3; ++i) {
 				max_radian[i] = 0.0f;
 				min_radian[i] = 0.0f;
 			}
 		}
 
 		int link_target;
 		uint8_t angle_lock;
 		float max_radian[3];
 		float min_radian[3];
 		void Read(std::istream *stream, PmxSetting *settingn);
 	};
 
 	class PmxBone
 	{
 	public:
 		PmxBone()
 			: parent_index(0)
 			, level(0)
 			, bone_flag(0)
 			, target_index(0)
 			, grant_parent_index(0)
 			, grant_weight(0.0f)
 			, key(0)
 			, ik_target_bone_index(0)
 			, ik_loop(0)
 			, ik_loop_angle_limit(0.0f)
 			, ik_link_count(0)
 		{
 			for (int i = 0; i < 3; ++i) {
 				position[i] = 0.0f;
 				offset[i] = 0.0f;
 				lock_axis_orientation[i] = 0.0f;
 				local_axis_x_orientation[i] = 0.0f;
 				local_axis_y_orientation[i] = 0.0f;
 			}
 		}
 
 		std::string bone_name;
 		std::string bone_english_name;
 		float position[3];
 		int parent_index;
 		int level;
 		uint16_t bone_flag;
 		float offset[3];
 		int target_index;
 		int grant_parent_index;
 		float grant_weight;
 		float lock_axis_orientation[3];
 		float local_axis_x_orientation[3];
 		float local_axis_y_orientation[3];
 		int key;
 		int ik_target_bone_index;
 		int ik_loop;
 		float ik_loop_angle_limit;
 		int ik_link_count;
 		std::unique_ptr<PmxIkLink []> ik_links;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	enum class MorphType : uint8_t
 	{
 		Group = 0,
 		Vertex = 1,
 		Bone = 2,
 		UV = 3,
 		AdditionalUV1 = 4,
 		AdditionalUV2 = 5,
 		AdditionalUV3 = 6,
 		AdditionalUV4 = 7,
 		Matrial = 8,
 		Flip = 9,
 		Implus = 10,
 	};
 
 	enum class MorphCategory : uint8_t
 	{
 		ReservedCategory = 0,
 		Eyebrow = 1,
 		Eye = 2,
 		Mouth = 3,
 		Other = 4,
 	};
 
 	class PmxMorphOffset
 	{
 	public:
 		void virtual Read(std::istream *stream, PmxSetting *setting) = 0;
+
+        virtual ~PmxMorphOffset() = default;
 	};
 
 	class PmxMorphVertexOffset : public PmxMorphOffset
 	{
 	public:
 		PmxMorphVertexOffset()
 			: vertex_index(0)
 		{
 			for (int i = 0; i < 3; ++i) {
 				position_offset[i] = 0.0f;
 			}
 		}
 		int vertex_index;
 		float position_offset[3];
 		void Read(std::istream *stream, PmxSetting *setting); //override;
 	};
 
 	class PmxMorphUVOffset : public PmxMorphOffset
 	{
 	public:
 		PmxMorphUVOffset()
 			: vertex_index(0)
 		{
 			for (int i = 0; i < 4; ++i) {
 				uv_offset[i] = 0.0f;
 			}
 		}
 		int vertex_index;
 		float uv_offset[4];
 		void Read(std::istream *stream, PmxSetting *setting); //override;
 	};
 
 	class PmxMorphBoneOffset : public PmxMorphOffset
 	{
 	public:
 		PmxMorphBoneOffset()
 			: bone_index(0)
 		{
 			for (int i = 0; i < 3; ++i) {
 				translation[i] = 0.0f;
 			}
 			for (int i = 0; i < 4; ++i) {
 				rotation[i] = 0.0f;
 			}
 		}
 		int bone_index;
 		float translation[3];
 		float rotation[4];
 		void Read(std::istream *stream, PmxSetting *setting); //override;
 	};
 
 	class PmxMorphMaterialOffset : public PmxMorphOffset
 	{
 	public:
 		PmxMorphMaterialOffset()
 			: specularity(0.0f)
 			, edge_size(0.0f)
 		{
 			for (int i = 0; i < 3; ++i) {
 				specular[i] = 0.0f;
 				ambient[i] = 0.0f;
 			}
 			for (int i = 0; i < 4; ++i) {
 				diffuse[i] = 0.0f;
 				edge_color[i] = 0.0f;
 				texture_argb[i] = 0.0f;
 				sphere_texture_argb[i] = 0.0f;
 				toon_texture_argb[i] = 0.0f;
 			}
 		}
 		int material_index;
 		uint8_t offset_operation;
 		float diffuse[4];
 		float specular[3];
 		float specularity;
 		float ambient[3];
 		float edge_color[4];
 		float edge_size;
 		float texture_argb[4];
 		float sphere_texture_argb[4];
 		float toon_texture_argb[4];
 		void Read(std::istream *stream, PmxSetting *setting); //override;
 	};
 
 	class PmxMorphGroupOffset : public PmxMorphOffset
 	{
 	public:
 		PmxMorphGroupOffset()
 			: morph_index(0)
 			, morph_weight(0.0f)
 		{}
 		int morph_index;
 		float morph_weight;
 		void Read(std::istream *stream, PmxSetting *setting); //override;
 	};
 
 	class PmxMorphFlipOffset : public PmxMorphOffset
 	{
 	public:
 		PmxMorphFlipOffset()
 			: morph_index(0)
 			, morph_value(0.0f)
 		{}
 		int morph_index;
 		float morph_value;
 		void Read(std::istream *stream, PmxSetting *setting); //override;
 	};
 
 	class PmxMorphImplusOffset : public PmxMorphOffset
 	{
 	public:
 		PmxMorphImplusOffset()
 			: rigid_body_index(0)
 			, is_local(0)
 		{
 			for (int i = 0; i < 3; ++i) {
 				velocity[i] = 0.0f;
 				angular_torque[i] = 0.0f;
 			}
 		}
 		int rigid_body_index;
 		uint8_t is_local;
 		float velocity[3];
 		float angular_torque[3];
 		void Read(std::istream *stream, PmxSetting *setting); //override;
 	};
 
 	class PmxMorph
 	{
 	public:
 		PmxMorph()
 			: offset_count(0)
 		{
 		}
 		std::string morph_name;
 		std::string morph_english_name;
 		MorphCategory category;
 		MorphType morph_type;
 		int offset_count;
 		std::unique_ptr<PmxMorphVertexOffset []> vertex_offsets;
 		std::unique_ptr<PmxMorphUVOffset []> uv_offsets;
 		std::unique_ptr<PmxMorphBoneOffset []> bone_offsets;
 		std::unique_ptr<PmxMorphMaterialOffset []> material_offsets;
 		std::unique_ptr<PmxMorphGroupOffset []> group_offsets;
 		std::unique_ptr<PmxMorphFlipOffset []> flip_offsets;
 		std::unique_ptr<PmxMorphImplusOffset []> implus_offsets;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	class PmxFrameElement
 	{
 	public:
 		PmxFrameElement()
 			: element_target(0)
 			, index(0)
 		{
 		}
 		uint8_t element_target;
 		int index;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	class PmxFrame
 	{
 	public:
 		PmxFrame()
 			: frame_flag(0)
 			, element_count(0)
 		{
 		}
 		std::string frame_name;
 		std::string frame_english_name;
 		uint8_t frame_flag;
 		int element_count;
 		std::unique_ptr<PmxFrameElement []> elements;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	class PmxRigidBody
 	{
 	public:
 		PmxRigidBody()
 			: target_bone(0)
 			, group(0)
 			, mask(0)
 			, shape(0)
 			, mass(0.0f)
 			, move_attenuation(0.0f)
 			, rotation_attenuation(0.0f)
 			, repulsion(0.0f)
 			, friction(0.0f)
 			, physics_calc_type(0)
 		{
 			for (int i = 0; i < 3; ++i) {
 				size[i] = 0.0f;
 				position[i] = 0.0f;
 				orientation[i] = 0.0f;
 			}
 		}
 		std::string girid_body_name;
 		std::string girid_body_english_name;
 		int target_bone;
 		uint8_t group;
 		uint16_t mask;
 		uint8_t shape;
 		float size[3];
 		float position[3];
 		float orientation[3];
 		float mass;
 		float move_attenuation;
 		float rotation_attenuation;
 		float repulsion;
 		float friction;
 		uint8_t physics_calc_type;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	enum class PmxJointType : uint8_t
 	{
 		Generic6DofSpring = 0,
 		Generic6Dof = 1,
 		Point2Point = 2,
 		ConeTwist = 3,
 		Slider = 5,
 		Hinge = 6
 	};
 
 	class PmxJointParam
 	{
 	public:
 		PmxJointParam()
 			: rigid_body1(0)
 			, rigid_body2(0)
 		{
 			for (int i = 0; i < 3; ++i) {
 				position[i] = 0.0f;
 				orientaiton[i] = 0.0f;
 				move_limitation_min[i] = 0.0f;
 				move_limitation_max[i] = 0.0f;
 				rotation_limitation_min[i] = 0.0f;
 				rotation_limitation_max[i] = 0.0f;
 				spring_move_coefficient[i] = 0.0f;
 				spring_rotation_coefficient[i] = 0.0f;
 			}
 		}
 		int rigid_body1;
 		int rigid_body2;
 		float position[3];
 		float orientaiton[3];
 		float move_limitation_min[3];
 		float move_limitation_max[3];
 		float rotation_limitation_min[3];
 		float rotation_limitation_max[3];
 		float spring_move_coefficient[3];
 		float spring_rotation_coefficient[3];
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	class PmxJoint
 	{
 	public:
 		std::string joint_name;
 		std::string joint_english_name;
 		PmxJointType joint_type;
 		PmxJointParam param;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	enum PmxSoftBodyFlag : uint8_t
 	{
 		BLink = 0x01,
 		Cluster = 0x02,
 		Link = 0x04
 	};
 
 	class PmxAncherRigidBody
 	{
 	public:
 		PmxAncherRigidBody()
 			: related_rigid_body(0)
 			, related_vertex(0)
 			, is_near(false)
 		{}
 		int related_rigid_body;
 		int related_vertex;
 		bool is_near;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	class PmxSoftBody
 	{
 	public:
 		PmxSoftBody()
 			: shape(0)
 			, target_material(0)
 			, group(0)
 			, mask(0)
 			, blink_distance(0)
 			, cluster_count(0)
 			, mass(0.0)
 			, collisioni_margin(0.0)
 			, aero_model(0)
 			, VCF(0.0f)
 			, DP(0.0f)
 			, DG(0.0f)
 			, LF(0.0f)
 			, PR(0.0f)
 			, VC(0.0f)
 			, DF(0.0f)
 			, MT(0.0f)
 			, CHR(0.0f)
 			, KHR(0.0f)
 			, SHR(0.0f)
 			, AHR(0.0f)
 			, SRHR_CL(0.0f)
 			, SKHR_CL(0.0f)
 			, SSHR_CL(0.0f)
 			, SR_SPLT_CL(0.0f)
 			, SK_SPLT_CL(0.0f)
 			, SS_SPLT_CL(0.0f)
 			, V_IT(0)
 			, P_IT(0)
 			, D_IT(0)
 			, C_IT(0)
 			, LST(0.0f)
 			, AST(0.0f)
 			, VST(0.0f)
 			, anchor_count(0)
 			, pin_vertex_count(0)
 		{}
 		std::string soft_body_name;
 		std::string soft_body_english_name;
 		uint8_t shape;
 		int target_material;
 		uint8_t group;
 		uint16_t mask;
 		PmxSoftBodyFlag flag;
 		int blink_distance;
 		int cluster_count;
 		float mass;
 		float collisioni_margin;
 		int aero_model;
 		float VCF;
 		float DP;
 		float DG;
 		float LF;
 		float PR;
 		float VC;
 		float DF;
 		float MT;
 		float CHR;
 		float KHR;
 		float SHR;
 		float AHR;
 		float SRHR_CL;
 		float SKHR_CL;
 		float SSHR_CL;
 		float SR_SPLT_CL;
 		float SK_SPLT_CL;
 		float SS_SPLT_CL;
 		int V_IT;
 		int P_IT;
 		int D_IT;
 		int C_IT;
 		float LST;
 		float AST;
 		float VST;
 		int anchor_count;
 		std::unique_ptr<PmxAncherRigidBody []> anchers;
 		int pin_vertex_count;
 		std::unique_ptr<int []> pin_vertices;
 		void Read(std::istream *stream, PmxSetting *setting);
 	};
 
 	class PmxModel
 	{
 	public:
 		PmxModel()
 			: version(0.0f)
 			, vertex_count(0)
 			, index_count(0)
 			, texture_count(0)
 			, material_count(0)
 			, bone_count(0)
 			, morph_count(0)
 			, frame_count(0)
 			, rigid_body_count(0)
 			, joint_count(0)
 			, soft_body_count(0)
 		{}
 
 		float version;
 		PmxSetting setting;
 		std::string model_name;
 		std::string model_english_name;
 		std::string model_comment;
 		std::string model_english_comment;
 		int vertex_count;
 		std::unique_ptr<PmxVertex []> vertices;
 		int index_count;
 		std::unique_ptr<int []> indices;
 		int texture_count;
 		std::unique_ptr< std::string []> textures;
 		int material_count;
 		std::unique_ptr<PmxMaterial []> materials;
 		int bone_count;
 		std::unique_ptr<PmxBone []> bones;
 		int morph_count;
 		std::unique_ptr<PmxMorph []> morphs;
 		int frame_count;
 		std::unique_ptr<PmxFrame [] > frames;
 		int rigid_body_count;
 		std::unique_ptr<PmxRigidBody []> rigid_bodies;
 		int joint_count;
 		std::unique_ptr<PmxJoint []> joints;
 		int soft_body_count;
 		std::unique_ptr<PmxSoftBody []> soft_bodies;
 		void Init();
 		void Read(std::istream *stream);
 		//static std::unique_ptr<PmxModel> ReadFromFile(const char *filename);
 		//static std::unique_ptr<PmxModel> ReadFromStream(std::istream *stream);
 	};
 }
diff --git a/code/AssetLib/glTF/glTFAsset.inl b/code/AssetLib/glTF/glTFAsset.inl
index 1f4544156..86fba95b7 100644
--- a/code/AssetLib/glTF/glTFAsset.inl
+++ b/code/AssetLib/glTF/glTFAsset.inl
@@ -786,158 +786,158 @@ mr_skip_extensions:
 #ifdef ASSIMP_IMPORTER_GLTF_USE_OPEN3DGC
 inline void Mesh::Decode_O3DGC(const SCompression_Open3DGC &pCompression_Open3DGC, Asset &pAsset_Root) {
     typedef unsigned short IndicesType; ///< \sa glTFExporter::ExportMeshes.
 
     o3dgc::SC3DMCDecoder<IndicesType> decoder;
     o3dgc::IndexedFaceSet<IndicesType> ifs;
     o3dgc::BinaryStream bstream;
     uint8_t *decoded_data;
     size_t decoded_data_size = 0;
     Ref<Buffer> buf = pAsset_Root.buffers.Get(pCompression_Open3DGC.Buffer);
 
     // Read data from buffer and place it in BinaryStream for decoder.
     // Just "Count" because always is used type equivalent to uint8_t.
     bstream.LoadFromBuffer(&buf->GetPointer()[pCompression_Open3DGC.Offset], static_cast<unsigned long>(pCompression_Open3DGC.Count));
 
     // After decoding header we can get size of primitives.
     if (decoder.DecodeHeader(ifs, bstream) != o3dgc::O3DGC_OK) throw DeadlyImportError("GLTF: can not decode Open3DGC header.");
 
     /****************** Get sizes of arrays and check sizes ******************/
     // Note. See "Limitations for meshes when using Open3DGC-compression".
 
     // Indices
     size_t size_coordindex = ifs.GetNCoordIndex() * 3; // See float attributes note.
 
     if (primitives[0].indices->count != size_coordindex)
         throw DeadlyImportError("GLTF: Open3DGC. Compressed indices count (", ai_to_string(size_coordindex),
                 ") not equal to uncompressed (", ai_to_string(primitives[0].indices->count), ").");
 
     size_coordindex *= sizeof(IndicesType);
     // Coordinates
     size_t size_coord = ifs.GetNCoord(); // See float attributes note.
 
     if (primitives[0].attributes.position[0]->count != size_coord)
         throw DeadlyImportError("GLTF: Open3DGC. Compressed positions count (", ai_to_string(size_coord),
                 ") not equal to uncompressed (", ai_to_string(primitives[0].attributes.position[0]->count), ").");
 
     size_coord *= 3 * sizeof(float);
     // Normals
     size_t size_normal = ifs.GetNNormal(); // See float attributes note.
 
     if (primitives[0].attributes.normal[0]->count != size_normal)
         throw DeadlyImportError("GLTF: Open3DGC. Compressed normals count (", ai_to_string(size_normal),
                 ") not equal to uncompressed (", ai_to_string(primitives[0].attributes.normal[0]->count), ").");
 
     size_normal *= 3 * sizeof(float);
     // Additional attributes.
     std::vector<size_t> size_floatattr;
     std::vector<size_t> size_intattr;
 
     size_floatattr.resize(ifs.GetNumFloatAttributes());
     size_intattr.resize(ifs.GetNumIntAttributes());
 
     decoded_data_size = size_coordindex + size_coord + size_normal;
     for (size_t idx = 0, idx_end = size_floatattr.size(), idx_texcoord = 0; idx < idx_end; idx++) {
         // size = number_of_elements * components_per_element * size_of_component.
         // Note. But as you can see above, at first we are use this variable in meaning "count". After checking count of objects...
         size_t tval = ifs.GetNFloatAttribute(static_cast<unsigned long>(idx));
 
         switch (ifs.GetFloatAttributeType(static_cast<unsigned long>(idx))) {
         case o3dgc::O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_TEXCOORD:
             // Check situation when encoded data contain texture coordinates but primitive not.
             if (idx_texcoord < primitives[0].attributes.texcoord.size()) {
                 if (primitives[0].attributes.texcoord[idx]->count != tval)
                     throw DeadlyImportError("GLTF: Open3DGC. Compressed texture coordinates count (", ai_to_string(tval),
                             ") not equal to uncompressed (", ai_to_string(primitives[0].attributes.texcoord[idx]->count), ").");
 
                 idx_texcoord++;
             } else {
                 ifs.SetNFloatAttribute(static_cast<unsigned long>(idx), 0ul); // Disable decoding this attribute.
             }
 
             break;
         default:
             throw DeadlyImportError("GLTF: Open3DGC. Unsupported type of float attribute: ", ai_to_string(ifs.GetFloatAttributeType(static_cast<unsigned long>(idx))));
         }
 
         tval *= ifs.GetFloatAttributeDim(static_cast<unsigned long>(idx)) * sizeof(o3dgc::Real); // After checking count of objects we can get size of array.
         size_floatattr[idx] = tval;
         decoded_data_size += tval;
     }
 
     for (size_t idx = 0, idx_end = size_intattr.size(); idx < idx_end; idx++) {
         // size = number_of_elements * components_per_element * size_of_component. See float attributes note.
         size_t tval = ifs.GetNIntAttribute(static_cast<unsigned long>(idx));
         switch (ifs.GetIntAttributeType(static_cast<unsigned long>(idx))) {
         case o3dgc::O3DGC_IFS_INT_ATTRIBUTE_TYPE_UNKOWN:
         case o3dgc::O3DGC_IFS_INT_ATTRIBUTE_TYPE_INDEX:
         case o3dgc::O3DGC_IFS_INT_ATTRIBUTE_TYPE_JOINT_ID:
         case o3dgc::O3DGC_IFS_INT_ATTRIBUTE_TYPE_INDEX_BUFFER_ID:
             break;
 
         default:
             throw DeadlyImportError("GLTF: Open3DGC. Unsupported type of int attribute: ", ai_to_string(ifs.GetIntAttributeType(static_cast<unsigned long>(idx))));
         }
 
         tval *= ifs.GetIntAttributeDim(static_cast<unsigned long>(idx)) * sizeof(long); // See float attributes note.
         size_intattr[idx] = tval;
         decoded_data_size += tval;
     }
 
     // Create array for decoded data.
     decoded_data = new uint8_t[decoded_data_size];
 
     /****************** Set right array regions for decoder ******************/
 
     auto get_buf_offset = [](Ref<Accessor> &pAccessor) -> size_t { return pAccessor->byteOffset + pAccessor->bufferView->byteOffset; };
 
     // Indices
-    ifs.SetCoordIndex((IndicesType *const)(decoded_data + get_buf_offset(primitives[0].indices)));
+    ifs.SetCoordIndex((IndicesType *)(decoded_data + get_buf_offset(primitives[0].indices)));
     // Coordinates
-    ifs.SetCoord((o3dgc::Real *const)(decoded_data + get_buf_offset(primitives[0].attributes.position[0])));
+    ifs.SetCoord((o3dgc::Real *)(decoded_data + get_buf_offset(primitives[0].attributes.position[0])));
     // Normals
     if (size_normal) {
-        ifs.SetNormal((o3dgc::Real *const)(decoded_data + get_buf_offset(primitives[0].attributes.normal[0])));
+        ifs.SetNormal((o3dgc::Real *)(decoded_data + get_buf_offset(primitives[0].attributes.normal[0])));
     }
 
     for (size_t idx = 0, idx_end = size_floatattr.size(), idx_texcoord = 0; idx < idx_end; idx++) {
         switch (ifs.GetFloatAttributeType(static_cast<unsigned long>(idx))) {
         case o3dgc::O3DGC_IFS_FLOAT_ATTRIBUTE_TYPE_TEXCOORD:
             if (idx_texcoord < primitives[0].attributes.texcoord.size()) {
                 // See above about absent attributes.
-                ifs.SetFloatAttribute(static_cast<unsigned long>(idx), (o3dgc::Real *const)(decoded_data + get_buf_offset(primitives[0].attributes.texcoord[idx])));
+                ifs.SetFloatAttribute(static_cast<unsigned long>(idx), (o3dgc::Real *)(decoded_data + get_buf_offset(primitives[0].attributes.texcoord[idx])));
                 idx_texcoord++;
             }
 
             break;
         default:
             throw DeadlyImportError("GLTF: Open3DGC. Unsupported type of float attribute: ", ai_to_string(ifs.GetFloatAttributeType(static_cast<unsigned long>(idx))));
         }
     }
 
     for (size_t idx = 0, idx_end = size_intattr.size(); idx < idx_end; idx++) {
         switch (ifs.GetIntAttributeType(static_cast<unsigned int>(idx))) {
         case o3dgc::O3DGC_IFS_INT_ATTRIBUTE_TYPE_UNKOWN:
         case o3dgc::O3DGC_IFS_INT_ATTRIBUTE_TYPE_INDEX:
         case o3dgc::O3DGC_IFS_INT_ATTRIBUTE_TYPE_JOINT_ID:
         case o3dgc::O3DGC_IFS_INT_ATTRIBUTE_TYPE_INDEX_BUFFER_ID:
             break;
 
         // ifs.SetIntAttribute(idx, (long* const)(decoded_data + get_buf_offset(primitives[0].attributes.joint)));
         default:
             throw DeadlyImportError("GLTF: Open3DGC. Unsupported type of int attribute: ", ai_to_string(ifs.GetIntAttributeType(static_cast<unsigned long>(idx))));
         }
     }
 
     //
     // Decode data
     //
     if (decoder.DecodePayload(ifs, bstream) != o3dgc::O3DGC_OK) {
         throw DeadlyImportError("GLTF: can not decode Open3DGC data.");
     }
 
     // Set encoded region for "buffer".
     buf->EncodedRegion_Mark(pCompression_Open3DGC.Offset, pCompression_Open3DGC.Count, decoded_data, decoded_data_size, id);
     // No. Do not delete "output_data". After calling "EncodedRegion_Mark" bufferView is owner of "output_data".
     // "delete [] output_data;"
 }
 #endif
diff --git a/code/AssetLib/glTF2/glTF2Asset.h b/code/AssetLib/glTF2/glTF2Asset.h
index c597fc951..44ab6c9c8 100644
--- a/code/AssetLib/glTF2/glTF2Asset.h
+++ b/code/AssetLib/glTF2/glTF2Asset.h
@@ -331,49 +331,51 @@ const AttribType::Info
 struct CustomExtension {
 
     //
     // A struct containing custom extension data added to a glTF2 file
     // Has to contain Object, Array, String, Double, Uint64, and Int64 at a minimum
     // String, Double, Uint64, and Int64 are stored in the Nullables
     // Object and Array are stored in the std::vector
     //
     std::string name;
 
     Nullable<std::string> mStringValue;
     Nullable<double> mDoubleValue;
     Nullable<uint64_t> mUint64Value;
     Nullable<int64_t> mInt64Value;
     Nullable<bool> mBoolValue;
 
     // std::vector<CustomExtension> handles both Object and Array
     Nullable<std::vector<CustomExtension>> mValues;
 
     operator bool() const {
         return Size() != 0;
     }
 
     size_t Size() const {
         if (mValues.isPresent) {
             return mValues.value.size();
         } else if (mStringValue.isPresent || mDoubleValue.isPresent || mUint64Value.isPresent || mInt64Value.isPresent || mBoolValue.isPresent) {
             return 1;
         }
         return 0;
     }
 
     CustomExtension() = default;
 
     ~CustomExtension() = default;
 
     CustomExtension(const CustomExtension &other) :
             name(other.name),
             mStringValue(other.mStringValue),
             mDoubleValue(other.mDoubleValue),
             mUint64Value(other.mUint64Value),
             mInt64Value(other.mInt64Value),
             mBoolValue(other.mBoolValue),
             mValues(other.mValues) {
         // empty
     }
+
+    CustomExtension& operator=(const CustomExtension&) = default;
 };
 
 //! Base class for all glTF top-level objects
diff --git a/contrib/clipper/clipper.cpp b/contrib/clipper/clipper.cpp
index 857cd1c3e..2d02aff67 100644
--- a/contrib/clipper/clipper.cpp
+++ b/contrib/clipper/clipper.cpp
@@ -77,188 +77,195 @@ inline long64 Abs(long64 val)
 class Int128
 {
   public:
 
     Int128(long64 _lo = 0)
     {
       lo = _lo;
       if (lo < 0) hi = -1; else hi = 0;
     }
 
     Int128(const Int128 &val): hi(val.hi), lo(val.lo){}
 
+    Int128 operator = (const Int128 &val)
+    {
+        lo = val.lo;
+        hi = val.hi;
+        return val;
+    }
+
     long64 operator = (const long64 &val)
     {
       lo = val;
       if (lo < 0) hi = -1; else hi = 0;
       return val;
     }
 
     bool operator == (const Int128 &val) const
       {return (hi == val.hi && lo == val.lo);}
 
     bool operator != (const Int128 &val) const
       { return !(*this == val);}
 
     bool operator > (const Int128 &val) const
     {
       if (hi != val.hi)
         return hi > val.hi;
       else
         return lo > val.lo;
     }
 
     bool operator < (const Int128 &val) const
     {
       if (hi != val.hi)
         return hi < val.hi;
       else
         return lo < val.lo;
     }
 
     bool operator >= (const Int128 &val) const
       { return !(*this < val);}
 
     bool operator <= (const Int128 &val) const
       { return !(*this > val);}
 
     Int128& operator += (const Int128 &rhs)
     {
       hi += rhs.hi;
       lo += rhs.lo;
       if (ulong64(lo) < ulong64(rhs.lo)) hi++;
       return *this;
     }
 
     Int128 operator + (const Int128 &rhs) const
     {
       Int128 result(*this);
       result+= rhs;
       return result;
     }
 
     Int128& operator -= (const Int128 &rhs)
     {
       Int128 tmp(rhs);
       Negate(tmp);
       *this += tmp;
       return *this;
     }
 
     //Int128 operator -() const
     //{
     //  Int128 result(*this);
     //  if (result.lo == 0) {
     //    if (result.hi != 0) result.hi = -1;
     //  }
     //  else {
     //    result.lo = -result.lo;
     //    result.hi = ~result.hi;
     //  }
     //  return result;
     //}
 
     Int128 operator - (const Int128 &rhs) const
     {
       Int128 result(*this);
       result -= rhs;
       return result;
     }
 
     Int128 operator * (const Int128 &rhs) const
     {
       if ( !(hi == 0 || hi == -1) || !(rhs.hi == 0 || rhs.hi == -1))
         throw "Int128 operator*: overflow error";
       bool negate = (hi < 0) != (rhs.hi < 0);
 
       Int128 tmp(*this);
       if (tmp.hi < 0) Negate(tmp);
       ulong64 int1Hi = ulong64(tmp.lo) >> 32;
       ulong64 int1Lo = ulong64(tmp.lo & 0xFFFFFFFF);
 
       tmp = rhs;
       if (tmp.hi < 0) Negate(tmp);
       ulong64 int2Hi = ulong64(tmp.lo) >> 32;
       ulong64 int2Lo = ulong64(tmp.lo & 0xFFFFFFFF);
 
       //nb: see comments in clipper.pas
       ulong64 a = int1Hi * int2Hi;
       ulong64 b = int1Lo * int2Lo;
       ulong64 c = int1Hi * int2Lo + int1Lo * int2Hi;
 
       tmp.hi = long64(a + (c >> 32));
       tmp.lo = long64(c << 32);
       tmp.lo += long64(b);
       if (ulong64(tmp.lo) < b) tmp.hi++;
       if (negate) Negate(tmp);
       return tmp;
     }
 
     Int128 operator/ (const Int128 &rhs) const
     {
       if (rhs.lo == 0 && rhs.hi == 0)
         throw "Int128 operator/: divide by zero";
       bool negate = (rhs.hi < 0) != (hi < 0);
       Int128 result(*this), denom(rhs);
       if (result.hi < 0) Negate(result);
       if (denom.hi < 0)  Negate(denom);
       if (denom > result) return Int128(0); //result is only a fraction of 1
       Negate(denom);
 
       Int128 p(0);
       for (int i = 0; i < 128; ++i)
       {
         p.hi = p.hi << 1;
         if (p.lo < 0) p.hi++;
         p.lo = long64(p.lo) << 1;
         if (result.hi < 0) p.lo++;
         result.hi = result.hi << 1;
         if (result.lo < 0) result.hi++;
         result.lo = long64(result.lo) << 1;
         Int128 p2(p);
         p += denom;
         if (p.hi < 0) p = p2;
         else result.lo++;
       }
       if (negate) Negate(result);
       return result;
     }
 
     double AsDouble() const
     {
       const double shift64 = 18446744073709551616.0; //2^64
       const double bit64 = 9223372036854775808.0;
       if (hi < 0)
       {
         Int128 tmp(*this);
         Negate(tmp);
         if (tmp.lo < 0)
           return (double)tmp.lo - bit64 - tmp.hi * shift64;
         else
           return -(double)tmp.lo - tmp.hi * shift64;
       }
       else if (lo < 0)
         return -(double)lo + bit64 + hi * shift64;
       else
         return (double)lo + (double)hi * shift64;
     }
 
     //for bug testing ...
     //std::string AsString() const
     //{
     //  std::string result;
     //  unsigned char r = 0;
     //  Int128 tmp(0), val(*this);
     //  if (hi < 0) Negate(val);
     //  result.resize(50);
     //  std::string::size_type i = result.size() -1;
     //  while (val.hi != 0 || val.lo != 0)
     //  {
     //    Div10(val, tmp, r);
     //    result[i--] = char('0' + r);
     //    val = tmp;
     //  }
     //  if (hi < 0) result[i--] = '-';
     //  result.erase(0,i+1);
     //  if (result.size() == 0) result = "0";
     //  return result;
     //}
