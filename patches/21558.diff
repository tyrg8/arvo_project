commit 5d093ebce2e044b77e6c77686e4ace7af0f9eaed
Merge: 47a93a942e cad107b6ef
Author: Even Rouault <even.rouault@spatialys.com>
Date:   Fri Apr 3 10:37:38 2020 +0200

    Merge pull request #2370 from rouault/StripTOWGS84IfKnownDatum
    
    Strip TOWGS84 when datum is known, in GTiff, Spatialite and GPKG drivers

diff --git a/autotest/cpp/test_osr.cpp b/autotest/cpp/test_osr.cpp
index 6a817b2093..252ebf233b 100644
--- a/autotest/cpp/test_osr.cpp
+++ b/autotest/cpp/test_osr.cpp
@@ -1,33 +1,34 @@
 ///////////////////////////////////////////////////////////////////////////////
 //
 // Project:  C++ Test Suite for GDAL/OGR
 // Purpose:  OGR Spatial Reference general features test.
 // Author:   Mateusz Loskot <mateusz@loskot.net>
 //
 ///////////////////////////////////////////////////////////////////////////////
 // Copyright (c) 2006, Mateusz Loskot <mateusz@loskot.net>
 //
 // This library is free software; you can redistribute it and/or
 // modify it under the terms of the GNU Library General Public
 // License as published by the Free Software Foundation; either
 // version 2 of the License, or (at your option) any later version.
 //
 // This library is distributed in the hope that it will be useful,
 // but WITHOUT ANY WARRANTY; without even the implied warranty of
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 // Library General Public License for more details.
 //
 // You should have received a copy of the GNU Library General Public
 // License along with this library; if not, write to the
 // Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 // Boston, MA 02111-1307, USA.
 ///////////////////////////////////////////////////////////////////////////////
 
 #include "gdal_unit_test.h"
 
 #include "cpl_string.h"
 #include "ogr_srs_api.h"
+#include "ogr_spatialref.h"
 
 #include <algorithm>
 #include <cmath>
 #include <string>
@@ -35,311 +36,383 @@
 namespace tut
 {
 
     // Common fixture with test data
     struct test_osr_data
     {
         OGRErr err_;
         OGRSpatialReferenceH srs_;
 
         test_osr_data()
             : err_(OGRERR_NONE), srs_(nullptr)
         {
             srs_ = OSRNewSpatialReference(nullptr);
         }
 
         ~test_osr_data()
         {
             OSRDestroySpatialReference(srs_);
         }
     };
 
     // Register test group
     typedef test_group<test_osr_data> group;
     typedef group::object object;
     group test_osr_group("OSR");
 
     // Test UTM WGS84 coordinate system and its various items
     template<>
     template<>
     void object::test<1>()
     {
         ensure("SRS handle is NULL", nullptr != srs_);
 
         err_ = OSRSetUTM(srs_, 11, TRUE);
         ensure_equals("Can't set UTM zone", err_, OGRERR_NONE);
 
         err_ = OSRSetWellKnownGeogCS(srs_, "WGS84");
         ensure_equals("Can't set GeogCS", err_, OGRERR_NONE);
 
         double val = 0;
 
         val = OSRGetProjParm(srs_, SRS_PP_CENTRAL_MERIDIAN, -1111, &err_);
         ensure("Invalid UTM central meridian",
             std::fabs(val - (-117.0)) <= .00000000000010);
 
         val = OSRGetProjParm(srs_, SRS_PP_LATITUDE_OF_ORIGIN, -1111, &err_);
         ensure("Invalid UTM latitude of origin",
             std::fabs(val - 0.0) <= .00000000000010);
 
         val = OSRGetProjParm(srs_, SRS_PP_SCALE_FACTOR, -1111, &err_);
         ensure("Invalid UTM scale factor",
             std::fabs(val - 0.9996) <= .00000000000010);
 
         val = OSRGetProjParm(srs_, SRS_PP_FALSE_EASTING, -1111, &err_);
         ensure("Invalid UTM false easting",
             std::fabs(val - 500000.0) <= .00000000000010);
 
         val = OSRGetProjParm(srs_, SRS_PP_FALSE_NORTHING, -1111, &err_);
         ensure("Invalid UTM false northing",
             std::fabs(val - 0.0) <= .00000000000010);
 
         ensure_equals("Invalid authority name",
             std::string(OSRGetAuthorityName(srs_, "GEOGCS")), std::string("EPSG"));
         ensure_equals("Invalid authority code",
             std::string(OSRGetAuthorityCode(srs_, "GEOGCS")), std::string("4326"));
 
         ensure_equals("Invalid authority name",
             std::string(OSRGetAuthorityName(srs_, "DATUM")), std::string("EPSG"));
         ensure_equals("Invalid authority code",
             std::string(OSRGetAuthorityCode(srs_, "DATUM")), std::string("6326"));
     }
 
     // Simple default NAD83 State Plane zone
     template<>
     template<>
     void object::test<2>()
     {
         ensure("SRS handle is NULL", nullptr != srs_);
 
         // California III NAD83
         OSRSetStatePlane(srs_, 403, 1);
 
         double val = 0;
 
         val = OSRGetProjParm(srs_, SRS_PP_STANDARD_PARALLEL_1, -1111, &err_);
         ensure_approx_equals(val, 38.43333333333333);
 
         val = OSRGetProjParm(srs_, SRS_PP_STANDARD_PARALLEL_2, -1111, &err_);
         ensure_approx_equals(val, 37.06666666666667);
 
         val = OSRGetProjParm(srs_, SRS_PP_LATITUDE_OF_ORIGIN, -1111, &err_);
         ensure_approx_equals(val, 36.5);
 
         val = OSRGetProjParm(srs_, SRS_PP_CENTRAL_MERIDIAN, -1111, &err_);
         ensure_approx_equals(val, -120.5);
 
         val = OSRGetProjParm(srs_, SRS_PP_FALSE_EASTING, -1111, &err_);
         ensure_approx_equals(val, 2000000.0);
 
         val = OSRGetProjParm(srs_, SRS_PP_FALSE_NORTHING, -1111, &err_);
         ensure_approx_equals(val, 500000.0);
 
         ensure_equals("Invalid authority name",
             std::string(OSRGetAuthorityName(srs_, "GEOGCS")), std::string("EPSG"));
         ensure_equals("Invalid authority code",
             std::string(OSRGetAuthorityCode(srs_, "GEOGCS")), std::string("4269"));
 
         ensure_equals("Invalid authority name",
             std::string(OSRGetAuthorityName(srs_, "DATUM")), std::string("EPSG"));
         ensure_equals("Invalid authority code",
             std::string(OSRGetAuthorityCode(srs_, "DATUM")), std::string("6269"));
 
         ensure_equals("Invalid authority name",
             std::string(OSRGetAuthorityName(srs_, "PROJCS")), std::string("EPSG"));
         ensure_equals("Invalid authority code",
             std::string(OSRGetAuthorityCode(srs_, "PROJCS")), std::string("26943"));
 
         ensure_equals("Invalid authority name",
             std::string(OSRGetAuthorityName(srs_, "PROJCS|UNIT")), std::string("EPSG"));
         ensure_equals("Invalid authority code",
             std::string(OSRGetAuthorityCode(srs_, "PROJCS|UNIT")), std::string("9001"));
     }
 
     // NAD83 State Plane zone, but overridden to be in Feet
     template<>
     template<>
     void object::test<3>()
     {
         ensure("SRS handle is NULL", nullptr != srs_);
 
         // California III NAD83 (feet)
         OSRSetStatePlaneWithUnits(srs_, 403, 1, "Foot", 0.3048006096012192);
 
         double val = 0;
 
         val = OSRGetProjParm(srs_, SRS_PP_STANDARD_PARALLEL_1, -1111, &err_);
         ensure_approx_equals(val, 38.43333333333333);
 
         val = OSRGetProjParm(srs_, SRS_PP_STANDARD_PARALLEL_2, -1111, &err_);
         ensure_approx_equals(val, 37.06666666666667);
 
         val = OSRGetProjParm(srs_, SRS_PP_LATITUDE_OF_ORIGIN, -1111, &err_);
         ensure_approx_equals(val, 36.5);
 
         val = OSRGetProjParm(srs_, SRS_PP_CENTRAL_MERIDIAN, -1111, &err_);
         ensure_approx_equals(val, -120.5);
 
         val = OSRGetProjParm(srs_, SRS_PP_FALSE_EASTING, -1111, &err_);
         ensure_approx_equals(val, 6561666.666666667);
 
         val = OSRGetProjParm(srs_, SRS_PP_FALSE_NORTHING, -1111, &err_);
         ensure_approx_equals(val, 1640416.666666667);
 
         ensure_equals("Invalid authority name",
             std::string(OSRGetAuthorityName(srs_, "GEOGCS")), std::string("EPSG"));
         ensure_equals("Invalid authority code",
             std::string(OSRGetAuthorityCode(srs_, "GEOGCS")), std::string("4269"));
 
         ensure_equals("Invalid authority name",
             std::string(OSRGetAuthorityName(srs_, "DATUM")), std::string("EPSG"));
         ensure_equals("Invalid authority code",
             std::string(OSRGetAuthorityCode(srs_, "DATUM")), std::string("6269"));
 
         ensure("Got a PROJCS Authority but we should not",
             nullptr == OSRGetAuthorityName(srs_, "PROJCS"));
 
         ensure("Got METER authority code on linear units",
             nullptr == OSRGetAuthorityCode(srs_, "PROJCS|UNIT"));
 
         char* unitsName = nullptr;
         val = OSRGetLinearUnits(srs_, &unitsName);
         ensure("Units name is NULL", nullptr != unitsName);
         ensure( "Did not get Foot linear units",
                 std::string("Foot") == unitsName);
     }
 
     // Translate a coordinate system with NAD shift into to PROJ.4 and back.
     // Also, verify that the TOWGS84 parameters are preserved.
     template<>
     template<>
     void object::test<4>()
     {
         ensure("SRS handle is NULL", nullptr != srs_);
 
         err_ = OSRSetGS(srs_, -117.0, 100000.0, 100000);
         ensure_equals("OSRSetGS failed", err_, OGRERR_NONE);
 
         err_ = OSRSetGeogCS(srs_, "Test GCS", "Test Datum", "WGS84",
             SRS_WGS84_SEMIMAJOR, SRS_WGS84_INVFLATTENING,
             nullptr, 0, nullptr, 0);
         ensure_equals("OSRSetGeogCS failed", err_, OGRERR_NONE);
 
         err_ = OSRSetTOWGS84(srs_, 1, 2, 3, 0, 0, 0, 0);
         ensure_equals("OSRSetTOWGS84 failed", err_, OGRERR_NONE);
 
         const int coeffSize = 7;
         double coeff[coeffSize] = { 0 };
         const double expect[coeffSize] = { 1, 2, 3, 0, 0, 0, 0 };
 
         err_ = OSRGetTOWGS84(srs_, coeff, 7);
         ensure_equals("OSRSetTOWGS84 failed", err_, OGRERR_NONE);
         ensure("GetTOWGS84 result is wrong",
             std::equal(coeff, coeff + coeffSize, expect));
         OSRSetLinearUnits(srs_, "Metre", 1);
 
         char* proj4 = nullptr;
         err_ = OSRExportToProj4(srs_, &proj4);
         ensure_equals("OSRExportToProj4 failed", err_, OGRERR_NONE);
 
         OGRSpatialReferenceH srs2 = nullptr;
         srs2 = OSRNewSpatialReference(nullptr);
 
         err_ = OSRImportFromProj4(srs2, proj4);
         ensure_equals("OSRImportFromProj4 failed", err_, OGRERR_NONE);
 
         err_ = OSRGetTOWGS84(srs2, coeff, 7);
         ensure_equals("OSRSetTOWGS84 failed", err_, OGRERR_NONE);
         ensure("GetTOWGS84 result is wrong",
             std::equal(coeff, coeff + coeffSize, expect));
 
         OSRDestroySpatialReference(srs2);
         CPLFree(proj4);
     }
 
     // Test URN support for OGC:CRS84
     template<>
     template<>
     void object::test<5>()
     {
         ensure("SRS handle is NULL", nullptr != srs_);
 
         err_ = OSRSetFromUserInput(srs_, "urn:ogc:def:crs:OGC:1.3:CRS84");
         ensure_equals("OSRSetFromUserInput failed", err_, OGRERR_NONE);
 
         char* wkt1 = nullptr;
         err_ = OSRExportToWkt(srs_, &wkt1);
         ensure_equals("OSRExportToWkt failed", err_, OGRERR_NONE);
         ensure("OSRExportToWkt returned NULL", nullptr != wkt1);
 
         CPLFree(wkt1);
     }
 
     // Test URN support for EPSG
     template<>
     template<>
     void object::test<6>()
     {
         ensure("SRS handle is NULL", nullptr != srs_);
 
         err_ = OSRSetFromUserInput(srs_, "urn:ogc:def:crs:EPSG::4326");
         ensure_equals("OSRSetFromUserInput failed", err_, OGRERR_NONE);
 
         char* wkt1 = nullptr;
         err_ = OSRExportToWkt(srs_, &wkt1);
         ensure_equals("OSRExportToWkt failed", err_, OGRERR_NONE);
         ensure("OSRExportToWkt returned NULL", nullptr != wkt1);
 
         err_ = OSRSetFromUserInput(srs_, "EPSGA:4326");
         ensure_equals("OSRSetFromUserInput failed", err_, OGRERR_NONE);
 
         char* wkt2 = nullptr;
         err_ = OSRExportToWkt(srs_, &wkt2);
         ensure_equals("OSRExportToWkt failed", err_, OGRERR_NONE);
         ensure("OSRExportToWkt returned NULL", nullptr != wkt2);
 
         ensure_equals("EPSG:4326 urn lookup not as expected",
             std::string(wkt1), std::string(wkt2));
         CPLFree(wkt1);
         CPLFree(wkt2);
     }
 
     // Test URN support for auto projection
     template<>
     template<>
     void object::test<7 >()
     {
         ensure("SRS handle is NULL", nullptr != srs_);
 
         err_ = OSRSetFromUserInput(srs_, "urn:ogc:def:crs:OGC::AUTO42001:-117:33");
         ensure_equals("OSRSetFromUserInput failed", err_, OGRERR_NONE);
 
         char* wkt1 = nullptr;
         err_ = OSRExportToWkt(srs_, &wkt1);
         ensure_equals("OSRExportToWkt failed", err_, OGRERR_NONE);
         ensure("OSRExportToWkt returned NULL", nullptr != wkt1);
 
         std::string expect("PROJCS[\"unnamed\",GEOGCS[\"WGS 84\","
                            "DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\","
                            "6378137,298.257223563,"
                            "AUTHORITY[\"EPSG\",\"7030\"]],"
                            "AUTHORITY[\"EPSG\",\"6326\"]],"
                            "PRIMEM[\"Greenwich\",0,"
                            "AUTHORITY[\"EPSG\",\"8901\"]],"
                            "UNIT[\"degree\",0.0174532925199433,"
                            "AUTHORITY[\"EPSG\",\"9122\"]],"
                            "AUTHORITY[\"EPSG\",\"4326\"]],"
                            "PROJECTION[\"Transverse_Mercator\"],"
                            "PARAMETER[\"latitude_of_origin\",0],"
                            "PARAMETER[\"central_meridian\",-117],"
                            "PARAMETER[\"scale_factor\",0.9996],"
                            "PARAMETER[\"false_easting\",500000],"
                            "PARAMETER[\"false_northing\",0],"
                            "UNIT[\"Meter\",1,AUTHORITY[\"EPSG\",\"9001\"]],"
                            "AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]");
 
         ensure_equals("AUTO42001 urn lookup not as expected", std::string(wkt1), expect);
         CPLFree(wkt1);
     }
 
+    // Test StripTOWGS84IfKnownDatum
+    template<>
+    template<>
+    void object::test<8 >()
+    {
+        // Not a boundCRS
+        {
+            OGRSpatialReference oSRS;
+            oSRS.importFromEPSG(4326);
+            ensure(!oSRS.StripTOWGS84IfKnownDatum());
+        }
+        // Custom boundCRS --> do not strip TOWGS84
+        {
+            OGRSpatialReference oSRS;
+            oSRS.SetFromUserInput("+proj=longlat +ellps=GRS80 +towgs84=1,2,3,4,5,6,7");
+            ensure(!oSRS.StripTOWGS84IfKnownDatum());
+            double vals[7] = { 0 };
+            ensure(oSRS.GetTOWGS84(vals, 7) == OGRERR_NONE);
+        }
+        // BoundCRS whose base CRS has a known code --> strip TOWGS84
+        {
+            OGRSpatialReference oSRS;
+            oSRS.importFromEPSG(4326);
+            oSRS.SetTOWGS84(1,2,3,4,5,6,7);
+            ensure(oSRS.StripTOWGS84IfKnownDatum());
+            double vals[7] = { 0 };
+            ensure(oSRS.GetTOWGS84(vals, 7) != OGRERR_NONE);
+        }
+        // BoundCRS whose datum code is known --> strip TOWGS84
+        {
+            OGRSpatialReference oSRS;
+            oSRS.SetFromUserInput(
+                "GEOGCS[\"bar\","
+                "DATUM[\"foo\","
+                "SPHEROID[\"WGS 84\",6378137,298.257223563],"
+                "TOWGS84[1,2,3,4,5,6,7],"
+                "AUTHORITY[\"FOO\",\"1\"]],"
+                "PRIMEM[\"Greenwich\",0],"
+                "UNIT[\"degree\",0.0174532925199433]]");
+            ensure(oSRS.StripTOWGS84IfKnownDatum());
+            double vals[7] = { 0 };
+            ensure(oSRS.GetTOWGS84(vals, 7) != OGRERR_NONE);
+        }
+        // BoundCRS whose datum name is known --> strip TOWGS84
+        {
+            OGRSpatialReference oSRS;
+            oSRS.SetFromUserInput(
+                "GEOGCS[\"WGS 84\","
+                "DATUM[\"WGS_1984\","
+                "SPHEROID[\"WGS 84\",6378137,298.257223563],"
+                "TOWGS84[1,2,3,4,5,6,7]],"
+                "PRIMEM[\"Greenwich\",0],"
+                "UNIT[\"degree\",0.0174532925199433]]");
+            ensure(oSRS.StripTOWGS84IfKnownDatum());
+            double vals[7] = { 0 };
+            ensure(oSRS.GetTOWGS84(vals, 7) != OGRERR_NONE);
+        }
+        // BoundCRS whose datum name is unknown --> do not strip TOWGS84
+        {
+            OGRSpatialReference oSRS;
+            oSRS.SetFromUserInput(
+                "GEOGCS[\"WGS 84\","
+                "DATUM[\"i am unknown\","
+                "SPHEROID[\"WGS 84\",6378137,298.257223563],"
+                "TOWGS84[1,2,3,4,5,6,7]],"
+                "PRIMEM[\"Greenwich\",0],"
+                "UNIT[\"degree\",0.0174532925199433]]");
+            ensure(!oSRS.StripTOWGS84IfKnownDatum());
+            double vals[7] = { 0 };
+            ensure(oSRS.GetTOWGS84(vals, 7) == OGRERR_NONE);
+        }
+    }
 
 } // namespace tut
diff --git a/autotest/gcore/tiff_srs.py b/autotest/gcore/tiff_srs.py
index 110992667e..d346f28c0f 100755
--- a/autotest/gcore/tiff_srs.py
+++ b/autotest/gcore/tiff_srs.py
@@ -362,13 +362,23 @@ def test_tiff_srs_imagine_localcs_citation():
 # override the default coming from EPSG
 
 
-def test_tiff_srs_towgs84_override():
+def test_tiff_srs_towgs84_override_OSR_STRIP_TOWGS84_NO():
+
+    with gdaltest.config_option('OSR_STRIP_TOWGS84', 'NO'):
+        ds = gdal.Open('data/gtiff_towgs84_override.tif')
+        wkt = ds.GetProjectionRef()
+    ds = None
+
+    assert 'TOWGS84[584.8,67,400.3,0.105,0.013,-2.378,10.29]' in wkt, wkt
+
+
+def test_tiff_srs_towgs84_override_OSR_STRIP_TOWGS84_default():
 
     ds = gdal.Open('data/gtiff_towgs84_override.tif')
     wkt = ds.GetProjectionRef()
     ds = None
 
-    assert 'TOWGS84[584.8,67,400.3,0.105,0.013,-2.378,10.29]' in wkt, wkt
+    assert 'TOWGS84' not in wkt
 
 ###############################################################################
 # Test reading PCSCitationGeoKey (#7199)
@@ -680,54 +690,56 @@ def test_tiff_srs_towgs84_from_epsg_do_not_write_it():
 def test_tiff_srs_towgs84_from_epsg_force_write_it():
 
     filename = '/vsimem/test.tif'
     ds = gdal.GetDriverByName('GTiff').Create(filename, 1, 1)
     srs_in = osr.SpatialReference()
     srs_in.ImportFromEPSG(31468)
     srs_in.AddGuessedTOWGS84()
     assert srs_in.HasTOWGS84()
     with gdaltest.config_option('GTIFF_WRITE_TOWGS84', 'YES'):
         ds.SetSpatialRef(srs_in)
         ds = None
 
-    ds = gdal.Open(filename)
-    with gdaltest.config_option('OSR_ADD_TOWGS84_ON_IMPORT_FROM_EPSG', 'NO'):
-        srs = ds.GetSpatialRef()
+    with gdaltest.config_option('OSR_STRIP_TOWGS84', 'NO'):
+        ds = gdal.Open(filename)
+        with gdaltest.config_option('OSR_ADD_TOWGS84_ON_IMPORT_FROM_EPSG', 'NO'):
+            srs = ds.GetSpatialRef()
     assert srs.HasTOWGS84()
 
 
 def test_tiff_srs_towgs84_with_epsg_code_but_non_default_TOWGS84():
 
     filename = '/vsimem/test.tif'
     ds = gdal.GetDriverByName('GTiff').Create(filename, 1, 1)
     srs_in = osr.SpatialReference()
     srs_in.SetFromUserInput("""PROJCS["DHDN / 3-degree Gauss-Kruger zone 4",
     GEOGCS["DHDN",
         DATUM["Deutsches_Hauptdreiecksnetz",
             SPHEROID["Bessel 1841",6377397.155,299.1528128,
                 AUTHORITY["EPSG","7004"]],
             TOWGS84[1,2,3,4,5,6,7],
             AUTHORITY["EPSG","6314"]],
         PRIMEM["Greenwich",0,
             AUTHORITY["EPSG","8901"]],
         UNIT["degree",0.0174532925199433,
             AUTHORITY["EPSG","9122"]],
         AUTHORITY["EPSG","4314"]],
     PROJECTION["Transverse_Mercator"],
     PARAMETER["latitude_of_origin",0],
     PARAMETER["central_meridian",12],
     PARAMETER["scale_factor",1],
     PARAMETER["false_easting",4500000],
     PARAMETER["false_northing",0],
     UNIT["metre",1,
         AUTHORITY["EPSG","9001"]],
     AXIS["Northing",NORTH],
     AXIS["Easting",EAST],
     AUTHORITY["EPSG","31468"]]""")
     ds.SetSpatialRef(srs_in)
     ds = None
 
-    ds = gdal.Open(filename)
-    srs = ds.GetSpatialRef()
+    with gdaltest.config_option('OSR_STRIP_TOWGS84', 'NO'):
+        ds = gdal.Open(filename)
+        srs = ds.GetSpatialRef()
     assert srs.GetTOWGS84() == (1,2,3,4,5,6,7)
 
 
diff --git a/gdal/frmts/gtiff/gt_wkt_srs.cpp b/gdal/frmts/gtiff/gt_wkt_srs.cpp
index eb4fe362a9..0c6b2ab83f 100644
--- a/gdal/frmts/gtiff/gt_wkt_srs.cpp
+++ b/gdal/frmts/gtiff/gt_wkt_srs.cpp
@@ -311,1080 +311,1092 @@ int GDALGTIFKeyGetDOUBLE( GTIF *hGTIF, geokey_t key,
 OGRSpatialReferenceH GTIFGetOGISDefnAsOSR( GTIF *hGTIF, GTIFDefn * psDefn )
 
 {
     OGRSpatialReference oSRS;
 
     LibgeotiffOneTimeInit();
 
 #if LIBGEOTIFF_VERSION >= 1600
     void* projContext = GTIFGetPROJContext(hGTIF, FALSE, nullptr);
 #endif
 
 /* -------------------------------------------------------------------- */
 /*  Handle non-standard coordinate systems where GTModelTypeGeoKey      */
 /*  is not defined, but ProjectedCSTypeGeoKey is defined (ticket #3019) */
 /* -------------------------------------------------------------------- */
     if( psDefn->Model == KvUserDefined && psDefn->PCS != KvUserDefined)
     {
         psDefn->Model = ModelTypeProjected;
     }
 
 /* -------------------------------------------------------------------- */
 /*      Handle non-standard coordinate systems as LOCAL_CS.             */
 /* -------------------------------------------------------------------- */
     if( psDefn->Model != ModelTypeProjected
         && psDefn->Model != ModelTypeGeographic
         && psDefn->Model != ModelTypeGeocentric )
     {
         char szPeStr[2400] = { '\0' };
 
         /** check if there is a pe string citation key **/
         if( GDALGTIFKeyGetASCII( hGTIF, PCSCitationGeoKey, szPeStr,
                                  0, sizeof(szPeStr) ) &&
             strstr(szPeStr, "ESRI PE String = " ) )
         {
             const char* pszWKT = szPeStr + strlen("ESRI PE String = ");
             oSRS.importFromWkt(pszWKT);
 
             if( strstr( pszWKT,
                         "PROJCS[\"WGS_1984_Web_Mercator_Auxiliary_Sphere\"" ) )
             {
                 oSRS.SetExtension(
                     "PROJCS", "PROJ4",
                     "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 "
                     "+x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null "
                     "+wktext  +no_defs" );  // TODO(schwehr): Why 2 spaces?
             }
 
             return OGRSpatialReference::ToHandle(oSRS.Clone());
         }
         else
         {
             char *pszUnitsName = nullptr;
             char szPCSName[300] = { '\0' };
             int nKeyCount = 0;
             int anVersion[3] = { 0 };
 
             GTIFDirectoryInfo( hGTIF, anVersion, &nKeyCount );
 
             if( nKeyCount > 0 ) // Use LOCAL_CS if we have any geokeys at all.
             {
                 // Handle citation.
                 strcpy( szPCSName, "unnamed" );
                 if( !GDALGTIFKeyGetASCII( hGTIF, GTCitationGeoKey, szPCSName,
                                           0, sizeof(szPCSName) ) )
                     GDALGTIFKeyGetASCII( hGTIF, GeogCitationGeoKey, szPCSName,
                                          0, sizeof(szPCSName) );
 
                 GTIFCleanupImagineNames( szPCSName );
                 oSRS.SetLocalCS( szPCSName );
 
                 // Handle units
                 if( psDefn->UOMLength != KvUserDefined )
                 {
 #if LIBGEOTIFF_VERSION >= 1600
                     GTIFGetUOMLengthInfoEx( projContext,
 #else
                     GTIFGetUOMLengthInfo(
 #endif
                         psDefn->UOMLength, &pszUnitsName, nullptr );
                 }
 
                 if( pszUnitsName != nullptr )
                 {
                     char szUOMLength[12];
                     snprintf(szUOMLength, sizeof(szUOMLength),
                              "%d", psDefn->UOMLength );
                     oSRS.SetTargetLinearUnits(
                         nullptr, pszUnitsName, psDefn->UOMLengthInMeters,
                         "EPSG", szUOMLength);
                 }
                 else
                     oSRS.SetLinearUnits( "unknown", psDefn->UOMLengthInMeters );
 
                 GTIFFreeMemory( pszUnitsName );
             }
             return OGRSpatialReference::ToHandle(oSRS.Clone());
         }
     }
 
 /* -------------------------------------------------------------------- */
 /*      Handle Geocentric coordinate systems.                           */
 /* -------------------------------------------------------------------- */
     if( psDefn->Model == ModelTypeGeocentric )
     {
         char szName[300] = { '\0' };
 
         strcpy( szName, "unnamed" );
         if( !GDALGTIFKeyGetASCII( hGTIF, GTCitationGeoKey, szName,
                                   0, sizeof(szName) ) )
             GDALGTIFKeyGetASCII( hGTIF, GeogCitationGeoKey, szName,
                                  0, sizeof(szName) );
 
         oSRS.SetGeocCS( szName );
 
         char *pszUnitsName = nullptr;
 
         if( psDefn->UOMLength != KvUserDefined )
         {
 #if LIBGEOTIFF_VERSION >= 1600
             GTIFGetUOMLengthInfoEx( projContext,
 #else
             GTIFGetUOMLengthInfo(
 #endif
                 psDefn->UOMLength, &pszUnitsName, nullptr );
         }
 
         if( pszUnitsName != nullptr )
         {
             char szUOMLength[12];
                     snprintf(szUOMLength, sizeof(szUOMLength),
                              "%d", psDefn->UOMLength );
             oSRS.SetTargetLinearUnits( nullptr,
                 pszUnitsName, psDefn->UOMLengthInMeters, "EPSG", szUOMLength);
         }
         else
             oSRS.SetLinearUnits( "unknown", psDefn->UOMLengthInMeters );
 
         GTIFFreeMemory( pszUnitsName );
     }
 
 /* -------------------------------------------------------------------- */
 /*      #3901: In libgeotiff 1.3.0 and earlier we incorrectly           */
 /*      interpreted linear projection parameter geokeys (false          */
 /*      easting/northing) as being in meters instead of the             */
 /*      coordinate system of the file.   The following code attempts    */
 /*      to provide mechanisms for fixing the issue if we are linked     */
 /*      with an older version of libgeotiff.                            */
 /* -------------------------------------------------------------------- */
     const char *pszLinearUnits =
         CPLGetConfigOption( "GTIFF_LINEAR_UNITS", "DEFAULT" );
 
 /* -------------------------------------------------------------------- */
 /*      #3901: If folks have broken GeoTIFF files generated with        */
 /*      older versions of GDAL+libgeotiff, then they may need a         */
 /*      hack to allow them to be read properly.  This is that           */
 /*      hack.  We basically try to undue the conversion applied by      */
 /*      libgeotiff to meters (or above) to simulate the old             */
 /*      behavior.                                                       */
 /* -------------------------------------------------------------------- */
     short bLinearUnitsMarkedCorrect = FALSE;
 
     GDALGTIFKeyGetSHORT(hGTIF, ProjLinearUnitsInterpCorrectGeoKey,
                &bLinearUnitsMarkedCorrect, 0, 1);
 
     if( EQUAL(pszLinearUnits,"BROKEN")
         && psDefn->Projection == KvUserDefined
         && !bLinearUnitsMarkedCorrect )
     {
         for( int iParm = 0; iParm < psDefn->nParms; iParm++ )
         {
             switch( psDefn->ProjParmId[iParm] )
             {
               case ProjFalseEastingGeoKey:
               case ProjFalseNorthingGeoKey:
               case ProjFalseOriginEastingGeoKey:
               case ProjFalseOriginNorthingGeoKey:
               case ProjCenterEastingGeoKey:
               case ProjCenterNorthingGeoKey:
                 if( psDefn->UOMLengthInMeters != 0
                     && psDefn->UOMLengthInMeters != 1.0 )
                 {
                     psDefn->ProjParm[iParm] /= psDefn->UOMLengthInMeters;
                     CPLDebug(
                         "GTIFF",
                         "Converting geokey to accommodate old broken file "
                         "due to GTIFF_LINEAR_UNITS=BROKEN setting." );
                 }
                 break;
 
               default:
                 break;
             }
         }
     }
 
 /* -------------------------------------------------------------------- */
 /*      If this is a projected SRS we set the PROJCS keyword first      */
 /*      to ensure that the GEOGCS will be a child.                      */
 /* -------------------------------------------------------------------- */
     OGRBoolean linearUnitIsSet = FALSE;
     if( psDefn->Model == ModelTypeProjected )
     {
         char szCTString[512] = { '\0' };
         if( psDefn->PCS != KvUserDefined )
         {
             char *pszPCSName = nullptr;
 
 #if LIBGEOTIFF_VERSION >= 1600
             GTIFGetPCSInfoEx( projContext,
 #else
             GTIFGetPCSInfo(
 #endif
                 psDefn->PCS, &pszPCSName, nullptr, nullptr, nullptr );
 
             oSRS.SetProjCS( pszPCSName ? pszPCSName : "unnamed" );
             if ( pszPCSName )
                 GTIFFreeMemory( pszPCSName );
 
             oSRS.SetLinearUnits("unknown", 1.0);
         }
         else
         {
             bool bTryGTCitationGeoKey = true;
             if( GDALGTIFKeyGetASCII( hGTIF, PCSCitationGeoKey,
                                               szCTString, 0,
                                               sizeof(szCTString)) )
             {
                 bTryGTCitationGeoKey = false;
                 if (!SetCitationToSRS( hGTIF, szCTString, sizeof(szCTString),
                                        PCSCitationGeoKey, &oSRS,
                                        &linearUnitIsSet) )
                 {
                     if( !STARTS_WITH_CI(szCTString, "LUnits = ") )
                     {
                         oSRS.SetProjCS( szCTString );
                         oSRS.SetLinearUnits("unknown", 1.0);
                     }
                     else
                     {
                         bTryGTCitationGeoKey = true;
                     }
                 }
             }
 
             if( bTryGTCitationGeoKey )
             {
                 if( GDALGTIFKeyGetASCII( hGTIF, GTCitationGeoKey, szCTString,
                                          0, sizeof(szCTString) ) &&
                     !SetCitationToSRS( hGTIF, szCTString, sizeof(szCTString),
                                        GTCitationGeoKey, &oSRS,
                                        &linearUnitIsSet ) )
                 {
                     oSRS.SetNode( "PROJCS", szCTString );
                     oSRS.SetLinearUnits("unknown", 1.0);
                 }
                 else
                 {
                     oSRS.SetNode( "PROJCS", "unnamed" );
                     oSRS.SetLinearUnits("unknown", 1.0);
                 }
             }
         }
 
         /* Handle ESRI/Erdas style state plane and UTM in citation key */
         if( CheckCitationKeyForStatePlaneUTM( hGTIF, psDefn, &oSRS,
                                               &linearUnitIsSet ) )
         {
             return OGRSpatialReference::ToHandle(oSRS.Clone());
         }
 
         /* Handle ESRI PE string in citation */
         szCTString[0] = '\0';
         if( GDALGTIFKeyGetASCII( hGTIF, GTCitationGeoKey, szCTString,
                                  0, sizeof(szCTString) ) )
             SetCitationToSRS( hGTIF, szCTString, sizeof(szCTString),
                               GTCitationGeoKey, &oSRS, &linearUnitIsSet );
     }
 
 /* ==================================================================== */
 /*      Read keys related to vertical component.                        */
 /* ==================================================================== */
     short verticalCSType = -1;
     short verticalDatum = -1;
     short verticalUnits = -1;
 
     GDALGTIFKeyGetSHORT( hGTIF, VerticalCSTypeGeoKey, &verticalCSType, 0, 1 );
     GDALGTIFKeyGetSHORT( hGTIF, VerticalDatumGeoKey, &verticalDatum, 0, 1 );
     GDALGTIFKeyGetSHORT( hGTIF, VerticalUnitsGeoKey, &verticalUnits, 0, 1 );
 
     if( verticalCSType != -1 || verticalDatum != -1 || verticalUnits != -1 )
     {
         int versions[3];
         GTIFDirectoryInfo(hGTIF, versions, nullptr);
         // GeoTIFF 1.0
         if( versions[0] == 1 && versions[1]== 1 && versions[2] == 0 )
         {
 /* -------------------------------------------------------------------- */
 /*      The original geotiff specification appears to have              */
 /*      misconstrued the EPSG codes 5101 to 5106 to be vertical         */
 /*      coordinate system codes, when in fact they are vertical         */
 /*      datum codes.  So if these are found in the                      */
 /*      VerticalCSTypeGeoKey move them to the VerticalDatumGeoKey       */
 /*      and insert the "normal" corresponding VerticalCSTypeGeoKey      */
 /*      value.                                                          */
 /* -------------------------------------------------------------------- */
             if( (verticalCSType >= 5101 && verticalCSType <= 5112)
                 && verticalDatum == -1 )
             {
                 verticalDatum = verticalCSType;
                 verticalCSType = verticalDatum + 600;
             }
 
 /* -------------------------------------------------------------------- */
 /*      This addresses another case where the EGM96 Vertical Datum code */
 /*      is misused as a Vertical CS code (#4922).                       */
 /* -------------------------------------------------------------------- */
             if( verticalCSType == 5171 )
             {
                 verticalDatum = 5171;
                 verticalCSType = 5773;
             }
         }
 
 /* -------------------------------------------------------------------- */
 /*      Somewhat similarly, codes 5001 to 5033 were treated as          */
 /*      vertical coordinate systems based on ellipsoidal heights.       */
 /*      We use the corresponding geodetic datum as the vertical         */
 /*      datum and clear the vertical coordinate system code since       */
 /*      there isn't one in EPSG.                                        */
 /* -------------------------------------------------------------------- */
         if( (verticalCSType >= 5001 && verticalCSType <= 5033)
             && verticalDatum == -1 )
         {
             verticalDatum = verticalCSType + 1000;
             verticalCSType = -1;
         }
     }
 
 /* ==================================================================== */
 /*      Setup the GeogCS                                                */
 /* ==================================================================== */
     char *pszGeogName = nullptr;
     char *pszDatumName = nullptr;
     char *pszPMName = nullptr;
     char *pszSpheroidName = nullptr;
     char *pszAngularUnits = nullptr;
     char szGCSName[512] = { '\0' };
 
     if( !
 #if LIBGEOTIFF_VERSION >= 1600
         GTIFGetGCSInfoEx( projContext,
 #else
         GTIFGetGCSInfo(
 #endif
             psDefn->GCS, &pszGeogName, nullptr, nullptr, nullptr )
         && GDALGTIFKeyGetASCII( hGTIF, GeogCitationGeoKey, szGCSName, 0,
                        sizeof(szGCSName)) )
     {
         GetGeogCSFromCitation(szGCSName, sizeof(szGCSName),
                               GeogCitationGeoKey,
                               &pszGeogName, &pszDatumName,
                               &pszPMName, &pszSpheroidName,
                               &pszAngularUnits);
     }
     else
     {
         GTIFToCPLRecycleString( &pszGeogName );
     }
 
     if( !pszDatumName )
     {
 #if LIBGEOTIFF_VERSION >= 1600
         GTIFGetDatumInfoEx( projContext,
 #else
         GTIFGetDatumInfo(
 #endif
             psDefn->Datum, &pszDatumName, nullptr );
         GTIFToCPLRecycleString( &pszDatumName );
     }
 
     double dfSemiMajor = 0.0;
     double dfInvFlattening = 0.0;
     if( !pszSpheroidName )
     {
 #if LIBGEOTIFF_VERSION >= 1600
         GTIFGetEllipsoidInfoEx( projContext,
 #else
         GTIFGetEllipsoidInfo(
 #endif
             psDefn->Ellipsoid, &pszSpheroidName, nullptr, nullptr );
         GTIFToCPLRecycleString( &pszSpheroidName );
     }
     else
     {
         GDALGTIFKeyGetDOUBLE( hGTIF, GeogSemiMajorAxisGeoKey,
                               &(psDefn->SemiMajor), 0, 1 );
         GDALGTIFKeyGetDOUBLE( hGTIF, GeogInvFlatteningGeoKey,
                               &dfInvFlattening, 0, 1 );
     }
     if( !pszPMName )
     {
 #if LIBGEOTIFF_VERSION >= 1600
         GTIFGetPMInfoEx( projContext,
 #else
         GTIFGetPMInfo(
 #endif
             psDefn->PM, &pszPMName, nullptr );
         GTIFToCPLRecycleString( &pszPMName );
     }
     else
     {
         GDALGTIFKeyGetDOUBLE( hGTIF, GeogPrimeMeridianLongGeoKey,
                               &(psDefn->PMLongToGreenwich), 0, 1 );
     }
 
     if( !pszAngularUnits )
     {
 #if LIBGEOTIFF_VERSION >= 1600
         GTIFGetUOMAngleInfoEx( projContext,
 #else
         GTIFGetUOMAngleInfo(
 #endif
             psDefn->UOMAngle, &pszAngularUnits, &psDefn->UOMAngleInDegrees );
         if( pszAngularUnits == nullptr )
             pszAngularUnits = CPLStrdup("unknown");
         else
             GTIFToCPLRecycleString( &pszAngularUnits );
     }
     else
     {
         double dfRadians = 0.0;
         if( GDALGTIFKeyGetDOUBLE(hGTIF, GeogAngularUnitSizeGeoKey, &dfRadians,
                                  0, 1) )
         {
             psDefn->UOMAngleInDegrees = dfRadians / CPLAtof(SRS_UA_DEGREE_CONV);
         }
     }
 
     if( pszDatumName != nullptr )
         WKTMassageDatum( &pszDatumName );
 
     dfSemiMajor = psDefn->SemiMajor;
     if( dfSemiMajor == 0.0 )
     {
         CPLFree(pszSpheroidName);
         pszSpheroidName = CPLStrdup("unretrievable - using WGS84");
         dfSemiMajor = SRS_WGS84_SEMIMAJOR;
         dfInvFlattening = SRS_WGS84_INVFLATTENING;
     }
     else if( dfInvFlattening == 0.0
              && ((psDefn->SemiMinor / psDefn->SemiMajor) < 0.99999999999999999
                  || (psDefn->SemiMinor / psDefn->SemiMajor) >
                  1.00000000000000001 ) )
     {
         dfInvFlattening = OSRCalcInvFlattening( psDefn->SemiMajor,
                                                 psDefn->SemiMinor );
 
         /* Take official inverse flattening definition in the WGS84 case */
         if (fabs(dfSemiMajor - SRS_WGS84_SEMIMAJOR) < 1e-10 &&
             fabs(dfInvFlattening - SRS_WGS84_INVFLATTENING) < 1e-10)
             dfInvFlattening = SRS_WGS84_INVFLATTENING;
     }
     if(!pszGeogName || strlen(pszGeogName) == 0)
     {
         CPLFree(pszGeogName);
         pszGeogName = CPLStrdup( pszDatumName ? pszDatumName : "unknown" );
     }
 
     oSRS.SetGeogCS( pszGeogName, pszDatumName,
                     pszSpheroidName, dfSemiMajor, dfInvFlattening,
                     pszPMName,
                     psDefn->PMLongToGreenwich / psDefn->UOMAngleInDegrees,
                     pszAngularUnits,
                     psDefn->UOMAngleInDegrees * CPLAtof(SRS_UA_DEGREE_CONV) );
 
     bool bGeog3DCRS = false;
     bool bSetDatumEllipsoid = true;
     {
         int nGCS = psDefn->GCS;
         if( nGCS != KvUserDefined && nGCS > 0 )
         {
             oSRS.SetAuthority( "GEOGCS", "EPSG", nGCS );
 
             int nVertSRSCode = verticalCSType;
             if( verticalDatum == 6030 && nGCS == 4326 ) // DatumE_WGS84
             {
                 nVertSRSCode = 4979;
             }
 
             // Try to reconstruct a Geographic3D CRS from the
             // GeodeticCRSGeoKey and the VerticalGeoKey, when they are consistent
             if( nVertSRSCode > 0 && nVertSRSCode != KvUserDefined )
             {
                 OGRSpatialReference oTmpSRS;
                 OGRSpatialReference oTmpVertSRS;
                 if( oTmpSRS.importFromEPSG(nGCS) == OGRERR_NONE &&
                     oTmpSRS.IsGeographic() && oTmpSRS.GetAxesCount() == 2 &&
                     oTmpVertSRS.importFromEPSG(nVertSRSCode) == OGRERR_NONE &&
                     oTmpVertSRS.IsGeographic() && oTmpVertSRS.GetAxesCount() == 3 )
                 {
                     const char* pszTmpCode = oTmpSRS.GetAuthorityCode( "GEOGCS|DATUM" );
                     const char* pszTmpVertCode = oTmpVertSRS.GetAuthorityCode( "GEOGCS|DATUM" );
                     if( pszTmpCode && pszTmpVertCode &&
                         atoi(pszTmpCode) == atoi(pszTmpVertCode) )
                     {
                         verticalCSType = -1;
                         verticalDatum = -1;
                         verticalUnits = -1;
                         oSRS.CopyGeogCSFrom(&oTmpVertSRS);
                         bSetDatumEllipsoid = false;
                         bGeog3DCRS = true;
                     }
                 }
             }
         }
     }
     if( bSetDatumEllipsoid )
     {
         if( psDefn->Datum != KvUserDefined )
             oSRS.SetAuthority( "DATUM", "EPSG", psDefn->Datum );
 
         if( psDefn->Ellipsoid != KvUserDefined )
             oSRS.SetAuthority( "SPHEROID", "EPSG", psDefn->Ellipsoid );
     }
 
     CPLFree( pszGeogName );
     CPLFree( pszDatumName );
     CPLFree( pszSpheroidName );
     CPLFree( pszPMName );
     CPLFree( pszAngularUnits );
 
 /* -------------------------------------------------------------------- */
 /*      Set projection units if not yet done                            */
 /* -------------------------------------------------------------------- */
     if( psDefn->Model == ModelTypeProjected && !linearUnitIsSet )
     {
         char *pszUnitsName = nullptr;
 
         if( psDefn->UOMLength != KvUserDefined )
         {
 #if LIBGEOTIFF_VERSION >= 1600
             GTIFGetUOMLengthInfoEx( projContext,
 #else
             GTIFGetUOMLengthInfo(
 #endif
                 psDefn->UOMLength, &pszUnitsName, nullptr );
         }
 
         if( pszUnitsName != nullptr )
         {
             char szUOMLength[12];
             snprintf(szUOMLength, sizeof(szUOMLength),
                         "%d", psDefn->UOMLength );
             oSRS.SetTargetLinearUnits( nullptr,
                 pszUnitsName, psDefn->UOMLengthInMeters, "EPSG", szUOMLength);
         }
         else
             oSRS.SetLinearUnits( "unknown", psDefn->UOMLengthInMeters );
 
         GTIFFreeMemory( pszUnitsName );
     }
 
 /* ==================================================================== */
 /*      Try to import PROJCS from ProjectedCSTypeGeoKey if we           */
 /*      have essentially only it. We could relax a bit the constraints  */
 /*      but that should do for now. This may mask shortcomings in the   */
 /*      libgeotiff GTIFGetDefn() function.                              */
 /* ==================================================================== */
     short tmp = 0;
     bool bGotFromEPSG = false;
     if( psDefn->Model == ModelTypeProjected &&
         psDefn->PCS != KvUserDefined &&
         GDALGTIFKeyGetSHORT(hGTIF, ProjectionGeoKey, &tmp, 0, 1) == 0 &&
         GDALGTIFKeyGetSHORT(hGTIF, ProjCoordTransGeoKey, &tmp, 0, 1) == 0 &&
         GDALGTIFKeyGetSHORT(hGTIF, GeographicTypeGeoKey, &tmp, 0, 1) == 0 &&
         GDALGTIFKeyGetSHORT(hGTIF, GeogGeodeticDatumGeoKey, &tmp, 0, 1) == 0 &&
         GDALGTIFKeyGetSHORT(hGTIF, GeogEllipsoidGeoKey, &tmp, 0, 1) == 0 &&
         CPLTestBool(CPLGetConfigOption("GTIFF_IMPORT_FROM_EPSG", "YES")) )
     {
         // Save error state as importFromEPSGA() will call CPLReset()
         CPLErrorNum errNo = CPLGetLastErrorNo();
         CPLErr eErr = CPLGetLastErrorType();
         const char* pszTmp = CPLGetLastErrorMsg();
         char* pszLastErrorMsg = CPLStrdup(pszTmp ? pszTmp : "");
         CPLPushErrorHandler(CPLQuietErrorHandler);
         OGRSpatialReference oSRSTmp;
         OGRErr eImportErr = oSRSTmp.importFromEPSG(psDefn->PCS);
         CPLPopErrorHandler();
         // Restore error state
         CPLErrorSetState( eErr, errNo, pszLastErrorMsg);
         CPLFree(pszLastErrorMsg);
         bGotFromEPSG = eImportErr == OGRERR_NONE;
 
         if( bGotFromEPSG )
         {
             // See #6210. In case there's an overridden linear units, take it
             // into account
             const char* pszUnitsName = nullptr;
             double dfUOMLengthInMeters = oSRS.GetLinearUnits( &pszUnitsName );
             // Non exact comparision, as there's a slight difference between
             // the evaluation of US Survey foot harcoded in geo_normalize.c to
             // 12.0 / 39.37, and the corresponding value returned by
             // PROJ >= 6.0.0 and <= 7.0.0 for EPSG:9003
             if( fabs(dfUOMLengthInMeters - oSRSTmp.GetLinearUnits(nullptr)) >
                     1e-15 * dfUOMLengthInMeters )
             {
                 CPLDebug( "GTiff", "Modify EPSG:%d to have %s linear units...",
                           psDefn->PCS,
                           pszUnitsName ? pszUnitsName : "unknown" );
 
                 const char* pszUnitAuthorityCode =
                     oSRS.GetAuthorityCode( "PROJCS|UNIT" );
                 const char* pszUnitAuthorityName =
                     oSRS.GetAuthorityName( "PROJCS|UNIT" );
 
                 if( pszUnitsName )
                     oSRSTmp.SetLinearUnitsAndUpdateParameters(
                         pszUnitsName, dfUOMLengthInMeters,
                         pszUnitAuthorityCode, pszUnitAuthorityName);
             }
 
             if( bGeog3DCRS )
             {
                 oSRSTmp.CopyGeogCSFrom(&oSRS);
                 oSRSTmp.UpdateCoordinateSystemFromGeogCRS();
             }
             oSRS = oSRSTmp;
         }
     }
 
 #if !defined(GEO_NORMALIZE_DISABLE_TOWGS84)
-    if( psDefn->TOWGS84Count > 0 )
+    if( psDefn->TOWGS84Count > 0 &&
+        bGotFromEPSG  &&
+        CPLTestBool(CPLGetConfigOption("OSR_STRIP_TOWGS84", "YES")) )
+    {
+        CPLDebug("OSR", "TOWGS84 information has been removed. "
+                 "It can be kept by setting the OSR_STRIP_TOWGS84 "
+                 "configuration option to NO");
+    }
+    else if( psDefn->TOWGS84Count > 0 &&
+        (!bGotFromEPSG ||
+         !CPLTestBool(CPLGetConfigOption("OSR_STRIP_TOWGS84", "YES"))) )
     {
         if( bGotFromEPSG )
         {
             double adfTOWGS84[7] = { 0.0 };
             oSRS.GetTOWGS84( adfTOWGS84 );
             bool bSame = true;
             for( int i = 0; i < 7; i++ )
             {
                 if( fabs(adfTOWGS84[i] - psDefn->TOWGS84[i]) > 1e-5 )
                 {
                     bSame = false;
                     break;
                 }
             }
             if( !bSame )
             {
                 CPLDebug( "GTiff",
                           "Modify EPSG:%d to have "
                           "TOWGS84=%f,%f,%f,%f,%f,%f,%f "
                           "coming from GeogTOWGS84GeoKey, instead of "
                           "%f,%f,%f,%f,%f,%f,%f coming from EPSG",
                           psDefn->PCS,
                           psDefn->TOWGS84[0],
                           psDefn->TOWGS84[1],
                           psDefn->TOWGS84[2],
                           psDefn->TOWGS84[3],
                           psDefn->TOWGS84[4],
                           psDefn->TOWGS84[5],
                           psDefn->TOWGS84[6],
                           adfTOWGS84[0],
                           adfTOWGS84[1],
                           adfTOWGS84[2],
                           adfTOWGS84[3],
                           adfTOWGS84[4],
                           adfTOWGS84[5],
                           adfTOWGS84[6] );
             }
         }
 
         oSRS.SetTOWGS84( psDefn->TOWGS84[0],
                          psDefn->TOWGS84[1],
                          psDefn->TOWGS84[2],
                          psDefn->TOWGS84[3],
                          psDefn->TOWGS84[4],
                          psDefn->TOWGS84[5],
                          psDefn->TOWGS84[6] );
     }
 #endif
 
 /* ==================================================================== */
 /*      Handle projection parameters.                                   */
 /* ==================================================================== */
     if( psDefn->Model == ModelTypeProjected && !bGotFromEPSG )
     {
 /* -------------------------------------------------------------------- */
 /*      Make a local copy of parms, and convert back into the           */
 /*      angular units of the GEOGCS and the linear units of the         */
 /*      projection.                                                     */
 /* -------------------------------------------------------------------- */
         double adfParm[10] = { 0.0 };
         int i = 0;  // Used after for.
 
         for( ; i < std::min(10, psDefn->nParms); i++ )
             adfParm[i] = psDefn->ProjParm[i];
 
         for( ; i < 10; i++ )
             adfParm[i] = 0.0;
 
 /* -------------------------------------------------------------------- */
 /*      Translation the fundamental projection.                         */
 /* -------------------------------------------------------------------- */
         switch( psDefn->CTProjection )
         {
           case CT_TransverseMercator:
             oSRS.SetTM( adfParm[0], adfParm[1],
                         adfParm[4],
                         adfParm[5], adfParm[6] );
             break;
 
           case CT_TransvMercator_SouthOriented:
             oSRS.SetTMSO( adfParm[0], adfParm[1],
                           adfParm[4],
                           adfParm[5], adfParm[6] );
             break;
 
           case CT_Mercator:
             // If a lat_ts was specified use 2SP, otherwise use 1SP.
             if (psDefn->ProjParmId[2] == ProjStdParallel1GeoKey)
             {
                 if (psDefn->ProjParmId[4] == ProjScaleAtNatOriginGeoKey)
                     CPLError(
                         CE_Warning, CPLE_AppDefined,
                         "Mercator projection should not define "
                         "both StdParallel1 and ScaleAtNatOrigin.  "
                         "Using StdParallel1 and ignoring ScaleAtNatOrigin." );
                 oSRS.SetMercator2SP( adfParm[2],
                                      adfParm[0], adfParm[1],
                                      adfParm[5], adfParm[6]);
             }
             else
                 oSRS.SetMercator( adfParm[0], adfParm[1],
                                   adfParm[4],
                                   adfParm[5], adfParm[6] );
 
             // Override hack for google mercator.
             if (psDefn->Projection == 1024 || psDefn->Projection == 9841)
             {
                 oSRS.SetExtension(
                     "PROJCS", "PROJ4",
                     "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 "
                     "+x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null "
                     "+wktext  +no_defs" );  // TODO(schwehr): Why 2 spaces?
             }
             break;
 
           case CT_ObliqueStereographic:
             oSRS.SetOS( adfParm[0], adfParm[1],
                         adfParm[4],
                         adfParm[5], adfParm[6] );
             break;
 
           case CT_Stereographic:
             oSRS.SetStereographic( adfParm[0], adfParm[1],
                         adfParm[4],
                         adfParm[5], adfParm[6] );
             break;
 
           case CT_ObliqueMercator:  // Hotine.
             oSRS.SetHOM( adfParm[0], adfParm[1],
                          adfParm[2], adfParm[3],
                          adfParm[4],
                          adfParm[5], adfParm[6] );
             break;
 
           case CT_HotineObliqueMercatorAzimuthCenter:
             oSRS.SetHOMAC( adfParm[0], adfParm[1],
                            adfParm[2], adfParm[3],
                            adfParm[4],
                            adfParm[5], adfParm[6] );
             break;
 
           case CT_ObliqueMercator_Laborde:
             oSRS.SetLOM( adfParm[0], adfParm[1],
                          adfParm[2],
                          adfParm[4],
                          adfParm[5], adfParm[6] );
             break;
 
           case CT_EquidistantConic:
             oSRS.SetEC( adfParm[0], adfParm[1],
                         adfParm[2], adfParm[3],
                         adfParm[5], adfParm[6] );
             break;
 
           case CT_CassiniSoldner:
             oSRS.SetCS( adfParm[0], adfParm[1],
                         adfParm[5], adfParm[6] );
             break;
 
           case CT_Polyconic:
             oSRS.SetPolyconic( adfParm[0], adfParm[1],
                                adfParm[5], adfParm[6] );
             break;
 
           case CT_AzimuthalEquidistant:
             oSRS.SetAE( adfParm[0], adfParm[1],
                         adfParm[5], adfParm[6] );
             break;
 
           case CT_MillerCylindrical:
             oSRS.SetMC( adfParm[0], adfParm[1],
                         adfParm[5], adfParm[6] );
             break;
 
           case CT_Equirectangular:
             oSRS.SetEquirectangular2( adfParm[0], adfParm[1],
                                       adfParm[2],
                                       adfParm[5], adfParm[6] );
             break;
 
           case CT_Gnomonic:
             oSRS.SetGnomonic( adfParm[0], adfParm[1],
                               adfParm[5], adfParm[6] );
             break;
 
           case CT_LambertAzimEqualArea:
             oSRS.SetLAEA( adfParm[0], adfParm[1],
                           adfParm[5], adfParm[6] );
             break;
 
           case CT_Orthographic:
             oSRS.SetOrthographic( adfParm[0], adfParm[1],
                                   adfParm[5], adfParm[6] );
             break;
 
           case CT_Robinson:
             oSRS.SetRobinson( adfParm[1],
                               adfParm[5], adfParm[6] );
             break;
 
           case CT_Sinusoidal:
             oSRS.SetSinusoidal( adfParm[1],
                                 adfParm[5], adfParm[6] );
             break;
 
           case CT_VanDerGrinten:
             oSRS.SetVDG( adfParm[1],
                          adfParm[5], adfParm[6] );
             break;
 
           case CT_PolarStereographic:
             oSRS.SetPS( adfParm[0], adfParm[1],
                         adfParm[4],
                         adfParm[5], adfParm[6] );
             break;
 
           case CT_LambertConfConic_2SP:
             oSRS.SetLCC( adfParm[2], adfParm[3],
                          adfParm[0], adfParm[1],
                          adfParm[5], adfParm[6] );
             break;
 
           case CT_LambertConfConic_1SP:
             oSRS.SetLCC1SP( adfParm[0], adfParm[1],
                             adfParm[4],
                             adfParm[5], adfParm[6] );
             break;
 
           case CT_AlbersEqualArea:
             oSRS.SetACEA( adfParm[0], adfParm[1],
                           adfParm[2], adfParm[3],
                           adfParm[5], adfParm[6] );
             break;
 
           case CT_NewZealandMapGrid:
             oSRS.SetNZMG( adfParm[0], adfParm[1],
                           adfParm[5], adfParm[6] );
             break;
 
           case CT_CylindricalEqualArea:
             oSRS.SetCEA( adfParm[0], adfParm[1],
                          adfParm[5], adfParm[6] );
             break;
           default:
             if( oSRS.IsProjected() )
             {
                 const char* pszName = oSRS.GetName();
                 std::string osName( pszName ? pszName : "unnamed" );
                 oSRS.Clear();
                 oSRS.SetLocalCS( osName.c_str() );
             }
             break;
         }
     }
 
     if( psDefn->Model == ModelTypeProjected && psDefn->PCS != KvUserDefined &&
         !bGotFromEPSG )
     {
         oSRS.SetAuthority( nullptr, "EPSG", psDefn->PCS );
     }
 
     if( oSRS.IsProjected() && oSRS.GetAxesCount() == 2 )
     {
         const char* pszProjCRSName = oSRS.GetAttrValue("PROJCS");
         if( pszProjCRSName )
         {
             // Hack to be able to read properly what we have written for
             // EPSG:102113 (ESRI ancient WebMercator).
             if( EQUAL(pszProjCRSName, "WGS_1984_Web_Mercator") )
                 oSRS.importFromEPSG(102113);
             // And for EPSG:900913
             else if( EQUAL( pszProjCRSName,
                             "Google Maps Global Mercator" ) )
                 oSRS.importFromEPSG(900913);
         }
     }
 
 /* ==================================================================== */
 /*      Handle vertical coordinate system information if we have it.    */
 /* ==================================================================== */
     bool bNeedManualVertCS = false;
     char citation[2048] = { '\0' };
     if( (verticalCSType != -1 || verticalDatum != -1 || verticalUnits != -1)
         && (oSRS.IsGeographic() || oSRS.IsProjected() || oSRS.IsLocal()) )
     {
         if( !GDALGTIFKeyGetASCII( hGTIF, VerticalCitationGeoKey, citation,
                                   0, sizeof(citation) ) )
             strcpy( citation, "unknown" );
 
         OGRSpatialReference oVertSRS;
         bool bCanBuildCompoundCRS = true;
         if( verticalCSType != KvUserDefined && verticalCSType > 0 )
         {
             if( !(oVertSRS.importFromEPSG( verticalCSType ) == OGRERR_NONE &&
                   oVertSRS.IsVertical() ) )
             {
                 bCanBuildCompoundCRS = false;
             }
         }
 
         if( bCanBuildCompoundCRS )
         {
 /* -------------------------------------------------------------------- */
 /*      Promote to being a compound coordinate system.                  */
 /* -------------------------------------------------------------------- */
             OGR_SRSNode *poOldRoot = oSRS.GetRoot()->Clone();
 
             oSRS.Clear();
 
 /* -------------------------------------------------------------------- */
 /*      Set COMPD_CS name.                                              */
 /* -------------------------------------------------------------------- */
             char szCTString[512];
             szCTString[0] = '\0';
             if( GDALGTIFKeyGetASCII( hGTIF, GTCitationGeoKey, szCTString,
                                     0, sizeof(szCTString) ) &&
                 strstr( szCTString, " = " ) == nullptr )
             {
                 oSRS.SetNode( "COMPD_CS", szCTString );
             }
             else
             {
                 oSRS.SetNode( "COMPD_CS", "unknown" );
             }
 
             oSRS.GetRoot()->AddChild( poOldRoot );
 
 /* -------------------------------------------------------------------- */
 /*      If we have the vertical cs, try to look it up, and use the      */
 /*      definition provided by that.                                    */
 /* -------------------------------------------------------------------- */
             bNeedManualVertCS = true;
 
             if( !oVertSRS.IsEmpty() )
             {
                 oSRS.GetRoot()->AddChild( oVertSRS.GetRoot()->Clone() );
                 bNeedManualVertCS = false;
             }
         }
     }
 
 /* -------------------------------------------------------------------- */
 /*      Collect some information from the VerticalCS if not provided    */
 /*      via geokeys.                                                    */
 /* -------------------------------------------------------------------- */
     if( bNeedManualVertCS )
     {
 /* -------------------------------------------------------------------- */
 /*      Setup VERT_CS with citation if present.                         */
 /* -------------------------------------------------------------------- */
         oSRS.SetNode( "COMPD_CS|VERT_CS", citation );
 
 /* -------------------------------------------------------------------- */
 /*      Setup the vertical datum.                                       */
 /* -------------------------------------------------------------------- */
         std::string osVDatumName = "unknown";
         const char *pszVDatumType = "2005"; // CS_VD_GeoidModelDerived
 
         if( verticalDatum > 0 && verticalDatum != KvUserDefined )
         {
             char szCode[12];
             snprintf(szCode, sizeof(szCode), "%d", verticalDatum);
             auto ctx = static_cast<PJ_CONTEXT*>(
                 GTIFGetPROJContext(hGTIF, true, nullptr));
             auto datum = proj_create_from_database(
                 ctx, "EPSG", szCode, PJ_CATEGORY_DATUM, 0, nullptr);
             if( datum )
             {
                 const char* pszName = proj_get_name(datum);
                 if( pszName )
                 {
                     osVDatumName = pszName;
                 }
                 proj_destroy(datum);
             }
         }
 
         oSRS.SetNode( "COMPD_CS|VERT_CS|VERT_DATUM", osVDatumName.c_str() );
         oSRS.GetAttrNode( "COMPD_CS|VERT_CS|VERT_DATUM" )
             ->AddChild( new OGR_SRSNode( pszVDatumType ) );
         if( verticalDatum > 0 && verticalDatum != KvUserDefined )
             oSRS.SetAuthority( "COMPD_CS|VERT_CS|VERT_DATUM", "EPSG",
                                verticalDatum );
 
 /* -------------------------------------------------------------------- */
 /*      Set the vertical units.                                         */
 /* -------------------------------------------------------------------- */
         if( verticalUnits > 0 && verticalUnits != KvUserDefined
             && verticalUnits != 9001 )
         {
             char szCode[12];
             snprintf(szCode, sizeof(szCode), "%d", verticalUnits);
             auto ctx = static_cast<PJ_CONTEXT*>(
                 GTIFGetPROJContext(hGTIF, true, nullptr));
             const char* pszName = nullptr;
             double dfInMeters = 0.0;
             if( proj_uom_get_info_from_database(
                 ctx, "EPSG", szCode, &pszName, &dfInMeters, nullptr) )
             {
                 if( pszName )
                     oSRS.SetNode( "COMPD_CS|VERT_CS|UNIT", pszName );
 
                 char szInMeters[128] = {};
                 CPLsnprintf( szInMeters, sizeof(szInMeters),
                              "%.16g", dfInMeters );
                 oSRS.GetAttrNode( "COMPD_CS|VERT_CS|UNIT" )
                     ->AddChild( new OGR_SRSNode( szInMeters ) );
             }
 
             oSRS.SetAuthority( "COMPD_CS|VERT_CS|UNIT", "EPSG", verticalUnits);
         }
         else
         {
             oSRS.SetNode( "COMPD_CS|VERT_CS|UNIT", "metre" );
             oSRS.GetAttrNode( "COMPD_CS|VERT_CS|UNIT" )
                 ->AddChild( new OGR_SRSNode( "1.0" ) );
             oSRS.SetAuthority( "COMPD_CS|VERT_CS|UNIT", "EPSG", 9001 );
         }
 
 /* -------------------------------------------------------------------- */
 /*      Set the axis and VERT_CS authority.                             */
 /* -------------------------------------------------------------------- */
         oSRS.SetNode( "COMPD_CS|VERT_CS|AXIS", "Up" );
         oSRS.GetAttrNode( "COMPD_CS|VERT_CS|AXIS" )
             ->AddChild( new OGR_SRSNode( "UP" ) );
     }
 
     // Hack for tiff_read.py:test_tiff_grads so as to normalize angular
     // parameters to grad
     if( psDefn->UOMAngleInDegrees != 1.0 )
     {
         char *pszWKT = nullptr;
         const char* const apszOptions[] = {
             "FORMAT=WKT1", "ADD_TOWGS84_ON_EXPORT_TO_WKT1=NO", nullptr };
         if( oSRS.exportToWkt( &pszWKT, apszOptions ) == OGRERR_NONE )
         {
             oSRS.importFromWkt(pszWKT);
         }
         CPLFree(pszWKT);
     }
 
+    oSRS.StripTOWGS84IfKnownDatumAndAllowed();
+
     return OGRSpatialReference::ToHandle(oSRS.Clone());
 }
 
 
 /************************************************************************/
 /*                          GTIFGetOGISDefn()                           */
 /************************************************************************/
diff --git a/gdal/ogr/ogr_spatialref.h b/gdal/ogr/ogr_spatialref.h
index 4d589d7a1d..bc61f9b445 100644
--- a/gdal/ogr/ogr_spatialref.h
+++ b/gdal/ogr/ogr_spatialref.h
@@ -157,553 +157,556 @@ class CPL_DLL OGR_SRSNode
 class CPL_DLL OGRSpatialReference
 {
     struct Private;
     std::unique_ptr<Private> d;
 
     void        GetNormInfo() const;
 
     OGRErr      importFromURNPart(const char* pszAuthority,
                                   const char* pszCode,
                                   const char* pszURN);
 
     static CPLString   lookupInDict( const char *pszDictFile,
                                      const char *pszCode );
 
   public:
                 OGRSpatialReference(const OGRSpatialReference&);
     explicit    OGRSpatialReference(const char * = nullptr);
 
     virtual    ~OGRSpatialReference();
 
     static void DestroySpatialReference(OGRSpatialReference* poSRS);
 
     OGRSpatialReference &operator=(const OGRSpatialReference&);
 
     int         Reference();
     int         Dereference();
     int         GetReferenceCount() const;
     void        Release();
 
     const char* GetName() const;
 
     OGRSpatialReference *Clone() const;
     OGRSpatialReference *CloneGeogCS() const;
 
     void        dumpReadable();
     OGRErr      exportToWkt( char ** ) const;
     OGRErr      exportToWkt( char ** ppszWKT, const char* const* papszOptions ) const;
     OGRErr      exportToPrettyWkt( char **, int = FALSE) const;
     // cppcheck-suppress functionStatic
     OGRErr      exportToPROJJSON( char **, const char* const* papszOptions ) const;
     OGRErr      exportToProj4( char ** ) const;
     OGRErr      exportToPCI( char **, char **, double ** ) const;
     OGRErr      exportToUSGS( long *, long *, double **, long * ) const;
     OGRErr      exportToXML( char **, const char * = nullptr ) const;
     OGRErr      exportToPanorama( long *, long *, long *, long *,
                                   double * ) const;
     OGRErr      exportToERM( char *pszProj, char *pszDatum, char *pszUnits );
     OGRErr      exportToMICoordSys( char ** ) const;
 
 
     OGRErr      importFromWkt( char ** )
 /*! @cond Doxygen_Suppress */
         CPL_WARN_DEPRECATED("Use importFromWkt(const char**) or importFromWkt(const char*)")
 /*! @endcond */
         ;
 
     OGRErr      importFromWkt( const char ** );
     OGRErr      importFromWkt( const char* );
     OGRErr      importFromProj4( const char * );
     OGRErr      importFromEPSG( int );
     OGRErr      importFromEPSGA( int );
     OGRErr      importFromESRI( char ** );
     OGRErr      importFromPCI( const char *, const char * = nullptr,
                                double * = nullptr );
 
 #define USGS_ANGLE_DECIMALDEGREES 0     /**< Angle is in decimal degrees. */
 #define USGS_ANGLE_PACKEDDMS      TRUE  /**< Angle is in packed degree minute second. */
 #define USGS_ANGLE_RADIANS        2     /**< Angle is in radians. */
     OGRErr      importFromUSGS( long iProjSys, long iZone,
                                 double *padfPrjParams, long iDatum,
                                 int nUSGSAngleFormat = USGS_ANGLE_PACKEDDMS );
     OGRErr      importFromPanorama( long, long, long, double* );
     OGRErr      importVertCSFromPanorama( int );
     OGRErr      importFromOzi( const char * const* papszLines );
     OGRErr      importFromWMSAUTO( const char *pszAutoDef );
     OGRErr      importFromXML( const char * );
     OGRErr      importFromDict( const char *pszDict, const char *pszCode );
     OGRErr      importFromURN( const char * );
     OGRErr      importFromCRSURL( const char * );
     OGRErr      importFromERM( const char *pszProj, const char *pszDatum,
                                const char *pszUnits );
     OGRErr      importFromUrl( const char * );
     OGRErr      importFromMICoordSys( const char * );
 
     OGRErr      morphToESRI();
     OGRErr      morphFromESRI();
 
     OGRSpatialReference* convertToOtherProjection(
                                     const char* pszTargetProjection,
                                     const char* const* papszOptions = nullptr ) const;
 
     OGRErr      Validate() const;
     OGRErr      StripVertical();
 
+    bool        StripTOWGS84IfKnownDatumAndAllowed();
+    bool        StripTOWGS84IfKnownDatum();
+
     int         EPSGTreatsAsLatLong() const;
     int         EPSGTreatsAsNorthingEasting() const;
     int         GetAxesCount() const;
     const char *GetAxis( const char *pszTargetKey, int iAxis,
                          OGRAxisOrientation *peOrientation ) const;
     OGRErr      SetAxes( const char *pszTargetKey,
                          const char *pszXAxisName,
                          OGRAxisOrientation eXAxisOrientation,
                          const char *pszYAxisName,
                          OGRAxisOrientation eYAxisOrientation );
 
     OSRAxisMappingStrategy GetAxisMappingStrategy() const;
     void                   SetAxisMappingStrategy(OSRAxisMappingStrategy);
     const std::vector<int>& GetDataAxisToSRSAxisMapping() const;
     OGRErr                 SetDataAxisToSRSAxisMapping(const std::vector<int>& mapping);
 
     // Machinery for accessing parse nodes
 
     //! Return root node
     OGR_SRSNode *GetRoot();
     //! Return root node
     const OGR_SRSNode *GetRoot() const;
     void        SetRoot( OGR_SRSNode * );
 
     OGR_SRSNode *GetAttrNode(const char *);
     const OGR_SRSNode *GetAttrNode(const char *) const;
     const char  *GetAttrValue(const char *, int = 0) const;
 
     OGRErr      SetNode( const char *, const char * );
     OGRErr      SetNode( const char *, double );
 
     OGRErr      SetLinearUnitsAndUpdateParameters( const char *pszName,
                                                    double dfInMeters,
                                                    const char *pszUnitAuthority = nullptr,
                                                    const char *pszUnitCode = nullptr );
     OGRErr      SetLinearUnits( const char *pszName, double dfInMeters );
     OGRErr      SetTargetLinearUnits( const char *pszTargetKey,
                                       const char *pszName,
                                       double dfInMeters,
                                       const char *pszUnitAuthority = nullptr,
                                       const char *pszUnitCode = nullptr);
 
     double      GetLinearUnits( char ** ) const CPL_WARN_DEPRECATED("Use GetLinearUnits(const char**) instead");
     double      GetLinearUnits( const char ** = nullptr ) const;
 /*! @cond Doxygen_Suppress */
     double      GetLinearUnits( std::nullptr_t ) const
         { return GetLinearUnits( static_cast<const char**>(nullptr) ); }
 /*! @endcond */
 
     double      GetTargetLinearUnits( const char *pszTargetKey,
                                       char ** ppszRetName ) const
             CPL_WARN_DEPRECATED("Use GetTargetLinearUnits(const char*, const char**)");
     double      GetTargetLinearUnits( const char *pszTargetKey,
                                       const char ** ppszRetName = nullptr ) const;
 /*! @cond Doxygen_Suppress */
     double      GetTargetLinearUnits( const char *pszTargetKey, std::nullptr_t ) const
         { return GetTargetLinearUnits( pszTargetKey, static_cast<const char**>(nullptr) ); }
 /*! @endcond */
 
     OGRErr      SetAngularUnits( const char *pszName, double dfInRadians );
     double      GetAngularUnits( char ** ) const CPL_WARN_DEPRECATED("Use GetAngularUnits(const char**) instead");
     double      GetAngularUnits( const char ** = nullptr ) const;
 /*! @cond Doxygen_Suppress */
     double      GetAngularUnits( std::nullptr_t ) const
         { return GetAngularUnits( static_cast<const char**>(nullptr) ); }
 /*! @endcond */
 
     double      GetPrimeMeridian( char ** ) const CPL_WARN_DEPRECATED("Use GetPrimeMeridian(const char**) instead");
     double      GetPrimeMeridian( const char ** = nullptr ) const;
 /*! @cond Doxygen_Suppress */
     double      GetPrimeMeridian( std::nullptr_t ) const
         { return GetPrimeMeridian( static_cast<const char**>(nullptr) ); }
 /*! @endcond */
 
     bool        IsEmpty() const;
     int         IsGeographic() const;
     int         IsProjected() const;
     int         IsGeocentric() const;
     int         IsLocal() const;
     int         IsVertical() const;
     int         IsCompound() const;
     int         IsSameGeogCS( const OGRSpatialReference * ) const;
     int         IsSameGeogCS( const OGRSpatialReference *,
                               const char* const * papszOptions ) const;
     int         IsSameVertCS( const OGRSpatialReference * ) const;
     int         IsSame( const OGRSpatialReference * ) const;
     int         IsSame( const OGRSpatialReference *,
                         const char* const * papszOptions ) const;
 
     void        Clear();
     OGRErr      SetLocalCS( const char * );
     OGRErr      SetProjCS( const char * );
     OGRErr      SetProjection( const char * );
     OGRErr      SetGeocCS( const char * pszGeocName );
     OGRErr      SetGeogCS( const char * pszGeogName,
                            const char * pszDatumName,
                            const char * pszEllipsoidName,
                            double dfSemiMajor, double dfInvFlattening,
                            const char * pszPMName = nullptr,
                            double dfPMOffset = 0.0,
                            const char * pszUnits = nullptr,
                            double dfConvertToRadians = 0.0 );
     OGRErr      SetWellKnownGeogCS( const char * );
     OGRErr      CopyGeogCSFrom( const OGRSpatialReference * poSrcSRS );
     OGRErr      SetVertCS( const char *pszVertCSName,
                            const char *pszVertDatumName,
                            int nVertDatumClass = 2005 );
     OGRErr      SetCompoundCS( const char *pszName,
                                const OGRSpatialReference *poHorizSRS,
                                const OGRSpatialReference *poVertSRS );
 
     // cppcheck-suppress functionStatic
     OGRErr      PromoteTo3D( const char* pszName );
 
     OGRErr      SetFromUserInput( const char * );
 
     OGRErr      SetTOWGS84( double, double, double,
                             double = 0.0, double = 0.0, double = 0.0,
                             double = 0.0 );
     OGRErr      GetTOWGS84( double *padfCoef, int nCoeff = 7 ) const;
     OGRErr      AddGuessedTOWGS84();
 
     double      GetSemiMajor( OGRErr * = nullptr ) const;
     double      GetSemiMinor( OGRErr * = nullptr ) const;
     double      GetInvFlattening( OGRErr * = nullptr ) const;
     double      GetEccentricity() const;
     double      GetSquaredEccentricity() const;
 
     OGRErr      SetAuthority( const char * pszTargetKey,
                               const char * pszAuthority,
                               int nCode );
 
     OGRErr      AutoIdentifyEPSG();
     OGRSpatialReferenceH* FindMatches( char** papszOptions,
                                        int* pnEntries,
                                        int** ppanMatchConfidence ) const;
 
     int         GetEPSGGeogCS() const;
 
     const char *GetAuthorityCode( const char * pszTargetKey ) const;
     const char *GetAuthorityName( const char * pszTargetKey ) const;
 
     bool        GetAreaOfUse( double* pdfWestLongitudeDeg,
                               double* pdfSouthLatitudeDeg,
                               double* pdfEastLongitudeDeg,
                               double* pdfNorthLatitudeDeg,
                               const char **ppszAreaName ) const;
 
     const char *GetExtension( const char *pszTargetKey,
                               const char *pszName,
                               const char *pszDefault = nullptr ) const;
     OGRErr      SetExtension( const char *pszTargetKey,
                               const char *pszName,
                               const char *pszValue );
 
     int         FindProjParm( const char *pszParameter,
                               const OGR_SRSNode *poPROJCS=nullptr ) const;
     OGRErr      SetProjParm( const char *, double );
     double      GetProjParm( const char *, double =0.0, OGRErr* = nullptr ) const;
 
     OGRErr      SetNormProjParm( const char *, double );
     double      GetNormProjParm( const char *, double=0.0, OGRErr* =nullptr)const;
 
     static int  IsAngularParameter( const char * );
     static int  IsLongitudeParameter( const char * );
     static int  IsLinearParameter( const char * );
 
     /** Albers Conic Equal Area */
     OGRErr      SetACEA( double dfStdP1, double dfStdP2,
                          double dfCenterLat, double dfCenterLong,
                          double dfFalseEasting, double dfFalseNorthing );
 
     /** Azimuthal Equidistant */
     OGRErr      SetAE( double dfCenterLat, double dfCenterLong,
                        double dfFalseEasting, double dfFalseNorthing );
 
     /** Bonne */
     OGRErr      SetBonne( double dfStdP1, double dfCentralMeridian,
                           double dfFalseEasting, double dfFalseNorthing );
 
     /** Cylindrical Equal Area */
     OGRErr      SetCEA( double dfStdP1, double dfCentralMeridian,
                         double dfFalseEasting, double dfFalseNorthing );
 
     /** Cassini-Soldner */
     OGRErr      SetCS( double dfCenterLat, double dfCenterLong,
                        double dfFalseEasting, double dfFalseNorthing );
 
     /** Equidistant Conic */
     OGRErr      SetEC( double dfStdP1, double dfStdP2,
                        double dfCenterLat, double dfCenterLong,
                        double dfFalseEasting, double dfFalseNorthing );
 
     /** Eckert I */
     OGRErr      SetEckert( int nVariation, double dfCentralMeridian,
                            double dfFalseEasting, double dfFalseNorthing );
 
     /** Eckert IV */
     OGRErr      SetEckertIV( double dfCentralMeridian,
                              double dfFalseEasting, double dfFalseNorthing );
 
     /** Eckert VI */
     OGRErr      SetEckertVI( double dfCentralMeridian,
                              double dfFalseEasting, double dfFalseNorthing );
 
     /** Equirectangular */
     OGRErr      SetEquirectangular(double dfCenterLat, double dfCenterLong,
                             double dfFalseEasting, double dfFalseNorthing );
     /** Equirectangular generalized form : */
     OGRErr      SetEquirectangular2( double dfCenterLat, double dfCenterLong,
                                      double dfPseudoStdParallel1,
                                      double dfFalseEasting, double dfFalseNorthing );
 
     /** Geostationary Satellite */
     OGRErr      SetGEOS( double dfCentralMeridian, double dfSatelliteHeight,
                          double dfFalseEasting, double dfFalseNorthing );
 
     /** Goode Homolosine */
     OGRErr      SetGH( double dfCentralMeridian,
                        double dfFalseEasting, double dfFalseNorthing );
 
     /** Interrupted Goode Homolosine */
     OGRErr      SetIGH();
 
     /** Gall Stereograpic */
     OGRErr      SetGS( double dfCentralMeridian,
                        double dfFalseEasting, double dfFalseNorthing );
 
     /** Gauss Schreiber Transverse Mercator */
     OGRErr      SetGaussSchreiberTMercator(double dfCenterLat, double dfCenterLong,
                                            double dfScale,
                                            double dfFalseEasting, double dfFalseNorthing );
 
     /** Gnomonic */
     OGRErr      SetGnomonic(double dfCenterLat, double dfCenterLong,
                             double dfFalseEasting, double dfFalseNorthing );
 
     /** Hotine Oblique Mercator */
     OGRErr      SetHOM( double dfCenterLat, double dfCenterLong,
                         double dfAzimuth, double dfRectToSkew,
                         double dfScale,
                         double dfFalseEasting, double dfFalseNorthing );
 
     /**  Hotine Oblique Mercator 2 points */
     OGRErr      SetHOM2PNO( double dfCenterLat,
                             double dfLat1, double dfLong1,
                             double dfLat2, double dfLong2,
                             double dfScale,
                             double dfFalseEasting, double dfFalseNorthing );
 
     /** Hotine Oblique Mercator Azimuth Center / Variant B */
     OGRErr      SetHOMAC( double dfCenterLat, double dfCenterLong,
                           double dfAzimuth, double dfRectToSkew,
                           double dfScale,
                           double dfFalseEasting, double dfFalseNorthing );
 
     /** Laborde Oblique Mercator */
     OGRErr      SetLOM( double dfCenterLat, double dfCenterLong,
                         double dfAzimuth,
                         double dfScale,
                         double dfFalseEasting, double dfFalseNorthing );
 
     /** International Map of the World Polyconic */
     OGRErr      SetIWMPolyconic( double dfLat1, double dfLat2,
                                  double dfCenterLong,
                                  double dfFalseEasting,
                                  double dfFalseNorthing );
 
     /** Krovak Oblique Conic Conformal */
     OGRErr      SetKrovak( double dfCenterLat, double dfCenterLong,
                            double dfAzimuth, double dfPseudoStdParallelLat,
                            double dfScale,
                            double dfFalseEasting, double dfFalseNorthing );
 
     /** Lambert Azimuthal Equal-Area */
     OGRErr      SetLAEA( double dfCenterLat, double dfCenterLong,
                          double dfFalseEasting, double dfFalseNorthing );
 
     /** Lambert Conformal Conic */
     OGRErr      SetLCC( double dfStdP1, double dfStdP2,
                         double dfCenterLat, double dfCenterLong,
                         double dfFalseEasting, double dfFalseNorthing );
 
     /** Lambert Conformal Conic 1SP */
     OGRErr      SetLCC1SP( double dfCenterLat, double dfCenterLong,
                            double dfScale,
                            double dfFalseEasting, double dfFalseNorthing );
 
     /** Lambert Conformal Conic (Belgium) */
     OGRErr      SetLCCB( double dfStdP1, double dfStdP2,
                          double dfCenterLat, double dfCenterLong,
                          double dfFalseEasting, double dfFalseNorthing );
 
     /** Miller Cylindrical */
     OGRErr      SetMC( double dfCenterLat, double dfCenterLong,
                        double dfFalseEasting, double dfFalseNorthing );
 
     /** Mercator 1SP */
     OGRErr      SetMercator( double dfCenterLat, double dfCenterLong,
                              double dfScale,
                              double dfFalseEasting, double dfFalseNorthing );
 
     /** Mercator 2SP */
     OGRErr      SetMercator2SP( double dfStdP1,
                                 double dfCenterLat, double dfCenterLong,
                                 double dfFalseEasting, double dfFalseNorthing );
 
     /** Mollweide */
     OGRErr      SetMollweide( double dfCentralMeridian,
                               double dfFalseEasting, double dfFalseNorthing );
 
     /** New Zealand Map Grid */
     OGRErr      SetNZMG( double dfCenterLat, double dfCenterLong,
                          double dfFalseEasting, double dfFalseNorthing );
 
     /** Oblique Stereographic */
     OGRErr      SetOS( double dfOriginLat, double dfCMeridian,
                        double dfScale,
                        double dfFalseEasting,double dfFalseNorthing);
 
     /** Orthographic */
     OGRErr      SetOrthographic( double dfCenterLat, double dfCenterLong,
                                  double dfFalseEasting,double dfFalseNorthing);
 
     /** Polyconic */
     OGRErr      SetPolyconic( double dfCenterLat, double dfCenterLong,
                               double dfFalseEasting, double dfFalseNorthing );
 
     /** Polar Stereographic */
     OGRErr      SetPS( double dfCenterLat, double dfCenterLong,
                        double dfScale,
                        double dfFalseEasting, double dfFalseNorthing);
 
     /** Robinson */
     OGRErr      SetRobinson( double dfCenterLong,
                              double dfFalseEasting, double dfFalseNorthing );
 
     /** Sinusoidal */
     OGRErr      SetSinusoidal( double dfCenterLong,
                                double dfFalseEasting, double dfFalseNorthing );
 
     /** Stereographic */
     OGRErr      SetStereographic( double dfCenterLat, double dfCenterLong,
                                   double dfScale,
                                  double dfFalseEasting,double dfFalseNorthing);
 
     /** Swiss Oblique Cylindrical */
     OGRErr      SetSOC( double dfLatitudeOfOrigin, double dfCentralMeridian,
                         double dfFalseEasting, double dfFalseNorthing );
 
     /** Transverse Mercator */
     OGRErr      SetTM( double dfCenterLat, double dfCenterLong,
                        double dfScale,
                        double dfFalseEasting, double dfFalseNorthing );
 
     /** Transverse Mercator variants. */
     OGRErr      SetTMVariant( const char *pszVariantName,
                               double dfCenterLat, double dfCenterLong,
                               double dfScale,
                               double dfFalseEasting, double dfFalseNorthing );
 
     /** Tunesia Mining Grid  */
     OGRErr      SetTMG( double dfCenterLat, double dfCenterLong,
                         double dfFalseEasting, double dfFalseNorthing );
 
     /** Transverse Mercator (South Oriented) */
     OGRErr      SetTMSO( double dfCenterLat, double dfCenterLong,
                          double dfScale,
                          double dfFalseEasting, double dfFalseNorthing );
 
     /** Two Point Equidistant */
     OGRErr      SetTPED( double dfLat1, double dfLong1,
                          double dfLat2, double dfLong2,
                          double dfFalseEasting, double dfFalseNorthing );
 
     /** VanDerGrinten */
     OGRErr      SetVDG( double dfCenterLong,
                         double dfFalseEasting, double dfFalseNorthing );
 
     /** Universal Transverse Mercator */
     OGRErr      SetUTM( int nZone, int bNorth = TRUE );
     int         GetUTMZone( int *pbNorth = nullptr ) const;
 
     /** Wagner I -- VII */
     OGRErr      SetWagner( int nVariation, double dfCenterLat,
                            double dfFalseEasting, double dfFalseNorthing );
 
     /** Quadrilateralized Spherical Cube */
     OGRErr      SetQSC(double dfCenterLat, double dfCenterLong);
 
     /** Spherical, Cross-track, Height */
     OGRErr      SetSCH( double dfPegLat, double dfPegLong,
                         double dfPegHeading, double dfPegHgt);
 
     /** Vertical Perspective / Near-sided Perspective */
     OGRErr      SetVerticalPerspective( double dfTopoOriginLat,
                                         double dfTopoOriginLon,
                                         double dfTopoOriginHeight,
                                         double dfViewPointHeight,
                                         double dfFalseEasting,
                                         double dfFalseNorthing);
 
     /** Pole rotation (GRIB convention) */
     OGRErr      SetDerivedGeogCRSWithPoleRotationGRIBConvention(
                                                const char* pszCRSName,
                                                double dfSouthPoleLat,
                                                double dfSouthPoleLon,
                                                double dfAxisRotation );
 
     /** State Plane */
     OGRErr      SetStatePlane( int nZone, int bNAD83 = TRUE,
                                const char *pszOverrideUnitName = nullptr,
                                double dfOverrideUnit = 0.0 );
 
     /** ImportFromESRIStatePlaneWKT */
     OGRErr      ImportFromESRIStatePlaneWKT(
         int nCode, const char* pszDatumName, const char* pszUnitsName,
         int nPCSCode, const char* pszCRSName = nullptr );
 
     /** ImportFromESRIWisconsinWKT */
     OGRErr      ImportFromESRIWisconsinWKT(
         const char* pszPrjName, double dfCentralMeridian, double dfLatOfOrigin,
         const char* pszUnitsName, const char* pszCRSName = nullptr );
 
 /*! @cond Doxygen_Suppress */
     void UpdateCoordinateSystemFromGeogCRS();
 /*! @endcond */
 
     static OGRSpatialReference* GetWGS84SRS();
 
     /** Convert a OGRSpatialReference* to a OGRSpatialReferenceH.
      * @since GDAL 2.3
      */
     static inline OGRSpatialReferenceH ToHandle(OGRSpatialReference* poSRS)
         { return reinterpret_cast<OGRSpatialReferenceH>(poSRS); }
 
     /** Convert a OGRSpatialReferenceH to a OGRSpatialReference*.
      * @since GDAL 2.3
      */
     static inline OGRSpatialReference* FromHandle(OGRSpatialReferenceH hSRS)
         { return reinterpret_cast<OGRSpatialReference*>(hSRS); }
 
 };
 
 /************************************************************************/
 /*                     OGRCoordinateTransformation                      */
 /*                                                                      */
 /*      This is really just used as a base class for a private          */
 /*      implementation.                                                 */
 /************************************************************************/
 
 /**
  * Interface for transforming between coordinate systems.
  *
  * Currently, the only implementation within OGR is OGRProjCT, which
  * requires the PROJ library.
  *
  * Also, see OGRCreateCoordinateTransformation() for creating transformations.
  */
diff --git a/gdal/ogr/ogrsf_frmts/gpkg/ogrgeopackagedatasource.cpp b/gdal/ogr/ogrsf_frmts/gpkg/ogrgeopackagedatasource.cpp
index 352020e88b..79432b86eb 100644
--- a/gdal/ogr/ogrsf_frmts/gpkg/ogrgeopackagedatasource.cpp
+++ b/gdal/ogr/ogrsf_frmts/gpkg/ogrgeopackagedatasource.cpp
@@ -261,69 +261,70 @@ static OGRErr GDALGPKGImportFromEPSG(OGRSpatialReference *poSpatialRef,
 OGRSpatialReference* GDALGeoPackageDataset::GetSpatialRef(int iSrsId)
 {
     /* Should we do something special with undefined SRS ? */
     if( iSrsId == 0 || iSrsId == -1 )
     {
         return nullptr;
     }
 
     std::map<int, OGRSpatialReference*>::const_iterator oIter =
                                                 m_oMapSrsIdToSrs.find(iSrsId);
     if( oIter != m_oMapSrsIdToSrs.end() )
     {
         if( oIter->second == nullptr )
             return nullptr;
         oIter->second->Reference();
         return oIter->second;
     }
 
     CPLString oSQL;
     oSQL.Printf( "SELECT definition, organization, organization_coordsys_id%s "
                  "FROM gpkg_spatial_ref_sys WHERE definition IS NOT NULL AND "
                  "srs_id = %d LIMIT 2",
                  m_bHasDefinition12_063 ? ", definition_12_063" : "",
                  iSrsId );
 
     SQLResult oResult;
     OGRErr err = SQLQuery(hDB, oSQL.c_str(), &oResult);
 
     if ( err != OGRERR_NONE || oResult.nRowCount != 1 )
     {
         SQLResultFree(&oResult);
         CPLError( CE_Warning, CPLE_AppDefined,
                   "unable to read srs_id '%d' from gpkg_spatial_ref_sys",
                   iSrsId);
         m_oMapSrsIdToSrs[iSrsId] = nullptr;
         return nullptr;
     }
 
     const char *pszWkt = SQLResultGetValue(&oResult, 0, 0);
     const char* pszOrganization = SQLResultGetValue(&oResult, 1, 0);
     const char* pszOrganizationCoordsysID = SQLResultGetValue(&oResult, 2, 0);
     const char *pszWkt2 = m_bHasDefinition12_063 ? SQLResultGetValue(&oResult, 3, 0) : nullptr;
     if( pszWkt2 && !EQUAL(pszWkt2, "undefined") )
         pszWkt = pszWkt2;
 
     OGRSpatialReference *poSpatialRef = new OGRSpatialReference();
     poSpatialRef->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);
     // Try to import first from EPSG code, and then from WKT
     if( !(pszOrganization && pszOrganizationCoordsysID
           && EQUAL(pszOrganization, "EPSG") &&
           atoi(pszOrganizationCoordsysID) == iSrsId &&
           GDALGPKGImportFromEPSG(poSpatialRef, atoi(pszOrganizationCoordsysID))
           == OGRERR_NONE) &&
         poSpatialRef->SetFromUserInput(pszWkt) != OGRERR_NONE )
     {
         CPLError( CE_Warning, CPLE_AppDefined,
                   "Unable to parse srs_id '%d' well-known text '%s'",
                 iSrsId, pszWkt);
         SQLResultFree(&oResult);
         delete poSpatialRef;
         m_oMapSrsIdToSrs[iSrsId] = nullptr;
         return nullptr;
     }
 
     SQLResultFree(&oResult);
+    poSpatialRef->StripTOWGS84IfKnownDatumAndAllowed();
     m_oMapSrsIdToSrs[iSrsId] = poSpatialRef;
     poSpatialRef->Reference();
     return poSpatialRef;
 }
diff --git a/gdal/ogr/ogrsf_frmts/sqlite/ogrsqlitedatasource.cpp b/gdal/ogr/ogrsf_frmts/sqlite/ogrsqlitedatasource.cpp
index 92d42ad7eb..5066447302 100644
--- a/gdal/ogr/ogrsf_frmts/sqlite/ogrsqlitedatasource.cpp
+++ b/gdal/ogr/ogrsf_frmts/sqlite/ogrsqlitedatasource.cpp
@@ -3590,155 +3590,158 @@ int OGRSQLiteDataSource::FetchSRSId( const OGRSpatialReference * poSRS )
 OGRSpatialReference *OGRSQLiteDataSource::FetchSRS( int nId )
 
 {
     if( nId <= 0 )
         return nullptr;
 
 /* -------------------------------------------------------------------- */
 /*      First, we look through our SRID cache, is it there?             */
 /* -------------------------------------------------------------------- */
     for( int i = 0; i < nKnownSRID; i++ )
     {
         if( panSRID[i] == nId )
             return papoSRS[i];
     }
 
 /* -------------------------------------------------------------------- */
 /*      Try looking up in spatial_ref_sys table.                        */
 /* -------------------------------------------------------------------- */
     char *pszErrMsg = nullptr;
     char **papszResult = nullptr;
     int nRowCount = 0;
     int nColCount = 0;
     OGRSpatialReference *poSRS = nullptr;
 
     CPLString osCommand;
     osCommand.Printf( "SELECT srtext FROM spatial_ref_sys WHERE srid = %d "
                       "LIMIT 2",
                       nId );
     int rc =
         sqlite3_get_table(
             hDB, osCommand,
             &papszResult, &nRowCount, &nColCount, &pszErrMsg );
 
     if ( rc == SQLITE_OK )
     {
         if( nRowCount < 1 )
         {
             sqlite3_free_table(papszResult);
             return nullptr;
         }
 
         char** papszRow = papszResult + nColCount;
         if (papszRow[0] != nullptr)
         {
             CPLString osWKT = papszRow[0];
 
 /* -------------------------------------------------------------------- */
 /*      Translate into a spatial reference.                             */
 /* -------------------------------------------------------------------- */
             poSRS = new OGRSpatialReference();
             poSRS->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);
             if( poSRS->importFromWkt( osWKT.c_str() ) != OGRERR_NONE )
             {
                 delete poSRS;
                 poSRS = nullptr;
             }
         }
 
         sqlite3_free_table(papszResult);
     }
 
 /* -------------------------------------------------------------------- */
 /*      Next try SpatiaLite flavor. SpatiaLite uses PROJ.4 strings     */
 /*      in 'proj4text' column instead of WKT in 'srtext'. Note: recent  */
 /*      versions of spatialite have a srs_wkt column too                */
 /* -------------------------------------------------------------------- */
     else
     {
         sqlite3_free( pszErrMsg );
         pszErrMsg = nullptr;
 
         const char* pszSRTEXTColName = GetSRTEXTColName();
         CPLString osSRTEXTColNameWithCommaBefore;
         if( pszSRTEXTColName != nullptr )
             osSRTEXTColNameWithCommaBefore.Printf(", %s", pszSRTEXTColName);
 
         osCommand.Printf(
             "SELECT proj4text, auth_name, auth_srid%s FROM spatial_ref_sys "
             "WHERE srid = %d LIMIT 2",
             (pszSRTEXTColName != nullptr) ? osSRTEXTColNameWithCommaBefore.c_str() : "", nId );
         rc = sqlite3_get_table( hDB, osCommand,
                                 &papszResult, &nRowCount,
                                 &nColCount, &pszErrMsg );
         if ( rc == SQLITE_OK )
         {
             if( nRowCount < 1 )
             {
                 sqlite3_free_table(papszResult);
                 return nullptr;
             }
 
 /* -------------------------------------------------------------------- */
 /*      Translate into a spatial reference.                             */
 /* -------------------------------------------------------------------- */
             char** papszRow = papszResult + nColCount;
 
             const char* pszProj4Text = papszRow[0];
             const char* pszAuthName = papszRow[1];
             int nAuthSRID = (papszRow[2] != nullptr) ? atoi(papszRow[2]) : 0;
             const char* pszWKT = (pszSRTEXTColName != nullptr) ? papszRow[3] : nullptr;
 
             poSRS = new OGRSpatialReference();
             poSRS->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);
 
             /* Try first from EPSG code */
             if (pszAuthName != nullptr &&
                 EQUAL(pszAuthName, "EPSG") &&
                 poSRS->importFromEPSG( nAuthSRID ) == OGRERR_NONE)
             {
                 /* Do nothing */
             }
             /* Then from WKT string */
             else if( pszWKT != nullptr &&
                      poSRS->importFromWkt( pszWKT ) == OGRERR_NONE )
             {
                 /* Do nothing */
             }
             /* Finally from Proj4 string */
             else if( pszProj4Text != nullptr &&
                      poSRS->importFromProj4( pszProj4Text ) == OGRERR_NONE )
             {
                 /* Do nothing */
             }
             else
             {
                 delete poSRS;
                 poSRS = nullptr;
             }
 
             sqlite3_free_table(papszResult);
         }
 
 /* -------------------------------------------------------------------- */
 /*      No success, report an error.                                    */
 /* -------------------------------------------------------------------- */
         else
         {
             CPLError( CE_Failure, CPLE_AppDefined,
                       "%s: %s", osCommand.c_str(), pszErrMsg );
             sqlite3_free( pszErrMsg );
             return nullptr;
         }
     }
 
+    if( poSRS )
+        poSRS->StripTOWGS84IfKnownDatumAndAllowed();
+
 /* -------------------------------------------------------------------- */
 /*      Add to the cache.                                               */
 /* -------------------------------------------------------------------- */
     AddSRIDToCache(nId, poSRS);
 
     return poSRS;
 }
 
 /************************************************************************/
 /*                              SetName()                               */
 /************************************************************************/
diff --git a/gdal/ogr/ogrspatialreference.cpp b/gdal/ogr/ogrspatialreference.cpp
index fff6078f71..b194bdadf0 100644
--- a/gdal/ogr/ogrspatialreference.cpp
+++ b/gdal/ogr/ogrspatialreference.cpp
@@ -7803,58 +7803,175 @@ const char *OSRGetAuthorityName( OGRSpatialReferenceH hSRS,
 OGRErr OGRSpatialReference::StripVertical()
 
 {
     d->refreshProjObj();
     d->demoteFromBoundCRS();
     if( !d->m_pj_crs || d->m_pjType != PJ_TYPE_COMPOUND_CRS )
     {
         d->undoDemoteFromBoundCRS();
         return OGRERR_NONE;
     }
     auto horizCRS =
         proj_crs_get_sub_crs(d->getPROJContext(), d->m_pj_crs, 0);
     if( !horizCRS )
     {
         d->undoDemoteFromBoundCRS();
         return OGRERR_FAILURE;
     }
 
     bool reuseExistingBoundCRS = false;
     if( d->m_pj_bound_crs_target )
     {
         auto type = proj_get_type(d->m_pj_bound_crs_target);
         reuseExistingBoundCRS =
             type == PJ_TYPE_GEOCENTRIC_CRS ||
             type == PJ_TYPE_GEOGRAPHIC_2D_CRS ||
             type == PJ_TYPE_GEOGRAPHIC_3D_CRS;
     }
 
     if( reuseExistingBoundCRS )
     {
         auto newBoundCRS =
             proj_crs_create_bound_crs(
                 d->getPROJContext(), horizCRS,
                 d->m_pj_bound_crs_target, d->m_pj_bound_crs_co);
         proj_destroy(horizCRS);
         d->undoDemoteFromBoundCRS();
         d->setPjCRS(newBoundCRS);
     }
     else
     {
         d->undoDemoteFromBoundCRS();
         d->setPjCRS(horizCRS);
     }
 
     return OGRERR_NONE;
 }
 
+/************************************************************************/
+/*                   StripTOWGS84IfKnownDatumAndAllowed()               */
+/************************************************************************/
+
+/**
+ * \brief Remove TOWGS84 information if the CRS has a known horizontal datum
+ *        and this is allowed by the user.
+ *
+ * The default behaviour is to remove TOWGS84 information if the CRS has a
+ * known horizontal datum. This can be disabled by setting the
+ * OSR_STRIP_TOWGS84 configuration option to NO.
+ *
+ * @return true if TOWGS84 has been removed.
+ * @since OGR 3.1.0
+ */
+
+bool OGRSpatialReference::StripTOWGS84IfKnownDatumAndAllowed()
+{
+    if( CPLTestBool(CPLGetConfigOption("OSR_STRIP_TOWGS84", "YES")) )
+    {
+        if( StripTOWGS84IfKnownDatum() )
+        {
+            CPLDebug("OSR", "TOWGS84 information has been removed. "
+                     "It can be kept by setting the OSR_STRIP_TOWGS84 "
+                     "configuration option to NO");
+            return true;
+        }
+    }
+    return false;
+}
+
+/************************************************************************/
+/*                      StripTOWGS84IfKnownDatum()                      */
+/************************************************************************/
+
+/**
+ * \brief Remove TOWGS84 information if the CRS has a known horizontal datum
+ *
+ * @return true if TOWGS84 has been removed.
+ * @since OGR 3.1.0
+ */
+
+bool OGRSpatialReference::StripTOWGS84IfKnownDatum()
+
+{
+    d->refreshProjObj();
+    if( !d->m_pj_crs || d->m_pjType != PJ_TYPE_BOUND_CRS )
+    {
+        return false;
+    }
+    auto ctxt = d->getPROJContext();
+    auto baseCRS = proj_get_source_crs(ctxt, d->m_pj_crs);
+    if( proj_get_type(baseCRS) == PJ_TYPE_COMPOUND_CRS )
+    {
+        proj_destroy(baseCRS);
+        return false;
+    }
+
+    // Known base CRS code ? Return base CRS
+    const char* pszCode = proj_get_id_code(baseCRS, 0);
+    if( pszCode )
+    {
+        d->setPjCRS(baseCRS);
+        return true;
+    }
+
+    auto datum = proj_crs_get_datum(ctxt, baseCRS);
+    if( !datum )
+    {
+        proj_destroy(baseCRS);
+        return false;
+    }
+
+    // Known datum code ? Return base CRS
+    pszCode = proj_get_id_code(datum, 0);
+    if( pszCode )
+    {
+        proj_destroy(datum);
+        d->setPjCRS(baseCRS);
+        return true;
+    }
+
+    const char* name = proj_get_name(datum);
+    if( EQUAL(name, "unknown") )
+    {
+        proj_destroy(datum);
+        proj_destroy(baseCRS);
+        return false;
+    }
+    const PJ_TYPE type = PJ_TYPE_GEODETIC_REFERENCE_FRAME;
+    PJ_OBJ_LIST* list = proj_create_from_name(ctxt, nullptr,
+                                              name,
+                                              &type, 1,
+                                              false,
+                                              1,
+                                              nullptr);
+
+    bool knownDatumName = false;
+    if( list )
+    {
+        if( proj_list_get_count(list) == 1 )
+        {
+            knownDatumName = true;
+        }
+        proj_list_destroy(list);
+    }
+
+    proj_destroy(datum);
+    if( knownDatumName )
+    {
+        d->setPjCRS(baseCRS);
+        return true;
+    }
+    proj_destroy(baseCRS);
+    return false;
+}
+
 /************************************************************************/
 /*                             IsCompound()                             */
 /************************************************************************/
 
 /**
  * \brief Check if coordinate system is compound.
  *
  * This method is the same as the C function OSRIsCompound().
  *
  * @return TRUE if this is rooted with a COMPD_CS node.
  */
