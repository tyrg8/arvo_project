commit 8e41a50de40011a974d57adfed876b26faf116ba
Author: Mallikarjun Kamble <mallikarjun.kamble@ittiam.com>
Date:   Tue Feb 14 11:12:24 2023 +0530

    libavc: Added support for SII SEI message
    
    - Add SII flag and SII parameters for the encoder and decoder.
    - Encoder: Added support for SII SEI
    - Decoder: Added support for SII SEI parsing and exporting

diff --git a/common/ih264_defs.h b/common/ih264_defs.h
index 392c67f..9a564c9 100644
--- a/common/ih264_defs.h
+++ b/common/ih264_defs.h
@@ -442,337 +442,347 @@ typedef enum
 typedef enum
 {
     B_DIRECT_8x8,
     B_L0_8x8,
     B_L1_8x8,
     B_BI_8x8,
     B_L0_8x4,
     B_L0_4x8,
     B_L1_8x4,
     B_L1_4x8,
     B_BI_8x4,
     B_BI_4x8,
     B_L0_4x4,
     B_L1_4x4,
     B_BI_4x4,
 }SUBMBTYPE_BSLICE_T;
 
 /**
  * DC Mode pattern for 4 4x4 sub blocks in an MB row
  */
 #define DC_I16X16_MB_ROW (DC_I16x16 << 24) | (DC_I16x16 << 16) | \
                          (DC_I16x16 << 8)  | DC_I16x16
 
 
 
 /*****************************************************************************/
 /* Constant Macros                                                           */
 /*****************************************************************************/
 
 /*****************************************************************************/
 /* Reference frame defs                                                      */
 /*****************************************************************************/
 /* Maximum DPB size */
 #define MAX_DPB_SIZE 16
 
 /* Maximum mmco commands in slice header */
 #define MAX_MMCO_COMMANDS 32
 
 /* Maximum reference reorder idc */
 #define MAX_MODICATION_IDC 32
 
 /*****************************************************************************/
 /* SPS restrictions                                                          */
 /*****************************************************************************/
 
 /* Number of SPS allowed */
 /* An extra buffer is allocated to write the parsed data
  * It is copied to the appropriate location later */
 #define MAX_SPS_CNT         (32 + 1)
 
 /* Maximum long term reference pics */
 #define MAX_LTREF_PICS_SPS 16
 
 /* Maximum short term reference pics */
 #define MAX_STREF_PICS_SPS 64
 
 
 /*****************************************************************************/
 /* PPS restrictions                                                          */
 /*****************************************************************************/
 
 /* Number of PPS allowed  */
 /* An extra buffer is allocated to write the parsed data
  * It is copied to the appropriate location later */
 #define MAX_PPS_CNT         (256 + 1)
 
 /*****************************************************************************/
 /* Macro definitions for sizes of MB, PU, TU, CU                            */
 /*****************************************************************************/
 #define MB_SIZE             16
 #define BLK8x8SIZE          8
 #define BLK_SIZE            4
 
 
 /* TU Size Range */
 #define MAX_TU_SIZE         8
 #define MIN_TU_SIZE         4
 
 /* Max Transform Size */
 #define MAX_TRANS_SIZE      (MAX_TU_SIZE*MAX_TU_SIZE)
 
 /* PU Size Range */
 #define MAX_PU_SIZE         16
 #define MIN_PU_SIZE         4
 
 /* Number of max TU in a MB row */
 #define MAX_TU_IN_MB_ROW   ((MB_SIZE / MIN_TU_SIZE))
 
 #define MIN_TU_IN_MB_ROW ((MB_SIZE / MAX_TU_SIZE))
 
 /* Number of max PU in a CTb row */
 #define MAX_PU_IN_MB_ROW   ((MB_SIZE / MIN_PU_SIZE))
 
 #define MAX_TU_IN_MB_COL MAX_TU_IN_MB_ROW
 
 #define MIN_TU_IN_MB_COL MIN_TU_IN_MB_ROW
 
 #define MAX_PU_IN_MB_COL MAX_PU_IN_MB_ROW
 
 /* Number of max PU in a MB */
 /*****************************************************************************/
 /* Note though for 64 x 64 MB, Max PU in MB is 128, in order to store      */
 /*  intra pred info, 256 entries are needed                                  */
 /*****************************************************************************/
 #define MAX_PU_IN_MB       ((MB_SIZE / MIN_PU_SIZE) * \
                              (MB_SIZE / MIN_PU_SIZE))
 
 /* Number of max TU in a MB */
 #define MAX_TU_IN_MB       ((MB_SIZE / MIN_TU_SIZE) * \
                              (MB_SIZE / MIN_TU_SIZE))
 
 #define MIN_TU_IN_MB (MIN_TU_IN_MB_ROW * MIN_TU_IN_MB_COL)
 
 #define NUM_4x4_IN_8x8 4
 
 #define NUM_COEFFS_IN_MIN_TU (MIN_TU_SIZE * MIN_TU_SIZE)
 
 /**
  * Maximum transform depths
  */
 #define MAX_TRAFO_DEPTH 5
 
 #define MAX_DC_4x4_SUBBLK_LUMA 1
 #define MAX_AC_4x4_SUBBLK_LUMA 16
 #define MAX_DC_4x4_SUBBLK_CHROMA 2
 #define MAX_AC_4x4_SUBBLK_CHROMA 8
 
 #define MAX_4x4_SUBBLKS (MAX_DC_4x4_SUBBLK_LUMA + MAX_DC_4x4_SUBBLK_CHROMA +\
                          MAX_AC_4x4_SUBBLK_LUMA + MAX_AC_4x4_SUBBLK_CHROMA)
 
 /* Max number of deblocking edges */
 #define MAX_VERT_DEBLK_EDGES ((MB_SIZE/8) * (MB_SIZE/4))
 #define MAX_HORZ_DEBLK_EDGES ((MB_SIZE/4) * (MB_SIZE/8))
 
 /* Qp can not change below 8x8 level */
 #define MAX_DEBLK_QP_CNT     ((MB_SIZE/8) * (MB_SIZE/8))
 
 /*****************************************************************************/
 /* Parsing related macros                                                    */
 /*****************************************************************************/
 #define SUBBLK_COEFF_CNT    16
 
 /* Quant and Trans defs */
 
 /*****************************************************************************/
 /* Sizes for Transform functions                                             */
 /*****************************************************************************/
 #define TRANS_SIZE_4   4
 #define TRANS_SIZE_8   8
 #define TRANS_SIZE_16 16
 #define TRANS_SIZE_32 32
 
 
 #define IT_SHIFT_STAGE_1 7
 #define IT_SHIFT_STAGE_2 12
 
 /**
  * @breif  Maximum transform dynamic range (excluding sign bit)
  */
 #define MAX_TR_DYNAMIC_RANGE  15
 
 /**
  * @brief  Q(QP%6) * IQ(QP%6) = 2^20
  */
 #define QUANT_IQUANT_SHIFT    20
 
 /**
  * @breif Q factor for Qp%6 multiplication
  */
 #define QUANT_SHIFT           14
 
 /**
  * @breif Q shift factor for flat rescale matrix weights
  */
 #define FLAT_RESCALE_MAT_Q_SHIFT    11
 
 /**
  * @breif  Scaling matrix is represented in Q15 format
  */
 #define SCALING_Q_SHIFT       15
 
 /**
  * @brief  rounding factor for quantization represented in Q9 format
  */
 #define QUANT_ROUND_FACTOR_Q   9
 
 /**
  * @brief  Minimum qp supported in H264 spec
  */
 #define MIN_H264_QP 0
 
 /**
  * @brief  Maximum qp supported in H264 spec
  */
 #define MAX_H264_QP 51
 
 /**
  * @brief  Minimum delta scale supported in H264 spec
  */
 #define MIN_H264_DELTA_SCALE (-128)
 
 /**
  * @brief  Maximum delta scale supported in H264 spec
  */
 #define MAX_H264_DELTA_SCALE 127
 
 /**
  * @breif  Total number of transform sizes
  * used for sizeID while getting scale matrix
  */
 #define NUM_UNIQUE_TRANS_SIZE 4
 
 /**
  * @breif  Maximum number of bits in frameNumber signaling
  */
 #define MAX_BITS_IN_FRAME_NUM     16
 
 /**
  * @breif  Maximum number of bits in POC LSB signaling
  */
 #define MAX_BITS_IN_POC_LSB     16
 
 
 /**
  * @breif  Maximum PIC Order Count type
  */
 #define MAX_PIC_ORDER_COUNT_TYPE    2
 
 
 /**
  * @breif  Maximum Weighted bipred idc
  */
 #define MAX_WEIGHT_BIPRED_IDC 2
 
 /*****************************************************************************/
 /* Number of scaling matrices for each transform size                        */
 /*****************************************************************************/
 #define SCALE_MAT_CNT_TRANS_SIZE_4    6
 #define SCALE_MAT_CNT_TRANS_SIZE_8    6
 #define SCALE_MAT_CNT_TRANS_SIZE_16   6
 #define SCALE_MAT_CNT_TRANS_SIZE_32   2
 
 /* Maximum number of scale matrices for a given transform size */
 #define SCALE_MAT_CNT_MAX_PER_TRANS_SIZE 6
 
 /* Total number of scale matrices */
 #define TOTAL_SCALE_MAT_COUNT   (SCALE_MAT_CNT_TRANS_SIZE_4     + \
                                  SCALE_MAT_CNT_TRANS_SIZE_8     + \
                                  SCALE_MAT_CNT_TRANS_SIZE_16    + \
                                  SCALE_MAT_CNT_TRANS_SIZE_32)
 
 
 /*****************************************************************************/
 /* Intra pred Macros                                                         */
 /*****************************************************************************/
 /** Planar Intra prediction mode */
 #define INTRA_PLANAR             0
 
 /** DC Intra prediction mode */
 #define INTRA_DC                 1
 
 /** Gives angular mode for intra prediction */
 #define INTRA_ANGULAR(x) (x)
 
 /** Following is used to signal no intra prediction in case of pcm blocks
  */
 #define INTRA_PRED_NONE  63
 
 
 /** Following is used to signal no intra prediction is needed for first three
  * 4x4 luma blocks in case of 4x4 TU sizes
  * Also used in pcm cases
  */
 #define INTRA_PRED_CHROMA_IDX_NONE  7
 
 
 /**
 ******************************************************************************
  *  @brief  neighbor availability masks
 ******************************************************************************
  */
 #define LEFT_MB_AVAILABLE_MASK      0x01
 #define TOP_LEFT_MB_AVAILABLE_MASK  0x02
 #define TOP_MB_AVAILABLE_MASK       0x04
 #define TOP_RIGHT_MB_AVAILABLE_MASK 0x08
 
 /**
 ******************************************************************************
  *  @brief  SEI macros
 ******************************************************************************
  */
 /*
  * @brief  specifies the number of colour primary components of the mastering display
  */
 #define NUM_SEI_MDCV_PRIMARIES      3
 
 /*
  * @brief  specifies the number of colour primary components of the nominal content colour volume
  */
 #define NUM_SEI_CCV_PRIMARIES       3
 
 #define DISPLAY_PRIMARIES_X_UPPER_LIMIT                37000
 #define DISPLAY_PRIMARIES_X_LOWER_LIMIT                5
 #define DISPLAY_PRIMARIES_X_DIVISION_FACTOR            5
 
 #define DISPLAY_PRIMARIES_Y_UPPER_LIMIT                42000
 #define DISPLAY_PRIMARIES_Y_LOWER_LIMIT                5
 #define DISPLAY_PRIMARIES_Y_DIVISION_FACTOR            5
 
 #define WHITE_POINT_X_UPPER_LIMIT                      37000
 #define WHITE_POINT_X_LOWER_LIMIT                      5
 #define WHITE_POINT_X_DIVISION_FACTOR                  5
 
 #define WHITE_POINT_Y_UPPER_LIMIT                      42000
 #define WHITE_POINT_Y_LOWER_LIMIT                      5
 #define WHITE_POINT_Y_DIVISION_FACTOR                  5
 
 #define MAX_DISPLAY_MASTERING_LUMINANCE_UPPER_LIMIT        100000000
 #define MAX_DISPLAY_MASTERING_LUMINANCE_LOWER_LIMIT        50000
 #define MAX_DISPLAY_MASTERING_LUMINANCE_DIVISION_FACTOR    10000
 
 #define MIN_DISPLAY_MASTERING_LUMINANCE_UPPER_LIMIT        50000
 #define MIN_DISPLAY_MASTERING_LUMINANCE_LOWER_LIMIT        1
 
 #define AMBIENT_LIGHT_X_UPPER_LIMIT        50000
 #define AMBIENT_LIGHT_Y_UPPER_LIMIT        50000
 
 #define CCV_PRIMARIES_X_UPPER_LIMIT        5000000
 #define CCV_PRIMARIES_X_LOWER_LIMIT        -5000000
 #define CCV_PRIMARIES_Y_UPPER_LIMIT        5000000
 #define CCV_PRIMARIES_Y_LOWER_LIMIT        -5000000
 
 #define RSD_MAX 255
 #define RSD_MIN -255
 #define CLIP_RSD(x) CLIP3(RSD_MIN, RSD_MAX, (x))
 
+#define SII_MAX_SUB_LAYERS 8
+#define SII_SUB_LAYER_IDX 0
+#define SHUTTER_INTERVAL_INFO_PRESENT_FLAG 1
+#define SII_TIME_SCALE 24000000
+#define FIXED_SHUTTER_INTERVAL_WITHIN_CVS_FLAG 0
+#define SII_NUM_UNITS_IN_SHUTTER_INTERVAL 480000
+#define SII_MAX_SUB_LAYERS_MINUS1 (SII_MAX_SUB_LAYERS - 1)
+#define SUB_LAYER_NUM_UNITS_IN_SHUTTER_INTERVAL_HFR 480000
+#define SUB_LAYER_NUM_UNITS_IN_SHUTTER_INTERVAL_SFR 240000
+
 #endif /* IH264_DEFS_H_ */
diff --git a/common/ih264_structs.h b/common/ih264_structs.h
index d1eaeac..b8b4564 100644
--- a/common/ih264_structs.h
+++ b/common/ih264_structs.h
@@ -1801,118 +1801,177 @@ typedef struct
 /**
  * Structure to hold Content color volume SEI
  */
 typedef struct
 {
     /*
      * Flag used to control persistence of CCV SEI messages
      */
     UWORD8 u1_ccv_cancel_flag;
 
     /*
      * specifies the persistence of the CCV SEI message for the current layer
      */
     UWORD8 u1_ccv_persistence_flag;
 
     /*
      * specifies the presence of syntax elements ccv_primaries_x and ccv_primaries_y
      */
     UWORD8 u1_ccv_primaries_present_flag;
 
     /*
      * specifies that the syntax element ccv_min_luminance_value is present
      */
     UWORD8 u1_ccv_min_luminance_value_present_flag;
 
     /*
      * specifies that the syntax element ccv_max_luminance_value is present
      */
     UWORD8 u1_ccv_max_luminance_value_present_flag;
 
     /*
      * specifies that the syntax element ccv_avg_luminance_value is present
      */
     UWORD8 u1_ccv_avg_luminance_value_present_flag;
 
     /*
      * shall be equal to 0 in bitstreams conforming to this version. Other values
      * for reserved_zero_2bits are reserved for future use
      */
     UWORD8 u1_ccv_reserved_zero_2bits;
 
     /*
      * specify the normalized x chromaticity coordinates of the colour
      * primary component c of the nominal content colour volume
      */
     WORD32 ai4_ccv_primaries_x[NUM_SEI_CCV_PRIMARIES];
 
     /*
      * specify the normalized y chromaticity coordinates of the colour
      * primary component c of the nominal content colour volume
      */
     WORD32 ai4_ccv_primaries_y[NUM_SEI_CCV_PRIMARIES];
 
     /*
      * specifies the normalized minimum luminance value
      */
     UWORD32 u4_ccv_min_luminance_value;
 
     /*
      * specifies the normalized maximum luminance value
      */
     UWORD32 u4_ccv_max_luminance_value;
 
     /*
      * specifies the normalized average luminance value
      */
     UWORD32 u4_ccv_avg_luminance_value;
 }sei_ccv_params_t;
 
 
+/**
+ * Structure to hold shutter interval info SEI
+ */
+typedef struct
+{
+    /**
+     * specifies if the sei sii is enabled
+     */
+    UWORD8 u1_shutter_interval_info_present_flag;
+
+    /**
+     * specifies the shutter interval temporal sub-layer index
+     * of the current picture
+     */
+    UWORD32 u4_sii_sub_layer_idx;
+
+    /**
+     * specify the number of time units that pass in one second
+     */
+    UWORD32 u4_sii_time_scale;
+
+    /**
+     * specifies that the indicated shutter interval is the same for all
+     * pictures in the coded video sequence
+     */
+    UWORD8 u1_fixed_shutter_interval_within_cvs_flag;
+
+    /**
+     * specifies the the number of time units of a clock operating at the
+     * frequency sii_time_scale Hz that corresponds to the indicated shutter
+     * interval of each picture in the coded video sequence
+     */
+    UWORD32 u4_sii_num_units_in_shutter_interval;
+
+    /**
+     * sii_max_sub_layers_minus1 plus 1 specifies the maximum number of
+     * shutter interval temporal sub-layers indexes that may be present
+     * in the coded video sequence
+     */
+    UWORD8 u1_sii_max_sub_layers_minus1;
+
+    /*
+     * specifies the number of time units of a clock operating at the
+     * frequency sii_time_scale Hz that corresponds to the shutter
+     * interval of each picture in the coded video sequence
+     */
+    UWORD32 au4_sub_layer_num_units_in_shutter_interval[SII_MAX_SUB_LAYERS];
+} sei_sii_params_t;
+
 /**
  * Structure to hold SEI parameters Info
  */
 typedef struct
 {
     /**
      *  mastering display color volume info present flag
      */
     UWORD8 u1_sei_mdcv_params_present_flag;
 
     /*
      * MDCV parameters
      */
     sei_mdcv_params_t s_sei_mdcv_params;
 
     /**
      * content light level info present flag
      */
     UWORD8 u1_sei_cll_params_present_flag;
 
     /*
      * CLL parameters
      */
     sei_cll_params_t s_sei_cll_params;
 
     /**
      * ambient viewing environment info present flag
      */
     UWORD8 u1_sei_ave_params_present_flag;
 
     /*
      * AVE parameters
      */
     sei_ave_params_t s_sei_ave_params;
 
     /**
      * content color volume info present flag
      */
     UWORD8 u1_sei_ccv_params_present_flag;
 
     /*
      * CCV parameters
      */
     sei_ccv_params_t s_sei_ccv_params;
+
+    /**
+     * shutter interval info present flag
+     */
+    UWORD8 u1_sei_sii_params_present_flag;
+
+    /*
+     * Shutter Interval Info parameters
+     */
+    sei_sii_params_t s_sei_sii_params;
 } sei_params_t;
 
 
 #endif /* _IH264_STRUCTS_H_ */
diff --git a/decoder/ih264d.h b/decoder/ih264d.h
index bee6b34..5ad2f9a 100644
--- a/decoder/ih264d.h
+++ b/decoder/ih264d.h
@@ -264,35 +264,38 @@ typedef struct
 typedef enum {
     /** Set number of cores/threads to be used */
     IH264D_CMD_CTL_SET_NUM_CORES         = IVD_CMD_CTL_CODEC_SUBCMD_START,
 
     /** Set processor details */
     IH264D_CMD_CTL_SET_PROCESSOR         = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x001,
 
     /** Get display buffer dimensions */
     IH264D_CMD_CTL_GET_BUFFER_DIMENSIONS = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x100,
 
     /** Get VUI parameters */
     IH264D_CMD_CTL_GET_VUI_PARAMS        = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x101,
 
     /** Enable/disable GPU, supported on select platforms */
     IH264D_CMD_CTL_GPU_ENABLE_DISABLE    = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x200,
 
     /** Set degrade level */
     IH264D_CMD_CTL_DEGRADE               = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x300,
 
     /** Get SEI MDCV parameters */
     IH264D_CMD_CTL_GET_SEI_MDCV_PARAMS   = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x301,
 
     /** Get SEI CLL parameters */
     IH264D_CMD_CTL_GET_SEI_CLL_PARAMS    = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x302,
 
     /** Get SEI AVE parameters */
     IH264D_CMD_CTL_GET_SEI_AVE_PARAMS    = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x303,
 
     /** Get SEI CCV parameters */
-    IH264D_CMD_CTL_GET_SEI_CCV_PARAMS    = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x304
+    IH264D_CMD_CTL_GET_SEI_CCV_PARAMS    = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x304,
+
+    /** Get SEI SII parameters */
+    IH264D_CMD_CTL_GET_SEI_SII_PARAMS = IVD_CMD_CTL_CODEC_SUBCMD_START + 0x305
 
 }IH264D_CMD_CTL_SUB_CMDS;
 /*****************************************************************************/
 /*   Video control  Flush                                                    */
 /*****************************************************************************/
@@ -734,81 +737,155 @@ typedef struct
 typedef struct
 {
     /**
      * u4_size
      */
     UWORD32                                     u4_size;
 
     /**
      * error_code
      */
     UWORD32                                     u4_error_code;
 
     /*
      * Flag used to control persistence of CCV SEI messages
      */
     UWORD8                                      u1_ccv_cancel_flag;
 
     /*
      * specifies the persistence of the CCV SEI message for the current layer
      */
     UWORD8                                      u1_ccv_persistence_flag;
 
     /*
      * specifies the presence of syntax elements ccv_primaries_x and ccv_primaries_y
      */
     UWORD8                                      u1_ccv_primaries_present_flag;
 
     /*
      * specifies that the syntax element ccv_min_luminance_value is present
      */
     UWORD8                                      u1_ccv_min_luminance_value_present_flag;
 
     /*
      * specifies that the syntax element ccv_max_luminance_value is present
      */
     UWORD8                                      u1_ccv_max_luminance_value_present_flag;
 
     /*
      * specifies that the syntax element ccv_avg_luminance_value is present
      */
     UWORD8                                      u1_ccv_avg_luminance_value_present_flag;
 
     /*
      * shall be equal to 0 in bitstreams conforming to this version. Other values
      * for reserved_zero_2bits are reserved for future use
      */
     UWORD8                                      u1_ccv_reserved_zero_2bits;
 
     /*
      * specify the normalized x chromaticity coordinates of the colour
      * primary component c of the nominal content colour volume
      */
     WORD32                                      ai4_ccv_primaries_x[NUM_SEI_CCV_PRIMARIES];
 
     /*
      * specify the normalized y chromaticity coordinates of the colour
      * primary component c of the nominal content colour volume
      */
     WORD32                                      ai4_ccv_primaries_y[NUM_SEI_CCV_PRIMARIES];
 
     /*
      * specifies the normalized minimum luminance value
      */
     UWORD32                                     u4_ccv_min_luminance_value;
 
     /*
      * specifies the normalized maximum luminance value
      */
     UWORD32                                     u4_ccv_max_luminance_value;
 
     /*
      * specifies the normalized average luminance value
      */
     UWORD32                                     u4_ccv_avg_luminance_value;
 } ih264d_ctl_get_sei_ccv_params_op_t;
 
+typedef struct
+{
+    /**
+     * u4_size
+     */
+    UWORD32 u4_size;
+
+    /**
+     * cmd
+     */
+    IVD_API_COMMAND_TYPE_T e_cmd;
+
+    /**
+     * sub_cmd
+     */
+    IVD_CONTROL_API_COMMAND_TYPE_T e_sub_cmd;
+} ih264d_ctl_get_sei_sii_params_ip_t;
+
+typedef struct
+{
+    /**
+     * u4_size
+     */
+    UWORD32 u4_size;
+
+    /**
+     * error_code
+     */
+    UWORD32 u4_error_code;
+
+    /**
+     * specifies if the sei sii is enabled
+     */
+    UWORD8 u1_shutter_interval_info_present_flag;
+
+    /**
+     * specifies the shutter interval temporal sub-layer index
+     * of the current picture
+     */
+    UWORD32 u4_sii_sub_layer_idx;
+
+    /**
+     * specify the number of time units that pass in one second
+     */
+    UWORD32 u4_sii_time_scale;
+
+    /**
+     * specifies that the indicated shutter interval is the same for all
+     * pictures in the coded video sequence
+     */
+    UWORD8 u1_fixed_shutter_interval_within_cvs_flag;
+
+    /**
+     * specifies the the number of time units of a clock operating at the
+     * frequency sii_time_scale Hz that corresponds to the indicated shutter
+     * interval of each picture in the coded video sequence
+     */
+    UWORD32 u4_sii_num_units_in_shutter_interval;
+
+    /**
+     * sii_max_sub_layers_minus1 plus 1 specifies the maximum number of
+     * shutter interval temporal sub-layers indexes that may be present
+     * in the coded video sequence
+     */
+    UWORD8 u1_sii_max_sub_layers_minus1;
+
+    /**
+     * specifies the number of time units of a clock operating at the
+     * frequency sii_time_scale Hz that corresponds to the shutter
+     * interval of each picture in the coded video sequence
+     */
+    UWORD32 au4_sub_layer_num_units_in_shutter_interval[SII_MAX_SUB_LAYERS];
+
+} ih264d_ctl_get_sei_sii_params_op_t;
 
 #ifdef __cplusplus
 } /* closing brace for extern "C" */
 #endif
 #endif /* _IH264D_H_ */
diff --git a/decoder/ih264d_api.c b/decoder/ih264d_api.c
index 144701c..cb296c8 100644
--- a/decoder/ih264d_api.c
+++ b/decoder/ih264d_api.c
@@ -155,6 +155,8 @@ WORD32 ih264d_get_sei_ccv_params(iv_obj_t *dec_hdl,
                                  void *pv_api_ip,
                                  void *pv_api_op);
 
+WORD32 ih264d_get_sei_sii_params(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op);
+
 WORD32 ih264d_set_num_cores(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op);
 
 WORD32 ih264d_deblock_display(dec_struct_t *ps_dec);
@@ -186,12 +188,13 @@ void ih264d_fill_output_struct_from_context(dec_struct_t *ps_dec,
 void ih264d_export_sei_params(ivd_sei_decode_op_t *ps_sei_decode_op, dec_struct_t *ps_dec)
 {
     WORD32 i4_status = IV_SUCCESS;
     sei *ps_sei = (sei *)ps_dec->pv_disp_sei_params;
 
     i4_status = ih264d_export_sei_mdcv_params(ps_sei_decode_op, ps_sei, &ps_dec->s_sei_export);
     i4_status = ih264d_export_sei_cll_params(ps_sei_decode_op, ps_sei, &ps_dec->s_sei_export);
     i4_status = ih264d_export_sei_ave_params(ps_sei_decode_op, ps_sei, &ps_dec->s_sei_export);
     i4_status = ih264d_export_sei_ccv_params(ps_sei_decode_op, ps_sei, &ps_dec->s_sei_export);
+    i4_status = ih264d_export_sei_sii_params(ps_sei_decode_op, ps_sei, &ps_dec->s_sei_export);
 
     UNUSED(i4_status);
 }
@@ -199,844 +202,869 @@ void ih264d_export_sei_params(ivd_sei_decode_op_t *ps_sei_decode_op, dec_struct_
 static IV_API_CALL_STATUS_T api_check_struct_sanity(iv_obj_t *ps_handle,
                                                     void *pv_api_ip,
                                                     void *pv_api_op)
 {
     IVD_API_COMMAND_TYPE_T e_cmd;
     UWORD32 *pu4_api_ip;
     UWORD32 *pu4_api_op;
     UWORD32 i, j;
 
     if(NULL == pv_api_op)
         return (IV_FAIL);
 
     if(NULL == pv_api_ip)
         return (IV_FAIL);
 
     pu4_api_ip = (UWORD32 *)pv_api_ip;
     pu4_api_op = (UWORD32 *)pv_api_op;
     e_cmd = *(pu4_api_ip + 1);
 
     /* error checks on handle */
     switch((WORD32)e_cmd)
     {
         case IVD_CMD_CREATE:
             break;
 
         case IVD_CMD_REL_DISPLAY_FRAME:
         case IVD_CMD_SET_DISPLAY_FRAME:
         case IVD_CMD_GET_DISPLAY_FRAME:
         case IVD_CMD_VIDEO_DECODE:
         case IVD_CMD_DELETE:
         case IVD_CMD_VIDEO_CTL:
             if(ps_handle == NULL)
             {
                 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVD_HANDLE_NULL;
                 return IV_FAIL;
             }
 
             if(ps_handle->u4_size != sizeof(iv_obj_t))
             {
                 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVD_HANDLE_STRUCT_SIZE_INCORRECT;
                 return IV_FAIL;
             }
 
             if(ps_handle->pv_fxns != ih264d_api_function)
             {
                 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVD_INVALID_HANDLE_NULL;
                 return IV_FAIL;
             }
 
             if(ps_handle->pv_codec_handle == NULL)
             {
                 *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVD_INVALID_HANDLE_NULL;
                 return IV_FAIL;
             }
             break;
         default:
             *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
             *(pu4_api_op + 1) |= IVD_INVALID_API_CMD;
             return IV_FAIL;
     }
 
     switch((WORD32)e_cmd)
     {
         case IVD_CMD_CREATE:
         {
             ih264d_create_ip_t *ps_ip = (ih264d_create_ip_t *)pv_api_ip;
             ih264d_create_op_t *ps_op = (ih264d_create_op_t *)pv_api_op;
 
 
             ps_op->s_ivd_create_op_t.u4_error_code = 0;
 
             if((ps_ip->s_ivd_create_ip_t.u4_size > sizeof(ih264d_create_ip_t))
                             || (ps_ip->s_ivd_create_ip_t.u4_size
                                             < sizeof(ivd_create_ip_t)))
             {
                 ps_op->s_ivd_create_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_create_op_t.u4_error_code |=
                                 IVD_IP_API_STRUCT_SIZE_INCORRECT;
                 H264_DEC_DEBUG_PRINT("\n");
                 return (IV_FAIL);
             }
 
             if((ps_op->s_ivd_create_op_t.u4_size != sizeof(ih264d_create_op_t))
                             && (ps_op->s_ivd_create_op_t.u4_size
                                             != sizeof(ivd_create_op_t)))
             {
                 ps_op->s_ivd_create_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_create_op_t.u4_error_code |=
                                 IVD_OP_API_STRUCT_SIZE_INCORRECT;
                 H264_DEC_DEBUG_PRINT("\n");
                 return (IV_FAIL);
             }
 
 
             if((ps_ip->s_ivd_create_ip_t.e_output_format != IV_YUV_420P)
                             && (ps_ip->s_ivd_create_ip_t.e_output_format
                                             != IV_YUV_422ILE)
                             && (ps_ip->s_ivd_create_ip_t.e_output_format
                                             != IV_RGB_565)
                             && (ps_ip->s_ivd_create_ip_t.e_output_format
                                             != IV_YUV_420SP_UV)
                             && (ps_ip->s_ivd_create_ip_t.e_output_format
                                             != IV_YUV_420SP_VU))
             {
                 ps_op->s_ivd_create_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_create_op_t.u4_error_code |=
                                 IVD_INIT_DEC_COL_FMT_NOT_SUPPORTED;
                 H264_DEC_DEBUG_PRINT("\n");
                 return (IV_FAIL);
             }
 
         }
             break;
 
         case IVD_CMD_GET_DISPLAY_FRAME:
         {
             ih264d_get_display_frame_ip_t *ps_ip =
                             (ih264d_get_display_frame_ip_t *)pv_api_ip;
             ih264d_get_display_frame_op_t *ps_op =
                             (ih264d_get_display_frame_op_t *)pv_api_op;
 
             ps_op->s_ivd_get_display_frame_op_t.u4_error_code = 0;
 
             if((ps_ip->s_ivd_get_display_frame_ip_t.u4_size
                             != sizeof(ih264d_get_display_frame_ip_t))
                             && (ps_ip->s_ivd_get_display_frame_ip_t.u4_size
                                             != sizeof(ivd_get_display_frame_ip_t)))
             {
                 ps_op->s_ivd_get_display_frame_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_get_display_frame_op_t.u4_error_code |=
                                 IVD_IP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if((ps_op->s_ivd_get_display_frame_op_t.u4_size
                             != sizeof(ih264d_get_display_frame_op_t))
                             && (ps_op->s_ivd_get_display_frame_op_t.u4_size
                                             != sizeof(ivd_get_display_frame_op_t)))
             {
                 ps_op->s_ivd_get_display_frame_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_get_display_frame_op_t.u4_error_code |=
                                 IVD_OP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
         }
             break;
 
         case IVD_CMD_REL_DISPLAY_FRAME:
         {
             ih264d_rel_display_frame_ip_t *ps_ip =
                             (ih264d_rel_display_frame_ip_t *)pv_api_ip;
             ih264d_rel_display_frame_op_t *ps_op =
                             (ih264d_rel_display_frame_op_t *)pv_api_op;
 
             ps_op->s_ivd_rel_display_frame_op_t.u4_error_code = 0;
 
             if((ps_ip->s_ivd_rel_display_frame_ip_t.u4_size
                             != sizeof(ih264d_rel_display_frame_ip_t))
                             && (ps_ip->s_ivd_rel_display_frame_ip_t.u4_size
                                             != sizeof(ivd_rel_display_frame_ip_t)))
             {
                 ps_op->s_ivd_rel_display_frame_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_rel_display_frame_op_t.u4_error_code |=
                                 IVD_IP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if((ps_op->s_ivd_rel_display_frame_op_t.u4_size
                             != sizeof(ih264d_rel_display_frame_op_t))
                             && (ps_op->s_ivd_rel_display_frame_op_t.u4_size
                                             != sizeof(ivd_rel_display_frame_op_t)))
             {
                 ps_op->s_ivd_rel_display_frame_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_rel_display_frame_op_t.u4_error_code |=
                                 IVD_OP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
         }
             break;
 
         case IVD_CMD_SET_DISPLAY_FRAME:
         {
             ih264d_set_display_frame_ip_t *ps_ip =
                             (ih264d_set_display_frame_ip_t *)pv_api_ip;
             ih264d_set_display_frame_op_t *ps_op =
                             (ih264d_set_display_frame_op_t *)pv_api_op;
             UWORD32 j;
 
             ps_op->s_ivd_set_display_frame_op_t.u4_error_code = 0;
 
             if((ps_ip->s_ivd_set_display_frame_ip_t.u4_size
                             != sizeof(ih264d_set_display_frame_ip_t))
                             && (ps_ip->s_ivd_set_display_frame_ip_t.u4_size
                                             != sizeof(ivd_set_display_frame_ip_t)))
             {
                 ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                 IVD_IP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if((ps_op->s_ivd_set_display_frame_op_t.u4_size
                             != sizeof(ih264d_set_display_frame_op_t))
                             && (ps_op->s_ivd_set_display_frame_op_t.u4_size
                                             != sizeof(ivd_set_display_frame_op_t)))
             {
                 ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                 IVD_OP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if(ps_ip->s_ivd_set_display_frame_ip_t.num_disp_bufs == 0)
             {
                 ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                 IVD_DISP_FRM_ZERO_OP_BUFS;
                 return IV_FAIL;
             }
 
             for(j = 0; j < ps_ip->s_ivd_set_display_frame_ip_t.num_disp_bufs;
                             j++)
             {
                 if(ps_ip->s_ivd_set_display_frame_ip_t.s_disp_buffer[j].u4_num_bufs
                                 == 0)
                 {
                     ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
                                     << IVD_UNSUPPORTEDPARAM;
                     ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                     IVD_DISP_FRM_ZERO_OP_BUFS;
                     return IV_FAIL;
                 }
 
                 for(i = 0;
                                 i
                                                 < ps_ip->s_ivd_set_display_frame_ip_t.s_disp_buffer[j].u4_num_bufs;
                                 i++)
                 {
                     if(ps_ip->s_ivd_set_display_frame_ip_t.s_disp_buffer[j].pu1_bufs[i]
                                     == NULL)
                     {
                         ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                         IVD_DISP_FRM_OP_BUF_NULL;
                         return IV_FAIL;
                     }
 
                     if(ps_ip->s_ivd_set_display_frame_ip_t.s_disp_buffer[j].u4_min_out_buf_size[i]
                                     == 0)
                     {
                         ps_op->s_ivd_set_display_frame_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_set_display_frame_op_t.u4_error_code |=
                                         IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
                         return IV_FAIL;
                     }
                 }
             }
         }
             break;
 
         case IVD_CMD_VIDEO_DECODE:
         {
             ih264d_video_decode_ip_t *ps_ip =
                             (ih264d_video_decode_ip_t *)pv_api_ip;
             ih264d_video_decode_op_t *ps_op =
                             (ih264d_video_decode_op_t *)pv_api_op;
 
             H264_DEC_DEBUG_PRINT("The input bytes is: %d",
                                  ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes);
             ps_op->s_ivd_video_decode_op_t.u4_error_code = 0;
 
             if(ps_ip->s_ivd_video_decode_ip_t.u4_size
                             != sizeof(ih264d_video_decode_ip_t) &&
                             ps_ip->s_ivd_video_decode_ip_t.u4_size != sizeof(ivd_video_decode_ip_t) &&
                             ps_ip->s_ivd_video_decode_ip_t.u4_size != offsetof(ivd_video_decode_ip_t, s_out_buffer))
             {
                 ps_op->s_ivd_video_decode_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_video_decode_op_t.u4_error_code |=
                                 IVD_IP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if(ps_op->s_ivd_video_decode_op_t.u4_size
                             != sizeof(ih264d_video_decode_op_t) &&
                             ps_op->s_ivd_video_decode_op_t.u4_size != sizeof(ivd_video_decode_op_t) &&
                             ps_op->s_ivd_video_decode_op_t.u4_size != offsetof(ivd_video_decode_op_t, u4_output_present))
             {
                 ps_op->s_ivd_video_decode_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_video_decode_op_t.u4_error_code |=
                                 IVD_OP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             {
                 dec_struct_t *ps_dec = (dec_struct_t *)(ps_handle->pv_codec_handle);
                 if(ps_dec->u1_enable_mb_info)
                 {
                     if(!ps_ip->pu1_8x8_blk_qp_map && !ps_ip->pu1_8x8_blk_type_map)
                     {
                         ps_op->s_ivd_video_decode_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_video_decode_op_t.u4_error_code |=
                                         IH264D_FRAME_INFO_OP_BUF_NULL;
                         return IV_FAIL;
                     }
                 }
             }
         }
             break;
 
         case IVD_CMD_DELETE:
         {
             ih264d_delete_ip_t *ps_ip =
                             (ih264d_delete_ip_t *)pv_api_ip;
             ih264d_delete_op_t *ps_op =
                             (ih264d_delete_op_t *)pv_api_op;
 
             ps_op->s_ivd_delete_op_t.u4_error_code = 0;
 
             if(ps_ip->s_ivd_delete_ip_t.u4_size
                             != sizeof(ih264d_delete_ip_t))
             {
                 ps_op->s_ivd_delete_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_delete_op_t.u4_error_code |=
                                 IVD_IP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if(ps_op->s_ivd_delete_op_t.u4_size
                             != sizeof(ih264d_delete_op_t))
             {
                 ps_op->s_ivd_delete_op_t.u4_error_code |= 1
                                 << IVD_UNSUPPORTEDPARAM;
                 ps_op->s_ivd_delete_op_t.u4_error_code |=
                                 IVD_OP_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
         }
             break;
 
         case IVD_CMD_VIDEO_CTL:
         {
             UWORD32 *pu4_ptr_cmd;
             UWORD32 sub_command;
 
             pu4_ptr_cmd = (UWORD32 *)pv_api_ip;
             pu4_ptr_cmd += 2;
             sub_command = *pu4_ptr_cmd;
 
             switch(sub_command)
             {
                 case IVD_CMD_CTL_SETPARAMS:
                 {
                     ih264d_ctl_set_config_ip_t *ps_ip;
                     ih264d_ctl_set_config_op_t *ps_op;
                     ps_ip = (ih264d_ctl_set_config_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_set_config_op_t *)pv_api_op;
 
                     if(ps_ip->s_ivd_ctl_set_config_ip_t.u4_size
                                     != sizeof(ih264d_ctl_set_config_ip_t))
                     {
                         ps_op->s_ivd_ctl_set_config_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_set_config_op_t.u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                 }
                     //no break; is needed here
                 case IVD_CMD_CTL_SETDEFAULT:
                 {
                     ih264d_ctl_set_config_op_t *ps_op;
                     ps_op = (ih264d_ctl_set_config_op_t *)pv_api_op;
                     if(ps_op->s_ivd_ctl_set_config_op_t.u4_size
                                     != sizeof(ih264d_ctl_set_config_op_t))
                     {
                         ps_op->s_ivd_ctl_set_config_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_set_config_op_t.u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                 }
                     break;
 
                 case IVD_CMD_CTL_GETPARAMS:
                 {
                     ih264d_ctl_getstatus_ip_t *ps_ip;
                     ih264d_ctl_getstatus_op_t *ps_op;
 
                     ps_ip = (ih264d_ctl_getstatus_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_getstatus_op_t *)pv_api_op;
                     if(ps_ip->s_ivd_ctl_getstatus_ip_t.u4_size
                                     != sizeof(ih264d_ctl_getstatus_ip_t))
                     {
                         ps_op->s_ivd_ctl_getstatus_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_getstatus_op_t.u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                     if(ps_op->s_ivd_ctl_getstatus_op_t.u4_size
                                     != sizeof(ih264d_ctl_getstatus_op_t))
                     {
                         ps_op->s_ivd_ctl_getstatus_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_getstatus_op_t.u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                 }
                     break;
 
                 case IVD_CMD_CTL_GETBUFINFO:
                 {
                     ih264d_ctl_getbufinfo_ip_t *ps_ip;
                     ih264d_ctl_getbufinfo_op_t *ps_op;
                     ps_ip = (ih264d_ctl_getbufinfo_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_getbufinfo_op_t *)pv_api_op;
 
                     if(ps_ip->s_ivd_ctl_getbufinfo_ip_t.u4_size
                                     != sizeof(ih264d_ctl_getbufinfo_ip_t))
                     {
                         ps_op->s_ivd_ctl_getbufinfo_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_getbufinfo_op_t.u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                     if(ps_op->s_ivd_ctl_getbufinfo_op_t.u4_size
                                     != sizeof(ih264d_ctl_getbufinfo_op_t))
                     {
                         ps_op->s_ivd_ctl_getbufinfo_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_getbufinfo_op_t.u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                 }
                     break;
 
                 case IVD_CMD_CTL_GETVERSION:
                 {
                     ih264d_ctl_getversioninfo_ip_t *ps_ip;
                     ih264d_ctl_getversioninfo_op_t *ps_op;
                     ps_ip = (ih264d_ctl_getversioninfo_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_getversioninfo_op_t *)pv_api_op;
                     if(ps_ip->s_ivd_ctl_getversioninfo_ip_t.u4_size
                                     != sizeof(ih264d_ctl_getversioninfo_ip_t))
                     {
                         ps_op->s_ivd_ctl_getversioninfo_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_getversioninfo_op_t.u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                     if(ps_op->s_ivd_ctl_getversioninfo_op_t.u4_size
                                     != sizeof(ih264d_ctl_getversioninfo_op_t))
                     {
                         ps_op->s_ivd_ctl_getversioninfo_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_getversioninfo_op_t.u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                 }
                     break;
 
                 case IVD_CMD_CTL_FLUSH:
                 {
                     ih264d_ctl_flush_ip_t *ps_ip;
                     ih264d_ctl_flush_op_t *ps_op;
                     ps_ip = (ih264d_ctl_flush_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_flush_op_t *)pv_api_op;
                     if(ps_ip->s_ivd_ctl_flush_ip_t.u4_size
                                     != sizeof(ih264d_ctl_flush_ip_t))
                     {
                         ps_op->s_ivd_ctl_flush_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_flush_op_t.u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                     if(ps_op->s_ivd_ctl_flush_op_t.u4_size
                                     != sizeof(ih264d_ctl_flush_op_t))
                     {
                         ps_op->s_ivd_ctl_flush_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_flush_op_t.u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                 }
                     break;
 
                 case IVD_CMD_CTL_RESET:
                 {
                     ih264d_ctl_reset_ip_t *ps_ip;
                     ih264d_ctl_reset_op_t *ps_op;
                     ps_ip = (ih264d_ctl_reset_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_reset_op_t *)pv_api_op;
                     if(ps_ip->s_ivd_ctl_reset_ip_t.u4_size
                                     != sizeof(ih264d_ctl_reset_ip_t))
                     {
                         ps_op->s_ivd_ctl_reset_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_reset_op_t.u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                     if(ps_op->s_ivd_ctl_reset_op_t.u4_size
                                     != sizeof(ih264d_ctl_reset_op_t))
                     {
                         ps_op->s_ivd_ctl_reset_op_t.u4_error_code |= 1
                                         << IVD_UNSUPPORTEDPARAM;
                         ps_op->s_ivd_ctl_reset_op_t.u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                 }
                     break;
 
                 case IH264D_CMD_CTL_DEGRADE:
                 {
                     ih264d_ctl_degrade_ip_t *ps_ip;
                     ih264d_ctl_degrade_op_t *ps_op;
 
                     ps_ip = (ih264d_ctl_degrade_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_degrade_op_t *)pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264d_ctl_degrade_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264d_ctl_degrade_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->i4_degrade_pics < 0)
                                     || (ps_ip->i4_degrade_pics > 4)
                                     || (ps_ip->i4_nondegrade_interval < 0)
                                     || (ps_ip->i4_degrade_type < 0)
                                     || (ps_ip->i4_degrade_type > 15))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IH264D_CMD_CTL_GET_BUFFER_DIMENSIONS:
                 {
                     ih264d_ctl_get_frame_dimensions_ip_t *ps_ip;
                     ih264d_ctl_get_frame_dimensions_op_t *ps_op;
 
                     ps_ip = (ih264d_ctl_get_frame_dimensions_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_get_frame_dimensions_op_t *)pv_api_op;
 
                     if(ps_ip->u4_size
                                     != sizeof(ih264d_ctl_get_frame_dimensions_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size
                                     != sizeof(ih264d_ctl_get_frame_dimensions_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
                 case IH264D_CMD_CTL_GET_VUI_PARAMS:
                 {
                     ih264d_ctl_get_vui_params_ip_t *ps_ip;
                     ih264d_ctl_get_vui_params_op_t *ps_op;
 
                     ps_ip =
                                     (ih264d_ctl_get_vui_params_ip_t *)pv_api_ip;
                     ps_op =
                                     (ih264d_ctl_get_vui_params_op_t *)pv_api_op;
 
                     if(ps_ip->u4_size
                                     != sizeof(ih264d_ctl_get_vui_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size
                                     != sizeof(ih264d_ctl_get_vui_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
                 case IH264D_CMD_CTL_GET_SEI_MDCV_PARAMS:
                 {
                     ih264d_ctl_get_sei_mdcv_params_ip_t *ps_ip;
                     ih264d_ctl_get_sei_mdcv_params_op_t *ps_op;
 
                     ps_ip = (ih264d_ctl_get_sei_mdcv_params_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_get_sei_mdcv_params_op_t *)pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264d_ctl_get_sei_mdcv_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264d_ctl_get_sei_mdcv_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IH264D_CMD_CTL_GET_SEI_CLL_PARAMS:
                 {
                     ih264d_ctl_get_sei_cll_params_ip_t *ps_ip;
                     ih264d_ctl_get_sei_cll_params_op_t *ps_op;
 
                     ps_ip = (ih264d_ctl_get_sei_cll_params_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_get_sei_cll_params_op_t *)pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264d_ctl_get_sei_cll_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264d_ctl_get_sei_cll_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IH264D_CMD_CTL_GET_SEI_AVE_PARAMS:
                 {
                     ih264d_ctl_get_sei_ave_params_ip_t *ps_ip;
                     ih264d_ctl_get_sei_ave_params_op_t *ps_op;
 
                     ps_ip = (ih264d_ctl_get_sei_ave_params_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_get_sei_ave_params_op_t *)pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264d_ctl_get_sei_ave_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264d_ctl_get_sei_ave_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IH264D_CMD_CTL_GET_SEI_CCV_PARAMS:
                 {
                     ih264d_ctl_get_sei_ccv_params_ip_t *ps_ip;
                     ih264d_ctl_get_sei_ccv_params_op_t *ps_op;
 
                     ps_ip = (ih264d_ctl_get_sei_ccv_params_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_get_sei_ccv_params_op_t *)pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264d_ctl_get_sei_ccv_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264d_ctl_get_sei_ccv_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
+                case IH264D_CMD_CTL_GET_SEI_SII_PARAMS:
+                {
+                    ih264d_ctl_get_sei_sii_params_ip_t *ps_ip;
+                    ih264d_ctl_get_sei_sii_params_op_t *ps_op;
+
+                    ps_ip = (ih264d_ctl_get_sei_sii_params_ip_t *) pv_api_ip;
+                    ps_op = (ih264d_ctl_get_sei_sii_params_op_t *) pv_api_op;
+
+                    if(ps_ip->u4_size != sizeof(ih264d_ctl_get_sei_sii_params_ip_t))
+                    {
+                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
+                        ps_op->u4_error_code |= IVD_IP_API_STRUCT_SIZE_INCORRECT;
+                        return IV_FAIL;
+                    }
+
+                    if(ps_op->u4_size != sizeof(ih264d_ctl_get_sei_sii_params_op_t))
+                    {
+                        ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
+                        ps_op->u4_error_code |= IVD_OP_API_STRUCT_SIZE_INCORRECT;
+                        return IV_FAIL;
+                    }
+
+                    break;
+                }
+
                 case IH264D_CMD_CTL_SET_NUM_CORES:
                 {
                     ih264d_ctl_set_num_cores_ip_t *ps_ip;
                     ih264d_ctl_set_num_cores_op_t *ps_op;
 
                     ps_ip = (ih264d_ctl_set_num_cores_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_set_num_cores_op_t *)pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264d_ctl_set_num_cores_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264d_ctl_set_num_cores_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->u4_num_cores != 1) && (ps_ip->u4_num_cores != 2)
                                     && (ps_ip->u4_num_cores != 3)
                                     && (ps_ip->u4_num_cores != 4))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         return IV_FAIL;
                     }
                     break;
                 }
                 case IH264D_CMD_CTL_SET_PROCESSOR:
                 {
                     ih264d_ctl_set_processor_ip_t *ps_ip;
                     ih264d_ctl_set_processor_op_t *ps_op;
 
                     ps_ip = (ih264d_ctl_set_processor_ip_t *)pv_api_ip;
                     ps_op = (ih264d_ctl_set_processor_op_t *)pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264d_ctl_set_processor_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_IP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264d_ctl_set_processor_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVD_OP_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
                 default:
                     *(pu4_api_op + 1) |= 1 << IVD_UNSUPPORTEDPARAM;
                     *(pu4_api_op + 1) |= IVD_UNSUPPORTED_API_CMD;
                     return IV_FAIL;
                     break;
             }
         }
             break;
     }
 
     return IV_SUCCESS;
 }
 
 
 /**
  *******************************************************************************
  *
  * @brief
  *  Sets Processor type
  *
  * @par Description:
  *  Sets Processor type
  *
  * @param[in] ps_codec_obj
  *  Pointer to codec object at API level
  *
  * @param[in] pv_api_ip
  *  Pointer to input argument structure
  *
  * @param[out] pv_api_op
  *  Pointer to output argument structure
  *
  * @returns  Status
  *
  * @remarks
  *
  *
  *******************************************************************************
  */
@@ -1839,114 +1867,116 @@ WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :  ih264d_map_error                                        */
 /*                                                                           */
 /*  Description   :  Maps error codes to IVD error groups                    */
 /*                                                                           */
 /*  Inputs        :                                                          */
 /*  Globals       : <Does it use any global variables?>                      */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         22 10 2008    100356         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 UWORD32 ih264d_map_error(UWORD32 i4_err_status)
 {
     UWORD32 temp = 0;
 
     switch(i4_err_status)
     {
         case ERROR_MEM_ALLOC_ISRAM_T:
         case ERROR_MEM_ALLOC_SDRAM_T:
         case ERROR_BUF_MGR:
         case ERROR_MB_GROUP_ASSGN_T:
         case ERROR_FRAME_LIMIT_OVER:
         case ERROR_ACTUAL_RESOLUTION_GREATER_THAN_INIT:
         case ERROR_PROFILE_NOT_SUPPORTED:
         case ERROR_INIT_NOT_DONE:
         case IVD_MEM_ALLOC_FAILED:
         case ERROR_FEATURE_UNAVAIL:
         case IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED:
             temp = 1 << IVD_FATALERROR;
             H264_DEC_DEBUG_PRINT("\nFatal Error\n");
             break;
 
         case ERROR_DBP_MANAGER_T:
         case ERROR_GAPS_IN_FRM_NUM:
         case ERROR_UNKNOWN_NAL:
         case ERROR_INV_MB_SLC_GRP_T:
         case ERROR_MULTIPLE_SLC_GRP_T:
         case ERROR_UNKNOWN_LEVEL:
         case ERROR_UNAVAIL_PICBUF_T:
         case ERROR_UNAVAIL_MVBUF_T:
         case ERROR_UNAVAIL_DISPBUF_T:
         case ERROR_NUM_REF:
         case ERROR_REFIDX_ORDER_T:
         case ERROR_PIC0_NOT_FOUND_T:
         case ERROR_MB_TYPE:
         case ERROR_SUB_MB_TYPE:
         case ERROR_CBP:
         case ERROR_REF_IDX:
         case ERROR_NUM_MV:
         case ERROR_CHROMA_PRED_MODE:
         case ERROR_INTRAPRED:
         case ERROR_NEXT_MB_ADDRESS_T:
         case ERROR_MB_ADDRESS_T:
         case ERROR_PIC1_NOT_FOUND_T:
         case ERROR_CAVLC_NUM_COEFF_T:
         case ERROR_CAVLC_SCAN_POS_T:
         case ERROR_PRED_WEIGHT_TABLE_T:
         case ERROR_CORRUPTED_SLICE:
             temp = 1 << IVD_CORRUPTEDDATA;
             break;
 
         case ERROR_NOT_SUPP_RESOLUTION:
         case ERROR_ACTUAL_LEVEL_GREATER_THAN_INIT:
             temp = 1 << IVD_UNSUPPORTEDINPUT;
             break;
 
         case ERROR_INVALID_PIC_PARAM:
         case ERROR_INVALID_SEQ_PARAM:
         case ERROR_EGC_EXCEED_32_1_T:
         case ERROR_EGC_EXCEED_32_2_T:
         case ERROR_INV_RANGE_TEV_T:
         case ERROR_INV_SLC_TYPE_T:
         case ERROR_INV_POC_TYPE_T:
         case ERROR_INV_RANGE_QP_T:
         case ERROR_INV_SPS_PPS_T:
         case ERROR_INV_SLICE_HDR_T:
         case ERROR_INV_SEI_MDCV_PARAMS:
         case ERROR_INV_SEI_CLL_PARAMS:
         case ERROR_INV_SEI_AVE_PARAMS:
         case ERROR_INV_SEI_CCV_PARAMS:
+        case ERROR_INV_SEI_SII_PARAMS:
+
             temp = 1 << IVD_CORRUPTEDHEADER;
             break;
 
         case ERROR_EOB_FLUSHBITS_T:
         case ERROR_EOB_GETBITS_T:
         case ERROR_EOB_GETBIT_T:
         case ERROR_EOB_BYPASS_T:
         case ERROR_EOB_DECISION_T:
         case ERROR_EOB_TERMINATE_T:
         case ERROR_EOB_READCOEFF4X4CAB_T:
             temp = 1 << IVD_INSUFFICIENTDATA;
             break;
         case ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED:
         case ERROR_DISP_WIDTH_RESET_TO_PIC_WIDTH:
             temp = 1 << IVD_UNSUPPORTEDPARAM | 1 << IVD_FATALERROR;
             break;
 
         case ERROR_DANGLING_FIELD_IN_PIC:
             temp = 1 << IVD_APPLIEDCONCEALMENT;
             break;
 
     }
 
     return temp;
 
 }
@@ -3628,132 +3658,135 @@ WORD32 ih264d_reset(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :  ih264d_ctl                                              */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         22 10 2008    100356         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 ih264d_ctl(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
     ivd_ctl_set_config_ip_t *ps_ctl_ip;
     ivd_ctl_set_config_op_t *ps_ctl_op;
     WORD32 ret = IV_SUCCESS;
     UWORD32 subcommand;
     dec_struct_t *ps_dec = dec_hdl->pv_codec_handle;
 
     if(ps_dec->init_done != 1)
     {
         //Return proper Error Code
         return IV_FAIL;
     }
     ps_ctl_ip = (ivd_ctl_set_config_ip_t*)pv_api_ip;
     ps_ctl_op = (ivd_ctl_set_config_op_t*)pv_api_op;
     ps_ctl_op->u4_error_code = 0;
     subcommand = ps_ctl_ip->e_sub_cmd;
 
     switch(subcommand)
     {
         case IVD_CMD_CTL_GETPARAMS:
             ret = ih264d_get_status(dec_hdl, (void *)pv_api_ip,
                                     (void *)pv_api_op);
             break;
         case IVD_CMD_CTL_SETPARAMS:
             ret = ih264d_set_params(dec_hdl, (void *)pv_api_ip,
                                     (void *)pv_api_op);
             break;
         case IVD_CMD_CTL_RESET:
             ret = ih264d_reset(dec_hdl, (void *)pv_api_ip, (void *)pv_api_op);
             break;
         case IVD_CMD_CTL_SETDEFAULT:
             ret = ih264d_set_default_params(dec_hdl, (void *)pv_api_ip,
                                             (void *)pv_api_op);
             break;
         case IVD_CMD_CTL_FLUSH:
             ret = ih264d_set_flush_mode(dec_hdl, (void *)pv_api_ip,
                                         (void *)pv_api_op);
             break;
         case IVD_CMD_CTL_GETBUFINFO:
             ret = ih264d_get_buf_info(dec_hdl, (void *)pv_api_ip,
                                       (void *)pv_api_op);
             break;
         case IVD_CMD_CTL_GETVERSION:
             ret = ih264d_get_version(dec_hdl, (void *)pv_api_ip,
                                      (void *)pv_api_op);
             break;
         case IH264D_CMD_CTL_DEGRADE:
             ret = ih264d_set_degrade(dec_hdl, (void *)pv_api_ip,
                                      (void *)pv_api_op);
             break;
 
         case IH264D_CMD_CTL_SET_NUM_CORES:
             ret = ih264d_set_num_cores(dec_hdl, (void *)pv_api_ip,
                                        (void *)pv_api_op);
             break;
         case IH264D_CMD_CTL_GET_BUFFER_DIMENSIONS:
             ret = ih264d_get_frame_dimensions(dec_hdl, (void *)pv_api_ip,
                                               (void *)pv_api_op);
             break;
         case IH264D_CMD_CTL_GET_VUI_PARAMS:
             ret = ih264d_get_vui_params(dec_hdl, (void *)pv_api_ip,
                                         (void *)pv_api_op);
             break;
         case IH264D_CMD_CTL_GET_SEI_MDCV_PARAMS:
             ret = ih264d_get_sei_mdcv_params(dec_hdl, (void *)pv_api_ip,
                                              (void *)pv_api_op);
             break;
         case IH264D_CMD_CTL_GET_SEI_CLL_PARAMS:
             ret = ih264d_get_sei_cll_params(dec_hdl, (void *)pv_api_ip,
                                             (void *)pv_api_op);
             break;
         case IH264D_CMD_CTL_GET_SEI_AVE_PARAMS:
             ret = ih264d_get_sei_ave_params(dec_hdl, (void *)pv_api_ip,
                                             (void *)pv_api_op);
             break;
         case IH264D_CMD_CTL_GET_SEI_CCV_PARAMS:
             ret = ih264d_get_sei_ccv_params(dec_hdl, (void *)pv_api_ip,
                                             (void *)pv_api_op);
             break;
+        case IH264D_CMD_CTL_GET_SEI_SII_PARAMS:
+            ret = ih264d_get_sei_sii_params(dec_hdl, (void *) pv_api_ip, (void *) pv_api_op);
+            break;
         case IH264D_CMD_CTL_SET_PROCESSOR:
             ret = ih264d_set_processor(dec_hdl, (void *)pv_api_ip,
                                        (void *)pv_api_op);
             break;
         default:
             H264_DEC_DEBUG_PRINT("\ndo nothing\n")
             ;
             break;
     }
 
     return ret;
 }
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name :   ih264d_rel_display_frame                               */
 /*                                                                           */
 /*  Description   :                                                          */
 /*                                                                           */
 /*  Inputs        :iv_obj_t decoder handle                                   */
 /*                :pv_api_ip pointer to input structure                      */
 /*                :pv_api_op pointer to output structure                     */
 /*  Outputs       :                                                          */
 /*  Returns       : void                                                     */
 /*                                                                           */
 /*  Issues        : none                                                     */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         22 10 2008    100356         Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -4250,6 +4283,93 @@ WORD32 ih264d_get_sei_ccv_params(iv_obj_t *dec_hdl,
     return IV_SUCCESS;
 }
 
+/*****************************************************************************/
+/*                                                                           */
+/*  Function Name : ih264d_get_sei_sii_params                                */
+/*                                                                           */
+/*  Description   : This function populates SEI sii message in               */
+/*                     output structure                                      */
+/*  Inputs        : iv_obj_t decoder handle                                  */
+/*                : pv_api_ip pointer to input structure                     */
+/*                : pv_api_op pointer to output structure                    */
+/*  Outputs       :                                                          */
+/*  Returns       : returns 0; 1 with error code when SII is not present     */
+/*                                                                           */
+/*  Issues        : none                                                     */
+/*                                                                           */
+/*  Revision History:                                                        */
+/*                                                                           */
+/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
+/*                                                                           */
+/*                                                                           */
+/*****************************************************************************/
+WORD32 ih264d_get_sei_sii_params(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
+{
+    ih264d_ctl_get_sei_sii_params_ip_t *ps_ip;
+    ih264d_ctl_get_sei_sii_params_op_t *ps_op;
+    dec_struct_t *ps_dec = dec_hdl->pv_codec_handle;
+    sei_sii_params_t *ps_sei_sii;
+    int i;
+
+    ps_ip = (ih264d_ctl_get_sei_sii_params_ip_t *) pv_api_ip;
+    ps_op = (ih264d_ctl_get_sei_sii_params_op_t *) pv_api_op;
+    UNUSED(ps_ip);
+
+    if(0 == ps_dec->s_sei_export.u1_sei_sii_params_present_flag)
+    {
+        ps_op->u4_error_code = ERROR_SEI_SII_PARAMS_NOT_FOUND;
+        return IV_FAIL;
+    }
+
+    ps_sei_sii = &ps_dec->s_sei_export.s_sei_sii_params;
+
+    if((ps_sei_sii->u4_sii_sub_layer_idx > 0) &&
+       (ps_sei_sii->u1_fixed_shutter_interval_within_cvs_flag == 1))
+    {
+        ps_op->u4_error_code = ERROR_INV_SEI_SII_PARAMS;
+        return IV_FAIL;
+    }
+
+    if((ps_sei_sii->u4_sii_sub_layer_idx > ps_sei_sii->u1_sii_max_sub_layers_minus1) &&
+       (ps_sei_sii->u1_fixed_shutter_interval_within_cvs_flag == 0))
+    {
+        ps_op->u4_error_code = ERROR_INV_SEI_SII_PARAMS;
+        return IV_FAIL;
+    }
+
+    ps_op->u4_sii_sub_layer_idx = ps_sei_sii->u4_sii_sub_layer_idx;
+
+    if(0 == ps_op->u4_sii_sub_layer_idx)
+    {
+        ps_op->u1_shutter_interval_info_present_flag =
+            ps_sei_sii->u1_shutter_interval_info_present_flag;
+
+        if(1 == ps_sei_sii->u1_shutter_interval_info_present_flag)
+        {
+            ps_op->u4_sii_time_scale = ps_sei_sii->u4_sii_time_scale;
+            ps_op->u1_fixed_shutter_interval_within_cvs_flag =
+                ps_sei_sii->u1_fixed_shutter_interval_within_cvs_flag;
+
+            if(1 == ps_sei_sii->u1_fixed_shutter_interval_within_cvs_flag)
+            {
+                ps_op->u4_sii_num_units_in_shutter_interval =
+                    ps_sei_sii->u4_sii_num_units_in_shutter_interval;
+            }
+            else
+            {
+                ps_op->u1_sii_max_sub_layers_minus1 = ps_sei_sii->u1_sii_max_sub_layers_minus1;
+                for(i = 0; i <= ps_sei_sii->u1_sii_max_sub_layers_minus1; i++)
+                {
+                    ps_op->au4_sub_layer_num_units_in_shutter_interval[i] =
+                        ps_sei_sii->au4_sub_layer_num_units_in_shutter_interval[i];
+                }
+            }
+        }
+    }
+
+    return IV_SUCCESS;
+}
+
 WORD32 ih264d_set_num_cores(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
     ih264d_ctl_set_num_cores_ip_t *ps_ip;
diff --git a/decoder/ih264d_error_handler.h b/decoder/ih264d_error_handler.h
index a651c46..a66fe7b 100644
--- a/decoder/ih264d_error_handler.h
+++ b/decoder/ih264d_error_handler.h
@@ -43,87 +43,89 @@
 typedef enum
 {
 
     ERROR_MEM_ALLOC_ISRAM_T = 0x50,
     ERROR_MEM_ALLOC_SDRAM_T = 0x51,
     ERROR_BUF_MGR = 0x52,
     ERROR_DBP_MANAGER_T = 0x53,
     ERROR_GAPS_IN_FRM_NUM = 0x54,
     ERROR_UNKNOWN_NAL = 0x55,
     ERROR_INV_MB_SLC_GRP_T = 0x56,
     ERROR_MULTIPLE_SLC_GRP_T = 0x57,
     ERROR_UNKNOWN_LEVEL = 0x58,
     ERROR_FEATURE_UNAVAIL = 0x59,
     ERROR_NOT_SUPP_RESOLUTION = 0x5A,
     ERROR_INVALID_PIC_PARAM = 0x5B,
     ERROR_INVALID_SEQ_PARAM = 0x5C,
     ERROR_EGC_EXCEED_32_1_T = 0x5D,
     ERROR_EGC_EXCEED_32_2_T = 0x5E,
     ERROR_INV_RANGE_TEV_T = 0x5F,
     ERROR_INV_SLC_TYPE_T = 0x60,
     ERROR_UNAVAIL_PICBUF_T = 0x61,
     ERROR_UNAVAIL_MVBUF_T = 0x62,
     ERROR_UNAVAIL_DISPBUF_T = 0x63,
     ERROR_INV_POC_TYPE_T = 0x64,
     ERROR_PIC1_NOT_FOUND_T = 0x65,
     ERROR_PIC0_NOT_FOUND_T = 0x66,
     ERROR_NUM_REF = 0x67,
     ERROR_REFIDX_ORDER_T = 0x68,
     ERROR_EOB_FLUSHBITS_T = 0x69,
     ERROR_EOB_GETBITS_T = 0x6A,
     ERROR_EOB_GETBIT_T = 0x6B,
     ERROR_EOB_BYPASS_T = 0x6C,
     ERROR_EOB_DECISION_T = 0x6D,
     ERROR_EOB_TERMINATE_T = 0x6E,
     ERROR_EOB_READCOEFF4X4CAB_T = 0x6F,
     ERROR_INV_RANGE_QP_T = 0x70,
     ERROR_END_OF_FRAME_EXPECTED_T = 0x71,
     ERROR_MB_TYPE = 0x72,
     ERROR_SUB_MB_TYPE = 0x73,
     ERROR_CBP = 0x74,
     ERROR_REF_IDX = 0x75,
     ERROR_NUM_MV = 0x76,
     ERROR_CHROMA_PRED_MODE = 0x77,
     ERROR_INTRAPRED = 0x78,
     ERROR_NEXT_MB_ADDRESS_T = 0x79,
     ERROR_MB_ADDRESS_T = 0x7A,
     ERROR_MB_GROUP_ASSGN_T = 0x7B,
     ERROR_CAVLC_NUM_COEFF_T = 0x7C,
     ERROR_CAVLC_SCAN_POS_T = 0x7D,
     ERROR_CABAC_RENORM_T = 0x7E,
     ERROR_CABAC_SIG_COEFF1_T = 0x7F,
     ERROR_CABAC_SIG_COEFF2_T = 0x80,
     ERROR_CABAC_ENCODE_COEFF_T = 0x81,
     ERROR_INV_SPS_PPS_T = 0x82,
     ERROR_INV_SLICE_HDR_T = 0x83,
     ERROR_PRED_WEIGHT_TABLE_T = 0x84,
     IH264D_VERS_BUF_INSUFFICIENT = 0x85,
     ERROR_ACTUAL_LEVEL_GREATER_THAN_INIT = 0x86,
     ERROR_CORRUPTED_SLICE = 0x87,
     ERROR_FRAME_LIMIT_OVER = 0x88,
     ERROR_ACTUAL_RESOLUTION_GREATER_THAN_INIT = 0x89,
     ERROR_PROFILE_NOT_SUPPORTED = 0x8A,
     ERROR_DISP_WIDTH_RESET_TO_PIC_WIDTH = 0x8B,
     ERROR_DISP_WIDTH_INVALID = 0x8C,
     ERROR_DANGLING_FIELD_IN_PIC = 0x8D,
     ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED = 0x8E,
     ERROR_INIT_NOT_DONE = 0x8F,
     ERROR_LEVEL_UNSUPPORTED = 0x90,
     ERROR_START_CODE_NOT_FOUND = 0x91,
     ERROR_PIC_NUM_IS_REPEATED = 0x92,
     ERROR_IN_LAST_SLICE_OF_PIC = 0x93,
     ERROR_NEW_FRAME_EXPECTED = 0x94,
     ERROR_INCOMPLETE_FRAME = 0x95,
     ERROR_VUI_PARAMS_NOT_FOUND = 0x96,
     ERROR_INV_POC = 0x97,
     ERROR_SEI_MDCV_PARAMS_NOT_FOUND = 0x98,
     ERROR_SEI_CLL_PARAMS_NOT_FOUND = 0x99,
     ERROR_SEI_AVE_PARAMS_NOT_FOUND = 0x9A,
     ERROR_SEI_CCV_PARAMS_NOT_FOUND = 0x9B,
     ERROR_INV_SEI_MDCV_PARAMS = 0x9C,
     ERROR_INV_SEI_CLL_PARAMS = 0x9D,
     ERROR_INV_SEI_AVE_PARAMS = 0x9E,
     ERROR_INV_SEI_CCV_PARAMS = 0x9F,
-    ERROR_INV_FRAME_NUM = 0xA0
+    ERROR_INV_FRAME_NUM = 0xA0,
+    ERROR_SEI_SII_PARAMS_NOT_FOUND = 0xA1,
+    ERROR_INV_SEI_SII_PARAMS = 0xA2
 
 } h264_decoder_error_code_t;
 
diff --git a/decoder/ih264d_parse_headers.c b/decoder/ih264d_parse_headers.c
index 275edaf..6cd122e 100644
--- a/decoder/ih264d_parse_headers.c
+++ b/decoder/ih264d_parse_headers.c
@@ -85,78 +85,82 @@
 void ih264d_get_pre_sei_params(dec_struct_t *ps_dec, UWORD8 u1_nal_unit_type)
 {
     if((NULL != ps_dec->ps_sei) &&
         ((0 == ps_dec->ps_sei->s_sei_ccv_params.u1_ccv_cancel_flag) &&
         (0 == ps_dec->ps_sei->s_sei_ccv_params.u1_ccv_persistence_flag)))
     {
         ps_dec->ps_sei->u1_sei_ccv_params_present_flag = 0;
         memset(&ps_dec->ps_sei->s_sei_ccv_params, 0, sizeof(sei_ccv_params_t));
     }
 
     if((NULL != ps_dec->ps_cur_sps) &&
         ((1 == ps_dec->ps_cur_sps->u1_vui_parameters_present_flag) &&
         ((2 != ps_dec->ps_cur_sps->s_vui.u1_colour_primaries) &&
         (2 != ps_dec->ps_cur_sps->s_vui.u1_matrix_coeffs) &&
         (2 != ps_dec->ps_cur_sps->s_vui.u1_tfr_chars) &&
         (4 != ps_dec->ps_cur_sps->s_vui.u1_tfr_chars) &&
         (5 != ps_dec->ps_cur_sps->s_vui.u1_tfr_chars))))
     {
         if((1 == ps_dec->ps_sei_parse->u1_sei_ccv_params_present_flag) ||
             (IDR_SLICE_NAL == u1_nal_unit_type))
         {
             ps_dec->ps_sei->u1_sei_ccv_params_present_flag =
                         ps_dec->ps_sei_parse->u1_sei_ccv_params_present_flag;
             ps_dec->ps_sei->s_sei_ccv_params = ps_dec->ps_sei_parse->s_sei_ccv_params;
         }
     }
     else
     {
         ps_dec->ps_sei->u1_sei_ccv_params_present_flag = 0;
         memset(&ps_dec->ps_sei->s_sei_ccv_params, 0, sizeof(sei_ccv_params_t));
     }
 
     if(IDR_SLICE_NAL == u1_nal_unit_type)
     {
         ps_dec->ps_sei->u1_sei_mdcv_params_present_flag =
                         ps_dec->ps_sei_parse->u1_sei_mdcv_params_present_flag;
         ps_dec->ps_sei->s_sei_mdcv_params = ps_dec->ps_sei_parse->s_sei_mdcv_params;
         ps_dec->ps_sei->u1_sei_cll_params_present_flag =
                         ps_dec->ps_sei_parse->u1_sei_cll_params_present_flag;
         ps_dec->ps_sei->s_sei_cll_params = ps_dec->ps_sei_parse->s_sei_cll_params;
         ps_dec->ps_sei->u1_sei_ave_params_present_flag =
                         ps_dec->ps_sei_parse->u1_sei_ave_params_present_flag;
         ps_dec->ps_sei->s_sei_ave_params = ps_dec->ps_sei_parse->s_sei_ave_params;
+        ps_dec->ps_sei->u1_sei_sii_params_present_flag =
+            ps_dec->ps_sei_parse->u1_sei_sii_params_present_flag;
+        ps_dec->ps_sei->s_sei_sii_params = ps_dec->ps_sei_parse->s_sei_sii_params;
     }
 
     ps_dec->ps_sei_parse->u1_sei_mdcv_params_present_flag = 0;
     memset(&ps_dec->ps_sei_parse->s_sei_mdcv_params, 0, sizeof(sei_mdcv_params_t));
     ps_dec->ps_sei_parse->u1_sei_cll_params_present_flag = 0;
     memset(&ps_dec->ps_sei_parse->s_sei_cll_params, 0, sizeof(sei_cll_params_t));
     ps_dec->ps_sei_parse->u1_sei_ave_params_present_flag = 0;
     memset(&ps_dec->ps_sei_parse->s_sei_ave_params, 0, sizeof(sei_ave_params_t));
     ps_dec->ps_sei_parse->u1_sei_ccv_params_present_flag = 0;
     memset(&ps_dec->ps_sei_parse->s_sei_ccv_params, 0, sizeof(sei_ccv_params_t));
-
+    ps_dec->ps_sei_parse->u1_sei_sii_params_present_flag = 0;
+    memset(&ps_dec->ps_sei_parse->s_sei_sii_params, 0, sizeof(sei_sii_params_t));
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_parse_slice_partition                                     */
 /*                                                                           */
 /*  Description   : This function is intended to parse and decode slice part */
 /*                  itions. Currently it's not implemented. Decoder will     */
 /*                  print a message, skips this NAL and continues            */
 /*  Inputs        : ps_dec    Decoder parameters                             */
 /*                  ps_bitstrm    Bitstream                                */
 /*  Globals       : None                                                     */
 /*  Processing    : This functionality needs to be implemented               */
 /*  Outputs       : None                                                     */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : Not implemented                                          */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 05 2002   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
diff --git a/decoder/ih264d_sei.c b/decoder/ih264d_sei.c
index ac4d056..ad1e60f 100644
--- a/decoder/ih264d_sei.c
+++ b/decoder/ih264d_sei.c
@@ -486,181 +486,286 @@ WORD32 ih264d_parse_ave(dec_bit_stream_t *ps_bitstrm,
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_parse_ccv                                         */
 /*                                                                           */
 /*  Description   : This function parses SEI message ccv                     */
 /*  Inputs        : ps_bitstrm    Bitstream                                  */
 /*                  ps_dec          Poniter decoder context                  */
 /*                  ui4_payload_size pay load i4_size                        */
 /*  Globals       : None                                                     */
 /*  Processing    :                                                          */
 /*  Outputs       : None                                                     */
 /*  Return        : 0 for successfull parsing, else -1                       */
 /*                                                                           */
 /*  Issues        :                                                          */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*                         Draft                                             */
 /*                                                                           */
 /*****************************************************************************/
 WORD32 ih264d_parse_ccv(dec_bit_stream_t *ps_bitstrm,
                         dec_struct_t *ps_dec,
                         UWORD32 ui4_payload_size)
 {
     sei *ps_sei = ps_dec->ps_sei_parse;
     dec_err_status_t *ps_err = ps_dec->ps_dec_err_status;
     UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
     UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
     UWORD32 u4_count;
     UNUSED(ui4_payload_size);
 
     if((ps_dec == NULL) || (ps_sei == NULL))
     {
         return NOT_OK;
     }
 
     ps_sei->u1_sei_ccv_params_present_flag = 0;
 
     ps_sei->s_sei_ccv_params.u1_ccv_cancel_flag = (UWORD8)ih264d_get_bit_h264(ps_bitstrm);
 
     if(ps_sei->s_sei_ccv_params.u1_ccv_cancel_flag > 1)
     {
         return ERROR_INV_SEI_CCV_PARAMS;
     }
     if(0 == ps_sei->s_sei_ccv_params.u1_ccv_cancel_flag)
     {
         ps_sei->s_sei_ccv_params.u1_ccv_persistence_flag =
                                                 (UWORD8)ih264d_get_bit_h264(ps_bitstrm);
         if(ps_sei->s_sei_ccv_params.u1_ccv_persistence_flag > 1)
         {
             return ERROR_INV_SEI_CCV_PARAMS;
         }
         ps_sei->s_sei_ccv_params.u1_ccv_primaries_present_flag =
                                                 (UWORD8)ih264d_get_bit_h264(ps_bitstrm);
         if(ps_sei->s_sei_ccv_params.u1_ccv_primaries_present_flag > 1)
         {
             return ERROR_INV_SEI_CCV_PARAMS;
         }
         ps_sei->s_sei_ccv_params.u1_ccv_min_luminance_value_present_flag =
                                                 (UWORD8)ih264d_get_bit_h264(ps_bitstrm);
         if(ps_sei->s_sei_ccv_params.u1_ccv_min_luminance_value_present_flag > 1)
         {
             return ERROR_INV_SEI_CCV_PARAMS;
         }
         ps_sei->s_sei_ccv_params.u1_ccv_max_luminance_value_present_flag =
                                                 (UWORD8)ih264d_get_bit_h264(ps_bitstrm);
         if(ps_sei->s_sei_ccv_params.u1_ccv_max_luminance_value_present_flag > 1)
         {
             return ERROR_INV_SEI_CCV_PARAMS;
         }
         ps_sei->s_sei_ccv_params.u1_ccv_avg_luminance_value_present_flag =
                                                 (UWORD8)ih264d_get_bit_h264(ps_bitstrm);
         if(ps_sei->s_sei_ccv_params.u1_ccv_avg_luminance_value_present_flag > 1)
         {
             return ERROR_INV_SEI_CCV_PARAMS;
         }
 
         if((ps_sei->s_sei_ccv_params.u1_ccv_primaries_present_flag == 0) &&
            (ps_sei->s_sei_ccv_params.u1_ccv_min_luminance_value_present_flag == 0) &&
            (ps_sei->s_sei_ccv_params.u1_ccv_max_luminance_value_present_flag == 0) &&
            (ps_sei->s_sei_ccv_params.u1_ccv_avg_luminance_value_present_flag == 0))
         {
             return ERROR_INV_SEI_CCV_PARAMS;
 	 }
 
         ps_sei->s_sei_ccv_params.u1_ccv_reserved_zero_2bits =
                                                 (UWORD8)ih264d_get_bits_h264(ps_bitstrm, 2);
         if((ps_sei->s_sei_ccv_params.u1_ccv_reserved_zero_2bits != 0))
         {
             return ERROR_INV_SEI_CCV_PARAMS;
         }
 
         /* ccv primaries */
         if(1 == ps_sei->s_sei_ccv_params.u1_ccv_primaries_present_flag)
         {
             for(u4_count = 0; u4_count < NUM_SEI_CCV_PRIMARIES; u4_count++)
             {
                 ps_sei->s_sei_ccv_params.ai4_ccv_primaries_x[u4_count] =
                                                 (WORD32)ih264d_get_bits_h264(ps_bitstrm, 32);
                 if((ps_sei->s_sei_ccv_params.ai4_ccv_primaries_x[u4_count] >
                                                         CCV_PRIMARIES_X_UPPER_LIMIT) ||
                    (ps_sei->s_sei_ccv_params.ai4_ccv_primaries_x[u4_count] <
                                                         CCV_PRIMARIES_X_LOWER_LIMIT))
                 {
                     return ERROR_INV_SEI_CCV_PARAMS;
                 }
 
                 ps_sei->s_sei_ccv_params.ai4_ccv_primaries_y[u4_count] =
                                                 (WORD32)ih264d_get_bits_h264(ps_bitstrm, 32);
                 if((ps_sei->s_sei_ccv_params.ai4_ccv_primaries_y[u4_count] >
                                                         CCV_PRIMARIES_Y_UPPER_LIMIT) ||
                    (ps_sei->s_sei_ccv_params.ai4_ccv_primaries_y[u4_count] <
                                                         CCV_PRIMARIES_Y_LOWER_LIMIT))
                 {
                     return ERROR_INV_SEI_CCV_PARAMS;
                 }
             }
         }
 
         if(1 == ps_sei->s_sei_ccv_params.u1_ccv_min_luminance_value_present_flag)
         {
             ps_sei->s_sei_ccv_params.u4_ccv_min_luminance_value =
                                                 (UWORD32)ih264d_get_bits_h264(ps_bitstrm, 32);
         }
 
         if(1 == ps_sei->s_sei_ccv_params.u1_ccv_max_luminance_value_present_flag)
         {
             ps_sei->s_sei_ccv_params.u4_ccv_max_luminance_value =
                                                 (UWORD32)ih264d_get_bits_h264(ps_bitstrm, 32);
             if((1 == ps_sei->s_sei_ccv_params.u1_ccv_min_luminance_value_present_flag) &&
                 (ps_sei->s_sei_ccv_params.u4_ccv_max_luminance_value <
                                                 ps_sei->s_sei_ccv_params.u4_ccv_min_luminance_value))
             {
                 return ERROR_INV_SEI_CCV_PARAMS;
             }
         }
         if(1 == ps_sei->s_sei_ccv_params.u1_ccv_avg_luminance_value_present_flag)
         {
             ps_sei->s_sei_ccv_params.u4_ccv_avg_luminance_value =
                                                 (UWORD32)ih264d_get_bits_h264(ps_bitstrm, 32);
             if((1 == ps_sei->s_sei_ccv_params.u1_ccv_min_luminance_value_present_flag) &&
                 (ps_sei->s_sei_ccv_params.u4_ccv_avg_luminance_value <
                                                 ps_sei->s_sei_ccv_params.u4_ccv_min_luminance_value))
             {
                 return ERROR_INV_SEI_CCV_PARAMS;
             }
             if((1 == ps_sei->s_sei_ccv_params.u1_ccv_max_luminance_value_present_flag) &&
                 (ps_sei->s_sei_ccv_params.u4_ccv_max_luminance_value <
                                                 ps_sei->s_sei_ccv_params.u4_ccv_avg_luminance_value))
             {
                 return ERROR_INV_SEI_CCV_PARAMS;
             }
         }
     }
     ps_sei->u1_sei_ccv_params_present_flag = 1;
     return (OK);
 }
 
+/*****************************************************************************/
+/*                                                                           */
+/*  Function Name : ih264d_parse_sii                                         */
+/*                                                                           */
+/*  Description   : This function parses SEI message sii                     */
+/*  Inputs        : ps_bitstrm    Bitstream                                  */
+/*                  ps_dec        Poniter decoder context                    */
+/*                  ui4_payload_size pay load i4_size                        */
+/*  Globals       : None                                                     */
+/*  Processing    :                                                          */
+/*  Outputs       : None                                                     */
+/*  Return        : 0 for successfull parsing, else -1                       */
+/*                                                                           */
+/*  Issues        :                                                          */
+/*                                                                           */
+/*  Revision History:                                                        */
+/*                                                                           */
+/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
+/*                                         Draft                             */
+/*                                                                           */
+/*****************************************************************************/
+WORD32 ih264d_parse_sii(dec_bit_stream_t *ps_bitstrm, dec_struct_t *ps_dec,
+                        UWORD32 ui4_payload_size)
+{
+    sei *ps_sei;
+    dec_err_status_t *ps_err;
+    int i;
+    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
+    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
+    UNUSED(ui4_payload_size);
+
+    if(ps_dec == NULL)
+    {
+        return NOT_OK;
+    }
+    ps_sei = ps_dec->ps_sei_parse;
+
+    if(ps_sei == NULL)
+    {
+        return NOT_OK;
+    }
+    ps_err = ps_dec->ps_dec_err_status;
+
+    ps_sei->u1_sei_sii_params_present_flag = 0;
+    memset(&ps_sei->s_sei_sii_params, 0, sizeof(ps_sei->s_sei_sii_params));
+
+    ps_sei->s_sei_sii_params.u4_sii_sub_layer_idx = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
+
+    if(0 == ps_sei->s_sei_sii_params.u4_sii_sub_layer_idx)
+    {
+        ps_sei->s_sei_sii_params.u1_shutter_interval_info_present_flag =
+            (UWORD8) ih264d_get_bit_h264(ps_bitstrm);
+
+        if(1 == ps_sei->s_sei_sii_params.u1_shutter_interval_info_present_flag)
+        {
+            ps_sei->s_sei_sii_params.u4_sii_time_scale =
+                (UWORD32) ih264d_get_bits_h264(ps_bitstrm, 32);
+
+            ps_sei->s_sei_sii_params.u1_fixed_shutter_interval_within_cvs_flag =
+                (UWORD8) ih264d_get_bit_h264(ps_bitstrm);
+
+            if(1 == ps_sei->s_sei_sii_params.u1_fixed_shutter_interval_within_cvs_flag)
+            {
+                ps_sei->s_sei_sii_params.u4_sii_num_units_in_shutter_interval =
+                    (UWORD32) ih264d_get_bits_h264(ps_bitstrm, 32);
+            }
+            else
+            {
+                ps_sei->s_sei_sii_params.u1_sii_max_sub_layers_minus1 =
+                    (UWORD8) ih264d_get_bits_h264(ps_bitstrm, 3);
+                for(i = 0; i <= ps_sei->s_sei_sii_params.u1_sii_max_sub_layers_minus1; i++)
+                {
+                    ps_sei->s_sei_sii_params.au4_sub_layer_num_units_in_shutter_interval[i] =
+                        (UWORD32) ih264d_get_bits_h264(ps_bitstrm, 32);
+                }
+            }
+        }
+    }
+
+    if((ps_sei->s_sei_sii_params.u4_sii_sub_layer_idx >
+        ps_sei->s_sei_sii_params.u1_sii_max_sub_layers_minus1) &&
+       (ps_sei->s_sei_sii_params.u1_fixed_shutter_interval_within_cvs_flag == 0))
+    {
+        return ERROR_INV_SEI_SII_PARAMS;
+    }
+
+    printf("ps_sei->s_sei_sii_params.u4_sii_sub_layer_idx: %d\n",
+           ps_sei->s_sei_sii_params.u4_sii_sub_layer_idx);
+    printf("ps_sei->s_sei_sii_params.u1_shutter_interval_info_present_flag: %d\n",
+           ps_sei->s_sei_sii_params.u1_shutter_interval_info_present_flag);
+    printf("ps_sei->s_sei_sii_params.u4_sii_time_scale: %d\n",
+           ps_sei->s_sei_sii_params.u4_sii_time_scale);
+    printf("ps_sei->s_sei_sii_params.u1_fixed_shutter_interval_within_cvs_flag: %d\n",
+           ps_sei->s_sei_sii_params.u1_fixed_shutter_interval_within_cvs_flag);
+    printf("ps_sei->s_sei_sii_params.u4_sii_num_units_in_shutter_interval: %d\n",
+           ps_sei->s_sei_sii_params.u4_sii_num_units_in_shutter_interval);
+    printf("ps_sei->s_sei_sii_params.u1_sii_max_sub_layers_minus1: %d\n",
+           ps_sei->s_sei_sii_params.u1_sii_max_sub_layers_minus1);
+    printf("ps_sei->s_sei_sii_params.au4_sub_layer_num_units_in_shutter_interval[1]: %d\n",
+           ps_sei->s_sei_sii_params.au4_sub_layer_num_units_in_shutter_interval[1]);
+
+    ps_sei->u1_sei_sii_params_present_flag = 1;
+    return (OK);
+}
+
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_parse_sei_payload                                 */
 /*                                                                           */
 /*  Description   : This function parses SEI pay loads. Currently it's       */
 /*                  implemented partially.                                   */
 /*  Inputs        : ps_bitstrm    Bitstream                                  */
 /*                  ui4_payload_type  SEI payload type                       */
 /*                  ui4_payload_size  SEI payload i4_size                    */
 /*  Globals       : None                                                     */
 /*  Processing    : Parses SEI payloads units and stores the info            */
 /*  Outputs       : None                                                     */
 /*  Return        : status for successful parsing, else -1                   */
 /*                                                                           */
 /*  Issues        : Not implemented fully                                    */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 05 2002   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -668,82 +773,86 @@ WORD32 ih264d_parse_ccv(dec_bit_stream_t *ps_bitstrm,
 WORD32 ih264d_parse_sei_payload(dec_bit_stream_t *ps_bitstrm,
                                 UWORD32 ui4_payload_type,
                                 UWORD32 ui4_payload_size,
                                 dec_struct_t *ps_dec)
 {
     sei *ps_sei;
     WORD32 i4_status = 0;
     ps_sei = (sei *)ps_dec->ps_sei_parse;
 
     if(ui4_payload_size == 0)
         return -1;
     if(NULL == ps_bitstrm)
     {
         return NOT_OK;
     }
 
     switch(ui4_payload_type)
     {
         case SEI_BUF_PERIOD:
 
             i4_status = ih264d_parse_buffering_period(&ps_sei->s_buf_period,
                                                       ps_bitstrm, ps_dec);
             break;
         case SEI_PIC_TIMING:
             if(NULL == ps_dec->ps_cur_sps)
                 i4_status = ih264d_flush_bits_h264(ps_bitstrm, (ui4_payload_size << 3));
             else
                 i4_status = ih264d_parse_pic_timing(ps_bitstrm, ps_dec,
                                         ui4_payload_size);
             break;
         case SEI_RECOVERY_PT:
             i4_status = ih264d_parse_recovery_point(ps_bitstrm, ps_dec,
                                         ui4_payload_size);
             break;
         case SEI_MASTERING_DISP_COL_VOL:
 
             i4_status = ih264d_parse_mdcv(ps_bitstrm, ps_dec,
                                           ui4_payload_size);
             break;
         case SEI_CONTENT_LIGHT_LEVEL_DATA:
 
             i4_status = ih264d_parse_cll(ps_bitstrm, ps_dec,
                                          ui4_payload_size);
             break;
         case SEI_AMBIENT_VIEWING_ENVIRONMENT:
 
             i4_status = ih264d_parse_ave(ps_bitstrm, ps_dec,
                                          ui4_payload_size);
             break;
         case SEI_CONTENT_COLOR_VOLUME:
 
             i4_status = ih264d_parse_ccv(ps_bitstrm, ps_dec,
                                          ui4_payload_size);
             break;
+        case SEI_SHUTTER_INTERVAL_INFO:
+
+            i4_status = ih264d_parse_sii(ps_bitstrm, ps_dec, ui4_payload_size);
+            break;
         default:
             i4_status = ih264d_flush_bits_h264(ps_bitstrm, (ui4_payload_size << 3));
             break;
     }
     return (i4_status);
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : ih264d_parse_sei_message                                        */
 /*                                                                           */
 /*  Description   : This function is parses and decode SEI. Currently it's   */
 /*                  not implemented fully.                                   */
 /*  Inputs        : ps_dec    Decoder parameters                       */
 /*                  ps_bitstrm    Bitstream                                */
 /*  Globals       : None                                                     */
 /*  Processing    : Parses SEI NAL units and stores the info                 */
 /*  Outputs       : None                                                     */
 /*  Returns       : None                                                     */
 /*                                                                           */
 /*  Issues        : Not implemented fully                                    */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         06 05 2002   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
@@ -985,3 +1094,44 @@ WORD32 ih264d_export_sei_ccv_params(ivd_sei_decode_op_t *ps_sei_decode_op,
     return (OK);
 }
 
+/*****************************************************************************/
+/*                                                                           */
+/*  Function Name : ih264d_export_sei_sii_params                             */
+/*                                                                           */
+/*  Description   : This function populates SEI sii message in               */
+/*                     output structure                                      */
+/*  Inputs        : ps_sei_sii_op pointer to sei sii o\p struct              */
+/*                : ps_sei pointer to decoded sei params                     */
+/*  Outputs       :                                                          */
+/*  Returns       : returns 0 for success; -1 for failure                    */
+/*                                                                           */
+/*  Issues        : none                                                     */
+/*                                                                           */
+/*  Revision History:                                                        */
+/*                                                                           */
+/*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
+/*                                                                           */
+/*                                                                           */
+/*****************************************************************************/
+WORD32 ih264d_export_sei_sii_params(ivd_sei_decode_op_t *ps_sei_decode_op, sei *ps_sei,
+                                    sei *ps_sei_export)
+{
+    if((ps_sei_export == NULL) || (ps_sei == NULL))
+    {
+        return NOT_OK;
+    }
+
+    ps_sei_export->u1_sei_sii_params_present_flag = ps_sei->u1_sei_sii_params_present_flag;
+    ps_sei_decode_op->u1_sei_sii_params_present_flag = ps_sei->u1_sei_sii_params_present_flag;
+
+    if(0 == ps_sei_export->u1_sei_sii_params_present_flag)
+    {
+        memset(&ps_sei_export->s_sei_sii_params, 0, sizeof(sei_sii_params_t));
+    }
+    else
+    {
+        memcpy(&ps_sei_export->s_sei_sii_params, &ps_sei->s_sei_sii_params,
+               sizeof(sei_sii_params_t));
+    }
+    return (OK);
+}
diff --git a/decoder/ih264d_sei.h b/decoder/ih264d_sei.h
index af143ac..c337662 100644
--- a/decoder/ih264d_sei.h
+++ b/decoder/ih264d_sei.h
@@ -1,73 +1,74 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 
 /*****************************************************************************/
 /*                                                                           */
 /*  File Name         : ih264d_sei.h                                                */
 /*                                                                           */
 /*  Description       : This file contains routines to parse SEI NAL's       */
 /*                                                                           */
 /*  List of Functions : <List the functions defined in this file>            */
 /*                                                                           */
 /*  Issues / Problems : None                                                 */
 /*                                                                           */
 /*  Revision History  :                                                      */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes (Describe the changes made)  */
 /*         25 05 2005   NS              Draft                                */
 /*                                                                           */
 /*****************************************************************************/
 
 #ifndef _IH264D_SEI_H_
 #define _IH264D_SEI_H_
 
 #include "ih264_typedefs.h"
 #include "ih264_macros.h"
 #include "ih264_platform_macros.h"
 #include "ih264d_bitstrm.h"
 #include "ih264d_structs.h"
 #include "ih264d.h"
 
 #define SEI_BUF_PERIOD      0
 #define SEI_PIC_TIMING      1
 #define SEI_PAN_SCAN_RECT   2
 #define SEI_FILLER          3
 #define SEI_UD_REG_T35      4
 #define SEI_UD_UN_REG       5
 #define SEI_RECOVERY_PT     6
 #define SEI_DEC_REF_MARK    7
 #define SEI_SPARE_PIC       8
 #define SEI_SCENE_INFO      9
 #define SEI_SUB_SEQN_INFO   10
 #define SEI_SUB_SEQN_LAY_CHAR       11
 #define SEI_SUB_SEQN_CHAR   12
 #define SEI_FULL_FRAME_FREEZE       13
 #define SEI_FULL_FRAME_FREEZE_REL   14
 #define SEI_FULL_FRAME_SNAP_SHOT    15
 #define SEI_PROG_REF_SEGMENT_START  16
 #define SEI_PROG_REF_SEGMENT_END    17
 #define SEI_MOT_CON_SLICE_GRP_SET   18
 #define SEI_MASTERING_DISP_COL_VOL       137
 #define SEI_CONTENT_LIGHT_LEVEL_DATA     144
 #define SEI_AMBIENT_VIEWING_ENVIRONMENT  148
 #define SEI_CONTENT_COLOR_VOLUME         149
+#define SEI_SHUTTER_INTERVAL_INFO        205
 
 /* Declaration of dec_struct_t to avoid CCS compilation Error */
 struct _DecStruct;
@@ -234,57 +235,116 @@ typedef struct
 
 }sei_ccv_params_t;
 
+/**
+ * Structure to hold Shutter Interval Info SEI
+ */
+typedef struct
+{
+    /**
+     * specifies if the sei sii is enabled
+     */
+    UWORD8 u1_shutter_interval_info_present_flag;
+
+    /**
+     * specifies the shutter interval temporal sub-layer index
+     * of the current picture
+     */
+    UWORD32 u4_sii_sub_layer_idx;
+
+    /**
+     * specify the number of time units that pass in one second
+     */
+    UWORD32 u4_sii_time_scale;
+
+    /**
+     * specifies that the indicated shutter interval is the same for all
+     * pictures in the coded video sequence
+     */
+    UWORD8 u1_fixed_shutter_interval_within_cvs_flag;
+
+    /**
+     * specifies the the number of time units of a clock operating at the
+     * frequency sii_time_scale Hz that corresponds to the indicated shutter
+     * interval of each picture in the coded video sequence
+     */
+    UWORD32 u4_sii_num_units_in_shutter_interval;
+
+    /**
+     * sii_max_sub_layers_minus1 plus 1 specifies the maximum number of
+     * shutter interval temporal sub-layers indexes that may be present
+     * in the coded video sequence
+     */
+    UWORD8 u1_sii_max_sub_layers_minus1;
+
+    /**
+     * specifies the number of time units of a clock operating at the
+     * frequency sii_time_scale Hz that corresponds to the shutter
+     * interval of each picture in the coded video sequence
+     */
+    UWORD32 au4_sub_layer_num_units_in_shutter_interval[SII_MAX_SUB_LAYERS];
+
+} sei_sii_params_t;
+
 struct _sei
 {
     UWORD8 u1_seq_param_set_id;
     buf_period_t s_buf_period;
     UWORD8 u1_pic_struct;
     UWORD16 u2_recovery_frame_cnt;
     UWORD8 u1_exact_match_flag;
     UWORD8 u1_broken_link_flag;
     UWORD8 u1_changing_slice_grp_idc;
     UWORD8 u1_is_valid;
 
     /**
      *  mastering display color volume info present flag
      */
     UWORD8 u1_sei_mdcv_params_present_flag;
 
     /*
      * MDCV parameters
      */
     sei_mdcv_params_t s_sei_mdcv_params;
 
     /**
      * content light level info present flag
      */
     UWORD8 u1_sei_cll_params_present_flag;
 
     /*
      * CLL parameters
      */
     sei_cll_params_t s_sei_cll_params;
 
     /**
      * ambient viewing environment info present flag
      */
     UWORD8 u1_sei_ave_params_present_flag;
 
     /*
      * AVE parameters
      */
     sei_ave_params_t s_sei_ave_params;
 
     /**
      * content color volume info present flag
      */
     UWORD8 u1_sei_ccv_params_present_flag;
 
     /*
      * CCV parameters
      */
     sei_ccv_params_t s_sei_ccv_params;
 
+    /**
+     * shutter interval info present flag
+     */
+    UWORD8 u1_sei_sii_params_present_flag;
+
+    /*
+     * SII parameters
+     */
+    sei_sii_params_t s_sei_sii_params;
 };
 typedef struct _sei sei;
 
@@ -300,5 +360,8 @@ WORD32 ih264d_export_sei_ave_params(ivd_sei_decode_op_t *ps_sei_decode_op,
 WORD32 ih264d_export_sei_ccv_params(ivd_sei_decode_op_t *ps_sei_decode_op,
                                     sei *ps_sei, sei *ps_sei_export);
 
+WORD32 ih264d_export_sei_sii_params(ivd_sei_decode_op_t *ps_sei_decode_op, sei *ps_sei,
+                                    sei *ps_sei_export);
+
 #endif /* _IH264D_SEI_H_ */
 
diff --git a/decoder/ivd.h b/decoder/ivd.h
index bac5847..586665e 100644
--- a/decoder/ivd.h
+++ b/decoder/ivd.h
@@ -1,66 +1,71 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 /**
 *******************************************************************************
 * @file
 *  ivd.h
 *
 * @brief
 *  This file contains all the necessary structure and  enumeration
 * definitions needed for the Application  Program Interface(API) of the
 * Ittiam Video Decoders
 *
 * @author
 *  100239(RCY)
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */
 
 #ifndef _IVD_H
 #define _IVD_H
 
 /*****************************************************************************/
 /* Constant Macros                                                           */
 /*****************************************************************************/
 #define IVD_VIDDEC_MAX_IO_BUFFERS 64
 
 /** SEI macros */
 /*
  * @brief  specifies the number of colour primary components of the mastering display
  */
 #define NUM_SEI_MDCV_PRIMARIES        3
 
 /*
  * @brief  specifies the number of colour primary components of the nominal content colour volume
  */
 #define NUM_SEI_CCV_PRIMARIES         3
 
+/*
+ * @brief  specifies maximum number of sub-layers available in the sequence
+ */
+#define SII_MAX_SUB_LAYERS 8
+
 /*****************************************************************************/
 /* Typedefs                                                                  */
 /*****************************************************************************/
 
 /*****************************************************************************/
 /* Enums                                                                     */
 /*****************************************************************************/
 
 /* IVD_ARCH_T: Architecture Enumeration                               */
@@ -383,13 +388,15 @@ typedef struct{
 /* SEI params deocde */
 typedef struct {
     UWORD8                                         u1_sei_mdcv_params_present_flag;
 
     UWORD8                                         u1_sei_cll_params_present_flag;
 
     UWORD8                                         u1_sei_ave_params_present_flag;
 
     UWORD8                                         u1_sei_ccv_params_present_flag;
 
+    UWORD8 u1_sei_sii_params_present_flag;
+
 }ivd_sei_decode_op_t;
 
 /* IVD_API_COMMAND_TYPE_T::e_cmd = IVD_CMD_VIDEO_DECODE                      */
diff --git a/encoder/ih264e.h b/encoder/ih264e.h
index c736d9b..bf874eb 100644
--- a/encoder/ih264e.h
+++ b/encoder/ih264e.h
@@ -830,13 +830,85 @@ typedef struct
 typedef struct
 {
     /** size of the structure                                             */
     UWORD32                                     u4_size;
 
     /** Return error code                                                 */
     UWORD32                                     u4_error_code;
 
 }ih264e_ctl_set_sei_ccv_params_op_t;
 
+/*****************************************************************************/
+/*    Video control  Set SEI SII params                                      */
+/*****************************************************************************/
+
+typedef struct
+{
+    /** size of the structure                                             */
+    UWORD32 u4_size;
+
+    /** Command type : IVE_CMD_VIDEO_CTL                                  */
+    IVE_API_COMMAND_TYPE_T e_cmd;
+
+    /** Sub command type : IVE_CMD_CTL_SET_SEI_SII_PARAMS                 */
+    IVE_CONTROL_API_COMMAND_TYPE_T e_sub_cmd;
+
+    /**
+     * specifies if the sei sii is enabled                                */
+    UWORD8 u1_shutter_interval_info_present_flag;
+
+    /**
+     * specifies the shutter interval temporal sub-layer index
+     * of the current picture                                             */
+    UWORD32 u4_sii_sub_layer_idx;
+
+    /**
+     * specify the number of time units that pass in one second           */
+    UWORD32 u4_sii_time_scale;
+
+    /**
+     * specifies that the indicated shutter interval is the same
+     * for all pictures in the coded video sequence                       */
+    UWORD8 u1_fixed_shutter_interval_within_cvs_flag;
+
+    /**
+     * specifies the the number of time units of a clock operating at
+     * the frequency sii_time_scale Hz that corresponds to the indicated
+     * shutter interval of each picture in the coded video sequence       */
+    UWORD32 u4_sii_num_units_in_shutter_interval;
+
+    /**
+     * sii_max_sub_layers_minus1 plus 1 specifies the maximum number of
+     * shutter interval temporal sub-layers indexes that may be present
+     * in the coded video sequence                                        */
+    UWORD8 u1_sii_max_sub_layers_minus1;
+
+    /**
+     * specifies the number of time units of a clock operating at the
+     * frequency sii_time_scale Hz that corresponds to the shutter
+     * interval of each picture in the coded video sequence               */
+    UWORD32 au4_sub_layer_num_units_in_shutter_interval[8];
+
+    /**
+     * Lower 32bits of time stamp corresponding to input buffer,
+     * from which this command takes effect                               */
+    UWORD32 u4_timestamp_low;
+
+    /**
+     * Upper 32bits of time stamp corresponding to input buffer,
+     * from which this command takes effect                               */
+    UWORD32 u4_timestamp_high;
+
+} ih264e_ctl_set_sei_sii_params_ip_t;
+
+typedef struct
+{
+    /** size of the structure                                             */
+    UWORD32 u4_size;
+
+    /** Return error code                                                 */
+    UWORD32 u4_error_code;
+
+} ih264e_ctl_set_sei_sii_params_op_t;
 
 /* The enum values should not have greater than 8 bits as this is assigned to WORD8 */
 typedef enum
diff --git a/encoder/ih264e_api.c b/encoder/ih264e_api.c
index 0660ba6..055c6e2 100644
--- a/encoder/ih264e_api.c
+++ b/encoder/ih264e_api.c
@@ -236,2629 +236,2688 @@ static IV_STATUS_T api_check_input_dimensions(codec_t *ps_codec,
 /**
 *******************************************************************************
 *
 * @brief
 *  Used to test arguments for corresponding API call
 *
 * @par Description:
 *  For each command the arguments are validated
 *
 * @param[in] ps_handle
 *  Codec handle at API level
 *
 * @param[in] pv_api_ip
 *  Pointer to input structure
 *
 * @param[out] pv_api_op
 *  Pointer to output structure
 *
 * @returns error status
 *
 * @remarks none
 *
 *******************************************************************************
 */
 static IV_STATUS_T api_check_struct_sanity(iv_obj_t *ps_handle,
                                            void *pv_api_ip,
                                            void *pv_api_op)
 {
     /* api call */
     WORD32 command = IV_CMD_NA;
 
     /* input structure expected by the api call */
     UWORD32 *pu4_api_ip = pv_api_ip;
 
     /* output structure expected by the api call */
     UWORD32 *pu4_api_op = pv_api_op;
 
     /* temp var */
     WORD32 i, j;
 
     if (NULL == pv_api_op || NULL == pv_api_ip)
     {
         return (IV_FAIL);
     }
 
     /* get command */
     command = pu4_api_ip[1];
 
     /* set error code */
     pu4_api_op[1] = 0;
 
     /* error checks on handle */
     switch (command)
     {
         case IV_CMD_GET_NUM_MEM_REC:
         case IV_CMD_FILL_NUM_MEM_REC:
             break;
 
         case IV_CMD_INIT:
             if (ps_handle == NULL)
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_HANDLE_NULL;
                 return IV_FAIL;
             }
 
             if (ps_handle->u4_size != sizeof(iv_obj_t))
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_HANDLE_STRUCT_SIZE_INCORRECT;
                 return IV_FAIL;
             }
             break;
 
         case IVE_CMD_QUEUE_INPUT:
         case IVE_CMD_QUEUE_OUTPUT:
         case IVE_CMD_DEQUEUE_OUTPUT:
         case IVE_CMD_GET_RECON:
         case IV_CMD_RETRIEVE_MEMREC:
         case IVE_CMD_VIDEO_CTL:
         case IVE_CMD_VIDEO_ENCODE:
 
             if (ps_handle == NULL)
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_HANDLE_NULL;
                 return IV_FAIL;
             }
 
             if (ps_handle->u4_size != sizeof(iv_obj_t))
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_HANDLE_STRUCT_SIZE_INCORRECT;
                 return IV_FAIL;
             }
 
             if (ps_handle->pv_fxns != ih264e_api_function)
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_API_FUNCTION_PTR_NULL;
                 return IV_FAIL;
             }
 
             if (ps_handle->pv_codec_handle == NULL)
             {
                 *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                 *(pu4_api_op + 1) |= IVE_ERR_INVALID_CODEC_HANDLE;
                 return IV_FAIL;
             }
             break;
 
         default:
             *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
             *(pu4_api_op + 1) |= IVE_ERR_INVALID_API_CMD;
             return IV_FAIL;
     }
 
     /* error checks on input output structures */
     switch (command)
     {
         case IV_CMD_GET_NUM_MEM_REC:
         {
             ih264e_num_mem_rec_ip_t *ps_ip = pv_api_ip;
             ih264e_num_mem_rec_op_t *ps_op = pv_api_op;
 
             ps_op->s_ive_op.u4_error_code = 0;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_num_mem_rec_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_GET_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_num_mem_rec_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_GET_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
             break;
         }
 
         case IV_CMD_FILL_NUM_MEM_REC:
         {
             ih264e_fill_mem_rec_ip_t *ps_ip = pv_api_ip;
             ih264e_fill_mem_rec_op_t *ps_op = pv_api_op;
 
             iv_mem_rec_t *ps_mem_rec = NULL;
 
             WORD32 max_wd = ALIGN16(ps_ip->s_ive_ip.u4_max_wd);
             WORD32 max_ht = ALIGN16(ps_ip->s_ive_ip.u4_max_ht);
 
             ps_op->s_ive_op.u4_error_code = 0;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_fill_mem_rec_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_FILL_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_fill_mem_rec_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_FILL_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (max_wd < MIN_WD || max_wd > MAX_WD)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_WIDTH_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (max_ht < MIN_HT || max_ht > MAX_HT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_HEIGHT_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             /* verify number of mem rec ptr */
             if (NULL == ps_ip->s_ive_ip.ps_mem_rec)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_FILL_NUM_MEM_RECS_POINTER_NULL;
                 return (IV_FAIL);
             }
 
             /* verify number of mem records */
             if (ps_ip->s_ive_ip.u4_num_mem_rec != MEM_REC_CNT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_NUM_MEM_REC_NOT_SUFFICIENT;
                 return IV_FAIL;
             }
 
             /* check mem records sizes are correct */
             ps_mem_rec = ps_ip->s_ive_ip.ps_mem_rec;
             for (i = 0; i < MEM_REC_CNT; i++)
             {
                 if (ps_mem_rec[i].u4_size != sizeof(iv_mem_rec_t))
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IVE_ERR_MEM_REC_STRUCT_SIZE_INCORRECT;
                     return IV_FAIL;
                 }
             }
             break;
         }
 
         case IV_CMD_INIT:
         {
             ih264e_init_ip_t *ps_ip = pv_api_ip;
             ih264e_init_op_t *ps_op = pv_api_op;
 
             iv_mem_rec_t *ps_mem_rec = NULL;
 
             WORD32 max_wd = ALIGN16(ps_ip->s_ive_ip.u4_max_wd);
             WORD32 max_ht = ALIGN16(ps_ip->s_ive_ip.u4_max_ht);
 
             ps_op->s_ive_op.u4_error_code = 0;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_init_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_INIT_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_init_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_INIT_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (max_wd < MIN_WD || max_wd > MAX_WD)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_WIDTH_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (max_ht < MIN_HT || max_ht > MAX_HT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_HEIGHT_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_ref_cnt > MAX_REF_PIC_CNT ||
                            ps_ip->s_ive_ip.u4_max_ref_cnt < MIN_REF_PIC_CNT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_NUM_REF_UNSUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_reorder_cnt != 0)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_NUM_REORDER_UNSUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_10)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_1B)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_11)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_12)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_13)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_20)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_21)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_22)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_30)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_31)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_32)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_40)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_41)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_42)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_50)
                             && (ps_ip->s_ive_ip.u4_max_level != IH264_LEVEL_51))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_CODEC_LEVEL_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420P)
                             && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_422ILE)
                             && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420SP_UV)
                             && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420SP_VU))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_INPUT_CHROMA_FORMAT_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.e_recon_color_fmt != IV_YUV_420P)
                             && (ps_ip->s_ive_ip.e_recon_color_fmt != IV_YUV_420SP_UV)
                             && (ps_ip->s_ive_ip.e_recon_color_fmt != IV_YUV_420SP_VU))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_RECON_CHROMA_FORMAT_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.e_rc_mode != IVE_RC_NONE)
                             && (ps_ip->s_ive_ip.e_rc_mode != IVE_RC_STORAGE)
                             && (ps_ip->s_ive_ip.e_rc_mode != IVE_RC_CBR_NON_LOW_DELAY))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_RATE_CONTROL_MODE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_framerate > DEFAULT_MAX_FRAMERATE)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_FRAME_RATE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_bitrate > DEFAULT_MAX_BITRATE)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_BITRATE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_num_bframes > MAX_NUM_BFRAMES)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_BFRAMES_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_num_bframes
                             && (ps_ip->s_ive_ip.u4_max_ref_cnt < 2))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IH264E_BFRAMES_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.e_content_type != IV_PROGRESSIVE)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_CONTENT_TYPE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_srch_rng_x > DEFAULT_MAX_SRCH_RANGE_X)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_HORIZONTAL_SEARCH_RANGE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.u4_max_srch_rng_y > DEFAULT_MAX_SRCH_RANGE_Y)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_VERTICAL_SEARCH_RANGE_NOT_SUPPORTED;
                 return (IV_FAIL);
             }
 
             if ((ps_ip->s_ive_ip.e_slice_mode != IVE_SLICE_MODE_NONE)
                             && (ps_ip->s_ive_ip.e_slice_mode != IVE_SLICE_MODE_BLOCKS))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IH264E_SLICE_TYPE_INPUT_INVALID;
                 return (IV_FAIL);
             }
 
             if (ps_ip->s_ive_ip.e_slice_mode == IVE_SLICE_MODE_BLOCKS)
             {
                 if (ps_ip->s_ive_ip.u4_slice_param == 0
                                 || ps_ip->s_ive_ip.u4_slice_param > ((UWORD32)max_ht >> 4))
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IH264E_SLICE_PARAM_INPUT_INVALID;
                     return (IV_FAIL);
                 }
             }
 
             if (NULL == ps_ip->s_ive_ip.ps_mem_rec)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_FILL_NUM_MEM_RECS_POINTER_NULL;
                 return (IV_FAIL);
             }
 
             /* verify number of mem records */
             if (ps_ip->s_ive_ip.u4_num_mem_rec != MEM_REC_CNT)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_NUM_MEM_REC_NOT_SUFFICIENT;
                 return (IV_FAIL);
             }
 
             ps_mem_rec = ps_ip->s_ive_ip.ps_mem_rec;
 
             /* check memrecords sizes are correct */
             for (i = 0; i <((WORD32)ps_ip->s_ive_ip.u4_num_mem_rec); i++)
             {
                 if (ps_mem_rec[i].u4_size != sizeof(iv_mem_rec_t))
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IVE_ERR_MEM_REC_STRUCT_SIZE_INCORRECT;
                     return IV_FAIL;
                 }
 
                 /* check memrecords pointers are not NULL */
                 if (ps_mem_rec[i].pv_base == NULL)
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IVE_ERR_MEM_REC_BASE_POINTER_NULL;
                     return IV_FAIL;
                 }
             }
 
             /* verify memtabs for overlapping regions */
             {
                 void *start[MEM_REC_CNT];
                 void *end[MEM_REC_CNT];
 
                 start[0] = (ps_mem_rec[0].pv_base);
                 end[0] = ((UWORD8 *) ps_mem_rec[0].pv_base)
                                 + ps_mem_rec[0].u4_mem_size - 1;
 
                 for (i = 1; i < MEM_REC_CNT; i++)
                 {
                     /* This array is populated to check memtab overlap */
                     start[i] = (ps_mem_rec[i].pv_base);
                     end[i] = ((UWORD8 *) ps_mem_rec[i].pv_base)
                                     + ps_mem_rec[i].u4_mem_size - 1;
 
                     for (j = 0; j < i; j++)
                     {
                         if ((start[i] >= start[j]) && (start[i] <= end[j]))
                         {
                             ps_op->s_ive_op.u4_error_code |= 1
                                             << IVE_UNSUPPORTEDPARAM;
                             ps_op->s_ive_op.u4_error_code |=
                                             IVE_ERR_MEM_REC_OVERLAP_ERR;
                             return IV_FAIL;
                         }
 
                         if ((end[i] >= start[j]) && (end[i] <= end[j]))
                         {
                             ps_op->s_ive_op.u4_error_code |= 1
                                             << IVE_UNSUPPORTEDPARAM;
                             ps_op->s_ive_op.u4_error_code |=
                                             IVE_ERR_MEM_REC_OVERLAP_ERR;
                             return IV_FAIL;
                         }
 
                         if ((start[i] < start[j]) && (end[i] > end[j]))
                         {
                             ps_op->s_ive_op.u4_error_code |= 1
                                             << IVE_UNSUPPORTEDPARAM;
                             ps_op->s_ive_op.u4_error_code |=
                                             IVE_ERR_MEM_REC_OVERLAP_ERR;
                             return IV_FAIL;
                         }
                     }
                 }
             }
 
             /* re-validate mem records with init config */
             {
                 /* mem records */
                 iv_mem_rec_t s_mem_rec_ittiam_api[MEM_REC_CNT];
 
                 /* api interface structs */
                 ih264e_fill_mem_rec_ip_t s_ip;
                 ih264e_fill_mem_rec_op_t s_op;
 
                 /* error status */
                 IV_STATUS_T e_status;
 
                 /* temp var */
                 WORD32 i;
 
                 s_ip.s_ive_ip.u4_size = sizeof(ih264e_fill_mem_rec_ip_t);
                 s_op.s_ive_op.u4_size = sizeof(ih264e_fill_mem_rec_op_t);
 
                 s_ip.s_ive_ip.e_cmd = IV_CMD_FILL_NUM_MEM_REC;
                 s_ip.s_ive_ip.ps_mem_rec = s_mem_rec_ittiam_api;
                 s_ip.s_ive_ip.u4_max_wd = max_wd;
                 s_ip.s_ive_ip.u4_max_ht = max_ht;
                 s_ip.s_ive_ip.u4_num_mem_rec = ps_ip->s_ive_ip.u4_num_mem_rec;
                 s_ip.s_ive_ip.u4_max_level = ps_ip->s_ive_ip.u4_max_level;
                 s_ip.s_ive_ip.u4_max_ref_cnt = ps_ip->s_ive_ip.u4_max_ref_cnt;
                 s_ip.s_ive_ip.u4_max_reorder_cnt =
                                 ps_ip->s_ive_ip.u4_max_reorder_cnt;
                 s_ip.s_ive_ip.e_color_format = ps_ip->s_ive_ip.e_inp_color_fmt;
                 s_ip.s_ive_ip.u4_max_srch_rng_x =
                                 ps_ip->s_ive_ip.u4_max_srch_rng_x;
                 s_ip.s_ive_ip.u4_max_srch_rng_y =
                                 ps_ip->s_ive_ip.u4_max_srch_rng_y;
 
                 for (i = 0; i < MEM_REC_CNT; i++)
                 {
                     s_mem_rec_ittiam_api[i].u4_size = sizeof(iv_mem_rec_t);
                 }
 
                 /* fill mem records */
                 e_status = ih264e_api_function(NULL, (void *) &s_ip,
                                                (void *) &s_op);
 
                 if (IV_FAIL == e_status)
                 {
                     ps_op->s_ive_op.u4_error_code = s_op.s_ive_op.u4_error_code;
                     return (IV_FAIL);
                 }
 
                 /* verify mem records */
                 for (i = 0; i < MEM_REC_CNT; i++)
                 {
                     if (ps_mem_rec[i].u4_mem_size
                                     < s_mem_rec_ittiam_api[i].u4_mem_size)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_MEM_REC_INSUFFICIENT_SIZE;
 
                         return IV_FAIL;
                     }
 
                     if (ps_mem_rec[i].u4_mem_alignment
                                     != s_mem_rec_ittiam_api[i].u4_mem_alignment)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_MEM_REC_ALIGNMENT_ERR;
 
                         return IV_FAIL;
                     }
 
                     if (ps_mem_rec[i].e_mem_type
                                     != s_mem_rec_ittiam_api[i].e_mem_type)
                     {
                         UWORD32 check = IV_SUCCESS;
                         UWORD32 diff = s_mem_rec_ittiam_api[i].e_mem_type
                                         - ps_mem_rec[i].e_mem_type;
 
                         if ((ps_mem_rec[i].e_mem_type
                                         <= IV_EXTERNAL_CACHEABLE_SCRATCH_MEM)
                                         && (s_mem_rec_ittiam_api[i].e_mem_type
                                                         >= IV_INTERNAL_NONCACHEABLE_PERSISTENT_MEM))
                         {
                             check = IV_FAIL;
                         }
 
                         if (3 != (s_mem_rec_ittiam_api[i].e_mem_type % 4))
                         {
                             /* It is not IV_EXTERNAL_NONCACHEABLE_PERSISTENT_MEM or
                              * IV_EXTERNAL_CACHEABLE_PERSISTENT_MEM */
 
                             if ((diff < 1) || (diff > 3))
                             {
                                 /* Difference between 1 and 3 is okay for all cases other than the
                                  * two filtered with the MOD condition above */
                                 check = IV_FAIL;
                             }
                         }
                         else
                         {
                             if (diff == 1)
                             {
                                 /* This particular case is when codec asked for External Persistent,
                                  * but got Internal Scratch */
                                 check = IV_FAIL;
                             }
                             if ((diff != 2) && (diff != 3))
                             {
                                 check = IV_FAIL;
                             }
                         }
 
                         if (check == IV_FAIL)
                         {
                             ps_op->s_ive_op.u4_error_code |= 1
                                             << IVE_UNSUPPORTEDPARAM;
                             ps_op->s_ive_op.u4_error_code |=
                                             IVE_ERR_MEM_REC_INCORRECT_TYPE;
 
                             return IV_FAIL;
                         }
                     }
                 }
             }
             break;
         }
 
         case IVE_CMD_QUEUE_INPUT:
         case IVE_CMD_QUEUE_OUTPUT:
         case IVE_CMD_DEQUEUE_OUTPUT:
         case IVE_CMD_GET_RECON:
             break;
 
         case IV_CMD_RETRIEVE_MEMREC:
         {
             ih264e_retrieve_mem_rec_ip_t *ps_ip = pv_api_ip;
             ih264e_retrieve_mem_rec_op_t *ps_op = pv_api_op;
 
             iv_mem_rec_t *ps_mem_rec = NULL;
 
             ps_op->s_ive_op.u4_error_code = 0;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_retrieve_mem_rec_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_RETRIEVE_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_retrieve_mem_rec_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_RETRIEVE_MEM_REC_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (NULL == ps_ip->s_ive_ip.ps_mem_rec)
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_FILL_NUM_MEM_RECS_POINTER_NULL;
                 return (IV_FAIL);
             }
 
             ps_mem_rec = ps_ip->s_ive_ip.ps_mem_rec;
 
             /* check memrecords sizes are correct */
             for (i = 0; i < MEM_REC_CNT; i++)
             {
                 if (ps_mem_rec[i].u4_size != sizeof(iv_mem_rec_t))
                 {
                     ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                     ps_op->s_ive_op.u4_error_code |=
                                     IVE_ERR_MEM_REC_STRUCT_SIZE_INCORRECT;
                     return IV_FAIL;
                 }
             }
             break;
         }
 
         case IVE_CMD_VIDEO_ENCODE:
         {
             codec_t *ps_codec = (codec_t *) (ps_handle->pv_codec_handle);
             ih264e_video_encode_ip_t *ps_ip = pv_api_ip;
             ih264e_video_encode_op_t *ps_op = pv_api_op;
 
             if (ps_ip->s_ive_ip.u4_size != sizeof(ih264e_video_encode_ip_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_IP_ENCODE_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (ps_op->s_ive_op.u4_size != sizeof(ih264e_video_encode_op_t))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |=
                                 IVE_ERR_OP_ENCODE_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
 
             if (NULL != ps_ip->s_ive_ip.s_inp_buf.apv_bufs[0] &&
                             ps_codec->i4_header_mode != 1 &&
                             IV_SUCCESS != api_check_input_dimensions(ps_codec, ps_ip, ps_op))
             {
                 ps_op->s_ive_op.u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                 ps_op->s_ive_op.u4_error_code |= IVE_ERR_OP_ENCODE_API_STRUCT_SIZE_INCORRECT;
                 return (IV_FAIL);
             }
             break;
         }
 
         case IVE_CMD_VIDEO_CTL:
         {
             /* ptr to input structure */
             WORD32 *pu4_ptr_cmd = pv_api_ip;
 
             /* sub command */
             WORD32 sub_command = pu4_ptr_cmd[2];
 
             switch (sub_command)
             {
                 case IVE_CMD_CTL_SETDEFAULT:
                 {
                     ih264e_ctl_setdefault_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_setdefault_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_setdefault_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETDEF_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_setdefault_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETDEF_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_GETBUFINFO:
                 {
                     codec_t *ps_codec = (codec_t *) (ps_handle->pv_codec_handle);
 
                     ih264e_ctl_getbufinfo_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_getbufinfo_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_getbufinfo_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_GETBUFINFO_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_getbufinfo_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_GETBUFINFO_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_max_wd < MIN_WD)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_max_wd > ps_codec->s_cfg.u4_max_wd)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_max_ht < MIN_HT)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_max_ht > ps_codec->s_cfg.u4_max_ht)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if ((ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420P)
                                     && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_422ILE)
                                     && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420SP_UV)
                                     && (ps_ip->s_ive_ip.e_inp_color_fmt != IV_YUV_420SP_VU))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INPUT_CHROMA_FORMAT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_GETVERSION:
                 {
                     ih264e_ctl_getversioninfo_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_getversioninfo_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_getversioninfo_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_GETVERSION_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_getversioninfo_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_GETVERSION_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.pu1_version == NULL)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_CTL_GET_VERSION_BUFFER_IS_NULL;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_FLUSH:
                 {
                     ih264e_ctl_flush_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_flush_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_flush_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_FLUSH_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_flush_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_FLUSH_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_RESET:
                 {
                     ih264e_ctl_reset_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_reset_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_reset_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_RESET_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_reset_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_RESET_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_NUM_CORES:
                 {
                     ih264e_ctl_set_num_cores_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_num_cores_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_num_cores_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETCORES_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_num_cores_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETCORES_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_num_cores < 1)
                                     || (ps_ip->s_ive_ip.u4_num_cores > MAX_NUM_CORES))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_NUM_CORES;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_DIMENSIONS:
                 {
                     codec_t *ps_codec = (codec_t *) (ps_handle->pv_codec_handle);
 
                     ih264e_ctl_set_dimensions_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_dimensions_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_dimensions_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETDIM_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_dimensions_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETDIM_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_wd < MIN_WD)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_wd > ps_codec->s_cfg.u4_max_wd)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_ht < MIN_HT)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_ht > ps_codec->s_cfg.u4_max_ht)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if(ps_ip->s_ive_ip.u4_wd & 1)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_WIDTH_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if(ps_ip->s_ive_ip.u4_ht & 1)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HEIGHT_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_FRAMERATE:
                 {
                     ih264e_ctl_set_frame_rate_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_frame_rate_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_frame_rate_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETFRAMERATE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_frame_rate_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETFRAMERATE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (((ps_ip->s_ive_ip.u4_src_frame_rate * 1000) > DEFAULT_MAX_FRAMERATE)
                                     || ((ps_ip->s_ive_ip.u4_tgt_frame_rate * 1000) > DEFAULT_MAX_FRAMERATE))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_FRAME_RATE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if ((ps_ip->s_ive_ip.u4_src_frame_rate == 0)
                                     || (ps_ip->s_ive_ip.u4_tgt_frame_rate == 0))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_FRAME_RATE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_tgt_frame_rate
                                     > ps_ip->s_ive_ip.u4_src_frame_rate)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_TGT_FRAME_RATE_EXCEEDS_SRC_FRAME_RATE;
                         return (IV_FAIL);
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_BITRATE:
                 {
                     ih264e_ctl_set_bitrate_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_bitrate_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_bitrate_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETBITRATE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_bitrate_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETBITRATE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_target_bitrate > DEFAULT_MAX_BITRATE)
                                     || (ps_ip->s_ive_ip.u4_target_bitrate == 0))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_BITRATE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_FRAMETYPE:
                 {
                     ih264e_ctl_set_frame_type_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_frame_type_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_frame_type_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETFRAMETYPE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_frame_type_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETFRAMETYPE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.e_frame_type != IV_NA_FRAME)
                                     && (ps_ip->s_ive_ip.e_frame_type != IV_I_FRAME)
                                     && (ps_ip->s_ive_ip.e_frame_type != IV_P_FRAME)
                                     && (ps_ip->s_ive_ip.e_frame_type != IV_IDR_FRAME))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_FORCE_FRAME_INPUT;
                         return IV_FAIL;
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_ME_PARAMS:
                 {
                     codec_t *ps_codec = (codec_t *) (ps_handle->pv_codec_handle);
 
                     ih264e_ctl_set_me_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_me_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_me_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETMEPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_me_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETMEPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_me_speed_preset != FULL_SRCH)
                                     && (ps_ip->s_ive_ip.u4_me_speed_preset != DMND_SRCH)
                                     && (ps_ip->s_ive_ip.u4_me_speed_preset != HEX_SRCH))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ME_SPEED_PRESET;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enable_hpel != 0)
                                     && (ps_ip->s_ive_ip.u4_enable_hpel != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_HALFPEL_OPTION;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enable_qpel != 0)
                                     && (ps_ip->s_ive_ip.u4_enable_qpel != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_QPEL_OPTION;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enable_fast_sad != 0)
                                     && (ps_ip->s_ive_ip.u4_enable_fast_sad != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_FAST_SAD_OPTION;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_enable_alt_ref > 255)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ALT_REF_OPTION;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_srch_rng_x
                                     > ps_codec->s_cfg.u4_max_srch_rng_x)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_HORIZONTAL_SEARCH_RANGE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     if (ps_ip->s_ive_ip.u4_srch_rng_y
                                     > ps_codec->s_cfg.u4_max_srch_rng_y)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_VERTICAL_SEARCH_RANGE_NOT_SUPPORTED;
                         return (IV_FAIL);
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_IPE_PARAMS:
                 {
                     ih264e_ctl_set_ipe_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_ipe_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_ipe_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETIPEPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_ipe_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETIPEPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enable_intra_4x4 != 0)
                                     && (ps_ip->s_ive_ip.u4_enable_intra_4x4 != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_INTRA4x4_OPTION;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_constrained_intra_pred != 0)
                                     && (ps_ip->s_ive_ip.u4_constrained_intra_pred != 1))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_CONSTRAINED_INTRA_PREDICTION_MODE;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_CONFIG)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_SLOWEST)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_NORMAL)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_FAST)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_HIGH_SPEED)
                                     && (ps_ip->s_ive_ip.u4_enc_speed_preset != IVE_FASTEST))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ENC_SPEED_PRESET;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_GOP_PARAMS:
                 {
                     ih264e_ctl_set_gop_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_gop_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_gop_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETGOPPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_gop_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETGOPPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_i_frm_interval < DEFAULT_MIN_INTRA_FRAME_RATE)
                                     || (ps_ip->s_ive_ip.u4_i_frm_interval > DEFAULT_MAX_INTRA_FRAME_RATE))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_INTRA_FRAME_INTERVAL;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_idr_frm_interval < DEFAULT_MIN_INTRA_FRAME_RATE)
                                     || (ps_ip->s_ive_ip.u4_idr_frm_interval > DEFAULT_MAX_INTRA_FRAME_RATE))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_IDR_FRAME_INTERVAL;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_DEBLOCK_PARAMS:
                 {
                     ih264e_ctl_set_deblock_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_deblock_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_deblock_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETDEBLKPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_deblock_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETDEBLKPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_disable_deblock_level != DISABLE_DEBLK_LEVEL_0)
                                     && (ps_ip->s_ive_ip.u4_disable_deblock_level != DISABLE_DEBLK_LEVEL_2)
                                     && (ps_ip->s_ive_ip.u4_disable_deblock_level != DISABLE_DEBLK_LEVEL_3)
                                     && (ps_ip->s_ive_ip.u4_disable_deblock_level != DISABLE_DEBLK_LEVEL_4))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_DEBLOCKING_TYPE_INPUT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_QP:
                 {
                     ih264e_ctl_set_qp_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_qp_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_qp_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETQPPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_qp_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETQPPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_i_qp_max > MAX_H264_QP)
                                     || (ps_ip->s_ive_ip.u4_p_qp_max > MAX_H264_QP)
                                     || (ps_ip->s_ive_ip.u4_b_qp_max > MAX_H264_QP))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_MAX_FRAME_QP;
                         return IV_FAIL;
                     }
 
                     /* We donot support QP < 4 */
                     if ((ps_ip->s_ive_ip.u4_i_qp_min < 4)
                                     || (ps_ip->s_ive_ip.u4_p_qp_min < 4)
                                     || (ps_ip->s_ive_ip.u4_b_qp_min < 4)
                                     || (ps_ip->s_ive_ip.u4_i_qp_min > ps_ip->s_ive_ip.u4_i_qp_max)
                                     || (ps_ip->s_ive_ip.u4_p_qp_min > ps_ip->s_ive_ip.u4_p_qp_max)
                                     || (ps_ip->s_ive_ip.u4_b_qp_min > ps_ip->s_ive_ip.u4_b_qp_max))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_MIN_FRAME_QP;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_i_qp > ps_ip->s_ive_ip.u4_i_qp_max)
                                     || (ps_ip->s_ive_ip.u4_p_qp > ps_ip->s_ive_ip.u4_p_qp_max)
                                     || (ps_ip->s_ive_ip.u4_b_qp > ps_ip->s_ive_ip.u4_b_qp_max))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |= IH264E_INVALID_INIT_QP;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_i_qp < ps_ip->s_ive_ip.u4_i_qp_min)
                                     || (ps_ip->s_ive_ip.u4_p_qp < ps_ip->s_ive_ip.u4_p_qp_min)
                                     || (ps_ip->s_ive_ip.u4_b_qp < ps_ip->s_ive_ip.u4_b_qp_min))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |= IH264E_INVALID_INIT_QP;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_VUI_PARAMS:
                 {
                     ih264e_vui_ip_t *ps_ip = pv_api_ip;
                     ih264e_vui_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_vui_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVE_ERR_IP_CTL_SET_VUI_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_vui_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                         IVE_ERR_OP_CTL_SET_VUI_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_SEI_MDCV_PARAMS:
                 {
                     ih264e_ctl_set_sei_mdcv_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_sei_mdcv_params_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_ctl_set_sei_mdcv_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_IP_CTL_SET_SEI_MDCV_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_ctl_set_sei_mdcv_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_OP_CTL_SET_SEI_MDCV_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->u1_sei_mdcv_params_present_flag != 0)
                             && (ps_ip->u1_sei_mdcv_params_present_flag) != 1)
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IH264E_INVALID_SEI_MDCV_PARAMS;
                         return IV_FAIL;
                     }
 
                     if(1 == ps_ip->u1_sei_mdcv_params_present_flag)
                     {
                         /* Check values for u2_display_primaries_x and u2_display_primaries_y */
                         for(i = 0; i < 3; i++)
                         {
                             if((ps_ip->au2_display_primaries_x[i] >
                                                     DISPLAY_PRIMARIES_X_UPPER_LIMIT) ||
                                (ps_ip->au2_display_primaries_x[i] <
                                                     DISPLAY_PRIMARIES_X_LOWER_LIMIT) ||
                                ((ps_ip->au2_display_primaries_x[i] %
                                                     DISPLAY_PRIMARIES_X_DIVISION_FACTOR) != 0))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_MDCV_PARAMS;
                                 return IV_FAIL;
                             }
 
                             if((ps_ip->au2_display_primaries_y[i] >
                                                     DISPLAY_PRIMARIES_Y_UPPER_LIMIT) ||
                                (ps_ip->au2_display_primaries_y[i] <
                                                     DISPLAY_PRIMARIES_Y_LOWER_LIMIT) ||
                                ((ps_ip->au2_display_primaries_y[i] %
                                                     DISPLAY_PRIMARIES_Y_DIVISION_FACTOR) != 0))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_MDCV_PARAMS;
                                 return IV_FAIL;
                             }
                         }
 
                         if((ps_ip->u2_white_point_x > WHITE_POINT_X_UPPER_LIMIT) ||
                            (ps_ip->u2_white_point_x < WHITE_POINT_X_LOWER_LIMIT) ||
                            ((ps_ip->u2_white_point_x % WHITE_POINT_X_DIVISION_FACTOR) != 0))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if((ps_ip->u2_white_point_y > WHITE_POINT_Y_UPPER_LIMIT) ||
                            (ps_ip->u2_white_point_y < WHITE_POINT_Y_LOWER_LIMIT) ||
                            ((ps_ip->u2_white_point_y % WHITE_POINT_Y_DIVISION_FACTOR) != 0))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if((ps_ip->u4_max_display_mastering_luminance >
                                         MAX_DISPLAY_MASTERING_LUMINANCE_UPPER_LIMIT) ||
                            (ps_ip->u4_max_display_mastering_luminance <
                                         MAX_DISPLAY_MASTERING_LUMINANCE_LOWER_LIMIT) ||
                            ((ps_ip->u4_max_display_mastering_luminance %
                                         MAX_DISPLAY_MASTERING_LUMINANCE_DIVISION_FACTOR) != 0))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if((ps_ip->u4_min_display_mastering_luminance >
                                         MIN_DISPLAY_MASTERING_LUMINANCE_UPPER_LIMIT ) ||
                            (ps_ip->u4_min_display_mastering_luminance <
                                         MIN_DISPLAY_MASTERING_LUMINANCE_LOWER_LIMIT))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if(ps_ip->u4_max_display_mastering_luminance <=
                                 ps_ip->u4_min_display_mastering_luminance)
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_MDCV_PARAMS;
                             return IV_FAIL;
                         }
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_SEI_CLL_PARAMS:
                 {
                     ih264e_ctl_set_sei_cll_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_sei_cll_params_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_ctl_set_sei_cll_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_IP_CTL_SET_SEI_CLL_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_ctl_set_sei_cll_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_OP_CTL_SET_SEI_CLL_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->u1_sei_cll_params_present_flag != 0)
                             && (ps_ip->u1_sei_cll_params_present_flag != 1))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IH264E_INVALID_SEI_CLL_PARAMS;
                         return IV_FAIL;
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_SEI_AVE_PARAMS:
                 {
                     ih264e_ctl_set_sei_ave_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_sei_ave_params_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_ctl_set_sei_ave_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_IP_CTL_SET_SEI_AVE_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_ctl_set_sei_ave_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_OP_CTL_SET_SEI_AVE_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->u1_sei_ave_params_present_flag != 0)
                             && (ps_ip->u1_sei_ave_params_present_flag != 1))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IH264E_INVALID_SEI_AVE_PARAMS;
                         return IV_FAIL;
                     }
 
                     if(1 == ps_ip->u1_sei_ave_params_present_flag)
                     {
                         if((0 == ps_ip->u4_ambient_illuminance))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_AVE_PARAMS;
                             return IV_FAIL;
                         }
 
                         if(ps_ip->u2_ambient_light_x > AMBIENT_LIGHT_X_UPPER_LIMIT)
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_AVE_PARAMS;
                             return IV_FAIL;
                         }
 
                         if(ps_ip->u2_ambient_light_y > AMBIENT_LIGHT_Y_UPPER_LIMIT)
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_AVE_PARAMS;
                             return IV_FAIL;
                         }
                     }
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_SEI_CCV_PARAMS:
                 {
                     ih264e_ctl_set_sei_ccv_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_sei_ccv_params_op_t *ps_op = pv_api_op;
 
                     if(ps_ip->u4_size != sizeof(ih264e_ctl_set_sei_ccv_params_ip_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_IP_CTL_SET_SEI_CCV_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if(ps_op->u4_size != sizeof(ih264e_ctl_set_sei_ccv_params_op_t))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IVE_ERR_OP_CTL_SET_SEI_CCV_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if((ps_ip->u1_sei_ccv_params_present_flag != 0)
                             && (ps_ip->u1_sei_ccv_params_present_flag != 1))
                     {
                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                         ps_op->u4_error_code |=
                                 IH264E_INVALID_SEI_CCV_PARAMS;
                         return IV_FAIL;
                     }
 
 
                     if(1 == ps_ip->u1_sei_ccv_params_present_flag)
                     {
                         if((ps_ip->u1_ccv_cancel_flag != 0)
                                 && (ps_ip->u1_ccv_cancel_flag != 1))
                         {
                             ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                             ps_op->u4_error_code |=
                                     IH264E_INVALID_SEI_CCV_PARAMS;
                             return IV_FAIL;
                         }
 
                         if(0 == ps_ip->u1_ccv_cancel_flag)
                         {
                             if((ps_ip->u1_ccv_persistence_flag != 0)
                                     && (ps_ip->u1_ccv_persistence_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_primaries_present_flag != 0)
                                     && (ps_ip->u1_ccv_primaries_present_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_min_luminance_value_present_flag != 0)
                                     && (ps_ip->u1_ccv_min_luminance_value_present_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_max_luminance_value_present_flag != 0)
                                     && (ps_ip->u1_ccv_max_luminance_value_present_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_avg_luminance_value_present_flag != 0)
                                     && (ps_ip->u1_ccv_avg_luminance_value_present_flag != 1))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
                             if((ps_ip->u1_ccv_primaries_present_flag == 0)
                                     && (ps_ip->u1_ccv_min_luminance_value_present_flag == 0)
                                     && (ps_ip->u1_ccv_max_luminance_value_present_flag == 0)
                                     && (ps_ip->u1_ccv_avg_luminance_value_present_flag == 0))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
 
                             if((ps_ip->u1_ccv_reserved_zero_2bits != 0))
                             {
                                 ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                 ps_op->u4_error_code |=
                                         IH264E_INVALID_SEI_CCV_PARAMS;
                                 return IV_FAIL;
                             }
 
                             if(1 == ps_ip->u1_ccv_primaries_present_flag)
                             {
                                 for(i = 0; i < 3; i++)
                                 {
                                     if((ps_ip->ai4_ccv_primaries_x[i] >
                                                         CCV_PRIMARIES_X_UPPER_LIMIT) ||
                                        (ps_ip->ai4_ccv_primaries_x[i] <
                                                         CCV_PRIMARIES_X_LOWER_LIMIT))
                                     {
                                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                         ps_op->u4_error_code |=
                                                 IH264E_INVALID_SEI_CCV_PARAMS;
                                         return IV_FAIL;
                                     }
 
                                     if((ps_ip->ai4_ccv_primaries_y[i] >
                                                         CCV_PRIMARIES_Y_UPPER_LIMIT) ||
                                        (ps_ip->ai4_ccv_primaries_y[i] <
                                                         CCV_PRIMARIES_Y_LOWER_LIMIT))
                                     {
                                         ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                         ps_op->u4_error_code |=
                                                 IH264E_INVALID_SEI_CCV_PARAMS;
                                         return IV_FAIL;
                                     }
                                 }
                             }
 
                             if((1 == ps_ip->u1_ccv_min_luminance_value_present_flag) &&
                                     (1 == ps_ip->u1_ccv_avg_luminance_value_present_flag))
                             {
                                 if((ps_ip->u4_ccv_avg_luminance_value <
                                                     ps_ip->u4_ccv_min_luminance_value))
                                 {
                                     ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                     ps_op->u4_error_code |=
                                             IH264E_INVALID_SEI_CCV_PARAMS;
                                     return IV_FAIL;
                                 }
                             }
 
                             if((1 == ps_ip->u1_ccv_min_luminance_value_present_flag) &&
                                     (1 == ps_ip->u1_ccv_max_luminance_value_present_flag))
                             {
                                 if((ps_ip->u4_ccv_max_luminance_value <
                                                     ps_ip->u4_ccv_min_luminance_value))
                                 {
                                     ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                     ps_op->u4_error_code |=
                                             IH264E_INVALID_SEI_CCV_PARAMS;
                                     return IV_FAIL;
                                 }
                             }
                             if((1 == ps_ip->u1_ccv_avg_luminance_value_present_flag) &&
                                     (1 == ps_ip->u1_ccv_max_luminance_value_present_flag))
                             {
                                 if((ps_ip->u4_ccv_max_luminance_value <
                                                     ps_ip->u4_ccv_avg_luminance_value))
                                 {
                                     ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
                                     ps_op->u4_error_code |=
                                             IH264E_INVALID_SEI_CCV_PARAMS;
                                     return IV_FAIL;
                                 }
                             }
                         }
                     }
                     break;
                 }
 
+                case IVE_CMD_CTL_SET_SEI_SII_PARAMS:
+                {
+                    ih264e_ctl_set_sei_sii_params_ip_t *ps_ip = pv_api_ip;
+                    ih264e_ctl_set_sei_sii_params_op_t *ps_op = pv_api_op;
+
+                    if(ps_ip->u4_size != sizeof(ih264e_ctl_set_sei_sii_params_ip_t))
+                    {
+                        ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                        ps_op->u4_error_code |= IVE_ERR_IP_CTL_SET_SEI_SII_STRUCT_SIZE_INCORRECT;
+                        return IV_FAIL;
+                    }
+
+                    if(ps_op->u4_size != sizeof(ih264e_ctl_set_sei_sii_params_op_t))
+                    {
+                        ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                        ps_op->u4_error_code |= IVE_ERR_OP_CTL_SET_SEI_SII_STRUCT_SIZE_INCORRECT;
+                        return IV_FAIL;
+                    }
+
+                    /* The below error check is based on H264 spec docs SII syntax */
+                    if(0 != ps_ip->u4_sii_sub_layer_idx)
+                    {
+                        ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                        ps_op->u4_error_code |= IH264E_INVALID_SEI_SII_PARAMS;
+                        return IV_FAIL;
+                    }
+
+                    if(ps_ip->u1_sii_max_sub_layers_minus1 > 7)
+                    {
+                        ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                        ps_op->u4_error_code |= IH264E_INVALID_SEI_SII_PARAMS;
+                        return IV_FAIL;
+                    }
+
+                    if((ps_ip->u4_sii_sub_layer_idx > 0) &&
+                       (ps_ip->u1_fixed_shutter_interval_within_cvs_flag == 1))
+                    {
+                        ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                        ps_op->u4_error_code |= IH264E_SEI_SII_FAILED_TO_MATCH_SPEC_COND;
+                        return IV_FAIL;
+                    }
+
+                    if((ps_ip->u4_sii_sub_layer_idx > ps_ip->u1_sii_max_sub_layers_minus1) &&
+                       (ps_ip->u1_fixed_shutter_interval_within_cvs_flag == 0))
+                    {
+                        ps_op->u4_error_code |= 1 << IVE_UNSUPPORTEDPARAM;
+                        ps_op->u4_error_code |= IH264E_SEI_SII_FAILED_TO_MATCH_SPEC_COND;
+                        return IV_FAIL;
+                    }
+
+                    break;
+                }
+
                 case IVE_CMD_CTL_SET_ENC_MODE:
                 {
                     ih264e_ctl_set_enc_mode_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_enc_mode_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_enc_mode_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETENCMODE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_enc_mode_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETENCMODE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.e_enc_mode != IVE_ENC_MODE_HEADER)
                                     && (ps_ip->s_ive_ip.e_enc_mode != IVE_ENC_MODE_PICTURE))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ENC_OPERATION_MODE;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_VBV_PARAMS:
                 {
                     ih264e_ctl_set_vbv_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_vbv_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_vbv_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETVBVPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_vbv_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETVBVPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.u4_vbv_buffer_delay < DEFAULT_MIN_BUFFER_DELAY)
                                     || (ps_ip->s_ive_ip.u4_vbv_buffer_delay > DEFAULT_MAX_BUFFER_DELAY))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_BUFFER_DELAY;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_AIR_PARAMS:
                 {
                     ih264e_ctl_set_air_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_air_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_air_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETAIRPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_air_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETAIRPARAMS_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if ((ps_ip->s_ive_ip.e_air_mode != IVE_AIR_MODE_NONE)
                                     && (ps_ip->s_ive_ip.e_air_mode != IVE_AIR_MODE_CYCLIC)
                                     && (ps_ip->s_ive_ip.e_air_mode != IVE_AIR_MODE_RANDOM))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_AIR_MODE;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_air_refresh_period == 0)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_AIR_REFRESH_PERIOD;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 case IVE_CMD_CTL_SET_PROFILE_PARAMS:
                 {
                     ih264e_ctl_set_profile_params_ip_t *ps_ip = pv_api_ip;
                     ih264e_ctl_set_profile_params_op_t *ps_op = pv_api_op;
 
                     if (ps_ip->s_ive_ip.u4_size
                                     != sizeof(ih264e_ctl_set_profile_params_ip_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_IP_CTL_SETPROFILE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_op->s_ive_op.u4_size
                                     != sizeof(ih264e_ctl_set_profile_params_op_t))
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IVE_ERR_OP_CTL_SETPROFILE_API_STRUCT_SIZE_INCORRECT;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.e_profile != IV_PROFILE_BASE &&
                         ps_ip->s_ive_ip.e_profile != IV_PROFILE_MAIN)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_PROFILE_NOT_SUPPORTED;
                         return IV_FAIL;
                     }
 
                     if (ps_ip->s_ive_ip.u4_entropy_coding_mode > 1)
                     {
                         ps_op->s_ive_op.u4_error_code |= 1
                                         << IVE_UNSUPPORTEDPARAM;
                         ps_op->s_ive_op.u4_error_code |=
                                         IH264E_INVALID_ENTROPY_CODING_MODE;
                         return IV_FAIL;
                     }
 
                     break;
                 }
 
                 default:
                     *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
                     *(pu4_api_op + 1) |= IVE_ERR_INVALID_API_SUB_CMD;
                     return IV_FAIL;
             }
 
             break;
         }
 
         default:
             *(pu4_api_op + 1) |= 1 << IVE_UNSUPPORTEDPARAM;
             *(pu4_api_op + 1) |= IVE_ERR_INVALID_API_CMD;
             return IV_FAIL;
     }
 
     return IV_SUCCESS;
 }
 
 /**
 *******************************************************************************
 *
 * @brief update encoder configuration parameters
 *
 * @par Description:
 *  updates encoder configuration parameters from the given config set.
 *  Initialize/reinitialize codec parameters according to new configurations.
 *
 * @param[in] ps_codec
 *  Pointer to codec context
 *
 * @param[in] ps_cfg
 *  Pointer to config param set
 *
 * @remarks none
 *
 *******************************************************************************
 */
 IH264E_ERROR_T ih264e_codec_update_config(codec_t *ps_codec,
                                           cfg_params_t *ps_cfg)
 {
     /* config params */
     cfg_params_t *ps_curr_cfg = &ps_codec->s_cfg;
 
     /* error status */
     IH264E_ERROR_T err = IH264E_SUCCESS;
 
     /* temp var */
     UWORD32 u4_init_rc = 0;
 
     /***********************/
     /* UPDATE CODEC CONFIG */
     /***********************/
     if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_DIMENSIONS)
     {
         UWORD32 wd_aln = ALIGN16(ps_cfg->u4_wd);
         UWORD32 ht_aln = ALIGN16(ps_cfg->u4_ht);
 
         if (ps_curr_cfg->u4_wd != wd_aln || ps_curr_cfg->u4_ht != ht_aln
                         || ps_curr_cfg->u4_disp_wd != ps_cfg->u4_disp_wd
                         || ps_curr_cfg->u4_disp_ht != ps_cfg->u4_disp_ht)
         {
             ps_curr_cfg->u4_wd = wd_aln;
             ps_curr_cfg->u4_ht = ht_aln;
 
             ps_curr_cfg->u4_disp_wd = ps_cfg->u4_disp_wd;
             ps_curr_cfg->u4_disp_ht = ps_cfg->u4_disp_ht;
 
             ps_curr_cfg->i4_wd_mbs = ps_curr_cfg->u4_wd >> 4;
             ps_curr_cfg->i4_ht_mbs = ps_curr_cfg->u4_ht >> 4;
 
             ps_codec->i4_rec_strd = ALIGN16(ps_cfg->u4_wd) + PAD_WD;
 
             /* If number of MBs in a frame changes the air map also changes.
              * Hence recompute air map also reset air pic cnt */
             if (ps_codec->s_cfg.e_air_mode != IVE_AIR_MODE_NONE)
             {
                 /* re-init the air map */
                 ih264e_init_air_map(ps_codec);
 
                 /* reset air counter */
                 ps_codec->i4_air_pic_cnt = -1;
             }
 
             /* initialize mv bank buffer manager */
             err = ih264e_mv_buf_mgr_add_bufs(ps_codec);
             if (err != IH264E_SUCCESS)
                 return err;
 
             /* initialize ref bank buffer manager */
             err = ih264e_pic_buf_mgr_add_bufs(ps_codec);
             if (err != IH264E_SUCCESS)
                 return err;
 
             /* since dimension changed, start new sequence by forcing IDR */
             ps_codec->force_curr_frame_type = IV_IDR_FRAME;
 
             /* in case dimension changes, we need to reinitialize RC as the
              * old model shall not fit further */
             u4_init_rc = 1;
 
             /* when the dimension changes, the header needs to be regenerated */
             ps_codec->i4_gen_header = 1;
         }
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_FRAMERATE)
     {
         /* temp var */
         UWORD32 u4_src_ticks, u4_tgt_ticks;
 
         u4_src_ticks = ih264e_frame_time_get_src_ticks(
                         ps_codec->s_rate_control.pps_frame_time);
 
         u4_tgt_ticks = ih264e_frame_time_get_tgt_ticks(
                         ps_codec->s_rate_control.pps_frame_time);
 
         /* Change frame rate */
         if (ps_codec->s_cfg.u4_src_frame_rate
                         != ps_cfg->u4_src_frame_rate * 1000)
         {
             ps_codec->s_cfg.u4_src_frame_rate = ps_cfg->u4_src_frame_rate
                             * 1000;
 
             ih264e_frame_time_update_src_frame_rate(
                             ps_codec->s_rate_control.pps_frame_time,
                             ps_codec->s_cfg.u4_src_frame_rate);
 
             ih264_time_stamp_update_frame_rate(
                             ps_codec->s_rate_control.pps_time_stamp,
                             ps_codec->s_cfg.u4_src_frame_rate);
 
             irc_change_frame_rate(ps_codec->s_rate_control.pps_rate_control_api,
                                   ps_codec->s_cfg.u4_src_frame_rate,
                                   u4_src_ticks, u4_tgt_ticks);
         }
 
         if (ps_codec->s_cfg.u4_tgt_frame_rate
                         != ps_cfg->u4_tgt_frame_rate * 1000)
         {
             ps_codec->s_cfg.u4_tgt_frame_rate = ps_cfg->u4_tgt_frame_rate
                             * 1000;
 
             ih264e_frame_time_update_tgt_frame_rate(
                             ps_codec->s_rate_control.pps_frame_time,
                             ps_codec->s_cfg.u4_tgt_frame_rate);
 
             irc_change_frame_rate(ps_codec->s_rate_control.pps_rate_control_api,
                                   ps_codec->s_cfg.u4_src_frame_rate,
                                   u4_src_ticks, u4_tgt_ticks);
 
             irc_change_frm_rate_for_bit_alloc(
                             ps_codec->s_rate_control.pps_rate_control_api,
                             ps_codec->s_cfg.u4_tgt_frame_rate);
         }
 
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_BITRATE)
     {
         if (ps_curr_cfg->u4_target_bitrate != ps_cfg->u4_target_bitrate)
         {
             if (IVE_RC_NONE != ps_curr_cfg->e_rc_mode)
                 irc_change_avg_bit_rate(
                                 ps_codec->s_rate_control.pps_rate_control_api,
                                 ps_cfg->u4_target_bitrate);
 
             ps_curr_cfg->u4_target_bitrate = ps_cfg->u4_target_bitrate;
         }
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_FRAMETYPE)
     {
         switch (ps_cfg->e_frame_type)
         {
             case IV_I_FRAME:
                 ps_codec->force_curr_frame_type = IV_I_FRAME;
                 break;
 
             case IV_IDR_FRAME:
                 ps_codec->force_curr_frame_type = IV_IDR_FRAME;
                 break;
 
             case IV_P_FRAME:
             default:
                 break;
         }
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_ME_PARAMS)
     {
         if (ps_curr_cfg->u4_enc_speed_preset == IVE_CONFIG)
         {
             ps_codec->s_cfg.u4_enable_hpel = ps_cfg->u4_enable_hpel;
             ps_codec->s_cfg.u4_enable_fast_sad = ps_cfg->u4_enable_fast_sad;
             ps_codec->s_cfg.u4_me_speed_preset = ps_cfg->u4_me_speed_preset;
             ps_codec->s_cfg.u4_enable_qpel = ps_cfg->u4_enable_qpel;
         }
         else if (ps_curr_cfg->u4_enc_speed_preset == IVE_FASTEST)
         {
             ps_codec->s_cfg.u4_enable_fast_sad = ps_cfg->u4_enable_fast_sad;
         }
         ps_codec->s_cfg.u4_srch_rng_x = ps_cfg->u4_srch_rng_x;
         ps_codec->s_cfg.u4_srch_rng_y = ps_cfg->u4_srch_rng_y;
 
         if (ps_codec->s_cfg.u4_enable_alt_ref != ps_cfg->u4_enable_alt_ref)
         {
             ps_codec->s_cfg.u4_enable_alt_ref = ps_cfg->u4_enable_alt_ref;
             ps_codec->u4_is_curr_frm_ref = 1;
         }
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_IPE_PARAMS)
     {
         ps_curr_cfg->u4_enc_speed_preset = ps_cfg->u4_enc_speed_preset;
         ps_curr_cfg->u4_constrained_intra_pred = ps_cfg->u4_constrained_intra_pred;
         if (ps_curr_cfg->u4_enc_speed_preset == IVE_SLOWEST)
         {/* high quality */
             /* enable diamond search */
             ps_curr_cfg->u4_me_speed_preset = DMND_SRCH;
             ps_curr_cfg->u4_enable_fast_sad = 0;
 
             /* disable intra 4x4 */
             ps_curr_cfg->u4_enable_intra_4x4 = 1;
             ps_codec->luma_energy_compaction[1] =
                             ih264e_code_luma_intra_macroblock_4x4_rdopt_on;
 
             /* sub pel off */
             ps_curr_cfg->u4_enable_hpel = 1;
 
             /* deblocking off */
             ps_curr_cfg->u4_disable_deblock_level = DISABLE_DEBLK_LEVEL_0;
 
             /* disabled intra inter gating in Inter slices */
             ps_codec->u4_inter_gate = 0;
         }
         else if (ps_curr_cfg->u4_enc_speed_preset == IVE_NORMAL)
         {/* normal */
             /* enable diamond search */
             ps_curr_cfg->u4_me_speed_preset = DMND_SRCH;
             ps_curr_cfg->u4_enable_fast_sad = 0;
 
             /* disable intra 4x4 */
             ps_curr_cfg->u4_enable_intra_4x4 = 1;
 
             /* sub pel off */
             ps_curr_cfg->u4_enable_hpel = 1;
 
             /* deblocking off */
             ps_curr_cfg->u4_disable_deblock_level = DISABLE_DEBLK_LEVEL_0;
 
             /* disabled intra inter gating in Inter slices */
             ps_codec->u4_inter_gate = 0;
         }
         else if (ps_curr_cfg->u4_enc_speed_preset == IVE_FAST)
         {/* normal */
             /* enable diamond search */
             ps_curr_cfg->u4_me_speed_preset = DMND_SRCH;
             ps_curr_cfg->u4_enable_fast_sad = 0;
 
             /* disable intra 4x4 */
             ps_curr_cfg->u4_enable_intra_4x4 = 0;
 
             /* sub pel off */
             ps_curr_cfg->u4_enable_hpel = 1;
 
             /* deblocking off */
             ps_curr_cfg->u4_disable_deblock_level = DISABLE_DEBLK_LEVEL_0;
 
             /* disabled intra inter gating in Inter slices */
             ps_codec->u4_inter_gate = 1;
         }
         else if (ps_curr_cfg->u4_enc_speed_preset == IVE_HIGH_SPEED)
         {/* fast */
             /* enable diamond search */
             ps_curr_cfg->u4_me_speed_preset = DMND_SRCH;
             ps_curr_cfg->u4_enable_fast_sad = 0;
 
             /* disable intra 4x4 */
             ps_curr_cfg->u4_enable_intra_4x4 = 0;
 
             /* sub pel off */
             ps_curr_cfg->u4_enable_hpel = 0;
 
             /* deblocking off */
             ps_curr_cfg->u4_disable_deblock_level = DISABLE_DEBLK_LEVEL_4;
 
             /* disabled intra inter gating in Inter slices */
             ps_codec->u4_inter_gate = 0;
         }
         else if (ps_curr_cfg->u4_enc_speed_preset == IVE_FASTEST)
         {/* fastest */
             /* enable diamond search */
             ps_curr_cfg->u4_me_speed_preset = DMND_SRCH;
             //u4_num_layers = 4;
 
             /* disable intra 4x4 */
             ps_curr_cfg->u4_enable_intra_4x4 = 0;
 
             /* sub pel off */
             ps_curr_cfg->u4_enable_hpel = 0;
 
             /* deblocking off */
             ps_curr_cfg->u4_disable_deblock_level = DISABLE_DEBLK_LEVEL_4;
 
             /* disabled intra inter gating in Inter slices */
             ps_codec->u4_inter_gate = 1;
         }
         else if (ps_curr_cfg->u4_enc_speed_preset == IVE_CONFIG)
         {
             ps_curr_cfg->u4_enable_intra_4x4 = ps_cfg->u4_enable_intra_4x4;
         }
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_GOP_PARAMS)
     {
         if (ps_curr_cfg->u4_i_frm_interval != ps_cfg->u4_i_frm_interval)
         {
             ps_curr_cfg->u4_i_frm_interval = ps_cfg->u4_i_frm_interval;
 
             /* reset air counter */
             ps_codec->i4_air_pic_cnt = -1;
 
             /* re-init air map */
             ih264e_init_air_map(ps_codec);
 
             /*Effect intra frame interval change*/
 
             irc_change_intra_frm_int_call(
                             ps_codec->s_rate_control.pps_rate_control_api,
                             ps_curr_cfg->u4_i_frm_interval);
         }
 
         ps_curr_cfg->u4_idr_frm_interval = ps_cfg->u4_idr_frm_interval;
 
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_DEBLOCK_PARAMS)
     {
         if (ps_curr_cfg->u4_enc_speed_preset == IVE_CONFIG)
         {
             ps_curr_cfg->u4_disable_deblock_level =
                             ps_cfg->u4_disable_deblock_level;
         }
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_QP)
     {
         UWORD8 au1_init_qp[MAX_PIC_TYPE];
         UWORD8 au1_min_max_qp[2 * MAX_PIC_TYPE];
 
         ps_codec->s_cfg.u4_i_qp_max = ps_cfg->u4_i_qp_max;
         ps_codec->s_cfg.u4_i_qp_min = ps_cfg->u4_i_qp_min;
         ps_codec->s_cfg.u4_i_qp = ps_cfg->u4_i_qp;
 
         ps_codec->s_cfg.u4_p_qp_max = ps_cfg->u4_p_qp_max;
         ps_codec->s_cfg.u4_p_qp_min = ps_cfg->u4_p_qp_min;
         ps_codec->s_cfg.u4_p_qp = ps_cfg->u4_p_qp;
 
         ps_codec->s_cfg.u4_b_qp_max = ps_cfg->u4_b_qp_max;
         ps_codec->s_cfg.u4_b_qp_min = ps_cfg->u4_b_qp_min;
         ps_codec->s_cfg.u4_b_qp = ps_cfg->u4_b_qp;
 
         /* update rc lib with modified qp */
         au1_init_qp[0] = gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_i_qp];
         au1_init_qp[1] = gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_p_qp];
         au1_init_qp[2] = gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_b_qp];
 
         irc_change_init_qp(ps_codec->s_rate_control.pps_rate_control_api,
                            au1_init_qp);
 
         au1_min_max_qp[2 * I_PIC] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_i_qp_min];
         au1_min_max_qp[2 * I_PIC + 1] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_i_qp_max];
 
         au1_min_max_qp[2 * P_PIC] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_p_qp_min];
         au1_min_max_qp[2 * P_PIC + 1] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_p_qp_max];
 
         au1_min_max_qp[2 * B_PIC] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_b_qp_min];
         au1_min_max_qp[2 * B_PIC + 1] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_b_qp_max];
 
         irc_change_min_max_qp(ps_codec->s_rate_control.pps_rate_control_api,
                               au1_min_max_qp);
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_ENC_MODE)
     {
         ps_codec->s_cfg.e_enc_mode = ps_cfg->e_enc_mode;
 
         if (ps_codec->s_cfg.e_enc_mode == IVE_ENC_MODE_HEADER)
         {
             ps_codec->i4_header_mode = 1;
             ps_codec->s_cfg.e_enc_mode = IVE_ENC_MODE_PICTURE;
         }
         else
         {
             ps_codec->i4_header_mode = 0;
         }
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_VBV_PARAMS
                     && IVE_RC_NONE != ps_codec->s_cfg.e_rc_mode)
     {
         ps_codec->s_cfg.u4_vbv_buf_size = ps_cfg->u4_vbv_buf_size;
         ps_codec->s_cfg.u4_vbv_buffer_delay = ps_cfg->u4_vbv_buffer_delay;
 
         // irc_change_buffer_delay(ps_codec->s_rate_control.pps_rate_control_api, ps_codec->s_cfg.u4_vbv_buffer_delay);
 
         // TODO: remove this when the support for changing buffer dynamically
         // is yet to be added.
         u4_init_rc = 1;
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_AIR_PARAMS)
     {
         if (ps_curr_cfg->e_air_mode != ps_cfg->e_air_mode
                         || ps_curr_cfg->u4_air_refresh_period
                                         != ps_cfg->u4_air_refresh_period)
         {
             ps_curr_cfg->e_air_mode = ps_cfg->e_air_mode;
             ps_curr_cfg->u4_air_refresh_period = ps_cfg->u4_air_refresh_period;
 
             ih264e_init_air_map(ps_codec);
 
             /* reset air counter */
             ps_codec->i4_air_pic_cnt = -1;
         }
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_PROFILE_PARAMS)
     {
         ps_codec->s_cfg.e_profile = ps_cfg->e_profile;
         ps_codec->s_cfg.u4_entropy_coding_mode = ps_cfg->u4_entropy_coding_mode;
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_NUM_CORES)
     {
         ps_codec->s_cfg.u4_num_cores = ps_cfg->u4_num_cores;
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_VUI_PARAMS)
     {
         ps_codec->s_cfg.s_vui = ps_cfg->s_vui;
     }
 
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_SEI_MDCV_PARAMS)
     {
         ps_codec->s_cfg.s_sei.u1_sei_mdcv_params_present_flag =
                                                 ps_cfg->s_sei.u1_sei_mdcv_params_present_flag;
         ps_codec->s_cfg.s_sei.s_sei_mdcv_params = ps_cfg->s_sei.s_sei_mdcv_params;
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_SEI_CLL_PARAMS)
     {
         ps_codec->s_cfg.s_sei.u1_sei_cll_params_present_flag =
                                                 ps_cfg->s_sei.u1_sei_cll_params_present_flag;
         ps_codec->s_cfg.s_sei.s_sei_cll_params = ps_cfg->s_sei.s_sei_cll_params;
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_SEI_AVE_PARAMS)
     {
         ps_codec->s_cfg.s_sei.u1_sei_ave_params_present_flag =
                                                 ps_cfg->s_sei.u1_sei_ave_params_present_flag;
         ps_codec->s_cfg.s_sei.s_sei_ave_params = ps_cfg->s_sei.s_sei_ave_params;
     }
     else if (ps_cfg->e_cmd == IVE_CMD_CTL_SET_SEI_CCV_PARAMS)
     {
         ps_codec->s_cfg.s_sei.u1_sei_ccv_params_present_flag =
                                                 ps_cfg->s_sei.u1_sei_ccv_params_present_flag;
         ps_codec->s_cfg.s_sei.s_sei_ccv_params = ps_cfg->s_sei.s_sei_ccv_params;
     }
+    else if(ps_cfg->e_cmd == IVE_CMD_CTL_SET_SEI_SII_PARAMS)
+    {
+        ps_codec->s_cfg.s_sei.u1_sei_sii_params_present_flag =
+            ps_cfg->s_sei.u1_sei_sii_params_present_flag;
+        ps_codec->s_cfg.s_sei.s_sei_sii_params = ps_cfg->s_sei.s_sei_sii_params;
+    }
 
     /* reset RC model */
     if (u4_init_rc)
     {
         /* init qp */
         UWORD8 au1_init_qp[MAX_PIC_TYPE];
 
         /* min max qp */
         UWORD8 au1_min_max_qp[2 * MAX_PIC_TYPE];
 
         /* init i,p,b qp */
         au1_init_qp[0] = gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_i_qp];
         au1_init_qp[1] = gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_p_qp];
         au1_init_qp[2] = gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_b_qp];
 
         /* init min max qp */
         au1_min_max_qp[2 * I_PIC] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_i_qp_min];
         au1_min_max_qp[2 * I_PIC + 1] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_i_qp_max];
 
         au1_min_max_qp[2 * P_PIC] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_p_qp_min];
         au1_min_max_qp[2 * P_PIC + 1] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_p_qp_max];
 
         au1_min_max_qp[2 * B_PIC] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_b_qp_min];
         au1_min_max_qp[2 * B_PIC + 1] =
                         gau1_h264_to_mpeg2_qmap[ps_codec->s_cfg.u4_b_qp_max];
 
         /* get rc mode */
         switch (ps_codec->s_cfg.e_rc_mode)
         {
             case IVE_RC_STORAGE:
                 ps_codec->s_rate_control.e_rc_type = VBR_STORAGE;
                 break;
 
             case IVE_RC_CBR_NON_LOW_DELAY:
                 ps_codec->s_rate_control.e_rc_type = CBR_NLDRC;
                 break;
 
             case IVE_RC_CBR_LOW_DELAY:
                 ps_codec->s_rate_control.e_rc_type = CBR_LDRC;
                 break;
 
             case IVE_RC_NONE:
                 ps_codec->s_rate_control.e_rc_type = CONST_QP;
                 break;
 
             default:
                 break;
         }
 
         /* init rate control */
         ih264e_rc_init(ps_codec->s_rate_control.pps_rate_control_api,
                        ps_codec->s_rate_control.pps_frame_time,
                        ps_codec->s_rate_control.pps_time_stamp,
                        ps_codec->s_rate_control.pps_pd_frm_rate,
                        ps_codec->s_cfg.u4_max_framerate,
                        ps_codec->s_cfg.u4_src_frame_rate,
                        ps_codec->s_cfg.u4_tgt_frame_rate,
                        ps_codec->s_rate_control.e_rc_type,
                        ps_codec->s_cfg.u4_target_bitrate,
                        ps_codec->s_cfg.u4_max_bitrate,
                        ps_codec->s_cfg.u4_vbv_buffer_delay,
                        ps_codec->s_cfg.u4_i_frm_interval,
                        ps_codec->s_cfg.u4_num_bframes + 1, au1_init_qp,
                        ps_codec->s_cfg.u4_num_bframes + 2, au1_min_max_qp,
                        ps_codec->s_cfg.u4_max_level);
     }
 
     return err;
 }
 
 /**
 *******************************************************************************
 *
 * @brief
 *  Sets default encoder config parameters
 *
 * @par Description:
 *  Sets default dynamic parameters. Will be called in ih264e_init() to ensure
 *  that even if set_params is not called, codec continues to work
 *
 * @param[in] ps_cfg
 *  Pointer to encoder config params
 *
 * @returns  error status
 *
 * @remarks none
 *
 *******************************************************************************
 */
@@ -6035,93 +6094,165 @@ static WORD32 ih264e_set_sei_ave_params(void *pv_api_ip,
 /**
  *******************************************************************************
  *
  * @brief
  *  Sets content color volume sei params
  *
  * @par Description:
  *  Supplemental enhancement information
  *
  * @param[in] pv_api_ip
  *  Pointer to input argument structure
  *
  * @param[out] pv_api_op
  *  Pointer to output argument structure
  *
  * @param[out] ps_cfg
  *  Pointer to config structure to be updated
  *
  * @return error status
  *
  * @remarks none
  *
  *******************************************************************************
  */
 static WORD32 ih264e_set_sei_ccv_params(void *pv_api_ip,
                                         void *pv_api_op,
                                         cfg_params_t *ps_cfg)
 {
     WORD32 i4_count;
     /* ctrl call I/O structures */
     ih264e_ctl_set_sei_ccv_params_ip_t *ps_ip = pv_api_ip;
     ih264e_ctl_set_sei_ccv_params_op_t *ps_op = pv_api_op;
     sei_params_t *ps_sei = &ps_cfg->s_sei;
 
     ps_op->u4_error_code = 0;
 
     ps_sei->u1_sei_ccv_params_present_flag = ps_ip->u1_sei_ccv_params_present_flag;
 
     ps_sei->s_sei_ccv_params.u1_ccv_cancel_flag = ps_ip->u1_ccv_cancel_flag;
     ps_sei->s_sei_ccv_params.u1_ccv_persistence_flag = ps_ip->u1_ccv_persistence_flag;
     ps_sei->s_sei_ccv_params.u1_ccv_primaries_present_flag =
                                                 ps_ip->u1_ccv_primaries_present_flag;
     ps_sei->s_sei_ccv_params.u1_ccv_min_luminance_value_present_flag =
                                                 ps_ip->u1_ccv_min_luminance_value_present_flag;
     ps_sei->s_sei_ccv_params.u1_ccv_max_luminance_value_present_flag =
                                                 ps_ip->u1_ccv_max_luminance_value_present_flag;
     ps_sei->s_sei_ccv_params.u1_ccv_avg_luminance_value_present_flag =
                                                 ps_ip->u1_ccv_avg_luminance_value_present_flag;
     ps_sei->s_sei_ccv_params.u1_ccv_reserved_zero_2bits =
                                                 ps_ip->u1_ccv_reserved_zero_2bits;
 
     for(i4_count = 0; i4_count < NUM_SEI_CCV_PRIMARIES; i4_count++)
     {
         ps_sei->s_sei_ccv_params.ai4_ccv_primaries_x[i4_count] =
                                                 ps_ip->ai4_ccv_primaries_x[i4_count];
         ps_sei->s_sei_ccv_params.ai4_ccv_primaries_y[i4_count] =
                                                 ps_ip->ai4_ccv_primaries_y[i4_count];
     }
 
     ps_sei->s_sei_ccv_params.u4_ccv_min_luminance_value = ps_ip->u4_ccv_min_luminance_value;
     ps_sei->s_sei_ccv_params.u4_ccv_max_luminance_value = ps_ip->u4_ccv_max_luminance_value;
     ps_sei->s_sei_ccv_params.u4_ccv_avg_luminance_value = ps_ip->u4_ccv_avg_luminance_value;
 
     ps_cfg->u4_timestamp_high = ps_ip->u4_timestamp_high;
     ps_cfg->u4_timestamp_low = ps_ip->u4_timestamp_low;
 
     return IV_SUCCESS;
 }
 
+/**
+*******************************************************************************
+*
+* @brief
+ *  Sets shutter interval info sei params
+ *
+ * @par Description:
+ *  Supplemental enhancement information
+ *
+ * @param[in] pv_api_ip
+ *  Pointer to input argument structure
+ *
+ * @param[out] pv_api_op
+ *  Pointer to output argument structure
+ *
+ * @param[out] ps_cfg
+ *  Pointer to config structure to be updated
+ *
+ * @return error status
+ *
+ * @remarks none
+ *
+ *******************************************************************************
+ */
+static WORD32 ih264e_set_sei_sii_params(void *pv_api_ip, void *pv_api_op, cfg_params_t *ps_cfg)
+{
+    /* ctrl call I/O structures */
+    ih264e_ctl_set_sei_sii_params_ip_t *ps_ip = pv_api_ip;
+    ih264e_ctl_set_sei_sii_params_op_t *ps_op = pv_api_op;
+    sei_params_t *ps_sei = &ps_cfg->s_sei;
+
+    ps_op->u4_error_code = 0;
+    ps_sei->u1_sei_sii_params_present_flag = ps_ip->u1_shutter_interval_info_present_flag;
+    ps_sei->s_sei_sii_params.u4_sii_sub_layer_idx = ps_ip->u4_sii_sub_layer_idx;
+
+    if(0 == ps_sei->s_sei_sii_params.u4_sii_sub_layer_idx)
+    {
+        ps_sei->s_sei_sii_params.u1_shutter_interval_info_present_flag =
+            ps_ip->u1_shutter_interval_info_present_flag;
+
+        if(1 == ps_sei->s_sei_sii_params.u1_shutter_interval_info_present_flag)
+        {
+            ps_sei->s_sei_sii_params.u4_sii_time_scale = ps_ip->u4_sii_time_scale;
+            ps_sei->s_sei_sii_params.u1_fixed_shutter_interval_within_cvs_flag =
+                ps_ip->u1_fixed_shutter_interval_within_cvs_flag;
+
+            if(1 == ps_sei->s_sei_sii_params.u1_fixed_shutter_interval_within_cvs_flag)
+            {
+                ps_sei->s_sei_sii_params.u4_sii_num_units_in_shutter_interval =
+                    ps_ip->u4_sii_num_units_in_shutter_interval;
+            }
+            else
+            {
+                int i;
+                ps_sei->s_sei_sii_params.u1_sii_max_sub_layers_minus1 =
+                    ps_ip->u1_sii_max_sub_layers_minus1;
+
+                for(i = 0; i <= ps_ip->u1_sii_max_sub_layers_minus1; i++)
+                {
+                    ps_sei->s_sei_sii_params.au4_sub_layer_num_units_in_shutter_interval[i] =
+                        ps_ip->au4_sub_layer_num_units_in_shutter_interval[i];
+                }
+            }
+        }
+    }
+
+    ps_cfg->u4_timestamp_high = ps_ip->u4_timestamp_high;
+    ps_cfg->u4_timestamp_low = ps_ip->u4_timestamp_low;
+
+    return IV_SUCCESS;
+}
+
 /**
 *******************************************************************************
 *
 * @brief
 *  Sets number of cores
 *
 * @par Description:
 *  Sets number of cores
 *
 * @param[in] ps_codec_obj
 *  Pointer to codec object at API level
 *
 * @param[in] pv_api_ip
 *  Pointer to input argument structure
 *
 * @param[out] pv_api_op
 *  Pointer to output argument structure
 *
 * @returns error status
 *
 * @remarks The number of encoder threads is limited to MAX_PROCESS_THREADS
 *
 *******************************************************************************
 */
@@ -6196,267 +6327,271 @@ static WORD32 ih264e_reset(iv_obj_t *ps_codec_obj,
 /**
 *******************************************************************************
 *
 * @brief
 *  Codec control call
 *
 * @par Description:
 *  Codec control call which in turn calls appropriate calls  based on sub-command
 *
 * @param[in] ps_codec_obj
 *  Pointer to codec object at API level
 *
 * @param[in] pv_api_ip
 *  Pointer to input argument structure
 *
 * @param[out] pv_api_op
 *  Pointer to output argument structure
 *
 * @returns error status
 *
 * @remarks none
 *
 *******************************************************************************
 */
 static WORD32 ih264e_ctl(iv_obj_t *ps_codec_obj,
                          void *pv_api_ip,
                          void *pv_api_op)
 {
     /* codec ctxt */
     codec_t *ps_codec = (codec_t *) ps_codec_obj->pv_codec_handle;
 
     /* ctrl call I/O structures */
     ih264e_ctl_setdefault_ip_t *ps_ctl_ip = pv_api_ip;
     ih264e_ctl_setdefault_op_t *ps_ctl_op = pv_api_op;
 
     /* ctrl call sub cmd */
     IVE_CONTROL_API_COMMAND_TYPE_T sub_cmd = ps_ctl_ip->s_ive_ip.e_sub_cmd;
 
     /* error status */
     IV_STATUS_T ret = IV_SUCCESS;
 
     /* temp var */
     WORD32 i;
     cfg_params_t *ps_cfg = NULL;
 
     /* control call is for configuring encoding params, this is not to be called
      * before a successful init call */
     if (ps_codec->i4_init_done != 1)
     {
         ps_ctl_op->s_ive_op.u4_error_code |= 1 << IVE_FATALERROR;
         ps_ctl_op->s_ive_op.u4_error_code |= IH264E_INIT_NOT_DONE;
         return IV_FAIL;
     }
 
     /* make it thread safe */
     ithread_mutex_lock(ps_codec->pv_ctl_mutex);
 
     /* find a free config param set to hold current parameters */
     for (i = 0; i < MAX_ACTIVE_CONFIG_PARAMS; i++)
     {
         if (0 == ps_codec->as_cfg[i].u4_is_valid)
         {
             ps_cfg = &ps_codec->as_cfg[i];
             break;
         }
     }
 
     /* If all are invalid, then start overwriting from the head config params */
     if (NULL == ps_cfg)
     {
         ps_cfg = &ps_codec->as_cfg[0];
     }
 
     ps_cfg->u4_is_valid = 1;
 
     ps_cfg->e_cmd = sub_cmd;
 
     switch (sub_cmd)
     {
         case IVE_CMD_CTL_SET_DIMENSIONS:
             ret = ih264e_set_dimensions(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_FRAMERATE:
             ret = ih264e_set_frame_rate(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_BITRATE:
             ret = ih264e_set_bit_rate(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_FRAMETYPE:
             ret = ih264e_set_frame_type(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_QP:
             ret = ih264e_set_qp(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_ENC_MODE:
             ret = ih264e_set_enc_mode(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_VBV_PARAMS:
             ret = ih264e_set_vbv_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_AIR_PARAMS:
             ret = ih264_set_air_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_ME_PARAMS:
             ret = ih264_set_me_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_IPE_PARAMS:
             ret = ih264_set_ipe_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_GOP_PARAMS:
             ret = ih264_set_gop_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_PROFILE_PARAMS:
             ret = ih264_set_profile_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_DEBLOCK_PARAMS:
             ret = ih264_set_deblock_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_VUI_PARAMS:
             ret = ih264e_set_vui_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_SEI_MDCV_PARAMS:
             ret = ih264e_set_sei_mdcv_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_SEI_CLL_PARAMS:
             ret = ih264e_set_sei_cll_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_SEI_AVE_PARAMS:
             ret = ih264e_set_sei_ave_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         case IVE_CMD_CTL_SET_SEI_CCV_PARAMS:
             ret = ih264e_set_sei_ccv_params(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
+        case IVE_CMD_CTL_SET_SEI_SII_PARAMS:
+            ret = ih264e_set_sei_sii_params(pv_api_ip, pv_api_op, ps_cfg);
+            break;
+
         case IVE_CMD_CTL_RESET:
 
             /* invalidate config param struct as it is being served right away */
             ps_codec->as_cfg[i].u4_is_valid = 0;
 
             ret = ih264e_reset(ps_codec_obj, pv_api_ip, pv_api_op);
             break;
 
         case IVE_CMD_CTL_SETDEFAULT:
         {
             /* ctrl call I/O structures */
             ih264e_ctl_setdefault_op_t *ps_op = pv_api_op;
 
             /* invalidate config param struct as it is being served right away */
             ps_codec->as_cfg[i].u4_is_valid = 0;
 
             /* error status */
             ret = ih264e_set_default_params(ps_cfg);
 
             ps_op->s_ive_op.u4_error_code = ret;
 
             break;
         }
 
         case IVE_CMD_CTL_FLUSH:
 
             /* invalidate config param struct as it is being served right away */
             ps_codec->as_cfg[i].u4_is_valid = 0;
 
             ret = ih264e_set_flush_mode(ps_codec_obj, pv_api_ip, pv_api_op);
             break;
 
         case IVE_CMD_CTL_GETBUFINFO:
 
             /* invalidate config param struct as it is being served right away */
             ps_codec->as_cfg[i].u4_is_valid = 0;
 
             ret = ih264e_get_buf_info(ps_codec_obj, pv_api_ip, pv_api_op);
             break;
 
         case IVE_CMD_CTL_GETVERSION:
         {
             /* ctrl call I/O structures */
             ih264e_ctl_getversioninfo_ip_t *ps_ip = pv_api_ip;
             ih264e_ctl_getversioninfo_op_t *ps_op = pv_api_op;
 
             /* invalidate config param struct as it is being served right away */
             ps_codec->as_cfg[i].u4_is_valid = 0;
 
             /* error status */
             ps_op->s_ive_op.u4_error_code = IV_SUCCESS;
 
             if (ps_ip->s_ive_ip.u4_version_bufsize <= 0)
             {
                 ps_op->s_ive_op.u4_error_code =
                                 IH264E_CXA_VERS_BUF_INSUFFICIENT;
                 ret = IV_FAIL;
             }
             else
             {
                 ret = ih264e_get_version((CHAR *) ps_ip->s_ive_ip.pu1_version,
                                          ps_ip->s_ive_ip.u4_version_bufsize);
 
                 if (ret != IV_SUCCESS)
                 {
                     ps_op->s_ive_op.u4_error_code =
                                     IH264E_CXA_VERS_BUF_INSUFFICIENT;
                     ret = IV_FAIL;
                 }
             }
             break;
         }
 
         case IVE_CMD_CTL_SET_NUM_CORES:
             ret = ih264e_set_num_cores(pv_api_ip, pv_api_op, ps_cfg);
             break;
 
         default:
             /* invalidate config param struct as it is being served right away */
             ps_codec->as_cfg[i].u4_is_valid = 0;
 
             DEBUG("Warning !! unrecognized control api command \n");
             break;
     }
 
     ithread_mutex_unlock(ps_codec->pv_ctl_mutex);
 
     return ret;
 }
 
 /**
 *******************************************************************************
 *
 * @brief
 *  Codec entry point function. All the function calls to  the codec are done
 *  using this function with different values specified in command
 *
 * @par Description:
 *  Arguments are tested for validity and then based on the command
 *  appropriate function is called
 *
 * @param[in] ps_handle
 *  API level handle for codec
 *
 * @param[in] pv_api_ip
 *  Input argument structure
 *
 * @param[out] pv_api_op
 *  Output argument structure
 *
 * @returns  error_status
 *
 * @remarks
 *
 *******************************************************************************
 */
diff --git a/encoder/ih264e_encode.c b/encoder/ih264e_encode.c
index 9cf8409..75a8335 100644
--- a/encoder/ih264e_encode.c
+++ b/encoder/ih264e_encode.c
@@ -1,121 +1,122 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 
 /**
 ******************************************************************************
 * @file
 *  ih264e_encode.c
 *
 * @brief
 *  This file contains functions for encoding the input yuv frame in synchronous
 *  api mode
 *
 * @author
 *  ittiam
 *
 * List of Functions
 *  - ih264e_join_threads()
 *  - ih264e_wait_for_thread()
 *  - ih264e_encode()
 *
 ******************************************************************************
 */
 
 /*****************************************************************************/
 /* File Includes                                                             */
 /*****************************************************************************/
 
 /* System Include files */
 #include <stdio.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
 #include <limits.h>
+#include <stdbool.h>
 /* User Include files */
 #include "ih264e_config.h"
 #include "ih264_typedefs.h"
 #include "iv2.h"
 #include "ive2.h"
 #include "ih264e.h"
 #include "ithread.h"
 #include "ih264_defs.h"
 #include "ih264_macros.h"
 #include "ih264_debug.h"
 #include "ih264_structs.h"
 #include "ih264_platform_macros.h"
 #include "ih264_error.h"
 #include "ime_distortion_metrics.h"
 #include "ime_defs.h"
 #include "ime_structs.h"
 #include "ih264_trans_quant_itrans_iquant.h"
 #include "ih264_inter_pred_filters.h"
 #include "ih264_mem_fns.h"
 #include "ih264_padding.h"
 #include "ih264_intra_pred_filters.h"
 #include "ih264_deblk_edge_filters.h"
 #include "ih264_cabac_tables.h"
 #include "ih264_list.h"
 #include "ih264e_error.h"
 #include "ih264e_defs.h"
 #include "ih264e_bitstream.h"
 #include "irc_mem_req_and_acq.h"
 #include "irc_cntrl_param.h"
 #include "irc_frame_info_collector.h"
 #include "ih264e_rate_control.h"
 #include "ih264e_time_stamp.h"
 #include "ih264e_cabac_structs.h"
 #include "ih264e_structs.h"
 #include "ih264e_master.h"
 #include "ih264e_process.h"
 #include "ih264_buf_mgr.h"
 #include "ih264_dpb_mgr.h"
 #include "ih264e_utils.h"
 #include "ih264e_fmt_conv.h"
 #include "ih264e_statistics.h"
 #include "ih264e_trace.h"
 #include "ih264e_debug.h"
 #ifdef LOGO_EN
 #include "ih264e_ittiam_logo.h"
 #endif
 
 
 #define SEI_BASED_FORCE_IDR 1
 
 /*****************************************************************************/
 /* Function Definitions                                                      */
 /*****************************************************************************/
 
 /**
 ******************************************************************************
 *
 * @brief
 *  This function joins all the spawned threads after successful completion of
 *  their tasks
 *
 * @par   Description
 *
 * @param[in] ps_codec
 *  pointer to codec context
 *
 * @returns  none
 *
 ******************************************************************************
 */
@@ -180,639 +181,674 @@ IH264E_ERROR_T ih264e_wait_for_thread(UWORD32 sleep_us)
 /**
 ******************************************************************************
 *
 * @brief
 *  Encodes in synchronous api mode
 *
 * @par Description
 *  This routine processes input yuv, encodes it and outputs bitstream and recon
 *
 * @param[in] ps_codec_obj
 *  Pointer to codec object at API level
 *
 * @param[in] pv_api_ip
 *  Pointer to input argument structure
 *
 * @param[out] pv_api_op
 *  Pointer to output argument structure
 *
 * @returns  Status
 *
 ******************************************************************************
 */
 WORD32 ih264e_encode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)
 {
     /* error status */
     IH264E_ERROR_T error_status = IH264E_SUCCESS;
 
     /* codec ctxt */
     codec_t *ps_codec = (codec_t *)ps_codec_obj->pv_codec_handle;
 
     /* input frame to encode */
     ih264e_video_encode_ip_t *ps_video_encode_ip = pv_api_ip;
 
     /* output buffer to write stream */
     ih264e_video_encode_op_t *ps_video_encode_op = pv_api_op;
 
     /* i/o structures */
     inp_buf_t s_inp_buf;
     out_buf_t s_out_buf;
 
     /* temp var */
     WORD32 ctxt_sel = 0, i, i4_rc_pre_enc_skip;
 
     /********************************************************************/
     /*                            BEGIN INIT                            */
     /********************************************************************/
     /* reset output structure */
     ps_video_encode_op->s_ive_op.u4_error_code = IV_SUCCESS;
     ps_video_encode_op->s_ive_op.output_present  = 0;
     ps_video_encode_op->s_ive_op.dump_recon = 0;
     ps_video_encode_op->s_ive_op.u4_encoded_frame_type = IV_NA_FRAME;
     /* By default set the current input buffer as the buffer to be freed */
     /* This will later be updated to the actual input that gets encoded */
     ps_video_encode_op->s_ive_op.s_inp_buf = ps_video_encode_ip->s_ive_ip.s_inp_buf;
 
     /* Check for output memory allocation size */
     if (ps_video_encode_ip->s_ive_ip.s_out_buf.u4_bufsize < MIN_STREAM_SIZE)
     {
         error_status = IH264E_INSUFFICIENT_OUTPUT_BUFFER;
         SET_ERROR_ON_RETURN(error_status,
                             IVE_UNSUPPORTEDPARAM,
                             ps_video_encode_op->s_ive_op.u4_error_code,
                             IV_FAIL);
     }
 
     /* copy output info. to internal structure */
     s_out_buf.s_bits_buf = ps_video_encode_ip->s_ive_ip.s_out_buf;
     s_out_buf.u4_is_last = 0;
     s_out_buf.u4_timestamp_low = ps_video_encode_ip->s_ive_ip.u4_timestamp_low;
     s_out_buf.u4_timestamp_high = ps_video_encode_ip->s_ive_ip.u4_timestamp_high;
 
     /* api call cnt */
     ps_codec->i4_encode_api_call_cnt += 1;
 
     /* codec context selector */
     ctxt_sel = ps_codec->i4_encode_api_call_cnt % MAX_CTXT_SETS;
 
     /* reset status flags */
     ps_codec->ai4_pic_cnt[ctxt_sel] = -1;
     ps_codec->s_rate_control.post_encode_skip[ctxt_sel] = 0;
     ps_codec->s_rate_control.pre_encode_skip[ctxt_sel] = 0;
 
     /* pass output buffer to codec */
     ps_codec->as_out_buf[ctxt_sel] = s_out_buf;
 
     /* initialize codec ctxt with default params for the first encode api call */
     if (ps_codec->i4_encode_api_call_cnt == 0)
     {
         ih264e_codec_init(ps_codec);
     }
 
     /* parse configuration params */
     for (i = 0; i < MAX_ACTIVE_CONFIG_PARAMS; i++)
     {
         cfg_params_t *ps_cfg = &ps_codec->as_cfg[i];
 
         if (1 == ps_cfg->u4_is_valid)
         {
             if ( ((ps_cfg->u4_timestamp_high == ps_video_encode_ip->s_ive_ip.u4_timestamp_high) &&
                             (ps_cfg->u4_timestamp_low == ps_video_encode_ip->s_ive_ip.u4_timestamp_low)) ||
                             ((WORD32)ps_cfg->u4_timestamp_high == -1) ||
                             ((WORD32)ps_cfg->u4_timestamp_low == -1) )
             {
                 error_status = ih264e_codec_update_config(ps_codec, ps_cfg);
                 SET_ERROR_ON_RETURN(error_status,
                                     IVE_UNSUPPORTEDPARAM,
                                     ps_video_encode_op->s_ive_op.u4_error_code,
                                     IV_FAIL);
 
                 ps_cfg->u4_is_valid = 0;
             }
         }
     }
     /* Force IDR based on SEI params */
 #if SEI_BASED_FORCE_IDR
     {
+        int i;
+        bool au4_sub_layer_num_units_in_shutter_interval_flag = 0;
+
         sei_mdcv_params_t *ps_sei_mdcv_params = &ps_codec->s_sei.s_sei_mdcv_params;
         sei_mdcv_params_t *ps_cfg_sei_mdcv_params =
                                 &ps_codec->s_cfg.s_sei.s_sei_mdcv_params;
         sei_cll_params_t *ps_sei_cll_params = &ps_codec->s_sei.s_sei_cll_params;
         sei_cll_params_t *ps_cfg_sei_cll_params =
                                 &ps_codec->s_cfg.s_sei.s_sei_cll_params;
         sei_ave_params_t *ps_sei_ave_params = &ps_codec->s_sei.s_sei_ave_params;
         sei_ave_params_t *ps_cfg_sei_ave_params =
                                 &ps_codec->s_cfg.s_sei.s_sei_ave_params;
+        sei_sii_params_t *ps_sei_sii_params = &ps_codec->s_sei.s_sei_sii_params;
+        sei_sii_params_t *ps_cfg_sei_sii_params = &ps_codec->s_cfg.s_sei.s_sei_sii_params;
 
         if((ps_sei_mdcv_params->au2_display_primaries_x[0]!=
                                 ps_cfg_sei_mdcv_params->au2_display_primaries_x[0]) ||
             (ps_sei_mdcv_params->au2_display_primaries_x[1] !=
                                 ps_cfg_sei_mdcv_params->au2_display_primaries_x[1]) ||
             (ps_sei_mdcv_params->au2_display_primaries_x[2] !=
                                 ps_cfg_sei_mdcv_params->au2_display_primaries_x[2]) ||
             (ps_sei_mdcv_params->au2_display_primaries_y[0] !=
                                 ps_cfg_sei_mdcv_params->au2_display_primaries_y[0]) ||
             (ps_sei_mdcv_params->au2_display_primaries_y[1] !=
                                 ps_cfg_sei_mdcv_params->au2_display_primaries_y[1]) ||
             (ps_sei_mdcv_params->au2_display_primaries_y[2] !=
                                 ps_cfg_sei_mdcv_params->au2_display_primaries_y[2]) ||
             (ps_sei_mdcv_params->u2_white_point_x !=
                                 ps_cfg_sei_mdcv_params->u2_white_point_x) ||
             (ps_sei_mdcv_params->u2_white_point_y !=
                                 ps_cfg_sei_mdcv_params->u2_white_point_y) ||
             (ps_sei_mdcv_params->u4_max_display_mastering_luminance !=
                                 ps_cfg_sei_mdcv_params->u4_max_display_mastering_luminance) ||
             (ps_sei_mdcv_params->u4_min_display_mastering_luminance !=
                                 ps_cfg_sei_mdcv_params->u4_min_display_mastering_luminance))
         {
             ps_codec->s_sei.s_sei_mdcv_params = ps_codec->s_cfg.s_sei.s_sei_mdcv_params;
             ps_codec->s_sei.u1_sei_mdcv_params_present_flag = 1;
         }
         else
         {
             ps_codec->s_sei.u1_sei_mdcv_params_present_flag = 0;
         }
 
         if((ps_sei_cll_params->u2_max_content_light_level !=
                                 ps_cfg_sei_cll_params->u2_max_content_light_level) ||
                 (ps_sei_cll_params->u2_max_pic_average_light_level !=
                                 ps_cfg_sei_cll_params->u2_max_pic_average_light_level))
         {
             ps_codec->s_sei.s_sei_cll_params = ps_codec->s_cfg.s_sei.s_sei_cll_params;
             ps_codec->s_sei.u1_sei_cll_params_present_flag = 1;
         }
         else
         {
             ps_codec->s_sei.u1_sei_cll_params_present_flag = 0;
         }
 
         if((ps_sei_ave_params->u4_ambient_illuminance !=
                                 ps_cfg_sei_ave_params->u4_ambient_illuminance) ||
                 (ps_sei_ave_params->u2_ambient_light_x !=
                                 ps_cfg_sei_ave_params->u2_ambient_light_x) ||
                 (ps_sei_ave_params->u2_ambient_light_y !=
                                 ps_cfg_sei_ave_params->u2_ambient_light_y))
         {
             ps_codec->s_sei.s_sei_ave_params = ps_codec->s_cfg.s_sei.s_sei_ave_params;
             ps_codec->s_sei.u1_sei_ave_params_present_flag = 1;
         }
         else
         {
             ps_codec->s_sei.u1_sei_ave_params_present_flag = 0;
         }
 
+        for(i = 0; i <= ps_cfg_sei_sii_params->u1_sii_max_sub_layers_minus1; i++)
+        {
+            au4_sub_layer_num_units_in_shutter_interval_flag =
+                (au4_sub_layer_num_units_in_shutter_interval_flag ||
+                 (ps_sei_sii_params->au4_sub_layer_num_units_in_shutter_interval[i] !=
+                  ps_cfg_sei_sii_params->au4_sub_layer_num_units_in_shutter_interval[i]));
+        }
+
+        if((ps_sei_sii_params->u4_sii_sub_layer_idx !=
+            ps_cfg_sei_sii_params->u4_sii_sub_layer_idx) ||
+           (ps_sei_sii_params->u1_shutter_interval_info_present_flag !=
+            ps_cfg_sei_sii_params->u1_shutter_interval_info_present_flag) ||
+           (ps_sei_sii_params->u4_sii_time_scale != ps_cfg_sei_sii_params->u4_sii_time_scale) ||
+           (ps_sei_sii_params->u1_fixed_shutter_interval_within_cvs_flag !=
+            ps_cfg_sei_sii_params->u1_fixed_shutter_interval_within_cvs_flag) ||
+           (ps_sei_sii_params->u4_sii_num_units_in_shutter_interval !=
+            ps_cfg_sei_sii_params->u4_sii_num_units_in_shutter_interval) ||
+           (ps_sei_sii_params->u1_sii_max_sub_layers_minus1 !=
+            ps_cfg_sei_sii_params->u1_sii_max_sub_layers_minus1) ||
+           au4_sub_layer_num_units_in_shutter_interval_flag)
+        {
+            ps_codec->s_sei.s_sei_sii_params = ps_codec->s_cfg.s_sei.s_sei_sii_params;
+            ps_codec->s_sei.u1_sei_sii_params_present_flag = 1;
+        }
+        else
+        {
+            ps_codec->s_sei.u1_sei_sii_params_present_flag = 0;
+        }
+
         if((1 == ps_codec->s_sei.u1_sei_mdcv_params_present_flag) ||
                 (1 == ps_codec->s_sei.u1_sei_cll_params_present_flag) ||
-                (1 == ps_codec->s_sei.u1_sei_ave_params_present_flag))
+           (1 == ps_codec->s_sei.u1_sei_ave_params_present_flag) ||
+           (1 == ps_codec->s_sei.u1_sei_sii_params_present_flag))
         {
             ps_codec->force_curr_frame_type = IV_IDR_FRAME;
         }
     }
 #endif
     /******************************************************************
      * INSERT LOGO
      *****************************************************************/
 #ifdef LOGO_EN
     if (s_inp_buf.s_raw_buf.apv_bufs[0] != NULL &&
                     ps_codec->i4_header_mode != 1)
     {
         ih264e_insert_logo(s_inp_buf.s_raw_buf.apv_bufs[0],
                            s_inp_buf.s_raw_buf.apv_bufs[1],
                            s_inp_buf.s_raw_buf.apv_bufs[2],
                            s_inp_buf.s_raw_buf.au4_strd[0],
                            0,
                            0,
                            ps_codec->s_cfg.e_inp_color_fmt,
                            ps_codec->s_cfg.u4_disp_wd,
                            ps_codec->s_cfg.u4_disp_ht);
     }
 #endif /*LOGO_EN*/
 
     /* In case of alt ref and B pics we will have non reference frame in stream */
     if (ps_codec->s_cfg.u4_enable_alt_ref || ps_codec->s_cfg.u4_num_bframes)
     {
         ps_codec->i4_non_ref_frames_in_stream = 1;
     }
 
     if (ps_codec->i4_encode_api_call_cnt == 0)
     {
         /********************************************************************/
         /*   number of mv/ref bank buffers used by the codec,               */
         /*      1 to handle curr frame                                      */
         /*      1 to store information of ref frame                         */
         /*      1 more additional because of the codec employs 2 ctxt sets  */
         /*        to assist asynchronous API                                */
         /********************************************************************/
 
         /* initialize mv bank buffer manager */
         error_status = ih264e_mv_buf_mgr_add_bufs(ps_codec);
         SET_ERROR_ON_RETURN(error_status,
                             IVE_FATALERROR,
                             ps_video_encode_op->s_ive_op.u4_error_code,
                             IV_FAIL);
 
         /* initialize ref bank buffer manager */
         error_status = ih264e_pic_buf_mgr_add_bufs(ps_codec);
         SET_ERROR_ON_RETURN(error_status,
                             IVE_FATALERROR,
                             ps_video_encode_op->s_ive_op.u4_error_code,
                             IV_FAIL);
 
         /* for the first frame, generate header when not requested explicitly */
         if (ps_codec->i4_header_mode == 0 &&
                         ps_codec->u4_header_generated == 0)
         {
             ps_codec->i4_gen_header = 1;
         }
     }
 
     /* generate header and return when encoder is operated in header mode */
     if (ps_codec->i4_header_mode == 1)
     {
         /* whenever the header is generated, this implies a start of sequence
          * and a sequence needs to be started with IDR
          */
         ps_codec->force_curr_frame_type = IV_IDR_FRAME;
 
         /* generate header */
         error_status = ih264e_generate_sps_pps(ps_codec);
 
         /* send the input to app */
         ps_video_encode_op->s_ive_op.s_inp_buf = ps_video_encode_ip->s_ive_ip.s_inp_buf;
         ps_video_encode_op->s_ive_op.u4_timestamp_low = ps_video_encode_ip->s_ive_ip.u4_timestamp_low;
         ps_video_encode_op->s_ive_op.u4_timestamp_high = ps_video_encode_ip->s_ive_ip.u4_timestamp_high;
 
         ps_video_encode_op->s_ive_op.u4_is_last = ps_video_encode_ip->s_ive_ip.u4_is_last;
 
         /* send the output to app */
         ps_video_encode_op->s_ive_op.output_present  = 1;
         ps_video_encode_op->s_ive_op.dump_recon = 0;
         ps_video_encode_op->s_ive_op.s_out_buf = ps_codec->as_out_buf[ctxt_sel].s_bits_buf;
 
         /* error status */
         SET_ERROR_ON_RETURN(error_status,
                             IVE_FATALERROR,
                             ps_video_encode_op->s_ive_op.u4_error_code,
                             IV_FAIL);
 
         /* indicates that header has been generated previously */
         ps_codec->u4_header_generated = 1;
 
         /* api call cnt */
         ps_codec->i4_encode_api_call_cnt --;
 
         /* header mode tag is not sticky */
         ps_codec->i4_header_mode = 0;
         ps_codec->i4_gen_header = 0;
 
         return IV_SUCCESS;
     }
 
     /* curr pic cnt */
      ps_codec->i4_pic_cnt += 1;
 
     i4_rc_pre_enc_skip = 0;
     i4_rc_pre_enc_skip = ih264e_input_queue_update(
                     ps_codec, &ps_video_encode_ip->s_ive_ip, &s_inp_buf);
 
     s_out_buf.u4_is_last = s_inp_buf.u4_is_last;
     ps_video_encode_op->s_ive_op.u4_is_last = s_inp_buf.u4_is_last;
 
     /* Send the input to application so that it can free it */
     ps_video_encode_op->s_ive_op.s_inp_buf = s_inp_buf.s_raw_buf;
 
     /* Only encode if the current frame is not pre-encode skip */
     if (!i4_rc_pre_enc_skip && s_inp_buf.s_raw_buf.apv_bufs[0])
     {
         /* proc ctxt base idx */
         WORD32 proc_ctxt_select = ctxt_sel * MAX_PROCESS_THREADS;
 
         /* proc ctxt */
         process_ctxt_t *ps_proc = &ps_codec->as_process[proc_ctxt_select];
 
         WORD32 ret = 0;
 
         /* number of addl. threads to be created */
         WORD32 num_thread_cnt = ps_codec->s_cfg.u4_num_cores - 1;
 
         /* array giving pic cnt that is being processed in curr context set */
         ps_codec->ai4_pic_cnt[ctxt_sel] = ps_codec->i4_pic_cnt;
 
         /* initialize all relevant process ctxts */
         error_status = ih264e_pic_init(ps_codec, &s_inp_buf);
         SET_ERROR_ON_RETURN(error_status,
                             IVE_FATALERROR,
                             ps_video_encode_op->s_ive_op.u4_error_code,
                             IV_FAIL);
 
         for (i = 0; i < num_thread_cnt; i++)
         {
             ret = ithread_create(ps_codec->apv_proc_thread_handle[i],
                                  NULL,
                                  (void *)ih264e_process_thread,
                                  &ps_codec->as_process[i + 1]);
             if (ret != 0)
             {
                 printf("pthread Create Failed");
                 assert(0);
             }
 
             ps_codec->ai4_process_thread_created[i] = 1;
 
             ps_codec->i4_proc_thread_cnt++;
         }
 
 
         /* launch job */
         ih264e_process_thread(ps_proc);
 
         /* Join threads at the end of encoding a frame */
         ih264e_join_threads(ps_codec);
 
         ih264_list_reset(ps_codec->pv_proc_jobq);
 
         ih264_list_reset(ps_codec->pv_entropy_jobq);
 
         if (ps_codec->s_cfg.u4_enable_quality_metrics & QUALITY_MASK_PSNR)
         {
             ih264e_compute_quality_stats(ps_proc);
         }
 
     }
 
 
    /****************************************************************************
    * RECON
    *    Since we have forward dependent frames, we cannot return recon in encoding
    *    order. It must be in poc order, or input pic order. To achieve this we
    *    introduce a delay of 1 to the recon wrt encode. Now since we have that
    *    delay, at any point minimum of pic_cnt in our ref buffer will be the
    *    correct frame. For ex let our GOP be IBBP [1 2 3 4] . The encode order
    *    will be [1 4 2 3] .Now since we have a delay of 1, when we are done with
    *    encoding 4, the min in the list will be 1. After encoding 2, it will be
    *    2, 3 after 3 and 4 after 4. Hence we can return in sequence. Note
    *    that the 1 delay is critical. Hence if we have post enc skip, we must
    *    skip here too. Note that since post enc skip already frees the recon
    *    buffer we need not do any thing here
    *
    *    We need to return a recon when ever we consume an input buffer. This
    *    comsumption include a pre or post enc skip. Thus dump recon is set for
    *    all cases except when
    *    1) We are waiting -> ps_codec->i4_pic_cnt > ps_codec->s_cfg.u4_num_bframe
    *        An exception need to be made for the case when we have the last buffer
    *        since we need to flush out the on remainig recon.
    ****************************************************************************/
 
     ps_video_encode_op->s_ive_op.dump_recon = 0;
 
     if (ps_codec->s_cfg.u4_enable_recon
                     && (ps_codec->i4_pic_cnt > (WORD32)ps_codec->s_cfg.u4_num_bframes ||
                         s_inp_buf.u4_is_last))
     {
         /* error status */
         IH264_ERROR_T ret = IH264_SUCCESS;
         pic_buf_t *ps_pic_buf = NULL;
         WORD32 i4_buf_status, i4_curr_poc = 32768;
         WORD8 buf_idx = -1;
 
         /* In case of skips we return recon, but indicate that buffer is zero size */
         if (ps_codec->s_rate_control.post_encode_skip[ctxt_sel]
                         || i4_rc_pre_enc_skip)
         {
 
             ps_video_encode_op->s_ive_op.dump_recon = 1;
             ps_video_encode_op->s_ive_op.s_recon_buf.au4_wd[0] = 0;
             ps_video_encode_op->s_ive_op.s_recon_buf.au4_wd[1] = 0;
 
         }
         else
         {
             for (i = 0; i < ps_codec->i4_ref_buf_cnt; i++)
             {
                 if (ps_codec->as_ref_set[i].i4_pic_cnt == -1)
                     continue;
 
                 i4_buf_status = ih264_buf_mgr_get_status(
                                 ps_codec->pv_ref_buf_mgr,
                                 ps_codec->as_ref_set[i].ps_pic_buf->i4_buf_id);
 
                 if ((i4_buf_status & BUF_MGR_IO)
                                 && (ps_codec->as_ref_set[i].i4_poc < i4_curr_poc))
                 {
                     ps_pic_buf = ps_codec->as_ref_set[i].ps_pic_buf;
                     i4_curr_poc = ps_codec->as_ref_set[i].i4_poc;
                     buf_idx = i;
                 }
             }
             if ((ps_codec->s_cfg.u4_enable_quality_metrics & QUALITY_MASK_PSNR)
                                 && buf_idx >= 0)
             {
                 UWORD8 comp;
                 for(comp = 0; comp < 3; comp++)
                 {
                     DEBUG("PSNR[%d]: %f\n", comp,
                         ps_codec->as_ref_set[buf_idx].s_pic_quality_stats.total_psnr[comp]);
                 }
             }
 
             ps_video_encode_op->s_ive_op.s_recon_buf =
                             ps_video_encode_ip->s_ive_ip.s_recon_buf;
 
             /*
              * If we get a valid buffer. output and free recon.
              *
              * we may get an invalid buffer if num_b_frames is 0. This is because
              * We assume that there will be a ref frame in ref list after encoding
              * the last frame. With B frames this is correct since its forward ref
              * pic will be in the ref list. But if num_b_frames is 0, we will not
              * have a forward ref pic
              */
 
             if (ps_pic_buf)
             {
                 /* copy/convert the recon buffer and return */
                 ih264e_fmt_conv(ps_codec,
                                 ps_pic_buf,
                                 ps_video_encode_ip->s_ive_ip.s_recon_buf.apv_bufs[0],
                                 ps_video_encode_ip->s_ive_ip.s_recon_buf.apv_bufs[1],
                                 ps_video_encode_ip->s_ive_ip.s_recon_buf.apv_bufs[2],
                                 ps_video_encode_ip->s_ive_ip.s_recon_buf.au4_wd[0],
                                 ps_video_encode_ip->s_ive_ip.s_recon_buf.au4_wd[1],
                                 0, ps_codec->s_cfg.u4_disp_ht);
 
                 ps_video_encode_op->s_ive_op.dump_recon = 1;
 
                 ret = ih264_buf_mgr_release(ps_codec->pv_ref_buf_mgr,
                                             ps_pic_buf->i4_buf_id, BUF_MGR_IO);
 
                 if (IH264_SUCCESS != ret)
                 {
                     SET_ERROR_ON_RETURN(
                                     (IH264E_ERROR_T)ret, IVE_FATALERROR,
                                     ps_video_encode_op->s_ive_op.u4_error_code,
                                     IV_FAIL);
                 }
             }
         }
     }
 
 
     /***************************************************************************
      * Free reference buffers:
      * In case of a post enc skip, we have to ensure that those pics will not
      * be used as reference anymore. In all other cases we will not even mark
      * the ref buffers
      ***************************************************************************/
     if (ps_codec->s_rate_control.post_encode_skip[ctxt_sel])
     {
         /* pic info */
         pic_buf_t *ps_cur_pic;
 
         /* mv info */
         mv_buf_t *ps_cur_mv_buf;
 
         /* error status */
         IH264_ERROR_T ret = IH264_SUCCESS;
 
         /* Decrement coded pic count */
         ps_codec->i4_poc--;
 
         /* loop through to get the min pic cnt among the list of pics stored in ref list */
         /* since the skipped frame may not be on reference list, we may not have an MV bank
          * hence free only if we have allocated */
         for (i = 0; i < ps_codec->i4_ref_buf_cnt; i++)
         {
             if (ps_codec->i4_pic_cnt == ps_codec->as_ref_set[i].i4_pic_cnt)
             {
 
                 ps_cur_pic = ps_codec->as_ref_set[i].ps_pic_buf;
 
                 ps_cur_mv_buf = ps_codec->as_ref_set[i].ps_mv_buf;
 
                 /* release this frame from reference list and recon list */
                 ret = ih264_buf_mgr_release(ps_codec->pv_mv_buf_mgr, ps_cur_mv_buf->i4_buf_id , BUF_MGR_REF);
                 ret |= ih264_buf_mgr_release(ps_codec->pv_mv_buf_mgr, ps_cur_mv_buf->i4_buf_id , BUF_MGR_IO);
                 SET_ERROR_ON_RETURN((IH264E_ERROR_T)ret,
                                     IVE_FATALERROR,
                                     ps_video_encode_op->s_ive_op.u4_error_code,
                                     IV_FAIL);
 
                 ret = ih264_buf_mgr_release(ps_codec->pv_ref_buf_mgr, ps_cur_pic->i4_buf_id , BUF_MGR_REF);
                 ret |= ih264_buf_mgr_release(ps_codec->pv_ref_buf_mgr, ps_cur_pic->i4_buf_id , BUF_MGR_IO);
                 SET_ERROR_ON_RETURN((IH264E_ERROR_T)ret,
                                     IVE_FATALERROR,
                                     ps_video_encode_op->s_ive_op.u4_error_code,
                                     IV_FAIL);
                 break;
             }
         }
     }
 
     /*
      * Since recon is not in sync with output, ie there can be frame to be
      * given back as recon even after last output. Hence we need to mark that
      * the output is not the last.
      * Hence search through reflist and mark appropriately
      */
     if (ps_codec->s_cfg.u4_enable_recon)
     {
         WORD32 i4_buf_status = 0;
 
         for (i = 0; i < ps_codec->i4_ref_buf_cnt; i++)
         {
             if (ps_codec->as_ref_set[i].i4_pic_cnt == -1)
                 continue;
 
             i4_buf_status |= ih264_buf_mgr_get_status(
                             ps_codec->pv_ref_buf_mgr,
                             ps_codec->as_ref_set[i].ps_pic_buf->i4_buf_id);
         }
 
         if (i4_buf_status & BUF_MGR_IO)
         {
             s_out_buf.u4_is_last = 0;
             ps_video_encode_op->s_ive_op.u4_is_last = 0;
         }
     }
 
 
     /**************************************************************************
      * Signaling to APP
      *  1) If we valid a valid output mark it so
      *  2) Set the codec output ps_video_encode_op
      *  3) Set the error status
      *  4) Set the return Pic type
      *      Note that we already has marked recon properly
      *  5)Send the consumed input back to app so that it can free it if possible
      *
      *  We will have to return the output and input buffers unconditionally
      *  so that app can release them
      **************************************************************************/
     if (!i4_rc_pre_enc_skip
                     && !ps_codec->s_rate_control.post_encode_skip[ctxt_sel]
                     && s_inp_buf.s_raw_buf.apv_bufs[0])
     {
 
         /* receive output back from codec */
         s_out_buf = ps_codec->as_out_buf[ctxt_sel];
 
         /* send the output to app */
         ps_video_encode_op->s_ive_op.output_present  = 1;
         ps_video_encode_op->s_ive_op.u4_error_code = IV_SUCCESS;
 
         /* Set the time stamps of the encodec input */
         ps_video_encode_op->s_ive_op.u4_timestamp_low = s_inp_buf.u4_timestamp_low;
         ps_video_encode_op->s_ive_op.u4_timestamp_high = s_inp_buf.u4_timestamp_high;
 
 
         switch (ps_codec->pic_type)
         {
             case PIC_IDR:
                 ps_video_encode_op->s_ive_op.u4_encoded_frame_type =IV_IDR_FRAME;
                 break;
 
             case PIC_I:
                 ps_video_encode_op->s_ive_op.u4_encoded_frame_type = IV_I_FRAME;
                 break;
 
             case PIC_P:
                 ps_video_encode_op->s_ive_op.u4_encoded_frame_type = IV_P_FRAME;
                 break;
 
             case PIC_B:
                 ps_video_encode_op->s_ive_op.u4_encoded_frame_type = IV_B_FRAME;
                 break;
 
             default:
                 ps_video_encode_op->s_ive_op.u4_encoded_frame_type = IV_NA_FRAME;
                 break;
         }
 
         for (i = 0; i < (WORD32)ps_codec->s_cfg.u4_num_cores; i++)
         {
             error_status = ps_codec->as_process[ctxt_sel + i].i4_error_code;
             SET_ERROR_ON_RETURN(error_status,
                                 IVE_FATALERROR,
                                 ps_video_encode_op->s_ive_op.u4_error_code,
                                 IV_FAIL);
         }
     }
     else
     {
         /* receive output back from codec */
         s_out_buf = ps_codec->as_out_buf[ctxt_sel];
 
         ps_video_encode_op->s_ive_op.output_present = 0;
         ps_video_encode_op->s_ive_op.u4_error_code = IV_SUCCESS;
 
         /* Set the time stamps of the encodec input */
         ps_video_encode_op->s_ive_op.u4_timestamp_low = 0;
         ps_video_encode_op->s_ive_op.u4_timestamp_high = 0;
 
         ps_video_encode_op->s_ive_op.u4_encoded_frame_type =  IV_NA_FRAME;
 
     }
 
     ps_video_encode_op->s_ive_op.s_out_buf = s_out_buf.s_bits_buf;
 
     return IV_SUCCESS;
 }
diff --git a/encoder/ih264e_encode_header.c b/encoder/ih264e_encode_header.c
index 16cf28e..4eb0017 100644
--- a/encoder/ih264e_encode_header.c
+++ b/encoder/ih264e_encode_header.c
@@ -706,119 +706,129 @@ WORD32 ih264e_generate_pps(bitstrm_t *ps_bitstrm, pps_t *ps_pps, sps_t *ps_sps)
 /**
 ******************************************************************************
 *
 * @brief Generates SEI (Supplemental Enhancement Information)
 *
 * @par   Description
 *  This function generates Supplemental Enhancement Information header as per the spec
 *
 * @param[in]   ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 * @param[in]   ps_sei
 *  pointer to structure containing SEI data
 *
 * @return      success or failure error code
 *
 ******************************************************************************
 */
 IH264E_ERROR_T ih264e_generate_sei(bitstrm_t *ps_bitstrm, sei_params_t *ps_sei,
                                                         UWORD32 u4_insert_per_idr)
 {
     WORD32 return_status = IH264E_SUCCESS;
     WORD8  i1_nal_unit_type = NAL_SEI;
     WORD8  i1_nal_ref_idc = 0;
 
     /* Insert Start Code */
     return_status = ih264e_put_nal_start_code_prefix(ps_bitstrm, 1);
     if(return_status != IH264E_SUCCESS)
     {
         return return_status;
     }
 
     /* Insert Nal Unit Header */
     return_status = ih264e_generate_nal_unit_header(ps_bitstrm,
                                                     i1_nal_unit_type, i1_nal_ref_idc);
     if(return_status != IH264E_SUCCESS)
     {
         return return_status;
     }
     /* Mastering Display Color SEI */
     if(1 == ps_sei->u1_sei_mdcv_params_present_flag && u4_insert_per_idr)
     {
         return_status = ih264e_put_sei_msg(IH264_SEI_MASTERING_DISP_COL_VOL,
                                             ps_sei, ps_bitstrm);
         if(return_status != IH264E_SUCCESS)
         {
             return return_status;
         }
     }
 
     /* Content Light Level Information*/
     if(1 == ps_sei->u1_sei_cll_params_present_flag && u4_insert_per_idr)
     {
         return_status = ih264e_put_sei_msg(IH264_SEI_CONTENT_LIGHT_LEVEL_DATA,
                                             ps_sei, ps_bitstrm);
         if(return_status != IH264E_SUCCESS)
         {
             return return_status;
         }
     }
 
     /* Ambient viewing environment SEI */
     if(1 == ps_sei->u1_sei_ave_params_present_flag && u4_insert_per_idr)
     {
         return_status = ih264e_put_sei_msg(IH264_SEI_AMBIENT_VIEWING_ENVIRONMENT,
                                             ps_sei, ps_bitstrm);
         if(return_status != IH264E_SUCCESS)
         {
             return return_status;
         }
     }
 
     /* Content color volume Information*/
     if(1 == ps_sei->u1_sei_ccv_params_present_flag)
     {
         return_status = ih264e_put_sei_msg(IH264_SEI_CONTENT_COLOR_VOLUME,
                                             ps_sei, ps_bitstrm);
         if(return_status != IH264E_SUCCESS)
         {
             return return_status;
         }
     }
 
+    /* Shutter Interval Information*/
+    if(1 == ps_sei->u1_sei_sii_params_present_flag)
+    {
+        return_status = ih264e_put_sei_msg(IH264_SEI_SHUTTER_INTERVAL_INFO, ps_sei, ps_bitstrm);
+        if(return_status != IH264E_SUCCESS)
+        {
+            return return_status;
+        }
+    }
+
     /* rbsp trailing bits */
     return_status = ih264e_put_rbsp_trailing_bits(ps_bitstrm);
 
     return return_status;
 }
 
 /**
 ******************************************************************************
 *
 * @brief Generates Slice Header
 *
 * @par   Description
 *  Generate Slice Header as per Section 7.3.5.1
 *
 * @param[inout]   ps_bitstrm
 *  pointer to bitstream context for generating slice header
 *
 * @param[in]   ps_slice_hdr
 *  pointer to slice header params
 *
 * @param[in]   ps_pps
 *  pointer to pps params referred by slice
 *
 * @param[in]   ps_sps
 *  pointer to sps params referred by slice
 *
 * @param[out]   ps_dup_bit_strm_ent_offset
 *  Bitstream struct to store bitstream state
 *
 * @param[out]   pu4_first_slice_start_offset
 *  first slice offset is returned
 *
 * @return      success or failure error code
 *
 ******************************************************************************
 */
diff --git a/encoder/ih264e_error.h b/encoder/ih264e_error.h
index c11d857..a460e5a 100644
--- a/encoder/ih264e_error.h
+++ b/encoder/ih264e_error.h
@@ -54,197 +54,203 @@
 /**
 ******************************************************************************
  *  @brief   Extended error code for each error in  H264 encoder
 ******************************************************************************
  */
 typedef enum
 {
     /* NOTE: the ive error codes ends at 0x80 */
     IVE_ERR_CODEC_EXTENSIONS                                        = 0x80,
 
     /* bit stream error start */
     IH264E_BITSTREAM_ERROR_START                                    = IVE_ERR_CODEC_EXTENSIONS,
 
     /* codec error start */
     IH264E_CODEC_ERROR_START                                        = IH264E_BITSTREAM_ERROR_START + 0x10,
 
     /** no error */
     IH264E_SUCCESS                                                  = 0,
 
     /** bitstream init failure, buffer ptr not aligned to WORD (32bits)     */
     IH264E_BITSTREAM_BUFPTR_ALIGN_FAIL                              = IH264E_BITSTREAM_ERROR_START + 0x01,
 
     /** bitstream init failure, buf size not multiple of WORD size (32bits) */
     IH264E_BITSTREAM_BUFSIZE_ALIGN_FAIL                             = IH264E_BITSTREAM_ERROR_START + 0x02,
 
     /** bitstream runtime failure, buf size limit exceeded during encode    */
     IH264E_BITSTREAM_BUFFER_OVERFLOW                                = IH264E_BITSTREAM_ERROR_START + 0x03,
 
     /**width not set within supported limit */
     IH264E_WIDTH_NOT_SUPPORTED                                      = IH264E_CODEC_ERROR_START + 0x01,
 
     /**height not set within supported limit */
     IH264E_HEIGHT_NOT_SUPPORTED                                     = IH264E_CODEC_ERROR_START + 0x02,
 
     /**Unsupported number of reference pictures passed as an argument */
     IH264E_NUM_REF_UNSUPPORTED                                      = IH264E_CODEC_ERROR_START + 0x03,
 
     /**Unsupported number of reference pictures passed as an argument */
     IH264E_NUM_REORDER_UNSUPPORTED                                  = IH264E_CODEC_ERROR_START + 0x04,
 
     /**codec level not supported */
     IH264E_CODEC_LEVEL_NOT_SUPPORTED                                = IH264E_CODEC_ERROR_START + 0x05,
 
     /**input chroma format not supported */
     IH264E_INPUT_CHROMA_FORMAT_NOT_SUPPORTED                        = IH264E_CODEC_ERROR_START + 0x06,
 
     /**recon chroma format not supported */
     IH264E_RECON_CHROMA_FORMAT_NOT_SUPPORTED                        = IH264E_CODEC_ERROR_START + 0x07,
 
     /**rate control option configured is not supported */
     IH264E_RATE_CONTROL_MODE_NOT_SUPPORTED                          = IH264E_CODEC_ERROR_START + 0x08,
 
     /**frame rate configured is not supported */
     IH264E_FRAME_RATE_NOT_SUPPORTED                                 = IH264E_CODEC_ERROR_START + 0x09,
 
     /**bit rate configured is not supported */
     IH264E_BITRATE_NOT_SUPPORTED                                    = IH264E_CODEC_ERROR_START + 0x0A,
 
     /**frame rate not supported */
     IH264E_BFRAMES_NOT_SUPPORTED                                    = IH264E_CODEC_ERROR_START + 0x0B,
 
     /**content type not supported */
     IH264E_CONTENT_TYPE_NOT_SUPPORTED                               = IH264E_CODEC_ERROR_START + 0x0C,
 
     /**unsupported horizontal search range */
     IH264E_HORIZONTAL_SEARCH_RANGE_NOT_SUPPORTED                    = IH264E_CODEC_ERROR_START + 0x0D,
 
     /**unsupported vertical search range */
     IH264E_VERTICAL_SEARCH_RANGE_NOT_SUPPORTED                      = IH264E_CODEC_ERROR_START + 0x0E,
 
     /**Unsupported slice type input */
     IH264E_SLICE_TYPE_INPUT_INVALID                                 = IH264E_CODEC_ERROR_START + 0x0F,
 
     /**unsupported architecture type */
     IH264E_ARCH_TYPE_NOT_SUPPORTED                                  = IH264E_CODEC_ERROR_START + 0x10,
 
     /**unsupported soc type */
     IH264E_SOC_TYPE_NOT_SUPPORTED                                   = IH264E_CODEC_ERROR_START + 0x11,
 
     /**target frame rate exceeds source frame rate */
     IH264E_TGT_FRAME_RATE_EXCEEDS_SRC_FRAME_RATE                    = IH264E_CODEC_ERROR_START + 0x12,
 
     /**invalid force frame input */
     IH264E_INVALID_FORCE_FRAME_INPUT                                = IH264E_CODEC_ERROR_START + 0x13,
 
     /**invalid me speed preset */
     IH264E_INVALID_ME_SPEED_PRESET                                  = IH264E_CODEC_ERROR_START + 0x14,
 
     /**invalid encoder speed preset */
     IH264E_INVALID_ENC_SPEED_PRESET                                 = IH264E_CODEC_ERROR_START + 0x15,
 
     /**invalid deblocking param */
     IH264E_INVALID_DEBLOCKING_TYPE_INPUT                            = IH264E_CODEC_ERROR_START + 0x16,
 
     /**invalid max qp */
     IH264E_INVALID_MAX_FRAME_QP                                     = IH264E_CODEC_ERROR_START + 0x17,
 
     /**invalid min qp */
     IH264E_INVALID_MIN_FRAME_QP                                     = IH264E_CODEC_ERROR_START + 0x18,
 
     /**invalid init qp */
     IH264E_INVALID_INIT_QP                                          = IH264E_CODEC_ERROR_START + 0x19,
 
     /**version buffer size is insufficient */
     IH264E_CXA_VERS_BUF_INSUFFICIENT                                = IH264E_CODEC_ERROR_START + 0x1A,
 
     /**init not done */
     IH264E_INIT_NOT_DONE                                            = IH264E_CODEC_ERROR_START + 0x1B,
 
     /**invalid refresh type input */
     IH264E_INVALID_AIR_MODE                                         = IH264E_CODEC_ERROR_START + 0x1C,
 
     /** Unsupported air mode */
     IH264E_INVALID_AIR_REFRESH_PERIOD                               = IH264E_CODEC_ERROR_START + 0x1D,
 
     /**In sufficient memory allocated for MV Bank */
     IH264E_INSUFFICIENT_MEM_MVBANK                                  = IH264E_CODEC_ERROR_START + 0x1E,
 
     /**In sufficient memory allocated for MV Bank */
     IH264E_INSUFFICIENT_MEM_PICBUF                                  = IH264E_CODEC_ERROR_START + 0x1F,
 
     /**Buffer manager error */
     IH264E_BUF_MGR_ERROR                                            = IH264E_CODEC_ERROR_START + 0x20,
 
     /**No free MV Bank buffer available to store current pic */
     IH264E_NO_FREE_MVBANK                                           = IH264E_CODEC_ERROR_START + 0x21,
 
     /**No free picture buffer available to store current pic */
     IH264E_NO_FREE_PICBUF                                           = IH264E_CODEC_ERROR_START + 0x22,
 
     /**Invalid encoder operation mode */
     IH264E_INVALID_ENC_OPERATION_MODE                               = IH264E_CODEC_ERROR_START + 0x23,
 
     /**Invalid half pel option */
     IH264E_INVALID_HALFPEL_OPTION                                   = IH264E_CODEC_ERROR_START + 0x24,
 
     /**Invalid quarter pel option */
     IH264E_INVALID_QPEL_OPTION                                      = IH264E_CODEC_ERROR_START + 0x25,
 
     /**Invalid fast sad option */
     IH264E_INVALID_FAST_SAD_OPTION                                  = IH264E_CODEC_ERROR_START + 0x26,
 
     /**Invalid intra 4x4 option */
     IH264E_INVALID_INTRA4x4_OPTION                                  = IH264E_CODEC_ERROR_START + 0x27,
 
     /**Invalid intra frame interval */
     IH264E_INVALID_INTRA_FRAME_INTERVAL                             = IH264E_CODEC_ERROR_START + 0x28,
 
     /**Invalid idr frame interval */
     IH264E_INVALID_IDR_FRAME_INTERVAL                               = IH264E_CODEC_ERROR_START + 0x29,
 
     /**Invalid buffer delay */
     IH264E_INVALID_BUFFER_DELAY                                     = IH264E_CODEC_ERROR_START + 0x2A,
 
     /**Invalid num cores */
     IH264E_INVALID_NUM_CORES                                        = IH264E_CODEC_ERROR_START + 0x2B,
 
     /**profile not supported */
     IH264E_PROFILE_NOT_SUPPORTED                                    = IH264E_CODEC_ERROR_START + 0x2C,
 
     /**Unsupported slice type input */
     IH264E_SLICE_PARAM_INPUT_INVALID                                = IH264E_CODEC_ERROR_START + 0x2D,
 
     /**Invalid alt ref option */
     IH264E_INVALID_ALT_REF_OPTION                                   = IH264E_CODEC_ERROR_START + 0x2E,
 
     /**No free picture buffer available to store recon pic */
     IH264E_NO_FREE_RECONBUF                                         = IH264E_CODEC_ERROR_START + 0x2F,
 
     /**Not enough memory allocated as output buffer */
     IH264E_INSUFFICIENT_OUTPUT_BUFFER                               = IH264E_CODEC_ERROR_START + 0x30,
 
     /**Invalid entropy coding mode */
     IH264E_INVALID_ENTROPY_CODING_MODE                              = IH264E_CODEC_ERROR_START + 0x31,
 
     /**Invalid Constrained Intra prediction mode */
     IH264E_INVALID_CONSTRAINED_INTRA_PREDICTION_MODE                = IH264E_CODEC_ERROR_START + 0x32,
 
     /**Invalid mastering display color volume sei params */
     IH264E_INVALID_SEI_MDCV_PARAMS                                  = IH264E_CODEC_ERROR_START + 0x33,
 
     /**Invalid content light level sei params */
     IH264E_INVALID_SEI_CLL_PARAMS                                   = IH264E_CODEC_ERROR_START + 0x34,
 
     /**Invalid ambient viewing environment sei params */
     IH264E_INVALID_SEI_AVE_PARAMS                                   = IH264E_CODEC_ERROR_START + 0x35,
 
     /**Invalid content color volume sei params */
     IH264E_INVALID_SEI_CCV_PARAMS                                   = IH264E_CODEC_ERROR_START + 0x36,
 
+    /**Invalid shutter interval info sei params */
+    IH264E_INVALID_SEI_SII_PARAMS = IH264E_CODEC_ERROR_START + 0x37,
+
+    /**Invalid shutter interval info sei params. Does not match H264 sii spec requirements*/
+    IH264E_SEI_SII_FAILED_TO_MATCH_SPEC_COND = IH264E_CODEC_ERROR_START + 0x38,
+
     /**max failure error code to ensure enum is 32 bits wide */
     IH264E_FAIL                                                     = -1,
 
 }IH264E_ERROR_T;
 
 
 #endif /* IH264E_ERROR_H_ */
diff --git a/encoder/ih264e_process.c b/encoder/ih264e_process.c
index 0381dec..71bc567 100644
--- a/encoder/ih264e_process.c
+++ b/encoder/ih264e_process.c
@@ -279,426 +279,429 @@ IH264E_ERROR_T ih264e_init_entropy_ctxt(process_ctxt_t *ps_proc)
 IH264E_ERROR_T ih264e_entropy(process_ctxt_t *ps_proc)
 {
     /* codec context */
     codec_t *ps_codec = ps_proc->ps_codec;
 
     /* entropy context */
     entropy_ctxt_t *ps_entropy = &ps_proc->s_entropy;
 
     /* cabac context */
     cabac_ctxt_t *ps_cabac_ctxt = ps_entropy->ps_cabac;
 
     /* sps */
     sps_t *ps_sps = ps_entropy->ps_sps_base + (ps_entropy->u4_sps_id % MAX_SPS_CNT);
 
     /* pps */
     pps_t *ps_pps = ps_entropy->ps_pps_base + (ps_entropy->u4_pps_id % MAX_PPS_CNT);
 
     /* slice header */
     slice_header_t *ps_slice_hdr = ps_entropy->ps_slice_hdr_base + (ps_entropy->i4_cur_slice_idx % MAX_SLICE_HDR_CNT);
 
     /* slice type */
     WORD32 i4_slice_type = ps_proc->i4_slice_type;
 
     /* Bitstream structure */
     bitstrm_t *ps_bitstrm = ps_entropy->ps_bitstrm;
 
     /* output buff */
     out_buf_t s_out_buf;
 
     /* sei params */
     sei_params_t s_sei;
 
     /* proc map */
     UWORD8  *pu1_proc_map;
 
     /* entropy map */
     UWORD8  *pu1_entropy_map_curr;
 
     /* proc base idx */
     WORD32 ctxt_sel = ps_proc->i4_encode_api_call_cnt % MAX_CTXT_SETS;
 
     /* temp var */
     WORD32 i4_wd_mbs, i4_ht_mbs;
     UWORD32 u4_mb_cnt, u4_mb_idx, u4_mb_end_idx, u4_insert_per_idr;
     WORD32 bitstream_start_offset, bitstream_end_offset;
     /********************************************************************/
     /*                            BEGIN INIT                            */
     /********************************************************************/
 
     /* entropy encode start address */
     u4_mb_idx = ps_entropy->i4_mb_start_add;
 
     /* entropy encode end address */
     u4_mb_end_idx = ps_entropy->i4_mb_end_add;
 
     /* width in mbs */
     i4_wd_mbs = ps_entropy->i4_wd_mbs;
 
     /* height in mbs */
     i4_ht_mbs = ps_entropy->i4_ht_mbs;
 
     /* total mb cnt */
     u4_mb_cnt = i4_wd_mbs * i4_ht_mbs;
 
     /* proc map */
     pu1_proc_map = ps_proc->pu1_proc_map + ps_entropy->i4_mb_y * i4_wd_mbs;
 
     /* entropy map */
     pu1_entropy_map_curr = ps_entropy->pu1_entropy_map + ps_entropy->i4_mb_y * i4_wd_mbs;
 
     /********************************************************************/
     /* @ start of frame / slice,                                        */
     /*      initialize the output buffer,                               */
     /*      initialize the bit stream buffer,                           */
     /*      check if sps and pps headers have to be generated,          */
     /*      populate and generate slice header                          */
     /********************************************************************/
     if (ps_entropy->i4_sof)
     {
         /********************************************************************/
         /*      initialize the output buffer                                */
         /********************************************************************/
         s_out_buf = ps_codec->as_out_buf[ctxt_sel];
 
         /* is last frame to encode */
         s_out_buf.u4_is_last = ps_entropy->u4_is_last;
 
         /* frame idx */
         s_out_buf.u4_timestamp_high = ps_entropy->u4_timestamp_high;
         s_out_buf.u4_timestamp_low = ps_entropy->u4_timestamp_low;
 
         /********************************************************************/
         /*      initialize the bit stream buffer                            */
         /********************************************************************/
         ih264e_bitstrm_init(ps_bitstrm, s_out_buf.s_bits_buf.pv_buf, s_out_buf.s_bits_buf.u4_bufsize);
 
         /********************************************************************/
         /*                    BEGIN HEADER GENERATION                       */
         /********************************************************************/
         if (1 == ps_entropy->i4_gen_header)
         {
             /* generate sps */
             ps_entropy->i4_error_code = ih264e_generate_sps(ps_bitstrm, ps_sps,
                                                              &ps_codec->s_cfg.s_vui);
             RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
             /* generate pps */
             ps_entropy->i4_error_code = ih264e_generate_pps(ps_bitstrm, ps_pps, ps_sps);
             RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
 
             /* reset i4_gen_header */
             ps_entropy->i4_gen_header = 0;
         }
 
         /* populate slice header */
         ih264e_populate_slice_header(ps_proc, ps_slice_hdr, ps_pps, ps_sps);
 
         /* generate sei */
         u4_insert_per_idr = (NAL_SLICE_IDR == ps_slice_hdr->i1_nal_unit_type);
 
         memset(&s_sei, 0, sizeof(sei_params_t));
         s_sei.u1_sei_mdcv_params_present_flag =
                     ps_codec->s_cfg.s_sei.u1_sei_mdcv_params_present_flag;
         s_sei.s_sei_mdcv_params = ps_codec->s_cfg.s_sei.s_sei_mdcv_params;
         s_sei.u1_sei_cll_params_present_flag =
                     ps_codec->s_cfg.s_sei.u1_sei_cll_params_present_flag;
         s_sei.s_sei_cll_params = ps_codec->s_cfg.s_sei.s_sei_cll_params;
         s_sei.u1_sei_ave_params_present_flag =
                     ps_codec->s_cfg.s_sei.u1_sei_ave_params_present_flag;
         s_sei.s_sei_ave_params = ps_codec->s_cfg.s_sei.s_sei_ave_params;
         s_sei.u1_sei_ccv_params_present_flag = 0;
         s_sei.s_sei_ccv_params =
                     ps_codec->as_inp_list[ps_codec->i4_poc % MAX_NUM_BFRAMES].s_sei_ccv;
+        s_sei.u1_sei_sii_params_present_flag = ps_codec->s_cfg.s_sei.u1_sei_sii_params_present_flag;
+        s_sei.s_sei_sii_params = ps_codec->s_cfg.s_sei.s_sei_sii_params;
 
         if((1 == ps_sps->i1_vui_parameters_present_flag) &&
            (1 == ps_codec->s_cfg.s_vui.u1_video_signal_type_present_flag) &&
            (1 == ps_codec->s_cfg.s_vui.u1_colour_description_present_flag) &&
            (2 != ps_codec->s_cfg.s_vui.u1_colour_primaries) &&
            (2 != ps_codec->s_cfg.s_vui.u1_matrix_coefficients) &&
            (2 != ps_codec->s_cfg.s_vui.u1_transfer_characteristics) &&
            (4 != ps_codec->s_cfg.s_vui.u1_transfer_characteristics) &&
            (5 != ps_codec->s_cfg.s_vui.u1_transfer_characteristics))
         {
             s_sei.u1_sei_ccv_params_present_flag =
             ps_codec->as_inp_list[ps_codec->i4_poc % MAX_NUM_BFRAMES].u1_sei_ccv_params_present_flag;
         }
 
         if((1 == s_sei.u1_sei_mdcv_params_present_flag && u4_insert_per_idr) ||
            (1 == s_sei.u1_sei_cll_params_present_flag && u4_insert_per_idr) ||
            (1 == s_sei.u1_sei_ave_params_present_flag && u4_insert_per_idr) ||
-           (1 == s_sei.u1_sei_ccv_params_present_flag))
+           (1 == s_sei.u1_sei_ccv_params_present_flag) ||
+           (1 == s_sei.u1_sei_sii_params_present_flag))
         {
             ps_entropy->i4_error_code =
                     ih264e_generate_sei(ps_bitstrm, &s_sei, u4_insert_per_idr);
             RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
         }
         ps_codec->as_inp_list[ps_codec->i4_poc % MAX_NUM_BFRAMES].u1_sei_ccv_params_present_flag = 0;
 
         /* generate slice header */
         ps_entropy->i4_error_code = ih264e_generate_slice_header(ps_bitstrm, ps_slice_hdr,
                                                                   ps_pps, ps_sps);
         RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
         /* once start of frame / slice is done, you can reset it */
         /* it is the responsibility of the caller to set this flag */
         ps_entropy->i4_sof = 0;
 
         if (CABAC == ps_entropy->u1_entropy_coding_mode_flag)
         {
             BITSTREAM_BYTE_ALIGN(ps_bitstrm);
             BITSTREAM_FLUSH(ps_bitstrm, ps_entropy->i4_error_code);
             ih264e_init_cabac_ctxt(ps_entropy);
         }
     }
 
     /* begin entropy coding for the mb set */
     while (u4_mb_idx < u4_mb_end_idx)
     {
         /* init ptrs/indices */
         if (ps_entropy->i4_mb_x == i4_wd_mbs)
         {
             ps_entropy->i4_mb_y++;
             ps_entropy->i4_mb_x = 0;
 
             /* packed mb coeff data */
             ps_entropy->pv_mb_coeff_data = ((UWORD8 *)ps_entropy->pv_pic_mb_coeff_data) +
                             ps_entropy->i4_mb_y * ps_codec->u4_size_coeff_data;
 
             /* packed mb header data */
             ps_entropy->pv_mb_header_data = ((UWORD8 *)ps_entropy->pv_pic_mb_header_data) +
                             ps_entropy->i4_mb_y * ps_codec->u4_size_header_data;
 
             /* proc map */
             pu1_proc_map = ps_proc->pu1_proc_map + ps_entropy->i4_mb_y * i4_wd_mbs;
 
             /* entropy map */
             pu1_entropy_map_curr = ps_entropy->pu1_entropy_map + ps_entropy->i4_mb_y * i4_wd_mbs;
         }
 
         DEBUG("\nmb indices x, y %d, %d", ps_entropy->i4_mb_x, ps_entropy->i4_mb_y);
         ENTROPY_TRACE("mb index x %d", ps_entropy->i4_mb_x);
         ENTROPY_TRACE("mb index y %d", ps_entropy->i4_mb_y);
 
         /* wait until the curr mb is core coded */
         /* The wait for curr mb to be core coded is essential when entropy is launched
          * as a separate job
          */
         while (1)
         {
             volatile UWORD8 *pu1_buf1;
             WORD32 idx = ps_entropy->i4_mb_x;
 
             pu1_buf1 = pu1_proc_map + idx;
             if (*pu1_buf1)
                 break;
             ithread_yield();
         }
 
 
         /* write mb layer */
         ps_entropy->i4_error_code = ps_codec->pf_write_mb_syntax_layer
                         [ps_entropy->u1_entropy_coding_mode_flag][i4_slice_type](ps_entropy);
         RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
 
         /* Starting bitstream offset for header in bits */
         bitstream_start_offset = GET_NUM_BITS(ps_bitstrm);
 
         /* set entropy map */
         pu1_entropy_map_curr[ps_entropy->i4_mb_x] = 1;
 
         u4_mb_idx++;
         ps_entropy->i4_mb_x++;
         /* check for eof */
         if (CABAC == ps_entropy->u1_entropy_coding_mode_flag)
         {
             if (ps_entropy->i4_mb_x < i4_wd_mbs)
             {
                 ih264e_cabac_encode_terminate(ps_cabac_ctxt, 0);
             }
         }
 
         if (ps_entropy->i4_mb_x == i4_wd_mbs)
         {
             /* if slices are enabled */
             if (ps_codec->s_cfg.e_slice_mode == IVE_SLICE_MODE_BLOCKS)
             {
                 /* current slice index */
                 WORD32 i4_curr_slice_idx = ps_entropy->i4_cur_slice_idx;
 
                 /* slice map */
                 UWORD8 *pu1_slice_idx = ps_entropy->pu1_slice_idx;
 
                 /* No need to open a slice at end of frame. The current slice can be closed at the time
                  * of signaling eof flag.
                  */
                 if ((u4_mb_idx != u4_mb_cnt) && (i4_curr_slice_idx
                                                 != pu1_slice_idx[u4_mb_idx]))
                 {
                     if (CAVLC == ps_entropy->u1_entropy_coding_mode_flag)
                     { /* mb skip run */
                         if ((i4_slice_type != ISLICE)
                                         && *ps_entropy->pi4_mb_skip_run)
                         {
                             if (*ps_entropy->pi4_mb_skip_run)
                             {
                                 PUT_BITS_UEV(ps_bitstrm, *ps_entropy->pi4_mb_skip_run,
                                             ps_entropy->i4_error_code, "mb skip run");
                                 *ps_entropy->pi4_mb_skip_run = 0;
                                 RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
                             }
                         }
                         /* put rbsp trailing bits for the previous slice */
                         ps_entropy->i4_error_code = ih264e_put_rbsp_trailing_bits(ps_bitstrm);
                         RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
                     }
                     else
                     {
                         ih264e_cabac_encode_terminate(ps_cabac_ctxt, 1);
                     }
 
                     /* update slice header pointer */
                     i4_curr_slice_idx = pu1_slice_idx[u4_mb_idx];
                     ps_entropy->i4_cur_slice_idx = i4_curr_slice_idx;
                     ps_slice_hdr = ps_entropy->ps_slice_hdr_base+ (i4_curr_slice_idx % MAX_SLICE_HDR_CNT);
 
                     /* populate slice header */
                     ps_entropy->i4_mb_start_add = u4_mb_idx;
                     ih264e_populate_slice_header(ps_proc, ps_slice_hdr, ps_pps,
                                                  ps_sps);
 
                     /* generate slice header */
                     ps_entropy->i4_error_code = ih264e_generate_slice_header(
                                     ps_bitstrm, ps_slice_hdr, ps_pps, ps_sps);
                     RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
                     if (CABAC == ps_entropy->u1_entropy_coding_mode_flag)
                     {
                         BITSTREAM_BYTE_ALIGN(ps_bitstrm);
                         BITSTREAM_FLUSH(ps_bitstrm, ps_entropy->i4_error_code);
                         ih264e_init_cabac_ctxt(ps_entropy);
                     }
                 }
                 else
                 {
                     if (CABAC == ps_entropy->u1_entropy_coding_mode_flag
                                     && u4_mb_idx != u4_mb_cnt)
                     {
                         ih264e_cabac_encode_terminate(ps_cabac_ctxt, 0);
                     }
                 }
             }
         }
 
         /* Ending bitstream offset for header in bits */
         bitstream_end_offset = GET_NUM_BITS(ps_bitstrm);
         ps_entropy->u4_header_bits[i4_slice_type == PSLICE] +=
                         bitstream_end_offset - bitstream_start_offset;
     }
 
     /* check for eof */
     if (u4_mb_idx == u4_mb_cnt)
     {
         /* set end of frame flag */
         ps_entropy->i4_eof = 1;
     }
     else
     {
         if (CABAC == ps_entropy->u1_entropy_coding_mode_flag
                         && ps_codec->s_cfg.e_slice_mode
                                         != IVE_SLICE_MODE_BLOCKS)
         {
             ih264e_cabac_encode_terminate(ps_cabac_ctxt, 0);
         }
     }
 
     if (ps_entropy->i4_eof)
     {
         if (CAVLC == ps_entropy->u1_entropy_coding_mode_flag)
         {
             /* mb skip run */
             if ((i4_slice_type != ISLICE) && *ps_entropy->pi4_mb_skip_run)
             {
                 if (*ps_entropy->pi4_mb_skip_run)
                 {
                     PUT_BITS_UEV(ps_bitstrm, *ps_entropy->pi4_mb_skip_run,
                                  ps_entropy->i4_error_code, "mb skip run");
                     *ps_entropy->pi4_mb_skip_run = 0;
                     RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
                 }
             }
             /* put rbsp trailing bits */
              ps_entropy->i4_error_code = ih264e_put_rbsp_trailing_bits(ps_bitstrm);
              RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
         }
         else
         {
             ih264e_cabac_encode_terminate(ps_cabac_ctxt, 1);
         }
 
         /* update current frame stats to rc library */
         {
             /* number of bytes to stuff */
             WORD32 i4_stuff_bytes;
 
             /* update */
             i4_stuff_bytes = ih264e_update_rc_post_enc(
                             ps_codec, ctxt_sel,
                             (ps_proc->ps_codec->i4_poc == 0));
 
             /* cbr rc - house keeping */
             if (ps_codec->s_rate_control.post_encode_skip[ctxt_sel])
             {
                  ps_entropy->ps_bitstrm->u4_strm_buf_offset = 0;
             }
             else if (i4_stuff_bytes)
             {
                 /* add filler nal units */
                  ps_entropy->i4_error_code = ih264e_add_filler_nal_unit(ps_bitstrm, i4_stuff_bytes);
                  RETURN_ENTROPY_IF_ERROR(ps_codec, ps_entropy, ctxt_sel);
             }
         }
 
         /*
          *Frame number is to be incremented only if the current frame is a
          * reference frame. After each successful frame encode, we increment
          * frame number by 1
          */
         if (!ps_codec->s_rate_control.post_encode_skip[ctxt_sel]
                         && ps_codec->u4_is_curr_frm_ref)
         {
             ps_codec->i4_frame_num++;
         }
         /********************************************************************/
         /*      signal the output                                           */
         /********************************************************************/
         ps_codec->as_out_buf[ctxt_sel].s_bits_buf.u4_bytes =
                         ps_entropy->ps_bitstrm->u4_strm_buf_offset;
 
         DEBUG("entropy status %x", ps_entropy->i4_error_code);
     }
 
     /* Dont execute any further instructions until store synchronization took place */
     DATA_SYNC();
 
     /* allow threads to dequeue entropy jobs */
     ps_codec->au4_entropy_thread_active[ctxt_sel] = 0;
 
     return ps_entropy->i4_error_code;
 }
 
 /**
 *******************************************************************************
 *
 * @brief Packs header information of a mb in to a buffer
 *
 * @par Description:
 *  After the deciding the mode info of a macroblock, the syntax elements
 *  associated with the mb are packed and stored. The entropy thread unpacks
 *  this buffer and generates the end bit stream.
 *
 * @param[in] ps_proc
 *  Pointer to the current process context
 *
 * @returns error status
 *
 * @remarks none
 *
 *******************************************************************************
 */
diff --git a/encoder/ih264e_sei.c b/encoder/ih264e_sei.c
index bffdeb2..c6cdf87 100644
--- a/encoder/ih264e_sei.c
+++ b/encoder/ih264e_sei.c
@@ -1,104 +1,105 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 
 /**
 *******************************************************************************
 * @file
 *  ih264e_sei.c
 *
 * @brief
 *  This file contains function definitions related to SEI NAL's header encoding
 *
 * @author
 *  ittiam
 *
 * @par List of Functions:
 *  - ih264e_put_sei_mdcv_params
 *  - ih264e_put_sei_cll_params
 *  - ih264e_put_sei_ave_params
 *  - ih264e_put_sei_ccv_params
 *  - ih264e_put_sei_msg
+*  - ih264e_put_sei_sii_params
 *
 * @remarks
 *  None
 *
 *******************************************************************************
 */
 
 /*****************************************************************************/
 /* File Includes                                                             */
 /*****************************************************************************/
 
 /* System include files */
 #include <stdio.h>
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
 
 /* User include files */
 #include "ih264_typedefs.h"
 #include "iv2.h"
 #include "ive2.h"
 #include "ih264_macros.h"
 #include "ih264_platform_macros.h"
 #include "ih264e_trace.h"
 #include "ih264e_error.h"
 #include "ih264e_bitstream.h"
 #include "ih264_defs.h"
 #include "ih264_structs.h"
 #include "ih264_cabac_tables.h"
 #include "ih264e_cabac_structs.h"
 #include "irc_cntrl_param.h"
 #include "ime_distortion_metrics.h"
 #include "ime_defs.h"
 #include "ime_structs.h"
 #include "ih264e_defs.h"
 #include "irc_cntrl_param.h"
 #include "irc_frame_info_collector.h"
 #include "ih264_trans_quant_itrans_iquant.h"
 #include "ih264_inter_pred_filters.h"
 #include "ih264_deblk_edge_filters.h"
 #include "ih264e_structs.h"
 #include "ih264e_encode_header.h"
 #include "ih264e_sei.h"
 
 /*****************************************************************************/
 /* Function Definitions                                                      */
 /*****************************************************************************/
 
 /**
 ******************************************************************************
 *
 *  @brief Generates Mastering Display Color Volume (Supplemental Enhancement Information )
 *
 *  @par   Description
 *  Parse Supplemental Enhancement Information
 *
 *  @param[in]   ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @param[in]   ps_sei_mdcv
 *  pointer to structure containing mdcv SEI data
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
@@ -253,195 +254,315 @@ IH264E_ERROR_T ih264e_put_sei_ave_params(sei_ave_params_t *ps_sei_ave,
 /**
 ******************************************************************************
 *
 *  @brief Generates Content Color Volume info (Supplemental Enhancement Information )
 *
 *  @par   Description
 *  Parse Supplemental Enhancement Information
 *
 *  @param[in]   ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @param[in]   ps_sei_ccv
 *  pointer to structure containing CCV SEI data
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
 IH264E_ERROR_T ih264e_put_sei_ccv_params(sei_ccv_params_t *ps_sei_ccv,
                                 bitstrm_t *ps_bitstrm)
 {
     WORD32 return_status = IH264E_SUCCESS;
     UWORD16 u2_payload_bits = 0;
     UWORD8  u1_payload_bytes = 0;
     UWORD32 u4_count;
 
     if(ps_sei_ccv == NULL)
     {
         return IH264E_FAIL;
     }
 
     u2_payload_bits += 1;   /* ccv cancel flag */
     if(0 == (UWORD32)ps_sei_ccv->u1_ccv_cancel_flag)
     {
         u2_payload_bits += 1;   /* ccv persistence flag */
         u2_payload_bits += 1;   /* ccv primaries present flag */
         u2_payload_bits += 1;   /* ccv min luminance value present flag */
         u2_payload_bits += 1;   /* ccv max luminance value present flag */
         u2_payload_bits += 1;   /* ccv avg luminance value present flag */
         u2_payload_bits += 2;   /* ccv reserved zero 2bits */
         if(1 == ps_sei_ccv->u1_ccv_primaries_present_flag)
         {
             u2_payload_bits += (NUM_SEI_CCV_PRIMARIES * 32);  /* ccv primaries x[ c ] */
             u2_payload_bits += (NUM_SEI_CCV_PRIMARIES * 32);  /* ccv primaries y[ c ] */
         }
         if(1 == ps_sei_ccv->u1_ccv_min_luminance_value_present_flag)
         {
             u2_payload_bits += 32;  /* ccv min luminance value */
         }
         if(1 == ps_sei_ccv->u1_ccv_max_luminance_value_present_flag)
         {
             u2_payload_bits += 32;  /* ccv max luminance value */
         }
         if(1 == ps_sei_ccv->u1_ccv_avg_luminance_value_present_flag)
         {
             u2_payload_bits += 32;  /* ccv avg luminance value */
         }
     }
 
     u1_payload_bytes = (UWORD8)((u2_payload_bits + 7) >> 3);
     /************************************************************************/
     /* PayloadSize : This is the size of the payload in bytes               */
     /************************************************************************/
     PUT_BITS(ps_bitstrm, u1_payload_bytes, 8, return_status, "u1_payload_bytes");
 
     /*******************************************************************************/
     /* Put the Content Color Volume SEI parameters into the bitstream.  */
     /*******************************************************************************/
 
     PUT_BITS(ps_bitstrm, ps_sei_ccv->u1_ccv_cancel_flag, 1,
                             return_status, "u1_ccv_cancel_flag");
 
     if(0 == ps_sei_ccv->u1_ccv_cancel_flag)
     {
         PUT_BITS(ps_bitstrm, ps_sei_ccv->u1_ccv_persistence_flag, 1,
                                 return_status, "u1_ccv_persistence_flag");
         PUT_BITS(ps_bitstrm, ps_sei_ccv->u1_ccv_primaries_present_flag, 1,
                                 return_status, "u1_ccv_primaries_present_flag");
         PUT_BITS(ps_bitstrm, ps_sei_ccv->u1_ccv_min_luminance_value_present_flag, 1,
                                 return_status, "u1_ccv_min_luminance_value_present_flag");
         PUT_BITS(ps_bitstrm, ps_sei_ccv->u1_ccv_max_luminance_value_present_flag, 1,
                                 return_status, "u1_ccv_max_luminance_value_present_flag");
         PUT_BITS(ps_bitstrm, ps_sei_ccv->u1_ccv_avg_luminance_value_present_flag, 1,
                                 return_status, "u1_ccv_avg_luminance_value_present_flag");
         PUT_BITS(ps_bitstrm, ps_sei_ccv->u1_ccv_reserved_zero_2bits, 2,
                                 return_status, "u1_ccv_reserved_zero_2bits");
 
         /* ccv primaries */
         if(1 == ps_sei_ccv->u1_ccv_primaries_present_flag)
         {
             for(u4_count = 0; u4_count < NUM_SEI_CCV_PRIMARIES; u4_count++)
             {
                 PUT_BITS(ps_bitstrm, ps_sei_ccv->ai4_ccv_primaries_x[u4_count], 32,
                                 return_status, "i4_ccv_primaries_x");
                 PUT_BITS(ps_bitstrm, ps_sei_ccv->ai4_ccv_primaries_y[u4_count], 32,
                                 return_status, "i4_ccv_primaries_y");
             }
         }
 
         if(1 == ps_sei_ccv->u1_ccv_min_luminance_value_present_flag)
         {
             PUT_BITS(ps_bitstrm, ps_sei_ccv->u4_ccv_min_luminance_value, 32,
                                 return_status, "u4_ccv_min_luminance_value");
         }
         if(1 == ps_sei_ccv->u1_ccv_max_luminance_value_present_flag)
         {
             PUT_BITS(ps_bitstrm, ps_sei_ccv->u4_ccv_max_luminance_value, 32,
                                 return_status, "u4_ccv_max_luminance_value");
         }
         if(1 == ps_sei_ccv->u1_ccv_avg_luminance_value_present_flag)
         {
             PUT_BITS(ps_bitstrm, ps_sei_ccv->u4_ccv_avg_luminance_value, 32,
                                 return_status, "u4_ccv_avg_luminance_value");
         }
     }
 
     return (return_status);
 }
 
+/**
+******************************************************************************
+*
+*  @brief Signal shutter interval info in the bitstream
+*
+*  @par   Description
+*  Parse Supplemental Enhancement Information
+*
+*  @param[in]   ps_bitstrm
+*  pointer to bitstream context (handle)
+*
+*  @param[in]   ps_sei_sii
+*  pointer to shutter interval info
+*
+*  @return      success or failure error code
+*
+******************************************************************************
+*/
+IH264E_ERROR_T ih264e_put_sei_sii_params(sei_sii_params_t *ps_sei_sii, bitstrm_t *ps_bitstrm)
+{
+    WORD32 return_status = IH264E_SUCCESS;
+    UWORD16 u2_payload_bits = 0;
+    UWORD8 u1_payload_bytes = 0;
+
+    if(ps_sei_sii == NULL)
+    {
+        return IH264E_FAIL;
+    }
+
+    printf("ps_sei_sii->u4_sii_sub_layer_idx: %d\n", ps_sei_sii->u4_sii_sub_layer_idx);
+    printf("ps_sei_sii->u1_shutter_interval_info_present_flag: %d\n",
+           ps_sei_sii->u1_shutter_interval_info_present_flag);
+    printf("ps_sei_sii->u4_sii_time_scale: %d\n", ps_sei_sii->u4_sii_time_scale);
+    printf("ps_sei_sii->u1_fixed_shutter_interval_within_cvs_flag: %d\n",
+           ps_sei_sii->u1_fixed_shutter_interval_within_cvs_flag);
+    printf("ps_sei_sii->u4_sii_num_units_in_shutter_interval: %d\n",
+           ps_sei_sii->u4_sii_num_units_in_shutter_interval);
+    printf("ps_sei_sii->u1_sii_max_sub_layers_minus1: %d\n",
+           ps_sei_sii->u1_sii_max_sub_layers_minus1);
+    printf("ps_sei_sii->au4_sub_layer_num_units_in_shutter_interval[1]: %d\n",
+           ps_sei_sii->au4_sub_layer_num_units_in_shutter_interval[1]);
+
+    if(0 == ps_sei_sii->u4_sii_sub_layer_idx)
+    {
+        u2_payload_bits += 1; /* shutter interval info present flag */
+
+        if(1 == ps_sei_sii->u1_shutter_interval_info_present_flag)
+        {
+            u2_payload_bits += 32; /* sii time scale */
+            u2_payload_bits += 1;  /* fixed shutter interval within cvs flag */
+
+            if(1 == ps_sei_sii->u1_fixed_shutter_interval_within_cvs_flag)
+            {
+                u2_payload_bits += 32; /* sii num units in shutter interval */
+            }
+            else
+            {
+                int sizeofSubLayer;
+                u2_payload_bits += 3; /* sii max sub layers minus1 */
+                sizeofSubLayer =
+                    sizeof(ps_sei_sii->au4_sub_layer_num_units_in_shutter_interval) /
+                    sizeof(ps_sei_sii->au4_sub_layer_num_units_in_shutter_interval[0]);
+                u2_payload_bits +=
+                    32 * sizeofSubLayer; /* sii sub layer num units in shutter interval */
+            }
+        }
+    }
+
+    u1_payload_bytes = (UWORD8) ((u2_payload_bits + 7) >> 3);
+    /************************************************************************/
+    /* PayloadSize : This is the size of the payload in bytes               */
+    /************************************************************************/
+    PUT_BITS(ps_bitstrm, u1_payload_bytes, 8, return_status, "u1_payload_bytes");
+
+    /*******************************************************************************/
+    /* Put the Shutter Interval Info SEI parameters into the bitstream.            */
+    /*******************************************************************************/
+
+    PUT_BITS_UEV(ps_bitstrm, ps_sei_sii->u4_sii_sub_layer_idx, return_status,
+                 "u4_sii_sub_layer_idx");
+
+    if(0 == ps_sei_sii->u4_sii_sub_layer_idx)
+    {
+        PUT_BITS(ps_bitstrm, ps_sei_sii->u1_shutter_interval_info_present_flag, 1, return_status,
+                 "u1_shutter_interval_info_present_flag");
+
+        if(1 == ps_sei_sii->u1_shutter_interval_info_present_flag)
+        {
+            PUT_BITS(ps_bitstrm, ps_sei_sii->u4_sii_time_scale, 32, return_status,
+                     "u4_sii_time_scale");
+            PUT_BITS(ps_bitstrm, ps_sei_sii->u1_fixed_shutter_interval_within_cvs_flag, 1,
+                     return_status, "u1_fixed_shutter_interval_within_cvs_flag");
+
+            if(1 == ps_sei_sii->u1_fixed_shutter_interval_within_cvs_flag)
+            {
+                PUT_BITS(ps_bitstrm, ps_sei_sii->u4_sii_num_units_in_shutter_interval, 32,
+                         return_status, "u4_sii_num_units_in_shutter_interval");
+            }
+            else
+            {
+                int i;
+                PUT_BITS(ps_bitstrm, ps_sei_sii->u1_sii_max_sub_layers_minus1, 3, return_status,
+                         "u1_sii_max_sub_layers_minus1");
+
+                for(i = 0; i <= ps_sei_sii->u1_sii_max_sub_layers_minus1; i++)
+                {
+                    PUT_BITS(ps_bitstrm, ps_sei_sii->au4_sub_layer_num_units_in_shutter_interval[i],
+                             32, return_status, "au4_sub_layer_num_units_in_shutter_interval[i]");
+                }
+            }
+        }
+    }
+    return (return_status);
+}
+
 /**
 ******************************************************************************
 *
 *  @brief Generates SEI (Supplemental Enhancement Information )
 *
 *  @par   Description
 *  Parse Supplemental Enhancement Information
 *
 *  @param[in]   e_payload_type
 *  Determines the type of SEI msg
 *
 *  @param[in]   ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @param[in]   ps_sei_params
 *  pointer to structure containing SEI data
 *               buffer period, recovery point, picture timing
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
 IH264E_ERROR_T ih264e_put_sei_msg(IH264_SEI_TYPE e_payload_type,
                          sei_params_t *ps_sei_params,
                          bitstrm_t *ps_bitstrm)
 {
     WORD32 return_status = IH264E_SUCCESS;
 
     /************************************************************************/
     /* PayloadType : Send in the SEI type in the stream                     */
     /************************************************************************/
 
     UWORD32 u4_payload_type = e_payload_type;
 
     while(u4_payload_type > 0xFF)
     {
         PUT_BITS(ps_bitstrm, 0xFF, 8, return_status, "payload");
         u4_payload_type -= 0xFF;
     }
 
     PUT_BITS(ps_bitstrm, (UWORD32)u4_payload_type, 8, return_status, "e_payload_type");
 
     switch(e_payload_type)
     {
     case IH264_SEI_MASTERING_DISP_COL_VOL :
         return_status = ih264e_put_sei_mdcv_params(&(ps_sei_params->s_sei_mdcv_params),
                                                     ps_bitstrm);
         break;
 
     case IH264_SEI_CONTENT_LIGHT_LEVEL_DATA :
         return_status = ih264e_put_sei_cll_params(&(ps_sei_params->s_sei_cll_params),
                                                     ps_bitstrm);
         break;
 
     case IH264_SEI_AMBIENT_VIEWING_ENVIRONMENT :
         return_status = ih264e_put_sei_ave_params(&(ps_sei_params->s_sei_ave_params),
                                                     ps_bitstrm);
         break;
 
     case IH264_SEI_CONTENT_COLOR_VOLUME :
          return_status = ih264e_put_sei_ccv_params(&(ps_sei_params->s_sei_ccv_params),
                                                     ps_bitstrm);
          break;
 
+    case IH264_SEI_SHUTTER_INTERVAL_INFO:
+         return_status = ih264e_put_sei_sii_params(&(ps_sei_params->s_sei_sii_params), ps_bitstrm);
+
+         break;
+
     default :
         return_status = IH264E_FAIL;
     }
 
     /* rbsp trailing bits */
     if((IH264E_SUCCESS == return_status) && (ps_bitstrm->i4_bits_left_in_cw & 0x7))
         return_status = ih264e_put_rbsp_trailing_bits(ps_bitstrm);
 
     return(return_status);
 }
 
 
diff --git a/encoder/ih264e_sei.h b/encoder/ih264e_sei.h
index a5b1d9d..d31f728 100644
--- a/encoder/ih264e_sei.h
+++ b/encoder/ih264e_sei.h
@@ -42,36 +42,36 @@
 /*****************************************************************************/
 /* INTERFACE STRUCTURE DEFINITIONS                                           */
 /*****************************************************************************/
 typedef enum
 {
     /* SEI PREFIX */
 
     IH264_SEI_MASTERING_DISP_COL_VOL       = 137,
     IH264_SEI_CONTENT_LIGHT_LEVEL_DATA     = 144,
     IH264_SEI_AMBIENT_VIEWING_ENVIRONMENT  = 148,
-    IH264_SEI_CONTENT_COLOR_VOLUME         = 149
-
+    IH264_SEI_CONTENT_COLOR_VOLUME         = 149,
+    IH264_SEI_SHUTTER_INTERVAL_INFO        = 205
 }IH264_SEI_TYPE;
 
 /*****************************************************************************/
 /* Function Declarations                                              */
 /*****************************************************************************/
 
 /**
 ******************************************************************************
 *
 *  @brief Generates Mastering Display Color Volume (Supplemental Enhancement Information )
 *
 *  @par   Description
 *  Parse Supplemental Enhancement Information
 *
 *  @param[in]   ps_sei_mdcl
 *  pointer to structure containing mdcv SEI data
 *
 *  @param[in]   ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
@@ -144,27 +144,46 @@ IH264E_ERROR_T ih264e_put_sei_ccv_params(sei_ccv_params_t *ps_sei_ccv,
 /**
 ******************************************************************************
 *
 *  @brief Generates SEI (Supplemental Enhancement Information )
 *
 *  @par   Description
 *  Parse Supplemental Enhancement Information
 *
 *  @param[in]   e_payload_type
 *  Determines the type of SEI msg
 *
 *  @param[in]   ps_bitstrm
 *  pointer to bitstream context (handle)
 *
 *  @param[in]   ps_sei
 *  pointer to structure containing SEI data
 *
 *  @return      success or failure error code
 *
 ******************************************************************************
 */
 IH264E_ERROR_T ih264e_put_sei_msg(IH264_SEI_TYPE e_payload_type,
                          sei_params_t *ps_sei_params,
                          bitstrm_t *ps_bitstrm);
 
+/**
+******************************************************************************
+*
+*  @brief Signal shutter interval info in the bitstream
+*
+*  @par   Description
+*  Parse Supplemental Enhancement Information
+*
+*  @param[in]   ps_bitstrm
+*  pointer to bitstream context (handle)
+*
+*  @param[in]   ps_sei_sii
+*  pointer to shutter interval info
+*
+*  @return      success or failure error code
+*
+******************************************************************************
+*/
+IH264E_ERROR_T ih264e_put_sei_sii_params(sei_sii_params_t *ps_sei_sii, bitstrm_t *ps_bitstrm);
 
 #endif /* ENCODER_IH264E_SEI_H_ */
diff --git a/encoder/ih264e_structs.h b/encoder/ih264e_structs.h
index 9b22642..b279d85 100644
--- a/encoder/ih264e_structs.h
+++ b/encoder/ih264e_structs.h
@@ -280,38 +280,44 @@ typedef struct
 typedef struct
 {
     /** Descriptor of raw buffer                                     */
     iv_raw_buf_t                            s_raw_buf;
 
     /** Lower 32bits of time stamp corresponding to the above buffer */
     UWORD32                                 u4_timestamp_low;
 
     /** Upper 32bits of time stamp corresponding to the above buffer */
     UWORD32                                 u4_timestamp_high;
 
     /** Flag to indicate if the current buffer is last buffer */
     UWORD32                                 u4_is_last;
 
     /** Flag to indicate if mb info is sent along with input buffer     */
     UWORD32                                 u4_mb_info_type;
 
     /** Flag to indicate the size of mb info structure                  */
     UWORD32                                 u4_mb_info_size;
 
     /** Buffer containing mb info if mb_info_type is non-zero           */
     void                                    *pv_mb_info;
 
     /** Flag to indicate if pic info is sent along with input buffer     */
     UWORD32                                 u4_pic_info_type;
 
     /** Buffer containing pic info if mb_info_type is non-zero           */
     void                                    *pv_pic_info;
 
     /** SEI CCV params flag                                              */
     UWORD8                                  u1_sei_ccv_params_present_flag;
 
     /** SEI CCV params info                                              */
     sei_ccv_params_t                        s_sei_ccv;
 
+    /** SEI SII params flag                                              */
+    UWORD8 u1_sei_sii_params_present_flag;
+
+    /** SEI SII params info                                              */
+    sei_sii_params_t s_sei_sii;
+
 }inp_buf_t;
 
 typedef struct
diff --git a/encoder/ih264e_utils.c b/encoder/ih264e_utils.c
index 94050cd..d83b8be 100644
--- a/encoder/ih264e_utils.c
+++ b/encoder/ih264e_utils.c
@@ -120,358 +120,364 @@
 /**
  *******************************************************************************
  *
  * @brief
  *  Queues the current buffer, gets back a another buffer for encoding with corrent
  *  picture type
  *
  * @par Description:
  *      This function performs 3 distinct but related functions.
  *      1) Maintains an input queue [Note the the term queue donot imply a
  *         first-in first-out logic here] that queues input and dequeues them so
  *         that input frames can be encoded at any predetermined encoding order
  *      2) Uses RC library to decide which frame must be encoded in current pass
  *         and which picture type it must be encoded to.
  *      3) Uses RC library to decide the QP at which current frame has to be
  *         encoded
  *      4) Determines if the current picture must be encoded or not based on
  *         PRE-ENC skip
  *
  *     Input queue is used for storing input buffers till they are used for
  *     encoding. This queue is maintained at ps_codec->as_inp_list. Whenever a
  *     valid input comes, it is added to the end of queue. This same input is
  *     added to RC queue using the identifier as ps_codec->i4_pic_cnt. Hence any
  *     pic from RC can be located in the input queue easily.
  *
  *     The dequeue operation does not start till we have ps_codec->s_cfg.u4_max_num_bframes
  *     frames in the queue. THis is done in order to ensure that once output starts
  *     we will have a constant stream of output with no gaps.
  *
  *     THe output frame order is governed by RC library. When ever we dequeue a
  *     buffer from RC library, it ensures that we will get them in encoding order
  *     With the output of RC library, we can use the picture id to dequeue the
  *     corresponding buffer from input queue and encode it.
  *
  *     Condition at the end of stream.
  *     -------------------------------
  *      At the last valid buffer from the app, we will get ps_ive_ip->u4_is_last
  *      to be set. This will the given to lib when appropriate input buffer is
  *      given to encoding.
  *
  *      Since we have to output is not in sync with input, we will have frames to
  *      encode even after we recive the last vaild input buffer. Hence we have to
  *      make sure that we donot queue any new buffers once we get the flag [It may
  *      mess up GOP ?]. This is acheived by setting ps_codec->i4_last_inp_buff_received
  *      to act as a permenent marker for last frame recived [This may not be needed,
  *      because in our current app, all buffers after the last are marked as last.
  *      But can we rely on that?] . Hence after this flgag is set no new buffers are
  *      queued.
  *
  * @param[in] ps_codec
  *   Pointer to codec descriptor
  *
  * @param[in] ps_ive_ip
  *   Current input buffer to the encoder
  *
  * @param[out] ps_inp
  *   Buffer to be encoded in the current pass
  *
  * @returns
  *   Flag indicating if we have a pre-enc skip or not
  *
  * @remarks
  * TODO (bpic)
  *  The check for null ans is last is redudent.
  *  Need to see if we can remove it
  *
  *******************************************************************************
  */
 WORD32 ih264e_input_queue_update(codec_t *ps_codec,
                                  ive_video_encode_ip_t *ps_ive_ip,
                                  inp_buf_t *ps_enc_buff)
 {
 
     inp_buf_t *ps_inp_buf;
     picture_type_e e_pictype;
     WORD32 i4_skip;
     UWORD32 ctxt_sel, u4_pic_id, u4_pic_disp_id;
     UWORD8 u1_frame_qp, i;
     UWORD32 max_frame_bits = 0x7FFFFFFF;
 
     /*  Mark that the last input frame has been received */
     if (ps_ive_ip->u4_is_last == 1)
     {
         ps_codec->i4_last_inp_buff_received = 1;
     }
 
     if (ps_ive_ip->s_inp_buf.apv_bufs[0] == NULL
                     && !ps_codec->i4_last_inp_buff_received)
     {
         ps_enc_buff->s_raw_buf.apv_bufs[0] = NULL;
         ps_enc_buff->u4_is_last = ps_ive_ip->u4_is_last;
         return 0;
     }
 
     /***************************************************************************
      * Check for pre enc skip
      *   When src and target frame rates donot match, we skip some frames to
      *   maintain the relation ship between them
      **************************************************************************/
     {
         WORD32 skip_src;
 
         skip_src = ih264e_update_rc_framerates(
                         ps_codec->s_rate_control.pps_rate_control_api,
                         ps_codec->s_rate_control.pps_pd_frm_rate,
                         ps_codec->s_rate_control.pps_time_stamp,
                         ps_codec->s_rate_control.pps_frame_time);
 
         if (skip_src)
         {
             ps_enc_buff->u4_is_last = ps_ive_ip->u4_is_last;
             return 1;
         }
     }
 
     /***************************************************************************
      *Queue the input to the queue
      **************************************************************************/
     ps_inp_buf = &(ps_codec->as_inp_list[ps_codec->i4_pic_cnt
                                          % MAX_NUM_INP_FRAMES]);
 
     /* copy input info. to internal structure */
     ps_inp_buf->s_raw_buf = ps_ive_ip->s_inp_buf;
     ps_inp_buf->u4_timestamp_low = ps_ive_ip->u4_timestamp_low;
     ps_inp_buf->u4_timestamp_high = ps_ive_ip->u4_timestamp_high;
     ps_inp_buf->u4_is_last = ps_ive_ip->u4_is_last;
     ps_inp_buf->pv_mb_info = ps_ive_ip->pv_mb_info;
     ps_inp_buf->u4_mb_info_type = ps_ive_ip->u4_mb_info_type;
     ps_inp_buf->pv_pic_info = ps_ive_ip->pv_pic_info;
     ps_inp_buf->u4_pic_info_type = ps_ive_ip->u4_pic_info_type;
 
     ps_inp_buf->u1_sei_ccv_params_present_flag =
                 ps_codec->s_cfg.s_sei.u1_sei_ccv_params_present_flag;
     ps_inp_buf->s_sei_ccv = ps_codec->s_cfg.s_sei.s_sei_ccv_params;
 
+    ps_inp_buf->u1_sei_sii_params_present_flag =
+        ps_codec->s_cfg.s_sei.u1_sei_sii_params_present_flag;
+    ps_inp_buf->s_sei_sii = ps_codec->s_cfg.s_sei.s_sei_sii_params;
+
     /***************************************************************************
      * Now we should add the picture to RC stack here
      **************************************************************************/
     /*
      * If an I frame has been requested, ask  RC to force it
      * For IDR requests, we have to ask RC to force I and set IDR by our selves
      * since RC Donot know about IDR. For forcing an IDR at dequeue stage we
      * should record that an IDR has been requested some where. Hence we will
      * store it in the u4_idr_inp_list at a position same as that of input frame
      */
     {
         WORD32 i4_force_idr, i4_force_i;
 
         i4_force_idr = (ps_codec->force_curr_frame_type == IV_IDR_FRAME);
         i4_force_idr |= !(ps_codec->i4_pic_cnt % ps_codec->s_cfg.u4_idr_frm_interval);
 
         i4_force_i = (ps_codec->force_curr_frame_type == IV_I_FRAME);
 
         ps_codec->i4_pending_idr_flag |= i4_force_idr;
 
         if ((ps_codec->i4_pic_cnt > 0) && (i4_force_idr || i4_force_i))
         {
             irc_force_I_frame(ps_codec->s_rate_control.pps_rate_control_api);
         }
         ps_codec->force_curr_frame_type = IV_NA_FRAME;
     }
 
     irc_add_picture_to_stack(ps_codec->s_rate_control.pps_rate_control_api,
                              ps_codec->i4_pic_cnt);
 
 
     /* Delay */
     if (ps_codec->i4_encode_api_call_cnt
                     < (WORD32)(ps_codec->s_cfg.u4_num_bframes))
     {
         ps_enc_buff->s_raw_buf.apv_bufs[0] = NULL;
         ps_enc_buff->u4_is_last = 0;
         return 0;
     }
 
     /***************************************************************************
      * Get a new pic to encode
      **************************************************************************/
     /* Query the picture_type */
     e_pictype = ih264e_rc_get_picture_details(
                     ps_codec->s_rate_control.pps_rate_control_api, (WORD32 *)(&u4_pic_id),
                     (WORD32 *)(&u4_pic_disp_id));
 
     switch (e_pictype)
     {
         case I_PIC:
             ps_codec->pic_type = PIC_I;
             break;
         case P_PIC:
             ps_codec->pic_type = PIC_P;
             break;
         case B_PIC:
             ps_codec->pic_type = PIC_B;
             break;
         default:
             ps_codec->pic_type = PIC_NA;
             ps_enc_buff->s_raw_buf.apv_bufs[0] = NULL;
             return 0;
     }
 
     /* Set IDR if it has been requested */
     if (ps_codec->pic_type == PIC_I)
     {
         ps_codec->pic_type = ps_codec->i4_pending_idr_flag ?
                                     PIC_IDR : ps_codec->pic_type;
         ps_codec->i4_pending_idr_flag = 0;
     }
 
     /* Get current frame Qp */
     u1_frame_qp = (UWORD8)irc_get_frame_level_qp(
                     ps_codec->s_rate_control.pps_rate_control_api, e_pictype,
                     max_frame_bits);
     ps_codec->u4_frame_qp = gau1_mpeg2_to_h264_qmap[u1_frame_qp];
 
     /*
      * copy the pic id to poc because the display order is assumed to be same
      * as input order
      */
     ps_codec->i4_poc = u4_pic_id;
 
     /***************************************************************************
      * Now retrieve the correct picture from the queue
      **************************************************************************/
 
     /* Mark the skip flag   */
     i4_skip = 0;
     ctxt_sel = ps_codec->i4_encode_api_call_cnt % MAX_CTXT_SETS;
     ps_codec->s_rate_control.pre_encode_skip[ctxt_sel] = i4_skip;
 
     /* Get a buffer to encode */
     ps_inp_buf = &(ps_codec->as_inp_list[u4_pic_id % MAX_NUM_INP_FRAMES]);
 
     /* copy dequeued input to output */
     ps_enc_buff->s_raw_buf = ps_inp_buf->s_raw_buf;
     ps_enc_buff->u4_timestamp_low = ps_inp_buf->u4_timestamp_low;
     ps_enc_buff->u4_timestamp_high = ps_inp_buf->u4_timestamp_high;
     ps_enc_buff->u4_is_last = ps_inp_buf->u4_is_last;
     ps_enc_buff->pv_mb_info = ps_inp_buf->pv_mb_info;
     ps_enc_buff->u4_mb_info_type = ps_inp_buf->u4_mb_info_type;
     ps_enc_buff->pv_pic_info = ps_inp_buf->pv_pic_info;
     ps_enc_buff->u4_pic_info_type = ps_inp_buf->u4_pic_info_type;
 
     ps_enc_buff->u1_sei_ccv_params_present_flag = ps_inp_buf->u1_sei_ccv_params_present_flag;
     ps_enc_buff->s_sei_ccv = ps_inp_buf->s_sei_ccv;
+    ps_enc_buff->u1_sei_sii_params_present_flag = ps_inp_buf->u1_sei_sii_params_present_flag;
+    ps_enc_buff->s_sei_sii = ps_inp_buf->s_sei_sii;
 
     /* Special case for encoding trailing B frames
      *
      * In encoding streams with B frames it may happen that we have a B frame
      * at the end without a P/I frame after it. Hence when we are dequeing from
      * the RC, it will return the P frame [next in display order but before in
      * encoding order] first. Since the dequeue happens for an invalid frame we
      * will get a frame with null buff and set u4_is_last. Hence lib with return
      * last frame flag at this point and will stop encoding.
      *
      * Since for the last B frame, we does not have the forward ref frame
      * it makes sense to force it into P.
      *
      * To solve this, in case the current frame is P and if the last frame flag
      * is set, we need to see if there is and pending B frames. If there are any,
      * we should just encode that picture as the current P frame and set
      * that B frame as the last frame. Hence the encoder will terminate naturally
      * once that B-frame is encoded after all the in between frames.
      *
      * Since we cannot touch RC stack directly, the option of actually swapping
      * frames in RC is ruled out. We have to modify the as_inp_list to simulate
      * such a behavior by RC. We can do that by
      *  1) Search through as_inp_list to locate the largest u4_timestamp_low less
      *     than current u4_timestamp_low. This will give us the last B frame before
      *     the current P frame. Note that this will handle pre encode skip too since
      *     queue happens after pre enc skip.
      *  2) Swap the position in as_inp_list. Hence now the last B frame is
      *     encoded as P frame. And the new last B frame will have u4_is_last
      *     set so that encoder will end naturally once we reached that B frame
      *     or any subsequent frame. Also the current GOP will have 1 less B frame
      *     Since we are swapping, the poc will also be in-order.
      *  3) In case we have an IPP stream, the result of our search will be an
      *     I/P frame which is already encoded. Thus swap and encode will result
      *     in encoding of duplicate frames. Hence to avoid this we will only
      *     have this work around in case of u4_num_bframes > 0.
      *
      *     In case we have forced an I/IDR frame In between this P frame and
      *     the last B frame -> This cannot happen as the current P frame is
      *     supposed to have u4_is_last set. Thus forcing an I/ IDR after this
      *     is illogical.
      *
      *     In cae if we have forced an I such that the frame just before last frame
      *     in is I/P -> This case will never arise. Since we have a closed GOP now,
      *     once we force an I, the gop gets reset, hence there will be a B between
      *     I/P and I/P.
      */
     if (ps_enc_buff->u4_is_last && (ps_codec->pic_type == PIC_P)
                     && ps_codec->s_cfg.u4_num_bframes)
     {
         WORD32 cntr;
         WORD32 lst_bframe = -1;
         UWORD32 u4_timestamp_low = 0;
         UWORD32 u4_timestamp_high = 0;
         inp_buf_t *ps_swap_buff, *ps_inp_list;
 
         ps_inp_list = &ps_codec->as_inp_list[0];
 
         /* Now search the inp list for highest timestamp */
         for(cntr = 0; cntr < MAX_NUM_INP_FRAMES; cntr++)
         {
             if(ps_inp_list[cntr].s_raw_buf.apv_bufs[0] != NULL)
             {
                 if ((ps_inp_list[cntr].u4_timestamp_high  > u4_timestamp_high) ||
                     (ps_inp_list[cntr].u4_timestamp_high  == u4_timestamp_high &&
                      ps_inp_list[cntr].u4_timestamp_low  > u4_timestamp_low))
                 {
                     u4_timestamp_low = ps_inp_list[cntr].u4_timestamp_low;
                     u4_timestamp_high = ps_inp_list[cntr].u4_timestamp_high;
                     lst_bframe = cntr;
                 }
             }
         }
 
         if(lst_bframe != -1)
         {
             ps_swap_buff = &(ps_codec->as_inp_list[lst_bframe]);
 
             /* copy the last B buffer to output */
             *ps_enc_buff = *ps_swap_buff;
 
             /* Store the current buf into the queue in place of last B buf */
             *ps_swap_buff = *ps_inp_buf;
         }
     }
 
     /* The buffer in the queue is set to NULL to specify that encoding is done for that frame */
     for(i = 0; i < 3; i++)
     {
         ps_inp_buf->s_raw_buf.apv_bufs[i] = NULL;
     }
 
     /* Return the buffer status */
     return (0);
 }
 
 /**
 *******************************************************************************
 *
 * @brief
 *  Used to get minimum level index for a given picture size
 *
 * @par Description:
 *  Gets the minimum level index and then gets corresponding level.
 *  Also used to ignore invalid levels like 2.3, 3.3 etc
 *
 * @param[in] level
 *  Level of the stream
 *
 * @returns  Level index for a given level
 *
 * @remarks
 *
 *******************************************************************************
 */
diff --git a/encoder/ive2.h b/encoder/ive2.h
index f3f1bd9..2ba0ec8 100644
--- a/encoder/ive2.h
+++ b/encoder/ive2.h
@@ -124,37 +124,38 @@ typedef enum
 /** Video Control API command type            */
 typedef enum
 {
     IVE_CMD_CT_NA                           = 0x7FFFFFFF,
     IVE_CMD_CTL_SETDEFAULT                  = 0x0,
     IVE_CMD_CTL_SET_DIMENSIONS              = 0x1,
     IVE_CMD_CTL_SET_FRAMERATE               = 0x2,
     IVE_CMD_CTL_SET_BITRATE                 = 0x3,
     IVE_CMD_CTL_SET_FRAMETYPE               = 0x4,
     IVE_CMD_CTL_SET_QP                      = 0x5,
     IVE_CMD_CTL_SET_ENC_MODE                = 0x6,
     IVE_CMD_CTL_SET_VBV_PARAMS              = 0x7,
     IVE_CMD_CTL_SET_AIR_PARAMS              = 0x8,
     IVE_CMD_CTL_SET_ME_PARAMS               = 0X9,
     IVE_CMD_CTL_SET_GOP_PARAMS              = 0XA,
     IVE_CMD_CTL_SET_PROFILE_PARAMS          = 0XB,
     IVE_CMD_CTL_SET_DEBLOCK_PARAMS          = 0XC,
     IVE_CMD_CTL_SET_IPE_PARAMS              = 0XD,
     IVE_CMD_CTL_SET_VUI_PARAMS              = 0XE,
     IVE_CMD_CTL_SET_NUM_CORES               = 0x30,
     IVE_CMD_CTL_RESET                       = 0xA0,
     IVE_CMD_CTL_FLUSH                       = 0xB0,
     IVE_CMD_CTL_GETBUFINFO                  = 0xC0,
     IVE_CMD_CTL_GETVERSION                  = 0xC1,
     IVE_CMD_CTL_SET_SEI_MDCV_PARAMS         = 0xD0,
     IVE_CMD_CTL_SET_SEI_CLL_PARAMS          = 0xD1,
     IVE_CMD_CTL_SET_SEI_AVE_PARAMS          = 0xD2,
     IVE_CMD_CTL_SET_SEI_CCV_PARAMS          = 0xD3,
+    IVE_CMD_CTL_SET_SEI_SII_PARAMS          = 0xD4,
     IVE_CMD_CTL_CODEC_SUBCMD_START          = 0x100,
 }IVE_CONTROL_API_COMMAND_TYPE_T;
 
 /* IVE_ERROR_BITS_T: A UWORD32 container will be used for reporting the error*/
 /* code to the application. The first 8 bits starting from LSB have been     */
 /* reserved for the codec to report internal error details. The rest of the  */
 /* bits will be generic for all video encoders and each bit has an associated*/
 /* meaning as mentioned below. The unused bit fields are reserved for future */
 /* extenstions and will be zero in the current implementation                */
@@ -173,88 +174,90 @@ typedef enum {
 /* IVE_ERROR_CODES_T: The list of error codes depicting the possible error  */
 /* scenarios that can be encountered while encoding                         */
 typedef enum
 {
 
     IVE_ERR_NA                                                  = 0x7FFFFFFF,
     IVE_ERR_NONE                                                = 0x00,
     IVE_ERR_INVALID_API_CMD                                     = 0x01,
     IVE_ERR_INVALID_API_SUB_CMD                                 = 0x02,
     IVE_ERR_IP_GET_MEM_REC_API_STRUCT_SIZE_INCORRECT            = 0x03,
     IVE_ERR_OP_GET_MEM_REC_API_STRUCT_SIZE_INCORRECT            = 0x04,
     IVE_ERR_IP_FILL_MEM_REC_API_STRUCT_SIZE_INCORRECT           = 0x05,
     IVE_ERR_OP_FILL_MEM_REC_API_STRUCT_SIZE_INCORRECT           = 0x06,
     IVE_ERR_IP_INIT_API_STRUCT_SIZE_INCORRECT                   = 0x07,
     IVE_ERR_OP_INIT_API_STRUCT_SIZE_INCORRECT                   = 0x08,
     IVE_ERR_IP_RETRIEVE_MEM_REC_API_STRUCT_SIZE_INCORRECT       = 0x09,
     IVE_ERR_OP_RETRIEVE_MEM_REC_API_STRUCT_SIZE_INCORRECT       = 0x0A,
     IVE_ERR_IP_ENCODE_API_STRUCT_SIZE_INCORRECT                 = 0x0B,
     IVE_ERR_OP_ENCODE_API_STRUCT_SIZE_INCORRECT                 = 0x0C,
     IVE_ERR_IP_CTL_SETDEF_API_STRUCT_SIZE_INCORRECT             = 0x0D,
     IVE_ERR_OP_CTL_SETDEF_API_STRUCT_SIZE_INCORRECT             = 0x0E,
     IVE_ERR_IP_CTL_GETBUFINFO_API_STRUCT_SIZE_INCORRECT         = 0x0F,
     IVE_ERR_OP_CTL_GETBUFINFO_API_STRUCT_SIZE_INCORRECT         = 0x10,
     IVE_ERR_IP_CTL_GETVERSION_API_STRUCT_SIZE_INCORRECT         = 0x11,
     IVE_ERR_OP_CTL_GETVERSION_API_STRUCT_SIZE_INCORRECT         = 0x12,
     IVE_ERR_IP_CTL_FLUSH_API_STRUCT_SIZE_INCORRECT              = 0x13,
     IVE_ERR_OP_CTL_FLUSH_API_STRUCT_SIZE_INCORRECT              = 0x14,
     IVE_ERR_IP_CTL_RESET_API_STRUCT_SIZE_INCORRECT              = 0x15,
     IVE_ERR_OP_CTL_RESET_API_STRUCT_SIZE_INCORRECT              = 0x16,
     IVE_ERR_IP_CTL_SETCORES_API_STRUCT_SIZE_INCORRECT           = 0x17,
     IVE_ERR_OP_CTL_SETCORES_API_STRUCT_SIZE_INCORRECT           = 0x18,
     IVE_ERR_IP_CTL_SETDIM_API_STRUCT_SIZE_INCORRECT             = 0x19,
     IVE_ERR_OP_CTL_SETDIM_API_STRUCT_SIZE_INCORRECT             = 0x1A,
     IVE_ERR_IP_CTL_SETFRAMERATE_API_STRUCT_SIZE_INCORRECT       = 0x1B,
     IVE_ERR_OP_CTL_SETFRAMERATE_API_STRUCT_SIZE_INCORRECT       = 0x1C,
     IVE_ERR_IP_CTL_SETBITRATE_API_STRUCT_SIZE_INCORRECT         = 0x1D,
     IVE_ERR_OP_CTL_SETBITRATE_API_STRUCT_SIZE_INCORRECT         = 0x1E,
     IVE_ERR_IP_CTL_SETFRAMETYPE_API_STRUCT_SIZE_INCORRECT       = 0x1F,
     IVE_ERR_OP_CTL_SETFRAMETYPE_API_STRUCT_SIZE_INCORRECT       = 0x20,
     IVE_ERR_IP_CTL_SETMEPARAMS_API_STRUCT_SIZE_INCORRECT        = 0x21,
     IVE_ERR_OP_CTL_SETMEPARAMS_API_STRUCT_SIZE_INCORRECT        = 0x22,
     IVE_ERR_IP_CTL_SETIPEPARAMS_API_STRUCT_SIZE_INCORRECT       = 0x23,
     IVE_ERR_OP_CTL_SETIPEPARAMS_API_STRUCT_SIZE_INCORRECT       = 0x24,
     IVE_ERR_IP_CTL_SETGOPPARAMS_API_STRUCT_SIZE_INCORRECT       = 0x25,
     IVE_ERR_OP_CTL_SETGOPPARAMS_API_STRUCT_SIZE_INCORRECT       = 0x26,
     IVE_ERR_IP_CTL_SETDEBLKPARAMS_API_STRUCT_SIZE_INCORRECT     = 0x27,
     IVE_ERR_OP_CTL_SETDEBLKPARAMS_API_STRUCT_SIZE_INCORRECT     = 0x28,
     IVE_ERR_IP_CTL_SETQPPARAMS_API_STRUCT_SIZE_INCORRECT        = 0x29,
     IVE_ERR_OP_CTL_SETQPPARAMS_API_STRUCT_SIZE_INCORRECT        = 0x2A,
     IVE_ERR_FILL_NUM_MEM_RECS_POINTER_NULL                      = 0x2B,
     IVE_ERR_NUM_MEM_REC_NOT_SUFFICIENT                          = 0x2C,
     IVE_ERR_MEM_REC_STRUCT_SIZE_INCORRECT                       = 0x2D,
     IVE_ERR_MEM_REC_BASE_POINTER_NULL                           = 0x2E,
     IVE_ERR_MEM_REC_OVERLAP_ERR                                 = 0x2F,
     IVE_ERR_MEM_REC_INSUFFICIENT_SIZE                           = 0x30,
     IVE_ERR_MEM_REC_ALIGNMENT_ERR                               = 0x31,
     IVE_ERR_MEM_REC_INCORRECT_TYPE                              = 0x32,
     IVE_ERR_HANDLE_NULL                                         = 0x33,
     IVE_ERR_HANDLE_STRUCT_SIZE_INCORRECT                        = 0x34,
     IVE_ERR_API_FUNCTION_PTR_NULL                               = 0x35,
     IVE_ERR_INVALID_CODEC_HANDLE                                = 0x36,
     IVE_ERR_CTL_GET_VERSION_BUFFER_IS_NULL                      = 0x37,
     IVE_ERR_IP_CTL_SETAIRPARAMS_API_STRUCT_SIZE_INCORRECT       = 0x38,
     IVE_ERR_OP_CTL_SETAIRPARAMS_API_STRUCT_SIZE_INCORRECT       = 0x39,
     IVE_ERR_IP_CTL_SETENCMODE_API_STRUCT_SIZE_INCORRECT         = 0x3A,
     IVE_ERR_OP_CTL_SETENCMODE_API_STRUCT_SIZE_INCORRECT         = 0x3B,
     IVE_ERR_IP_CTL_SETVBVPARAMS_API_STRUCT_SIZE_INCORRECT       = 0x3C,
     IVE_ERR_OP_CTL_SETVBVPARAMS_API_STRUCT_SIZE_INCORRECT       = 0x3D,
     IVE_ERR_IP_CTL_SETPROFILE_API_STRUCT_SIZE_INCORRECT         = 0x3E,
     IVE_ERR_OP_CTL_SETPROFILE_API_STRUCT_SIZE_INCORRECT         = 0x3F,
     IVE_ERR_IP_CTL_SET_VUI_STRUCT_SIZE_INCORRECT                = 0x40,
     IVE_ERR_OP_CTL_SET_VUI_STRUCT_SIZE_INCORRECT                = 0x41,
     IVE_ERR_IP_CTL_SET_SEI_MDCV_STRUCT_SIZE_INCORRECT           = 0x42,
     IVE_ERR_OP_CTL_SET_SEI_MDCV_STRUCT_SIZE_INCORRECT           = 0x43,
     IVE_ERR_IP_CTL_SET_SEI_CLL_STRUCT_SIZE_INCORRECT            = 0x44,
     IVE_ERR_OP_CTL_SET_SEI_CLL_STRUCT_SIZE_INCORRECT            = 0x45,
     IVE_ERR_IP_CTL_SET_SEI_AVE_STRUCT_SIZE_INCORRECT            = 0x46,
     IVE_ERR_OP_CTL_SET_SEI_AVE_STRUCT_SIZE_INCORRECT            = 0x47,
     IVE_ERR_IP_CTL_SET_SEI_CCV_STRUCT_SIZE_INCORRECT            = 0x48,
     IVE_ERR_OP_CTL_SET_SEI_CCV_STRUCT_SIZE_INCORRECT            = 0x49,
+    IVE_ERR_IP_CTL_SET_SEI_SII_STRUCT_SIZE_INCORRECT            = 0x4A,
+    IVE_ERR_OP_CTL_SET_SEI_SII_STRUCT_SIZE_INCORRECT            = 0x4B,
 }IVE_ERROR_CODES_T;
 
 
 /*****************************************************************************/
 /*   Initialize encoder                                                      */
 /*****************************************************************************/
 
 /** Input structure : Initialize the encoder                                */
diff --git a/fuzzer/avc_enc_fuzzer.cpp b/fuzzer/avc_enc_fuzzer.cpp
index ce36756..f9d5372 100644
--- a/fuzzer/avc_enc_fuzzer.cpp
+++ b/fuzzer/avc_enc_fuzzer.cpp
@@ -57,46 +57,47 @@ constexpr size_t kMaxBitrate = 500000000;
 enum {
     IDX_WD_BYTE_1,
     IDX_WD_BYTE_2,
     IDX_HT_BYTE_1,
     IDX_HT_BYTE_2,
     IDX_COLOR_FORMAT,
     IDX_ARCH_TYPE,
     IDX_RC_MODE,
     IDX_NUM_CORES,
     IDX_NUM_B_FRAMES,
     IDX_ENC_SPEED,
     IDX_CONSTRAINED_INTRA_FLAG,
     IDX_INTRA_4x4,
     IDX_I_FRAME_QP,
     IDX_P_FRAME_QP,
     IDX_B_FRAME_QP,
     IDX_BITRATE_BYTE_1,
     IDX_BITRATE_BYTE_2,
     IDX_FRAME_RATE,
     IDX_INTRA_REFRESH,
     IDX_ENABLE_HALF_PEL,
     IDX_ENABLE_Q_PEL,
     IDX_ME_SPEED_PRESET,
     IDX_AIR_MODE,
     IDX_DISABLE_DEBLOCK_LEVEL,
     IDX_SEARCH_RANGE_X,
     IDX_SEARCH_RANGE_Y,
     IDX_I_INTERVAL,
     IDX_IDR_INTERVAL,
     IDX_SEI_MDCV_FLAG,
     IDX_SEI_CLL_FLAG,
     IDX_SEI_AVE_FLAG,
     IDX_SEI_CCV_FLAG,
+    IDX_SEI_SII_FLAG,
     IDX_PROFILE,
     IDX_ASPECT_RATIO_FLAG,
     IDX_NAL_HRD_FLAG,
     IDX_VCL_HRD_FLAG,
     IDX_ENABLE_FORCE_IDR,
     IDX_ENABLE_DYNAMIC_BITRATE,
     IDX_ENABLE_DYNAMIC_FRAME_RATE,
     IDX_FORCE_IDR_INTERVAL,
     IDX_DYNAMIC_BITRATE_INTERVAL,
     IDX_DYNAMIC_FRAME_RATE_INTERVAL,
     IDX_SEND_EOS_WITH_LAST_FRAME,
     IDX_LAST
 };
@@ -104,82 +105,84 @@ enum {
 class Codec {
    public:
     Codec() = default;
     ~Codec() { deInitEncoder(); }
     bool initEncoder(const uint8_t **pdata, size_t *psize);
     void encodeFrames(const uint8_t *data, size_t size);
     void deInitEncoder();
 
    private:
     bufferPtrs setEncParams(iv_raw_buf_t *psInpRawBuf, const uint8_t *data, size_t frameSize);
     void setFrameType(IV_PICTURE_CODING_TYPE_T eFrameType);
     void setQp();
     void setEncMode(IVE_ENC_MODE_T eEncMode);
     void setDimensions();
     void setNumCores();
     void setFrameRate();
     void setIpeParams();
     void setBitRate();
     void setAirParams();
     void setMeParams();
     void setGopParams();
     void setProfileParams();
     void setDeblockParams();
     void setVbvParams();
     void setDefault();
     void setVuiParams();
     void getBufInfo();
     void setSeiMdcvParams();
     void setSeiCllParams();
     void setSeiAveParams();
     void setSeiCcvParams();
+    void setSeiSiiParams();
     void logVersion();
     bool mHalfPelEnable = 1;
     bool mQPelEnable = 1;
     bool mIntra4x4 = 0;
     bool mEnableFastSad = 0;
     bool mEnableAltRef = 0;
     bool mConstrainedIntraFlag = 0;
     bool mSeiCllFlag = 1;
     bool mSeiAveFlag = 1;
     bool mSeiCcvFlag = 1;
     bool mSeiMdcvFlag = 1;
+    bool mSeiSiiFlag = 1;
     bool mAspectRatioFlag = 0;
     bool mNalHrdFlag = 0;
     bool mVclHrdFlag = 0;
     bool mIsForceIdrEnabled = false;
     bool mIsDynamicBitRateChangeEnabled = false;
     bool mIsDynamicFrameRateChangeEnabled = false;
     bool mSendEosWithLastFrame = false;
     uint32_t mWidth = 2560;
     uint32_t mHeight = 2560;
     uint32_t mAvcEncLevel = 41;
     uint32_t mNumMemRecords = 0;
     uint32_t mNumCores = 1;
     uint32_t mBframes = 0;
     uint32_t mSliceParam = 256;
     uint32_t mMeSpeedPreset = 100;
     uint32_t mIInterval = 60;
     uint32_t mIDRInterval = 60;
     uint32_t mDisableDeblockLevel = 0;
     uint32_t m_I_QP = 22;
     uint32_t m_P_QP = 28;
     uint32_t m_B_QP = 22;
     uint32_t mIntraRefresh = 30;
     uint32_t mSearchRangeX = 64;
     uint32_t mSearchRangeY = 48;
     uint32_t mForceIdrInterval = 0;          // in number of frames
     uint32_t mDynamicBitRateInterval = 0;    // in number of frames
     uint32_t mDynamicFrameRateInterval = 0;  // in number of frames
     uint64_t mBitrate = 6000000;
     float mFrameRate = 30;
     iv_obj_t *mCodecCtx = nullptr;
     iv_mem_rec_t *mMemRecords = nullptr;
     IVE_AIR_MODE_T mAirMode = IVE_AIR_MODE_NONE;
     IVE_SPEED_CONFIG mEncSpeed = IVE_NORMAL;
     IVE_RC_MODE_T mRCMode = IVE_RC_STORAGE;
     IV_ARCH_T mArch = ARCH_NA;
     IVE_SLICE_MODE_T mSliceMode = IVE_SLICE_MODE_NONE;
     IV_COLOR_FORMAT_T mIvVideoColorFormat = IV_YUV_420P;
     IV_COLOR_FORMAT_T mReconFormat = IV_YUV_420P;
     IV_PROFILE_T mProfile = IV_PROFILE_BASE;
 };
@@ -187,168 +190,170 @@ class Codec {
 bool Codec::initEncoder(const uint8_t **pdata, size_t *psize) {
     uint8_t *data = const_cast<uint8_t *>(*pdata);
     mWidth = ((data[IDX_WD_BYTE_1] << 8) | data[IDX_WD_BYTE_2]) % kMaxWidth;
     mHeight = ((data[IDX_HT_BYTE_1] << 8) | data[IDX_HT_BYTE_2]) % kMaxHeight;
 
     mIvVideoColorFormat =
         kSupportedColorFormats[data[IDX_COLOR_FORMAT] % kSupportedColorFormatsNum];
     mArch = ((data[IDX_ARCH_TYPE] & 0x03) == 0x00) ? ARCH_ARM_NONEON : ARCH_NA;
     mRCMode = kRCMode[data[IDX_RC_MODE] % kRCModeNum];
     mNumCores = (data[IDX_NUM_CORES] & 0x07) + 1;
     mBframes = data[IDX_NUM_B_FRAMES] & 0x07;
     mEncSpeed = kEncSpeed[data[IDX_ENC_SPEED] % kEncSpeedNum];
     mConstrainedIntraFlag = data[IDX_CONSTRAINED_INTRA_FLAG] & 0x01;
     mIntra4x4 = data[IDX_INTRA_4x4] & 0x01;
     m_I_QP = (data[IDX_I_FRAME_QP] % (MAX_H264_QP - kMinQP)) + kMinQP;
     m_P_QP = (data[IDX_P_FRAME_QP] % (MAX_H264_QP - kMinQP)) + kMinQP;
     m_B_QP = (data[IDX_B_FRAME_QP] % (MAX_H264_QP - kMinQP)) + kMinQP;
     mBitrate = (((data[IDX_BITRATE_BYTE_1] << 8) | data[IDX_BITRATE_BYTE_2]) * 1000) % kMaxBitrate;
     mFrameRate = data[IDX_FRAME_RATE];
     mIntraRefresh = data[IDX_INTRA_REFRESH] + 1;
     mHalfPelEnable = data[IDX_ENABLE_HALF_PEL] & 0x01;
     mQPelEnable = data[IDX_ENABLE_Q_PEL] & 0x01;
     mMeSpeedPreset = kMeSpeedPreset[data[IDX_ME_SPEED_PRESET] % kMeSpeedPresetNum];
     mAirMode = kAirMode[data[IDX_AIR_MODE] % kAirModeNum];
     mDisableDeblockLevel = data[IDX_DISABLE_DEBLOCK_LEVEL] & 0x03;
     mSearchRangeX = data[IDX_SEARCH_RANGE_X];
     mSearchRangeY = data[IDX_SEARCH_RANGE_Y];
     mIInterval = data[IDX_I_INTERVAL] + 1;
     mIDRInterval = data[IDX_IDR_INTERVAL] + 1;
     mSeiMdcvFlag = data[IDX_SEI_MDCV_FLAG] & 0x01;
     mSeiCllFlag = data[IDX_SEI_CLL_FLAG] & 0x01;
     mSeiAveFlag = data[IDX_SEI_AVE_FLAG] & 0x01;
     mSeiCcvFlag = data[IDX_SEI_CCV_FLAG] & 0x01;
+    mSeiSiiFlag = data[IDX_SEI_SII_FLAG] & 0x01;
     mProfile = kProfle[data[IDX_PROFILE] % kProfleNum];
     mAspectRatioFlag = data[IDX_ASPECT_RATIO_FLAG] & 0x01;
     mNalHrdFlag = data[IDX_NAL_HRD_FLAG] & 0x01;
     mVclHrdFlag = data[IDX_VCL_HRD_FLAG] & 0x01;
     mIsForceIdrEnabled = data[IDX_ENABLE_FORCE_IDR] & 0x01;
     mIsDynamicBitRateChangeEnabled = data[IDX_ENABLE_DYNAMIC_BITRATE] & 0x01;
     mIsDynamicFrameRateChangeEnabled = data[IDX_ENABLE_DYNAMIC_FRAME_RATE] & 0x01;
     mSendEosWithLastFrame = data[IDX_SEND_EOS_WITH_LAST_FRAME] & 0x01;
     mForceIdrInterval = data[IDX_FORCE_IDR_INTERVAL] & 0x07;
     mDynamicBitRateInterval = data[IDX_DYNAMIC_BITRATE_INTERVAL] & 0x07;
     mDynamicFrameRateInterval = data[IDX_DYNAMIC_FRAME_RATE_INTERVAL] & 0x07;
 
     /* Getting Number of MemRecords */
     iv_num_mem_rec_ip_t sNumMemRecIp{};
     iv_num_mem_rec_op_t sNumMemRecOp{};
 
     sNumMemRecIp.u4_size = sizeof(iv_num_mem_rec_ip_t);
     sNumMemRecOp.u4_size = sizeof(iv_num_mem_rec_op_t);
     sNumMemRecIp.e_cmd = IV_CMD_GET_NUM_MEM_REC;
 
     if (IV_SUCCESS != ive_api_function(nullptr, &sNumMemRecIp, &sNumMemRecOp)) {
         return false;
     }
     mNumMemRecords = sNumMemRecOp.u4_num_mem_rec;
     mMemRecords = (iv_mem_rec_t *)malloc(mNumMemRecords * sizeof(iv_mem_rec_t));
     if (!mMemRecords) {
         return false;
     }
     iv_mem_rec_t *psMemRec;
     psMemRec = mMemRecords;
     for (size_t i = 0; i < mNumMemRecords; ++i) {
         psMemRec->u4_size = sizeof(iv_mem_rec_t);
         psMemRec->pv_base = nullptr;
         psMemRec->u4_mem_size = 0;
         psMemRec->u4_mem_alignment = 0;
         psMemRec->e_mem_type = IV_NA_MEM_TYPE;
         ++psMemRec;
     }
 
     /* Getting MemRecords Attributes */
     iv_fill_mem_rec_ip_t sFillMemRecIp{};
     iv_fill_mem_rec_op_t sFillMemRecOp{};
 
     sFillMemRecIp.u4_size = sizeof(iv_fill_mem_rec_ip_t);
     sFillMemRecOp.u4_size = sizeof(iv_fill_mem_rec_op_t);
 
     sFillMemRecIp.e_cmd = IV_CMD_FILL_NUM_MEM_REC;
     sFillMemRecIp.ps_mem_rec = mMemRecords;
     sFillMemRecIp.u4_num_mem_rec = mNumMemRecords;
     sFillMemRecIp.u4_max_wd = mWidth;
     sFillMemRecIp.u4_max_ht = mHeight;
     sFillMemRecIp.u4_max_level = mAvcEncLevel;
     sFillMemRecIp.e_color_format = IV_YUV_420SP_VU;
     sFillMemRecIp.u4_max_ref_cnt = 2;
     sFillMemRecIp.u4_max_reorder_cnt = 0;
     sFillMemRecIp.u4_max_srch_rng_x = 256;
     sFillMemRecIp.u4_max_srch_rng_y = 256;
 
     if (IV_SUCCESS != ive_api_function(nullptr, &sFillMemRecIp, &sFillMemRecOp)) {
         return false;
     }
     /* Allocating Memory for Mem Records */
     psMemRec = mMemRecords;
     for (size_t i = 0; i < mNumMemRecords; ++i) {
         posix_memalign(&psMemRec->pv_base, psMemRec->u4_mem_alignment, psMemRec->u4_mem_size);
         if (!psMemRec->pv_base) {
             return false;
         }
         ++psMemRec;
     }
 
     /* Codec Instance Creation */
     ive_init_ip_t sInitIp{};
     ive_init_op_t sInitOp{};
 
     mCodecCtx = (iv_obj_t *)mMemRecords[0].pv_base;
     mCodecCtx->u4_size = sizeof(iv_obj_t);
     mCodecCtx->pv_fxns = (void *)ive_api_function;
 
     sInitIp.u4_size = sizeof(ive_init_ip_t);
     sInitOp.u4_size = sizeof(ive_init_op_t);
 
     sInitIp.e_cmd = IV_CMD_INIT;
     sInitIp.u4_num_mem_rec = mNumMemRecords;
     sInitIp.ps_mem_rec = mMemRecords;
     sInitIp.u4_max_wd = mWidth;
     sInitIp.u4_max_ht = mHeight;
     sInitIp.u4_max_ref_cnt = 2;
     sInitIp.u4_max_reorder_cnt = 0;
     sInitIp.u4_max_level = mAvcEncLevel;
     sInitIp.e_inp_color_fmt = mIvVideoColorFormat;
     sInitIp.u4_enable_recon = 0;
     sInitIp.e_recon_color_fmt = mReconFormat;
     sInitIp.e_rc_mode = mRCMode;
     sInitIp.u4_max_framerate = 120000;
     sInitIp.u4_max_bitrate = 240000000;
     sInitIp.u4_num_bframes = mBframes;
     sInitIp.e_content_type = IV_PROGRESSIVE;
     sInitIp.u4_max_srch_rng_x = 256;
     sInitIp.u4_max_srch_rng_y = 256;
     sInitIp.e_slice_mode = mSliceMode;
     sInitIp.u4_slice_param = mSliceParam;
     sInitIp.e_arch = mArch;
     sInitIp.e_soc = SOC_GENERIC;
 
     if (IV_SUCCESS != ive_api_function(mCodecCtx, &sInitIp, &sInitOp)) {
         return false;
     }
 
     logVersion();
     setDefault();
     getBufInfo();
     setNumCores();
     setDimensions();
     setFrameRate();
     setIpeParams();
     setBitRate();
     setQp();
     setAirParams();
     setVbvParams();
     setMeParams();
     setGopParams();
     setDeblockParams();
     setVuiParams();
     setSeiMdcvParams();
     setSeiCllParams();
     setSeiAveParams();
     setSeiCcvParams();
+    setSeiSiiParams();
     setProfileParams();
     setEncMode(IVE_ENC_MODE_HEADER);
 
     *pdata += IDX_LAST;
     *psize -= IDX_LAST;
     return true;
 }
@@ -824,6 +829,37 @@ void Codec::setSeiCcvParams() {
     return;
 }
 
+void Codec::setSeiSiiParams() {
+    ih264e_ctl_set_sei_sii_params_ip_t sSeiSiiParamsIp{};
+    ih264e_ctl_set_sei_sii_params_op_t sSeiSiiParamsOp{};
+
+    sSeiSiiParamsIp.e_cmd = IVE_CMD_VIDEO_CTL;
+    sSeiSiiParamsIp.e_sub_cmd = IVE_CMD_CTL_SET_SEI_SII_PARAMS;
+    sSeiSiiParamsIp.u1_shutter_interval_info_present_flag = mSeiSiiFlag;
+    if(mSeiSiiFlag) {
+        sSeiSiiParamsIp.u4_sii_sub_layer_idx = 0;
+        sSeiSiiParamsIp.u1_shutter_interval_info_present_flag = 1;
+        sSeiSiiParamsIp.u4_sii_time_scale = 24000000;
+        sSeiSiiParamsIp.u1_fixed_shutter_interval_within_cvs_flag = 0;
+        sSeiSiiParamsIp.u4_sii_num_units_in_shutter_interval = 480000;
+        sSeiSiiParamsIp.u1_sii_max_sub_layers_minus1 = 7;
+        for(int i4_count = 0; i4_count <= sSeiSiiParamsIp.u1_sii_max_sub_layers_minus1; ++i4_count) {
+            sSeiSiiParamsIp.au4_sub_layer_num_units_in_shutter_interval[i4_count] = 480000;
+        }
+        sSeiSiiParamsIp.au4_sub_layer_num_units_in_shutter_interval
+            [sSeiSiiParamsIp.u1_sii_max_sub_layers_minus1] = 240000;
+    }
+
+    sSeiSiiParamsIp.u4_timestamp_high = -1;
+    sSeiSiiParamsIp.u4_timestamp_low = -1;
+
+    sSeiSiiParamsIp.u4_size = sizeof(ih264e_ctl_set_sei_sii_params_ip_t);
+    sSeiSiiParamsOp.u4_size = sizeof(ih264e_ctl_set_sei_sii_params_op_t);
+
+    ih264e_api_function(mCodecCtx, &sSeiSiiParamsIp, &sSeiSiiParamsOp);
+    return;
+}
+
 void Codec::logVersion() {
     ive_ctl_getversioninfo_ip_t sCtlIp{};
     ive_ctl_getversioninfo_op_t sCtlOp{};
diff --git a/test/decoder/main.c b/test/decoder/main.c
index bddf0b8..38083b1 100644
--- a/test/decoder/main.c
+++ b/test/decoder/main.c
@@ -1680,249 +1680,274 @@ void output_write_stall(CHAR *fname, UWORD32 cur_frm_idx)
 void flush_output(iv_obj_t *codec_obj,
                   vid_dec_ctx_t *ps_app_ctx,
                   ivd_out_bufdesc_t *ps_out_buf,
                   UWORD8 *pu1_bs_buf,
                   UWORD32 *pu4_op_frm_ts,
                   FILE *ps_op_file,
                   FILE *ps_qp_file,
                   FILE *ps_mb_type_file,
                   UWORD8 *pu1_qp_map_buf,
                   UWORD8 *pu1_blk_type_map_buf,
                   FILE *ps_op_chksum_file,
                   UWORD32 u4_ip_frm_ts,
                   UWORD32 u4_bytes_remaining)
 {
     WORD32 ret;
 
     do
     {
 
         ivd_ctl_flush_ip_t s_ctl_ip;
         ivd_ctl_flush_op_t s_ctl_op;
 
         if(*pu4_op_frm_ts >= (ps_app_ctx->u4_max_frm_ts + ps_app_ctx->disp_delay))
             break;
 
         s_ctl_ip.e_cmd = IVD_CMD_VIDEO_CTL;
         s_ctl_ip.e_sub_cmd = IVD_CMD_CTL_FLUSH;
         s_ctl_ip.u4_size = sizeof(ivd_ctl_flush_ip_t);
         s_ctl_op.u4_size = sizeof(ivd_ctl_flush_op_t);
         ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_ctl_ip,
                                    (void *)&s_ctl_op);
 
         if(ret != IV_SUCCESS)
         {
             printf("Error in Setting the decoder in flush mode\n");
         }
 
         if(IV_SUCCESS == ret)
         {
             ih264d_video_decode_ip_t s_h264d_decode_ip = {};
             ih264d_video_decode_op_t s_h264d_decode_op = {};
             ivd_video_decode_ip_t *ps_video_decode_ip = &s_h264d_decode_ip.s_ivd_video_decode_ip_t;
             ivd_video_decode_op_t *ps_video_decode_op = &s_h264d_decode_op.s_ivd_video_decode_op_t;
 
             ps_video_decode_ip->e_cmd = IVD_CMD_VIDEO_DECODE;
             ps_video_decode_ip->u4_ts = u4_ip_frm_ts;
             ps_video_decode_ip->pv_stream_buffer = pu1_bs_buf;
             ps_video_decode_ip->u4_num_Bytes = u4_bytes_remaining;
             ps_video_decode_ip->u4_size = sizeof(ih264d_video_decode_ip_t);
             ps_video_decode_ip->s_out_buffer.u4_min_out_buf_size[0] =
                             ps_out_buf->u4_min_out_buf_size[0];
             ps_video_decode_ip->s_out_buffer.u4_min_out_buf_size[1] =
                             ps_out_buf->u4_min_out_buf_size[1];
             ps_video_decode_ip->s_out_buffer.u4_min_out_buf_size[2] =
                             ps_out_buf->u4_min_out_buf_size[2];
 
             ps_video_decode_ip->s_out_buffer.pu1_bufs[0] =
                             ps_out_buf->pu1_bufs[0];
             ps_video_decode_ip->s_out_buffer.pu1_bufs[1] =
                             ps_out_buf->pu1_bufs[1];
             ps_video_decode_ip->s_out_buffer.pu1_bufs[2] =
                             ps_out_buf->pu1_bufs[2];
             ps_video_decode_ip->s_out_buffer.u4_num_bufs =
                             ps_out_buf->u4_num_bufs;
 
             ps_video_decode_op->u4_size = sizeof(ih264d_video_decode_op_t);
             s_h264d_decode_ip.pu1_8x8_blk_qp_map = pu1_qp_map_buf;
             s_h264d_decode_ip.pu1_8x8_blk_type_map = pu1_blk_type_map_buf;
             s_h264d_decode_ip.u4_8x8_blk_qp_map_size = (ADAPTIVE_MAX_HT * ADAPTIVE_MAX_WD) >> 6;
             s_h264d_decode_ip.u4_8x8_blk_type_map_size = (ADAPTIVE_MAX_HT * ADAPTIVE_MAX_WD) >> 6;
 
             /*****************************************************************************/
             /*   API Call: Video Decode                                                  */
             /*****************************************************************************/
             ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_h264d_decode_ip,
                                        (void *)&s_h264d_decode_op);
 
             if(1 == ps_video_decode_op->u4_output_present)
             {
                 CHAR cur_fname[1000];
                 CHAR *extn = NULL;
                 /* The objective is to dump the decoded frames into separate files instead of
                  * dumping all the frames in one common file. Also, the number of dumped frames
                  * at any given instance of time cannot exceed 'frame_memory'
                  */
 
                 /*************************************************************************/
                 /* Get SEI MDCV parameters                                               */
                 /*************************************************************************/
                 if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_mdcv_params_present_flag)
                 {
                     ih264d_ctl_get_sei_mdcv_params_ip_t s_ctl_get_sei_mdcv_params_ip;
                     ih264d_ctl_get_sei_mdcv_params_op_t s_ctl_get_sei_mdcv_params_op;
 
                     memset(&s_ctl_get_sei_mdcv_params_ip, 0,
                                         sizeof(ih264d_ctl_get_sei_mdcv_params_ip_t));
                     memset(&s_ctl_get_sei_mdcv_params_op, 0,
                                         sizeof(ih264d_ctl_get_sei_mdcv_params_op_t));
 
                     s_ctl_get_sei_mdcv_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                     s_ctl_get_sei_mdcv_params_ip.e_sub_cmd =
                             (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_SEI_MDCV_PARAMS;
                     s_ctl_get_sei_mdcv_params_ip.u4_size =
                             sizeof(ih264d_ctl_get_sei_mdcv_params_ip_t);
                     s_ctl_get_sei_mdcv_params_op.u4_size =
                             sizeof(ih264d_ctl_get_sei_mdcv_params_op_t);
 
                     ret = ivd_api_function((iv_obj_t *)codec_obj,
                                             (void *)&s_ctl_get_sei_mdcv_params_ip,
                                             (void *)&s_ctl_get_sei_mdcv_params_op);
 
                     if(IV_SUCCESS != ret)
                     {
                         printf("MDCV SEI params not present : Error %x\n",
                                  s_ctl_get_sei_mdcv_params_op.u4_error_code);
                     }
                 }
                 /*************************************************************************/
                 /* Get SEI CLL parameters                                                */
                 /*************************************************************************/
                 if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_cll_params_present_flag)
                 {
                     ih264d_ctl_get_sei_cll_params_ip_t s_ctl_get_sei_cll_params_ip;
                     ih264d_ctl_get_sei_cll_params_op_t s_ctl_get_sei_cll_params_op;
 
                     memset(&s_ctl_get_sei_cll_params_ip, 0,
                                         sizeof(ih264d_ctl_get_sei_cll_params_ip_t));
                     memset(&s_ctl_get_sei_cll_params_op, 0,
                                         sizeof(ih264d_ctl_get_sei_cll_params_op_t));
 
                     s_ctl_get_sei_cll_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                     s_ctl_get_sei_cll_params_ip.e_sub_cmd =
                             (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_SEI_CLL_PARAMS;
                     s_ctl_get_sei_cll_params_ip.u4_size =
                             sizeof(ih264d_ctl_get_sei_cll_params_ip_t);
                     s_ctl_get_sei_cll_params_op.u4_size =
                             sizeof(ih264d_ctl_get_sei_cll_params_op_t);
 
                     ret = ivd_api_function((iv_obj_t *)codec_obj,
                                             (void *)&s_ctl_get_sei_cll_params_ip,
                                             (void *)&s_ctl_get_sei_cll_params_op);
 
                     if(IV_SUCCESS != ret)
                     {
                         printf("CLL SEI params not present : Error %x\n",
                                 s_ctl_get_sei_cll_params_op.u4_error_code);
                     }
                 }
                 /*************************************************************************/
                 /* Get SEI AVE parameters                                                */
                 /*************************************************************************/
                 if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_ave_params_present_flag)
                 {
                     ih264d_ctl_get_sei_ave_params_ip_t s_ctl_get_sei_ave_params_ip;
                     ih264d_ctl_get_sei_ave_params_op_t s_ctl_get_sei_ave_params_op;
 
                     memset(&s_ctl_get_sei_ave_params_ip, 0,
                                         sizeof(ih264d_ctl_get_sei_ave_params_ip_t));
                     memset(&s_ctl_get_sei_ave_params_op, 0,
                                         sizeof(ih264d_ctl_get_sei_ave_params_op_t));
 
                     s_ctl_get_sei_ave_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                     s_ctl_get_sei_ave_params_ip.e_sub_cmd =
                             (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_SEI_AVE_PARAMS;
                     s_ctl_get_sei_ave_params_ip.u4_size =
                             sizeof(ih264d_ctl_get_sei_ave_params_ip_t);
                     s_ctl_get_sei_ave_params_op.u4_size =
                             sizeof(ih264d_ctl_get_sei_ave_params_op_t);
 
                     ret = ivd_api_function((iv_obj_t *)codec_obj,
                                             (void *)&s_ctl_get_sei_ave_params_ip,
                                             (void *)&s_ctl_get_sei_ave_params_op);
 
                     if(IV_SUCCESS != ret)
                     {
                         printf("AVE SEI params not present : Error %x\n",
                                 s_ctl_get_sei_ave_params_op.u4_error_code);
                     }
                 }
                 /*************************************************************************/
                 /* Get SEI CCV parameters                                                */
                 /*************************************************************************/
                 if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_ccv_params_present_flag)
                 {
                     ih264d_ctl_get_sei_ccv_params_ip_t s_ctl_get_sei_ccv_params_ip;
                     ih264d_ctl_get_sei_ccv_params_op_t s_ctl_get_sei_ccv_params_op;
 
                     memset(&s_ctl_get_sei_ccv_params_ip, 0,
                                         sizeof(ih264d_ctl_get_sei_ccv_params_ip_t));
                     memset(&s_ctl_get_sei_ccv_params_op, 0,
                                         sizeof(ih264d_ctl_get_sei_ccv_params_op_t));
 
                     s_ctl_get_sei_ccv_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                     s_ctl_get_sei_ccv_params_ip.e_sub_cmd =
                             (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_SEI_CCV_PARAMS;
                     s_ctl_get_sei_ccv_params_ip.u4_size =
                             sizeof(ih264d_ctl_get_sei_ccv_params_ip_t);
                     s_ctl_get_sei_ccv_params_op.u4_size =
                             sizeof(ih264d_ctl_get_sei_ccv_params_op_t);
 
                     ret = ivd_api_function((iv_obj_t *)codec_obj,
                                             (void *)&s_ctl_get_sei_ccv_params_ip,
                                             (void *)&s_ctl_get_sei_ccv_params_op);
 
                     if(IV_SUCCESS != ret)
                     {
                         printf("CCV SEI params not present : Error %x\n",
                                 s_ctl_get_sei_ccv_params_op.u4_error_code);
                     }
                 }
+                /*************************************************************************/
+                /* Get SEI SII parameters                                                */
+                /*************************************************************************/
+                if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_sii_params_present_flag)
+                {
+                    ih264d_ctl_get_sei_sii_params_ip_t s_ctl_get_sei_sii_params_ip = {0};
+                    ih264d_ctl_get_sei_sii_params_op_t s_ctl_get_sei_sii_params_op = {0};
+
+                    s_ctl_get_sei_sii_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
+                    s_ctl_get_sei_sii_params_ip.e_sub_cmd =
+                        (IVD_CONTROL_API_COMMAND_TYPE_T) IH264D_CMD_CTL_GET_SEI_SII_PARAMS;
+                    s_ctl_get_sei_sii_params_ip.u4_size =
+                        sizeof(ih264d_ctl_get_sei_sii_params_ip_t);
+                    s_ctl_get_sei_sii_params_op.u4_size =
+                        sizeof(ih264d_ctl_get_sei_sii_params_op_t);
+                    ret = ivd_api_function((iv_obj_t *) codec_obj,
+                                           (void *) &s_ctl_get_sei_sii_params_ip,
+                                           (void *) &s_ctl_get_sei_sii_params_op);
+
+                    if(IV_SUCCESS != ret)
+                    {
+                        printf("SII SEI params not present : Error %x\n",
+                               s_ctl_get_sei_sii_params_op.u4_error_code);
+                    }
+                }
 
                 if(ps_app_ctx->u4_file_save_flag)
                 {
                     /* Locate the position of extension yuv */
                     extn = strstr(ps_app_ctx->ac_op_fname,"%d");
                     if (extn != NULL)
                     {
                         output_write_stall(ps_app_ctx->ac_op_fname,*pu4_op_frm_ts);
                         /* Generate output file names */
                         sprintf(cur_fname,ps_app_ctx->ac_op_fname,*pu4_op_frm_ts);
                         /* Open Output file */
                         ps_op_file = fopen(cur_fname,"wb");
                         if (NULL == ps_op_file)
                         {
                             CHAR ac_error_str[STRLENGTH];
                             snprintf(ac_error_str, sizeof(ac_error_str),
                                 "Could not open output file %s", cur_fname);
 
                             codec_exit(ac_error_str);
                         }
                     }
                 }
 
                 dump_output(ps_app_ctx, &(ps_video_decode_op->s_disp_frm_buf), &s_h264d_decode_op,
                             ps_video_decode_op->u4_disp_buf_id, ps_op_file, ps_qp_file,
                             ps_mb_type_file, ps_op_chksum_file, *pu4_op_frm_ts,
                             ps_app_ctx->u4_file_save_flag, ps_app_ctx->u4_chksum_save_flag,
                             ps_app_ctx->u4_frame_info_enable);
                 if (extn != NULL)
                     fclose(ps_op_file);
                 (*pu4_op_frm_ts)++;
             }
         }
     }
     while(IV_SUCCESS == ret);
 
 }
 
 #ifdef X86_MINGW
@@ -1972,1606 +1997,1630 @@ int h264dec_main(char * homedir,char *documentdir, int screen_wd, int screen_ht)
 #else
 int main(WORD32 argc, CHAR *argv[])
 #endif
 {
     CHAR ac_cfg_fname[STRLENGTH];
     FILE *fp_cfg_file = NULL;
     FILE *ps_piclen_file = NULL;
     FILE *ps_ip_file = NULL;
     FILE *ps_op_file = NULL;
     FILE *ps_qp_file = NULL;
     FILE *ps_mb_type_file = NULL;
     FILE *ps_op_chksum_file = NULL;
     WORD32 ret;
     CHAR ac_error_str[STRLENGTH];
     vid_dec_ctx_t s_app_ctx;
     UWORD8 *pu1_bs_buf = NULL;
     UWORD8 *pu1_qp_map_buf = NULL;
     UWORD8 *pu1_blk_type_map_buf = NULL;
 
     ivd_out_bufdesc_t *ps_out_buf;
     UWORD32 u4_num_bytes_dec = 0;
     UWORD32 file_pos = 0;
 
     UWORD32 u4_ip_frm_ts = 0, u4_op_frm_ts = 0;
 
     WORD32 u4_bytes_remaining = 0;
     UWORD32 i;
     UWORD32 u4_ip_buf_len;
     UWORD32 frm_cnt = 0;
     WORD32 total_bytes_comsumed;
     UWORD32 max_op_frm_ts;
     UWORD32 u4_num_disp_bufs_with_dec;
 
 #ifdef PROFILE_ENABLE
     UWORD32 u4_tot_cycles = 0;
     UWORD32 u4_tot_fmt_cycles = 0;
     UWORD32 peak_window[PEAK_WINDOW_SIZE];
     UWORD32 peak_window_idx = 0;
     UWORD32 peak_avg_max = 0;
 #ifdef INTEL_CE5300
     UWORD32 time_consumed = 0;
     UWORD32 bytes_consumed = 0;
 #endif
 #endif
 
 #ifdef WINDOWS_TIMER
     TIMER frequency;
 #endif
     WORD32 width = 0, height = 0;
     iv_obj_t *codec_obj;
 #if defined(GPU_BUILD) && !defined(X86)
 //    int ioctl_init();
 //    ioctl_init();
 #endif
 
 #ifdef X86_MINGW
     //For getting printfs without any delay
     setvbuf(stdout, NULL, _IONBF, 0);
     setvbuf(stderr, NULL, _IONBF, 0);
 #endif
 #ifdef IOS
         sprintf(filename_trace, "%s/iostrace.txt", homedir );
         printf("\ntrace file name = %s",filename_trace);
 #endif
 
 #ifdef X86_MINGW
     {
         signal(SIGSEGV, sigsegv_handler);
     }
 #endif
 
 
 #ifndef IOS
     /* Usage */
     if(argc < 2)
     {
         printf("Using test.cfg as configuration file \n");
         strcpy(ac_cfg_fname, "test.cfg");
     }
     else if(argc == 2)
     {
         strcpy(ac_cfg_fname, argv[1]);
     }
 
 #else
     strcpy(ac_cfg_fname, "test.cfg");
 
 #endif
 
 
     /***********************************************************************/
     /*                  Initialize Application parameters                  */
     /***********************************************************************/
 
     strcpy(s_app_ctx.ac_ip_fname, "\0");
     s_app_ctx.dump_q_wr_idx = 0;
     s_app_ctx.dump_q_rd_idx = 0;
     s_app_ctx.display_thread_created = 0;
     s_app_ctx.disp_q_wr_idx = 0;
     s_app_ctx.disp_q_rd_idx = 0;
     s_app_ctx.disp_delay = 0;
     s_app_ctx.loopback = 0;
     s_app_ctx.display = 0;
     s_app_ctx.full_screen = 0;
     s_app_ctx.u4_piclen_flag = 0;
     s_app_ctx.fps = DEFAULT_FPS;
     file_pos = 0;
     total_bytes_comsumed = 0;
     u4_ip_frm_ts = 0;
     u4_op_frm_ts = 0;
 #ifdef PROFILE_ENABLE
     memset(peak_window, 0, sizeof(WORD32) * PEAK_WINDOW_SIZE);
 #endif
     s_app_ctx.u4_share_disp_buf = DEFAULT_SHARE_DISPLAY_BUF;
     s_app_ctx.u4_num_cores = DEFAULT_NUM_CORES;
     s_app_ctx.i4_degrade_type = 0;
     s_app_ctx.i4_degrade_pics = 0;
     s_app_ctx.e_arch = ARCH_ARM_A9Q;
     s_app_ctx.e_soc = SOC_GENERIC;
 
     s_app_ctx.u4_strd = STRIDE;
 
     s_app_ctx.display_thread_handle           = malloc(ithread_get_handle_size());
     s_app_ctx.quit          = 0;
     s_app_ctx.paused        = 0;
     //s_app_ctx.u4_output_present = 0;
     s_app_ctx.u4_chksum_save_flag = 0;
     s_app_ctx.u4_frame_info_enable = 0;
 
     s_app_ctx.get_stride = &default_get_stride;
 
     s_app_ctx.get_color_fmt = &default_get_color_fmt;
 
     /* Set function pointers for display */
 #ifdef SDL_DISPLAY
     s_app_ctx.disp_init = &sdl_disp_init;
     s_app_ctx.alloc_disp_buffers = &sdl_alloc_disp_buffers;
     s_app_ctx.display_buffer = &sdl_display;
     s_app_ctx.set_disp_buffers = &sdl_set_disp_buffers;
     s_app_ctx.disp_deinit = &sdl_disp_deinit;
     s_app_ctx.disp_usleep = &sdl_disp_usleep;
     s_app_ctx.get_color_fmt = &sdl_get_color_fmt;
     s_app_ctx.get_stride = &sdl_get_stride;
 #endif
 
 #ifdef FBDEV_DISPLAY
     s_app_ctx.disp_init = &fbd_disp_init;
     s_app_ctx.alloc_disp_buffers = &fbd_alloc_disp_buffers;
     s_app_ctx.display_buffer = &fbd_display;
     s_app_ctx.set_disp_buffers = &fbd_set_disp_buffers;
     s_app_ctx.disp_deinit = &fbd_disp_deinit;
     s_app_ctx.disp_usleep = &fbd_disp_usleep;
     s_app_ctx.get_color_fmt = &fbd_get_color_fmt;
     s_app_ctx.get_stride = &fbd_get_stride;
 #endif
 
 #ifdef INTEL_CE5300
     s_app_ctx.disp_init = &gdl_disp_init;
     s_app_ctx.alloc_disp_buffers = &gdl_alloc_disp_buffers;
     s_app_ctx.display_buffer = &gdl_display;
     s_app_ctx.set_disp_buffers = &gdl_set_disp_buffers;
     s_app_ctx.disp_deinit = &gdl_disp_deinit;
     s_app_ctx.disp_usleep = &gdl_disp_usleep;
     s_app_ctx.get_color_fmt = &gdl_get_color_fmt;
     s_app_ctx.get_stride = &gdl_get_stride;
 #endif
 
 #ifdef IOS_DISPLAY
     s_app_ctx.disp_init = &ios_disp_init;
     s_app_ctx.alloc_disp_buffers = &ios_alloc_disp_buffers;
     s_app_ctx.display_buffer = &ios_display;
     s_app_ctx.set_disp_buffers = &ios_set_disp_buffers;
     s_app_ctx.disp_deinit = &ios_disp_deinit;
     s_app_ctx.disp_usleep = &ios_disp_usleep;
     s_app_ctx.get_color_fmt = &ios_get_color_fmt;
     s_app_ctx.get_stride = &ios_get_stride;
 #endif
 
     s_app_ctx.display_deinit_flag = 0;
     s_app_ctx.e_output_chroma_format = IV_YUV_420SP_UV;
     /*************************************************************************/
     /* Parse arguments                                                       */
     /*************************************************************************/
 
 #ifndef IOS
     /* Read command line arguments */
     if(argc > 2)
     {
         for(i = 1; i < (UWORD32)argc; i += 2)
         {
             if(CONFIG == get_argument(argv[i]))
             {
                 strcpy(ac_cfg_fname, argv[i + 1]);
                 if((fp_cfg_file = fopen(ac_cfg_fname, "r")) == NULL)
                 {
                     snprintf(ac_error_str, sizeof(ac_error_str),
                             "Could not open Configuration file %s", ac_cfg_fname);
                     codec_exit(ac_error_str);
                 }
                 read_cfg_file(&s_app_ctx, fp_cfg_file);
                 fclose(fp_cfg_file);
             }
             else
             {
                 parse_argument(&s_app_ctx, argv[i], argv[i + 1]);
             }
         }
     }
     else
     {
         if((fp_cfg_file = fopen(ac_cfg_fname, "r")) == NULL)
         {
             snprintf(ac_error_str, sizeof(ac_error_str), "Could not open Configuration file %s",
                     ac_cfg_fname);
             codec_exit(ac_error_str);
         }
         read_cfg_file(&s_app_ctx, fp_cfg_file);
         fclose(fp_cfg_file);
     }
 #else
     snprintf(filename_with_path, sizeof(filename_with_path), "%s/%s", homedir, ac_cfg_fname);
     if((fp_cfg_file = fopen(filename_with_path, "r")) == NULL)
     {
         snprintf(ac_error_str, sizeof(ac_error_str),"Could not open Configuration file %s",
                 ac_cfg_fname);
         codec_exit(ac_error_str);
 
     }
     read_cfg_file(&s_app_ctx, fp_cfg_file);
     fclose(fp_cfg_file);
 
 #endif
 #ifdef PRINT_PICSIZE
     /* If the binary is used for only getting number of bytes in each picture, then disable the following features */
     s_app_ctx.u4_piclen_flag = 0;
     s_app_ctx.u4_file_save_flag = 0;
     s_app_ctx.u4_chksum_save_flag = 0;
     s_app_ctx.i4_degrade_pics = 0;
     s_app_ctx.i4_degrade_type = 0;
     s_app_ctx.loopback = 0;
     s_app_ctx.u4_share_disp_buf = 0;
     s_app_ctx.display = 0;
 #endif
 
     /* If display is enabled, then turn off shared mode and get color format that is supported by display */
     if(1 == s_app_ctx.display)
     {
         s_app_ctx.u4_share_disp_buf = 0;
         s_app_ctx.e_output_chroma_format = s_app_ctx.get_color_fmt();
     }
     if(strcmp(s_app_ctx.ac_ip_fname, "\0") == 0)
     {
         printf("\nNo input file given for decoding\n");
         exit(-1);
     }
 
     if(1 == s_app_ctx.u4_frame_info_enable)
     {
         pu1_qp_map_buf = calloc((ADAPTIVE_MAX_HT * ADAPTIVE_MAX_WD) >> 6, 1);
         pu1_blk_type_map_buf = calloc((ADAPTIVE_MAX_HT * ADAPTIVE_MAX_WD) >> 6, 1);
     }
 
 
 
     /***********************************************************************/
     /*          create the file object for input file                      */
     /***********************************************************************/
 #ifdef IOS
    snprintf(filename_with_path, sizeof(filename_with_path), "%s/%s", homedir, s_app_ctx.ac_ip_fname);
    ps_ip_file = fopen(filename_with_path, "rb");
 #else
     ps_ip_file = fopen(s_app_ctx.ac_ip_fname, "rb");
 #endif
     if(NULL == ps_ip_file)
     {
         snprintf(ac_error_str, sizeof(ac_error_str), "Could not open input file %s",
                 s_app_ctx.ac_ip_fname);
         codec_exit(ac_error_str);
     }
     /***********************************************************************/
     /*          create the file object for input file                      */
     /***********************************************************************/
     if(1 == s_app_ctx.u4_piclen_flag)
     {
 #ifdef IOS
         snprintf(filename_with_path, sizeof(filename_with_path), "%s/%s",
                 s_app_ctx.ac_piclen_fname);
         ps_piclen_file = fopen(filename_with_path, "rb");
 #else
         ps_piclen_file = fopen(s_app_ctx.ac_piclen_fname, "rb");
 #endif
         if(NULL == ps_piclen_file)
         {
             snprintf(ac_error_str, sizeof(ac_error_str), "Could not open piclen file %s",
                 s_app_ctx.ac_piclen_fname);
             codec_exit(ac_error_str);
         }
     }
 
     /***********************************************************************/
     /*          create the file object for output file                     */
     /***********************************************************************/
 
     /* If the filename does not contain %d, then output will be dumped to
        a single file and it is opened here */
     if((1 == s_app_ctx.u4_file_save_flag) && (strstr(s_app_ctx.ac_op_fname,"%d") == NULL))
     {
 #ifdef IOS
     snprintf(filename_with_path, sizeof(filename_with_path), "%s/%s", documentdir,
             s_app_ctx.ac_op_fname);
     ps_op_file = fopen(filename_with_path,"wb");
 #else
         ps_op_file = fopen(s_app_ctx.ac_op_fname, "wb");
 #endif
 
         if(NULL == ps_op_file)
         {
             snprintf(ac_error_str, sizeof(ac_error_str), "Could not open output file %s",
                     s_app_ctx.ac_op_fname);
             codec_exit(ac_error_str);
         }
     }
 
     /***********************************************************************/
     /*          create the file object for mbinfo file                     */
     /***********************************************************************/
 
     if(1 == s_app_ctx.u4_frame_info_enable)
     {
 #ifdef IOS
         snprintf(filename_with_path, sizeof(filename_with_path), "%s/%s", documentdir,
                 s_app_ctx.ac_qp_map_fname);
         ps_qp_file = fopen(filename_with_path, "wb");
 
         snprintf(filename_with_path, sizeof(filename_with_path), "%s/%s", documentdir,
                 s_app_ctx.ac_blk_type_map_fname);
         ps_mb_type_file = fopen(filename_with_path, "wb");
 #else
         ps_qp_file = fopen(s_app_ctx.ac_qp_map_fname, "wb");
         ps_mb_type_file = fopen(s_app_ctx.ac_blk_type_map_fname, "wb");
 
 #endif
 
         if(NULL == ps_qp_file)
         {
             snprintf(ac_error_str, sizeof(ac_error_str), "Could not open block_qp map file %s",
                     s_app_ctx.ac_qp_map_fname);
         }
         if(NULL == ps_mb_type_file)
         {
             snprintf(ac_error_str, sizeof(ac_error_str), "Could not open block_type map file %s",
                     s_app_ctx.ac_blk_type_map_fname);
         }
     }
 
     /***********************************************************************/
     /*          create the file object for check sum file                  */
     /***********************************************************************/
     if(1 == s_app_ctx.u4_chksum_save_flag)
     {
 #if IOS
         snprintf(filename_with_path, sizeof(filename_with_path), "%s/%s", documentdir,
                 s_app_ctx.ac_op_chksum_fname);
         ps_op_chksum_file = fopen(filename_with_path,"wb");
 #else
         ps_op_chksum_file = fopen(s_app_ctx.ac_op_chksum_fname, "wb");
 #endif
         if(NULL == ps_op_chksum_file)
         {
             snprintf(ac_error_str, sizeof(ac_error_str), "Could not open check sum file %s",
                     s_app_ctx.ac_op_chksum_fname);
             codec_exit(ac_error_str);
         }
     }
     /***********************************************************************/
     /*                      Create decoder instance                        */
     /***********************************************************************/
     {
 
         ps_out_buf = (ivd_out_bufdesc_t *)malloc(sizeof(ivd_out_bufdesc_t));
 
         /*****************************************************************************/
         /*   API Call: Initialize the Decoder                                        */
         /*****************************************************************************/
         {
             ih264d_create_ip_t s_create_ip = {};
             ih264d_create_op_t s_create_op = {};
             void *fxns = &ivd_api_function;
 
             s_create_ip.s_ivd_create_ip_t.e_cmd = IVD_CMD_CREATE;
             s_create_ip.s_ivd_create_ip_t.u4_share_disp_buf = s_app_ctx.u4_share_disp_buf;
             s_create_ip.s_ivd_create_ip_t.e_output_format = (IV_COLOR_FORMAT_T)s_app_ctx.e_output_chroma_format;
             s_create_ip.s_ivd_create_ip_t.pf_aligned_alloc = ih264a_aligned_malloc;
             s_create_ip.s_ivd_create_ip_t.pf_aligned_free = ih264a_aligned_free;
             s_create_ip.s_ivd_create_ip_t.pv_mem_ctxt = NULL;
             s_create_ip.s_ivd_create_ip_t.u4_size = sizeof(ih264d_create_ip_t);
             s_create_op.s_ivd_create_op_t.u4_size = sizeof(ih264d_create_op_t);
             s_create_ip.u4_enable_frame_info = s_app_ctx.u4_frame_info_enable;
 
 
 
             ret = ivd_api_function(NULL, (void *)&s_create_ip,
                                        (void *)&s_create_op);
             if(ret != IV_SUCCESS)
             {
                 sprintf(ac_error_str, "Error in Create %8x\n",
                         s_create_op.s_ivd_create_op_t.u4_error_code);
                 codec_exit(ac_error_str);
             }
             codec_obj = (iv_obj_t*)s_create_op.s_ivd_create_op_t.pv_handle;
             codec_obj->pv_fxns = fxns;
             codec_obj->u4_size = sizeof(iv_obj_t);
             s_app_ctx.cocodec_obj = codec_obj;
 
             /*****************************************************************************/
             /*  set stride                                                               */
             /*****************************************************************************/
             {
                 ih264d_ctl_set_config_ip_t s_h264d_ctl_ip = {};
                 ih264d_ctl_set_config_op_t s_h264d_ctl_op = {};
                 ivd_ctl_set_config_ip_t *ps_ctl_ip = &s_h264d_ctl_ip.s_ivd_ctl_set_config_ip_t;
                 ivd_ctl_set_config_op_t *ps_ctl_op = &s_h264d_ctl_op.s_ivd_ctl_set_config_op_t;
 
 
                 ps_ctl_ip->u4_disp_wd = STRIDE;
                 if(1 == s_app_ctx.display)
                     ps_ctl_ip->u4_disp_wd = s_app_ctx.get_stride();
 
                 ps_ctl_ip->e_frm_skip_mode = IVD_SKIP_NONE;
                 ps_ctl_ip->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;
                 ps_ctl_ip->e_vid_dec_mode = IVD_DECODE_HEADER;
                 ps_ctl_ip->e_cmd = IVD_CMD_VIDEO_CTL;
                 ps_ctl_ip->e_sub_cmd = IVD_CMD_CTL_SETPARAMS;
                 ps_ctl_ip->u4_size = sizeof(ih264d_ctl_set_config_ip_t);
                 ps_ctl_op->u4_size = sizeof(ih264d_ctl_set_config_op_t);
 
                 ret = ivd_api_function((iv_obj_t*)codec_obj, (void *)&s_h264d_ctl_ip,
                                            (void *)&s_h264d_ctl_op);
                 if(ret != IV_SUCCESS)
                 {
                     sprintf(ac_error_str,
                             "\nError in setting the stride");
                     codec_exit(ac_error_str);
                 }
             }
 
 
 
         }
 
     }
 
 
     /*************************************************************************/
     /* set num of cores                                                      */
     /*************************************************************************/
     {
 
         ih264d_ctl_set_num_cores_ip_t s_ctl_set_cores_ip;
         ih264d_ctl_set_num_cores_op_t s_ctl_set_cores_op;
 
         s_ctl_set_cores_ip.e_cmd = IVD_CMD_VIDEO_CTL;
         s_ctl_set_cores_ip.e_sub_cmd =(IVD_CONTROL_API_COMMAND_TYPE_T) IH264D_CMD_CTL_SET_NUM_CORES;
         s_ctl_set_cores_ip.u4_num_cores = s_app_ctx.u4_num_cores;
         s_ctl_set_cores_ip.u4_size = sizeof(ih264d_ctl_set_num_cores_ip_t);
         s_ctl_set_cores_op.u4_size = sizeof(ih264d_ctl_set_num_cores_op_t);
 
         ret = ivd_api_function((iv_obj_t*)codec_obj, (void *)&s_ctl_set_cores_ip,
                                    (void *)&s_ctl_set_cores_op);
         if(ret != IV_SUCCESS)
         {
             sprintf(ac_error_str, "\nError in setting number of cores");
             codec_exit(ac_error_str);
         }
 
     }
 
     /*************************************************************************/
     /* set processsor                                                        */
     /*************************************************************************/
     {
 
         ih264d_ctl_set_processor_ip_t s_ctl_set_num_processor_ip;
         ih264d_ctl_set_processor_op_t s_ctl_set_num_processor_op;
 
         s_ctl_set_num_processor_ip.e_cmd = IVD_CMD_VIDEO_CTL;
         s_ctl_set_num_processor_ip.e_sub_cmd =(IVD_CONTROL_API_COMMAND_TYPE_T) IH264D_CMD_CTL_SET_PROCESSOR;
         s_ctl_set_num_processor_ip.u4_arch = s_app_ctx.e_arch;
         s_ctl_set_num_processor_ip.u4_soc = s_app_ctx.e_soc;
         s_ctl_set_num_processor_ip.u4_size = sizeof(ih264d_ctl_set_processor_ip_t);
         s_ctl_set_num_processor_op.u4_size = sizeof(ih264d_ctl_set_processor_op_t);
 
         ret = ivd_api_function((iv_obj_t*)codec_obj, (void *)&s_ctl_set_num_processor_ip,
                                    (void *)&s_ctl_set_num_processor_op);
         if(ret != IV_SUCCESS)
         {
             sprintf(ac_error_str, "\nError in setting Processor type");
             codec_exit(ac_error_str);
         }
 
     }
 
     flush_output(codec_obj, &s_app_ctx, ps_out_buf, pu1_bs_buf, &u4_op_frm_ts,
                  ps_op_file, ps_qp_file, ps_mb_type_file,
                  pu1_qp_map_buf, pu1_blk_type_map_buf,
                  ps_op_chksum_file, u4_ip_frm_ts, u4_bytes_remaining);
 
     /*****************************************************************************/
     /*   Decode header to get width and height and buffer sizes                  */
     /*****************************************************************************/
     {
         ih264d_video_decode_ip_t s_h264d_decode_ip = {};
         ih264d_video_decode_op_t s_h264d_decode_op = {};
         ivd_video_decode_ip_t *ps_video_decode_ip = &s_h264d_decode_ip.s_ivd_video_decode_ip_t;
         ivd_video_decode_op_t *ps_video_decode_op = &s_h264d_decode_op.s_ivd_video_decode_op_t;
 
 
 
         {
             ih264d_ctl_set_config_ip_t s_h264d_ctl_ip = {};
             ih264d_ctl_set_config_op_t s_h264d_ctl_op = {};
             ivd_ctl_set_config_ip_t *ps_ctl_ip = &s_h264d_ctl_ip.s_ivd_ctl_set_config_ip_t;
             ivd_ctl_set_config_op_t *ps_ctl_op = &s_h264d_ctl_op.s_ivd_ctl_set_config_op_t;
 
 
             ps_ctl_ip->u4_disp_wd = STRIDE;
             if(1 == s_app_ctx.display)
                 ps_ctl_ip->u4_disp_wd = s_app_ctx.get_stride();
 
             ps_ctl_ip->e_frm_skip_mode = IVD_SKIP_NONE;
             ps_ctl_ip->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;
             ps_ctl_ip->e_vid_dec_mode = IVD_DECODE_HEADER;
             ps_ctl_ip->e_cmd = IVD_CMD_VIDEO_CTL;
             ps_ctl_ip->e_sub_cmd = IVD_CMD_CTL_SETPARAMS;
             ps_ctl_ip->u4_size = sizeof(ih264d_ctl_set_config_ip_t);
             ps_ctl_op->u4_size = sizeof(ih264d_ctl_set_config_op_t);
 
             ret = ivd_api_function((iv_obj_t*)codec_obj, (void *)&s_h264d_ctl_ip,
                                        (void *)&s_h264d_ctl_op);
             if(ret != IV_SUCCESS)
             {
                 sprintf(ac_error_str,
                         "\nError in setting the codec in header decode mode");
                 codec_exit(ac_error_str);
             }
         }
 
         /* Allocate input buffer for header */
         u4_ip_buf_len = 256 * 1024;
         pu1_bs_buf = (UWORD8 *)malloc(u4_ip_buf_len);
 
         if(pu1_bs_buf == NULL)
         {
             sprintf(ac_error_str,
                     "\nAllocation failure for input buffer of i4_size %d",
                     u4_ip_buf_len);
             codec_exit(ac_error_str);
         }
 
         do
         {
             WORD32 numbytes;
 
             if(0 == s_app_ctx.u4_piclen_flag)
             {
                 fseek(ps_ip_file, file_pos, SEEK_SET);
                 numbytes = u4_ip_buf_len;
             }
             else
             {
                 WORD32 entries;
                 entries = fscanf(ps_piclen_file, "%d\n", &numbytes);
                 if(1 != entries)
                     numbytes = u4_ip_buf_len;
             }
 
             u4_bytes_remaining = fread(pu1_bs_buf, sizeof(UWORD8), numbytes,
                                        ps_ip_file);
 
             if(0 == u4_bytes_remaining)
             {
                 sprintf(ac_error_str, "\nUnable to read from input file");
                 codec_exit(ac_error_str);
             }
 
             ps_video_decode_ip->e_cmd = IVD_CMD_VIDEO_DECODE;
             ps_video_decode_ip->u4_ts = u4_ip_frm_ts;
             ps_video_decode_ip->pv_stream_buffer = pu1_bs_buf;
             ps_video_decode_ip->u4_num_Bytes = u4_bytes_remaining;
             ps_video_decode_ip->u4_size = sizeof(ih264d_video_decode_ip_t);
             ps_video_decode_op->u4_size = sizeof(ih264d_video_decode_op_t);
             s_h264d_decode_ip.pu1_8x8_blk_qp_map = pu1_qp_map_buf;
             s_h264d_decode_ip.pu1_8x8_blk_type_map = pu1_blk_type_map_buf;
             s_h264d_decode_ip.u4_8x8_blk_qp_map_size = (ADAPTIVE_MAX_HT * ADAPTIVE_MAX_WD) >> 6;
             s_h264d_decode_ip.u4_8x8_blk_type_map_size = (ADAPTIVE_MAX_HT * ADAPTIVE_MAX_WD) >> 6;
 
             /*****************************************************************************/
             /*   API Call: Header Decode                                                  */
             /*****************************************************************************/
             ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_h264d_decode_ip,
                                        (void *)&s_h264d_decode_op);
 
             if(ret != IV_SUCCESS)
             {
                 printf("Error in header decode 0x%x\n",  ps_video_decode_op->u4_error_code);
                 // codec_exit(ac_error_str);
             }
 
             u4_num_bytes_dec = ps_video_decode_op->u4_num_bytes_consumed;
 #ifndef PROFILE_ENABLE
             printf("%d\n",ps_video_decode_op->u4_num_bytes_consumed);
 #endif
             file_pos += u4_num_bytes_dec;
             total_bytes_comsumed += u4_num_bytes_dec;
         }while(ret != IV_SUCCESS);
 
         /* copy pic_wd and pic_ht to initialize buffers */
         s_app_ctx.u4_pic_wd = ps_video_decode_op->u4_pic_wd;
         s_app_ctx.u4_pic_ht = ps_video_decode_op->u4_pic_ht;
 
         free(pu1_bs_buf);
 
 #if IOS_DISPLAY
         s_app_ctx.i4_screen_wd = screen_wd;
         s_app_ctx.i4_screen_ht = screen_ht;
 #endif
         {
 
             ivd_ctl_getbufinfo_ip_t s_ctl_ip;
             ivd_ctl_getbufinfo_op_t s_ctl_op;
             WORD32 outlen = 0;
 
             s_ctl_ip.e_cmd = IVD_CMD_VIDEO_CTL;
             s_ctl_ip.e_sub_cmd = IVD_CMD_CTL_GETBUFINFO;
             s_ctl_ip.u4_size = sizeof(ivd_ctl_getbufinfo_ip_t);
             s_ctl_op.u4_size = sizeof(ivd_ctl_getbufinfo_op_t);
             ret = ivd_api_function((iv_obj_t*)codec_obj, (void *)&s_ctl_ip,
                                        (void *)&s_ctl_op);
             if(ret != IV_SUCCESS)
             {
                 sprintf(ac_error_str, "Error in Get Buf Info %x", s_ctl_op.u4_error_code);
                 codec_exit(ac_error_str);
             }
 
             /* Allocate bitstream buffer */
             u4_ip_buf_len = s_ctl_op.u4_min_in_buf_size[0];
 #ifdef ADAPTIVE_TEST
             u4_ip_buf_len = ADAPTIVE_MAX_WD * ADAPTIVE_MAX_HT * 3 >> 1;
 #endif
             pu1_bs_buf = (UWORD8 *)malloc(u4_ip_buf_len);
 
             if(pu1_bs_buf == NULL)
             {
                 sprintf(ac_error_str,
                         "\nAllocation failure for input buffer of i4_size %d",
                         u4_ip_buf_len);
                 codec_exit(ac_error_str);
             }
 
             s_app_ctx.num_disp_buf = s_ctl_op.u4_num_disp_bufs;
             /* Allocate output buffer only if display buffers are not shared */
             /* Or if shared and output is 420P */
             if((0 == s_app_ctx.u4_share_disp_buf) || (IV_YUV_420P == s_app_ctx.e_output_chroma_format))
             {
 #ifdef ADAPTIVE_TEST
                 switch(s_app_ctx.e_output_chroma_format)
                 {
                     case IV_YUV_420P:
                     {
                         s_ctl_op.u4_min_out_buf_size[0] = ADAPTIVE_MAX_WD * ADAPTIVE_MAX_HT;
                         s_ctl_op.u4_min_out_buf_size[1] = ADAPTIVE_MAX_WD * ADAPTIVE_MAX_HT >> 2;
                         s_ctl_op.u4_min_out_buf_size[2] = ADAPTIVE_MAX_WD * ADAPTIVE_MAX_HT >> 2;
                         break;
                     }
                     case IV_YUV_420SP_UV:
                     case IV_YUV_420SP_VU:
                     {
                         s_ctl_op.u4_min_out_buf_size[0] = ADAPTIVE_MAX_WD * ADAPTIVE_MAX_HT;
                         s_ctl_op.u4_min_out_buf_size[1] = ADAPTIVE_MAX_WD * ADAPTIVE_MAX_HT >> 1;
                         s_ctl_op.u4_min_out_buf_size[2] = 0;
                         break;
                     }
                     case IV_YUV_422ILE:
                     {
                         s_ctl_op.u4_min_out_buf_size[0] = ADAPTIVE_MAX_WD * ADAPTIVE_MAX_HT * 2;
                         s_ctl_op.u4_min_out_buf_size[1] = 0;
                         s_ctl_op.u4_min_out_buf_size[2] = 0;
                         break;
                     }
                     case IV_RGBA_8888:
                     {
                         s_ctl_op.u4_min_out_buf_size[0] = ADAPTIVE_MAX_WD * ADAPTIVE_MAX_HT * 4;
                         s_ctl_op.u4_min_out_buf_size[1] = 0;
                         s_ctl_op.u4_min_out_buf_size[2] = 0;
                         break;
                     }
                     case IV_RGB_565:
                     {
                         s_ctl_op.u4_min_out_buf_size[0] = ADAPTIVE_MAX_WD * ADAPTIVE_MAX_HT * 2;
                         s_ctl_op.u4_min_out_buf_size[1] = 0;
                         s_ctl_op.u4_min_out_buf_size[2] = 0;
                         break;
                     }
                     default:
                         break;
 
                 }
 #endif
                 ps_out_buf->u4_min_out_buf_size[0] =
                                 s_ctl_op.u4_min_out_buf_size[0];
                 ps_out_buf->u4_min_out_buf_size[1] =
                                 s_ctl_op.u4_min_out_buf_size[1];
                 ps_out_buf->u4_min_out_buf_size[2] =
                                 s_ctl_op.u4_min_out_buf_size[2];
 
                 outlen = s_ctl_op.u4_min_out_buf_size[0];
                 if(s_ctl_op.u4_min_num_out_bufs > 1)
                     outlen += s_ctl_op.u4_min_out_buf_size[1];
 
                 if(s_ctl_op.u4_min_num_out_bufs > 2)
                     outlen += s_ctl_op.u4_min_out_buf_size[2];
 
                 ps_out_buf->pu1_bufs[0] = (UWORD8 *)malloc(outlen);
                 if(ps_out_buf->pu1_bufs[0] == NULL)
                 {
                     sprintf(ac_error_str,
                             "\nAllocation failure for output buffer of i4_size %d",
                             outlen);
                     codec_exit(ac_error_str);
                 }
 
                 if(s_ctl_op.u4_min_num_out_bufs > 1)
                     ps_out_buf->pu1_bufs[1] = ps_out_buf->pu1_bufs[0]
                                     + (s_ctl_op.u4_min_out_buf_size[0]);
 
                 if(s_ctl_op.u4_min_num_out_bufs > 2)
                     ps_out_buf->pu1_bufs[2] = ps_out_buf->pu1_bufs[1]
                                     + (s_ctl_op.u4_min_out_buf_size[1]);
 
                 ps_out_buf->u4_num_bufs = s_ctl_op.u4_min_num_out_bufs;
             }
 
 #ifdef APP_EXTRA_BUFS
             s_app_ctx.disp_delay = EXTRA_DISP_BUFFERS;
             s_ctl_op.u4_num_disp_bufs += EXTRA_DISP_BUFFERS;
 #endif
 
             /*****************************************************************************/
             /*   API Call: Allocate display buffers for display buffer shared case       */
             /*****************************************************************************/
 
             for(i = 0; i < s_ctl_op.u4_num_disp_bufs; i++)
             {
 
                 s_app_ctx.s_disp_buffers[i].u4_min_out_buf_size[0] =
                                 s_ctl_op.u4_min_out_buf_size[0];
                 s_app_ctx.s_disp_buffers[i].u4_min_out_buf_size[1] =
                                 s_ctl_op.u4_min_out_buf_size[1];
                 s_app_ctx.s_disp_buffers[i].u4_min_out_buf_size[2] =
                                 s_ctl_op.u4_min_out_buf_size[2];
 
                 outlen = s_ctl_op.u4_min_out_buf_size[0];
                 if(s_ctl_op.u4_min_num_out_bufs > 1)
                     outlen += s_ctl_op.u4_min_out_buf_size[1];
 
                 if(s_ctl_op.u4_min_num_out_bufs > 2)
                     outlen += s_ctl_op.u4_min_out_buf_size[2];
 
                 s_app_ctx.s_disp_buffers[i].pu1_bufs[0] = (UWORD8 *)malloc(outlen);
 
                 if(s_app_ctx.s_disp_buffers[i].pu1_bufs[0] == NULL)
                 {
                     sprintf(ac_error_str,
                             "\nAllocation failure for output buffer of i4_size %d",
                             outlen);
                     codec_exit(ac_error_str);
                 }
 
                 if(s_ctl_op.u4_min_num_out_bufs > 1)
                     s_app_ctx.s_disp_buffers[i].pu1_bufs[1] =
                                     s_app_ctx.s_disp_buffers[i].pu1_bufs[0]
                                                     + (s_ctl_op.u4_min_out_buf_size[0]);
 
                 if(s_ctl_op.u4_min_num_out_bufs > 2)
                     s_app_ctx.s_disp_buffers[i].pu1_bufs[2] =
                                     s_app_ctx.s_disp_buffers[i].pu1_bufs[1]
                                                     + (s_ctl_op.u4_min_out_buf_size[1]);
 
                 s_app_ctx.s_disp_buffers[i].u4_num_bufs =
                                 s_ctl_op.u4_min_num_out_bufs;
             }
             s_app_ctx.num_disp_buf = s_ctl_op.u4_num_disp_bufs;
         }
 
         /* Create display thread and wait for the display buffers to be initialized */
         if(1 == s_app_ctx.display)
         {
             if(0 == s_app_ctx.display_thread_created)
             {
                 s_app_ctx.display_init_done = 0;
                 ithread_create(s_app_ctx.display_thread_handle, NULL,
                                                     (void *) &display_thread, (void *) &s_app_ctx);
                 s_app_ctx.display_thread_created = 1;
 
                 while(1)
                 {
                     if(s_app_ctx.display_init_done)
                         break;
 
                     ithread_msleep(1);
                 }
             }
 
             s_app_ctx.u4_strd = s_app_ctx.get_stride();
         }
     }
 
     /*************************************************************************/
     /* Get actual number of output buffers requried, which is dependent      */
     /* on ps_bitstrm properties such as width, height and level etc              */
     /* This is needed mainly for shared display mode                         */
     /*************************************************************************/
     //if(1 == s_app_ctx.u4_share_disp_buf)
     {
         /*****************************************************************************/
         /*   API Call: Send the allocated display buffers to codec                   */
         /*****************************************************************************/
         {
             ivd_set_display_frame_ip_t s_set_display_frame_ip;
             ivd_set_display_frame_op_t s_set_display_frame_op;
 
             s_set_display_frame_ip.e_cmd = IVD_CMD_SET_DISPLAY_FRAME;
             s_set_display_frame_ip.u4_size = sizeof(ivd_set_display_frame_ip_t);
             s_set_display_frame_op.u4_size = sizeof(ivd_set_display_frame_op_t);
 
             s_set_display_frame_ip.num_disp_bufs = s_app_ctx.num_disp_buf;
 
             memcpy(&(s_set_display_frame_ip.s_disp_buffer),
                    &(s_app_ctx.s_disp_buffers),
                    s_app_ctx.num_disp_buf * sizeof(ivd_out_bufdesc_t));
 
             ret = ivd_api_function((iv_obj_t *)codec_obj,
                                        (void *)&s_set_display_frame_ip,
                                        (void *)&s_set_display_frame_op);
 
             if(IV_SUCCESS != ret)
             {
                 sprintf(ac_error_str, "Error in Set display frame");
                 codec_exit(ac_error_str);
             }
 
         }
 
     }
 
     /*************************************************************************/
     /* Get frame dimensions for display buffers such as x_offset,y_offset    */
     /* etc. This information might be needed to set display buffer           */
     /* offsets in case of shared display buffer mode                         */
     /*************************************************************************/
     {
 
         ih264d_ctl_get_frame_dimensions_ip_t s_ctl_get_frame_dimensions_ip;
         ih264d_ctl_get_frame_dimensions_op_t s_ctl_get_frame_dimensions_op;
 
         s_ctl_get_frame_dimensions_ip.e_cmd = IVD_CMD_VIDEO_CTL;
         s_ctl_get_frame_dimensions_ip.e_sub_cmd =
                         (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_BUFFER_DIMENSIONS;
         s_ctl_get_frame_dimensions_ip.u4_size =
                         sizeof(ih264d_ctl_get_frame_dimensions_ip_t);
         s_ctl_get_frame_dimensions_op.u4_size =
                         sizeof(ih264d_ctl_get_frame_dimensions_op_t);
 
         ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_ctl_get_frame_dimensions_ip,
                              (void *)&s_ctl_get_frame_dimensions_op);
         if(IV_SUCCESS != ret)
         {
             sprintf(ac_error_str, "Error in Get buffer Dimensions");
             codec_exit(ac_error_str);
         }
 
 /*
         printf("Frame offsets due to padding\n");
         printf("s_ctl_get_frame_dimensions_op.x_offset[0] %d s_ctl_get_frame_dimensions_op.y_offset[0] %d\n",
                s_ctl_get_frame_dimensions_op.u4_x_offset[0],
                s_ctl_get_frame_dimensions_op.u4_y_offset[0]);
 */
     }
 
     /*************************************************************************/
     /* Get VUI parameters                                                    */
     /*************************************************************************/
     {
 
         ih264d_ctl_get_vui_params_ip_t s_ctl_get_vui_params_ip;
         ih264d_ctl_get_vui_params_op_t s_ctl_get_vui_params_op;
 
         s_ctl_get_vui_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
         s_ctl_get_vui_params_ip.e_sub_cmd =
                         (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_VUI_PARAMS;
         s_ctl_get_vui_params_ip.u4_size =
                         sizeof(ih264d_ctl_get_vui_params_ip_t);
         s_ctl_get_vui_params_op.u4_size =
                         sizeof(ih264d_ctl_get_vui_params_op_t);
 
         ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_ctl_get_vui_params_ip,
                              (void *)&s_ctl_get_vui_params_op);
         if(IV_SUCCESS != ret)
         {
             sprintf(ac_error_str, "Error in Get VUI params");
             //codec_exit(ac_error_str);
         }
     }
 
     /*************************************************************************/
     /* Set the decoder in frame decode mode. It was set in header decode     */
     /* mode earlier                                                          */
     /*************************************************************************/
     {
 
         ih264d_ctl_set_config_ip_t s_h264d_ctl_ip = {};
         ih264d_ctl_set_config_op_t s_h264d_ctl_op = {};
         ivd_ctl_set_config_ip_t *ps_ctl_ip = &s_h264d_ctl_ip.s_ivd_ctl_set_config_ip_t;
         ivd_ctl_set_config_op_t *ps_ctl_op = &s_h264d_ctl_op.s_ivd_ctl_set_config_op_t;
 
         ps_ctl_ip->u4_disp_wd = STRIDE;
         if(1 == s_app_ctx.display)
             ps_ctl_ip->u4_disp_wd = s_app_ctx.get_stride();
         ps_ctl_ip->e_frm_skip_mode = IVD_SKIP_NONE;
 
         ps_ctl_ip->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT;
         ps_ctl_ip->e_vid_dec_mode = IVD_DECODE_FRAME;
         ps_ctl_ip->e_cmd = IVD_CMD_VIDEO_CTL;
         ps_ctl_ip->e_sub_cmd = IVD_CMD_CTL_SETPARAMS;
         ps_ctl_ip->u4_size = sizeof(ih264d_ctl_set_config_ip_t);
 
         ps_ctl_op->u4_size = sizeof(ih264d_ctl_set_config_op_t);
 
         ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_h264d_ctl_ip,
                                (void *)&s_h264d_ctl_op);
 
         if(IV_SUCCESS != ret)
         {
             sprintf(ac_error_str, "Error in Set Parameters");
             //codec_exit(ac_error_str);
         }
 
     }
     /*************************************************************************/
     /* If required disable deblocking and sao at given level                 */
     /*************************************************************************/
 
     set_degrade(codec_obj, s_app_ctx.i4_degrade_type, s_app_ctx.i4_degrade_pics);
 #ifdef WINDOWS_TIMER
         QueryPerformanceFrequency ( &frequency);
 #endif
 #ifndef PRINT_PICSIZE
     get_version(codec_obj);
 #endif
 
 
     max_op_frm_ts = s_app_ctx.u4_max_frm_ts + s_app_ctx.disp_delay;
 
     if(max_op_frm_ts <  s_app_ctx.disp_delay)
         max_op_frm_ts = 0xffffffff;/* clip as overflow has occured*/
 
     max_op_frm_ts = (s_app_ctx.u4_max_frm_ts > 0)? (max_op_frm_ts): 0xffffffff;
 
     u4_num_disp_bufs_with_dec = 0;
 
     while(u4_op_frm_ts < max_op_frm_ts)
     {
 
 #ifdef TEST_FLUSH
         if(u4_ip_frm_ts == FLUSH_FRM_CNT)
         {
             ivd_ctl_flush_ip_t s_ctl_ip;
             ivd_ctl_flush_op_t s_ctl_op;
 
             s_ctl_ip.e_cmd = IVD_CMD_VIDEO_CTL;
             s_ctl_ip.e_sub_cmd = IVD_CMD_CTL_FLUSH;
             s_ctl_ip.u4_size = sizeof(ivd_ctl_flush_ip_t);
             s_ctl_op.u4_size = sizeof(ivd_ctl_flush_op_t);
             ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_ctl_ip,
                                        (void *)&s_ctl_op);
 
             if(ret != IV_SUCCESS)
             {
                 printf("Error in Setting the decoder in flush mode\n");
             }
 //            file_pos = 0;
 
 //          fseek(ps_ip_file, file_pos, SEEK_SET);
 
         }
 #endif
         if(u4_num_disp_bufs_with_dec < s_app_ctx.num_disp_buf)
         {
             release_disp_frame(codec_obj, u4_num_disp_bufs_with_dec);
             u4_num_disp_bufs_with_dec ++;
         }
 
 
         /*************************************************************************/
         /* set num of cores                                                      */
         /*************************************************************************/
 #ifdef DYNAMIC_NUMCORES
         {
 
             ih264d_ctl_set_num_cores_ip_t s_ctl_set_cores_ip;
             ih264d_ctl_set_num_cores_op_t s_ctl_set_cores_op;
 
             s_ctl_set_cores_ip.e_cmd = IVD_CMD_VIDEO_CTL;
             s_ctl_set_cores_ip.e_sub_cmd = IH264D_CMD_CTL_SET_NUM_CORES;
             s_ctl_set_cores_ip.u4_num_cores =  1 + 3 * (u4_ip_frm_ts % 2);
             s_ctl_set_cores_ip.u4_size = sizeof(ih264d_ctl_set_num_cores_ip_t);
             s_ctl_set_cores_op.u4_size = sizeof(ih264d_ctl_set_num_cores_op_t);
 
             ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_ctl_set_cores_ip,
                                        (void *)&s_ctl_set_cores_op);
             if(ret != IV_SUCCESS)
             {
                 sprintf(ac_error_str, "\nError in setting number of cores");
                 codec_exit(ac_error_str);
             }
 
         }
 #endif
         /***********************************************************************/
         /*   Seek the file to start of current frame, this is equavelent of    */
         /*   having a parcer which tells the start of current frame            */
         /***********************************************************************/
         {
             WORD32 numbytes;
 
             if(0 == s_app_ctx.u4_piclen_flag)
             {
                 fseek(ps_ip_file, file_pos, SEEK_SET);
                 numbytes = u4_ip_buf_len;
             }
             else
             {
                 WORD32 entries;
                 entries = fscanf(ps_piclen_file, "%d\n", &numbytes);
                 if(1 != entries)
                     numbytes = u4_ip_buf_len;
             }
 
             u4_bytes_remaining = fread(pu1_bs_buf, sizeof(UWORD8),
                                        numbytes, ps_ip_file);
 
             if(u4_bytes_remaining == 0)
             {
                 if(1 == s_app_ctx.loopback)
                 {
                     file_pos = 0;
                     if(0 == s_app_ctx.u4_piclen_flag)
                     {
                         fseek(ps_ip_file, file_pos, SEEK_SET);
                         numbytes = u4_ip_buf_len;
                     }
                     else
                     {
                         WORD32 entries;
                         entries = fscanf(ps_piclen_file, "%d\n", &numbytes);
                         if(1 != entries)
                             numbytes = u4_ip_buf_len;
                     }
 
 
                     u4_bytes_remaining = fread(pu1_bs_buf, sizeof(UWORD8),
                                                numbytes, ps_ip_file);
                 }
                 else
                     break;
             }
         }
 
         /*********************************************************************/
         /* Following calls can be enabled at diffent times                   */
         /*********************************************************************/
 #if ENABLE_DEGRADE
         if(u4_op_frm_ts >= 10000)
             disable_deblocking(codec_obj, 4);
 
         if(u4_op_frm_ts == 30000)
             enable_deblocking(codec_obj);
 
         if(u4_op_frm_ts == 10000)
             enable_skippb_frames(codec_obj);
 
         if(u4_op_frm_ts == 60000)
             disable_skippb_frames(codec_obj);
 
         if(u4_op_frm_ts == 30000)
             enable_skipb_frames(codec_obj);
 
         if(u4_op_frm_ts == 60000)
             disable_skipb_frames(codec_obj);
 #endif
 
 
         {
             ih264d_video_decode_ip_t s_h264d_decode_ip = {};
             ih264d_video_decode_op_t s_h264d_decode_op = {};
             ivd_video_decode_ip_t *ps_video_decode_ip = &s_h264d_decode_ip.s_ivd_video_decode_ip_t;
             ivd_video_decode_op_t *ps_video_decode_op = &s_h264d_decode_op.s_ivd_video_decode_op_t;
 #ifdef PROFILE_ENABLE
             UWORD32 s_elapsed_time;
             TIMER s_start_timer;
             TIMER s_end_timer;
 #endif
 
 
             ps_video_decode_ip->e_cmd = IVD_CMD_VIDEO_DECODE;
             ps_video_decode_ip->u4_ts = u4_ip_frm_ts;
             ps_video_decode_ip->pv_stream_buffer = pu1_bs_buf;
             ps_video_decode_ip->u4_num_Bytes = u4_bytes_remaining;
             ps_video_decode_ip->u4_size = sizeof(ih264d_video_decode_ip_t);
             ps_video_decode_ip->s_out_buffer.u4_min_out_buf_size[0] =
                             ps_out_buf->u4_min_out_buf_size[0];
             ps_video_decode_ip->s_out_buffer.u4_min_out_buf_size[1] =
                             ps_out_buf->u4_min_out_buf_size[1];
             ps_video_decode_ip->s_out_buffer.u4_min_out_buf_size[2] =
                             ps_out_buf->u4_min_out_buf_size[2];
 
             ps_video_decode_ip->s_out_buffer.pu1_bufs[0] =
                             ps_out_buf->pu1_bufs[0];
             ps_video_decode_ip->s_out_buffer.pu1_bufs[1] =
                             ps_out_buf->pu1_bufs[1];
             ps_video_decode_ip->s_out_buffer.pu1_bufs[2] =
                             ps_out_buf->pu1_bufs[2];
             ps_video_decode_ip->s_out_buffer.u4_num_bufs =
                             ps_out_buf->u4_num_bufs;
             ps_video_decode_op->u4_size = sizeof(ih264d_video_decode_op_t);
             s_h264d_decode_ip.pu1_8x8_blk_qp_map = pu1_qp_map_buf;
             s_h264d_decode_ip.pu1_8x8_blk_type_map = pu1_blk_type_map_buf;
             s_h264d_decode_ip.u4_8x8_blk_qp_map_size = (ADAPTIVE_MAX_HT * ADAPTIVE_MAX_WD) >> 6;
             s_h264d_decode_ip.u4_8x8_blk_type_map_size = (ADAPTIVE_MAX_HT * ADAPTIVE_MAX_WD) >> 6;
 
             /* Get display buffer pointers */
             if(1 == s_app_ctx.display)
             {
                 WORD32 wr_idx;
 
                 wr_idx = dispq_producer_dequeue(&s_app_ctx);
 
                 if(s_app_ctx.quit)
                     break;
 
                 s_app_ctx.set_disp_buffers(s_app_ctx.pv_disp_ctx, wr_idx,
                                      &ps_video_decode_ip->s_out_buffer.pu1_bufs[0],
                                      &ps_video_decode_ip->s_out_buffer.pu1_bufs[1],
                                      &ps_video_decode_ip->s_out_buffer.pu1_bufs[2]);
             }
 
             /*****************************************************************************/
             /*   API Call: Video Decode                                                  */
             /*****************************************************************************/
 
             GETTIME(&s_start_timer);
 
             ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_h264d_decode_ip,
                                        (void *)&s_h264d_decode_op);
 
 
             GETTIME(&s_end_timer);
             ELAPSEDTIME(s_start_timer,s_end_timer,s_elapsed_time,frequency);
 #ifdef PROFILE_ENABLE
             {
                     UWORD32 peak_avg, id;
                     u4_tot_cycles += s_elapsed_time;
                     peak_window[peak_window_idx++] = s_elapsed_time;
                     if(peak_window_idx == PEAK_WINDOW_SIZE)
                     peak_window_idx = 0;
                     peak_avg = 0;
                     for(id = 0; id < PEAK_WINDOW_SIZE; id++)
                     {
                             peak_avg += peak_window[id];
                     }
                     peak_avg /= PEAK_WINDOW_SIZE;
                     if(peak_avg > peak_avg_max)
                     peak_avg_max = peak_avg;
                     frm_cnt++;
 
                     printf("FrameNum: %4d TimeTaken(microsec): %6d AvgTime: %6d PeakAvgTimeMax: %6d Output: %2d NumBytes: %6d \n",
                                     frm_cnt, s_elapsed_time, u4_tot_cycles / frm_cnt, peak_avg_max, ps_video_decode_op->u4_output_present, ps_video_decode_op->u4_num_bytes_consumed);
 
             }
 #ifdef INTEL_CE5300
         time_consumed += s_elapsed_time;
         bytes_consumed += ps_video_decode_op->u4_num_bytes_consumed;
         if (!(frm_cnt % (s_app_ctx.fps)))
         {
             time_consumed = time_consumed/s_app_ctx.fps;
             printf("Average decode time(micro sec) for the last second = %6d\n",time_consumed);
             printf("Average bitrate(kb) for the last second = %6d\n",(bytes_consumed * 8) / 1024);
             time_consumed = 0;
             bytes_consumed = 0;
 
         }
 #endif
 #else
         printf("%d\n",ps_video_decode_op->u4_num_bytes_consumed);
 #endif
 
             if(ret != IV_SUCCESS)
             {
                 printf("Error in video Frame decode : ret %x Error %x\n", ret,
                        ps_video_decode_op->u4_error_code);
             }
 
             if((IV_SUCCESS != ret) &&
                             ((ps_video_decode_op->u4_error_code & 0xFF) == IVD_RES_CHANGED))
             {
                 ivd_ctl_reset_ip_t s_ctl_ip;
                 ivd_ctl_reset_op_t s_ctl_op;
 
                 flush_output(codec_obj, &s_app_ctx, ps_out_buf, pu1_bs_buf, &u4_op_frm_ts,
                              ps_op_file, ps_qp_file, ps_mb_type_file,
                              pu1_qp_map_buf, pu1_blk_type_map_buf,
                              ps_op_chksum_file, u4_ip_frm_ts, u4_bytes_remaining);
 
                 s_ctl_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                 s_ctl_ip.e_sub_cmd = IVD_CMD_CTL_RESET;
                 s_ctl_ip.u4_size = sizeof(ivd_ctl_reset_ip_t);
                 s_ctl_op.u4_size = sizeof(ivd_ctl_reset_op_t);
 
                 ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_ctl_ip,
                                                    (void *)&s_ctl_op);
                 if(IV_SUCCESS != ret)
                 {
                     sprintf(ac_error_str, "Error in Reset");
                     codec_exit(ac_error_str);
                 }
 
                 /*when reset all buffers are released by lib*/
                 u4_num_disp_bufs_with_dec = 0;
                 /*************************************************************************/
                 /* set num of cores                                                      */
                 /*************************************************************************/
                 {
 
                     ih264d_ctl_set_num_cores_ip_t s_ctl_set_cores_ip;
                     ih264d_ctl_set_num_cores_op_t s_ctl_set_cores_op;
 
                     s_ctl_set_cores_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                     s_ctl_set_cores_ip.e_sub_cmd =(IVD_CONTROL_API_COMMAND_TYPE_T) IH264D_CMD_CTL_SET_NUM_CORES;
                     s_ctl_set_cores_ip.u4_num_cores = s_app_ctx.u4_num_cores;
                     s_ctl_set_cores_ip.u4_size = sizeof(ih264d_ctl_set_num_cores_ip_t);
                     s_ctl_set_cores_op.u4_size = sizeof(ih264d_ctl_set_num_cores_op_t);
 
                     ret = ivd_api_function((iv_obj_t*)codec_obj, (void *)&s_ctl_set_cores_ip,
                                                (void *)&s_ctl_set_cores_op);
                     if(ret != IV_SUCCESS)
                     {
                         sprintf(ac_error_str, "\nError in setting number of cores");
                         codec_exit(ac_error_str);
                     }
 
                 }
                 /*************************************************************************/
                 /* set processsor                                                        */
                 /*************************************************************************/
 
                 {
 
                     ih264d_ctl_set_processor_ip_t s_ctl_set_num_processor_ip;
                     ih264d_ctl_set_processor_op_t s_ctl_set_num_processor_op;
 
                     s_ctl_set_num_processor_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                     s_ctl_set_num_processor_ip.e_sub_cmd =(IVD_CONTROL_API_COMMAND_TYPE_T) IH264D_CMD_CTL_SET_PROCESSOR;
                     s_ctl_set_num_processor_ip.u4_arch = s_app_ctx.e_arch;
                     s_ctl_set_num_processor_ip.u4_soc = s_app_ctx.e_soc;
                     s_ctl_set_num_processor_ip.u4_size = sizeof(ih264d_ctl_set_processor_ip_t);
                     s_ctl_set_num_processor_op.u4_size = sizeof(ih264d_ctl_set_processor_op_t);
 
                     ret = ivd_api_function((iv_obj_t*)codec_obj, (void *)&s_ctl_set_num_processor_ip,
                                                (void *)&s_ctl_set_num_processor_op);
                     if(ret != IV_SUCCESS)
                     {
                         sprintf(ac_error_str, "\nError in setting Processor type");
                         codec_exit(ac_error_str);
                     }
 
                 }
             }
 
             /*************************************************************************/
             /* Get SEI MDCV parameters                                               */
             /*************************************************************************/
             if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_mdcv_params_present_flag)
             {
                 ih264d_ctl_get_sei_mdcv_params_ip_t s_ctl_get_sei_mdcv_params_ip;
                 ih264d_ctl_get_sei_mdcv_params_op_t s_ctl_get_sei_mdcv_params_op;
 
                 memset(&s_ctl_get_sei_mdcv_params_ip, 0,
                                         sizeof(ih264d_ctl_get_sei_mdcv_params_ip_t));
                 memset(&s_ctl_get_sei_mdcv_params_op, 0,
                                         sizeof(ih264d_ctl_get_sei_mdcv_params_op_t));
 
                 s_ctl_get_sei_mdcv_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                 s_ctl_get_sei_mdcv_params_ip.e_sub_cmd =
                         (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_SEI_MDCV_PARAMS;
                 s_ctl_get_sei_mdcv_params_ip.u4_size =
                         sizeof(ih264d_ctl_get_sei_mdcv_params_ip_t);
                 s_ctl_get_sei_mdcv_params_op.u4_size =
                         sizeof(ih264d_ctl_get_sei_mdcv_params_op_t);
 
                 ret = ivd_api_function((iv_obj_t *)codec_obj,
                                         (void *)&s_ctl_get_sei_mdcv_params_ip,
                                         (void *)&s_ctl_get_sei_mdcv_params_op);
 
                 if(IV_SUCCESS != ret)
                 {
                      printf("MDCV SEI params not present : Error %x\n",
                              s_ctl_get_sei_mdcv_params_op.u4_error_code);
                 }
             }
             /*************************************************************************/
             /* Get SEI CLL parameters                                                */
             /*************************************************************************/
             if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_cll_params_present_flag)
             {
 
                 ih264d_ctl_get_sei_cll_params_ip_t s_ctl_get_sei_cll_params_ip;
                 ih264d_ctl_get_sei_cll_params_op_t s_ctl_get_sei_cll_params_op;
 
                 memset(&s_ctl_get_sei_cll_params_ip, 0,
                                         sizeof(ih264d_ctl_get_sei_cll_params_ip_t));
                 memset(&s_ctl_get_sei_cll_params_op, 0,
                                         sizeof(ih264d_ctl_get_sei_cll_params_op_t));
 
                 s_ctl_get_sei_cll_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                 s_ctl_get_sei_cll_params_ip.e_sub_cmd =
                         (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_SEI_CLL_PARAMS;
                 s_ctl_get_sei_cll_params_ip.u4_size =
                         sizeof(ih264d_ctl_get_sei_cll_params_ip_t);
                 s_ctl_get_sei_cll_params_op.u4_size =
                         sizeof(ih264d_ctl_get_sei_cll_params_op_t);
 
                 ret = ivd_api_function((iv_obj_t *)codec_obj,
                                         (void *)&s_ctl_get_sei_cll_params_ip,
                                         (void *)&s_ctl_get_sei_cll_params_op);
 
                 if(IV_SUCCESS != ret)
                 {
                     printf("CLL SEI params not present : Error %x\n",
                             s_ctl_get_sei_cll_params_op.u4_error_code);
                 }
             }
             /*************************************************************************/
             /* Get SEI AVE parameters                                                */
             /*************************************************************************/
             if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_ave_params_present_flag)
             {
                 ih264d_ctl_get_sei_ave_params_ip_t s_ctl_get_sei_ave_params_ip;
                 ih264d_ctl_get_sei_ave_params_op_t s_ctl_get_sei_ave_params_op;
 
                 memset(&s_ctl_get_sei_ave_params_ip, 0,
                                         sizeof(ih264d_ctl_get_sei_ave_params_ip_t));
                 memset(&s_ctl_get_sei_ave_params_op, 0,
                                         sizeof(ih264d_ctl_get_sei_ave_params_op_t));
 
                 s_ctl_get_sei_ave_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                 s_ctl_get_sei_ave_params_ip.e_sub_cmd =
                         (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_SEI_AVE_PARAMS;
                 s_ctl_get_sei_ave_params_ip.u4_size =
                         sizeof(ih264d_ctl_get_sei_ave_params_ip_t);
                 s_ctl_get_sei_ave_params_op.u4_size =
                         sizeof(ih264d_ctl_get_sei_ave_params_op_t);
 
                 ret = ivd_api_function((iv_obj_t *)codec_obj,
                                         (void *)&s_ctl_get_sei_ave_params_ip,
                                         (void *)&s_ctl_get_sei_ave_params_op);
 
                 if(IV_SUCCESS != ret)
                 {
                     printf("AVE SEI params not present : Error %x\n",
                             s_ctl_get_sei_ave_params_op.u4_error_code);
                 }
             }
             /*************************************************************************/
             /* Get SEI CCV parameters                                                */
             /*************************************************************************/
             if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_ccv_params_present_flag)
             {
                 ih264d_ctl_get_sei_ccv_params_ip_t s_ctl_get_sei_ccv_params_ip;
                 ih264d_ctl_get_sei_ccv_params_op_t s_ctl_get_sei_ccv_params_op;
 
                 memset(&s_ctl_get_sei_ccv_params_ip, 0,
                                         sizeof(ih264d_ctl_get_sei_ccv_params_ip_t));
                 memset(&s_ctl_get_sei_ccv_params_op, 0,
                                         sizeof(ih264d_ctl_get_sei_ccv_params_op_t));
 
                 s_ctl_get_sei_ccv_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
                 s_ctl_get_sei_ccv_params_ip.e_sub_cmd =
                         (IVD_CONTROL_API_COMMAND_TYPE_T)IH264D_CMD_CTL_GET_SEI_CCV_PARAMS;
                 s_ctl_get_sei_ccv_params_ip.u4_size =
                         sizeof(ih264d_ctl_get_sei_ccv_params_ip_t);
                 s_ctl_get_sei_ccv_params_op.u4_size =
                         sizeof(ih264d_ctl_get_sei_ccv_params_op_t);
 
                 ret = ivd_api_function((iv_obj_t *)codec_obj,
                                         (void *)&s_ctl_get_sei_ccv_params_ip,
                                         (void *)&s_ctl_get_sei_ccv_params_op);
 
                 if(IV_SUCCESS != ret)
                 {
                     printf("CCV SEI params not present : Error %x\n",
                             s_ctl_get_sei_ccv_params_op.u4_error_code);
                 }
             }
+            /*************************************************************************/
+            /* Get SEI SII parameters                                                */
+            /*************************************************************************/
+            if(1 == ps_video_decode_op->s_sei_decode_op.u1_sei_sii_params_present_flag)
+            {
+                ih264d_ctl_get_sei_sii_params_ip_t s_ctl_get_sei_sii_params_ip = {0};
+                ih264d_ctl_get_sei_sii_params_op_t s_ctl_get_sei_sii_params_op = {0};
+
+                s_ctl_get_sei_sii_params_ip.e_cmd = IVD_CMD_VIDEO_CTL;
+                s_ctl_get_sei_sii_params_ip.e_sub_cmd =
+                    (IVD_CONTROL_API_COMMAND_TYPE_T) IH264D_CMD_CTL_GET_SEI_SII_PARAMS;
+                s_ctl_get_sei_sii_params_ip.u4_size = sizeof(ih264d_ctl_get_sei_sii_params_ip_t);
+                s_ctl_get_sei_sii_params_op.u4_size = sizeof(ih264d_ctl_get_sei_sii_params_op_t);
+
+                ret =
+                    ivd_api_function((iv_obj_t *) codec_obj, (void *) &s_ctl_get_sei_sii_params_ip,
+                                     (void *) &s_ctl_get_sei_sii_params_op);
+
+                if(IV_SUCCESS != ret)
+                {
+                    printf("SII SEI params not present : Error %x\n",
+                           s_ctl_get_sei_sii_params_op.u4_error_code);
+                }
+            }
 
             if((1 == s_app_ctx.display) &&
                             (1 == ps_video_decode_op->u4_output_present))
             {
                 dispq_producer_queue(&s_app_ctx);
             }
 
             if(IV_B_FRAME == ps_video_decode_op->e_pic_type)
                 s_app_ctx.b_pic_present |= 1;
 
             u4_num_bytes_dec = ps_video_decode_op->u4_num_bytes_consumed;
 
             file_pos += u4_num_bytes_dec;
             total_bytes_comsumed += u4_num_bytes_dec;
             u4_ip_frm_ts++;
 
 
             if(1 == ps_video_decode_op->u4_output_present)
             {
 
                 CHAR cur_fname[1000];
                 CHAR *extn = NULL;
                 /* The objective is to dump the decoded frames into separate files instead of
                  * dumping all the frames in one common file. Also, the number of dumped frames
                  * at any given instance of time cannot exceed 'frame_memory'
                  */
                 if(s_app_ctx.u4_file_save_flag)
                 {
                     /* Locate the position of extension yuv */
                     extn = strstr(s_app_ctx.ac_op_fname,"%d");
                     if (extn != NULL)
                     {
                         output_write_stall(s_app_ctx.ac_op_fname,u4_op_frm_ts);
                         /* Generate output file names */
                         sprintf(cur_fname,s_app_ctx.ac_op_fname,u4_op_frm_ts);
                         /* Open Output file */
                         ps_op_file = fopen(cur_fname,"wb");
                         if (NULL == ps_op_file)
                         {
                             snprintf(ac_error_str, sizeof(ac_error_str),
                                     "Could not open output file %s", cur_fname);
 
                             codec_exit(ac_error_str);
                         }
                     }
                 }
 
                 width = ps_video_decode_op->s_disp_frm_buf.u4_y_wd;
                 height = ps_video_decode_op->s_disp_frm_buf.u4_y_ht;
                 dump_output(&s_app_ctx, &(ps_video_decode_op->s_disp_frm_buf), &s_h264d_decode_op,
                             ps_video_decode_op->u4_disp_buf_id, ps_op_file,
                             ps_qp_file, ps_mb_type_file, ps_op_chksum_file,
                             u4_op_frm_ts, s_app_ctx.u4_file_save_flag,
                             s_app_ctx.u4_chksum_save_flag, s_app_ctx.u4_frame_info_enable);
 
                 u4_op_frm_ts++;
                 if (extn != NULL)
                     fclose(ps_op_file);
 
             }
             else
             {
                 if((ps_video_decode_op->u4_error_code >> IVD_FATALERROR) & 1)
                 {
                     printf("Fatal error\n");
                     break;
                 }
             }
 
         }
     }
 
     /***********************************************************************/
     /*      To get the last decoded frames, call process with NULL input    */
     /***********************************************************************/
     flush_output(codec_obj, &s_app_ctx, ps_out_buf, pu1_bs_buf, &u4_op_frm_ts,
                  ps_op_file, ps_qp_file, ps_mb_type_file,
                  pu1_qp_map_buf, pu1_blk_type_map_buf,
                  ps_op_chksum_file, u4_ip_frm_ts, u4_bytes_remaining);
 
     /* set disp_end u4_flag */
     s_app_ctx.quit = 1;
 
 
 #ifdef PROFILE_ENABLE
     printf("Summary\n");
     printf("Input filename                  : %s\n", s_app_ctx.ac_ip_fname);
     printf("Output Width                    : %-4d\n", width);
     printf("Output Height                   : %-4d\n", height);
 
     if(frm_cnt)
     {
         double avg = u4_tot_cycles / frm_cnt;
         double bytes_avg = total_bytes_comsumed / frm_cnt;
         double bitrate = (bytes_avg * 8 * s_app_ctx.fps)/1000000;
         printf("Bitrate @ %2d fps(mbps)          : %-6.2f\n", s_app_ctx.fps, bitrate);
         printf("Average decode time(micro sec)  : %-6d\n", (WORD32)avg);
         printf("Avg Peak decode time(%2d frames) : %-6d\n", PEAK_WINDOW_SIZE, (WORD32)peak_avg_max);
         avg = (u4_tot_cycles + u4_tot_fmt_cycles)* 1.0 / frm_cnt;
 
         if(0 == s_app_ctx.u4_share_disp_buf)
             printf("FPS achieved (with format conv) : %-3.2f\n", 1000000/avg);
         else
             printf("FPS achieved                    : %-3.2f\n", 1000000/avg);
     }
 #endif
     /***********************************************************************/
     /*   Clear the decoder, close all the files, free all the memory       */
     /***********************************************************************/
     if(1 == s_app_ctx.display)
     {
         s_app_ctx.display_deinit_flag = 1;
         /* wait for display to finish */
         if(s_app_ctx.display_thread_created)
         {
             ithread_join(s_app_ctx.display_thread_handle, NULL);
         }
         free(s_app_ctx.display_thread_handle);
     }
 
     {
         ivd_delete_ip_t s_delete_dec_ip;
         ivd_delete_op_t s_delete_dec_op;
 
         s_delete_dec_ip.e_cmd = IVD_CMD_DELETE;
         s_delete_dec_ip.u4_size = sizeof(ivd_delete_ip_t);
         s_delete_dec_op.u4_size = sizeof(ivd_delete_op_t);
 
         ret = ivd_api_function((iv_obj_t *)codec_obj, (void *)&s_delete_dec_ip,
                                    (void *)&s_delete_dec_op);
 
         if(IV_SUCCESS != ret)
         {
             sprintf(ac_error_str, "Error in Codec delete");
             codec_exit(ac_error_str);
         }
     }
     /***********************************************************************/
     /*              Close all the files and free all the memory            */
     /***********************************************************************/
     {
         fclose(ps_ip_file);
 
         if((1 == s_app_ctx.u4_file_save_flag) && (strstr(s_app_ctx.ac_op_fname,"%d") == NULL))
         {
             fclose(ps_op_file);
         }
         if(1 == s_app_ctx.u4_chksum_save_flag)
         {
             fclose(ps_op_chksum_file);
         }
         if(1 == s_app_ctx.u4_frame_info_enable)
         {
             if(NULL != ps_qp_file)
             {
                 fclose(ps_qp_file);
             }
             if(NULL != ps_mb_type_file)
             {
                 fclose(ps_mb_type_file);
             }
         }
     }
 
     if(0 == s_app_ctx.u4_share_disp_buf)
     {
         free(ps_out_buf->pu1_bufs[0]);
     }
 
     for(i = 0; i < s_app_ctx.num_disp_buf; i++)
     {
         free(s_app_ctx.s_disp_buffers[i].pu1_bufs[0]);
     }
 
     free(ps_out_buf);
     free(pu1_bs_buf);
     if(1 == s_app_ctx.u4_frame_info_enable)
     {
         if(pu1_qp_map_buf)
         {
             free(pu1_qp_map_buf);
         }
         if(pu1_blk_type_map_buf)
         {
             free(pu1_blk_type_map_buf);
         }
     }
 
     if(s_app_ctx.display_thread_handle)
         free(s_app_ctx.display_thread_handle);
 
     return (0);
 }
diff --git a/test/encoder/app.h b/test/encoder/app.h
index 232a59b..4abbe54 100644
--- a/test/encoder/app.h
+++ b/test/encoder/app.h
@@ -216,150 +216,159 @@ typedef struct
 typedef struct
 {
     iv_obj_t *ps_enc;
     iv_mem_rec_t *ps_mem_rec;
     UWORD32 u4_num_mem_rec;
     UWORD32 u4_recon_enable;
     UWORD32 u4_chksum_enable;
     UWORD32 u4_mb_info_type;
     UWORD32 u4_pic_info_type;
     UWORD32 u4_mb_info_size;
     UWORD32 u4_pic_info_size;
     UWORD32 u4_start_frm;
     UWORD32 u4_max_num_frms;
     UWORD32 u4_total_bytes;
     UWORD32 u4_pics_cnt;
     IV_COLOR_FORMAT_T e_inp_color_fmt;
     IV_COLOR_FORMAT_T e_recon_color_fmt;
     IV_ARCH_T e_arch;
     IV_SOC_T e_soc;
 
     WORD32  header_generated;
     void *pv_codec_obj;
 
     UWORD32 u4_num_cores;
     UWORD32 u4_pre_enc_me;
     UWORD32 u4_pre_enc_ipe;
     CHAR ac_ip_fname[STRLENGTH];
     CHAR ac_op_fname[STRLENGTH];
     CHAR ac_recon_fname[STRLENGTH];
     CHAR ac_chksum_fname[STRLENGTH];
     CHAR ac_mb_info_fname[STRLENGTH];
     CHAR ac_pic_info_fname[STRLENGTH];
 
 
     FILE *fp_ip;
     FILE *fp_op;
     FILE *fp_recon;
     FILE *fp_chksum;
     FILE *fp_psnr_ip;
     FILE *fp_mb_info;
     FILE *fp_pic_info;
     FILE *fp_dump_op;
 
 
     UWORD32 u4_loopback;
     UWORD32 u4_max_frame_rate;
     UWORD32 u4_src_frame_rate;
     UWORD32 u4_tgt_frame_rate;
     UWORD32 u4_max_wd;
     UWORD32 u4_max_ht;
     UWORD32 u4_max_level;
 
     UWORD32 u4_strd;
 
     UWORD32 u4_wd;
     UWORD32 u4_ht;
 
     UWORD32 u4_psnr_enable;
 
 
     UWORD32 u4_enc_speed;
     UWORD32 u4_me_speed;
     UWORD32 u4_enable_fast_sad;
     UWORD32 u4_enable_alt_ref;
     UWORD32 u4_rc;
     UWORD32 u4_max_bitrate;
     UWORD32 u4_bitrate;
     UWORD32 u4_i_qp,u4_i_qp_max,u4_i_qp_min;
     UWORD32 u4_p_qp,u4_p_qp_max,u4_p_qp_min;
     UWORD32 u4_b_qp,u4_b_qp_max,u4_b_qp_min;
     UWORD32 u4_air;
     UWORD32 u4_air_refresh_period;
     UWORD32 u4_srch_rng_x;
     UWORD32 u4_srch_rng_y;
     UWORD32 u4_i_interval;
     UWORD32 u4_idr_interval;
     UWORD32 u4_constrained_intra_pred;
     UWORD32 u4_b_frames;
     UWORD32 u4_num_bframes;
     UWORD32 u4_disable_deblk_level;
     UWORD32 u4_hpel;
     UWORD32 u4_qpel;
     UWORD32 u4_enable_intra_4x4;
     IV_PROFILE_T e_profile;
 
     UWORD32 u4_slice_mode;
     UWORD32 u4_slice_param;
     UWORD32 u4_entropy_coding_mode;
 
     void *pv_input_thread_handle;
     void *pv_output_thread_handle;
     void *pv_recon_thread_handle;
 
     ih264e_ctl_getbufinfo_op_t s_get_buf_info_op;
     input_buf_t as_input_buf[DEFAULT_MAX_INPUT_BUFS];
     output_buf_t as_output_buf[DEFAULT_MAX_OUTPUT_BUFS];
     recon_buf_t as_recon_buf[DEFAULT_MAX_RECON_BUFS];
 
     DOUBLE  adbl_psnr[3];
     UWORD32 u4_psnr_cnt;
     UWORD8  *pu1_psnr_buf;
     UWORD8  u4_psnr_buf_size;
 
     UWORD32 u4_vbv_buffer_delay;
     UWORD32 u4_vbv_buf_size;
 
     TIMER   enc_start_time;
     TIMER   enc_last_time;
     WORD32  avg_time;
 
     UWORD32 u4_sei_mdcv_params_present_flag;
     UWORD32 au4_display_primaries_x[NUM_SEI_MDCV_PRIMARIES];
     UWORD32 au4_display_primaries_y[NUM_SEI_MDCV_PRIMARIES];
     UWORD32 u4_white_point_x;
     UWORD32 u4_white_point_y;
     UWORD32 u4_max_display_mastering_luminance;
     UWORD32 u4_min_display_mastering_luminance;
 
     UWORD32 u4_sei_cll_params_present_flag;
     UWORD32 u4_max_content_light_level;
     UWORD32 u4_max_pic_average_light_level;
 
     UWORD32 u4_sei_ave_params_present_flag;
     UWORD32 u4_ambient_illuminance;
     UWORD32 u4_ambient_light_x;
     UWORD32 u4_ambient_light_y;
 
     UWORD32 u4_sei_ccv_params_present_flag;
     UWORD32 u4_ccv_cancel_flag;
     UWORD32 u4_ccv_persistence_flag;
     UWORD32 u4_ccv_primaries_present_flag;
     UWORD32 u4_ccv_min_luminance_value_present_flag;
     UWORD32 u4_ccv_max_luminance_value_present_flag;
     UWORD32 u4_ccv_avg_luminance_value_present_flag;
     UWORD32 u4_ccv_reserved_zero_2bits;
     WORD32  ai4_ccv_primaries_x[NUM_SEI_CCV_PRIMARIES];
     WORD32  ai4_ccv_primaries_y[NUM_SEI_CCV_PRIMARIES];
     UWORD32 u4_ccv_min_luminance_value;
     UWORD32 u4_ccv_max_luminance_value;
     UWORD32 u4_ccv_avg_luminance_value;
 
+    UWORD32 u4_shutter_interval_info_present_flag;
+    UWORD32 u4_sii_sub_layer_idx;
+    UWORD32 u4_sii_time_scale;
+    UWORD32 u4_fixed_shutter_interval_within_cvs_flag;
+    UWORD32 u4_sii_num_units_in_shutter_interval;
+    UWORD32 u4_sii_max_sub_layers_minus1;
+    UWORD32 au4_sub_layer_num_units_in_shutter_interval[SII_MAX_SUB_LAYERS];
+
     ih264e_ctl_set_sei_mdcv_params_ip_t s_sei_mdcv_params;
     ih264e_ctl_set_sei_cll_params_ip_t s_sei_cll_params;
     ih264e_ctl_set_sei_ave_params_ip_t s_sei_ave_params;
+    ih264e_ctl_set_sei_sii_params_ip_t s_sei_sii_params;
 
 } app_ctxt_t;
 
 /*****************************************************************************/
 /*  Function Declarations                                                    */
 /*****************************************************************************/
diff --git a/test/encoder/main.c b/test/encoder/main.c
index b39d5cb..25a063c 100644
--- a/test/encoder/main.c
+++ b/test/encoder/main.c
@@ -1,47 +1,48 @@
 /******************************************************************************
  *
  * Copyright (C) 2015 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  *****************************************************************************
  * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
 */
 
 /*****************************************************************************/
 /* File Includes                                                             */
 /*****************************************************************************/
 
 /* System include files */
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
 #include <assert.h>
 #include <string.h>
+#include <stdbool.h>
 
 #ifdef WINDOWS_TIMER
 #include "windows.h"
 #else
 #include <sys/time.h>
 #endif
 /* User include files */
 #include "ih264_typedefs.h"
 #include "ih264_defs.h"
 #include "iv2.h"
 #include "ive2.h"
 #include "ih264e.h"
 #include "app.h"
 #include "psnr.h"
 
 /* Function declarations */
 #ifndef MD5_DISABLE
@@ -1669,777 +1670,895 @@ void set_sei_ave_params(app_ctxt_t *ps_app_ctxt,
 void set_sei_ccv_params(app_ctxt_t *ps_app_ctxt,
                         UWORD32 u4_timestamp_low,
                         UWORD32 u4_timestamp_high)
 {
     WORD32 i4_count;
     IV_STATUS_T status;
 
     ih264e_ctl_set_sei_ccv_params_ip_t s_sei_ccv_params_ip;
     ih264e_ctl_set_sei_ccv_params_op_t s_sei_ccv_params_op;
 
     s_sei_ccv_params_ip.e_cmd = IVE_CMD_VIDEO_CTL;
     s_sei_ccv_params_ip.e_sub_cmd = IVE_CMD_CTL_SET_SEI_CCV_PARAMS;
 
     s_sei_ccv_params_ip.u1_sei_ccv_params_present_flag =
                             (UWORD8)ps_app_ctxt->u4_sei_ccv_params_present_flag;
 
     s_sei_ccv_params_ip.u1_ccv_cancel_flag = (UWORD8)ps_app_ctxt->u4_ccv_cancel_flag;
     s_sei_ccv_params_ip.u1_ccv_persistence_flag =
                             (UWORD8)ps_app_ctxt->u4_ccv_persistence_flag;
     s_sei_ccv_params_ip.u1_ccv_primaries_present_flag =
                             (UWORD8)ps_app_ctxt->u4_ccv_primaries_present_flag;
     s_sei_ccv_params_ip.u1_ccv_min_luminance_value_present_flag =
                             (UWORD8)ps_app_ctxt->u4_ccv_min_luminance_value_present_flag;
     s_sei_ccv_params_ip.u1_ccv_max_luminance_value_present_flag =
                             (UWORD8)ps_app_ctxt->u4_ccv_max_luminance_value_present_flag;
     s_sei_ccv_params_ip.u1_ccv_avg_luminance_value_present_flag =
                             (UWORD8)ps_app_ctxt->u4_ccv_avg_luminance_value_present_flag;
     s_sei_ccv_params_ip.u1_ccv_reserved_zero_2bits =
                             (UWORD8)ps_app_ctxt->u4_ccv_reserved_zero_2bits;
 
     for(i4_count = 0; i4_count < NUM_SEI_CCV_PRIMARIES; i4_count++)
     {
         s_sei_ccv_params_ip.ai4_ccv_primaries_x[i4_count] =
                             ps_app_ctxt->ai4_ccv_primaries_x[i4_count];
         s_sei_ccv_params_ip.ai4_ccv_primaries_y[i4_count] =
                             ps_app_ctxt->ai4_ccv_primaries_y[i4_count];
     }
 
     s_sei_ccv_params_ip.u4_ccv_min_luminance_value = ps_app_ctxt->u4_ccv_min_luminance_value;
     s_sei_ccv_params_ip.u4_ccv_max_luminance_value = ps_app_ctxt->u4_ccv_max_luminance_value;
     s_sei_ccv_params_ip.u4_ccv_avg_luminance_value = ps_app_ctxt->u4_ccv_avg_luminance_value;
 
     s_sei_ccv_params_ip.u4_timestamp_high  =   u4_timestamp_high;
     s_sei_ccv_params_ip.u4_timestamp_low   =   u4_timestamp_low;
 
     s_sei_ccv_params_ip.u4_size = sizeof(ih264e_ctl_set_sei_ccv_params_ip_t);
     s_sei_ccv_params_op.u4_size = sizeof(ih264e_ctl_set_sei_ccv_params_op_t);
 
     status = ih264e_api_function(ps_app_ctxt->ps_enc, &s_sei_ccv_params_ip,
                                  &s_sei_ccv_params_op);
     if(status != IV_SUCCESS)
     {
         printf("Unable to set sei ccv params = 0x%x\n",
                 s_sei_ccv_params_op.u4_error_code);
     }
     return;
 }
 
+void set_sei_sii_params(app_ctxt_t *ps_app_ctxt, UWORD32 u4_timestamp_low,
+                        UWORD32 u4_timestamp_high)
+{
+    IV_STATUS_T status;
+    int i;
+    bool au4_sub_layer_num_units_in_shutter_interval_flag = 0;
+
+    ih264e_ctl_set_sei_sii_params_ip_t s_sei_sii_params_ip = {0};
+    ih264e_ctl_set_sei_sii_params_op_t s_sei_sii_params_op = {0};
+
+    s_sei_sii_params_ip.e_cmd = IVE_CMD_VIDEO_CTL;
+    s_sei_sii_params_ip.e_sub_cmd = IVE_CMD_CTL_SET_SEI_SII_PARAMS;
+
+    s_sei_sii_params_ip.u4_sii_sub_layer_idx = ps_app_ctxt->u4_sii_sub_layer_idx;
+
+    if(0 == s_sei_sii_params_ip.u4_sii_sub_layer_idx)
+    {
+        s_sei_sii_params_ip.u1_shutter_interval_info_present_flag =
+            (UWORD8) ps_app_ctxt->u4_shutter_interval_info_present_flag;
+
+        if(1 == s_sei_sii_params_ip.u1_shutter_interval_info_present_flag)
+        {
+            s_sei_sii_params_ip.u4_sii_time_scale = ps_app_ctxt->u4_sii_time_scale;
+            s_sei_sii_params_ip.u1_fixed_shutter_interval_within_cvs_flag =
+                (UWORD8) ps_app_ctxt->u4_fixed_shutter_interval_within_cvs_flag;
+
+            if(1 == s_sei_sii_params_ip.u1_fixed_shutter_interval_within_cvs_flag)
+            {
+                s_sei_sii_params_ip.u4_sii_num_units_in_shutter_interval =
+                    ps_app_ctxt->u4_sii_num_units_in_shutter_interval;
+            }
+            else
+            {
+                s_sei_sii_params_ip.u1_sii_max_sub_layers_minus1 =
+                    (UWORD8) ps_app_ctxt->u4_sii_max_sub_layers_minus1;
+
+                for(i = 0; i <= s_sei_sii_params_ip.u1_sii_max_sub_layers_minus1; i++)
+                {
+                    s_sei_sii_params_ip.au4_sub_layer_num_units_in_shutter_interval[i] =
+                        ps_app_ctxt->au4_sub_layer_num_units_in_shutter_interval[i];
+                }
+            }
+        }
+    }
+
+    s_sei_sii_params_ip.u4_timestamp_high = u4_timestamp_high;
+    s_sei_sii_params_ip.u4_timestamp_low = u4_timestamp_low;
+
+    s_sei_sii_params_ip.u4_size = sizeof(ih264e_ctl_set_sei_sii_params_ip_t);
+    s_sei_sii_params_op.u4_size = sizeof(ih264e_ctl_set_sei_sii_params_op_t);
+
+    for(i = 0; i <= s_sei_sii_params_ip.u1_sii_max_sub_layers_minus1; i++)
+    {
+        au4_sub_layer_num_units_in_shutter_interval_flag =
+            (au4_sub_layer_num_units_in_shutter_interval_flag ||
+             (ps_app_ctxt->s_sei_sii_params.au4_sub_layer_num_units_in_shutter_interval[i] !=
+              s_sei_sii_params_ip.au4_sub_layer_num_units_in_shutter_interval[i]));
+    }
+
+    if((ps_app_ctxt->s_sei_sii_params.u4_sii_sub_layer_idx !=
+        s_sei_sii_params_ip.u4_sii_sub_layer_idx) ||
+       (ps_app_ctxt->s_sei_sii_params.u1_shutter_interval_info_present_flag !=
+        s_sei_sii_params_ip.u1_shutter_interval_info_present_flag) ||
+       (ps_app_ctxt->s_sei_sii_params.u4_sii_time_scale != s_sei_sii_params_ip.u4_sii_time_scale) ||
+       (ps_app_ctxt->s_sei_sii_params.u1_fixed_shutter_interval_within_cvs_flag !=
+        s_sei_sii_params_ip.u1_fixed_shutter_interval_within_cvs_flag) ||
+       (ps_app_ctxt->s_sei_sii_params.u4_sii_num_units_in_shutter_interval !=
+        s_sei_sii_params_ip.u4_sii_num_units_in_shutter_interval) ||
+       (ps_app_ctxt->s_sei_sii_params.u1_sii_max_sub_layers_minus1 !=
+        s_sei_sii_params_ip.u1_sii_max_sub_layers_minus1) ||
+       au4_sub_layer_num_units_in_shutter_interval_flag)
+    {
+        status =
+            ih264e_api_function(ps_app_ctxt->ps_enc, &s_sei_sii_params_ip, &s_sei_sii_params_op);
+        if(status != IV_SUCCESS)
+        {
+            printf("Unable to set sei sii params = 0x%x\n", s_sei_sii_params_op.u4_error_code);
+        }
+        ps_app_ctxt->s_sei_sii_params = s_sei_sii_params_ip;
+    }
+    return;
+}
+
 #define PEAK_WINDOW_SIZE    8
 
 void synchronous_encode(iv_obj_t *ps_enc, app_ctxt_t *ps_app_ctxt)
 {
-    ih264e_video_encode_ip_t ih264e_video_encode_ip;
-    ih264e_video_encode_op_t ih264e_video_encode_op;
+    ih264e_video_encode_ip_t ih264e_video_encode_ip = {0};
+    ih264e_video_encode_op_t ih264e_video_encode_op = {0};
 
     ive_video_encode_ip_t *ps_video_encode_ip = &ih264e_video_encode_ip.s_ive_ip;
     ive_video_encode_op_t *ps_video_encode_op = &ih264e_video_encode_op.s_ive_op;
 
     iv_raw_buf_t *ps_inp_raw_buf = &ps_video_encode_ip->s_inp_buf;
 
     IV_STATUS_T status = IV_SUCCESS;
 
     WORD32 i, is_last = 0, buff_size = 0, num_bytes = 0;
     UWORD32 u4_total_time = 0;
     UWORD8 *pu1_buf = NULL;
     UWORD32 u4_timestamp_low, u4_timestamp_high;
     void *pv_mb_info = NULL, *pv_pic_info = NULL;
 
     TIMER curtime ;
 #ifdef WINDOWS_TIMER
     TIMER frequency;
 #endif
     WORD32 peak_window[PEAK_WINDOW_SIZE] = {0};
     WORD32 peak_window_idx = 0;
     WORD32 peak_avg_max = 0, timetaken = 0;
     iv_raw_buf_t s_inp_buf, s_recon_buf;
     CHAR ac_error[STRLENGTH];
     WORD32 end_of_frames=0;
     WORD32 i4_inp_done =0;
 
     u4_timestamp_low = 0;
     u4_timestamp_high = 0;
 
     /*************************************************************************/
     /*                         Allocate I/O Buffers                          */
     /*************************************************************************/
     allocate_input(ps_app_ctxt);
     allocate_output(ps_app_ctxt);
     allocate_recon(ps_app_ctxt);
 
     /* init psnr */
     init_psnr(ps_app_ctxt);
 
     /* open file pointers */
     ps_app_ctxt->fp_ip = fopen(ps_app_ctxt->ac_ip_fname, "rb");
     if(NULL == ps_app_ctxt->fp_ip)
     {
         sprintf(ac_error, "Unable to open input file for reading: %s", ps_app_ctxt->ac_ip_fname);
         invalid_argument_exit(ac_error);
     }
 
     ps_app_ctxt->fp_op = fopen(ps_app_ctxt->ac_op_fname, "wb");
     if(NULL == ps_app_ctxt->fp_op)
     {
         sprintf(ac_error, "Unable to open output file for writing: %s", ps_app_ctxt->ac_op_fname);
         invalid_argument_exit(ac_error);
     }
 
     if(1 == ps_app_ctxt->u4_recon_enable)
     {
         ps_app_ctxt->fp_recon = fopen(ps_app_ctxt->ac_recon_fname, "wb");
         if(NULL == ps_app_ctxt->fp_recon)
         {
             sprintf(ac_error, "Unable to open recon file for writing: %s", ps_app_ctxt->ac_recon_fname);
             invalid_argument_exit(ac_error);
         }
     }
 
     if(1 == ps_app_ctxt->u4_chksum_enable)
     {
         ps_app_ctxt->fp_chksum               = fopen(ps_app_ctxt->ac_chksum_fname, "wb");
         if(NULL == ps_app_ctxt->fp_chksum)
         {
             sprintf(ac_error, "Unable to open checksum file for writing: %s", ps_app_ctxt->ac_chksum_fname);
             invalid_argument_exit(ac_error);
         }
     }
 
     /* If PSNR is enabled, open input file again and hold a different file pointer
      * This makes it easy to compute PSNR without adding dependency between input and recon threads
      */
     if(1 == ps_app_ctxt->u4_psnr_enable)
     {
         ps_app_ctxt->fp_psnr_ip              = fopen(ps_app_ctxt->ac_ip_fname, "rb");
         if(NULL == ps_app_ctxt->fp_psnr_ip)
         {
             sprintf(ac_error, "Unable to open input file for reading: %s", ps_app_ctxt->ac_ip_fname);
             invalid_argument_exit(ac_error);
         }
     }
 
     if(0 != ps_app_ctxt->u4_mb_info_type)
     {
         ps_app_ctxt->fp_mb_info  = fopen(ps_app_ctxt->ac_mb_info_fname, "rb");
         if(NULL == ps_app_ctxt->fp_mb_info)
         {
             sprintf(ac_error, "Unable to open MB info file for reading: %s", ps_app_ctxt->ac_mb_info_fname);
             invalid_argument_exit(ac_error);
         }
     }
     if (ps_app_ctxt->u4_pic_info_type)
     {
         ps_app_ctxt->fp_pic_info  = fopen(ps_app_ctxt->ac_pic_info_fname, "rb");
         if(NULL == ps_app_ctxt->fp_pic_info)
         {
             sprintf(ac_error, "Unable to open Pic info file for reading: %s", ps_app_ctxt->ac_pic_info_fname);
             invalid_argument_exit(ac_error);
         }
     }
 
     /*****************************************************************************/
     /*   Video control Set in Encode header mode                                 */
     /*****************************************************************************/
     set_enc_mode(ps_app_ctxt, -1, -1, IVE_ENC_MODE_HEADER);
 
     // Encode header
     memset(&ih264e_video_encode_ip, 0, sizeof(ih264e_video_encode_ip));
     memset(&ih264e_video_encode_op, 0, sizeof(ih264e_video_encode_op));
 
     ps_video_encode_ip->u4_size = sizeof(ih264e_video_encode_ip_t);
     ps_video_encode_op->u4_size = sizeof(ih264e_video_encode_op_t);
 
     ps_inp_raw_buf->apv_bufs[0] = NULL;
     ps_inp_raw_buf->apv_bufs[1] = NULL;
     ps_inp_raw_buf->apv_bufs[2] = NULL;
 
     ps_video_encode_ip->e_cmd = IVE_CMD_VIDEO_ENCODE;
     ps_video_encode_ip->pv_bufs = NULL;
     ps_video_encode_ip->pv_mb_info = NULL;
     ps_video_encode_ip->pv_pic_info = NULL;
     ps_video_encode_ip->u4_pic_info_type = ps_app_ctxt->u4_pic_info_type;
     ps_video_encode_ip->u4_is_last = 0;
     ps_video_encode_ip->u4_mb_info_type = ps_app_ctxt->u4_mb_info_type;
     ps_video_encode_ip->u4_pic_info_type = ps_app_ctxt->u4_pic_info_type;
     ps_video_encode_ip->s_out_buf.pv_buf = ps_app_ctxt->as_output_buf[0].pu1_buf;
     ps_video_encode_ip->s_out_buf.u4_bytes = 0;
     ps_video_encode_ip->s_out_buf.u4_bufsize = ps_app_ctxt->as_output_buf[0].u4_buf_size;
     ps_video_encode_ip->u4_timestamp_high = 0;
     ps_video_encode_ip->u4_timestamp_low = 0;
 
     status = ih264e_api_function(ps_enc, &ih264e_video_encode_ip, &ih264e_video_encode_op);
     if(IV_SUCCESS != status)
     {
         printf("Encode Header failed = 0x%x\n", ih264e_video_encode_op.s_ive_op.u4_error_code);
         return;
     }
 
     if(1 == ps_video_encode_op->output_present)
     {
         status = write_output(ps_app_ctxt->fp_op, (UWORD8 *) ps_video_encode_op->s_out_buf.pv_buf,
                               ps_video_encode_op->s_out_buf.u4_bytes);
         if(IV_SUCCESS != status)
         {
             printf("Error: Unable to write to output file\n");
             return;
         }
     }
 
     /*****************************************************************************/
     /*   Video control Set in Encode picture mode                                */
     /*****************************************************************************/
     set_enc_mode(ps_app_ctxt, -1, -1, IVE_ENC_MODE_PICTURE);
 
     GETTIME(&ps_app_ctxt->enc_start_time);
     ps_app_ctxt->enc_last_time = ps_app_ctxt->enc_start_time;
 
     while(1)
     {
         IV_PICTURE_CODING_TYPE_T  e_frame_type;
         WORD32 i4_count;
 
         /* Default sei params values*/
         ps_app_ctxt->u4_sei_mdcv_params_present_flag = 1;
         if(1 == ps_app_ctxt->u4_sei_mdcv_params_present_flag)
         {
             for(i4_count = 0; i4_count < NUM_SEI_MDCV_PRIMARIES; i4_count++)
             {
                 ps_app_ctxt->au4_display_primaries_x[i4_count] = 0;
                 ps_app_ctxt->au4_display_primaries_y[i4_count] = 0;
             }
             ps_app_ctxt->u4_white_point_x = 0;
             ps_app_ctxt->u4_white_point_y = 0;
             ps_app_ctxt->u4_max_display_mastering_luminance = DEFAULT_MAX_DISPLAY_MASTERING_LUMINANCE;
             ps_app_ctxt->u4_min_display_mastering_luminance = DEFAULT_MIN_DISPLAY_MASTERING_LUMINANCE;
             set_sei_mdcv_params(ps_app_ctxt, u4_timestamp_low, u4_timestamp_high);
         }
 
         ps_app_ctxt->u4_sei_cll_params_present_flag = 1;
         if(1 == ps_app_ctxt->u4_sei_cll_params_present_flag)
         {
             ps_app_ctxt->u4_max_content_light_level = 0;
             ps_app_ctxt->u4_max_pic_average_light_level = 0;
             set_sei_cll_params(ps_app_ctxt, u4_timestamp_low, u4_timestamp_high);
         }
 
         ps_app_ctxt->u4_sei_ave_params_present_flag = 1;
         if(1 == ps_app_ctxt->u4_sei_ave_params_present_flag)
         {
             ps_app_ctxt->u4_ambient_illuminance = 1;
             ps_app_ctxt->u4_ambient_light_x = 0;
             ps_app_ctxt->u4_ambient_light_y = 0;
             set_sei_ave_params(ps_app_ctxt, u4_timestamp_low, u4_timestamp_high);
         }
 
         ps_app_ctxt->u4_sei_ccv_params_present_flag = 1;
         if(1 == ps_app_ctxt->u4_sei_ccv_params_present_flag)
         {
             ps_app_ctxt->u4_ccv_cancel_flag = 0;
             ps_app_ctxt->u4_ccv_persistence_flag = 1;
             ps_app_ctxt->u4_ccv_primaries_present_flag = 1;
             ps_app_ctxt->u4_ccv_min_luminance_value_present_flag = 1;
             ps_app_ctxt->u4_ccv_max_luminance_value_present_flag = 1;
             ps_app_ctxt->u4_ccv_avg_luminance_value_present_flag = 1;
             ps_app_ctxt->u4_ccv_reserved_zero_2bits = 0;
             for(i4_count = 0; i4_count < NUM_SEI_CCV_PRIMARIES; i4_count++)
             {
                 ps_app_ctxt->ai4_ccv_primaries_x[i4_count] = 1;
                 ps_app_ctxt->ai4_ccv_primaries_y[i4_count] = 1;
             }
             ps_app_ctxt->u4_ccv_min_luminance_value = 1;
             ps_app_ctxt->u4_ccv_max_luminance_value = 1;
             ps_app_ctxt->u4_ccv_avg_luminance_value = 1;
             set_sei_ccv_params(ps_app_ctxt, u4_timestamp_low, u4_timestamp_high);
         }
 
+        ps_app_ctxt->u4_sii_sub_layer_idx = SII_SUB_LAYER_IDX;
+
+        if(0 == ps_app_ctxt->u4_sii_sub_layer_idx)
+        {
+            ps_app_ctxt->u4_shutter_interval_info_present_flag = SHUTTER_INTERVAL_INFO_PRESENT_FLAG;
+
+            if(1 == ps_app_ctxt->u4_shutter_interval_info_present_flag)
+            {
+                ps_app_ctxt->u4_sii_time_scale = SII_TIME_SCALE;
+                ps_app_ctxt->u4_fixed_shutter_interval_within_cvs_flag =
+                    FIXED_SHUTTER_INTERVAL_WITHIN_CVS_FLAG;
+
+                if(1 == ps_app_ctxt->u4_fixed_shutter_interval_within_cvs_flag)
+                {
+                    ps_app_ctxt->u4_sii_num_units_in_shutter_interval =
+                        SII_NUM_UNITS_IN_SHUTTER_INTERVAL;
+                }
+                else
+                {
+                    int i;
+                    ps_app_ctxt->u4_sii_max_sub_layers_minus1 = SII_MAX_SUB_LAYERS_MINUS1;
+
+                    for(i = 0; i <= (int) ps_app_ctxt->u4_sii_max_sub_layers_minus1; i++)
+                    {
+                        ps_app_ctxt->au4_sub_layer_num_units_in_shutter_interval[i] =
+                            SUB_LAYER_NUM_UNITS_IN_SHUTTER_INTERVAL_HFR;
+                    }
+                    ps_app_ctxt->au4_sub_layer_num_units_in_shutter_interval
+                        [ps_app_ctxt->u4_sii_max_sub_layers_minus1] =
+                        SUB_LAYER_NUM_UNITS_IN_SHUTTER_INTERVAL_SFR;
+                }
+            }
+        }
+        set_sei_sii_params(ps_app_ctxt, u4_timestamp_low, u4_timestamp_high);
+
         /******************************************************************************/
         /****************** Input Initialization **************************************/
         /******************************************************************************/
 
         for(i = 0; i < DEFAULT_MAX_INPUT_BUFS; i++)
         {
             if(ps_app_ctxt->as_input_buf[i].u4_is_free)
             {
                 pu1_buf = ps_app_ctxt->as_input_buf[i].pu1_buf;
                 pv_mb_info = ps_app_ctxt->as_input_buf[i].pv_mb_info;
                 pv_pic_info = ps_app_ctxt->as_input_buf[i].pv_pic_info;
                 ps_app_ctxt->as_input_buf[i].u4_is_free = 0;
                 break;
             }
         }
 
         if (i == DEFAULT_MAX_INPUT_BUFS)
         {
             printf("\n Unable to find a free input buffer!!");
             exit(0);
         }
 
         memset(&ih264e_video_encode_ip, 0, sizeof(ih264e_video_encode_ip));
         memset(&ih264e_video_encode_op, 0, sizeof(ih264e_video_encode_op));
 
         ps_video_encode_ip->u4_size = sizeof(ih264e_video_encode_ip_t);
         ps_video_encode_op->u4_size = sizeof(ih264e_video_encode_op_t);
 
         ps_video_encode_ip->e_cmd = IVE_CMD_VIDEO_ENCODE;
         ps_video_encode_ip->pv_bufs = pu1_buf;
         ps_video_encode_ip->pv_mb_info = pv_mb_info;
         ps_video_encode_ip->pv_pic_info = pv_pic_info;
         ps_video_encode_ip->u4_pic_info_type = ps_app_ctxt->u4_pic_info_type;
         /*
          * Since the buffers are used for reading,
          * And after each row we have a stride we nned to calculate
          * the luma size according to the stride
          */
         ps_inp_raw_buf->e_color_fmt = ps_app_ctxt->e_inp_color_fmt;
 
         /* Initialize for 420SP */
         if(IV_YUV_420SP_UV == ps_app_ctxt->e_inp_color_fmt||
                         IV_YUV_420SP_VU == ps_app_ctxt->e_inp_color_fmt)
         {
             /*init luma buffer*/
             ps_inp_raw_buf->apv_bufs[0] = pu1_buf;
 
             /*Init chroma buffer*/
             pu1_buf += ps_app_ctxt->u4_strd * ps_app_ctxt->u4_ht;
             ps_inp_raw_buf->apv_bufs[1] = pu1_buf;
 
             ps_inp_raw_buf->au4_wd[0] =  ps_app_ctxt->u4_wd;
             ps_inp_raw_buf->au4_wd[1] =  ps_app_ctxt->u4_wd;
 
             ps_inp_raw_buf->au4_ht[0] =  ps_app_ctxt->u4_ht;
             ps_inp_raw_buf->au4_ht[1] =  ps_app_ctxt->u4_ht / 2;
 
             ps_inp_raw_buf->au4_strd[0] =  ps_app_ctxt->u4_strd;
             ps_inp_raw_buf->au4_strd[1] =  ps_app_ctxt->u4_strd;
         }
         else if(IV_YUV_420P == ps_app_ctxt->e_inp_color_fmt)
         {
             /* init buffers */
             ps_inp_raw_buf->apv_bufs[0] = pu1_buf;
             pu1_buf += (ps_app_ctxt->u4_wd) * ps_app_ctxt->u4_ht;
             ps_inp_raw_buf->apv_bufs[1] = pu1_buf;
             pu1_buf += (ps_app_ctxt->u4_wd >> 1) * (ps_app_ctxt->u4_ht >> 1);
             ps_inp_raw_buf->apv_bufs[2] = pu1_buf;
 
             ps_inp_raw_buf->au4_wd[0] =  ps_app_ctxt->u4_wd;
             ps_inp_raw_buf->au4_wd[1] =  ps_app_ctxt->u4_wd / 2;
             ps_inp_raw_buf->au4_wd[2] =  ps_app_ctxt->u4_wd / 2;
 
             ps_inp_raw_buf->au4_ht[0] =  ps_app_ctxt->u4_ht;
             ps_inp_raw_buf->au4_ht[1] =  ps_app_ctxt->u4_ht / 2;
             ps_inp_raw_buf->au4_ht[2] =  ps_app_ctxt->u4_ht / 2;
 
             ps_inp_raw_buf->au4_strd[0] =  ps_app_ctxt->u4_strd;
             ps_inp_raw_buf->au4_strd[1] =  ps_app_ctxt->u4_strd / 2;
             ps_inp_raw_buf->au4_strd[2] =  ps_app_ctxt->u4_strd / 2;
 
         }
         else if(IV_YUV_422ILE == ps_app_ctxt->e_inp_color_fmt)
         {
             /*init luma buffer*/
             ps_inp_raw_buf->apv_bufs[0] = pu1_buf;
 
             ps_inp_raw_buf->au4_wd[0] =  ps_app_ctxt->u4_wd * 2;
 
             ps_inp_raw_buf->au4_ht[0] =  ps_app_ctxt->u4_ht;
 
             ps_inp_raw_buf->au4_strd[0] = ps_app_ctxt->u4_strd *2;
         }
 
         /*
          * Here we read input and other associated buffers. Regardless of success
          * we will proceed from here as we will need extra calls to flush out
          * input queue in encoder. Note that this is not necessary. You can just
          * send encode calls till with valid output and recon buffers till the
          * queue is flushed.
          */
         while(1)
         {
             IV_STATUS_T mb_info_status = IV_SUCCESS, pic_info_status = IV_SUCCESS;
 
             status = read_input(ps_app_ctxt->fp_ip, ps_inp_raw_buf);
 
             if (ps_app_ctxt->u4_mb_info_type != 0)
             {
                 mb_info_status = read_mb_info(ps_app_ctxt, pv_mb_info);
             }
             if (ps_app_ctxt->u4_pic_info_type != 0)
             {
                 pic_info_status = read_pic_info(ps_app_ctxt, pv_pic_info);
             }
             if((IV_SUCCESS != status) || (IV_SUCCESS != mb_info_status)
                             || (IV_SUCCESS != pic_info_status))
             {
                 if(0 == ps_app_ctxt->u4_loopback)
                 {
                     is_last = 1;
                     break;
                 }
                 else
                     fseek(ps_app_ctxt->fp_ip, 0, SEEK_SET);
             }
             break;
         }
 
         /******************************************************************************/
         /****************** Output Initialization *************************************/
         /******************************************************************************/
 
         for(i = 0; i < DEFAULT_MAX_OUTPUT_BUFS; i++)
         {
             if(ps_app_ctxt->as_output_buf[i].u4_is_free)
             {
                 pu1_buf = ps_app_ctxt->as_output_buf[i].pu1_buf;
                 buff_size = ps_app_ctxt->as_output_buf[i].u4_buf_size;
                 ps_app_ctxt->as_output_buf[i].u4_is_free = 0;
                 break;
             }
         }
         ps_video_encode_ip->s_out_buf.pv_buf = pu1_buf;
         ps_video_encode_ip->s_out_buf.u4_bytes = 0;
         ps_video_encode_ip->s_out_buf.u4_bufsize = buff_size;
 
         /******************************************************************************/
         /****************** Recon Initialization **************************************/
         /******************************************************************************/
         init_raw_buf_descr(ps_app_ctxt, &s_recon_buf, ps_app_ctxt->as_recon_buf[0].pu1_buf, ps_app_ctxt->e_recon_color_fmt);
 
         if(ps_app_ctxt->u4_psnr_enable)
             init_raw_buf_descr(ps_app_ctxt, &s_inp_buf, ps_app_ctxt->pu1_psnr_buf, ps_app_ctxt->e_inp_color_fmt);
 
         ps_video_encode_ip->s_recon_buf = s_recon_buf;
 
         /******************************************************************************/
         /************************* Un Initialized *************************************/
         /******************************************************************************/
         if(0 == ps_app_ctxt->u4_loopback)
         {
             /* If input file is read completely and loopback is not enabled,
              *  then exit the loop */
             if(feof(ps_app_ctxt->fp_ip))
             {
                 is_last = 1;
             }
         }
 
 
         /* If last frame, send input null to get back encoded frames */
         if ( is_last == 1 || ((ps_app_ctxt->u4_max_num_frms) <= u4_timestamp_low) )
         {
             is_last = 1;
             ps_inp_raw_buf->apv_bufs[0] = NULL;
             ps_inp_raw_buf->apv_bufs[1] = NULL;
             ps_inp_raw_buf->apv_bufs[2] = NULL;
         }
 
         ps_video_encode_ip->u4_is_last = is_last;
         ps_video_encode_ip->u4_mb_info_type = ps_app_ctxt->u4_mb_info_type;
         ps_video_encode_ip->u4_pic_info_type = ps_app_ctxt->u4_pic_info_type;;
         ps_video_encode_ip->u4_timestamp_high = u4_timestamp_high;
         ps_video_encode_ip->u4_timestamp_low = u4_timestamp_low;
 
 
         GETTIME(&ps_app_ctxt->enc_last_time);
 
         status = ih264e_api_function(ps_enc, &ih264e_video_encode_ip, &ih264e_video_encode_op);
 
         if (IV_SUCCESS != status)
         {
             printf("Encode Frame failed = 0x%x\n", ih264e_video_encode_op.s_ive_op.u4_error_code);
             break;
         }
 
 #ifdef WINDOWS_TIMER
         QueryPerformanceFrequency ( &frequency);
 #endif
         GETTIME(&curtime);
         ELAPSEDTIME(ps_app_ctxt->enc_last_time, curtime, timetaken, frequency);
         ps_app_ctxt->enc_last_time = curtime;
 
 #ifdef PROFILE_ENABLE
         {
             WORD32 peak_avg, id;
             u4_total_time += timetaken;
             peak_window[peak_window_idx++] = timetaken;
             if(peak_window_idx == PEAK_WINDOW_SIZE)
                 peak_window_idx = 0;
             peak_avg = 0;
             for(id = 0; id < PEAK_WINDOW_SIZE; id++)
             {
                 peak_avg += peak_window[id];
             }
             peak_avg /= PEAK_WINDOW_SIZE;
             if (peak_avg > peak_avg_max)
                 peak_avg_max = peak_avg;
         }
 #endif
 
         /******************************************************************************/
         /****************** Writing Output ********************************************/
         /******************************************************************************/
         num_bytes = 0;
 
         if(1 == ps_video_encode_op->output_present)
         {
             num_bytes = ps_video_encode_op->s_out_buf.u4_bytes;
             buff_size = ps_video_encode_op->s_out_buf.u4_bufsize;
             pu1_buf = (UWORD8*)ps_video_encode_op->s_out_buf.pv_buf;
 
             status = write_output(ps_app_ctxt->fp_op, pu1_buf, num_bytes);
             if(IV_SUCCESS != status)
             {
                 printf("Error: Unable to write to output file\n");
                 break;
             }
         }
 
         /* free input bufer if codec returns a valid input buffer */
         if (ps_video_encode_op->s_inp_buf.apv_bufs[0])
         {
             /* Reuse of freed input buffer */
             for(i = 0; i < DEFAULT_MAX_INPUT_BUFS; i++)
             {
                 if(ps_app_ctxt->as_input_buf[i].pu1_buf == ps_video_encode_op->s_inp_buf.apv_bufs[0])
                 {
                     ps_app_ctxt->as_input_buf[i].u4_is_free = 1;
                     break;
                 }
             }
         }
 
         /* free output buffer if codec returns a valid output buffer */
         // if(ps_video_encode_op->s_out_buf.pv_buf)
         {
             for(i = 0; i < DEFAULT_MAX_OUTPUT_BUFS; i++)
             {
                 if(ps_app_ctxt->as_output_buf[i].pu1_buf == ps_video_encode_op->s_out_buf.pv_buf)
                 {
                     ps_app_ctxt->as_output_buf[i].u4_is_free = 1;
                     break;
                 }
             }
         }
 
         /**********************************************************************
          *  Print stats
          **********************************************************************/
         {
             UWORD8 u1_pic_type[][5] =
                 { "IDR", "I", "P", "B", "NA" };
             WORD32 lookup_idx = 0;
 
             if (ih264e_video_encode_op.s_ive_op.u4_encoded_frame_type
                             == IV_IDR_FRAME)
             {
                 lookup_idx = 0;
             }
             else if(ih264e_video_encode_op.s_ive_op.u4_encoded_frame_type
                             == IV_I_FRAME)
             {
                 lookup_idx = 1;
             }
             else if(ih264e_video_encode_op.s_ive_op.u4_encoded_frame_type
                             == IV_P_FRAME)
             {
                 lookup_idx = 2;
             }
             else if(ih264e_video_encode_op.s_ive_op.u4_encoded_frame_type
                             == IV_B_FRAME)
             {
                 lookup_idx = 3;
             }
             else if(ih264e_video_encode_op.s_ive_op.u4_encoded_frame_type
                             == IV_NA_FRAME)
             {
                 lookup_idx = 4;
             }
 
             if (ih264e_video_encode_op.s_ive_op.u4_encoded_frame_type
                             != IV_NA_FRAME)
             {
                 ps_app_ctxt->u4_pics_cnt++;
                 ps_app_ctxt->avg_time = u4_total_time / ps_app_ctxt->u4_pics_cnt;
                 ps_app_ctxt->u4_total_bytes += num_bytes;
             }
 
             if (ps_app_ctxt->u4_psnr_enable == 0)
             {
                 printf("[%s] PicNum %4d Bytes Generated %6d TimeTaken(microsec): %6d AvgTime: %6d PeakAvgTimeMax: %6d\n",
                        u1_pic_type[lookup_idx], ps_app_ctxt->u4_pics_cnt,
                        num_bytes, timetaken, ps_app_ctxt->avg_time,
                        peak_avg_max);
             }
         }
 
 
         /* For psnr computation, we need to read the correct input frame and
          * compare with recon. The difficulty with doing it is that we only know
          * that the frame number of recon is monotonically increasing. There
          * may be gaps in the recon if any pre or post enc skip happens. There are
          * 3 senarios
          *  1) A frame is encoded -> returns the pic type
          *  2) A frame is not encoded -> Encoder is waiting, the frame may get
          *     encoded later
          *  3) A frame is not encoded -> A post enc or pre enc skip happend. The
          *     frame is not going to be encoded
          *
          *     The 1st and 2nd scenarios are easy, since we just needs to increment
          *     recon cnt whenever we get a valid recon. This cnt can we used to
          *     sync the recon and input
          *     3rd scenario in conjuction with 2nd will pose problems. Even if
          *     the returning frame is NA, we donot know we should increment the
          *     recon cnt or not becasue it can be case 2 or case 3.
          *
          *  Solutions:
          *  -------------------------
          *   One way to over come this will be to return more information as of
          *   the frame type. We can send if a frame was skipped as a part of the
          *   return frame type.
          *   This will not work. Since the output and recon are not in sync, we
          *   cannot use the current output frame type to determine if a recon
          *   is present currently or not. We need some other way to acheive this.
          *
          *   Other way to do this which is cleaner and maintains the seperation
          *   between recon and the ouptut is to set the width [& height] of output recon
          *   buffer to be zero. Hence we will in effect be saying :"look there
          *   is a recon, but due to frame not being encoded it is having a width 0".
          *   To be more clear we need to make height also to be zero.
          *
          *   But are we using these variables for allocating and deallocating
          *   the buffers some where ? No we are not. The buffer gets re-init
          *   at every encode call
          *
          *   Fixes
          *   ------------------------
          *   Currently the recon buff width and height are set in the encoder.
          *   This will not work now because since recon and input are not
          *   in sync. Hence a recon buff sent at time stamp x will get used to
          *   fill recon of input at time stamp y (x > y). If we reduced the
          *   frame dimensions in between, the recon buffer will not have enough
          *   space. Hence we need to set the with and height appropriatley inside
          *   lib itself.
          */
 
         if (ps_app_ctxt->u4_recon_enable || ps_app_ctxt->u4_chksum_enable
                         || ps_app_ctxt->u4_psnr_enable)
         {
             if (ps_video_encode_op->dump_recon)
             {
                 s_recon_buf = ps_video_encode_op->s_recon_buf;
 
                 /* Read input for psnr computuation */
                 if (ps_app_ctxt->u4_psnr_enable)
                     read_input(ps_app_ctxt->fp_psnr_ip, &s_inp_buf);
 
                 /* if we have a valid recon buffer do the assocated tasks */
                 if (s_recon_buf.au4_wd[0])
                 {
                     /* Dump recon when enabled, and output bytes != 0 */
                     if (ps_app_ctxt->u4_recon_enable)
                     {
                         status = write_recon(ps_app_ctxt->fp_recon, &s_recon_buf);
                         if (IV_SUCCESS != status)
                         {
                             printf("Error: Unable to write to recon file\n");
                             break;
                         }
                     }
 
                     if (ps_app_ctxt->u4_psnr_enable)
                     {
                         compute_psnr(ps_app_ctxt, &s_recon_buf, &s_inp_buf);
                     }
 
 
                     if (ps_app_ctxt->u4_chksum_enable)
                     {
                         WORD32 comp, num_comp = 2;
 
                         if (IV_YUV_420P == s_recon_buf.e_color_fmt)
                             num_comp = 3;
 
                         for (comp = 0; comp < num_comp; comp++)
                         {
                             UWORD8 au1_chksum[16];
                             calc_md5_cksum((UWORD8 *)s_recon_buf.apv_bufs[comp],
                                            s_recon_buf.au4_strd[comp],
                                            s_recon_buf.au4_wd[comp],
                                            s_recon_buf.au4_ht[comp],
                                            au1_chksum);
                             fwrite(au1_chksum, sizeof(UWORD8), 16, ps_app_ctxt->fp_chksum);
                         }
                     }
                 }
             }
         }
 
         u4_timestamp_low++;
 
         /* Break if all the encoded frames are taken from encoder */
         if (1 == ps_video_encode_op->u4_is_last)
         {
             break;
         }
     }
 
     /* Pic count is 1 more than actual num frames encoded, because last call is to just get the output  */
     ps_app_ctxt->u4_pics_cnt--;
 
     if(ps_app_ctxt->u4_psnr_enable)
     {
         print_average_psnr(ps_app_ctxt);
     }
 
     /* house keeping operations */
     fclose(ps_app_ctxt->fp_ip);
     fclose(ps_app_ctxt->fp_op);
     if(1 == ps_app_ctxt->u4_recon_enable)
     {
         fclose(ps_app_ctxt->fp_recon);
     }
     if(1 == ps_app_ctxt->u4_chksum_enable)
     {
         fclose(ps_app_ctxt->fp_chksum);
     }
     if(1 == ps_app_ctxt->u4_psnr_enable)
     {
         fclose(ps_app_ctxt->fp_psnr_ip);
     }
 
     if(0 != ps_app_ctxt->u4_mb_info_type)
     {
         fclose(ps_app_ctxt->fp_mb_info);
     }
     if (ps_app_ctxt->u4_pic_info_type)
     {
         fclose(ps_app_ctxt->fp_pic_info);
     }
 
     free_input(ps_app_ctxt);
     free_output(ps_app_ctxt);
     free_recon(ps_app_ctxt);
 }
 
 /*****************************************************************************/
 /*                                                                           */
 /*  Function Name : main                                                     */
 /*                                                                           */
 /*  Description   : Application to demonstrate codec API                     */
 /*                                                                           */
 /*                                                                           */
 /*  Inputs        : argc    - Number of arguments                            */
 /*                  argv[]  - Arguments                                      */
 /*  Globals       :                                                          */
 /*  Processing    : Shows how to use create, process, control and delete     */
 /*                                                                           */
 /*  Outputs       : Codec output in a file                                   */
 /*  Returns       :                                                          */
 /*                                                                           */
 /*  Issues        : Assumes both PROFILE_ENABLE to be                        */
 /*                  defined for multithread decode-display working           */
 /*                                                                           */
 /*  Revision History:                                                        */
 /*                                                                           */
 /*         DD MM YYYY   Author(s)       Changes                              */
 /*         20 11 2013   100189          Initial Version                      */
 /*****************************************************************************/
 #ifdef IOS
