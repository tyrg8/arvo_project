commit e1f8d2e6eb1167fd51eb5b8c99d2d40c37299897
Author: Nick Wellnhofer <wellnhofer@aevum.de>
Date:   Sun Sep 15 13:08:38 2019 +0200

    Check that crypto:rc4_decrypt produces valid UTF-8
    
    Otherwise, invalid UTF-8 could be sneaked into the output.
    
    Found by OSS-Fuzz.

diff --git a/libexslt/crypto.c b/libexslt/crypto.c
index ac390387..621fd904 100644
--- a/libexslt/crypto.c
+++ b/libexslt/crypto.c
@@ -683,79 +683,86 @@ static void
 exsltCryptoRc4DecryptFunction (xmlXPathParserContextPtr ctxt, int nargs) {
 
     int key_len = 0;
     int str_len = 0, bin_len = 0, ret_len = 0;
     xmlChar *key = NULL, *str = NULL, *padkey = NULL, *bin =
 	NULL, *ret = NULL;
     xsltTransformContextPtr tctxt = NULL;
 
     if (nargs != 2) {
 	xmlXPathSetArityError (ctxt);
 	return;
     }
     tctxt = xsltXPathGetTransformContext(ctxt);
 
     str = xmlXPathPopString (ctxt);
     str_len = xmlStrlen (str);
 
     if (str_len == 0) {
 	xmlXPathReturnEmptyString (ctxt);
 	xmlFree (str);
 	return;
     }
 
     key = xmlXPathPopString (ctxt);
     key_len = xmlStrlen (key);
 
     if (key_len == 0) {
 	xmlXPathReturnEmptyString (ctxt);
 	xmlFree (key);
 	xmlFree (str);
 	return;
     }
 
     padkey = xmlMallocAtomic (RC4_KEY_LENGTH + 1);
     if (padkey == NULL) {
 	xsltTransformError(tctxt, NULL, tctxt->inst,
 	    "exsltCryptoRc4EncryptFunction: Failed to allocate padkey\n");
 	tctxt->state = XSLT_STATE_STOPPED;
 	xmlXPathReturnEmptyString (ctxt);
 	goto done;
     }
     memset(padkey, 0, RC4_KEY_LENGTH + 1);
     if ((key_len > RC4_KEY_LENGTH) || (key_len < 0)) {
 	xsltTransformError(tctxt, NULL, tctxt->inst,
 	    "exsltCryptoRc4EncryptFunction: key size too long or key broken\n");
 	tctxt->state = XSLT_STATE_STOPPED;
 	xmlXPathReturnEmptyString (ctxt);
 	goto done;
     }
     memcpy (padkey, key, key_len);
 
 /* decode hex to binary */
     bin_len = str_len;
     bin = xmlMallocAtomic (bin_len);
     if (bin == NULL) {
 	xsltTransformError(tctxt, NULL, tctxt->inst,
 	    "exsltCryptoRc4EncryptFunction: Failed to allocate string\n");
 	tctxt->state = XSLT_STATE_STOPPED;
 	xmlXPathReturnEmptyString (ctxt);
 	goto done;
     }
     ret_len = exsltCryptoHex2Bin (str, str_len, bin, bin_len);
 
 /* decrypt the binary blob */
     ret = xmlMallocAtomic (ret_len + 1);
     if (ret == NULL) {
 	xsltTransformError(tctxt, NULL, tctxt->inst,
 	    "exsltCryptoRc4EncryptFunction: Failed to allocate result\n");
 	tctxt->state = XSLT_STATE_STOPPED;
 	xmlXPathReturnEmptyString (ctxt);
 	goto done;
     }
     PLATFORM_RC4_DECRYPT (ctxt, padkey, bin, ret_len, ret, ret_len);
     ret[ret_len] = 0;
 
-    xmlXPathReturnString (ctxt, ret);
+    if (xmlCheckUTF8(ret) == 0) {
+	xsltTransformError(tctxt, NULL, tctxt->inst,
+	    "exsltCryptoRc4DecryptFunction: Invalid UTF-8\n");
+        xmlFree(ret);
+	xmlXPathReturnEmptyString(ctxt);
+    } else {
+        xmlXPathReturnString(ctxt, ret);
+    }
 
 done:
     if (key != NULL)
