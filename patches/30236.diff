commit bd4e8bc699ba1355c5579f345b4521017b8454f1
Author: Todd C. Miller <Todd.Miller@sudo.ws>
Date:   Wed Feb 3 07:52:38 2021 -0700

    Remove options from the leak list before freeing them.
    Should fix oss-fuzz issue #30236

diff --git a/plugins/sudoers/gram.c b/plugins/sudoers/gram.c
index 09131eebb..5863103bf 100644
--- a/plugins/sudoers/gram.c
+++ b/plugins/sudoers/gram.c
@@ -855,28 +855,28 @@ static const yytype_int8 yytranslate[] =
 #if YYDEBUG
   /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_int16 yyrline[] =
 {
        0,   197,   197,   200,   203,   204,   207,   210,   213,   222,
      231,   237,   240,   243,   246,   249,   253,   257,   261,   265,
      271,   274,   280,   283,   289,   290,   297,   306,   315,   325,
      335,   347,   348,   353,   359,   376,   380,   386,   395,   403,
      412,   421,   432,   433,   493,   559,   568,   577,   586,   597,
      598,   605,   608,   630,   634,   640,   652,   664,   669,   673,
      678,   683,   688,   692,   697,   700,   705,   721,   732,   744,
      755,   773,   774,   775,   776,   777,   778,   779,   780,   781,
-     782,   785,   791,   794,   798,   802,   811,   820,   832,   838,
-     844,   850,   858,   861,   864,   867,   870,   873,   876,   879,
-     882,   885,   888,   891,   894,   897,   900,   905,   913,   922,
-     941,   942,   945,   945,   957,   960,   961,   968,   969,   972,
-     972,   984,   987,   988,   995,   996,   999,   999,  1011,  1014,
-    1015,  1018,  1018,  1030,  1033,  1034,  1041,  1045,  1051,  1060,
-    1068,  1077,  1086,  1097,  1098,  1105,  1109,  1115,  1124,  1132
+     782,   785,   791,   794,   799,   804,   813,   822,   834,   841,
+     848,   855,   864,   867,   870,   873,   876,   879,   882,   885,
+     888,   891,   894,   897,   900,   903,   906,   911,   919,   928,
+     947,   948,   951,   951,   963,   966,   967,   974,   975,   978,
+     978,   990,   993,   994,  1001,  1002,  1005,  1005,  1017,  1020,
+    1021,  1024,  1024,  1036,  1039,  1040,  1047,  1051,  1057,  1066,
+    1074,  1083,  1092,  1103,  1104,  1111,  1115,  1121,  1130,  1138
 };
 #endif
 
 /** Accessing symbol of state STATE.  */
 #define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
 
 #if YYDEBUG || 0
 /* The user-facing name of the symbol whose (internal) number is
    YYSYMBOL.  No bounds checking.  */
@@ -1620,1517 +1620,1523 @@ yydefault:
 /*-----------------------------.
 | yyreduce -- do a reduction.  |
 `-----------------------------*/
 yyreduce:
   /* yyn is the number of a rule to reduce with.  */
   yylen = yyr2[yyn];
 
   /* If YYLEN is nonzero, implement the default value of the action:
      '$$ = $1'.
 
      Otherwise, the following line sets YYVAL to garbage.
      This behavior is undocumented and Bison
      users should not rely upon it.  Assigning to YYVAL
      unconditionally makes the parser a bit smaller, and it avoids a
      GCC warning that YYVAL may be used uninitialized.  */
   yyval = yyvsp[1-yylen];
 
 
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
   case 2: /* file: %empty  */
 #line 197 "gram.y"
                         {
 			    ; /* empty file */
 			}
 #line 1641 "gram.c"
     break;
 
   case 6: /* entry: '\n'  */
 #line 207 "gram.y"
                              {
 			    ; /* blank line */
 			}
 #line 1649 "gram.c"
     break;
 
   case 7: /* entry: error '\n'  */
 #line 210 "gram.y"
                                    {
 			    yyerrok;
 			}
 #line 1657 "gram.c"
     break;
 
   case 8: /* entry: include  */
 #line 213 "gram.y"
                                 {
 			    if (!push_include((yyvsp[0].string), false)) {
 				parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 				free((yyvsp[0].string));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    free((yyvsp[0].string));
 			}
 #line 1671 "gram.c"
     break;
 
   case 9: /* entry: includedir  */
 #line 222 "gram.y"
                                    {
 			    if (!push_include((yyvsp[0].string), true)) {
 				parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 				free((yyvsp[0].string));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    free((yyvsp[0].string));
 			}
 #line 1685 "gram.c"
     break;
 
   case 10: /* entry: userlist privileges '\n'  */
 #line 231 "gram.y"
                                                  {
 			    if (!add_userspec((yyvsp[-2].member), (yyvsp[-1].privilege))) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			}
 #line 1696 "gram.c"
     break;
 
   case 11: /* entry: USERALIAS useraliases '\n'  */
 #line 237 "gram.y"
                                                    {
 			    ;
 			}
 #line 1704 "gram.c"
     break;
 
   case 12: /* entry: HOSTALIAS hostaliases '\n'  */
 #line 240 "gram.y"
                                                    {
 			    ;
 			}
 #line 1712 "gram.c"
     break;
 
   case 13: /* entry: CMNDALIAS cmndaliases '\n'  */
 #line 243 "gram.y"
                                                    {
 			    ;
 			}
 #line 1720 "gram.c"
     break;
 
   case 14: /* entry: RUNASALIAS runasaliases '\n'  */
 #line 246 "gram.y"
                                                      {
 			    ;
 			}
 #line 1728 "gram.c"
     break;
 
   case 15: /* entry: DEFAULTS defaults_list '\n'  */
 #line 249 "gram.y"
                                                     {
 			    if (!add_defaults(DEFAULTS, NULL, (yyvsp[-1].defaults)))
 				YYERROR;
 			}
 #line 1737 "gram.c"
     break;
 
   case 16: /* entry: DEFAULTS_USER userlist defaults_list '\n'  */
 #line 253 "gram.y"
                                                                   {
 			    if (!add_defaults(DEFAULTS_USER, (yyvsp[-2].member), (yyvsp[-1].defaults)))
 				YYERROR;
 			}
 #line 1746 "gram.c"
     break;
 
   case 17: /* entry: DEFAULTS_RUNAS userlist defaults_list '\n'  */
 #line 257 "gram.y"
                                                                    {
 			    if (!add_defaults(DEFAULTS_RUNAS, (yyvsp[-2].member), (yyvsp[-1].defaults)))
 				YYERROR;
 			}
 #line 1755 "gram.c"
     break;
 
   case 18: /* entry: DEFAULTS_HOST hostlist defaults_list '\n'  */
 #line 261 "gram.y"
                                                                   {
 			    if (!add_defaults(DEFAULTS_HOST, (yyvsp[-2].member), (yyvsp[-1].defaults)))
 				YYERROR;
 			}
 #line 1764 "gram.c"
     break;
 
   case 19: /* entry: DEFAULTS_CMND cmndlist defaults_list '\n'  */
 #line 265 "gram.y"
                                                                   {
 			    if (!add_defaults(DEFAULTS_CMND, (yyvsp[-2].member), (yyvsp[-1].defaults)))
 				YYERROR;
 			}
 #line 1773 "gram.c"
     break;
 
   case 20: /* include: INCLUDE WORD '\n'  */
 #line 271 "gram.y"
                                           {
 			    (yyval.string) = (yyvsp[-1].string);
 			}
 #line 1781 "gram.c"
     break;
 
   case 21: /* include: INCLUDE WORD error '\n'  */
 #line 274 "gram.y"
                                                 {
 			    yyerrok;
 			    (yyval.string) = (yyvsp[-2].string);
 			}
 #line 1790 "gram.c"
     break;
 
   case 22: /* includedir: INCLUDEDIR WORD '\n'  */
 #line 280 "gram.y"
                                              {
 			    (yyval.string) = (yyvsp[-1].string);
 			}
 #line 1798 "gram.c"
     break;
 
   case 23: /* includedir: INCLUDEDIR WORD error '\n'  */
 #line 283 "gram.y"
                                                    {
 			    yyerrok;
 			    (yyval.string) = (yyvsp[-2].string);
 			}
 #line 1807 "gram.c"
     break;
 
   case 25: /* defaults_list: defaults_list ',' defaults_entry  */
 #line 290 "gram.y"
                                                          {
 			    parser_leak_remove(LEAK_DEFAULTS, (yyvsp[0].defaults));
 			    HLTQ_CONCAT((yyvsp[-2].defaults), (yyvsp[0].defaults), entries);
 			    (yyval.defaults) = (yyvsp[-2].defaults);
 			}
 #line 1817 "gram.c"
     break;
 
   case 26: /* defaults_entry: DEFVAR  */
 #line 297 "gram.y"
                                {
 			    (yyval.defaults) = new_default((yyvsp[0].string), NULL, true);
 			    if ((yyval.defaults) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_DEFAULTS, (yyval.defaults));
 			}
 #line 1831 "gram.c"
     break;
 
   case 27: /* defaults_entry: '!' DEFVAR  */
 #line 306 "gram.y"
                                    {
 			    (yyval.defaults) = new_default((yyvsp[0].string), NULL, false);
 			    if ((yyval.defaults) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_DEFAULTS, (yyval.defaults));
 			}
 #line 1845 "gram.c"
     break;
 
   case 28: /* defaults_entry: DEFVAR '=' WORD  */
 #line 315 "gram.y"
                                         {
 			    (yyval.defaults) = new_default((yyvsp[-2].string), (yyvsp[0].string), true);
 			    if ((yyval.defaults) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-2].string));
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_DEFAULTS, (yyval.defaults));
 			}
 #line 1860 "gram.c"
     break;
 
   case 29: /* defaults_entry: DEFVAR '+' WORD  */
 #line 325 "gram.y"
                                         {
 			    (yyval.defaults) = new_default((yyvsp[-2].string), (yyvsp[0].string), '+');
 			    if ((yyval.defaults) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-2].string));
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_DEFAULTS, (yyval.defaults));
 			}
 #line 1875 "gram.c"
     break;
 
   case 30: /* defaults_entry: DEFVAR '-' WORD  */
 #line 335 "gram.y"
                                         {
 			    (yyval.defaults) = new_default((yyvsp[-2].string), (yyvsp[0].string), '-');
 			    if ((yyval.defaults) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-2].string));
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_DEFAULTS, (yyval.defaults));
 			}
 #line 1890 "gram.c"
     break;
 
   case 32: /* privileges: privileges ':' privilege  */
 #line 348 "gram.y"
                                                  {
 			    parser_leak_remove(LEAK_PRIVILEGE, (yyvsp[0].privilege));
 			    HLTQ_CONCAT((yyvsp[-2].privilege), (yyvsp[0].privilege), entries);
 			    (yyval.privilege) = (yyvsp[-2].privilege);
 			}
 #line 1900 "gram.c"
     break;
 
   case 33: /* privileges: privileges ':' error  */
 #line 353 "gram.y"
                                              {
 			    yyerrok;
 			    (yyval.privilege) = (yyvsp[-2].privilege);
 			}
 #line 1909 "gram.c"
     break;
 
   case 34: /* privilege: hostlist '=' cmndspeclist  */
 #line 359 "gram.y"
                                                   {
 			    struct privilege *p = calloc(1, sizeof(*p));
 			    if (p == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_PRIVILEGE, p);
 			    TAILQ_INIT(&p->defaults);
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[-2].member));
 			    HLTQ_TO_TAILQ(&p->hostlist, (yyvsp[-2].member), entries);
 			    parser_leak_remove(LEAK_CMNDSPEC, (yyvsp[0].cmndspec));
 			    HLTQ_TO_TAILQ(&p->cmndlist, (yyvsp[0].cmndspec), entries);
 			    HLTQ_INIT(p, entries);
 			    (yyval.privilege) = p;
 			}
 #line 1929 "gram.c"
     break;
 
   case 35: /* ophost: host  */
 #line 376 "gram.y"
                              {
 			    (yyval.member) = (yyvsp[0].member);
 			    (yyval.member)->negated = false;
 			}
 #line 1938 "gram.c"
     break;
 
   case 36: /* ophost: '!' host  */
 #line 380 "gram.y"
                                  {
 			    (yyval.member) = (yyvsp[0].member);
 			    (yyval.member)->negated = true;
 			}
 #line 1947 "gram.c"
     break;
 
   case 37: /* host: ALIAS  */
 #line 386 "gram.y"
                               {
 			    (yyval.member) = new_member((yyvsp[0].string), ALIAS);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
 #line 1961 "gram.c"
     break;
 
   case 38: /* host: ALL  */
 #line 395 "gram.y"
                             {
 			    (yyval.member) = new_member(NULL, ALL);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
 #line 1974 "gram.c"
     break;
 
   case 39: /* host: NETGROUP  */
 #line 403 "gram.y"
                                  {
 			    (yyval.member) = new_member((yyvsp[0].string), NETGROUP);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
 #line 1988 "gram.c"
     break;
 
   case 40: /* host: NTWKADDR  */
 #line 412 "gram.y"
                                  {
 			    (yyval.member) = new_member((yyvsp[0].string), NTWKADDR);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
 #line 2002 "gram.c"
     break;
 
   case 41: /* host: WORD  */
 #line 421 "gram.y"
                              {
 			    (yyval.member) = new_member((yyvsp[0].string), WORD);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
 #line 2016 "gram.c"
     break;
 
   case 43: /* cmndspeclist: cmndspeclist ',' cmndspec  */
 #line 433 "gram.y"
                                                   {
 			    struct cmndspec *prev;
 			    prev = HLTQ_LAST((yyvsp[-2].cmndspec), cmndspec, entries);
 			    parser_leak_remove(LEAK_CMNDSPEC, (yyvsp[0].cmndspec));
 			    HLTQ_CONCAT((yyvsp[-2].cmndspec), (yyvsp[0].cmndspec), entries);
 
 			    /* propagate runcwd and runchroot */
 			    if ((yyvsp[0].cmndspec)->runcwd == NULL)
 				(yyvsp[0].cmndspec)->runcwd = prev->runcwd;
 			    if ((yyvsp[0].cmndspec)->runchroot == NULL)
 				(yyvsp[0].cmndspec)->runchroot = prev->runchroot;
 #ifdef HAVE_SELINUX
 			    /* propagate role and type */
 			    if ((yyvsp[0].cmndspec)->role == NULL && (yyvsp[0].cmndspec)->type == NULL) {
 				(yyvsp[0].cmndspec)->role = prev->role;
 				(yyvsp[0].cmndspec)->type = prev->type;
 			    }
 #endif /* HAVE_SELINUX */
 #ifdef HAVE_PRIV_SET
 			    /* propagate privs & limitprivs */
 			    if ((yyvsp[0].cmndspec)->privs == NULL && (yyvsp[0].cmndspec)->limitprivs == NULL) {
 			        (yyvsp[0].cmndspec)->privs = prev->privs;
 			        (yyvsp[0].cmndspec)->limitprivs = prev->limitprivs;
 			    }
 #endif /* HAVE_PRIV_SET */
 			    /* propagate command time restrictions */
 			    if ((yyvsp[0].cmndspec)->notbefore == UNSPEC)
 				(yyvsp[0].cmndspec)->notbefore = prev->notbefore;
 			    if ((yyvsp[0].cmndspec)->notafter == UNSPEC)
 				(yyvsp[0].cmndspec)->notafter = prev->notafter;
 			    /* propagate command timeout */
 			    if ((yyvsp[0].cmndspec)->timeout == UNSPEC)
 				(yyvsp[0].cmndspec)->timeout = prev->timeout;
 			    /* propagate tags and runas list */
 			    if ((yyvsp[0].cmndspec)->tags.nopasswd == UNSPEC)
 				(yyvsp[0].cmndspec)->tags.nopasswd = prev->tags.nopasswd;
 			    if ((yyvsp[0].cmndspec)->tags.noexec == UNSPEC)
 				(yyvsp[0].cmndspec)->tags.noexec = prev->tags.noexec;
 			    if ((yyvsp[0].cmndspec)->tags.setenv == UNSPEC &&
 				prev->tags.setenv != IMPLIED)
 				(yyvsp[0].cmndspec)->tags.setenv = prev->tags.setenv;
 			    if ((yyvsp[0].cmndspec)->tags.log_input == UNSPEC)
 				(yyvsp[0].cmndspec)->tags.log_input = prev->tags.log_input;
 			    if ((yyvsp[0].cmndspec)->tags.log_output == UNSPEC)
 				(yyvsp[0].cmndspec)->tags.log_output = prev->tags.log_output;
 			    if ((yyvsp[0].cmndspec)->tags.send_mail == UNSPEC)
 				(yyvsp[0].cmndspec)->tags.send_mail = prev->tags.send_mail;
 			    if ((yyvsp[0].cmndspec)->tags.follow == UNSPEC)
 				(yyvsp[0].cmndspec)->tags.follow = prev->tags.follow;
 			    if (((yyvsp[0].cmndspec)->runasuserlist == NULL &&
 				 (yyvsp[0].cmndspec)->runasgrouplist == NULL) &&
 				(prev->runasuserlist != NULL ||
 				 prev->runasgrouplist != NULL)) {
 				(yyvsp[0].cmndspec)->runasuserlist = prev->runasuserlist;
 				(yyvsp[0].cmndspec)->runasgrouplist = prev->runasgrouplist;
 			    }
 			    (yyval.cmndspec) = (yyvsp[-2].cmndspec);
 			}
 #line 2079 "gram.c"
     break;
 
   case 44: /* cmndspec: runasspec options cmndtag digcmnd  */
 #line 493 "gram.y"
                                                           {
 			    struct cmndspec *cs = calloc(1, sizeof(*cs));
 			    if (cs == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_CMNDSPEC, cs);
 			    if ((yyvsp[-3].runas) != NULL) {
 				if ((yyvsp[-3].runas)->runasusers != NULL) {
 				    cs->runasuserlist =
 					malloc(sizeof(*cs->runasuserlist));
 				    if (cs->runasuserlist == NULL) {
 					free(cs);
 					sudoerserror(N_("unable to allocate memory"));
 					YYERROR;
 				    }
 				    /* g/c done via runas container */
 				    HLTQ_TO_TAILQ(cs->runasuserlist,
 					(yyvsp[-3].runas)->runasusers, entries);
 				}
 				if ((yyvsp[-3].runas)->runasgroups != NULL) {
 				    cs->runasgrouplist =
 					malloc(sizeof(*cs->runasgrouplist));
 				    if (cs->runasgrouplist == NULL) {
 					free(cs);
 					sudoerserror(N_("unable to allocate memory"));
 					YYERROR;
 				    }
 				    /* g/c done via runas container */
 				    HLTQ_TO_TAILQ(cs->runasgrouplist,
 					(yyvsp[-3].runas)->runasgroups, entries);
 				}
 				parser_leak_remove(LEAK_RUNAS, (yyvsp[-3].runas));
 				free((yyvsp[-3].runas));
 			    }
 #ifdef HAVE_SELINUX
 			    cs->role = (yyvsp[-2].options).role;
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-2].options).role);
 			    cs->type = (yyvsp[-2].options).type;
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-2].options).type);
 #endif
 #ifdef HAVE_PRIV_SET
 			    cs->privs = (yyvsp[-2].options).privs;
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-2].options).privs);
 			    cs->limitprivs = (yyvsp[-2].options).limitprivs;
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-2].options).limitprivs);
 #endif
 			    cs->notbefore = (yyvsp[-2].options).notbefore;
 			    cs->notafter = (yyvsp[-2].options).notafter;
 			    cs->timeout = (yyvsp[-2].options).timeout;
 			    cs->runcwd = (yyvsp[-2].options).runcwd;
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-2].options).runcwd);
 			    cs->runchroot = (yyvsp[-2].options).runchroot;
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-2].options).runchroot);
 			    cs->tags = (yyvsp[-1].tag);
 			    cs->cmnd = (yyvsp[0].member);
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    HLTQ_INIT(cs, entries);
 			    /* sudo "ALL" implies the SETENV tag */
 			    if (cs->cmnd->type == ALL && !cs->cmnd->negated &&
 				cs->tags.setenv == UNSPEC)
 				cs->tags.setenv = IMPLIED;
 			    (yyval.cmndspec) = cs;
 			}
 #line 2148 "gram.c"
     break;
 
   case 45: /* digestspec: SHA224_TOK ':' DIGEST  */
 #line 559 "gram.y"
                                               {
 			    (yyval.digest) = new_digest(SUDO_DIGEST_SHA224, (yyvsp[0].string));
 			    if ((yyval.digest) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_DIGEST, (yyval.digest));
 			}
 #line 2162 "gram.c"
     break;
 
   case 46: /* digestspec: SHA256_TOK ':' DIGEST  */
 #line 568 "gram.y"
                                               {
 			    (yyval.digest) = new_digest(SUDO_DIGEST_SHA256, (yyvsp[0].string));
 			    if ((yyval.digest) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_DIGEST, (yyval.digest));
 			}
 #line 2176 "gram.c"
     break;
 
   case 47: /* digestspec: SHA384_TOK ':' DIGEST  */
 #line 577 "gram.y"
                                               {
 			    (yyval.digest) = new_digest(SUDO_DIGEST_SHA384, (yyvsp[0].string));
 			    if ((yyval.digest) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_DIGEST, (yyval.digest));
 			}
 #line 2190 "gram.c"
     break;
 
   case 48: /* digestspec: SHA512_TOK ':' DIGEST  */
 #line 586 "gram.y"
                                               {
 			    (yyval.digest) = new_digest(SUDO_DIGEST_SHA512, (yyvsp[0].string));
 			    if ((yyval.digest) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_DIGEST, (yyval.digest));
 			}
 #line 2204 "gram.c"
     break;
 
   case 50: /* digestlist: digestlist ',' digestspec  */
 #line 598 "gram.y"
                                                   {
 			    parser_leak_remove(LEAK_DIGEST, (yyvsp[0].digest));
 			    HLTQ_CONCAT((yyvsp[-2].digest), (yyvsp[0].digest), entries);
 			    (yyval.digest) = (yyvsp[-2].digest);
 			}
 #line 2214 "gram.c"
     break;
 
   case 51: /* digcmnd: opcmnd  */
 #line 605 "gram.y"
                                {
 			    (yyval.member) = (yyvsp[0].member);
 			}
 #line 2222 "gram.c"
     break;
 
   case 52: /* digcmnd: digestlist opcmnd  */
 #line 608 "gram.y"
                                           {
 			    struct sudo_command *c =
 				(struct sudo_command *) (yyvsp[0].member)->name;
 
 			    if ((yyvsp[0].member)->type != COMMAND && (yyvsp[0].member)->type != ALL) {
 				sudoerserror(N_("a digest requires a path name"));
 				YYERROR;
 			    }
 			    if (c == NULL) {
 				/* lazy-allocate sudo_command for ALL */
 				if ((c = new_command(NULL, NULL)) == NULL) {
 				    sudoerserror(N_("unable to allocate memory"));
 				    YYERROR;
 				}
 				(yyvsp[0].member)->name = (char *)c;
 			    }
 			    parser_leak_remove(LEAK_DIGEST, (yyvsp[-1].digest));
 			    HLTQ_TO_TAILQ(&c->digests, (yyvsp[-1].digest), entries);
 			    (yyval.member) = (yyvsp[0].member);
 			}
 #line 2247 "gram.c"
     break;
 
   case 53: /* opcmnd: cmnd  */
 #line 630 "gram.y"
                              {
 			    (yyval.member) = (yyvsp[0].member);
 			    (yyval.member)->negated = false;
 			}
 #line 2256 "gram.c"
     break;
 
   case 54: /* opcmnd: '!' cmnd  */
 #line 634 "gram.y"
                                  {
 			    (yyval.member) = (yyvsp[0].member);
 			    (yyval.member)->negated = true;
 			}
 #line 2265 "gram.c"
     break;
 
   case 55: /* chdirspec: CWD '=' WORD  */
 #line 640 "gram.y"
                                      {
 			    if ((yyvsp[0].string)[0] != '/' && (yyvsp[0].string)[0] != '~') {
 				if (strcmp((yyvsp[0].string), "*") != 0) {
 				    sudoerserror(N_("values for \"CWD\" must"
 					" start with a '/', '~', or '*'"));
 				    YYERROR;
 				}
 			    }
 			    (yyval.string) = (yyvsp[0].string);
 			}
 #line 2280 "gram.c"
     break;
 
   case 56: /* chrootspec: CHROOT '=' WORD  */
 #line 652 "gram.y"
                                         {
 			    if ((yyvsp[0].string)[0] != '/' && (yyvsp[0].string)[0] != '~') {
 				if (strcmp((yyvsp[0].string), "*") != 0) {
 				    sudoerserror(N_("values for \"CHROOT\" must"
 					" start with a '/', '~', or '*'"));
 				    YYERROR;
 				}
 			    }
 			    (yyval.string) = (yyvsp[0].string);
 			}
 #line 2295 "gram.c"
     break;
 
   case 57: /* timeoutspec: CMND_TIMEOUT '=' WORD  */
 #line 664 "gram.y"
                                               {
 			    (yyval.string) = (yyvsp[0].string);
 			}
 #line 2303 "gram.c"
     break;
 
   case 58: /* notbeforespec: NOTBEFORE '=' WORD  */
 #line 669 "gram.y"
                                            {
 			    (yyval.string) = (yyvsp[0].string);
 			}
 #line 2311 "gram.c"
     break;
 
   case 59: /* notafterspec: NOTAFTER '=' WORD  */
 #line 673 "gram.y"
                                           {
 			    (yyval.string) = (yyvsp[0].string);
 			}
 #line 2319 "gram.c"
     break;
 
   case 60: /* rolespec: ROLE '=' WORD  */
 #line 678 "gram.y"
                                       {
 			    (yyval.string) = (yyvsp[0].string);
 			}
 #line 2327 "gram.c"
     break;
 
   case 61: /* typespec: TYPE '=' WORD  */
 #line 683 "gram.y"
                                       {
 			    (yyval.string) = (yyvsp[0].string);
 			}
 #line 2335 "gram.c"
     break;
 
   case 62: /* privsspec: PRIVS '=' WORD  */
 #line 688 "gram.y"
                                        {
 			    (yyval.string) = (yyvsp[0].string);
 			}
 #line 2343 "gram.c"
     break;
 
   case 63: /* limitprivsspec: LIMITPRIVS '=' WORD  */
 #line 692 "gram.y"
                                             {
 			    (yyval.string) = (yyvsp[0].string);
 			}
 #line 2351 "gram.c"
     break;
 
   case 64: /* runasspec: %empty  */
 #line 697 "gram.y"
                                     {
 			    (yyval.runas) = NULL;
 			}
 #line 2359 "gram.c"
     break;
 
   case 65: /* runasspec: '(' runaslist ')'  */
 #line 700 "gram.y"
                                           {
 			    (yyval.runas) = (yyvsp[-1].runas);
 			}
 #line 2367 "gram.c"
     break;
 
   case 66: /* runaslist: %empty  */
 #line 705 "gram.y"
                                     {
 			    (yyval.runas) = calloc(1, sizeof(struct runascontainer));
 			    if ((yyval.runas) != NULL) {
 				(yyval.runas)->runasusers = new_member(NULL, MYSELF);
 				/* $$->runasgroups = NULL; */
 				if ((yyval.runas)->runasusers == NULL) {
 				    free((yyval.runas));
 				    (yyval.runas) = NULL;
 				}
 			    }
 			    if ((yyval.runas) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_RUNAS, (yyval.runas));
 			}
 #line 2388 "gram.c"
     break;
 
   case 67: /* runaslist: userlist  */
 #line 721 "gram.y"
                                  {
 			    (yyval.runas) = calloc(1, sizeof(struct runascontainer));
 			    if ((yyval.runas) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_RUNAS, (yyval.runas));
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    (yyval.runas)->runasusers = (yyvsp[0].member);
 			    /* $$->runasgroups = NULL; */
 			}
 #line 2404 "gram.c"
     break;
 
   case 68: /* runaslist: userlist ':' grouplist  */
 #line 732 "gram.y"
                                                {
 			    (yyval.runas) = calloc(1, sizeof(struct runascontainer));
 			    if ((yyval.runas) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_RUNAS, (yyval.runas));
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[-2].member));
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    (yyval.runas)->runasusers = (yyvsp[-2].member);
 			    (yyval.runas)->runasgroups = (yyvsp[0].member);
 			}
 #line 2421 "gram.c"
     break;
 
   case 69: /* runaslist: ':' grouplist  */
 #line 744 "gram.y"
                                       {
 			    (yyval.runas) = calloc(1, sizeof(struct runascontainer));
 			    if ((yyval.runas) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_RUNAS, (yyval.runas));
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    /* $$->runasusers = NULL; */
 			    (yyval.runas)->runasgroups = (yyvsp[0].member);
 			}
 #line 2437 "gram.c"
     break;
 
   case 70: /* runaslist: ':'  */
 #line 755 "gram.y"
                             {
 			    (yyval.runas) = calloc(1, sizeof(struct runascontainer));
 			    if ((yyval.runas) != NULL) {
 				(yyval.runas)->runasusers = new_member(NULL, MYSELF);
 				/* $$->runasgroups = NULL; */
 				if ((yyval.runas)->runasusers == NULL) {
 				    free((yyval.runas));
 				    (yyval.runas) = NULL;
 				}
 			    }
 			    if ((yyval.runas) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_RUNAS, (yyval.runas));
 			}
 #line 2458 "gram.c"
     break;
 
   case 71: /* reserved_word: ALL  */
 #line 773 "gram.y"
                                         { (yyval.string) = "ALL"; }
 #line 2464 "gram.c"
     break;
 
   case 72: /* reserved_word: CHROOT  */
 #line 774 "gram.y"
                                         { (yyval.string) = "CHROOT"; }
 #line 2470 "gram.c"
     break;
 
   case 73: /* reserved_word: CWD  */
 #line 775 "gram.y"
                                         { (yyval.string) = "CWD"; }
 #line 2476 "gram.c"
     break;
 
   case 74: /* reserved_word: CMND_TIMEOUT  */
 #line 776 "gram.y"
                                         { (yyval.string) = "CMND_TIMEOUT"; }
 #line 2482 "gram.c"
     break;
 
   case 75: /* reserved_word: NOTBEFORE  */
 #line 777 "gram.y"
                                         { (yyval.string) = "NOTBEFORE"; }
 #line 2488 "gram.c"
     break;
 
   case 76: /* reserved_word: NOTAFTER  */
 #line 778 "gram.y"
                                         { (yyval.string) = "NOTAFTER"; }
 #line 2494 "gram.c"
     break;
 
   case 77: /* reserved_word: ROLE  */
 #line 779 "gram.y"
                                         { (yyval.string) = "ROLE"; }
 #line 2500 "gram.c"
     break;
 
   case 78: /* reserved_word: TYPE  */
 #line 780 "gram.y"
                                         { (yyval.string) = "TYPE"; }
 #line 2506 "gram.c"
     break;
 
   case 79: /* reserved_word: PRIVS  */
 #line 781 "gram.y"
                                         { (yyval.string) = "PRIVS"; }
 #line 2512 "gram.c"
     break;
 
   case 80: /* reserved_word: LIMITPRIVS  */
 #line 782 "gram.y"
                                         { (yyval.string) = "LIMITPRIVS"; }
 #line 2518 "gram.c"
     break;
 
   case 81: /* reserved_alias: reserved_word  */
 #line 785 "gram.y"
                                       {
 			    sudoerserrorf(U_("syntax error, reserved word %s used as an alias name"), (yyvsp[0].string));
 			    YYERROR;
 			}
 #line 2527 "gram.c"
     break;
 
   case 82: /* options: %empty  */
 #line 791 "gram.y"
                                     {
 			    init_options(&(yyval.options));
 			}
 #line 2535 "gram.c"
     break;
 
   case 83: /* options: options chdirspec  */
 #line 794 "gram.y"
                                           {
+			    parser_leak_remove(LEAK_PTR, (yyval.options).runcwd);
 			    free((yyval.options).runcwd);
 			    (yyval.options).runcwd = (yyvsp[0].string);
 			}
-#line 2544 "gram.c"
+#line 2545 "gram.c"
     break;
 
   case 84: /* options: options chrootspec  */
-#line 798 "gram.y"
+#line 799 "gram.y"
                                            {
+			    parser_leak_remove(LEAK_PTR, (yyval.options).runchroot);
 			    free((yyval.options).runchroot);
 			    (yyval.options).runchroot = (yyvsp[0].string);
 			}
-#line 2553 "gram.c"
+#line 2555 "gram.c"
     break;
 
   case 85: /* options: options notbeforespec  */
-#line 802 "gram.y"
+#line 804 "gram.y"
                                               {
 			    (yyval.options).notbefore = parse_gentime((yyvsp[0].string));
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    free((yyvsp[0].string));
 			    if ((yyval.options).notbefore == -1) {
 				sudoerserror(N_("invalid notbefore value"));
 				YYERROR;
 			    }
 			}
-#line 2567 "gram.c"
+#line 2569 "gram.c"
     break;
 
   case 86: /* options: options notafterspec  */
-#line 811 "gram.y"
+#line 813 "gram.y"
                                              {
 			    (yyval.options).notafter = parse_gentime((yyvsp[0].string));
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    free((yyvsp[0].string));
 			    if ((yyval.options).notafter == -1) {
 				sudoerserror(N_("invalid notafter value"));
 				YYERROR;
 			    }
 			}
-#line 2581 "gram.c"
+#line 2583 "gram.c"
     break;
 
   case 87: /* options: options timeoutspec  */
-#line 820 "gram.y"
+#line 822 "gram.y"
                                             {
 			    (yyval.options).timeout = parse_timeout((yyvsp[0].string));
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    free((yyvsp[0].string));
 			    if ((yyval.options).timeout == -1) {
 				if (errno == ERANGE)
 				    sudoerserror(N_("timeout value too large"));
 				else
 				    sudoerserror(N_("invalid timeout value"));
 				YYERROR;
 			    }
 			}
-#line 2598 "gram.c"
+#line 2600 "gram.c"
     break;
 
   case 88: /* options: options rolespec  */
-#line 832 "gram.y"
+#line 834 "gram.y"
                                          {
 #ifdef HAVE_SELINUX
+			    parser_leak_remove(LEAK_PTR, (yyval.options).role);
 			    free((yyval.options).role);
 			    (yyval.options).role = (yyvsp[0].string);
 #endif
 			}
-#line 2609 "gram.c"
+#line 2612 "gram.c"
     break;
 
   case 89: /* options: options typespec  */
-#line 838 "gram.y"
+#line 841 "gram.y"
                                          {
 #ifdef HAVE_SELINUX
+			    parser_leak_remove(LEAK_PTR, (yyval.options).type);
 			    free((yyval.options).type);
 			    (yyval.options).type = (yyvsp[0].string);
 #endif
 			}
-#line 2620 "gram.c"
+#line 2624 "gram.c"
     break;
 
   case 90: /* options: options privsspec  */
-#line 844 "gram.y"
+#line 848 "gram.y"
                                           {
 #ifdef HAVE_PRIV_SET
+			    parser_leak_remove(LEAK_PTR, (yyval.options).privs);
 			    free((yyval.options).privs);
 			    (yyval.options).privs = (yyvsp[0].string);
 #endif
 			}
-#line 2631 "gram.c"
+#line 2636 "gram.c"
     break;
 
   case 91: /* options: options limitprivsspec  */
-#line 850 "gram.y"
+#line 855 "gram.y"
                                                {
 #ifdef HAVE_PRIV_SET
+			    parser_leak_remove(LEAK_PTR, (yyval.options).limitprivs);
 			    free((yyval.options).limitprivs);
 			    (yyval.options).limitprivs = (yyvsp[0].string);
 #endif
 			}
-#line 2642 "gram.c"
+#line 2648 "gram.c"
     break;
 
   case 92: /* cmndtag: %empty  */
-#line 858 "gram.y"
+#line 864 "gram.y"
                                     {
 			    TAGS_INIT(&(yyval.tag));
 			}
-#line 2650 "gram.c"
+#line 2656 "gram.c"
     break;
 
   case 93: /* cmndtag: cmndtag NOPASSWD  */
-#line 861 "gram.y"
+#line 867 "gram.y"
                                          {
 			    (yyval.tag).nopasswd = true;
 			}
-#line 2658 "gram.c"
+#line 2664 "gram.c"
     break;
 
   case 94: /* cmndtag: cmndtag PASSWD  */
-#line 864 "gram.y"
+#line 870 "gram.y"
                                        {
 			    (yyval.tag).nopasswd = false;
 			}
-#line 2666 "gram.c"
+#line 2672 "gram.c"
     break;
 
   case 95: /* cmndtag: cmndtag NOEXEC  */
-#line 867 "gram.y"
+#line 873 "gram.y"
                                        {
 			    (yyval.tag).noexec = true;
 			}
-#line 2674 "gram.c"
+#line 2680 "gram.c"
     break;
 
   case 96: /* cmndtag: cmndtag EXEC  */
-#line 870 "gram.y"
+#line 876 "gram.y"
                                      {
 			    (yyval.tag).noexec = false;
 			}
-#line 2682 "gram.c"
+#line 2688 "gram.c"
     break;
 
   case 97: /* cmndtag: cmndtag SETENV  */
-#line 873 "gram.y"
+#line 879 "gram.y"
                                        {
 			    (yyval.tag).setenv = true;
 			}
-#line 2690 "gram.c"
+#line 2696 "gram.c"
     break;
 
   case 98: /* cmndtag: cmndtag NOSETENV  */
-#line 876 "gram.y"
+#line 882 "gram.y"
                                          {
 			    (yyval.tag).setenv = false;
 			}
-#line 2698 "gram.c"
+#line 2704 "gram.c"
     break;
 
   case 99: /* cmndtag: cmndtag LOG_INPUT  */
-#line 879 "gram.y"
+#line 885 "gram.y"
                                           {
 			    (yyval.tag).log_input = true;
 			}
-#line 2706 "gram.c"
+#line 2712 "gram.c"
     break;
 
   case 100: /* cmndtag: cmndtag NOLOG_INPUT  */
-#line 882 "gram.y"
+#line 888 "gram.y"
                                             {
 			    (yyval.tag).log_input = false;
 			}
-#line 2714 "gram.c"
+#line 2720 "gram.c"
     break;
 
   case 101: /* cmndtag: cmndtag LOG_OUTPUT  */
-#line 885 "gram.y"
+#line 891 "gram.y"
                                            {
 			    (yyval.tag).log_output = true;
 			}
-#line 2722 "gram.c"
+#line 2728 "gram.c"
     break;
 
   case 102: /* cmndtag: cmndtag NOLOG_OUTPUT  */
-#line 888 "gram.y"
+#line 894 "gram.y"
                                              {
 			    (yyval.tag).log_output = false;
 			}
-#line 2730 "gram.c"
+#line 2736 "gram.c"
     break;
 
   case 103: /* cmndtag: cmndtag FOLLOWLNK  */
-#line 891 "gram.y"
+#line 897 "gram.y"
                                           {
 			    (yyval.tag).follow = true;
 			}
-#line 2738 "gram.c"
+#line 2744 "gram.c"
     break;
 
   case 104: /* cmndtag: cmndtag NOFOLLOWLNK  */
-#line 894 "gram.y"
+#line 900 "gram.y"
                                             {
 			    (yyval.tag).follow = false;
 			}
-#line 2746 "gram.c"
+#line 2752 "gram.c"
     break;
 
   case 105: /* cmndtag: cmndtag MAIL  */
-#line 897 "gram.y"
+#line 903 "gram.y"
                                      {
 			    (yyval.tag).send_mail = true;
 			}
-#line 2754 "gram.c"
+#line 2760 "gram.c"
     break;
 
   case 106: /* cmndtag: cmndtag NOMAIL  */
-#line 900 "gram.y"
+#line 906 "gram.y"
                                        {
 			    (yyval.tag).send_mail = false;
 			}
-#line 2762 "gram.c"
+#line 2768 "gram.c"
     break;
 
   case 107: /* cmnd: ALL  */
-#line 905 "gram.y"
+#line 911 "gram.y"
                             {
 			    (yyval.member) = new_member(NULL, ALL);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 2775 "gram.c"
+#line 2781 "gram.c"
     break;
 
   case 108: /* cmnd: ALIAS  */
-#line 913 "gram.y"
+#line 919 "gram.y"
                               {
 			    (yyval.member) = new_member((yyvsp[0].string), ALIAS);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 2789 "gram.c"
+#line 2795 "gram.c"
     break;
 
   case 109: /* cmnd: COMMAND  */
-#line 922 "gram.y"
+#line 928 "gram.y"
                                 {
 			    struct sudo_command *c;
 
 			    if ((c = new_command((yyvsp[0].command).cmnd, (yyvsp[0].command).args)) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    (yyval.member) = new_member((char *)c, COMMAND);
 			    if ((yyval.member) == NULL) {
 				free(c);
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].command).cmnd);
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].command).args);
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 2811 "gram.c"
+#line 2817 "gram.c"
     break;
 
   case 112: /* $@1: %empty  */
-#line 945 "gram.y"
+#line 951 "gram.y"
                               {
 			    alias_line = this_lineno;
 			    alias_column = sudolinebuf.toke_start + 1;
 			}
-#line 2820 "gram.c"
+#line 2826 "gram.c"
     break;
 
   case 113: /* hostalias: ALIAS $@1 '=' hostlist  */
-#line 948 "gram.y"
+#line 954 "gram.y"
                                        {
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-3].string));
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    if (!alias_add(&parsed_policy, (yyvsp[-3].string), HOSTALIAS,
 				sudoers, alias_line, alias_column, (yyvsp[0].member))) {
 				alias_error((yyvsp[-3].string), errno);
 				YYERROR;
 			    }
 			}
-#line 2834 "gram.c"
+#line 2840 "gram.c"
     break;
 
   case 116: /* hostlist: hostlist ',' ophost  */
-#line 961 "gram.y"
+#line 967 "gram.y"
                                             {
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    HLTQ_CONCAT((yyvsp[-2].member), (yyvsp[0].member), entries);
 			    (yyval.member) = (yyvsp[-2].member);
 			}
-#line 2844 "gram.c"
+#line 2850 "gram.c"
     break;
 
   case 119: /* $@2: %empty  */
-#line 972 "gram.y"
+#line 978 "gram.y"
                               {
 			    alias_line = this_lineno;
 			    alias_column = sudolinebuf.toke_start + 1;
 			}
-#line 2853 "gram.c"
+#line 2859 "gram.c"
     break;
 
   case 120: /* cmndalias: ALIAS $@2 '=' cmndlist  */
-#line 975 "gram.y"
+#line 981 "gram.y"
                                        {
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-3].string));
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    if (!alias_add(&parsed_policy, (yyvsp[-3].string), CMNDALIAS,
 				sudoers, alias_line, alias_column, (yyvsp[0].member))) {
 				alias_error((yyvsp[-3].string), errno);
 				YYERROR;
 			    }
 			}
-#line 2867 "gram.c"
+#line 2873 "gram.c"
     break;
 
   case 123: /* cmndlist: cmndlist ',' digcmnd  */
-#line 988 "gram.y"
+#line 994 "gram.y"
                                              {
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    HLTQ_CONCAT((yyvsp[-2].member), (yyvsp[0].member), entries);
 			    (yyval.member) = (yyvsp[-2].member);
 			}
-#line 2877 "gram.c"
+#line 2883 "gram.c"
     break;
 
   case 126: /* $@3: %empty  */
-#line 999 "gram.y"
+#line 1005 "gram.y"
                               {
 			    alias_line = this_lineno;
 			    alias_column = sudolinebuf.toke_start + 1;
 			}
-#line 2886 "gram.c"
+#line 2892 "gram.c"
     break;
 
   case 127: /* runasalias: ALIAS $@3 '=' userlist  */
-#line 1002 "gram.y"
+#line 1008 "gram.y"
                                        {
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-3].string));
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    if (!alias_add(&parsed_policy, (yyvsp[-3].string), RUNASALIAS,
 				sudoers, alias_line, alias_column, (yyvsp[0].member))) {
 				alias_error((yyvsp[-3].string), errno);
 				YYERROR;
 			    }
 			}
-#line 2900 "gram.c"
+#line 2906 "gram.c"
     break;
 
   case 131: /* $@4: %empty  */
-#line 1018 "gram.y"
+#line 1024 "gram.y"
                               {
 			    alias_line = this_lineno;
 			    alias_column = sudolinebuf.toke_start + 1;
 			}
-#line 2909 "gram.c"
+#line 2915 "gram.c"
     break;
 
   case 132: /* useralias: ALIAS $@4 '=' userlist  */
-#line 1021 "gram.y"
+#line 1027 "gram.y"
                                        {
 			    parser_leak_remove(LEAK_PTR, (yyvsp[-3].string));
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    if (!alias_add(&parsed_policy, (yyvsp[-3].string), USERALIAS,
 				sudoers, alias_line, alias_column, (yyvsp[0].member))) {
 				alias_error((yyvsp[-3].string), errno);
 				YYERROR;
 			    }
 			}
-#line 2923 "gram.c"
+#line 2929 "gram.c"
     break;
 
   case 135: /* userlist: userlist ',' opuser  */
-#line 1034 "gram.y"
+#line 1040 "gram.y"
                                             {
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    HLTQ_CONCAT((yyvsp[-2].member), (yyvsp[0].member), entries);
 			    (yyval.member) = (yyvsp[-2].member);
 			}
-#line 2933 "gram.c"
+#line 2939 "gram.c"
     break;
 
   case 136: /* opuser: user  */
-#line 1041 "gram.y"
+#line 1047 "gram.y"
                              {
 			    (yyval.member) = (yyvsp[0].member);
 			    (yyval.member)->negated = false;
 			}
-#line 2942 "gram.c"
+#line 2948 "gram.c"
     break;
 
   case 137: /* opuser: '!' user  */
-#line 1045 "gram.y"
+#line 1051 "gram.y"
                                  {
 			    (yyval.member) = (yyvsp[0].member);
 			    (yyval.member)->negated = true;
 			}
-#line 2951 "gram.c"
+#line 2957 "gram.c"
     break;
 
   case 138: /* user: ALIAS  */
-#line 1051 "gram.y"
+#line 1057 "gram.y"
                               {
 			    (yyval.member) = new_member((yyvsp[0].string), ALIAS);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 2965 "gram.c"
+#line 2971 "gram.c"
     break;
 
   case 139: /* user: ALL  */
-#line 1060 "gram.y"
+#line 1066 "gram.y"
                             {
 			    (yyval.member) = new_member(NULL, ALL);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 2978 "gram.c"
+#line 2984 "gram.c"
     break;
 
   case 140: /* user: NETGROUP  */
-#line 1068 "gram.y"
+#line 1074 "gram.y"
                                  {
 			    (yyval.member) = new_member((yyvsp[0].string), NETGROUP);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 2992 "gram.c"
+#line 2998 "gram.c"
     break;
 
   case 141: /* user: USERGROUP  */
-#line 1077 "gram.y"
+#line 1083 "gram.y"
                                   {
 			    (yyval.member) = new_member((yyvsp[0].string), USERGROUP);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 3006 "gram.c"
+#line 3012 "gram.c"
     break;
 
   case 142: /* user: WORD  */
-#line 1086 "gram.y"
+#line 1092 "gram.y"
                              {
 			    (yyval.member) = new_member((yyvsp[0].string), WORD);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 3020 "gram.c"
+#line 3026 "gram.c"
     break;
 
   case 144: /* grouplist: grouplist ',' opgroup  */
-#line 1098 "gram.y"
+#line 1104 "gram.y"
                                               {
 			    parser_leak_remove(LEAK_MEMBER, (yyvsp[0].member));
 			    HLTQ_CONCAT((yyvsp[-2].member), (yyvsp[0].member), entries);
 			    (yyval.member) = (yyvsp[-2].member);
 			}
-#line 3030 "gram.c"
+#line 3036 "gram.c"
     break;
 
   case 145: /* opgroup: group  */
-#line 1105 "gram.y"
+#line 1111 "gram.y"
                               {
 			    (yyval.member) = (yyvsp[0].member);
 			    (yyval.member)->negated = false;
 			}
-#line 3039 "gram.c"
+#line 3045 "gram.c"
     break;
 
   case 146: /* opgroup: '!' group  */
-#line 1109 "gram.y"
+#line 1115 "gram.y"
                                   {
 			    (yyval.member) = (yyvsp[0].member);
 			    (yyval.member)->negated = true;
 			}
-#line 3048 "gram.c"
+#line 3054 "gram.c"
     break;
 
   case 147: /* group: ALIAS  */
-#line 1115 "gram.y"
+#line 1121 "gram.y"
                               {
 			    (yyval.member) = new_member((yyvsp[0].string), ALIAS);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 3062 "gram.c"
+#line 3068 "gram.c"
     break;
 
   case 148: /* group: ALL  */
-#line 1124 "gram.y"
+#line 1130 "gram.y"
                             {
 			    (yyval.member) = new_member(NULL, ALL);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 3075 "gram.c"
+#line 3081 "gram.c"
     break;
 
   case 149: /* group: WORD  */
-#line 1132 "gram.y"
+#line 1138 "gram.y"
                              {
 			    (yyval.member) = new_member((yyvsp[0].string), WORD);
 			    if ((yyval.member) == NULL) {
 				sudoerserror(N_("unable to allocate memory"));
 				YYERROR;
 			    }
 			    parser_leak_remove(LEAK_PTR, (yyvsp[0].string));
 			    parser_leak_add(LEAK_MEMBER, (yyval.member));
 			}
-#line 3089 "gram.c"
+#line 3095 "gram.c"
     break;
 
 
-#line 3093 "gram.c"
+#line 3099 "gram.c"
 
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
      that yytoken be updated with the new translation.  We take the
      approach of translating immediately before every use of yytoken.
      One alternative is translating here after every semantic action,
      but that translation would be missed if the semantic action invokes
      YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
      if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
      incorrect destructor might then be invoked immediately.  In the
      case of YYERROR or YYBACKUP, subsequent parser actions might lead
      to an incorrect destructor call or verbose syntax error message
      before the lookahead is translated.  */
   YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
   yylen = 0;
 
   *++yyvsp = yyval;
 
   /* Now 'shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
   {
     const int yylhs = yyr1[yyn] - YYNTOKENS;
     const int yyi = yypgoto[yylhs] + *yyssp;
     yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
                ? yytable[yyi]
                : yydefgoto[yylhs]);
   }
 
   goto yynewstate;
 
 
 /*--------------------------------------.
 | yyerrlab -- here on detecting error.  |
 `--------------------------------------*/
@@ -3262,34 +3268,34 @@ yyexhaustedlab:
 /*-------------------------------------------------------.
 | yyreturn -- parsing is finished, clean up and return.  |
 `-------------------------------------------------------*/
 yyreturn:
   if (yychar != YYEMPTY)
     {
       /* Make sure we have latest lookahead translation.  See comments at
          user semantic actions for why this is necessary.  */
       yytoken = YYTRANSLATE (yychar);
       yydestruct ("Cleanup: discarding lookahead",
                   yytoken, &yylval);
     }
   /* Do not reclaim the symbols of the rule whose action triggered
      this YYABORT or YYACCEPT.  */
   YYPOPSTACK (yylen);
   YY_STACK_PRINT (yyss, yyssp);
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
                   YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
 
   return yyresult;
 }
 
-#line 1142 "gram.y"
+#line 1148 "gram.y"
 
 /* Like yyerror() but takes a printf-style format string. */
 void
diff --git a/plugins/sudoers/gram.y b/plugins/sudoers/gram.y
index 17e1457e4..e7faf29b0 100644
--- a/plugins/sudoers/gram.y
+++ b/plugins/sudoers/gram.y
@@ -791,66 +791,72 @@ reserved_alias	:	reserved_word {
 options		:	/* empty */ {
 			    init_options(&$$);
 			}
 		|	options chdirspec {
+			    parser_leak_remove(LEAK_PTR, $$.runcwd);
 			    free($$.runcwd);
 			    $$.runcwd = $2;
 			}
 		|	options chrootspec {
+			    parser_leak_remove(LEAK_PTR, $$.runchroot);
 			    free($$.runchroot);
 			    $$.runchroot = $2;
 			}
 		|	options notbeforespec {
 			    $$.notbefore = parse_gentime($2);
 			    parser_leak_remove(LEAK_PTR, $2);
 			    free($2);
 			    if ($$.notbefore == -1) {
 				sudoerserror(N_("invalid notbefore value"));
 				YYERROR;
 			    }
 			}
 		|	options notafterspec {
 			    $$.notafter = parse_gentime($2);
 			    parser_leak_remove(LEAK_PTR, $2);
 			    free($2);
 			    if ($$.notafter == -1) {
 				sudoerserror(N_("invalid notafter value"));
 				YYERROR;
 			    }
 			}
 		|	options timeoutspec {
 			    $$.timeout = parse_timeout($2);
 			    parser_leak_remove(LEAK_PTR, $2);
 			    free($2);
 			    if ($$.timeout == -1) {
 				if (errno == ERANGE)
 				    sudoerserror(N_("timeout value too large"));
 				else
 				    sudoerserror(N_("invalid timeout value"));
 				YYERROR;
 			    }
 			}
 		|	options rolespec {
 #ifdef HAVE_SELINUX
+			    parser_leak_remove(LEAK_PTR, $$.role);
 			    free($$.role);
 			    $$.role = $2;
 #endif
 			}
 		|	options typespec {
 #ifdef HAVE_SELINUX
+			    parser_leak_remove(LEAK_PTR, $$.type);
 			    free($$.type);
 			    $$.type = $2;
 #endif
 			}
 		|	options privsspec {
 #ifdef HAVE_PRIV_SET
+			    parser_leak_remove(LEAK_PTR, $$.privs);
 			    free($$.privs);
 			    $$.privs = $2;
 #endif
 			}
 		|	options limitprivsspec {
 #ifdef HAVE_PRIV_SET
+			    parser_leak_remove(LEAK_PTR, $$.limitprivs);
 			    free($$.limitprivs);
 			    $$.limitprivs = $2;
 #endif
 			}
 		;
