commit f522359c08d49e0f1a059ad6cc8566ddeb7a37ed
Author: Reini Urban <rurban@cpan.org>
Date:   Tue Nov 21 11:30:58 2023 +0100

    injson: fail on arrays when a primitive expected
    
    e.g. ossfuzz 63057

diff --git a/src/in_json.c b/src/in_json.c
index f62fdf2d..5cd2a49e 100644
--- a/src/in_json.c
+++ b/src/in_json.c
@@ -1148,177 +1148,186 @@ static int
 json_HEADER (Bit_Chain *restrict dat, Dwg_Data *restrict dwg,
              jsmntokens_t *restrict tokens)
 {
   const char *section = "HEADER";
   const char *name = section;
   jsmntok_t *t = &tokens->tokens[tokens->index];
   // Dwg_Header_Variables *_obj = &dwg->header_vars;
   Dwg_Object *obj = NULL;
   int size = t->size;
 
   if (t->type != JSMN_OBJECT)
     {
       LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected %s OBJECT",
                  t_typename[t->type], tokens->index, tokens->num_tokens,
                  section);
       json_advance_unknown (dat, tokens, t->type, 0);
       return DWG_ERR_INVALIDTYPE;
     }
   LOG_TRACE ("\n%s pos:%d [%d keys]\n--------------------\n", section,
              tokens->index, t->size);
   tokens->index++;
   for (int i = 0; i < size; i++)
     {
       char key[80];
       Dwg_DYNAPI_field *f;
 
       json_fixed_key (key, dat, tokens);
       JSON_TOKENS_CHECK_OVERFLOW_ERR
       t = &tokens->tokens[tokens->index];
       f = (Dwg_DYNAPI_field *)dwg_dynapi_header_field (key);
       if (!f)
         {
           if (t->type == JSMN_ARRAY && strEQc (key, "layer_colors"))
             {
               tokens->index++;
               for (int index = 0; index < MAX (t->size, 128); index++)
                 {
                   dwg->header_vars.layer_colors[index]
                       = (BITCODE_RS)json_long (dat, tokens);
                   LOG_TRACE ("%s: " FORMAT_RS " [RS]\n", key,
                              dwg->header_vars.layer_colors[index]);
                 }
               JSON_TOKENS_CHECK_OVERFLOW_ERR;
             }
           else
             {
               LOG_WARN ("Unknown key HEADER.%s", key)
               json_advance_unknown (dat, tokens, t->type, 0);
               continue;
             }
         }
       else if (t->type == JSMN_PRIMITIVE
                && (strEQc (f->type, "BD") || strEQc (f->type, "RD")))
         {
           double num = json_float (dat, tokens);
           LOG_TRACE ("%s: " FORMAT_RD " [%s]\n", key, num, f->type)
           dwg_dynapi_header_set_value (dwg, key, &num, 0);
         }
       else if (t->type == JSMN_PRIMITIVE
                && f->size <= 4  // not a RS[]
                && (strEQc (f->type, "RC") || strEQc (f->type, "B")
                    || strEQc (f->type, "BB") || strEQc (f->type, "RS")
                    || strEQc (f->type, "BS") || strEQc (f->type, "RL")
                    || strEQc (f->type, "BL") || strEQc (f->type, "RSd")
                    || strEQc (f->type, "BLd") || strEQc (f->type, "BSd")))
         {
           long num = json_long (dat, tokens);
           LOG_TRACE ("%s: %ld [%s]\n", key, num, f->type)
           dwg_dynapi_header_set_value (dwg, key, &num, 0);
         }
       else if (t->type == JSMN_PRIMITIVE
                && f->size == 8 // not a RLL[]
                && (strEQc (f->type, "RLL") || strEQc (f->type, "BLL")))
         {
           uint64_t num = json_longlong (dat, tokens);
           LOG_TRACE ("%s: " FORMAT_RLL " [%s]\n", key, num, f->type)
           dwg_dynapi_header_set_value (dwg, key, &num, 0);
         }
       else if (t->type == JSMN_STRING
                && (strEQc (f->type, "TV") || strEQc (f->type, "T")))
         {
           size_t len;
           char *str = json_string (dat, tokens);
           LOG_TRACE ("%s: \"%s\" [%s]\n", key, str, f->type);
           if (dwg->header.version < R_13b1 && strEQc (key, "MENU")
               && (len = strlen (str) > 15))
             { // split into MENU + MENUEXT
               strncpy ((char *)dwg->header_vars.MENUEXT, &str[15], 45);
               str[15] = '\0';
               dwg->header_vars.MENU = strdup (str);
               dwg->header_vars.MENUEXT[45] = '\0';
             }
           else
             dwg_dynapi_header_set_value (dwg, key, &str, 1);
           free (str);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "3BD") || strEQc (f->type, "3RD")
                    || strEQc (f->type, "3DPOINT") || strEQc (f->type, "BE")
                    || strEQc (f->type, "3BD_1")))
         {
           BITCODE_3DPOINT pt;
           json_3DPOINT (dat, tokens, name, key, f->type, &pt);
           dwg_dynapi_header_set_value (dwg, key, &pt, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "2BD") || strEQc (f->type, "2RD")
                    || strEQc (f->type, "2DPOINT")
                    || strEQc (f->type, "2BD_1")))
         {
           BITCODE_2DPOINT pt;
           json_2DPOINT (dat, tokens, name, key, f->type, &pt);
           dwg_dynapi_header_set_value (dwg, key, &pt, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "BS") || strEQc (f->type, "RS")))
         {
           int size1 = t->size;
           BITCODE_BS *nums = (BITCODE_BS *)calloc (f->size, 1);
           tokens->index++;
+          // fail if not malloced or inlined array (but json has an array)
+          if (f->size <= 2 && size1 > 1)
+            {
+              LOG_ERROR ("Invalid JSON: HEADER.%s array where primitive expected",
+                         f->name);
+              free (nums);
+              tokens->index += size1;
+              return 0;
+            }
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               nums[k] = (BITCODE_BS)json_long (dat, tokens);
               LOG_TRACE ("%s.%s[%d]: " FORMAT_BS " [%s]\n", name, key, k,
                          nums[k], f->type);
             }
           if (!size1)
             LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
           if (!f->is_malloc)
             {
               dwg_dynapi_header_set_value (dwg, key, nums, 1);
               free (nums);
             }
           else
             dwg_dynapi_header_set_value (dwg, key, &nums, 1);
         }
       else if (strEQc (f->type, "TIMEBLL") || strEQc (f->type, "TIMERLL"))
         {
           BITCODE_TIMEBLL date = { 0 };
           json_TIMEBLL (dat, tokens, key, &date);
           dwg_dynapi_header_set_value (dwg, key, &date, 0);
         }
       else if (strEQc (f->type, "CMC"))
         {
           BITCODE_CMC color = { 0 };
           json_CMC (dat, dwg, tokens, name, key, &color);
           dwg_dynapi_header_set_value (dwg, key, &color, 0);
         }
       else if (t->type == JSMN_ARRAY && strEQc (f->type, "H"))
         {
           BITCODE_H hdl
               = json_HANDLE (dat, dwg, tokens, section, key, NULL, -1);
           if (hdl)
             dwg_dynapi_header_set_value (dwg, key, &hdl, 0);
         }
       //...
       else if (t->type == JSMN_OBJECT && strEQc (key, "CLASSES"))
         {
           LOG_WARN ("Unexpected next section %s", key)
           tokens->index--;
           tokens->index--;
           return 0;
         }
       else
         {
           LOG_WARN ("Unhandled %s [%s] with %s", key, f->type,
                     t_typename[t->type])
           tokens->index++;
           continue;
         }
     }
   LOG_TRACE ("End of %s\n", section)
   // the key
   tokens->index--;
   return 0;
 }
@@ -2109,781 +2118,807 @@ static int
 _set_struct_field (Bit_Chain *restrict dat, const Dwg_Object *restrict obj,
                    jsmntokens_t *restrict tokens, void *restrict _obj,
                    const char *restrict name, const char *restrict key,
                    const Dwg_DYNAPI_field *restrict fields)
 {
   Dwg_Data *restrict dwg = obj->parent;
   const Dwg_DYNAPI_field *f = (Dwg_DYNAPI_field *)fields;
   const jsmntok_t *t = &tokens->tokens[tokens->index];
   int error = 0;
   LOG_INSANE ("-search %s key %s: %s %.*s\n", name, key, t_typename[t->type],
               t->end - t->start, &dat->chain[t->start]);
   JSON_TOKENS_CHECK_OVERFLOW_ERR;
   for (; f->name; f++)
     {
       if (strEQ (f->name, key))
         break;
     }
   // Found common, subclass or entity key, check types
   if (f && f->name)
     {
       LOG_INSANE ("-found %s [%s] %s\n", f->name, f->type,
                   t_typename[t->type]);
       if (t->type == JSMN_PRIMITIVE
           && (strEQc (f->type, "BD") || strEQc (f->type, "RD")
               || strEQc (f->type, "BT")))
         {
           double num = json_float (dat, tokens);
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
           LOG_TRACE ("%s.%s: %f [%s]\n", name, key, num, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &num, 0);
         }
       // all numfields are calculated from actual array sizes
       // for easier adding or deleting entries.
       else if (t->type == JSMN_PRIMITIVE && memBEGINc (key, "num_"))
         {
           tokens->index++;
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
           LOG_TRACE ("%s.%s: %.*s (ignored)\n", name, key, t->end - t->start,
                      &dat->chain[t->start]);
         }
       else if (t->type == JSMN_PRIMITIVE
                && (strEQc (f->type, "RC") || strEQc (f->type, "B")
                    || strEQc (f->type, "BB") || strEQc (f->type, "RS")
                    || strEQc (f->type, "BS") || strEQc (f->type, "RL")
                    || strEQc (f->type, "BL") || strEQc (f->type, "BLd")
                    || strEQc (f->type, "BSd") || strEQc (f->type, "RCd")
                    || strEQc (f->type, "RSd") || strEQc (f->type, "4BITS")))
         {
           long num = json_long (dat, tokens);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           LOG_TRACE ("%s.%s: %ld [%s]\n", name, key, num, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &num, 0);
           if (strEQc (name, "JUMP") && strEQc (key, "jump_address_raw"))
             {
               json_fixup_JUMP ((Dwg_Entity_JUMP *)_obj);
               LOG_TRACE ("%s.%s: 0x%lx [RLx]\n", name, key, num);
             }
         }
       else if (t->type == JSMN_PRIMITIVE
                && (strEQc (f->type, "RLL") || strEQc (f->type, "BLL")))
         {
           uint64_t num = json_long (dat, tokens);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           LOG_TRACE ("%s.%s: " FORMAT_RLL " [%s]\n", name, key, num, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &num, 0);
         }
       // TFF not yet in dynapi.c
       else if (t->type == JSMN_STRING
                && (strEQc (f->type, "TV") || strEQc (f->type, "T")
                    || strEQc (f->type, "TF") || strEQc (f->type, "TU")))
         {
           char *str = json_string (dat, tokens);
           size_t len = strlen (str);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           if (f->dxf == 310) // is BINARY. TODO: TABLE/FIELD *.data_date
             {
               // convert from hex
               size_t blen = len / 2;
               size_t read;
               unsigned char *buf
                   = len ? (unsigned char *)malloc (blen + 1) : NULL;
               char *pos = str;
               char *old;
               if (buf)
                 {
                   if ((read = in_hex2bin (buf, pos, blen) != blen))
                     LOG_ERROR ("in_hex2bin with key %s at pos %" PRIuSIZE
                                " of %" PRIuSIZE,
                                key, read, blen);
                   buf[blen] = '\0';
                   LOG_TRACE ("%s.%s: '%.*s'... [BINARY %" PRIuSIZE "]\n", name,
                              key, MIN ((int)len, 60), str, len);
                 }
               free (str);
               json_set_sizefield (_obj, fields, key, blen);
               // set the ptr directly, no alloc, no conversion.
               old = &((char *)_obj)[f->offset];
               memcpy (old, &buf, f->size);
             }
           // is r11 fixed size string? (tables and controls,
           // marked as TV, not TF)
           else if (dwg->header.from_version <= R_12
                    && (dwg_obj_is_table (obj) || dwg_obj_is_control (obj)))
             {
               char *old;
               // sizes:
               // 16: DIMSTYLE.DIM*
               // 32: *.name
               // 48: LTYPE.description
               // 64: STYLE.font_file, bigfont_file
               // 66: DIMSTYLE.DIMBLK2_T
               const int k = strEQc (key, "name")               ? 32
                             : obj->fixedtype == DWG_TYPE_LTYPE ? 48
                             : obj->fixedtype == DWG_TYPE_DIMSTYLE
                                     && strEQc (key, "DIMBLK2_T")
                                 ? 66
                             : obj->fixedtype == DWG_TYPE_DIMSTYLE ? 16
                                                                   : 64;
               tokens->index--;
               free (str);
               str = json_fixed_string (dat, k, tokens);
               LOG_TRACE ("%s.%s: \"%s\" [TF %d %d]\n", name, key, str, k,
                          f->dxf);
               old = &((char *)_obj)[f->offset];
               memcpy (old, &str, sizeof (char *));
             }
           else if (strEQc (f->type, "TF")) // oleclient, strings_area, ...
                                            // fixup size field
             {
               char *old;
               if (strEQc (key, "strings_area"))
                 {
                   const size_t k
                       = dwg->header.from_version > R_2004 ? 512 : 256;
                   const size_t blen = len / 2;
                   // binary hexstring
                   BITCODE_TF buf = (BITCODE_TF)malloc (blen);
                   len = in_hex2bin (buf, str, blen);
                   if (len != blen)
                     LOG_ERROR ("in_hex2bin with key %s at pos %" PRIuSIZE
                                " of %" PRIuSIZE,
                                key, len, blen);
                   memcpy (str, buf, len);
                   free (buf);
                   if (len > k)
                     {
                       LOG_ERROR ("Illegal %s.%s length %" PRIuSIZE
                                  " > %" PRIuSIZE ", stripped",
                                  name, key, len, k);
                       len = k;
                     }
                   else if (len != k)
                     {
                       str = (char *)realloc (str, k);
                       memset (&str[len + 1], 0, k - len - 1);
                     }
                 }
               else if (f->size > sizeof (char *))
                 {
                   str = (char *)realloc (str, f->size);
                   memset (&str[len + 1], 0, f->size - len - 1);
                 }
               LOG_TRACE ("%s.%s: \"%s\" [%s %d]\n", name, key, str, f->type,
                          f->size);
               if (strNE (key, "strings_area"))
                 json_set_sizefield (_obj, fields, key, len);
               old = &((char *)_obj)[f->offset];
               memcpy (old, &str, sizeof (char *));
               // dwg_dynapi_field_set_value (dwg, _obj, f, &str, 1);
             }
           else
             {
               LOG_TRACE ("%s.%s: \"%s\" [%s] len=%d\n", name, key, str,
                          f->type, (int)len);
               dwg_dynapi_field_set_value (dwg, _obj, f, &str, 1);
               free (str);
             }
         }
       // arrays
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "3BD") || strEQc (f->type, "3RD")
                    || strEQc (f->type, "3DPOINT") || strEQc (f->type, "BE")
                    || strEQc (f->type, "3BD_1")))
         {
           BITCODE_3DPOINT pt;
           json_3DPOINT (dat, tokens, name, key, f->type, &pt);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           dwg_dynapi_field_set_value (dwg, _obj, f, &pt, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "2BD") || strEQc (f->type, "2RD")
                    || strEQc (f->type, "2DPOINT")
                    || strEQc (f->type, "2BD_1")))
         {
           BITCODE_2DPOINT pt;
           json_2DPOINT (dat, tokens, name, key, f->type, &pt);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           dwg_dynapi_field_set_value (dwg, _obj, f, &pt, 1);
         }
       else if (strEQc (f->type, "TIMEBLL") || strEQc (f->type, "TIMERLL"))
         {
           static BITCODE_TIMEBLL date = { 0, 0, 0 };
           json_TIMEBLL (dat, tokens, key, &date);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           dwg_dynapi_field_set_value (dwg, _obj, f, &date, 1);
         }
       else if (strEQc (f->type, "CMC"))
         {
           BITCODE_CMC color = { 0, 0, 0, 0, 0, NULL, NULL, NULL, 0, 0, 0 };
           json_CMC (dat, dwg, tokens, name, key, &color);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           dwg_dynapi_field_set_value (dwg, _obj, f, &color, 1);
         }
       else if (t->type == JSMN_ARRAY && strEQc (f->type, "H"))
         {
           BITCODE_H hdl;
           hdl = json_HANDLE (dat, dwg, tokens, name, key, obj, -1);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           if (hdl)
             dwg_dynapi_field_set_value (dwg, _obj, f, &hdl, 1);
         }
       else if (t->type == JSMN_ARRAY && strEQc (f->type, "H*"))
         {
           BITCODE_BL size1 = t->size;
           BITCODE_H *hdls;
           if (memBEGINc (name, "DICTIONARY") && strEQc (key, "itemhandles"))
             {
               LOG_ERROR ("Illegal old json format");
               return DWG_ERR_INVALIDDWG;
             }
           hdls
               = size1 ? (BITCODE_H *)calloc (size1, sizeof (BITCODE_H)) : NULL;
           json_set_numfield (_obj, fields, key, (long)size1);
           tokens->index++;
           for (int k = 0; k < t->size; k++)
             {
               BITCODE_H hdl;
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               hdl = json_HANDLE (dat, dwg, tokens, name, key, obj, k);
               if (k < (int)size1)
                 {
                   if (hdl)
                     hdls[k] = hdl;
                   else
                     hdls[k] = dwg_add_handleref (dwg, 0, 0, NULL);
                 }
               else
                 LOG_WARN ("ignored");
             }
           if (!size1)
             LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
           // memcpy (&((char *)_obj)[f->offset], &hdls, sizeof (hdls));
           dwg_dynapi_field_set_value (dwg, _obj, f, &hdls, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "T*") || strEQc (f->type, "TV*")))
         {
           int skip = 0;
           BITCODE_BL size1 = t->size;
           BITCODE_T *elems;
           if (memBEGINc (name, "DICTIONARY") && strEQc (key, "texts"))
             {
               LOG_ERROR ("Illegal old json format");
               return DWG_ERR_INVALIDDWG;
             }
           elems
               = size1 ? (BITCODE_T *)calloc (size1, sizeof (BITCODE_T)) : NULL;
           json_set_numfield (_obj, fields, key, (long)size1);
           tokens->index++;
           for (int k = 0; k < t->size; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               if (k < (int)size1)
                 {
                   elems[k] = json_string (dat, tokens);
                   LOG_TRACE ("%s.%s[%d]: \"%s\" [%s]\n", name, key, k,
                              elems[k], f->type);
                 }
               else
                 {
                   tokens->index++;
                   t = &tokens->tokens[tokens->index];
                   LOG_WARN ("%s.%s[%d]: \"%.*s\" [%s] ignored", name, key, k,
                             t->end - t->start, &dat->chain[t->start], f->type);
                 }
             }
           if (!t->size)
             LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &elems, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "3DPOINT*") || strEQc (f->type, "3BD*")))
         {
           int size1 = t->size;
           BITCODE_3DPOINT *pts
               = size1 ? (BITCODE_3BD *)calloc (size1, sizeof (BITCODE_3BD))
                       : NULL;
           json_set_numfield (_obj, fields, key, size1);
           tokens->index++;
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR;
               json_3DPOINT (dat, tokens, name, key, f->type, &pts[k]);
             }
           if (!size1)
             LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &pts, 1);
         }
       else if (t->type == JSMN_ARRAY && strEQc (f->type, "2RD*"))
         {
           const int size1 = t->size;
           BITCODE_2DPOINT *pts = size1 ? (BITCODE_2DPOINT *)calloc (
                                      size1, sizeof (BITCODE_2DPOINT))
                                        : NULL;
           json_set_numfield (_obj, fields, key, size1);
           tokens->index++;
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR;
               json_2DPOINT (dat, tokens, name, key, f->type, &pts[k]);
             }
           if (!size1)
             LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
           dwg_dynapi_field_set_value (dwg, _obj, f, &pts, 1);
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "BD*") || strEQc (f->type, "RD")))
         {
           const int size1 = t->size;
           const int max_k
               = !f->is_malloc ? (int)(f->size / sizeof (BITCODE_BD)) : size1;
           BITCODE_BD *nums;
+          // fail if not malloced or inlined array (but json has an array)
+          if (f->size <= 8 && size1 > 1)
+            {
+              LOG_ERROR ("Invalid JSON: %s.%s array where primitive expected",
+                         name, f->name);
+              tokens->index += size1;
+              return 0;
+            }
           if (f->is_malloc)
             {
               nums = size1 ? (BITCODE_BD *)calloc (size1, sizeof (BITCODE_BD))
                            : NULL;
               json_set_numfield (_obj, fields, key, size1);
             }
           else
-            nums = (BITCODE_BD *)calloc (f->size, 1);
+            {
+              nums = (BITCODE_BD *)calloc (f->size, 1);
+            }
           tokens->index++;
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               if (k < max_k)
                 {
                   nums[k] = json_float (dat, tokens);
                   LOG_TRACE ("%s.%s[%d]: %f [%s]\n", name, key, k, nums[k],
                              f->type);
                 }
             }
           if (!size1)
             {
               LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
             }
           else
             {
               if (f->is_malloc) // BD*, just copy the pointer
                 dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
               else
                 { // copy all values
                   dwg_dynapi_field_set_value (dwg, _obj, f, nums, 1);
                   free (nums);
                 }
             }
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "BL*") || strEQc (f->type, "BLd")))
         {
           const int size1 = t->size;
           const int max_k
               = !f->is_malloc ? (int)(f->size / sizeof (BITCODE_BL)) : size1;
           BITCODE_BL *nums;
+          // fail if not malloced or inlined array (but json has an array)
+          if (f->size <= 4 && size1 > 1)
+            {
+              LOG_ERROR ("Invalid JSON: %s.%s array where primitive expected",
+                         name, f->name);
+              tokens->index += size1;
+              return 0;
+            }
           if (f->is_malloc)
             {
               nums = size1 ? (BITCODE_BL *)calloc (size1, sizeof (BITCODE_BL))
                            : NULL;
               json_set_numfield (_obj, fields, key, size1);
             }
           else
             nums = (BITCODE_BL *)calloc (f->size, 1);
           tokens->index++;
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               if (k < max_k)
                 {
                   nums[k] = (BITCODE_BL)json_long (dat, tokens);
                   if (strEQc (f->type, "BL*"))
                     {
                       LOG_TRACE ("%s.%s[%d]: " FORMAT_BL " [%s]\n", name, key,
                                  k, nums[k], f->type);
                     }
                   else
                     {
                       LOG_TRACE ("%s.%s[%d]: " FORMAT_BLd " [%s]\n", name, key,
                                  k, nums[k], f->type);
                     }
                 }
               else
                 {
                   tokens->index++;
                   LOG_TRACE ("%s.%s[%d]: [%s] ignored\n", name, key, k,
                              f->type);
                 }
             }
           if (!size1)
             {
               LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
             }
           else
             {
               if (f->is_malloc) // BL*
                 dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
               else
                 {
                   dwg_dynapi_field_set_value (dwg, _obj, f, nums, 1);
                   free (nums);
                 }
             }
         }
       else if (t->type == JSMN_ARRAY
                && (strEQc (f->type, "BS") || strEQc (f->type, "BS*")
                    || strEQc (f->type, "RS")))
         {
           const int size1 = t->size;
           const int max_k
               = !f->is_malloc ? (int)(f->size / sizeof (BITCODE_BS)) : size1;
           BITCODE_BS *nums;
+          // fail if not malloced or inlined array (but json has an array)
+          if (f->size <= 2 && size1 > 1)
+            {
+              LOG_ERROR ("Invalid JSON: %s.%s array where primitive expected",
+                         name, f->name);
+              tokens->index += size1;
+              return 0;
+            }
           if (f->is_malloc)
             {
               nums = size1 ? (BITCODE_BS *)calloc (size1, sizeof (BITCODE_BS))
                            : NULL;
               json_set_numfield (_obj, fields, key, size1);
             }
           else
             nums = (BITCODE_BS *)calloc (f->size, 1);
           tokens->index++;
           for (int k = 0; k < size1; k++)
             {
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               if (k < max_k)
                 {
                   nums[k] = (BITCODE_BS)json_long (dat, tokens);
                   LOG_TRACE ("%s.%s[%d]: " FORMAT_BS " [%s]\n", name, key, k,
                              nums[k], f->type);
                 }
               else
                 {
                   tokens->index++;
                   LOG_TRACE ("%s.%s[%d]: [%s] ignored\n", name, key, k,
                              f->type);
                 }
             }
           if (!size1)
             {
               LOG_TRACE ("%s.%s: [%s] empty\n", name, key, f->type);
             }
           else
             {
               if (f->is_malloc) // BS*
                 dwg_dynapi_field_set_value (dwg, _obj, f, &nums, 1);
               else
                 {
                   dwg_dynapi_field_set_value (dwg, _obj, f, nums, 1);
                   free (nums);
                 }
             }
         }
       else if (t->type == JSMN_ARRAY && strEQc (key, "xdata")
                && strEQc (name, "XRECORD"))
         {
           error |= json_xdata (dat, dwg, tokens, (Dwg_Object_XRECORD *)_obj);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
         }
       else if (t->type == JSMN_ARRAY && strEQc (key, "acis_data")
                && strEQc (f->type, "RC*"))
         {
           error |= json_acis_data (dat, dwg, tokens, obj);
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
         }
       else if (t->type == JSMN_ARRAY && strEQc (key, "encr_sat_data")
                && strEQc (f->type, "char **"))
         {
           BITCODE_BL num_blocks = t->size;
           BITCODE_BL *block_size
               = (BITCODE_BL *)calloc (num_blocks + 1, sizeof (BITCODE_BL));
           unsigned char **data = (unsigned char **)calloc (
               num_blocks + 1, sizeof (unsigned char *));
           tokens->index++;
           LOG_TRACE ("num_blocks: " FORMAT_BL " [BL]\n", num_blocks);
           for (BITCODE_BL k = 0; k < num_blocks; k++)
             {
               size_t len;
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               data[k] = json_binary (dat, tokens, "encr_sat_data", &len);
               block_size[k] = (BITCODE_BL)len;
               LOG_TRACE ("block_size[%d]: %" PRIuSIZE " [BL]\n", k, len);
             }
           block_size[num_blocks] = 0;
           LOG_TRACE ("block_size[%d]: 0 [BL]\n", num_blocks);
           dwg_dynapi_entity_set_value (_obj, obj->name, "num_blocks",
                                        &num_blocks, true);
           dwg_dynapi_entity_set_value (_obj, obj->name, "block_size",
                                        &block_size, true);
           dwg_dynapi_field_set_value (dwg, _obj, f, &data, true);
         }
       // TFFx (binary)
       else if (t->type == JSMN_STRING && strEQc (key, "revision_bytes"))
         {
           size_t len;
           unsigned char *s = json_binary (dat, tokens, "revision_bytes", &len);
           JSON_TOKENS_CHECK_OVERFLOW_ERR
           f = dwg_dynapi_entity_field (name, "revision_bytes");
           if (f && len == 8)
             {
               LOG_TRACE ("%s.%s: [%s]\n", name, key, s);
               dwg_dynapi_field_set_value (dwg, _obj, f, s, true);
             }
           free (s);
         }
       // subclass arrays:
       else if (t->type == JSMN_ARRAY && memBEGINc (f->type, "Dwg_"))
         {
           int num_elems = t->size;
           int size_elem;
           char *elems;
           const Dwg_DYNAPI_field *sfields;
           // strip off Dwg_ and final *
           // e.g. 'Dwg_MLINESTYLE_line*' => 'MLINESTYLE_line'
           char *subclass = dwg_dynapi_subclass_name (f->type);
           if (!subclass)
             {
               LOG_ERROR ("Unknown subclass type %s", f->type);
               goto unknown_ent;
             }
           size_elem = dwg_dynapi_fields_size (subclass);
           sfields = dwg_dynapi_subclass_fields (subclass);
           if (!size_elem || !sfields)
             {
               LOG_ERROR ("Unknown subclass name %s", subclass);
               free (subclass);
               goto unknown_ent;
             }
           LOG_TRACE ("new subclass %s %s [%d elems with size %d]\n", name,
                      subclass, num_elems, size_elem);
           json_set_numfield (_obj, fields, key, num_elems);
           if (strEQc (subclass, "MLINE_line") && num_elems)
             {
               Dwg_Entity_MLINE *o = obj->tio.entity->tio.MLINE;
               o->num_lines = num_elems;
               LOG_TRACE ("MLINE.num_lines = %d\n", num_elems);
             }
           if (strEQc (subclass, "DIMASSOC_Ref") && num_elems != 4)
             {
               elems = (char *)calloc (MAX (4, num_elems), size_elem);
               LOG_TRACE ("DIMASSOC num_refs = 4\n");
             }
           else
             elems = num_elems ? (char *)calloc (num_elems, size_elem) : NULL;
           dwg_dynapi_field_set_value (dwg, _obj, f, &elems, 1);
           tokens->index++;
           // array of structs
           if (!num_elems)
             LOG_TRACE ("%s: [%s] empty\n", key, f->type);
           for (int k = 0; k < num_elems; k++)
             {
               int keys;
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               t = &tokens->tokens[tokens->index];
               if (t->type != JSMN_OBJECT)
                 {
                   LOG_ERROR ("Unexpected %s at %u of %ld tokens, expected "
                              "%s OBJECT. %s:%d",
                              t_typename[t->type], tokens->index,
                              tokens->num_tokens, subclass, __FUNCTION__,
                              __LINE__);
                   free (subclass);
                   json_advance_unknown (dat, tokens, t->type, 0);
                   JSON_TOKENS_CHECK_OVERFLOW_ERR
                   return DWG_ERR_INVALIDTYPE;
                 }
               LOG_TRACE ("%s.%s[%d]:\n", name, key, k);
               keys = t->size;
               tokens->index++;
               for (int ki = 0; ki < keys; ki++)
                 {
                   // separate subclass type loop
                   const Dwg_DYNAPI_field *f1;
                   char key1[80];
                   char *rest;
                   JSON_TOKENS_CHECK_OVERFLOW_ERR
                   json_fixed_key (key1, dat, tokens);
                   LOG_INSANE ("-search %s key: %s\n", subclass, key1);
                   f1 = dwg_dynapi_subclass_field (subclass, key1);
                   if (f1)
                     {
                       LOG_INSANE ("-found %s [%s]\n", f1->name, f1->type);
                       if (!_set_struct_field (dat, obj, tokens,
                                               &elems[k * size_elem], subclass,
                                               key1, sfields))
                         ++tokens->index;
                     }
                   else if ((rest = strchr (key1, '.'))) // embedded struct
                     {
                       *rest = '\0';
                       rest++;
                       f1 = dwg_dynapi_subclass_field (subclass, key1);
                       if (f1 && *rest)
                         {
                           char *sb1 = dwg_dynapi_subclass_name (f1->type);
                           const Dwg_DYNAPI_field *sfields1
                               = sb1 ? dwg_dynapi_subclass_fields (sb1) : NULL;
                           if (!sfields1
                               || !_set_struct_field (
                                   dat, obj, tokens,
                                   &elems[(k * size_elem) + f1->offset], sb1,
                                   rest, sfields1))
                             ++tokens->index;
                           free (sb1);
                         }
                     }
                   if (!f1 || !f1->name) // not found
                     {
                       LOG_ERROR ("Unknown subclass field %s.%s", subclass,
                                  key1);
                       ++tokens->index;
                     }
                 }
             }
           if (dwg_dynapi_field_set_value (dwg, _obj, f, &elems, 1))
             LOG_TRACE ("subclass %s.%s done\n", name, key);
           free (subclass);
         }
       // subclass structs (embedded):
       else if (t->type == JSMN_OBJECT && memBEGINc (f->type, "Dwg_"))
         {
           int num_keys = t->size; // div by 2 really
           // int size_struct;
           const Dwg_DYNAPI_field *sfields;
           char *subclass = dwg_dynapi_subclass_name (f->type);
           if (!subclass)
             {
               LOG_ERROR ("Unknown subclass type %s", f->type);
               goto unknown_ent;
             }
           // size_struct = dwg_dynapi_fields_size (subclass);
           sfields = dwg_dynapi_subclass_fields (subclass);
           if (!sfields)
             {
               LOG_ERROR ("Unknown subclass name %s", subclass);
               free (subclass);
               goto unknown_ent;
             }
           LOG_TRACE ("embedded struct %s %s [%d keys]\n", subclass, key,
                      num_keys / 2);
           tokens->index++;
           // a single struct
           if (!num_keys)
             LOG_TRACE ("%s: [%s] empty\n", key, f->type);
           for (int k = 0; k < num_keys; k++)
             {
               const Dwg_DYNAPI_field *f1;
               char key1[80];
               char *rest;
               JSON_TOKENS_CHECK_OVERFLOW_ERR
               json_fixed_key (key1, dat, tokens);
               LOG_INSANE ("-search %s key %s\n", subclass, key1);
               f1 = dwg_dynapi_subclass_field (subclass, key1);
               if (f1)
                 {
                   // subclass offset for _obj
                   void *off = &((char *)_obj)[f->offset + f1->offset];
                   if (!_set_struct_field (dat, obj, tokens, off, subclass,
                                           key1, sfields))
                     ++tokens->index;
                 }
               else if ((rest = strchr (key1, '.'))) // embedded struct
                 {
                   *rest = '\0';
                   rest++;
                   f1 = dwg_dynapi_subclass_field (subclass, key1);
                   if (f1 && *rest)
                     {
                       void *off = &((char *)_obj)[f->offset + f1->offset];
                       char *subclass1 = dwg_dynapi_subclass_name (f1->type);
                       const Dwg_DYNAPI_field *sfields1
                           = subclass1 ? dwg_dynapi_subclass_fields (subclass1)
                                       : NULL;
                       if (!sfields1
                           || !_set_struct_field (dat, obj, tokens, off,
                                                  subclass1, rest, sfields1))
                         ++tokens->index;
                       free (subclass1);
                     }
                 }
               if (!f1 || !f1->name) // not found
                 {
                   LOG_ERROR ("Unknown subclass field %s.%s", subclass, key1);
                   ++tokens->index;
                 }
             }
           free (subclass);
         }
       else
         {
         unknown_ent:
           LOG_ERROR ("Unknown type for %s.%s %s with %s", name, key, f->type,
                      t_typename[t->type]);
           ++tokens->index;
           JSON_TOKENS_CHECK_OVERFLOW_ERR
         }
       return error | (f->name ? 1 : 0); // found or not
     }
   else // not found
     {  // maybe it's an embedded subclass. look for the dot(s)
       int found = 0;
       char *rest = strchr ((char *)key, '.');
       while (rest)
         {
           // Currently we have 3 known static arrays, and a few embedded
           // subclasses. Color e.g.
           const Dwg_DYNAPI_field *f1;
           const char *subclass = NULL;
           JSON_TOKENS_CHECK_OVERFLOW_ERR;
           *rest = '\0';
           rest++;
           f1 = dwg_dynapi_entity_field (name, key);
           if (f1 && *rest)
             {
               void *off = &((char *)_obj)[f1->offset];
               const char *subclass1 = dwg_dynapi_subclass_name (f1->type);
               const Dwg_DYNAPI_field *sfields1
                   = subclass1 ? dwg_dynapi_subclass_fields (subclass1) : NULL;
               if (!sfields1 && subclass1)
                 sfields1 = dwg_dynapi_entity_fields (subclass1);
               if (!sfields1
                   || !_set_struct_field (dat, obj, tokens, off, subclass1,
                                          rest, sfields1))
                 ++tokens->index;
               free ((char *)subclass1);
               return error | (f1->name ? 1 : 0); // found or not
             }
           f1 = dwg_dynapi_subclass_field (name, key);
           if (f1 && *rest)
             {
               void *off = &((char *)_obj)[f1->offset];
               const char *subclass1 = dwg_dynapi_subclass_name (f1->type);
               const Dwg_DYNAPI_field *sfields1
                   = subclass1 ? dwg_dynapi_subclass_fields (subclass1) : NULL;
               if (!sfields1 && subclass1)
                 sfields1 = dwg_dynapi_entity_fields (subclass1);
               if (!sfields1
                   || !_set_struct_field (dat, obj, tokens, off, subclass1,
                                          rest, sfields1))
                 ++tokens->index;
               free ((char *)subclass1);
               return error | (f1->name ? 1 : 0); // found or not
             }
           else
             {
               // failed_key.rest.nextfieldatteept
               *(rest - 1) = '.'; // unsuccessful search, set the dot back
               rest = strchr (rest, '.');
               if (rest)
                 {
                   LOG_HANDLE ("Try next embedded struct with %s.%s\n", key,
                               rest);
                 }
               else
                 {
                   LOG_HANDLE ("No embedded struct with %s\n", key);
                 }
             }
         }
     }
   return error;
 }
 
 /*
 // check both texts[] and itemhandles[]
