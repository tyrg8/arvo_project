commit bfd1461ec81311f31e9fc0f3f298ae779911c7f4
Author: Peter Wu <peter@lekensteyn.nl>
Date:   Tue Apr 25 12:13:01 2017 +0200

    ieee80211: fix stack-use-after-return
    
    Bug: 13662
    Change-Id: I26c53ecc78005b26908d74877814be22924848bc
    Fixes: v1.11.3-rc1-2029-g4b8b83407a ("Support for IEEE 802.11ad")
    Link: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1268
    Reviewed-on: https://code.wireshark.org/review/21333
    Petri-Dish: Peter Wu <peter@lekensteyn.nl>
    Tested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>
    Reviewed-by: Peter Wu <peter@lekensteyn.nl>

diff --git a/epan/dissectors/packet-ieee80211.c b/epan/dissectors/packet-ieee80211.c
index 5347845f02..1c14c81cc0 100644
--- a/epan/dissectors/packet-ieee80211.c
+++ b/epan/dissectors/packet-ieee80211.c
@@ -14327,73 +14327,72 @@ int
 add_tagged_field(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, int ftype,
                  const guint8 *valid_element_ids, guint valid_element_ids_count,
                  association_sanity_check_t *association_sanity_check)
 {
   tvbuff_t     *tag_tvb;
   guint32       tag_no, tag_len;
   proto_tree   *orig_tree = tree;
   proto_item   *ti        = NULL;
   proto_item   *ti_len, *ti_tag;
   ieee80211_tagged_field_data_t field_data;
   gboolean      isDMG;
 
-  gboolean     *p_isDMG = ((gboolean*)(p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_DMG_KEY)));
+  isDMG = GPOINTER_TO_INT(p_get_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_DMG_KEY));
 
-  isDMG   = p_isDMG ? *p_isDMG : FALSE;
   tag_no  = tvb_get_guint8(tvb, offset);
   tag_len = tvb_get_guint8(tvb, offset + 1);
 
   if (tree) {
     ti = proto_tree_add_item(orig_tree, hf_ieee80211_tag, tvb, offset, 2 + tag_len , ENC_NA);
     proto_item_append_text(ti, ": %s", val_to_str_ext(tag_no, &tag_num_vals_ext, "Reserved (%d)"));
 
     tree = proto_item_add_subtree(ti, ett_80211_mgt_ie);
 
   }
 
   ti_tag = proto_tree_add_item(tree, hf_ieee80211_tag_number, tvb, offset, 1, ENC_LITTLE_ENDIAN);
   ti_len = proto_tree_add_uint(tree, hf_ieee80211_tag_length, tvb, offset + 1, 1, tag_len);
   if (tag_len > (guint)tvb_reported_length_remaining(tvb, offset)) {
     expert_add_info_format(pinfo, ti_len, &ei_ieee80211_tag_length,
                            "Tag Length is longer than remaining payload");
   }
 
   /* If the list of valid elements is restricted, require an Element ID to be
    * present in that list. Otherwise stop decoding the value to prevent possible
    * infinite recursions due to unexpected elements. */
   if (valid_element_ids_count) {
     gboolean valid_tag_no;
     guint i;
 
     for (i = 0; i < valid_element_ids_count; i++) {
       valid_tag_no = valid_element_ids[i] == tag_no;
       if (valid_tag_no)
         break;
     }
     if (!valid_tag_no) {
       expert_add_info_format(pinfo, ti_tag, &ei_ieee80211_tag_number,
           "Unexpected Element ID %d", tag_no);
         return tag_len + 1 + 1;
     }
   }
 
   tag_tvb = tvb_new_subset_length(tvb, offset+2, tag_len);
   field_data.sanity_check = association_sanity_check;
   field_data.ftype = ftype;
   field_data.isDMG = isDMG;
   field_data.item_tag = ti;
   field_data.item_tag_length = ti_len;
   if (!dissector_try_uint_new(tagged_field_table, tag_no, tag_tvb, pinfo, tree, FALSE, &field_data))
   {
       proto_tree_add_item(tree, hf_ieee80211_tag_data, tvb, offset + 1 + 1, tag_len, ENC_NA);
       expert_add_info_format(pinfo, ti_tag, &ei_ieee80211_tag_data,
                              "Dissector for 802.11 IE Tag"
                              " (%s) code not implemented, Contact"
                              " Wireshark developers if you want this supported", val_to_str_ext(tag_no,
                                             &tag_num_vals_ext, "(%d)"));
       proto_item_append_text(ti, ": Undecoded");
   }
 
   return tag_len + 1 + 1;
 }
 
 /* 7.3.2.12 Request information element (10) */
@@ -17122,1839 +17121,1839 @@ static int
 dissect_ieee80211_common(tvbuff_t *tvb, packet_info *pinfo,
                           proto_tree *tree, guint32 option_flags,
                           struct ieee_802_11_phdr *phdr)
 {
   guint16          fcf, flags, frame_type_subtype, ctrl_fcf, ctrl_type_subtype;
   guint16          cw_fcf;
   guint16          seq_control;
   guint32          seq_number, frag_number;
   gboolean         more_frags;
   proto_item      *ti          = NULL;
   proto_item      *cw_item     = NULL;
   proto_item      *hidden_item;
   proto_tree      *cw_tree     = NULL;
   guint16          hdr_len, ohdr_len;
   guint16          htc_len     = 0;
   gboolean         has_fcs;
   gint             len, reported_len, ivlen;
   gint             sta_addr_offset = 0;
   const gchar     *station_name;
   gboolean         is_amsdu    = 0;
   gboolean         save_fragmented;
   guint32          addr_type;
   guint8           octet1, octet2;
   char             out_buff[SHORT_STR];
   gint             is_iv_bad;
   guchar           iv_buff[4];
   const char      *addr1_str   = NULL;
   int              addr1_hf    = -1, addr1_hf_resolved = -1;
   guint            offset;
   const gchar     *fts_str;
   gchar            flag_str[]  = "opmPRMFTC";
   gint             ii;
   guint16          qosoff      = 0;
   guint16          qos_control = 0;
   gint             meshctl_len = 0;
   guint8           mesh_flags;
   guint16          meshoff     = 0;
   static wlan_hdr_t whdrs[4];
   gboolean         retransmitted;
   gboolean         isDMG = (phdr->has_frequency ?
                                 IS_80211AD(phdr->frequency) :
                                 FALSE);
 
   encap_t     encap_type;
   proto_tree *hdr_tree = NULL;
   tvbuff_t   *next_tvb = NULL;
   wlan_hdr_t *whdr;
 
   AIRPDCAP_KEY_ITEM  used_key;
 
-  p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_DMG_KEY, &isDMG);
+  p_add_proto_data(wmem_file_scope(), pinfo, proto_wlan, IS_DMG_KEY, GINT_TO_POINTER(isDMG));
 
   whdr= &whdrs[0];
 
   col_set_str(pinfo->cinfo, COL_PROTOCOL, "802.11");
   col_clear(pinfo->cinfo, COL_INFO);
 
   fcf = FETCH_FCF(0);
   frame_type_subtype = COMPOSE_FRAME_TYPE(fcf);
   whdr->type = frame_type_subtype;
   if (frame_type_subtype == CTRL_CONTROL_WRAPPER)
     ctrl_fcf = FETCH_FCF(10);
   else
     ctrl_fcf = 0;
 
   fts_str = val_to_str_ext_const(frame_type_subtype, &frame_type_subtype_vals_ext,
                                  "Unrecognized (Reserved frame)");
   col_set_str(pinfo->cinfo, COL_INFO, fts_str);
 
 
 # define FROM_TO_DS 3
   flags = FCF_FLAGS(fcf);
   more_frags = HAVE_FRAGMENTS(flags);
 
   for (ii = 0; ii < 8; ii++) {
     if (! (flags & 0x80 >> ii)) {
       flag_str[ii] = '.';
     }
   }
 
   switch (FCF_FRAME_TYPE (fcf)) {
 
   case MGT_FRAME:
     hdr_len = MGT_FRAME_HDR_LEN;
     if (HAS_HT_CONTROL(FCF_FLAGS(fcf))) {
       /*
        * Management frames with the Order bit set have an HT Control field;
        * see 8.2.4.1.10 "Order field".  If they're not HT frames, they should
        * never have the Order bit set.
        */
       hdr_len += 4;
       htc_len = 4;
     }
     break;
 
   case CONTROL_FRAME:
     if (frame_type_subtype == CTRL_CONTROL_WRAPPER) {
       hdr_len = 6;
       cw_fcf = ctrl_fcf;
     } else {
       hdr_len = 0;
       cw_fcf = fcf;
     }
     switch (COMPOSE_FRAME_TYPE (cw_fcf)) {
 
     case CTRL_BEAMFORM_RPT_POLL:
       hdr_len += 17;
       break;
 
     case CTRL_VHT_NDP_ANNC:
       hdr_len += 17;
       /* TODO: for now we only consider a single STA, add support for more */
       hdr_len += 2;
       break;
 
     case CTRL_CTS:
     case CTRL_ACKNOWLEDGEMENT:
       hdr_len += 10;
       break;
 
     case CTRL_POLL:
       hdr_len += 18;
       break;
 
     case CTRL_SPR:
     case CTRL_GRANT:
     case CTRL_GRANT_ACK:
       hdr_len += 23;
       break;
 
     case CTRL_DMG_CTS:
       hdr_len += 16;
       break;
 
     case CTRL_DMG_DTS:
     case CTRL_SSW:
       hdr_len += 22;
       break;
 
     case CTRL_SSW_FEEDBACK:
     case CTRL_SSW_ACK:
       hdr_len += 24;
       break;
 
     case CTRL_RTS:
     case CTRL_PS_POLL:
     case CTRL_CFP_END:
     case CTRL_CFP_ENDACK:
     case CTRL_BLOCK_ACK_REQ:
     case CTRL_BLOCK_ACK:
       hdr_len += 16;
       break;
 
     default:
       hdr_len += 4;  /* XXX */
       break;
     }
     break;
 
   case DATA_FRAME:
     hdr_len = (FCF_ADDR_SELECTOR(fcf) == DATA_ADDR_T4) ? DATA_LONG_HDR_LEN : DATA_SHORT_HDR_LEN;
 
     if ((option_flags & IEEE80211_COMMON_OPT_NORMAL_QOS) && DATA_FRAME_IS_QOS(frame_type_subtype)) {
       /* QoS frame */
       qosoff = hdr_len;
       hdr_len += 2; /* Include the QoS field in the header length */
 
       if (HAS_HT_CONTROL(FCF_FLAGS(fcf))) {
         /*
          * QoS data frames with the Order bit set have an HT Control field;
          * see 8.2.4.1.10 "Order field".  If they're not HT frames, they
          * should never have the Order bit set.
          */
         hdr_len += 4;
         htc_len = 4;
       }
 
       /*
        * Does it look as if we have a mesh header?
        * Look at the Mesh Control subfield of the QoS field and at the
        * purported mesh flag fields.
        */
       qos_control = tvb_get_letohs(tvb, qosoff);
       if (tvb_bytes_exist(tvb, hdr_len, 1)) {
         meshoff = hdr_len;
         mesh_flags = tvb_get_guint8(tvb, meshoff);
         if (has_mesh_control(fcf, qos_control, mesh_flags)) {
           /* Yes, add the length of that in as well. */
           meshctl_len = find_mesh_control_length(mesh_flags);
           hdr_len += meshctl_len;
         }
       }
     }
     break;
 
   case EXTENSION_FRAME:
     hdr_len = 10;
     break;
 
   default:
     hdr_len = 4;  /* XXX */
     break;
   }
 
   /*
    * Some portions of this code calculate offsets relative to the end of the
    * header.  But when the header has been padded to align the data this must
    * be done relative to true header size, not the padded/aligned value.  To
    * simplify this work we stash the original header size in ohdr_len instead
    * of recalculating it every time we need it.
    */
   ohdr_len = hdr_len;
   if (phdr->datapad) {
     /*
      * Add in Atheros padding between the 802.11 header and body.
      *
      * XXX - would the mesh header be part of the header or the body
      * from the point of view of the Atheros adapters that insert
      * the padding, assuming they even recognize a mesh header?
      */
     hdr_len = roundup2(hdr_len, 4);
   }
 
   /* Add the FC and duration/id to the current tree */
   ti = proto_tree_add_protocol_format (tree, proto_wlan, tvb, 0, hdr_len,
                                            "IEEE 802.11 %s", fts_str);
   hdr_tree = proto_item_add_subtree(ti, ett_80211);
 
   dissect_frame_control(hdr_tree, tvb, option_flags, 0, pinfo);
   dissect_durid(hdr_tree, tvb, frame_type_subtype, 2);
 
   switch (phdr->fcs_len)
     {
       case 0: /* Definitely has no FCS */
         has_fcs = FALSE;
         break;
 
       case 4: /* Definitely has an FCS */
         has_fcs = TRUE;
         break;
 
       case -2: /* Data frames have no FCS, other frames may have an FCS */
                /* XXX: -2 currently used only in wiretap/netmon.c       */
         if (FCF_FRAME_TYPE (fcf) == DATA_FRAME)
           has_fcs = FALSE;
         else /* Management, Control, Extension */
           has_fcs = wlan_check_fcs;
         break;
 
       default: /* Don't know - use "wlan_check_fcs" */
         has_fcs = wlan_check_fcs;
         break;
     }
 
   /*
    * Decode the part of the frame header that isn't the same for all
    * frame types.
    */
   seq_control = 0;
   frag_number = 0;
   seq_number = 0;
 
   switch (FCF_FRAME_TYPE (fcf))
   {
 
     case MGT_FRAME:
       /*
        * All management frame types have the same header.
        */
       set_address_tvb(&pinfo->dl_src, wlan_address_type, 6, tvb, 10);
       copy_address_shallow(&pinfo->src, &pinfo->dl_src);
       set_address_tvb(&pinfo->dl_dst, wlan_address_type, 6, tvb, 4);
       copy_address_shallow(&pinfo->dst, &pinfo->dl_dst);
 
       /* for tap */
       set_address_tvb(&whdr->bssid, wlan_bssid_address_type, 6, tvb, 16);
       copy_address_shallow(&whdr->src, &pinfo->dl_src);
       copy_address_shallow(&whdr->dst, &pinfo->dl_dst);
 
       seq_control = tvb_get_letohs(tvb, 22);
       frag_number = SEQCTL_FRAGMENT_NUMBER(seq_control);
       seq_number = SEQCTL_SEQUENCE_NUMBER(seq_control);
 
       col_append_fstr(pinfo->cinfo, COL_INFO,
             ", SN=%d", seq_number);
 
       col_append_fstr(pinfo->cinfo, COL_INFO,
             ", FN=%d", frag_number);
 
       if (tree)
       {
         const gchar *ra_da_name, *ta_sa_name, *bssid_name;
 
         proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ra, tvb, 4, 6, ENC_NA);
         ra_da_name = tvb_get_ether_name(tvb, 4);
         hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ra_resolved, tvb, 4, 6, ra_da_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         proto_tree_add_item(hdr_tree, hf_ieee80211_addr_da, tvb, 4, 6, ENC_NA);
         hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_da_resolved, tvb, 4, 6, ra_da_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ta, tvb, 10, 6, ENC_NA);
         ta_sa_name = tvb_get_ether_name(tvb, 10);
         hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ta_resolved, tvb, 10, 6, ta_sa_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         proto_tree_add_item(hdr_tree, hf_ieee80211_addr_sa, tvb, 10, 6, ENC_NA);
         hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_sa_resolved, tvb, 10, 6, ta_sa_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         proto_tree_add_item(hdr_tree, hf_ieee80211_addr_bssid, tvb, 16, 6, ENC_NA);
         bssid_name = tvb_get_ether_name(tvb, 16);
         hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_bssid_resolved, tvb, 16, 6, bssid_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
 
         /* FIXME: With mgmt frames FROM_TO_DS is always 0, perhaps compare address to bssid instead? */
         if ((flags & FROM_TO_DS) == FLAG_FROM_DS) { /* Receiver address */
           sta_addr_offset = 4;
         } else if ((flags & FROM_TO_DS) == FLAG_TO_DS) { /* Transmitter address */
           sta_addr_offset = 10;
         }
         if (sta_addr_offset > 0) {
           proto_tree_add_item(hdr_tree, hf_ieee80211_addr_staa, tvb, sta_addr_offset, 6, ENC_NA);
           station_name = tvb_get_ether_name(tvb, sta_addr_offset);
           hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_staa_resolved, tvb, sta_addr_offset, 6, station_name);
           PROTO_ITEM_SET_HIDDEN(hidden_item);
         }
         /* add items for wlan.addr filter */
         hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, 4, 6, ENC_NA);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, 4, 6, ra_da_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, 10, 6, ENC_NA);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, 10, 6, ta_sa_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, 16, 6, ENC_NA);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, 16, 6, bssid_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         proto_tree_add_item(hdr_tree, hf_ieee80211_frag_number, tvb, 22, 2, ENC_LITTLE_ENDIAN);
         proto_tree_add_item(hdr_tree, hf_ieee80211_seq_number, tvb, 22, 2, ENC_LITTLE_ENDIAN);
       }
       break;
 
     case CONTROL_FRAME:
     {
       /*
        * Control Wrapper frames insert themselves between address 1
        * and address 2 in a normal control frame.  Process address 1
        * first, then handle the rest of the frame in dissect_control.
        */
       if (frame_type_subtype == CTRL_CONTROL_WRAPPER) {
         offset = 10; /* FC + D/ID + Address 1 + CFC + HTC */
         ctrl_fcf = FETCH_FCF(10);
         ctrl_type_subtype = COMPOSE_FRAME_TYPE(ctrl_fcf);
       } else {
         offset = 10; /* FC + D/ID + Address 1 */
         ctrl_type_subtype = frame_type_subtype;
       }
       /* Added to disallow DMG STA to transfer packets of certain forbidden types. */
       switch (ctrl_type_subtype)
       {
         case CTRL_PS_POLL:
         case CTRL_CTS:
         case CTRL_CFP_ENDACK:
         if(isDMG == TRUE) {
           expert_add_info_format(pinfo, hdr_tree, &ei_ieee80211_dmg_subtype,
               "DMG STA shouldn't transmit control frame of type contention-free period end+ack");
         }
         break;
         default:
           break;
       }
 
       switch (ctrl_type_subtype)
       {
         case CTRL_PS_POLL:
           addr1_str = "BSSID";
           addr1_hf = hf_ieee80211_addr_bssid;
           addr1_hf_resolved = hf_ieee80211_addr_bssid_resolved;
 
           break;
         case CTRL_BEAMFORM_RPT_POLL:
         case CTRL_VHT_NDP_ANNC:
         case CTRL_RTS:
         case CTRL_POLL:
         case CTRL_SPR:
         case CTRL_GRANT:
         case CTRL_DMG_CTS:
         case CTRL_DMG_DTS:
         case CTRL_GRANT_ACK:
         case CTRL_SSW:
         case CTRL_SSW_FEEDBACK:
         case CTRL_SSW_ACK:
         case CTRL_CTS:
         case CTRL_ACKNOWLEDGEMENT:
         case CTRL_CFP_END:
         case CTRL_CFP_ENDACK:
         case CTRL_BLOCK_ACK_REQ:
         case CTRL_BLOCK_ACK:
           addr1_str = "RA";
           addr1_hf = hf_ieee80211_addr_ra;
           addr1_hf_resolved = hf_ieee80211_addr_ra_resolved;
           break;
         default:
           break;
       }
 
       if (!addr1_str) /* XXX - Should we throw some sort of error? */
         break;
 
       /* Add address 1 */
       set_dst_addr_cols(pinfo, tvb, 4, addr1_str);
       if (tree) {
         const gchar *ether_name = tvb_get_ether_name(tvb, 4);
         proto_tree_add_item(hdr_tree, addr1_hf, tvb, 4, 6, ENC_NA);
         hidden_item = proto_tree_add_string(hdr_tree, addr1_hf_resolved, tvb, 4, 6, ether_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, 4, 6, ENC_NA);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
         hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, 4, 6, ether_name);
         PROTO_ITEM_SET_HIDDEN(hidden_item);
       }
 
       /*
        * Start shoving in other fields if needed.
        */
       if (frame_type_subtype == CTRL_CONTROL_WRAPPER) {
         /* if (tree) */
         {
           cw_tree = proto_tree_add_subtree(hdr_tree, tvb, offset, 2,
                       ett_cntrl_wrapper_fc, NULL, "Contained Frame Control");
           dissect_frame_control(cw_tree, tvb, 0, offset, pinfo);
           dissect_ht_control(hdr_tree, tvb, offset + 2);
           offset += 6;
           hdr_tree = proto_tree_add_subtree(hdr_tree, tvb, offset, 2,
                       ett_cntrl_wrapper_fc, &cw_item, "Carried Frame");
           if (isDMG) {
             expert_add_info_format(pinfo, cw_item, &ei_ieee80211_dmg_subtype,
                                    "DMG STA shouldn't transmit Control Wrapper frame");
           }
         }
       }
 
       switch (ctrl_type_subtype)
       {
         case CTRL_PS_POLL:
         case CTRL_CFP_ENDACK:
         {
           set_src_addr_cols(pinfo, tvb, offset, "BSSID");
           /* if (tree) */
           {
             const gchar *ether_name = tvb_get_ether_name(tvb, offset);
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ta, tvb, offset, 6, ENC_NA);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ta_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             offset += 6;
           }
           break;
         }
 
         case CTRL_CFP_END:
         {
           if (isDMG)
             set_src_addr_cols(pinfo, tvb, offset, "TA");
           else
             set_src_addr_cols(pinfo, tvb, offset, "BSSID");
           /* if (tree) */
           {
             const gchar *ether_name = tvb_get_ether_name(tvb, offset);
             if (isDMG) {
               proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ta, tvb, offset, 6, ENC_NA);
               hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ta_resolved, tvb, offset, 6, ether_name);
               PROTO_ITEM_SET_HIDDEN(hidden_item);
             } else {
               proto_tree_add_item(hdr_tree, hf_ieee80211_addr_bssid, tvb, offset, 6, ENC_NA);
               hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_bssid_resolved, tvb, offset, 6, ether_name);
               PROTO_ITEM_SET_HIDDEN(hidden_item);
             }
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             offset += 6;
           }
           break;
         }
 
         case CTRL_BEAMFORM_RPT_POLL:
         {
           set_src_addr_cols(pinfo, tvb, offset, "TA");
           /* if (tree) */
           {
             const gchar *ether_name = tvb_get_ether_name(tvb, offset);
 
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ta, tvb, offset, 6, ENC_NA);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ta_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             offset += 6;
 
             proto_tree_add_item(hdr_tree, hf_ieee80211_beamform_feedback_seg_retrans_bitmap, tvb, offset, 1, ENC_NA);
           }
         break;
         }
 
         case CTRL_VHT_NDP_ANNC:
         {
           set_src_addr_cols(pinfo, tvb, offset, "TA");
           /* if (tree) */
           {
             guint16 sta_info;
             guint8 len_fcs = 0;
             proto_tree *dialog_token_tree;
             proto_item *dialog_token_item;
             proto_tree *sta_info_tree;
             proto_item *sta_info_item;
             const gchar *ether_name = tvb_get_ether_name(tvb, offset);
 
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ta, tvb, offset, 6, ENC_NA);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ta_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             offset += 6;
 
             dialog_token_item = proto_tree_add_item(hdr_tree, hf_ieee80211_vht_ndp_annc_token,
                                                     tvb, offset, 1, ENC_NA);
             dialog_token_tree = proto_item_add_subtree(dialog_token_item, ett_vht_ndp_annc_token_tree);
             proto_tree_add_item(dialog_token_tree, hf_ieee80211_vht_ndp_annc_token_number,
                                 tvb, offset, 1, ENC_NA);
             proto_tree_add_item(dialog_token_tree, hf_ieee80211_vht_ndp_annc_token_reserved,
                                 tvb, offset, 1, ENC_NA);
             offset++;
 
             /* Check if there is FCS in the packet */
             if(has_fcs){
               len_fcs = 4;
             }
             while (tvb_reported_length_remaining(tvb, offset) > len_fcs) {
               sta_info_item = proto_tree_add_item(hdr_tree, hf_ieee80211_vht_ndp_annc_sta_info,
                                                   tvb, offset, 2, ENC_LITTLE_ENDIAN);
               sta_info_tree = proto_item_add_subtree(sta_info_item, ett_vht_ndp_annc_sta_info_tree);
               proto_tree_add_item(sta_info_tree, hf_ieee80211_vht_ndp_annc_sta_info_aid12,
                                   tvb, offset, 2, ENC_LITTLE_ENDIAN);
               proto_tree_add_item(sta_info_tree, hf_ieee80211_vht_ndp_annc_sta_info_feedback_type,
                                   tvb, offset, 2, ENC_LITTLE_ENDIAN);
 
               sta_info = tvb_get_letohs(tvb, offset);
 
               if (sta_info & 0x1000)
                 proto_tree_add_uint(sta_info_tree,
                                     hf_ieee80211_vht_ndp_annc_sta_info_nc_index,
                                     tvb, offset, 2, sta_info);
               else
                 proto_tree_add_item(sta_info_tree, hf_ieee80211_vht_ndp_annc_sta_info_reserved,
                                     tvb, offset, 2, ENC_LITTLE_ENDIAN);
               offset += 2;
             }
           }
         break;
         }
 
         case CTRL_GRANT_ACK:
         case CTRL_SSW:
         case CTRL_SSW_FEEDBACK:
         case CTRL_SSW_ACK:
         case CTRL_DMG_CTS:
         case CTRL_GRANT:
         case CTRL_SPR:
         case CTRL_POLL:
         case CTRL_RTS:
         {
           set_src_addr_cols(pinfo, tvb, offset, "TA");
           /* if (tree) */
           {
             const gchar *ether_name = tvb_get_ether_name(tvb, offset);
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ta, tvb, offset, 6, ENC_NA);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ta_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             offset += 6;
           }
           break;
         }
 
         case CTRL_CONTROL_WRAPPER:
         {
           /* XXX - We shouldn't see this.  Should we throw an error? */
           break;
         }
 
         case CTRL_BLOCK_ACK_REQ:
         {
           set_src_addr_cols(pinfo, tvb, offset, "TA");
 
           /* if (tree) */
           {
             guint16 bar_control;
             guint8 block_ack_type;
             proto_item *bar_parent_item;
             proto_tree *bar_sub_tree;
             const gchar *ether_name = tvb_get_ether_name(tvb, offset);
 
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ta, tvb, offset, 6, ENC_NA);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ta_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             offset += 6;
 
             bar_control = tvb_get_letohs(tvb, offset);
             /* According to the 802.11ad standard (28/12/12) there is need to find the
              * GCR subfield which isn't described, thus the black_ack_type calculations
              * should be changed.
              */
             block_ack_type = (bar_control & 0x0006) >> 1;
             proto_tree_add_item(hdr_tree, hf_ieee80211_block_ack_request_type, tvb,
               offset, 2, ENC_LITTLE_ENDIAN);
             bar_parent_item = proto_tree_add_item(hdr_tree,
               hf_ieee80211_block_ack_request_control, tvb, offset, 2, ENC_LITTLE_ENDIAN);
             bar_sub_tree = proto_item_add_subtree(bar_parent_item,
               ett_block_ack);
             proto_tree_add_item(bar_sub_tree,
               hf_ieee80211_block_ack_control_ack_policy, tvb, offset, 2, ENC_LITTLE_ENDIAN);
             proto_tree_add_item(bar_sub_tree, hf_ieee80211_block_ack_control_multi_tid,
               tvb, offset, 2, ENC_LITTLE_ENDIAN);
             proto_tree_add_item(bar_sub_tree,
               hf_ieee80211_block_ack_control_compressed_bitmap, tvb, offset, 2,
               ENC_LITTLE_ENDIAN);
             proto_tree_add_item(bar_sub_tree, hf_ieee80211_block_ack_control_reserved,
               tvb, offset, 2, ENC_LITTLE_ENDIAN);
 
             switch (block_ack_type)
             {
               case 0: /*Basic BlockAckReq */
               {
                 if(isDMG == TRUE) {
                    expert_add_info_format(pinfo, bar_sub_tree, &ei_ieee80211_dmg_subtype,
                            "DMG STA shouldn't transmit BlockAckReq frame with Basic BlockAckReq");
                    break;
                 }
                 proto_tree_add_item(bar_sub_tree,
                 hf_ieee80211_block_ack_control_basic_tid_info, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 /*offset +=*/ add_ff_block_ack_ssc(hdr_tree, tvb, pinfo, offset);
                 break;
               }
               case 1: /* Extended Compressesd BlockAckReq */
                 if(isDMG == FALSE) {
                    expert_add_info_format(pinfo, bar_sub_tree, &ei_ieee80211_dmg_subtype,
                            "Non-DMG STA shouldn't transmit BlockAckReq frame with Extended Compressed BlockAckReq");
                    break;
                 }
               /* FALL THROUGH */
               case 2: /* Compressed BlockAckReq */
               {
                 proto_tree_add_item(bar_sub_tree,
                 hf_ieee80211_block_ack_control_compressed_tid_info, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 /*offset +=*/ add_ff_block_ack_ssc(hdr_tree, tvb, pinfo, offset);
                 break;
               }
               case 3: /* Multi-TID BlockAckReq */
               {
                 guint8 tid_count;
                 guint iii;
                 proto_tree *bar_mtid_tree, *bar_mtid_sub_tree;
 
                 if(isDMG == TRUE) {
                    expert_add_info_format(pinfo, bar_sub_tree, &ei_ieee80211_dmg_subtype,
                            "DMG STA shouldn't transmit BlockAckReq frame with Basic BlockAckReq");
                    break;
                 }
 
                 tid_count = ((bar_control & 0xF000) >> 12) + 1;
                 proto_tree_add_uint(bar_sub_tree, hf_ieee80211_block_ack_control_multi_tid_info, tvb, offset, 2, tid_count);
                 offset += 2;
 
                 bar_mtid_tree = proto_tree_add_subtree(hdr_tree, tvb, offset, tid_count*4, ett_block_ack, NULL, "Per TID Info");
                 for (iii = 0; iii < tid_count; iii++) {
                   bar_parent_item = proto_tree_add_uint(bar_mtid_tree, hf_ieee80211_block_ack_multi_tid_info, tvb, offset, 4, iii);
                   bar_mtid_sub_tree = proto_item_add_subtree(bar_parent_item, ett_block_ack);
 
                   proto_tree_add_item(bar_mtid_sub_tree, hf_ieee80211_block_ack_multi_tid_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                   proto_tree_add_item(bar_mtid_sub_tree, hf_ieee80211_block_ack_multi_tid_value, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                   offset += 2;
 
                   offset += add_ff_block_ack_ssc(bar_mtid_sub_tree, tvb, pinfo, offset);
                 }
                 break;
               }
             }
           }
           break;
         }
 
         case CTRL_BLOCK_ACK:
         {
           set_src_addr_cols(pinfo, tvb, offset, "TA");
 
           /* if (tree) */
           {
             guint16 ba_control;
             guint8 block_ack_type;
             proto_item *ba_parent_item;
             proto_tree *ba_sub_tree;
             const gchar *ether_name = tvb_get_ether_name(tvb, offset);
 
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ta, tvb, offset, 6, ENC_NA);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ta_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, offset, 6, ether_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             offset += 6;
 
             ba_control = tvb_get_letohs(tvb, offset);
             block_ack_type = (ba_control & 0x0006) >> 1;
             proto_tree_add_item(hdr_tree, hf_ieee80211_block_ack_type, tvb, offset, 2, ENC_LITTLE_ENDIAN);
             ba_parent_item = proto_tree_add_item(hdr_tree,
               hf_ieee80211_block_ack_control, tvb, offset, 2, ENC_LITTLE_ENDIAN);
             ba_sub_tree = proto_item_add_subtree(ba_parent_item, ett_block_ack);
             proto_tree_add_item(ba_sub_tree, hf_ieee80211_block_ack_control_ack_policy,
               tvb, offset, 2, ENC_LITTLE_ENDIAN);
             proto_tree_add_item(ba_sub_tree, hf_ieee80211_block_ack_control_multi_tid,
               tvb, offset, 2, ENC_LITTLE_ENDIAN);
             proto_tree_add_item(ba_sub_tree,
               hf_ieee80211_block_ack_control_compressed_bitmap, tvb, offset, 2,
               ENC_LITTLE_ENDIAN);
             proto_tree_add_item(ba_sub_tree, hf_ieee80211_block_ack_control_reserved, tvb,
               offset, 2, ENC_LITTLE_ENDIAN);
 
             switch (block_ack_type)
             {
               case 0: /*Basic BlockAck */
               {
                 proto_tree_add_item(ba_sub_tree,
                 hf_ieee80211_block_ack_control_basic_tid_info, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 offset += add_ff_block_ack_ssc(hdr_tree, tvb, pinfo, offset);
                 proto_tree_add_item(hdr_tree, hf_ieee80211_block_ack_bitmap, tvb, offset, 128, ENC_NA);
                 /*offset += 128;*/
                 break;
               }
               /* Added to support Extended Compressed BlockAck RBUFCAP subfield.*/
               case 1: /* Extended Compressed BlockAck */
               {
                 guint16 ssn;
                 guint64 bmap;
                 int f;
                 proto_item *ba_bitmap_item;
                 proto_tree *ba_bitmap_tree;
                 if(isDMG == FALSE) {
                    expert_add_info_format(pinfo, ba_sub_tree, &ei_ieee80211_dmg_subtype,
                            "Non-DMG STA shouldn't transmit BlockAck frame with Extended Compressed BlockAck");
                    break;
                 }
                 proto_tree_add_item(ba_sub_tree, hf_ieee80211_block_ack_control_basic_tid_info, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 ssn = tvb_get_letohs(tvb, offset);
                 ssn >>= 4;
                 offset += add_ff_block_ack_ssc(hdr_tree, tvb, pinfo, offset);
                 bmap = tvb_get_letoh64(tvb, offset);
                 ba_bitmap_item = proto_tree_add_item(hdr_tree, hf_ieee80211_block_ack_bitmap, tvb, offset, 8, ENC_NA);
                 ba_bitmap_tree = proto_item_add_subtree(ba_bitmap_item, ett_block_ack_bitmap);
                 for (f = 0; f < 64; f++) {
                   if (bmap & (G_GUINT64_CONSTANT(1) << f))
                     continue;
                   proto_tree_add_uint(ba_bitmap_tree, hf_ieee80211_block_ack_bitmap_missing_frame,
                                                    tvb, offset + (f/8), 1, ssn + f);
                 }
                 offset += 8;
                 proto_tree_add_item(ba_sub_tree, hf_ieee80211_block_ack_RBUFCAP, tvb, offset, 1, ENC_LITTLE_ENDIAN);
                 offset += 1;
                 break;
               }
               case 2: /* Compressed BlockAck */
               {
                 guint16 ssn;
                 guint64 bmap;
                 int f;
                 proto_item *ba_bitmap_item;
                 proto_tree *ba_bitmap_tree;
 
                 proto_tree_add_item(ba_sub_tree, hf_ieee80211_block_ack_control_basic_tid_info, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                 offset += 2;
 
                 ssn = tvb_get_letohs(tvb, offset);
                 ssn >>= 4;
                 offset += add_ff_block_ack_ssc(hdr_tree, tvb, pinfo, offset);
                 bmap = tvb_get_letoh64(tvb, offset);
                 ba_bitmap_item = proto_tree_add_item(hdr_tree, hf_ieee80211_block_ack_bitmap, tvb, offset, 8, ENC_NA);
                 ba_bitmap_tree = proto_item_add_subtree(ba_bitmap_item, ett_block_ack_bitmap);
                 for (f = 0; f < 64; f++) {
                   if (bmap & (G_GUINT64_CONSTANT(1) << f))
                     continue;
                   proto_tree_add_uint_format_value(ba_bitmap_tree, hf_ieee80211_block_ack_bitmap_missing_frame,
                                                    tvb, offset + (f/8), 1, ssn + f, "%u", (ssn + f) & 0x0fff);
                 }
                 /*offset += 8;*/
                 break;
               }
               case 3:  /* Multi-TID BlockAck */
               {
                 guint8 tid_count;
                 guint iii;
                 proto_tree *ba_mtid_tree, *ba_mtid_sub_tree;
 
                 tid_count = ((ba_control & 0xF000) >> 12) + 1;
                 proto_tree_add_uint(ba_sub_tree,
                 hf_ieee80211_block_ack_control_compressed_tid_info, tvb, offset, 2, tid_count);
                 offset += 2;
 
                 ba_mtid_tree = proto_tree_add_subtree(hdr_tree, tvb, offset, tid_count*4, ett_block_ack, NULL, "Per TID Info");
                 for (iii = 0; iii < tid_count; iii++) {
                   ba_parent_item = proto_tree_add_uint(ba_mtid_tree, hf_ieee80211_block_ack_multi_tid_info, tvb, offset, 4, iii);
                   ba_mtid_sub_tree = proto_item_add_subtree(ba_parent_item, ett_block_ack);
 
                   proto_tree_add_item(ba_mtid_sub_tree, hf_ieee80211_block_ack_multi_tid_reserved, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                   proto_tree_add_item(ba_mtid_sub_tree, hf_ieee80211_block_ack_multi_tid_value, tvb, offset, 2, ENC_LITTLE_ENDIAN);
                   offset += 2;
 
                   offset += add_ff_block_ack_ssc(ba_mtid_sub_tree, tvb, pinfo, offset);
                   proto_tree_add_item(ba_mtid_sub_tree, hf_ieee80211_block_ack_bitmap, tvb, offset, 8, ENC_NA);
                   offset += 8;
                 }
                 break;
               }
             }
           }
           break;
         }
       }
 /*
  * 802.11ad : Used for extension types.
  */
       switch (ctrl_type_subtype) {
         case CTRL_POLL: {
                 proto_tree_add_item(hdr_tree, hf_ieee80211_cf_response_offset,
                       tvb, offset, 2, ENC_LITTLE_ENDIAN);
 
                 break;
         }
         case CTRL_GRANT:
         case CTRL_GRANT_ACK:
         case CTRL_SPR: {
           gboolean isGrant;
           if(ctrl_type_subtype != CTRL_GRANT_ACK) {
             offset += add_ff_dynamic_allocation(hdr_tree, tvb, pinfo, offset);
           } else { /* CTRL_GRANT_ACK have 5 octets that are reserved*/
             proto_tree_add_item(hdr_tree, hf_ieee80211_grant_ack_reserved, tvb, offset, 5, ENC_NA);
             offset += 5;
           }
           isGrant = ((ctrl_type_subtype==CTRL_GRANT)||(ctrl_type_subtype==CTRL_GRANT_ACK));
           add_ff_beamforming_ctrl(hdr_tree, tvb, pinfo, offset, isGrant);
           /* offset += 2; */
           break;
         }
         case CTRL_SSW: {
           guint32 sector_sweep;
 
           sector_sweep = tvb_get_letoh24(tvb, offset);
           offset += add_ff_sector_sweep(hdr_tree, tvb, pinfo, offset);
           /* if Sector Sweep Direction = Responder, use SW Feedback field format when not transmitted as part of an ISS */
           if(sector_sweep & 0x00001) {
             add_ff_sector_sweep_feedback_to_iss(hdr_tree, tvb, pinfo, offset);
           } else {
             add_ff_sector_sweep_feedback_from_iss(hdr_tree, tvb, pinfo, offset);
           }
           /* offset += 3; */
           break;
         }
         case CTRL_SSW_ACK:
         case CTRL_SSW_FEEDBACK: {
           offset += add_ff_sector_sweep_feedback_to_iss(hdr_tree, tvb, pinfo, offset);
           offset += add_ff_BRP_request(hdr_tree, tvb, pinfo, offset);
           add_ff_beamformed_link(hdr_tree, tvb, pinfo, offset);
           /* offset += 1; */
           break;
         }
         case CTRL_DMG_DTS: {
           proto_tree_add_item(hdr_tree, hf_ieee80211_addr_nav_sa, tvb, offset, 6, ENC_NA);
           offset += 6;
           proto_tree_add_item(hdr_tree, hf_ieee80211_addr_nav_da, tvb, offset, 6, ENC_NA);
           /* offset += 6; */
           break;
         }
         default:
                 break;
       }
       break;
     }
 
     case DATA_FRAME:
     {
       guint32 ra_offset, da_offset, sa_offset, ta_offset, bssid_offset;
       addr_type = FCF_ADDR_SELECTOR(fcf);
 
       /* In order to show src/dst address we must always do the following */
       switch (addr_type)
       {
 
         case DATA_ADDR_T1:
           ra_offset = 4;
           da_offset = 4;
           sa_offset = 10;
           ta_offset = 10;
           bssid_offset = 16;
           break;
 
         case DATA_ADDR_T2:
           ra_offset = 4;
           da_offset = 4;
           sa_offset = 16;
           ta_offset = 10;
           bssid_offset = 10;
           break;
 
         case DATA_ADDR_T3:
           ra_offset = 4;
           da_offset = 16;
           sa_offset = 10;
           ta_offset = 10;
           bssid_offset = 4;
           break;
 
         case DATA_ADDR_T4:
           ra_offset = 4;
           da_offset = 16;
           sa_offset = 24;
           ta_offset = 10;
           bssid_offset = 10;
           break;
 
         default:
           /* Should never happen? */
           ra_offset = 0;
           da_offset = 0;
           sa_offset = 0;
           ta_offset = 0;
           bssid_offset = 0;
           break;
       }
 
 
 
       set_address_tvb(&pinfo->dl_src, wlan_address_type, 6, tvb, sa_offset);
       copy_address_shallow(&pinfo->src, &pinfo->dl_src);
       set_address_tvb(&pinfo->dl_dst, wlan_address_type, 6, tvb, da_offset);
       copy_address_shallow(&pinfo->dst, &pinfo->dl_dst);
 
       /* for tap */
       set_address_tvb(&whdr->bssid, wlan_bssid_address_type, 6, tvb, bssid_offset);
 
       copy_address_shallow(&whdr->src, &pinfo->dl_src);
       copy_address_shallow(&whdr->dst, &pinfo->dl_dst);
 
       seq_control = tvb_get_letohs(tvb, 22);
       frag_number = SEQCTL_FRAGMENT_NUMBER(seq_control);
       seq_number = SEQCTL_SEQUENCE_NUMBER(seq_control);
 
       col_append_fstr(pinfo->cinfo, COL_INFO,
             ", SN=%d, FN=%d", seq_number, frag_number);
 
       /* Now if we have a tree we start adding stuff */
       if (tree)
       {
         const gchar *ra_name, *ta_name, *sa_name, *da_name, *bssid_name = NULL;
 
         switch (addr_type)
         {
           case DATA_ADDR_T1:
           case DATA_ADDR_T2:
           case DATA_ADDR_T3:
           case DATA_ADDR_T4:
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ra, tvb, ra_offset, 6, ENC_NA);
             ra_name = tvb_get_ether_name(tvb, ra_offset);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ra_resolved, tvb, ra_offset, 6, ra_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
 
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_da, tvb, da_offset, 6, ENC_NA);
             da_name = tvb_get_ether_name(tvb, da_offset);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_da_resolved, tvb, da_offset, 6, da_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
 
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_ta, tvb, ta_offset, 6, ENC_NA);
             ta_name = tvb_get_ether_name(tvb, ta_offset);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_ta_resolved, tvb, ta_offset, 6, ta_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
 
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_sa, tvb, sa_offset, 6, ENC_NA);
             sa_name = tvb_get_ether_name(tvb, sa_offset);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_sa_resolved, tvb, sa_offset, 6, sa_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
 
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_bssid, tvb, bssid_offset, 6, ENC_NA);
             bssid_name = tvb_get_ether_name(tvb, bssid_offset);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_bssid_resolved, tvb, bssid_offset, 6, bssid_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
 
             if ((flags & FROM_TO_DS) == FLAG_FROM_DS) { /* Receiver address */
               sta_addr_offset = ra_offset;
             } else if ((flags & FROM_TO_DS) == FLAG_TO_DS) { /* Transmitter address */
               sta_addr_offset = ta_offset;
             }
             if (sta_addr_offset > 0) {
               proto_tree_add_item(hdr_tree, hf_ieee80211_addr_staa, tvb, sta_addr_offset, 6, ENC_NA);
               station_name = tvb_get_ether_name(tvb, sta_addr_offset);
               hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_staa_resolved, tvb, sta_addr_offset, 6, station_name);
               PROTO_ITEM_SET_HIDDEN(hidden_item);
             }
             proto_tree_add_item(hdr_tree, hf_ieee80211_frag_number, tvb, 22, 2, ENC_LITTLE_ENDIAN);
             proto_tree_add_item(hdr_tree, hf_ieee80211_seq_number, tvb, 22, 2, ENC_LITTLE_ENDIAN);
 
             /* add items for wlan.addr filter */
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, ra_offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, ra_offset, 6, ra_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, ta_offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, ta_offset, 6, ta_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, sa_offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, sa_offset, 6, sa_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, da_offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, da_offset, 6, da_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, bssid_offset, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_resolved, tvb, bssid_offset, 6, bssid_name);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
             break;
         }
 
       }
       break;
       }
     case EXTENSION_FRAME: {
       switch (frame_type_subtype) {
         case EXTENSION_DMG_BEACON: {
           set_dst_addr_cols(pinfo, tvb, 4, "BSSID");
           if (tree) {
             proto_tree_add_item(hdr_tree, hf_ieee80211_addr_bssid, tvb, 4, 6, ENC_NA);
             hidden_item = proto_tree_add_item(hdr_tree, hf_ieee80211_addr, tvb, 4, 6, ENC_NA);
             PROTO_ITEM_SET_HIDDEN(hidden_item);
           }
           break;
         }
       }
     }
   }
 
   len = tvb_captured_length_remaining(tvb, hdr_len);
   reported_len = tvb_reported_length_remaining(tvb, hdr_len);
 
   if (has_fcs)
     {
       /*
        * Well, this packet should, in theory, have an FCS.
        * Do we have the entire packet, and does it have enough data for
        * the FCS?
        */
       if (reported_len < 4)
       {
         /*
          * The packet is claimed not to even have enough data for a 4-byte
          * FCS.
          * Pretend it doesn't have an FCS.
          */
         ;
       }
       else if (len < reported_len)
       {
         /*
          * The packet is claimed to have enough data for a 4-byte FCS, but
          * we didn't capture all of the packet.
          * Slice off the 4-byte FCS from the reported length, and trim the
          * captured length so it's no more than the reported length; that
          * will slice off what of the FCS, if any, is in the captured
          * length.
          */
         reported_len -= 4;
         if (len > reported_len)
             len = reported_len;
       }
       else
       {
         /*
          * We have the entire packet, and it includes a 4-byte FCS.
          * Slice it off, and put it into the tree.
          */
         len          -= 4;
         reported_len -= 4;
         if (wlan_check_checksum)
         {
           guint32 sent_fcs = tvb_get_letohl(tvb, hdr_len + len);
           guint32 fcs;
 
           if (phdr->datapad)
             fcs = crc32_802_tvb_padded(tvb, ohdr_len, hdr_len, len);
           else
             fcs = crc32_ccitt_tvb(tvb, hdr_len + len);
           if (fcs != sent_fcs) {
             flag_str[8] = '.';
           }
 
           proto_tree_add_checksum(hdr_tree, tvb, hdr_len + len, hf_ieee80211_fcs, hf_ieee80211_fcs_status, &ei_ieee80211_fcs, pinfo, fcs, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_VERIFY);
         } else {
           proto_tree_add_checksum(hdr_tree, tvb, hdr_len + len, hf_ieee80211_fcs, hf_ieee80211_fcs_status, &ei_ieee80211_fcs, pinfo, 0, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_NO_FLAGS);
         }
       }
     }
   else
     {
       flag_str[8] = '\0';
     }
 
   proto_item_append_text(ti, ", Flags: %s", flag_str);
   col_append_fstr(pinfo->cinfo, COL_INFO, ", Flags=%s", flag_str);
 
 
   /*
    * Only management and data frames have a body, so we don't have
    * anything more to do for other types of frames.
    */
   switch (FCF_FRAME_TYPE (fcf))
     {
 
     case MGT_FRAME:
       if (htc_len == 4) {
         dissect_ht_control(hdr_tree, tvb, ohdr_len - 4);
       }
       break;
 
     case DATA_FRAME:
       if ((option_flags & IEEE80211_COMMON_OPT_NORMAL_QOS) && tree && DATA_FRAME_IS_QOS(frame_type_subtype))
       {
         proto_item *qos_fields, *qos_ti;
         proto_tree *qos_tree;
 
         guint16 qos_eosp;
         guint16 qos_field_content;
 
         qos_fields = proto_tree_add_item(hdr_tree, hf_ieee80211_qos, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
         qos_tree = proto_item_add_subtree(qos_fields, ett_qos_parameters);
 
         qos_eosp = QOS_EOSP(qos_control);
         qos_field_content = QOS_FIELD_CONTENT(qos_control);
 
         proto_tree_add_item(qos_tree, hf_ieee80211_qos_tid, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
 
         qos_ti = proto_tree_add_item(qos_tree, hf_ieee80211_qos_priority, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
         PROTO_ITEM_SET_GENERATED(qos_ti);
 
         if (FLAGS_DS_STATUS(flags) == (FLAG_FROM_DS|FLAG_TO_DS)) {
           /* mesh frame */
           proto_tree_add_item(qos_tree, hf_ieee80211_qos_eosp, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
         } else {
           if (flags & FLAG_TO_DS) {
             proto_tree_add_item(qos_tree, hf_ieee80211_qos_bit4, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
           } else {
             proto_tree_add_item(qos_tree, hf_ieee80211_qos_eosp, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
           }
         }
 
         proto_tree_add_item(qos_tree, hf_ieee80211_qos_ack_policy, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
 
         if (flags & FLAG_FROM_DS) {
           if (!DATA_FRAME_IS_NULL(frame_type_subtype)) {
             proto_tree_add_item(qos_tree, hf_ieee80211_qos_amsdu_present, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
             is_amsdu = QOS_AMSDU_PRESENT(qos_control);
           }
           if (DATA_FRAME_IS_CF_POLL(frame_type_subtype)) {
             /* txop limit */
               qos_ti = proto_tree_add_item(qos_tree, hf_ieee80211_qos_txop_limit, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
             if (qos_field_content == 0) {
               proto_item_append_text(qos_ti, " (transmit one frame immediately)");
             }
           } else {
             /* qap ps buffer state */
             proto_item *qos_ps_buf_state_fields;
             proto_tree *qos_ps_buf_state_tree;
 
             qos_ps_buf_state_fields = proto_tree_add_item(qos_tree, hf_ieee80211_qos_ps_buf_state, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
             qos_ps_buf_state_tree = proto_item_add_subtree(qos_ps_buf_state_fields, ett_qos_ps_buf_state);
 
             proto_tree_add_item(qos_ps_buf_state_tree, hf_ieee80211_qos_buf_state_indicated, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
 
             if (QOS_PS_BUF_STATE_INDICATED(qos_field_content)) {
               proto_tree_add_item(qos_ps_buf_state_tree, hf_ieee80211_qos_highest_pri_buf_ac, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
               qos_ti = proto_tree_add_item(qos_ps_buf_state_tree, hf_ieee80211_qos_qap_buf_load, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
               switch (QOS_PS_QAP_BUF_LOAD(qos_field_content)) {
 
               case 0:
                 proto_item_append_text(qos_ti, " (no buffered traffic)");
                 break;
 
               default:
                 proto_item_append_text(qos_ti, " (%d octets)", QOS_PS_QAP_BUF_LOAD(qos_field_content)*4096);
                 break;
 
               case 15:
                 proto_item_append_text(qos_ti, " (greater than 57344 octets)");
                 break;
               }
 
             }
           }
         } else {
           if (!DATA_FRAME_IS_NULL(frame_type_subtype)) {
             proto_tree_add_item(qos_tree, hf_ieee80211_qos_amsdu_present, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
             is_amsdu = QOS_AMSDU_PRESENT(qos_control);
           }
           if (qos_eosp) {
             /* queue size */
             qos_ti = proto_tree_add_item(qos_tree, hf_ieee80211_qos_queue_size, tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
             switch (qos_field_content) {
             case 0:
               proto_item_append_text(qos_ti, " (no buffered traffic in the queue)");
               break;
 
             default:
               proto_item_append_text(qos_ti, " (%u bytes)", qos_field_content*256);
               break;
 
             case 254:
               proto_item_append_text(qos_ti, " (more than 64768 octets)");
               break;
 
             case 255:
               proto_item_append_text(qos_ti, " (unspecified or unknown)");
               break;
             }
           } else {
             /* txop duration requested */
             qos_ti = proto_tree_add_item(qos_tree, hf_ieee80211_qos_txop_dur_req,
                                    tvb, qosoff, 2, ENC_LITTLE_ENDIAN);
             if (qos_field_content == 0) {
               proto_item_append_text(qos_ti, " (no TXOP requested)");
             }
           }
         }
 
         /* Do we have +HTC? */
         if (htc_len == 4) {
           dissect_ht_control(hdr_tree, tvb, ohdr_len - 4);
         }
 
         if (meshctl_len != 0) {
           proto_item *msh_fields;
           proto_tree *msh_tree;
 
           msh_fields = proto_tree_add_item(hdr_tree, hf_ieee80211_mesh_control_field, tvb, meshoff, meshctl_len, ENC_NA);
           msh_tree = proto_item_add_subtree(msh_fields, ett_msh_control);
           add_ff_mesh_control(msh_tree, tvb, pinfo, meshoff);
         }
 
       } /* end of qos control field */
       if (enable_decryption && !pinfo->fd->flags.visited) {
         const guint8 *enc_data = tvb_get_ptr(tvb, 0, hdr_len+reported_len);
         /* The processing will take care of 4-way handshake sessions for WPA and WPA2 decryption */
         AirPDcapPacketProcess(&airpdcap_ctx, enc_data, hdr_len, hdr_len+reported_len, NULL, 0, NULL, TRUE);
 
       }
       /*
        * No-data frames don't have a body.
        */
       if (DATA_FRAME_IS_NULL(frame_type_subtype))
         goto end_of_wlan;
 
       if (!wlan_subdissector) {
         guint fnum = 0;
 
         /* key: bssid:src
          * data: last seq_control seen and frame number
          */
         retransmitted = FALSE;
         if (!pinfo->fd->flags.visited) {
           retransmit_key key;
           retransmit_key *result;
 
           memcpy(key.bssid, whdr->bssid.data, 6);
           memcpy(key.src, whdr->src.data, 6);
           key.seq_control = 0;
           result = (retransmit_key *)g_hash_table_lookup(fc_analyse_retransmit_table, &key);
           if (result && (result->seq_control == seq_control)) {
             /* keep a pointer to the first seen frame, could be done with proto data? */
             fnum = result->fnum;
             g_hash_table_insert(fc_first_frame_table, GINT_TO_POINTER(pinfo->num),
                                 GINT_TO_POINTER(fnum));
             retransmitted = TRUE;
           } else {
             /* first time or new seq*/
             if (!result) {
               result = wmem_new(wmem_file_scope(), retransmit_key);
               *result = key;
               g_hash_table_insert(fc_analyse_retransmit_table, result, result);
             }
             result->seq_control = seq_control;
             result->fnum =  pinfo->num;
           }
         }
         else if ((fnum = GPOINTER_TO_UINT(g_hash_table_lookup(fc_first_frame_table, GINT_TO_POINTER(pinfo->num))))) {
           retransmitted = TRUE;
         }
 
         if (retransmitted) {
           col_append_str(pinfo->cinfo, COL_INFO, " [retransmitted]");
           if (tree) {
             proto_item *item;
 
             item=proto_tree_add_none_format(hdr_tree, hf_ieee80211_fc_analysis_retransmission, tvb, 0, 0,
                                             "Retransmitted frame");
             PROTO_ITEM_SET_GENERATED(item);
             item=proto_tree_add_uint(hdr_tree, hf_ieee80211_fc_analysis_retransmission_frame, tvb, 0, 0, fnum);
             PROTO_ITEM_SET_GENERATED(item);
           }
           next_tvb = tvb_new_subset_length_caplen(tvb, hdr_len, len, reported_len);
           call_data_dissector(next_tvb, pinfo, tree);
           goto end_of_wlan;
         }
       }
 
       break;
 
     case CONTROL_FRAME:
       goto end_of_wlan;
 
     case EXTENSION_FRAME:
       break;
 
     default:
       goto end_of_wlan;
     }
 
   if (IS_PROTECTED(FCF_FLAGS(fcf))
       && !phdr->decrypted
       && (wlan_ignore_prot != WLAN_IGNORE_PROT_WO_IV)) {
     /*
      * It's a WEP or WPA encrypted frame, and it hasn't already been
      * decrypted; dissect the protections parameters and decrypt the data,
      * if we have a matching key. Otherwise display it as data.
      */
     gboolean    can_decrypt = FALSE;
     proto_tree *wep_tree    = NULL;
     guint32     iv;
     guint8      key, keybyte;
 
 #define PROTECTION_ALG_WEP  AIRPDCAP_KEY_TYPE_WEP
 #define PROTECTION_ALG_TKIP  AIRPDCAP_KEY_TYPE_TKIP
 #define PROTECTION_ALG_CCMP  AIRPDCAP_KEY_TYPE_CCMP
 #define PROTECTION_ALG_RSNA  PROTECTION_ALG_CCMP | PROTECTION_ALG_TKIP
     guint8 algorithm=G_MAXUINT8;
 #define IS_TKIP(tvb, hdr_len)  (tvb_get_guint8(tvb, hdr_len + 1) == \
   ((tvb_get_guint8(tvb, hdr_len) | 0x20) & 0x7f))
 #define IS_CCMP(tvb, hdr_len)  (tvb_get_guint8(tvb, hdr_len + 2) == 0)
     guint32 sec_header=0;
     guint32 sec_trailer=0;
 
     next_tvb = try_decrypt(tvb, pinfo, hdr_len, reported_len, &algorithm, &sec_header, &sec_trailer, &used_key);
 
     keybyte = tvb_get_guint8(tvb, hdr_len + 3);
     key = KEY_OCTET_WEP_KEY(keybyte);
     if ((keybyte & KEY_EXTIV) && (len >= EXTIV_LEN)) {
       /* Extended IV; this frame is likely encrypted with TKIP or CCMP */
       if (tree) {
         if (algorithm==PROTECTION_ALG_TKIP)
           wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
               ett_wep_parameters, NULL, "TKIP parameters");
         else if (algorithm==PROTECTION_ALG_CCMP)
           wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
             ett_wep_parameters, NULL, "CCMP parameters");
         else {
           if (IS_TKIP(tvb, hdr_len)) {
             algorithm=PROTECTION_ALG_TKIP;
             wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
                 ett_wep_parameters, NULL, "TKIP parameters");
           } else if (IS_CCMP(tvb, hdr_len)) {
             algorithm=PROTECTION_ALG_CCMP;
             wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
                 ett_wep_parameters, NULL, "CCMP parameters");
           } else
             wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 8,
                 ett_wep_parameters, NULL, "TKIP/CCMP parameters");
         }
         proto_item_set_len(ti, hdr_len + 8);
 
         if (algorithm==PROTECTION_ALG_TKIP) {
           g_snprintf(out_buff, SHORT_STR, "0x%08X%02X%02X",
               tvb_get_letohl(tvb, hdr_len + 4),
               tvb_get_guint8(tvb, hdr_len),
               tvb_get_guint8(tvb, hdr_len + 2));
           proto_tree_add_string(wep_tree, hf_ieee80211_tkip_extiv, tvb, hdr_len,
               EXTIV_LEN, out_buff);
         } else if (algorithm==PROTECTION_ALG_CCMP) {
           g_snprintf(out_buff, SHORT_STR, "0x%08X%02X%02X",
               tvb_get_letohl(tvb, hdr_len + 4),
               tvb_get_guint8(tvb, hdr_len + 1),
               tvb_get_guint8(tvb, hdr_len));
           proto_tree_add_string(wep_tree, hf_ieee80211_ccmp_extiv, tvb, hdr_len,
               EXTIV_LEN, out_buff);
         }
 
         proto_tree_add_uint(wep_tree, hf_ieee80211_wep_key, tvb, hdr_len + 3, 1, key);
       }
 
       /* Subtract out the length of the IV. */
       len          -= EXTIV_LEN;
       reported_len -= EXTIV_LEN;
       ivlen         = EXTIV_LEN;
       /* It is unknown whether this is TKIP or CCMP, so let's not even try to
        * parse TKIP Michael MIC+ICV or CCMP MIC. */
 
       /* checking for the trailer                            */
       if (next_tvb!=NULL) {
         if (reported_len < (gint) sec_trailer) {
           /* There is no space for a trailer, ignore it and don't decrypt  */
           ;
         } else if (len < reported_len) {
           /* There is space for a trailer, but we haven't capture all the  */
           /* packet. Slice off the trailer, but don't try to decrypt      */
           reported_len -= sec_trailer;
           if (len > reported_len)
             len = reported_len;
         } else {
           /* Ok, we have a trailer and the whole packet. Decrypt it!      */
           /* TODO: At the moment we won't add the trailer to the tree,    */
           /* so don't remove the trailer from the packet                  */
           len          -= sec_trailer;
           reported_len -= sec_trailer;
           can_decrypt   = TRUE;
 
           /* Add Key information to packet */
           bytes_to_hexstr(out_buff, used_key.KeyData.Wpa.Ptk+32, AIRPDCAP_TK_LEN); /* TK is stored in PTK at offset 32 bytes and 16 bytes long */
           out_buff[2*AIRPDCAP_TK_LEN] = '\0';
 
           if (key == 0) { /* encrypted with pairwise key */
             ti = proto_tree_add_string(wep_tree, hf_ieee80211_fc_analysis_tk, tvb, 0, 0, out_buff);
             PROTO_ITEM_SET_GENERATED(ti);
 
             /* Also add the PMK used to to decrypt the packet. (PMK==PSK) */
             bytes_to_hexstr(out_buff, used_key.KeyData.Wpa.Psk, AIRPDCAP_WPA_PSK_LEN); /* 32 bytes */
             out_buff[2*AIRPDCAP_WPA_PSK_LEN] = '\0';
             ti = proto_tree_add_string(wep_tree, hf_ieee80211_fc_analysis_pmk, tvb, 0, 0, out_buff);
             PROTO_ITEM_SET_GENERATED(ti);
 
           } else { /* Encrypted with Group Key */
             ti = proto_tree_add_string(wep_tree, hf_ieee80211_fc_analysis_gtk, tvb, 0, 0, out_buff); /* GTK is stored in PTK at offset 32 bytes and 16 bytes long */
             PROTO_ITEM_SET_GENERATED(ti);
           }
         }
       }
     } else {
       /* No Ext. IV - WEP packet */
       /*
        * XXX - pass the IV and key to "try_decrypt_wep()", and have it pass
        * them to "wep_decrypt()", rather than having "wep_decrypt()" extract
        * them itself.
        *
        * Also, just pass the data *following* the WEP parameters as the
        * buffer to decrypt.
        */
       iv = tvb_get_ntoh24(tvb, hdr_len);
       if (tree) {
         wep_tree = proto_tree_add_subtree(hdr_tree, tvb, hdr_len, 4,
             ett_wep_parameters, NULL, "WEP parameters");
 
         proto_tree_add_uint(wep_tree, hf_ieee80211_wep_iv, tvb, hdr_len, 3, iv);
         tvb_memcpy(tvb, iv_buff, hdr_len, 3);
         is_iv_bad = weak_iv(iv_buff);
         if (is_iv_bad != -1) {
           proto_tree_add_boolean_format (wep_tree, hf_ieee80211_wep_iv_weak,
               tvb, 0, 0, TRUE,
               "Weak IV for key byte %d",
               is_iv_bad);
         }
       }
       if (tree)
         proto_tree_add_uint(wep_tree, hf_ieee80211_wep_key, tvb, hdr_len + 3, 1, key);
 
       /* Subtract out the length of the IV. */
       len          -= 4;
       reported_len -= 4;
       ivlen         = 4;
 
       /* Even if the decryption was not successful, set the algorithm */
       algorithm=PROTECTION_ALG_WEP;
 
       /*
        * Well, this packet should, in theory, have an ICV.
        * Do we have the entire packet, and does it have enough data for
        * the ICV?
        */
       if (reported_len < 4) {
         /*
          * The packet is claimed not to even have enough data for a
          * 4-byte ICV.
          * Pretend it doesn't have an ICV.
          */
         ;
       } else if (len < reported_len) {
         /*
          * The packet is claimed to have enough data for a 4-byte ICV,
          * but we didn't capture all of the packet.
          * Slice off the 4-byte ICV from the reported length, and trim
          * the captured length so it's no more than the reported length;
          * that will slice off what of the ICV, if any, is in the
          * captured length.
          */
         reported_len -= 4;
         if (len > reported_len)
           len         = reported_len;
       } else {
         /*
          * We have the entire packet, and it includes a 4-byte ICV.
          * Slice it off, and put it into the tree.
          *
          * We only support decrypting if we have the the ICV.
          *
          * XXX - the ICV is encrypted; we're putting the encrypted
          * value, not the decrypted value, into the tree.
          */
         len          -= 4;
         reported_len -= 4;
         can_decrypt   = TRUE;
       }
     }
 
     if (algorithm == PROTECTION_ALG_WEP) {
       g_strlcpy(wlan_stats.protection, "WEP", MAX_PROTECT_LEN);
     } else if (algorithm == PROTECTION_ALG_TKIP) {
       g_strlcpy(wlan_stats.protection, "TKIP", MAX_PROTECT_LEN);
     } else if (algorithm == PROTECTION_ALG_CCMP) {
       g_strlcpy(wlan_stats.protection, "CCMP", MAX_PROTECT_LEN);
     } else {
       g_strlcpy(wlan_stats.protection, "Unknown", MAX_PROTECT_LEN);
     }
 
     /* protection header                                  */
     if (!can_decrypt || (next_tvb == NULL)) {
       /*
        * WEP decode impossible or failed, treat payload as raw data
        * and don't attempt fragment reassembly or further dissection.
        */
       next_tvb = tvb_new_subset_length_caplen(tvb, hdr_len + ivlen, len, reported_len);
 
       if (tree) {
         if (algorithm == PROTECTION_ALG_WEP) {
           if (can_decrypt)
             proto_tree_add_uint_format_value(wep_tree, hf_ieee80211_wep_icv, tvb,
                 hdr_len + ivlen + len, 4,
                 tvb_get_ntohl(tvb, hdr_len + ivlen + len),
                 "0x%08x (not verified)",
                 tvb_get_ntohl(tvb, hdr_len + ivlen + len));
         } else if (algorithm == PROTECTION_ALG_CCMP) {
         } else if (algorithm == PROTECTION_ALG_TKIP) {
         }
       }
 
       if ((!(option_flags & IEEE80211_COMMON_OPT_IS_CENTRINO)) && (wlan_ignore_prot == WLAN_IGNORE_PROT_NO)) {
         /* Some wireless drivers (such as Centrino) WEP payload already decrypted */
         call_data_dissector(next_tvb, pinfo, tree);
         goto end_of_wlan;
       }
     } else {
       if (algorithm == PROTECTION_ALG_WEP) {
         if (tree)
           proto_tree_add_uint_format_value(wep_tree, hf_ieee80211_wep_icv, tvb,
               hdr_len + ivlen + len, 4,
               tvb_get_ntohl(tvb, hdr_len + ivlen + len),
               "0x%08x (correct)",
               tvb_get_ntohl(tvb, hdr_len + ivlen + len));
 
         add_new_data_source(pinfo, next_tvb, "Decrypted WEP data");
       } else if (algorithm==PROTECTION_ALG_CCMP) {
         add_new_data_source(pinfo, next_tvb, "Decrypted CCMP data");
       } else if (algorithm==PROTECTION_ALG_TKIP) {
         add_new_data_source(pinfo, next_tvb, "Decrypted TKIP data");
       }
 #undef IS_TKIP
 #undef IS_CCMP
 #undef PROTECTION_ALG_CCMP
 #undef PROTECTION_ALG_TKIP
 #undef PROTECTION_ALG_WEP
     }
 
     /*
      * WEP decryption successful!
      *
      * Use the tvbuff we got back from the decryption; the data starts at
      * the beginning.  The lengths are already correct for the decoded WEP
      * payload.
      */
     hdr_len = 0;
 
   } else {
     /*
      * Not a WEP-encrypted frame; just use the data from the tvbuff
      * handed to us.
      *
      * The payload starts at "hdr_len" (i.e., just past the 802.11
      * MAC header), the length of data in the tvbuff following the
      * 802.11 header is "len", and the length of data in the packet
      * following the 802.11 header is "reported_len".
      */
     next_tvb = tvb;
   }
 
   /*
    * Do defragmentation if "wlan_defragment" is true, and we have more
    * fragments or this isn't the first fragment.
    *
    * We have to do some special handling to catch frames that
    * have the "More Fragments" indicator not set but that
    * don't show up as reassembled and don't have any other
    * fragments present.  Some networking interfaces appear
    * to do reassembly even when you're capturing raw packets
    * *and* show the reassembled packet without the "More
    * Fragments" indicator set *but* with a non-zero fragment
    * number.
    *
    * "fragment_add_seq_802_11()" handles that; we want to call it
    * even if we have a short frame, so that it does those checks - if
    * the frame is short, it doesn't do reassembly on it.
    *
    * (This could get some false positives if we really *did* only
    * capture the last fragment of a fragmented packet, but that's
    * life.)
    */
   save_fragmented = pinfo->fragmented;
   if (wlan_defragment && (more_frags || (frag_number != 0))) {
     fragment_head *fd_head;
 
     /*
      * If we've already seen this frame, look it up in the
      * table of reassembled packets, otherwise add it to
      * whatever reassembly is in progress, if any, and see
      * if it's done.
      */
     if (reported_len < 0)
       THROW(ReportedBoundsError);
     fd_head = fragment_add_seq_802_11(&wlan_reassembly_table,
         next_tvb, hdr_len, pinfo, seq_number, NULL,
         frag_number,
         reported_len,
         more_frags);
     next_tvb = process_reassembled_data(tvb, hdr_len, pinfo,
         "Reassembled 802.11", fd_head,
         &frag_items, NULL, hdr_tree);
   } else {
     /*
      * If this is the first fragment, dissect its contents, otherwise
      * just show it as a fragment.
      */
     if (frag_number != 0) {
       /* Not the first fragment - don't dissect it. */
       next_tvb = NULL;
     } else {
       /* First fragment, or not fragmented.  Dissect what we have here. */
 
       /* Get a tvbuff for the payload. */
       next_tvb = tvb_new_subset_length_caplen(next_tvb, hdr_len, len, reported_len);
 
       /*
        * If this is the first fragment, but not the only fragment,
        * tell the next protocol that.
        */
       if (more_frags)
         pinfo->fragmented = TRUE;
       else
         pinfo->fragmented = FALSE;
     }
   }
 
   if (next_tvb == NULL) {
     /* Just show this as an incomplete fragment. */
     col_set_str(pinfo->cinfo, COL_INFO, "Fragmented IEEE 802.11 frame");
     next_tvb = tvb_new_subset_length_caplen(tvb, hdr_len, len, reported_len);
     call_data_dissector(next_tvb, pinfo, tree);
     pinfo->fragmented = save_fragmented;
     goto end_of_wlan;
   }
 
   switch (FCF_FRAME_TYPE (fcf))
     {
 
     case MGT_FRAME:
       dissect_ieee80211_mgt(fcf, next_tvb, pinfo, tree);
       break;
 
     case DATA_FRAME:
       if (is_amsdu && (tvb_reported_length_remaining(next_tvb, 0) > 4)) {
         proto_item   *parent_item;
         proto_tree   *mpdu_tree;
         guint32       msdu_offset = 0;
         guint         i           = 1;
 
         parent_item = proto_tree_add_protocol_format(tree, proto_aggregate, next_tvb, 0,
                                     tvb_reported_length_remaining(next_tvb, 0), "IEEE 802.11 Aggregate MSDU");
         mpdu_tree = proto_item_add_subtree(parent_item, ett_msdu_aggregation_parent_tree);
 
         do {
           tvbuff_t *volatile  msdu_tvb;
           guint16             msdu_length;
           proto_tree         *subframe_tree;
 
           /*
            * IEEE Std 802.11-2012 says, in section 8.3.2.2 "A-MSDU format":
            *
            *  The A-MSDU subframe header contains three fields: DA, SA, and
            *  Length. The order of these fields and the bits within these
            *  fields are the same as the IEEE 802.3 frame format.
            *
            * which means that the length field is big-endian, not
            * little-endian.
            */
           msdu_length = tvb_get_ntohs(next_tvb, msdu_offset+12);
 
           parent_item = proto_tree_add_item(mpdu_tree, hf_ieee80211_amsdu_subframe, next_tvb,
                             msdu_offset, roundup2(msdu_offset+14+msdu_length, 4), ENC_NA);
           proto_item_append_text(parent_item, " #%u", i);
           subframe_tree = proto_item_add_subtree(parent_item, ett_msdu_aggregation_subframe_tree);
           i += 1;
 
           proto_tree_add_item(subframe_tree, hf_ieee80211_addr_da, next_tvb, msdu_offset, 6, ENC_NA);
           hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_da_resolved, tvb, msdu_offset, 6,
             tvb_get_ether_name(tvb, msdu_offset));
           PROTO_ITEM_SET_HIDDEN(hidden_item);
           proto_tree_add_item(subframe_tree, hf_ieee80211_addr_sa, next_tvb, msdu_offset+6, 6, ENC_NA);
           hidden_item = proto_tree_add_string(hdr_tree, hf_ieee80211_addr_sa_resolved, tvb, msdu_offset+6, 6,
             tvb_get_ether_name(tvb, msdu_offset+6));
           PROTO_ITEM_SET_HIDDEN(hidden_item);
           proto_tree_add_item(subframe_tree, hf_ieee80211_amsdu_length, next_tvb, msdu_offset+12, 2, ENC_BIG_ENDIAN);
 
           msdu_offset += 14;
           msdu_tvb = tvb_new_subset_length(next_tvb, msdu_offset, msdu_length);
           call_dissector(llc_handle, msdu_tvb, pinfo, subframe_tree);
           msdu_offset = roundup2(msdu_offset+msdu_length, 4);
         } while (tvb_reported_length_remaining(next_tvb, msdu_offset) > 14);
 
         break;
       }
       /* I guess some bridges take Netware Ethernet_802_3 frames,
          which are 802.3 frames (with a length field rather than
          a type field, but with no 802.2 header in the payload),
          and just stick the payload into an 802.11 frame.  I've seen
          captures that show frames of that sort.
 
          We also handle some odd form of encapsulation in which a
          complete Ethernet frame is encapsulated within an 802.11
          data frame, with no 802.2 header.  This has been seen
          from some hardware.
 
          On top of that, at least at some point it appeared that
          the OLPC XO sent out frames with two bytes of 0 between
          the "end" of the 802.11 header and the beginning of
          the payload. Something similar has also been observed
          with Atheros chipsets. There the sequence control field
          seems repeated.
 
          So, if the packet doesn't start with 0xaa 0xaa:
 
            we first use the same scheme that linux-wlan-ng does to detect
            those encapsulated Ethernet frames, namely looking to see whether
            the frame either starts with 6 octets that match the destination
            address from the 802.11 header or has 6 octets that match the
            source address from the 802.11 header following the first 6 octets,
            and, if so, treat it as an encapsulated Ethernet frame;
 
            otherwise, we use the same scheme that we use in the Ethernet
            dissector to recognize Netware 802.3 frames, namely checking
            whether the packet starts with 0xff 0xff and, if so, treat it
            as an encapsulated IPX frame, and then check whether the
            packet starts with 0x00 0x00 and, if so, treat it as an OLPC
            frame, or check the packet starts with the repetition of the
            sequence control field and, if so, treat it as an Atheros frame. */
       encap_type = ENCAP_802_2;
       if (tvb_bytes_exist(next_tvb, 0, 2)) {
         octet1 = tvb_get_guint8(next_tvb, 0);
         octet2 = tvb_get_guint8(next_tvb, 1);
         if ((octet1 != 0xaa) || (octet2 != 0xaa)) {
           if ((tvb_memeql(next_tvb, 6, (const guint8 *)pinfo->dl_src.data, 6) == 0) ||
               (tvb_memeql(next_tvb, 0, (const guint8 *)pinfo->dl_dst.data, 6) == 0))
             encap_type = ENCAP_ETHERNET;
           else if ((octet1 == 0xff) && (octet2 == 0xff))
             encap_type = ENCAP_IPX;
           else if (((octet1 == 0x00) && (octet2 == 0x00)) ||
                    (((octet2 << 8) | octet1) == seq_control)) {
             proto_tree_add_item(tree, hf_ieee80211_mysterious_olpc_stuff, next_tvb, 0, 2, ENC_NA);
             next_tvb = tvb_new_subset_remaining(next_tvb, 2);
           }
         }
       }
 
       switch (encap_type) {
 
       case ENCAP_802_2:
         call_dissector(llc_handle, next_tvb, pinfo, tree);
         break;
 
       case ENCAP_ETHERNET:
         call_dissector(eth_withoutfcs_handle, next_tvb, pinfo, tree);
         break;
 
       case ENCAP_IPX:
         call_dissector(ipx_handle, next_tvb, pinfo, tree);
         break;
       }
       break;
 
     case EXTENSION_FRAME:
     {
       dissect_ieee80211_extension(fcf, next_tvb, pinfo, tree);
       break;
     }
   }
   pinfo->fragmented = save_fragmented;
