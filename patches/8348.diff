commit 5f3d02e8955b0b0eb62cf85eca1f56f55d64bd63
Author: Cristy <urban-warrior@imagemagick.org>
Date:   Thu May 17 20:38:41 2018 -0400

    Fix SchrÃ¶dinger's cat problem with clip / composite mask
    o Please enter the commit message for your changes. Lines starting

diff --git a/MagickCore/attribute.c b/MagickCore/attribute.c
index 432df0095..32ddfa062 100644
--- a/MagickCore/attribute.c
+++ b/MagickCore/attribute.c
@@ -194,334 +194,330 @@ MagickExport RectangleInfo GetImageBoundingBox(const Image *image,
     if (status == MagickFalse)
       continue;
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
 #  pragma omp critical (MagickCore_GetImageBoundingBox)
 #endif
     bounding_box=bounds;
     p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
     if (p == (const Quantum *) NULL)
       {
         status=MagickFalse;
         continue;
       }
     pixel=zero;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       GetPixelInfoPixel(image,p,&pixel);
       if ((x < bounding_box.x) &&
           (IsFuzzyEquivalencePixelInfo(&pixel,&target[0]) == MagickFalse))
         bounding_box.x=x;
       if ((x > (ssize_t) bounding_box.width) &&
           (IsFuzzyEquivalencePixelInfo(&pixel,&target[1]) == MagickFalse))
         bounding_box.width=(size_t) x;
       if ((y < bounding_box.y) &&
           (IsFuzzyEquivalencePixelInfo(&pixel,&target[0]) == MagickFalse))
         bounding_box.y=y;
       if ((y > (ssize_t) bounding_box.height) &&
           (IsFuzzyEquivalencePixelInfo(&pixel,&target[2]) == MagickFalse))
         bounding_box.height=(size_t) y;
       p+=GetPixelChannels(image);
     }
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
 #  pragma omp critical (MagickCore_GetImageBoundingBox)
 #endif
     {
       if (bounding_box.x < bounds.x)
         bounds.x=bounding_box.x;
       if (bounding_box.y < bounds.y)
         bounds.y=bounding_box.y;
       if (bounding_box.width > bounds.width)
         bounds.width=bounding_box.width;
       if (bounding_box.height > bounds.height)
         bounds.height=bounding_box.height;
     }
   }
   image_view=DestroyCacheView(image_view);
   if ((bounds.width == 0) && (bounds.height == 0))
     (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,
       "GeometryDoesNotContainImage","`%s'",image->filename);
   else
     {
       bounds.width-=(bounds.x-1);
       bounds.height-=(bounds.y-1);
     }
   return(bounds);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   G e t I m a g e D e p t h                                                 %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  GetImageDepth() returns the depth of a particular image channel.
 %
 %  The format of the GetImageDepth method is:
 %
 %      size_t GetImageDepth(const Image *image,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 MagickExport size_t GetImageDepth(const Image *image,ExceptionInfo *exception)
 {
   CacheView
     *image_view;
 
   MagickBooleanType
     status;
 
   register ssize_t
     i;
 
   size_t
     *current_depth,
     depth,
     number_threads;
 
   ssize_t
     y;
 
   /*
     Compute image depth.
   */
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);
   current_depth=(size_t *) AcquireQuantumMemory(number_threads,
     sizeof(*current_depth));
   if (current_depth == (size_t *) NULL)
     ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
   status=MagickTrue;
   for (i=0; i < (ssize_t) number_threads; i++)
     current_depth[i]=1;
   if ((image->storage_class == PseudoClass) &&
       (image->alpha_trait == UndefinedPixelTrait))
     {
       for (i=0; i < (ssize_t) image->colors; i++)
       {
         const int
           id = GetOpenMPThreadId();
 
         while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH)
         {
           MagickBooleanType
             atDepth;
 
           QuantumAny
             range;
 
           atDepth=MagickTrue;
           range=GetQuantumRange(current_depth[id]);
           if ((atDepth != MagickFalse) &&
               (GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
             if (IsPixelAtDepth(ClampToQuantum(image->colormap[i].red),range) == MagickFalse)
               atDepth=MagickFalse;
           if ((atDepth != MagickFalse) &&
               (GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
             if (IsPixelAtDepth(ClampToQuantum(image->colormap[i].green),range) == MagickFalse)
               atDepth=MagickFalse;
           if ((atDepth != MagickFalse) &&
               (GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
             if (IsPixelAtDepth(ClampToQuantum(image->colormap[i].blue),range) == MagickFalse)
               atDepth=MagickFalse;
           if ((atDepth != MagickFalse))
             break;
           current_depth[id]++;
         }
       }
       depth=current_depth[0];
       for (i=1; i < (ssize_t) number_threads; i++)
         if (depth < current_depth[i])
           depth=current_depth[i];
       current_depth=(size_t *) RelinquishMagickMemory(current_depth);
       return(depth);
     }
   image_view=AcquireVirtualCacheView(image,exception);
 #if !defined(MAGICKCORE_HDRI_SUPPORT)
   if ((1UL*QuantumRange) <= MaxMap)
     {
       size_t
         *depth_map;
 
       /*
         Scale pixels to desired (optimized with depth map).
       */
       depth_map=(size_t *) AcquireQuantumMemory(MaxMap+1,sizeof(*depth_map));
       if (depth_map == (size_t *) NULL)
         ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
       for (i=0; i <= (ssize_t) MaxMap; i++)
       {
         unsigned int
           depth;
 
         for (depth=1; depth < MAGICKCORE_QUANTUM_DEPTH; depth++)
         {
           Quantum
             pixel;
 
           QuantumAny
             range;
 
           range=GetQuantumRange(depth);
           pixel=(Quantum) i;
           if (pixel == ScaleAnyToQuantum(ScaleQuantumToAny(pixel,range),range))
             break;
         }
         depth_map[i]=depth;
       }
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
       #pragma omp parallel for schedule(static) shared(status) \
         magick_number_threads(image,image,image->rows,1)
 #endif
       for (y=0; y < (ssize_t) image->rows; y++)
       {
         const int
           id = GetOpenMPThreadId();
 
         register const Quantum
           *magick_restrict p;
 
         register ssize_t
           x;
 
         if (status == MagickFalse)
           continue;
         p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
         if (p == (const Quantum *) NULL)
           continue;
         for (x=0; x < (ssize_t) image->columns; x++)
         {
           register ssize_t
             i;
 
           for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
           {
             PixelChannel channel = GetPixelChannelChannel(image,i);
             PixelTrait traits = GetPixelChannelTraits(image,channel);
-            if ((traits == UndefinedPixelTrait) ||
-                (channel == IndexPixelChannel) ||
-                (channel == ReadMaskPixelChannel) ||
-                (channel == MetaPixelChannel))
+            if ((traits & UpdatePixelTrait) == 0)
               continue;
             if (depth_map[ScaleQuantumToMap(p[i])] > current_depth[id])
               current_depth[id]=depth_map[ScaleQuantumToMap(p[i])];
           }
           p+=GetPixelChannels(image);
         }
         if (current_depth[id] == MAGICKCORE_QUANTUM_DEPTH)
           status=MagickFalse;
       }
       image_view=DestroyCacheView(image_view);
       depth=current_depth[0];
       for (i=1; i < (ssize_t) number_threads; i++)
         if (depth < current_depth[i])
           depth=current_depth[i];
       depth_map=(size_t *) RelinquishMagickMemory(depth_map);
       current_depth=(size_t *) RelinquishMagickMemory(current_depth);
       return(depth);
     }
 #endif
   /*
     Compute pixel depth.
   */
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static) shared(status) \
     magick_number_threads(image,image,image->rows,1)
 #endif
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     const int
       id = GetOpenMPThreadId();
 
     register const Quantum
       *magick_restrict p;
 
     register ssize_t
       x;
 
     if (status == MagickFalse)
       continue;
     p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
     if (p == (const Quantum *) NULL)
       continue;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       register ssize_t
         i;
 
       for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
       {
         PixelChannel
           channel;
 
         PixelTrait
           traits;
 
         channel=GetPixelChannelChannel(image,i);
         traits=GetPixelChannelTraits(image,channel);
-        if ((traits == UndefinedPixelTrait) || (channel == IndexPixelChannel) ||
-            (channel == ReadMaskPixelChannel))
+        if ((traits & UpdatePixelTrait) == 0)
           continue;
         while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH)
         {
           QuantumAny
             range;
 
           range=GetQuantumRange(current_depth[id]);
           if (p[i] == ScaleAnyToQuantum(ScaleQuantumToAny(p[i],range),range))
             break;
           current_depth[id]++;
         }
       }
       p+=GetPixelChannels(image);
     }
     if (current_depth[id] == MAGICKCORE_QUANTUM_DEPTH)
       status=MagickFalse;
   }
   image_view=DestroyCacheView(image_view);
   depth=current_depth[0];
   for (i=1; i < (ssize_t) number_threads; i++)
     if (depth < current_depth[i])
       depth=current_depth[i];
   current_depth=(size_t *) RelinquishMagickMemory(current_depth);
   return(depth);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   G e t I m a g e Q u a n t u m D e p t h                                   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  GetImageQuantumDepth() returns the depth of the image rounded to a legal
 %  quantum depth: 8, 16, or 32.
 %
 %  The format of the GetImageQuantumDepth method is:
 %
 %      size_t GetImageQuantumDepth(const Image *image,
 %        const MagickBooleanType constrain)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o constrain: A value other than MagickFalse, constrains the depth to
 %      a maximum of MAGICKCORE_QUANTUM_DEPTH.
 %
 */
@@ -934,274 +930,271 @@ MagickExport MagickBooleanType IsImageOpaque(const Image *image,
   /*
     Determine if image is opaque.
   */
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   if (image->alpha_trait == UndefinedPixelTrait)
     return(MagickTrue);
   image_view=AcquireVirtualCacheView(image,exception);
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);
     if (p == (const Quantum *) NULL)
       break;
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       if (GetPixelAlpha(image,p) != OpaqueAlpha)
         break;
       p+=GetPixelChannels(image);
     }
     if (x < (ssize_t) image->columns)
       break;
   }
   image_view=DestroyCacheView(image_view);
   return(y < (ssize_t) image->rows ? MagickFalse : MagickTrue);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   S e t I m a g e D e p t h                                                 %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SetImageDepth() sets the depth of the image.
 %
 %  The format of the SetImageDepth method is:
 %
 %      MagickBooleanType SetImageDepth(Image *image,const size_t depth,
 %        ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o channel: the channel.
 %
 %    o depth: the image depth.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 MagickExport MagickBooleanType SetImageDepth(Image *image,
   const size_t depth,ExceptionInfo *exception)
 {
   CacheView
     *image_view;
 
   MagickBooleanType
     status;
 
   QuantumAny
     range;
 
   ssize_t
     y;
 
   assert(image != (Image *) NULL);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(image->signature == MagickCoreSignature);
   if (depth >= MAGICKCORE_QUANTUM_DEPTH)
     {
       image->depth=depth;
       return(MagickTrue);
     }
   range=GetQuantumRange(depth);
   if (image->storage_class == PseudoClass)
     {
       register ssize_t
         i;
 
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
       #pragma omp parallel for schedule(static) shared(status) \
         magick_number_threads(image,image,image->colors,1)
 #endif
       for (i=0; i < (ssize_t) image->colors; i++)
       {
         if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)
           image->colormap[i].red=(double) ScaleAnyToQuantum(ScaleQuantumToAny(
             ClampPixel(image->colormap[i].red),range),range);
         if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)
           image->colormap[i].green=(double) ScaleAnyToQuantum(ScaleQuantumToAny(
             ClampPixel(image->colormap[i].green),range),range);
         if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)
           image->colormap[i].blue=(double) ScaleAnyToQuantum(ScaleQuantumToAny(
             ClampPixel(image->colormap[i].blue),range),range);
         if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)
           image->colormap[i].alpha=(double) ScaleAnyToQuantum(ScaleQuantumToAny(
             ClampPixel(image->colormap[i].alpha),range),range);
       }
     }
   status=MagickTrue;
   image_view=AcquireAuthenticCacheView(image,exception);
 #if !defined(MAGICKCORE_HDRI_SUPPORT)
   if ((1UL*QuantumRange) <= MaxMap)
     {
       Quantum
         *depth_map;
 
       register ssize_t
         i;
 
       /*
         Scale pixels to desired (optimized with depth map).
       */
       depth_map=(Quantum *) AcquireQuantumMemory(MaxMap+1,sizeof(*depth_map));
       if (depth_map == (Quantum *) NULL)
         ThrowFatalException(ResourceLimitFatalError,"MemoryAllocationFailed");
       for (i=0; i <= (ssize_t) MaxMap; i++)
         depth_map[i]=ScaleAnyToQuantum(ScaleQuantumToAny((Quantum) i,range),
           range);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
       #pragma omp parallel for schedule(static) shared(status) \
         magick_number_threads(image,image,image->rows,1)
 #endif
       for (y=0; y < (ssize_t) image->rows; y++)
       {
         register ssize_t
           x;
 
         register Quantum
           *magick_restrict q;
 
         if (status == MagickFalse)
           continue;
         q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,
           exception);
         if (q == (Quantum *) NULL)
           {
             status=MagickFalse;
             continue;
           }
         for (x=0; x < (ssize_t) image->columns; x++)
         {
           register ssize_t
             i;
 
           for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
           {
             PixelChannel
               channel;
 
             PixelTrait
               traits;
 
             channel=GetPixelChannelChannel(image,i);
             traits=GetPixelChannelTraits(image,channel);
-            if ((traits == UndefinedPixelTrait) ||
-                (channel == IndexPixelChannel) ||
-                (channel == ReadMaskPixelChannel))
+            if ((traits & UpdatePixelTrait) == 0)
               continue;
             q[i]=depth_map[ScaleQuantumToMap(q[i])];
           }
           q+=GetPixelChannels(image);
         }
         if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
           {
             status=MagickFalse;
             continue;
           }
       }
       image_view=DestroyCacheView(image_view);
       depth_map=(Quantum *) RelinquishMagickMemory(depth_map);
       if (status != MagickFalse)
         image->depth=depth;
       return(status);
     }
 #endif
   /*
     Scale pixels to desired depth.
   */
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static) shared(status) \
     magick_number_threads(image,image,image->rows,1)
 #endif
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register ssize_t
       x;
 
     register Quantum
       *magick_restrict q;
 
     if (status == MagickFalse)
       continue;
     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
     if (q == (Quantum *) NULL)
       {
         status=MagickFalse;
         continue;
       }
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       register ssize_t
         i;
 
       for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
       {
         PixelChannel
           channel;
 
         PixelTrait
           traits;
 
         channel=GetPixelChannelChannel(image,i);
         traits=GetPixelChannelTraits(image,channel);
-        if ((traits == UndefinedPixelTrait) || (channel == IndexPixelChannel) ||
-            (channel == ReadMaskPixelChannel))
+        if ((traits & UpdatePixelTrait) == 0)
           continue;
         q[i]=ScaleAnyToQuantum(ScaleQuantumToAny(ClampPixel((MagickRealType)
           q[i]),range),range);
       }
       q+=GetPixelChannels(image);
     }
     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
       {
         status=MagickFalse;
         continue;
       }
   }
   image_view=DestroyCacheView(image_view);
   if (status != MagickFalse)
     image->depth=depth;
   return(status);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   S e t I m a g e T y p e                                                   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SetImageType() sets the type of image.  Choose from these types:
 %
 %        Bilevel        Grayscale       GrayscaleMatte
 %        Palette        PaletteMatte    TrueColor
 %        TrueColorMatte ColorSeparation ColorSeparationMatte
 %        OptimizeType
 %
 %  The format of the SetImageType method is:
 %
 %      MagickBooleanType SetImageType(Image *image,const ImageType type,
 %        ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o type: Image type.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
diff --git a/MagickCore/cache.c b/MagickCore/cache.c
index a036f8b2f..2a8f20ee9 100644
--- a/MagickCore/cache.c
+++ b/MagickCore/cache.c
@@ -5288,103 +5288,106 @@ MagickPrivate void SyncAuthenticOpenCLBuffer(const Image *image)
   assert(image != (const Image *) NULL);
   cache_info=(CacheInfo *) image->cache;
   CopyOpenCLBuffer(cache_info);
 }
 #endif
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   S y n c A u t h e n t i c P i x e l C a c h e N e x u s                   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SyncAuthenticPixelCacheNexus() saves the authentic image pixels to the
 %  in-memory or disk cache.  The method returns MagickTrue if the pixel region
 %  is synced, otherwise MagickFalse.
 %
 %  The format of the SyncAuthenticPixelCacheNexus() method is:
 %
 %      MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,
 %        NexusInfo *nexus_info,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o nexus_info: the cache nexus to sync.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 MagickPrivate MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,
   NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)
 {
   CacheInfo
     *magick_restrict cache_info;
 
   MagickBooleanType
     status;
 
   /*
     Transfer pixels to the cache.
   */
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->cache == (Cache) NULL)
     ThrowBinaryException(CacheError,"PixelCacheIsNotOpen",image->filename);
   cache_info=(CacheInfo *) image->cache;
   assert(cache_info->signature == MagickCoreSignature);
   if (cache_info->type == UndefinedCache)
     return(MagickFalse);
-  if ((image->write_mask != MagickFalse) &&
-      (ClipPixelCacheNexus(image,nexus_info,exception) == MagickFalse))
-    return(MagickFalse);
-  if ((image->composite_mask != MagickFalse) &&
-      (MaskPixelCacheNexus(image,nexus_info,exception) == MagickFalse))
-    return(MagickFalse);
+  if (image->mask_trait != UpdatePixelTrait)
+    {
+      if ((image->write_mask != MagickFalse) &&
+          (ClipPixelCacheNexus(image,nexus_info,exception) == MagickFalse))
+        return(MagickFalse);
+      if ((image->composite_mask != MagickFalse) &&
+          (MaskPixelCacheNexus(image,nexus_info,exception) == MagickFalse))
+        return(MagickFalse);
+    }
   if (nexus_info->authentic_pixel_cache != MagickFalse)
     {
       image->taint=MagickTrue;
       return(MagickTrue);
     }
   assert(cache_info->signature == MagickCoreSignature);
   status=WritePixelCachePixels(cache_info,nexus_info,exception);
   if ((cache_info->metacontent_extent != 0) &&
       (WritePixelCacheMetacontent(cache_info,nexus_info,exception) == MagickFalse))
     return(MagickFalse);
   if (status != MagickFalse)
     image->taint=MagickTrue;
   return(status);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 +   S y n c A u t h e n t i c P i x e l C a c h e                             %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SyncAuthenticPixelsCache() saves the authentic image pixels to the in-memory
 %  or disk cache.  The method returns MagickTrue if the pixel region is synced,
 %  otherwise MagickFalse.
 %
 %  The format of the SyncAuthenticPixelsCache() method is:
 %
 %      MagickBooleanType SyncAuthenticPixelsCache(Image *image,
 %        ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
diff --git a/MagickCore/channel.c b/MagickCore/channel.c
index a5955833f..c2aafb738 100644
--- a/MagickCore/channel.c
+++ b/MagickCore/channel.c
@@ -194,288 +194,293 @@ static MagickBooleanType ChannelImage(Image *destination_image,
 MagickExport Image *ChannelFxImage(const Image *image,const char *expression,
   ExceptionInfo *exception)
 {
 #define ChannelFxImageTag  "ChannelFx/Image"
 
   ChannelFx
     channel_op;
 
   ChannelType
     channel_mask;
 
   char
     token[MagickPathExtent];
 
   const char
     *p;
 
   const Image
     *source_image;
 
   double
     pixel;
 
   Image
     *destination_image;
 
   MagickBooleanType
     status;
 
   PixelChannel
     source_channel,
     destination_channel;
 
   ssize_t
     channels;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   source_image=image;
   destination_image=CloneImage(source_image,0,0,MagickTrue,exception);
   if (destination_image == (Image *) NULL)
     return((Image *) NULL);
   if (expression == (const char *) NULL)
     return(destination_image);
   status=SetImageStorageClass(destination_image,DirectClass,exception);
   if (status == MagickFalse)
     {
       destination_image=GetLastImageInList(destination_image);
       return((Image *) NULL);
     }
   destination_channel=RedPixelChannel;
   channel_mask=UndefinedChannel;
   pixel=0.0;
   p=(char *) expression;
   GetNextToken(p,&p,MagickPathExtent,token);
   channel_op=ExtractChannelOp;
   for (channels=0; *token != '\0'; )
   {
     ssize_t
       i;
 
     /*
       Interpret channel expression.
     */
     switch (*token)
     {
       case ',':
       {
         GetNextToken(p,&p,MagickPathExtent,token);
         break;
       }
       case '|':
       {
         if (GetNextImageInList(source_image) != (Image *) NULL)
           source_image=GetNextImageInList(source_image);
         else
           source_image=GetFirstImageInList(source_image);
         GetNextToken(p,&p,MagickPathExtent,token);
         break;
       }
       case ';':
       {
         Image
           *canvas;
 
         (void) SetPixelChannelMask(destination_image,channel_mask);
         if ((channel_op == ExtractChannelOp) && (channels == 1))
           {
             (void) SetPixelMetaChannels(destination_image,0,exception);
             (void) SetImageColorspace(destination_image,GRAYColorspace,
               exception);
           }
         canvas=CloneImage(source_image,0,0,MagickTrue,exception);
         if (canvas == (Image *) NULL)
           {
             destination_image=DestroyImageList(destination_image);
             return(destination_image);
           }
         AppendImageToList(&destination_image,canvas);
         destination_image=GetLastImageInList(destination_image);
         status=SetImageStorageClass(destination_image,DirectClass,exception);
         if (status == MagickFalse)
           {
             destination_image=GetLastImageInList(destination_image);
             return((Image *) NULL);
           }
         GetNextToken(p,&p,MagickPathExtent,token);
         channels=0;
         destination_channel=RedPixelChannel;
         channel_mask=UndefinedChannel;
         break;
       }
       default:
         break;
     }
     i=ParsePixelChannelOption(token);
     if (i < 0)
       {
         (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
           "UnrecognizedChannelType","`%s'",token);
         destination_image=DestroyImageList(destination_image);
         return(destination_image);
       }
     source_channel=(PixelChannel) i;
     channel_op=ExtractChannelOp;
     GetNextToken(p,&p,MagickPathExtent,token);
     if (*token == '<')
       {
         channel_op=ExchangeChannelOp;
         GetNextToken(p,&p,MagickPathExtent,token);
       }
     if (*token == '=')
       {
         if (channel_op != ExchangeChannelOp)
           channel_op=AssignChannelOp;
         GetNextToken(p,&p,MagickPathExtent,token);
       }
     if (*token == '>')
       {
         if (channel_op != ExchangeChannelOp)
           channel_op=TransferChannelOp;
         GetNextToken(p,&p,MagickPathExtent,token);
       }
     switch (channel_op)
     {
       case AssignChannelOp:
       case ExchangeChannelOp:
       case TransferChannelOp:
       {
         if (channel_op == AssignChannelOp)
           pixel=StringToDoubleInterval(token,(double) QuantumRange+1.0);
         else
           {
             i=ParsePixelChannelOption(token);
             if (i < 0)
               {
                 (void) ThrowMagickException(exception,GetMagickModule(),
                   OptionError,"UnrecognizedChannelType","`%s'",token);
                 destination_image=DestroyImageList(destination_image);
                 return(destination_image);
               }
           }
         destination_channel=(PixelChannel) i;
         if (i >= (ssize_t) GetPixelChannels(destination_image))
           (void) SetPixelMetaChannels(destination_image,(size_t) (
             destination_channel-GetPixelChannels(destination_image)+1),
             exception);
         if (image->colorspace != UndefinedColorspace)
           switch (destination_channel)
           {
             case RedPixelChannel:
             case GreenPixelChannel:
             case BluePixelChannel:
             case BlackPixelChannel:
             case IndexPixelChannel:
               break;
             case AlphaPixelChannel:
             {
               destination_image->alpha_trait=BlendPixelTrait;
               break;
             }
+            case CompositeMaskPixelChannel:
+            {
+              destination_image->composite_mask=MagickTrue;
+              break;
+            }
             case ReadMaskPixelChannel:
             {
               destination_image->read_mask=MagickTrue;
               break;
             }
             case WriteMaskPixelChannel:
             {
               destination_image->write_mask=MagickTrue;
               break;
             }
             case MetaPixelChannel:
             default:
             {
               (void) SetPixelMetaChannels(destination_image,(size_t) (
                 destination_channel-GetPixelChannels(destination_image)+1),
                 exception);
               break;
             }
           }
         channel_mask=(ChannelType) (channel_mask | ParseChannelOption(token));
         if (((channels >= 1)  || (destination_channel >= 1)) &&
             (IsGrayColorspace(destination_image->colorspace) != MagickFalse))
           (void) SetImageColorspace(destination_image,sRGBColorspace,exception);
         GetNextToken(p,&p,MagickPathExtent,token);
         break;
       }
       default:
         break;
     }
     status=ChannelImage(destination_image,destination_channel,channel_op,
       source_image,source_channel,ClampToQuantum(pixel),exception);
     if (status == MagickFalse)
       {
         destination_image=DestroyImageList(destination_image);
         break;
       }
     channels++;
     if (channel_op == ExchangeChannelOp)
       {
         status=ChannelImage(destination_image,source_channel,channel_op,
           source_image,destination_channel,ClampToQuantum(pixel),exception);
         if (status == MagickFalse)
           {
             destination_image=DestroyImageList(destination_image);
             break;
           }
         channels++;
       }
     switch (channel_op)
     {
       case ExtractChannelOp:
       {
         channel_mask=(ChannelType) (channel_mask | (1 << destination_channel));
         destination_channel=(PixelChannel) (destination_channel+1);
         break;
       }
       default:
         break;
     }
     status=SetImageProgress(source_image,ChannelFxImageTag,p-expression,
       strlen(expression));
     if (status == MagickFalse)
       break;
   }
   (void) SetPixelChannelMask(destination_image,channel_mask);
   if ((channel_op == ExtractChannelOp) && (channels == 1))
     {
       (void) SetPixelMetaChannels(destination_image,0,exception);
       (void) SetImageColorspace(destination_image,GRAYColorspace,exception);
     }
   return(GetFirstImageInList(destination_image));
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %     C o m b i n e I m a g e s                                               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  CombineImages() combines one or more images into a single image.  The
 %  grayscale value of the pixels of each image in the sequence is assigned in
 %  order to the specified channels of the combined image.   The typical
 %  ordering would be image 1 => Red, 2 => Green, 3 => Blue, etc.
 %
 %  The format of the CombineImages method is:
 %
 %      Image *CombineImages(const Image *images,const ColorspaceType colorspace,
 %        ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o images: the image sequence.
 %
 %    o colorspace: the image colorspace.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
diff --git a/MagickCore/image.c b/MagickCore/image.c
index 21be905c5..2b2bde822 100644
--- a/MagickCore/image.c
+++ b/MagickCore/image.c
@@ -715,222 +715,224 @@ MagickExport MagickBooleanType ClipImagePath(Image *image,const char *pathname,
   assert(image != (const Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(pathname != NULL);
   property=AcquireString(pathname);
   (void) FormatLocaleString(property,MagickPathExtent,"8BIM:1999,2998:%s",
     pathname);
   value=GetImageProperty(image,property,exception);
   property=DestroyString(property);
   if (value == (const char *) NULL)
     {
       ThrowFileException(exception,OptionError,"NoClipPathDefined",
         image->filename);
       return(MagickFalse);
     }
   image_info=AcquireImageInfo();
   (void) CopyMagickString(image_info->filename,image->filename,
      MagickPathExtent);
   (void) ConcatenateMagickString(image_info->filename,pathname,
     MagickPathExtent);
   clip_mask=BlobToImage(image_info,value,strlen(value),exception);
   image_info=DestroyImageInfo(image_info);
   if (clip_mask == (Image *) NULL)
     return(MagickFalse);
   if (clip_mask->storage_class == PseudoClass)
     {
       (void) SyncImage(clip_mask,exception);
       if (SetImageStorageClass(clip_mask,DirectClass,exception) == MagickFalse)
         return(MagickFalse);
     }
   if (inside == MagickFalse)
     (void) NegateImage(clip_mask,MagickFalse,exception);
   (void) FormatLocaleString(clip_mask->magick_filename,MagickPathExtent,
     "8BIM:1999,2998:%s\nPS",pathname);
   (void) SetImageMask(image,WritePixelMask,clip_mask,exception);
   clip_mask=DestroyImage(clip_mask);
   return(MagickTrue);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   C l o n e I m a g e                                                       %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  CloneImage() copies an image and returns the copy as a new image object.
 %
 %  If the specified columns and rows is 0, an exact copy of the image is
 %  returned, otherwise the pixel data is undefined and must be initialized
 %  with the QueueAuthenticPixels() and SyncAuthenticPixels() methods.  On
 %  failure, a NULL image is returned and exception describes the reason for the
 %  failure.
 %
 %  The format of the CloneImage method is:
 %
 %      Image *CloneImage(const Image *image,const size_t columns,
 %        const size_t rows,const MagickBooleanType orphan,
 %        ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o columns: the number of columns in the cloned image.
 %
 %    o rows: the number of rows in the cloned image.
 %
 %    o detach:  With a value other than 0, the cloned image is detached from
 %      its parent I/O stream.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 MagickExport Image *CloneImage(const Image *image,const size_t columns,
   const size_t rows,const MagickBooleanType detach,ExceptionInfo *exception)
 {
   Image
     *clone_image;
 
   double
     scale;
 
   size_t
     length;
 
   /*
     Clone the image.
   */
   assert(image != (const Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
   assert(exception != (ExceptionInfo *) NULL);
   assert(exception->signature == MagickCoreSignature);
   if ((image->columns == 0) || (image->rows == 0))
     {
       (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError,
         "NegativeOrZeroImageSize","`%s'",image->filename);
       return((Image *) NULL);
     }
   clone_image=(Image *) AcquireCriticalMemory(sizeof(*clone_image));
   (void) memset(clone_image,0,sizeof(*clone_image));
   clone_image->signature=MagickCoreSignature;
   clone_image->storage_class=image->storage_class;
   clone_image->number_channels=image->number_channels;
   clone_image->number_meta_channels=image->number_meta_channels;
   clone_image->metacontent_extent=image->metacontent_extent;
   clone_image->colorspace=image->colorspace;
   clone_image->read_mask=image->read_mask;
   clone_image->write_mask=image->write_mask;
+  clone_image->composite_mask=image->composite_mask;
   clone_image->alpha_trait=image->alpha_trait;
+  clone_image->mask_trait=image->mask_trait;
   clone_image->columns=image->columns;
   clone_image->rows=image->rows;
   clone_image->dither=image->dither;
   clone_image->image_info=CloneImageInfo(image->image_info);
   (void) CloneImageProfiles(clone_image,image);
   (void) CloneImageProperties(clone_image,image);
   (void) CloneImageArtifacts(clone_image,image);
   GetTimerInfo(&clone_image->timer);
   if (image->ascii85 != (void *) NULL)
     Ascii85Initialize(clone_image);
   clone_image->magick_columns=image->magick_columns;
   clone_image->magick_rows=image->magick_rows;
   clone_image->type=image->type;
   clone_image->channel_mask=image->channel_mask;
   clone_image->channel_map=ClonePixelChannelMap(image->channel_map);
   (void) CopyMagickString(clone_image->magick_filename,image->magick_filename,
     MagickPathExtent);
   (void) CopyMagickString(clone_image->magick,image->magick,MagickPathExtent);
   (void) CopyMagickString(clone_image->filename,image->filename,
     MagickPathExtent);
   clone_image->progress_monitor=image->progress_monitor;
   clone_image->client_data=image->client_data;
   clone_image->reference_count=1;
   clone_image->next=image->next;
   clone_image->previous=image->previous;
   clone_image->list=NewImageList();
   if (detach == MagickFalse)
     clone_image->blob=ReferenceBlob(image->blob);
   else
     {
       clone_image->next=NewImageList();
       clone_image->previous=NewImageList();
       clone_image->blob=CloneBlobInfo((BlobInfo *) NULL);
     }
   clone_image->ping=image->ping;
   clone_image->debug=IsEventLogging();
   clone_image->semaphore=AcquireSemaphoreInfo();
   if (image->colormap != (PixelInfo *) NULL)
     {
       /*
         Allocate and copy the image colormap.
       */
       clone_image->colors=image->colors;
       length=(size_t) image->colors;
       clone_image->colormap=(PixelInfo *) AcquireQuantumMemory(length+1,
         sizeof(*clone_image->colormap));
       if (clone_image->colormap == (PixelInfo *) NULL)
         {
           clone_image=DestroyImage(clone_image);
           ThrowImageException(ResourceLimitError,"MemoryAllocationFailed");
         }
       (void) memcpy(clone_image->colormap,image->colormap,length*
         sizeof(*clone_image->colormap));
     }
   if ((columns == 0) || (rows == 0))
     {
       if (image->montage != (char *) NULL)
         (void) CloneString(&clone_image->montage,image->montage);
       if (image->directory != (char *) NULL)
         (void) CloneString(&clone_image->directory,image->directory);
       clone_image->cache=ReferencePixelCache(image->cache);
       return(clone_image);
     }
   scale=1.0;
   if (image->columns != 0)
     scale=(double) columns/(double) image->columns;
   clone_image->page.width=(size_t) floor(scale*image->page.width+0.5);
   clone_image->page.x=(ssize_t) ceil(scale*image->page.x-0.5);
   clone_image->tile_offset.x=(ssize_t) ceil(scale*image->tile_offset.x-0.5);
   scale=1.0;
   if (image->rows != 0)
     scale=(double) rows/(double) image->rows;
   clone_image->page.height=(size_t) floor(scale*image->page.height+0.5);
   clone_image->page.y=(ssize_t) ceil(scale*image->page.y-0.5);
   clone_image->tile_offset.y=(ssize_t) ceil(scale*image->tile_offset.y-0.5);
   clone_image->cache=ClonePixelCache(image->cache);
   if (SetImageExtent(clone_image,columns,rows,exception) == MagickFalse)
     clone_image=DestroyImage(clone_image);
   return(clone_image);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   C l o n e I m a g e I n f o                                               %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  CloneImageInfo() makes a copy of the given image info structure.  If
 %  NULL is specified, a new image info structure is created initialized to
 %  default values.
 %
 %  The format of the CloneImageInfo method is:
 %
 %      ImageInfo *CloneImageInfo(const ImageInfo *image_info)
 %
 %  A description of each parameter follows:
 %
 %    o image_info: the image info.
 %
 */
@@ -3118,295 +3120,299 @@ MagickExport void SetImageInfoFile(ImageInfo *image_info,FILE *file)
 {
   assert(image_info != (ImageInfo *) NULL);
   assert(image_info->signature == MagickCoreSignature);
   if (image_info->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",
       image_info->filename);
   image_info->file=file;
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   S e t I m a g e M a s k                                                   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SetImageMask() associates a mask with the image.  The mask must be the same
 %  dimensions as the image.
 %
 %  The format of the SetImageMask method is:
 %
 %      MagickBooleanType SetImageMask(Image *image,const PixelMask type,
 %        const Image *mask,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o type: the mask type, ReadPixelMask or WritePixelMask.
 %
 %    o mask: the image mask.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 MagickExport MagickBooleanType SetImageMask(Image *image,const PixelMask type,
   const Image *mask,ExceptionInfo *exception)
 {
   CacheView
     *mask_view,
     *image_view;
 
   MagickBooleanType
     status;
 
   ssize_t
     y;
 
   /*
     Set image mask.
   */
   assert(image != (Image *) NULL);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(image->signature == MagickCoreSignature);
   if (mask == (const Image *) NULL)
     {
       switch (type)
       {
         case ReadPixelMask: image->read_mask=MagickFalse; break;
         case WritePixelMask: image->write_mask=MagickFalse; break;
         default: image->composite_mask=MagickFalse; break;
       }
       return(SyncImagePixelCache(image,exception));
     }
   switch (type)
   {
     case ReadPixelMask: image->read_mask=MagickTrue; break;
     case WritePixelMask: image->write_mask=MagickTrue; break;
     default: image->composite_mask=MagickTrue; break;
   }
   if (SyncImagePixelCache(image,exception) == MagickFalse)
     return(MagickFalse);
   status=MagickTrue;
+  image->mask_trait=UpdatePixelTrait;
   mask_view=AcquireVirtualCacheView(mask,exception);
   image_view=AcquireAuthenticCacheView(image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static) shared(status) \
     magick_number_threads(mask,image,image->rows,1)
 #endif
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register const Quantum
       *magick_restrict p;
 
     register Quantum
       *magick_restrict q;
 
     register ssize_t
       x;
 
     if (status == MagickFalse)
       continue;
     p=GetCacheViewVirtualPixels(mask_view,0,y,mask->columns,1,exception);
     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))
       {
         status=MagickFalse;
         continue;
       }
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       MagickRealType
         intensity;
 
       intensity=0.0;
       if ((x < (ssize_t) mask->columns) && (y < (ssize_t) mask->rows))
         intensity=GetPixelIntensity(mask,p);
       switch (type)
       {
         case ReadPixelMask:
         {
           SetPixelReadMask(image,ClampToQuantum(intensity),q);
           break;
         }
         case WritePixelMask:
         {
           SetPixelWriteMask(image,ClampToQuantum(intensity),q);
           break;
         }
         default:
         {
           SetPixelCompositeMask(image,ClampToQuantum(intensity),q);
           break;
         }
       }
       p+=GetPixelChannels(mask);
       q+=GetPixelChannels(image);
     }
     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
       status=MagickFalse;
   }
+  image->mask_trait=UndefinedPixelTrait;
   mask_view=DestroyCacheView(mask_view);
   image_view=DestroyCacheView(image_view);
   return(status);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   S e t I m a g e R e g i o n M a s k                                       %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SetImageRegionMask() associates a mask with the image as defined by the
 %  specified region.
 %
 %  The format of the SetImageRegionMask method is:
 %
 %      MagickBooleanType SetImageRegionMask(Image *image,const PixelMask type,
 %        const RectangleInfo *region,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o type: the mask type, ReadPixelMask or WritePixelMask.
 %
 %    o geometry: the mask region.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
 MagickExport MagickBooleanType SetImageRegionMask(Image *image,
   const PixelMask type,const RectangleInfo *region,ExceptionInfo *exception)
 {
   CacheView
     *image_view;
 
   MagickBooleanType
     status;
 
   ssize_t
     y;
 
   /*
     Set image mask as defined by the region.
   */
   assert(image != (Image *) NULL);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(TraceEvent,GetMagickModule(),"...");
   assert(image->signature == MagickCoreSignature);
   if (region == (const RectangleInfo *) NULL)
     {
       switch (type)
       {
         case ReadPixelMask: image->read_mask=MagickFalse; break;
         case WritePixelMask: image->write_mask=MagickFalse; break;
         default: image->composite_mask=MagickFalse; break;
       }
       return(SyncImagePixelCache(image,exception));
     }
   switch (type)
   {
     case ReadPixelMask: image->read_mask=MagickTrue; break;
     case WritePixelMask: image->write_mask=MagickTrue; break;
     default: image->composite_mask=MagickTrue; break;
   }
-  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
+  if (SyncImagePixelCache(image,exception) == MagickFalse)
     return(MagickFalse);
   status=MagickTrue;
+  image->mask_trait=UpdatePixelTrait;
   image_view=AcquireAuthenticCacheView(image,exception);
 #if defined(MAGICKCORE_OPENMP_SUPPORT)
   #pragma omp parallel for schedule(static) shared(status) \
     magick_number_threads(image,image,image->rows,1)
 #endif
   for (y=0; y < (ssize_t) image->rows; y++)
   {
     register Quantum
       *magick_restrict q;
 
     register ssize_t
       x;
 
     if (status == MagickFalse)
       continue;
     q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
     if (q == (Quantum *) NULL)
       {
         status=MagickFalse;
         continue;
       }
     for (x=0; x < (ssize_t) image->columns; x++)
     {
       Quantum
         pixel;
 
       pixel=(Quantum) 0;
       if (((x >= region->x) && (x < (region->x+(ssize_t) region->width))) &&
           ((y >= region->y) && (y < (region->y+(ssize_t) region->height))))
         pixel=QuantumRange;
       switch (type)
       {
         case ReadPixelMask:
         {
           SetPixelReadMask(image,pixel,q);
           break;
         }
         case WritePixelMask:
         {
           SetPixelWriteMask(image,pixel,q);
           break;
         }
         default:
         {
           SetPixelCompositeMask(image,pixel,q);
           break;
         }
       }
       q+=GetPixelChannels(image);
     }
     if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
       status=MagickFalse;
   }
+  image->mask_trait=UndefinedPixelTrait;
   image_view=DestroyCacheView(image_view);
   return(status);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   S e t I m a g e V i r t u a l P i x e l M e t h o d                       %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SetImageVirtualPixelMethod() sets the "virtual pixels" method for the
 %  image and returns the previous setting.  A virtual pixel is any pixel access
 %  that is outside the boundaries of the image cache.
 %
 %  The format of the SetImageVirtualPixelMethod() method is:
 %
 %      VirtualPixelMethod SetImageVirtualPixelMethod(Image *image,
 %        const VirtualPixelMethod virtual_pixel_method,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o virtual_pixel_method: choose the type of virtual pixel.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
diff --git a/MagickCore/image.h b/MagickCore/image.h
index 1ef596baa..62a56a21d 100644
--- a/MagickCore/image.h
+++ b/MagickCore/image.h
@@ -151,218 +151,221 @@ typedef struct _ChromaticityInfo
 struct _Image
 {
   ClassType
     storage_class;
 
   ColorspaceType
     colorspace;         /* colorspace of image data */
 
   CompressionType
     compression;        /* compression of image when read/write */
 
   size_t
     quality;            /* compression quality setting, meaning varies */
 
   OrientationType
     orientation;        /* photo orientation of image */
 
   MagickBooleanType
     taint;              /* has image been modified since reading */
 
   size_t
     columns,            /* physical size of image */
     rows,
     depth,              /* depth of image on read/write */
     colors;             /* Size of color table, or actual color count */
                         /* Only valid if image is not DirectClass */
 
   PixelInfo
     *colormap,
     alpha_color,        /* deprecated */
     background_color,   /* current background color attribute */
     border_color,       /* current bordercolor attribute */
     transparent_color;  /* color for 'transparent' color index in GIF */
 
   double
     gamma;
 
   ChromaticityInfo
     chromaticity;
 
   RenderingIntent
     rendering_intent;
 
   void
     *profiles;
 
   ResolutionType
     units;          /* resolution/density  ppi or ppc */
 
   char
     *montage,
     *directory,
     *geometry;
 
   ssize_t
     offset;         /* ??? */
 
   PointInfo
     resolution;     /* image resolution/density */
 
   RectangleInfo
     page,           /* virtual canvas size and offset of image */
     extract_info;
 
   double
     fuzz;           /* current color fuzz attribute - move to image_info */
 
   FilterType
     filter;         /* resize/distort filter to apply */
 
   PixelIntensityMethod
     intensity;      /* method to generate an intensity value from a pixel */
 
   InterlaceType
     interlace;
 
   EndianType
     endian;         /* raw data integer ordering on read/write */
 
   GravityType
     gravity;        /* Gravity attribute for positioning in image */
 
   CompositeOperator
     compose;        /* alpha composition method for layered images */
 
   DisposeType
     dispose;        /* GIF animation disposal method */
 
   size_t
     scene,          /* index of image in multi-image file */
     delay,          /* Animation delay time */
     duration;       /* Total animation duration sum(delay*iterations) */
 
   ssize_t
     ticks_per_second;  /* units for delay time, default 100 for GIF */
 
   size_t
     iterations,        /* number of interations for GIF animations */
     total_colors;
 
   ssize_t
     start_loop;        /* ??? */
 
   PixelInterpolateMethod
     interpolate;       /* Interpolation of color for between pixel lookups */
 
   MagickBooleanType
     black_point_compensation;
 
   RectangleInfo
     tile_offset;
 
   ImageType
     type;
 
   MagickBooleanType
     dither;            /* dithering on/off */
 
   MagickSizeType
     extent;            /* Size of image read from disk */
 
   MagickBooleanType
     ping;              /* no image data read, just attributes */
 
   MagickBooleanType
     read_mask,
     write_mask;
 
   PixelTrait
     alpha_trait;       /* is transparency channel defined and active */
 
   size_t
     number_channels,
     number_meta_channels,
     metacontent_extent;
 
   ChannelType
     channel_mask;
 
   PixelChannelMap
     *channel_map;
 
   void
     *cache;
 
   ErrorInfo
     error;
 
   TimerInfo
     timer;
 
   MagickProgressMonitor
     progress_monitor;
 
   void
     *client_data;
 
   Ascii85Info
     *ascii85;
 
   ProfileInfo
     *generic_profile;
 
   void
     *properties,       /* general settings, to save with image */
     *artifacts;        /* general operational/coder settings, not saved */
 
   char
     filename[MagickPathExtent],        /* images input filename */
     magick_filename[MagickPathExtent], /* given image filename (with read mods) */
     magick[MagickPathExtent];          /* images file format (file magic) */
 
   size_t
     magick_columns,     /* size of image when read/created */
     magick_rows;
 
   BlobInfo
     *blob;             /* image file as in-memory string of 'extent' */
 
   time_t
     timestamp;
 
   MagickBooleanType
     debug;             /* debug output attribute */
 
   volatile ssize_t
     reference_count;   /* image data sharing memory management */
 
   SemaphoreInfo
     *semaphore;
 
   struct _ImageInfo
     *image_info;       /* (Optional) Image belongs to this ImageInfo 'list'
                         * For access to 'global options' when no per-image
                         * attribute, properity, or artifact has been set.
                         */
 
   struct _Image
     *list,             /* Undo/Redo image processing list (for display) */
     *previous,         /* Image list links */
     *next;
 
   size_t
     signature;
 
   PixelInfo
     matte_color;        /* current mattecolor attribute */
 
   MagickBooleanType
     composite_mask;
+
+  PixelTrait
+    mask_trait;       /* apply the clip or composite mask */
 };
 
 /*
   ImageInfo structure:
     Stores an image list, as well as all global settings used by all images
     held, -- unless overridden for that specific image.  See SyncImagesettings()
     which maps any global setting that always overrides specific image settings.
 */
diff --git a/MagickCore/pixel.c b/MagickCore/pixel.c
index dd55ce52f..f74170465 100644
--- a/MagickCore/pixel.c
+++ b/MagickCore/pixel.c
@@ -6169,101 +6169,106 @@ MagickExport MagickBooleanType IsFuzzyEquivalencePixelInfo(const PixelInfo *p,
 static void LogPixelChannels(const Image *image)
 {
   register ssize_t
     i;
 
   (void) LogMagickEvent(PixelEvent,GetMagickModule(),"%s[%08x]",
     image->filename,image->channel_mask);
   for (i=0; i < (ssize_t) image->number_channels; i++)
   {
     char
       channel_name[MagickPathExtent],
       traits[MagickPathExtent];
 
     const char
       *name;
 
     PixelChannel
       channel;
 
     channel=GetPixelChannelChannel(image,i);
     switch (channel)
     {
       case RedPixelChannel:
       {
         name="red";
         if (image->colorspace == CMYKColorspace)
           name="cyan";
         if ((image->colorspace == LinearGRAYColorspace) ||
             (image->colorspace == GRAYColorspace))
           name="gray";
         break;
       }
       case GreenPixelChannel:
       {
         name="green";
         if (image->colorspace == CMYKColorspace)
           name="magenta";
         break;
       }
       case BluePixelChannel:
       {
         name="blue";
         if (image->colorspace == CMYKColorspace)
           name="yellow";
         break;
       }
       case BlackPixelChannel:
       {
         name="black";
         if (image->storage_class == PseudoClass)
           name="index";
         break;
       }
       case IndexPixelChannel:
       {
         name="index";
         break;
       }
       case AlphaPixelChannel:
       {
         name="alpha";
         break;
       }
       case ReadMaskPixelChannel:
       {
         name="read-mask";
         break;
       }
       case WriteMaskPixelChannel:
       {
         name="write-mask";
         break;
       }
+      case CompositeMaskPixelChannel:
+      {
+        name="composite-mask";
+        break;
+      }
       case MetaPixelChannel:
       {
         name="meta";
         break;
       }
       default:
         name="undefined";
     }
     if (image->colorspace ==  UndefinedColorspace)
       {
         (void) FormatLocaleString(channel_name,MagickPathExtent,"%.20g",
           (double) channel);
         name=(const char *) channel_name;
       }
     *traits='\0';
     if ((GetPixelChannelTraits(image,channel) & UpdatePixelTrait) != 0)
       (void) ConcatenateMagickString(traits,"update,",MagickPathExtent);
     if ((GetPixelChannelTraits(image,channel) & BlendPixelTrait) != 0)
       (void) ConcatenateMagickString(traits,"blend,",MagickPathExtent);
     if ((GetPixelChannelTraits(image,channel) & CopyPixelTrait) != 0)
       (void) ConcatenateMagickString(traits,"copy,",MagickPathExtent);
     if (*traits == '\0')
       (void) ConcatenateMagickString(traits,"undefined,",MagickPathExtent);
     traits[strlen(traits)-1]='\0';
     (void) LogMagickEvent(PixelEvent,GetMagickModule(),"  %.20g: %s (%s)",
       (double) i,name,traits);
   }
 }
@@ -6271,82 +6276,84 @@ static void LogPixelChannels(const Image *image)
 MagickExport ChannelType SetPixelChannelMask(Image *image,
   const ChannelType channel_mask)
 {
 #define GetChannelBit(mask,bit)  (((size_t) (mask) >> (size_t) (bit)) & 0x01)
 
   ChannelType
     mask;
 
   register ssize_t
     i;
 
   assert(image != (Image *) NULL);
   assert(image->signature == MagickCoreSignature);
   if (image->debug != MagickFalse)
     (void) LogMagickEvent(PixelEvent,GetMagickModule(),"%s[%08x]",
       image->filename,channel_mask);
   mask=image->channel_mask;
   image->channel_mask=channel_mask;
   for (i=0; i < (ssize_t) GetPixelChannels(image); i++)
   {
     PixelChannel channel = GetPixelChannelChannel(image,i);
     if (GetChannelBit(channel_mask,channel) == 0)
       {
         SetPixelChannelTraits(image,channel,CopyPixelTrait);
         continue;
       }
     if (channel == AlphaPixelChannel)
       {
         if ((image->alpha_trait & CopyPixelTrait) != 0)
           {
             SetPixelChannelTraits(image,channel,CopyPixelTrait);
             continue;
           }
         SetPixelChannelTraits(image,channel,UpdatePixelTrait);
         continue;
       }
     if (image->alpha_trait != UndefinedPixelTrait)
       {
         SetPixelChannelTraits(image,channel,(const PixelTrait)
           (UpdatePixelTrait | BlendPixelTrait));
         continue;
       }
     SetPixelChannelTraits(image,channel,UpdatePixelTrait);
   }
   if (image->storage_class == PseudoClass)
     SetPixelChannelTraits(image,IndexPixelChannel,CopyPixelTrait);
   if (image->read_mask != MagickFalse)
     SetPixelChannelTraits(image,ReadMaskPixelChannel,CopyPixelTrait);
   if (image->write_mask != MagickFalse)
     SetPixelChannelTraits(image,WriteMaskPixelChannel,CopyPixelTrait);
+  if (image->composite_mask != MagickFalse)
+    SetPixelChannelTraits(image,CompositeMaskPixelChannel,CopyPixelTrait);
   if (image->debug != MagickFalse)
     LogPixelChannels(image);
   return(mask);
 }
 
 /*
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %   S e t P i x e l M e t a C h a n n e l s                                   %
 %                                                                             %
 %                                                                             %
 %                                                                             %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 %  SetPixelMetaChannels() sets the image meta channels.
 %
 %  The format of the SetPixelMetaChannels method is:
 %
 %      MagickBooleanType SetPixelMetaChannels(Image *image,
 %        const size_t number_meta_channels,ExceptionInfo *exception)
 %
 %  A description of each parameter follows:
 %
 %    o image: the image.
 %
 %    o number_meta_channels:  the number of meta channels.
 %
 %    o exception: return any errors or warnings in this structure.
 %
 */
