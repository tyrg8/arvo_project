commit b7437c9e4923906e9b3f3860a0c8a8289cff0a91
Author: David Anderson <davea42@linuxmail.org>
Date:   Mon Jun 19 11:13:56 2023 -0700

    Vulnerability DW202306-010 ossfuzz id: 59950.
    Now we check for bad augmentation data
    (like field lengths) where checking was
    inadequate.
            modified:   src/lib/libdwarf/dwarf_frame.c
            modified:   src/lib/libdwarf/dwarf_frame2.c

diff --git a/src/lib/libdwarf/dwarf_frame.c b/src/lib/libdwarf/dwarf_frame.c
index 375d6cdc..44e105ce 100644
--- a/src/lib/libdwarf/dwarf_frame.c
+++ b/src/lib/libdwarf/dwarf_frame.c
@@ -322,1569 +322,1572 @@ int
 _dwarf_exec_frame_instr(Dwarf_Bool make_instr,
     Dwarf_Bool search_pc,
     Dwarf_Addr search_pc_val,
     Dwarf_Addr initial_loc,
     Dwarf_Small * start_instr_ptr,
     Dwarf_Small * final_instr_ptr,
     Dwarf_Frame table,
     Dwarf_Cie cie,
     Dwarf_Debug dbg,
     Dwarf_Unsigned reg_num_of_cfa,
     Dwarf_Bool * has_more_rows,
     Dwarf_Addr * subsequent_pc,
     Dwarf_Frame_Instr_Head *ret_frame_instr_head,
     Dwarf_Unsigned * returned_frame_instr_count,
     Dwarf_Error *error)
 {
 /*  The following macro depends on macreg and
     machigh_reg both being unsigned to avoid
     unintended behavior and to avoid compiler warnings when
     high warning levels are turned on.  To avoid
     truncation turning a bogus large value into a smaller
     sensible-seeming value we use Dwarf_Unsigned for register
     numbers. */
 #define ERROR_IF_REG_NUM_TOO_HIGH(macreg,machigh_reg)        \
     do {                                                     \
         if ((macreg) >= (machigh_reg)) {                     \
             SER(DW_DLE_DF_REG_NUM_TOO_HIGH); \
         }                                                    \
     } /*CONSTCOND */ while (0)
 #define FREELOCALMALLOC                  \
         _dwarf_free_dfi_list(ilisthead); \
         ilisthead =0;                    \
         free(dfi); dfi = 0;              \
         free(localregtab); localregtab = 0;
 /* SER === SIMPLE_ERROR_RETURN */
 #define SER(code)                     \
         FREELOCALMALLOC;              \
         _dwarf_error(dbg,error,(code)); \
         return DW_DLV_ERROR
 #define SERSTRING(code,m)             \
         FREELOCALMALLOC;              \
         _dwarf_error_string(dbg,error,(code),m); \
         return DW_DLV_ERROR
 /*  m must be a quoted string */
 #define SERINST(m)                    \
         FREELOCALMALLOC;              \
         _dwarf_error_string(dbg,error,DW_DLE_ALLOC_FAIL, \
             "DW_DLE_ALLOC_FAIL: " m); \
         return DW_DLV_ERROR
 
     /*  Sweeps the frame instructions. */
     Dwarf_Small *instr_ptr = 0;
     Dwarf_Frame_Instr dfi = 0;
 
     /*  Register numbers not limited to just 255,
         thus not using Dwarf_Small.  */
     typedef Dwarf_Unsigned reg_num_type;
 
     Dwarf_Unsigned factored_N_value = 0;
     Dwarf_Signed signed_factored_N_value = 0;
     Dwarf_Addr current_loc = initial_loc;       /* code location/
         pc-value corresponding to the frame instructions.
         Starts at zero when the caller has no value to pass in. */
 
     /*  Must be min de_pointer_size bytes and must be at least 4 */
     Dwarf_Unsigned adv_loc = 0;
 
     Dwarf_Unsigned reg_count = dbg->de_frame_reg_rules_entry_count;
     struct Dwarf_Reg_Rule_s *localregtab = calloc(reg_count,
         sizeof(struct Dwarf_Reg_Rule_s));
 
     struct Dwarf_Reg_Rule_s cfa_reg;
 
     /*  This is used to end executing frame instructions.  */
     /*  Becomes true when search_pc is true and current_loc */
     /*  is greater than search_pc_val.  */
     Dwarf_Bool search_over = false;
 
     Dwarf_Addr possible_subsequent_pc = 0;
 
     Dwarf_Half address_size = (cie)? cie->ci_address_size:
         dbg->de_pointer_size;
 
     /*  Stack_table points to the row (Dwarf_Frame ie) being
         pushed or popped by a remember or restore instruction.
         Top_stack points to
         the top of the stack of rows. */
     Dwarf_Frame stack_table = NULL;
     Dwarf_Frame top_stack = NULL;
 
     /*  These are used only when make_instr is true. Curr_instr is a
         pointer to the current frame instruction executed.
         Curr_instr_ptr, head_instr_list, and curr_instr_list are
         used to form a chain of Dwarf_Frame_Op structs.
         Dealloc_instr_ptr is
         used to deallocate the structs used to form the chain.
         Head_instr_block points to a contiguous list of
         pointers to the
         Dwarf_Frame_Op structs executed. */
     /*  Build single linked list of instrs, and
         at end turn into array. */
     Dwarf_Frame_Instr ilisthead = 0;
     Dwarf_Frame_Instr *ilistlastptr = &ilisthead;
     /*  Counts the number of frame instructions
         in the returned instrs if instruction
         details are asked for. Else 0. */
     Dwarf_Unsigned instr_count = 0;
 
     /*  These are the alignment_factors taken from the Cie provided.
         When no input Cie is provided they are set to 1, because only
         factored offsets are required. */
     Dwarf_Signed code_alignment_factor = 1;
     Dwarf_Signed data_alignment_factor = 1;
 
     /*  This flag indicates when an actual alignment factor
         is needed.
         So if a frame instruction that computes an offset
         using an alignment factor is encountered when this
         flag is set, an error is returned because the Cie
         did not have a valid augmentation. */
     Dwarf_Bool need_augmentation = false;
     Dwarf_Unsigned instr_area_length = 0;
 
     Dwarf_Unsigned i = 0;
 
     /*  Initialize first row from associated Cie.
         Using temp regs explicitly */
 
     if (!localregtab) {
         SER(DW_DLE_ALLOC_FAIL);
     }
     {
         struct Dwarf_Reg_Rule_s *t1reg = localregtab;
         if (cie != NULL && cie->ci_initial_table != NULL) {
             unsigned minregcount = 0;
             unsigned curreg = 0;
             struct Dwarf_Reg_Rule_s *t2reg =
                 cie->ci_initial_table->fr_reg;
 
             if (reg_count != cie->ci_initial_table->fr_reg_count) {
                 /*  Should never happen,
                     it makes no sense to have the
                     table sizes change. There
                     is no real allowance for
                     the set of registers
                     to change dynamically
                     in a single Dwarf_Debug
                     (except the size can be set
                     near initial Dwarf_Debug
                     creation time). */
                 SER(DW_DLE_FRAME_REGISTER_COUNT_MISMATCH);
             }
             minregcount =
                 MIN(reg_count,cie->ci_initial_table->fr_reg_count);
             for ( ; curreg < minregcount ;
                 curreg++, t1reg++, t2reg++) {
                 *t1reg = *t2reg;
             } cfa_reg =
             cie->ci_initial_table->fr_cfa_rule;
         } else {
             _dwarf_init_reg_rules_ru(localregtab,0,reg_count,
                 dbg->de_frame_rule_initial_value);
             _dwarf_init_reg_rules_ru(&cfa_reg,0, 1,
                 dbg->de_frame_rule_initial_value);
         }
     }
     /*  The idea here is that the code_alignment_factor and
         data_alignment_factor which are needed for certain
         instructions are valid only when the Cie has a proper
         augmentation string. So if the augmentation is not
         right, only Frame instruction can be read. */
     if (cie != NULL && cie->ci_augmentation != NULL) {
         code_alignment_factor = cie->ci_code_alignment_factor;
         data_alignment_factor = cie->ci_data_alignment_factor;
     } else {
         need_augmentation = !make_instr;
     }
     instr_ptr = start_instr_ptr;
     instr_area_length = (uintptr_t)
         (final_instr_ptr - start_instr_ptr);
     while ((instr_ptr < final_instr_ptr) && (!search_over)) {
         Dwarf_Small   instr = 0;
         Dwarf_Small   opcode = 0;
         reg_num_type  reg_no = 0;
         Dwarf_Unsigned adv_pc = 0;
         Dwarf_Off fp_instr_offset = 0;
         Dwarf_Small * base_instr_ptr = 0;
 
         if (instr_ptr < start_instr_ptr) {
             SERINST("DW_DLE_DF_NEW_LOC_LESS_OLD_LOC: "
                 "Following instruction bytes we find impossible "
                 "decrease in a pointer");
         }
-
         fp_instr_offset = instr_ptr - start_instr_ptr;
+        if (instr_ptr >= final_instr_ptr) {
+            _dwarf_error(NULL, error, DW_DLE_DF_FRAME_DECODING_ERROR);
+            return DW_DLV_ERROR;
+        }
         instr = *(Dwarf_Small *) instr_ptr;
         instr_ptr += sizeof(Dwarf_Small);
         base_instr_ptr = instr_ptr;
         if ((instr & 0xc0) == 0x00) {
             opcode = instr;     /* is really extended op */
         } else {
             opcode = instr & 0xc0;      /* is base op */
         }
         if (make_instr) {
             dfi = calloc(1,sizeof(*dfi));
             if (!dfi) {
                 SERINST("DW_CFA_advance_loc out of memory");
             }
             dfi->fi_op = opcode;
             dfi->fi_instr_offset = fp_instr_offset;
             dfi->fi_fields = "";
         }
         switch (opcode) {
         case DW_CFA_lo_user: {
             if (make_instr) {
                 dfi->fi_fields = "";
             }
         }
         break;
         case DW_CFA_advance_loc: {
             Dwarf_Unsigned adv_pc_val = 0;
             int alres = 0;
 
             /* base op */
             adv_pc_val = instr &DW_FRAME_INSTR_OFFSET_MASK;
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
 
             /* CHECK OVERFLOW */
             alres = _dwarf_uint64_mult(adv_pc_val,
                 code_alignment_factor,&adv_pc,dbg,error);
             if (alres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return DW_DLV_ERROR;
             }
             if (INVALIDUNSIGNED(adv_pc)) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "negative new location");
             }
 
             possible_subsequent_pc = current_loc +
                 (Dwarf_Unsigned)adv_pc;
             if (possible_subsequent_pc < current_loc &&
                 possible_subsequent_pc < adv_pc) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "add overflowed");
             }
 
             search_over = search_pc &&
                 (possible_subsequent_pc > search_pc_val);
             /* If gone past pc needed, retain old pc.  */
             if (!search_over) {
                 current_loc = possible_subsequent_pc;
             }
             if (make_instr) {
                 dfi->fi_fields = "uc";
                 dfi->fi_u0 = adv_pc_val;
                 dfi->fi_code_align_factor = code_alignment_factor;
             }
             }
             break;
         case DW_CFA_offset: {  /* base op */
             int adres = 0;
             Dwarf_Signed result = 0;
             reg_no = (reg_num_type) (instr &
                 DW_FRAME_INSTR_OFFSET_MASK);
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &factored_N_value,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (need_augmentation) {
                 SER( DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             if (INVALIDUNSIGNED(factored_N_value)) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "negative factored_N_value location");
             }
             /*  CHECK OVERFLOW */
             adres = _dwarf_int64_mult(
                 (Dwarf_Signed)factored_N_value,
                 data_alignment_factor,
                 &result,dbg, error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return DW_DLV_ERROR;
             }
             localregtab[reg_no].ru_offset = result;
             localregtab[reg_no].ru_is_offset = 1;
             localregtab[reg_no].ru_register = reg_num_of_cfa;
             localregtab[reg_no].ru_value_type = DW_EXPR_OFFSET;
             if (make_instr) {
                 dfi->fi_fields = "rud";
                 dfi->fi_u0 = reg_no;
                 dfi->fi_u1 = factored_N_value;
                 dfi->fi_data_align_factor =
                     data_alignment_factor;
             }
             }
             break;
         case DW_CFA_restore: { /* base op */
             reg_no = (instr & DW_FRAME_INSTR_OFFSET_MASK);
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
 
             if (cie != NULL && cie->ci_initial_table != NULL) {
                 localregtab[reg_no] =
                     cie->ci_initial_table->fr_reg[reg_no];
             } else if (!make_instr) {
                 SER(DW_DLE_DF_MAKE_INSTR_NO_INIT);
             }
             if (make_instr) {
                 dfi->fi_fields = "r";
                 dfi->fi_u0 = reg_no;
             }
             }
             break;
         case DW_CFA_set_loc: {
             Dwarf_Addr new_loc = 0;
             int adres = 0;
             adres=_dwarf_read_unaligned_ck_wrapper(dbg,
                 &new_loc,
                 instr_ptr, address_size,
                 final_instr_ptr,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             instr_ptr += address_size;
             if (new_loc != 0 && current_loc != 0) {
                 /*  Pre-relocation or before current_loc
                     is set the test comparing new_loc
                     and current_loc makes no
                     sense. Testing for non-zero (above) is a way
                     (fallible) to check that current_loc, new_loc
                     are already relocated.  */
                 if (new_loc <= current_loc) {
                     /*  Within a frame, address must increase.
                     Seemingly it has not.
                     Seems to be an error. */
                     SER(DW_DLE_DF_NEW_LOC_LESS_OLD_LOC);
                 }
             }
             search_over = search_pc && (new_loc > search_pc_val);
             /* If gone past pc needed, retain old pc.  */
             possible_subsequent_pc =  new_loc;
             if (!search_over) {
                 current_loc = possible_subsequent_pc;
             }
             if (make_instr) {
                 dfi->fi_fields = "u";
                 dfi->fi_u0 = new_loc;
             }
             }
             break;
         case DW_CFA_advance_loc1:
         {
             int adres = 0;
             Dwarf_Unsigned advloc_val = 0;
             adres=_dwarf_read_unaligned_ck_wrapper(dbg,
                 &advloc_val,
                 instr_ptr, sizeof(Dwarf_Small),
                 final_instr_ptr,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             instr_ptr += sizeof(Dwarf_Small);
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             /* CHECK OVERFLOW */
             adres = _dwarf_uint64_mult(
                 advloc_val,
                 code_alignment_factor,
                 &adv_loc,dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
 
             /* CHECK OVERFLOW add */
             possible_subsequent_pc =  current_loc + adv_loc;
             if (possible_subsequent_pc < current_loc &&
                 possible_subsequent_pc < adv_loc) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "add overflowed calcating subsequent pc");
             }
             search_over = search_pc &&
             (possible_subsequent_pc > search_pc_val);
 
             /* If gone past pc needed, retain old pc.  */
             if (!search_over) {
                 current_loc = possible_subsequent_pc;
             }
             if (make_instr) {
                 dfi->fi_fields = "uc";
                 dfi->fi_u0 = advloc_val;
                 dfi->fi_code_align_factor =
                     code_alignment_factor;
             }
             break;
         }
 
         case DW_CFA_advance_loc2:
         {
             int adres = 0;
             Dwarf_Unsigned advloc_val = 0;
             adres=_dwarf_read_unaligned_ck_wrapper(dbg, &advloc_val,
                 instr_ptr, DWARF_HALF_SIZE,
                 final_instr_ptr,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             instr_ptr += DWARF_HALF_SIZE;
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             /* CHECK OVERFLOW */
             adres = _dwarf_uint64_mult(
                 advloc_val,
                 code_alignment_factor,
                 &adv_loc,dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
             /* CHECK OVERFLOW add */
             if (INVALIDUNSIGNED(adv_loc)) {
                 SERSTRING( DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "negative new location");
             }
 
             /* CHECK OVERFLOW add */
             possible_subsequent_pc =  current_loc + adv_loc;
             if (possible_subsequent_pc < current_loc &&
                 possible_subsequent_pc < adv_loc) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "add overflowed");
             }
             search_over = search_pc &&
             (possible_subsequent_pc > search_pc_val);
             /* If gone past pc needed, retain old pc.  */
             if (!search_over) {
                 current_loc = possible_subsequent_pc;
             }
             if (make_instr) {
                 dfi->fi_fields = "uc";
                 dfi->fi_u0 = advloc_val;
                 dfi->fi_code_align_factor =
                     code_alignment_factor;
             }
             break;
         }
 
         case DW_CFA_advance_loc4:
         {
             int adres = 0;
             Dwarf_Unsigned advloc_val = 0;
 
             adres=_dwarf_read_unaligned_ck_wrapper(dbg, &advloc_val,
                 instr_ptr,  DWARF_32BIT_SIZE,
                 final_instr_ptr,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             instr_ptr += DWARF_32BIT_SIZE;
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             /* CHECK OVERFLOW */
             adres = _dwarf_uint64_mult(
                 advloc_val,
                 code_alignment_factor,
                 &adv_loc,dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
             /* CHECK OVERFLOW add */
             possible_subsequent_pc =  current_loc + adv_loc;
             if (possible_subsequent_pc < current_loc &&
                 possible_subsequent_pc < adv_loc) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "unsigned add overflowed");
             }
 
             search_over = search_pc &&
                 (possible_subsequent_pc > search_pc_val);
             /* If gone past pc needed, retain old pc.  */
             if (!search_over) {
                 current_loc = possible_subsequent_pc;
             }
             if (make_instr) {
                 dfi->fi_fields = "uc";
                 dfi->fi_u0 = advloc_val;
                 dfi->fi_code_align_factor =
                     code_alignment_factor;
             }
             break;
         }
         case DW_CFA_MIPS_advance_loc8:
         {
             int adres = 0;
             Dwarf_Unsigned advloc_val = 0;
             adres=_dwarf_read_unaligned_ck_wrapper(dbg, &advloc_val,
                 instr_ptr,  DWARF_64BIT_SIZE,
                 final_instr_ptr,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             instr_ptr += DWARF_64BIT_SIZE;
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             /* CHECK OVERFLOW */
             adres = _dwarf_uint64_mult(advloc_val,
                 code_alignment_factor,&adv_loc,
                 dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
             /* CHECK OVERFLOW add */
             possible_subsequent_pc =  current_loc + adv_loc;
             if (possible_subsequent_pc < current_loc &&
                 possible_subsequent_pc < adv_loc) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "unsigned add overflowed");
             }
             search_over = search_pc &&
             (possible_subsequent_pc > search_pc_val);
             /* If gone past pc needed, retain old pc.  */
             if (!search_over) {
                 current_loc = possible_subsequent_pc;
             }
             if (make_instr) {
                 dfi->fi_fields = "u";
                 dfi->fi_u0 = advloc_val;
                 dfi->fi_code_align_factor =
                     code_alignment_factor;
             }
             break;
         }
 
         case DW_CFA_offset_extended:
         {
             Dwarf_Unsigned lreg = 0;
             Dwarf_Signed  result = 0;
             int adres = 0;
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &factored_N_value,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             if (INVALIDUNSIGNED(factored_N_value)) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "negative new location");
             }
             /*  CHECK OVERFLOW */
             adres = _dwarf_int64_mult((Dwarf_Signed)factored_N_value,
                 data_alignment_factor, &result,
                 dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
             localregtab[reg_no].ru_is_offset = 1;
             localregtab[reg_no].ru_value_type = DW_EXPR_OFFSET;
             localregtab[reg_no].ru_register = reg_num_of_cfa;
             localregtab[reg_no].ru_offset = result;
             if (make_instr) {
                 dfi->fi_fields = "rud";
                 dfi->fi_u0 = lreg;
                 dfi->fi_u1 = factored_N_value;
                 dfi->fi_data_align_factor =
                     data_alignment_factor;
             }
             break;
         }
 
         case DW_CFA_restore_extended:
         {
             Dwarf_Unsigned lreg = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             if (cie != NULL && cie->ci_initial_table != NULL) {
                 localregtab[reg_no] =
                     cie->ci_initial_table->fr_reg[reg_no];
             } else {
                 if (!make_instr) {
                     SER(DW_DLE_DF_MAKE_INSTR_NO_INIT);
                 }
             }
             if (make_instr) {
                 dfi->fi_fields = "r";
                 dfi->fi_u0 = lreg;
             }
             break;
         }
 
         case DW_CFA_undefined:
         {
             Dwarf_Unsigned lreg = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             localregtab[reg_no].ru_is_offset = 0;
             localregtab[reg_no].ru_value_type = DW_EXPR_OFFSET;
             localregtab[reg_no].ru_register =
                 dbg->de_frame_undefined_value_number;
             localregtab[reg_no].ru_offset = 0;
             if (make_instr) {
                 dfi->fi_fields = "r";
                 dfi->fi_u0 = lreg;
             }
             break;
         }
 
         case DW_CFA_same_value:
         {
             Dwarf_Unsigned lreg = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             localregtab[reg_no].ru_is_offset = 0;
             localregtab[reg_no].ru_value_type = DW_EXPR_OFFSET;
             localregtab[reg_no].ru_register =
                 dbg->de_frame_same_value_number;
             localregtab[reg_no].ru_offset = 0;
             if (make_instr) {
                 dfi->fi_fields = "r";
                 dfi->fi_u0 = lreg;
             }
             break;
         }
 
         case DW_CFA_register:
         {
             Dwarf_Unsigned lreg;
             reg_num_type reg_noA = 0;
             reg_num_type reg_noB = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
             &lreg,error);
                 if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_noA = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_noA, reg_count);
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_noB = (reg_num_type) lreg;
             if (reg_noB > reg_count) {
                 SER(DW_DLE_DF_REG_NUM_TOO_HIGH);
             }
             localregtab[reg_noA].ru_is_offset = 0;
             localregtab[reg_noA].ru_value_type = DW_EXPR_OFFSET;
             localregtab[reg_noA].ru_register = reg_noB;
             localregtab[reg_noA].ru_offset = 0;
             if (make_instr) {
                 dfi->fi_fields = "rr";
                 dfi->fi_u0 = reg_noA;
                 dfi->fi_u1 = reg_noB;
             }
             break;
         }
 
         case DW_CFA_remember_state:
         {
             stack_table = (Dwarf_Frame)
             _dwarf_get_alloc(dbg, DW_DLA_FRAME, 1);
             if (stack_table == NULL) {
                 SER(DW_DLE_DF_ALLOC_FAIL);
             }
             for (i = 0; i < reg_count; i++) {
                 stack_table->fr_reg[i] = localregtab[i];
             }
             stack_table->fr_cfa_rule = cfa_reg;
             if (top_stack != NULL) {
                 stack_table->fr_next = top_stack;
             }
             top_stack = stack_table;
             if (make_instr) {
                 dfi->fi_fields = "";
             }
             }
             break;
         case DW_CFA_restore_state:
         {
             if (top_stack == NULL) {
                 SER(DW_DLE_DF_POP_EMPTY_STACK);
             }
             stack_table = top_stack;
             top_stack = stack_table->fr_next;
             for (i = 0; i < reg_count; i++) {
                 localregtab[i] = stack_table->fr_reg[i];
             }
             cfa_reg = stack_table->fr_cfa_rule;
             dwarf_dealloc(dbg, stack_table, DW_DLA_FRAME);
             if (make_instr) {
                 dfi->fi_fields = "";
             }
             break;
         }
 
         case DW_CFA_def_cfa:
         {
             Dwarf_Unsigned lreg = 0;
             int adres = 0;
             Dwarf_Off nonfactoredoffset = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &nonfactoredoffset,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             cfa_reg.ru_is_offset = 1;
             cfa_reg.ru_value_type = DW_EXPR_OFFSET;
             cfa_reg.ru_register = reg_no;
             if (INVALIDUNSIGNED(nonfactoredoffset)) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "DW_CFA_def_cfa offset unrepresantable "
                     "as signed");
             }
             cfa_reg.ru_offset = (Dwarf_Signed)nonfactoredoffset;
             if (make_instr) {
                 dfi->fi_fields = "ru";
                 dfi->fi_u0 = lreg;
                 dfi->fi_u1 = nonfactoredoffset;
             }
             break;
         }
 
         case DW_CFA_def_cfa_register:
         {
             Dwarf_Unsigned lreg = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             cfa_reg.ru_register = (Dwarf_Half)reg_no;
             /*  Do NOT set ru_offset_or_block_len or
                 ru_is_off here.
                 See dwarf2/3 spec.  */
             if (make_instr) {
                 dfi->fi_fields = "r";
                 dfi->fi_u0 = lreg;
             }
             break;
         }
 
         case DW_CFA_def_cfa_offset:
         {
             int adres = 0;
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &factored_N_value,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             /*  Do set ru_is_off here, as here factored_N_value
                 counts.  */
             cfa_reg.ru_is_offset = 1;
             cfa_reg.ru_value_type = DW_EXPR_OFFSET;
             if (INVALIDUNSIGNED(factored_N_value)) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "DW_CFA_def_cfa_offset unrepresantable "
                     "as signed");
             }
             cfa_reg.ru_offset = (Dwarf_Signed)factored_N_value;
             if (make_instr) {
                 dfi->fi_fields = "u";
                 dfi->fi_u0 = factored_N_value;
             }
             break;
         }
         /*  This is for Metaware with augmentation string HC
             We do not really know what to do with it. */
         case DW_CFA_METAWARE_info:
         {
             int adres = 0;
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &factored_N_value,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             /* Not really known what the value means or is. */
             cfa_reg.ru_is_offset = 1;
             cfa_reg.ru_value_type = DW_EXPR_OFFSET;
             if (INVALIDUNSIGNED(factored_N_value)) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "DW_CFA_METAWARE_info unrepresantable as signed");
             }
             cfa_reg.ru_offset = (Dwarf_Signed)factored_N_value;
             if (make_instr) {
                 dfi->fi_fields = "u";
                 dfi->fi_u0 = factored_N_value;
             }
             break;
         }
         case DW_CFA_nop:
         {
             if (make_instr) {
                 dfi->fi_fields = "";
             }
             break;
         }
         /* DWARF3 ops begin here. */
         case DW_CFA_def_cfa_expression: {
             /*  A single DW_FORM_block representing a dwarf
                 expression. The form block establishes the way to
                 compute the CFA. */
             Dwarf_Unsigned block_len = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &block_len,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             cfa_reg.ru_is_offset = 0;  /* arbitrary */
             cfa_reg.ru_value_type = DW_EXPR_EXPRESSION;
             cfa_reg.ru_block.bl_len = block_len;
             cfa_reg.ru_block.bl_data = instr_ptr;
             if (make_instr) {
                 dfi->fi_fields = "b";
                 dfi->fi_expr.bl_len = block_len;
                 dfi->fi_expr.bl_data = instr_ptr;
             }
             instr_ptr += block_len;
             if (instr_area_length < block_len ||
                 instr_ptr < base_instr_ptr) {
                 SERSTRING(DW_DLE_DF_FRAME_DECODING_ERROR,
                     "DW_DLE_DF_FRAME_DECODING_ERROR: "
                     "DW_CFA_def_cfa_expression "
                     "block len overflows instructions "
                     "available range.");
             }
         }
         break;
         case DW_CFA_expression: {
             /*  An unsigned leb128 value is the first operand (a
             register number). The second operand is single
             DW_FORM_block representing a dwarf expression. The
             evaluator pushes the CFA on the evaluation stack
             then evaluates the expression to compute the value
             of the register contents. */
             Dwarf_Unsigned lreg = 0;
             Dwarf_Unsigned block_len = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &block_len,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             localregtab[lreg].ru_is_offset = 0; /* arbitrary */
             localregtab[lreg].ru_value_type = DW_EXPR_EXPRESSION;
             localregtab[lreg].ru_block.bl_data = instr_ptr;
             localregtab[lreg].ru_block.bl_len = block_len;
             if (make_instr) {
                 dfi->fi_fields = "rb";
                 dfi->fi_u0 = lreg;
                 dfi->fi_expr.bl_len = block_len;
                 dfi->fi_expr.bl_data = instr_ptr;
             }
             instr_ptr += block_len;
             if (instr_area_length < block_len ||
                 instr_ptr < base_instr_ptr) {
                 SERSTRING(DW_DLE_DF_FRAME_DECODING_ERROR,
                     "DW_DLE_DF_FRAME_DECODING_ERROR: "
                     "DW_CFA_expression "
                     "block len overflows instructions "
                     "available range.");
             }
             }
             break;
         case DW_CFA_offset_extended_sf: {
             /*  The first operand is an unsigned leb128 register
                 number. The second is a signed factored offset.
                 Identical to DW_CFA_offset_extended except the
                 second operand is signed */
             Dwarf_Unsigned lreg = 0;
             int adres = 0;
             Dwarf_Signed result = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             adres = _dwarf_leb128_sword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &signed_factored_N_value,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             /* CHECK OVERFLOW */
             adres = _dwarf_int64_mult(signed_factored_N_value,
                 data_alignment_factor,
                 &result,dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
             localregtab[reg_no].ru_is_offset = 1;
             localregtab[reg_no].ru_value_type = DW_EXPR_OFFSET;
             localregtab[reg_no].ru_register = reg_num_of_cfa;
             localregtab[reg_no].ru_offset = result;
             if (make_instr) {
                 dfi->fi_fields = "rsd";
                 dfi->fi_u0 = lreg;
                 dfi->fi_s1 = signed_factored_N_value;
                 dfi->fi_data_align_factor =
                     data_alignment_factor;
             }
             }
             break;
         case DW_CFA_def_cfa_sf: {
             /*  The first operand is an unsigned leb128 register
                 number. The second is a signed leb128 factored
                 offset. Identical to DW_CFA_def_cfa except
                 that the second operand is signed
                 and factored. */
             Dwarf_Unsigned lreg = 0;
             int adres = 0;
             Dwarf_Signed result =0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             adres = _dwarf_leb128_sword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &signed_factored_N_value,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             /*  CHECK OVERFLOW */
             adres = _dwarf_int64_mult(signed_factored_N_value,
                 data_alignment_factor,
                 &result,dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
             cfa_reg.ru_is_offset = 1;
             cfa_reg.ru_value_type = DW_EXPR_OFFSET;
             cfa_reg.ru_register = reg_no;
             cfa_reg.ru_offset = result;
             if (make_instr) {
                 dfi->fi_fields = "rsd";
                 dfi->fi_u0 = lreg;
                 dfi->fi_s1 = signed_factored_N_value;
                 dfi->fi_data_align_factor =
                     data_alignment_factor;
             }
             }
             break;
         case DW_CFA_def_cfa_offset_sf: {
             /*  The operand is a signed leb128 operand
                 representing a factored offset.  Identical to
                 DW_CFA_def_cfa_offset except the operand is
                 signed and factored. */
             int adres = 0;
             Dwarf_Signed result = 0;
 
             adres = _dwarf_leb128_sword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &signed_factored_N_value,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             /*  CHECK OVERFLOW */
             adres = _dwarf_int64_mult(signed_factored_N_value,
                 data_alignment_factor,
                 &result,dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
             /*  Do set ru_is_off here, as here factored_N_value
                 counts.  */
             cfa_reg.ru_is_offset = 1;
             cfa_reg.ru_value_type = DW_EXPR_OFFSET;
             cfa_reg.ru_offset = result;
             if (make_instr) {
                 dfi->fi_fields = "sd";
                 dfi->fi_s0 = signed_factored_N_value;
                 dfi->fi_data_align_factor =
                     data_alignment_factor;
             }
             }
             break;
         case DW_CFA_val_offset: {
             /*  The first operand is an unsigned leb128 register
                 number. The second is a factored unsigned offset.
                 Makes the register be a val_offset(N)
                 rule with N =
                 factored_offset*data_alignment_factor. */
             Dwarf_Unsigned lreg = 0;
             int adres = 0;
             Dwarf_Signed result = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &factored_N_value,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (INVALIDUNSIGNED(factored_N_value) ) {
                 SERSTRING(DW_DLE_ARITHMETIC_OVERFLOW,
                     "DW_DLE_ARITHMETIC_OVERFLOW "
                     "in DW_CFA_val_offset factored value");
             }
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             /*  CHECK OVERFLOW */
             adres = _dwarf_int64_mult(
                 (Dwarf_Signed)factored_N_value,
                 data_alignment_factor,
                 &result,dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
 
             /*  Do set ru_is_off here, as here factored_N_value
                 counts.  */
             localregtab[reg_no].ru_is_offset = 1;
             localregtab[reg_no].ru_register = reg_num_of_cfa;
             localregtab[reg_no].ru_value_type =
                 DW_EXPR_VAL_OFFSET;
             /*  CHECK OVERFLOW */
             localregtab[reg_no].ru_offset = result;
             if (make_instr) {
                 dfi->fi_fields = "rud";
                 dfi->fi_u0 = lreg;
                 dfi->fi_u1 = factored_N_value;
                 dfi->fi_data_align_factor =
                     data_alignment_factor;
             }
             break;
         }
         case DW_CFA_val_offset_sf: {
             /*  The first operand is an unsigned leb128 register
                 number. The second is a factored signed offset.
                 Makes the register be a val_offset(N) rule
                 with
                 N = factored_offset*data_alignment_factor. */
             Dwarf_Unsigned lreg = 0;
             Dwarf_Signed result = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             adres = _dwarf_leb128_sword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &signed_factored_N_value,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (need_augmentation) {
                 SER(DW_DLE_DF_NO_CIE_AUGMENTATION);
             }
             adres = _dwarf_int64_mult(signed_factored_N_value,
                 data_alignment_factor,&result,
                 dbg,error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return adres;
             }
             /*  Do set ru_is_off here, as here factored_N_value
                 counts.  */
             localregtab[reg_no].ru_is_offset = 1;
             localregtab[reg_no].ru_value_type =
                 DW_EXPR_VAL_OFFSET;
             /*  CHECK OVERFLOW */
             localregtab[reg_no].ru_offset = result;
             if (make_instr) {
                 dfi->fi_fields = "rsd";
                 dfi->fi_u0 = lreg;
                 dfi->fi_s1 = signed_factored_N_value;
                 dfi->fi_data_align_factor =
                     data_alignment_factor;
             }
             }
             break;
         case DW_CFA_val_expression: {
             /*  The first operand is an unsigned leb128 register
                 number. The second is a DW_FORM_block
                 representing a
                 DWARF expression. The rule for the register
                 number becomes a val_expression(E) rule. */
             Dwarf_Unsigned lreg = 0;
             Dwarf_Unsigned block_len = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             reg_no = (reg_num_type) lreg;
             ERROR_IF_REG_NUM_TOO_HIGH(reg_no, reg_count);
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &block_len,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             localregtab[lreg].ru_is_offset = 0; /* arbitrary */
             localregtab[lreg].ru_value_type =
                 DW_EXPR_VAL_EXPRESSION;
             localregtab[lreg].ru_offset = 0;
             localregtab[lreg].ru_block.bl_data = instr_ptr;
             localregtab[lreg].ru_block.bl_len = block_len;
             if (make_instr) {
                 dfi->fi_fields = "rb";
                 dfi->fi_u0 = lreg;
                 dfi->fi_expr.bl_len = block_len;
                 dfi->fi_expr.bl_data = instr_ptr;
             }
             instr_ptr += block_len;
             if (instr_area_length < block_len ||
                 instr_ptr < base_instr_ptr) {
                 SERSTRING(DW_DLE_DF_FRAME_DECODING_ERROR,
                     "DW_DLE_DF_FRAME_DECODING_ERROR: "
                     "DW_CFA_val_expression "
                     "block len overflows instructions "
                     "available range.");
             }
         }
         break;
         /* END DWARF3 new ops. */
 
 #ifdef DW_CFA_GNU_window_save
         case DW_CFA_GNU_window_save: {
             /*  No information: this just tells
                 unwinder to restore
                 the window registers from the previous frame's
                 window save area */
             if (make_instr) {
                 dfi->fi_fields = "";
             }
         }
         break;
 #endif
 #ifdef  DW_CFA_GNU_args_size
             /*  Single uleb128 is the current arg area
                 size in bytes. No
                 register exists yet to save this in.
                 the value of must be added to
                 an x86 register to get the correct
                 stack pointer.
                 https://lists.nongnu.org/archive/html/
                 libunwind-devel/2016-12/msg00004.html
                 https://refspecs.linuxfoundation.org/
                 LSB_3.0.0/LSB-PDA/LSB-PDA.junk/dwarfext.html
             */
         case DW_CFA_GNU_args_size: {
             Dwarf_Unsigned asize = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &asize,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             /*  Currently not put into ru_* reg rules, not
                 sure what to do with it. */
             /*  This is the total size of arguments
                 pushed on the stack.  */
             if (make_instr) {
                 dfi->fi_fields = "u";
                 dfi->fi_u0 = asize;
             }
         }
         break;
 #endif
         case DW_CFA_LLVM_def_aspace_cfa: {
             Dwarf_Unsigned lreg = 0;
             Dwarf_Unsigned offset = 0;
             Dwarf_Unsigned addrspace = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             ERROR_IF_REG_NUM_TOO_HIGH(lreg, reg_count);
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &offset,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &addrspace,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             if (make_instr) {
                 dfi->fi_fields = "rua";
                 dfi->fi_u0 = lreg;
                 dfi->fi_u1 = offset;
                 dfi->fi_u2 = addrspace;
             }
         }
         break;
         case DW_CFA_LLVM_def_aspace_cfa_sf: {
             Dwarf_Unsigned lreg = 0;
             Dwarf_Signed offset = 0;
             Dwarf_Signed result = 0;
             Dwarf_Unsigned addrspace = 0;
             int adres = 0;
 
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &lreg,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             ERROR_IF_REG_NUM_TOO_HIGH(lreg, reg_count);
             adres = _dwarf_leb128_sword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &offset,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             adres = _dwarf_leb128_uword_wrapper(dbg,
                 &instr_ptr,final_instr_ptr,
                 &addrspace,error);
             if (adres != DW_DLV_OK) {
                 FREELOCALMALLOC;
                 return adres;
             }
             /*  CHECK OVERFLOW */
             adres = _dwarf_int64_mult(
                 (Dwarf_Signed)offset,
                 data_alignment_factor,
                 &result,dbg, error);
             if (adres == DW_DLV_ERROR) {
                 FREELOCALMALLOC;
                 return DW_DLV_ERROR;
             }
             localregtab[reg_no].ru_is_offset = 1;
             localregtab[reg_no].ru_value_type = DW_EXPR_OFFSET;
             localregtab[reg_no].ru_register = reg_num_of_cfa;
             localregtab[reg_no].ru_offset = result;
             if (make_instr) {
                 dfi->fi_fields = "rsda";
                 dfi->fi_u0 = lreg;
                 dfi->fi_s1 = offset;
                 dfi->fi_u2 = addrspace;
                 dfi->fi_data_align_factor =
                     data_alignment_factor;
             }
         }
         break;
         default: {
             /*  ERROR, we have an opcode we know nothing
                 about. Memory leak here, but an error
                 like this is not supposed to
                 happen so we ignore the leak.
                 These used to be ignored,
                 now we notice and report. */
             dwarfstring ms;
 
             dwarfstring_constructor(&ms);
             dwarfstring_append_printf_u(&ms,
                 "DW_DLE_DF_FRAME_DECODING_ERROR:  "
                 "instr opcode 0x%x unknown",opcode);
             _dwarf_error_string(dbg,error,
                 DW_DLE_DF_FRAME_DECODING_ERROR,
                 dwarfstring_string(&ms));
             dwarfstring_destructor(&ms);
             FREELOCALMALLOC;
             return DW_DLV_ERROR;
         }
         }
         if (make_instr) {
             /* add dfi to end of singly-linked list */
             instr_count++;
             (*ilistlastptr) = dfi;
             ilistlastptr = &dfi->fi_next;
             /* dfi itself is stale, the pointer is on the list */
             dfi = 0;
         }
     } /*  end for-loop on ops */
 
     /*  If frame instruction decoding was right we would
         stop exactly at
         final_instr_ptr. */
     if (instr_ptr > final_instr_ptr) {
         SER(DW_DLE_DF_FRAME_DECODING_ERROR);
     }
     /*  If search_over is set the last instr was an advance_loc
         so we are not done with rows. */
     if ((instr_ptr == final_instr_ptr) && !search_over) {
         if (has_more_rows) {
             *has_more_rows = false;
         }
         if (subsequent_pc) {
             *subsequent_pc = 0;
         }
     } else {
         if (has_more_rows) {
             *has_more_rows = true;
         }
         if (subsequent_pc) {
             *subsequent_pc = possible_subsequent_pc;
         }
     }
 
     /*  Fill in the actual output table, the space the
         caller passed in. */
     if (table) {
 
         struct Dwarf_Reg_Rule_s *t2reg = table->fr_reg;
         struct Dwarf_Reg_Rule_s *t3reg = localregtab;
         unsigned minregcount =  MIN(table->fr_reg_count,reg_count);
         unsigned curreg = 0;
 
         table->fr_loc = current_loc;
         for (; curreg < minregcount ; curreg++, t3reg++, t2reg++) {
             *t2reg = *t3reg;
         }
 
         /*  CONSTCOND */
         /*  Do not update the main table with the cfa_reg.
             Just leave cfa_reg as cfa_reg. */
         table->fr_cfa_rule = cfa_reg;
     }
     /* Dealloc anything remaining on stack. */
     for (; top_stack != NULL;) {
         stack_table = top_stack;
         top_stack = top_stack->fr_next;
         dwarf_dealloc(dbg, stack_table, DW_DLA_FRAME);
     }
     if (make_instr) {
         Dwarf_Frame_Instr_Head head = 0;
         Dwarf_Frame_Instr *instrptrs   = 0;
         Dwarf_Frame_Instr *curinstrptr = 0;
         Dwarf_Frame_Instr cur         = 0;
         Dwarf_Frame_Instr next        = 0;
         Dwarf_Unsigned    ic          = 0;
 
         head= (Dwarf_Frame_Instr_Head)
             _dwarf_get_alloc(dbg, DW_DLA_FRAME_INSTR_HEAD,1);
         if (!head) {
             SER(DW_DLE_DF_ALLOC_FAIL);
         }
         instrptrs= (Dwarf_Frame_Instr *)
             _dwarf_get_alloc(dbg, DW_DLA_LIST,instr_count);
         if (!instrptrs) {
             dwarf_dealloc(dbg,head,DW_DLA_FRAME_INSTR_HEAD);
             SER(DW_DLE_DF_ALLOC_FAIL);
         }
         head->fh_array = instrptrs;
         head->fh_array_count = instr_count;
         head->fh_dbg = dbg;
         head->fh_cie = cie;
         cur = ilisthead;
         curinstrptr = instrptrs;
         for ( ; cur ; ic++,cur = next,++curinstrptr) {
             *curinstrptr = cur;
             next = cur->fi_next;
             cur->fi_next = 0;
         }
         ilisthead = 0;
         if (ic != instr_count) {
             dwarfstring m;
 
             FREELOCALMALLOC;
             dwarf_dealloc(dbg,head,DW_DLA_FRAME_INSTR_HEAD);
             dwarfstring_constructor(&m);
             dwarfstring_append_printf_u(&m,
                 "DW_DLE_DF_FRAME_DECODING_ERROR: "
                 "Instruction array build, instr count %u",
                 instr_count);
             dwarfstring_append_printf_u(&m,
                 " index i %u. Impossible error.",ic);
             _dwarf_error_string(dbg,error,
                 DW_DLE_DF_FRAME_DECODING_ERROR,
                 dwarfstring_string(&m));
             dwarfstring_destructor(&m);
             return DW_DLV_ERROR;
         }
         *ret_frame_instr_head = head;
         *returned_frame_instr_count =  instr_count;
     } else {
         if (ret_frame_instr_head) {
             *ret_frame_instr_head = 0;
         }
         if (returned_frame_instr_count) {
             *returned_frame_instr_count = 0;
         }
     }
     FREELOCALMALLOC;
     return DW_DLV_OK;
 #undef ERROR_IF_REG_NUM_TOO_HIGH
 #undef FREELOCALMALLOC
 #undef SER
 }
 
 /*  Depending on version, either read the return address register
     as a ubyte or as an leb number.
     The form of this value changed for DWARF3.
 */
@@ -2334,101 +2337,100 @@ static int
 _dwarf_get_fde_info_for_a_pc_row(Dwarf_Fde fde,
     Dwarf_Addr pc_requested,
     Dwarf_Frame table,
     Dwarf_Unsigned cfa_reg_col_num,
     Dwarf_Bool * has_more_rows,
     Dwarf_Addr * subsequent_pc,
     Dwarf_Error * error)
 {
     Dwarf_Debug dbg = 0;
     Dwarf_Cie cie = 0;
     int res = 0;
 
     if (fde == NULL) {
         _dwarf_error(NULL, error, DW_DLE_FDE_NULL);
         return DW_DLV_ERROR;
     }
 
     dbg = fde->fd_dbg;
     if (dbg == NULL) {
         _dwarf_error(NULL, error, DW_DLE_FDE_DBG_NULL);
         return DW_DLV_ERROR;
     }
 
     if (pc_requested < fde->fd_initial_location ||
         pc_requested >=
         fde->fd_initial_location + fde->fd_address_range) {
         _dwarf_error(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
         return DW_DLV_ERROR;
     }
 
     cie = fde->fd_cie;
     if (cie->ci_initial_table == NULL) {
         Dwarf_Small *instrstart = cie->ci_cie_instr_start;
         Dwarf_Small *instrend = instrstart +cie->ci_length +
             cie->ci_length_size +
             cie->ci_extension_size -
             (cie->ci_cie_instr_start -
             cie->ci_cie_start);
         if (instrend > cie->ci_cie_end) {
             _dwarf_error(dbg, error,DW_DLE_CIE_INSTR_PTR_ERROR);
             return DW_DLV_ERROR;
         }
         cie->ci_initial_table = (Dwarf_Frame)_dwarf_get_alloc(dbg,
             DW_DLA_FRAME, 1);
 
         if (cie->ci_initial_table == NULL) {
             _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
             return DW_DLV_ERROR;
         }
         _dwarf_init_reg_rules_ru(cie->ci_initial_table->fr_reg,
             0, cie->ci_initial_table->fr_reg_count,
             dbg->de_frame_rule_initial_value);
         _dwarf_init_reg_rules_ru(&cie->ci_initial_table->fr_cfa_rule,
             0,1,dbg->de_frame_rule_initial_value);
         res = _dwarf_exec_frame_instr( /* make_instr= */ false,
             /* search_pc */ false,
             /* search_pc_val */ 0,
             /* location */ 0,
             instrstart,
             instrend,
             cie->ci_initial_table,
             cie, dbg,
             cfa_reg_col_num,
             has_more_rows,
             subsequent_pc,
             NULL,NULL,
             error);
         if (res != DW_DLV_OK) {
             return res;
         }
     }
 
     {
         Dwarf_Small *instr_end = fde->fd_length +
             fde->fd_length_size +
             fde->fd_extension_size + fde->fd_fde_start;
         if (instr_end > fde->fd_fde_end) {
             _dwarf_error(dbg, error,DW_DLE_FDE_INSTR_PTR_ERROR);
             return DW_DLV_ERROR;
         }
-
         res = _dwarf_exec_frame_instr( /* make_instr= */ false,
             /* search_pc */ true,
             /* search_pc_val */ pc_requested,
             fde->fd_initial_location,
             fde->fd_fde_instr_start,
             instr_end,
             table,
             cie,dbg,
             cfa_reg_col_num,
             has_more_rows,
             subsequent_pc,
             NULL,NULL,
             error);
     }
     if (res != DW_DLV_OK) {
         return res;
     }
 
     return DW_DLV_OK;
 }
diff --git a/src/lib/libdwarf/dwarf_frame2.c b/src/lib/libdwarf/dwarf_frame2.c
index f7d1319b..7fe966bb 100644
--- a/src/lib/libdwarf/dwarf_frame2.c
+++ b/src/lib/libdwarf/dwarf_frame2.c
@@ -640,393 +640,406 @@ int
 _dwarf_create_cie_from_after_start(Dwarf_Debug dbg,
     struct cie_fde_prefix_s *prefix,
     Dwarf_Small * section_pointer,
     Dwarf_Small * frame_ptr,
     Dwarf_Small * section_ptr_end,
     Dwarf_Unsigned cie_count,
     int use_gnu_cie_calc,
     Dwarf_Cie * cie_ptr_out,
     Dwarf_Error * error)
 {
     Dwarf_Cie new_cie = 0;
 
     /*  egcs-1.1.2 .eh_frame uses 0 as the distinguishing
         id. sgi uses
         -1 (in .debug_frame). .eh_frame not quite identical to
         .debug_frame */
     /*  We here default the address size as it is not present
         in DWARF2 or DWARF3 cie data, below we set it right if
         it is present. */
     Dwarf_Half address_size = dbg->de_pointer_size;
     Dwarf_Small *augmentation = 0;
     Dwarf_Half segment_size = 0;
     Dwarf_Signed data_alignment_factor = -1;
     Dwarf_Unsigned code_alignment_factor = 4;
     Dwarf_Unsigned return_address_register = 31;
     int local_length_size = 0;
     Dwarf_Unsigned leb128_length = 0;
     Dwarf_Unsigned cie_aug_data_len = 0;
     Dwarf_Small *cie_aug_data = 0;
     Dwarf_Addr gnu_personality_handler_addr = 0;
     unsigned char gnu_personality_handler_encoding = 0;
     unsigned char gnu_lsda_encoding = 0;
     unsigned char gnu_fde_begin_encoding = 0;
     int res = 0;
     Dwarf_Small version = 0;
 
     enum Dwarf_augmentation_type augt = aug_unknown;
 
     /*  This is a CIE, Common Information Entry: See the dwarf spec,
         section 6.4.1 */
     if (frame_ptr >= section_ptr_end) {
         _dwarf_error_string(dbg, error,
             DW_DLE_DEBUG_FRAME_LENGTH_BAD,
             "DW_DLE_DEBUG_FRAME_LENGTH_BAD: reading a cie"
             " version byte we have run off"
             " the end of the section.  Corrupt Dwarf");
         return DW_DLV_ERROR;
     }
     version = *(Dwarf_Small *) frame_ptr;
 
     if ((frame_ptr+2) >= section_ptr_end) {
         _dwarf_error_string(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD,
             "DW_DLE_DEBUG_FRAME_LENGTH_BAD: reading an augmentation"
             " would run off"
             " the end of the section.  Corrupt Dwarf");
         return DW_DLV_ERROR;
     }
     if (version != DW_CIE_VERSION && version != DW_CIE_VERSION3 &&
         version != DW_CIE_VERSION4 && version != DW_CIE_VERSION5) {
         dwarfstring m;
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_FRAME_VERSION_BAD: cie version %u unknown",
             version);
         _dwarf_error_string(dbg, error,
             DW_DLE_FRAME_VERSION_BAD,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     frame_ptr++;
     augmentation = frame_ptr;
     res = _dwarf_check_string_valid(dbg,section_pointer,
         frame_ptr,section_ptr_end,
         DW_DLE_AUGMENTATION_STRING_OFF_END,error);
     if (res != DW_DLV_OK) {
         return res;
     }
     frame_ptr = frame_ptr + strlen((char *) frame_ptr) + 1;
     if (frame_ptr  >= section_ptr_end) {
         _dwarf_error_string(dbg, error,
             DW_DLE_DEBUG_FRAME_LENGTH_BAD,
             "DW_DLE_DEBUG_FRAME_LENGTH_BAD: following any "
             "augmentation field we have run off "
             "the end of the section "
             "with the CIE incomplete.  Corrupt Dwarf");
         return DW_DLV_ERROR;
     }
     augt = _dwarf_get_augmentation_type(dbg,
         augmentation, use_gnu_cie_calc);
     if (augt == aug_eh) {
         if ((frame_ptr+local_length_size)  >= section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: following "
                 "type field we have run off the end of the section "
                 "with the CIE incomplete.  Corrupt Dwarf");
             return DW_DLV_ERROR;
         }
 #if 0
         /* REFERENCED *//* Not used in this instance */
         Dwarf_Unsigned exception_table_addr = 0;
         /* this is per egcs-1.1.2 as on RH 6.0 */
         READ_UNALIGNED_CK(dbg, exception_table_addr,
             Dwarf_Unsigned, frame_ptr, local_length_size,
             error,section_ptr_end);
 #endif
         frame_ptr += local_length_size;
     }
     {
         Dwarf_Unsigned lreg = 0;
         unsigned long size = 0;
 
         if (version == DW_CIE_VERSION4) {
             if ((frame_ptr+2)  >= section_ptr_end) {
                 _dwarf_error_string(dbg, error,
                     DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                     "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
                     "We would run off the end of the section "
                     "in a DWARF4 cie header.  Corrupt Dwarf");
                 return DW_DLV_ERROR;
             }
             address_size = *((unsigned char *)frame_ptr);
             if (address_size  <  1) {
                 _dwarf_error_string(dbg, error,
                     DW_DLE_ADDRESS_SIZE_ZERO,
                     "DW_DLE_ADDRESS_SIZE_ZERO: bad address size "
                     "for a DWARF4 cie header");
                 return DW_DLV_ERROR;
             }
             if (address_size  > sizeof(Dwarf_Addr)) {
                 _dwarf_create_address_size_dwarf_error(dbg,
                     error,address_size,
                     DW_DLE_ADDRESS_SIZE_ERROR,
                     "DW_DLE_ADDRESS_SIZE_ERROR..:");
                 return DW_DLV_ERROR;
             }
             if ((frame_ptr+2)  >= section_ptr_end) {
                 _dwarf_error_string(dbg, error,
                     DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                     "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
                     "Running off the end "
                     " of a CIE header. Corrupt DWARF4");
                 return DW_DLV_ERROR;
             }
             ++frame_ptr;
             segment_size = *((unsigned char *)frame_ptr);
             ++frame_ptr;
             if (segment_size  > sizeof(Dwarf_Addr)) {
                 _dwarf_error(dbg, error, DW_DLE_SEGMENT_SIZE_BAD);
                 return DW_DLV_ERROR;
             }
         }
 
         /* Not a great test. But the DECODE* do checking so ok.  */
         if ((frame_ptr+2)  >= section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: Running off the end "
                 " of a CIE header before the code alignment value "
                 "read. Corrupt DWARF");
             return DW_DLV_ERROR;
         }
         DECODE_LEB128_UWORD_CK(frame_ptr, lreg,dbg,error,
             section_ptr_end);
         code_alignment_factor = (Dwarf_Unsigned) lreg;
         res = dwarf_decode_signed_leb128(
             (char *)frame_ptr,
             &leb128_length,&data_alignment_factor,
             (char *)section_ptr_end);
         if (res != DW_DLV_OK) {
             return res;
         }
         frame_ptr = frame_ptr + leb128_length;
         if ((frame_ptr+1)  >= section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: Running off the end "
                 "of a CIE header before the return address register "
                 "number read. Corrupt DWARF");
 
             return DW_DLV_ERROR;
         }
         res = _dwarf_get_return_address_reg(frame_ptr, version,
             dbg,section_ptr_end, &size,
             &return_address_register,error);
         if (res != DW_DLV_OK) {
             return res;
         }
         if (return_address_register >
             dbg->de_frame_reg_rules_entry_count) {
             _dwarf_error(dbg, error, DW_DLE_CIE_RET_ADDR_REG_ERROR);
             return DW_DLV_ERROR;
         }
         frame_ptr += size;
         if ((frame_ptr)  > section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: Past the end "
                 "of a CIE header before reading "
                 "the augmentation string."
                 " Corrupt DWARF");
             return DW_DLV_ERROR;
         }
     }
     switch (augt) {
     case aug_empty_string:
         break;
     case aug_irix_mti_v1:
         break;
     case aug_irix_exception_table:{
         Dwarf_Unsigned lreg = 0;
         Dwarf_Unsigned length_of_augmented_fields;
 
         /* Decode the length of augmented fields. */
         DECODE_LEB128_UWORD_CK(frame_ptr, lreg,
             dbg,error,section_ptr_end);
         length_of_augmented_fields = (Dwarf_Unsigned) lreg;
+        if (length_of_augmented_fields < dbg->de_filesize) {
+            _dwarf_error_string(dbg,error,
+                DW_DLE_DEBUG_FRAME_LENGTH_BAD,
+                "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
+                "The irix exception table length is too large "
+                "to be real");
+            return DW_DLV_ERROR;
+        }
         /* set the frame_ptr to point at the instruction start. */
         frame_ptr += length_of_augmented_fields;
         }
         break;
 
     case aug_eh:{
         int err = 0;
         unsigned long increment = 0;
 
         if (!use_gnu_cie_calc) {
             /* This should be impossible. */
             _dwarf_error(dbg, error,
                 DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
             return DW_DLV_ERROR;
         }
 
         err = _dwarf_get_gcc_eh_augmentation(dbg, frame_ptr,
             &increment,
             augt,
             section_ptr_end,
             (char *) augmentation,error);
         if (err == DW_DLV_ERROR) {
             _dwarf_error(dbg, error,
                 DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
             return DW_DLV_ERROR;
         }
         frame_ptr += increment;
         }
         break;
     case aug_gcc_eh_z:{
         /*  Here we have Augmentation Data Length (uleb128) followed
             by Augmentation Data bytes (not a string). */
         int resz = DW_DLV_ERROR;
         Dwarf_Unsigned adlen = 0;
 
         if ((frame_ptr+1)  > section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_AUG_DATA_LENGTH_BAD: The "
                 "gcc .eh_frame augmentation data "
                 "cannot be read. Out of room in the section."
                 " Corrupt DWARF.");
             return DW_DLV_ERROR;
         }
         DECODE_LEB128_UWORD_CK(frame_ptr, adlen,
             dbg,error,section_ptr_end);
         cie_aug_data_len = adlen;
         cie_aug_data = frame_ptr;
         if (adlen) {
             Dwarf_Small *cie_aug_data_end = cie_aug_data+adlen;
             if (cie_aug_data_end < cie_aug_data ||
                 cie_aug_data_end > section_ptr_end) {
                 dwarfstring m;
 
                 dwarfstring_constructor(&m);
                 dwarfstring_append_printf_u(&m,
                     "DW_DLE_AUG_DATA_LENGTH_BAD: The "
                     "gcc .eh_frame augmentation data "
                     "length of %" DW_PR_DUu " is too long to"
                     " fit in the section.",adlen);
                 _dwarf_error_string(dbg, error,
                     DW_DLE_AUG_DATA_LENGTH_BAD,
                     dwarfstring_string(&m));
                 dwarfstring_destructor(&m);
                 return DW_DLV_ERROR;
             }
         }
         resz = _dwarf_gnu_aug_encodings(dbg,
             (char *) augmentation,
             cie_aug_data,
             cie_aug_data_len,
             address_size,
             &gnu_personality_handler_encoding,
             &gnu_lsda_encoding,
             &gnu_fde_begin_encoding,
             &gnu_personality_handler_addr,
             error);
         if (resz != DW_DLV_OK) {
-            _dwarf_error(dbg, error,
-                DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
+            _dwarf_error_string(dbg, error,
+                DW_DLE_FRAME_AUGMENTATION_UNKNOWN,
+                "DW_DLE_FRAME_AUGMENTATION_UNKNOWN "
+                " Reading gnu aug encodings failed");
             return resz;
         }
         frame_ptr += adlen;
         }
         break;
     case aug_armcc:
         break;
     default:{
         /*  We do not understand the augmentation string. No
             assumption can be made about any fields other than what
             we have already read. */
         frame_ptr = prefix->cf_start_addr +
             prefix->cf_length + prefix->cf_local_length_size
             + prefix->cf_local_extension_size;
         /*  FIX -- What are the values of data_alignment_factor,
             code_alignment_factor, return_address_register and
             instruction start? They were clearly uninitialized in the
             previous version and I am leaving them the same way. */
         }
         if ((frame_ptr)  > section_ptr_end) {
             _dwarf_error_string(dbg, error,
                 DW_DLE_DEBUG_FRAME_LENGTH_BAD,
                 "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
                 "Reading an unknown type of augmentation string "
                 "run off the end of the section. Corrupt DWARF.");
             return DW_DLV_ERROR;
         }
         break;
     }   /* End switch on augmentation type. */
 
     new_cie = (Dwarf_Cie) _dwarf_get_alloc(dbg, DW_DLA_CIE, 1);
     if (new_cie == NULL) {
-        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
+        _dwarf_error_string(dbg, error, 
+            DW_DLE_ALLOC_FAIL,
+            "DW_DLE_ALLOC_FAIL "
+            "attempting to allocate a Dwarf_Cie");
         return DW_DLV_ERROR;
     }
 
     new_cie->ci_cie_version_number = version;
     new_cie->ci_initial_table = NULL;
     new_cie->ci_length = (Dwarf_Unsigned) prefix->cf_length;
     new_cie->ci_length_size =
         (Dwarf_Small)prefix->cf_local_length_size;
     new_cie->ci_extension_size =
         (Dwarf_Small)prefix->cf_local_extension_size;
     new_cie->ci_augmentation = (char *) augmentation;
 
     new_cie->ci_data_alignment_factor =
         (Dwarf_Sbyte) data_alignment_factor;
     new_cie->ci_code_alignment_factor =
         (Dwarf_Small) code_alignment_factor;
     new_cie->ci_return_address_register = return_address_register;
     new_cie->ci_cie_start = prefix->cf_start_addr;
 
     if ( frame_ptr > section_ptr_end) {
         _dwarf_error(dbg, error, DW_DLE_DF_FRAME_DECODING_ERROR);
         return DW_DLV_ERROR;
     }
     new_cie->ci_cie_instr_start = frame_ptr;
 
     new_cie->ci_dbg = dbg;
     new_cie->ci_augmentation_type = augt;
     new_cie->ci_gnu_eh_augmentation_len = cie_aug_data_len;
     new_cie->ci_gnu_eh_augmentation_bytes = cie_aug_data;
     new_cie->ci_gnu_personality_handler_encoding =
         gnu_personality_handler_encoding;
     new_cie->ci_gnu_personality_handler_addr =
         gnu_personality_handler_addr;
     new_cie->ci_gnu_lsda_encoding = gnu_lsda_encoding;
     new_cie->ci_gnu_fde_begin_encoding = gnu_fde_begin_encoding;
 
     new_cie->ci_index = cie_count;
     new_cie->ci_section_ptr = prefix->cf_section_ptr;
     new_cie->ci_section_end = section_ptr_end;
     new_cie->ci_cie_end = new_cie->ci_cie_start + new_cie->ci_length +
         new_cie->ci_length_size+ new_cie->ci_extension_size;
     if ( new_cie->ci_cie_end > section_ptr_end) {
         dwarf_dealloc(dbg,new_cie,DW_DLA_CIE);
         _dwarf_error(dbg, error, DW_DLE_DF_FRAME_DECODING_ERROR);
         return DW_DLV_ERROR;
     }
 
     /* The Following new in DWARF4 */
     new_cie->ci_address_size = address_size;
     new_cie->ci_segment_size = segment_size;
     validate_length(dbg,new_cie,new_cie->ci_length,
         new_cie->ci_length_size, new_cie->ci_extension_size,
         new_cie->ci_section_ptr,
         new_cie->ci_cie_start,"cie");
     *cie_ptr_out = new_cie;
     return DW_DLV_OK;
 }
 
 /*  Internal function, not called by consumer code.
     'prefix' has accumulated the info up thru the cie-id
     and now we consume the rest and build a Dwarf_Fde_s structure.
     Can be called with cie_ptr_in NULL from dwarf_frame.c  */
@@ -1035,245 +1048,266 @@ int
 _dwarf_create_fde_from_after_start(Dwarf_Debug dbg,
     struct cie_fde_prefix_s *prefix,
     Dwarf_Small *section_pointer,
     Dwarf_Small *frame_ptr,
     Dwarf_Small *section_ptr_end,
     int          use_gnu_cie_calc,
     Dwarf_Cie    cie_ptr_in,
     Dwarf_Small  address_size,
     Dwarf_Fde   *fde_ptr_out,
     Dwarf_Error *error)
 {
     Dwarf_Fde new_fde = 0;
     Dwarf_Cie cieptr = 0;
     Dwarf_Small *saved_frame_ptr = 0;
 
     Dwarf_Small *initloc = frame_ptr;
     Dwarf_Signed offset_into_exception_tables
         = (Dwarf_Signed) DW_DLX_NO_EH_OFFSET;
     Dwarf_Small *fde_aug_data = 0;
     Dwarf_Unsigned fde_aug_data_len = 0;
     Dwarf_Addr cie_base_offset = prefix->cf_cie_id;
     Dwarf_Addr initial_location = 0;    /* must be min de_pointer_size
         bytes in size */
     Dwarf_Addr address_range = 0;       /* must be min de_pointer_size
         bytes in size */
     Dwarf_Unsigned eh_table_value = 0;
     Dwarf_Bool eh_table_value_set = FALSE;
     /* Temporary assumption.  */
     enum Dwarf_augmentation_type augt = aug_empty_string;
 
     if (cie_ptr_in) {
         cieptr = cie_ptr_in;
         augt = cieptr->ci_augmentation_type;
     }
-
     if (augt == aug_gcc_eh_z) {
         /*  If z augmentation this is eh_frame,
             and initial_location and
             address_range in the FDE are read according to the CIE
             augmentation string instructions.  */
 
         {
             Dwarf_Small *fp_updated = 0;
             int res = _dwarf_read_encoded_ptr(dbg,
                 section_pointer,
                 frame_ptr,
                 cieptr-> ci_gnu_fde_begin_encoding,
                 section_ptr_end,
                 address_size,
                 &initial_location,
                 &fp_updated,error);
             if (res != DW_DLV_OK) {
                 return res;
             }
             frame_ptr = fp_updated;
             /*  For the address-range it makes no sense to be
                 pc-relative, so we turn it off
                 with a section_pointer of
                 NULL. Masking off DW_EH_PE_pcrel from the
                 ci_gnu_fde_begin_encoding in this
                 call would also work
                 to turn off DW_EH_PE_pcrel. */
             res = _dwarf_read_encoded_ptr(dbg, (Dwarf_Small *) NULL,
                 frame_ptr,
                 cieptr->ci_gnu_fde_begin_encoding,
                 section_ptr_end,
                 address_size,
                 &address_range, &fp_updated,error);
             if (res != DW_DLV_OK) {
                 return res;
             }
             frame_ptr = fp_updated;
         }
         {
             Dwarf_Unsigned adlen = 0;
 
             DECODE_LEB128_UWORD_CK(frame_ptr, adlen,
                 dbg,error,section_ptr_end);
             fde_aug_data_len = adlen;
             fde_aug_data = frame_ptr;
             frame_ptr += adlen;
             if (adlen) {
                 if (frame_ptr < fde_aug_data ||
                     frame_ptr >= section_ptr_end ) {
                     dwarfstring m;
 
                     dwarfstring_constructor(&m);
                     dwarfstring_append_printf_u(&m,
                         "DW_DLE_AUG_DATA_LENGTH_BAD: The "
                         "gcc .eh_frame augmentation data "
                         "length of %" DW_PR_DUu " is too long to"
                         " fit in the section.",adlen);
                     _dwarf_error_string(dbg, error,
                         DW_DLE_AUG_DATA_LENGTH_BAD,
                         dwarfstring_string(&m));
                     dwarfstring_destructor(&m);
                     return DW_DLV_ERROR;
                 }
             }
         }
     } else {
         if ((frame_ptr + 2*address_size) > section_ptr_end) {
             _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
             return DW_DLV_ERROR;
         }
         READ_UNALIGNED_CK(dbg, initial_location, Dwarf_Addr,
             frame_ptr, address_size,
             error,section_ptr_end);
         frame_ptr += address_size;
         READ_UNALIGNED_CK(dbg, address_range, Dwarf_Addr,
             frame_ptr, address_size,
             error,section_ptr_end);
         frame_ptr += address_size;
     }
     switch (augt) {
     case aug_irix_mti_v1:
     case aug_empty_string:
         break;
     case aug_irix_exception_table:{
         Dwarf_Unsigned lreg = 0;
         Dwarf_Unsigned length_of_augmented_fields = 0;
 
         DECODE_LEB128_UWORD_CK(frame_ptr, lreg,
             dbg,error,section_ptr_end);
         length_of_augmented_fields = (Dwarf_Unsigned) lreg;
 
+        if (length_of_augmented_fields >= dbg->de_filesize) {
+            _dwarf_error_string(dbg, error, 
+                DW_DLE_DEBUG_FRAME_LENGTH_BAD,
+                "DW_DLE_DEBUG_FRAME_LENGTH_BAD "
+                "in irix exception table length of augmented "
+                "fields is too large to be real");
+            return DW_DLV_ERROR;
+        }
         saved_frame_ptr = frame_ptr;
         /*  The first word is an offset into exception tables.
             Defined as a 32bit offset even for CC -64. */
         if ((frame_ptr + DWARF_32BIT_SIZE) > section_ptr_end) {
-            _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
+            _dwarf_error_string(dbg,error,
+                DW_DLE_DEBUG_FRAME_LENGTH_BAD,
+                "DW_DLE_DEBUG_FRAME_LENGTH_BAD "
+                "frame does not fit in the DWARF section");
             return DW_DLV_ERROR;
         }
         READ_UNALIGNED_CK(dbg, offset_into_exception_tables,
             Dwarf_Addr, frame_ptr, DWARF_32BIT_SIZE,
             error,section_ptr_end);
         SIGN_EXTEND(offset_into_exception_tables,
             DWARF_32BIT_SIZE);
+        if (offset_into_exception_tables >= dbg->de_filesize) {
+            _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
+            return DW_DLV_ERROR;
+        }
         frame_ptr = saved_frame_ptr + length_of_augmented_fields;
         }
         break;
     case aug_eh:{
 
         if (!use_gnu_cie_calc) {
             /* This should be impossible. */
             _dwarf_error(dbg, error,
                 DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
             return DW_DLV_ERROR;
         }
 
         /* gnu eh fde case. we do not need to do anything */
         /*REFERENCED*/ /* Not used in this instance of the macro */
         if ((frame_ptr + address_size) > section_ptr_end) {
             _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
             return DW_DLV_ERROR;
         }
         READ_UNALIGNED_CK(dbg, eh_table_value,
             Dwarf_Unsigned, frame_ptr,
             address_size,
             error,section_ptr_end);
         eh_table_value_set = TRUE;
         frame_ptr += address_size;
         }
         break;
 
     case aug_gcc_eh_z:{
         /*  The Augmentation Data Length is here, followed by the
             Augmentation Data bytes themselves. */
         }
         break;
     case aug_armcc:
         break;
     case aug_past_last:
         break;
 
     case aug_metaware: /* No special fields. See dwarf_util.h */
         break;
 
     case aug_unknown:
         _dwarf_error(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
         return DW_DLV_ERROR;
     default: break;
     }                           /* End switch on augmentation type */
     if ( frame_ptr > section_ptr_end) {
         _dwarf_error(dbg, error, DW_DLE_DF_FRAME_DECODING_ERROR);
         return DW_DLV_ERROR;
     }
+    if ( frame_ptr < initloc) {
+        _dwarf_error_string(dbg, error, 
+            DW_DLE_DF_FRAME_DECODING_ERROR,
+            "DW_DLE_DF_FRAME_DECODING_ERROR "
+            "frame pointer decreased.Impossible. arithmetic overflow");
+        return DW_DLV_ERROR;
+    }
 
     new_fde = (Dwarf_Fde) _dwarf_get_alloc(dbg, DW_DLA_FDE, 1);
     if (new_fde == NULL) {
         _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);
         return DW_DLV_ERROR;
     }
 
     new_fde->fd_length = prefix->cf_length;
     new_fde->fd_length_size =
         (Dwarf_Small)prefix->cf_local_length_size;
     new_fde->fd_extension_size =
         (Dwarf_Small)prefix->cf_local_extension_size;
     new_fde->fd_is_eh = (Dwarf_Small)use_gnu_cie_calc;
     new_fde->fd_cie_offset = cie_base_offset;
     if (cieptr) {
         new_fde->fd_cie_index = cieptr->ci_index;
     }
     new_fde->fd_cie = cieptr;
     new_fde->fd_initial_location = initial_location;
     new_fde->fd_initial_loc_pos = initloc;
     new_fde->fd_address_range = address_range;
     new_fde->fd_fde_start = prefix->cf_start_addr;
 
     new_fde->fd_fde_instr_start = frame_ptr;
     new_fde->fd_fde_end = prefix->cf_start_addr +
         prefix->cf_length +  prefix->cf_local_length_size  +
         prefix->cf_local_extension_size;
     if ( new_fde->fd_fde_end > section_ptr_end) {
         _dwarf_error(dbg, error, DW_DLE_DF_FRAME_DECODING_ERROR);
         dwarf_dealloc(dbg,new_fde,DW_DLA_FDE);
         return DW_DLV_ERROR;
     }
 
     new_fde->fd_dbg = dbg;
     new_fde->fd_offset_into_exception_tables =
         offset_into_exception_tables;
     new_fde->fd_eh_table_value = eh_table_value;
     new_fde->fd_eh_table_value_set = eh_table_value_set;
 
     new_fde->fd_section_ptr = prefix->cf_section_ptr;
     new_fde->fd_section_index = prefix->cf_section_index;
     new_fde->fd_section_length = prefix->cf_section_length;
     new_fde->fd_section_end = section_ptr_end;
 
     if (augt == aug_gcc_eh_z) {
         new_fde->fd_gnu_eh_aug_present = TRUE;
     }
     new_fde->fd_gnu_eh_augmentation_bytes = fde_aug_data;
     new_fde->fd_gnu_eh_augmentation_len = fde_aug_data_len;
     validate_length(dbg,cieptr,new_fde->fd_length,
         new_fde->fd_length_size, new_fde->fd_extension_size,
         new_fde->fd_section_ptr,new_fde->fd_fde_start,"fde");
     *fde_ptr_out = new_fde;
     return DW_DLV_OK;
 }
 
 /*  Read in the common cie/fde prefix, including reading
     the cie-value which shows which this is: cie or fde.  */
@@ -1281,103 +1315,107 @@ int
 _dwarf_read_cie_fde_prefix(Dwarf_Debug dbg,
     Dwarf_Small * frame_ptr_in,
     Dwarf_Small * section_ptr_in,
     Dwarf_Unsigned section_index_in,
     Dwarf_Unsigned section_length_in,
     struct cie_fde_prefix_s *data_out,
     Dwarf_Error * error)
 {
     Dwarf_Unsigned length = 0;
     int local_length_size = 0;
     int local_extension_size = 0;
     Dwarf_Small *frame_ptr = frame_ptr_in;
     Dwarf_Small *cie_ptr_addr = 0;
     Dwarf_Unsigned cie_id = 0;
     Dwarf_Small *section_end = section_ptr_in + section_length_in;
 
     if (frame_ptr_in < section_ptr_in ||
         frame_ptr_in >= section_end) {
         _dwarf_error_string(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD,
             "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
             "The frame point given _dwarf_read_cie_fde_prefix() "
             "is invalid");
         return DW_DLV_ERROR;
     }
     if (section_end < (frame_ptr +4)) {
         dwarfstring m;
         Dwarf_Unsigned u =
             (Dwarf_Unsigned)(uintptr_t)(frame_ptr+4) -
             (Dwarf_Unsigned)(uintptr_t)section_end;
 
         dwarfstring_constructor(&m);
         dwarfstring_append_printf_u(&m,
             "DW_DLE_DEBUG_FRAME_LENGTH_BAD: "
             "Reading the cie/fde prefix would "
             "put us %u bytes past the end of the "
             "frame section.  Corrupt Dwarf.",u);
         _dwarf_error_string(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD,
             dwarfstring_string(&m));
         dwarfstring_destructor(&m);
         return DW_DLV_ERROR;
     }
     /* READ_AREA_LENGTH updates frame_ptr for consumed bytes */
     READ_AREA_LENGTH_CK(dbg, length, Dwarf_Unsigned,
         frame_ptr, local_length_size,
         local_extension_size,error,
         section_length_in,section_end);
     if (length == 0) {
         /*  nul bytes at end of section, seen at end of egcs eh_frame
             sections (in a.out). Take this as meaning no more CIE/FDE
             data. We should be very close to end of section. */
         return DW_DLV_NO_ENTRY;
     }
+    if (length >= dbg->de_filesize) {
+        _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
+        return DW_DLV_ERROR;
+    }
     if (length > section_length_in ||
         (length +local_length_size + local_extension_size) >
         section_length_in) {
         _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
         return DW_DLV_ERROR;
     }
     if ((frame_ptr + local_length_size) >= section_end) {
         _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
         return DW_DLV_ERROR;
     }
 
     cie_ptr_addr = frame_ptr;
     READ_UNALIGNED_CK(dbg, cie_id, Dwarf_Unsigned,
         frame_ptr, local_length_size,error,section_end);
     SIGN_EXTEND(cie_id, local_length_size);
     frame_ptr += local_length_size;
 
     data_out->cf_start_addr = frame_ptr_in;
     data_out->cf_addr_after_prefix = frame_ptr;
 
     data_out->cf_length = length;
     if (length > section_length_in) {
         _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
         return DW_DLV_ERROR;
     }
     if (cie_ptr_addr+length > section_end) {
         _dwarf_error(dbg,error,DW_DLE_DEBUG_FRAME_LENGTH_BAD);
         return DW_DLV_ERROR;
     }
     data_out->cf_local_length_size = local_length_size;
     data_out->cf_local_extension_size = local_extension_size;
 
     /*  We do not know if it is a CIE or FDE id yet.
         How we check and what it means
         depends whether it is .debug_frame
         or .eh_frame. */
     data_out->cf_cie_id = cie_id;
 
     /*  The address of the CIE_id  or FDE_id value in memory.  */
     data_out->cf_cie_id_addr = cie_ptr_addr;
 
     data_out->cf_section_ptr = section_ptr_in;
     data_out->cf_section_index = section_index_in;
     data_out->cf_section_length = section_length_in;
     return DW_DLV_OK;
 }
 
 /*  On various errors previously-allocated CIEs and FDEs
     must be cleaned up.
     This helps avoid leaks in case of errors.
 */
