commit 2616a929064f1ca9509813ed4c29e967c00ec824
Author: Greg Landrum <greg.landrum@gmail.com>
Date:   Wed Jan 26 08:52:10 2022 +0100

    Support CXSMILES/CXSMARTS for reactions (#4895)
    
    * start with some basic tests
    these currently fail, of course
    
    * prep work
    
    * minor refactoring and prep work
    
    * get better at handling spaces
    
    * first pass, needs completion and testing
    loads more testing required
    coordinate bonds don't work at all yet
    I'm suspicious about the SGroup hierarchy
    
    * more progress
    agents and products are now parsed
    more testing added
    way more testing needed
    
    * correctly ignore names
    test cleanup
    
    * more sgroup improvements and testing
    now I think most everything is there and the basics are tested
    
    * all tests pass
    
    * link nodes and variable attachment points
    
    * more cleanup and testing
    
    * changes in response to review

diff --git a/Code/GraphMol/ChemReactions/DaylightParser.cpp b/Code/GraphMol/ChemReactions/DaylightParser.cpp
index dc192af6f..f915ae488 100644
--- a/Code/GraphMol/ChemReactions/DaylightParser.cpp
+++ b/Code/GraphMol/ChemReactions/DaylightParser.cpp
@@ -1,41 +1,43 @@
 //
 //  Copyright (c) 2007-2021, Novartis Institutes for BioMedical Research Inc.
 //  and other RDKit contributors
 //  All rights reserved.
 //
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are
 // met:
 //
 //     * Redistributions of source code must retain the above copyright
 //       notice, this list of conditions and the following disclaimer.
 //     * Redistributions in binary form must reproduce the above
 //       copyright notice, this list of conditions and the following
 //       disclaimer in the documentation and/or other materials provided
 //       with the distribution.
 //     * Neither the name of Novartis Institutes for BioMedical Research Inc.
 //       nor the names of its contributors may be used to endorse or promote
 //       products derived from this software without specific prior written
 //       permission.
 //
 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 //
 
 #include <GraphMol/ChemReactions/Reaction.h>
 #include <GraphMol/ChemReactions/ReactionParser.h>
 #include <GraphMol/SmilesParse/SmilesParse.h>
+#include <GraphMol/SmilesParse/SmilesParseOps.h>
+#include <boost/range/iterator_range.hpp>
 
 #include <boost/algorithm/string.hpp>
 #include <vector>
 #include <string>
 #include "ReactionUtils.h"
@@ -91,134 +93,220 @@ std::vector<std::string> splitSmartsIntoComponents(
 ROMol *constructMolFromString(const std::string &txt,
                               std::map<std::string, std::string> *replacements,
                               bool useSmiles) {
   ROMol *mol;
   if (!useSmiles) {
     SmartsParserParams ps;
     ps.replacements = replacements;
     ps.allowCXSMILES = false;
     ps.parseName = false;
     ps.mergeHs = false;
+    ps.skipCleanup = true;
     mol = SmartsToMol(txt, ps);
   } else {
     SmilesParserParams ps;
     ps.replacements = replacements;
     ps.allowCXSMILES = false;
     ps.parseName = false;
     ps.sanitize = false;
     ps.removeHs = false;
+    ps.skipCleanup = true;
     mol = SmilesToMol(txt, ps);
   }
   return mol;
 }
 
 }  // end of namespace DaylightParserUtils
 
+namespace {
+void removeSpacesAround(std::string &text, size_t pos) {
+  auto nextp = pos + 1;
+  while (nextp < text.size() && (text[nextp] == ' ' || text[nextp] == '\t')) {
+    text.erase(nextp, 1);
+  }
+  if (pos > 0) {
+    nextp = pos - 1;
+    while (text[nextp] == ' ' || text[nextp] == '\t') {
+      text.erase(nextp, 1);
+      if (nextp > 0) {
+        --nextp;
+      } else {
+        break;
+      }
+    }
+  }
+}
+}  // namespace
 ChemicalReaction *RxnSmartsToChemicalReaction(
-    const std::string &text, std::map<std::string, std::string> *replacements,
-    bool useSmiles) {
+    const std::string &origText,
+    std::map<std::string, std::string> *replacements, bool useSmiles,
+    bool allowCXSMILES) {
+  std::string text = origText;
+  std::string cxPart;
+  if (allowCXSMILES) {
+    auto sidx = origText.find_first_of("|");
+    if (sidx != std::string::npos && sidx != 0) {
+      text = origText.substr(0, sidx);
+      cxPart = boost::trim_copy(origText.substr(sidx, origText.size() - sidx));
+    }
+  }
+  // remove any spaces at the beginning, end, or before the '>'s
+  boost::trim(text);
   std::vector<std::size_t> pos;
-
   for (std::size_t i = 0; i < text.length(); ++i) {
     if (text[i] == '>' && (i == 0 || text[i - 1] != '-')) {
       pos.push_back(i);
     }
   }
-
   if (pos.size() < 2) {
     throw ChemicalReactionParserException(
         "a reaction requires at least two > characters");
   }
 
-  std::size_t pos1 = pos[0];
-  std::size_t pos2 = pos[1];
+  // remove spaces around ">" symbols
+  for (auto p : boost::make_iterator_range(pos.rbegin(), pos.rend())) {
+    removeSpacesAround(text, p);
+  }
+
+  // remove spaces around "." symbols
+  pos.clear();
+  for (std::size_t i = 0; i < text.length(); ++i) {
+    if (text[i] == '.') {
+      pos.push_back(i);
+    }
+  }
+  for (auto p : boost::make_iterator_range(pos.rbegin(), pos.rend())) {
+    removeSpacesAround(text, p);
+  }
+
+  // we shouldn't have whitespace left in the reaction string, so go ahead and
+  // split and strip:
+  auto sidx = text.find_first_of(" \t");
+  if (sidx != std::string::npos && sidx != 0) {
+    text = text.substr(0, sidx);
+  }
+
+  // re-find the '>' characters so that we can split on them
+  pos.clear();
+  for (std::size_t i = 0; i < text.length(); ++i) {
+    if (text[i] == '>' && (i == 0 || text[i - 1] != '-')) {
+      pos.push_back(i);
+    }
+  }
 
+  // there's always the chance that one or more of the ">" was in the name
+  // part, so verify that we have exactly two:
+  if (pos.size() < 2) {
+    throw ChemicalReactionParserException(
+        "a reaction requires at least two > characters");
+  }
   if (pos.size() > 2) {
     throw ChemicalReactionParserException("multi-step reactions not supported");
   }
 
-  std::string reactText = text.substr(0, pos1);
+  auto pos1 = pos[0];
+  auto pos2 = pos[1];
+
+  auto reactText = text.substr(0, pos1);
   std::string agentText;
   if (pos2 != pos1 + 1) {
     agentText = text.substr(pos1 + 1, (pos2 - pos1) - 1);
   }
-  std::string productText = text.substr(pos2 + 1);
+  auto productText = text.substr(pos2 + 1);
 
   // recognize changes within the same molecules, e.g., intra molecular bond
-  // formation
-  // therefore we need to correctly interpret parenthesis and dots in the
-  // reaction smarts
-  std::vector<std::string> reactSmarts =
-      DaylightParserUtils::splitSmartsIntoComponents(reactText);
-  std::vector<std::string> productSmarts =
+  // formation therefore we need to correctly interpret parenthesis and dots
+  // in the reaction smarts
+  auto reactSmarts = DaylightParserUtils::splitSmartsIntoComponents(reactText);
+  auto productSmarts =
       DaylightParserUtils::splitSmartsIntoComponents(productText);
 
-  // if the input includes CX extensions, they will show up here after the
-  // last product. We can't currently deal with those, so issue a warning and
-  // strip out anything following the last productSmarts
-  // This was Github #4759
-  if (!productSmarts.empty()) {
-    auto &lastSmarts = productSmarts.back();
-    boost::trim(lastSmarts);
-    std::vector<std::string> tokens;
-    boost::split(tokens, lastSmarts, boost::is_any_of(" \t"));
-    if (tokens.size() > 1) {
-      auto fromWhat = useSmiles ? "SMILES" : "SMARTS";
-      BOOST_LOG(rdWarningLog)
-          << "stripping extra text from input " << fromWhat << std::endl;
-      lastSmarts = tokens[0];
-    }
-  }
-
   auto *rxn = new ChemicalReaction();
 
   for (const auto &txt : reactSmarts) {
-    ROMol *mol;
-    mol = DaylightParserUtils::constructMolFromString(txt, replacements,
-                                                      useSmiles);
+    auto mol = DaylightParserUtils::constructMolFromString(txt, replacements,
+                                                           useSmiles);
     if (!mol) {
       std::string errMsg = "Problems constructing reactant from SMARTS: ";
       errMsg += txt;
       delete rxn;
       throw ChemicalReactionParserException(errMsg);
     }
     rxn->addReactantTemplate(ROMOL_SPTR(mol));
   }
 
   for (const auto &txt : productSmarts) {
-    ROMol *mol;
-    mol = DaylightParserUtils::constructMolFromString(txt, replacements,
-                                                      useSmiles);
+    auto mol = DaylightParserUtils::constructMolFromString(txt, replacements,
+                                                           useSmiles);
     if (!mol) {
       std::string errMsg = "Problems constructing product from SMARTS: ";
       errMsg += txt;
       delete rxn;
       throw ChemicalReactionParserException(errMsg);
     }
     rxn->addProductTemplate(ROMOL_SPTR(mol));
   }
   updateProductsStereochem(rxn);
 
-  ROMol *agentMol;
   // allow a reaction template to have no agent specified
   if (agentText.size() != 0) {
-    agentMol = DaylightParserUtils::constructMolFromString(
+    auto agentMol = DaylightParserUtils::constructMolFromString(
         agentText, replacements, useSmiles);
     if (!agentMol) {
       std::string errMsg = "Problems constructing agent from SMARTS: ";
       errMsg += agentText;
       delete rxn;
       throw ChemicalReactionParserException(errMsg);
     }
     std::vector<ROMOL_SPTR> agents = MolOps::getMolFrags(*agentMol, false);
     delete agentMol;
     for (auto &agent : agents) {
       rxn->addAgentTemplate(agent);
     }
   }
 
+  if (allowCXSMILES && !cxPart.empty()) {
+    unsigned int startAtomIdx = 0;
+    unsigned int startBondIdx = 0;
+    for (auto &mol : boost::make_iterator_range(rxn->beginReactantTemplates(),
+                                                rxn->endReactantTemplates())) {
+      SmilesParseOps::parseCXExtensions(*static_cast<RWMol *>(mol.get()),
+                                        cxPart, startAtomIdx, startBondIdx);
+      startAtomIdx += mol->getNumAtoms();
+      startBondIdx += mol->getNumBonds();
+    }
+    for (auto &mol : boost::make_iterator_range(rxn->beginAgentTemplates(),
+                                                rxn->endAgentTemplates())) {
+      SmilesParseOps::parseCXExtensions(*static_cast<RWMol *>(mol.get()),
+                                        cxPart, startAtomIdx, startBondIdx);
+      startAtomIdx += mol->getNumAtoms();
+      startBondIdx += mol->getNumBonds();
+    }
+    for (auto &mol : boost::make_iterator_range(rxn->beginProductTemplates(),
+                                                rxn->endProductTemplates())) {
+      SmilesParseOps::parseCXExtensions(*static_cast<RWMol *>(mol.get()),
+                                        cxPart, startAtomIdx, startBondIdx);
+      startAtomIdx += mol->getNumAtoms();
+      startBondIdx += mol->getNumBonds();
+    }
+  }
+
+  // final cleanups:
+  for (auto &mol : boost::make_iterator_range(rxn->beginReactantTemplates(),
+                                              rxn->endReactantTemplates())) {
+    SmilesParseOps::CleanupAfterParsing(static_cast<RWMol *>(mol.get()));
+  }
+  for (auto &mol : boost::make_iterator_range(rxn->beginAgentTemplates(),
+                                              rxn->endAgentTemplates())) {
+    SmilesParseOps::CleanupAfterParsing(static_cast<RWMol *>(mol.get()));
+  }
+  for (auto &mol : boost::make_iterator_range(rxn->beginProductTemplates(),
+                                              rxn->endProductTemplates())) {
+    SmilesParseOps::CleanupAfterParsing(static_cast<RWMol *>(mol.get()));
+  }
+
   // "SMARTS"-based reactions have implicit properties
   rxn->setImplicitPropertiesFlag(true);
 
   return rxn;
 }
 }  // namespace RDKit
diff --git a/Code/GraphMol/ChemReactions/ReactionParser.h b/Code/GraphMol/ChemReactions/ReactionParser.h
index 6eb39f576..efd2dfeaf 100644
--- a/Code/GraphMol/ChemReactions/ReactionParser.h
+++ b/Code/GraphMol/ChemReactions/ReactionParser.h
@@ -1,44 +1,46 @@
 //
-//  Copyright (c) 2007-2014, Novartis Institutes for BioMedical Research Inc.
+//  Copyright (c) 2007-2022, Novartis Institutes for BioMedical Research Inc.
+//  and other RDKit contributors
+//
 //  All rights reserved.
 //
 // Redistribution and use in source and binary forms, with or without
 // modification, are permitted provided that the following conditions are
 // met:
 //
 //     * Redistributions of source code must retain the above copyright
 //       notice, this list of conditions and the following disclaimer.
 //     * Redistributions in binary form must reproduce the above
 //       copyright notice, this list of conditions and the following
 //       disclaimer in the documentation and/or other materials provided
 //       with the distribution.
 //     * Neither the name of Novartis Institutes for BioMedical Research Inc.
 //       nor the names of its contributors may be used to endorse or promote
 //       products derived from this software without specific prior written
 //       permission.
 //
 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 //
 
 #include <RDGeneral/export.h>
 #ifndef RD_REACTIONPARSER_H_21Aug2006
 #define RD_REACTIONPARSER_H_21Aug2006
 
 #include <string>
 #include <iostream>
 #include <fstream>
 #include <sstream>
 #include <utility>
 #include <boost/format.hpp>
 #include <RDGeneral/BadFileException.h>
 #include <RDGeneral/FileParseException.h>
@@ -49,41 +51,45 @@ class ChemicalReaction;
 //! used to indicate an error in parsing reaction data
 class RDKIT_CHEMREACTIONS_EXPORT ChemicalReactionParserException
     : public std::exception {
  public:
   //! construct with an error message
   explicit ChemicalReactionParserException(const char *msg) : _msg(msg) {}
   //! construct with an error message
   explicit ChemicalReactionParserException(std::string msg)
       : _msg(std::move(msg)) {}
   //! get the error message
   const char *what() const noexcept override { return _msg.c_str(); }
   ~ChemicalReactionParserException() noexcept override = default;
 
  private:
   std::string _msg;
 };
 
 //---------------------------------------------------------------------------
 //! \name Reaction SMARTS/SMILES Support
 //@{
 
 //! Parse a string containing "Reaction SMARTS" into a ChemicalReaction
 /*!
-   Our definition of Reaction SMARTS is something that looks a lot like
-   reaction SMILES, except that SMARTS queries are allowed on the reactant
-   side and that atom-map numbers are required (at least for now)
+   Our definition of Reaction SMARTS is something that looks a lot like reaction
+   SMILES, except that SMARTS queries are allowed on the reactant side and that
+   atom-map numbers are required (at least for now)
 
    \param text          the SMARTS to convert
-   \param replacements  a string->string map of replacement strings.
-                        \see SmilesToMol for more information about replacements
+
+   \param replacements  a string->string map of replacement strings. \see
+   SmilesToMol for more information about replacements
+
    \param useSmiles     if set, the SMILES parser will be used instead of the
-   SMARTS
-                         parserfor the individual components
+   SMARTS parserfor the individual components
+
+   \param allowCXSMILES     if set, any CXSMILES extensions present will be
+   parsed, otherwise it will be ignored
  */
 RDKIT_CHEMREACTIONS_EXPORT ChemicalReaction *RxnSmartsToChemicalReaction(
     const std::string &text,
     std::map<std::string, std::string> *replacements = nullptr,
-    bool useSmiles = false);
+    bool useSmiles = false, bool allowCXSMILES = true);
 
 //! returns the reaction SMARTS for a reaction
 RDKIT_CHEMREACTIONS_EXPORT std::string ChemicalReactionToRxnSmarts(
@@ -92,18 +98,17 @@ RDKIT_CHEMREACTIONS_EXPORT std::string ChemicalReactionToRxnSmarts(
 //! returns the reaction SMILES for a reaction
 RDKIT_CHEMREACTIONS_EXPORT std::string ChemicalReactionToRxnSmiles(
     const ChemicalReaction &rxn, bool canonical = true);
 //@}
 
 //---------------------------------------------------------------------------
 //! \name Reaction Mol Support
 //@{
 
 //! Parse a ROMol into a ChemicalReaction, RXN role must be set before
 /*!
    Alternative to build a reaction from a molecule (fragments) which have RXN
-   roles
-   set as atom properties: common_properties::molRxnRole (1=reactant, 2=product,
-   3=agent)
+   roles set as atom properties: common_properties::molRxnRole (1=reactant,
+   2=product, 3=agent)
 
    \param mol           ROMol with RXN roles set
  */
@@ -128,15 +133,16 @@ RDKIT_CHEMREACTIONS_EXPORT ChemicalReaction *RxnFileToChemicalReaction(
     const std::string &fileName, bool sanitize = false, bool removeHs = false,
     bool strictParsing = true);
 //! Parse a text stream in MDL rxn format into a ChemicalReaction
 RDKIT_CHEMREACTIONS_EXPORT ChemicalReaction *RxnDataStreamToChemicalReaction(
     std::istream &rxnStream, unsigned int &line, bool sanitize = false,
     bool removeHs = false, bool strictParsing = true);
 //! returns an rxn block for a reaction
 /*!
    \param rxn            chemical reaction
+
    \param separateAgents flag to decide if agents were put in a separate block,
                          otherwise they were included in the reactants block
-   (default)
+                         (default)
  */
 RDKIT_CHEMREACTIONS_EXPORT std::string ChemicalReactionToRxnBlock(
     const ChemicalReaction &rxn, bool separateAgents = false);
@@ -230,25 +236,25 @@ inline std::unique_ptr<ChemicalReaction> operator"" _rxnsmarts(const char *text,
                                                                size_t len) {
   std::string sma(text, len);
   ChemicalReaction *ptr = nullptr;
   try {
     ptr = RxnSmartsToChemicalReaction(sma);
   } catch (...) {
     ptr = nullptr;
   }
   return std::unique_ptr<ChemicalReaction>(ptr);
 }
 inline std::unique_ptr<ChemicalReaction> operator"" _rxnsmiles(const char *text,
                                                                size_t len) {
   std::string sma(text, len);
   ChemicalReaction *ptr = nullptr;
   try {
     ptr = RxnSmartsToChemicalReaction(sma, nullptr, true);
   } catch (...) {
     ptr = nullptr;
   }
   return std::unique_ptr<ChemicalReaction>(ptr);
 }
 
-};  // namespace RDKit
+}  // namespace RDKit
 
 #endif
diff --git a/Code/GraphMol/ChemReactions/catch_tests.cpp b/Code/GraphMol/ChemReactions/catch_tests.cpp
index a6d97d5ca..3c4223e8e 100644
--- a/Code/GraphMol/ChemReactions/catch_tests.cpp
+++ b/Code/GraphMol/ChemReactions/catch_tests.cpp
@@ -979,28 +979,202 @@ TEST_CASE("one-component reactions") {
 TEST_CASE("Github #4759 Reaction parser fails when CX extensions are present") {
   std::string sma = "[C:1]Br.[C:2]O>>[C:2][C:1] |$Aryl;;;;;Aryl$|";
   SECTION("SMARTS") {
     std::unique_ptr<ChemicalReaction> rxn(RxnSmartsToChemicalReaction(sma));
     REQUIRE(rxn);
     // make sure we have a product and that it didn't end up with a name:
     CHECK(rxn->getProducts().size() == 1);
     CHECK(!rxn->getProducts()[0]->hasProp(common_properties::_Name));
     CHECK(rxn->getProducts()[0]->getNumAtoms() == 2);
+    CHECK(rxn->getProducts()[0]->getAtomWithIdx(1)->hasProp(
+        common_properties::atomLabel));
+    CHECK(rxn->getProducts()[0]->getAtomWithIdx(1)->getProp<std::string>(
+              common_properties::atomLabel) == "Aryl");
+    CHECK(rxn->getReactants()[0]->getAtomWithIdx(0)->hasProp(
+        common_properties::atomLabel));
+    CHECK(rxn->getReactants()[0]->getAtomWithIdx(0)->getProp<std::string>(
+              common_properties::atomLabel) == "Aryl");
   }
   SECTION("SMILES") {
+    bool useSmiles = true;
     std::unique_ptr<ChemicalReaction> rxn(
-        RxnSmartsToChemicalReaction(sma, nullptr, true));
+        RxnSmartsToChemicalReaction(sma, nullptr, useSmiles));
     REQUIRE(rxn);
     CHECK(rxn->getProducts().size() == 1);
     CHECK(!rxn->getProducts()[0]->hasProp(common_properties::_Name));
     CHECK(rxn->getProducts()[0]->getNumAtoms() == 2);
   }
-  SECTION("Ensure we still handle spaces before/after the >>") {
-    std::string sma2 = "[C:1]Br.[C:2]O >> [C:2][C:1] |$Aryl;;;;;Aryl$|";
-    std::unique_ptr<ChemicalReaction> rxn(RxnSmartsToChemicalReaction(sma2));
+  SECTION("disabling CXSMILES") {
+    bool useSmiles = false;
+    bool allowCXSMILES = false;
+    std::unique_ptr<ChemicalReaction> rxn(
+        RxnSmartsToChemicalReaction(sma, nullptr, useSmiles, allowCXSMILES));
     REQUIRE(rxn);
+    CHECK(rxn->getProducts().size() == 1);
+    CHECK(!rxn->getProducts()[0]->hasProp(common_properties::_Name));
+    CHECK(rxn->getProducts()[0]->getNumAtoms() == 2);
+    CHECK(!rxn->getProducts()[0]->getAtomWithIdx(1)->hasProp(
+        common_properties::atomLabel));
+    CHECK(!rxn->getReactants()[0]->getAtomWithIdx(0)->hasProp(
+        common_properties::atomLabel));
+  }
+  SECTION("Ensure we still handle spaces before/after the >>") {
+    auto rxn = " [C:1]Br.[C:2]O >> [C:2][C:1] |$Aryl;;;;;Aryl$|"_rxnsmarts;
     // make sure we have a product and that it didn't end up with a name:
     CHECK(rxn->getProducts().size() == 1);
     CHECK(!rxn->getProducts()[0]->hasProp(common_properties::_Name));
     CHECK(rxn->getProducts()[0]->getNumAtoms() == 2);
   }
+  SECTION("advanced space removal") {
+    // clang-format off
+    auto rxn =
+        " [C:1]Br  . [C:2]O    >  CCO  > [C:2][C:1] .   [Cl]    |$Aryl;;;;;Aryl$|"_rxnsmarts;
+    // clang-format n
+    REQUIRE(rxn);
+    CHECK(rxn->getReactants().size() == 2);
+    CHECK(rxn->getAgents().size() ==1);
+    // make sure we have a product and that it didn't end up with a name:
+    CHECK(rxn->getProducts().size() == 2);
+    CHECK(!rxn->getProducts()[0]->hasProp(common_properties::_Name));
+    CHECK(rxn->getProducts()[0]->getNumAtoms() == 2);
+  }
+  SECTION("not a cxsmiles") {
+    // clang-format off
+    auto rxn =
+        "[C:1]Br.[C:2]O>CCO>[C:2][C:1].[Cl]  reaction_name"_rxnsmarts;
+    // clang-format n
+    REQUIRE(rxn);
+    CHECK(rxn->getReactants().size() == 2);
+    CHECK(rxn->getAgents().size() ==1);
+    // make sure we have a product and that it didn't end up with a name:
+    CHECK(rxn->getProducts().size() == 2);
+    CHECK(!rxn->getProducts()[0]->hasProp(common_properties::_Name));
+    CHECK(rxn->getProducts()[0]->getNumAtoms() == 2);
+  }
+}
+
+TEST_CASE("CXSMILES for reactions", "[cxsmiles]") {
+  SECTION("basics") {
+    // clang-format off
+    auto rxn = "[CH3:1][CH:2]([CH3:3])[*:4].[OH:5][CH2:6][*:7]>>[CH3:1][CH:2]([CH3:3])[CH2:6][OH:5] |$;;;_AP1;;;_AP1;;;;;$|"_rxnsmarts;
+    // clang-format on
+    REQUIRE(rxn);
+    CHECK(rxn->getReactants().size() == 2);
+    std::string alabel;
+    CHECK(rxn->getReactants()[0]->getAtomWithIdx(3)->getPropIfPresent(
+        common_properties::atomLabel, alabel));
+    CHECK(alabel == "_AP1");
+    CHECK(rxn->getReactants()[1]->getAtomWithIdx(2)->getPropIfPresent(
+        common_properties::atomLabel, alabel));
+    CHECK(alabel == "_AP1");
+  }
+  SECTION("basics with agents") {
+    // clang-format off
+    auto rxn = "[CH3:1][CH:2]([CH3:3])[*:4].[OH:5][CH2:6][*:7]>O=C=O>[CH3:1][CH:2]([CH3:3])[CH2:6][OH:5] |$;;;_AP1;;;_AP1;;;;;;;;$|"_rxnsmarts;
+    // clang-format on
+    REQUIRE(rxn);
+    CHECK(rxn->getReactants().size() == 2);
+    std::string alabel;
+    CHECK(rxn->getReactants()[0]->getAtomWithIdx(3)->getPropIfPresent(
+        common_properties::atomLabel, alabel));
+    CHECK(alabel == "_AP1");
+    CHECK(rxn->getReactants()[1]->getAtomWithIdx(2)->getPropIfPresent(
+        common_properties::atomLabel, alabel));
+    CHECK(alabel == "_AP1");
+  }
+  SECTION("missing products") {
+    // clang-format off
+    auto rxn="[CH3:1][CH:2]([CH3:3])[*:4].[OH:5][CH2:6][*:7]>> |$;;;_AP1;;;_AP1$|"_rxnsmarts;
+    // clang-format on
+    REQUIRE(rxn);
+    CHECK(rxn->getReactants().size() == 2);
+    std::string alabel;
+    CHECK(rxn->getReactants()[0]->getAtomWithIdx(3)->getPropIfPresent(
+        common_properties::atomLabel, alabel));
+    CHECK(alabel == "_AP1");
+    CHECK(rxn->getReactants()[1]->getAtomWithIdx(2)->getPropIfPresent(
+        common_properties::atomLabel, alabel));
+    CHECK(alabel == "_AP1");
+  }
+  SECTION("coordinate bonds and sgroups") {
+    // when initially writing this, coordinate bonds were not properly parsed
+    // from SMARTS, so we use SMILES
+    // clang-format off
+    auto rxn = "[CH3:1][CH:2]([CH3:3])[*:4].[Fe:8][OH:5][CH2:6][*:7]>>[Fe:8][OH:5][CH2:6][CH2:1][CH:2]([CH3:3])[*:4] "
+    "|$;;;_AP1;;;;_AP1;;;;;;;_AP1$,C:5.3,9.6,SgD:6:foo:bar::::,SgD:10:bar:baz::::|"_rxnsmiles;
+    // clang-format on
+    REQUIRE(rxn);
+    CHECK(rxn->getReactants().size() == 2);
+    CHECK(rxn->getProducts().size() == 1);
+    std::string alabel;
+    CHECK(rxn->getReactants()[0]->getAtomWithIdx(3)->getPropIfPresent(
+        common_properties::atomLabel, alabel));
+    CHECK(alabel == "_AP1");
+    CHECK(rxn->getReactants()[1]->getAtomWithIdx(3)->getPropIfPresent(
+        common_properties::atomLabel, alabel));
+    CHECK(alabel == "_AP1");
+    CHECK(getSubstanceGroups(*rxn->getReactants()[0]).empty());
+    CHECK(getSubstanceGroups(*rxn->getReactants()[1]).size() == 1);
+
+    const auto p0 = rxn->getProducts()[0];
+    CHECK(p0->getAtomWithIdx(6)->getPropIfPresent(common_properties::atomLabel,
+                                                  alabel));
+    CHECK(alabel == "_AP1");
+    CHECK(getSubstanceGroups(*p0).size() == 1);
+  }
+  SECTION("sgroup hierarchy") {
+    // clang-format off
+    auto rxn = "[CH3:6][O:5][CH:3](-*)[O:2]-*>>[CH3:6][NH:5][CH:3](-*)[O:2]-* "
+    "|$;;;star_e;;star_e;;;;star_e;;star_e$,SgD:1,0:foo:bar::::,SgD:7,6:foo:baz::::,Sg:n:4,2,1,0::ht,Sg:n:10,8,7,6::ht,SgH:2:0,3:1|"_rxnsmiles;
+    // clang-format on
+    REQUIRE(rxn);
+    CHECK(getSubstanceGroups(*rxn->getReactants()[0]).size() == 2);
+    CHECK(getSubstanceGroups(*rxn->getProducts()[0]).size() == 2);
+  }
+  SECTION("link nodes") {
+    // clang-format off
+    auto rxn = "CO.OC1CCC(F)C1>>COC1CC(O)CC1F |LN:3:1.3.4.8,13:2.5.12.15|"_rxnsmarts;
+    // clang-format on
+    REQUIRE(rxn);
+    CHECK(rxn->getReactants().size() == 2);
+    CHECK(rxn->getProducts().size() == 1);
+    CHECK(
+        !rxn->getReactants()[0]->hasProp(common_properties::molFileLinkNodes));
+    std::string lns;
+    CHECK(rxn->getReactants()[1]->getPropIfPresent(
+        common_properties::molFileLinkNodes, lns));
+    CHECK(lns == "1 3 2 2 3 2 7");
+    CHECK(rxn->getProducts()[0]->getPropIfPresent(
+        common_properties::molFileLinkNodes, lns));
+    CHECK(lns == "2 5 2 5 4 5 7");
+  }
+#if 1
+  // note that these only work with the current parser if the
+  // variable-attachment point part is grouped with the molecule it's attached
+  // to. This probably isn't the end of the world
+  SECTION("variable attachment points") {
+    // clang-format off
+    auto rxn = "CN.(CO*.CC1=CN=CC=C1)>>(CNC1=C(C)C=CC=N1.CO*) |m:4:11.9.10,23:17.19.18|"_rxnsmarts;
+    // clang-format on
+    REQUIRE(rxn);
+    CHECK(rxn->getReactants().size() == 2);
+    CHECK(rxn->getProducts().size() == 1);
+    auto bnd = rxn->getReactants()[1]->getBondBetweenAtoms(1, 2);
+    REQUIRE(bnd);
+    CHECK(bnd->hasProp(common_properties::_MolFileBondAttach));
+    CHECK(bnd->getProp<std::string>(common_properties::_MolFileBondAttach) ==
+          "ANY");
+    CHECK(bnd->hasProp(common_properties::_MolFileBondEndPts));
+    CHECK(bnd->getProp<std::string>(common_properties::_MolFileBondEndPts) ==
+          "(3 10 8 9)");
+
+    bnd = rxn->getProducts()[0]->getBondBetweenAtoms(10, 11);
+    REQUIRE(bnd);
+    CHECK(bnd->hasProp(common_properties::_MolFileBondAttach));
+    CHECK(bnd->getProp<std::string>(common_properties::_MolFileBondAttach) ==
+          "ANY");
+    CHECK(bnd->hasProp(common_properties::_MolFileBondEndPts));
+    CHECK(bnd->getProp<std::string>(common_properties::_MolFileBondEndPts) ==
+          "(3 6 8 7)");
+  }
+#endif
 }
\ No newline at end of file
diff --git a/Code/GraphMol/SmilesParse/CXSmilesOps.cpp b/Code/GraphMol/SmilesParse/CXSmilesOps.cpp
index d5e8a6b4c..5163a9c1b 100644
--- a/Code/GraphMol/SmilesParse/CXSmilesOps.cpp
+++ b/Code/GraphMol/SmilesParse/CXSmilesOps.cpp
@@ -24,6 +24,8 @@
 namespace SmilesParseOps {
 using namespace RDKit;
 
+const std::string cxsmilesindex = "_cxsmilesindex";
+
 std::map<std::string, std::string> sgroupTypemap = {
     {"n", "SRU"},   {"mon", "MON"}, {"mer", "MER"}, {"co", "COP"},
     {"xl", "CRO"},  {"mod", "MOD"}, {"mix", "MIX"}, {"f", "FOR"},
@@ -309,876 +311,998 @@ void finalizePolymerSGroup(RWMol &mol, SubstanceGroup &sgroup) {
 
 }  // end of anonymous namespace
 
+// we use this pattern a lot and it's a long function call, but a very short
+// #define
+#define VALID_ATIDX(_atidx_) \
+  ((_atidx_) >= startAtomIdx && (_atidx_) < startAtomIdx + mol.getNumAtoms())
+
 template <typename Iterator>
-bool parse_atom_values(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_atom_values(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                       unsigned int startAtomIdx) {
   if (first >= last || *first != ':') {
     return false;
   }
   ++first;
   unsigned int atIdx = 0;
   while (first <= last && *first != '$') {
     std::string tkn = read_text_to(first, last, ";$");
-    if (tkn != "") {
+    if (tkn != "" && VALID_ATIDX(atIdx)) {
       mol.getAtomWithIdx(atIdx)->setProp(RDKit::common_properties::molFileValue,
                                          tkn);
     }
     ++atIdx;
     if (first <= last && *first != '$') {
       ++first;
     }
   }
   if (first >= last || *first != '$') {
     return false;
   }
   ++first;
   return true;
 }
 
 template <typename Iterator>
-bool parse_atom_props(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_atom_props(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                      unsigned int startAtomIdx) {
   if (first >= last) {
     return false;
   }
   while (first <= last && *first != '|' && *first != ',') {
     unsigned int atIdx;
     if (read_int(first, last, atIdx)) {
       if (first >= last || *first != '.') {
         return false;
       }
       ++first;
       std::string pname = read_text_to(first, last, ".");
-      if (pname != "") {
+      if (!pname.empty()) {
         if (first >= last || *first != '.') {
           return false;
         }
         ++first;
         std::string pval = read_text_to(first, last, ":|,");
-        if (pval != "") {
-          mol.getAtomWithIdx(atIdx)->setProp(pname, pval);
+        if (VALID_ATIDX(atIdx) && !pval.empty()) {
+          mol.getAtomWithIdx(atIdx - startAtomIdx)->setProp(pname, pval);
         }
       }
     }
     if (first <= last && *first != '|' && *first != ',') {
       ++first;
     }
   }
   if (first <= last && *first != '|' && *first != ',') {
     return false;
   }
   if (*first != '|') {
     ++first;
   }
   return true;
 }
 
 template <typename Iterator>
-bool parse_atom_labels(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_atom_labels(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                       unsigned int startAtomIdx) {
   if (first >= last || *first != '$') {
     return false;
   }
   ++first;
   unsigned int atIdx = 0;
   while (first <= last && *first != '$') {
     std::string tkn = read_text_to(first, last, ";$");
-    if (tkn != "") {
-      mol.getAtomWithIdx(atIdx)->setProp(RDKit::common_properties::atomLabel,
-                                         tkn);
+    if (!tkn.empty() && VALID_ATIDX(atIdx)) {
+      mol.getAtomWithIdx(atIdx - startAtomIdx)
+          ->setProp(RDKit::common_properties::atomLabel, tkn);
     }
     ++atIdx;
     if (first <= last && *first != '$') {
       ++first;
     }
   }
   if (first >= last || *first != '$') {
     return false;
   }
   ++first;
   return true;
 }
 
 template <typename Iterator>
-bool parse_coords(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_coords(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                  unsigned int startAtomIdx) {
   if (first >= last || *first != '(') {
     return false;
   }
 
   auto *conf = new Conformer(mol.getNumAtoms());
   mol.addConformer(conf);
   ++first;
   unsigned int atIdx = 0;
   while (first <= last && *first != ')') {
     RDGeom::Point3D pt;
     std::string tkn = read_text_to(first, last, ";)");
-    if (tkn != "") {
-      std::vector<std::string> tokens;
-      boost::split(tokens, tkn, boost::is_any_of(std::string(",")));
-      if (tokens.size() >= 1 && tokens[0].size()) {
-        pt.x = boost::lexical_cast<double>(tokens[0]);
-      }
-      if (tokens.size() >= 2 && tokens[1].size()) {
-        pt.y = boost::lexical_cast<double>(tokens[1]);
-      }
-      if (tokens.size() >= 3 && tokens[2].size()) {
-        pt.z = boost::lexical_cast<double>(tokens[2]);
+    if (VALID_ATIDX(atIdx)) {
+      if (!tkn.empty()) {
+        std::vector<std::string> tokens;
+        boost::split(tokens, tkn, boost::is_any_of(std::string(",")));
+        if (tokens.size() >= 1 && tokens[0].size()) {
+          pt.x = boost::lexical_cast<double>(tokens[0]);
+        }
+        if (tokens.size() >= 2 && tokens[1].size()) {
+          pt.y = boost::lexical_cast<double>(tokens[1]);
+        }
+        if (tokens.size() >= 3 && tokens[2].size()) {
+          pt.z = boost::lexical_cast<double>(tokens[2]);
+        }
       }
-    }
 
-    conf->setAtomPos(atIdx, pt);
+      conf->setAtomPos(atIdx - startAtomIdx, pt);
+    }
     ++atIdx;
     if (first <= last && *first != ')') {
       ++first;
     }
   }
   if (first >= last || *first != ')') {
     return false;
   }
   ++first;
   return true;
 }
 
 template <typename Iterator>
 bool parse_coordinate_bonds(Iterator &first, Iterator last, RDKit::RWMol &mol,
-                            Bond::BondType typ) {
+                            Bond::BondType typ, unsigned int startAtomIdx,
+                            unsigned int startBondIdx) {
   if (first >= last || (*first != 'C' && *first != 'H')) {
     return false;
   }
   ++first;
   if (first >= last || *first != ':') {
     return false;
   }
   ++first;
   while (first <= last && *first >= '0' && *first <= '9') {
     unsigned int aidx;
     unsigned int bidx;
     if (read_int_pair(first, last, aidx, bidx)) {
-      Bond *bnd = nullptr;
-      for (auto bond : mol.bonds()) {
-        unsigned int smilesIdx;
-        if (bond->getPropIfPresent("_cxsmilesBondIdx", smilesIdx) &&
-            smilesIdx == bidx) {
-          bnd = bond;
-          break;
+      if (VALID_ATIDX(aidx) && bidx >= startBondIdx &&
+          bidx < startBondIdx + mol.getNumBonds()) {
+        Bond *bnd = nullptr;
+        for (auto bond : mol.bonds()) {
+          unsigned int smilesIdx;
+          if (bond->getPropIfPresent("_cxsmilesBondIdx", smilesIdx) &&
+              smilesIdx + startBondIdx == bidx) {
+            bnd = bond;
+            break;
+          }
+        }
+        if (!bnd || (bnd->getBeginAtomIdx() != aidx - startAtomIdx &&
+                     bnd->getEndAtomIdx() != aidx - startAtomIdx)) {
+          BOOST_LOG(rdWarningLog) << "BOND NOT FOUND! " << bidx
+                                  << " involving atom " << aidx << std::endl;
+          return false;
+        }
+        bnd->setBondType(typ);
+        if (bnd->getBeginAtomIdx() != aidx - startAtomIdx) {
+          unsigned int tmp = bnd->getBeginAtomIdx();
+          bnd->setBeginAtomIdx(aidx - startAtomIdx);
+          bnd->setEndAtomIdx(tmp);
         }
-      }
-      if (!bnd ||
-          (bnd->getBeginAtomIdx() != aidx && bnd->getEndAtomIdx() != aidx)) {
-        BOOST_LOG(rdWarningLog) << "BOND NOT FOUND! " << bidx
-                                << " involving atom " << aidx << std::endl;
-        return false;
-      }
-      bnd->setBondType(typ);
-      if (bnd->getBeginAtomIdx() != aidx) {
-        unsigned int tmp = bnd->getBeginAtomIdx();
-        bnd->setBeginAtomIdx(aidx);
-        bnd->setEndAtomIdx(tmp);
       }
     } else {
       return false;
     }
     if (first < last && *first == ',') {
       ++first;
     }
   }
   return true;
 }
 
 template <typename Iterator>
-bool parse_unsaturation(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_unsaturation(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                        unsigned int startAtomIdx) {
   if (first + 1 >= last || *first != 'u') {
     return false;
   }
   ++first;
   if (first >= last || *first != ':') {
     return false;
   }
   ++first;
   while (first < last && *first >= '0' && *first <= '9') {
     unsigned int idx;
     if (!read_int(first, last, idx)) {
       return false;
     }
-    auto atom = mol.getAtomWithIdx(idx);
-    if (!atom->hasQuery()) {
-      atom = QueryOps::replaceAtomWithQueryAtom(&mol, atom);
+    if (VALID_ATIDX(idx)) {
+      auto atom = mol.getAtomWithIdx(idx - startAtomIdx);
+      if (!atom->hasQuery()) {
+        atom = QueryOps::replaceAtomWithQueryAtom(&mol, atom);
+      }
+      atom->expandQuery(makeAtomUnsaturatedQuery(), Queries::COMPOSITE_AND);
     }
-    atom->expandQuery(makeAtomUnsaturatedQuery(), Queries::COMPOSITE_AND);
     if (first < last && *first == ',') {
       ++first;
     }
   }
   return true;
 }
 
 template <typename Iterator>
-bool parse_ring_bonds(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_ring_bonds(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                      unsigned int startAtomIdx) {
   if (first >= last || *first != 'r' || first + 1 >= last ||
       *(first + 1) != 'b' || first + 2 >= last || *(first + 2) != ':') {
     return false;
   }
   first += 3;
   while (first < last && *first >= '0' && *first <= '9') {
     unsigned int n1;
     if (!read_int(first, last, n1)) {
       return false;
     }
     // check that we can read at least two more characters:
     if (first + 1 >= last || *first != ':') {
       return false;
     }
     ++first;
     unsigned int n2;
     bool gt = false;
     if (*first == '*') {
       ++first;
       n2 = 0xDEADBEEF;
-      mol.setProp(common_properties::_NeedsQueryScan, 1);
+      if (VALID_ATIDX(n1)) {
+        mol.setProp(common_properties::_NeedsQueryScan, 1);
+      }
     } else {
       if (!read_int(first, last, n2)) {
         return false;
       }
       switch (n2) {
         case 0:
         case 2:
         case 3:
           break;
         case 4:
           gt = true;
           break;
         default:
           BOOST_LOG(rdWarningLog)
               << "unrecognized rb value: " << n2 << std::endl;
           return false;
       }
     }
-    auto atom = mol.getAtomWithIdx(n1);
-    if (!atom->hasQuery()) {
-      atom = QueryOps::replaceAtomWithQueryAtom(&mol, atom);
-    }
-    if (!gt) {
-      atom->expandQuery(makeAtomRingBondCountQuery(n2), Queries::COMPOSITE_AND);
-    } else {
-      auto q = static_cast<ATOM_EQUALS_QUERY *>(new ATOM_LESSEQUAL_QUERY);
-      q->setVal(n2);
-      q->setDescription("AtomRingBondCount");
-      q->setDataFunc(queryAtomRingBondCount);
-      atom->expandQuery(q, Queries::COMPOSITE_AND);
+    if (VALID_ATIDX(n1)) {
+      auto atom = mol.getAtomWithIdx(n1 - startAtomIdx);
+      if (!atom->hasQuery()) {
+        atom = QueryOps::replaceAtomWithQueryAtom(&mol, atom);
+      }
+      if (!gt) {
+        atom->expandQuery(makeAtomRingBondCountQuery(n2),
+                          Queries::COMPOSITE_AND);
+      } else {
+        auto q = static_cast<ATOM_EQUALS_QUERY *>(new ATOM_LESSEQUAL_QUERY);
+        q->setVal(n2);
+        q->setDescription("AtomRingBondCount");
+        q->setDataFunc(queryAtomRingBondCount);
+        atom->expandQuery(q, Queries::COMPOSITE_AND);
+      }
     }
     if (first < last && *first == ',') {
       ++first;
     }
   }
   return true;
 }
 
 template <typename Iterator>
-bool parse_linknodes(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_linknodes(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                     unsigned int startAtomIdx) {
   // these look like: |LN:1:1.3.2.6,4:1.4.3.6|
   // that's two records:
   //   1:1.3.2.6: 1-3 repeats, atom 1-2, 1-6
-  //   4:1.4.3.6: 1-4 repeats, atom 4-4, 4-6
+  //   4:1.4.3.6: 1-4 repeats, atom 4-3, 4-6
   // which maps to the property value "1 3 2 2 3 2 7|1 4 2 5 4 5 7"
   // If the linking atom only has two neighbors then the outer atom
   // specification (the last two digits) can be left out. So for a molecule
   // where atom 1 has bonds only to atoms 2 and 6 we could have
   // |LN:1:1.3|
   // instead of
   // |LN:1:1.3.2.6|
   if (first >= last || *first != 'L' || first + 1 >= last ||
       *(first + 1) != 'N' || first + 2 >= last || *(first + 2) != ':') {
     return false;
   }
   first += 3;
   std::string accum = "";
   while (first < last && *first >= '0' && *first <= '9') {
     unsigned int atidx;
     if (!read_int(first, last, atidx)) {
       return false;
     }
     // check that we can read at least two more characters:
     if (first + 1 >= last || *first != ':') {
       return false;
     }
     ++first;
     unsigned int startReps;
     if (!read_int(first, last, startReps)) {
       return false;
     }
     if (first + 1 >= last || *first != '.') {
       return false;
     }
     ++first;
     unsigned int endReps;
     if (!read_int(first, last, endReps)) {
       return false;
     }
     unsigned int idx1;
     unsigned int idx2;
     if (first < last && *first == '.') {
       ++first;
       if (!read_int(first, last, idx1)) {
         return false;
       }
       ++first;
       if (!read_int(first, last, idx2)) {
         return false;
       }
-    } else if (mol.getAtomWithIdx(atidx)->getDegree() == 2) {
-      auto nbrs = mol.getAtomNeighbors(mol.getAtomWithIdx(atidx));
+    } else if (VALID_ATIDX(atidx) &&
+               mol.getAtomWithIdx(atidx - startAtomIdx)->getDegree() == 2) {
+      auto nbrs =
+          mol.getAtomNeighbors(mol.getAtomWithIdx(atidx - startAtomIdx));
       idx1 = *nbrs.first;
       nbrs.first++;
       idx2 = *nbrs.first;
-    } else {
+    } else if (VALID_ATIDX(atidx)) {
       return false;
     }
     if (first < last && *first == ',') {
       ++first;
     }
-
-    if (!accum.empty()) {
-      accum += "|";
+    if (VALID_ATIDX(atidx)) {
+      if (!accum.empty()) {
+        accum += "|";
+      }
+      accum += (boost::format("%d %d 2 %d %d %d %d") % startReps % endReps %
+                (atidx - startAtomIdx + 1) % (idx1 - startAtomIdx + 1) %
+                (atidx - startAtomIdx + 1) % (idx2 - startAtomIdx + 1))
+                   .str();
     }
-    accum += (boost::format("%d %d 2 %d %d %d %d") % startReps % endReps %
-              (atidx + 1) % (idx1 + 1) % (atidx + 1) % (idx2 + 1))
-                 .str();
   }
-  mol.setProp(common_properties::molFileLinkNodes, accum);
+  if (!accum.empty()) {
+    mol.setProp(common_properties::molFileLinkNodes, accum);
+  }
   return true;
 }
 
 template <typename Iterator>
-bool parse_data_sgroup(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_data_sgroup(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                       unsigned int startAtomIdx, unsigned int nSGroups) {
   // these look like: |SgD:2,1:FIELD:info::::|
   // example from CXSMILES docs:
   //    SgD:3,2,1,0:name:data:like:unit:t:(1.,1.)
   // the fields are:
   //    SgD:[atom indices]:[field name]:[data value]:[query
   //    operator]:[unit]:[tag]:[coords]
   //   coords are (-1) if atomic coordinates are present
   if (first >= last || *first != 'S' || first + 3 >= last ||
       *(first + 1) != 'g' || *(first + 2) != 'D' || *(first + 3) != ':') {
     return false;
   }
   first += 4;
   std::vector<unsigned int> atoms;
   if (!read_int_list(first, last, atoms)) {
     return false;
   }
   SubstanceGroup sgroup(&mol, std::string("DAT"));
+  sgroup.setProp(cxsmilesindex, nSGroups);
+  bool keepSGroup = false;
   for (auto idx : atoms) {
-    sgroup.addAtomWithIdx(idx);
+    if (VALID_ATIDX(idx)) {
+      keepSGroup = true;
+      sgroup.addAtomWithIdx(idx - startAtomIdx);
+    }
   }
   ++first;
   std::string name = read_text_to(first, last, ":");
   ++first;
-  if (!name.empty()) {
+  if (keepSGroup && !name.empty()) {
     sgroup.setProp("FIELDNAME", name);
   }
   // FIX:
-  sgroup.setProp("FIELDDISP", "    0.0000    0.0000    DR    ALL  0       0");
+  if (keepSGroup) {
+    sgroup.setProp("FIELDDISP", "    0.0000    0.0000    DR    ALL  0       0");
+  }
 
   std::string data = read_text_to(first, last, ":");
   ++first;
-  if (!data.empty()) {
+  if (!data.empty() && keepSGroup) {
     std::vector<std::string> dataFields = {data};
     sgroup.setProp("DATAFIELDS", dataFields);
   }
 
   std::string oper = read_text_to(first, last, ":");
   ++first;
-  if (!oper.empty()) {
+  if (!oper.empty() && keepSGroup) {
     sgroup.setProp("QUERYOP", oper);
   }
   std::string unit = read_text_to(first, last, ":");
   ++first;
-  if (!unit.empty()) {
+  if (!unit.empty() && keepSGroup) {
     sgroup.setProp("FIELDINFO", unit);
   }
   std::string tag = read_text_to(first, last, ":");
   ++first;
-  if (!tag.empty()) {
+  if (!tag.empty() && keepSGroup) {
     // not actually part of what ends up in the output, but
     // it is part of CXSMARTS
     sgroup.setProp("FIELDTAG", tag);
   }
   if (first < last && *first == '(') {
     // FIX
     std::string coords = read_text_to(first, last, ")");
     ++first;
-    sgroup.setProp("COORDS", coords);
+    if (keepSGroup) {
+      sgroup.setProp("COORDS", coords);
+    }
   }
   // the label processing can destroy sgroup info, so do that now
   // (the function will immediately return if already called)
-  processCXSmilesLabels(mol);
-  sgroup.setProp<unsigned int>("index", getSubstanceGroups(mol).size() + 1);
-  addSubstanceGroup(mol, sgroup);
+  if (keepSGroup) {
+    processCXSmilesLabels(mol);
+    sgroup.setProp<unsigned int>("index", getSubstanceGroups(mol).size() + 1);
+    addSubstanceGroup(mol, sgroup);
+  }
   return true;
 }
 
+namespace {
+std::vector<RDKit::SubstanceGroup>::iterator find_matching_sgroup(
+    std::vector<RDKit::SubstanceGroup> &sgs, unsigned int targetId) {
+  return std::find_if(sgs.begin(), sgs.end(), [targetId](const auto &sg) {
+    unsigned int pval;
+    if (sg.getPropIfPresent(cxsmilesindex, pval)) {
+      if (pval == targetId) {
+        return true;
+      }
+    }
+    return false;
+  });
+}
+}  // namespace
 template <typename Iterator>
 bool parse_sgroup_hierarchy(Iterator &first, Iterator last, RDKit::RWMol &mol) {
   // these look like: |SgH:1:0|
   // from CXSMILES docs:
   //    SgH:parentSgroupIndex1:childSgroupIndex1.childSgroupIndex2,parentSgroupIndex2:childSgroupIndex1
   if (first >= last || *first != 'S' || first + 3 >= last ||
       *(first + 1) != 'g' || *(first + 2) != 'H' || *(first + 3) != ':') {
     return false;
   }
   first += 4;
   auto &sgs = getSubstanceGroups(mol);
   while (1) {
     unsigned int parentId;
     if (!read_int(first, last, parentId)) {
       return false;
     }
-    if (parentId >= sgs.size()) {
-      throw SmilesParseException("parent id references non-existent SGroup");
-    }
-    sgs[parentId].getPropIfPresent("index", parentId);
 
+    bool validParent = true;
+    auto psg = find_matching_sgroup(sgs, parentId);
+    if (psg == sgs.end()) {
+      validParent = false;
+    } else {
+      psg->getPropIfPresent("index", parentId);
+    }
     if (first <= last && *first == ':') {
       ++first;
       std::vector<unsigned int> children;
       if (!read_int_list(first, last, children, '.')) {
         return false;
       }
-      for (auto childId : children) {
-        if (childId >= sgs.size()) {
-          throw SmilesParseException("child id references non-existent SGroup");
+      if (validParent) {
+        for (auto childId : children) {
+          if (childId >= sgs.size()) {
+            throw SmilesParseException(
+                "child id references non-existent SGroup");
+          }
+          auto csg = find_matching_sgroup(sgs, childId);
+          if (csg != sgs.end()) {
+            unsigned int cid;
+            csg->getProp("index", cid);
+            csg->setProp("PARENT", parentId);
+          }
         }
-        sgs[childId].setProp("PARENT", parentId);
       }
       if (first <= last && *first == ',') {
         ++first;
       } else {
         break;
       }
     } else {
       return false;
     }
   }
 
   return true;
 }
 
 template <typename Iterator>
-bool parse_polymer_sgroup(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_polymer_sgroup(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                          unsigned int startAtomIdx, unsigned int nSGroups) {
   // these look like:
   //    |Sg:n:6,1,2,4::hh&#44;f:6,0,:4,2,|
   // example from CXSMILES docs:
   // the fields are:
   //    Sg:[type]:[atom indices]:[subscript]:[superscript]:[head crossing
   //    bonds]:[tail crossing bonds]:
   //
   // note that it's legit for empty fields to be completely missing.
   //   for example, this doesn't have any crossing bonds indicated:
   // *-CCCN-* |$star_e;;;;;star_e$,Sg:n:4,1,2,3::hh|
   // this last bit makes the whole thing doubleplusfun to parse
 
   if (first >= last || *first != 'S' || first + 2 >= last ||
       *(first + 1) != 'g' || *(first + 2) != ':') {
     return false;
   }
   first += 3;
 
   std::string typ = read_text_to(first, last, ":");
   ++first;
   if (sgroupTypemap.find(typ) == sgroupTypemap.end()) {
     return false;
   }
+  bool keepSGroup = false;
   SubstanceGroup sgroup(&mol, sgroupTypemap[typ]);
+  sgroup.setProp(cxsmilesindex, nSGroups);
   if (typ == "alt") {
     sgroup.setProp("SUBTYPE", std::string("ALT"));
   } else if (typ == "ran") {
     sgroup.setProp("SUBTYPE", std::string("RAN"));
   } else if (typ == "blk") {
     sgroup.setProp("SUBTYPE", std::string("BLO"));
   }
 
   std::vector<unsigned int> atoms;
   if (!read_int_list(first, last, atoms)) {
     return false;
   }
   //++first;
   for (auto idx : atoms) {
-    sgroup.addAtomWithIdx(idx);
+    if (VALID_ATIDX(idx)) {
+      sgroup.addAtomWithIdx(idx - startAtomIdx);
+      keepSGroup = true;
+    }
   }
   std::vector<unsigned int> headCrossing;
   std::vector<unsigned int> tailCrossing;
   if (first <= last && *first == ':') {
     ++first;
     std::string subscript = read_text_to(first, last, ":|");
-    if (!subscript.empty()) {
+    if (keepSGroup && !subscript.empty()) {
       sgroup.setProp("LABEL", subscript);
     }
     if (first <= last && *first == ':') {
       ++first;
       std::string superscript = read_text_to(first, last, ":|,");
-      if (!superscript.empty()) {
+      if (keepSGroup && !superscript.empty()) {
         sgroup.setProp("CONNECT", superscript);
       }
 
       if (first <= last && *first == ':') {
         ++first;
         if (!read_int_list(first, last, headCrossing)) {
           return false;
         }
-        if (!headCrossing.empty()) {
+        if (keepSGroup && !headCrossing.empty()) {
+          for (auto &cidx : headCrossing) {
+            if (VALID_ATIDX(cidx)) {
+              cidx -= startAtomIdx;
+            } else {
+              keepSGroup = false;
+              break;
+            }
+          }
           sgroup.setProp(_headCrossings, headCrossing, true);
         }
         if (first <= last && *first == ':') {
           ++first;
           if (!read_int_list(first, last, tailCrossing)) {
             return false;
           }
         }
-        if (!tailCrossing.empty()) {
+        if (keepSGroup && !tailCrossing.empty()) {
+          for (auto &cidx : tailCrossing) {
+            if (VALID_ATIDX(cidx)) {
+              cidx -= startAtomIdx;
+            } else {
+              keepSGroup = false;
+              break;
+            }
+          }
           sgroup.setProp("_tailCrossings", tailCrossing, true);
         }
       }
     }
   }
-  // the label processing can destroy sgroup info, so do that now
-  // (the function will immediately return if already called)
-  processCXSmilesLabels(mol);
+  if (keepSGroup) {  // the label processing can destroy sgroup info, so do that
+                     // now (the function will immediately return if already
+                     // called)
+    processCXSmilesLabels(mol);
 
-  finalizePolymerSGroup(mol, sgroup);
-  sgroup.setProp<unsigned int>("index", getSubstanceGroups(mol).size() + 1);
+    finalizePolymerSGroup(mol, sgroup);
+    sgroup.setProp<unsigned int>("index", getSubstanceGroups(mol).size() + 1);
 
-  addSubstanceGroup(mol, sgroup);
+    addSubstanceGroup(mol, sgroup);
+  }
   return true;
 }
 
 template <typename Iterator>
 bool parse_variable_attachments(Iterator &first, Iterator last,
-                                RDKit::RWMol &mol) {
+                                RDKit::RWMol &mol, unsigned int startAtomIdx) {
   // these look like: CO*.C1=CC=NC=C1 |m:2:3.5.4|
   // that corresponds to replacing the bond to atom 2 with bonds to atom 3, 5,
   // or 4
   //
   if (first >= last || *first != 'm' || first + 1 >= last ||
       *(first + 1) != ':') {
     return false;
   }
   first += 2;
 
   while (first < last && *first >= '0' && *first <= '9') {
     unsigned int at1idx;
     if (!read_int(first, last, at1idx)) {
       return false;
     }
-    if (mol.getAtomWithIdx(at1idx)->getDegree() != 1) {
+
+    if (VALID_ATIDX(at1idx) &&
+        mol.getAtomWithIdx(at1idx - startAtomIdx)->getDegree() != 1) {
       BOOST_LOG(rdWarningLog)
           << "position variation bond to atom with more than one bond"
           << std::endl;
       return false;
     }
     if (first < last && *first == ':') {
       ++first;
     } else {
       BOOST_LOG(rdWarningLog) << "improperly formatted m: block" << std::endl;
       return false;
     }
     std::vector<std::string> others;
     while (first < last && *first >= '0' && *first <= '9') {
       unsigned int aidx;
       if (!read_int(first, last, aidx)) {
         return false;
       }
-      others.push_back((boost::format("%d") % (aidx + 1)).str());
+      if (VALID_ATIDX(aidx)) {
+        others.push_back(
+            (boost::format("%d") % (aidx - startAtomIdx + 1)).str());
+      }
       if (first < last && *first == '.') {
         ++first;
       }
     }
-    std::string endPts = (boost::format("(%d") % others.size()).str();
-    for (auto idx : others) {
-      endPts += " " + idx;
-    }
-    endPts += ")";
+    if (VALID_ATIDX(at1idx)) {
+      std::string endPts = (boost::format("(%d") % others.size()).str();
+      for (auto idx : others) {
+        endPts += " " + idx;
+      }
+      endPts += ")";
 
-    for (auto nbri : boost::make_iterator_range(
-             mol.getAtomBonds(mol.getAtomWithIdx(at1idx)))) {
-      auto bnd = mol[nbri];
-      bnd->setProp(common_properties::_MolFileBondEndPts, endPts);
-      bnd->setProp(common_properties::_MolFileBondAttach, std::string("ANY"));
+      for (auto nbri : boost::make_iterator_range(
+               mol.getAtomBonds(mol.getAtomWithIdx(at1idx - startAtomIdx)))) {
+        auto bnd = mol[nbri];
+        bnd->setProp(common_properties::_MolFileBondEndPts, endPts);
+        bnd->setProp(common_properties::_MolFileBondAttach, std::string("ANY"));
+      }
     }
     if (first < last && *first == ',') {
       ++first;
     }
   }
   return true;
 }
 template <typename Iterator>
-bool parse_substitution(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_substitution(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                        unsigned int startAtomIdx) {
   if (first >= last || *first != 's' || first + 1 >= last ||
       *(first + 1) != ':') {
     return false;
   }
   first += 2;
   while (first < last && *first >= '0' && *first <= '9') {
     unsigned int n1;
     if (!read_int(first, last, n1)) {
       return false;
     }
     // check that we can read at least two more characters:
     if (first + 1 >= last || *first != ':') {
       return false;
     }
     ++first;
     unsigned int n2;
     if (*first == '*') {
       ++first;
       n2 = 0xDEADBEEF;
-      mol.setProp(common_properties::_NeedsQueryScan, 1);
+      if (VALID_ATIDX(n1)) {
+        mol.setProp(common_properties::_NeedsQueryScan, 1);
+      }
     } else {
       if (!read_int(first, last, n2)) {
         return false;
       }
     }
-    auto atom = mol.getAtomWithIdx(n1);
-    if (!atom->hasQuery()) {
-      atom = QueryOps::replaceAtomWithQueryAtom(&mol, atom);
+    if (VALID_ATIDX(n1)) {
+      auto atom = mol.getAtomWithIdx(n1 - startAtomIdx);
+      if (!atom->hasQuery()) {
+        atom = QueryOps::replaceAtomWithQueryAtom(&mol, atom);
+      }
+      atom->expandQuery(makeAtomNonHydrogenDegreeQuery(n2),
+                        Queries::COMPOSITE_AND);
     }
-    atom->expandQuery(makeAtomNonHydrogenDegreeQuery(n2),
-                      Queries::COMPOSITE_AND);
     if (first < last && *first == ',') {
       ++first;
     }
   }
   return true;
 }
 
 template <typename Iterator>
 bool processRadicalSection(Iterator &first, Iterator last, RDKit::RWMol &mol,
-                           unsigned int numRadicalElectrons) {
+                           unsigned int numRadicalElectrons,
+                           unsigned int startAtomIdx) {
   if (first >= last) {
     return false;
   }
   ++first;
   if (first >= last || *first != ':') {
     return false;
   }
   ++first;
   unsigned int atIdx;
   if (!read_int(first, last, atIdx)) {
     return false;
   }
-  mol.getAtomWithIdx(atIdx)->setNumRadicalElectrons(numRadicalElectrons);
+  if (VALID_ATIDX(atIdx)) {
+    mol.getAtomWithIdx(atIdx - startAtomIdx)
+        ->setNumRadicalElectrons(numRadicalElectrons);
+  }
   while (first < last && *first == ',') {
     ++first;
     if (first < last && (*first < '0' || *first > '9')) {
       return true;
     }
     if (!read_int(first, last, atIdx)) {
       return false;
     }
-    mol.getAtomWithIdx(atIdx)->setNumRadicalElectrons(numRadicalElectrons);
+    if (VALID_ATIDX(atIdx)) {
+      mol.getAtomWithIdx(atIdx - startAtomIdx)
+          ->setNumRadicalElectrons(numRadicalElectrons);
+    }
   }
   if (first >= last) {
     return false;
   }
   return true;
 }
 
 template <typename Iterator>
-bool parse_radicals(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_radicals(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                    unsigned int startAtomIdx) {
   if (first >= last || *first != '^') {
     return false;
   }
   while (*first == '^') {
     ++first;
     if (first >= last) {
       return false;
     }
     if (*first < '1' || *first > '7') {
       return false;  // these are the values that are allowed to be there
     }
     switch (*first) {
       case '1':
-        if (!processRadicalSection(first, last, mol, 1)) {
+        if (!processRadicalSection(first, last, mol, 1, startAtomIdx)) {
           return false;
         }
         break;
       case '2':
       case '3':
       case '4':
-        if (!processRadicalSection(first, last, mol, 2)) {
+        if (!processRadicalSection(first, last, mol, 2, startAtomIdx)) {
           return false;
         }
         break;
       case '5':
       case '6':
       case '7':
-        if (!processRadicalSection(first, last, mol, 3)) {
+        if (!processRadicalSection(first, last, mol, 3, startAtomIdx)) {
           return false;
         }
         break;
       default:
         BOOST_LOG(rdWarningLog)
             << "Radical specification " << *first << " ignored.";
     }
   }
   return true;
 }
 
 template <typename Iterator>
-bool parse_enhanced_stereo(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_enhanced_stereo(Iterator &first, Iterator last, RDKit::RWMol &mol,
+                           unsigned int startAtomIdx) {
   StereoGroupType group_type = StereoGroupType::STEREO_ABSOLUTE;
   if (*first == 'a') {
     group_type = StereoGroupType::STEREO_ABSOLUTE;
   } else if (*first == 'o') {
     group_type = StereoGroupType::STEREO_OR;
   } else if (*first == '&') {
     group_type = StereoGroupType::STEREO_AND;
   }
   ++first;
 
   // OR and AND groups carry a group number
   if (group_type != StereoGroupType::STEREO_ABSOLUTE) {
     unsigned int group_id = 0;
     read_int(first, last, group_id);
   }
 
   if (first >= last || *first != ':') {
     return false;
   }
   ++first;
 
   std::vector<Atom *> atoms;
   while (first <= last && *first >= '0' && *first <= '9') {
     unsigned int aidx;
     if (read_int(first, last, aidx)) {
-      Atom *atom = mol.getAtomWithIdx(aidx);
-      if (!atom) {
-        BOOST_LOG(rdWarningLog)
-            << "Atom " << aidx << " not found!" << std::endl;
-        return false;
+      if (VALID_ATIDX(aidx)) {
+        Atom *atom = mol.getAtomWithIdx(aidx - startAtomIdx);
+        if (!atom) {
+          BOOST_LOG(rdWarningLog)
+              << "Atom " << aidx << " not found!" << std::endl;
+          return false;
+        }
+        atoms.push_back(atom);
       }
-      atoms.push_back(atom);
     } else {
       return false;
     }
 
     if (first < last && *first == ',') {
       ++first;
     }
   }
-
-  std::vector<StereoGroup> mol_stereo_groups(mol.getStereoGroups());
-  mol_stereo_groups.emplace_back(group_type, std::move(atoms));
-  mol.setStereoGroups(std::move(mol_stereo_groups));
+  if (!atoms.empty()) {
+    std::vector<StereoGroup> mol_stereo_groups(mol.getStereoGroups());
+    mol_stereo_groups.emplace_back(group_type, std::move(atoms));
+    mol.setStereoGroups(std::move(mol_stereo_groups));
+  }
 
   return true;
 }
 
 template <typename Iterator>
-bool parse_it(Iterator &first, Iterator last, RDKit::RWMol &mol) {
+bool parse_it(Iterator &first, Iterator last, RDKit::RWMol &mol,
+              unsigned int startAtomIdx, unsigned int startBondIdx) {
   if (first >= last || *first != '|') {
     return false;
   }
   ++first;
+  unsigned int nSGroups = 0;
   while (first < last && *first != '|') {
     typename Iterator::difference_type length = std::distance(first, last);
     if (*first == '(') {
-      if (!parse_coords(first, last, mol)) {
+      if (!parse_coords(first, last, mol, startAtomIdx)) {
         return false;
       }
     } else if (*first == '$') {
       if (length > 4 && *(first + 1) == '_' && *(first + 2) == 'A' &&
           *(first + 3) == 'V' && *(first + 4) == ':') {
         first += 4;
-        if (!parse_atom_values(first, last, mol)) {
+        if (!parse_atom_values(first, last, mol, startAtomIdx)) {
           return false;
         }
       } else {
-        if (!parse_atom_labels(first, last, mol)) {
+        if (!parse_atom_labels(first, last, mol, startAtomIdx)) {
           return false;
         }
       }
     } else if (length > 9 && std::string(first, first + 9) == "atomProp:") {
       first += 9;
-      if (!parse_atom_props(first, last, mol)) {
+      if (!parse_atom_props(first, last, mol, startAtomIdx)) {
         return false;
       }
     } else if (*first == 'C') {
-      if (!parse_coordinate_bonds(first, last, mol, Bond::DATIVE)) {
+      if (!parse_coordinate_bonds(first, last, mol, Bond::DATIVE, startAtomIdx,
+                                  startBondIdx)) {
         return false;
       }
     } else if (*first == 'H') {
-      if (!parse_coordinate_bonds(first, last, mol, Bond::HYDROGEN)) {
+      if (!parse_coordinate_bonds(first, last, mol, Bond::HYDROGEN,
+                                  startAtomIdx, startBondIdx)) {
         return false;
       }
     } else if (*first == '^') {
-      if (!parse_radicals(first, last, mol)) {
+      if (!parse_radicals(first, last, mol, startAtomIdx)) {
         return false;
       }
     } else if (*first == 'a' || *first == 'o' ||
                (*first == '&' && first + 1 < last && first[1] != '#')) {
-      if (!parse_enhanced_stereo(first, last, mol)) {
+      if (!parse_enhanced_stereo(first, last, mol, startAtomIdx)) {
         return false;
       }
     } else if (*first == 'r' && first + 1 < last && first[1] == 'b') {
-      if (!parse_ring_bonds(first, last, mol)) {
+      if (!parse_ring_bonds(first, last, mol, startAtomIdx)) {
         return false;
       }
     } else if (*first == 'L' && first + 1 < last && first[1] == 'N') {
-      if (!parse_linknodes(first, last, mol)) {
+      if (!parse_linknodes(first, last, mol, startAtomIdx)) {
         return false;
       }
     } else if (*first == 'S' && first + 2 < last && first[1] == 'g' &&
                first[2] == 'D') {
-      if (!parse_data_sgroup(first, last, mol)) {
+      if (!parse_data_sgroup(first, last, mol, startAtomIdx, nSGroups++)) {
         return false;
       }
     } else if (*first == 'S' && first + 2 < last && first[1] == 'g' &&
                first[2] == 'H') {
       if (!parse_sgroup_hierarchy(first, last, mol)) {
         return false;
       }
     } else if (*first == 'S' && first + 1 < last && first[1] == 'g') {
-      if (!parse_polymer_sgroup(first, last, mol)) {
+      if (!parse_polymer_sgroup(first, last, mol, startAtomIdx, nSGroups++)) {
         return false;
       }
     } else if (*first == 'u') {
-      if (!parse_unsaturation(first, last, mol)) {
+      if (!parse_unsaturation(first, last, mol, startAtomIdx)) {
         return false;
       }
     } else if (*first == 's') {
-      if (!parse_substitution(first, last, mol)) {
+      if (!parse_substitution(first, last, mol, startAtomIdx)) {
         return false;
       }
     } else if (*first == 'm') {
-      if (!parse_variable_attachments(first, last, mol)) {
+      if (!parse_variable_attachments(first, last, mol, startAtomIdx)) {
         return false;
       }
     } else {
       ++first;
     }
     // if(first < last && *first != '|') ++first;
   }
   if (first >= last || *first != '|') {
     return false;
   }
   ++first;  // step past the last '|'
   return true;
 }
 }  // namespace parser
 
 void parseCXExtensions(RDKit::RWMol &mol, const std::string &extText,
-                       std::string::const_iterator &first) {
+                       std::string::const_iterator &first,
+                       unsigned int startAtomIdx, unsigned int startBondIdx) {
   // BOOST_LOG(rdWarningLog) << "parseCXNExtensions: " << extText << std::endl;
   if (extText.empty()) {
     return;
   }
   if (extText[0] != '|') {
     throw RDKit::SmilesParseException(
         "CXSMILES extension does not start with |");
   }
   first = extText.begin();
-  bool ok = parser::parse_it(first, extText.end(), mol);
+  bool ok =
+      parser::parse_it(first, extText.end(), mol, startAtomIdx, startBondIdx);
   if (!ok) {
     throw RDKit::SmilesParseException("failure parsing CXSMILES extensions");
   }
   processCXSmilesLabels(mol);
   mol.clearProp("_cxsmilesLabelsProcessed");
 }
 }  // end of namespace SmilesParseOps
diff --git a/Code/GraphMol/SmilesParse/SmilesParse.cpp b/Code/GraphMol/SmilesParse/SmilesParse.cpp
index a5a5da008..fabcd6ba7 100644
--- a/Code/GraphMol/SmilesParse/SmilesParse.cpp
+++ b/Code/GraphMol/SmilesParse/SmilesParse.cpp
@@ -393,57 +393,59 @@ void handleCXPartAndName(RWMol *res, const T &params, const std::string &cxPart,
 RWMol *SmilesToMol(const std::string &smiles,
                    const SmilesParserParams &params) {
   // Calling SmilesToMol in a multithreaded context is generally safe *unless*
   // the value of debugParse is different for different threads. The if
   // statement below avoids a TSAN warning in the case where multiple threads
   // all use the same value for debugParse.
   if (yysmiles_debug != params.debugParse) {
     yysmiles_debug = params.debugParse;
   }
 
   std::string lsmiles, name, cxPart;
   preprocessSmiles(smiles, params, lsmiles, name, cxPart);
   // strip any leading/trailing whitespace:
   // boost::trim_if(smi,boost::is_any_of(" \t\r\n"));
   RWMol *res = nullptr;
   res = toMol(lsmiles, smiles_parse, lsmiles);
   handleCXPartAndName(res, params, cxPart, name);
   if (res && (params.sanitize || params.removeHs)) {
     try {
       if (params.removeHs) {
         bool implicitOnly = false, updateExplicitCount = true;
         MolOps::removeHs(*res, implicitOnly, updateExplicitCount,
                          params.sanitize);
       } else if (params.sanitize) {
         MolOps::sanitizeMol(*res);
       }
     } catch (...) {
       delete res;
       throw;
     }
     // figure out stereochemistry:
     if (params.useLegacyStereo) {
       bool cleanIt = true, force = true, flagPossible = true;
       MolOps::assignStereochemistry(*res, cleanIt, force, flagPossible);
     } else {
       bool cleanIt = true, flagPossible = false;
       Chirality::findPotentialStereo(*res, cleanIt, flagPossible);
     }
   }
   if (res && res->hasProp(common_properties::_NeedsQueryScan)) {
     res->clearProp(common_properties::_NeedsQueryScan);
     if (!params.sanitize) {
       // we know that this can be the ring bond query, do ring perception if we
       // need to:
       MolOps::fastFindRings(*res);
     }
     QueryOps::completeMolQueries(res, 0xDEADBEEF);
   }
 
   if (res) {
-    SmilesParseOps::CleanupAfterParsing(res);
+    if (!params.skipCleanup) {
+      SmilesParseOps::CleanupAfterParsing(res);
+    }
     if (!name.empty()) {
       res->setProp(common_properties::_Name, name);
     }
   }
   return res;
 };
@@ -467,34 +469,36 @@ Bond *SmartsToBond(const std::string &smiles) {
 RWMol *SmartsToMol(const std::string &smarts,
                    const SmartsParserParams &params) {
   // Calling SmartsToMol in a multithreaded context is generally safe *unless*
   // the value of debugParse is different for different threads. The if
   // statement below avoids a TSAN warning in the case where multiple threads
   // all use the same value for debugParse.
   if (yysmarts_debug != params.debugParse) {
     yysmarts_debug = params.debugParse;
   }
 
   std::string lsmarts, name, cxPart;
   preprocessSmiles(smarts, params, lsmarts, name, cxPart);
 
   RWMol *res = nullptr;
   res = toMol(labelRecursivePatterns(lsmarts), smarts_parse, lsmarts);
   handleCXPartAndName(res, params, cxPart, name);
   if (res) {
     if (params.mergeHs) {
       try {
         MolOps::mergeQueryHs(*res);
       } catch (...) {
         delete res;
         throw;
       }
     }
     MolOps::setBondStereoFromDirections(*res);
-    SmilesParseOps::CleanupAfterParsing(res);
+    if (!params.skipCleanup) {
+      SmilesParseOps::CleanupAfterParsing(res);
+    }
     if (!name.empty()) {
       res->setProp(common_properties::_Name, name);
     }
   }
   return res;
 };
 }  // namespace RDKit
diff --git a/Code/GraphMol/SmilesParse/SmilesParse.h b/Code/GraphMol/SmilesParse/SmilesParse.h
index 939094780..ce8b59505 100644
--- a/Code/GraphMol/SmilesParse/SmilesParse.h
+++ b/Code/GraphMol/SmilesParse/SmilesParse.h
@@ -22,15 +22,17 @@ namespace RDKit {
 struct RDKIT_SMILESPARSE_EXPORT SmilesParserParams {
   int debugParse = 0;   /**< enable debugging in the SMILES parser*/
   bool sanitize = true; /**< sanitize the molecule after building it */
   std::map<std::string, std::string> *replacements =
       nullptr;               /**< allows SMILES "macros" */
   bool allowCXSMILES = true; /**< recognize and parse CXSMILES*/
   bool strictCXSMILES =
       true; /**< throw an exception if the CXSMILES parsing fails */
   bool parseName = true; /**< parse (and set) the molecule name as well */
   bool removeHs = true;  /**< remove Hs after constructing the molecule */
   bool useLegacyStereo =
       true; /**< use the legacy stereochemistry perception code */
+  bool skipCleanup =
+      false; /**<  skip the final cleanup stage (for internal use) */
 };
 RDKIT_SMILESPARSE_EXPORT RWMol *SmilesToMol(const std::string &smi,
                                             const SmilesParserParams &params);
@@ -84,13 +86,15 @@ inline RWMol *SmilesToMol(
 struct RDKIT_SMILESPARSE_EXPORT SmartsParserParams {
   int debugParse = 0; /**< enable debugging in the SMARTS parser*/
   std::map<std::string, std::string> *replacements =
       nullptr;               /**< allows SMARTS "macros" */
   bool allowCXSMILES = true; /**< recognize and parse CXSMILES extensions */
   bool strictCXSMILES =
       true; /**< throw an exception if the CXSMILES parsing fails */
   bool parseName = true; /**< parse (and set) the molecule name as well */
   bool mergeHs =
       true; /**< toggles merging H atoms in the SMARTS into neighboring atoms*/
+  bool skipCleanup =
+      false; /**<  skip the final cleanup stage (for internal use) */
 };
 RDKIT_SMILESPARSE_EXPORT RWMol *SmartsToMol(const std::string &sma,
                                             const SmartsParserParams &ps);
diff --git a/Code/GraphMol/SmilesParse/SmilesParseOps.cpp b/Code/GraphMol/SmilesParse/SmilesParseOps.cpp
index 1b384c9b3..0fdbe9071 100644
--- a/Code/GraphMol/SmilesParse/SmilesParseOps.cpp
+++ b/Code/GraphMol/SmilesParse/SmilesParseOps.cpp
@@ -551,13 +551,16 @@ void CloseMolRings(RWMol *mol, bool toleratePartials) {
 void CleanupAfterParsing(RWMol *mol) {
   PRECONDITION(mol, "no molecule");
   for (auto atom : mol->atoms()) {
     atom->clearProp(common_properties::_RingClosures);
     atom->clearProp(common_properties::_SmilesStart);
   }
   for (auto bond : mol->bonds()) {
     bond->clearProp(common_properties::_unspecifiedOrder);
     bond->clearProp("_cxsmilesBondIdx");
   }
+  for (auto sg : RDKit::getSubstanceGroups(*mol)) {
+    sg.clearProp("_cxsmilesindex");
+  }
 }
 
 }  // end of namespace SmilesParseOps
diff --git a/Code/GraphMol/SmilesParse/SmilesParseOps.h b/Code/GraphMol/SmilesParse/SmilesParseOps.h
index a83530cf5..839953a62 100644
--- a/Code/GraphMol/SmilesParse/SmilesParseOps.h
+++ b/Code/GraphMol/SmilesParse/SmilesParseOps.h
@@ -1,15 +1,15 @@
 //
-//  Copyright (C) 2001-2019 Greg Landrum and Rational Discovery LLC
+//  Copyright (C) 2001-2022 Greg Landrum and other RDKit contributors
 //
 //   @@ All Rights Reserved @@
 //  This file is part of the RDKit.
 //  The contents are covered by the terms of the BSD license
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
 #include <RDGeneral/export.h>
-#ifndef _RD_SMILESPARSEOPS_H
-#define _RD_SMILESPARSEOPS_H
+#ifndef RD_SMILESPARSEOPS_H
+#define RD_SMILESPARSEOPS_H
 #include <GraphMol/Bond.h>
 
 namespace RDKit {
@@ -17,25 +17,37 @@ class RWMol;
 class Atom;
 }  // namespace RDKit
 namespace SmilesParseOps {
-void CheckRingClosureBranchStatus(RDKit::Atom *atom, RDKit::RWMol *mp);
-void ReportParseError(const char *message, bool throwIt = true);
-void CleanupAfterParseError(RDKit::RWMol *mol);
+RDKIT_SMILESPARSE_EXPORT void CheckRingClosureBranchStatus(RDKit::Atom *atom,
+                                                           RDKit::RWMol *mp);
+RDKIT_SMILESPARSE_EXPORT void ReportParseError(const char *message,
+                                               bool throwIt = true);
+RDKIT_SMILESPARSE_EXPORT void CleanupAfterParseError(RDKit::RWMol *mol);
 // This uses SMARTS semantics: unspecified bonds are treated as
 // aromatic or single.
-void AddFragToMol(RDKit::RWMol *mol, RDKit::RWMol *frag,
-                  RDKit::Bond::BondType bondOrder = RDKit::Bond::UNSPECIFIED,
-                  RDKit::Bond::BondDir bondDir = RDKit::Bond::NONE);
-RDKit::Bond::BondType GetUnspecifiedBondType(const RDKit::RWMol *mol,
-                                             const RDKit::Atom *atom1,
-                                             const RDKit::Atom *atom2);
-void CloseMolRings(RDKit::RWMol *mol, bool toleratePartials);
-void SetUnspecifiedBondTypes(RDKit::RWMol *mol);
-void AdjustAtomChiralityFlags(RDKit::RWMol *mol);
-void CleanupAfterParsing(RDKit::RWMol *mol);
-void parseCXExtensions(RDKit::RWMol &mol, const std::string &extText,
-                       std::string::const_iterator &pos);
+RDKIT_SMILESPARSE_EXPORT void AddFragToMol(
+    RDKit::RWMol *mol, RDKit::RWMol *frag,
+    RDKit::Bond::BondType bondOrder = RDKit::Bond::UNSPECIFIED,
+    RDKit::Bond::BondDir bondDir = RDKit::Bond::NONE);
+RDKIT_SMILESPARSE_EXPORT RDKit::Bond::BondType GetUnspecifiedBondType(
+    const RDKit::RWMol *mol, const RDKit::Atom *atom1,
+    const RDKit::Atom *atom2);
+RDKIT_SMILESPARSE_EXPORT void CloseMolRings(RDKit::RWMol *mol,
+                                            bool toleratePartials);
+RDKIT_SMILESPARSE_EXPORT void SetUnspecifiedBondTypes(RDKit::RWMol *mol);
+RDKIT_SMILESPARSE_EXPORT void AdjustAtomChiralityFlags(RDKit::RWMol *mol);
+RDKIT_SMILESPARSE_EXPORT void CleanupAfterParsing(RDKit::RWMol *mol);
+RDKIT_SMILESPARSE_EXPORT void parseCXExtensions(
+    RDKit::RWMol &mol, const std::string &extText,
+    std::string::const_iterator &pos, unsigned int startAtomIdx = 0,
+    unsigned int startBondIdx = 0);
+inline void parseCXExtensions(RDKit::RWMol &mol, const std::string &extText,
+                              unsigned int startAtomIdx,
+                              unsigned int startBondIdx) {
+  auto iter = extText.begin();
+  parseCXExtensions(mol, extText, iter, startAtomIdx, startBondIdx);
+};
 //! removes formal charge, isotope, etc. Primarily useful for QueryAtoms
-void ClearAtomChemicalProps(RDKit::Atom *atom);
+RDKIT_SMILESPARSE_EXPORT void ClearAtomChemicalProps(RDKit::Atom *atom);
 };  // namespace SmilesParseOps
 
 #endif
diff --git a/Code/GraphMol/SmilesParse/catch_tests.cpp b/Code/GraphMol/SmilesParse/catch_tests.cpp
index 01300fdcf..0744e4274 100644
--- a/Code/GraphMol/SmilesParse/catch_tests.cpp
+++ b/Code/GraphMol/SmilesParse/catch_tests.cpp
@@ -1235,45 +1235,44 @@ TEST_CASE("polymer SGroups") {
 TEST_CASE("SGroup hierarchy") {
   SECTION("basics") {
     auto mol =
         "*-CNC(C-*)O-* "
         "|$star_e;;;;;star_e;;star_e$,Sg:any:2,1::ht,Sg:any:4,3,2,1,0,6::ht,"
         "SgH:1:0|"_smiles;
     REQUIRE(mol);
     const auto &sgs = getSubstanceGroups(*mol);
     REQUIRE(sgs.size() == 2);
     CHECK(sgs[0].getAtoms() == std::vector<unsigned int>{2, 1});
     CHECK(sgs[0].getProp<std::string>("TYPE") == "ANY");
     CHECK(sgs[0].getProp<unsigned int>("PARENT") == 2);
     CHECK(sgs[0].getProp<unsigned int>("index") == 1);
     CHECK(sgs[1].getAtoms() == std::vector<unsigned int>{4, 3, 2, 1, 0, 6});
     CHECK(sgs[1].getProp<std::string>("TYPE") == "ANY");
     CHECK(sgs[1].getProp<unsigned int>("index") == 2);
     CHECK(!sgs[1].hasProp("PARENT"));
     CHECK(MolToCXSmiles(*mol) ==
           "*CNC(C*)O* "
           "|$star_e;;;;;star_e;;star_e$,,,Sg:any:2,1::ht:::,Sg:any:4,3,2,1,0,6:"
           ":ht:::,SgH:1:0|");
   }
-
   SECTION("nested") {
     auto mol =
         "*-CNC(CC(-*)C-*)O-* "
         "|$star_e;;;;;;star_e;;star_e;;star_e$,"
         "SgD:4:internal data:val::::,SgD:7:atom value:value2::::,"
         "Sg:n:7::ht,Sg:n:2::ht,Sg:any:5,7,8,4,3,2,1,0,9::ht,"
         "SgH:4:2.3.0,2:1|"_smiles;
     REQUIRE(mol);
     const auto &sgs = getSubstanceGroups(*mol);
     REQUIRE(sgs.size() == 5);
     CHECK(sgs[0].getProp<unsigned int>("PARENT") == 5);
     CHECK(sgs[2].getProp<unsigned int>("PARENT") == 5);
     CHECK(sgs[3].getProp<unsigned int>("PARENT") == 5);
     CHECK(sgs[1].getProp<unsigned int>("PARENT") == 3);
     CHECK(
         MolToCXSmiles(*mol) ==
         "*CNC(CC(*)C*)O* |$star_e;;;;;;star_e;;star_e;;star_e$,SgD:4:internal "
         "data:val::::,SgD:7:atom "
         "value:value2::::,,,,,,Sg:n:7::ht:::,Sg:n:2::ht:::,Sg:any:5,7,8,4,3,2,"
         "1,0,9::ht:::,SgH:2:1,4:0.2.3|");
   }
 }
