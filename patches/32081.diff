commit cf02dfc992ae5544c92f69befc7093aacf168e77
Author: Francesc Alted <francesc@blosc.org>
Date:   Wed Apr 7 19:34:03 2021 +0200

    Start supporting postfilters for runlen

diff --git a/bench/create_frame.c b/bench/create_frame.c
index e409f1b6..46579e44 100644
--- a/bench/create_frame.c
+++ b/bench/create_frame.c
@@ -37,20 +37,20 @@ Decompression time: 0.17 s, 11.0 GB/s
 Process finished with exit code 0
 
  */
 
 #include <stdio.h>
 #include <blosc2.h>
 
 #define KB  (1024.)
 #define MB  (1024*KB)
 #define GB  (1024*MB)
 
 #define CHUNKSIZE (500 * 1000)
 #define NCHUNKS 1000
 #define NTHREADS 8
 
 // For exercising the optimized zero chunk creators uncomment the line below
-//#define CREATE_ZEROS
+#define CREATE_ZEROS
 
 
 int create_cframe(const char* compname) {
@@ -150,11 +150,11 @@ int create_cframe(const char* compname) {
 int main(void) {
 #ifdef CREATE_ZEROS
   printf("\n   ***  Creating zeros!   ***\n");
 #endif
 
   create_cframe("blosclz");
   create_cframe("lz4");
-  create_cframe("lz4hc");
-  create_cframe("zlib");
-  create_cframe("zstd");
+//  create_cframe("lz4hc");
+//  create_cframe("zlib");
+//  create_cframe("zstd");
 }
diff --git a/bench/zero_runlen.c b/bench/zero_runlen.c
index 76b76cd8..63d62fee 100644
--- a/bench/zero_runlen.c
+++ b/bench/zero_runlen.c
@@ -35,194 +35,194 @@ enum {
 int check_special_values(int svalue) {
   blosc2_schunk *schunk;
   int32_t isize = CHUNKSIZE * sizeof(int32_t);
   int32_t osize = CHUNKSIZE * sizeof(int32_t) + BLOSC_MAX_OVERHEAD;
   int dsize, csize;
   int64_t nbytes, frame_len;
   int nchunk, nchunks = 0;
   int rc;
   int32_t value = REPEATED_VALUE;
   float fvalue;
   blosc_timestamp_t last, current;
   double totaltime;
   double totalsize = (double)isize * NCHUNKS;
   int32_t *data_buffer = malloc(CHUNKSIZE * sizeof(int32_t));
   int32_t *rec_buffer = malloc(CHUNKSIZE * sizeof(int32_t));
 
   /* Initialize the Blosc compressor */
   blosc_init();
 
   /* Create a super-chunk container */
   blosc2_cparams cparams = BLOSC2_CPARAMS_DEFAULTS;
   cparams.typesize = sizeof(int32_t);
   cparams.compcode = BLOSC_BLOSCLZ;
   cparams.clevel = 9;
   cparams.nthreads = NTHREADS;
-  blosc2_storage storage = {.cparams=&cparams, .contiguous=true};
+  blosc2_storage storage = {.cparams=&cparams, .contiguous=false};
   schunk = blosc2_schunk_new(&storage);
 
   /* Append the chunks */
   blosc_set_timestamp(&last);
   void* chunk = malloc(BLOSC_EXTENDED_HEADER_LENGTH + isize);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     switch (svalue) {
       case ZERO_DETECTION:
         memset(data_buffer, 0, isize);
         csize = blosc2_compress(5, 1, sizeof(int32_t), data_buffer, isize, chunk, osize);
         break;
       case CHECK_ZEROS:
         csize = blosc2_chunk_zeros(isize, sizeof(int32_t), chunk, BLOSC_EXTENDED_HEADER_LENGTH);
         break;
       case CHECK_NANS:
         csize = blosc2_chunk_nans(isize, sizeof(float), chunk, BLOSC_EXTENDED_HEADER_LENGTH);
         break;
       case CHECK_VALUES:
         csize = blosc2_chunk_repeatval(isize, sizeof(int32_t), chunk,
                                        BLOSC_EXTENDED_HEADER_LENGTH + sizeof(int32_t), &value);
         break;
       default:
         printf("Unrecognized case");
         exit(1);
     }
     if (csize < 0) {
       printf("Error creating chunk: %d\n", csize);
       exit(1);
     }
     nchunks = blosc2_schunk_append_chunk(schunk, chunk, true);
     if (nchunks < 0) {
       printf("Error appending chunk: %d\n", nchunks);
       exit(1);
     }
   }
 
   blosc_set_timestamp(&current);
   free(chunk);
   totaltime = blosc_elapsed_secs(last, current);
   printf("[Compr] Elapsed time:\t %6.3f s."
                  "  Processed data: %.3f GB (%.3f GB/s)\n",
          totaltime, totalsize / GB, totalsize / (GB * totaltime));
 
   /* Gather some info */
   nbytes = schunk->nbytes;
   frame_len = blosc2_schunk_frame_len(schunk);
   printf("Compression super-chunk: %ld -> %ld (%.1fx)\n",
          (long)nbytes, (long)frame_len, (1. * nbytes) / frame_len);
 
   /* Retrieve and decompress the chunks */
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, rec_buffer, isize);
     if (dsize < 0) {
       printf("Decompression error.  Error code: %d\n", dsize);
       exit(dsize);
     }
     assert (dsize == (int)isize);
   }
   blosc_set_timestamp(&current);
   totaltime = blosc_elapsed_secs(last, current);
   totalsize = (double)(isize) * nchunks;
   printf("[Decompr] Elapsed time:\t %6.3f s."
          "  Processed data: %.3f GB (%.3f GB/s)\n",
          totaltime, totalsize / GB, totalsize / (GB * totaltime));
 
   /* Exercise the getitem */
   blosc_set_timestamp(&last);
   for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
     bool needs_free;
     uint8_t* chunk_;
     csize = blosc2_schunk_get_chunk(schunk, nchunk, &chunk_, &needs_free);
     if (csize < 0) {
       printf("blosc2_schunk_get_chunk error.  Error code: %d\n", dsize);
       return csize;
     }
     switch (svalue) {
       case CHECK_VALUES:
         rc = blosc_getitem(chunk_, nchunk, 1, &value);
         if (rc < 0) {
           printf("Error in getitem of a special value\n");
           return rc;
         }
         if (value != REPEATED_VALUE) {
           printf("Wrong value!");
           exit(1);
         }
         break;
       case CHECK_NANS:
         rc = blosc_getitem(chunk_, nchunk, 1, &fvalue);
         if (rc < 0) {
           printf("Error in getitem of a special value\n");
           return rc;
         }
         if (!isnan(fvalue)) {
           printf("Wrong value!");
           exit(1);
         }
         break;
       default:
         // It can only be zeros
         rc = blosc_getitem(chunk_, nchunk, 1, &value);
         if (rc < 0) {
           printf("Error in getitem of a special value\n");
           return rc;
         }
         if (value != 0) {
         printf("Wrong value!");
         exit(1);
       }
     }
     if (needs_free) {
       free(chunk_);
     }
   }
   blosc_set_timestamp(&current);
   totaltime = blosc_elapsed_secs(last, current);
   printf("[getitem] Elapsed time:\t %6.3f s.\n", totaltime);
 
 //  /* Check that all the values have a good roundtrip */
 //  blosc_set_timestamp(&last);
 //  for (nchunk = 0; nchunk < NCHUNKS; nchunk++) {
 //    dsize = blosc2_schunk_decompress_chunk(schunk, nchunk, (void *) rec_buffer, isize);
 //    if (dsize < 0) {
 //      printf("Decompression error.  Error code: %d\n", dsize);
 //      return dsize;
 //    }
 //    assert (dsize == (int)isize);
 //    if (CHECK_VALUE) {
 //      int32_t* buffer = (int32_t*)rec_buffer;
 //      for (int i = 0; i < CHUNKSIZE; i++) {
 //        if (buffer[i] != REPEATED_VALUE) {
 //          printf("Value is not correct in chunk %d, position: %d\n", nchunk, i);
 //          return -1;
 //        }
 //      }
 //    }
 //    else if (CHECK_NAN) {
 //      float* buffer = (float*)rec_buffer;
 //      for (int i = 0; i < CHUNKSIZE; i++) {
 //        if (!isnan(buffer[i])) {
 //          printf("Value is not correct in chunk %d, position: %d\n", nchunk, i);
 //          return -1;
 //        }
 //      }
 //    }
 //    else {
 //      int32_t* buffer = (int32_t*)rec_buffer;
 //      for (int i = 0; i < CHUNKSIZE; i++) {
 //        if (buffer[i] != 0) {
 //          printf("Value is not correct in chunk %d, position: %d\n", nchunk, i);
 //          return -1;
 //        }
 //      }
 //    }
 //  }
 //  printf("All data did a good roundtrip!\n");
 
   /* Free resources */
   free(data_buffer);
   free(rec_buffer);
   /* Destroy the super-chunk */
   blosc2_schunk_free(schunk);
   /* Destroy the Blosc environment */
   blosc_destroy();
 
   return 0;
 }
diff --git a/blosc/blosc2.c b/blosc/blosc2.c
index e177340c..072f99ae 100644
--- a/blosc/blosc2.c
+++ b/blosc/blosc2.c
@@ -752,35 +752,36 @@ static inline void blosc2_calculate_blocks(blosc2_context* context) {
 static int blosc2_initialize_context_from_header(blosc2_context* context, blosc_header* header) {
   context->header_flags = header->flags;
   context->typesize = header->typesize;
   context->sourcesize = header->nbytes;
   context->blocksize = header->blocksize;
   context->blosc2_flags = header->blosc2_flags;
 
   blosc2_calculate_blocks(context);
 
   bool is_lazy = false;
   if ((context->header_flags & BLOSC_DOSHUFFLE) &&
       (context->header_flags & BLOSC_DOBITSHUFFLE)) {
     /* Extended header */
     context->header_overhead = BLOSC_EXTENDED_HEADER_LENGTH;
 
     memcpy(context->filters, header->filter_codes, BLOSC2_MAX_FILTERS);
     memcpy(context->filters_meta, header->filter_meta, BLOSC2_MAX_FILTERS);
 
     context->filter_flags = filters_to_flags(header->filter_codes);
+    context->runlen_type = (header->blosc2_flags >> 4) & BLOSC2_RUNLEN_MASK;
 
     is_lazy = (context->blosc2_flags & 0x08u);
   }
   else {
     context->header_overhead = BLOSC_MIN_HEADER_LENGTH;
     context->filter_flags = get_filter_flags(context->header_flags, context->typesize);
     flags_to_filters(context->header_flags, context->filters);
   }
 
   // Some checks for malformed headers
   if (!is_lazy && header->cbytes > context->srcsize) {
     return BLOSC2_ERROR_INVALID_HEADER;
   }
 
   return 0;
 }
@@ -1117,453 +1118,528 @@ static int blosc_c(struct thread_context* thread_context, int32_t bsize,
 /* Process the filter pipeline (decompression mode) */
 int pipeline_d(struct thread_context* thread_context, const int32_t bsize, uint8_t* dest,
                const int32_t offset, uint8_t* src, uint8_t* tmp,
                uint8_t* tmp2, int last_filter_index) {
   blosc2_context* context = thread_context->parent_context;
   int32_t typesize = context->typesize;
   uint8_t* filters = context->filters;
   uint8_t* filters_meta = context->filters_meta;
   uint8_t* _src = src;
   uint8_t* _dest = tmp;
   uint8_t* _tmp = tmp2;
   int errcode = 0;
 
   for (int i = BLOSC2_MAX_FILTERS - 1; i >= 0; i--) {
     // Delta filter requires the whole chunk ready
     int last_copy_filter = (last_filter_index == i) || (next_filter(filters, i, 'd') == BLOSC_DELTA);
     if (last_copy_filter && context->postfilter == NULL) {
       _dest = dest + offset;
     }
     switch (filters[i]) {
       case BLOSC_SHUFFLE:
         for (int j = 0; j <= filters_meta[i]; j++) {
           unshuffle(typesize, bsize, _src, _dest);
           // Cycle filters when required
           if (j < filters_meta[i]) {
             _src = _dest;
             _dest = _tmp;
             _tmp = _src;
           }
           // Check whether we have to copy the intermediate _dest buffer to final destination
           if (last_copy_filter && (filters_meta[i] % 2) == 1 && j == filters_meta[i]) {
             memcpy(dest + offset, _dest, (unsigned int)bsize);
           }
         }
         break;
       case BLOSC_BITSHUFFLE:
         if (bitunshuffle(typesize, bsize, _src, _dest, _tmp, context->src[BLOSC2_CHUNK_VERSION]) < 0) {
           return BLOSC2_ERROR_FILTER_PIPELINE;
         }
         break;
       case BLOSC_DELTA:
         if (context->nthreads == 1) {
           /* Serial mode */
           delta_decoder(dest, offset, bsize, typesize, _dest);
         } else {
           /* Force the thread in charge of the block 0 to go first */
           pthread_mutex_lock(&context->delta_mutex);
           if (context->dref_not_init) {
             if (offset != 0) {
               pthread_cond_wait(&context->delta_cv, &context->delta_mutex);
             } else {
               delta_decoder(dest, offset, bsize, typesize, _dest);
               context->dref_not_init = 0;
               pthread_cond_broadcast(&context->delta_cv);
             }
           }
           pthread_mutex_unlock(&context->delta_mutex);
           if (offset != 0) {
             delta_decoder(dest, offset, bsize, typesize, _dest);
           }
         }
         break;
       case BLOSC_TRUNC_PREC:
         // TRUNC_PREC filter does not need to be undone
         break;
       default:
         if (filters[i] != BLOSC_NOFILTER) {
           BLOSC_TRACE_ERROR("Filter %d not handled during decompression.",
                             filters[i]);
 
           errcode = -1;
         }
     }
     // Cycle buffers when required
     if ((filters[i] != BLOSC_NOFILTER) && (filters[i] != BLOSC_TRUNC_PREC)) {
       _src = _dest;
       _dest = _tmp;
       _tmp = _src;
     }
     if (last_filter_index == i) {
       break;
     }
   }
 
   /* Postfilter function */
   if (context->postfilter != NULL) {
     // Create new postfilter parameters for this block (must be private for each thread)
     blosc2_postfilter_params postparams;
     memcpy(&postparams, context->postparams, sizeof(postparams));
     postparams.in = _src;
     postparams.out = dest + offset;
     postparams.size = bsize;
     postparams.typesize = typesize;
     postparams.offset = offset;
     postparams.tid = thread_context->tid;
     postparams.ttmp = thread_context->tmp;
     postparams.ttmp_nbytes = thread_context->tmp_nbytes;
     postparams.ctx = context;
 
     if (context->postfilter(&postparams) != 0) {
       BLOSC_TRACE_ERROR("Execution of postfilter function failed");
       return BLOSC2_ERROR_POSTFILTER;
     }
   }
 
   return errcode;
 }
 
 
+int set_nans(int32_t nbytes, int32_t typesize, const uint8_t* src,
+             uint8_t* dest, int32_t destsize) {
+  int32_t nitems = nbytes / typesize;
+  if (nitems > destsize / typesize) {
+    nitems = destsize / typesize;
+  }
+
+  if (typesize > destsize) {
+    BLOSC_TRACE_ERROR("Not enough space in dest");
+    return BLOSC2_ERROR_WRITE_BUFFER;
+  }
+
+  if (typesize == 4) {
+    float* dest_ = (float*)dest;
+    for (int i = 0; i < nitems; i++) {
+      dest_[i] = nanf("");
+    }
+    return nbytes;
+  }
+  else if (typesize == 8) {
+    double* dest_ = (double*)dest;
+    for (int i = 0; i < nitems; i++) {
+      dest_[i] = nan("");
+    }
+    return nbytes;
+  }
+
+  BLOSC_TRACE_ERROR("Unsupported typesize for NaN");
+  return BLOSC2_ERROR_DATA;
+}
+
+
+int set_values(int32_t nbytes, int32_t typesize, const uint8_t* src,
+               uint8_t* dest, int32_t destsize) {
+  int32_t nitems = nbytes / typesize;
+  if (nitems > destsize / typesize) {
+    nitems = destsize / typesize;
+  }
+
+  if (typesize > destsize) {
+    BLOSC_TRACE_ERROR("Not enough space in dest");
+    return BLOSC2_ERROR_WRITE_BUFFER;
+  }
+  // Get the value at the end of the header
+  void* value = malloc(typesize);
+  BLOSC_ERROR_NULL(value, BLOSC2_ERROR_MEMORY_ALLOC);
+  memcpy(value, src + BLOSC_EXTENDED_HEADER_LENGTH, typesize);
+  // And copy it to dest
+  for (int i = 0; i < nitems; i++) {
+    memcpy(dest + i * typesize, value, typesize);
+  }
+  free(value);
+
+  return nbytes;
+}
+
+
 /* Decompress & unshuffle a single block */
 static int blosc_d(
     struct thread_context* thread_context, int32_t bsize,
-    int32_t leftoverblock, const uint8_t* src, int32_t srcsize, int32_t src_offset,
+    int32_t leftoverblock, bool memcpyed, const uint8_t* src, int32_t srcsize, int32_t src_offset,
     int32_t nblock, uint8_t* dest, int32_t dest_offset, uint8_t* tmp, uint8_t* tmp2) {
   blosc2_context* context = thread_context->parent_context;
   uint8_t* filters = context->filters;
   uint8_t *tmp3 = thread_context->tmp4;
   int32_t compformat = (context->header_flags & (uint8_t)0xe0) >> 5u;
   int dont_split = (context->header_flags & (uint8_t)0x10) >> 4u;
-  int memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
   int32_t chunk_nbytes;
   int32_t chunk_cbytes;
   int nstreams;
   int32_t neblock;
   int32_t nbytes;                /* number of decompressed bytes in split */
   int32_t cbytes;                /* number of compressed bytes in split */
   int32_t ctbytes = 0;           /* number of compressed bytes in block */
   int32_t ntbytes = 0;           /* number of uncompressed bytes in block */
   uint8_t* _dest;
   int32_t typesize = context->typesize;
   const char* compname;
   int rc;
 
   rc = blosc2_cbuffer_sizes(src, &chunk_nbytes, &chunk_cbytes, NULL);
   if (rc < 0) {
     return rc;
   }
 
   if (context->block_maskout != NULL && context->block_maskout[nblock]) {
     // Do not decompress, but act as if we successfully decompressed everything
     return bsize;
   }
 
   // In some situations (lazychunks) the context can arrive uninitialized
   // (but BITSHUFFLE needs it for accessing the format of the chunk)
   if (context->src == NULL) {
     context->src = src;
   }
 
   bool is_lazy = ((context->header_overhead == BLOSC_EXTENDED_HEADER_LENGTH) &&
           (context->blosc2_flags & 0x08u));
   if (is_lazy) {
     // The chunk is on disk, so just lazily load the block
     if (context->schunk == NULL) {
       BLOSC_TRACE_ERROR("Lazy chunk needs an associated super-chunk.");
       return BLOSC2_ERROR_INVALID_PARAM;
     }
     if (context->schunk->frame == NULL) {
       BLOSC_TRACE_ERROR("Lazy chunk needs an associated frame.");
       return BLOSC2_ERROR_INVALID_PARAM;
     }
     blosc2_frame_s* frame = (blosc2_frame_s*)context->schunk->frame;
     char* urlpath = frame->urlpath;
     int32_t trailer_len = sizeof(int32_t) + sizeof(int64_t) + context->nblocks * sizeof(int32_t);
     size_t trailer_offset = BLOSC_EXTENDED_HEADER_LENGTH + context->nblocks * sizeof(int32_t);
     int32_t nchunk;
     int64_t chunk_offset;
     // The nchunk and the offset of the current chunk are in the trailer
     nchunk = *(int32_t*)(src + trailer_offset);
     chunk_offset = *(int64_t*)(src + trailer_offset + sizeof(int32_t));
     // Get the csize of the nblock
     int32_t *block_csizes = (int32_t *)(src + trailer_offset + sizeof(int32_t) + sizeof(int64_t));
     int32_t block_csize = block_csizes[nblock];
     // Read the lazy block on disk
     FILE* fp = NULL;
     if (frame->sframe) {
       // The chunk is not in the frame
       char* chunkpath = malloc(strlen(frame->urlpath) + 1 + 8 + strlen(".chunk") + 1);
       BLOSC_ERROR_NULL(chunkpath, BLOSC2_ERROR_MEMORY_ALLOC);
       sprintf(chunkpath, "%s/%08X.chunk", frame->urlpath, nchunk);
       fp = fopen(chunkpath, "rb");
       free(chunkpath);
       // The offset of the block is src_offset
       fseek(fp, src_offset, SEEK_SET);
     }
     else {
       fp = fopen(urlpath, "rb");
       // The offset of the block is src_offset
       fseek(fp, chunk_offset + src_offset, SEEK_SET);
     }
     // We can make use of tmp3 because it will be used after src is not needed anymore
     size_t rbytes = fread(tmp3, 1, block_csize, fp);
     fclose(fp);
     if ((int32_t)rbytes != block_csize) {
       BLOSC_TRACE_ERROR("Cannot read the (lazy) block out of the fileframe.");
       return BLOSC2_ERROR_READ_BUFFER;
     }
     src = tmp3;
     src_offset = 0;
     srcsize = block_csize;
   }
 
   // If the chunk is memcpyed, we just have to copy the block to dest and return
   if (memcpyed) {
-    if (chunk_nbytes + context->header_overhead != chunk_cbytes) {
-      return BLOSC2_ERROR_WRITE_BUFFER;
-    }
     int bsize_ = leftoverblock ? chunk_nbytes % context->blocksize : bsize;
-    if (chunk_cbytes < context->header_overhead + (nblock * context->blocksize) + bsize_) {
-      /* Not enough input to copy block */
-      return BLOSC2_ERROR_READ_BUFFER;
+    if (!context->runlen_type) {
+      if (chunk_nbytes + context->header_overhead != chunk_cbytes) {
+        return BLOSC2_ERROR_WRITE_BUFFER;
+      }
+      if (chunk_cbytes < context->header_overhead + (nblock * context->blocksize) + bsize_) {
+        /* Not enough input to copy block */
+        return BLOSC2_ERROR_READ_BUFFER;
+      }
     }
     if (!is_lazy) {
       src += context->header_overhead + nblock * context->blocksize;
     }
     if (context->postfilter == NULL) {
-      memcpy(dest + dest_offset, src, bsize_);
+      switch (context->runlen_type) {
+        case BLOSC2_VALUE_RUNLEN:
+          // All repeated values
+          rc = set_values(chunk_nbytes, context->typesize, src, dest, bsize_);
+          break;
+        case BLOSC2_NAN_RUNLEN:
+          rc = set_nans(chunk_nbytes, context->typesize, src, dest, bsize_);
+          break;
+        case BLOSC2_ZERO_RUNLEN:
+          memset(dest, 0, bsize_);
+          break;
+        default:
+          memcpy(dest + dest_offset, src, bsize_);
+      }
     }
     else {
       // Create new postfilter parameters for this block (must be private for each thread)
       blosc2_postfilter_params postparams;
       memcpy(&postparams, context->postparams, sizeof(postparams));
       postparams.in = src;
       postparams.out = dest + dest_offset;
       postparams.size = bsize;
       postparams.typesize = typesize;
       postparams.offset = dest_offset;
       postparams.tid = thread_context->tid;
       postparams.ttmp = thread_context->tmp;
       postparams.ttmp_nbytes = thread_context->tmp_nbytes;
       postparams.ctx = context;
 
       // Execute the postfilter (the processed block will be copied to dest)
       if (context->postfilter(&postparams) != 0) {
         BLOSC_TRACE_ERROR("Execution of postfilter function failed");
         return BLOSC2_ERROR_POSTFILTER;
       }
     }
     return bsize_;
   }
 
   if (!is_lazy && (src_offset <= 0 || src_offset >= srcsize)) {
     /* Invalid block src offset encountered */
     return BLOSC2_ERROR_DATA;
   }
 
   src += src_offset;
   srcsize -= src_offset;
 
   int last_filter_index = last_filter(filters, 'd');
 
   if (((last_filter_index >= 0) &&
       (next_filter(filters, BLOSC2_MAX_FILTERS, 'd') != BLOSC_DELTA)) ||
       context->postfilter != NULL) {
    // We are making use of some filter, so use a temp for destination
    _dest = tmp;
   } else {
     // If no filters, or only DELTA in pipeline
    _dest = dest + dest_offset;
   }
 
   /* The number of compressed data streams for this block */
   if (!dont_split && !leftoverblock && !context->use_dict) {
     // We don't want to split when in a training dict state
     nstreams = (int32_t)typesize;
   }
   else {
     nstreams = 1;
   }
 
   neblock = bsize / nstreams;
   if (neblock == 0) {
     /* Not enough space to output bytes */
     return -1;
   }
   for (int j = 0; j < nstreams; j++) {
     if (srcsize < (signed)sizeof(int32_t)) {
       /* Not enough input to read compressed size */
       return BLOSC2_ERROR_READ_BUFFER;
     }
     srcsize -= sizeof(int32_t);
     cbytes = sw32_(src);      /* amount of compressed bytes */
     if (cbytes > 0) {
       if (srcsize < cbytes) {
         /* Not enough input to read compressed bytes */
         return BLOSC2_ERROR_READ_BUFFER;
       }
       srcsize -= cbytes;
     }
     src += sizeof(int32_t);
     ctbytes += (signed)sizeof(int32_t);
 
     /* Uncompress */
     if (cbytes == 0) {
       // A run of 0's
       memset(_dest, 0, (unsigned int)neblock);
       nbytes = neblock;
     }
     else if (cbytes < 0) {
       // A negative number means some encoding depending on the token that comes next
       uint8_t token;
 
       if (srcsize < (signed)sizeof(uint8_t)) {
         // Not enough input to read token */
         return BLOSC2_ERROR_READ_BUFFER;
       }
       srcsize -= sizeof(uint8_t);
 
       token = src[0];
       src += 1;
       ctbytes += 1;
 
       if (token & 0x1) {
         // A run of bytes that are different than 0
         if (cbytes < -255) {
           // Runs can only encode a byte
           return BLOSC2_ERROR_RUN_LENGTH;
         }
         uint8_t value = -cbytes;
         memset(_dest, value, (unsigned int)neblock);
       } else {
         BLOSC_TRACE_ERROR("Invalid or unsupported compressed stream token value - %d", token);
         return BLOSC2_ERROR_RUN_LENGTH;
       }
       nbytes = neblock;
       cbytes = 0;  // everything is encoded in the cbytes token
     }
     else if (cbytes == neblock) {
       memcpy(_dest, src, (unsigned int)neblock);
       nbytes = (int32_t)neblock;
     }
     else {
       if (compformat == BLOSC_BLOSCLZ_FORMAT) {
         nbytes = blosclz_decompress(src, cbytes, _dest, (int)neblock);
       }
   #if defined(HAVE_LZ4)
       else if (compformat == BLOSC_LZ4_FORMAT) {
         nbytes = lz4_wrap_decompress((char*)src, (size_t)cbytes,
                                      (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_LZ4 */
   #if defined(HAVE_SNAPPY)
       else if (compformat == BLOSC_SNAPPY_FORMAT) {
         nbytes = snappy_wrap_decompress((char*)src, (size_t)cbytes,
                                         (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_SNAPPY */
   #if defined(HAVE_ZLIB)
       else if (compformat == BLOSC_ZLIB_FORMAT) {
         nbytes = zlib_wrap_decompress((char*)src, (size_t)cbytes,
                                       (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_ZLIB */
   #if defined(HAVE_ZSTD)
       else if (compformat == BLOSC_ZSTD_FORMAT) {
         nbytes = zstd_wrap_decompress(thread_context,
                                       (char*)src, (size_t)cbytes,
                                       (char*)_dest, (size_t)neblock);
       }
   #endif /*  HAVE_ZSTD */
       else {
         compname = clibcode_to_clibname(compformat);
         BLOSC_TRACE_ERROR(
                 "Blosc has not been compiled with decompression "
                 "support for '%s' format.  "
                 "Please recompile for adding this support.", compname);
         return BLOSC2_ERROR_CODEC_SUPPORT;
       }
 
       /* Check that decompressed bytes number is correct */
       if (nbytes != neblock) {
         return BLOSC2_ERROR_DATA;
       }
 
     }
     src += cbytes;
     ctbytes += cbytes;
     _dest += nbytes;
     ntbytes += nbytes;
   } /* Closes j < nstreams */
 
   if (last_filter_index >= 0 || context->postfilter != NULL) {
     /* Apply regular filter pipeline */
     int errcode = pipeline_d(thread_context, bsize, dest, dest_offset, tmp, tmp2, tmp3,
                              last_filter_index);
     if (errcode < 0)
       return errcode;
   }
 
   /* Return the number of uncompressed bytes */
   return (int)ntbytes;
 }
 
 
 /* Serial version for compression/decompression */
 static int serial_blosc(struct thread_context* thread_context) {
   blosc2_context* context = thread_context->parent_context;
   int32_t j, bsize, leftoverblock;
   int32_t cbytes;
   int32_t ntbytes = (int32_t)context->output_bytes;
   int32_t* bstarts = context->bstarts;
   uint8_t* tmp = thread_context->tmp;
   uint8_t* tmp2 = thread_context->tmp2;
   int dict_training = context->use_dict && (context->dict_cdict == NULL);
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
+  if (!context->do_compress && context->runlen_type) {
+    // Fake a runlen as if its a memcpyed chunk
+    memcpyed = true;
+  }
 
   for (j = 0; j < context->nblocks; j++) {
     if (context->do_compress && !memcpyed && !dict_training) {
       _sw32(bstarts + j, ntbytes);
     }
     bsize = context->blocksize;
     leftoverblock = 0;
     if ((j == context->nblocks - 1) && (context->leftover > 0)) {
       bsize = context->leftover;
       leftoverblock = 1;
     }
     if (context->do_compress) {
       if (memcpyed && !context->prefilter) {
         /* We want to memcpy only */
         memcpy(context->dest + context->header_overhead + j * context->blocksize,
                context->src + j * context->blocksize, (unsigned int)bsize);
         cbytes = (int32_t)bsize;
       }
       else {
         /* Regular compression */
         cbytes = blosc_c(thread_context, bsize, leftoverblock, ntbytes,
                          context->destsize, context->src, j * context->blocksize,
                          context->dest + ntbytes, tmp, tmp2);
         if (cbytes == 0) {
           ntbytes = 0;              /* uncompressible data */
           break;
         }
       }
     }
     else {
       /* Regular decompression */
       // If memcpyed we don't have a bstarts section (because it is not needed)
       int32_t src_offset = memcpyed ?
           context->header_overhead + j * context->blocksize : sw32_(bstarts + j);
-      cbytes = blosc_d(thread_context, bsize, leftoverblock,
+      cbytes = blosc_d(thread_context, bsize, leftoverblock, memcpyed,
                        context->src, context->srcsize, src_offset, j,
                        context->dest, j * context->blocksize, tmp, tmp2);
     }
 
     if (cbytes < 0) {
       ntbytes = cbytes;         /* error in blosc_c or blosc_d */
       break;
     }
     ntbytes += cbytes;
   }
 
   return ntbytes;
 }
@@ -1811,76 +1887,80 @@ static int initialize_context_compression(
 static int initialize_context_decompression(blosc2_context* context, blosc_header* header, const void* src,
                                             int32_t srcsize, void* dest, int32_t destsize) {
   int32_t bstarts_end;
 
   context->do_compress = 0;
   context->src = (const uint8_t*)src;
   context->srcsize = srcsize;
   context->dest = (uint8_t*)dest;
   context->destsize = destsize;
   context->output_bytes = 0;
   context->end_threads = 0;
 
   int rc = blosc2_initialize_context_from_header(context, header);
   if (rc < 0) {
     return rc;
   }
 
   /* Check that we have enough space to decompress */
   if (context->sourcesize > (int32_t)context->destsize) {
     return BLOSC2_ERROR_WRITE_BUFFER;
   }
 
   if (context->block_maskout != NULL && context->block_maskout_nitems != context->nblocks) {
     BLOSC_TRACE_ERROR("The number of items in block_maskout (%d) must match the number"
                       " of blocks in chunk (%d).",
                       context->block_maskout_nitems, context->nblocks);
     return BLOSC2_ERROR_DATA;
   }
 
-  context->bstarts = (int32_t*)(context->src + context->header_overhead);
-  if (context->header_flags & (uint8_t)BLOSC_MEMCPYED) {
-    /* If chunk is a memcpy, bstarts does not exist */
-    bstarts_end = context->header_overhead;
-  } else {
-    bstarts_end = context->header_overhead + (context->nblocks * sizeof(int32_t));
-  }
+  context->runlen_type = (header->blosc2_flags >> 4) & BLOSC2_RUNLEN_MASK;
 
-  if (srcsize < bstarts_end) {
-    BLOSC_TRACE_ERROR("`bstarts` exceeds length of source buffer.");
-    return BLOSC2_ERROR_READ_BUFFER;
+  if (context->runlen_type == 0) {
+    context->bstarts = (int32_t *) (context->src + context->header_overhead);
+    if (context->header_flags & (uint8_t) BLOSC_MEMCPYED) {
+      /* If chunk is a memcpy, bstarts does not exist */
+      bstarts_end = context->header_overhead;
+    } else {
+      bstarts_end = context->header_overhead + (context->nblocks * sizeof(int32_t));
+    }
+
+    if (srcsize < bstarts_end) {
+      BLOSC_TRACE_ERROR("`bstarts` exceeds length of source buffer.");
+      return BLOSC2_ERROR_READ_BUFFER;
+    }
+    srcsize -= bstarts_end;
   }
-  srcsize -= bstarts_end;
 
   /* Read optional dictionary if flag set */
   if (context->blosc2_flags & BLOSC2_USEDICT) {
 #if defined(HAVE_ZSTD)
     context->use_dict = 1;
     if (context->dict_ddict != NULL) {
       // Free the existing dictionary (probably from another chunk)
       ZSTD_freeDDict(context->dict_ddict);
     }
     // The trained dictionary is after the bstarts block
     if (srcsize < (signed)sizeof(int32_t)) {
       BLOSC_TRACE_ERROR("Not enough space to read size of dictionary.");
       return BLOSC2_ERROR_READ_BUFFER;
     }
     srcsize -= sizeof(int32_t);
     // Read dictionary size
     context->dict_size = (size_t)sw32_(context->src + bstarts_end);
     if (context->dict_size <= 0 || context->dict_size > BLOSC2_MAXDICTSIZE) {
       BLOSC_TRACE_ERROR("Dictionary size is smaller than minimum or larger than maximum allowed.");
       return BLOSC2_ERROR_CODEC_DICT;
     }
     if (srcsize < (int32_t)context->dict_size) {
       BLOSC_TRACE_ERROR("Not enough space to read entire dictionary.");
       return BLOSC2_ERROR_READ_BUFFER;
     }
     srcsize -= context->dict_size;
     // Read dictionary
     context->dict_buffer = (void*)(context->src + bstarts_end + sizeof(int32_t));
     context->dict_ddict = ZSTD_createDDict(context->dict_buffer, context->dict_size);
 #endif   // HAVE_ZSTD
   }
 
   return 0;
 }
@@ -2315,127 +2395,38 @@ int blosc_compress(int clevel, int doshuffle, size_t typesize, size_t nbytes,
 }
 
 
-int set_nans(blosc_header* header, uint8_t* src, uint8_t* dest, int32_t destsize) {
-  int32_t nitems = header->nbytes / header->typesize;
-  if (nitems > destsize / header->typesize) {
-    nitems = destsize / header->typesize;
-  }
-
-  if (header->typesize > destsize) {
-    BLOSC_TRACE_ERROR("Not enough space in dest");
-    return BLOSC2_ERROR_WRITE_BUFFER;
-  }
-
-  if (header->typesize == 4) {
-    float* dest_ = (float*)dest;
-    for (int i = 0; i < nitems; i++) {
-      dest_[i] = nanf("");
-    }
-    return header->nbytes;
-  }
-  else if (header->typesize == 8) {
-    double* dest_ = (double*)dest;
-    for (int i = 0; i < nitems; i++) {
-      dest_[i] = nan("");
-    }
-    return header->nbytes;
-  }
-
-  BLOSC_TRACE_ERROR("Unsupported typesize for NaN");
-  return BLOSC2_ERROR_DATA;
-}
-
-
-int set_values(blosc_header* header, uint8_t* src, uint8_t* dest, int32_t destsize) {
-  int32_t nitems = header->nbytes / header->typesize;
-  if (nitems > destsize / header->typesize) {
-    nitems = destsize / header->typesize;
-  }
-
-  if (header->typesize > destsize) {
-    BLOSC_TRACE_ERROR("Not enough space in dest");
-    return BLOSC2_ERROR_WRITE_BUFFER;
-  }
-  // Get the value at the end of the header
-  void* value = malloc(header->typesize);
-  BLOSC_ERROR_NULL(value, BLOSC2_ERROR_MEMORY_ALLOC);
-  memcpy(value, src + BLOSC_EXTENDED_HEADER_LENGTH, header->typesize);
-  // And copy it to dest
-  for (int i = 0; i < nitems; i++) {
-    memcpy(dest + i * header->typesize, value, header->typesize);
-  }
-  free(value);
-
-  return header->nbytes;
-}
-
-
-// Return > 0 if runlen.  0 if not a runlen.
-int handle_runlen(blosc_header *header, uint8_t* src, uint8_t* dest, int32_t destsize) {
-  bool doshuffle_flag = header->flags & BLOSC_DOSHUFFLE;
-  bool dobitshuffle_flag = header->flags & BLOSC_DOBITSHUFFLE;
-  int rc = 0;
-
-  if (doshuffle_flag & dobitshuffle_flag) {
-    int32_t runlen_type = (header->blosc2_flags >> 4) & BLOSC2_RUNLEN_MASK;
-    if (runlen_type == BLOSC2_VALUE_RUNLEN) {
-      // All repeated values
-      rc = set_values(header, src, dest, destsize);
-    }
-    else if (runlen_type == BLOSC2_NAN_RUNLEN) {
-      rc = set_nans(header, src, dest, destsize);
-    }
-    else if (runlen_type == BLOSC2_ZERO_RUNLEN) {
-      memset(dest, 0, destsize);
-      rc = header->nbytes;
-    }
-  }
-
-  return rc;
-}
-
 
 int blosc_run_decompression_with_context(blosc2_context* context, const void* src, int32_t srcsize,
                                          void* dest, int32_t destsize) {
   blosc_header header;
   int32_t ntbytes;
   uint8_t* _src = (uint8_t*)src;
   int rc;
 
   rc = blosc_read_header(src, srcsize, true, &header);
   if (rc < 0) {
     return rc;
   }
 
   if (header.nbytes > destsize) {
     // Not enough space for writing into the destination
     return BLOSC2_ERROR_WRITE_BUFFER;
   }
 
-  // Is that a chunk with a special value (runlen)?
-  rc = handle_runlen(&header, _src, dest, destsize);
-  if (rc < 0) {
-    return rc;
-  }
-  if (rc > 0) {
-    // This means that we have found a special value and we are done.
-    return rc;
-  }
-
   rc = initialize_context_decompression(context, &header, src, srcsize, dest, destsize);
   if (rc < 0) {
     return rc;
   }
 
   /* Do the actual decompression */
   ntbytes = do_job(context);
   if (ntbytes < 0) {
     return ntbytes;
   }
 
   assert(ntbytes <= (int32_t)destsize);
   return ntbytes;
 }
 
 
 /* The public secure routine for decompression with context. */
@@ -2514,119 +2505,114 @@ int blosc_decompress(const void* src, void* dest, size_t destsize) {
 /* Specific routine optimized for decompression a small number of
    items out of a compressed chunk.  This does not use threads because
    it would affect negatively to performance. */
 int _blosc_getitem(blosc2_context* context, blosc_header* header, const void* src, int32_t srcsize,
                    int start, int nitems, void* dest, int32_t destsize) {
   uint8_t* _src = (uint8_t*)(src);  /* current pos for source buffer */
   int32_t ntbytes = 0;              /* the number of uncompressed bytes */
   int32_t bsize, bsize2, ebsize, leftoverblock;
   int32_t cbytes;
   int32_t startb, stopb;
   int32_t stop = start + nitems;
   int j, rc;
 
   if (nitems == 0) {
     // We have nothing to do
     return 0;
   }
   if (nitems * header->typesize > destsize) {
     BLOSC_TRACE_ERROR("`nitems`*`typesize` out of dest bounds.");
     return BLOSC2_ERROR_WRITE_BUFFER;
   }
 
-  // Is that a chunk with a special value (runlen)?
-  rc = handle_runlen(header, _src, dest, nitems * header->typesize);
-  if (rc < 0) {
-    return rc;
-  }
-  if (rc > 0) {
-    // This means that we have found a special value and we are done.
-    return rc;
-  }
-
   context->bstarts = (int32_t*)(_src + context->header_overhead);
 
   /* Check region boundaries */
   if ((start < 0) || (start * header->typesize > header->nbytes)) {
     BLOSC_TRACE_ERROR("`start` out of bounds.");
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   if ((stop < 0) || (stop * header->typesize > header->nbytes)) {
     BLOSC_TRACE_ERROR("`start`+`nitems` out of bounds.");
     return BLOSC2_ERROR_INVALID_PARAM;
   }
 
   if (_src + srcsize < (uint8_t *)(context->bstarts + context->nblocks)) {
     BLOSC_TRACE_ERROR("`bstarts` out of bounds.");
     return BLOSC2_ERROR_READ_BUFFER;
   }
 
   ebsize = header->blocksize + header->typesize * (signed)sizeof(int32_t);
 
   for (j = 0; j < context->nblocks; j++) {
     bsize = header->blocksize;
     leftoverblock = 0;
     if ((j == context->nblocks - 1) && (context->leftover > 0)) {
       bsize = context->leftover;
       leftoverblock = 1;
     }
 
     /* Compute start & stop for each block */
     startb = start * header->typesize - j * header->blocksize;
     stopb = stop * header->typesize - j * header->blocksize;
     if (stopb <= 0) {
       // We can exit as soon as this block is beyond stop
       break;
     }
     if (startb >= header->blocksize) {
       continue;
     }
     if (startb < 0) {
       startb = 0;
     }
     if (stopb > header->blocksize) {
       stopb = header->blocksize;
     }
     bsize2 = stopb - startb;
 
     /* Do the actual data copy */
     struct thread_context* scontext = context->serial_context;
 
     /* Resize the temporaries in serial context if needed */
     if (header->blocksize > scontext->tmp_blocksize) {
       my_free(scontext->tmp);
       scontext->tmp_nbytes = (size_t)4 * ebsize;
       scontext->tmp = my_malloc(scontext->tmp_nbytes);
       BLOSC_ERROR_NULL(scontext->tmp, BLOSC2_ERROR_MEMORY_ALLOC);
       scontext->tmp2 = scontext->tmp + ebsize;
       scontext->tmp3 = scontext->tmp2 + ebsize;
       scontext->tmp4 = scontext->tmp3 + ebsize;
       scontext->tmp_blocksize = (int32_t)header->blocksize;
     }
 
     // Regular decompression.  Put results in tmp2.
     // If the block is aligned and the worst case fits in destination, let's avoid a copy
     bool get_single_block = ((startb == 0) && (bsize == nitems * header->typesize));
     uint8_t* tmp2 = get_single_block ? dest : scontext->tmp2;
     bool memcpyed = header->flags & (uint8_t)BLOSC_MEMCPYED;
+    if (context->runlen_type) {
+      // Fake a runlen as if its a memcpyed chunk
+      memcpyed = true;
+    }
+
     // If memcpyed we don't have a bstarts section (because it is not needed)
     int32_t src_offset = memcpyed ?
       context->header_overhead + j * bsize : sw32_(context->bstarts + j);
 
-    cbytes = blosc_d(context->serial_context, bsize, leftoverblock,
+    cbytes = blosc_d(context->serial_context, bsize, leftoverblock, memcpyed,
                      src, srcsize, src_offset, j,
                      tmp2, 0, scontext->tmp, scontext->tmp3);
     if (cbytes < 0) {
       ntbytes = cbytes;
       break;
     }
     if (!get_single_block) {
       /* Copy to destination */
       memcpy((uint8_t *) dest + ntbytes, tmp2 + startb, (unsigned int) bsize2);
     }
     cbytes = (int)bsize2;
     ntbytes += cbytes;
   }
 
   return ntbytes;
 }
@@ -2691,187 +2677,192 @@ int blosc2_getitem_ctx(blosc2_context* context, const void* src, int32_t srcsize
 /* execute single compression/decompression job for a single thread_context */
 static void t_blosc_do_job(void *ctxt)
 {
   struct thread_context* thcontext = (struct thread_context*)ctxt;
   blosc2_context* context = thcontext->parent_context;
   int32_t cbytes;
   int32_t ntdest;
   int32_t tblocks;               /* number of blocks per thread */
   int32_t tblock;                /* limit block on a thread */
   int32_t nblock_;              /* private copy of nblock */
   int32_t bsize;
   int32_t leftoverblock;
   /* Parameters for threads */
   int32_t blocksize;
   int32_t ebsize;
   int32_t srcsize;
   bool compress = context->do_compress != 0;
   int32_t maxbytes;
   int32_t nblocks;
   int32_t leftover;
   int32_t leftover2;
   int32_t* bstarts;
   const uint8_t* src;
   uint8_t* dest;
   uint8_t* tmp;
   uint8_t* tmp2;
   uint8_t* tmp3;
 
   /* Get parameters for this thread before entering the main loop */
   blocksize = context->blocksize;
   ebsize = blocksize + context->typesize * sizeof(int32_t);
   maxbytes = context->destsize;
   nblocks = context->nblocks;
   leftover = context->leftover;
   bstarts = context->bstarts;
   src = context->src;
   srcsize = context->srcsize;
   dest = context->dest;
 
   /* Resize the temporaries if needed */
   if (blocksize > thcontext->tmp_blocksize) {
     my_free(thcontext->tmp);
     thcontext->tmp_nbytes = (size_t) 4 * ebsize;
     thcontext->tmp = my_malloc(thcontext->tmp_nbytes);
     thcontext->tmp2 = thcontext->tmp + ebsize;
     thcontext->tmp3 = thcontext->tmp2 + ebsize;
     thcontext->tmp4 = thcontext->tmp3 + ebsize;
     thcontext->tmp_blocksize = blocksize;
   }
 
   tmp = thcontext->tmp;
   tmp2 = thcontext->tmp2;
   tmp3 = thcontext->tmp3;
 
   // Determine whether we can do a static distribution of workload among different threads
   bool memcpyed = context->header_flags & (uint8_t)BLOSC_MEMCPYED;
+  if (!context->do_compress && context->runlen_type) {
+    // Fake a runlen as if its a memcpyed chunk
+    memcpyed = true;
+  }
+
   bool static_schedule = (!compress || memcpyed) && context->block_maskout == NULL;
   if (static_schedule) {
       /* Blocks per thread */
       tblocks = nblocks / context->nthreads;
       leftover2 = nblocks % context->nthreads;
       tblocks = (leftover2 > 0) ? tblocks + 1 : tblocks;
       nblock_ = thcontext->tid * tblocks;
       tblock = nblock_ + tblocks;
       if (tblock > nblocks) {
           tblock = nblocks;
       }
   }
   else {
     // Use dynamic schedule via a queue.  Get the next block.
     pthread_mutex_lock(&context->count_mutex);
     context->thread_nblock++;
     nblock_ = context->thread_nblock;
     pthread_mutex_unlock(&context->count_mutex);
     tblock = nblocks;
   }
 
   /* Loop over blocks */
   leftoverblock = 0;
   while ((nblock_ < tblock) && (context->thread_giveup_code > 0)) {
     bsize = blocksize;
     if (nblock_ == (nblocks - 1) && (leftover > 0)) {
       bsize = leftover;
       leftoverblock = 1;
     }
     if (compress) {
       if (memcpyed) {
         if (!context->prefilter) {
           /* We want to memcpy only */
           memcpy(dest + context->header_overhead + nblock_ * blocksize,
                  src + nblock_ * blocksize, (unsigned int) bsize);
           cbytes = (int32_t) bsize;
         }
         else {
           /* Only the prefilter has to be executed, and this is done in blosc_c().
            * However, no further actions are needed, so we can put the result
            * directly in dest. */
           cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,
                            ebsize, src, nblock_ * blocksize,
                            dest + context->header_overhead + nblock_ * blocksize,
                            tmp, tmp3);
         }
       }
       else {
         /* Regular compression */
         cbytes = blosc_c(thcontext, bsize, leftoverblock, 0,
                           ebsize, src, nblock_ * blocksize, tmp2, tmp, tmp3);
       }
     }
     else {
       /* Regular decompression */
       if (srcsize < (int32_t)(context->header_overhead + (sizeof(int32_t) * nblocks))) {
         /* Not enough input to read all `bstarts` */
         cbytes = -1;
       }
       else {
         // If memcpyed we don't have a bstarts section (because it is not needed)
         int32_t src_offset = memcpyed ?
             context->header_overhead + nblock_ * blocksize : sw32_(bstarts + nblock_);
-        cbytes = blosc_d(thcontext, bsize, leftoverblock,
+        cbytes = blosc_d(thcontext, bsize, leftoverblock, memcpyed,
                           src, srcsize, src_offset, nblock_,
                           dest, nblock_ * blocksize, tmp, tmp2);
       }
     }
 
     /* Check whether current thread has to giveup */
     if (context->thread_giveup_code <= 0) {
       break;
     }
 
     /* Check results for the compressed/decompressed block */
     if (cbytes < 0) {            /* compr/decompr failure */
       /* Set giveup_code error */
       pthread_mutex_lock(&context->count_mutex);
       context->thread_giveup_code = cbytes;
       pthread_mutex_unlock(&context->count_mutex);
       break;
     }
 
     if (compress && !memcpyed) {
       /* Start critical section */
       pthread_mutex_lock(&context->count_mutex);
       ntdest = context->output_bytes;
       // Note: do not use a typical local dict_training variable here
       // because it is probably cached from previous calls if the number of
       // threads does not change (the usual thing).
       if (!(context->use_dict && context->dict_cdict == NULL)) {
         _sw32(bstarts + nblock_, (int32_t) ntdest);
       }
 
       if ((cbytes == 0) || (ntdest + cbytes > maxbytes)) {
         context->thread_giveup_code = 0;  /* uncompressible buf */
         pthread_mutex_unlock(&context->count_mutex);
         break;
       }
       context->thread_nblock++;
       nblock_ = context->thread_nblock;
       context->output_bytes += cbytes;
       pthread_mutex_unlock(&context->count_mutex);
       /* End of critical section */
 
       /* Copy the compressed buffer to destination */
       memcpy(dest + ntdest, tmp2, (unsigned int) cbytes);
     }
     else if (static_schedule) {
       nblock_++;
     }
     else {
       pthread_mutex_lock(&context->count_mutex);
       context->thread_nblock++;
       nblock_ = context->thread_nblock;
       context->output_bytes += cbytes;
       pthread_mutex_unlock(&context->count_mutex);
     }
 
   } /* closes while (nblock_) */
 
   if (static_schedule) {
     context->output_bytes = context->sourcesize;
     if (compress) {
       context->output_bytes += context->header_overhead;
     }
   }
 
 }
 
 /* Decompress & unshuffle several blocks in a single thread */
@@ -3457,105 +3448,105 @@ int blosc2_set_maskout(blosc2_context *ctx, bool *maskout, int nblocks) {
 /* Create a chunk made of zeros */
 int blosc2_chunk_zeros(const size_t nbytes, const size_t typesize, void* dest, size_t destsize) {
   blosc_header header;
 
   if (typesize == 0 || typesize > BLOSC_MAX_TYPESIZE) {
     BLOSC_TRACE_ERROR("typesize cannot be larger than %d bytes", BLOSC_MAX_TYPESIZE);
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % typesize != 0) {
     BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
   memset(&header, 0, sizeof(header));
   header.version = BLOSC_VERSION_FORMAT;
   header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
   header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
   header.typesize = (uint8_t)typesize;
   header.nbytes = (int32_t)nbytes;
-  header.blocksize = (int32_t)nbytes;
+  header.blocksize = 4 * 4096;
   header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
   header.blosc2_flags = BLOSC2_ZERO_RUNLEN << 4;  // mark chunk as all zeros
 
   memcpy((uint8_t *)dest, &header, sizeof(header));
 
   return BLOSC_EXTENDED_HEADER_LENGTH;
 }
 
 
 /* Create a chunk made of nans */
 int blosc2_chunk_nans(const size_t nbytes, const size_t typesize, void* dest, size_t destsize) {
   blosc_header header;
 
   if (typesize == 0 || typesize > BLOSC_MAX_TYPESIZE) {
     BLOSC_TRACE_ERROR("typesize cannot be larger than %d bytes", BLOSC_MAX_TYPESIZE);
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % typesize != 0) {
     BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
   memset(&header, 0, sizeof(header));
   header.version = BLOSC_VERSION_FORMAT;
   header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
   header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
   header.typesize = (uint8_t)typesize;
   header.nbytes = (int32_t)nbytes;
-  header.blocksize = (int32_t)nbytes;
+  header.blocksize = 4096;
   header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH;
   header.blosc2_flags = BLOSC2_NAN_RUNLEN << 4;  // mark chunk as all NaNs
 
   memcpy((uint8_t *)dest, &header, sizeof(header));
 
   return BLOSC_EXTENDED_HEADER_LENGTH;
 }
 
 
 /* Create a chunk made of repeated values */
 int blosc2_chunk_repeatval(const size_t nbytes, const size_t typesize, void* dest,
                            size_t destsize, void* repeatval) {
   blosc_header header;
 
   if (typesize == 0 || typesize > BLOSC_MAX_TYPESIZE) {
     BLOSC_TRACE_ERROR("typesize cannot be larger than %d bytes", BLOSC_MAX_TYPESIZE);
     return BLOSC2_ERROR_DATA;
   }
 
   if (nbytes % typesize != 0) {
     BLOSC_TRACE_ERROR("nbytes is not a multiple of typesize");
     return BLOSC2_ERROR_DATA;
   }
 
   if (destsize < BLOSC_EXTENDED_HEADER_LENGTH + typesize) {
     BLOSC_TRACE_ERROR("dest buffer is not long enough");
     return BLOSC2_ERROR_DATA;
   }
 
   memset(&header, 0, sizeof(header));
   header.version = BLOSC_VERSION_FORMAT;
   header.versionlz = BLOSC_BLOSCLZ_VERSION_FORMAT;
   header.flags = BLOSC_DOSHUFFLE | BLOSC_DOBITSHUFFLE;  // extended header
   header.typesize = (uint8_t)typesize;
   header.nbytes = (int32_t)nbytes;
-  header.blocksize = (int32_t)nbytes;
+  header.blocksize = 4096;
   header.cbytes = BLOSC_EXTENDED_HEADER_LENGTH + (int32_t)typesize;
   header.blosc2_flags = BLOSC2_VALUE_RUNLEN << 4;  // mark chunk as all repeated value
 
   memcpy((uint8_t *)dest, &header, sizeof(header));
   memcpy((uint8_t *)dest + sizeof(header), repeatval, typesize);
 
   return BLOSC_EXTENDED_HEADER_LENGTH + (uint8_t)typesize;
 }
diff --git a/blosc/context.h b/blosc/context.h
index c910108e..6acd643f 100644
--- a/blosc/context.h
+++ b/blosc/context.h
@@ -35,99 +35,101 @@
 struct blosc2_context_s {
   const uint8_t* src;
   /* The source buffer */
   uint8_t* dest;
   /* The destination buffer */
   uint8_t header_flags;
   /* Flags for header */
   uint8_t blosc2_flags;
   /* Flags specific for blosc2 */
   int32_t sourcesize;
   /* Number of bytes in source buffer */
   int32_t header_overhead;
   /* The number of bytes in chunk header */
   int32_t nblocks;
   /* Number of total blocks in buffer */
   int32_t leftover;
   /* Extra bytes at end of buffer */
   int32_t blocksize;
   /* Length of the block in bytes */
   int32_t output_bytes;
   /* Counter for the number of input bytes */
   int32_t srcsize;
   /* Counter for the number of output bytes */
   int32_t destsize;
   /* Maximum size for destination buffer */
   int32_t typesize;
   /* Type size */
   int32_t* bstarts;
   /* Starts for every block inside the compressed buffer */
+  int32_t runlen_type;
+  /* Run-length type for chunk.  0 if not run-length */
   int compcode;
   /* Compressor code to use */
   int clevel;
   /* Compression level (1-9) */
   int use_dict;
   /* Whether to use dicts or not */
   void* dict_buffer;
   /* The buffer to keep the trained dictionary */
   int32_t dict_size;
   /* The size of the trained dictionary */
   void* dict_cdict;
   /* The dictionary in digested form for compression */
   void* dict_ddict;
   /* The dictionary in digested form for decompression */
   uint8_t filter_flags;
   /* The filter flags in the filter pipeline */
   uint8_t filters[BLOSC2_MAX_FILTERS];
   /* the (sequence of) filters */
   uint8_t filters_meta[BLOSC2_MAX_FILTERS];
   /* the metainfo for filters */
   blosc2_prefilter_fn prefilter;
   /* prefilter function */
   blosc2_postfilter_fn postfilter;
   /* postfilter function */
   blosc2_prefilter_params *preparams;
   /* prefilter params */
   blosc2_postfilter_params *postparams;
   /* postfilter params */
   bool* block_maskout;
   /* The blocks that are not meant to be decompressed.
    * If NULL (default), all blocks in a chunk should be read. */
   int block_maskout_nitems;
   /* The number of items in block_maskout array (must match
    * the number of blocks in chunk) */
   blosc2_schunk* schunk;
   /* Associated super-chunk (if available) */
   struct thread_context* serial_context;
   /* Cache for temporaries for serial operation */
   int do_compress;
   /* 1 if we are compressing, 0 if decompressing */
   void *btune;
   /* Entry point for BTune persistence between runs */
   blosc2_btune *udbtune;
   /* User-defined BTune parameters */
   /* Threading */
   int nthreads;
   int new_nthreads;
   int threads_started;
   int end_threads;
   pthread_t *threads;
   struct thread_context *thread_contexts; /* only for user-managed threads */
   pthread_mutex_t count_mutex;
 #ifdef BLOSC_POSIX_BARRIERS
   pthread_barrier_t barr_init;
   pthread_barrier_t barr_finish;
 #else
   int count_threads;
   pthread_mutex_t count_threads_mutex;
   pthread_cond_t count_threads_cv;
 #endif
 #if !defined(_WIN32)
   pthread_attr_t ct_attr;      /* creation time attrs for threads */
 #endif
   int thread_giveup_code;
   /* error code when give up */
   int thread_nblock;       /* block counter */
   int dref_not_init;       /* data ref in delta not initialized */
   pthread_mutex_t delta_mutex;
   pthread_cond_t delta_cv;
 };
