commit 924d1ecf6370c26bd31c08b922519a85669fa301
Author: Chris Wills <xenkrs@outlook.com>
Date:   Mon May 15 22:36:52 2017 -0700

    Fixed array index using nss to match the definition
    
    Bug: 13713
    Change-Id: I7e96a6209fe5cd0ba11323f35e4408eb4ff7141a
    Signed-off-by: Chris Wills <xenkrs@outlook.com>
    Reviewed-on: https://code.wireshark.org/review/21677
    Reviewed-by: Guy Harris <guy@alum.mit.edu>

diff --git a/epan/dissectors/packet-ieee80211-radiotap.c b/epan/dissectors/packet-ieee80211-radiotap.c
index e520704d08..a8193e7122 100644
--- a/epan/dissectors/packet-ieee80211-radiotap.c
+++ b/epan/dissectors/packet-ieee80211-radiotap.c
@@ -666,1284 +666,1284 @@ static int
 dissect_radiotap(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* unused_data _U_)
 {
 	proto_tree *radiotap_tree     = NULL;
 	proto_item *present_item      = NULL;
 	proto_tree *present_tree      = NULL;
 	proto_item *present_word_item = NULL;
 	proto_tree *present_word_tree = NULL;
 	proto_tree *ft;
 	proto_item *ti                = NULL;
 	proto_item *hidden_item;
 	int         offset;
 	tvbuff_t   *next_tvb;
 	guint8      version;
 	guint       length;
 	guint16     cflags;
 	guint32     freq;
 	proto_item *rate_ti;
 	gint8       dbm, db;
 	gboolean    have_rflags       = FALSE;
 	guint8      rflags            = 0;
 	guint32     xcflags;
 	/* backward compat with bit 14 == fcs in header */
 	proto_item *hdr_fcs_ti        = NULL;
 	int         hdr_fcs_offset    = 0;
 	guint32     sent_fcs          = 0;
 	guint32     calc_fcs;
 	gint        err               = -ENOENT;
 	void       *data;
 	struct _radiotap_info              *radiotap_info;
 	static struct _radiotap_info        rtp_info_arr;
 	struct ieee80211_radiotap_iterator  iter;
 	struct ieee_802_11_phdr phdr;
 
 	/* our non-standard overrides */
 	static struct radiotap_override overrides[] = {
 		{IEEE80211_RADIOTAP_XCHANNEL, 4, 8},	/* xchannel */
 
 		/* keep last */
 		{14, 4, 4},	/* FCS in header */
 	};
 	guint n_overrides = array_length(overrides);
 
 	if (!radiotap_bit14_fcs)
 		n_overrides--;
 
 	radiotap_info = &rtp_info_arr;
 
 	/* We don't have any 802.11 metadata yet. */
 	memset(&phdr, 0, sizeof(phdr));
 	phdr.fcs_len = -1;
 	phdr.decrypted = FALSE;
 	phdr.datapad = FALSE;
 	phdr.phy = PHDR_802_11_PHY_UNKNOWN;
 
 	col_set_str(pinfo->cinfo, COL_PROTOCOL, "WLAN");
 	col_clear(pinfo->cinfo, COL_INFO);
 
 	version = tvb_get_guint8(tvb, 0);
 	length = tvb_get_letohs(tvb, 2);
 
 	radiotap_info->radiotap_length = length;
 
 	col_add_fstr(pinfo->cinfo, COL_INFO, "Radiotap Capture v%u, Length %u",
 		     version, length);
 
 	/* Dissect the packet */
 	if (tree) {
 		ti = proto_tree_add_protocol_format(tree, proto_radiotap,
 						    tvb, 0, length,
 						    "Radiotap Header v%u, Length %u",
 						    version, length);
 		radiotap_tree = proto_item_add_subtree(ti, ett_radiotap);
 		proto_tree_add_uint(radiotap_tree, hf_radiotap_version,
 				    tvb, 0, 1, version);
 		proto_tree_add_item(radiotap_tree, hf_radiotap_pad,
 				    tvb, 1, 1, ENC_BIG_ENDIAN);
 		proto_tree_add_uint(radiotap_tree, hf_radiotap_length,
 				    tvb, 2, 2, length);
 	}
 
 	data = tvb_memdup(wmem_packet_scope(), tvb, 0, length);
 
 	if (ieee80211_radiotap_iterator_init(&iter, (struct ieee80211_radiotap_header *)data, length, NULL)) {
 		if (tree)
 			proto_item_append_text(ti, " (invalid)");
 		/* maybe the length was correct anyway ... */
 		goto hand_off_to_80211;
 	}
 
 	iter.overrides = overrides;
 	iter.n_overrides = n_overrides;
 
 	/* Add the "present flags" bitmaps. */
 	if (tree) {
 		guchar	 *bmap_start	      = (guchar *)data + 4;
 		guint	  n_bitmaps	      = (guint)(iter.this_arg - bmap_start) / 4;
 		guint	  i;
 		gboolean  rtap_ns;
 		gboolean  rtap_ns_next	      = TRUE;
 		guint	  rtap_ns_offset;
 		guint	  rtap_ns_offset_next = 0;
 
 		present_item = proto_tree_add_item(radiotap_tree,
 		    hf_radiotap_present, tvb, 4, n_bitmaps * 4, ENC_NA);
 		present_tree = proto_item_add_subtree(present_item,
 		    ett_radiotap_present);
 
 		for (i = 0; i < n_bitmaps; i++) {
 			guint32 bmap = pletoh32(bmap_start + 4 * i);
 
 			rtap_ns_offset = rtap_ns_offset_next;
 			rtap_ns_offset_next += 32;
 
 			offset = 4 * i;
 
 			present_word_item =
 			    proto_tree_add_item(present_tree,
 			      hf_radiotap_present_word,
 			      tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 
 			present_word_tree =
 			    proto_item_add_subtree(present_word_item,
 			      ett_radiotap_present_word);
 
 			rtap_ns = rtap_ns_next;
 
 			/* Evaluate what kind of namespaces will come next */
 			if (bmap & BIT(IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE)) {
 				rtap_ns_next = TRUE;
 				rtap_ns_offset_next = 0;
 			}
 			if (bmap & BIT(IEEE80211_RADIOTAP_VENDOR_NAMESPACE))
 				rtap_ns_next = FALSE;
 			if ((bmap & (BIT(IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE) |
 				     BIT(IEEE80211_RADIOTAP_VENDOR_NAMESPACE)))
 				== (BIT(IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE) |
 				    BIT(IEEE80211_RADIOTAP_VENDOR_NAMESPACE))) {
 				expert_add_info_format(pinfo, present_word_item,
 				    &ei_radiotap_present,
 				    "Both radiotap and vendor namespace specified in bitmask word %u",
 				    i);
 				goto malformed;
 			}
 
 			if (!rtap_ns)
 				goto always_bits;
 
 			/* Currently, we don't know anything about bits >= 32 */
 			if (rtap_ns_offset)
 				goto always_bits;
 
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_tsft, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_flags, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_rate, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_channel, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_fhss, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_dbm_antsignal,
 					    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_dbm_antnoise,
 					    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_lock_quality,
 					    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_tx_attenuation,
 					    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_db_tx_attenuation,
 					    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_dbm_tx_power,
 					    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_antenna, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_db_antsignal,
 					    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_db_antnoise,
 					    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			if (radiotap_bit14_fcs) {
 				proto_tree_add_item(present_word_tree,
 						    hf_radiotap_present_hdrfcs,
 						    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			} else {
 				proto_tree_add_item(present_word_tree,
 						    hf_radiotap_present_rxflags,
 						    tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);
 			}
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_xchannel, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_mcs, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_ampdu, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_vht, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_timestamp, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 
 			ti = proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_reserved, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			/* Check if Reserved/Not Defined is not "zero" */
 			if(bmap & IEEE80211_RADIOTAP_NOTDEFINED)
 			{
 				expert_add_info(pinfo, present_word_item,
 				    &ei_radiotap_present_reserved);
 			}
  always_bits:
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_rtap_ns, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_vendor_ns, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(present_word_tree,
 					    hf_radiotap_present_ext, tvb,
 					    offset + 4, 4, ENC_LITTLE_ENDIAN);
 		}
 	}
 
 	while (!(err = ieee80211_radiotap_iterator_next(&iter))) {
 		offset = (int)((guchar *) iter.this_arg - (guchar *) data);
 
 		if (iter.this_arg_index == IEEE80211_RADIOTAP_VENDOR_NAMESPACE
 		    && tree) {
 			proto_tree *vt, *ven_tree = NULL;
 			const gchar *manuf_name;
 			guint8 subns;
 
 			manuf_name = tvb_get_manuf_name(tvb, offset);
 			subns = tvb_get_guint8(tvb, offset+3);
 
 			vt = proto_tree_add_bytes_format_value(radiotap_tree,
 							 hf_radiotap_vendor_ns,
 							 tvb, offset,
 							 iter.this_arg_size,
 							 NULL,
 							 "%s-%d",
 							 manuf_name, subns);
 			ven_tree = proto_item_add_subtree(vt, ett_radiotap_vendor);
 			proto_tree_add_bytes_format_value(ven_tree,
 						    hf_radiotap_ven_oui, tvb,
 						    offset, 3, NULL,
 						    "%s", manuf_name);
 			proto_tree_add_item(ven_tree, hf_radiotap_ven_subns,
 					    tvb, offset + 3, 1, ENC_BIG_ENDIAN);
 			proto_tree_add_item(ven_tree, hf_radiotap_ven_skip, tvb,
 					    offset + 4, 2, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(ven_tree, hf_radiotap_ven_data, tvb,
 					    offset + 6, iter.this_arg_size - 6,
 					    ENC_NA);
 		}
 
 		if (!iter.is_radiotap_ns)
 			continue;
 
 		switch (iter.this_arg_index) {
 
 		case IEEE80211_RADIOTAP_TSFT:
 			radiotap_info->tsft = tvb_get_letoh64(tvb, offset);
 			phdr.tsf_timestamp = radiotap_info->tsft;
 			phdr.has_tsf_timestamp = TRUE;
 			if (tree) {
 				proto_tree_add_uint64(radiotap_tree,
 						      hf_radiotap_mactime, tvb,
 						      offset, 8,
 						      radiotap_info->tsft);
 			}
 			break;
 
 		case IEEE80211_RADIOTAP_FLAGS: {
 			rflags = tvb_get_guint8(tvb, offset);
 			have_rflags = TRUE;
 			if (rflags & IEEE80211_RADIOTAP_F_DATAPAD)
 				phdr.datapad = TRUE;
 			if (rflags & IEEE80211_RADIOTAP_F_FCS)
 				phdr.fcs_len = 4;
 			else
 				phdr.fcs_len = 0;
 
 			if (tree) {
 				proto_tree *flags_tree;
 
 				ft = proto_tree_add_item(radiotap_tree,
 							 hf_radiotap_flags,
 							 tvb, offset, 1, ENC_BIG_ENDIAN);
 				flags_tree =
 				    proto_item_add_subtree(ft,
 							   ett_radiotap_flags);
 
 				proto_tree_add_item(flags_tree,
 						    hf_radiotap_flags_cfp,
 						    tvb, offset, 1, ENC_BIG_ENDIAN);
 				proto_tree_add_item(flags_tree,
 						    hf_radiotap_flags_preamble,
 						    tvb, offset, 1, ENC_BIG_ENDIAN);
 				proto_tree_add_item(flags_tree,
 						    hf_radiotap_flags_wep,
 						    tvb, offset, 1, ENC_BIG_ENDIAN);
 				proto_tree_add_item(flags_tree,
 						    hf_radiotap_flags_frag,
 						    tvb, offset, 1, ENC_BIG_ENDIAN);
 				proto_tree_add_item(flags_tree,
 						    hf_radiotap_flags_fcs,
 						    tvb, offset, 1, ENC_BIG_ENDIAN);
 				proto_tree_add_item(flags_tree,
 						    hf_radiotap_flags_datapad,
 						    tvb, offset, 1, ENC_BIG_ENDIAN);
 				proto_tree_add_item(flags_tree,
 						    hf_radiotap_flags_badfcs,
 						    tvb, offset, 1, ENC_BIG_ENDIAN);
 				proto_tree_add_item(flags_tree,
 						    hf_radiotap_flags_shortgi,
 						    tvb, offset, 1, ENC_BIG_ENDIAN);
 			}
 			break;
 		}
 
 		case IEEE80211_RADIOTAP_RATE: {
 			guint32 rate;
 			rate = tvb_get_guint8(tvb, offset);
 			/*
 			 * XXX On FreeBSD rate & 0x80 means we have an MCS. On
 			 * Linux and AirPcap it does not.  (What about
 			 * macOS, NetBSD, OpenBSD, and DragonFly BSD?)
 			 *
 			 * This is an issue either for proprietary extensions
 			 * to 11a or 11g, which do exist, or for 11n
 			 * implementations that stuff a rate value into
 			 * this field, which also appear to exist.
 			 */
 			if (radiotap_interpret_high_rates_as_mcs &&
 					rate >= 0x80 && rate <= (0x80+76)) {
 				/*
 				 * XXX - we don't know the channel width
 				 * or guard interval length, so we can't
 				 * convert this to a data rate.
 				 *
 				 * If you want us to show a data rate,
 				 * use the MCS field, not the Rate field;
 				 * the MCS field includes not only the
 				 * MCS index, it also includes bandwidth
 				 * and guard interval information.
 				 *
 				 * XXX - can we get the channel width
 				 * from XChannel and the guard interval
 				 * information from Flags, at least on
 				 * FreeBSD?
 				 */
 				if (tree) {
 					proto_tree_add_uint(radiotap_tree,
 							    hf_radiotap_mcs_index,
 							    tvb, offset, 1,
 							    rate & 0x7f);
 				}
 			} else {
 				col_add_fstr(pinfo->cinfo, COL_TX_RATE, "%d.%d",
 					     rate / 2, rate & 1 ? 5 : 0);
 				if (tree) {
 					proto_tree_add_float_format(radiotap_tree,
 								    hf_radiotap_datarate,
 								    tvb, offset, 1,
 								    (float)rate / 2,
 								    "Data Rate: %.1f Mb/s",
 								    (float)rate / 2);
 				}
 				radiotap_info->rate = rate;
 				phdr.has_data_rate = TRUE;
 				phdr.data_rate = rate;
 			}
 			break;
 		}
 
 		case IEEE80211_RADIOTAP_CHANNEL: {
 			freq = tvb_get_letohs(tvb, offset);
 			if (freq != 0) {
 				/*
 				 * XXX - some captures have 0, which is
 				 * obviously bogus.
 				 */
 				gint calc_channel;
 
 				phdr.has_frequency = TRUE;
 				phdr.frequency = freq;
 				calc_channel = ieee80211_mhz_to_chan(freq);
 				if (calc_channel != -1) {
 					phdr.has_channel = TRUE;
 					phdr.channel = calc_channel;
 				}
 			}
 			memset(&phdr.phy_info, 0, sizeof(phdr.phy_info));
 			cflags = tvb_get_letohs(tvb, offset + 2);
 			switch (cflags & IEEE80211_CHAN_ALLTURBO) {
 
 			case IEEE80211_CHAN_FHSS:
 				phdr.phy = PHDR_802_11_PHY_11_FHSS;
 				break;
 
 			case IEEE80211_CHAN_DSSS:
 				phdr.phy = PHDR_802_11_PHY_11_DSSS;
 				break;
 
 			case IEEE80211_CHAN_A:
 				phdr.phy = PHDR_802_11_PHY_11A;
 				phdr.phy_info.info_11a.has_turbo_type = TRUE;
 				phdr.phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_NORMAL;
 				break;
 
 			case IEEE80211_CHAN_B:
 				phdr.phy = PHDR_802_11_PHY_11B;
 				if (have_rflags) {
 					phdr.phy_info.info_11b.has_short_preamble = TRUE;
 					phdr.phy_info.info_11b.short_preamble = (rflags & IEEE80211_RADIOTAP_F_SHORTPRE) != 0;
 				}
 				break;
 
 			case IEEE80211_CHAN_PUREG:
 				phdr.phy = PHDR_802_11_PHY_11G;
 				phdr.phy_info.info_11g.has_mode = TRUE;
 				phdr.phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;
 				if (have_rflags) {
 					phdr.phy_info.info_11g.has_short_preamble = TRUE;
 					phdr.phy_info.info_11g.short_preamble = (rflags & IEEE80211_RADIOTAP_F_SHORTPRE) != 0;
 				}
 				break;
 
 			case IEEE80211_CHAN_G:
 				phdr.phy = PHDR_802_11_PHY_11G;
 				phdr.phy_info.info_11g.has_mode = TRUE;
 				phdr.phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;
 				if (have_rflags) {
 					phdr.phy_info.info_11g.has_short_preamble = TRUE;
 					phdr.phy_info.info_11g.short_preamble = (rflags & IEEE80211_RADIOTAP_F_SHORTPRE) != 0;
 				}
 				break;
 
 			case IEEE80211_CHAN_108A:
 				phdr.phy = PHDR_802_11_PHY_11A;
 				phdr.phy_info.info_11a.has_turbo_type = TRUE;
 				/* We assume non-STURBO is dynamic turbo */
 				phdr.phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_DYNAMIC_TURBO;
 				break;
 
 			case IEEE80211_CHAN_108PUREG:
 				phdr.phy = PHDR_802_11_PHY_11G;
 				phdr.phy_info.info_11g.has_mode = TRUE;
 				phdr.phy_info.info_11g.mode = PHDR_802_11G_MODE_SUPER_G;
 				if (have_rflags) {
 					phdr.phy_info.info_11g.has_short_preamble = TRUE;
 					phdr.phy_info.info_11g.short_preamble = (rflags & IEEE80211_RADIOTAP_F_SHORTPRE) != 0;
 				}
 				break;
 			}
 			if (tree) {
 				gchar	   *chan_str;
 				static const int * channel_flags[] = {
 					&hf_radiotap_channel_flags_turbo,
 					&hf_radiotap_channel_flags_cck,
 					&hf_radiotap_channel_flags_ofdm,
 					&hf_radiotap_channel_flags_2ghz,
 					&hf_radiotap_channel_flags_5ghz,
 					&hf_radiotap_channel_flags_passive,
 					&hf_radiotap_channel_flags_dynamic,
 					&hf_radiotap_channel_flags_gfsk,
 					&hf_radiotap_channel_flags_gsm,
 					&hf_radiotap_channel_flags_sturbo,
 					&hf_radiotap_channel_flags_half,
 					&hf_radiotap_channel_flags_quarter,
 					NULL
 				};
 
 				chan_str = ieee80211_mhz_to_str(freq);
 				col_add_fstr(pinfo->cinfo,
 					     COL_FREQ_CHAN, "%s", chan_str);
 				proto_tree_add_uint_format_value(radiotap_tree,
 							   hf_radiotap_channel_frequency,
 							   tvb, offset, 2, freq,
 							   "%s",
 							   chan_str);
 				g_free(chan_str);
 
 				/* We're already 2-byte aligned. */
 				proto_tree_add_bitmask(radiotap_tree, tvb, offset + 2, hf_radiotap_channel_flags, ett_radiotap_channel_flags, channel_flags, ENC_LITTLE_ENDIAN);
 				radiotap_info->freq = freq;
 				radiotap_info->flags = cflags;
 			}
 			break;
 		}
 
 		case IEEE80211_RADIOTAP_FHSS:
 			/*
 			 * Just in case we didn't have a Channel field or
 			 * it said this was something other than 11 legacy
 			 * FHSS.
 			 */
 			phdr.phy = PHDR_802_11_PHY_11_FHSS;
 			phdr.phy_info.info_11_fhss.has_hop_set = TRUE;
 			phdr.phy_info.info_11_fhss.hop_set = tvb_get_guint8(tvb, offset);
 			phdr.phy_info.info_11_fhss.has_hop_pattern = TRUE;
 			phdr.phy_info.info_11_fhss.hop_pattern = tvb_get_guint8(tvb, offset + 1);
 			proto_tree_add_item(radiotap_tree,
 					    hf_radiotap_fhss_hopset, tvb,
 					    offset, 1, ENC_BIG_ENDIAN);
 			proto_tree_add_item(radiotap_tree,
 					    hf_radiotap_fhss_pattern, tvb,
 					    offset + 1, 1, ENC_BIG_ENDIAN);
 			break;
 
 		case IEEE80211_RADIOTAP_DBM_ANTSIGNAL:
 			dbm = (gint8)tvb_get_guint8(tvb, offset);
 			phdr.has_signal_dbm = TRUE;
 			phdr.signal_dbm = dbm;
 			col_add_fstr(pinfo->cinfo, COL_RSSI, "%d dBm", dbm);
 			proto_tree_add_int(radiotap_tree,
 							  hf_radiotap_dbm_antsignal,
 							  tvb, offset, 1, dbm);
 			radiotap_info->dbm_antsignal = dbm;
 			break;
 
 		case IEEE80211_RADIOTAP_DBM_ANTNOISE:
 			dbm = (gint8) tvb_get_guint8(tvb, offset);
 			phdr.has_noise_dbm = TRUE;
 			phdr.noise_dbm = dbm;
 			if (tree) {
 				proto_tree_add_int(radiotap_tree,
 							  hf_radiotap_dbm_antnoise,
 							  tvb, offset, 1, dbm);
 			}
 			radiotap_info->dbm_antnoise = dbm;
 			break;
 
 		case IEEE80211_RADIOTAP_LOCK_QUALITY:
 			if (tree) {
 				proto_tree_add_uint(radiotap_tree,
 						    hf_radiotap_quality, tvb,
 						    offset, 2,
 						    tvb_get_letohs(tvb,
 								   offset));
 			}
 			break;
 
 		case IEEE80211_RADIOTAP_TX_ATTENUATION:
 			proto_tree_add_item(radiotap_tree,
 					    hf_radiotap_tx_attenuation, tvb,
 					    offset, 2, ENC_BIG_ENDIAN);
 			break;
 
 		case IEEE80211_RADIOTAP_DB_TX_ATTENUATION:
 			proto_tree_add_item(radiotap_tree,
 					    hf_radiotap_db_tx_attenuation, tvb,
 					    offset, 2, ENC_BIG_ENDIAN);
 			break;
 
 		case IEEE80211_RADIOTAP_DBM_TX_POWER:
 			if (tree) {
 				proto_tree_add_int(radiotap_tree,
 						   hf_radiotap_txpower, tvb,
 						   offset, 1,
 						   tvb_get_guint8(tvb, offset));
 			}
 			break;
 
 		case IEEE80211_RADIOTAP_ANTENNA:
 			if (tree) {
 				proto_tree_add_uint(radiotap_tree,
 						    hf_radiotap_antenna, tvb,
 						    offset, 1,
 						    tvb_get_guint8(tvb,
 								   offset));
 			}
 			break;
 
 		case IEEE80211_RADIOTAP_DB_ANTSIGNAL:
 			db = tvb_get_guint8(tvb, offset);
 			col_add_fstr(pinfo->cinfo, COL_RSSI, "%u dB", db);
 			proto_tree_add_uint(radiotap_tree,
 							   hf_radiotap_db_antsignal,
 							   tvb, offset, 1, db);
 			break;
 
 		case IEEE80211_RADIOTAP_DB_ANTNOISE:
 			db = tvb_get_guint8(tvb, offset);
 			proto_tree_add_uint(radiotap_tree,
 							   hf_radiotap_db_antnoise,
 							   tvb, offset, 1, db);
 			break;
 
 		case IEEE80211_RADIOTAP_RX_FLAGS: {
 			if (radiotap_bit14_fcs) {
 				if (tree) {
 					sent_fcs   = tvb_get_ntohl(tvb, offset);
 					hdr_fcs_ti = proto_tree_add_uint(radiotap_tree,
 									 hf_radiotap_fcs, tvb,
 									 offset, 4, sent_fcs);
 					hdr_fcs_offset = offset;
 				}
 			} else {
 				static const int * rxflags[] = {
 					&hf_radiotap_rxflags_badplcp,
 					NULL
 				};
 
 				proto_tree_add_bitmask(radiotap_tree, tvb, offset, hf_radiotap_rxflags, ett_radiotap_rxflags, rxflags, ENC_LITTLE_ENDIAN);
 			}
 			break;
 		}
 
 		case IEEE80211_RADIOTAP_XCHANNEL: {
 			xcflags = tvb_get_letohl(tvb, offset);
 			switch (xcflags & IEEE80211_CHAN_ALLTURBO) {
 
 			case IEEE80211_CHAN_FHSS:
 				/*
 				 * Don't overwrite any FHSS information
 				 * we've seen before this.
 				 */
 				if (phdr.phy != PHDR_802_11_PHY_11_FHSS) {
 					phdr.phy = PHDR_802_11_PHY_11_FHSS;
 				}
 				break;
 
 			case IEEE80211_CHAN_DSSS:
 				phdr.phy = PHDR_802_11_PHY_11_DSSS;
 				break;
 
 			case IEEE80211_CHAN_A:
 				phdr.phy = PHDR_802_11_PHY_11A;
 				phdr.phy_info.info_11a.has_turbo_type = TRUE;
 				phdr.phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_NORMAL;
 				break;
 
 			case IEEE80211_CHAN_B:
 				phdr.phy = PHDR_802_11_PHY_11B;
 				if (have_rflags) {
 					phdr.phy_info.info_11b.has_short_preamble = TRUE;
 					phdr.phy_info.info_11b.short_preamble = (rflags & IEEE80211_RADIOTAP_F_SHORTPRE) != 0;
 				}
 				break;
 
 			case IEEE80211_CHAN_PUREG:
 				phdr.phy = PHDR_802_11_PHY_11G;
 				phdr.phy_info.info_11g.has_mode = TRUE;
 				phdr.phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;
 				if (have_rflags) {
 					phdr.phy_info.info_11g.has_short_preamble = TRUE;
 					phdr.phy_info.info_11g.short_preamble = (rflags & IEEE80211_RADIOTAP_F_SHORTPRE) != 0;
 				}
 				break;
 
 			case IEEE80211_CHAN_G:
 				phdr.phy = PHDR_802_11_PHY_11G;
 				phdr.phy_info.info_11g.has_mode = TRUE;
 				phdr.phy_info.info_11g.mode = PHDR_802_11G_MODE_NORMAL;
 				if (have_rflags) {
 					phdr.phy_info.info_11g.has_short_preamble = TRUE;
 					phdr.phy_info.info_11g.short_preamble = (rflags & IEEE80211_RADIOTAP_F_SHORTPRE) != 0;
 				}
 				break;
 
 			case IEEE80211_CHAN_108A:
 				phdr.phy = PHDR_802_11_PHY_11A;
 				phdr.phy_info.info_11a.has_turbo_type = TRUE;
 				/* We assume non-STURBO is dynamic turbo */
 				phdr.phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_DYNAMIC_TURBO;
 				break;
 
 			case IEEE80211_CHAN_108PUREG:
 				phdr.phy = PHDR_802_11_PHY_11G;
 				phdr.phy_info.info_11g.has_mode = TRUE;
 				phdr.phy_info.info_11g.mode = PHDR_802_11G_MODE_SUPER_G;
 				if (have_rflags) {
 					phdr.phy_info.info_11g.has_short_preamble = TRUE;
 					phdr.phy_info.info_11g.short_preamble = (rflags & IEEE80211_RADIOTAP_F_SHORTPRE) != 0;
 				}
 				break;
 
 			case IEEE80211_CHAN_ST:
 				phdr.phy = PHDR_802_11_PHY_11A;
 				phdr.phy_info.info_11a.has_turbo_type = TRUE;
 				phdr.phy_info.info_11a.turbo_type = PHDR_802_11A_TURBO_TYPE_STATIC_TURBO;
 				break;
 
 			case IEEE80211_CHAN_A|IEEE80211_CHAN_HT20:
 			case IEEE80211_CHAN_A|IEEE80211_CHAN_HT40D:
 			case IEEE80211_CHAN_A|IEEE80211_CHAN_HT40U:
 			case IEEE80211_CHAN_G|IEEE80211_CHAN_HT20:
 			case IEEE80211_CHAN_G|IEEE80211_CHAN_HT40U:
 			case IEEE80211_CHAN_G|IEEE80211_CHAN_HT40D:
 				phdr.phy = PHDR_802_11_PHY_11N;
 
 				/*
 				 * This doesn't supply "short GI" information,
 				 * so use the 0x80 bit in the Flags field,
 				 * if we have it; it's "Currently unspecified
 				 * but used" for that purpose, according to
 				 * the radiotap.org page for that field.
 				 */
 				if (have_rflags) {
 					phdr.phy_info.info_11n.has_short_gi = TRUE;
 					if (rflags & 0x80)
 						phdr.phy_info.info_11n.short_gi = 1;
 					else
 						phdr.phy_info.info_11n.short_gi = 0;
 				}
 				break;
 			}
 			freq = tvb_get_letohs(tvb, offset + 4);
 			if (freq != 0) {
 				/*
 				 * XXX - some captures have 0, which is
 				 * obviously bogus.
 				 */
 				phdr.has_frequency = TRUE;
 				phdr.frequency = freq;
 			}
 			phdr.has_channel = TRUE;
 			phdr.channel = tvb_get_guint8(tvb, offset + 6);
 			if (tree) {
 				static const int * xchannel_flags[] = {
 					&hf_radiotap_xchannel_flags_turbo,
 					&hf_radiotap_xchannel_flags_cck,
 					&hf_radiotap_xchannel_flags_ofdm,
 					&hf_radiotap_xchannel_flags_2ghz,
 					&hf_radiotap_xchannel_flags_5ghz,
 					&hf_radiotap_xchannel_flags_passive,
 					&hf_radiotap_xchannel_flags_dynamic,
 					&hf_radiotap_xchannel_flags_gfsk,
 					&hf_radiotap_xchannel_flags_gsm,
 					&hf_radiotap_xchannel_flags_sturbo,
 					&hf_radiotap_xchannel_flags_half,
 					&hf_radiotap_xchannel_flags_quarter,
 					&hf_radiotap_xchannel_flags_ht20,
 					&hf_radiotap_xchannel_flags_ht40u,
 					&hf_radiotap_xchannel_flags_ht40d,
 					NULL
 				};
 
 				proto_tree_add_item(radiotap_tree,
 							hf_radiotap_xchannel_channel,
 							tvb, offset + 6, 1,
 							ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(radiotap_tree,
 							hf_radiotap_xchannel_frequency,
 							tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);
 
 				proto_tree_add_bitmask(radiotap_tree, tvb, offset, hf_radiotap_xchannel_flags, ett_radiotap_xchannel_flags, xchannel_flags, ENC_LITTLE_ENDIAN);
 
 
 #if 0
 				proto_tree_add_uint(radiotap_tree,
 							hf_radiotap_xchannel_maxpower,
 							tvb, offset + 7, 1, maxpower);
 #endif
 			}
 			break;
 		}
 		case IEEE80211_RADIOTAP_MCS: {
 			proto_tree *mcs_tree = NULL;
 			guint8	    mcs_known, mcs_flags;
 			guint8	    mcs;
 			guint	    bandwidth;
 			guint	    gi_length;
 			gboolean    can_calculate_rate;
 
 			/*
 			 * Start out assuming that we can calculate the rate;
 			 * if we are missing any of the MCS index, channel
 			 * width, or guard interval length, we can't.
 			 */
 			can_calculate_rate = TRUE;
 
 			mcs_known = tvb_get_guint8(tvb, offset);
 			/*
 			 * If there's actually any data here, not an
 			 * empty field, this is 802.11n.
 			 */
 			if (mcs_known != 0) {
 				phdr.phy = PHDR_802_11_PHY_11N;
 				memset(&phdr.phy_info.info_11n, 0, sizeof(phdr.phy_info.info_11n));
 			}
 
 			mcs_flags = tvb_get_guint8(tvb, offset + 1);
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS) {
 				mcs = tvb_get_guint8(tvb, offset + 2);
 				phdr.phy_info.info_11n.has_mcs_index = TRUE;
 				phdr.phy_info.info_11n.mcs_index = mcs;
 			} else {
 				mcs = 0;
 				can_calculate_rate = FALSE;	/* no MCS index */
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW) {
 				phdr.phy_info.info_11n.has_bandwidth = TRUE;
 				phdr.phy_info.info_11n.bandwidth = (mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK);
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI) {
 				gi_length = (mcs_flags & IEEE80211_RADIOTAP_MCS_SGI) ?
 				    1 : 0;
 				phdr.phy_info.info_11n.has_short_gi = TRUE;
 				phdr.phy_info.info_11n.short_gi = gi_length;
 			} else {
 				gi_length = 0;
 				can_calculate_rate = FALSE;	/* no GI width */
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FMT) {
 				phdr.phy_info.info_11n.has_greenfield = TRUE;
 				phdr.phy_info.info_11n.greenfield = (mcs_flags & IEEE80211_RADIOTAP_MCS_FMT_GF) != 0;
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC) {
 				phdr.phy_info.info_11n.has_fec = TRUE;
 				phdr.phy_info.info_11n.fec = (mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC) ? 1 : 0;
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {
 				phdr.phy_info.info_11n.has_stbc_streams = TRUE;
 				phdr.phy_info.info_11n.stbc_streams = (mcs_flags & IEEE80211_RADIOTAP_MCS_STBC_MASK) >> IEEE80211_RADIOTAP_MCS_STBC_SHIFT;
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_NESS) {
 				phdr.phy_info.info_11n.has_ness = TRUE;
 				/* This is stored a bit weirdly */
 				phdr.phy_info.info_11n.ness =
 				    ((mcs_known & IEEE80211_RADIOTAP_MCS_NESS_BIT1) >> 6) |
 				    ((mcs_flags & IEEE80211_RADIOTAP_MCS_NESS_BIT0) >> 7);
 			}
 
 			if (tree) {
 				proto_item *it;
 				static const int * mcs_haves_with_ness_bit1[] = {
 					&hf_radiotap_mcs_have_bw,
 					&hf_radiotap_mcs_have_index,
 					&hf_radiotap_mcs_have_gi,
 					&hf_radiotap_mcs_have_format,
 					&hf_radiotap_mcs_have_fec,
 					&hf_radiotap_mcs_have_stbc,
 					&hf_radiotap_mcs_have_ness,
 					&hf_radiotap_mcs_ness_bit1,
 					NULL
 				};
 				static const int * mcs_haves_without_ness_bit1[] = {
 					&hf_radiotap_mcs_have_bw,
 					&hf_radiotap_mcs_have_index,
 					&hf_radiotap_mcs_have_gi,
 					&hf_radiotap_mcs_have_format,
 					&hf_radiotap_mcs_have_fec,
 					&hf_radiotap_mcs_have_stbc,
 					&hf_radiotap_mcs_have_ness,
 					NULL
 				};
 
 				it = proto_tree_add_item(radiotap_tree, hf_radiotap_mcs,
 							 tvb, offset, 3, ENC_NA);
 				mcs_tree = proto_item_add_subtree(it, ett_radiotap_mcs);
 
 				if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_NESS)
 					proto_tree_add_bitmask(mcs_tree, tvb, offset, hf_radiotap_mcs_known, ett_radiotap_mcs_known, mcs_haves_with_ness_bit1, ENC_LITTLE_ENDIAN);
 				else
 					proto_tree_add_bitmask(mcs_tree, tvb, offset, hf_radiotap_mcs_known, ett_radiotap_mcs_known, mcs_haves_without_ness_bit1, ENC_LITTLE_ENDIAN);
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW) {
 				bandwidth = ((mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK) == IEEE80211_RADIOTAP_MCS_BW_40) ?
 				    1 : 0;
 				proto_tree_add_uint(mcs_tree, hf_radiotap_mcs_bw,
 							    tvb, offset + 1, 1, mcs_flags);
 			} else {
 				bandwidth = 0;
 				can_calculate_rate = FALSE;	/* no bandwidth */
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI) {
 				proto_tree_add_uint(mcs_tree, hf_radiotap_mcs_gi,
 							    tvb, offset + 1, 1, mcs_flags);
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FMT) {
 				proto_tree_add_uint(mcs_tree, hf_radiotap_mcs_format,
 							    tvb, offset + 1, 1, mcs_flags);
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC) {
 				proto_tree_add_uint(mcs_tree, hf_radiotap_mcs_fec,
 							    tvb, offset + 1, 1, mcs_flags);
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {
 				proto_tree_add_uint(mcs_tree, hf_radiotap_mcs_stbc,
 							    tvb, offset + 1, 1, mcs_flags);
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_NESS) {
 				proto_tree_add_uint(mcs_tree, hf_radiotap_mcs_ness_bit0,
 							    tvb, offset + 1, 1, mcs_flags);
 			}
 			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS) {
 				proto_tree_add_uint(mcs_tree, hf_radiotap_mcs_index,
 							    tvb, offset + 2, 1, mcs);
 			}
 
 			/*
 			 * If we have the MCS index, channel width, and
 			 * guard interval length, and the MCS index is
 			 * valid, we can compute the rate.  If the resulting
 			 * rate is non-zero, report it.  (If it's zero,
 			 * it's an MCS/channel width/GI combination that
 			 * 802.11n doesn't support.)
 			 */
 			if (can_calculate_rate && mcs <= MAX_MCS_INDEX
 					&& ieee80211_ht_Dbps[mcs] != 0) {
 				float rate = ieee80211_htrate(mcs, bandwidth, gi_length);
 				col_add_fstr(pinfo->cinfo, COL_TX_RATE, "%.1f", rate);
 				if (tree) {
 					rate_ti = proto_tree_add_float_format(radiotap_tree,
 						hf_radiotap_datarate,
 						tvb, offset, 3, rate,
 						"Data Rate: %.1f Mb/s", rate);
 					PROTO_ITEM_SET_GENERATED(rate_ti);
 				}
 			}
 			break;
 		}
 		case IEEE80211_RADIOTAP_AMPDU_STATUS: {
 			proto_item *it;
 			proto_tree *ampdu_tree = NULL, *ampdu_flags_tree;
 			guint16	    ampdu_flags;
 
 			phdr.has_aggregate_info = 1;
 			phdr.aggregate_flags = 0;
 			phdr.aggregate_id = tvb_get_letohl(tvb, offset);
 
 			ampdu_flags = tvb_get_letohs(tvb, offset + 4);
 			if (ampdu_flags & IEEE80211_RADIOTAP_AMPDU_IS_LAST)
 				phdr.aggregate_flags |= PHDR_802_11_LAST_PART_OF_A_MPDU;
 			if (ampdu_flags & IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_ERR)
 				phdr.aggregate_flags |= PHDR_802_11_A_MPDU_DELIM_CRC_ERROR;
 
 			if (tree) {
 				it = proto_tree_add_item(radiotap_tree, hf_radiotap_ampdu,
 							 tvb, offset, 8, ENC_NA);
 				ampdu_tree = proto_item_add_subtree(it, ett_radiotap_ampdu);
 
 				proto_tree_add_item(ampdu_tree, hf_radiotap_ampdu_ref,
 						    tvb, offset, 4, ENC_LITTLE_ENDIAN);
 
 				it = proto_tree_add_item(ampdu_tree, hf_radiotap_ampdu_flags,
 							 tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);
 				ampdu_flags_tree = proto_item_add_subtree(it, ett_radiotap_ampdu_flags);
 				proto_tree_add_item(ampdu_flags_tree, hf_radiotap_ampdu_flags_report_zerolen,
 						    tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(ampdu_flags_tree, hf_radiotap_ampdu_flags_is_zerolen,
 						    tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(ampdu_flags_tree, hf_radiotap_ampdu_flags_last_known,
 						    tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(ampdu_flags_tree, hf_radiotap_ampdu_flags_is_last,
 						    tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(ampdu_flags_tree, hf_radiotap_ampdu_flags_delim_crc_error,
 						    tvb, offset + 4, 2, ENC_LITTLE_ENDIAN);
 			}
 			if (ampdu_flags & IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_KNOWN) {
 				if (ampdu_tree)
 					proto_tree_add_item(ampdu_tree, hf_radiotap_ampdu_delim_crc,
 							    tvb, offset + 6, 1, ENC_NA);
 			}
 			break;
 		}
 		case IEEE80211_RADIOTAP_VHT: {
 			proto_item *it, *it_root = NULL;
 			proto_tree *vht_tree	 = NULL, *vht_known_tree = NULL, *user_tree = NULL;
 			guint16	    known;
 			guint8	    vht_flags, bw, mcs_nss;
 			guint	    bandwidth	 = 0;
 			guint	    gi_length	 = 0;
 			guint	    nss		 = 0;
 			guint	    mcs		 = 0;
 			gboolean    can_calculate_rate;
 			guint	    i;
 
 			/*
 			 * Start out assuming that we can calculate the rate;
 			 * if we are missing any of the MCS index, channel
 			 * width, or guard interval length, we can't.
 			 */
 			can_calculate_rate = TRUE;
 
 			known = tvb_get_letohs(tvb, offset);
 			/*
 			 * If there's actually any data here, not an
 			 * empty field, this is 802.11ac.
 			 */
 			if (known != 0) {
 				phdr.phy = PHDR_802_11_PHY_11AC;
 			}
 			vht_flags = tvb_get_guint8(tvb, offset + 2);
 			if (tree) {
 				it_root = proto_tree_add_item(radiotap_tree, hf_radiotap_vht,
 						tvb, offset, 12, ENC_NA);
 				vht_tree = proto_item_add_subtree(it_root, ett_radiotap_vht);
 				it = proto_tree_add_item(vht_tree, hf_radiotap_vht_known,
 						tvb, offset, 2, known);
 				vht_known_tree = proto_item_add_subtree(it, ett_radiotap_vht_known);
 
 				proto_tree_add_item(vht_known_tree, hf_radiotap_vht_have_stbc,
 						tvb, offset, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(vht_known_tree, hf_radiotap_vht_have_txop_ps,
 						tvb, offset, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(vht_known_tree, hf_radiotap_vht_have_gi,
 						tvb, offset, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(vht_known_tree, hf_radiotap_vht_have_sgi_nsym_da,
 						tvb, offset, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(vht_known_tree, hf_radiotap_vht_have_ldpc_extra,
 						tvb, offset, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(vht_known_tree, hf_radiotap_vht_have_bf,
 						tvb, offset, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(vht_known_tree, hf_radiotap_vht_have_bw,
 						tvb, offset, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(vht_known_tree, hf_radiotap_vht_have_gid,
 						tvb, offset, 2, ENC_LITTLE_ENDIAN);
 				proto_tree_add_item(vht_known_tree, hf_radiotap_vht_have_p_aid,
 						tvb, offset, 2, ENC_LITTLE_ENDIAN);
 			}
 
 			if (known & IEEE80211_RADIOTAP_VHT_HAVE_STBC) {
 				phdr.phy_info.info_11ac.has_stbc = TRUE;
 				phdr.phy_info.info_11ac.stbc = (vht_flags & IEEE80211_RADIOTAP_VHT_STBC) != 0;
 				if (vht_tree)
 					proto_tree_add_item(vht_tree, hf_radiotap_vht_stbc,
 							tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
 			}
 
 			if (known & IEEE80211_RADIOTAP_VHT_HAVE_TXOP_PS) {
 				phdr.phy_info.info_11ac.has_txop_ps_not_allowed = TRUE;
 				phdr.phy_info.info_11ac.txop_ps_not_allowed = (vht_flags & IEEE80211_RADIOTAP_VHT_TXOP_PS) != 0;
 				if (vht_tree)
 					proto_tree_add_item(vht_tree, hf_radiotap_vht_txop_ps,
 							tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
 			}
 
 			if (known & IEEE80211_RADIOTAP_VHT_HAVE_GI) {
 				gi_length = (vht_flags & IEEE80211_RADIOTAP_VHT_SGI) ? 1 : 0;
 				phdr.phy_info.info_11ac.has_short_gi = TRUE;
 				phdr.phy_info.info_11ac.short_gi = gi_length;
 				if (vht_tree) {
 					proto_tree_add_item(vht_tree, hf_radiotap_vht_gi,
 							tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
 				}
 			} else {
 				can_calculate_rate = FALSE;	/* no GI width */
 			}
 
 			if (known & IEEE80211_RADIOTAP_VHT_HAVE_SGI_NSYM_DA) {
 				phdr.phy_info.info_11ac.has_short_gi_nsym_disambig = TRUE;
 				phdr.phy_info.info_11ac.short_gi_nsym_disambig = (vht_flags & IEEE80211_RADIOTAP_VHT_SGI_NSYM_DA) != 0;
 				if (vht_tree) {
 					it = proto_tree_add_item(vht_tree, hf_radiotap_vht_sgi_nsym_da,
 							tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
 					if ((vht_flags & IEEE80211_RADIOTAP_VHT_SGI_NSYM_DA) &&
 						(known & IEEE80211_RADIOTAP_VHT_HAVE_GI) &&
 						!(vht_flags & IEEE80211_RADIOTAP_VHT_SGI))
 						proto_item_append_text(it, " (invalid)");
 				}
 			}
 
 			if (known & IEEE80211_RADIOTAP_VHT_HAVE_LDPC_EXTRA) {
 				phdr.phy_info.info_11ac.has_ldpc_extra_ofdm_symbol = TRUE;
 				phdr.phy_info.info_11ac.ldpc_extra_ofdm_symbol = (vht_flags & IEEE80211_RADIOTAP_VHT_LDPC_EXTRA) != 0;
 				if (vht_tree) {
 					proto_tree_add_item(vht_tree, hf_radiotap_vht_ldpc_extra,
 							tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
 				}
 			}
 
 			if (known & IEEE80211_RADIOTAP_VHT_HAVE_BF) {
 				phdr.phy_info.info_11ac.has_beamformed = TRUE;
 				phdr.phy_info.info_11ac.beamformed = (vht_flags & IEEE80211_RADIOTAP_VHT_BF) != 0;
 				if (vht_tree)
 					proto_tree_add_item(vht_tree, hf_radiotap_vht_bf,
 							tvb, offset + 2, 1, ENC_LITTLE_ENDIAN);
 			}
 
 			if (known & IEEE80211_RADIOTAP_VHT_HAVE_BW) {
 				bw = tvb_get_guint8(tvb, offset + 3) & IEEE80211_RADIOTAP_VHT_BW_MASK;
 				phdr.phy_info.info_11ac.has_bandwidth = TRUE;
 				phdr.phy_info.info_11ac.bandwidth = bw;
 				if (bw < sizeof(ieee80211_vht_bw2rate_index)/sizeof(ieee80211_vht_bw2rate_index[0]))
 					bandwidth = ieee80211_vht_bw2rate_index[bw];
 				else
 					can_calculate_rate = FALSE; /* unknown bandwidth */
 
 				if (vht_tree)
 					proto_tree_add_item(vht_tree, hf_radiotap_vht_bw,
 							tvb, offset + 3, 1, ENC_LITTLE_ENDIAN);
 			} else {
 				can_calculate_rate = FALSE;	/* no bandwidth */
 			}
 
 			phdr.phy_info.info_11ac.has_fec = TRUE;
 			phdr.phy_info.info_11ac.fec = tvb_get_guint8(tvb, offset + 8);
 
 			for(i=0; i<4; i++) {
 				mcs_nss = tvb_get_guint8(tvb, offset + 4 + i);
 				nss = (mcs_nss & IEEE80211_RADIOTAP_VHT_NSS);
 				mcs = (mcs_nss & IEEE80211_RADIOTAP_VHT_MCS) >> 4;
 				phdr.phy_info.info_11ac.mcs[i] = mcs;
 				phdr.phy_info.info_11ac.nss[i] = nss;
 
 				if (nss) {
 					/*
 					 * OK, there's some data here.
 					 * If we haven't already flagged this
 					 * as VHT, do so.
 					 */
 					if (phdr.phy != PHDR_802_11_PHY_11AC) {
 						phdr.phy = PHDR_802_11_PHY_11AC;
 					}
 					if (vht_tree) {
 						it = proto_tree_add_item(vht_tree, hf_radiotap_vht_user,
 							tvb, offset + 4, 5, ENC_NA);
 						proto_item_append_text(it, " %d: MCS %u", i, mcs);
 						user_tree = proto_item_add_subtree(it, ett_radiotap_vht_user);
 
 						it = proto_tree_add_item(user_tree, hf_radiotap_vht_mcs[i],
 							tvb, offset + 4 + i, 1,
 							ENC_LITTLE_ENDIAN);
 						if (mcs > MAX_MCS_VHT_INDEX) {
 							proto_item_append_text(it, " (invalid)");
 						} else {
 							proto_item_append_text(it, " (%s %s)",
 								ieee80211_vhtinfo[mcs].modulation,
 								ieee80211_vhtinfo[mcs].coding_rate);
 						}
 
 						proto_tree_add_item(user_tree, hf_radiotap_vht_nss[i],
 							tvb, offset + 4 + i, 1, ENC_LITTLE_ENDIAN);
 						if (known & IEEE80211_RADIOTAP_VHT_HAVE_STBC) {
 							guint nsts;
 							proto_item *nsts_ti;
 
 							if (vht_flags & IEEE80211_RADIOTAP_VHT_STBC)
 								nsts = 2 * nss;
 							else
 								nsts = nss;
 							nsts_ti = proto_tree_add_uint(user_tree, hf_radiotap_vht_nsts[i],
 								tvb, offset + 4 + i, 1, nsts);
 							PROTO_ITEM_SET_GENERATED(nsts_ti);
 						}
 						proto_tree_add_item(user_tree, hf_radiotap_vht_coding[i],
 							tvb, offset + 8, 1,ENC_LITTLE_ENDIAN);
 					}
 
 					if (can_calculate_rate && mcs <= MAX_MCS_VHT_INDEX &&
 					    nss <= MAX_VHT_NSS ) {
 						float rate = ieee80211_vhtinfo[mcs].rates[bandwidth][gi_length] * nss;
 						if (rate != 0.0f ) {
 							rate_ti = proto_tree_add_float_format(user_tree,
 									hf_radiotap_vht_datarate[i],
 									tvb, offset, 12, rate,
 									"Data Rate: %.1f Mb/s", rate);
 							PROTO_ITEM_SET_GENERATED(rate_ti);
-							if (ieee80211_vhtvalid[mcs].valid[bandwidth][nss] == FALSE)
+							if (ieee80211_vhtvalid[mcs].valid[bandwidth][nss-1] == FALSE)
 								expert_add_info(pinfo, rate_ti, &ei_radiotap_invalid_data_rate);
 
 						}
 					}
 				}
 			}
 
 			if (known & IEEE80211_RADIOTAP_VHT_HAVE_GID) {
 				phdr.phy_info.info_11ac.has_group_id = TRUE;
 				phdr.phy_info.info_11ac.group_id = tvb_get_guint8(tvb, offset + 9);
 				if (vht_tree)
 					proto_tree_add_item(vht_tree, hf_radiotap_vht_gid,
 							tvb, offset+9, 1, ENC_LITTLE_ENDIAN);
 			}
 
 			if (known & IEEE80211_RADIOTAP_VHT_HAVE_PAID) {
 				phdr.phy_info.info_11ac.has_partial_aid = TRUE;
 				phdr.phy_info.info_11ac.partial_aid = tvb_get_letohs(tvb, offset + 10);
 				if (vht_tree) {
 					proto_tree_add_item(vht_tree, hf_radiotap_vht_p_aid,
 							tvb, offset+10, 2, ENC_LITTLE_ENDIAN);
 				}
 			}
 
 			break;
 		}
 		case IEEE80211_RADIOTAP_TIMESTAMP: {
 			proto_item *it_root;
 			proto_tree *ts_tree, *flg_tree;
 
 			it_root = proto_tree_add_item(radiotap_tree, hf_radiotap_timestamp,
 					tvb, offset, 12, ENC_NA);
 			ts_tree = proto_item_add_subtree(it_root, ett_radiotap_timestamp);
 
 			proto_tree_add_item(ts_tree, hf_radiotap_timestamp_ts,
 					tvb, offset, 8, ENC_LITTLE_ENDIAN);
 			if (tvb_get_letohs(tvb, offset + 11) & IEEE80211_RADIOTAP_TS_FLG_ACCURACY)
 				proto_tree_add_item(ts_tree, hf_radiotap_timestamp_accuracy,
 					tvb, offset + 8, 2, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(ts_tree, hf_radiotap_timestamp_unit,
 					tvb, offset + 10, 1, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(ts_tree, hf_radiotap_timestamp_spos,
 					tvb, offset + 10, 1, ENC_LITTLE_ENDIAN);
 			flg_tree = proto_item_add_subtree(ts_tree, ett_radiotap_timestamp_flags);
 			proto_tree_add_item(flg_tree,
 					hf_radiotap_timestamp_flags_32bit, tvb,
 					offset + 11, 1, ENC_LITTLE_ENDIAN);
 			proto_tree_add_item(flg_tree,
 					hf_radiotap_timestamp_flags_accuracy, tvb,
 					offset + 11, 1, ENC_LITTLE_ENDIAN);
 			break;
 		}
 		}
 	}
 
 	if (err != -ENOENT && tree) {
 		expert_add_info(pinfo, present_item,
 		    &ei_radiotap_data_past_header);
  malformed:
 		proto_item_append_text(ti, " (malformed)");
 	}
 
  hand_off_to_80211:
 	/* Grab the rest of the frame. */
 	next_tvb = tvb_new_subset_remaining(tvb, length);
 
 	/* If we had an in-header FCS, check it.
 	 * This can only happen if the backward-compat configuration option
 	 * is chosen by the user. */
 	if (hdr_fcs_ti) {
 		guint captured_length = tvb_captured_length(next_tvb);
 		guint reported_length = tvb_reported_length(next_tvb);
 		guint fcs_len = (phdr.fcs_len > 0) ? phdr.fcs_len : 0;
 
 		/* It would be very strange for the header to have an FCS for the
 		 * frame *and* the frame to have the FCS at the end, but it's possible, so
 		 * take that into account by using the FCS length recorded in pinfo. */
 
 		/* Watch out for [erroneously] short frames */
 		if (captured_length >= reported_length &&
 		    captured_length > fcs_len) {
 			calc_fcs =
 			    crc32_802_tvb(next_tvb, tvb_captured_length(next_tvb) - fcs_len);
 
 			/* By virtue of hdr_fcs_ti being set, we know that 'tree' is set,
 			 * so there's no need to check it here. */
 			if (calc_fcs == sent_fcs) {
 				proto_item_append_text(hdr_fcs_ti,
 						       " [correct]");
 			} else {
 				proto_item_append_text(hdr_fcs_ti,
 						       " [incorrect, should be 0x%08x]",
 						       calc_fcs);
 				hidden_item =
 				    proto_tree_add_boolean(radiotap_tree,
 							   hf_radiotap_fcs_bad,
 							   tvb, hdr_fcs_offset,
 							   4, TRUE);
 				PROTO_ITEM_SET_HIDDEN(hidden_item);
 			}
 		} else {
 			proto_item_append_text(hdr_fcs_ti,
 					       " [cannot verify - not enough data]");
 		}
 	}
 
 	/* dissect the 802.11 packet next */
 	call_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo,
 	    tree, &phdr);
 
 	tap_queue_packet(radiotap_tap, pinfo, radiotap_info);
 	return tvb_captured_length(tvb);
 }
