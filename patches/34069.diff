commit 9cabe33ee9c6f1098e7866c0d05217d948e0b19c
Merge: 634c3ceaa 383b80986
Author: Richard Cordovano <rcordovano@basistech.com>
Date:   Wed Jun 23 10:03:12 2021 -0400

    Merge pull request #2458 from sleuthkit/release-4.11.0
    
    Merge release 4.11.0 into develop

diff --git a/tsk/fs/hfs.c b/tsk/fs/hfs.c
index e3221152b..e778f5eb5 100644
--- a/tsk/fs/hfs.c
+++ b/tsk/fs/hfs.c
@@ -306,431 +306,437 @@ static uint8_t
 hfs_ext_find_extent_record_attr(HFS_INFO * hfs, uint32_t cnid,
     TSK_FS_ATTR * a_attr, unsigned char dataForkQ)
 {
     TSK_FS_INFO *fs = (TSK_FS_INFO *) & (hfs->fs_info);
     uint16_t nodesize;          /* size of nodes (all, regardless of the name) */
     uint32_t cur_node;          /* node id of the current node */
     char *node = NULL;
     uint8_t is_done;
     uint8_t desiredType;
 
     tsk_error_reset();
 
     if (tsk_verbose)
         tsk_fprintf(stderr,
             "hfs_ext_find_extent_record_attr: Looking for extents for file %"
             PRIu32 " %s\n", cnid,
             dataForkQ ? "data fork" : "resource fork");
 
     if (!hfs->has_extents_file) {
         // No extents file (which is optional), and so, no further extents are possible.
         return 0;
     }
 
     // Are we looking for extents of the data fork or the resource fork?
     desiredType =
         dataForkQ ? HFS_EXT_KEY_TYPE_DATA : HFS_EXT_KEY_TYPE_RSRC;
 
     // Load the extents attribute, if it has not been done so yet.
     if (hfs->extents_file == NULL) {
         ssize_t cnt;
 
         if ((hfs->extents_file =
                 tsk_fs_file_open_meta(fs, NULL,
                     HFS_EXTENTS_FILE_ID)) == NULL) {
             return 1;
         }
 
         /* cache the data attribute */
         hfs->extents_attr =
             tsk_fs_attrlist_get(hfs->extents_file->meta->attr,
             TSK_FS_ATTR_TYPE_DEFAULT);
         if (!hfs->extents_attr) {
             tsk_error_errstr2_concat
                 (" - Default Attribute not found in Extents File");
             return 1;
         }
 
         // cache the extents file header
         cnt = tsk_fs_attr_read(hfs->extents_attr, 14,
             (char *) &(hfs->extents_header),
             sizeof(hfs_btree_header_record), 0);
         if (cnt != sizeof(hfs_btree_header_record)) {
             if (cnt >= 0) {
                 tsk_error_reset();
                 tsk_error_set_errno(TSK_ERR_FS_READ);
             }
             tsk_error_set_errstr2
                 ("hfs_ext_find_extent_record_attr: Error reading header");
             return 1;
         }
     }
 
     // allocate a node buffer
     nodesize = tsk_getu16(fs->endian, hfs->extents_header.nodesize);
     if ((node = (char *) tsk_malloc(nodesize)) == NULL) {
         return 1;
     }
 
     /* start at root node */
     cur_node = tsk_getu32(fs->endian, hfs->extents_header.rootNode);
 
     /* if the root node is zero, then the extents btree is empty */
     /* if no files have overflow extents, the Extents B-tree still
        exists on disk, but is an empty B-tree containing only
        the header node */
     if (cur_node == 0) {
         if (tsk_verbose)
             tsk_fprintf(stderr, "hfs_ext_find_extent_record: "
                 "empty extents btree\n");
         free(node);
         return 0;
     }
 
     if (tsk_verbose)
         tsk_fprintf(stderr, "hfs_ext_find_extent_record: starting at "
             "root node %" PRIu32 "; nodesize = %"
             PRIu16 "\n", cur_node, nodesize);
 
     /* Recurse down to the needed leaf nodes and then go forward */
     is_done = 0;
     while (is_done == 0) {
         TSK_OFF_T cur_off;      /* start address of cur_node */
         uint16_t num_rec;       /* number of records in this node */
         ssize_t cnt;
         hfs_btree_node *node_desc;
 
         // sanity check
         if (cur_node > tsk_getu32(fs->endian,
                 hfs->extents_header.totalNodes)) {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             tsk_error_set_errstr
                 ("hfs_ext_find_extent_record_attr: Node %d too large for file",
                 cur_node);
             free(node);
             return 1;
         }
 
         // read the current node
         cur_off = (TSK_OFF_T)cur_node * nodesize;
         if (tsk_verbose)
             tsk_fprintf(stderr,
                 "hfs_ext_find_extent_record: reading node %" PRIu32
                 " at offset %" PRIdOFF "\n", cur_node, cur_off);
 
         cnt = tsk_fs_attr_read(hfs->extents_attr, cur_off,
             node, nodesize, 0);
         if (cnt != nodesize) {
             if (cnt >= 0) {
                 tsk_error_reset();
                 tsk_error_set_errno(TSK_ERR_FS_READ);
             }
             tsk_error_set_errstr2
                 ("hfs_ext_find_extent_record_attr: Error reading node %d at offset %"
                 PRIdOFF, cur_node, cur_off);
             free(node);
             return 1;
         }
 
         // process the header / descriptor
         if (nodesize < sizeof(hfs_btree_node)) {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             tsk_error_set_errstr
                 ("hfs_ext_find_extent_record_attr: Node size %d is too small to be valid", nodesize);
             free(node);
             return 1;
         }
         node_desc = (hfs_btree_node *) node;
         num_rec = tsk_getu16(fs->endian, node_desc->num_rec);
 
         if (num_rec == 0) {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             tsk_error_set_errstr
                 ("hfs_ext_find_extent_record: zero records in node %"
                 PRIu32, cur_node);
             free(node);
             return 1;
         }
 
 
         /* With an index node, find the record with the largest key that is smaller
          * to or equal to cnid */
         if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {
             uint32_t next_node = 0;
             int rec;
 
             if (tsk_verbose)
                 tsk_fprintf(stderr,
                     "hfs_ext_find_extent_record: Index node %" PRIu32
                     " @ %" PRIu64 " has %" PRIu16 " records\n", cur_node,
                     cur_off, num_rec);
 
             for (rec = 0; rec < num_rec; ++rec) {
                 int cmp;
                 size_t rec_off;
                 hfs_btree_key_ext *key;
 
                 // Make sure node is large enough, note that (rec + 1) * 2 is an offset
                 // relative to the end of node
                 if ((rec + 1) * 2 > (int) nodesize) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_ext_find_extent_record: offset of record %d in leaf node %d too small (%"
                         PRIu16 ")", rec, cur_node, nodesize);
                     free(node);
                     return 1;
                 }
                 // get the record offset in the node
                 rec_off =
                     tsk_getu16(fs->endian,
                     &node[nodesize - (rec + 1) * 2]);
                 if (rec_off + sizeof(hfs_btree_key_ext) > nodesize) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_ext_find_extent_record_attr: offset of record %d in index node %d too large (%d vs %"
                         PRIu16 ")", rec, cur_node, (int) rec_off,
                         nodesize);
                     free(node);
                     return 1;
                 }
                 key = (hfs_btree_key_ext *) & node[rec_off];
 
                 cmp = hfs_ext_compare_keys(hfs, cnid, key);
 
                 if (tsk_verbose)
                     tsk_fprintf(stderr,
                         "hfs_ext_find_extent_record: record %" PRIu16
                         " ; keylen %" PRIu16 " (FileId: %" PRIu32
                         ", ForkType: %" PRIu8 ", StartBlk: %" PRIu32
                         "); compare: %d\n", rec, tsk_getu16(fs->endian,
                             key->key_len), tsk_getu32(fs->endian,
                             key->file_id), key->fork_type,
                         tsk_getu32(fs->endian, key->start_block), cmp);
 
                 /* save the info from this record unless it is bigger than cnid */
                 if ((cmp <= 0) || (next_node == 0)) {
                     hfs_btree_index_record *idx_rec;
                     int keylen =
                         2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,
                             key->key_len), &(hfs->extents_header));
-                    if (rec_off + keylen > nodesize) {
+                    if ((nodesize < 4) || (keylen > nodesize - 4) || (rec_off >= nodesize - 4 - keylen)) {
                         tsk_error_set_errno(TSK_ERR_FS_GENFS);
                         tsk_error_set_errstr
                             ("hfs_ext_find_extent_record_attr: offset and keylenth of record %d in index node %d too large (%d vs %"
                             PRIu16 ")", rec, cur_node,
                             (int) rec_off + keylen, nodesize);
                         free(node);
                         return 1;
                     }
                     idx_rec =
                         (hfs_btree_index_record *) & node[rec_off +
                         keylen];
                     next_node = tsk_getu32(fs->endian, idx_rec->childNode);
                 }
 
                 // we are bigger than cnid, so move on to the next node
                 if (cmp > 0) {
                     break;
                 }
             }
 
             // check if we found a relevant node, if not stop.
             if (next_node == 0) {
                 if (tsk_verbose)
                     tsk_fprintf(stderr,
                         "hfs_ext_find_extent_record_attr: did not find any keys for %d in index node %d",
                         cnid, cur_node);
                 is_done = 1;
                 break;
             }
             cur_node = next_node;
         }
 
         /* with a leaf, we process until we are past cnid.  We move right too if we can */
         else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {
             int rec;
 
             if (tsk_verbose)
                 tsk_fprintf(stderr,
                     "hfs_ext_find_extent_record: Leaf node %" PRIu32 " @ %"
                     PRIu64 " has %" PRIu16 " records\n", cur_node, cur_off,
                     num_rec);
 
             for (rec = 0; rec < num_rec; ++rec) {
                 size_t rec_off;
                 hfs_btree_key_ext *key;
                 uint32_t rec_cnid;
                 hfs_extents *extents;
                 TSK_OFF_T ext_off = 0;
                 int keylen;
                 TSK_FS_ATTR_RUN *attr_run;
 
                 // Make sure node is large enough, note that (rec + 1) * 2 is an offset
                 // relative to the end of node
                 if ((rec + 1) * 2 > (int) nodesize) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_ext_find_extent_record_attr: offset of record %d in leaf node %d too small (%"
                         PRIu16 ")", rec, cur_node, nodesize);
                     free(node);
                     return 1;
                 }
                 // get the record offset in the node
                 rec_off =
                     tsk_getu16(fs->endian,
                     &node[nodesize - (rec + 1) * 2]);
                 if (rec_off >= nodesize) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_ext_find_extent_record_attr: offset of record %d in leaf node %d too large (%d vs %"
                         PRIu16 ")", rec, cur_node, (int) rec_off,
                         nodesize);
                     free(node);
                     return 1;
                 }
 
                 // Check that the whole hfs_btree_key_ext structure is set
                 if (sizeof(hfs_btree_key_ext) > nodesize - rec_off) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                     ("hfs_ext_find_extent_record_attr: record %d in leaf node %d truncated (have %d vs %"
                         PRIu16 " bytes)", rec, cur_node, nodesize - (int)rec_off,
                         sizeof(hfs_btree_key_ext));
                     free(node);
                     return 1;
                 }
 
                 key = (hfs_btree_key_ext *) & node[rec_off];
 
                 if (tsk_verbose)
                     tsk_fprintf(stderr,
                         "hfs_ext_find_extent_record: record %" PRIu16
                         "; keylen %" PRIu16 " (%" PRIu32
                         ", %" PRIu8 ", %" PRIu32 ")\n", rec,
                         tsk_getu16(fs->endian, key->key_len),
                         tsk_getu32(fs->endian, key->file_id),
                         key->fork_type, tsk_getu32(fs->endian,
                             key->start_block));
 
                 rec_cnid = tsk_getu32(fs->endian, key->file_id);
 
                 // see if this record is for our file
                 // OLD logic, just handles the DATA fork
 //                if (rec_cnid < cnid) {
 //                    continue;
 //                }
 //                else if ((rec_cnid > cnid)
 //                    || (key->fork_type != HFS_EXT_KEY_TYPE_DATA)) {
 //                    is_done = 1;
 //                    break;
 //                }
 
                 // NEW logic, handles both DATA and RSRC forks.
                 if (rec_cnid < cnid) {
                     continue;
                 }
                 if (rec_cnid > cnid) {
                     is_done = 1;
                     break;
                 }
 
 
                 if (key->fork_type != desiredType) {
                     if (dataForkQ) {
                         is_done = 1;
                         break;
                     }
                     else
                         continue;
                 }
 
                 // OK, this is one of the extents records that we are seeking, so save it.
                 // Make sure there is room for the hfs_extents struct
                 keylen = 2 + tsk_getu16(fs->endian, key->key_len);
                 if (rec_off + keylen + sizeof(hfs_extents) > nodesize) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_ext_find_extent_record_attr: offset and keylenth of record %d in leaf node %d too large (%d vs %"
                         PRIu16 ")", rec, cur_node, (int) rec_off + keylen,
                         nodesize);
                     free(node);
                     return 1;
                 }
 
                 // get the starting offset of this extent
                 ext_off = tsk_getu32(fs->endian, key->start_block);
 
                 // convert the extents to the TSK format
                 extents = (hfs_extents *) & node[rec_off + keylen];
 
                 attr_run =
                     hfs_extents_to_attr(fs, extents->extents, ext_off);
                 if ((attr_run == NULL) && (tsk_error_get_errno() != 0)) {
                     tsk_error_errstr2_concat
                         (" - hfs_ext_find_extent_record_attr");
                     free(node);
                     return 1;
                 }
 
                 if (tsk_fs_attr_add_run(fs, a_attr, attr_run)) {
                     tsk_error_errstr2_concat
                         (" - hfs_ext_find_extent_record_attr");
                     free(node);
                     return 1;
                 }
             }
             cur_node = tsk_getu32(fs->endian, node_desc->flink);
             if (cur_node == 0) {
                 is_done = 1;
                 break;
             }
         }
         else {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             tsk_error_set_errstr("hfs_ext_find_extent_record: btree node %"
                 PRIu32 " (%" PRIdOFF ") is neither index nor leaf (%" PRIu8
                 ")", cur_node, cur_off, node_desc->type);
             free(node);
             return 1;
         }
     }
     free(node);
     return 0;
 }
 
 
 /** \internal
  * Compares two Catalog B-tree keys.
  * @param hfs File System being analyzed
  * @param key1 Key 1 to compare
  * @param key2 Key 2 to compare
  * @returns -1 if key1 is smaller, 0 if equal, and 1 if key1 is larger
  */
 int
 hfs_cat_compare_keys(HFS_INFO * hfs, const hfs_btree_key_cat * key1,
-    const hfs_btree_key_cat * key2)
+    int keylen1, const hfs_btree_key_cat * key2)
 {
     TSK_FS_INFO *fs = (TSK_FS_INFO *) & (hfs->fs_info);
     uint32_t cnid1, cnid2;
 
+    if (keylen1 < 6) {
+        // Note that it would be better to return an error value here
+        // but the current function interface does not support this
+        // Also see issue #2365
+        return -1;
+    }
     cnid1 = tsk_getu32(fs->endian, key1->parent_cnid);
     cnid2 = tsk_getu32(fs->endian, key2->parent_cnid);
 
     if (cnid1 < cnid2)
         return -1;
     if (cnid1 > cnid2)
         return 1;
 
-    return hfs_unicode_compare(hfs, &key1->name, &key2->name);
+    return hfs_unicode_compare(hfs, &key1->name, keylen1 - 6, &key2->name);
 }
 
 
 /** \internal
  *
  * Traverse the HFS catalog file.  Call the callback for each
  * record.
  *
  * @param hfs File system
  * @param a_cb callback
  * @param ptr Pointer to pass to callback
  * @returns 1 on error
  */
@@ -738,315 +744,315 @@ uint8_t
 hfs_cat_traverse(HFS_INFO * hfs,
     TSK_HFS_BTREE_CB a_cb, void *ptr)
 {
     TSK_FS_INFO *fs = &(hfs->fs_info);
     uint32_t cur_node;          /* node id of the current node */
     char *node;
 
     uint16_t nodesize;
     uint8_t is_done = 0;
 
     tsk_error_reset();
 
     nodesize = tsk_getu16(fs->endian, hfs->catalog_header.nodesize);
     if ((node = (char *) tsk_malloc(nodesize)) == NULL)
         return 1;
 
     /* start at root node */
     cur_node = tsk_getu32(fs->endian, hfs->catalog_header.rootNode);
 
     /* if the root node is zero, then the extents btree is empty */
     /* if no files have overflow extents, the Extents B-tree still
        exists on disk, but is an empty B-tree containing only
        the header node */
     if (cur_node == 0) {
         if (tsk_verbose)
             tsk_fprintf(stderr, "hfs_cat_traverse: "
                 "empty extents btree\n");
         free(node);
         return 1;
     }
 
     if (tsk_verbose)
         tsk_fprintf(stderr, "hfs_cat_traverse: starting at "
             "root node %" PRIu32 "; nodesize = %"
             PRIu16 "\n", cur_node, nodesize);
 
     /* Recurse down to the needed leaf nodes and then go forward */
     is_done = 0;
     while (is_done == 0) {
         TSK_OFF_T cur_off;      /* start address of cur_node */
         uint16_t num_rec;       /* number of records in this node */
         ssize_t cnt;
         hfs_btree_node *node_desc;
 
         // sanity check
         if (cur_node > tsk_getu32(fs->endian,
                 hfs->catalog_header.totalNodes)) {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             tsk_error_set_errstr
                 ("hfs_cat_traverse: Node %d too large for file", cur_node);
             free(node);
             return 1;
         }
 
         // read the current node
         cur_off = (TSK_OFF_T)cur_node * nodesize;
         cnt = tsk_fs_attr_read(hfs->catalog_attr, cur_off,
             node, nodesize, 0);
         if (cnt != nodesize) {
             if (cnt >= 0) {
                 tsk_error_reset();
                 tsk_error_set_errno(TSK_ERR_FS_READ);
             }
             tsk_error_set_errstr2
                 ("hfs_cat_traverse: Error reading node %d at offset %"
                 PRIdOFF, cur_node, cur_off);
             free(node);
             return 1;
         }
 
         // process the header / descriptor
         if (nodesize < sizeof(hfs_btree_node)) {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             tsk_error_set_errstr
             ("hfs_cat_traverse: Node size %d is too small to be valid", nodesize);
             free(node);
             return 1;
         }
         node_desc = (hfs_btree_node *) node;
         num_rec = tsk_getu16(fs->endian, node_desc->num_rec);
 
         if (tsk_verbose)
             tsk_fprintf(stderr, "hfs_cat_traverse: node %" PRIu32
                 " @ %" PRIu64 " has %" PRIu16 " records\n",
                 cur_node, cur_off, num_rec);
 
         if (num_rec == 0) {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             tsk_error_set_errstr("hfs_cat_traverse: zero records in node %"
                 PRIu32, cur_node);
             free(node);
             return 1;
         }
 
         /* With an index node, find the record with the largest key that is smaller
          * to or equal to cnid */
         if (node_desc->type == HFS_BT_NODE_TYPE_IDX) {
             uint32_t next_node = 0;
             int rec;
 
             for (rec = 0; rec < num_rec; ++rec) {
                 size_t rec_off;
                 hfs_btree_key_cat *key;
                 uint8_t retval;
                 int keylen;
 
                 // Make sure node is large enough, note that (rec + 1) * 2 is an offset
                 // relative to the end of node
                 if ((rec + 1) * 2 > (int) nodesize) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_cat_traverse: offset of record %d in leaf node %d too small (%"
                         PRIu16 ")", rec, cur_node, nodesize);
                     free(node);
                     return 1;
                 }
                 // get the record offset in the node
                 rec_off =
                     tsk_getu16(fs->endian,
                     &node[nodesize - (rec + 1) * 2]);
                 if (rec_off >= nodesize) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_cat_traverse: offset of record %d in index node %d too large (%d vs %"
                         PRIu16 ")", rec, cur_node, (int) rec_off,
                         nodesize);
                     free(node);
                     return 1;
                 }
 
                 key = (hfs_btree_key_cat *) & node[rec_off];
                 keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);
 
                 // Want a key of at least 6 bytes, the size of the first 2 members of hfs_btree_key_cat
                 if ((keylen < 6) || (keylen > nodesize - rec_off)) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_cat_traverse: length of key %d in index node %d out of bounds (6 < %d < %"
                         PRIu16 ")", rec, cur_node, keylen, (nodesize - rec_off));
                     free(node);
                     return 1;
                 }
 
                 /*
                    if (tsk_verbose)
                    tsk_fprintf(stderr,
                    "hfs_cat_traverse: record %" PRIu16
                    " ; keylen %" PRIu16 " (%" PRIu32 ")\n", rec,
                    tsk_getu16(fs->endian, key->key_len),
                    tsk_getu32(fs->endian, key->parent_cnid));
                  */
 
 
                 /* save the info from this record unless it is too big */
                 retval =
-                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key,
+                    a_cb(hfs, HFS_BT_NODE_TYPE_IDX, key, keylen, nodesize,
                     cur_off + rec_off, ptr);
                 if (retval == HFS_BTREE_CB_ERR) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr2
                         ("hfs_cat_traverse: Callback returned error");
                     free(node);
                     return 1;
                 }
                 // record the closest entry
                 else if ((retval == HFS_BTREE_CB_IDX_LT)
                     || (next_node == 0)) {
                     hfs_btree_index_record *idx_rec;
                     int keylen =
                         2 + hfs_get_idxkeylen(hfs, tsk_getu16(fs->endian,
                             key->key_len), &(hfs->catalog_header));
                     if (keylen > nodesize - rec_off) {
                         tsk_error_set_errno(TSK_ERR_FS_GENFS);
                         tsk_error_set_errstr
                             ("hfs_cat_traverse: offset of record and keylength %d in index node %d too large (%d vs %"
                             PRIu16 ")", rec, cur_node,
                             (int) rec_off + keylen, nodesize);
                         free(node);
                         return 1;
                     }
                     if (sizeof(hfs_btree_index_record) > nodesize - rec_off - keylen) {
                         tsk_error_set_errno(TSK_ERR_FS_GENFS);
                         tsk_error_set_errstr("hfs_cat_traverse: truncated btree index record");
                         free(node);
                         return 1;
                     }
                     idx_rec =
                         (hfs_btree_index_record *) & node[rec_off +
                         keylen];
                     next_node = tsk_getu32(fs->endian, idx_rec->childNode);
                 }
                 if (retval == HFS_BTREE_CB_IDX_EQGT) {
                     // move down to the next node
                     break;
                 }
             }
             // check if we found a relevant node
             if (next_node == 0) {
                 tsk_error_set_errno(TSK_ERR_FS_GENFS);
                 tsk_error_set_errstr
                     ("hfs_cat_traverse: did not find any keys in index node %d",
                     cur_node);
                 is_done = 1;
                 break;
             }
             // TODO: Handle multinode loops
             if (next_node == cur_node) {
                 tsk_error_set_errno(TSK_ERR_FS_GENFS);
                 tsk_error_set_errstr
                     ("hfs_cat_traverse: node %d references itself as next node",
                     cur_node);
                 is_done = 1;
                 break;
             }
             cur_node = next_node;
         }
 
         /* With a leaf, we look for the specific record. */
         else if (node_desc->type == HFS_BT_NODE_TYPE_LEAF) {
             int rec;
 
             for (rec = 0; rec < num_rec; ++rec) {
                 size_t rec_off;
                 hfs_btree_key_cat *key;
                 uint8_t retval;
                 int keylen;
 
                 // Make sure node is large enough, note that (rec + 1) * 2 is an offset
                 // relative to the end of node
                 if ((rec + 1) * 2 > (int) nodesize) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_cat_traverse: offset of record %d in leaf node %d too small (%"
                         PRIu16 ")", rec, cur_node, nodesize);
                     free(node);
                     return 1;
                 }
                 // get the record offset in the node
                 rec_off =
                     tsk_getu16(fs->endian,
                     &node[nodesize - (rec + 1) * 2]);
 
                 // Need at least 2 bytes for key_len
                 if (rec_off >= nodesize - 2) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_cat_traverse: offset of record %d in leaf node %d too large (%d vs %"
                         PRIu16 ")", rec, cur_node, (int) rec_off,
                         nodesize);
                     free(node);
                     return 1;
                 }
 
                 key = (hfs_btree_key_cat *) & node[rec_off];
                 keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);
 
                 // Want a key of at least 6 bytes, the size of the first 2 members of hfs_btree_key_cat
                 if ((keylen < 6) || (keylen > nodesize - rec_off)) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr
                         ("hfs_cat_traverse: length of key %d in leaf node %d out of bounds (6 < %d < %"
                         PRIu16 ")", rec, cur_node, keylen, nodesize);
                     free(node);
                     return 1;
                 }
 
                 /*
                    if (tsk_verbose)
                    tsk_fprintf(stderr,
                    "hfs_cat_traverse: record %" PRIu16
                    "; keylen %" PRIu16 " (%" PRIu32 ")\n", rec,
                    tsk_getu16(fs->endian, key->key_len),
                    tsk_getu32(fs->endian, key->parent_cnid));
                  */
                 //                rec_cnid = tsk_getu32(fs->endian, key->file_id);
 
                 retval =
-                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key,
+                    a_cb(hfs, HFS_BT_NODE_TYPE_LEAF, key, keylen, nodesize,
                     cur_off + rec_off, ptr);
                 if (retval == HFS_BTREE_CB_LEAF_STOP) {
                     is_done = 1;
                     break;
                 }
                 else if (retval == HFS_BTREE_CB_ERR) {
                     tsk_error_set_errno(TSK_ERR_FS_GENFS);
                     tsk_error_set_errstr2
                         ("hfs_cat_traverse: Callback returned error");
                     free(node);
                     return 1;
                 }
             }
 
             // move right to the next node if we got this far
             if (is_done == 0) {
                 cur_node = tsk_getu32(fs->endian, node_desc->flink);
                 if (cur_node == 0) {
                     is_done = 1;
                 }
                 if (tsk_verbose)
                     tsk_fprintf(stderr,
                         "hfs_cat_traverse: moving forward to next leaf");
             }
         }
         else {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             tsk_error_set_errstr("hfs_cat_traverse: btree node %" PRIu32
                 " (%" PRIu64 ") is neither index nor leaf (%" PRIu8 ")",
                 cur_node, cur_off, node_desc->type);
             free(node);
             return 1;
         }
     }
     free(node);
     return 0;
 }
@@ -1058,49 +1064,49 @@ typedef struct {
 
 static uint8_t
 hfs_cat_get_record_offset_cb(HFS_INFO * hfs, int8_t level_type,
-    const hfs_btree_key_cat * cur_key,
+    const hfs_btree_key_cat * cur_key, int cur_keylen, size_t node_size,
     TSK_OFF_T key_off, void *ptr)
 {
     HFS_CAT_GET_RECORD_OFFSET_DATA *offset_data = (HFS_CAT_GET_RECORD_OFFSET_DATA *)ptr;
     const hfs_btree_key_cat *targ_key = offset_data->targ_key;
 
     if (tsk_verbose)
         tsk_fprintf(stderr,
             "hfs_cat_get_record_offset_cb: %s node want: %" PRIu32
             " vs have: %" PRIu32 "\n",
             (level_type == HFS_BT_NODE_TYPE_IDX) ? "Index" : "Leaf",
             tsk_getu32(hfs->fs_info.endian, targ_key->parent_cnid),
             tsk_getu32(hfs->fs_info.endian, cur_key->parent_cnid));
 
     if (level_type == HFS_BT_NODE_TYPE_IDX) {
-        int diff = hfs_cat_compare_keys(hfs, cur_key, targ_key);
+        int diff = hfs_cat_compare_keys(hfs, cur_key, cur_keylen, targ_key);
         if (diff < 0)
             return HFS_BTREE_CB_IDX_LT;
         else
             return HFS_BTREE_CB_IDX_EQGT;
     }
     else {
-        int diff = hfs_cat_compare_keys(hfs, cur_key, targ_key);
+        int diff = hfs_cat_compare_keys(hfs, cur_key, cur_keylen, targ_key);
 
         // see if this record is for our file or if we passed the interesting entries
         if (diff < 0) {
             return HFS_BTREE_CB_LEAF_GO;
         }
         else if (diff == 0) {
             offset_data->off =
                 key_off + 2 + tsk_getu16(hfs->fs_info.endian,
                 cur_key->key_len);
         }
         return HFS_BTREE_CB_LEAF_STOP;
     }
 }
 
 
 /** \internal
  * Find the byte offset (from the start of the catalog file) to a record
  * in the catalog file.
  * @param hfs File System being analyzed
  * @param needle Key to search for
  * @returns Byte offset or 0 on error. 0 is also returned if catalog
  * record was not found. Check tsk_errno to determine if error occurred.
  */
@@ -1653,18 +1659,24 @@ hfs_cat_file_lookup(HFS_INFO * hfs, TSK_INUM_T inum, HFS_ENTRY * entry,
 
 static uint8_t
 hfs_find_highest_inum_cb(HFS_INFO * hfs, int8_t level_type,
-    const hfs_btree_key_cat * cur_key,
+    const hfs_btree_key_cat * cur_key, int cur_keylen, size_t node_size,
     TSK_OFF_T key_off, void *ptr)
 {
+    if (cur_keylen < 6) {
+        // Note that it would be better to return an error value here
+        // but the current function interface does not support this
+        // Also see issue #2365
+        return -1;
+    }
     // NOTE: This assumes that the biggest inum is the last one that we
     // see.  the traverse method does not currently promise that as part of
     // its callback "contract".
     *((TSK_INUM_T*) ptr) = tsk_getu32(hfs->fs_info.endian, cur_key->parent_cnid);
     return HFS_BTREE_CB_IDX_LT;
 }
 
 /** \internal
 * Returns the largest inode number in file system
 * @param hfs File system being analyzed
 * @returns largest metadata address
 */
diff --git a/tsk/fs/hfs_dent.c b/tsk/fs/hfs_dent.c
index e4cebf8a4..54460f14b 100644
--- a/tsk/fs/hfs_dent.c
+++ b/tsk/fs/hfs_dent.c
@@ -198,174 +198,191 @@ typedef struct {
 
 static uint8_t
 hfs_dir_open_meta_cb(HFS_INFO * hfs, int8_t level_type,
-    const hfs_btree_key_cat * cur_key,
+    const hfs_btree_key_cat * cur_key, int cur_keylen, size_t nodesize,
     TSK_OFF_T key_off, void *ptr)
 {
     HFS_DIR_OPEN_META_INFO *info = (HFS_DIR_OPEN_META_INFO *) ptr;
     TSK_FS_INFO *fs = &hfs->fs_info;
 
     if (tsk_verbose)
         fprintf(stderr,
             "hfs_dir_open_meta_cb: want %" PRIu32 " vs got %" PRIu32
             " (%s node)\n", info->cnid, tsk_getu32(hfs->fs_info.endian,
                 cur_key->parent_cnid),
             (level_type == HFS_BT_NODE_TYPE_IDX) ? "Index" : "Leaf");
 
     if (level_type == HFS_BT_NODE_TYPE_IDX) {
         if (tsk_getu32(hfs->fs_info.endian,
                 cur_key->parent_cnid) < info->cnid) {
             return HFS_BTREE_CB_IDX_LT;
         }
         else {
             return HFS_BTREE_CB_IDX_EQGT;
         }
     }
     else {
         uint8_t *rec_buf = (uint8_t *) cur_key;
         uint16_t rec_type;
         size_t rec_off2;
 
         if (tsk_getu32(hfs->fs_info.endian,
                 cur_key->parent_cnid) < info->cnid) {
             return HFS_BTREE_CB_LEAF_GO;
         }
         else if (tsk_getu32(hfs->fs_info.endian,
                 cur_key->parent_cnid) > info->cnid) {
             return HFS_BTREE_CB_LEAF_STOP;
         }
+	// Need at least 2 bytes for key_len
+        if (cur_keylen < 2) {
+            tsk_error_set_errno(TSK_ERR_FS_GENFS);
+            tsk_error_set_errstr("hfs_dir_open_meta: cur_keylen value out of bounds");
+            return HFS_BTREE_CB_ERR;
+        }
         rec_off2 = 2 + tsk_getu16(hfs->fs_info.endian, cur_key->key_len);
+
+        if ((nodesize < 2) || (rec_off2 >= nodesize - 2)) {
+            tsk_error_set_errno(TSK_ERR_FS_GENFS);
+            tsk_error_set_errstr("hfs_dir_open_meta: nodesize value out of bounds");
+            return HFS_BTREE_CB_ERR;
+        }
         rec_type = tsk_getu16(hfs->fs_info.endian, &rec_buf[rec_off2]);
 
         // Catalog entry is for a file
         if (rec_type == HFS_FILE_THREAD) {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             tsk_error_set_errstr("hfs_dir_open_meta: Entry"
                 " is a file, not a folder");
             return HFS_BTREE_CB_ERR;
         }
 
         /* This will link the folder to its parent, which is the ".." entry */
         else if (rec_type == HFS_FOLDER_THREAD) {
             hfs_thread *thread = (hfs_thread *) & rec_buf[rec_off2];
             strcpy(info->fs_name->name, "..");
             info->fs_name->meta_addr =
                 tsk_getu32(hfs->fs_info.endian, thread->parent_cnid);
             info->fs_name->type = TSK_FS_NAME_TYPE_DIR;
             info->fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;
         }
 
         /* This is a folder in the folder */
         else if (rec_type == HFS_FOLDER_RECORD) {
             hfs_folder *folder = (hfs_folder *) & rec_buf[rec_off2];
 
             info->fs_name->meta_addr =
                 tsk_getu32(hfs->fs_info.endian, folder->std.cnid);
             info->fs_name->type = TSK_FS_NAME_TYPE_DIR;
             info->fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;
 
             // Make sure there is enough space in cur_key for the name 
             // (name is unicode so each characters is two bytes; 6 bytes
             // of non-name characters)
             const int32_t nameLength =
                 tsk_getu16(hfs->fs_info.endian, cur_key->name.length);
 
             if (2*nameLength > tsk_getu16(hfs->fs_info.endian, cur_key->key_len) - 6) {
                 error_returned
                 ("hfs_dir_open_meta_cb: name length is too long");
                 return HFS_BTREE_CB_ERR;
             }
             if (hfs_UTF16toUTF8(fs, (uint8_t *) cur_key->name.unicode,
                     nameLength, info->fs_name->name, HFS_MAXNAMLEN + 1,
                     HFS_U16U8_FLAG_REPLACE_SLASH)) {
                 return HFS_BTREE_CB_ERR;
             }
         }
 
         /* This is a normal file in the folder */
         else if (rec_type == HFS_FILE_RECORD) {
+            if ((nodesize < sizeof(hfs_file)) || (rec_off2 >= nodesize - sizeof(hfs_file))) {
+                tsk_error_set_errno(TSK_ERR_FS_GENFS);
+                tsk_error_set_errstr("hfs_dir_open_meta: nodesize value out of bounds");
+                return HFS_BTREE_CB_ERR;
+            }
             hfs_file *file = (hfs_file *) & rec_buf[rec_off2];
             // This could be a hard link.  We need to test this CNID, and follow it if necessary.
             unsigned char is_err;
             TSK_INUM_T file_cnid =
                 tsk_getu32(hfs->fs_info.endian, file->std.cnid);
             TSK_INUM_T target_cnid =
                 hfs_follow_hard_link(hfs, file, &is_err);
             if (is_err > 1) {
                 error_returned
                     ("hfs_dir_open_meta_cb: trying to follow a possible hard link in the directory");
                 return HFS_BTREE_CB_ERR;
             }
             if (target_cnid != file_cnid) {
                 HFS_ENTRY entry;
                 uint8_t lkup;   // lookup result
 
                 // This is a hard link.  We need to fill in the name->type and name->meta_addr from the target
                 info->fs_name->meta_addr = target_cnid;
                 // get the Catalog entry for the target CNID
 
                 lkup = hfs_cat_file_lookup(hfs, target_cnid, &entry,
                     FALSE);
                 if (lkup != 0) {
                     error_returned
                         ("hfs_dir_open_meta_cb: retrieving the catalog entry for the target of a hard link");
                     return HFS_BTREE_CB_ERR;
                 }
                 info->fs_name->type =
                     hfsmode2tsknametype(tsk_getu16(hfs->fs_info.endian,
                         entry.cat.std.perm.mode));
             }
             else {
                 // This is NOT a hard link.
                 info->fs_name->meta_addr =
                     tsk_getu32(hfs->fs_info.endian, file->std.cnid);
                 info->fs_name->type =
                     hfsmode2tsknametype(tsk_getu16(hfs->fs_info.endian,
                         file->std.perm.mode));
             }
             info->fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;
 
             // Make sure there is enough space in cur_key for the name 
             // (name is unicode so each characters is two bytes; 6 bytes
             // of non-name characters)
             const int32_t nameLength =
                 tsk_getu16(hfs->fs_info.endian, cur_key->name.length);
             if (2*nameLength > tsk_getu16(hfs->fs_info.endian, cur_key->key_len) - 6) {
                 error_returned
                 ("hfs_dir_open_meta_cb: name length is too long");
                 return HFS_BTREE_CB_ERR;
             }
             if (hfs_UTF16toUTF8(fs, (uint8_t *) cur_key->name.unicode,
                     nameLength, info->fs_name->name, HFS_MAXNAMLEN + 1,
                     HFS_U16U8_FLAG_REPLACE_SLASH)) {
                 return HFS_BTREE_CB_ERR;
             }
         }
         else {
             tsk_error_set_errno(TSK_ERR_FS_GENFS);
             // @@@ MAY NEED TO IMPROVE BELOW MESSAGE
             tsk_error_set_errstr
                 ("hfs_dir_open_meta: Unknown record type %d in leaf node",
                 rec_type);
             return HFS_BTREE_CB_ERR;
         }
 
         if (tsk_fs_dir_add(info->fs_dir, info->fs_name)) {
             return HFS_BTREE_CB_ERR;
         }
         return HFS_BTREE_CB_LEAF_GO;
     }
 }
 
 /** \internal
 * Process a directory and load up FS_DIR with the entries. If a pointer to
 * an already allocated FS_DIR structure is given, it will be cleared.  If no existing
 * FS_DIR structure is passed (i.e. NULL), then a new one will be created. If the return
 * value is error or corruption, then the FS_DIR structure could
 * have entries (depending on when the error occurred).
 *
 * @param a_fs File system to analyze
 * @param a_fs_dir Pointer to FS_DIR pointer. Can contain an already allocated
 * structure or a new structure.
 * @param a_addr Address of directory to process.
 * @returns error, corruption, ok etc.
 */
diff --git a/tsk/fs/hfs_unicompare.c b/tsk/fs/hfs_unicompare.c
index 752486af0..91d528b88 100644
--- a/tsk/fs/hfs_unicompare.c
+++ b/tsk/fs/hfs_unicompare.c
@@ -109,55 +109,68 @@
 #include "tsk_hfs.h"
 
 static int hfs_unicode_compare_int(uint16_t endian,
-    const hfs_uni_str * uni1, const hfs_uni_str * uni2);
+    const hfs_uni_str * uni1, int uni1_len, const hfs_uni_str * uni2);
 
 
 /**
  * This function compares two unicode strings (as hfs_uni_str) as either case-sensitive
  * or case-insensitive, based on the case-sensitivity of the file system.  The file
  * system is supplied as a parameter.  We need this to compare file names that appear in
  * the catalog file (b-tree) keys.
  *
  * I (Matt S.) think that this is wrong.  The two bytes unicode characters should always be
  * treated as big endian (TSK_BIG_ENDIAN) because they are documented to be "in canonical
  * order".
  */
 int
 hfs_unicode_compare(HFS_INFO * hfs, const hfs_uni_str * uni1,
-    const hfs_uni_str * uni2)
+    int uni1_len, const hfs_uni_str * uni2)
 {
     if (hfs->is_case_sensitive) {
         uint16_t l1, l2;
         const uint8_t *s1, *s2;
         uint16_t c1, c2;
 
+        if (uni1_len < 2) {
+            // Note that it would be better to return an error value here
+            // but the current function interface does not support this
+            // Also see issue #2365
+            return -1;
+        }
         l1 = tsk_getu16(hfs->fs_info.endian, uni1->length);
         l2 = tsk_getu16(hfs->fs_info.endian, uni2->length);
         s1 = uni1->unicode;
         s2 = uni2->unicode;
 
+        // Note that l1 contains number of UTF-16 "characters" and uni1_len number of bytes.
+        if (l1 > (uni1_len - 2) / 2) {
+            // Note that it would be better to return an error value here
+            // but the current function interface does not support this
+            // Also see issue #2365
+            return -1;
+        }
         while (1) {
             if ((l1 == 0) && (l2 == 0))
                 return 0;
             if (l1 == 0)
                 return -1;
             if (l2 == 0)
                 return 1;
             c1 = tsk_getu16(hfs->fs_info.endian, s1);
             c2 = tsk_getu16(hfs->fs_info.endian, s2);
             if (c1 < c2)
                 return -1;
             if (c1 > c2)
                 return 1;
             s1 += 2;
             s2 += 2;
             --l1;
             --l2;
         }
         return 0;
     }
     else
-        return hfs_unicode_compare_int(hfs->fs_info.endian, uni1, uni2);
+        return hfs_unicode_compare_int(hfs->fs_info.endian, uni1, uni1_len, uni2);
 }
 
 extern uint16_t gLowerCaseTable[];
@@ -169,56 +182,73 @@ extern uint16_t gLowerCaseTable[];
  */
 static int
 hfs_unicode_compare_int(uint16_t endian, const hfs_uni_str * uni1,
-    const hfs_uni_str * uni2)
+    int uni1_len, const hfs_uni_str * uni2)
 {
     uint16_t c1, c2;
     uint16_t temp;
     uint16_t *lowerCaseTable;
-
-    const uint8_t *str1 = uni1->unicode;
-    const uint8_t *str2 = uni2->unicode;
-    uint16_t length1 = tsk_getu16(endian, uni1->length);
-    uint16_t length2 = tsk_getu16(endian, uni2->length);
-
+    const uint8_t *str1 = NULL;
+    const uint8_t *str2 = NULL;
+    uint16_t length1 = 0;
+    uint16_t length2 = 0;
+
+    if (uni1_len < 2) {
+        // Note that it would be better to return an error value here
+        // but the current function interface does not support this
+        // Also see issue #2365
+        return -1;
+    }
+    str1 = uni1->unicode;
+    str2 = uni2->unicode;
+    length1 = tsk_getu16(endian, uni1->length);
+    length2 = tsk_getu16(endian, uni2->length);
+
+    // Note that length1 contains number of UTF-16 "characters" and uni1_len number of bytes.
+    if (length1 > (uni1_len - 2) / 2) {
+        // Note that it would be better to return an error value here
+        // but the current function interface does not support this
+        // Also see issue #2365
+        return -1;
+    }
     lowerCaseTable = gLowerCaseTable;
 
     while (1) {
         //  Set default values for c1, c2 in case there are no more valid chars
         c1 = 0;
         c2 = 0;
         //  Find next non-ignorable char from str1, or zero if no more
         while (length1 && c1 == 0) {
             c1 = tsk_getu16(endian, str1);
             str1 += 2;
             --length1;
             if ((temp = lowerCaseTable[c1 >> 8]) != 0)  //  is there a subtable
                 //  for this upper byte?
                 c1 = lowerCaseTable[temp + (c1 & 0x00FF)];      //  yes, so fold the char
         }
         //  Find next non-ignorable char from str2, or zero if no more
         while (length2 && c2 == 0) {
             c2 = tsk_getu16(endian, str2);
             str2 += 2;
             --length2;
             if ((temp = lowerCaseTable[c2 >> 8]) != 0)  //  is there a subtable
                 //  for this upper byte?
                 c2 = lowerCaseTable[temp + (c2 & 0x00FF)];      //  yes, so fold the char
         }
         if (c1 != c2)           //  found a difference, so stop looping
             break;
         if (c1 == 0)            //  did we reach the end of both strings at the same time?
             return 0;           //  yes, so strings are equal
     }
     if (c1 < c2)
         return -1;
     else
         return 1;
 }
 
 
 /*  The lower case table consists of a 256-entry high-byte table followed by
     some number of 256-entry subtables. The high-byte table contains either an
     offset to the subtable for characters with that high byte or zero, which
     means that there are no case mappings or ignored characters in that block.
     Ignored characters are mapped to zero.
  */
diff --git a/tsk/fs/tsk_hfs.h b/tsk/fs/tsk_hfs.h
index 7becb2ab3..2530e0cfe 100644
--- a/tsk/fs/tsk_hfs.h
+++ b/tsk/fs/tsk_hfs.h
@@ -734,7 +734,7 @@ extern uint8_t hfs_UTF16toUTF8(TSK_FS_INFO *, uint8_t *, int, char *, int,
     uint32_t);
 
 extern int hfs_unicode_compare(HFS_INFO *, const hfs_uni_str *,
-    const hfs_uni_str *);
+    int, const hfs_uni_str *);
 extern uint16_t hfs_get_idxkeylen(HFS_INFO * hfs, uint16_t keylen,
     const hfs_btree_header_record * header);
 
@@ -760,16 +760,16 @@ extern char hfs_is_hard_link(TSK_FS_INFO * fs, TSK_INUM_T inum);
 /**
  * @param hfs
  * @param level_type Type of node the records are from
  * @param cur_key Key currently being analyzed (record data follows it)
  * @param key_off Byte offset in tree that this key is located in
  * @param ptr Pointer to data that was passed into parent
  */
 typedef uint8_t(*TSK_HFS_BTREE_CB) (HFS_INFO *, int8_t level_type,
-    const hfs_btree_key_cat * cur_key,
+    const hfs_btree_key_cat * cur_key, int cur_keylen, size_t node_size,
     TSK_OFF_T key_off, void *ptr);
 // return values for callback
 #define HFS_BTREE_CB_IDX_LT     1       // current key is less than target (keeps looking in node)
 #define HFS_BTREE_CB_IDX_EQGT   2       // current key is equal or greater than target (stops)
 #define HFS_BTREE_CB_LEAF_GO    3       // keep on going to the next key in the leaf node
 #define HFS_BTREE_CB_LEAF_STOP  4       // stop processing keys in the leaf node
 #define HFS_BTREE_CB_ERR        5
