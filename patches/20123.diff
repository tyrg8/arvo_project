commit 3dc281397f42dd26bf77e45c7ba4ebeb1eb9aba8
Author: Antoine Pitrou <antoine@python.org>
Date:   Mon Jan 20 16:25:05 2020 -0600

    ARROW-7623: [C++] Update generated flatbuffers code
    
    Also use scoped enums, which are much nicer.
    
    Closes #6233 from pitrou/ARROW-7623-update-fbs-generated-code and squashes the following commits:
    
    9942d2c96 <Antoine Pitrou> ARROW-7623:  Update generated flatbuffers code
    
    Authored-by: Antoine Pitrou <antoine@python.org>
    Signed-off-by: Wes McKinney <wesm+git@apache.org>

diff --git a/cpp/build-support/update-flatbuffers.sh b/cpp/build-support/update-flatbuffers.sh
index 9dfd65efa..799ea2d29 100755
--- a/cpp/build-support/update-flatbuffers.sh
+++ b/cpp/build-support/update-flatbuffers.sh
@@ -25,9 +25,10 @@ SOURCE_DIR=$CWD/../src
 FORMAT_DIR=$CWD/../../format
 
 flatc -c -o $SOURCE_DIR/generated \
+      --scoped-enums \
       $FORMAT_DIR/Message.fbs \
       $FORMAT_DIR/File.fbs \
       $FORMAT_DIR/Schema.fbs \
       $FORMAT_DIR/Tensor.fbs \
       $FORMAT_DIR/SparseTensor.fbs \
       src/arrow/ipc/feather.fbs
diff --git a/cpp/src/arrow/ipc/feather.cc b/cpp/src/arrow/ipc/feather.cc
index 4a1319f92..1d7ec19f9 100644
--- a/cpp/src/arrow/ipc/feather.cc
+++ b/cpp/src/arrow/ipc/feather.cc
@@ -274,250 +274,250 @@ std::unique_ptr<ColumnBuilder> TableBuilder::AddColumn(const std::string& name)
 class TableReader::TableReaderImpl {
  public:
   TableReaderImpl() {}
 
   Status Open(const std::shared_ptr<io::RandomAccessFile>& source) {
     source_ = source;
 
     int magic_size = static_cast<int>(strlen(kFeatherMagicBytes));
     int footer_size = magic_size + static_cast<int>(sizeof(uint32_t));
 
     // Pathological issue where the file is smaller than
     ARROW_ASSIGN_OR_RAISE(int64_t size, source->GetSize());
     if (size < magic_size + footer_size) {
       return Status::Invalid("File is too small to be a well-formed file");
     }
 
     ARROW_ASSIGN_OR_RAISE(auto buffer, source->ReadAt(0, magic_size));
 
     if (memcmp(buffer->data(), kFeatherMagicBytes, magic_size)) {
       return Status::Invalid("Not a feather file");
     }
 
     // Now get the footer and verify
     ARROW_ASSIGN_OR_RAISE(buffer, source->ReadAt(size - footer_size, footer_size));
 
     if (memcmp(buffer->data() + sizeof(uint32_t), kFeatherMagicBytes, magic_size)) {
       return Status::Invalid("Feather file footer incomplete");
     }
 
     uint32_t metadata_length = *reinterpret_cast<const uint32_t*>(buffer->data());
     if (size < magic_size + footer_size + metadata_length) {
       return Status::Invalid("File is smaller than indicated metadata size");
     }
     ARROW_ASSIGN_OR_RAISE(
         buffer, source->ReadAt(size - footer_size - metadata_length, metadata_length));
 
     metadata_.reset(new TableMetadata());
     return metadata_->Open(buffer);
   }
 
   Status GetDataType(const fbs::PrimitiveArray* values, fbs::TypeMetadata metadata_type,
                      const void* metadata, std::shared_ptr<DataType>* out,
                      std::shared_ptr<Array>* out_dictionary = nullptr) {
 #define PRIMITIVE_CASE(CAP_TYPE, FACTORY_FUNC) \
-  case fbs::Type_##CAP_TYPE:                   \
+  case fbs::Type::CAP_TYPE:                    \
     *out = FACTORY_FUNC();                     \
     break;
 
     switch (metadata_type) {
-      case fbs::TypeMetadata_CategoryMetadata: {
+      case fbs::TypeMetadata::CategoryMetadata: {
         auto meta = static_cast<const fbs::CategoryMetadata*>(metadata);
 
         std::shared_ptr<DataType> index_type;
-        RETURN_NOT_OK(GetDataType(values, fbs::TypeMetadata_NONE, nullptr, &index_type));
+        RETURN_NOT_OK(GetDataType(values, fbs::TypeMetadata::NONE, nullptr, &index_type));
 
         RETURN_NOT_OK(
-            LoadValues(meta->levels(), fbs::TypeMetadata_NONE, nullptr, out_dictionary));
+            LoadValues(meta->levels(), fbs::TypeMetadata::NONE, nullptr, out_dictionary));
 
         *out = dictionary(index_type, (*out_dictionary)->type(), meta->ordered());
         break;
       }
-      case fbs::TypeMetadata_TimestampMetadata: {
+      case fbs::TypeMetadata::TimestampMetadata: {
         auto meta = static_cast<const fbs::TimestampMetadata*>(metadata);
         TimeUnit::type unit = FromFlatbufferEnum(meta->unit());
         std::string tz;
         // flatbuffer non-null
         if (meta->timezone() != 0) {
           tz = meta->timezone()->str();
         } else {
           tz = "";
         }
         *out = timestamp(unit, tz);
       } break;
-      case fbs::TypeMetadata_DateMetadata:
+      case fbs::TypeMetadata::DateMetadata:
         *out = date32();
         break;
-      case fbs::TypeMetadata_TimeMetadata: {
+      case fbs::TypeMetadata::TimeMetadata: {
         auto meta = static_cast<const fbs::TimeMetadata*>(metadata);
         *out = time32(FromFlatbufferEnum(meta->unit()));
       } break;
       default:
         switch (values->type()) {
           PRIMITIVE_CASE(BOOL, boolean);
           PRIMITIVE_CASE(INT8, int8);
           PRIMITIVE_CASE(INT16, int16);
           PRIMITIVE_CASE(INT32, int32);
           PRIMITIVE_CASE(INT64, int64);
           PRIMITIVE_CASE(UINT8, uint8);
           PRIMITIVE_CASE(UINT16, uint16);
           PRIMITIVE_CASE(UINT32, uint32);
           PRIMITIVE_CASE(UINT64, uint64);
           PRIMITIVE_CASE(FLOAT, float32);
           PRIMITIVE_CASE(DOUBLE, float64);
           PRIMITIVE_CASE(UTF8, utf8);
           PRIMITIVE_CASE(BINARY, binary);
           PRIMITIVE_CASE(LARGE_UTF8, large_utf8);
           PRIMITIVE_CASE(LARGE_BINARY, large_binary);
           default:
             return Status::Invalid("Unrecognized type");
         }
         break;
     }
 
 #undef PRIMITIVE_CASE
 
     return Status::OK();
   }
 
   // Retrieve a primitive array from the data source
   //
   // @returns: a Buffer instance, the precise type will depend on the kind of
   // input data source (which may or may not have memory-map like semantics)
   Status LoadValues(const fbs::PrimitiveArray* meta, fbs::TypeMetadata metadata_type,
                     const void* metadata, std::shared_ptr<Array>* out) {
     std::shared_ptr<DataType> type;
     std::shared_ptr<Array> dictionary;
     RETURN_NOT_OK(GetDataType(meta, metadata_type, metadata, &type, &dictionary));
 
     std::vector<std::shared_ptr<Buffer>> buffers;
 
     // Buffer data from the source (may or may not perform a copy depending on
     // input source)
     ARROW_ASSIGN_OR_RAISE(auto buffer,
                           source_->ReadAt(meta->offset(), meta->total_bytes()));
 
     int64_t offset = 0;
 
     // If there are nulls, the null bitmask is first
     if (meta->null_count() > 0) {
       int64_t null_bitmap_size = GetOutputLength(BitUtil::BytesForBits(meta->length()));
       buffers.push_back(SliceBuffer(buffer, offset, null_bitmap_size));
       offset += null_bitmap_size;
     } else {
       buffers.push_back(nullptr);
     }
 
     if (is_binary_like(type->id())) {
       int64_t offsets_size = GetOutputLength((meta->length() + 1) * sizeof(int32_t));
       buffers.push_back(SliceBuffer(buffer, offset, offsets_size));
       offset += offsets_size;
     } else if (is_large_binary_like(type->id())) {
       int64_t offsets_size = GetOutputLength((meta->length() + 1) * sizeof(int64_t));
       buffers.push_back(SliceBuffer(buffer, offset, offsets_size));
       offset += offsets_size;
     }
 
     buffers.push_back(SliceBuffer(buffer, offset, buffer->size() - offset));
 
     auto arr_data =
         ArrayData::Make(type, meta->length(), std::move(buffers), meta->null_count());
     arr_data->dictionary = dictionary;
     *out = MakeArray(arr_data);
     return Status::OK();
   }
 
   bool HasDescription() const { return metadata_->HasDescription(); }
 
   std::string GetDescription() const { return metadata_->GetDescription(); }
 
   int version() const { return metadata_->version(); }
   int64_t num_rows() const { return metadata_->num_rows(); }
   int64_t num_columns() const { return metadata_->num_columns(); }
 
   std::string GetColumnName(int i) const {
     const fbs::Column* col_meta = metadata_->column(i);
     return col_meta->name()->str();
   }
 
   Status GetColumn(int i, std::shared_ptr<ChunkedArray>* out) {
     const fbs::Column* col_meta = metadata_->column(i);
 
     // auto user_meta = column->user_metadata();
     // if (user_meta->size() > 0) { user_metadata_ = user_meta->str(); }
 
     std::shared_ptr<Array> values;
     RETURN_NOT_OK(LoadValues(col_meta->values(), col_meta->metadata_type(),
                              col_meta->metadata(), &values));
     *out = std::make_shared<ChunkedArray>(values);
     return Status::OK();
   }
 
   Status Read(std::shared_ptr<Table>* out) {
     std::vector<std::shared_ptr<Field>> fields;
     std::vector<std::shared_ptr<ChunkedArray>> columns;
     for (int i = 0; i < num_columns(); ++i) {
       std::shared_ptr<ChunkedArray> column;
       RETURN_NOT_OK(GetColumn(i, &column));
       columns.push_back(column);
       fields.push_back(::arrow::field(GetColumnName(i), column->type()));
     }
     *out = Table::Make(schema(fields), columns);
     return Status::OK();
   }
 
   Status Read(const std::vector<int>& indices, std::shared_ptr<Table>* out) {
     std::vector<std::shared_ptr<Field>> fields;
     std::vector<std::shared_ptr<ChunkedArray>> columns;
     for (int i = 0; i < num_columns(); ++i) {
       bool found = false;
       for (auto j : indices) {
         if (i == j) {
           found = true;
           break;
         }
       }
       if (!found) {
         continue;
       }
       std::shared_ptr<ChunkedArray> column;
       RETURN_NOT_OK(GetColumn(i, &column));
       columns.push_back(column);
       fields.push_back(::arrow::field(GetColumnName(i), column->type()));
     }
     *out = Table::Make(schema(fields), columns);
     return Status::OK();
   }
 
   Status Read(const std::vector<std::string>& names, std::shared_ptr<Table>* out) {
     std::vector<std::shared_ptr<Field>> fields;
     std::vector<std::shared_ptr<ChunkedArray>> columns;
     for (int i = 0; i < num_columns(); ++i) {
       auto name = GetColumnName(i);
       bool found = false;
       for (auto& n : names) {
         if (name == n) {
           found = true;
           break;
         }
       }
       if (!found) {
         continue;
       }
       std::shared_ptr<ChunkedArray> column;
       RETURN_NOT_OK(GetColumn(i, &column));
       columns.push_back(column);
       fields.push_back(::arrow::field(name, column->type()));
     }
     *out = Table::Make(schema(fields), columns);
     return Status::OK();
   }
 
  private:
   std::shared_ptr<io::RandomAccessFile> source_;
   std::unique_ptr<TableMetadata> metadata_;
 
   std::shared_ptr<Schema> schema_;
 };
 
 // ----------------------------------------------------------------------
 // TableReader public API
@@ -565,48 +565,48 @@ Status TableReader::Read(const std::vector<std::string>& names,
 fbs::Type ToFlatbufferType(Type::type type) {
   switch (type) {
     case Type::BOOL:
-      return fbs::Type_BOOL;
+      return fbs::Type::BOOL;
     case Type::INT8:
-      return fbs::Type_INT8;
+      return fbs::Type::INT8;
     case Type::INT16:
-      return fbs::Type_INT16;
+      return fbs::Type::INT16;
     case Type::INT32:
-      return fbs::Type_INT32;
+      return fbs::Type::INT32;
     case Type::INT64:
-      return fbs::Type_INT64;
+      return fbs::Type::INT64;
     case Type::UINT8:
-      return fbs::Type_UINT8;
+      return fbs::Type::UINT8;
     case Type::UINT16:
-      return fbs::Type_UINT16;
+      return fbs::Type::UINT16;
     case Type::UINT32:
-      return fbs::Type_UINT32;
+      return fbs::Type::UINT32;
     case Type::UINT64:
-      return fbs::Type_UINT64;
+      return fbs::Type::UINT64;
     case Type::FLOAT:
-      return fbs::Type_FLOAT;
+      return fbs::Type::FLOAT;
     case Type::DOUBLE:
-      return fbs::Type_DOUBLE;
+      return fbs::Type::DOUBLE;
     case Type::STRING:
-      return fbs::Type_UTF8;
+      return fbs::Type::UTF8;
     case Type::BINARY:
-      return fbs::Type_BINARY;
+      return fbs::Type::BINARY;
     case Type::LARGE_STRING:
-      return fbs::Type_LARGE_UTF8;
+      return fbs::Type::LARGE_UTF8;
     case Type::LARGE_BINARY:
-      return fbs::Type_LARGE_BINARY;
+      return fbs::Type::LARGE_BINARY;
     case Type::DATE32:
-      return fbs::Type_INT32;
+      return fbs::Type::INT32;
     case Type::TIMESTAMP:
-      return fbs::Type_INT64;
+      return fbs::Type::INT64;
     case Type::TIME32:
-      return fbs::Type_INT32;
+      return fbs::Type::INT32;
     case Type::TIME64:
-      return fbs::Type_INT64;
+      return fbs::Type::INT64;
     default:
       DCHECK(false) << "Cannot reach this code";
   }
   // prevent compiler warning
-  return fbs::Type_MIN;
+  return fbs::Type::MIN;
 }
 
 static Status SanitizeUnsupportedTypes(const Array& values, std::shared_ptr<Array>* out) {
diff --git a/cpp/src/arrow/ipc/feather_internal.h b/cpp/src/arrow/ipc/feather_internal.h
index 53f84d7a9..1502874ea 100644
--- a/cpp/src/arrow/ipc/feather_internal.h
+++ b/cpp/src/arrow/ipc/feather_internal.h
@@ -156,7 +156,7 @@ class ARROW_EXPORT TableMetadata {
 
 static inline flatbuffers::Offset<fbs::PrimitiveArray> GetPrimitiveArray(
     FBB& fbb, const ArrayMetadata& array) {
-  return fbs::CreatePrimitiveArray(fbb, array.type, fbs::Encoding_PLAIN, array.offset,
+  return fbs::CreatePrimitiveArray(fbb, array.type, fbs::Encoding::PLAIN, array.offset,
                                    array.length, array.null_count, array.total_bytes);
 }
 
@@ -171,11 +171,11 @@ static inline TimeUnit::type FromFlatbufferEnum(fbs::TimeUnit unit) {
 // Convert Feather enums to Flatbuffer enums
 
 const fbs::TypeMetadata COLUMN_TYPE_ENUM_MAPPING[] = {
-    fbs::TypeMetadata_NONE,               // PRIMITIVE
-    fbs::TypeMetadata_CategoryMetadata,   // CATEGORY
-    fbs::TypeMetadata_TimestampMetadata,  // TIMESTAMP
-    fbs::TypeMetadata_DateMetadata,       // DATE
-    fbs::TypeMetadata_TimeMetadata        // TIME
+    fbs::TypeMetadata::NONE,               // PRIMITIVE
+    fbs::TypeMetadata::CategoryMetadata,   // CATEGORY
+    fbs::TypeMetadata::TimestampMetadata,  // TIMESTAMP
+    fbs::TypeMetadata::DateMetadata,       // DATE
+    fbs::TypeMetadata::TimeMetadata        // TIME
 };
 
 static inline fbs::TypeMetadata ToFlatbufferEnum(ColumnType::type column_type) {
diff --git a/cpp/src/arrow/ipc/feather_test.cc b/cpp/src/arrow/ipc/feather_test.cc
index e9ad7fba3..74b94a101 100644
--- a/cpp/src/arrow/ipc/feather_test.cc
+++ b/cpp/src/arrow/ipc/feather_test.cc
@@ -103,157 +103,157 @@ void AssertArrayEquals(const ArrayMetadata& left, const ArrayMetadata& right) {
 TEST_F(TestTableBuilder, AddPrimitiveColumn) {
   std::unique_ptr<ColumnBuilder> cb = tb_->AddColumn("f0");
 
   ArrayMetadata values1;
   ArrayMetadata values2;
-  values1.type = fbs::Type_INT32;
+  values1.type = fbs::Type::INT32;
   values1.offset = 10000;
   values1.length = 1000;
   values1.null_count = 100;
   values1.total_bytes = 4000;
 
   cb->SetValues(values1);
 
   std::string user_meta = "as you wish";
   cb->SetUserMetadata(user_meta);
 
   ASSERT_OK(cb->Finish());
 
   cb = tb_->AddColumn("f1");
 
-  values2.type = fbs::Type_UTF8;
+  values2.type = fbs::Type::UTF8;
   values2.offset = 14000;
   values2.length = 1000;
   values2.null_count = 100;
   values2.total_bytes = 10000;
 
   cb->SetValues(values2);
   ASSERT_OK(cb->Finish());
 
   Finish();
 
   ASSERT_EQ(2, table_->num_columns());
 
   auto col = table_->column(0);
 
   ASSERT_EQ("f0", col->name()->str());
   ASSERT_EQ(user_meta, col->user_metadata()->str());
 
   ArrayMetadata values3;
   FromFlatbuffer(col->values(), &values3);
   AssertArrayEquals(values3, values1);
 
   col = table_->column(1);
   ASSERT_EQ("f1", col->name()->str());
 
   ArrayMetadata values4;
   FromFlatbuffer(col->values(), &values4);
   AssertArrayEquals(values4, values2);
 }
 
 TEST_F(TestTableBuilder, AddCategoryColumn) {
-  ArrayMetadata values1(fbs::Type_UINT8, 10000, 1000, 100, 4000);
-  ArrayMetadata levels(fbs::Type_UTF8, 14000, 10, 0, 300);
+  ArrayMetadata values1(fbs::Type::UINT8, 10000, 1000, 100, 4000);
+  ArrayMetadata levels(fbs::Type::UTF8, 14000, 10, 0, 300);
 
   std::unique_ptr<ColumnBuilder> cb = tb_->AddColumn("c0");
   cb->SetValues(values1);
   cb->SetCategory(levels);
   ASSERT_OK(cb->Finish());
 
   cb = tb_->AddColumn("c1");
   cb->SetValues(values1);
   cb->SetCategory(levels, true);
   ASSERT_OK(cb->Finish());
 
   Finish();
 
   auto col = table_->column(0);
-  ASSERT_EQ(fbs::TypeMetadata_CategoryMetadata, col->metadata_type());
+  ASSERT_EQ(fbs::TypeMetadata::CategoryMetadata, col->metadata_type());
 
   ArrayMetadata result;
   FromFlatbuffer(col->values(), &result);
   AssertArrayEquals(result, values1);
 
   auto cat_ptr = static_cast<const fbs::CategoryMetadata*>(col->metadata());
   ASSERT_FALSE(cat_ptr->ordered());
 
   FromFlatbuffer(cat_ptr->levels(), &result);
   AssertArrayEquals(result, levels);
 
   col = table_->column(1);
   cat_ptr = static_cast<const fbs::CategoryMetadata*>(col->metadata());
   ASSERT_TRUE(cat_ptr->ordered());
   FromFlatbuffer(cat_ptr->levels(), &result);
   AssertArrayEquals(result, levels);
 }
 
 TEST_F(TestTableBuilder, AddTimestampColumn) {
-  ArrayMetadata values1(fbs::Type_INT64, 10000, 1000, 100, 4000);
+  ArrayMetadata values1(fbs::Type::INT64, 10000, 1000, 100, 4000);
   std::unique_ptr<ColumnBuilder> cb = tb_->AddColumn("c0");
   cb->SetValues(values1);
   cb->SetTimestamp(TimeUnit::MILLI);
   ASSERT_OK(cb->Finish());
 
   cb = tb_->AddColumn("c1");
 
   std::string tz("America/Los_Angeles");
 
   cb->SetValues(values1);
   cb->SetTimestamp(TimeUnit::SECOND, tz);
   ASSERT_OK(cb->Finish());
 
   Finish();
 
   auto col = table_->column(0);
 
-  ASSERT_EQ(fbs::TypeMetadata_TimestampMetadata, col->metadata_type());
+  ASSERT_EQ(fbs::TypeMetadata::TimestampMetadata, col->metadata_type());
 
   ArrayMetadata result;
   FromFlatbuffer(col->values(), &result);
   AssertArrayEquals(result, values1);
 
   auto ts_ptr = static_cast<const fbs::TimestampMetadata*>(col->metadata());
-  ASSERT_EQ(fbs::TimeUnit_MILLISECOND, ts_ptr->unit());
+  ASSERT_EQ(fbs::TimeUnit::MILLISECOND, ts_ptr->unit());
 
   col = table_->column(1);
   ts_ptr = static_cast<const fbs::TimestampMetadata*>(col->metadata());
-  ASSERT_EQ(fbs::TimeUnit_SECOND, ts_ptr->unit());
+  ASSERT_EQ(fbs::TimeUnit::SECOND, ts_ptr->unit());
   ASSERT_EQ(tz, ts_ptr->timezone()->str());
 }
 
 TEST_F(TestTableBuilder, AddDateColumn) {
-  ArrayMetadata values1(fbs::Type_INT64, 10000, 1000, 100, 4000);
+  ArrayMetadata values1(fbs::Type::INT64, 10000, 1000, 100, 4000);
   std::unique_ptr<ColumnBuilder> cb = tb_->AddColumn("d0");
   cb->SetValues(values1);
   cb->SetDate();
   ASSERT_OK(cb->Finish());
 
   Finish();
 
   auto col = table_->column(0);
 
-  ASSERT_EQ(fbs::TypeMetadata_DateMetadata, col->metadata_type());
+  ASSERT_EQ(fbs::TypeMetadata::DateMetadata, col->metadata_type());
   ArrayMetadata result;
   FromFlatbuffer(col->values(), &result);
   AssertArrayEquals(result, values1);
 }
 
 TEST_F(TestTableBuilder, AddTimeColumn) {
-  ArrayMetadata values1(fbs::Type_INT64, 10000, 1000, 100, 4000);
+  ArrayMetadata values1(fbs::Type::INT64, 10000, 1000, 100, 4000);
   std::unique_ptr<ColumnBuilder> cb = tb_->AddColumn("c0");
   cb->SetValues(values1);
   cb->SetTime(TimeUnit::SECOND);
   ASSERT_OK(cb->Finish());
   Finish();
 
   auto col = table_->column(0);
 
-  ASSERT_EQ(fbs::TypeMetadata_TimeMetadata, col->metadata_type());
+  ASSERT_EQ(fbs::TypeMetadata::TimeMetadata, col->metadata_type());
   ArrayMetadata result;
   FromFlatbuffer(col->values(), &result);
   AssertArrayEquals(result, values1);
 
   auto t_ptr = static_cast<const fbs::TimeMetadata*>(col->metadata());
-  ASSERT_EQ(fbs::TimeUnit_SECOND, t_ptr->unit());
+  ASSERT_EQ(fbs::TimeUnit::SECOND, t_ptr->unit());
 }
 
 void CheckArrays(const Array& expected, const Array& result) {
diff --git a/cpp/src/arrow/ipc/message.cc b/cpp/src/arrow/ipc/message.cc
index 9ce2a2225..dd2f61ffd 100644
--- a/cpp/src/arrow/ipc/message.cc
+++ b/cpp/src/arrow/ipc/message.cc
@@ -41,55 +41,55 @@ namespace ipc {
 class Message::MessageImpl {
  public:
   explicit MessageImpl(const std::shared_ptr<Buffer>& metadata,
                        const std::shared_ptr<Buffer>& body)
       : metadata_(metadata), message_(nullptr), body_(body) {}
 
   Status Open() {
     RETURN_NOT_OK(
         internal::VerifyMessage(metadata_->data(), metadata_->size(), &message_));
 
     // Check that the metadata version is supported
     if (message_->version() < internal::kMinMetadataVersion) {
       return Status::Invalid("Old metadata version not supported");
     }
 
     return Status::OK();
   }
 
   Message::Type type() const {
     switch (message_->header_type()) {
-      case flatbuf::MessageHeader_Schema:
+      case flatbuf::MessageHeader::Schema:
         return Message::SCHEMA;
-      case flatbuf::MessageHeader_DictionaryBatch:
+      case flatbuf::MessageHeader::DictionaryBatch:
         return Message::DICTIONARY_BATCH;
-      case flatbuf::MessageHeader_RecordBatch:
+      case flatbuf::MessageHeader::RecordBatch:
         return Message::RECORD_BATCH;
-      case flatbuf::MessageHeader_Tensor:
+      case flatbuf::MessageHeader::Tensor:
         return Message::TENSOR;
-      case flatbuf::MessageHeader_SparseTensor:
+      case flatbuf::MessageHeader::SparseTensor:
         return Message::SPARSE_TENSOR;
       default:
         return Message::NONE;
     }
   }
 
   MetadataVersion version() const {
     return internal::GetMetadataVersion(message_->version());
   }
 
   const void* header() const { return message_->header(); }
 
   int64_t body_length() const { return message_->bodyLength(); }
 
   std::shared_ptr<Buffer> body() const { return body_; }
 
   std::shared_ptr<Buffer> metadata() const { return metadata_; }
 
  private:
   // The Flatbuffer metadata
   std::shared_ptr<Buffer> metadata_;
   const flatbuf::Message* message_;
 
   // The message body, if any
   std::shared_ptr<Buffer> body_;
 };
diff --git a/cpp/src/arrow/ipc/metadata_internal.cc b/cpp/src/arrow/ipc/metadata_internal.cc
index 8eb197e19..246c179c2 100644
--- a/cpp/src/arrow/ipc/metadata_internal.cc
+++ b/cpp/src/arrow/ipc/metadata_internal.cc
@@ -65,20 +65,20 @@ using KVVector = flatbuffers::Vector<KeyValueOffset>;
 
 MetadataVersion GetMetadataVersion(flatbuf::MetadataVersion version) {
   switch (version) {
-    case flatbuf::MetadataVersion_V1:
+    case flatbuf::MetadataVersion::V1:
       // Arrow 0.1
       return MetadataVersion::V1;
-    case flatbuf::MetadataVersion_V2:
+    case flatbuf::MetadataVersion::V2:
       // Arrow 0.2
       return MetadataVersion::V2;
-    case flatbuf::MetadataVersion_V3:
+    case flatbuf::MetadataVersion::V3:
       // Arrow 0.3 to 0.7.1
       return MetadataVersion::V4;
-    case flatbuf::MetadataVersion_V4:
+    case flatbuf::MetadataVersion::V4:
       // Arrow >= 0.8
       return MetadataVersion::V4;
     // Add cases as other versions become available
     default:
       return MetadataVersion::V4;
   }
 }
@@ -114,14 +114,14 @@ Status IntFromFlatbuffer(const flatbuf::Int* int_data, std::shared_ptr<DataType>
 
 Status FloatFromFlatbuffer(const flatbuf::FloatingPoint* float_data,
                            std::shared_ptr<DataType>* out) {
-  if (float_data->precision() == flatbuf::Precision_HALF) {
+  if (float_data->precision() == flatbuf::Precision::HALF) {
     *out = float16();
-  } else if (float_data->precision() == flatbuf::Precision_SINGLE) {
+  } else if (float_data->precision() == flatbuf::Precision::SINGLE) {
     *out = float32();
   } else {
     *out = float64();
   }
   return Status::OK();
 }
 
 // Forward declaration
@@ -153,64 +153,64 @@ Status AppendChildFields(FBB& fbb, const DataType& type,
 Status UnionFromFlatbuffer(const flatbuf::Union* union_data,
                            const std::vector<std::shared_ptr<Field>>& children,
                            std::shared_ptr<DataType>* out) {
   UnionMode::type mode =
-      (union_data->mode() == flatbuf::UnionMode_Sparse ? UnionMode::SPARSE
-                                                       : UnionMode::DENSE);
+      (union_data->mode() == flatbuf::UnionMode::Sparse ? UnionMode::SPARSE
+                                                        : UnionMode::DENSE);
 
   std::vector<int8_t> type_codes;
 
   const flatbuffers::Vector<int32_t>* fb_type_ids = union_data->typeIds();
   if (fb_type_ids == nullptr) {
     for (int8_t i = 0; i < static_cast<int8_t>(children.size()); ++i) {
       type_codes.push_back(i);
     }
   } else {
     for (int32_t id : (*fb_type_ids)) {
       const auto type_code = static_cast<int8_t>(id);
       if (id != type_code) {
         return Status::Invalid("union type id out of bounds");
       }
       type_codes.push_back(type_code);
     }
   }
 
   return UnionType::Make(children, type_codes, mode).Value(out);
 }
 
 #define INT_TO_FB_CASE(BIT_WIDTH, IS_SIGNED)            \
-  *out_type = flatbuf::Type_Int;                        \
+  *out_type = flatbuf::Type::Int;                       \
   *offset = IntToFlatbuffer(fbb, BIT_WIDTH, IS_SIGNED); \
   break;
 
 static inline flatbuf::TimeUnit ToFlatbufferUnit(TimeUnit::type unit) {
   switch (unit) {
     case TimeUnit::SECOND:
-      return flatbuf::TimeUnit_SECOND;
+      return flatbuf::TimeUnit::SECOND;
     case TimeUnit::MILLI:
-      return flatbuf::TimeUnit_MILLISECOND;
+      return flatbuf::TimeUnit::MILLISECOND;
     case TimeUnit::MICRO:
-      return flatbuf::TimeUnit_MICROSECOND;
+      return flatbuf::TimeUnit::MICROSECOND;
     case TimeUnit::NANO:
-      return flatbuf::TimeUnit_NANOSECOND;
+      return flatbuf::TimeUnit::NANOSECOND;
     default:
       break;
   }
-  return flatbuf::TimeUnit_MIN;
+  return flatbuf::TimeUnit::MIN;
 }
 
 static inline TimeUnit::type FromFlatbufferUnit(flatbuf::TimeUnit unit) {
   switch (unit) {
-    case flatbuf::TimeUnit_SECOND:
+    case flatbuf::TimeUnit::SECOND:
       return TimeUnit::SECOND;
-    case flatbuf::TimeUnit_MILLISECOND:
+    case flatbuf::TimeUnit::MILLISECOND:
       return TimeUnit::MILLI;
-    case flatbuf::TimeUnit_MICROSECOND:
+    case flatbuf::TimeUnit::MICROSECOND:
       return TimeUnit::MICRO;
-    case flatbuf::TimeUnit_NANOSECOND:
+    case flatbuf::TimeUnit::NANOSECOND:
       return TimeUnit::NANO;
     default:
       break;
   }
   // cannot reach
   return TimeUnit::SECOND;
 }
@@ -218,148 +218,148 @@ static inline TimeUnit::type FromFlatbufferUnit(flatbuf::TimeUnit unit) {
 Status ConcreteTypeFromFlatbuffer(flatbuf::Type type, const void* type_data,
                                   const std::vector<std::shared_ptr<Field>>& children,
                                   std::shared_ptr<DataType>* out) {
   switch (type) {
-    case flatbuf::Type_NONE:
+    case flatbuf::Type::NONE:
       return Status::Invalid("Type metadata cannot be none");
-    case flatbuf::Type_Null:
+    case flatbuf::Type::Null:
       *out = null();
       return Status::OK();
-    case flatbuf::Type_Int:
+    case flatbuf::Type::Int:
       return IntFromFlatbuffer(static_cast<const flatbuf::Int*>(type_data), out);
-    case flatbuf::Type_FloatingPoint:
+    case flatbuf::Type::FloatingPoint:
       return FloatFromFlatbuffer(static_cast<const flatbuf::FloatingPoint*>(type_data),
                                  out);
-    case flatbuf::Type_Binary:
+    case flatbuf::Type::Binary:
       *out = binary();
       return Status::OK();
-    case flatbuf::Type_LargeBinary:
+    case flatbuf::Type::LargeBinary:
       *out = large_binary();
       return Status::OK();
-    case flatbuf::Type_FixedSizeBinary: {
+    case flatbuf::Type::FixedSizeBinary: {
       auto fw_binary = static_cast<const flatbuf::FixedSizeBinary*>(type_data);
       *out = fixed_size_binary(fw_binary->byteWidth());
       return Status::OK();
     }
-    case flatbuf::Type_Utf8:
+    case flatbuf::Type::Utf8:
       *out = utf8();
       return Status::OK();
-    case flatbuf::Type_LargeUtf8:
+    case flatbuf::Type::LargeUtf8:
       *out = large_utf8();
       return Status::OK();
-    case flatbuf::Type_Bool:
+    case flatbuf::Type::Bool:
       *out = boolean();
       return Status::OK();
-    case flatbuf::Type_Decimal: {
+    case flatbuf::Type::Decimal: {
       auto dec_type = static_cast<const flatbuf::Decimal*>(type_data);
       return Decimal128Type::Make(dec_type->precision(), dec_type->scale(), out);
     }
-    case flatbuf::Type_Date: {
+    case flatbuf::Type::Date: {
       auto date_type = static_cast<const flatbuf::Date*>(type_data);
-      if (date_type->unit() == flatbuf::DateUnit_DAY) {
+      if (date_type->unit() == flatbuf::DateUnit::DAY) {
         *out = date32();
       } else {
         *out = date64();
       }
       return Status::OK();
     }
-    case flatbuf::Type_Time: {
+    case flatbuf::Type::Time: {
       auto time_type = static_cast<const flatbuf::Time*>(type_data);
       TimeUnit::type unit = FromFlatbufferUnit(time_type->unit());
       int32_t bit_width = time_type->bitWidth();
       switch (unit) {
         case TimeUnit::SECOND:
         case TimeUnit::MILLI:
           if (bit_width != 32) {
             return Status::Invalid("Time is 32 bits for second/milli unit");
           }
           *out = time32(unit);
           break;
         default:
           if (bit_width != 64) {
             return Status::Invalid("Time is 64 bits for micro/nano unit");
           }
           *out = time64(unit);
           break;
       }
       return Status::OK();
     }
-    case flatbuf::Type_Timestamp: {
+    case flatbuf::Type::Timestamp: {
       auto ts_type = static_cast<const flatbuf::Timestamp*>(type_data);
       TimeUnit::type unit = FromFlatbufferUnit(ts_type->unit());
       if (ts_type->timezone() != 0 && ts_type->timezone()->Length() > 0) {
         *out = timestamp(unit, ts_type->timezone()->str());
       } else {
         *out = timestamp(unit);
       }
       return Status::OK();
     }
-    case flatbuf::Type_Duration: {
+    case flatbuf::Type::Duration: {
       auto duration = static_cast<const flatbuf::Duration*>(type_data);
       TimeUnit::type unit = FromFlatbufferUnit(duration->unit());
       *out = arrow::duration(unit);
       return Status::OK();
     }
 
-    case flatbuf::Type_Interval: {
+    case flatbuf::Type::Interval: {
       auto i_type = static_cast<const flatbuf::Interval*>(type_data);
       switch (i_type->unit()) {
-        case flatbuf::IntervalUnit_YEAR_MONTH: {
+        case flatbuf::IntervalUnit::YEAR_MONTH: {
           *out = month_interval();
           return Status::OK();
         }
-        case flatbuf::IntervalUnit_DAY_TIME: {
+        case flatbuf::IntervalUnit::DAY_TIME: {
           *out = day_time_interval();
           return Status::OK();
         }
       }
       return Status::NotImplemented("Unrecognized interval type.");
     }
 
-    case flatbuf::Type_List:
+    case flatbuf::Type::List:
       if (children.size() != 1) {
         return Status::Invalid("List must have exactly 1 child field");
       }
       *out = std::make_shared<ListType>(children[0]);
       return Status::OK();
-    case flatbuf::Type_LargeList:
+    case flatbuf::Type::LargeList:
       if (children.size() != 1) {
         return Status::Invalid("LargeList must have exactly 1 child field");
       }
       *out = std::make_shared<LargeListType>(children[0]);
       return Status::OK();
-    case flatbuf::Type_Map:
+    case flatbuf::Type::Map:
       if (children.size() != 1) {
         return Status::Invalid("Map must have exactly 1 child field");
       }
       if (children[0]->nullable() || children[0]->type()->id() != Type::STRUCT ||
           children[0]->type()->num_children() != 2) {
         return Status::Invalid("Map's key-item pairs must be non-nullable structs");
       }
       if (children[0]->type()->child(0)->nullable()) {
         return Status::Invalid("Map's keys must be non-nullable");
       } else {
         auto map = static_cast<const flatbuf::Map*>(type_data);
         *out = std::make_shared<MapType>(children[0]->type()->child(0)->type(),
                                          children[0]->type()->child(1)->type(),
                                          map->keysSorted());
       }
       return Status::OK();
-    case flatbuf::Type_FixedSizeList:
+    case flatbuf::Type::FixedSizeList:
       if (children.size() != 1) {
         return Status::Invalid("FixedSizeList must have exactly 1 child field");
       } else {
         auto fs_list = static_cast<const flatbuf::FixedSizeList*>(type_data);
         *out = std::make_shared<FixedSizeListType>(children[0], fs_list->listSize());
       }
       return Status::OK();
-    case flatbuf::Type_Struct_:
+    case flatbuf::Type::Struct_:
       *out = std::make_shared<StructType>(children);
       return Status::OK();
-    case flatbuf::Type_Union:
+    case flatbuf::Type::Union:
       return UnionFromFlatbuffer(static_cast<const flatbuf::Union*>(type_data), children,
                                  out);
     default:
       return Status::Invalid("Unrecognized type:" +
                              std::to_string(static_cast<int>(type)));
   }
 }
@@ -400,37 +400,37 @@ static Status TypeFromFlatbuffer(const flatbuf::Field* field,
 Status TensorTypeToFlatbuffer(FBB& fbb, const DataType& type, flatbuf::Type* out_type,
                               Offset* offset) {
   switch (type.id()) {
     case Type::UINT8:
       INT_TO_FB_CASE(8, false);
     case Type::INT8:
       INT_TO_FB_CASE(8, true);
     case Type::UINT16:
       INT_TO_FB_CASE(16, false);
     case Type::INT16:
       INT_TO_FB_CASE(16, true);
     case Type::UINT32:
       INT_TO_FB_CASE(32, false);
     case Type::INT32:
       INT_TO_FB_CASE(32, true);
     case Type::UINT64:
       INT_TO_FB_CASE(64, false);
     case Type::INT64:
       INT_TO_FB_CASE(64, true);
     case Type::HALF_FLOAT:
-      *out_type = flatbuf::Type_FloatingPoint;
-      *offset = FloatToFlatbuffer(fbb, flatbuf::Precision_HALF);
+      *out_type = flatbuf::Type::FloatingPoint;
+      *offset = FloatToFlatbuffer(fbb, flatbuf::Precision::HALF);
       break;
     case Type::FLOAT:
-      *out_type = flatbuf::Type_FloatingPoint;
-      *offset = FloatToFlatbuffer(fbb, flatbuf::Precision_SINGLE);
+      *out_type = flatbuf::Type::FloatingPoint;
+      *offset = FloatToFlatbuffer(fbb, flatbuf::Precision::SINGLE);
       break;
     case Type::DOUBLE:
-      *out_type = flatbuf::Type_FloatingPoint;
-      *offset = FloatToFlatbuffer(fbb, flatbuf::Precision_DOUBLE);
+      *out_type = flatbuf::Type::FloatingPoint;
+      *offset = FloatToFlatbuffer(fbb, flatbuf::Precision::DOUBLE);
       break;
     default:
-      *out_type = flatbuf::Type_NONE;  // Make clang-tidy happy
+      *out_type = flatbuf::Type::NONE;  // Make clang-tidy happy
       return Status::NotImplemented("Unable to convert type: ", type.ToString());
   }
   return Status::OK();
 }
@@ -493,261 +493,261 @@ Status KeyValueMetadataFromFlatbuffer(const KVVector* fb_metadata,
 class FieldToFlatbufferVisitor {
  public:
   FieldToFlatbufferVisitor(FBB& fbb, DictionaryMemo* dictionary_memo)
       : fbb_(fbb), dictionary_memo_(dictionary_memo) {}
 
   Status VisitType(const DataType& type) { return VisitTypeInline(type, this); }
 
   Status Visit(const NullType& type) {
-    fb_type_ = flatbuf::Type_Null;
+    fb_type_ = flatbuf::Type::Null;
     type_offset_ = flatbuf::CreateNull(fbb_).Union();
     return Status::OK();
   }
 
   Status Visit(const BooleanType& type) {
-    fb_type_ = flatbuf::Type_Bool;
+    fb_type_ = flatbuf::Type::Bool;
     type_offset_ = flatbuf::CreateBool(fbb_).Union();
     return Status::OK();
   }
 
   template <int BitWidth, bool IsSigned, typename T>
   Status Visit(const T& type) {
-    fb_type_ = flatbuf::Type_Int;
+    fb_type_ = flatbuf::Type::Int;
     type_offset_ = IntToFlatbuffer(fbb_, BitWidth, IsSigned);
     return Status::OK();
   }
 
   template <typename T>
   enable_if_integer<T, Status> Visit(const T& type) {
     constexpr bool is_signed = is_signed_integer_type<T>::value;
     return Visit<sizeof(typename T::c_type) * 8, is_signed>(type);
   }
 
   Status Visit(const HalfFloatType& type) {
-    fb_type_ = flatbuf::Type_FloatingPoint;
-    type_offset_ = FloatToFlatbuffer(fbb_, flatbuf::Precision_HALF);
+    fb_type_ = flatbuf::Type::FloatingPoint;
+    type_offset_ = FloatToFlatbuffer(fbb_, flatbuf::Precision::HALF);
     return Status::OK();
   }
 
   Status Visit(const FloatType& type) {
-    fb_type_ = flatbuf::Type_FloatingPoint;
-    type_offset_ = FloatToFlatbuffer(fbb_, flatbuf::Precision_SINGLE);
+    fb_type_ = flatbuf::Type::FloatingPoint;
+    type_offset_ = FloatToFlatbuffer(fbb_, flatbuf::Precision::SINGLE);
     return Status::OK();
   }
 
   Status Visit(const DoubleType& type) {
-    fb_type_ = flatbuf::Type_FloatingPoint;
-    type_offset_ = FloatToFlatbuffer(fbb_, flatbuf::Precision_DOUBLE);
+    fb_type_ = flatbuf::Type::FloatingPoint;
+    type_offset_ = FloatToFlatbuffer(fbb_, flatbuf::Precision::DOUBLE);
     return Status::OK();
   }
 
   Status Visit(const FixedSizeBinaryType& type) {
     const auto& fw_type = checked_cast<const FixedSizeBinaryType&>(type);
-    fb_type_ = flatbuf::Type_FixedSizeBinary;
+    fb_type_ = flatbuf::Type::FixedSizeBinary;
     type_offset_ = flatbuf::CreateFixedSizeBinary(fbb_, fw_type.byte_width()).Union();
     return Status::OK();
   }
 
   Status Visit(const BinaryType& type) {
-    fb_type_ = flatbuf::Type_Binary;
+    fb_type_ = flatbuf::Type::Binary;
     type_offset_ = flatbuf::CreateBinary(fbb_).Union();
     return Status::OK();
   }
 
   Status Visit(const LargeBinaryType& type) {
-    fb_type_ = flatbuf::Type_LargeBinary;
+    fb_type_ = flatbuf::Type::LargeBinary;
     type_offset_ = flatbuf::CreateLargeBinary(fbb_).Union();
     return Status::OK();
   }
 
   Status Visit(const StringType& type) {
-    fb_type_ = flatbuf::Type_Utf8;
+    fb_type_ = flatbuf::Type::Utf8;
     type_offset_ = flatbuf::CreateUtf8(fbb_).Union();
     return Status::OK();
   }
 
   Status Visit(const LargeStringType& type) {
-    fb_type_ = flatbuf::Type_LargeUtf8;
+    fb_type_ = flatbuf::Type::LargeUtf8;
     type_offset_ = flatbuf::CreateLargeUtf8(fbb_).Union();
     return Status::OK();
   }
 
   Status Visit(const Date32Type& type) {
-    fb_type_ = flatbuf::Type_Date;
-    type_offset_ = flatbuf::CreateDate(fbb_, flatbuf::DateUnit_DAY).Union();
+    fb_type_ = flatbuf::Type::Date;
+    type_offset_ = flatbuf::CreateDate(fbb_, flatbuf::DateUnit::DAY).Union();
     return Status::OK();
   }
 
   Status Visit(const Date64Type& type) {
-    fb_type_ = flatbuf::Type_Date;
-    type_offset_ = flatbuf::CreateDate(fbb_, flatbuf::DateUnit_MILLISECOND).Union();
+    fb_type_ = flatbuf::Type::Date;
+    type_offset_ = flatbuf::CreateDate(fbb_, flatbuf::DateUnit::MILLISECOND).Union();
     return Status::OK();
   }
 
   Status Visit(const Time32Type& type) {
     const auto& time_type = checked_cast<const Time32Type&>(type);
-    fb_type_ = flatbuf::Type_Time;
+    fb_type_ = flatbuf::Type::Time;
     type_offset_ =
         flatbuf::CreateTime(fbb_, ToFlatbufferUnit(time_type.unit()), 32).Union();
     return Status::OK();
   }
 
   Status Visit(const Time64Type& type) {
     const auto& time_type = checked_cast<const Time64Type&>(type);
-    fb_type_ = flatbuf::Type_Time;
+    fb_type_ = flatbuf::Type::Time;
     type_offset_ =
         flatbuf::CreateTime(fbb_, ToFlatbufferUnit(time_type.unit()), 64).Union();
     return Status::OK();
   }
 
   Status Visit(const TimestampType& type) {
     const auto& ts_type = checked_cast<const TimestampType&>(type);
-    fb_type_ = flatbuf::Type_Timestamp;
+    fb_type_ = flatbuf::Type::Timestamp;
     flatbuf::TimeUnit fb_unit = ToFlatbufferUnit(ts_type.unit());
     FBString fb_timezone = 0;
     if (ts_type.timezone().size() > 0) {
       fb_timezone = fbb_.CreateString(ts_type.timezone());
     }
     type_offset_ = flatbuf::CreateTimestamp(fbb_, fb_unit, fb_timezone).Union();
     return Status::OK();
   }
 
   Status Visit(const DurationType& type) {
-    fb_type_ = flatbuf::Type_Duration;
+    fb_type_ = flatbuf::Type::Duration;
     flatbuf::TimeUnit fb_unit = ToFlatbufferUnit(type.unit());
     type_offset_ = flatbuf::CreateDuration(fbb_, fb_unit).Union();
     return Status::OK();
   }
 
   Status Visit(const DayTimeIntervalType& type) {
-    fb_type_ = flatbuf::Type_Interval;
-    type_offset_ = flatbuf::CreateInterval(fbb_, flatbuf::IntervalUnit_DAY_TIME).Union();
+    fb_type_ = flatbuf::Type::Interval;
+    type_offset_ = flatbuf::CreateInterval(fbb_, flatbuf::IntervalUnit::DAY_TIME).Union();
     return Status::OK();
   }
 
   Status Visit(const MonthIntervalType& type) {
-    fb_type_ = flatbuf::Type_Interval;
+    fb_type_ = flatbuf::Type::Interval;
     type_offset_ =
-        flatbuf::CreateInterval(fbb_, flatbuf::IntervalUnit_YEAR_MONTH).Union();
+        flatbuf::CreateInterval(fbb_, flatbuf::IntervalUnit::YEAR_MONTH).Union();
     return Status::OK();
   }
 
   Status Visit(const DecimalType& type) {
     const auto& dec_type = checked_cast<const Decimal128Type&>(type);
-    fb_type_ = flatbuf::Type_Decimal;
+    fb_type_ = flatbuf::Type::Decimal;
     type_offset_ =
         flatbuf::CreateDecimal(fbb_, dec_type.precision(), dec_type.scale()).Union();
     return Status::OK();
   }
 
   Status Visit(const ListType& type) {
-    fb_type_ = flatbuf::Type_List;
+    fb_type_ = flatbuf::Type::List;
     RETURN_NOT_OK(AppendChildFields(fbb_, type, &children_, dictionary_memo_));
     type_offset_ = flatbuf::CreateList(fbb_).Union();
     return Status::OK();
   }
 
   Status Visit(const LargeListType& type) {
-    fb_type_ = flatbuf::Type_LargeList;
+    fb_type_ = flatbuf::Type::LargeList;
     RETURN_NOT_OK(AppendChildFields(fbb_, type, &children_, dictionary_memo_));
     type_offset_ = flatbuf::CreateLargeList(fbb_).Union();
     return Status::OK();
   }
 
   Status Visit(const MapType& type) {
-    fb_type_ = flatbuf::Type_Map;
+    fb_type_ = flatbuf::Type::Map;
     RETURN_NOT_OK(AppendChildFields(fbb_, type, &children_, dictionary_memo_));
     type_offset_ = flatbuf::CreateMap(fbb_, type.keys_sorted()).Union();
     return Status::OK();
   }
 
   Status Visit(const FixedSizeListType& type) {
-    fb_type_ = flatbuf::Type_FixedSizeList;
+    fb_type_ = flatbuf::Type::FixedSizeList;
     RETURN_NOT_OK(AppendChildFields(fbb_, type, &children_, dictionary_memo_));
     type_offset_ = flatbuf::CreateFixedSizeList(fbb_, type.list_size()).Union();
     return Status::OK();
   }
 
   Status Visit(const StructType& type) {
-    fb_type_ = flatbuf::Type_Struct_;
+    fb_type_ = flatbuf::Type::Struct_;
     RETURN_NOT_OK(AppendChildFields(fbb_, type, &children_, dictionary_memo_));
     type_offset_ = flatbuf::CreateStruct_(fbb_).Union();
     return Status::OK();
   }
 
   Status Visit(const UnionType& type) {
-    fb_type_ = flatbuf::Type_Union;
+    fb_type_ = flatbuf::Type::Union;
     RETURN_NOT_OK(AppendChildFields(fbb_, type, &children_, dictionary_memo_));
 
     const auto& union_type = checked_cast<const UnionType&>(type);
 
     flatbuf::UnionMode mode = union_type.mode() == UnionMode::SPARSE
-                                  ? flatbuf::UnionMode_Sparse
-                                  : flatbuf::UnionMode_Dense;
+                                  ? flatbuf::UnionMode::Sparse
+                                  : flatbuf::UnionMode::Dense;
 
     std::vector<int32_t> type_ids;
     type_ids.reserve(union_type.type_codes().size());
     for (uint8_t code : union_type.type_codes()) {
       type_ids.push_back(code);
     }
 
     auto fb_type_ids =
         fbb_.CreateVector(util::MakeNonNull(type_ids.data()), type_ids.size());
 
     type_offset_ = flatbuf::CreateUnion(fbb_, mode, fb_type_ids).Union();
     return Status::OK();
   }
 
   Status Visit(const DictionaryType& type) {
     // In this library, the dictionary "type" is a logical construct. Here we
     // pass through to the value type, as we've already captured the index
     // type in the DictionaryEncoding metadata in the parent field
     return VisitType(*checked_cast<const DictionaryType&>(type).value_type());
   }
 
   Status Visit(const ExtensionType& type) {
     RETURN_NOT_OK(VisitType(*type.storage_type()));
     extra_type_metadata_[kExtensionTypeKeyName] = type.extension_name();
     extra_type_metadata_[kExtensionMetadataKeyName] = type.Serialize();
     return Status::OK();
   }
 
   Status GetResult(const std::shared_ptr<Field>& field, FieldOffset* offset) {
     auto fb_name = fbb_.CreateString(field->name());
     RETURN_NOT_OK(VisitType(*field->type()));
     auto fb_children =
         fbb_.CreateVector(util::MakeNonNull(children_.data()), children_.size());
 
     DictionaryOffset dictionary = 0;
     if (field->type()->id() == Type::DICTIONARY) {
       RETURN_NOT_OK(GetDictionaryEncoding(fbb_, field, dictionary_memo_, &dictionary));
     }
 
     auto metadata = field->metadata();
 
     flatbuffers::Offset<KVVector> fb_custom_metadata;
     std::vector<KeyValueOffset> key_values;
     if (metadata != nullptr) {
       AppendKeyValueMetadata(fbb_, *metadata, &key_values);
     }
 
     for (auto it : extra_type_metadata_) {
       key_values.push_back(AppendKeyValue(fbb_, it.first, it.second));
     }
 
     if (key_values.size() > 0) {
       fb_custom_metadata = fbb_.CreateVector(key_values);
     }
     *offset =
         flatbuf::CreateField(fbb_, fb_name, field->nullable(), fb_type_, type_offset_,
                              dictionary, fb_children, fb_custom_metadata);
     return Status::OK();
   }
 
  private:
   FBB& fbb_;
   DictionaryMemo* dictionary_memo_;
   flatbuf::Type fb_type_;
   Offset type_offset_;
   std::vector<FieldOffset> children_;
   std::unordered_map<std::string, std::string> extra_type_metadata_;
 };
@@ -817,12 +817,12 @@ Status FieldFromFlatbuffer(const flatbuf::Field* field, DictionaryMemo* dictiona
 // will return the endianness of the system we are running on
 // based the NUMPY_API function. See NOTICE.txt
 flatbuf::Endianness endianness() {
   union {
     uint32_t i;
     char c[4];
   } bint = {0x01020304};
 
-  return bint.c[0] == 1 ? flatbuf::Endianness_Big : flatbuf::Endianness_Little;
+  return bint.c[0] == 1 ? flatbuf::Endianness::Big : flatbuf::Endianness::Little;
 }
 
 Status SchemaToFlatbuffer(FBB& fbb, const Schema& schema, DictionaryMemo* dictionary_memo,
@@ -912,25 +912,25 @@ static Status MakeRecordBatch(FBB& fbb, int64_t length, int64_t body_length,
 Status MakeSparseTensorIndexCOO(FBB& fbb, const SparseCOOIndex& sparse_index,
                                 const std::vector<BufferMetadata>& buffers,
                                 flatbuf::SparseTensorIndex* fb_sparse_index_type,
                                 Offset* fb_sparse_index, size_t* num_buffers) {
-  *fb_sparse_index_type = flatbuf::SparseTensorIndex_SparseTensorIndexCOO;
+  *fb_sparse_index_type = flatbuf::SparseTensorIndex::SparseTensorIndexCOO;
 
   // We assume that the value type of indices tensor is an integer.
   const auto& index_value_type =
       checked_cast<const IntegerType&>(*sparse_index.indices()->type());
   auto indices_type_offset =
       flatbuf::CreateInt(fbb, index_value_type.bit_width(), index_value_type.is_signed());
 
   auto fb_strides =
       fbb.CreateVector(util::MakeNonNull(sparse_index.indices()->strides().data()),
                        sparse_index.indices()->strides().size());
 
   const BufferMetadata& indices_metadata = buffers[0];
   flatbuf::Buffer indices(indices_metadata.offset, indices_metadata.length);
 
   *fb_sparse_index =
       flatbuf::CreateSparseTensorIndexCOO(fbb, indices_type_offset, fb_strides, &indices)
           .Union();
   *num_buffers = 1;
   return Status::OK();
 }
@@ -940,44 +940,44 @@ struct SparseMatrixCompressedAxis {};
 
 template <>
 struct SparseMatrixCompressedAxis<SparseCSRIndex> {
-  constexpr static const auto value = flatbuf::SparseMatrixCompressedAxis_Row;
+  constexpr static const auto value = flatbuf::SparseMatrixCompressedAxis::Row;
 };
 
 template <>
 struct SparseMatrixCompressedAxis<SparseCSCIndex> {
-  constexpr static const auto value = flatbuf::SparseMatrixCompressedAxis_Column;
+  constexpr static const auto value = flatbuf::SparseMatrixCompressedAxis::Column;
 };
 
 template <typename SparseIndexType>
 Status MakeSparseMatrixIndexCSX(FBB& fbb, const SparseIndexType& sparse_index,
                                 const std::vector<BufferMetadata>& buffers,
                                 flatbuf::SparseTensorIndex* fb_sparse_index_type,
                                 Offset* fb_sparse_index, size_t* num_buffers) {
-  *fb_sparse_index_type = flatbuf::SparseTensorIndex_SparseMatrixIndexCSX;
+  *fb_sparse_index_type = flatbuf::SparseTensorIndex::SparseMatrixIndexCSX;
 
   // We assume that the value type of indptr tensor is an integer.
   const auto& indptr_value_type =
       checked_cast<const IntegerType&>(*sparse_index.indptr()->type());
   auto indptr_type_offset = flatbuf::CreateInt(fbb, indptr_value_type.bit_width(),
                                                indptr_value_type.is_signed());
 
   const BufferMetadata& indptr_metadata = buffers[0];
   flatbuf::Buffer indptr(indptr_metadata.offset, indptr_metadata.length);
 
   // We assume that the value type of indices tensor is an integer.
   const auto& indices_value_type =
       checked_cast<const IntegerType&>(*sparse_index.indices()->type());
   auto indices_type_offset = flatbuf::CreateInt(fbb, indices_value_type.bit_width(),
                                                 indices_value_type.is_signed());
 
   const BufferMetadata& indices_metadata = buffers[1];
   flatbuf::Buffer indices(indices_metadata.offset, indices_metadata.length);
 
   auto compressedAxis = SparseMatrixCompressedAxis<SparseIndexType>::value;
   *fb_sparse_index =
       flatbuf::CreateSparseMatrixIndexCSX(fbb, compressedAxis, indptr_type_offset,
                                           &indptr, indices_type_offset, &indices)
           .Union();
   *num_buffers = 2;
   return Status::OK();
 }
@@ -1055,20 +1055,20 @@ Status MakeSparseTensor(FBB& fbb, const SparseTensor& sparse_tensor, int64_t bod
 Status WriteSchemaMessage(const Schema& schema, DictionaryMemo* dictionary_memo,
                           std::shared_ptr<Buffer>* out) {
   FBB fbb;
   flatbuffers::Offset<flatbuf::Schema> fb_schema;
   RETURN_NOT_OK(SchemaToFlatbuffer(fbb, schema, dictionary_memo, &fb_schema));
-  return WriteFBMessage(fbb, flatbuf::MessageHeader_Schema, fb_schema.Union(), 0)
+  return WriteFBMessage(fbb, flatbuf::MessageHeader::Schema, fb_schema.Union(), 0)
       .Value(out);
 }
 
 Status WriteRecordBatchMessage(int64_t length, int64_t body_length,
                                const std::vector<FieldMetadata>& nodes,
                                const std::vector<BufferMetadata>& buffers,
                                std::shared_ptr<Buffer>* out) {
   FBB fbb;
   RecordBatchOffset record_batch;
   RETURN_NOT_OK(MakeRecordBatch(fbb, length, body_length, nodes, buffers, &record_batch));
-  return WriteFBMessage(fbb, flatbuf::MessageHeader_RecordBatch, record_batch.Union(),
+  return WriteFBMessage(fbb, flatbuf::MessageHeader::RecordBatch, record_batch.Union(),
                         body_length)
       .Value(out);
 }
@@ -1076,58 +1076,58 @@ Status WriteRecordBatchMessage(int64_t length, int64_t body_length,
 Result<std::shared_ptr<Buffer>> WriteTensorMessage(const Tensor& tensor,
                                                    int64_t buffer_start_offset) {
   using TensorDimOffset = flatbuffers::Offset<flatbuf::TensorDim>;
   using TensorOffset = flatbuffers::Offset<flatbuf::Tensor>;
 
   FBB fbb;
 
   const auto& type = checked_cast<const FixedWidthType&>(*tensor.type());
   const int elem_size = type.bit_width() / 8;
 
   flatbuf::Type fb_type_type;
   Offset fb_type;
   RETURN_NOT_OK(TensorTypeToFlatbuffer(fbb, *tensor.type(), &fb_type_type, &fb_type));
 
   std::vector<TensorDimOffset> dims;
   for (int i = 0; i < tensor.ndim(); ++i) {
     FBString name = fbb.CreateString(tensor.dim_name(i));
     dims.push_back(flatbuf::CreateTensorDim(fbb, tensor.shape()[i], name));
   }
 
   auto fb_shape = fbb.CreateVector(util::MakeNonNull(dims.data()), dims.size());
 
   flatbuffers::Offset<flatbuffers::Vector<int64_t>> fb_strides;
   fb_strides = fbb.CreateVector(util::MakeNonNull(tensor.strides().data()),
                                 tensor.strides().size());
   int64_t body_length = tensor.size() * elem_size;
   flatbuf::Buffer buffer(buffer_start_offset, body_length);
 
   TensorOffset fb_tensor =
       flatbuf::CreateTensor(fbb, fb_type_type, fb_type, fb_shape, fb_strides, &buffer);
 
-  return WriteFBMessage(fbb, flatbuf::MessageHeader_Tensor, fb_tensor.Union(),
+  return WriteFBMessage(fbb, flatbuf::MessageHeader::Tensor, fb_tensor.Union(),
                         body_length);
 }
 
 Result<std::shared_ptr<Buffer>> WriteSparseTensorMessage(
     const SparseTensor& sparse_tensor, int64_t body_length,
     const std::vector<BufferMetadata>& buffers) {
   FBB fbb;
   SparseTensorOffset fb_sparse_tensor;
   RETURN_NOT_OK(
       MakeSparseTensor(fbb, sparse_tensor, body_length, buffers, &fb_sparse_tensor));
-  return WriteFBMessage(fbb, flatbuf::MessageHeader_SparseTensor,
+  return WriteFBMessage(fbb, flatbuf::MessageHeader::SparseTensor,
                         fb_sparse_tensor.Union(), body_length);
 }
 
 Status WriteDictionaryMessage(int64_t id, int64_t length, int64_t body_length,
                               const std::vector<FieldMetadata>& nodes,
                               const std::vector<BufferMetadata>& buffers,
                               std::shared_ptr<Buffer>* out) {
   FBB fbb;
   RecordBatchOffset record_batch;
   RETURN_NOT_OK(MakeRecordBatch(fbb, length, body_length, nodes, buffers, &record_batch));
   auto dictionary_batch = flatbuf::CreateDictionaryBatch(fbb, id, record_batch).Union();
-  return WriteFBMessage(fbb, flatbuf::MessageHeader_DictionaryBatch, dictionary_batch,
+  return WriteFBMessage(fbb, flatbuf::MessageHeader::DictionaryBatch, dictionary_batch,
                         body_length)
       .Value(out);
 }
@@ -1263,79 +1263,79 @@ Status GetSparseCSXIndexMetadata(const flatbuf::SparseMatrixIndexCSX* sparse_ind
 Status GetSparseTensorMetadata(const Buffer& metadata, std::shared_ptr<DataType>* type,
                                std::vector<int64_t>* shape,
                                std::vector<std::string>* dim_names,
                                int64_t* non_zero_length,
                                SparseTensorFormat::type* sparse_tensor_format_id) {
   const flatbuf::Message* message;
   RETURN_NOT_OK(internal::VerifyMessage(metadata.data(), metadata.size(), &message));
   auto sparse_tensor = message->header_as_SparseTensor();
   if (sparse_tensor == nullptr) {
     return Status::IOError(
         "Header-type of flatbuffer-encoded Message is not SparseTensor.");
   }
   int ndim = static_cast<int>(sparse_tensor->shape()->size());
 
   if (shape || dim_names) {
     for (int i = 0; i < ndim; ++i) {
       auto dim = sparse_tensor->shape()->Get(i);
 
       if (shape) {
         shape->push_back(dim->size());
       }
 
       if (dim_names) {
         auto fb_name = dim->name();
         if (fb_name == 0) {
           dim_names->push_back("");
         } else {
           dim_names->push_back(fb_name->str());
         }
       }
     }
   }
 
   if (non_zero_length) {
     *non_zero_length = sparse_tensor->non_zero_length();
   }
 
   if (sparse_tensor_format_id) {
     switch (sparse_tensor->sparseIndex_type()) {
-      case flatbuf::SparseTensorIndex_SparseTensorIndexCOO:
+      case flatbuf::SparseTensorIndex::SparseTensorIndexCOO:
         *sparse_tensor_format_id = SparseTensorFormat::COO;
         break;
 
-      case flatbuf::SparseTensorIndex_SparseMatrixIndexCSX: {
+      case flatbuf::SparseTensorIndex::SparseMatrixIndexCSX: {
         auto cs = sparse_tensor->sparseIndex_as_SparseMatrixIndexCSX();
         switch (cs->compressedAxis()) {
-          case flatbuf::SparseMatrixCompressedAxis_Row:
+          case flatbuf::SparseMatrixCompressedAxis::Row:
             *sparse_tensor_format_id = SparseTensorFormat::CSR;
             break;
 
-          case flatbuf::SparseMatrixCompressedAxis_Column:
+          case flatbuf::SparseMatrixCompressedAxis::Column:
             *sparse_tensor_format_id = SparseTensorFormat::CSC;
             break;
 
           default:
             return Status::Invalid("Invalid value of SparseMatrixCompressedAxis");
         }
       } break;
 
       default:
         return Status::Invalid("Unrecognized sparse index type");
     }
   }
 
   auto type_data = sparse_tensor->type();
   if (type_data == nullptr) {
     return Status::IOError(
         "Type-pointer in custom metadata of flatbuffer-encoded SparseTensor is null.");
   }
   if (type) {
     return ConcreteTypeFromFlatbuffer(sparse_tensor->type_type(), type_data, {}, type);
   } else {
     return Status::OK();
   }
 }
 
 }  // namespace internal
 }  // namespace ipc
 }  // namespace arrow
diff --git a/cpp/src/arrow/ipc/metadata_internal.h b/cpp/src/arrow/ipc/metadata_internal.h
index d73fad73c..b2ac81f86 100644
--- a/cpp/src/arrow/ipc/metadata_internal.h
+++ b/cpp/src/arrow/ipc/metadata_internal.h
@@ -63,10 +63,10 @@ namespace internal {
 constexpr int32_t kIpcContinuationToken = -1;
 
 static constexpr flatbuf::MetadataVersion kCurrentMetadataVersion =
-    flatbuf::MetadataVersion_V4;
+    flatbuf::MetadataVersion::V4;
 
 static constexpr flatbuf::MetadataVersion kMinMetadataVersion =
-    flatbuf::MetadataVersion_V4;
+    flatbuf::MetadataVersion::V4;
 
 MetadataVersion GetMetadataVersion(flatbuf::MetadataVersion version);
 
diff --git a/cpp/src/arrow/ipc/read_write_test.cc b/cpp/src/arrow/ipc/read_write_test.cc
index b1b24663a..d3c0f9649 100644
--- a/cpp/src/arrow/ipc/read_write_test.cc
+++ b/cpp/src/arrow/ipc/read_write_test.cc
@@ -89,31 +89,31 @@ TEST(TestMessage, Equals) {
 TEST(TestMessage, SerializeTo) {
   const int64_t body_length = 64;
 
   flatbuffers::FlatBufferBuilder fbb;
   fbb.Finish(flatbuf::CreateMessage(fbb, internal::kCurrentMetadataVersion,
-                                    flatbuf::MessageHeader_RecordBatch, 0 /* header */,
+                                    flatbuf::MessageHeader::RecordBatch, 0 /* header */,
                                     body_length));
 
   std::shared_ptr<Buffer> metadata;
   ASSERT_OK_AND_ASSIGN(metadata, internal::WriteFlatbufferBuilder(fbb));
 
   std::string body = "abcdef";
 
   std::unique_ptr<Message> message;
   ASSERT_OK(Message::Open(metadata, std::make_shared<Buffer>(body), &message));
 
   auto CheckWithAlignment = [&](int32_t alignment) {
     IpcOptions options;
     options.alignment = alignment;
     const int32_t prefix_size = 8;
     int64_t output_length = 0;
     ASSERT_OK_AND_ASSIGN(auto stream, io::BufferOutputStream::Create(1 << 10));
     ASSERT_OK(message->SerializeTo(stream.get(), options, &output_length));
     ASSERT_EQ(BitUtil::RoundUp(metadata->size() + prefix_size, alignment) + body_length,
               output_length);
     ASSERT_OK_AND_EQ(output_length, stream->Tell());
   };
 
   CheckWithAlignment(8);
   CheckWithAlignment(64);
 }
diff --git a/cpp/src/arrow/ipc/reader.cc b/cpp/src/arrow/ipc/reader.cc
index 1a800b97d..762ea2737 100644
--- a/cpp/src/arrow/ipc/reader.cc
+++ b/cpp/src/arrow/ipc/reader.cc
@@ -889,58 +889,58 @@ Result<std::shared_ptr<SparseIndex>> ReadSparseCOOIndex(
 Result<std::shared_ptr<SparseIndex>> ReadSparseCSXIndex(
     const flatbuf::SparseTensor* sparse_tensor, const std::vector<int64_t>& shape,
     int64_t non_zero_length, io::RandomAccessFile* file) {
   if (shape.size() != 2) {
     return Status::Invalid("Invalid shape length for a sparse matrix");
   }
 
   auto* sparse_index = sparse_tensor->sparseIndex_as_SparseMatrixIndexCSX();
 
   std::shared_ptr<DataType> indptr_type, indices_type;
   RETURN_NOT_OK(
       internal::GetSparseCSXIndexMetadata(sparse_index, &indptr_type, &indices_type));
 
   auto* indptr_buffer = sparse_index->indptrBuffer();
   ARROW_ASSIGN_OR_RAISE(auto indptr_data,
                         file->ReadAt(indptr_buffer->offset(), indptr_buffer->length()));
 
   auto* indices_buffer = sparse_index->indicesBuffer();
   ARROW_ASSIGN_OR_RAISE(auto indices_data,
                         file->ReadAt(indices_buffer->offset(), indices_buffer->length()));
 
   std::vector<int64_t> indices_shape({non_zero_length});
   const auto indices_minimum_bytes =
       indices_shape[0] * checked_pointer_cast<FixedWidthType>(indices_type)->bit_width() /
       CHAR_BIT;
   if (indices_minimum_bytes > indices_buffer->length()) {
     return Status::Invalid("shape is inconsistent to the size of indices buffer");
   }
 
   switch (sparse_index->compressedAxis()) {
-    case flatbuf::SparseMatrixCompressedAxis_Row: {
+    case flatbuf::SparseMatrixCompressedAxis::Row: {
       std::vector<int64_t> indptr_shape({shape[0] + 1});
       const int64_t indptr_minimum_bytes =
           indptr_shape[0] *
           checked_pointer_cast<FixedWidthType>(indptr_type)->bit_width() / CHAR_BIT;
       if (indptr_minimum_bytes > indptr_buffer->length()) {
         return Status::Invalid("shape is inconsistent to the size of indptr buffer");
       }
       return std::make_shared<SparseCSRIndex>(
           std::make_shared<Tensor>(indptr_type, indptr_data, indptr_shape),
           std::make_shared<Tensor>(indices_type, indices_data, indices_shape));
     }
-    case flatbuf::SparseMatrixCompressedAxis_Column: {
+    case flatbuf::SparseMatrixCompressedAxis::Column: {
       std::vector<int64_t> indptr_shape({shape[1] + 1});
       const int64_t indptr_minimum_bytes =
           indptr_shape[0] *
           checked_pointer_cast<FixedWidthType>(indptr_type)->bit_width() / CHAR_BIT;
       if (indptr_minimum_bytes > indptr_buffer->length()) {
         return Status::Invalid("shape is inconsistent to the size of indptr buffer");
       }
       return std::make_shared<SparseCSCIndex>(
           std::make_shared<Tensor>(indptr_type, indptr_data, indptr_shape),
           std::make_shared<Tensor>(indices_type, indices_data, indices_shape));
     }
     default:
       return Status::Invalid("Invalid value of SparseMatrixCompressedAxis");
   }
 }
diff --git a/cpp/src/generated/File_generated.h b/cpp/src/generated/File_generated.h
index bca47b4fd..e1bc329eb 100644
--- a/cpp/src/generated/File_generated.h
+++ b/cpp/src/generated/File_generated.h
@@ -54,34 +54,42 @@ FLATBUFFERS_STRUCT_END(Block, 24);
 /// ----------------------------------------------------------------------
 /// Arrow File metadata
 ///
 struct Footer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_VERSION = 4,
     VT_SCHEMA = 6,
     VT_DICTIONARIES = 8,
-    VT_RECORDBATCHES = 10
+    VT_RECORDBATCHES = 10,
+    VT_CUSTOM_METADATA = 12
   };
-  org::apache::arrow::flatbuf::MetadataVersion version() const {
-    return static_cast<org::apache::arrow::flatbuf::MetadataVersion>(GetField<int16_t>(VT_VERSION, 0));
+  MetadataVersion version() const {
+    return static_cast<MetadataVersion>(GetField<int16_t>(VT_VERSION, 0));
   }
-  const org::apache::arrow::flatbuf::Schema *schema() const {
-    return GetPointer<const org::apache::arrow::flatbuf::Schema *>(VT_SCHEMA);
+  const Schema *schema() const {
+    return GetPointer<const Schema *>(VT_SCHEMA);
   }
-  const flatbuffers::Vector<const org::apache::arrow::flatbuf::Block *> *dictionaries() const {
-    return GetPointer<const flatbuffers::Vector<const org::apache::arrow::flatbuf::Block *> *>(VT_DICTIONARIES);
+  const flatbuffers::Vector<const Block *> *dictionaries() const {
+    return GetPointer<const flatbuffers::Vector<const Block *> *>(VT_DICTIONARIES);
   }
-  const flatbuffers::Vector<const org::apache::arrow::flatbuf::Block *> *recordBatches() const {
-    return GetPointer<const flatbuffers::Vector<const org::apache::arrow::flatbuf::Block *> *>(VT_RECORDBATCHES);
+  const flatbuffers::Vector<const Block *> *recordBatches() const {
+    return GetPointer<const flatbuffers::Vector<const Block *> *>(VT_RECORDBATCHES);
+  }
+  /// User-defined metadata
+  const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *custom_metadata() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *>(VT_CUSTOM_METADATA);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_VERSION) &&
            VerifyOffset(verifier, VT_SCHEMA) &&
            verifier.VerifyTable(schema()) &&
            VerifyOffset(verifier, VT_DICTIONARIES) &&
            verifier.VerifyVector(dictionaries()) &&
            VerifyOffset(verifier, VT_RECORDBATCHES) &&
            verifier.VerifyVector(recordBatches()) &&
+           VerifyOffset(verifier, VT_CUSTOM_METADATA) &&
+           verifier.VerifyVector(custom_metadata()) &&
+           verifier.VerifyVectorOfTables(custom_metadata()) &&
            verifier.EndTable();
   }
 };
@@ -89,58 +97,66 @@ struct Footer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct FooterBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_version(org::apache::arrow::flatbuf::MetadataVersion version) {
+  void add_version(MetadataVersion version) {
     fbb_.AddElement<int16_t>(Footer::VT_VERSION, static_cast<int16_t>(version), 0);
   }
-  void add_schema(flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema) {
+  void add_schema(flatbuffers::Offset<Schema> schema) {
     fbb_.AddOffset(Footer::VT_SCHEMA, schema);
   }
-  void add_dictionaries(flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Block *>> dictionaries) {
+  void add_dictionaries(flatbuffers::Offset<flatbuffers::Vector<const Block *>> dictionaries) {
     fbb_.AddOffset(Footer::VT_DICTIONARIES, dictionaries);
   }
-  void add_recordBatches(flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Block *>> recordBatches) {
+  void add_recordBatches(flatbuffers::Offset<flatbuffers::Vector<const Block *>> recordBatches) {
     fbb_.AddOffset(Footer::VT_RECORDBATCHES, recordBatches);
   }
+  void add_custom_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> custom_metadata) {
+    fbb_.AddOffset(Footer::VT_CUSTOM_METADATA, custom_metadata);
+  }
   explicit FooterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   FooterBuilder &operator=(const FooterBuilder &);
   flatbuffers::Offset<Footer> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Footer>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Footer> CreateFooter(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::MetadataVersion version = org::apache::arrow::flatbuf::MetadataVersion_V1,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0,
-    flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Block *>> dictionaries = 0,
-    flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Block *>> recordBatches = 0) {
+    MetadataVersion version = MetadataVersion::V1,
+    flatbuffers::Offset<Schema> schema = 0,
+    flatbuffers::Offset<flatbuffers::Vector<const Block *>> dictionaries = 0,
+    flatbuffers::Offset<flatbuffers::Vector<const Block *>> recordBatches = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> custom_metadata = 0) {
   FooterBuilder builder_(_fbb);
+  builder_.add_custom_metadata(custom_metadata);
   builder_.add_recordBatches(recordBatches);
   builder_.add_dictionaries(dictionaries);
   builder_.add_schema(schema);
   builder_.add_version(version);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<Footer> CreateFooterDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::MetadataVersion version = org::apache::arrow::flatbuf::MetadataVersion_V1,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::Schema> schema = 0,
-    const std::vector<org::apache::arrow::flatbuf::Block> *dictionaries = nullptr,
-    const std::vector<org::apache::arrow::flatbuf::Block> *recordBatches = nullptr) {
-  auto dictionaries__ = dictionaries ? _fbb.CreateVectorOfStructs<org::apache::arrow::flatbuf::Block>(*dictionaries) : 0;
-  auto recordBatches__ = recordBatches ? _fbb.CreateVectorOfStructs<org::apache::arrow::flatbuf::Block>(*recordBatches) : 0;
+    MetadataVersion version = MetadataVersion::V1,
+    flatbuffers::Offset<Schema> schema = 0,
+    const std::vector<Block> *dictionaries = nullptr,
+    const std::vector<Block> *recordBatches = nullptr,
+    const std::vector<flatbuffers::Offset<KeyValue>> *custom_metadata = nullptr) {
+  auto dictionaries__ = dictionaries ? _fbb.CreateVectorOfStructs<Block>(*dictionaries) : 0;
+  auto recordBatches__ = recordBatches ? _fbb.CreateVectorOfStructs<Block>(*recordBatches) : 0;
+  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<flatbuffers::Offset<KeyValue>>(*custom_metadata) : 0;
   return org::apache::arrow::flatbuf::CreateFooter(
       _fbb,
       version,
       schema,
       dictionaries__,
-      recordBatches__);
+      recordBatches__,
+      custom_metadata__);
 }
 
 inline const org::apache::arrow::flatbuf::Footer *GetFooter(const void *buf) {
diff --git a/cpp/src/generated/Message_generated.h b/cpp/src/generated/Message_generated.h
index 3c1c4e193..c541db0d0 100644
--- a/cpp/src/generated/Message_generated.h
+++ b/cpp/src/generated/Message_generated.h
@@ -26,75 +26,75 @@ struct Message;
 /// ----------------------------------------------------------------------
 /// The root Message type
 /// This union enables us to easily send different message types without
 /// redundant storage, and in the future we can easily add new message types.
 ///
 /// Arrow implementations do not need to implement all of the message types,
 /// which may include experimental metadata types. For maximum compatibility,
 /// it is best to send data using RecordBatch
-enum MessageHeader {
-  MessageHeader_NONE = 0,
-  MessageHeader_Schema = 1,
-  MessageHeader_DictionaryBatch = 2,
-  MessageHeader_RecordBatch = 3,
-  MessageHeader_Tensor = 4,
-  MessageHeader_SparseTensor = 5,
-  MessageHeader_MIN = MessageHeader_NONE,
-  MessageHeader_MAX = MessageHeader_SparseTensor
+enum class MessageHeader : uint8_t {
+  NONE = 0,
+  Schema = 1,
+  DictionaryBatch = 2,
+  RecordBatch = 3,
+  Tensor = 4,
+  SparseTensor = 5,
+  MIN = NONE,
+  MAX = SparseTensor
 };
 
 inline const MessageHeader (&EnumValuesMessageHeader())[6] {
   static const MessageHeader values[] = {
-    MessageHeader_NONE,
-    MessageHeader_Schema,
-    MessageHeader_DictionaryBatch,
-    MessageHeader_RecordBatch,
-    MessageHeader_Tensor,
-    MessageHeader_SparseTensor
+    MessageHeader::NONE,
+    MessageHeader::Schema,
+    MessageHeader::DictionaryBatch,
+    MessageHeader::RecordBatch,
+    MessageHeader::Tensor,
+    MessageHeader::SparseTensor
   };
   return values;
 }
 
 inline const char * const *EnumNamesMessageHeader() {
-  static const char * const names[7] = {
+  static const char * const names[] = {
     "NONE",
     "Schema",
     "DictionaryBatch",
     "RecordBatch",
     "Tensor",
     "SparseTensor",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameMessageHeader(MessageHeader e) {
-  if (e < MessageHeader_NONE || e > MessageHeader_SparseTensor) return "";
+  if (e < MessageHeader::NONE || e > MessageHeader::SparseTensor) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesMessageHeader()[index];
 }
 
 template<typename T> struct MessageHeaderTraits {
-  static const MessageHeader enum_value = MessageHeader_NONE;
+  static const MessageHeader enum_value = MessageHeader::NONE;
 };
 
-template<> struct MessageHeaderTraits<org::apache::arrow::flatbuf::Schema> {
-  static const MessageHeader enum_value = MessageHeader_Schema;
+template<> struct MessageHeaderTraits<Schema> {
+  static const MessageHeader enum_value = MessageHeader::Schema;
 };
 
-template<> struct MessageHeaderTraits<org::apache::arrow::flatbuf::DictionaryBatch> {
-  static const MessageHeader enum_value = MessageHeader_DictionaryBatch;
+template<> struct MessageHeaderTraits<DictionaryBatch> {
+  static const MessageHeader enum_value = MessageHeader::DictionaryBatch;
 };
 
-template<> struct MessageHeaderTraits<org::apache::arrow::flatbuf::RecordBatch> {
-  static const MessageHeader enum_value = MessageHeader_RecordBatch;
+template<> struct MessageHeaderTraits<RecordBatch> {
+  static const MessageHeader enum_value = MessageHeader::RecordBatch;
 };
 
-template<> struct MessageHeaderTraits<org::apache::arrow::flatbuf::Tensor> {
-  static const MessageHeader enum_value = MessageHeader_Tensor;
+template<> struct MessageHeaderTraits<Tensor> {
+  static const MessageHeader enum_value = MessageHeader::Tensor;
 };
 
-template<> struct MessageHeaderTraits<org::apache::arrow::flatbuf::SparseTensor> {
-  static const MessageHeader enum_value = MessageHeader_SparseTensor;
+template<> struct MessageHeaderTraits<SparseTensor> {
+  static const MessageHeader enum_value = MessageHeader::SparseTensor;
 };
 
 bool VerifyMessageHeader(flatbuffers::Verifier &verifier, const void *obj, MessageHeader type);
@@ -139,37 +139,37 @@ FLATBUFFERS_STRUCT_END(FieldNode, 16);
 /// A data header describing the shared memory layout of a "record" or "row"
 /// batch. Some systems call this a "row batch" internally and others a "record
 /// batch".
 struct RecordBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_LENGTH = 4,
     VT_NODES = 6,
     VT_BUFFERS = 8
   };
   /// number of records / rows. The arrays in the batch should all have this
   /// length
   int64_t length() const {
     return GetField<int64_t>(VT_LENGTH, 0);
   }
   /// Nodes correspond to the pre-ordered flattened logical schema
-  const flatbuffers::Vector<const org::apache::arrow::flatbuf::FieldNode *> *nodes() const {
-    return GetPointer<const flatbuffers::Vector<const org::apache::arrow::flatbuf::FieldNode *> *>(VT_NODES);
+  const flatbuffers::Vector<const FieldNode *> *nodes() const {
+    return GetPointer<const flatbuffers::Vector<const FieldNode *> *>(VT_NODES);
   }
   /// Buffers correspond to the pre-ordered flattened buffer tree
   ///
   /// The number of buffers appended to this list depends on the schema. For
   /// example, most primitive arrays will have 2 buffers, 1 for the validity
   /// bitmap and 1 for the values. For struct arrays, there will only be a
   /// single buffer for the validity (nulls) bitmap
-  const flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *> *buffers() const {
-    return GetPointer<const flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *> *>(VT_BUFFERS);
+  const flatbuffers::Vector<const Buffer *> *buffers() const {
+    return GetPointer<const flatbuffers::Vector<const Buffer *> *>(VT_BUFFERS);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int64_t>(verifier, VT_LENGTH) &&
            VerifyOffset(verifier, VT_NODES) &&
            verifier.VerifyVector(nodes()) &&
            VerifyOffset(verifier, VT_BUFFERS) &&
            verifier.VerifyVector(buffers()) &&
            verifier.EndTable();
   }
 };
@@ -177,23 +177,23 @@ struct RecordBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct RecordBatchBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_length(int64_t length) {
     fbb_.AddElement<int64_t>(RecordBatch::VT_LENGTH, length, 0);
   }
-  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::FieldNode *>> nodes) {
+  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<const FieldNode *>> nodes) {
     fbb_.AddOffset(RecordBatch::VT_NODES, nodes);
   }
-  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *>> buffers) {
+  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<const Buffer *>> buffers) {
     fbb_.AddOffset(RecordBatch::VT_BUFFERS, buffers);
   }
   explicit RecordBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   RecordBatchBuilder &operator=(const RecordBatchBuilder &);
   flatbuffers::Offset<RecordBatch> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<RecordBatch>(end);
     return o;
   }
 };
@@ -201,11 +201,11 @@ struct RecordBatchBuilder {
 inline flatbuffers::Offset<RecordBatch> CreateRecordBatch(
     flatbuffers::FlatBufferBuilder &_fbb,
     int64_t length = 0,
-    flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::FieldNode *>> nodes = 0,
-    flatbuffers::Offset<flatbuffers::Vector<const org::apache::arrow::flatbuf::Buffer *>> buffers = 0) {
+    flatbuffers::Offset<flatbuffers::Vector<const FieldNode *>> nodes = 0,
+    flatbuffers::Offset<flatbuffers::Vector<const Buffer *>> buffers = 0) {
   RecordBatchBuilder builder_(_fbb);
   builder_.add_length(length);
   builder_.add_buffers(buffers);
   builder_.add_nodes(nodes);
   return builder_.Finish();
 }
@@ -213,47 +213,47 @@ inline flatbuffers::Offset<RecordBatch> CreateRecordBatch(
 inline flatbuffers::Offset<RecordBatch> CreateRecordBatchDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
     int64_t length = 0,
-    const std::vector<org::apache::arrow::flatbuf::FieldNode> *nodes = nullptr,
-    const std::vector<org::apache::arrow::flatbuf::Buffer> *buffers = nullptr) {
-  auto nodes__ = nodes ? _fbb.CreateVectorOfStructs<org::apache::arrow::flatbuf::FieldNode>(*nodes) : 0;
-  auto buffers__ = buffers ? _fbb.CreateVectorOfStructs<org::apache::arrow::flatbuf::Buffer>(*buffers) : 0;
+    const std::vector<FieldNode> *nodes = nullptr,
+    const std::vector<Buffer> *buffers = nullptr) {
+  auto nodes__ = nodes ? _fbb.CreateVectorOfStructs<FieldNode>(*nodes) : 0;
+  auto buffers__ = buffers ? _fbb.CreateVectorOfStructs<Buffer>(*buffers) : 0;
   return org::apache::arrow::flatbuf::CreateRecordBatch(
       _fbb,
       length,
       nodes__,
       buffers__);
 }
 
 /// For sending dictionary encoding information. Any Field can be
 /// dictionary-encoded, but in this case none of its children may be
 /// dictionary-encoded.
 /// There is one vector / column per dictionary, but that vector / column
 /// may be spread across multiple dictionary batches by using the isDelta
 /// flag
 struct DictionaryBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_ID = 4,
     VT_DATA = 6,
     VT_ISDELTA = 8
   };
   int64_t id() const {
     return GetField<int64_t>(VT_ID, 0);
   }
-  const org::apache::arrow::flatbuf::RecordBatch *data() const {
-    return GetPointer<const org::apache::arrow::flatbuf::RecordBatch *>(VT_DATA);
+  const RecordBatch *data() const {
+    return GetPointer<const RecordBatch *>(VT_DATA);
   }
   /// If isDelta is true the values in the dictionary are to be appended to a
   /// dictionary with the indicated id. If isDelta is false this dictionary
   /// should replace the existing dictionary.
   bool isDelta() const {
     return GetField<uint8_t>(VT_ISDELTA, 0) != 0;
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int64_t>(verifier, VT_ID) &&
            VerifyOffset(verifier, VT_DATA) &&
            verifier.VerifyTable(data()) &&
            VerifyField<uint8_t>(verifier, VT_ISDELTA) &&
            verifier.EndTable();
   }
 };
@@ -261,23 +261,23 @@ struct DictionaryBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct DictionaryBatchBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_id(int64_t id) {
     fbb_.AddElement<int64_t>(DictionaryBatch::VT_ID, id, 0);
   }
-  void add_data(flatbuffers::Offset<org::apache::arrow::flatbuf::RecordBatch> data) {
+  void add_data(flatbuffers::Offset<RecordBatch> data) {
     fbb_.AddOffset(DictionaryBatch::VT_DATA, data);
   }
   void add_isDelta(bool isDelta) {
     fbb_.AddElement<uint8_t>(DictionaryBatch::VT_ISDELTA, static_cast<uint8_t>(isDelta), 0);
   }
   explicit DictionaryBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   DictionaryBatchBuilder &operator=(const DictionaryBatchBuilder &);
   flatbuffers::Offset<DictionaryBatch> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<DictionaryBatch>(end);
     return o;
   }
 };
@@ -285,11 +285,11 @@ struct DictionaryBatchBuilder {
 inline flatbuffers::Offset<DictionaryBatch> CreateDictionaryBatch(
     flatbuffers::FlatBufferBuilder &_fbb,
     int64_t id = 0,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::RecordBatch> data = 0,
+    flatbuffers::Offset<RecordBatch> data = 0,
     bool isDelta = false) {
   DictionaryBatchBuilder builder_(_fbb);
   builder_.add_id(id);
   builder_.add_data(data);
   builder_.add_isDelta(isDelta);
   return builder_.Finish();
 }
@@ -297,165 +297,165 @@ inline flatbuffers::Offset<DictionaryBatch> CreateDictionaryBatch(
 struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_VERSION = 4,
     VT_HEADER_TYPE = 6,
     VT_HEADER = 8,
     VT_BODYLENGTH = 10,
     VT_CUSTOM_METADATA = 12
   };
-  org::apache::arrow::flatbuf::MetadataVersion version() const {
-    return static_cast<org::apache::arrow::flatbuf::MetadataVersion>(GetField<int16_t>(VT_VERSION, 0));
+  MetadataVersion version() const {
+    return static_cast<MetadataVersion>(GetField<int16_t>(VT_VERSION, 0));
   }
-  org::apache::arrow::flatbuf::MessageHeader header_type() const {
-    return static_cast<org::apache::arrow::flatbuf::MessageHeader>(GetField<uint8_t>(VT_HEADER_TYPE, 0));
+  MessageHeader header_type() const {
+    return static_cast<MessageHeader>(GetField<uint8_t>(VT_HEADER_TYPE, 0));
   }
   const void *header() const {
     return GetPointer<const void *>(VT_HEADER);
   }
   template<typename T> const T *header_as() const;
-  const org::apache::arrow::flatbuf::Schema *header_as_Schema() const {
-    return header_type() == org::apache::arrow::flatbuf::MessageHeader_Schema ? static_cast<const org::apache::arrow::flatbuf::Schema *>(header()) : nullptr;
+  const Schema *header_as_Schema() const {
+    return header_type() == MessageHeader::Schema ? static_cast<const Schema *>(header()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::DictionaryBatch *header_as_DictionaryBatch() const {
-    return header_type() == org::apache::arrow::flatbuf::MessageHeader_DictionaryBatch ? static_cast<const org::apache::arrow::flatbuf::DictionaryBatch *>(header()) : nullptr;
+  const DictionaryBatch *header_as_DictionaryBatch() const {
+    return header_type() == MessageHeader::DictionaryBatch ? static_cast<const DictionaryBatch *>(header()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::RecordBatch *header_as_RecordBatch() const {
-    return header_type() == org::apache::arrow::flatbuf::MessageHeader_RecordBatch ? static_cast<const org::apache::arrow::flatbuf::RecordBatch *>(header()) : nullptr;
+  const RecordBatch *header_as_RecordBatch() const {
+    return header_type() == MessageHeader::RecordBatch ? static_cast<const RecordBatch *>(header()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Tensor *header_as_Tensor() const {
-    return header_type() == org::apache::arrow::flatbuf::MessageHeader_Tensor ? static_cast<const org::apache::arrow::flatbuf::Tensor *>(header()) : nullptr;
+  const Tensor *header_as_Tensor() const {
+    return header_type() == MessageHeader::Tensor ? static_cast<const Tensor *>(header()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::SparseTensor *header_as_SparseTensor() const {
-    return header_type() == org::apache::arrow::flatbuf::MessageHeader_SparseTensor ? static_cast<const org::apache::arrow::flatbuf::SparseTensor *>(header()) : nullptr;
+  const SparseTensor *header_as_SparseTensor() const {
+    return header_type() == MessageHeader::SparseTensor ? static_cast<const SparseTensor *>(header()) : nullptr;
   }
   int64_t bodyLength() const {
     return GetField<int64_t>(VT_BODYLENGTH, 0);
   }
-  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *>(VT_CUSTOM_METADATA);
+  const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *custom_metadata() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *>(VT_CUSTOM_METADATA);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_VERSION) &&
            VerifyField<uint8_t>(verifier, VT_HEADER_TYPE) &&
            VerifyOffset(verifier, VT_HEADER) &&
            VerifyMessageHeader(verifier, header(), header_type()) &&
            VerifyField<int64_t>(verifier, VT_BODYLENGTH) &&
            VerifyOffset(verifier, VT_CUSTOM_METADATA) &&
            verifier.VerifyVector(custom_metadata()) &&
            verifier.VerifyVectorOfTables(custom_metadata()) &&
            verifier.EndTable();
   }
 };
 
-template<> inline const org::apache::arrow::flatbuf::Schema *Message::header_as<org::apache::arrow::flatbuf::Schema>() const {
+template<> inline const Schema *Message::header_as<Schema>() const {
   return header_as_Schema();
 }
 
-template<> inline const org::apache::arrow::flatbuf::DictionaryBatch *Message::header_as<org::apache::arrow::flatbuf::DictionaryBatch>() const {
+template<> inline const DictionaryBatch *Message::header_as<DictionaryBatch>() const {
   return header_as_DictionaryBatch();
 }
 
-template<> inline const org::apache::arrow::flatbuf::RecordBatch *Message::header_as<org::apache::arrow::flatbuf::RecordBatch>() const {
+template<> inline const RecordBatch *Message::header_as<RecordBatch>() const {
   return header_as_RecordBatch();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Tensor *Message::header_as<org::apache::arrow::flatbuf::Tensor>() const {
+template<> inline const Tensor *Message::header_as<Tensor>() const {
   return header_as_Tensor();
 }
 
-template<> inline const org::apache::arrow::flatbuf::SparseTensor *Message::header_as<org::apache::arrow::flatbuf::SparseTensor>() const {
+template<> inline const SparseTensor *Message::header_as<SparseTensor>() const {
   return header_as_SparseTensor();
 }
 
 struct MessageBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_version(org::apache::arrow::flatbuf::MetadataVersion version) {
+  void add_version(MetadataVersion version) {
     fbb_.AddElement<int16_t>(Message::VT_VERSION, static_cast<int16_t>(version), 0);
   }
-  void add_header_type(org::apache::arrow::flatbuf::MessageHeader header_type) {
+  void add_header_type(MessageHeader header_type) {
     fbb_.AddElement<uint8_t>(Message::VT_HEADER_TYPE, static_cast<uint8_t>(header_type), 0);
   }
   void add_header(flatbuffers::Offset<void> header) {
     fbb_.AddOffset(Message::VT_HEADER, header);
   }
   void add_bodyLength(int64_t bodyLength) {
     fbb_.AddElement<int64_t>(Message::VT_BODYLENGTH, bodyLength, 0);
   }
-  void add_custom_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata) {
+  void add_custom_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> custom_metadata) {
     fbb_.AddOffset(Message::VT_CUSTOM_METADATA, custom_metadata);
   }
   explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   MessageBuilder &operator=(const MessageBuilder &);
   flatbuffers::Offset<Message> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Message>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Message> CreateMessage(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::MetadataVersion version = org::apache::arrow::flatbuf::MetadataVersion_V1,
-    org::apache::arrow::flatbuf::MessageHeader header_type = org::apache::arrow::flatbuf::MessageHeader_NONE,
+    MetadataVersion version = MetadataVersion::V1,
+    MessageHeader header_type = MessageHeader::NONE,
     flatbuffers::Offset<void> header = 0,
     int64_t bodyLength = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata = 0) {
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> custom_metadata = 0) {
   MessageBuilder builder_(_fbb);
   builder_.add_bodyLength(bodyLength);
   builder_.add_custom_metadata(custom_metadata);
   builder_.add_header(header);
   builder_.add_version(version);
   builder_.add_header_type(header_type);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<Message> CreateMessageDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::MetadataVersion version = org::apache::arrow::flatbuf::MetadataVersion_V1,
-    org::apache::arrow::flatbuf::MessageHeader header_type = org::apache::arrow::flatbuf::MessageHeader_NONE,
+    MetadataVersion version = MetadataVersion::V1,
+    MessageHeader header_type = MessageHeader::NONE,
     flatbuffers::Offset<void> header = 0,
     int64_t bodyLength = 0,
-    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata = nullptr) {
-  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>(*custom_metadata) : 0;
+    const std::vector<flatbuffers::Offset<KeyValue>> *custom_metadata = nullptr) {
+  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<flatbuffers::Offset<KeyValue>>(*custom_metadata) : 0;
   return org::apache::arrow::flatbuf::CreateMessage(
       _fbb,
       version,
       header_type,
       header,
       bodyLength,
       custom_metadata__);
 }
 
 inline bool VerifyMessageHeader(flatbuffers::Verifier &verifier, const void *obj, MessageHeader type) {
   switch (type) {
-    case MessageHeader_NONE: {
+    case MessageHeader::NONE: {
       return true;
     }
-    case MessageHeader_Schema: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Schema *>(obj);
+    case MessageHeader::Schema: {
+      auto ptr = reinterpret_cast<const Schema *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case MessageHeader_DictionaryBatch: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::DictionaryBatch *>(obj);
+    case MessageHeader::DictionaryBatch: {
+      auto ptr = reinterpret_cast<const DictionaryBatch *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case MessageHeader_RecordBatch: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::RecordBatch *>(obj);
+    case MessageHeader::RecordBatch: {
+      auto ptr = reinterpret_cast<const RecordBatch *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case MessageHeader_Tensor: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Tensor *>(obj);
+    case MessageHeader::Tensor: {
+      auto ptr = reinterpret_cast<const Tensor *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case MessageHeader_SparseTensor: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::SparseTensor *>(obj);
+    case MessageHeader::SparseTensor: {
+      auto ptr = reinterpret_cast<const SparseTensor *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    default: return true;
+    default: return false;
   }
 }
 
diff --git a/cpp/src/generated/Schema_generated.h b/cpp/src/generated/Schema_generated.h
index 91e321195..bfcde614c 100644
--- a/cpp/src/generated/Schema_generated.h
+++ b/cpp/src/generated/Schema_generated.h
@@ -63,384 +63,384 @@ struct Buffer;
 
 struct Schema;
 
-enum MetadataVersion {
+enum class MetadataVersion : int16_t {
   /// 0.1.0
-  MetadataVersion_V1 = 0,
-  /// 0.2.0
-  MetadataVersion_V2 = 1,
-  /// 0.3.0 -> 0.7.1
-  MetadataVersion_V3 = 2,
-  /// >= 0.8.0
-  MetadataVersion_V4 = 3,
-  MetadataVersion_MIN = MetadataVersion_V1,
-  MetadataVersion_MAX = MetadataVersion_V4
+  V1 = 0  /// 0.2.0
+,
+  V2 = 1  /// 0.3.0 -> 0.7.1
+,
+  V3 = 2  /// >= 0.8.0
+,
+  V4 = 3,
+  MIN = V1,
+  MAX = V4
 };
 
 inline const MetadataVersion (&EnumValuesMetadataVersion())[4] {
   static const MetadataVersion values[] = {
-    MetadataVersion_V1,
-    MetadataVersion_V2,
-    MetadataVersion_V3,
-    MetadataVersion_V4
+    MetadataVersion::V1,
+    MetadataVersion::V2,
+    MetadataVersion::V3,
+    MetadataVersion::V4
   };
   return values;
 }
 
 inline const char * const *EnumNamesMetadataVersion() {
-  static const char * const names[5] = {
+  static const char * const names[] = {
     "V1",
     "V2",
     "V3",
     "V4",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameMetadataVersion(MetadataVersion e) {
-  if (e < MetadataVersion_V1 || e > MetadataVersion_V4) return "";
+  if (e < MetadataVersion::V1 || e > MetadataVersion::V4) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesMetadataVersion()[index];
 }
 
-enum UnionMode {
-  UnionMode_Sparse = 0,
-  UnionMode_Dense = 1,
-  UnionMode_MIN = UnionMode_Sparse,
-  UnionMode_MAX = UnionMode_Dense
+enum class UnionMode : int16_t {
+  Sparse = 0,
+  Dense = 1,
+  MIN = Sparse,
+  MAX = Dense
 };
 
 inline const UnionMode (&EnumValuesUnionMode())[2] {
   static const UnionMode values[] = {
-    UnionMode_Sparse,
-    UnionMode_Dense
+    UnionMode::Sparse,
+    UnionMode::Dense
   };
   return values;
 }
 
 inline const char * const *EnumNamesUnionMode() {
-  static const char * const names[3] = {
+  static const char * const names[] = {
     "Sparse",
     "Dense",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameUnionMode(UnionMode e) {
-  if (e < UnionMode_Sparse || e > UnionMode_Dense) return "";
+  if (e < UnionMode::Sparse || e > UnionMode::Dense) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesUnionMode()[index];
 }
 
-enum Precision {
-  Precision_HALF = 0,
-  Precision_SINGLE = 1,
-  Precision_DOUBLE = 2,
-  Precision_MIN = Precision_HALF,
-  Precision_MAX = Precision_DOUBLE
+enum class Precision : int16_t {
+  HALF = 0,
+  SINGLE = 1,
+  DOUBLE = 2,
+  MIN = HALF,
+  MAX = DOUBLE
 };
 
 inline const Precision (&EnumValuesPrecision())[3] {
   static const Precision values[] = {
-    Precision_HALF,
-    Precision_SINGLE,
-    Precision_DOUBLE
+    Precision::HALF,
+    Precision::SINGLE,
+    Precision::DOUBLE
   };
   return values;
 }
 
 inline const char * const *EnumNamesPrecision() {
-  static const char * const names[4] = {
+  static const char * const names[] = {
     "HALF",
     "SINGLE",
     "DOUBLE",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNamePrecision(Precision e) {
-  if (e < Precision_HALF || e > Precision_DOUBLE) return "";
+  if (e < Precision::HALF || e > Precision::DOUBLE) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesPrecision()[index];
 }
 
-enum DateUnit {
-  DateUnit_DAY = 0,
-  DateUnit_MILLISECOND = 1,
-  DateUnit_MIN = DateUnit_DAY,
-  DateUnit_MAX = DateUnit_MILLISECOND
+enum class DateUnit : int16_t {
+  DAY = 0,
+  MILLISECOND = 1,
+  MIN = DAY,
+  MAX = MILLISECOND
 };
 
 inline const DateUnit (&EnumValuesDateUnit())[2] {
   static const DateUnit values[] = {
-    DateUnit_DAY,
-    DateUnit_MILLISECOND
+    DateUnit::DAY,
+    DateUnit::MILLISECOND
   };
   return values;
 }
 
 inline const char * const *EnumNamesDateUnit() {
-  static const char * const names[3] = {
+  static const char * const names[] = {
     "DAY",
     "MILLISECOND",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameDateUnit(DateUnit e) {
-  if (e < DateUnit_DAY || e > DateUnit_MILLISECOND) return "";
+  if (e < DateUnit::DAY || e > DateUnit::MILLISECOND) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesDateUnit()[index];
 }
 
-enum TimeUnit {
-  TimeUnit_SECOND = 0,
-  TimeUnit_MILLISECOND = 1,
-  TimeUnit_MICROSECOND = 2,
-  TimeUnit_NANOSECOND = 3,
-  TimeUnit_MIN = TimeUnit_SECOND,
-  TimeUnit_MAX = TimeUnit_NANOSECOND
+enum class TimeUnit : int16_t {
+  SECOND = 0,
+  MILLISECOND = 1,
+  MICROSECOND = 2,
+  NANOSECOND = 3,
+  MIN = SECOND,
+  MAX = NANOSECOND
 };
 
 inline const TimeUnit (&EnumValuesTimeUnit())[4] {
   static const TimeUnit values[] = {
-    TimeUnit_SECOND,
-    TimeUnit_MILLISECOND,
-    TimeUnit_MICROSECOND,
-    TimeUnit_NANOSECOND
+    TimeUnit::SECOND,
+    TimeUnit::MILLISECOND,
+    TimeUnit::MICROSECOND,
+    TimeUnit::NANOSECOND
   };
   return values;
 }
 
 inline const char * const *EnumNamesTimeUnit() {
-  static const char * const names[5] = {
+  static const char * const names[] = {
     "SECOND",
     "MILLISECOND",
     "MICROSECOND",
     "NANOSECOND",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameTimeUnit(TimeUnit e) {
-  if (e < TimeUnit_SECOND || e > TimeUnit_NANOSECOND) return "";
+  if (e < TimeUnit::SECOND || e > TimeUnit::NANOSECOND) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesTimeUnit()[index];
 }
 
-enum IntervalUnit {
-  IntervalUnit_YEAR_MONTH = 0,
-  IntervalUnit_DAY_TIME = 1,
-  IntervalUnit_MIN = IntervalUnit_YEAR_MONTH,
-  IntervalUnit_MAX = IntervalUnit_DAY_TIME
+enum class IntervalUnit : int16_t {
+  YEAR_MONTH = 0,
+  DAY_TIME = 1,
+  MIN = YEAR_MONTH,
+  MAX = DAY_TIME
 };
 
 inline const IntervalUnit (&EnumValuesIntervalUnit())[2] {
   static const IntervalUnit values[] = {
-    IntervalUnit_YEAR_MONTH,
-    IntervalUnit_DAY_TIME
+    IntervalUnit::YEAR_MONTH,
+    IntervalUnit::DAY_TIME
   };
   return values;
 }
 
 inline const char * const *EnumNamesIntervalUnit() {
-  static const char * const names[3] = {
+  static const char * const names[] = {
     "YEAR_MONTH",
     "DAY_TIME",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameIntervalUnit(IntervalUnit e) {
-  if (e < IntervalUnit_YEAR_MONTH || e > IntervalUnit_DAY_TIME) return "";
+  if (e < IntervalUnit::YEAR_MONTH || e > IntervalUnit::DAY_TIME) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesIntervalUnit()[index];
 }
 
 /// ----------------------------------------------------------------------
 /// Top-level Type value, enabling extensible type-specific metadata. We can
 /// add new logical types to Type without breaking backwards compatibility
-enum Type {
-  Type_NONE = 0,
-  Type_Null = 1,
-  Type_Int = 2,
-  Type_FloatingPoint = 3,
-  Type_Binary = 4,
-  Type_Utf8 = 5,
-  Type_Bool = 6,
-  Type_Decimal = 7,
-  Type_Date = 8,
-  Type_Time = 9,
-  Type_Timestamp = 10,
-  Type_Interval = 11,
-  Type_List = 12,
-  Type_Struct_ = 13,
-  Type_Union = 14,
-  Type_FixedSizeBinary = 15,
-  Type_FixedSizeList = 16,
-  Type_Map = 17,
-  Type_Duration = 18,
-  Type_LargeBinary = 19,
-  Type_LargeUtf8 = 20,
-  Type_LargeList = 21,
-  Type_MIN = Type_NONE,
-  Type_MAX = Type_LargeList
+enum class Type : uint8_t {
+  NONE = 0,
+  Null = 1,
+  Int = 2,
+  FloatingPoint = 3,
+  Binary = 4,
+  Utf8 = 5,
+  Bool = 6,
+  Decimal = 7,
+  Date = 8,
+  Time = 9,
+  Timestamp = 10,
+  Interval = 11,
+  List = 12,
+  Struct_ = 13,
+  Union = 14,
+  FixedSizeBinary = 15,
+  FixedSizeList = 16,
+  Map = 17,
+  Duration = 18,
+  LargeBinary = 19,
+  LargeUtf8 = 20,
+  LargeList = 21,
+  MIN = NONE,
+  MAX = LargeList
 };
 
 inline const Type (&EnumValuesType())[22] {
   static const Type values[] = {
-    Type_NONE,
-    Type_Null,
-    Type_Int,
-    Type_FloatingPoint,
-    Type_Binary,
-    Type_Utf8,
-    Type_Bool,
-    Type_Decimal,
-    Type_Date,
-    Type_Time,
-    Type_Timestamp,
-    Type_Interval,
-    Type_List,
-    Type_Struct_,
-    Type_Union,
-    Type_FixedSizeBinary,
-    Type_FixedSizeList,
-    Type_Map,
-    Type_Duration,
-    Type_LargeBinary,
-    Type_LargeUtf8,
-    Type_LargeList
+    Type::NONE,
+    Type::Null,
+    Type::Int,
+    Type::FloatingPoint,
+    Type::Binary,
+    Type::Utf8,
+    Type::Bool,
+    Type::Decimal,
+    Type::Date,
+    Type::Time,
+    Type::Timestamp,
+    Type::Interval,
+    Type::List,
+    Type::Struct_,
+    Type::Union,
+    Type::FixedSizeBinary,
+    Type::FixedSizeList,
+    Type::Map,
+    Type::Duration,
+    Type::LargeBinary,
+    Type::LargeUtf8,
+    Type::LargeList
   };
   return values;
 }
 
 inline const char * const *EnumNamesType() {
-  static const char * const names[23] = {
+  static const char * const names[] = {
     "NONE",
     "Null",
     "Int",
     "FloatingPoint",
     "Binary",
     "Utf8",
     "Bool",
     "Decimal",
     "Date",
     "Time",
     "Timestamp",
     "Interval",
     "List",
     "Struct_",
     "Union",
     "FixedSizeBinary",
     "FixedSizeList",
     "Map",
     "Duration",
     "LargeBinary",
     "LargeUtf8",
     "LargeList",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameType(Type e) {
-  if (e < Type_NONE || e > Type_LargeList) return "";
+  if (e < Type::NONE || e > Type::LargeList) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesType()[index];
 }
 
 template<typename T> struct TypeTraits {
-  static const Type enum_value = Type_NONE;
+  static const Type enum_value = Type::NONE;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Null> {
-  static const Type enum_value = Type_Null;
+template<> struct TypeTraits<Null> {
+  static const Type enum_value = Type::Null;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Int> {
-  static const Type enum_value = Type_Int;
+template<> struct TypeTraits<Int> {
+  static const Type enum_value = Type::Int;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::FloatingPoint> {
-  static const Type enum_value = Type_FloatingPoint;
+template<> struct TypeTraits<FloatingPoint> {
+  static const Type enum_value = Type::FloatingPoint;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Binary> {
-  static const Type enum_value = Type_Binary;
+template<> struct TypeTraits<Binary> {
+  static const Type enum_value = Type::Binary;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Utf8> {
-  static const Type enum_value = Type_Utf8;
+template<> struct TypeTraits<Utf8> {
+  static const Type enum_value = Type::Utf8;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Bool> {
-  static const Type enum_value = Type_Bool;
+template<> struct TypeTraits<Bool> {
+  static const Type enum_value = Type::Bool;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Decimal> {
-  static const Type enum_value = Type_Decimal;
+template<> struct TypeTraits<Decimal> {
+  static const Type enum_value = Type::Decimal;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Date> {
-  static const Type enum_value = Type_Date;
+template<> struct TypeTraits<Date> {
+  static const Type enum_value = Type::Date;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Time> {
-  static const Type enum_value = Type_Time;
+template<> struct TypeTraits<Time> {
+  static const Type enum_value = Type::Time;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Timestamp> {
-  static const Type enum_value = Type_Timestamp;
+template<> struct TypeTraits<Timestamp> {
+  static const Type enum_value = Type::Timestamp;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Interval> {
-  static const Type enum_value = Type_Interval;
+template<> struct TypeTraits<Interval> {
+  static const Type enum_value = Type::Interval;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::List> {
-  static const Type enum_value = Type_List;
+template<> struct TypeTraits<List> {
+  static const Type enum_value = Type::List;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Struct_> {
-  static const Type enum_value = Type_Struct_;
+template<> struct TypeTraits<Struct_> {
+  static const Type enum_value = Type::Struct_;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Union> {
-  static const Type enum_value = Type_Union;
+template<> struct TypeTraits<Union> {
+  static const Type enum_value = Type::Union;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::FixedSizeBinary> {
-  static const Type enum_value = Type_FixedSizeBinary;
+template<> struct TypeTraits<FixedSizeBinary> {
+  static const Type enum_value = Type::FixedSizeBinary;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::FixedSizeList> {
-  static const Type enum_value = Type_FixedSizeList;
+template<> struct TypeTraits<FixedSizeList> {
+  static const Type enum_value = Type::FixedSizeList;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Map> {
-  static const Type enum_value = Type_Map;
+template<> struct TypeTraits<Map> {
+  static const Type enum_value = Type::Map;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::Duration> {
-  static const Type enum_value = Type_Duration;
+template<> struct TypeTraits<Duration> {
+  static const Type enum_value = Type::Duration;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::LargeBinary> {
-  static const Type enum_value = Type_LargeBinary;
+template<> struct TypeTraits<LargeBinary> {
+  static const Type enum_value = Type::LargeBinary;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::LargeUtf8> {
-  static const Type enum_value = Type_LargeUtf8;
+template<> struct TypeTraits<LargeUtf8> {
+  static const Type enum_value = Type::LargeUtf8;
 };
 
-template<> struct TypeTraits<org::apache::arrow::flatbuf::LargeList> {
-  static const Type enum_value = Type_LargeList;
+template<> struct TypeTraits<LargeList> {
+  static const Type enum_value = Type::LargeList;
 };
 
 bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
@@ -449,66 +449,66 @@ bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector
 /// ----------------------------------------------------------------------
 /// Dictionary encoding metadata
 /// Maintained for forwards compatibility, in the future
 /// Dictionaries might be explicit maps between integers and values
 /// allowing for non-contiguous index values
-enum DictionaryKind {
-  DictionaryKind_DenseArray = 0,
-  DictionaryKind_MIN = DictionaryKind_DenseArray,
-  DictionaryKind_MAX = DictionaryKind_DenseArray
+enum class DictionaryKind : int16_t {
+  DenseArray = 0,
+  MIN = DenseArray,
+  MAX = DenseArray
 };
 
 inline const DictionaryKind (&EnumValuesDictionaryKind())[1] {
   static const DictionaryKind values[] = {
-    DictionaryKind_DenseArray
+    DictionaryKind::DenseArray
   };
   return values;
 }
 
 inline const char * const *EnumNamesDictionaryKind() {
-  static const char * const names[2] = {
+  static const char * const names[] = {
     "DenseArray",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameDictionaryKind(DictionaryKind e) {
-  if (e < DictionaryKind_DenseArray || e > DictionaryKind_DenseArray) return "";
+  if (e < DictionaryKind::DenseArray || e > DictionaryKind::DenseArray) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesDictionaryKind()[index];
 }
 
 /// ----------------------------------------------------------------------
 /// Endianness of the platform producing the data
-enum Endianness {
-  Endianness_Little = 0,
-  Endianness_Big = 1,
-  Endianness_MIN = Endianness_Little,
-  Endianness_MAX = Endianness_Big
+enum class Endianness : int16_t {
+  Little = 0,
+  Big = 1,
+  MIN = Little,
+  MAX = Big
 };
 
 inline const Endianness (&EnumValuesEndianness())[2] {
   static const Endianness values[] = {
-    Endianness_Little,
-    Endianness_Big
+    Endianness::Little,
+    Endianness::Big
   };
   return values;
 }
 
 inline const char * const *EnumNamesEndianness() {
-  static const char * const names[3] = {
+  static const char * const names[] = {
     "Little",
     "Big",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameEndianness(Endianness e) {
-  if (e < Endianness_Little || e > Endianness_Big) return "";
+  if (e < Endianness::Little || e > Endianness::Big) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesEndianness()[index];
 }
 
 /// ----------------------------------------------------------------------
 /// A Buffer represents a single contiguous memory segment
@@ -768,23 +768,23 @@ inline flatbuffers::Offset<Map> CreateMap(
 /// A union is a complex type with children in Field
 /// By default ids in the type vector refer to the offsets in the children
 /// optionally typeIds provides an indirection between the child offset and the type id
 /// for each child typeIds[offset] is the id used in the type vector
 struct Union FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_MODE = 4,
     VT_TYPEIDS = 6
   };
-  org::apache::arrow::flatbuf::UnionMode mode() const {
-    return static_cast<org::apache::arrow::flatbuf::UnionMode>(GetField<int16_t>(VT_MODE, 0));
+  UnionMode mode() const {
+    return static_cast<UnionMode>(GetField<int16_t>(VT_MODE, 0));
   }
   const flatbuffers::Vector<int32_t> *typeIds() const {
     return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TYPEIDS);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_MODE) &&
            VerifyOffset(verifier, VT_TYPEIDS) &&
            verifier.VerifyVector(typeIds()) &&
            verifier.EndTable();
   }
 };
@@ -792,41 +792,41 @@ struct Union FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct UnionBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_mode(org::apache::arrow::flatbuf::UnionMode mode) {
+  void add_mode(UnionMode mode) {
     fbb_.AddElement<int16_t>(Union::VT_MODE, static_cast<int16_t>(mode), 0);
   }
   void add_typeIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> typeIds) {
     fbb_.AddOffset(Union::VT_TYPEIDS, typeIds);
   }
   explicit UnionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   UnionBuilder &operator=(const UnionBuilder &);
   flatbuffers::Offset<Union> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Union>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Union> CreateUnion(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::UnionMode mode = org::apache::arrow::flatbuf::UnionMode_Sparse,
+    UnionMode mode = UnionMode::Sparse,
     flatbuffers::Offset<flatbuffers::Vector<int32_t>> typeIds = 0) {
   UnionBuilder builder_(_fbb);
   builder_.add_typeIds(typeIds);
   builder_.add_mode(mode);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<Union> CreateUnionDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::UnionMode mode = org::apache::arrow::flatbuf::UnionMode_Sparse,
+    UnionMode mode = UnionMode::Sparse,
     const std::vector<int32_t> *typeIds = nullptr) {
   auto typeIds__ = typeIds ? _fbb.CreateVector<int32_t>(*typeIds) : 0;
   return org::apache::arrow::flatbuf::CreateUnion(
       _fbb,
       mode,
       typeIds__);
 }
@@ -884,13 +884,13 @@ inline flatbuffers::Offset<Int> CreateInt(
 struct FloatingPoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_PRECISION = 4
   };
-  org::apache::arrow::flatbuf::Precision precision() const {
-    return static_cast<org::apache::arrow::flatbuf::Precision>(GetField<int16_t>(VT_PRECISION, 0));
+  Precision precision() const {
+    return static_cast<Precision>(GetField<int16_t>(VT_PRECISION, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_PRECISION) &&
            verifier.EndTable();
   }
 };
@@ -898,27 +898,27 @@ struct FloatingPoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct FloatingPointBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_precision(org::apache::arrow::flatbuf::Precision precision) {
+  void add_precision(Precision precision) {
     fbb_.AddElement<int16_t>(FloatingPoint::VT_PRECISION, static_cast<int16_t>(precision), 0);
   }
   explicit FloatingPointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   FloatingPointBuilder &operator=(const FloatingPointBuilder &);
   flatbuffers::Offset<FloatingPoint> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<FloatingPoint>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<FloatingPoint> CreateFloatingPoint(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::Precision precision = org::apache::arrow::flatbuf::Precision_HALF) {
+    Precision precision = Precision::HALF) {
   FloatingPointBuilder builder_(_fbb);
   builder_.add_precision(precision);
   return builder_.Finish();
 }
 
 /// Unicode with UTF-8 encoding
@@ -1163,19 +1163,19 @@ inline flatbuffers::Offset<Decimal> CreateDecimal(
 /// Date is either a 32-bit or 64-bit type representing elapsed time since UNIX
 /// epoch (1970-01-01), stored in either of two units:
 ///
 /// * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
 ///   leap seconds), where the values are evenly divisible by 86400000
 /// * Days (32 bits) since the UNIX epoch
 struct Date FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_UNIT = 4
   };
-  org::apache::arrow::flatbuf::DateUnit unit() const {
-    return static_cast<org::apache::arrow::flatbuf::DateUnit>(GetField<int16_t>(VT_UNIT, 1));
+  DateUnit unit() const {
+    return static_cast<DateUnit>(GetField<int16_t>(VT_UNIT, 1));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_UNIT) &&
            verifier.EndTable();
   }
 };
@@ -1183,47 +1183,47 @@ struct Date FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct DateBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_unit(org::apache::arrow::flatbuf::DateUnit unit) {
+  void add_unit(DateUnit unit) {
     fbb_.AddElement<int16_t>(Date::VT_UNIT, static_cast<int16_t>(unit), 1);
   }
   explicit DateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   DateBuilder &operator=(const DateBuilder &);
   flatbuffers::Offset<Date> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Date>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Date> CreateDate(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::DateUnit unit = org::apache::arrow::flatbuf::DateUnit_MILLISECOND) {
+    DateUnit unit = DateUnit::MILLISECOND) {
   DateBuilder builder_(_fbb);
   builder_.add_unit(unit);
   return builder_.Finish();
 }
 
 /// Time type. The physical storage type depends on the unit
 /// - SECOND and MILLISECOND: 32 bits
 /// - MICROSECOND and NANOSECOND: 64 bits
 struct Time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_UNIT = 4,
     VT_BITWIDTH = 6
   };
-  org::apache::arrow::flatbuf::TimeUnit unit() const {
-    return static_cast<org::apache::arrow::flatbuf::TimeUnit>(GetField<int16_t>(VT_UNIT, 1));
+  TimeUnit unit() const {
+    return static_cast<TimeUnit>(GetField<int16_t>(VT_UNIT, 1));
   }
   int32_t bitWidth() const {
     return GetField<int32_t>(VT_BITWIDTH, 32);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_UNIT) &&
            VerifyField<int32_t>(verifier, VT_BITWIDTH) &&
            verifier.EndTable();
   }
 };
@@ -1231,76 +1231,76 @@ struct Time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct TimeBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_unit(org::apache::arrow::flatbuf::TimeUnit unit) {
+  void add_unit(TimeUnit unit) {
     fbb_.AddElement<int16_t>(Time::VT_UNIT, static_cast<int16_t>(unit), 1);
   }
   void add_bitWidth(int32_t bitWidth) {
     fbb_.AddElement<int32_t>(Time::VT_BITWIDTH, bitWidth, 32);
   }
   explicit TimeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   TimeBuilder &operator=(const TimeBuilder &);
   flatbuffers::Offset<Time> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Time>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Time> CreateTime(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_MILLISECOND,
+    TimeUnit unit = TimeUnit::MILLISECOND,
     int32_t bitWidth = 32) {
   TimeBuilder builder_(_fbb);
   builder_.add_bitWidth(bitWidth);
   builder_.add_unit(unit);
   return builder_.Finish();
 }
 
 /// Time elapsed from the Unix epoch, 00:00:00.000 on 1 January 1970, excluding
 /// leap seconds, as a 64-bit integer. Note that UNIX time does not include
 /// leap seconds.
 ///
 /// The Timestamp metadata supports both "time zone naive" and "time zone
 /// aware" timestamps. Read about the timezone attribute for more detail
 struct Timestamp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_UNIT = 4,
     VT_TIMEZONE = 6
   };
-  org::apache::arrow::flatbuf::TimeUnit unit() const {
-    return static_cast<org::apache::arrow::flatbuf::TimeUnit>(GetField<int16_t>(VT_UNIT, 0));
+  TimeUnit unit() const {
+    return static_cast<TimeUnit>(GetField<int16_t>(VT_UNIT, 0));
   }
   /// The time zone is a string indicating the name of a time zone, one of:
   ///
   /// * As used in the Olson time zone database (the "tz database" or
   ///   "tzdata"), such as "America/New_York"
   /// * An absolute time zone offset of the form +XX:XX or -XX:XX, such as +07:30
   ///
   /// Whether a timezone string is present indicates different semantics about
   /// the data:
   ///
   /// * If the time zone is null or equal to an empty string, the data is "time
   ///   zone naive" and shall be displayed *as is* to the user, not localized
   ///   to the locale of the user. This data can be though of as UTC but
   ///   without having "UTC" as the time zone, it is not considered to be
   ///   localized to any time zone
   ///
   /// * If the time zone is set to a valid value, values can be displayed as
   ///   "localized" to that time zone, even though the underlying 64-bit
   ///   integers are identical to the same data stored in UTC. Converting
   ///   between time zones is a metadata-only operation and does not change the
   ///   underlying values
   const flatbuffers::String *timezone() const {
     return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_UNIT) &&
            VerifyOffset(verifier, VT_TIMEZONE) &&
            verifier.VerifyString(timezone()) &&
            verifier.EndTable();
   }
 };
@@ -1308,41 +1308,41 @@ struct Timestamp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct TimestampBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_unit(org::apache::arrow::flatbuf::TimeUnit unit) {
+  void add_unit(TimeUnit unit) {
     fbb_.AddElement<int16_t>(Timestamp::VT_UNIT, static_cast<int16_t>(unit), 0);
   }
   void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
     fbb_.AddOffset(Timestamp::VT_TIMEZONE, timezone);
   }
   explicit TimestampBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   TimestampBuilder &operator=(const TimestampBuilder &);
   flatbuffers::Offset<Timestamp> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Timestamp>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Timestamp> CreateTimestamp(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_SECOND,
+    TimeUnit unit = TimeUnit::SECOND,
     flatbuffers::Offset<flatbuffers::String> timezone = 0) {
   TimestampBuilder builder_(_fbb);
   builder_.add_timezone(timezone);
   builder_.add_unit(unit);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<Timestamp> CreateTimestampDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_SECOND,
+    TimeUnit unit = TimeUnit::SECOND,
     const char *timezone = nullptr) {
   auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
   return org::apache::arrow::flatbuf::CreateTimestamp(
       _fbb,
       unit,
       timezone__);
 }
@@ -1350,13 +1350,13 @@ inline flatbuffers::Offset<Timestamp> CreateTimestampDirect(
 struct Interval FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_UNIT = 4
   };
-  org::apache::arrow::flatbuf::IntervalUnit unit() const {
-    return static_cast<org::apache::arrow::flatbuf::IntervalUnit>(GetField<int16_t>(VT_UNIT, 0));
+  IntervalUnit unit() const {
+    return static_cast<IntervalUnit>(GetField<int16_t>(VT_UNIT, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_UNIT) &&
            verifier.EndTable();
   }
 };
@@ -1364,25 +1364,25 @@ struct Interval FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct IntervalBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_unit(org::apache::arrow::flatbuf::IntervalUnit unit) {
+  void add_unit(IntervalUnit unit) {
     fbb_.AddElement<int16_t>(Interval::VT_UNIT, static_cast<int16_t>(unit), 0);
   }
   explicit IntervalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   IntervalBuilder &operator=(const IntervalBuilder &);
   flatbuffers::Offset<Interval> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Interval>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Interval> CreateInterval(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::IntervalUnit unit = org::apache::arrow::flatbuf::IntervalUnit_YEAR_MONTH) {
+    IntervalUnit unit = IntervalUnit::YEAR_MONTH) {
   IntervalBuilder builder_(_fbb);
   builder_.add_unit(unit);
   return builder_.Finish();
 }
@@ -1390,13 +1390,13 @@ inline flatbuffers::Offset<Interval> CreateInterval(
 struct Duration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_UNIT = 4
   };
-  org::apache::arrow::flatbuf::TimeUnit unit() const {
-    return static_cast<org::apache::arrow::flatbuf::TimeUnit>(GetField<int16_t>(VT_UNIT, 1));
+  TimeUnit unit() const {
+    return static_cast<TimeUnit>(GetField<int16_t>(VT_UNIT, 1));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_UNIT) &&
            verifier.EndTable();
   }
 };
@@ -1404,29 +1404,29 @@ struct Duration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct DurationBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_unit(org::apache::arrow::flatbuf::TimeUnit unit) {
+  void add_unit(TimeUnit unit) {
     fbb_.AddElement<int16_t>(Duration::VT_UNIT, static_cast<int16_t>(unit), 1);
   }
   explicit DurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   DurationBuilder &operator=(const DurationBuilder &);
   flatbuffers::Offset<Duration> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Duration>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Duration> CreateDuration(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::TimeUnit unit = org::apache::arrow::flatbuf::TimeUnit_MILLISECOND) {
+    TimeUnit unit = TimeUnit::MILLISECOND) {
   DurationBuilder builder_(_fbb);
   builder_.add_unit(unit);
   return builder_.Finish();
 }
 
 /// ----------------------------------------------------------------------
 /// user defined key value pairs to add custom metadata to arrow
 /// key namespacing is the responsibility of the user
@@ -1497,38 +1497,38 @@ inline flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
 struct DictionaryEncoding FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_ID = 4,
     VT_INDEXTYPE = 6,
     VT_ISORDERED = 8,
     VT_DICTIONARYKIND = 10
   };
   /// The known dictionary id in the application where this data is used. In
   /// the file or streaming formats, the dictionary ids are found in the
   /// DictionaryBatch messages
   int64_t id() const {
     return GetField<int64_t>(VT_ID, 0);
   }
   /// The dictionary indices are constrained to be positive integers. If this
   /// field is null, the indices must be signed int32
-  const org::apache::arrow::flatbuf::Int *indexType() const {
-    return GetPointer<const org::apache::arrow::flatbuf::Int *>(VT_INDEXTYPE);
+  const Int *indexType() const {
+    return GetPointer<const Int *>(VT_INDEXTYPE);
   }
   /// By default, dictionaries are not ordered, or the order does not have
   /// semantic meaning. In some statistical, applications, dictionary-encoding
   /// is used to represent ordered categorical data, and we provide a way to
   /// preserve that metadata here
   bool isOrdered() const {
     return GetField<uint8_t>(VT_ISORDERED, 0) != 0;
   }
-  org::apache::arrow::flatbuf::DictionaryKind dictionaryKind() const {
-    return static_cast<org::apache::arrow::flatbuf::DictionaryKind>(GetField<int16_t>(VT_DICTIONARYKIND, 0));
+  DictionaryKind dictionaryKind() const {
+    return static_cast<DictionaryKind>(GetField<int16_t>(VT_DICTIONARYKIND, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int64_t>(verifier, VT_ID) &&
            VerifyOffset(verifier, VT_INDEXTYPE) &&
            verifier.VerifyTable(indexType()) &&
            VerifyField<uint8_t>(verifier, VT_ISORDERED) &&
            VerifyField<int16_t>(verifier, VT_DICTIONARYKIND) &&
            verifier.EndTable();
   }
 };
@@ -1536,26 +1536,26 @@ struct DictionaryEncoding FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct DictionaryEncodingBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_id(int64_t id) {
     fbb_.AddElement<int64_t>(DictionaryEncoding::VT_ID, id, 0);
   }
-  void add_indexType(flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indexType) {
+  void add_indexType(flatbuffers::Offset<Int> indexType) {
     fbb_.AddOffset(DictionaryEncoding::VT_INDEXTYPE, indexType);
   }
   void add_isOrdered(bool isOrdered) {
     fbb_.AddElement<uint8_t>(DictionaryEncoding::VT_ISORDERED, static_cast<uint8_t>(isOrdered), 0);
   }
-  void add_dictionaryKind(org::apache::arrow::flatbuf::DictionaryKind dictionaryKind) {
+  void add_dictionaryKind(DictionaryKind dictionaryKind) {
     fbb_.AddElement<int16_t>(DictionaryEncoding::VT_DICTIONARYKIND, static_cast<int16_t>(dictionaryKind), 0);
   }
   explicit DictionaryEncodingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   DictionaryEncodingBuilder &operator=(const DictionaryEncodingBuilder &);
   flatbuffers::Offset<DictionaryEncoding> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<DictionaryEncoding>(end);
     return o;
   }
 };
@@ -1563,258 +1563,258 @@ struct DictionaryEncodingBuilder {
 inline flatbuffers::Offset<DictionaryEncoding> CreateDictionaryEncoding(
     flatbuffers::FlatBufferBuilder &_fbb,
     int64_t id = 0,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indexType = 0,
+    flatbuffers::Offset<Int> indexType = 0,
     bool isOrdered = false,
-    org::apache::arrow::flatbuf::DictionaryKind dictionaryKind = org::apache::arrow::flatbuf::DictionaryKind_DenseArray) {
+    DictionaryKind dictionaryKind = DictionaryKind::DenseArray) {
   DictionaryEncodingBuilder builder_(_fbb);
   builder_.add_id(id);
   builder_.add_indexType(indexType);
   builder_.add_dictionaryKind(dictionaryKind);
   builder_.add_isOrdered(isOrdered);
   return builder_.Finish();
 }
 
 /// ----------------------------------------------------------------------
 /// A field represents a named column in a record / row batch or child of a
 /// nested type.
 struct Field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_NAME = 4,
     VT_NULLABLE = 6,
     VT_TYPE_TYPE = 8,
     VT_TYPE = 10,
     VT_DICTIONARY = 12,
     VT_CHILDREN = 14,
     VT_CUSTOM_METADATA = 16
   };
   /// Name is not required, in i.e. a List
   const flatbuffers::String *name() const {
     return GetPointer<const flatbuffers::String *>(VT_NAME);
   }
   /// Whether or not this field can contain nulls. Should be true in general.
   bool nullable() const {
     return GetField<uint8_t>(VT_NULLABLE, 0) != 0;
   }
-  org::apache::arrow::flatbuf::Type type_type() const {
-    return static_cast<org::apache::arrow::flatbuf::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
+  Type type_type() const {
+    return static_cast<Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
   }
   /// This is the type of the decoded value if the field is dictionary encoded.
   const void *type() const {
     return GetPointer<const void *>(VT_TYPE);
   }
   template<typename T> const T *type_as() const;
-  const org::apache::arrow::flatbuf::Null *type_as_Null() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Null ? static_cast<const org::apache::arrow::flatbuf::Null *>(type()) : nullptr;
+  const Null *type_as_Null() const {
+    return type_type() == Type::Null ? static_cast<const Null *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Int *type_as_Int() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Int ? static_cast<const org::apache::arrow::flatbuf::Int *>(type()) : nullptr;
+  const Int *type_as_Int() const {
+    return type_type() == Type::Int ? static_cast<const Int *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::FloatingPoint *type_as_FloatingPoint() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_FloatingPoint ? static_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(type()) : nullptr;
+  const FloatingPoint *type_as_FloatingPoint() const {
+    return type_type() == Type::FloatingPoint ? static_cast<const FloatingPoint *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Binary *type_as_Binary() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Binary ? static_cast<const org::apache::arrow::flatbuf::Binary *>(type()) : nullptr;
+  const Binary *type_as_Binary() const {
+    return type_type() == Type::Binary ? static_cast<const Binary *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Utf8 *type_as_Utf8() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Utf8 ? static_cast<const org::apache::arrow::flatbuf::Utf8 *>(type()) : nullptr;
+  const Utf8 *type_as_Utf8() const {
+    return type_type() == Type::Utf8 ? static_cast<const Utf8 *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Bool *type_as_Bool() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Bool ? static_cast<const org::apache::arrow::flatbuf::Bool *>(type()) : nullptr;
+  const Bool *type_as_Bool() const {
+    return type_type() == Type::Bool ? static_cast<const Bool *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Decimal *type_as_Decimal() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Decimal ? static_cast<const org::apache::arrow::flatbuf::Decimal *>(type()) : nullptr;
+  const Decimal *type_as_Decimal() const {
+    return type_type() == Type::Decimal ? static_cast<const Decimal *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Date *type_as_Date() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Date ? static_cast<const org::apache::arrow::flatbuf::Date *>(type()) : nullptr;
+  const Date *type_as_Date() const {
+    return type_type() == Type::Date ? static_cast<const Date *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Time *type_as_Time() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Time ? static_cast<const org::apache::arrow::flatbuf::Time *>(type()) : nullptr;
+  const Time *type_as_Time() const {
+    return type_type() == Type::Time ? static_cast<const Time *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Timestamp *type_as_Timestamp() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Timestamp ? static_cast<const org::apache::arrow::flatbuf::Timestamp *>(type()) : nullptr;
+  const Timestamp *type_as_Timestamp() const {
+    return type_type() == Type::Timestamp ? static_cast<const Timestamp *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Interval *type_as_Interval() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Interval ? static_cast<const org::apache::arrow::flatbuf::Interval *>(type()) : nullptr;
+  const Interval *type_as_Interval() const {
+    return type_type() == Type::Interval ? static_cast<const Interval *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::List *type_as_List() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_List ? static_cast<const org::apache::arrow::flatbuf::List *>(type()) : nullptr;
+  const List *type_as_List() const {
+    return type_type() == Type::List ? static_cast<const List *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Struct_ *type_as_Struct_() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Struct_ ? static_cast<const org::apache::arrow::flatbuf::Struct_ *>(type()) : nullptr;
+  const Struct_ *type_as_Struct_() const {
+    return type_type() == Type::Struct_ ? static_cast<const Struct_ *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Union *type_as_Union() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Union ? static_cast<const org::apache::arrow::flatbuf::Union *>(type()) : nullptr;
+  const Union *type_as_Union() const {
+    return type_type() == Type::Union ? static_cast<const Union *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::FixedSizeBinary *type_as_FixedSizeBinary() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_FixedSizeBinary ? static_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(type()) : nullptr;
+  const FixedSizeBinary *type_as_FixedSizeBinary() const {
+    return type_type() == Type::FixedSizeBinary ? static_cast<const FixedSizeBinary *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::FixedSizeList *type_as_FixedSizeList() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_FixedSizeList ? static_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(type()) : nullptr;
+  const FixedSizeList *type_as_FixedSizeList() const {
+    return type_type() == Type::FixedSizeList ? static_cast<const FixedSizeList *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Map *type_as_Map() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Map ? static_cast<const org::apache::arrow::flatbuf::Map *>(type()) : nullptr;
+  const Map *type_as_Map() const {
+    return type_type() == Type::Map ? static_cast<const Map *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Duration *type_as_Duration() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Duration ? static_cast<const org::apache::arrow::flatbuf::Duration *>(type()) : nullptr;
+  const Duration *type_as_Duration() const {
+    return type_type() == Type::Duration ? static_cast<const Duration *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::LargeBinary *type_as_LargeBinary() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_LargeBinary ? static_cast<const org::apache::arrow::flatbuf::LargeBinary *>(type()) : nullptr;
+  const LargeBinary *type_as_LargeBinary() const {
+    return type_type() == Type::LargeBinary ? static_cast<const LargeBinary *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::LargeUtf8 *type_as_LargeUtf8() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_LargeUtf8 ? static_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(type()) : nullptr;
+  const LargeUtf8 *type_as_LargeUtf8() const {
+    return type_type() == Type::LargeUtf8 ? static_cast<const LargeUtf8 *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::LargeList *type_as_LargeList() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_LargeList ? static_cast<const org::apache::arrow::flatbuf::LargeList *>(type()) : nullptr;
+  const LargeList *type_as_LargeList() const {
+    return type_type() == Type::LargeList ? static_cast<const LargeList *>(type()) : nullptr;
   }
   /// Present only if the field is dictionary encoded.
-  const org::apache::arrow::flatbuf::DictionaryEncoding *dictionary() const {
-    return GetPointer<const org::apache::arrow::flatbuf::DictionaryEncoding *>(VT_DICTIONARY);
+  const DictionaryEncoding *dictionary() const {
+    return GetPointer<const DictionaryEncoding *>(VT_DICTIONARY);
   }
   /// children apply only to nested data types like Struct, List and Union. For
   /// primitive types children will have length 0.
-  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *children() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *>(VT_CHILDREN);
+  const flatbuffers::Vector<flatbuffers::Offset<Field>> *children() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Field>> *>(VT_CHILDREN);
   }
   /// User-defined metadata
-  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *>(VT_CUSTOM_METADATA);
+  const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *custom_metadata() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *>(VT_CUSTOM_METADATA);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_NAME) &&
            verifier.VerifyString(name()) &&
            VerifyField<uint8_t>(verifier, VT_NULLABLE) &&
            VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
            VerifyOffset(verifier, VT_TYPE) &&
            VerifyType(verifier, type(), type_type()) &&
            VerifyOffset(verifier, VT_DICTIONARY) &&
            verifier.VerifyTable(dictionary()) &&
            VerifyOffset(verifier, VT_CHILDREN) &&
            verifier.VerifyVector(children()) &&
            verifier.VerifyVectorOfTables(children()) &&
            VerifyOffset(verifier, VT_CUSTOM_METADATA) &&
            verifier.VerifyVector(custom_metadata()) &&
            verifier.VerifyVectorOfTables(custom_metadata()) &&
            verifier.EndTable();
   }
 };
 
-template<> inline const org::apache::arrow::flatbuf::Null *Field::type_as<org::apache::arrow::flatbuf::Null>() const {
+template<> inline const Null *Field::type_as<Null>() const {
   return type_as_Null();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Int *Field::type_as<org::apache::arrow::flatbuf::Int>() const {
+template<> inline const Int *Field::type_as<Int>() const {
   return type_as_Int();
 }
 
-template<> inline const org::apache::arrow::flatbuf::FloatingPoint *Field::type_as<org::apache::arrow::flatbuf::FloatingPoint>() const {
+template<> inline const FloatingPoint *Field::type_as<FloatingPoint>() const {
   return type_as_FloatingPoint();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Binary *Field::type_as<org::apache::arrow::flatbuf::Binary>() const {
+template<> inline const Binary *Field::type_as<Binary>() const {
   return type_as_Binary();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Utf8 *Field::type_as<org::apache::arrow::flatbuf::Utf8>() const {
+template<> inline const Utf8 *Field::type_as<Utf8>() const {
   return type_as_Utf8();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Bool *Field::type_as<org::apache::arrow::flatbuf::Bool>() const {
+template<> inline const Bool *Field::type_as<Bool>() const {
   return type_as_Bool();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Decimal *Field::type_as<org::apache::arrow::flatbuf::Decimal>() const {
+template<> inline const Decimal *Field::type_as<Decimal>() const {
   return type_as_Decimal();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Date *Field::type_as<org::apache::arrow::flatbuf::Date>() const {
+template<> inline const Date *Field::type_as<Date>() const {
   return type_as_Date();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Time *Field::type_as<org::apache::arrow::flatbuf::Time>() const {
+template<> inline const Time *Field::type_as<Time>() const {
   return type_as_Time();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Timestamp *Field::type_as<org::apache::arrow::flatbuf::Timestamp>() const {
+template<> inline const Timestamp *Field::type_as<Timestamp>() const {
   return type_as_Timestamp();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Interval *Field::type_as<org::apache::arrow::flatbuf::Interval>() const {
+template<> inline const Interval *Field::type_as<Interval>() const {
   return type_as_Interval();
 }
 
-template<> inline const org::apache::arrow::flatbuf::List *Field::type_as<org::apache::arrow::flatbuf::List>() const {
+template<> inline const List *Field::type_as<List>() const {
   return type_as_List();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Struct_ *Field::type_as<org::apache::arrow::flatbuf::Struct_>() const {
+template<> inline const Struct_ *Field::type_as<Struct_>() const {
   return type_as_Struct_();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Union *Field::type_as<org::apache::arrow::flatbuf::Union>() const {
+template<> inline const Union *Field::type_as<Union>() const {
   return type_as_Union();
 }
 
-template<> inline const org::apache::arrow::flatbuf::FixedSizeBinary *Field::type_as<org::apache::arrow::flatbuf::FixedSizeBinary>() const {
+template<> inline const FixedSizeBinary *Field::type_as<FixedSizeBinary>() const {
   return type_as_FixedSizeBinary();
 }
 
-template<> inline const org::apache::arrow::flatbuf::FixedSizeList *Field::type_as<org::apache::arrow::flatbuf::FixedSizeList>() const {
+template<> inline const FixedSizeList *Field::type_as<FixedSizeList>() const {
   return type_as_FixedSizeList();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Map *Field::type_as<org::apache::arrow::flatbuf::Map>() const {
+template<> inline const Map *Field::type_as<Map>() const {
   return type_as_Map();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Duration *Field::type_as<org::apache::arrow::flatbuf::Duration>() const {
+template<> inline const Duration *Field::type_as<Duration>() const {
   return type_as_Duration();
 }
 
-template<> inline const org::apache::arrow::flatbuf::LargeBinary *Field::type_as<org::apache::arrow::flatbuf::LargeBinary>() const {
+template<> inline const LargeBinary *Field::type_as<LargeBinary>() const {
   return type_as_LargeBinary();
 }
 
-template<> inline const org::apache::arrow::flatbuf::LargeUtf8 *Field::type_as<org::apache::arrow::flatbuf::LargeUtf8>() const {
+template<> inline const LargeUtf8 *Field::type_as<LargeUtf8>() const {
   return type_as_LargeUtf8();
 }
 
-template<> inline const org::apache::arrow::flatbuf::LargeList *Field::type_as<org::apache::arrow::flatbuf::LargeList>() const {
+template<> inline const LargeList *Field::type_as<LargeList>() const {
   return type_as_LargeList();
 }
 
 struct FieldBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_name(flatbuffers::Offset<flatbuffers::String> name) {
     fbb_.AddOffset(Field::VT_NAME, name);
   }
   void add_nullable(bool nullable) {
     fbb_.AddElement<uint8_t>(Field::VT_NULLABLE, static_cast<uint8_t>(nullable), 0);
   }
-  void add_type_type(org::apache::arrow::flatbuf::Type type_type) {
+  void add_type_type(Type type_type) {
     fbb_.AddElement<uint8_t>(Field::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
   }
   void add_type(flatbuffers::Offset<void> type) {
     fbb_.AddOffset(Field::VT_TYPE, type);
   }
-  void add_dictionary(flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryEncoding> dictionary) {
+  void add_dictionary(flatbuffers::Offset<DictionaryEncoding> dictionary) {
     fbb_.AddOffset(Field::VT_DICTIONARY, dictionary);
   }
-  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>> children) {
+  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Field>>> children) {
     fbb_.AddOffset(Field::VT_CHILDREN, children);
   }
-  void add_custom_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata) {
+  void add_custom_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> custom_metadata) {
     fbb_.AddOffset(Field::VT_CUSTOM_METADATA, custom_metadata);
   }
   explicit FieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   FieldBuilder &operator=(const FieldBuilder &);
   flatbuffers::Offset<Field> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Field>(end);
     return o;
   }
 };
@@ -1822,19 +1822,19 @@ struct FieldBuilder {
 inline flatbuffers::Offset<Field> CreateField(
     flatbuffers::FlatBufferBuilder &_fbb,
     flatbuffers::Offset<flatbuffers::String> name = 0,
     bool nullable = false,
-    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type_NONE,
+    Type type_type = Type::NONE,
     flatbuffers::Offset<void> type = 0,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryEncoding> dictionary = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>> children = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata = 0) {
+    flatbuffers::Offset<DictionaryEncoding> dictionary = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Field>>> children = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> custom_metadata = 0) {
   FieldBuilder builder_(_fbb);
   builder_.add_custom_metadata(custom_metadata);
   builder_.add_children(children);
   builder_.add_dictionary(dictionary);
   builder_.add_type(type);
   builder_.add_name(name);
   builder_.add_type_type(type_type);
   builder_.add_nullable(nullable);
   return builder_.Finish();
 }
@@ -1842,55 +1842,55 @@ inline flatbuffers::Offset<Field> CreateField(
 inline flatbuffers::Offset<Field> CreateFieldDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
     const char *name = nullptr,
     bool nullable = false,
-    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type_NONE,
+    Type type_type = Type::NONE,
     flatbuffers::Offset<void> type = 0,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::DictionaryEncoding> dictionary = 0,
-    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *children = nullptr,
-    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata = nullptr) {
+    flatbuffers::Offset<DictionaryEncoding> dictionary = 0,
+    const std::vector<flatbuffers::Offset<Field>> *children = nullptr,
+    const std::vector<flatbuffers::Offset<KeyValue>> *custom_metadata = nullptr) {
   auto name__ = name ? _fbb.CreateString(name) : 0;
-  auto children__ = children ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>(*children) : 0;
-  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>(*custom_metadata) : 0;
+  auto children__ = children ? _fbb.CreateVector<flatbuffers::Offset<Field>>(*children) : 0;
+  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<flatbuffers::Offset<KeyValue>>(*custom_metadata) : 0;
   return org::apache::arrow::flatbuf::CreateField(
       _fbb,
       name__,
       nullable,
       type_type,
       type,
       dictionary,
       children__,
       custom_metadata__);
 }
 
 /// ----------------------------------------------------------------------
 /// A Schema describes the columns in a row batch
 struct Schema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_ENDIANNESS = 4,
     VT_FIELDS = 6,
     VT_CUSTOM_METADATA = 8
   };
   /// endianness of the buffer
   /// it is Little Endian by default
   /// if endianness doesn't match the underlying system then the vectors need to be converted
-  org::apache::arrow::flatbuf::Endianness endianness() const {
-    return static_cast<org::apache::arrow::flatbuf::Endianness>(GetField<int16_t>(VT_ENDIANNESS, 0));
+  Endianness endianness() const {
+    return static_cast<Endianness>(GetField<int16_t>(VT_ENDIANNESS, 0));
   }
-  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *fields() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *>(VT_FIELDS);
+  const flatbuffers::Vector<flatbuffers::Offset<Field>> *fields() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Field>> *>(VT_FIELDS);
   }
-  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *>(VT_CUSTOM_METADATA);
+  const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *custom_metadata() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<KeyValue>> *>(VT_CUSTOM_METADATA);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_ENDIANNESS) &&
            VerifyOffset(verifier, VT_FIELDS) &&
            verifier.VerifyVector(fields()) &&
            verifier.VerifyVectorOfTables(fields()) &&
            VerifyOffset(verifier, VT_CUSTOM_METADATA) &&
            verifier.VerifyVector(custom_metadata()) &&
            verifier.VerifyVectorOfTables(custom_metadata()) &&
            verifier.EndTable();
   }
 };
@@ -1898,143 +1898,143 @@ struct Schema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct SchemaBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_endianness(org::apache::arrow::flatbuf::Endianness endianness) {
+  void add_endianness(Endianness endianness) {
     fbb_.AddElement<int16_t>(Schema::VT_ENDIANNESS, static_cast<int16_t>(endianness), 0);
   }
-  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>> fields) {
+  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Field>>> fields) {
     fbb_.AddOffset(Schema::VT_FIELDS, fields);
   }
-  void add_custom_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata) {
+  void add_custom_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> custom_metadata) {
     fbb_.AddOffset(Schema::VT_CUSTOM_METADATA, custom_metadata);
   }
   explicit SchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   SchemaBuilder &operator=(const SchemaBuilder &);
   flatbuffers::Offset<Schema> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Schema>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Schema> CreateSchema(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::Endianness endianness = org::apache::arrow::flatbuf::Endianness_Little,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>> fields = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>> custom_metadata = 0) {
+    Endianness endianness = Endianness::Little,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Field>>> fields = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<KeyValue>>> custom_metadata = 0) {
   SchemaBuilder builder_(_fbb);
   builder_.add_custom_metadata(custom_metadata);
   builder_.add_fields(fields);
   builder_.add_endianness(endianness);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<Schema> CreateSchemaDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::Endianness endianness = org::apache::arrow::flatbuf::Endianness_Little,
-    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>> *fields = nullptr,
-    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>> *custom_metadata = nullptr) {
-  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::Field>>(*fields) : 0;
-  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::KeyValue>>(*custom_metadata) : 0;
+    Endianness endianness = Endianness::Little,
+    const std::vector<flatbuffers::Offset<Field>> *fields = nullptr,
+    const std::vector<flatbuffers::Offset<KeyValue>> *custom_metadata = nullptr) {
+  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<Field>>(*fields) : 0;
+  auto custom_metadata__ = custom_metadata ? _fbb.CreateVector<flatbuffers::Offset<KeyValue>>(*custom_metadata) : 0;
   return org::apache::arrow::flatbuf::CreateSchema(
       _fbb,
       endianness,
       fields__,
       custom_metadata__);
 }
 
 inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
   switch (type) {
-    case Type_NONE: {
+    case Type::NONE: {
       return true;
     }
-    case Type_Null: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Null *>(obj);
+    case Type::Null: {
+      auto ptr = reinterpret_cast<const Null *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Int: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Int *>(obj);
+    case Type::Int: {
+      auto ptr = reinterpret_cast<const Int *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_FloatingPoint: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(obj);
+    case Type::FloatingPoint: {
+      auto ptr = reinterpret_cast<const FloatingPoint *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Binary: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Binary *>(obj);
+    case Type::Binary: {
+      auto ptr = reinterpret_cast<const Binary *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Utf8: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Utf8 *>(obj);
+    case Type::Utf8: {
+      auto ptr = reinterpret_cast<const Utf8 *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Bool: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Bool *>(obj);
+    case Type::Bool: {
+      auto ptr = reinterpret_cast<const Bool *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Decimal: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Decimal *>(obj);
+    case Type::Decimal: {
+      auto ptr = reinterpret_cast<const Decimal *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Date: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Date *>(obj);
+    case Type::Date: {
+      auto ptr = reinterpret_cast<const Date *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Time: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Time *>(obj);
+    case Type::Time: {
+      auto ptr = reinterpret_cast<const Time *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Timestamp: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Timestamp *>(obj);
+    case Type::Timestamp: {
+      auto ptr = reinterpret_cast<const Timestamp *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Interval: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Interval *>(obj);
+    case Type::Interval: {
+      auto ptr = reinterpret_cast<const Interval *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_List: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::List *>(obj);
+    case Type::List: {
+      auto ptr = reinterpret_cast<const List *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Struct_: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Struct_ *>(obj);
+    case Type::Struct_: {
+      auto ptr = reinterpret_cast<const Struct_ *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Union: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Union *>(obj);
+    case Type::Union: {
+      auto ptr = reinterpret_cast<const Union *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_FixedSizeBinary: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(obj);
+    case Type::FixedSizeBinary: {
+      auto ptr = reinterpret_cast<const FixedSizeBinary *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_FixedSizeList: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(obj);
+    case Type::FixedSizeList: {
+      auto ptr = reinterpret_cast<const FixedSizeList *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Map: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Map *>(obj);
+    case Type::Map: {
+      auto ptr = reinterpret_cast<const Map *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_Duration: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::Duration *>(obj);
+    case Type::Duration: {
+      auto ptr = reinterpret_cast<const Duration *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_LargeBinary: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::LargeBinary *>(obj);
+    case Type::LargeBinary: {
+      auto ptr = reinterpret_cast<const LargeBinary *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_LargeUtf8: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(obj);
+    case Type::LargeUtf8: {
+      auto ptr = reinterpret_cast<const LargeUtf8 *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case Type_LargeList: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::LargeList *>(obj);
+    case Type::LargeList: {
+      auto ptr = reinterpret_cast<const LargeList *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    default: return true;
+    default: return false;
   }
 }
 
diff --git a/cpp/src/generated/SparseTensor_generated.h b/cpp/src/generated/SparseTensor_generated.h
index 5ea88c69f..80e5b5827 100644
--- a/cpp/src/generated/SparseTensor_generated.h
+++ b/cpp/src/generated/SparseTensor_generated.h
@@ -20,79 +20,79 @@ struct SparseMatrixIndexCSX;
 
 struct SparseTensor;
 
-enum SparseMatrixCompressedAxis {
-  SparseMatrixCompressedAxis_Row = 0,
-  SparseMatrixCompressedAxis_Column = 1,
-  SparseMatrixCompressedAxis_MIN = SparseMatrixCompressedAxis_Row,
-  SparseMatrixCompressedAxis_MAX = SparseMatrixCompressedAxis_Column
+enum class SparseMatrixCompressedAxis : int16_t {
+  Row = 0,
+  Column = 1,
+  MIN = Row,
+  MAX = Column
 };
 
 inline const SparseMatrixCompressedAxis (&EnumValuesSparseMatrixCompressedAxis())[2] {
   static const SparseMatrixCompressedAxis values[] = {
-    SparseMatrixCompressedAxis_Row,
-    SparseMatrixCompressedAxis_Column
+    SparseMatrixCompressedAxis::Row,
+    SparseMatrixCompressedAxis::Column
   };
   return values;
 }
 
 inline const char * const *EnumNamesSparseMatrixCompressedAxis() {
-  static const char * const names[3] = {
+  static const char * const names[] = {
     "Row",
     "Column",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameSparseMatrixCompressedAxis(SparseMatrixCompressedAxis e) {
-  if (e < SparseMatrixCompressedAxis_Row || e > SparseMatrixCompressedAxis_Column) return "";
+  if (e < SparseMatrixCompressedAxis::Row || e > SparseMatrixCompressedAxis::Column) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesSparseMatrixCompressedAxis()[index];
 }
 
-enum SparseTensorIndex {
-  SparseTensorIndex_NONE = 0,
-  SparseTensorIndex_SparseTensorIndexCOO = 1,
-  SparseTensorIndex_SparseMatrixIndexCSX = 2,
-  SparseTensorIndex_MIN = SparseTensorIndex_NONE,
-  SparseTensorIndex_MAX = SparseTensorIndex_SparseMatrixIndexCSX
+enum class SparseTensorIndex : uint8_t {
+  NONE = 0,
+  SparseTensorIndexCOO = 1,
+  SparseMatrixIndexCSX = 2,
+  MIN = NONE,
+  MAX = SparseMatrixIndexCSX
 };
 
 inline const SparseTensorIndex (&EnumValuesSparseTensorIndex())[3] {
   static const SparseTensorIndex values[] = {
-    SparseTensorIndex_NONE,
-    SparseTensorIndex_SparseTensorIndexCOO,
-    SparseTensorIndex_SparseMatrixIndexCSX
+    SparseTensorIndex::NONE,
+    SparseTensorIndex::SparseTensorIndexCOO,
+    SparseTensorIndex::SparseMatrixIndexCSX
   };
   return values;
 }
 
 inline const char * const *EnumNamesSparseTensorIndex() {
-  static const char * const names[4] = {
+  static const char * const names[] = {
     "NONE",
     "SparseTensorIndexCOO",
     "SparseMatrixIndexCSX",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameSparseTensorIndex(SparseTensorIndex e) {
-  if (e < SparseTensorIndex_NONE || e > SparseTensorIndex_SparseMatrixIndexCSX) return "";
+  if (e < SparseTensorIndex::NONE || e > SparseTensorIndex::SparseMatrixIndexCSX) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesSparseTensorIndex()[index];
 }
 
 template<typename T> struct SparseTensorIndexTraits {
-  static const SparseTensorIndex enum_value = SparseTensorIndex_NONE;
+  static const SparseTensorIndex enum_value = SparseTensorIndex::NONE;
 };
 
-template<> struct SparseTensorIndexTraits<org::apache::arrow::flatbuf::SparseTensorIndexCOO> {
-  static const SparseTensorIndex enum_value = SparseTensorIndex_SparseTensorIndexCOO;
+template<> struct SparseTensorIndexTraits<SparseTensorIndexCOO> {
+  static const SparseTensorIndex enum_value = SparseTensorIndex::SparseTensorIndexCOO;
 };
 
-template<> struct SparseTensorIndexTraits<org::apache::arrow::flatbuf::SparseMatrixIndexCSX> {
-  static const SparseTensorIndex enum_value = SparseTensorIndex_SparseMatrixIndexCSX;
+template<> struct SparseTensorIndexTraits<SparseMatrixIndexCSX> {
+  static const SparseTensorIndex enum_value = SparseTensorIndex::SparseMatrixIndexCSX;
 };
 
 bool VerifySparseTensorIndex(flatbuffers::Verifier &verifier, const void *obj, SparseTensorIndex type);
@@ -101,58 +101,58 @@ bool VerifySparseTensorIndexVector(flatbuffers::Verifier &verifier, const flatbu
 /// ----------------------------------------------------------------------
 /// EXPERIMENTAL: Data structures for sparse tensors
 /// Coordinate (COO) format of sparse tensor index.
 ///
 /// COO's index list are represented as a NxM matrix,
 /// where N is the number of non-zero values,
 /// and M is the number of dimensions of a sparse tensor.
 ///
 /// indicesBuffer stores the location and size of the data of this indices
 /// matrix.  The value type and the stride of the indices matrix is
 /// specified in indicesType and indicesStrides fields.
 ///
 /// For example, let X be a 2x3x4x5 tensor, and it has the following
 /// 6 non-zero values:
 ///
 ///   X[0, 1, 2, 0] := 1
 ///   X[1, 1, 2, 3] := 2
 ///   X[0, 2, 1, 0] := 3
 ///   X[0, 1, 3, 0] := 4
 ///   X[0, 1, 2, 1] := 5
 ///   X[1, 2, 0, 4] := 6
 ///
 /// In COO format, the index matrix of X is the following 4x6 matrix:
 ///
 ///   [[0, 0, 0, 0, 1, 1],
 ///    [1, 1, 1, 2, 1, 2],
 ///    [2, 2, 3, 1, 2, 0],
 ///    [0, 1, 0, 0, 3, 4]]
 ///
 /// Note that the indices are sorted in lexicographical order.
 struct SparseTensorIndexCOO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_INDICESTYPE = 4,
     VT_INDICESSTRIDES = 6,
     VT_INDICESBUFFER = 8
   };
   /// The type of values in indicesBuffer
-  const org::apache::arrow::flatbuf::Int *indicesType() const {
-    return GetPointer<const org::apache::arrow::flatbuf::Int *>(VT_INDICESTYPE);
+  const Int *indicesType() const {
+    return GetPointer<const Int *>(VT_INDICESTYPE);
   }
   /// Non-negative byte offsets to advance one value cell along each dimension
   const flatbuffers::Vector<int64_t> *indicesStrides() const {
     return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_INDICESSTRIDES);
   }
   /// The location and size of the indices matrix's data
-  const org::apache::arrow::flatbuf::Buffer *indicesBuffer() const {
-    return GetStruct<const org::apache::arrow::flatbuf::Buffer *>(VT_INDICESBUFFER);
+  const Buffer *indicesBuffer() const {
+    return GetStruct<const Buffer *>(VT_INDICESBUFFER);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_INDICESTYPE) &&
            verifier.VerifyTable(indicesType()) &&
            VerifyOffset(verifier, VT_INDICESSTRIDES) &&
            verifier.VerifyVector(indicesStrides()) &&
-           VerifyField<org::apache::arrow::flatbuf::Buffer>(verifier, VT_INDICESBUFFER) &&
+           VerifyField<Buffer>(verifier, VT_INDICESBUFFER) &&
            verifier.EndTable();
   }
 };
@@ -160,119 +160,119 @@ struct SparseTensorIndexCOO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
 struct SparseTensorIndexCOOBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_indicesType(flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indicesType) {
+  void add_indicesType(flatbuffers::Offset<Int> indicesType) {
     fbb_.AddOffset(SparseTensorIndexCOO::VT_INDICESTYPE, indicesType);
   }
   void add_indicesStrides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> indicesStrides) {
     fbb_.AddOffset(SparseTensorIndexCOO::VT_INDICESSTRIDES, indicesStrides);
   }
-  void add_indicesBuffer(const org::apache::arrow::flatbuf::Buffer *indicesBuffer) {
+  void add_indicesBuffer(const Buffer *indicesBuffer) {
     fbb_.AddStruct(SparseTensorIndexCOO::VT_INDICESBUFFER, indicesBuffer);
   }
   explicit SparseTensorIndexCOOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   SparseTensorIndexCOOBuilder &operator=(const SparseTensorIndexCOOBuilder &);
   flatbuffers::Offset<SparseTensorIndexCOO> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<SparseTensorIndexCOO>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<SparseTensorIndexCOO> CreateSparseTensorIndexCOO(
     flatbuffers::FlatBufferBuilder &_fbb,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indicesType = 0,
+    flatbuffers::Offset<Int> indicesType = 0,
     flatbuffers::Offset<flatbuffers::Vector<int64_t>> indicesStrides = 0,
-    const org::apache::arrow::flatbuf::Buffer *indicesBuffer = 0) {
+    const Buffer *indicesBuffer = 0) {
   SparseTensorIndexCOOBuilder builder_(_fbb);
   builder_.add_indicesBuffer(indicesBuffer);
   builder_.add_indicesStrides(indicesStrides);
   builder_.add_indicesType(indicesType);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<SparseTensorIndexCOO> CreateSparseTensorIndexCOODirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indicesType = 0,
+    flatbuffers::Offset<Int> indicesType = 0,
     const std::vector<int64_t> *indicesStrides = nullptr,
-    const org::apache::arrow::flatbuf::Buffer *indicesBuffer = 0) {
+    const Buffer *indicesBuffer = 0) {
   auto indicesStrides__ = indicesStrides ? _fbb.CreateVector<int64_t>(*indicesStrides) : 0;
   return org::apache::arrow::flatbuf::CreateSparseTensorIndexCOO(
       _fbb,
       indicesType,
       indicesStrides__,
       indicesBuffer);
 }
 
 /// Compressed Sparse format, that is matrix-specific.
 struct SparseMatrixIndexCSX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_COMPRESSEDAXIS = 4,
     VT_INDPTRTYPE = 6,
     VT_INDPTRBUFFER = 8,
     VT_INDICESTYPE = 10,
     VT_INDICESBUFFER = 12
   };
   /// Which axis, row or column, is compressed
-  org::apache::arrow::flatbuf::SparseMatrixCompressedAxis compressedAxis() const {
-    return static_cast<org::apache::arrow::flatbuf::SparseMatrixCompressedAxis>(GetField<int16_t>(VT_COMPRESSEDAXIS, 0));
+  SparseMatrixCompressedAxis compressedAxis() const {
+    return static_cast<SparseMatrixCompressedAxis>(GetField<int16_t>(VT_COMPRESSEDAXIS, 0));
   }
   /// The type of values in indptrBuffer
-  const org::apache::arrow::flatbuf::Int *indptrType() const {
-    return GetPointer<const org::apache::arrow::flatbuf::Int *>(VT_INDPTRTYPE);
+  const Int *indptrType() const {
+    return GetPointer<const Int *>(VT_INDPTRTYPE);
   }
   /// indptrBuffer stores the location and size of indptr array that
   /// represents the range of the rows.
   /// The i-th row spans from indptr[i] to indptr[i+1] in the data.
   /// The length of this array is 1 + (the number of rows), and the type
   /// of index value is long.
   ///
   /// For example, let X be the following 6x4 matrix:
   ///
   ///   X := [[0, 1, 2, 0],
   ///         [0, 0, 3, 0],
   ///         [0, 4, 0, 5],
   ///         [0, 0, 0, 0],
   ///         [6, 0, 7, 8],
   ///         [0, 9, 0, 0]].
   ///
   /// The array of non-zero values in X is:
   ///
   ///   values(X) = [1, 2, 3, 4, 5, 6, 7, 8, 9].
   ///
   /// And the indptr of X is:
   ///
   ///   indptr(X) = [0, 2, 3, 5, 5, 8, 10].
-  const org::apache::arrow::flatbuf::Buffer *indptrBuffer() const {
-    return GetStruct<const org::apache::arrow::flatbuf::Buffer *>(VT_INDPTRBUFFER);
+  const Buffer *indptrBuffer() const {
+    return GetStruct<const Buffer *>(VT_INDPTRBUFFER);
   }
   /// The type of values in indicesBuffer
-  const org::apache::arrow::flatbuf::Int *indicesType() const {
-    return GetPointer<const org::apache::arrow::flatbuf::Int *>(VT_INDICESTYPE);
+  const Int *indicesType() const {
+    return GetPointer<const Int *>(VT_INDICESTYPE);
   }
   /// indicesBuffer stores the location and size of the array that
   /// contains the column indices of the corresponding non-zero values.
   /// The type of index value is long.
   ///
   /// For example, the indices of the above X is:
   ///
   ///   indices(X) = [1, 2, 2, 1, 3, 0, 2, 3, 1].
   ///
   /// Note that the indices are sorted in lexicographical order for each row.
-  const org::apache::arrow::flatbuf::Buffer *indicesBuffer() const {
-    return GetStruct<const org::apache::arrow::flatbuf::Buffer *>(VT_INDICESBUFFER);
+  const Buffer *indicesBuffer() const {
+    return GetStruct<const Buffer *>(VT_INDICESBUFFER);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int16_t>(verifier, VT_COMPRESSEDAXIS) &&
            VerifyOffset(verifier, VT_INDPTRTYPE) &&
            verifier.VerifyTable(indptrType()) &&
-           VerifyField<org::apache::arrow::flatbuf::Buffer>(verifier, VT_INDPTRBUFFER) &&
+           VerifyField<Buffer>(verifier, VT_INDPTRBUFFER) &&
            VerifyOffset(verifier, VT_INDICESTYPE) &&
            verifier.VerifyTable(indicesType()) &&
-           VerifyField<org::apache::arrow::flatbuf::Buffer>(verifier, VT_INDICESBUFFER) &&
+           VerifyField<Buffer>(verifier, VT_INDICESBUFFER) &&
            verifier.EndTable();
   }
 };
@@ -280,45 +280,45 @@ struct SparseMatrixIndexCSX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
 struct SparseMatrixIndexCSXBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_compressedAxis(org::apache::arrow::flatbuf::SparseMatrixCompressedAxis compressedAxis) {
+  void add_compressedAxis(SparseMatrixCompressedAxis compressedAxis) {
     fbb_.AddElement<int16_t>(SparseMatrixIndexCSX::VT_COMPRESSEDAXIS, static_cast<int16_t>(compressedAxis), 0);
   }
-  void add_indptrType(flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indptrType) {
+  void add_indptrType(flatbuffers::Offset<Int> indptrType) {
     fbb_.AddOffset(SparseMatrixIndexCSX::VT_INDPTRTYPE, indptrType);
   }
-  void add_indptrBuffer(const org::apache::arrow::flatbuf::Buffer *indptrBuffer) {
+  void add_indptrBuffer(const Buffer *indptrBuffer) {
     fbb_.AddStruct(SparseMatrixIndexCSX::VT_INDPTRBUFFER, indptrBuffer);
   }
-  void add_indicesType(flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indicesType) {
+  void add_indicesType(flatbuffers::Offset<Int> indicesType) {
     fbb_.AddOffset(SparseMatrixIndexCSX::VT_INDICESTYPE, indicesType);
   }
-  void add_indicesBuffer(const org::apache::arrow::flatbuf::Buffer *indicesBuffer) {
+  void add_indicesBuffer(const Buffer *indicesBuffer) {
     fbb_.AddStruct(SparseMatrixIndexCSX::VT_INDICESBUFFER, indicesBuffer);
   }
   explicit SparseMatrixIndexCSXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   SparseMatrixIndexCSXBuilder &operator=(const SparseMatrixIndexCSXBuilder &);
   flatbuffers::Offset<SparseMatrixIndexCSX> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<SparseMatrixIndexCSX>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<SparseMatrixIndexCSX> CreateSparseMatrixIndexCSX(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::SparseMatrixCompressedAxis compressedAxis = org::apache::arrow::flatbuf::SparseMatrixCompressedAxis_Row,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indptrType = 0,
-    const org::apache::arrow::flatbuf::Buffer *indptrBuffer = 0,
-    flatbuffers::Offset<org::apache::arrow::flatbuf::Int> indicesType = 0,
-    const org::apache::arrow::flatbuf::Buffer *indicesBuffer = 0) {
+    SparseMatrixCompressedAxis compressedAxis = SparseMatrixCompressedAxis::Row,
+    flatbuffers::Offset<Int> indptrType = 0,
+    const Buffer *indptrBuffer = 0,
+    flatbuffers::Offset<Int> indicesType = 0,
+    const Buffer *indicesBuffer = 0) {
   SparseMatrixIndexCSXBuilder builder_(_fbb);
   builder_.add_indicesBuffer(indicesBuffer);
   builder_.add_indicesType(indicesType);
   builder_.add_indptrBuffer(indptrBuffer);
   builder_.add_indptrType(indptrType);
   builder_.add_compressedAxis(compressedAxis);
   return builder_.Finish();
 }
@@ -326,312 +326,312 @@ inline flatbuffers::Offset<SparseMatrixIndexCSX> CreateSparseMatrixIndexCSX(
 struct SparseTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_TYPE_TYPE = 4,
     VT_TYPE = 6,
     VT_SHAPE = 8,
     VT_NON_ZERO_LENGTH = 10,
     VT_SPARSEINDEX_TYPE = 12,
     VT_SPARSEINDEX = 14,
     VT_DATA = 16
   };
-  org::apache::arrow::flatbuf::Type type_type() const {
-    return static_cast<org::apache::arrow::flatbuf::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
+  Type type_type() const {
+    return static_cast<Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
   }
   /// The type of data contained in a value cell.
   /// Currently only fixed-width value types are supported,
   /// no strings or nested types.
   const void *type() const {
     return GetPointer<const void *>(VT_TYPE);
   }
   template<typename T> const T *type_as() const;
-  const org::apache::arrow::flatbuf::Null *type_as_Null() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Null ? static_cast<const org::apache::arrow::flatbuf::Null *>(type()) : nullptr;
+  const Null *type_as_Null() const {
+    return type_type() == Type::Null ? static_cast<const Null *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Int *type_as_Int() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Int ? static_cast<const org::apache::arrow::flatbuf::Int *>(type()) : nullptr;
+  const Int *type_as_Int() const {
+    return type_type() == Type::Int ? static_cast<const Int *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::FloatingPoint *type_as_FloatingPoint() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_FloatingPoint ? static_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(type()) : nullptr;
+  const FloatingPoint *type_as_FloatingPoint() const {
+    return type_type() == Type::FloatingPoint ? static_cast<const FloatingPoint *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Binary *type_as_Binary() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Binary ? static_cast<const org::apache::arrow::flatbuf::Binary *>(type()) : nullptr;
+  const Binary *type_as_Binary() const {
+    return type_type() == Type::Binary ? static_cast<const Binary *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Utf8 *type_as_Utf8() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Utf8 ? static_cast<const org::apache::arrow::flatbuf::Utf8 *>(type()) : nullptr;
+  const Utf8 *type_as_Utf8() const {
+    return type_type() == Type::Utf8 ? static_cast<const Utf8 *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Bool *type_as_Bool() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Bool ? static_cast<const org::apache::arrow::flatbuf::Bool *>(type()) : nullptr;
+  const Bool *type_as_Bool() const {
+    return type_type() == Type::Bool ? static_cast<const Bool *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Decimal *type_as_Decimal() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Decimal ? static_cast<const org::apache::arrow::flatbuf::Decimal *>(type()) : nullptr;
+  const Decimal *type_as_Decimal() const {
+    return type_type() == Type::Decimal ? static_cast<const Decimal *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Date *type_as_Date() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Date ? static_cast<const org::apache::arrow::flatbuf::Date *>(type()) : nullptr;
+  const Date *type_as_Date() const {
+    return type_type() == Type::Date ? static_cast<const Date *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Time *type_as_Time() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Time ? static_cast<const org::apache::arrow::flatbuf::Time *>(type()) : nullptr;
+  const Time *type_as_Time() const {
+    return type_type() == Type::Time ? static_cast<const Time *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Timestamp *type_as_Timestamp() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Timestamp ? static_cast<const org::apache::arrow::flatbuf::Timestamp *>(type()) : nullptr;
+  const Timestamp *type_as_Timestamp() const {
+    return type_type() == Type::Timestamp ? static_cast<const Timestamp *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Interval *type_as_Interval() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Interval ? static_cast<const org::apache::arrow::flatbuf::Interval *>(type()) : nullptr;
+  const Interval *type_as_Interval() const {
+    return type_type() == Type::Interval ? static_cast<const Interval *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::List *type_as_List() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_List ? static_cast<const org::apache::arrow::flatbuf::List *>(type()) : nullptr;
+  const List *type_as_List() const {
+    return type_type() == Type::List ? static_cast<const List *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Struct_ *type_as_Struct_() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Struct_ ? static_cast<const org::apache::arrow::flatbuf::Struct_ *>(type()) : nullptr;
+  const Struct_ *type_as_Struct_() const {
+    return type_type() == Type::Struct_ ? static_cast<const Struct_ *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Union *type_as_Union() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Union ? static_cast<const org::apache::arrow::flatbuf::Union *>(type()) : nullptr;
+  const Union *type_as_Union() const {
+    return type_type() == Type::Union ? static_cast<const Union *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::FixedSizeBinary *type_as_FixedSizeBinary() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_FixedSizeBinary ? static_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(type()) : nullptr;
+  const FixedSizeBinary *type_as_FixedSizeBinary() const {
+    return type_type() == Type::FixedSizeBinary ? static_cast<const FixedSizeBinary *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::FixedSizeList *type_as_FixedSizeList() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_FixedSizeList ? static_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(type()) : nullptr;
+  const FixedSizeList *type_as_FixedSizeList() const {
+    return type_type() == Type::FixedSizeList ? static_cast<const FixedSizeList *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Map *type_as_Map() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Map ? static_cast<const org::apache::arrow::flatbuf::Map *>(type()) : nullptr;
+  const Map *type_as_Map() const {
+    return type_type() == Type::Map ? static_cast<const Map *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Duration *type_as_Duration() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Duration ? static_cast<const org::apache::arrow::flatbuf::Duration *>(type()) : nullptr;
+  const Duration *type_as_Duration() const {
+    return type_type() == Type::Duration ? static_cast<const Duration *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::LargeBinary *type_as_LargeBinary() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_LargeBinary ? static_cast<const org::apache::arrow::flatbuf::LargeBinary *>(type()) : nullptr;
+  const LargeBinary *type_as_LargeBinary() const {
+    return type_type() == Type::LargeBinary ? static_cast<const LargeBinary *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::LargeUtf8 *type_as_LargeUtf8() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_LargeUtf8 ? static_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(type()) : nullptr;
+  const LargeUtf8 *type_as_LargeUtf8() const {
+    return type_type() == Type::LargeUtf8 ? static_cast<const LargeUtf8 *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::LargeList *type_as_LargeList() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_LargeList ? static_cast<const org::apache::arrow::flatbuf::LargeList *>(type()) : nullptr;
+  const LargeList *type_as_LargeList() const {
+    return type_type() == Type::LargeList ? static_cast<const LargeList *>(type()) : nullptr;
   }
   /// The dimensions of the tensor, optionally named.
-  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>> *shape() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>> *>(VT_SHAPE);
+  const flatbuffers::Vector<flatbuffers::Offset<TensorDim>> *shape() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorDim>> *>(VT_SHAPE);
   }
   /// The number of non-zero values in a sparse tensor.
   int64_t non_zero_length() const {
     return GetField<int64_t>(VT_NON_ZERO_LENGTH, 0);
   }
-  org::apache::arrow::flatbuf::SparseTensorIndex sparseIndex_type() const {
-    return static_cast<org::apache::arrow::flatbuf::SparseTensorIndex>(GetField<uint8_t>(VT_SPARSEINDEX_TYPE, 0));
+  SparseTensorIndex sparseIndex_type() const {
+    return static_cast<SparseTensorIndex>(GetField<uint8_t>(VT_SPARSEINDEX_TYPE, 0));
   }
   /// Sparse tensor index
   const void *sparseIndex() const {
     return GetPointer<const void *>(VT_SPARSEINDEX);
   }
   template<typename T> const T *sparseIndex_as() const;
-  const org::apache::arrow::flatbuf::SparseTensorIndexCOO *sparseIndex_as_SparseTensorIndexCOO() const {
-    return sparseIndex_type() == org::apache::arrow::flatbuf::SparseTensorIndex_SparseTensorIndexCOO ? static_cast<const org::apache::arrow::flatbuf::SparseTensorIndexCOO *>(sparseIndex()) : nullptr;
+  const SparseTensorIndexCOO *sparseIndex_as_SparseTensorIndexCOO() const {
+    return sparseIndex_type() == SparseTensorIndex::SparseTensorIndexCOO ? static_cast<const SparseTensorIndexCOO *>(sparseIndex()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::SparseMatrixIndexCSX *sparseIndex_as_SparseMatrixIndexCSX() const {
-    return sparseIndex_type() == org::apache::arrow::flatbuf::SparseTensorIndex_SparseMatrixIndexCSX ? static_cast<const org::apache::arrow::flatbuf::SparseMatrixIndexCSX *>(sparseIndex()) : nullptr;
+  const SparseMatrixIndexCSX *sparseIndex_as_SparseMatrixIndexCSX() const {
+    return sparseIndex_type() == SparseTensorIndex::SparseMatrixIndexCSX ? static_cast<const SparseMatrixIndexCSX *>(sparseIndex()) : nullptr;
   }
   /// The location and size of the tensor's data
-  const org::apache::arrow::flatbuf::Buffer *data() const {
-    return GetStruct<const org::apache::arrow::flatbuf::Buffer *>(VT_DATA);
+  const Buffer *data() const {
+    return GetStruct<const Buffer *>(VT_DATA);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
            VerifyOffset(verifier, VT_TYPE) &&
            VerifyType(verifier, type(), type_type()) &&
            VerifyOffset(verifier, VT_SHAPE) &&
            verifier.VerifyVector(shape()) &&
            verifier.VerifyVectorOfTables(shape()) &&
            VerifyField<int64_t>(verifier, VT_NON_ZERO_LENGTH) &&
            VerifyField<uint8_t>(verifier, VT_SPARSEINDEX_TYPE) &&
            VerifyOffset(verifier, VT_SPARSEINDEX) &&
            VerifySparseTensorIndex(verifier, sparseIndex(), sparseIndex_type()) &&
-           VerifyField<org::apache::arrow::flatbuf::Buffer>(verifier, VT_DATA) &&
+           VerifyField<Buffer>(verifier, VT_DATA) &&
            verifier.EndTable();
   }
 };
 
-template<> inline const org::apache::arrow::flatbuf::Null *SparseTensor::type_as<org::apache::arrow::flatbuf::Null>() const {
+template<> inline const Null *SparseTensor::type_as<Null>() const {
   return type_as_Null();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Int *SparseTensor::type_as<org::apache::arrow::flatbuf::Int>() const {
+template<> inline const Int *SparseTensor::type_as<Int>() const {
   return type_as_Int();
 }
 
-template<> inline const org::apache::arrow::flatbuf::FloatingPoint *SparseTensor::type_as<org::apache::arrow::flatbuf::FloatingPoint>() const {
+template<> inline const FloatingPoint *SparseTensor::type_as<FloatingPoint>() const {
   return type_as_FloatingPoint();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Binary *SparseTensor::type_as<org::apache::arrow::flatbuf::Binary>() const {
+template<> inline const Binary *SparseTensor::type_as<Binary>() const {
   return type_as_Binary();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Utf8 *SparseTensor::type_as<org::apache::arrow::flatbuf::Utf8>() const {
+template<> inline const Utf8 *SparseTensor::type_as<Utf8>() const {
   return type_as_Utf8();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Bool *SparseTensor::type_as<org::apache::arrow::flatbuf::Bool>() const {
+template<> inline const Bool *SparseTensor::type_as<Bool>() const {
   return type_as_Bool();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Decimal *SparseTensor::type_as<org::apache::arrow::flatbuf::Decimal>() const {
+template<> inline const Decimal *SparseTensor::type_as<Decimal>() const {
   return type_as_Decimal();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Date *SparseTensor::type_as<org::apache::arrow::flatbuf::Date>() const {
+template<> inline const Date *SparseTensor::type_as<Date>() const {
   return type_as_Date();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Time *SparseTensor::type_as<org::apache::arrow::flatbuf::Time>() const {
+template<> inline const Time *SparseTensor::type_as<Time>() const {
   return type_as_Time();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Timestamp *SparseTensor::type_as<org::apache::arrow::flatbuf::Timestamp>() const {
+template<> inline const Timestamp *SparseTensor::type_as<Timestamp>() const {
   return type_as_Timestamp();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Interval *SparseTensor::type_as<org::apache::arrow::flatbuf::Interval>() const {
+template<> inline const Interval *SparseTensor::type_as<Interval>() const {
   return type_as_Interval();
 }
 
-template<> inline const org::apache::arrow::flatbuf::List *SparseTensor::type_as<org::apache::arrow::flatbuf::List>() const {
+template<> inline const List *SparseTensor::type_as<List>() const {
   return type_as_List();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Struct_ *SparseTensor::type_as<org::apache::arrow::flatbuf::Struct_>() const {
+template<> inline const Struct_ *SparseTensor::type_as<Struct_>() const {
   return type_as_Struct_();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Union *SparseTensor::type_as<org::apache::arrow::flatbuf::Union>() const {
+template<> inline const Union *SparseTensor::type_as<Union>() const {
   return type_as_Union();
 }
 
-template<> inline const org::apache::arrow::flatbuf::FixedSizeBinary *SparseTensor::type_as<org::apache::arrow::flatbuf::FixedSizeBinary>() const {
+template<> inline const FixedSizeBinary *SparseTensor::type_as<FixedSizeBinary>() const {
   return type_as_FixedSizeBinary();
 }
 
-template<> inline const org::apache::arrow::flatbuf::FixedSizeList *SparseTensor::type_as<org::apache::arrow::flatbuf::FixedSizeList>() const {
+template<> inline const FixedSizeList *SparseTensor::type_as<FixedSizeList>() const {
   return type_as_FixedSizeList();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Map *SparseTensor::type_as<org::apache::arrow::flatbuf::Map>() const {
+template<> inline const Map *SparseTensor::type_as<Map>() const {
   return type_as_Map();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Duration *SparseTensor::type_as<org::apache::arrow::flatbuf::Duration>() const {
+template<> inline const Duration *SparseTensor::type_as<Duration>() const {
   return type_as_Duration();
 }
 
-template<> inline const org::apache::arrow::flatbuf::LargeBinary *SparseTensor::type_as<org::apache::arrow::flatbuf::LargeBinary>() const {
+template<> inline const LargeBinary *SparseTensor::type_as<LargeBinary>() const {
   return type_as_LargeBinary();
 }
 
-template<> inline const org::apache::arrow::flatbuf::LargeUtf8 *SparseTensor::type_as<org::apache::arrow::flatbuf::LargeUtf8>() const {
+template<> inline const LargeUtf8 *SparseTensor::type_as<LargeUtf8>() const {
   return type_as_LargeUtf8();
 }
 
-template<> inline const org::apache::arrow::flatbuf::LargeList *SparseTensor::type_as<org::apache::arrow::flatbuf::LargeList>() const {
+template<> inline const LargeList *SparseTensor::type_as<LargeList>() const {
   return type_as_LargeList();
 }
 
-template<> inline const org::apache::arrow::flatbuf::SparseTensorIndexCOO *SparseTensor::sparseIndex_as<org::apache::arrow::flatbuf::SparseTensorIndexCOO>() const {
+template<> inline const SparseTensorIndexCOO *SparseTensor::sparseIndex_as<SparseTensorIndexCOO>() const {
   return sparseIndex_as_SparseTensorIndexCOO();
 }
 
-template<> inline const org::apache::arrow::flatbuf::SparseMatrixIndexCSX *SparseTensor::sparseIndex_as<org::apache::arrow::flatbuf::SparseMatrixIndexCSX>() const {
+template<> inline const SparseMatrixIndexCSX *SparseTensor::sparseIndex_as<SparseMatrixIndexCSX>() const {
   return sparseIndex_as_SparseMatrixIndexCSX();
 }
 
 struct SparseTensorBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_type_type(org::apache::arrow::flatbuf::Type type_type) {
+  void add_type_type(Type type_type) {
     fbb_.AddElement<uint8_t>(SparseTensor::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
   }
   void add_type(flatbuffers::Offset<void> type) {
     fbb_.AddOffset(SparseTensor::VT_TYPE, type);
   }
-  void add_shape(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>>> shape) {
+  void add_shape(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDim>>> shape) {
     fbb_.AddOffset(SparseTensor::VT_SHAPE, shape);
   }
   void add_non_zero_length(int64_t non_zero_length) {
     fbb_.AddElement<int64_t>(SparseTensor::VT_NON_ZERO_LENGTH, non_zero_length, 0);
   }
-  void add_sparseIndex_type(org::apache::arrow::flatbuf::SparseTensorIndex sparseIndex_type) {
+  void add_sparseIndex_type(SparseTensorIndex sparseIndex_type) {
     fbb_.AddElement<uint8_t>(SparseTensor::VT_SPARSEINDEX_TYPE, static_cast<uint8_t>(sparseIndex_type), 0);
   }
   void add_sparseIndex(flatbuffers::Offset<void> sparseIndex) {
     fbb_.AddOffset(SparseTensor::VT_SPARSEINDEX, sparseIndex);
   }
-  void add_data(const org::apache::arrow::flatbuf::Buffer *data) {
+  void add_data(const Buffer *data) {
     fbb_.AddStruct(SparseTensor::VT_DATA, data);
   }
   explicit SparseTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   SparseTensorBuilder &operator=(const SparseTensorBuilder &);
   flatbuffers::Offset<SparseTensor> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<SparseTensor>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<SparseTensor> CreateSparseTensor(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type_NONE,
+    Type type_type = Type::NONE,
     flatbuffers::Offset<void> type = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>>> shape = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDim>>> shape = 0,
     int64_t non_zero_length = 0,
-    org::apache::arrow::flatbuf::SparseTensorIndex sparseIndex_type = org::apache::arrow::flatbuf::SparseTensorIndex_NONE,
+    SparseTensorIndex sparseIndex_type = SparseTensorIndex::NONE,
     flatbuffers::Offset<void> sparseIndex = 0,
-    const org::apache::arrow::flatbuf::Buffer *data = 0) {
+    const Buffer *data = 0) {
   SparseTensorBuilder builder_(_fbb);
   builder_.add_non_zero_length(non_zero_length);
   builder_.add_data(data);
   builder_.add_sparseIndex(sparseIndex);
   builder_.add_shape(shape);
   builder_.add_type(type);
   builder_.add_sparseIndex_type(sparseIndex_type);
   builder_.add_type_type(type_type);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<SparseTensor> CreateSparseTensorDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type_NONE,
+    Type type_type = Type::NONE,
     flatbuffers::Offset<void> type = 0,
-    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>> *shape = nullptr,
+    const std::vector<flatbuffers::Offset<TensorDim>> *shape = nullptr,
     int64_t non_zero_length = 0,
-    org::apache::arrow::flatbuf::SparseTensorIndex sparseIndex_type = org::apache::arrow::flatbuf::SparseTensorIndex_NONE,
+    SparseTensorIndex sparseIndex_type = SparseTensorIndex::NONE,
     flatbuffers::Offset<void> sparseIndex = 0,
-    const org::apache::arrow::flatbuf::Buffer *data = 0) {
-  auto shape__ = shape ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>>(*shape) : 0;
+    const Buffer *data = 0) {
+  auto shape__ = shape ? _fbb.CreateVector<flatbuffers::Offset<TensorDim>>(*shape) : 0;
   return org::apache::arrow::flatbuf::CreateSparseTensor(
       _fbb,
       type_type,
       type,
       shape__,
       non_zero_length,
       sparseIndex_type,
       sparseIndex,
       data);
 }
 
 inline bool VerifySparseTensorIndex(flatbuffers::Verifier &verifier, const void *obj, SparseTensorIndex type) {
   switch (type) {
-    case SparseTensorIndex_NONE: {
+    case SparseTensorIndex::NONE: {
       return true;
     }
-    case SparseTensorIndex_SparseTensorIndexCOO: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::SparseTensorIndexCOO *>(obj);
+    case SparseTensorIndex::SparseTensorIndexCOO: {
+      auto ptr = reinterpret_cast<const SparseTensorIndexCOO *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case SparseTensorIndex_SparseMatrixIndexCSX: {
-      auto ptr = reinterpret_cast<const org::apache::arrow::flatbuf::SparseMatrixIndexCSX *>(obj);
+    case SparseTensorIndex::SparseMatrixIndexCSX: {
+      auto ptr = reinterpret_cast<const SparseMatrixIndexCSX *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    default: return true;
+    default: return false;
   }
 }
 
diff --git a/cpp/src/generated/Tensor_generated.h b/cpp/src/generated/Tensor_generated.h
index 8d575d467..99b254238 100644
--- a/cpp/src/generated/Tensor_generated.h
+++ b/cpp/src/generated/Tensor_generated.h
@@ -87,254 +87,254 @@ inline flatbuffers::Offset<TensorDim> CreateTensorDimDirect(
 struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_TYPE_TYPE = 4,
     VT_TYPE = 6,
     VT_SHAPE = 8,
     VT_STRIDES = 10,
     VT_DATA = 12
   };
-  org::apache::arrow::flatbuf::Type type_type() const {
-    return static_cast<org::apache::arrow::flatbuf::Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
+  Type type_type() const {
+    return static_cast<Type>(GetField<uint8_t>(VT_TYPE_TYPE, 0));
   }
   /// The type of data contained in a value cell. Currently only fixed-width
   /// value types are supported, no strings or nested types
   const void *type() const {
     return GetPointer<const void *>(VT_TYPE);
   }
   template<typename T> const T *type_as() const;
-  const org::apache::arrow::flatbuf::Null *type_as_Null() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Null ? static_cast<const org::apache::arrow::flatbuf::Null *>(type()) : nullptr;
+  const Null *type_as_Null() const {
+    return type_type() == Type::Null ? static_cast<const Null *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Int *type_as_Int() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Int ? static_cast<const org::apache::arrow::flatbuf::Int *>(type()) : nullptr;
+  const Int *type_as_Int() const {
+    return type_type() == Type::Int ? static_cast<const Int *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::FloatingPoint *type_as_FloatingPoint() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_FloatingPoint ? static_cast<const org::apache::arrow::flatbuf::FloatingPoint *>(type()) : nullptr;
+  const FloatingPoint *type_as_FloatingPoint() const {
+    return type_type() == Type::FloatingPoint ? static_cast<const FloatingPoint *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Binary *type_as_Binary() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Binary ? static_cast<const org::apache::arrow::flatbuf::Binary *>(type()) : nullptr;
+  const Binary *type_as_Binary() const {
+    return type_type() == Type::Binary ? static_cast<const Binary *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Utf8 *type_as_Utf8() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Utf8 ? static_cast<const org::apache::arrow::flatbuf::Utf8 *>(type()) : nullptr;
+  const Utf8 *type_as_Utf8() const {
+    return type_type() == Type::Utf8 ? static_cast<const Utf8 *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Bool *type_as_Bool() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Bool ? static_cast<const org::apache::arrow::flatbuf::Bool *>(type()) : nullptr;
+  const Bool *type_as_Bool() const {
+    return type_type() == Type::Bool ? static_cast<const Bool *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Decimal *type_as_Decimal() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Decimal ? static_cast<const org::apache::arrow::flatbuf::Decimal *>(type()) : nullptr;
+  const Decimal *type_as_Decimal() const {
+    return type_type() == Type::Decimal ? static_cast<const Decimal *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Date *type_as_Date() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Date ? static_cast<const org::apache::arrow::flatbuf::Date *>(type()) : nullptr;
+  const Date *type_as_Date() const {
+    return type_type() == Type::Date ? static_cast<const Date *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Time *type_as_Time() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Time ? static_cast<const org::apache::arrow::flatbuf::Time *>(type()) : nullptr;
+  const Time *type_as_Time() const {
+    return type_type() == Type::Time ? static_cast<const Time *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Timestamp *type_as_Timestamp() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Timestamp ? static_cast<const org::apache::arrow::flatbuf::Timestamp *>(type()) : nullptr;
+  const Timestamp *type_as_Timestamp() const {
+    return type_type() == Type::Timestamp ? static_cast<const Timestamp *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Interval *type_as_Interval() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Interval ? static_cast<const org::apache::arrow::flatbuf::Interval *>(type()) : nullptr;
+  const Interval *type_as_Interval() const {
+    return type_type() == Type::Interval ? static_cast<const Interval *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::List *type_as_List() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_List ? static_cast<const org::apache::arrow::flatbuf::List *>(type()) : nullptr;
+  const List *type_as_List() const {
+    return type_type() == Type::List ? static_cast<const List *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Struct_ *type_as_Struct_() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Struct_ ? static_cast<const org::apache::arrow::flatbuf::Struct_ *>(type()) : nullptr;
+  const Struct_ *type_as_Struct_() const {
+    return type_type() == Type::Struct_ ? static_cast<const Struct_ *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Union *type_as_Union() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Union ? static_cast<const org::apache::arrow::flatbuf::Union *>(type()) : nullptr;
+  const Union *type_as_Union() const {
+    return type_type() == Type::Union ? static_cast<const Union *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::FixedSizeBinary *type_as_FixedSizeBinary() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_FixedSizeBinary ? static_cast<const org::apache::arrow::flatbuf::FixedSizeBinary *>(type()) : nullptr;
+  const FixedSizeBinary *type_as_FixedSizeBinary() const {
+    return type_type() == Type::FixedSizeBinary ? static_cast<const FixedSizeBinary *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::FixedSizeList *type_as_FixedSizeList() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_FixedSizeList ? static_cast<const org::apache::arrow::flatbuf::FixedSizeList *>(type()) : nullptr;
+  const FixedSizeList *type_as_FixedSizeList() const {
+    return type_type() == Type::FixedSizeList ? static_cast<const FixedSizeList *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Map *type_as_Map() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Map ? static_cast<const org::apache::arrow::flatbuf::Map *>(type()) : nullptr;
+  const Map *type_as_Map() const {
+    return type_type() == Type::Map ? static_cast<const Map *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::Duration *type_as_Duration() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_Duration ? static_cast<const org::apache::arrow::flatbuf::Duration *>(type()) : nullptr;
+  const Duration *type_as_Duration() const {
+    return type_type() == Type::Duration ? static_cast<const Duration *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::LargeBinary *type_as_LargeBinary() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_LargeBinary ? static_cast<const org::apache::arrow::flatbuf::LargeBinary *>(type()) : nullptr;
+  const LargeBinary *type_as_LargeBinary() const {
+    return type_type() == Type::LargeBinary ? static_cast<const LargeBinary *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::LargeUtf8 *type_as_LargeUtf8() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_LargeUtf8 ? static_cast<const org::apache::arrow::flatbuf::LargeUtf8 *>(type()) : nullptr;
+  const LargeUtf8 *type_as_LargeUtf8() const {
+    return type_type() == Type::LargeUtf8 ? static_cast<const LargeUtf8 *>(type()) : nullptr;
   }
-  const org::apache::arrow::flatbuf::LargeList *type_as_LargeList() const {
-    return type_type() == org::apache::arrow::flatbuf::Type_LargeList ? static_cast<const org::apache::arrow::flatbuf::LargeList *>(type()) : nullptr;
+  const LargeList *type_as_LargeList() const {
+    return type_type() == Type::LargeList ? static_cast<const LargeList *>(type()) : nullptr;
   }
   /// The dimensions of the tensor, optionally named
-  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>> *shape() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>> *>(VT_SHAPE);
+  const flatbuffers::Vector<flatbuffers::Offset<TensorDim>> *shape() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TensorDim>> *>(VT_SHAPE);
   }
   /// Non-negative byte offsets to advance one value cell along each dimension
   const flatbuffers::Vector<int64_t> *strides() const {
     return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
   }
   /// The location and size of the tensor's data
-  const org::apache::arrow::flatbuf::Buffer *data() const {
-    return GetStruct<const org::apache::arrow::flatbuf::Buffer *>(VT_DATA);
+  const Buffer *data() const {
+    return GetStruct<const Buffer *>(VT_DATA);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<uint8_t>(verifier, VT_TYPE_TYPE) &&
            VerifyOffset(verifier, VT_TYPE) &&
            VerifyType(verifier, type(), type_type()) &&
            VerifyOffset(verifier, VT_SHAPE) &&
            verifier.VerifyVector(shape()) &&
            verifier.VerifyVectorOfTables(shape()) &&
            VerifyOffset(verifier, VT_STRIDES) &&
            verifier.VerifyVector(strides()) &&
-           VerifyField<org::apache::arrow::flatbuf::Buffer>(verifier, VT_DATA) &&
+           VerifyField<Buffer>(verifier, VT_DATA) &&
            verifier.EndTable();
   }
 };
 
-template<> inline const org::apache::arrow::flatbuf::Null *Tensor::type_as<org::apache::arrow::flatbuf::Null>() const {
+template<> inline const Null *Tensor::type_as<Null>() const {
   return type_as_Null();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Int *Tensor::type_as<org::apache::arrow::flatbuf::Int>() const {
+template<> inline const Int *Tensor::type_as<Int>() const {
   return type_as_Int();
 }
 
-template<> inline const org::apache::arrow::flatbuf::FloatingPoint *Tensor::type_as<org::apache::arrow::flatbuf::FloatingPoint>() const {
+template<> inline const FloatingPoint *Tensor::type_as<FloatingPoint>() const {
   return type_as_FloatingPoint();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Binary *Tensor::type_as<org::apache::arrow::flatbuf::Binary>() const {
+template<> inline const Binary *Tensor::type_as<Binary>() const {
   return type_as_Binary();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Utf8 *Tensor::type_as<org::apache::arrow::flatbuf::Utf8>() const {
+template<> inline const Utf8 *Tensor::type_as<Utf8>() const {
   return type_as_Utf8();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Bool *Tensor::type_as<org::apache::arrow::flatbuf::Bool>() const {
+template<> inline const Bool *Tensor::type_as<Bool>() const {
   return type_as_Bool();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Decimal *Tensor::type_as<org::apache::arrow::flatbuf::Decimal>() const {
+template<> inline const Decimal *Tensor::type_as<Decimal>() const {
   return type_as_Decimal();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Date *Tensor::type_as<org::apache::arrow::flatbuf::Date>() const {
+template<> inline const Date *Tensor::type_as<Date>() const {
   return type_as_Date();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Time *Tensor::type_as<org::apache::arrow::flatbuf::Time>() const {
+template<> inline const Time *Tensor::type_as<Time>() const {
   return type_as_Time();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Timestamp *Tensor::type_as<org::apache::arrow::flatbuf::Timestamp>() const {
+template<> inline const Timestamp *Tensor::type_as<Timestamp>() const {
   return type_as_Timestamp();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Interval *Tensor::type_as<org::apache::arrow::flatbuf::Interval>() const {
+template<> inline const Interval *Tensor::type_as<Interval>() const {
   return type_as_Interval();
 }
 
-template<> inline const org::apache::arrow::flatbuf::List *Tensor::type_as<org::apache::arrow::flatbuf::List>() const {
+template<> inline const List *Tensor::type_as<List>() const {
   return type_as_List();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Struct_ *Tensor::type_as<org::apache::arrow::flatbuf::Struct_>() const {
+template<> inline const Struct_ *Tensor::type_as<Struct_>() const {
   return type_as_Struct_();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Union *Tensor::type_as<org::apache::arrow::flatbuf::Union>() const {
+template<> inline const Union *Tensor::type_as<Union>() const {
   return type_as_Union();
 }
 
-template<> inline const org::apache::arrow::flatbuf::FixedSizeBinary *Tensor::type_as<org::apache::arrow::flatbuf::FixedSizeBinary>() const {
+template<> inline const FixedSizeBinary *Tensor::type_as<FixedSizeBinary>() const {
   return type_as_FixedSizeBinary();
 }
 
-template<> inline const org::apache::arrow::flatbuf::FixedSizeList *Tensor::type_as<org::apache::arrow::flatbuf::FixedSizeList>() const {
+template<> inline const FixedSizeList *Tensor::type_as<FixedSizeList>() const {
   return type_as_FixedSizeList();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Map *Tensor::type_as<org::apache::arrow::flatbuf::Map>() const {
+template<> inline const Map *Tensor::type_as<Map>() const {
   return type_as_Map();
 }
 
-template<> inline const org::apache::arrow::flatbuf::Duration *Tensor::type_as<org::apache::arrow::flatbuf::Duration>() const {
+template<> inline const Duration *Tensor::type_as<Duration>() const {
   return type_as_Duration();
 }
 
-template<> inline const org::apache::arrow::flatbuf::LargeBinary *Tensor::type_as<org::apache::arrow::flatbuf::LargeBinary>() const {
+template<> inline const LargeBinary *Tensor::type_as<LargeBinary>() const {
   return type_as_LargeBinary();
 }
 
-template<> inline const org::apache::arrow::flatbuf::LargeUtf8 *Tensor::type_as<org::apache::arrow::flatbuf::LargeUtf8>() const {
+template<> inline const LargeUtf8 *Tensor::type_as<LargeUtf8>() const {
   return type_as_LargeUtf8();
 }
 
-template<> inline const org::apache::arrow::flatbuf::LargeList *Tensor::type_as<org::apache::arrow::flatbuf::LargeList>() const {
+template<> inline const LargeList *Tensor::type_as<LargeList>() const {
   return type_as_LargeList();
 }
 
 struct TensorBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_type_type(org::apache::arrow::flatbuf::Type type_type) {
+  void add_type_type(Type type_type) {
     fbb_.AddElement<uint8_t>(Tensor::VT_TYPE_TYPE, static_cast<uint8_t>(type_type), 0);
   }
   void add_type(flatbuffers::Offset<void> type) {
     fbb_.AddOffset(Tensor::VT_TYPE, type);
   }
-  void add_shape(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>>> shape) {
+  void add_shape(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDim>>> shape) {
     fbb_.AddOffset(Tensor::VT_SHAPE, shape);
   }
   void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
     fbb_.AddOffset(Tensor::VT_STRIDES, strides);
   }
-  void add_data(const org::apache::arrow::flatbuf::Buffer *data) {
+  void add_data(const Buffer *data) {
     fbb_.AddStruct(Tensor::VT_DATA, data);
   }
   explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   TensorBuilder &operator=(const TensorBuilder &);
   flatbuffers::Offset<Tensor> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Tensor>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<Tensor> CreateTensor(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type_NONE,
+    Type type_type = Type::NONE,
     flatbuffers::Offset<void> type = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>>> shape = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TensorDim>>> shape = 0,
     flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
-    const org::apache::arrow::flatbuf::Buffer *data = 0) {
+    const Buffer *data = 0) {
   TensorBuilder builder_(_fbb);
   builder_.add_data(data);
   builder_.add_strides(strides);
   builder_.add_shape(shape);
   builder_.add_type(type);
   builder_.add_type_type(type_type);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<Tensor> CreateTensorDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    org::apache::arrow::flatbuf::Type type_type = org::apache::arrow::flatbuf::Type_NONE,
+    Type type_type = Type::NONE,
     flatbuffers::Offset<void> type = 0,
-    const std::vector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>> *shape = nullptr,
+    const std::vector<flatbuffers::Offset<TensorDim>> *shape = nullptr,
     const std::vector<int64_t> *strides = nullptr,
-    const org::apache::arrow::flatbuf::Buffer *data = 0) {
-  auto shape__ = shape ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::flatbuf::TensorDim>>(*shape) : 0;
+    const Buffer *data = 0) {
+  auto shape__ = shape ? _fbb.CreateVector<flatbuffers::Offset<TensorDim>>(*shape) : 0;
   auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
   return org::apache::arrow::flatbuf::CreateTensor(
       _fbb,
       type_type,
       type,
       shape__,
       strides__,
       data);
 }
diff --git a/cpp/src/generated/feather_generated.h b/cpp/src/generated/feather_generated.h
index f2c54ff0d..23fd6dc15 100644
--- a/cpp/src/generated/feather_generated.h
+++ b/cpp/src/generated/feather_generated.h
@@ -28,219 +28,219 @@ struct CTable;
 /// Feather is an experimental serialization format implemented using
 /// techniques from Apache Arrow. It was created as a proof-of-concept of an
 /// interoperable file format for storing data frames originating in Python or
 /// R. It enabled the developers to sidestep some of the open design questions
 /// in Arrow from early 2016 and instead create something simple and useful for
 /// the intended use cases.
-enum Type {
-  Type_BOOL = 0,
-  Type_INT8 = 1,
-  Type_INT16 = 2,
-  Type_INT32 = 3,
-  Type_INT64 = 4,
-  Type_UINT8 = 5,
-  Type_UINT16 = 6,
-  Type_UINT32 = 7,
-  Type_UINT64 = 8,
-  Type_FLOAT = 9,
-  Type_DOUBLE = 10,
-  Type_UTF8 = 11,
-  Type_BINARY = 12,
-  Type_CATEGORY = 13,
-  Type_TIMESTAMP = 14,
-  Type_DATE = 15,
-  Type_TIME = 16,
-  Type_LARGE_UTF8 = 17,
-  Type_LARGE_BINARY = 18,
-  Type_MIN = Type_BOOL,
-  Type_MAX = Type_LARGE_BINARY
+enum class Type : int8_t {
+  BOOL = 0,
+  INT8 = 1,
+  INT16 = 2,
+  INT32 = 3,
+  INT64 = 4,
+  UINT8 = 5,
+  UINT16 = 6,
+  UINT32 = 7,
+  UINT64 = 8,
+  FLOAT = 9,
+  DOUBLE = 10,
+  UTF8 = 11,
+  BINARY = 12,
+  CATEGORY = 13,
+  TIMESTAMP = 14,
+  DATE = 15,
+  TIME = 16,
+  LARGE_UTF8 = 17,
+  LARGE_BINARY = 18,
+  MIN = BOOL,
+  MAX = LARGE_BINARY
 };
 
 inline const Type (&EnumValuesType())[19] {
   static const Type values[] = {
-    Type_BOOL,
-    Type_INT8,
-    Type_INT16,
-    Type_INT32,
-    Type_INT64,
-    Type_UINT8,
-    Type_UINT16,
-    Type_UINT32,
-    Type_UINT64,
-    Type_FLOAT,
-    Type_DOUBLE,
-    Type_UTF8,
-    Type_BINARY,
-    Type_CATEGORY,
-    Type_TIMESTAMP,
-    Type_DATE,
-    Type_TIME,
-    Type_LARGE_UTF8,
-    Type_LARGE_BINARY
+    Type::BOOL,
+    Type::INT8,
+    Type::INT16,
+    Type::INT32,
+    Type::INT64,
+    Type::UINT8,
+    Type::UINT16,
+    Type::UINT32,
+    Type::UINT64,
+    Type::FLOAT,
+    Type::DOUBLE,
+    Type::UTF8,
+    Type::BINARY,
+    Type::CATEGORY,
+    Type::TIMESTAMP,
+    Type::DATE,
+    Type::TIME,
+    Type::LARGE_UTF8,
+    Type::LARGE_BINARY
   };
   return values;
 }
 
 inline const char * const *EnumNamesType() {
-  static const char * const names[20] = {
+  static const char * const names[] = {
     "BOOL",
     "INT8",
     "INT16",
     "INT32",
     "INT64",
     "UINT8",
     "UINT16",
     "UINT32",
     "UINT64",
     "FLOAT",
     "DOUBLE",
     "UTF8",
     "BINARY",
     "CATEGORY",
     "TIMESTAMP",
     "DATE",
     "TIME",
     "LARGE_UTF8",
     "LARGE_BINARY",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameType(Type e) {
-  if (e < Type_BOOL || e > Type_LARGE_BINARY) return "";
+  if (e < Type::BOOL || e > Type::LARGE_BINARY) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesType()[index];
 }
 
-enum Encoding {
-  Encoding_PLAIN = 0,
-  /// Data is stored dictionary-encoded
+enum class Encoding : int8_t {
+  PLAIN = 0  /// Data is stored dictionary-encoded
   /// dictionary size: <INT32 Dictionary size>
   /// dictionary data: <TYPE primitive array>
   /// dictionary index: <INT32 primitive array>
   ///
   /// TODO: do we care about storing the index values in a smaller typeclass
-  Encoding_DICTIONARY = 1,
-  Encoding_MIN = Encoding_PLAIN,
-  Encoding_MAX = Encoding_DICTIONARY
+,
+  DICTIONARY = 1,
+  MIN = PLAIN,
+  MAX = DICTIONARY
 };
 
 inline const Encoding (&EnumValuesEncoding())[2] {
   static const Encoding values[] = {
-    Encoding_PLAIN,
-    Encoding_DICTIONARY
+    Encoding::PLAIN,
+    Encoding::DICTIONARY
   };
   return values;
 }
 
 inline const char * const *EnumNamesEncoding() {
-  static const char * const names[3] = {
+  static const char * const names[] = {
     "PLAIN",
     "DICTIONARY",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameEncoding(Encoding e) {
-  if (e < Encoding_PLAIN || e > Encoding_DICTIONARY) return "";
+  if (e < Encoding::PLAIN || e > Encoding::DICTIONARY) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesEncoding()[index];
 }
 
-enum TimeUnit {
-  TimeUnit_SECOND = 0,
-  TimeUnit_MILLISECOND = 1,
-  TimeUnit_MICROSECOND = 2,
-  TimeUnit_NANOSECOND = 3,
-  TimeUnit_MIN = TimeUnit_SECOND,
-  TimeUnit_MAX = TimeUnit_NANOSECOND
+enum class TimeUnit : int8_t {
+  SECOND = 0,
+  MILLISECOND = 1,
+  MICROSECOND = 2,
+  NANOSECOND = 3,
+  MIN = SECOND,
+  MAX = NANOSECOND
 };
 
 inline const TimeUnit (&EnumValuesTimeUnit())[4] {
   static const TimeUnit values[] = {
-    TimeUnit_SECOND,
-    TimeUnit_MILLISECOND,
-    TimeUnit_MICROSECOND,
-    TimeUnit_NANOSECOND
+    TimeUnit::SECOND,
+    TimeUnit::MILLISECOND,
+    TimeUnit::MICROSECOND,
+    TimeUnit::NANOSECOND
   };
   return values;
 }
 
 inline const char * const *EnumNamesTimeUnit() {
-  static const char * const names[5] = {
+  static const char * const names[] = {
     "SECOND",
     "MILLISECOND",
     "MICROSECOND",
     "NANOSECOND",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameTimeUnit(TimeUnit e) {
-  if (e < TimeUnit_SECOND || e > TimeUnit_NANOSECOND) return "";
+  if (e < TimeUnit::SECOND || e > TimeUnit::NANOSECOND) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesTimeUnit()[index];
 }
 
-enum TypeMetadata {
-  TypeMetadata_NONE = 0,
-  TypeMetadata_CategoryMetadata = 1,
-  TypeMetadata_TimestampMetadata = 2,
-  TypeMetadata_DateMetadata = 3,
-  TypeMetadata_TimeMetadata = 4,
-  TypeMetadata_MIN = TypeMetadata_NONE,
-  TypeMetadata_MAX = TypeMetadata_TimeMetadata
+enum class TypeMetadata : uint8_t {
+  NONE = 0,
+  CategoryMetadata = 1,
+  TimestampMetadata = 2,
+  DateMetadata = 3,
+  TimeMetadata = 4,
+  MIN = NONE,
+  MAX = TimeMetadata
 };
 
 inline const TypeMetadata (&EnumValuesTypeMetadata())[5] {
   static const TypeMetadata values[] = {
-    TypeMetadata_NONE,
-    TypeMetadata_CategoryMetadata,
-    TypeMetadata_TimestampMetadata,
-    TypeMetadata_DateMetadata,
-    TypeMetadata_TimeMetadata
+    TypeMetadata::NONE,
+    TypeMetadata::CategoryMetadata,
+    TypeMetadata::TimestampMetadata,
+    TypeMetadata::DateMetadata,
+    TypeMetadata::TimeMetadata
   };
   return values;
 }
 
 inline const char * const *EnumNamesTypeMetadata() {
-  static const char * const names[6] = {
+  static const char * const names[] = {
     "NONE",
     "CategoryMetadata",
     "TimestampMetadata",
     "DateMetadata",
     "TimeMetadata",
     nullptr
   };
   return names;
 }
 
 inline const char *EnumNameTypeMetadata(TypeMetadata e) {
-  if (e < TypeMetadata_NONE || e > TypeMetadata_TimeMetadata) return "";
+  if (e < TypeMetadata::NONE || e > TypeMetadata::TimeMetadata) return "";
   const size_t index = static_cast<size_t>(e);
   return EnumNamesTypeMetadata()[index];
 }
 
 template<typename T> struct TypeMetadataTraits {
-  static const TypeMetadata enum_value = TypeMetadata_NONE;
+  static const TypeMetadata enum_value = TypeMetadata::NONE;
 };
 
-template<> struct TypeMetadataTraits<arrow::ipc::feather::fbs::CategoryMetadata> {
-  static const TypeMetadata enum_value = TypeMetadata_CategoryMetadata;
+template<> struct TypeMetadataTraits<CategoryMetadata> {
+  static const TypeMetadata enum_value = TypeMetadata::CategoryMetadata;
 };
 
-template<> struct TypeMetadataTraits<arrow::ipc::feather::fbs::TimestampMetadata> {
-  static const TypeMetadata enum_value = TypeMetadata_TimestampMetadata;
+template<> struct TypeMetadataTraits<TimestampMetadata> {
+  static const TypeMetadata enum_value = TypeMetadata::TimestampMetadata;
 };
 
-template<> struct TypeMetadataTraits<arrow::ipc::feather::fbs::DateMetadata> {
-  static const TypeMetadata enum_value = TypeMetadata_DateMetadata;
+template<> struct TypeMetadataTraits<DateMetadata> {
+  static const TypeMetadata enum_value = TypeMetadata::DateMetadata;
 };
 
-template<> struct TypeMetadataTraits<arrow::ipc::feather::fbs::TimeMetadata> {
-  static const TypeMetadata enum_value = TypeMetadata_TimeMetadata;
+template<> struct TypeMetadataTraits<TimeMetadata> {
+  static const TypeMetadata enum_value = TypeMetadata::TimeMetadata;
 };
 
 bool VerifyTypeMetadata(flatbuffers::Verifier &verifier, const void *obj, TypeMetadata type);
@@ -249,43 +249,43 @@ bool VerifyTypeMetadataVector(flatbuffers::Verifier &verifier, const flatbuffers
 struct PrimitiveArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_TYPE = 4,
     VT_ENCODING = 6,
     VT_OFFSET = 8,
     VT_LENGTH = 10,
     VT_NULL_COUNT = 12,
     VT_TOTAL_BYTES = 14
   };
-  arrow::ipc::feather::fbs::Type type() const {
-    return static_cast<arrow::ipc::feather::fbs::Type>(GetField<int8_t>(VT_TYPE, 0));
+  Type type() const {
+    return static_cast<Type>(GetField<int8_t>(VT_TYPE, 0));
   }
-  arrow::ipc::feather::fbs::Encoding encoding() const {
-    return static_cast<arrow::ipc::feather::fbs::Encoding>(GetField<int8_t>(VT_ENCODING, 0));
+  Encoding encoding() const {
+    return static_cast<Encoding>(GetField<int8_t>(VT_ENCODING, 0));
   }
   /// Relative memory offset of the start of the array data excluding the size
   /// of the metadata
   int64_t offset() const {
     return GetField<int64_t>(VT_OFFSET, 0);
   }
   /// The number of logical values in the array
   int64_t length() const {
     return GetField<int64_t>(VT_LENGTH, 0);
   }
   /// The number of observed nulls
   int64_t null_count() const {
     return GetField<int64_t>(VT_NULL_COUNT, 0);
   }
   /// The total size of the actual data in the file
   int64_t total_bytes() const {
     return GetField<int64_t>(VT_TOTAL_BYTES, 0);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int8_t>(verifier, VT_TYPE) &&
            VerifyField<int8_t>(verifier, VT_ENCODING) &&
            VerifyField<int64_t>(verifier, VT_OFFSET) &&
            VerifyField<int64_t>(verifier, VT_LENGTH) &&
            VerifyField<int64_t>(verifier, VT_NULL_COUNT) &&
            VerifyField<int64_t>(verifier, VT_TOTAL_BYTES) &&
            verifier.EndTable();
   }
 };
@@ -293,50 +293,50 @@ struct PrimitiveArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct PrimitiveArrayBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_type(arrow::ipc::feather::fbs::Type type) {
+  void add_type(Type type) {
     fbb_.AddElement<int8_t>(PrimitiveArray::VT_TYPE, static_cast<int8_t>(type), 0);
   }
-  void add_encoding(arrow::ipc::feather::fbs::Encoding encoding) {
+  void add_encoding(Encoding encoding) {
     fbb_.AddElement<int8_t>(PrimitiveArray::VT_ENCODING, static_cast<int8_t>(encoding), 0);
   }
   void add_offset(int64_t offset) {
     fbb_.AddElement<int64_t>(PrimitiveArray::VT_OFFSET, offset, 0);
   }
   void add_length(int64_t length) {
     fbb_.AddElement<int64_t>(PrimitiveArray::VT_LENGTH, length, 0);
   }
   void add_null_count(int64_t null_count) {
     fbb_.AddElement<int64_t>(PrimitiveArray::VT_NULL_COUNT, null_count, 0);
   }
   void add_total_bytes(int64_t total_bytes) {
     fbb_.AddElement<int64_t>(PrimitiveArray::VT_TOTAL_BYTES, total_bytes, 0);
   }
   explicit PrimitiveArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PrimitiveArrayBuilder &operator=(const PrimitiveArrayBuilder &);
   flatbuffers::Offset<PrimitiveArray> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PrimitiveArray>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<PrimitiveArray> CreatePrimitiveArray(
     flatbuffers::FlatBufferBuilder &_fbb,
-    arrow::ipc::feather::fbs::Type type = arrow::ipc::feather::fbs::Type_BOOL,
-    arrow::ipc::feather::fbs::Encoding encoding = arrow::ipc::feather::fbs::Encoding_PLAIN,
+    Type type = Type::BOOL,
+    Encoding encoding = Encoding::PLAIN,
     int64_t offset = 0,
     int64_t length = 0,
     int64_t null_count = 0,
     int64_t total_bytes = 0) {
   PrimitiveArrayBuilder builder_(_fbb);
   builder_.add_total_bytes(total_bytes);
   builder_.add_null_count(null_count);
   builder_.add_length(length);
   builder_.add_offset(offset);
   builder_.add_encoding(encoding);
   builder_.add_type(type);
   return builder_.Finish();
 }
@@ -344,21 +344,21 @@ inline flatbuffers::Offset<PrimitiveArray> CreatePrimitiveArray(
 struct CategoryMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_LEVELS = 4,
     VT_ORDERED = 6
   };
   /// The category codes are presumed to be integers that are valid indexes into
   /// the levels array
-  const arrow::ipc::feather::fbs::PrimitiveArray *levels() const {
-    return GetPointer<const arrow::ipc::feather::fbs::PrimitiveArray *>(VT_LEVELS);
+  const PrimitiveArray *levels() const {
+    return GetPointer<const PrimitiveArray *>(VT_LEVELS);
   }
   bool ordered() const {
     return GetField<uint8_t>(VT_ORDERED, 0) != 0;
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_LEVELS) &&
            verifier.VerifyTable(levels()) &&
            VerifyField<uint8_t>(verifier, VT_ORDERED) &&
            verifier.EndTable();
   }
 };
@@ -366,30 +366,30 @@ struct CategoryMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct CategoryMetadataBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_levels(flatbuffers::Offset<arrow::ipc::feather::fbs::PrimitiveArray> levels) {
+  void add_levels(flatbuffers::Offset<PrimitiveArray> levels) {
     fbb_.AddOffset(CategoryMetadata::VT_LEVELS, levels);
   }
   void add_ordered(bool ordered) {
     fbb_.AddElement<uint8_t>(CategoryMetadata::VT_ORDERED, static_cast<uint8_t>(ordered), 0);
   }
   explicit CategoryMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   CategoryMetadataBuilder &operator=(const CategoryMetadataBuilder &);
   flatbuffers::Offset<CategoryMetadata> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<CategoryMetadata>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<CategoryMetadata> CreateCategoryMetadata(
     flatbuffers::FlatBufferBuilder &_fbb,
-    flatbuffers::Offset<arrow::ipc::feather::fbs::PrimitiveArray> levels = 0,
+    flatbuffers::Offset<PrimitiveArray> levels = 0,
     bool ordered = false) {
   CategoryMetadataBuilder builder_(_fbb);
   builder_.add_levels(levels);
   builder_.add_ordered(ordered);
   return builder_.Finish();
 }
@@ -397,21 +397,21 @@ inline flatbuffers::Offset<CategoryMetadata> CreateCategoryMetadata(
 struct TimestampMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_UNIT = 4,
     VT_TIMEZONE = 6
   };
-  arrow::ipc::feather::fbs::TimeUnit unit() const {
-    return static_cast<arrow::ipc::feather::fbs::TimeUnit>(GetField<int8_t>(VT_UNIT, 0));
+  TimeUnit unit() const {
+    return static_cast<TimeUnit>(GetField<int8_t>(VT_UNIT, 0));
   }
   /// Timestamp data is assumed to be UTC, but the time zone is stored here for
   /// presentation as localized
   const flatbuffers::String *timezone() const {
     return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int8_t>(verifier, VT_UNIT) &&
            VerifyOffset(verifier, VT_TIMEZONE) &&
            verifier.VerifyString(timezone()) &&
            verifier.EndTable();
   }
 };
@@ -419,41 +419,41 @@ struct TimestampMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct TimestampMetadataBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_unit(arrow::ipc::feather::fbs::TimeUnit unit) {
+  void add_unit(TimeUnit unit) {
     fbb_.AddElement<int8_t>(TimestampMetadata::VT_UNIT, static_cast<int8_t>(unit), 0);
   }
   void add_timezone(flatbuffers::Offset<flatbuffers::String> timezone) {
     fbb_.AddOffset(TimestampMetadata::VT_TIMEZONE, timezone);
   }
   explicit TimestampMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   TimestampMetadataBuilder &operator=(const TimestampMetadataBuilder &);
   flatbuffers::Offset<TimestampMetadata> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<TimestampMetadata>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<TimestampMetadata> CreateTimestampMetadata(
     flatbuffers::FlatBufferBuilder &_fbb,
-    arrow::ipc::feather::fbs::TimeUnit unit = arrow::ipc::feather::fbs::TimeUnit_SECOND,
+    TimeUnit unit = TimeUnit::SECOND,
     flatbuffers::Offset<flatbuffers::String> timezone = 0) {
   TimestampMetadataBuilder builder_(_fbb);
   builder_.add_timezone(timezone);
   builder_.add_unit(unit);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<TimestampMetadata> CreateTimestampMetadataDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    arrow::ipc::feather::fbs::TimeUnit unit = arrow::ipc::feather::fbs::TimeUnit_SECOND,
+    TimeUnit unit = TimeUnit::SECOND,
     const char *timezone = nullptr) {
   auto timezone__ = timezone ? _fbb.CreateString(timezone) : 0;
   return arrow::ipc::feather::fbs::CreateTimestampMetadata(
       _fbb,
       unit,
       timezone__);
 }
@@ -489,13 +489,13 @@ inline flatbuffers::Offset<DateMetadata> CreateDateMetadata(
 struct TimeMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_UNIT = 4
   };
-  arrow::ipc::feather::fbs::TimeUnit unit() const {
-    return static_cast<arrow::ipc::feather::fbs::TimeUnit>(GetField<int8_t>(VT_UNIT, 0));
+  TimeUnit unit() const {
+    return static_cast<TimeUnit>(GetField<int8_t>(VT_UNIT, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int8_t>(verifier, VT_UNIT) &&
            verifier.EndTable();
   }
 };
@@ -503,25 +503,25 @@ struct TimeMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct TimeMetadataBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_unit(arrow::ipc::feather::fbs::TimeUnit unit) {
+  void add_unit(TimeUnit unit) {
     fbb_.AddElement<int8_t>(TimeMetadata::VT_UNIT, static_cast<int8_t>(unit), 0);
   }
   explicit TimeMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   TimeMetadataBuilder &operator=(const TimeMetadataBuilder &);
   flatbuffers::Offset<TimeMetadata> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<TimeMetadata>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<TimeMetadata> CreateTimeMetadata(
     flatbuffers::FlatBufferBuilder &_fbb,
-    arrow::ipc::feather::fbs::TimeUnit unit = arrow::ipc::feather::fbs::TimeUnit_SECOND) {
+    TimeUnit unit = TimeUnit::SECOND) {
   TimeMetadataBuilder builder_(_fbb);
   builder_.add_unit(unit);
   return builder_.Finish();
 }
@@ -529,97 +529,97 @@ inline flatbuffers::Offset<TimeMetadata> CreateTimeMetadata(
 struct Column FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_NAME = 4,
     VT_VALUES = 6,
     VT_METADATA_TYPE = 8,
     VT_METADATA = 10,
     VT_USER_METADATA = 12
   };
   const flatbuffers::String *name() const {
     return GetPointer<const flatbuffers::String *>(VT_NAME);
   }
-  const arrow::ipc::feather::fbs::PrimitiveArray *values() const {
-    return GetPointer<const arrow::ipc::feather::fbs::PrimitiveArray *>(VT_VALUES);
+  const PrimitiveArray *values() const {
+    return GetPointer<const PrimitiveArray *>(VT_VALUES);
   }
-  arrow::ipc::feather::fbs::TypeMetadata metadata_type() const {
-    return static_cast<arrow::ipc::feather::fbs::TypeMetadata>(GetField<uint8_t>(VT_METADATA_TYPE, 0));
+  TypeMetadata metadata_type() const {
+    return static_cast<TypeMetadata>(GetField<uint8_t>(VT_METADATA_TYPE, 0));
   }
   const void *metadata() const {
     return GetPointer<const void *>(VT_METADATA);
   }
   template<typename T> const T *metadata_as() const;
-  const arrow::ipc::feather::fbs::CategoryMetadata *metadata_as_CategoryMetadata() const {
-    return metadata_type() == arrow::ipc::feather::fbs::TypeMetadata_CategoryMetadata ? static_cast<const arrow::ipc::feather::fbs::CategoryMetadata *>(metadata()) : nullptr;
+  const CategoryMetadata *metadata_as_CategoryMetadata() const {
+    return metadata_type() == TypeMetadata::CategoryMetadata ? static_cast<const CategoryMetadata *>(metadata()) : nullptr;
   }
-  const arrow::ipc::feather::fbs::TimestampMetadata *metadata_as_TimestampMetadata() const {
-    return metadata_type() == arrow::ipc::feather::fbs::TypeMetadata_TimestampMetadata ? static_cast<const arrow::ipc::feather::fbs::TimestampMetadata *>(metadata()) : nullptr;
+  const TimestampMetadata *metadata_as_TimestampMetadata() const {
+    return metadata_type() == TypeMetadata::TimestampMetadata ? static_cast<const TimestampMetadata *>(metadata()) : nullptr;
   }
-  const arrow::ipc::feather::fbs::DateMetadata *metadata_as_DateMetadata() const {
-    return metadata_type() == arrow::ipc::feather::fbs::TypeMetadata_DateMetadata ? static_cast<const arrow::ipc::feather::fbs::DateMetadata *>(metadata()) : nullptr;
+  const DateMetadata *metadata_as_DateMetadata() const {
+    return metadata_type() == TypeMetadata::DateMetadata ? static_cast<const DateMetadata *>(metadata()) : nullptr;
   }
-  const arrow::ipc::feather::fbs::TimeMetadata *metadata_as_TimeMetadata() const {
-    return metadata_type() == arrow::ipc::feather::fbs::TypeMetadata_TimeMetadata ? static_cast<const arrow::ipc::feather::fbs::TimeMetadata *>(metadata()) : nullptr;
+  const TimeMetadata *metadata_as_TimeMetadata() const {
+    return metadata_type() == TypeMetadata::TimeMetadata ? static_cast<const TimeMetadata *>(metadata()) : nullptr;
   }
   /// This should (probably) be JSON
   const flatbuffers::String *user_metadata() const {
     return GetPointer<const flatbuffers::String *>(VT_USER_METADATA);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_NAME) &&
            verifier.VerifyString(name()) &&
            VerifyOffset(verifier, VT_VALUES) &&
            verifier.VerifyTable(values()) &&
            VerifyField<uint8_t>(verifier, VT_METADATA_TYPE) &&
            VerifyOffset(verifier, VT_METADATA) &&
            VerifyTypeMetadata(verifier, metadata(), metadata_type()) &&
            VerifyOffset(verifier, VT_USER_METADATA) &&
            verifier.VerifyString(user_metadata()) &&
            verifier.EndTable();
   }
 };
 
-template<> inline const arrow::ipc::feather::fbs::CategoryMetadata *Column::metadata_as<arrow::ipc::feather::fbs::CategoryMetadata>() const {
+template<> inline const CategoryMetadata *Column::metadata_as<CategoryMetadata>() const {
   return metadata_as_CategoryMetadata();
 }
 
-template<> inline const arrow::ipc::feather::fbs::TimestampMetadata *Column::metadata_as<arrow::ipc::feather::fbs::TimestampMetadata>() const {
+template<> inline const TimestampMetadata *Column::metadata_as<TimestampMetadata>() const {
   return metadata_as_TimestampMetadata();
 }
 
-template<> inline const arrow::ipc::feather::fbs::DateMetadata *Column::metadata_as<arrow::ipc::feather::fbs::DateMetadata>() const {
+template<> inline const DateMetadata *Column::metadata_as<DateMetadata>() const {
   return metadata_as_DateMetadata();
 }
 
-template<> inline const arrow::ipc::feather::fbs::TimeMetadata *Column::metadata_as<arrow::ipc::feather::fbs::TimeMetadata>() const {
+template<> inline const TimeMetadata *Column::metadata_as<TimeMetadata>() const {
   return metadata_as_TimeMetadata();
 }
 
 struct ColumnBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_name(flatbuffers::Offset<flatbuffers::String> name) {
     fbb_.AddOffset(Column::VT_NAME, name);
   }
-  void add_values(flatbuffers::Offset<arrow::ipc::feather::fbs::PrimitiveArray> values) {
+  void add_values(flatbuffers::Offset<PrimitiveArray> values) {
     fbb_.AddOffset(Column::VT_VALUES, values);
   }
-  void add_metadata_type(arrow::ipc::feather::fbs::TypeMetadata metadata_type) {
+  void add_metadata_type(TypeMetadata metadata_type) {
     fbb_.AddElement<uint8_t>(Column::VT_METADATA_TYPE, static_cast<uint8_t>(metadata_type), 0);
   }
   void add_metadata(flatbuffers::Offset<void> metadata) {
     fbb_.AddOffset(Column::VT_METADATA, metadata);
   }
   void add_user_metadata(flatbuffers::Offset<flatbuffers::String> user_metadata) {
     fbb_.AddOffset(Column::VT_USER_METADATA, user_metadata);
   }
   explicit ColumnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   ColumnBuilder &operator=(const ColumnBuilder &);
   flatbuffers::Offset<Column> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<Column>(end);
     return o;
   }
 };
@@ -627,15 +627,15 @@ struct ColumnBuilder {
 inline flatbuffers::Offset<Column> CreateColumn(
     flatbuffers::FlatBufferBuilder &_fbb,
     flatbuffers::Offset<flatbuffers::String> name = 0,
-    flatbuffers::Offset<arrow::ipc::feather::fbs::PrimitiveArray> values = 0,
-    arrow::ipc::feather::fbs::TypeMetadata metadata_type = arrow::ipc::feather::fbs::TypeMetadata_NONE,
+    flatbuffers::Offset<PrimitiveArray> values = 0,
+    TypeMetadata metadata_type = TypeMetadata::NONE,
     flatbuffers::Offset<void> metadata = 0,
     flatbuffers::Offset<flatbuffers::String> user_metadata = 0) {
   ColumnBuilder builder_(_fbb);
   builder_.add_user_metadata(user_metadata);
   builder_.add_metadata(metadata);
   builder_.add_values(values);
   builder_.add_name(name);
   builder_.add_metadata_type(metadata_type);
   return builder_.Finish();
 }
@@ -643,17 +643,17 @@ inline flatbuffers::Offset<Column> CreateColumn(
 inline flatbuffers::Offset<Column> CreateColumnDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
     const char *name = nullptr,
-    flatbuffers::Offset<arrow::ipc::feather::fbs::PrimitiveArray> values = 0,
-    arrow::ipc::feather::fbs::TypeMetadata metadata_type = arrow::ipc::feather::fbs::TypeMetadata_NONE,
+    flatbuffers::Offset<PrimitiveArray> values = 0,
+    TypeMetadata metadata_type = TypeMetadata::NONE,
     flatbuffers::Offset<void> metadata = 0,
     const char *user_metadata = nullptr) {
   auto name__ = name ? _fbb.CreateString(name) : 0;
   auto user_metadata__ = user_metadata ? _fbb.CreateString(user_metadata) : 0;
   return arrow::ipc::feather::fbs::CreateColumn(
       _fbb,
       name__,
       values,
       metadata_type,
       metadata,
       user_metadata__);
 }
@@ -661,40 +661,40 @@ inline flatbuffers::Offset<Column> CreateColumnDirect(
 struct CTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_DESCRIPTION = 4,
     VT_NUM_ROWS = 6,
     VT_COLUMNS = 8,
     VT_VERSION = 10,
     VT_METADATA = 12
   };
   /// Some text (or a name) metadata about what the file is, optional
   const flatbuffers::String *description() const {
     return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
   }
   int64_t num_rows() const {
     return GetField<int64_t>(VT_NUM_ROWS, 0);
   }
-  const flatbuffers::Vector<flatbuffers::Offset<arrow::ipc::feather::fbs::Column>> *columns() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<arrow::ipc::feather::fbs::Column>> *>(VT_COLUMNS);
+  const flatbuffers::Vector<flatbuffers::Offset<Column>> *columns() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Column>> *>(VT_COLUMNS);
   }
   /// Version number of the Feather format
   int32_t version() const {
     return GetField<int32_t>(VT_VERSION, 0);
   }
   /// Table metadata (likely JSON), not yet used
   const flatbuffers::String *metadata() const {
     return GetPointer<const flatbuffers::String *>(VT_METADATA);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_DESCRIPTION) &&
            verifier.VerifyString(description()) &&
            VerifyField<int64_t>(verifier, VT_NUM_ROWS) &&
            VerifyOffset(verifier, VT_COLUMNS) &&
            verifier.VerifyVector(columns()) &&
            verifier.VerifyVectorOfTables(columns()) &&
            VerifyField<int32_t>(verifier, VT_VERSION) &&
            VerifyOffset(verifier, VT_METADATA) &&
            verifier.VerifyString(metadata()) &&
            verifier.EndTable();
   }
 };
@@ -702,29 +702,29 @@ struct CTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct CTableBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_description(flatbuffers::Offset<flatbuffers::String> description) {
     fbb_.AddOffset(CTable::VT_DESCRIPTION, description);
   }
   void add_num_rows(int64_t num_rows) {
     fbb_.AddElement<int64_t>(CTable::VT_NUM_ROWS, num_rows, 0);
   }
-  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<arrow::ipc::feather::fbs::Column>>> columns) {
+  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Column>>> columns) {
     fbb_.AddOffset(CTable::VT_COLUMNS, columns);
   }
   void add_version(int32_t version) {
     fbb_.AddElement<int32_t>(CTable::VT_VERSION, version, 0);
   }
   void add_metadata(flatbuffers::Offset<flatbuffers::String> metadata) {
     fbb_.AddOffset(CTable::VT_METADATA, metadata);
   }
   explicit CTableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   CTableBuilder &operator=(const CTableBuilder &);
   flatbuffers::Offset<CTable> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<CTable>(end);
     return o;
   }
 };
@@ -732,15 +732,15 @@ struct CTableBuilder {
 inline flatbuffers::Offset<CTable> CreateCTable(
     flatbuffers::FlatBufferBuilder &_fbb,
     flatbuffers::Offset<flatbuffers::String> description = 0,
     int64_t num_rows = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<arrow::ipc::feather::fbs::Column>>> columns = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Column>>> columns = 0,
     int32_t version = 0,
     flatbuffers::Offset<flatbuffers::String> metadata = 0) {
   CTableBuilder builder_(_fbb);
   builder_.add_num_rows(num_rows);
   builder_.add_metadata(metadata);
   builder_.add_version(version);
   builder_.add_columns(columns);
   builder_.add_description(description);
   return builder_.Finish();
 }
@@ -748,44 +748,44 @@ inline flatbuffers::Offset<CTable> CreateCTable(
 inline flatbuffers::Offset<CTable> CreateCTableDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
     const char *description = nullptr,
     int64_t num_rows = 0,
-    const std::vector<flatbuffers::Offset<arrow::ipc::feather::fbs::Column>> *columns = nullptr,
+    const std::vector<flatbuffers::Offset<Column>> *columns = nullptr,
     int32_t version = 0,
     const char *metadata = nullptr) {
   auto description__ = description ? _fbb.CreateString(description) : 0;
-  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<arrow::ipc::feather::fbs::Column>>(*columns) : 0;
+  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<Column>>(*columns) : 0;
   auto metadata__ = metadata ? _fbb.CreateString(metadata) : 0;
   return arrow::ipc::feather::fbs::CreateCTable(
       _fbb,
       description__,
       num_rows,
       columns__,
       version,
       metadata__);
 }
 
 inline bool VerifyTypeMetadata(flatbuffers::Verifier &verifier, const void *obj, TypeMetadata type) {
   switch (type) {
-    case TypeMetadata_NONE: {
+    case TypeMetadata::NONE: {
       return true;
     }
-    case TypeMetadata_CategoryMetadata: {
-      auto ptr = reinterpret_cast<const arrow::ipc::feather::fbs::CategoryMetadata *>(obj);
+    case TypeMetadata::CategoryMetadata: {
+      auto ptr = reinterpret_cast<const CategoryMetadata *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case TypeMetadata_TimestampMetadata: {
-      auto ptr = reinterpret_cast<const arrow::ipc::feather::fbs::TimestampMetadata *>(obj);
+    case TypeMetadata::TimestampMetadata: {
+      auto ptr = reinterpret_cast<const TimestampMetadata *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case TypeMetadata_DateMetadata: {
-      auto ptr = reinterpret_cast<const arrow::ipc::feather::fbs::DateMetadata *>(obj);
+    case TypeMetadata::DateMetadata: {
+      auto ptr = reinterpret_cast<const DateMetadata *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    case TypeMetadata_TimeMetadata: {
-      auto ptr = reinterpret_cast<const arrow::ipc::feather::fbs::TimeMetadata *>(obj);
+    case TypeMetadata::TimeMetadata: {
+      auto ptr = reinterpret_cast<const TimeMetadata *>(obj);
       return verifier.VerifyTable(ptr);
     }
-    default: return true;
+    default: return false;
   }
 }
 
diff --git a/cpp/src/plasma/common_generated.h b/cpp/src/plasma/common_generated.h
index e25ffaa04..f1023b43c 100644
--- a/cpp/src/plasma/common_generated.h
+++ b/cpp/src/plasma/common_generated.h
@@ -183,14 +183,14 @@ inline ObjectInfoT *ObjectInfo::UnPack(const flatbuffers::resolver_function_t *_
 inline void ObjectInfo::UnPackTo(ObjectInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = data_size(); _o->data_size = _e; }
-  { auto _e = metadata_size(); _o->metadata_size = _e; }
-  { auto _e = ref_count(); _o->ref_count = _e; }
-  { auto _e = create_time(); _o->create_time = _e; }
-  { auto _e = construct_duration(); _o->construct_duration = _e; }
-  { auto _e = digest(); if (_e) _o->digest = _e->str(); }
-  { auto _e = is_deletion(); _o->is_deletion = _e; }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = data_size(); _o->data_size = _e; };
+  { auto _e = metadata_size(); _o->metadata_size = _e; };
+  { auto _e = ref_count(); _o->ref_count = _e; };
+  { auto _e = create_time(); _o->create_time = _e; };
+  { auto _e = construct_duration(); _o->construct_duration = _e; };
+  { auto _e = digest(); if (_e) _o->digest = _e->str(); };
+  { auto _e = is_deletion(); _o->is_deletion = _e; };
 }
 
 inline flatbuffers::Offset<ObjectInfo> ObjectInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
diff --git a/cpp/src/plasma/plasma_generated.h b/cpp/src/plasma/plasma_generated.h
index 1b71b3b92..43edbee24 100644
--- a/cpp/src/plasma/plasma_generated.h
+++ b/cpp/src/plasma/plasma_generated.h
@@ -120,41 +120,41 @@ struct PlasmaRefreshLRUReplyT;
 
 enum class MessageType : int64_t {
   PlasmaDisconnectClient = 0,
-  PlasmaCreateRequest = 1LL,
-  PlasmaCreateReply = 2LL,
-  PlasmaCreateAndSealRequest = 3LL,
-  PlasmaCreateAndSealReply = 4LL,
-  PlasmaAbortRequest = 5LL,
-  PlasmaAbortReply = 6LL,
-  PlasmaSealRequest = 7LL,
-  PlasmaSealReply = 8LL,
-  PlasmaGetRequest = 9LL,
-  PlasmaGetReply = 10LL,
-  PlasmaReleaseRequest = 11LL,
-  PlasmaReleaseReply = 12LL,
-  PlasmaDeleteRequest = 13LL,
-  PlasmaDeleteReply = 14LL,
-  PlasmaContainsRequest = 15LL,
-  PlasmaContainsReply = 16LL,
-  PlasmaListRequest = 17LL,
-  PlasmaListReply = 18LL,
-  PlasmaConnectRequest = 19LL,
-  PlasmaConnectReply = 20LL,
-  PlasmaEvictRequest = 21LL,
-  PlasmaEvictReply = 22LL,
-  PlasmaSubscribeRequest = 23LL,
-  PlasmaUnsubscribeRequest = 24LL,
-  PlasmaDataRequest = 25LL,
-  PlasmaDataReply = 26LL,
-  PlasmaNotification = 27LL,
-  PlasmaSetOptionsRequest = 28LL,
-  PlasmaSetOptionsReply = 29LL,
-  PlasmaGetDebugStringRequest = 30LL,
-  PlasmaGetDebugStringReply = 31LL,
-  PlasmaCreateAndSealBatchRequest = 32LL,
-  PlasmaCreateAndSealBatchReply = 33LL,
-  PlasmaRefreshLRURequest = 34LL,
-  PlasmaRefreshLRUReply = 35LL,
+  PlasmaCreateRequest = 1,
+  PlasmaCreateReply = 2,
+  PlasmaCreateAndSealRequest = 3,
+  PlasmaCreateAndSealReply = 4,
+  PlasmaAbortRequest = 5,
+  PlasmaAbortReply = 6,
+  PlasmaSealRequest = 7,
+  PlasmaSealReply = 8,
+  PlasmaGetRequest = 9,
+  PlasmaGetReply = 10,
+  PlasmaReleaseRequest = 11,
+  PlasmaReleaseReply = 12,
+  PlasmaDeleteRequest = 13,
+  PlasmaDeleteReply = 14,
+  PlasmaContainsRequest = 15,
+  PlasmaContainsReply = 16,
+  PlasmaListRequest = 17,
+  PlasmaListReply = 18,
+  PlasmaConnectRequest = 19,
+  PlasmaConnectReply = 20,
+  PlasmaEvictRequest = 21,
+  PlasmaEvictReply = 22,
+  PlasmaSubscribeRequest = 23,
+  PlasmaUnsubscribeRequest = 24,
+  PlasmaDataRequest = 25,
+  PlasmaDataReply = 26,
+  PlasmaNotification = 27,
+  PlasmaSetOptionsRequest = 28,
+  PlasmaSetOptionsReply = 29,
+  PlasmaGetDebugStringRequest = 30,
+  PlasmaGetDebugStringReply = 31,
+  PlasmaCreateAndSealBatchRequest = 32,
+  PlasmaCreateAndSealBatchReply = 33,
+  PlasmaRefreshLRURequest = 34,
+  PlasmaRefreshLRUReply = 35,
   MIN = PlasmaDisconnectClient,
   MAX = PlasmaRefreshLRUReply
 };
@@ -202,44 +202,44 @@ inline const MessageType (&EnumValuesMessageType())[36] {
 }
 
 inline const char * const *EnumNamesMessageType() {
-  static const char * const names[37] = {
+  static const char * const names[] = {
     "PlasmaDisconnectClient",
     "PlasmaCreateRequest",
     "PlasmaCreateReply",
     "PlasmaCreateAndSealRequest",
     "PlasmaCreateAndSealReply",
     "PlasmaAbortRequest",
     "PlasmaAbortReply",
     "PlasmaSealRequest",
     "PlasmaSealReply",
     "PlasmaGetRequest",
     "PlasmaGetReply",
     "PlasmaReleaseRequest",
     "PlasmaReleaseReply",
     "PlasmaDeleteRequest",
     "PlasmaDeleteReply",
     "PlasmaContainsRequest",
     "PlasmaContainsReply",
     "PlasmaListRequest",
     "PlasmaListReply",
     "PlasmaConnectRequest",
     "PlasmaConnectReply",
     "PlasmaEvictRequest",
     "PlasmaEvictReply",
     "PlasmaSubscribeRequest",
     "PlasmaUnsubscribeRequest",
     "PlasmaDataRequest",
     "PlasmaDataReply",
     "PlasmaNotification",
     "PlasmaSetOptionsRequest",
     "PlasmaSetOptionsReply",
     "PlasmaGetDebugStringRequest",
     "PlasmaGetDebugStringReply",
     "PlasmaCreateAndSealBatchRequest",
     "PlasmaCreateAndSealBatchReply",
     "PlasmaRefreshLRURequest",
     "PlasmaRefreshLRUReply",
     nullptr
   };
   return names;
 }
@@ -274,14 +274,14 @@ inline const PlasmaError (&EnumValuesPlasmaError())[6] {
 }
 
 inline const char * const *EnumNamesPlasmaError() {
-  static const char * const names[7] = {
+  static const char * const names[] = {
     "OK",
     "ObjectExists",
     "ObjectNonexistent",
     "OutOfMemory",
     "ObjectNotSealed",
     "ObjectInUse",
     nullptr
   };
   return names;
 }
@@ -419,26 +419,26 @@ flatbuffers::Offset<PlasmaSetOptionsRequest> CreatePlasmaSetOptionsRequest(flatb
 
 struct PlasmaSetOptionsReplyT : public flatbuffers::NativeTable {
   typedef PlasmaSetOptionsReply TableType;
-  plasma::flatbuf::PlasmaError error;
+  PlasmaError error;
   PlasmaSetOptionsReplyT()
-      : error(plasma::flatbuf::PlasmaError::OK) {
+      : error(PlasmaError::OK) {
   }
 };
 
 struct PlasmaSetOptionsReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef PlasmaSetOptionsReplyT NativeTableType;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_ERROR = 4
   };
-  plasma::flatbuf::PlasmaError error() const {
-    return static_cast<plasma::flatbuf::PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
+  PlasmaError error() const {
+    return static_cast<PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int32_t>(verifier, VT_ERROR) &&
            verifier.EndTable();
   }
   PlasmaSetOptionsReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   void UnPackTo(PlasmaSetOptionsReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   static flatbuffers::Offset<PlasmaSetOptionsReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaSetOptionsReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
@@ -446,25 +446,25 @@ struct PlasmaSetOptionsReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Tabl
 struct PlasmaSetOptionsReplyBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_error(plasma::flatbuf::PlasmaError error) {
+  void add_error(PlasmaError error) {
     fbb_.AddElement<int32_t>(PlasmaSetOptionsReply::VT_ERROR, static_cast<int32_t>(error), 0);
   }
   explicit PlasmaSetOptionsReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PlasmaSetOptionsReplyBuilder &operator=(const PlasmaSetOptionsReplyBuilder &);
   flatbuffers::Offset<PlasmaSetOptionsReply> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PlasmaSetOptionsReply>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<PlasmaSetOptionsReply> CreatePlasmaSetOptionsReply(
     flatbuffers::FlatBufferBuilder &_fbb,
-    plasma::flatbuf::PlasmaError error = plasma::flatbuf::PlasmaError::OK) {
+    PlasmaError error = PlasmaError::OK) {
   PlasmaSetOptionsReplyBuilder builder_(_fbb);
   builder_.add_error(error);
   return builder_.Finish();
 }
@@ -745,14 +745,14 @@ flatbuffers::Offset<CudaHandle> CreateCudaHandle(flatbuffers::FlatBufferBuilder
 struct PlasmaCreateReplyT : public flatbuffers::NativeTable {
   typedef PlasmaCreateReply TableType;
   std::string object_id;
-  std::unique_ptr<plasma::flatbuf::PlasmaObjectSpec> plasma_object;
-  plasma::flatbuf::PlasmaError error;
+  std::unique_ptr<PlasmaObjectSpec> plasma_object;
+  PlasmaError error;
   int32_t store_fd;
   int64_t mmap_size;
-  std::unique_ptr<plasma::flatbuf::CudaHandleT> ipc_handle;
+  std::unique_ptr<CudaHandleT> ipc_handle;
   PlasmaCreateReplyT()
-      : error(plasma::flatbuf::PlasmaError::OK),
+      : error(PlasmaError::OK),
         store_fd(0),
         mmap_size(0) {
   }
 };
@@ -760,44 +760,44 @@ struct PlasmaCreateReplyT : public flatbuffers::NativeTable {
 struct PlasmaCreateReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef PlasmaCreateReplyT NativeTableType;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_OBJECT_ID = 4,
     VT_PLASMA_OBJECT = 6,
     VT_ERROR = 8,
     VT_STORE_FD = 10,
     VT_MMAP_SIZE = 12,
     VT_IPC_HANDLE = 14
   };
   const flatbuffers::String *object_id() const {
     return GetPointer<const flatbuffers::String *>(VT_OBJECT_ID);
   }
-  const plasma::flatbuf::PlasmaObjectSpec *plasma_object() const {
-    return GetStruct<const plasma::flatbuf::PlasmaObjectSpec *>(VT_PLASMA_OBJECT);
+  const PlasmaObjectSpec *plasma_object() const {
+    return GetStruct<const PlasmaObjectSpec *>(VT_PLASMA_OBJECT);
   }
-  plasma::flatbuf::PlasmaError error() const {
-    return static_cast<plasma::flatbuf::PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
+  PlasmaError error() const {
+    return static_cast<PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
   }
   int32_t store_fd() const {
     return GetField<int32_t>(VT_STORE_FD, 0);
   }
   int64_t mmap_size() const {
     return GetField<int64_t>(VT_MMAP_SIZE, 0);
   }
-  const plasma::flatbuf::CudaHandle *ipc_handle() const {
-    return GetPointer<const plasma::flatbuf::CudaHandle *>(VT_IPC_HANDLE);
+  const CudaHandle *ipc_handle() const {
+    return GetPointer<const CudaHandle *>(VT_IPC_HANDLE);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_OBJECT_ID) &&
            verifier.VerifyString(object_id()) &&
-           VerifyField<plasma::flatbuf::PlasmaObjectSpec>(verifier, VT_PLASMA_OBJECT) &&
+           VerifyField<PlasmaObjectSpec>(verifier, VT_PLASMA_OBJECT) &&
            VerifyField<int32_t>(verifier, VT_ERROR) &&
            VerifyField<int32_t>(verifier, VT_STORE_FD) &&
            VerifyField<int64_t>(verifier, VT_MMAP_SIZE) &&
            VerifyOffset(verifier, VT_IPC_HANDLE) &&
            verifier.VerifyTable(ipc_handle()) &&
            verifier.EndTable();
   }
   PlasmaCreateReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   void UnPackTo(PlasmaCreateReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   static flatbuffers::Offset<PlasmaCreateReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaCreateReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
@@ -805,32 +805,32 @@ struct PlasmaCreateReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct PlasmaCreateReplyBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_object_id(flatbuffers::Offset<flatbuffers::String> object_id) {
     fbb_.AddOffset(PlasmaCreateReply::VT_OBJECT_ID, object_id);
   }
-  void add_plasma_object(const plasma::flatbuf::PlasmaObjectSpec *plasma_object) {
+  void add_plasma_object(const PlasmaObjectSpec *plasma_object) {
     fbb_.AddStruct(PlasmaCreateReply::VT_PLASMA_OBJECT, plasma_object);
   }
-  void add_error(plasma::flatbuf::PlasmaError error) {
+  void add_error(PlasmaError error) {
     fbb_.AddElement<int32_t>(PlasmaCreateReply::VT_ERROR, static_cast<int32_t>(error), 0);
   }
   void add_store_fd(int32_t store_fd) {
     fbb_.AddElement<int32_t>(PlasmaCreateReply::VT_STORE_FD, store_fd, 0);
   }
   void add_mmap_size(int64_t mmap_size) {
     fbb_.AddElement<int64_t>(PlasmaCreateReply::VT_MMAP_SIZE, mmap_size, 0);
   }
-  void add_ipc_handle(flatbuffers::Offset<plasma::flatbuf::CudaHandle> ipc_handle) {
+  void add_ipc_handle(flatbuffers::Offset<CudaHandle> ipc_handle) {
     fbb_.AddOffset(PlasmaCreateReply::VT_IPC_HANDLE, ipc_handle);
   }
   explicit PlasmaCreateReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PlasmaCreateReplyBuilder &operator=(const PlasmaCreateReplyBuilder &);
   flatbuffers::Offset<PlasmaCreateReply> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PlasmaCreateReply>(end);
     return o;
   }
 };
@@ -838,17 +838,17 @@ struct PlasmaCreateReplyBuilder {
 inline flatbuffers::Offset<PlasmaCreateReply> CreatePlasmaCreateReply(
     flatbuffers::FlatBufferBuilder &_fbb,
     flatbuffers::Offset<flatbuffers::String> object_id = 0,
-    const plasma::flatbuf::PlasmaObjectSpec *plasma_object = 0,
-    plasma::flatbuf::PlasmaError error = plasma::flatbuf::PlasmaError::OK,
+    const PlasmaObjectSpec *plasma_object = 0,
+    PlasmaError error = PlasmaError::OK,
     int32_t store_fd = 0,
     int64_t mmap_size = 0,
-    flatbuffers::Offset<plasma::flatbuf::CudaHandle> ipc_handle = 0) {
+    flatbuffers::Offset<CudaHandle> ipc_handle = 0) {
   PlasmaCreateReplyBuilder builder_(_fbb);
   builder_.add_mmap_size(mmap_size);
   builder_.add_ipc_handle(ipc_handle);
   builder_.add_store_fd(store_fd);
   builder_.add_error(error);
   builder_.add_plasma_object(plasma_object);
   builder_.add_object_id(object_id);
   return builder_.Finish();
 }
@@ -856,18 +856,18 @@ inline flatbuffers::Offset<PlasmaCreateReply> CreatePlasmaCreateReply(
 inline flatbuffers::Offset<PlasmaCreateReply> CreatePlasmaCreateReplyDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
     const char *object_id = nullptr,
-    const plasma::flatbuf::PlasmaObjectSpec *plasma_object = 0,
-    plasma::flatbuf::PlasmaError error = plasma::flatbuf::PlasmaError::OK,
+    const PlasmaObjectSpec *plasma_object = 0,
+    PlasmaError error = PlasmaError::OK,
     int32_t store_fd = 0,
     int64_t mmap_size = 0,
-    flatbuffers::Offset<plasma::flatbuf::CudaHandle> ipc_handle = 0) {
+    flatbuffers::Offset<CudaHandle> ipc_handle = 0) {
   auto object_id__ = object_id ? _fbb.CreateString(object_id) : 0;
   return plasma::flatbuf::CreatePlasmaCreateReply(
       _fbb,
       object_id__,
       plasma_object,
       error,
       store_fd,
       mmap_size,
       ipc_handle);
 }
@@ -984,26 +984,26 @@ flatbuffers::Offset<PlasmaCreateAndSealRequest> CreatePlasmaCreateAndSealRequest
 
 struct PlasmaCreateAndSealReplyT : public flatbuffers::NativeTable {
   typedef PlasmaCreateAndSealReply TableType;
-  plasma::flatbuf::PlasmaError error;
+  PlasmaError error;
   PlasmaCreateAndSealReplyT()
-      : error(plasma::flatbuf::PlasmaError::OK) {
+      : error(PlasmaError::OK) {
   }
 };
 
 struct PlasmaCreateAndSealReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef PlasmaCreateAndSealReplyT NativeTableType;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_ERROR = 4
   };
-  plasma::flatbuf::PlasmaError error() const {
-    return static_cast<plasma::flatbuf::PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
+  PlasmaError error() const {
+    return static_cast<PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int32_t>(verifier, VT_ERROR) &&
            verifier.EndTable();
   }
   PlasmaCreateAndSealReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   void UnPackTo(PlasmaCreateAndSealReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   static flatbuffers::Offset<PlasmaCreateAndSealReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaCreateAndSealReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
@@ -1011,25 +1011,25 @@ struct PlasmaCreateAndSealReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::T
 struct PlasmaCreateAndSealReplyBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_error(plasma::flatbuf::PlasmaError error) {
+  void add_error(PlasmaError error) {
     fbb_.AddElement<int32_t>(PlasmaCreateAndSealReply::VT_ERROR, static_cast<int32_t>(error), 0);
   }
   explicit PlasmaCreateAndSealReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PlasmaCreateAndSealReplyBuilder &operator=(const PlasmaCreateAndSealReplyBuilder &);
   flatbuffers::Offset<PlasmaCreateAndSealReply> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PlasmaCreateAndSealReply>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<PlasmaCreateAndSealReply> CreatePlasmaCreateAndSealReply(
     flatbuffers::FlatBufferBuilder &_fbb,
-    plasma::flatbuf::PlasmaError error = plasma::flatbuf::PlasmaError::OK) {
+    PlasmaError error = PlasmaError::OK) {
   PlasmaCreateAndSealReplyBuilder builder_(_fbb);
   builder_.add_error(error);
   return builder_.Finish();
 }
@@ -1150,26 +1150,26 @@ flatbuffers::Offset<PlasmaCreateAndSealBatchRequest> CreatePlasmaCreateAndSealBa
 
 struct PlasmaCreateAndSealBatchReplyT : public flatbuffers::NativeTable {
   typedef PlasmaCreateAndSealBatchReply TableType;
-  plasma::flatbuf::PlasmaError error;
+  PlasmaError error;
   PlasmaCreateAndSealBatchReplyT()
-      : error(plasma::flatbuf::PlasmaError::OK) {
+      : error(PlasmaError::OK) {
   }
 };
 
 struct PlasmaCreateAndSealBatchReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef PlasmaCreateAndSealBatchReplyT NativeTableType;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_ERROR = 4
   };
-  plasma::flatbuf::PlasmaError error() const {
-    return static_cast<plasma::flatbuf::PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
+  PlasmaError error() const {
+    return static_cast<PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyField<int32_t>(verifier, VT_ERROR) &&
            verifier.EndTable();
   }
   PlasmaCreateAndSealBatchReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   void UnPackTo(PlasmaCreateAndSealBatchReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   static flatbuffers::Offset<PlasmaCreateAndSealBatchReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaCreateAndSealBatchReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
@@ -1177,25 +1177,25 @@ struct PlasmaCreateAndSealBatchReply FLATBUFFERS_FINAL_CLASS : private flatbuffe
 struct PlasmaCreateAndSealBatchReplyBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_error(plasma::flatbuf::PlasmaError error) {
+  void add_error(PlasmaError error) {
     fbb_.AddElement<int32_t>(PlasmaCreateAndSealBatchReply::VT_ERROR, static_cast<int32_t>(error), 0);
   }
   explicit PlasmaCreateAndSealBatchReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PlasmaCreateAndSealBatchReplyBuilder &operator=(const PlasmaCreateAndSealBatchReplyBuilder &);
   flatbuffers::Offset<PlasmaCreateAndSealBatchReply> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PlasmaCreateAndSealBatchReply>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<PlasmaCreateAndSealBatchReply> CreatePlasmaCreateAndSealBatchReply(
     flatbuffers::FlatBufferBuilder &_fbb,
-    plasma::flatbuf::PlasmaError error = plasma::flatbuf::PlasmaError::OK) {
+    PlasmaError error = PlasmaError::OK) {
   PlasmaCreateAndSealBatchReplyBuilder builder_(_fbb);
   builder_.add_error(error);
   return builder_.Finish();
 }
@@ -1409,32 +1409,32 @@ flatbuffers::Offset<PlasmaSealRequest> CreatePlasmaSealRequest(flatbuffers::Flat
 struct PlasmaSealReplyT : public flatbuffers::NativeTable {
   typedef PlasmaSealReply TableType;
   std::string object_id;
-  plasma::flatbuf::PlasmaError error;
+  PlasmaError error;
   PlasmaSealReplyT()
-      : error(plasma::flatbuf::PlasmaError::OK) {
+      : error(PlasmaError::OK) {
   }
 };
 
 struct PlasmaSealReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef PlasmaSealReplyT NativeTableType;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_OBJECT_ID = 4,
     VT_ERROR = 6
   };
   const flatbuffers::String *object_id() const {
     return GetPointer<const flatbuffers::String *>(VT_OBJECT_ID);
   }
-  plasma::flatbuf::PlasmaError error() const {
-    return static_cast<plasma::flatbuf::PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
+  PlasmaError error() const {
+    return static_cast<PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_OBJECT_ID) &&
            verifier.VerifyString(object_id()) &&
            VerifyField<int32_t>(verifier, VT_ERROR) &&
            verifier.EndTable();
   }
   PlasmaSealReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   void UnPackTo(PlasmaSealReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   static flatbuffers::Offset<PlasmaSealReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaSealReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
@@ -1442,20 +1442,20 @@ struct PlasmaSealReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct PlasmaSealReplyBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_object_id(flatbuffers::Offset<flatbuffers::String> object_id) {
     fbb_.AddOffset(PlasmaSealReply::VT_OBJECT_ID, object_id);
   }
-  void add_error(plasma::flatbuf::PlasmaError error) {
+  void add_error(PlasmaError error) {
     fbb_.AddElement<int32_t>(PlasmaSealReply::VT_ERROR, static_cast<int32_t>(error), 0);
   }
   explicit PlasmaSealReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PlasmaSealReplyBuilder &operator=(const PlasmaSealReplyBuilder &);
   flatbuffers::Offset<PlasmaSealReply> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PlasmaSealReply>(end);
     return o;
   }
 };
@@ -1463,9 +1463,9 @@ struct PlasmaSealReplyBuilder {
 inline flatbuffers::Offset<PlasmaSealReply> CreatePlasmaSealReply(
     flatbuffers::FlatBufferBuilder &_fbb,
     flatbuffers::Offset<flatbuffers::String> object_id = 0,
-    plasma::flatbuf::PlasmaError error = plasma::flatbuf::PlasmaError::OK) {
+    PlasmaError error = PlasmaError::OK) {
   PlasmaSealReplyBuilder builder_(_fbb);
   builder_.add_error(error);
   builder_.add_object_id(object_id);
   return builder_.Finish();
 }
@@ -1473,10 +1473,10 @@ inline flatbuffers::Offset<PlasmaSealReply> CreatePlasmaSealReply(
 inline flatbuffers::Offset<PlasmaSealReply> CreatePlasmaSealReplyDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
     const char *object_id = nullptr,
-    plasma::flatbuf::PlasmaError error = plasma::flatbuf::PlasmaError::OK) {
+    PlasmaError error = PlasmaError::OK) {
   auto object_id__ = object_id ? _fbb.CreateString(object_id) : 0;
   return plasma::flatbuf::CreatePlasmaSealReply(
       _fbb,
       object_id__,
       error);
 }
@@ -1564,10 +1564,10 @@ flatbuffers::Offset<PlasmaGetRequest> CreatePlasmaGetRequest(flatbuffers::FlatBu
 struct PlasmaGetReplyT : public flatbuffers::NativeTable {
   typedef PlasmaGetReply TableType;
   std::vector<std::string> object_ids;
-  std::vector<plasma::flatbuf::PlasmaObjectSpec> plasma_objects;
+  std::vector<PlasmaObjectSpec> plasma_objects;
   std::vector<int32_t> store_fds;
   std::vector<int64_t> mmap_sizes;
-  std::vector<std::unique_ptr<plasma::flatbuf::CudaHandleT>> handles;
+  std::vector<std::unique_ptr<CudaHandleT>> handles;
   PlasmaGetReplyT() {
   }
 };
@@ -1575,44 +1575,44 @@ struct PlasmaGetReplyT : public flatbuffers::NativeTable {
 struct PlasmaGetReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef PlasmaGetReplyT NativeTableType;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_OBJECT_IDS = 4,
     VT_PLASMA_OBJECTS = 6,
     VT_STORE_FDS = 8,
     VT_MMAP_SIZES = 10,
     VT_HANDLES = 12
   };
   const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *object_ids() const {
     return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OBJECT_IDS);
   }
-  const flatbuffers::Vector<const plasma::flatbuf::PlasmaObjectSpec *> *plasma_objects() const {
-    return GetPointer<const flatbuffers::Vector<const plasma::flatbuf::PlasmaObjectSpec *> *>(VT_PLASMA_OBJECTS);
+  const flatbuffers::Vector<const PlasmaObjectSpec *> *plasma_objects() const {
+    return GetPointer<const flatbuffers::Vector<const PlasmaObjectSpec *> *>(VT_PLASMA_OBJECTS);
   }
   const flatbuffers::Vector<int32_t> *store_fds() const {
     return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STORE_FDS);
   }
   const flatbuffers::Vector<int64_t> *mmap_sizes() const {
     return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MMAP_SIZES);
   }
-  const flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::CudaHandle>> *handles() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::CudaHandle>> *>(VT_HANDLES);
+  const flatbuffers::Vector<flatbuffers::Offset<CudaHandle>> *handles() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CudaHandle>> *>(VT_HANDLES);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_OBJECT_IDS) &&
            verifier.VerifyVector(object_ids()) &&
            verifier.VerifyVectorOfStrings(object_ids()) &&
            VerifyOffset(verifier, VT_PLASMA_OBJECTS) &&
            verifier.VerifyVector(plasma_objects()) &&
            VerifyOffset(verifier, VT_STORE_FDS) &&
            verifier.VerifyVector(store_fds()) &&
            VerifyOffset(verifier, VT_MMAP_SIZES) &&
            verifier.VerifyVector(mmap_sizes()) &&
            VerifyOffset(verifier, VT_HANDLES) &&
            verifier.VerifyVector(handles()) &&
            verifier.VerifyVectorOfTables(handles()) &&
            verifier.EndTable();
   }
   PlasmaGetReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   void UnPackTo(PlasmaGetReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   static flatbuffers::Offset<PlasmaGetReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaGetReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
@@ -1620,29 +1620,29 @@ struct PlasmaGetReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct PlasmaGetReplyBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_object_ids(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> object_ids) {
     fbb_.AddOffset(PlasmaGetReply::VT_OBJECT_IDS, object_ids);
   }
-  void add_plasma_objects(flatbuffers::Offset<flatbuffers::Vector<const plasma::flatbuf::PlasmaObjectSpec *>> plasma_objects) {
+  void add_plasma_objects(flatbuffers::Offset<flatbuffers::Vector<const PlasmaObjectSpec *>> plasma_objects) {
     fbb_.AddOffset(PlasmaGetReply::VT_PLASMA_OBJECTS, plasma_objects);
   }
   void add_store_fds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> store_fds) {
     fbb_.AddOffset(PlasmaGetReply::VT_STORE_FDS, store_fds);
   }
   void add_mmap_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> mmap_sizes) {
     fbb_.AddOffset(PlasmaGetReply::VT_MMAP_SIZES, mmap_sizes);
   }
-  void add_handles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::CudaHandle>>> handles) {
+  void add_handles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CudaHandle>>> handles) {
     fbb_.AddOffset(PlasmaGetReply::VT_HANDLES, handles);
   }
   explicit PlasmaGetReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PlasmaGetReplyBuilder &operator=(const PlasmaGetReplyBuilder &);
   flatbuffers::Offset<PlasmaGetReply> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PlasmaGetReply>(end);
     return o;
   }
 };
@@ -1650,15 +1650,15 @@ struct PlasmaGetReplyBuilder {
 inline flatbuffers::Offset<PlasmaGetReply> CreatePlasmaGetReply(
     flatbuffers::FlatBufferBuilder &_fbb,
     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> object_ids = 0,
-    flatbuffers::Offset<flatbuffers::Vector<const plasma::flatbuf::PlasmaObjectSpec *>> plasma_objects = 0,
+    flatbuffers::Offset<flatbuffers::Vector<const PlasmaObjectSpec *>> plasma_objects = 0,
     flatbuffers::Offset<flatbuffers::Vector<int32_t>> store_fds = 0,
     flatbuffers::Offset<flatbuffers::Vector<int64_t>> mmap_sizes = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::CudaHandle>>> handles = 0) {
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CudaHandle>>> handles = 0) {
   PlasmaGetReplyBuilder builder_(_fbb);
   builder_.add_handles(handles);
   builder_.add_mmap_sizes(mmap_sizes);
   builder_.add_store_fds(store_fds);
   builder_.add_plasma_objects(plasma_objects);
   builder_.add_object_ids(object_ids);
   return builder_.Finish();
 }
@@ -1666,20 +1666,20 @@ inline flatbuffers::Offset<PlasmaGetReply> CreatePlasmaGetReply(
 inline flatbuffers::Offset<PlasmaGetReply> CreatePlasmaGetReplyDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
     const std::vector<flatbuffers::Offset<flatbuffers::String>> *object_ids = nullptr,
-    const std::vector<plasma::flatbuf::PlasmaObjectSpec> *plasma_objects = nullptr,
+    const std::vector<PlasmaObjectSpec> *plasma_objects = nullptr,
     const std::vector<int32_t> *store_fds = nullptr,
     const std::vector<int64_t> *mmap_sizes = nullptr,
-    const std::vector<flatbuffers::Offset<plasma::flatbuf::CudaHandle>> *handles = nullptr) {
+    const std::vector<flatbuffers::Offset<CudaHandle>> *handles = nullptr) {
   auto object_ids__ = object_ids ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*object_ids) : 0;
-  auto plasma_objects__ = plasma_objects ? _fbb.CreateVectorOfStructs<plasma::flatbuf::PlasmaObjectSpec>(*plasma_objects) : 0;
+  auto plasma_objects__ = plasma_objects ? _fbb.CreateVectorOfStructs<PlasmaObjectSpec>(*plasma_objects) : 0;
   auto store_fds__ = store_fds ? _fbb.CreateVector<int32_t>(*store_fds) : 0;
   auto mmap_sizes__ = mmap_sizes ? _fbb.CreateVector<int64_t>(*mmap_sizes) : 0;
-  auto handles__ = handles ? _fbb.CreateVector<flatbuffers::Offset<plasma::flatbuf::CudaHandle>>(*handles) : 0;
+  auto handles__ = handles ? _fbb.CreateVector<flatbuffers::Offset<CudaHandle>>(*handles) : 0;
   return plasma::flatbuf::CreatePlasmaGetReply(
       _fbb,
       object_ids__,
       plasma_objects__,
       store_fds__,
       mmap_sizes__,
       handles__);
 }
@@ -1752,32 +1752,32 @@ flatbuffers::Offset<PlasmaReleaseRequest> CreatePlasmaReleaseRequest(flatbuffers
 struct PlasmaReleaseReplyT : public flatbuffers::NativeTable {
   typedef PlasmaReleaseReply TableType;
   std::string object_id;
-  plasma::flatbuf::PlasmaError error;
+  PlasmaError error;
   PlasmaReleaseReplyT()
-      : error(plasma::flatbuf::PlasmaError::OK) {
+      : error(PlasmaError::OK) {
   }
 };
 
 struct PlasmaReleaseReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef PlasmaReleaseReplyT NativeTableType;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_OBJECT_ID = 4,
     VT_ERROR = 6
   };
   const flatbuffers::String *object_id() const {
     return GetPointer<const flatbuffers::String *>(VT_OBJECT_ID);
   }
-  plasma::flatbuf::PlasmaError error() const {
-    return static_cast<plasma::flatbuf::PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
+  PlasmaError error() const {
+    return static_cast<PlasmaError>(GetField<int32_t>(VT_ERROR, 0));
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_OBJECT_ID) &&
            verifier.VerifyString(object_id()) &&
            VerifyField<int32_t>(verifier, VT_ERROR) &&
            verifier.EndTable();
   }
   PlasmaReleaseReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   void UnPackTo(PlasmaReleaseReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   static flatbuffers::Offset<PlasmaReleaseReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaReleaseReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
@@ -1785,20 +1785,20 @@ struct PlasmaReleaseReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct PlasmaReleaseReplyBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
   void add_object_id(flatbuffers::Offset<flatbuffers::String> object_id) {
     fbb_.AddOffset(PlasmaReleaseReply::VT_OBJECT_ID, object_id);
   }
-  void add_error(plasma::flatbuf::PlasmaError error) {
+  void add_error(PlasmaError error) {
     fbb_.AddElement<int32_t>(PlasmaReleaseReply::VT_ERROR, static_cast<int32_t>(error), 0);
   }
   explicit PlasmaReleaseReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PlasmaReleaseReplyBuilder &operator=(const PlasmaReleaseReplyBuilder &);
   flatbuffers::Offset<PlasmaReleaseReply> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PlasmaReleaseReply>(end);
     return o;
   }
 };
@@ -1806,9 +1806,9 @@ struct PlasmaReleaseReplyBuilder {
 inline flatbuffers::Offset<PlasmaReleaseReply> CreatePlasmaReleaseReply(
     flatbuffers::FlatBufferBuilder &_fbb,
     flatbuffers::Offset<flatbuffers::String> object_id = 0,
-    plasma::flatbuf::PlasmaError error = plasma::flatbuf::PlasmaError::OK) {
+    PlasmaError error = PlasmaError::OK) {
   PlasmaReleaseReplyBuilder builder_(_fbb);
   builder_.add_error(error);
   builder_.add_object_id(object_id);
   return builder_.Finish();
 }
@@ -1816,10 +1816,10 @@ inline flatbuffers::Offset<PlasmaReleaseReply> CreatePlasmaReleaseReply(
 inline flatbuffers::Offset<PlasmaReleaseReply> CreatePlasmaReleaseReplyDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
     const char *object_id = nullptr,
-    plasma::flatbuf::PlasmaError error = plasma::flatbuf::PlasmaError::OK) {
+    PlasmaError error = PlasmaError::OK) {
   auto object_id__ = object_id ? _fbb.CreateString(object_id) : 0;
   return plasma::flatbuf::CreatePlasmaReleaseReply(
       _fbb,
       object_id__,
       error);
 }
@@ -1907,9 +1907,9 @@ flatbuffers::Offset<PlasmaDeleteRequest> CreatePlasmaDeleteRequest(flatbuffers::
 struct PlasmaDeleteReplyT : public flatbuffers::NativeTable {
   typedef PlasmaDeleteReply TableType;
   int32_t count;
   std::vector<std::string> object_ids;
-  std::vector<plasma::flatbuf::PlasmaError> errors;
+  std::vector<PlasmaError> errors;
   PlasmaDeleteReplyT()
       : count(0) {
   }
 };
@@ -2179,7 +2179,7 @@ flatbuffers::Offset<PlasmaListRequest> CreatePlasmaListRequest(flatbuffers::Flat
 
 struct PlasmaListReplyT : public flatbuffers::NativeTable {
   typedef PlasmaListReply TableType;
-  std::vector<std::unique_ptr<plasma::flatbuf::ObjectInfoT>> objects;
+  std::vector<std::unique_ptr<ObjectInfoT>> objects;
   PlasmaListReplyT() {
   }
 };
@@ -2187,19 +2187,19 @@ struct PlasmaListReplyT : public flatbuffers::NativeTable {
 struct PlasmaListReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef PlasmaListReplyT NativeTableType;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_OBJECTS = 4
   };
-  const flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>> *objects() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>> *>(VT_OBJECTS);
+  const flatbuffers::Vector<flatbuffers::Offset<ObjectInfo>> *objects() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ObjectInfo>> *>(VT_OBJECTS);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_OBJECTS) &&
            verifier.VerifyVector(objects()) &&
            verifier.VerifyVectorOfTables(objects()) &&
            verifier.EndTable();
   }
   PlasmaListReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   void UnPackTo(PlasmaListReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   static flatbuffers::Offset<PlasmaListReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaListReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
@@ -2207,34 +2207,34 @@ struct PlasmaListReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct PlasmaListReplyBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>>> objects) {
+  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ObjectInfo>>> objects) {
     fbb_.AddOffset(PlasmaListReply::VT_OBJECTS, objects);
   }
   explicit PlasmaListReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PlasmaListReplyBuilder &operator=(const PlasmaListReplyBuilder &);
   flatbuffers::Offset<PlasmaListReply> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PlasmaListReply>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<PlasmaListReply> CreatePlasmaListReply(
     flatbuffers::FlatBufferBuilder &_fbb,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>>> objects = 0) {
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ObjectInfo>>> objects = 0) {
   PlasmaListReplyBuilder builder_(_fbb);
   builder_.add_objects(objects);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<PlasmaListReply> CreatePlasmaListReplyDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    const std::vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>> *objects = nullptr) {
-  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>>(*objects) : 0;
+    const std::vector<flatbuffers::Offset<ObjectInfo>> *objects = nullptr) {
+  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<ObjectInfo>>(*objects) : 0;
   return plasma::flatbuf::CreatePlasmaListReply(
       _fbb,
       objects__);
 }
@@ -2485,7 +2485,7 @@ flatbuffers::Offset<PlasmaSubscribeRequest> CreatePlasmaSubscribeRequest(flatbuf
 
 struct PlasmaNotificationT : public flatbuffers::NativeTable {
   typedef PlasmaNotification TableType;
-  std::vector<std::unique_ptr<plasma::flatbuf::ObjectInfoT>> object_info;
+  std::vector<std::unique_ptr<ObjectInfoT>> object_info;
   PlasmaNotificationT() {
   }
 };
@@ -2493,19 +2493,19 @@ struct PlasmaNotificationT : public flatbuffers::NativeTable {
 struct PlasmaNotification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef PlasmaNotificationT NativeTableType;
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_OBJECT_INFO = 4
   };
-  const flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>> *object_info() const {
-    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>> *>(VT_OBJECT_INFO);
+  const flatbuffers::Vector<flatbuffers::Offset<ObjectInfo>> *object_info() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ObjectInfo>> *>(VT_OBJECT_INFO);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_OBJECT_INFO) &&
            verifier.VerifyVector(object_info()) &&
            verifier.VerifyVectorOfTables(object_info()) &&
            verifier.EndTable();
   }
   PlasmaNotificationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   void UnPackTo(PlasmaNotificationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
   static flatbuffers::Offset<PlasmaNotification> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaNotificationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
@@ -2513,34 +2513,34 @@ struct PlasmaNotification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct PlasmaNotificationBuilder {
   flatbuffers::FlatBufferBuilder &fbb_;
   flatbuffers::uoffset_t start_;
-  void add_object_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>>> object_info) {
+  void add_object_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ObjectInfo>>> object_info) {
     fbb_.AddOffset(PlasmaNotification::VT_OBJECT_INFO, object_info);
   }
   explicit PlasmaNotificationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
   }
   PlasmaNotificationBuilder &operator=(const PlasmaNotificationBuilder &);
   flatbuffers::Offset<PlasmaNotification> Finish() {
     const auto end = fbb_.EndTable(start_);
     auto o = flatbuffers::Offset<PlasmaNotification>(end);
     return o;
   }
 };
 
 inline flatbuffers::Offset<PlasmaNotification> CreatePlasmaNotification(
     flatbuffers::FlatBufferBuilder &_fbb,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>>> object_info = 0) {
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ObjectInfo>>> object_info = 0) {
   PlasmaNotificationBuilder builder_(_fbb);
   builder_.add_object_info(object_info);
   return builder_.Finish();
 }
 
 inline flatbuffers::Offset<PlasmaNotification> CreatePlasmaNotificationDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    const std::vector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>> *object_info = nullptr) {
-  auto object_info__ = object_info ? _fbb.CreateVector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>>(*object_info) : 0;
+    const std::vector<flatbuffers::Offset<ObjectInfo>> *object_info = nullptr) {
+  auto object_info__ = object_info ? _fbb.CreateVector<flatbuffers::Offset<ObjectInfo>>(*object_info) : 0;
   return plasma::flatbuf::CreatePlasmaNotification(
       _fbb,
       object_info__);
 }
@@ -2843,8 +2843,8 @@ inline PlasmaSetOptionsRequestT *PlasmaSetOptionsRequest::UnPack(const flatbuffe
 inline void PlasmaSetOptionsRequest::UnPackTo(PlasmaSetOptionsRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = client_name(); if (_e) _o->client_name = _e->str(); }
-  { auto _e = output_memory_quota(); _o->output_memory_quota = _e; }
+  { auto _e = client_name(); if (_e) _o->client_name = _e->str(); };
+  { auto _e = output_memory_quota(); _o->output_memory_quota = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaSetOptionsRequest> PlasmaSetOptionsRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaSetOptionsRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -2872,7 +2872,7 @@ inline PlasmaSetOptionsReplyT *PlasmaSetOptionsReply::UnPack(const flatbuffers::
 inline void PlasmaSetOptionsReply::UnPackTo(PlasmaSetOptionsReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = error(); _o->error = _e; }
+  { auto _e = error(); _o->error = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaSetOptionsReply> PlasmaSetOptionsReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaSetOptionsReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -2921,7 +2921,7 @@ inline PlasmaGetDebugStringReplyT *PlasmaGetDebugStringReply::UnPack(const flatb
 inline void PlasmaGetDebugStringReply::UnPackTo(PlasmaGetDebugStringReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = debug_string(); if (_e) _o->debug_string = _e->str(); }
+  { auto _e = debug_string(); if (_e) _o->debug_string = _e->str(); };
 }
 
 inline flatbuffers::Offset<PlasmaGetDebugStringReply> PlasmaGetDebugStringReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaGetDebugStringReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -2947,10 +2947,10 @@ inline PlasmaCreateRequestT *PlasmaCreateRequest::UnPack(const flatbuffers::reso
 inline void PlasmaCreateRequest::UnPackTo(PlasmaCreateRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = data_size(); _o->data_size = _e; }
-  { auto _e = metadata_size(); _o->metadata_size = _e; }
-  { auto _e = device_num(); _o->device_num = _e; }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = data_size(); _o->data_size = _e; };
+  { auto _e = metadata_size(); _o->metadata_size = _e; };
+  { auto _e = device_num(); _o->device_num = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaCreateRequest> PlasmaCreateRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaCreateRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -2982,7 +2982,7 @@ inline CudaHandleT *CudaHandle::UnPack(const flatbuffers::resolver_function_t *_
 inline void CudaHandle::UnPackTo(CudaHandleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = handle(); if (_e) { _o->handle.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->handle[_i] = _e->Get(_i); } } }
+  { auto _e = handle(); if (_e) { _o->handle.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->handle[_i] = _e->Get(_i); } } };
 }
 
 inline flatbuffers::Offset<CudaHandle> CudaHandle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CudaHandleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3008,12 +3008,12 @@ inline PlasmaCreateReplyT *PlasmaCreateReply::UnPack(const flatbuffers::resolver
 inline void PlasmaCreateReply::UnPackTo(PlasmaCreateReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = plasma_object(); if (_e) _o->plasma_object = std::unique_ptr<plasma::flatbuf::PlasmaObjectSpec>(new plasma::flatbuf::PlasmaObjectSpec(*_e)); }
-  { auto _e = error(); _o->error = _e; }
-  { auto _e = store_fd(); _o->store_fd = _e; }
-  { auto _e = mmap_size(); _o->mmap_size = _e; }
-  { auto _e = ipc_handle(); if (_e) _o->ipc_handle = std::unique_ptr<plasma::flatbuf::CudaHandleT>(_e->UnPack(_resolver)); }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = plasma_object(); if (_e) _o->plasma_object = std::unique_ptr<PlasmaObjectSpec>(new PlasmaObjectSpec(*_e)); };
+  { auto _e = error(); _o->error = _e; };
+  { auto _e = store_fd(); _o->store_fd = _e; };
+  { auto _e = mmap_size(); _o->mmap_size = _e; };
+  { auto _e = ipc_handle(); if (_e) _o->ipc_handle = std::unique_ptr<CudaHandleT>(_e->UnPack(_resolver)); };
 }
 
 inline flatbuffers::Offset<PlasmaCreateReply> PlasmaCreateReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaCreateReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3049,10 +3049,10 @@ inline PlasmaCreateAndSealRequestT *PlasmaCreateAndSealRequest::UnPack(const fla
 inline void PlasmaCreateAndSealRequest::UnPackTo(PlasmaCreateAndSealRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = data(); if (_e) _o->data = _e->str(); }
-  { auto _e = metadata(); if (_e) _o->metadata = _e->str(); }
-  { auto _e = digest(); if (_e) _o->digest = _e->str(); }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = data(); if (_e) _o->data = _e->str(); };
+  { auto _e = metadata(); if (_e) _o->metadata = _e->str(); };
+  { auto _e = digest(); if (_e) _o->digest = _e->str(); };
 }
 
 inline flatbuffers::Offset<PlasmaCreateAndSealRequest> PlasmaCreateAndSealRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaCreateAndSealRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3084,7 +3084,7 @@ inline PlasmaCreateAndSealReplyT *PlasmaCreateAndSealReply::UnPack(const flatbuf
 inline void PlasmaCreateAndSealReply::UnPackTo(PlasmaCreateAndSealReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = error(); _o->error = _e; }
+  { auto _e = error(); _o->error = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaCreateAndSealReply> PlasmaCreateAndSealReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaCreateAndSealReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3110,10 +3110,10 @@ inline PlasmaCreateAndSealBatchRequestT *PlasmaCreateAndSealBatchRequest::UnPack
 inline void PlasmaCreateAndSealBatchRequest::UnPackTo(PlasmaCreateAndSealBatchRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } }
-  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i)->str(); } } }
-  { auto _e = metadata(); if (_e) { _o->metadata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata[_i] = _e->Get(_i)->str(); } } }
-  { auto _e = digest(); if (_e) { _o->digest.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->digest[_i] = _e->Get(_i)->str(); } } }
+  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } };
+  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i)->str(); } } };
+  { auto _e = metadata(); if (_e) { _o->metadata.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->metadata[_i] = _e->Get(_i)->str(); } } };
+  { auto _e = digest(); if (_e) { _o->digest.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->digest[_i] = _e->Get(_i)->str(); } } };
 }
 
 inline flatbuffers::Offset<PlasmaCreateAndSealBatchRequest> PlasmaCreateAndSealBatchRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaCreateAndSealBatchRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3145,7 +3145,7 @@ inline PlasmaCreateAndSealBatchReplyT *PlasmaCreateAndSealBatchReply::UnPack(con
 inline void PlasmaCreateAndSealBatchReply::UnPackTo(PlasmaCreateAndSealBatchReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = error(); _o->error = _e; }
+  { auto _e = error(); _o->error = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaCreateAndSealBatchReply> PlasmaCreateAndSealBatchReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaCreateAndSealBatchReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3171,7 +3171,7 @@ inline PlasmaAbortRequestT *PlasmaAbortRequest::UnPack(const flatbuffers::resolv
 inline void PlasmaAbortRequest::UnPackTo(PlasmaAbortRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
 }
 
 inline flatbuffers::Offset<PlasmaAbortRequest> PlasmaAbortRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaAbortRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3197,7 +3197,7 @@ inline PlasmaAbortReplyT *PlasmaAbortReply::UnPack(const flatbuffers::resolver_f
 inline void PlasmaAbortReply::UnPackTo(PlasmaAbortReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
 }
 
 inline flatbuffers::Offset<PlasmaAbortReply> PlasmaAbortReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaAbortReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3223,8 +3223,8 @@ inline PlasmaSealRequestT *PlasmaSealRequest::UnPack(const flatbuffers::resolver
 inline void PlasmaSealRequest::UnPackTo(PlasmaSealRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = digest(); if (_e) _o->digest = _e->str(); }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = digest(); if (_e) _o->digest = _e->str(); };
 }
 
 inline flatbuffers::Offset<PlasmaSealRequest> PlasmaSealRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaSealRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3252,8 +3252,8 @@ inline PlasmaSealReplyT *PlasmaSealReply::UnPack(const flatbuffers::resolver_fun
 inline void PlasmaSealReply::UnPackTo(PlasmaSealReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = error(); _o->error = _e; }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = error(); _o->error = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaSealReply> PlasmaSealReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaSealReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3281,8 +3281,8 @@ inline PlasmaGetRequestT *PlasmaGetRequest::UnPack(const flatbuffers::resolver_f
 inline void PlasmaGetRequest::UnPackTo(PlasmaGetRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } }
-  { auto _e = timeout_ms(); _o->timeout_ms = _e; }
+  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } };
+  { auto _e = timeout_ms(); _o->timeout_ms = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaGetRequest> PlasmaGetRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaGetRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3310,11 +3310,11 @@ inline PlasmaGetReplyT *PlasmaGetReply::UnPack(const flatbuffers::resolver_funct
 inline void PlasmaGetReply::UnPackTo(PlasmaGetReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } }
-  { auto _e = plasma_objects(); if (_e) { _o->plasma_objects.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->plasma_objects[_i] = *_e->Get(_i); } } }
-  { auto _e = store_fds(); if (_e) { _o->store_fds.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->store_fds[_i] = _e->Get(_i); } } }
-  { auto _e = mmap_sizes(); if (_e) { _o->mmap_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mmap_sizes[_i] = _e->Get(_i); } } }
-  { auto _e = handles(); if (_e) { _o->handles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->handles[_i] = std::unique_ptr<plasma::flatbuf::CudaHandleT>(_e->Get(_i)->UnPack(_resolver)); } } }
+  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } };
+  { auto _e = plasma_objects(); if (_e) { _o->plasma_objects.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->plasma_objects[_i] = *_e->Get(_i); } } };
+  { auto _e = store_fds(); if (_e) { _o->store_fds.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->store_fds[_i] = _e->Get(_i); } } };
+  { auto _e = mmap_sizes(); if (_e) { _o->mmap_sizes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mmap_sizes[_i] = _e->Get(_i); } } };
+  { auto _e = handles(); if (_e) { _o->handles.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->handles[_i] = std::unique_ptr<CudaHandleT>(_e->Get(_i)->UnPack(_resolver)); } } };
 }
 
 inline flatbuffers::Offset<PlasmaGetReply> PlasmaGetReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaGetReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3324,17 +3324,17 @@ inline flatbuffers::Offset<PlasmaGetReply> PlasmaGetReply::Pack(flatbuffers::Fla
 inline flatbuffers::Offset<PlasmaGetReply> CreatePlasmaGetReply(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaGetReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
   (void)_rehasher;
   (void)_o;
   struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlasmaGetReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
   auto _object_ids = _o->object_ids.size() ? _fbb.CreateVectorOfStrings(_o->object_ids) : 0;
   auto _plasma_objects = _o->plasma_objects.size() ? _fbb.CreateVectorOfStructs(_o->plasma_objects) : 0;
   auto _store_fds = _o->store_fds.size() ? _fbb.CreateVector(_o->store_fds) : 0;
   auto _mmap_sizes = _o->mmap_sizes.size() ? _fbb.CreateVector(_o->mmap_sizes) : 0;
-  auto _handles = _o->handles.size() ? _fbb.CreateVector<flatbuffers::Offset<plasma::flatbuf::CudaHandle>> (_o->handles.size(), [](size_t i, _VectorArgs *__va) { return CreateCudaHandle(*__va->__fbb, __va->__o->handles[i].get(), __va->__rehasher); }, &_va ) : 0;
+  auto _handles = _o->handles.size() ? _fbb.CreateVector<flatbuffers::Offset<CudaHandle>> (_o->handles.size(), [](size_t i, _VectorArgs *__va) { return CreateCudaHandle(*__va->__fbb, __va->__o->handles[i].get(), __va->__rehasher); }, &_va ) : 0;
   return plasma::flatbuf::CreatePlasmaGetReply(
       _fbb,
       _object_ids,
       _plasma_objects,
       _store_fds,
       _mmap_sizes,
       _handles);
 }
@@ -3348,7 +3348,7 @@ inline PlasmaReleaseRequestT *PlasmaReleaseRequest::UnPack(const flatbuffers::re
 inline void PlasmaReleaseRequest::UnPackTo(PlasmaReleaseRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
 }
 
 inline flatbuffers::Offset<PlasmaReleaseRequest> PlasmaReleaseRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaReleaseRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3374,8 +3374,8 @@ inline PlasmaReleaseReplyT *PlasmaReleaseReply::UnPack(const flatbuffers::resolv
 inline void PlasmaReleaseReply::UnPackTo(PlasmaReleaseReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = error(); _o->error = _e; }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = error(); _o->error = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaReleaseReply> PlasmaReleaseReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaReleaseReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3403,8 +3403,8 @@ inline PlasmaDeleteRequestT *PlasmaDeleteRequest::UnPack(const flatbuffers::reso
 inline void PlasmaDeleteRequest::UnPackTo(PlasmaDeleteRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = count(); _o->count = _e; }
-  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } }
+  { auto _e = count(); _o->count = _e; };
+  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } };
 }
 
 inline flatbuffers::Offset<PlasmaDeleteRequest> PlasmaDeleteRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaDeleteRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3432,9 +3432,9 @@ inline PlasmaDeleteReplyT *PlasmaDeleteReply::UnPack(const flatbuffers::resolver
 inline void PlasmaDeleteReply::UnPackTo(PlasmaDeleteReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = count(); _o->count = _e; }
-  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } }
-  { auto _e = errors(); if (_e) { _o->errors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->errors[_i] = static_cast<plasma::flatbuf::PlasmaError>(_e->Get(_i)); } } }
+  { auto _e = count(); _o->count = _e; };
+  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } };
+  { auto _e = errors(); if (_e) { _o->errors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->errors[_i] = static_cast<PlasmaError>(_e->Get(_i)); } } };
 }
 
 inline flatbuffers::Offset<PlasmaDeleteReply> PlasmaDeleteReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaDeleteReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3464,7 +3464,7 @@ inline PlasmaContainsRequestT *PlasmaContainsRequest::UnPack(const flatbuffers::
 inline void PlasmaContainsRequest::UnPackTo(PlasmaContainsRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
 }
 
 inline flatbuffers::Offset<PlasmaContainsRequest> PlasmaContainsRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaContainsRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3490,8 +3490,8 @@ inline PlasmaContainsReplyT *PlasmaContainsReply::UnPack(const flatbuffers::reso
 inline void PlasmaContainsReply::UnPackTo(PlasmaContainsReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = has_object(); _o->has_object = _e; }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = has_object(); _o->has_object = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaContainsReply> PlasmaContainsReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaContainsReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3542,7 +3542,7 @@ inline PlasmaListReplyT *PlasmaListReply::UnPack(const flatbuffers::resolver_fun
 inline void PlasmaListReply::UnPackTo(PlasmaListReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = objects(); if (_e) { _o->objects.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->objects[_i] = std::unique_ptr<plasma::flatbuf::ObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
+  { auto _e = objects(); if (_e) { _o->objects.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->objects[_i] = std::unique_ptr<ObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
 }
 
 inline flatbuffers::Offset<PlasmaListReply> PlasmaListReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaListReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3552,9 +3552,9 @@ inline flatbuffers::Offset<PlasmaListReply> PlasmaListReply::Pack(flatbuffers::F
 inline flatbuffers::Offset<PlasmaListReply> CreatePlasmaListReply(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaListReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
   (void)_rehasher;
   (void)_o;
   struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlasmaListReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
-  auto _objects = _o->objects.size() ? _fbb.CreateVector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>> (_o->objects.size(), [](size_t i, _VectorArgs *__va) { return CreateObjectInfo(*__va->__fbb, __va->__o->objects[i].get(), __va->__rehasher); }, &_va ) : 0;
+  auto _objects = _o->objects.size() ? _fbb.CreateVector<flatbuffers::Offset<ObjectInfo>> (_o->objects.size(), [](size_t i, _VectorArgs *__va) { return CreateObjectInfo(*__va->__fbb, __va->__o->objects[i].get(), __va->__rehasher); }, &_va ) : 0;
   return plasma::flatbuf::CreatePlasmaListReply(
       _fbb,
       _objects);
 }
@@ -3591,7 +3591,7 @@ inline PlasmaConnectReplyT *PlasmaConnectReply::UnPack(const flatbuffers::resolv
 inline void PlasmaConnectReply::UnPackTo(PlasmaConnectReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = memory_capacity(); _o->memory_capacity = _e; }
+  { auto _e = memory_capacity(); _o->memory_capacity = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaConnectReply> PlasmaConnectReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaConnectReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3617,7 +3617,7 @@ inline PlasmaEvictRequestT *PlasmaEvictRequest::UnPack(const flatbuffers::resolv
 inline void PlasmaEvictRequest::UnPackTo(PlasmaEvictRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = num_bytes(); _o->num_bytes = _e; }
+  { auto _e = num_bytes(); _o->num_bytes = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaEvictRequest> PlasmaEvictRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaEvictRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3643,7 +3643,7 @@ inline PlasmaEvictReplyT *PlasmaEvictReply::UnPack(const flatbuffers::resolver_f
 inline void PlasmaEvictReply::UnPackTo(PlasmaEvictReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = num_bytes(); _o->num_bytes = _e; }
+  { auto _e = num_bytes(); _o->num_bytes = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaEvictReply> PlasmaEvictReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaEvictReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3692,7 +3692,7 @@ inline PlasmaNotificationT *PlasmaNotification::UnPack(const flatbuffers::resolv
 inline void PlasmaNotification::UnPackTo(PlasmaNotificationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_info(); if (_e) { _o->object_info.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_info[_i] = std::unique_ptr<plasma::flatbuf::ObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
+  { auto _e = object_info(); if (_e) { _o->object_info.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_info[_i] = std::unique_ptr<ObjectInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
 }
 
 inline flatbuffers::Offset<PlasmaNotification> PlasmaNotification::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaNotificationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3702,9 +3702,9 @@ inline flatbuffers::Offset<PlasmaNotification> PlasmaNotification::Pack(flatbuff
 inline flatbuffers::Offset<PlasmaNotification> CreatePlasmaNotification(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaNotificationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
   (void)_rehasher;
   (void)_o;
   struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlasmaNotificationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
-  auto _object_info = _o->object_info.size() ? _fbb.CreateVector<flatbuffers::Offset<plasma::flatbuf::ObjectInfo>> (_o->object_info.size(), [](size_t i, _VectorArgs *__va) { return CreateObjectInfo(*__va->__fbb, __va->__o->object_info[i].get(), __va->__rehasher); }, &_va ) : 0;
+  auto _object_info = _o->object_info.size() ? _fbb.CreateVector<flatbuffers::Offset<ObjectInfo>> (_o->object_info.size(), [](size_t i, _VectorArgs *__va) { return CreateObjectInfo(*__va->__fbb, __va->__o->object_info[i].get(), __va->__rehasher); }, &_va ) : 0;
   return plasma::flatbuf::CreatePlasmaNotification(
       _fbb,
       _object_info);
 }
@@ -3718,9 +3718,9 @@ inline PlasmaDataRequestT *PlasmaDataRequest::UnPack(const flatbuffers::resolver
 inline void PlasmaDataRequest::UnPackTo(PlasmaDataRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = address(); if (_e) _o->address = _e->str(); }
-  { auto _e = port(); _o->port = _e; }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = address(); if (_e) _o->address = _e->str(); };
+  { auto _e = port(); _o->port = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaDataRequest> PlasmaDataRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaDataRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3750,9 +3750,9 @@ inline PlasmaDataReplyT *PlasmaDataReply::UnPack(const flatbuffers::resolver_fun
 inline void PlasmaDataReply::UnPackTo(PlasmaDataReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); }
-  { auto _e = object_size(); _o->object_size = _e; }
-  { auto _e = metadata_size(); _o->metadata_size = _e; }
+  { auto _e = object_id(); if (_e) _o->object_id = _e->str(); };
+  { auto _e = object_size(); _o->object_size = _e; };
+  { auto _e = metadata_size(); _o->metadata_size = _e; };
 }
 
 inline flatbuffers::Offset<PlasmaDataReply> PlasmaDataReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaDataReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
@@ -3782,7 +3782,7 @@ inline PlasmaRefreshLRURequestT *PlasmaRefreshLRURequest::UnPack(const flatbuffe
 inline void PlasmaRefreshLRURequest::UnPackTo(PlasmaRefreshLRURequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
   (void)_o;
   (void)_resolver;
-  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } }
+  { auto _e = object_ids(); if (_e) { _o->object_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->object_ids[_i] = _e->Get(_i)->str(); } } };
 }
 
 inline flatbuffers::Offset<PlasmaRefreshLRURequest> PlasmaRefreshLRURequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlasmaRefreshLRURequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
