commit f65f8be1767690c34513b12605076287785fd148
Author: Sean Parkinson <sean@wolfssl.com>
Date:   Mon Nov 27 08:50:22 2023 +1000

    SSL: make temp X25519/X448 key failure
    
    On failure to make the temporary X25519/X448 key, free it as the type is
    stored in eccTempKeyPresent which also indicates a valid key is present.
    Otherwise on SSL free, it will default to freeing the key with ECC APIs.

diff --git a/src/internal.c b/src/internal.c
index d69696f65..0aaef81eb 100644
--- a/src/internal.c
+++ b/src/internal.c
@@ -32048,4710 +32048,4718 @@ int SetTicket(WOLFSSL* ssl, const byte* ticket, word32 length)
 /* handle processing of session_ticket (4) */
 static int DoSessionTicket(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
     word32 size)
 {
     word32 begin = *inOutIdx;
     word32 lifetime;
     word16 length;
     int    ret;
 
     if (ssl->expect_session_ticket == 0) {
         WOLFSSL_MSG("Unexpected session ticket");
         WOLFSSL_ERROR_VERBOSE(SESSION_TICKET_EXPECT_E);
         return SESSION_TICKET_EXPECT_E;
     }
 
     if (OPAQUE32_LEN > size)
         return BUFFER_ERROR;
 
     ato32(input + *inOutIdx, &lifetime);
     *inOutIdx += OPAQUE32_LEN;
 
     if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
         return BUFFER_ERROR;
 
     ato16(input + *inOutIdx, &length);
     *inOutIdx += OPAQUE16_LEN;
 
     if ((*inOutIdx - begin) + length > size)
         return BUFFER_ERROR;
 
     if ((ret = SetTicket(ssl, input + *inOutIdx, length)) != 0)
         return ret;
     *inOutIdx += length;
     if (length > 0) {
         ssl->timeout = lifetime;
         SetupSession(ssl);
 #ifndef NO_SESSION_CACHE
         AddSession(ssl);
 #endif
     }
 
     if (IsEncryptionOn(ssl, 0)) {
         *inOutIdx += ssl->keys.padSz;
     #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
         if (ssl->options.startedETMRead)
             *inOutIdx += MacSize(ssl);
     #endif
     }
 
     ssl->expect_session_ticket = 0;
 
     return 0;
 }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #endif /* HAVE_SESSION_TICKET */
 
 #endif /* NO_WOLFSSL_CLIENT */
 
 #ifndef NO_CERTS
 
 #ifdef WOLF_PRIVATE_KEY_ID
     int GetPrivateKeySigSize(WOLFSSL* ssl)
     {
         int sigSz = 0;
 
         if (ssl == NULL)
             return 0;
 
         switch (ssl->buffers.keyType) {
         #ifndef NO_RSA
         #ifdef WC_RSA_PSS
             case rsa_pss_sa_algo:
         #endif
             case rsa_sa_algo:
                 sigSz = ssl->buffers.keySz;
                 ssl->hsType = DYNAMIC_TYPE_RSA;
                 break;
         #endif
         #ifdef HAVE_ECC
             case ecc_dsa_sa_algo:
                 sigSz = wc_ecc_sig_size_calc(ssl->buffers.keySz);
                 ssl->hsType = DYNAMIC_TYPE_ECC;
                 break;
         #endif
         #ifdef HAVE_ED25519
             case ed25519_sa_algo:
                 sigSz = ED25519_SIG_SIZE; /* fixed known value */
                 ssl->hsType = DYNAMIC_TYPE_ED25519;
                 break;
         #endif
         #ifdef HAVE_ED448
             case ed448_sa_algo:
                 sigSz = ED448_SIG_SIZE; /* fixed known value */
                 ssl->hsType = DYNAMIC_TYPE_ED448;
                 break;
         #endif
             default:
                 break;
         }
         return sigSz;
     }
 #endif /* HAVE_PK_CALLBACKS */
 
 #endif /* NO_CERTS */
 
 #ifdef HAVE_ECC
     /* returns the WOLFSSL_* version of the curve from the OID sum */
     word16 GetCurveByOID(int oidSum) {
         switch(oidSum) {
     #if (defined(HAVE_ECC160) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 160
         #ifndef NO_ECC_SECP
             case ECC_SECP160R1_OID:
                 return WOLFSSL_ECC_SECP160R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_SECPR2
             case ECC_SECP160R2_OID:
                 return WOLFSSL_ECC_SECP160R2;
         #endif /* HAVE_ECC_SECPR2 */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP160K1_OID:
                 return WOLFSSL_ECC_SECP160K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if (defined(HAVE_ECC192) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 192
         #ifndef NO_ECC_SECP
             case ECC_SECP192R1_OID:
                 return WOLFSSL_ECC_SECP192R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP192K1_OID:
                 return WOLFSSL_ECC_SECP192K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if (defined(HAVE_ECC224) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 224
         #ifndef NO_ECC_SECP
             case ECC_SECP224R1_OID:
                 return WOLFSSL_ECC_SECP224R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP224K1_OID:
                 return WOLFSSL_ECC_SECP224K1;
         #endif /* HAVE_ECC_KOBLITZ */
     #endif
     #if (!defined(NO_ECC256)  || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 256
         #ifndef NO_ECC_SECP
             case ECC_SECP256R1_OID:
                 return WOLFSSL_ECC_SECP256R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_KOBLITZ
             case ECC_SECP256K1_OID:
                 return WOLFSSL_ECC_SECP256K1;
         #endif /* HAVE_ECC_KOBLITZ */
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP256R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP256R1;
         #endif /* HAVE_ECC_BRAINPOOL */
         #ifdef WOLFSSL_SM2
             case ECC_SM2P256V1_OID:
                 return WOLFSSL_ECC_SM2P256V1;
         #endif /* WOLFSSL_SM2 */
     #endif
     #if (defined(HAVE_ECC384) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 384
         #ifndef NO_ECC_SECP
             case ECC_SECP384R1_OID:
                 return WOLFSSL_ECC_SECP384R1;
         #endif /* !NO_ECC_SECP */
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP384R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP384R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if (defined(HAVE_ECC512) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 512
         #ifdef HAVE_ECC_BRAINPOOL
             case ECC_BRAINPOOLP512R1_OID:
                 return WOLFSSL_ECC_BRAINPOOLP512R1;
         #endif /* HAVE_ECC_BRAINPOOL */
     #endif
     #if (defined(HAVE_ECC521) || defined(HAVE_ALL_CURVES)) && ECC_MIN_KEY_SZ <= 521
         #ifndef NO_ECC_SECP
             case ECC_SECP521R1_OID:
                 return WOLFSSL_ECC_SECP521R1;
         #endif /* !NO_ECC_SECP */
     #endif
             default:
                 WOLFSSL_MSG("Curve OID not compiled in or implemented");
                 return 0;
         }
     }
 #endif /* HAVE_ECC */
 
     int TranslateErrorToAlert(int err)
     {
         switch (err) {
             case BUFFER_ERROR:
                 return decode_error;
             case EXT_NOT_ALLOWED:
             case PEER_KEY_ERROR:
             case ECC_PEERKEY_ERROR:
             case BAD_KEY_SHARE_DATA:
             case PSK_KEY_ERROR:
             case INVALID_PARAMETER:
             case HRR_COOKIE_ERROR:
                 return illegal_parameter;
             case INCOMPLETE_DATA:
                 return missing_extension;
             case MATCH_SUITE_ERROR:
             case MISSING_HANDSHAKE_DATA:
                 return handshake_failure;
             case VERSION_ERROR:
                 return wolfssl_alert_protocol_version;
             default:
                 return invalid_alert;
         }
     }
 
 
 #ifndef NO_WOLFSSL_SERVER
 
 #ifndef WOLFSSL_NO_TLS12
 
     /* handle generation of server_hello (2) */
     int SendServerHello(WOLFSSL* ssl)
     {
         int    ret;
         byte   *output;
         word16 length;
         word32 idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int    sendSz;
         byte   sessIdSz = ID_LEN;
     #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_SESSION_TICKET)
         byte   echoId   = 0;  /* ticket echo id flag */
     #endif
         byte   cacheOff = 0;  /* session cache off flag */
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_SEND);
         WOLFSSL_ENTER("SendServerHello");
 
         length = VERSION_SZ + RAN_LEN
                + ID_LEN + ENUM_LEN
                + SUITE_LEN
                + ENUM_LEN;
 
 #ifdef HAVE_TLS_EXTENSIONS
         ret = TLSX_GetResponseSize(ssl, server_hello, &length);
         if (ret != 0)
             return ret;
     #ifdef HAVE_SESSION_TICKET
         if (ssl->options.useTicket) {
             /* echo session id sz can be 0,32 or bogus len in between */
             sessIdSz = ssl->arrays->sessionIDSz;
             if (sessIdSz > ID_LEN) {
                 WOLFSSL_MSG("Bad bogus session id len");
                 return BUFFER_ERROR;
             }
             if (!IsAtLeastTLSv1_3(ssl->version))
                 length -= (ID_LEN - sessIdSz);  /* adjust ID_LEN assumption */
             echoId = 1;
         }
     #endif /* HAVE_SESSION_TICKET */
 #else
         if (ssl->options.haveEMS) {
             length += HELLO_EXT_SZ_SZ + HELLO_EXT_SZ;
         }
 #endif
 
         /* is the session cache off at build or runtime */
 #ifdef NO_SESSION_CACHE
         cacheOff = 1;
 #else
         if (ssl->options.sessionCacheOff == 1) {
             cacheOff = 1;
         }
 #endif
 
         /* if no session cache don't send a session ID unless we're echoing
          * an ID as part of session tickets */
         if (cacheOff == 1
         #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_SESSION_TICKET)
             && echoId == 0
         #endif
             ) {
             length -= ID_LEN;    /* adjust ID_LEN assumption */
             sessIdSz = 0;
         }
 
         sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
         #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls) {
             idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
         }
         #endif /* WOLFSSL_DTLS */
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* Set this in case CheckAvailableSize returns a WANT_WRITE so that state
          * is not advanced yet */
         ssl->options.buildingMsg = 1;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = GetOutputBuffer(ssl);
         AddHeaders(output, length, server_hello, ssl);
 
         /* now write to output */
         /* first version */
         output[idx++] = (byte)ssl->version.major;
         output[idx++] = (byte)ssl->version.minor;
 
         /* then random and session id */
         if (!ssl->options.resuming) {
             /* generate random part and session id */
             ret = wc_RNG_GenerateBlock(ssl->rng, output + idx,
                 RAN_LEN + sizeof(sessIdSz) + sessIdSz);
             if (ret != 0)
                 return ret;
 
 #ifdef WOLFSSL_TLS13
             if (TLSv1_3_Capable(ssl)) {
                 /* TLS v1.3 capable server downgraded. */
                 XMEMCPY(output + idx + RAN_LEN - (TLS13_DOWNGRADE_SZ + 1),
                         tls13Downgrade, TLS13_DOWNGRADE_SZ);
                 output[idx + RAN_LEN - 1] = (byte)IsAtLeastTLSv1_2(ssl);
             }
             else
 #endif
             if (ssl->ctx->method->version.major == SSLv3_MAJOR &&
                 ssl->ctx->method->version.minor == TLSv1_2_MINOR &&
                 (wolfSSL_get_options(ssl) & WOLFSSL_OP_NO_TLSv1_2) == 0 &&
                 !IsAtLeastTLSv1_2(ssl)) {
                 /* TLS v1.2 capable server downgraded. */
                 XMEMCPY(output + idx + RAN_LEN - (TLS13_DOWNGRADE_SZ + 1),
                         tls13Downgrade, TLS13_DOWNGRADE_SZ);
                 output[idx + RAN_LEN - 1] = 0;
             }
 
             /* store info in SSL for later */
             XMEMCPY(ssl->arrays->serverRandom, output + idx, RAN_LEN);
             idx += RAN_LEN;
             output[idx++] = sessIdSz;
             XMEMCPY(ssl->arrays->sessionID, output + idx, sessIdSz);
             ssl->arrays->sessionIDSz = sessIdSz;
         }
         else {
             /* If resuming, use info from SSL */
             XMEMCPY(output + idx, ssl->arrays->serverRandom, RAN_LEN);
             idx += RAN_LEN;
             output[idx++] = sessIdSz;
             XMEMCPY(output + idx, ssl->arrays->sessionID, sessIdSz);
         }
         idx += sessIdSz;
 
 #ifdef SHOW_SECRETS
         {
             int j;
             printf("server random: ");
             for (j = 0; j < RAN_LEN; j++)
                 printf("%02x", ssl->arrays->serverRandom[j]);
             printf("\n");
         }
 #endif
 
         /* then cipher suite */
         output[idx++] = ssl->options.cipherSuite0;
         output[idx++] = ssl->options.cipherSuite;
 
         /* then compression */
         if (ssl->options.usingCompression)
             output[idx++] = ZLIB_COMPRESSION;
         else
             output[idx++] = NO_COMPRESSION;
 
         /* last, extensions */
 #ifdef HAVE_TLS_EXTENSIONS
         {
             word16 offset = 0;
             ret = TLSX_WriteResponse(ssl, output + idx, server_hello, &offset);
             if (ret != 0)
                 return ret;
             idx += offset;
         }
 #else
 #ifdef HAVE_EXTENDED_MASTER
         if (ssl->options.haveEMS) {
             c16toa(HELLO_EXT_SZ, output + idx);
             idx += HELLO_EXT_SZ_SZ;
 
             c16toa(HELLO_EXT_EXTMS, output + idx);
             idx += HELLO_EXT_TYPE_SZ;
             c16toa(0, output + idx);
             /*idx += HELLO_EXT_SZ_SZ;*/
             /* idx is not used after this point. uncomment the line above
              * if adding any more extensions in the future. */
         }
 #endif
 #endif
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = idx; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls)
                 recordHeaderSz += DTLS_RECORD_EXTRA;
             inputSz -= recordHeaderSz;
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, server_hello)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, server_hello)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ServerHello");
         if (ssl->toInfoOn) {
             ret = AddPacketInfo(ssl, "ServerHello", handshake, output, sendSz,
                           WRITE_PROTO, 0, ssl->heap);
             if (ret != 0)
                 return ret;
         }
     #endif
 
         ssl->options.serverState = SERVER_HELLO_COMPLETE;
         ssl->options.buildingMsg = 0;
         ssl->buffers.outputBuffer.length += sendSz;
 
         if (ssl->options.groupMessages)
             ret = 0;
         else
             ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendServerHello", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_SEND);
 
         return ret;
     }
 
 
 #if defined(HAVE_ECC)
 
     static byte SetCurveId(ecc_key* key)
     {
         if (key == NULL || key->dp == NULL) {
             WOLFSSL_MSG("SetCurveId: Invalid key!");
             return 0;
         }
 
         return (byte)GetCurveByOID(key->dp->oidSum);
     }
 
 #endif /* HAVE_ECC */
 
     typedef struct SskeArgs {
         byte*  output; /* not allocated */
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         byte*  exportBuf;
     #endif
     #ifndef NO_RSA
         byte*  verifySig;
     #endif
         byte*  input;
         word32 idx;
         word32 tmpSigSz;
         word32 length;
         word32 sigSz;
     #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                                                                 !defined(NO_RSA)
         word32 sigDataSz;
     #endif
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         word32 exportSz;
     #endif
         int    sendSz;
         int    inputSz;
     } SskeArgs;
 
     static void FreeSskeArgs(WOLFSSL* ssl, void* pArgs)
     {
         SskeArgs* args = (SskeArgs*)pArgs;
 
         (void)ssl;
 
     #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
         if (args->exportBuf) {
             XFREE(args->exportBuf, ssl->heap, DYNAMIC_TYPE_DER);
             args->exportBuf = NULL;
         }
     #endif
     #ifndef NO_RSA
         if (args->verifySig) {
             XFREE(args->verifySig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
             args->verifySig = NULL;
         }
     #endif
         (void)args;
     }
 
     /* handle generation of server_key_exchange (12) */
     int SendServerKeyExchange(WOLFSSL* ssl)
     {
         int ret = 0;
     #ifdef WOLFSSL_ASYNC_IO
         SskeArgs* args = NULL;
         WOLFSSL_ASSERT_SIZEOF_GE(ssl->async->args, *args);
     #else
         SskeArgs  args[1];
     #endif
 
         WOLFSSL_START(WC_FUNC_SERVER_KEY_EXCHANGE_SEND);
         WOLFSSL_ENTER("SendServerKeyExchange");
 
     #ifdef WOLFSSL_ASYNC_IO
         if (ssl->async == NULL) {
             ssl->async = (struct WOLFSSL_ASYNC*)
                     XMALLOC(sizeof(struct WOLFSSL_ASYNC), ssl->heap,
                             DYNAMIC_TYPE_ASYNC);
             if (ssl->async == NULL)
                 ERROR_OUT(MEMORY_E, exit_sske);
             XMEMSET(ssl->async, 0, sizeof(struct WOLFSSL_ASYNC));
         }
         args = (SskeArgs*)ssl->async->args;
     #ifdef WOLFSSL_ASYNC_CRYPT
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NO_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_sske;
         }
         else
     #endif
         if (ssl->options.buildingMsg) {
             /* We should be in the sending state. */
             if (ssl->options.asyncState != TLS_ASYNC_END) {
                 ret = BAD_STATE_E;
                 goto exit_sske;
             }
         }
         else
     #endif
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(SskeArgs));
         #ifdef WOLFSSL_ASYNC_IO
             ssl->async->freeArgs = FreeSskeArgs;
         #endif
         }
 
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
                 /* Do some checks / debug msgs */
                 switch(ssl->specs.kea)
                 {
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         WOLFSSL_MSG("Using ephemeral ECDH PSK");
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC)
                     case ecc_diffie_hellman_kea:
                     {
                         if (ssl->specs.static_ecdh) {
                             WOLFSSL_MSG("Using Static ECDH, not sending "
                                         "ServerKeyExchange");
                             ERROR_OUT(0, exit_sske);
                         }
 
                         WOLFSSL_MSG("Using ephemeral ECDH");
                         break;
                     }
                 #endif /* HAVE_ECC */
                 }
 
                 /* Preparing keys */
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && (!defined(NO_PSK) || !defined(NO_RSA) \
                           || (defined(HAVE_ANON) && !defined(WOLFSSL_NO_TLS12)))
                 #if !defined(NO_PSK)
                     case dhe_psk_kea:
                 #endif
                 #if !defined(NO_RSA) || (defined(HAVE_ANON) && \
                                          !defined(WOLFSSL_NO_TLS12))
                     case diffie_hellman_kea:
                 #endif
 #if (defined(WOLFSSL_TLS13) || defined(HAVE_FFDHE)) && !defined(HAVE_PUBLIC_FFDHE)
                     if (ssl->namedGroup) {
                         word32 pSz = 0;
 
                         ret = wc_DhGetNamedKeyParamSize(ssl->namedGroup, &pSz,
                                 NULL, NULL);
                         if (ret != 0)
                             goto exit_sske;
 
                         if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and
                              * FreeHandshakeResources */
                             ssl->buffers.serverDH_Pub.buffer = (byte*)XMALLOC(
                                     pSz, ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
                             if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
                             ssl->buffers.serverDH_Pub.length = pSz;
                         }
                         ssl->options.dhKeySz =(word16)pSz;
 
                         pSz = wc_DhGetNamedKeyMinSize(ssl->namedGroup);
 
                         if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and
                              * FreeHandshakeResources */
                             ssl->buffers.serverDH_Priv.buffer = (byte*)XMALLOC(
                                     pSz, ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
                             if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
                             ssl->buffers.serverDH_Priv.length = pSz;
                         }
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_sske;
                         }
 
                         ret = wc_DhSetNamedKey(ssl->buffers.serverDH_Key,
                                 ssl->namedGroup);
                         if (ret != 0) {
                             goto exit_sske;
                         }
     #if !defined(WOLFSSL_OLD_PRIME_CHECK) && \
         !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
                         ssl->options.dhKeyTested = 1;
     #endif
 
                 #ifdef HAVE_SECURE_RENEGOTIATION
                         /* Check that the DH public key buffer is large
                          * enough to hold the key. This may occur on a
                          * renegotiation when the key generated in the
                          * initial handshake is shorter than the key
                          * generated in the renegotiation. */
                         if (ssl->buffers.serverDH_Pub.length <
                                 ssl->buffers.serverDH_P.length) {
                             byte* tmp = (byte*)XREALLOC(
                                     ssl->buffers.serverDH_Pub.buffer,
                                     ssl->buffers.serverDH_P.length +
                                         OPAQUE16_LEN,
                                     ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
                             if (tmp == NULL)
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             ssl->buffers.serverDH_Pub.buffer = tmp;
                             ssl->buffers.serverDH_Pub.length =
                                 ssl->buffers.serverDH_P.length + OPAQUE16_LEN;
                         }
                 #endif
 
                         ret = DhGenKeyPair(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             (word32*)&ssl->buffers.serverDH_Priv.length,
                             ssl->buffers.serverDH_Pub.buffer,
                             (word32*)&ssl->buffers.serverDH_Pub.length);
                     #ifdef WOLFSSL_CHECK_MEM_ZERO
                         wc_MemZero_Add("DH private key buffer",
                             ssl->buffers.serverDH_Priv.buffer,
                             ssl->buffers.serverDH_Priv.length);
                     #endif
                         break;
                     }
                     else
 #endif
                     {
                         /* Allocate DH key buffers and generate key */
                         if (ssl->buffers.serverDH_P.buffer == NULL ||
                             ssl->buffers.serverDH_G.buffer == NULL) {
                             ERROR_OUT(NO_DH_PARAMS, exit_sske);
                         }
 
                         if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and FreeHandshakeResources */
                             ssl->buffers.serverDH_Pub.buffer = (byte*)XMALLOC(
                                     ssl->buffers.serverDH_P.length,
                                     ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
                             if (ssl->buffers.serverDH_Pub.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
                             ssl->buffers.serverDH_Pub.length =
                                 ssl->buffers.serverDH_P.length;
                         }
 
                         if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                             /* Free'd in SSL_ResourceFree and FreeHandshakeResources */
                             ssl->buffers.serverDH_Priv.buffer = (byte*)XMALLOC(
                                     ssl->buffers.serverDH_P.length,
                                     ssl->heap, DYNAMIC_TYPE_PRIVATE_KEY);
                             if (ssl->buffers.serverDH_Priv.buffer == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             }
                             ssl->buffers.serverDH_Priv.length =
                                 ssl->buffers.serverDH_P.length;
                         }
 
                         ssl->options.dhKeySz =
                                 (word16)ssl->buffers.serverDH_P.length;
 
                         ret = AllocKey(ssl, DYNAMIC_TYPE_DH,
                                             (void**)&ssl->buffers.serverDH_Key);
                         if (ret != 0) {
                             goto exit_sske;
                         }
 
                         #if !defined(WOLFSSL_OLD_PRIME_CHECK) && \
                             !defined(HAVE_FIPS) && \
                             !defined(HAVE_SELFTEST)
                         if (ssl->options.dhDoKeyTest &&
                             !ssl->options.dhKeyTested)
                         {
                             ret = wc_DhSetCheckKey(
                                 ssl->buffers.serverDH_Key,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length,
                                 NULL, 0, 0, ssl->rng);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                             ssl->options.dhKeyTested = 1;
                         }
                         else
                         #endif
                         {
                             ret = wc_DhSetKey(ssl->buffers.serverDH_Key,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                 #ifdef HAVE_SECURE_RENEGOTIATION
                         /* Check that the DH public key buffer is large
                          * enough to hold the key. This may occur on a
                          * renegotiation when the key generated in the
                          * initial handshake is shorter than the key
                          * generated in the renegotiation. */
                         if (ssl->buffers.serverDH_Pub.length <
                                 ssl->buffers.serverDH_P.length) {
                             byte* tmp = (byte*)XREALLOC(
                                     ssl->buffers.serverDH_Pub.buffer,
                                     ssl->buffers.serverDH_P.length +
                                         OPAQUE16_LEN,
                                     ssl->heap, DYNAMIC_TYPE_PUBLIC_KEY);
                             if (tmp == NULL)
                                 ERROR_OUT(MEMORY_E, exit_sske);
                             ssl->buffers.serverDH_Pub.buffer = tmp;
                             ssl->buffers.serverDH_Pub.length =
                                 ssl->buffers.serverDH_P.length + OPAQUE16_LEN;
                         }
                 #endif
                         ret = DhGenKeyPair(ssl, ssl->buffers.serverDH_Key,
                             ssl->buffers.serverDH_Priv.buffer,
                             (word32*)&ssl->buffers.serverDH_Priv.length,
                             ssl->buffers.serverDH_Pub.buffer,
                             (word32*)&ssl->buffers.serverDH_Pub.length);
                     #ifdef WOLFSSL_CHECK_MEM_ZERO
                         wc_MemZero_Add("DH private key buffer",
                             ssl->buffers.serverDH_Priv.buffer,
                             ssl->buffers.serverDH_Priv.length);
                     #endif
                         break;
                     }
                 #endif /* !NO_DH && (!NO_PSK || !NO_RSA) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                         /* Fall through to create temp ECC key */
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || \
                     ((defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)) && \
                      (defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                       !defined(NO_RSA)))
                     case ecc_diffie_hellman_kea:
                     {
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             /* need ephemeral key now, create it if missing */
                             if (ssl->eccTempKey == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
                                     (void**)&ssl->eccTempKey);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 ret = X25519MakeKey(ssl,
                                         (curve25519_key*)ssl->eccTempKey, NULL);
                                 if (ret == 0 || ret == WC_PENDING_E) {
                                     ssl->eccTempKeyPresent =
                                         DYNAMIC_TYPE_CURVE25519;
                                 }
+                                else {
+                                    FreeKey(ssl, DYNAMIC_TYPE_CURVE25519,
+                                    (void**)&ssl->eccTempKey);
+                                }
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             /* need ephemeral key now, create it if missing */
                             if (ssl->eccTempKey == NULL) {
                                 /* alloc/init on demand */
                                 ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE448,
                                     (void**)&ssl->eccTempKey);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             if (ssl->eccTempKeyPresent == 0) {
                                 ret = X448MakeKey(ssl,
                                           (curve448_key*)ssl->eccTempKey, NULL);
                                 if (ret == 0 || ret == WC_PENDING_E) {
                                     ssl->eccTempKeyPresent =
                                         DYNAMIC_TYPE_CURVE448;
                                 }
+                                else {
+                                    FreeKey(ssl, DYNAMIC_TYPE_CURVE448,
+                                    (void**)&ssl->eccTempKey);
+                                }
                             }
                             break;
                         }
                     #endif
                     #ifdef HAVE_ECC
                         /* need ephemeral key now, create it if missing */
                         if (ssl->eccTempKey == NULL) {
                             /* alloc/init on demand */
                             ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
                                 (void**)&ssl->eccTempKey);
                             if (ret != 0) {
                                 goto exit_sske;
                             }
                         }
 
                         if (ssl->eccTempKeyPresent == 0) {
                             ret = EccMakeKey(ssl, ssl->eccTempKey, NULL);
                             if (ret == 0 || ret == WC_PENDING_E) {
                                 ssl->eccTempKeyPresent = DYNAMIC_TYPE_ECC;
                             }
                         }
                     #endif
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                     default:
                         /* Skip ServerKeyExchange */
                         goto exit_sske;
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* case TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
 
                         if (ssl->arrays->server_hint[0] == 0) {
                             ERROR_OUT(0, exit_sske); /* don't send */
                         }
 
                         /* include size part */
                         args->length = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (args->length > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
 
                         args->length += HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* Use tmp buffer */
                         args->input = (byte*)XMALLOC(args->sendSz,
                                 ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                         if (args->input == NULL)
                             ERROR_OUT(MEMORY_E, exit_sske);
                         args->output = args->input;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* key data */
                         c16toa((word16)(args->length - HINT_LEN_SZ),
                                                       args->output + args->idx);
 
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->arrays->server_hint,
                                 args->length - HINT_LEN_SZ);
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         word32 hintLen;
 
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = LENGTH_SZ * 3 + /* p, g, pub */
                                  ssl->buffers.serverDH_P.length +
                                  ssl->buffers.serverDH_G.length +
                                  ssl->buffers.serverDH_Pub.length;
 
                         /* include size part */
                         hintLen = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (hintLen > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
                         args->length += hintLen + HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* Use tmp buffer */
                         args->input = (byte*)XMALLOC(args->sendSz,
                                 ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                         if (args->input == NULL)
                             ERROR_OUT(MEMORY_E, exit_sske);
                         args->output = args->input;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* key data */
                         c16toa((word16)hintLen, args->output + args->idx);
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                             ssl->arrays->server_hint, hintLen);
                         args->idx += hintLen;
 
                         /* add p, g, pub */
                         c16toa((word16)ssl->buffers.serverDH_P.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_P.buffer,
                                 ssl->buffers.serverDH_P.length);
                         args->idx += ssl->buffers.serverDH_P.length;
 
                         /*  g */
                         c16toa((word16)ssl->buffers.serverDH_G.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_G.buffer,
                                 ssl->buffers.serverDH_G.length);
                         args->idx += ssl->buffers.serverDH_G.length;
 
                         /*  pub */
                         c16toa((word16)ssl->buffers.serverDH_Pub.length,
                             args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                 ssl->buffers.serverDH_Pub.buffer,
                                 ssl->buffers.serverDH_Pub.length);
                         /* No need to update idx, since sizes are already set */
                         /* args->idx += ssl->buffers.serverDH_Pub.length; */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         word32 hintLen;
 
                         /* curve type, named curve, length(1) */
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;
 
                         args->exportSz = MAX_EXPORT_ECC_SZ;
                         args->exportBuf = (byte*)XMALLOC(MAX_EXPORT_ECC_SZ,
                                             ssl->heap, DYNAMIC_TYPE_DER);
                         if (args->exportBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             if (wc_curve25519_export_public_ex(
                                     (curve25519_key*)ssl->eccTempKey,
                                     args->exportBuf, &args->exportSz,
                                     EC25519_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             if (wc_curve448_export_public_ex(
                                     (curve448_key*)ssl->eccTempKey,
                                     args->exportBuf, &args->exportSz,
                                     EC448_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                         {
                             PRIVATE_KEY_UNLOCK();
                             ret = wc_ecc_export_x963(ssl->eccTempKey,
                                        args->exportBuf, &args->exportSz);
                             PRIVATE_KEY_LOCK();
                             if (ret != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         args->length += args->exportSz;
 
                         /* include size part */
                         hintLen = (word32)XSTRLEN(ssl->arrays->server_hint);
                         if (hintLen > MAX_PSK_ID_LEN) {
                             ERROR_OUT(SERVER_HINT_ERROR, exit_sske);
                         }
                         args->length += hintLen + HINT_LEN_SZ;
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* Use tmp buffer */
                         args->input = (byte*)XMALLOC(args->sendSz,
                                 ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                         if (args->input == NULL)
                             ERROR_OUT(MEMORY_E, exit_sske);
                         args->output = args->input;
 
                         /* key data */
                         c16toa((word16)hintLen, args->output + args->idx);
                         args->idx += HINT_LEN_SZ;
                         XMEMCPY(args->output + args->idx,
                                             ssl->arrays->server_hint, hintLen);
                         args->idx += hintLen;
 
                         /* ECC key exchange data */
                         args->output[args->idx++] = named_curve;
                         args->output[args->idx++] = 0x00;          /* leading zero */
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X25519;
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X448;
                         else
                     #endif
                         {
                     #ifdef HAVE_ECC
                             args->output[args->idx++] =
                                                     SetCurveId(ssl->eccTempKey);
                     #endif
                         }
                         args->output[args->idx++] = (byte)args->exportSz;
                         XMEMCPY(args->output + args->idx, args->exportBuf,
                                                                 args->exportSz);
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || \
                     ((defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)) && \
                      (defined(HAVE_ED25519) || defined(HAVE_ED448) || \
                       !defined(NO_RSA)))
                     case ecc_diffie_hellman_kea:
                     {
                         enum wc_HashType hashType;
                         word32 preSigSz, preSigIdx;
 
                         /* curve type, named curve, length(1) */
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;
 
                         /* Export temp ECC key and add to length */
                         args->exportSz = MAX_EXPORT_ECC_SZ;
                         args->exportBuf = (byte*)XMALLOC(MAX_EXPORT_ECC_SZ,
                                             ssl->heap, DYNAMIC_TYPE_DER);
                         if (args->exportBuf == NULL) {
                             ERROR_OUT(MEMORY_E, exit_sske);
                         }
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID) {
                             if (wc_curve25519_export_public_ex(
                                         (curve25519_key*)ssl->eccTempKey,
                                         args->exportBuf, &args->exportSz,
                                         EC25519_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID) {
                             if (wc_curve448_export_public_ex(
                                         (curve448_key*)ssl->eccTempKey,
                                         args->exportBuf, &args->exportSz,
                                         EC448_LITTLE_ENDIAN) != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                         }
                         else
                     #endif
                         {
                     #if defined(HAVE_ECC) && defined(HAVE_ECC_KEY_EXPORT)
                             PRIVATE_KEY_UNLOCK();
                             ret = wc_ecc_export_x963(ssl->eccTempKey,
                                     args->exportBuf, &args->exportSz);
                             PRIVATE_KEY_LOCK();
                             if (ret != 0) {
                                 ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
                             }
                     #endif
                         }
                         args->length += args->exportSz;
 
                         preSigSz  = args->length;
                         preSigIdx = args->idx;
 
                         if (ssl->buffers.key == NULL) {
                         #ifdef HAVE_PK_CALLBACKS
                             if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx)) {
                                 args->tmpSigSz = GetPrivateKeySigSize(ssl);
                                 if (args->tmpSigSz == 0) {
                                     ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                                 }
                             }
                             else
                         #endif
                                 ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                         }
                         else {
                             switch(ssl->options.sigAlgo) {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = rsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 args->tmpSigSz = (word32)keySz;
                                 break;
                             }
                         #endif /* !NO_RSA */
                         #ifdef HAVE_ECC
                         #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                             case sm2_sa_algo:
                         #endif
                             case ecc_dsa_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ecc_dsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                                 /* worst case estimate */
                                 args->tmpSigSz = keySz;
                                 break;
                             }
                         #endif
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ed25519_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 /* worst case estimate */
                                 args->tmpSigSz = ED25519_SIG_SIZE;
                                 break;
                             }
                         #endif /* HAVE_ED25519 */
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                             {
                                 word16 keySz;
 
                                 ssl->buffers.keyType = ed448_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
 
                                 /* worst case estimate */
                                 args->tmpSigSz = ED448_SIG_SIZE;
                                 break;
                             }
                         #endif /* HAVE_ED448 */
                             default:
                                 ERROR_OUT(ALGO_ID_E, exit_sske);  /* unsupported type */
                             } /* switch(ssl->specs.sig_algo) */
                         }
 
                         /* sig length */
                         args->length += LENGTH_SZ;
                         args->length += args->tmpSigSz;
 
                         if (IsAtLeastTLSv1_2(ssl)) {
                             args->length += HASH_SIG_SIZE;
                         }
 
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             preSigIdx = args->idx;
                         }
                     #endif
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* Use tmp buffer */
                         args->input = (byte*)XMALLOC(args->sendSz,
                                 ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                         if (args->input == NULL)
                             ERROR_OUT(MEMORY_E, exit_sske);
                         args->output = args->input;
 
                         /* record and message headers will be added below, when we're sure
                            of the sig length */
 
                         /* key exchange data */
                         args->output[args->idx++] = named_curve;
                         args->output[args->idx++] = 0x00;          /* leading zero */
                     #ifdef HAVE_CURVE25519
                         if (ssl->ecdhCurveOID == ECC_X25519_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X25519;
                         else
                     #endif
                     #ifdef HAVE_CURVE448
                         if (ssl->ecdhCurveOID == ECC_X448_OID)
                             args->output[args->idx++] = WOLFSSL_ECC_X448;
                         else
                     #endif
                         {
                     #ifdef HAVE_ECC
                             args->output[args->idx++] =
                                                     SetCurveId(ssl->eccTempKey);
                     #endif
                         }
                         args->output[args->idx++] = (byte)args->exportSz;
                         XMEMCPY(args->output + args->idx, args->exportBuf, args->exportSz);
                         args->idx += args->exportSz;
 
                         /* Determine hash type */
                         if (IsAtLeastTLSv1_2(ssl)) {
                             EncodeSigAlg(ssl->options.hashAlgo,
                                          ssl->options.sigAlgo,
                                          &args->output[args->idx]);
                             args->idx += 2;
 
                             hashType = HashAlgoToType(ssl->options.hashAlgo);
                             if (hashType == WC_HASH_TYPE_NONE) {
                                 ERROR_OUT(ALGO_ID_E, exit_sske);
                             }
 
                         } else {
                             /* only using sha and md5 for rsa */
                         #ifndef NO_OLD_TLS
                             hashType = WC_HASH_TYPE_SHA;
                             if (ssl->options.sigAlgo == rsa_sa_algo) {
                                 hashType = WC_HASH_TYPE_MD5_SHA;
                             }
                         #else
                             ERROR_OUT(ALGO_ID_E, exit_sske);
                         #endif
                         }
 
                         /* Signature length will be written later, when we're sure what it is */
 
                     #ifdef HAVE_FUZZER
                         if (ssl->fuzzerCb) {
                             ssl->fuzzerCb(ssl, args->output + preSigIdx,
                                 preSigSz, FUZZ_SIGNATURE, ssl->fuzzerCtx);
                         }
                     #endif
 
                         ret = HashSkeData(ssl, hashType,
                             args->output + preSigIdx, preSigSz,
                             ssl->options.sigAlgo);
                         if (ret != 0) {
                             goto exit_sske;
                         }
 
                         args->sigSz = args->tmpSigSz;
 
                         /* Sign hash to create signature */
                         switch (ssl->options.sigAlgo)
                         {
                         #ifndef NO_RSA
                             case rsa_sa_algo:
                             {
                                 /* For TLS 1.2 re-encode signature */
                                 if (IsAtLeastTLSv1_2(ssl)) {
                                     byte* encodedSig = (byte*)XMALLOC(
                                                   MAX_ENCODED_SIG_SZ, ssl->heap,
                                                            DYNAMIC_TYPE_DIGEST);
                                     if (encodedSig == NULL) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
 
                                     ssl->buffers.digest.length =
                                         wc_EncodeSignature(encodedSig,
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             TypeHash(ssl->options.hashAlgo));
 
                                     /* Replace sig buffer with new one */
                                     if (!ssl->options.dontFreeDigest) {
                                         XFREE(ssl->buffers.digest.buffer,
                                             ssl->heap, DYNAMIC_TYPE_DIGEST);
                                     }
                                     ssl->options.dontFreeDigest = 0;
                                     ssl->buffers.digest.buffer = encodedSig;
                                 }
 
                                 /* write sig size here */
                                 c16toa((word16)args->sigSz,
                                     args->output + args->idx);
                                 args->idx += LENGTH_SZ;
                                 break;
                             }
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                                 /* write sig size here */
                                 c16toa((word16)args->sigSz,
                                     args->output + args->idx);
                                 args->idx += LENGTH_SZ;
                                 break;
                         #endif
                         #endif /* !NO_RSA */
                         #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                             case sm2_sa_algo:
                         #endif
                             case ecc_dsa_sa_algo:
                             {
                                 break;
                             }
                         #ifdef  HAVE_ED25519
                             case ed25519_sa_algo:
                                 ret = Ed25519CheckPubKey(ssl);
                                 if (ret != 0)
                                     goto exit_sske;
                                 break;
                         #endif /* HAVE_ED25519 */
                         #ifdef  HAVE_ED448
                             case ed448_sa_algo:
                                 ret = Ed448CheckPubKey(ssl);
                                 if (ret != 0)
                                     goto exit_sske;
                                 break;
                         #endif /* HAVE_ED448 */
                             default:
                                 break;
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && (!defined(NO_RSA) || \
                              (defined(HAVE_ANON) && !defined(WOLFSSL_NO_TLS12)))
                     case diffie_hellman_kea:
                     {
                         enum wc_HashType hashType;
                         word32 preSigSz, preSigIdx;
 
                         args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
                         args->length = LENGTH_SZ * 3;  /* p, g, pub */
                         args->length += ssl->buffers.serverDH_P.length +
                                         ssl->buffers.serverDH_G.length +
                                         ssl->buffers.serverDH_Pub.length;
 
                         preSigIdx = args->idx;
                         preSigSz  = args->length;
 
                         if (!ssl->options.usingAnon_cipher) {
                             word16 keySz = 0;
 
                             /* sig length */
                             args->length += LENGTH_SZ;
 
                             if (ssl->buffers.key == NULL) {
                             #ifdef HAVE_PK_CALLBACKS
                                 if (wolfSSL_CTX_IsPrivatePkSet(ssl->ctx))
                                     keySz = (word32)GetPrivateKeySigSize(ssl);
                                 else
                             #endif
                                     ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
                             }
                             else
                             {
                                 if (ssl->buffers.keyType == 0)
                                     ssl->buffers.keyType = rsa_sa_algo;
                                 ret = DecodePrivateKey(ssl, &keySz);
                                 if (ret != 0) {
                                     goto exit_sske;
                                 }
                             }
 
                             /* test if keySz has error */
                             if (keySz == 0) {
                                 ERROR_OUT(keySz, exit_sske);
                             }
 
                             args->tmpSigSz = (word32)keySz;
                             args->length += args->tmpSigSz;
 
                             if (IsAtLeastTLSv1_2(ssl)) {
                                 args->length += HASH_SIG_SIZE;
                             }
                         }
 
                         args->sendSz = args->length + HANDSHAKE_HEADER_SZ +
                                                             RECORD_HEADER_SZ;
 
                     #ifdef WOLFSSL_DTLS
                         if (ssl->options.dtls) {
                             args->sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             args->idx    += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
                             preSigIdx = args->idx;
                         }
                     #endif
 
                         if (IsEncryptionOn(ssl, 1)) {
                             args->sendSz += MAX_MSG_EXTRA;
                         }
 
                         /* Use tmp buffer */
                         args->input = (byte*)XMALLOC(args->sendSz,
                                 ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                         if (args->input == NULL)
                             ERROR_OUT(MEMORY_E, exit_sske);
                         args->output = args->input;
 
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
 
                         /* add p, g, pub */
                         c16toa((word16)ssl->buffers.serverDH_P.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_P.buffer,
                                               ssl->buffers.serverDH_P.length);
                         args->idx += ssl->buffers.serverDH_P.length;
 
                         /*  g */
                         c16toa((word16)ssl->buffers.serverDH_G.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_G.buffer,
                                               ssl->buffers.serverDH_G.length);
                         args->idx += ssl->buffers.serverDH_G.length;
 
                         /*  pub */
                         c16toa((word16)ssl->buffers.serverDH_Pub.length,
                                                     args->output + args->idx);
                         args->idx += LENGTH_SZ;
                         XMEMCPY(args->output + args->idx,
                                               ssl->buffers.serverDH_Pub.buffer,
                                               ssl->buffers.serverDH_Pub.length);
                         args->idx += ssl->buffers.serverDH_Pub.length;
 
                     #ifdef HAVE_FUZZER
                         if (ssl->fuzzerCb) {
                             ssl->fuzzerCb(ssl, args->output + preSigIdx,
                                 preSigSz, FUZZ_SIGNATURE, ssl->fuzzerCtx);
                         }
                     #endif
 
                         if (ssl->options.usingAnon_cipher) {
                             break;
                         }
 
                         /* Determine hash type */
                         if (IsAtLeastTLSv1_2(ssl)) {
                             EncodeSigAlg(ssl->options.hashAlgo,
                                          ssl->options.sigAlgo,
                                          &args->output[args->idx]);
                             args->idx += 2;
 
                             hashType = HashAlgoToType(ssl->options.hashAlgo);
                             if (hashType == WC_HASH_TYPE_NONE) {
                                 ERROR_OUT(ALGO_ID_E, exit_sske);
                             }
                         } else {
                             /* only using sha and md5 for rsa */
                         #ifndef NO_OLD_TLS
                             hashType = WC_HASH_TYPE_SHA;
                             if (ssl->options.sigAlgo == rsa_sa_algo) {
                                 hashType = WC_HASH_TYPE_MD5_SHA;
                             }
                         #else
                             ERROR_OUT(ALGO_ID_E, exit_sske);
                         #endif
                         }
 
                         /* signature size */
                         c16toa((word16)args->tmpSigSz, args->output + args->idx);
                         args->idx += LENGTH_SZ;
 
                         ret = HashSkeData(ssl, hashType,
                             args->output + preSigIdx, preSigSz,
                             ssl->options.sigAlgo);
                         if (ret != 0) {
                             goto exit_sske;
                         }
 
                         args->sigSz = args->tmpSigSz;
 
                         /* Sign hash to create signature */
                         switch (ssl->options.sigAlgo)
                         {
                         #ifndef NO_RSA
                             case rsa_sa_algo:
                             {
                                 /* For TLS 1.2 re-encode signature */
                                 if (IsAtLeastTLSv1_2(ssl)) {
                                     byte* encodedSig = (byte*)XMALLOC(
                                                   MAX_ENCODED_SIG_SZ, ssl->heap,
                                                            DYNAMIC_TYPE_DIGEST);
                                     if (encodedSig == NULL) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
 
                                     ssl->buffers.digest.length =
                                         wc_EncodeSignature(encodedSig,
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             TypeHash(ssl->options.hashAlgo));
 
                                     /* Replace sig buffer with new one */
                                     if (!ssl->options.dontFreeDigest) {
                                         XFREE(ssl->buffers.digest.buffer,
                                             ssl->heap, DYNAMIC_TYPE_DIGEST);
                                     }
                                     ssl->options.dontFreeDigest = 0;
                                     ssl->buffers.digest.buffer = encodedSig;
                                 }
                                 break;
                             }
                         #endif /* NO_RSA */
                             default:
                                 break;
                         } /* switch (ssl->options.sigAlgo) */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                     default:
                         break;
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* case TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC)  || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         /* Sign hash to create signature */
                         switch (ssl->options.sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 ret = RsaSign(ssl,
                                     ssl->buffers.digest.buffer,
                                     ssl->buffers.digest.length,
                                     args->output + args->idx,
                                     &args->sigSz,
                                     ssl->options.sigAlgo, ssl->options.hashAlgo,
                                     key,
                                     ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif /* !NO_RSA */
                         #ifdef HAVE_ECC
                         #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                             case sm2_sa_algo:
                             {
                                 ecc_key* key = (ecc_key*)ssl->hsKey;
 
                                 ret = Sm2wSm3Sign(ssl,
                                     TLS12_SM2_SIG_ID, TLS12_SM2_SIG_ID_SZ,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif
                             case ecc_dsa_sa_algo:
                             {
                                 ecc_key* key = (ecc_key*)ssl->hsKey;
 
                                 ret = EccSign(ssl,
                                     ssl->buffers.digest.buffer,
                                     ssl->buffers.digest.length,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif /* HAVE_ECC */
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                             {
                                 ed25519_key* key = (ed25519_key*)ssl->hsKey;
 
                                 ret = Ed25519Sign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                             {
                                 ed448_key* key = (ed448_key*)ssl->hsKey;
 
                                 ret = Ed448Sign(ssl,
                                     ssl->buffers.sig.buffer,
                                     ssl->buffers.sig.length,
                                     args->output + LENGTH_SZ + args->idx,
                                     &args->sigSz,
                                     key,
                             #ifdef HAVE_PK_CALLBACKS
                                     ssl->buffers.key
                             #else
                                     NULL
                             #endif
                                 );
                                 break;
                             }
                         #endif
                             default:
                                 ERROR_OUT(ALGO_ID_E, exit_sske);
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         /* Sign hash to create signature */
                         switch (ssl->options.sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (ssl->options.usingAnon_cipher) {
                                     break;
                                 }
 
                                 ret = RsaSign(ssl,
                                     ssl->buffers.digest.buffer,
                                     ssl->buffers.digest.length,
                                     args->output + args->idx,
                                     &args->sigSz,
                                     ssl->options.sigAlgo, ssl->options.hashAlgo,
                                     key,
                                     ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif /* NO_RSA */
                             default:
                                 break;
                         } /* switch (ssl->options.sigAlgo) */
 
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                     default:
                         break;
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* case TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
                 switch(ssl->specs.kea)
                 {
                 #ifndef NO_PSK
                     case psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !NO_PSK */
                 #if !defined(NO_DH) && !defined(NO_PSK)
                     case dhe_psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_PSK) */
                 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) ||  \
                                      defined(HAVE_CURVE448)) && !defined(NO_PSK)
                     case ecdhe_psk_kea:
                     {
                         /* Nothing to do in this sub-state */
                         break;
                     }
                 #endif /* (HAVE_ECC || CURVE25519 || CURVE448) && !NO_PSK */
                 #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                     case ecc_diffie_hellman_kea:
                     {
                         switch(ssl->options.sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifdef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (args->verifySig == NULL) {
                                     if (args->sigSz == 0) {
                                         ERROR_OUT(BAD_COND_E, exit_sske);
                                     }
                                     args->verifySig = (byte*)XMALLOC(
                                                     args->sigSz, ssl->heap,
                                                     DYNAMIC_TYPE_SIGNATURE);
                                     if (!args->verifySig) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
                                     XMEMCPY(args->verifySig,
                                         args->output + args->idx, args->sigSz);
                                 }
 
                                 /* check for signature faults */
                                 ret = VerifyRsaSign(ssl,
                                     args->verifySig, args->sigSz,
                                     ssl->buffers.digest.buffer,
                                     ssl->buffers.digest.length,
                                     ssl->options.sigAlgo, ssl->options.hashAlgo,
                                     key, ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif
                         #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                             case sm2_sa_algo:
                         #endif /* WOLFSSL_SM2 */
                             case ecc_dsa_sa_algo:
                         #ifdef WOLFSSL_CHECK_SIG_FAULTS
                             {
                                 ecc_key* key = (ecc_key*)ssl->hsKey;
 
                             #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                                 if (ssl->options.sigAlgo == sm2_sa_algo) {
                                     ret = Sm2wSm3Verify(ssl,
                                         TLS12_SM2_SIG_ID, TLS12_SM2_SIG_ID_SZ,
                                         args->output + LENGTH_SZ + args->idx,
                                         args->sigSz,
                                         ssl->buffers.sig.buffer,
                                         ssl->buffers.sig.length,
                                         key,
                                     #ifdef HAVE_PK_CALLBACKS
                                         ssl->buffers.key
                                     #else
                                         NULL
                                     #endif
                                     );
                                 }
                                 else
                             #endif /* WOLFSSL_SM2 */
                                 {
                                     ret = EccVerify(ssl,
                                         args->output + LENGTH_SZ + args->idx,
                                         args->sigSz,
                                         ssl->buffers.digest.buffer,
                                         ssl->buffers.digest.length,
                                         key,
                                     #ifdef HAVE_PK_CALLBACKS
                                         ssl->buffers.key
                                     #else
                                         NULL
                                     #endif
                                     );
                                 }
                                 if (ret != 0) {
                                     WOLFSSL_MSG(
                                         "Failed to verify ECC signature");
                                     goto exit_sske;
                                 }
                             }
                             #if defined(HAVE_E25519) || defined(HAVE_ED448)
                             FALL_THROUGH;
                             #endif
                         #endif /*  WOLFSSL_CHECK_SIG_FAULTS */
                         #ifdef HAVE_ED25519
                             case ed25519_sa_algo:
                         #endif
                         #ifdef HAVE_ED448
                             case ed448_sa_algo:
                         #endif
                             {
                                 /* Now that we know the real sig size, write it. */
                                 c16toa((word16)args->sigSz,
                                                     args->output + args->idx);
 
                                 /* And adjust length and sendSz from estimates */
                                 args->length += args->sigSz - args->tmpSigSz;
                                 args->sendSz += args->sigSz - args->tmpSigSz;
                                 break;
                             }
                             default:
                                 ERROR_OUT(ALGO_ID_E, exit_sske);  /* unsupported type */
                         } /* switch(ssl->specs.sig_algo) */
                         break;
                     }
                 #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
                 #if !defined(NO_DH) && !defined(NO_RSA)
                     case diffie_hellman_kea:
                     {
                         switch (ssl->options.sigAlgo)
                         {
                         #ifndef NO_RSA
                         #ifndef WC_RSA_PSS
                             case rsa_pss_sa_algo:
                         #endif
                             case rsa_sa_algo:
                             {
                                 RsaKey* key = (RsaKey*)ssl->hsKey;
 
                                 if (ssl->options.usingAnon_cipher) {
                                     break;
                                 }
 
                                 if (args->verifySig == NULL) {
                                     if (args->sigSz == 0) {
                                         ERROR_OUT(BAD_COND_E, exit_sske);
                                     }
                                     args->verifySig = (byte*)XMALLOC(
                                                       args->sigSz, ssl->heap,
                                                       DYNAMIC_TYPE_SIGNATURE);
                                     if (!args->verifySig) {
                                         ERROR_OUT(MEMORY_E, exit_sske);
                                     }
                                     XMEMCPY(args->verifySig,
                                         args->output + args->idx, args->sigSz);
                                 }
 
                                 /* check for signature faults */
                                 ret = VerifyRsaSign(ssl,
                                     args->verifySig, args->sigSz,
                                     ssl->buffers.digest.buffer,
                                     ssl->buffers.digest.length,
                                     ssl->options.sigAlgo, ssl->options.hashAlgo,
                                     key, ssl->buffers.key
                                 );
                                 break;
                             }
                         #endif
                         } /* switch (ssl->options.sigAlgo) */
                         break;
                     }
                 #endif /* !defined(NO_DH) && !defined(NO_RSA) */
                     default:
                         break;
                 } /* switch(ssl->specs.kea) */
 
                 /* Check for error */
                 if (ret != 0) {
                     goto exit_sske;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* case TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
             #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                                                           defined(HAVE_CURVE448)
                 if (ssl->specs.kea == ecdhe_psk_kea ||
                     ssl->specs.kea == ecc_diffie_hellman_kea) {
                     /* Check output to make sure it was set */
                     if (args->output) {
                         AddHeaders(args->output, args->length,
                                                     server_key_exchange, ssl);
                     }
                     else {
                         ERROR_OUT(BUFFER_ERROR, exit_sske);
                     }
                 }
             #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* case TLS_ASYNC_FINALIZE */
             FALL_THROUGH;
 
             case TLS_ASYNC_END:
             {
                 ret = SendHandshakeMsg(ssl, args->output, args->length,
                         server_key_exchange, "ServerKeyExchange");
                 if (ret != 0)
                     goto exit_sske;
                 ssl->options.serverState = SERVER_KEYEXCHANGE_COMPLETE;
                 break;
             }
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_sske:
 
         WOLFSSL_LEAVE("SendServerKeyExchange", ret);
         WOLFSSL_END(WC_FUNC_SERVER_KEY_EXCHANGE_SEND);
 
     #ifdef WOLFSSL_ASYNC_IO
         /* Handle async operation */
         if (ret == WANT_WRITE
         #ifdef WOLFSSL_ASYNC_CRYPT
                 || ret == WC_PENDING_E
         #endif
                 )
             return ret;
     #endif /* WOLFSSL_ASYNC_IO */
 
         /* Final cleanup */
         if (
         #ifdef WOLFSSL_ASYNC_IO
             args != NULL &&
         #endif
             args->input != NULL) {
             XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             args->input = NULL;
         }
     #ifdef WOLFSSL_ASYNC_IO
         /* Cleanup async */
         FreeAsyncCtx(ssl, 0);
     #else
         FreeSskeArgs(ssl, args);
     #endif
         FreeKeyExchange(ssl);
 
         if (ret != 0) {
             WOLFSSL_ERROR_VERBOSE(ret);
         }
 
         return ret;
     }
 
 #if defined(HAVE_SERVER_RENEGOTIATION_INFO) || defined(HAVE_FALLBACK_SCSV) || \
                                                             defined(OPENSSL_ALL)
 
     /* search suites for specific one, idx on success, negative on error */
     static int FindSuite(Suites* suites, byte first, byte second)
     {
         int i;
 
         if (suites == NULL || suites->suiteSz == 0) {
             WOLFSSL_MSG("Suites pointer error or suiteSz 0");
             return SUITES_ERROR;
         }
 
         for (i = 0; i < suites->suiteSz-1; i += SUITE_LEN) {
             if (suites->suites[i]   == first &&
                 suites->suites[i+1] == second )
                 return i;
         }
 
         return MATCH_SUITE_ERROR;
     }
 
 #endif
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
     /* Make sure server cert/key are valid for this suite, true on success
      * Returns 1 for valid server suite or 0 if not found
      * For asynchronous this can return WC_PENDING_E
      */
     static int VerifyServerSuite(const WOLFSSL* ssl, const Suites* suites,
                                  word16 idx, CipherSuite* cs, TLSX* extensions)
     {
     #ifndef NO_PSK
         int  havePSK = ssl->options.havePSK;
     #endif
         byte first;
         byte second;
 
         (void)cs;
         (void)extensions;
 
         WOLFSSL_ENTER("VerifyServerSuite");
 
         if (suites == NULL) {
             WOLFSSL_MSG("Suites pointer error");
             return 0;
         }
 
         first   = suites->suites[idx];
         second  = suites->suites[idx+1];
 
         if (CipherRequires(first, second, REQUIRES_RSA)) {
             WOLFSSL_MSG("Requires RSA");
             if (ssl->options.haveRSA == 0) {
                 WOLFSSL_MSG("Don't have RSA");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_DHE)) {
             WOLFSSL_MSG("Requires DHE");
             if (ssl->options.haveDH == 0) {
                 WOLFSSL_MSG("Don't have DHE");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_ECC)) {
             WOLFSSL_MSG("Requires ECC");
             if (ssl->options.haveECC == 0) {
                 WOLFSSL_MSG("Don't have ECC");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_ECC_STATIC)) {
             WOLFSSL_MSG("Requires static ECC");
             if (ssl->options.haveStaticECC == 0) {
                 WOLFSSL_MSG("Don't have static ECC");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_PSK)) {
             WOLFSSL_MSG("Requires PSK");
         #ifndef NO_PSK
             if (havePSK == 0)
         #endif
             {
                 WOLFSSL_MSG("Don't have PSK");
                 return 0;
             }
         }
 
         if (CipherRequires(first, second, REQUIRES_RSA_SIG)) {
             WOLFSSL_MSG("Requires RSA Signature");
             if (ssl->options.side == WOLFSSL_SERVER_END &&
                                            ssl->options.haveECDSAsig == 1) {
                 WOLFSSL_MSG("Don't have RSA Signature");
                 return 0;
             }
         }
 
 #if !defined(WOLFSSL_OLDTLS_AEAD_CIPHERSUITES)
         if (CipherRequires(first, second, REQUIRES_AEAD)) {
             WOLFSSL_MSG("Requires AEAD");
             if (ssl->version.major == SSLv3_MAJOR &&
                                            ssl->version.minor < TLSv1_2_MINOR) {
                 WOLFSSL_MSG("Version of SSL does not support AEAD ciphers");
                 return 0;
             }
 
         }
 #endif
 
 #if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                        defined(HAVE_CURVE448)) && defined(HAVE_SUPPORTED_CURVES)
         if (!TLSX_ValidateSupportedCurves(ssl, first, second,
                                           &cs->ecdhCurveOID)) {
             WOLFSSL_MSG("Don't have matching curves");
             return 0;
         }
 #endif
 
 #ifdef WOLFSSL_TLS13
         if (IsAtLeastTLSv1_3(ssl->version) &&
                                       ssl->options.side == WOLFSSL_SERVER_END) {
     #ifdef HAVE_SUPPORTED_CURVES
             byte searched = 0;
             int ret = TLSX_KeyShare_Choose(ssl, extensions, first, second,
                                            &cs->clientKSE, &searched);
 
             if (ret == MEMORY_E) {
                 WOLFSSL_MSG("TLSX_KeyShare_Choose() failed in "
                             "VerifyServerSuite() with MEMORY_E");
                 return 0;
             }
             if (cs->clientKSE == NULL && searched) {
             #ifdef WOLFSSL_SEND_HRR_COOKIE
                 /* If the CH contains a cookie then we need to send an alert to
                  * start from scratch. */
                 if (TLSX_Find(extensions, TLSX_COOKIE) != NULL)
                     return INVALID_PARAMETER;
             #endif
                 cs->doHelloRetry = 1;
             }
         #ifdef WOLFSSL_ASYNC_CRYPT
             if (ret == WC_PENDING_E)
                 return ret;
         #endif
             if (!cs->doHelloRetry && ret != 0)
                 return 0; /* not found */
     #endif /* HAVE_SUPPORTED_CURVES */
         }
         else if ((first == TLS13_BYTE) || ((first == ECC_BYTE) &&
                  ((second == TLS_SHA256_SHA256) ||
                   (second == TLS_SHA384_SHA384))) ||
                  ((first == CIPHER_BYTE) && ((second == TLS_SM4_GCM_SM3) ||
                   (second == TLS_SM4_CCM_SM3)))) {
             /* Can't negotiate TLS 1.3 cipher suites with lower protocol
              * version. */
             return 0;
         }
 #endif /* WOLFSSL_TLS13 */
 
         return 1;
     }
 
     static int CompareSuites(const WOLFSSL* ssl, const Suites* suites,
                              Suites* peerSuites, word16 i, word16 j,
                              CipherSuite* cs, TLSX* extensions)
     {
         if (suites->suites[i]   == peerSuites->suites[j] &&
             suites->suites[i+1] == peerSuites->suites[j+1] ) {
 
             int ret = VerifyServerSuite(ssl, suites, i, cs, extensions);
             if (ret < 0) {
                 return ret;
             }
             if (ret) {
                 WOLFSSL_MSG("Verified suite validity");
                 cs->cipherSuite0 = suites->suites[i];
                 cs->cipherSuite  = suites->suites[i+1];
                 return 0;
             }
             else {
                 WOLFSSL_MSG("Could not verify suite validity, continue");
             }
         }
 
         return MATCH_SUITE_ERROR;
     }
 
     int MatchSuite_ex(const WOLFSSL* ssl, Suites* peerSuites, CipherSuite* cs,
                       TLSX* extensions)
     {
         int ret;
         word16 i, j;
         const Suites* suites = WOLFSSL_SUITES(ssl);
 
         WOLFSSL_ENTER("MatchSuite");
 
         /* & 0x1 equivalent % 2 */
         if (peerSuites->suiteSz == 0 || peerSuites->suiteSz & 0x1)
             return BUFFER_ERROR;
 
         if (suites == NULL)
             return SUITES_ERROR;
 
         if (!ssl->options.useClientOrder) {
             /* Server order */
             for (i = 0; i < suites->suiteSz; i += 2) {
                 for (j = 0; j < peerSuites->suiteSz; j += 2) {
                     ret = CompareSuites(ssl, suites, peerSuites, i, j, cs, extensions);
                     if (ret != MATCH_SUITE_ERROR)
                         return ret;
                 }
             }
         }
         else {
             /* Client order */
             for (j = 0; j < peerSuites->suiteSz; j += 2) {
                 for (i = 0; i < suites->suiteSz; i += 2) {
                     ret = CompareSuites(ssl, suites, peerSuites, i, j, cs, extensions);
                     if (ret != MATCH_SUITE_ERROR)
                         return ret;
                 }
             }
         }
 
         WOLFSSL_ERROR_VERBOSE(MATCH_SUITE_ERROR);
         return MATCH_SUITE_ERROR;
 
     }
 
     int MatchSuite(WOLFSSL* ssl, Suites* peerSuites)
     {
         int ret;
         CipherSuite cs;
 
         XMEMSET(&cs, 0, sizeof(cs));
 
         ret = MatchSuite_ex(ssl, peerSuites, &cs,
 #ifdef HAVE_TLS_EXTENSIONS
                 ssl->extensions
 #else
                 NULL
 #endif
                 );
         if (ret != 0)
             return ret;
 
         ssl->options.cipherSuite0 = cs.cipherSuite0;
         ssl->options.cipherSuite  = cs.cipherSuite;
 #if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_CURVE25519) || \
     defined(HAVE_ED448) || defined(HAVE_CURVE448)
         ssl->ecdhCurveOID = cs.ecdhCurveOID;
 #endif
 
         ret = SetCipherSpecs(ssl);
         if (ret != 0)
             return ret;
         ret = PickHashSigAlgo(ssl, peerSuites->hashSigAlgo,
                                          peerSuites->hashSigAlgoSz);
         if (ret != 0)
             return ret;
 
 #if defined(WOLFSSL_TLS13) && defined(HAVE_SUPPORTED_CURVES)
         if (cs.doHelloRetry) {
             /* Make sure we don't send HRR twice */
             if (ssl->options.serverState == SERVER_HELLO_RETRY_REQUEST_COMPLETE)
                 return INVALID_PARAMETER;
             ssl->options.serverState = SERVER_HELLO_RETRY_REQUEST_COMPLETE;
             return TLSX_KeyShare_SetSupported(ssl, &ssl->extensions);
         }
 #endif
 
 #if defined(WOLFSSL_TLS13) && defined(HAVE_SUPPORTED_CURVES)
         if (IsAtLeastTLSv1_3(ssl->version) &&
                                       ssl->options.side == WOLFSSL_SERVER_END) {
             ret = TLSX_KeyShare_Setup(ssl, cs.clientKSE);
             if (ret != 0)
                 return ret;
         }
 #endif
         return ret;
     }
 
 #ifdef OLD_HELLO_ALLOWED
 
     /* process old style client hello, deprecate? */
     int ProcessOldClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                               word32 inSz, word16 sz)
     {
         word32          idx = *inOutIdx;
         word16          sessionSz;
         word16          randomSz;
         word16          i, j;
         ProtocolVersion pv;
         Suites          clSuites;
         int ret = -1;
 
         (void)inSz;
         WOLFSSL_MSG("Got old format client hello");
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn)
             AddLateName("ClientHello", &ssl->timeoutInfo);
 #endif
 
         /* manually hash input since different format */
 #ifndef NO_OLD_TLS
 #ifndef NO_MD5
         wc_Md5Update(&ssl->hsHashes->hashMd5, input + idx, sz);
 #endif
 #ifndef NO_SHA
         wc_ShaUpdate(&ssl->hsHashes->hashSha, input + idx, sz);
 #endif
 #endif
 #ifndef NO_SHA256
         if (IsAtLeastTLSv1_2(ssl)) {
             int shaRet = wc_Sha256Update(&ssl->hsHashes->hashSha256,
                                          input + idx, sz);
             if (shaRet != 0)
                 return shaRet;
         }
 #endif
 
         /* does this value mean client_hello? */
         idx++;
 
         /* version */
         pv.major = input[idx++];
         pv.minor = input[idx++];
         ssl->chVersion = pv;  /* store */
 
         if (ssl->version.minor > pv.minor) {
             byte haveRSA = 0;
             byte havePSK = 0;
             int  keySz   = 0;
 
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 return VERSION_ERROR;
             }
             if (pv.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 return VERSION_ERROR;
             }
             if (pv.minor == SSLv3_MINOR) {
                 /* turn off tls */
                 WOLFSSL_MSG("\tdowngrading to SSLv3");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = SSLv3_MINOR;
             }
             else if (pv.minor == TLSv1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1");
                 /* turn off tls 1.1+ */
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor  = TLSv1_MINOR;
             }
             else if (pv.minor == TLSv1_1_MINOR) {
                 WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                 ssl->version.minor  = TLSv1_1_MINOR;
             }
             else if (pv.minor == TLSv1_2_MINOR) {
                 WOLFSSL_MSG("    downgrading to TLSv1.2");
                 ssl->version.minor  = TLSv1_2_MINOR;
             }
 #ifndef NO_RSA
             haveRSA = 1;
 #endif
 #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
 #endif
 #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
 #endif
             ret = AllocateSuites(ssl);
             if (ret != 0)
                 return ret;
             InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveECDSAsig,
                        ssl->options.haveECC, TRUE, ssl->options.haveStaticECC,
                        ssl->options.haveFalconSig,
                        ssl->options.haveDilithiumSig, ssl->options.haveAnon,
                        TRUE, ssl->options.side);
         }
 
         /* suite size */
         ato16(&input[idx], &clSuites.suiteSz);
         idx += OPAQUE16_LEN;
 
         if (clSuites.suiteSz > WOLFSSL_MAX_SUITE_SZ)
             return BUFFER_ERROR;
         /* Make sure the suiteSz is a multiple of 3. (Old Client Hello) */
         if (clSuites.suiteSz % 3 != 0)
             return BUFFER_ERROR;
         clSuites.hashSigAlgoSz = 0;
 
         /* session size */
         ato16(&input[idx], &sessionSz);
         idx += OPAQUE16_LEN;
 
         if (sessionSz > ID_LEN)
             return BUFFER_ERROR;
 
         /* random size */
         ato16(&input[idx], &randomSz);
         idx += OPAQUE16_LEN;
 
         if (randomSz > RAN_LEN)
             return BUFFER_ERROR;
 
         /* suites */
         for (i = 0, j = 0; i < clSuites.suiteSz; i += 3) {
             byte first = input[idx++];
             if (!first) { /* implicit: skip sslv2 type */
                 XMEMCPY(&clSuites.suites[j], &input[idx], SUITE_LEN);
                 j += SUITE_LEN;
             }
             idx += SUITE_LEN;
         }
         clSuites.suiteSz = j;
 
         /* session id */
         if (sessionSz) {
             XMEMCPY(ssl->arrays->sessionID, input + idx, sessionSz);
             ssl->arrays->sessionIDSz = (byte)sessionSz;
             idx += sessionSz;
             ssl->options.resuming = 1;
         }
 
         /* random */
         if (randomSz < RAN_LEN)
             XMEMSET(ssl->arrays->clientRandom, 0, RAN_LEN - randomSz);
         XMEMCPY(&ssl->arrays->clientRandom[RAN_LEN - randomSz], input + idx,
                randomSz);
         idx += randomSz;
 
         if (ssl->options.usingCompression)
             ssl->options.usingCompression = 0;  /* turn off */
 
         ssl->options.clientState = CLIENT_HELLO_COMPLETE;
         ssl->cbmode = SSL_CB_MODE_WRITE;
         *inOutIdx = idx;
 
         ssl->options.haveSessionId = 1;
         /* DoClientHello uses same resume code */
         if (ssl->options.resuming) {  /* let's try */
             WOLFSSL_SESSION* session;
         #ifdef HAVE_SESSION_TICKET
             if (ssl->options.useTicket == 1) {
                 session = ssl->session;
             }
             else
         #endif
             {
                 session = wolfSSL_GetSession(ssl, ssl->arrays->masterSecret, 1);
             }
             if (!session) {
                 WOLFSSL_MSG("Session lookup for resume failed");
                 ssl->options.resuming = 0;
             } else {
                 if (MatchSuite(ssl, &clSuites) < 0) {
                     WOLFSSL_MSG("Unsupported cipher suite, OldClientHello");
                     return UNSUPPORTED_SUITE;
                 }
 
                 ret = wc_RNG_GenerateBlock(ssl->rng, ssl->arrays->serverRandom,
                                                                        RAN_LEN);
                 if (ret != 0)
                     return ret;
 
                 #ifdef NO_OLD_TLS
                     ret = DeriveTlsKeys(ssl);
                 #else
                     #ifndef NO_TLS
                         if (ssl->options.tls)
                             ret = DeriveTlsKeys(ssl);
                     #endif
                         if (!ssl->options.tls)
                             ret = DeriveKeys(ssl);
                 #endif
                 /* SERVER: peer auth based on session secret. */
                 ssl->options.peerAuthGood = (ret == 0);
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
 
                 return ret;
             }
         }
 
         ret = MatchSuite(ssl, &clSuites);
         if (ret != 0)return ret;
         return SanityCheckMsgReceived(ssl, client_hello);
     }
 
 #endif /* OLD_HELLO_ALLOWED */
 
 #ifndef WOLFSSL_NO_TLS12
 
     /**
      *  Handles session resumption.
      *  Session tickets are checked for validity based on the time each ticket
      *  was created, timeout value and the current time. If the tickets are
      *  judged expired, falls back to full-handshake. If you want disable this
      *  session ticket validation check in TLS1.2 and below, define
      *  WOLFSSL_NO_TICKET_EXPIRE.
      */
     int HandleTlsResumption(WOLFSSL* ssl, Suites* clSuites)
     {
         int ret = 0;
         WOLFSSL_SESSION* session;
     #ifdef HAVE_SESSION_TICKET
         if (ssl->options.useTicket == 1) {
             session = ssl->session;
         }
         else
     #endif
         {
             session = wolfSSL_GetSession(ssl, ssl->arrays->masterSecret, 1);
         }
         if (!session) {
             WOLFSSL_MSG("Session lookup for resume failed");
             ssl->options.resuming = 0;
             return ret;
         }
 #if !defined(WOLFSSL_NO_TICKET_EXPIRE) && !defined(NO_ASN_TIME)
         /* check if the ticket is valid */
         if (LowResTimer() > session->bornOn + ssl->timeout) {
             WOLFSSL_MSG("Expired session, fall back to full handshake.");
             ssl->options.resuming = 0;
         }
 #endif /* !WOLFSSL_NO_TICKET_EXPIRE && !NO_ASN_TIME */
 
         else if (session->haveEMS != ssl->options.haveEMS) {
             /* RFC 7627, 5.3, server-side */
             /* if old sess didn't have EMS, but new does, full handshake */
             if (!session->haveEMS && ssl->options.haveEMS) {
                 WOLFSSL_MSG("Attempting to resume a session that didn't "
                             "use EMS with a new session with EMS. Do full "
                             "handshake.");
                 ssl->options.resuming = 0;
             }
             /* if old sess used EMS, but new doesn't, MUST abort */
             else if (session->haveEMS && !ssl->options.haveEMS) {
                 WOLFSSL_MSG("Trying to resume a session with EMS without "
                             "using EMS");
             #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, handshake_failure);
             #endif
                 ret = EXT_MASTER_SECRET_NEEDED_E;
                 WOLFSSL_ERROR_VERBOSE(ret);
             }
         }
         else {
         #ifndef NO_RESUME_SUITE_CHECK
             int j;
 
             /* Check client suites include the one in session */
             for (j = 0; j < clSuites->suiteSz; j += 2) {
                 if (clSuites->suites[j] == session->cipherSuite0 &&
                                 clSuites->suites[j+1] == session->cipherSuite) {
                     break;
                 }
             }
             if (j == clSuites->suiteSz) {
                 WOLFSSL_MSG("Prev session's cipher suite not in ClientHello");
             #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, illegal_parameter);
             #endif
                 ret = UNSUPPORTED_SUITE;
                 WOLFSSL_ERROR_VERBOSE(ret);
             }
         #endif
 
             if (ret == 0 && ssl->options.resuming) {
                 /* for resumption use the cipher suite from session */
                 ssl->options.cipherSuite0 = session->cipherSuite0;
                 ssl->options.cipherSuite =  session->cipherSuite;
                 ret = SetCipherSpecs(ssl);
                 if (ret == 0) {
                     ret = PickHashSigAlgo(ssl, clSuites->hashSigAlgo,
                                                clSuites->hashSigAlgoSz);
                 }
             }
             else if (ret == 0) {
                 if (MatchSuite(ssl, clSuites) < 0) {
                     WOLFSSL_MSG("Unsupported cipher suite, ClientHello");
                     ret = UNSUPPORTED_SUITE;
                     WOLFSSL_ERROR_VERBOSE(ret);
                 }
             }
             if (ret == 0) {
                 ret = wc_RNG_GenerateBlock(ssl->rng,
                                            ssl->arrays->serverRandom, RAN_LEN);
             }
             if (ret == 0) {
                 #ifdef NO_OLD_TLS
                     ret = DeriveTlsKeys(ssl);
                 #else
                     #ifndef NO_TLS
                         if (ssl->options.tls)
                             ret = DeriveTlsKeys(ssl);
                     #endif
                         if (!ssl->options.tls)
                             ret = DeriveKeys(ssl);
                 #endif
                 /* SERVER: peer auth based on session secret. */
                 ssl->options.peerAuthGood = (ret == 0);
                 ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
             }
         }
 
 
         return ret;
     }
 
 
     /* handle processing of client_hello (1) */
     int DoClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                              word32 helloSz)
     {
         byte            b;
         ProtocolVersion pv;
 #ifdef WOLFSSL_SMALL_STACK
         Suites*         clSuites = NULL;
 #else
         Suites          clSuites[1];
 #endif
         word32          i = *inOutIdx;
         word32          begin = i;
         int             ret = 0;
         byte            lesserVersion;
 
         WOLFSSL_START(WC_FUNC_CLIENT_HELLO_DO);
         WOLFSSL_ENTER("DoClientHello");
 
 #ifdef WOLFSSL_CALLBACKS
         if (ssl->hsInfoOn) AddPacketName(ssl, "ClientHello");
         if (ssl->toInfoOn) AddLateName("ClientHello", &ssl->timeoutInfo);
 #endif
         /* do not change state in the SSL object before the next region of code
          * to be able to statelessly compute a DTLS cookie */
 #ifdef WOLFSSL_DTLS
         /* Update the ssl->options.dtlsStateful setting `if` statement in
          * wolfSSL_accept when changing this one. */
         if (IsDtlsNotSctpMode(ssl) && IsDtlsNotSrtpMode(ssl) && !IsSCR(ssl) &&
                 !ssl->options.dtlsStateful) {
             DtlsSetSeqNumForReply(ssl);
             ret = DoClientHelloStateless(ssl, input + *inOutIdx, helloSz, 0,
                     NULL);
             if (ret != 0 || !ssl->options.dtlsStateful) {
                 int alertType = TranslateErrorToAlert(ret);
                 if (alertType != invalid_alert) {
                     int err;
 
                     /* propagate socket errors to avoid re-calling send alert */
                     err = SendAlert(ssl, alert_fatal, alertType);
                     if (err == SOCKET_ERROR_E)
                         ret = SOCKET_ERROR_E;
                 }
                 *inOutIdx += helloSz;
                 DtlsResetState(ssl);
                 if (DtlsIgnoreError(ret))
                     ret = 0;
                 return ret;
             }
             if (ssl->chGoodCb != NULL) {
                 int cbret = ssl->chGoodCb(ssl, ssl->chGoodCtx);
                 if (cbret < 0) {
                     ssl->error = cbret;
                     WOLFSSL_MSG("ClientHello Good Cb don't continue error");
                     return WOLFSSL_FATAL_ERROR;
                 }
             }
         }
         ssl->options.dtlsStateful = 1;
 #endif /* WOLFSSL_DTLS */
 
         /* Reset to sane value for SCR */
         ssl->options.resuming = 0;
         ssl->arrays->sessionIDSz = 0;
 
         /* protocol version, random and session id length check */
         if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
             return BUFFER_ERROR;
 
         /* protocol version */
         XMEMCPY(&pv, input + i, OPAQUE16_LEN);
         ssl->chVersion = pv;   /* store */
         i += OPAQUE16_LEN;
 
         /* Legacy protocol version cannot negotiate TLS 1.3 or higher. */
         if (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR)
             pv.minor = TLSv1_2_MINOR;
 
         lesserVersion = !ssl->options.dtls && ssl->version.minor > pv.minor;
         lesserVersion |= ssl->options.dtls && ssl->version.minor < pv.minor;
 
         if (lesserVersion) {
             byte   belowMinDowngrade;
             word16 haveRSA = 0;
             word16 havePSK = 0;
             int    keySz   = 0;
 
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 ret = VERSION_ERROR;
                 goto out;
             }
 
             belowMinDowngrade = pv.minor < ssl->options.minDowngrade;
 
             /* DTLS versions increase backwards (-1,-2,-3) ecc  */
             if (ssl->options.dtls)
                 belowMinDowngrade = ssl->options.dtls
                     && pv.minor > ssl->options.minDowngrade;
 
             if (belowMinDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 ret = VERSION_ERROR;
                 goto out;
             }
 
             if (!ssl->options.dtls) {
                 if (pv.minor == SSLv3_MINOR) {
                     /* turn off tls */
                     WOLFSSL_MSG("\tdowngrading to SSLv3");
                     ssl->options.tls    = 0;
                     ssl->options.tls1_1 = 0;
                     ssl->version.minor  = SSLv3_MINOR;
                 }
                 else if (pv.minor == TLSv1_MINOR) {
                     /* turn off tls 1.1+ */
                     WOLFSSL_MSG("\tdowngrading to TLSv1");
                     ssl->options.tls1_1 = 0;
                     ssl->version.minor  = TLSv1_MINOR;
                 }
                 else if (pv.minor == TLSv1_1_MINOR) {
                     WOLFSSL_MSG("\tdowngrading to TLSv1.1");
                     ssl->version.minor  = TLSv1_1_MINOR;
                 }
                 else if (pv.minor == TLSv1_2_MINOR) {
                     WOLFSSL_MSG("    downgrading to TLSv1.2");
                     ssl->version.minor  = TLSv1_2_MINOR;
                 }
             }
             else {
                 if (pv.minor == DTLSv1_2_MINOR) {
                     WOLFSSL_MSG("\tDowngrading to DTLSv1.2");
                     ssl->options.tls1_3 = 0;
                     ssl->version.minor = DTLSv1_2_MINOR;
                 }
                 else if (pv.minor == DTLS_MINOR) {
                     WOLFSSL_MSG("\tDowngrading to DTLSv1.0");
                     ssl->options.tls1_3 = 0;
                     ssl->version.minor = DTLS_MINOR;
                 }
             }
 #ifndef NO_RSA
             haveRSA = 1;
 #endif
 #ifndef NO_PSK
             havePSK = ssl->options.havePSK;
 #endif
 #ifndef NO_CERTS
             keySz = ssl->buffers.keySz;
 #endif
             ret = AllocateSuites(ssl);
             if (ret != 0)
                 goto out;
             InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                        ssl->options.haveDH, ssl->options.haveECDSAsig,
                        ssl->options.haveECC, TRUE, ssl->options.haveStaticECC,
                        ssl->options.haveFalconSig,
                        ssl->options.haveDilithiumSig, ssl->options.haveAnon,
                        TRUE, ssl->options.side);
         }
 
         /* check if option is set to not allow the current version
          * set from either wolfSSL_set_options or wolfSSL_CTX_set_options */
         if (!ssl->options.dtls && ssl->options.downgrade &&
             ssl->options.mask > 0) {
 
             int reset = 0;
 
             if (ssl->version.minor == TLSv1_2_MINOR &&
                (ssl->options.mask & WOLFSSL_OP_NO_TLSv1_2) ==
                 WOLFSSL_OP_NO_TLSv1_2) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.2, Downgrading");
                 ssl->version.minor = TLSv1_1_MINOR;
                 reset = 1;
             }
 
             if (ssl->version.minor == TLSv1_1_MINOR &&
                (ssl->options.mask & WOLFSSL_OP_NO_TLSv1_1) ==
                 WOLFSSL_OP_NO_TLSv1_1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1.1, Downgrading");
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = TLSv1_MINOR;
                 reset = 1;
             }
 
             if (ssl->version.minor == TLSv1_MINOR &&
                (ssl->options.mask & WOLFSSL_OP_NO_TLSv1) ==
                 WOLFSSL_OP_NO_TLSv1) {
                 WOLFSSL_MSG("\tOption set to not allow TLSv1, Downgrading");
                 ssl->options.tls    = 0;
                 ssl->options.tls1_1 = 0;
                 ssl->version.minor = SSLv3_MINOR;
                 reset = 1;
             }
 
             if (ssl->version.minor == SSLv3_MINOR &&
                (ssl->options.mask & WOLFSSL_OP_NO_SSLv3) ==
                 WOLFSSL_OP_NO_SSLv3) {
                 WOLFSSL_MSG("\tError, option set to not allow SSLv3");
                 ret = VERSION_ERROR;
 #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);
 #endif
                 goto out;
             }
 
             if (ssl->version.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                 ret = VERSION_ERROR;
                 goto out;
             }
 
             if (reset) {
                 word16 haveRSA = 0;
                 word16 havePSK = 0;
                 int    keySz   = 0;
 
             #ifndef NO_RSA
                 haveRSA = 1;
             #endif
             #ifndef NO_PSK
                 havePSK = ssl->options.havePSK;
             #endif
             #ifndef NO_CERTS
                 keySz = ssl->buffers.keySz;
             #endif
 
                 ret = AllocateSuites(ssl);
                 if (ret != 0)
                     goto out;
                 /* reset cipher suites to account for TLS version change */
                 InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                            ssl->options.haveDH, ssl->options.haveECDSAsig,
                            ssl->options.haveECC, TRUE, ssl->options.haveStaticECC,
                            ssl->options.haveFalconSig,
                            ssl->options.haveDilithiumSig, ssl->options.haveAnon,
                            TRUE, ssl->options.side);
             }
         }
 
         /* random */
         XMEMCPY(ssl->arrays->clientRandom, input + i, RAN_LEN);
         i += RAN_LEN;
 
 #ifdef SHOW_SECRETS
         {
             int j;
             printf("client random: ");
             for (j = 0; j < RAN_LEN; j++)
                 printf("%02x", ssl->arrays->clientRandom[j]);
             printf("\n");
         }
 #endif
 
         /* session id */
         b = input[i++];
         if (b > ID_LEN) {
             WOLFSSL_MSG("Invalid session ID size");
             ret = BUFFER_ERROR; /* session ID greater than 32 bytes long */
             goto out;
         }
         else if (b > 0 && !IsSCR(ssl)) {
             if ((i - begin) + b > helloSz) {
                 ret = BUFFER_ERROR;
                 goto out;
             }
 
             /* Always save session ID in case we want to echo it. */
             XMEMCPY(ssl->arrays->sessionID, input + i, b);
             ssl->arrays->sessionIDSz = b;
 
             if (b == ID_LEN)
                 ssl->options.resuming = 1; /* client wants to resume */
             WOLFSSL_MSG("Client wants to resume session");
         }
         i += b;
 
 #ifdef WOLFSSL_DTLS
             /* cookie */
             if (ssl->options.dtls) {
                 word8 peerCookieSz;
                 if ((i - begin) + OPAQUE8_LEN > helloSz) {
                     ret = BUFFER_ERROR;
                     goto out;
                 }
 
                 peerCookieSz = input[i++];
 
                 if (peerCookieSz) {
                     if (peerCookieSz > MAX_COOKIE_LEN) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     if ((i - begin) + peerCookieSz > helloSz) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     i += peerCookieSz;
                 }
             }
 #endif /* WOLFSSL_DTLS */
 
         /* suites */
         if ((i - begin) + OPAQUE16_LEN > helloSz) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
 #ifdef WOLFSSL_SMALL_STACK
         clSuites = (Suites*)XMALLOC(sizeof(Suites), ssl->heap,
                                        DYNAMIC_TYPE_SUITES);
         if (clSuites == NULL) {
             ret = MEMORY_E;
             goto out;
         }
 #endif
         XMEMSET(clSuites, 0, sizeof(Suites));
         ato16(&input[i], &clSuites->suiteSz);
         i += OPAQUE16_LEN;
 
         /* Cipher suite lists are always multiples of two in length. */
         if (clSuites->suiteSz % 2 != 0) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         /* suites and compression length check */
         if ((i - begin) + clSuites->suiteSz + OPAQUE8_LEN > helloSz) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         if (clSuites->suiteSz > WOLFSSL_MAX_SUITE_SZ) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         XMEMCPY(clSuites->suites, input + i, clSuites->suiteSz);
 
 #ifdef HAVE_SERVER_RENEGOTIATION_INFO
         /* check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV suite */
         if (FindSuite(clSuites, 0, TLS_EMPTY_RENEGOTIATION_INFO_SCSV) >= 0) {
             TLSX* extension;
 
             /* check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV suite */
             ret = TLSX_AddEmptyRenegotiationInfo(&ssl->extensions, ssl->heap);
             if (ret != WOLFSSL_SUCCESS)
                 goto out;
 
             extension = TLSX_Find(ssl->extensions, TLSX_RENEGOTIATION_INFO);
             if (extension) {
                 ssl->secure_renegotiation =
                                           (SecureRenegotiation*)extension->data;
                 ssl->secure_renegotiation->enabled = 1;
             }
         }
 #endif /* HAVE_SERVER_RENEGOTIATION_INFO */
 #if defined(HAVE_FALLBACK_SCSV) || defined(OPENSSL_ALL)
         /* check for TLS_FALLBACK_SCSV suite */
         if (FindSuite(clSuites, TLS_FALLBACK_SCSV, 0) >= 0) {
             WOLFSSL_MSG("Found Fallback SCSV");
             if (ssl->ctx->method->version.minor > pv.minor) {
                 WOLFSSL_MSG("Client trying to connect with lesser version");
                 SendAlert(ssl, alert_fatal, inappropriate_fallback);
                 ret = VERSION_ERROR;
                 goto out;
             }
         }
 #endif
 
         i += clSuites->suiteSz;
         clSuites->hashSigAlgoSz = 0;
 
         /* compression length */
         b = input[i++];
 
         if ((i - begin) + b > helloSz) {
             ret = BUFFER_ERROR;
             goto out;
         }
 
         if (b == 0) {
             WOLFSSL_MSG("No compression types in list");
 #ifdef WOLFSSL_EXTRA_ALERTS
             SendAlert(ssl, alert_fatal, decode_error);
 #endif
             ret = COMPRESSION_ERROR;
             goto out;
         }
 
         {
             /* compression match types */
             int matchNo = 0;
             int matchZlib = 0;
 
             while (b--) {
                 byte comp = input[i++];
 
                 if (comp == NO_COMPRESSION) {
                     matchNo = 1;
                 }
                 if (comp == ZLIB_COMPRESSION) {
                     matchZlib = 1;
                 }
             }
 
             if (ssl->options.usingCompression == 0 && matchNo) {
                 WOLFSSL_MSG("Matched No Compression");
             } else if (ssl->options.usingCompression && matchZlib) {
                 WOLFSSL_MSG("Matched zlib Compression");
             } else if (ssl->options.usingCompression && matchNo) {
                 WOLFSSL_MSG("Could only match no compression, turning off");
                 ssl->options.usingCompression = 0;  /* turn off */
             } else {
                 WOLFSSL_MSG("Could not match compression");
 #ifdef WOLFSSL_EXTRA_ALERTS
                 SendAlert(ssl, alert_fatal, illegal_parameter);
 #endif
                 ret = COMPRESSION_ERROR;
                 goto out;
             }
         }
 
         *inOutIdx = i;
 
         /* tls extensions */
         if ((i - begin) < helloSz) {
 #ifdef HAVE_TLS_EXTENSIONS
             if (TLSX_SupportExtensions(ssl))
 #else
             if (IsAtLeastTLSv1_2(ssl))
 #endif
             {
                 /* Process the hello extension. Skip unsupported. */
                 word16 totalExtSz;
 
 #ifdef HAVE_TLS_EXTENSIONS
                 /* auto populate extensions supported unless user defined */
                 if ((ret = TLSX_PopulateExtensions(ssl, 1)) != 0)
                     goto out;
 #endif
 
                 if ((i - begin) + OPAQUE16_LEN > helloSz) {
                     ret = BUFFER_ERROR;
                     goto out;
                 }
 
                 ato16(&input[i], &totalExtSz);
                 i += OPAQUE16_LEN;
 
                 if ((i - begin) + totalExtSz > helloSz) {
                     ret = BUFFER_ERROR;
                     goto out;
                 }
 
 #ifdef HAVE_TLS_EXTENSIONS
                 /* tls extensions */
                 if ((ret = TLSX_Parse(ssl, input + i, totalExtSz, client_hello,
                                                                     clSuites)))
                     goto out;
     #ifdef WOLFSSL_TLS13
                 if (TLSX_Find(ssl->extensions,
                                              TLSX_SUPPORTED_VERSIONS) != NULL) {
                     WOLFSSL_MSG(
                             "Client attempting to connect with higher version");
                     ret = VERSION_ERROR;
                     goto out;
                 }
     #endif
     #ifdef HAVE_SNI
                 if((ret=SNI_Callback(ssl)))
                     goto out;
     #endif
     #ifdef HAVE_ALPN
                 if((ret=ALPN_Select(ssl)))
                     goto out;
     #endif
 
                 i += totalExtSz;
 #else
                 while (totalExtSz) {
                     word16 extId, extSz;
 
                     if (OPAQUE16_LEN + OPAQUE16_LEN > totalExtSz) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     ato16(&input[i], &extId);
                     i += OPAQUE16_LEN;
                     ato16(&input[i], &extSz);
                     i += OPAQUE16_LEN;
 
                     if (OPAQUE16_LEN + OPAQUE16_LEN + extSz > totalExtSz) {
                         ret = BUFFER_ERROR;
                         goto out;
                     }
 
                     if (extId == HELLO_EXT_SIG_ALGO) {
                         word16 hashSigAlgoSz;
 
                         ato16(&input[i], &hashSigAlgoSz);
                         i += OPAQUE16_LEN;
 
                         if (OPAQUE16_LEN + hashSigAlgoSz > extSz) {
                             ret = BUFFER_ERROR;
                             goto out;
                         }
 
                         if (hashSigAlgoSz % 2 != 0) {
                             ret = BUFFER_ERROR;
                             goto out;
                         }
 
                         clSuites->hashSigAlgoSz = hashSigAlgoSz;
                         if (clSuites->hashSigAlgoSz > WOLFSSL_MAX_SIGALGO) {
                             WOLFSSL_MSG("ClientHello SigAlgo list exceeds max, "
                                                                   "truncating");
                             clSuites->hashSigAlgoSz = WOLFSSL_MAX_SIGALGO;
                         }
 
                         XMEMCPY(clSuites->hashSigAlgo, &input[i],
                                                       clSuites->hashSigAlgoSz);
 
                         i += hashSigAlgoSz;
                     }
 #ifdef HAVE_EXTENDED_MASTER
                     else if (extId == HELLO_EXT_EXTMS)
                         ssl->options.haveEMS = 1;
 #endif
                     else
                         i += extSz;
 
                     totalExtSz -= OPAQUE16_LEN + OPAQUE16_LEN + extSz;
                 }
 #endif
                 *inOutIdx = i;
             }
             else
                 *inOutIdx = begin + helloSz; /* skip extensions */
         }
 
 #ifdef WOLFSSL_DTLS_CID
         if (ssl->options.useDtlsCID)
             DtlsCIDOnExtensionsParsed(ssl);
 #endif /* WOLFSSL_DTLS_CID */
 
         ssl->options.clientState   = CLIENT_HELLO_COMPLETE;
         ssl->options.haveSessionId = 1;
 
         /* ProcessOld uses same resume code */
         if (ssl->options.resuming) {
             ret = HandleTlsResumption(ssl, clSuites);
             if (ret != 0)
                 goto out;
 
 #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_ENCRYPT_THEN_MAC) && \
     !defined(WOLFSSL_AEAD_ONLY)
             if (ssl->options.encThenMac && ssl->specs.cipher_type == block) {
                 ret = TLSX_EncryptThenMac_Respond(ssl);
                 if (ret != 0)
                     goto out;
             }
             else
                 ssl->options.encThenMac = 0;
 #endif
             if (ssl->options.clientState == CLIENT_KEYEXCHANGE_COMPLETE) {
                 WOLFSSL_LEAVE("DoClientHello", ret);
                 WOLFSSL_END(WC_FUNC_CLIENT_HELLO_DO);
 
                 goto out;
             }
         }
 
 
 #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_DH_DEFAULT_PARAMS)
     #if defined(HAVE_FFDHE) && defined(HAVE_SUPPORTED_CURVES)
         if (TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS) != NULL) {
             /* Set FFDHE parameters or clear DHE parameters if FFDH parameters
              * present and no matches in the server's list. */
             ret = TLSX_SupportedFFDHE_Set(ssl);
             if (ret != 0)
                 goto out;
         }
     #endif
 #endif
 
 #ifdef OPENSSL_EXTRA
         /* Give user last chance to provide a cert for cipher selection */
         if (ret == 0 && ssl->ctx->certSetupCb != NULL)
             ret = CertSetupCbWrapper(ssl);
 #endif
         if (ret == 0)
             ret = MatchSuite(ssl, clSuites);
 
 #if defined(HAVE_TLS_EXTENSIONS) && defined(HAVE_ENCRYPT_THEN_MAC) && \
     !defined(WOLFSSL_AEAD_ONLY)
         if (ret == 0 && ssl->options.encThenMac &&
                                               ssl->specs.cipher_type == block) {
             ret = TLSX_EncryptThenMac_Respond(ssl);
         }
         else
             ssl->options.encThenMac = 0;
 #endif
 
 #ifdef WOLFSSL_DTLS
         if (ret == 0 && ssl->options.dtls)
             DtlsMsgPoolReset(ssl);
 #endif
 
     out:
 
 #ifdef WOLFSSL_SMALL_STACK
         if (clSuites != NULL)
             XFREE(clSuites, ssl->heap, DYNAMIC_TYPE_SUITES);
 #endif
         WOLFSSL_LEAVE("DoClientHello", ret);
         WOLFSSL_END(WC_FUNC_CLIENT_HELLO_DO);
 
         if (ret != 0) {
             WOLFSSL_ERROR_VERBOSE(ret);
         }
 
         return ret;
     }
 
 
 #if (!defined(NO_RSA) || defined(HAVE_ECC) || defined(HAVE_ED25519) || \
                         defined(HAVE_ED448)) && !defined(WOLFSSL_NO_CLIENT_AUTH)
 
     typedef struct DcvArgs {
         byte*  output; /* not allocated */
         word32 sendSz;
         word16 sz;
         word32 sigSz;
         word32 idx;
         word32 begin;
         byte   hashAlgo;
         byte   sigAlgo;
     } DcvArgs;
 
     static void FreeDcvArgs(WOLFSSL* ssl, void* pArgs)
     {
         DcvArgs* args = (DcvArgs*)pArgs;
 
         (void)ssl;
         (void)args;
     }
 
     /* handle processing of certificate_verify (15) */
     static int DoCertificateVerify(WOLFSSL* ssl, byte* input,
                                 word32* inOutIdx, word32 size)
     {
         int ret = 0;
     #ifdef WOLFSSL_ASYNC_CRYPT
         DcvArgs* args = NULL;
         WOLFSSL_ASSERT_SIZEOF_GE(ssl->async->args, *args);
     #else
         DcvArgs  args[1];
     #endif
 
         WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);
         WOLFSSL_ENTER("DoCertificateVerify");
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         if (ssl->async == NULL) {
             ssl->async = (struct WOLFSSL_ASYNC*)
                     XMALLOC(sizeof(struct WOLFSSL_ASYNC), ssl->heap,
                             DYNAMIC_TYPE_ASYNC);
             if (ssl->async == NULL)
                 ERROR_OUT(MEMORY_E, exit_dcv);
         }
         args = (DcvArgs*)ssl->async->args;
 
         ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);
         if (ret != WC_NO_PENDING_E) {
             /* Check for error */
             if (ret < 0)
                 goto exit_dcv;
         }
         else
     #endif
         {
             /* Reset state */
             ret = 0;
             ssl->options.asyncState = TLS_ASYNC_BEGIN;
             XMEMSET(args, 0, sizeof(DcvArgs));
             args->hashAlgo = sha_mac;
             args->sigAlgo = anonymous_sa_algo;
             args->idx = *inOutIdx;
             args->begin = *inOutIdx;
         #ifdef WOLFSSL_ASYNC_CRYPT
             ssl->async->freeArgs = FreeDcvArgs;
         #endif
         }
 
         switch(ssl->options.asyncState)
         {
             case TLS_ASYNC_BEGIN:
             {
             #ifdef WOLFSSL_CALLBACKS
                 if (ssl->hsInfoOn)
                     AddPacketName(ssl, "CertificateVerify");
                 if (ssl->toInfoOn)
                     AddLateName("CertificateVerify", &ssl->timeoutInfo);
             #endif
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_BUILD;
             } /* case TLS_ASYNC_BEGIN */
             FALL_THROUGH;
 
             case TLS_ASYNC_BUILD:
             {
                 if (IsAtLeastTLSv1_2(ssl)) {
                     if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > size) {
                         ERROR_OUT(BUFFER_ERROR, exit_dcv);
                     }
 
                     DecodeSigAlg(&input[args->idx], &args->hashAlgo,
                                  &args->sigAlgo);
                     args->idx += 2;
                 }
             #ifndef NO_RSA
                 else if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0)
                     args->sigAlgo = rsa_sa_algo;
             #endif
             #ifdef HAVE_ECC
                 else if (ssl->peerEccDsaKeyPresent) {
                 #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                     if (ssl->peerEccDsaKey->dp->id == ECC_SM2P256V1) {
                         args->sigAlgo = sm2_sa_algo;
                     }
                     else
                 #endif
                     {
                         args->sigAlgo = ecc_dsa_sa_algo;
                     }
                 }
             #endif
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 else if (ssl->peerEd25519KeyPresent)
                     args->sigAlgo = ed25519_sa_algo;
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 else if (ssl->peerEd448KeyPresent)
                     args->sigAlgo = ed448_sa_algo;
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
                 if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
                     ERROR_OUT(BUFFER_ERROR, exit_dcv);
                 }
 
                 ato16(input + args->idx, &args->sz);
                 args->idx += OPAQUE16_LEN;
 
                 if ((args->idx - args->begin) + args->sz > size ||
                                                     args->sz > ENCRYPT_LEN) {
                     ERROR_OUT(BUFFER_ERROR, exit_dcv);
                 }
 
             #ifdef HAVE_ECC
                 if (ssl->peerEccDsaKeyPresent) {
 
                     WOLFSSL_MSG("Doing ECC peer cert verify");
 
                 /* make sure a default is defined */
                 #if !defined(NO_SHA)
                     SetDigest(ssl, sha_mac);
                 #elif !defined(NO_SHA256)
                     SetDigest(ssl, sha256_mac);
                 #elif defined(WOLFSSL_SM3)
                     SetDigest(ssl, sm3_mac);
                 #elif defined(WOLFSSL_SHA384)
                     SetDigest(ssl, sha384_mac);
                 #elif defined(WOLFSSL_SHA512)
                     SetDigest(ssl, sha512_mac);
                 #else
                     #error No digest enabled for ECC sig verify
                 #endif
 
                     if (IsAtLeastTLSv1_2(ssl)) {
                         if (args->sigAlgo != ecc_dsa_sa_algo
                         #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                             && args->sigAlgo != sm2_sa_algo
                         #endif
                             ) {
                             WOLFSSL_MSG("Oops, peer sent ECC key but not in verify");
                         }
 
                         SetDigest(ssl, args->hashAlgo);
                     }
                 }
             #endif /* HAVE_ECC */
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 if (ssl->peerEd25519KeyPresent) {
                     WOLFSSL_MSG("Doing ED25519 peer cert verify");
                     if (IsAtLeastTLSv1_2(ssl) &&
                                              args->sigAlgo != ed25519_sa_algo) {
                         WOLFSSL_MSG(
                                "Oops, peer sent ED25519 key but not in verify");
                     }
                 }
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 if (ssl->peerEd448KeyPresent) {
                     WOLFSSL_MSG("Doing ED448 peer cert verify");
                     if (IsAtLeastTLSv1_2(ssl) &&
                                                args->sigAlgo != ed448_sa_algo) {
                         WOLFSSL_MSG(
                                  "Oops, peer sent ED448 key but not in verify");
                     }
                 }
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_DO;
             } /* case TLS_ASYNC_BUILD */
             FALL_THROUGH;
 
             case TLS_ASYNC_DO:
             {
             #ifndef NO_RSA
                 if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {
                     WOLFSSL_MSG("Doing RSA peer cert verify");
 
                     ret = RsaVerify(ssl,
                         input + args->idx,
                         args->sz,
                         &args->output,
                         args->sigAlgo, args->hashAlgo,
                         ssl->peerRsaKey,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerRsaKey
                     #else
                         NULL
                     #endif
                     );
                     if (ret >= 0) {
                         if (args->sigAlgo == rsa_sa_algo)
                             args->sendSz = ret;
                         else {
                             args->sigSz = ret;
                             args->sendSz = ssl->buffers.digest.length;
                         }
                         ret = 0;
                     }
                 }
             #endif /* !NO_RSA */
             #ifdef HAVE_ECC
                 if (ssl->peerEccDsaKeyPresent) {
                     WOLFSSL_MSG("Doing ECC peer cert verify");
 
                 #if defined(WOLFSSL_SM2) && defined(WOLFSSL_SM3)
                     if (args->sigAlgo == sm2_sa_algo) {
                         ret = Sm2wSm3Verify(ssl,
                             TLS12_SM2_SIG_ID, TLS12_SM2_SIG_ID_SZ,
                             input + args->idx, args->sz,
                             ssl->hsHashes->messages, ssl->hsHashes->prevLen,
                             ssl->peerEccDsaKey,
                         #ifdef HAVE_PK_CALLBACKS
                             &ssl->buffers.peerEccDsaKey
                         #else
                             NULL
                         #endif
                         );
                     }
                     else
                 #endif
                     {
                         ret = EccVerify(ssl,
                             input + args->idx, args->sz,
                             ssl->buffers.digest.buffer,
                             ssl->buffers.digest.length,
                             ssl->peerEccDsaKey,
                         #ifdef HAVE_PK_CALLBACKS
                             &ssl->buffers.peerEccDsaKey
                         #else
                             NULL
                         #endif
                         );
                     }
                     /* SERVER: Data verified with certificate's public key. */
                     ssl->options.peerAuthGood = ssl->options.havePeerCert &&
                                                 (ret == 0);
                 }
             #endif /* HAVE_ECC */
             #if defined(HAVE_ED25519) && !defined(NO_ED25519_CLIENT_AUTH)
                 if (ssl->peerEd25519KeyPresent) {
                     WOLFSSL_MSG("Doing Ed25519 peer cert verify");
 
                     ret = Ed25519Verify(ssl,
                         input + args->idx, args->sz,
                         ssl->hsHashes->messages, ssl->hsHashes->prevLen,
                         ssl->peerEd25519Key,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEd25519Key
                     #else
                         NULL
                     #endif
                     );
                     /* SERVER: Data verified with certificate's public key. */
                     ssl->options.peerAuthGood = ssl->options.havePeerCert &&
                                                 (ret == 0);
                 }
             #endif /* HAVE_ED25519 && !NO_ED25519_CLIENT_AUTH */
             #if defined(HAVE_ED448) && !defined(NO_ED448_CLIENT_AUTH)
                 if (ssl->peerEd448KeyPresent) {
                     WOLFSSL_MSG("Doing Ed448 peer cert verify");
 
                     ret = Ed448Verify(ssl,
                         input + args->idx, args->sz,
                         ssl->hsHashes->messages, ssl->hsHashes->prevLen,
                         ssl->peerEd448Key,
                     #ifdef HAVE_PK_CALLBACKS
                         &ssl->buffers.peerEd448Key
                     #else
                         NULL
                     #endif
                     );
                     /* SERVER: Data verified with certificate's public key. */
                     ssl->options.peerAuthGood = ssl->options.havePeerCert &&
                                                 (ret == 0);
                 }
             #endif /* HAVE_ED448 && !NO_ED448_CLIENT_AUTH */
 
             #ifdef WOLFSSL_ASYNC_CRYPT
                 /* handle async pending */
                 if (ret == WC_PENDING_E)
                     goto exit_dcv;
             #endif
 
                 /* Check for error */
                 if (ret != 0) {
                     ret = SIG_VERIFY_E;
                     goto exit_dcv;
                 }
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_VERIFY;
             } /* case TLS_ASYNC_DO */
             FALL_THROUGH;
 
             case TLS_ASYNC_VERIFY:
             {
             #ifndef NO_RSA
                 if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {
                     if (IsAtLeastTLSv1_2(ssl)) {
                     #ifdef WC_RSA_PSS
                         if (args->sigAlgo == rsa_pss_sa_algo) {
                             SetDigest(ssl, args->hashAlgo);
 
                         #ifdef HAVE_SELFTEST
                             ret = wc_RsaPSS_CheckPadding(
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             args->output, args->sigSz,
                                             HashAlgoToType(args->hashAlgo));
                         #else
                             ret = wc_RsaPSS_CheckPadding_ex(
                                             ssl->buffers.digest.buffer,
                                             ssl->buffers.digest.length,
                                             args->output, args->sigSz,
                                             HashAlgoToType(args->hashAlgo), -1,
                                             mp_count_bits(&ssl->peerRsaKey->n));
                         #endif
                             if (ret != 0) {
                                 ret = SIG_VERIFY_E;
                                 goto exit_dcv;
                             }
                         }
                         else
                     #endif
                         {
                         #ifndef WOLFSSL_SMALL_STACK
                             byte  encodedSig[MAX_ENCODED_SIG_SZ];
                         #else
                             byte* encodedSig = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
                                              ssl->heap, DYNAMIC_TYPE_SIGNATURE);
                             if (encodedSig == NULL) {
                                 ERROR_OUT(MEMORY_E, exit_dcv);
                             }
                         #endif
 
                             if (args->sigAlgo != rsa_sa_algo) {
                                 WOLFSSL_MSG("Oops, peer sent RSA key but not "
                                             "in verify");
                             }
 
                             SetDigest(ssl, args->hashAlgo);
 
                             args->sigSz = wc_EncodeSignature(encodedSig,
                                 ssl->buffers.digest.buffer,
                                 ssl->buffers.digest.length,
                                 TypeHash(args->hashAlgo));
 
                             if (args->sendSz != args->sigSz || !args->output ||
                                 XMEMCMP(args->output, encodedSig,
                                    min(args->sigSz, MAX_ENCODED_SIG_SZ)) != 0) {
                                 ret = VERIFY_CERT_ERROR;
                             }
 
                         #ifdef WOLFSSL_SMALL_STACK
                             XFREE(encodedSig, ssl->heap,
                                   DYNAMIC_TYPE_SIGNATURE);
                         #endif
                         }
                     }
                     else {
                         if (args->sendSz != FINISHED_SZ || !args->output ||
                             XMEMCMP(args->output,
                                 &ssl->hsHashes->certHashes, FINISHED_SZ) != 0) {
                             ret = VERIFY_CERT_ERROR;
                         }
                     }
                     if (ret == 0) {
                         /* SERVER: Data verified with cert's public key. */
                         ssl->options.peerAuthGood = ssl->options.havePeerCert &&
                                                     (ret == 0);
                     }
                 }
             #endif /* !NO_RSA */
                 if (ret != 0)
                     break;
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_FINALIZE;
             } /* case TLS_ASYNC_VERIFY */
             FALL_THROUGH;
 
             case TLS_ASYNC_FINALIZE:
             {
                 if (IsEncryptionOn(ssl, 0)) {
                     args->idx += ssl->keys.padSz;
             #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)
                     if (ssl->options.startedETMRead)
                         args->idx += MacSize(ssl);
             #endif
                 }
 
                 ssl->options.havePeerVerify = 1;
 
                 /* Set final index */
                 args->idx += args->sz;
                 *inOutIdx = args->idx;
 
                 /* Advance state and proceed */
                 ssl->options.asyncState = TLS_ASYNC_END;
             } /* case TLS_ASYNC_FINALIZE */
             FALL_THROUGH;
 
             case TLS_ASYNC_END:
             {
                 break;
             }
             default:
                 ret = INPUT_CASE_ERROR;
         } /* switch(ssl->options.asyncState) */
 
     exit_dcv:
 
         WOLFSSL_LEAVE("DoCertificateVerify", ret);
         WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Handle async operation */
         if (ret == WC_PENDING_E) {
             /* Mark message as not received so it can process again */
             ssl->msgsReceived.got_certificate_verify = 0;
 
             return ret;
         }
     #endif /* WOLFSSL_ASYNC_CRYPT */
     #ifdef WOLFSSL_EXTRA_ALERTS
         if (ret == BUFFER_ERROR)
             SendAlert(ssl, alert_fatal, decode_error);
         else if (ret == SIG_VERIFY_E)
             SendAlert(ssl, alert_fatal, decrypt_error);
         else if (ret != 0)
             SendAlert(ssl, alert_fatal, bad_certificate);
     #endif
         /* Digest is not allocated, so do this to prevent free */
         if(ssl->buffers.digest.buffer) {
             if (!ssl->options.dontFreeDigest) {
                 /*This should not happen*/
                 XFREE(ssl->buffers.digest.buffer,
                     ssl->heap, DYNAMIC_TYPE_DIGEST);
             }
         }
         ssl->buffers.digest.buffer = NULL;
         ssl->buffers.digest.length = 0;
         ssl->options.dontFreeDigest = 0;
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         /* Cleanup async */
         FreeAsyncCtx(ssl, 0);
     #else
         FreeDcvArgs(ssl, args);
     #endif
         /* Final cleanup */
         FreeKeyExchange(ssl);
 
         if (ret != 0) {
             WOLFSSL_ERROR_VERBOSE(ret);
         }
 
         return ret;
     }
 
 #endif /* (!NO_RSA || ECC || ED25519 || ED448) && !WOLFSSL_NO_CLIENT_AUTH */
 
     /* handle generation of server_hello_done (14) */
     int SendServerHelloDone(WOLFSSL* ssl)
     {
         byte* output;
         int   sendSz = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
         int   ret;
 
         WOLFSSL_START(WC_FUNC_SERVER_HELLO_DONE_SEND);
         WOLFSSL_ENTER("SendServerHelloDone");
 
     #ifdef WOLFSSL_DTLS
         if (ssl->options.dtls)
             sendSz += DTLS_RECORD_EXTRA + DTLS_HANDSHAKE_EXTRA;
     #endif
 
         if (IsEncryptionOn(ssl, 1))
             sendSz += MAX_MSG_EXTRA;
 
         /* Set this in case CheckAvailableSize returns a WANT_WRITE so that state
          * is not advanced yet */
         ssl->options.buildingMsg = 1;
 
         /* check for available size */
         if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
             return ret;
 
         /* get output buffer */
         output = GetOutputBuffer(ssl);
         AddHeaders(output, 0, server_hello_done, ssl);
 
         if (IsEncryptionOn(ssl, 1)) {
             byte* input;
             int   inputSz = HANDSHAKE_HEADER_SZ; /* build msg adds rec hdr */
             int   recordHeaderSz = RECORD_HEADER_SZ;
 
             if (ssl->options.dtls) {
                 recordHeaderSz += DTLS_RECORD_EXTRA;
                 inputSz += DTLS_HANDSHAKE_EXTRA;
             }
 
             input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
             if (input == NULL)
                 return MEMORY_E;
 
             XMEMCPY(input, output + recordHeaderSz, inputSz);
             #ifdef WOLFSSL_DTLS
             if (IsDtlsNotSctpMode(ssl) &&
                     (ret = DtlsMsgPoolSave(ssl, input, inputSz, server_hello_done)) != 0) {
                 XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
                 return ret;
             }
             #endif
             sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
                                   handshake, 1, 0, 0, CUR_ORDER);
             XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 
             if (sendSz < 0)
                 return sendSz;
         } else {
             #ifdef WOLFSSL_DTLS
                 if (IsDtlsNotSctpMode(ssl)) {
                     if ((ret = DtlsMsgPoolSave(ssl, output, sendSz, server_hello_done)) != 0)
                         return ret;
                 }
                 if (ssl->options.dtls)
                     DtlsSEQIncrement(ssl, CUR_ORDER);
             #endif
             ret = HashOutput(ssl, output, sendSz, 0);
             if (ret != 0)
                 return ret;
         }
 
     #if defined(WOLFSSL_CALLBACKS) || defined(OPENSSL_EXTRA)
         if (ssl->hsInfoOn)
             AddPacketName(ssl, "ServerHelloDone");
         if (ssl->toInfoOn) {
             ret = AddPacketInfo(ssl, "ServerHelloDone", handshake, output,
                     sendSz, WRITE_PROTO, 0, ssl->heap);
             if (ret != 0)
                 return ret;
         }
     #endif
         ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
         ssl->options.buildingMsg = 0;
 
         ssl->buffers.outputBuffer.length += sendSz;
 
         ret = SendBuffered(ssl);
 
         WOLFSSL_LEAVE("SendServerHelloDone", ret);
         WOLFSSL_END(WC_FUNC_SERVER_HELLO_DONE_SEND);
 
         return ret;
     }
 
 #endif /* !WOLFSSL_NO_TLS12 */
 
 #ifdef HAVE_SESSION_TICKET
 
 #ifdef WOLFSSL_TICKET_HAVE_ID
     static void GetRealSessionID(WOLFSSL* ssl, const byte** id, byte* idSz)
     {
         if (ssl->session->haveAltSessionID) {
             *id = ssl->session->altSessionID;
             *idSz = ID_LEN;
         }
         else if (!IsAtLeastTLSv1_3(ssl->version) && ssl->arrays != NULL) {
             *id = ssl->arrays->sessionID;
             *idSz = ssl->arrays->sessionIDSz;
         }
         else {
             *id = ssl->session->sessionID;
             *idSz = ssl->session->sessionIDSz;
         }
     }
 #endif
 
     int SetupTicket(WOLFSSL* ssl)
     {
         int ret = 0;
 
         (void)ssl;
 
 #ifdef WOLFSSL_TLS13
         {
             /* Client adds to ticket age to obfuscate. */
             byte ageAdd[AGEADD_LEN]; /* Obfuscation of age */
             ret = wc_RNG_GenerateBlock(ssl->rng, ageAdd, AGEADD_LEN);
             if (ret != 0)
                 return ret;
             ato32(ageAdd, &ssl->session->ticketAdd);
         }
 #endif
 
 #ifdef WOLFSSL_TICKET_HAVE_ID
         {
             const byte* id = NULL;
             byte idSz = 0;
 
             GetRealSessionID(ssl, &id, &idSz);
             if (idSz == 0) {
                 ret = wc_RNG_GenerateBlock(ssl->rng, ssl->session->altSessionID,
                                            ID_LEN);
                 if (ret != 0)
                     return ret;
                 ssl->session->haveAltSessionID = 1;
             }
         }
 #endif
         return ret;
     }
 
     /* create a new session ticket, 0 on success
      * Do any kind of setup in SetupTicket */
     int CreateTicket(WOLFSSL* ssl)
     {
         InternalTicket* it;
         ExternalTicket* et;
         int encLen;
         int ret;
         int error;
         word32 itHash = 0;
         byte zeros[WOLFSSL_TICKET_MAC_SZ];   /* biggest cmp size */
 
         WOLFSSL_ASSERT_SIZEOF_GE(ssl->session->staticTicket, *et);
         WOLFSSL_ASSERT_SIZEOF_GE(et->enc_ticket, *it);
 
         if (ssl->session->ticket != ssl->session->staticTicket) {
             /* Always use the static ticket buffer */
             XFREE(ssl->session->ticket, NULL, DYNAMIC_TYPE_SESSION_TICK);
             ssl->session->ticket = ssl->session->staticTicket;
             ssl->session->ticketLenAlloc = 0;
         }
 
         et = (ExternalTicket*)ssl->session->ticket;
         it = (InternalTicket*)et->enc_ticket;
 
     #ifdef WOLFSSL_ASYNC_CRYPT
         if (ssl->error != WC_PENDING_E)
     #endif
         {
             XMEMSET(et, 0, sizeof(*et));
         }
 
         /* build internal */
         it->pv.major = ssl->version.major;
         it->pv.minor = ssl->version.minor;
 
         it->suite[0] = ssl->options.cipherSuite0;
         it->suite[1] = ssl->options.cipherSuite;
 
     #ifdef WOLFSSL_EARLY_DATA
         c32toa(ssl->options.maxEarlyDataSz, it->maxEarlyDataSz);
     #endif
 
         if (!ssl->options.tls1_3) {
             if (ssl->arrays == NULL) {
                 WOLFSSL_MSG("CreateTicket called with null arrays");
                 ret = BAD_FUNC_ARG;
                 goto error;
             }
             XMEMCPY(it->msecret, ssl->arrays->masterSecret, SECRET_LEN);
 #ifndef NO_ASN_TIME
             c32toa(LowResTimer(), it->timestamp);
 #endif
             it->haveEMS = (byte) ssl->options.haveEMS;
         }
         else {
 #ifdef WOLFSSL_TLS13
         #ifdef WOLFSSL_32BIT_MILLI_TIME
             word32 now = TimeNowInMilliseconds();
         #else
             sword64 now = TimeNowInMilliseconds();
         #endif
             if (now == 0) {
                 ret = GETTIME_ERROR;
                 goto error;
             }
 
             c32toa(ssl->session->ticketAdd, it->ageAdd);
             c16toa(ssl->session->namedGroup, it->namedGroup);
         #ifdef WOLFSSL_32BIT_MILLI_TIME
             c32toa(now, it->timestamp);
         #else
             c32toa((word32)(now >> 32), it->timestamp);
             c32toa((word32)now        , it->timestamp + OPAQUE32_LEN);
         #endif
             /* Resumption master secret. */
             XMEMCPY(it->msecret, ssl->session->masterSecret, SECRET_LEN);
             if (ssl->session->ticketNonce.len > MAX_TICKET_NONCE_STATIC_SZ) {
                 WOLFSSL_MSG("Bad ticket nonce value");
                 ret = BAD_TICKET_MSG_SZ;
                 goto error;
             }
             XMEMCPY(it->ticketNonce, ssl->session->ticketNonce.data,
                 ssl->session->ticketNonce.len);
             it->ticketNonceLen = ssl->session->ticketNonce.len;
 #endif
         }
 
 #ifdef OPENSSL_EXTRA
         it->sessionCtxSz = ssl->sessionCtxSz;
         XMEMCPY(it->sessionCtx, ssl->sessionCtx, ID_LEN);
 #endif
 
 #ifdef WOLFSSL_TICKET_HAVE_ID
         {
             const byte* id = NULL;
             byte idSz = 0;
             GetRealSessionID(ssl, &id, &idSz);
             /* make sure idSz is not larger than ID_LEN */
             if (idSz > ID_LEN)
                 idSz = ID_LEN;
             XMEMCPY(it->id, id, idSz);
         }
 #endif
 
         /* encrypt */
         encLen = WOLFSSL_TICKET_ENC_SZ;  /* max size user can use */
         if (ssl->ctx->ticketEncCb == NULL
 #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || defined(WOLFSSL_WPAS_SMALL)
                 ||
                 /* SSL_OP_NO_TICKET turns off tickets in <= 1.2. Forces
                  * "stateful" tickets for 1.3 so just use the regular
                  * stateless ones. */
                 (!IsAtLeastTLSv1_3(ssl->version) &&
                         (ssl->options.mask & WOLFSSL_OP_NO_TICKET) != 0)
 #endif
                         ) {
             /* Use BAD_TICKET_ENCRYPT to signal missing ticket callback */
             ret = BAD_TICKET_ENCRYPT;
         }
         else {
             itHash = HashObject((byte*)it, sizeof(*it), &error);
             if (error == 0) {
                 ret = ssl->ctx->ticketEncCb(ssl, et->key_name, et->iv, et->mac,
                         1, et->enc_ticket, sizeof(InternalTicket), &encLen,
                         SSL_TICKET_CTX(ssl));
             }
             else {
                 ret = WOLFSSL_TICKET_RET_FATAL;
             }
         }
         if (ret != WOLFSSL_TICKET_RET_OK) {
 #ifdef WOLFSSL_ASYNC_CRYPT
             if (ret == WC_PENDING_E) {
                 return ret;
             }
 #endif
             goto error;
         }
         if (encLen < (int)sizeof(InternalTicket) ||
                 encLen > (int)WOLFSSL_TICKET_ENC_SZ) {
             WOLFSSL_MSG("Bad user ticket encrypt size");
             ret = BAD_TICKET_KEY_CB_SZ;
         }
 
         /* sanity checks on encrypt callback */
 
         /* internal ticket can't be the same if encrypted */
         if (itHash == HashObject((byte*)it, sizeof(*it), &error) || error != 0)
         {
             WOLFSSL_MSG("User ticket encrypt didn't encrypt or hash failed");
             ret = BAD_TICKET_ENCRYPT;
             goto error;
         }
 
         XMEMSET(zeros, 0, sizeof(zeros));
 
         /* name */
         if (XMEMCMP(et->key_name, zeros, WOLFSSL_TICKET_NAME_SZ) == 0) {
             WOLFSSL_MSG("User ticket encrypt didn't set name");
             ret = BAD_TICKET_ENCRYPT;
             goto error;
         }
 
         /* iv */
         if (XMEMCMP(et->iv, zeros, WOLFSSL_TICKET_IV_SZ) == 0) {
             WOLFSSL_MSG("User ticket encrypt didn't set iv");
             ret = BAD_TICKET_ENCRYPT;
             goto error;
         }
 
         /* mac */
         if (XMEMCMP(et->mac, zeros, WOLFSSL_TICKET_MAC_SZ) == 0) {
             WOLFSSL_MSG("User ticket encrypt didn't set mac");
             ret = BAD_TICKET_ENCRYPT;
             goto error;
         }
 
         /* set size */
         c16toa((word16)encLen, et->enc_len);
         if (encLen < (int)WOLFSSL_TICKET_ENC_SZ) {
             /* move mac up since whole enc buffer not used */
             XMEMMOVE(et->enc_ticket + encLen, et->mac,
                     WOLFSSL_TICKET_MAC_SZ);
         }
         ssl->session->ticketLen =
                 (word16)(encLen + WOLFSSL_TICKET_FIXED_SZ);
 
         return ret;
     error:
 #ifdef WOLFSSL_CHECK_MEM_ZERO
         /* Ticket has sensitive data in it now. */
         wc_MemZero_Add("Create Ticket internal", it, sizeof(InternalTicket));
 #endif
         ForceZero(it, sizeof(*it));
 #ifdef WOLFSSL_CHECK_MEM_ZERO
         wc_MemZero_Check(it, sizeof(InternalTicket));
 #endif
         WOLFSSL_ERROR_VERBOSE(ret);
         return ret;
 
     }
 
     int DoDecryptTicket(const WOLFSSL* ssl, const byte* input, word32 len,
         InternalTicket **it)
     {
         ExternalTicket* et;
         int             ret;
         int             outLen;
         word16          inLen;
 
         WOLFSSL_START(WC_FUNC_TICKET_DO);
         WOLFSSL_ENTER("DoDecryptTicket");
 
         if (len > SESSION_TICKET_LEN ||
             len < (word32)(sizeof(InternalTicket) + WOLFSSL_TICKET_FIXED_SZ)) {
             WOLFSSL_ERROR_VERBOSE(BAD_TICKET_MSG_SZ);
             return WOLFSSL_TICKET_RET_REJECT;
         }
 
         et = (ExternalTicket*)input;
 
         /* decrypt */
         ato16(et->enc_len, &inLen);
         if (inLen > WOLFSSL_TICKET_ENC_SZ) {
             WOLFSSL_ERROR_VERBOSE(BAD_TICKET_MSG_SZ);
             return WOLFSSL_TICKET_RET_REJECT;
         }
         outLen = (int)inLen;   /* may be reduced by user padding */
 
         if (ssl->ctx->ticketEncCb == NULL
 #if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || defined(WOLFSSL_WPAS_SMALL)
                 ||
                 /* SSL_OP_NO_TICKET turns off tickets in < 1.2. Forces
                  * "stateful" tickets for 1.3 so just use the regular
                  * stateless ones. */
                 (!IsAtLeastTLSv1_3(ssl->version) &&
                         (ssl->options.mask & WOLFSSL_OP_NO_TICKET) != 0)
 #endif
                         ) {
             /* Use BAD_TICKET_ENCRYPT to signal missing ticket callback */
             WOLFSSL_ERROR_VERBOSE(BAD_TICKET_ENCRYPT);
             ret = WOLFSSL_TICKET_RET_REJECT;
         }
         else {
             /* Callback uses ssl without const but for DTLS, it really shouldn't
              * modify its state. */
             ret = ssl->ctx->ticketEncCb((WOLFSSL*)ssl, et->key_name, et->iv,
                                     et->enc_ticket + inLen, 0,
                                     et->enc_ticket, inLen, &outLen,
                                     SSL_TICKET_CTX(ssl));
         }
         if (ret != WOLFSSL_TICKET_RET_OK) {
         #ifdef WOLFSSL_ASYNC_CRYPT
             if (ret == WC_PENDING_E) {
                 return ret;
             }
         #endif /* WOLFSSL_ASYNC_CRYPT */
             if (ret != WOLFSSL_TICKET_RET_CREATE) {
                 WOLFSSL_ERROR_VERBOSE(BAD_TICKET_KEY_CB_SZ);
                 return WOLFSSL_TICKET_RET_REJECT;
             }
         }
         if (outLen > (int)inLen || outLen < (int)sizeof(InternalTicket)) {
             WOLFSSL_MSG("Bad user ticket decrypt len");
             WOLFSSL_ERROR_VERBOSE(BAD_TICKET_KEY_CB_SZ);
             return BAD_TICKET_KEY_CB_SZ;
         }
         *it = (InternalTicket*)et->enc_ticket;
         return ret;
     }
 
     static int DoClientTicketCheckVersion(const WOLFSSL* ssl,
             InternalTicket* it)
     {
         if (ssl->version.minor < it->pv.minor) {
             WOLFSSL_MSG("Ticket has greater version");
             return VERSION_ERROR;
         }
         else if (ssl->version.minor > it->pv.minor) {
             if (IsAtLeastTLSv1_3(it->pv) != IsAtLeastTLSv1_3(ssl->version)) {
                 WOLFSSL_MSG("Tickets cannot be shared between "
                                            "TLS 1.3 and TLS 1.2 and lower");
                 return VERSION_ERROR;
             }
 
             if (!ssl->options.downgrade) {
                 WOLFSSL_MSG("Ticket has lesser version");
                 return VERSION_ERROR;
             }
 
             WOLFSSL_MSG("Downgrading protocol due to ticket");
 
             if (it->pv.minor < ssl->options.minDowngrade) {
                 WOLFSSL_MSG("Ticket has lesser version than allowed");
                 return VERSION_ERROR;
             }
         }
     #ifdef WOLFSSL_TLS13
         /* Check resumption master secret. */
         if (IsAtLeastTLSv1_3(it->pv) &&
                 it->ticketNonceLen > MAX_TICKET_NONCE_STATIC_SZ) {
             WOLFSSL_MSG("Unsupported ticketNonce len in ticket");
             return BAD_TICKET_ENCRYPT;
         }
     #endif
         return 0;
     }
 
 #if defined(WOLFSSL_TLS13)
     /* Return 0 when check successful. <0 on failure. */
     int DoClientTicketCheck(const WOLFSSL* ssl, const PreSharedKey* psk,
             sword64 timeout, const byte* suite)
     {
         word32 ticketAdd;
 #ifdef WOLFSSL_32BIT_MILLI_TIME
         word32 now;
         sword64 diff;
         word32 ticketSeen;        /* Time ticket seen (ms) */
 
         ato32(psk->it->timestamp, &ticketSeen);
 
         now = TimeNowInMilliseconds();
         if (now == 0)
             return GETTIME_ERROR;
         /* Difference between now and time ticket constructed
          * (from decrypted ticket). */
         diff = now;
         diff -= ticketSeen;
         if (diff > timeout * 1000 ||
             diff > (sword64)TLS13_MAX_TICKET_AGE * 1000)
             return -1;
 #else
         sword64 diff;
         sword64 ticketSeen; /* Time ticket seen (ms) */
         word32 seenHi, seenLo;
 
         ato32(psk->it->timestamp               , &seenHi);
         ato32(psk->it->timestamp + OPAQUE32_LEN, &seenLo);
         ticketSeen = ((sword64)seenHi << 32) + seenLo;
 
         diff = TimeNowInMilliseconds();
         if (diff == 0)
             return GETTIME_ERROR;
         /* Difference between now and time ticket constructed
          * (from decrypted ticket). */
         diff -= ticketSeen;
         if (diff > timeout * 1000 ||
             diff > (sword64)TLS13_MAX_TICKET_AGE * 1000)
             return -1;
 #endif
         ato32(psk->it->ageAdd, &ticketAdd);
         /* Subtract client's ticket age and unobfuscate. */
         diff -= psk->ticketAge;
         diff += ticketAdd;
         /* Check session and ticket age timeout.
          * Allow +/- 1000 milliseconds on ticket age.
          */
         if (diff < -1000 || diff - MAX_TICKET_AGE_DIFF * 1000 > 1000)
             return -1;
 
 #if !defined(WOLFSSL_PSK_ONE_ID) && !defined(WOLFSSL_PRIORITIZE_PSK)
         /* Check whether resumption is possible based on suites in SSL and
          * ciphersuite in ticket.
          */
         (void)ssl;
         if (XMEMCMP(suite, psk->it->suite, SUITE_LEN) != 0)
             return -1;
 #else
         (void)suite;
         if (!FindSuiteSSL(ssl, psk->it->suite))
             return -1;
 #endif
 #ifdef OPENSSL_EXTRA
         if (ssl->sessionCtxSz > 0 &&
                (psk->it->sessionCtxSz != ssl->sessionCtxSz ||
                 XMEMCMP(psk->it->sessionCtx, ssl->sessionCtx,
                         ssl->sessionCtxSz) != 0))
             return -1;
 #endif
         return 0;
     }
 #endif /* WOLFSSL_SLT13 */
 
     void DoClientTicketFinalize(WOLFSSL* ssl, InternalTicket* it,
             const WOLFSSL_SESSION* sess)
     {
 #ifdef WOLFSSL_TICKET_HAVE_ID
         ssl->session->haveAltSessionID = 1;
         XMEMCPY(ssl->session->altSessionID, it->id, ID_LEN);
 #endif
         if (sess != NULL) {
             byte bogusID[ID_LEN];
             byte bogusIDSz = ssl->session->sessionIDSz;
             XMEMCPY(bogusID, ssl->session->sessionID, ID_LEN);
             /* Failure here should not interrupt the resumption. We already have
              * all the cipher material we need in `it` */
             WOLFSSL_MSG("Copying in session from passed in arg");
             (void)wolfSSL_DupSession(sess, ssl->session, 1);
             /* Restore the fake ID */
             XMEMCPY(ssl->session->sessionID, bogusID, ID_LEN);
             ssl->session->sessionIDSz= bogusIDSz;
         }
 #ifdef WOLFSSL_TICKET_HAVE_ID
         else {
             if (wolfSSL_GetSession(ssl, NULL, 1) != NULL) {
                 WOLFSSL_MSG("Found session matching the session id"
                             " found in the ticket");
             }
             else {
                 WOLFSSL_MSG("Can't find session matching the session id"
                             " found in the ticket");
             }
         }
 #endif
 
         if (!IsAtLeastTLSv1_3(ssl->version)) {
             XMEMCPY(ssl->arrays->masterSecret, it->msecret, SECRET_LEN);
             /* Copy the haveExtendedMasterSecret property from the ticket to
              * the saved session, so the property may be checked later. */
             ssl->session->haveEMS = it->haveEMS;
             ato32((const byte*)&it->timestamp, &ssl->session->bornOn);
 #ifndef NO_RESUME_SUITE_CHECK
             ssl->session->cipherSuite0 = it->suite[0];
             ssl->session->cipherSuite = it->suite[1];
 #endif
         }
         else {
 #ifdef WOLFSSL_TLS13
             /* This should have been already checked in
              * DoClientTicketCheckVersion */
             if (it->ticketNonceLen > MAX_TICKET_NONCE_STATIC_SZ) {
                 WOLFSSL_MSG("Unsupported ticketNonce len in ticket");
                 return;
             }
             /* Restore information to renegotiate. */
 #ifdef WOLFSSL_32BIT_MILLI_TIME
             ato32(it->timestamp, &ssl->session->ticketSeen);
 #else
             {
                 word32 seenHi, seenLo;
 
                 ato32(it->timestamp               , &seenHi);
                 ato32(it->timestamp + OPAQUE32_LEN, &seenLo);
                 ssl->session->ticketSeen = ((sword64)seenHi << 32) + seenLo;
             }
 #endif
             ato32(it->ageAdd, &ssl->session->ticketAdd);
             ssl->session->cipherSuite0 = it->suite[0];
             ssl->session->cipherSuite = it->suite[1];
 #ifdef WOLFSSL_EARLY_DATA
             ato32(it->maxEarlyDataSz, &ssl->session->maxEarlyDataSz);
 #endif
             /* Resumption master secret. */
             XMEMCPY(ssl->session->masterSecret, it->msecret, SECRET_LEN);
 #if defined(WOLFSSL_TICKET_NONCE_MALLOC) && \
      (!defined(HAVE_FIPS) || (defined(FIPS_VERSION_GE) && FIPS_VERSION_GE(5,3)))
             if (ssl->session->ticketNonce.data
                    != ssl->session->ticketNonce.dataStatic) {
                 XFREE(ssl->session->ticketNonce.data, ssl->heap,
                     DYNAMIC_TYPE_SESSION_TICK);
                 ssl->session->ticketNonce.data =
                     ssl->session->ticketNonce.dataStatic;
             }
 #endif /* defined(WOLFSSL_TICKET_NONCE_MALLOC) && FIPS_VERSION_GE(5,3) */
             XMEMCPY(ssl->session->ticketNonce.data, it->ticketNonce,
                 it->ticketNonceLen);
             ssl->session->ticketNonce.len = it->ticketNonceLen;
             ato16(it->namedGroup, &ssl->session->namedGroup);
 #endif
         }
         ssl->version.minor = it->pv.minor;
     }
 
 #if defined(WOLFSSL_TLS13)
     static void PopulateInternalTicketFromSession(const WOLFSSL_SESSION* sess,
             InternalTicket* it)
     {
 #ifdef WOLFSSL_32BIT_MILLI_TIME
         word32 milliBornOn = sess->bornOn;
 #else
         sword64 milliBornOn = (sword64)sess->bornOn;
 #endif
         /* Convert to milliseconds */
         milliBornOn *= 1000;
         it->pv = sess->version;
         it->suite[0] = sess->cipherSuite0;
         it->suite[1] = sess->cipherSuite;
         XMEMCPY(it->msecret, sess->masterSecret, SECRET_LEN);
 #ifdef WOLFSSL_32BIT_MILLI_TIME
         c32toa(milliBornOn, it->timestamp);
 #else
         c32toa((word32)(milliBornOn >> 32), it->timestamp);
         c32toa((word32)milliBornOn        , it->timestamp + OPAQUE32_LEN);
 #endif
         it->haveEMS = (byte)sess->haveEMS;
         c32toa(sess->ticketAdd, it->ageAdd);
         c16toa(sess->namedGroup, it->namedGroup);
         if (sess->ticketNonce.len <= MAX_TICKET_NONCE_STATIC_SZ) {
             it->ticketNonceLen = sess->ticketNonce.len;
             XMEMCPY(it->ticketNonce, sess->ticketNonce.data,
                     sess->ticketNonce.len);
         }
 #ifdef WOLFSSL_EARLY_DATA
         c32toa(sess->maxEarlyDataSz, it->maxEarlyDataSz);
 #endif
 #ifdef WOLFSSL_TICKET_HAVE_ID
         if (sess->haveAltSessionID)
             XMEMCPY(it->id, sess->altSessionID, ID_LEN);
         else
             XMEMCPY(it->id, sess->sessionID, ID_LEN);
 #endif
 #ifdef OPENSSL_EXTRA
         it->sessionCtxSz = sess->sessionCtxSz;
         XMEMCPY(it->sessionCtx, sess->sessionCtx, sess->sessionCtxSz);
 #endif
     }
 
 
     static const WOLFSSL_SESSION* GetSesionFromCacheOrExt(const WOLFSSL* ssl,
             const byte* id, psk_sess_free_cb_ctx* freeCtx)
     {
         const WOLFSSL_SESSION* sess = NULL;
         int ret;
         XMEMSET(freeCtx, 0, sizeof(*freeCtx));
 #ifdef HAVE_EXT_CACHE
         if (ssl->ctx->get_sess_cb != NULL) {
             int copy = 0;
             sess = ssl->ctx->get_sess_cb((WOLFSSL*)ssl,
                     id, ID_LEN, &copy);
             if (sess != NULL) {
                 freeCtx->extCache = 1;
                 /* If copy not set then free immediately */
                 if (!copy)
                     freeCtx->freeSess = 1;
             }
         }
 #endif
         if (sess == NULL) {
             ret = TlsSessionCacheGetAndRdLock(id, &sess, &freeCtx->row,
                     ssl->options.side);
             if (ret != 0)
                 sess = NULL;
         }
         return sess;
     }
 
     static void FreeSessionFromCacheOrExt(const WOLFSSL* ssl,
             const WOLFSSL_SESSION* sess, psk_sess_free_cb_ctx* freeCtx)
     {
         (void)ssl;
         (void)sess;
 #ifdef HAVE_EXT_CACHE
         if (freeCtx->extCache) {
             if (freeCtx->freeSess)
                 /* In this case sess is not longer const and the external cache
                  * wants us to free it. */
                 wolfSSL_FreeSession(ssl->ctx, (WOLFSSL_SESSION*)sess);
         }
         else
 #endif
             TlsSessionCacheUnlockRow(freeCtx->row);
     }
 
     /* Parse ticket sent by client, returns callback return value. Doesn't
      * modify ssl and stores the InternalTicket inside psk */
     int DoClientTicket_ex(const WOLFSSL* ssl, PreSharedKey* psk, int retainSess)
     {
         int ret;
         int decryptRet = WOLFSSL_TICKET_RET_REJECT;
 
         WOLFSSL_START(WC_FUNC_TICKET_DO);
         WOLFSSL_ENTER("DoClientTicket_ex");
 
         if (psk->identityLen == ID_LEN && IsAtLeastTLSv1_3(ssl->version)) {
             /* This is a stateful ticket. We can be sure about this because
              * stateless tickets are much longer. */
             const WOLFSSL_SESSION* sess = NULL;
             sess = GetSesionFromCacheOrExt(ssl, psk->identity,
                     &psk->sess_free_cb_ctx);
             if (sess != NULL) {
                 /* Session found in cache. Copy in relevant info to psk */
                 byte* tmp;
                 WOLFSSL_MSG("Found session matching the session id"
                             " found in the ticket");
                 /* Allocate and populate an InternalTicket */
                 tmp = (byte*)XREALLOC(psk->identity, sizeof(InternalTicket),
                         ssl->heap, DYNAMIC_TYPE_TLSX);
                 if (tmp != NULL) {
                     XMEMSET(tmp, 0, sizeof(InternalTicket));
                     psk->identity = tmp;
                     psk->identityLen = sizeof(InternalTicket);
                     psk->it = (InternalTicket*)tmp;
                     PopulateInternalTicketFromSession(sess, psk->it);
                     decryptRet = WOLFSSL_TICKET_RET_OK;
                     if (retainSess) {
                         psk->sess = sess;
                         psk->sess_free_cb = FreeSessionFromCacheOrExt;
                     }
                 }
                 if (psk->sess == NULL) {
                     FreeSessionFromCacheOrExt(ssl, sess,
                             &psk->sess_free_cb_ctx);
                     XMEMSET(&psk->sess_free_cb_ctx, 0,
                             sizeof(psk_sess_free_cb_ctx));
                 }
             }
         }
         else {
             decryptRet = DoDecryptTicket(ssl, psk->identity, psk->identityLen,
                     &psk->it);
         }
         switch (decryptRet) {
         case WOLFSSL_TICKET_RET_OK:
             psk->decryptRet = PSK_DECRYPT_OK;
             break;
         case WOLFSSL_TICKET_RET_CREATE:
             psk->decryptRet = PSK_DECRYPT_CREATE;
             break;
         default:
             psk->decryptRet = PSK_DECRYPT_FAIL;
             WOLFSSL_LEAVE("DoClientTicket_ex", decryptRet);
             return decryptRet;
         }
 #ifdef WOLFSSL_CHECK_MEM_ZERO
         /* Internal ticket successfully decrypted. */
         wc_MemZero_Add("Do Client Ticket internal", psk->it,
             sizeof(InternalTicket));
 #endif
 
         ret = DoClientTicketCheckVersion(ssl, psk->it);
         if (ret != 0) {
             psk->decryptRet = PSK_DECRYPT_FAIL;
             ForceZero(psk->identity, psk->identityLen);
 #ifdef WOLFSSL_CHECK_MEM_ZERO
             wc_MemZero_Check(psk->it, sizeof(InternalTicket));
 #endif
             WOLFSSL_LEAVE("DoClientTicket_ex", ret);
             return ret;
         }
         WOLFSSL_LEAVE("DoClientTicket_ex", decryptRet);
         return decryptRet;
     }
 #endif /* WOLFSL_TLS13 */
 
     /* Parse ticket sent by client, returns callback return value */
     int DoClientTicket(WOLFSSL* ssl, const byte* input, word32 len)
     {
         int decryptRet = WOLFSSL_TICKET_RET_REJECT;
         int ret;
         InternalTicket* it;
 #ifdef WOLFSSL_TLS13
         InternalTicket staticIt;
         const WOLFSSL_SESSION* sess = NULL;
         psk_sess_free_cb_ctx freeCtx;
 
         XMEMSET(&freeCtx, 0, sizeof(psk_sess_free_cb_ctx));
 #endif
 
         WOLFSSL_START(WC_FUNC_TICKET_DO);
         WOLFSSL_ENTER("DoClientTicket");
 
 #ifdef WOLFSSL_TLS13
         if (len == ID_LEN && IsAtLeastTLSv1_3(ssl->version)) {
             /* This is a stateful ticket. We can be sure about this because
              * stateless tickets are much longer. */
             sess = GetSesionFromCacheOrExt(ssl, input, &freeCtx);
             if (sess != NULL) {
                 it = &staticIt;
                 XMEMSET(it, 0, sizeof(InternalTicket));
                 PopulateInternalTicketFromSession(sess, it);
                 decryptRet = WOLFSSL_TICKET_RET_OK;
             }
         }
         else
 #endif
             decryptRet = DoDecryptTicket(ssl, input, len, &it);
 
         if (decryptRet != WOLFSSL_TICKET_RET_OK &&
                 decryptRet != WOLFSSL_TICKET_RET_CREATE) {
             it = NULL;
             goto cleanup;
         }
     #ifdef WOLFSSL_CHECK_MEM_ZERO
         /* Internal ticket successfully decrypted. */
         wc_MemZero_Add("Do Client Ticket internal", it, sizeof(InternalTicket));
     #endif
 
         ret = DoClientTicketCheckVersion(ssl, it);
         if (ret != 0) {
             decryptRet = ret;
             goto cleanup;
         }
 
         DoClientTicketFinalize(ssl, it, NULL);
