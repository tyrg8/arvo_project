commit b9d897ce63d510a9b62710fffa4c7e7a27e41215
Author: basyskom-jvoe <33348624+basyskom-jvoe@users.noreply.github.com>
Date:   Thu Aug 20 17:07:41 2020 +0200

    feat(plugin): Add support for PEM encoded local certificates (#3854)

diff --git a/plugins/securityPolicies/openssl/securitypolicy_openssl_common.c b/plugins/securityPolicies/openssl/securitypolicy_openssl_common.c
index 57286fa6d..16e630f2b 100755
--- a/plugins/securityPolicies/openssl/securitypolicy_openssl_common.c
+++ b/plugins/securityPolicies/openssl/securitypolicy_openssl_common.c
@@ -162,35 +162,35 @@ UA_StatusCode
 UA_Openssl_X509_GetCertificateThumbprint (const UA_ByteString * certficate,
                                           UA_ByteString *       pThumbprint,
                                           bool                  bThumbPrint) {
     if (bThumbPrint) {
         pThumbprint->length = SHA_DIGEST_LENGTH; 
         UA_StatusCode ret = UA_ByteString_allocBuffer (pThumbprint, pThumbprint->length);
         if (ret != UA_STATUSCODE_GOOD) {
             return ret;
             }
     }
     else {
         if (pThumbprint->length != SHA_DIGEST_LENGTH) {
             return UA_STATUSCODE_BADINTERNALERROR;
         }
     }
-    // The client certificate must be DER encoded
-    X509 * x509Certificate = UA_OpenSSL_LoadDerCertificate(certficate);
+    X509 * x509Certificate = UA_OpenSSL_LoadCertificate(certficate);
+
     if (x509Certificate == NULL) {
         if (bThumbPrint) {
             UA_ByteString_deleteMembers (pThumbprint);
         }
         return UA_STATUSCODE_BADINTERNALERROR;
     }
 
     if (X509_digest (x509Certificate, EVP_sha1(), pThumbprint->data, NULL) 
         != 1) {
         if (bThumbPrint) {
             UA_ByteString_deleteMembers (pThumbprint);
         }
     return UA_STATUSCODE_BADINTERNALERROR;
     }
     X509_free(x509Certificate);
 
     return UA_STATUSCODE_GOOD;                                              
 }
@@ -923,16 +923,37 @@ X509 *
 UA_OpenSSL_LoadPemCertificate(const UA_ByteString *certificate) {
     X509 * result = NULL;
 
     BIO* bio = NULL;
 #if OPENSSL_VERSION_NUMBER < 0x1000207fL
     bio = BIO_new_mem_buf((void *) certificate->data, (int) certificate->length);
 #else
     bio = BIO_new_mem_buf((const void *) certificate->data, (int) certificate->length);
 #endif
     result = PEM_read_bio_X509(bio, NULL, NULL, NULL);
     BIO_free(bio);
 
     return result;
 }
 
+UA_StatusCode
+UA_OpenSSL_LoadLocalCertificate(const UA_ByteString *certificate, UA_ByteString *target) {
+    X509 *cert = UA_OpenSSL_LoadCertificate(certificate);
+
+    if (!cert)
+        return UA_STATUSCODE_BADINVALIDARGUMENT;
+
+    unsigned char *derData = NULL;
+    int length = i2d_X509(cert, &derData);
+    X509_free(cert);
+
+    if (length > 0) {
+        target->length = (size_t) length;
+        target->data = derData;
+        return UA_STATUSCODE_GOOD;
+    }
+
+    return UA_STATUSCODE_BADINVALIDARGUMENT;
+}
+
+
 #endif
diff --git a/plugins/securityPolicies/openssl/securitypolicy_openssl_common.h b/plugins/securityPolicies/openssl/securitypolicy_openssl_common.h
index 487519f75..edf7bd821 100755
--- a/plugins/securityPolicies/openssl/securitypolicy_openssl_common.h
+++ b/plugins/securityPolicies/openssl/securitypolicy_openssl_common.h
@@ -136,6 +136,9 @@ UA_OpenSSL_LoadDerCertificate(const UA_ByteString *certificate);
 X509 *
 UA_OpenSSL_LoadPemCertificate(const UA_ByteString *certificate);
 
+UA_StatusCode
+UA_OpenSSL_LoadLocalCertificate(const UA_ByteString *certificate, UA_ByteString *target);
+
 _UA_END_DECLS
 
 #endif /* UA_ENABLE_ENCRYPTION_OPENSSL */
diff --git a/plugins/securityPolicies/openssl/ua_openssl_basic128rsa15.c b/plugins/securityPolicies/openssl/ua_openssl_basic128rsa15.c
index 8dc294b50..10158708b 100755
--- a/plugins/securityPolicies/openssl/ua_openssl_basic128rsa15.c
+++ b/plugins/securityPolicies/openssl/ua_openssl_basic128rsa15.c
@@ -536,118 +536,117 @@ UA_StatusCode
 UA_SecurityPolicy_Basic128Rsa15 (UA_SecurityPolicy * policy,
                                  const UA_ByteString localCertificate,
                                  const UA_ByteString localPrivateKey, 
                                  const UA_Logger *   logger) {
 
     UA_SecurityPolicyAsymmetricModule * const asymmetricModule = &policy->asymmetricModule;
     UA_SecurityPolicySymmetricModule * const  symmetricModule = &policy->symmetricModule;  
     UA_SecurityPolicyChannelModule * const    channelModule = &policy->channelModule;  
     UA_StatusCode                             retval; 
 
     UA_LOG_INFO (logger, UA_LOGCATEGORY_SECURITYPOLICY, 
                  "The Basic128Rsa15 security policy with openssl is added.");
 
     UA_Openssl_Init ();
     memset(policy, 0, sizeof(UA_SecurityPolicy));
     policy->logger = logger;
     policy->policyUri = UA_STRING("http://opcfoundation.org/UA/SecurityPolicy#Basic128Rsa15\0");
 
     /* set ChannelModule context  */
 
     channelModule->newContext = UA_ChannelModule_Basic128Rsa15_New_Context;
     channelModule->deleteContext = UA_ChannelModule_Basic128Rsa15_Delete_Context;
 
     channelModule->setLocalSymSigningKey = UA_ChannelModule_Basic128Rsa15_setLocalSymSigningKey;
     channelModule->setLocalSymEncryptingKey = UA_ChannelModule_Basic128Rsa15_setLocalSymEncryptingKey;
     channelModule->setLocalSymIv = UA_ChannelModule_Basic128Rsa15_setLocalSymIv;
     channelModule->setRemoteSymSigningKey = UA_ChannelModule_Basic128Rsa15_setRemoteSymSigningKey;
     channelModule->setRemoteSymEncryptingKey = UA_ChannelModule_Basic128Rsa15_setRemoteSymEncryptingKey;
     channelModule->setRemoteSymIv = UA_ChannelModule_Basic128Rsa15_setRemoteSymIv;
     channelModule->compareCertificate = UA_ChannelModule_Basic128Rsa15_compareCertificate;    
 
-    /* Copy the certificate and add a NULL to the end */
+    retval = UA_OpenSSL_LoadLocalCertificate(&localCertificate, &policy->localCertificate);
 
-    retval = UA_copyCertificate (&policy->localCertificate, &localCertificate);
     if (retval != UA_STATUSCODE_GOOD)
         return retval;
 
     /* asymmetricModule */
 
     asymmetricModule->compareCertificateThumbprint = UA_Asy_Basic128Rsa15_compareCertificateThumbprint;
     asymmetricModule->makeCertificateThumbprint = UA_Asy_Basic128Rsa15_makeCertificateThumbprint;
 
     /* AsymmetricModule - signature algorithm */
 
     UA_SecurityPolicySignatureAlgorithm * asySigAlgorithm = 
                     &asymmetricModule->cryptoModule.signatureAlgorithm;
     asySigAlgorithm->uri = UA_STRING("http://www.w3.org/2000/09/xmldsig#rsa-sha1\0");
     asySigAlgorithm->getRemoteSignatureSize = UA_AsySig_Basic128Rsa15_getRemoteSignatureSize;
     asySigAlgorithm->getLocalSignatureSize = UA_AsySig_Basic128Rsa15_getLocalSignatureSize;
     asySigAlgorithm->getLocalKeyLength = NULL;
     asySigAlgorithm->getRemoteKeyLength = NULL;
     asySigAlgorithm->verify = UA_AsySig_Basic128Rsa15_Verify;    
     asySigAlgorithm->sign = UA_AsySig_Basic128Rsa15_Sign;
 
     /*  AsymmetricModule encryption algorithm */
 
     UA_SecurityPolicyEncryptionAlgorithm * asymEncryAlg =
         &asymmetricModule->cryptoModule.encryptionAlgorithm;
     asymEncryAlg->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#rsa-1_5\0");
     asymEncryAlg->getRemotePlainTextBlockSize = UA_AsymEn_Basic128Rsa15_getRemotePlainTextBlockSize;
     asymEncryAlg->getRemoteBlockSize = UA_AsymEn_Basic128Rsa15_getRemoteBlockSize;
     asymEncryAlg->getRemoteKeyLength = UA_AsymEn_Basic128Rsa15_getRemoteKeyLength;
     asymEncryAlg->getLocalKeyLength = UA_AsymEn_Basic128Rsa15_getLocalKeyLength;
     asymEncryAlg->getLocalPlainTextBlockSize = NULL;
     asymEncryAlg->getLocalBlockSize = NULL;
     asymEncryAlg->decrypt = UA_AsymEn_Basic128Rsa15_Decrypt;
     asymEncryAlg->encrypt = UA_AsymEn_Basic128Rsa15_Encrypt;
 
     /* SymmetricModule */
 
     symmetricModule->secureChannelNonceLength = 16;  /* 128 bits*/
     symmetricModule->generateNonce = UA_Sym_Basic128Rsa15_generateNonce;
     symmetricModule->generateKey = UA_Sym_Basic128Rsa15_generateKey; 
 
     /* Symmetric encryption Algorithm */
 
     UA_SecurityPolicyEncryptionAlgorithm * symEncryptionAlgorithm =
         &symmetricModule->cryptoModule.encryptionAlgorithm;
     symEncryptionAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#aes128-cbc\0");   
     symEncryptionAlgorithm->getLocalKeyLength = UA_SymEn_Basic128Rsa15_getLocalKeyLength;
     symEncryptionAlgorithm->getLocalBlockSize = UA_SymEn_Basic128Rsa15_getBlockSize;
     symEncryptionAlgorithm->getRemoteKeyLength = UA_SymEn_Basic128Rsa15_getRemoteKeyLength;
     symEncryptionAlgorithm->getRemoteBlockSize = UA_SymEn_Basic128Rsa15_getBlockSize;
     symEncryptionAlgorithm->getLocalPlainTextBlockSize = UA_SymEn_Basic128Rsa15_getPlainTextBlockSize;
     symEncryptionAlgorithm->getRemotePlainTextBlockSize = UA_SymEn_Basic128Rsa15_getPlainTextBlockSize;
     symEncryptionAlgorithm->decrypt = UA_SymEn_Basic128Rsa15_Decrypt;
     symEncryptionAlgorithm->encrypt = UA_SymEn_Basic128Rsa15_Encrypt;    
 
     /* Symmetric signature Algorithm */
 
     UA_SecurityPolicySignatureAlgorithm * symSignatureAlgorithm =
         &symmetricModule->cryptoModule.signatureAlgorithm;
     symSignatureAlgorithm->uri = UA_STRING("http://www.w3.org/2000/09/xmldsig#hmac-sha1\0");
     symSignatureAlgorithm->getLocalKeyLength = UA_SymSig_Basic128Rsa15_getKeyLength;
     symSignatureAlgorithm->getRemoteKeyLength = UA_SymSig_Basic128Rsa15_getKeyLength;
     symSignatureAlgorithm->getRemoteSignatureSize = UA_SymSig_Basic128Rsa15_getSignatureSize;
     symSignatureAlgorithm->getLocalSignatureSize = UA_SymSig_Basic128Rsa15_getSignatureSize;
 
     symSignatureAlgorithm->verify = UA_SymSig_Basic128Rsa15_Verify;
     symSignatureAlgorithm->sign = UA_SymSig_Basic128Rsa15_Sign;
 
     /* set the policy context */
 
     retval = UA_Policy_Basic128Rsa15_New_Context (policy, localPrivateKey, logger);
     if (retval != UA_STATUSCODE_GOOD) {
         UA_ByteString_clear (&policy->localCertificate);
         return retval;
     }
     policy->clear = UA_Policy_Basic128Rsa15_Clear_Context;    
 
     /* Use the same signature algorithm as the asymmetric component for 
        certificate signing (see standard) */
     policy->certificateSigningAlgorithm = policy->asymmetricModule.cryptoModule.signatureAlgorithm;
 
     return UA_STATUSCODE_GOOD;
 }
 
 #endif
diff --git a/plugins/securityPolicies/openssl/ua_openssl_basic256.c b/plugins/securityPolicies/openssl/ua_openssl_basic256.c
index a675668eb..193dd4b96 100755
--- a/plugins/securityPolicies/openssl/ua_openssl_basic256.c
+++ b/plugins/securityPolicies/openssl/ua_openssl_basic256.c
@@ -539,116 +539,115 @@ UA_StatusCode
 UA_SecurityPolicy_Basic256 (UA_SecurityPolicy * policy,
                             const UA_ByteString localCertificate,
                             const UA_ByteString localPrivateKey, 
                             const UA_Logger *   logger) {
     UA_SecurityPolicyAsymmetricModule * const asymmetricModule = &policy->asymmetricModule;
     UA_SecurityPolicySymmetricModule * const  symmetricModule = &policy->symmetricModule; 
     UA_SecurityPolicyChannelModule * const    channelModule = &policy->channelModule;  
     UA_StatusCode                             retval; 
 
     UA_LOG_INFO (logger, UA_LOGCATEGORY_SECURITYPOLICY, 
                  "The basic256 security policy with openssl is added.");
 
     UA_Openssl_Init ();
     memset(policy, 0, sizeof(UA_SecurityPolicy));
     policy->logger = logger;
     policy->policyUri = UA_STRING("http://opcfoundation.org/UA/SecurityPolicy#Basic256\0");
 
     /* set ChannelModule context  */
 
     channelModule->newContext = UA_ChannelModule_Basic256_New_Context;
     channelModule->deleteContext = UA_ChannelModule_Basic256_Delete_Context;
 
     channelModule->setLocalSymSigningKey = UA_ChannelModule_Basic256_setLocalSymSigningKey;
     channelModule->setLocalSymEncryptingKey = UA_ChannelModule_Basic256_setLocalSymEncryptingKey;
     channelModule->setLocalSymIv = UA_ChannelModule_Basic256_setLocalSymIv;
     channelModule->setRemoteSymSigningKey = UA_ChannelModule_Basic256_setRemoteSymSigningKey;
     channelModule->setRemoteSymEncryptingKey = UA_ChannelModule_Basic256_setRemoteSymEncryptingKey;
     channelModule->setRemoteSymIv = UA_ChannelModule_Basic256_setRemoteSymIv;
     channelModule->compareCertificate = UA_ChannelModule_Basic256_compareCertificate;
 
-    /* Copy the certificate and add a NULL to the end */
+    retval = UA_OpenSSL_LoadLocalCertificate(&localCertificate, &policy->localCertificate);
 
-    retval = UA_copyCertificate (&policy->localCertificate, &localCertificate);
     if (retval != UA_STATUSCODE_GOOD)
         return retval;
 
     /* asymmetricModule */
 
     asymmetricModule->compareCertificateThumbprint = UA_Asy_Basic256_compareCertificateThumbprint;
     asymmetricModule->makeCertificateThumbprint = UA_Asy_Basic256_makeCertificateThumbprint;
 
     /* AsymmetricModule - signature algorithm */
 
     UA_SecurityPolicySignatureAlgorithm * asySigAlgorithm =
         &asymmetricModule->cryptoModule.signatureAlgorithm;
     asySigAlgorithm->uri = UA_STRING("http://www.w3.org/2000/09/xmldsig#rsa-sha1\0");
     asySigAlgorithm->getRemoteSignatureSize = UA_AsySig_Basic256_getRemoteSignatureSize;
     asySigAlgorithm->getLocalSignatureSize = UA_AsySig_Basic256_getLocalSignatureSize;
     asySigAlgorithm->verify = UA_AsySig_Basic256_Verify;    
     asySigAlgorithm->sign = UA_AsySig_Basic256_Sign;
     asySigAlgorithm->getLocalKeyLength = NULL;
     asySigAlgorithm->getRemoteKeyLength = NULL;
 
     /*  AsymmetricModule encryption algorithm */
 
     UA_SecurityPolicyEncryptionAlgorithm * asymEncryAlg =
         &asymmetricModule->cryptoModule.encryptionAlgorithm;
     asymEncryAlg->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#rsa-oaep\0");
     asymEncryAlg->getRemotePlainTextBlockSize = UA_AsymEn_Basic256_getRemotePlainTextBlockSize;
     asymEncryAlg->getRemoteBlockSize = UA_AsymEn_Basic256_getRemoteBlockSize;
     asymEncryAlg->getRemoteKeyLength = UA_AsymEn_Basic256_getRemoteKeyLength;
     asymEncryAlg->getLocalKeyLength = UA_AsymEn_Basic256_getLocalKeyLength;
     asymEncryAlg->getLocalPlainTextBlockSize = NULL;
     asymEncryAlg->getLocalBlockSize = NULL;    
     asymEncryAlg->decrypt = UA_AsymEn_Basic256_Decrypt;
     asymEncryAlg->encrypt = UA_AsymEn_Basic256_Encrypt;
 
     /* SymmetricModule */
 
     symmetricModule->secureChannelNonceLength = 32;
     symmetricModule->generateNonce = UA_Sym_Basic256_generateNonce;
     symmetricModule->generateKey = UA_Sym_Basic256_generateKey; 
 
     /* Symmetric encryption Algorithm */
 
     UA_SecurityPolicyEncryptionAlgorithm * symEncryptionAlgorithm =
         &symmetricModule->cryptoModule.encryptionAlgorithm;
     symEncryptionAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#aes256-cbc\0");   
     symEncryptionAlgorithm->getLocalKeyLength = UA_SymEn_Basic256_getLocalKeyLength;
     symEncryptionAlgorithm->getLocalBlockSize = UA_SymEn_Basic256_getBlockSize;
     symEncryptionAlgorithm->getRemoteKeyLength = UA_SymEn_Basic256_getRemoteKeyLength;
     symEncryptionAlgorithm->getRemoteBlockSize = UA_SymEn_Basic256_getBlockSize;
     symEncryptionAlgorithm->getLocalPlainTextBlockSize = UA_SymEn_Basic256_getPlainTextBlockSize;
     symEncryptionAlgorithm->getRemotePlainTextBlockSize = UA_SymEn_Basic256_getPlainTextBlockSize;
     symEncryptionAlgorithm->decrypt = UA_SymEn_Basic256_Decrypt;
     symEncryptionAlgorithm->encrypt = UA_SymEn_Basic256_Encrypt;
 
     /* Symmetric signature Algorithm */
 
     UA_SecurityPolicySignatureAlgorithm * symSignatureAlgorithm =
         &symmetricModule->cryptoModule.signatureAlgorithm;
     symSignatureAlgorithm->uri = UA_STRING("http://www.w3.org/2000/09/xmldsig#hmac-sha1\0");
     symSignatureAlgorithm->getLocalKeyLength = UA_SymSig_Basic256_getKeyLength;
     symSignatureAlgorithm->getRemoteKeyLength = UA_SymSig_Basic256_getKeyLength;
     symSignatureAlgorithm->getRemoteSignatureSize = UA_SymSig_Basic256_getSignatureSize;
     symSignatureAlgorithm->getLocalSignatureSize = UA_SymSig_Basic256_getSignatureSize;
     symSignatureAlgorithm->verify = UA_SymSig_Basic256_Verify;
     symSignatureAlgorithm->sign = UA_SymSig_Basic256_Sign;
 
     /* set the policy context */
 
     retval = UA_Policy_Basic256_New_Context (policy, localPrivateKey, logger);
     if (retval != UA_STATUSCODE_GOOD) {
         UA_ByteString_clear (&policy->localCertificate);
         return retval;
     }
     policy->clear = UA_Policy_Basic256_Clear_Context;    
 
     /* Use the same signature algorithm as the asymmetric component for 
        certificate signing (see standard) */
     policy->certificateSigningAlgorithm = policy->asymmetricModule.cryptoModule.signatureAlgorithm;
 
     return UA_STATUSCODE_GOOD;
 }
 
 #endif
diff --git a/plugins/securityPolicies/openssl/ua_openssl_basic256sha256.c b/plugins/securityPolicies/openssl/ua_openssl_basic256sha256.c
index 46341538f..d95a1bd60 100755
--- a/plugins/securityPolicies/openssl/ua_openssl_basic256sha256.c
+++ b/plugins/securityPolicies/openssl/ua_openssl_basic256sha256.c
@@ -552,117 +552,116 @@ UA_StatusCode
 UA_SecurityPolicy_Basic256Sha256(UA_SecurityPolicy * policy,
                                  const UA_ByteString localCertificate,
                                  const UA_ByteString localPrivateKey, 
                                  const UA_Logger *   logger) {
 
     UA_SecurityPolicyAsymmetricModule * const asymmetricModule = &policy->asymmetricModule;
     UA_SecurityPolicySymmetricModule * const  symmetricModule = &policy->symmetricModule;
     UA_SecurityPolicyChannelModule * const    channelModule = &policy->channelModule; 
     UA_StatusCode                             retval;
 
     UA_LOG_INFO (logger, UA_LOGCATEGORY_SECURITYPOLICY, 
                  "The basic256sha256 security policy with openssl is added.");
 
     UA_Openssl_Init ();
     memset(policy, 0, sizeof(UA_SecurityPolicy));
     policy->logger = logger;
     policy->policyUri = UA_STRING("http://opcfoundation.org/UA/SecurityPolicy#Basic256Sha256\0");
 
     /* set ChannelModule context  */
 
     channelModule->newContext = UA_ChannelModule_New_Context;
     channelModule->deleteContext = UA_ChannelModule_Delete_Context;
     channelModule->setLocalSymSigningKey = UA_ChannelModule_Basic256Sha256_setLocalSymSigningKey;
     channelModule->setLocalSymEncryptingKey = UA_ChannelM_Basic256Sha256_setLocalSymEncryptingKey;
     channelModule->setLocalSymIv = UA_ChannelM_Basic256Sha256_setLocalSymIv;
     channelModule->setRemoteSymSigningKey = UA_ChannelM_Basic256Sha256_setRemoteSymSigningKey;
     channelModule->setRemoteSymEncryptingKey = UA_ChannelM_Basic256Sha256_setRemoteSymEncryptingKey;
     channelModule->setRemoteSymIv = UA_ChannelM_Basic256Sha256_setRemoteSymIv;
     channelModule->compareCertificate = UA_ChannelM_Basic256Sha256_compareCertificate;
 
-    /* Copy the certificate and add a NULL to the end */
+    retval = UA_OpenSSL_LoadLocalCertificate(&localCertificate, &policy->localCertificate);
 
-    retval = UA_copyCertificate (&policy->localCertificate, &localCertificate);
     if (retval != UA_STATUSCODE_GOOD)
         return retval;
 
     /* AsymmetricModule - signature algorithm */
 
     UA_SecurityPolicySignatureAlgorithm * asySigAlgorithm =
         &asymmetricModule->cryptoModule.signatureAlgorithm;
     asySigAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\0");
     asySigAlgorithm->verify = UA_AsySig_Basic256Sha256_Verify;
     asySigAlgorithm->getRemoteSignatureSize = UA_Asym_Basic256Sha256_getRemoteSignatureSize;
     asySigAlgorithm->getLocalSignatureSize = UA_AsySig_Basic256Sha256_getLocalSignatureSize;
     asySigAlgorithm->sign = UA_AsySig_Basic256Sha256_sign;
     asySigAlgorithm->getLocalKeyLength = NULL;
     asySigAlgorithm->getRemoteKeyLength = NULL;
 
     /*  AsymmetricModule encryption algorithm */
 
     UA_SecurityPolicyEncryptionAlgorithm * asymEncryAlg =
         &asymmetricModule->cryptoModule.encryptionAlgorithm;
     asymEncryAlg->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#rsa-oaep\0");
     asymEncryAlg->decrypt = UA_Asym_Basic256Sha256_Decrypt;
     asymEncryAlg->getRemotePlainTextBlockSize = 
             UA_AsymEn_Basic256Sha256_getRemotePlainTextBlockSize;
     asymEncryAlg->getRemoteBlockSize = UA_AsymEn_Basic256Sha256_getRemoteBlockSize;
     asymEncryAlg->getRemoteKeyLength = UA_AsymEn_Basic256Sha256_getRemoteKeyLength;
     asymEncryAlg->encrypt = UA_AsymEn_Basic256Sha256_encrypt;
     asymEncryAlg->getLocalKeyLength = UA_AsymEn_Basic256Sha256_getLocalKeyLength;
     asymEncryAlg->getLocalPlainTextBlockSize = NULL;
     asymEncryAlg->getLocalBlockSize = NULL;
 
     /* asymmetricModule */
 
     asymmetricModule->compareCertificateThumbprint = UA_compareCertificateThumbprint;
     asymmetricModule->makeCertificateThumbprint = UA_makeCertificateThumbprint;
 
     /* SymmetricModule */
 
     symmetricModule->secureChannelNonceLength = 32;
     symmetricModule->generateNonce = UA_Sym_Basic256Sha256_generateNonce;
     symmetricModule->generateKey = UA_Sym_Basic256Sha256_generateKey;
 
     /* Symmetric encryption Algorithm */
 
     UA_SecurityPolicyEncryptionAlgorithm * symEncryptionAlgorithm =
         &symmetricModule->cryptoModule.encryptionAlgorithm;
     symEncryptionAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#aes256-cbc\0");        
     symEncryptionAlgorithm->getLocalKeyLength = UA_SymEn_Basic256Sha256_getLocalKeyLength;
     symEncryptionAlgorithm->getLocalBlockSize = UA_SymEn_Basic256Sha256_getLocalBlockSize;
     symEncryptionAlgorithm->getRemoteKeyLength = UA_SymEn_Basic256Sha256_getRemoteKeyLength;
     symEncryptionAlgorithm->getRemoteBlockSize = UA_SymEn_Basic256Sha256_getRemoteBlockSize;
     symEncryptionAlgorithm->decrypt = UA_SymEn_Basic256Sha256_decrypt;
     symEncryptionAlgorithm->encrypt = UA_SymEn_Basic256Sha256_encrypt;
     symEncryptionAlgorithm->getLocalPlainTextBlockSize = 
                   UA_SymEn_Basic256Sha256_getLocalPlainTextBlockSize;
 
     /* Symmetric signature Algorithm */
 
     UA_SecurityPolicySignatureAlgorithm * symSignatureAlgorithm =
         &symmetricModule->cryptoModule.signatureAlgorithm;
     symSignatureAlgorithm->uri = UA_STRING("http://www.w3.org/2000/09/xmldsig#hmac-sha2-256\0");
     symSignatureAlgorithm->getLocalKeyLength = UA_SymSig_Basic256Sha256_getLocalKeyLength;
     symSignatureAlgorithm->getRemoteKeyLength = UA_SymSig_Basic256Sha256_getRemoteKeyLength;
     symSignatureAlgorithm->getRemoteSignatureSize = 
                            UA_SymSig_Basic256Sha256_getRemoteSignatureSize;
     symSignatureAlgorithm->verify = UA_SymSig_Basic256Sha256_verify;
     symSignatureAlgorithm->sign = UA_SymSig_Basic256Sha256_sign;
     symSignatureAlgorithm->getLocalSignatureSize = UA_SymSig_Basic256Sha256_getLocalSignatureSize;
 
     retval = UA_Policy_New_Context (policy, localPrivateKey, logger);
     if (retval != UA_STATUSCODE_GOOD) {
         UA_ByteString_clear (&policy->localCertificate);
         return retval;
     }
     policy->clear = UA_Policy_Clear_Context;
 
     /* Use the same signature algorithm as the asymmetric component for 
        certificate signing (see standard) */
        
     policy->certificateSigningAlgorithm = policy->asymmetricModule.cryptoModule.signatureAlgorithm;
 
     return UA_STATUSCODE_GOOD;
 }
 
 #endif
diff --git a/plugins/securityPolicies/securitypolicy_mbedtls_common.c b/plugins/securityPolicies/securitypolicy_mbedtls_common.c
index 9f3f16c19..980f9322d 100755
--- a/plugins/securityPolicies/securitypolicy_mbedtls_common.c
+++ b/plugins/securityPolicies/securitypolicy_mbedtls_common.c
@@ -212,33 +212,59 @@ UA_StatusCode
 mbedtls_decrypt_rsaOaep(mbedtls_pk_context *localPrivateKey,
                         mbedtls_ctr_drbg_context *drbgContext,
                         UA_ByteString *data) {
     mbedtls_rsa_context *rsaContext = mbedtls_pk_rsa(*localPrivateKey);
     mbedtls_rsa_set_padding(rsaContext, MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA1);
 
     if(data->length % rsaContext->len != 0)
         return UA_STATUSCODE_BADINTERNALERROR;
 
     size_t inOffset = 0;
     size_t outOffset = 0;
     size_t outLength = 0;
     unsigned char buf[512];
 
     while(inOffset < data->length) {
         int mbedErr = mbedtls_rsa_rsaes_oaep_decrypt(rsaContext, mbedtls_ctr_drbg_random,
                                                      drbgContext, MBEDTLS_RSA_PRIVATE,
                                                      NULL, 0, &outLength,
                                                      data->data + inOffset,
                                                      buf, 512);
         if(mbedErr)
             return UA_STATUSCODE_BADSECURITYCHECKSFAILED;
 
         memcpy(data->data + outOffset, buf, outLength);
         inOffset += rsaContext->len;
         outOffset += outLength;
     }
 
     data->length = outOffset;
     return UA_STATUSCODE_GOOD;
 }
 
+int UA_mbedTLS_LoadPrivateKey(const UA_ByteString *key, mbedtls_pk_context *target)
+{
+    return mbedtls_pk_parse_key(target, key->data, key->length, NULL, 0);
+}
+
+UA_StatusCode UA_mbedTLS_LoadLocalCertificate(const UA_ByteString *certData, UA_ByteString *target)
+{
+    mbedtls_x509_crt cert;
+    mbedtls_x509_crt_init(&cert);
+
+    int mbedErr = mbedtls_x509_crt_parse(&cert, certData->data, certData->length);
+
+    UA_StatusCode result = UA_STATUSCODE_BADINVALIDARGUMENT;
+
+    if (!mbedErr) {
+        UA_ByteString tmp;
+        tmp.data = cert.raw.p;
+        tmp.length = cert.raw.len;
+
+        result = UA_ByteString_copy(&tmp, target);
+    }
+
+    mbedtls_x509_crt_free(&cert);
+    return result;
+}
+
 #endif
diff --git a/plugins/securityPolicies/securitypolicy_mbedtls_common.h b/plugins/securityPolicies/securitypolicy_mbedtls_common.h
index 546db8030..320afdddf 100644
--- a/plugins/securityPolicies/securitypolicy_mbedtls_common.h
+++ b/plugins/securityPolicies/securitypolicy_mbedtls_common.h
@@ -64,6 +64,10 @@ mbedtls_decrypt_rsaOaep(mbedtls_pk_context *localPrivateKey,
                         mbedtls_ctr_drbg_context *drbgContext,
                         UA_ByteString *data);
 
+int UA_mbedTLS_LoadPrivateKey(const UA_ByteString *key, mbedtls_pk_context *target);
+
+UA_StatusCode UA_mbedTLS_LoadLocalCertificate(const UA_ByteString *certData, UA_ByteString *target);
+
 _UA_END_DECLS
 
 #endif
diff --git a/plugins/securityPolicies/ua_securitypolicy_basic128rsa15.c b/plugins/securityPolicies/ua_securitypolicy_basic128rsa15.c
index 3962095af..39ed81025 100755
--- a/plugins/securityPolicies/ua_securitypolicy_basic128rsa15.c
+++ b/plugins/securityPolicies/ua_securitypolicy_basic128rsa15.c
@@ -1,41 +1,42 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  *
  *    Copyright 2018-2019 (c) Mark Giraud, Fraunhofer IOSB
  *    Copyright 2019 (c) Kalycito Infotech Private Limited
  *    Copyright 2018 (c) HMS Industrial Networks AB (Author: Jonas Green)
  *    Copyright 2020 (c) Wind River Systems, Inc.
+ *    Copyright 2020 (c) basysKom GmbH
  * 
  */
 
 #include <open62541/plugin/securitypolicy_default.h>
 #include <open62541/util.h>
 
 #ifdef UA_ENABLE_ENCRYPTION_MBEDTLS
 
 #include "securitypolicy_mbedtls_common.h"
 
 #include <mbedtls/aes.h>
 #include <mbedtls/ctr_drbg.h>
 #include <mbedtls/entropy.h>
 #include <mbedtls/entropy_poll.h>
 #include <mbedtls/error.h>
 #include <mbedtls/md.h>
 #include <mbedtls/sha1.h>
 #include <mbedtls/version.h>
 #include <mbedtls/x509_crt.h>
 
 /* Notes:
  * mbedTLS' AES allows in-place encryption and decryption. Sow we don't have to
  * allocate temp buffers.
  * https://tls.mbed.org/discussions/generic/in-place-decryption-with-aes256-same-input-output-buffer
  */
 
 #define UA_SECURITYPOLICY_BASIC128RSA15_RSAPADDING_LEN 11
 #define UA_SECURITYPOLICY_BASIC128RSA15_SYM_KEY_LENGTH 16
 #define UA_BASIC128RSA15_SYM_SIGNING_KEY_LENGTH 16
 #define UA_SECURITYPOLICY_BASIC128RSA15_SYM_ENCRYPTION_BLOCK_SIZE 16
 #define UA_SECURITYPOLICY_BASIC128RSA15_SYM_PLAIN_TEXT_BLOCK_SIZE 16
 #define UA_SECURITYPOLICY_BASIC128RSA15_MINASYMKEYLENGTH 128
 #define UA_SECURITYPOLICY_BASIC128RSA15_MAXASYMKEYLENGTH 512
@@ -614,46 +615,44 @@ static UA_StatusCode
 updateCertificateAndPrivateKey_sp_basic128rsa15(UA_SecurityPolicy *securityPolicy,
                                                 const UA_ByteString newCertificate,
                                                 const UA_ByteString newPrivateKey) {
     if(securityPolicy == NULL)
         return UA_STATUSCODE_BADINTERNALERROR;
 
     if(securityPolicy->policyContext == NULL)
         return UA_STATUSCODE_BADINTERNALERROR;
 
     Basic128Rsa15_PolicyContext *pc = (Basic128Rsa15_PolicyContext *)securityPolicy->policyContext;
 
     UA_ByteString_deleteMembers(&securityPolicy->localCertificate);
 
-    UA_StatusCode retval = UA_ByteString_allocBuffer(&securityPolicy->localCertificate, newCertificate.length + 1);
-    if(retval != UA_STATUSCODE_GOOD)
+    UA_StatusCode retval = UA_mbedTLS_LoadLocalCertificate(&newCertificate, &securityPolicy->localCertificate);
+
+    if (retval != UA_STATUSCODE_GOOD)
         return retval;
-    memcpy(securityPolicy->localCertificate.data, newCertificate.data, newCertificate.length);
-    securityPolicy->localCertificate.data[newCertificate.length] = '\0';
-    securityPolicy->localCertificate.length--;
 
     /* Set the new private key */
     mbedtls_pk_free(&pc->localPrivateKey);
     mbedtls_pk_init(&pc->localPrivateKey);
     int mbedErr = mbedtls_pk_parse_key(&pc->localPrivateKey,
                                        newPrivateKey.data, newPrivateKey.length,
                                        NULL, 0);
     if(mbedErr) {
         retval = UA_STATUSCODE_BADSECURITYCHECKSFAILED;
         goto error;
     }
 
     retval = asym_makeThumbprint_sp_basic128rsa15(securityPolicy,
                                                   &securityPolicy->localCertificate,
                                                   &pc->localCertThumbprint);
     if(retval != UA_STATUSCODE_GOOD)
         goto error;
 
     return retval;
 
     error:
     UA_LOG_ERROR(securityPolicy->logger, UA_LOGCATEGORY_SECURITYPOLICY,
                  "Could not update certificate and private key");
     if(securityPolicy->policyContext != NULL)
         clear_sp_basic128rsa15(securityPolicy);
     return retval;
 }
@@ -746,139 +745,135 @@ UA_StatusCode
 UA_SecurityPolicy_Basic128Rsa15(UA_SecurityPolicy *policy, const UA_ByteString localCertificate,
                                 const UA_ByteString localPrivateKey, const UA_Logger *logger) {
     memset(policy, 0, sizeof(UA_SecurityPolicy));
     policy->logger = logger;
 
     policy->policyUri = UA_STRING("http://opcfoundation.org/UA/SecurityPolicy#Basic128Rsa15\0");
 
     UA_SecurityPolicyAsymmetricModule *const asymmetricModule = &policy->asymmetricModule;
     UA_SecurityPolicySymmetricModule *const symmetricModule = &policy->symmetricModule;
     UA_SecurityPolicyChannelModule *const channelModule = &policy->channelModule;
 
-    /* Copy the certificate and add a NULL to the end */
-    UA_StatusCode retval =
-        UA_ByteString_allocBuffer(&policy->localCertificate, localCertificate.length + 1);
-    if(retval != UA_STATUSCODE_GOOD)
+    UA_StatusCode retval = UA_mbedTLS_LoadLocalCertificate(&localCertificate, &policy->localCertificate);
+
+    if (retval != UA_STATUSCODE_GOOD)
         return retval;
-    memcpy(policy->localCertificate.data, localCertificate.data, localCertificate.length);
-    policy->localCertificate.data[localCertificate.length] = '\0';
-    policy->localCertificate.length--;
 
     /* AsymmetricModule */
     UA_SecurityPolicySignatureAlgorithm *asym_signatureAlgorithm =
         &asymmetricModule->cryptoModule.signatureAlgorithm;
     asym_signatureAlgorithm->uri =
         UA_STRING("http://www.w3.org/2000/09/xmldsig#rsa-sha1\0");
     asym_signatureAlgorithm->verify =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *,
                            const UA_ByteString *, const UA_ByteString *))asym_verify_sp_basic128rsa15;
     asym_signatureAlgorithm->sign =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *,
                            const UA_ByteString *, UA_ByteString *))asym_sign_sp_basic128rsa15;
     asym_signatureAlgorithm->getLocalSignatureSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getLocalSignatureSize_sp_basic128rsa15;
     asym_signatureAlgorithm->getRemoteSignatureSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getRemoteSignatureSize_sp_basic128rsa15;
     asym_signatureAlgorithm->getLocalKeyLength = NULL; // TODO: Write function
     asym_signatureAlgorithm->getRemoteKeyLength = NULL; // TODO: Write function
 
     UA_SecurityPolicyEncryptionAlgorithm *asym_encryptionAlgorithm =
         &asymmetricModule->cryptoModule.encryptionAlgorithm;
     asym_encryptionAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#rsa-1_5");
     asym_encryptionAlgorithm->encrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))asym_encrypt_sp_basic128rsa15;
     asym_encryptionAlgorithm->decrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))
             asym_decrypt_sp_basic128rsa15;
     asym_encryptionAlgorithm->getLocalKeyLength =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getLocalEncryptionKeyLength_sp_basic128rsa15;
     asym_encryptionAlgorithm->getRemoteKeyLength =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getRemoteEncryptionKeyLength_sp_basic128rsa15;
     asym_encryptionAlgorithm->getLocalBlockSize = NULL; // TODO: Write function
     asym_encryptionAlgorithm->getRemoteBlockSize = (size_t (*)(const UA_SecurityPolicy *,
                                                                const void *))asym_getRemoteBlockSize_sp_basic128rsa15;
     asym_encryptionAlgorithm->getLocalPlainTextBlockSize = NULL; // TODO: Write function
     asym_encryptionAlgorithm->getRemotePlainTextBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getRemotePlainTextBlockSize_sp_basic128rsa15;
 
     asymmetricModule->makeCertificateThumbprint = asym_makeThumbprint_sp_basic128rsa15;
     asymmetricModule->compareCertificateThumbprint =
         asymmetricModule_compareCertificateThumbprint_sp_basic128rsa15;
 
     /* SymmetricModule */
     symmetricModule->generateKey = sym_generateKey_sp_basic128rsa15;
     symmetricModule->generateNonce = sym_generateNonce_sp_basic128rsa15;
 
     UA_SecurityPolicySignatureAlgorithm *sym_signatureAlgorithm =
         &symmetricModule->cryptoModule.signatureAlgorithm;
     sym_signatureAlgorithm->uri =
         UA_STRING("http://www.w3.org/2000/09/xmldsig#hmac-sha1\0");
     sym_signatureAlgorithm->verify =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *, const UA_ByteString *,
                            const UA_ByteString *))sym_verify_sp_basic128rsa15;
     sym_signatureAlgorithm->sign =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *,
                            const UA_ByteString *, UA_ByteString *))sym_sign_sp_basic128rsa15;
     sym_signatureAlgorithm->getLocalSignatureSize = sym_getSignatureSize_sp_basic128rsa15;
     sym_signatureAlgorithm->getRemoteSignatureSize = sym_getSignatureSize_sp_basic128rsa15;
     sym_signatureAlgorithm->getLocalKeyLength =
         (size_t (*)(const UA_SecurityPolicy *,
                     const void *))sym_getSigningKeyLength_sp_basic128rsa15;
     sym_signatureAlgorithm->getRemoteKeyLength =
         (size_t (*)(const UA_SecurityPolicy *,
                     const void *))sym_getSigningKeyLength_sp_basic128rsa15;
 
     UA_SecurityPolicyEncryptionAlgorithm *sym_encryptionAlgorithm =
         &symmetricModule->cryptoModule.encryptionAlgorithm;
     sym_encryptionAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#aes128-cbc");
     sym_encryptionAlgorithm->encrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))sym_encrypt_sp_basic128rsa15;
     sym_encryptionAlgorithm->decrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))sym_decrypt_sp_basic128rsa15;
     sym_encryptionAlgorithm->getLocalKeyLength = sym_getEncryptionKeyLength_sp_basic128rsa15;
     sym_encryptionAlgorithm->getRemoteKeyLength = sym_getEncryptionKeyLength_sp_basic128rsa15;
     sym_encryptionAlgorithm->getLocalBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getEncryptionBlockSize_sp_basic128rsa15;
     sym_encryptionAlgorithm->getRemoteBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getEncryptionBlockSize_sp_basic128rsa15;
     sym_encryptionAlgorithm->getLocalPlainTextBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getPlainTextBlockSize_sp_basic128rsa15;
     sym_encryptionAlgorithm->getRemotePlainTextBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getPlainTextBlockSize_sp_basic128rsa15;
     symmetricModule->secureChannelNonceLength = 16;
 
     // Use the same signature algorithm as the asymmetric component for certificate signing (see standard)
     policy->certificateSigningAlgorithm = policy->asymmetricModule.cryptoModule.signatureAlgorithm;
 
     /* ChannelModule */
     channelModule->newContext = channelContext_newContext_sp_basic128rsa15;
     channelModule->deleteContext = (void (*)(void *))
         channelContext_deleteContext_sp_basic128rsa15;
 
     channelModule->setLocalSymEncryptingKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setLocalSymEncryptingKey_sp_basic128rsa15;
     channelModule->setLocalSymSigningKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setLocalSymSigningKey_sp_basic128rsa15;
     channelModule->setLocalSymIv = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setLocalSymIv_sp_basic128rsa15;
 
     channelModule->setRemoteSymEncryptingKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setRemoteSymEncryptingKey_sp_basic128rsa15;
     channelModule->setRemoteSymSigningKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setRemoteSymSigningKey_sp_basic128rsa15;
     channelModule->setRemoteSymIv = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setRemoteSymIv_sp_basic128rsa15;
 
     channelModule->compareCertificate = (UA_StatusCode (*)(const void *, const UA_ByteString *))
         channelContext_compareCertificate_sp_basic128rsa15;
 
     policy->updateCertificateAndPrivateKey = updateCertificateAndPrivateKey_sp_basic128rsa15;
     policy->clear = clear_sp_basic128rsa15;
 
     UA_StatusCode res = policyContext_newContext_sp_basic128rsa15(policy, localPrivateKey);
     if(res != UA_STATUSCODE_GOOD)
         clear_sp_basic128rsa15(policy);
 
     return res;
 }
 
 #endif
diff --git a/plugins/securityPolicies/ua_securitypolicy_basic256.c b/plugins/securityPolicies/ua_securitypolicy_basic256.c
index f456718a8..89d481fe0 100755
--- a/plugins/securityPolicies/ua_securitypolicy_basic256.c
+++ b/plugins/securityPolicies/ua_securitypolicy_basic256.c
@@ -1,42 +1,43 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  *
  *    Copyright 2018 (c) Mark Giraud, Fraunhofer IOSB
  *    Copyright 2018 (c) Daniel Feist, Precitec GmbH & Co. KG
  *    Copyright 2019 (c) Kalycito Infotech Private Limited
  *    Copyright 2020 (c) Wind River Systems, Inc.
+ *    Copyright 2020 (c) basysKom GmbH
  *
  */
 
 #include <open62541/plugin/securitypolicy.h>
 #include <open62541/plugin/pki.h>
 #include <open62541/types.h>
 #include <open62541/util.h>
 
 #ifdef UA_ENABLE_ENCRYPTION_MBEDTLS
 
 #include <open62541/plugin/securitypolicy_default.h>
 #include "securitypolicy_mbedtls_common.h"
 
 #include <mbedtls/aes.h>
 #include <mbedtls/entropy.h>
 #include <mbedtls/entropy_poll.h>
 #include <mbedtls/error.h>
 #include <mbedtls/sha1.h>
 #include <mbedtls/version.h>
 
 /* Notes:
  * mbedTLS' AES allows in-place encryption and decryption. Sow we don't have to
  * allocate temp buffers.
  * https://tls.mbed.org/discussions/generic/in-place-decryption-with-aes256-same-input-output-buffer
  */
 
 #define UA_SECURITYPOLICY_BASIC256SHA1_RSAPADDING_LEN 42
 #define UA_SHA1_LENGTH 20
 #define UA_BASIC256_SYM_SIGNING_KEY_LENGTH 24
 #define UA_SECURITYPOLICY_BASIC256_SYM_KEY_LENGTH 32
 #define UA_SECURITYPOLICY_BASIC256_SYM_ENCRYPTION_BLOCK_SIZE 16
 #define UA_SECURITYPOLICY_BASIC256_SYM_PLAIN_TEXT_BLOCK_SIZE 16
 #define UA_SECURITYPOLICY_BASIC256_MINASYMKEYLENGTH 128
 #define UA_SECURITYPOLICY_BASIC256_MAXASYMKEYLENGTH 512
@@ -562,48 +563,45 @@ static UA_StatusCode
 updateCertificateAndPrivateKey_sp_basic256(UA_SecurityPolicy *securityPolicy,
                                            const UA_ByteString newCertificate,
                                            const UA_ByteString newPrivateKey) {
     if(securityPolicy == NULL)
         return UA_STATUSCODE_BADINTERNALERROR;
 
     if(securityPolicy->policyContext == NULL)
         return UA_STATUSCODE_BADINTERNALERROR;
 
     Basic256_PolicyContext *pc = (Basic256_PolicyContext *)
         securityPolicy->policyContext;
 
     UA_ByteString_deleteMembers(&securityPolicy->localCertificate);
 
-    UA_StatusCode retval = UA_ByteString_allocBuffer(&securityPolicy->localCertificate,
-                                                     newCertificate.length + 1);
-    if(retval != UA_STATUSCODE_GOOD)
+    UA_StatusCode retval = UA_mbedTLS_LoadLocalCertificate(&newCertificate, &securityPolicy->localCertificate);
+
+    if (retval != UA_STATUSCODE_GOOD)
         return retval;
-    memcpy(securityPolicy->localCertificate.data, newCertificate.data, newCertificate.length);
-    securityPolicy->localCertificate.data[newCertificate.length] = '\0';
-    securityPolicy->localCertificate.length--;
 
     /* Set the new private key */
     mbedtls_pk_free(&pc->localPrivateKey);
     mbedtls_pk_init(&pc->localPrivateKey);
     int mbedErr = mbedtls_pk_parse_key(&pc->localPrivateKey,
                                        newPrivateKey.data, newPrivateKey.length,
                                        NULL, 0);
     if(mbedErr) {
         retval = UA_STATUSCODE_BADSECURITYCHECKSFAILED;
         goto error;
     }
 
     retval = asym_makeThumbprint_sp_basic256(securityPolicy,
                                              &securityPolicy->localCertificate,
                                              &pc->localCertThumbprint);
     if(retval != UA_STATUSCODE_GOOD)
         goto error;
 
     return retval;
 
     error:
     UA_LOG_ERROR(securityPolicy->logger, UA_LOGCATEGORY_SECURITYPOLICY,
                  "Could not update certificate and private key");
     if(securityPolicy->policyContext != NULL)
         clear_sp_basic256(securityPolicy);
     return retval;
 }
@@ -695,139 +693,135 @@ UA_StatusCode
 UA_SecurityPolicy_Basic256(UA_SecurityPolicy *policy, const UA_ByteString localCertificate,
                            const UA_ByteString localPrivateKey, const UA_Logger *logger) {
     memset(policy, 0, sizeof(UA_SecurityPolicy));
     policy->logger = logger;
 
     policy->policyUri = UA_STRING("http://opcfoundation.org/UA/SecurityPolicy#Basic256\0");
 
     UA_SecurityPolicyAsymmetricModule *const asymmetricModule = &policy->asymmetricModule;
     UA_SecurityPolicySymmetricModule *const symmetricModule = &policy->symmetricModule;
     UA_SecurityPolicyChannelModule *const channelModule = &policy->channelModule;
 
-    /* Copy the certificate and add a NULL to the end */
-    UA_StatusCode retval =
-        UA_ByteString_allocBuffer(&policy->localCertificate, localCertificate.length + 1);
-    if(retval != UA_STATUSCODE_GOOD)
+    UA_StatusCode retval = UA_mbedTLS_LoadLocalCertificate(&localCertificate, &policy->localCertificate);
+
+    if (retval != UA_STATUSCODE_GOOD)
         return retval;
-    memcpy(policy->localCertificate.data, localCertificate.data, localCertificate.length);
-    policy->localCertificate.data[localCertificate.length] = '\0';
-    policy->localCertificate.length--;
 
     /* AsymmetricModule */
     UA_SecurityPolicySignatureAlgorithm *asym_signatureAlgorithm =
         &asymmetricModule->cryptoModule.signatureAlgorithm;
     asym_signatureAlgorithm->uri =
         UA_STRING("http://www.w3.org/2000/09/xmldsig#rsa-sha1\0");
     asym_signatureAlgorithm->verify =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *,
                            const UA_ByteString *, const UA_ByteString *))asym_verify_sp_basic256;
     asym_signatureAlgorithm->sign =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *,
                            const UA_ByteString *, UA_ByteString *))asym_sign_sp_basic256;
     asym_signatureAlgorithm->getLocalSignatureSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getLocalSignatureSize_sp_basic256;
     asym_signatureAlgorithm->getRemoteSignatureSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getRemoteSignatureSize_sp_basic256;
     asym_signatureAlgorithm->getLocalKeyLength = NULL; // TODO: Write function
     asym_signatureAlgorithm->getRemoteKeyLength = NULL; // TODO: Write function
 
     UA_SecurityPolicyEncryptionAlgorithm *asym_encryptionAlgorithm =
         &asymmetricModule->cryptoModule.encryptionAlgorithm;
     asym_encryptionAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#rsa-oaep\0");
     asym_encryptionAlgorithm->encrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))asym_encrypt_sp_basic256;
     asym_encryptionAlgorithm->decrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))
             asym_decrypt_sp_basic256;
     asym_encryptionAlgorithm->getLocalKeyLength =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getLocalEncryptionKeyLength_sp_basic256;
     asym_encryptionAlgorithm->getRemoteKeyLength =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getRemoteEncryptionKeyLength_sp_basic256;
     asym_encryptionAlgorithm->getLocalBlockSize = NULL; // TODO: Write function
     asym_encryptionAlgorithm->getRemoteBlockSize = (size_t (*)(const UA_SecurityPolicy *,
                                                                const void *))asym_getRemoteBlockSize_sp_basic256;
     asym_encryptionAlgorithm->getLocalPlainTextBlockSize = NULL; // TODO: Write function
     asym_encryptionAlgorithm->getRemotePlainTextBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getRemotePlainTextBlockSize_sp_basic256;
 
     asymmetricModule->makeCertificateThumbprint = asym_makeThumbprint_sp_basic256;
     asymmetricModule->compareCertificateThumbprint =
         asymmetricModule_compareCertificateThumbprint_sp_basic256;
 
     /* SymmetricModule */
     symmetricModule->generateKey = sym_generateKey_sp_basic256;
     symmetricModule->generateNonce = sym_generateNonce_sp_basic256;
 
     UA_SecurityPolicySignatureAlgorithm *sym_signatureAlgorithm =
         &symmetricModule->cryptoModule.signatureAlgorithm;
     sym_signatureAlgorithm->uri =
         UA_STRING("http://www.w3.org/2000/09/xmldsig#hmac-sha1\0");
     sym_signatureAlgorithm->verify =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *, const UA_ByteString *,
                            const UA_ByteString *))sym_verify_sp_basic256;
     sym_signatureAlgorithm->sign =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *,
                            const UA_ByteString *, UA_ByteString *))sym_sign_sp_basic256;
     sym_signatureAlgorithm->getLocalSignatureSize = sym_getSignatureSize_sp_basic256;
     sym_signatureAlgorithm->getRemoteSignatureSize = sym_getSignatureSize_sp_basic256;
     sym_signatureAlgorithm->getLocalKeyLength =
         (size_t (*)(const UA_SecurityPolicy *,
                     const void *))sym_getSigningKeyLength_sp_basic256;
     sym_signatureAlgorithm->getRemoteKeyLength =
         (size_t (*)(const UA_SecurityPolicy *,
                     const void *))sym_getSigningKeyLength_sp_basic256;
 
     UA_SecurityPolicyEncryptionAlgorithm *sym_encryptionAlgorithm =
         &symmetricModule->cryptoModule.encryptionAlgorithm;
     sym_encryptionAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#aes256-cbc\0");
     sym_encryptionAlgorithm->encrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))sym_encrypt_sp_basic256;
     sym_encryptionAlgorithm->decrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))sym_decrypt_sp_basic256;
     sym_encryptionAlgorithm->getLocalKeyLength = sym_getEncryptionKeyLength_sp_basic256;
     sym_encryptionAlgorithm->getRemoteKeyLength = sym_getEncryptionKeyLength_sp_basic256;
     sym_encryptionAlgorithm->getLocalBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getEncryptionBlockSize_sp_basic256;
     sym_encryptionAlgorithm->getRemoteBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getEncryptionBlockSize_sp_basic256;
     sym_encryptionAlgorithm->getLocalPlainTextBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getPlainTextBlockSize_sp_basic256;
     sym_encryptionAlgorithm->getRemotePlainTextBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getPlainTextBlockSize_sp_basic256;
     symmetricModule->secureChannelNonceLength = 32;
 
     // Use the same signature algorithm as the asymmetric component for certificate signing (see standard)
     policy->certificateSigningAlgorithm = policy->asymmetricModule.cryptoModule.signatureAlgorithm;
 
     /* ChannelModule */
     channelModule->newContext = channelContext_newContext_sp_basic256;
     channelModule->deleteContext = (void (*)(void *))
         channelContext_deleteContext_sp_basic256;
 
     channelModule->setLocalSymEncryptingKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setLocalSymEncryptingKey_sp_basic256;
     channelModule->setLocalSymSigningKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setLocalSymSigningKey_sp_basic256;
     channelModule->setLocalSymIv = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setLocalSymIv_sp_basic256;
 
     channelModule->setRemoteSymEncryptingKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setRemoteSymEncryptingKey_sp_basic256;
     channelModule->setRemoteSymSigningKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setRemoteSymSigningKey_sp_basic256;
     channelModule->setRemoteSymIv = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setRemoteSymIv_sp_basic256;
 
     channelModule->compareCertificate = (UA_StatusCode (*)(const void *, const UA_ByteString *))
         channelContext_compareCertificate_sp_basic256;
 
     policy->updateCertificateAndPrivateKey = updateCertificateAndPrivateKey_sp_basic256;
     policy->clear = clear_sp_basic256;
 
     UA_StatusCode res = policyContext_newContext_sp_basic256(policy, localPrivateKey);
     if(res != UA_STATUSCODE_GOOD)
         clear_sp_basic256(policy);
 
     return res;
 }
 
 #endif
diff --git a/plugins/securityPolicies/ua_securitypolicy_basic256sha256.c b/plugins/securityPolicies/ua_securitypolicy_basic256sha256.c
index 7f40e7206..3757791ae 100755
--- a/plugins/securityPolicies/ua_securitypolicy_basic256sha256.c
+++ b/plugins/securityPolicies/ua_securitypolicy_basic256sha256.c
@@ -1,43 +1,44 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/.
  *
  *    Copyright 2018 (c) Mark Giraud, Fraunhofer IOSB
  *    Copyright 2018 (c) Daniel Feist, Precitec GmbH & Co. KG
  *    Copyright 2018 (c) HMS Industrial Networks AB (Author: Jonas Green)
  *    Copyright 2020 (c) Wind River Systems, Inc.
+ *    Copyright 2020 (c) basysKom GmbH
  */
 
 #include <open62541/plugin/securitypolicy_default.h>
 #include <open62541/util.h>
 
 #ifdef UA_ENABLE_ENCRYPTION_MBEDTLS
 
 #include "securitypolicy_mbedtls_common.h"
 
 #include <mbedtls/aes.h>
 #include <mbedtls/ctr_drbg.h>
 #include <mbedtls/entropy.h>
 #include <mbedtls/entropy_poll.h>
 #include <mbedtls/error.h>
 #include <mbedtls/md.h>
 #include <mbedtls/sha1.h>
 #include <mbedtls/sha256.h>
 #include <mbedtls/version.h>
 #include <mbedtls/x509_crt.h>
 
 /* Notes:
  * mbedTLS' AES allows in-place encryption and decryption. Sow we don't have to
  * allocate temp buffers.
  * https://tls.mbed.org/discussions/generic/in-place-decryption-with-aes256-same-input-output-buffer
  */
 
 #define UA_SECURITYPOLICY_BASIC256SHA256_RSAPADDING_LEN 42
 #define UA_SHA1_LENGTH 20
 #define UA_SHA256_LENGTH 32
 #define UA_BASIC256SHA256_SYM_SIGNING_KEY_LENGTH 32
 #define UA_SECURITYPOLICY_BASIC256SHA256_SYM_KEY_LENGTH 32
 #define UA_SECURITYPOLICY_BASIC256SHA256_SYM_ENCRYPTION_BLOCK_SIZE 16
 #define UA_SECURITYPOLICY_BASIC256SHA256_SYM_PLAIN_TEXT_BLOCK_SIZE 16
 #define UA_SECURITYPOLICY_BASIC256SHA256_MINASYMKEYLENGTH 256
 #define UA_SECURITYPOLICY_BASIC256SHA256_MAXASYMKEYLENGTH 512
@@ -605,47 +606,44 @@ static UA_StatusCode
 updateCertificateAndPrivateKey_sp_basic256sha256(UA_SecurityPolicy *securityPolicy,
                                                  const UA_ByteString newCertificate,
                                                  const UA_ByteString newPrivateKey) {
     if(securityPolicy == NULL)
         return UA_STATUSCODE_BADINTERNALERROR;
 
     if(securityPolicy->policyContext == NULL)
         return UA_STATUSCODE_BADINTERNALERROR;
 
     Basic256Sha256_PolicyContext *pc =
             (Basic256Sha256_PolicyContext *) securityPolicy->policyContext;
 
     UA_ByteString_deleteMembers(&securityPolicy->localCertificate);
 
-    UA_StatusCode retval = UA_ByteString_allocBuffer(&securityPolicy->localCertificate,
-                                                     newCertificate.length + 1);
-    if(retval != UA_STATUSCODE_GOOD)
+    UA_StatusCode retval = UA_mbedTLS_LoadLocalCertificate(&newCertificate, &securityPolicy->localCertificate);
+
+    if (retval != UA_STATUSCODE_GOOD)
         return retval;
-    memcpy(securityPolicy->localCertificate.data, newCertificate.data, newCertificate.length);
-    securityPolicy->localCertificate.data[newCertificate.length] = '\0';
-    securityPolicy->localCertificate.length--;
 
     /* Set the new private key */
     mbedtls_pk_free(&pc->localPrivateKey);
     mbedtls_pk_init(&pc->localPrivateKey);
     int mbedErr = mbedtls_pk_parse_key(&pc->localPrivateKey, newPrivateKey.data,
                                        newPrivateKey.length, NULL, 0);
     if(mbedErr) {
         retval = UA_STATUSCODE_BADSECURITYCHECKSFAILED;
         goto error;
     }
 
     retval = asym_makeThumbprint_sp_basic256sha256(securityPolicy,
                                                    &securityPolicy->localCertificate,
                                                    &pc->localCertThumbprint);
     if(retval != UA_STATUSCODE_GOOD)
         goto error;
 
     return retval;
 
     error:
     UA_LOG_ERROR(securityPolicy->logger, UA_LOGCATEGORY_SECURITYPOLICY,
                  "Could not update certificate and private key");
     if(securityPolicy->policyContext != NULL)
         clear_sp_basic256sha256(securityPolicy);
     return retval;
 }
@@ -737,139 +735,135 @@ UA_StatusCode
 UA_SecurityPolicy_Basic256Sha256(UA_SecurityPolicy *policy, const UA_ByteString localCertificate,
                                  const UA_ByteString localPrivateKey, const UA_Logger *logger) {
     memset(policy, 0, sizeof(UA_SecurityPolicy));
     policy->logger = logger;
 
     policy->policyUri = UA_STRING("http://opcfoundation.org/UA/SecurityPolicy#Basic256Sha256");
 
     UA_SecurityPolicyAsymmetricModule *const asymmetricModule = &policy->asymmetricModule;
     UA_SecurityPolicySymmetricModule *const symmetricModule = &policy->symmetricModule;
     UA_SecurityPolicyChannelModule *const channelModule = &policy->channelModule;
 
-    /* Copy the certificate and add a NULL to the end */
-    UA_StatusCode retval =
-        UA_ByteString_allocBuffer(&policy->localCertificate, localCertificate.length + 1);
-    if(retval != UA_STATUSCODE_GOOD)
+    UA_StatusCode retval = UA_mbedTLS_LoadLocalCertificate(&localCertificate, &policy->localCertificate);
+
+    if (retval != UA_STATUSCODE_GOOD)
         return retval;
-    memcpy(policy->localCertificate.data, localCertificate.data, localCertificate.length);
-    policy->localCertificate.data[localCertificate.length] = '\0';
-    policy->localCertificate.length--;
 
     /* AsymmetricModule */
     UA_SecurityPolicySignatureAlgorithm *asym_signatureAlgorithm =
         &asymmetricModule->cryptoModule.signatureAlgorithm;
     asym_signatureAlgorithm->uri =
         UA_STRING("http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\0");
     asym_signatureAlgorithm->verify =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *,
                            const UA_ByteString *, const UA_ByteString *))asym_verify_sp_basic256sha256;
     asym_signatureAlgorithm->sign =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *,
                            const UA_ByteString *, UA_ByteString *))asym_sign_sp_basic256sha256;
     asym_signatureAlgorithm->getLocalSignatureSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getLocalSignatureSize_sp_basic256sha256;
     asym_signatureAlgorithm->getRemoteSignatureSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getRemoteSignatureSize_sp_basic256sha256;
     asym_signatureAlgorithm->getLocalKeyLength = NULL; // TODO: Write function
     asym_signatureAlgorithm->getRemoteKeyLength = NULL; // TODO: Write function
 
     UA_SecurityPolicyEncryptionAlgorithm *asym_encryptionAlgorithm =
         &asymmetricModule->cryptoModule.encryptionAlgorithm;
     asym_encryptionAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#rsa-oaep\0");
     asym_encryptionAlgorithm->encrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))asym_encrypt_sp_basic256sha256;
     asym_encryptionAlgorithm->decrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))
             asym_decrypt_sp_basic256sha256;
     asym_encryptionAlgorithm->getLocalKeyLength =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getLocalEncryptionKeyLength_sp_basic256sha256;
     asym_encryptionAlgorithm->getRemoteKeyLength =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getRemoteEncryptionKeyLength_sp_basic256sha256;
     asym_encryptionAlgorithm->getLocalBlockSize = NULL; // TODO: Write function
     asym_encryptionAlgorithm->getRemoteBlockSize = (size_t (*)(const UA_SecurityPolicy *,
                                                                const void *))asym_getRemoteBlockSize_sp_basic256sha256;
     asym_encryptionAlgorithm->getLocalPlainTextBlockSize = NULL; // TODO: Write function
     asym_encryptionAlgorithm->getRemotePlainTextBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))asym_getRemotePlainTextBlockSize_sp_basic256sha256;
 
     asymmetricModule->makeCertificateThumbprint = asym_makeThumbprint_sp_basic256sha256;
     asymmetricModule->compareCertificateThumbprint =
         asymmetricModule_compareCertificateThumbprint_sp_basic256sha256;
 
     /* SymmetricModule */
     symmetricModule->generateKey = sym_generateKey_sp_basic256sha256;
     symmetricModule->generateNonce = sym_generateNonce_sp_basic256sha256;
 
     UA_SecurityPolicySignatureAlgorithm *sym_signatureAlgorithm =
         &symmetricModule->cryptoModule.signatureAlgorithm;
     sym_signatureAlgorithm->uri =
         UA_STRING("http://www.w3.org/2000/09/xmldsig#hmac-sha1\0");
     sym_signatureAlgorithm->verify =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *, const UA_ByteString *,
                            const UA_ByteString *))sym_verify_sp_basic256sha256;
     sym_signatureAlgorithm->sign =
         (UA_StatusCode (*)(const UA_SecurityPolicy *, void *,
                            const UA_ByteString *, UA_ByteString *))sym_sign_sp_basic256sha256;
     sym_signatureAlgorithm->getLocalSignatureSize = sym_getSignatureSize_sp_basic256sha256;
     sym_signatureAlgorithm->getRemoteSignatureSize = sym_getSignatureSize_sp_basic256sha256;
     sym_signatureAlgorithm->getLocalKeyLength =
         (size_t (*)(const UA_SecurityPolicy *,
                     const void *))sym_getSigningKeyLength_sp_basic256sha256;
     sym_signatureAlgorithm->getRemoteKeyLength =
         (size_t (*)(const UA_SecurityPolicy *,
                     const void *))sym_getSigningKeyLength_sp_basic256sha256;
 
     UA_SecurityPolicyEncryptionAlgorithm *sym_encryptionAlgorithm =
         &symmetricModule->cryptoModule.encryptionAlgorithm;
     sym_encryptionAlgorithm->uri = UA_STRING("http://www.w3.org/2001/04/xmlenc#aes128-cbc");
     sym_encryptionAlgorithm->encrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))sym_encrypt_sp_basic256sha256;
     sym_encryptionAlgorithm->decrypt =
         (UA_StatusCode(*)(const UA_SecurityPolicy *, void *, UA_ByteString *))sym_decrypt_sp_basic256sha256;
     sym_encryptionAlgorithm->getLocalKeyLength = sym_getEncryptionKeyLength_sp_basic256sha256;
     sym_encryptionAlgorithm->getRemoteKeyLength = sym_getEncryptionKeyLength_sp_basic256sha256;
     sym_encryptionAlgorithm->getLocalBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getEncryptionBlockSize_sp_basic256sha256;
     sym_encryptionAlgorithm->getRemoteBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getEncryptionBlockSize_sp_basic256sha256;
     sym_encryptionAlgorithm->getLocalPlainTextBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getPlainTextBlockSize_sp_basic256sha256;
     sym_encryptionAlgorithm->getRemotePlainTextBlockSize =
         (size_t (*)(const UA_SecurityPolicy *, const void *))sym_getPlainTextBlockSize_sp_basic256sha256;
     symmetricModule->secureChannelNonceLength = 32;
 
     // Use the same signature algorithm as the asymmetric component for certificate signing (see standard)
     policy->certificateSigningAlgorithm = policy->asymmetricModule.cryptoModule.signatureAlgorithm;
 
     /* ChannelModule */
     channelModule->newContext = channelContext_newContext_sp_basic256sha256;
     channelModule->deleteContext = (void (*)(void *))
         channelContext_deleteContext_sp_basic256sha256;
 
     channelModule->setLocalSymEncryptingKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setLocalSymEncryptingKey_sp_basic256sha256;
     channelModule->setLocalSymSigningKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setLocalSymSigningKey_sp_basic256sha256;
     channelModule->setLocalSymIv = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setLocalSymIv_sp_basic256sha256;
 
     channelModule->setRemoteSymEncryptingKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setRemoteSymEncryptingKey_sp_basic256sha256;
     channelModule->setRemoteSymSigningKey = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setRemoteSymSigningKey_sp_basic256sha256;
     channelModule->setRemoteSymIv = (UA_StatusCode (*)(void *, const UA_ByteString *))
         channelContext_setRemoteSymIv_sp_basic256sha256;
 
     channelModule->compareCertificate = (UA_StatusCode (*)(const void *, const UA_ByteString *))
         channelContext_compareCertificate_sp_basic256sha256;
 
     policy->updateCertificateAndPrivateKey = updateCertificateAndPrivateKey_sp_basic256sha256;
     policy->clear = clear_sp_basic256sha256;
 
     UA_StatusCode res = policyContext_newContext_sp_basic256sha256(policy, localPrivateKey);
     if(res != UA_STATUSCODE_GOOD)
         clear_sp_basic256sha256(policy);
 
     return res;
 }
 
 #endif
